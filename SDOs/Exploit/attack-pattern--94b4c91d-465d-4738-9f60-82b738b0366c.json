{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--94b4c91d-465d-4738-9f60-82b738b0366c",
    "created": "2024-08-14T16:27:56.735792Z",
    "modified": "2024-08-14T16:27:56.735796Z",
    "name": "NFS Mount Scanner",
    "description": " This module scans NFS mounts and their permissions. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/nfs/nfsmount.rb",
            "external_id": "nfsmount.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "1999-0170"
        },
        {
            "source_name": "CVE",
            "external_id": "1999-0554"
        },
        {
            "source_name": "reference",
            "url": "https://www.ietf.org/rfc/rfc1094.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::SunRPC\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Nfs\n\n  def initialize\n    super(\n      'Name' => 'NFS Mount Scanner',\n      'Description' => %q{\n        This module scans NFS mounts and their permissions.\n      },\n      'Author'\t=> ['<tebo[at]attackresearch.com>'],\n      'References' => [\n        ['CVE', '1999-0170'],\n        ['CVE', '1999-0554'],\n        ['URL', 'https://www.ietf.org/rfc/rfc1094.txt']\n      ],\n      'License'\t=> MSF_LICENSE\n    )\n\n    register_options([\n      OptEnum.new('PROTOCOL', [ true, 'The protocol to use', 'udp', ['udp', 'tcp']])\n    ])\n\n    register_advanced_options(\n      [\n        OptBool.new('Mountable', [false, 'Determine if an export is mountable', true]),\n      ]\n    )\n  end\n\n  def run_host(ip)\n    program\t= 100005\n    progver\t= 1\n    procedure\t= 5\n\n    sunrpc_create(datastore['PROTOCOL'], program, progver)\n    sunrpc_authnull\n    resp = sunrpc_call(procedure, '')\n\n    # XXX: Assume that transport is udp and port is 2049\n    # Technically we are talking to mountd not nfsd\n\n    report_service(\n      host: ip,\n      proto: datastore['PROTOCOL'],\n      port: 2049,\n      name: 'nfsd',\n      info: \"NFS Daemon #{program} v#{progver}\"\n    )\n\n    exports = resp[3, 1].unpack('C')[0]\n    if (exports == 0x01)\n      shares = []\n      while Rex::Encoder::XDR.decode_int!(resp) == 1\n        dir = Rex::Encoder::XDR.decode_string!(resp)\n        grp = []\n        grp << Rex::Encoder::XDR.decode_string!(resp) while Rex::Encoder::XDR.decode_int!(resp) == 1\n\n        if can_mount?(grp, datastore['Mountable'], datastore['HOSTNAME'], datastore['LHOST'] || '')\n          print_good(\"#{ip} Mountable NFS Export: #{dir} [#{grp.join(', ')}]\")\n        else\n          print_status(\"#{ip} NFS Export: #{dir} [#{grp.join(', ')}]\")\n        end\n        shares << [dir, grp]\n      end\n      report_note(\n        host: ip,\n        proto: datastore['PROTOCOL'],\n        port: 2049,\n        type: 'nfs.exports',\n        data: { exports: shares },\n        update: :unique_data\n      )\n    elsif (exports == 0x00)\n      vprint_status(\"#{ip} - No exported directories\")\n    end\n\n    sunrpc_destroy\n  rescue ::Rex::Proto::SunRPC::RPCTimeout, ::Rex::Proto::SunRPC::RPCError => e\n    vprint_error(e.to_s)\n  end\nend\n"
}