{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--816a0869-72cd-4fc0-8568-ef68c993852c",
    "created": "2024-08-14T16:31:13.644319Z",
    "modified": "2024-08-14T16:31:13.644323Z",
    "name": "H.323 Version Scanner",
    "description": "Detect H.323 Version.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/h323/h323_version.rb",
            "external_id": "h323_version.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'H.323 Version Scanner',\n      'Description' => 'Detect H.323 Version.',\n      'Author'      => 'hdm',\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        Opt::RPORT(1720),\n      ])\n  end\n\n  def run_host(ip)\n\n    remote_display    = nil\n    remote_product_id = nil\n    remote_version_id = nil\n    remote_vendor_id  = nil\n    remote_protocol   = nil\n\n    begin\n\n    # Wrap this in a timeout to prevent dead services from\n    # hanging this thread.\n    Timeout.timeout( call_timeout) do\n\n    connect\n\n    caller_name = \"SYSTEM\\x00\"\n    h323_id     = Rex::Text.rand_text_alpha(3)\n    vendor_id   = Rex::Text.rand_text_alpha(32)\n    caller_host = Rex::Socket.source_address( ip )\n    caller_port = rand( 32768 ) + 30000\n    callee_host = rhost\n    callee_port = rport\n    conf_guid   = Rex::Text.rand_text(16)\n    call_guid   = Rex::Text.rand_text(16)\n\n    pkt_setup = h323_setup_call({\n      :caller_name => caller_name,\n      :h323_id => h323_id,\n      :vendor_id => vendor_id,\n      :callee_host => callee_host,\n      :callee_port => callee_port,\n      :caller_host => caller_host,\n      :caller_port => caller_port,\n      :conf_guid => conf_guid,\n      :call_guid => call_guid\n    })\n\n    res = sock.put(pkt_setup) rescue nil\n    if not res\n      disconnect\n      return\n    end\n\n    cnt = 0\n    while( true )\n      info = read_packet\n      break if not info\n\n      # The remote side of the call disconnected us\n      break if info[:type] == @@H323_STATUS_RELEASE_COMPLETE\n\n      remote_display     = info[40].strip if info[40]\n      remote_product_id  = info[:product_id].strip if info[:product_id]\n      remote_version_id  = info[:version_id].strip if info[:version_id]\n      remote_protocol    = info[:protocol_version].strip  if info[:protocol_version]\n\n      if info[:vendor_id] and [nil, \"Unknown\"].include?( remote_vendor_id )\n        remote_vendor_id   = info[:vendor_id].strip\n      end\n\n      # Diagnostics\n      # print_status(\"Host: #{rhost}:#{rport} => #{info.inspect}\")\n\n      # The remote side of the call was connected (kill it)\n      break if info[:type] == @@H323_STATUS_CONNECT\n\n      # Exit if we already received 5 packets from the server\n      break if (cnt +=1) > 5\n\n    end\n\n    # Make sure the call was shut down cleanly\n    pkt_release = h323_release_call({\n      :caller_name => caller_name,\n      :call_guid => call_guid\n    })\n    sock.put(pkt_release) rescue nil\n\n    # End timeout block\n    end\n\n    rescue ::Timeout::Error\n    rescue ::Interrupt\n      raise $!\n    rescue ::Rex::ConnectionError, ::IOError, ::Errno::ECONNRESET, ::Errno::ENOPROTOOPT\n    rescue ::Exception\n      print_error(\"#{rhost}:#{rport} #{$!.class} #{$!} #{$!.backtrace}\")\n    ensure\n      disconnect\n    end\n\n    if remote_vendor_id\n      remote_product_id   = remote_product_id.to_s.gsub(/[^\\x20-\\x7e]/, '')\n      remote_version_id   = remote_version_id.to_s.gsub(/[^\\x20-\\x7e]/, '')\n\n      banner = \"Protocol: #{ remote_protocol }  VendorID: #{ remote_vendor_id }  \"\n\n      if remote_version_id and remote_version_id.length > 0\n        banner << \"VersionID: #{ remote_version_id }  \"\n      end\n\n      if remote_product_id and remote_product_id.length > 0\n        banner << \"ProductID: #{ remote_product_id }  \"\n      end\n\n      if remote_display and remote_display.length > 0\n        remote_display = remote_display.to_s.gsub(/[^\\x20-\\x7e]/, '')\n        banner << \"DisplayName: #{ remote_display }\"\n      end\n\n      print_good(\"#{rhost}:#{rport} #{banner}\")\n      report_service(:host => rhost, :port => rport, :name => \"h323\", :info => banner)\n    end\n\n  end\n\n  def read_packet\n    begin\n      ::Timeout.timeout( read_timeout ) do\n        ver = sock.read(2)\n        return if not (ver and ver == \"\\x03\\x00\")\n\n        bin = sock.read(2)\n        return if not bin\n\n        len = [ bin.unpack(\"n\")[0] - 4, 0 ].max\n        return if len == 0\n\n        bin = sock.read(len)\n        return if not bin\n\n        f_desc, cref_len = bin.unpack(\"CC\")\n        cref_val = bin[2, cref_len]\n        f_type = bin[2 + cref_len, 1].unpack(\"C\")[0]\n\n        return { :type => f_type, :call_ref => cref_val }.merge( read_ies(f_type, bin[ 2 + cref_len + 1, bin.length] ) )\n      end\n    rescue ::Timeout::Error\n    end\n    nil\n  end\n\n  def read_ies(mtype, data)\n    r = { }\n    i = 0\n\n    while( i < (data.length - 1) )\n      ie_type = data[i, 1].unpack(\"C\")[0]\n      break if not ie_type\n\n      ie_len  = 0\n      ie_data = \"\"\n\n      case ie_type\n        when @@H225_IE_USER_USER\n          ie_len  = data[i+1, 2].unpack(\"n\")[0]\n          break if not ie_len\n\n          ie_data = data[i+3, ie_len]\n          break if not ie_data\n\n          i = i + 3 + ie_len\n        else\n          ie_len  = data[i+1, 1].unpack(\"C\")[0]\n          break if not ie_len\n\n          ie_data = data[i+2, ie_len]\n          break if not ie_data\n\n          i = i + 2 + ie_len\n      end\n\n      r[ ie_type ] = ie_data\n\n      if ie_type == @@H225_IE_USER_USER\n        r.merge!( ( read_user_user(mtype, ie_data) rescue {} ) )\n      end\n    end\n    r\n  end\n\n\n  # This provides a weak method of decoding USER-USER PDUs. These are\n  # actually PER-encoded ASN.1, but we take a few shortcuts since PER\n  # encoding is such a pain.\n  def read_user_user(mtype, data)\n    r = {}\n\n    # Identify the embedded version (2/3/4/5/6 commonly found)\n    i = data.index(\"\\x00\\x08\\x91\\x4a\\x00\")\n    return r if not i\n\n    # Store the protocol version\n    pver = data[i + 5, 1].unpack(\"C\")[0]\n\n    r[:protocol_version] = pver.to_s\n\n    # Bump the index over the version\n    i+= 6\n\n    # print_line( Rex::Text.to_hex_dump( data[i, 32] ) )\n\n    # Set a placeholder VendorID so this system will be reported\n    r[:vendor_id] = \"Unknown\"\n\n    # We use the version offset to identify the destination block location\n    # This changes slightly based on the type of packet we receive\n    case mtype\n    when @@H323_STATUS_ALERTING, @@H323_STATUS_PROCEEDING\n\n      if pver == 2 and data[i, 2] == \"\\x20\\x00\"\n        r[ :vendor_id ] = \"0x%.8x\" %  ( data[i + 2, 4].unpack(\"N\")[0] rescue 0 )\n        return r\n      end\n\n      # Find the offset to the VendorID\n      if data[i + 1, 1] != \"\\xc0\"\n        i+= 7\n      end\n\n      # Stop processing if we can't identify a VendorID\n      return r if data[i + 1, 1] != \"\\xc0\"\n\n      # Otherwise just add 2 to the offset of the version\n      i += 2\n\n    when @@H323_STATUS_CONNECT\n\n      # Bail early in some corner cases\n      return r if data[i, 1] == \"\\x00\"\n\n      # Find the offset to the VendorID\n      if data[i + 1, 1] != \"\\xc0\"\n        i+= 7\n      end\n\n      # Stop processing if we can't identify a VendorID\n      return r if data[i + 1, 1] != \"\\xc0\"\n\n      i += 2\n\n      return r\n    else\n      return r\n    end\n\n    # Extract the manufacturer ID\n    r[ :vendor_id ] = \"0x%.8x\" %  ( data[i, 4].unpack(\"N\")[0] rescue 0 )\n    i+= 4\n\n    # No Product ID / Version ID in versions less than 3 (unless special cased above)\n    return r if pver < 3\n\n    # Get the product_id length (-1)\n    product_id_length = data[i, 1].unpack(\"C\")[0] + 1\n    i+= 1\n\n    # Extract the product ID\n    r[ :product_id ] = data[i, product_id_length]\n    i+= product_id_length\n\n    # Get the version ID length (-1)\n    version_id_length = data[i, 1].unpack(\"C\")[0] + 1\n    i+= 1\n\n    # Extract the version ID\n    r[ :version_id ] = data[i, version_id_length]\n\n    # Thats it for now\n\n    r\n  end\n\n  def read_timeout\n    10\n  end\n\n  def call_timeout\n    30\n  end\n\n\n  @@H225_IE_BEARER_CAP   = 0x04\n  @@H225_IE_DISPLAY      = 0x28\n  @@H225_IE_USER_USER    = 0x7e  # Yes, really User-user\n\n\n  @@H323_STATUS_ALERTING          = 0x01\n  @@H323_STATUS_PROCEEDING        = 0x02\n  @@H323_STATUS_SETUP             = 0x05\n  @@H323_STATUS_SETUP_ACK         = 0x0D\n  @@H323_STATUS_CONNECT           = 0x07\n  @@H323_STATUS_RELEASE_COMPLETE  = 0x5a\n  @@H323_STATUS_FACILITY          = 0x62\n\n\n  def encap_tpkt(ver,data)\n    [ ver, 0, data.length + 4 ].pack(\"CCn\") + data\n  end\n\n  def encap_q225(desc, cref_value, msg_type, data)\n    [ desc, cref_value.length, cref_value, msg_type].pack(\"CCA*C\") + data\n  end\n\n  def encap_q225_standard(msg_type, data)\n    encap_q225(0x08, [0x733f].pack(\"n\"), msg_type, data)\n  end\n\n  def encap_q225_setup(data)\n    encap_q225_standard(0x05, data)\n  end\n\n  def encap_q225_release(data)\n    encap_q225_standard(0x5a, data)\n  end\n\n  def create_ie_byte(ie_type, data)\n    [ie_type, data.length].pack(\"CC\") + data\n  end\n\n  def create_ie_short(ie_type, data)\n    [ie_type, data.length].pack(\"Cn\") + data\n  end\n\n  def create_ie_bearer_capability(cap = 0x00038893)\n    create_ie_byte( @@H225_IE_BEARER_CAP, [cap].pack(\"N\")[0,3] )\n  end\n\n  def create_ie_display(name = \"DEBUG\\x00\")\n    create_ie_byte( @@H225_IE_DISPLAY, name )\n  end\n\n  def create_ie_user_user(data)\n    create_ie_short( @@H225_IE_USER_USER, data )\n  end\n\n  #\n  # This is ugly. Doing it properly requires a PER capable ASN.1 encoder, which is overkill for this task\n  #\n  def create_user_info(opts = {})\n    h323_id = opts[:h323_id]\n    vendor_id = opts[:vendor_id]\n    callee_host = opts[:callee_host]\n    callee_port = opts[:callee_port]\n    caller_host = opts[:caller_host]\n    caller_port = opts[:caller_port]\n    conf_guid = opts[:conf_guid]\n    call_guid = opts[:call_guid]\n\n    buff = \"\\x05\" # Protocol descriminator: X.208/X.209 coded user information\n\n    buff << \"\\x20\\xa8\\x06\\x00\\x08\\x91\\x4a\\x00\\x06\\x01\\x40\\x02\"\n\n    # H323-ID\n    buff << h323_id.unpack(\"C*\").pack(\"n*\")\n\n    buff << \"\\x22\\xc0\\x09\\x00\\x00\\x3d\\x02\\x00\\x00\\x00\\x21\"\n\n    # VENDOR: 32 + 2 null bytes\n    buff << [vendor_id].pack(\"Z32\") + \"\\x00\\x00\"\n\n    buff << \"\\x00\"\n\n    # Remote IP + Remote Port\n    buff << ( ::Rex::Socket.addr_aton( callee_host ) + [ callee_port.to_i ].pack(\"n\") )\n\n    buff << \"\\x00\"\n\n    # Conference GUID\n    buff << conf_guid\n\n    buff << \"\\x00\\xc5\\x1d\\x80\\x04\\x07\\x00\"\n\n    # Local IP + Port\n    buff << ( ::Rex::Socket.addr_aton( caller_host ) + [ caller_port.to_i ].pack(\"n\") )\n\n    buff << \"\\x11\\x00\"\n\n    # Call GUID\n    buff << call_guid\n\n    buff <<\n      \"\\x82\\x49\\x10\\x47\\x40\\x00\\x00\\x06\\x04\\x01\\x00\\x4c\\x10\\xb5\" +\n      \"\\x00\\x00\\x26\\x25\\x73\\x70\\x65\\x65\\x78\\x20\\x73\\x72\\x3d\\x31\" +\n      \"\\x36\\x30\\x30\\x30\\x3b\\x6d\\x6f\\x64\\x65\\x3d\\x36\\x3b\\x76\\x62\" +\n      \"\\x72\\x3d\\x6f\\x66\\x66\\x3b\\x63\\x6e\\x67\\x3d\\x6f\\x66\\x66\\x80\" +\n      \"\\x12\\x1c\\x40\\x01\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc6\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc7\\x90\\x3c\\x00\\x00\\x64\\x0c\\x10\\xb5\\x00\\x00\\x26\\x25\" +\n      \"\\x73\\x70\\x65\\x65\\x78\\x20\\x73\\x72\\x3d\\x31\\x36\\x30\\x30\\x30\" +\n      \"\\x3b\\x6d\\x6f\\x64\\x65\\x3d\\x36\\x3b\\x76\\x62\\x72\\x3d\\x6f\\x66\" +\n      \"\\x66\\x3b\\x63\\x6e\\x67\\x3d\\x6f\\x66\\x66\\x80\\x0b\\x0d\\x40\\x01\" +\n      \"\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc7\\x48\\x31\\x40\\x00\\x00\\x06\\x04\\x01\\x00\\x4c\\x10\\x09\" +\n      \"\\x00\\x00\\x3d\\x0f\\x53\\x70\\x65\\x65\\x78\\x20\\x62\\x73\\x34\\x20\" +\n      \"\\x57\\x69\\x64\\x65\\x36\\x80\\x12\\x1c\\x40\\x01\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc6\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc7\\xa0\\x26\\x00\\x00\\x65\\x0c\\x10\\x09\\x00\\x00\\x3d\\x0f\" +\n      \"\\x53\\x70\\x65\\x65\\x78\\x20\\x62\\x73\\x34\\x20\\x57\\x69\\x64\\x65\" +\n      \"\\x36\\x80\\x0b\\x0d\\x40\\x01\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc7\\x50\\x1d\\x40\\x00\\x00\\x06\\x04\\x01\\x00\\x4c\\x60\\x13\" +\n      \"\\x80\\x11\\x1c\\x00\\x01\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc6\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc7\\x13\\x00\\x00\\x66\\x0c\\x60\\x13\\x80\\x0b\\x0d\\x00\\x01\" +\n      \"\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc7\\x00\\x1d\\x40\\x00\\x00\\x06\\x04\\x01\\x00\\x4c\\x20\\x13\" +\n      \"\\x80\\x11\\x1c\\x00\\x01\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc6\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc7\\x13\\x00\\x00\\x67\\x0c\\x20\\x13\\x80\\x0b\\x0d\\x00\\x01\" +\n      \"\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc7\\x00\\x23\\x40\\x00\\x00\\x06\\x04\\x01\\x00\\x48\\x78\\x00\" +\n      \"\\x4a\\xff\\x00\\x80\\x01\\x00\\x80\\x11\\x1c\\x00\\x02\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc8\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc9\\x19\\x00\\x00\\x68\\x08\\x78\\x00\\x4a\\xff\\x00\\x80\\x01\" +\n      \"\\x00\\x80\\x0b\\x0d\\x00\\x02\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc9\\x00\\x22\\x40\\x00\\x00\\x06\\x04\\x01\\x00\\x48\\x68\\x4a\" +\n      \"\\xff\\x00\\x80\\x01\\x00\\x80\\x11\\x1c\\x00\\x02\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc8\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc9\\x18\\x00\\x00\\x69\\x08\\x68\\x4a\\xff\\x00\\x80\\x01\\x00\" +\n      \"\\x80\\x0b\\x0d\\x00\\x02\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc9\\x00\\x22\\x40\\x00\\x00\\x06\\x04\\x01\\x00\\x48\\x70\\x4a\" +\n      \"\\xff\\x00\\x80\\x01\\x00\\x80\\x11\\x1c\\x00\\x02\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc8\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc9\\x18\\x00\\x00\\x6a\\x08\\x70\\x4a\\xff\\x00\\x80\\x01\\x00\" +\n      \"\\x80\\x0b\\x0d\\x00\\x02\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc9\\x00\\x2c\\x40\\x00\\x00\\x06\\x04\\x01\\x00\\x48\\xee\\x00\" +\n      \"\\x00\\x20\\x9f\\xff\\x20\\x50\\x40\\x01\\x00\\x80\\x17\\x1c\\x20\\x02\" +\n      \"\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc8\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc9\\x80\\x04\\x48\\x08\\x8d\\x44\\x22\\x00\\x00\\x6b\\x08\\xee\" +\n      \"\\x00\\x00\\x20\\x9f\\xff\\x20\\x50\\x40\\x01\\x00\\x80\\x11\\x0d\\x20\" +\n      \"\\x02\\x00\" +\n\n      Rex::Socket.addr_aton( caller_host ) +\n\n      \"\\x13\\xc9\\x40\\x00\\x04\\x48\\x08\\x8d\\x44\\x01\\x00\\x01\\x00\\x01\" +\n      \"\\x00\\x01\\x00\\x80\\xfa\\x02\\x80\\xef\\x02\\x70\\x01\\x06\\x00\\x08\" +\n      \"\\x81\\x75\\x00\\x0d\\x80\\x1a\\x80\\x01\\xf4\\x00\\x01\\x00\\x00\\x01\" +\n      \"\\x00\\x00\\x01\\x00\\x04\\x02\\x05\\x00\\x48\\x08\\x8d\\x44\\x06\\x60\" +\n      \"\\x01\\x00\\x01\\x80\\x0b\\x80\\x00\\x00\\x20\\x20\\xb5\\x00\\x00\\x26\" +\n      \"\\x25\\x73\\x70\\x65\\x65\\x78\\x20\\x73\\x72\\x3d\\x31\\x36\\x30\\x30\" +\n      \"\\x30\\x3b\\x6d\\x6f\\x64\\x65\\x3d\\x36\\x3b\\x76\\x62\\x72\\x3d\\x6f\" +\n      \"\\x66\\x66\\x3b\\x63\\x6e\\x67\\x3d\\x6f\\x66\\x66\\x80\\x00\\x01\\x20\" +\n      \"\\x20\\x09\\x00\\x00\\x3d\\x0f\\x53\\x70\\x65\\x65\\x78\\x20\\x62\\x73\" +\n      \"\\x34\\x20\\x57\\x69\\x64\\x65\\x36\\x80\\x00\\x02\\x20\\xc0\\xef\\x80\" +\n      \"\\x00\\x03\\x20\\x40\\xef\\x80\\x00\\x04\\x08\\xf0\\x00\\x4a\\xff\\x00\" +\n      \"\\x80\\x01\\x00\\x80\\x00\\x05\\x08\\xd0\\x4a\\xff\\x00\\x80\\x01\\x00\" +\n      \"\\x80\\x00\\x06\\x08\\xe0\\x4a\\xff\\x00\\x80\\x01\\x00\\x80\\x00\\x07\" +\n      \"\\x09\\xdc\\x00\\x00\\x40\\x9f\\xff\\x20\\x50\\x40\\x01\\x00\\x80\\x00\" +\n      \"\\x08\\x83\\x01\\x50\\x80\\x00\\x09\\x83\\x01\\x10\\x80\\x00\\x0a\\x83\" +\n      \"\\x01\\x40\\x80\\x00\\x0b\\x8a\\x0c\\x14\\x0a\\x30\\x2d\\x31\\x36\\x2c\" +\n      \"\\x33\\x32\\x2c\\x33\\x36\\x00\\x80\\x01\\x03\\x03\\x00\\x00\\x00\\x01\" +\n      \"\\x00\\x02\\x00\\x03\\x03\\x00\\x04\\x00\\x05\\x00\\x06\\x00\\x07\\x00\" +\n      \"\\x00\\x08\\x02\\x00\\x09\\x00\\x0a\\x00\\x0b\\x07\\x01\\x00\\x32\\x80\" +\n      \"\\x96\\x61\\x41\\x02\\x80\\x01\\x80\"\n\n    buff\n  end\n\n  def create_user_release_info(call_guid)\n    \"\\x05\" +\n    \"\\x25\\x80\\x06\\x00\\x08\\x91\\x4a\\x00\\x05\\x01\\x11\\x00\" +\n    call_guid +\n    \"\\x02\\x80\\x01\\x00\"\n  end\n\n  def h323_release_call(opts = {})\n    caller_name = opts[:caller_name]\n    call_guid = opts[:call_guid]\n\n    encap_tpkt(3,\n      encap_q225_release(\n        create_ie_display(caller_name) +\n        create_ie_user_user(\n          create_user_release_info(call_guid )\n        )\n      )\n    )\n  end\n\n  def h323_setup_call(opts = {})\n    caller_name = opts[:caller_name]\n    h323_id = opts[:h323_id]\n    vendor_id = opts[:vendor_id]\n    callee_host = opts[:callee_host]\n    callee_port = opts[:callee_port]\n    caller_host = opts[:caller_host]\n    caller_port = opts[:caller_port]\n    conf_guid = opts[:conf_guid]\n    call_guid = opts[:call_guid]\n\n    encap_tpkt(3,\n      encap_q225_setup(\n        create_ie_bearer_capability() +\n        create_ie_display(caller_name) +\n        create_ie_user_user(\n          create_user_info({\n            :h323_id => h323_id,\n            :vendor_id => vendor_id,\n            :callee_host => callee_host,\n            :callee_port => callee_port,\n            :caller_host => caller_host,\n            :caller_port => caller_port,\n            :conf_guid => conf_guid,\n            :call_guid => call_guid\n          })\n        )\n      )\n    )\n  end\nend\n"
}