{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--675cb6cc-b9d2-45dc-855b-5a878c237bbc",
    "created": "2024-08-14T16:32:59.446513Z",
    "modified": "2024-08-14T16:32:59.446517Z",
    "name": "Module to Probe Different Data Points in a CAN Packet",
    "description": " Scans between two CAN IDs and writes data at each byte position. It will either write a set byte value (Default 0xFF) or iterate through all possible values of that byte position (takes much longer). Does not check for responses and is basically a simple blind fuzzer.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/hardware/automotive/canprobe.rb",
            "external_id": "canprobe.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Module to Probe Different Data Points in a CAN Packet',\n        'Description' => %q{\n          Scans between two CAN IDs and writes data at each byte position. It will\n          either write a set byte value (Default 0xFF) or iterate through all possible values\n          of that byte position (takes much longer). Does not check for responses and is\n          basically a simple blind fuzzer.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['Craig Smith'],\n        'Platform' => ['hardware'],\n        'SessionTypes' => ['hwbridge']\n      )\n    )\n    register_options([\n      OptInt.new('STARTID', [false, 'CAN ID to start scan', 0x300]),\n      OptInt.new('STOPID', [false, 'CAN ID to stop scan', nil]),\n      OptInt.new('PROBEVALUE', [false, 'Value to inject in the data stream', 0xFF]),\n      OptInt.new('PADDING', [false, 'If a value is given a full 8 bytes will be used and padded with this value', nil]),\n      OptBool.new('FUZZ', [false, 'If true interates through all possible values for each data position', false]),\n      OptString.new('CANBUS', [false, 'CAN Bus to perform scan on, defaults to connected bus', nil])\n    ])\n  end\n\n  def run\n    unless client.automotive\n      print_error('The hwbridge requires a functional automotive extention')\n      return\n    end\n    stopid = datastore['STARTID']\n    stopid = datastore['STOPID'] unless datastore['STOPID'].nil?\n    data = '%02X' % datastore['PROBEVALUE']\n    (datastore['STARTID']..stopid).each do |id|\n      print_status(\"Probing 0x#{id.to_s(16)}...\")\n      8.times do |pos|\n        padding = '00' * pos\n        endpadding = ''\n        endpadding = ('%02X' % datastore['PADDING']) * (7 - pos) if !datastore['PADDING'].nil?\n        if datastore['FUZZ']\n          256.times do |fuzzdata|\n            client.automotive.cansend(datastore['CANBUS'], id.to_s(16), padding + ('%02X' % fuzzdata) + endpadding)\n          end\n        else\n          client.automotive.cansend(datastore['CANBUS'], id.to_s(16), padding + data + endpadding)\n        end\n      end\n    end\n    print_status('Probe Complete')\n  end\nend\n",
    "x_mitre_platforms": [
        "['hardware']"
    ]
}