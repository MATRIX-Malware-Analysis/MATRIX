{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f17608b3-c2a5-4417-88b5-1b351720127a",
    "created": "2024-08-14T16:21:55.034138Z",
    "modified": "2024-08-14T16:21:55.034142Z",
    "name": "Hardware Bridge Server",
    "description": " This module sets up a web server to bridge communications between Metasploit and physically attached hardware. Currently this module supports: automotive ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/local_hwbridge.rb",
            "external_id": "local_hwbridge.rb"
        }
    ],
    "x_code_snippet": "##\n#\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n#\n# TODO: SSL Support, Authentication, Listen to localhost only by default\n#\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Auxiliary::Report\n\n  HWBRIDGE_API_VERSION = \"0.0.4\"\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Hardware Bridge Server',\n      'Description' => %q{\n          This module sets up a web server to bridge communications between\n        Metasploit and physically attached hardware.\n        Currently this module supports: automotive\n      },\n      'Author'      => [ 'Craig Smith' ],\n      'License'     => MSF_LICENSE,\n      'Actions'     =>\n        [\n          [ 'WebServer', 'Description' => 'Run HWBridge web server' ]\n        ],\n      'PassiveActions' =>\n        [\n          'WebServer'\n        ],\n      'DefaultAction'  => 'WebServer'))\n\n    @operational_status = 0   # 0=unk, 1=connected, 2=not connected\n    @last_errors = {}\n    @server_started = Time.new\n    @can_interfaces = []\n    @pkt_response = {}  # Candump returned packets\n    @packets_sent = 0\n    @last_sent = nil\n  end\n\n  def detect_can\n    @can_interfaces = []\n    Socket.getifaddrs.each do |i|\n      if i.name =~ /^can\\d+$/ || i.name =~ /^vcan\\d+$/ || i.name =~ /^slcan\\d+$/\n        @can_interfaces << i.name\n      end\n    end\n  end\n\n  def get_status\n    status = {}\n    status[\"operational\"] = @operational_status\n    status[\"hw_specialty\"] = {}\n    status[\"hw_capabilities\"] = {}\n    status[\"last_10_errors\"] = @last_errors # NOTE: no support for this yet\n    status[\"api_version\"] = HWBRIDGE_API_VERSION\n    status[\"fw_version\"] = \"not supported\"\n    status[\"hw_version\"] = \"not supported\"\n    unless @can_interfaces.empty?\n      status[\"hw_specialty\"][\"automotive\"] = true\n      status[\"hw_capabilities\"][\"can\"] = true\n    end\n    status[\"hw_capabilities\"][\"custom_methods\"] = true # To test custom methods\n    status\n  end\n\n  def get_statistics\n    stats = {}\n    stats[\"uptime\"] = Time.now - @server_started\n    stats[\"packet_stats\"] = @packets_sent\n    stats[\"last_request\"] = @last_sent if @last_sent\n    stats[\"voltage\"] = \"not supported\"\n    stats\n  end\n\n  def get_datetime\n    { \"system_datetime\" => Time.now }\n  end\n\n  def get_timezone\n    { \"system_timezone\" => Time.now.getlocal.zone }\n  end\n\n  def get_ip_config\n  end\n\n  #\n  # Stub fucntion to test custom methods\n  # Defines a method \"sample_cmd\" with one argument \"data\" which is required\n  #\n  def get_custom_methods\n    m = {}\n    m[\"Methods\"] = []\n    meth = { \"method_name\" => \"custom/sample_cmd\", \"method_desc\" => \"Sample HW test command\", \"args\" => [] }\n    arg = { \"arg_name\" => \"data\", \"arg_type\" => \"string\", \"required\" => true }\n    meth[\"args\"] << arg\n    meth[\"return\"] = \"string\"\n    m[\"Methods\"] << meth\n    m\n  end\n\n  def get_auto_supported_buses\n    detect_can()\n    buses = []\n    @can_interfaces.each do |can|\n      buses << { \"bus_name\" => can }\n    end\n    buses\n  end\n\n  # Sends a raw CAN packet\n  # bus = string\n  # id = hex ID\n  # data = string of up to 8 hex bytes\n  def cansend(bus, id, data)\n    result = {}\n    result[\"Success\"] = false\n    id = id.to_i(16).to_s(16)  # Clean up the HEX\n    bytes = data.scan(/../)  # Break up data string into 2 char (byte) chunks\n    if bytes.size > 8\n      print_error(\"Data section can only contain a max of 8 bytes\")\n      return result\n    end\n    `which cansend`\n    unless $?.success?\n      print_error(\"cansend from can-utils not found in path\")\n      return result\n    end\n    @can_interfaces.each do |can|\n      if can == bus\n        system(\"cansend #{bus} #{id}##{bytes.join}\")\n        @packets_sent += 1\n        @last_sent = Time.now.to_i\n        result[\"Success\"] = true if $?.success?\n      end\n    end\n    result\n  end\n\n  # Converts candump output to {Packets => [{ ID=> id DATA => [] }]}\n  def candump2hash(str_packets)\n    hash = {}\n    hash[\"Packets\"] = []\n    lines = str_packets.split(/\\n/)\n    lines.each do |line|\n      if line =~ /\\w+\\s+(\\w+)   \\[\\d\\]  (.+)$/\n        id = $1\n        str_data = $2\n        data = str_data.split\n        hash[\"Packets\"] << { \"ID\" => id, \"DATA\" => data }\n      end\n    end\n    hash\n  end\n\n  def candump(bus, id, timeout, maxpkts)\n    $candump_sniffer = Thread.new do\n      output = `candump #{bus},#{id}:FFFFFF -T #{timeout} -n #{maxpkts}`\n      @pkt_response = candump2hash(output)\n      Thread::exit\n    end\n  end\n\n  # Sends an ISO-TP style CAN packet and waites for a response or a timeout\n  # bus = string\n  # srcid = hex id of the sent packet\n  # dstid = hex id of the return packets\n  # data = string of hex bytes to send\n  # OPT = Options\n  #    timeout = optional int to timeout on lack of response\n  #    maxpkts = max number of packets to recieve\n  #    padding = append bytes to end of packet (Doesn't increase reported ISO-TP size)\n  #    fc = flow control, if true forces flow control packets\n  def isotp_send_and_wait(bus, srcid, dstid, data, opt = {})\n    result = {}\n    result[\"Success\"] = false\n    srcid = srcid.to_i(16).to_s(16)\n    dstid = dstid.to_i(16).to_s(16)\n    timeout = 2000\n    maxpkts = 3\n    flowcontrol = nil\n    padding = nil\n    timeout = opt['TIMEOUT'] if opt.key? 'TIMEOUT'\n    maxpkts = opt['MAXPKTS'] if opt.key? 'MAXPKTS'\n    padding = opt['PADDING'] if opt.key? 'PADDING'\n    flowcontrol = opt['FC'] if opt.key? 'FC'\n    bytes = data.scan(/../)\n    if bytes.size > 8\n      print_error(\"Data section currently has to be less than 8 bytes\")\n      return result\n    else\n      sz = \"%02x\" % bytes.size\n      bytes = sz + bytes.join\n    end\n    if padding && bytes.size < 16 # 16 == 8 bytes because of ascii size\n      padding = \"%02x\" % padding.to_i\n      bytes += ([ padding ] * (16 - bytes.size)).join\n    end\n    # Should we ever require isotpsend for this?\n    `which cansend`\n    unless $?.success?\n      print_error(\"cansend from can-utils not found in path\")\n      return result\n    end\n    @can_interfaces.each do |can|\n      if can == bus\n        if flowcontrol\n          candump(bus, dstid, timeout, 1)\n          system(\"cansend #{bus} #{srcid}##{bytes}\")\n          @packets_sent += 1\n          @last_sent = Time.now.to_i\n          result[\"Success\"] = true if $?.success?\n          result[\"Packets\"] = []\n          $candump_sniffer.join\n          unless @pkt_response.empty?\n            result = @pkt_response\n            if result.key?(\"Packets\") && result[\"Packets\"].size > 0 && result[\"Packets\"][0].key?(\"DATA\")\n              if result[\"Packets\"][0][\"DATA\"][0] == \"10\"\n                system(\"cansend #{bus} #{srcid}#3000000000000000\")\n                candump(bus, dstid, timeout, maxpkts)\n                @packets_sent += 1\n                @last_sent = Time.now.to_i\n                $candump_sniffer.join\n                unless @pkt_response.empty?\n                  if @pkt_response.key?(\"Packets\") && @pkt_response[\"Packets\"].size > 0\n                    result[\"Packets\"] += @pkt_response[\"Packets\"]\n                  end\n                end\n              end\n            end\n          end\n\n        else\n          candump(bus, dstid, timeout, maxpkts)\n          system(\"cansend #{bus} #{srcid}##{bytes}\")\n          @packets_sent += 1\n          @last_sent = Time.now.to_i\n          result[\"Success\"] = true if $?.success?\n          result[\"Packets\"] = []\n          $candump_sniffer.join\n          unless @pkt_response.empty?\n            result = @pkt_response\n          end\n        end\n      end\n    end\n    result\n\n  end\n\n  #\n  # This is just a sample method that should show up\n  # as sample_cmd in the interface\n  #\n  def sample_custom_method(data)\n    res = {}\n    res[\"value\"] = \"Succesfully processed: #{data}\"\n    res\n  end\n\n  def not_supported\n    { \"status\" => \"not supported\" }\n  end\n\n  def on_request_uri(cli, request)\n    if request.uri =~ /status$/i\n      print_status(\"Sending status...\") if datastore['VERBOSE']\n      send_response_html(cli, get_status().to_json(), { 'Content-Type' => 'application/json' })\n    elsif request.uri =~ /statistics$/i\n      print_status(\"Sending statistics...\") if datastore['VERBOSE']\n      send_response_html(cli, get_statistics().to_json(), { 'Content-Type' => 'application/json' })\n    elsif request.uri =~ /settings\\/datetime\\/get$/i\n      print_status(\"Sending Datetime\") if datastore['VERBOSE']\n      send_response_html(cli, get_datetime().to_json(), { 'Content-Type' => 'application/json' })\n    elsif request.uri =~ /settings\\/timezone\\/get$/i\n      print_status(\"Sending Timezone\") if datastore['VERBOSE']\n      send_response_html(cli, get_timezone().to_json(), { 'Content-Type' => 'application/json' })\n    elsif request.uri =~ /custom_methods$/i\n      print_status(\"Sending custom methods\") if datastore['VERBOSE']\n      send_response_html(cli, get_custom_methods().to_json(), { 'Content-Type' => 'application/json' })\n    elsif request.uri =~ /custom\\/sample_cmd\\?data=(\\S+)$/\n      print_status(\"Request for custom command with args #{$1}\") if datastore['VERBOSE']\n      send_response_html(cli, sample_custom_method($1).to_json(), { 'Content-Type' => 'application/json' })\n    elsif request.uri =~ /automotive/i\n      if request.uri =~ /automotive\\/supported_buses/\n        print_status(\"Sending known buses...\") if datastore['VERBOSE']\n        send_response_html(cli, get_auto_supported_buses().to_json, { 'Content-Type' => 'application/json' })\n      elsif request.uri =~ /automotive\\/(\\w+)\\/cansend\\?id=(\\w+)&data=(\\w+)/\n        print_status(\"Request to send CAN packets for #{$1} => #{$2}##{$3}\") if datastore['VERBOSE']\n        send_response_html(cli, cansend($1, $2, $3).to_json(), { 'Content-Type' => 'application/json' })\n      elsif request.uri =~ /automotive\\/(\\w+)\\/isotpsend_and_wait\\?srcid=(\\w+)&dstid=(\\w+)&data=(\\w+)/\n        bus = $1; srcid = $2; dstid = $3; data = $4\n        print_status(\"Request to send ISO-TP packet and wait for response  #{srcid}##{data} => #{dstid}\") if datastore['VERBOSE']\n        opt = {}\n        opt['TIMEOUT'] = $1 if request.uri =~ /&timeout=(\\d+)/\n        opt['MAXPKTS'] = $1 if request.uri =~ /&maxpkts=(\\d+)/\n        opt['PADDING'] = $1 if request.uri =~ /&padding=(\\d+)/\n        opt['FC'] = true if request.uri =~ /&fc=true/i\n        send_response_html(cli, isotp_send_and_wait(bus, srcid, dstid, data, opt).to_json(),  { 'Content-Type' => 'application/json' })\n      else\n        send_response_html(cli, not_supported().to_json(), { 'Content-Type' => 'application/json' })\n      end\n    else\n      send_response_html(cli, not_supported().to_json(), { 'Content-Type' => 'application/json' })\n    end\n  end\n\n  def run\n    detect_can\n    @server_started = Time.now\n    exploit\n  end\nend\n"
}