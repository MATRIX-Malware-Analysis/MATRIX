{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--dc3d1b30-3a44-4b00-ac3d-67603d032072",
    "created": "2024-08-14T16:27:56.543958Z",
    "modified": "2024-08-14T16:27:56.543963Z",
    "name": "Oracle TNS Listener SID Enumeration",
    "description": " This module simply queries the TNS listener for the Oracle SID. With Oracle 9.2.0.8 and above the listener will be protected and the SID will have to be bruteforced or guessed. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/oracle/sid_enum.rb",
            "external_id": "sid_enum.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::TNS\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Oracle TNS Listener SID Enumeration',\n      'Description'    => %q{\n        This module simply queries the TNS listener for the Oracle SID.\n        With Oracle 9.2.0.8 and above the listener will be protected and\n        the SID will have to be bruteforced or guessed.\n      },\n      'Author'         => [ 'CG', 'MC' ],\n      'License'        => MSF_LICENSE,\n      'DisclosureDate' => '2009-01-07'\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(1521)\n      ])\n  end\n\n  def run_host(ip)\n    begin\n      connect\n\n      pkt = tns_packet(\"(CONNECT_DATA=(COMMAND=STATUS))\")\n\n      sock.put(pkt)\n\n      select(nil,nil,nil,0.5)\n\n      data = sock.get_once\n\n        if ( data and data =~ /ERROR_STACK/ )\n          print_error(\"TNS listener protected for #{ip}...\")\n        else\n          if(not data)\n            print_error(\"#{ip} Connection but no data\")\n          else\n            sid = data.scan(/INSTANCE_NAME=([^\\)]+)/)\n              sid.uniq.each do |s|\n                report_note(\n                  :host   => ip,\n                  :port\t=> rport,\n                  :type   => \"oracle_sid\",\n                  :data   => \"PORT=#{rport}, SID=#{s}\",\n                  :update\t=> :unique_data\n                )\n                print_good(\"Identified SID for #{ip}:#{rport} #{s}\")\n              end\n            service_name = data.scan(/SERVICE_NAME=([^\\)]+)/)\n              service_name.uniq.each do |s|\n                report_note(\n                  :host   => ip,\n                  :port\t=> rport,\n                  :type   => \"oracle_service_name\",\n                  :data   => \"PORT=#{rport}, SERVICE_NAME=#{s}\",\n                  :update\t=> :unique_data\n                )\n                print_status(\"Identified SERVICE_NAME for #{ip}:#{rport} #{s}\")\n              end\n          end\n        end\n      disconnect\n    rescue ::Rex::ConnectionError\n    rescue ::Errno::EPIPE\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2009-01-07"
}