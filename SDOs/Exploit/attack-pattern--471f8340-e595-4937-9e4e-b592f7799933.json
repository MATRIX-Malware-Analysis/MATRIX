{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--471f8340-e595-4937-9e4e-b592f7799933",
    "created": "2024-08-14T16:33:19.24171Z",
    "modified": "2024-08-14T16:33:19.241714Z",
    "name": "The EICAR Encoder",
    "description": " This encoder merely replaces the given payload with the EICAR test string. Note, this is sure to ruin your payload.  Any content-aware firewall, proxy, IDS, or IPS that follows anti-virus standards should alert and do what it would normally do when malware is transmitted across the wire. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/generic/eicar.rb",
            "external_id": "eicar.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Encoder\n\n  # Set to ManualRanking because actually using ths encoder will\n  # certainly destroy any possibility of a successful shell.\n  #\n  Rank = ManualRanking\n\n  def initialize\n    super(\n      'Name'             => 'The EICAR Encoder',\n      'Description'      => %q{\n        This encoder merely replaces the given payload with the EICAR test string.\n        Note, this is sure to ruin your payload.\n\n        Any content-aware firewall, proxy, IDS, or IPS that follows anti-virus\n        standards should alert and do what it would normally do when malware is\n        transmitted across the wire.\n      },\n      'Author'           => 'todb',\n      'License'          => MSF_LICENSE,\n      'Arch'             => ARCH_ALL,\n      'EncoderType'      => Msf::Encoder::Type::Unspecified)\n\n  end\n\n  # Avoid stating the string directly, don't want to get caught by local\n  # antivirus!\n  def eicar_test_string\n    obfus_eicar = [\"x5o!p%@ap[4\\\\pzx54(p^)7cc)7}$eicar\", \"standard\", \"antivirus\", \"test\", \"file!$h+h*\"]\n    obfus_eicar.join(\"-\").upcase\n  end\n\n  # TODO: add an option to merely prepend and not delete, using\n  # prepend_buf. Now, technically, EICAR should be all by itself\n  # and not part of a larger whole. Problem is, OptBool is\n  # acting funny here as an encoder option.\n  #\n  def encode_block(state, buf)\n    buf = eicar_test_string\n  end\nend\n"
}