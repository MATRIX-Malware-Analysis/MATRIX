{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9f9712ac-8e5c-4c17-a512-e43e23739662",
    "created": "2024-08-14T16:31:17.48563Z",
    "modified": "2024-08-14T16:31:17.485634Z",
    "name": "MS17-010 SMB RCE Detection",
    "description": " Uses information disclosure to determine if MS17-010 has been patched or not. Specifically, it connects to the IPC$ tree and attempts a transaction on FID 0. If the status returned is \"STATUS_INSUFF_SERVER_RESOURCES\", the machine does not have the MS17-010 patch.  If the machine is missing the MS17-010 patch, the module will check for an existing DoublePulsar (ring 0 shellcode/malware) infection.  This module does not require valid SMB credentials in default server configurations. It can log on as the user \"\\\" and connect to IPC$. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/smb/smb_ms17_010.rb",
            "external_id": "smb_ms17_010.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-0143"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-0144"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-0145"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-0146"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-0147"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-0148"
        },
        {
            "source_name": "reference",
            "url": "https://zerosum0x0.blogspot.com/2017/04/doublepulsar-initial-smb-backdoor-ring.html"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/countercept/doublepulsar-detection-script"
        },
        {
            "source_name": "reference",
            "url": "https://web.archive.org/web/20170513050203/https://technet.microsoft.com/en-us/library/security/ms17-010.aspx"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Exploit::Remote::SMB::Client::Authenticated\n  include Msf::Exploit::Remote::SMB::Client::PipeAuditor\n\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MS17-010 SMB RCE Detection',\n      'Description'    => %q{\n        Uses information disclosure to determine if MS17-010 has been patched or not.\n        Specifically, it connects to the IPC$ tree and attempts a transaction on FID 0.\n        If the status returned is \"STATUS_INSUFF_SERVER_RESOURCES\", the machine does\n        not have the MS17-010 patch.\n\n        If the machine is missing the MS17-010 patch, the module will check for an\n        existing DoublePulsar (ring 0 shellcode/malware) infection.\n\n        This module does not require valid SMB credentials in default server\n        configurations. It can log on as the user \"\\\" and connect to IPC$.\n      },\n      'Author'         =>\n          [\n            'Sean Dillon <sean.dillon@risksense.com>', # @zerosum0x0\n            'Luke Jennings' # DoublePulsar detection Python code\n          ],\n      'References'     =>\n        [\n          [ 'CVE', '2017-0143'],\n          [ 'CVE', '2017-0144'],\n          [ 'CVE', '2017-0145'],\n          [ 'CVE', '2017-0146'],\n          [ 'CVE', '2017-0147'],\n          [ 'CVE', '2017-0148'],\n          [ 'MSB', 'MS17-010'],\n          [ 'URL', 'https://zerosum0x0.blogspot.com/2017/04/doublepulsar-initial-smb-backdoor-ring.html'],\n          [ 'URL', 'https://github.com/countercept/doublepulsar-detection-script'],\n          [ 'URL', 'https://web.archive.org/web/20170513050203/https://technet.microsoft.com/en-us/library/security/ms17-010.aspx']\n        ],\n      'License'        => MSF_LICENSE,\n      'Notes' =>\n          {\n              'AKA' => [\n                  'DOUBLEPULSAR',\n                  'ETERNALBLUE'\n              ]\n          }\n    ))\n\n    register_options(\n      [\n        OptBool.new('CHECK_DOPU', [false, 'Check for DOUBLEPULSAR on vulnerable hosts', true]),\n        OptBool.new('CHECK_ARCH', [false, 'Check for architecture on vulnerable hosts', true]),\n        OptBool.new('CHECK_PIPE', [false, 'Check for named pipe on vulnerable hosts', false])\n      ])\n  end\n\n  # algorithm to calculate the XOR Key for DoublePulsar knocks\n  def calculate_doublepulsar_xor_key(s)\n    x = (2 * s ^ (((s & 0xff00 | (s << 16)) << 8) | (((s >> 16) | s & 0xff0000) >> 8)))\n    x & 0xffffffff  # this line was added just to truncate to 32 bits\n  end\n\n  # The arch is adjacent to the XOR key in the SMB signature\n  def calculate_doublepulsar_arch(s)\n    s == 0 ? 'x86 (32-bit)' : 'x64 (64-bit)'\n  end\n\n  def run_host(ip)\n    checkcode = Exploit::CheckCode::Unknown\n    details = {}\n\n    begin\n      ipc_share = \"\\\\\\\\#{ip}\\\\IPC$\"\n\n      tree_id = do_smb_setup_tree(ipc_share)\n      vprint_status(\"Connected to #{ipc_share} with TID = #{tree_id}\")\n\n      status = do_smb_ms17_010_probe(tree_id)\n      vprint_status(\"Received #{status} with FID = 0\")\n\n      os = simple.client.peer_native_os.dup\n      details[:os] = os.dup\n      if status == 'STATUS_INSUFF_SERVER_RESOURCES'\n        if datastore['CHECK_ARCH']\n          case dcerpc_getarch\n          when ARCH_X86\n            os << ' x86 (32-bit)'\n            details[:arch] = ARCH_X86\n          when ARCH_X64\n            os << ' x64 (64-bit)'\n            details[:arch] = ARCH_X64\n          end\n        end\n\n        print_good(\"Host is likely VULNERABLE to MS17-010! - #{os}\")\n\n        checkcode = Exploit::CheckCode::Vulnerable(details: details)\n\n        report_vuln(\n          host: ip,\n          port: rport, # A service is necessary for the analyze command\n          name: self.name,\n          refs: self.references,\n          info: \"STATUS_INSUFF_SERVER_RESOURCES for FID 0 against IPC$ - #{os}\"\n        )\n\n        # vulnerable to MS17-010, check for DoublePulsar infection\n        if datastore['CHECK_DOPU']\n          code, signature1, signature2 = do_smb_doublepulsar_probe(tree_id)\n\n          if code == 0x51\n            xor_key = calculate_doublepulsar_xor_key(signature1).to_s(16).upcase\n            arch = calculate_doublepulsar_arch(signature2)\n            print_warning(\"Host is likely INFECTED with DoublePulsar! - Arch: #{arch}, XOR Key: 0x#{xor_key}\")\n            report_vuln(\n              host: ip,\n              name: \"MS17-010 DoublePulsar Infection\",\n              refs: self.references,\n              info: \"MultiPlexID += 0x10 on Trans2 request - Arch: #{arch}, XOR Key: 0x#{xor_key}\"\n            )\n          end\n        end\n\n        if datastore['CHECK_PIPE']\n          pipe_name, _ = check_named_pipes(return_first: true)\n          if pipe_name\n            print_good(\"Named pipe found: #{pipe_name}\")\n\n            report_note(\n              host:  ip,\n              port:  rport,\n              proto: 'tcp',\n              sname: 'smb',\n              type:  'MS17-010 Named Pipe',\n              data:  pipe_name\n            )\n          end\n        end\n      elsif status == \"STATUS_ACCESS_DENIED\" or status == \"STATUS_INVALID_HANDLE\"\n        # STATUS_ACCESS_DENIED (Windows 10) and STATUS_INVALID_HANDLE (others)\n        print_error(\"Host does NOT appear vulnerable.\")\n      else\n        print_error(\"Unable to properly detect if host is vulnerable.\")\n      end\n\n      unless (fp_match = Recog::Nizer.match('smb.native_os', simple.client.peer_native_os)).nil?\n        report_host(\n          host: rhost,\n          arch: details[:arch],\n          os_family: 'Windows',\n          os_flavor: fp_match['os.edition'],\n          os_name: fp_match['os.product']\n        )\n      end\n\n    rescue ::Interrupt\n      print_status(\"Exiting on interrupt.\")\n      raise $!\n    rescue ::Rex::Proto::SMB::Exceptions::LoginError\n      print_error(\"An SMB Login Error occurred while connecting to the IPC$ tree.\")\n    rescue ::Exception => e\n      print_error(\"#{e.class}: #{e.message}\")\n    ensure\n      disconnect\n    end\n\n    checkcode\n  end\n\n  def do_smb_setup_tree(ipc_share)\n    connect(versions: [1])\n\n    # logon as user \\\n    simple.login(datastore['SMBName'], datastore['SMBUser'], datastore['SMBPass'], datastore['SMBDomain'])\n\n    # connect to IPC$\n    simple.connect(ipc_share)\n\n    # return tree\n    return simple.shares[ipc_share]\n  end\n\n  def do_smb_doublepulsar_probe(tree_id)\n    # make doublepulsar knock\n    pkt = make_smb_trans2_doublepulsar(tree_id)\n\n    sock.put(pkt)\n    bytes = sock.get_once\n\n    # convert packet to response struct\n    pkt = Rex::Proto::SMB::Constants::SMB_TRANS_RES_HDR_PKT.make_struct\n    pkt.from_s(bytes[4..-1])\n\n    return pkt['SMB'].v['MultiplexID'], pkt['SMB'].v['Signature1'], pkt['SMB'].v['Signature2']\n  end\n\n  def do_smb_ms17_010_probe(tree_id)\n    # request transaction with fid = 0\n    pkt = make_smb_trans_ms17_010(tree_id)\n    sock.put(pkt)\n    bytes = sock.get_once\n\n    # convert packet to response struct\n    pkt = Rex::Proto::SMB::Constants::SMB_TRANS_RES_HDR_PKT.make_struct\n    pkt.from_s(bytes[4..-1])\n\n    # convert error code to string\n    code = pkt['SMB'].v['ErrorClass']\n    smberr = Rex::Proto::SMB::Exceptions::ErrorCode.new\n\n    return smberr.get_error(code)\n  end\n\n  def make_smb_trans2_doublepulsar(tree_id)\n    # make a raw transaction packet\n    # this one is a trans2 packet, the checker is trans\n    pkt = Rex::Proto::SMB::Constants::SMB_TRANS2_PKT.make_struct\n    simple.client.smb_defaults(pkt['Payload']['SMB'])\n\n    # opcode 0x0e = SESSION_SETUP\n    setup = \"\\x0e\\x00\\x00\\x00\"\n    setup_count = 1             # 1 word\n    trans = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\n    # calculate offsets to the SetupData payload\n    base_offset = pkt.to_s.length + (setup.length) - 4\n    param_offset = base_offset + trans.length\n    data_offset = param_offset # + 0\n\n    # packet baselines\n    pkt['Payload']['SMB'].v['Command'] = Rex::Proto::SMB::Constants::SMB_COM_TRANSACTION2\n    pkt['Payload']['SMB'].v['Flags1'] = 0x18\n    pkt['Payload']['SMB'].v['MultiplexID'] = 65\n    pkt['Payload']['SMB'].v['Flags2'] = 0xc007\n    pkt['Payload']['SMB'].v['TreeID'] = tree_id\n    pkt['Payload']['SMB'].v['WordCount'] = 14 + setup_count\n    pkt['Payload'].v['Timeout'] = 0x00a4d9a6\n    pkt['Payload'].v['ParamCountTotal'] = 12\n    pkt['Payload'].v['ParamCount'] = 12\n    pkt['Payload'].v['ParamCountMax'] = 1\n    pkt['Payload'].v['DataCountMax'] = 0\n    pkt['Payload'].v['ParamOffset'] = 66\n    pkt['Payload'].v['DataOffset'] = 78\n\n    pkt['Payload'].v['SetupCount'] = setup_count\n    pkt['Payload'].v['SetupData'] = setup\n    pkt['Payload'].v['Payload'] = trans\n\n    pkt.to_s\n  end\n\n  def make_smb_trans_ms17_010(tree_id)\n    # make a raw transaction packet\n    pkt = Rex::Proto::SMB::Constants::SMB_TRANS_PKT.make_struct\n    simple.client.smb_defaults(pkt['Payload']['SMB'])\n\n    # opcode 0x23 = PeekNamedPipe, fid = 0\n    setup = \"\\x23\\x00\\x00\\x00\"\n    setup_count = 2             # 2 words\n    trans = \"\\\\PIPE\\\\\\x00\"\n\n    # calculate offsets to the SetupData payload\n    base_offset = pkt.to_s.length + (setup.length) - 4\n    param_offset = base_offset + trans.length\n    data_offset = param_offset # + 0\n\n    # packet baselines\n    pkt['Payload']['SMB'].v['Command'] = Rex::Proto::SMB::Constants::SMB_COM_TRANSACTION\n    pkt['Payload']['SMB'].v['Flags1'] = 0x18\n    pkt['Payload']['SMB'].v['Flags2'] = 0x2801 # 0xc803 would unicode\n    pkt['Payload']['SMB'].v['TreeID'] = tree_id\n    pkt['Payload']['SMB'].v['WordCount'] = 14 + setup_count\n    pkt['Payload'].v['ParamCountMax'] = 0xffff\n    pkt['Payload'].v['DataCountMax'] = 0xffff\n    pkt['Payload'].v['ParamOffset'] = param_offset\n    pkt['Payload'].v['DataOffset'] = data_offset\n\n    # actual magic: PeekNamedPipe FID=0, \\PIPE\\\n    pkt['Payload'].v['SetupCount'] = setup_count\n    pkt['Payload'].v['SetupData'] = setup\n    pkt['Payload'].v['Payload'] = trans\n\n    pkt.to_s\n  end\nend\n"
}