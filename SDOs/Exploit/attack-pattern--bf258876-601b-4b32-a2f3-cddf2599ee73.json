{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bf258876-601b-4b32-a2f3-cddf2599ee73",
    "created": "2024-08-14T16:32:28.706847Z",
    "modified": "2024-08-14T16:32:28.706851Z",
    "name": "Shodan Honeyscore Client",
    "description": " This module uses the shodan API to check if a server is a honeypot or not. The api returns a score from 0.0 to 1.0. 1.0 being a honeypot. A shodan API key is needed for this module to work properly.  If you don't have an account, go here to register: https://account.shodan.io/register For more info on how their honeyscore system works, go here: https://honeyscore.shodan.io/ ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/shodan_honeyscore.rb",
            "external_id": "shodan_honeyscore.rb"
        },
        {
            "source_name": "reference",
            "url": "https://honeyscore.shodan.io/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name' => 'Shodan Honeyscore Client',\n      'Description' => %q{\n        This module uses the shodan API to check\n        if a server is a honeypot or not. The api\n        returns a score from 0.0 to 1.0. 1.0 being a honeypot.\n        A shodan API key is needed for this module to work properly.\n\n        If you don't have an account, go here to register:\n        https://account.shodan.io/register\n        For more info on how their honeyscore system works, go here:\n        https://honeyscore.shodan.io/\n      },\n      'Author' =>\n        [ 'thecarterb' ],  # Thanks to @rwhitcroft, @h00die and @wvu-r7 for the improvements and review!\n      'License' => MSF_LICENSE,\n      'References' =>\n        [\n          [ 'URL', 'https://honeyscore.shodan.io/']\n        ]\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('TARGET', [true, 'The target to get the score of']),\n        OptString.new('SHODAN_APIKEY', [true, 'The SHODAN API key'])\n      ])\n  end\n\n  def print_score(score)\n    tgt = datastore['TARGET']\n    print_status(\"#{tgt} honeyscore: #{score}/1.0\")\n  end\n\n  def run\n    # check our API key is somewhat sane\n    unless /^[a-z\\d]{32}$/i.match?(datastore['SHODAN_APIKEY'])\n      fail_with(Failure::BadConfig, 'Shodan API key should be 32 characters a-z,A-Z,0-9.')\n    end\n\n    key = datastore['SHODAN_APIKEY']\n\n    # Check the length of the key (should be 32 chars)\n    if key.length != 32\n      print_error('Invalid API key (Not long enough)')\n      return\n    end\n\n    tgt = datastore['TARGET']\n    print_status(\"Scanning #{tgt}\")\n    cli = Rex::Proto::Http::Client.new('api.shodan.io', 443, {}, true)\n    cli.connect\n    req = cli.request_cgi({\n      'uri'    => \"/labs/honeyscore/#{tgt}?key=#{key}\",\n      'method' => 'GET'\n      })\n    res = cli.send_recv(req)\n    cli.close\n    if res.nil?\n      fail_with(Failure::Unknown, 'Unable to connect to shodan')\n    end\n\n    if res.code != 200\n      print_error('Shodan did not respond in an expected way. Check your api key')\n      return\n    end\n\n    score = res.body.to_f  # Change the score to a float to be able to determine value in the checks\n\n    if score == 0\n      print_error(\"#{tgt} is not a honeypot\")\n    elsif score < 0.4 && score != 0.0\n      print_error(\"#{tgt} is probably not a honeypot\")\n    elsif score > 0.4 && score < 0.6\n      print_status(\"#{tgt} might be a honeypot\")\n    elsif score > 0.6 && score < 1.0\n      print_good(\"#{tgt} is probably a honeypot\")\n    elsif score == 1.0\n      print_good(\"#{tgt} is definitely a honeypot\")\n    else  # We shouldn't ever get here as the previous checks should catch an unexpected response\n      print_error('An unexpected error occurred.')\n      return\n    end\n    print_score(score)\n  end\nend\n"
}