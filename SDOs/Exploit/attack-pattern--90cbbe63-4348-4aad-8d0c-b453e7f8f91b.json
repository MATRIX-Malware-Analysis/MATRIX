{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--90cbbe63-4348-4aad-8d0c-b453e7f8f91b",
    "created": "2024-08-14T16:33:19.236486Z",
    "modified": "2024-08-14T16:33:19.236493Z",
    "name": "Perl Command Encoder",
    "description": " This encoder uses perl to avoid commonly restricted characters. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/cmd/perl.rb",
            "external_id": "perl.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Encoder\n  Rank = NormalRanking\n\n  def initialize\n    super(\n      'Name'             => 'Perl Command Encoder',\n      'Description'      => %q{\n        This encoder uses perl to avoid commonly restricted characters.\n      },\n      'Author'           => 'hdm',\n      'Arch'             => ARCH_CMD,\n      'Platform'         => 'unix',\n      'EncoderType'      => Msf::Encoder::Type::CmdUnixPerl)\n  end\n\n\n  #\n  # Encodes the payload\n  #\n  def encode_block(state, buf)\n\n    # Skip encoding for empty badchars\n    if state.badchars.length == 0\n      return buf\n    end\n\n    if state.badchars.include?(\"-\")\n      raise EncodingError\n    else\n      buf = encode_block_perl(state,buf)\n    end\n\n    return buf\n  end\n\n  #\n  # Uses the perl command to hex encode the command string\n  #\n  def encode_block_perl(state, buf)\n\n    hex = buf.unpack(\"H*\").join\n    cmd = 'perl -e '\n    qot = ',-:.=+!@#$%^&'\n\n    # Convert spaces to IFS...\n    if state.badchars.include?(\" \")\n      if state.badchars.match(/[${IFS}]/n)\n        raise EncodingError\n      end\n      cmd.gsub!(/\\s/, '${IFS}')\n    end\n\n    # Can we use single quotes to enclose the command string?\n    if state.badchars.include?(\"'\")\n      if (state.badchars.match(/[()\\\\]/))\n        cmd << perl_e(state, qot, hex)\n      else\n        # Without quotes, we can use backslash to escape parens so the\n        # shell doesn't try to interpreter them.\n        cmd << \"system\\\\(pack\\\\(#{perl_qq(state, qot, hex)}\\\\)\\\\)\"\n      end\n    else\n      # Quotes are ok, but we still need parens or spaces\n      if (state.badchars.match(/[()]/n))\n        if state.badchars.include?(\" \")\n          cmd << perl_e(state, qot, hex)\n        else\n          cmd << \"'system pack #{perl_qq(state, qot, hex)}'\"\n        end\n      else\n        cmd << \"'system(pack(#{perl_qq(state, qot, hex)}))'\"\n      end\n    end\n\n    return cmd\n  end\n\n  def perl_e(state, qot, hex)\n    # We don't have parens, quotes, or backslashes so we have to use\n    # barewords on the commandline for the argument to the pack\n    # function. As a consequence, we can't use things that the shell\n    # would interpret, so $ and & become badchars.\n    qot.delete(\"$\")\n    qot.delete(\"&\")\n\n    # Perl chains -e with newlines, but doesn't automatically add\n    # semicolons, so the following will result in the interpreter\n    # seeing a file like this:\n    #    system\n    #    pack\n    #    qq^H*^,qq^whatever^\n    # Since system and pack require arguments (rather than assuming\n    # $_ when no args are given like many other perl functions),\n    # this works out to do what we need.\n    cmd = \"system -e pack -e #{perl_qq(state, qot, hex)}\"\n    if state.badchars.include?(\" \")\n      # We already tested above to make sure that these chars are ok\n      # if space isn't.\n      cmd.gsub!(\" \", \"${IFS}\")\n    end\n\n    cmd\n  end\n\n  def perl_qq(state, qot, hex)\n\n    # Find a quoting character to use\n    state.badchars.unpack('C*') { |c| qot.delete(c.chr) }\n\n    # Throw an error if we ran out of quotes\n    raise EncodingError if qot.length == 0\n\n    sep = qot[0].chr\n    # Use an explicit length for the H specifier instead of just \"H*\"\n    # in case * is a badchar for the module, and for the case where this\n    # ends up unquoted so the shell doesn't try to expand a path.\n    \"qq#{sep}H#{hex.length}#{sep},qq#{sep}#{hex}#{sep}\"\n  end\nend\n",
    "x_mitre_platforms": [
        "unix'"
    ]
}