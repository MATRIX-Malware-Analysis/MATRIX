{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ce9721f3-28e4-4c38-a7eb-5016d51acc03",
    "created": "2024-08-14T16:22:58.652196Z",
    "modified": "2024-08-14T16:22:58.6522Z",
    "name": "Kerberos Ticket Inspecting",
    "description": " This module outputs the contents of a ccache/kirbi file and optionally (when provided with the appropriate key) decrypts and displays the encrypted content too. Can be used for inspecting tickets that aren't working as intended in an effort to debug them. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/kerberos/inspect_ticket.rb",
            "external_id": "inspect_ticket.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::Kerberos::Client\n  include Msf::Exploit::Remote::Kerberos::Ticket\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Kerberos Ticket Inspecting',\n        'Description' => %q{\n          This module outputs the contents of a ccache/kirbi file and optionally (when provided with the appropriate key)\n          decrypts and displays the encrypted content too.\n          Can be used for inspecting tickets that aren't working as intended in an effort to debug them.\n        },\n        'Author' => [\n          'Dean Welch' # Metasploit Module\n        ],\n        'References' => [],\n        'License' => MSF_LICENSE,\n        'Notes' => {\n          'Stability' => [],\n          'SideEffects' => [],\n          'Reliability' => [],\n          'AKA' => ['klist']\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('NTHASH', [ false, 'The krbtgt/service nthash' ]),\n        OptString.new('AES_KEY', [ false, 'The krbtgt/service AES key' ]),\n        OptString.new('TICKET_PATH', [true, 'Path to the ticket (ccache/kirbi format) you wish to inspect'])\n      ]\n    )\n    deregister_options('RHOSTS', 'RPORT', 'Timeout')\n  end\n\n  SECS_IN_DAY = 86400 # 60 * 60 * 24\n\n  def run\n    enc_key = get_enc_key\n    print_contents(datastore['TICKET_PATH'], key: enc_key)\n  rescue Rex::Proto::Kerberos::Model::Error::KerberosError => e\n    fail_with(Msf::Exploit::Failure::Unknown, \"Could not print ticket contents (#{e})\")\n  end\n\n  private\n\n  def get_enc_key\n    key = validate_key\n    key.nil? ? nil : [key].pack('H*')\n  end\n\n  def validate_key\n    if datastore['NTHASH'].present? && datastore['AES_KEY'].present?\n      fail_with(Msf::Exploit::Failure::BadConfig, 'NTHASH and AES_KEY may not both be set for inspecting a ticket')\n    end\n\n    if datastore['NTHASH'].present?\n      key_type = :nthash\n    elsif datastore['AES_KEY'].present?\n      key_type = :aes_key\n    else\n      key_type = nil\n    end\n\n    case key_type\n    when :nthash\n      key = validate_nthash(datastore['NTHASH'])\n    when :aes_key\n      key = validate_aes_key(datastore['AES_KEY'])\n    else\n      print_status('No decryption key provided proceeding without decryption.')\n      key = nil\n    end\n\n    key\n  end\n\n  def validate_nthash(nthash)\n    if nthash.size != 32\n      fail_with(Msf::Exploit::Failure::BadConfig, \"NTHASH length was #{nthash.size}. It should be 32\")\n    else\n      nthash\n    end\n  end\n\n  def validate_aes_key(aes_key)\n    if aes_key.size != 32 && aes_key.size != 64\n      fail_with(Msf::Exploit::Failure::BadConfig, \"AES key length was #{aes_key.size}. It should be 32 or 64\")\n    else\n      aes_key\n    end\n  end\nend\n"
}