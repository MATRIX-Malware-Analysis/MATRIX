{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b076bd70-523e-4766-b331-f3c5e059c832",
    "created": "2024-08-14T16:27:48.010872Z",
    "modified": "2024-08-14T16:27:48.010876Z",
    "name": "NTP Monitor List Scanner",
    "description": " This module identifies NTP servers which permit \"monlist\" queries and obtains the recent clients list. The monlist feature allows remote attackers to cause a denial of service (traffic amplification) via spoofed requests. The more clients there are in the list, the greater the amplification.  'References'  => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/ntp/ntp_monlist.rb",
            "external_id": "ntp_monlist.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.cisa.gov/uscert/ncas/alerts/TA14-013A"
        },
        {
            "source_name": "reference",
            "url": "https://support.ntp.org/bin/view/Main/SecurityNotice"
        },
        {
            "source_name": "reference",
            "url": "https://nmap.org/nsedoc/scripts/ntp-monlist.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::Udp\n  include Msf::Auxiliary::UDPScanner\n  include Msf::Auxiliary::NTP\n  include Msf::Auxiliary::DRDoS\n\n  def initialize\n    super(\n      'Name'        => 'NTP Monitor List Scanner',\n      'Description' => %q{\n        This module identifies NTP servers which permit \"monlist\" queries and\n        obtains the recent clients list. The monlist feature allows remote\n        attackers to cause a denial of service (traffic amplification)\n        via spoofed requests. The more clients there are in the list, the\n        greater the amplification.\n      },\n      'References'  =>\n        [\n          ['CVE', '2013-5211'],\n          ['URL', 'https://www.cisa.gov/uscert/ncas/alerts/TA14-013A'],\n          ['URL', 'https://support.ntp.org/bin/view/Main/SecurityNotice'],\n          ['URL', 'https://nmap.org/nsedoc/scripts/ntp-monlist.html'],\n        ],\n      'Author'      => 'hdm',\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n    [\n      OptInt.new('RETRY', [false, \"Number of tries to query the NTP server\", 3]),\n      OptBool.new('SHOW_LIST', [false, 'Show the recent clients list', false])\n    ])\n\n    register_advanced_options(\n    [\n      OptBool.new('StoreNTPClients', [true, 'Store NTP clients as host records in the database', false])\n    ])\n  end\n\n  # Called for each response packet\n  def scanner_process(data, shost, sport)\n    @results[shost] ||= { messages: [], peers: [] }\n    @results[shost][:messages] << Rex::Proto::NTP::NTPPrivate.new.read(data).to_binary_s\n    @results[shost][:peers] << extract_peer_tuples(data)\n  end\n\n  # Called before the scan block\n  def scanner_prescan(batch)\n    @results = {}\n    @aliases = {}\n    @probe = Rex::Proto::NTP.ntp_private(datastore['VERSION'], datastore['IMPLEMENTATION'], 42, \"\\0\" * 40).to_binary_s\n  end\n\n  # Called after the scan block\n  def scanner_postscan(batch)\n    @results.keys.each do |k|\n      response_map = { @probe => @results[k][:messages] }\n      peer = \"#{k}:#{rport}\"\n\n      # TODO: check to see if any of the responses are actually NTP before reporting\n      report_service(\n        :host  => k,\n        :proto => 'udp',\n        :port  => rport,\n        :name  => 'ntp'\n      )\n\n      peers = @results[k][:peers].flatten(1)\n      unless peers.empty?\n        print_good(\"#{peer} NTP monlist request permitted (#{peers.length} entries)\")\n        # store the peers found from the monlist\n        report_note(\n          :host  => k,\n          :proto => 'udp',\n          :port  => rport,\n          :type  => 'ntp.monlist',\n          :data  => {:monlist => peers}\n        )\n        # print out peers if desired\n        if datastore['SHOW_LIST']\n          peers.each do |ntp_peer|\n            print_status(\"#{peer} #{ntp_peer}\")\n          end\n        end\n        # store any aliases for our target\n        report_note(\n          :host  => k,\n          :proto => 'udp',\n          :port  => rport,\n          :type  => 'ntp.addresses',\n          :data  => {:addresses => peers.map { |p| p.last }.sort.uniq }\n        )\n\n        if (datastore['StoreNTPClients'])\n          print_status(\"#{peer} Storing #{peers.length} NTP client hosts in the database...\")\n          peers.each do |r|\n            maddr,mport,mserv = r\n            next if maddr == '127.0.0.1' # some NTP servers peer with themselves..., but we can't store loopback\n            report_note(\n              :host => maddr,\n              :type => 'ntp.client.history',\n              :data => {\n                :address => maddr,\n                :port    => mport,\n                :server  => mserv\n              }\n            )\n          end\n        end\n      end\n\n      vulnerable, proof = prove_amplification(response_map)\n      what = 'NTP Mode 7 monlist DRDoS (CVE-2013-5211)'\n      if vulnerable\n        print_good(\"#{peer} - Vulnerable to #{what}: #{proof}\")\n        report_vuln({\n          :host  => k,\n          :port  => rport,\n          :proto => 'udp',\n          :name  => what,\n          :refs  => self.references\n        })\n      else\n        vprint_status(\"#{peer} - Not vulnerable to #{what}: #{proof}\")\n      end\n    end\n\n  end\n\n  # Examine the monlist reponse +data+ and extract all peer tuples (saddd, dport, daddr)\n  def extract_peer_tuples(data)\n    return [] if data.length < 76\n\n    # NTP headers 8 bytes\n    ntp_flags, ntp_auth, ntp_vers, ntp_code = data.slice!(0,4).unpack('C*')\n    pcnt, plen = data.slice!(0,4).unpack('nn')\n    return [] if plen != 72\n\n    idx = 0\n    peer_tuples = []\n    1.upto(pcnt) do\n      # u_int32 firsttime; /* first time we received a packet */\n      # u_int32 lasttime;  /* last packet from this host */\n      # u_int32 restr;     /* restrict bits (was named lastdrop) */\n      # u_int32 count;     /* count of packets received */\n      # u_int32 addr;      /* host address V4 style */\n      # u_int32 daddr;     /* destination host address */\n      # u_int32 flags;     /* flags about destination */\n      # u_short port;      /* port number of last reception */\n\n      _,_,_,_,saddr,daddr,_,dport = data[idx, 30].unpack(\"NNNNNNNn\")\n\n      peer_tuples << [ Rex::Socket.addr_itoa(saddr), dport, Rex::Socket.addr_itoa(daddr) ]\n      idx += plen\n    end\n    peer_tuples\n  end\nend\n",
    "x_mitre_contributors": [
        "hdm",
        ""
    ]
}