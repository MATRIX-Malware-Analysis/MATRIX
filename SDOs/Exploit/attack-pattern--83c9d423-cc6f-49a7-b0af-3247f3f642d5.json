{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--83c9d423-cc6f-49a7-b0af-3247f3f642d5",
    "created": "2024-08-14T16:26:58.126804Z",
    "modified": "2024-08-14T16:26:58.126809Z",
    "name": "SAPRouter Port Scanner",
    "description": " This module allows for mapping ACLs and identify open/closed ports accessible on hosts through a saprouter. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/sap/sap_router_portscanner.rb",
            "external_id": "sap_router_portscanner.rb"
        },
        {
            "source_name": "reference",
            "url": "https://web.archive.org/web/20130204114105/http://help.sap.com/saphelp_nw70ehp3/helpdata/en/48/6c68b01d5a350ce10000000a42189d/content.htm"
        },
        {
            "source_name": "reference",
            "url": "https://web.archive.org/web/20160818155950/http://help.sap.com/saphelp_dimp50/helpdata/En/f8/bb960899d743378ccb8372215bb767/content.htm"
        },
        {
            "source_name": "reference",
            "url": "https://labs.f-secure.com/archive/sap-smashing-internet-windows/"
        },
        {
            "source_name": "reference",
            "url": "http://conference.hitb.org/hitbsecconf2010ams/materials/D2T2%20-%20Mariano%20Nunez%20Di%20Croce%20-%20SAProuter%20.pdf"
        },
        {
            "source_name": "reference",
            "url": "https://archive.sap.com/documents/docs/DOC-17124#SAPdefaultports"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Report\n\n  VALID_HOSTNAME_REGEX = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/\n\n  def initialize\n    super(\n      'Name' => 'SAPRouter Port Scanner',\n      'Description' => %q{\n          This module allows for mapping ACLs and identify open/closed ports accessible\n        on hosts through a saprouter.\n      },\n      'Author' => [\n        'Bruno Morisson <bm[at]integrity.pt>', # metasploit module\n        'nmonkee' # saprouter packet building code from sapcat.rb and default sap ports information\n      ],\n      'References' =>\n        [\n          # General\n          ['URL', 'https://web.archive.org/web/20130204114105/http://help.sap.com/saphelp_nw70ehp3/helpdata/en/48/6c68b01d5a350ce10000000a42189d/content.htm'],\n          ['URL', 'https://web.archive.org/web/20160818155950/http://help.sap.com/saphelp_dimp50/helpdata/En/f8/bb960899d743378ccb8372215bb767/content.htm'],\n          ['URL', 'https://labs.f-secure.com/archive/sap-smashing-internet-windows/'],\n          ['URL', 'http://conference.hitb.org/hitbsecconf2010ams/materials/D2T2%20-%20Mariano%20Nunez%20Di%20Croce%20-%20SAProuter%20.pdf'],\n          ['URL', 'https://archive.sap.com/documents/docs/DOC-17124'] # SAP default ports\n        ],\n      'License' => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        OptAddress.new('RHOST', [true, 'SAPRouter address', '']),\n        OptPort.new('RPORT', [true, 'SAPRouter TCP port', '3299']),\n        OptString.new('TARGETS', [true, 'Comma delimited targets. When resolution is local address ranges or CIDR identifiers allowed.', '']),\n        OptEnum.new('MODE', [true, 'Connection Mode: SAP_PROTO or TCP ', 'SAP_PROTO', ['SAP_PROTO', 'TCP']]),\n        OptString.new('INSTANCES', [false, 'SAP instance numbers to scan (NN in PORTS definition)', '00-99']),\n        OptString.new('PORTS', [true, 'Ports to scan (e.g. 3200-3299,5NN13)', '32NN']),\n        # Default ports: 32NN,33NN,48NN,80NN,36NN,81NN,5NN00-5NN19,21212,21213,\n        # 59975,59976,4238-4241,3299,3298,515,7200,7210,7269,7270,7575,39NN,\n        # 3909,4NN00,8200,8210,8220,8230,4363,4444,4445,9999,3NN01-3NN08,\n        # 3NN11,3NN17,20003-20007,31596,31597,31602,31601,31604,2000-2002,\n        # 8355,8357,8351-8353,8366,1090,1095,20201,1099,1089,443NN,444NN\n        OptInt.new('CONCURRENCY', [true, 'The number of concurrent ports to check per host', 10]),\n        OptEnum.new('RESOLVE',[true,'Where to resolve TARGETS','local',['remote','local']])\n      ])\n\n  end\n\n  # Converts a instance specification like \"4,21-23,33\" into a sorted,\n  # unique array of valid port numbers like [4,21,22,23,33]\n  def sap_instance_to_list(instance)\n    instances = []\n\n    return if !instance\n\n    # Build ports array from port specification\n    instance.split(/,/).each do |item|\n      start, stop = item.split(/-/).map { |p| p.to_i }\n\n      start ||= 0\n      stop ||= item.match(/-/) ? 99 : start\n\n      start, stop = stop, start if stop < start\n\n      start.upto(stop) { |p| instances << p }\n    end\n\n    # Sort, and remove dups and invalid instances\n    instances.sort.uniq.delete_if { |p| p < 0 or p > 99 }\n  end\n\n  def build_sap_ports(ports)\n    sap_ports = []\n\n    sap_instances = sap_instance_to_list(datastore['INSTANCES'])\n\n    # if we have INSTANCES, let's fill in the NN on PORTS\n    if sap_instances and ports.include? 'NN'\n      sap_instances.each { |i| sap_ports << (ports.gsub('NN', \"%02d\" % i)).to_s }\n      ports = Rex::Socket.portspec_crack(sap_ports.join(','))\n    else\n      ports = Rex::Socket.portspec_crack(ports)\n    end\n\n    return ports\n  end\n\n  def build_ni_packet(routes)\n\n    mode = {'SAP_PROTO' => 0, 'TCP' => 1}[datastore['MODE']]\n\n    route_data=''\n    ni_packet = [\n      'NI_ROUTE',\n      0,\n      2,\n      39,\n      2,\n      mode,\n      0,\n      0,\n      1\n    ].pack(\"A8c8\")\n\n    first = false\n\n    routes.each do |host, port| # create routes\n      route_item = [host, 0, port.to_s, 0, 0].pack(\"A*CA*cc\")\n      if !first\n        route_data = [route_data, route_item.length, route_item].pack(\"A*NA*\")\n        first = true\n      else\n        route_data = route_data << route_item\n      end\n    end\n\n    ni_packet << [route_data.length - 4].pack('N') << route_data # add routes to packet\n    ni_packet = [ni_packet.length].pack('N') << ni_packet # add size\n  end\n\n  def sap_port_info(port)\n\n    case port.to_s\n\n    when /^3299$/\n      service = \"SAP Router\"\n    when /^3298$/\n      service = \"SAP niping (Network Test Program)\"\n    when /^32[0-9][0-9]/\n      service = \"SAP Dispatcher sapdp\" + port.to_s[-2, 2]\n    when /^33[0-9][0-9]/\n      service = \"SAP Gateway sapgw\" + port.to_s[-2, 2]\n    when /^48[0-9][0-9]/\n      service = \"SAP Gateway [SNC] sapgw\" + port.to_s[-2, 2]\n    when /^80[0-9][0-9]/\n      service = \"SAP ICM HTTP\"\n    when /^443[0-9][0-9]/\n      service = \"SAP ICM HTTPS\"\n    when /^36[0-9][0-9]/\n      service = \"SAP Message Server sapms<SID>\" + port.to_s[-2, 2]\n    when /^81[0-9][0-9]/\n      service = \"SAP Message Server [HTTP]\"\n    when /^444[0-9][0-9]/\n      service = \"SAP Message Server [HTTPS]\"\n    when /^5[0-9][0-9]00/\n      service = \"SAP JAVA EE Dispatcher [HTTP]\"\n    when /^5[0-9][0-9]01/\n      service = \"SAP JAVA EE Dispatcher [HTTPS]\"\n    when /^5[0-9][0-9]02/\n      service = \"SAP JAVA EE Dispatcher [IIOP]\"\n    when /^5[0-9][0-9]03/\n      service = \"SAP JAVA EE Dispatcher [IIOP over SSL]\"\n    when /^5[0-9][0-9]04/\n      service = \"SAP JAVA EE Dispatcher [P4]\"\n    when /^5[0-9][0-9]05/\n      service = \"SAP JAVA EE Dispatcher [P4 over HTTP]\"\n    when /^5[0-9][0-9]06/\n      service = \"SAP JAVA EE Dispatcher [P4 over SSL]\"\n    when /^5[0-9][0-9]07/\n      service = \"SAP JAVA EE Dispatcher [IIOP]\"\n    when /^5[0-9][0-9]08$/\n      service = \"SAP JAVA EE Dispatcher [Telnet]\"\n    when /^5[0-9][0-9]10/\n      service = \"SAP JAVA EE Dispatcher [JMS]\"\n    when /^5[0-9][0-9]16/\n      service = \"SAP JAVA Enq. Replication\"\n    when /^5[0-9][0-9]13/\n      service = \"SAP StartService [SOAP] sapctrl\" + port.to_s[1, 2]\n    when /^5[0-9][0-9]14/\n      service = \"SAP StartService [SOAP over SSL] sapctrl\" + port.to_s[1, 2]\n    when /^5[0-9][0-9]1(7|8|9)/\n      service = \"SAP Software Deployment Manager\"\n    when /^2121(2|3)/\n      service = \"SAPinst\"\n    when /^5997(5|6)/\n      service = \"SAPinst (IBM AS/400 iSeries)\"\n    when /^42(3|4)(8|9|0|1$)/\n      service = \"SAP Upgrade\"\n    when /^515$/\n      service = \"SAPlpd\"\n    when /^7(2|5)(00|10|69|70|75$)/\n      service = \"LiveCache MaxDB (formerly SAP DB)\"\n    when /^5[0-9][0-9]15/\n      service = \"DTR - Design Time Repository\"\n    when /^3909$/\n      service = \"ITS MM (Mapping Manager) sapvwmm00_<INST>\"\n    when /^39[0-9][0-9]$/\n      service = \"ITS AGate sapavw00_<INST>\"\n    when /^4[0-9][0-9]00/\n      service = \"IGS Multiplexer\"\n    when /^8200$/\n      service = \"XI JMS/JDBC/File Adapter\"\n    when /^8210$/\n      service = \"XI JMS Adapter\"\n    when /^8220$/\n      service = \"XI JDBC Adapter\"\n    when /^8230$/\n      service = \"XI File Adapter\"\n    when /^4363$/\n      service = \"IPC Dispatcher\"\n    when /^4444$/\n      service = \"IPC Dispatcher\"\n    when /^4445$/\n      service = \"IPC Data Loader\"\n    when /^9999$/\n      service = \"IPC Server\"\n    when /^3[0-9][0-9](0|1)(1|2|3|4|5|6|7|8$)/\n      service = \"SAP Software Deployment Manager\"\n    when /^2000(3|4|5|6|7$)/\n      service = \"MDM (Master Data Management)\"\n    when /^3159(6|7$)/\n      service = \"MDM (Master Data Management)\"\n    when /^3160(2|3|4$)/\n      service = \"MDM (Master Data Management)\"\n    when /^200(0|1|2$)/\n      service = \"MDM Server (Master Data Management)\"\n    when /^83(5|6)(1|2|3|5|6|7$)/\n      service = \"MDM Server (Master Data Management)\"\n    when /^109(0|5$)/\n      service = \"Content Server / Cache Server\"\n    when /^20201$/\n      service = \"CRM - Central Software Deployment Manager\"\n    when /^10(8|9)9$/\n      service = \"PAW - Performance Assessment Workbench\"\n    when /^59950$/\n      service = \"SAP NetWeaver Master Data Server\"\n    when /^59951$/\n      service = \"SAP NetWeaver Master Data Server (HTTPS)\"\n    when /^59650$/\n      service = \"SAP NetWeaver Master Data Layout Server\"\n    when /^59651$/\n      service = \"SAP NetWeaver Master Data Layout Server (HTTPS)\"\n    when /^59750$/\n      service = \"SAP NetWeaver Master Data Import Server\"\n    when /^59751$/\n      service = \"SAP NetWeaver Master Data Import Server (HTTPS)\"\n    when /^59850$/\n      service = \"SAP NetWeaver Master Data Syndication Server\"\n    when /^59851$/\n      service = \"SAP NetWeaver Master Data Syndication Server (HTTPS)\"\n    when /^4[0-9][0-9](0[1-9]|[1-7][0-9])$/\n      service = \"IGS Portwatcher (Clients)\"\n    when /^4[0-9][0-9](8|9)[0-9]$/\n      service = \"IGS HTTP-ports\"\n    when /^1128$/\n      service = \"SAP Host Agent\"\n    when /^1129$/\n      service = \"SAP Host Agent with SSL\"\n    else\n      service = ''\n    end\n\n  end\n\n  def parse_response_packet(response, ip, port)\n\n    #vprint_error(\"#{ip}:#{port} - response packet: #{response}\")\n\n    case response\n    when /NI_RTERR/\n      case response\n      when /timed out/\n        vprint_error (\"#{ip}:#{port} - connection timed out\")\n      when /refused/\n        vprint_error(\"#{ip}:#{port} - TCP closed\")\n        return [ip, port, \"closed\", sap_port_info(port)]\n      when /denied/\n        vprint_error(\"#{ip}:#{port} - blocked by ACL\")\n      when /invalid/\n        vprint_error(\"#{ip}:#{port} - invalid route\")\n      when /reacheable/\n        vprint_error(\"#{ip}:#{port} - unreachable\")\n      when /hostname '#{ip}' unknown/\n        vprint_error(\"#{ip}:#{port} - unknown host\")\n      when /GetHostByName: '#{ip}' not found/\n        vprint_error(\"#{ip}:#{port} - unknown host\")\n      when /connection to .* timed out/\n        vprint_error(\"#{ip}:#{port} - connection timed out\")\n      when /partner .* not reached/\n        vprint_error(\"#{ip}:#{port} - host unreachable\")\n      else\n        vprint_error(\"#{ip}:#{port} - unknown error message\")\n      end\n    when /NI_PONG/\n      vprint_good(\"#{ip}:#{port} - TCP OPEN\")\n      return [ip, port, \"open\", sap_port_info(port)]\n    else\n      vprint_error(\"#{ip}:#{port} - unknown response\")\n    end\n\n    return nil\n  end\n\n  def validate_hosts_range(range)\n    hosts_list = range.split(\",\")\n    return false if hosts_list.nil? or hosts_list.empty?\n\n    hosts_list.each do |host|\n      unless Rex::Socket.is_ipv6?(host) || Rex::Socket.is_ipv4?(host) || host =~ VALID_HOSTNAME_REGEX\n        return false\n      end\n    end\n  end\n\n  def run\n\n    if datastore['RESOLVE'] == 'remote'\n      range = datastore['TARGETS']\n      unless validate_hosts_range(range)\n        print_error(\"TARGETS must be a comma separated list of IP addresses or hostnames when RESOLVE is remote\")\n        return\n      end\n\n      range.split(/,/).each do |host|\n        run_host(host)\n      end\n    else\n      # resolve IP or crack IP range\n      ip_list = Rex::Socket::RangeWalker.new(datastore['TARGETS'])\n      ip_list.each do |ip|\n        run_host(ip)\n      end\n    end\n\n  end\n\n  def run_host(ip)\n    ports = datastore['PORTS']\n\n    # if port definition has NN then we require INSTANCES\n    if ports.include? 'NN' and datastore['INSTANCES'].nil?\n      print_error('Error: No instances specified')\n      return\n    end\n\n    ports = build_sap_ports(ports)\n\n    if ports.empty?\n      raise Msf::OptionValidateError.new(['PORTS'])\n    end\n\n    print_status(\"Scanning #{ip}\")\n    thread = []\n    r = []\n\n    begin\n      ports.each do |port|\n\n        if thread.length >= datastore['CONCURRENCY']\n          # Assume the first thread will be among the earliest to finish\n          thread.first.join\n        end\n        thread << framework.threads.spawn(\"Module(#{self.refname})-#{ip}:#{port}\", false) do\n\n          begin\n            # create ni_packet to send to saprouter\n            routes = {rhost => rport, ip => port}\n            ni_packet = build_ni_packet(routes)\n\n            s = connect(false)\n\n            s.write(ni_packet, ni_packet.length)\n            response = s.get()\n\n            res = parse_response_packet(response, ip, port)\n            if res\n              r << res\n            end\n\n          rescue ::Rex::ConnectionRefused\n            print_error(\"#{ip}:#{port} - Unable to connect to SAPRouter #{rhost}:#{rport} - Connection Refused\")\n\n          rescue ::Rex::ConnectionError, ::IOError, ::Timeout::Error\n          rescue ::Rex::Post::Meterpreter::RequestError\n          rescue ::Interrupt\n            raise $!\n          ensure\n            disconnect(s) rescue nil\n          end\n        end\n      end\n      thread.each { |x| x.join }\n\n    rescue ::Timeout::Error\n    ensure\n      thread.each { |x| x.kill rescue nil }\n    end\n\n    tbl = Msf::Ui::Console::Table.new(\n      Msf::Ui::Console::Table::Style::Default,\n      'Header' => \"Portscan Results\",\n      'Prefix' => \"\\n\",\n      'Postfix' => \"\\n\",\n      'Indent' => 1,\n      'Columns' =>\n        [\n          \"Host\",\n          \"Port\",\n          \"State\",\n          \"Info\",\n        ])\n\n    r.each do |res|\n      tbl << [res[0], res[1], res[2], res[3]]\n      # we can't report if resolution is remote, since host is unknown locally\n      if datastore['RESOLVE'] == 'local'\n        begin\n          report_service(:host => res[0], :port => res[1], :state => res[2])\n        rescue ActiveRecord::RecordInvalid\n          # Probably raised because the Address is reserved, for example\n          # when trying to report a service on 127.0.0.1\n          print_warning(\"Can't report #{res[0]} as host to the database\")\n        end\n      end\n    end\n\n    print_warning(\"Warning: Service info could be inaccurate\")\n    print(tbl.to_s)\n\n  end\nend\n"
}