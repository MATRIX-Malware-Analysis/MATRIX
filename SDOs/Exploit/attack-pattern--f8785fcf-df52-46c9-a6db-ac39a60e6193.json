{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f8785fcf-df52-46c9-a6db-ac39a60e6193",
    "created": "2024-08-14T16:29:19.978112Z",
    "modified": "2024-08-14T16:29:19.978117Z",
    "name": "HTTP Copy File Scanner",
    "description": " This module identifies the existence of possible copies of a specific file in a given path. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/copy_of_file.rb",
            "external_id": "copy_of_file.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::WmapScanFile\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'   \t\t=> 'HTTP Copy File Scanner',\n      'Description'\t=> %q{\n        This module identifies the existence of possible copies\n        of a specific file in a given path.\n      },\n      'Author' \t\t=> [ 'et [at] cyberspace.org' ],\n      'License'\t\t=> BSD_LICENSE))\n\n    register_options(\n      [\n        OptString.new('PATH', [ true,  \"The path/file to identify copies\", '/index.asp'])\n      ])\n\n    register_advanced_options(\n      [\n        OptInt.new('ErrorCode', [ true, \"Error code for non existent directory\", 404]),\n        OptPath.new('HTTP404Sigs',   [ false, \"Path of 404 signatures to use\",\n            File.join(Msf::Config.data_directory, \"wmap\", \"wmap_404s.txt\")\n          ]\n        ),\n        OptBool.new('NoDetailMessages', [ false, \"Do not display detailed test messages\", true ])\n      ])\n\n  end\n\n  def run_host(ip)\n    conn = true\n    ecode = nil\n    emesg = nil\n\n    ecode = datastore['ErrorCode'].to_i\n    dm = datastore['NoDetailMessages']\n\n    # Required to calculate error code for each case as special charcters amd spaces\n    # trigger different responses\n\n    prestr = [\n            'Copy_(1)_of_',\n            'Copy_(2)_of_',\n            'Copy of ',\n            'Copy_of_',\n            'Copy_',\n            'Copy',\n            '_'\n          ]\n\n\n    tpathf = normalize_uri(datastore['PATH'])\n    testf = tpathf.split('/').last\n\n\n    if testf\n      prestr.each do |pre|\n        #\n        # Detect error code\n        #\n        begin\n          randfile = Rex::Text.rand_text_alpha(5).chomp\n\n          filec = tpathf.sub(testf,pre + randfile + testf)\n\n          res = send_request_cgi({\n            'uri'  \t\t=>  filec,\n            'method'   \t=> 'GET',\n            'ctype'\t\t=> 'text/html'\n          }, 20)\n\n          return if not res\n\n          tcode = res.code.to_i\n\n\n          # Look for a string we can signature on as well\n          if(tcode >= 200 and tcode <= 299)\n\n            File.open(datastore['HTTP404Sigs'], 'rb').each do |str|\n              if(res.body.index(str))\n                emesg = str\n                break\n              end\n            end\n\n            if(not emesg)\n              print_status(\"Using first 256 bytes of the response as 404 string\")\n              emesg = res.body[0,256]\n            else\n              print_status(\"Using custom 404 string of '#{emesg}'\")\n            end\n          else\n            ecode = tcode\n            print_status(\"Using code '#{ecode}' as not found.\")\n          end\n\n        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n          conn = false\n        rescue ::Timeout::Error, ::Errno::EPIPE\n        end\n\n        return if not conn\n\n        filec = tpathf.sub(testf,pre + testf)\n\n        begin\n          res = send_request_cgi({\n            'uri'  \t\t=>  filec,\n            'method'   \t=> 'GET',\n            'ctype'\t\t=> 'text/plain'\n          }, 20)\n\n          if(not res or ((res.code.to_i == ecode) or (emesg and res.body.index(emesg))))\n            if dm == false\n              print_status(\"NOT Found #{filec} #{res.code} [#{wmap_target_host}] [#{res.code.to_i}]\")\n            end\n          else\n            if ecode != 400 and res.code.to_i == 400\n              print_error(\"[#{wmap_target_host}] Server returned a 400 error on #{wmap_base_url}#{filec} [#{res.code.to_i}]\")\n            else\n              print_good(\"[#{wmap_target_host}] Found #{wmap_base_url}#{filec} [#{res.code.to_i}]\")\n\n              report_web_vuln(\n                :host\t=> ip,\n                :port\t=> rport,\n                :vhost  => vhost,\n                :ssl    => ssl,\n                :path\t=> \"#{filec}\",\n                :method => 'GET',\n                :pname  => \"\",\n                :proof  => \"Res code: #{res.code.to_s}\",\n                :risk   => 0,\n                :confidence   => 100,\n                :category     => 'file',\n                :description  => 'Copy file found.',\n                :name   => 'copy of file'\n              )\n            end\n          end\n\n        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n        rescue ::Timeout::Error, ::Errno::EPIPE\n        end\n      end\n    end\n  end\nend\n"
}