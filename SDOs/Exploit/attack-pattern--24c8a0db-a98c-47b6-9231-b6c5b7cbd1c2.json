{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--24c8a0db-a98c-47b6-9231-b6c5b7cbd1c2",
    "created": "2024-08-14T16:26:49.088833Z",
    "modified": "2024-08-14T16:26:49.088837Z",
    "name": "BACnet Scanner",
    "description": " Discover BACnet devices by broadcasting Who-is message, then poll discovered devices for properties including model name software version, firmware revision and description. '",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/scada/bacnet_l3.rb",
            "external_id": "bacnet_l3.rb"
        }
    ],
    "x_code_snippet": "class MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Capture\n  include Rex::Socket::Udp\n\n  FILE_NAME = 'bacnet-discovery'.freeze\n  DEFAULT_SERVER_TIMEOUT = 1\n  DEFAULT_SEND_COUNT = 1\n  DEFAULT_SLEEP = 1\n\n  BACNET_ASHARE_STANDARD = \"\\x01\".freeze\n  BACNETIP_CONSTANT = \"\\x81\".freeze\n  BACNET_LLC = \"\\x82\\x82\\x03\".freeze\n  BACNET_BVLC = \"\\x81\\x0b\\x00\\x0c\".freeze\n  BACNET_BVLC_LEN = BACNET_BVLC.length\n\n  BACNET_WHOIS_APDU_NPDU = \"\\x01\\x20\\xff\\xff\\x00\\xff\\x10\\x08\".freeze\n\n  # Building Automation and Control Network APDU\n  #     0001 .... = APDU Type: Unconfirmed-REQ (1)\n  #     Unconfirmed Service Choice: i-Am (0)\n  #     ObjectIdentifier: device\n  BACNET_UNCOFIRMED_REQ_I_AM_OBJ_DEVICE_PREFIX = \"\\x10\\x00\\xc4\\x02\".freeze\n  DEFAULT_BACNET_PORT = 47808\n  DISCOVERY_MESSAGE_L3 = BACNET_BVLC + BACNET_WHOIS_APDU_NPDU\n  DISCOVERY_MESSAGE_L2 = BACNET_LLC + BACNET_WHOIS_APDU_NPDU\n  DISCOVERY_MESSAGE_L2_LEN = Array[DISCOVERY_MESSAGE_L2.length].pack('n')\n\n  READ_MULTIPLE_DEVICES_PROP = \"\\x1e\\x09\\x08\\x1f\".freeze\n  READ_MODEL_NAME_PROP = \"\\x19\\x46\".freeze\n  READ_FIRMWARE_VERSION_PROP = \"\\x19\\x2c\".freeze\n  READ_APP_SOFT_VERSION_PROP = \"\\x19\\x0c\".freeze\n  READ_DESCRIPTION_PROP = \"\\x19\\x1c\".freeze\n\n  GET_PROPERTY_MESSAGES_L3_SIMPLE = [\n    \"\\x81\\n\\u0000\\u0011\\u0001\\u0004\\u0002\\u0002\\u0000\\f\\f\\u0002{object_identifier}#{READ_MODEL_NAME_PROP}\", # model-name\n    \"\\x81\\n\\u0000\\u0011\\u0001\\u0004\\u0002\\u0002\\u0000\\f\\f\\u0002{object_identifier}#{READ_FIRMWARE_VERSION_PROP}\", # firmware-revision\n    \"\\x81\\n\\u0000\\u0011\\u0001\\u0004\\u0002\\u0002\\u0000\\f\\f\\u0002{object_identifier}#{READ_APP_SOFT_VERSION_PROP}\", # application-software-version\n    \"\\x81\\n\\u0000\\u0011\\u0001\\u0004\\u0002\\u0002\\u0000\\f\\f\\u0002{object_identifier}#{READ_DESCRIPTION_PROP}\"\n  ].freeze # description\n\n  GET_PROPERTY_MESSAGES_L3_NESTED = [\n    \"\\u0001${dest_net_id}{dadr_len}{dadr}\\xFF\\u0002\\u0002\\u0002\\f\\f\\u0002{object_identifier}#{READ_MODEL_NAME_PROP}\",\n    \"\\u0001${dest_net_id}{dadr_len}{dadr}\\xFF\\u0002\\u0002\\u0002\\f\\f\\u0002{object_identifier}#{READ_FIRMWARE_VERSION_PROP}\",\n    \"\\u0001${dest_net_id}{dadr_len}{dadr}\\xFF\\u0002\\u0002\\u0002\\f\\f\\u0002{object_identifier}#{READ_APP_SOFT_VERSION_PROP}\",\n    \"\\u0001${dest_net_id}{dadr_len}{dadr}\\xFF\\u0002\\u0002\\u0002\\f\\f\\u0002{object_identifier}#{READ_DESCRIPTION_PROP}\"\n  ].freeze\n\n  def initialize\n    super(\n      'Name' => 'BACnet Scanner',\n      'Description' => '\n        Discover BACnet devices by broadcasting Who-is message, then poll\n        discovered devices for properties including model name,\n        software version, firmware revision and description.\n      ',\n      'Author' => ['Paz @ SCADAfence'],\n      'License' => MSF_LICENSE,\n      'Notes' => {\n        'Stability' => [CRASH_SAFE],\n        'Reliability' => [UNRELIABLE_SESSION],\n        'SideEffects' => [SCREEN_EFFECTS]\n      }\n    )\n\n    register_options(\n      [\n        OptInt.new('TIMEOUT', [true, 'The socket connect timeout in seconds', DEFAULT_SERVER_TIMEOUT]),\n        OptInt.new('COUNT', [true, 'The number of times to send each packet', DEFAULT_SEND_COUNT]),\n        OptPort.new('PORT', [true, 'BACnet/IP UDP port to scan (usually between 47808-47817)', DEFAULT_BACNET_PORT]),\n        OptString.new('INTERFACE', [true, 'The interface to scan from', 'eth1'])\n      ], self.class\n    )\n    deregister_options('RHOSTS', 'FILTER', 'PCAPFILE', 'LHOST')\n  end\n\n  def hex_to_bin(str)\n    str.scan(/../).map { |x| x.hex.chr }.join\n  end\n\n  def bin_to_hex(str)\n    str.each_byte.map { |b| b.to_s(16).rjust(2, '0') }.join\n  end\n\n  # Check if device is nested and extract relevant data\n  def parse_npdu(data)\n    is_nested = false\n    if data.start_with? BACNET_ASHARE_STANDARD\n      control = data[1].unpack1('C*')\n      src_specifier = control & (1 << 3) != 0  # check if 4th bit is set\n      dst_specifier = control & (1 << 5) != 0  # check if 6th bit is set\n\n      idx = 2\n      if dst_specifier\n        dst_len = data[idx + 2].ord\n        idx += 3 + dst_len\n      end\n      if src_specifier\n        src_net_id = data[idx..idx + 1]\n        sadr_len = data[idx + 2]\n        sadr = data[idx + 3..idx + 2 + sadr_len.unpack1('C*')]\n        is_nested = true\n      end\n\n      # if no network address specified - set as broadcast network address\n      src_net_id ||= '\\x00'\n    end\n    [is_nested, src_net_id, sadr_len, sadr]\n  end\n\n  # Extracting index to start handling the data from\n  def extract_index(data)\n    if data.start_with? BACNET_ASHARE_STANDARD\n      begin\n        control = data[1].unpack1('C*')\n        src_specifier = control & (1 << 3) != 0  # check if 4th bit is set\n        dst_specifier = control & (1 << 5) != 0  # check if 6th bit is set\n        idx = 2\n        if dst_specifier\n          idx += 3 + dst_len\n        end\n        if src_specifier\n          sadr_len = data[idx + 2]\n          idx += 3 + sadr_len.unpack1('C*')\n        end\n        idx += 1 if dst_specifier # increase index if both specifiers exist\n        idx\n      end\n    end\n  end\n\n  # Broadcasting Who-is and returns a capture with the responses.\n  def broadcast_who_is\n    begin\n      broadcast_addr = get_ipv4_broadcast(datastore['INTERFACE'])\n      interface_addr = get_ipv4_addr(datastore['INTERFACE'])\n    rescue StandardError\n      raise StandardError, \"Interface #{datastore['INTERFACE']} is down\"\n    end\n    cap = []\n\n    # Create a socket for broadcast response and a socket for unicast response.\n    lsocket = Rex::Socket::Udp.create({\n      'LocalHost' => broadcast_addr,\n      'LocalPort' => datastore['PORT'],\n      'Context' => { 'Msf' => framework, 'MsfExploit' => self }\n    })\n    ssocket = Rex::Socket::Udp.create({\n      'LocalHost' => interface_addr,\n      'LocalPort' => datastore['PORT'],\n      'Context' => { 'Msf' => framework, 'MsfExploit' => self }\n    })\n    datastore['COUNT'].times { lsocket.sendto(DISCOVERY_MESSAGE_L3, '255.255.255.255', datastore['PORT'], 0) }\n\n    # Collect responses with unicast or broadcast destination.\n    loop do\n      data, host, port = lsocket.recvfrom(65535, datastore['TIMEOUT'])\n      data2, host2, port2 = ssocket.recvfrom(65535, datastore['TIMEOUT'])\n      break if (host.nil? && host2.nil?)\n\n      cap << [data, host, port] if host\n      cap << [data2, host2, port2] if host2\n    end\n    lsocket.close\n    cap\n  end\n\n  # Analyze I-am packets,and prepare read-property messages for each.\n  def analyze_i_am_devices(capture)\n    devices_data = {}\n    instance_numbers = []\n    capture.each do |cap|\n      data = cap[0]\n      ip = cap[1]\n      next unless data[0] == BACNETIP_CONSTANT # If communication is not a bacnet/ip\n\n      data = data[4..]\n      index = data.index(BACNET_UNCOFIRMED_REQ_I_AM_OBJ_DEVICE_PREFIX)\n      next unless index # If cap has no I-am object\n\n      raw_instance_number = bin_to_hex(data[(index + BACNET_UNCOFIRMED_REQ_I_AM_OBJ_DEVICE_PREFIX.length)..(index + BACNET_UNCOFIRMED_REQ_I_AM_OBJ_DEVICE_PREFIX.length + 2)]).to_i(16) & 0x3fffff\n      instance_number = raw_instance_number.to_s(16).rjust(6, '0')\n      next if instance_numbers.include? instance_number # Pass if we already analysed this instance number\n\n      devices_data[[instance_number, ip]] = data unless devices_data[[instance_number, ip]]\n    end\n    devices_data\n  end\n\n  def create_messages_for_devices(devices_data)\n    messages = {}\n    devices_data.each do |key, data|\n      instance_number = hex_to_bin(key[0])\n      items = parse_npdu(data) # Get specifier data\n      # Check if device is nested and create messages accordingly\n      if items[0] == true\n        messages[key] = create_nested_messages(instance_number, items)\n      else\n        messages[key] = create_simple_messages(instance_number)\n      end\n    end\n    messages\n  end\n\n  # Create messages for nested device and return them in array.\n  def create_nested_messages(instance_number, items)\n    nested_messages = []\n    GET_PROPERTY_MESSAGES_L3_NESTED.each do |msg_base|\n      msg = msg_base\n            .sub('{object_identifier}', instance_number)\n            .sub('{dest_net_id}', items[1])\n            .sub('{dadr_len}', items[2])\n            .sub('{dadr}', items[3])\n      length = Array(msg.length + BACNET_BVLC_LEN).pack('n*')\n      msg = \"\\x81\\n#{length}#{msg}\"\n      nested_messages.append(msg)\n    end\n    nested_messages\n  end\n\n  # Create messages for non-nested device and return them in array.\n  def create_simple_messages(instance_number)\n    simple_messages = []\n    GET_PROPERTY_MESSAGES_L3_SIMPLE.each do |msg_base|\n      msg = msg_base.sub('{object_identifier}', instance_number)\n      simple_messages.append(msg)\n    end\n    simple_messages\n  end\n\n  # Loop on recorded packets and extract data from read-property messages\n  def extract_data(capture)\n    asset_data = {}\n    capture.each do |packet|\n      data = packet[0][4..]\n      items = parse_npdu(data)\n      index = extract_index(data)\n      asset_data['sadr'] = bin_to_hex(items[3]) if items[0] == true\n      type = data[index + 8..index + 9]\n      attribute = ''\n      case type\n      when READ_MODEL_NAME_PROP\n        attribute = 'model-name'\n      when READ_DESCRIPTION_PROP\n        attribute = 'description'\n      when READ_APP_SOFT_VERSION_PROP\n        attribute = 'application-software-version'\n      when READ_FIRMWARE_VERSION_PROP\n        attribute = 'firmware-revision'\n      else\n        raise \"undefined attribute for property number #{bin_to_hex(type)}.\"\n      end\n      value = bin_to_hex(data[index + 9..])[/3e(.*?)3f/m, 1]\n      value = hex_to_bin(value)\n      value = (value[value.index(hex_to_bin('00')) + 1..]).force_encoding('UTF-8') # parsing the needed text\n      asset_data[attribute] = value\n    end\n    asset_data\n  end\n\n  # Gets properties from devices and returns a hash with the details of each device.\n  def get_properties_from_devices(messages)\n    devices_by_ip = {}\n    messages.each do |key, message_block|\n      instance_number = key[0].to_i(16)\n      ip = key[1]\n\n      capture = send_read_properties(message_block, ip, instance_number)\n      begin\n        device = extract_data(capture)\n        raise StandardError if device.empty?\n\n        device['instance-number'] = instance_number.to_s\n        devices_by_ip[ip] = [] unless devices_by_ip[ip]\n        devices_by_ip[ip].append(device)\n      rescue StandardError\n        print_bad(\"Couldn't collect data for asset number #{instance_number}.\")\n      end\n    end\n    devices_by_ip\n  end\n\n  # Sending read-property packets and returns a pcap with the responses.\n  def send_read_properties(messages, ip, instance_number)\n    cap = []\n    ssocket = Rex::Socket::Udp.create({\n      'PeerHost' => ip,\n      'PeerPort' => datastore['PORT'],\n      'Context' => { 'Msf' => framework, 'MsfExploit' => self }\n    })\n    print_status(\"Querying device number #{instance_number} in ip #{ip}\")\n    messages.each do |message|\n      ssocket.sendto(message, ip, datastore['PORT'], 0)\n      loop do\n        data, host, port = ssocket.recvfrom(65535, datastore['TIMEOUT'])\n        break if host.nil?\n\n        cap << [data, host, port]\n      end\n    end\n    ssocket.close\n    cap\n  end\n\n  # Iterates over all the devices and prints the details to the user.\n  def output_results(devices_by_ip)\n    devices_by_ip.each_value do |ip_group|\n      ip_group.each do |asset|\n        sadr = ''\n        if asset['sadr']\n          sadr = \"sadr: #{asset['sadr']}\\n\"\n        end\n        print_good(<<~OUTPUT)\n          for asset number #{asset['instance-number']}:\n          \\tmodel name: #{asset['model-name']}\n          \\tfirmware revision: #{asset['firmware-revision']}\n          \\tapplication software version: #{asset['application-software-version']}\n          \\tdescription: #{asset['description']}\n          \\t#{sadr}\n        OUTPUT\n      end\n    end\n  end\n\n  # Convert data values to xml format.\n  def parse_data_to_xml(raw_data)\n    data = ''\n    raw_data.each do |ip, devices|\n      chunk = <<~IP.chomp\n        <ip>\n          <value> #{ip} </value>\n      IP\n      devices.each do |device|\n        sadr = ''\n        if device['sadr']\n          sadr = \"\n          <sadr> #{device['sadr']} </sadr>\"\n        end\n        chunk = <<~XML.chomp\n          #{chunk}\n              <asset>\n                <instance-number> #{device['instance-number']} </instance-number>\n                <model-name> #{device['model-name']} </model-name>\n                <application-software-version> #{device['application-software-version']} </application-software-version>\n                <firmware-revision> #{device['firmware-revision']} </firmware-revision>\n                <description> #{device['description']} </description>#{sadr}\n              </asset>\n        XML\n      end\n      chunk += <<~IP\n\n        </ip>\n      IP\n      data += chunk\n    end\n    data\n  end\n\n  def get_device_array(devices_by_ip)\n    devices = []\n    devices_by_ip.each do |ip, batch|\n      batch.each do |device|\n        device['ip'] = ip\n        devices << device\n      end\n    end\n    devices\n  end\n\n  def run\n    # Validate user input\n    raise Msf::OptionValidateError, ['TIMEOUT'] if datastore['TIMEOUT'].negative?\n    raise Msf::OptionValidateError, ['COUNT'] if datastore['COUNT'] < 1\n    raise Msf::OptionValidateError, ['INTERFACE'] if datastore['INTERFACE'].empty?\n\n    begin\n      # Broadcast who-is and create request-property messages for detected devices.\n      print_status \"Broadcasting Who-is via #{datastore['INTERFACE']}\"\n      capture = broadcast_who_is\n      devices_data = analyze_i_am_devices(capture)\n      messages = create_messages_for_devices(devices_data)\n\n      # If there are messages to send\n      if !messages.empty?\n        print_status \"found #{messages.length} devices\"\n        sleep(DEFAULT_SLEEP)\n        devices_by_ip = get_properties_from_devices(messages)\n        print_status 'Done collecting data'\n        sleep(DEFAULT_SLEEP)\n        output_results(devices_by_ip)\n      else\n        fail_with(Failure::NotFound, 'No devices found. Exiting.')\n      end\n    rescue StandardError => e\n      fail_with(Failure::Unknown, e.message)\n      return\n    end\n    begin\n      data = parse_data_to_xml(devices_by_ip)\n      begin\n        store_local('bacnet.devices.info'.dup, 'text/xml', data, FILE_NAME)\n        print_good(\"Successfully saved data to local store named #{FILE_NAME}.xml\")\n      rescue StandardError # If there are no privileges to save a file\n        devices = get_device_array(devices_by_ip)\n        report_note(\n          ips: devices_by_ip.keys,\n          devices: devices,\n          proto: 'udp'\n        )\n        print_good('Successfully reported data')\n      end\n      print_status('Done.')\n    rescue StandardError => e\n      fail_with(Failure::Unknown, e.message)\n    end\n  end\nend\n"
}