{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a992003a-c83d-4150-b645-8c58247ddb09",
    "created": "2024-08-14T16:31:13.643415Z",
    "modified": "2024-08-14T16:31:13.643418Z",
    "name": "SIP Username Enumerator (TCP)",
    "description": "Scan for numeric username/extensions using OPTIONS/REGISTER requests",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/sip/enumerator_tcp.rb",
            "external_id": "enumerator_tcp.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'SIP Username Enumerator (TCP)',\n      'Description' => 'Scan for numeric username/extensions using OPTIONS/REGISTER requests',\n      'Author'      => 'et',\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n    [\n      OptInt.new('MINEXT',   [true, 'Starting extension',0]),\n      OptInt.new('MAXEXT',   [true, 'Ending extension', 9999]),\n      OptInt.new('PADLEN',   [true, 'Cero padding maximum length', 4]),\n      OptEnum.new('METHOD',  [true, 'Enumeration method', 'REGISTER', ['OPTIONS', 'REGISTER']]),\n      Opt::RPORT(5060)\n    ])\n  end\n\n\n  # Operate on a single system at a time\n  def run_host(ip)\n\n    connect\n\n    begin\n      idx  = 0\n      mini = datastore['MINEXT']\n      maxi = datastore['MAXEXT']\n\n      for i in (mini..maxi)\n        testext = padnum(i,datastore['PADLEN'])\n        data    = \"\"\n\n        case datastore['METHOD']\n        when 'REGISTER'\n          data = create_probe(ip,testext,'REGISTER')\n        when 'OPTIONS'\n          data = create_probe(ip,testext,'OPTIONS')\n        end\n\n        begin\n          sock.put(data)\n          res = sock.get_once(-1, 5)\n          parse_reply(res,datastore['METHOD']) if res\n        rescue ::Interrupt\n          raise $!\n        rescue ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionRefused\n          nil\n        end\n      end\n    rescue ::EOFError\n    rescue ::Interrupt\n      raise $!\n    ensure\n      disconnect\n    end\n  end\n\n  #\n  # The response parsers\n  #\n  def parse_reply(resp,meth)\n\n    repcode = ''\n    agent  = ''\n    verbs = ''\n    serv  = ''\n    prox  = ''\n\n    if(resp =~ /^To\\:\\s*(.*)$/mi)\n      testn = \"#{$1.strip}\".split(';')[0]\n    end\n\n    case resp\n    when /^401/\n      print_good(\"Found user: #{testn} [Auth]\")\n      # Add Report\n      report_note(\n        :host\t=> rhost,\n        :proto\t=> 'sip',\n        :port\t=> rport,\n        :type\t=> \"Found user: #{testn} [Auth]\",\n        :data\t=> \"Found user: #{testn} [Auth]\"\n      )\n    when /^200/\n      print_good(\"Found user: #{testn} [Open]\")\n      # Add Report\n      report_note(\n        :host\t=> rhost,\n        :proto\t=> 'sip',\n        :port\t=> rport,\n        :type\t=> \"Found user: #{testn} [Open]\",\n        :data\t=> \"Found user: #{testn} [Open]\"\n      )\n    else\n      #print_error(\"Undefined error code: #{resp.to_i}\"\n    end\n  end\n\n  def create_probe(ip,toext,meth)\n    suser = Rex::Text.rand_text_alphanumeric(rand(8)+1)\n    shost = Rex::Socket.source_address(ip)\n    src   = \"#{shost}:#{datastore['RPORT']}\"\n\n    data  = \"#{meth} sip:#{toext}@#{ip} SIP/2.0\\r\\n\"\n    data << \"Via: SIP/2.0/TCP #{src};branch=z9hG4bK.#{\"%.8x\" % rand(0x100000000)};rport;alias\\r\\n\"\n    data << \"From: #{toext} <sip:#{suser}@#{src}>;tag=70c00e8c\\r\\n\"\n    data << \"To: #{toext} <sip:#{toext}@#{ip}>\\r\\n\"\n    data << \"Call-ID: #{rand(0x100000000)}@#{shost}\\r\\n\"\n    data << \"CSeq: 1 #{meth}\\r\\n\"\n    data << \"Contact: <sip:#{suser}@#{src}>\\r\\n\"\n    data << \"Max-Forwards: 20\\r\\n\"\n    data << \"User-Agent: #{suser}\\r\\n\"\n    data << \"Accept: text/plain\\r\\n\"\n    data << \"Content-Length: 0\\r\\n\"\n    data << \"\\r\\n\"\n    data\n  end\n\n  def padnum(num,padding)\n    if padding >= num.to_s.length\n      ('0'*(padding-num.to_s.length)) << num.to_s\n    end\n  end\nend\n"
}