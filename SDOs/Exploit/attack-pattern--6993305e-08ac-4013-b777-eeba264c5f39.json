{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6993305e-08ac-4013-b777-eeba264c5f39",
    "created": "2024-08-14T16:32:53.760928Z",
    "modified": "2024-08-14T16:32:53.760932Z",
    "name": "Password Cracker: Databases",
    "description": "( This module uses John the Ripper or Hashcat to identify weak passwords that have been acquired from the mssql_hashdump, mysql_hashdump, postgres_hashdump, or oracle_hashdump modules. Passwords that have been successfully cracked are then saved as proper credentials. Due to the complexity of some of the hash types, they can be very slow.  Setting the ITERATION_TIMEOUT is highly recommended. MSSQL is 131, 132, and 1731 in hashcat. MYSQL is 200, and 300 in hashcat. ORACLE is 112, and 12300 in hashcat. POSTGRES is 12 in hashcat. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/analyze/crack_databases.rb",
            "external_id": "crack_databases.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::PasswordCracker\n  include Msf::Exploit::Deprecated\n  moved_from 'auxiliary/analyze/jtr_mssql_fast'\n  moved_from 'auxiliary/analyze/jtr_mysql_fast'\n  moved_from 'auxiliary/analyze/jtr_oracle_fast'\n  moved_from 'auxiliary/analyze/jtr_postgres_fast'\n\n  def initialize\n    super(\n      'Name' => 'Password Cracker: Databases',\n      'Description' => %(\n          This module uses John the Ripper or Hashcat to identify weak passwords that have been\n        acquired from the mssql_hashdump, mysql_hashdump, postgres_hashdump, or oracle_hashdump modules.\n        Passwords that have been successfully cracked are then saved as proper credentials.\n        Due to the complexity of some of the hash types, they can be very slow.  Setting the\n        ITERATION_TIMEOUT is highly recommended.\n        MSSQL is 131, 132, and 1731 in hashcat.\n        MYSQL is 200, and 300 in hashcat.\n        ORACLE is 112, and 12300 in hashcat.\n        POSTGRES is 12 in hashcat.\n      ),\n      'Author' => [\n        'theLightCosine',\n        'hdm',\n        'h00die' # hashcat integration\n      ],\n      'License' => MSF_LICENSE, # JtR itself is GPLv2, but this wrapper is MSF (BSD)\n      'Actions' => [\n        ['john', { 'Description' => 'Use John the Ripper' }],\n        ['hashcat', { 'Description' => 'Use Hashcat' }],\n      ],\n      'DefaultAction' => 'john',\n    )\n\n    register_options(\n      [\n        OptBool.new('MSSQL', [false, 'Include MSSQL hashes', true]),\n        OptBool.new('MYSQL', [false, 'Include MySQL hashes', true]),\n        OptBool.new('ORACLE', [false, 'Include Oracle hashes', true]),\n        OptBool.new('POSTGRES', [false, 'Include Postgres hashes', true]),\n        OptBool.new('INCREMENTAL', [false, 'Run in incremental mode', true]),\n        OptBool.new('WORDLIST', [false, 'Run in wordlist mode', true])\n      ]\n    )\n  end\n\n  def show_command(cracker_instance)\n    return unless datastore['ShowCommand']\n\n    if action.name == 'john'\n      cmd = cracker_instance.john_crack_command\n    elsif action.name == 'hashcat'\n      cmd = cracker_instance.hashcat_crack_command\n    end\n    print_status(\"   Cracking Command: #{cmd.join(' ')}\")\n  end\n\n  def run\n    def check_results(passwords, results, hash_type, method)\n      passwords.each do |password_line|\n        password_line.chomp!\n        next if password_line.blank?\n\n        fields = password_line.split(':')\n        cred = { 'hash_type' => hash_type, 'method' => method }\n\n        if action.name == 'john'\n          next unless fields.count >= 3\n\n          cred['username'] = fields.shift\n          cred['core_id'] = fields.pop\n          cred['password'] = fields.join(':') # Anything left must be the password. This accounts for passwords with semi-colons in it\n        elsif action.name == 'hashcat'\n          next unless fields.count >= 2\n\n          case hash_type\n          when 'dynamic_1034'\n            # for postgres we get 4 fields, id:hash:un:pass.\n            cred['core_id'] = fields.shift\n            cred['hash'] = fields.shift\n            cred['username'] = fields.shift\n            cred['password'] = fields.join(':')\n          when 'oracle11', 'raw-sha1,oracle'\n            cred['core_id'] = fields.shift\n            cred['hash'] = \"#{fields.shift}#{fields.shift}\" # we pull the first two fields, hash and salt\n            cred['password'] = fields.join(':')\n          else\n            cred['core_id'] = fields.shift\n            cred['hash'] = fields.shift\n            cred['password'] = fields.join(':') # Anything left must be the password. This accounts for passwords with semi-colons in it\n          end\n\n          next if cred['core_id'].include?(\"Hashfile '\") && cred['core_id'].include?(\"' on line \") # skip error lines\n\n          # we don't have the username since we overloaded it with the core_id (since its a better fit for us)\n          # so we can now just go grab the username from the DB\n          cred['username'] = framework.db.creds(workspace: myworkspace, id: cred['core_id'])[0].public.username\n        end\n        results = process_cracker_results(results, cred)\n      end\n      results\n    end\n\n    tbl = tbl = cracker_results_table\n\n    # array of hashes in jtr_format in the db, converted to an OR combined regex\n    hash_types_to_crack = []\n\n    if datastore['MSSQL']\n      hash_types_to_crack << 'mssql'\n      hash_types_to_crack << 'mssql05'\n      hash_types_to_crack << 'mssql12'\n    end\n    if datastore['MYSQL']\n      hash_types_to_crack << 'mysql'\n      hash_types_to_crack << 'mysql-sha1'\n    end\n    if datastore['ORACLE']\n      # dynamic_1506 is oracle 11/12's H field, MD5.\n\n      # hashcat requires a format we dont have all the data for\n      # in the current dumper, so this is disabled in module and lib\n      if action.name == 'john'\n        hash_types_to_crack << 'oracle'\n        hash_types_to_crack << 'dynamic_1506'\n      end\n      hash_types_to_crack << 'oracle11'\n      hash_types_to_crack << 'oracle12c'\n    end\n    if datastore['POSTGRES']\n      hash_types_to_crack << 'dynamic_1034'\n    end\n\n    jobs_to_do = []\n\n    # build our job list\n    hash_types_to_crack.each do |hash_type|\n      job = hash_job(hash_type, action.name)\n      if job.nil?\n        print_status(\"No #{hash_type} found to crack\")\n      else\n        jobs_to_do << job\n      end\n    end\n\n    # bail early of no jobs to do\n    if jobs_to_do.empty?\n      print_good(\"No uncracked password hashes found for: #{hash_types_to_crack.join(', ')}\")\n      return\n    end\n\n    # array of arrays for cracked passwords.\n    # Inner array format: db_id, hash_type, username, password, method_of_crack\n    results = []\n\n    cracker = new_password_cracker(action.name)\n\n    # generate our wordlist and close the file handle.\n    wordlist = wordlist_file\n    unless wordlist\n      print_error('This module cannot run without a database connected. Use db_connect to connect to a database.')\n      return\n    end\n\n    wordlist.close\n    print_status \"Wordlist file written out to #{wordlist.path}\"\n\n    cleanup_files = [wordlist.path]\n\n    jobs_to_do.each do |job|\n      format = job['type']\n      hash_file = Rex::Quickfile.new(\"hashes_#{job['type']}_\")\n      hash_file.puts job['formatted_hashlist']\n      hash_file.close\n      cracker.hash_path = hash_file.path\n      cleanup_files << hash_file.path\n\n      # dupe our original cracker so we can safely change options between each run\n      cracker_instance = cracker.dup\n      cracker_instance.format = format\n\n      if action.name == 'john'\n        cracker_instance.fork = datastore['FORK']\n      end\n\n      # first check if anything has already been cracked so we don't report it incorrectly\n      print_status \"Checking #{format} hashes already cracked...\"\n      results = check_results(cracker_instance.each_cracked_password, results, format, 'Already Cracked/POT')\n      vprint_good(append_results(tbl, results)) unless results.empty?\n      job['cred_ids_left_to_crack'] = job['cred_ids_left_to_crack'] - results.map { |i| i[0].to_i } # remove cracked hashes from the hash list\n      next if job['cred_ids_left_to_crack'].empty?\n\n      if action.name == 'john'\n        print_status \"Cracking #{format} hashes in single mode...\"\n        cracker_instance.mode_single(wordlist.path)\n        show_command cracker_instance\n        cracker_instance.crack do |line|\n          vprint_status line.chomp\n        end\n        results = check_results(cracker_instance.each_cracked_password, results, format, 'Single')\n        vprint_good(append_results(tbl, results)) unless results.empty?\n        job['cred_ids_left_to_crack'] = job['cred_ids_left_to_crack'] - results.map { |i| i[0].to_i } # remove cracked hashes from the hash list\n        next if job['cred_ids_left_to_crack'].empty?\n\n        print_status \"Cracking #{format} hashes in normal mode...\"\n        cracker_instance.mode_normal\n        show_command cracker_instance\n        cracker_instance.crack do |line|\n          vprint_status line.chomp\n        end\n        results = check_results(cracker_instance.each_cracked_password, results, format, 'Normal')\n        vprint_good(append_results(tbl, results)) unless results.empty?\n        job['cred_ids_left_to_crack'] = job['cred_ids_left_to_crack'] - results.map { |i| i[0].to_i } # remove cracked hashes from the hash list\n        next if job['cred_ids_left_to_crack'].empty?\n      end\n\n      if datastore['INCREMENTAL']\n        print_status \"Cracking #{format} hashes in incremental mode...\"\n        cracker_instance.mode_incremental\n        show_command cracker_instance\n        cracker_instance.crack do |line|\n          vprint_status line.chomp\n        end\n        results = check_results(cracker_instance.each_cracked_password, results, format, 'Incremental')\n        vprint_good(append_results(tbl, results)) unless results.empty?\n        job['cred_ids_left_to_crack'] = job['cred_ids_left_to_crack'] - results.map { |i| i[0].to_i } # remove cracked hashes from the hash list\n        next if job['cred_ids_left_to_crack'].empty?\n      end\n\n      if datastore['WORDLIST']\n        print_status \"Cracking #{format} hashes in wordlist mode...\"\n        cracker_instance.mode_wordlist(wordlist.path)\n        # Turn on KoreLogic rules if the user asked for it\n        if action.name == 'john' && datastore['KORELOGIC']\n          cracker_instance.rules = 'KoreLogicRules'\n          print_status 'Applying KoreLogic ruleset...'\n        end\n        show_command cracker_instance\n        cracker_instance.crack do |line|\n          vprint_status line.chomp\n        end\n\n        results = check_results(cracker_instance.each_cracked_password, results, format, 'Wordlist')\n        vprint_good(append_results(tbl, results)) unless results.empty?\n        job['cred_ids_left_to_crack'] = job['cred_ids_left_to_crack'] - results.map { |i| i[0].to_i } # remove cracked hashes from the hash list\n        next if job['cred_ids_left_to_crack'].empty?\n      end\n\n      # give a final print of results\n      print_good(append_results(tbl, results))\n    end\n    if datastore['DeleteTempFiles']\n      cleanup_files.each do |f|\n        File.delete(f)\n      end\n    end\n  end\nend\n"
}