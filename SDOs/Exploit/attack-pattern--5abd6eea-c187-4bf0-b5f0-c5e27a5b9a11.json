{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5abd6eea-c187-4bf0-b5f0-c5e27a5b9a11",
    "created": "2024-08-14T16:22:57.168598Z",
    "modified": "2024-08-14T16:22:57.168603Z",
    "name": "TFTP File Transfer Utility",
    "description": " This module will transfer a file to or from a remote TFTP server. Note that the target must be able to connect back to the Metasploit system and NAT traversal for TFTP is often unsupported.  Two actions are supported: \"Upload\" and \"Download,\" which behave as one might expect -- use 'set action Actionname' to use either mode of operation.  If \"Download\" is selected, at least one of FILENAME or REMOTE_FILENAME must be set. If \"Upload\" is selected, either FILENAME must be set to a valid path to a source file, or FILEDATA must be populated. FILENAME may be a fully qualified path or the name of a file in the Msf::Config.local_directory or Msf::Config.data_directory. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/tftp/tftp_transfer_util.rb",
            "external_id": "tftp_transfer_util.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.faqs.org/rfcs/rfc1350.html"
        },
        {
            "source_name": "reference",
            "url": "http://www.networksorcery.com/enp/protocol/tftp.htm"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Rex::Proto::TFTP\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'TFTP File Transfer Utility',\n      'Description' => %q{\n          This module will transfer a file to or from a remote TFTP server.\n          Note that the target must be able to connect back to the Metasploit system,\n          and NAT traversal for TFTP is often unsupported.\n\n          Two actions are supported: \"Upload\" and \"Download,\" which behave as one might\n          expect -- use 'set action Actionname' to use either mode of operation.\n\n          If \"Download\" is selected, at least one of FILENAME or REMOTE_FILENAME\n          must be set. If \"Upload\" is selected, either FILENAME must be set to a valid path to\n          a source file, or FILEDATA must be populated. FILENAME may be a fully qualified path,\n          or the name of a file in the Msf::Config.local_directory or Msf::Config.data_directory.\n        },\n      'Author'      => [ 'todb' ],\n      'References'  =>\n        [\n          ['URL', 'http://www.faqs.org/rfcs/rfc1350.html'],\n          ['URL', 'http://www.networksorcery.com/enp/protocol/tftp.htm']\n        ],\n      'Actions' => [\n          [ 'Download', 'Description' => \"Download REMOTE_FILENAME as FILENAME from the server.\"],\n          [ 'Upload',   'Description' => \"Upload FILENAME as REMOTE_FILENAME to the server.\"]\n        ],\n      'DefaultAction' => 'Upload',\n      'License'     => MSF_LICENSE\n    )\n    register_options([\n      OptString.new( 'FILENAME', [false, \"The local filename\" ]),\n      OptString.new( 'FILEDATA', [false, \"Data to upload in lieu of a real local file.\" ]),\n      OptString.new( 'REMOTE_FILENAME', [false, \"The remote filename\"]),\n      OptAddress.new('RHOST',    [true, \"The remote TFTP server\"]),\n      OptPort.new(   'LPORT',    [false, \"The local port the TFTP client should listen on (default is random)\" ]),\n      OptAddressLocal.new('LHOST',    [false, \"The local address the TFTP client should bind to\"]),\n      OptString.new( 'MODE',     [false, \"The TFTP mode; usual choices are netascii and octet.\", \"octet\"]),\n      Opt::RPORT(69)\n    ])\n  end\n\n  def mode\n    datastore['MODE'] || \"octect\"\n  end\n\n  def remote_file\n    return datastore['REMOTE_FILENAME'] if datastore['REMOTE_FILENAME']\n    return ::File.split(datastore['FILENAME']).last if datastore['FILENAME']\n  end\n\n  def rport\n    datastore['RPORT'] || 69\n  end\n\n  def rhost\n    datastore['RHOST']\n  end\n\n  # Used only to store loot, doesn't actually have any semantic meaning\n  # for the TFTP protocol.\n  def datatype\n    case datastore['MODE']\n    when \"netascii\"\n      \"text/plain\"\n    else\n      \"application/octet-stream\"\n    end\n  end\n\n  def file\n    if action.name == \"Upload\"\n      fdata = datastore['FILEDATA'].to_s\n      fname = datastore['FILENAME'].to_s\n      if not fdata.empty?\n        fdata_decorated = \"DATA:#{datastore['FILEDATA']}\"\n      elsif ::File.readable? fname\n        fname\n      else\n        fname_local = ::File.join(Msf::Config.local_directory,fname)\n        fname_data  = ::File.join(Msf::Config.data_directory,fname)\n        return fname_local if ::File.file?(fname_local) and ::File.readable?(fname_local)\n        return fname_data  if ::File.file?(fname_data)  and ::File.readable?(fname_data)\n        return nil # Couldn't find it, giving up.\n      end\n    else # \"Download\"\n      fname = ::File.split(datastore['FILENAME'] || datastore['REMOTE_FILENAME']).last rescue nil\n    end\n  end\n\n  # Experimental message prepending thinger. Might make it up into the\n  # standard Metasploit lib like vprint_status and friends.\n  def rtarget(ip=nil)\n    if (ip or rhost) and rport\n      [(ip || rhost),rport].map {|x| x.to_s}.join(\":\") << \" \"\n    elsif (ip or rhost)\n      \"#{rhost} \"\n    else\n      \"\"\n    end\n  end\n\n  # This all happens before run(), and should give an idea on how to use\n  # the TFTP client mixin. Essentially, you create an instance of the\n  # Rex::Proto::TFTP::Client class, fill it up with the relevant host and\n  # file data, set it to either :upload or :download, then kick off the\n  # transfer as you like.\n  def setup\n    @lport = datastore['LPORT'] || (1025 + rand(0xffff-1025))\n    @lhost = datastore['LHOST'] || \"0.0.0.0\"\n    @local_file = file\n    @remote_file = remote_file\n\n    @tftp_client = Rex::Proto::TFTP::Client.new(\n      \"LocalHost\"  => @lhost,\n      \"LocalPort\"  => @lport,\n      \"PeerHost\"   => rhost,\n      \"PeerPort\"   => rport,\n      \"LocalFile\"  => @local_file,\n      \"RemoteFile\" => @remote_file,\n      \"Mode\"       => mode,\n      \"Context\"    => {'Msf' => self.framework, 'MsfExploit' => self},\n      \"Action\"     => action.name.to_s.downcase.intern\n    )\n  end\n\n  def run\n    case action.name\n    when 'Upload'\n      if file\n        run_upload()\n      else\n        print_error \"Need at least a local file name or file data to upload.\"\n        return\n      end\n    when 'Download'\n      if remote_file\n        run_download()\n      else\n        print_error \"Need at least a remote file name to download.\"\n        return\n      end\n    else\n      print_error \"Unknown action: '#{action.name}'\"\n    end\n    while not @tftp_client.complete\n      select(nil,nil,nil,1)\n      print_status [rtarget,\"TFTP transfer operation complete.\"].join\n      save_downloaded_file() if action.name == 'Download'\n      break\n    end\n  end\n\n  # Run in case something untoward happend with the connection and the\n  # client object didn't get stopped on its own. This can happen with\n  # transfers that got interrupted or malformed (like sending a 0 byte\n  # file).\n  def cleanup\n    if @tftp_client and @tftp_client.respond_to? :complete\n      while not @tftp_client.complete\n        select(nil,nil,nil,1)\n        vprint_status \"Cleaning up the TFTP client ports and threads.\"\n        @tftp_client.stop\n      end\n    end\n  end\n\n  def run_upload\n    print_status \"Sending '#{file}' to #{rhost}:#{rport} as '#{remote_file}'\"\n    ret = @tftp_client.send_write_request { |msg| print_tftp_status(msg) }\n  end\n\n  def run_download\n    print_status \"Receiving '#{remote_file}' from #{rhost}:#{rport} as '#{file}'\"\n    ret = @tftp_client.send_read_request { |msg| print_tftp_status(msg) }\n  end\n\n  def save_downloaded_file\n    print_status \"Saving #{remote_file} as '#{file}'\"\n    fh = @tftp_client.recv_tempfile\n    data = File.open(fh,\"rb\") {|f| f.read f.stat.size} rescue nil\n    if data and not data.empty?\n      unless framework.db.active\n        print_status \"No database connected, so not actually saving the data:\"\n        print_line data\n      end\n      this_service = report_service(\n        :host => rhost,\n        :port => rport,\n        :name => \"tftp\",\n        :proto => \"udp\"\n      )\n      store_loot(\"tftp.file\",datatype,rhost,data,file,remote_file,this_service)\n    else\n      print_status [rtarget,\"Did not find any data, so nothing to save.\"].join\n    end\n    fh.unlink rescue nil # Windows often complains about unlinking tempfiles\n  end\n\n  def print_tftp_status(msg)\n    case msg\n    when /Aborting/, /errors.$/\n      print_error [rtarget,msg].join\n    when /^WRQ accepted/, /^Sending/, /complete!$/\n      print_good [rtarget,msg].join\n    else\n      vprint_status [rtarget,msg].join\n    end\n  end\nend\n"
}