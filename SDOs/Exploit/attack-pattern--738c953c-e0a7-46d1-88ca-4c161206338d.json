{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--738c953c-e0a7-46d1-88ca-4c161206338d",
    "created": "2024-08-14T16:31:26.839049Z",
    "modified": "2024-08-14T16:31:26.839053Z",
    "name": "Misconfigured Certificate Template Finder",
    "description": " This module allows users to query a LDAP server for vulnerable certificate templates and will print these certificates out in a table along with which attack they are vulnerable to and the SIDs that can be used to enroll in that certificate template.  Additionally the module will also print out a list of known certificate servers along with info about which vulnerable certificate templates the certificate server allows enrollment in and which SIDs are authorized to use that certificate server to perform this enrollment operation.  Currently the module is capable of checking for ESC1, ESC2, and ESC3 vulnerable certificates. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/ldap_esc_vulnerable_cert_finder.rb",
            "external_id": "ldap_esc_vulnerable_cert_finder.rb"
        }
    ],
    "x_code_snippet": "class MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::LDAP\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Misconfigured Certificate Template Finder',\n        'Description' => %q{\n          This module allows users to query a LDAP server for vulnerable certificate\n          templates and will print these certificates out in a table along with which\n          attack they are vulnerable to and the SIDs that can be used to enroll in that\n          certificate template.\n\n          Additionally the module will also print out a list of known certificate servers\n          along with info about which vulnerable certificate templates the certificate server\n          allows enrollment in and which SIDs are authorized to use that certificate server to\n          perform this enrollment operation.\n\n          Currently the module is capable of checking for ESC1, ESC2, and ESC3 vulnerable certificates.\n        },\n        'Author' => [\n          'Grant Willcox', # Original module author\n        ],\n        'References' => [\n          'URL' => 'https://posts.specterops.io/certified-pre-owned-d95910965cd2'\n        ],\n        'DisclosureDate' => '2021-06-17',\n        'License' => MSF_LICENSE,\n        'DefaultOptions' => {\n          'SSL' => false\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [IOC_IN_LOGS],\n          'Reliability' => []\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('BASE_DN', [false, 'LDAP base DN if you already have it']),\n      OptBool.new('REPORT_NONENROLLABLE', [true, 'Report nonenrollable certificate templates', false])\n    ])\n  end\n\n  # Constants Definition\n  CERTIFICATE_ENROLLMENT_EXTENDED_RIGHT = '0e10c968-78fb-11d2-90d4-00c04f79dc55'.freeze\n  CERTIFICATE_AUTOENROLLMENT_EXTENDED_RIGHT = 'a05b8cc2-17bc-4802-a710-e7c15ab866a2'.freeze\n  CONTROL_ACCESS = 0x00000100\n\n  # LDAP_SERVER_SD_FLAGS constant definition, taken from https://ldapwiki.com/wiki/LDAP_SERVER_SD_FLAGS_OID\n  LDAP_SERVER_SD_FLAGS_OID = '1.2.840.113556.1.4.801'.freeze\n  OWNER_SECURITY_INFORMATION = 0x1\n  GROUP_SECURITY_INFORMATION = 0x2\n  DACL_SECURITY_INFORMATION = 0x4\n  SACL_SECURITY_INFORMATION = 0x8\n\n  def parse_acl(acl)\n    allowed_sids = []\n    acl.aces.each do |ace|\n      ace_header = ace[:header]\n      ace_body = ace[:body]\n      if ace_body[:access_mask].blank?\n        fail_with(Failure::UnexpectedReply, 'Encountered a DACL/SACL object without an access mask! Either data is an unrecognized type or we are reading it wrong!')\n      end\n      ace_type_name = Rex::Proto::MsDtyp::MsDtypAceType.name(ace_header[:ace_type])\n      if ace_type_name.blank?\n        print_error(\"Skipping unexpected ACE of type #{ace_header[:ace_type]}. Either the data was read incorrectly or we currently don't support this type.\")\n        next\n      end\n      if ace_header[:ace_flags][:inherit_only_ace] == 1\n        vprint_warning('      ACE only affects those that inherit from it, not those that it is attached to. Ignoring this ACE, as its not relevant.')\n        next\n      end\n\n      # To decode the ObjectType we need to do another query to CN=Configuration,DC=daforest,DC=com\n      # and look at either schemaIDGUID or rightsGUID fields to see if they match this value.\n      if (object_type = ace_body[:object_type]) && !(object_type == CERTIFICATE_ENROLLMENT_EXTENDED_RIGHT || object_type == CERTIFICATE_AUTOENROLLMENT_EXTENDED_RIGHT)\n        # If an object type was specified, only process the rest if it is one of these two (note that objects with no\n        # object types will be processed to make sure we can detect vulnerable templates post exploiting ESC4).\n        next\n      end\n\n      # Skip entry if it is not related to an extended access control right, where extended access control right is\n      # described as ADS_RIGHT_DS_CONTROL_ACCESS in the ObjectType field of ACCESS_ALLOWED_OBJECT_ACE. This is\n      # detailed further at https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-access_allowed_object_ace\n      next unless (ace_body.access_mask.protocol & CONTROL_ACCESS) == CONTROL_ACCESS\n\n      if ace_type_name.match(/ALLOWED/)\n        allowed_sids << ace_body[:sid].to_s\n      end\n    end\n\n    allowed_sids\n  end\n\n  def query_ldap_server(raw_filter, attributes, base_prefix: nil)\n    ldap_connect do |ldap|\n      validate_bind_success!(ldap)\n\n      if !@base_dn.blank?\n        vprint_status(\"Using already discovered base DN: #{@base_dn}\")\n      elsif (@base_dn = datastore['BASE_DN'])\n        print_status(\"User-specified base DN: #{@base_dn}\")\n      else\n        print_status('Discovering base DN automatically')\n\n        unless (@base_dn = discover_base_dn(ldap))\n          print_warning(\"Couldn't discover base DN!\")\n        end\n      end\n\n      if @base_dn.blank?\n        fail_with(Failure::BadConfig, 'No base DN was found or specified, cannot continue!')\n      end\n\n      if base_prefix.blank?\n        full_base_dn = @base_dn.to_s\n      else\n        full_base_dn = \"#{base_prefix},#{@base_dn}\"\n      end\n      begin\n        filter = Net::LDAP::Filter.construct(raw_filter)\n      rescue StandardError => e\n        fail_with(Failure::BadConfig, \"Could not compile the filter! Error was #{e}\")\n      end\n\n      # Set the value of LDAP_SERVER_SD_FLAGS_OID flag so everything but\n      # the SACL flag is set, as we need administrative privileges to retrieve\n      # the SACL from the ntSecurityDescriptor attribute on Windows AD LDAP servers.\n      #\n      # Note that without specifying the LDAP_SERVER_SD_FLAGS_OID control in this manner,\n      # the LDAP searchRequest will default to trying to grab all possible attributes of\n      # the ntSecurityDescriptor attribute, hence resulting in an attempt to retrieve the\n      # SACL even if the user is not an administrative user.\n      #\n      # Now one may think that we would just get the rest of the data without the SACL field,\n      # however in reality LDAP will cause that attribute to just be blanked out if a part of it\n      # cannot be retrieved, so we just will get nothing for the ntSecurityDescriptor attribute\n      # in these cases if the user doesn't have permissions to read the SACL.\n      all_but_sacl_flag = OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION\n      control_values = [all_but_sacl_flag].map(&:to_ber).to_ber_sequence.to_s.to_ber\n      controls = []\n      controls << [LDAP_SERVER_SD_FLAGS_OID.to_ber, true.to_ber, control_values].to_ber_sequence\n\n      returned_entries = ldap.search(base: full_base_dn, filter: filter, attributes: attributes, controls: controls)\n      query_result_table = ldap.get_operation_result.table\n\n      validate_query_result!(query_result_table, filter)\n\n      if returned_entries.blank?\n        vprint_error(\"No results found for #{filter}.\")\n\n        nil\n      else\n\n        returned_entries\n      end\n    end\n  rescue Rex::ConnectionTimeout\n    fail_with(Failure::Unreachable, \"Couldn't reach #{datastore['RHOST']}!\")\n  rescue Net::LDAP::Error => e\n    fail_with(Failure::UnexpectedReply, \"Could not query #{datastore['RHOST']}! Error was: #{e.message}\")\n  end\n\n  def query_ldap_server_certificates(esc_raw_filter, esc_name)\n    attributes = ['cn', 'description', 'ntSecurityDescriptor']\n    base_prefix = 'CN=Certificate Templates,CN=Public Key Services,CN=Services,CN=Configuration'\n    esc_entries = query_ldap_server(esc_raw_filter, attributes, base_prefix: base_prefix)\n\n    if esc_entries.blank?\n      print_warning(\"Couldn't find any vulnerable #{esc_name} templates!\")\n      return\n    end\n\n    # Grab a list of certificates that contain vulnerable settings.\n    # Also print out the list of SIDs that can enroll in that server.\n    esc_entries.each do |entry|\n      begin\n        security_descriptor = Rex::Proto::MsDtyp::MsDtypSecurityDescriptor.read(entry[:ntsecuritydescriptor][0])\n      rescue IOError => e\n        fail_with(Failure::UnexpectedReply, \"Unable to read security descriptor! Error was: #{e.message}\")\n      end\n\n      allowed_sids = parse_acl(security_descriptor.dacl) if security_descriptor.dacl\n      next if allowed_sids.empty?\n\n      certificate_symbol = entry[:cn][0].to_sym\n      if @vuln_certificate_details.key?(certificate_symbol)\n        @vuln_certificate_details[certificate_symbol][:vulns] << esc_name\n      else\n        @vuln_certificate_details[certificate_symbol] = { vulns: [esc_name], dn: entry[:dn][0], certificate_enrollment_sids: convert_sids_to_human_readable_name(allowed_sids), ca_servers_n_enrollment_sids: {} }\n      end\n    end\n  end\n\n  def convert_sids_to_human_readable_name(sids_array)\n    output = []\n    for sid in sids_array\n      raw_filter = \"(objectSID=#{sid})\"\n      attributes = ['sAMAccountName', 'name']\n      base_prefix = 'CN=Configuration'\n      sid_entry = query_ldap_server(raw_filter, attributes, base_prefix: base_prefix) # First try with prefix to find entries that may be group specific.\n      sid_entry = query_ldap_server(raw_filter, attributes) if sid_entry.blank? # Retry without prefix if blank.\n      if sid_entry.blank?\n        print_warning(\"Could not find any details on the LDAP server for SID #{sid}!\")\n        output << [sid, nil, nil] # Still want to print out the SID even if we couldn't get additional information.\n      elsif sid_entry[0][:samaccountname][0]\n        output << [sid, sid_entry[0][:name][0], sid_entry[0][:samaccountname][0]]\n      else\n        output << [sid, sid_entry[0][:name][0], nil]\n      end\n    end\n\n    result = []\n    output.each do |sid_string, sid_name, sam_account_name|\n      if sam_account_name\n        result << \"#{sid_string} (#{sam_account_name})\"\n      else\n        result << \"#{sid_string} (#{sid_name})\"\n      end\n    end\n\n    result.join(' | ')\n  end\n\n  def find_esc1_vuln_cert_templates\n    esc1_raw_filter = '(&'\\\n      '(objectclass=pkicertificatetemplate)'\\\n      '(!(mspki-enrollment-flag:1.2.840.113556.1.4.804:=2))'\\\n      '(|(mspki-ra-signature=0)(!(mspki-ra-signature=*)))'\\\n      '(|'\\\n        '(pkiextendedkeyusage=1.3.6.1.4.1.311.20.2.2)'\\\n        '(pkiextendedkeyusage=1.3.6.1.5.5.7.3.2)'\\\n        '(pkiextendedkeyusage=1.3.6.1.5.2.3.4)'\\\n        '(pkiextendedkeyusage=2.5.29.37.0)'\\\n        '(!(pkiextendedkeyusage=*))'\\\n      ')'\\\n      '(mspki-certificate-name-flag:1.2.840.113556.1.4.804:=1)'\\\n    ')'\n    query_ldap_server_certificates(esc1_raw_filter, 'ESC1')\n  end\n\n  def find_esc2_vuln_cert_templates\n    esc2_raw_filter = '(&'\\\n      '(objectclass=pkicertificatetemplate)'\\\n      '(!(mspki-enrollment-flag:1.2.840.113556.1.4.804:=2))'\\\n      '(|(mspki-ra-signature=0)(!(mspki-ra-signature=*)))'\\\n      '(|'\\\n        '(pkiextendedkeyusage=2.5.29.37.0)'\\\n        '(!(pkiextendedkeyusage=*))'\\\n      ')'\\\n    ')'\n\n    query_ldap_server_certificates(esc2_raw_filter, 'ESC2')\n  end\n\n  def find_esc3_vuln_cert_templates\n    # Find the first vulnerable types of ESC3 templates, those that have the OID of the\n    # Certificate Request Agent which allows the template to be used for\n    # requesting other certificate templates on behalf of other principals.\n    esc3_template_1_raw_filter = '(&'\\\n      '(objectclass=pkicertificatetemplate)'\\\n      '(!(mspki-enrollment-flag:1.2.840.113556.1.4.804:=2))'\\\n      '(|'\\\n        '(mspki-ra-signature=0)'\\\n        '(!(mspki-ra-signature=*))'\\\n      ')'\\\n      '(pkiextendedkeyusage=1.3.6.1.4.1.311.20.2.1)'\\\n    ')'\n    query_ldap_server_certificates(esc3_template_1_raw_filter, 'ESC3_TEMPLATE_1')\n\n    # Find the second vulnerable types of ESC3 templates, those that\n    # have the right template schema version and, for those with a template\n    # version of 2 or greater, have an Application Policy Insurance Requirement\n    # requiring the Certificate Request Agent EKU.\n    #\n    # Additionally the certificate template must also allow for domain authentication\n    # and the CA must not have any enrollment agent restrictions.\n    esc3_template_2_raw_filter = '(&'\\\n      '(objectclass=pkicertificatetemplate)'\\\n      '(!(mspki-enrollment-flag:1.2.840.113556.1.4.804:=2))'\\\n      '(|'\\\n        '(mspki-template-schema-version=1)'\\\n        '(&'\\\n          '(mspki-template-schema-version>=2)'\\\n          '(msPKI-RA-Application-Policies=1.3.6.1.4.1.311.20.2.1)'\\\n        ')'\\\n      ')'\\\n      '(|'\\\n        '(pkiextendedkeyusage=1.3.6.1.4.1.311.20.2.2)'\\\n        '(pkiextendedkeyusage=1.3.6.1.5.5.7.3.2)'\\\n        '(pkiextendedkeyusage=1.3.6.1.5.2.3.4)'\\\n        '(pkiextendedkeyusage=2.5.29.37.0)'\\\n        '(!(pkiextendedkeyusage=*))'\\\n      ')'\\\n    ')'\n    query_ldap_server_certificates(esc3_template_2_raw_filter, 'ESC3_TEMPLATE_2')\n  end\n\n  def find_enrollable_vuln_certificate_templates\n    # For each of the vulnerable certificate templates, determine which servers\n    # allows users to enroll in that certificate template and which users/groups\n    # have permissions to enroll in certificates on each server.\n\n    @vuln_certificate_details.each_key do |certificate_template|\n      certificate_enrollment_raw_filter = \"(&(objectClass=pKIEnrollmentService)(certificateTemplates=#{certificate_template}))\"\n      attributes = ['cn', 'dnsHostname', 'ntsecuritydescriptor']\n      base_prefix = 'CN=Enrollment Services,CN=Public Key Services,CN=Services,CN=Configuration'\n      enrollment_ca_data = query_ldap_server(certificate_enrollment_raw_filter, attributes, base_prefix: base_prefix)\n      next if enrollment_ca_data.blank?\n\n      enrollment_ca_data.each do |ca_server|\n        begin\n          security_descriptor = Rex::Proto::MsDtyp::MsDtypSecurityDescriptor.read(ca_server[:ntsecuritydescriptor][0])\n        rescue IOError => e\n          fail_with(Failure::UnexpectedReply, \"Unable to read security descriptor! Error was: #{e.message}\")\n        end\n\n        allowed_sids = parse_acl(security_descriptor.dacl) if security_descriptor.dacl\n        next if allowed_sids.empty?\n\n        ca_server_key = ca_server[:dnshostname][0].to_sym\n        unless @vuln_certificate_details[certificate_template][:ca_servers_n_enrollment_sids].key?(ca_server_key)\n          @vuln_certificate_details[certificate_template][:ca_servers_n_enrollment_sids][ca_server_key] = { cn: ca_server[:cn][0], ca_enrollment_sids: allowed_sids }\n        end\n      end\n    end\n  end\n\n  def print_vulnerable_cert_info\n    @vuln_certificate_details.each do |key, hash|\n      enrollable = true\n      if hash[:ca_servers_n_enrollment_sids].blank?\n        next unless datastore['REPORT_NONENROLLABLE']\n\n        enrollable = false\n      end\n\n      print_status(\"Template: #{key}\")\n      unless enrollable\n        print_warning(\"   #{key} not published as an enrollable certificate!\")\n      end\n\n      print_status(\"   Distinguished Name: #{hash[:dn]}\")\n      print_status(\"   Vulnerable to: #{hash[:vulns].join(', ')}\")\n\n      print_status('   Certificate Template Enrollment SIDs:')\n      for sid in hash[:certificate_enrollment_sids].split(' | ')\n        print_status(\"      * #{sid}\")\n      end\n\n      next unless enrollable\n\n      for ca_hostname, ca_hash in hash[:ca_servers_n_enrollment_sids]\n        print_status('   Issuing CAs:')\n        print_status(\"      * #{ca_hash[:cn]}\")\n        print_status(\"         Server: #{ca_hostname}\")\n        print_status('         Enrollment SIDs:')\n        sid_list_string = convert_sids_to_human_readable_name(ca_hash[:ca_enrollment_sids])\n        for sid_info in sid_list_string.split(' | ')\n          print_status(\"            * #{sid_info}\")\n        end\n      end\n    end\n  end\n\n  def run\n    # Define our instance variables real quick.\n    @base_dn = nil\n    @vuln_certificate_details = {} # Initialize to empty hash since we want to only keep one copy of each certificate template along with its details.\n\n    find_esc1_vuln_cert_templates\n    find_esc2_vuln_cert_templates\n    find_esc3_vuln_cert_templates\n\n    find_enrollable_vuln_certificate_templates\n    print_vulnerable_cert_info\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-06-17"
}