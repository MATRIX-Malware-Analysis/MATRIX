{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6d60c8c1-5e91-415f-b88d-8e1d7f7a5371",
    "created": "2024-08-14T16:26:36.481174Z",
    "modified": "2024-08-14T16:26:36.481178Z",
    "name": "SMTP NTLM Domain Extraction",
    "description": "Extract the Windows domain name from an SMTP NTLM challenge.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/smtp/smtp_ntlm_domain.rb",
            "external_id": "smtp_ntlm_domain.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Smtp\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'SMTP NTLM Domain Extraction',\n      'Description' => 'Extract the Windows domain name from an SMTP NTLM challenge.',\n      'References'  => [ ['URL', 'https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-smtpntlm/a048c79f-7597-401b-bcb4-521d682de765' ] ],\n      'Author'      => [ 'Rich Whitcroft <rwhitcroft[at]digitalboundary.net>' ],\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        Opt::RPORT(25),\n        OptString.new('EHLO_DOMAIN', [ true, 'The domain to send with the EHLO command', 'localhost' ]),\n      ])\n\n    deregister_options('MAILTO', 'MAILFROM')\n  end\n\n  def run_host(ip)\n    begin\n      domain = nil\n      connect\n\n      unless banner\n        vprint_error(\"#{rhost}:#{rport} No banner received, aborting...\")\n        return\n      end\n\n      vprint_status(\"#{rhost}:#{rport} Connected: #{banner.strip.inspect}\")\n\n      # Report the last line of the banner as services information (typically the interesting one)\n      report_service(host: rhost, port: rport, name: 'smtp', proto: 'tcp', info: banner.strip.split(\"\\n\").last)\n\n      # Send a EHLO and parse the extensions returned\n      sock.puts(\"EHLO \" + datastore['EHLO_DOMAIN'] + \"\\r\\n\")\n\n      # Find all NTLM references in the EHLO response\n      exts = sock.get_once.to_s.split(/\\n/).grep(/NTLM/)\n      if exts.length == 0\n        vprint_error(\"#{rhost}:#{rport} No NTLM extensions found\")\n        return\n      end\n\n      exts.each do |ext|\n\n        # Extract the reply minus the first 4 chars (response code + dash)\n        e = ext[4..-1].chomp\n\n        # Try the usual AUTH NTLM approach if possible, otherwise echo the extension back to server\n        if e =~ /AUTH.*NTLM/\n          sock.puts(\"AUTH NTLM\\r\\n\")\n          vprint_status(\"#{rhost}:#{rport} Sending AUTH NTLM\")\n        else\n          sock.puts(e + \"\\r\\n\")\n          vprint_status(\"#{rhost}:#{rport} Sending #{e}\")\n        end\n\n        # We expect a \"334\" code to go ahead with NTLM auth\n        reply = sock.get_once.to_s\n        if reply !~ /^334\\s+/m\n          vprint_status(\"#{rhost}:#{rport} Expected a 334 response, received #{reply.strip.inspect} aborting...\")\n          break\n        else\n          # Send the NTLM AUTH blob to tell the server we're ready to auth\n          blob = \"TlRMTVNTUAABAAAAt4II4gAAAAAAAAAAAAAAAAAAAAAFAs4OAAAADw==\"\n          sock.puts(blob + \"\\r\\n\")\n\n          # Capture the challenge sent by server\n          challenge = sock.get_once.to_s.split(/\\s+/).last\n\n          if challenge.length == 0\n            vprint_status(\"#{rhost}:#{rport} Empty challenge response, aborting...\")\n            break\n          end\n\n          begin\n            # Extract the domain out of the NTLM response\n            ntlm_reply = Rex::Proto::NTLM::Message.parse(Rex::Text.decode_base64(challenge))\n            if ! ntlm_reply && ntlm_reply.has_key?(:target_name)\n              vprint_status(\"#{rhost}:#{rport} Invalid challenge response, aborting...\")\n              break\n            end\n\n            # TODO: Extract the server name from :target_info as well\n            domain = ntlm_reply[:target_name].value.to_s.gsub(/\\x00/, '')\n            if domain.to_s.length == 0\n              vprint_status(\"#{rhost}:#{rport} Invalid target name in challenge response, aborting...\")\n              break\n            end\n\n            print_good(\"#{rhost}:#{rport} Domain: #{domain}\")\n            report_note(host: rhost, port: rport, proto: 'tcp', type: 'smtp.ntlm_auth_info', data: { domain: domain })\n            break\n\n          rescue ::Rex::ArgumentError\n            vprint_status(\"#{rhost}:#{rport} Invalid challenge response message, aborting...\")\n            break\n          end\n        end\n      end\n\n      if ! domain\n        vprint_error(\"#{rhost}:#{rport} No NTLM domain found\")\n      end\n\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Timeout::Error\n      # Ignore common networking and response timeout errors\n    ensure\n      disconnect\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        "[ Rich Whitcroft <rwhitcroft[at]digitalboundary.net> ]",
        ""
    ]
}