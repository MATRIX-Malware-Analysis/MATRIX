{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1470d996-7aec-4def-9be1-afaf1a308bf2",
    "created": "2024-08-14T16:31:26.841299Z",
    "modified": "2024-08-14T16:31:26.841303Z",
    "name": "Prometheus Node Exporter And Windows Exporter Information Gather",
    "description": " This modules connects to a Prometheus Node Exporter or Windows Exporter service and gathers information about the host.  Tested against Docker image 1.6.1, Linux 1.6.1, and Windows 0.23.1  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/prometheus_node_exporter_gather.rb",
            "external_id": "prometheus_node_exporter_gather.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/prometheus/node_exporter"
        },
        {
            "source_name": "reference",
            "url": "https://sysdig.com/blog/exposed-prometheus-exploit-kubernetes-kubeconeu/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Prometheus\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Prometheus Node Exporter And Windows Exporter Information Gather',\n        'Description' => %q{\n          This modules connects to a Prometheus Node Exporter or Windows Exporter service\n          and gathers information about the host.\n\n          Tested against Docker image 1.6.1, Linux 1.6.1, and Windows 0.23.1\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die'\n        ],\n        'References' => [\n          ['URL', 'https://github.com/prometheus/node_exporter'],\n          ['URL', 'https://sysdig.com/blog/exposed-prometheus-exploit-kubernetes-kubeconeu/']\n        ],\n\n        'Targets' => [\n          [ 'Automatic Target', {}]\n        ],\n        'DisclosureDate' => '2013-04-18', # node exporter first commit on github\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(9100), # windows 9182\n        OptString.new('TARGETURI', [ true, 'The URI of the Prometheus Node Exporter', '/'])\n      ]\n    )\n  end\n\n  def run\n    vprint_status(\"#{peer} - Checking \")\n    # since we will check res to see if auth was a success, make sure to capture the return\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path),\n      'method' => 'GET'\n    )\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response from server (response code #{res.code})\") unless res.code == 200\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Prometheus Node Exporter not found\") unless (\n      res.body.include?('<h2>Prometheus Node Exporter</h2>') ||\n      res.body.include?('<title>Node Exporter</title>') || # version 0.15.2\n      res.body.include?('<h2>Prometheus Exporter for Windows servers</h2>')\n    )\n\n    vprint_good(\"#{peer} - Prometheus Node Exporter version: #{Regexp.last_match(1)}\") if res.body =~ /version=([\\d.]+)/\n\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'metrics'),\n      'method' => 'GET'\n    )\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response from server (response code #{res.code})\") unless res.code == 200\n\n    results = process_results_page(res.body)\n\n    if results.nil? || results == []\n      print_bad(\"#{peer} - No metric data found\")\n      return\n    end\n\n    table_network = Rex::Text::Table.new(\n      'Header' => 'Network Interfaces',\n      'Indent' => 2,\n      'Columns' =>\n      [\n        'Device',\n        'MAC',\n        'Broadcast',\n        'State',\n      ]\n    )\n\n    table_fs = Rex::Text::Table.new(\n      'Header' => 'File Systems',\n      'Indent' => 2,\n      'Columns' =>\n      [\n        'Device',\n        'Mount Point',\n        'FS Type',\n      ]\n    )\n\n    table_bios = Rex::Text::Table.new(\n      'Header' => 'BIOS Information',\n      'Indent' => 2,\n      'Columns' =>\n      [\n        'Field',\n        'Value',\n      ]\n    )\n\n    table_os = Rex::Text::Table.new(\n      'Header' => 'OS Information',\n      'Indent' => 2,\n      'Columns' =>\n      [\n        'Field',\n        'Value',\n      ]\n    )\n\n    table_uname = Rex::Text::Table.new(\n      'Header' => 'uname Information',\n      'Indent' => 2,\n      'Columns' =>\n      [\n        'Field',\n        'Value',\n      ]\n    )\n\n    table_windows_domain = Rex::Text::Table.new(\n      'Header' => 'Domain Information',\n      'Indent' => 2,\n      'Columns' =>\n      [\n        'Field',\n        'Value',\n      ]\n    )\n\n    table_device_mapper = Rex::Text::Table.new(\n      'Header' => 'Disk Device Mapper Information',\n      'Indent' => 2,\n      'Columns' =>\n      [\n        'Device',\n        'Name',\n        'Logical Volume Name',\n        'UUID'\n      ]\n    )\n\n    table_network_route = Rex::Text::Table.new(\n      'Header' => 'Network Route Information',\n      'Indent' => 2,\n      'Columns' =>\n      [\n        'Device',\n        'IP',\n        'Gateway',\n        'Network'\n      ]\n    )\n\n    table_systemd = Rex::Text::Table.new(\n      'Header' => 'Systemd Information',\n      'Indent' => 2,\n      'Columns' =>\n      [\n        'Service',\n        'State',\n        'Permission'\n      ]\n    )\n\n    table_windows_cpu = Rex::Text::Table.new(\n      'Header' => 'CPU Information',\n      'Indent' => 2,\n      'Columns' =>\n      [\n        'Field',\n        'Value',\n      ]\n    )\n\n    results.each do |result|\n      if result['go_info']\n        print_good(\"Go Version: #{result.dig('go_info', 'labels', 'version')}\")\n      elsif result['node_selinux_enabled']\n        print_good(\"SELinux enabled: #{result.dig('node_selinux_enabled', 'value')}\")\n      elsif result['node_time_zone_offset_seconds']\n        print_good(\"Timezone: #{result.dig('node_time_zone_offset_seconds', 'labels', 'time_zone')}\")\n      elsif result['windows_os_timezone']\n        print_good(\"Timezone: #{result.dig('windows_os_timezone', 'labels', 'timezone')}\")\n      elsif result['node_dmi_info']\n        table_bios << ['Date', result.dig('node_dmi_info', 'labels', 'bios_date')]\n        table_bios << ['Vendor', result.dig('node_dmi_info', 'labels', 'bios_vendor')]\n        table_bios << ['Version', result.dig('node_dmi_info', 'labels', 'bios_version')]\n        table_bios << ['Asset Tag', result.dig('node_dmi_info', 'labels', 'board_asset_tag')]\n        table_bios << ['Board Vendor', result.dig('node_dmi_info', 'labels', 'board_vendor')]\n        table_bios << ['Board Name', result.dig('node_dmi_info', 'labels', 'board_name')]\n        table_bios << ['Board Version', result.dig('node_dmi_info', 'labels', 'board_version')]\n        table_bios << ['Chassis Asset Tag', result.dig('node_dmi_info', 'labels', 'chassis_asset_tag')]\n        table_bios << ['Chassis Vendor', result.dig('node_dmi_info', 'labels', 'chassis_vendor')]\n        table_bios << ['Product Family', result.dig('node_dmi_info', 'labels', 'product_family')]\n        table_bios << ['Product Name', result.dig('node_dmi_info', 'labels', 'product_name')]\n        table_bios << ['System Vendor', result.dig('node_dmi_info', 'labels', 'system_vendor')]\n      elsif result['node_filesystem_avail_bytes']\n        table_fs << [\n          result.dig('node_filesystem_avail_bytes', 'labels', 'device'),\n          result.dig('node_filesystem_avail_bytes', 'labels', 'mountpoint'),\n          result.dig('node_filesystem_avail_bytes', 'labels', 'fstype'),\n        ]\n      elsif result['node_filesystem_avail'] # version 0.15.2\n        table_fs << [\n          result.dig('node_filesystem_avail', 'labels', 'device'),\n          result.dig('node_filesystem_avail', 'labels', 'mountpoint'),\n          result.dig('node_filesystem_avail', 'labels', 'fstype'),\n        ]\n      elsif result['windows_logical_disk_size_bytes']\n        table_fs << [\n          '',\n          result.dig('windows_logical_disk_size_bytes', 'labels', 'volume'),\n          '',\n        ]\n      elsif result['node_network_info']\n        table_network << [\n          result.dig('node_network_info', 'labels', 'device'),\n          result.dig('node_network_info', 'labels', 'address'),\n          result.dig('node_network_info', 'labels', 'broadcast'),\n          result.dig('node_network_info', 'labels', 'operstate')\n        ]\n      elsif result['node_os_info']\n        table_os << ['Family', result.dig('node_os_info', 'labels', 'id')]\n        table_os << ['Name', result.dig('node_os_info', 'labels', 'name')]\n        table_os << ['Version', result.dig('node_os_info', 'labels', 'version')]\n        table_os << ['Version ID', result.dig('node_os_info', 'labels', 'version_id')]\n        table_os << ['Version Codename', result.dig('node_os_info', 'labels', 'version_codename')]\n        table_os << ['Pretty Name', result.dig('node_os_info', 'labels', 'pretty_name')]\n      elsif result['windows_os_info']\n        table_os << ['Product', result.dig('windows_os_info', 'labels', 'product')]\n        table_os << ['Version', result.dig('windows_os_info', 'labels', 'version')]\n        table_os << ['Build Number', result.dig('windows_os_info', 'labels', 'build_number')]\n      elsif result['node_uname_info']\n        table_uname << ['Domain Name', result.dig('node_uname_info', 'labels', 'domainname')]\n        table_uname << ['Arch', result.dig('node_uname_info', 'labels', 'machine')]\n        table_uname << ['Release', result.dig('node_uname_info', 'labels', 'release')]\n        table_uname << ['OS Type', result.dig('node_uname_info', 'labels', 'sysname')]\n        table_uname << ['Version', result.dig('node_uname_info', 'labels', 'version')]\n        table_uname << ['Node Name', result.dig('node_uname_info', 'labels', 'nodename')]\n      elsif result['windows_cs_hostname']\n        table_windows_domain << ['Domain Name', result.dig('windows_cs_hostname', 'labels', 'domain')]\n        table_windows_domain << ['FQDN', result.dig('windows_cs_hostname', 'labels', 'fqdn')]\n        table_windows_domain << ['Hostname', result.dig('windows_cs_hostname', 'labels', 'hostname')]\n      elsif result['node_disk_device_mapper_info']\n        table_device_mapper << [\n          result.dig('node_disk_device_mapper_info', 'labels', 'device'),\n          result.dig('node_disk_device_mapper_info', 'labels', 'name'),\n          result.dig('node_disk_device_mapper_info', 'labels', 'lv_name'),\n          result.dig('node_disk_device_mapper_info', 'labels', 'uuid'),\n        ]\n      elsif result['node_network_route_info']\n        table_network_route << [\n          result.dig('node_network_route_info', 'labels', 'device'),\n          result.dig('node_network_route_info', 'labels', 'src'),\n          result.dig('node_network_route_info', 'labels', 'gw'),\n          result.dig('node_network_route_info', 'labels', 'dest'),\n        ]\n      elsif result['windows_net_bytes_sent_total']\n        table_network_route << [\n          result.dig('windows_net_bytes_sent_total', 'labels', 'nic'),\n          '',\n          '',\n          '',\n        ]\n      elsif result['node_systemd_unit_state']\n        # these come back in groups of 4-5 where the value is 0 if a state isn't enabled.\n        # we only care about state 1 because thats what that service is at run time\n        if result.dig('node_systemd_unit_state', 'value') == '1'\n          table_systemd << [\n            result.dig('node_systemd_unit_state', 'labels', 'name'),\n            result.dig('node_systemd_unit_state', 'labels', 'state'),\n            ''\n          ]\n        end\n      elsif result['windows_service_info']\n        table_systemd << [\n          result.dig('windows_service_info', 'labels', 'display_name'),\n          result.dig('windows_service_info', 'labels', 'process_id') == '0' ? 'inactive' : 'active',\n          result.dig('windows_service_info', 'labels', 'run_as'),\n        ]\n      elsif result['windows_cpu_info']\n        table_windows_cpu << ['ID', result.dig('windows_cpu_info', 'labels', 'device_id')]\n        table_windows_cpu << ['Architecture', result.dig('windows_cpu_info', 'labels', 'architecture')]\n        table_windows_cpu << ['Description', result.dig('windows_cpu_info', 'labels', 'description')]\n        table_windows_cpu << ['Name', result.dig('windows_cpu_info', 'labels', 'name')]\n\n      end\n    end\n\n    [\n      table_bios, table_os, table_network, table_windows_domain, table_fs, table_uname, table_windows_cpu,\n      table_device_mapper, table_network_route, table_systemd,\n    ].each do |table|\n      print_good(table.to_s) if !table.rows.empty?\n    end\n  rescue ::Rex::ConnectionError\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-04-18, # node exporter first commit on github"
}