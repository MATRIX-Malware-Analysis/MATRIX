{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--cebd6767-83a1-479b-a526-3fe729ffc20c",
    "created": "2024-08-14T16:31:17.838089Z",
    "modified": "2024-08-14T16:31:17.838093Z",
    "name": "SMB Domain User Enumeration",
    "description": "Determine what domain users are logged into a remote system via a DCERPC to NetWkstaUserEnum.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/smb/smb_enumusers_domain.rb",
            "external_id": "smb_enumusers_domain.rb"
        },
        {
            "source_name": "reference",
            "url": "https://docs.microsoft.com/en-us/windows/win32/api/lmwksta/nf-lmwksta-netwkstauserenum"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  # Exploit mixins should be called first\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Exploit::Remote::SMB::Client::Authenticated\n  include Msf::Exploit::Remote::DCERPC\n\n  # Scanner mixin should be near last\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'SMB Domain User Enumeration',\n      'Description' => 'Determine what domain users are logged into a remote system via a DCERPC to NetWkstaUserEnum.',\n      'Author'      =>\n        [\n          'natron', # original module\n          'Joshua D. Abraham <jabra[at]praetorian.com>', # database storage\n        ],\n      'References'  =>\n        [\n          [ 'URL', 'https://docs.microsoft.com/en-us/windows/win32/api/lmwksta/nf-lmwksta-netwkstauserenum' ]\n        ],\n      'License'     => MSF_LICENSE\n    )\n\n    deregister_options('RPORT')\n\n  end\n\n  def parse_value(resp, idx)\n    #val_length  = resp[idx,4].unpack(\"V\")[0]\n    idx += 4\n    #val_offset = resp[idx,4].unpack(\"V\")[0]\n    idx += 4\n    val_actual = resp[idx,4].unpack(\"V\")[0]\n    idx += 4\n    value = resp[idx,val_actual*2]\n    idx += val_actual * 2\n\n    idx += val_actual % 2 * 2 # alignment\n\n    return value,idx\n  end\n\n  def parse_net_wksta_enum_users_info(resp)\n    accounts = [ Hash.new() ]\n\n    idx = 20\n    count = resp[idx,4].unpack(\"V\")[0] # wkssvc_NetWkstaEnumUsersInfo -> Info -> PtrCt0 -> User() -> Ptr -> Max Count\n    idx += 4\n\n    1.upto(count) do\n      # wkssvc_NetWkstaEnumUsersInfo -> Info -> PtrCt0 -> User() -> Ptr -> Ref ID\n      idx += 4 # ref id name\n      idx += 4 # ref id logon domain\n      idx += 4 # ref id other domains\n      idx += 4 # ref id logon server\n    end\n\n    1.upto(count) do\n      # wkssvc_NetWkstaEnumUsersInfo -> Info -> PtrCt0 -> User() -> Ptr -> ID1 max count\n\n      account_name,idx  = parse_value(resp, idx)\n      logon_domain,idx  = parse_value(resp, idx)\n      other_domains,idx = parse_value(resp, idx)\n      logon_server,idx  = parse_value(resp, idx)\n\n      accounts << {\n        :account_name => account_name,\n        :logon_domain => logon_domain,\n        :other_domains => other_domains,\n        :logon_server => logon_server\n      }\n    end\n\n    accounts\n  end\n\n  def rport\n    @rport || datastore['RPORT']\n  end\n\n  def smb_direct\n    @smbdirect || datastore['SMBDirect']\n  end\n\n  def store_username(username, res, ip, rport)\n    service_data = {\n      address: ip,\n      port: rport,\n      service_name: 'smb',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id,\n      proof: res\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: username\n    }\n\n    credential_data.merge!(service_data)\n\n    credential_core = create_credential(credential_data)\n\n    login_data = {\n      core: credential_core,\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }\n\n    login_data.merge!(service_data)\n    create_credential_login(login_data)\n  end\n\n  def run_host(ip)\n\n    [[139, false], [445, true]].each do |info|\n\n    @rport = info[0]\n    @smbdirect = info[1]\n\n    begin\n      connect()\n      smb_login()\n\n      uuid = [ '6bffd098-a112-3610-9833-46c3f87e345a', '1.0' ]\n\n      handle = dcerpc_handle(\n        uuid[0], uuid[1], 'ncacn_np', [\"\\\\wkssvc\"]\n      )\n      begin\n        dcerpc_bind(handle)\n        stub =\n          NDR.uwstring(\"\\\\\\\\\" + ip) + # Server Name\n          NDR.long(1) +           # Level\n          NDR.long(1) +           # Ctr\n          NDR.long(rand(0xffffffff)) +  # ref id\n          NDR.long(0) +           # entries read\n          NDR.long(0) +           # null ptr to user0\n\n          NDR.long(0xffffffff) +      # Prefmaxlen\n          NDR.long(rand(0xffffffff)) +  # ref id\n          NDR.long(0)             # null ptr to resume handle\n\n        dcerpc.call(2,stub)\n\n        resp = dcerpc.last_response ? dcerpc.last_response.stub_data : nil\n\n        accounts = parse_net_wksta_enum_users_info(resp)\n        accounts.shift\n\n        if datastore['VERBOSE']\n          accounts.each do |x|\n            print_status x[:logon_domain] + \"\\\\\" + x[:account_name] +\n              \"\\t(logon_server: #{x[:logon_server]}, other_domains: #{x[:other_domains]})\"\n          end\n        else\n          print_status \"#{accounts.collect{|x| x[:logon_domain] + \"\\\\\" + x[:account_name]}.join(\", \")}\"\n        end\n\n        found_accounts = []\n        accounts.each do |x|\n          comp_user = x[:logon_domain] + \"\\\\\" + x[:account_name]\n          found_accounts.push(comp_user.scan(/[[:print:]]/).join) unless found_accounts.include?(comp_user.scan(/[[:print:]]/).join)\n        end\n\n        found_accounts.each do |comp_user|\n          if comp_user.to_s =~ /\\$$/\n            next\n          end\n\n          print_good(\"Found user: #{comp_user}\")\n          store_username(comp_user, resp, ip, rport)\n        end\n\n      rescue ::Rex::Proto::SMB::Exceptions::ErrorCode => e\n        print_error(\"UUID #{uuid[0]} #{uuid[1]} ERROR 0x%.8x\" % e.error_code)\n        #puts e\n        #return\n      rescue ::Exception => e\n        print_error(\"UUID #{uuid[0]} #{uuid[1]} ERROR #{$!}\")\n        #puts e\n        #return\n      end\n\n      disconnect()\n      return\n    rescue ::Exception\n      print_line($!.to_s)\n    end\n  end\nend\n\nend\n"
}