{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6b566b8f-daf7-436d-9836-1681da19d4e4",
    "created": "2024-08-14T16:28:57.19679Z",
    "modified": "2024-08-14T16:28:57.196794Z",
    "name": "HTTP File Same Name Directory Scanner",
    "description": " This module identifies the existence of files in a given directory path named as the same name of the directory.  Only works if PATH is different than '/'. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/file_same_name_dir.rb",
            "external_id": "file_same_name_dir.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::WmapScanDir\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'   \t\t=> 'HTTP File Same Name Directory Scanner',\n      'Description'\t=> %q{\n        This module identifies the existence of files\n        in a given directory path named as the same name of the\n        directory.\n\n        Only works if PATH is different than '/'.\n      },\n      'Author' \t\t=> [ 'et [at] metasploit.com' ],\n      'License'\t\t=> BSD_LICENSE))\n\n    register_options(\n      [\n        OptString.new('PATH', [ true,  \"The directory path  to identify files\", '/']),\n        OptString.new('EXT', [ true, \"File extension to use\", '.aspx']),\n\n      ])\n\n  end\n\n  def run_host(ip)\n    extensions = [\n      '.null',\n      '.backup',\n      '.bak',\n      '.c',\n      '.cfg',\n      '.class',\n      '.copy',\n      '.conf',\n      '.exe',\n      '.html',\n      '.htm',\n      '.log',\n      '.old',\n      '.orig',\n      '.php',\n      '.tar',\n      '.tar.gz',\n      '.tgz',\n      '.tmp',\n      '.temp',\n      '.txt',\n      '.zip',\n      '~',\n      ''\n    ]\n\n    tpath = normalize_uri(datastore['PATH'])\n\n    if tpath.eql? \"/\"||\"\"\n      print_error(\"Blank or default PATH set.\");\n      return\n    end\n\n    if tpath[-1,1] != '/'\n      tpath += '/'\n    end\n\n    testf = tpath.split('/').last\n\n    extensions << datastore['EXT']\n\n    extensions.each { |ext|\n      begin\n        testfext = testf.chomp + ext\n        res = send_request_cgi({\n          'uri'  \t\t=>  tpath+testfext,\n          'method'   \t=> 'GET',\n          'ctype'\t\t=> 'text/plain'\n        }, 20)\n\n        if (res and res.code >= 200 and res.code < 300)\n          print_good(\"Found #{wmap_base_url}#{tpath}#{testfext}\")\n\n          report_web_vuln(\n            :host\t=> ip,\n            :port\t=> rport,\n            :vhost  => vhost,\n            :ssl    => ssl,\n            :path\t=> \"#{tpath}#{testfext}\",\n            :method => 'GET',\n            :pname  => \"\",\n            :proof  => \"Res code: #{res.code.to_s}\",\n            :risk   => 0,\n            :confidence   => 100,\n            :category     => 'file',\n            :description  => 'File found.',\n            :name   => 'file'\n          )\n\n        else\n          vprint_status(\"NOT Found #{wmap_base_url}#{tpath}#{testfext}\")\n        end\n\n      rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      rescue ::Timeout::Error, ::Errno::EPIPE\n      end\n\n    }\n\n  end\nend\n"
}