{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--30c12665-ffe3-412f-8a1c-251fb3951207",
    "created": "2024-08-14T16:26:30.976716Z",
    "modified": "2024-08-14T16:26:30.97672Z",
    "name": "HTTP Form Field Fuzzer",
    "description": " This module will grab all fields from a form and launch a series of POST actions, fuzzing the contents of the form fields. You can optionally fuzz headers too (option is enabled by default) ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/fuzzers/http/http_form_field.rb",
            "external_id": "http_form_field.rb"
        },
        {
            "source_name": "print_error(\"Serverrepliedwitherrorcode.CheckURLorsetCODEtoanothervalue",
            "external_id": "andtryagain.\")"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'HTTP Form Field Fuzzer',\n      'Description'    => %q{\n        This module will grab all fields from a form,\n        and launch a series of POST actions, fuzzing the contents\n        of the form fields. You can optionally fuzz headers too\n        (option is enabled by default)\n      },\n      'Author'  => [\n        'corelanc0d3r',\n        'Paulino Calderon <calderon[at]websec.mx>' #Added cookie handling\n        ],\n      'License'       => MSF_LICENSE,\n      'References'    =>\n        [\n          ['URL','http://www.corelan.be:8800/index.php/2010/11/12/metasploit-module-http-form-field-fuzzer'],\n        ]\n      ))\n\n    register_options(\n      [\n        OptString.new('URL', [ false, \"The URL that contains the form\", \"/\"]),\n        OptString.new('FORM', [ false, \"The name of the form to use. Leave empty to fuzz all forms\",\"\" ] ),\n        OptString.new('FIELDS', [ false, \"Name of the fields to fuzz. Leave empty to fuzz all fields\",\"\" ] ),\n        OptString.new('ACTION', [ false, \"Form action full URI. Leave empty to autodetect\",\"\" ] ),\n        OptInt.new('STARTSIZE', [ true, \"Fuzzing string startsize.\",1000]),\n        OptInt.new('ENDSIZE', [ true, \"Max Fuzzing string size.\",40000]),\n        OptInt.new('STEPSIZE', [ true, \"Increment fuzzing string each attempt.\",1000]),\n        OptInt.new('TIMEOUT', [ true, \"Number of seconds to wait for response on GET or POST\",15]),\n        OptInt.new('DELAY', [ true, \"Number of seconds to wait between 2 actions\",0]),\n        OptInt.new('STOPAFTER', [ false, \"Stop after x number of consecutive errors\",2]),\n        OptBool.new('CYCLIC', [ true, \"Use Cyclic pattern instead of A's (fuzzing payload).\",true]),\n        OptBool.new('FUZZHEADERS', [ true, \"Fuzz headers\",true]),\n        OptString.new('HEADERFIELDS', [ false, \"Name of the headerfields to fuzz. Leave empty to fuzz all fields\",\"\" ] ),\n        OptString.new('TYPES', [ true, \"Field types to fuzz\",\"text,password,inputtextbox\"]),\n        OptString.new('CODE', [ true, \"Response code(s) indicating OK\", \"200,301,302,303\" ] ),\n        OptBool.new('HANDLECOOKIES', [ true, \"Appends cookies with every request.\",false])\n      ])\n  end\n\n  def init_vars\n    proto = \"http://\"\n    if datastore['SSL']\n      proto = \"https://\"\n    end\n\n    @send_data = {\n        :uri => '',\n        :version => '1.1',\n        :method => 'POST',\n        :headers => {\n          'Content-Length' => 100,\n          'Accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n          'Accept-Language' => 'en-us,en;q=0.5',\n          'Accept-Encoding' => 'gzip,deflate',\n          'Accept-Charset' => 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',\n          'Keep-Alive' => '300',\n          'Connection' => 'keep-alive',\n          'Referer' => proto + datastore['RHOST'] + \":\" + datastore['RPORT'].to_s,\n          'Content-Type' => 'application/x-www-form-urlencoded'\n        }\n      }\n    @get_data_headers = {\n        'Referer' => proto + datastore['RHOST'] + \":\" + datastore['RPORT'].to_s,\n      }\n  end\n\n  def init_fuzzdata\n    @fuzzsize = datastore['STARTSIZE']\n    @endsize = datastore['ENDSIZE']\n    set_fuzz_payload()\n    @nrerrors = 0\n  end\n\n  def incr_fuzzsize\n    @stepsize = datastore['STEPSIZE'].to_i\n    @fuzzsize = @fuzzsize + @stepsize\n  end\n\n  def set_fuzz_payload\n    if datastore['CYCLIC']\n      @fuzzdata = Rex::Text.pattern_create(@fuzzsize)\n    else\n      @fuzzdata = \"A\" * @fuzzsize\n    end\n  end\n\n  def is_error_code(code)\n    okcode = false\n    checkcodes = datastore['CODE'].split(\",\")\n    checkcodes.each do | testcode |\n      testcode = testcode.upcase.gsub(\" \",\"\")\n      if testcode == code.to_s().upcase.gsub(\" \",\"\")\n        okcode = true\n      end\n    end\n    return okcode\n  end\n\n  def fuzz_this_field(fieldname,fieldtype)\n    fuzzcommands = datastore['FIELDS'].split(\",\")\n    fuzzme = 0\n    if fuzzcommands.size > 0\n      fuzzcommands.each do |thiscmd|\n        thiscmd = thiscmd.strip\n        if ((fieldname.upcase == thiscmd.upcase) || (thiscmd == \"\")) && (fuzzme == 0)\n          fuzzme = 1\n        end\n      end\n    else\n      fuzztypes = datastore['TYPES'].split(\",\")\n      fuzztypes.each do | thistype |\n        if (fieldtype.upcase.strip == thistype.upcase.strip)\n          fuzzme = 1\n        end\n      end\n    end\n    if fuzzme == 1\n      set_fuzz_payload()\n    end\n    return fuzzme\n  end\n\n  def fuzz_this_headerfield(fieldname)\n    fuzzheaderfields = datastore['HEADERFIELDS'].split(\",\")\n    fuzzme = 0\n    if fuzzheaderfields.size > 0\n      fuzzheaderfields.each do |thisfield|\n        thisfield = thisfield.strip\n        if ((fieldname.upcase == thisfield.upcase) || (thisfield == \"\")) && (fuzzme == 0)\n          fuzzme = 1\n        end\n      end\n    else\n      fuzzme = 1\n    end\n    if fuzzme == 1\n      set_fuzz_payload()\n    end\n    return fuzzme\n  end\n\n  def do_fuzz_headers(form,headers)\n    headercnt = 0\n    datastr = \"\"\n    form[:fields].each do | thisfield |\n      normaldata = \"blah&\"\n      if thisfield[:value]\n        if thisfield[:value] != \"\"\n          normaldata = thisfield[:value].strip + \"&\"\n        end\n      end\n      datastr << thisfield[:name].downcase.strip + \"=\" + normaldata\n    end\n    if datastr.length > 0\n      datastr=datastr[0,datastr.length-1] + \"\\r\\n\"\n    else\n      datastr = \"\\r\\n\"\n    end\n    # first, check the original header fields and add some others - just for fun\n    myheaders = @send_data[:headers]\n    mysendheaders = @send_data[:headers].dup\n    # get or post ?\n    mysendheaders[:method] = form[:method].upcase\n    myheaders.each do | thisheader |\n      if not headers[thisheader[0]]\n        # add header if needed\n        mysendheaders[thisheader[0]]= thisheader[1]\n      end\n    end\n    nrheaderstofuzz = mysendheaders.size\n    mysendheaders.each do | thisheader|\n      @fuzzheader = mysendheaders.dup\n      @nrerrors = 0\n      fuzzpacket = @send_data.dup\n      fuzzpacket[:method] = mysendheaders[:method]\n      headername = thisheader[0]\n      if fuzz_this_headerfield(headername.to_s().upcase) == 1\n        print_status(\"    - Fuzzing header '#{headername}' (#{headercnt+1}/#{nrheaderstofuzz})\")\n        init_fuzzdata()\n        while @fuzzsize <= @endsize+1\n          @fuzzheader[headername] = @fuzzdata\n          fuzzpacket[:headers] = @fuzzheader\n          response = send_fuzz(fuzzpacket,datastr)\n          if not process_response(response,headername,\"header\")\n            @fuzzsize = @endsize+2\n          end\n          if datastore['DELAY'] > 0\n            print_status(\"      (Sleeping for #{datastore['DELAY']} seconds...)\")\n            select(nil,nil,nil,datastore['DELAY'])\n          end\n          incr_fuzzsize()\n        end\n      else\n        print_status(\"    - Skipping header '#{headername}' (#{headercnt+1}/#{nrheaderstofuzz})\")\n      end\n      headercnt += 1\n    end\n  end\n\n  def do_fuzz_field(form,field)\n    fieldstofuzz = field.downcase.strip.split(\",\")\n    @nrerrors = 0\n    while @fuzzsize <= @endsize+1\n      allfields = form[:fields]\n      datastr = \"\"\n      normaldata = \"\"\n      allfields.each do | thisfield |\n        dofuzzthis = false\n        if thisfield[:name]\n          fieldstofuzz.each do | fuzzthis |\n            if fuzzthis\n              if (thisfield[:name].downcase.strip == fuzzthis.downcase.strip)\n                dofuzzthis = true\n              end\n            end\n          end\n          if thisfield[:value]\n            normaldata = thisfield[:value].strip\n          else\n            normaldata = \"\"\n          end\n          if (dofuzzthis)\n            datastr << thisfield[:name].downcase.strip + \"=\" + @fuzzdata + \"&\"\n          else\n            datastr << thisfield[:name].downcase.strip + \"=\" + normaldata + \"&\"\n          end\n        end\n      end\n      datastr=datastr[0,datastr.length-1]\n      @send_data[:uri] = form[:action]\n      @send_data[:uri] = \"/#{form[:action]}\" if @send_data[:uri][0,1] != '/'\n\n      @send_data[:method] = form[:method].upcase\n      response = send_fuzz(@send_data,datastr)\n      if not process_response(response,field,\"field\")\n        return\n      end\n      if datastore['DELAY'] > 0\n        print_status(\"      (Sleeping for #{datastore['DELAY']} seconds...)\")\n        select(nil,nil,nil,datastore['DELAY'])\n      end\n    end\n  end\n\n  def process_response(response,field,type)\n    if response == nil\n      print_error(\"      No response - #{@nrerrors+1} / #{datastore['STOPAFTER']} - fuzzdata length : #{@fuzzsize}\")\n      if @nrerrors+1 >= datastore['STOPAFTER']\n        print_status(\"      *!* No response : #{type} #{field} | fuzzdata length : #{@fuzzsize}\")\n        return false\n      else\n        @nrerrors = @nrerrors + 1\n      end\n    else\n      okcode = is_error_code(response.code)\n      if okcode\n          @nrerrors = 0\n          incr_fuzzsize()\n      end\n      if not okcode and @nrerrors+1 >= datastore['STOPAFTER']\n        print_status(\"      *!* Error response code #{response.code} | #{type} #{field} | fuzzdata length #{@fuzzsize}\")\n        return false\n      else\n        @nrerrors = @nrerrors + 1\n      end\n    end\n    return true\n  end\n\n  def send_fuzz(postdata,data)\n    header = postdata[:headers]\n    response = send_request_raw({\n        'uri' => postdata[:uri],\n        'version' => postdata[:version],\n        'method' => postdata[:method],\n        'headers' => header,\n        'data' => data\n        }, datastore['TIMEOUT'])\n    return response\n  end\n\n  def get_field_val(input)\n    tmp = input.split(/\\=/)\n    # get delimeter\n    tmp2 = tmp[1].strip\n    delim = tmp2[0,1]\n    if delim != \"'\" && delim != '\"'\n      delim = \"\"\n    end\n    tmp3 = tmp[1].split(/>/)\n    tmp4 = tmp3[0].gsub(delim,\"\")\n    return tmp4\n  end\n\n  def get_form_data(body)\n    print_status(\"Enumerating form data\")\n    body = body.gsub(\"\\r\",\"\")\n    body = body.gsub(\"\\n\",\"\")\n    bodydata = body.downcase.split(/<form/)\n    # we need part after <form\n    totalforms = bodydata.size - 1\n    print_status(\"    Number of forms : #{totalforms}\")\n    formcnt = 0\n    formidx = 1\n    forms = []\n    while formcnt < totalforms\n      fdata = bodydata[formidx]\n      print_status(\"    - Enumerating form ##{formcnt+1}\")\n      data = fdata.downcase.split(/<\\/form>/)\n      # first, get action and name\n      formdata = data[0].downcase.split(/>/)\n      subdata = formdata[0].downcase.split(/ /)\n      namefound = false\n      actionfound = false\n      idfound = false\n      actionname = \"\"\n      formname = \"\"\n      formid = \"\"\n      formmethod = \"post\"\n      subdata.each do | thisfield |\n        if thisfield.match(/^name=/) and not namefound\n          formname = get_field_val(thisfield)\n          namefound = true\n        end\n        if thisfield.match(/^id=/) and not idfound\n          formid = get_field_val(thisfield)\n          idfound = true\n        end\n        if thisfield.match(/^method=/)\n          formmethod = get_field_val(thisfield)\n        end\n        if thisfield.match(/^action=/) and not actionfound\n          actionname = get_field_val(thisfield)\n          if (actionname.length < datastore['URL'].length) and (datastore['URL'].downcase.index(actionname.downcase).to_i() > -1)\n            actionname = datastore['URL']\n          end\n          actionfound = true\n        end\n      end\n      if datastore['ACTION'].length > 0\n        actionname = datastore['ACTION']\n        actionfound = true\n      end\n\n      if formname == \"\" and formid != \"\"\n        formname = formid\n      end\n      if formid == \"\" and formname != \"\"\n        formid = formname\n      end\n      if formid == \"\" and formname == \"\"\n        formid = \"noname_\" + (formcnt+1).to_s()\n        formname = formid\n      end\n      idfound = true\n      namefound = true\n\n      formfields = []\n      # input boxes\n      fieldtypemarks = [ '<input', '<select' ]\n      fieldtypemarks.each do | currfieldmark |\n        formfieldcnt=0\n        if (namefound or idfound) and actionfound\n          # get fields in current form - data[0]\n          subdata = data[0].downcase.split(currfieldmark)\n          skipflag=0\n          if subdata.size > 1\n            subdata.each do | thisinput |\n              if skipflag == 1\n                # first, find the delimeter\n                fielddata = thisinput.downcase.split(/>/)\n                fields = fielddata[0].split(/ /)\n                fieldname = \"\"\n                fieldtype = \"\"\n                fieldvalue = \"\"\n                fieldmethod = \"post\"\n                fieldid = \"\"\n                fields.each do | thisfield |\n                  if thisfield.match(/^type=/)\n                    fieldtype = get_field_val(thisfield)\n                  end\n                  if currfieldmark == \"<select\" and thisfield.match(/^class=/)\n                    fieldtype = get_field_val(thisfield)\n                  end\n                  if thisfield.match(/^name=/)\n                    fieldname = get_field_val(thisfield)\n                  end\n                  if thisfield.match(/^id=/)\n                    fieldid = get_field_val(thisfield)\n                  end\n                  if thisfield.match(/^value=/)\n                    # special case\n                    location = fielddata[0].index(thisfield)\n                    delta = fielddata[0].size - location\n                    remaining = fielddata[0][location,delta]\n                    tmp = remaining.strip.split(/\\=/)\n                    if tmp.size > 1\n                      delim = tmp[1][0,1]\n                      tmp2 = tmp[1].split(delim)\n                      fieldvalue = tmp2[1]\n                    end\n                  end\n                end\n                if fieldname == \"\" and fieldid != \"\"\n                  fieldname = fieldid\n                end\n                if fieldid == \"\" and fieldname != \"\"\n                  fieldid = fieldname\n                end\n                print_status(\"      Field : #{fieldname}, type #{fieldtype}\")\n                if fieldid != \"\"\n                  formfields << {\n                    :id => fieldid,\n                    :name => fieldname,\n                    :type => fieldtype,\n                    :value => fieldvalue\n                  }\n                  formfieldcnt += 1\n                end\n              else\n                skipflag += 1\n              end\n            end\n          end\n        end\n      end\n      print_status(\"      Nr of fields in form '#{formname}' : #{formfields.size}\")\n      # store in multidimensional array\n      forms << {\n        :name => formname,\n        :id => formid,\n        :action => actionname,\n        :method => formmethod,\n        :fields => formfields\n      }\n      formidx = formidx + 1\n      formcnt += 1\n    end\n\n    if forms.size > 0\n      print_status(\"    Forms : \")\n    end\n\n    forms.each do | thisform |\n      print_status(\"     - Name : #{thisform[:name]}, ID : #{thisform[:id]}, Action : #{thisform[:action]}, Method : #{thisform[:method]}\")\n    end\n\n    return forms\n  end\n\n  def set_cookie(cookie)\n    @get_data_headers[\"Cookie\"]=cookie\n    @send_data[:headers][\"Cookie\"]=cookie\n  end\n\n  def run\n    init_fuzzdata()\n    init_vars()\n\n    print_status(\"Grabbing webpage #{datastore['URL']} from #{datastore['RHOST']}\")\n    response = send_request_raw(\n    {\n      'uri' => normalize_uri(datastore['URL']),\n      'version' => '1.1',\n      'method' => 'GET',\n      'headers' => @get_data_headers\n\n    }, datastore['TIMEOUT'])\n    if response == nil\n      print_error(\"No response\")\n      return\n    end\n\n    if datastore['HANDLECOOKIES']\n      cookie = response.get_cookies\n      set_cookie(cookie)\n      print_status(\"Set cookie: #{cookie}\")\n      print_status(\"Grabbing webpage #{datastore['URL']} from #{datastore['RHOST']} using cookies\")\n\n      response = send_request_raw(\n      {\n        'uri' => normalize_uri(datastore['URL']),\n        'version' => '1.1',\n        'method' => 'GET',\n        'headers' => @get_data_headers\n      }, datastore['TIMEOUT'])\n    end\n    if response == nil\n      print_error(\"No response\")\n      return\n    end\n    print_status(\"Code : #{response.code}\")\n    okcode = is_error_code(response.code)\n    if not okcode\n      print_error(\"Server replied with error code. Check URL or set CODE to another value, and try again.\")\n      return\n    end\n    if response.body\n      formfound = response.body.downcase.index(\"<form\")\n      if formfound\n        formdata = get_form_data(response.body)\n        # fuzz !\n        # for each form that needs to be fuzzed\n        formdata.each do | thisform |\n          if thisform[:name].length > 0\n            if ((datastore['FORM'].strip == \"\") || (datastore['FORM'].upcase.strip == thisform[:name].upcase.strip)) && (thisform[:fields].size > 0)\n              print_status(\"Fuzzing fields in form #{thisform[:name].upcase.strip}\")\n              # for each field in this form, fuzz one field at a time\n              formfields = thisform[:fields]\n              formfields.each do | thisfield |\n                if thisfield[:name]\n                  if fuzz_this_field(thisfield[:name],thisfield[:type]) == 1\n                    print_status(\"    - Fuzzing field #{thisfield[:name]}\")\n                    do_fuzz_field(thisform,thisfield[:name])\n                    init_fuzzdata()\n                  end\n                end\n              end\n              print_status(\"Done fuzzing fields in form #{thisform[:name].upcase.strip}\")\n            end\n            # fuzz headers ?\n            if datastore['FUZZHEADERS']\n              print_status(\"Fuzzing header fields\")\n              do_fuzz_headers(thisform,response.headers)\n            end\n          end\n        end\n\n      else\n        print_error(\"No form found in response body\")\n        print_status(response.body)\n        return\n      end\n    else\n      print_error(\"No response data\")\n    end\n\n  end\nend\n"
}