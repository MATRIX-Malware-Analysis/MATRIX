{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4f41490c-4629-4507-b5dc-6abd90995d8e",
    "created": "2024-08-14T16:30:27.627281Z",
    "modified": "2024-08-14T16:30:27.627285Z",
    "name": "HTTP Error Based SQL Injection Scanner",
    "description": " This module identifies the existence of Error Based SQL injection issues. Still requires a lot of work  ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/error_sql_injection.rb",
            "external_id": "error_sql_injection.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::WmapScanUniqueQuery\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'   \t\t=> 'HTTP Error Based SQL Injection Scanner',\n      'Description'\t=> %q{\n        This module identifies the existence of Error Based SQL injection issues. Still requires a lot of work\n\n      },\n      'Author' \t\t=> [ 'et [at] cyberspace.org' ],\n      'License'\t\t=> BSD_LICENSE))\n\n    register_options(\n      [\n        OptEnum.new('METHOD', [true, 'HTTP Request Method', 'GET', ['GET', 'POST']]),\n        OptString.new('PATH', [ true,  \"The path/file to test SQL injection\", '/default.aspx']),\n        OptString.new('QUERY',[ false,  \"HTTP URI Query\", '']),\n        OptString.new('DATA', [ false,  \"HTTP Body/Data Query\", ''])\n      ])\n\n    register_advanced_options(\n      [\n        OptBool.new('NoDetailMessages', [ false, \"Do not display detailed test messages\", true ])\n      ])\n\n  end\n\n  def run_host(ip)\n\n    http_method = datastore['METHOD'].upcase\n\n    qvars = nil\n\n    sqlinj = [\n      [ \"'\" ,'Single quote'],\n      [ \"')\",'Single quote and parenthesis'],\n      [ \"\\\"\",'Double quote'],\n      [ \"%u0027\",'unicode single quote'],\n      [ \"%u02b9\",'unicode single quote'],\n      [ \"%u02bc\",'unicode single quote'],\n      [ \"%u02c8\",'unicode single quote'],\n      [ \"%c0%27\",'unicode single quote'],\n      [ \"%c0%a7\",'unicode single quote'],\n      [ \"%e0%80%a7\",'unicode single quote'],\n      [ \"#{rand(10)}'\", 'Random value with single quote']\n    ]\n\n    errorstr = [\n      [\"Unclosed quotation mark after the character string\",'MSSQL','string'],\n      [\"Syntax error in string in query expression\",'MSSQL','string'],\n      [\"Microsoft OLE DB Provider\",'MSSQL','unknown'],\n      [\"You have an error in your SQL syntax\",'MySQL','unknown'],\n      [\"java.sql.SQLException\",'unknown','unknown'],\n      [\"ORA-\",'ORACLE','unknown'],\n      [\"PLS-\",'ORACLE','unknown'],\n      [\"Syntax error\",'unknown','unknown'],\n    ]\n\n    #\n    # Dealing with empty query/data and making them hashes.\n    #\n\n    if  http_method =='GET'\n      if not datastore['QUERY'].empty?\n        qvars = queryparse(datastore['QUERY']) #Now its a Hash\n      else\n        print_error(\"You need to set QUERY param for GET\")\n        return\n      end\n    else\n      if not datastore['DATA'].empty?\n        qvars = queryparse(datastore['DATA']) #Now its a Hash\n      else\n        print_error(\"You need to set DATA parameter for POST\")\n        return\n      end\n    end\n\n    #\n    # Send normal request to check if error is generated\n    # (means the error is caused by other means)\n    #\n    #\n\n    if http_method == 'POST'\n      reqinfo = {\n        'uri'  \t\t=> normalize_uri(datastore['PATH']),\n        'query' \t=> datastore['QUERY'],\n        'data' \t\t=> datastore['DATA'],\n        'method'   \t=> http_method,\n        'ctype'\t\t=> 'application/x-www-form-urlencoded',\n        'encode'\t=> false\n      }\n    else\n      reqinfo = {\n        'uri'  \t\t=> normalize_uri(datastore['PATH']),\n        'query' \t=> datastore['QUERY'],\n        'method'   \t=> http_method,\n        'ctype'\t\t=> 'application/x-www-form-urlencoded',\n        'encode'\t=> false\n      }\n    end\n\n    begin\n      normalres = send_request_raw(reqinfo, 20)\n\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n    rescue ::Timeout::Error, ::Errno::EPIPE\n    end\n\n    if !datastore['NoDetailMessages']\n      print_status(\"Normal request sent.\")\n    end\n\n    found = false\n    inje = nil\n    dbt = nil\n    injt = nil\n\n    if normalres\n      errorstr.each do |estr,dbtype,injtype|\n        if normalres.body.include? estr\n          found = true\n          inje = estr\n          dbt = dbtype\n          injt = injtype\n        end\n      end\n\n      if found\n        print_error(\"[#{wmap_target_host}] Error string appears in the normal response, unable to test\")\n        print_error(\"[#{wmap_target_host}] Error string: '#{inje}'\")\n        print_error(\"[#{wmap_target_host}] DB TYPE: #{dbt}, Error type '#{injt}'\")\n\n        report_web_vuln(\n          :host\t=> ip,\n          :port\t=> rport,\n          :vhost  => vhost,\n          :ssl    => ssl,\n          :path\t=> datastore['PATH'],\n          :method => datastore['METHOD'],\n          :pname  => \"\",\n          :proof  => \"Error: #{inje}\",\n          :risk   => 2,\n          :confidence   => 50,\n          :category     => 'Database error',\n          :description  => \"Error string appears in the normal response #{inje} #{dbt}\",\n          :name   => 'Database error'\n        )\n\n        return\n      end\n    else\n      print_error(\"[#{wmap_target_host}] No response\")\n      return\n    end\n\n    #\n    # Test URI Query parameters\n    #\n\n    found = false\n\n    if qvars\n      sqlinj.each do |istr,idesc|\n\n        if found\n          break\n        end\n\n        qvars.each do |key,value|\n          if http_method == 'POST'\n            qvars = queryparse(datastore['DATA']) #Now its a Hash\n          else\n            qvars = queryparse(datastore['QUERY']) #Now its a Hash\n          end\n          qvars[key] = qvars[key]+istr\n\n          if !datastore['NoDetailMessages']\n            print_status(\"- Testing query with #{idesc}. Parameter #{key}:\")\n          end\n\n          fstr = \"\"\n          qvars.each_pair do |var,val|\n            fstr += var+\"=\"+val+\"&\"\n          end\n\n          if http_method == 'POST'\n            reqinfo = {\n              'uri'  \t\t=> normalize_uri(datastore['PATH']),\n              'query'\t\t=> datastore['QUERY'],\n              'data' \t\t=> fstr,\n              'method'   \t=> http_method,\n              'ctype'\t\t=> 'application/x-www-form-urlencoded',\n              'encode'\t=> false\n            }\n          else\n            reqinfo = {\n              'uri'  \t\t=> normalize_uri(datastore['PATH']),\n              'query' \t=> fstr,\n              'method'   \t=> http_method,\n              'ctype'\t\t=> 'application/x-www-form-urlencoded',\n              'encode'\t=> false\n            }\n          end\n\n          begin\n\n            testres = send_request_raw(reqinfo, 20)\n\n          rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n          rescue ::Timeout::Error, ::Errno::EPIPE\n          end\n\n          if testres\n            errorstr.each do |estr,dbtype,injtype|\n              if testres.body.include? estr\n                found = true\n                inje = estr\n                dbt = dbtype\n                injt = injtype\n              end\n            end\n\n            if found\n              print_good(\"[#{wmap_target_host}] SQL Injection found. (#{idesc}) (#{datastore['PATH']})\")\n              print_good(\"[#{wmap_target_host}] Error string: '#{inje}' Test Value: #{qvars[key]}\")\n              print_good(\"[#{wmap_target_host}] Vuln query parameter: #{key} DB TYPE: #{dbt}, Error type '#{injt}'\")\n\n              report_web_vuln(\n                :host\t=> ip,\n                :port\t=> rport,\n                :vhost  => vhost,\n                :ssl    => ssl,\n                :path\t=> datastore['PATH'],\n                :method => datastore['METHOD'],\n                :pname  => key,\n                :proof  => istr,\n                :risk   => 2,\n                :confidence   => 50,\n                :category     => 'SQL injection',\n                :description  => \"Error string appears in the normal response #{inje} #{dbt}\",\n                :name   => 'SQL injection'\n              )\n\n              return\n            end\n          else\n            print_error(\"[#{wmap_target_host}] No response\")\n            return\n          end\n        end\n      end\n\n      if http_method == 'POST'\n        qvars = queryparse(datastore['DATA']) #Now its a Hash\n      else\n        qvars = queryparse(datastore['QUERY']) #Now its a Hash\n      end\n    end\n  end\nend\n"
}