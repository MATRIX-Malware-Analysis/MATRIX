{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ee2a33a1-1cc1-4b25-82a7-f574ffa7283c",
    "created": "2024-08-14T16:26:52.936663Z",
    "modified": "2024-08-14T16:26:52.936668Z",
    "name": "Modbus Unit ID and Station ID Enumerator",
    "description": " Modbus is a cleartext protocol used in common SCADA systems, developed originally as a serial-line (RS232) async protocol, and later transformed to IP, which is called ModbusTCP. default tcp port is 502.  This module sends a command (0x04, read input register) to the modbus endpoint. If this command is sent to the correct unit-id, it returns with the same function-id. if not, it should be added 0x80, so that it sys 0x84, and an exception-code follows which do not interest us. This does not always happen, but at least the first 4 bytes in the return-packet should be exact the same as what was sent.  You can change port, ip and the scan-range for unit-id. There is also added a value - BENICE - to make the scanner sleep a second or more between probes. We have seen installations where scanning too many too fast works like a DoS.  'References'  => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/scada/modbus_findunitid.rb",
            "external_id": "modbus_findunitid.rb"
        },
        {
            "source_name": "reference",
            "url": "https://en.wikipedia.org/wiki/Modbus:TCP"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Fuzzer\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Modbus Unit ID and Station ID Enumerator',\n      'Description'    => %q{\n        Modbus is a cleartext protocol used in common SCADA systems, developed\n        originally as a serial-line (RS232) async protocol, and later transformed\n        to IP, which is called ModbusTCP. default tcp port is 502.\n\n        This module sends a command (0x04, read input register) to the modbus endpoint.\n        If this command is sent to the correct unit-id, it returns with the same function-id.\n        if not, it should be added 0x80, so that it sys 0x84, and an exception-code follows\n        which do not interest us. This does not always happen, but at least the first 4\n        bytes in the return-packet should be exact the same as what was sent.\n\n        You can change port, ip and the scan-range for unit-id. There is also added a\n        value - BENICE - to make the scanner sleep a second or more between probes. We\n        have seen installations where scanning too many too fast works like a DoS.\n      },\n      'References'  =>\n        [\n          [ 'URL', 'https://www.saia-pcd.com/en/products/plc/pcd-overview/Pages/pcd1-m2.aspx' ],\n          [ 'URL', 'https://en.wikipedia.org/wiki/Modbus:TCP' ]\n        ],\n      'Author'         => [ 'EsMnemon <esm[at]mnemonic.no>' ],\n      'License'        => MSF_LICENSE,\n      'DisclosureDate' => '2012-10-28'\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(502),\n        OptInt.new('UNIT_ID_FROM', [true, \"ModBus Unit Identifier scan from value [1..254]\", 1]),\n        OptInt.new('UNIT_ID_TO', [true, \"ModBus Unit Identifier scan to value [UNIT_ID_FROM..254]\", 254]),\n        OptInt.new('BENICE', [true, \"Seconds to sleep between StationID-probes, just for beeing nice\", 1]),\n        OptInt.new('TIMEOUT', [true, 'Timeout for the network probe, 0 means no timeout', 2])\n      ])\n  end\n\n  def run\n    start=\"\\x21\\x00\\x00\\x00\\x00\\x06\"\n    theend=\"\\x04\\x00\\x01\\x00\\x00\"\n    noll=\"\\x00\"\n    # between, \\01..\\0ff  (1-255)\n    unless (1..255).include? datastore['UNIT_ID_FROM']\n      print_status(\"unit ID must be between 1 and 254 adjusting  UNIT_ID_FROM to 1\")\n      datastore['UNIT_ID_FROM']=1\n    end\n\n    unless (1..255).include? datastore['UNIT_ID_TO']\n      print_status(\"Unit ID must be between #{datastore['UNIT_ID_FROM']} and 255\")\n      print_warning(\"Adjusting UNIT_ID_TO to #{datastore['UNIT_ID_FROM']} \")\n      datastore['UNIT_ID_TO'] = datastore['UNIT_ID_FROM']\n    end\n\n    if datastore['UNIT_ID_FROM'] > datastore['UNIT_ID_TO'] then\n      print_warning(\"UNIT_ID_TO is less than UNIT_ID_FROM, setting them equal\")\n      datastore['UNIT_ID_TO'] = datastore['UNIT_ID_FROM']\n    end\n\n    datastore['UNIT_ID_FROM'].upto(datastore['UNIT_ID_TO']) do |counter|\n      sploit  = start\n      sploit += [counter].pack(\"C\")\n      sploit += theend\n      select(nil,nil,nil,datastore['BENICE'])\n      connect()\n      sock.put(sploit)\n\n      data = sock.get_once(12, datastore['TIMEOUT'])\n      if (data.nil?)\n        data=noll+noll+noll+noll\n      end\n\n      if data[0,4]  == \"\\x21\\x00\\x00\\x00\"  #return of the same trans-id+proto-id\n        print_good(\"Received: correct MODBUS/TCP from stationID  #{counter}\")\n      else\n        print_status(\"Received: incorrect/none data from stationID #{counter} (probably not in use)\")\n      end\n\n      disconnect()\n    end\n  end\nend\n\n\n=begin\nFor testing purposes:\n\n  This client is developed and tested against a SAIA PCD1.M2 system\n  https://www.saia-pcd.com/en/products/plc/pcd-overview/Pages/pcd1-m2.aspx\n  and a modbus/tcp PLC simulator from plcsimulator.org\n  and the Modbus SLAVE from http://www.modbustools.com/\n\n  Mission is to find Unit-ID/stationID of the modbus-endpoint:\n  RHOST=IP of the modbus-service (PLC)\n  RPORT=Usually 502\n=end\n",
    "x_mitre_contributors": [
        "[ EsMnemon <esm[at]mnemonic.no> ]",
        ""
    ],
    "x_mitre_disclosure_date": "2012-10-28"
}