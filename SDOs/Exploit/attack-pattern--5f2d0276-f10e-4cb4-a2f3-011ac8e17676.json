{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5f2d0276-f10e-4cb4-a2f3-011ac8e17676",
    "created": "2024-08-14T16:27:39.179765Z",
    "modified": "2024-08-14T16:27:39.179769Z",
    "name": "VMWare Authentication Daemon Version Scanner",
    "description": " This module will identify information about a host through the vmauthd service. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/vmware/vmauthd_version.rb",
            "external_id": "vmauthd_version.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Exploit::Remote::Tcp\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  @@cached_rsa_key = nil\n\n  def initialize\n    super(\n      'Name'        => 'VMWare Authentication Daemon Version Scanner',\n      'Description' => %q{\n        This module will identify information about a host through the\n      vmauthd service.\n      },\n      'Author'      => ['theLightCosine', 'hdm'],\n      'License'     => MSF_LICENSE\n    )\n\n    register_options([Opt::RPORT(902)])\n\n  end\n\n\n\n  def run_host(ip)\n    begin\n\n    connect rescue nil\n    if not self.sock\n      return\n    end\n\n    banner = sock.get_once(-1, 10)\n    if not banner\n      print_error \"#{rhost}:#{rport} No banner received from vmauthd\"\n      return\n    end\n\n    banner = banner.strip\n\n    unless banner =~ /VMware Authentication Daemon/\n      print_error \"#{rhost}:#{rport} This does not appear to be a vmauthd service\"\n      return\n    end\n\n    cert = nil\n\n    if banner =~ /SSL/\n      print_status(\"#{rhost}:#{rport} Switching to SSL connection...\")\n      swap_sock_plain_to_ssl\n      cert = self.sock.peer_cert\n    end\n\n    if cert\n      banner << \" Certificate:#{cert.subject.to_s}\"\n    end\n\n    print_good \"#{rhost}:#{rport} Banner: #{banner}\"\n\n    report_service(\n      :host  => rhost,\n      :port  => rport,\n      :sname => 'vmauthd',\n      :info  => banner,\n      :proto => 'tcp'\n    )\n\n\n    rescue ::Interrupt\n      raise $!\n    ensure\n      disconnect\n    end\n\n  end\n\n  def do_login(user, pass, nsock=self.sock)\n    nsock.put(\"USER #{user}\\r\\n\")\n    res = nsock.get_once || ''\n    unless res.start_with? \"331\"\n      ret_msg = \"Unexpected reply to the USER command: #{res}\"\n      return ret_msg\n    end\n    nsock.put(\"PASS #{pass}\\r\\n\")\n    res = nsock.get_once || ''\n    if res.start_with? \"530\"\n      return :failed\n    elsif res.start_with? \"230\"\n      return :success\n    else\n      ret_msg = \"Unexpected reply to the PASS command: #{res}\"\n      return ret_msg\n    end\n  end\n\n  def swap_sock_plain_to_ssl(nsock=self.sock)\n    ctx =  generate_ssl_context()\n    ssl = OpenSSL::SSL::SSLSocket.new(nsock, ctx)\n\n    ssl.connect\n\n    nsock.extend(Rex::Socket::SslTcp)\n    nsock.sslsock = ssl\n    nsock.sslctx  = ctx\n  end\n\n  def generate_ssl_context\n    ctx = OpenSSL::SSL::SSLContext.new(:SSLv3)\n    @@cached_rsa_key ||= OpenSSL::PKey::RSA.new(1024){ }\n\n    ctx.key = @@cached_rsa_key\n\n    ctx.session_id_context = Rex::Text.rand_text(16)\n\n    return ctx\n  end\n\n\nend\n"
}