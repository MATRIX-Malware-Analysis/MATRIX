{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d1e4611d-0518-49a5-a49c-e4fa69244602",
    "created": "2024-08-14T16:29:28.907676Z",
    "modified": "2024-08-14T16:29:28.907681Z",
    "name": "Web Site Crawler",
    "description": "Crawl a web site and store information about what was found",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/crawler.rb",
            "external_id": "crawler.rb"
        },
        {
            "source_name": "#-ThepathofanyURLfoundbythecrawler(web.uri",
            "external_id": ":path=>page.path)"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::HttpCrawler\n\n  def initialize\n    super(\n      'Name'        => 'Web Site Crawler',\n      'Description' => 'Crawl a web site and store information about what was found',\n      'Author'      => %w(hdm tasos),\n      'License'     => MSF_LICENSE\n    )\n\n    register_advanced_options([\n      OptString.new('ExcludePathPatterns', [false, 'Newline-separated list of path patterns to ignore (\\'*\\' is a wildcard)']),\n    ])\n    @for_each_page_blocks = []\n  end\n\n=begin\n  # Prefer dynamic content over non-dynamic\n  def focus_crawl(page)\n    page.links\n  end\n=end\n\n  # Overrides Msf::Auxiliary::HttpCrawler#get_link_filter to add\n  # datastore['ExcludePathPatterns']\n  def get_link_filter\n    return super if datastore['ExcludePathPatterns'].to_s.empty?\n\n    patterns = opt_patterns_to_regexps( datastore['ExcludePathPatterns'].to_s )\n    patterns = patterns.map { |r| \"(#{r.source})\" }\n\n    Regexp.new( [[\"(#{super.source})\"] | patterns].join( '|' ) )\n  end\n\n  def run\n    super\n\n    if form = form_from_url( @current_site, datastore['URI'] )\n      print_status((\" \" * 24) + \"FORM: #{form[:method]} #{form[:path]}\")\n      report_web_form( form )\n      self.form_count += 1\n    end\n  end\n\n  def for_each_page( &block )\n    @for_each_page_blocks << block if block_given?\n  end\n\n  #\n  # The main callback from the crawler, redefines crawler_process_page() as\n  # defined by Msf::Auxiliary::HttpCrawler\n  #\n  # Data we will report:\n  # - The path of any URL found by the crawler (web.uri, :path => page.path)\n  # - The occurence of any form (web.form :path, :type (get|post|path_info), :params)\n  #\n  def crawler_process_page(t, page, cnt)\n    return if page.nil? # Skip over pages that don't contain any info aka page is nil. We can't process these types of pages since there is no data to process.\n    msg = \"[#{\"%.5d\" % cnt}/#{\"%.5d\" % max_page_count}]    #{page ? page.code || \"ERR\" : \"ERR\"} - #{t[:vhost]} - #{page.url}\"\n    if page.error\n      print_error(\"Error accessing page #{page.error.to_s}\")\n      elog(page.error)\n    end\n    case page.code\n      when 301,302\n        if page.headers and page.headers[\"location\"]\n          print_status(msg + \" -> \" + page.headers[\"location\"].to_s)\n        else\n          print_status(msg)\n        end\n      when 500...599\n        # XXX: Log the fact that we hit an error page\n        print_good(msg)\n      when 401,403\n        print_good(msg)\n      when 200\n        print_status(msg)\n      when 404\n        print_error(msg)\n      else\n        print_error(msg)\n    end\n\n    #\n    # Process the web page\n    #\n\n    info = {\n      :web_site => t[:site],\n      :path     => page.url.path,\n      :query    => page.url.query,\n      :code     => page.code,\n      :body     => page.body,\n      :headers  => page.headers\n    }\n\n    if page.headers['content-type']\n      info[:ctype] = page.headers['content-type']\n    end\n\n    if !page.cookies.empty?\n      info[:cookie] = page.cookies\n    end\n\n    if page.headers['authorization']\n      info[:auth] = page.headers['authorization']\n    end\n\n    if page.headers['location']\n      info[:location] = page.headers['location']\n    end\n\n    if page.headers['last-modified']\n      info[:mtime] = page.headers['last-modified']\n    end\n\n    # Report the web page to the database\n    report_web_page(info)\n\n    # Only process interesting response codes\n    return if not [302, 301, 200, 500, 401, 403, 404].include?(page.code)\n\n    #\n    # Skip certain types of forms right off the bat\n    #\n\n    # Apache multiview directories\n    return if page.url.query =~ /^C=[A-Z];O=/ # Apache\n\n    forms = []\n    form_template = { :web_site => t[:site] }\n\n    if form = form_from_url( t[:site], page.url )\n      forms << form\n    end\n\n    if page.doc\n      page.doc.css(\"form\").each do |f|\n\n        target = page.url\n\n        if f['action'] and not f['action'].strip.empty?\n          action = f['action']\n\n          # Prepend relative URLs with the current directory\n          if action[0,1] != \"/\" and action !~ /\\:\\/\\//\n            # Extract the base href first\n            base = target.path.gsub(/(.*\\/)[^\\/]+$/, \"\\\\1\")\n            page.doc.css(\"base\").each do |bref|\n              if bref['href']\n                base = bref['href']\n              end\n            end\n            action = (base + \"/\").sub(/\\/\\/$/, '/') + action\n          end\n\n          target = page.to_absolute(URI( action )) rescue next\n\n          if not page.in_domain?(target)\n            # Replace 127.0.0.1 and non-qualified hostnames with our page.host\n            # ex: http://localhost/url OR http://www01/url\n            target_uri = URI(target.to_s)\n            if (target_uri.host.index(\".\").nil? or target_uri.host == \"127.0.0.1\")\n              target_uri.host = page.url.host\n              target = target_uri\n            else\n              next\n            end\n          end\n        end\n\n        # skip this form if it matches exclusion criteria\n        if !(target.to_s =~ get_link_filter)\n          form = {}.merge!(form_template)\n          form[:method] = (f['method'] || 'GET').upcase\n          form[:query]  = target.query.to_s if form[:method] != \"GET\"\n          form[:path]   = target.path\n          form[:params] = []\n          f.css('input', 'textarea').each do |inp|\n            form[:params] << [inp['name'].to_s, inp['value'] || inp.content || '', { :type => inp['type'].to_s }]\n          end\n\n          f.css( 'select' ).each do |s|\n            value = nil\n\n            # iterate over each option to find the default value (if there is a selected one)\n            s.children.each do |opt|\n              ov = opt['value'] || opt.content\n              value = ov if opt['selected']\n            end\n\n            # set the first one as the default value if we don't already have one\n            value ||= s.children.first['value'] || s.children.first.content rescue ''\n\n            form[:params] << [ s['name'].to_s, value.to_s, [ :type => 'select'] ]\n          end\n\n          forms << form\n        end\n      end\n    end\n\n    # Report each of the discovered forms\n    forms.each do |form|\n      next if not form[:method]\n      print_status((\" \" * 24) + \"FORM: #{form[:method]} #{form[:path]}\")\n      report_web_form(form)\n      self.form_count += 1\n    end\n\n    @for_each_page_blocks.each { |p| p.call( page ) }\n  end\n\n  def form_from_url( website, url )\n    url = URI( url.to_s ) if !url.is_a?( URI )\n\n    begin\n      # Scrub out the jsessionid appends\n      url.path = url.path.sub(/;jsessionid=[a-zA-Z0-9]+/, '')\n    rescue URI::Error\n    end\n\n    #\n    # Continue processing forms\n    #\n    forms = []\n    form_template = { :web_site => website }\n    form  = {}.merge(form_template)\n\n    # This page has a query parameter we can test with GET parameters\n    # ex: /test.php?a=b&c=d\n    if url.query and not url.query.empty?\n      form[:method] = 'GET'\n      form[:path]   = url.path\n      vars = url.query.split('&').map{|x| x.split(\"=\", 2) }\n      form[:params] = vars\n    end\n\n    # This is a REST-ish application with numeric parameters\n    # ex: /customers/343\n    if not form[:path] and url.path.to_s =~ /(.*)\\/(\\d+)$/\n      path_base = $1\n      path_info = $2\n      form[:method] = 'PATH'\n      form[:path]   = path_base\n      form[:params] = [['PATH', path_info]]\n      form[:query]  = url.query.to_s\n    end\n\n    # This is an application that uses PATH_INFO for parameters:\n    # ex:  /index.php/Main_Page/Article01\n    if not form[:path] and url.path.to_s =~ /(.*\\/[a-z0-9A-Z]{3,256}\\.[a-z0-9A-Z]{2,8})(\\/.*)/\n      path_base = $1\n      path_info = $2\n      form[:method] = 'PATH'\n      form[:path]   = path_base\n      form[:params] = [['PATH', path_info]]\n      form[:query]  = url.query.to_s\n    end\n\n    form[:method] ? form : nil\n  end\n\n  private\n  def opt_patterns_to_regexps( patterns )\n    magic_wildcard_replacement = Rex::Text.rand_text_alphanumeric( 10 )\n    patterns.to_s.split( /[\\r\\n]+/).map do |p|\n      Regexp.new '^' + Regexp.escape( p.gsub( '*', magic_wildcard_replacement ) ).\n        gsub( magic_wildcard_replacement, '.*' ) + '$'\n    end\n  end\n\n\nend\n"
}