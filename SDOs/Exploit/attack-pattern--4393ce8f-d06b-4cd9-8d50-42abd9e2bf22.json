{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4393ce8f-d06b-4cd9-8d50-42abd9e2bf22",
    "created": "2024-08-14T16:28:05.624187Z",
    "modified": "2024-08-14T16:28:05.624192Z",
    "name": "SSL/TLS Version Detection",
    "description": " Check if a server supports a given version of SSL/TLS and cipher suites.  The certificate is stored in loot, and any known vulnerabilities against that SSL version and cipher suite combination are checked. These checks include POODLE, deprecated protocols, expired/not valid certs, low key strength, null cipher suites certificates signed with MD5, DROWN, RC4 ciphers, exportable ciphers, LOGJAM, and BEAST. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/ssl/ssl_version.rb",
            "external_id": "ssl_version.rb"
        },
        {
            "source_name": "reference",
            "url": "https://security.googleblog.com/2014/10/this-poodle-bites-exploiting-ssl-30.html"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-3566"
        },
        {
            "source_name": "reference",
            "url": "https://www.openssl.org/~bodo/ssl-poodle.pdf"
        },
        {
            "source_name": "reference",
            "url": "https://datatracker.ietf.org/doc/rfc8996/"
        },
        {
            "source_name": "reference",
            "url": "https://datatracker.ietf.org/doc/html/rfc6176"
        },
        {
            "source_name": "reference",
            "url": "https://datatracker.ietf.org/doc/html/rfc7568"
        },
        {
            "source_name": "reference",
            "url": "https://www.win.tue.nl/hashclash/rogue-ca/"
        },
        {
            "source_name": "reference",
            "url": "https://drownattack.com/"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-0800"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-3389"
        },
        {
            "source_name": "reference",
            "url": "http://www.isg.rhul.ac.uk/tls/"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-2566"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-4000"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-3358"
        },
        {
            "source_name": "info:\"Module#{fullname}confirmedSSLv3isavailable.VulnerabletoPOODLE",
            "external_id": "CVE-2014-3566.\""
        },
        {
            "source_name": "info:\"Module#{fullname}confirmedSSLv2isavailable.VulnerabletoDROWN",
            "external_id": "CVE-2016-0800.\""
        },
        {
            "source_name": "info:\"Module#{fullname}confirmedSSLv3/TLSv1andaCBCcipher.VulnerabletoBEAST",
            "external_id": "CVE-2011-3389.\""
        },
        {
            "source_name": "info:\"Module#{fullname}confirmedDHE_EXPORTbasedcipher.VulnerabletoLOGJAM",
            "external_id": "CVE-2015-4000\""
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n  include Msf::Module::Deprecated\n\n  moved_from 'auxiliary/scanner/http/ssl'\n  moved_from 'auxiliary/scanner/http/ssl_version'\n\n  def initialize\n    super(\n      'Name' => 'SSL/TLS Version Detection',\n      'Description' => %q{\n        Check if a server supports a given version of SSL/TLS and cipher suites.\n\n        The certificate is stored in loot, and any known vulnerabilities against that\n        SSL version and cipher suite combination are checked. These checks include\n        POODLE, deprecated protocols, expired/not valid certs, low key strength, null cipher suites,\n        certificates signed with MD5, DROWN, RC4 ciphers, exportable ciphers, LOGJAM, and BEAST.\n      },\n      'Author' => [\n        'todb', # original ssl scanner for poodle\n        'et', # original ssl certificate module\n        'Chris John Riley', # original ssl certificate additions\n        'Veit Hailperin <hailperv[at]gmail.com>', # original ssl certificate checks for public key size, valid time\n        'h00die' # combining, modernization\n      ],\n      'License' => MSF_LICENSE,\n      'DefaultOptions' => {\n        'SSL' => true,\n        'RPORT' => 443\n      },\n      'References' => [\n        # poodle\n        [ 'URL', 'https://security.googleblog.com/2014/10/this-poodle-bites-exploiting-ssl-30.html' ],\n        [ 'CVE', '2014-3566' ],\n        [ 'URL', 'https://www.openssl.org/~bodo/ssl-poodle.pdf' ],\n        # TLS v1.0 and v1.1 depreciation\n        [ 'URL', 'https://datatracker.ietf.org/doc/rfc8996/' ],\n        # SSLv2 deprecation\n        [ 'URL', 'https://datatracker.ietf.org/doc/html/rfc6176' ],\n        # SSLv3 deprecation\n        [ 'URL', 'https://datatracker.ietf.org/doc/html/rfc7568' ],\n        # MD5 signed certs\n        [ 'URL', 'https://www.win.tue.nl/hashclash/rogue-ca/' ],\n        [ 'CWE', '328' ],\n        # DROWN attack\n        [ 'URL', 'https://drownattack.com/' ],\n        [ 'CVE', '2016-0800' ],\n        # BEAST\n        [ 'CVE', '2011-3389' ],\n        # RC4\n        [ 'URL', 'http://www.isg.rhul.ac.uk/tls/' ],\n        [ 'CVE', '2013-2566' ],\n        # LOGJAM\n        [ 'CVE', '2015-4000' ],\n        # NULL ciphers\n        [ 'CVE', '2022-3358' ],\n        [ 'CWE', '319'],\n        # certificate expired\n        [ 'CWE', '298' ],\n        # certificate broken or risky crypto aglorithms\n        [ 'CWE', '327' ],\n        # certificate inadequate encryption strength\n        [ 'CWE', '326' ]\n      ],\n      'DisclosureDate' => 'Oct 14 2014'\n    )\n\n    register_options(\n      [\n        OptEnum.new('SSLVersion', [ true, 'SSL version to test', 'All', ['All'] + Array.new(OpenSSL::SSL::SSLContext.new.ciphers.length) { |i| (OpenSSL::SSL::SSLContext.new.ciphers[i][1]).to_s }.uniq.reverse]),\n        OptEnum.new('SSLCipher', [ true, 'SSL cipher to test', 'All', ['All'] + Array.new(OpenSSL::SSL::SSLContext.new.ciphers.length) { |i| (OpenSSL::SSL::SSLContext.new.ciphers[i][0]).to_s }.uniq]),\n      ]\n    )\n  end\n\n  def get_metasploit_ssl_versions\n    # There are two ways to generate a list of valid SSL Versions (SSLv3, TLS1.1, etc) and cipher suites (AES256-GCM-SHA384,\n    # ECDHE-RSA-CHACHA20-POLY1305, etc). The first would be to generate them independently. It's possible to\n    # pull all SSLContext methods (SSL Versions) via OpenSSL::SSL::SSLContext::METHODS here, as referenced in\n    # https://github.com/rapid7/rex-socket/blob/6ea0bb3b4e19c53d73e4337617be72c0ed351ceb/lib/rex/socket/ssl_tcp.rb#L46\n    # then pull all ciphers with OpenSSL::Cipher.ciphers. Now in theory you have a nice easy loop:\n    #\n    # OpenSSL::SSL::SSLContext::METHODS.each do |ssl_version|\n    #    OpenSSL::Cipher.ciphers.each do |cipher_suite|\n    #      # do something\n    #    end\n    # end\n    #\n    # However, in practice we find that OpenSSL::SSL::SSLContext::METHODS includes '_client' and '_server' variants\n    # such as :TLSv1, :TLSv1_client, :TLSv1_server. In this case, we only need :TLSv1, so we need to remove ~2/3 of the list.\n    #\n    # Next, we'll find that many ciphers in OpenSSL::Cipher.ciphers are not applicable for various SSL versions.\n    # The loop we previously looked at has (at the time of writing on Kali Rollin, msf 6.2.23) 3060 rounds.\n    # This is a lot of iterations when we already know there are many combinations that will not be applicable for our\n    # use. Luckily there is a 2nd way which is much more efficent.\n    #\n    # The OpenSSL library includes https://docs.ruby-lang.org/en/2.4.0/OpenSSL/SSL/SSLContext.html#method-i-ciphers\n    # which we can use to generate a list of all ciphers, and SSL versions they work with. The structure is:\n    #\n    # [[name, version, bits, alg_bits], ...]\n    #\n    # which makes it very easy to just pull the 2nd element (version, or SSL version) from each list item, and unique it.\n    # This gives us the list of all SSL versions which also have at least one working cipher on our system.\n    # Using this method we produce no unusable SSL versions or matching cipher suites and the list is 60 items long, so 1/51 the size.\n    # Later in get_metasploit_ssl_cipher_suites, we can grab all cipher suites to a SSL version easily by simply filtering\n    # the 2nd element (version, or SSL version) from each list item.\n\n    if datastore['SSLVersion'] == 'All'\n      return Array.new(OpenSSL::SSL::SSLContext.new.ciphers.length) { |i| (OpenSSL::SSL::SSLContext.new.ciphers[i][1]).to_s }.uniq.reverse\n    end\n\n    [datastore['SSLVersion']]\n  end\n\n  def get_metasploit_ssl_cipher_suites(ssl_version)\n    # See comments in get_metasploit_ssl_versions for details on the use of\n    # OpenSSL::SSL::SSLContext.new.ciphers vs other methods to generate\n    # valid ciphers for a given SSL version\n\n    # First find all valid ciphers that the Metasploit host supports.\n    # Also transform the SSL version to a standard format.\n    ssl_version = ssl_version.to_s.gsub('_', '.')\n    all_ciphers = OpenSSL::SSL::SSLContext.new.ciphers\n    valid_ciphers = []\n\n    # For each cipher that the Metasploit host supports, determine if that cipher\n    # is supported for use with the SSL version passed into this function. If it is,\n    # then add it to the valid_ciphers list.\n    all_ciphers.each do |cipher|\n      # cipher list has struct of [cipher, ssl_version, <int>, <int>]\n      if cipher[1] == ssl_version\n        valid_ciphers << cipher[0]\n      end\n    end\n\n    # If the user wants to use all ciphers then return all valid ciphers.\n    # Otherwise return only the one that matches the one the user specified\n    # in the SSLCipher datastore option.\n    #\n    # If no match is found for some reason then we will return an empty array.\n    if datastore['SSLCipher'] == 'All'\n      return valid_ciphers\n    elsif valid_ciphers.contains? datastore['SSLCipher']\n      return [datastore['SSLCipher']]\n    end\n\n    []\n  end\n\n  def public_key_size(cert)\n    if cert.public_key.respond_to? :n\n      return cert.public_key.n.num_bytes * 8\n    end\n\n    0\n  end\n\n  def print_cert(cert, ip)\n    if cert && cert.instance_of?(OpenSSL::X509::Certificate)\n      print_status('Certificate Information:')\n      print_status(\"\\tSubject: #{cert.subject}\")\n      print_status(\"\\tIssuer: #{cert.issuer}\")\n      print_status(\"\\tSignature Alg: #{cert.signature_algorithm}\")\n\n      # If we use ECDSA rather than RSA, our metrics for key size are different\n      print_status(\"\\tPublic Key Size: #{public_key_size(cert)} bits\")\n\n      print_status(\"\\tNot Valid Before: #{cert.not_before}\")\n      print_status(\"\\tNot Valid After: #{cert.not_after}\")\n\n      # Checks for common properties of self signed certificates\n      # regex tried against a bunch of alexa top 100 and others.\n      # https://rubular.com/r/Yj6vyy1VqGWCL8\n      caissuer = nil\n      cert.extensions.each do |e|\n        next unless /CA Issuers - URI:([^, \\n]*)/i =~ e.to_s\n\n        caissuer = ::Regexp.last_match(1)\n        break\n      end\n\n      if caissuer.blank?\n        print_good(\"\\tCertificate contains no CA Issuers extension... possible self signed certificate\")\n      else\n        print_status(\"\\tCA Issuer: #{caissuer}\")\n      end\n\n      if cert.issuer.to_s == cert.subject.to_s\n        print_good(\"\\tCertificate Subject and Issuer match... possible self signed certificate\")\n      end\n\n      alg = cert.signature_algorithm\n\n      if alg.downcase.include? 'md5'\n        print_status(\"\\tWARNING: Signature algorithm using MD5 (#{alg})\")\n      end\n\n      vhostn = nil\n      # Convert the certificate subject field into a series of arrays.\n      # For each array, which will represent one subject, then\n      # go ahead and check if the subject describes a CN entry.\n      #\n      # If it does, then assign the value of vhost name, aka the\n      # second entry in the array,to vhostn\n      cert.subject.to_a.each do |n|\n        vhostn = n[1] if n[0] == 'CN'\n      end\n\n      if vhostn\n        print_status(\"\\tHas common name #{vhostn}\")\n\n        # Store the virtual hostname for HTTP\n        report_note(\n          host: ip,\n          port: rport,\n          proto: 'tcp',\n          type: 'http.vhost',\n          data: { name: vhostn }\n        )\n\n        # Update the server hostname if necessary\n        # https://github.com/rapid7/metasploit-framework/pull/17149#discussion_r1000675472\n        if vhostn !~ /localhost|snakeoil/i\n          report_host(\n            host: ip,\n            name: vhostn\n          )\n        end\n\n      end\n    else\n      print_status(\"\\tNo certificate subject or common name found.\")\n    end\n  end\n\n  def check_vulnerabilities(ip, ssl_version, ssl_cipher, cert)\n    # POODLE\n    if ssl_version == 'SSLv3'\n      print_good('Accepts SSLv3, vulnerable to POODLE')\n      report_vuln(\n        host: ip,\n        port: rport,\n        proto: 'tcp',\n        name: name,\n        info: \"Module #{fullname} confirmed SSLv3 is available. Vulnerable to POODLE, CVE-2014-3566.\",\n        refs: ['CVE-2014-3566']\n      )\n    end\n\n    # DROWN\n    if ssl_version == 'SSLv2'\n      print_good('Accepts SSLv2, vulnerable to DROWN')\n      report_vuln(\n        host: ip,\n        port: rport,\n        proto: 'tcp',\n        name: name,\n        info: \"Module #{fullname} confirmed SSLv2 is available. Vulnerable to DROWN, CVE-2016-0800.\",\n        refs: ['CVE-2016-0800']\n      )\n    end\n\n    # BEAST\n    if ((ssl_version == 'SSLv3') || (ssl_version == 'TLSv1.0')) && ssl_cipher.include?('CBC')\n      print_good('Accepts SSLv3/TLSv1 and a CBC cipher, vulnerable to BEAST')\n      report_vuln(\n        host: ip,\n        port: rport,\n        proto: 'tcp',\n        name: name,\n        info: \"Module #{fullname} confirmed SSLv3/TLSv1 and a CBC cipher. Vulnerable to BEAST, CVE-2011-3389.\",\n        refs: ['CVE-2011-3389']\n      )\n    end\n\n    # RC4 ciphers\n    if ssl_cipher.upcase.include?('RC4')\n      print_good('Accepts RC4 cipher.')\n      report_vuln(\n        host: ip,\n        port: rport,\n        proto: 'tcp',\n        name: name,\n        info: \"Module #{fullname} confirmed RC4 cipher.\",\n        refs: ['CVE-2013-2566']\n      )\n    end\n\n    # export ciphers\n    if ssl_cipher.upcase.include?('EXPORT')\n      print_good('Accepts EXPORT based cipher.')\n      report_vuln(\n        host: ip,\n        port: rport,\n        proto: 'tcp',\n        name: name,\n        info: \"Module #{fullname} confirmed EXPORT based cipher.\",\n        refs: ['CWE-327']\n      )\n    end\n\n    # LOGJAM\n    if ssl_cipher.upcase.include?('DHE_EXPORT')\n      print_good('Accepts DHE_EXPORT based cipher.')\n      report_vuln(\n        host: ip,\n        port: rport,\n        proto: 'tcp',\n        name: name,\n        info: \"Module #{fullname} confirmed DHE_EXPORT based cipher. Vulnerable to LOGJAM, CVE-2015-4000\",\n        refs: ['CVE-2015-4000']\n      )\n    end\n\n    # Null ciphers\n    if ssl_cipher.upcase.include? 'NULL'\n      print_good('Accepts Null cipher')\n      report_vuln(\n        host: ip,\n        port: rport,\n        proto: 'tcp',\n        name: name,\n        info: \"Module #{fullname} confirmed Null cipher.\",\n        refs: ['CVE-2022-3358']\n      )\n    end\n\n    # deprecation\n    if ssl_version == 'SSLv2'\n      print_good('Accepts Deprecated SSLv2')\n      report_vuln(\n        host: ip,\n        port: rport,\n        proto: 'tcp',\n        name: name,\n        info: \"Module #{fullname} confirmed SSLv2, which was deprecated in 2011.\",\n        refs: ['https://datatracker.ietf.org/doc/html/rfc6176']\n      )\n    elsif ssl_version == 'SSLv3'\n      print_good('Accepts Deprecated SSLv3')\n      report_vuln(\n        host: ip,\n        port: rport,\n        proto: 'tcp',\n        name: name,\n        info: \"Module #{fullname} confirmed SSLv3, which was deprecated in 2015.\",\n        refs: ['https://datatracker.ietf.org/doc/html/rfc7568']\n      )\n    elsif ssl_version == 'TLSv1.0'\n      print_good('Accepts Deprecated TLSv1.0')\n      report_vuln(\n        host: ip,\n        port: rport,\n        proto: 'tcp',\n        name: name,\n        info: \"Module #{fullname} confirmed TLSv1.0, which was widely deprecated in 2020.\",\n        refs: ['https://datatracker.ietf.org/doc/rfc8996/']\n      )\n    end\n\n    return if cert.nil?\n\n    key_size = public_key_size(cert)\n    if key_size > 0\n      if key_size == 1024\n        print_good('Public Key only 1024 bits')\n        report_vuln(\n          host: ip,\n          port: rport,\n          proto: 'tcp',\n          name: name,\n          info: \"Module #{fullname} confirmed certificate key size 1024 bits\",\n          refs: ['CWE-326']\n        )\n      elsif key_size < 1024\n        print_good('Public Key < 1024 bits')\n        report_vuln(\n          host: ip,\n          port: rport,\n          proto: 'tcp',\n          name: name,\n          info: \"Module #{fullname} confirmed certificate key size < 1024 bits\",\n          refs: ['CWE-326']\n        )\n      end\n    end\n\n    # certificate signed md5\n    alg = cert.signature_algorithm\n\n    if alg.downcase.include? 'md5'\n      print_good('Certificate signed with MD5')\n      report_vuln(\n        host: ip,\n        port: rport,\n        proto: 'tcp',\n        name: name,\n        info: \"Module #{fullname} confirmed certificate signed with MD5 algo\",\n        refs: ['CWE-328']\n      )\n    end\n\n    # expired\n    if cert.not_after < DateTime.now\n      print_good(\"Certificate expired: #{cert.not_after}\")\n      report_vuln(\n        host: ip,\n        port: rport,\n        proto: 'tcp',\n        name: name,\n        info: \"Module #{fullname} confirmed certificate expired\",\n        refs: ['CWE-298']\n      )\n    end\n\n    # not yet valid\n    if cert.not_before > DateTime.now\n      print_good(\"Certificate not yet valid: #{cert.not_after}\")\n      report_vuln(\n        host: ip,\n        port: rport,\n        proto: 'tcp',\n        name: name,\n        info: \"Module #{fullname} confirmed certificate not yet valid\",\n        refs: []\n      )\n    end\n  end\n\n  # Fingerprint a single host\n  def run_host(ip)\n    # Get the available SSL/TLS versions that that Metasploit host supports\n    versions = get_metasploit_ssl_versions\n\n    certs_found = {}\n    skip_ssl_version = false\n    vprint_status(\"Scanning #{ip} for: #{versions.map(&:to_s).join(', ')}\")\n\n    # For each SSL/TLS version...\n    versions.each do |version|\n      skip_ssl_version = false\n\n      # Get the cipher suites that SSL/TLS can use on the Metasploit host\n      # and print them out.\n      ciphers = get_metasploit_ssl_cipher_suites(version)\n      vprint_status(\"Scanning #{ip} #{version} with ciphers: #{ciphers.map(&:to_s).join(', ')}\")\n\n      # For each cipher attempt to connect to the server. If we could connect with the given SSL version,\n      # then skip it and move onto the next one. If the cipher isn't supported, then note this.\n      # If the server responds with a peer certificate, make a new certificate object from it and find\n      # its fingerprint, then check it for vulnerabilities, before saving it to loot if it hasn't been\n      # saved already (check done using the certificate's SHA1 hash).\n      #\n      # In all cases the SSL version and cipher combination will also be checked for vulnerabilities\n      # using the check_vulnerabilities function.\n      ciphers.each do |cipher|\n        break if skip_ssl_version\n\n        vprint_status(\"Attempting connection with SSL Version: #{version}, Cipher: #{cipher}\")\n        begin\n          # setting the connect global to false means we can't see the socket, therefore the cert\n          connect(true, { 'SSL' => true, 'SSLVersion' => version.sub('.', '_').to_sym, 'SSLCipher' => cipher }) # Force SSL\n          print_good(\"Connected with SSL Version: #{version}, Cipher: #{cipher}\")\n\n          if sock.respond_to? :peer_cert\n            cert = OpenSSL::X509::Certificate.new(sock.peer_cert)\n            # https://stackoverflow.com/questions/16516555/ruby-code-for-openssl-to-generate-fingerprint\n            cert_fingerprint = OpenSSL::Digest::SHA1.new(cert.to_der).to_s\n            if certs_found.key? cert_fingerprint\n              # dont check the cert more than once if its the same cert\n              check_vulnerabilities(ip, version, cipher, nil)\n            else\n              loot_cert = store_loot('ssl.certificate', 'text/plain', ip, cert.to_text)\n              print_good(\"Certificate saved to loot: #{loot_cert}\")\n              print_cert(cert, ip)\n              check_vulnerabilities(ip, version, cipher, cert)\n            end\n            certs_found[cert_fingerprint] = cert\n          end\n        rescue ::OpenSSL::SSL::SSLError => e\n          error_message = e.message.match(/ state=(.+)$/)\n\n          if error_message.nil?\n            vprint_error(\"\\tSSL Connection Error: #{e}\")\n            next\n          end\n\n          # catch if the ssl_version/protocol isn't allowed and then we can skip out of it.\n          if error_message[1].include? 'no protocols available'\n            skip_ssl_version = true\n            vprint_error(\"\\tDoesn't accept #{version} connections, Skipping\")\n            break\n          end\n          vprint_error(\"\\tDoes not accept #{version} using cipher #{cipher}, error message: #{error_message[1]}\")\n        rescue ArgumentError => e\n          if e.message.match(%r{This version of Ruby does not support the requested SSL/TLS version})\n            skip_ssl_version = true\n            vprint_error(\"\\t#{e.message}, Skipping\")\n            break\n          end\n          print_error(\"Exception encountered: #{e}\")\n        rescue StandardError => e\n          if e.message.match(/connection was refused/) || e.message.match(/timed out/)\n            print_error(\"\\tPort closed or timeout occured.\")\n            return 'Port closed or timeout occured.'\n          end\n          print_error(\"\\tException encountered: #{e}\")\n        ensure\n          disconnect\n        end\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "Oct 14 2014"
}