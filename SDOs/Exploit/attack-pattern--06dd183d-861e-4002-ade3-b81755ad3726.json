{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--06dd183d-861e-4002-ade3-b81755ad3726",
    "created": "2024-08-14T16:26:52.940074Z",
    "modified": "2024-08-14T16:26:52.940078Z",
    "name": "Siemens Profinet Scanner",
    "description": " This module will use Layer2 packets, known as Profinet Discovery packets to detect all Siemens (and sometimes other) devices on a network. It is perfectly SCADA-safe, as there will only be ONE single packet sent out. Devices will respond with their IP configuration and hostnames. Created by XiaK Industrial Security Research Center (www[dot]xiak[dot]be))  'References'  => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/scada/profinet_siemens.rb",
            "external_id": "profinet_siemens.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/tijldeneut/ICSSecurityScripts"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'packetfu'\n\nclass MetasploitModule < Msf::Auxiliary\n  def initialize\n    super(\n      'Name'        => 'Siemens Profinet Scanner',\n      'Description' => %q{\n          This module will use Layer2 packets, known as Profinet Discovery packets,\n        to detect all Siemens (and sometimes other) devices on a network.\n        It is perfectly SCADA-safe, as there will only be ONE single packet sent out.\n        Devices will respond with their IP configuration and hostnames.\n        Created by XiaK Industrial Security Research Center (www[dot]xiak[dot]be))\n      },\n      'References'  =>\n        [\n          [ 'URL', 'https://wiki.wireshark.org/PROFINET/DCP' ],\n          [ 'URL', 'https://github.com/tijldeneut/ICSSecurityScripts' ]\n        ],\n      'Author'      => 'Tijl Deneut <tijl.deneut[at]howest.be>',\n      'License'     => MSF_LICENSE\n      )\n\n    register_options(\n      [\n        OptString.new('INTERFACE', [ true, 'Set an interface', 'eth0' ]),\n        OptInt.new('ANSWERTIME', [ true, 'Seconds to wait for answers, set longer on slower networks', 2 ])\n      ], self.class\n    )\n  end\n\n  def hex_to_bin(s)\n    s.scan(/../).map { |x| x.hex.chr }.join\n  end\n\n  def bin_to_hex(s)\n    s.each_byte.map { |b| b.to_s(16).rjust(2, '0') }.join\n  end\n\n  def hexint_to_str(s)\n    s.to_i(16).to_s\n  end\n\n  def hex_to_address(s)\n    hexint_to_str(s[0..1]) + '.' + hexint_to_str(s[2..3]) + '.' + hexint_to_str(s[4..5]) + '.' + hexint_to_str(s[6..7])\n  end\n\n  def parse_devicerole(role)\n    arr = { \"01\" => \"IO-Device\", \"02\" => \"IO-Controller\", \"04\" => \"IO-Multidevice\", \"08\" => \"PN-Supervisor\" }\n    return arr[role] unless arr[role].nil?\n    'Unknown'\n  end\n\n  def parse_vendorid(id)\n    return 'Siemens' if id == '002a'\n    'Unknown'\n  end\n\n  def parse_deviceid(id)\n    arr = { \"0a01\" => \"Switch\", \"0202\" => \"PC Simulator\", \"0203\" => \"S7-300 CPU\", \\\n            \"0101\" => \"S7-300\", \"010e\" => \"S7-1500\", \"010d\" => \"S7-1200\", \"0301\" => \"HMI\", \\\n            \"0403\" => \"HMI\", \"010b\" => \"ET200S\" }\n    return arr[id] unless arr[id].nil?\n    'Unknown'\n  end\n\n  def parse_block(block, block_length)\n    block_id = block[0..2 * 2 - 1]\n    case block_id\n    when '0201'\n      type_of_station = hex_to_bin(block[4 * 2..4 * 2 + block_length * 2 - 1])\n      print_line(\"Type of station: #{type_of_station}\")\n    when '0202'\n      name_of_station = hex_to_bin(block[4 * 2..4 * 2 + block_length * 2 - 1])\n      print_line(\"Name of station: #{name_of_station}\")\n    when '0203'\n      vendor_id = parse_vendorid(block[6 * 2..8 * 2 - 1])\n      device_id = parse_deviceid(block[8 * 2..10 * 2 - 1])\n      print_line(\"Vendor and Device Type: #{vendor_id}, #{device_id}\")\n    when '0204'\n      device_role = parse_devicerole(block[6 * 2..7 * 2 - 1])\n      print_line(\"Device Role: #{device_role}\")\n    when '0102'\n      ip = hex_to_address(block[6 * 2..10 * 2 - 1])\n      snm = hex_to_address(block[10 * 2..14 * 2 - 1])\n      gw = hex_to_address(block[14 * 2..18 * 2 - 1])\n      print_line(\"IP, Subnetmask and Gateway are: #{ip}, #{snm}, #{gw}\")\n    end\n  end\n\n  def parse_profinet(data)\n    data_to_parse = data[24..-1]\n\n    until data_to_parse.empty?\n      block_length = data_to_parse[2 * 2..4 * 2 - 1].to_i(16)\n      block = data_to_parse[0..(4 + block_length) * 2 - 1]\n\n      parse_block(block, block_length)\n\n      padding = block_length % 2\n      data_to_parse = data_to_parse[(4 + block_length + padding) * 2..-1]\n    end\n  end\n\n  def receive(iface, answertime)\n    capture = PacketFu::Capture.new(iface: iface, start: true, filter: 'ether proto 0x8892')\n    sleep answertime\n    capture.save\n    i = 0\n    capture.array.each do |packet|\n      data = bin_to_hex(packet).downcase\n      mac = data[12..13] + ':' + data[14..15] + ':' + data[16..17] + ':' + data[18..19] + ':' + data[20..21] + ':' + data[22..23]\n      next unless data[28..31] == 'feff'\n      print_good(\"Parsing packet from #{mac}\")\n      parse_profinet(data[28..-1])\n      print_line('')\n      i += 1\n    end\n    if i.zero?\n      print_warning('No devices found, maybe you are running virtually?')\n    else\n      print_good(\"I found #{i} devices for you!\")\n    end\n  end\n\n  def run\n    iface = datastore['INTERFACE']\n    answertime = datastore['ANSWERTIME']\n    packet = \"\\x00\\x00\\x88\\x92\\xfe\\xfe\\x05\\x00\\x04\\x00\\x00\\x03\\x00\\x80\\x00\\x04\\xff\\xff\\x00\\x00\\x00\\x00\"\n    packet += \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\n    eth_pkt = PacketFu::EthPacket.new\n    begin\n      eth_pkt.eth_src = PacketFu::Utils.whoami?(iface: iface)[:eth_src]\n    rescue\n      print_error(\"Error: interface #{iface} not active?\")\n      return\n    end\n    eth_pkt.eth_daddr = \"01:0e:cf:00:00:00\"\n    eth_pkt.eth_proto = 0x8100\n    eth_pkt.payload = packet\n    print_status(\"Sending packet out to #{iface}\")\n    eth_pkt.to_w(iface)\n\n    receive(iface, answertime)\n  end\nend\n",
    "x_mitre_contributors": [
        "Tijl Deneut <tijl.deneut[at]howest.be>",
        ""
    ]
}