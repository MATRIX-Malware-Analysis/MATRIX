{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d2e9ee75-3fa2-4854-b942-9d61bff1950d",
    "created": "2024-08-14T16:32:53.763691Z",
    "modified": "2024-08-14T16:32:53.763695Z",
    "name": "DNS Lookup Result Comparison",
    "description": " This module can be used to determine differences in the cache entries between two DNS servers. This is primarily useful for detecting cache poisoning attacks but can also be used to detect geo-location load balancing. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/spoof/dns/compare_results.rb",
            "external_id": "compare_results.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'net/dns'\nrequire 'resolv'\n\nclass MetasploitModule < Msf::Auxiliary\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'DNS Lookup Result Comparison',\n      'Description'    => %q{\n        This module can be used to determine differences\n      in the cache entries between two DNS servers. This is\n      primarily useful for detecting cache poisoning attacks,\n      but can also be used to detect geo-location load balancing.\n      },\n      'Author'         => [ 'hdm' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n        ],\n      'DisclosureDate' => '2008-07-21'\n      ))\n\n      register_options(\n        [\n          OptAddress.new('BASEDNS', [ true,  'The DNS cache server to use as a baseline', '4.2.2.3' ]),\n          OptAddress.new('TARGDNS', [ true,  'The DNS cache server to test', nil ]),\n          OptString.new('NAMES',    [ true,  'The list of host names that should be tested (comma separated)', 'www.google.com,www.yahoo.com,www.msn.com']),\n          OptBool.new('CHECK_AUTHORITY',  [ false, 'Set this to true to verify authority records', false ]),\n          OptBool.new('CHECK_ADDITIONAL', [ false, 'Set this to true to verify additional records', false ]),\n\n        ])\n\n  end\n\n\n  def run\n    base_addr = datastore['BASEDNS']\n    targ_addr = datastore['TARGDNS']\n    check_ar  = datastore['CHECK_ADDITIONAL']\n    check_aa  = datastore['CHECK_AUTHORITY']\n    names     = datastore['NAMES'].split(\",\").map {|c| c.strip }\n    recurse   = true\n    results   = {}\n\n    print_status(\"Comparing results between #{base_addr} and #{targ_addr}...\")\n\n    base_sock = Rex::Socket.create_udp(\n      'PeerHost' => base_addr,\n      'PeerPort' => 53\n    )\n\n    targ_sock = Rex::Socket.create_udp(\n      'PeerHost' => targ_addr,\n      'PeerPort' => 53\n    )\n\n    names.each do |entry|\n      entry.strip!\n      next if (entry.length == 0)\n\n      req = Resolv::DNS::Message.new\n      req.add_question(entry, Resolv::DNS::Resource::IN::A)\n      req.rd = recurse ? 1 : 0\n\n      buf = req.encode\n      print_status(\"Querying servers for #{entry}...\")\n      base_sock.put(buf)\n      targ_sock.put(buf)\n\n      base_res, base_saddr = base_sock.recvfrom(65535, 3.0)\n      targ_res, targ_saddr = targ_sock.recvfrom(65535, 3.0)\n\n      if !(base_res and targ_res and base_res.length > 0 and targ_res.length > 0)\n        print_error(\"  Error: The baseline server did not respond to our request.\") if ! (base_res and base_res.length > 0)\n        print_error(\"  Error: The target server did not respond to our request.\") if ! (targ_res and targ_res.length > 0)\n        next\n      end\n\n      base_res = Resolv::DNS::Message.decode(base_res)\n      targ_res = Resolv::DNS::Message.decode(targ_res)\n\n      [base_res, targ_res].each do |res|\n        hkey = (res == base_res) ? :base : :targ\n\n        rrset = res.answer\n        rrset += res.authority  if check_aa\n        rrset += res.additional if check_ar\n\n        (rrset).each do |ref|\n          name,ttl,data = ref\n\n          name = name.to_s\n          anst = data.class.to_s.gsub(/^.*Resolv::DNS::Resource::IN::/, '')\n          case data\n          when Resolv::DNS::Resource::IN::NS\n            data = data.name.to_s\n          when Resolv::DNS::Resource::IN::MX\n            data = data.exchange.to_s\n          when Resolv::DNS::Resource::IN::A\n            data = data.address.to_s\n          when Resolv::DNS::Resource::IN::TXT\n            data = data.strings.join\n          when Resolv::DNS::Resource::IN::CNAME\n            data = data.name.to_s\n          else\n            data = anst\n          end\n\n          results[entry]||={}\n          results[entry][hkey]||={}\n          results[entry][hkey][anst]||=[]\n          results[entry][hkey][anst] << data\n        end\n      end\n    end\n\n    [ base_sock, targ_sock ].each {|s| s.close }\n\n\n    print_status(\"Analyzing results for #{results.keys.length} entries...\")\n\n    results.each_key do |entry|\n\n      n_add = []\n      n_sub = []\n\n      # Look for additional entries in the target NS\n      if(results[entry][:targ])\n        results[entry][:targ].each_key do |rtype|\n          if(not results[entry][:base] or not results[entry][:base][rtype])\n            results[entry][:targ][rtype].sort.each do |ref|\n              n_sub << (\"  + #{entry} #{rtype} #{ref}\")\n            end\n          end\n        end\n      end\n\n      if (results[entry][:base])\n        results[entry][:base].each_key do |rtype|\n\n          # Look for missing entries in the target NS\n          if(not results[entry][:targ] or not results[entry][:targ][rtype])\n            results[entry][:base][rtype].sort.each do |ref|\n              n_sub << (\"  - #{entry} #{rtype} #{ref}\")\n            end\n            next\n          end\n\n          # Look for differences\n          if( results[entry][:base][rtype].sort !=  results[entry][:targ][rtype].sort )\n            results[entry][:base][rtype].sort.each do |ref|\n              if(not results[entry][:targ][rtype].include?(ref))\n                n_sub << (\"  - #{entry} #{rtype} #{ref}\")\n              end\n            end\n            results[entry][:targ][rtype].sort.each do |ref|\n              if(not results[entry][:base][rtype].include?(ref))\n                n_add << (\"  + #{entry} #{rtype} #{ref}\")\n              end\n            end\n          end\n        end\n      end\n\n      n_sub.each {|s| print_status(s) }\n      n_add.each {|s| print_status(s) }\n    end\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2008-07-21"
}