{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3b5c0397-38c5-4fb7-989a-bae89032c3b1",
    "created": "2024-08-14T16:31:24.845484Z",
    "modified": "2024-08-14T16:31:24.845488Z",
    "name": "IEC104 Client Utility",
    "description": "( This module allows sending 104 commands. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/client/iec104/iec104.rb",
            "external_id": "iec104.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  #\n  # this module sends IEC104 commands\n  #\n\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'          => 'IEC104 Client Utility',\n      'Description'   => %q(\n         This module allows sending 104 commands.\n      ),\n      'Author'         =>\n        [\n          'Michael John <mjohn.info[at]gmail.com>'\n        ],\n      'License'        => MSF_LICENSE,\n      'Actions'        =>\n        [\n          ['SEND_COMMAND', 'Description' => 'Send command to device']\n        ],\n      'DefaultAction' => 'SEND_COMMAND'))\n\n    register_options(\n      [\n        Opt::RPORT(2404),\n        OptInt.new('ORIGINATOR_ADDRESS', [true, \"Originator Address\", 0]),\n        OptInt.new('ASDU_ADDRESS', [true, \"Common Address of ASDU\", 1]),\n        OptInt.new('COMMAND_ADDRESS', [true, \"Command Address / IOA Address\", 0]),\n        OptInt.new('COMMAND_TYPE', [true, \"Command Type\", 100]),\n        OptInt.new('COMMAND_VALUE', [true, \"Command Value\", 20])\n      ]\n    )\n  end\n\n  # sends the frame data over tcp connection and returns received string\n  # using sock.get is causing quite some delay, but scripte needs to process responses from 104 server\n  def send_frame(data)\n    begin\n      sock.put(data)\n      sock.get(-1, sock.def_read_timeout)\n    rescue StandardError => e\n      print_error(\"Error:\" + e.message)\n    end\n  end\n\n  # ACPI formats:\n  # TESTFR_CON = '\\x83\\x00\\x00\\x00'\n  # TESTFR_ACT = '\\x43\\x00\\x00\\x00'\n  # STOPDT_CON = '\\x23\\x00\\x00\\x00'\n  # STOPDT_ACT = '\\x13\\x00\\x00\\x00'\n  # STARTDT_CON = '\\x0b\\x00\\x00\\x00'\n  # STARTDT_ACT = '\\x07\\x00\\x00\\x00'\n\n  # creates and STARTDT Activation frame -> answer should be a STARTDT confirmation\n  def startcon\n    apci_data = \"\\x68\"\n    apci_data << \"\\x04\"\n    apci_data << \"\\x07\"\n    apci_data << \"\\x00\"\n    apci_data << \"\\x00\"\n    apci_data << \"\\x00\"\n    apci_data\n  end\n\n  # creates and STOPDT Activation frame -> answer should be a STOPDT confirmation\n  def stopcon\n    apci_data = \"\\x68\"\n    apci_data << \"\\x04\"\n    apci_data << \"\\x13\"\n    apci_data << \"\\x00\"\n    apci_data << \"\\x00\"\n    apci_data << \"\\x00\"\n    apci_data\n  end\n\n  # creates the acpi header of a 104 message\n  def make_apci(asdu_data)\n    apci_data = \"\\x68\"\n    apci_data << [asdu_data.size + 4].pack(\"c\") # size byte\n    apci_data << String([$tx].pack('v'))\n    apci_data << String([$rx].pack('v'))\n    $rx = $rx + 2\n    $tx = $tx + 2\n    apci_data << asdu_data\n    apci_data\n  end\n\n  # parses the header of a 104 message\n  def parse_headers(response_data)\n    if !response_data[0].eql?(\"\\x04\") && !response_data[1].eql?(\"\\x01\")\n      $rx = + (response_data[2].unpack('H*').first + response_data[1].unpack('H*').first).to_i(16)\n      print_good(\"    TX: \" + response_data[4].unpack('H*').first + response_data[3].unpack('H*').first + \\\n                 \" RX: \" + response_data[2].unpack('H*').first + response_data[1].unpack('H*').first)\n    end\n    if response_data[7].eql?(\"\\x07\")\n      print_good(\"    CauseTx: \" + response_data[7].unpack('H*').first + \" (Activation Confirmation)\")\n    elsif response_data[7].eql?(\"\\x0a\")\n      print_good(\"    CauseTx: \" + response_data[7].unpack('H*').first + \" (Termination Activation)\")\n    elsif response_data[7].eql?(\"\\x14\")\n      print_good(\"    CauseTx: \" + response_data[7].unpack('H*').first + \" (Inrogen)\")\n    elsif response_data[7].eql?(\"\\x0b\")\n      print_good(\"    CauseTx: \" + response_data[7].unpack('H*').first + \" (Feedback by distant command / Retrem)\")\n    elsif response_data[7].eql?(\"\\x03\")\n      print_good(\"    CauseTx: \" + response_data[7].unpack('H*').first + \" (Spontaneous)\")\n    elsif response_data[7].eql?(\"\\x04\")\n      print_good(\"    CauseTx: \" + response_data[7].unpack('H*').first + \" (Initialized)\")\n    elsif response_data[7].eql?(\"\\x05\")\n      print_good(\"    CauseTx: \" + response_data[7].unpack('H*').first + \" (Interrogation)\")\n    elsif response_data[7].eql?(\"\\x06\")\n      print_good(\"    CauseTx: \" + response_data[7].unpack('H*').first + \" (Activiation)\")\n\n    # 104 error messages\n    elsif response_data[7].eql?(\"\\x2c\")\n      print_error(\"    CauseTx: \" + response_data[7].unpack('H*').first + \" (Type Identification Unknown)\")\n    elsif response_data[7].eql?(\"\\x2d\")\n      print_error(\"   CauseTx: \" + response_data[7].unpack('H*').first + \" (Cause Unknown)\")\n    elsif response_data[7].eql?(\"\\x2e\")\n      print_error(\"    CauseTx: \" + response_data[7].unpack('H*').first + \" (ASDU Address Unknown)\")\n    elsif response_data[7].eql?(\"\\x2f\")\n      print_error(\"    CauseTx: \" + response_data[7].unpack('H*').first + \" (IOA Address Unknown)\")\n    elsif response_data[7].eql?(\"\\x6e\")\n      print_error(\"    CauseTx: \" + response_data[7].unpack('H*').first + \" (Unknown Comm Address ASDU)\")\n    end\n  end\n\n  ##############################################################################################################\n  # following functions parse different 104 ASDU messages and prints it content, not all messages of the standard are currently implemented\n  ##############################################################################################################\n  def parse_m_sp_na_1(response_data)\n    sq_bit = Integer(response_data[6].unpack('C').first) & 0b10000000 # this bit determines the object addressing structure\n    response_data = response_data[11..-1] # cut out acpi data\n    if sq_bit.eql?(0b10000000)\n      ioa = response_data[0..3] # extract ioa value\n      response_data = response_data[3..-1] # cut ioa from message\n      i = 0\n      while response_data.length >= 1\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16) + i) + \\\n                   \" SIQ: 0x\" + response_data[0].unpack('H*').first)\n        response_data = response_data[1..-1]\n        i += 1\n      end\n    else\n      while response_data.length >= 4\n        ioa = response_data[0..3] # extract ioa\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16)) + \\\n                   \" SIQ: 0x\" + response_data[3].unpack('H*').first)\n        response_data = response_data[4..-1]\n      end\n    end\n  end\n\n  def parse_m_me_nb_1(response_data)\n    sq_bit = Integer(response_data[6].unpack('C').first) & 0b10000000\n    response_data = response_data[11..-1] # cut out acpi data\n    if sq_bit.eql?(0b10000000)\n      ioa = response_data[0..3]\n      response_data = response_data[3..-1]\n      i = 0\n      while response_data.length >= 3\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16) + i) + \\\n                   \" Value: 0x\" + response_data[0..1].unpack('H*').first + \" QDS: 0x\" + response_data[2].unpack('H*').first)\n        response_data = response_data[3..-1]\n        i += 1\n      end\n    else\n      while response_data.length >= 6\n        ioa = response_data[0..5]\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16)) + \\\n                   \" Value: 0x\" + response_data[3..4].unpack('H*').first + \" QDS: 0x\" + + response_data[5].unpack('H*').first)\n        response_data = response_data[6..-1]\n      end\n    end\n  end\n\n  def parse_c_sc_na_1(response_data)\n    sq_bit = Integer(response_data[6].unpack('C').first) & 0b10000000\n    response_data = response_data[11..-1] # cut out acpi data\n    if sq_bit.eql?(0b10000000)\n      ioa = response_data[0..3]\n      response_data = response_data[3..-1]\n      i = 0\n      while response_data.length >= 1\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16) + i) + \\\n                   \" DIQ: 0x\" + response_data[0].unpack('H*').first)\n        response_data = response_data[1..-1]\n        i += 1\n      end\n    else\n      while response_data.length >= 4\n        ioa = response_data[0..3]\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16)) + \\\n                   \" DIQ: 0x\" + response_data[3].unpack('H*').first)\n        response_data = response_data[4..-1]\n      end\n    end\n  end\n\n  def parse_m_dp_na_1(response_data)\n    sq_bit = Integer(response_data[6].unpack('C').first) & 0b10000000\n    response_data = response_data[11..-1] # cut out acpi data\n    if sq_bit.eql?(0b10000000)\n      ioa = response_data[0..3]\n      response_data = response_data[3..-1]\n      i = 0\n      while response_data.length >= 1\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16) + i) + \\\n                   \" SIQ: 0x\" + response_data[0].unpack('H*').first)\n        response_data = response_data[1..-1]\n        i += 1\n      end\n    else\n      while response_data.length >= 4\n        ioa = response_data[0..3]\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16)) + \\\n                   \" SIQ: 0x\" + response_data[3].unpack('H*').first)\n        response_data = response_data[4..-1]\n      end\n    end\n  end\n\n  def parse_m_st_na_1(response_data)\n    sq_bit = Integer(response_data[6].unpack('C').first) & 0b10000000\n    response_data = response_data[11..-1] # cut out acpi data\n    if sq_bit.eql?(0b10000000)\n      ioa = response_data[0..3]\n      response_data = response_data[3..-1]\n      i = 0\n      while response_data.length >= 2\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16) + i) + \\\n                   \" VTI: 0x\" + response_data[0].unpack('H*').first + \" QDS: 0x\" + response_data[1].unpack('H*').first)\n        response_data = response_data[2..-1]\n        i += 1\n      end\n    else\n      while response_data.length >= 5\n        ioa = response_data[0..4]\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16)) + \\\n                   \" VTI: 0x\" + response_data[3].unpack('H*').first + \" QDS: 0x\" + response_data[4].unpack('H*').first)\n        response_data = response_data[5..-1]\n      end\n    end\n  end\n\n  def parse_m_dp_tb_1(response_data)\n    sq_bit = Integer(response_data[6].unpack('C').first) & 0b10000000\n    response_data = response_data[11..-1] # cut out acpi data\n    if sq_bit.eql?(0b10000000)\n      ioa = response_data[0..3]\n      response_data = response_data[3..-1]\n      i = 0\n      while response_data.length >= 8\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16) + i) + \\\n                   \" DIQ: 0x\" + response_data[0].unpack('H*').first)\n        print_cp56time2a(response_data[1..7])\n        response_data = response_data[8..-1]\n        i += 1\n      end\n    else\n      while response_data.length >= 11\n        ioa = response_data[0..10]\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16)) + \\\n                   \" DIQ: 0x\" + response_data[3].unpack('H*').first)\n        print_cp56time2a(response_data[4..10])\n        response_data = response_data[11..-1]\n      end\n    end\n  end\n\n  def parse_m_sp_tb_1(response_data)\n    sq_bit = Integer(response_data[6].unpack('C').first) & 0b10000000\n    response_data = response_data[11..-1] # cut out acpi data\n    if sq_bit.eql?(0b10000000)\n      ioa = response_data[0..3]\n      response_data = response_data[3..-1]\n      i = 0\n      while response_data.length >= 8\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16) + i) + \\\n                   \" SIQ: 0x\" + response_data[0].unpack('H*').first)\n        print_cp56time2a(response_data[1..7])\n        response_data = response_data[8..-1]\n        i += 1\n      end\n    else\n      while response_data.length >= 11\n        ioa = response_data[0..10]\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16)) + \\\n                   \" SIQ: 0x\" + response_data[3].unpack('H*').first)\n        print_cp56time2a(response_data[4..10])\n        response_data = response_data[11..-1]\n      end\n    end\n  end\n\n  def parse_c_dc_na_1(response_data)\n    sq_bit = Integer(response_data[6].unpack('C').first) & 0b10000000\n    response_data = response_data[11..-1] # cut out acpi data\n    if sq_bit.eql?(0b10000000)\n      ioa = response_data[0..3]\n      response_data = response_data[3..-1]\n      i = 0\n      while response_data.length >= 1\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16) + i) + \\\n                   \" DCO: 0x\" + response_data[0].unpack('H*').first)\n        response_data = response_data[1..-1]\n        i += 1\n      end\n    else\n      while response_data.length >= 4\n        ioa = response_data[0..3]\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16)) + \\\n                   \" DCO: 0x\" + response_data[3].unpack('H*').first)\n        response_data = response_data[4..-1]\n      end\n    end\n  end\n\n  def parse_m_me_na_1(response_data)\n    sq_bit = Integer(response_data[6].unpack('C').first) & 0b10000000\n    response_data = response_data[11..-1] # cut out acpi data\n    if sq_bit.eql?(0b10000000)\n      ioa = response_data[0..3]\n      response_data = response_data[3..-1]\n      i = 0\n      while response_data.length >= 3\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16) + i) + \\\n                   \" Value: 0x\" + response_data[0..1].unpack('H*').first + \" QDS: 0x\" + response_data[2].unpack('H*').first)\n        response_data = response_data[3..-1]\n        i += 1\n      end\n    else\n      while response_data.length >= 6\n        ioa = response_data[0..3]\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16)) + \\\n                   \" Value: 0x\" + ioa[3..4].unpack('H*').first + \" QDS: 0x\" + response_data[5].unpack('H*').first)\n        response_data = response_data[6..-1]\n      end\n    end\n  end\n\n  def parse_m_me_nc_1(response_data)\n    sq_bit = Integer(response_data[6].unpack('C').first) & 0b10000000\n    response_data = response_data[11..-1] # cut out acpi data\n    if sq_bit.eql?(0b10000000)\n      ioa = response_data[0..3]\n      response_data = response_data[3..-1]\n      i = 0\n      while response_data.length >= 5\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16) + i) + \\\n                   \" Value: 0x\" + response_data[0..3].unpack('H*').first + \" QDS: 0x\" + response_data[4].unpack('H*').first)\n        response_data = response_data[5..-1]\n        i += 1\n      end\n    else\n      while response_data.length >= 8\n        ioa = response_data[0..3]\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16)) + \\\n                   \" Value: 0x\" + response_data[3..6].unpack('H*').first + \" QDS: 0x\" + response_data[7].unpack('H*').first)\n        response_data = response_data[8..-1]\n      end\n    end\n  end\n\n  def parse_m_it_na_1(response_data)\n    sq_bit = Integer(response_data[6].unpack('C').first) & 0b10000000\n    response_data = response_data[11..-1] # cut out acpi data\n    if sq_bit.eql?(0b10000000)\n      response_data = response_data[11..-1]\n      ioa = response_data[0..3]\n      i = 0\n      while response_data.length >= 5\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16) + i) + \\\n                   \" Value: 0x\" + response_data[0..3].unpack('H*').first + \" QDS: 0x\" + response_data[4].unpack('H*').first)\n        response_data = response_data[5..-1]\n        i += 1\n      end\n    else\n      while response_data.length >= 8\n        ioa = response_data[0..3]\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16)) + \\\n                   \" Value: 0x\" + response_data[3..6].unpack('H*').first + \" QDS: 0x\" + response_data[7].unpack('H*').first)\n        response_data = response_data[8..-1]\n      end\n    end\n  end\n\n  def parse_m_bo_na_1(response_data)\n    sq_bit = Integer(response_data[6].unpack('C').first) & 0b10000000\n    response_data = response_data[11..-1] # cut out acpi data\n    if sq_bit.eql?(0b10000000)\n      ioa = response_data[0..3]\n      response_data = response_data[3..-1]\n      i = 0\n      while response_data.length >= 5\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16) + i) + \\\n                   \" Value: 0x\" + response_data[0..3].unpack('H*').first + \" QDS: 0x\" + response_data[4].unpack('H*').first)\n        response_data = response_data[5..-1]\n        i += 1\n      end\n    else\n      while response_data.length >= 8\n        ioa = response_data[0..3]\n        print_good(\"    IOA: \" + String((ioa[2].unpack('H*').first + ioa[1].unpack('H*').first + ioa[0].unpack('H*').first).to_i(16)) + \\\n                   \" Value: 0x\" + response_data[3..6].unpack('H*').first + \" QDS: 0x\" + response_data[7].unpack('H*').first)\n        response_data = response_data[8..-1]\n      end\n    end\n  end\n\n  # function to parses time format used in IEC 104\n  # function ported to ruby from: https://github.com/Ebolon/iec104\n  def print_cp56time2a(buf)\n    us = ((Integer(buf[1].unpack('c').first) & 0xFF) << 8) | (Integer(buf[0].unpack('c').first) & 0xFF)\n    second = Integer(us) / 1000\n    us = us % 1000\n    minute = Integer(buf[2].unpack('c').first) & 0x3F\n    hour = Integer(buf[3].unpack('c').first) & 0x1F\n    day = Integer(buf[4].unpack('c').first) & 0x1F\n    month = (Integer(buf[5].unpack('c').first) & 0x0F) - 1\n    year = (Integer(buf[6].unpack('c').first) & 0x7F) + 2000\n    print_good(\"    Timestamp: \" + String(year) + \"-\" + String(format(\"%02d\", month)) + \"-\" + String(format(\"%02d\", day)) + \" \" + \\\n               String(format(\"%02d\", hour)) + \":\" + String(format(\"%02d\", minute)) + \":\" + String(format(\"%02d\", second)) + \".\" + String(us))\n  end\n\n  ##############################################################################################################\n  # END of individual parse functions section\n  ##############################################################################################################\n\n  # parses the 104 response string of a message\n  def parse_response(response)\n    response_elements = response.split(\"\\x68\")\n    response_elements.shift\n    response_elements.each do |response_element|\n      if response_element[5].eql?(\"\\x64\")\n        print_good(\"  Parsing response: Interrogation command (C_IC_NA_1)\")\n        parse_headers(response_element)\n      elsif response_element[5].eql?(\"\\x01\")\n        print_good(\"  Parsing response: Single point information (M_SP_NA_1)\")\n        parse_headers(response_element)\n        parse_m_sp_na_1(response_element)\n      elsif response_element[5].eql?(\"\\x0b\")\n        print_good(\"  Parsing response: Measured value, scaled value (M_ME_NB_1)\")\n        parse_headers(response_element)\n        parse_m_me_nb_1(response_element)\n      elsif response_element[5].eql?(\"\\x2d\")\n        print_good(\"  Parsing response: Single command (C_SC_NA_1)\")\n        parse_headers(response_element)\n        parse_c_sc_na_1(response_element)\n      elsif response_element[5].eql?(\"\\x03\")\n        print_good(\"  Parsing response: Double point information (M_DP_NA_1)\")\n        parse_headers(response_element)\n        parse_m_dp_na_1(response_element)\n      elsif response_element[5].eql?(\"\\x05\")\n        print_good(\"  Parsing response: Step position information (M_ST_NA_1)\")\n        parse_headers(response_element)\n        parse_m_st_na_1(response_element)\n      elsif response_element[5].eql?(\"\\x1f\")\n        print_good(\"  Parsing response: Double point information with time (M_DP_TB_1)\")\n        parse_headers(response_element)\n        parse_m_dp_tb_1(response_element)\n      elsif response_element[5].eql?(\"\\x2e\")\n        print_good(\"  Parsing response: Double command (C_DC_NA_1)\")\n        parse_headers(response_element)\n        parse_c_dc_na_1(response_element)\n      elsif response_element[5].eql?(\"\\x1e\")\n        print_good(\"  Parsing response: Single point information with time (M_SP_TB_1)\")\n        parse_headers(response_element)\n        parse_m_sp_tb_1(response_element)\n      elsif response_element[5].eql?(\"\\x09\")\n        print_good(\"  Parsing response: Measured value, normalized value (M_ME_NA_1)\")\n        parse_headers(response_element)\n        parse_m_me_na_1(response_element)\n      elsif response_element[5].eql?(\"\\x0d\")\n        print_good(\"  Parsing response: Measured value, short floating point value (M_ME_NC_1)\")\n        parse_headers(response_element)\n        parse_m_me_nc_1(response_element)\n      elsif response_element[5].eql?(\"\\x0f\")\n        print_good(\"  Parsing response: Integrated total without time tag (M_IT_NA_1)\")\n        parse_headers(response_element)\n        parse_m_it_na_1(response_element)\n      elsif response_element[5].eql?(\"\\x07\")\n        print_good(\"  Parsing response: Bitstring of 32 bits without time tag. (M_BO_NA_1)\")\n        parse_headers(response_element)\n        parse_m_bo_na_1(response_element)\n\n      elsif response_element[5].eql?(\"\\x46\")\n        print_good(\"Received end of initialisation confirmation\")\n        parse_headers(response_element)\n      elsif response_element[0].eql?(\"\\x04\") && response_element[1].eql?(\"\\x01\") && response_element[2].eql?(\"\\x00\")\n        print_good(\"Received S-Frame\")\n        parse_headers(response_element)\n      elsif response_element[0].eql?(\"\\x04\") && response_element[1].eql?(\"\\x0b\") && response_element[2].eql?(\"\\x00\") && response_element[3].eql?(\"\\x00\")\n        print_good(\"Received STARTDT_ACT\")\n      elsif response_element[0].eql?(\"\\x04\") && response_element[1].eql?(\"\\x23\") && response_element[2].eql?(\"\\x00\") && response_element[3].eql?(\"\\x00\")\n        print_good(\"Received STOPDT_ACT\")\n      elsif response_element[0].eql?(\"\\x04\") && response_element[1].eql?(\"\\x43\") && response_element[2].eql?(\"\\x00\") && response_element[3].eql?(\"\\x00\")\n        print_good(\"Received TESTFR_ACT\")\n      else\n        print_status(\"Received unknown message\")\n        parse_headers(response_element)\n        print_status(response_element.unpack('H*').first)\n      end\n      # Uncomment for print received data\n      # print_good(\"DEBUG: \" + response_element.unpack('H*').first)\n    end\n  end\n\n  # sends 104 command with configure datastore options\n  # default values are for a general interrogation command\n  # for example a switching command would be:\n  #    COMMAND_TYPE => 46   // double command without time\n  #    COMMAND_ADDRESS => 100 // any IOA address that should be switched\n  #    COMMAND_VALUE => 6 // switching off with short pulse\n  #                          use value 5 to switch on with short pulse\n  #\n  # Structure of 104 message:\n  #    1byte command type\n  #    1byte num ix -> 1 (one item send)\n  #    1byte cause of transmission -> 6 (activation)\n  #    1byte originator address\n  #    2byte common adsu address\n  #    3byte command address\n  #    1byte command value\n  def func_send_command\n    print_status(\"Sending 104 command\")\n\n    asdu = [datastore['COMMAND_TYPE']].pack(\"c\") # type of command\n    asdu << \"\\x01\" # num ix -> only one item is send\n    asdu << \"\\x06\" # cause of transmission = activation, 6\n    asdu << [datastore['ORIGINATOR_ADDRESS']].pack(\"c\") # sets originator address of client\n    asdu << String([Integer(datastore['ASDU_ADDRESS'])].pack('v')) # sets the common address of ADSU\n    asdu << String([Integer(datastore['COMMAND_ADDRESS'])].pack('V'))[0..2] # sets the IOA address, todo: check command address fits in the 3byte address field\n    asdu << [datastore['COMMAND_VALUE']].pack(\"c\") # sets the value of the command\n\n    # Uncomment for debugging\n    # print_status(\"Sending: \" + make_apci(asdu).unpack('H*').first)\n    response = send_frame(make_apci(asdu))\n\n    if response.nil?\n      print_error(\"No answer\")\n    else\n      parse_response(response)\n    end\n    print_status(\"operation ended\")\n  end\n\n  def run\n    $rx = 0\n    $tx = 0\n    begin\n      connect\n    rescue StandardError => e\n      print_error(\"Error:\" + e.message)\n      return\n    end\n\n    # send STARTDT_CON to activate connection\n    response = send_frame(startcon)\n    if response.nil?\n      print_error(\"Could not connect to 104 service\")\n      return\n    else\n      parse_response(response)\n    end\n\n    # send the 104 command\n    case action.name\n    when \"SEND_COMMAND\"\n      func_send_command\n    else\n      print_error(\"Invalid ACTION\")\n    end\n\n    # send STOPDT_CON to terminate connection\n    response = send_frame(stopcon)\n    if response.nil?\n      print_error(\"Terminating Connection\")\n      return\n    else\n      print_status(\"Terminating Connection\")\n      parse_response(response)\n    end\n\n    begin\n      disconnect\n    rescue StandardError => e\n      print_error(\"Error:\" + e.message)\n    end\n  end\nend\n"
}