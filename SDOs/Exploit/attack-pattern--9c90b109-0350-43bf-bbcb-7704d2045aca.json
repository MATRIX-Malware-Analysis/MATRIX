{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9c90b109-0350-43bf-bbcb-7704d2045aca",
    "created": "2024-08-14T16:30:31.495628Z",
    "modified": "2024-08-14T16:30:31.495632Z",
    "name": "HTTP Open Proxy Detection",
    "description": " Checks if an HTTP proxy is open. False positive are avoided verifying the HTTP return code and matching a pattern. The CONNECT method is verified only the return code. HTTP headers are shown regarding the use of proxy or load balancer.  'References'  => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/open_proxy.rb",
            "external_id": "open_proxy.rb"
        },
        {
            "source_name": "reference",
            "url": "https://svn.nmap.org/nmap/scripts/http-open-proxy.nse"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::WmapScanServer\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'HTTP Open Proxy Detection',\n      'Description' => %q{\n        Checks if an HTTP proxy is open. False positive are avoided\n        verifying the HTTP return code and matching a pattern.\n        The CONNECT method is verified only the return code.\n        HTTP headers are shown regarding the use of proxy or load balancer.\n      },\n      'References'  =>\n        [\n          ['URL', 'https://en.wikipedia.org/wiki/Open_proxy'],\n          ['URL', 'https://svn.nmap.org/nmap/scripts/http-open-proxy.nse'],\n        ],\n      'Author'      => 'Matteo Cantoni <goony[at]nothink.org>',\n      'License'     => MSF_LICENSE\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(8080),\n        OptBool.new('MULTIPORTS', [ false, 'Multiple ports will be used: 80, 443, 1080, 3128, 8000, 8080, 8123', false ]),\n        OptBool.new('VERIFYCONNECT', [ false, 'Enable CONNECT HTTP method check', false ]),\n        OptString.new('CHECKURL', [ true, 'The web site to test via alleged web proxy', 'http://www.google.com' ]),\n        OptString.new('VALIDCODES', [ true, \"Valid HTTP code for a successfully request\", '200,302' ]),\n        OptString.new('VALIDPATTERN', [ true, \"Valid pattern match (case-sensitive into the headers and HTML body) for a successfully request\", '<TITLE>302 Moved</TITLE>' ]),\n      ])\n\n    register_wmap_options({\n      'OrderID' => 1,\n      'Require' => {},\n    })\n  end\n\n  def run_host(target_host)\n\n    check_url = datastore['CHECKURL']\n\n    if datastore['VERIFYCONNECT']\n      target_method = 'CONNECT'\n      # CONNECT doesn't need <scheme> but need port\n      check_url = check_url.gsub(/[http:\\/\\/|https:\\/\\/]/, '')\n      if check_url !~ /:443$/\n        check_url = check_url + \":443\"\n      end\n    else\n      target_method = 'GET'\n      # GET only http request\n      check_url = check_url.gsub(/https:\\/\\//, '')\n      if check_url !~ /^http:\\/\\//i\n        check_url = 'http://' + check_url\n      end\n    end\n\n    target_ports = []\n\n    if datastore['MULTIPORTS']\n      target_ports = [ 80, 443, 1080, 3128, 8000, 8080, 8123 ]\n    else\n      target_ports.push(datastore['RPORT'].to_i)\n    end\n\n    target_proxy_headers = [ 'Forwarded', 'Front-End-Https', 'Max-Forwards', 'Via', 'X-Cache', 'X-Cache-Lookup', 'X-Client-IP', 'X-Forwarded-For', 'X-Forwarded-Host' ]\n\n    target_ports.each do |target_port|\n      verify_target(target_host,target_port,target_method,check_url,target_proxy_headers)\n    end\n\n  end\n\n  def verify_target(target_host,target_port,target_method,check_url,target_proxy_headers)\n\n    vprint_status(\"#{peer} - Sending a web request... [#{target_method}][#{check_url}]\")\n\n    datastore['RPORT'] = target_port\n\n    begin\n      res = send_request_cgi(\n        'uri'     => check_url,\n        'method'  => target_method,\n        'version' => '1.1'\n      )\n\n      return if not res\n\n      vprint_status(\"#{peer} - Returns with '#{res.code}' status code [#{target_method}][#{check_url}]\")\n\n      valid_codes = datastore['VALIDCODES'].split(/,/)\n\n      target_proxy_headers_results = []\n      target_proxy_headers.each do |proxy_header|\n        if (res.headers.to_s.match(/#{proxy_header}: (.*)/))\n          proxy_header_value = $1\n          # Ok...I don't like it but works...\n          target_proxy_headers_results.push(\"\\n                          |_ #{proxy_header}: #{proxy_header_value}\")\n        end\n      end\n\n      if target_proxy_headers_results.any?\n        proxy_headers = target_proxy_headers_results.join()\n      end\n\n      if datastore['VERIFYCONNECT']\n        # Verifiying CONNECT we check only the return code\n        if valid_codes.include?(res.code.to_s)\n\n          print_good(\"#{peer} - Potentially open proxy [#{res.code}][#{target_method}]#{proxy_headers}\")\n\n          report_note(\n            :host   => target_host,\n            :port   => target_port,\n            :method => target_method,\n            :proto  => 'tcp',\n            :sname  => (ssl ? 'https' : 'http'),\n            :type   => 'OPEN HTTP PROXY',\n            :data   => 'Open http proxy (CONNECT)'\n          )\n\n        end\n      else\n        # Verify return code && (headers.pattern or body.pattern)\n        if valid_codes.include?(res.code.to_s) && (res.headers.include?(datastore['VALIDPATTERN']) || res.body.include?(datastore['VALIDPATTERN']))\n\n          print_good(\"#{peer} - Potentially open proxy [#{res.code}][#{target_method}]#{proxy_headers}\")\n\n          report_note(\n            :host   => target_host,\n            :port   => target_port,\n            :method => target_method,\n            :proto  => 'tcp',\n            :sname  => (ssl ? 'https' : 'http'),\n            :type   => 'OPEN HTTP PROXY',\n            :data   => 'Open http proxy (GET)'\n          )\n\n        end\n      end\n\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Timeout::Error, ::Errno::EPIPE => e\n      vprint_error(\"#{peer} - The port '#{target_port}' is unreachable!\")\n      return nil\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        "Matteo Cantoni <goony[at]nothink.org>",
        ""
    ]
}