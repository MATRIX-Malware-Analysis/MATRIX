{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e9b6a8f1-6de7-4e34-8728-d057eee9da52",
    "created": "2024-08-14T16:30:52.163238Z",
    "modified": "2024-08-14T16:30:52.163242Z",
    "name": "HTTP Directory Brute Force Scanner",
    "description": " This module identifies the existence of interesting directories by brute forcing the name in a given directory path. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/brute_dirs.rb",
            "external_id": "brute_dirs.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'enumerable'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::WmapScanDir\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'   \t\t=> 'HTTP Directory Brute Force Scanner',\n      'Description'\t=> %q{\n        This module identifies the existence of interesting directories by brute forcing the name\n        in a given directory path.\n      },\n      'Author' \t\t=> [ 'et' ],\n      'License'\t\t=> BSD_LICENSE))\n\n    register_options(\n      [\n        OptString.new('PATH', [ true,  \"The path to identify directories\", '/']),\n        OptString.new('FORMAT', [ true,  \"The expected directory format (a alpha, d digit, A upperalpha)\", 'a,aa,aaa']),\n        OptInt.new('TIMEOUT', [true, 'The socket connect/read timeout in seconds', 20]),\n        OptInt.new('DELAY', [true, \"The delay between connections, per thread, in milliseconds\", 0]),\n        OptInt.new('JITTER', [true, \"The delay jitter factor (maximum value by which to +/- DELAY) in milliseconds.\", 0]),\n      ])\n\n    register_advanced_options(\n      [\n        OptInt.new('ErrorCode', [ true,  \"The expected http code for non existant directories\", 404]),\n        OptPath.new('HTTP404Sigs', [ false, \"Path of 404 signatures to use\",\n          File.join(Msf::Config.data_directory, \"wmap\", \"wmap_404s.txt\")\n        ]),\n        OptBool.new('NoDetailMessages', [ false, \"Do not display detailed test messages\", true ]),\n        OptInt.new('TestThreads', [ true, \"Number of test threads\", 25])\n      ])\n  end\n\n  def wmap_enabled\n    true\n  end\n\n  def run_host(ip)\n\n    conn = false\n\n    timeout = datastore['TIMEOUT']\n\n    delay_value = datastore['DELAY'].to_i\n    if delay_value < 0\n      raise Msf::OptionValidateError.new(['DELAY'])\n    end\n\n    jitter_value = datastore['JITTER'].to_i\n    if jitter_value < 0\n      raise Msf::OptionValidateError.new(['JITTER'])\n    end\n\n    tpath = normalize_uri(datastore['PATH'])\n    if tpath[-1,1] != '/'\n      tpath += '/'\n    end\n\n    vhost = datastore['VHOST'] || datastore['RHOST']\n\n    dm = datastore['NoDetailMessages']\n\n    # You may add more extensions in the extens array\n    extens = [\"/\"]\n\n    # You may add multiple formats in the array\n    forma = []\n    forma = datastore['FORMAT'].split(',')\n\n    ecode = datastore['ErrorCode'].to_i\n    extens.each do |exte|\n\n      #\n      # Detect error code\n      #\n      ecode = datastore['ErrorCode'].to_i\n      begin\n        randdir = Rex::Text.rand_text_alpha(5).chomp\n        randdir << exte\n        res = send_request_cgi({\n          'uri'    =>  tpath+randdir,\n          'method' => 'GET',\n          'ctype'  => 'text/html'\n        }, timeout)\n\n        return if not res\n\n        tcode = res.code.to_i\n\n        # Look for a string we can signature on as well\n        if(tcode >= 200 and tcode <= 299)\n          emesg = nil\n          File.open(datastore['HTTP404Sigs'], 'rb').each do |str|\n            if(res.body.index(str))\n              emesg = str\n              break\n            end\n          end\n\n          if(not emesg)\n            print_status(\"Using first 256 bytes of the response as 404 string\")\n            emesg = res.body[0,256]\n          else\n            print_status(\"Using custom 404 string of '#{emesg}'\")\n          end\n        else\n          ecode = tcode\n          print_status(\"Using code '#{ecode}' as not found.\")\n        end\n\n      rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n        conn = false\n      rescue ::Timeout::Error, ::Errno::EPIPE\n      end\n\n      forma.each do |f|\n\n        numb = []\n        f.scan(/./) { |c|\n          case c\n          when 'a'\n            numb << ('a'..'z')\n          when 'd'\n            numb << ('0'..'9')\n          when 'A'\n            numb << ('A'..'Z')\n      # These dont actually work\n      #\t\twhen 'N'\n      #\t\t\tnumb << ('A'..'Z')+('0'..'9')\n      #\t\twhen 'n'\n      #\t\t\tnumb << ('a'..'z')+('0'..'9')\n          else\n            print_error(\"Format string error\")\n            return\n          end\n        }\n\n        #exte.scan(/./) { |c|\n        #\tnumb << \"#{c}\"\n        #}\n\n        Enumerable.cart(*numb).each {|testd|\n\n          strdir = testd.join\n\n          begin\n            teststr = tpath+strdir\n            teststr << exte\n\n            # Add the delay based on JITTER and DELAY if needs be\n            add_delay_jitter(delay_value,jitter_value)\n\n            vprint_status(\"Try... #{wmap_base_url}#{teststr} (#{vhost})\")\n\n            res = send_request_cgi({\n              'uri'    =>  teststr,\n              'method' => 'GET',\n              'ctype'  => 'text/plain'\n            }, timeout)\n\n            if (not res or ((res.code.to_i == ecode) or (emesg and res.body.index(emesg))))\n              if dm == false\n                print_status(\"NOT Found #{wmap_base_url}#{teststr} #{res.code.to_i}\")\n                #blah\n              end\n            else\n              if res.code.to_i == 400  and ecode != 400\n                print_error(\"Server returned an error code. #{wmap_base_url}#{teststr} #{res.code.to_i}\")\n              else\n                print_good(\"Found #{wmap_base_url}#{teststr} #{res.code.to_i}\")\n\n                report_web_vuln({\n                  :host         => rhost,\n                  :port         => rport,\n                  :vhost        => vhost,\n                  :ssl          => ssl,\n                  :path         => \"#{teststr}\",\n                  :method       => 'GET',\n                  :pname        => \"\",\n                  :proof        => \"Res code: #{res.code.to_s}\",\n                  :risk         => 0,\n                  :confidence   => 100,\n                  :category     => 'directory',\n                  :description  => 'Directory found.',\n                  :name         => 'directory'\n                })\n\n              end\n            end\n\n          rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n          rescue ::Timeout::Error, ::Errno::EPIPE\n          end\n        }\n      end\n    end\n  end\nend\n"
}