{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--80fd30f1-4900-4f58-9401-6c84c19fd40f",
    "created": "2024-08-14T16:24:23.758339Z",
    "modified": "2024-08-14T16:24:23.758343Z",
    "name": "SMB Scanner Check File/Directory Utility",
    "description": "Q This module is useful when checking an entire network of SMB hosts for the presence of a known file or directory. An example would be to scan all systems for the presence of antivirus or known malware outbreak. Typically you must set RPATH, SMBUser, SMBDomain and SMBPass to operate correctly. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/smb/check_dir_file.rb",
            "external_id": "check_dir_file.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  # Exploit mixins should be called first\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Exploit::Remote::SMB::Client::Authenticated\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  # Aliases for common classes\n  SIMPLE = Rex::Proto::SMB::SimpleClient\n  XCEPT  = Rex::Proto::SMB::Exceptions\n  CONST  = Rex::Proto::SMB::Constants\n\n\n  def initialize\n    super(\n      'Name'        => 'SMB Scanner Check File/Directory Utility',\n      'Description' => %Q{\n        This module is useful when checking an entire network\n        of SMB hosts for the presence of a known file or directory.\n        An example would be to scan all systems for the presence of\n        antivirus or known malware outbreak. Typically you must set\n        RPATH, SMBUser, SMBDomain and SMBPass to operate correctly.\n      },\n      'Author'      =>\n        [\n          'aushack',\n          'j0hn__f'\n        ],\n      'References'  =>\n        [\n        ],\n      'License'     => MSF_LICENSE\n    )\n\n    register_options([\n      OptString.new('SMBSHARE', [true, 'The name of an accessible share on the server', 'C$']),\n      OptString.new('RPATH', [true, 'The name of the remote file/directory relative to the share'])\n    ])\n\n  end\n\n  def check_path(path)\n    begin\n      if (fd = simple.open(\"\\\\#{path}\", 'o')) # mode is open only - do not create/append/write etc\n        print_good(\"File FOUND: \\\\\\\\#{rhost}\\\\#{datastore['SMBSHARE']}\\\\#{path}\")\n        fd.close\n      end\n    rescue ::Rex::Proto::SMB::Exceptions::ErrorCode => e\n      error_name = e.get_error(e.error_code)\n    rescue ::RubySMB::Error::UnexpectedStatusCode => e\n      error_name = e.status_code.name\n    end\n    if error_name\n      case error_name\n      when \"STATUS_FILE_IS_A_DIRECTORY\"\n        print_good(\"Directory FOUND: \\\\\\\\#{rhost}\\\\#{datastore['SMBSHARE']}\\\\#{path}\")\n      when \"STATUS_OBJECT_NAME_NOT_FOUND\"\n        vprint_error(\"Object \\\\\\\\#{rhost}\\\\#{datastore['SMBSHARE']}\\\\#{path} NOT found!\")\n      when \"STATUS_OBJECT_PATH_NOT_FOUND\"\n        vprint_error(\"Object PATH \\\\\\\\#{rhost}\\\\#{datastore['SMBSHARE']}\\\\#{path} NOT found!\")\n      when \"STATUS_ACCESS_DENIED\"\n        vprint_error(\"Host reports access denied.\")\n      when \"STATUS_BAD_NETWORK_NAME\"\n        vprint_error(\"Host is NOT connected to #{datastore['SMBDomain']}!\")\n      when \"STATUS_INSUFF_SERVER_RESOURCES\"\n        vprint_error(\"Host rejected with insufficient resources!\")\n      when \"STATUS_OBJECT_NAME_INVALID\"\n        vprint_error(\"opening \\\\#{path} bad filename\")\n      else\n        raise e\n      end\n    end\n  end\n\n  def run_host(ip)\n    vprint_status(\"Connecting to the server...\")\n\n    begin\n      connect\n      smb_login\n\n      vprint_status(\"Mounting the remote share \\\\\\\\#{datastore['RHOST']}\\\\#{datastore['SMBSHARE']}'...\")\n      self.simple.connect(\"\\\\\\\\#{rhost}\\\\#{datastore['SMBSHARE']}\")\n      vprint_status(\"Checking for file/folder #{datastore['RPATH']}...\")\n\n      datastore['RPATH'].each_line do |path|\n        check_path(path.chomp)\n      end #end do\n    rescue ::Rex::HostUnreachable\n      vprint_error(\"Host offline.\")\n    rescue ::Rex::Proto::SMB::Exceptions::LoginError\n      print_error(\"Host login error.\")\n    rescue ::Rex::ConnectionRefused\n      print_error \"Unable to connect - connection refused\"\n    rescue ::Rex::Proto::SMB::Exceptions::ErrorCode\n      print_error \"Unable to connect to share #{datastore['SMBSHARE']}\"\n    end # end begin\n  end # end def\nend\n"
}