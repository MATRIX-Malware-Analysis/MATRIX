{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--54b0d4b6-11cb-45e0-bbad-1074d191bbf6",
    "created": "2024-08-14T16:33:17.984096Z",
    "modified": "2024-08-14T16:33:17.984099Z",
    "name": "Gather Available Shell Commands",
    "description": " This module will check which shell commands are available on a system.\" ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/linux/gather/enum_commands.rb",
            "external_id": "enum_commands.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Linux::System\n\n  def initialize\n    super(\n      'Name' => 'Gather Available Shell Commands',\n      'Description' => %q{\n        This module will check which shell commands are available on a system.\"\n      },\n      'Author' => 'Alberto Rafael Rodriguez Iglesias <albertocysec[at]gmail.com>',\n      'License' => MSF_LICENSE,\n      'Platform' => ['linux', 'unix'],\n      'SessionTypes' => ['shell', 'meterpreter'],\n      'Notes' => {\n        'Stability' => [CRASH_SAFE],\n        'Reliability' => [],\n        'SideEffects' => []\n      }\n    )\n    register_options([\n      OptString.new('DIR', [false, 'Optional directory name to list (in addition to default system PATH and common paths)', ''])\n    ])\n  end\n\n  def run\n    path = get_path\n\n    print_warning('System PATH is empty!') if path.blank?\n\n    paths = []\n    path.split(':').each do |p|\n      paths << p.chomp('/')\n    end\n\n    common_dirs = [\n      '/root/local/bin',\n      '/usr/local/sbin',\n      '/usr/local/bin',\n      '/usr/sbin',\n      '/usr/bin',\n      '/sbin',\n      '/bin',\n      '/usr/local/go/bin'\n    ]\n\n    common_dirs << datastore['DIR'] unless datastore['DIR'].blank?\n\n    common_dirs.each do |p|\n      paths << p.chomp('/')\n    end\n\n    binaries = []\n\n    paths.sort.uniq.each do |p|\n      next unless directory?(p)\n\n      files = dir(p)\n\n      next if files.blank?\n\n      files.each do |f|\n        binaries << \"#{p}/#{f.strip}\"\n      end\n    end\n\n    # BusyBox commands\n    busybox_path = nil\n    if command_exists?('busybox')\n      busybox_path = 'busybox'\n    elsif command_exists?('/bin/busybox')\n      busybox_path = '/bin/busybox'\n    end\n\n    unless busybox_path.blank?\n      busybox_cmds = cmd_exec(\"#{busybox_path} --list\")\n      busybox_cmds.each_line do |cmd|\n        binaries << \"busybox #{cmd.strip}\"\n      end\n    end\n\n    # A recursive `ls /` or `find / -executable -type f`\n    # could be added to find extra binaries.\n\n    print_good(\"Found #{binaries.sort.uniq.length} executable binaries/commands\")\n\n    binaries.uniq.sort.each do |bin|\n      print_line(bin)\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "['linux', 'unix']"
    ]
}