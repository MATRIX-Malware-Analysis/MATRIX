{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--55145e9b-f181-4fb2-917d-d85885e9e20b",
    "created": "2024-08-14T16:30:41.748405Z",
    "modified": "2024-08-14T16:30:41.748409Z",
    "name": "HTTP Subversion Scanner",
    "description": "Detect subversion directories and files and analize its content. Only SVN Version > 7 supported",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/svn_scanner.rb",
            "external_id": "svn_scanner.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  # Exploit mixins should be called first\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::WmapScanServer\n  # Scanner mixin should be near last\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'HTTP Subversion Scanner',\n      'Description' => 'Detect subversion directories and files and analize its content. Only SVN Version > 7 supported',\n      'Author'       => ['et'],\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        OptString.new('PATH', [ true,  \"The test path to .svn directory\", '/']),\n        OptBool.new('GET_SOURCE', [ false, \"Attempt to obtain file source code\", true ]),\n        OptBool.new('SHOW_SOURCE', [ false, \"Show source code\", true ])\n\n      ])\n\n    register_advanced_options(\n      [\n        OptInt.new('ErrorCode', [ true, \"Error code for non existent directory\", 404]),\n        OptPath.new('HTTP404Sigs',   [ false, \"Path of 404 signatures to use\",\n            File.join(Msf::Config.data_directory, \"wmap\", \"wmap_404s.txt\")\n          ]\n        ),\n        OptBool.new('NoDetailMessages', [ false, \"Do not display detailed test messages\", true ])\n\n      ])\n  end\n\n  def run_host(target_host)\n    conn = true\n    ecode = nil\n    emesg = nil\n\n    tpath = normalize_uri(datastore['PATH'])\n    if tpath[-1,1] != '/'\n      tpath += '/'\n    end\n\n    ecode = datastore['ErrorCode'].to_i\n    vhost = datastore['VHOST'] || wmap_target_host\n\n    #\n    # Detect error code\n    #\n    begin\n      randdir = Rex::Text.rand_text_alpha(5).chomp + '/'\n      res = send_request_cgi({\n        'uri'  \t\t=>  tpath+randdir,\n        'method'   \t=> 'GET',\n        'ctype'\t\t=> 'text/html'\n      }, 20)\n\n      return if not res\n\n      tcode = res.code.to_i\n\n\n      # Look for a string we can signature on as well\n      if(tcode >= 200 and tcode <= 299)\n\n        File.open(datastore['HTTP404Sigs'], 'rb').each do |str|\n          if(res.body.index(str))\n            emesg = str\n            break\n          end\n        end\n\n        if(not emesg)\n          print_status(\"Using first 256 bytes of the response as 404 string\")\n          emesg = res.body[0,256]\n        else\n          print_status(\"Using custom 404 string of '#{emesg}'\")\n        end\n      else\n        ecode = tcode\n        print_status(\"Using code '#{ecode}' as not found.\")\n      end\n\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      conn = false\n    rescue ::Timeout::Error, ::Errno::EPIPE\n    end\n\n    return if not conn\n\n    dm = datastore['NoDetailMessages']\n\n    begin\n      turl = tpath+'.svn/entries'\n\n      res = send_request_cgi({\n        'uri'          => turl,\n        'method'       => 'GET',\n        'version' => '1.0',\n      }, 10)\n\n      if(not res or ((res.code.to_i == ecode) or (emesg and res.body.index(emesg))))\n        if dm == false\n          print_status(\"[#{target_host}] NOT Found. #{tpath} #{res.code}\")\n        end\n      else\n        print_good(\"[#{target_host}:#{rport}] SVN Entries file found.\")\n\n        report_web_vuln(\n          :host\t=> target_host,\n          :port\t=> rport,\n          :vhost  => vhost,\n          :ssl    => ssl,\n          :path\t=> turl,\n          :method => 'GET',\n          :pname  => \"\",\n          :proof  => \"Res code: #{res.code.to_s}\",\n          :risk   => 0,\n          :confidence   => 100,\n          :category     => 'file',\n          :description  => 'SVN Entry found.',\n          :name   => 'file'\n        )\n\n        vers = res.body[0..1].chomp.to_i\n        if vers <= 6\n          print_error(\"[#{target_host}] Version #{vers} not supported\")\n          return\n        end\n        n = 0\n        res.body.split(\"\\f\\n\").each do |record|\n          resarr = []\n          resarr = record.to_s.split(\"\\n\")\n\n          if n==0\n            #first record\n            version = resarr[0]\n            sname = \"CURRENT\"\n            skind = resarr[2]\n            srevision = resarr[3]\n            surl = resarr[4]\n            slastauthor = resarr[11]\n\n          else\n            sname = resarr[0]\n            skind = resarr[1]\n            srevision = resarr[2]\n            surl = resarr[3]\n            slastauthor = resarr[10]\n          end\n\n          print_status(\"[#{target_host}] #{skind} #{sname} [#{slastauthor}]\")\n\n          if slastauthor and slastauthor.length > 0\n            report_note(\n              :host\t=> target_host,\n              :proto => 'tcp',\n              :sname => (ssl ? 'https' : 'http'),\n              :port\t=> rport,\n              :type\t=> 'USERNAME',\n              :data\t=> slastauthor,\n              :update => :unique_data\n            )\n\n          end\n\n          if skind\n            if skind == 'dir'\n              report_note(\n                :host\t=> target_host,\n                :proto => 'tcp',\n                :sname => (ssl ? 'https' : 'http'),\n                :port\t=> rport,\n                :type\t=> 'DIRECTORY',\n                :data\t=> sname,\n                :update => :unique_data\n              )\n            end\n\n            if skind == 'file'\n              report_note(\n                :host\t=> target_host,\n                :proto => 'tcp',\n                :sname => (ssl ? 'https' : 'http'),\n                :port\t=> rport,\n                :type\t=> 'FILE',\n                :data\t=> sname,\n                :update => :unique_data\n              )\n\n              if datastore['GET_SOURCE']\n                print_status(\"- Trying to get file #{sname} source code.\")\n\n                begin\n                  turl = tpath+'.svn/text-base/'+sname+'.svn-base'\n                  print_status(\"- Location: #{turl}\")\n\n                  srcres = send_request_cgi({\n                    'uri'          => turl,\n                    'method'       => 'GET',\n                    'version' => '1.0',\n                  }, 10)\n\n                  if srcres and srcres.body.length > 0\n                    if datastore['SHOW_SOURCE']\n                      print_status(srcres.body)\n                    end\n\n                    report_note(\n                      :host\t=> target_host,\n                      :proto => 'tcp',\n                      :sname => (ssl ? 'https' : 'http'),\n                      :port\t=> rport,\n                      :type\t=> 'SOURCE_CODE',\n                      :data\t=> \"#{sname} Code: #{srcres.body}\",\n                      :update => :unique_data\n                    )\n                  end\n                rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n                rescue ::Timeout::Error, ::Errno::EPIPE\n                end\n              end\n            end\n          end\n          n += 1\n        end\n        print_status(\"Done. #{n} records.\")\n      end\n\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n    rescue ::Timeout::Error, ::Errno::EPIPE\n    end\n  end\nend\n"
}