{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6031418e-bc65-47bd-a839-49023ce6cfb8",
    "created": "2024-08-14T16:22:00.811832Z",
    "modified": "2024-08-14T16:22:00.811837Z",
    "name": "Native LDAP Server (Example)",
    "description": " This module provides a Rex based LDAP service to expose the native Rex LDAP server functionality created during log4shell development. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/ldap.rb",
            "external_id": "ldap.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::LDAP::Server\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Native LDAP Server (Example)',\n        'Description' => %q{\n          This module provides a Rex based LDAP service to expose the\n          native Rex LDAP server functionality created during log4shell\n          development.\n        },\n        'Author' => [\n          'RageLtMan <rageltman[at]sempervictus>', # infrastructure\n          'Spencer McIntyre' # syntactically sane/correct Ruby LDAP object actions from early effort on l4j2 scanner\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [],\n        'Actions' => [\n          [ 'Service', { 'Description' => 'Run LDAP server' } ]\n        ],\n        'PassiveActions' => [\n          'Service'\n        ],\n        'DefaultAction' => 'Service',\n        'Notes' => {\n          'Stability' => [],\n          'Reliability' => [],\n          'SideEffects' => []\n        }\n      )\n    )\n  end\n\n  #\n  # Wrapper for service execution\n  #\n  def run\n    start_service\n    service.wait\n  rescue Rex::BindFailed => e\n    print_error \"Failed to bind to port #{datastore['SRVPORT']}: #{e.message}\"\n  end\n\n  #\n  # Creates Proc to handle incoming requests\n  #\n  def on_dispatch_request(client, data)\n    return if data.strip.empty?\n\n    data.extend(Net::BER::Extensions::String)\n    begin\n      pdu = Net::LDAP::PDU.new(data.read_ber!(Net::LDAP::AsnSyntax))\n      vprint_status(\"LDAP request data remaining: #{data}\") if !data.empty?\n      resp = case pdu.app_tag\n             when Net::LDAP::PDU::BindRequest # bind request\n               # vprint_good(\"Received LDAP bind request from #{client} - #{pp pdu}\")\n               client.authenticated = true\n               service.encode_ldap_response(\n                 pdu.message_id,\n                 Net::LDAP::ResultCodeSuccess,\n                 '',\n                 '',\n                 Net::LDAP::PDU::BindResult\n               )\n             when Net::LDAP::PDU::SearchRequest # search request\n               if client.authenticated || datastore['LDAP_AUTH_BYPASS']\n                 # Perform query against some loaded LDIF structure\n                 filter = Net::LDAP::Filter.parse_ldap_filter(pdu.search_parameters[:filter])\n                 attrs = pdu.search_parameters[:attributes].empty? ? :all : pdu.search_parameters[:attributes]\n                 res = service.search_ldif(filter, pdu.message_id, attrs)\n                 if res.nil? || res.empty?\n                   service.encode_ldap_response(\n                     pdu.message_id,\n                     Net::LDAP::ResultCodeNoSuchObject, '',\n                     Net::LDAP::ResultStrings[Net::LDAP::ResultCodeNoSuchObject],\n                     Net::LDAP::PDU::SearchResult\n                   )\n                 else\n                   # Send the results and return success message for callback completion\n                   client.write(res.join)\n                   service.encode_ldap_response(\n                     pdu.message_id,\n                     Net::LDAP::ResultCodeSuccess, '',\n                     Net::LDAP::ResultStrings[Net::LDAP::ResultCodeSuccess],\n                     Net::LDAP::PDU::SearchResult\n                   )\n                 end\n               else\n                 service.encode_ldap_response(pdu.message_id, 50, '', 'Not authenticated', Net::LDAP::PDU::SearchResult)\n               end\n             else\n               # vprint_status(\"Received unknown LDAP request from #{client} - #{pp pdu}\")\n               service.encode_ldap_response(\n                 pdu.message_id,\n                 Net::LDAP::ResultCodeUnwillingToPerform,\n                 '',\n                 Net::LDAP::ResultStrings[Net::LDAP::ResultCodeUnwillingToPerform],\n                 Net::LDAP::PDU::SearchResult\n               )\n             end\n      resp.nil? ? client.close : on_send_response(client, resp)\n    rescue StandardError => e\n      print_error(\"Failed to handle LDAP request due to #{e}\")\n      client.close\n    end\n  end\n\nend\n"
}