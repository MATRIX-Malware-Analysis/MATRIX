{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3f973f6f-48ba-4c88-9381-a8eee6a91bf6",
    "created": "2024-08-14T16:26:52.943606Z",
    "modified": "2024-08-14T16:26:52.94361Z",
    "name": "List Rsync Modules",
    "description": "( An rsync module is essentially a directory share.  These modules can optionally be protected by a password.  This module connects to and negotiates with an rsync server, lists the available modules and optionally, determines if the module requires a password to access. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/rsync/modules_list.rb",
            "external_id": "modules_list.rb"
        },
        {
            "source_name": "reference",
            "url": "http://rsync.samba.org/ftp/rsync/rsync.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  RSYNC_HEADER = '@RSYNCD:'\n  HANDLED_EXCEPTIONS = [\n    Rex::AddressInUse, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused,\n    ::Errno::ETIMEDOUT, ::Timeout::Error, ::EOFError\n  ]\n\n  def initialize\n    super(\n      'Name'        => 'List Rsync Modules',\n      'Description' => %q(\n        An rsync module is essentially a directory share.  These modules can\n        optionally be protected by a password.  This module connects to and\n        negotiates with an rsync server, lists the available modules and,\n        optionally, determines if the module requires a password to access.\n      ),\n      'Author'      => [\n        'ikkini', # original metasploit module\n        'Jon Hart <jon_hart[at]rapid7.com>', # improved metasploit module\n        'Nixawk' # improved metasploit module\n      ],\n      'References'  =>\n        [\n          ['URL', 'http://rsync.samba.org/ftp/rsync/rsync.html']\n        ],\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        OptBool.new('TEST_AUTHENTICATION',\n                    [ true, 'Test if the rsync module requires authentication', true ]),\n        Opt::RPORT(873)\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptBool.new('SHOW_MOTD',\n                    [ true, 'Show the rsync motd, if found', false ]),\n        OptBool.new('SHOW_VERSION',\n                    [ true, 'Show the rsync version', false ]),\n        OptInt.new('READ_TIMEOUT', [ true, 'Seconds to wait while reading rsync responses', 2 ])\n      ]\n    )\n  end\n\n  def read_timeout\n    datastore['READ_TIMEOUT']\n  end\n\n  def get_rsync_auth_status(rmodule)\n    sock.puts(\"#{rmodule}\\n\")\n    res = sock.get_once(-1, read_timeout)\n    if res\n      res.strip!\n      if res =~ /^#{RSYNC_HEADER} AUTHREQD \\S+$/\n        'required'\n      elsif res =~ /^#{RSYNC_HEADER} OK$/\n        'not required'\n      else\n        vprint_error(\"unexpected response when connecting to #{rmodule}: #{res}\")\n        \"unexpected response '#{res}'\"\n      end\n    else\n      vprint_error(\"no response when connecting to #{rmodule}\")\n      'no response'\n    end\n  end\n\n  def rsync_list\n    sock.puts(\"#list\\n\")\n\n    modules_metadata = []\n    # the module listing is the module name and comment separated by a tab, each module\n    # on its own line, lines separated with a newline\n    sock.get(read_timeout).split(/\\n/).map(&:strip).map do |module_line|\n      break if module_line =~ /^#{RSYNC_HEADER} EXIT$/\n      name, comment = module_line.split(/\\t/).map(&:strip)\n      next unless name\n      modules_metadata << { name: name, comment: comment }\n    end\n\n    modules_metadata\n  end\n\n  # Attempts to negotiate the rsync protocol with the endpoint.\n  def rsync_negotiate\n    # rsync is promiscuous and will send the negotitation and motd\n    # upon connecting.  abort if we get nothing\n    return unless (greeting = sock.get_once(-1, read_timeout))\n\n    # parse the greeting control and data lines.  With some systems, the data\n    # lines at this point will be the motd.\n    greeting_control_lines, greeting_data_lines = rsync_parse_lines(greeting)\n\n    # locate the rsync negotiation and complete it by just echo'ing\n    # back the same rsync version that it sent us\n    version = nil\n    greeting_control_lines.map do |greeting_control_line|\n      if /^#{RSYNC_HEADER} (?<version>\\d+(\\.\\d+)?)$/ =~ greeting_control_line\n        version = Regexp.last_match('version')\n        sock.puts(\"#{RSYNC_HEADER} #{version}\\n\")\n      end\n    end\n\n    unless version\n      vprint_error(\"no rsync negotiation found\")\n      return\n    end\n\n    _, post_neg_data_lines = rsync_parse_lines(sock.get_once(-1, read_timeout))\n    motd_lines = greeting_data_lines + post_neg_data_lines\n    [ version, motd_lines.empty? ? nil : motd_lines.join(\"\\n\") ]\n  end\n\n  # parses the control and data lines from the provided response data\n  def rsync_parse_lines(response_data)\n    control_lines = []\n    data_lines = []\n\n    if response_data\n      response_data.strip!\n      response_data.split(/\\n/).map do |line|\n        if line =~ /^#{RSYNC_HEADER}/\n          control_lines << line\n        else\n          data_lines << line\n        end\n      end\n    end\n\n    [ control_lines, data_lines ]\n  end\n\n  def run_host(ip)\n    begin\n      connect\n      version, motd = rsync_negotiate\n      unless version\n        vprint_error(\"does not appear to be rsync\")\n        disconnect\n        return\n      end\n    rescue *HANDLED_EXCEPTIONS => e\n      vprint_error(\"error while connecting and negotiating: #{e}\")\n      disconnect\n      return\n    end\n\n    info = \"rsync protocol version #{version}\"\n    info += \", MOTD '#{motd}'\" if motd\n    report_service(\n      host: ip,\n      port: rport,\n      proto: 'tcp',\n      name: 'rsync',\n      info: info\n    )\n    print_status(\"rsync version: #{version}\") if datastore['SHOW_VERSION']\n    print_status(\"rsync MOTD: #{motd}\") if motd && datastore['SHOW_MOTD']\n\n    modules_metadata = {}\n    begin\n      modules_metadata = rsync_list\n    rescue *HANDLED_EXCEPTIONS => e\n      vprint_error(\"Error while listing modules: #{e}\")\n      return\n    ensure\n      disconnect\n    end\n\n    if modules_metadata.empty?\n      print_status(\"no rsync modules found\")\n    else\n      modules = modules_metadata.map { |m| m[:name] }\n      print_good(\"#{modules.size} rsync modules found: #{modules.join(', ')}\")\n\n      table_columns = %w(Name Comment)\n      if datastore['TEST_AUTHENTICATION']\n        table_columns << 'Authentication'\n        modules_metadata.each do |module_metadata|\n          begin\n            connect\n            rsync_negotiate\n            module_metadata[:authentication] = get_rsync_auth_status(module_metadata[:name])\n          rescue *HANDLED_EXCEPTIONS => e\n            vprint_error(\"error while testing authentication on #{module_metadata[:name]}: #{e}\")\n            break\n          ensure\n            disconnect\n          end\n        end\n      end\n\n      # build a table to store the module listing in\n      listing_table = Msf::Ui::Console::Table.new(\n        Msf::Ui::Console::Table::Style::Default,\n        'Header' => \"rsync modules for #{peer}\",\n        'Columns' => table_columns,\n        'Rows' => modules_metadata.map(&:values)\n      )\n      vprint_line(listing_table.to_s)\n\n      report_note(\n        host: ip,\n        proto: 'tcp',\n        port: rport,\n        type: 'rsync_modules',\n        data: { modules: modules_metadata }\n      )\n    end\n  end\n\n  def setup\n    fail_with(Failure::BadConfig, 'READ_TIMEOUT must be > 0') if read_timeout <= 0\n  end\nend\n"
}