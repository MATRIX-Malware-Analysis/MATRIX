{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c13532f7-bbf7-4ab4-8523-b51579b1c597",
    "created": "2024-08-14T16:31:15.189926Z",
    "modified": "2024-08-14T16:31:15.189931Z",
    "name": "SMB Version Detection",
    "description": " Fingerprint and display version information about SMB servers. Protocol information and host operating system (if available) will be reported. Host operating system detection requires the remote server to support version 1 of the SMB protocol. Compression and encryption capability negotiation is only present in version 3.1.1. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/smb/smb_version.rb",
            "external_id": "smb_version.rb"
        },
        {
            "source_name": "SiteReference.new(URL",
            "external_id": "https://support.microsoft.com/en-us/help/161372/how-to-enable-smb-signing-in-windows-nt)"
        },
        {
            "source_name": "SiteReference.new(URL",
            "external_id": "https://support.microsoft.com/en-us/help/887429/overview-of-server-message-block-signing)"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'recog'\n\nclass MetasploitModule < Msf::Auxiliary\n\n  # Exploit mixins should be called first\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Exploit::Remote::Kerberos::Ticket::Storage\n  include Msf::Exploit::Remote::Kerberos::ServiceAuthenticator::Options\n\n  # Scanner mixin should be near last\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  SMB2_DIALECT_STRINGS = {\n    '0x0202' => 'SMB 2.0.2',\n    '0x0210' => 'SMB 2.1',\n    '0x0300' => 'SMB 3.0',\n    '0x0302' => 'SMB 3.0.2',\n    '0x0311' => 'SMB 3.1.1',\n    '0x02ff' => 'SMB 2.???'\n  }.freeze\n\n  def initialize\n    super(\n      'Name' => 'SMB Version Detection',\n      'Description' => %q{\n        Fingerprint and display version information about SMB servers. Protocol\n        information and host operating system (if available) will be reported.\n        Host operating system detection requires the remote server to support\n        version 1 of the SMB protocol. Compression and encryption capability\n        negotiation is only present in version 3.1.1.\n      },\n      'Author' => ['hdm', 'Spencer McIntyre', 'Christophe De La Fuente'],\n      'License' => MSF_LICENSE\n    )\n\n    register_advanced_options(\n      [\n        *kerberos_storage_options(protocol: 'SMB'),\n        *kerberos_auth_options(protocol: 'SMB', auth_methods: Msf::Exploit::Remote::AuthOption::SMB_OPTIONS),\n      ]\n    )\n\n    deregister_options('RPORT', 'SMBDIRECT', 'SMB::ProtocolVersion')\n  end\n\n  def rport\n    @smb_port\n  end\n\n  def smb_direct\n    (@smb_port == 445)\n  end\n\n  def seconds_to_timespan(seconds)\n    timespan = []\n    [\n      ['w', 60 * 60 * 24 * 7], # weeks\n      ['d', 60 * 60 * 24], # days\n      ['h', 60 * 60], # hours\n      ['m', 60], # minutes\n      ['s', 1] # seconds\n    ].each do |spec, span|\n      if seconds > span || !timespan.empty?\n        timespan << \"#{(seconds / span).floor}#{spec}\"\n        seconds %= span\n      end\n    end\n\n    timespan.join(' ')\n  end\n\n  def smb_proto_info\n    info = {\n      capabilities: {},\n      versions: []\n    }\n    versions = [1, 2, 3]\n    while !versions.empty?\n      begin\n        simple = connect(false, versions: versions)\n        protocol = simple.client.negotiate\n      rescue Rex::Proto::SMB::Exceptions::Error, RubySMB::Error::RubySMBError\n        break\n      rescue Errno::ECONNRESET\n        break\n      rescue ::Exception => e # rubocop:disable Lint/RescueException\n        vprint_error(\"#{rhost}: #{e.class} #{e}\")\n        break\n      end\n\n      break if protocol.nil?\n      version = { 'SMB2' => 2, 'SMB3' => 3 }.fetch(protocol, 1)\n      versions.select! { |v| v < version }\n\n      dialect = simple.client.dialect\n      if simple.client.is_a? RubySMB::Client\n        info[:signing_required] = simple.client.signing_required\n        if dialect == '0x0311'\n          info[:capabilities][:compression] = simple.client.server_compression_algorithms.map do |algorithm|\n            RubySMB::SMB2::CompressionCapabilities::COMPRESSION_ALGORITHM_MAP[algorithm]\n          end\n          info[:capabilities][:encryption] = simple.client.server_encryption_algorithms.map do |algorithm|\n            RubySMB::SMB2::EncryptionCapabilities::ENCRYPTION_ALGORITHM_MAP[algorithm]\n          end\n        end\n        # assume that if the server supports multiple versions, the preferred\n        # dialect will correspond to the latest version\n        dialect = SMB2_DIALECT_STRINGS[dialect]\n\n        if simple.client.server_start_time && simple.client.server_system_time\n          uptime = simple.client.server_system_time - simple.client.server_start_time\n          info[:uptime] = seconds_to_timespan(uptime)\n        end\n        info[:server_guid] = simple.client.server_guid\n\n        unless info.key? :auth_domain\n          begin\n            simple.client.authenticate\n          rescue RubySMB::Error::RubySMBError\n            info[:auth_domain] = nil\n          else\n            info[:auth_domain] = simple.client.default_domain\n          end\n        end\n      else\n        info[:signing_required] = simple.client.peer_require_signing\n      end\n\n      info[:preferred_dialect] = dialect unless info.key? :preferred_dialect\n      info[:versions] << version\n    end\n\n    info[:versions].reverse!\n    info\n  end\n\n  def smb_os_description(res, nd_smb_fingerprint)\n    #\n    # Create the note hash for fingerprint.match\n    #\n    nd_fingerprint_match = {}\n\n    #\n    # Create a descriptive string for service.info\n    #\n    desc = res['os'].dup\n\n    if !res['edition'].to_s.empty?\n      desc << \" #{res['edition']}\"\n      nd_smb_fingerprint[:os_edition] = res['edition']\n      nd_fingerprint_match['os.edition'] = res['edition']\n    end\n\n    if !res['sp'].to_s.empty?\n      desc << \" #{res['sp'].downcase.gsub('service pack ', 'SP')}\"\n      nd_smb_fingerprint[:os_sp] = res['sp']\n      nd_fingerprint_match['os.version'] = res['sp']\n    end\n\n    if !res['build'].to_s.empty?\n      desc << \" (build:#{res['build']})\"\n      nd_smb_fingerprint[:os_build] = res['build']\n      nd_fingerprint_match['os.build'] = res['build']\n    end\n\n    if !res['lang'].to_s.empty? && res['lang'] != 'Unknown'\n      desc << \" (language:#{res['lang']})\"\n      nd_smb_fingerprint[:os_lang] = res['lang']\n      nd_fingerprint_match['os.language'] = nd_smb_fingerprint[:os_lang]\n    end\n\n    if simple.client.default_name\n      desc << \" (name:#{simple.client.default_name})\"\n      nd_smb_fingerprint[:SMBName] = simple.client.default_name\n      nd_fingerprint_match['host.name'] = nd_smb_fingerprint[:SMBName]\n    end\n\n    { text: desc, fingerprint_match: nd_fingerprint_match, smb_fingerprint: nd_smb_fingerprint }\n  end\n\n  #\n  # Fingerprint a single host\n  #\n  def run_host(ip)\n    smb_ports = [445, 139]\n    lines = [] # defer status output to the very end to group lines together by host\n    smb_ports.each do |pnum|\n      @smb_port = pnum\n      self.simple = nil\n\n      begin\n        res = smb_fingerprint\n\n        info = smb_proto_info\n        desc = \"SMB Detected (versions:#{info[:versions].join(', ')}) (preferred dialect:#{info[:preferred_dialect]})\"\n        info[:capabilities].each do |name, values|\n          desc << \" (#{name} capabilities:#{values.join(', ')})\"\n        end\n\n        if info[:signing_required]\n          desc << ' (signatures:required)'\n        else\n          desc << ' (signatures:optional)'\n          report_vuln({\n            host: ip,\n            port: rport,\n            proto: 'tcp',\n            name: 'SMB Signing Is Not Required',\n            refs: [\n              SiteReference.new('URL', 'https://support.microsoft.com/en-us/help/161372/how-to-enable-smb-signing-in-windows-nt'),\n              SiteReference.new('URL', 'https://support.microsoft.com/en-us/help/887429/overview-of-server-message-block-signing'),\n            ]\n          })\n        end\n        desc << \" (uptime:#{info[:uptime]})\" if info[:uptime]\n        desc << \" (guid:#{Rex::Text.to_guid(info[:server_guid])})\" if info[:server_guid]\n        desc << \" (authentication domain:#{info[:auth_domain]})\" if info[:auth_domain]\n        lines << { type: :status, message: desc }\n\n        #\n        # Create the note hash for smb.fingerprint\n        #\n        nd_smb_fingerprint = {\n          native_os: res['native_os'],\n          native_lm: res['native_lm']\n        }\n\n        if res['os'] && res['os'] != 'Unknown'\n          description = smb_os_description(res, nd_smb_fingerprint)\n          desc << description[:text]\n          nd_fingerprint_match = description[:fingerprint_match]\n          nd_smb_fingerprint = description[:smb_fingerprint]\n\n          if simple.client.default_domain\n            if simple.client.default_domain.encoding.name == 'UTF-8'\n              desc << \" (domain:#{simple.client.default_domain})\"\n            else\n              # Workgroup names are in ANSI, but may contain invalid characters\n              # Go through each char and convert/check\n              temp_workgroup = simple.client.default_domain.dup\n              desc << ' (workgroup:'\n              temp_workgroup.each_char do |i|\n                begin\n                  desc << i.encode('UTF-8')\n                rescue ::Encoding::UndefinedConversionError # rubocop:disable Metrics/BlockNesting\n                  desc << '?'\n                end\n              end\n              desc << ')'\n            end\n            nd_smb_fingerprint[:SMBDomain] = simple.client.default_domain\n            nd_fingerprint_match['host.domain'] = nd_smb_fingerprint[:SMBDomain]\n          end\n\n          lines << { type: :good, message: \"  Host is running #{desc}\" }\n\n          # Report the service with a friendly banner\n          report_service(\n            host: ip,\n            port: rport,\n            proto: 'tcp',\n            name: 'smb',\n            info: desc\n          )\n\n          # Report a fingerprint.match hash for name, domain, and language\n          # Ignore OS fields, as those are handled via smb.fingerprint\n          report_note(\n            host: ip,\n            port: rport,\n            proto: 'tcp',\n            ntype: 'fingerprint.match',\n            data: nd_fingerprint_match\n          )\n        elsif res['native_os'] || res['native_lm']\n          desc = \"#{res['native_os']} (#{res['native_lm']})\"\n          report_service(host: ip, port: rport, name: 'smb', info: desc)\n          lines << { type: :status, message: \"  Host could not be identified: #{desc}\" }\n        else\n          lines << { type: :status, message: '  Host could not be identified', verbose: true }\n        end\n\n        report_service(\n          host: ip,\n          port: rport,\n          proto: 'tcp',\n          name: 'smb',\n          info: desc\n        )\n\n\n        # Report a smb.fingerprint hash of attributes for OS fingerprinting\n        report_note(\n          host: ip,\n          port: rport,\n          proto: 'tcp',\n          ntype: 'smb.fingerprint',\n          data: nd_smb_fingerprint\n        )\n\n        disconnect\n\n        break\n      rescue ::Rex::Proto::SMB::Exceptions::NoReply\n        next\n      rescue ::Rex::Proto::SMB::Exceptions::ErrorCode\n        next\n      rescue ::Rex::Proto::SMB::Exceptions::LoginError => e\n        # Vista has 139 open but doesnt like *SMBSERVER\n        next if e.to_s =~ /server refused our NetBIOS/\n\n        break\n      rescue ::Timeout::Error\n        next\n      rescue ::Rex::ConnectionError\n        next\n      rescue ::Exception => e # rubocop:disable Lint/RescueException\n        print_error(\"#{rhost}: #{e.class} #{e}\")\n      ensure\n        disconnect\n\n        lines.each do |line|\n          send \"#{ line[:verbose] ? 'v' : '' }print_#{line[:type]}\", line[:message]\n        end\n        lines = []\n      end\n    end\n  end\nend\n"
}