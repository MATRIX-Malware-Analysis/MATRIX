{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2ed2a42f-5647-4eec-9236-9711dfc2d936",
    "created": "2024-08-14T16:26:52.941579Z",
    "modified": "2024-08-14T16:26:52.941583Z",
    "name": "Modbus Version Scanner",
    "description": " This module detects the Modbus service, tested on a SAIA PCD1.M2 system. Modbus is a clear text protocol used in common SCADA systems, developed originally as a serial-line (RS232) async protocol, and later transformed to IP which is called ModbusTCP.  'References'  => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/scada/modbusdetect.rb",
            "external_id": "modbusdetect.rb"
        },
        {
            "source_name": "reference",
            "url": "https://en.wikipedia.org/wiki/Modbus:TCP"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'Modbus Version Scanner',\n      'Description' => %q{\n          This module detects the Modbus service, tested on a SAIA PCD1.M2 system.\n        Modbus is a clear text protocol used in common SCADA systems, developed\n        originally as a serial-line (RS232) async protocol, and later transformed to IP,\n        which is called ModbusTCP.\n      },\n      'References'  =>\n        [\n          [ 'URL', 'https://www.saia-pcd.com/en/products/plc/pcd-overview/Pages/pcd1-m2.aspx' ],\n          [ 'URL', 'https://en.wikipedia.org/wiki/Modbus:TCP' ]\n        ],\n      'Author'      => [ 'EsMnemon <esm[at]mnemonic.no>' ],\n      'DisclosureDate' => 'Nov 1 2011',\n      'License'     => MSF_LICENSE\n      )\n\n    register_options(\n      [\n        Opt::RPORT(502),\n        OptInt.new('UNIT_ID', [true, \"ModBus Unit Identifier, 1..255, most often 1 \", 1]),\n        OptInt.new('TIMEOUT', [true, 'Timeout for the network probe', 10])\n      ])\n  end\n\n  def run_host(ip)\n    # read input register=func:04, register 1\n    sploit=\"\\x21\\x00\\x00\\x00\\x00\\x06\\x01\\x04\\x00\\x01\\x00\\x00\"\n    sploit[6] = [datastore['UNIT_ID']].pack(\"C\")\n    connect()\n    sock.put(sploit)\n    data = sock.get_once\n\n    # Theory: When sending a modbus request of some sort, the endpoint will return\n    # with at least the same transaction-id, and protocol-id\n    if data\n      if data[0,4] == \"\\x21\\x00\\x00\\x00\"\n        print_good(\"#{ip}:#{rport} - MODBUS - received correct MODBUS/TCP header (unit-ID: #{datastore['UNIT_ID']})\")\n      else\n        print_error(\"#{ip}:#{rport} - MODBUS - received incorrect data #{data[0,4].inspect} (not modbus/tcp?)\")\n      end\n    else\n      vprint_status(\"#{ip}:#{rport} - MODBUS - did not receive data.\")\n    end\n\n    disconnect()\n  end\nend\n",
    "x_mitre_contributors": [
        "[ EsMnemon <esm[at]mnemonic.no> ]",
        ""
    ],
    "x_mitre_disclosure_date": "Nov 1 2011"
}