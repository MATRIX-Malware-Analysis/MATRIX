{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0b1c2507-10bb-4aa0-b8f9-362ddb691f8b",
    "created": "2024-08-14T16:31:22.613283Z",
    "modified": "2024-08-14T16:31:22.613286Z",
    "name": "Postgres Schema Dump",
    "description": "( This module extracts the schema information from a Postgres server. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/postgres/postgres_schemadump.rb",
            "external_id": "postgres_schemadump.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Postgres\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name' => 'Postgres Schema Dump',\n      'Description' => %(\n          This module extracts the schema information from a\n          Postgres server.\n      ),\n      'Author' => ['theLightCosine'],\n      'License' => MSF_LICENSE\n    )\n    register_options([\n      OptString.new('DATABASE', [ true, 'The database to authenticate against', 'postgres']),\n      OptBool.new('DISPLAY_RESULTS', [true, 'Display the Results to the Screen', true]),\n      OptString.new('IGNORED_DATABASES', [true, 'Comma separated list of databases to ignore during the schema dump', 'template1,template0'])\n    ])\n    deregister_options('SQL', 'RETURN_ROWSET', 'VERBOSE')\n  end\n\n  def run_host(_ip)\n    pg_schema = get_schema\n    pg_schema.each do |db|\n      report_note(\n        host: datastore['RHOST'],\n        type: 'postgres.db.schema',\n        data: db,\n        port: datastore['RPORT'],\n        proto: 'tcp',\n        update: :unique_data\n      )\n    end\n    output = \"Postgres SQL Server Schema \\n Host: #{datastore['RHOST']} \\n Port: #{datastore['RPORT']} \\n ====================\\n\\n\"\n    output << YAML.dump(pg_schema)\n    this_service = report_service(\n      host: datastore['RHOST'],\n      port: datastore['RPORT'],\n      name: 'postgres',\n      proto: 'tcp'\n    )\n    store_loot('postgres_schema', 'text/plain', datastore['RHOST'], output, \"#{datastore['RHOST']}_postgres_schema.txt\", 'Postgres SQL Schema', this_service)\n    print_good output if datastore['DISPLAY_RESULTS']\n  end\n\n  def get_schema\n    ignored_databases = datastore['IGNORED_DATABASES'].split(',').map(&:strip)\n    pg_schema = []\n    database_names = smart_query('SELECT datname FROM pg_database').to_a.flatten\n    if database_names.empty?\n      print_status(\"#{rhost}:#{rport} - No databases found\")\n      return pg_schema\n    end\n    status_message = \"#{rhost}:#{rport} - Found databases: #{database_names.join(', ')}.\"\n    excluded_databases = (database_names & ignored_databases)\n    status_message += \" Ignoring #{excluded_databases.join(', ')}.\" if excluded_databases.any?\n    print_status(status_message)\n    extractable_database_names = database_names - ignored_databases\n    extractable_database_names.each do |database_name|\n      next if ignored_databases.include? database_name\n      tmp_db = {}\n      tmp_db['DBName'] = database_name\n      tmp_db['Tables'] = []\n      postgres_login({ database: database_name })\n      tmp_tblnames = smart_query(\"SELECT c.relname, n.nspname FROM pg_catalog.pg_class c LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace WHERE n.nspname NOT IN ('pg_catalog','pg_toast') AND pg_catalog.pg_table_is_visible(c.oid);\")\n      if tmp_tblnames && !tmp_tblnames.empty?\n        tmp_tblnames.each do |tbl_row|\n          tmp_tbl = {}\n          tmp_tbl['TableName'] = tbl_row[0]\n          tmp_tbl['Columns'] = []\n          tmp_column_names = smart_query(\"SELECT  A.attname, T.typname, A.attlen FROM pg_class C, pg_namespace N, pg_attribute A, pg_type T WHERE  (N.oid=C.relnamespace) AND (A.attrelid=C.oid) AND (A.atttypid=T.oid) AND (A.attnum>0) AND (NOT A.attisdropped) AND (N.nspname ILIKE 'public') AND (c.relname='#{tbl_row[0]}');\")\n          if tmp_column_names && !tmp_column_names.empty?\n            tmp_column_names.each do |column_row|\n              tmp_column = {}\n              tmp_column['ColumnName'] = column_row[0]\n              tmp_column['ColumnType'] = column_row[1]\n              tmp_column['ColumnLength'] = column_row[2]\n              tmp_tbl['Columns'] << tmp_column\n            end\n          end\n          tmp_db['Tables'] << tmp_tbl\n        end\n      end\n      pg_schema << tmp_db\n    end\n\n    pg_schema\n  end\n\n  def smart_query(query_string)\n    res = postgres_query(query_string, false)\n    # Error handling routine here, borrowed heavily from todb\n    case res.keys[0]\n    when :conn_error\n      print_error('A Connection Error Occurred')\n      return\n    when :sql_error\n      case res[:sql_error]\n      when /^C42501/\n        print_error \"#{datastore['RHOST']}:#{datastore['RPORT']} Postgres - Insufficent permissions.\"\n      else\n        print_error \"#{datastore['RHOST']}:#{datastore['RPORT']} Postgres - #{res[:sql_error]}\"\n      end\n      return nil\n    when :complete\n      return res[:complete].rows\n    end\n  end\n\nend\n"
}