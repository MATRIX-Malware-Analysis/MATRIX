{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--309bf64c-76e4-4e85-a01c-7902c1273982",
    "created": "2024-08-14T17:04:53.004615Z",
    "modified": "2024-08-14T17:04:53.004619Z",
    "name": "Generic Payload Handler",
    "description": "( This module is a stub that provides all of the features of the Metasploit payload system to exploits that have been launched outside of the framework. ) 'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/handler.rb",
            "external_id": "handler.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  #\n  # This module does basically nothing\n  # NOTE: Because of this it's missing a disclosure date that makes msftidy angry.\n  #\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name'           => 'Generic Payload Handler',\n        'Description'    => %q(\n          This module is a stub that provides all of the\n          features of the Metasploit payload system to exploits\n          that have been launched outside of the framework.\n        ),\n        'License'        => MSF_LICENSE,\n        'Author'         =>  [ 'hdm', 'bcook-r7' ],\n        'References'     =>  [ ],\n        'Payload'        =>\n          {\n            'Space'       => 10000000,\n            'BadChars'    => '',\n            'DisableNops' => true\n          },\n        'Platform'       => %w[android apple_ios bsd java js linux osx nodejs php python ruby solaris unix win mainframe multi],\n        'Arch'           => ARCH_ALL,\n        'Targets'        => [ [ 'Wildcard Target', {} ] ],\n        'DefaultTarget'  => 0,\n        'DefaultOptions' => { 'PAYLOAD' => 'generic/shell_reverse_tcp' }\n      )\n    )\n\n    register_advanced_options(\n      [\n        OptBool.new(\n          \"ExitOnSession\",\n          [ true, \"Return from the exploit after a session has been created\", true ]\n        ),\n        OptInt.new(\n          \"ListenerTimeout\",\n          [ false, \"The maximum number of seconds to wait for new sessions\", 0 ]\n        )\n      ]\n    )\n  end\n\n  def exploit\n    if datastore['DisablePayloadHandler']\n      print_error \"DisablePayloadHandler is enabled, so there is nothing to do. Exiting!\"\n      return\n    end\n\n    stime = Time.now.to_f\n    timeout = datastore['ListenerTimeout'].to_i\n    loop do\n      break if session_created? && datastore['ExitOnSession']\n      break if timeout > 0 && (stime + timeout < Time.now.to_f)\n      Rex::ThreadSafe.sleep(1)\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "%w[android apple_ios bsd java js linux osx nodejs php python ruby solaris unix win mainframe multi]"
    ]
}