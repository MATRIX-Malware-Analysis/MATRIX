{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5ee7e062-d6f2-42af-a52c-00f138b7bc3d",
    "created": "2024-08-14T16:27:08.191686Z",
    "modified": "2024-08-14T16:27:08.19169Z",
    "name": "Poison Ivy Command and Control Scanner",
    "description": " Enumerate Poison Ivy Command and Control (C&C) on ports 3460, 80, 8080 and 443. Adaptation of iTrust Python script. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/misc/poisonivy_control_scanner.rb",
            "external_id": "poisonivy_control_scanner.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'Poison Ivy Command and Control Scanner',\n      'Description' => %q{\n        Enumerate Poison Ivy Command and Control (C&C) on ports 3460, 80, 8080 and 443. Adaptation of iTrust Python script.\n      },\n      'Author'      => ['SeawolfRN'],\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n    [\n      OptString.new('PORTS', [true, \"Ports to Check\",\"80,8080,443,3460\"]),\n      OptInt.new('TIMEOUT', [true, \"The socket connect timeout in milliseconds\", 1000]),\n      OptInt.new('CONCURRENCY', [true, \"The number of concurrent ports to check per host\", 10])\n    ])\n\n    deregister_options('RPORT')\n\n  end\n\n\n  def run_host(ip)\n\n    timeout = datastore['TIMEOUT'].to_i\n\n    ports = Rex::Socket.portspec_crack(datastore['PORTS'])\n\n    if ports.empty?\n      raise Msf::OptionValidateError.new(['PORTS'])\n    end\n\n    while(ports.length > 0)\n      t = []\n      r = []\n      begin\n      1.upto(datastore['CONCURRENCY']) do\n        this_port = ports.shift\n        break if not this_port\n        t << framework.threads.spawn(\"Module(#{self.refname})-#{ip}:#{this_port}\", false, this_port) do |port|\n          begin\n            s = connect(false,\n              {\n                'RPORT' => port,\n                'RHOST' => ip,\n                'ConnectTimeout' => (timeout / 1000.0)\n              }\n            )\n            r << [ip,port,\"open\",'Unknown']\n            s.puts(\"\\x00\"*0x100,0) #Send 0x100 zeros, wait for answer\n            data = s.get_once(0x100) || ''\n            if data.length == 0x100\n              data = s.get_once(0x4) || ''\n              if data == \"\\xD0\\x15\\x00\\x00\" #Signature for PIVY C&C\n                print_status(\"#{ip}:#{port} - C&C Server Found\")\n                r << [ip,port,\"open\",'Poison Ivy C&C']\n              end\n            end\n          rescue ::Rex::ConnectionRefused\n            vprint_status(\"#{ip}:#{port} - TCP closed\")\n            r << [ip,port,\"closed\",'']\n          rescue ::Rex::ConnectionError, ::IOError, ::Timeout::Error\n          rescue ::Rex::Post::Meterpreter::RequestError\n            raise $!\n          ensure\n            disconnect(s) rescue nil\n          end\n        end\n      end\n      t.each {|x| x.join }\n\n      rescue ::Timeout::Error\n      ensure\n        t.each {|x| x.kill rescue nil }\n      end\n\n      r.each do |res|\n        report_service(:host => res[0], :port => res[1], :state => res[2], :name=> res[3])\n      end\n    end\n  end\nend\n"
}