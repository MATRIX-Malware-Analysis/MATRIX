{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--146b2161-3878-4948-8872-2bc8d71a07a7",
    "created": "2024-08-14T16:33:19.216261Z",
    "modified": "2024-08-14T16:33:19.216264Z",
    "name": "\"Non-Alpha Encoder\"",
    "description": " Encodes payloads as non-alpha based bytes. This allows payloads to bypass both toupper() and tolower() calls but will fail isalpha(). Table based design from Russel Sanford. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/x86/nonalpha.rb",
            "external_id": "nonalpha.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/encoder/nonalpha'\n\nclass MetasploitModule < Msf::Encoder::NonAlpha\n  Rank = LowRanking\n\n  def initialize\n    super(\n      'Name'             => \"Non-Alpha Encoder\",\n      'Description'      => %q{\n          Encodes payloads as non-alpha based bytes. This allows\n        payloads to bypass both toupper() and tolower() calls,\n        but will fail isalpha(). Table based design from\n        Russel Sanford.\n      },\n      'Author'           => [ 'pusscat'],\n      'Arch'             => ARCH_X86,\n      'License'          => BSD_LICENSE,\n      'EncoderType'      => Msf::Encoder::Type::NonAlpha,\n      'Decoder'          =>\n        {\n          'BlockSize' => 1,\n        })\n  end\n\n  #\n  # Returns the decoder stub that is adjusted for the size of the buffer\n  # being encoded.\n  #\n  def decoder_stub(state)\n    state.key                   = \"\"\n    state.decoder_key_size      = 0\n    Rex::Encoder::NonAlpha::gen_decoder()\n  end\n\n  #\n  # Encodes a one byte block with the current index of the length of the\n  # payload.\n  #\n  def encode_block(state, block)\n    begin\n      newchar, state.key, state.decoder_key_size = Rex::Encoder::NonAlpha::encode_byte(block.unpack('C')[0], state.key, state.decoder_key_size)\n    rescue RuntimeError => e\n      raise BadcharError if e.message == \"BadChar\"\n    end\n    return newchar\n  end\n\n  #\n  # Fix stuff, and add the table :)\n  #\n  def encode_end(state)\n    state.encoded.gsub!(/A/, state.decoder_key_size.chr)\n    state.encoded.gsub!(/B/, (state.decoder_key_size+5).chr)\n    state.encoded[0x24, 0] = state.key\n  end\nend\n"
}