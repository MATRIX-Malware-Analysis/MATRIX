{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--35834953-7dae-448d-98a6-a8b789b2cc94",
    "created": "2024-08-14T16:33:05.025476Z",
    "modified": "2024-08-14T16:33:05.02548Z",
    "name": "Windows Gather Directory Permissions Enumeration",
    "description": " This module enumerates directories and lists the permissions set on found directories. Please note: if the PATH option isn't specified then the module will start enumerate whatever is in the target machine's %PATH% variable.  'License' => MSF_LICENSE 'Platform' => ['win'] 'SessionTypes' => ['meterpreter']",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/enum_dirperms.rb",
            "external_id": "enum_dirperms.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Accounts\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Directory Permissions Enumeration',\n        'Description' => %q{\n          This module enumerates directories and lists the permissions set\n          on found directories. Please note: if the PATH option isn't specified,\n          then the module will start enumerate whatever is in the target machine's\n          %PATH% variable.\n        },\n        'License' => MSF_LICENSE,\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Author' => [\n          'Kx499',\n          'Ben Campbell',\n          'sinn3r'\n        ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_stat\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('PATH', [ false, 'Directory to begin search from', '']),\n        OptEnum.new('FILTER', [ false, 'Filter to limit results by', 'NA', [ 'NA', 'R', 'W', 'RW' ]]),\n        OptInt.new('DEPTH', [ true, 'Depth to drill down into subdirs, O = no limit', 0]),\n      ]\n    )\n  end\n\n  def enum_subdirs(perm_filter, dpath, maxdepth, token)\n    filter = datastore['FILTER']\n    filter = nil if datastore['FILTER'] == 'NA'\n\n    begin\n      dirs = session.fs.dir.foreach(dpath)\n    rescue Rex::Post::Meterpreter::RequestError\n      # Sometimes we cannot see the dir\n      dirs = []\n    end\n\n    if (maxdepth >= 1) || (maxdepth < 0)\n      dirs.each do |d|\n        next if d =~ /^(\\.|\\.\\.)$/\n\n        realpath = dpath + '\\\\' + d\n        next unless session.fs.file.stat(realpath).directory?\n\n        perm = check_dir_perms(realpath, token)\n        if perm_filter && perm && perm.include?(perm_filter)\n          print_status(perm + \"\\t\" + realpath)\n        end\n        enum_subdirs(perm_filter, realpath, maxdepth - 1, token)\n      end\n    end\n  end\n\n  def get_paths\n    p = datastore['PATH']\n    return [p] if !p.nil? && !p.empty?\n\n    begin\n      p = cmd_exec('cmd.exe', '/c echo %PATH%')\n    rescue Rex::Post::Meterpreter::RequestError => e\n      vprint_error(e.message)\n      return []\n    end\n    print_status(\"Option 'PATH' isn't specified. Using system %PATH%\")\n    if p.include?(';')\n      return p.split(';')\n    else\n      return [p]\n    end\n  end\n\n  def get_token\n    print_status('Getting impersonation token...')\n    begin\n      t = get_imperstoken\n    rescue ::Exception => e\n      # Failure due to timeout, access denied, etc.\n      t = nil\n      vprint_error(\"Error #{e.message} while using get_imperstoken()\")\n      vprint_error(e.backtrace)\n    end\n    return t\n  end\n\n  def enum_perms(perm_filter, token, depth, paths)\n    paths.each do |path|\n      next if path.empty?\n\n      path = path.strip\n\n      print_status(\"Checking directory permissions from: #{path}\")\n\n      perm = check_dir_perms(path, token)\n      next if perm.nil?\n\n      # Show the permission of the parent directory\n      if perm_filter && perm.include?(perm_filter)\n        print_status(perm + \"\\t\" + path)\n      end\n\n      # call recursive function to loop through and check all sub directories\n      enum_subdirs(perm_filter, path, depth, token)\n    end\n  end\n\n  def run\n    perm_filter = datastore['FILTER']\n    perm_filter = nil if datastore['FILTER'] == 'NA'\n\n    paths = get_paths\n    if paths.empty?\n      print_error('Unable to get the path')\n      return\n    end\n\n    depth = -1\n    if datastore['DEPTH'] > 0\n      depth = datastore['DEPTH']\n    end\n\n    t = get_token\n\n    if t\n      print_status(\"Got token: #{t}...\")\n      enum_perms(perm_filter, t, depth, paths)\n    else\n      print_error('Getting impersonation token failed')\n    end\n  end\nend\n"
}