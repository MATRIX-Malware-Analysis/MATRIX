{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8a12fee3-c0fa-4cab-afd5-2afdfa6c4eca",
    "created": "2024-08-14T16:32:15.145825Z",
    "modified": "2024-08-14T16:32:15.145829Z",
    "name": "Shodan Search",
    "description": " This module uses the Shodan API to search Shodan. Accounts are free and an API key is required to use this module. Output from the module is displayed to the screen and can be saved to a file or the MSF database. NOTE: SHODAN filters (i.e. port, hostname, os, geo, city) can be used in queries, but there are limitations when used with a free API key. Please see the Shodan site for more information. Shodan website: https://www.shodan.io/ API: https://developer.shodan.io/api ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/shodan_search.rb",
            "external_id": "shodan_search.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'net/https'\nrequire 'uri'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name' => 'Shodan Search',\n      'Description' => %q{\n        This module uses the Shodan API to search Shodan. Accounts are free\n        and an API key is required to use this module. Output from the module\n        is displayed to the screen and can be saved to a file or the MSF database.\n        NOTE: SHODAN filters (i.e. port, hostname, os, geo, city) can be used in\n        queries, but there are limitations when used with a free API key. Please\n        see the Shodan site for more information.\n        Shodan website: https://www.shodan.io/\n        API: https://developer.shodan.io/api\n      },\n      'Author' =>\n        [\n          'John H Sawyer <john[at]sploitlab.com>', # InGuardians, Inc.\n          'sinn3r'  # Metasploit-fu plus other features\n        ],\n      'License' => MSF_LICENSE\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('SHODAN_APIKEY', [true, 'The SHODAN API key']),\n        OptString.new('QUERY', [true, 'Keywords you want to search for']),\n        OptString.new('OUTFILE', [false, 'A filename to store the list of IPs']),\n        OptBool.new('DATABASE', [false, 'Add search results to the database', false]),\n        OptInt.new('MAXPAGE', [true, 'Max amount of pages to collect', 1]),\n        OptRegexp.new('REGEX', [true, 'Regex search for a specific IP/City/Country/Hostname', '.*'])\n\n      ]\n    )\n\n    # overwriting the default user-agent. Shodan is checking it and delivering a html response when using the default ua (see #16189 and #16223)\n    register_advanced_options(\n      [\n        OptString.new('UserAgent', [false, 'The User-Agent header to use for all requests', 'Wget/1.21.2 (linux-gnu)' ])\n      ]\n    )\n\n    deregister_http_client_options\n  end\n\n  # create our Shodan query function that performs the actual web request\n  def shodan_query(apikey, query, page)\n    # send our query to Shodan\n    res = send_request_cgi({\n      'method' => 'GET',\n      'rhost' => 'api.shodan.io',\n      'rport' => 443,\n      'uri' => '/shodan/host/search',\n      'SSL' => true,\n      'vars_get' => {\n        'key' => apikey,\n        'query' => query,\n        'page' => page.to_s\n      }\n    })\n\n    if res && res.code == 401\n      fail_with(Failure::BadConfig, '401 Unauthorized. Your SHODAN_APIKEY is invalid')\n    end\n\n    # Check if we can resolve host, got a response,\n    # then parse the JSON, and return it\n    if res\n      results = ActiveSupport::JSON.decode(res.body)\n      return results\n    else\n      return 'server_response_error'\n    end\n  end\n\n  # save output to file\n  def save_output(data)\n    ::File.open(datastore['OUTFILE'], 'wb') do |f|\n      f.write(data)\n      print_status(\"Saved results in #{datastore['OUTFILE']}\")\n    end\n  end\n\n  # Check to see if api.shodan.io resolves properly\n  def shodan_resolvable?\n    begin\n      Rex::Socket.resolv_to_dotted(\"api.shodan.io\")\n    rescue RuntimeError, SocketError\n      return false\n    end\n\n    true\n  end\n\n  def run\n    # check our API key is somewhat sane\n    unless /^[a-z\\d]{32}$/i.match?(datastore['SHODAN_APIKEY'])\n      fail_with(Failure::BadConfig, 'Shodan API key should be 32 characters a-z,A-Z,0-9.')\n    end\n\n    # check to ensure api.shodan.io is resolvable\n    unless shodan_resolvable?\n      print_error(\"Unable to resolve api.shodan.io\")\n      return\n    end\n\n    # create our Shodan request parameters\n    query = datastore['QUERY']\n    apikey = datastore['SHODAN_APIKEY']\n    maxpage = datastore['MAXPAGE']\n\n    # results gets our results from shodan_query\n    results = []\n    results[0] = shodan_query(apikey, query, 1)\n\n    if results[0]['total'].nil? || results[0]['total'] == 0\n      msg = \"No results.\"\n      if results[0]['error'].to_s.length > 0\n        msg << \" Error: #{results[0]['error']}\"\n      end\n      print_error(msg)\n      return\n    end\n\n    # Determine page count based on total results\n    if results[0]['total'] % 100 == 0\n      tpages = results[0]['total'] / 100\n    else\n      tpages = results[0]['total'] / 100 + 1\n    end\n    maxpage = tpages if datastore['MAXPAGE'] > tpages\n\n    # start printing out our query statistics\n    print_status(\"Total: #{results[0]['total']} on #{tpages} \" +\n      \"pages. Showing: #{maxpage} page(s)\")\n\n    # If search results greater than 100, loop & get all results\n    print_status('Collecting data, please wait...')\n\n    if results[0]['total'] > 100\n      page = 1\n      while page < maxpage\n        page_result = shodan_query(apikey, query, page+1)\n        if page_result['matches'].nil?\n          next\n        end\n        results[page] = page_result\n        page += 1\n      end\n    end\n\n    # Save the results to this table\n    tbl = Rex::Text::Table.new(\n      'Header'  => 'Search Results',\n      'Indent'  => 1,\n      'Columns' => ['IP:Port', 'City', 'Country', 'Hostname']\n    )\n\n    # Organize results and put them into the table and database\n    regex = datastore['REGEX'] if datastore['REGEX']\n    results.each do |page|\n      page['matches'].each do |host|\n        city = host['location']['city'] || 'N/A'\n        ip   = host['ip_str'] || 'N/A'\n        port = host['port'] || ''\n        country = host['location']['country_name'] || 'N/A'\n        hostname = host['hostnames'][0]\n        data = host['data']\n\n        report_host(:host     => ip,\n                    :name     => hostname,\n                    :comments => 'Added from Shodan',\n                    :info     => host['info']\n                    ) if datastore['DATABASE']\n\n        report_service(:host => ip,\n                       :port => port,\n                       :info => 'Added from Shodan'\n                       ) if datastore['DATABASE']\n\n        if ip =~ regex ||\n          city =~ regex ||\n          country =~ regex ||\n          hostname =~ regex ||\n          data =~ regex\n          # Unfortunately we cannot display the banner properly,\n          # because it messes with our output format\n          tbl << [\"#{ip}:#{port}\", city, country, hostname]\n        end\n      end\n    end\n    #Show data and maybe save it if needed\n    print_line()\n    print_line(\"#{tbl}\")\n    save_output(tbl) if datastore['OUTFILE']\n  end\nend\n"
}