{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f54b4a27-a8a0-40bf-a66f-f08b54f8c403",
    "created": "2024-08-14T16:32:53.762304Z",
    "modified": "2024-08-14T16:32:53.762307Z",
    "name": "Extract zip from Modbus communication",
    "description": " This module is able to extract a zip file sent through Modbus from a pcap. Tested with Schneider TM221CE16R ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/analyze/modbus_zip.rb",
            "external_id": "modbus_zip.rb"
        }
    ],
    "x_code_snippet": "##\n## This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      'Name'           => 'Extract zip from Modbus communication',\n      'Description'    => %q{\n        This module is able to extract a zip file sent through Modbus from a pcap.\n        Tested with Schneider TM221CE16R\n      },\n      'Author' => [\n        'Jos\u00e9 Diogo Monteiro <jdlopes[at]student.dei.uc.pt>',\n        'Luis Rosa <lmrosa[at]dei.uc.pt)>'\n      ],\n      'License' => MSF_LICENSE\n    )\n\n    register_options [\n      Opt::RPORT(502),\n      OptEnum.new('MODE', [true, 'Extract zip from upload/download capture', 'UPLOAD',\n                  ['UPLOAD','DOWNLOAD']]),\n      OptString.new('PCAPFILE', [ true, 'Pcap to read', '' ]),\n      OptString.new('FILENAME', [ false, 'Zip file output name'])\n    ]\n\n  end\n\n  FIRST_BYTE_UPLOAD = 12\n  FIRST_BYTE_DOWNLOAD = 16\n\n  def extract_zip(packet, zip_packet, first_byte, data, packet_number)\n    # ZIP start signature\n    h = packet.payload.scan(/\\x50\\x4B\\x03\\x04.*/)\n    if h.size.nonzero?\n      print_status \"Zip start on packet #{packet_number + 1}\"\n      data = h[0]\n      zip_packet += 1\n      return zip_packet, data\n    end\n\n    # ZIP end signature (central directory record)\n    h = packet.payload.scan(/.*\\x50\\x4B\\x05\\x06................../)\n    if h.size.nonzero?\n      print_status \"Zip end on packet #{packet_number + 1}\"\n      data += h[0][first_byte..-1]\n      zip_packet += 1\n      return zip_packet, data\n    end\n\n    # ZIP data\n    if zip_packet == 1\n      unless packet.payload[first_byte..-1].nil?\n        data += packet.payload[first_byte..-1]\n      end\n    end\n    return zip_packet, data\n  end\n\n  def run\n    packets = PacketFu::PcapFile.read_packets datastore['PCAPFILE']\n    zip_packet = 0\n    data = ''\n    packets.each_with_index do |packet, i|\n      if datastore['MODE'] == 'UPLOAD'\n        if  packet.respond_to?(:tcp_src) and packet.tcp_src == datastore['RPORT']\n          zip_packet, data = extract_zip(packet, zip_packet, FIRST_BYTE_UPLOAD, data, i)\n        end\n      elsif datastore['MODE'] == 'DOWNLOAD'\n        if  packet.respond_to?(:tcp_dst) and packet.tcp_dst == datastore['RPORT']\n          zip_packet, data = extract_zip(packet, zip_packet, FIRST_BYTE_DOWNLOAD, data, i)\n        end\n      end\n      break if zip_packet == 2\n    end\n\n    filename = datastore['FILENAME'] || 'project.zip'\n    unless data.empty?\n      path = store_loot(filename, 'application/zip', datastore['RHOSTS'], data, filename, 'modbus.zip')\n      print_good \"Zip file saved in loot: #{path}\"\n    else\n      print_status \"Zip file not found in #{datastore['PCAPFILE']}\"\n    end\n  end\nend\n"
}