{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d4a96ee1-4d26-48e0-baa4-fcf260b11225",
    "created": "2024-08-14T16:33:19.182632Z",
    "modified": "2024-08-14T16:33:19.182635Z",
    "name": "Multi Gather DNS Service Record Lookup Scan",
    "description": " Enumerates known SRV Records for a given domain using target host DNS query tool.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/gather/dns_srv_lookup.rb",
            "external_id": "dns_srv_lookup.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Multi Gather DNS Service Record Lookup Scan',\n        'Description' => %q{\n          Enumerates known SRV Records for a given domain using target host DNS query tool.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'Carlos Perez <carlos_perez[at]darkoperator.com>'],\n        'Platform' => %w[bsd linux osx solaris win],\n        'SessionTypes' => [ 'meterpreter', 'shell' ]\n      )\n    )\n    register_options(\n      [\n\n        OptString.new('DOMAIN', [true, 'Domain to perform SRV query against.'])\n\n      ]\n    )\n  end\n\n  # Run Method for when run command is issued\n  def run\n    srvrcd = [\n      '_gc._tcp.', '_kerberos._tcp.', '_kerberos._udp.', '_ldap._tcp.',\n      '_test._tcp.', '_sips._tcp.', '_sip._udp.', '_sip._tcp.', '_aix._tcp.',\n      '_aix._tcp.', '_finger._tcp.', '_ftp._tcp.', '_http._tcp.', '_nntp._tcp.',\n      '_telnet._tcp.', '_whois._tcp.', '_h323cs._tcp.', '_h323cs._udp.',\n      '_h323be._tcp.', '_h323be._udp.', '_h323ls._tcp.',\n      '_h323ls._udp.', '_sipinternal._tcp.', '_sipinternaltls._tcp.',\n      '_sip._tls.', '_sipfederationtls._tcp.', '_jabber._tcp.',\n      '_xmpp-server._tcp.', '_xmpp-client._tcp.', '_imap.tcp.',\n      '_certificates._tcp.', '_crls._tcp.', '_pgpkeys._tcp.',\n      '_pgprevokations._tcp.', '_cmp._tcp.', '_svcp._tcp.', '_crl._tcp.',\n      '_ocsp._tcp.', '_PKIXREP._tcp.', '_smtp._tcp.', '_hkp._tcp.',\n      '_hkps._tcp.', '_jabber._udp.', '_xmpp-server._udp.', '_xmpp-client._udp.',\n      '_jabber-client._tcp.', '_jabber-client._udp.', '_kerberos.tcp.dc._msdcs.',\n      '_ldap._tcp.ForestDNSZones.', '_ldap._tcp.dc._msdcs.', '_ldap._tcp.pdc._msdcs.',\n      '_ldap._tcp.gc._msdcs.', '_kerberos._tcp.dc._msdcs.', '_kpasswd._tcp.', '_kpasswd._udp.',\n      '_imap._tcp.'\n    ]\n\n    domain = datastore['DOMAIN']\n\n    print_status(\"Performing DNS SRV Record Lookup for Domain #{domain}\")\n\n    a = []\n\n    case session.platform\n    when 'windows'\n      ns_opt = ' -query=srv '\n      cmd = 'nslookup'\n    when 'solaris'\n      ns_opt = ' -t srv '\n      cmd = '/usr/sbin/host'\n    else\n      ns_opt = ' -t srv '\n      cmd = '/usr/bin/host'\n    end\n\n    while !srvrcd.nil? && !srvrcd.empty?\n      1.upto session.max_threads do\n        a << framework.threads.spawn(\"Module(#{refname})\", false, srvrcd.shift) do |srv|\n          next if srv.nil?\n\n          r = cmd_exec(cmd, ns_opt + \"#{srv}#{domain}\")\n\n          case session.platform\n          when 'windows'\n            if r =~ /\\s*internet\\saddress\\s=\\s/\n              nslookup_srv_consume(\"#{srv}#{domain}\", r).each do |f|\n                print_good(\"\\t#{f[:srv]} #{f[:target]} #{f[:port]} #{f[:ip]}\")\n              end\n            end\n          else\n            found = host_srv_consume(r)\n            if found\n              found.each do |f|\n                print_good(\"\\t#{f[:srv]} #{f[:target]} #{f[:port]} #{f[:ip]}\")\n              end\n            end\n          end\n        end\n        a.map(&:join)\n      end\n    end\n  end\n\n  def nslookup_srv_consume(srv, ns_out)\n    srv_records = []\n    records = ns_out.split(srv)\n\n    # Get host to IP mapping\n    ip_map = {}\n    records.last.each_line do |e|\n      if e =~ /internet\\saddress/i\n        host, ip = e.split(/\\s*internet\\saddress\\s=\\s/)\n        ip_map[host.strip] = ip.strip\n      end\n    end\n\n    # Get SRV parameter for each record\n    records.each do |r|\n      next unless r =~ /svr hostname/\n\n      rcrd = {}\n      rcrd[:srv] = srv\n      rcrd[:port] = r.scan(/port\\s*=\\s(\\d*)/).join\n      rcrd[:target] = r.scan(/svr hostname\\s*=\\s(\\S*)/).join\n      if !Rex::Socket.dotted_ip?(rcrd[:target])\n        w_get_ip(rcrd[:target]).each do |i|\n          rcrd[:ip] = i\n          report_host(host: rcrd[:ip].strip, name: rcrd[:target])\n\n          # Report on the service found\n          srv_info = rcrd[:srv].scan(/^_(\\S*)\\._(\\w*)\\./)[0]\n\n          report_service(host: rcrd[:ip].strip,\n                         port: rcrd[:port].to_i,\n                         proto: srv_info[1],\n                         name: srv_info[0],\n                         host_name: rcrd[:target])\n          srv_records << rcrd\n        end\n      else\n\n        rcrd[:ip] = ip_map[rcrd[:target]]\n        # Report hosts found\n        report_host(host: rcrd[:ip].strip, name: rcrd[:target])\n\n        # Report on the service found\n        srv_info = rcrd[:srv].scan(/^_(\\S*)\\._(\\w*)\\./)[0]\n\n        report_service(host: '1.2.3.4',\n                       port: rcrd[:port].to_i,\n                       proto: srv_info[1],\n                       name: srv_info[0],\n                       host_name: rcrd[:target])\n        srv_records << rcrd\n      end\n    end\n    return srv_records\n  end\n\n  # Get I{ for a given host using host, returns array\n  def get_ip(host)\n    ip_add = []\n    cmd_exec('host', \" #{host}\").each_line do |l|\n      ip = ''\n      ip = l.scan(/has address (\\S*)$/).join\n      ip_add << ip if ip != ''\n    end\n    return ip_add\n  end\n\n  # Get IP for given host with nslookup, return array\n  def w_get_ip(host)\n    ips = []\n    data = cmd_exec(\"nslookup #{host}\")\n    if data =~ /Name/\n      # Remove unnecessary data and get the section with the addresses\n      returned_data = data.split(/Name:/)[1]\n      # check each element of the array to see if they are IP\n      returned_data.gsub(/\\r\\n\\t |\\r\\n|Aliases:|Addresses:|Address:/, ' ').split(' ').each do |e|\n        if Rex::Socket.dotted_ip?(e)\n          ips << e\n        end\n      end\n    end\n    return ips\n  end\n\n  def host_srv_consume(host_out)\n    srv_records = []\n    # Parse for SRV Records\n    host_out.each_line do |l|\n      next unless l =~ /has SRV/\n\n      record, port, target = l.scan(/(\\S*) has SRV record \\d*\\s\\d*\\s(\\d*)\\s(\\S*)/)[0]\n      if Rex::Socket.dotted_ip?(target)\n        rcrd = {}\n        rcrd[:srv] = record\n        rcrd[:port] = port\n        rcrd[:target] = target\n        rcrd[:ip] = target\n        srv_records << rcrd\n\n        # Report hosts found\n        report_host(host: rcrd[:ip], name: rcrd[:target])\n\n        # Report on the service found\n        srv_info = rcrd[:srv].scan(/^_(\\S*)\\._(\\w*)\\./)[0]\n        report_service(host: rcrd[:ip],\n                       port: rcrd[:port],\n                       proto: srv_info[1],\n                       name: srv_info[0],\n                       host_name: rcrd[:target])\n      else\n        get_ip(target).each do |i|\n          rcrd = {}\n          rcrd[:srv] = record\n          rcrd[:port] = port\n          rcrd[:target] = target\n          rcrd[:ip] = i\n          srv_records << rcrd\n\n          # Report hosts found\n          report_host(host: rcrd[:ip], name: rcrd[:target])\n\n          # Report on the service found\n          srv_info = rcrd[:srv].scan(/^_(\\S*)\\._(\\w*)\\./)[0]\n          report_service(host: rcrd[:ip],\n                         port: rcrd[:port].to_i,\n                         proto: srv_info[1],\n                         name: srv_info[0],\n                         host_name: rcrd[:target])\n        end\n      end\n    end\n    return srv_records\n  end\nend\n",
    "x_mitre_platforms": [
        "%w[bsd linux osx solaris win]"
    ]
}