{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c13e956e-8473-44a6-8309-20cd0923f33b",
    "created": "2024-08-14T16:27:52.796869Z",
    "modified": "2024-08-14T16:27:52.796873Z",
    "name": "SSDP ssdp:all M-SEARCH Amplification Scanner",
    "description": "Discover SSDP amplification possibilities",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/upnp/ssdp_amp.rb",
            "external_id": "ssdp_amp.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.cisa.gov/uscert/ncas/alerts/TA14-017A"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Capture\n  include Msf::Auxiliary::UDPScanner\n  include Msf::Auxiliary::DRDoS\n\n  def initialize\n    super(\n      'Name'        => 'SSDP ssdp:all M-SEARCH Amplification Scanner',\n      'Description' => 'Discover SSDP amplification possibilities',\n      'Author'      => ['xistence <xistence[at]0x90.nl>'], # Original scanner module\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          ['CVE', '2013-5211'], # see also scanner/ntp/ntp_monlist.rb\n          ['URL', 'https://www.cisa.gov/uscert/ncas/alerts/TA14-017A']\n        ],\n    )\n\n    register_options([\n      Opt::RPORT(1900),\n      OptBool.new('SHORT', [ false, \"Does a shorter request, for a higher amplifier, not compatible with all devices\", false])\n    ])\n  end\n\n  def setup\n    super\n    # SSDP packet containing the \"ST:ssdp:all\" search query\n    if datastore['short']\n      # Short packet doesn't contain Host, MX and last \\r\\n\n      @msearch_probe = \"M-SEARCH * HTTP/1.1\\r\\nST: ssdp:all\\r\\nMan: \\\"ssdp:discover\\\"\\r\\n\"\n    else\n      @msearch_probe = \"M-SEARCH * HTTP/1.1\\r\\nHost: 239.255.255.250:1900\\r\\nST: ssdp:all\\r\\nMan: \\\"ssdp:discover\\\"\\r\\nMX: 1\\r\\n\\r\\n\"\n    end\n  end\n\n  def scanner_prescan(batch)\n    print_status(\"Sending SSDP ssdp:all M-SEARCH probes to #{batch[0]}->#{batch[-1]} (#{batch.length} hosts)\")\n    @results = {}\n  end\n\n  def scan_host(ip)\n    if spoofed?\n      datastore['ScannerRecvWindow'] = 0\n      scanner_spoof_send(@msearch_probe, ip, datastore['RPORT'], datastore['SRCIP'], datastore['NUM_REQUESTS'])\n    else\n      scanner_send(@msearch_probe, ip, datastore['RPORT'])\n    end\n  end\n\n  def scanner_process(data, shost, sport)\n    if data =~ /HTTP\\/\\d\\.\\d 200/\n      @results[shost] ||= []\n      @results[shost] << data\n    else\n      vprint_error(\"Skipping #{data.size}-byte non-SSDP response from #{shost}:#{sport}\")\n    end\n  end\n\n  # Called after the scan block\n  def scanner_postscan(batch)\n    @results.keys.each do |k|\n      response_map = { @msearch_probe => @results[k] }\n      report_service(\n        host: k,\n        proto: 'udp',\n        port: datastore['RPORT'],\n        name: 'ssdp'\n      )\n\n      peer = \"#{k}:#{datastore['RPORT']}\"\n      vulnerable, proof = prove_amplification(response_map)\n      what = 'SSDP ssdp:all M-SEARCH amplification'\n      if vulnerable\n        print_good(\"#{peer} - Vulnerable to #{what}: #{proof}\")\n        report_vuln(\n          host: k,\n          port: datastore['RPORT'],\n          proto: 'udp',\n          name: what,\n          refs: self.references\n        )\n      else\n        vprint_status(\"#{peer} - Not vulnerable to #{what}: #{proof}\")\n      end\n    end\n  end\nend\n"
}