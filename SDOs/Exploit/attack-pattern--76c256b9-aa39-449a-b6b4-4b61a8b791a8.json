{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--76c256b9-aa39-449a-b6b4-4b61a8b791a8",
    "created": "2024-08-14T16:28:08.501904Z",
    "modified": "2024-08-14T16:28:08.501907Z",
    "name": "Rogue Gateway Detection: Sender",
    "description": " This module send a series of TCP SYN and ICMP ECHO requests to each internal target host, spoofing the source address of an external system running the rogue_recv module. This allows the system running the rogue_recv module to determine what external IP a given internal system is using as its default route. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/rogue/rogue_send.rb",
            "external_id": "rogue_send.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Capture\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'Rogue Gateway Detection: Sender',\n      'Description' => %q{\n        This module send a series of TCP SYN and ICMP ECHO requests\n      to each internal target host, spoofing the source address of an external\n      system running the rogue_recv module. This allows the system running\n      the rogue_recv module to determine what external IP a given internal\n      system is using as its default route.\n      },\n      'Author'      => 'hdm',\n      'License'     => MSF_LICENSE\n    )\n\n    register_options([\n      OptAddress.new(\"EHOST\", [true, \"The IP address of the machine running rogue_recv\"]),\n      OptPort.new(\"RPORT\", [true, \"The destination port for the TCP SYN packet\", 80]),\n      OptPort.new(\"CPORT\", [true, \"The source port for the TCP SYN packet\", 13832]),\n      OptInt.new(\"ECHOID\", [true, \"The unique ICMP ECHO ID to embed into the packet\", 7893]),\n    ])\n\n    deregister_options('FILTER','PCAPFILE')\n  end\n\n  def run_host(ip)\n    open_pcap\n\n    pcap = self.capture\n\n    capture_sendto(build_tcp_syn(ip), ip) and capture_sendto(build_icmp(ip), ip)\n\n    close_pcap\n  end\n\n  def build_tcp_syn(dst)\n    p = PacketFu::TCPPacket.new\n    p.ip_saddr = datastore['EHOST']\n    p.ip_daddr = dst\n    p.ip_ttl = 255\n    p.tcp_sport = datastore['CPORT'].to_i\n    p.tcp_dport = datastore['RPORT'].to_i\n    p.tcp_flags.syn = 1\n    p.tcp_seq = Rex::Socket.addr_atoi(dst)\n    p.recalc\n    p\n  end\n\n  def build_icmp(dst)\n    p = PacketFu::ICMPPacket.new\n    p.ip_saddr = datastore['EHOST']\n    p.ip_daddr = dst\n    p.ip_ttl = 255\n    p.icmp_type = 8\n    payload = Rex::Socket.addr_aton(dst) + [datastore['ECHOID']].pack('n') + Rex::Text.rand_text(26)\n    p.payload = capture_icmp_echo_pack(datastore['ECHOID'],1,payload)\n    p.recalc\n  end\nend\n"
}