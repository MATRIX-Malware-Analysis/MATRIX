{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--227768a4-2ae6-4222-8e67-58494bd42ea1",
    "created": "2024-08-14T16:26:30.985577Z",
    "modified": "2024-08-14T16:26:30.985581Z",
    "name": "MS12-020 Microsoft Remote Desktop Checker",
    "description": " This module checks a range of hosts for the MS12-020 vulnerability. This does not cause a DoS on the target.  'References'     => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/rdp/ms12_020_check.rb",
            "external_id": "ms12_020_check.rb"
        },
        {
            "source_name": "reference",
            "url": "https://docs.microsoft.com/en-us/security-updates/SecurityBulletins/2012/ms12-020"
        },
        {
            "source_name": "reference",
            "url": "https://svn.nmap.org/nmap/scripts/rdp-vuln-ms12-020.nse"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MS12-020 Microsoft Remote Desktop Checker',\n      'Description'    => %q{\n        This module checks a range of hosts for the MS12-020 vulnerability.\n        This does not cause a DoS on the target.\n      },\n      'References'     =>\n        [\n          [ 'CVE', '2012-0002' ],\n          [ 'MSB', 'MS12-020' ],\n          [ 'URL', 'https://docs.microsoft.com/en-us/security-updates/SecurityBulletins/2012/ms12-020' ],\n          [ 'EDB', '18606' ],\n          [ 'URL', 'https://svn.nmap.org/nmap/scripts/rdp-vuln-ms12-020.nse' ]\n        ],\n      'Author'         =>\n        [\n          'Royce Davis \"R3dy\" <rdavis[at]accuvant.com>',\n          'Brandon McCann \"zeknox\" <bmccann[at]accuvant.com>'\n        ],\n      'License'        => MSF_LICENSE\n    ))\n\n    register_options(\n      [\n        OptPort.new('RPORT', [ true, 'Remote port running RDP', 3389 ])\n      ])\n  end\n\n  def check_rdp\n    # code to check if RDP is open or not\n    vprint_status(\"Verifying RDP protocol...\")\n\n    # send connection\n    sock.put(connection_request)\n\n    # read packet to see if its rdp\n    res = sock.get_once(-1, 5)\n\n    # return true if this matches our vulnerable response\n    ( res and res.match(\"\\x03\\x00\\x00\\x0b\\x06\\xd0\\x00\\x00\\x12\\x34\\x00\") )\n  end\n\n  def report_goods\n    report_vuln(\n      :host         => rhost,\n      :port         => rport,\n      :proto        => 'tcp',\n      :name         => self.name,\n      :info         => 'Response indicates a missing patch',\n      :refs         => self.references\n    )\n  end\n\n  def connection_request\n    \"\\x03\\x00\" +    # TPKT Header version 03, reserved 0\n    \"\\x00\\x0b\" +    # Length\n    \"\\x06\" +        # X.224 Data TPDU length\n    \"\\xe0\" +        # X.224 Type (Connection request)\n    \"\\x00\\x00\" +    # dst reference\n    \"\\x00\\x00\" +    # src reference\n    \"\\x00\"          # class and options\n  end\n\n  def connect_initial\n    \"\\x03\\x00\\x00\\x65\" + # TPKT Header\n    \"\\x02\\xf0\\x80\" +     # Data TPDU, EOT\n    \"\\x7f\\x65\\x5b\" +     # Connect-Initial\n    \"\\x04\\x01\\x01\" +     # callingDomainSelector\n    \"\\x04\\x01\\x01\" +     # callingDomainSelector\n    \"\\x01\\x01\\xff\" +     # upwardFlag\n    \"\\x30\\x19\" +         # targetParams + size\n    \"\\x02\\x01\\x22\" +     # maxChannelIds\n    \"\\x02\\x01\\x20\" +     # maxUserIds\n    \"\\x02\\x01\\x00\" +     # maxTokenIds\n    \"\\x02\\x01\\x01\" +     # numPriorities\n    \"\\x02\\x01\\x00\" +     # minThroughput\n    \"\\x02\\x01\\x01\" +     # maxHeight\n    \"\\x02\\x02\\xff\\xff\" + # maxMCSPDUSize\n    \"\\x02\\x01\\x02\" +     # protocolVersion\n    \"\\x30\\x18\" +         # minParams + size\n    \"\\x02\\x01\\x01\" +     # maxChannelIds\n    \"\\x02\\x01\\x01\" +     # maxUserIds\n    \"\\x02\\x01\\x01\" +     # maxTokenIds\n    \"\\x02\\x01\\x01\" +     # numPriorities\n    \"\\x02\\x01\\x00\" +     # minThroughput\n    \"\\x02\\x01\\x01\" +     # maxHeight\n    \"\\x02\\x01\\xff\" +     # maxMCSPDUSize\n    \"\\x02\\x01\\x02\" +     # protocolVersion\n    \"\\x30\\x19\" +         # maxParams + size\n    \"\\x02\\x01\\xff\" +     # maxChannelIds\n    \"\\x02\\x01\\xff\" +     # maxUserIds\n    \"\\x02\\x01\\xff\" +     # maxTokenIds\n    \"\\x02\\x01\\x01\" +     # numPriorities\n    \"\\x02\\x01\\x00\" +     # minThroughput\n    \"\\x02\\x01\\x01\" +     # maxHeight\n    \"\\x02\\x02\\xff\\xff\" + # maxMCSPDUSize\n    \"\\x02\\x01\\x02\" +     # protocolVersion\n    \"\\x04\\x00\"           # userData\n  end\n\n  def user_request\n    \"\\x03\\x00\" +         # header\n    \"\\x00\\x08\" +         # length\n    \"\\x02\\xf0\\x80\" +     # X.224 Data TPDU (2 bytes: 0xf0 = Data TPDU, 0x80 = EOT, end of transmission)\n    \"\\x28\"               # PER encoded PDU contents\n  end\n\n  def channel_request\n    \"\\x03\\x00\\x00\\x0c\" +\n    \"\\x02\\xf0\\x80\\x38\"\n  end\n\n\n  def check_rdp_vuln\n    # check if rdp is open\n    unless check_rdp\n      vprint_status \"Could not connect to RDP.\"\n      return Exploit::CheckCode::Unknown\n    end\n\n    # send connectInitial\n    sock.put(connect_initial)\n\n    # send userRequest\n    sock.put(user_request)\n    res = sock.get_once(-1, 5)\n    return Exploit::CheckCode::Unknown unless res # nil due to a timeout\n    user1 = res[9,2].unpack(\"n\").first\n    chan1 = user1 + 1001\n\n    # send 2nd userRequest\n    sock.put(user_request)\n    res = sock.get_once(-1, 5)\n    return Exploit::CheckCode::Unknown unless res # nil due to a timeout\n    user2 = res[9,2].unpack(\"n\").first\n    chan2 = user2 + 1001\n\n    # send channel request one\n    sock.put(channel_request << [user1, chan2].pack(\"nn\"))\n    res = sock.get_once(-1, 5)\n    return Exploit::CheckCode::Unknown unless res # nil due to a timeout\n    if res[7,2] == \"\\x3e\\x00\"\n      # send ChannelRequestTwo - prevent BSoD\n      sock.put(channel_request << [user2, chan2].pack(\"nn\"))\n\n      report_goods\n      return Exploit::CheckCode::Vulnerable\n    else\n      return Exploit::CheckCode::Safe\n    end\n\n    # Can't determine, but at least I know the service is running\n    return Exploit::CheckCode::Detected\n  end\n\n  def check_host(ip)\n    # The check command will call this method instead of run_host\n\n    status = Exploit::CheckCode::Unknown\n\n    begin\n      connect\n      status = check_rdp_vuln\n    rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e\n      bt = e.backtrace.join(\"\\n\")\n      vprint_error(\"Unexpected error: #{e.message}\")\n      vprint_line(bt)\n      elog(e)\n    ensure\n      disconnect\n    end\n\n    status\n  end\n\n  def run_host(ip)\n    # Allow the run command to call the check command\n    status = check_host(ip)\n    if status == Exploit::CheckCode::Vulnerable\n      print_good(\"#{ip}:#{rport} - #{status[1]}\")\n    else\n      print_status(\"#{ip}:#{rport} - #{status[1]}\")\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ]
}