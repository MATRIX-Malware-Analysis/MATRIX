{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bb367869-1d6c-4986-97a9-05045974ab1c",
    "created": "2024-08-14T16:26:30.975618Z",
    "modified": "2024-08-14T16:26:30.975622Z",
    "name": "HTTP GET Request URI Fuzzer (Incrementing Lengths)",
    "description": "No description available.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/fuzzers/http/http_get_uri_long.rb",
            "external_id": "http_get_uri_long.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Fuzzer\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'HTTP GET Request URI Fuzzer (Incrementing Lengths)',\n      'Description'    => %q{\n        This module sends a series of HTTP GET request with incrementing URL lengths.\n      },\n      'Author'         => [ 'nullthreat' ],\n      'License'        => MSF_LICENSE\n    ))\n    register_options([\n      Opt::RPORT(80),\n      OptInt.new(\"MAXLENGTH\", [true, \"The longest string length to try\", 16384] ),\n      OptString.new(\"URIBASE\", [true, \"The base URL to use for the request fuzzer\", \"/\"]),\n      OptString.new(\"VHOST\", [false, \"The virtual host name to use in requests\"])\n    ])\n  end\n\n  def do_http_get(uri='',opts={})\n    @connected = false\n    connect\n    @connected = true\n\n    sock.put(\"GET #{uri} HTTP/1.1\\r\\nHost: #{datastore['VHOST'] || rhost}\\r\\n\\r\\n\")\n    sock.get_once(-1, opts[:timeout] || 0.01)\n  end\n\n  def run\n    last_str = nil\n    last_inp = nil\n    last_err = nil\n\n    pre = make_http_uri_base\n    cnt = 0\n\n    1.upto(datastore['MAXLENGTH'].to_i) do |len|\n      cnt += 1\n\n      str = fuzzer_gen_string(len)\n\n      # XXX: Encode the string or leave it raw? Best to make a new boolean option to enable/disable this\n      uri = pre + str\n\n      if(cnt % 100 == 0)\n        print_status(\"Fuzzing with iteration #{cnt} using string length #{len}\")\n      end\n\n      begin\n        r = do_http_get(uri,:timeout => 0.25)\n      rescue ::Interrupt\n        print_status(\"Exiting on interrupt: iteration #{cnt} using string length #{len}\")\n        raise $!\n      rescue ::Exception => e\n        last_err = e\n      ensure\n        disconnect\n      end\n\n      if(not @connected)\n        if(last_str)\n          print_status(\"The service may have crashed: iteration:#{cnt-1} len=#{len} uri=''#{last_str}'' error=#{last_err}\")\n        else\n          print_status(\"Could not connect to the service: #{last_err}\")\n        end\n        return\n      end\n\n      last_str = str\n      last_inp = @last_fuzzer_input\n    end\n  end\n\n  def make_http_uri_base\n    datastore['URIBASE']\n  end\nend\n",
    "x_mitre_contributors": [
        "[ nullthreat ]",
        ""
    ]
}