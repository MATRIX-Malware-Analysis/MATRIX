{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--47d8f3b7-6911-492b-9266-09a064fe76ba",
    "created": "2024-08-14T16:26:52.937486Z",
    "modified": "2024-08-14T16:26:52.937491Z",
    "name": "Digi RealPort Serial Server Port Scanner",
    "description": "Identify active ports on RealPort-enabled serial servers. 'References'  => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/scada/digi_realport_serialport_scan.rb",
            "external_id": "digi_realport_serialport_scan.rb"
        },
        {
            "source_name": "reference",
            "url": "https://web.archive.org/web/20151012224641/http://www.digi.com/support/productdetail?pid=2229&type=drivers"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::RealPort\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'Digi RealPort Serial Server Port Scanner',\n      'Description' => 'Identify active ports on RealPort-enabled serial servers.',\n      'References'  =>\n        [\n          ['URL', 'https://www.digi.com/resources/library/technical-briefs/fs_realport'],\n          ['URL', 'https://web.archive.org/web/20151012224641/http://www.digi.com/support/productdetail?pid=2229&type=drivers']\n        ],\n      'Author'      =>\n        [\n          'hdm'\n        ],\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        OptInt.new(\"BANNER_TIMEOUT\", [true, \"How long to capture data from the serial port\", 5]),\n        OptString.new('BAUD_RATES', [true, \"A space delimited list of baud rates to try for each port\", \"9600 115200\"]),\n        OptString.new('PORTS', [true, \"A space delimited list of 1-indexed serial port numbers to try, default is all supported\", \"ALL\"])\n      ])\n  end\n\n  def setup\n    test_speeds = datastore['BAUD_RATES'].split(/\\s+/)\n    test_speeds.each do |baud|\n      valid = realport_baud_to_speed(baud)\n      if not valid\n        raise RuntimeError, \"The baud rate #{baud} is not supported\"\n      end\n    end\n  end\n\n  def run_host(target_host)\n    test_ports  = datastore['PORTS'].upcase.split(/\\s+/)\n    test_speeds = datastore['BAUD_RATES'].split(/\\s+/)\n\n    return unless realport_connect\n\n    info = \"#{@realport_name} ( ports: #{@realport_port_count} )\"\n    vprint_good(\"#{target_host}:#{rport} is running #{info}\")\n    report_service(:host => rhost, :port => rport, :name => \"realport\", :info => info)\n\n    1.upto(@realport_port_count) do |pnum|\n      unless test_ports.include?('ALL') or test_ports.include?(pnum.to_s)\n        # Skip this port\n        next\n      end\n\n      test_speeds.each do |baud|\n        ret = realport_open(pnum - 1, baud)\n        break unless ret == :open\n        res = realport_recv_banner(pnum - 1, datastore['BANNER_TIMEOUT'])\n        if res and res.length > 0\n          print_status(\"#{target_host}:#{rport} [port #{pnum} @ #{baud}bps] #{res.inspect}\")\n          report_note(\n            :host   => target_host,\n            :proto  => 'tcp',\n            :port   => rport,\n            :type   => \"realport.port#{pnum}.banner\",\n            :data   => {:baud => baud, :banner => res},\n            :update => :unique_data\n          )\n\n        end\n        realport_close(pnum - 1)\n      end\n    end\n\n    realport_disconnect\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ]
}