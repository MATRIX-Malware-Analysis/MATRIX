{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ba80f9fb-7c00-4930-a105-d9b6d147ef57",
    "created": "2024-08-14T16:33:18.000134Z",
    "modified": "2024-08-14T16:33:18.000137Z",
    "name": "Multi Manage Post Module Macro Execution",
    "description": " This module will execute a list of modules given in a macro file in the format of <module> <opt=val,opt=val> against the select session checking for compatibility of the module against the sessions and validation of the options provided.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/manage/multi_post.rb",
            "external_id": "multi_post.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Multi Manage Post Module Macro Execution',\n        'Description' => %q{\n          This module will execute a list of modules given in a macro file in the format\n          of <module> <opt=val,opt=val> against the select session checking for compatibility\n          of the module against the sessions and validation of the options provided.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ '<carlos_perez[at]darkoperator.com>'],\n        'Platform' => %w[linux osx solaris unix win],\n        'SessionTypes' => [ 'meterpreter', 'shell' ]\n      )\n    )\n    register_options(\n      [\n\n        OptString.new('MACRO', [true, 'File with Post Modules and Options to run in the session', nil])\n\n      ]\n    )\n  end\n\n  # Run Method for when run command is issued\n  def run\n    # syinfo is only on meterpreter sessions\n    print_status(\"Running module against #{sysinfo['Computer']}\") if !sysinfo.nil?\n    macro = datastore['MACRO']\n    entries = []\n    if !::File.exist?(macro)\n      print_error 'Resource File does not exist!'\n      return\n    else\n      ::File.open(datastore['MACRO'], 'rb').each_line do |line|\n        # Empty line\n        next if line.strip.empty?\n        # Comment\n        next if line[0, 1] == '#'\n\n        entries << line.chomp\n      end\n    end\n\n    if entries\n      entries.each do |l|\n        values = l.split(' ')\n        post_mod = values[0]\n        if values.length == 2\n          mod_opts = values[1].split(',')\n        end\n        print_line(\"Loading #{post_mod}\")\n        # Make sure we can handle post module names with or without post in the start\n        if post_mod =~ %r{^post/}\n          post_mod.gsub!(%r{^post/}, '')\n        end\n        m = framework.post.create(post_mod)\n\n        # Check if a post module was actually initiated\n        if m.nil?\n          print_error(\"Post module #{post_mod} could not be initialized!\")\n          next\n        end\n        # Set the current session\n        s = datastore['SESSION']\n\n        if m.session_compatible?(s.to_i)\n          print_line(\"Running Against #{s}\")\n          m.datastore['SESSION'] = s\n          if mod_opts\n            mod_opts.each do |o|\n              opt_pair = o.split('=', 2)\n              print_line(\"\\tSetting Option #{opt_pair[0]} to #{opt_pair[1]}\")\n              m.datastore[opt_pair[0]] = opt_pair[1]\n            end\n          end\n          m.options.validate(m.datastore)\n          m.run_simple(\n            'LocalInput' => user_input,\n            'LocalOutput' => user_output\n          )\n        else\n          print_error(\"Session #{s} is not compatible with #{post_mod}\")\n        end\n      end\n    else\n      print_error('Resource file was empty!')\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "%w[linux osx solaris unix win]"
    ]
}