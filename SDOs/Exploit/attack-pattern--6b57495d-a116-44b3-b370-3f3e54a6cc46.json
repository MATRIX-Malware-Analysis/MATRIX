{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6b57495d-a116-44b3-b370-3f3e54a6cc46",
    "created": "2024-08-14T16:33:19.212843Z",
    "modified": "2024-08-14T16:33:19.212846Z",
    "name": "\"Non-Upper Encoder\"",
    "description": " Encodes payloads as non-alpha based bytes. This allows payloads to bypass tolower() calls, but will fail isalpha(). Table based design from Russel Sanford. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/x86/nonupper.rb",
            "external_id": "nonupper.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/encoder/nonupper'\n\nclass MetasploitModule < Msf::Encoder::NonUpper\n  Rank = LowRanking\n\n  def initialize\n    super(\n      'Name'             => \"Non-Upper Encoder\",\n      'Description'      => %q{\n          Encodes payloads as non-alpha based bytes. This allows\n        payloads to bypass tolower() calls, but will fail isalpha().\n        Table based design from Russel Sanford.\n      },\n      'Author'           => [ 'pusscat'],\n      'Arch'             => ARCH_X86,\n      'License'          => BSD_LICENSE,\n      'EncoderType'      => Msf::Encoder::Type::NonUpper,\n      'Decoder'          =>\n        {\n          'BlockSize' => 1,\n        })\n  end\n\n  #\n  # Returns the decoder stub that is adjusted for the size of the buffer\n  # being encoded.\n  #\n  def decoder_stub(state)\n    state.key                   = \"\"\n    state.decoder_key_size      = 0\n    Rex::Encoder::NonUpper::gen_decoder()\n  end\n\n  #\n  # Encodes a one byte block with the current index of the length of the\n  # payload.\n  #\n  def encode_block(state, block)\n    begin\n      newchar, state.key, state.decoder_key_size =\n        Rex::Encoder::NonUpper::encode_byte(datastore['BadChars'], block.unpack('C')[0], state.key, state.decoder_key_size)\n    rescue RuntimeError => e\n      # This is a bandaid to deal with the fact that, since it's in\n      # the Rex namespace, the encoder itself doesn't have access to the\n      # Msf exception classes.  Turn it into an actual EncodingError\n      # exception so the encoder doesn't look broken when it just fails\n      # to encode.\n      raise BadcharError if e.message == \"BadChar\"\n    end\n    return newchar\n  end\n\n  #\n  # Fix stuff, and add the table :)\n  #\n  def encode_end(state)\n    state.encoded.gsub!(/A/, state.decoder_key_size.chr)\n    state.encoded.gsub!(/B/, (state.decoder_key_size+5).chr)\n    state.encoded[0x24, 0] = state.key\n  end\nend\n"
}