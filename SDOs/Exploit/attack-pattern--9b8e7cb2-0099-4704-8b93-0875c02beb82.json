{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9b8e7cb2-0099-4704-8b93-0875c02beb82",
    "created": "2024-08-14T16:28:08.502576Z",
    "modified": "2024-08-14T16:28:08.50258Z",
    "name": "IPID Sequence Scanner",
    "description": " This module will probe hosts' IPID sequences and classify them using the same method Nmap uses when it's performing its IPID Idle Scan (-sI) and OS Detection (-O).  Nmap's probes are SYN/ACKs while this module's are SYNs. While this does not change the underlying functionality it does change the chance of whether or not the probe will be stopped by a firewall.  Nmap's Idle Scan can use hosts whose IPID sequences are classified as \"Incremental\" or \"Broken little-endian incremental\". ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/ip/ipidseq.rb",
            "external_id": "ipidseq.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'timeout'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Capture\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'IPID Sequence Scanner',\n      'Description' => %q{\n        This module will probe hosts' IPID sequences and classify\n        them using the same method Nmap uses when it's performing\n        its IPID Idle Scan (-sI) and OS Detection (-O).\n\n        Nmap's probes are SYN/ACKs while this module's are SYNs.\n        While this does not change the underlying functionality,\n        it does change the chance of whether or not the probe\n        will be stopped by a firewall.\n\n        Nmap's Idle Scan can use hosts whose IPID sequences are\n        classified as \"Incremental\" or \"Broken little-endian incremental\".\n      },\n      'Author'      => 'kris katterjohn',\n      'License'     => MSF_LICENSE\n    )\n\n    register_options([\n      Opt::RPORT(80),\n      OptInt.new('TIMEOUT', [true, \"The reply read timeout in milliseconds\", 500]),\n      OptString.new('INTERFACE', [false, 'The name of the interface'])\n    ])\n\n    register_advanced_options([\n      OptInt.new('SAMPLES', [true, \"The IPID sample size\", 6])\n    ])\n\n    deregister_options('FILTER','PCAPFILE')\n  end\n\n  def rport\n    datastore['RPORT'].to_i\n  end\n\n  def run_host(ip)\n    open_pcap\n\n    raise \"SAMPLES option must be >= 2\" if datastore['SAMPLES'] < 2\n\n    pcap = self.capture\n\n    shost = Rex::Socket.source_address(ip)\n\n    to = (datastore['TIMEOUT'] || 500).to_f / 1000.0\n\n    ipids = []\n\n    pcap.setfilter(getfilter(shost, ip, rport))\n\n    datastore['SAMPLES'].times do\n      sport = rand(0xffff - 1025) + 1025\n\n      probe = buildprobe(shost, sport, ip, rport)\n\n      next unless capture_sendto(probe, ip)\n\n      reply = probereply(pcap, to)\n\n      next if not reply\n\n      ipids << reply.ip_id\n    end\n\n    close_pcap\n\n    return if ipids.empty?\n\n    print_status(\"#{ip}'s IPID sequence class: #{analyze(ipids)}\")\n\n    #Add Report\n    report_note(\n      :host\t=> ip,\n      :proto\t=> 'ip',\n      :type\t=> 'IPID sequence',\n      :data\t=> \"IPID sequence class: #{analyze(ipids)}\"\n    )\n  end\n\n  # Based on Nmap's get_ipid_sequence() in osscan2.cc\n  def analyze(ipids)\n    allzeros = true\n    allsame = true\n    mul256 = true\n    inc = true\n\n    # ipids.each do |ipid|\n    #\tprint_status(\"Got IPID ##{ipid}\")\n    # end\n\n    return \"Unknown\" if ipids.size < 2\n\n    diffs = []\n    i = 1\n\n    while i < ipids.size\n      p = ipids[i - 1]\n      c = ipids[i]\n\n      if p != 0 or c != 0\n        allzeros = false\n      end\n\n      if p <= c\n        diffs[i - 1] = c - p\n      else\n        diffs[i - 1] = c - p + 65536\n      end\n\n      if ipids.size > 2 and diffs[i - 1] > 20000\n        return \"Randomized\"\n      end\n\n      i += 1\n    end\n\n    return \"All zeros\" if allzeros\n\n    diffs.each do |diff|\n      if diff > 1000 and ((diff % 256) != 0 or ((diff % 256) == 0 and diff >= 25600))\n        return \"Random positive increments\"\n      end\n\n      allsame = false if diff != 0\n\n      mul256 = false if diff > 5120 or (diff % 256) != 0\n\n      inc = false if diff >= 10\n    end\n\n    return \"Constant\" if allsame\n\n    return \"Broken little-endian incremental!\" if mul256\n\n    return \"Incremental!\" if inc\n\n    \"Unknown\"\n  end\n\n  def getfilter(shost, dhost, dport)\n    \"tcp and src host #{dhost} and src port #{dport} and \" +\n    \"dst host #{shost}\"\n  end\n\n  # This gets set via the usual capture_sendto interface\n  def buildprobe(shost, sport, dhost, dport)\n    p = PacketFu::TCPPacket.new\n    p.ip_saddr = shost\n    p.ip_daddr = dhost\n    p.tcp_sport = sport\n    p.tcp_dport = dport\n    p.tcp_flags.syn = 1\n    p.recalc\n    p\n  end\n\n  def probereply(pcap, to)\n    reply = nil\n\n    begin\n      Timeout.timeout(to) do\n        pcap.each do |r|\n          pkt = PacketFu::Packet.parse(r)\n          next unless pkt.is_tcp?\n          next unless pkt.tcp_flags.syn == 1 || pkt.tcp_flags.rst == 1\n          reply = pkt\n          break\n        end\n      end\n    rescue Timeout::Error\n    end\n\n    return reply\n  end\nend\n"
}