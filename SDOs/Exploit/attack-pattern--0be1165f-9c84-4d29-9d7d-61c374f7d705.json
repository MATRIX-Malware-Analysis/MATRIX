{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0be1165f-9c84-4d29-9d7d-61c374f7d705",
    "created": "2024-08-14T16:27:01.298176Z",
    "modified": "2024-08-14T16:27:01.29818Z",
    "name": "URGENT/11 Scanner, Based on Detection Tool by Armis",
    "description": " This module detects VxWorks and the IPnet IP stack, along with devices",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/vxworks/urgent11_check.rb",
            "external_id": "urgent11_check.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-12258"
        },
        {
            "source_name": "reference",
            "url": "https://armis.com/urgent11"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/ArmisSecurity/urgent11-detector"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n  include Msf::Exploit::Capture\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'URGENT/11 Scanner, Based on Detection Tool by Armis',\n      'Description'    => %q{\n        This module detects VxWorks and the IPnet IP stack, along with devices\n        vulnerable to CVE-2019-12258.\n      },\n      'Author'         => [\n        'Ben Seri',   # Upstream tool\n        'Brent Cook', # Metasploit module\n        'wvu'         # Metasploit module\n      ],\n      'References'     => [\n        ['CVE', '2019-12258'],\n        ['URL', 'https://armis.com/urgent11'],\n        ['URL', 'https://github.com/ArmisSecurity/urgent11-detector']\n      ],\n      'DisclosureDate' => '2019-08-09', # NVD entry publication\n      'License'        => MSF_LICENSE,\n      'Notes'          => {'Stability' => [CRASH_SAFE]}\n    ))\n\n    register_options([\n      OptString.new('RPORTS', required: true, default: \"21 22 23 80 443\", desc: 'Target ports for TCP detections')\n    ])\n\n    register_advanced_options([\n      OptInt.new('RetransmissionRate', required: true, default: 3, desc: 'Send n TCP packets')\n    ])\n\n    deregister_options('PCAPFILE', 'FILTER')\n  end\n\n  #\n  # Utility methods\n  #\n\n  def rports\n    datastore['RPORTS'].split(/[\\s,]/).collect{|i| (i.to_i.to_s == i) ? i.to_i : nil}.compact\n  end\n\n  def filter(ip)\n    \"src host #{ip} and dst host #{Rex::Socket.source_address(ip)}\"\n  end\n\n  #\n  # Scanner methods\n  #\n\n  def run_host(ip)\n    # XXX: Configuring Ethernet and IP headers sends a UDP packet!\n    @config = PacketFu::Utils.whoami?(target: ip)\n\n    open_pcap\n    capture.setfilter(filter(ip))\n\n    port_open = false\n    rports.each do |rport|\n      port_open |= run_detections(ip, rport)\n    end\n    raise RuntimeError.new(\"No ports open on #{ip} from #{datastore['RPORTS']}\") if !port_open\n  rescue RuntimeError => e\n    fail_with(Failure::BadConfig, e.message)\n  ensure\n    close_pcap\n  end\n\n  def detections\n    %w[\n      tcp_dos_detection\n      tcp_malformed_options_detection\n      icmp_code_detection\n      icmp_timestamp_detection\n    ]\n  end\n\n  def run_detections(ip, port)\n    print_status(\"#{ip}:#{port} being checked\")\n\n    final_ipnet_score        = 0\n    final_vxworks_score      = 0\n    affected_vulnerabilities = []\n\n    begin\n      sock = Rex::Socket::Tcp.create(\n        'PeerHost' => ip,\n        'PeerPort' => port\n      )\n    rescue\n      vprint_bad(\"Could not connect to #{ip}:#{port}, cannot verify vulnerability\")\n      return false\n    end\n\n    detections.each do |detection|\n      @ipnet_score     = 0\n      @vxworks_score   = 0\n      @vulnerable_cves = []\n\n      detection_name = detection.camelize\n\n      begin\n        send(detection, sock, ip, port)\n      rescue StandardError => e\n        vprint_error(\"#{detection_name} failed: #{e.message}\")\n        next\n      end\n\n      vprint_status(\n        \"\\t#{detection_name.ljust(30)}\" \\\n        \"\\tVxWorks: #{@vxworks_score}\" \\\n        \"\\tIPnet: #{@ipnet_score}\"\n      )\n\n      final_ipnet_score        += @ipnet_score\n      final_vxworks_score      += @vxworks_score\n      affected_vulnerabilities += @vulnerable_cves\n    end\n\n    sock.close\n\n    if final_ipnet_score > 0\n      vprint_good(\"#{ip}:#{port} detected as IPnet\")\n    elsif final_ipnet_score < 0\n      vprint_error(\"#{ip}:#{port} detected as NOT IPnet\")\n    end\n\n    if final_vxworks_score > 100\n      vprint_good(\"#{ip}:#{port} detected as VxWorks\")\n    elsif final_vxworks_score < 0\n      vprint_error(\"#{ip}:#{port} detected as NOT VxWorks\")\n    end\n\n    affected_vulnerabilities.each do |vuln|\n      msg = \"#{ip}:#{port} affected by #{vuln}\"\n      print_good(msg)\n      report_vuln(\n        host: ip,\n        name: name,\n        refs: references,\n        info: msg\n      )\n    end\n    true\n  end\n\n  #\n  # TCP detection methods\n  #\n\n  def tcp_malformed_options_detection(sock, ip, port)\n    pkt = PacketFu::TCPPacket.new(config: @config)\n\n    # IP destination address\n    pkt.ip_daddr = ip\n\n    # TCP SYN with malformed options\n    pkt.tcp_dst       = port\n    pkt.tcp_flags.syn = 1\n    pkt.tcp_opts      = [2, 4, 1460].pack('CCn') + # MSS\n                        [1].pack('C') +            # NOP\n                        [3, 2].pack('CC') +        # WSCALE with invalid length\n                        [3, 3, 0].pack('CCC')      # WSCALE with valid length\n    pkt.recalc\n\n    res = nil\n\n    datastore['RetransmissionRate'].times do\n      pkt.to_w\n      res = inject_reply(:tcp)\n\n      break unless res\n    end\n\n    unless res\n      return @vxworks_score = 0,\n             @ipnet_score   = 50\n    end\n\n    if res.tcp_flags.rst == 1 &&\n      res.tcp_dst == pkt.tcp_src && res.tcp_dst == pkt.tcp_src\n\n      return @vxworks_score = 100,\n             @ipnet_score   = 100\n    end\n\n    return @vxworks_score = -100,\n           @ipnet_score   = -100\n  end\n\n  def tcp_dos_detection(sock, ip, port)\n    pkt = PacketFu::TCPPacket.new(config: @config)\n\n    # IP destination address\n    pkt.ip_daddr = ip\n\n    # TCP SYN with malformed (truncated) WS option\n    pkt.tcp_src       = sock.getlocalname.last\n    pkt.tcp_dst       = sock.peerport\n    pkt.tcp_seq       = rand(0xffffffff + 1)\n    pkt.tcp_ack       = rand(0xffffffff + 1)\n    pkt.tcp_flags.syn = 1\n    pkt.tcp_opts      = [3, 2].pack('CC') +    # WSCALE with invalid length\n                        [1, 0].pack('CC')      # NOP + EOL\n    pkt.recalc\n\n    res = nil\n\n    datastore['RetransmissionRate'].times do\n      pkt.to_w\n      res = inject_reply(:tcp)\n\n      break unless res\n    end\n\n    unless res\n      return @vxworks_score = 0,\n             @ipnet_score   = 0\n    end\n\n    if res.tcp_flags.rst == 1 &&\n      res.tcp_dst == pkt.tcp_src && res.tcp_dst == pkt.tcp_src\n\n      return @vxworks_score   = 100,\n             @ipnet_score     = 100,\n             @vulnerable_cves = ['CVE-2019-12258']\n    end\n\n    return @vxworks_score = 0,\n           @ipnet_score   = 0\n  end\n\n  #\n  # ICMP detection methods\n  #\n\n  def icmp_code_detection(sock, ip, _port = nil)\n    pkt = PacketFu::ICMPPacket.new(config: @config)\n\n    # IP destination address\n    pkt.ip_daddr = ip\n\n    # ICMP echo request with non-zero code\n    pkt.icmp_type = 8\n    pkt.icmp_code = rand(0x01..0xff)\n    pkt.payload   = capture_icmp_echo_pack\n    pkt.recalc\n\n    pkt.to_w\n    res = inject_reply(:icmp)\n\n    unless res\n      return @ipnet_score = 0\n    end\n\n    # Echo reply with zeroed code\n    if res.icmp_type == 0 && res.icmp_code == 0\n      return @ipnet_score = 20\n    end\n\n    @ipnet_score = -20\n  end\n\n  def icmp_timestamp_detection(sock, ip, _port = nil)\n    pkt = PacketFu::ICMPPacket.new(config: @config)\n\n    # IP destination address\n    pkt.ip_daddr = ip\n\n    # Truncated ICMP timestamp request\n    pkt.icmp_type = 13\n    pkt.icmp_code = 0\n    pkt.payload   = \"\\x00\" * 4\n    pkt.recalc\n\n    pkt.to_w\n    res = inject_reply(:icmp)\n\n    unless res\n      return @ipnet_score = 0\n    end\n\n    # Timestamp reply\n    if res.icmp_type == 14\n      return @ipnet_score = 90\n    end\n\n    @ipnet_score = -30\n  end\n\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2019-08-09, # NVD entry publication"
}