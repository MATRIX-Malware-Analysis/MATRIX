{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--206bb8d4-5c2f-48ff-8bbf-5c277911f193",
    "created": "2024-08-14T16:27:09.305227Z",
    "modified": "2024-08-14T16:27:09.305231Z",
    "name": "UDP Scanner Example",
    "description": "( This module is an example of how to send probes to UDP services en-masse, analyze any responses, and then report on any discovered hosts, services, vulnerabilities or otherwise noteworthy things. Simply address any of the TODOs. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/udp/example.rb",
            "external_id": "example.rb"
        },
        {
            "source_name": "reference",
            "url": "https://SomeURLinCyberspace.local"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::UDPScanner\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        # TODO: fill in all of this\n        'Name'           => 'UDP Scanner Example',\n        'Description'    => %q(\n          This module is an example of how to send probes to UDP services\n          en-masse, analyze any responses, and then report on any discovered\n          hosts, services, vulnerabilities or otherwise noteworthy things.\n          Simply address any of the TODOs.\n        ),\n        'Author'         => 'Joe Contributor <joe_contributor[at]example.com>',\n        'DisclosureDate' => '2014-03-15',\n        'License'        => MSF_LICENSE,\n        'References'     => [\n          [ 'CVE', '0000-0000' ], # remove or update if CVE exists\n          [ 'URL', 'https://SomeURLinCyberspace.local' ]\n        ]\n      )\n    )\n\n    register_options(\n      [\n        # TODO: change to the port you need to scan\n        Opt::RPORT(12345)\n      ]\n    )\n\n    # TODO: add any advanced, special options here, otherwise remove\n    register_advanced_options(\n      [\n        OptBool.new('SPECIAL', [true, 'Try this special thing', false])\n      ]\n    )\n  end\n\n  def setup\n    super\n    # TODO: do any sort of preliminary sanity checking, like perhaps validating some options\n    # in the datastore, etc.\n  end\n\n  # TODO: construct the appropriate probe here.\n  def build_probe\n    @probe ||= 'abracadabra!'\n  end\n\n  # TODO: this is called before the scan block for each batch of hosts.  Do any\n  # per-batch setup here, otherwise remove it.\n  def scanner_prescan(batch)\n    super\n  end\n\n  # TODO: this is called for each IP in the batch.  This will send all of the\n  # necessary probes.  If something different must be done for each IP, do it\n  # here, otherwise remove it.\n  def scan_host(ip)\n    super\n  end\n\n  # Called for each response packet\n  def scanner_process(response, src_host, _src_port)\n    # TODO: inspect each response, perhaps confirming that it is a valid\n    # response for the service/protocol in question and/or analyzing it more\n    # closely.  In this case, we simply check to see that it is of reasonable\n    # size and storing a result for this host iff so.  Note that src_port may\n    # not actually be the same as the original RPORT for some services if they\n    # respond back from different ports\n    return unless response.size >= 42\n    @results[src_host] ||= []\n\n    # TODO: store something about this response, perhaps the response itself,\n    # some metadata obtained by analyzing it, the proof that it is vulnerable\n    # to something, etc.  In this example, we simply look for any response\n    # with a sequence of 5 useful ASCII characters and, iff found, we store\n    # that sequence\n    /(?<relevant>[\\x20-\\x7E]{5})/ =~ response && @results[src_host] << relevant\n  end\n\n  # Called after the scan block\n  def scanner_postscan(_batch)\n    @results.each_pair do |host, relevant_responses|\n      peer = \"#{host}:#{rport}\"\n\n      # report on the host\n      report_host(host: host)\n\n      # report on the service, since it responded\n      report_service(\n        host: host,\n        proto: 'udp',\n        port: rport,\n        name: 'example',\n        # show at most 4 relevant responses\n        info: relevant_responses[0, 4].join(',')\n      )\n\n      if relevant_responses.empty?\n        vprint_status(\"#{peer} Not vulnerable to something\")\n      else\n        print_good(\"#{peer} Vulnerable to something!\")\n        report_vuln(\n          host: host,\n          port: rport,\n          proto: 'udp',\n          name: 'something!',\n          info: \"Got #{relevant_responses.size} response(s)\",\n          refs: references\n        )\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-03-15"
}