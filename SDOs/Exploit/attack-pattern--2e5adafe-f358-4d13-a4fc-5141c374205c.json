{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2e5adafe-f358-4d13-a4fc-5141c374205c",
    "created": "2024-08-14T16:27:06.936114Z",
    "modified": "2024-08-14T16:27:06.936118Z",
    "name": "Identify Queue Manager Name and MQ Version",
    "description": "Run this auxiliary against the listening port of an IBM MQ Queue Manager to identify its name and version. Any channel type can be used to get this information as long as the name of the channel is valid.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/misc/ibm_mq_enum.rb",
            "external_id": "ibm_mq_enum.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Identify Queue Manager Name and MQ Version',\n      'Description'    => 'Run this auxiliary against the listening port of an IBM MQ Queue Manager to identify its name and version. Any channel type can be used to get this information as long as the name of the channel is valid.',\n      'Author'         => [ 'Petros Koutroumpis' ],\n      'License'        => MSF_LICENSE\n    ))\n    register_options(\n      [\n        OptString.new('CHANNEL', [ true, \"Channel to use\" ,\"SYSTEM.DEF.SVRCONN\"]),\n        OptInt.new('CONCURRENCY', [true, \"The number of concurrent ports to check per host\", 10]),\n        OptInt.new('TIMEOUT', [true, \"The socket connect timeout in seconds\", 10]),\n        OptString.new('PORTS', [true, 'Ports to probe', '1414']),\n\n      ])\n    deregister_options('RPORT')\n  end\n\n\n  def create_packet(channel_type)\n    chan = datastore['CHANNEL'] + \"\\x20\"*(20-datastore['CHANNEL'].length.to_i)\n    if channel_type == 0\n      chan_type = \"\\x26\"\n    elsif channel_type == 1\n      chan_type = \"\\x07\"\n    elsif channel_type == 2\n      chan_type = \"\\x08\"\n    end\n\n    packet = \"\\x54\\x53\\x48\\x20\" + \t\t# StructID\n    \"\\x00\\x00\\x01\\x0c\" + \t\t\t# MQSegmLen\n    \"\\x02\" + \t\t\t\t\t# ByteOrder\n    \"\\x01\" + \t\t\t\t\t# SegmType\n    \"\\x01\" + \t\t\t\t\t# CtlFlag1\n    \"\\x00\" + \t\t\t\t\t# CtlFlag2\n    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" +\t# LUW Ident\n    \"\\x22\\x02\\x00\\x00\" + \t\t\t# Encoding\n    \"\\xb5\\x01\" + \t\t\t\t# CCSID\n    \"\\x00\\x00\" + \t\t\t\t# Reserved\n    \"\\x49\\x44\\x20\\x20\" + \t\t\t# StructId\n    \"\\x0d\" + \t\t\t\t\t# FAP level\n    chan_type + \t\t\t\t# CapFlag1 - Message Type\n    \"\\x00\" + \t\t\t\t\t# ECapFlag1\n    \"\\x00\" + \t\t\t\t\t# IniErrFlg1\n    \"\\x00\\x00\" + \t\t\t\t# Reserved\n    \"\\x32\\x00\" + \t\t\t\t# MaxMsgBtch\n    \"\\xec\\x7f\\x00\\x00\" + \t\t\t# MaxTrSize\n    \"\\x00\\x00\\x40\\x00\" + \t\t\t# MaxMsgSize\n    \"\\xff\\xc9\\x9a\\x3b\" + \t\t\t# SeqWrapVal\n    chan + \t\t\t\t\t# Channel Name\n    \"\\x87\" + \t\t\t\t\t# CapFlag2\n    \"\\x00\" + \t\t\t\t\t# ECapFlag2\n    \"\\x5b\\x01\" +\t\t\t\t# ccsid\n    \"QM1\" + \"\\x20\"*45 +\t\t\t# Queue Manager Name\n    \"\\x2c\\x01\\x00\\x00\" + \t\t\t# HBInterval\n    \"\\x8a\\x00\" + \t\t\t\t# EFLLength\n    \"\\x00\" + \t\t\t\t\t# IniErrFlg2\n    \"\\x55\" + \t\t\t\t\t# Reserved1\n    \"\\x00\\xff\" +\t\t\t\t# HdrCprsLst\n    \"\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\" + \t# MsgCprsLst1\n    \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\" + \t\t# MsgCprsLst2\n    \"\\x00\\x00\" + \t\t\t\t# Reserved2\n    \"\\x00\\x00\\x00\\x00\" + \t\t\t# SSLKeyRst\n    \"\\x00\\x00\\x00\\x00\" + \t\t\t# ConvBySkt\n    \"\\x05\" + \t\t\t\t\t# CapFlag3\n    \"\\x00\" + \t\t\t\t\t# ECapFlag3\n    \"\\x00\\x00\" + \t\t\t\t# Reserved3\n    \"\\x10\\x13\\x00\\x00\" + \t\t\t# ProcessId\n    \"\\x01\\x00\\x00\\x00\" + \t\t\t# ThreadId\n    \"\\x01\\x00\\x00\\x00\" + \t\t\t# TraceId\n    \"MQMM09000000\" +\t\t \t\t# ProdId\n    \"MQMID\" + \"\\x20\"*43 + \t\t\t# MQM ID\n    \"\\x00\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\" +\t# Unknown1\n    \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\" + \t# Unknown2\n    \"\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" + \t# Unknown3\n    \"\\x00\\x00\\x00\\x00\\x00\" \t\t\t# Unknown4\n  end\n\n\n  def run_host(ip)\n    chan = datastore['CHANNEL']\n    if chan.length > 20\n      print_error(\"Channel name must be less than 20 characters.\")\n      raise Msf::OptionValidateError.new(['CHANNEL'])\n    end\n    ports = Rex::Socket.portspec_crack(datastore['PORTS'])\n    while(ports.length > 0)\n      t = []\n      r = []\n      begin\n        1.upto(datastore['CONCURRENCY']) do\n          this_port = ports.shift\n          break if not this_port\n          t << framework.threads.spawn(\"Module(#{self.refname})-#{ip}:#{this_port}\", false, this_port) do |port|\n            begin\n                data_recv = \"\"\n                3.times do |channel_type|\n                  data_recv = send_packet(ip,port,channel_type)\n                  if data_recv.nil?\n                    next\n                  end\n                  # check if CHANNEL_WRONG_TYPE error received and retry with different type\n                  if data_recv[data_recv.length-4...data_recv.length] != \"\\x02\\x00\\x00\\x00\"\n                    break\n                  end\n                end\n                if data_recv.nil?\n                  print_status(\"No response received. Try increasing TIMEOUT value.\")\n                  print_line\n                  next\n                end\n                status_code = data_recv[-4..-1]\n                if status_code == \"\\x18\\x00\\x00\\x00\"\n                  print_status(\"Channel Requires SSL. Could not get more information.\")\n                  print_line\n                end\n                if not data_recv[0...3].include?('TSH')\n                  next\n                end\n                if status_code == \"\\x01\\x00\\x00\\x00\"\n                  print_error('Channel \"' + chan + '\" does not exist.')\n                  print_line\n                end\n                if status_code == \"\\x02\\x00\\x00\\x00\" or status_code == \"\\x06\\x00\\x00\\x00\"\n                  print_error('Unsupported channel type. Try a different channel.')\n                  print_line\n                end\n                if data_recv.length < 180\n                  next\n                end\n                qm_name = data_recv[76...124].delete(' ')\n                mq_version = data_recv[180...188].scan(/../).collect{|x| x.to_i}.join('.')\n                print_good(\"#{ip}:#{port} - Queue Manager Name: #{qm_name} - MQ Version: #{mq_version}\")\n                print_line\n            end\n          end\n        end\n        t.each {|x| x.join }\n      end\n    end\n  end\n\n  def send_packet(ip,port,channel_type)\n    begin\n      timeout = datastore['TIMEOUT'].to_i\n      packet = create_packet(channel_type)\n      s = connect(false,\n       {\n         'RPORT' => port,\n         'RHOST' => ip,\n        }\n      )\n      s.put(packet)\n      data = s.get_once(-1,timeout)\n      return data\n    rescue ::Rex::ConnectionRefused\n      print_error(\"#{ip}:#{port} - TCP Port Closed.\")\n      print_line\n    rescue ::Rex::ConnectionError, ::IOError, ::Timeout::Error, Errno::ECONNRESET\n      print_error(\"#{ip}:#{port} - Connection Failed.\")\n      print_line\n    rescue ::Interrupt\n      raise $!\n    ensure\n      if s\n        disconnect(s) rescue nil\n      end\n    end\n  end\n\nend\n"
}