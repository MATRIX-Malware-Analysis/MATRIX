{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--cc71c660-f606-4924-886e-715181f8f65b",
    "created": "2024-08-14T16:30:14.37818Z",
    "modified": "2024-08-14T16:30:14.378185Z",
    "name": "Http:BL Lookup",
    "description": " This module can be used to enumerate information about an IP addresses from Project HoneyPot's HTTP Block List. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/httpbl_lookup.rb",
            "external_id": "httpbl_lookup.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.projecthoneypot.org/httpbl_api.php"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire \"net/dns/resolver\"\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'\t\t   => 'Http:BL Lookup',\n      'Description'\t=> %q{\n          This module can be used to enumerate information\n        about an IP addresses from Project HoneyPot's HTTP Block List.\n      },\n      'Author' \t\t=> [ 'mubix' ],\n      'License'\t\t=> MSF_LICENSE,\n      'References' \t=>\n        [\n          ['URL', 'https://www.projecthoneypot.org/httpbl_api.php'],\n        ]\n      ))\n\n\n    register_options(\n      [\n        # OptAddressRange.new('RHOSTS', [false, \"The target address, range, or CIDR identifier\"]),\n        OptString.new('HTTPBL_APIKEY', [ true, \"Your HTTP:BL api key\"])\n      ])\n  end\n\n  # Not compatible today\n  def support_ipv6?\n    false\n  end\n\n  def resolve(ip)\n    results = ''\n    apikey = datastore['HTTPBL_APIKEY']\n    query = apikey + '.' + ip.split('.').reverse.join('.') + '.dnsbl.httpbl.org'\n    begin\n      results = Resolv::DNS.new.getaddress(query).to_s\n    rescue Resolv::ResolvError => e\n      results = 0\n    rescue => e\n      print_error e\n      results = 0\n    end\n    return results\n  end\n\n  def translate(ip)\n    ip.split('.')\n  end\n\n  def run_host(ip)\n    result = resolve(ip)\n    if result != 0\n      breakup = result.split('.')\n      lastseen = breakup[1]\n      threatnum = breakup[2].to_i\n      if threatnum < 25 then\n        threat = \"less than 100\"\n      elsif threatnum > 25 and threatnum < 49 then\n        threat = \"over 100\"\n      elsif threatnum > 50 and threatnum < 99 then\n        threat = \"over 10,000\"\n      elsif threatnum > 75 then\n        threat = \"over 1 million\"\n      end\n\n      typenum = breakup[3]\n      typestring = case typenum\n        when '0' then 'Search Engine'\n        when '1' then 'Suspicious'\n        when '2' then 'Harvester'\n        when '3' then 'Suspicious & Harvester'\n        when '4' then 'Comment Spammer'\n        when '5' then 'Suspicious & Comment Spammer'\n        when '6' then 'Harvester & Comment Spammer'\n        when '7' then 'Suspicious & Harvester & Comment Spammer'\n        else\n          \"Unknown\"\n      end\n\n      print_status \"\"\n      print_status \"#{ip} resloves to #{result} which means: #{typestring}\"\n      print_status \"=> it was last seen #{lastseen} day ago and has a threat score of #{threatnum} or \\'#{threat} spam messages\\'\"\n      print_status \"=> more info here: http://www.projecthoneypot.org/ip_#{ip}\\n\"\n    end\n  end\nend\n"
}