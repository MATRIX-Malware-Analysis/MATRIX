{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3335d39c-62cb-4a1e-b08b-f4e2daa22b24",
    "created": "2024-08-14T16:30:41.749908Z",
    "modified": "2024-08-14T16:30:41.749912Z",
    "name": "HTTP HTML Title Tag Content Grabber",
    "description": " Generates a GET request to the provided webservers and returns the server header HTML title attribute and location header (if set). This is useful for rapidly identifying interesting web applications en mass. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/title.rb",
            "external_id": "title.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  # Exploit mixins should be called first\n  include Msf::Exploit::Remote::HttpClient\n  # Scanner mixin should be near last\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'HTTP HTML Title Tag Content Grabber',\n      'Description' => %q{\n        Generates a GET request to the provided webservers and returns the server header,\n        HTML title attribute and location header (if set). This is useful for rapidly identifying\n        interesting web applications en mass.\n      },\n      'Author'       => 'Stuart Morgan <stuart.morgan[at]mwrinfosecurity.com>',\n      'License'     => MSF_LICENSE,\n    )\n\n    register_options(\n      [\n        OptBool.new('STORE_NOTES', [ true, 'Store the captured information in notes. Use \"notes -t http.title\" to view', true ]),\n        OptBool.new('SHOW_TITLES', [ true, 'Show the titles on the console as they are grabbed', true ]),\n        OptString.new('TARGETURI', [true, 'The base path', '/'])\n      ])\n\n    register_advanced_options(\n      [\n        OptString.new('HttpQueryString', [ false, 'The HTTP query string', nil ]),\n        OptBool.new('FollowRedirect', [ false, 'Follow a HTTP redirect', false ]),\n        OptInt.new('FollowRedirectDepth', [false, 'Follow HTTP redirect depth', 1]),\n      ]\n    )\n  end\n\n  def run\n    if !datastore['STORE_NOTES'] && !datastore['SHOW_TITLES']\n      print_error(\"Notes storage is false and titles are not being shown on the console. There isn't much point in running this module.\")\n    else\n      super\n    end\n  end\n\n  def run_host(target_host)\n    begin\n      http_opts = {\n        'uri' => normalize_uri(target_uri.path),\n        'query' => datastore['HttpQueryString']\n      }\n\n      # Send a normal GET request\n      if datastore['FollowRedirect']\n        res = send_request_cgi!(http_opts, datastore['HttpClientTimeout'] || 20, datastore['FollowRedirectDepth'])\n      else\n        res = send_request_cgi(http_opts)\n      end\n\n      # If no response, quit now\n      if res.nil?\n        vprint_error(\"[#{target_host}:#{rport}] No response\")\n        return\n      end\n\n      # Retrieve the headers to capture the Location and Server header\n      # Note that they are case-insensitive but stored in a hash\n      server_header = nil\n      location_header = nil\n      if !res.headers.nil?\n        res.headers.each do |key, val|\n          location_header = val if key.downcase == 'location'\n          server_header  = val if key.downcase == 'server'\n        end\n      else\n        vprint_error(\"[#{target_host}:#{rport}] No HTTP headers\")\n      end\n\n      # If the body is blank, just stop now as there is no chance of a title\n      if res.body.nil?\n        vprint_error(\"[#{target_host}:#{rport}] No webpage body\")\n        return\n      end\n\n      # Very basic, just match the first title tag we come to. If the match fails,\n      # there is no chance that we will have a title\n      rx = %r{<title>[\\n\\t\\s]*(?<title>.+?)[\\s\\n\\t]*</title>}im.match(res.body.to_s)\n      unless rx\n        vprint_error(\"[#{target_host}:#{rport}] No webpage title\")\n        return\n      end\n\n      # Last bit of logic to capture the title\n      rx[:title].strip!\n      if rx[:title] != ''\n        rx_title = Rex::Text.html_decode(rx[:title])\n        if datastore['SHOW_TITLES']\n          print_good(\"[#{target_host}:#{rport}] [C:#{res.code}] [R:#{location_header}] [S:#{server_header}] #{rx_title}\")\n        end\n        if datastore['STORE_NOTES']\n          notedata = { code: res.code, port: rport, server: server_header, title: rx_title, redirect: location_header, uri: datastore['TARGETURI'] }\n          report_note(host: target_host, port: rport, type: \"http.title\", data: notedata, update: :unique_data)\n        end\n      else\n        vprint_error(\"[#{target_host}:#{rport}] No webpage title\")\n      end\n    end\n\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n    rescue ::Timeout::Error, ::Errno::EPIPE\n  end\nend\n"
}