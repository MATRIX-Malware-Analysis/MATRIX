{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--23807c2f-f934-406a-9861-3543e5e579de",
    "created": "2024-08-14T16:30:36.898213Z",
    "modified": "2024-08-14T16:30:36.898217Z",
    "name": "Jenkins-CI Enumeration",
    "description": " This module enumerates a remote Jenkins-CI installation in an unauthenticated manner, including host operating system and Jenkins installation details. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/jenkins_enum.rb",
            "external_id": "jenkins_enum.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n##\n# Some of this code was taken from the \"jboss_vulnscan\" module by: Tyler Krpata\n##\n\n\nrequire 'rexml/document'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Jenkins-CI Enumeration',\n      'Description' => %q{\n        This module enumerates a remote Jenkins-CI installation in an unauthenticated manner, including\n        host operating system and Jenkins installation details.\n      },\n      'Author'      => 'Jeff McCutchan',\n      'License'     => MSF_LICENSE\n      ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [ true,  'The path to the Jenkins-CI application', '/jenkins/' ])\n      ])\n  end\n\n  def run_host(ip)\n    res = send_request_cgi(\n      {\n      'uri'       => target_uri.path,\n      'method'    => 'GET',\n      'ctype'     => 'text/plain',\n    })\n\n    unless res\n      vprint_error(\"No response received\")\n      return\n    end\n\n    unless res.headers.include?('X-Jenkins')\n      vprint_error(\"responded with #{res.code} but does not seem to be Jenkins\")\n      return\n    end\n\n    version = res.headers['X-Jenkins']\n    print_good(\"#{peer} - Jenkins Version #{version}\")\n    report_service(\n      :host  => rhost,\n      :port  => rport,\n      :name  => (ssl ? 'https' : 'http'),\n      :proto => 'tcp'\n    )\n\n    report_web_site(\n      :host  => rhost,\n      :port  => rport,\n      :ssl   => ssl,\n      :info  => \"Jenkins Version - #{version}\"\n    )\n\n    # script - exploit module for this\n    # view/All/newJob - can be exploited manually\n    # asynchPeople - Jenkins users\n    # systemInfo - system information\n    apps = [\n      'script',\n      'view/All/newJob',\n      'asynchPeople/',\n      'systemInfo'\n    ]\n    apps.each do |app|\n      check_app(app)\n    end\n  end\n\n  def check_app(app)\n    uri_path = normalize_uri(target_uri.path, app)\n    res = send_request_cgi({\n      'uri'       => uri_path,\n      'method'    => 'GET',\n      'ctype'     => 'text/plain',\n    })\n    unless res\n      vprint_error(\"Timeout\")\n      return\n    end\n\n    case res.code\n    when 200\n      print_good(\"#{full_uri} - #{uri_path} does not require authentication (200)\")\n      report_note({\n        :type  => \"jenkins_path\",\n        :host  => rhost,\n        :port  => rport,\n        :proto => 'tcp',\n        :data  => \"#{full_uri} - #{uri_path} does not require authentication (200)\",\n        :update => :unique_data\n      })\n      case app\n      when \"systemInfo\"\n        parse_system_info(res.body)\n      when \"script\"\n        report_vuln(\n          :host        => rhost,\n          :port        => rport,\n          :proto       => 'tcp',\n          :sname       => (ssl ? 'https' : 'http'),\n          :name        => \"Jenkins Script-Console Java Execution\",\n          :info        => \"Module #{self.fullname} confirmed access to the Jenkins Script Console with no authentication\"\n        )\n      end\n    when 403\n      print_status(\"#{uri_path} restricted (403)\")\n    when 401\n      print_status(\"#{uri_path} requires authentication (401): #{res.headers['WWW-Authenticate']}\")\n    when 404\n      print_status(\"#{uri_path} not found (404)\")\n    when 301\n      print_status(\"#{uri_path} is redirected (#{res.code}) to #{res.headers['Location']} (not following)\")\n    when 302\n      print_status(\"#{uri_path} is redirected (#{res.code}) to #{res.headers['Location']} (not following)\")\n    else\n      print_status(\"#{uri_path} Don't know how to handle response code #{res.code}\")\n    end\n  end\n\n  def parse_system_info(body)\n    vprint_status(\"Getting useful information from systemInfo\")\n    infos = {\n      \"os.name\"            => nil,\n      \"os.version\"         => nil,\n      \"sun.os.patch.level\" => nil,\n      \"os.arch\"            => nil,\n      \"user.name\"          => nil,\n      \"USERDOMAIN\"         => nil,\n      \"user.home\"          => nil,\n      \"user.language\"      => nil,\n      \"user.country\"       => nil,\n      \"user.timezone\"      => nil,\n      \"COMPUTERNAME\"       => nil,\n      \"SystemDrive\"        => nil,\n      \"TEMP\"               => nil,\n      \"TMP\"                => nil,\n      \"SHELL\"              => nil\n    }\n\n    # remove unclosed tags for REXML\n    body.gsub!('<wbr>', '')\n    body.gsub!('<br>', '')\n    doc = REXML::Document.new(body)\n    tds = doc.get_elements(\"//td\")\n    tds.each_index do |idx|\n      td = tds[idx].get_text.to_s.strip\n      infos[td] = tds[idx+1].get_text.to_s.strip if infos.has_key?(td)\n    end\n\n    fprint = {}\n    jinfo  = {}\n\n    # print out the goodies\n    infos.each do |k, v|\n      next if v.nil?\n      v = v.strip\n      next if v.length == 0\n\n      jinfo[k.gsub(/\\s+/, '_')] = v\n\n      case k\n      when \"os.name\"\n        vprint_line(\"   OS: #{v}\")\n        fprint['os.product'] = v\n      when \"os.version\"\n        vprint_line(\"   OS Version: #{v}\")\n        fprint['os.version'] = v\n      when \"sun.os.patch.level\"\n        vprint_line(\"   Patch Level: #{v}\")\n      when \"os.arch\"\n        vprint_line(\"   Arch: #{v}\")\n        fprint['os.arch'] = v\n      when \"user.name\"\n        vprint_line(\"   User: #{v}\")\n      when \"USERDOMAIN\"\n        vprint_line(\"   Domain: #{v}\")\n        fprint['host.domain'] = v\n      when \"COMPUTERNAME\"\n        vprint_line(\"   Computer Name: #{v}\")\n        fprint['host.name'] = v\n      when \"SystemDrive\"\n        vprint_line(\"   System Drive: #{v}\")\n      when \"SHELL\"\n        vprint_line(\"   Shell: #{v}\")\n      when \"TEMP\"\n        vprint_line(\"   Temp Directory: #{v}\")\n      when \"TMP\"\n        vprint_line(\"   Temp Directory: #{v}\")\n      when \"user.home\"\n        vprint_line(\"   Home Directory: #{v}\")\n      when \"user.language\"\n        vprint_line(\"   Language: #{v}\")\n        fprint['os.language'] = v\n      when \"user.country\"\n        vprint_line(\"   Country: #{v}\")\n      when \"user.timezone\"\n        vprint_line(\"   Timezone: #{v}\")\n      end\n    end\n\n    # Report a fingerprint.match for OS fingerprinting support, tied to this service\n    report_note(:host => rhost, :port => rport, :proto => 'tcp', :ntype => 'fingerprint.match', :data => fprint)\n\n    # Report a jenkins information note for future analysis, tied to this service\n    report_note(:host => rhost, :port => rport, :proto => 'tcp', :ntype => 'jenkins.info', :data => jinfo)\n\n    vprint_line\n  end\nend\n"
}