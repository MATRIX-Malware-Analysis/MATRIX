{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--614798db-3034-4337-9da0-f074f507ea5b",
    "created": "2024-08-14T16:29:00.819001Z",
    "modified": "2024-08-14T16:29:00.819005Z",
    "name": "HTTP Vuln Scanner",
    "description": " This module identifies common vulnerable files or cgis. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/web_vulndb.rb",
            "external_id": "web_vulndb.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::WmapScanServer\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'   \t\t=> 'HTTP Vuln Scanner',\n      'Description'\t=> %q{\n        This module identifies common vulnerable files or cgis.\n      },\n      'Author' \t\t=> [ 'et' ],\n      'License'\t\t=> BSD_LICENSE))\n\n    register_options(\n      [\n        OptString.new('PATH', [ true, \"Original test path\", '/']),\n        OptPath.new('VULNCSV',[ true, \"Path of vulnerabilities csv file to use\" ])\n      ])\n\n    register_advanced_options(\n      [\n        OptInt.new('ErrorCode', [ true,  \"The expected http code for non existant files\", 404]),\n        OptPath.new('HTTP404Sigs',   [ false, \"Path of 404 signatures to use\",\n            File.join(Msf::Config.data_directory, \"wmap\", \"wmap_404s.txt\")\n          ]\n        ),\n        OptBool.new('NoDetailMessages', [ false, \"Do not display detailed test messages\", true ]),\n        OptBool.new('ForceCode', [ false, \"Force detection using HTTP code\", false ]),\n        OptInt.new('TestThreads', [ true, \"Number of test threads\", 25])\n      ])\n\n  end\n\n  # Modify to true if you have sqlmap installed.\n  def wmap_enabled\n    false\n  end\n\n  def run_host(ip)\n    conn = false\n    usecode = datastore['ForceCode']\n\n    tpath = normalize_uri(datastore['PATH'])\n    if tpath[-1,1] != '/'\n      tpath += '/'\n    end\n\n    nt = datastore['TestThreads'].to_i\n    nt = 1 if nt == 0\n\n    dm = datastore['NoDetailMessages']\n\n    queue = []\n\n    File.open(datastore['VULNCSV'], 'rb').each do |testf|\n      queue << testf.strip\n    end\n\n    #\n    # Detect error code\n    #\n    ecode = datastore['ErrorCode'].to_i\n    begin\n      randfile = Rex::Text.rand_text_alpha(5).chomp\n\n      res = send_request_cgi({\n        'uri'  \t\t=>  tpath+randfile,\n        'method'   \t=> 'GET',\n        'ctype'\t\t=> 'text/html'\n      }, 20)\n\n      return if not res\n\n      tcode = res.code.to_i\n\n      # Look for a string we can signature on as well\n      if(tcode >= 200 and tcode <= 299)\n        File.open(datastore['HTTP404Sigs'], 'rb').each do |str|\n          if(res.body.index(str))\n            emesg = str\n            break\n          end\n        end\n\n        if(not emesg)\n          print_status(\"Using first 256 bytes of the response as 404 string\")\n          emesg = res.body[0,256]\n        else\n          print_status(\"Using custom 404 string of '#{emesg}'\")\n        end\n      else\n        ecode = tcode\n        print_status(\"Using code '#{ecode}' as not found.\")\n      end\n\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      conn = false\n    rescue ::Timeout::Error, ::Errno::EPIPE\n    end\n\n\n    while(not queue.empty?)\n      t = []\n      1.upto(nt) do\n        t << framework.threads.spawn(\"Module(#{self.refname})-#{rhost}\", false, queue.shift) do |testf|\n          Thread.current.kill if not testf\n\n          testarr = []\n          testfvuln = \"\"\n          testmesg = \"\"\n          testnote = \"\"\n          foundstr = false\n\n          testarr = testf.split(',')\n\n          testfvuln = testarr[0].to_s\n          testmesg = testarr[1].to_s\n          testnote = testarr[2].to_s\n\n          res = send_request_cgi({\n            'uri'  \t\t=>  tpath+testfvuln,\n            'method'   \t=> 'GET',\n            'ctype'\t\t=> 'text/plain'\n          }, 20)\n\n          if res.nil?\n            print_error(\"Connection timed out\")\n            return\n          end\n\n          if testmesg.empty? or usecode\n            if (res.code.to_i == ecode) or (emesg and res.body.index(emesg))\n              if dm == false\n                print_status(\"NOT Found #{wmap_base_url}#{tpath}#{testfvuln}  #{res.code.to_i}\")\n              end\n            else\n              if res.code.to_i == 400  and ecode != 400\n                print_error(\"Server returned an error code. #{wmap_base_url}#{tpath}#{testfvuln} #{res.code.to_i}\")\n              else\n                print_good(\"FOUND #{wmap_base_url}#{tpath}#{testfvuln} [#{res.code.to_i}] #{testnote}\")\n\n                report_note(\n                  :host\t=> ip,\n                  :proto => 'tcp',\n                  :sname => (ssl ? 'https' : 'http'),\n                  :port\t=> rport,\n                  :type\t=> 'FILE',\n                  :data\t=> \"#{tpath}#{testfvuln} Code: #{res.code}\"\n                )\n              end\n            end\n          else\n            if res and res.body.include?(testmesg)\n              print_good(\"FOUND #{wmap_base_url}#{tpath}#{testfvuln} [#{res.code.to_i}] #{testnote}\")\n\n              report_note(\n                  :host\t=> ip,\n                  :proto => 'tcp',\n                  :sname => (ssl ? 'https' : 'http'),\n                  :port\t=> rport,\n                  :type\t=> 'FILE',\n                  :data\t=> \"#{tpath}#{testfvuln} Code: #{res.code}\"\n              )\n            else\n              if dm == false\n                print_status(\"NOT Found #{wmap_base_url}#{tpath}#{testfvuln}  #{res.code.to_i}\")\n              end\n            end\n          end\n        end\n      end\n      t.map{|x| x.join }\n    end\n  end\nend\n"
}