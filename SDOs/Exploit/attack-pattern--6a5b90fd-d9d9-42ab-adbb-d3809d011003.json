{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6a5b90fd-d9d9-42ab-adbb-d3809d011003",
    "created": "2024-08-14T16:26:30.971496Z",
    "modified": "2024-08-14T16:26:30.9715Z",
    "name": "NTP Protocol Fuzzer",
    "description": "( A simplistic fuzzer for the Network Time Protocol that sends the following probes to understand NTP and look for anomalous NTP behavior:  * All possible combinations of NTP versions and modes, even if not allowed or specified in the RFCs * Short versions of the above * Short, invalid datagrams * Full-size, random datagrams * All possible NTP control messages * All possible NTP private messages  This findings of this fuzzer are not necessarily indicative of bugs let alone vulnerabilities, rather they point out interesting things that might deserve more attention.  Furthermore, this module is not particularly intelligent and there are many more areas of NTP that could be explored, including:  * Warn if the response is 100% identical to the request * Warn if the \"mode\" (if applicable) doesn't align with what we expect * Filter out the 12-byte mode 6 unsupported opcode errors. * Fuzz the control message payload offset/size/etc.  There be bugs )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/fuzzers/ntp/ntp_protocol_fuzzer.rb",
            "external_id": "ntp_protocol_fuzzer.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'securerandom'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Fuzzer\n  include Msf::Exploit::Remote::Udp\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'NTP Protocol Fuzzer',\n      'Description' => %q(\n        A simplistic fuzzer for the Network Time Protocol that sends the\n        following probes to understand NTP and look for anomalous NTP behavior:\n\n        * All possible combinations of NTP versions and modes, even if not\n          allowed or specified in the RFCs\n        * Short versions of the above\n        * Short, invalid datagrams\n        * Full-size, random datagrams\n        * All possible NTP control messages\n        * All possible NTP private messages\n\n        This findings of this fuzzer are not necessarily indicative of bugs,\n        let alone vulnerabilities, rather they point out interesting things\n        that might deserve more attention.  Furthermore, this module is not\n        particularly intelligent and there are many more areas of NTP that\n        could be explored, including:\n\n        * Warn if the response is 100% identical to the request\n        * Warn if the \"mode\" (if applicable) doesn't align with what we expect,\n        * Filter out the 12-byte mode 6 unsupported opcode errors.\n        * Fuzz the control message payload offset/size/etc.  There be bugs\n      ),\n      'Author'      => 'Jon Hart <jon_hart[at]rapid7.com>',\n      'License'     => MSF_LICENSE\n      )\n\n    register_options(\n      [\n        Opt::RPORT(123),\n        OptInt.new('SLEEP', [true, 'Sleep for this many ms between requests', 0]),\n        OptInt.new('WAIT', [true, 'Wait this many ms for responses', 250])\n      ])\n\n    register_advanced_options(\n      [\n        OptString.new('VERSIONS', [false, 'Specific versions to fuzz (csv)', '2,3,4']),\n        OptString.new('MODES', [false, 'Modes to fuzz (csv)']),\n        OptString.new('MODE_6_OPERATIONS', [false, 'Mode 6 operations to fuzz (csv)']),\n        OptString.new('MODE_7_IMPLEMENTATIONS', [false, 'Mode 7 implementations to fuzz (csv)']),\n        OptString.new('MODE_7_REQUEST_CODES', [false, 'Mode 7 request codes to fuzz (csv)'])\n      ])\n  end\n\n  def sleep_time\n    datastore['SLEEP'] / 1000.0\n  end\n\n  def check_and_set(setting)\n    thing = setting.upcase\n    const_name = thing.to_sym\n    var_name = thing.downcase\n    if datastore[thing]\n      instance_variable_set(\"@#{var_name}\", datastore[thing].split(/[^\\d]/).select { |v| !v.empty? }.map { |v| v.to_i })\n      unsupported_things = instance_variable_get(\"@#{var_name}\") - Rex::Proto::NTP.const_get(const_name)\n      fail \"Unsupported #{thing}: #{unsupported_things}\" unless unsupported_things.empty?\n    else\n      instance_variable_set(\"@#{var_name}\", Rex::Proto::NTP.const_get(const_name))\n    end\n  end\n\n  def run_host(ip)\n    # check and set the optional advanced options\n    check_and_set('VERSIONS')\n    check_and_set('MODES')\n    check_and_set('MODE_6_OPERATIONS')\n    check_and_set('MODE_7_IMPLEMENTATIONS')\n    check_and_set('MODE_7_REQUEST_CODES')\n\n    connect_udp\n    fuzz_version_mode(ip, true)\n    fuzz_version_mode(ip, false)\n    fuzz_short(ip)\n    fuzz_random(ip)\n    fuzz_control(ip) if @modes.include?(6)\n    fuzz_private(ip) if @modes.include?(7)\n    disconnect_udp\n  end\n\n  # Sends a series of NTP control messages\n  def fuzz_control(host)\n    @versions.each do |version|\n      print_status(\"#{host}:#{rport} fuzzing version #{version} control messages (mode 6)\")\n      @mode_6_operations.each do |op|\n        request = Rex::Proto::NTP.ntp_control(version, op).to_binary_s\n        what = \"#{request.size}-byte version #{version} mode 6 op #{op} message\"\n        vprint_status(\"#{host}:#{rport} probing with #{request.size}-byte #{what}\")\n        responses = probe(host, datastore['RPORT'].to_i, request)\n        handle_responses(host, request, responses, what)\n        Rex.sleep(sleep_time)\n      end\n    end\n  end\n\n  # Sends a series of NTP private messages\n  def fuzz_private(host)\n    @versions.each do |version|\n      print_status(\"#{host}:#{rport} fuzzing version #{version} private messages (mode 7)\")\n      @mode_7_implementations.each do |implementation|\n        @mode_7_request_codes.each do |request_code|\n          request = Rex::Proto::NTP.ntp_private(version, implementation, request_code, \"\\0\" * 188).to_binary_s\n          what = \"#{request.size}-byte version #{version} mode 7 imp #{implementation} req #{request_code} message\"\n          vprint_status(\"#{host}:#{rport} probing with #{request.size}-byte #{what}\")\n          responses = probe(host, datastore['RPORT'].to_i, request)\n          handle_responses(host, request, responses, what)\n          Rex.sleep(sleep_time)\n        end\n      end\n    end\n  end\n\n  # Sends a series of small, short datagrams, looking for a reply\n  def fuzz_short(host)\n    print_status(\"#{host}:#{rport} fuzzing short messages\")\n    0.upto(4) do |size|\n      request = SecureRandom.random_bytes(size)\n      what = \"short #{request.size}-byte random message\"\n      vprint_status(\"#{host}:#{rport} probing with #{what}\")\n      responses = probe(host, datastore['RPORT'].to_i, request)\n      handle_responses(host, request, responses, what)\n      Rex.sleep(sleep_time)\n    end\n  end\n\n  # Sends a series of random, full-sized datagrams, looking for a reply\n  def fuzz_random(host)\n    print_status(\"#{host}:#{rport} fuzzing random messages\")\n    0.upto(5) do\n      # TODO: is there a better way to pick this size?  Should more than one be tried?\n      request = SecureRandom.random_bytes(48)\n      what = \"random #{request.size}-byte message\"\n      vprint_status(\"#{host}:#{rport} probing with #{what}\")\n      responses = probe(host, datastore['RPORT'].to_i, request)\n      handle_responses(host, request, responses, what)\n      Rex.sleep(sleep_time)\n    end\n  end\n\n  # Sends a series of different version + mode combinations\n  def fuzz_version_mode(host, short)\n    print_status(\"#{host}:#{rport} fuzzing #{short ? 'short ' : nil}version and mode combinations\")\n    @versions.each do |version|\n      @modes.each do |mode|\n        request = Rex::Proto::NTP::NTPGeneric.new\n        request.version = version\n        request.mode = mode\n        unless short\n          # TODO: is there a better way to pick this size?  Should more than one be tried?\n          request.payload = SecureRandom.random_bytes(16)\n        end\n        request = request.to_binary_s\n        what = \"#{request.size}-byte #{short ? 'short ' : nil}version #{version} mode #{mode} message\"\n        vprint_status(\"#{host}:#{rport} probing with #{what}\")\n        responses = probe(host, datastore['RPORT'].to_i, request)\n        handle_responses(host, request, responses, what)\n        Rex.sleep(sleep_time)\n      end\n    end\n  end\n\n  # Sends +message+ to +host+ on UDP port +port+, returning all replies\n  def probe(host, port, message)\n    message = message.to_binary_s if message.respond_to?('to_binary_s')\n    replies = []\n    begin\n      udp_sock.sendto(message, host, port, 0)\n    rescue ::Errno::EISCONN\n      udp_sock.write(message)\n    end\n    reply = udp_sock.recvfrom(65535, datastore['WAIT'] / 1000.0)\n    while reply && reply[1]\n      replies << reply\n      reply = udp_sock.recvfrom(65535, datastore['WAIT'] / 1000.0)\n    end\n    replies\n  end\n\n  def handle_responses(host, request, responses, what)\n    problems = []\n    descriptions = []\n    request = request.to_binary_s if request.respond_to?('to_binary_s')\n    responses.select! { |r| r[1] }\n    return if responses.empty?\n    responses.each do |response|\n      data = response[0]\n      descriptions << Rex::Proto::NTP.describe(data)\n      problems << 'large response' if request.size < data.size\n      ntp_req = Rex::Proto::NTP::NTPGeneric.new.read(request)\n      ntp_resp = Rex::Proto::NTP::NTPGeneric.new.read(data)\n      problems << 'version mismatch' if ntp_req.version != ntp_resp.version\n    end\n\n    problems << 'multiple responses' if responses.size > 1\n    problems.sort!\n    problems.uniq!\n\n    description = descriptions.join(',')\n    if problems.empty?\n      vprint_status(\"#{host}:#{rport} -- Received '#{description}' to #{what}\")\n    else\n      print_good(\"#{host}:#{rport} -- Received '#{description}' to #{what}: #{problems.join(',')}\")\n    end\n  end\nend\n"
}