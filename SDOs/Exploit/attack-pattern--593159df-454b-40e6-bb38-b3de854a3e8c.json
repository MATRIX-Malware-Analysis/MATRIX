{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--593159df-454b-40e6-bb38-b3de854a3e8c",
    "created": "2024-08-14T16:26:36.098889Z",
    "modified": "2024-08-14T16:26:36.098893Z",
    "name": "NetBIOS Information Discovery",
    "description": "Discover host information through NetBIOS",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/netbios/nbname.rb",
            "external_id": "nbname.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::UDPScanner\n\n  def initialize\n    super(\n      'Name'        => 'NetBIOS Information Discovery',\n      'Description' => 'Discover host information through NetBIOS',\n      'Author'      => 'hdm',\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n    [\n      Opt::RPORT(137)\n    ])\n  end\n\n  def scanner_prescan(batch)\n    print_status(\"Sending NetBIOS requests to #{batch[0]}->#{batch[-1]} (#{batch.length} hosts)\")\n    @results = {}\n  end\n\n  def scan_host(ip)\n    scanner_send(create_netbios_status(ip), ip, datastore['RPORT'])\n  end\n\n  def scanner_postscan(batch)\n\n    cnt = 0\n\n    # Perform a second pass based on responsive hosts\n    @results.keys.each do |ip|\n      next if not @results[ip][:name]\n      scanner_send(create_netbios_lookup(@results[ip][:name]), ip, datastore['RPORT'])\n      cnt += 1\n    end\n\n    # Wait for the final replies to trickle in\n    scanner_recv(10) if cnt > 0\n\n    @results.keys.each do |ip|\n\n      host = @results[ip]\n      user = \"\"\n      os   = \"Windows\"\n\n      if (host[:user] and host[:mac] != \"00:00:00:00:00:00\")\n        user = \" User:#{host[:user]}\"\n      end\n\n      if (host[:mac] == \"00:00:00:00:00:00\")\n        os = \"Unix\"\n      end\n\n      names = \"\"\n      if (host[:names])\n        names = \" Names:(\" + host[:names].map{|n| n[0]}.uniq.join(\", \") + \")\"\n      end\n\n      addrs = \"\"\n      if (host[:addrs])\n        addrs = \"Addresses:(\" + host[:addrs].map{|n| n[0]}.uniq.join(\", \") + \")\"\n      end\n\n      if (host[:mac] != \"00:00:00:00:00:00\")\n        report_host(:host => ip, :mac => host[:mac])\n      else\n        report_host(:host => ip)\n      end\n\n      extra = \"\"\n\n      virtual = nil\n      case host[:mac]\n      when /^00:13:07/i\n        virtual = 'ParaVirtual'\n      when /^(00:1C:14|00:50:56|00:05:69|00:0c:29)/i\n        virtual = 'VMWare'\n      when /^00:1C:42/\n        virtual = \"Parallels\"\n      when /^00:18:51/\n        virtual = \"SWsoft Virtuozzo\"\n      when /^00:21:F6/i\n        virtual = 'Virtual Iron'\n      when /^00:16:3e/\n        virtual = 'Xen'\n      when /^(54:52:00|DE:AD:BE)/\n        virtual = 'QEMU (unofficial)'\n      when /^00:24:0B/i\n        virtual = 'Virtual Computer Inc'\n      end\n\n      if (virtual)\n        extra = \"Virtual Machine:#{virtual}\"\n        report_note(\n          :host  => ip,\n          :type  => 'host.virtual_machine',\n          :data  => {:vendor => virtual, :method => 'netbios'}\n        )\n      end\n\n      if (host[:addrs])\n        aliases = []\n        host[:addrs].map{|n| n[0]}.uniq.each do |addr|\n          next if addr == ip\n          aliases << addr\n        end\n\n        if not aliases.empty?\n          report_note(\n            :host  => ip,\n            :proto => 'udp',\n            :port  => 137,\n            :type  => 'netbios.addresses',\n            :data  => {:addresses => aliases}\n          )\n        end\n      end\n\n      print_good(\"#{ip} [#{host[:name]}] OS:#{os}#{user}#{names} #{addrs} Mac:#{host[:mac]} #{extra}\")\n    end\n  end\n\n\n  def scanner_process(data, shost, sport)\n\n    head = data.slice!(0,12)\n\n    xid, flags, quests, answers, auths, adds = head.unpack('n6')\n\n    return if quests != 0\n    return if answers == 0\n\n    qname = data.slice!(0,34)\n    rtype,rclass,rttl,rlen = data.slice!(0,10).unpack('nnNn')\n    buff = data.slice!(0,rlen)\n\n    names = []\n\n    hname = nil\n    uname = nil\n\n    @results[shost] ||= {}\n\n    case rtype\n    when 0x21\n      rcnt = buff.slice!(0,1).unpack(\"C\")[0]\n      1.upto(rcnt) do\n        tname = buff.slice!(0,15).gsub(/\\x00.*/, '').strip\n        ttype = buff.slice!(0,1).unpack(\"C\")[0]\n        tflag = buff.slice!(0,2).unpack('n')[0]\n        names << [ tname, ttype, tflag ]\n        hname = tname if ttype == 0x20\n        uname = tname if ttype == 0x03\n      end\n      maddr = buff.slice!(0,6).unpack(\"C*\").map{|c| \"%.2x\" % c }.join(\":\")\n\n      @results[shost][:names] = names\n      @results[shost][:mac]   = maddr\n\n      if (!hname and @results[shost][:names].length > 0)\n        @results[shost][:name] = @results[shost][:names][0][0]\n      end\n\n      @results[shost][:name] = hname if hname\n      @results[shost][:user] = uname if uname\n\n      inf = ''\n      names.each do |name|\n        inf << name[0]\n        inf << \":<%.2x>\" % name[1]\n        if (name[2] & 0x8000 == 0)\n          inf << \":U :\"\n        else\n          inf << \":G :\"\n        end\n      end\n      inf << maddr\n\n      report_service(\n        :host  => shost,\n        :mac   => (maddr and maddr != '00:00:00:00:00:00') ? maddr : nil,\n        :host_name => (hname) ? hname.downcase : nil,\n        :port  => datastore['RPORT'],\n        :proto => 'udp',\n        :name  => 'netbios',\n        :info  => inf\n      )\n\n    when 0x20\n      1.upto(rlen / 6.0) do\n        tflag = buff.slice!(0,2).unpack('n')[0]\n        taddr = buff.slice!(0,4).unpack(\"C*\").join(\".\")\n        names << [ taddr, tflag ]\n      end\n      @results[shost][:addrs] = names\n    end\n  end\n\n  def create_netbios_status(ip)\n    data =\n    [rand(0xffff)].pack('n')+\n    \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\"+\n    \"\\x00\\x00\\x20\\x43\\x4b\\x41\\x41\\x41\"+\n    \"\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\"+\n    \"\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\"+\n    \"\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\"+\n    \"\\x41\\x41\\x41\\x00\\x00\\x21\\x00\\x01\"\n\n    return data\n  end\n\n  def create_netbios_lookup(name)\n    name = [name].pack(\"A15\") + \"\\x00\"\n\n    data =\n    [rand(0xffff)].pack('n') +\n    \"\\x01\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\" +\n    \"\\x20\" +\n    Rex::Proto::SMB::Utils.nbname_encode(name) +\n    \"\\x00\" +\n    \"\\x00\\x20\\x00\\x01\"\n\n    return data\n  end\nend\n"
}