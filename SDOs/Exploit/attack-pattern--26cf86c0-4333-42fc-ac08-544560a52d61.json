{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--26cf86c0-4333-42fc-ac08-544560a52d61",
    "created": "2024-08-14T16:32:57.989266Z",
    "modified": "2024-08-14T16:32:57.98927Z",
    "name": "BNAT Scanner",
    "description": " This module is a scanner which can detect Broken NAT (network address translation) implementations, which could result in an inability to reach ports on remote machines. Typically, these ports will appear in nmap scans as 'filtered'/'closed'. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/bnat/bnat_scan.rb",
            "external_id": "bnat_scan.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/claudijd/bnat"
        },
        {
            "source_name": "reference",
            "url": "http://www.slideshare.net/claudijd/dc-skytalk-bnat-hijacking-repairing-broken-communication-channels"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Scanner\n  include Msf::Exploit::Capture\n\n  def initialize\n    super(\n      'Name'         => 'BNAT Scanner',\n      'Description'  => %q{\n          This module is a scanner which can detect Broken NAT (network address translation)\n        implementations, which could result in an inability to reach ports on remote\n        machines. Typically, these ports will appear in nmap scans as 'filtered'/'closed'.\n        },\n      'Author'       =>\n        [\n          'bannedit',\n          'Jonathan Claudius <jclaudius[at]trustwave.com>',\n        ],\n      'License'      => MSF_LICENSE,\n      'References'   =>\n        [\n          [ 'URL', 'https://github.com/claudijd/bnat'],\n          [ 'URL', 'http://www.slideshare.net/claudijd/dc-skytalk-bnat-hijacking-repairing-broken-communication-channels']\n        ]\n    )\n\n    register_options(\n        [\n          OptString.new('PORTS', [true, \"Ports to scan (e.g. 22-25,80,110-900)\", \"21,22,23,80,443\"]),\n          OptString.new('INTERFACE', [true, \"The name of the interface\", \"eth0\"]),\n          OptInt.new('TIMEOUT', [true, \"The reply read timeout in milliseconds\", 500])\n        ])\n\n    deregister_options('FILTER','PCAPFILE','SNAPLEN')\n\n  end\n\n  def probe_reply(pcap, to)\n    reply = nil\n    begin\n      Timeout.timeout(to) do\n        pcap.each do |r|\n          pkt = PacketFu::Packet.parse(r)\n          next unless pkt.is_tcp?\n          reply = pkt\n          break\n        end\n      end\n      rescue Timeout::Error\n    end\n    return reply\n  end\n\n  def generate_probe(ip)\n    ftypes = %w{windows, linux, freebsd}\n    @flavor = ftypes[rand(ftypes.length)]\n    config = PacketFu::Utils.whoami?(:iface => datastore['INTERFACE'])\n    p = PacketFu::TCPPacket.new(:config => config)\n    p.ip_daddr = ip\n    p.tcp_flags.syn = 1\n    return p\n  end\n\n  def run_host(ip)\n    open_pcap\n\n    to = (datastore['TIMEOUT'] || 500).to_f / 1000.0\n\n    p = generate_probe(ip)\n    pcap = self.capture\n\n    ports = Rex::Socket.portspec_crack(datastore['PORTS'])\n\n    if ports.empty?\n      raise Msf::OptionValidateError.new(['PORTS'])\n    end\n\n    ports.each_with_index do |port,i|\n      p.tcp_dst = port\n      p.tcp_src = rand(64511)+1024\n      p.tcp_seq = rand(64511)+1024\n      p.recalc\n\n      ackbpf = \"tcp [8:4] == 0x#{(p.tcp_seq + 1).to_s(16)}\"\n      pcap.setfilter(\"tcp and tcp[13] == 18 and not host #{ip} and src port #{p.tcp_dst} and dst port #{p.tcp_src} and #{ackbpf}\")\n      break unless capture_sendto(p, ip)\n      reply = probe_reply(pcap, to)\n      next if reply.nil?\n\n      print_status(\"[BNAT RESPONSE] Requested IP: #{ip} Responding IP: #{reply.ip_saddr} Port: #{reply.tcp_src}\")\n    end\n\n    close_pcap\n  end\nend\n"
}