{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8c6d6818-14f5-4641-aee9-0fa8a25751c0",
    "created": "2024-08-14T16:26:30.97255Z",
    "modified": "2024-08-14T16:26:30.972554Z",
    "name": "Simple FTP Client Fuzzer",
    "description": " This module will serve an FTP server and perform FTP client interaction fuzzing ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/fuzzers/ftp/client_ftp.rb",
            "external_id": "client_ftp.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.corelan.be:8800/index.php/2010/10/12/death-of-an-ftp-client/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n##\n# Fuzzer written by corelanc0d3r - <peter.ve [at] corelan.be>\n# http://www.corelan.be:8800/index.php/2010/10/12/death-of-an-ftp-client/\n#\n##\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Exploit::Remote::TcpServer\n\n  def initialize()\n    super(\n      'Name'           => 'Simple FTP Client Fuzzer',\n      'Description'    => %q{\n        This module will serve an FTP server and perform FTP client interaction fuzzing\n      },\n      'Author'         => [ 'corelanc0d3r <peter.ve[at]corelan.be>' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'URL', 'http://www.corelan.be:8800/index.php/2010/10/12/death-of-an-ftp-client/' ],\n        ]\n      )\n    register_options(\n      [\n      OptPort.new('SRVPORT', [ true, \"The local port to listen on.\", 21 ]),\n      OptString.new('FUZZCMDS', [ true, \"Comma separated list of commands to fuzz (Uppercase).\", \"LIST,NLST,LS,RETR\", nil, /(?:[A-Z]+,?)+/ ]),\n      OptInt.new('STARTSIZE', [ true, \"Fuzzing string startsize.\",1000]),\n      OptInt.new('ENDSIZE', [ true, \"Max Fuzzing string size.\",200000]),\n      OptInt.new('STEPSIZE', [ true, \"Increment fuzzing string each attempt.\",1000]),\n      OptBool.new('RESET', [ true, \"Reset fuzzing values after client disconnects with QUIT cmd.\",true]),\n      OptString.new('WELCOME', [ true, \"FTP Server welcome message.\",\"Evil FTP Server Ready\"]),\n      OptBool.new('CYCLIC', [ true, \"Use Cyclic pattern instead of A's (fuzzing payload).\",true]),\n      OptBool.new('ERROR', [ true, \"Reply with error codes only\",false]),\n      OptBool.new('EXTRALINE', [ true, \"Add extra CRLF's in response to LIST\",true])\n      ])\n  end\n\n\n  # Not compatible today\n  def support_ipv6?\n    false\n  end\n\n  def setup\n    super\n    @state = {}\n  end\n\n  def run\n    @fuzzsize=datastore['STARTSIZE'].to_i\n    exploit()\n  end\n\n  # Handler for new FTP client connections\n  def on_client_connect(c)\n    @state[c] = {\n      :name => \"#{c.peerhost}:#{c.peerport}\",\n      :ip   => c.peerhost,\n      :port => c.peerport,\n      :user => nil,\n      :pass => nil\n    }\n    # set up an active data port on port 20\n    print_status(\"Client connected : \" + c.peerhost)\n    active_data_port_for_client(c, 20)\n    send_response(c,\"\",\"WELCOME\",220,\" \"+datastore['WELCOME'])\n    # from this point forward, on_client_data() will take over\n  end\n\n  def on_client_close(c)\n    @state.delete(c)\n  end\n\n  # Active and Passive data connections\n  def passive_data_port_for_client(c)\n    @state[c][:mode] = :passive\n    if(not @state[c][:passive_sock])\n      s = Rex::Socket::TcpServer.create(\n        'LocalHost' => '0.0.0.0',\n        'LocalPort' => 0,\n        'Context'   => { 'Msf' => framework, 'MsfExploit' => self }\n      )\n      dport = s.getsockname[2]\n      @state[c][:passive_sock] = s\n      @state[c][:passive_port] = dport\n      print_status(\" - Set up passive data port #{dport}\")\n    end\n    @state[c][:passive_port]\n  end\n\n\n  def active_data_port_for_client(c,port)\n    @state[c][:mode] = :active\n    connector = Proc.new {\n      host = c.peerhost.dup\n      sock = Rex::Socket::Tcp.create(\n        'PeerHost' => host,\n        'PeerPort' => port,\n        'Context'   => { 'Msf' => framework, 'MsfExploit' => self }\n      )\n    }\n    @state[c][:active_connector] = connector\n    @state[c][:active_port]      = port\n    print_status(\" - Set up active data port #{port}\")\n  end\n\n\n  def establish_data_connection(c)\n    print_status(\" - Establishing #{@state[c][:mode]} data connection\")\n    begin\n    Timeout.timeout(20) do\n      if(@state[c][:mode] == :active)\n        return @state[c][:active_connector].call()\n      end\n      if(@state[c][:mode] == :passive)\n        return @state[c][:passive_sock].accept\n      end\n    end\n    print_status(\" - Data connection active\")\n    rescue ::Exception => e\n      print_error(\"Failed to establish data connection: #{e.class} #{e}\")\n    end\n    nil\n  end\n\n  # FTP Client-to-Server Command handlers\n  def on_client_data(c)\n    # get the client data\n    data = c.get_once\n    return if not data\n    # split data into command and arguments\n    cmd,arg = data.strip.split(/\\s+/, 2)\n    arg ||= \"\"\n\n    return if not cmd\n    # convert commands to uppercase and strip spaces\n    case cmd.upcase.strip\n\n    when 'USER'\n      @state[c][:user] = arg\n      send_response(c,arg,\"USER\",331,\" User name okay, need password\")\n      return\n\n    when 'PASS'\n      @state[c][:pass] = arg\n      send_response(c,arg,\"PASS\",230,\"-Password accepted.\\r\\n230 User logged in.\")\n      return\n\n    when 'QUIT'\n      if (datastore['RESET'])\n        print_status(\"Resetting fuzz settings\")\n        @fuzzsize = datastore['STARTSIZE']\n        @stepsize = datastore['STEPSIZE']\n      end\n      print_status(\"** Client disconnected **\")\n      send_response(c,arg,\"QUIT\",221,\" User logged out\")\n      return\n\n    when 'SYST'\n      send_response(c,arg,\"SYST\",215,\" UNIX Type: L8\")\n      return\n\n    when 'TYPE'\n      send_response(c,arg,\"TYPE\",200,\" Type set to #{arg}\")\n      return\n\n    when 'CWD'\n      send_response(c,arg,\"CWD\",250,\" CWD Command successful\")\n      return\n\n    when 'PWD'\n      send_response(c,arg,\"PWD\",257,\" \\\"/\\\" is current directory.\")\n      return\n\n    when 'REST'\n      send_response(c,arg,\"REST\",200,\" OK\")\n      return\n\n    when 'XPWD'\n      send_response(c,arg,\"PWD\",257,\" \\\"/\\\" is current directory\")\n      return\n\n    when 'SIZE'\n      send_response(c,arg,\"SIZE\",213,\" 1\")\n      return\n\n    when 'MDTM'\n      send_response(c,arg,\"MDTM\",213,\" #{Time.now.strftime(\"%Y%m%d%H%M%S\")}\")\n      return\n\n    when 'CDUP'\n      send_response(c,arg,\"CDUP\",257,\" \\\"/\\\" is current directory\")\n      return\n\n    when 'PORT'\n      port = arg.split(',')[4,2]\n      if(not port and port.length == 2)\n        c.put(\"500 Illegal PORT command.\\r\\n\")\n        return\n      end\n      port = port.map{|x| x.to_i}.pack('C*').unpack('n')[0]\n      active_data_port_for_client(c, port)\n      send_response(c,arg,\"PORT\",200,\" PORT command successful\")\n      return\n\n    when 'PASV'\n      print_status(\"Handling #{cmd.upcase} command\")\n      daddr = Rex::Socket.source_address(c.peerhost)\n      dport = passive_data_port_for_client(c)\n      @state[c][:daddr] = daddr\n      @state[c][:dport] = dport\n      pasv  = (daddr.split('.') + [dport].pack('n').unpack('CC')).join(',')\n      dofuzz = fuzz_this_cmd(\"PASV\")\n      code = 227\n      if datastore['ERROR']\n        code = 557\n      end\n      if (dofuzz==1)\n        print_status(\" * Fuzzing response for PASV, payload length #{@fuzzdata.length}\")\n        send_response(c,arg,\"PASV\",code,\" Entering Passive Mode (#{@fuzzdata},1,1,1,1,1)\\r\\n\")\n        incr_fuzzsize()\n      else\n        send_response(c,arg,\"PASV\",code,\" Entering Passive Mode (#{pasv})\")\n      end\n      return\n\n    when /^(LIST|NLST|LS)$/\n      # special case - requires active/passive connection\n      print_status(\"Handling #{cmd.upcase} command\")\n      conn = establish_data_connection(c)\n      if(not conn)\n        c.put(\"425 Can't build data connection\\r\\n\")\n        return\n      end\n      print_status(\" - Data connection set up\")\n      code = 150\n      if datastore['ERROR']\n        code = 550\n      end\n      c.put(\"#{code} Here comes the directory listing.\\r\\n\")\n      code = 226\n      if datastore['ERROR']\n        code = 550\n      end\n      c.put(\"#{code} Directory send ok.\\r\\n\")\n      strfile = \"passwords.txt\"\n      strfolder = \"Secret files\"\n      dofuzz = fuzz_this_cmd(\"LIST\")\n      if (dofuzz==1)\n        strfile = @fuzzdata + \".txt\"\n        strfolder = @fuzzdata\n        paylen = @fuzzdata.length\n        print_status(\"* Fuzzing response for LIST, payload length #{paylen}\")\n        incr_fuzzsize()\n      end\n      print_status(\" - Sending directory list via data connection\")\n      dirlist = \"\"\n      if datastore['EXTRALINE']\n        extra = \"\\r\\n\"\n      else\n        extra = \"\"\n      end\n      dirlist = \"drwxrwxrwx    1 100      0           11111 Jun 11 21:10 #{strfolder}\\r\\n\" + extra\n      dirlist << \"-rw-rw-r--    1 1176     1176         1060 Aug 16 22:22 #{strfile}\\r\\n\" + extra\n      conn.put(\"total 2\\r\\n\"+dirlist)\n      conn.close\n      return\n\n    when 'RETR'\n      # special case - requires active/passive connection\n      print_status(\"Handling #{cmd.upcase} command\")\n      conn = establish_data_connection(c)\n      if(not conn)\n        c.put(\"425 Can't build data connection\\r\\n\")\n        return\n      end\n      print_status(\" - Data connection set up\")\n      strcontent = \"blahblahblah\"\n      dofuzz = fuzz_this_cmd(\"LIST\")\n      if (dofuzz==1)\n        strcontent = @fuzzdata\n        paylen = @fuzzdata.length\n        print_status(\"* Fuzzing response for RETR, payload length #{paylen}\")\n        incr_fuzzsize()\n      end\n      c.put(\"150 Opening BINARY mode data connection #{strcontent}\\r\\n\")\n      print_status(\" - Sending data via data connection\")\n      conn.put(strcontent)\n      c.put(\"226 Transfer complete\\r\\n\")\n      conn.close\n      return\n\n    when /^(STOR|MKD|REM|DEL|RMD)$/\n      send_response(c,arg,cmd.upcase,500,\" Access denied\")\n      return\n\n    when 'FEAT'\n      send_response(c,arg,\"FEAT\",\"\",\"211-Features:\\r\\n211 End\")\n      return\n\n    when 'HELP'\n      send_response(c,arg,\"HELP\",214,\" Syntax: #{arg} - (#{arg}-specific commands)\")\n\n    when 'SITE'\n      send_response(c,arg,\"SITE\",200,\" OK\")\n      return\n\n    when 'NOOP'\n      send_response(c,arg,\"NOOP\",200,\" OK\")\n      return\n\n    when 'ABOR'\n      send_response(c,arg,\"ABOR\",225,\" Abor command successful\")\n      return\n\n    when 'ACCT'\n      send_response(c,arg,\"ACCT\",200,\" OK\")\n      return\n\n    when 'RNFR'\n      send_response(c,arg,\"RNRF\",350,\" File.exist\")\n      return\n\n    when 'RNTO'\n      send_response(c,arg,\"RNTO\",350,\" File.exist\")\n      return\n    else\n      send_response(c,arg,cmd.upcase,200,\" Command not understood\")\n      return\n    end\n    return\n  end\n\n  # Fuzzer functions\n\n  # Do we need to fuzz this command ?\n  def fuzz_this_cmd(cmd)\n    @fuzzcommands = datastore['FUZZCMDS'].split(\",\")\n    fuzzme = 0\n    @fuzzcommands.each do |thiscmd|\n      if ((cmd.upcase == thiscmd.upcase) || (thiscmd==\"*\")) && (fuzzme==0)\n        fuzzme = 1\n      end\n    end\n    if fuzzme==1\n      # should we use a cyclic pattern, or just A's ?\n      if datastore['CYCLIC']\n        @fuzzdata = Rex::Text.pattern_create(@fuzzsize)\n      else\n        @fuzzdata = \"A\" * @fuzzsize\n      end\n    end\n    return fuzzme\n  end\n\n  def incr_fuzzsize\n    @stepsize = datastore['STEPSIZE'].to_i\n    @fuzzsize = @fuzzsize + @stepsize\n    print_status(\"(i) Setting next payload size to #{@fuzzsize}\")\n    if (@fuzzsize > datastore['ENDSIZE'].to_i)\n      @fuzzsize = datastore['ENDSIZE'].to_i\n    end\n  end\n\n\n  # Send data back to the server\n  def send_response(c,arg,cmd,code,msg)\n    if arg.length > 40\n      showarg = arg[0,40] + \"...\"\n    else\n      showarg = arg\n    end\n    if cmd.length > 40\n      showcmd = cmd[0,40] + \"...\"\n    else\n      showcmd = cmd\n    end\n    print_status(\"Sending response for '#{showcmd}' command, arg #{showarg}\")\n    dofuzz = fuzz_this_cmd(cmd)\n    ## Fuzz this command ?  (excluding PASV, which is handled in the command handler)\n    if (dofuzz==1) && (cmd.upcase != \"PASV\")\n      paylen = @fuzzdata.length\n      print_status(\"* Fuzzing response for #{cmd.upcase}, payload length #{paylen}\")\n      if datastore['ERROR']\n        code = \"550 \"\n      end\n      if cmd==\"FEAT\"\n        @fuzzdata = \"211-Features:\\r\\n \"+@fuzzdata+\"\\r\\n211 End\"\n      end\n      if cmd==\"PWD\"\n        @fuzzdata = \"  \\\"/\"+@fuzzdata+\"\\\" is current directory\"\n      end\n      cmsg = code.to_s + \" \" + @fuzzdata\n      c.put(\"#{cmsg}\\r\\n\")\n      print_status(\"* Fuzz data sent\")\n      incr_fuzzsize()\n    else\n      # Do not fuzz\n      cmsg = code.to_s + msg\n      cmsg = cmsg.strip\n      c.put(\"#{cmsg}\\r\\n\")\n    end\n    return\n  end\nend\n"
}