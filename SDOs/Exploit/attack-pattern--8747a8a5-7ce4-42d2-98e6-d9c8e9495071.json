{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8747a8a5-7ce4-42d2-98e6-d9c8e9495071",
    "created": "2024-08-14T16:27:50.679831Z",
    "modified": "2024-08-14T16:27:50.679835Z",
    "name": "Portmapper Amplification Scanner",
    "description": " This module can be used to discover Portmapper services which can be used in an amplification DDoS attack against a third party. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/portmap/portmap_amp.rb",
            "external_id": "portmap_amp.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.cisa.gov/uscert/ncas/alerts/TA14-017A"
        },
        {
            "source_name": "reference",
            "url": "http://blog.level3.com/security/a-new-ddos-reflection-attack-portmapper-an-early-warning-to-the-industry/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::UDPScanner\n  include Msf::Auxiliary::DRDoS\n\n  def initialize\n    super(\n      'Name'        => 'Portmapper Amplification Scanner',\n      'Description' => %q{\n        This module can be used to discover Portmapper services which can be used in an\n        amplification DDoS attack against a third party.\n      },\n      'Author'      => ['xistence <xistence[at]0x90.nl>'],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          ['CVE', '2013-5211'], # see also scanner/ntp/ntp_monlist.rb\n          ['URL', 'https://www.cisa.gov/uscert/ncas/alerts/TA14-017A'],\n          ['URL', 'http://blog.level3.com/security/a-new-ddos-reflection-attack-portmapper-an-early-warning-to-the-industry/']\n        ],\n    )\n\n    register_options( [\n      Opt::RPORT(111),\n    ])\n  end\n\n  def rport\n    datastore['RPORT']\n  end\n\n  def xid_summary\n    @xid_summary ||= [Rex::Text::rand_text_numeric(8).to_i].pack('N')\n  end\n\n  def xid_dump\n    @xid_dump ||= [Rex::Text::rand_text_numeric(8).to_i].pack('N')\n  end\n\n  def xid_metrics\n    @xid_metrics ||= [Rex::Text::rand_text_numeric(8).to_i].pack('N')\n  end\n\n  def setup\n    super\n\n    # RPC DUMP (Program version: 3) request: rpcinfo -T udp -s <IP>\n    @portmap_summary = ''\n    @portmap_summary << xid_summary # Random ID\n    @portmap_summary << \"\\x00\\x00\\x00\\x00\" # Message Type: 0 (Call)\n    @portmap_summary << \"\\x00\\x00\\x00\\x02\" # RPC Version: 2\n    @portmap_summary << \"\\x00\\x01\\x86\\xa0\" # Program: Portmap (10000)\n    @portmap_summary << \"\\x00\\x00\\x00\\x03\" # Program version: 3\n    @portmap_summary << \"\\x00\\x00\\x00\\x04\" # Procedure: DUMP (4)\n    @portmap_summary << \"\\x00\\x00\\x00\\x00\" # Credentials Flavor: AUTH_NULL (0)\n    @portmap_summary << \"\\x00\\x00\\x00\\x00\" # Credentials Length: 0\n    @portmap_summary << \"\\x00\\x00\\x00\\x00\" # Verifier Flavor: AUTH_NULL (0)\n    @portmap_summary << \"\\x00\\x00\\x00\\x00\" # Verifier Length: 0\n\n    # RPC DUMP (Program version: 2) request: rpcinfo -T udp -p <IP>\n    @portmap_dump = ''\n    @portmap_dump << xid_dump # Random ID\n    @portmap_dump << \"\\x00\\x00\\x00\\x00\" # Message Type: 0 (Call)\n    @portmap_dump << \"\\x00\\x00\\x00\\x02\" # RPC Version: 2\n    @portmap_dump << \"\\x00\\x01\\x86\\xa0\" # Program: Portmap (10000)\n    @portmap_dump << \"\\x00\\x00\\x00\\x02\" # Program version: 2\n    @portmap_dump << \"\\x00\\x00\\x00\\x04\" # Procedure: DUMP (4)\n    @portmap_dump << \"\\x00\\x00\\x00\\x00\" # Credentials Flavor: AUTH_NULL (0)\n    @portmap_dump << \"\\x00\\x00\\x00\\x00\" # Credentials Length: 0\n    @portmap_dump << \"\\x00\\x00\\x00\\x00\" # Verifier Flavor: AUTH_NULL (0)\n    @portmap_dump << \"\\x00\\x00\\x00\\x00\" # Verifier Length: 0\n\n    # RPC GETSTAT request: rpcinfo -T udp -m <IP>\n    @portmap_metrics = ''\n    @portmap_metrics << xid_metrics # Random ID\n    @portmap_metrics << \"\\x00\\x00\\x00\\x00\" # Message Type: 0 (Call)\n    @portmap_metrics << \"\\x00\\x00\\x00\\x02\" # RPC Version: 2\n    @portmap_metrics << \"\\x00\\x01\\x86\\xa0\" # Program: Portmap (10000)\n    @portmap_metrics << \"\\x00\\x00\\x00\\x04\" # Program version: 4\n    @portmap_metrics << \"\\x00\\x00\\x00\\x0c\" # Procedure: GETSTAT (12)\n    @portmap_metrics << \"\\x00\\x00\\x00\\x00\" # Credentials Flavor: AUTH_NULL (0)\n    @portmap_metrics << \"\\x00\\x00\\x00\\x00\" # Credentials Length: 0\n    @portmap_metrics << \"\\x00\\x00\\x00\\x00\" # Verifier Flavor: AUTH_NULL (0)\n    @portmap_metrics << \"\\x00\\x00\\x00\\x00\" # Verifier Length: 0\n  end\n\n  def scanner_prescan(batch)\n    print_status(\"Sending Portmap RPC probes to #{batch[0]}->#{batch[-1]} (#{batch.length} hosts)\")\n    @results_summary = {}\n    @results_dump = {}\n    @results_metrics = {}\n  end\n\n  def scan_host(ip)\n    if spoofed?\n      datastore['ScannerRecvWindow'] = 0\n      scanner_spoof_send(@portmap_summary, ip, rport, datastore['SRCIP'], datastore['NUM_REQUESTS'])\n      scanner_spoof_send(@portmap_dump, ip, rport, datastore['SRCIP'], datastore['NUM_REQUESTS'])\n      scanner_spoof_send(@portmap_metrics, ip, rport, datastore['SRCIP'], datastore['NUM_REQUESTS'])\n    else\n      scanner_send(@portmap_summary, ip, rport)\n      scanner_send(@portmap_dump, ip, rport)\n      scanner_send(@portmap_metrics, ip, rport)\n    end\n  end\n\n  def scanner_process(data, shost, sport)\n    if data =~ /#{@xid_summary}\\x00\\x00\\x00\\x01/\n      @results_summary[shost] ||= []\n      @results_summary[shost] << data\n    elsif data =~ /#{@xid_metrics}\\x00\\x00\\x00\\x01/\n      @results_metrics[shost] ||= []\n      @results_metrics[shost] << data\n    elsif data =~ /#{@xid_dump}\\x00\\x00\\x00\\x01/\n      @results_dump[shost] ||= []\n      @results_dump[shost] << data\n    else\n      vprint_error(\"Skipping #{data.size}-byte non-Portmap response from #{shost}:#{sport}\")\n    end\n  end\n\n  # Called after the scan block\n  def scanner_postscan(batch)\n    @results_summary.keys.each do |k|\n      response_map_summary = { @portmap_summary => @results_summary[k] }\n      what = 'Portmap RPC DUMP (Program version: 3) amplification'\n      report_result(k, what, response_map_summary)\n    end\n\n    @results_dump.keys.each do |k|\n      response_map_dump = { @portmap_dump => @results_dump[k] }\n      what = 'Portmap RPC DUMP (Program version: 2) amplification'\n      report_result(k, what, response_map_dump)\n    end\n\n    @results_metrics.keys.each do |k|\n      response_map_metrics = { @portmap_summary => @results_metrics[k] }\n      what = 'Portmap RPC GETSTAT amplification'\n      report_result(k, what, response_map_metrics)\n    end\n  end\n\n  def report_result(host, attack, map)\n    report_service(\n      host: host,\n      proto: 'udp',\n      port: rport,\n      name: 'portmap'\n    )\n\n    peer = \"#{host}:#{rport}\"\n    vulnerable, proof = prove_amplification(map)\n    if vulnerable\n      print_good(\"#{peer} - Vulnerable to #{attack}: #{proof}\")\n      report_vuln(\n        host: host,\n        port: rport,\n        proto: 'udp',\n        name: attack,\n        refs: references\n      )\n    else\n      vprint_status(\"#{peer} - Not vulnerable to #{attack}: #{proof}\")\n    end\n  end\nend\n\n\n"
}