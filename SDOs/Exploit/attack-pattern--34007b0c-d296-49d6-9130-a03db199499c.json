{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--34007b0c-d296-49d6-9130-a03db199499c",
    "created": "2024-08-14T16:22:00.812521Z",
    "modified": "2024-08-14T16:22:00.812525Z",
    "name": "DNS Spoofing Helper Service",
    "description": " This module provides a DNS service that returns TXT records indicating information about the querying service. Based on Dino Dai Zovi DNS code from Karma.  ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/dns/spoofhelper.rb",
            "external_id": "spoofhelper.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'resolv'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n\n\n  def initialize\n    super(\n      'Name'        => 'DNS Spoofing Helper Service',\n      'Description'    => %q{\n        This module provides a DNS service that returns TXT\n      records indicating information about the querying service.\n      Based on Dino Dai Zovi DNS code from Karma.\n\n      },\n      'Author'      => ['hdm', 'ddz'],\n      'License'     => MSF_LICENSE,\n      'Actions'     =>\n        [\n          [ 'Service', 'Description' => 'Run DNS spoofing server' ]\n        ],\n      'PassiveActions' =>\n        [\n          'Service'\n        ],\n      'DefaultAction'  => 'Service'\n    )\n\n    register_options(\n      [\n        OptAddress.new('SRVHOST',   [ true, \"The local host to listen on.\", '0.0.0.0' ]),\n        OptPort.new('SRVPORT',      [ true, \"The local port to listen on.\", 53 ]),\n      ])\n  end\n\n\n  def run\n    @targ = datastore['TARGETHOST']\n\n    if(@targ and @targ.strip.length == 0)\n      @targ = nil\n    end\n\n    @port = datastore['SRVPORT'].to_i\n\n    # MacOS X workaround\n    ::Socket.do_not_reverse_lookup = true\n\n    @sock = ::UDPSocket.new()\n    @sock.setsockopt(::Socket::SOL_SOCKET, ::Socket::SO_REUSEADDR, 1)\n    @sock.bind(datastore['SRVHOST'], @port)\n    @run = true\n\n    # Wrap in exception handler\n    begin\n      while @run\n        reply = false\n        packet, addr = @sock.recvfrom(65535)\n        if (packet.length == 0)\n          break\n        end\n\n        names = []\n        request = Resolv::DNS::Message.decode(packet)\n\n        request.each_question {|name, typeclass|\n          tc_s = typeclass.to_s().gsub(/^Resolv::DNS::Resource::/, \"\")\n\n          request.qr = 1\n          request.ra = 1\n\n          names << \"IN #{tc_s} #{name}\"\n          case tc_s\n          when 'IN::TXT'\n            print_status(\"#{Time.now} PASSED #{addr[3]}:#{addr[1]} XID #{request.id} #{name}\")\n            answer = Resolv::DNS::Resource::IN::TXT.new(\"#{addr[3]}:#{addr[1]} #{names.join(\",\")}\")\n            request.add_answer(name, 1, answer)\n            reply = true\n          end\n        }\n\n        if(reply)\n          @sock.send(request.encode(), 0, addr[3], addr[1])\n        else\n          print_status(\"#{Time.now} IGNORE #{addr[3]}:#{addr[1]} XID #{request.id} #{names.join(\",\")}\")\n        end\n      end\n\n    # Make sure the socket gets closed on exit\n    rescue ::Exception => e\n      print_error(\"spoofhelper: #{e.class} #{e} #{e.backtrace}\")\n    ensure\n      @sock.close\n    end\n  end\nend\n"
}