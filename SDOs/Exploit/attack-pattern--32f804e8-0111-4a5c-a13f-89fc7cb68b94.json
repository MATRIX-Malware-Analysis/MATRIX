{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--32f804e8-0111-4a5c-a13f-89fc7cb68b94",
    "created": "2024-08-14T16:22:57.17491Z",
    "modified": "2024-08-14T16:22:57.174914Z",
    "name": "Kerberos keytab utilities",
    "description": " Utilities for interacting with keytab files, which can store the hashed passwords of one or more principals.  Discovered keytab files can be used to generate Kerberos Ticket Granting Tickets, or bruteforced offline.  Keytab files can be also useful for decrypting Kerberos traffic using Wireshark dissectors including the krbtgt encrypted blobs if the AES password hash is used. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/kerberos/keytab.rb",
            "external_id": "keytab.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Kerberos keytab utilities',\n        'Description' => %q{\n          Utilities for interacting with keytab files, which can store the hashed passwords of one or\n          more principals.\n\n          Discovered keytab files can be used to generate Kerberos Ticket Granting Tickets, or bruteforced\n          offline.\n\n          Keytab files can be also useful for decrypting Kerberos traffic using Wireshark dissectors,\n          including the krbtgt encrypted blobs if the AES password hash is used.\n        },\n        'Author' => [\n          'alanfoster' # Metasploit Module\n        ],\n        'References' => [\n        ],\n        'License' => MSF_LICENSE,\n        'Notes' => {\n          'Stability' => [],\n          'SideEffects' => [],\n          'Reliability' => []\n        },\n        'Actions' => [\n          ['LIST', { 'Description' => 'List the entries in the keytab file' }],\n          ['ADD', { 'Description' => 'Add a new entry to the keytab file' }],\n          ['EXPORT', { 'Description' => 'Export the current database creds to the keytab file' }]\n        ],\n        'DefaultAction' => 'LIST',\n        'DefaultOptions' => {\n          'VERBOSE' => true\n        }\n      )\n    )\n\n    supported_encryption_names = ['ALL']\n    supported_encryption_names += Rex::Proto::Kerberos::Crypto::Encryption::SUPPORTED_ENCRYPTIONS\n                                  .map { |id| Rex::Proto::Kerberos::Crypto::Encryption.const_name(id) }\n\n    register_options(\n      [\n        OptString.new('KEYTAB_FILE', [true, 'The keytab file to manipulate']),\n        OptString.new('PRINCIPAL', [false, 'The kerberos principal name']),\n        OptString.new('REALM', [false, 'The kerberos realm']),\n        OptEnum.new('ENCTYPE', [false, 'The enctype to use. If a password is specified this can set to \\'ALL\\'', supported_encryption_names[0], supported_encryption_names]),\n        OptString.new('KEY', [false, 'The key to use. If not specified, the key will be generated from the password']),\n        OptString.new('PASSWORD', [false, 'The password. If not specified, the KEY option will be used']),\n        OptString.new('SALT', [false, 'The salt to use when creating a key from the password. If not specified, this will be generated from the principal name']),\n        OptInt.new('KVNO', [true, 'The kerberos key version number', 1]),\n        OptEnum.new('OUTPUT_FORMAT', [true, 'The output format to use for listing keytab entries', 'table', %w[csv table]]),\n      ]\n    )\n  end\n\n  def run\n    if datastore['KEYTAB_FILE'].blank?\n      fail_with(Failure::BadConfig, 'KEYTAB_FILE must be set to a non-empty string')\n    end\n\n    case action.name\n    when 'LIST'\n      list_keytab_entries\n    when 'ADD'\n      add_keytab_entry\n    when 'EXPORT'\n      export_keytab_entries\n    end\n  end\n\n  # Export the keytab entries from the database into the given keytab file. The keytab file will be created if it did not previously exist.\n  def export_keytab_entries\n    unless framework.db.active\n      print_error('export not available, because the database is not active.')\n      return\n    end\n\n    keytab_path = datastore['KEYTAB_FILE']\n    keytab = read_or_initialize_keytab(keytab_path)\n\n    # Kerberos encryption keys, most likely extracted from running secrets dump\n    kerberos_key_creds = framework.db.creds(type: 'Metasploit::Credential::KrbEncKey')\n    keytab_entries = kerberos_key_creds.map do |cred|\n      [\n        cred.id,\n        {\n          realm: cred.realm.value,\n          components: cred.public.username.split('/'),\n          name_type: Rex::Proto::Kerberos::Model::NameType::NT_PRINCIPAL,\n          timestamp: Time.at(0).utc,\n          vno8: datastore['KVNO'],\n          vno: datastore['KVNO'],\n          keyblock: {\n            enctype: cred.private.enctype,\n            data: cred.private.key\n          }\n        }\n      ]\n    end\n\n    # Additionally append NTHASH values, which don't require a salt\n    nthash_creds = framework.db.creds(type: 'Metasploit::Credential::NTLMHash')\n    keytab_entries += nthash_creds.map do |cred|\n      nthash = cred.private.to_s.split(':').last\n      [\n        cred.id,\n        {\n          realm: cred.realm&.value.to_s,\n          components: cred.public.username.split('/'),\n          name_type: Rex::Proto::Kerberos::Model::NameType::NT_PRINCIPAL,\n          timestamp: Time.at(0).utc,\n          vno8: datastore['KVNO'],\n          vno: datastore['KVNO'],\n          keyblock: {\n            enctype: Rex::Proto::Kerberos::Crypto::Encryption::RC4_HMAC,\n            data: [nthash].pack('H*')\n          }\n        }\n      ]\n    end\n\n    if keytab_entries.empty?\n      print_status('No entries to export')\n    end\n\n    keytab.key_entries.concat(keytab_entries.sort_by { |id, _entry| id }.to_h.values)\n    write_keytab(keytab_path, keytab)\n  end\n\n  # Add keytab entries into the given keytab file. The keytab file will be created if it did not previously exist.\n  def add_keytab_entry\n    keytab_path = datastore['KEYTAB_FILE']\n    keytab = read_or_initialize_keytab(keytab_path)\n\n    principal = datastore['PRINCIPAL']\n    fail_with(Failure::BadConfig, 'PRINCIPAL must be set to a non-empty string') if principal.blank?\n\n    realm = datastore['REALM']\n    fail_with(Failure::BadConfig, 'REALM must be set to a non-empty string') if realm.blank?\n\n    if /[[:lower:]]/.match(realm)\n      print_warning(\"REALM option has lowercase letters present - this may not work as expected for Window's Active Directory environments which uses a uppercase domain\")\n    end\n\n    keyblocks = []\n    if datastore['KEY'].present?\n      fail_with(Failure::BadConfig, 'enctype ALL not supported when KEY is set') if datastore['ENCTYPE'] == 'ALL'\n\n      keyblocks << {\n        enctype: Rex::Proto::Kerberos::Crypto::Encryption.value_for(datastore['ENCTYPE']),\n        data: [datastore['KEY']].pack('H*')\n      }\n    elsif datastore['PASSWORD'].present?\n      password = datastore['PASSWORD']\n      salt = datastore['SALT']\n      if salt.blank?\n        salt = \"#{realm}#{principal.split('/')[0]}\"\n        vprint_status(\"Generating key with salt: #{salt}. The SALT option can be set manually\")\n      end\n\n      if datastore['ENCTYPE'] == 'ALL'\n        enctypes = Rex::Proto::Kerberos::Crypto::Encryption::SUPPORTED_ENCRYPTIONS\n      else\n        enctypes = [Rex::Proto::Kerberos::Crypto::Encryption.value_for(datastore['ENCTYPE'])]\n      end\n\n      enctypes.each do |enctype|\n        encryptor = Rex::Proto::Kerberos::Crypto::Encryption.from_etype(enctype)\n        keyblocks << {\n          enctype: enctype,\n          data: encryptor.string_to_key(password, salt)\n        }\n      end\n    else\n      fail_with(Failure::BadConfig, 'KEY or PASSWORD required to add a new entry')\n    end\n\n    keytab_entries = keyblocks.map do |keyblock|\n      {\n        realm: realm,\n        components: principal.split('/'),\n        name_type: Rex::Proto::Kerberos::Model::NameType::NT_PRINCIPAL,\n        timestamp: Time.at(0).utc,\n        vno8: datastore['KVNO'],\n        vno: datastore['KVNO'],\n        keyblock: keyblock\n      }\n    end\n    keytab.key_entries.concat(keytab_entries)\n    write_keytab(keytab_path, keytab)\n  end\n\n  # List the keytab entries within the keytab file\n  def list_keytab_entries\n    if datastore['KEYTAB_FILE'].blank? || !File.exist?(datastore['KEYTAB_FILE'])\n      fail_with(Failure::BadConfig, 'Invalid key tab file')\n    end\n\n    tbl = Rex::Text::Table.new(\n      'Header' => 'Keytab entries',\n      'Indent' => 1,\n      'WordWrap' => false,\n      'Columns' => %w[\n        kvno\n        type\n        principal\n        hash\n        date\n      ]\n    )\n\n    keytab = File.binread(datastore['KEYTAB_FILE'])\n    keytab = Rex::Proto::Kerberos::Keytab::Krb5Keytab.read(keytab)\n    keytab.key_entries.each do |entry|\n      keyblock = entry.keyblock\n      tbl << [\n        entry.vno,\n        enctype_name(keyblock.enctype),\n        entry.principal,\n        keyblock.data.unpack1('H*'),\n        entry.timestamp,\n      ]\n    end\n\n    case datastore['OUTPUT_FORMAT']\n    when 'table'\n      print_line(tbl.to_s)\n    when 'csv'\n      print_line(tbl.to_csv)\n    else\n      print_line(tbl.to_s)\n    end\n  end\n\n  # @param [Object] id\n  # @see Rex::Proto::Kerberos::Crypto::Encryption\n  def enctype_name(id)\n    name = Rex::Proto::Kerberos::Crypto::Encryption.const_name(id)\n    name ? \"#{id.to_s.ljust(2)} (#{name})\" : id.to_s\n  end\n\n  private\n\n  # @param [String] keytab_path the keytab path\n  # @return [Rex::Proto::Kerberos::Keytab::Keytab]\n  def read_or_initialize_keytab(keytab_path)\n    return Rex::Proto::Kerberos::Keytab::Krb5Keytab.read(File.binread(keytab_path)) if File.exist?(keytab_path)\n\n    Rex::Proto::Kerberos::Keytab::Krb5Keytab.new\n  end\n\n  # @param [String] keytab_path the keytab path\n  # @param [Rex::Proto::Kerberos::Keytab::Keytab] keytab\n  def write_keytab(keytab_path, keytab)\n    File.binwrite(keytab_path, keytab.to_binary_s)\n    print_good \"keytab saved to #{keytab_path}\"\n\n    if datastore['VERBOSE']\n      list_keytab_entries\n    end\n  end\nend\n"
}