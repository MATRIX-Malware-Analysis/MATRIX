{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8bf0bf7c-69d4-4b0f-96df-a0bd259a198b",
    "created": "2024-08-14T16:30:36.899082Z",
    "modified": "2024-08-14T16:30:36.899086Z",
    "name": "Nagios XI Scanner",
    "description": " The module detects the version of Nagios XI applications and suggests matching exploit modules based on the version number. Since Nagios XI applications only reveal the version to authenticated users, valid credentials for a Nagios XI account are required. Alternatively, it is possible to provide a specific Nagios XI version number via the `VERSION` option. In that case, the module simply suggests matching exploit modules and does not probe the target(s).  ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/nagios_xi_scanner.rb",
            "external_id": "nagios_xi_scanner.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-15949"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-5791"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-5792"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-35578"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-37343"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HTTP::NagiosXi\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name' => 'Nagios XI Scanner',\n      'Description' => %q{\n        The module detects the version of Nagios XI applications and\n        suggests matching exploit modules based on the version number.\n        Since Nagios XI applications only reveal the version to authenticated\n        users, valid credentials for a Nagios XI account are required.\n        Alternatively, it is possible to provide a specific Nagios XI version\n        number via the `VERSION` option. In that case, the module simply\n        suggests matching exploit modules and does not probe the target(s).\n\n      },\n      'Author' => [ 'Erik Wynter' ], # @wyntererik\n      'License' => MSF_LICENSE,\n      'References' => [\n        ['CVE', '2019-15949'],\n        ['CVE', '2020-5791'],\n        ['CVE', '2020-5792'],\n        ['CVE', '2020-35578'],\n        ['CVE', '2021-37343']\n      ]\n    )\n    register_options [\n      OptString.new('VERSION', [false, 'Nagios XI version to check against existing exploit modules', nil])\n    ]\n  end\n\n  def finish_install\n    datastore['FINISH_INSTALL']\n  end\n\n  def username\n    datastore['USERNAME']\n  end\n\n  def password\n    datastore['PASSWORD']\n  end\n\n  def version\n    datastore['VERSION']\n  end\n\n  def parse_version(nagios_version)\n    # Strip the xi- prefix used for Nagios XI versions in the official documentation\n    clean_version = nagios_version.downcase.delete_prefix('xi-')\n\n    # Check for special case of 5r1.0, which is actually 5.1.0 but for some reason they still added\n    # the `r` used in legacy versions (this is the only version with this format)\n    if clean_version == '5r1.0'\n      clean_version = '5.1.0'\n    end\n\n    # Since we are dealing with a user provided version here, a strict regex check seems appropriate\n    # So far all modern Nagios XI versions start with 5. This regex can be updated if Nagios XI 6 ever\n    # comes out and modules for this new version are added\n    modern_check = clean_version.scan(/5\\.\\d{1,2}\\.\\d{1,2}/).flatten.first\n\n    unless modern_check.blank?\n      return ['modern', clean_version]\n    end\n\n    # Nagios XI legacy version numbers vary a lot, but they always start with a year followed by `r` and a single digit\n    legacy_check = clean_version.scan(/(20\\d{2}r\\d{1})/).flatten.first\n\n    unless legacy_check.blank?\n      return ['legacy', clean_version]\n    end\n\n    return 'unsupported'\n  end\n\n  def rce_check(version, real_target: false)\n    version_type, clean_version = parse_version(version)\n    if version_type == 'unsupported'\n      print_error(\"Invalid version format: `#{version}`. Please provide an existing Nagios XI version or use `unset VERSION` to cancel\")\n      return\n    end\n\n    if version_type == 'legacy'\n      print_error(\"This module does not support the legacy Nagios XI version #{version}\")\n      return\n    end\n\n    begin\n      gem_version = Rex::Version.new(clean_version)\n    rescue ArgumentError\n      print_error(\"Invalid version format: `#{version}`. Please provide an existing Nagios XI version or use `unset VERSION` to cancel\")\n      return\n    end\n\n    cve_rce_hash = nagios_xi_rce_check(gem_version)\n\n    if cve_rce_hash.empty?\n      print_error(\"Nagios XI version #{version} doesn't match any exploit modules.\")\n      return\n    end\n\n    # Adjust the output based on whether a version was provided, or we obtained a version from a target\n    if real_target\n      print_good(\"The target appears to be vulnerable to the following #{cve_rce_hash.length} exploit(s):\")\n    else\n      print_good(\"Version #{version} matches the following #{cve_rce_hash.length} exploit(s):\")\n    end\n\n    print_status('')\n    # Get the length of the longest key, this is used to align the output when printing\n    max_key_length = 0\n    cve_rce_hash.each_key { |k| max_key_length = k.length if k.length > max_key_length }\n    # Iterate over the hash, and print out the keys and values while using max_key_length to calculate the padding\n    cve_rce_hash.each do |cve, exploit_module|\n      padding = (max_key_length + 4) - cve.length\n      print_status(\"\\t#{cve}#{' ' * padding}exploit/linux/http/#{exploit_module}\")\n    end\n    print_status('')\n    return\n  end\n\n  # The first undercore in _target_host is used since this parameter is passed in by default but our code never uses it\n  def run_host(_target_host)\n    # Check if we have a valid version to test\n    if version\n      if version.empty?\n        print_error('VERSION cannot be empty. Please provide an existing Nagios XI VERSION or use `unset VERSION` to cancel')\n        return\n      end\n\n      return rce_check(version)\n    end\n\n    # Check if we have credentials, if not, try to obtain the Nagios XI version from login.php\n    if username.blank? || password.blank?\n      print_warning('No credentials provided. Attempting to obtain the Nagios XI version from the login page. This will not work for newer versions.')\n      nagios_version_result, error_message = nagios_xi_version_no_auth\n\n      if error_message\n        print_error(\"#{rhost}:#{rport} - #{error_message}\")\n        print_warning('Please provide a valid Nagios XI USERNAME and PASSWORD, or a specific VERSION to check')\n        return\n      end\n\n      print_status(\"Target is Nagios XI with version #{nagios_version_result}\")\n\n      # Check if the Nagios XI version matches any exploit modules\n      return rce_check(nagios_version_result, real_target: true)\n    end\n\n    # Use nagios_xi_login to try and authenticate. If authentication succeeds, nagios_xi_login returns\n    # an array containing the http response body of a get request to index.php and the session cookies\n    login_result, res_array = nagios_xi_login(username, password, finish_install)\n    case login_result\n    when 1..3 # An error occurred\n      print_error(\"#{rhost}:#{rport} - #{res_array[0]}\")\n      return\n    when 4 # Nagios XI is not fully installed\n      install_result = install_nagios_xi(password)\n      if install_result\n        print_error(\"#{rhost}:#{rport} - #{install_result[1]}\")\n        return\n      end\n\n      login_result, res_array = login_after_install_or_license(username, password, finish_install)\n      case login_result\n      when 1..3 # An error occurred\n        print_error(\"#{rhost}:#{rport} - #{res_array[0]}\")\n        return\n      when 4 # Nagios XI is still not fully installed\n        print_error(\"#{rhost}:#{rport} - Failed to install Nagios XI on the target.\")\n        return\n      end\n    end\n\n    # when 5 is excluded from the case statement above to prevent having to use this code block twice.\n    # Including when 5 would require using this code block once at the end of the `when 4` code block above, and once here.\n    if login_result == 5 # the Nagios XI license agreement has not been signed\n      auth_cookies, nsp = res_array\n      sign_license_result = sign_license_agreement(auth_cookies, nsp)\n      if sign_license_result\n        print_error(\"#{rhost}:#{rport} - #{sign_license_result[1]}\")\n        return\n      end\n\n      login_result, res_array = login_after_install_or_license(username, password, finish_install)\n      case login_result\n      when 1..3\n        print_error(\"#{rhost}:#{rport} - #{res_array[0]}\")\n        return\n      when 5 # the Nagios XI license agreement still has not been signed\n        print_error(\"#{rhost}:#{rport} - Failed to sign the license agreement.\")\n        return\n      end\n    end\n\n    print_good('Successfully authenticated to Nagios XI')\n\n    # Obtain the Nagios XI version\n    nagios_version = nagios_xi_version(res_array[0])\n    if nagios_version.nil?\n      print_error(\"#{rhost}:#{rport} - Unable to obtain the Nagios XI version from the dashboard\")\n      return\n    end\n\n    print_status(\"Target is Nagios XI with version #{nagios_version}\")\n\n    # Check if the Nagios XI version matches any exploit modules\n    rce_check(nagios_version, real_target: true)\n  end\nend\n"
}