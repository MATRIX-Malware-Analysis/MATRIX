{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--93494be6-5cec-409a-9f1c-b2ca8c5bee5e",
    "created": "2024-08-14T16:30:28.499829Z",
    "modified": "2024-08-14T16:30:28.499833Z",
    "name": "HTTP Page Scraper",
    "description": "Scrape defined data from a specific web page based on a regular expression",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/scraper.rb",
            "external_id": "scraper.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  # Exploit mixins should be called first\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::WmapScanServer\n  # Scanner mixin should be near last\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'HTTP Page Scraper',\n      'Description' => 'Scrape defined data from a specific web page based on a regular expression',\n      'Author'      => ['et'],\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        OptString.new('PATH', [ true,  \"The test path to the page to analize\", '/']),\n        OptRegexp.new('PATTERN', [ true,  \"The regex to use (default regex is a sample to grab page title)\", '<title>(.*)</title>'])\n\n      ])\n\n  end\n\n  def run_host(target_host)\n\n    tpath = normalize_uri(datastore['PATH'])\n    if tpath[-1,1] != '/'\n      tpath += '/'\n    end\n\n    begin\n\n\n      res = send_request_raw({\n        'uri'     => tpath,\n        'method'  => 'GET',\n        'version' => '1.0',\n      }, 10)\n\n\n      if not res\n        print_error(\"[#{target_host}] #{tpath} - No response\")\n        return\n      end\n\n      result = res.body.scan(datastore['PATTERN']).flatten.map{ |s| s.strip }.uniq\n\n      result.each do |u|\n        print_good(\"[#{target_host}] #{tpath} [#{u}]\")\n\n        report_note(\n          :host    => target_host,\n          :port    => rport,\n          :proto   => 'tcp',\n          :type    => \"http.scraper.#{rport}\",\n          :data    => u\n        )\n\n        report_web_vuln(\n          :host\t=> target_host,\n          :port\t=> rport,\n          :vhost  => vhost,\n          :ssl    => ssl,\n          :path\t=> tpath,\n          :method => 'GET',\n          :pname  => \"\",\n          :proof  => u,\n          :risk   => 0,\n          :confidence   => 100,\n          :category     => 'scraper',\n          :description  => 'Scraper',\n          :name   => 'scraper'\n        )\n\n      end\n\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n    rescue ::Timeout::Error, ::Errno::EPIPE\n    end\n  end\nend\n"
}