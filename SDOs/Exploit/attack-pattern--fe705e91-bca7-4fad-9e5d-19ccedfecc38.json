{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--fe705e91-bca7-4fad-9e5d-19ccedfecc38",
    "created": "2024-08-14T16:26:52.938451Z",
    "modified": "2024-08-14T16:26:52.938455Z",
    "name": "Modbus Client Utility",
    "description": " This module allows reading and writing data to a PLC using the Modbus protocol. This module is based on the 'modiconstop.rb' Basecamp module from DigitalBond as well as the mbtget perl script. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/scada/modbusclient.rb",
            "external_id": "modbusclient.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Modbus Client Utility',\n        'Description' => %q{\n          This module allows reading and writing data to a PLC using the Modbus protocol.\n          This module is based on the 'modiconstop.rb' Basecamp module from DigitalBond,\n          as well as the mbtget perl script.\n        },\n        'Author' => [\n          'EsMnemon <esm[at]mnemonic.no>', # original write-only module\n          'Arnaud SOULLIE  <arnaud.soullie[at]solucom.fr>', # code that allows read/write\n          'Alexandrine TORRENTS <alexandrine.torrents[at]eurecom.fr>', # code that allows reading/writing at multiple consecutive addresses\n          'Mathieu CHEVALIER <mathieu.chevalier[at]eurecom.fr>',\n          'AZSG <AstroZombieSG@gmail.com>' # updated read actions to include function codes 2 and 4 and renamed actions to align with modbus standard 1.1b3\n        ],\n        'License' => MSF_LICENSE,\n        'Actions' => [\n          ['READ_COILS', { 'Description' => 'Read bits from several coils' } ], # Function Code 1 Read Coils\n          ['READ_DISCRETE_INPUTS', { 'Description' => 'Read bits from several DISCRETE INPUTS' } ], # Function Code 2 Read Discrete Inputs\n          ['READ_HOLDING_REGISTERS', { 'Description' => 'Read words from several HOLDING registers' } ], # Function Code 3 Read Holding Registers\n          ['READ_INPUT_REGISTERS', { 'Description' => 'Read words from several INPUT registers' } ], # Function Code 4 Read Input Registers\n          ['WRITE_COIL', { 'Description' => 'Write one bit to a coil' } ],\n          ['WRITE_REGISTER', { 'Description' => 'Write one word to a register' } ],\n          ['WRITE_COILS', { 'Description' => 'Write bits to several coils' } ],\n          ['WRITE_REGISTERS', { 'Description' => 'Write words to several registers' } ],\n          ['READ_ID', { 'Description' => 'Read device id' } ]\n        ],\n        'DefaultAction' => 'READ_HOLDING_REGISTERS'\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(502),\n        OptInt.new('DATA_ADDRESS', [true, 'Modbus data address']),\n        OptInt.new('NUMBER', [false, 'Number of coils/registers to read (READ_COILS, READ_DISCRETE_INPUTS, READ_HOLDING_REGISTERS, READ_INPUT_REGISTERS modes only)', 1]),\n        OptInt.new('DATA', [false, 'Data to write (WRITE_COIL and WRITE_REGISTER modes only)']),\n        OptString.new('DATA_COILS', [false, 'Data in binary to write (WRITE_COILS mode only) e.g. 0110']),\n        OptString.new('DATA_REGISTERS', [false, 'Words to write to each register separated with a comma (WRITE_REGISTERS mode only) e.g. 1,2,3,4']),\n        OptInt.new('UNIT_NUMBER', [false, 'Modbus unit number', 1]),\n        OptBool.new('HEXDUMP', [false, 'Print hex dump of response', false]),\n      ]\n    )\n  end\n\n  # a wrapper just to be sure we increment the counter\n  def send_frame(payload)\n    sock.put(payload)\n    @modbus_counter += 1\n    rsp = sock.get_once(-1, sock.def_read_timeout)\n    dump_response(rsp)\n    rsp\n  end\n\n  def dump_response(response)\n    print_good('response: ' + response.unpack1('H*')) if datastore['HEXDUMP']\n  end\n\n  def make_payload(payload)\n    packet_data = [@modbus_counter].pack('n')\n    packet_data += \"\\x00\\x00\\x00\" # dunno what these are\n    packet_data += [payload.size].pack('c') # size byte\n    packet_data += payload\n\n    packet_data\n  end\n\n  def make_read_payload\n    payload = [datastore['UNIT_NUMBER']].pack('c')\n    payload += [@function_code].pack('c')\n    payload += [datastore['DATA_ADDRESS']].pack('n')\n    payload += [datastore['NUMBER']].pack('n')\n    make_payload(payload)\n  end\n\n  def make_write_coil_payload(data)\n    payload = [datastore['UNIT_NUMBER']].pack('c')\n    payload += [@function_code].pack('c')\n    payload += [datastore['DATA_ADDRESS']].pack('n')\n    payload += [data].pack('c')\n    payload += \"\\x00\"\n\n    packet_data = make_payload(payload)\n\n    packet_data\n  end\n\n  def make_write_coils_payload(data, byte)\n    payload = [datastore['UNIT_NUMBER']].pack('c')\n    payload += [@function_code].pack('c')\n    payload += [datastore['DATA_ADDRESS']].pack('n')\n    payload += [datastore['DATA_COILS'].size].pack('n') # bit count\n    payload += [byte].pack('c') # byte count\n    for i in 0..(byte - 1)\n      payload += [data[i]].pack('b*')\n    end\n\n    packet_data = make_payload(payload)\n\n    packet_data\n  end\n\n  def make_write_register_payload(data)\n    payload = [datastore['UNIT_NUMBER']].pack('c')\n    payload += [@function_code].pack('c')\n    payload += [datastore['DATA_ADDRESS']].pack('n')\n    payload += [data].pack('n')\n\n    make_payload(payload)\n  end\n\n  def make_write_registers_payload(data, size)\n    payload = [datastore['UNIT_NUMBER']].pack('c')\n    payload += [@function_code].pack('c')\n    payload += [datastore['DATA_ADDRESS']].pack('n')\n    payload += [size].pack('n') # word count\n    payload += [2 * size].pack('c') # byte count\n    for i in 0..(size - 1)\n      payload += [data[i]].pack('n')\n    end\n\n    make_payload(payload)\n  end\n\n  def make_read_id_payload\n    payload = [datastore['UNIT_NUMBER']].pack('c')\n    payload += [@function_code].pack('c')\n    payload += \"\\x0E\\x01\\x00\" # dunno what these are\n    make_payload(payload)\n  end\n\n  def handle_error(response)\n    case response.reverse.unpack('c')[0].to_i\n    when 1\n      print_error('Error : ILLEGAL FUNCTION')\n    when 2\n      print_error('Error : ILLEGAL DATA ADDRESS')\n    when 3\n      print_error('Error : ILLEGAL DATA VALUE')\n    when 4\n      print_error('Error : SLAVE DEVICE FAILURE')\n    when 6\n      print_error('Error : SLAVE DEVICE BUSY')\n    else\n      print_error('Unknown error')\n    end\n    return\n  end\n\n  def read_coils\n    if datastore['NUMBER'] + datastore['DATA_ADDRESS'] > 65535\n      print_error('Coils addresses go from 0 to 65535. You cannot go beyond.')\n      return\n    end\n    @function_code = 0x1\n    print_status('Sending READ COILS...')\n    response = send_frame(make_read_payload)\n    values = []\n    if response.nil?\n      print_error('No answer for the READ COILS')\n      return\n    elsif response.unpack('C*')[7] == (0x80 | @function_code)\n      handle_error(response)\n    elsif response.unpack('C*')[7] == @function_code\n      loop = (datastore['NUMBER'] - 1) / 8\n      for i in 0..loop\n        bin_value = response[9 + i].unpack('b*')[0]\n        list = bin_value.split('')\n        for j in 0..7\n          list[j] = list[j].to_i\n          values[i * 8 + j] = list[j]\n        end\n      end\n      values = values[0..(datastore['NUMBER'] - 1)]\n      print_good(\"#{datastore['NUMBER']} coil values from address #{datastore['DATA_ADDRESS']} : \")\n      print_good(values.to_s)\n    else\n      print_error('Unknown answer')\n    end\n  end\n\n  def read_discrete_inputs\n    if datastore['NUMBER'] + datastore['DATA_ADDRESS'] > 65535\n      print_error('DISCRETE INPUT addresses go from 0 to 65535. You cannot go beyond.')\n      return\n    end\n    @function_code = 0x2\n    print_status('Sending READ DISCRETE INPUTS...')\n    response = send_frame(make_read_payload)\n    values = []\n    if response.nil?\n      print_error('No answer for the READ DISCRETE INPUTS')\n      return\n    elsif response.unpack('C*')[7] == (0x80 | @function_code)\n      handle_error(response)\n    elsif response.unpack('C*')[7] == @function_code\n      loop = (datastore['NUMBER'] - 1) / 8\n      for i in 0..loop\n        bin_value = response[9 + i].unpack('b*')[0]\n        list = bin_value.split('')\n        for j in 0..7\n          list[j] = list[j].to_i\n          values[i * 8 + j] = list[j]\n        end\n      end\n      values = values[0..(datastore['NUMBER'] - 1)]\n      print_good(\"#{datastore['NUMBER']} DISCRETE INPUT values from address #{datastore['DATA_ADDRESS']} : \")\n      print_good(values.to_s)\n    else\n      print_error('Unknown answer')\n    end\n  end\n\n  def read_holding_registers\n    if datastore['NUMBER'] + datastore['DATA_ADDRESS'] > 65535\n      print_error('Holding Registers addresses go from 0 to 65535. You cannot go beyond.')\n      return\n    end\n    @function_code = 3\n    print_status('Sending READ HOLDING REGISTERS...')\n    response = send_frame(make_read_payload)\n    values = []\n    if response.nil?\n      print_error('No answer for the READ HOLDING REGISTERS')\n    elsif response.unpack('C*')[7] == (0x80 | @function_code)\n      handle_error(response)\n    elsif response.unpack('C*')[7] == @function_code\n      for i in 0..(datastore['NUMBER'] - 1)\n        values.push(response[9 + 2 * i..10 + 2 * i].unpack('n')[0])\n      end\n      print_good(\"#{datastore['NUMBER']} register values from address #{datastore['DATA_ADDRESS']} : \")\n      print_good(values.to_s)\n    else\n      print_error('Unknown answer')\n    end\n  end\n\n  def read_input_registers\n    if datastore['NUMBER'] + datastore['DATA_ADDRESS'] > 65535\n      print_error('Input Registers addresses go from 0 to 65535. You cannot go beyond.')\n      return\n    end\n    @function_code = 4\n    print_status('Sending READ INPUT REGISTERS...')\n    response = send_frame(make_read_payload)\n    values = []\n    if response.nil?\n      print_error('No answer for the READ INPUT REGISTERS')\n    elsif response.unpack('C*')[7] == (0x80 | @function_code)\n      handle_error(response)\n    elsif response.unpack('C*')[7] == @function_code\n      for i in 0..(datastore['NUMBER'] - 1)\n        values.push(response[9 + 2 * i..10 + 2 * i].unpack('n')[0])\n      end\n      print_good(\"#{datastore['NUMBER']} register values from address #{datastore['DATA_ADDRESS']} : \")\n      print_good(values.to_s)\n    else\n      print_error('Unknown answer')\n    end\n  end\n\n  def write_coil\n    @function_code = 5\n    if datastore['DATA'] == 0\n      data = 0\n    elsif datastore['DATA'] == 1\n      data = 255\n    else\n      print_error('Data value must be 0 or 1 in WRITE_COIL mode')\n      return\n    end\n    print_status('Sending WRITE COIL...')\n    response = send_frame(make_write_coil_payload(data))\n    if response.nil?\n      print_error('No answer for the WRITE COIL')\n    elsif response.unpack('C*')[7] == (0x80 | @function_code)\n      handle_error(response)\n    elsif response.unpack('C*')[7] == @function_code\n      print_good(\"Value #{datastore['DATA']} successfully written at coil address #{datastore['DATA_ADDRESS']}\")\n    else\n      print_error('Unknown answer')\n    end\n  end\n\n  def write_coils\n    @function_code = 15\n    temp = datastore['DATA_COILS']\n    check = temp.split('')\n    if temp.size > 65535\n      print_error('DATA_COILS size must be between 0 and 65535')\n      return\n    end\n    for j in check\n      unless (j == '0') || (j == '1')\n        print_error('DATA_COILS value must only contain 0s and 1s without space')\n        return\n      end\n    end\n    byte_number = (temp.size - 1) / 8 + 1\n    data = []\n    for i in 0..(byte_number - 1)\n      data.push(temp[(i * 8 + 0)..(i * 8 + 7)])\n    end\n    print_status('Sending WRITE COILS...')\n    response = send_frame(make_write_coils_payload(data, byte_number))\n    if response.nil?\n      print_error('No answer for the WRITE COILS')\n    elsif response.unpack('C*')[7] == (0x80 | @function_code)\n      handle_error(response)\n    elsif response.unpack('C*')[7] == @function_code\n      print_good(\"Values #{datastore['DATA_COILS']} successfully written from coil address #{datastore['DATA_ADDRESS']}\")\n    else\n      print_error('Unknown answer')\n    end\n  end\n\n  def write_register\n    @function_code = 6\n    if datastore['DATA'] < 0 || datastore['DATA'] > 65535\n      print_error('Data to write must be an integer between 0 and 65535 in WRITE_REGISTER mode')\n      return\n    end\n    print_status('Sending WRITE REGISTER...')\n    response = send_frame(make_write_register_payload(datastore['DATA']))\n    if response.nil?\n      print_error('No answer for the WRITE REGISTER')\n    elsif response.unpack('C*')[7] == (0x80 | @function_code)\n      handle_error(response)\n    elsif response.unpack('C*')[7] == @function_code\n      print_good(\"Value #{datastore['DATA']} successfully written at registry address #{datastore['DATA_ADDRESS']}\")\n    else\n      print_error('Unknown answer')\n    end\n  end\n\n  def write_registers\n    @function_code = 16\n    check = datastore['DATA_REGISTERS'].split('')\n    for j in 0..(check.size - 1)\n      if (check[j] == '0') || (check[j] == '1') || (check[j] == '2') || (check[j] == '3') || (check[j] == '4') || (check[j] == '5') || (check[j] == '6') || (check[j] == '7') || (check[j] == '8') || (check[j] == '9') || (check[j] == ',')\n        if (check[j] == ',') && (check[j + 1] == ',')\n          print_error('DATA_REGISTERS cannot contain two consecutive commas')\n          return\n        end\n      else\n        print_error('DATA_REGISTERS value must only contain numbers and commas without space')\n        return\n      end\n    end\n    list = datastore['DATA_REGISTERS'].split(',')\n    if list.size + datastore['DATA_ADDRESS'] > 65535\n      print_error('Registers addresses go from 0 to 65535. You cannot go beyond.')\n      return\n    end\n    data = []\n    for i in 0..(list.size - 1)\n      data[i] = list[i].to_i\n    end\n    for j in 0..(data.size - 1)\n      if data[j] < 0 || data[j] > 65535\n        print_error('Each word to write must be an integer between 0 and 65535 in WRITE_REGISTERS mode')\n        return\n      end\n    end\n    print_status('Sending WRITE REGISTERS...')\n    response = send_frame(make_write_registers_payload(data, data.size))\n    if response.nil?\n      print_error('No answer for the WRITE REGISTERS')\n    elsif response.unpack('C*')[7] == (0x80 | @function_code)\n      handle_error(response)\n    elsif response.unpack('C*')[7] == @function_code\n      print_good(\"Values #{datastore['DATA_REGISTERS']} successfully written from registry address #{datastore['DATA_ADDRESS']}\")\n    else\n      print_error('Unknown answer')\n    end\n  end\n\n  def read_id\n    @function_code = 0x2b\n    obj_cnt = 0\n    obj_id_pos = 0\n    obj_len = 0\n    print_status('Sending READ ID...')\n    response = send_frame(make_read_id_payload)\n    if response.nil?\n      print_error('No answer for READ ID')\n    elsif response.size < 9\n      print_error('response is not modbus conform')\n    elsif response.unpack('C*')[7] == (0x80 | @function_code)\n      handle_error(response)\n    elsif response.size < 16\n      print_error('response is too short for READ ID')\n    elsif response.unpack('C*')[7] == @function_code\n      obj_cnt = response[13].unpack('C')[0]\n      obj_id_pos = 14\n      max_ref_size = response.size(-1)\n      loop do\n        obj_len = response[obj_id_pos + 1].unpack('C')[0]\n        value = response.slice(obj_id_pos + 2, obj_len).unpack('a*')[0]\n        obj_id = response[obj_id_pos].unpack('C')[0]\n        print_good(\"Object ID #{obj_id}: #{value}\")\n        obj_cnt -= 1\n        obj_id_pos = obj_id_pos + obj_len + 2\n        if obj_id_pos > max_ref_size\n          print_error('Out of bounds reference occured whilst processing READ ID operation! Check sender data!')\n          break\n        end\n        break unless obj_cnt > 0\n      end\n    else\n      print_error('Unknown answer')\n    end\n  end\n\n  def run\n    @modbus_counter = 0x0000 # used for modbus frames\n    connect\n    case action.name\n    when 'READ_COILS'\n      read_coils\n    when 'READ_DISCRETE_INPUTS'\n      read_discrete_inputs\n    when 'READ_HOLDING_REGISTERS'\n      read_holding_registers\n    when 'READ_INPUT_REGISTERS'\n      read_input_registers\n    when 'WRITE_COIL'\n      write_coil\n    when 'WRITE_REGISTER'\n      write_register\n    when 'WRITE_COILS'\n      if datastore['DATA_COILS'].nil?\n        print_error('The following option is needed in WRITE_COILS mode: DATA_COILS.')\n        return\n      else\n        write_coils\n      end\n    when 'WRITE_REGISTERS'\n      if datastore['DATA_REGISTERS'].nil?\n        print_error('The following option is needed in WRITE_REGISTERS mode: DATA_REGISTERS.')\n        return\n      else\n        write_registers\n      end\n    when 'READ_ID'\n      read_id\n    else\n      print_error('Invalid ACTION')\n    end\n    disconnect\n  end\nend\n"
}