{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9b683a8c-f248-4c1e-9506-28e3aa82a3ea",
    "created": "2024-08-14T16:26:30.965132Z",
    "modified": "2024-08-14T16:26:30.965136Z",
    "name": "SMTP Simple Fuzzer",
    "description": "SMTP Simple Fuzzer 'References'  => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/fuzzers/smtp/smtp_fuzzer.rb",
            "external_id": "smtp_fuzzer.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n##\n# A Very simple Module to fuzzer some SMTP commands.\n# It allows to respect the order or just throw everything at it....\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Smtp\n  include Msf::Auxiliary::Fuzzer\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'SMTP Simple Fuzzer',\n      'Description' => 'SMTP Simple Fuzzer',\n      'References'  =>\n        [\n          ['URL', 'http://www.ietf.org/rfc/rfc2821.txt'],\n        ],\n      'Author'      => 'justme',\n      'License'     => MSF_LICENSE\n    )\n\n    register_options([\n      Opt::RPORT(25),\n      OptInt.new(\"STARTLEN\", [true, \"Length of the string - start number\", 100] ),\n      OptInt.new(\"INTERACTIONS\", [false, \"Number of interactions to run\", 100] ),\n      OptBool.new(\"RESPECTORDER\", [false, \"Respect order of commands\", true] ),\n      OptEnum.new(\"CMD\", [true,\"Command to fuzzer\",'EHLO',\n        [\n          'EHLO',\n          'HELO',\n          'MAILFROM',\n          'RCPTTO',\n          'DATA',\n          'VRFY',\n          'EXPN'\n        ], 'EHLO'])\n    ])\n  end\n\n  def smtp_send(data='', con=true)\n    begin\n      @result=''\n      @coderesult=''\n      if (con)\n        @connected=false\n        connect\n      end\n      @connected=true\n      sock.put(data)\n      @result=sock.get_once\n      @codresult=@result[0..2]\n    rescue ::Exception => e\n      print_error(e.to_s)\n    end\n  end\n\n  def run_host(ip)\n    begin\n    last_str = nil\n    last_inp = nil\n    last_err = nil\n\n    cnt = datastore['STARTLEN'] - 1\n\n    1.upto(datastore['INTERACTIONS']) do |interection|\n      cnt += 1\n\n      str = fuzzer_gen_string(cnt)\n      cmd=datastore['CMD']\n\n      begin\n        if (datastore['RESPECTORDER'])\n          case cmd\n          when \"HELO\", \"EHLO\", \"VRFY\", \"EXPN\"\n            c = datastore['CMD'] + \" \" + str  + \"\\r\\n\"\n            smtp_send(c,true)\n            #print_status(c)\n            disconnect\n\n          when \"MAILFROM\"\n            c =\"EHLO localhost\\r\\n\"\n            smtp_send(c,true)\n            #print_status(c)\n            c=\"MAIL FROM:<\" + str + \">\\r\\n\"\n            smtp_send(c,false)\n            disconnect\n            #print_status(c)\n          when \"RCPTTO\"\n            c =\"EHLO localhost\\r\\n\"\n            smtp_send(c,true)\n            #print_status(c)\n            c=\"MAIL FROM:<\" + datastore['MAILFROM'] + \">\\r\\n\"\n            smtp_send(c,false)\n            #print_status(c)\n            c=\"RCPT TO:<\" + str + \">\\r\\n\"\n            smtp_send(c,false)\n            #print_status(c)\n            disconnect\n          when \"DATA\"\n            c =\"EHLO localhost\\r\\n\"\n            smtp_send(c,true)\n            #print_status(c)\n            c=\"MAIL FROM:<\" + datastore['MAILFROM'] + \">\\r\\n\"\n            smtp_send(c,false)\n            #print_status(c)\n            c=\"RCPT TO:<\" + datastore['MAILTO'] + \">\\r\\n\"\n            smtp_send(c,false)\n            #print_status(c)\n            c=\"DATA \\r\\n\"\n            smtp_send(c,false)\n            c= str + \"\\r\\n.\\r\\n\"\n            smtp_send(c,false)\n            #print_status(c)\n            disconnect\n          end\n        else\n          c = datastore['CMD'] + \" \" + str  + \"\\r\\n\"\n          smtp_send(c,true)\n          #print_status(c)\n          disconnect\n        end\n\n        print_status(\"Fuzzing with iteration #{interection}\\n #{@result}\")\n\n      rescue ::Interrupt\n        print_status(\"Exiting on interrupt: iteration #{interection} using string  #{str}\")\n        raise $!\n      rescue ::Exception => e\n        last_err = e\n      #ensure\n      #disconnect\n      end\n\n\n      if(not @connected)\n        if(last_str)\n          print_status(\"The service may have crashed: iteration:#{interection-1} String=''#{last_str}'' error=#{last_err}\")\n        else\n          print_status(\"Could not connect to the service: #{last_err}\")\n        end\n        return\n      end\n\n      last_str = str\n      last_inp = @last_fuzzer_input\n    end\n  end\n  end\nend\n",
    "x_mitre_contributors": [
        "justme",
        ""
    ]
}