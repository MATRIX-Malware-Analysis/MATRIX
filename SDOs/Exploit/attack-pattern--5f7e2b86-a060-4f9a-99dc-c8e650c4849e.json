{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5f7e2b86-a060-4f9a-99dc-c8e650c4849e",
    "created": "2024-08-14T16:33:19.202536Z",
    "modified": "2024-08-14T16:33:19.20254Z",
    "name": "Simple",
    "description": "An x64 single/multi byte NOP instruction generator.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/nops/x64/simple.rb",
            "external_id": "simple.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Nop\n\n  def initialize\n    super(\n      'Name'        => 'Simple',\n      'Alias'       => 'x64_simple',\n      'Description' => 'An x64 single/multi byte NOP instruction generator.',\n      'Author'      => [ 'sf' ],\n      'License'     => MSF_LICENSE,\n      'Arch'        => ARCH_X64 )\n\n    register_advanced_options( [ OptBool.new( 'RandomNops', [ false, \"Generate a random NOP sled\", true ] ) ])\n    register_advanced_options( [ OptBool.new( 'MultiByte',  [ false, \"Generate a multi byte instruction NOP sled\", false ] ) ])\n  end\n\n  # This instruction list is far from complete (Only single byte instructions and some multi byte ADD/MOV instructions are used).\n  # A more complete list might warrent an pseudo assembler (Rex::Arch::X64) instead of hardcoding these.\n  INSTRUCTIONS = [\t[ \"\\x90\",             0, \"nop\" ],\n            [ \"\\x91\",             0, \"xchg eax, ecx\" ],\n            [ \"\\x92\",             0, \"xchg eax, edx\" ],\n            [ \"\\x93\",             0, \"xchg eax, ebx\" ],\n            [ \"\\x94\",             0, \"xchg eax, esp\" ],\n            [ \"\\x95\",             0, \"xchg eax, ebp\" ],\n            [ \"\\x96\",             0, \"xchg eax, esi\" ],\n            [ \"\\x97\",             0, \"xchg eax, edi\" ],\n            [ \"\\x98\",             0, \"cwde\" ],\n            [ \"\\x99\",             0, \"cdq\" ],\n            [ \"\\x9B\",             0, \"wait\" ],\n            [ \"\\x9C\",             0, \"pushfq\" ],\n            [ \"\\x9D\",             0, \"popfq\" ],\n            [ \"\\x9E\",             0, \"sahf\" ],\n            [ \"\\x9F\",             0, \"lahf\" ],\n            [ \"\\xFC\",             0, \"cld\" ],\n            [ \"\\xFD\",             0, \"std\" ],\n            [ \"\\xF8\",             0, \"clc\" ],\n            [ \"\\xF9\",             0, \"cmc\" ],\n            [ \"\\x50\",             0, \"push rax\" ],\n            [ \"\\x51\",             0, \"push rcx\" ],\n            [ \"\\x52\",             0, \"push rdx\" ],\n            [ \"\\x53\",             0, \"push rbx\" ],\n            [ \"\\x54\",             0, \"push rsp\" ],\n            [ \"\\x55\",             0, \"push rbp\" ],\n            [ \"\\x56\",             0, \"push rsi\" ],\n            [ \"\\x57\",             0, \"push rdi\" ],\n            [ \"\\x58\",             0, \"pop rax\" ],\n            [ \"\\x59\",             0, \"pop rcx\" ],\n            [ \"\\x5A\",             0, \"pop rdx\" ],\n            [ \"\\x5B\",             0, \"pop rbx\" ],\n            [ \"\\x5C\",             0, \"pop rsp\" ],\n            [ \"\\x5D\",             0, \"pop rbp\" ],\n            [ \"\\x5E\",             0, \"pop rsi\" ],\n            [ \"\\x5F\",             0, \"pop rdi\" ],\n            [ \"\\x04\",             1, \"add al, 0x??\" ],\n            [ \"\\x80\\xC3\",         1, \"add bl, 0x??\" ],\n            [ \"\\x80\\xC1\",         1, \"add cl, 0x??\" ],\n            [ \"\\x80\\xC2\",         1, \"add dl, 0x??\" ],\n            [ \"\\x80\\xC4\",         1, \"add ah, 0x??\" ],\n            [ \"\\x80\\xC7\",         1, \"add bh, 0x??\" ],\n            [ \"\\x80\\xC5\",         1, \"add ch, 0x??\" ],\n            [ \"\\x80\\xC6\",         1, \"add dh, 0x??\" ],\n            [ \"\\x66\\x05\",         2, \"add ax, 0x????\" ],\n            [ \"\\x66\\x81\\xC3\",     2, \"add bx, 0x????\" ],\n            [ \"\\x66\\x81\\xC1\",     2, \"add cx, 0x????\" ],\n            [ \"\\x66\\x81\\xC2\",     2, \"add dx, 0x????\" ],\n            [ \"\\x66\\x81\\xC6\",     2, \"add si, 0x????\" ],\n            [ \"\\x66\\x81\\xC7\",     2, \"add di, 0x????\" ],\n            [ \"\\x66\\x41\\x81\\xC0\", 2, \"add r8w, 0x????\" ],\n            [ \"\\x66\\x41\\x81\\xC1\", 2, \"add r9w, 0x????\" ],\n            [ \"\\x66\\x41\\x81\\xC2\", 2, \"add r10w, 0x????\" ],\n            [ \"\\x66\\x41\\x81\\xC3\", 2, \"add r11w, 0x????\" ],\n            [ \"\\x66\\x41\\x81\\xC4\", 2, \"add r12w, 0x????\" ],\n            [ \"\\x66\\x41\\x81\\xC5\", 2, \"add r13w, 0x????\" ],\n            [ \"\\x66\\x41\\x81\\xC6\", 2, \"add r14w, 0x????\" ],\n            [ \"\\x66\\x41\\x81\\xC7\", 2, \"add r15w, 0x????\" ],\n            [ \"\\x05\",             4, \"add eax, 0x????????\" ],\n            [ \"\\x81\\xC3\",         4, \"add ebx, 0x????????\" ],\n            [ \"\\x81\\xC1\",         4, \"add ecx, 0x????????\" ],\n            [ \"\\x81\\xC2\",         4, \"add edx, 0x????????\" ],\n            [ \"\\x81\\xC6\",         4, \"add esi, 0x????????\" ],\n            [ \"\\x81\\xC7\",         4, \"add edi, 0x????????\" ],\n            [ \"\\x41\\x81\\xC0\",     4, \"add r8d, 0x????????\" ],\n            [ \"\\x41\\x81\\xC1\",     4, \"add r9d, 0x????????\" ],\n            [ \"\\x41\\x81\\xC2\",     4, \"add r10d, 0x????????\" ],\n            [ \"\\x41\\x81\\xC3\",     4, \"add r11d, 0x????????\" ],\n            [ \"\\x41\\x81\\xC4\",     4, \"add r12d, 0x????????\" ],\n            [ \"\\x41\\x81\\xC5\",     4, \"add r13d, 0x????????\" ],\n            [ \"\\x41\\x81\\xC6\",     4, \"add r14d, 0x????????\" ],\n            [ \"\\x41\\x81\\xC7\",     4, \"add r15d, 0x????????\" ],\n            [ \"\\x48\\xB8\",         8, \"mov rax, 0x????????????????\" ],\n            [ \"\\x48\\xBB\",         8, \"mov rbx, 0x????????????????\" ],\n            [ \"\\x48\\xB9\",         8, \"mov rcx, 0x????????????????\" ],\n            [ \"\\x48\\xBA\",         8, \"mov rdx, 0x????????????????\" ],\n            [ \"\\x48\\xBE\",         8, \"mov rsi, 0x????????????????\" ],\n            [ \"\\x48\\xBF\",         8, \"mov rdi, 0x????????????????\" ],\n            [ \"\\x49\\xB8\",         8, \"mov r8, 0x????????????????\" ],\n            [ \"\\x49\\xB9\",         8, \"mov r8, 0x????????????????\" ],\n            [ \"\\x49\\xBA\",         8, \"mov r10, 0x????????????????\" ],\n            [ \"\\x49\\xBB\",         8, \"mov r11, 0x????????????????\" ],\n            [ \"\\x49\\xBC\",         8, \"mov r12, 0x????????????????\" ],\n            [ \"\\x49\\xBD\",         8, \"mov r13, 0x????????????????\" ],\n            [ \"\\x49\\xBE\",         8, \"mov r14, 0x????????????????\" ],\n            [ \"\\x49\\xBF\",         8, \"mov r15, 0x????????????????\" ],\n  ]\n\n  I_OP   = 0\n  I_SIZE = 1\n  I_TEXT = 2\n\n  REGISTERS = [\t\t[ \"rsp\", \"esp\", \"sp\" ],\n            [ \"rbp\", \"ebp\", \"bp\" ],\n            [ \"rax\", \"eax\", \"ax\", \"al\", \"ah\" ],\n            [ \"rbx\", \"ebx\", \"bx\", \"bl\", \"bh\" ],\n            [ \"rcx\", \"ecx\", \"cx\", \"cl\", \"ch\" ],\n            [ \"rdx\", \"edx\", \"dx\", \"dl\", \"dh\" ],\n            [ \"rsi\", \"esi\", \"si\" ],\n            [ \"rdi\", \"edi\", \"di\" ],\n            [ \"r8\", \"r8d\", \"r8w\", \"r8b\" ],\n            [ \"r9\", \"r9d\", \"r9w\", \"r9b\" ],\n            [ \"r10\", \"r10d\", \"r10w\", \"r10b\" ],\n            [ \"r11\", \"r11d\", \"r11w\", \"r11b\" ],\n            [ \"r12\", \"r12d\", \"r12w\", \"r12b\" ],\n            [ \"r13\", \"r13d\", \"r13w\", \"r13b\" ],\n            [ \"r14\", \"r14d\", \"r14w\", \"r14b\" ],\n            [ \"r15\", \"r15d\", \"r15w\", \"r15b\" ],\n  ]\n\n  def generate_random_sled( length, instructions, badchars, badregs )\n    opcodes_stack = []\n    total_size    = 0\n    sled          = ''\n    try_count     = 0\n    good_bytes    = []\n\n    # Fixup SaveRegisters so for example, if we wish to preserve RSP we also should also preserve ESP and SP\n    REGISTERS.each { | reg | reg.each { |x| badregs += reg if badregs.include?( x ) } }\n    badregs = badregs.uniq()\n\n    # If we are preserving RSP we should avoid all PUSH/POP instructions...\n    if badregs.include?( \"rsp\" )\n      badregs.push( 'push' )\n      badregs.push( 'pop' )\n    end\n\n    # Loop while we still have bytes to fill in the sled...\n    while true\n      # Pick a random instruction and see if we can use it...\n      instruction = instructions[ rand(instructions.length) ]\n\n      # Avoid using any bad mnemonics/registers...\n      try_another = false\n      badregs.each do | bad |\n        try_another = true if instruction[I_TEXT].include?( bad.downcase() )\n        break if try_another\n      end\n      next if try_another\n\n      # Get the first bytes of the chosed instructions opcodes...\n      opcodes = instruction[I_OP]\n\n      # If their are additional bytes to append, do it now...\n      1.upto( instruction[I_SIZE] ) do | i |\n        opcodes += Rex::Text.rand_char( badchars )\n      end\n\n      # If we have gone over the requested sled length, try again.\n      if total_size + opcodes.length > length\n        try_count -= 1\n\n        # If we have tried unsuccessfully 32 times we start unwinding the chosen opcode_stack to speed things up\n        if try_count == 0\n          pop_count = 4\n          while opcodes_stack.length and pop_count\n            total_size -= opcodes_stack.pop().length\n            pop_count -= 1\n          end\n        end\n        next\n      end\n\n      # Reset the try_count for the next itteration.\n      try_count = 32\n\n      # save the opcodes we just generated.\n      opcodes_stack.push( opcodes )\n\n      # Increment the total size appropriately.\n      total_size += opcodes.length\n\n      # Once we have generated the requested amount of bytes we can finish.\n      break if total_size == length\n    end\n\n    # Now that we have chosen all the instructions to use we must generate the actual sled.\n    opcodes_stack.each do | opcodes_ |\n      sled += opcodes_\n    end\n\n    return sled\n  end\n\n  def generate_sled( length, opts )\n    badchars  = opts['BadChars'] || ''\n    random    = opts['Random'] || datastore['RandomNops']\n    badregs   = opts['SaveRegisters'] || []\n    good_instructions = []\n    sled      = ''\n\n    # Weed out any instructions which will contain a bad char/instruction...\n    INSTRUCTIONS.each do | instruction |\n      good = true;\n      # If the instruction contains some bad chars we wont use it...\n      badchars.each_char do | bc |\n        if instruction[I_OP].include?( bc )\n          good = false\n          break\n        end\n      end\n      # if we are only to generate single byte instructions, weed out the multi byte ones...\n      good = false if instruction[I_SIZE] > 0 and not datastore['MultiByte']\n\n      good_instructions.push( instruction ) if good\n    end\n\n    # After we have pruned the instruction list we can proceed to generate a sled...\n    if good_instructions.empty?\n      # If we are left with no valid instructions to use we simple cant generate a sled.\n      sled = nil\n    elsif not random\n      if not badchars.include?( \"\\x90\" )\n        sled += \"\\x90\" * length\n      else\n        sled = nil\n      end\n    else\n      sled += generate_random_sled( length, good_instructions, badchars, badregs )\n    end\n\n    return sled\n  end\nend\n"
}