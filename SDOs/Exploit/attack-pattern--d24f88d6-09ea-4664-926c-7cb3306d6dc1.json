{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d24f88d6-09ea-4664-926c-7cb3306d6dc1",
    "created": "2024-08-14T16:28:57.196148Z",
    "modified": "2024-08-14T16:28:57.196152Z",
    "name": "HTTP Directory Scanner",
    "description": " This module identifies the existence of interesting directories in a given directory path. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/dir_scanner.rb",
            "external_id": "dir_scanner.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nrequire 'thread'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::WmapScanDir\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'   \t\t=> 'HTTP Directory Scanner',\n      'Description'\t=> %q{\n        This module identifies the existence of interesting directories\n        in a given directory path.\n      },\n      'Author' \t\t=> [ 'et [at] metasploit.com' ],\n      'License'\t\t=> BSD_LICENSE))\n\n    register_options(\n      [\n        OptString.new('PATH', [ true,  \"The path  to identify files\", '/']),\n        OptPath.new('DICTIONARY',   [ false, \"Path of word dictionary to use\",\n            File.join(Msf::Config.data_directory, \"wmap\", \"wmap_dirs.txt\")\n          ]\n        )\n\n      ])\n\n    register_advanced_options(\n      [\n        OptInt.new('ErrorCode', [ false, \"Error code for non existent directory\" ]),\n        OptPath.new('HTTP404Sigs',   [ false, \"Path of 404 signatures to use\",\n            File.join(Msf::Config.data_directory, \"wmap\", \"wmap_404s.txt\")\n          ]\n        ),\n        OptBool.new('NoDetailMessages', [ false, \"Do not display detailed test messages\", true ]),\n        OptInt.new('TestThreads', [ true, \"Number of test threads\", 25])\n\n      ])\n\n  end\n\n  def run_host(ip)\n    conn = true\n    ecode = nil\n    emesg = nil\n\n    tpath = normalize_uri(datastore['PATH'])\n    if tpath[-1,1] != '/'\n      tpath += '/'\n    end\n\n    ecode = datastore['ErrorCode'].to_i\n    vhost = datastore['VHOST'] || wmap_target_host\n    prot  = datastore['SSL'] ? 'https' : 'http'\n\n\n    if (ecode == 0)\n      # Then the user didn't specify one, go request a (probably)\n      # nonexistent file to detect what to use.\n      begin\n        #\n        # Detect error code\n        #\n        print_status(\"Detecting error code\")\n        randdir = Rex::Text.rand_text_alpha(5).chomp + '/'\n        res = send_request_cgi({\n          'uri'  \t\t=>  tpath+randdir,\n          'method'   \t=> 'GET',\n          'ctype'\t\t=> 'text/html'\n        }, 20)\n\n        return if not res\n\n        tcode = res.code.to_i\n\n        # Look for a string we can signature on as well\n        if(tcode >= 200 and tcode <= 299)\n\n          File.open(datastore['HTTP404Sigs'], 'rb').each do |str|\n            if(res.body.index(str))\n              emesg = str\n              break\n            end\n          end\n\n          if(not emesg)\n            print_status(\"Using first 256 bytes of the response as 404 string for #{wmap_target_host}\")\n            emesg = res.body[0,256]\n          else\n            print_status(\"Using custom 404 string of '#{emesg}' for #{wmap_target_host}\")\n          end\n        else\n          ecode = tcode\n          print_status(\"Using code '#{ecode}' as not found for #{wmap_target_host}\")\n        end\n      rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n        conn = false\n      rescue ::Timeout::Error, ::Errno::EPIPE\n      end\n    end\n\n    return if not conn\n\n    nt = datastore['TestThreads'].to_i\n    nt = 1 if nt == 0\n\n    dm = datastore['NoDetailMessages']\n\n    queue = []\n    File.open(datastore['DICTIONARY'], 'rb').each_line do |testd|\n      queue << testd.strip + '/'\n    end\n\n    while(not queue.empty?)\n      t = []\n      1.upto(nt) do\n        t << framework.threads.spawn(\"Module(#{self.refname})-#{rhost}\", false, queue.shift) do |testf|\n          Thread.current.kill if not testf\n\n          testfdir = testf\n          res = send_request_cgi({\n            'uri'  \t\t=>  tpath+testfdir,\n            'method'   \t=> 'GET',\n            'ctype'\t\t=> 'text/html'\n          }, 20)\n\n\n          if(not res or ((res.code.to_i == ecode) or (emesg and res.body.index(emesg))))\n            if dm == false\n              print_status(\"NOT Found #{wmap_base_url}#{tpath}#{testfdir} #{res.code} (#{wmap_target_host})\")\n            end\n          else\n\n            report_web_vuln(\n              :host\t=> ip,\n              :port\t=> rport,\n              :vhost  => vhost,\n              :ssl    => ssl,\n              :path\t=> \"#{tpath}#{testfdir}\",\n              :method => 'GET',\n              :pname  => \"\",\n              :proof  => \"Res code: #{res.code.to_s}\",\n              :risk   => 0,\n              :confidence   => 100,\n              :category     => 'directory',\n              :description  => 'Directory found.',\n              :name   => 'directory'\n            )\n\n            print_good(\"Found #{wmap_base_url}#{tpath}#{testfdir} #{res.code} (#{wmap_target_host})\")\n\n            if res.code.to_i == 401\n              print_status(\"#{wmap_base_url}#{tpath}#{testfdir} requires authentication: #{res.headers['WWW-Authenticate']}\")\n\n              report_note(\n                :host\t=> ip,\n                :port\t=> rport,\n                :proto => 'tcp',\n                :sname\t=> (ssl ? 'https' : 'http'),\n                :type\t=> 'WWW_AUTHENTICATE',\n                :data\t=> \"#{tpath}#{testfdir} Auth: #{res.headers['WWW-Authenticate']}\",\n                :update => :unique_data\n              )\n\n            end\n          end\n\n        end\n      end\n      t.map{|x| x.join }\n    end\n  end\nend\n"
}