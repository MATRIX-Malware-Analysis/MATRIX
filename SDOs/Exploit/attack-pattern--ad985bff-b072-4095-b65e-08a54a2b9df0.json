{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ad985bff-b072-4095-b65e-08a54a2b9df0",
    "created": "2024-08-14T16:32:29.393955Z",
    "modified": "2024-08-14T16:32:29.393959Z",
    "name": "ZoomEye Search",
    "description": " The module use the ZoomEye API to search ZoomEye. ZoomEye is a search engine for cyberspace that lets the user find specific network components(ip, services, etc.). Mind to enclose the whole request with quotes and limit the span of filters: `set zoomeye_dork 'country:\"france\"+some+query'`  Setting facets will output a simple report on the overall search. It's values are: Host search: app, device, service, os, port, country, city Web search: webapp, component, framework, frontend, server, waf, os, country, city  Possible filters values are: Host search: app, ver, device, os, service, ip, cidr, hostname, port, city, country, asn Web search: app, header, keywords, desc, title, ip, site, city, country ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/zoomeye_search.rb",
            "external_id": "zoomeye_search.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/knownsec/ZoomEye-python"
        },
        {
            "source_name": "reference",
            "url": "https://www.zoomeye.org/api/doc"
        },
        {
            "source_name": "reference",
            "url": "https://www.zoomeye.org/help/manual"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'ZoomEye Search',\n        'Description' => %q{\n          The module use the ZoomEye API to search ZoomEye. ZoomEye is a search\n          engine for cyberspace that lets the user find specific network\n          components(ip, services, etc.).\n          Mind to enclose the whole request with quotes and limit the span of filters:\n          `set zoomeye_dork 'country:\"france\"+some+query'`\n\n          Setting facets will output a simple report on the overall search. It's values are:\n          Host search: app, device, service, os, port, country, city\n          Web search: webapp, component, framework, frontend, server, waf, os, country, city\n\n          Possible filters values are:\n          Host search: app, ver, device, os, service, ip, cidr, hostname, port, city, country, asn\n          Web search: app, header, keywords, desc, title, ip, site, city, country\n        },\n        'Author' => [\n          'Nixawk', # Original Author\n          'Yvain', # Initial improvements\n          'Grant Willcox' # Additional fixes to refine searches, improve quality of info saved and improve error handling.\n        ],\n        'References' => [\n          ['URL', 'https://github.com/knownsec/ZoomEye-python'],\n          ['URL', 'https://www.zoomeye.org/api/doc'],\n          ['URL', 'https://www.zoomeye.org/help/manual']\n        ],\n        'License' => MSF_LICENSE\n      )\n    )\n    register_options(\n      [\n        OptString.new('USERNAME', [true, 'The ZoomEye username']),\n        OptString.new('PASSWORD', [true, 'The ZoomEye password']),\n        OptString.new('ZOOMEYE_DORK', [true, 'The ZoomEye dork']),\n        OptString.new('FACETS', [false, 'A comma-separated list of properties to get summary information on query', nil]),\n        OptEnum.new('RESOURCE', [true, 'ZoomEye Resource Type', 'host', ['host', 'web']]),\n        OptInt.new('MAXPAGE', [true, 'Max amount of pages to collect', 1]),\n        OptString.new('OUTFILE', [false, 'Path to the file to store the resulting table of info']),\n        OptBool.new('DATABASE', [false, 'Add search results to the database', false])\n      ]\n    )\n  end\n\n  # save output to file\n  def save_output(data)\n    ::File.open(datastore['OUTFILE'], 'wb') do |f|\n      f.write(data)\n      print_status(\"Saved results in #{datastore['OUTFILE']}\")\n    end\n  end\n\n  # Check to see if api.zoomeye.org resolves properly\n  def zoomeye_resolvable?\n    begin\n      Rex::Socket.resolv_to_dotted('api.zoomeye.org')\n    rescue RuntimeError, SocketError\n      return false\n    end\n    true\n  end\n\n  def login(username, password)\n    # See more: https://www.zoomeye.org/api/doc#login\n\n    access_token = ''\n    begin\n      @cli = Rex::Proto::Http::Client.new('api.zoomeye.org', 443, {}, true)\n      @cli.connect\n\n      data = { 'username' => username, 'password' => password }\n      req = @cli.request_cgi({\n        'uri' => '/user/login',\n        'method' => 'POST',\n        'data' => data.to_json\n      })\n\n      res = @cli.send_recv(req)\n    rescue ::Rex::ConnectionError, Errno::ECONNREFUSED, Errno::ETIMEDOUT, Errno::ECONNRESET, Rex::ConnectionRefused\n      print_error('HTTP Connection Failed')\n      return\n    end\n\n    unless res\n      print_error('server_response_error')\n      return\n    end\n\n    records = ActiveSupport::JSON.decode(res.body)\n    access_token = records['access_token'] if records && records.key?('access_token')\n    access_token\n  end\n\n  def dork_search(resource, dork, page, facets)\n    begin\n      req = @cli.request_cgi({\n        'uri' => \"/#{resource}/search\",\n        'method' => 'GET',\n        'headers' => { 'Authorization' => \"JWT #{@zoomeye_token}\" },\n        'vars_get' => {\n          'query' => dork,\n          'page' => page,\n          'facets' => facets\n        }\n      })\n\n      res = @cli.send_recv(req)\n    rescue ::Rex::ConnectionError, Errno::ECONNREFUSED, Errno::ETIMEDOUT, Errno::ECONNRESET, Rex::ConnectionRefused\n      print_error('HTTP Connection Failed')\n    end\n\n    unless res\n      print_error('server_response_error')\n      return\n    end\n\n    # Invalid Token, Not enough segments\n    # Invalid Token, Signature has expired\n    if res.body =~ /Invalid Token, /\n      fail_with(Failure::BadConfig, '401 Unauthorized. Your ZOOMEYE_APIKEY is invalid')\n    end\n    res.get_json_document\n  end\n\n  def match_records?(records)\n    records && records.key?('matches')\n  end\n\n  def run\n    dork = datastore['ZOOMEYE_DORK']\n    resource = datastore['RESOURCE']\n    maxpage = datastore['MAXPAGE']\n    facets = datastore['FACETS']\n    # check to ensure api.zoomeye.org is resolvable\n    unless zoomeye_resolvable?\n      print_error('Unable to resolve api.zoomeye.org')\n      return\n    end\n\n    @zoomeye_token = login(datastore['USERNAME'], datastore['PASSWORD'])\n    if @zoomeye_token.blank? || @zoomeye_token.nil?\n      print_error('Unable to login api.zoomeye.org')\n      return\n    else\n      print_status('Logged in to zoomeye')\n    end\n\n    first_page = 0\n    results = []\n    results[first_page] = dork_search(resource, dork, 1, facets)\n\n    if results[first_page].nil? || results[first_page]['total'].nil? || results[first_page]['total'] == 0\n      msg = 'No results.'\n      if !results[first_page]['error'].to_s.empty?\n        msg << \" Error: #{results[first_page]['error']}\"\n      end\n      print_error(msg)\n      return\n    end\n\n    # Determine page count based on total results\n    if results[first_page]['total'] % 20 == 0\n      tpages = results[first_page]['total'] / 20\n    else\n      tpages = results[first_page]['total'] / 20 + 1\n    end\n    maxpage = tpages if datastore['MAXPAGE'] > tpages\n\n    if facets\n      facets_tbl = Rex::Text::Table.new(\n        'Header' => 'Facets',\n        'Indent' => 1,\n        'Columns' => ['Facet', 'Name', 'Count']\n      )\n      print_status(\"Total: #{results[first_page]['total']} on #{tpages} \" \\\n        'pages. Showing facets')\n      facet = results[first_page]['facets']\n      facet.each do |name, list|\n        list.each do |f|\n          facets_tbl << [name.to_s, (f['name']).to_s, (f['count']).to_s]\n        end\n      end\n    else\n      print_status(\"Total: #{results[first_page]['total']} on #{tpages} \" \\\n        \"pages. Showing: #{maxpage} page(s)\")\n      # If search results greater than 20, loop & get all results\n      if results[first_page]['total'] > 20\n        print_status('Collecting data, please wait...')\n        page = 1\n        while page < maxpage\n          page_result = dork_search(resource, dork, page + 1, facets)\n          if page_result['matches'].nil?\n            next\n          end\n\n          results[page] = page_result\n          page += 1\n        end\n      end\n      tbl1 = Rex::Text::Table.new(\n        'Header' => 'Host search',\n        'Indent' => 1,\n        'Columns' => ['IP:Port', 'Protocol', 'City', 'Country', 'Hostname', 'OS', 'Service', 'AppName', 'Version', 'Info']\n      )\n      tbl2 = Rex::Text::Table.new(\n        'Header' => 'Web search',\n        'Indent' => 1,\n        'Columns' => ['IP', 'Site', 'City', 'Country', 'DB:Version', 'WebApp:Version']\n      )\n      # scroll max pages from ZoomEye\n      results.each do |result|\n        result['matches'].each do |match|\n          city = match['geoinfo']['city']['names']['en']\n          country = match['geoinfo']['country']['names']['en']\n          if resource.include?('host')\n            ip = match['ip']\n            protocol = match['protocol']['transport']\n            port = match['portinfo']['port']\n            hostname = match['portinfo']['hostname']\n            os = match['portinfo']['os']\n            app = match['portinfo']['app']\n            service = match['portinfo']['service']\n            version = match['portinfo']['version']\n            info = match['portinfo']['info']\n            if datastore['DATABASE']\n              report_host(host: ip,\n                          name: hostname,\n                          os_name: os,\n                          comments: 'Added from Zoomeye')\n            end\n            if datastore['DATABASE']\n              protocol = 'tcp' if ((protocol != 'tcp') || (protocol != 'udp'))\n              report_service(host: ip,\n                             port: port,\n                             proto: protocol,\n                             name: service,\n                             info: \"#{app} running version: #{version}\")\n            end\n            tbl1 << [\"#{ip}:#{port}\", protocol, city, country, hostname, os, service, app, version, info]\n          else\n            ips = match['ip']\n            site = match['site']\n            database = match['db']\n            if database.empty?\n              db_info = \"\"\n            else\n              db_info = database.map { |db|\n                if !db['name']&.empty? && !db['version']&.empty?\n                  \"#{db['name']}:#{db['version']}\"\n                else\n                  \"\"\n                end\n              }\n            end\n            webapp = match['webapp']\n            if webapp.empty?\n              wa_info = \"\"\n            else\n              wa_info = webapp.map { |wa|\n                if !wa['name']&.empty? && !wa['version']&.empty?\n                  \"#{wa['name']}:#{wa['version']}\"\n                else\n                  \"\"\n                end\n              }\n            end\n            if datastore['DATABASE']\n              for ip in ips\n                report_host(host: ip, name: site, comments: 'Added from Zoomeye')\n              end\n            end\n            for ip in ips\n                tbl2 << [ip, site, city, country, db_info, wa_info]\n            end\n          end\n        end\n      end\n      if resource.include?('host')\n        print_line(tbl1.to_s)\n        save_output(tbl1) if datastore['OUTFILE']\n      else\n        print_line(tbl2.to_s)\n        save_output(tbl2) if datastore['OUTFILE']\n      end\n    end\n    if datastore['FACETS']\n      print_line(facets_tbl.to_s)\n      save_output(facets_tbl) if datastore['OUTFILE']\n    end\n  end\nend\n"
}