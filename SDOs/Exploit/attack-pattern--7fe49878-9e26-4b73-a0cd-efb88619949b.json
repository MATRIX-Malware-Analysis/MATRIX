{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7fe49878-9e26-4b73-a0cd-efb88619949b",
    "created": "2024-08-14T16:27:09.307236Z",
    "modified": "2024-08-14T16:27:09.30724Z",
    "name": "Wardialer",
    "description": "Scan for dial-up systems that are connected to modems and answer telephony indials.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/telephony/wardial.rb",
            "external_id": "wardial.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'zlib'\n\n\n# Extend Object class to include save_to_file and load_from_file methods\nclass Object\n  def self.save_to_file obj, filename, options={}\n    #obj = self\n    marshal_dump = Marshal.dump(obj)\n    file = File.new(filename,'w')\n    file = Zlib::GzipWriter.new(file) unless options[:gzip] == false\n    file.write marshal_dump\n    file.close\n    return obj\n  end\n\n  def self.load_from_file filename\n    begin\n      file = Zlib::GzipReader.open(filename)\n    rescue Zlib::GzipFile::Error\n      file = File.open(filename, 'rb')\n    ensure\n      return nil if ! file\n      #obj = Marshal.load file.read\n      obj = Marshal.load file.read\n      file.close\n      return obj\n    end\n  end\nend\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'Wardialer',\n      'Description' => 'Scan for dial-up systems that are connected to modems and answer telephony indials.',\n      'Author'      => [ 'I)ruid' ],\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n    [\n      OptString.new('DIALMASK',     [true,  'Dial Mask (e.g. 1.800.95X.99XX, (202) 358-XXXX, 358.####, etc.)', '202.358.XXXX']),\n      OptString.new('DIALPREFIX',   [true,  'Dial Prefix', 'ATDT']),\n      OptString.new('INITSTRING',   [true,  'Initialization String', 'AT X6 S11=80']),\n      OptString.new('SERIALPORT',   [true,  'Serial Port (e.g. 0 (COM1), 1 (COM2), /dev/ttyS0, etc.)', '/dev/ttyS0']),\n    ])\n\n    register_advanced_options(\n    [\n      OptInt.new(   'BaudRate',     [true,  'Baud Rate', 19200]),\n      OptEnum.new(  'DataBits',     [true,  'Data Bits (4 is Windows Only)', '8', ['4', '5', '6', '7', '8'], '8']),\n      OptInt.new(   'ConnTimeout',  [true,  'Timeout per data connection in seconds', 45]),\n      OptInt.new(   'DialDelay',    [true,  'Time to wait between dials in seconds (rec. min. 1)', 1]),\n      OptString.new('DialSuffix',   [false, 'Dial Suffix', nil]),\n      OptInt.new(   'DialTimeout',  [true,  'Timeout per dialed number in seconds', 40]),\n      OptBool.new(  'DisplayModem', [false,  'Displays modem commands and responses on the console', false]),\n      OptEnum.new(  'FlowControl',  [true,  'Flow Control', 'None', ['None', 'Hardware', 'Software', 'Both'], 'None']),\n      OptInt.new(   'InitInterval', [true,  'Number of dials before reinitializing modem', 30]),\n      #OptEnum.new(  'LogMethod',    [true,  'Log Method', 'File', ['File', 'DataBase', 'TIDBITS'], 'File']),\n      OptEnum.new(  'LogMethod',    [true,  'Log Method', 'File', ['File'], 'File']),\n      OptString.new('NudgeString',  [false, 'Nudge String', '\\x1b\\x1b\\r\\n\\r\\n']),\n      OptEnum.new(  'Parity',       [false,  'Parity (Mark & Space are Windows Only)', 'None', ['None', 'Even', 'Odd', 'Mark', 'Space'], 'None']),\n      OptBool.new(  'RedialBusy',   [false,  'Redials numbers found to be busy', false]),\n      OptEnum.new(  'StopBits',     [true,  'Stop Bits', '1', ['1', '2'], '1']),\n    ])\n\n    deregister_options('NUMBER')\n    deregister_options('RPORT')\n    deregister_options('RHOSTS')\n    deregister_options('PAYLOAD')\n\n    @logmethod = :file\n    @commandstate = true\n\n    begin\n      require 'telephony'\n      @telephony_loaded = true\n    rescue ::Exception => e\n      @telephony_loaded = false\n      @telephony_error  = e\n    end\n  end\n\n  def run\n    if ! @telephony_loaded\n      print_error(\"The Telephony module is not available: #{@telephony_error}\")\n      raise RuntimeError, \"Telephony not available\"\n    end\n\n    @confdir      = File.join(Msf::Config.config_directory, 'wardial')\n    @datadir      = File.join(Msf::Config.config_directory, 'logs', 'wardial')\n\n    # make sure working dirs exist\n    FileUtils.mkdir_p(@confdir)\n    FileUtils.mkdir_p(@datadir)\n\n    @logmethod   = case datastore['LogMethod']\n      when 'DataBase' ; :database\n      when 'TIDBITS'  ; :tidbits\n      else              :file\n    end\n    serialport   = datastore['SERIALPORT']\n    baud         = datastore['BaudRate'].to_i\n    data_bits    = datastore['DataBits'].to_i\n    stop_bits    = datastore['StopBits'].to_i\n    parity       = case datastore['Parity']\n      when 'Even' ; Telephony::Modem::EVEN\n      when 'Odd'  ; Telephony::Modem::ODD\n      when 'Mark' ; Telephony::Modem::MARK\n      when 'Space'; Telephony::Modem::SPACE\n      else          Telephony::Modem::NONE\n    end\n    flowcontrol  = case datastore['FlowControl']\n      when 'Hardware' ; Telephony::Modem::HARD\n      when 'Software' ; Telephony::Modem::SOFT\n      when 'Both'     ; Telephony::Modem::HARD | Telephony::Modem::SOFT\n      else            ; Telephony::Modem::NONE\n    end\n    initstring   = datastore['INITSTRING']\n    initinterval = datastore['InitInterval']\n    dialprefix   = datastore['DIALPREFIX']\n    dialsuffix   = datastore['DialSuffix']\n    nudgestring  = datastore['NudgeString'] ? eval('\"'+datastore['NudgeString']+'\"') : \"\\r\\n\\r\\n\"\n    dialtimeout  = datastore['DialTimeout'].to_i\n    conntimeout  = datastore['ConnTimeout'].to_i\n    dialmask     = datastore['DIALMASK'].tr(' ', '')\n    dialdelay    = datastore['DialDelay'].to_i\n    redialbusy   = datastore['RedialBusy']\n    @displaymodem = datastore['DisplayModem']\n\n    # Connect to and init modem\n    modem = Telephony::Modem.new(serialport)\n    modem.params = {\n      'baud'      => baud,\n      'data_bits' => data_bits,\n      'parity'    => parity,\n      'stop_bits' => stop_bits\n    }\n    modem.flow_control = flowcontrol\n    modem.display = @displaymodem\n\n    modem.flush\n\n    # reload data from previous scan\n    datfile = @datadir + '/' + dialmask.gsub(/[( ]/, '').gsub(/[).]/, '-').gsub(/[#]/, 'X').upcase + '.dat'\n    dialrange = Object.load_from_file(datfile)\n    if dialrange\n      print_status( \"Previous scan data loaded from #{datfile}\" )\n      select = dialrange.select {|key, value|\n        case @target\n          when :carrier ; value[:carrier] == true\n          when :fax     ; value[:fax]     == true\n        end\n      }\n      num_identified = select.size\n      select = dialrange.select {|key, value|\n        value[:carrier] == true\n      }\n      num_carriers = select.size\n      select = dialrange.select {|key, value|\n        value[:fax] == true\n      }\n      num_faxes = select.size\n      select = dialrange.select {|key, value|\n        value[:busy] == true\n      }\n      num_busy = select.size\n    else\n      print_status( \"No previous scan data found (#{datfile})\" )\n      dialrange = build_dialrange(dialmask)\n      num_identified = 0\n      num_carriers   = 0\n      num_faxes      = 0\n      num_busy       = 0\n    end\n\n    # Dial loop\n    begin\n      done = false\n      nextnum = true\n      dialcount = 0\n      while true\n\n        if dialcount % initinterval == 0\n          return if initmodem(modem, initstring) == false\n        end\n\n        if nextnum == true\n          unidentified = dialrange.select {|key, value|\n            value[:identified] == false\n          }\n          if redialbusy\n            unidentified += unidentified.select {|key, value|\n              value[:busy] == true\n            }\n          end\n          break if unidentified.size == 0\n\n          chosen  = rand(unidentified.size)\n          dialnum = unidentified[chosen][0]\n          dialval = unidentified[chosen][1]\n        end\n        print_status(\"#{unidentified.size} of #{dialrange.size} numbers unidentified, #{num_carriers} carriers found, #{num_faxes} faxes found, #{num_busy} busy\")\n        if dialval[:busy] == true\n          print_status(\"Dialing: #{dialnum} (#{dialtimeout} sec. timeout, previously busy)\")\n        else\n          print_status(\"Dialing: #{dialnum} (#{dialtimeout} sec. timeout, previously undialed)\")\n        end\n\n        dialstring = dialprefix + ' ' + dialnum\n        dialstring += (' ' + dialsuffix) if dialsuffix\n\n        modem.flush\n        time = Time.now\n        result = modem.put_command(dialstring, dialtimeout)\n        while result =~ /RINGING/i\n          result = modem.get_response(dialtimeout-(Time.now-time))\n        end\n        dialcount += 1\n        dialrange[dialnum][:dialed] = dialnum\n\n        case result\n          when /TIMEOUT/i\n            print_status( 'Timeout' )\n            dialrange[dialnum][:identified] = true\n            dialrange[dialnum][:result] = result\n            dialrange[dialnum][:timeout] = true\n            dialrange[dialnum][:timestamp] = Time.now\n            modem.puts \"\\r\\n\" # force the modem to respond to last command (hangup/abort)\n            result = modem.get_response(3)\n          when /CONNECT/i\n            print_status( \"Carrier: #{result}\" )\n            @commandstate = false\n            dialrange[dialnum][:identified] = true\n            dialrange[dialnum][:result] = result\n            dialrange[dialnum][:carrier] = true\n            dialrange[dialnum][:timestamp] = Time.now\n            dialrange[dialnum][:banner] = get_banner(modem, conntimeout, nudgestring)\n            modem.hangup\n            initmodem(modem, initstring)\n            num_carriers += 1\n            note = dialrange[dialnum][:result] + \"\\n\" + dialrange[dialnum][:banner]\n            report_note(:host => dialnum, :type => \"wardial_result\", :data => note)\n            log_result(dialrange[dialnum])\n          when /HK_CARRIER/i\n            print_status( \"Carrier: #{result}\" )\n            dialrange[dialnum][:identified] = true\n            dialrange[dialnum][:result] = result\n            dialrange[dialnum][:carrier] = true\n            dialrange[dialnum][:timestamp] = Time.now\n            modem.hangup\n            initmodem(modem, initstring)\n            num_carriers += 1\n            note = dialrange[dialnum][:result] + \"\\n\" + dialrange[dialnum][:banner]\n            report_note(:host => dialnum, :type => \"wardial_result\", :data => note)\n            log_result(dialrange[dialnum])\n          when /\\+FCO/i\n            print_status( \"Fax: #{result}\" )\n            dialrange[dialnum][:identified] = true\n            dialrange[dialnum][:result] = result\n            dialrange[dialnum][:fax] = true\n            dialrange[dialnum][:timestamp] = Time.now\n            modem.hangup\n            initmodem(modem, initstring)\n            num_faxes += 1\n            note = dialrange[dialnum][:result] + \"\\n\" + dialrange[dialnum][:banner]\n            report_note(:host => dialnum, :type => \"wardial_result\", :data => note)\n            log_result(dialrange[dialnum])\n          when /VOICE/i\n            print_status( \"Voice\" )\n            dialrange[dialnum][:identified] = true\n            dialrange[dialnum][:result] = result\n            dialrange[dialnum][:voice] = true\n            dialrange[dialnum][:timestamp] = Time.now\n            modem.hangup\n          when /HK_VMB/i\n            dialrange[dialnum][:identified] = true\n            dialrange[dialnum][:result] = result\n            dialrange[dialnum][:voicemail] = true\n            dialrange[dialnum][:timestamp] = Time.now\n            modem.hangup\n          when /HK_AVS/i\n            dialrange[dialnum][:identified] = true\n            dialrange[dialnum][:result] = result\n            dialrange[dialnum][:avs] = true\n            dialrange[dialnum][:timestamp] = Time.now\n            modem.hangup\n          when /HK_NOTED/i\n            dialrange[dialnum][:identified] = true\n            dialrange[dialnum][:result] = result\n            dialrange[dialnum][:noted] = true\n            dialrange[dialnum][:timestamp] = Time.now\n            modem.hangup\n          when /HK_GIRL/i\n            dialrange[dialnum][:identified] = true\n            dialrange[dialnum][:result] = result\n            dialrange[dialnum][:girl] = true\n            dialrange[dialnum][:timestamp] = Time.now\n            modem.hangup\n          when /NO CARRIER/i\n            print_status( \"No Carrier\" )\n            dialrange[dialnum][:identified] = true #TODO: should this be false?\n            dialrange[dialnum][:result] = result\n            dialrange[dialnum][:timestamp] = Time.now\n          when /BUSY/i\n            print_status( \"Busy\" )\n            dialrange[dialnum][:identified] = false\n            dialrange[dialnum][:result] = result\n            dialrange[dialnum][:busy] = true\n            dialrange[dialnum][:timestamp] = Time.now\n            num_busy += 1\n          when /OK/i\n            print_status( \"Unexpected OK response...\" )\n          when /NO DIAL *TONE/i\n            nextnum = false\n            modem.hangup\n            select(nil,nil,nil,1)\n            next\n          when nil\n            modem.hangup\n          else\n            print_status( \"Unrecognized Response String\" )\n        end\n\n        Object.save_to_file(dialrange, datfile)\n        #dialrange.save_to_file(datfile)\n        nextnum = true\n        select(nil,nil,nil,1) # we need at least a little buffer for the modem to hangup/reset\n        select(nil,nil,nil,dialdelay-1) if dialdelay >= 1\n      end\n\n    rescue ::Interrupt\n      modem.hangup\n      Object.save_to_file(dialrange, datfile)\n      #dialrange.save_to_file(datfile)\n      raise $!\n    rescue ::Exception => e\n      print_error(\"Error during dial process: #{e.class} #{e} #{e.backtrace}\")\n      return\n    end\n\n    print_status(\"Dialing Complete\")\n    modem.close\n  end\n\n  def initmodem(modem, initstring)\n    print_status(\"Initializing Modem\")\n    result = modem.put_command('ATZ', 3)\n    if result != 'OK'\n      print_error(\"Error resetting modem\")\n      return false\n    end\n    result = modem.put_command(initstring, 3)\n    if result != 'OK'\n      print_error(\"Error initializing modem\")\n      return false\n    end\n\n    return true\n  end\n\n  def build_dialrange(dialmask)\n    dialrange = {}\n\n    incdigits = 0\n    dialmask.each_char {|c|\n      incdigits += 1 if c =~ /^[X#]$/i\n    }\n    max = (10**incdigits)-1\n    print_status(\"Detected #{incdigits} masked digits in DIALMASK (#{dialmask})\")\n    print_status(\"Generating storage for #{max+1} numbers to dial\")\n\n    (0..max).each {|num|\n      number = dialmask.dup # copy the mask\n      numstr = sprintf(\"%0#{incdigits}d\", num) # stringify our incrementing number\n      j = 0 # index for numstr\n      for i in 0..number.length-1 do # step through the number (mask)\n        if number[i].chr =~ /^[X#]$/i\n          number[i] = numstr[j] # replaced masked indexes with digits from incrementing number\n          j += 1\n        end\n      end\n      dialrange[number] = {}\n      dialrange[number][:identified] = false\n    }\n    #print_status(\"Storage for #{dialrange.size} numbers generated\")\n\n    return dialrange\n  end\n\n  def log_result(dialnum)\n    case @logmethod\n      when :file\n        logfile = File.join(@datadir, 'found.log')\n        file = File.new(logfile, 'a')\n        file.puts( \"#####( NEW LOG ENTRY )#####\\n\")\n        file.puts( \"#{Time.now}\\n\")\n        file.puts( \"#{dialnum[:dialed]} : #{dialnum[:result]}\\n\")\n        file.puts( \"#{dialnum[:banner]}\\n\") if dialnum[:banner]\n        file.puts( \"#####( END LOG ENTRY )#####\\n\")\n        file.close\n      when :database\n      when :tidbits\n    end\n  end\n\n  def get_banner(modem, timeout, nudgestring)\n    print_status(\"Grabbing banner...\")\n    banner = ''\n\n    time = Time.now\n    gotchar = Time.now\n    while Time.now < time + timeout\n      if Time.now >= gotchar + 8 # nudges after 8 seconds of receiving nothing\n        if nudgestring\n          print_status( \"Nudging...\" )\n          modem.puts nudgestring\n        end\n        gotchar = Time.now # resets timer so we don't nudge too often\n      end\n\n      c = modem.getc\n      next if ! c\n\n      gotchar = Time.now\n      print( c.chr ) if @displaymodem\n\n      # stop if carrier dropped\n      break if modem.dcd == 0\n\n      banner += c.chr\n    end\n\n    print(\"\\n\") if @displaymodem\n    return banner\n  end\nend\n"
}