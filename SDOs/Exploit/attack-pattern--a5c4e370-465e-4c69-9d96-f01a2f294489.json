{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a5c4e370-465e-4c69-9d96-f01a2f294489",
    "created": "2024-08-14T16:22:56.174984Z",
    "modified": "2024-08-14T16:22:56.174988Z",
    "name": "NAT-PMP Port Mapper",
    "description": "Map (forward) TCP and UDP ports on NAT devices using NAT-PMP",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/natpmp/natpmp_map.rb",
            "external_id": "natpmp_map.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::NATPMP\n  include Rex::Proto::NATPMP\n\n  def initialize\n    super(\n      'Name'        => 'NAT-PMP Port Mapper',\n      'Description' => 'Map (forward) TCP and UDP ports on NAT devices using NAT-PMP',\n      'Author'      => 'Jon Hart <jhart[at]spoofed.org>',\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        OptString.new('EXTERNAL_PORTS', [true, 'The external ports to foward from (0 to let the target choose)', 0]),\n        OptString.new('INTERNAL_PORTS', [true, 'The internal ports to forward to', '22,135-139,80,443,445'])\n      ],\n      self.class\n    )\n  end\n\n  def build_ports(ports_string)\n    # We don't use Rex::Socket.portspec_crack because we need to allow 0 and preserve order\n    ports = []\n    ports_string.split(/[ ,]/).map { |s| s.strip }.compact.each do |port_part|\n      if /^(?<port>\\d+)$/ =~ port_part\n        ports << port.to_i\n      elsif /^(?<low>\\d+)\\s*-\\s*(?<high>\\d+)$/ =~ port_part\n        ports |= (low..high).to_a.map(&:to_i)\n      else\n        fail ArgumentError, \"Invalid port specification #{port_part}\"\n      end\n    end\n    ports\n  end\n\n  def setup\n    super\n    @external_ports = build_ports(datastore['EXTERNAL_PORTS'])\n    @internal_ports = build_ports(datastore['INTERNAL_PORTS'])\n\n    if @external_ports.size > @internal_ports.size\n      fail ArgumentError, \"Too many external ports specified (#{@external_ports.size}); \" +\n        \"must be one port (0) or #{@internal_ports.size} ports\"\n    end\n\n    if @external_ports.size < @internal_ports.size\n      if @external_ports != [0]\n        fail ArgumentError, \"Incorrect number of external ports specified (#{@external_ports.size}); \" +\n          \"must be one port (0) or #{@internal_ports.size} ports\"\n      else\n        @external_ports = [0] * @internal_ports.size\n      end\n    end\n  end\n\n  def run_host(host)\n    begin\n\n      udp_sock = Rex::Socket::Udp.create({\n        'LocalHost' => datastore['CHOST'] || nil,\n        'Context'   => {'Msf' => framework, 'MsfExploit' => self}\n      })\n      add_socket(udp_sock)\n\n      external_address = get_external_address(udp_sock, host, datastore['RPORT']) || host\n\n      @external_ports.each_index do |i|\n        external_port = @external_ports[i]\n        internal_port = @internal_ports[i]\n\n        actual_ext_port = map_port(udp_sock, host, datastore['RPORT'], internal_port, external_port, Rex::Proto::NATPMP.const_get(protocol), lifetime)\n        map_target = Rex::Socket.source_address(host)\n        requested_forwarding = \"#{external_address}:#{external_port}/#{protocol}\" +\n                              \" -> \" +\n                              \"#{map_target}:#{internal_port}/#{protocol}\"\n        if actual_ext_port\n          map_target = datastore['CHOST'] ? datastore['CHOST'] : Rex::Socket.source_address(host)\n          actual_forwarding = \"#{external_address}:#{actual_ext_port}/#{protocol}\" +\n                                \" -> \" +\n                                \"#{map_target}:#{internal_port}/#{protocol}\"\n          if external_port == 0\n            print_good(\"#{actual_forwarding} forwarded\")\n          else\n            if (external_port != 0 && external_port != actual_ext_port)\n              print_good(\"#{requested_forwarding} could not be forwarded, but #{actual_forwarding} could\")\n            else\n              print_good(\"#{requested_forwarding} forwarded\")\n            end\n          end\n        else\n          print_error(\"#{requested_forwarding} could not be forwarded\")\n        end\n\n        report_service(\n          :host   => host,\n          :port   => datastore['RPORT'],\n          :proto  => 'udp',\n          :name  => 'natpmp',\n          :state => Msf::ServiceState::Open\n        )\n      end\n    rescue ::Interrupt\n      raise $!\n    rescue ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionRefused\n      nil\n    rescue ::Exception => e\n      print_error(\"Unknown error: #{e.class} #{e.backtrace}\")\n    end\n  end\nend\n"
}