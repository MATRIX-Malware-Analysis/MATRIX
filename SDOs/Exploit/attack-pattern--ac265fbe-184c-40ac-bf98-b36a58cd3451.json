{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ac265fbe-184c-40ac-bf98-b36a58cd3451",
    "created": "2024-08-14T16:29:51.629919Z",
    "modified": "2024-08-14T16:29:51.629922Z",
    "name": "Apache HTTPD mod_negotiation Scanner",
    "description": " This module scans the webserver of the given host(s) for the existence of mod_negotiate. If the webserver has mod_negotiation enabled, the IP address will be displayed. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/mod_negotiation_scanner.rb",
            "external_id": "mod_negotiation_scanner.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'   \t\t=> 'Apache HTTPD mod_negotiation Scanner',\n      'Description'\t=> %q{\n          This module scans the webserver of the given host(s) for the existence of mod_negotiate.\n        If the webserver has mod_negotiation enabled, the IP address will be displayed.\n      },\n      'Author' \t\t=> [ 'diablohorn [at] gmail.com' ],\n      'License'\t\t=> MSF_LICENSE))\n\n    register_options(\n      [\n        OptString.new('PATH', [ true,  \"The path to detect mod_negotiation\", '/']),\n        OptString.new('FILENAME',[true, \"Filename to use as a test\",'index'])\n      ])\n  end\n\n  def run_host(ip)\n    ecode = nil\n    emesg = nil\n\n    tpath = datastore['PATH']\n    tfile = datastore['FILENAME']\n\n    if tpath[-1,1] != '/'\n      tpath += '/'\n    end\n\n    vhost = datastore['VHOST'] || ip\n    prot  = datastore['SSL'] ? 'https' : 'http'\n\n    #\n    # Send the request and parse the response headers for an alternates header\n    #\n    begin\n      # Send the request the accept header is key here\n      res = send_request_cgi({\n        'uri'  \t\t=>  tpath+tfile,\n        'method'   \t=> 'GET',\n        'ctype'     => 'text/html',\n        'headers'\t=> {'Accept' => 'a/b'}\n      }, 20)\n\n      return if not res\n\n      # Sheck for alternates header\n      if(res.code == 406)\n        print_status(ip.to_s)\n      end\n\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n    rescue ::Timeout::Error, ::Errno::EPIPE\n    end\n\n  end\nend\n"
}