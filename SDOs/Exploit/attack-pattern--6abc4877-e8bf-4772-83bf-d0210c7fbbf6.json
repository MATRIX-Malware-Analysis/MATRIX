{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6abc4877-e8bf-4772-83bf-d0210c7fbbf6",
    "created": "2024-08-14T16:33:19.198186Z",
    "modified": "2024-08-14T16:33:19.19819Z",
    "name": "Single Byte",
    "description": "Single-byte NOP generator",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/nops/x86/single_byte.rb",
            "external_id": "single_byte.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n###\n#\n# This class implements single-byte NOP generation for X86.  It takes from\n# ADMmutate and from spoonfu.\n#\n###\nclass MetasploitModule < Msf::Nop\n\nSINGLE_BYTE_SLED =\n  {\n    # opcode  affected registers\n    # ------  ------------------\n    \"\\x90\" => nil               , # nop\n    \"\\x97\" => [ 'eax', 'edi'   ], # xchg eax,edi\n    \"\\x96\" => [ 'eax', 'esi'   ], # xchg eax,esi\n    \"\\x95\" => [ 'eax', 'ebp'   ], # xchg eax,ebp\n    \"\\x93\" => [ 'eax', 'ebx'   ], # xchg eax,ebx\n    \"\\x92\" => [ 'eax', 'edx'   ], # xchg eax,edx\n    \"\\x91\" => [ 'eax', 'ecx'   ], # xchg eax,ecx\n    \"\\x99\" => [ 'edx'          ], # cdq\n    \"\\x4d\" => [ 'ebp'          ], # dec ebp\n    \"\\x48\" => [ 'eax'          ], # dec eax\n    \"\\x47\" => [ 'edi'          ], # inc edi\n    \"\\x4f\" => [ 'edi'          ], # dec edi\n    \"\\x40\" => [ 'eax'          ], # inc eax\n    \"\\x41\" => [ 'ecx'          ], # inc ecx\n    \"\\x37\" => [ 'eax'          ], # aaa\n    \"\\x3f\" => [ 'eax'          ], # aas\n    \"\\x27\" => [ 'eax'          ], # daa\n    \"\\x2f\" => [ 'eax'          ], # das\n    \"\\x46\" => [ 'esi'          ], # inc esi\n    \"\\x4e\" => [ 'esi'          ], # dec esi\n    \"\\xfc\" => nil               , # cld\n    \"\\xfd\" => nil               , # std\n    \"\\xf8\" => nil               , # clc\n    \"\\xf9\" => nil               , # stc\n    \"\\xf5\" => nil               , # cmc\n    \"\\x98\" => [ 'eax'          ], # cwde\n    \"\\x9f\" => [ 'eax'          ], # lahf\n    \"\\x4a\" => [ 'edx'          ], # dec edx\n    \"\\x44\" => [ 'esp', 'align' ], # inc esp\n    \"\\x42\" => [ 'edx'          ], # inc edx\n    \"\\x43\" => [ 'ebx'          ], # inc ebx\n    \"\\x49\" => [ 'ecx'          ], # dec ecx\n    \"\\x4b\" => [ 'ebx'          ], # dec ebx\n    \"\\x45\" => [ 'ebp'          ], # inc ebp\n    \"\\x4c\" => [ 'esp', 'align' ], # dec esp\n    \"\\x9b\" => nil               , # wait\n    \"\\x60\" => [ 'esp'          ], # pusha\n    \"\\x0e\" => [ 'esp', 'align' ], # push cs\n    \"\\x1e\" => [ 'esp', 'align' ], # push ds\n    \"\\x50\" => [ 'esp'          ], # push eax\n    \"\\x55\" => [ 'esp'          ], # push ebp\n    \"\\x53\" => [ 'esp'          ], # push ebx\n    \"\\x51\" => [ 'esp'          ], # push ecx\n    \"\\x57\" => [ 'esp'          ], # push edi\n    \"\\x52\" => [ 'esp'          ], # push edx\n    \"\\x06\" => [ 'esp', 'align' ], # push es\n    \"\\x56\" => [ 'esp'          ], # push esi\n    \"\\x54\" => [ 'esp'          ], # push esp\n    \"\\x16\" => [ 'esp', 'align' ], # push ss\n    \"\\x58\" => [ 'esp', 'eax'   ], # pop eax\n    \"\\x5d\" => [ 'esp', 'ebp'   ], # pop ebp\n    \"\\x5b\" => [ 'esp', 'ebx'   ], # pop ebx\n    \"\\x59\" => [ 'esp', 'ecx'   ], # pop ecx\n    \"\\x5f\" => [ 'esp', 'edi'   ], # pop edi\n    \"\\x5a\" => [ 'esp', 'edx'   ], # pop edx\n    \"\\x5e\" => [ 'esp', 'esi'   ], # pop esi\n    \"\\xd6\" => [ 'eax'          ], # salc\n  }\n\n  def initialize\n    super(\n      'Name'        => 'Single Byte',\n      'Alias'       => 'ia32_singlebyte',\n      'Description' => 'Single-byte NOP generator',\n      'Author'      => 'spoonm',\n      'License'     => MSF_LICENSE,\n      'Arch'        => ARCH_X86)\n\n    register_advanced_options(\n      [\n        OptBool.new('RandomNops', [ false, \"Generate a random NOP sled\", true ])\n      ])\n  end\n\n  # Generate a single-byte NOP sled for X86\n  def generate_sled(length, opts = {})\n    sled_hash    = SINGLE_BYTE_SLED\n    sled_max_idx = sled_hash.length\n    sled_cur_idx = 0\n    out_sled     = ''\n\n    random   = opts['Random']\n    badchars = opts['BadChars']      || ''\n    badregs  = opts['SaveRegisters'] || []\n\n    # Did someone specify random NOPs in the environment?\n    if (!random and datastore['RandomNops'])\n      random = datastore['RandomNops']\n    end\n\n    # Generate the whole sled...\n    1.upto(length) { |current|\n\n      cur_char  = nil\n      threshold = 0\n\n      # Keep snagging characters until we find one that satisfies both the\n      # bad character and bad register requirements\n      begin\n        sled_cur_idx  = rand(sled_max_idx) if (random == true)\n        cur_char      = sled_hash.keys[sled_cur_idx]\n        sled_cur_idx += 1 if (random == false)\n        sled_cur_idx  = 0 if (sled_cur_idx >= sled_max_idx)\n\n        # Make sure that we haven't gone over the sled repeat threshold\n        if ((threshold += 1) > self.nop_repeat_threshold)\n          return nil\n        end\n\n      end while ((badchars.include?(cur_char)) or\n        ((sled_hash[cur_char]) and\n          ((sled_hash[cur_char] & badregs).length > 0)))\n\n      # Add the character to the sled now that it's passed our checks\n      out_sled += cur_char\n    }\n\n    # If the sled fails to entirely generate itself, then that's bogus,\n    # man...\n    if (out_sled.length != length)\n      return nil\n    end\n\n    return out_sled\n  end\nend\n"
}