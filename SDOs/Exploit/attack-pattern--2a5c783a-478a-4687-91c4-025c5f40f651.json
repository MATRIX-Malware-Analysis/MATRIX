{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2a5c783a-478a-4687-91c4-025c5f40f651",
    "created": "2024-08-14T16:33:19.19698Z",
    "modified": "2024-08-14T16:33:19.196984Z",
    "name": "SPARC NOP Generator",
    "description": "SPARC NOP generator",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/nops/sparc/random.rb",
            "external_id": "random.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n###\n#\n# SingleByte\n# ----------\n#\n# This class implements NOP generator for the SPARC platform\n#\n###\nclass MetasploitModule < Msf::Nop\n\n  # Nop types\n  InsSethi      = 0\n  InsArithmetic = 1\n  InsBranch     = 2\n\n  # Generator table\n  SPARC_Table = [\n    [ InsSethi, [ ], ],                       # sethi\n    [ InsArithmetic, [ 0, 0 ], ],             # add\n    [ InsArithmetic, [ 0, 1 ], ],             # and\n    [ InsArithmetic, [ 0, 2 ], ],             # or\n    [ InsArithmetic, [ 0, 3 ], ],             # xor\n    [ InsArithmetic, [ 0, 4 ], ],             # sub\n    [ InsArithmetic, [ 0, 5 ], ],             # andn\n    [ InsArithmetic, [ 0, 6 ], ],             # orn\n    [ InsArithmetic, [ 0, 7 ], ],             # xnor\n    [ InsArithmetic, [ 0, 8 ], ],             # addx\n    [ InsArithmetic, [ 0, 12 ], ],            # subx\n    [ InsArithmetic, [ 0, 16 ], ],            # addcc\n    [ InsArithmetic, [ 0, 17 ], ],            # andcc\n    [ InsArithmetic, [ 0, 18 ], ],            # orcc\n    [ InsArithmetic, [ 0, 19 ], ],            # xorcc\n    [ InsArithmetic, [ 0, 20 ], ],            # subcc\n    [ InsArithmetic, [ 0, 21 ], ],            # andncc\n    [ InsArithmetic, [ 0, 22 ], ],            # orncc\n    [ InsArithmetic, [ 0, 23 ], ],            # xnorcc\n    [ InsArithmetic, [ 0, 24 ], ],            # addxcc\n    [ InsArithmetic, [ 0, 28 ], ],            # subxcc\n    [ InsArithmetic, [ 0, 32 ], ],            # taddcc\n    [ InsArithmetic, [ 0, 33 ], ],            # tsubcc\n    [ InsArithmetic, [ 0, 36 ], ],            # mulscc\n    [ InsArithmetic, [ 2, 37 ], ],            # sll\n    [ InsArithmetic, [ 2, 38 ], ],            # srl\n    [ InsArithmetic, [ 2, 39 ], ],            # sra\n    [ InsArithmetic, [ 4, 40 ], ],            # rdy\n    [ InsArithmetic, [ 3, 48 ], ],            # wry\n    [ InsBranch, [ 0 ] ],                     # bn[,a]\n    [ InsBranch, [ 1 ] ],                     # be[,a]\n    [ InsBranch, [ 2 ] ],                     # ble[,a]\n    [ InsBranch, [ 3 ] ],                     # bl[,a]\n    [ InsBranch, [ 4 ] ],                     # bleu[,a]\n    [ InsBranch, [ 5 ] ],                     # bcs[,a]\n    [ InsBranch, [ 6 ] ],                     # bneg[,a]\n    [ InsBranch, [ 7 ] ],                     # bvs[,a]\n    [ InsBranch, [ 8 ] ],                     # ba[,a]\n    [ InsBranch, [ 9 ] ],                     # bne[,a]\n    [ InsBranch, [ 10 ] ],                    # bg[,a]\n    [ InsBranch, [ 11 ] ],                    # bge[,a]\n    [ InsBranch, [ 12 ] ],                    # bgu[,a]\n    [ InsBranch, [ 13 ] ],                    # bcc[,a]\n    [ InsBranch, [ 14 ] ],                    # bpos[,a]\n    [ InsBranch, [ 15 ] ],                    # bvc[,a]\n  ]\n\n  def initialize\n    super(\n      'Name'        => 'SPARC NOP Generator',\n      'Alias'       => 'sparc_simple',\n      'Description' => 'SPARC NOP generator',\n      'Author'      => 'vlad902',\n      'License'     => MSF_LICENSE,\n      'Arch'        => ARCH_SPARC)\n\n    register_advanced_options(\n      [\n        OptBool.new('RandomNops', [ false, \"Generate a random NOP sled\", true ])\n      ])\n  end\n\n\n\n  # Nops are always random...\n  def generate_sled(length, opts)\n\n    badchars = opts['BadChars'] || ''\n    random   = opts['Random']   || datastore['RandomNops']\n    blen     = length\n\n    buff  = ''\n    count = 0\n    while (buff.length < blen)\n      r = SPARC_Table[ rand(SPARC_Table.length) ]\n      t = ''\n\n      case r[0]\n        when InsSethi\n          t = ins_sethi(r[1], blen - buff.length)\n        when InsArithmetic\n          t = ins_arithmetic(r[1], blen - buff.length)\n        when InsBranch\n          t = ins_branch(r[1], blen - buff.length)\n        else\n          print_status(\"Invalid opcode type\")\n          raise RuntimeError\n      end\n\n      failed = false\n\n      t.each_byte do |c|\n        failed = true if badchars.include?(c.chr)\n      end\n\n      if (not failed)\n        buff << t\n        count = -100\n      end\n\n      if (count > length + 1000)\n        if(buff.length != 0)\n          return buff.slice(0, 4) * (blen / 4)\n        end\n        print_status(\"The SPARC nop generator could not create a usable sled\")\n        raise RuntimeError\n      end\n\n      count += 1\n    end\n\n    return buff\n  end\n\n  def get_dst_reg\n    reg = rand(30).to_i\n    reg += 1 if (reg >= 14)\t\t# %sp\n    reg += 1 if (reg >= 30)\t\t# %fp\n    return reg\n  end\n\n  def get_src_reg\n    return rand(32).to_i\n  end\n\n  def ins_sethi(ref, len=0)\n    [(get_dst_reg() << 25) | (4 << 22) | rand(1 << 22)].pack('N')\n  end\n\n  def ins_arithmetic(ref, len=0)\n    dst = get_dst_reg()\n    ver = ref[0]\n\n    # WRY fixups\n    if (ver == 3)\n      dst = 0\n      ver = 1\n    end\n\n    # 0, ~1, !2, ~3, !4\n    # Use one src reg with a signed 13-bit immediate (non-0)\n    if((ver == 0 && rand(2)) || ver == 1)\n      return [\n        (2 << 30)               |\n        (dst << 25)             |\n        (ref[1] << 19)          |\n        (get_src_reg() << 14)   |\n        (1 << 13)               |\n        (rand((1 << 13) - 1) + 1)\n      ].pack('N')\n    end\n\n    # ref[1] could be replaced with a static value since this only encodes for one function but it's done this way for\n    # conistancy/clarity.\n    if (ver == 4)\n      return [(2 << 30) | (dst << 25) | (ref[1] << 19)].pack('N')\n    end\n\n    # Use two src regs\n    return [\n      (2 << 30) |\n      (dst << 25) |\n      (ref[1] << 19) |\n      (get_src_reg() << 14) |\n      get_src_reg()\n    ].pack('N')\n  end\n\n  def ins_branch(ref, len)\n    # We jump to 1 instruction before the payload so in cases where the delay slot is another branch instruction that is\n    # not taken with the anull bit set the first bit of the payload is not anulled.\n    len = (len / 4) - 1\n\n    return '' if len == 0\n    len = 0x3fffff if (len >= 0x400000)\n\n    a = rand(2).floor\n    b = ref[0]\n    c = rand(len - 1).floor\n\n    return [\n      (a << 29)  |\n      (b << 25)  |\n      (2 << 22)  |\n      c + 1\n    ].pack('N')\n  end\nend\n"
}