{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a3ece5f3-5b17-4c9f-b5f2-fbdf8bec0671",
    "created": "2024-08-14T16:28:48.543063Z",
    "modified": "2024-08-14T16:28:48.543067Z",
    "name": "HTTP SOAP Verb/Noun Brute Force Scanner",
    "description": "( This module attempts to brute force SOAP/XML requests to uncover hidden methods. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/soap_xml.rb",
            "external_id": "soap_xml.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  # Exploit mixins should be called first\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::WmapScanDir\n  # Scanner mixin should be near last\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'HTTP SOAP Verb/Noun Brute Force Scanner',\n      'Description' => %q(\n        This module attempts to brute force SOAP/XML requests to uncover\n        hidden methods.\n      ),\n      'Author'      => ['aushack'],\n      'License'     => MSF_LICENSE))\n\n    register_options(\n      [\n        OptString.new('PATH', [true, 'The path to test', '/']),\n        OptString.new('XMLNAMESPACE', [true, 'XML Web Service Namespace', 'http://tempuri.org/']),\n        OptString.new('XMLINSTANCE', [true, 'XML Schema Instance', 'http://www.w3.org/2001/XMLSchema-instance']),\n        OptString.new('XMLSCHEMA', [true, 'XML Schema', 'http://www.w3.org/2001/XMLSchema']),\n        OptString.new('XMLSOAP', [true, 'XML SOAP', 'http://schemas.xmlsoap.org/soap/envelope/']),\n        OptString.new('CONTENTTYPE', [true, 'The HTTP Content-Type Header', 'application/x-www-form-urlencoded']),\n        OptInt.new('SLEEP', [true, 'Sleep this many milliseconds between requests', 0]),\n        OptBool.new('DISPLAYHTML', [true, 'Display HTML response', false]),\n        OptBool.new('SSL', [true, 'Use SSL', false]),\n        OptBool.new('VERB_DELETE', [false, 'Enable DELETE verb', false])\n      ])\n  end\n\n  # Fingerprint a single host\n  def run_host(ip)\n    verbs = %w(\n      get\n      active\n      activate\n      create\n      change\n      set\n      put\n      do\n      go\n      resolve\n      start\n      recover\n      initiate\n      negotiate\n      define\n      stop\n      begin\n      end\n      manage\n      administer\n      modify\n      register\n      log\n      add\n      list\n      query\n    )\n\n    verbs << 'delete' if datastore['VERB_DELETE']\n\n    nouns = %w(\n      password\n      task\n      tasks\n      pass\n      administration\n      account\n      accounts\n      admin\n      login\n      logins\n      token\n      tokens\n      credential\n      credentials\n      key\n      keys\n      guid\n      message\n      messages\n      user\n      users\n      username\n      usernames\n      load\n      list\n      name\n      names\n      file\n      files\n      path\n      paths\n      directory\n      directories\n      configuration\n      configurations\n      config\n      configs\n      setting\n      settings\n      registry\n      on\n      off\n    )\n\n    vhost = datastore['VHOST'] || wmap_target_host || ip\n\n    # regular expressions for common rejection messages\n    reject_regexen = []\n    reject_regexen << Regexp.new('method \\\\S+ is not valid', Regexp::IGNORECASE)\n    reject_regexen << Regexp.new('Method \\\\S+ not implemented', Regexp::IGNORECASE)\n    reject_regexen << Regexp.new('unable to resolve WSDL method name', Regexp::IGNORECASE)\n\n    print_status(\"Starting scan with #{datastore['SLEEP']}ms delay between requests\")\n    verbs.each do |v|\n      nouns.each do |n|\n        begin\n          data_parts = []\n          data_parts << '<?xml version=\"1.0\" encoding=\"utf-8\"?>'\n          data_parts << \"<soap:Envelope xmlns:xsi=\\\"#{datastore['XMLINSTANCE']}\\\" xmlns:xsd=\\\"#{datastore['XMLSCHEMA']}\\\" xmlns:soap=\\\"#{datastore['XMLSOAP']}\\\">\"\n          data_parts << '<soap:Body>'\n          data_parts << \"<#{v}#{n} xmlns=\\\"#{datastore['XMLNAMESPACE']}\\\">\"\n          data_parts << \"</#{v}#{n}>\"\n          data_parts << '</soap:Body>'\n          data_parts << '</soap:Envelope>'\n          data_parts << nil\n          data_parts << nil\n          data = data_parts.join(\"\\r\\n\")\n\n          uri = normalize_uri(datastore['PATH'])\n          uri += '/' unless uri =~ /^\\/$/\n          uri += v + n\n\n          vprint_status(\"Sending request #{uri} #{wmap_target_host}:#{datastore['RPORT']}\")\n\n          res = send_request_raw(\n            {\n              'uri'     => uri,\n              'method'  => 'POST',\n              'vhost'   => vhost,\n              'data'\t  => data,\n              'headers' =>\n                {\n                  'Content-Length' => data.length,\n                  'SOAPAction'\t => '\"' + datastore['XMLNAMESPACE'] + v + n + '\"',\n                  'Expect'\t => '100-continue',\n                  'Content-Type'\t => datastore['CONTENTTYPE']\n                }\n            }, 15)\n\n          if res && !(res.body.empty?)\n            if reject_regexen.any? { |r| res.body =~ r }\n              print_status(\"Server #{wmap_target_host}:#{datastore['RPORT']} rejected SOAPAction: #{v}#{n} with HTTP: #{res.code} #{res.message}.\")\n            elsif res.message =~ /Cannot process the message because the content type/\n              print_status(\"Server #{wmap_target_host}:#{datastore['RPORT']} rejected CONTENTTYPE: HTTP: #{res.code} #{res.message}.\")\n              res.message =~ /was not the expected type\\s\\'([^']+)'/\n              print_status(\"Set CONTENTTYPE to \\\"#{$1}\\\"\")\n              return false\n            elsif res.code == 404\n              print_status(\"Server #{wmap_target_host}:#{datastore['RPORT']} returned HTTP 404 for #{datastore['PATH']}.  Use a different one.\")\n              return false\n            else\n              print_good(\"Server #{wmap_target_host}:#{datastore['RPORT']} responded to SOAPAction: #{v}#{n} with HTTP: #{res.code} #{res.message}.\")\n              # Add Report\n              report_note(\n                host: ip,\n                proto: 'tcp',\n                sname: (ssl ? 'https' : 'http'),\n                port: rport,\n                type: \"SOAPAction: #{v}#{n}\",\n                data: \"SOAPAction: #{v}#{n} with HTTP: #{res.code} #{res.message}.\"\n              )\n              if datastore['DISPLAYHTML']\n                print_status('The HTML content follows:')\n                print_status(res.body + \"\\r\\n\")\n              end\n            end\n          end\n        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Timeout::Error, ::Errno::EPIPE => e\n          print_error(e.message)\n        ensure\n          Rex.sleep(sleep_time)\n        end\n      end\n    end\n  end\n\n  def sleep_time\n    datastore['SLEEP'] / 1000.0\n  end\nend\n"
}