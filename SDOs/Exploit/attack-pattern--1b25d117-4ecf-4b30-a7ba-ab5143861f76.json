{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1b25d117-4ecf-4b30-a7ba-ab5143861f76",
    "created": "2024-08-14T16:33:19.154513Z",
    "modified": "2024-08-14T16:33:19.154517Z",
    "name": "Generate TCP/UDP Outbound Traffic On Multiple Ports",
    "description": " This module generates TCP or UDP traffic across a sequence of ports, and is useful for finding firewall holes and egress filtering. It only generates traffic on the port range you specify. It is up to you to run a responder or packet capture tool on a remote endpoint to determine which ports are open.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/recon/multiport_egress_traffic.rb",
            "external_id": "multiport_egress_traffic.rb"
        }
    ],
    "x_code_snippet": "# -*- coding: binary -*-\n\n##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Generate TCP/UDP Outbound Traffic On Multiple Ports',\n        'Description' => %q{\n          This module generates TCP or UDP traffic across a\n          sequence of ports, and is useful for finding firewall\n          holes and egress filtering. It only generates traffic\n          on the port range you specify. It is up to you to\n          run a responder or packet capture tool on a remote\n          endpoint to determine which ports are open.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => 'Stuart Morgan <stuart.morgan[at]mwrinfosecurity.com>',\n        'Platform' => ['linux', 'osx', 'unix', 'solaris', 'bsd', 'windows'],\n        'SessionTypes' => ['meterpreter'],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptAddress.new('TARGET', [true, 'Destination IP address.']),\n        OptString.new('PORTS', [true, 'Ports to test.', '22,23,53,80,88,443,445,33434-33534']),\n        OptEnum.new('PROTOCOL', [true, 'Protocol to use.', 'TCP', [ 'TCP', 'UDP', 'ALL' ]]),\n        OptEnum.new('METHOD', [true, 'The mechanism by which the packets are generated. Can be NATIVE or WINAPI (Windows only).', 'NATIVE', [ 'NATIVE', 'WINAPI']]),\n        OptInt.new('THREADS', [true, 'Number of simultaneous threads/connections to try.', '20'])\n      ]\n    )\n  end\n\n  def winapi_create_socket(proto)\n    if proto == 'TCP'\n      client.railgun.ws2_32.socket('AF_INET', 'SOCK_STREAM', 'IPPROTO_TCP')\n    elsif proto == 'UDP'\n      client.railgun.ws2_32.socket('AF_INET', 'SOCK_DGRAM', 'IPPROTO_UDP')\n    end\n  end\n\n  def native_init_connect(proto, ip, port, num, gw)\n    vprint_status(\"[#{num}:NATIVE] Connecting to #{ip} port #{proto}/#{port}\")\n    if proto == 'TCP'\n      begin\n        Rex::Socket::Tcp.create(\n          'Comm' => gw,\n          'PeerHost' => ip,\n          'PeerPort' => port\n        )\n      rescue StandardError\n        vprint_status(\"[#{num}:NATIVE] Error connecting to #{ip} #{proto}/#{port}\")\n      end\n    elsif proto == 'UDP'\n      begin\n        rudp = Rex::Socket::Udp.create(\n          'Comm' => gw,\n          'PeerHost' => ip,\n          'PeerPort' => port\n        )\n        rudp.sendto('.', ip, port, 0) if rudp\n      rescue StandardError\n        vprint_status(\"[#{num}:NATIVE] Error connecting to #{ip} #{proto}/#{port}\")\n      end\n    end\n  end\n\n  def winapi_make_connection(remote, dst_port, socket_handle, proto)\n    sock_addr = \"\\x02\\x00\"\n    sock_addr << [dst_port].pack('n')\n    sock_addr << Rex::Socket.addr_aton(remote)\n    sock_addr << \"\\x00\" * 8\n    return client.railgun.ws2_32.connect(socket_handle, sock_addr, 16) if proto == 'TCP'\n    return client.railgun.ws2_32.sendto(socket_handle, '.', 0, 0, sock_addr, 16) if proto == 'UDP'\n  end\n\n  def run\n    type = datastore['METHOD']\n    remote = datastore['TARGET']\n    thread_num = datastore['THREADS']\n    proto = datastore['PROTOCOL']\n\n    unless client.type == 'meterpreter'\n      print_error('This module requires meterpreter')\n      return\n    end\n\n    # If we want WINAPI egress, make sure winsock is loaded\n    if type == 'WINAPI' && !(client.railgun.ws2_32 && client.platform == 'windows')\n      print_error('The WINAPI method requires Windows, railgun and support for winsock APIs. Try using the NATIVE method instead.')\n      return\n    end\n\n    unless [ARCH_X64, ARCH_X86].include?(client.arch)\n      print_error('This module cannot be used without native meterpreter at present')\n      return\n    end\n\n    ports = Rex::Socket.portspec_crack(datastore['PORTS'])\n\n    workload_ports = []\n    workload_cycle = 0\n    completed_cycle = false\n\n    if thread_num > 1\n      # Now we need to divvy up the ports into pots for each thread\n      while !ports.nil? && !ports.empty?\n\n        # If that group hasn't had its own ports array yet, give it some\n        workload_ports[workload_cycle] = [] if workload_ports[workload_cycle].nil?\n\n        # Add the port to the array to test\n        workload_ports[workload_cycle] << ports.shift\n\n        # Now increase the cycle until it goes above threads\n        workload_cycle += 1\n        if workload_cycle >= thread_num\n          completed_cycle = true\n          workload_cycle = 0\n        end\n\n      end\n\n      if completed_cycle == false && thread_num > workload_cycle\n        thread_num = workload_cycle\n        vprint_status(\"Reduced threads to #{thread_num}.\")\n      else\n        vprint_status(\"Number of threads: #{thread_num}.\")\n      end\n    end\n\n    gw = 0\n    if type == 'NATIVE' && !((gw = framework.sessions.get(datastore['SESSION'])) && gw.is_a?(Msf::Session::Comm))\n      print_error(\"Error getting session to route egress traffic through to #{remote}\")\n      return\n    end\n\n    str_proto = (proto == 'ALL') ? 'TCP and UDP' : proto\n\n    print_status(\"Generating #{str_proto} traffic to #{remote}...\")\n    if thread_num > 1\n      a = []\n      0.upto(thread_num - 1) do |num|\n        a << framework.threads.spawn(\"Module(#{refname})-#{remote}-#{proto}\", false, workload_ports[num]) do |portlist|\n          portlist.each do |dport|\n            egress(type, proto, remote, dport, num, gw)\n          end\n        end\n      end\n      a.map(&:join)\n    else\n      ports.each do |dport|\n        egress(type, proto, remote, dport, 1, gw)\n      end\n    end\n\n    print_status(\"#{str_proto} traffic generation to #{remote} completed.\")\n  end\n\n  # This will generate a single packet, selecting the correct methodology\n  def egress(type, proto, remote, dport, num, gw)\n    if type == 'WINAPI'\n      if proto == 'ALL'\n        winapi_egress_to_port('TCP', remote, dport, num)\n        winapi_egress_to_port('UDP', remote, dport, num)\n      else\n        winapi_egress_to_port(proto, remote, dport, num)\n      end\n    elsif type == 'NATIVE'\n      if proto == 'ALL'\n        native_init_connect('TCP', remote, dport, num, gw)\n        native_init_connect('UDP', remote, dport, num, gw)\n      else\n        native_init_connect(proto, remote, dport, num, gw)\n      end\n    end\n  end\n\n  # This will generate a packet on proto <proto> to IP <remote> on port <dport>\n  def winapi_egress_to_port(proto, remote, dport, num)\n    socket_handle = winapi_create_socket(proto)\n    if socket_handle['return'] == 0\n      vprint_status(\"[#{num}:WINAPI] Error setting up socket for #{remote}; Error: #{socket_handle['GetLastError']}\")\n      return\n    else\n      vprint_status(\"[#{num}:WINAPI] Set up socket for #{remote} port #{proto}/#{dport} (Handle: #{socket_handle['return']})\")\n    end\n\n    vprint_status(\"[#{num}:WINAPI] Connecting to #{remote}:#{proto}/#{dport}\")\n    r = winapi_make_connection(remote, dport, socket_handle['return'], proto)\n    if r['GetLastError'] == 0\n      vprint_good(\"[#{num}:WINAPI] Connection packet sent successfully #{proto}/#{dport}\")\n    else\n      vprint_bad(\"[#{num}:WINAPI] There was an error sending a connect packet for #{proto} socket (port #{dport}) Error: #{r['GetLastError']}\")\n    end\n\n    client.railgun.ws2_32.closesocket(socket_handle['return'])\n  end\nend\n",
    "x_mitre_platforms": [
        "['linux', 'osx', 'unix', 'solaris', 'bsd', 'windows']"
    ]
}