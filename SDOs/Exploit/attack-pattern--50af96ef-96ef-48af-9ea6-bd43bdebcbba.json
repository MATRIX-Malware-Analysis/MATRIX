{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--50af96ef-96ef-48af-9ea6-bd43bdebcbba",
    "created": "2024-08-14T16:31:31.35466Z",
    "modified": "2024-08-14T16:31:31.354664Z",
    "name": "DNS Record Scanner and Enumerator",
    "description": "( This module can be used to gather information about a domain from a given DNS server by performing various DNS queries such as zone transfers, reverse lookups, SRV record brute forcing, and other techniques. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/enum_dns.rb",
            "external_id": "enum_dns.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "1999-0532"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::DNS::Enumeration\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'DNS Record Scanner and Enumerator',\n      'Description'    => %q(\n        This module can be used to gather information about a domain from a\n        given DNS server by performing various DNS queries such as zone\n        transfers, reverse lookups, SRV record brute forcing, and other techniques.\n    ),\n      'Author'         => [\n        'Carlos Perez <carlos_perez[at]darkoperator.com>',\n        'Nixawk'\n      ],\n      'License'        => MSF_LICENSE,\n      'References'     => [\n        ['CVE', '1999-0532'],\n        ['OSVDB', '492']\n      ]))\n\n    register_options(\n      [\n        OptString.new('DOMAIN', [true, 'The target domain']),\n        OptBool.new('ENUM_AXFR', [true, 'Initiate a zone transfer against each NS record', true]),\n        OptBool.new('ENUM_BRT', [true, 'Brute force subdomains and hostnames via the supplied wordlist', false]),\n        OptBool.new('ENUM_A', [true, 'Enumerate DNS A record', true]),\n        OptBool.new('ENUM_CNAME', [true, 'Enumerate DNS CNAME record', true]),\n        OptBool.new('ENUM_MX', [true, 'Enumerate DNS MX record', true]),\n        OptBool.new('ENUM_NS', [true, 'Enumerate DNS NS record', true]),\n        OptBool.new('ENUM_SOA', [true, 'Enumerate DNS SOA record', true]),\n        OptBool.new('ENUM_TXT', [true, 'Enumerate DNS TXT record', true]),\n        OptBool.new('ENUM_RVL', [ true, 'Reverse lookup a range of IP addresses', false]),\n        OptBool.new('ENUM_TLD', [true, 'Perform a TLD expansion by replacing the TLD with the IANA TLD list', false]),\n        OptBool.new('ENUM_SRV', [true, 'Enumerate the most common SRV records', true]),\n        OptBool.new('STOP_WLDCRD', [true, 'Stops bruteforce enumeration if wildcard resolution is detected', false]),\n        OptAddressRange.new('IPRANGE', [false, \"The target address range or CIDR identifier\"]),\n        OptInt.new('THREADS', [false, 'Threads for ENUM_BRT', 1]),\n        OptPath.new('WORDLIST', [false, 'Wordlist of subdomains', ::File.join(Msf::Config.data_directory, 'wordlists', 'namelist.txt')])\n      ])\n\n    register_advanced_options(\n      [\n        OptInt.new('TIMEOUT', [false, 'DNS TIMEOUT', 8]),\n        OptInt.new('RETRY', [false, 'Number of times to try to resolve a record if no response is received', 2]),\n        OptInt.new('RETRY_INTERVAL', [false, 'Number of seconds to wait before doing a retry', 2]),\n        OptBool.new('TCP_DNS', [false, 'Run queries over TCP', false])\n      ])\n    deregister_options('DnsClientUdpTimeout', 'DnsClientRetry', 'DnsClientRetryInterval', 'DnsClientTcpDns')\n  end\n\n  def run\n    datastore['DnsClientUdpTimeout'] = datastore['TIMEOUT']\n    datastore['DnsClientRetry'] = datastore['RETRY']\n    datastore['DnsClientRetryInterval'] = datastore['RETRY_INTERVAL']\n    datastore['DnsClientTcpDns'] = datastore['TCP_DNS']\n\n    begin\n      setup_resolver\n    rescue RuntimeError => e\n      fail_with(Failure::BadConfig, \"Resolver setup failed - exception: #{e}\")\n    end\n\n    domain = datastore['DOMAIN']\n    is_wildcard = dns_wildcard_enabled?(domain)\n\n    # All exceptions should be being handled by the library\n    # but catching here as well, just in case.\n    begin\n      dns_axfr(domain) if datastore['ENUM_AXFR']\n    rescue => e\n      print_error(\"AXFR failed: #{e}\")\n    end\n    dns_get_a(domain) if datastore['ENUM_A']\n    dns_get_cname(domain) if datastore['ENUM_CNAME']\n    dns_get_ns(domain) if datastore['ENUM_NS']\n    dns_get_mx(domain) if datastore['ENUM_MX']\n    dns_get_soa(domain) if datastore['ENUM_SOA']\n    dns_get_txt(domain) if datastore['ENUM_TXT']\n    dns_get_tld(domain) if datastore['ENUM_TLD']\n    dns_get_srv(domain) if datastore['ENUM_SRV']\n    threads = datastore['THREADS']\n    dns_reverse(datastore['IPRANGE'], threads) if datastore['ENUM_RVL']\n\n    return unless datastore['ENUM_BRT']\n    if is_wildcard\n      dns_bruteforce(domain, datastore['WORDLIST'], threads) unless datastore['STOP_WLDCRD']\n    else\n      dns_bruteforce(domain, datastore['WORDLIST'], threads)\n    end\n  end\n\n  def save_note(target, type, records)\n    data = { 'target' => target, 'records' => records }\n    report_note(host: target, sname: 'dns', type: type, data: data, update: :unique_data)\n  end\nend\n"
}