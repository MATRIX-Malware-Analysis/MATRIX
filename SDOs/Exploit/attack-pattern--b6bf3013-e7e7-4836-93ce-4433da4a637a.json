{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b6bf3013-e7e7-4836-93ce-4433da4a637a",
    "created": "2024-08-14T16:31:22.453518Z",
    "modified": "2024-08-14T16:31:22.453522Z",
    "name": "TCP ACK Firewall Scanner",
    "description": " Map out firewall rulesets with a raw ACK scan.  Any unfiltered ports found means a stateful firewall is not in place for them. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/portscan/ack.rb",
            "external_id": "ack.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Capture\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'TCP ACK Firewall Scanner',\n      'Description' => %q{\n        Map out firewall rulesets with a raw ACK scan.  Any\n        unfiltered ports found means a stateful firewall is\n        not in place for them.\n      },\n      'Author'      => 'kris katterjohn',\n      'License'     => MSF_LICENSE\n    )\n\n    register_options([\n      OptString.new('PORTS', [true, \"Ports to scan (e.g. 22-25,80,110-900)\", \"1-10000\"]),\n      OptInt.new('TIMEOUT', [true, \"The reply read timeout in milliseconds\", 500]),\n      OptInt.new('BATCHSIZE', [true, \"The number of hosts to scan per set\", 256]),\n      OptInt.new('DELAY', [true, \"The delay between connections, per thread, in milliseconds\", 0]),\n      OptInt.new('JITTER', [true, \"The delay jitter factor (maximum value by which to +/- DELAY) in milliseconds.\", 0]),\n      OptString.new('INTERFACE', [false, 'The name of the interface'])\n    ])\n\n    deregister_options('FILTER','PCAPFILE')\n  end\n\n  # No IPv6 support yet\n  def support_ipv6?\n    false\n  end\n\n  def run_batch_size\n    datastore['BATCHSIZE'] || 256\n  end\n\n  def run_batch(hosts)\n\n    ports = Rex::Socket.portspec_crack(datastore['PORTS'])\n    if ports.empty?\n      raise Msf::OptionValidateError.new(['PORTS'])\n    end\n\n    jitter_value = datastore['JITTER'].to_i\n    if jitter_value < 0\n      raise Msf::OptionValidateError.new(['JITTER'])\n    end\n\n    delay_value = datastore['DELAY'].to_i\n    if delay_value < 0\n      raise Msf::OptionValidateError.new(['DELAY'])\n    end\n\n    open_pcap\n\n    pcap = self.capture\n\n    to = (datastore['TIMEOUT'] || 500).to_f / 1000.0\n\n    # we copy the hosts because some may not be reachable and need to be ejected\n    host_queue = hosts.dup\n    # Spread the load across the hosts\n    ports.each do |dport|\n      host_queue.each do |dhost|\n        shost, sport = getsource(dhost)\n\n        pcap.setfilter(getfilter(shost, sport, dhost, dport))\n\n        # Add the delay based on JITTER and DELAY if needs be\n        add_delay_jitter(delay_value,jitter_value)\n\n        begin\n          probe = buildprobe(shost, sport, dhost, dport)\n\n          unless capture_sendto(probe, dhost)\n            host_queue.delete(dhost)\n            next\n          end\n\n          reply = probereply(pcap, to)\n\n          next if not reply\n\n          print_status(\" TCP UNFILTERED #{dhost}:#{dport}\")\n\n          #Add Report\n          report_note(\n            :host\t=> dhost,\n            :proto\t=> 'tcp',\n            :port\t=> dport,\n            :type\t=> \"TCP UNFILTERED #{dhost}:#{dport}\",\n            :data\t=> \"TCP UNFILTERED #{dhost}:#{dport}\"\n          )\n\n        rescue ::Exception\n          print_error(\"Error: #{$!.class} #{$!}\")\n        end\n      end\n    end\n\n    close_pcap\n  end\n\n  def getfilter(shost, sport, dhost, dport)\n    # Look for associated RSTs\n    \"tcp and (tcp[13] & 0x04) != 0 and \" +\n    \"src host #{dhost} and src port #{dport} and \" +\n    \"dst host #{shost} and dst port #{sport}\"\n  end\n\n  def getsource(dhost)\n    # srcip, srcport\n    [ Rex::Socket.source_address(dhost), rand(0xffff - 1025) + 1025 ]\n  end\n\n  def buildprobe(shost, sport, dhost, dport)\n    p = PacketFu::TCPPacket.new\n    p.ip_saddr = shost\n    p.ip_daddr = dhost\n    p.tcp_sport = sport\n    p.tcp_ack = rand(0x100000000)\n    p.tcp_flags.ack = 1\n    p.tcp_dport = dport\n    p.tcp_win = 3072\n    p.recalc\n    p\n  end\n\n  def probereply(pcap, to)\n    reply = nil\n    begin\n      Timeout.timeout(to) do\n        pcap.each do |r|\n          pkt = PacketFu::Packet.parse(r)\n          next unless pkt.is_tcp?\n          reply = pkt\n          break\n        end\n      end\n    rescue Timeout::Error\n    end\n    return reply\n  end\nend\n"
}