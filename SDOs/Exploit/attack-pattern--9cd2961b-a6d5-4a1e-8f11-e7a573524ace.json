{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9cd2961b-a6d5-4a1e-8f11-e7a573524ace",
    "created": "2024-08-14T16:31:24.842426Z",
    "modified": "2024-08-14T16:31:24.84243Z",
    "name": "Hardware Bridge Session Connector",
    "description": " The Hardware Bridge (HWBridge) is a standardized method for Metasploit to interact with Hardware Devices.  This extends the normal exploit capabilities to the non-ethernet realm and enables direct hardware and alternative bus manipulations.  You must have compatible bridging hardware attached to this machine or reachable on your network to use any HWBridge exploits.  Use this exploit module to connect the physical HWBridge which will start an interactive hwbridge session.  You can launch a hwbridge server locally by using compliant hardware and executing the local_hwbridge",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/client/hwbridge/connect.rb",
            "external_id": "connect.rb"
        },
        {
            "source_name": "reference",
            "url": "http://opengarages.org/hwbridge#TODO"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n\n\n  def initialize(info={})\n    super( update_info( info, {\n        'Name'          => 'Hardware Bridge Session Connector',\n        'Description'   => %q{\n          The Hardware Bridge (HWBridge) is a standardized method for\n          Metasploit to interact with Hardware Devices.  This extends\n          the normal exploit capabilities to the non-ethernet realm and\n          enables direct hardware and alternative bus manipulations.  You\n          must have compatible bridging hardware attached to this machine or\n          reachable on your network to use any HWBridge exploits.\n\n          Use this exploit module to connect the physical HWBridge which\n          will start an interactive hwbridge session.  You can launch a hwbridge\n          server locally by using compliant hardware and executing the local_hwbridge\n          module.  After that module has started, pass the HWBRIDGE_BASE_URL\n          options to this connector module.\n        },\n        'License'       => MSF_LICENSE,\n        'Author'        =>\n          [\n            'Craig Smith'                       # hwbridge metaspliot module\n          ],\n        'Session'       => Msf::Sessions::HWBridge,\n        'SessionTypes'  => [ 'hwbridge' ],\n        'References'    =>\n          [\n            [ 'URL', 'http://opengarages.org/hwbridge' ]  # TODO\n          ]\n      }\n      ))\n    register_options(\n      [\n        Opt::RPORT(8080),\n        Opt::RHOST('127.0.0.1'),\n        OptBool.new('DEBUGJSON', [false, \"Additional debugging out for JSON requests to HW Bridge\", false]),\n        OptString.new('TARGETURI', [ true, \"The path to the hwbridge API\", '/'])\n      ],\n      self.class\n    )\n    @last_access = nil\n  end\n\n  #\n  # Generic fetch json call. returns hash of json\n  #\n  def fetch_json(uri)\n    tpath = normalize_uri(\"#{datastore['TARGETURI']}/#{uri}\")\n    res = send_request_cgi({\n      'uri' => tpath,\n      'method' => 'GET'\n    })\n    return nil if !res || !res.body || !res.code\n    if res.code == 200\n      print_status res.body if datastore['DEBUGJSON'] == true\n      return JSON.parse(res.body)\n    elsif res.code == 401\n      print_error \"Access Denied: #{res.body}\"\n    end\n    return nil\n\n    rescue OpenSSL::SSL::SSLError\n      vprint_error(\"SSL error\")\n      return nil\n    rescue Errno::ENOPROTOOPT, Errno::ECONNRESET, ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::ArgumentError\n      vprint_error(\"Unable to Connect\")\n      return nil\n    rescue ::Timeout::Error, ::Errno::EPIPE\n      vprint_error(\"Timeout error\")\n      return nil\n\n  end\n\n  #\n  # Disclaimer for legal and those without common sense...\n  #\n  def print_disclaimer\n    print_warning(\"NOTICE:  You are about to leave the matrix.  All actions performed on this hardware bridge\")\n    print_warning(\"         could have real world consequences.  Use this module in a controlled testing\")\n    print_warning(\"         environment and with equipment you are authorized to perform testing on.\")\n  end\n\n  #\n  # Uses status information to automatically load proper extensions\n  #\n  def autoload_extensions(sess)\n    if self.hw_specialty.key? 'automotive'\n      sess.load_automotive if self.hw_specialty['automotive'] == true\n    end\n    if self.hw_specialty.has_key? 'zigbee'\n      sess.load_zigbee if self.hw_specialty['zigbee'] == true\n    end\n    if self.hw_specialty.has_key? 'rftransceiver'\n      sess.load_rftransceiver if self.hw_specialty['rftransceiver'] == true\n    end\n    sess.api_version = self.api_version if self.api_version\n    sess.fw_version = self.fw_version if self.fw_version\n    sess.hw_version = self.hw_version if self.hw_version\n    sess.device_name = self.device_name if self.device_name\n  end\n\n  #\n  # If the hardware contains custom methods, create functions for those\n  #\n  def load_custom_methods(sess)\n    if self.hw_capabilities.key? 'custom_methods'\n      sess.load_custom_methods if self.hw_capabilities['custom_methods'] == true\n    end\n  end\n\n  #\n  # Fetches the status of the hwbridge\n  #\n  def get_status\n    data = fetch_json(\"/status\")\n    unless data.nil?\n      if data.key? 'operational'\n        @last_access = Time.now\n        if data.key? 'hw_specialty'\n          self.hw_specialty = data['hw_specialty']\n        end\n        if data.key? 'hw_capabilities'\n          self.hw_capabilities = data['hw_capabilities']\n        end\n        if data.key? 'api_version'\n          self.api_version = data['api_version']\n        end\n        if data.key? 'fw_version'\n          self.fw_version = data['fw_version']\n        end\n        if data.key? 'hw_vesrion'\n          self.hw_version = data['hw_version']\n        end\n        if data.key? 'device_name'\n          self.device_name = data['device_name']\n        end\n      end\n    end\n  end\n\n  def run\n    print_status \"Attempting to connect to #{datastore['RHOST']}...\"\n    self.get_status()\n    unless @last_access.nil?\n      sess = Msf::Sessions::HWBridge.new(self)\n      sess.set_from_exploit(self)\n\n      framework.sessions.register(sess)\n      print_good \"HWBridge session established\"\n      autoload_extensions(sess)\n      load_custom_methods(sess)\n      print_status \"HW Specialty: #{self.hw_specialty}  Capabilities: #{self.hw_capabilities}\"\n      print_disclaimer\n    else\n      print_error \"Could not connect to API\"\n    end\n  end\n\n  attr_reader :hw_specialty\n  attr_reader :hw_capabilities\n  attr_reader :api_version\n  attr_reader :fw_version\n  attr_reader :hw_version\n  attr_reader :device_name\n\n  protected\n\n  attr_writer :hw_specialty\n  attr_writer :hw_capabilities\n  attr_writer :api_version\n  attr_writer :fw_version\n  attr_writer :hw_version\n  attr_writer :device_name\nend\n",
    "x_mitre_contributors": [
        ""
    ]
}