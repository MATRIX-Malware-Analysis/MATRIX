{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--72d3275c-9a79-46c8-a63c-bbdcf73ad1bc",
    "created": "2024-08-14T16:26:32.031342Z",
    "modified": "2024-08-14T16:26:32.031346Z",
    "name": "UDP Service Sweeper",
    "description": "Detect interesting UDP services",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/discovery/udp_sweep.rb",
            "external_id": "udp_sweep.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'openssl'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::UDPScanner\n\n  def initialize\n    super(\n      'Name'        => 'UDP Service Sweeper',\n      'Description' => 'Detect interesting UDP services',\n      'Author'      => 'hdm',\n      'License'     => MSF_LICENSE\n    )\n\n    register_advanced_options(\n    [\n      OptBool.new('RANDOMIZE_PORTS', [false, 'Randomize the order the ports are probed', true])\n    ])\n\n    # RPORT is required by UDPScanner but not used in this module since it\n    # works with multiple ports.\n    # TODO: update this module to simply use Scanner or update UDPScanner to support\n    # multiple ports.\n    deregister_options('RPORT')\n\n    # Initialize the probes array\n    @probes = []\n\n    # Add the UDP probe method names\n    @probes << 'probe_pkt_dns'\n    @probes << 'probe_pkt_netbios'\n    @probes << 'probe_pkt_portmap'\n    @probes << 'probe_pkt_mssql'\n    @probes << 'probe_pkt_ntp'\n    @probes << 'probe_pkt_snmp1'\n    @probes << 'probe_pkt_snmp2'\n    @probes << 'probe_pkt_sentinel'\n    @probes << 'probe_pkt_db2disco'\n    @probes << 'probe_pkt_citrix'\n    @probes << 'probe_pkt_pca_st'\n    @probes << 'probe_pkt_pca_nq'\n    @probes << 'probe_chargen'\n  end\n\n  def setup\n    super\n\n    if datastore['RANDOMIZE_PORTS']\n      @probes = @probes.sort_by { rand }\n    end\n  end\n\n  def scanner_prescan(batch)\n    print_status(\"Sending #{@probes.length} probes to #{batch[0]}->#{batch[-1]} (#{batch.length} hosts)\")\n    @results = {}\n  end\n\n  def scan_host(ip)\n    @probes.each do |probe|\n      data, port = self.send(probe, ip)\n      scanner_send(data, ip, port)\n    end\n  end\n\n  def scanner_postscan(batch)\n    @results.each_key do |k|\n      next if not @results[k].respond_to?('keys')\n      data = @results[k]\n\n      conf = {\n        :host  => data[:host],\n        :port  => data[:port],\n        :proto => 'udp',\n        :name  => data[:app],\n        :info  => data[:info]\n      }\n\n      if data[:hname]\n        conf[:host_name] = data[:hname].downcase\n      end\n\n      if data[:mac]\n        conf[:mac] = data[:mac].downcase\n      end\n\n      report_service(conf)\n      print_good(\"Discovered #{data[:app]} on #{k} (#{data[:info]})\")\n    end\n  end\n\n\n  def scanner_process(data, shost, sport)\n\n    hkey  = \"#{shost}:#{sport}\"\n    app   = 'unknown'\n    inf   = ''\n    maddr = nil\n    hname = nil\n\n    # Work with protocols that return different data in different packets\n    # These are reported at the end of the scanning loop to build state\n    case sport\n      when 5632\n\n        @results[hkey] ||= {}\n        data = @results[hkey]\n        data[:app]  = \"pcAnywhere_stat\"\n        data[:port] = sport\n        data[:host] = shost\n\n        case data\n\n        when /^NR(........................)(........)/\n          name = $1.dup\n          caps = $2.dup\n          name = name.gsub(/_+$/, '').gsub(\"\\x00\", '').strip\n          caps = caps.gsub(/_+$/, '').gsub(\"\\x00\", '').strip\n          data[:name] = name\n          data[:caps] = caps\n\n        when /^ST(.+)/\n          buff = $1.dup\n          stat = 'Unknown'\n\n          if buff[2,1].unpack(\"C\")[0] == 67\n            stat = \"Available\"\n          end\n\n          if buff[2,1].unpack(\"C\")[0] == 11\n            stat = \"Busy\"\n          end\n\n          data[:stat] = stat\n        end\n\n        if data[:name]\n          inf << \"Name: #{data[:name]} \"\n        end\n\n        if data[:stat]\n          inf << \"- #{data[:stat]} \"\n        end\n\n        if data[:caps]\n          inf << \"( #{data[:caps]} ) \"\n        end\n        data[:info] = inf\n    end\n\n    # Ignore duplicates\n    return if @results[hkey]\n\n    case sport\n\n      when 19\n        app = 'chargen'\n        ver = nil\n        return unless chargen_parse(data)\n        @results[hkey] = true\n\n      when 53\n        app = 'DNS'\n        ver = nil\n\n        if (not ver and data =~ /([6789]\\.[\\w\\.\\-_\\:\\(\\)\\[\\]\\/\\=\\+\\|\\{\\}]+)/i)\n          ver = 'BIND ' + $1\n        end\n\n        ver = 'Microsoft DNS' if (not ver and data[2,4] == \"\\x81\\x04\\x00\\x01\")\n        ver = 'TinyDNS'       if (not ver and data[2,4] == \"\\x81\\x81\\x00\\x01\")\n\n        ver = data.unpack('H*')[0] if not ver\n        inf = ver if ver\n\n        @results[hkey] = true\n\n      when 137\n        app = 'NetBIOS'\n\n        buff = data.dup\n\n        head = buff.slice!(0,12)\n\n        xid, flags, quests, answers, auths, adds = head.unpack('n6')\n        return if quests != 0\n        return if answers == 0\n\n        qname = buff.slice!(0,34)\n        rtype,rclass,rttl,rlen = buff.slice!(0,10).unpack('nnNn')\n        bits = buff.slice!(0,rlen)\n\n        names = []\n\n        case rtype\n        when 0x21\n          rcnt = bits.slice!(0,1).unpack(\"C\")[0]\n          1.upto(rcnt) do\n            tname = bits.slice!(0,15).gsub(/\\x00.*/, '').strip\n            ttype = bits.slice!(0,1).unpack(\"C\")[0]\n            tflag = bits.slice!(0,2).unpack('n')[0]\n            names << [ tname, ttype, tflag ]\n          end\n          maddr = bits.slice!(0,6).unpack(\"C*\").map{|c| \"%.2x\" % c }.join(\":\")\n\n          names.each do |name|\n            inf << name[0]\n            inf << \":<%.2x>\" % name[1]\n            if (name[2] & 0x8000 == 0)\n              inf << \":U :\"\n            else\n              inf << \":G :\"\n            end\n          end\n          inf << maddr\n\n          if(names.length > 0)\n            hname = names[0][0]\n          end\n        end\n\n        @results[hkey] = true\n\n      when 111\n        app = 'Portmap'\n        buf = data\n        inf = \"\"\n        hed = buf.slice!(0,24)\n        svc = []\n        while(buf.length >= 20)\n          rec = buf.slice!(0,20).unpack(\"N5\")\n          svc << \"#{rec[1]} v#{rec[2]} #{rec[3] == 0x06 ? \"TCP\" : \"UDP\"}(#{rec[4]})\"\n          report_service(\n            :host => shost,\n            :port => rec[4],\n            :proto => (rec[3] == 0x06 ? \"tcp\" : \"udp\"),\n            :name => \"sunrpc\",\n            :info => \"#{rec[1]} v#{rec[2]}\",\n            :state => \"open\"\n          )\n        end\n        inf = svc.join(\", \")\n\n        @results[hkey] = true\n\n      when 123\n        app = 'NTP'\n        ver = nil\n        ver = data.unpack('H*')[0]\n        ver = 'NTP v3'                  if (ver =~ /^1c06|^1c05/)\n        ver = 'NTP v4'                  if (ver =~ /^240304/)\n        ver = 'NTP v4 (unsynchronized)' if (ver =~ /^e40/)\n        ver = 'Microsoft NTP'           if (ver =~ /^dc00|^dc0f/)\n        inf = ver if ver\n\n        @results[hkey] = true\n\n      when 1434\n        app = 'MSSQL'\n        mssql_ping_parse(data).each_pair { |k,v|\n          inf += k+'='+v+' '\n        }\n\n        @results[hkey] = true\n\n      when 161\n        app = 'SNMP'\n        asn = OpenSSL::ASN1.decode(data) rescue nil\n        return if not asn\n\n        snmp_error = asn.value[0].value rescue nil\n        snmp_comm  = asn.value[1].value rescue nil\n        snmp_data  = asn.value[2].value[3].value[0] rescue nil\n        snmp_oid   = snmp_data.value[0].value rescue nil\n        snmp_info  = snmp_data.value[1].value rescue nil\n\n        return if not (snmp_error and snmp_comm and snmp_data and snmp_oid and snmp_info)\n        snmp_info = snmp_info.to_s.gsub(/\\s+/, ' ')\n\n        inf = snmp_info\n        com = snmp_comm\n\n        @results[hkey] = true\n\n      when 5093\n        app = 'Sentinel'\n        @results[hkey] = true\n\n      when 523\n        app = 'ibm-db2'\n        inf = db2disco_parse(data)\n        @results[hkey] = true\n\n      when 1604\n        app = 'citrix-ica'\n        return unless citrix_parse(data)\n        @results[hkey] = true\n\n    end\n\n    report_service(\n      :host  => shost,\n      :mac   => (maddr and maddr != '00:00:00:00:00:00') ? maddr : nil,\n      :host_name => (hname) ? hname.downcase : nil,\n      :port  => sport,\n      :proto => 'udp',\n      :name  => app,\n      :info  => inf,\n      :state => \"open\"\n    )\n\n    print_status(\"Discovered #{app} on #{shost}:#{sport} (#{inf})\")\n  end\n\n  #\n  # Validate a chargen packet.\n  #\n  def chargen_parse(data)\n    data =~ /ABCDEFGHIJKLMNOPQRSTUVWXYZ|0123456789/i\n  end\n\n  #\n  # Parse a db2disco packet.\n  #\n  def db2disco_parse(data)\n    res = data.split(\"\\x00\")\n    \"#{res[2]}_#{res[1]}\"\n  end\n\n  #\n  # Validate this is truly Citrix ICA; returns true or false.\n  #\n  def citrix_parse(data)\n    server_response = \"\\x30\\x00\\x02\\x31\\x02\\xfd\\xa8\\xe3\\x02\\x00\\x06\\x44\" # Server hello response\n    data =~ /^#{server_response}/\n  end\n\n  #\n  # Parse a 'ping' response and format as a hash\n  #\n  def mssql_ping_parse(data)\n    res = {}\n    var = nil\n    idx = data.index('ServerName')\n    return res if not idx\n\n    data[idx, data.length-idx].split(';').each do |d|\n      if (not var)\n        var = d\n      else\n        if (var.length > 0)\n          res[var] = d\n          var = nil\n        end\n      end\n    end\n\n    return res\n  end\n\n  #\n  # The probe definitions\n  #\n\n  def probe_chargen(ip)\n    pkt = Rex::Text.rand_text_alpha_lower(1)\n    return [pkt, 19]\n  end\n\n  def probe_pkt_dns(ip)\n    data = [rand(0xffff)].pack('n') +\n    \"\\x01\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\"+\n    \"\\x07\"+ \"VERSION\"+\n    \"\\x04\"+ \"BIND\"+\n    \"\\x00\\x00\\x10\\x00\\x03\"\n\n    return [data, 53]\n  end\n\n  def probe_pkt_netbios(ip)\n    data =\n    [rand(0xffff)].pack('n')+\n    \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\"+\n    \"\\x00\\x00\\x20\\x43\\x4b\\x41\\x41\\x41\"+\n    \"\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\"+\n    \"\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\"+\n    \"\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\"+\n    \"\\x41\\x41\\x41\\x00\\x00\\x21\\x00\\x01\"\n\n    return [data, 137]\n  end\n\n  def probe_pkt_portmap(ip)\n    data =\n    [\n      rand(0xffffffff), # XID\n      0,              # Type\n      2,              # RPC Version\n      100000,         # Program ID\n      2,              # Program Version\n      4,              # Procedure\n      0, 0,   # Credentials\n      0, 0,   # Verifier\n    ].pack('N*')\n\n    return [data, 111]\n  end\n\n  def probe_pkt_mssql(ip)\n    return [\"\\x02\", 1434]\n  end\n\n  def probe_pkt_ntp(ip)\n    data =\n      \"\\xe3\\x00\\x04\\xfa\\x00\\x01\\x00\\x00\\x00\\x01\\x00\\x00\\x00\" +\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" +\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" +\n      \"\\x00\\xc5\\x4f\\x23\\x4b\\x71\\xb1\\x52\\xf3\"\n    return [data, 123]\n  end\n\n\n  def probe_pkt_sentinel(ip)\n    return [\"\\x7a\\x00\\x00\\x00\\x00\\x00\", 5093]\n  end\n\n  def probe_pkt_snmp1(ip)\n    version = 1\n    data = OpenSSL::ASN1::Sequence([\n      OpenSSL::ASN1::Integer(version - 1),\n      OpenSSL::ASN1::OctetString(\"public\"),\n      OpenSSL::ASN1::Set.new([\n        OpenSSL::ASN1::Integer(rand(0x80000000)),\n        OpenSSL::ASN1::Integer(0),\n        OpenSSL::ASN1::Integer(0),\n        OpenSSL::ASN1::Sequence([\n          OpenSSL::ASN1::Sequence([\n            OpenSSL::ASN1.ObjectId(\"1.3.6.1.2.1.1.1.0\"),\n            OpenSSL::ASN1.Null(nil)\n          ])\n        ]),\n      ], 0, :IMPLICIT)\n    ]).to_der\n    [data, 161]\n  end\n\n  def probe_pkt_snmp2(ip)\n    version = 2\n    data = OpenSSL::ASN1::Sequence([\n      OpenSSL::ASN1::Integer(version - 1),\n      OpenSSL::ASN1::OctetString(\"public\"),\n      OpenSSL::ASN1::Set.new([\n        OpenSSL::ASN1::Integer(rand(0x80000000)),\n        OpenSSL::ASN1::Integer(0),\n        OpenSSL::ASN1::Integer(0),\n        OpenSSL::ASN1::Sequence([\n          OpenSSL::ASN1::Sequence([\n            OpenSSL::ASN1.ObjectId(\"1.3.6.1.2.1.1.1.0\"),\n            OpenSSL::ASN1.Null(nil)\n          ])\n        ]),\n      ], 0, :IMPLICIT)\n    ]).to_der\n    [data, 161]\n  end\n\n  def probe_pkt_db2disco(ip)\n    data = \"DB2GETADDR\\x00SQL05000\\x00\"\n    [data, 523]\n  end\n\n  def probe_pkt_citrix(ip) # Server hello packet from citrix_published_bruteforce\n    data =\n      \"\\x1e\\x00\\x01\\x30\\x02\\xfd\\xa8\\xe3\\x00\\x00\\x00\\x00\\x00\" +\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" +\n      \"\\x00\\x00\\x00\\x00\"\n    return [data, 1604]\n  end\n\n  def probe_pkt_pca_st(ip)\n    return [\"ST\", 5632]\n  end\n\n  def probe_pkt_pca_nq(ip)\n    return [\"NQ\", 5632]\n  end\nend\n"
}