{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--062bb5b9-c30a-4d0d-bfdc-4b2983f70bfa",
    "created": "2024-08-14T16:32:53.758556Z",
    "modified": "2024-08-14T16:32:53.75856Z",
    "name": "Password Cracker: Windows",
    "description": "( This module uses John the Ripper or Hashcat to identify weak passwords that have been acquired from Windows systems. LANMAN is format 3000 in hashcat. NTLM is format 1000 in hashcat. MSCASH is format 1100 in hashcat. MSCASH2 is format 2100 in hashcat. NetNTLM is format 5500 in hashcat. NetNTLMv2 is format 5600 in hashcat. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/analyze/crack_windows.rb",
            "external_id": "crack_windows.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::PasswordCracker\n  include Msf::Exploit::Deprecated\n  moved_from 'auxiliary/analyze/jtr_windows_fast'\n\n  def initialize\n    super(\n      'Name' => 'Password Cracker: Windows',\n      'Description' => %(\n          This module uses John the Ripper or Hashcat to identify weak passwords that have been\n        acquired from Windows systems.\n        LANMAN is format 3000 in hashcat.\n        NTLM is format 1000 in hashcat.\n        MSCASH is format 1100 in hashcat.\n        MSCASH2 is format 2100 in hashcat.\n        NetNTLM is format 5500 in hashcat.\n        NetNTLMv2 is format 5600 in hashcat.\n      ),\n      'Author' => [\n        'theLightCosine',\n        'hdm',\n        'h00die' # hashcat integration\n      ],\n      'License' => MSF_LICENSE, # JtR itself is GPLv2, but this wrapper is MSF (BSD)\n      'Actions' => [\n        ['john', { 'Description' => 'Use John the Ripper' }],\n        ['hashcat', { 'Description' => 'Use Hashcat' }],\n      ],\n      'DefaultAction' => 'john',\n    )\n\n    register_options(\n      [\n        OptBool.new('NTLM', [false, 'Crack NTLM hashes', true]),\n        OptBool.new('LANMAN', [false, 'Crack LANMAN hashes', true]),\n        OptBool.new('MSCASH', [false, 'Crack M$ CASH hashes (1 and 2)', true]),\n        OptBool.new('NETNTLM', [false, 'Crack NetNTLM', true]),\n        OptBool.new('NETNTLMV2', [false, 'Crack NetNTLMv2', true]),\n        OptBool.new('INCREMENTAL', [false, 'Run in incremental mode', true]),\n        OptBool.new('WORDLIST', [false, 'Run in wordlist mode', true]),\n        OptBool.new('NORMAL', [false, 'Run in normal mode (John the Ripper only)', true])\n      ]\n    )\n  end\n\n  def half_lm_regex\n    # ^\\?{7} is ??????? which is JTR format, so password would be ???????D\n    # ^[notfound] is hashcat format, so password would be [notfound]D\n    /^[?{7}|\\[notfound\\]]/\n  end\n\n  def show_command(cracker_instance)\n    return unless datastore['ShowCommand']\n\n    if action.name == 'john'\n      cmd = cracker_instance.john_crack_command\n    elsif action.name == 'hashcat'\n      cmd = cracker_instance.hashcat_crack_command\n    end\n    print_status(\"   Cracking Command: #{cmd.join(' ')}\")\n  end\n\n  def run\n    # we have to overload the process_cracker_results from password_cracker.rb since LANMAN\n    # is a special case where we may need to do some combining\n    def process_cracker_results(results, cred)\n      return results if cred['core_id'].nil? # make sure we have good data\n\n      # make sure we dont add the same one again\n      if results.select { |r| r.first == cred['core_id'] }.empty?\n        results << [cred['core_id'], cred['hash_type'], cred['username'], cred['password'], cred['method']]\n      end\n\n      # however, a special case for LANMAN where it may come back as ???????D (jtr) or [notfound]D (hashcat)\n      # we want to overwrite the one that was there *if* we have something better.\n      results.map! do |r|\n        if r.first == cred['core_id'] &&\n           r[3] =~ half_lm_regex\n          [cred['core_id'], cred['hash_type'], cred['username'], cred['password'], cred['method']]\n        else\n          r\n        end\n      end\n\n      create_cracked_credential(username: cred['username'], password: cred['password'], core_id: cred['core_id'])\n      results\n    end\n\n    def check_results(passwords, results, hash_type, method)\n      passwords.each do |password_line|\n        password_line.chomp!\n        next if password_line.blank?\n\n        fields = password_line.split(':')\n        cred = { 'hash_type' => hash_type, 'method' => method }\n        if action.name == 'john'\n          # If we don't have an expected minimum number of fields, this is probably not a hash line\n          next unless fields.count > 2\n\n          cred['username'] = fields.shift\n          cred['core_id'] = fields.pop\n          case hash_type\n          when 'mscash', 'mscash2', 'netntlm', 'netntlmv2'\n            cred['password'] = fields.shift\n          when 'lm', 'nt'\n            # If we don't have an expected minimum number of fields, this is probably not a NTLM hash\n            next unless fields.count >= 6\n\n            2.times { fields.pop } # Get rid of extra :\n            nt_hash = fields.pop\n            lm_hash = fields.pop\n            id = fields.pop\n            password = fields.join(':') # Anything left must be the password. This accounts for passwords with semi-colons in it\n            if hash_type == 'lm' && password.blank?\n              if nt_hash == Metasploit::Credential::NTLMHash::BLANK_NT_HASH\n                password = ''\n              else\n                next\n              end\n            end\n\n            # password can be nil if the hash is broken (i.e., the NT and\n            # LM sides don't actually match) or if john was only able to\n            # crack one half of the LM hash. In the latter case, we'll\n            # have a line like:\n            #  username:???????WORD:...:...:::\n            cred['password'] = john_lm_upper_to_ntlm(password, nt_hash)\n          end\n          next if cred['password'].nil?\n        elsif action.name == 'hashcat'\n          next unless fields.count >= 2\n\n          cred['core_id'] = fields.shift\n\n          if ['netntlm', 'netntlmv2'].include? hash_type\n            # we could grab the username here, but no need since we grab it later based on core_id, which is safer\n            6.times { fields.shift } # Get rid of a bunch of extra fields\n          else\n            cred['hash'] = fields.shift\n          end\n\n          fields.pop if hash_type == 'mscash' # Get rid of username\n\n          cred['password'] = fields.join(':') # Anything left must be the password. This accounts for passwords with semi-colons in it\n          next if cred['core_id'].include?(\"Hashfile '\") && cred['core_id'].include?(\"' on line \") # skip error lines\n\n          # we don't have the username since we overloaded it with the core_id (since its a better fit for us)\n          # so we can now just go grab the username from the DB\n          cred['username'] = framework.db.creds(workspace: myworkspace, id: cred['core_id'])[0].public.username\n        end\n        results = process_cracker_results(results, cred)\n      end\n      results\n    end\n\n    tbl = cracker_results_table\n\n    # array of hashes in jtr_format in the db, converted to an OR combined regex\n    hash_types_to_crack = []\n    hash_types_to_crack << 'lm' if datastore['LANMAN']\n    hash_types_to_crack << 'nt' if datastore['NTLM']\n    hash_types_to_crack << 'mscash' if datastore['MSCASH']\n    hash_types_to_crack << 'mscash2' if datastore['MSCASH']\n    hash_types_to_crack << 'netntlm' if datastore['NETNTLM']\n    hash_types_to_crack << 'netntlmv2' if datastore['NETNTLMV2']\n\n    jobs_to_do = []\n\n    # build our job list\n    hash_types_to_crack.each do |hash_type|\n      job = hash_job(hash_type, action.name)\n      if job.nil?\n        print_status(\"No #{hash_type} found to crack\")\n      else\n        jobs_to_do << job\n      end\n    end\n\n    # bail early of no jobs to do\n    if jobs_to_do.empty?\n      print_good(\"No uncracked password hashes found for: #{hash_types_to_crack.join(', ')}\")\n      return\n    end\n\n    # array of arrays for cracked passwords.\n    # Inner array format: db_id, hash_type, username, password, method_of_crack\n    results = []\n\n    cracker = new_password_cracker(action.name)\n\n    # generate our wordlist and close the file handle.\n    wordlist = wordlist_file\n    unless wordlist\n      print_error('This module cannot run without a database connected. Use db_connect to connect to a database.')\n      return\n    end\n\n    wordlist.close\n    print_status \"Wordlist file written out to #{wordlist.path}\"\n\n    cleanup_files = [wordlist.path]\n\n    jobs_to_do.each do |job|\n      format = job['type']\n      hash_file = Rex::Quickfile.new(\"hashes_#{job['type']}_\")\n      hash_file.puts job['formatted_hashlist']\n      hash_file.close\n      cracker.hash_path = hash_file.path\n      cleanup_files << hash_file.path\n      # dupe our original cracker so we can safely change options between each run\n      cracker_instance = cracker.dup\n      cracker_instance.format = format\n      if action.name == 'john'\n        cracker_instance.fork = datastore['FORK']\n      end\n\n      # first check if anything has already been cracked so we don't report it incorrectly\n      print_status \"Checking #{format} hashes already cracked...\"\n      results = check_results(cracker_instance.each_cracked_password, results, format, 'Already Cracked/POT')\n      vprint_good(append_results(tbl, results)) unless results.empty?\n      job['cred_ids_left_to_crack'] = job['cred_ids_left_to_crack'] - results.map { |i| i[0].to_i } # remove cracked hashes from the hash list\n      next if job['cred_ids_left_to_crack'].empty?\n\n      if action.name == 'john'\n        print_status \"Cracking #{format} hashes in single mode...\"\n        cracker_instance.mode_single(wordlist.path)\n        show_command cracker_instance\n        cracker_instance.crack do |line|\n          vprint_status line.chomp\n        end\n        results = check_results(cracker_instance.each_cracked_password, results, format, 'Single')\n        vprint_good(append_results(tbl, results)) unless results.empty?\n        job['cred_ids_left_to_crack'] = job['cred_ids_left_to_crack'] - results.map { |i| i[0].to_i } # remove cracked hashes from the hash list\n        next if job['cred_ids_left_to_crack'].empty?\n\n        if datastore['NORMAL']\n          print_status \"Cracking #{format} hashes in normal mode...\"\n          cracker_instance.mode_normal\n          show_command cracker_instance\n          cracker_instance.crack do |line|\n            vprint_status line.chomp\n          end\n          results = check_results(cracker_instance.each_cracked_password, results, format, 'Normal')\n          vprint_good(append_results(tbl, results)) unless results.empty?\n          job['cred_ids_left_to_crack'] = job['cred_ids_left_to_crack'] - results.map { |i| i[0].to_i } # remove cracked hashes from the hash list\n          next if job['cred_ids_left_to_crack'].empty?\n        end\n      end\n\n      if datastore['INCREMENTAL']\n        print_status \"Cracking #{format} hashes in incremental mode...\"\n        cracker_instance.mode_incremental\n        show_command cracker_instance\n        cracker_instance.crack do |line|\n          vprint_status line.chomp\n        end\n        results = check_results(cracker_instance.each_cracked_password, results, format, 'Incremental')\n        vprint_good(append_results(tbl, results)) unless results.empty?\n        job['cred_ids_left_to_crack'] = job['cred_ids_left_to_crack'] - results.map { |i| i[0].to_i } # remove cracked hashes from the hash list\n        next if job['cred_ids_left_to_crack'].empty?\n      end\n\n      if datastore['WORDLIST']\n        print_status \"Cracking #{format} hashes in wordlist mode...\"\n        cracker_instance.mode_wordlist(wordlist.path)\n        # Turn on KoreLogic rules if the user asked for it\n        if action.name == 'john' && datastore['KORELOGIC']\n          cracker_instance.rules = 'KoreLogicRules'\n          print_status 'Applying KoreLogic ruleset...'\n        end\n        show_command cracker_instance\n        cracker_instance.crack do |line|\n          vprint_status line.chomp\n        end\n\n        results = check_results(cracker_instance.each_cracked_password, results, format, 'Wordlist')\n\n        vprint_good(append_results(tbl, results)) unless results.empty?\n        job['cred_ids_left_to_crack'] = job['cred_ids_left_to_crack'] - results.map { |i| i[0].to_i } # remove cracked hashes from the hash list\n        next if job['cred_ids_left_to_crack'].empty?\n      end\n\n      # give a final print of results\n      print_good(append_results(tbl, results))\n    end\n    if datastore['DeleteTempFiles']\n      cleanup_files.each do |f|\n        File.delete(f)\n      end\n    end\n  end\nend\n"
}