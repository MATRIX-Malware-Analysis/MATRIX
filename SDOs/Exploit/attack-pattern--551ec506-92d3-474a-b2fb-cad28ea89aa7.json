{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--551ec506-92d3-474a-b2fb-cad28ea89aa7",
    "created": "2024-08-14T16:28:02.409634Z",
    "modified": "2024-08-14T16:28:02.409638Z",
    "name": "OpenSSL Server-Side ChangeCipherSpec Injection Scanner",
    "description": " This module checks for the OpenSSL ChangeCipherSpec (CCS) Injection vulnerability. The problem exists in the handling of early CCS messages during session negotiation. Vulnerable installations of OpenSSL accepts them, while later implementations do not. If successful, an attacker can leverage this vulnerability to perform a man-in-the-middle (MITM) attack by downgrading the cipher spec between a client and server. This issue was first reported in early June, 2014. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/ssl/openssl_ccs.rb",
            "external_id": "openssl_ccs.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-0224"
        },
        {
            "source_name": "reference",
            "url": "http://ccsinjection.lepidum.co.jp/"
        },
        {
            "source_name": "reference",
            "url": "http://ccsinjection.lepidum.co.jp/blog/2014-06-05/CCS-Injection-en/index.html"
        },
        {
            "source_name": "reference",
            "url": "http://www.tripwire.com/state-of-security/incident-detection/detection-script-for-cve-2014-0224-openssl-cipher-change-spec-injection/"
        },
        {
            "source_name": "reference",
            "url": "https://www.imperialviolet.org/2014/06/05/earlyccs.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  CIPHER_SUITES = [\n    0xc014, # TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n    0xc00a, # TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\n    0xc022, # TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA\n    0xc021, # TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA\n    0x0039, # TLS_DHE_RSA_WITH_AES_256_CBC_SHA\n    0x0038, # TLS_DHE_DSS_WITH_AES_256_CBC_SHA\n    0x0088, # TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA\n    0x0087, # TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA\n    0x0087, # TLS_ECDH_RSA_WITH_AES_256_CBC_SHA\n    0xc00f, # TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA\n    0x0035, # TLS_RSA_WITH_AES_256_CBC_SHA\n    0x0084, # TLS_RSA_WITH_CAMELLIA_256_CBC_SHA\n    0xc012, # TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\n    0xc008, # TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA\n    0xc01c, # TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA\n    0xc01b, # TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA\n    0x0016, # TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA\n    0x0013, # TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA\n    0xc00d, # TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA\n    0xc003, # TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA\n    0x000a, # TLS_RSA_WITH_3DES_EDE_CBC_SHA\n    0xc013, # TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\n    0xc009, # TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\n    0xc01f, # TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA\n    0xc01e, # TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA\n    0x0033, # TLS_DHE_RSA_WITH_AES_128_CBC_SHA\n    0x0032, # TLS_DHE_DSS_WITH_AES_128_CBC_SHA\n    0x009a, # TLS_DHE_RSA_WITH_SEED_CBC_SHA\n    0x0099, # TLS_DHE_DSS_WITH_SEED_CBC_SHA\n    0x0045, # TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA\n    0x0044, # TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA\n    0xc00e, # TLS_ECDH_RSA_WITH_AES_128_CBC_SHA\n    0xc004, # TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA\n    0x002f, # TLS_RSA_WITH_AES_128_CBC_SHA\n    0x0096, # TLS_RSA_WITH_SEED_CBC_SHA\n    0x0041, # TLS_RSA_WITH_CAMELLIA_128_CBC_SHA\n    0xc011, # TLS_ECDHE_RSA_WITH_RC4_128_SHA\n    0xc007, # TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\n    0xc00c, # TLS_ECDH_RSA_WITH_RC4_128_SHA\n    0xc002, # TLS_ECDH_ECDSA_WITH_RC4_128_SHA\n    0x0005, # TLS_RSA_WITH_RC4_128_SHA\n    0x0004, # TLS_RSA_WITH_RC4_128_MD5\n    0x0015, # TLS_DHE_RSA_WITH_DES_CBC_SHA\n    0x0012, # TLS_DHE_DSS_WITH_DES_CBC_SHA\n    0x0009, # TLS_RSA_WITH_DES_CBC_SHA\n    0x0014, # TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA\n    0x0011, # TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA\n    0x0008, # TLS_RSA_EXPORT_WITH_DES40_CBC_SHA\n    0x0006, # TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5\n    0x0003, # TLS_RSA_EXPORT_WITH_RC4_40_MD5\n    0x00ff  # Unknown\n  ]\n\n  HANDSHAKE_RECORD_TYPE = 0x16\n  CCS_RECORD_TYPE       = 0x14\n  ALERT_RECORD_TYPE     = 0x15\n  TLS_VERSION = {\n    'SSLv3' => 0x0300,\n    '1.0'   => 0x0301,\n    '1.1'   => 0x0302,\n    '1.2'   => 0x0303\n  }\n\n  def initialize\n    super(\n      'Name'           => 'OpenSSL Server-Side ChangeCipherSpec Injection Scanner',\n      'Description'    => %q{\n        This module checks for the OpenSSL ChangeCipherSpec (CCS)\n        Injection vulnerability. The problem exists in the handling of early\n        CCS messages during session negotiation. Vulnerable installations of OpenSSL accepts\n        them, while later implementations do not. If successful, an attacker can leverage this\n        vulnerability to perform a man-in-the-middle (MITM) attack by downgrading the cipher spec\n        between a client and server. This issue was first reported in early June, 2014.\n      },\n      'Author'         => [\n        'Masashi Kikuchi', # Vulnerability discovery\n        'Craig Young <CYoung[at]tripwire.com>', # Original Scanner. This module is based on it.\n        'juan vazquez' # Metasploit module\n      ],\n      'References'     =>\n        [\n          ['CVE', '2014-0224'],\n          ['URL', 'http://ccsinjection.lepidum.co.jp/'],\n          ['URL', 'http://ccsinjection.lepidum.co.jp/blog/2014-06-05/CCS-Injection-en/index.html'],\n          ['URL', 'http://www.tripwire.com/state-of-security/incident-detection/detection-script-for-cve-2014-0224-openssl-cipher-change-spec-injection/'],\n          ['URL', 'https://www.imperialviolet.org/2014/06/05/earlyccs.html']\n        ],\n      'DisclosureDate' => 'Jun 5 2014',\n      'License'        => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        Opt::RPORT(443),\n        OptEnum.new('TLS_VERSION', [true, 'TLS/SSL version to use', '1.0', ['SSLv3','1.0', '1.1', '1.2']]),\n        OptInt.new('RESPONSE_TIMEOUT', [true, 'Number of seconds to wait for a server response', 10])\n      ])\n  end\n\n  def response_timeout\n    datastore['RESPONSE_TIMEOUT']\n  end\n\n  def run_host(ip)\n    ccs_injection\n  end\n\n  def ccs_injection\n    connect_result = establish_connect\n    return if connect_result.nil?\n\n    vprint_status(\"Sending CCS...\")\n    sock.put(ccs)\n    alert = sock.get_once(-1, response_timeout)\n    if alert.blank?\n      print_good(\"No alert after invalid CCS message, probably vulnerable\")\n      report\n    elsif alert.unpack(\"C\").first == ALERT_RECORD_TYPE\n      vprint_error(\"Alert record as response to the invalid CCS Message, probably not vulnerable\")\n    elsif alert\n      vprint_warning(\"Unexpected response.\")\n    end\n  end\n\n  def report\n    report_vuln({\n      :host => rhost,\n      :port => rport,\n      :name => self.name,\n      :refs => self.references,\n      :info => \"Module #{self.fullname} successfully detected CCS injection\"\n    })\n  end\n\n  def ccs\n    payload = \"\\x01\" # Change Cipher Spec Message\n\n    ssl_record(CCS_RECORD_TYPE, payload)\n  end\n\n  def client_hello\n    # Use current day for TLS time\n    time_temp = Time.now\n    time_epoch = Time.mktime(time_temp.year, time_temp.month, time_temp.day, 0, 0).to_i\n\n    hello_data = [TLS_VERSION[datastore['TLS_VERSION']]].pack(\"n\") # Version TLS\n    hello_data << [time_epoch].pack(\"N\")    # Time in epoch format\n    hello_data << Rex::Text.rand_text(28)   # Random\n    hello_data << \"\\x00\"                    # Session ID length\n    hello_data << [CIPHER_SUITES.length * 2].pack(\"n\") # Cipher Suites length (102)\n    hello_data << CIPHER_SUITES.pack(\"n*\")  # Cipher Suites\n    hello_data << \"\\x01\"                    # Compression methods length (1)\n    hello_data << \"\\x00\"                    # Compression methods: null\n\n    data = \"\\x01\\x00\"                      # Handshake Type: Client Hello (1)\n    data << [hello_data.length].pack(\"n\")  # Length\n    data << hello_data\n\n    ssl_record(HANDSHAKE_RECORD_TYPE, data)\n  end\n\n  def ssl_record(type, data)\n    record = [type, TLS_VERSION[datastore['TLS_VERSION']], data.length].pack('Cnn')\n    record << data\n  end\n\n  def establish_connect\n    connect\n\n    vprint_status(\"Sending Client Hello...\")\n    sock.put(client_hello)\n    server_hello = sock.get_once(-1, response_timeout)\n\n    unless server_hello\n      vprint_error(\"No Server Hello after #{response_timeout} seconds...\")\n      disconnect\n      return nil\n    end\n\n    unless server_hello.unpack(\"C\").first == HANDSHAKE_RECORD_TYPE\n      vprint_error(\"Server Hello Not Found\")\n      return nil\n    end\n\n    true\n  end\nend\n\n",
    "x_mitre_disclosure_date": "Jun 5 2014"
}