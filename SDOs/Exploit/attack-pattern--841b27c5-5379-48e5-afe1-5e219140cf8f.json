{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--841b27c5-5379-48e5-afe1-5e219140cf8f",
    "created": "2024-08-14T16:31:22.451649Z",
    "modified": "2024-08-14T16:31:22.451653Z",
    "name": "TCP Port Scanner",
    "description": " Enumerate open TCP services by performing a full TCP connect on each port. This does not need administrative privileges on the source machine, which may be useful if pivoting. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/portscan/tcp.rb",
            "external_id": "tcp.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n\n  def initialize\n    super(\n      'Name'        => 'TCP Port Scanner',\n      'Description' => %q{\n        Enumerate open TCP services by performing a full TCP connect on each port.\n        This does not need administrative privileges on the source machine, which\n        may be useful if pivoting.\n      },\n      'Author'      => [ 'hdm', 'kris katterjohn' ],\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n    [\n      OptString.new('PORTS', [true, \"Ports to scan (e.g. 22-25,80,110-900)\", \"1-10000\"]),\n      OptInt.new('TIMEOUT', [true, \"The socket connect timeout in milliseconds\", 1000]),\n      OptInt.new('CONCURRENCY', [true, \"The number of concurrent ports to check per host\", 10]),\n      OptInt.new('DELAY', [true, \"The delay between connections, per thread, in milliseconds\", 0]),\n      OptInt.new('JITTER', [true, \"The delay jitter factor (maximum value by which to +/- DELAY) in milliseconds.\", 0]),\n    ])\n\n    deregister_options('RPORT')\n\n  end\n\n  def run_host(ip)\n\n    timeout = datastore['TIMEOUT'].to_i\n\n    ports = Rex::Socket.portspec_crack(datastore['PORTS'])\n\n    if ports.empty?\n      raise Msf::OptionValidateError.new(['PORTS'])\n    end\n\n    jitter_value = datastore['JITTER'].to_i\n    if jitter_value < 0\n      raise Msf::OptionValidateError.new(['JITTER'])\n    end\n\n    delay_value = datastore['DELAY'].to_i\n    if delay_value < 0\n      raise Msf::OptionValidateError.new(['DELAY'])\n    end\n\n    while(ports.length > 0)\n      t = []\n      r = []\n      begin\n      1.upto(datastore['CONCURRENCY']) do\n        this_port = ports.shift\n        break if not this_port\n        t << framework.threads.spawn(\"Module(#{self.refname})-#{ip}:#{this_port}\", false, this_port) do |port|\n          begin\n\n            # Add the delay based on JITTER and DELAY if needs be\n            add_delay_jitter(delay_value,jitter_value)\n\n            # Actually perform the TCP connection\n            s = connect(false,\n              {\n                'RPORT' => port,\n                'RHOST' => ip,\n                'ConnectTimeout' => (timeout / 1000.0)\n              }\n            )\n            if s\n              print_good(\"#{ip}:#{port} - TCP OPEN\")\n              r << [ip,port,\"open\"]\n            end\n          rescue ::Rex::ConnectionRefused\n            vprint_status(\"#{ip}:#{port} - TCP closed\")\n          rescue ::Rex::ConnectionError, ::IOError, ::Timeout::Error\n          rescue ::Rex::Post::Meterpreter::RequestError\n          rescue ::Interrupt\n            raise $!\n          rescue ::Exception => e\n            print_error(\"#{ip}:#{port} exception #{e.class} #{e} #{e.backtrace}\")\n          ensure\n            if s\n              disconnect(s) rescue nil\n            end\n          end\n        end\n      end\n      t.each {|x| x.join }\n\n      rescue ::Timeout::Error\n      ensure\n        t.each {|x| x.kill rescue nil }\n      end\n\n      r.each do |res|\n        report_service(:host => res[0], :port => res[1], :state => res[2])\n      end\n    end\n  end\nend\n"
}