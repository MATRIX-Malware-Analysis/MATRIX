{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d32baf8a-1de0-457c-aa6d-1aa5d15cb167",
    "created": "2024-08-14T16:31:15.191852Z",
    "modified": "2024-08-14T16:31:15.191856Z",
    "name": "{",
    "description": " This module determines what shares are provided by the SMB service and which ones are readable/writable. It also collects additional information such as share types directories, files, time stamps, etc.  By default, a RubySMB net_share_enum_all request is done in order to retrieve share information which uses SRVSVC. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/smb/smb_enumshares.rb",
            "external_id": "smb_enumshares.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  # Exploit mixins should be called first\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Exploit::Remote::SMB::Client::Authenticated\n  include Msf::Exploit::Remote::DCERPC\n\n  # Scanner mixin should be near last\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'SMB Share Enumeration',\n        'Description' => %q{\n          This module determines what shares are provided by the SMB service and which ones\n          are readable/writable. It also collects additional information such as share types,\n          directories, files, time stamps, etc.\n\n          By default, a RubySMB net_share_enum_all request is done in order to retrieve share information,\n          which uses SRVSVC.\n        },\n        'Author' => [\n          'hdm',\n          'nebulus',\n          'sinn3r',\n          'r3dy',\n          'altonjx',\n          'sjanusz-r7'\n        ],\n        'License' => MSF_LICENSE,\n        'DefaultOptions' => {\n          'DCERPC::fake_bind_multi' => false\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptBool.new('SpiderShares', [false, 'Spider shares recursively', false]),\n        OptBool.new('ShowFiles', [true, 'Show detailed information when spidering', false]),\n        OptString.new('Share', [ false, 'Show only the specified share']),\n        OptRegexp.new('HIGHLIGHT_NAME_PATTERN', [true, 'PCRE regex of resource names to highlight', 'username|password|user|pass|Groups.xml']),\n        OptBool.new('SpiderProfiles', [false, 'Spider only user profiles when share is a disk share', true]),\n        OptEnum.new('LogSpider', [false, '0 = disabled, 1 = CSV, 2 = table (txt), 3 = one liner (txt)', 3, [0, 1, 2, 3]]),\n        OptInt.new('MaxDepth', [true, 'Max number of subdirectories to spider', 999]),\n      ]\n    )\n\n    deregister_options('RPORT')\n  end\n\n  # Updated types for RubySMB. These are all the types we can ever receive from calling net_share_enum_all\n  ENUMERABLE_SHARE_TYPES = ['DISK', 'TEMPORARY'].freeze\n  SKIPPABLE_SHARE_TYPES = ['PRINTER', 'IPC', 'DEVICE', 'SPECIAL'].freeze\n  SKIPPABLE_SHARES = ['ADMIN$', 'IPC$'].freeze\n\n  # By default all of the drives connected to the server can be seen\n  DEFAULT_SHARES = [\n    'C$', 'D$', 'E$', 'F$', 'G$', 'H$', 'I$', 'J$', 'K$', 'L$', 'M$', 'N$',\n    'O$', 'P$', 'Q$', 'R$', 'S$', 'T$', 'U$', 'V$', 'W$', 'X$', 'Y$', 'Z$'\n  ].freeze\n\n  USERS_SHARE = 'Users'.freeze # Where the users are stored in Windows 7\n  USERS_DIR = '\\Users'.freeze # Windows 7 & Windows 10 user directory\n  DOCUMENTS_DIR = '\\Documents and Settings'.freeze # Windows XP user directory\n\n  SMB1_PORT = 139\n  SMB2_3_PORT = 445\n\n  def rport\n    @rport || datastore['RPORT']\n  end\n\n  def enum_tree(tree, share, subdir = '')\n    subdir = subdir[1..subdir.length] if subdir.starts_with?('\\\\')\n    read = tree.permissions.read_ea == 1\n    write = tree.permissions.write_ea == 1\n    skip = false\n\n    if ENUMERABLE_SHARE_TYPES.include?(share[:type])\n      msg = share[:type]\n    elsif SKIPPABLE_SHARE_TYPES.include?(share[:type])\n      msg = share[:type]\n      skip = true\n    else\n      msg = \"Unhandled Device Type (#{share[:type]})\"\n      skip = true\n    end\n\n    print_status(\"Skipping share #{share[:name].strip} as it is of type #{share[:type]}\") if skip\n    return read, write, msg, nil if skip\n\n    # Create list after possibly skipping a share we wouldn't be able to access.\n    begin\n      list = tree.list(directory: subdir)\n    rescue RubySMB::Error::UnexpectedStatusCode => e\n      vprint_error(\"Error when trying to list tree contents in #{share[:name]}\\\\#{subdir} - #{e.status_code.name}\")\n      return read, write, msg, nil\n    end\n\n    rfd = []\n    unless list.nil? || list.empty?\n      list.entries.each do |file|\n        file_name = file.file_name.strip.encode('UTF-8')\n        next if file_name == '.' || file_name == '..'\n\n        rfd.push(file)\n      end\n    end\n\n    return read, write, msg, rfd\n  end\n\n  def get_os_info(ip)\n    os = smb_fingerprint\n    if os['os'] != 'Unknown'\n      os_info = \"#{os['os']} #{os['sp']} (#{os['lang']})\"\n    end\n    if os_info\n      report_service(\n        host: ip,\n        port: rport,\n        proto: 'tcp',\n        name: 'smb',\n        info: os_info\n      )\n    end\n\n    os_info\n  end\n\n  def get_user_dirs(tree, share, base)\n    dirs = []\n\n    read, _write, _type, files = enum_tree(tree, share, base)\n\n    return dirs if files.nil? || !read\n\n    files.each do |f|\n      dirs.push(\"\\\\#{base}\\\\#{f[:file_name].encode('UTF-8')}\")\n    end\n\n    dirs\n  end\n\n  def profile_options(tree, share)\n    dirs = get_user_dirs(tree, share, 'Documents and Settings')\n    if dirs.blank?\n      dirs = get_user_dirs(tree, share, 'Users')\n    end\n\n    dirs\n  end\n\n  def get_files_info(ip, shares)\n    # Creating a separate file for each IP address's results.\n    detailed_tbl = Rex::Text::Table.new(\n      'Header' => \"Spidered results for #{ip}.\",\n      'Indent' => 1,\n      'Columns' => [ 'IP Address', 'Type', 'Share', 'Path', 'Name', 'Created', 'Accessed', 'Written', 'Changed', 'Size' ]\n    )\n\n    logdata = ''\n\n    shares.each do |share|\n      share_name = share[:name].strip\n      if SKIPPABLE_SHARES.include?(share_name) || (share_name == USERS_SHARE && !datastore['SpiderProfiles'])\n        print_status(\"Skipping #{share_name}\")\n        next\n      end\n\n      if !datastore['ShowFiles']\n        print_status(\"Spidering #{share_name}\")\n      end\n\n      begin\n        tree = simple.client.tree_connect(\"\\\\\\\\#{ip}\\\\#{share_name}\")\n      rescue RubySMB::Error::UnexpectedStatusCode, RubySMB::Error::InvalidPacket => e\n        if datastore['Share'].nil?\n          vprint_error(\"Error when trying to connect to share #{share_name} - #{e.status_code.name}\")\n        else\n          print_error(\"Error when trying to connect to share #{share_name} - #{e.status_code.name}\")\n        end\n        print_status(\"Spidering #{share_name} complete\") unless datastore['ShowFiles']\n        next\n      end\n\n      subdirs = ['']\n      if DEFAULT_SHARES.include?(share_name) && datastore['SpiderProfiles']\n        subdirs = profile_options(tree, share)\n      end\n      until subdirs.empty?\n        # Skip user directories if we do not want to spider them\n        if (subdirs.first == USERS_DIR || subdirs.first == DOCUMENTS_DIR) && !datastore['SpiderProfiles']\n          subdirs.shift\n          next\n        end\n        depth = subdirs.first.count('\\\\')\n\n        if datastore['SpiderProfiles'] && DEFAULT_SHARES.include?(share_name)\n          if (depth - 2) > datastore['MaxDepth']\n            subdirs.shift\n            next\n          end\n        elsif depth > datastore['MaxDepth']\n          subdirs.shift\n          next\n        end\n\n        read, _write, _type, files = enum_tree(tree, share, subdirs.first)\n\n        if files.nil? || files.empty? || !read\n          subdirs.shift\n          next\n        end\n\n        header = ''\n        if simple.client.default_domain && simple.client.default_name\n          header << \" \\\\\\\\#{simple.client.default_domain}\"\n        end\n        header << \"\\\\#{share_name}\" if simple.client.default_name\n        header << subdirs.first\n        pretty_tbl = Rex::Text::Table.new(\n          'Header' => header,\n          'Indent' => 1,\n          'Columns' => [ 'Type', 'Name', 'Created', 'Accessed', 'Written', 'Changed', 'Size' ],\n          'ColProps' => {\n            'Name' => {\n              'Stylers' => [Msf::Ui::Console::TablePrint::HighlightSubstringStyler.new([datastore['HIGHLIGHT_NAME_PATTERN']])]\n            }\n          }\n        )\n\n        files.each do |file|\n          fname = file.file_name.encode('UTF-8')\n          tcr = file.create_time.to_datetime\n          tac = file.last_access.to_datetime\n          twr = file.last_write.to_datetime\n          tch = file.last_change.to_datetime\n\n          # Add subdirectories to list to use if SpiderShare is enabled.\n          if (file[:file_attributes]&.directory == 1) || (file[:ext_file_attributes]&.directory == 1)\n            fa = 'DIR'\n            subdirs.push(subdirs.first + '\\\\' + fname)\n          else\n            fa = 'FILE'\n            sz = file.end_of_file\n          end\n\n          # Logging of the obtained data.\n          logdata << \"#{ip}\\\\#{share_name}#{subdirs.first}\\\\#{fname.encode}\\n\"\n          detailed_tbl << [ip.to_s, fa || 'Unknown', share_name, subdirs.first + '\\\\', fname, tcr, tac, twr, tch, sz]\n\n          # Filename is too long for the UI table, cut it.\n          fname = \"#{fname[0, 35]}...\" if fname.length > 35\n\n          pretty_tbl << [fa || 'Unknown', fname, tcr, tac, twr, tch, sz]\n        end\n        print_good(pretty_tbl.to_s) if datastore['ShowFiles']\n        subdirs.shift\n      end\n      print_status(\"Spidering #{share_name} complete\") unless datastore['ShowFiles']\n    end\n\n    unless detailed_tbl.rows.empty?\n      if datastore['LogSpider'] == '1'\n        p = store_loot('smb.enumshares', 'text/csv', ip, detailed_tbl.to_csv)\n        print_good(\"info saved in: #{p}\")\n      elsif datastore['LogSpider'] == '2'\n        p = store_loot('smb.enumshares', 'text/plain', ip, detailed_tbl)\n        print_good(\"info saved in: #{p}\")\n      elsif datastore['LogSpider'] == '3'\n        p = store_loot('smb.enumshares', 'text/plain', ip, logdata)\n        print_good(\"info saved in: #{p}\")\n      end\n    end\n  end\n\n  def run_host(ip)\n    shares = []\n\n    [{ port: SMB1_PORT }, { port: SMB2_3_PORT } ].each do |info|\n      # Assign @rport so that it is accessible via the rport method in this module,\n      # as well as making it accessible to the module mixins\n      @rport = info[:port]\n\n      begin\n        print_status 'Starting module'\n        if rport == SMB1_PORT\n          # force library in smb1 mode otherwise simple.client is a\n          # `Rex::Proto::SMB::Client` that does not supply `net_share_enum_all`\n          connect(versions: [1], backend: :ruby_smb)\n        else\n          connect(versions: [1, 2, 3])\n        end\n        smb_login\n\n        begin\n          # Return all shares if `Shares` option has not been set\n          if datastore['Share'].nil?\n            shares = simple.client.net_share_enum_all(ip)\n          else\n            # Return specific share if the `Share` option has been set\n            simple.client.net_share_enum_all(ip).each { |share| shares = [share] if share[:name] == datastore['Share'] }\n            # Return an error if `Share` option has been set but no matches were found\n            if shares.empty?\n              print_error(\"No shares match #{datastore['Share']}\")\n            end\n          end\n        rescue RubySMB::Error::UnexpectedStatusCode => e\n          print_error(\"Error when trying to enumerate shares - #{e.status_code.name}\")\n          next\n        rescue RubySMB::Error::InvalidPacket => e\n          print_error(\"Invalid packet received when trying to enumerate shares - #{e}\")\n          next\n        end\n\n        os_info = get_os_info(ip)\n        print_status(os_info) if os_info\n\n        if shares.empty?\n          print_status('No shares available')\n        else\n          shares.each do |share|\n            print_good(\"#{share[:name]} - (#{share[:type]}) #{share[:comment]}\")\n          end\n\n          # Map RubySMB shares to the same data format as it was with Rex SMB\n          report_shares = shares.map { |share| [share[:name], share[:type], share[:comment]] }\n          report_note(\n            host: ip,\n            proto: 'tcp',\n            port: rport,\n            type: 'smb.shares',\n            data: { shares: report_shares },\n            update: :unique_data\n          )\n\n          if datastore['SpiderShares']\n            get_files_info(ip, shares)\n          end\n        end\n      rescue ::Interrupt\n        raise $ERROR_INFO\n      rescue Errno::ECONNRESET => e\n        vprint_error(e.message)\n      rescue Errno::ENOPROTOOPT\n        print_status('Wait 5 seconds before retrying...')\n        select(nil, nil, nil, 5)\n        retry\n      rescue Rex::ConnectionTimeout => e\n        print_error(e.to_s)\n        next\n      rescue Rex::Proto::SMB::Exceptions::LoginError => e\n        print_error(e.to_s)\n      rescue RubySMB::Error::RubySMBError => e\n        print_error(\"RubySMB encountered an error: #{e}\")\n        next\n      rescue RuntimeError => e\n        print_error e.to_s\n        next\n      rescue StandardError => e\n        vprint_error(\"Error: '#{ip}' '#{e.class}' '#{e}'\")\n      ensure\n        disconnect\n      end\n\n      # if we already got results, not need to try on another port\n      return unless shares.empty?\n    end\n  end\nend\n"
}