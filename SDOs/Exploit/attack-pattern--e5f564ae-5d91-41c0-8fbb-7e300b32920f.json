{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e5f564ae-5d91-41c0-8fbb-7e300b32920f",
    "created": "2024-08-14T16:29:16.938429Z",
    "modified": "2024-08-14T16:29:16.938433Z",
    "name": "Apache Reverse Proxy Bypass Vulnerability Scanner",
    "description": " Scan for poorly configured reverse proxy servers. By default, this module attempts to force the server to make a request with an invalid domain name. Then, if the bypass is successful, the server will look it up and of course fail then responding with a status code 502. A baseline status code is always established and if that baseline matches your test status code, the injection attempt does not occur. \"set VERBOSE true\" if you are paranoid and want to catch potential false negatives. Works best against Apache and mod_rewrite ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/rewrite_proxy_bypass.rb",
            "external_id": "rewrite_proxy_bypass.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.contextis.com/research/blog/reverseproxybypass/"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-3368"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'Apache Reverse Proxy Bypass Vulnerability Scanner',\n      'Description' => %q{\n        Scan for poorly configured reverse proxy servers.\n        By default, this module attempts to force the server to make\n        a request with an invalid domain name. Then, if the bypass\n        is successful, the server will look it up and of course fail,\n        then responding with a status code 502. A baseline status code\n        is always established and if that baseline matches your test\n        status code, the injection attempt does not occur.\n        \"set VERBOSE true\" if you are paranoid and want to catch potential\n        false negatives. Works best against Apache and mod_rewrite\n      },\n      'Author'      => ['chao-mu'],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          ['URL', 'http://www.contextis.com/research/blog/reverseproxybypass/'],\n          ['CVE', '2011-3368'],\n        ]\n    )\n\n    register_options(\n      [\n        OptString.new('ESCAPE_SEQUENCE',\n          [true, 'Character(s) that terminate the rewrite rule', '@']),\n\n        OptString.new('INJECTED_URI',\n          [true, 'String injected after escape sequence', '...']),\n\n        OptInt.new('EXPECTED_RESPONSE',\n          [true, 'Status code that indicates vulnerability', 502]),\n\n        OptString.new('BASELINE_URI',\n          [true, 'Requested to establish that EXPECTED_RESPONSE is not the usual response', '/']),\n      ])\n  end\n\n  def make_request(host, uri, timeout=20)\n    begin\n      requested_at = Time.now.utc\n      response     = send_request_raw({'uri' => uri}, timeout)\n      responded_at = Time.now.utc\n    rescue ::Rex::ConnectionError => e\n      vprint_error e.to_s\n      return nil\n    end\n\n    if response.nil?\n      vprint_error \"#{rhost}:#{rport} Request timed out\"\n      return nil\n    end\n\n    seconds_transpired = (responded_at - requested_at).to_f\n    vprint_status \"#{rhost}:#{rport} Server took #{seconds_transpired} seconds to respond to URI #{uri}\"\n\n    status_code = response.code\n    vprint_status \"#{rhost}:#{rport} Server responded with status code #{status_code} to URI #{uri}\"\n\n    return {\n      :requested_at => requested_at,\n      :responded_at => responded_at,\n      :status_code  => status_code\n    }\n  end\n\n  def run_host(host)\n    test_status_code = datastore['EXPECTED_RESPONSE']\n\n    baseline = make_request(host, datastore['BASELINE_URI'])\n    if baseline.nil?\n      return\n    end\n\n    if baseline[:status_code] == test_status_code\n      vprint_error \"#{rhost}:#{rport} The baseline status code for #{host} matches our test's\"\n      return\n    end\n\n    uri = datastore['ESCAPE_SEQUENCE'] + datastore['INJECTED_URI']\n    injection_info = make_request(host, uri, 60)\n\n    status_code = injection_info[:status_code]\n    if status_code == test_status_code\n      print_good \"#{rhost}:#{rport} Server appears to be vulnerable!\"\n      report_vuln(\n        :host   => host,\n        :port   => rport,\n        :proto  => 'tcp',\n        :sname  => ssl ? 'https' : 'http',\n        :name   => self.name,\n        :info   => \"Module #{self.fullname} obtained #{status_code} when requesting #{uri}\",\n        :refs   => self.references,\n        :exploited_at => injection_info[:requested_at]\n      )\n    end\n  end\nend\n"
}