{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b6d2e296-b732-48cd-a1ee-af3e077b5333",
    "created": "2024-08-14T16:30:41.746499Z",
    "modified": "2024-08-14T16:30:41.746504Z",
    "name": "HTTP SSL Certificate Checker",
    "description": " This module will check the certificate of the specified web servers to ensure the subject and issuer match the supplied pattern and that the certificate is not expired.  )  register_options( [ Opt::RPORT(443) OptRegexp.new('ISSUER', [ true,  \"Show a warning if the Issuer doesn't match this regex\", '.*']) OptBool.new('SHOWALL', [ false, \"Show all certificates (issuer,time) regardless of match\", false]) ]) end  # Fingerprint a single host def run_host(ip)  connect(true, {\"SSL\" => true}) #Force SSL cert  = OpenSSL::X509::Certificate.new(sock.peer_cert) disconnect  if(not cert) print_status(\"#{ip} No certificate subject or CN found\") return end sub = cert.subject.to_a  before = Time.parse(\"#{cert.not_before}\") after = Time.parse(\"#{cert.not_after}\")  now = Time.now a = now <=> before b = now <=> after  vhostn = 'EMPTY' sub.each do |n| if n[0] == 'CN' vhostn = n[1] end end  if cert.issuer.to_s !~ /#{datastore['ISSUER'].source}/n print_good(\"#{ip} - '#{vhostn}' : #{cert.issuer} (BAD ISSUER)\" ) elsif datastore['SHOWALL'] # show verbose as status print_status(\"#{ip} - '#{vhostn}' : #{cert.issuer}\") end  if ( a < 1 or b > 0 ) print_good(\"#{ip} - '#{vhostn}' : '\" + before.to_s + \"' - '\" + after.to_s + \"' (EXPIRED)'\") elsif # show verbose as status print_status(\"#{ip} - '#{vhostn}' : '\" + before.to_s + \"' - '\" + after.to_s + \"'\") end  report_note( :host\t=> ip :port\t=> rport :proto  => 'tcp' :type\t=> 'http.vhost' :data\t=> {:name => vhostn ) if vhostn  # Store the SSL certificate itself report_note( :host\t=> ip :proto  => 'tcp' :port\t=> rport :type\t=> 'ssl.certificate' :data\t=> { :cn        => vhostn :subject   => cert.subject.to_a :algorithm => cert.signature_algorithm   ) if vhostn  # Update the server hostname if necessary if vhostn !~ /localhost|snakeoil/i report_host( :host => ip :name => vhostn ) end   rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout rescue ::Timeout::Error, ::Errno::EPIPE rescue ::OpenSSL::SSL::SSLError => e return if(e.to_s.match(/^SSL_connect /) ) # strange errors / exception if SSL connection aborted rescue ::Exception => e return if(e.to_s =~ /execution expired/) print_error(\"Error: '#{ip}' '#{e.class}' '#{e}' '#{e.backtrace}'\") end end",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/cert.rb",
            "external_id": "cert.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::WmapScanSSL\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'HTTP SSL Certificate Checker',\n      'Author'      => 'nebulus',\n      'License'     => MSF_LICENSE,\n      'Description' => %q{\n          This module will check the certificate of the specified web servers\n        to ensure the subject and issuer match the supplied pattern and that the certificate\n        is not expired.\n      }\n    )\n\n    register_options(\n      [\n        Opt::RPORT(443),\n        OptRegexp.new('ISSUER', [ true,  \"Show a warning if the Issuer doesn't match this regex\", '.*']),\n        OptBool.new('SHOWALL', [ false, \"Show all certificates (issuer,time) regardless of match\", false]),\n      ])\n  end\n\n  # Fingerprint a single host\n  def run_host(ip)\n\n    connect(true, {\"SSL\" => true}) #Force SSL\n    cert  = OpenSSL::X509::Certificate.new(sock.peer_cert)\n    disconnect\n\n    if(not cert)\n      print_status(\"#{ip} No certificate subject or CN found\")\n      return\n    end\n    sub = cert.subject.to_a\n\n    before = Time.parse(\"#{cert.not_before}\")\n    after = Time.parse(\"#{cert.not_after}\")\n\n    now = Time.now\n    a = now <=> before\n    b = now <=> after\n\n    vhostn = 'EMPTY'\n    sub.each do |n|\n      if n[0] == 'CN'\n        vhostn = n[1]\n      end\n    end\n\n    if cert.issuer.to_s !~ /#{datastore['ISSUER'].source}/n\n      print_good(\"#{ip} - '#{vhostn}' : #{cert.issuer} (BAD ISSUER)\" )\n    elsif datastore['SHOWALL']\n      # show verbose as status\n      print_status(\"#{ip} - '#{vhostn}' : #{cert.issuer}\")\n    end\n\n    if ( a < 1 or b > 0 )\n      print_good(\"#{ip} - '#{vhostn}' : '\" + before.to_s + \"' - '\" + after.to_s + \"' (EXPIRED)'\")\n    elsif\n      # show verbose as status\n      print_status(\"#{ip} - '#{vhostn}' : '\" + before.to_s + \"' - '\" + after.to_s + \"'\")\n    end\n\n    report_note(\n      :host\t=> ip,\n      :port\t=> rport,\n      :proto  => 'tcp',\n      :type\t=> 'http.vhost',\n      :data\t=> {:name => vhostn}\n    ) if vhostn\n\n    # Store the SSL certificate itself\n    report_note(\n      :host\t=> ip,\n      :proto  => 'tcp',\n      :port\t=> rport,\n      :type\t=> 'ssl.certificate',\n      :data\t=> {\n        :cn        => vhostn,\n        :subject   => cert.subject.to_a,\n        :algorithm => cert.signature_algorithm\n\n      }\n    ) if vhostn\n\n    # Update the server hostname if necessary\n    if vhostn !~ /localhost|snakeoil/i\n      report_host(\n        :host => ip,\n        :name => vhostn\n      )\n    end\n\n\n  rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n  rescue ::Timeout::Error, ::Errno::EPIPE\n  rescue ::OpenSSL::SSL::SSLError => e\n    return if(e.to_s.match(/^SSL_connect /) ) # strange errors / exception if SSL connection aborted\n  rescue ::Exception => e\n    return if(e.to_s =~ /execution expired/)\n    print_error(\"Error: '#{ip}' '#{e.class}' '#{e}' '#{e.backtrace}'\")\n  end\nend\n",
    "x_mitre_contributors": [
        "nebulus",
        ""
    ]
}