{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2f1df853-5138-4987-8e7f-7e22671b4ae4",
    "created": "2024-08-14T16:21:44.51952Z",
    "modified": "2024-08-14T16:21:44.519525Z",
    "name": "Sample Auxiliary Module",
    "description": "Sample Auxiliary Module",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/example.rb",
            "external_id": "example.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n###\n#\n# This sample auxiliary module simply displays the selected action and\n# registers a custom command that will show up when the module is used.\n#\n###\nclass MetasploitModule < Msf::Auxiliary\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Sample Auxiliary Module',\n        # The description can be multiple lines, but does not preserve formatting.\n        'Description' => 'Sample Auxiliary Module',\n        'Author' => ['Joe Module <joem@example.com>'],\n        'License' => MSF_LICENSE,\n        'Actions' => [\n          [ 'Default Action', { 'Description' => 'This does something' } ],\n          [ 'Another Action', { 'Description' => 'This does a different thing' } ]\n        ],\n        # The action(s) that will run as background job\n        'PassiveActions' => [\n          'Another Action'\n        ],\n        # https://docs.metasploit.com/docs/development/developing-modules/module-metadata/definition-of-module-reliability-side-effects-and-stability.html\n        'Notes' => {\n          'Stability' => [],\n          'Reliability' => [],\n          'SideEffects' => []\n        },\n        'DefaultAction' => 'Default Action'\n      )\n    )\n  end\n\n  def run\n    print_status(\"Running the simple auxiliary module with action #{action.name}\")\n  end\n\n  # auxiliary modules can register new commands, they all call cmd_* to\n  # dispatch them\n  def auxiliary_commands\n    { 'aux_extra_command' => 'Run this auxiliary test commmand' }\n  end\n\n  def cmd_aux_extra_command(*args)\n    print_status(\"Running inside aux_extra_command(#{args.join(' ')})\")\n  end\nend\n"
}