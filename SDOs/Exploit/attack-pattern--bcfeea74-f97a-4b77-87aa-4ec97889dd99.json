{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bcfeea74-f97a-4b77-87aa-4ec97889dd99",
    "created": "2024-08-14T16:32:49.249549Z",
    "modified": "2024-08-14T16:32:49.249553Z",
    "name": "SSL Labs API Client",
    "description": " This module is a simple client for the SSL Labs APIs, designed for SSL/TLS assessment during a penetration test.  'License'       => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/ssllabs_scan.rb",
            "external_id": "ssllabs_scan.rb"
        },
        {
            "source_name": "report_bad\"OpenSSLCCSvulnerability(CVE-2014-0224)-Possiblyvulnerable",
            "external_id": "butnotexploitable\""
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'active_support/inflector'\nrequire 'json'\nrequire 'active_support/core_ext/hash'\n\nclass MetasploitModule < Msf::Auxiliary\n  class InvocationError < StandardError; end\n  class RequestRateTooHigh < StandardError; end\n  class InternalError < StandardError; end\n  class ServiceNotAvailable < StandardError; end\n  class ServiceOverloaded < StandardError; end\n\n  class Api\n    attr_reader :max_assessments, :current_assessments\n\n    def initialize\n      @max_assessments = 0\n      @current_assessments = 0\n    end\n\n    def request(name, params = {})\n      api_host = \"api.ssllabs.com\"\n      api_port = \"443\"\n      api_path = \"/api/v2/\"\n      user_agent = \"Msf_ssllabs_scan\"\n\n      name = name.to_s.camelize(:lower)\n      uri = api_path + name\n      cli = Rex::Proto::Http::Client.new(api_host, api_port, {}, true, 'TLS')\n      cli.connect\n      req = cli.request_cgi({\n          'uri' => uri,\n          'agent' => user_agent,\n          'method' => 'GET',\n          'vars_get' => params\n      })\n      res = cli.send_recv(req)\n      cli.close\n\n      if res && res.code.to_i == 200\n        @max_assessments = res.headers['X-Max-Assessments']\n        @current_assessments = res.headers['X-Current-Assessments']\n        r = JSON.load(res.body)\n        fail InvocationError, \"API returned: #{r['errors']}\" if r.key?('errors')\n        return r\n      end\n\n      case res.code.to_i\n      when 400\n        fail InvocationError\n      when 429\n        fail RequestRateTooHigh\n      when 500\n        fail InternalError\n      when 503\n        fail ServiceNotAvailable\n      when 529\n        fail ServiceOverloaded\n      else\n        fail StandardError, \"HTTP error code #{r.code}\", caller\n      end\n    end\n\n    def report_unused_attrs(type, unused_attrs)\n      unused_attrs.each do | attr |\n        # $stderr.puts \"#{type} request returned unknown parameter #{attr}\"\n      end\n    end\n\n    def info\n      obj, unused_attrs = Info.load request(:info)\n      report_unused_attrs('info', unused_attrs)\n      obj\n    end\n\n    def analyse(params = {})\n      obj, unused_attrs = Host.load request(:analyze, params)\n      report_unused_attrs('analyze', unused_attrs)\n      obj\n    end\n\n    def get_endpoint_data(params = {})\n      obj, unused_attrs = Endpoint.load request(:get_endpoint_data, params)\n      report_unused_attrs('get_endpoint_data', unused_attrs)\n      obj\n    end\n\n    def get_status_codes\n      obj, unused_attrs = StatusCodes.load request(:get_status_codes)\n      report_unused_attrs('get_status_codes', unused_attrs)\n      obj\n    end\n  end\n\n  class ApiObject\n\n    class << self;\n      attr_accessor :all_attributes\n      attr_accessor :fields\n      attr_accessor :lists\n      attr_accessor :refs\n    end\n\n    def self.inherited(base)\n      base.all_attributes = []\n      base.fields = []\n      base.lists = {}\n      base.refs = {}\n    end\n\n    def self.to_api_name(name)\n      name.to_s.gsub(/\\?$/, '').camelize(:lower)\n    end\n\n    def self.to_attr_name(name)\n      name.to_s.gsub(/\\?$/, '').underscore\n    end\n\n    def self.field_methods(name)\n      is_bool = name.to_s.end_with?('?')\n      attr_name = to_attr_name(name)\n      api_name = to_api_name(name)\n      class_eval <<-EOF, __FILE__, __LINE__\n        def #{attr_name}#{'?' if is_bool}\n          @#{api_name}\n        end\n        def #{attr_name}=(value)\n          @#{api_name} = value\n        end\n      EOF\n    end\n\n    def self.has_fields(*names)\n      names.each do |name|\n        @all_attributes << to_api_name(name)\n        @fields << to_api_name(name)\n        field_methods(name)\n      end\n    end\n\n    def self.has_objects_list(name, klass)\n      @all_attributes << to_api_name(name)\n      @lists[to_api_name(name)] = klass\n      field_methods(name)\n    end\n\n    def self.has_object_ref(name, klass)\n      @all_attributes << to_api_name(name)\n      @refs[to_api_name(name)] = klass\n      field_methods(name)\n    end\n\n    def self.load(attributes = {})\n      obj = self.new\n      unused_attrs = []\n      attributes.each do |name, value|\n        if @fields.include?(name)\n          obj.instance_variable_set(\"@#{name}\", value)\n        elsif @lists.key?(name)\n          unless value.nil?\n            var = value.map do |v|\n              val, ua = @lists[name].load(v)\n              unused_attrs.concat ua\n              val\n            end\n            obj.instance_variable_set(\"@#{name}\", var)\n          end\n        elsif @refs.key?(name)\n          unless value.nil?\n            val, ua = @refs[name].load(value)\n            unused_attrs.concat ua\n            obj.instance_variable_set(\"@#{name}\", val)\n          end\n        else\n          unused_attrs << name\n        end\n      end\n      return obj, unused_attrs\n    end\n\n    def to_json(opts = {})\n      obj = {}\n      self.class.all_attributes.each do |api_name|\n        v = instance_variable_get(\"@#{api_name}\")\n        obj[api_name] = v\n      end\n      obj.to_json\n    end\n  end\n\n  class Cert < ApiObject\n    has_fields :subject,\n               :commonNames,\n               :altNames,\n               :notBefore,\n               :notAfter,\n               :issuerSubject,\n               :sigAlg,\n               :issuerLabel,\n               :revocationInfo,\n               :crlURIs,\n               :ocspURIs,\n               :revocationStatus,\n               :crlRevocationStatus,\n               :ocspRevocationStatus,\n               :sgc?,\n               :validationType,\n               :issues,\n               :sct?,\n               :mustStaple,\n               :sha1Hash,\n               :pinSha256\n\n    def valid?\n      issues == 0\n    end\n\n    def invalid?\n      !valid?\n    end\n  end\n\n  class ChainCert < ApiObject\n    has_fields :subject,\n               :label,\n               :notBefore,\n               :notAfter,\n               :issuerSubject,\n               :issuerLabel,\n               :sigAlg,\n               :issues,\n               :keyAlg,\n               :keySize,\n               :keyStrength,\n               :revocationStatus,\n               :crlRevocationStatus,\n               :ocspRevocationStatus,\n               :raw,\n               :sha1Hash,\n               :pinSha256\n\n    def valid?\n      issues == 0\n    end\n\n    def invalid?\n      !valid?\n    end\n  end\n\n  class Chain < ApiObject\n    has_objects_list :certs, ChainCert\n    has_fields :issues\n\n    def valid?\n      issues == 0\n    end\n\n    def invalid?\n      !valid?\n    end\n  end\n\n  class Key < ApiObject\n    has_fields :size,\n               :strength,\n               :alg,\n               :debianFlaw?,\n               :q\n\n    def insecure?\n      debian_flaw? || q == 0\n    end\n\n    def secure?\n      !insecure?\n    end\n  end\n\n  class Protocol < ApiObject\n    has_fields :id,\n               :name,\n               :version,\n               :v2SuitesDisabled?,\n               :q\n\n    def insecure?\n      q == 0\n    end\n\n    def secure?\n      !insecure?\n    end\n\n  end\n\n  class Info < ApiObject\n    has_fields :engineVersion,\n               :criteriaVersion,\n               :clientMaxAssessments,\n               :maxAssessments,\n               :currentAssessments,\n               :messages,\n               :newAssessmentCoolOff\n  end\n\n  class SimClient < ApiObject\n    has_fields :id,\n               :name,\n               :platform,\n               :version,\n               :isReference?\n  end\n\n  class Simulation < ApiObject\n    has_object_ref :client, SimClient\n    has_fields :errorCode,\n               :attempts,\n               :protocolId,\n               :suiteId,\n               :kxInfo\n\n    def success?\n      error_code == 0\n    end\n\n    def error?\n      !success?\n    end\n  end\n\n  class SimDetails < ApiObject\n    has_objects_list :results, Simulation\n  end\n\n  class StatusCodes < ApiObject\n    has_fields :statusDetails\n\n    def [](name)\n      status_details[name]\n    end\n  end\n\n  class Suite < ApiObject\n    has_fields :id,\n               :name,\n               :cipherStrength,\n               :dhStrength,\n               :dhP,\n               :dhG,\n               :dhYs,\n               :ecdhBits,\n               :ecdhStrength,\n               :q\n\n    def insecure?\n      q == 0\n    end\n\n    def secure?\n      !insecure?\n    end\n  end\n\n  class Suites < ApiObject\n    has_objects_list :list, Suite\n    has_fields :preference?\n  end\n\n  class EndpointDetails < ApiObject\n    has_fields :hostStartTime\n    has_object_ref :key, Key\n    has_object_ref :cert, Cert\n    has_object_ref :chain, Chain\n    has_objects_list :protocols, Protocol\n    has_object_ref :suites, Suites\n    has_fields :serverSignature,\n               :prefixDelegation?,\n               :nonPrefixDelegation?,\n               :vulnBeast?,\n               :renegSupport,\n               :stsResponseHeader,\n               :stsMaxAge,\n               :stsSubdomains?,\n               :pkpResponseHeader,\n               :sessionResumption,\n               :compressionMethods,\n               :supportsNpn?,\n               :npnProtocols,\n               :sessionTickets,\n               :ocspStapling?,\n               :staplingRevocationStatus,\n               :staplingRevocationErrorMessage,\n               :sniRequired?,\n               :httpStatusCode,\n               :httpForwarding,\n               :supportsRc4?,\n               :forwardSecrecy,\n               :rc4WithModern?\n    has_object_ref :sims, SimDetails\n    has_fields :heartbleed?,\n               :heartbeat?,\n               :openSslCcs,\n               :poodle?,\n               :poodleTls,\n               :fallbackScsv?,\n               :freak?,\n               :hasSct,\n               :stsStatus,\n               :stsPreload,\n               :supportsAlpn,\n               :rc4Only,\n               :protocolIntolerance,\n               :miscIntolerance,\n               :openSSLLuckyMinus20,\n               :logjam,\n               :chaCha20Preference,\n               :hstsPolicy,\n               :hstsPreloads,\n               :hpkpPolicy,\n               :hpkpRoPolicy,\n               :drownHosts,\n               :drownErrors,\n               :drownVulnerable\n  end\n\n  class Endpoint < ApiObject\n    has_fields :ipAddress,\n               :serverName,\n               :statusMessage,\n               :statusDetails,\n               :statusDetailsMessage,\n               :grade,\n               :gradeTrustIgnored,\n               :hasWarnings?,\n               :isExceptional?,\n               :progress,\n               :duration,\n               :eta,\n               :delegation\n    has_object_ref :details, EndpointDetails\n  end\n\n  class Host < ApiObject\n    has_fields :host,\n               :port,\n               :protocol,\n               :isPublic?,\n               :status,\n               :statusMessage,\n               :startTime,\n               :testTime,\n               :engineVersion,\n               :criteriaVersion,\n               :cacheExpiryTime\n    has_objects_list :endpoints, Endpoint\n    has_fields :certHostnames\n  end\n\n  def initialize(info = {})\n    super(update_info(info,\n        'Name'          => 'SSL Labs API Client',\n        'Description'   => %q{\n          This module is a simple client for the SSL Labs APIs, designed for\n          SSL/TLS assessment during a penetration test.\n        },\n        'License'       => MSF_LICENSE,\n        'Author'        =>\n          [\n            'Denis Kolegov <dnkolegov[at]gmail.com>',\n            'Francois Chagnon' # ssllab.rb author (https://github.com/Shopify/ssllabs.rb)\n           ],\n        'DefaultOptions' =>\n          {\n            'RPORT'      => 443,\n            'SSL'        => true,\n          }\n    ))\n    register_options(\n      [\n        OptString.new('HOSTNAME', [true, 'The target hostname']),\n        OptInt.new('DELAY', [true, 'The delay in seconds between  API requests', 5]),\n        OptBool.new('USECACHE', [true, 'Use cached results (if available), else force live scan', true]),\n        OptBool.new('GRADE', [true, 'Output only the hostname: grade', false]),\n        OptBool.new('IGNOREMISMATCH', [true, 'Proceed with assessments even when the server certificate doesn\\'t match the assessment hostname', true])\n      ])\n  end\n\n  def report_good(line)\n    print_good line\n  end\n\n  def report_warning(line)\n    print_warning line\n  end\n\n  def report_bad(line)\n    print_warning line\n  end\n\n  def report_status(line)\n    print_status line\n  end\n\n  def output_endpoint_data(r)\n    ssl_protocols = [\n      { id: 771, name: \"TLS\", version: \"1.2\", secure: true, active: false },\n      { id: 770, name: \"TLS\", version: \"1.1\", secure: true, active: false },\n      { id: 769, name: \"TLS\", version: \"1.0\", secure: true, active: false },\n      { id: 768, name: \"SSL\", version: \"3.0\", secure: false, active: false },\n      { id: 2, name: \"SSL\", version: \"2.0\", secure: false, active: false }\n    ]\n\n    report_status \"-----------------------------------------------------------------\"\n    report_status \"Report for #{r.server_name} (#{r.ip_address})\"\n    report_status \"-----------------------------------------------------------------\"\n\n    case r.grade.to_s\n    when \"A+\", \"A\", \"A-\"\n      report_good \"Overall rating: #{r.grade}\"\n    when \"B\"\n      report_warning \"Overall rating: #{r.grade}\"\n    when \"C\", \"D\", \"E\", \"F\"\n      report_bad \"Overall rating: #{r.grade}\"\n    when \"M\"\n      report_bad \"Overall rating: #{r.grade} - Certificate name mismatch\"\n    when \"T\"\n      report_bad \"Overall rating: #{r.grade} - Server's certificate is not trusted\"\n    end\n\n    report_warning \"Grade is #{r.grade_trust_ignored}, if trust issues are ignored)\" if r.grade.to_s != r.grade_trust_ignored.to_s\n\n    # Supported protocols\n    r.details.protocols.each do |i|\n      p = ssl_protocols.detect { |x| x[:id] == i.id }\n      p.store(:active, true) if p\n    end\n\n    ssl_protocols.each do |proto|\n      if proto[:active]\n        if proto[:secure]\n          report_good \"#{proto[:name]} #{proto[:version]} - Yes\"\n        else\n          report_bad \"#{proto[:name]} #{proto[:version]} - Yes\"\n        end\n      else\n        report_good \"#{proto[:name]} #{proto[:version]} - No\"\n      end\n    end\n\n    # Renegotioation\n    case\n    when r.details.reneg_support == 0\n      report_warning \"Secure renegotiation is not supported\"\n    when r.details.reneg_support[0] == 1\n      report_bad \"Insecure client-initiated renegotiation is supported\"\n    when r.details.reneg_support[1] == 1\n      report_good \"Secure renegotiation is supported\"\n    when r.details.reneg_support[2] == 1\n      report_warning \"Secure client-initiated renegotiation is supported\"\n    when r.details.reneg_support[3] == 1\n      report_warning \"Server requires secure renegotiation support\"\n    end\n\n    # BEAST\n    if r.details.vuln_beast?\n      report_bad \"BEAST attack - Yes\"\n    else\n      report_good \"BEAST attack - No\"\n    end\n\n    # POODLE (SSLv3)\n    if r.details.poodle?\n      report_bad \"POODLE SSLv3 - Vulnerable\"\n    else\n      report_good \"POODLE SSLv3 - Not vulnerable\"\n    end\n\n    # POODLE TLS\n    case r.details.poodle_tls\n    when -1\n      report_warning \"POODLE TLS - Test failed\"\n    when 0\n      report_warning \"POODLE TLS - Unknown\"\n    when 1\n      report_good \"POODLE TLS - Not vulnerable\"\n    when 2\n      report_bad \"POODLE TLS - Vulnerable\"\n    end\n\n    # Downgrade attack prevention\n    if r.details.fallback_scsv?\n      report_good \"Downgrade attack prevention - Yes, TLS_FALLBACK_SCSV supported\"\n    else\n      report_bad \"Downgrade attack prevention - No, TLS_FALLBACK_SCSV not supported\"\n    end\n\n    # Freak\n    if r.details.freak?\n      report_bad \"Freak - Vulnerable\"\n    else\n      report_good \"Freak - Not vulnerable\"\n    end\n\n    # RC4\n    if r.details.supports_rc4?\n      report_warning \"RC4 - Server supports at least one RC4 suite\"\n    else\n      report_good \"RC4 - No\"\n    end\n\n    # RC4 with modern browsers\n    report_warning \"RC4 is used with modern clients\" if r.details.rc4_with_modern?\n\n    # Heartbeat\n    if r.details.heartbeat?\n      report_status \"Heartbeat (extension) - Yes\"\n    else\n      report_status \"Heartbeat (extension) - No\"\n    end\n\n    # Heartbleed\n    if r.details.heartbleed?\n      report_bad \"Heartbleed (vulnerability) - Yes\"\n    else\n      report_good \"Heartbleed (vulnerability) - No\"\n    end\n\n    # OpenSSL CCS\n    case r.details.open_ssl_ccs\n    when -1\n      report_warning \"OpenSSL CCS vulnerability (CVE-2014-0224) - Test failed\"\n    when 0\n      report_warning \"OpenSSL CCS vulnerability (CVE-2014-0224) - Unknown\"\n    when 1\n      report_good \"OpenSSL CCS vulnerability (CVE-2014-0224) - No\"\n    when 2\n      report_bad \"OpenSSL CCS vulnerability (CVE-2014-0224) - Possibly vulnerable, but not exploitable\"\n    when 3\n      report_bad \"OpenSSL CCS vulnerability (CVE-2014-0224) - Vulnerable and exploitable\"\n    end\n\n    # Forward Secrecy\n    case\n    when r.details.forward_secrecy == 0\n      report_bad \"Forward Secrecy - No\"\n    when r.details.forward_secrecy[0] == 1\n      report_bad \"Forward Secrecy - With some browsers\"\n    when r.details.forward_secrecy[1] == 1\n      report_good \"Forward Secrecy - With modern browsers\"\n    when r.details.forward_secrecy[2] == 1\n      report_good \"Forward Secrecy - Yes (with most browsers)\"\n    end\n\n    # HSTS\n    if r.details.sts_response_header\n      str = \"Strict Transport Security (HSTS) - Yes\"\n      if r.details.sts_max_age && r.details.sts_max_age != -1\n        str += \":max-age=#{r.details.sts_max_age}\"\n      end\n      str += \":includeSubdomains\" if r.details.sts_subdomains?\n      report_good str\n    else\n      report_bad \"Strict Transport Security (HSTS) - No\"\n    end\n\n    # HPKP\n    if r.details.pkp_response_header\n      report_good \"Public Key Pinning (HPKP) - Yes\"\n    else\n      report_warning \"Public Key Pinning (HPKP) - No\"\n    end\n\n    # Compression\n    if r.details.compression_methods == 0\n      report_good \"Compression - No\"\n    elsif (r.details.session_tickets & 1) != 0\n      report_warning \"Compression - Yes (Deflate)\"\n    end\n\n    # Session Resumption\n    case r.details.session_resumption\n    when 0\n      print_status \"Session resumption - No\"\n    when 1\n      report_warning \"Session resumption - No (IDs assigned but not accepted)\"\n    when 2\n      print_status \"Session resumption - Yes\"\n    end\n\n    # Session Tickets\n    case\n    when r.details.session_tickets == 0\n      print_status \"Session tickets - No\"\n    when r.details.session_tickets[0] == 1\n      print_status \"Session tickets - Yes\"\n    when r.details.session_tickets[1] == 1\n      report_good \"Session tickets - Implementation is faulty\"\n    when r.details.session_tickets[2] == 1\n      report_warning \"Session tickets - Server is intolerant to the extension\"\n    end\n\n    # OCSP stapling\n    if r.details.ocsp_stapling?\n      print_status \"OCSP Stapling - Yes\"\n    else\n      print_status \"OCSP Stapling - No\"\n    end\n\n    # NPN\n    if r.details.supports_npn?\n      print_status \"Next Protocol Negotiation (NPN) - Yes (#{r.details.npn_protocols})\"\n    else\n      print_status \"Next Protocol Negotiation (NPN) - No\"\n    end\n\n    # SNI\n    print_status \"SNI Required - Yes\" if r.details.sni_required?\n  end\n\n  def output_grades_only(r)\n    r.endpoints.each do |e|\n      if e.status_message == \"Ready\"\n        print_status \"Server: #{e.server_name} (#{e.ip_address}) - Grade:#{e.grade}\"\n      else\n        print_status \"Server: #{e.server_name} (#{e.ip_address} - Status:#{e.status_message}\"\n      end\n    end\n  end\n\n  def output_common_info(r)\n    return unless r\n    print_status \"Host: #{r.host}\"\n\n    r.endpoints.each do |e|\n      print_status \"\\t  #{e.ip_address}\"\n    end\n  end\n\n  def output_result(r, grade)\n    return unless r\n    output_common_info(r)\n    if grade\n      output_grades_only(r)\n    else\n      r.endpoints.each do |e|\n        if e.status_message == \"Ready\"\n          output_endpoint_data(e)\n        else\n          print_status \"#{e.status_message}\"\n        end\n      end\n    end\n  end\n\n  def output_testing_details(r)\n    return unless r.status == \"IN_PROGRESS\"\n\n    if r.endpoints.length == 1\n      print_status \"#{r.host} (#{r.endpoints[0].ip_address}) - Progress #{[r.endpoints[0].progress, 0].max}% (#{r.endpoints[0].status_details_message})\"\n    elsif r.endpoints.length > 1\n      in_progress_srv_num = 0\n      ready_srv_num = 0\n      pending_srv_num = 0\n      r.endpoints.each do |e|\n        case e.status_message.to_s\n        when \"In progress\"\n          in_progress_srv_num += 1\n          print_status \"Scanned host: #{e.ip_address} (#{e.server_name})- #{[e.progress, 0].max}% complete (#{e.status_details_message})\"\n        when \"Pending\"\n          pending_srv_num += 1\n        when \"Ready\"\n          ready_srv_num += 1\n        end\n      end\n      progress = ((ready_srv_num.to_f / (pending_srv_num + in_progress_srv_num + ready_srv_num)) * 100.0).round(0)\n      print_status \"Ready: #{ready_srv_num}, In progress: #{in_progress_srv_num}, Pending: #{pending_srv_num}\"\n      print_status \"#{r.host} - Progress #{progress}%\"\n    end\n  end\n\n  def valid_hostname?(hostname)\n    hostname =~ /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/\n  end\n\n  def run\n    delay = datastore['DELAY']\n    hostname = datastore['HOSTNAME']\n    unless valid_hostname?(hostname)\n      print_status \"Invalid hostname\"\n      return\n    end\n\n    usecache = datastore['USECACHE']\n    grade = datastore['GRADE']\n\n    # Use cached results\n    if usecache\n      from_cache = 'on'\n      start_new = 'off'\n    else\n      from_cache = 'off'\n      start_new = 'on'\n    end\n\n    # Ignore mismatch\n    ignore_mismatch = datastore['IGNOREMISMATCH'] ? 'on' : 'off'\n\n    api = Api.new\n    info = api.info\n    print_status \"SSL Labs API info\"\n    print_status \"API version: #{info.engine_version}\"\n    print_status \"Evaluation criteria: #{info.criteria_version}\"\n    print_status \"Running assessments: #{info.current_assessments} (max #{info.max_assessments})\"\n\n    if api.current_assessments >= api.max_assessments\n      print_status \"Too many active assessments\"\n      return\n    end\n\n    if usecache\n      r = api.analyse(host: hostname, fromCache: from_cache, ignoreMismatch: ignore_mismatch, all: 'done')\n    else\n      r = api.analyse(host: hostname, startNew: start_new, ignoreMismatch: ignore_mismatch, all: 'done')\n    end\n\n    loop do\n      case r.status\n      when \"DNS\"\n        print_status \"Server: #{r.host} - #{r.status_message}\"\n      when \"IN_PROGRESS\"\n        output_testing_details(r)\n      when \"READY\"\n        output_result(r, grade)\n        return\n      when \"ERROR\"\n        print_error \"#{r.status_message}\"\n        return\n      else\n        print_error \"Unknown assessment status\"\n        return\n      end\n      sleep delay\n      r = api.analyse(host: hostname, all: 'done')\n    end\n\n    rescue RequestRateTooHigh\n      print_error \"Request rate is too high, please slow down\"\n    rescue InternalError\n      print_error \"Service encountered an error, sleep 5 minutes\"\n    rescue ServiceNotAvailable\n      print_error \"Service is not available, sleep 15 minutes\"\n    rescue ServiceOverloaded\n      print_error \"Service is overloaded, sleep 30 minutes\"\n    rescue\n      print_error \"Invalid parameters\"\n  end\nend\n"
}