{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--64e4c770-52e3-4b46-bf2e-8721e71bb454",
    "created": "2024-08-14T16:30:28.500573Z",
    "modified": "2024-08-14T16:30:28.500577Z",
    "name": "HTTP Previous Directory File Scanner",
    "description": " This module identifies files in the first parent directory with same name as the given directory path. Example: Test /backup/files/ will look for the following files /backup/files.ext . ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/prev_dir_same_name_file.rb",
            "external_id": "prev_dir_same_name_file.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::WmapScanDir\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'   \t\t=> 'HTTP Previous Directory File Scanner',\n      'Description'\t=> %q{\n        This module identifies files in the first parent directory with same name as\n        the given directory path. Example: Test /backup/files/ will look for the\n        following files /backup/files.ext .\n      },\n      'Author' \t\t=> [ 'et [at] metasploit.com' ],\n      'License'\t\t=> BSD_LICENSE))\n\n    register_options(\n      [\n        OptString.new('PATH', [ true,  \"The test path. The default value will not work.\", '/']),\n        OptString.new('EXT', [ true,  \"Extension to include.\", '.aspx']),\n      ])\n\n  end\n\n  def run_host(ip)\n    extensions = [\n      '.null',\n      '.backup',\n      '.bak',\n      '.c',\n      '.class',\n      '.copy',\n      '.conf',\n      '.exe',\n      '.html',\n      '.htm',\n      '.jar',\n      '.log',\n      '.old',\n      '.orig',\n      '.o',\n      '.php',\n      '.tar',\n      '.tar.gz',\n      '.tgz',\n      '.temp',\n      '.tmp',\n      '.txt',\n      '.zip',\n      '~'\n    ]\n\n    tpath = normalize_uri(datastore['PATH'])\n\n    if tpath.eql? \"/\"||\"\"\n      print_error(\"Blank or default PATH set.\");\n      return\n    end\n\n    if tpath[-1,1] != '/'\n      tpath += '/'\n    end\n\n    extensions << datastore['EXT']\n\n    extensions.each { |ext|\n      begin\n        testf = tpath.chop+ext\n\n        res = send_request_cgi({\n          'uri'  \t\t=>  testf,\n          'method'   \t=> 'GET',\n          'ctype'\t\t=> 'text/plain'\n        }, 20)\n\n        if (res and res.code >= 200 and res.code < 300)\n          print_good(\"Found #{wmap_base_url}#{testf}\")\n\n          report_web_vuln(\n            :host\t=> ip,\n            :port\t=> rport,\n            :vhost  => vhost,\n            :ssl    => ssl,\n            :path\t=> testf,\n            :method => 'GET',\n            :pname  => \"\",\n            :proof  => \"Res code: #{res.code.to_s}\",\n            :risk   => 0,\n            :confidence   => 100,\n            :category     => 'file',\n            :description  => 'File found.',\n            :name   => 'file'\n          )\n\n        else\n          vprint_status(\"NOT Found #{wmap_base_url}#{testf}\")\n        end\n\n      rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      rescue ::Timeout::Error, ::Errno::EPIPE\n      end\n\n    }\n\n  end\nend\n"
}