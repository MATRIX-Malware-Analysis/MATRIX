{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--be658663-004e-46f3-a12a-8466d53ba631",
    "created": "2024-08-14T16:33:19.152904Z",
    "modified": "2024-08-14T16:33:19.152908Z",
    "name": "Sudo Commands",
    "description": " This module examines the sudoers configuration for the session user and lists the commands executable via sudo.  This module also inspects each command and reports potential avenues for privileged code execution due to poor file system permissions or permitting execution of executables known to be useful for privesc such as utilities designed for file read/write, user modification or execution of arbitrary operating system commands.  Note, you may need to provide the password for the session user.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/recon/sudo_commands.rb",
            "external_id": "sudo_commands.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n\n  include Msf::Post::File\n  include Msf::Post::Linux::Priv\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Sudo Commands',\n        'Description' => %q{\n          This module examines the sudoers configuration for the session user\n          and lists the commands executable via sudo.\n\n          This module also inspects each command and reports potential avenues\n          for privileged code execution due to poor file system permissions or\n          permitting execution of executables known to be useful for privesc,\n          such as utilities designed for file read/write, user modification,\n          or execution of arbitrary operating system commands.\n\n          Note, you may need to provide the password for the session user.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'bcoles' ],\n        'Platform' => [ 'bsd', 'linux', 'osx', 'solaris', 'unix' ],\n        'SessionTypes' => [ 'meterpreter', 'shell' ]\n      )\n    )\n    register_options [\n      OptString.new('SUDO_PATH', [ true, 'Path to sudo executable', '/usr/bin/sudo' ]),\n      OptString.new('PASSWORD', [ false, 'Password for the current user', '' ])\n    ]\n  end\n\n  def sudo_path\n    datastore['SUDO_PATH'].to_s\n  end\n\n  def password\n    datastore['PASSWORD'].to_s\n  end\n\n  def eop_bins\n    %w[\n      cat chgrp chmod chown cp echo find less ln mkdir more mv tail tar\n      usermod useradd userdel\n      env crontab\n      awk gdb gawk lua irb ld node perl php python python2 python3 ruby tclsh wish\n      ncat netcat netcat.traditional nc nc.traditional openssl socat telnet telnetd\n      ash bash csh dash ksh sh zsh\n      su sudo\n      expect ionice nice script setarch strace taskset time\n      wget curl ftp scp sftp ssh tftp\n      nmap\n      ed emacs man nano vi vim visudo\n      dpkg rpm rpmquery\n    ]\n  end\n\n  #\n  # Check if a sudo command offers prvileged code execution\n  #\n  def check_eop(cmd)\n    # drop args for simplicity (at the risk of false positives)\n    cmd = cmd.split(/\\s/).first\n\n    if cmd.eql? 'ALL'\n      print_good 'sudo any command!'\n      return true\n    end\n\n    base_dir = File.dirname cmd\n    base_name = File.basename cmd\n\n    if file_exist? cmd\n      if writable? cmd\n        print_good \"#{cmd} is writable!\"\n        return true\n      end\n    elsif writable? base_dir\n      print_good \"#{cmd} does not exist and #{base_dir} is writable!\"\n      return true\n    end\n\n    if eop_bins.include? base_name\n      print_good \"#{cmd} matches known privesc executable '#{base_name}' !\"\n      return true\n    end\n\n    false\n  end\n\n  #\n  # Retrieve list of sudo commands for current session user\n  #\n  def sudo_list\n    # try non-interactive (-n) without providing a password\n    cmd = \"#{sudo_path} -n -l\"\n    vprint_status \"Executing: #{cmd}\"\n    output = cmd_exec(cmd).to_s\n\n    if output.start_with?('usage:') || output.include?('illegal option') || output.include?('a password is required')\n      # try with a password from stdin (-S)\n      cmd = \"echo #{password} | #{sudo_path} -S -l\"\n      vprint_status \"Executing: #{cmd}\"\n      output = cmd_exec(cmd).to_s\n    end\n\n    output\n  end\n\n  #\n  # Format sudo output and extract permitted commands\n  #\n  def parse_sudo(sudo_data)\n    cmd_data = sudo_data.scan(/may run the following commands.*?$(.*)\\z/m).flatten.first\n\n    # remove leading whitespace from each line and remove linewraps\n    formatted_data = ''\n    cmd_data.split(\"\\n\").reject { |line| line.eql?('') }.each do |line|\n      formatted_line = line.gsub(/^\\s*/, '').to_s\n      if formatted_line.start_with? '('\n        formatted_data << \"\\n#{formatted_line}\"\n      else\n        formatted_data << \" #{formatted_line}\"\n      end\n    end\n\n    formatted_data.split(\"\\n\").reject { |line| line.eql?('') }.each do |line|\n      run_as = line.scan(/^\\((.+?)\\)/).flatten.first\n\n      if run_as.blank?\n        print_warning \"Could not parse sudoers entry: #{line.inspect}\"\n        next\n      end\n\n      user = run_as.split(':')[0].to_s.strip || ''\n      group = run_as.split(':')[1].to_s.strip || ''\n      no_passwd = false\n\n      cmds = line.scan(/^\\(.+?\\) (.+)$/).flatten.first\n      if cmds.start_with? 'NOPASSWD:'\n        no_passwd = true\n        cmds = cmds.gsub(/^NOPASSWD:\\s*/, '')\n      end\n\n      # Commands are separated by commas but may also contain commas (escaped with a backslash)\n      # so we temporarily replace escaped commas with some junk\n      # later, we'll replace each instance of the junk with a comma\n      junk = Rex::Text.rand_text_alpha(10)\n      cmds = cmds.gsub('\\, ', junk)\n\n      cmds.split(', ').each do |cmd|\n        cmd = cmd.gsub(junk, ', ').strip\n\n        if cmd.start_with? '('\n          run_as = cmd.scan(/^\\((.+?)\\)/).flatten.first\n\n          if run_as.blank?\n            print_warning \"Could not parse sudo command: #{cmd.inspect}\"\n            next\n          end\n\n          user = run_as.split(':')[0].to_s.strip || ''\n          group = run_as.split(':')[1].to_s.strip || ''\n          cmd = cmd.scan(/^\\(.+?\\) (.+)$/).flatten.first\n        end\n\n        msg = \"Command: #{cmd.inspect}\"\n        msg << \" RunAsUsers: #{user}\" unless user.eql? ''\n        msg << \" RunAsGroups: #{group}\" unless group.eql? ''\n        msg << ' without providing a password' if no_passwd\n        vprint_status msg\n\n        eop = check_eop cmd\n\n        @results << [cmd, user, group, no_passwd ? '' : 'True', eop ? 'True' : '']\n      end\n    end\n  rescue StandardError => e\n    print_error \"Could not parse sudo output: #{e.message}\"\n  end\n\n  def run\n    if is_root?\n      fail_with Failure::BadConfig, 'Session already has root privileges'\n    end\n\n    unless executable? sudo_path\n      print_error 'Could not find sudo executable'\n      return\n    end\n\n    output = sudo_list\n    vprint_line output\n    vprint_line\n\n    if output.include? 'Sorry, try again'\n      fail_with Failure::NoAccess, 'Incorrect password'\n    end\n\n    if output =~ /^Sorry, .* may not run sudo/\n      fail_with Failure::NoAccess, 'Session user is not permitted to execute any commands with sudo'\n    end\n\n    if output !~ /may run the following commands/\n      fail_with Failure::NoAccess, 'Incorrect password, or the session user is not permitted to execute any commands with sudo'\n    end\n\n    @results = Rex::Text::Table.new(\n      'Header' => 'Sudo Commands',\n      'Indent' => 2,\n      'Columns' =>\n        [\n          'Command',\n          'RunAsUsers',\n          'RunAsGroups',\n          'Password?',\n          'Privesc?'\n        ]\n    )\n\n    parse_sudo output\n\n    if @results.rows.empty?\n      print_status 'Found no sudo commands for the session user'\n      return\n    end\n\n    print_line\n    print_line @results.to_s\n\n    path = store_loot(\n      'sudo.commands',\n      'text/csv',\n      session,\n      @results.to_csv,\n      'sudo.commands.txt',\n      'Sudo Commands'\n    )\n\n    print_good \"Output stored in: #{path}\"\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'bsd', 'linux', 'osx', 'solaris', 'unix' ]"
    ]
}