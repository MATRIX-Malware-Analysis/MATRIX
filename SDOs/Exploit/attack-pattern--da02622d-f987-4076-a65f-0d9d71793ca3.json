{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--da02622d-f987-4076-a65f-0d9d71793ca3",
    "created": "2024-08-14T16:32:59.447681Z",
    "modified": "2024-08-14T16:32:59.447684Z",
    "name": "Get the Vehicle Information Such as the VIN from the Target Module",
    "description": " Post Module to query DTCs, Some common engine info and Vehicle Info. It returns such things as engine speed, coolant temp, Diagnostic Trouble Codes as well as All info stored by Mode $09 Vehicle Info, VIN, etc  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/hardware/automotive/getvinfo.rb",
            "external_id": "getvinfo.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Hardware::Automotive::UDS\n  include Msf::Post::Hardware::Automotive::DTC\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Get the Vehicle Information Such as the VIN from the Target Module',\n        'Description' => %q{\n          Post Module to query DTCs, Some common engine info and Vehicle Info.\n          It returns such things as engine speed, coolant temp, Diagnostic\n          Trouble Codes as well as All info stored by Mode $09 Vehicle Info, VIN, etc\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['Craig Smith'],\n        'Platform' => ['hardware'],\n        'SessionTypes' => ['hwbridge']\n      )\n    )\n    register_options([\n      OptInt.new('SRCID', [true, 'Module ID to query', 0x7e0]),\n      OptInt.new('DSTID', [false, 'Expected reponse ID, defaults to SRCID + 8', 0x7e8]),\n      OptInt.new('PADDING', [false, 'Optinal end of packet padding', nil]),\n      OptBool.new('FC', [false, 'Optinal forces flow control', nil]),\n      OptBool.new('CLEAR_DTCS', [false, 'Clear any DTCs and reset MIL if errors are present', false]),\n      OptString.new('CANBUS', [false, 'CAN Bus to perform scan on, defaults to connected bus', nil])\n    ])\n  end\n\n  def run\n    opt = {}\n    opt['PADDING'] = datastore['PADDING'] if datastore['PADDING']\n    opt['FC'] = datastore['FC'] if datastore['FC']\n    pids = get_current_data_pids(datastore['CANBUS'], datastore['SRCID'], datastore['DSTID'], opt)\n    if pids.empty?\n      print_status('No reported PIDs. You may not be properly connected')\n    else\n      print_status(\"Available PIDS for pulling realtime data: #{pids.size} pids\")\n      print_status(\"  #{pids.inspect}\")\n    end\n    if pids.include? 1\n      data = get_monitor_status(datastore['CANBUS'], datastore['SRCID'], datastore['DSTID'], opt)\n      print_status(\"  MIL (Engine Light) : #{data['MIL'] ? 'ON' : 'OFF'}\") if data.key? 'MIL'\n      print_status(\"  Number of DTCs: #{data['DTC_COUNT']}\") if data.key? 'DTC_COUNT'\n    end\n    if pids.include? 5\n      data = get_engine_coolant_temp(datastore['CANBUS'], datastore['SRCID'], datastore['DSTID'], opt)\n      print_status(\"  Engine Temp: #{data['TEMP_C']} \\u00b0C / #{data['TEMP_F']} \\u00b0F\") if data.key? 'TEMP_C'\n    end\n    if pids.include? 0x0C\n      data = get_rpms(datastore['CANBUS'], datastore['SRCID'], datastore['DSTID'], opt)\n      print_status(\"  RPMS: #{data['RPM']}\") if data.key? 'RPM'\n    end\n    if pids.include? 0x0D\n      data = get_vehicle_speed(datastore['CANBUS'], datastore['SRCID'], datastore['DSTID'], opt)\n      print_status(\"  Speed: #{data['SPEED_K']} km/h  /  #{data['SPEED_M']} mph\") if data.key? 'SPEED_K'\n    end\n    if pids.include? 0x1C\n      print_status(\"Supported OBD Standards: #{get_obd_standards(datastore['CANBUS'], datastore['SRCID'], datastore['DSTID'], opt)}\")\n    end\n    dtcs = get_dtcs(datastore['CANBUS'], datastore['SRCID'], datastore['DSTID'], opt)\n    unless dtcs.empty?\n      print_status('DTCS:')\n      dtcs.each do |dtc|\n        msg = dtc\n        msg += \": #{DTC_CODES[dtc]}\" if DTC_CODES.key? dtc\n        print_status(\"  #{msg}\")\n      end\n    end\n    frozen_dtcs = get_frozen_dtcs(datastore['CANBUS'], datastore['SRCID'], datastore['DSTID'], opt)\n    unless frozen_dtcs.empty?\n      print_status('Frozen DTCS:')\n      frozen_dtcs.each do |dtc|\n        msg = dtc\n        msg += \": #{DTC_CODES[dtc]}\" if DTC_CODES.key? dtc\n        print_status(\"  #{msg}\")\n      end\n    end\n    pids = get_vinfo_supported_pids(datastore['CANBUS'], datastore['SRCID'], datastore['DSTID'], opt)\n    print_status(\"Mode $09 Vehicle Info Supported PIDS: #{pids.inspect}\") if !pids.empty?\n    pids.each do |pid|\n      # Handle known pids\n      if pid == 2\n        vin = get_vin(datastore['CANBUS'], datastore['SRCID'], datastore['DSTID'], opt)\n        print_status(\"VIN: #{vin}\")\n      elsif pid == 4\n        calid = get_calibration_id(datastore['CANBUS'], datastore['SRCID'], datastore['DSTID'], opt)\n        print_status(\"Calibration ID: #{calid}\")\n      elsif pid == 0x0A\n        ecuname = get_ecu_name(datastore['CANBUS'], datastore['SRCID'], datastore['DSTID'], opt)\n        print_status(\"ECU Name: #{ecuname}\")\n      else\n        data = get_vehicle_info(datastore['CANBUS'], datastore['SRCID'], datastore['DSTID'], pid, opt)\n        data = response_hash_to_data_array(datastore['DSTID'].to_s(16), data)\n        print_status(\"PID #{pid} Response: #{data.inspect}\")\n      end\n    end\n    if datastore['CLEAR_DTCS'] == true\n      clear_dtcs(datastore['CANBUS'], datastore['SRCID'], datastore['DSTID'], opt)\n      print_status('Cleared DTCs and reseting MIL')\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "['hardware']"
    ]
}